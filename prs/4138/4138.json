{
  "repo": "duckdb/duckdb",
  "pull_number": 4138,
  "instance_id": "duckdb__duckdb-4138",
  "issue_numbers": [
    "4114"
  ],
  "base_commit": "2c623978d700443665d519282ee52891e4573a3d",
  "patch": "diff --git a/src/planner/bind_context.cpp b/src/planner/bind_context.cpp\nindex 2518adfa3b4e..e032a63e969a 100644\n--- a/src/planner/bind_context.cpp\n+++ b/src/planner/bind_context.cpp\n@@ -1,20 +1,18 @@\n #include \"duckdb/planner/bind_context.hpp\"\n \n+#include \"duckdb/catalog/catalog_entry/table_column_type.hpp\"\n+#include \"duckdb/catalog/standard_entry.hpp\"\n+#include \"duckdb/common/pair.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/parser/expression/columnref_expression.hpp\"\n+#include \"duckdb/parser/expression/operator_expression.hpp\"\n #include \"duckdb/parser/expression/positional_reference_expression.hpp\"\n+#include \"duckdb/parser/expression/star_expression.hpp\"\n+#include \"duckdb/parser/parsed_expression_iterator.hpp\"\n #include \"duckdb/parser/tableref/subqueryref.hpp\"\n #include \"duckdb/parser/tableref/table_function_ref.hpp\"\n-#include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n #include \"duckdb/planner/bound_query_node.hpp\"\n-\n-#include \"duckdb/parser/expression/operator_expression.hpp\"\n-#include \"duckdb/parser/expression/star_expression.hpp\"\n-#include \"duckdb/parser/parsed_expression_iterator.hpp\"\n-\n-#include \"duckdb/common/string_util.hpp\"\n-#include \"duckdb/common/pair.hpp\"\n-#include \"duckdb/catalog/catalog_entry/table_column_type.hpp\"\n-#include \"duckdb/catalog/standard_entry.hpp\"\n+#include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n \n #include <algorithm>\n \n@@ -357,16 +355,45 @@ void BindContext::GenerateAllColumnExpressions(StarExpression &expr,\n \t\t}\n \t} else {\n \t\t// SELECT tbl.* case\n+\t\t// SELECT struct.* case\n \t\tstring error;\n \t\tauto binding = GetBinding(expr.relation_name, error);\n+\t\tbool is_struct_ref = false;\n \t\tif (!binding) {\n-\t\t\tthrow BinderException(error);\n+\t\t\tauto binding_name = GetMatchingBinding(expr.relation_name);\n+\t\t\tif (binding_name.empty()) {\n+\t\t\t\tthrow BinderException(error);\n+\t\t\t}\n+\t\t\tbinding = bindings[binding_name].get();\n+\t\t\tis_struct_ref = true;\n \t\t}\n-\t\tfor (auto &column_name : binding->names) {\n-\t\t\tif (CheckExclusionList(expr, binding, column_name, new_select_list, excluded_columns)) {\n-\t\t\t\tcontinue;\n+\n+\t\tif (is_struct_ref) {\n+\t\t\tauto col_idx = binding->GetBindingIndex(expr.relation_name);\n+\t\t\tauto col_type = binding->types[col_idx];\n+\t\t\tif (col_type.id() != LogicalTypeId::STRUCT) {\n+\t\t\t\tthrow BinderException(StringUtil::Format(\n+\t\t\t\t    \"Cannot extract field from expression \\\"%s\\\" because it is not a struct\", expr.ToString()));\n+\t\t\t}\n+\t\t\tauto &struct_children = StructType::GetChildTypes(col_type);\n+\t\t\tvector<string> column_names(3);\n+\t\t\tcolumn_names[0] = binding->alias;\n+\t\t\tcolumn_names[1] = expr.relation_name;\n+\t\t\tfor (auto &child : struct_children) {\n+\t\t\t\tif (CheckExclusionList(expr, binding, child.first, new_select_list, excluded_columns)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tcolumn_names[2] = child.first;\n+\t\t\t\tnew_select_list.push_back(make_unique<ColumnRefExpression>(column_names));\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (auto &column_name : binding->names) {\n+\t\t\t\tif (CheckExclusionList(expr, binding, column_name, new_select_list, excluded_columns)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tnew_select_list.push_back(make_unique<ColumnRefExpression>(column_name, binding->alias));\n \t\t\t}\n-\t\t\tnew_select_list.push_back(make_unique<ColumnRefExpression>(column_name, binding->alias));\n \t\t}\n \t}\n \tfor (auto &excluded : expr.exclude_list) {\n",
  "test_patch": "diff --git a/test/sql/projection/select_struct_star.test b/test/sql/projection/select_struct_star.test\nnew file mode 100644\nindex 000000000000..a170274f47aa\n--- /dev/null\n+++ b/test/sql/projection/select_struct_star.test\n@@ -0,0 +1,46 @@\n+# name: test/sql/projection/select_struct_star.test\n+# description: SELECT struct.*;\n+# group: [projection]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# create table\n+statement ok\n+CREATE TABLE test(a STRUCT(i INT, j INT));\n+\n+# insertion: 1 affected row\n+query I\n+INSERT INTO test VALUES ({i: 1, j: 2});\n+----\n+1\n+\n+query II\n+SELECT a.* FROM test;\n+----\n+1\t2\n+\n+query I\n+SELECT a.* EXCLUDE(j) FROM test;\n+----\n+1\n+\n+query I\n+SELECT a.* EXCLUDE(i) FROM test;\n+----\n+2\n+\n+query II\n+SELECT a.* REPLACE(a.i + 3 AS i) FROM test;\n+----\n+4\t2\n+\n+statement ok\n+CREATE TABLE a(i row(t int));\n+\n+statement ok\n+CREATE TABLE b(i row(t int));\n+\n+# Binder Error: Ambiguous reference to column name \"i\" (use: \"b.i\" or \"a.i\")\n+statement error\n+SELECT i.* FROM a, b;\n\\ No newline at end of file\n",
  "problem_statement": "Support struct.* to retrieve all struct fields in SELECT list\nThis should work and expand to all fields in a struct:\r\n\r\n```sql\r\nselect x.* from (values ({'a': 42, 'b': 84})) t(x);\r\n-- should be identical to this\r\nselect x.a, x.b from (values ({'a': 42, 'b': 84})) t(x);\r\n\r\n```\n",
  "hints_text": "Please let me have a try!\nGo ahead :)",
  "created_at": "2022-07-16T12:13:06Z"
}