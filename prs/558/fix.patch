diff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp
index 678698020d39..c8f030ccefa6 100644
--- a/src/common/types/vector.cpp
+++ b/src/common/types/vector.cpp
@@ -722,6 +722,10 @@ void StringVector::AddHeapReference(Vector &vector, Vector &other) {
 	assert(vector.type == TypeId::VARCHAR);
 	assert(other.type == TypeId::VARCHAR);
 
+	if (other.vector_type == VectorType::DICTIONARY_VECTOR) {
+		StringVector::AddHeapReference(vector, DictionaryVector::Child(other));
+		return;
+	}
 	if (!other.auxiliary) {
 		return;
 	}
diff --git a/src/function/aggregate/distributive/sum.cpp b/src/function/aggregate/distributive/sum.cpp
index 379883e39381..de629ff9b181 100644
--- a/src/function/aggregate/distributive/sum.cpp
+++ b/src/function/aggregate/distributive/sum.cpp
@@ -9,49 +9,70 @@ using namespace std;
 
 namespace duckdb {
 
-struct SumOperation : public StandardDistributiveFunction {
-	template <class INPUT_TYPE, class STATE>
-	static void Assign(STATE *state, INPUT_TYPE input) {
-		*state = input;
+struct sum_state_t {
+	double value;
+	bool isset;
+};
+
+struct SumOperation {
+	template <class STATE> static void Initialize(STATE *state) {
+		state->value = 0;
+		state->isset = false;
 	}
 
-	template <class INPUT_TYPE, class STATE> static void Execute(STATE *state, INPUT_TYPE input) {
-		*state += input;
+	template <class INPUT_TYPE, class STATE, class OP>
+	static void Operation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t idx) {
+		state->isset = true;
+		state->value += input[idx];
 	}
 
 	template <class INPUT_TYPE, class STATE, class OP>
 	static void ConstantOperation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t count) {
-		assert(!nullmask[0]);
-		if (IsNullValue<INPUT_TYPE>(*state)) {
-			*state = 0;
-		}
-		*state += input[0] * count;
+		state->isset = true;
+		state->value += input[0] * count;
 	}
 
 	template <class T, class STATE>
 	static void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {
-		nullmask[idx] = IsNullValue<T>(*state);
-		target[idx] = *state;
+		if (!state->isset) {
+			nullmask[idx] = true;
+		} else {
+			if (!Value::DoubleIsValid(state->value)) {
+				throw OutOfRangeException("SUM is out of range!");
+			}
+			target[idx] = state->value;
+		}
 	}
-};
 
-template <>
-void SumOperation::Finalize(Vector &result, double *state, double *target, nullmask_t &nullmask, idx_t idx) {
-	if (!Value::DoubleIsValid(*state)) {
-		throw OutOfRangeException("SUM is out of range!");
+	template <class STATE, class OP> static void Combine(STATE source, STATE *target) {
+		if (!source.isset) {
+			// source is NULL, nothing to do
+			return;
+		}
+		if (!target->isset) {
+			// target is NULL, use source value directly
+			*target = source;
+		} else {
+			// else perform the operation
+			target->value += source.value;
+		}
 	}
-	nullmask[idx] = IsNullValue<double>(*state);
-	target[idx] = *state;
-}
+
+	static bool IgnoreNull() {
+		return true;
+	}
+};
 
 void SumFun::RegisterFunction(BuiltinFunctions &set) {
 	AggregateFunctionSet sum("sum");
 	// integer sums to bigint
 	sum.AddFunction(
-	    AggregateFunction::UnaryAggregate<int64_t, int64_t, int64_t, SumOperation>(SQLType::BIGINT, SQLType::BIGINT));
+	    AggregateFunction::UnaryAggregate<sum_state_t, int32_t, double, SumOperation>(SQLType::INTEGER, SQLType::DOUBLE));
+	sum.AddFunction(
+	    AggregateFunction::UnaryAggregate<sum_state_t, int64_t, double, SumOperation>(SQLType::BIGINT, SQLType::DOUBLE));
 	// float sums to float
 	sum.AddFunction(
-	    AggregateFunction::UnaryAggregate<double, double, double, SumOperation>(SQLType::DOUBLE, SQLType::DOUBLE));
+	    AggregateFunction::UnaryAggregate<sum_state_t, double, double, SumOperation>(SQLType::DOUBLE, SQLType::DOUBLE));
 
 	set.AddFunction(sum);
 }
diff --git a/src/optimizer/pushdown/pushdown_left_join.cpp b/src/optimizer/pushdown/pushdown_left_join.cpp
index b5f01a1ceb09..4b957624677b 100644
--- a/src/optimizer/pushdown/pushdown_left_join.cpp
+++ b/src/optimizer/pushdown/pushdown_left_join.cpp
@@ -7,6 +7,7 @@
 #include "duckdb/planner/expression_iterator.hpp"
 #include "duckdb/planner/operator/logical_comparison_join.hpp"
 #include "duckdb/planner/operator/logical_filter.hpp"
+#include "duckdb/execution/expression_executor.hpp"
 
 using namespace duckdb;
 using namespace std;
@@ -39,19 +40,22 @@ static bool FilterRemovesNull(ExpressionRewriter &rewriter, Expression *expr, un
 	auto filter = make_unique<LogicalFilter>();
 	filter->expressions.push_back(move(copy));
 	rewriter.Apply(*filter);
-	assert(filter->expressions.size() == 1);
 
-	if (filter->expressions[0]->type != ExpressionType::VALUE_CONSTANT) {
-		// could not flatten the result
-		assert(!filter->expressions[0]->IsFoldable());
-		return false;
+	// check if all expressions are foldable
+	for(idx_t i = 0; i < filter->expressions.size(); i++) {
+		if (!filter->expressions[i]->IsFoldable()) {
+			return false;
+		}
+		// we flattened the result into a scalar, check if it is FALSE or NULL
+		auto val = ExpressionExecutor::EvaluateScalar(*filter->expressions[i]).CastAs(TypeId::BOOL);
+		// if the result of the expression with all expressions replaced with NULL is "NULL" or "false"
+		// then any extra entries generated by the LEFT OUTER JOIN will be filtered out!
+		// hence the LEFT OUTER JOIN is equivalent to an inner join
+		if (val.is_null || !val.value_.boolean) {
+			return true;
+		}
 	}
-	// we flattened the result into a scalar, check if it is FALSE or NULL
-	auto val = ((BoundConstantExpression &)*filter->expressions[0]).value.CastAs(TypeId::BOOL);
-	// if the result of the expression with all expressions replaced with NULL is "NULL" or "false"
-	// then any extra entries generated by the LEFT OUTER JOIN will be filtered out!
-	// hence the LEFT OUTER JOIN is equivalent to an inner join
-	return val.is_null || !val.value_.boolean;
+	return false;
 }
 
 unique_ptr<LogicalOperator> FilterPushdown::PushdownLeftJoin(unique_ptr<LogicalOperator> op,
