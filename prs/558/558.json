{
  "repo": "duckdb/duckdb",
  "pull_number": 558,
  "instance_id": "duckdb__duckdb-558",
  "issue_numbers": [
    "543",
    "552"
  ],
  "base_commit": "0560e8104008670262d630aefffb640e963576f0",
  "patch": "diff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp\nindex 678698020d39..c8f030ccefa6 100644\n--- a/src/common/types/vector.cpp\n+++ b/src/common/types/vector.cpp\n@@ -722,6 +722,10 @@ void StringVector::AddHeapReference(Vector &vector, Vector &other) {\n \tassert(vector.type == TypeId::VARCHAR);\n \tassert(other.type == TypeId::VARCHAR);\n \n+\tif (other.vector_type == VectorType::DICTIONARY_VECTOR) {\n+\t\tStringVector::AddHeapReference(vector, DictionaryVector::Child(other));\n+\t\treturn;\n+\t}\n \tif (!other.auxiliary) {\n \t\treturn;\n \t}\ndiff --git a/src/function/aggregate/distributive/sum.cpp b/src/function/aggregate/distributive/sum.cpp\nindex 379883e39381..de629ff9b181 100644\n--- a/src/function/aggregate/distributive/sum.cpp\n+++ b/src/function/aggregate/distributive/sum.cpp\n@@ -9,49 +9,70 @@ using namespace std;\n \n namespace duckdb {\n \n-struct SumOperation : public StandardDistributiveFunction {\n-\ttemplate <class INPUT_TYPE, class STATE>\n-\tstatic void Assign(STATE *state, INPUT_TYPE input) {\n-\t\t*state = input;\n+struct sum_state_t {\n+\tdouble value;\n+\tbool isset;\n+};\n+\n+struct SumOperation {\n+\ttemplate <class STATE> static void Initialize(STATE *state) {\n+\t\tstate->value = 0;\n+\t\tstate->isset = false;\n \t}\n \n-\ttemplate <class INPUT_TYPE, class STATE> static void Execute(STATE *state, INPUT_TYPE input) {\n-\t\t*state += input;\n+\ttemplate <class INPUT_TYPE, class STATE, class OP>\n+\tstatic void Operation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t idx) {\n+\t\tstate->isset = true;\n+\t\tstate->value += input[idx];\n \t}\n \n \ttemplate <class INPUT_TYPE, class STATE, class OP>\n \tstatic void ConstantOperation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t count) {\n-\t\tassert(!nullmask[0]);\n-\t\tif (IsNullValue<INPUT_TYPE>(*state)) {\n-\t\t\t*state = 0;\n-\t\t}\n-\t\t*state += input[0] * count;\n+\t\tstate->isset = true;\n+\t\tstate->value += input[0] * count;\n \t}\n \n \ttemplate <class T, class STATE>\n \tstatic void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {\n-\t\tnullmask[idx] = IsNullValue<T>(*state);\n-\t\ttarget[idx] = *state;\n+\t\tif (!state->isset) {\n+\t\t\tnullmask[idx] = true;\n+\t\t} else {\n+\t\t\tif (!Value::DoubleIsValid(state->value)) {\n+\t\t\t\tthrow OutOfRangeException(\"SUM is out of range!\");\n+\t\t\t}\n+\t\t\ttarget[idx] = state->value;\n+\t\t}\n \t}\n-};\n \n-template <>\n-void SumOperation::Finalize(Vector &result, double *state, double *target, nullmask_t &nullmask, idx_t idx) {\n-\tif (!Value::DoubleIsValid(*state)) {\n-\t\tthrow OutOfRangeException(\"SUM is out of range!\");\n+\ttemplate <class STATE, class OP> static void Combine(STATE source, STATE *target) {\n+\t\tif (!source.isset) {\n+\t\t\t// source is NULL, nothing to do\n+\t\t\treturn;\n+\t\t}\n+\t\tif (!target->isset) {\n+\t\t\t// target is NULL, use source value directly\n+\t\t\t*target = source;\n+\t\t} else {\n+\t\t\t// else perform the operation\n+\t\t\ttarget->value += source.value;\n+\t\t}\n \t}\n-\tnullmask[idx] = IsNullValue<double>(*state);\n-\ttarget[idx] = *state;\n-}\n+\n+\tstatic bool IgnoreNull() {\n+\t\treturn true;\n+\t}\n+};\n \n void SumFun::RegisterFunction(BuiltinFunctions &set) {\n \tAggregateFunctionSet sum(\"sum\");\n \t// integer sums to bigint\n \tsum.AddFunction(\n-\t    AggregateFunction::UnaryAggregate<int64_t, int64_t, int64_t, SumOperation>(SQLType::BIGINT, SQLType::BIGINT));\n+\t    AggregateFunction::UnaryAggregate<sum_state_t, int32_t, double, SumOperation>(SQLType::INTEGER, SQLType::DOUBLE));\n+\tsum.AddFunction(\n+\t    AggregateFunction::UnaryAggregate<sum_state_t, int64_t, double, SumOperation>(SQLType::BIGINT, SQLType::DOUBLE));\n \t// float sums to float\n \tsum.AddFunction(\n-\t    AggregateFunction::UnaryAggregate<double, double, double, SumOperation>(SQLType::DOUBLE, SQLType::DOUBLE));\n+\t    AggregateFunction::UnaryAggregate<sum_state_t, double, double, SumOperation>(SQLType::DOUBLE, SQLType::DOUBLE));\n \n \tset.AddFunction(sum);\n }\ndiff --git a/src/optimizer/pushdown/pushdown_left_join.cpp b/src/optimizer/pushdown/pushdown_left_join.cpp\nindex b5f01a1ceb09..4b957624677b 100644\n--- a/src/optimizer/pushdown/pushdown_left_join.cpp\n+++ b/src/optimizer/pushdown/pushdown_left_join.cpp\n@@ -7,6 +7,7 @@\n #include \"duckdb/planner/expression_iterator.hpp\"\n #include \"duckdb/planner/operator/logical_comparison_join.hpp\"\n #include \"duckdb/planner/operator/logical_filter.hpp\"\n+#include \"duckdb/execution/expression_executor.hpp\"\n \n using namespace duckdb;\n using namespace std;\n@@ -39,19 +40,22 @@ static bool FilterRemovesNull(ExpressionRewriter &rewriter, Expression *expr, un\n \tauto filter = make_unique<LogicalFilter>();\n \tfilter->expressions.push_back(move(copy));\n \trewriter.Apply(*filter);\n-\tassert(filter->expressions.size() == 1);\n \n-\tif (filter->expressions[0]->type != ExpressionType::VALUE_CONSTANT) {\n-\t\t// could not flatten the result\n-\t\tassert(!filter->expressions[0]->IsFoldable());\n-\t\treturn false;\n+\t// check if all expressions are foldable\n+\tfor(idx_t i = 0; i < filter->expressions.size(); i++) {\n+\t\tif (!filter->expressions[i]->IsFoldable()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// we flattened the result into a scalar, check if it is FALSE or NULL\n+\t\tauto val = ExpressionExecutor::EvaluateScalar(*filter->expressions[i]).CastAs(TypeId::BOOL);\n+\t\t// if the result of the expression with all expressions replaced with NULL is \"NULL\" or \"false\"\n+\t\t// then any extra entries generated by the LEFT OUTER JOIN will be filtered out!\n+\t\t// hence the LEFT OUTER JOIN is equivalent to an inner join\n+\t\tif (val.is_null || !val.value_.boolean) {\n+\t\t\treturn true;\n+\t\t}\n \t}\n-\t// we flattened the result into a scalar, check if it is FALSE or NULL\n-\tauto val = ((BoundConstantExpression &)*filter->expressions[0]).value.CastAs(TypeId::BOOL);\n-\t// if the result of the expression with all expressions replaced with NULL is \"NULL\" or \"false\"\n-\t// then any extra entries generated by the LEFT OUTER JOIN will be filtered out!\n-\t// hence the LEFT OUTER JOIN is equivalent to an inner join\n-\treturn val.is_null || !val.value_.boolean;\n+\treturn false;\n }\n \n unique_ptr<LogicalOperator> FilterPushdown::PushdownLeftJoin(unique_ptr<LogicalOperator> op,\n",
  "test_patch": "diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp\nindex fdac2cb3a464..0a8d9f2cd8ed 100644\n--- a/test/rigger/test_rigger.cpp\n+++ b/test/rigger/test_rigger.cpp\n@@ -470,6 +470,22 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tresult = con.Query(\"SELECT MAX(agg0) FROM (SELECT MAX(t0.c0) AS agg0 FROM t0) as s0;\");\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {\"aaaaaaaaaaaa\"}));\n \t}\n+\tSECTION(\"543\") {\n+\t\t// Unexpected result for SUM() upon overflow\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c1 BIGINT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c1) VALUES (2);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c1) VALUES (9223372036854775807);\"));\n+\t\tresult = con.Query(\"SELECT SUM(t0.c1) FROM t0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {9223372036854775809.0}));\n+\n+\t\tREQUIRE_NO_FAIL(con.Query(\"DROP TABLE t0;\"));\n+\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c1 BIGINT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c1) VALUES (1);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c1) VALUES (9223372036854775807);\"));\n+\t\tresult = con.Query(\"SELECT SUM(t0.c1) FROM t0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {9223372036854775808.0}));\n+\t}\n \tSECTION(\"544\") {\n \t\t// SELECT on view with text constant in ORDER BY crashes\n \t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n@@ -485,4 +501,20 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 SIMILAR TO '.';\");\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {\"0\"}));\n \t}\n+\tSECTION(\"549\") {\n+\t\t// Nested CASE expression results in Assertion `other.auxiliary->type == VectorBufferType::STRING_BUFFER' failed\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (NULL), (0), (1); \"));\n+\t\tREQUIRE_FAIL(con.Query(\"SELECT * FROM t0 WHERE CASE WHEN c0 THEN 0 ELSE CASE '0.1' WHEN c0 THEN '' END END;\"));\n+\t\tresult = con.Query(\"SELECT CASE WHEN c0 THEN 0 ELSE (CASE '0' WHEN c0 THEN '0.6' END) END FROM t0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {Value(), \"0.6\", \"0\"}));\n+\t}\n+\tSECTION(\"552\") {\n+\t\t// RIGHT JOIN results in Assertion `filter->expressions.size() == 1'\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 INT);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 RIGHT JOIN t1 ON 0 WHERE t0.c0 OR t1.c0 BETWEEN t0.c0 AND 1;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t}\n+\n }\ndiff --git a/tools/sqlite3_api_wrapper/test_sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/test_sqlite3_api_wrapper.cpp\nindex 50fdddf03df8..21f072794cfb 100644\n--- a/tools/sqlite3_api_wrapper/test_sqlite3_api_wrapper.cpp\n+++ b/tools/sqlite3_api_wrapper/test_sqlite3_api_wrapper.cpp\n@@ -119,7 +119,7 @@ TEST_CASE(\"Basic sqlite wrapper usage\", \"[sqlite3wrapper]\") {\n \t// simple statements\n \tREQUIRE(db.Execute(\"CREATE TABLE test(i INTEGER)\"));\n \tREQUIRE(db.Execute(\"INSERT INTO test VALUES (1), (2), (3)\"));\n-\tREQUIRE(db.Execute(\"SELECT SUM(t1.i) FROM test t1, test t2, test t3;\"));\n+\tREQUIRE(db.Execute(\"SELECT SUM(t1.i)::BIGINT FROM test t1, test t2, test t3;\"));\n \tREQUIRE(db.CheckColumn(0, {\"54\"}));\n \n \tREQUIRE(db.Execute(\"DELETE FROM test WHERE i=2\"));\n",
  "problem_statement": "Unexpected result for SUM() upon overflow\nConsider the following statements:\r\n```sql\r\nCREATE TABLE t0(c1 BIGINT);\r\nINSERT INTO t0(c1) VALUES (2);\r\nINSERT INTO t0(c1) VALUES (9223372036854775807);\r\nSELECT SUM(t0.c1) FROM t0; -- expected: {9223372036854776000}, actual: {-9223372036854775807}\r\n```\r\nThe overflow here might be unexpected. DBMS like Postgres and MySQL seem to return a floating-point result, avoiding the wraparound. SQLite outputs an integer overflow error. Interestingly, an exact overflow results in `NULL` being computed for DuckDB, which might also be an expected behavior for an overflow:\r\n```sql\r\nCREATE TABLE t0(c1 BIGINT);\r\nINSERT INTO t0(c1) VALUES (1);\r\nINSERT INTO t0(c1) VALUES (9223372036854775807);\r\nSELECT SUM(t0.c1) FROM t0; -- NULL\r\n```\r\nWhether this is a bug is less clear than other cases. Feel free to close this issue, if this is the expected behavior. I found this based on commit b4aada80e3b0614029ec957de01cac0a14d8a785.\nRIGHT JOIN results in Assertion `filter->expressions.size() == 1' failed.\nConsider the following statements:\r\n```sql\r\nCREATE TABLE t0(c0 INT);\r\nCREATE TABLE t1(c0 INT);\r\nSELECT * FROM t0 RIGHT JOIN t1 ON 0 WHERE t0.c0 OR t1.c0 BETWEEN t0.c0 AND 1; -- Assertion `filter->expressions.size() == 1' failed.\r\n```\r\nWhen using the debug build, the query results in the following assertion failure:\r\n```\r\n/projects/duckdb/src/optimizer/pushdown/pushdown_left_join.cpp:42: bool FilterRemovesNull(duckdb::ExpressionRewriter&, duckdb::Expression*, std::unordered_set<long unsigned int>&): Assertion `filter->expressions.size() == 1' failed.\r\n```\r\nI found this based on commit 0560e8104008670262d630aefffb640e963576f0.\n",
  "hints_text": "This is indeed a bug, but it is one we are quite aware of :) This is related to #74 and #111 , however, it has ended up on the backburner for some time already. Fixing it by itself is quite trivial (e.g. double promotion), but we want to fix it with a minimal performance impact, which requires a lot more work to do properly. I will leave this issue open, as we can use these test cases when we get around to fixing it.\nOkay, thanks for the feedback! I'll consider this a duplicate bug report then. Feel free to close this issue now or later, depending on what is more convenient for you.\n",
  "created_at": "2020-04-14T14:41:03Z"
}