{
  "repo": "duckdb/duckdb",
  "pull_number": 5386,
  "instance_id": "duckdb__duckdb-5386",
  "issue_numbers": [
    "5368"
  ],
  "base_commit": "0f0461113f3341135471805c9928c4d71d1f5874",
  "patch": "diff --git a/src/common/types/hash.cpp b/src/common/types/hash.cpp\nindex 33c220bfd3a1..9f2f23b1e4e6 100644\n--- a/src/common/types/hash.cpp\n+++ b/src/common/types/hash.cpp\n@@ -2,6 +2,7 @@\n \n #include \"duckdb/common/helper.hpp\"\n #include \"duckdb/common/types/string_type.hpp\"\n+#include \"duckdb/common/types/interval.hpp\"\n \n #include <functional>\n #include <cmath>\ndiff --git a/src/include/duckdb/common/operator/add.hpp b/src/include/duckdb/common/operator/add.hpp\nindex 9e639a3731f2..bcfd709573bb 100644\n--- a/src/include/duckdb/common/operator/add.hpp\n+++ b/src/include/duckdb/common/operator/add.hpp\n@@ -9,6 +9,7 @@\n #pragma once\n \n #include \"duckdb/common/types.hpp\"\n+#include \"duckdb/common/type_util.hpp\"\n #include \"duckdb/common/exception.hpp\"\n \n namespace duckdb {\ndiff --git a/src/include/duckdb/common/operator/convert_to_string.hpp b/src/include/duckdb/common/operator/convert_to_string.hpp\nindex e05faa264884..067b75ad9832 100644\n--- a/src/include/duckdb/common/operator/convert_to_string.hpp\n+++ b/src/include/duckdb/common/operator/convert_to_string.hpp\n@@ -10,6 +10,7 @@\n \n #include \"duckdb/common/common.hpp\"\n #include \"duckdb/common/types.hpp\"\n+#include \"duckdb/common/type_util.hpp\"\n #include \"duckdb/common/exception.hpp\"\n \n namespace duckdb {\ndiff --git a/src/include/duckdb/common/operator/multiply.hpp b/src/include/duckdb/common/operator/multiply.hpp\nindex a181875c91d7..4c709e763c72 100644\n--- a/src/include/duckdb/common/operator/multiply.hpp\n+++ b/src/include/duckdb/common/operator/multiply.hpp\n@@ -10,9 +10,12 @@\n \n #include \"duckdb/common/types.hpp\"\n #include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/type_util.hpp\"\n \n namespace duckdb {\n \n+struct interval_t;\n+\n struct MultiplyOperator {\n \ttemplate <class TA, class TB, class TR>\n \tstatic inline TR Operation(TA left, TB right) {\ndiff --git a/src/include/duckdb/common/operator/subtract.hpp b/src/include/duckdb/common/operator/subtract.hpp\nindex 2d22588a8bae..85a3de3f94ea 100644\n--- a/src/include/duckdb/common/operator/subtract.hpp\n+++ b/src/include/duckdb/common/operator/subtract.hpp\n@@ -10,9 +10,15 @@\n \n #include \"duckdb/common/types.hpp\"\n #include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/type_util.hpp\"\n \n namespace duckdb {\n \n+struct interval_t;\n+struct date_t;\n+struct timestamp_t;\n+struct dtime_t;\n+\n struct SubtractOperator {\n \ttemplate <class TA, class TB, class TR>\n \tstatic inline TR Operation(TA left, TB right) {\ndiff --git a/src/include/duckdb/common/type_util.hpp b/src/include/duckdb/common/type_util.hpp\nnew file mode 100644\nindex 000000000000..19eae9e4ae44\n--- /dev/null\n+++ b/src/include/duckdb/common/type_util.hpp\n@@ -0,0 +1,68 @@\n+#pragma once\n+\n+#include \"duckdb/common/types.hpp\"\n+#include \"duckdb/common/types/date.hpp\"\n+#include \"duckdb/common/types/datetime.hpp\"\n+#include \"duckdb/common/types/timestamp.hpp\"\n+#include \"duckdb/common/types/interval.hpp\"\n+\n+namespace duckdb {\n+\n+//! Returns the PhysicalType for the given type\n+template <class T>\n+PhysicalType GetTypeId() {\n+\tif (std::is_same<T, bool>()) {\n+\t\treturn PhysicalType::BOOL;\n+\t} else if (std::is_same<T, int8_t>()) {\n+\t\treturn PhysicalType::INT8;\n+\t} else if (std::is_same<T, int16_t>()) {\n+\t\treturn PhysicalType::INT16;\n+\t} else if (std::is_same<T, int32_t>()) {\n+\t\treturn PhysicalType::INT32;\n+\t} else if (std::is_same<T, int64_t>()) {\n+\t\treturn PhysicalType::INT64;\n+\t} else if (std::is_same<T, uint8_t>()) {\n+\t\treturn PhysicalType::UINT8;\n+\t} else if (std::is_same<T, uint16_t>()) {\n+\t\treturn PhysicalType::UINT16;\n+\t} else if (std::is_same<T, uint32_t>()) {\n+\t\treturn PhysicalType::UINT32;\n+\t} else if (std::is_same<T, uint64_t>()) {\n+\t\treturn PhysicalType::UINT64;\n+\t} else if (std::is_same<T, hugeint_t>()) {\n+\t\treturn PhysicalType::INT128;\n+\t} else if (std::is_same<T, date_t>()) {\n+\t\treturn PhysicalType::INT32;\n+\t} else if (std::is_same<T, dtime_t>()) {\n+\t\treturn PhysicalType::INT64;\n+\t} else if (std::is_same<T, timestamp_t>()) {\n+\t\treturn PhysicalType::INT64;\n+\t} else if (std::is_same<T, float>()) {\n+\t\treturn PhysicalType::FLOAT;\n+\t} else if (std::is_same<T, double>()) {\n+\t\treturn PhysicalType::DOUBLE;\n+\t} else if (std::is_same<T, const char *>() || std::is_same<T, char *>() || std::is_same<T, string_t>()) {\n+\t\treturn PhysicalType::VARCHAR;\n+\t} else if (std::is_same<T, interval_t>()) {\n+\t\treturn PhysicalType::INTERVAL;\n+\t} else {\n+\t\treturn PhysicalType::INVALID;\n+\t}\n+}\n+\n+template <class T>\n+bool TypeIsNumber() {\n+\treturn std::is_integral<T>() || std::is_floating_point<T>() || std::is_same<T, hugeint_t>();\n+}\n+\n+template <class T>\n+bool IsValidType() {\n+\treturn GetTypeId<T>() != PhysicalType::INVALID;\n+}\n+\n+template <class T>\n+bool IsIntegerType() {\n+\treturn TypeIsIntegral(GetTypeId<T>());\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/common/types.hpp b/src/include/duckdb/common/types.hpp\nindex 4281d7d40806..28c6f2f3c4f4 100644\n--- a/src/include/duckdb/common/types.hpp\n+++ b/src/include/duckdb/common/types.hpp\n@@ -23,124 +23,6 @@ class Value;\n class TypeCatalogEntry;\n class Vector;\n class ClientContext;\n-//! Type used to represent dates (days since 1970-01-01)\n-struct date_t { // NOLINT\n-\tint32_t days;\n-\n-\tdate_t() = default;\n-\texplicit inline date_t(int32_t days_p) : days(days_p) {}\n-\n-\t// explicit conversion\n-\texplicit inline operator int32_t() const {return days;}\n-\n-\t// comparison operators\n-\tinline bool operator==(const date_t &rhs) const {return days == rhs.days;};\n-\tinline bool operator!=(const date_t &rhs) const {return days != rhs.days;};\n-\tinline bool operator<=(const date_t &rhs) const {return days <= rhs.days;};\n-\tinline bool operator<(const date_t &rhs) const {return days < rhs.days;};\n-\tinline bool operator>(const date_t &rhs) const {return days > rhs.days;};\n-\tinline bool operator>=(const date_t &rhs) const {return days >= rhs.days;};\n-\n-\t// arithmetic operators\n-\tinline date_t operator+(const int32_t &days) const {return date_t(this->days + days);};\n-\tinline date_t operator-(const int32_t &days) const {return date_t(this->days - days);};\n-\n-\t// in-place operators\n-\tinline date_t &operator+=(const int32_t &days) {this->days += days; return *this;};\n-\tinline date_t &operator-=(const int32_t &days) {this->days -= days; return *this;};\n-\n-\t// special values\n-\tstatic inline date_t infinity() {return date_t(std::numeric_limits<int32_t>::max()); } // NOLINT\n-\tstatic inline date_t ninfinity() {return date_t(-std::numeric_limits<int32_t>::max()); } // NOLINT\n-\tstatic inline date_t epoch() {return date_t(0); } // NOLINT\n-};\n-\n-//! Type used to represent time (microseconds)\n-struct dtime_t { // NOLINT\n-\tint64_t micros;\n-\n-\tdtime_t() = default;\n-\texplicit inline dtime_t(int64_t micros_p) : micros(micros_p) {}\n-\tinline dtime_t& operator=(int64_t micros_p) {micros = micros_p; return *this;}\n-\n-\t// explicit conversion\n-\texplicit inline operator int64_t() const {return micros;}\n-\texplicit inline operator double() const {return micros;}\n-\n-\t// comparison operators\n-\tinline bool operator==(const dtime_t &rhs) const {return micros == rhs.micros;};\n-\tinline bool operator!=(const dtime_t &rhs) const {return micros != rhs.micros;};\n-\tinline bool operator<=(const dtime_t &rhs) const {return micros <= rhs.micros;};\n-\tinline bool operator<(const dtime_t &rhs) const {return micros < rhs.micros;};\n-\tinline bool operator>(const dtime_t &rhs) const {return micros > rhs.micros;};\n-\tinline bool operator>=(const dtime_t &rhs) const {return micros >= rhs.micros;};\n-\n-\t// arithmetic operators\n-\tinline dtime_t operator+(const int64_t &micros) const {return dtime_t(this->micros + micros);};\n-\tinline dtime_t operator+(const double &micros) const {return dtime_t(this->micros + int64_t(micros));};\n-\tinline dtime_t operator-(const int64_t &micros) const {return dtime_t(this->micros - micros);};\n-\tinline dtime_t operator*(const idx_t &copies) const {return dtime_t(this->micros * copies);};\n-\tinline dtime_t operator/(const idx_t &copies) const {return dtime_t(this->micros / copies);};\n-\tinline int64_t operator-(const dtime_t &other) const {return this->micros - other.micros;};\n-\n-\t// in-place operators\n-\tinline dtime_t &operator+=(const int64_t &micros) {this->micros += micros; return *this;};\n-\tinline dtime_t &operator-=(const int64_t &micros) {this->micros -= micros; return *this;};\n-\tinline dtime_t &operator+=(const dtime_t &other) {this->micros += other.micros; return *this;};\n-\n-\t// special values\n-\tstatic inline dtime_t allballs() {return dtime_t(0); } // NOLINT\n-};\n-\n-struct dtime_tz_t : public dtime_t {};\n-\n-//! Type used to represent timestamps (seconds,microseconds,milliseconds or nanoseconds since 1970-01-01)\n-struct timestamp_t { // NOLINT\n-\tint64_t value;\n-\n-\ttimestamp_t() = default;\n-\texplicit inline timestamp_t(int64_t value_p) : value(value_p) {}\n-\tinline timestamp_t& operator=(int64_t value_p) {value = value_p; return *this;}\n-\n-\t// explicit conversion\n-\texplicit inline operator int64_t() const {return value;}\n-\n-\t// comparison operators\n-\tinline bool operator==(const timestamp_t &rhs) const {return value == rhs.value;};\n-\tinline bool operator!=(const timestamp_t &rhs) const {return value != rhs.value;};\n-\tinline bool operator<=(const timestamp_t &rhs) const {return value <= rhs.value;};\n-\tinline bool operator<(const timestamp_t &rhs) const {return value < rhs.value;};\n-\tinline bool operator>(const timestamp_t &rhs) const {return value > rhs.value;};\n-\tinline bool operator>=(const timestamp_t &rhs) const {return value >= rhs.value;};\n-\n-\t// arithmetic operators\n-\tinline timestamp_t operator+(const double &value) const {return timestamp_t(this->value + int64_t(value));};\n-\tinline int64_t operator-(const timestamp_t &other) const {return this->value - other.value;};\n-\n-\t// in-place operators\n-\tinline timestamp_t &operator+=(const int64_t &value) {this->value += value; return *this;};\n-\tinline timestamp_t &operator-=(const int64_t &value) {this->value -= value; return *this;};\n-\n-\t// special values\n-\tstatic inline timestamp_t infinity() {return timestamp_t(std::numeric_limits<int64_t>::max()); } // NOLINT\n-\tstatic inline timestamp_t ninfinity() {return timestamp_t(-std::numeric_limits<int64_t>::max()); } // NOLINT\n-\tstatic inline timestamp_t epoch() {return timestamp_t(0); } // NOLINT\n-};\n-\n-struct timestamp_tz_t : public timestamp_t {};\n-struct timestamp_ns_t : public timestamp_t {};\n-struct timestamp_ms_t : public timestamp_t {};\n-struct timestamp_sec_t : public timestamp_t {};\n-\n-struct interval_t {\n-\tint32_t months;\n-\tint32_t days;\n-\tint64_t micros;\n-\n-\tinline bool operator==(const interval_t &rhs) const {\n-\t\treturn this->days == rhs.days && this->months == rhs.months && this->micros == rhs.micros;\n-\t}\n-};\n \n struct hugeint_t {\n public:\n@@ -595,65 +477,12 @@ struct AggregateStateType {\n \tDUCKDB_API static const aggregate_state_t &GetStateType(const LogicalType &type);\n };\n \n-\n DUCKDB_API string LogicalTypeIdToString(LogicalTypeId type);\n \n DUCKDB_API LogicalTypeId TransformStringToLogicalTypeId(const string &str);\n \n DUCKDB_API LogicalType TransformStringToLogicalType(const string &str);\n \n-//! Returns the PhysicalType for the given type\n-template <class T>\n-PhysicalType GetTypeId() {\n-\tif (std::is_same<T, bool>()) {\n-\t\treturn PhysicalType::BOOL;\n-\t} else if (std::is_same<T, int8_t>()) {\n-\t\treturn PhysicalType::INT8;\n-\t} else if (std::is_same<T, int16_t>()) {\n-\t\treturn PhysicalType::INT16;\n-\t} else if (std::is_same<T, int32_t>()) {\n-\t\treturn PhysicalType::INT32;\n-\t} else if (std::is_same<T, int64_t>()) {\n-\t\treturn PhysicalType::INT64;\n-\t} else if (std::is_same<T, uint8_t>()) {\n-\t\treturn PhysicalType::UINT8;\n-\t} else if (std::is_same<T, uint16_t>()) {\n-\t\treturn PhysicalType::UINT16;\n-\t} else if (std::is_same<T, uint32_t>()) {\n-\t\treturn PhysicalType::UINT32;\n-\t} else if (std::is_same<T, uint64_t>()) {\n-\t\treturn PhysicalType::UINT64;\n-\t} else if (std::is_same<T, hugeint_t>()) {\n-\t\treturn PhysicalType::INT128;\n-\t} else if (std::is_same<T, date_t>()) {\n-\t\treturn PhysicalType::INT32;\n-\t} else if (std::is_same<T, dtime_t>()) {\n-\t\treturn PhysicalType::INT64;\n-\t} else if (std::is_same<T, timestamp_t>()) {\n-\t\treturn PhysicalType::INT64;\n-\t} else if (std::is_same<T, float>()) {\n-\t\treturn PhysicalType::FLOAT;\n-\t} else if (std::is_same<T, double>()) {\n-\t\treturn PhysicalType::DOUBLE;\n-\t} else if (std::is_same<T, const char *>() || std::is_same<T, char *>() || std::is_same<T, string_t>()) {\n-\t\treturn PhysicalType::VARCHAR;\n-\t} else if (std::is_same<T, interval_t>()) {\n-\t\treturn PhysicalType::INTERVAL;\n-\t} else {\n-\t\treturn PhysicalType::INVALID;\n-\t}\n-}\n-\n-template<class T>\n-bool TypeIsNumber() {\n-\treturn std::is_integral<T>() || std::is_floating_point<T>() || std::is_same<T, hugeint_t>();\n-}\n-\n-template <class T>\n-bool IsValidType() {\n-\treturn GetTypeId<T>() != PhysicalType::INVALID;\n-}\n-\n //! The PhysicalType used by the row identifiers column\n extern const PhysicalType ROW_TYPE;\n \n@@ -664,11 +493,6 @@ bool TypeIsIntegral(PhysicalType type);\n bool TypeIsNumeric(PhysicalType type);\n bool TypeIsInteger(PhysicalType type);\n \n-template <class T>\n-bool IsIntegerType() {\n-\treturn TypeIsIntegral(GetTypeId<T>());\n-}\n-\n bool ApproxEqual(float l, float r);\n bool ApproxEqual(double l, double r);\n \n@@ -682,84 +506,3 @@ struct aggregate_state_t {\n };\n \n } // namespace duckdb\n-\n-namespace std {\n-\n-\t//! Date\n-\ttemplate <>\n-\tstruct hash<duckdb::date_t>\n-\t{\n-\t\tstd::size_t operator()(const duckdb::date_t& k) const\n-\t\t{\n-\t\t\tusing std::hash;\n-\t\t\treturn hash<int32_t>()((int32_t)k);\n-\t\t}\n-\t};\n-\n-\t//! Time\n-\ttemplate <>\n-\tstruct hash<duckdb::dtime_t>\n-\t{\n-\t\tstd::size_t operator()(const duckdb::dtime_t& k) const\n-\t\t{\n-\t\t\tusing std::hash;\n-\t\t\treturn hash<int64_t>()((int64_t)k);\n-\t\t}\n-\t};\n-\ttemplate <>\n-\tstruct hash<duckdb::dtime_tz_t>\n-\t{\n-\t\tstd::size_t operator()(const duckdb::dtime_tz_t& k) const\n-\t\t{\n-\t\t\tusing std::hash;\n-\t\t\treturn hash<int64_t>()((int64_t)k);\n-\t\t}\n-\t};\n-\n-\t//! Timestamp\n-\ttemplate <>\n-\tstruct hash<duckdb::timestamp_t>\n-\t{\n-\t\tstd::size_t operator()(const duckdb::timestamp_t& k) const\n-\t\t{\n-\t\t\tusing std::hash;\n-\t\t\treturn hash<int64_t>()((int64_t)k);\n-\t\t}\n-\t};\n-\ttemplate <>\n-\tstruct hash<duckdb::timestamp_ms_t>\n-\t{\n-\t\tstd::size_t operator()(const duckdb::timestamp_ms_t& k) const\n-\t\t{\n-\t\t\tusing std::hash;\n-\t\t\treturn hash<int64_t>()((int64_t)k);\n-\t\t}\n-\t};\n-\ttemplate <>\n-\tstruct hash<duckdb::timestamp_ns_t>\n-\t{\n-\t\tstd::size_t operator()(const duckdb::timestamp_ns_t& k) const\n-\t\t{\n-\t\t\tusing std::hash;\n-\t\t\treturn hash<int64_t>()((int64_t)k);\n-\t\t}\n-\t};\n-\ttemplate <>\n-\tstruct hash<duckdb::timestamp_sec_t>\n-\t{\n-\t\tstd::size_t operator()(const duckdb::timestamp_sec_t& k) const\n-\t\t{\n-\t\t\tusing std::hash;\n-\t\t\treturn hash<int64_t>()((int64_t)k);\n-\t\t}\n-\t};\n-\ttemplate <>\n-\tstruct hash<duckdb::timestamp_tz_t>\n-\t{\n-\t\tstd::size_t operator()(const duckdb::timestamp_tz_t& k) const\n-\t\t{\n-\t\t\tusing std::hash;\n-\t\t\treturn hash<int64_t>()((int64_t)k);\n-\t\t}\n-\t};\n-}\ndiff --git a/src/include/duckdb/common/types/date.hpp b/src/include/duckdb/common/types/date.hpp\nindex 3cb8525e515b..02b50f3cde61 100644\n--- a/src/include/duckdb/common/types/date.hpp\n+++ b/src/include/duckdb/common/types/date.hpp\n@@ -12,9 +12,77 @@\n #include \"duckdb/common/types.hpp\"\n #include \"duckdb/common/winapi.hpp\"\n #include \"duckdb/common/types/string_type.hpp\"\n+#include \"duckdb/common/limits.hpp\"\n+\n+#include <functional>\n \n namespace duckdb {\n \n+struct timestamp_t;\n+\n+//! Type used to represent dates (days since 1970-01-01)\n+struct date_t { // NOLINT\n+\tint32_t days;\n+\n+\tdate_t() = default;\n+\texplicit inline date_t(int32_t days_p) : days(days_p) {\n+\t}\n+\n+\t// explicit conversion\n+\texplicit inline operator int32_t() const {\n+\t\treturn days;\n+\t}\n+\n+\t// comparison operators\n+\tinline bool operator==(const date_t &rhs) const {\n+\t\treturn days == rhs.days;\n+\t};\n+\tinline bool operator!=(const date_t &rhs) const {\n+\t\treturn days != rhs.days;\n+\t};\n+\tinline bool operator<=(const date_t &rhs) const {\n+\t\treturn days <= rhs.days;\n+\t};\n+\tinline bool operator<(const date_t &rhs) const {\n+\t\treturn days < rhs.days;\n+\t};\n+\tinline bool operator>(const date_t &rhs) const {\n+\t\treturn days > rhs.days;\n+\t};\n+\tinline bool operator>=(const date_t &rhs) const {\n+\t\treturn days >= rhs.days;\n+\t};\n+\n+\t// arithmetic operators\n+\tinline date_t operator+(const int32_t &days) const {\n+\t\treturn date_t(this->days + days);\n+\t};\n+\tinline date_t operator-(const int32_t &days) const {\n+\t\treturn date_t(this->days - days);\n+\t};\n+\n+\t// in-place operators\n+\tinline date_t &operator+=(const int32_t &days) {\n+\t\tthis->days += days;\n+\t\treturn *this;\n+\t};\n+\tinline date_t &operator-=(const int32_t &days) {\n+\t\tthis->days -= days;\n+\t\treturn *this;\n+\t};\n+\n+\t// special values\n+\tstatic inline date_t infinity() {\n+\t\treturn date_t(NumericLimits<int32_t>::Maximum());\n+\t} // NOLINT\n+\tstatic inline date_t ninfinity() {\n+\t\treturn date_t(-NumericLimits<int32_t>::Maximum());\n+\t} // NOLINT\n+\tstatic inline date_t epoch() {\n+\t\treturn date_t(0);\n+\t} // NOLINT\n+};\n+\n //! The Date class is a static class that holds helper functions for the Date type.\n class Date {\n public:\n@@ -136,4 +204,17 @@ class Date {\n private:\n \tstatic void ExtractYearOffset(int32_t &n, int32_t &year, int32_t &year_offset);\n };\n+\n } // namespace duckdb\n+\n+namespace std {\n+\n+//! Date\n+template <>\n+struct hash<duckdb::date_t> {\n+\tstd::size_t operator()(const duckdb::date_t &k) const {\n+\t\tusing std::hash;\n+\t\treturn hash<int32_t>()((int32_t)k);\n+\t}\n+};\n+} // namespace std\ndiff --git a/src/include/duckdb/common/types/datetime.hpp b/src/include/duckdb/common/types/datetime.hpp\nnew file mode 100644\nindex 000000000000..7ee62cb15fb9\n--- /dev/null\n+++ b/src/include/duckdb/common/types/datetime.hpp\n@@ -0,0 +1,110 @@\n+#pragma once\n+\n+#include \"duckdb/common/common.hpp\"\n+\n+#include <functional>\n+\n+namespace duckdb {\n+\n+//! Type used to represent time (microseconds)\n+struct dtime_t { // NOLINT\n+\tint64_t micros;\n+\n+\tdtime_t() = default;\n+\texplicit inline dtime_t(int64_t micros_p) : micros(micros_p) {\n+\t}\n+\tinline dtime_t &operator=(int64_t micros_p) {\n+\t\tmicros = micros_p;\n+\t\treturn *this;\n+\t}\n+\n+\t// explicit conversion\n+\texplicit inline operator int64_t() const {\n+\t\treturn micros;\n+\t}\n+\texplicit inline operator double() const {\n+\t\treturn micros;\n+\t}\n+\n+\t// comparison operators\n+\tinline bool operator==(const dtime_t &rhs) const {\n+\t\treturn micros == rhs.micros;\n+\t};\n+\tinline bool operator!=(const dtime_t &rhs) const {\n+\t\treturn micros != rhs.micros;\n+\t};\n+\tinline bool operator<=(const dtime_t &rhs) const {\n+\t\treturn micros <= rhs.micros;\n+\t};\n+\tinline bool operator<(const dtime_t &rhs) const {\n+\t\treturn micros < rhs.micros;\n+\t};\n+\tinline bool operator>(const dtime_t &rhs) const {\n+\t\treturn micros > rhs.micros;\n+\t};\n+\tinline bool operator>=(const dtime_t &rhs) const {\n+\t\treturn micros >= rhs.micros;\n+\t};\n+\n+\t// arithmetic operators\n+\tinline dtime_t operator+(const int64_t &micros) const {\n+\t\treturn dtime_t(this->micros + micros);\n+\t};\n+\tinline dtime_t operator+(const double &micros) const {\n+\t\treturn dtime_t(this->micros + int64_t(micros));\n+\t};\n+\tinline dtime_t operator-(const int64_t &micros) const {\n+\t\treturn dtime_t(this->micros - micros);\n+\t};\n+\tinline dtime_t operator*(const idx_t &copies) const {\n+\t\treturn dtime_t(this->micros * copies);\n+\t};\n+\tinline dtime_t operator/(const idx_t &copies) const {\n+\t\treturn dtime_t(this->micros / copies);\n+\t};\n+\tinline int64_t operator-(const dtime_t &other) const {\n+\t\treturn this->micros - other.micros;\n+\t};\n+\n+\t// in-place operators\n+\tinline dtime_t &operator+=(const int64_t &micros) {\n+\t\tthis->micros += micros;\n+\t\treturn *this;\n+\t};\n+\tinline dtime_t &operator-=(const int64_t &micros) {\n+\t\tthis->micros -= micros;\n+\t\treturn *this;\n+\t};\n+\tinline dtime_t &operator+=(const dtime_t &other) {\n+\t\tthis->micros += other.micros;\n+\t\treturn *this;\n+\t};\n+\n+\t// special values\n+\tstatic inline dtime_t allballs() {\n+\t\treturn dtime_t(0);\n+\t} // NOLINT\n+};\n+\n+struct dtime_tz_t : public dtime_t {};\n+\n+} // namespace duckdb\n+\n+namespace std {\n+\n+//! Time\n+template <>\n+struct hash<duckdb::dtime_t> {\n+\tstd::size_t operator()(const duckdb::dtime_t &k) const {\n+\t\tusing std::hash;\n+\t\treturn hash<int64_t>()((int64_t)k);\n+\t}\n+};\n+template <>\n+struct hash<duckdb::dtime_tz_t> {\n+\tstd::size_t operator()(const duckdb::dtime_tz_t &k) const {\n+\t\tusing std::hash;\n+\t\treturn hash<int64_t>()((int64_t)k);\n+\t}\n+};\n+} // namespace std\ndiff --git a/src/include/duckdb/common/types/hash.hpp b/src/include/duckdb/common/types/hash.hpp\nindex 5509a0618c33..337705a891e5 100644\n--- a/src/include/duckdb/common/types/hash.hpp\n+++ b/src/include/duckdb/common/types/hash.hpp\n@@ -14,6 +14,7 @@\n namespace duckdb {\n \n struct string_t;\n+struct interval_t;\n \n // efficient hash function that maximizes the avalanche effect and minimizes\n // bias\ndiff --git a/src/include/duckdb/common/types/hugeint.hpp b/src/include/duckdb/common/types/hugeint.hpp\nindex c7a5f2cabc76..7457cab47909 100644\n--- a/src/include/duckdb/common/types/hugeint.hpp\n+++ b/src/include/duckdb/common/types/hugeint.hpp\n@@ -9,6 +9,7 @@\n #pragma once\n \n #include \"duckdb/common/types.hpp\"\n+#include \"duckdb/common/type_util.hpp\"\n #include \"duckdb/common/limits.hpp\"\n #include \"duckdb/common/exception.hpp\"\n \ndiff --git a/src/include/duckdb/common/types/interval.hpp b/src/include/duckdb/common/types/interval.hpp\nindex b17daa44aa0b..8ed91cfe6eaf 100644\n--- a/src/include/duckdb/common/types/interval.hpp\n+++ b/src/include/duckdb/common/types/interval.hpp\n@@ -12,6 +12,20 @@\n \n namespace duckdb {\n \n+struct dtime_t;\n+struct date_t;\n+struct timestamp_t;\n+\n+struct interval_t {\n+\tint32_t months;\n+\tint32_t days;\n+\tint64_t micros;\n+\n+\tinline bool operator==(const interval_t &rhs) const {\n+\t\treturn this->days == rhs.days && this->months == rhs.months && this->micros == rhs.micros;\n+\t}\n+};\n+\n //! The Interval class is a static class that holds helper functions for the Interval\n //! type.\n class Interval {\ndiff --git a/src/include/duckdb/common/types/null_value.hpp b/src/include/duckdb/common/types/null_value.hpp\nindex 0456836b3203..7671567142a2 100644\n--- a/src/include/duckdb/common/types/null_value.hpp\n+++ b/src/include/duckdb/common/types/null_value.hpp\n@@ -11,6 +11,7 @@\n #include \"duckdb/common/common.hpp\"\n #include \"duckdb/common/types/string_type.hpp\"\n #include \"duckdb/common/types.hpp\"\n+#include \"duckdb/common/types/interval.hpp\"\n #include \"duckdb/common/limits.hpp\"\n #include \"duckdb/common/windows_undefs.hpp\"\n \ndiff --git a/src/include/duckdb/common/types/time.hpp b/src/include/duckdb/common/types/time.hpp\nindex b79c8f066966..0b4871fecf03 100644\n--- a/src/include/duckdb/common/types/time.hpp\n+++ b/src/include/duckdb/common/types/time.hpp\n@@ -14,6 +14,8 @@\n \n namespace duckdb {\n \n+struct dtime_t;\n+\n //! The Time class is a static class that holds helper functions for the Time\n //! type.\n class Time {\ndiff --git a/src/include/duckdb/common/types/timestamp.hpp b/src/include/duckdb/common/types/timestamp.hpp\nindex 461075a57415..f1a6eab90f75 100644\n--- a/src/include/duckdb/common/types/timestamp.hpp\n+++ b/src/include/duckdb/common/types/timestamp.hpp\n@@ -9,11 +9,89 @@\n #pragma once\n \n #include \"duckdb/common/common.hpp\"\n+#include \"duckdb/common/limits.hpp\"\n #include \"duckdb/common/types.hpp\"\n #include \"duckdb/common/winapi.hpp\"\n \n+#include <functional>\n+\n namespace duckdb {\n \n+struct date_t;\n+struct dtime_t;\n+\n+//! Type used to represent timestamps (seconds,microseconds,milliseconds or nanoseconds since 1970-01-01)\n+struct timestamp_t { // NOLINT\n+\tint64_t value;\n+\n+\ttimestamp_t() = default;\n+\texplicit inline timestamp_t(int64_t value_p) : value(value_p) {\n+\t}\n+\tinline timestamp_t &operator=(int64_t value_p) {\n+\t\tvalue = value_p;\n+\t\treturn *this;\n+\t}\n+\n+\t// explicit conversion\n+\texplicit inline operator int64_t() const {\n+\t\treturn value;\n+\t}\n+\n+\t// comparison operators\n+\tinline bool operator==(const timestamp_t &rhs) const {\n+\t\treturn value == rhs.value;\n+\t};\n+\tinline bool operator!=(const timestamp_t &rhs) const {\n+\t\treturn value != rhs.value;\n+\t};\n+\tinline bool operator<=(const timestamp_t &rhs) const {\n+\t\treturn value <= rhs.value;\n+\t};\n+\tinline bool operator<(const timestamp_t &rhs) const {\n+\t\treturn value < rhs.value;\n+\t};\n+\tinline bool operator>(const timestamp_t &rhs) const {\n+\t\treturn value > rhs.value;\n+\t};\n+\tinline bool operator>=(const timestamp_t &rhs) const {\n+\t\treturn value >= rhs.value;\n+\t};\n+\n+\t// arithmetic operators\n+\tinline timestamp_t operator+(const double &value) const {\n+\t\treturn timestamp_t(this->value + int64_t(value));\n+\t};\n+\tinline int64_t operator-(const timestamp_t &other) const {\n+\t\treturn this->value - other.value;\n+\t};\n+\n+\t// in-place operators\n+\tinline timestamp_t &operator+=(const int64_t &value) {\n+\t\tthis->value += value;\n+\t\treturn *this;\n+\t};\n+\tinline timestamp_t &operator-=(const int64_t &value) {\n+\t\tthis->value -= value;\n+\t\treturn *this;\n+\t};\n+\n+\t// special values\n+\tstatic timestamp_t infinity() {\n+\t\treturn timestamp_t(NumericLimits<int64_t>::Maximum());\n+\t} // NOLINT\n+\tstatic timestamp_t ninfinity() {\n+\t\treturn timestamp_t(-NumericLimits<int64_t>::Maximum());\n+\t} // NOLINT\n+\tstatic inline timestamp_t epoch() {\n+\t\treturn timestamp_t(0);\n+\t} // NOLINT\n+};\n+\n+struct timestamp_tz_t : public timestamp_t {};\n+struct timestamp_ns_t : public timestamp_t {};\n+struct timestamp_ms_t : public timestamp_t {};\n+struct timestamp_sec_t : public timestamp_t {};\n+\n //! The Timestamp class is a static class that holds helper functions for the Timestamp\n //! type.\n class Timestamp {\n@@ -77,4 +155,45 @@ class Timestamp {\n \tDUCKDB_API static string ConversionError(const string &str);\n \tDUCKDB_API static string ConversionError(string_t str);\n };\n+\n } // namespace duckdb\n+\n+namespace std {\n+\n+//! Timestamp\n+template <>\n+struct hash<duckdb::timestamp_t> {\n+\tstd::size_t operator()(const duckdb::timestamp_t &k) const {\n+\t\tusing std::hash;\n+\t\treturn hash<int64_t>()((int64_t)k);\n+\t}\n+};\n+template <>\n+struct hash<duckdb::timestamp_ms_t> {\n+\tstd::size_t operator()(const duckdb::timestamp_ms_t &k) const {\n+\t\tusing std::hash;\n+\t\treturn hash<int64_t>()((int64_t)k);\n+\t}\n+};\n+template <>\n+struct hash<duckdb::timestamp_ns_t> {\n+\tstd::size_t operator()(const duckdb::timestamp_ns_t &k) const {\n+\t\tusing std::hash;\n+\t\treturn hash<int64_t>()((int64_t)k);\n+\t}\n+};\n+template <>\n+struct hash<duckdb::timestamp_sec_t> {\n+\tstd::size_t operator()(const duckdb::timestamp_sec_t &k) const {\n+\t\tusing std::hash;\n+\t\treturn hash<int64_t>()((int64_t)k);\n+\t}\n+};\n+template <>\n+struct hash<duckdb::timestamp_tz_t> {\n+\tstd::size_t operator()(const duckdb::timestamp_tz_t &k) const {\n+\t\tusing std::hash;\n+\t\treturn hash<int64_t>()((int64_t)k);\n+\t}\n+};\n+} // namespace std\ndiff --git a/src/include/duckdb/common/types/value.hpp b/src/include/duckdb/common/types/value.hpp\nindex 246129021b6f..4ee4c15ab1a1 100644\n--- a/src/include/duckdb/common/types/value.hpp\n+++ b/src/include/duckdb/common/types/value.hpp\n@@ -12,6 +12,10 @@\n #include \"duckdb/common/exception.hpp\"\n #include \"duckdb/common/types.hpp\"\n #include \"duckdb/common/winapi.hpp\"\n+#include \"duckdb/common/types/timestamp.hpp\"\n+#include \"duckdb/common/types/date.hpp\"\n+#include \"duckdb/common/types/datetime.hpp\"\n+#include \"duckdb/common/types/interval.hpp\"\n \n namespace duckdb {\n \n",
  "test_patch": "diff --git a/test/api/CMakeLists.txt b/test/api/CMakeLists.txt\nindex a35f11815ef1..2830f7197f95 100644\n--- a/test/api/CMakeLists.txt\n+++ b/test/api/CMakeLists.txt\n@@ -17,7 +17,8 @@ set(TEST_API_OBJECTS\n     test_query_profiler.cpp\n     test_dbdir.cpp\n     test_progress_bar.cpp\n-    test_threads.cpp)\n+    test_threads.cpp\n+    test_windows_header_compatibility.cpp)\n \n if(NOT WIN32)\n   set(TEST_API_OBJECTS ${TEST_API_OBJECTS} test_read_only.cpp)\ndiff --git a/test/api/test_windows_header_compatibility.cpp b/test/api/test_windows_header_compatibility.cpp\nnew file mode 100644\nindex 000000000000..e7121e60644a\n--- /dev/null\n+++ b/test/api/test_windows_header_compatibility.cpp\n@@ -0,0 +1,20 @@\n+#ifdef _WIN32\n+#include <windows.h>\n+#endif\n+#include \"catch.hpp\"\n+#include \"test_helpers.hpp\"\n+#include \"duckdb.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+TEST_CASE(\"Test compatibility with windows.h\", \"[windows]\") {\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\t// This test solely exists to check if compilation is hindered by including windows.h\n+\t// before including duckdb.hpp\n+\tcon.BeginTransaction();\n+\tcon.Query(\"select 42;\");\n+\tcon.Commit();\n+}\ndiff --git a/test/sql/storage/compression/chimp/chimp_read.test b/test/sql/storage/compression/chimp/chimp_read.test_slow\nsimilarity index 93%\nrename from test/sql/storage/compression/chimp/chimp_read.test\nrename to test/sql/storage/compression/chimp/chimp_read.test_slow\nindex 7b3c242d42d8..1bb2f26a8581 100644\n--- a/test/sql/storage/compression/chimp/chimp_read.test\n+++ b/test/sql/storage/compression/chimp/chimp_read.test_slow\n@@ -1,4 +1,4 @@\n-# name: test/sql/storage/compression/chimp/chimp_read.test\n+# name: test/sql/storage/compression/chimp/chimp_read.test_slow\n # group: [chimp]\n \n require parquet\ndiff --git a/test/sql/storage/compression/chimp/chimp_read_float.test b/test/sql/storage/compression/chimp/chimp_read_float.test_slow\nsimilarity index 99%\nrename from test/sql/storage/compression/chimp/chimp_read_float.test\nrename to test/sql/storage/compression/chimp/chimp_read_float.test_slow\nindex f95c276b000b..8b3feb70f40a 100644\n--- a/test/sql/storage/compression/chimp/chimp_read_float.test\n+++ b/test/sql/storage/compression/chimp/chimp_read_float.test_slow\n@@ -1,4 +1,4 @@\n-# name: test/sql/storage/compression/chimp/chimp_read_float.test\n+# name: test/sql/storage/compression/chimp/chimp_read_float.test_slow\n # group: [chimp]\n \n require parquet\ndiff --git a/test/sql/storage/compression/patas/patas_read.test b/test/sql/storage/compression/patas/patas_read.test_slow\nsimilarity index 93%\nrename from test/sql/storage/compression/patas/patas_read.test\nrename to test/sql/storage/compression/patas/patas_read.test_slow\nindex 9de23a43010a..e50fd9be79d8 100644\n--- a/test/sql/storage/compression/patas/patas_read.test\n+++ b/test/sql/storage/compression/patas/patas_read.test_slow\n@@ -1,4 +1,4 @@\n-# name: test/sql/storage/compression/patas/patas_read.test\n+# name: test/sql/storage/compression/patas/patas_read.test_slow\n # group: [patas]\n \n require parquet\ndiff --git a/test/sql/storage/compression/patas/patas_skip.test b/test/sql/storage/compression/patas/patas_skip.test_slow\nsimilarity index 94%\nrename from test/sql/storage/compression/patas/patas_skip.test\nrename to test/sql/storage/compression/patas/patas_skip.test_slow\nindex 8560836ea705..d3aa2202e036 100644\n--- a/test/sql/storage/compression/patas/patas_skip.test\n+++ b/test/sql/storage/compression/patas/patas_skip.test_slow\n@@ -1,4 +1,4 @@\n-# name: test/sql/storage/compression/patas/patas_skip.test\n+# name: test/sql/storage/compression/patas/patas_skip.test_slow\n # group: [patas]\n \n # load the DB from disk\ndiff --git a/test/sql/storage/test_buffer_manager.cpp b/test/sql/storage/test_buffer_manager.cpp\nindex 5e267a91cb8b..4cdfa3098d31 100644\n--- a/test/sql/storage/test_buffer_manager.cpp\n+++ b/test/sql/storage/test_buffer_manager.cpp\n@@ -240,7 +240,7 @@ TEST_CASE(\"Test buffer reallocation\", \"[storage][.]\") {\n \tDuckDB db(storage_database, config.get());\n \n #if defined(DEBUG) || defined(DUCKDB_FORCE_ASSERT)\n-\tauto align = [](idx_t requested_size) {\n+\tauto align_value = [](idx_t requested_size) {\n \t\treturn AlignValue<idx_t, Storage::SECTOR_SIZE>(requested_size);\n \t};\n #endif\n@@ -256,11 +256,11 @@ TEST_CASE(\"Test buffer reallocation\", \"[storage][.]\") {\n \tidx_t requested_size = Storage::BLOCK_SIZE;\n \tauto block = buffer_manager.RegisterMemory(requested_size, false);\n \tauto handle = buffer_manager.Pin(block);\n-\tD_ASSERT(buffer_manager.GetUsedMemory() == align(requested_size + Storage::BLOCK_HEADER_SIZE));\n+\tD_ASSERT(buffer_manager.GetUsedMemory() == align_value(requested_size + Storage::BLOCK_HEADER_SIZE));\n \tfor (; requested_size < limit; requested_size *= 2) {\n \t\t// increase size\n \t\tbuffer_manager.ReAllocate(block, requested_size);\n-\t\tD_ASSERT(buffer_manager.GetUsedMemory() == align(requested_size + Storage::BLOCK_HEADER_SIZE));\n+\t\tD_ASSERT(buffer_manager.GetUsedMemory() == align_value(requested_size + Storage::BLOCK_HEADER_SIZE));\n \t\t// unpin and make sure it's evicted\n \t\thandle.Destroy();\n \t\tREQUIRE_NO_FAIL(con.Query(StringUtil::Format(\"PRAGMA memory_limit='%lldB'\", requested_size)));\n@@ -268,13 +268,13 @@ TEST_CASE(\"Test buffer reallocation\", \"[storage][.]\") {\n \t\t// re-pin\n \t\tREQUIRE_NO_FAIL(con.Query(StringUtil::Format(\"PRAGMA memory_limit='%lldB'\", limit)));\n \t\thandle = buffer_manager.Pin(block);\n-\t\tD_ASSERT(buffer_manager.GetUsedMemory() == align(requested_size + Storage::BLOCK_HEADER_SIZE));\n+\t\tD_ASSERT(buffer_manager.GetUsedMemory() == align_value(requested_size + Storage::BLOCK_HEADER_SIZE));\n \t}\n \trequested_size /= 2;\n \tfor (; requested_size > Storage::BLOCK_SIZE; requested_size /= 2) {\n \t\t// decrease size\n \t\tbuffer_manager.ReAllocate(block, requested_size);\n-\t\tD_ASSERT(buffer_manager.GetUsedMemory() == align(requested_size + Storage::BLOCK_HEADER_SIZE));\n+\t\tD_ASSERT(buffer_manager.GetUsedMemory() == align_value(requested_size + Storage::BLOCK_HEADER_SIZE));\n \t\t// unpin and make sure it's evicted\n \t\thandle.Destroy();\n \t\tREQUIRE_NO_FAIL(con.Query(StringUtil::Format(\"PRAGMA memory_limit='%lldB'\", requested_size)));\n@@ -282,7 +282,7 @@ TEST_CASE(\"Test buffer reallocation\", \"[storage][.]\") {\n \t\t// re-pin\n \t\tREQUIRE_NO_FAIL(con.Query(StringUtil::Format(\"PRAGMA memory_limit='%lldB'\", limit)));\n \t\thandle = buffer_manager.Pin(block);\n-\t\tD_ASSERT(buffer_manager.GetUsedMemory() == align(requested_size + Storage::BLOCK_HEADER_SIZE));\n+\t\tD_ASSERT(buffer_manager.GetUsedMemory() == align_value(requested_size + Storage::BLOCK_HEADER_SIZE));\n \t}\n }\n \n",
  "problem_statement": "DuckDB 0.6.0 on Windows (MSVC) Compile Error \nDuckDB 0.6.0 on Windows (MSVC) Compile Error:\r\n.../test/sql/storage/test_buffer_manager.cpp(263): error C2660: 'std::align': function does not take 1 arguments\r\n\r\nHere is 0.6.0 version of test_buffer_manager.cpp (error):\r\nD_ASSERT(buffer_manager.GetUsedMemory() == align(requested_size + Storage::BLOCK_HEADER_SIZE));\r\n\r\nHere is 0.5.1 version of test_buffer_manager.cpp (without error):\r\nD_ASSERT(buffer_manager.GetUsedMemory() == requested_size + Storage::BLOCK_HEADER_SIZE);\r\n\r\nBTW: DuckDB not available via VCPKG...\n",
  "hints_text": "One more issue on Windows while trying to compile C++ app...\r\n\r\nError\tC2589\t'(': illegal token on right side of '::' on:\r\n...\\src\\include\\duckdb\\common\\types.hpp\r\n\tstatic inline date_t infinity() {return date_t(std::numeric_limits<int32_t>::max()); } // NOLINT\r\n\tstatic inline date_t ninfinity() {return date_t(-std::numeric_limits<int32_t>::max()); } // NOLINT\r\n\r\nProblem is caused by the <Windows.h> header file that includes macro definition max:\r\n#define max(a,b) (((a) > (b)) ? (a) : (b))\r\n\r\nWorkaround:\r\n#define NOMINMAX \nCould you please make this a reproducible example instead of just posting compiler errors, for example, how is your project setup, which version of msvc are you using on which version of windows etc.\nAs much as this is definitely not the way issue submission works, there is a point to be made here\r\nWe use `using namespace std;` in `test_buffer_manager.cpp` and then we also define a `align` function, which conflicts with `std::align`",
  "created_at": "2022-11-17T09:40:46Z"
}