{
  "repo": "duckdb/duckdb",
  "pull_number": 1096,
  "instance_id": "duckdb__duckdb-1096",
  "issue_numbers": [
    "1067"
  ],
  "base_commit": "7ac2446682bc701933e1863a0d93f90135fee80f",
  "patch": "diff --git a/src/parser/transform/statement/transform_select_node.cpp b/src/parser/transform/statement/transform_select_node.cpp\nindex 4f991ba8f714..a65e0fb7a83c 100644\n--- a/src/parser/transform/statement/transform_select_node.cpp\n+++ b/src/parser/transform/statement/transform_select_node.cpp\n@@ -33,6 +33,20 @@ unique_ptr<QueryNode> Transformer::TransformSelectNode(PGSelectStmt *stmt) {\n \t\t\t}\n \t\t}\n \n+\t\t// checks distinct clause\n+\t\tif (stmt->distinctClause != NULL) {\n+\t\t\tauto modifier = make_unique<DistinctModifier>();\n+\t\t\t// checks distinct on clause\n+\t\t\tauto target = reinterpret_cast<PGNode *>(stmt->distinctClause->head->data.ptr_value);\n+\t\t\tif (target) {\n+\t\t\t\t//  add the columns defined in the ON clause to the select list\n+\t\t\t\tif (!TransformExpressionList(stmt->distinctClause, modifier->distinct_on_targets)) {\n+\t\t\t\t\tthrow Exception(\"Failed to transform expression list from DISTINCT ON.\");\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tresult->modifiers.push_back(move(modifier));\n+\t\t}\n+\n \t\t// do this early so the value lists also have a `FROM`\n \t\tif (stmt->valuesLists) {\n \t\t\t// VALUES list, create an ExpressionList\n@@ -40,34 +54,22 @@ unique_ptr<QueryNode> Transformer::TransformSelectNode(PGSelectStmt *stmt) {\n \t\t\tresult->from_table = TransformValuesList(stmt->valuesLists);\n \t\t\tresult->select_list.push_back(make_unique<StarExpression>());\n \t\t} else {\n-\t\t\tresult->from_table = TransformFrom(stmt->fromClause);\n \t\t\tif (!stmt->targetList) {\n \t\t\t\tthrow ParserException(\"SELECT clause without selection list\");\n \t\t\t}\n \t\t\t// select list\n \t\t\tif (!TransformExpressionList(stmt->targetList, result->select_list)) {\n-\t\t\t\tthrow Exception(\"Failed to transform expression list.\");\n-\t\t\t}\n-\t\t}\n-\t\t// checks distinct clause\n-\t\tif (stmt->distinctClause != NULL) {\n-\t\t\tauto modifier = make_unique<DistinctModifier>();\n-\t\t\t// checks distinct on clause\n-\t\t\tauto target = reinterpret_cast<PGNode *>(stmt->distinctClause->head->data.ptr_value);\n-\t\t\tif (target) {\n-\t\t\t\t//  add the columns defined in the ON clause to the select list\n-\t\t\t\tif (!TransformExpressionList(stmt->distinctClause, modifier->distinct_on_targets)) {\n-\t\t\t\t\tthrow Exception(\"Failed to transform expression list from DISTINCT ON.\");\n-\t\t\t\t}\n+\t\t\t\tthrow InternalException(\"Failed to transform expression list.\");\n \t\t\t}\n-\t\t\tresult->modifiers.push_back(move(modifier));\n+\t\t\tresult->from_table = TransformFrom(stmt->fromClause);\n \t\t}\n-\t\t// from table\n+\n+\t\t// where\n+\t\tresult->where_clause = TransformExpression(stmt->whereClause);\n \t\t// group by\n \t\tTransformGroupBy(stmt->groupClause, result->groups);\n+\t\t// having\n \t\tresult->having = TransformExpression(stmt->havingClause);\n-\t\t// where\n-\t\tresult->where_clause = TransformExpression(stmt->whereClause);\n \t\tbreak;\n \t}\n \tcase PG_SETOP_UNION:\ndiff --git a/src/parser/transform/statement/transform_update.cpp b/src/parser/transform/statement/transform_update.cpp\nindex 41c6b194ce59..b6d04adc0193 100644\n--- a/src/parser/transform/statement/transform_update.cpp\n+++ b/src/parser/transform/statement/transform_update.cpp\n@@ -16,14 +16,14 @@ unique_ptr<UpdateStatement> Transformer::TransformUpdate(PGNode *node) {\n \t\tresult->from_table = TransformFrom(stmt->fromClause);\n \t}\n \n-\tresult->condition = TransformExpression(stmt->whereClause);\n-\n \tauto root = stmt->targetList;\n \tfor (auto cell = root->head; cell != NULL; cell = cell->next) {\n \t\tauto target = (PGResTarget *)(cell->data.ptr_value);\n \t\tresult->columns.push_back(target->name);\n \t\tresult->expressions.push_back(TransformExpression(target->val));\n \t}\n+\n+\tresult->condition = TransformExpression(stmt->whereClause);\n \treturn result;\n }\n \n",
  "test_patch": "diff --git a/test/sql/prepared/prepared_select.test b/test/sql/prepared/prepared_select.test\nnew file mode 100644\nindex 000000000000..4ef01ca014c5\n--- /dev/null\n+++ b/test/sql/prepared/prepared_select.test\n@@ -0,0 +1,62 @@\n+# name: test/sql/prepared/prepared_select.test\n+# description: Test order of unmarked prepared statements in select\n+# group: [prepared]\n+\n+# select - from - where with subquery\n+statement ok\n+PREPARE s1 AS SELECT ?::VARCHAR FROM (SELECT ?::INTEGER) tbl(i) WHERE i > ?::INTEGER\n+\n+query I\n+EXECUTE s1('hello', 2, 1)\n+----\n+hello\n+\n+# select - from - where - groupby - having\n+statement ok\n+PREPARE s2 AS\n+SELECT FIRST(?::VARCHAR)\n+FROM (VALUES (?::INTEGER)) tbl(i)\n+WHERE i > ?::INTEGER\n+GROUP BY i % ?::INTEGER\n+HAVING SUM(i)::VARCHAR <> ?::VARCHAR\n+\n+query I\n+EXECUTE s2('hello', 2, 1, 2, 'blabla')\n+----\n+hello\n+\n+query I\n+EXECUTE s2('hello', 2, 1, 2, '2')\n+----\n+\n+# union\n+statement ok\n+PREPARE s3 AS\n+SELECT LENGTH(?::VARCHAR)\n+UNION ALL\n+SELECT ?::INTEGER\n+ORDER BY 1\n+\n+query I\n+EXECUTE s3('hello', 3)\n+----\n+3\n+5\n+\n+# IN clause\n+statement ok\n+PREPARE s4 AS SELECT ?::INTEGER IN (?::INTEGER, ?::INTEGER, ?::INTEGER)\n+\n+query I\n+EXECUTE s4(1, 2, 3, 1)\n+----\n+1\n+\n+# IN clause with subquery\n+statement ok\n+PREPARE s5 AS SELECT ?::INTEGER IN (SELECT i FROM (VALUES (?::INTEGER), (?::INTEGER), (?::INTEGER)) tbl(i))\n+\n+query I\n+EXECUTE s5(1, 2, 3, 1)\n+----\n+1\ndiff --git a/test/sql/prepared/prepared_update.test b/test/sql/prepared/prepared_update.test\nnew file mode 100644\nindex 000000000000..038e1bf153d2\n--- /dev/null\n+++ b/test/sql/prepared/prepared_update.test\n@@ -0,0 +1,42 @@\n+# name: test/sql/prepared/prepared_update.test\n+# description: Test order of unmarked prepared statements\n+# group: [prepared]\n+\n+statement ok\n+CREATE TABLE integers(i INTEGER, j VARCHAR)\n+\n+statement ok\n+INSERT INTO integers VALUES (1, 'hello')\n+\n+statement ok\n+PREPARE s1 AS UPDATE integers SET i=?, j=?;\n+\n+statement ok\n+EXECUTE s1(2, 'world')\n+\n+query II\n+SELECT * FROM integers\n+----\n+2\tworld\n+\n+statement ok\n+PREPARE s2 AS UPDATE integers SET j=? WHERE i=?;\n+\n+statement ok\n+EXECUTE s2('test', 2)\n+\n+query II\n+SELECT * FROM integers\n+----\n+2\ttest\n+\n+statement ok\n+PREPARE s3 AS UPDATE integers SET j=? WHERE i=? AND j=?;\n+\n+statement ok\n+EXECUTE s3('test2', 2, 'test')\n+\n+query II\n+SELECT * FROM integers\n+----\n+2\ttest2\n",
  "problem_statement": "C++ documentation for prepared statements\nI don't know how to write `prepared statements in C++` the same as in `C API`. The C++ API has a lot of **//TO DO** blocks in the example section. Please complete the example section in C++\r\n\r\nI tried this but it throws **_expected body of lambda expression_**\r\n```\r\nduckdb::DuckDB db(nullptr);\r\nduckdb::Connection con(db);\r\n\r\n// Rest of the code block\r\n.....\r\n// Rest of the code block\r\n\r\n\r\nstring name = \"Mark2\";\r\nint id = 1;\r\n\r\n// error here: expected body of lambda expression\r\ncon.Prepare(\"UPDATE people SET name = ? WHERE id = ?\", [name, id]);\r\n\r\n```\n",
  "hints_text": "The error thrown is not from us, but rather from the C++ compiler. The bracket operator `[]` indicates the start of a lambda function (e.g. `[](int a, int b) {return a + b}`). The error states that the system expects the rest of the lambda expression. [Read more about it here](https://www.geeksforgeeks.org/lambda-expression-in-c/).\r\n\r\nI think what you are trying to do here is:\r\n\r\n```cpp\r\ncon.Execute(\"UPDATE people SET name = ? WHERE id = ?\", name, id);\r\n```\r\n\r\nThe `Prepare` method returns a prepared statement object that can be executed, e.g.:\r\n```cpp\r\nauto prepared = con.Prepare(\"UPDATE people SET name = ? WHERE id = ?\");\r\nprepared->Execute(name, id);\r\n```\r\n\r\nSee [`test/api/test_prepared_api.cpp`](https://github.com/cwida/duckdb/blob/f9f597620ce590d6e65efaa6faf66d5639714cb1/test/api/test_prepared_api.cpp) for some more examples.\nThanks @Mytherin . \r\n\r\nMy bad and I should not have mentioned my compiler-specific error here. \nHi @Mytherin, I think there is an issue in the `prepared->Execute(name, id)` statement. It seems, the parameters are not accepted in the order they are mentioned.\r\nI get the desired result only when I write `prepared->Execute(id, name)`. Can you check this issue?\nThat's a good point, thanks for the report! Indeed the unmarked parameters should be resolved in the order that they appear in the query. You can circumvent this issue by explicitly marking the prepared statement parameters with their id (e.g. `UPDATE people SET name = $1 WHERE id = $2`). ",
  "created_at": "2020-11-08T18:17:57Z"
}