diff --git a/src/parser/transform/statement/transform_select_node.cpp b/src/parser/transform/statement/transform_select_node.cpp
index 4f991ba8f714..a65e0fb7a83c 100644
--- a/src/parser/transform/statement/transform_select_node.cpp
+++ b/src/parser/transform/statement/transform_select_node.cpp
@@ -33,6 +33,20 @@ unique_ptr<QueryNode> Transformer::TransformSelectNode(PGSelectStmt *stmt) {
 			}
 		}
 
+		// checks distinct clause
+		if (stmt->distinctClause != NULL) {
+			auto modifier = make_unique<DistinctModifier>();
+			// checks distinct on clause
+			auto target = reinterpret_cast<PGNode *>(stmt->distinctClause->head->data.ptr_value);
+			if (target) {
+				//  add the columns defined in the ON clause to the select list
+				if (!TransformExpressionList(stmt->distinctClause, modifier->distinct_on_targets)) {
+					throw Exception("Failed to transform expression list from DISTINCT ON.");
+				}
+			}
+			result->modifiers.push_back(move(modifier));
+		}
+
 		// do this early so the value lists also have a `FROM`
 		if (stmt->valuesLists) {
 			// VALUES list, create an ExpressionList
@@ -40,34 +54,22 @@ unique_ptr<QueryNode> Transformer::TransformSelectNode(PGSelectStmt *stmt) {
 			result->from_table = TransformValuesList(stmt->valuesLists);
 			result->select_list.push_back(make_unique<StarExpression>());
 		} else {
-			result->from_table = TransformFrom(stmt->fromClause);
 			if (!stmt->targetList) {
 				throw ParserException("SELECT clause without selection list");
 			}
 			// select list
 			if (!TransformExpressionList(stmt->targetList, result->select_list)) {
-				throw Exception("Failed to transform expression list.");
-			}
-		}
-		// checks distinct clause
-		if (stmt->distinctClause != NULL) {
-			auto modifier = make_unique<DistinctModifier>();
-			// checks distinct on clause
-			auto target = reinterpret_cast<PGNode *>(stmt->distinctClause->head->data.ptr_value);
-			if (target) {
-				//  add the columns defined in the ON clause to the select list
-				if (!TransformExpressionList(stmt->distinctClause, modifier->distinct_on_targets)) {
-					throw Exception("Failed to transform expression list from DISTINCT ON.");
-				}
+				throw InternalException("Failed to transform expression list.");
 			}
-			result->modifiers.push_back(move(modifier));
+			result->from_table = TransformFrom(stmt->fromClause);
 		}
-		// from table
+
+		// where
+		result->where_clause = TransformExpression(stmt->whereClause);
 		// group by
 		TransformGroupBy(stmt->groupClause, result->groups);
+		// having
 		result->having = TransformExpression(stmt->havingClause);
-		// where
-		result->where_clause = TransformExpression(stmt->whereClause);
 		break;
 	}
 	case PG_SETOP_UNION:
diff --git a/src/parser/transform/statement/transform_update.cpp b/src/parser/transform/statement/transform_update.cpp
index 41c6b194ce59..b6d04adc0193 100644
--- a/src/parser/transform/statement/transform_update.cpp
+++ b/src/parser/transform/statement/transform_update.cpp
@@ -16,14 +16,14 @@ unique_ptr<UpdateStatement> Transformer::TransformUpdate(PGNode *node) {
 		result->from_table = TransformFrom(stmt->fromClause);
 	}
 
-	result->condition = TransformExpression(stmt->whereClause);
-
 	auto root = stmt->targetList;
 	for (auto cell = root->head; cell != NULL; cell = cell->next) {
 		auto target = (PGResTarget *)(cell->data.ptr_value);
 		result->columns.push_back(target->name);
 		result->expressions.push_back(TransformExpression(target->val));
 	}
+
+	result->condition = TransformExpression(stmt->whereClause);
 	return result;
 }
 
