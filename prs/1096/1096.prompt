You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
C++ documentation for prepared statements
I don't know how to write `prepared statements in C++` the same as in `C API`. The C++ API has a lot of **//TO DO** blocks in the example section. Please complete the example section in C++

I tried this but it throws **_expected body of lambda expression_**
```
duckdb::DuckDB db(nullptr);
duckdb::Connection con(db);

// Rest of the code block
.....
// Rest of the code block


string name = "Mark2";
int id = 1;

// error here: expected body of lambda expression
con.Prepare("UPDATE people SET name = ? WHERE id = ?", [name, id]);

```

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of src/parser/transform/statement/transform_select_node.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/parser/query_node/select_node.hpp"
3: #include "duckdb/parser/query_node/set_operation_node.hpp"
4: #include "duckdb/parser/statement/select_statement.hpp"
5: #include "duckdb/parser/transformer.hpp"
6: #include "duckdb/parser/expression/star_expression.hpp"
7: #include "duckdb/common/string_util.hpp"
8: 
9: namespace duckdb {
10: using namespace std;
11: using namespace duckdb_libpgquery;
12: 
13: unique_ptr<QueryNode> Transformer::TransformSelectNode(PGSelectStmt *stmt) {
14: 	unique_ptr<QueryNode> node;
15: 
16: 	switch (stmt->op) {
17: 	case PG_SETOP_NONE: {
18: 		node = make_unique<SelectNode>();
19: 		auto result = (SelectNode *)node.get();
20: 
21: 		if (stmt->windowClause) {
22: 			for (auto window_ele = stmt->windowClause->head; window_ele != NULL; window_ele = window_ele->next) {
23: 				auto window_def = reinterpret_cast<PGWindowDef *>(window_ele->data.ptr_value);
24: 				D_ASSERT(window_def);
25: 				D_ASSERT(window_def->name);
26: 				auto window_name = StringUtil::Lower(string(window_def->name));
27: 
28: 				auto it = window_clauses.find(window_name);
29: 				if (it != window_clauses.end()) {
30: 					throw ParserException("window \"%s\" is already defined", window_name);
31: 				}
32: 				window_clauses[window_name] = window_def;
33: 			}
34: 		}
35: 
36: 		// do this early so the value lists also have a `FROM`
37: 		if (stmt->valuesLists) {
38: 			// VALUES list, create an ExpressionList
39: 			D_ASSERT(!stmt->fromClause);
40: 			result->from_table = TransformValuesList(stmt->valuesLists);
41: 			result->select_list.push_back(make_unique<StarExpression>());
42: 		} else {
43: 			result->from_table = TransformFrom(stmt->fromClause);
44: 			if (!stmt->targetList) {
45: 				throw ParserException("SELECT clause without selection list");
46: 			}
47: 			// select list
48: 			if (!TransformExpressionList(stmt->targetList, result->select_list)) {
49: 				throw Exception("Failed to transform expression list.");
50: 			}
51: 		}
52: 		// checks distinct clause
53: 		if (stmt->distinctClause != NULL) {
54: 			auto modifier = make_unique<DistinctModifier>();
55: 			// checks distinct on clause
56: 			auto target = reinterpret_cast<PGNode *>(stmt->distinctClause->head->data.ptr_value);
57: 			if (target) {
58: 				//  add the columns defined in the ON clause to the select list
59: 				if (!TransformExpressionList(stmt->distinctClause, modifier->distinct_on_targets)) {
60: 					throw Exception("Failed to transform expression list from DISTINCT ON.");
61: 				}
62: 			}
63: 			result->modifiers.push_back(move(modifier));
64: 		}
65: 		// from table
66: 		// group by
67: 		TransformGroupBy(stmt->groupClause, result->groups);
68: 		result->having = TransformExpression(stmt->havingClause);
69: 		// where
70: 		result->where_clause = TransformExpression(stmt->whereClause);
71: 		break;
72: 	}
73: 	case PG_SETOP_UNION:
74: 	case PG_SETOP_EXCEPT:
75: 	case PG_SETOP_INTERSECT: {
76: 		node = make_unique<SetOperationNode>();
77: 		auto result = (SetOperationNode *)node.get();
78: 		result->left = TransformSelectNode(stmt->larg);
79: 		result->right = TransformSelectNode(stmt->rarg);
80: 		if (!result->left || !result->right) {
81: 			throw Exception("Failed to transform setop children.");
82: 		}
83: 
84: 		bool select_distinct = true;
85: 		switch (stmt->op) {
86: 		case PG_SETOP_UNION:
87: 			select_distinct = !stmt->all;
88: 			result->setop_type = SetOperationType::UNION;
89: 			break;
90: 		case PG_SETOP_EXCEPT:
91: 			result->setop_type = SetOperationType::EXCEPT;
92: 			break;
93: 		case PG_SETOP_INTERSECT:
94: 			result->setop_type = SetOperationType::INTERSECT;
95: 			break;
96: 		default:
97: 			throw Exception("Unexpected setop type");
98: 		}
99: 		if (select_distinct) {
100: 			result->modifiers.push_back(make_unique<DistinctModifier>());
101: 		}
102: 		break;
103: 	}
104: 	default:
105: 		throw NotImplementedException("Statement type %d not implemented!", stmt->op);
106: 	}
107: 	// transform the common properties
108: 	// both the set operations and the regular select can have an ORDER BY/LIMIT attached to them
109: 	vector<OrderByNode> orders;
110: 	TransformOrderBy(stmt->sortClause, orders);
111: 	if (orders.size() > 0) {
112: 		auto order_modifier = make_unique<OrderModifier>();
113: 		order_modifier->orders = move(orders);
114: 		node->modifiers.push_back(move(order_modifier));
115: 	}
116: 	if (stmt->limitCount || stmt->limitOffset) {
117: 		auto limit_modifier = make_unique<LimitModifier>();
118: 		if (stmt->limitCount) {
119: 			limit_modifier->limit = TransformExpression(stmt->limitCount);
120: 		}
121: 		if (stmt->limitOffset) {
122: 			limit_modifier->offset = TransformExpression(stmt->limitOffset);
123: 		}
124: 		node->modifiers.push_back(move(limit_modifier));
125: 	}
126: 	return node;
127: }
128: 
129: } // namespace duckdb
[end of src/parser/transform/statement/transform_select_node.cpp]
[start of src/parser/transform/statement/transform_update.cpp]
1: #include "duckdb/parser/statement/update_statement.hpp"
2: #include "duckdb/parser/transformer.hpp"
3: 
4: namespace duckdb {
5: using namespace std;
6: using namespace duckdb_libpgquery;
7: 
8: unique_ptr<UpdateStatement> Transformer::TransformUpdate(PGNode *node) {
9: 	auto stmt = reinterpret_cast<PGUpdateStmt *>(node);
10: 	D_ASSERT(stmt);
11: 
12: 	auto result = make_unique<UpdateStatement>();
13: 
14: 	result->table = TransformRangeVar(stmt->relation);
15: 	if (stmt->fromClause) {
16: 		result->from_table = TransformFrom(stmt->fromClause);
17: 	}
18: 
19: 	result->condition = TransformExpression(stmt->whereClause);
20: 
21: 	auto root = stmt->targetList;
22: 	for (auto cell = root->head; cell != NULL; cell = cell->next) {
23: 		auto target = (PGResTarget *)(cell->data.ptr_value);
24: 		result->columns.push_back(target->name);
25: 		result->expressions.push_back(TransformExpression(target->val));
26: 	}
27: 	return result;
28: }
29: 
30: } // namespace duckdb
[end of src/parser/transform/statement/transform_update.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: