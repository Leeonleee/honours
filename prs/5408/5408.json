{
  "repo": "duckdb/duckdb",
  "pull_number": 5408,
  "instance_id": "duckdb__duckdb-5408",
  "issue_numbers": [
    "5395"
  ],
  "base_commit": "228d056b984a3d92c973a8a4a0f538e9eaf3e57b",
  "patch": "diff --git a/src/function/scalar/enum/enum_functions_implementation.cpp b/src/function/scalar/enum/enum_functions_implementation.cpp\nindex 22052feec10c..6b2fe22ded59 100644\n--- a/src/function/scalar/enum/enum_functions_implementation.cpp\n+++ b/src/function/scalar/enum/enum_functions_implementation.cpp\n@@ -61,6 +61,11 @@ static void EnumRangeBoundaryFunction(DataChunk &input, ExpressionState &state,\n \tresult.Reference(val);\n }\n \n+static void EnumCodeFunction(DataChunk &input, ExpressionState &state, Vector &result) {\n+\tD_ASSERT(input.GetTypes().size() == 1);\n+\tresult.Reinterpret(input.data[0]);\n+}\n+\n static void CheckEnumParameter(const Expression &expr) {\n \tif (expr.HasParameter()) {\n \t\tthrow ParameterNotResolvedException();\n@@ -76,6 +81,34 @@ unique_ptr<FunctionData> BindEnumFunction(ClientContext &context, ScalarFunction\n \treturn nullptr;\n }\n \n+unique_ptr<FunctionData> BindEnumCodeFunction(ClientContext &context, ScalarFunction &bound_function,\n+                                              vector<unique_ptr<Expression>> &arguments) {\n+\tCheckEnumParameter(*arguments[0]);\n+\tif (arguments[0]->return_type.id() != LogicalTypeId::ENUM) {\n+\t\tthrow BinderException(\"This function needs an ENUM as an argument\");\n+\t}\n+\n+\tauto phy_type = EnumType::GetPhysicalType(arguments[0]->return_type);\n+\tswitch (phy_type) {\n+\tcase PhysicalType::UINT8:\n+\t\tbound_function.return_type = LogicalType(LogicalTypeId::UTINYINT);\n+\t\tbreak;\n+\tcase PhysicalType::UINT16:\n+\t\tbound_function.return_type = LogicalType(LogicalTypeId::USMALLINT);\n+\t\tbreak;\n+\tcase PhysicalType::UINT32:\n+\t\tbound_function.return_type = LogicalType(LogicalTypeId::UINTEGER);\n+\t\tbreak;\n+\tcase PhysicalType::UINT64:\n+\t\tbound_function.return_type = LogicalType(LogicalTypeId::UBIGINT);\n+\t\tbreak;\n+\tdefault:\n+\t\tthrow InternalException(\"Unsupported Enum Internal Type\");\n+\t}\n+\n+\treturn nullptr;\n+}\n+\n unique_ptr<FunctionData> BindEnumRangeBoundaryFunction(ClientContext &context, ScalarFunction &bound_function,\n                                                        vector<unique_ptr<Expression>> &arguments) {\n \tCheckEnumParameter(*arguments[0]);\n@@ -111,6 +144,13 @@ void EnumLast::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(fun);\n }\n \n+void EnumCode::RegisterFunction(BuiltinFunctions &set) {\n+\tauto fun =\n+\t    ScalarFunction(\"enum_code\", {LogicalType::ANY}, LogicalType::ANY, EnumCodeFunction, BindEnumCodeFunction);\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\tset.AddFunction(fun);\n+}\n+\n void EnumRange::RegisterFunction(BuiltinFunctions &set) {\n \tauto fun = ScalarFunction(\"enum_range\", {LogicalType::ANY}, LogicalType::LIST(LogicalType::VARCHAR),\n \t                          EnumRangeFunction, BindEnumFunction);\ndiff --git a/src/function/scalar/enum_functions.cpp b/src/function/scalar/enum_functions.cpp\nindex bd620221d687..5d6303a10c29 100644\n--- a/src/function/scalar/enum_functions.cpp\n+++ b/src/function/scalar/enum_functions.cpp\n@@ -5,6 +5,7 @@ namespace duckdb {\n void BuiltinFunctions::RegisterEnumFunctions() {\n \tRegister<EnumFirst>();\n \tRegister<EnumLast>();\n+\tRegister<EnumCode>();\n \tRegister<EnumRange>();\n \tRegister<EnumRangeBoundary>();\n }\ndiff --git a/src/include/duckdb/function/scalar/enum_functions.hpp b/src/include/duckdb/function/scalar/enum_functions.hpp\nindex 6a21b379f943..53e06a791a0c 100644\n--- a/src/include/duckdb/function/scalar/enum_functions.hpp\n+++ b/src/include/duckdb/function/scalar/enum_functions.hpp\n@@ -21,6 +21,10 @@ struct EnumLast {\n \tstatic void RegisterFunction(BuiltinFunctions &set);\n };\n \n+struct EnumCode {\n+\tstatic void RegisterFunction(BuiltinFunctions &set);\n+};\n+\n struct EnumRange {\n \tstatic void RegisterFunction(BuiltinFunctions &set);\n };\n",
  "test_patch": "diff --git a/test/sql/function/enum/test_enum_code.test b/test/sql/function/enum/test_enum_code.test\nnew file mode 100644\nindex 000000000000..bef744df4a76\n--- /dev/null\n+++ b/test/sql/function/enum/test_enum_code.test\n@@ -0,0 +1,45 @@\n+# name: test/sql/function/enum/test_enum_code.test\n+# description: Enum Code Function\n+# group: [enum]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy', 'anxious')\n+\n+statement ok\n+CREATE TABLE test (x mood)\n+\n+statement ok\n+INSERT INTO test VALUES ('ok'), ('sad'), ('anxious'), ('happy')\n+\n+query I\n+SELECT enum_code(x) FROM test\n+----\n+1\n+0\n+3\n+2\n+\n+statement error\n+SELECT enum_code('bla')\n+\n+statement ok\n+PREPARE p1 as SELECT enum_code(x) FROM test\n+\n+query I\n+EXECUTE p1\n+----\n+1\n+0\n+3\n+2\n+\n+statement ok\n+PREPARE p2 as SELECT enum_code(?);\n+\n+query I\n+EXECUTE p2('happy'::mood)\n+----\n+2\n",
  "problem_statement": "Feature request: retrieve integer index values from an ENUM column using SQL\nI'd like to have the option to retrieve the underlying index values from an ENUM-typed column using SQL. Perhaps this could be done by explicitly casting the column to an int?\r\n\r\nFor instance, given the following setup code:\r\n```sql\r\nCREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');\r\nCREATE TABLE person (\r\n    name text,\r\n    current_mood mood\r\n);\r\nINSERT INTO person VALUES ('Moe','happy'), ('Dave', NULL), ('Larry', 'sad'), ('Curly, 'ok');\r\n```\r\n\r\nAnd this query:\r\n```sql\r\nSELECT\r\n  name, CAST(current_mood AS INTEGER) AS mood_index\r\nFROM\r\n  person;\r\n```\r\n\r\nThe results would look like:\r\n\r\nname  | mood_index\r\n----- | ----------\r\nMoe   | 2\r\nDave  | NULL\r\nLarry | 0\r\nCurly | 1\r\n\r\nApologies if there's already a way to do this which I've missed. And thanks so much for DuckDB! It's a staggeringly impressive piece of software.\r\n\n",
  "hints_text": "I couldn't find a function that does this, looking at the documentation\r\nMaybe it should just be a function? `enum_value(x)` ?",
  "created_at": "2022-11-18T16:10:25Z"
}