{
  "repo": "duckdb/duckdb",
  "pull_number": 14675,
  "instance_id": "duckdb__duckdb-14675",
  "issue_numbers": [
    "14663"
  ],
  "base_commit": "56bd3084a6accab1578c14a2fce2647eb4561b6d",
  "patch": "diff --git a/src/function/scalar/string/concat.cpp b/src/function/scalar/string/concat.cpp\nindex be879f0176bd..a6a495a95a6b 100644\n--- a/src/function/scalar/string/concat.cpp\n+++ b/src/function/scalar/string/concat.cpp\n@@ -155,14 +155,14 @@ struct ListConcatInputData {\n \tconst list_entry_t *input_entries = nullptr;\n };\n \n-static void ListConcatFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+static void ListConcatFunction(DataChunk &args, ExpressionState &state, Vector &result, bool is_operator) {\n \tauto count = args.size();\n \n \tauto result_entries = FlatVector::GetData<list_entry_t>(result);\n \tvector<ListConcatInputData> input_data;\n \tfor (auto &input : args.data) {\n-\t\tif (input.GetType().id() == LogicalTypeId::SQLNULL) {\n-\t\t\t// ignore NULL values\n+\t\tif (!is_operator && input.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\t\t// LIST_CONCAT ignores NULL values\n \t\t\tcontinue;\n \t\t}\n \n@@ -178,6 +178,7 @@ static void ListConcatFunction(DataChunk &args, ExpressionState &state, Vector &\n \t\tinput_data.push_back(std::move(data));\n \t}\n \n+\tauto &result_validity = FlatVector::Validity(result);\n \tidx_t offset = 0;\n \tfor (idx_t i = 0; i < count; i++) {\n \t\tauto &result_entry = result_entries[i];\n@@ -186,6 +187,10 @@ static void ListConcatFunction(DataChunk &args, ExpressionState &state, Vector &\n \t\tfor (auto &data : input_data) {\n \t\t\tauto list_index = data.vdata.sel->get_index(i);\n \t\t\tif (!data.vdata.validity.RowIsValid(list_index)) {\n+\t\t\t\t// LIST_CONCAT ignores NULL values, but || does not\n+\t\t\t\tif (is_operator) {\n+\t\t\t\t\tresult_validity.SetInvalid(i);\n+\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tconst auto &list_entry = data.input_entries[list_index];\n@@ -206,7 +211,7 @@ static void ConcatFunction(DataChunk &args, ExpressionState &state, Vector &resu\n \tauto &func_expr = state.expr.Cast<BoundFunctionExpression>();\n \tauto &info = func_expr.bind_info->Cast<ConcatFunctionData>();\n \tif (info.return_type.id() == LogicalTypeId::LIST) {\n-\t\treturn ListConcatFunction(args, state, result);\n+\t\treturn ListConcatFunction(args, state, result, info.is_operator);\n \t} else if (info.is_operator) {\n \t\treturn ConcatOperator(args, state, result);\n \t}\n",
  "test_patch": "diff --git a/test/sql/function/list/list_concat.test b/test/sql/function/list/list_concat.test\nindex ce170468d49d..a7a73702c61f 100644\n--- a/test/sql/function/list/list_concat.test\n+++ b/test/sql/function/list/list_concat.test\n@@ -187,6 +187,22 @@ SELECT array_push_front(NULL, 1);\n ----\n [1]\n \n+# concat operator\n+query T\n+SELECT [1, 2] || NULL\n+----\n+NULL\n+\n+query T\n+SELECT [1, 2] || b FROM (VALUES (NULL::INT[])) t(b)\n+----\n+NULL\n+\n+query T\n+SELECT a || b FROM (VALUES ([1,2,3], NULL::INT[])) t(a,b)\n+----\n+NULL\n+\n # type mismatch\n statement error\n SELECT concat([42], [84], 'str')\n",
  "problem_statement": "`LIST_CONCAT()` and `||` don't propagate nulls\n### What happens?\r\n\r\nUsing the concatenation operator `||` on strings does NULL propagation, ie `'foo' || NULL` results in `NULL`. I think this is good behavior. I expected that for lists, the `||` operator (and the alias function, `LIST_CONCAT()`), to work the same. But instead, they treat NULL as an empty list, so that `NULL || [1,2,3]` results in `[1,2,3]`, where I would expect `NULL`.\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nSELECT\r\n    a,\r\n    LIST_CONCAT(a, [3, 4]),\r\n    a || [3, 4],\r\nFROM (\r\n    SELECT [1, 2] AS \"a\"\r\n    UNION ALL\r\n    SELECT [] AS \"a\"\r\n    UNION ALL\r\n    SELECT NULL AS \"a\"\r\n);\r\n```\r\n\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    a    \u2502 list_concat(a, main.list_value(3, 4)) \u2502 (a || main.list_value(3, 4)) \u2502\r\n\u2502 int32[] \u2502                int32[]                \u2502           int32[]            \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [1, 2]  \u2502 [1, 2, 3, 4]                          \u2502 [1, 2, 3, 4]                 \u2502\r\n\u2502 []      \u2502 [3, 4]                                \u2502 [3, 4]                       \u2502\r\n\u2502 NULL    \u2502 [3, 4]                                \u2502 [3, 4]                       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nIn addition, there is separate issue related to parsing, but may be related so I wanted to bring it up. The way duckdb interprets the types from using `||` vs `LIST_CONCAT` are different. Note the int32 vs the int32[]. This datatype different leads to different values getting produced as well.\r\n\r\n```sql\r\nSELECT NULL || [1, 2, 3] as pipes, LIST_CONCAT(NULL, [1, 2, 3]) as list_concat;\r\n```\r\n\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 pipes \u2502 list_concat \u2502\r\n\u2502 int32 \u2502   int32[]   \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502  NULL \u2502 [1, 2, 3]   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### OS:\r\n\r\nshell.duckdb.org\r\n\r\n### DuckDB Version:\r\n\r\n1.1.2\r\n\r\n### DuckDB Client:\r\n\r\nhttps://shell.duckdb.org/\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nNick Crews\r\n\r\n### Affiliation:\r\n\r\nShip Creek Group\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNo - Other reason (please specify in the issue body)\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-11-02T11:00:57Z"
}