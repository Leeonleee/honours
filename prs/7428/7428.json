{
  "repo": "duckdb/duckdb",
  "pull_number": 7428,
  "instance_id": "duckdb__duckdb-7428",
  "issue_numbers": [
    "7426"
  ],
  "base_commit": "c54a5ca25b722d4022a1968f55998936c0b15cc7",
  "patch": "diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBVector.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBVector.java\nindex fb8f6118bda5..76ad064a29cb 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBVector.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBVector.java\n@@ -469,7 +469,7 @@ Timestamp getTimestamp(int idx, Calendar cal) throws SQLException {\n \t\t// Our raw data is already a proper count of units since the epoch\n \t\t// So just construct the SQL Timestamp.\n \t\tif (isType(DuckDBColumnType.TIMESTAMP)) {\n-\t\t\treturn DuckDBTimestamp.fromMicroInstant(getbuf(idx, 8).getLong(idx));\n+\t\t\treturn DuckDBTimestamp.fromMicroInstant(getbuf(idx, 8).getLong());\n \t\t}\n \t\tif (isType(DuckDBColumnType.TIMESTAMP_MS)) {\n \t\t\treturn DuckDBTimestamp.fromMilliInstant(getbuf(idx, 8).getLong());\n",
  "test_patch": "diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex 01e1b7267c0e..26411f47f8f8 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -505,6 +505,19 @@ public static void test_timestamp_as_long() throws Exception {\n \t\tconn.close();\n \t}\n \n+    public static void test_consecutive_timestamps() throws Exception {\n+    \tlong expected = 986860800000L;\n+        try (Connection conn = DriverManager.getConnection(\"jdbc:duckdb:\"); Statement stmt = conn.createStatement()) {\n+            try (ResultSet rs = stmt.executeQuery(\"select range from range(TIMESTAMP '2001-04-10', TIMESTAMP '2001-04-11', INTERVAL 30 MINUTE)\")) {\n+                while (rs.next()) {\n+                    Timestamp actual = rs.getTimestamp(1, Calendar.getInstance());\n+                    assertEquals(expected, actual.getTime());\n+                    expected += 30 * 60 * 1_000;\n+                }\n+            }\n+        }\n+    }\n+\n \tpublic static void test_throw_wrong_datatype() throws Exception {\n \t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n \t\tStatement stmt = conn.createStatement();\n",
  "problem_statement": "JDBC no longer reading timestamps correctly in Tableau\n### What happens?\n\nThe latest JDBC driver returns `NULL`s for non-null data in a simple data set.\n\n### To Reproduce\n\n1. Install Tableau Desktop\r\n2. Install the latest JDBC driver in `~/Library/Tableau/Drivers`\r\n3. Copy the `duckdb_jdbc.properties` file to `~/Documents/My Tableau Repository/Datasources`\r\n4. Copy the `calcs.db` file to your home directory.\r\n5. Launch Tableau and Connect > To a Server > Other Databases (JDBC)\r\n6. URL: `jdbc:duckdb:/Users/username/calcs.db`, Dialect: `PostgresSQL`, Properties File: `~/Documents/My Tableau Repository/Datasources/duckdb_jdbc.properties`\r\n7. Database: `calcs`, Schema: `TestV1`, Table: `Calcs`\r\n8. Go to `Sheet 1`\r\n9. Drag `key` to Rows\r\n10. Option-drag `datetime0` to Rows and choose `datetime0 (discrete)`\r\n\r\nExpected: All 17 valid datetime values\r\nActual: Only the values in rows 0, 8 and 16 appear.\r\n[calcs.db.zip](https://github.com/duckdb/duckdb/files/11434471/calcs.db.zip)\r\n[duckdb_jdbc.properties.zip](https://github.com/duckdb/duckdb/files/11434488/duckdb_jdbc.properties.zip)\r\n\n\n### OS:\n\nOSX\n\n### DuckDB Version:\n\nv0.7.2-dev3351 c54a5ca25b\n\n### DuckDB Client:\n\nJDBC\n\n### Full Name:\n\nRichard Wesley\n\n### Affiliation:\n\nDuckDB Labs\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "[Here is the log file](https://github.com/duckdb/duckdb/files/11434679/jprotocolserver.log.zip) from Tableau's JDBC protocol server. The query is at the end of the file:\r\n\r\n```\r\n2023-05-09 11:03:50.610 -0700 (,,,,7,117) grpc-default-executor-2 : INFO  com.tableau.connect.grpc.GrpcProtocolService - Start local request 117 /runQuery.\r\n2023-05-09 11:03:50.610 -0700 (,,,,7,117) grpc-default-executor-2 : INFO  com.tableau.connect.service.ProtocolService - Running query \r\n   SELECT \"Calcs\".\"datetime0\" AS \"datetime0\",\r\n     \"Calcs\".\"key\" AS \"key\"\r\n   FROM \"TestV1\".\"Calcs\" \"Calcs\"\r\n   GROUP BY 1,\r\n     2\r\n2023-05-09 11:03:50.610 -0700 (,,,,7,117) grpc-default-executor-2 : INFO  com.tableau.connect.grpc.GrpcProtocolService - End local request 117 /runQuery.\r\n2023-05-09 11:03:50.611 -0700 (,,,,7,117) pool-3-thread-2 : INFO  com.tableausoftware.jdbc.FetchSizeHelpers - Setting max result buffer size to 322122547 bytes, 30% of the max heap size.\r\n2023-05-09 11:03:50.611 -0700 (,,,,7,117) pool-3-thread-2 : INFO  com.tableausoftware.jdbc.FetchSizeHelpers - Setting adaptive fetch size to 2000.\r\n2023-05-09 11:03:50.611 -0700 (,,,,7,117) pool-3-thread-2 : INFO  com.tableausoftware.data.ProtobufJDBCResultSet - BindingInfo{columnName='datetime0', columnTypeName='TIMESTAMP', columnLabel='datetime0', columnType=93, precision=0, scale=0, columnDisplaySize=0, protobufType=TIMESTAMP, nullable=nullable}\r\n2023-05-09 11:03:50.611 -0700 (,,,,7,117) pool-3-thread-2 : INFO  com.tableausoftware.data.ProtobufJDBCResultSet - BindingInfo{columnName='key', columnTypeName='VARCHAR', columnLabel='key', columnType=12, precision=0, scale=0, columnDisplaySize=0, protobufType=STRING, nullable=nullable}\r\n2023-05-09 11:03:50.612 -0700 (,,,,7,117) pool-3-thread-2 : INFO  com.tableau.connect.service.QueryTask - Query task for protocol 7 completed.\r\n```\r\n\r\n",
  "created_at": "2023-05-09T18:25:47Z"
}