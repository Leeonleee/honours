{
  "repo": "duckdb/duckdb",
  "pull_number": 5860,
  "instance_id": "duckdb__duckdb-5860",
  "issue_numbers": [
    "5795",
    "5795"
  ],
  "base_commit": "29229a04fc5e96b676ed588352cf98382c7ae9bd",
  "patch": "diff --git a/src/common/enums/expression_type.cpp b/src/common/enums/expression_type.cpp\nindex 25990eff960c..b14a72400e49 100644\n--- a/src/common/enums/expression_type.cpp\n+++ b/src/common/enums/expression_type.cpp\n@@ -133,6 +133,8 @@ string ExpressionTypeToString(ExpressionType type) {\n \t\treturn \"COLLATE\";\n \tcase ExpressionType::POSITIONAL_REFERENCE:\n \t\treturn \"POSITIONAL_REFERENCE\";\n+\tcase ExpressionType::BOUND_LAMBDA_REF:\n+\t\treturn \"BOUND_LAMBDA_REF\";\n \tcase ExpressionType::LAMBDA:\n \t\treturn \"LAMBDA\";\n \tcase ExpressionType::ARROW:\ndiff --git a/src/function/scalar/list/list_lambdas.cpp b/src/function/scalar/list/list_lambdas.cpp\nindex e34d5d7423ca..f592e2d75a1b 100644\n--- a/src/function/scalar/list/list_lambdas.cpp\n+++ b/src/function/scalar/list/list_lambdas.cpp\n@@ -112,15 +112,19 @@ static void ExecuteExpression(vector<LogicalType> &types, vector<LogicalType> &r\n \n \t// set the list child vector\n \tVector slice(child_vector, sel, elem_cnt);\n+\tVector second_slice(child_vector, sel, elem_cnt);\n \tslice.Flatten(elem_cnt);\n+\tsecond_slice.Flatten(elem_cnt);\n+\n \tinput_chunk.data[0].Reference(slice);\n+\tinput_chunk.data[1].Reference(second_slice);\n \n \t// set the other vectors\n \tvector<Vector> slices;\n \tfor (idx_t col_idx = 0; col_idx < args.ColumnCount() - 1; col_idx++) {\n \t\tslices.emplace_back(Vector(args.data[col_idx + 1], sel_vectors[col_idx], elem_cnt));\n \t\tslices[col_idx].Flatten(elem_cnt);\n-\t\tinput_chunk.data[col_idx + 1].Reference(slices[col_idx]);\n+\t\tinput_chunk.data[col_idx + 2].Reference(slices[col_idx]);\n \t}\n \n \t// execute the lambda expression\n@@ -185,6 +189,7 @@ static void ListLambdaFunction(DataChunk &args, ExpressionState &state, Vector &\n \n \tvector<LogicalType> types;\n \ttypes.push_back(child_vector.GetType());\n+\ttypes.push_back(child_vector.GetType());\n \n \t// skip the list column\n \tfor (idx_t i = 1; i < args.ColumnCount(); i++) {\ndiff --git a/src/include/duckdb/common/enums/expression_type.hpp b/src/include/duckdb/common/enums/expression_type.hpp\nindex 4f65d465b814..011031e55d5c 100644\n--- a/src/include/duckdb/common/enums/expression_type.hpp\n+++ b/src/include/duckdb/common/enums/expression_type.hpp\n@@ -143,7 +143,8 @@ enum class ExpressionType : uint8_t {\n \tBOUND_UNNEST = 229,\n \tCOLLATE = 230,\n \tLAMBDA = 231,\n-\tPOSITIONAL_REFERENCE = 232\n+\tPOSITIONAL_REFERENCE = 232,\n+\tBOUND_LAMBDA_REF = 233\n };\n \n //===--------------------------------------------------------------------===//\n@@ -192,6 +193,7 @@ enum class ExpressionClass : uint8_t {\n \tBOUND_BETWEEN = 39,\n \tBOUND_UNNEST = 40,\n \tBOUND_LAMBDA = 41,\n+\tBOUND_LAMBDA_REF = 42,\n \t//===--------------------------------------------------------------------===//\n \t// Miscellaneous\n \t//===--------------------------------------------------------------------===//\ndiff --git a/src/include/duckdb/planner/expression/bound_lambdaref_expression.hpp b/src/include/duckdb/planner/expression/bound_lambdaref_expression.hpp\nnew file mode 100644\nindex 000000000000..61f5bb08d698\n--- /dev/null\n+++ b/src/include/duckdb/planner/expression/bound_lambdaref_expression.hpp\n@@ -0,0 +1,54 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/planner/expression/bound_lambdaref_expression.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/planner/column_binding.hpp\"\n+#include \"duckdb/planner/expression.hpp\"\n+\n+namespace duckdb {\n+\n+class FieldReader;\n+class FieldWriter;\n+\n+//! A BoundLambdaRef expression represents a LambdaRef expression that was bound to an lambda parameter\n+//! in the lambda bindings vector. When capturing lambdas the BoundLambdaRef becomes a\n+//! BoundReferenceExpresssion, indexing the corresponding lambda parameter in the lambda bindings vector,\n+//! which refers to the physical chunk of the lambda parameter during execution.\n+class BoundLambdaRefExpression : public Expression {\n+public:\n+\tBoundLambdaRefExpression(LogicalType type, ColumnBinding binding, idx_t lambda_index, idx_t depth = 0);\n+\tBoundLambdaRefExpression(string alias, LogicalType type, ColumnBinding binding, idx_t lambda_index,\n+\t                         idx_t depth = 0);\n+\t//! Column index set by the binder, used to generate the final BoundExpression\n+\tColumnBinding binding;\n+\t//! The index of the lambda parameter in the lambda bindings vector\n+\tidx_t lambda_index;\n+\t//! The subquery depth (i.e. depth 0 = current query, depth 1 = parent query, depth 2 = parent of parent, etc...).\n+\t//! This is only non-zero for correlated expressions inside subqueries.\n+\tidx_t depth;\n+\n+public:\n+\tbool IsScalar() const override {\n+\t\treturn false;\n+\t}\n+\tbool IsFoldable() const override {\n+\t\treturn false;\n+\t}\n+\n+\tstring ToString() const override;\n+\n+\tbool Equals(const BaseExpression *other) const override;\n+\thash_t Hash() const override;\n+\n+\tunique_ptr<Expression> Copy() override;\n+\n+\tvoid Serialize(FieldWriter &writer) const override;\n+\tstatic unique_ptr<Expression> Deserialize(ExpressionDeserializationState &state, FieldReader &reader);\n+};\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex ab9dfdf4c250..019ed584124c 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -126,10 +126,9 @@ class ExpressionBinder {\n \tBindResult BindExpression(SubqueryExpression &expr, idx_t depth);\n \n \tvoid TransformCapturedLambdaColumn(unique_ptr<Expression> &original, unique_ptr<Expression> &replacement,\n-\t                                   vector<unique_ptr<Expression>> &captures, LogicalType &list_child_type,\n-\t                                   string &alias);\n+\t                                   vector<unique_ptr<Expression>> &captures, LogicalType &list_child_type);\n \tvoid CaptureLambdaColumns(vector<unique_ptr<Expression>> &captures, LogicalType &list_child_type,\n-\t                          unique_ptr<Expression> &expr, string &alias);\n+\t                          unique_ptr<Expression> &expr);\n \n protected:\n \tvirtual BindResult BindGroupingFunction(OperatorExpression &op, idx_t depth);\ndiff --git a/src/include/duckdb/planner/table_binding.hpp b/src/include/duckdb/planner/table_binding.hpp\nindex d7ad75087af0..9a3443d02d87 100644\n--- a/src/include/duckdb/planner/table_binding.hpp\n+++ b/src/include/duckdb/planner/table_binding.hpp\n@@ -40,6 +40,7 @@ struct Binding {\n \tstring alias;\n \t//! The table index of the binding\n \tidx_t index;\n+\t//! The types of the bound columns\n \tvector<LogicalType> types;\n \t//! Column names of the subquery\n \tvector<string> names;\n@@ -99,6 +100,7 @@ struct DummyBinding : public Binding {\n \n public:\n \tBindResult Bind(ColumnRefExpression &colref, idx_t depth) override;\n+\tBindResult Bind(ColumnRefExpression &colref, idx_t lambda_index, idx_t depth);\n \n \t//! Given the parameter colref, returns a copy of the argument that was supplied for this parameter\n \tunique_ptr<ParsedExpression> ParamToArg(ColumnRefExpression &colref);\ndiff --git a/src/planner/binder/expression/bind_columnref_expression.cpp b/src/planner/binder/expression/bind_columnref_expression.cpp\nindex 8e40d7b595b8..f0e19d60bc6d 100644\n--- a/src/planner/binder/expression/bind_columnref_expression.cpp\n+++ b/src/planner/binder/expression/bind_columnref_expression.cpp\n@@ -10,6 +10,7 @@\n #include \"duckdb/parser/parsed_expression_iterator.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_lambdaref_expression.hpp\"\n #include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n #include \"duckdb/planner/expression_binder/where_binder.hpp\"\n@@ -317,7 +318,7 @@ BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref_p, idx_t\n \tif (lambda_bindings) {\n \t\tfor (idx_t i = 0; i < lambda_bindings->size(); i++) {\n \t\t\tif (table_name == (*lambda_bindings)[i].alias) {\n-\t\t\t\tresult = (*lambda_bindings)[i].Bind(colref, depth);\n+\t\t\t\tresult = (*lambda_bindings)[i].Bind(colref, i, depth);\n \t\t\t\tfound_lambda_binding = true;\n \t\t\t\tbreak;\n \t\t\t}\ndiff --git a/src/planner/binder/expression/bind_function_expression.cpp b/src/planner/binder/expression/bind_function_expression.cpp\nindex 1daac3c78ce5..dc9e0445592f 100644\n--- a/src/planner/binder/expression/bind_function_expression.cpp\n+++ b/src/planner/binder/expression/bind_function_expression.cpp\n@@ -5,6 +5,7 @@\n #include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n #include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n #include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_reference_expression.hpp\"\n #include \"duckdb/planner/expression/bound_lambda_expression.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n@@ -155,8 +156,7 @@ BindResult ExpressionBinder::BindLambdaFunction(FunctionExpression &function, Sc\n \n \t// capture the (lambda) columns\n \tauto &bound_lambda_expr = (BoundLambdaExpression &)*children.back();\n-\tCaptureLambdaColumns(bound_lambda_expr.captures, list_child_type, bound_lambda_expr.lambda_expr,\n-\t                     children[0]->alias);\n+\tCaptureLambdaColumns(bound_lambda_expr.captures, list_child_type, bound_lambda_expr.lambda_expr);\n \n \tFunctionBinder function_binder(context);\n \tunique_ptr<Expression> result =\n@@ -165,12 +165,32 @@ BindResult ExpressionBinder::BindLambdaFunction(FunctionExpression &function, Sc\n \t\tthrow BinderException(binder.FormatError(function, error));\n \t}\n \n-\t// remove the lambda expression from the children\n \tauto &bound_function_expr = (BoundFunctionExpression &)*result;\n+\tD_ASSERT(bound_function_expr.children.size() == 2);\n+\n+\t// remove the lambda expression from the children\n \tauto lambda = std::move(bound_function_expr.children.back());\n \tbound_function_expr.children.pop_back();\n \tauto &bound_lambda = (BoundLambdaExpression &)*lambda;\n \n+\t// push back (in reverse order) any nested lambda parameters so that we can later use them in the lambda expression\n+\t// (rhs)\n+\tif (lambda_bindings) {\n+\t\tfor (idx_t i = lambda_bindings->size(); i > 0; i--) {\n+\n+\t\t\tidx_t lambda_index = lambda_bindings->size() - i + 1;\n+\t\t\tauto &binding = (*lambda_bindings)[i - 1];\n+\n+\t\t\tD_ASSERT(binding.names.size() == 1);\n+\t\t\tD_ASSERT(binding.types.size() == 1);\n+\n+\t\t\tbound_function_expr.function.arguments.push_back(binding.types[0]);\n+\t\t\tauto bound_lambda_param =\n+\t\t\t    make_unique<BoundReferenceExpression>(binding.names[0], binding.types[0], lambda_index);\n+\t\t\tbound_function_expr.children.push_back(std::move(bound_lambda_param));\n+\t\t}\n+\t}\n+\n \t// push back the captures into the children vector and the correct return types into the bound_function arguments\n \tfor (auto &capture : bound_lambda.captures) {\n \t\tbound_function_expr.function.arguments.push_back(capture->return_type);\ndiff --git a/src/planner/binder/expression/bind_lambda.cpp b/src/planner/binder/expression/bind_lambda.cpp\nindex 483619e38dd8..f02d2545403b 100644\n--- a/src/planner/binder/expression/bind_lambda.cpp\n+++ b/src/planner/binder/expression/bind_lambda.cpp\n@@ -6,6 +6,7 @@\n #include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/parser/expression/function_expression.hpp\"\n #include \"duckdb/planner/expression/bound_reference_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_lambdaref_expression.hpp\"\n #include \"duckdb/planner/expression/bound_lambda_expression.hpp\"\n #include \"duckdb/planner/expression_iterator.hpp\"\n \n@@ -102,33 +103,48 @@ BindResult ExpressionBinder::BindExpression(LambdaExpression &expr, idx_t depth,\n void ExpressionBinder::TransformCapturedLambdaColumn(unique_ptr<Expression> &original,\n                                                      unique_ptr<Expression> &replacement,\n                                                      vector<unique_ptr<Expression>> &captures,\n-                                                     LogicalType &list_child_type, string &alias) {\n+                                                     LogicalType &list_child_type) {\n \n \t// check if the original expression is a lambda parameter\n-\tbool is_lambda_parameter = false;\n-\tif (original->expression_class == ExpressionClass::BOUND_COLUMN_REF) {\n+\tif (original->expression_class == ExpressionClass::BOUND_LAMBDA_REF) {\n \n \t\t// determine if this is the lambda parameter\n-\t\tauto &bound_col_ref = (BoundColumnRefExpression &)*original;\n-\t\tif (bound_col_ref.binding.table_index == DConstants::INVALID_INDEX) {\n-\t\t\tis_lambda_parameter = true;\n-\t\t}\n-\t}\n+\t\tauto &bound_lambda_ref = (BoundLambdaRefExpression &)*original;\n+\t\tauto alias = bound_lambda_ref.alias;\n+\n+\t\tif (lambda_bindings && bound_lambda_ref.lambda_index != lambda_bindings->size()) {\n+\n+\t\t\tD_ASSERT(bound_lambda_ref.lambda_index < lambda_bindings->size());\n+\t\t\tauto &lambda_binding = (*lambda_bindings)[bound_lambda_ref.lambda_index];\n \n-\tif (is_lambda_parameter) {\n-\t\t// this is a lambda parameter, so the replacement refers to the first argument, which is the list\n-\t\treplacement = make_unique<BoundReferenceExpression>(alias, list_child_type, 0);\n+\t\t\tD_ASSERT(lambda_binding.names.size() == 1);\n+\t\t\tD_ASSERT(lambda_binding.types.size() == 1);\n+\t\t\t// refers to a lambda parameter outside of the current lambda function\n+\t\t\treplacement =\n+\t\t\t    make_unique<BoundReferenceExpression>(lambda_binding.names[0], lambda_binding.types[0],\n+\t\t\t                                          lambda_bindings->size() - bound_lambda_ref.lambda_index + 1);\n+\n+\t\t} else {\n+\t\t\t// refers to current lambda parameter\n+\t\t\treplacement = make_unique<BoundReferenceExpression>(alias, list_child_type, 0);\n+\t\t}\n \n \t} else {\n+\t\t// always at least the current lambda parameter\n+\t\tidx_t index_offset = 1;\n+\t\tif (lambda_bindings) {\n+\t\t\tindex_offset += lambda_bindings->size();\n+\t\t}\n+\n \t\t// this is not a lambda parameter, so we need to create a new argument for the arguments vector\n-\t\treplacement =\n-\t\t    make_unique<BoundReferenceExpression>(original->alias, original->return_type, captures.size() + 1);\n+\t\treplacement = make_unique<BoundReferenceExpression>(original->alias, original->return_type,\n+\t\t                                                    captures.size() + index_offset + 1);\n \t\tcaptures.push_back(std::move(original));\n \t}\n }\n \n void ExpressionBinder::CaptureLambdaColumns(vector<unique_ptr<Expression>> &captures, LogicalType &list_child_type,\n-                                            unique_ptr<Expression> &expr, string &alias) {\n+                                            unique_ptr<Expression> &expr) {\n \n \tif (expr->expression_class == ExpressionClass::BOUND_SUBQUERY) {\n \t\tthrow InvalidInputException(\"Subqueries are not supported in lambda expressions!\");\n@@ -137,22 +153,22 @@ void ExpressionBinder::CaptureLambdaColumns(vector<unique_ptr<Expression>> &capt\n \t// these expression classes do not have children, transform them\n \tif (expr->expression_class == ExpressionClass::BOUND_CONSTANT ||\n \t    expr->expression_class == ExpressionClass::BOUND_COLUMN_REF ||\n-\t    expr->expression_class == ExpressionClass::BOUND_PARAMETER) {\n+\t    expr->expression_class == ExpressionClass::BOUND_PARAMETER ||\n+\t    expr->expression_class == ExpressionClass::BOUND_LAMBDA_REF) {\n \n \t\t// move the expr because we are going to replace it\n \t\tauto original = std::move(expr);\n \t\tunique_ptr<Expression> replacement;\n \n-\t\tTransformCapturedLambdaColumn(original, replacement, captures, list_child_type, alias);\n+\t\tTransformCapturedLambdaColumn(original, replacement, captures, list_child_type);\n \n \t\t// replace the expression\n \t\texpr = std::move(replacement);\n \n \t} else {\n \t\t// recursively enumerate the children of the expression\n-\t\tExpressionIterator::EnumerateChildren(*expr, [&](unique_ptr<Expression> &child) {\n-\t\t\tCaptureLambdaColumns(captures, list_child_type, child, alias);\n-\t\t});\n+\t\tExpressionIterator::EnumerateChildren(\n+\t\t    *expr, [&](unique_ptr<Expression> &child) { CaptureLambdaColumns(captures, list_child_type, child); });\n \t}\n }\n \ndiff --git a/src/planner/expression/CMakeLists.txt b/src/planner/expression/CMakeLists.txt\nindex 8be29e3024b9..d26a0429824e 100644\n--- a/src/planner/expression/CMakeLists.txt\n+++ b/src/planner/expression/CMakeLists.txt\n@@ -13,6 +13,7 @@ add_library_unity(\n   bound_default_expression.cpp\n   bound_function_expression.cpp\n   bound_lambda_expression.cpp\n+  bound_lambdaref_expression.cpp\n   bound_operator_expression.cpp\n   bound_parameter_expression.cpp\n   bound_reference_expression.cpp\ndiff --git a/src/planner/expression/bound_lambdaref_expression.cpp b/src/planner/expression/bound_lambdaref_expression.cpp\nnew file mode 100644\nindex 000000000000..c0c1240ce906\n--- /dev/null\n+++ b/src/planner/expression/bound_lambdaref_expression.cpp\n@@ -0,0 +1,71 @@\n+#include \"duckdb/planner/expression/bound_lambdaref_expression.hpp\"\n+\n+#include \"duckdb/common/types/hash.hpp\"\n+#include \"duckdb/common/to_string.hpp\"\n+#include \"duckdb/common/field_writer.hpp\"\n+\n+namespace duckdb {\n+\n+BoundLambdaRefExpression::BoundLambdaRefExpression(string alias_p, LogicalType type, ColumnBinding binding,\n+                                                   idx_t lambda_index, idx_t depth)\n+    : Expression(ExpressionType::BOUND_LAMBDA_REF, ExpressionClass::BOUND_LAMBDA_REF, move(type)), binding(binding),\n+      lambda_index(lambda_index), depth(depth) {\n+\tthis->alias = move(alias_p);\n+}\n+\n+BoundLambdaRefExpression::BoundLambdaRefExpression(LogicalType type, ColumnBinding binding, idx_t lambda_index,\n+                                                   idx_t depth)\n+    : BoundLambdaRefExpression(string(), move(type), binding, lambda_index, depth) {\n+}\n+\n+unique_ptr<Expression> BoundLambdaRefExpression::Copy() {\n+\treturn make_unique<BoundLambdaRefExpression>(alias, return_type, binding, lambda_index, depth);\n+}\n+\n+hash_t BoundLambdaRefExpression::Hash() const {\n+\tauto result = Expression::Hash();\n+\tresult = CombineHash(result, duckdb::Hash<uint64_t>(lambda_index));\n+\tresult = CombineHash(result, duckdb::Hash<uint64_t>(binding.column_index));\n+\tresult = CombineHash(result, duckdb::Hash<uint64_t>(binding.table_index));\n+\treturn CombineHash(result, duckdb::Hash<uint64_t>(depth));\n+}\n+\n+bool BoundLambdaRefExpression::Equals(const BaseExpression *other_p) const {\n+\tif (!Expression::Equals(other_p)) {\n+\t\treturn false;\n+\t}\n+\tauto other = (BoundLambdaRefExpression *)other_p;\n+\treturn other->binding == binding && other->lambda_index == lambda_index && other->depth == depth;\n+}\n+\n+string BoundLambdaRefExpression::ToString() const {\n+\tif (!alias.empty()) {\n+\t\treturn alias;\n+\t}\n+\treturn \"#[\" + to_string(binding.table_index) + \".\" + to_string(binding.column_index) + \".\" +\n+\t       to_string(lambda_index) + \"]\";\n+}\n+\n+void BoundLambdaRefExpression::Serialize(FieldWriter &writer) const {\n+\twriter.WriteString(alias);\n+\twriter.WriteSerializable(return_type);\n+\twriter.WriteField(lambda_index);\n+\twriter.WriteField(binding.table_index);\n+\twriter.WriteField(binding.column_index);\n+\twriter.WriteField(depth);\n+}\n+\n+unique_ptr<Expression> BoundLambdaRefExpression::Deserialize(ExpressionDeserializationState &state,\n+                                                             FieldReader &reader) {\n+\tauto alias = reader.ReadRequired<string>();\n+\tauto return_type = reader.ReadRequiredSerializable<LogicalType, LogicalType>();\n+\tauto lambda_index = reader.ReadRequired<idx_t>();\n+\tauto table_index = reader.ReadRequired<idx_t>();\n+\tauto column_index = reader.ReadRequired<idx_t>();\n+\tauto depth = reader.ReadRequired<idx_t>();\n+\n+\treturn make_unique<BoundLambdaRefExpression>(alias, return_type, ColumnBinding(table_index, column_index),\n+\t                                             lambda_index, depth);\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/planner/expression_iterator.cpp b/src/planner/expression_iterator.cpp\nindex ba307f8de764..976ac50a889d 100644\n--- a/src/planner/expression_iterator.cpp\n+++ b/src/planner/expression_iterator.cpp\n@@ -120,6 +120,7 @@ void ExpressionIterator::EnumerateChildren(Expression &expr,\n \t\tbreak;\n \t}\n \tcase ExpressionClass::BOUND_COLUMN_REF:\n+\tcase ExpressionClass::BOUND_LAMBDA_REF:\n \tcase ExpressionClass::BOUND_CONSTANT:\n \tcase ExpressionClass::BOUND_DEFAULT:\n \tcase ExpressionClass::BOUND_PARAMETER:\ndiff --git a/src/planner/table_binding.cpp b/src/planner/table_binding.cpp\nindex aafa7c930786..736c05c8dee1 100644\n--- a/src/planner/table_binding.cpp\n+++ b/src/planner/table_binding.cpp\n@@ -8,6 +8,7 @@\n #include \"duckdb/planner/bind_context.hpp\"\n #include \"duckdb/planner/bound_query_node.hpp\"\n #include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_lambdaref_expression.hpp\"\n #include \"duckdb/parser/parsed_expression_iterator.hpp\"\n \n namespace duckdb {\n@@ -200,7 +201,8 @@ string TableBinding::ColumnNotFoundError(const string &column_name) const {\n }\n \n DummyBinding::DummyBinding(vector<LogicalType> types_p, vector<string> names_p, string dummy_name_p)\n-    : Binding(BindingType::DUMMY, DummyBinding::DUMMY_NAME + dummy_name_p, std::move(types_p), std::move(names_p), -1),\n+    : Binding(BindingType::DUMMY, DummyBinding::DUMMY_NAME + dummy_name_p, std::move(types_p), std::move(names_p),\n+              DConstants::INVALID_INDEX),\n       dummy_name(std::move(dummy_name_p)) {\n }\n \n@@ -209,14 +211,22 @@ BindResult DummyBinding::Bind(ColumnRefExpression &colref, idx_t depth) {\n \tif (!TryGetBindingIndex(colref.GetColumnName(), column_index)) {\n \t\tthrow InternalException(\"Column %s not found in bindings\", colref.GetColumnName());\n \t}\n-\tColumnBinding binding;\n-\tbinding.table_index = index;\n-\tbinding.column_index = column_index;\n+\tColumnBinding binding(index, column_index);\n \n \t// we are binding a parameter to create the dummy binding, no arguments are supplied\n \treturn BindResult(make_unique<BoundColumnRefExpression>(colref.GetName(), types[column_index], binding, depth));\n }\n \n+BindResult DummyBinding::Bind(ColumnRefExpression &colref, idx_t lambda_index, idx_t depth) {\n+\tcolumn_t column_index;\n+\tif (!TryGetBindingIndex(colref.GetColumnName(), column_index)) {\n+\t\tthrow InternalException(\"Column %s not found in bindings\", colref.GetColumnName());\n+\t}\n+\tColumnBinding binding(index, column_index);\n+\treturn BindResult(\n+\t    make_unique<BoundLambdaRefExpression>(colref.GetName(), types[column_index], binding, lambda_index, depth));\n+}\n+\n unique_ptr<ParsedExpression> DummyBinding::ParamToArg(ColumnRefExpression &colref) {\n \tcolumn_t column_index;\n \tif (!TryGetBindingIndex(colref.GetColumnName(), column_index)) {\n",
  "test_patch": "diff --git a/test/sql/function/list/lambdas/rhs_parameters.test b/test/sql/function/list/lambdas/rhs_parameters.test\nnew file mode 100644\nindex 000000000000..b8ece98fd299\n--- /dev/null\n+++ b/test/sql/function/list/lambdas/rhs_parameters.test\n@@ -0,0 +1,87 @@\n+# name: test/sql/function/list/lambdas/rhs_parameters.test\n+# description: Test nested lambda parameters in the rhs of lambda expressions\n+# group: [lambdas]\n+\n+# issue #5795\n+query I\n+SELECT list_apply([1,2], x -> list_apply([3,4], y -> (x,y))) AS bug;\n+----\n+[[{'x': 1, 'y': 3}, {'x': 1, 'y': 4}], [{'x': 2, 'y': 3}, {'x': 2, 'y': 4}]]\n+\n+# arbitrary other nested lambdas\n+\n+query I\n+select list_transform([1,2], x -> list_transform([3,4], y -> x + y));\n+----\n+[[4, 5], [5, 6]]\n+\n+query I\n+select list_transform([1,2], x -> list_transform([3,4], y -> list_transform([5,6], z -> z + y + x)));\n+----\n+[[[9, 10], [10, 11]], [[10, 11], [11, 12]]]\n+\n+query I\n+select list_transform([1,2,3,4], x -> list_filter([4,5,1,2,3,3,3,5,1,4], y -> y != x))\n+----\n+[[4, 5, 2, 3, 3, 3, 5, 4], [4, 5, 1, 3, 3, 3, 5, 1, 4], [4, 5, 1, 2, 5, 1, 4], [5, 1, 2, 3, 3, 3, 5, 1]]\n+\n+query I\n+select list_transform([[2, 4, 6]], x -> list_transform(x, y -> list_sum([y] || x)))\n+----\n+[[14, 16, 18]]\n+\n+query I\n+SELECT list_apply(range(5), x -> {x:x, w:list_filter(range(5), y -> abs(y-x) < 2)});\n+----\n+[{'x': 0, 'w': [0, 1]}, {'x': 1, 'w': [0, 1, 2]}, {'x': 2, 'w': [1, 2, 3]}, {'x': 3, 'w': [2, 3, 4]}, {'x': 4, 'w': [3, 4]}]\n+\n+query I\n+SELECT list_apply(range(8), x -> list_aggr(list_apply(range(8),\n+y -> list_element('\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588', 1+abs(y-x))), 'string_agg', ''));\n+----\n+[\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588, \u2582\u2581\u2582\u2583\u2584\u2585\u2586\u2587, \u2583\u2582\u2581\u2582\u2583\u2584\u2585\u2586, \u2584\u2583\u2582\u2581\u2582\u2583\u2584\u2585, \u2585\u2584\u2583\u2582\u2581\u2582\u2583\u2584, \u2586\u2585\u2584\u2583\u2582\u2581\u2582\u2583, \u2587\u2586\u2585\u2584\u2583\u2582\u2581\u2582, \u2588\u2587\u2586\u2585\u2584\u2583\u2582\u2581]\n+\n+statement ok\n+CREATE TABLE lists (i integer, v varchar[])\n+\n+statement ok\n+INSERT INTO lists VALUES (1, ['a', 'b', 'c']), (8, NULL), (3, ['duck', 'db', 'tests']), (NULL, NULL), (NULL, ['lambdas!'])\n+\n+query I\n+SELECT list_transform(v, x -> list_transform(v, y -> x || y)) FROM lists\n+----\n+[[aa, ab, ac], [ba, bb, bc], [ca, cb, cc]]\n+NULL\n+[[duckduck, duckdb, ducktests], [dbduck, dbdb, dbtests], [testsduck, testsdb, teststests]]\n+NULL\n+[[lambdas!lambdas!]]\n+\n+query I\n+SELECT list_transform(v, x -> list_transform(v, y -> list_transform(v, z -> x || y || z))) FROM lists\n+----\n+[[[aaa, aab, aac], [aba, abb, abc], [aca, acb, acc]], [[baa, bab, bac], [bba, bbb, bbc], [bca, bcb, bcc]], [[caa, cab, cac], [cba, cbb, cbc], [cca, ccb, ccc]]]\n+NULL\n+[[[duckduckduck, duckduckdb, duckducktests], [duckdbduck, duckdbdb, duckdbtests], [ducktestsduck, ducktestsdb, duckteststests]], [[dbduckduck, dbduckdb, dbducktests], [dbdbduck, dbdbdb, dbdbtests], [dbtestsduck, dbtestsdb, dbteststests]], [[testsduckduck, testsduckdb, testsducktests], [testsdbduck, testsdbdb, testsdbtests], [teststestsduck, teststestsdb, teststeststests]]]\n+NULL\n+[[[lambdas!lambdas!lambdas!]]]\n+\n+query I\n+SELECT list_transform(v, x -> [list_transform([':-)'], y -> x || y || '-#lambdaLove')]\n+|| list_filter(list_transform(['B-)'], k -> [k] || [x]), j -> list_contains(j, 'a') or list_contains(j, 'duck')))\n+FROM lists\n+----\n+[[[a:-)-#lambdaLove], [B-), a]], [[b:-)-#lambdaLove]], [[c:-)-#lambdaLove]]]\n+NULL\n+[[[duck:-)-#lambdaLove], [B-), duck]], [[db:-)-#lambdaLove]], [[tests:-)-#lambdaLove]]]\n+NULL\n+[[[lambdas!:-)-#lambdaLove]]]\n+\n+statement ok\n+create table no_overwrite as select [range, range + 1] l from range(3);\n+\n+query II\n+select l, [[(x + y, x, y, l) for y in [42, 43]] for x in l] from no_overwrite;\n+----\n+[0, 1]\t[[{'v1': 42, 'x': 0, 'y': 42, 'l': [0, 1]}, {'v1': 43, 'x': 0, 'y': 43, 'l': [0, 1]}], [{'v1': 43, 'x': 1, 'y': 42, 'l': [0, 1]}, {'v1': 44, 'x': 1, 'y': 43, 'l': [0, 1]}]]\n+[1, 2]\t[[{'v1': 43, 'x': 1, 'y': 42, 'l': [1, 2]}, {'v1': 44, 'x': 1, 'y': 43, 'l': [1, 2]}], [{'v1': 44, 'x': 2, 'y': 42, 'l': [1, 2]}, {'v1': 45, 'x': 2, 'y': 43, 'l': [1, 2]}]]\n+[2, 3]\t[[{'v1': 44, 'x': 2, 'y': 42, 'l': [2, 3]}, {'v1': 45, 'x': 2, 'y': 43, 'l': [2, 3]}], [{'v1': 45, 'x': 3, 'y': 42, 'l': [2, 3]}, {'v1': 46, 'x': 3, 'y': 43, 'l': [2, 3]}]]\n\\ No newline at end of file\n",
  "problem_statement": "Nested lambdas fail to bind variables correctly\n### What happens?\r\n\r\nWith nested lambdas (*e.g.*, when using two nested `list_apply`), any variable binding performed by the outer lambda appears to be \"overwritten\" by the variable binding performed by the inner lambda.\r\n\r\n### To Reproduce\r\n\r\nBuggy behaviour:\r\n\r\n~~~\r\n                                      unexpectedly carries y's binding (y \"overwrites\" x)\r\n                                                      \u2193\r\nSELECT list_apply([1,2], x -> list_apply([3,4], y -> (x,y))) AS bug;  \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                                     bug                                      \u2502\r\n\u2502                       struct(x integer, y integer)[][]                       \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [[{'x': 3, 'y': 3}, {'x': 4, 'y': 4}], [{'x': 3, 'y': 3}, {'x': 4, 'y': 4}]] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n~~~\r\n\r\nThe expected result reads:\r\n\r\n~~~\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                                   expected                                   \u2502\r\n\u2502                       struct(x integer, y integer)[][]                       \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [[{'x': 1, 'y': 3}, {'x': 1, 'y': 4}], [{'x': 2, 'y': 3}, {'x': 2, 'y': 4}]] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n~~~\r\n\r\n### OS:\r\n\r\nmacOS 12.5, aarch64\r\n\r\n### DuckDB Version:\r\n\r\nv0.6.1 919cad22e8\r\n\r\n### DuckDB Client:\r\n\r\nDuckDB CLI\r\n\r\n### Full Name:\r\n\r\nTorsten Grust\r\n\r\n### Affiliation:\r\n\r\nU T\u00fcbingen, Germany\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\nNested lambdas fail to bind variables correctly\n### What happens?\r\n\r\nWith nested lambdas (*e.g.*, when using two nested `list_apply`), any variable binding performed by the outer lambda appears to be \"overwritten\" by the variable binding performed by the inner lambda.\r\n\r\n### To Reproduce\r\n\r\nBuggy behaviour:\r\n\r\n~~~\r\n                                      unexpectedly carries y's binding (y \"overwrites\" x)\r\n                                                      \u2193\r\nSELECT list_apply([1,2], x -> list_apply([3,4], y -> (x,y))) AS bug;  \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                                     bug                                      \u2502\r\n\u2502                       struct(x integer, y integer)[][]                       \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [[{'x': 3, 'y': 3}, {'x': 4, 'y': 4}], [{'x': 3, 'y': 3}, {'x': 4, 'y': 4}]] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n~~~\r\n\r\nThe expected result reads:\r\n\r\n~~~\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                                   expected                                   \u2502\r\n\u2502                       struct(x integer, y integer)[][]                       \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [[{'x': 1, 'y': 3}, {'x': 1, 'y': 4}], [{'x': 2, 'y': 3}, {'x': 2, 'y': 4}]] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n~~~\r\n\r\n### OS:\r\n\r\nmacOS 12.5, aarch64\r\n\r\n### DuckDB Version:\r\n\r\nv0.6.1 919cad22e8\r\n\r\n### DuckDB Client:\r\n\r\nDuckDB CLI\r\n\r\n### Full Name:\r\n\r\nTorsten Grust\r\n\r\n### Affiliation:\r\n\r\nU T\u00fcbingen, Germany\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "Huh, thanks for spotting this! Will have a look.\nThank you, Tania! \nHuh, thanks for spotting this! Will have a look.\nThank you, Tania! ",
  "created_at": "2023-01-09T10:20:42Z"
}