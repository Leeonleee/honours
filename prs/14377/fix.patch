diff --git a/src/include/duckdb/common/types/validity_mask.hpp b/src/include/duckdb/common/types/validity_mask.hpp
index 897488e5fdbf..880bd9ff8410 100644
--- a/src/include/duckdb/common/types/validity_mask.hpp
+++ b/src/include/duckdb/common/types/validity_mask.hpp
@@ -155,6 +155,7 @@ struct TemplatedValidityMask {
 		return validity_mask[entry_idx];
 	}
 	static inline bool AllValid(V entry) {
+		// Check if all the tuples that are covered by this entry (usually 64) are valid
 		return entry == ValidityBuffer::MAX_ENTRY;
 	}
 	static inline bool NoneValid(V entry) {
diff --git a/tools/pythonpkg/scripts/cache_data.json b/tools/pythonpkg/scripts/cache_data.json
index 7aa110e3b074..44408d142a75 100644
--- a/tools/pythonpkg/scripts/cache_data.json
+++ b/tools/pythonpkg/scripts/cache_data.json
@@ -51,7 +51,18 @@
             "pandas.isnull",
             "pandas.ArrowDtype",
             "pandas.NaT",
-            "pandas.NA"
+            "pandas.NA",
+            "pandas.BooleanDtype",
+            "pandas.UInt8Dtype",
+            "pandas.UInt16Dtype",
+            "pandas.UInt32Dtype",
+            "pandas.UInt64Dtype",
+            "pandas.Int8Dtype",
+            "pandas.Int16Dtype",
+            "pandas.Int32Dtype",
+            "pandas.Int64Dtype",
+            "pandas.Float32Dtype",
+            "pandas.Float64Dtype"
         ],
         "required": false
     },
@@ -85,6 +96,72 @@
         "name": "ArrowDtype",
         "children": []
     },
+    "pandas.BooleanDtype": {
+        "type": "attribute",
+        "full_path": "pandas.BooleanDtype",
+        "name": "BooleanDtype",
+        "children": []
+    },
+    "pandas.UInt8Dtype": {
+        "type": "attribute",
+        "full_path": "pandas.UInt8Dtype",
+        "name": "UInt8Dtype",
+        "children": []
+    },
+    "pandas.UInt16Dtype": {
+        "type": "attribute",
+        "full_path": "pandas.UInt16Dtype",
+        "name": "UInt16Dtype",
+        "children": []
+    },
+    "pandas.UInt32Dtype": {
+        "type": "attribute",
+        "full_path": "pandas.UInt32Dtype",
+        "name": "UInt32Dtype",
+        "children": []
+    },
+    "pandas.UInt64Dtype": {
+        "type": "attribute",
+        "full_path": "pandas.UInt64Dtype",
+        "name": "UInt64Dtype",
+        "children": []
+    },
+    "pandas.Int8Dtype": {
+        "type": "attribute",
+        "full_path": "pandas.Int8Dtype",
+        "name": "Int8Dtype",
+        "children": []
+    },
+    "pandas.Int16Dtype": {
+        "type": "attribute",
+        "full_path": "pandas.Int16Dtype",
+        "name": "Int16Dtype",
+        "children": []
+    },
+    "pandas.Int32Dtype": {
+        "type": "attribute",
+        "full_path": "pandas.Int32Dtype",
+        "name": "Int32Dtype",
+        "children": []
+    },
+    "pandas.Int64Dtype": {
+        "type": "attribute",
+        "full_path": "pandas.Int64Dtype",
+        "name": "Int64Dtype",
+        "children": []
+    },
+    "pandas.Float32Dtype": {
+        "type": "attribute",
+        "full_path": "pandas.Float32Dtype",
+        "name": "Float32Dtype",
+        "children": []
+    },
+    "pandas.Float64Dtype": {
+        "type": "attribute",
+        "full_path": "pandas.Float64Dtype",
+        "name": "Float64Dtype",
+        "children": []
+    },
     "datetime": {
         "type": "module",
         "full_path": "datetime",
@@ -281,7 +358,8 @@
         "full_path": "numpy.ma",
         "name": "ma",
         "children": [
-            "numpy.ma.masked"
+            "numpy.ma.masked",
+            "numpy.ma.masked_array"
         ]
     },
     "numpy.ma.masked": {
@@ -290,6 +368,12 @@
         "name": "masked",
         "children": []
     },
+    "numpy.ma.masked_array": {
+        "type": "attribute",
+        "full_path": "numpy.ma.masked_array",
+        "name": "masked_array",
+        "children": []
+    },
     "numpy.ndarray": {
         "type": "attribute",
         "full_path": "numpy.ndarray",
diff --git a/tools/pythonpkg/scripts/imports.py b/tools/pythonpkg/scripts/imports.py
index f34844280080..cfa45d65a13c 100644
--- a/tools/pythonpkg/scripts/imports.py
+++ b/tools/pythonpkg/scripts/imports.py
@@ -13,6 +13,17 @@
 pandas.NA
 pandas.isnull
 pandas.ArrowDtype
+pandas.BooleanDtype
+pandas.UInt8Dtype
+pandas.UInt16Dtype
+pandas.UInt32Dtype
+pandas.UInt64Dtype
+pandas.Int8Dtype
+pandas.Int16Dtype
+pandas.Int32Dtype
+pandas.Int64Dtype
+pandas.Float32Dtype
+pandas.Float64Dtype
 
 import datetime
 
@@ -46,6 +57,7 @@
 
 numpy.core.multiarray
 numpy.ma.masked
+numpy.ma.masked_array
 numpy.ndarray
 numpy.datetime64
 numpy.generic
diff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp
index fbfaf52cc462..7ec78a883842 100644
--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp
+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp
@@ -17,12 +17,13 @@ struct NumpyMaCacheItem : public PythonImportCacheItem {
 
 public:
 	NumpyMaCacheItem(optional_ptr<PythonImportCacheItem> parent)
-	    : PythonImportCacheItem("ma", parent), masked("masked", this) {
+	    : PythonImportCacheItem("ma", parent), masked("masked", this), masked_array("masked_array", this) {
 	}
 	~NumpyMaCacheItem() override {
 	}
 
 	PythonImportCacheItem masked;
+	PythonImportCacheItem masked_array;
 };
 
 struct NumpyCoreCacheItem : public PythonImportCacheItem {
diff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp
index 30c36f691233..dc13c129a2d9 100644
--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp
+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp
@@ -21,7 +21,11 @@ struct PandasCacheItem : public PythonImportCacheItem {
 public:
 	PandasCacheItem()
 	    : PythonImportCacheItem("pandas"), DataFrame("DataFrame", this), isnull("isnull", this),
-	      ArrowDtype("ArrowDtype", this), NaT("NaT", this), NA("NA", this) {
+	      ArrowDtype("ArrowDtype", this), NaT("NaT", this), NA("NA", this), BooleanDtype("BooleanDtype", this),
+	      UInt8Dtype("UInt8Dtype", this), UInt16Dtype("UInt16Dtype", this), UInt32Dtype("UInt32Dtype", this),
+	      UInt64Dtype("UInt64Dtype", this), Int8Dtype("Int8Dtype", this), Int16Dtype("Int16Dtype", this),
+	      Int32Dtype("Int32Dtype", this), Int64Dtype("Int64Dtype", this), Float32Dtype("Float32Dtype", this),
+	      Float64Dtype("Float64Dtype", this) {
 	}
 	~PandasCacheItem() override {
 	}
@@ -31,6 +35,17 @@ struct PandasCacheItem : public PythonImportCacheItem {
 	PythonImportCacheItem ArrowDtype;
 	PythonImportCacheItem NaT;
 	PythonImportCacheItem NA;
+	PythonImportCacheItem BooleanDtype;
+	PythonImportCacheItem UInt8Dtype;
+	PythonImportCacheItem UInt16Dtype;
+	PythonImportCacheItem UInt32Dtype;
+	PythonImportCacheItem UInt64Dtype;
+	PythonImportCacheItem Int8Dtype;
+	PythonImportCacheItem Int16Dtype;
+	PythonImportCacheItem Int32Dtype;
+	PythonImportCacheItem Int64Dtype;
+	PythonImportCacheItem Float32Dtype;
+	PythonImportCacheItem Float64Dtype;
 
 protected:
 	bool IsRequired() const override final {
diff --git a/tools/pythonpkg/src/include/duckdb_python/pyresult.hpp b/tools/pythonpkg/src/include/duckdb_python/pyresult.hpp
index b889f108d99b..2e6b83070604 100644
--- a/tools/pythonpkg/src/include/duckdb_python/pyresult.hpp
+++ b/tools/pythonpkg/src/include/duckdb_python/pyresult.hpp
@@ -65,7 +65,6 @@ struct DuckDBPyResult {
 	PandasDataFrame FrameFromNumpy(bool date_as_object, const py::handle &o);
 
 	void ChangeToTZType(PandasDataFrame &df);
-	void ChangeDateToDatetime(PandasDataFrame &df);
 	unique_ptr<DataChunk> FetchNext(QueryResult &result);
 	unique_ptr<DataChunk> FetchNextRaw(QueryResult &result);
 	unique_ptr<NumpyResultConversion> InitializeNumpyConversion(bool pandas = false);
diff --git a/tools/pythonpkg/src/numpy/array_wrapper.cpp b/tools/pythonpkg/src/numpy/array_wrapper.cpp
index 6f45d344b9f5..94b283bc2d11 100644
--- a/tools/pythonpkg/src/numpy/array_wrapper.cpp
+++ b/tools/pythonpkg/src/numpy/array_wrapper.cpp
@@ -567,10 +567,12 @@ static bool ConvertDecimalInternal(NumpyAppendData &append_data, double division
 	auto src_ptr = UnifiedVectorFormat::GetData<DUCKDB_T>(idata);
 	auto out_ptr = reinterpret_cast<double *>(target_data);
 	if (!idata.validity.AllValid()) {
+		bool requires_mask = false;
 		for (idx_t i = 0; i < count; i++) {
 			idx_t src_idx = idata.sel->get_index(i + source_offset);
 			idx_t offset = target_offset + i;
 			if (!idata.validity.RowIsValidUnsafe(src_idx)) {
+				requires_mask = true;
 				target_mask[offset] = true;
 			} else {
 				out_ptr[offset] =
@@ -579,7 +581,7 @@ static bool ConvertDecimalInternal(NumpyAppendData &append_data, double division
 				target_mask[offset] = false;
 			}
 		}
-		return true;
+		return requires_mask;
 	} else {
 		for (idx_t i = 0; i < count; i++) {
 			idx_t src_idx = idata.sel->get_index(i + source_offset);
diff --git a/tools/pythonpkg/src/pyresult.cpp b/tools/pythonpkg/src/pyresult.cpp
index a61bb0c7dd96..f20c68de7ca3 100644
--- a/tools/pythonpkg/src/pyresult.cpp
+++ b/tools/pythonpkg/src/pyresult.cpp
@@ -2,6 +2,7 @@
 #include "duckdb_python/pyconnection/pyconnection.hpp"
 #include "duckdb_python/pyresult.hpp"
 #include "duckdb_python/python_objects.hpp"
+#include "duckdb_python/numpy/numpy_type.hpp"
 
 #include "duckdb_python/arrow/arrow_array_stream.hpp"
 #include "duckdb/common/arrow/arrow.hpp"
@@ -288,23 +289,85 @@ void DuckDBPyResult::ChangeToTZType(PandasDataFrame &df) {
 	}
 }
 
-// TODO: unify these with an enum/flag to indicate which conversions to perform
-void DuckDBPyResult::ChangeDateToDatetime(PandasDataFrame &df) {
-	auto names = df.attr("columns").cast<vector<string>>();
+static py::object ConvertNumpyDtype(py::handle numpy_array) {
+	D_ASSERT(py::gil_check());
+	auto &import_cache = *DuckDBPyConnection::ImportCache();
 
-	for (idx_t i = 0; i < result->ColumnCount(); i++) {
-		if (result->types[i] == LogicalType::DATE) {
-			df.attr("__setitem__")(names[i].c_str(), df[names[i].c_str()].attr("dt").attr("date"));
-		}
+	auto dtype = numpy_array.attr("dtype");
+	if (!py::isinstance(numpy_array, import_cache.numpy.ma.masked_array())) {
+		return dtype;
+	}
+
+	auto numpy_type = ConvertNumpyType(dtype);
+	switch (numpy_type.type) {
+	case NumpyNullableType::BOOL: {
+		return import_cache.pandas.BooleanDtype()();
+	}
+	case NumpyNullableType::UINT_8: {
+		return import_cache.pandas.UInt8Dtype()();
+	}
+	case NumpyNullableType::UINT_16: {
+		return import_cache.pandas.UInt16Dtype()();
+	}
+	case NumpyNullableType::UINT_32: {
+		return import_cache.pandas.UInt32Dtype()();
+	}
+	case NumpyNullableType::UINT_64: {
+		return import_cache.pandas.UInt64Dtype()();
+	}
+	case NumpyNullableType::INT_8: {
+		return import_cache.pandas.Int8Dtype()();
+	}
+	case NumpyNullableType::INT_16: {
+		return import_cache.pandas.Int16Dtype()();
+	}
+	case NumpyNullableType::INT_32: {
+		return import_cache.pandas.Int32Dtype()();
+	}
+	case NumpyNullableType::INT_64: {
+		return import_cache.pandas.Int64Dtype()();
+	}
+	case NumpyNullableType::FLOAT_32:
+	case NumpyNullableType::FLOAT_64:
+	case NumpyNullableType::FLOAT_16: // there is no pandas.Float16Dtype
+	default:
+		return dtype;
 	}
 }
 
 PandasDataFrame DuckDBPyResult::FrameFromNumpy(bool date_as_object, const py::handle &o) {
-	PandasDataFrame df = py::cast<PandasDataFrame>(py::module::import("pandas").attr("DataFrame").attr("from_dict")(o));
+	D_ASSERT(py::gil_check());
+	auto &import_cache = *DuckDBPyConnection::ImportCache();
+	auto pandas = import_cache.pandas();
+
+	py::object items = o.attr("items")();
+	for (const py::handle &item : items) {
+		// Each item is a tuple of (key, value)
+		auto key_value = py::cast<py::tuple>(item);
+		py::handle key = key_value[0];   // Access the first element (key)
+		py::handle value = key_value[1]; // Access the second element (value)
+
+		auto dtype = ConvertNumpyDtype(value);
+		if (py::isinstance(value, import_cache.numpy.ma.masked_array())) {
+			// o[key] = pd.Series(value.filled(pd.NA), dtype=dtype)
+			auto series = pandas.attr("Series")(value.attr("data"), py::arg("dtype") = dtype);
+			series.attr("__setitem__")(value.attr("mask"), import_cache.pandas.NA());
+			o.attr("__setitem__")(key, series);
+		}
+	}
+
+	PandasDataFrame df = py::cast<PandasDataFrame>(pandas.attr("DataFrame").attr("from_dict")(o));
 	// Unfortunately we have to do a type change here for timezones since these types are not supported by numpy
 	ChangeToTZType(df);
+
+	auto names = df.attr("columns").cast<vector<string>>();
+	D_ASSERT(result->ColumnCount() == names.size());
 	if (date_as_object) {
-		ChangeDateToDatetime(df);
+		for (idx_t i = 0; i < result->ColumnCount(); i++) {
+			if (result->types[i] == LogicalType::DATE) {
+				df.attr("__setitem__")(names[i].c_str(), df[names[i].c_str()].attr("dt").attr("date"));
+			}
+		}
 	}
 	return df;
 }
