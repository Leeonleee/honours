diff --git a/tools/pythonpkg/tests/fast/api/test_dbapi00.py b/tools/pythonpkg/tests/fast/api/test_dbapi00.py
index e8614864814e..141ff4c42897 100644
--- a/tools/pythonpkg/tests/fast/api/test_dbapi00.py
+++ b/tools/pythonpkg/tests/fast/api/test_dbapi00.py
@@ -94,7 +94,7 @@ def test_pandas_selection(self, duckdb_cursor, pandas, integers, timestamps):
         result = duckdb_cursor.fetchdf()
         arr = numpy.ma.masked_array(numpy.arange(11))
         arr.mask = [False] * 10 + [True]
-        arr = {'i': arr}
+        arr = {'i': pandas.Series(arr, dtype=pandas.Int32Dtype)}
         arr = pandas.DataFrame(arr)
         pandas.testing.assert_frame_equal(result, arr)
 
diff --git a/tools/pythonpkg/tests/fast/pandas/test_fetch_nested.py b/tools/pythonpkg/tests/fast/pandas/test_fetch_nested.py
index 641d4d119656..060974e7a018 100644
--- a/tools/pythonpkg/tests/fast/pandas/test_fetch_nested.py
+++ b/tools/pythonpkg/tests/fast/pandas/test_fetch_nested.py
@@ -433,8 +433,8 @@ def test_map_df(self, duckdb_cursor, query, expected, expected_error):
             'a': [
                 {'i': 1, 'j': 2},
                 {'i': 1, 'j': 2},
-                np.nan,
-                np.nan
+                pd.NA,
+                pd.NA
             ]
         }),
         ("""
@@ -454,8 +454,8 @@ def test_map_df(self, duckdb_cursor, query, expected, expected_error):
                     '1':3,
                     '2':4
                 },
-                np.nan,
-                np.nan
+                pd.NA,
+                pd.NA
             ]
         }),
     ])
diff --git a/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py b/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py
index 59e28c907bd9..e86a97d9467f 100644
--- a/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py
+++ b/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py
@@ -70,7 +70,7 @@ def test_category_nulls(self, duckdb_cursor):
         print(duckdb.query_df(df_in, "data", "SELECT * FROM data").fetchall())
         assert df_out['int'][0] == 1
         assert df_out['int'][1] == 2
-        assert numpy.isnan(df_out['int'][2])
+        assert pd.isna(df_out['int'][2])
 
     def test_category_string(self, duckdb_cursor):
         check_category_equal(['foo', 'bla', 'zoo', 'foo', 'foo', 'bla'])
diff --git a/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py b/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py
index b5f5d6327bec..aeb33ea4601b 100644
--- a/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py
+++ b/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py
@@ -4,6 +4,8 @@
 import numpy
 import string
 from packaging import version
+import warnings
+from contextlib import suppress
 
 
 def round_trip(data, pandas_type):
@@ -106,9 +108,9 @@ def test_pandas_boolean(self, duckdb_cursor):
 
         df_out = duckdb.query_df(df_in, "data", "SELECT * FROM data").df()
         assert df_out['object'][0] == df_in['object'][0]
-        assert numpy.isnan(df_out['object'][1])
-        assert numpy.isnan(df_out['object'][2])
-        assert numpy.isnan(df_out['object'][3])
+        assert pd.isna(df_out['object'][1])
+        assert pd.isna(df_out['object'][2])
+        assert pd.isna(df_out['object'][3])
         assert df_out['object'][4] == df_in['object'][4]
 
     def test_pandas_float32(self, duckdb_cursor):
@@ -124,7 +126,7 @@ def test_pandas_float32(self, duckdb_cursor):
         assert df_out['object'][0] == df_in['object'][0]
         assert df_out['object'][1] == df_in['object'][1]
         assert df_out['object'][2] == df_in['object'][2]
-        assert numpy.isnan(df_out['object'][3])
+        assert pd.isna(df_out['object'][3])
 
     def test_pandas_float64(self):
         data = numpy.array([0.233, numpy.nan, 3456.2341231, float('-inf'), -23424.45345, float('+inf'), 0.0000000001])
@@ -136,7 +138,7 @@ def test_pandas_float64(self):
         df_out = duckdb.query_df(df_in, "data", "SELECT * FROM data").df()
 
         for i in range(len(data)):
-            if numpy.isnan(df_out['object'][i]):
+            if pd.isna(df_out['object'][i]):
                 assert i == 1
                 continue
             assert df_out['object'][i] == df_in['object'][i]
@@ -164,3 +166,69 @@ def test_pandas_encoded_utf8(self, duckdb_cursor):
         df_in = pd.DataFrame({'object': pd.Series(data, dtype='object')})
         result = duckdb.query_df(df_in, "data", "SELECT * FROM data").fetchone()[0]
         assert result == expected_result
+
+    @pytest.mark.parametrize(
+        'dtype',
+        [
+            'bool',
+            'utinyint',
+            'usmallint',
+            'uinteger',
+            'ubigint',
+            'tinyint',
+            'smallint',
+            'integer',
+            'bigint',
+            'float',
+            'double',
+        ],
+    )
+    def test_producing_nullable_dtypes(self, duckdb_cursor, dtype):
+        class Input:
+            def __init__(self, value, expected_dtype):
+                self.value = value
+                self.expected_dtype = expected_dtype
+
+        inputs = {
+            'bool': Input('true', 'BooleanDtype'),
+            'utinyint': Input('255', 'UInt8Dtype'),
+            'usmallint': Input('65535', 'UInt16Dtype'),
+            'uinteger': Input('4294967295', 'UInt32Dtype'),
+            'ubigint': Input('18446744073709551615', 'UInt64Dtype'),
+            'tinyint': Input('-128', 'Int8Dtype'),
+            'smallint': Input('-32768', 'Int16Dtype'),
+            'integer': Input('-2147483648', 'Int32Dtype'),
+            'bigint': Input('-9223372036854775808', 'Int64Dtype'),
+            'float': Input('268043421344044473239570760152672894976.0000000000', 'float32'),
+            'double': Input(
+                '14303088389124869511075243108389716684037132417196499782261853698893384831666205572097390431189931733040903060865714975797777061496396865611606109149583360363636503436181348332896211726552694379264498632046075093077887837955077425420408952536212326792778411457460885268567735875437456412217418386401944141824.0000000000',
+                'float64',
+            ),
+        }
+
+        input = inputs[dtype]
+        if not hasattr(pd, input.expected_dtype) and not hasattr(numpy, input.expected_dtype):
+            pytest.skip("Could not test this nullable type, the version of pandas does not provide it")
+
+        query = f"""
+            select
+                a::{dtype} a
+            from (VALUES
+                (NULL),
+                ({input.value}),
+                (NULL)
+            ) t(a)
+        """
+
+        rel = duckdb_cursor.sql(query)
+        # Pandas <= 2.2.3 does not convert without throwing a warning
+        warnings.simplefilter(action='ignore', category=RuntimeWarning)
+        with suppress(TypeError):
+            df = rel.df()
+            warnings.resetwarnings()
+
+            if hasattr(pd, input.expected_dtype):
+                expected_dtype = getattr(pd, input.expected_dtype)
+            else:
+                expected_dtype = numpy.dtype(input.expected_dtype)
+            assert isinstance(df['a'].dtype, expected_dtype)
diff --git a/tools/pythonpkg/tests/fast/test_all_types.py b/tools/pythonpkg/tests/fast/test_all_types.py
index f7ab55178113..ce56165e428d 100644
--- a/tools/pythonpkg/tests/fast/test_all_types.py
+++ b/tools/pythonpkg/tests/fast/test_all_types.py
@@ -7,6 +7,8 @@
 from uuid import UUID
 import pytz
 import pytest
+import warnings
+from contextlib import suppress
 
 
 def replace_with_ndarray(obj):
@@ -582,16 +584,20 @@ def test_pandas(self, cur_type):
             'time': """CASE WHEN "time" = '24:00:00'::TIME THEN '23:59:59.999999'::TIME ELSE "time" END AS "time" """,
         }
         conn = duckdb.connect()
+        # Pandas <= 2.2.3 does not convert without throwing a warning
         conn.execute("SET timezone = UTC")
-        if cur_type in replacement_values:
-            dataframe = conn.execute("select " + replacement_values[cur_type]).df()
-        elif cur_type in adjusted_values:
-            dataframe = conn.execute(f'select {adjusted_values[cur_type]} from test_all_types()').df()
-        else:
-            dataframe = conn.execute(f'select "{cur_type}" from test_all_types()').df()
-        print(cur_type)
-        round_trip_dataframe = conn.execute("select * from dataframe").df()
-        result_dataframe = conn.execute("select * from dataframe").fetchall()
-        print(round_trip_dataframe)
-        result_roundtrip = conn.execute("select * from round_trip_dataframe").fetchall()
-        assert recursive_equality(result_dataframe, result_roundtrip)
+        warnings.simplefilter(action='ignore', category=RuntimeWarning)
+        with suppress(TypeError):
+            if cur_type in replacement_values:
+                dataframe = conn.execute("select " + replacement_values[cur_type]).df()
+            elif cur_type in adjusted_values:
+                dataframe = conn.execute(f'select {adjusted_values[cur_type]} from test_all_types()').df()
+            else:
+                dataframe = conn.execute(f'select "{cur_type}" from test_all_types()').df()
+            print(cur_type)
+            round_trip_dataframe = conn.execute("select * from dataframe").df()
+            result_dataframe = conn.execute("select * from dataframe").fetchall()
+            print(round_trip_dataframe)
+            result_roundtrip = conn.execute("select * from round_trip_dataframe").fetchall()
+            warnings.resetwarnings()
+            assert recursive_equality(result_dataframe, result_roundtrip)
diff --git a/tools/pythonpkg/tests/fast/types/test_object_int.py b/tools/pythonpkg/tests/fast/types/test_object_int.py
index d22a63d41e9a..ce153d497730 100644
--- a/tools/pythonpkg/tests/fast/types/test_object_int.py
+++ b/tools/pythonpkg/tests/fast/types/test_object_int.py
@@ -2,6 +2,8 @@
 import datetime
 import duckdb
 import pytest
+import warnings
+from contextlib import suppress
 
 
 class TestPandasObjectInteger(object):
@@ -16,40 +18,47 @@ def test_object_integer(self, duckdb_cursor):
                 'int64': pd.Series([None, 1, -1], dtype="Int64"),
             }
         )
-        # These are float64 because pandas would force these to be float64 even if we set them to int8, int16, int32, int64 respectively
+        warnings.simplefilter(action='ignore', category=RuntimeWarning)
         df_expected_res = pd.DataFrame(
             {
-                'int8': np.ma.masked_array([0, 1, -1], mask=[True, False, False], dtype='float64'),
-                'int16': np.ma.masked_array([0, 1, -1], mask=[True, False, False], dtype='float64'),
-                'int32': np.ma.masked_array([0, 1, -1], mask=[True, False, False], dtype='float64'),
-                'int64': np.ma.masked_array([0, 1, -1], mask=[True, False, False], dtype='float64'),
+                'int8': pd.Series(np.ma.masked_array([0, 1, -1], mask=[True, False, False]), dtype='Int8'),
+                'int16': pd.Series(np.ma.masked_array([0, 1, -1], mask=[True, False, False]), dtype='Int16'),
+                'int32': pd.Series(np.ma.masked_array([0, 1, -1], mask=[True, False, False]), dtype='Int32'),
+                'int64': pd.Series(np.ma.masked_array([0, 1, -1], mask=[True, False, False]), dtype='Int64'),
             }
         )
         df_out = duckdb.query_df(df_in, "data", "SELECT * FROM data").df()
+        warnings.resetwarnings()
         pd.testing.assert_frame_equal(df_expected_res, df_out)
 
     # Unsigned Masked Integer types
     def test_object_uinteger(self, duckdb_cursor):
         pd = pytest.importorskip("pandas")
-        df_in = pd.DataFrame(
-            {
-                'uint8': pd.Series([None, 1, 255], dtype="UInt8"),
-                'uint16': pd.Series([None, 1, 65535], dtype="UInt16"),
-                'uint32': pd.Series([None, 1, 4294967295], dtype="UInt32"),
-                'uint64': pd.Series([None, 1, 18446744073709551615], dtype="UInt64"),
-            }
-        )
-        # These are float64 because pandas would force these to be float64 even if we set them to uint8, uint16, uint32, uint64 respectively
-        df_expected_res = pd.DataFrame(
-            {
-                'uint8': np.ma.masked_array([0, 1, 255], mask=[True, False, False], dtype='float64'),
-                'uint16': np.ma.masked_array([0, 1, 65535], mask=[True, False, False], dtype='float64'),
-                'uint32': np.ma.masked_array([0, 1, 4294967295], mask=[True, False, False], dtype='float64'),
-                'uint64': np.ma.masked_array([0, 1, 18446744073709551615], mask=[True, False, False], dtype='float64'),
-            }
-        )
-        df_out = duckdb.query_df(df_in, "data", "SELECT * FROM data").df()
-        pd.testing.assert_frame_equal(df_expected_res, df_out)
+        with suppress(TypeError):
+            df_in = pd.DataFrame(
+                {
+                    'uint8': pd.Series([None, 1, 255], dtype="UInt8"),
+                    'uint16': pd.Series([None, 1, 65535], dtype="UInt16"),
+                    'uint32': pd.Series([None, 1, 4294967295], dtype="UInt32"),
+                    'uint64': pd.Series([None, 1, 18446744073709551615], dtype="UInt64"),
+                }
+            )
+            warnings.simplefilter(action='ignore', category=RuntimeWarning)
+            df_expected_res = pd.DataFrame(
+                {
+                    'uint8': pd.Series(np.ma.masked_array([0, 1, 255], mask=[True, False, False]), dtype='UInt8'),
+                    'uint16': pd.Series(np.ma.masked_array([0, 1, 65535], mask=[True, False, False]), dtype='UInt16'),
+                    'uint32': pd.Series(
+                        np.ma.masked_array([0, 1, 4294967295], mask=[True, False, False]), dtype='UInt32'
+                    ),
+                    'uint64': pd.Series(
+                        np.ma.masked_array([0, 1, 18446744073709551615], mask=[True, False, False]), dtype='UInt64'
+                    ),
+                }
+            )
+            df_out = duckdb.query_df(df_in, "data", "SELECT * FROM data").df()
+            warnings.resetwarnings()
+            pd.testing.assert_frame_equal(df_expected_res, df_out)
 
     # Unsigned Masked float/double types
     def test_object_float(self, duckdb_cursor):
@@ -63,8 +72,12 @@ def test_object_float(self, duckdb_cursor):
         )
         df_expected_res = pd.DataFrame(
             {
-                'float32': np.ma.masked_array([0, 1, 4294967295], mask=[True, False, False], dtype='float32'),
-                'float64': np.ma.masked_array([0, 1, 18446744073709551615], mask=[True, False, False], dtype='float64'),
+                'float32': pd.Series(
+                    np.ma.masked_array([0, 1, 4294967295], mask=[True, False, False]), dtype='float32'
+                ),
+                'float64': pd.Series(
+                    np.ma.masked_array([0, 1, 18446744073709551615], mask=[True, False, False]), dtype='float64'
+                ),
             }
         )
         df_out = duckdb.query_df(df_in, "data", "SELECT * FROM data").df()
