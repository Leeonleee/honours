{
  "repo": "duckdb/duckdb",
  "pull_number": 14377,
  "instance_id": "duckdb__duckdb-14377",
  "issue_numbers": [
    "14340"
  ],
  "base_commit": "059ac75f6225fde78b686bc85f23d2e70af1dbe0",
  "patch": "diff --git a/src/include/duckdb/common/types/validity_mask.hpp b/src/include/duckdb/common/types/validity_mask.hpp\nindex 897488e5fdbf..880bd9ff8410 100644\n--- a/src/include/duckdb/common/types/validity_mask.hpp\n+++ b/src/include/duckdb/common/types/validity_mask.hpp\n@@ -155,6 +155,7 @@ struct TemplatedValidityMask {\n \t\treturn validity_mask[entry_idx];\n \t}\n \tstatic inline bool AllValid(V entry) {\n+\t\t// Check if all the tuples that are covered by this entry (usually 64) are valid\n \t\treturn entry == ValidityBuffer::MAX_ENTRY;\n \t}\n \tstatic inline bool NoneValid(V entry) {\ndiff --git a/tools/pythonpkg/scripts/cache_data.json b/tools/pythonpkg/scripts/cache_data.json\nindex 7aa110e3b074..44408d142a75 100644\n--- a/tools/pythonpkg/scripts/cache_data.json\n+++ b/tools/pythonpkg/scripts/cache_data.json\n@@ -51,7 +51,18 @@\n             \"pandas.isnull\",\n             \"pandas.ArrowDtype\",\n             \"pandas.NaT\",\n-            \"pandas.NA\"\n+            \"pandas.NA\",\n+            \"pandas.BooleanDtype\",\n+            \"pandas.UInt8Dtype\",\n+            \"pandas.UInt16Dtype\",\n+            \"pandas.UInt32Dtype\",\n+            \"pandas.UInt64Dtype\",\n+            \"pandas.Int8Dtype\",\n+            \"pandas.Int16Dtype\",\n+            \"pandas.Int32Dtype\",\n+            \"pandas.Int64Dtype\",\n+            \"pandas.Float32Dtype\",\n+            \"pandas.Float64Dtype\"\n         ],\n         \"required\": false\n     },\n@@ -85,6 +96,72 @@\n         \"name\": \"ArrowDtype\",\n         \"children\": []\n     },\n+    \"pandas.BooleanDtype\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"pandas.BooleanDtype\",\n+        \"name\": \"BooleanDtype\",\n+        \"children\": []\n+    },\n+    \"pandas.UInt8Dtype\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"pandas.UInt8Dtype\",\n+        \"name\": \"UInt8Dtype\",\n+        \"children\": []\n+    },\n+    \"pandas.UInt16Dtype\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"pandas.UInt16Dtype\",\n+        \"name\": \"UInt16Dtype\",\n+        \"children\": []\n+    },\n+    \"pandas.UInt32Dtype\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"pandas.UInt32Dtype\",\n+        \"name\": \"UInt32Dtype\",\n+        \"children\": []\n+    },\n+    \"pandas.UInt64Dtype\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"pandas.UInt64Dtype\",\n+        \"name\": \"UInt64Dtype\",\n+        \"children\": []\n+    },\n+    \"pandas.Int8Dtype\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"pandas.Int8Dtype\",\n+        \"name\": \"Int8Dtype\",\n+        \"children\": []\n+    },\n+    \"pandas.Int16Dtype\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"pandas.Int16Dtype\",\n+        \"name\": \"Int16Dtype\",\n+        \"children\": []\n+    },\n+    \"pandas.Int32Dtype\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"pandas.Int32Dtype\",\n+        \"name\": \"Int32Dtype\",\n+        \"children\": []\n+    },\n+    \"pandas.Int64Dtype\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"pandas.Int64Dtype\",\n+        \"name\": \"Int64Dtype\",\n+        \"children\": []\n+    },\n+    \"pandas.Float32Dtype\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"pandas.Float32Dtype\",\n+        \"name\": \"Float32Dtype\",\n+        \"children\": []\n+    },\n+    \"pandas.Float64Dtype\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"pandas.Float64Dtype\",\n+        \"name\": \"Float64Dtype\",\n+        \"children\": []\n+    },\n     \"datetime\": {\n         \"type\": \"module\",\n         \"full_path\": \"datetime\",\n@@ -281,7 +358,8 @@\n         \"full_path\": \"numpy.ma\",\n         \"name\": \"ma\",\n         \"children\": [\n-            \"numpy.ma.masked\"\n+            \"numpy.ma.masked\",\n+            \"numpy.ma.masked_array\"\n         ]\n     },\n     \"numpy.ma.masked\": {\n@@ -290,6 +368,12 @@\n         \"name\": \"masked\",\n         \"children\": []\n     },\n+    \"numpy.ma.masked_array\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"numpy.ma.masked_array\",\n+        \"name\": \"masked_array\",\n+        \"children\": []\n+    },\n     \"numpy.ndarray\": {\n         \"type\": \"attribute\",\n         \"full_path\": \"numpy.ndarray\",\ndiff --git a/tools/pythonpkg/scripts/imports.py b/tools/pythonpkg/scripts/imports.py\nindex f34844280080..cfa45d65a13c 100644\n--- a/tools/pythonpkg/scripts/imports.py\n+++ b/tools/pythonpkg/scripts/imports.py\n@@ -13,6 +13,17 @@\n pandas.NA\n pandas.isnull\n pandas.ArrowDtype\n+pandas.BooleanDtype\n+pandas.UInt8Dtype\n+pandas.UInt16Dtype\n+pandas.UInt32Dtype\n+pandas.UInt64Dtype\n+pandas.Int8Dtype\n+pandas.Int16Dtype\n+pandas.Int32Dtype\n+pandas.Int64Dtype\n+pandas.Float32Dtype\n+pandas.Float64Dtype\n \n import datetime\n \n@@ -46,6 +57,7 @@\n \n numpy.core.multiarray\n numpy.ma.masked\n+numpy.ma.masked_array\n numpy.ndarray\n numpy.datetime64\n numpy.generic\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp\nindex fbfaf52cc462..7ec78a883842 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp\n@@ -17,12 +17,13 @@ struct NumpyMaCacheItem : public PythonImportCacheItem {\n \n public:\n \tNumpyMaCacheItem(optional_ptr<PythonImportCacheItem> parent)\n-\t    : PythonImportCacheItem(\"ma\", parent), masked(\"masked\", this) {\n+\t    : PythonImportCacheItem(\"ma\", parent), masked(\"masked\", this), masked_array(\"masked_array\", this) {\n \t}\n \t~NumpyMaCacheItem() override {\n \t}\n \n \tPythonImportCacheItem masked;\n+\tPythonImportCacheItem masked_array;\n };\n \n struct NumpyCoreCacheItem : public PythonImportCacheItem {\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp\nindex 30c36f691233..dc13c129a2d9 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pandas_module.hpp\n@@ -21,7 +21,11 @@ struct PandasCacheItem : public PythonImportCacheItem {\n public:\n \tPandasCacheItem()\n \t    : PythonImportCacheItem(\"pandas\"), DataFrame(\"DataFrame\", this), isnull(\"isnull\", this),\n-\t      ArrowDtype(\"ArrowDtype\", this), NaT(\"NaT\", this), NA(\"NA\", this) {\n+\t      ArrowDtype(\"ArrowDtype\", this), NaT(\"NaT\", this), NA(\"NA\", this), BooleanDtype(\"BooleanDtype\", this),\n+\t      UInt8Dtype(\"UInt8Dtype\", this), UInt16Dtype(\"UInt16Dtype\", this), UInt32Dtype(\"UInt32Dtype\", this),\n+\t      UInt64Dtype(\"UInt64Dtype\", this), Int8Dtype(\"Int8Dtype\", this), Int16Dtype(\"Int16Dtype\", this),\n+\t      Int32Dtype(\"Int32Dtype\", this), Int64Dtype(\"Int64Dtype\", this), Float32Dtype(\"Float32Dtype\", this),\n+\t      Float64Dtype(\"Float64Dtype\", this) {\n \t}\n \t~PandasCacheItem() override {\n \t}\n@@ -31,6 +35,17 @@ struct PandasCacheItem : public PythonImportCacheItem {\n \tPythonImportCacheItem ArrowDtype;\n \tPythonImportCacheItem NaT;\n \tPythonImportCacheItem NA;\n+\tPythonImportCacheItem BooleanDtype;\n+\tPythonImportCacheItem UInt8Dtype;\n+\tPythonImportCacheItem UInt16Dtype;\n+\tPythonImportCacheItem UInt32Dtype;\n+\tPythonImportCacheItem UInt64Dtype;\n+\tPythonImportCacheItem Int8Dtype;\n+\tPythonImportCacheItem Int16Dtype;\n+\tPythonImportCacheItem Int32Dtype;\n+\tPythonImportCacheItem Int64Dtype;\n+\tPythonImportCacheItem Float32Dtype;\n+\tPythonImportCacheItem Float64Dtype;\n \n protected:\n \tbool IsRequired() const override final {\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pyresult.hpp b/tools/pythonpkg/src/include/duckdb_python/pyresult.hpp\nindex b889f108d99b..2e6b83070604 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyresult.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyresult.hpp\n@@ -65,7 +65,6 @@ struct DuckDBPyResult {\n \tPandasDataFrame FrameFromNumpy(bool date_as_object, const py::handle &o);\n \n \tvoid ChangeToTZType(PandasDataFrame &df);\n-\tvoid ChangeDateToDatetime(PandasDataFrame &df);\n \tunique_ptr<DataChunk> FetchNext(QueryResult &result);\n \tunique_ptr<DataChunk> FetchNextRaw(QueryResult &result);\n \tunique_ptr<NumpyResultConversion> InitializeNumpyConversion(bool pandas = false);\ndiff --git a/tools/pythonpkg/src/numpy/array_wrapper.cpp b/tools/pythonpkg/src/numpy/array_wrapper.cpp\nindex 6f45d344b9f5..94b283bc2d11 100644\n--- a/tools/pythonpkg/src/numpy/array_wrapper.cpp\n+++ b/tools/pythonpkg/src/numpy/array_wrapper.cpp\n@@ -567,10 +567,12 @@ static bool ConvertDecimalInternal(NumpyAppendData &append_data, double division\n \tauto src_ptr = UnifiedVectorFormat::GetData<DUCKDB_T>(idata);\n \tauto out_ptr = reinterpret_cast<double *>(target_data);\n \tif (!idata.validity.AllValid()) {\n+\t\tbool requires_mask = false;\n \t\tfor (idx_t i = 0; i < count; i++) {\n \t\t\tidx_t src_idx = idata.sel->get_index(i + source_offset);\n \t\t\tidx_t offset = target_offset + i;\n \t\t\tif (!idata.validity.RowIsValidUnsafe(src_idx)) {\n+\t\t\t\trequires_mask = true;\n \t\t\t\ttarget_mask[offset] = true;\n \t\t\t} else {\n \t\t\t\tout_ptr[offset] =\n@@ -579,7 +581,7 @@ static bool ConvertDecimalInternal(NumpyAppendData &append_data, double division\n \t\t\t\ttarget_mask[offset] = false;\n \t\t\t}\n \t\t}\n-\t\treturn true;\n+\t\treturn requires_mask;\n \t} else {\n \t\tfor (idx_t i = 0; i < count; i++) {\n \t\t\tidx_t src_idx = idata.sel->get_index(i + source_offset);\ndiff --git a/tools/pythonpkg/src/pyresult.cpp b/tools/pythonpkg/src/pyresult.cpp\nindex a61bb0c7dd96..f20c68de7ca3 100644\n--- a/tools/pythonpkg/src/pyresult.cpp\n+++ b/tools/pythonpkg/src/pyresult.cpp\n@@ -2,6 +2,7 @@\n #include \"duckdb_python/pyconnection/pyconnection.hpp\"\n #include \"duckdb_python/pyresult.hpp\"\n #include \"duckdb_python/python_objects.hpp\"\n+#include \"duckdb_python/numpy/numpy_type.hpp\"\n \n #include \"duckdb_python/arrow/arrow_array_stream.hpp\"\n #include \"duckdb/common/arrow/arrow.hpp\"\n@@ -288,23 +289,85 @@ void DuckDBPyResult::ChangeToTZType(PandasDataFrame &df) {\n \t}\n }\n \n-// TODO: unify these with an enum/flag to indicate which conversions to perform\n-void DuckDBPyResult::ChangeDateToDatetime(PandasDataFrame &df) {\n-\tauto names = df.attr(\"columns\").cast<vector<string>>();\n+static py::object ConvertNumpyDtype(py::handle numpy_array) {\n+\tD_ASSERT(py::gil_check());\n+\tauto &import_cache = *DuckDBPyConnection::ImportCache();\n \n-\tfor (idx_t i = 0; i < result->ColumnCount(); i++) {\n-\t\tif (result->types[i] == LogicalType::DATE) {\n-\t\t\tdf.attr(\"__setitem__\")(names[i].c_str(), df[names[i].c_str()].attr(\"dt\").attr(\"date\"));\n-\t\t}\n+\tauto dtype = numpy_array.attr(\"dtype\");\n+\tif (!py::isinstance(numpy_array, import_cache.numpy.ma.masked_array())) {\n+\t\treturn dtype;\n+\t}\n+\n+\tauto numpy_type = ConvertNumpyType(dtype);\n+\tswitch (numpy_type.type) {\n+\tcase NumpyNullableType::BOOL: {\n+\t\treturn import_cache.pandas.BooleanDtype()();\n+\t}\n+\tcase NumpyNullableType::UINT_8: {\n+\t\treturn import_cache.pandas.UInt8Dtype()();\n+\t}\n+\tcase NumpyNullableType::UINT_16: {\n+\t\treturn import_cache.pandas.UInt16Dtype()();\n+\t}\n+\tcase NumpyNullableType::UINT_32: {\n+\t\treturn import_cache.pandas.UInt32Dtype()();\n+\t}\n+\tcase NumpyNullableType::UINT_64: {\n+\t\treturn import_cache.pandas.UInt64Dtype()();\n+\t}\n+\tcase NumpyNullableType::INT_8: {\n+\t\treturn import_cache.pandas.Int8Dtype()();\n+\t}\n+\tcase NumpyNullableType::INT_16: {\n+\t\treturn import_cache.pandas.Int16Dtype()();\n+\t}\n+\tcase NumpyNullableType::INT_32: {\n+\t\treturn import_cache.pandas.Int32Dtype()();\n+\t}\n+\tcase NumpyNullableType::INT_64: {\n+\t\treturn import_cache.pandas.Int64Dtype()();\n+\t}\n+\tcase NumpyNullableType::FLOAT_32:\n+\tcase NumpyNullableType::FLOAT_64:\n+\tcase NumpyNullableType::FLOAT_16: // there is no pandas.Float16Dtype\n+\tdefault:\n+\t\treturn dtype;\n \t}\n }\n \n PandasDataFrame DuckDBPyResult::FrameFromNumpy(bool date_as_object, const py::handle &o) {\n-\tPandasDataFrame df = py::cast<PandasDataFrame>(py::module::import(\"pandas\").attr(\"DataFrame\").attr(\"from_dict\")(o));\n+\tD_ASSERT(py::gil_check());\n+\tauto &import_cache = *DuckDBPyConnection::ImportCache();\n+\tauto pandas = import_cache.pandas();\n+\n+\tpy::object items = o.attr(\"items\")();\n+\tfor (const py::handle &item : items) {\n+\t\t// Each item is a tuple of (key, value)\n+\t\tauto key_value = py::cast<py::tuple>(item);\n+\t\tpy::handle key = key_value[0];   // Access the first element (key)\n+\t\tpy::handle value = key_value[1]; // Access the second element (value)\n+\n+\t\tauto dtype = ConvertNumpyDtype(value);\n+\t\tif (py::isinstance(value, import_cache.numpy.ma.masked_array())) {\n+\t\t\t// o[key] = pd.Series(value.filled(pd.NA), dtype=dtype)\n+\t\t\tauto series = pandas.attr(\"Series\")(value.attr(\"data\"), py::arg(\"dtype\") = dtype);\n+\t\t\tseries.attr(\"__setitem__\")(value.attr(\"mask\"), import_cache.pandas.NA());\n+\t\t\to.attr(\"__setitem__\")(key, series);\n+\t\t}\n+\t}\n+\n+\tPandasDataFrame df = py::cast<PandasDataFrame>(pandas.attr(\"DataFrame\").attr(\"from_dict\")(o));\n \t// Unfortunately we have to do a type change here for timezones since these types are not supported by numpy\n \tChangeToTZType(df);\n+\n+\tauto names = df.attr(\"columns\").cast<vector<string>>();\n+\tD_ASSERT(result->ColumnCount() == names.size());\n \tif (date_as_object) {\n-\t\tChangeDateToDatetime(df);\n+\t\tfor (idx_t i = 0; i < result->ColumnCount(); i++) {\n+\t\t\tif (result->types[i] == LogicalType::DATE) {\n+\t\t\t\tdf.attr(\"__setitem__\")(names[i].c_str(), df[names[i].c_str()].attr(\"dt\").attr(\"date\"));\n+\t\t\t}\n+\t\t}\n \t}\n \treturn df;\n }\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_dbapi00.py b/tools/pythonpkg/tests/fast/api/test_dbapi00.py\nindex e8614864814e..141ff4c42897 100644\n--- a/tools/pythonpkg/tests/fast/api/test_dbapi00.py\n+++ b/tools/pythonpkg/tests/fast/api/test_dbapi00.py\n@@ -94,7 +94,7 @@ def test_pandas_selection(self, duckdb_cursor, pandas, integers, timestamps):\n         result = duckdb_cursor.fetchdf()\n         arr = numpy.ma.masked_array(numpy.arange(11))\n         arr.mask = [False] * 10 + [True]\n-        arr = {'i': arr}\n+        arr = {'i': pandas.Series(arr, dtype=pandas.Int32Dtype)}\n         arr = pandas.DataFrame(arr)\n         pandas.testing.assert_frame_equal(result, arr)\n \ndiff --git a/tools/pythonpkg/tests/fast/pandas/test_fetch_nested.py b/tools/pythonpkg/tests/fast/pandas/test_fetch_nested.py\nindex 641d4d119656..060974e7a018 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_fetch_nested.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_fetch_nested.py\n@@ -433,8 +433,8 @@ def test_map_df(self, duckdb_cursor, query, expected, expected_error):\n             'a': [\n                 {'i': 1, 'j': 2},\n                 {'i': 1, 'j': 2},\n-                np.nan,\n-                np.nan\n+                pd.NA,\n+                pd.NA\n             ]\n         }),\n         (\"\"\"\n@@ -454,8 +454,8 @@ def test_map_df(self, duckdb_cursor, query, expected, expected_error):\n                     '1':3,\n                     '2':4\n                 },\n-                np.nan,\n-                np.nan\n+                pd.NA,\n+                pd.NA\n             ]\n         }),\n     ])\ndiff --git a/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py b/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py\nindex 59e28c907bd9..e86a97d9467f 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py\n@@ -70,7 +70,7 @@ def test_category_nulls(self, duckdb_cursor):\n         print(duckdb.query_df(df_in, \"data\", \"SELECT * FROM data\").fetchall())\n         assert df_out['int'][0] == 1\n         assert df_out['int'][1] == 2\n-        assert numpy.isnan(df_out['int'][2])\n+        assert pd.isna(df_out['int'][2])\n \n     def test_category_string(self, duckdb_cursor):\n         check_category_equal(['foo', 'bla', 'zoo', 'foo', 'foo', 'bla'])\ndiff --git a/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py b/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py\nindex b5f5d6327bec..aeb33ea4601b 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py\n@@ -4,6 +4,8 @@\n import numpy\n import string\n from packaging import version\n+import warnings\n+from contextlib import suppress\n \n \n def round_trip(data, pandas_type):\n@@ -106,9 +108,9 @@ def test_pandas_boolean(self, duckdb_cursor):\n \n         df_out = duckdb.query_df(df_in, \"data\", \"SELECT * FROM data\").df()\n         assert df_out['object'][0] == df_in['object'][0]\n-        assert numpy.isnan(df_out['object'][1])\n-        assert numpy.isnan(df_out['object'][2])\n-        assert numpy.isnan(df_out['object'][3])\n+        assert pd.isna(df_out['object'][1])\n+        assert pd.isna(df_out['object'][2])\n+        assert pd.isna(df_out['object'][3])\n         assert df_out['object'][4] == df_in['object'][4]\n \n     def test_pandas_float32(self, duckdb_cursor):\n@@ -124,7 +126,7 @@ def test_pandas_float32(self, duckdb_cursor):\n         assert df_out['object'][0] == df_in['object'][0]\n         assert df_out['object'][1] == df_in['object'][1]\n         assert df_out['object'][2] == df_in['object'][2]\n-        assert numpy.isnan(df_out['object'][3])\n+        assert pd.isna(df_out['object'][3])\n \n     def test_pandas_float64(self):\n         data = numpy.array([0.233, numpy.nan, 3456.2341231, float('-inf'), -23424.45345, float('+inf'), 0.0000000001])\n@@ -136,7 +138,7 @@ def test_pandas_float64(self):\n         df_out = duckdb.query_df(df_in, \"data\", \"SELECT * FROM data\").df()\n \n         for i in range(len(data)):\n-            if numpy.isnan(df_out['object'][i]):\n+            if pd.isna(df_out['object'][i]):\n                 assert i == 1\n                 continue\n             assert df_out['object'][i] == df_in['object'][i]\n@@ -164,3 +166,69 @@ def test_pandas_encoded_utf8(self, duckdb_cursor):\n         df_in = pd.DataFrame({'object': pd.Series(data, dtype='object')})\n         result = duckdb.query_df(df_in, \"data\", \"SELECT * FROM data\").fetchone()[0]\n         assert result == expected_result\n+\n+    @pytest.mark.parametrize(\n+        'dtype',\n+        [\n+            'bool',\n+            'utinyint',\n+            'usmallint',\n+            'uinteger',\n+            'ubigint',\n+            'tinyint',\n+            'smallint',\n+            'integer',\n+            'bigint',\n+            'float',\n+            'double',\n+        ],\n+    )\n+    def test_producing_nullable_dtypes(self, duckdb_cursor, dtype):\n+        class Input:\n+            def __init__(self, value, expected_dtype):\n+                self.value = value\n+                self.expected_dtype = expected_dtype\n+\n+        inputs = {\n+            'bool': Input('true', 'BooleanDtype'),\n+            'utinyint': Input('255', 'UInt8Dtype'),\n+            'usmallint': Input('65535', 'UInt16Dtype'),\n+            'uinteger': Input('4294967295', 'UInt32Dtype'),\n+            'ubigint': Input('18446744073709551615', 'UInt64Dtype'),\n+            'tinyint': Input('-128', 'Int8Dtype'),\n+            'smallint': Input('-32768', 'Int16Dtype'),\n+            'integer': Input('-2147483648', 'Int32Dtype'),\n+            'bigint': Input('-9223372036854775808', 'Int64Dtype'),\n+            'float': Input('268043421344044473239570760152672894976.0000000000', 'float32'),\n+            'double': Input(\n+                '14303088389124869511075243108389716684037132417196499782261853698893384831666205572097390431189931733040903060865714975797777061496396865611606109149583360363636503436181348332896211726552694379264498632046075093077887837955077425420408952536212326792778411457460885268567735875437456412217418386401944141824.0000000000',\n+                'float64',\n+            ),\n+        }\n+\n+        input = inputs[dtype]\n+        if not hasattr(pd, input.expected_dtype) and not hasattr(numpy, input.expected_dtype):\n+            pytest.skip(\"Could not test this nullable type, the version of pandas does not provide it\")\n+\n+        query = f\"\"\"\n+            select\n+                a::{dtype} a\n+            from (VALUES\n+                (NULL),\n+                ({input.value}),\n+                (NULL)\n+            ) t(a)\n+        \"\"\"\n+\n+        rel = duckdb_cursor.sql(query)\n+        # Pandas <= 2.2.3 does not convert without throwing a warning\n+        warnings.simplefilter(action='ignore', category=RuntimeWarning)\n+        with suppress(TypeError):\n+            df = rel.df()\n+            warnings.resetwarnings()\n+\n+            if hasattr(pd, input.expected_dtype):\n+                expected_dtype = getattr(pd, input.expected_dtype)\n+            else:\n+                expected_dtype = numpy.dtype(input.expected_dtype)\n+            assert isinstance(df['a'].dtype, expected_dtype)\ndiff --git a/tools/pythonpkg/tests/fast/test_all_types.py b/tools/pythonpkg/tests/fast/test_all_types.py\nindex f7ab55178113..ce56165e428d 100644\n--- a/tools/pythonpkg/tests/fast/test_all_types.py\n+++ b/tools/pythonpkg/tests/fast/test_all_types.py\n@@ -7,6 +7,8 @@\n from uuid import UUID\n import pytz\n import pytest\n+import warnings\n+from contextlib import suppress\n \n \n def replace_with_ndarray(obj):\n@@ -582,16 +584,20 @@ def test_pandas(self, cur_type):\n             'time': \"\"\"CASE WHEN \"time\" = '24:00:00'::TIME THEN '23:59:59.999999'::TIME ELSE \"time\" END AS \"time\" \"\"\",\n         }\n         conn = duckdb.connect()\n+        # Pandas <= 2.2.3 does not convert without throwing a warning\n         conn.execute(\"SET timezone = UTC\")\n-        if cur_type in replacement_values:\n-            dataframe = conn.execute(\"select \" + replacement_values[cur_type]).df()\n-        elif cur_type in adjusted_values:\n-            dataframe = conn.execute(f'select {adjusted_values[cur_type]} from test_all_types()').df()\n-        else:\n-            dataframe = conn.execute(f'select \"{cur_type}\" from test_all_types()').df()\n-        print(cur_type)\n-        round_trip_dataframe = conn.execute(\"select * from dataframe\").df()\n-        result_dataframe = conn.execute(\"select * from dataframe\").fetchall()\n-        print(round_trip_dataframe)\n-        result_roundtrip = conn.execute(\"select * from round_trip_dataframe\").fetchall()\n-        assert recursive_equality(result_dataframe, result_roundtrip)\n+        warnings.simplefilter(action='ignore', category=RuntimeWarning)\n+        with suppress(TypeError):\n+            if cur_type in replacement_values:\n+                dataframe = conn.execute(\"select \" + replacement_values[cur_type]).df()\n+            elif cur_type in adjusted_values:\n+                dataframe = conn.execute(f'select {adjusted_values[cur_type]} from test_all_types()').df()\n+            else:\n+                dataframe = conn.execute(f'select \"{cur_type}\" from test_all_types()').df()\n+            print(cur_type)\n+            round_trip_dataframe = conn.execute(\"select * from dataframe\").df()\n+            result_dataframe = conn.execute(\"select * from dataframe\").fetchall()\n+            print(round_trip_dataframe)\n+            result_roundtrip = conn.execute(\"select * from round_trip_dataframe\").fetchall()\n+            warnings.resetwarnings()\n+            assert recursive_equality(result_dataframe, result_roundtrip)\ndiff --git a/tools/pythonpkg/tests/fast/types/test_object_int.py b/tools/pythonpkg/tests/fast/types/test_object_int.py\nindex d22a63d41e9a..ce153d497730 100644\n--- a/tools/pythonpkg/tests/fast/types/test_object_int.py\n+++ b/tools/pythonpkg/tests/fast/types/test_object_int.py\n@@ -2,6 +2,8 @@\n import datetime\n import duckdb\n import pytest\n+import warnings\n+from contextlib import suppress\n \n \n class TestPandasObjectInteger(object):\n@@ -16,40 +18,47 @@ def test_object_integer(self, duckdb_cursor):\n                 'int64': pd.Series([None, 1, -1], dtype=\"Int64\"),\n             }\n         )\n-        # These are float64 because pandas would force these to be float64 even if we set them to int8, int16, int32, int64 respectively\n+        warnings.simplefilter(action='ignore', category=RuntimeWarning)\n         df_expected_res = pd.DataFrame(\n             {\n-                'int8': np.ma.masked_array([0, 1, -1], mask=[True, False, False], dtype='float64'),\n-                'int16': np.ma.masked_array([0, 1, -1], mask=[True, False, False], dtype='float64'),\n-                'int32': np.ma.masked_array([0, 1, -1], mask=[True, False, False], dtype='float64'),\n-                'int64': np.ma.masked_array([0, 1, -1], mask=[True, False, False], dtype='float64'),\n+                'int8': pd.Series(np.ma.masked_array([0, 1, -1], mask=[True, False, False]), dtype='Int8'),\n+                'int16': pd.Series(np.ma.masked_array([0, 1, -1], mask=[True, False, False]), dtype='Int16'),\n+                'int32': pd.Series(np.ma.masked_array([0, 1, -1], mask=[True, False, False]), dtype='Int32'),\n+                'int64': pd.Series(np.ma.masked_array([0, 1, -1], mask=[True, False, False]), dtype='Int64'),\n             }\n         )\n         df_out = duckdb.query_df(df_in, \"data\", \"SELECT * FROM data\").df()\n+        warnings.resetwarnings()\n         pd.testing.assert_frame_equal(df_expected_res, df_out)\n \n     # Unsigned Masked Integer types\n     def test_object_uinteger(self, duckdb_cursor):\n         pd = pytest.importorskip(\"pandas\")\n-        df_in = pd.DataFrame(\n-            {\n-                'uint8': pd.Series([None, 1, 255], dtype=\"UInt8\"),\n-                'uint16': pd.Series([None, 1, 65535], dtype=\"UInt16\"),\n-                'uint32': pd.Series([None, 1, 4294967295], dtype=\"UInt32\"),\n-                'uint64': pd.Series([None, 1, 18446744073709551615], dtype=\"UInt64\"),\n-            }\n-        )\n-        # These are float64 because pandas would force these to be float64 even if we set them to uint8, uint16, uint32, uint64 respectively\n-        df_expected_res = pd.DataFrame(\n-            {\n-                'uint8': np.ma.masked_array([0, 1, 255], mask=[True, False, False], dtype='float64'),\n-                'uint16': np.ma.masked_array([0, 1, 65535], mask=[True, False, False], dtype='float64'),\n-                'uint32': np.ma.masked_array([0, 1, 4294967295], mask=[True, False, False], dtype='float64'),\n-                'uint64': np.ma.masked_array([0, 1, 18446744073709551615], mask=[True, False, False], dtype='float64'),\n-            }\n-        )\n-        df_out = duckdb.query_df(df_in, \"data\", \"SELECT * FROM data\").df()\n-        pd.testing.assert_frame_equal(df_expected_res, df_out)\n+        with suppress(TypeError):\n+            df_in = pd.DataFrame(\n+                {\n+                    'uint8': pd.Series([None, 1, 255], dtype=\"UInt8\"),\n+                    'uint16': pd.Series([None, 1, 65535], dtype=\"UInt16\"),\n+                    'uint32': pd.Series([None, 1, 4294967295], dtype=\"UInt32\"),\n+                    'uint64': pd.Series([None, 1, 18446744073709551615], dtype=\"UInt64\"),\n+                }\n+            )\n+            warnings.simplefilter(action='ignore', category=RuntimeWarning)\n+            df_expected_res = pd.DataFrame(\n+                {\n+                    'uint8': pd.Series(np.ma.masked_array([0, 1, 255], mask=[True, False, False]), dtype='UInt8'),\n+                    'uint16': pd.Series(np.ma.masked_array([0, 1, 65535], mask=[True, False, False]), dtype='UInt16'),\n+                    'uint32': pd.Series(\n+                        np.ma.masked_array([0, 1, 4294967295], mask=[True, False, False]), dtype='UInt32'\n+                    ),\n+                    'uint64': pd.Series(\n+                        np.ma.masked_array([0, 1, 18446744073709551615], mask=[True, False, False]), dtype='UInt64'\n+                    ),\n+                }\n+            )\n+            df_out = duckdb.query_df(df_in, \"data\", \"SELECT * FROM data\").df()\n+            warnings.resetwarnings()\n+            pd.testing.assert_frame_equal(df_expected_res, df_out)\n \n     # Unsigned Masked float/double types\n     def test_object_float(self, duckdb_cursor):\n@@ -63,8 +72,12 @@ def test_object_float(self, duckdb_cursor):\n         )\n         df_expected_res = pd.DataFrame(\n             {\n-                'float32': np.ma.masked_array([0, 1, 4294967295], mask=[True, False, False], dtype='float32'),\n-                'float64': np.ma.masked_array([0, 1, 18446744073709551615], mask=[True, False, False], dtype='float64'),\n+                'float32': pd.Series(\n+                    np.ma.masked_array([0, 1, 4294967295], mask=[True, False, False]), dtype='float32'\n+                ),\n+                'float64': pd.Series(\n+                    np.ma.masked_array([0, 1, 18446744073709551615], mask=[True, False, False]), dtype='float64'\n+                ),\n             }\n         )\n         df_out = duckdb.query_df(df_in, \"data\", \"SELECT * FROM data\").df()\n",
  "problem_statement": "Can not cast field type to Int64 when querying nullable Int64 fields from a Pandas.DataFrame\n### What happens?\n\nAs indicated in the title and attachment, even when using the cast function, it is impossible to maintain the cc_id in the dataframe returned by duckdb.query as Int64; the cc_id has been converted to a float64 type.\r\n![image](https://github.com/user-attachments/assets/70ca1382-f7c2-4c7b-9510-c436e947ed3d)\r\n\n\n### To Reproduce\n\n```\r\nimport pandas as pd\r\nimport duckdb\r\n\r\ndf = pd.DataFrame({\r\n    'cc_id': pd.Series([1844743171901218817, 1844691776961568771, None, None], dtype='Int64'),\r\n    'other_column': [10, 20, 30, 40]\r\n})\r\n\r\nresult = duckdb.query(\"SELECT CAST(cc_id AS Int64) AS cc_id, other_column FROM df WHERE other_column > 10\").df()\r\nresult['cc_id']\r\n```\n\n### OS:\n\nmacOS 12.7.6\n\n### DuckDB Version:\n\n0.10.2, 1.1.1\n\n### DuckDB Client:\n\nPython\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nKafka Liu\n\n### Affiliation:\n\nFreelancer\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-10-15T13:50:32Z"
}