{
  "repo": "duckdb/duckdb",
  "pull_number": 8523,
  "instance_id": "duckdb__duckdb-8523",
  "issue_numbers": [
    "2827"
  ],
  "base_commit": "1f17e1cec65e4207b6e38ca701c9d16573a98316",
  "patch": "diff --git a/extension/icu/icu-datepart.cpp b/extension/icu/icu-datepart.cpp\nindex 725d7265e45b..7891d54e3d60 100644\n--- a/extension/icu/icu-datepart.cpp\n+++ b/extension/icu/icu-datepart.cpp\n@@ -14,7 +14,8 @@\n namespace duckdb {\n \n struct ICUDatePart : public ICUDateFunc {\n-\ttypedef int64_t (*part_adapter_t)(icu::Calendar *calendar, const uint64_t micros);\n+\ttypedef int64_t (*part_bigint_t)(icu::Calendar *calendar, const uint64_t micros);\n+\ttypedef double (*part_double_t)(icu::Calendar *calendar, const uint64_t micros);\n \n \t// Date part adapters\n \tstatic int64_t ExtractEra(icu::Calendar *calendar, const uint64_t micros) {\n@@ -129,7 +130,26 @@ struct ICUDatePart : public ICUDateFunc {\n \t\treturn (secs % Interval::SECS_PER_HOUR) / Interval::SECS_PER_MINUTE;\n \t}\n \n-\tstatic part_adapter_t PartCodeAdapterFactory(DatePartSpecifier part) {\n+\t//\tPG uses doubles for JDs so we can only use them with other double types\n+\tstatic double ExtractJulianDay(icu::Calendar *calendar, const uint64_t micros) {\n+\t\t//\tWe need days + fraction\n+\t\tauto days = ExtractField(calendar, UCAL_JULIAN_DAY);\n+\t\tauto frac = ExtractHour(calendar, micros);\n+\n+\t\tfrac *= Interval::MINS_PER_HOUR;\n+\t\tfrac += ExtractMinute(calendar, micros);\n+\n+\t\tfrac *= Interval::MICROS_PER_MINUTE;\n+\t\tfrac += ExtractMicrosecond(calendar, micros);\n+\n+\t\tdouble result = frac;\n+\t\tresult /= Interval::MICROS_PER_DAY;\n+\t\tresult += days;\n+\n+\t\treturn result;\n+\t}\n+\n+\tstatic part_bigint_t PartCodeBigintFactory(DatePartSpecifier part) {\n \t\tswitch (part) {\n \t\tcase DatePartSpecifier::YEAR:\n \t\t\treturn ExtractYear;\n@@ -178,7 +198,16 @@ struct ICUDatePart : public ICUDateFunc {\n \t\tcase DatePartSpecifier::TIMEZONE_MINUTE:\n \t\t\treturn ExtractTimezoneMinute;\n \t\tdefault:\n-\t\t\tthrow Exception(\"Unsupported ICU extract adapter\");\n+\t\t\tthrow Exception(\"Unsupported ICU BIGINT extractor\");\n+\t\t}\n+\t}\n+\n+\tstatic part_double_t PartCodeDoubleFactory(DatePartSpecifier part) {\n+\t\tswitch (part) {\n+\t\tcase DatePartSpecifier::JULIAN_DAY:\n+\t\t\treturn ExtractJulianDay;\n+\t\tdefault:\n+\t\t\tthrow Exception(\"Unsupported ICU DOUBLE extractor\");\n \t\t}\n \t}\n \n@@ -208,7 +237,7 @@ struct ICUDatePart : public ICUDateFunc {\n \tstatic string_t MonthName(icu::Calendar *calendar, const uint64_t micros) {\n \t\tconst auto mm = ExtractMonth(calendar, micros) - 1;\n \t\tif (mm == 12) {\n-\t\t\treturn \"Undecember\";\n+\t\t\treturn \"Undecimber\";\n \t\t}\n \t\treturn Date::MONTH_NAMES[mm];\n \t}\n@@ -282,7 +311,7 @@ struct ICUDatePart : public ICUDateFunc {\n \t\t    [&](string_t specifier, INPUT_TYPE input, ValidityMask &mask, idx_t idx) {\n \t\t\t    if (Timestamp::IsFinite(input)) {\n \t\t\t\t    const auto micros = SetTime(calendar, input);\n-\t\t\t\t    auto adapter = PartCodeAdapterFactory(GetDatePartSpecifier(specifier.GetString()));\n+\t\t\t\t    auto adapter = PartCodeBigintFactory(GetDatePartSpecifier(specifier.GetString()));\n \t\t\t\t    return adapter(calendar, micros);\n \t\t\t    } else {\n \t\t\t\t    mask.SetInvalid(idx);\n@@ -291,11 +320,37 @@ struct ICUDatePart : public ICUDateFunc {\n \t\t    });\n \t}\n \n+\tstruct BindStructData : public BindData {\n+\t\tusing part_codes_t = vector<DatePartSpecifier>;\n+\t\tusing bigints_t = vector<part_bigint_t>;\n+\t\tusing doubles_t = vector<part_double_t>;\n+\n+\t\tBindStructData(ClientContext &context, part_codes_t &part_codes_p, bigints_t &bigints_p, doubles_t &doubles_p)\n+\t\t    : BindData(context), part_codes(part_codes_p), bigints(bigints_p), doubles(doubles_p) {\n+\t\t}\n+\t\tBindStructData(const BindStructData &other)\n+\t\t    : BindData(other), part_codes(other.part_codes), bigints(other.bigints), doubles(other.doubles) {\n+\t\t}\n+\n+\t\tpart_codes_t part_codes;\n+\t\tbigints_t bigints;\n+\t\tdoubles_t doubles;\n+\n+\t\tbool Equals(const FunctionData &other_p) const override {\n+\t\t\tconst auto &other = other_p.Cast<BindStructData>();\n+\t\t\treturn BindData::Equals(other_p) && part_codes == other.part_codes && bigints == other.bigints &&\n+\t\t\t       doubles == other.doubles;\n+\t\t}\n+\n+\t\tduckdb::unique_ptr<FunctionData> Copy() const override {\n+\t\t\treturn make_uniq<BindStructData>(*this);\n+\t\t}\n+\t};\n+\n \ttemplate <typename INPUT_TYPE>\n \tstatic void StructFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\t\tusing BIND_TYPE = BindAdapterData<int64_t>;\n \t\tauto &func_expr = state.expr.Cast<BoundFunctionExpression>();\n-\t\tauto &info = func_expr.bind_info->Cast<BIND_TYPE>();\n+\t\tauto &info = func_expr.bind_info->Cast<BindStructData>();\n \t\tCalendarPtr calendar_ptr(info.calendar->clone());\n \t\tauto calendar = calendar_ptr.get();\n \n@@ -318,9 +373,15 @@ struct ICUDatePart : public ICUDateFunc {\n \t\t\t\t\tauto &child_entry = child_entries[col];\n \t\t\t\t\tif (is_finite) {\n \t\t\t\t\t\tConstantVector::SetNull(*child_entry, false);\n-\t\t\t\t\t\tauto pdata = ConstantVector::GetData<int64_t>(*child_entry);\n-\t\t\t\t\t\tauto adapter = info.adapters[col];\n-\t\t\t\t\t\tpdata[0] = adapter(calendar, micros);\n+\t\t\t\t\t\tif (IsBigintDatepart(info.part_codes[col])) {\n+\t\t\t\t\t\t\tauto pdata = ConstantVector::GetData<int64_t>(*child_entry);\n+\t\t\t\t\t\t\tauto adapter = info.bigints[col];\n+\t\t\t\t\t\t\tpdata[0] = adapter(calendar, micros);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tauto pdata = ConstantVector::GetData<double>(*child_entry);\n+\t\t\t\t\t\t\tauto adapter = info.doubles[col];\n+\t\t\t\t\t\t\tpdata[0] = adapter(calendar, micros);\n+\t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\tConstantVector::SetNull(*child_entry, true);\n \t\t\t\t\t}\n@@ -350,9 +411,15 @@ struct ICUDatePart : public ICUDateFunc {\n \t\t\t\t\t\tauto &child_entry = child_entries[col];\n \t\t\t\t\t\tif (is_finite) {\n \t\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetValid(i);\n-\t\t\t\t\t\t\tauto pdata = FlatVector::GetData<int64_t>(*child_entry);\n-\t\t\t\t\t\t\tauto adapter = info.adapters[col];\n-\t\t\t\t\t\t\tpdata[i] = adapter(calendar, micros);\n+\t\t\t\t\t\t\tif (IsBigintDatepart(info.part_codes[col])) {\n+\t\t\t\t\t\t\t\tauto pdata = ConstantVector::GetData<int64_t>(*child_entry);\n+\t\t\t\t\t\t\t\tauto adapter = info.bigints[col];\n+\t\t\t\t\t\t\t\tpdata[i] = adapter(calendar, micros);\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tauto pdata = ConstantVector::GetData<double>(*child_entry);\n+\t\t\t\t\t\t\t\tauto adapter = info.doubles[col];\n+\t\t\t\t\t\t\t\tpdata[i] = adapter(calendar, micros);\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetInvalid(i);\n \t\t\t\t\t\t}\n@@ -376,19 +443,54 @@ struct ICUDatePart : public ICUDateFunc {\n \t\treturn make_uniq<BIND_TYPE>(context, adapter);\n \t}\n \n-\tstatic duckdb::unique_ptr<FunctionData> BindDatePart(ClientContext &context, ScalarFunction &bound_function,\n-\t                                                     vector<duckdb::unique_ptr<Expression>> &arguments) {\n+\tstatic duckdb::unique_ptr<FunctionData> BindUnaryDatePart(ClientContext &context, ScalarFunction &bound_function,\n+\t                                                          vector<duckdb::unique_ptr<Expression>> &arguments) {\n+\t\tconst auto part_code = GetDatePartSpecifier(bound_function.name);\n+\t\tif (IsBigintDatepart(part_code)) {\n+\t\t\tusing data_t = BindAdapterData<int64_t>;\n+\t\t\tauto adapter = PartCodeBigintFactory(part_code);\n+\t\t\treturn BindAdapter<data_t>(context, bound_function, arguments, adapter);\n+\t\t} else {\n+\t\t\tusing data_t = BindAdapterData<double>;\n+\t\t\tauto adapter = PartCodeDoubleFactory(part_code);\n+\t\t\treturn BindAdapter<data_t>(context, bound_function, arguments, adapter);\n+\t\t}\n+\t}\n+\n+\tstatic duckdb::unique_ptr<FunctionData> BindBinaryDatePart(ClientContext &context, ScalarFunction &bound_function,\n+\t                                                           vector<duckdb::unique_ptr<Expression>> &arguments) {\n+\t\t//\tIf we are only looking for Julian Days, then patch in the unary function.\n+\t\tdo {\n+\t\t\tif (arguments[0]->HasParameter() || !arguments[0]->IsFoldable()) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tValue part_value = ExpressionExecutor::EvaluateScalar(context, *arguments[0]);\n+\t\t\tif (part_value.IsNull()) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tconst auto part_name = part_value.ToString();\n+\t\t\tconst auto part_code = GetDatePartSpecifier(part_name);\n+\t\t\tif (IsBigintDatepart(part_code)) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\targuments.erase(arguments.begin());\n+\t\t\tbound_function.arguments.erase(bound_function.arguments.begin());\n+\t\t\tbound_function.name = part_name;\n+\t\t\tbound_function.return_type = LogicalType::DOUBLE;\n+\t\t\tbound_function.function = UnaryTimestampFunction<timestamp_t, double>;\n+\n+\t\t\treturn BindUnaryDatePart(context, bound_function, arguments);\n+\t\t} while (false);\n+\n \t\tusing data_t = BindAdapterData<int64_t>;\n-\t\tauto adapter =\n-\t\t    (arguments.size() == 1) ? PartCodeAdapterFactory(GetDatePartSpecifier(bound_function.name)) : nullptr;\n-\t\treturn BindAdapter<data_t>(context, bound_function, arguments, adapter);\n+\t\treturn BindAdapter<data_t>(context, bound_function, arguments, nullptr);\n \t}\n \n \tstatic duckdb::unique_ptr<FunctionData> BindStruct(ClientContext &context, ScalarFunction &bound_function,\n \t                                                   vector<duckdb::unique_ptr<Expression>> &arguments) {\n-\t\tusing data_t = BindAdapterData<int64_t>;\n-\t\tusing adapters_t = data_t::adapters_t;\n-\n \t\t// collect names and deconflict, construct return type\n \t\tif (arguments[0]->HasParameter()) {\n \t\t\tthrow ParameterNotResolvedException();\n@@ -399,7 +501,9 @@ struct ICUDatePart : public ICUDateFunc {\n \n \t\tcase_insensitive_set_t name_collision_set;\n \t\tchild_list_t<LogicalType> struct_children;\n-\t\tadapters_t adapters;\n+\t\tBindStructData::part_codes_t part_codes;\n+\t\tBindStructData::bigints_t bigints;\n+\t\tBindStructData::doubles_t doubles;\n \n \t\tValue parts_list = ExpressionExecutor::EvaluateScalar(context, *arguments[0]);\n \t\tif (parts_list.type().id() == LogicalTypeId::LIST) {\n@@ -407,7 +511,11 @@ struct ICUDatePart : public ICUDateFunc {\n \t\t\tif (list_children.empty()) {\n \t\t\t\tthrow BinderException(\"%s requires non-empty lists of part names\", bound_function.name);\n \t\t\t}\n-\t\t\tfor (const auto &part_value : list_children) {\n+\n+\t\t\tbigints.resize(list_children.size(), nullptr);\n+\t\t\tdoubles.resize(list_children.size(), nullptr);\n+\t\t\tfor (size_t col = 0; col < list_children.size(); ++col) {\n+\t\t\t\tconst auto &part_value = list_children[col];\n \t\t\t\tif (part_value.IsNull()) {\n \t\t\t\t\tthrow BinderException(\"NULL struct entry name in %s\", bound_function.name);\n \t\t\t\t}\n@@ -417,8 +525,14 @@ struct ICUDatePart : public ICUDateFunc {\n \t\t\t\t\tthrow BinderException(\"Duplicate struct entry name \\\"%s\\\" in %s\", part_name, bound_function.name);\n \t\t\t\t}\n \t\t\t\tname_collision_set.insert(part_name);\n-\t\t\t\tadapters.emplace_back(PartCodeAdapterFactory(part_code));\n-\t\t\t\tstruct_children.emplace_back(make_pair(part_name, LogicalType::BIGINT));\n+\t\t\t\tpart_codes.emplace_back(part_code);\n+\t\t\t\tif (IsBigintDatepart(part_code)) {\n+\t\t\t\t\tbigints[col] = PartCodeBigintFactory(part_code);\n+\t\t\t\t\tstruct_children.emplace_back(make_pair(part_name, LogicalType::BIGINT));\n+\t\t\t\t} else {\n+\t\t\t\t\tdoubles[col] = PartCodeDoubleFactory(part_code);\n+\t\t\t\t\tstruct_children.emplace_back(make_pair(part_name, LogicalType::DOUBLE));\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tthrow BinderException(\"%s can only take constant lists of part names\", bound_function.name);\n@@ -426,7 +540,7 @@ struct ICUDatePart : public ICUDateFunc {\n \n \t\tFunction::EraseArgument(bound_function, arguments, 0);\n \t\tbound_function.return_type = LogicalType::STRUCT(std::move(struct_children));\n-\t\treturn make_uniq<data_t>(context, adapters);\n+\t\treturn make_uniq<BindStructData>(context, part_codes, bigints, doubles);\n \t}\n \n \tstatic void SerializeFunction(FieldWriter &writer, const FunctionData *bind_data_p,\n@@ -440,15 +554,18 @@ struct ICUDatePart : public ICUDateFunc {\n \t}\n \n \ttemplate <typename INPUT_TYPE, typename RESULT_TYPE>\n-\tstatic ScalarFunction GetUnaryPartCodeFunction(const LogicalType &temporal_type) {\n-\t\treturn ScalarFunction({temporal_type}, LogicalType::BIGINT, UnaryTimestampFunction<INPUT_TYPE, RESULT_TYPE>,\n-\t\t                      BindDatePart);\n+\tstatic ScalarFunction GetUnaryPartCodeFunction(const LogicalType &temporal_type,\n+\t                                               const LogicalType &result_type = LogicalType::BIGINT) {\n+\t\treturn ScalarFunction({temporal_type}, result_type, UnaryTimestampFunction<INPUT_TYPE, RESULT_TYPE>,\n+\t\t                      BindUnaryDatePart);\n \t}\n \n-\tstatic void AddUnaryPartCodeFunctions(const string &name, ClientContext &context) {\n+\ttemplate <typename RESULT_TYPE = int64_t>\n+\tstatic void AddUnaryPartCodeFunctions(const string &name, ClientContext &context,\n+\t                                      const LogicalType &result_type = LogicalType::BIGINT) {\n \t\tauto &catalog = Catalog::GetSystemCatalog(context);\n \t\tScalarFunctionSet set(name);\n-\t\tset.AddFunction(GetUnaryPartCodeFunction<timestamp_t, int64_t>(LogicalType::TIMESTAMP_TZ));\n+\t\tset.AddFunction(GetUnaryPartCodeFunction<timestamp_t, RESULT_TYPE>(LogicalType::TIMESTAMP_TZ, result_type));\n \t\tCreateScalarFunctionInfo func_info(set);\n \t\tcatalog.AddFunction(context, func_info);\n \t}\n@@ -456,7 +573,7 @@ struct ICUDatePart : public ICUDateFunc {\n \ttemplate <typename INPUT_TYPE, typename RESULT_TYPE>\n \tstatic ScalarFunction GetBinaryPartCodeFunction(const LogicalType &temporal_type) {\n \t\treturn ScalarFunction({LogicalType::VARCHAR, temporal_type}, LogicalType::BIGINT,\n-\t\t                      BinaryTimestampFunction<INPUT_TYPE, RESULT_TYPE>, BindDatePart);\n+\t\t                      BinaryTimestampFunction<INPUT_TYPE, RESULT_TYPE>, BindBinaryDatePart);\n \t}\n \n \ttemplate <typename INPUT_TYPE>\n@@ -561,6 +678,8 @@ void RegisterICUDatePartFunctions(ClientContext &context) {\n \tICUDatePart::AddUnaryPartCodeFunctions(\"timezone_hour\", context);\n \tICUDatePart::AddUnaryPartCodeFunctions(\"timezone_minute\", context);\n \n+\tICUDatePart::AddUnaryPartCodeFunctions<double>(\"julian\", context, LogicalType::DOUBLE);\n+\n \t//  register combinations\n \tICUDatePart::AddUnaryPartCodeFunctions(\"yearweek\", context); //  Note this is ISO year and week\n \ndiff --git a/extension/icu/icu-datesub.cpp b/extension/icu/icu-datesub.cpp\nindex 16587a2b4c14..beb35f331493 100644\n--- a/extension/icu/icu-datesub.cpp\n+++ b/extension/icu/icu-datesub.cpp\n@@ -171,6 +171,7 @@ ICUDateFunc::part_sub_t ICUDateFunc::SubtractFactory(DatePartSpecifier type) {\n \tcase DatePartSpecifier::DOW:\n \tcase DatePartSpecifier::ISODOW:\n \tcase DatePartSpecifier::DOY:\n+\tcase DatePartSpecifier::JULIAN_DAY:\n \t\treturn ICUCalendarSub::SubtractDay;\n \tcase DatePartSpecifier::HOUR:\n \t\treturn ICUCalendarSub::SubtractHour;\ndiff --git a/extension/icu/icu-datetrunc.cpp b/extension/icu/icu-datetrunc.cpp\nindex 8f4f1945d53b..7e6ebc98a7d4 100644\n--- a/extension/icu/icu-datetrunc.cpp\n+++ b/extension/icu/icu-datetrunc.cpp\n@@ -175,6 +175,7 @@ ICUDateFunc::part_trunc_t ICUDateFunc::TruncationFactory(DatePartSpecifier type)\n \tcase DatePartSpecifier::DOW:\n \tcase DatePartSpecifier::ISODOW:\n \tcase DatePartSpecifier::DOY:\n+\tcase DatePartSpecifier::JULIAN_DAY:\n \t\treturn ICUDateTrunc::TruncDay;\n \tcase DatePartSpecifier::HOUR:\n \t\treturn ICUDateTrunc::TruncHour;\ndiff --git a/src/common/enum_util.cpp b/src/common/enum_util.cpp\nindex 0df35c5a2f97..3c5c24bd47a0 100644\n--- a/src/common/enum_util.cpp\n+++ b/src/common/enum_util.cpp\n@@ -1154,6 +1154,8 @@ const char* EnumUtil::ToChars<DatePartSpecifier>(DatePartSpecifier value) {\n \t\treturn \"TIMEZONE_HOUR\";\n \tcase DatePartSpecifier::TIMEZONE_MINUTE:\n \t\treturn \"TIMEZONE_MINUTE\";\n+\tcase DatePartSpecifier::JULIAN_DAY:\n+\t\treturn \"JULIAN_DAY\";\n \tdefault:\n \t\tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%d' not implemented\", value));\n \t}\n@@ -1230,6 +1232,9 @@ DatePartSpecifier EnumUtil::FromString<DatePartSpecifier>(const char *value) {\n \tif (StringUtil::Equals(value, \"TIMEZONE_MINUTE\")) {\n \t\treturn DatePartSpecifier::TIMEZONE_MINUTE;\n \t}\n+\tif (StringUtil::Equals(value, \"JULIAN_DAY\")) {\n+\t\treturn DatePartSpecifier::JULIAN_DAY;\n+\t}\n \tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%s' not implemented\", value));\n }\n \ndiff --git a/src/common/enums/date_part_specifier.cpp b/src/common/enums/date_part_specifier.cpp\nindex ff2c08a45932..4a633a51515e 100644\n--- a/src/common/enums/date_part_specifier.cpp\n+++ b/src/common/enums/date_part_specifier.cpp\n@@ -65,6 +65,8 @@ bool TryGetDatePartSpecifier(const string &specifier_p, DatePartSpecifier &resul\n \t\tresult = DatePartSpecifier::TIMEZONE_HOUR;\n \t} else if (specifier == \"timezone_minute\") {\n \t\tresult = DatePartSpecifier::TIMEZONE_MINUTE;\n+\t} else if (specifier == \"julian\" || specifier == \"jd\") {\n+\t\tresult = DatePartSpecifier::JULIAN_DAY;\n \t} else {\n \t\treturn false;\n \t}\ndiff --git a/src/common/types/date.cpp b/src/common/types/date.cpp\nindex 61f3f0a4ef79..780576b105da 100644\n--- a/src/common/types/date.cpp\n+++ b/src/common/types/date.cpp\n@@ -490,6 +490,12 @@ int32_t Date::ExtractDayOfTheYear(date_t date) {\n \treturn date.days - Date::CUMULATIVE_YEAR_DAYS[year_offset] + 1;\n }\n \n+int64_t Date::ExtractJulianDay(date_t date) {\n+\t// Julian Day 0 is (-4713, 11, 24) in the proleptic Gregorian calendar.\n+\tstatic const auto JULIAN_EPOCH = -2440588;\n+\treturn date.days - JULIAN_EPOCH;\n+}\n+\n int32_t Date::ExtractISODayOfTheWeek(date_t date) {\n \t// date of 0 is 1970-01-01, which was a Thursday (4)\n \t// -7 = 4\ndiff --git a/src/common/types/timestamp.cpp b/src/common/types/timestamp.cpp\nindex 54517ecf4062..f0f5796d1824 100644\n--- a/src/common/types/timestamp.cpp\n+++ b/src/common/types/timestamp.cpp\n@@ -341,4 +341,11 @@ int64_t Timestamp::GetEpochNanoSeconds(timestamp_t timestamp) {\n \treturn result;\n }\n \n+double Timestamp::GetJulianDay(timestamp_t timestamp) {\n+\tdouble result = Timestamp::GetTime(timestamp).micros;\n+\tresult /= Interval::MICROS_PER_DAY;\n+\tresult += Date::ExtractJulianDay(Timestamp::GetDate(timestamp));\n+\treturn result;\n+}\n+\n } // namespace duckdb\ndiff --git a/src/core_functions/function_list.cpp b/src/core_functions/function_list.cpp\nindex f1b393b7c0f7..79ddbebc0784 100644\n--- a/src/core_functions/function_list.cpp\n+++ b/src/core_functions/function_list.cpp\n@@ -182,6 +182,7 @@ static StaticFunctionDefinition internal_functions[] = {\n \tDUCKDB_SCALAR_FUNCTION(JaccardFun),\n \tDUCKDB_SCALAR_FUNCTION(JaroSimilarityFun),\n \tDUCKDB_SCALAR_FUNCTION(JaroWinklerSimilarityFun),\n+\tDUCKDB_SCALAR_FUNCTION_SET(JulianDayFun),\n \tDUCKDB_AGGREGATE_FUNCTION(KahanSumFun),\n \tDUCKDB_AGGREGATE_FUNCTION(KurtosisFun),\n \tDUCKDB_SCALAR_FUNCTION_SET(LastDayFun),\ndiff --git a/src/core_functions/scalar/date/date_diff.cpp b/src/core_functions/scalar/date/date_diff.cpp\nindex 7eed6a9e4275..8fdd808d32ee 100644\n--- a/src/core_functions/scalar/date/date_diff.cpp\n+++ b/src/core_functions/scalar/date/date_diff.cpp\n@@ -304,6 +304,7 @@ static int64_t DifferenceDates(DatePartSpecifier type, TA startdate, TB enddate)\n \tcase DatePartSpecifier::DOW:\n \tcase DatePartSpecifier::ISODOW:\n \tcase DatePartSpecifier::DOY:\n+\tcase DatePartSpecifier::JULIAN_DAY:\n \t\treturn DateDiff::DayOperator::template Operation<TA, TB, TR>(startdate, enddate);\n \tcase DatePartSpecifier::DECADE:\n \t\treturn DateDiff::DecadeOperator::template Operation<TA, TB, TR>(startdate, enddate);\n@@ -359,6 +360,7 @@ static void DateDiffBinaryExecutor(DatePartSpecifier type, Vector &left, Vector\n \tcase DatePartSpecifier::DOW:\n \tcase DatePartSpecifier::ISODOW:\n \tcase DatePartSpecifier::DOY:\n+\tcase DatePartSpecifier::JULIAN_DAY:\n \t\tDateDiff::BinaryExecute<TA, TB, TR, DateDiff::DayOperator>(left, right, result, count);\n \t\tbreak;\n \tcase DatePartSpecifier::DECADE:\ndiff --git a/src/core_functions/scalar/date/date_part.cpp b/src/core_functions/scalar/date/date_part.cpp\nindex 33b532cf48d6..57bc1d4b0cce 100644\n--- a/src/core_functions/scalar/date/date_part.cpp\n+++ b/src/core_functions/scalar/date/date_part.cpp\n@@ -37,6 +37,7 @@ DatePartSpecifier GetDateTypePartSpecifier(const string &specifier, LogicalType\n \t\tcase DatePartSpecifier::DOY:\n \t\tcase DatePartSpecifier::YEARWEEK:\n \t\tcase DatePartSpecifier::ERA:\n+\t\tcase DatePartSpecifier::JULIAN_DAY:\n \t\t\treturn part;\n \t\tdefault:\n \t\t\tbreak;\n@@ -97,8 +98,9 @@ static unique_ptr<BaseStatistics> PropagateSimpleDatePartStatistics(vector<BaseS\n }\n \n struct DatePart {\n-\ttemplate <class T, class OP>\n-\tstatic unique_ptr<BaseStatistics> PropagateDatePartStatistics(vector<BaseStatistics> &child_stats) {\n+\ttemplate <class T, class OP, class TR = int64_t>\n+\tstatic unique_ptr<BaseStatistics> PropagateDatePartStatistics(vector<BaseStatistics> &child_stats,\n+\t                                                              const LogicalType &stats_type = LogicalType::BIGINT) {\n \t\t// we can only propagate complex date part stats if the child has stats\n \t\tauto &nstats = child_stats[0];\n \t\tif (!NumericStats::HasMinMax(nstats)) {\n@@ -114,11 +116,11 @@ struct DatePart {\n \t\tif (!Value::IsFinite(min) || !Value::IsFinite(max)) {\n \t\t\treturn nullptr;\n \t\t}\n-\t\tauto min_part = OP::template Operation<T, int64_t>(min);\n-\t\tauto max_part = OP::template Operation<T, int64_t>(max);\n-\t\tauto result = NumericStats::CreateEmpty(LogicalType::BIGINT);\n-\t\tNumericStats::SetMin(result, Value::BIGINT(min_part));\n-\t\tNumericStats::SetMax(result, Value::BIGINT(max_part));\n+\t\tTR min_part = OP::template Operation<T, TR>(min);\n+\t\tTR max_part = OP::template Operation<T, TR>(max);\n+\t\tauto result = NumericStats::CreateEmpty(stats_type);\n+\t\tNumericStats::SetMin(result, Value(min_part));\n+\t\tNumericStats::SetMax(result, Value(max_part));\n \t\tresult.CopyValidity(child_stats[0]);\n \t\treturn result.ToUnique();\n \t}\n@@ -499,6 +501,18 @@ struct DatePart {\n \t\t}\n \t};\n \n+\tstruct JulianDayOperator {\n+\t\ttemplate <class TA, class TR>\n+\t\tstatic inline TR Operation(TA input) {\n+\t\t\treturn Timestamp::GetJulianDay(input);\n+\t\t}\n+\n+\t\ttemplate <class T>\n+\t\tstatic unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {\n+\t\t\treturn PropagateDatePartStatistics<T, JulianDayOperator, double>(input.child_stats, LogicalType::DOUBLE);\n+\t\t}\n+\t};\n+\n \t// These are all zero and have the same restrictions\n \tusing TimezoneHourOperator = TimezoneOperator;\n \tusing TimezoneMinuteOperator = TimezoneOperator;\n@@ -514,7 +528,8 @@ struct DatePart {\n \t\t\tEPOCH = 1 << 3,\n \t\t\tTIME = 1 << 4,\n \t\t\tZONE = 1 << 5,\n-\t\t\tISO = 1 << 6\n+\t\t\tISO = 1 << 6,\n+\t\t\tJD = 1 << 7\n \t\t};\n \n \t\tstatic part_mask_t GetMask(const part_codes_t &part_codes) {\n@@ -546,6 +561,9 @@ struct DatePart {\n \t\t\t\tcase DatePartSpecifier::EPOCH:\n \t\t\t\t\tmask |= EPOCH;\n \t\t\t\t\tbreak;\n+\t\t\t\tcase DatePartSpecifier::JULIAN_DAY:\n+\t\t\t\t\tmask |= JD;\n+\t\t\t\t\tbreak;\n \t\t\t\tcase DatePartSpecifier::MICROSECONDS:\n \t\t\t\tcase DatePartSpecifier::MILLISECONDS:\n \t\t\t\tcase DatePartSpecifier::SECOND:\n@@ -564,63 +582,73 @@ struct DatePart {\n \t\t}\n \n \t\ttemplate <typename P>\n-\t\tstatic inline P HasPartValue(P *part_values, DatePartSpecifier part) {\n-\t\t\treturn part_values[int(part)];\n+\t\tstatic inline P HasPartValue(vector<P> part_values, DatePartSpecifier part) {\n+\t\t\tstatic const auto BEGIN_DOUBLE = size_t(DatePartSpecifier::JULIAN_DAY);\n+\t\t\tauto idx = size_t(part);\n+\t\t\tif (IsBigintDatepart(part)) {\n+\t\t\t\treturn part_values[idx];\n+\t\t\t} else {\n+\t\t\t\treturn part_values[idx - BEGIN_DOUBLE];\n+\t\t\t}\n \t\t}\n \n-\t\ttemplate <class TA, class TR>\n-\t\tstatic inline void Operation(TR **part_values, const TA &input, const idx_t idx, const part_mask_t mask) {\n-\t\t\tTR *part_data;\n+\t\tusing bigint_vec = vector<int64_t *>;\n+\t\tusing double_vec = vector<double *>;\n+\n+\t\ttemplate <class TA>\n+\t\tstatic inline void Operation(bigint_vec &bigint_values, double_vec &double_values, const TA &input,\n+\t\t                             const idx_t idx, const part_mask_t mask) {\n+\t\t\tint64_t *bigint_data;\n \t\t\t// YMD calculations\n \t\t\tint32_t yyyy = 1970;\n \t\t\tint32_t mm = 0;\n \t\t\tint32_t dd = 1;\n \t\t\tif (mask & YMD) {\n \t\t\t\tDate::Convert(input, yyyy, mm, dd);\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::YEAR);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = yyyy;\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::YEAR);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = yyyy;\n \t\t\t\t}\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::MONTH);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = mm;\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::MONTH);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = mm;\n \t\t\t\t}\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::DAY);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = dd;\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::DAY);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = dd;\n \t\t\t\t}\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::DECADE);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = DecadeOperator::DecadeFromYear(yyyy);\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::DECADE);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = DecadeOperator::DecadeFromYear(yyyy);\n \t\t\t\t}\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::CENTURY);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = CenturyOperator::CenturyFromYear(yyyy);\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::CENTURY);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = CenturyOperator::CenturyFromYear(yyyy);\n \t\t\t\t}\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::MILLENNIUM);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = MillenniumOperator::MillenniumFromYear(yyyy);\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::MILLENNIUM);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = MillenniumOperator::MillenniumFromYear(yyyy);\n \t\t\t\t}\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::QUARTER);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = QuarterOperator::QuarterFromMonth(mm);\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::QUARTER);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = QuarterOperator::QuarterFromMonth(mm);\n \t\t\t\t}\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::ERA);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = EraOperator::EraFromYear(yyyy);\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::ERA);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = EraOperator::EraFromYear(yyyy);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t// Week calculations\n \t\t\tif (mask & DOW) {\n \t\t\t\tauto isodow = Date::ExtractISODayOfTheWeek(input);\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::DOW);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = DayOfWeekOperator::DayOfWeekFromISO(isodow);\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::DOW);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = DayOfWeekOperator::DayOfWeekFromISO(isodow);\n \t\t\t\t}\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::ISODOW);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = isodow;\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::ISODOW);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = isodow;\n \t\t\t\t}\n \t\t\t}\n \n@@ -629,30 +657,36 @@ struct DatePart {\n \t\t\t\tint32_t ww = 0;\n \t\t\t\tint32_t iyyy = 0;\n \t\t\t\tDate::ExtractISOYearWeek(input, iyyy, ww);\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::WEEK);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = ww;\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::WEEK);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = ww;\n \t\t\t\t}\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::ISOYEAR);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = iyyy;\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::ISOYEAR);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = iyyy;\n \t\t\t\t}\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::YEARWEEK);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = YearWeekOperator::YearWeekFromParts(iyyy, ww);\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::YEARWEEK);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = YearWeekOperator::YearWeekFromParts(iyyy, ww);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (mask & EPOCH) {\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::EPOCH);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = Date::Epoch(input);\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = Date::Epoch(input);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (mask & DOY) {\n-\t\t\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::DOY);\n-\t\t\t\tif (part_data) {\n-\t\t\t\t\tpart_data[idx] = Date::ExtractDayOfTheYear(input);\n+\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::DOY);\n+\t\t\t\tif (bigint_data) {\n+\t\t\t\t\tbigint_data[idx] = Date::ExtractDayOfTheYear(input);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (mask & JD) {\n+\t\t\t\tauto double_data = HasPartValue(double_values, DatePartSpecifier::JULIAN_DAY);\n+\t\t\t\tif (double_data) {\n+\t\t\t\t\tdouble_data[idx] = Date::ExtractJulianDay(input);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -1046,35 +1080,50 @@ int64_t DatePart::TimezoneOperator::Operation(dtime_t input) {\n }\n \n template <>\n-void DatePart::StructOperator::Operation(int64_t **part_values, const dtime_t &input, const idx_t idx,\n-                                         const part_mask_t mask) {\n+double DatePart::JulianDayOperator::Operation(date_t input) {\n+\treturn Date::ExtractJulianDay(input);\n+}\n+\n+template <>\n+double DatePart::JulianDayOperator::Operation(interval_t input) {\n+\tthrow NotImplementedException(\"interval units \\\"julian\\\" not recognized\");\n+}\n+\n+template <>\n+double DatePart::JulianDayOperator::Operation(dtime_t input) {\n+\tthrow NotImplementedException(\"\\\"time\\\" units \\\"julian\\\" not recognized\");\n+}\n+\n+template <>\n+void DatePart::StructOperator::Operation(bigint_vec &bigint_values, double_vec &double_values, const dtime_t &input,\n+                                         const idx_t idx, const part_mask_t mask) {\n \tint64_t *part_data;\n \tif (mask & TIME) {\n \t\tconst auto micros = MicrosecondsOperator::Operation<dtime_t, int64_t>(input);\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::MICROSECONDS);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::MICROSECONDS);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = micros;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::MILLISECONDS);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::MILLISECONDS);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = micros / Interval::MICROS_PER_MSEC;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::SECOND);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::SECOND);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = micros / Interval::MICROS_PER_SEC;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::MINUTE);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::MINUTE);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = MinutesOperator::Operation<dtime_t, int64_t>(input);\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::HOUR);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::HOUR);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = HoursOperator::Operation<dtime_t, int64_t>(input);\n \t\t}\n \t}\n \n \tif (mask & EPOCH) {\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::EPOCH);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = EpochOperator::Operation<dtime_t, int64_t>(input);\n \t\t\t;\n@@ -1082,15 +1131,15 @@ void DatePart::StructOperator::Operation(int64_t **part_values, const dtime_t &i\n \t}\n \n \tif (mask & ZONE) {\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::TIMEZONE);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::TIMEZONE);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = 0;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::TIMEZONE_HOUR);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::TIMEZONE_HOUR);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = 0;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::TIMEZONE_MINUTE);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::TIMEZONE_MINUTE);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = 0;\n \t\t}\n@@ -1098,56 +1147,63 @@ void DatePart::StructOperator::Operation(int64_t **part_values, const dtime_t &i\n }\n \n template <>\n-void DatePart::StructOperator::Operation(int64_t **part_values, const timestamp_t &input, const idx_t idx,\n-                                         const part_mask_t mask) {\n+void DatePart::StructOperator::Operation(bigint_vec &bigint_values, double_vec &double_values, const timestamp_t &input,\n+                                         const idx_t idx, const part_mask_t mask) {\n \tdate_t d;\n \tdtime_t t;\n \tTimestamp::Convert(input, d, t);\n \n \t// Both define epoch, and the correct value is the sum.\n \t// So mask it out and compute it separately.\n-\tOperation(part_values, d, idx, mask & ~EPOCH);\n-\tOperation(part_values, t, idx, mask & ~EPOCH);\n+\tOperation(bigint_values, double_values, d, idx, mask & ~EPOCH);\n+\tOperation(bigint_values, double_values, t, idx, mask & ~EPOCH);\n \n \tif (mask & EPOCH) {\n-\t\tauto part_data = HasPartValue(part_values, DatePartSpecifier::EPOCH);\n+\t\tauto part_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = EpochOperator::Operation<timestamp_t, int64_t>(input);\n \t\t}\n \t}\n+\n+\tif (mask & JD) {\n+\t\tauto part_data = HasPartValue(double_values, DatePartSpecifier::JULIAN_DAY);\n+\t\tif (part_data) {\n+\t\t\tpart_data[idx] = JulianDayOperator::Operation<timestamp_t, double>(input);\n+\t\t}\n+\t}\n }\n \n template <>\n-void DatePart::StructOperator::Operation(int64_t **part_values, const interval_t &input, const idx_t idx,\n-                                         const part_mask_t mask) {\n+void DatePart::StructOperator::Operation(bigint_vec &bigint_values, double_vec &double_values, const interval_t &input,\n+                                         const idx_t idx, const part_mask_t mask) {\n \tint64_t *part_data;\n \tif (mask & YMD) {\n \t\tconst auto mm = input.months % Interval::MONTHS_PER_YEAR;\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::YEAR);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::YEAR);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = input.months / Interval::MONTHS_PER_YEAR;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::MONTH);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::MONTH);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = mm;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::DAY);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::DAY);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = input.days;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::DECADE);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::DECADE);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = input.months / Interval::MONTHS_PER_DECADE;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::CENTURY);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::CENTURY);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = input.months / Interval::MONTHS_PER_CENTURY;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::MILLENNIUM);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::MILLENNIUM);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = input.months / Interval::MONTHS_PER_MILLENIUM;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::QUARTER);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::QUARTER);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = mm / Interval::MONTHS_PER_QUARTER + 1;\n \t\t}\n@@ -1155,30 +1211,30 @@ void DatePart::StructOperator::Operation(int64_t **part_values, const interval_t\n \n \tif (mask & TIME) {\n \t\tconst auto micros = MicrosecondsOperator::Operation<interval_t, int64_t>(input);\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::MICROSECONDS);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::MICROSECONDS);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = micros;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::MILLISECONDS);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::MILLISECONDS);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = micros / Interval::MICROS_PER_MSEC;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::SECOND);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::SECOND);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = micros / Interval::MICROS_PER_SEC;\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::MINUTE);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::MINUTE);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = MinutesOperator::Operation<interval_t, int64_t>(input);\n \t\t}\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::HOUR);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::HOUR);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = HoursOperator::Operation<interval_t, int64_t>(input);\n \t\t}\n \t}\n \n \tif (mask & EPOCH) {\n-\t\tpart_data = HasPartValue(part_values, DatePartSpecifier::EPOCH);\n+\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);\n \t\tif (part_data) {\n \t\t\tpart_data[idx] = EpochOperator::Operation<interval_t, int64_t>(input);\n \t\t}\n@@ -1254,6 +1310,45 @@ static void DatePartFunction(DataChunk &args, ExpressionState &state, Vector &re\n \t    });\n }\n \n+static unique_ptr<FunctionData> DatePartBind(ClientContext &context, ScalarFunction &bound_function,\n+                                             vector<unique_ptr<Expression>> &arguments) {\n+\t//\tIf we are only looking for Julian Days for timestamps,\n+\t//\tthen return doubles.\n+\tif (arguments[0]->HasParameter() || !arguments[0]->IsFoldable()) {\n+\t\treturn nullptr;\n+\t}\n+\n+\tValue part_value = ExpressionExecutor::EvaluateScalar(context, *arguments[0]);\n+\tif (part_value.IsNull()) {\n+\t\treturn nullptr;\n+\t}\n+\tconst auto part_name = part_value.ToString();\n+\tswitch (GetDatePartSpecifier(part_name)) {\n+\tcase DatePartSpecifier::JULIAN_DAY:\n+\t\targuments.erase(arguments.begin());\n+\t\tbound_function.arguments.erase(bound_function.arguments.begin());\n+\t\tbound_function.name = \"julian\";\n+\t\tbound_function.return_type = LogicalType::DOUBLE;\n+\t\tswitch (arguments[0]->return_type.id()) {\n+\t\tcase LogicalType::TIMESTAMP:\n+\t\t\tbound_function.function = DatePart::UnaryFunction<timestamp_t, double, DatePart::JulianDayOperator>;\n+\t\t\tbound_function.statistics = DatePart::JulianDayOperator::template PropagateStatistics<timestamp_t>;\n+\t\t\tbreak;\n+\t\tcase LogicalType::DATE:\n+\t\t\tbound_function.function = DatePart::UnaryFunction<date_t, double, DatePart::JulianDayOperator>;\n+\t\t\tbound_function.statistics = DatePart::JulianDayOperator::template PropagateStatistics<date_t>;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow BinderException(\"%s can only take DATE or TIMESTAMP arguments\", bound_function.name);\n+\t\t}\n+\t\tbreak;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\n+\treturn nullptr;\n+}\n+\n ScalarFunctionSet GetGenericDatePartFunction(scalar_function_t date_func, scalar_function_t ts_func,\n                                              scalar_function_t interval_func, function_statistics_t date_stats,\n                                              function_statistics_t ts_stats) {\n@@ -1332,6 +1427,10 @@ struct DayNameOperator {\n struct StructDatePart {\n \tusing part_codes_t = vector<DatePartSpecifier>;\n \n+\tstatic const auto BEGIN_BIGINT = size_t(DatePartSpecifier::YEAR);\n+\tstatic const auto BEGIN_DOUBLE = size_t(DatePartSpecifier::JULIAN_DAY);\n+\tstatic const auto BEGIN_INVALID = size_t(DatePartSpecifier::JULIAN_DAY) + 1;\n+\n \tstruct BindData : public VariableReturnBindData {\n \t\tpart_codes_t part_codes;\n \n@@ -1375,7 +1474,8 @@ struct StructDatePart {\n \t\t\t\t}\n \t\t\t\tname_collision_set.insert(part_name);\n \t\t\t\tpart_codes.emplace_back(part_code);\n-\t\t\t\tstruct_children.emplace_back(make_pair(part_name, LogicalType::BIGINT));\n+\t\t\t\tconst auto part_type = IsBigintDatepart(part_code) ? LogicalType::BIGINT : LogicalType::DOUBLE;\n+\t\t\t\tstruct_children.emplace_back(make_pair(part_name, part_type));\n \t\t\t}\n \t\t} else {\n \t\t\tthrow BinderException(\"%s can only take constant lists of part names\", bound_function.name);\n@@ -1394,14 +1494,15 @@ struct StructDatePart {\n \n \t\tconst auto count = args.size();\n \t\tVector &input = args.data[0];\n-\t\tvector<int64_t *> part_values(int(DatePartSpecifier::TIMEZONE_MINUTE) + 1, nullptr);\n+\t\tDatePart::StructOperator::bigint_vec bigint_values(size_t(BEGIN_DOUBLE), nullptr);\n+\t\tDatePart::StructOperator::double_vec double_values(BEGIN_INVALID - size_t(BEGIN_DOUBLE), nullptr);\n \t\tconst auto part_mask = DatePart::StructOperator::GetMask(info.part_codes);\n \n \t\tauto &child_entries = StructVector::GetEntries(result);\n \n \t\t// The first computer of a part \"owns\" it\n \t\t// and other requestors just reference the owner\n-\t\tvector<size_t> owners(int(DatePartSpecifier::TIMEZONE_MINUTE) + 1, child_entries.size());\n+\t\tvector<size_t> owners(int(DatePartSpecifier::JULIAN_DAY) + 1, child_entries.size());\n \t\tfor (size_t col = 0; col < child_entries.size(); ++col) {\n \t\t\tconst auto part_index = size_t(info.part_codes[col]);\n \t\t\tif (owners[part_index] == child_entries.size()) {\n@@ -1421,12 +1522,16 @@ struct StructDatePart {\n \t\t\t\t\tConstantVector::SetNull(*child_entry, false);\n \t\t\t\t\tconst auto part_index = size_t(info.part_codes[col]);\n \t\t\t\t\tif (owners[part_index] == col) {\n-\t\t\t\t\t\tpart_values[part_index] = ConstantVector::GetData<int64_t>(*child_entry);\n+\t\t\t\t\t\tif (IsBigintDatepart(info.part_codes[col])) {\n+\t\t\t\t\t\t\tbigint_values[part_index - BEGIN_BIGINT] = ConstantVector::GetData<int64_t>(*child_entry);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tdouble_values[part_index - BEGIN_DOUBLE] = ConstantVector::GetData<double>(*child_entry);\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tauto tdata = ConstantVector::GetData<INPUT_TYPE>(input);\n \t\t\t\tif (Value::IsFinite(tdata[0])) {\n-\t\t\t\t\tDatePart::StructOperator::Operation(part_values.data(), tdata[0], 0, part_mask);\n+\t\t\t\t\tDatePart::StructOperator::Operation(bigint_values, double_values, tdata[0], 0, part_mask);\n \t\t\t\t} else {\n \t\t\t\t\tfor (auto &child_entry : child_entries) {\n \t\t\t\t\t\tConstantVector::SetNull(*child_entry, true);\n@@ -1459,7 +1564,11 @@ struct StructDatePart {\n \t\t\t\t// Pre-multiplex\n \t\t\t\tconst auto part_index = size_t(info.part_codes[col]);\n \t\t\t\tif (owners[part_index] == col) {\n-\t\t\t\t\tpart_values[part_index] = FlatVector::GetData<int64_t>(*child_entry);\n+\t\t\t\t\tif (IsBigintDatepart(info.part_codes[col])) {\n+\t\t\t\t\t\tbigint_values[part_index - BEGIN_BIGINT] = FlatVector::GetData<int64_t>(*child_entry);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tdouble_values[part_index - BEGIN_DOUBLE] = FlatVector::GetData<double>(*child_entry);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n@@ -1467,7 +1576,7 @@ struct StructDatePart {\n \t\t\t\tconst auto idx = rdata.sel->get_index(i);\n \t\t\t\tif (arg_valid.RowIsValid(idx)) {\n \t\t\t\t\tif (Value::IsFinite(tdata[idx])) {\n-\t\t\t\t\t\tDatePart::StructOperator::Operation(part_values.data(), tdata[idx], i, part_mask);\n+\t\t\t\t\t\tDatePart::StructOperator::Operation(bigint_values, double_values, tdata[idx], i, part_mask);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tfor (auto &child_entry : child_entries) {\n \t\t\t\t\t\t\tFlatVector::Validity(*child_entry).SetInvalid(i);\n@@ -1695,16 +1804,32 @@ ScalarFunctionSet DayNameFun::GetFunctions() {\n \treturn dayname;\n }\n \n+ScalarFunctionSet JulianDayFun::GetFunctions() {\n+\tusing OP = DatePart::JulianDayOperator;\n+\n+\tScalarFunctionSet operator_set;\n+\tauto date_func = DatePart::UnaryFunction<date_t, double, OP>;\n+\tauto date_stats = OP::template PropagateStatistics<date_t>;\n+\toperator_set.AddFunction(\n+\t    ScalarFunction({LogicalType::DATE}, LogicalType::DOUBLE, date_func, nullptr, nullptr, date_stats));\n+\tauto ts_func = DatePart::UnaryFunction<timestamp_t, double, OP>;\n+\tauto ts_stats = OP::template PropagateStatistics<timestamp_t>;\n+\toperator_set.AddFunction(\n+\t    ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::DOUBLE, ts_func, nullptr, nullptr, ts_stats));\n+\n+\treturn operator_set;\n+}\n+\n ScalarFunctionSet DatePartFun::GetFunctions() {\n \tScalarFunctionSet date_part;\n-\tdate_part.AddFunction(\n-\t    ScalarFunction({LogicalType::VARCHAR, LogicalType::DATE}, LogicalType::BIGINT, DatePartFunction<date_t>));\n+\tdate_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::DATE}, LogicalType::BIGINT,\n+\t                                     DatePartFunction<date_t>, DatePartBind));\n \tdate_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::TIMESTAMP}, LogicalType::BIGINT,\n-\t                                     DatePartFunction<timestamp_t>));\n-\tdate_part.AddFunction(\n-\t    ScalarFunction({LogicalType::VARCHAR, LogicalType::TIME}, LogicalType::BIGINT, DatePartFunction<dtime_t>));\n+\t                                     DatePartFunction<timestamp_t>, DatePartBind));\n+\tdate_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::TIME}, LogicalType::BIGINT,\n+\t                                     DatePartFunction<dtime_t>, DatePartBind));\n \tdate_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::INTERVAL}, LogicalType::BIGINT,\n-\t                                     DatePartFunction<interval_t>));\n+\t                                     DatePartFunction<interval_t>, DatePartBind));\n \n \t// struct variants\n \tdate_part.AddFunction(StructDatePart::GetFunction<date_t>(LogicalType::DATE));\ndiff --git a/src/core_functions/scalar/date/date_sub.cpp b/src/core_functions/scalar/date/date_sub.cpp\nindex 30dcfb07f885..6d4c4e249e82 100644\n--- a/src/core_functions/scalar/date/date_sub.cpp\n+++ b/src/core_functions/scalar/date/date_sub.cpp\n@@ -322,6 +322,7 @@ static int64_t SubtractDateParts(DatePartSpecifier type, TA startdate, TB enddat\n \tcase DatePartSpecifier::DOW:\n \tcase DatePartSpecifier::ISODOW:\n \tcase DatePartSpecifier::DOY:\n+\tcase DatePartSpecifier::JULIAN_DAY:\n \t\treturn DateSub::DayOperator::template Operation<TA, TB, TR>(startdate, enddate);\n \tcase DatePartSpecifier::DECADE:\n \t\treturn DateSub::DecadeOperator::template Operation<TA, TB, TR>(startdate, enddate);\n@@ -376,6 +377,7 @@ static void DateSubBinaryExecutor(DatePartSpecifier type, Vector &left, Vector &\n \tcase DatePartSpecifier::DOW:\n \tcase DatePartSpecifier::ISODOW:\n \tcase DatePartSpecifier::DOY:\n+\tcase DatePartSpecifier::JULIAN_DAY:\n \t\tDateSub::BinaryExecute<TA, TB, TR, DateSub::DayOperator>(left, right, result, count);\n \t\tbreak;\n \tcase DatePartSpecifier::DECADE:\ndiff --git a/src/core_functions/scalar/date/date_trunc.cpp b/src/core_functions/scalar/date/date_trunc.cpp\nindex 9638151587f0..0493c71b988c 100644\n--- a/src/core_functions/scalar/date/date_trunc.cpp\n+++ b/src/core_functions/scalar/date/date_trunc.cpp\n@@ -485,6 +485,7 @@ static TR TruncateElement(DatePartSpecifier type, TA element) {\n \tcase DatePartSpecifier::DOW:\n \tcase DatePartSpecifier::ISODOW:\n \tcase DatePartSpecifier::DOY:\n+\tcase DatePartSpecifier::JULIAN_DAY:\n \t\treturn DateTrunc::DayOperator::Operation<TA, TR>(element);\n \tcase DatePartSpecifier::HOUR:\n \t\treturn DateTrunc::HourOperator::Operation<TA, TR>(element);\n@@ -541,6 +542,7 @@ static void DateTruncUnaryExecutor(DatePartSpecifier type, Vector &left, Vector\n \tcase DatePartSpecifier::DOW:\n \tcase DatePartSpecifier::ISODOW:\n \tcase DatePartSpecifier::DOY:\n+\tcase DatePartSpecifier::JULIAN_DAY:\n \t\tDateTrunc::UnaryExecute<TA, TR, DateTrunc::DayOperator>(left, result, count);\n \t\tbreak;\n \tcase DatePartSpecifier::HOUR:\n@@ -641,6 +643,7 @@ static function_statistics_t DateTruncStats(DatePartSpecifier type) {\n \tcase DatePartSpecifier::DOW:\n \tcase DatePartSpecifier::ISODOW:\n \tcase DatePartSpecifier::DOY:\n+\tcase DatePartSpecifier::JULIAN_DAY:\n \t\treturn PropagateDateTruncStatistics<TA, TR, DateTrunc::DayOperator>;\n \tcase DatePartSpecifier::HOUR:\n \t\treturn PropagateDateTruncStatistics<TA, TR, DateTrunc::HourOperator>;\n@@ -685,6 +688,7 @@ static unique_ptr<FunctionData> DateTruncBind(ClientContext &context, ScalarFunc\n \tcase DatePartSpecifier::DOW:\n \tcase DatePartSpecifier::ISODOW:\n \tcase DatePartSpecifier::DOY:\n+\tcase DatePartSpecifier::JULIAN_DAY:\n \t\tswitch (bound_function.arguments[1].id()) {\n \t\tcase LogicalType::TIMESTAMP:\n \t\t\tbound_function.function = DateTruncFunction<timestamp_t, date_t>;\ndiff --git a/src/core_functions/scalar/date/functions.json b/src/core_functions/scalar/date/functions.json\nindex 9e37c7730f15..aaf4b889cc7c 100644\n--- a/src/core_functions/scalar/date/functions.json\n+++ b/src/core_functions/scalar/date/functions.json\n@@ -171,6 +171,14 @@\n         \"example\": \"isoyear(timestamp '2021-08-03 11:59:44.123456')\",\n         \"type\": \"scalar_function_set\"\n     },\n+    {\n+        \"struct\": \"JulianDayFun\",\n+        \"name\": \"julian\",\n+        \"parameters\": \"ts\",\n+        \"description\": \"Extract the Julian Day number from a date or timestamp\",\n+        \"example\": \"julian(timestamp '2006-01-01 12:00')\",\n+        \"type\": \"scalar_function_set\"\n+    },\n     {\n         \"name\": \"last_day\",\n         \"parameters\": \"ts\",\ndiff --git a/src/include/duckdb/common/enums/date_part_specifier.hpp b/src/include/duckdb/common/enums/date_part_specifier.hpp\nindex 7671c40b7514..fc0f243139c7 100644\n--- a/src/include/duckdb/common/enums/date_part_specifier.hpp\n+++ b/src/include/duckdb/common/enums/date_part_specifier.hpp\n@@ -13,6 +13,7 @@\n namespace duckdb {\n \n enum class DatePartSpecifier : uint8_t {\n+\t//\tBIGINT values\n \tYEAR,\n \tMONTH,\n \tDAY,\n@@ -35,9 +36,16 @@ enum class DatePartSpecifier : uint8_t {\n \tERA,\n \tTIMEZONE,\n \tTIMEZONE_HOUR,\n-\tTIMEZONE_MINUTE\n+\tTIMEZONE_MINUTE,\n+\n+\t//\tDOUBLE values\n+\tJULIAN_DAY\n };\n \n+inline bool IsBigintDatepart(DatePartSpecifier part_code) {\n+\treturn size_t(part_code) < size_t(DatePartSpecifier::JULIAN_DAY);\n+}\n+\n DUCKDB_API bool TryGetDatePartSpecifier(const string &specifier, DatePartSpecifier &result);\n DUCKDB_API DatePartSpecifier GetDatePartSpecifier(const string &specifier);\n \ndiff --git a/src/include/duckdb/common/types/date.hpp b/src/include/duckdb/common/types/date.hpp\nindex 9491f46c8e77..8e9bfac863d3 100644\n--- a/src/include/duckdb/common/types/date.hpp\n+++ b/src/include/duckdb/common/types/date.hpp\n@@ -181,6 +181,8 @@ class Date {\n \tDUCKDB_API static int32_t ExtractISODayOfTheWeek(date_t date);\n \t//! Extract the day of the year\n \tDUCKDB_API static int32_t ExtractDayOfTheYear(date_t date);\n+\t//! Extract the day of the year\n+\tDUCKDB_API static int64_t ExtractJulianDay(date_t date);\n \t//! Extract the ISO week number\n \t//! ISO weeks start on Monday and the first week of a year\n \t//! contains January 4 of that year.\ndiff --git a/src/include/duckdb/common/types/timestamp.hpp b/src/include/duckdb/common/types/timestamp.hpp\nindex f6f427d4a2fe..0bb5101a42f0 100644\n--- a/src/include/duckdb/common/types/timestamp.hpp\n+++ b/src/include/duckdb/common/types/timestamp.hpp\n@@ -151,6 +151,8 @@ class Timestamp {\n \tDUCKDB_API static int64_t GetEpochMicroSeconds(timestamp_t timestamp);\n \t//! Convert a timestamp to epoch (in nanoseconds)\n \tDUCKDB_API static int64_t GetEpochNanoSeconds(timestamp_t timestamp);\n+\t//! Convert a timestamp to a Julian Day\n+\tDUCKDB_API static double GetJulianDay(timestamp_t timestamp);\n \n \tDUCKDB_API static bool TryParseUTCOffset(const char *str, idx_t &pos, idx_t len, int &hour_offset,\n \t                                         int &minute_offset);\ndiff --git a/src/include/duckdb/core_functions/scalar/date_functions.hpp b/src/include/duckdb/core_functions/scalar/date_functions.hpp\nindex 0331df80797e..5d512299f83d 100644\n--- a/src/include/duckdb/core_functions/scalar/date_functions.hpp\n+++ b/src/include/duckdb/core_functions/scalar/date_functions.hpp\n@@ -264,6 +264,15 @@ struct ISOYearFun {\n \tstatic ScalarFunctionSet GetFunctions();\n };\n \n+struct JulianDayFun {\n+\tstatic constexpr const char *Name = \"julian\";\n+\tstatic constexpr const char *Parameters = \"ts\";\n+\tstatic constexpr const char *Description = \"Extract the Julian Day number from a date or timestamp\";\n+\tstatic constexpr const char *Example = \"julian(timestamp '2006-01-01 12:00')\";\n+\n+\tstatic ScalarFunctionSet GetFunctions();\n+};\n+\n struct LastDayFun {\n \tstatic constexpr const char *Name = \"last_day\";\n \tstatic constexpr const char *Parameters = \"ts\";\n",
  "test_patch": "diff --git a/test/sql/function/date/test_date_part.test b/test/sql/function/date/test_date_part.test\nindex d10addd52d80..b3738b8bd03d 100644\n--- a/test/sql/function/date/test_date_part.test\n+++ b/test/sql/function/date/test_date_part.test\n@@ -131,6 +131,18 @@ NULL\n NULL\n NULL\n \n+query I\n+SELECT date_part('julian', d) FROM dates;\n+----\n+2448623\n+2448685\n+2448748\n+2459581\n+1705428\n+NULL\n+NULL\n+NULL\n+\n statement error\n SELECT date_part('timezone', d) FROM dates;\n \n@@ -355,6 +367,18 @@ NULL\n NULL\n NULL\n \n+query I\n+SELECT JULIAN(d) FROM dates;\n+----\n+2448623\n+2448685\n+2448748\n+2459581\n+1705428\n+NULL\n+NULL\n+NULL\n+\n query IIIIIIIIIIII\n select\n date_part('quarter', DATE '1992-01-20'),\n@@ -373,7 +397,7 @@ date_part('quarter', DATE '1992-12-20')\n 1\t1\t1\t2\t2\t2\t3\t3\t3\t4\t4\t4\n \n # Correctness: Compare date_part values with scalar values\n-foreach partcode era millennium century decade year quarter month day week weekday isodow dayofyear isoyear yearweek\n+foreach partcode era millennium century decade year quarter month day week weekday isodow dayofyear isoyear yearweek julian\n \n query III\n SELECT d, DATE_PART('${partcode}', d) AS p, ${partcode}(d) AS f\n@@ -469,18 +493,23 @@ infinity\t{'era': NULL, 'millennium': NULL, 'century': NULL, 'decade': NULL, 'qua\n \n # Day parts\n query II\n-SELECT d, DATE_PART(['weekday', 'isodow', 'doy'], d) AS parts\n+SELECT d, DATE_PART(['weekday', 'isodow', 'doy', 'julian'], d) AS parts\n FROM dates\n ORDER BY 1;\n ----\n NULL\tNULL\n--infinity\t{'weekday': NULL, 'isodow': NULL, 'doy': NULL}\n-0044-03-15 (BC)\t{'weekday': 5, 'isodow': 5, 'doy': 74}\n-1992-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1}\n-1992-03-03\t{'weekday': 2, 'isodow': 2, 'doy': 63}\n-1992-05-05\t{'weekday': 2, 'isodow': 2, 'doy': 126}\n-2022-01-01\t{'weekday': 6, 'isodow': 6, 'doy': 1}\n-infinity\t{'weekday': NULL, 'isodow': NULL, 'doy': NULL}\n+-infinity\t{'weekday': NULL, 'isodow': NULL, 'doy': NULL, 'julian': NULL}\n+0044-03-15 (BC)\t{'weekday': 5, 'isodow': 5, 'doy': 74, 'julian': 1705428.0}\n+1992-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1, 'julian': 2448623.0}\n+1992-03-03\t{'weekday': 2, 'isodow': 2, 'doy': 63, 'julian': 2448685.0}\n+1992-05-05\t{'weekday': 2, 'isodow': 2, 'doy': 126, 'julian': 2448748.0}\n+2022-01-01\t{'weekday': 6, 'isodow': 6, 'doy': 1, 'julian': 2459581.0}\n+infinity\t{'weekday': NULL, 'isodow': NULL, 'doy': NULL, 'julian': NULL}\n+\n+query I\n+SELECT DATE_PART(['weekday', 'isodow', 'doy', 'julian'], '2022-01-01'::DATE) AS parts\n+----\n+{'weekday': 6, 'isodow': 6, 'doy': 1, 'julian': 2459581.0}\n \n # ISO parts\n query II\ndiff --git a/test/sql/function/date/test_date_trunc.test b/test/sql/function/date/test_date_trunc.test\nindex 6513501b4d04..a852cb47709f 100644\n--- a/test/sql/function/date/test_date_trunc.test\n+++ b/test/sql/function/date/test_date_trunc.test\n@@ -101,11 +101,15 @@ SELECT date_trunc(s, d) FROM dates;\n # Issue #4388: Verify DATE results for all timestamp types\n foreach temporal TIMESTAMP TIMESTAMP_MS TIMESTAMP_NS TIMESTAMP_S\n \n+foreach datepart day doy dow isodow julian\n+\n query I\n-select date_trunc('day', '2022-08-15 07:52:55'::${temporal});\n+select date_trunc('${datepart}', '2022-08-15 07:52:55'::${temporal});\n ----\n 2022-08-15\n \n+endloop\n+\n query I\n select date_trunc('hour', '2022-08-15 07:52:55'::${temporal});\n ----\ndiff --git a/test/sql/function/interval/test_date_part.test b/test/sql/function/interval/test_date_part.test\nindex a7f41f24dce8..14847483521f 100644\n--- a/test/sql/function/interval/test_date_part.test\n+++ b/test/sql/function/interval/test_date_part.test\n@@ -86,12 +86,21 @@ SELECT week(i) FROM intervals\n statement error\n SELECT era(i) FROM intervals;\n \n+statement error\n+SELECT julian(i) FROM intervals;\n+\n statement error\n SELECT extract(era from i) FROM intervals;\n \n+statement error\n+SELECT extract(julian from i) FROM intervals;\n+\n statement error\n SELECT date_part('era', i) FROM intervals;\n \n+statement error\n+SELECT date_part('julian', i) FROM intervals;\n+\n statement error\n SELECT date_part('offset', i) FROM intervals;\n \ndiff --git a/test/sql/function/time/test_date_part.test b/test/sql/function/time/test_date_part.test\nindex 69f66e25ff9d..121461fdf9ba 100644\n--- a/test/sql/function/time/test_date_part.test\n+++ b/test/sql/function/time/test_date_part.test\n@@ -132,6 +132,12 @@ select extract(era from time '10:00:00');\n statement error\n select date_part('era', time '10:00:00');\n \n+statement error\n+select extract(julian from time '10:00:00');\n+\n+statement error\n+select date_part('julian', time '10:00:00');\n+\n # Correctness: Compare date_part against function value\n foreach partcode hour minute second millisecond microsecond epoch\n \n@@ -209,7 +215,7 @@ SELECT d, epoch_ms(d) FROM times ORDER BY ALL;\n \n # Invalid parts\n \n-foreach datepart year month day decade century millennium quarter dow isodow doy week isoyear yearweek era\n+foreach datepart year month day decade century millennium quarter dow isodow doy week isoyear yearweek era julian\n \n statement error\n SELECT d, DATE_PART(['${datepart}'], d) AS parts\ndiff --git a/test/sql/function/timestamp/date_diff.test_slow b/test/sql/function/timestamp/date_diff.test_slow\nindex da08d701c0d9..597561502649 100644\n--- a/test/sql/function/timestamp/date_diff.test_slow\n+++ b/test/sql/function/timestamp/date_diff.test_slow\n@@ -12,19 +12,19 @@ statement ok\n CREATE TABLE date1 AS\n SELECT '2005-12-31'::DATE AS startdate, '2006-01-01'::DATE AS enddate;\n \n-foreach datepart 'year' 'quarter' 'month' 'day' 'dayofyear'\n+foreach datepart year quarter month day dayofyear julian\n \n query I\n-SELECT DATEDIFF(${datepart}, startdate, enddate) FROM date1\n+SELECT DATEDIFF('${datepart}', startdate, enddate) FROM date1\n ----\n 1\n \n endloop\n \n-foreach datepart 'decade' 'century' 'millennium' 'week' 'yearweek'\n+foreach datepart decade century millennium week yearweek\n \n query I\n-SELECT DATEDIFF(${datepart}, startdate, enddate) FROM date1\n+SELECT DATEDIFF('${datepart}', startdate, enddate) FROM date1\n ----\n 0\n \n@@ -62,10 +62,10 @@ SELECT DATEDIFF('isoyear', startdate, enddate) FROM date1\n 0\n \n # Negation\n-foreach datepart 'year' 'quarter' 'month' 'day' 'dayofyear' 'hour' 'minute' 'second' 'millisecond' 'microsecond' 'decade' 'century' 'millennium' 'week' 'yearweek' 'isoyear'\n+foreach datepart year quarter month day dayofyear hour minute second millisecond microsecond decade century millennium week yearweek isoyear julian\n \n query I\n-SELECT DATEDIFF(${datepart}, startdate, enddate) + DATEDIFF(${datepart}, enddate, startdate) FROM date1\n+SELECT DATEDIFF('${datepart}', startdate, enddate) + DATEDIFF('${datepart}', enddate, startdate) FROM date1\n ----\n 0\n \n@@ -116,29 +116,29 @@ statement ok\n CREATE TABLE datetime1 AS\n SELECT '2005-12-31 23:59:59.9999999'::TIMESTAMP AS startdate, '2006-01-01 00:00:00.0000000'::TIMESTAMP AS enddate;\n \n-foreach datepart 'year' 'quarter' 'month' 'day' 'dayofyear' 'hour' 'minute' 'second' 'millisecond' 'microsecond'\n+foreach datepart year quarter month day dayofyear hour minute second millisecond microsecond julian\n \n query I\n-SELECT DATEDIFF(${datepart}, startdate, enddate) FROM datetime1\n+SELECT DATEDIFF('${datepart}', startdate, enddate) FROM datetime1\n ----\n 1\n \n endloop\n \n-foreach datepart 'decade' 'century' 'millennium' 'week' 'yearweek' 'isoyear'\n+foreach datepart decade century millennium week yearweek isoyear\n \n query I\n-SELECT DATEDIFF(${datepart}, startdate, enddate) FROM datetime1\n+SELECT DATEDIFF('${datepart}', startdate, enddate) FROM datetime1\n ----\n 0\n \n endloop\n \n # Negation\n-foreach datepart 'year' 'quarter' 'month' 'day' 'dayofyear' 'hour' 'minute' 'second' 'millisecond' 'microsecond' 'decade' 'century' 'millennium' 'week' 'yearweek' 'isoyear'\n+foreach datepart year quarter month day dayofyear hour minute second millisecond microsecond decade century millennium week yearweek isoyear julian\n \n query I\n-SELECT DATEDIFF(${datepart}, startdate, enddate) + DATEDIFF(${datepart}, enddate, startdate) FROM datetime1\n+SELECT DATEDIFF('${datepart}', startdate, enddate) + DATEDIFF('${datepart}', enddate, startdate) FROM datetime1\n ----\n 0\n \n@@ -166,10 +166,10 @@ statement ok\n CREATE TABLE time1 AS\n SELECT '23:59:59.9999999'::TIME AS enddate, '00:00:00.0000000'::TIME AS startdate;\n \n-foreach datepart 'year' 'quarter' 'month' 'day' 'dayofyear' 'decade' 'century' 'millennium' 'week' 'yearweek' 'isoyear'\n+foreach datepart year quarter month day dayofyear decade century millennium week yearweek isoyear julian\n \n statement error\n-SELECT DATEDIFF(${datepart}, startdate, enddate) FROM time1\n+SELECT DATEDIFF('${datepart}', startdate, enddate) FROM time1\n \n endloop\n \n@@ -199,10 +199,10 @@ SELECT DATEDIFF('microsecond' , startdate, enddate) FROM time1\n 86399999999\n \n # Negation\n-foreach datepart 'hour' 'minute' 'second' 'millisecond' 'microsecond'\n+foreach datepart hour minute second millisecond microsecond\n \n query I\n-SELECT DATEDIFF(${datepart}, startdate, enddate) + DATEDIFF(${datepart}, enddate, startdate) FROM time1\n+SELECT DATEDIFF('${datepart}', startdate, enddate) + DATEDIFF('${datepart}', enddate, startdate) FROM time1\n ----\n 0\n \n@@ -227,22 +227,22 @@ endloop\n # NULLs\n #\n \n-foreach datepart 'year' 'quarter' 'month' 'day' 'dayofyear' 'hour' 'minute' 'second' 'millisecond' 'microsecond' 'decade' 'century' 'millennium' 'week' 'yearweek' 'isoyear'\n+foreach datepart year quarter month day dayofyear hour minute second millisecond microsecond decade century millennium week yearweek isoyear julian\n \n foreach tbl date1 datetime1 time1\n \n query I\n-SELECT DATEDIFF(${datepart}, NULL::TIMESTAMP, NULL::TIMESTAMP) FROM ${tbl}\n+SELECT DATEDIFF('${datepart}', NULL::TIMESTAMP, NULL::TIMESTAMP) FROM ${tbl}\n ----\n NULL\n \n query I\n-SELECT DATEDIFF(${datepart}, NULL, enddate) FROM ${tbl}\n+SELECT DATEDIFF('${datepart}', NULL, enddate) FROM ${tbl}\n ----\n NULL\n \n query I\n-SELECT DATEDIFF(${datepart}, startdate, NULL) FROM ${tbl}\n+SELECT DATEDIFF('${datepart}', startdate, NULL) FROM ${tbl}\n ----\n NULL\n \n@@ -260,7 +260,7 @@ NULL\n endloop\n \n # Table\n-foreach datepart year month day hour minute second millisecond microsecond isoyear\n+foreach datepart year month day hour minute second millisecond microsecond isoyear julian\n \n query I\n SELECT DATEDIFF('${datepart}', startdate, NULL)\n@@ -307,7 +307,7 @@ NULL\n #\n # Infinities\n #\n-foreach specifier year isoyear month day decade century millennium quarter week microseconds milliseconds second minute hour\n+foreach specifier year isoyear julian month day decade century millennium quarter week microseconds milliseconds second minute hour\n \n foreach ltype DATE TIMESTAMP\n \n@@ -349,10 +349,10 @@ CREATE TABLE parts (datepart VARCHAR);\n statement ok\n INSERT into parts VALUES(NULL);\n \n-foreach datepart 'year' 'quarter' 'month' 'day' 'dayofyear' 'hour' 'minute' 'second' 'millisecond' 'microsecond' 'decade' 'century' 'millennium' 'week' 'yearweek' 'isoyear'\n+foreach datepart year quarter month day dayofyear hour minute second millisecond microsecond decade century millennium week yearweek isoyear julian\n \n statement ok\n-INSERT into parts VALUES(${datepart});\n+INSERT into parts VALUES('${datepart}');\n \n endloop\n \n@@ -377,6 +377,7 @@ millennium\t0\n week\t0\n yearweek\t0\n isoyear\t0\n+julian\t1\n \n statement ok\n INSERT into parts VALUES('duck');\ndiff --git a/test/sql/function/timestamp/date_sub.test_slow b/test/sql/function/timestamp/date_sub.test_slow\nindex 7449e656d9f4..202b2d757be8 100644\n--- a/test/sql/function/timestamp/date_sub.test_slow\n+++ b/test/sql/function/timestamp/date_sub.test_slow\n@@ -55,7 +55,7 @@ select DATESUB('millennium', '1004-02-29'::DATE, '2004-02-29'::DATE);\n 1\n \n # Sub-month\n-foreach datepart day doy dow isodow\n+foreach datepart day doy dow isodow julian\n \n query I\n select DATESUB('${datepart}', '2004-01-31'::DATE, '2004-02-29'::DATE);\n@@ -235,7 +235,7 @@ select DATESUB('millennium', '1004-02-29 12:00:00'::TIMESTAMP, '2004-02-28 13:00\n 0\n \n # Sub-month\n-foreach datepart day doy dow isodow\n+foreach datepart day doy dow isodow julian\n \n query I\n select DATESUB('${datepart}', '2004-01-31 12:00:00'::TIMESTAMP, '2004-02-29 13:00:00'::TIMESTAMP);\ndiff --git a/test/sql/function/timestamp/test_date_part.test b/test/sql/function/timestamp/test_date_part.test\nindex 9b676a92e770..fc68f3445d83 100644\n--- a/test/sql/function/timestamp/test_date_part.test\n+++ b/test/sql/function/timestamp/test_date_part.test\n@@ -142,8 +142,49 @@ FROM generate_series('2021-12-26'::TIMESTAMP, '2022-01-12'::TIMESTAMP, INTERVAL\n 2022\t2022-01-11 00:00:00\n 2022\t2022-01-12 00:00:00\n \n+# Julian Days\n+query II\n+SELECT DATE_PART('julian', ts), ts\n+FROM timestamps\n+ORDER BY 2;\n+----\n+NULL\tNULL\n+NULL\t-infinity\n+2437877.5144458734\t1962-07-31 12:20:48.123456\n+2440223.0439867396\t1969-01-01 01:03:20.45432\n+2448623.042377315\t1992-01-01 01:01:01.4\n+2448623.042386574\t1992-01-01 01:01:02.2\n+2448623.042388889\t1992-01-01 01:01:02.4\n+2449214.3489930555\t1993-08-14 08:22:33\n+2449214.3489979166\t1993-08-14 08:22:33.42\n+2452020.612627315\t2001-04-20 14:42:11\n+2452020.6126287384\t2001-04-20 14:42:11.123\n+2453036.5000000005\t2004-01-31 12:00:00.00005\n+2453036.500000579\t2004-01-31 12:00:00.05\n+2453037.5000000005\t2004-02-01 12:00:00.00005\n+2453037.500000579\t2004-02-01 12:00:00.05\n+2453065.5456842994\t2004-02-29 13:05:47.123456\n+2454467.0000173612\t2008-01-01 00:00:01.5\n+2454467.000018449\t2008-01-01 00:00:01.594\n+2454467.000020764\t2008-01-01 00:00:01.794\n+2454467.0000218665\t2008-01-01 00:00:01.88926\n+2454467.0000219215\t2008-01-01 00:00:01.894\n+2454467.0000230237\t2008-01-01 00:00:01.98926\n+2454467.0000231396\t2008-01-01 00:00:01.99926\n+2454467.000128472\t2008-01-01 00:00:11.1\n+2458490.168774577\t2019-01-06 04:03:02.123456\n+2458490.168778935\t2019-01-06 04:03:02.5\n+2458850.0000218665\t2020-01-01 00:00:01.88926\n+2459215.893041033\t2020-12-31 21:25:58.745232\n+2459320.621735127\t2021-04-15 14:55:17.915\n+2459320.621735127\t2021-04-15 14:55:17.915\n+2459337.5082118055\t2021-05-02 12:11:49.5\n+2459550.579723651\t2021-12-01 13:54:48.123456\n+2459581.0004745373\t2022-01-01 00:00:41\n+NULL\tinfinity\n+\n # Correctness: Compare date_part to named function\n-foreach partcode era millennium century decade year quarter month day hour minute second millisecond microsecond week weekday isodow dayofyear yearweek isoyear epoch timezone timezone_hour timezone_minute\n+foreach partcode era millennium century decade year quarter month day hour minute second millisecond microsecond week weekday isodow dayofyear yearweek isoyear epoch timezone timezone_hour timezone_minute julian\n \n query III\n SELECT ts, DATE_PART('${partcode}', ts) AS p, ${partcode}(ts) AS f\n@@ -274,55 +315,60 @@ ORDER BY 1;\n \n # Day parts\n query II\n-SELECT ts::DATE AS d, DATE_PART(['weekday', 'isodow','doy'], ts) AS parts\n+SELECT ts::DATE AS d, DATE_PART(['weekday', 'isodow','doy', 'julian'], ts) AS parts\n FROM timestamps\n ORDER BY 1;\n ----\n NULL\tNULL\n--infinity\t{'weekday': NULL, 'isodow': NULL, 'doy': NULL}\n-1962-07-31\t{'weekday': 2, 'isodow': 2, 'doy': 212}\n-1969-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1}\n-1992-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1}\n-1992-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1}\n-1992-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1}\n-1993-08-14\t{'weekday': 6, 'isodow': 6, 'doy': 226}\n-1993-08-14\t{'weekday': 6, 'isodow': 6, 'doy': 226}\n-2001-04-20\t{'weekday': 5, 'isodow': 5, 'doy': 110}\n-2001-04-20\t{'weekday': 5, 'isodow': 5, 'doy': 110}\n-2004-01-31\t{'weekday': 6, 'isodow': 6, 'doy': 31}\n-2004-01-31\t{'weekday': 6, 'isodow': 6, 'doy': 31}\n-2004-02-01\t{'weekday': 0, 'isodow': 7, 'doy': 32}\n-2004-02-01\t{'weekday': 0, 'isodow': 7, 'doy': 32}\n-2004-02-29\t{'weekday': 0, 'isodow': 7, 'doy': 60}\n-2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1}\n-2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1}\n-2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1}\n-2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1}\n-2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1}\n-2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1}\n-2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1}\n-2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1}\n-2019-01-06\t{'weekday': 0, 'isodow': 7, 'doy': 6}\n-2019-01-06\t{'weekday': 0, 'isodow': 7, 'doy': 6}\n-2020-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1}\n-2020-12-31\t{'weekday': 4, 'isodow': 4, 'doy': 366}\n-2021-04-15\t{'weekday': 4, 'isodow': 4, 'doy': 105}\n-2021-04-15\t{'weekday': 4, 'isodow': 4, 'doy': 105}\n-2021-05-02\t{'weekday': 0, 'isodow': 7, 'doy': 122}\n-2021-12-01\t{'weekday': 3, 'isodow': 3, 'doy': 335}\n-2022-01-01\t{'weekday': 6, 'isodow': 6, 'doy': 1}\n-infinity\t{'weekday': NULL, 'isodow': NULL, 'doy': NULL}\n+-infinity\t{'weekday': NULL, 'isodow': NULL, 'doy': NULL, 'julian': NULL}\n+1962-07-31\t{'weekday': 2, 'isodow': 2, 'doy': 212, 'julian': 2437877.5144458734}\n+1969-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1, 'julian': 2440223.0439867396}\n+1992-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1, 'julian': 2448623.042377315}\n+1992-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1, 'julian': 2448623.042386574}\n+1992-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1, 'julian': 2448623.042388889}\n+1993-08-14\t{'weekday': 6, 'isodow': 6, 'doy': 226, 'julian': 2449214.3489930555}\n+1993-08-14\t{'weekday': 6, 'isodow': 6, 'doy': 226, 'julian': 2449214.3489979166}\n+2001-04-20\t{'weekday': 5, 'isodow': 5, 'doy': 110, 'julian': 2452020.612627315}\n+2001-04-20\t{'weekday': 5, 'isodow': 5, 'doy': 110, 'julian': 2452020.6126287384}\n+2004-01-31\t{'weekday': 6, 'isodow': 6, 'doy': 31, 'julian': 2453036.5000000005}\n+2004-01-31\t{'weekday': 6, 'isodow': 6, 'doy': 31, 'julian': 2453036.500000579}\n+2004-02-01\t{'weekday': 0, 'isodow': 7, 'doy': 32, 'julian': 2453037.5000000005}\n+2004-02-01\t{'weekday': 0, 'isodow': 7, 'doy': 32, 'julian': 2453037.500000579}\n+2004-02-29\t{'weekday': 0, 'isodow': 7, 'doy': 60, 'julian': 2453065.5456842994}\n+2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1, 'julian': 2454467.0000173612}\n+2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1, 'julian': 2454467.000018449}\n+2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1, 'julian': 2454467.000020764}\n+2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1, 'julian': 2454467.0000218665}\n+2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1, 'julian': 2454467.0000219215}\n+2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1, 'julian': 2454467.0000230237}\n+2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1, 'julian': 2454467.0000231396}\n+2008-01-01\t{'weekday': 2, 'isodow': 2, 'doy': 1, 'julian': 2454467.000128472}\n+2019-01-06\t{'weekday': 0, 'isodow': 7, 'doy': 6, 'julian': 2458490.168774577}\n+2019-01-06\t{'weekday': 0, 'isodow': 7, 'doy': 6, 'julian': 2458490.168778935}\n+2020-01-01\t{'weekday': 3, 'isodow': 3, 'doy': 1, 'julian': 2458850.0000218665}\n+2020-12-31\t{'weekday': 4, 'isodow': 4, 'doy': 366, 'julian': 2459215.893041033}\n+2021-04-15\t{'weekday': 4, 'isodow': 4, 'doy': 105, 'julian': 2459320.621735127}\n+2021-04-15\t{'weekday': 4, 'isodow': 4, 'doy': 105, 'julian': 2459320.621735127}\n+2021-05-02\t{'weekday': 0, 'isodow': 7, 'doy': 122, 'julian': 2459337.5082118055}\n+2021-12-01\t{'weekday': 3, 'isodow': 3, 'doy': 335, 'julian': 2459550.579723651}\n+2022-01-01\t{'weekday': 6, 'isodow': 6, 'doy': 1, 'julian': 2459581.0004745373}\n+infinity\t{'weekday': NULL, 'isodow': NULL, 'doy': NULL, 'julian': NULL}\n+\n+query I\n+SELECT DATE_PART(['weekday', 'isodow', 'doy', 'julian'], '2008-01-01 00:00:01.894'::TIMESTAMP) AS parts\n+----\n+{'weekday': 2, 'isodow': 2, 'doy': 1, 'julian': 2454467.0000219215}\n \n query II\n-SELECT ts::DATE AS d, DATE_PART(['weekday', 'isodow','doy'], ts) AS parts\n+SELECT ts::DATE AS d, DATE_PART(['weekday', 'isodow', 'doy', 'julian'], ts) AS parts\n FROM millennia\n ORDER BY 1;\n ----\n-1001-03-15 (BC)\t{'weekday': 6, 'isodow': 6, 'doy': 74}\n-0044-03-15 (BC)\t{'weekday': 5, 'isodow': 5, 'doy': 74}\n-0998-02-16\t{'weekday': 5, 'isodow': 5, 'doy': 47}\n-1998-02-16\t{'weekday': 1, 'isodow': 1, 'doy': 47}\n-2001-02-16\t{'weekday': 5, 'isodow': 5, 'doy': 47}\n+1001-03-15 (BC)\t{'weekday': 6, 'isodow': 6, 'doy': 74, 'julian': 1355891.8601851852}\n+0044-03-15 (BC)\t{'weekday': 5, 'isodow': 5, 'doy': 74, 'julian': 1705428.8601851852}\n+0998-02-16\t{'weekday': 5, 'isodow': 5, 'doy': 47, 'julian': 2085619.8601851852}\n+1998-02-16\t{'weekday': 1, 'isodow': 1, 'doy': 47, 'julian': 2450861.860185185}\n+2001-02-16\t{'weekday': 5, 'isodow': 5, 'doy': 47, 'julian': 2451957.860185185}\n \n # ISO parts\n query II\ndiff --git a/test/sql/function/timestamp/test_icu_datediff.test b/test/sql/function/timestamp/test_icu_datediff.test\nindex 1da070a49ee2..b67d742285e5 100644\n--- a/test/sql/function/timestamp/test_icu_datediff.test\n+++ b/test/sql/function/timestamp/test_icu_datediff.test\n@@ -18,7 +18,7 @@ statement ok\n CREATE TABLE datetime1 AS\n SELECT '2005-12-31 23:59:59.9999999-08'::TIMESTAMPTZ AS startdate, '2006-01-01 00:00:00.0000000-08'::TIMESTAMPTZ AS enddate;\n \n-foreach datepart year quarter month day dayofyear hour minute second millisecond microsecond\n+foreach datepart year quarter month day dayofyear hour minute second millisecond microsecond julian\n \n query I\n SELECT DATEDIFF('${datepart}', startdate, enddate) FROM datetime1\n@@ -45,7 +45,7 @@ SELECT DATEDIFF('isoyear', '2022-01-01 00:00:00-08'::TIMESTAMPTZ, '2022-01-03 00\n #\n # Infinities\n #\n-foreach specifier year isoyear month day decade century millennium quarter week microseconds milliseconds second minute hour\n+foreach specifier year isoyear month day decade century millennium quarter week microseconds milliseconds second minute hour julian\n \n foreach lspecial infinity -infinity 2004-01-31T12:00:00.000050-08\n \n@@ -68,7 +68,7 @@ endloop\n endloop\n \n # Negation\n-foreach datepart year quarter month day dayofyear hour minute second millisecond microsecond decade century millennium week yearweek isoyear\n+foreach datepart year quarter month day dayofyear hour minute second millisecond microsecond decade century millennium week yearweek isoyear julian\n \n query I\n SELECT DATEDIFF('${datepart}', startdate, enddate) + DATEDIFF('${datepart}', enddate, startdate) FROM datetime1\ndiff --git a/test/sql/function/timestamp/test_icu_datepart.test b/test/sql/function/timestamp/test_icu_datepart.test\nindex 43822f5b0354..5bff05fc45bd 100644\n--- a/test/sql/function/timestamp/test_icu_datepart.test\n+++ b/test/sql/function/timestamp/test_icu_datepart.test\n@@ -387,9 +387,39 @@ NULL\n \n # Beware the ides of March\n query I\n-SELECT DATE_PART('era', '0044-03-15 (BC) 12:00:00'::TIMESTAMPTZ);\n+SELECT DATE_PART('julian', '0044-03-15 (BC) 12:00:00'::TIMESTAMPTZ);\n ----\n-0\n+1705428.5\n+\n+query I\n+SELECT JULIAN(ts) FROM timestamps;\n+----\n+1705426.0699535608\n+2437877.2227792065\n+2459215.6666666665\n+2459247.6666666665\n+2459545.0939018917\n+2459534.1041666665\n+2459534.0625\n+2459573.5833333335\n+NULL\n+NULL\n+NULL\n+\n+query I\n+SELECT DATE_PART('julian', ts) FROM timestamps;\n+----\n+1705426.0699535608\n+2437877.2227792065\n+2459215.6666666665\n+2459247.6666666665\n+2459545.0939018917\n+2459534.1041666665\n+2459534.0625\n+2459573.5833333335\n+NULL\n+NULL\n+NULL\n \n query I\n SELECT DATE_PART('timezone', ts) FROM timestamps;\n@@ -509,7 +539,7 @@ NULL\tNULL\n NULL\tNULL\n \n # Correctness: Compare date_part to named function\n-foreach partcode era millennium century decade year quarter month day hour minute second millisecond microsecond week weekday isodow dayofyear yearweek isoyear epoch timezone timezone_hour timezone_minute\n+foreach partcode era millennium century decade year quarter month day hour minute second millisecond microsecond week weekday isodow dayofyear yearweek isoyear julian epoch timezone timezone_hour timezone_minute\n \n query III\n SELECT *\n@@ -527,7 +557,7 @@ endloop\n #\n \n # Correctness: Compare struct values with scalar values\n-foreach partcode era millennium century decade year quarter month day hour minute second millisecond microsecond week weekday isodow doy yearweek epoch timezone timezone_hour timezone_minute\n+foreach partcode era millennium century decade year quarter month day hour minute second millisecond microsecond week weekday isodow doy yearweek isoyear julian epoch timezone timezone_hour timezone_minute\n \n query III\n SELECT ts, DATE_PART('${partcode}', ts) AS pc, DATE_PART(['${partcode}'], ts) AS st\n@@ -539,21 +569,21 @@ endloop\n \n # Date parts\n query II\n-SELECT DATE_PART(['era', 'year', 'month', 'day'], ts), ts\n+SELECT DATE_PART(['era', 'year', 'month', 'day', 'julian'], ts), ts\n FROM timestamps\n ORDER BY 2\n ----\n NULL\tNULL\n-{'era': NULL, 'year': NULL, 'month': NULL, 'day': NULL}\t-infinity\n-{'era': 0, 'year': 44, 'month': 3, 'day': 13}\t0044-03-13 (BC) 01:40:43.987654-07:52\n-{'era': 1, 'year': 1962, 'month': 7, 'day': 31}\t1962-07-31 05:20:48.123456-07\n-{'era': 1, 'year': 2020, 'month': 12, 'day': 31}\t2020-12-31 16:00:00-08\n-{'era': 1, 'year': 2021, 'month': 2, 'day': 1}\t2021-02-01 16:00:00-08\n-{'era': 1, 'year': 2021, 'month': 11, 'day': 15}\t2021-11-15 01:30:00-08\n-{'era': 1, 'year': 2021, 'month': 11, 'day': 15}\t2021-11-15 02:30:00-08\n-{'era': 1, 'year': 2021, 'month': 11, 'day': 26}\t2021-11-26 02:15:13.123456-08\n-{'era': 1, 'year': 2021, 'month': 12, 'day': 24}\t2021-12-24 14:00:00-08\n-{'era': NULL, 'year': NULL, 'month': NULL, 'day': NULL}\tinfinity\n+{'era': NULL, 'year': NULL, 'month': NULL, 'day': NULL, 'julian': NULL}\t-infinity\n+{'era': 0, 'year': 44, 'month': 3, 'day': 13, 'julian': 1705426.0699535608}\t0044-03-13 (BC) 01:40:43.987654-07:52\n+{'era': 1, 'year': 1962, 'month': 7, 'day': 31, 'julian': 2437877.2227792065}\t1962-07-31 05:20:48.123456-07\n+{'era': 1, 'year': 2020, 'month': 12, 'day': 31, 'julian': 2459215.6666666665}\t2020-12-31 16:00:00-08\n+{'era': 1, 'year': 2021, 'month': 2, 'day': 1, 'julian': 2459247.6666666665}\t2021-02-01 16:00:00-08\n+{'era': 1, 'year': 2021, 'month': 11, 'day': 15, 'julian': 2459534.0625}\t2021-11-15 01:30:00-08\n+{'era': 1, 'year': 2021, 'month': 11, 'day': 15, 'julian': 2459534.1041666665}\t2021-11-15 02:30:00-08\n+{'era': 1, 'year': 2021, 'month': 11, 'day': 26, 'julian': 2459545.0939018917}\t2021-11-26 02:15:13.123456-08\n+{'era': 1, 'year': 2021, 'month': 12, 'day': 24, 'julian': 2459573.5833333335}\t2021-12-24 14:00:00-08\n+{'era': NULL, 'year': NULL, 'month': NULL, 'day': NULL, 'julian': NULL}\tinfinity\n \n # Time parts\n query II\n@@ -646,7 +676,7 @@ NULL\tNULL\n {'epoch': NULL, 'second': NULL, 'timezone': NULL, 'timezone_hour': NULL, 'timezone_minute': NULL}\tinfinity\n \n # Correctness: Compare struct values with scalar values\n-foreach partcode era millennium century decade year quarter month day hour minute second millisecond microsecond week weekday isodow doy yearweek isoyear epoch timezone timezone_hour timezone_minute\n+foreach partcode era millennium century decade year quarter month day hour minute second millisecond microsecond week weekday isodow doy yearweek isoyear julian epoch timezone timezone_hour timezone_minute\n \n query III\n SELECT ts, DATE_PART('${partcode}', ts) AS p, DATE_PART(['${partcode}'], ts) AS s\n@@ -784,4 +814,4 @@ ORDER BY ALL;\n 5872\t10\tOctober\n 5872\t11\tNovember\n 5872\t12\tDecember\n-5872\t13\tUndecember\n+5872\t13\tUndecimber\ndiff --git a/test/sql/function/timestamp/test_icu_datesub.test b/test/sql/function/timestamp/test_icu_datesub.test\nindex 906f247709d8..37e0e907305c 100644\n--- a/test/sql/function/timestamp/test_icu_datesub.test\n+++ b/test/sql/function/timestamp/test_icu_datesub.test\n@@ -98,15 +98,13 @@ select DATESUB('century', '1904-02-29 13:00:00-08'::TIMESTAMPTZ, '2004-02-28 12:\n ----\n 0\n \n-# 6 day difference between the proleptic Gregorian calendar (used to parse the strings)\n-# and the Julian calendar (used by ICU) at the millenium\n query I\n-select DATESUB('millennium', '1004-03-06 12:00:00-08'::TIMESTAMPTZ, '2004-02-29 11:00:00-08'::TIMESTAMPTZ);\n+select DATESUB('millennium', '1004-02-29 11:00:00-08'::TIMESTAMPTZ, '2004-02-29 11:00:00-08'::TIMESTAMPTZ);\n ----\n 0\n \n # Sub-month\n-foreach datepart day doy dow isodow\n+foreach datepart day doy dow isodow julian\n \n query I\n select DATESUB('${datepart}', '2004-01-31 12:00:00-08'::TIMESTAMPTZ, '2004-02-29 13:00:00-08'::TIMESTAMPTZ);\n@@ -214,7 +212,7 @@ select DATESUB('microsecond', '2004-01-31 12:00:00.000050-08'::TIMESTAMPTZ, '200\n #\n # Infinities\n #\n-foreach specifier year isoyear month day decade century millennium quarter week microseconds milliseconds second minute hour\n+foreach specifier year isoyear month day decade century millennium quarter week microseconds milliseconds second minute hour julian\n \n foreach lspecial infinity -infinity 2004-01-31T12:00:00.000050-08\n \ndiff --git a/test/sql/function/timestamp/test_icu_datetrunc.test b/test/sql/function/timestamp/test_icu_datetrunc.test\nindex 28af1c45c5c2..f8427c0305af 100644\n--- a/test/sql/function/timestamp/test_icu_datetrunc.test\n+++ b/test/sql/function/timestamp/test_icu_datetrunc.test\n@@ -180,6 +180,20 @@ SELECT date_trunc('epoch', TIMESTAMPTZ '2019-01-06 04:03:02.5-08') FROM timestam\n ----\n 2019-01-06 04:03:02-08\n \n+# Synonyms for day\n+\n+foreach daypart day dow isodow doy julian\n+\n+query II\n+SELECT d, date_trunc('${daypart}', d) \n+FROM (SELECT DISTINCT d FROM timestamps) tbl(d);\n+----\n+-infinity\t-infinity\n+1992-02-02 02:02:03.123456-08\t1992-02-02 00:00:00-08\n+infinity\tinfinity\n+\n+endloop\n+\n # ISO Years\n query II\n SELECT ts, DATE_TRUNC('isoyear', ts::TIMESTAMPTZ)\n",
  "problem_statement": "Postgres date part compatibility\nThe [Postgres date parts](https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT) are a bit different from ours, so we should fix the discrepancies:\r\n* `offset` should be called `timezone`, `timezone_hour` and `timezone_minute`, with (signed) units of seconds, hours and minutes;\r\n* `century`, `decade` and `millennium` should be checked for extreme values;\r\n* We should add support for `julian` (actually modified/midnight Julian day) and `isoyear`;\n",
  "hints_text": "Giving up on `julian` for now because it is a floating point value.\nThis issue is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.\nOnly missing Julian days.",
  "created_at": "2023-08-09T13:22:57Z"
}