diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp
index 3f309ea806cc..f5fe70b3ad65 100644
--- a/src/include/duckdb/planner/binder.hpp
+++ b/src/include/duckdb/planner/binder.hpp
@@ -20,6 +20,7 @@
 
 namespace duckdb {
 class BoundResultModifier;
+class BoundSelectNode;
 class ClientContext;
 class ExpressionBinder;
 class LimitModifier;
@@ -233,7 +234,6 @@ class Binder : public std::enable_shared_from_this<Binder> {
 
 	BoundStatement BindSummarize(ShowStatement &stmt);
 	unique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);
-	unique_ptr<Expression> BindFilter(unique_ptr<ParsedExpression> condition);
 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
 
 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
diff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp
index 5b75b6c09278..698c1aa97b99 100644
--- a/src/include/duckdb/planner/expression_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder.hpp
@@ -91,10 +91,12 @@ class ExpressionBinder {
 	static void ResolveParameterType(LogicalType &type);
 	static void ResolveParameterType(unique_ptr<Expression> &expr);
 
-protected:
+	//! Bind the given expresion. Unlike Bind(), this does *not* mute the given ParsedExpression.
+	//! Exposed to be used from sub-binders that aren't subclasses of ExpressionBinder.
 	virtual BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,
 	                                  bool root_expression = false);
 
+protected:
 	BindResult BindExpression(BetweenExpression &expr, idx_t depth);
 	BindResult BindExpression(CaseExpression &expr, idx_t depth);
 	BindResult BindExpression(CollateExpression &expr, idx_t depth);
diff --git a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp
new file mode 100644
index 000000000000..f1a7f8c9c47c
--- /dev/null
+++ b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp
@@ -0,0 +1,33 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// duckdb/planner/expression_binder/column_alias_binder.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include "duckdb/common/unordered_map.hpp"
+#include "duckdb/planner/expression_binder.hpp"
+
+namespace duckdb {
+
+class BoundSelectNode;
+class ColumnRefExpression;
+
+//! A helper binder for WhereBinder and HavingBinder which support alias as a columnref.
+class ColumnAliasBinder {
+public:
+	ColumnAliasBinder(BoundSelectNode &node, const unordered_map<string, idx_t> &alias_map);
+
+	BindResult BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,
+	                     bool root_expression);
+
+private:
+	BoundSelectNode &node;
+	const unordered_map<string, idx_t> &alias_map;
+	bool in_alias;
+};
+
+} // namespace duckdb
diff --git a/src/include/duckdb/planner/expression_binder/having_binder.hpp b/src/include/duckdb/planner/expression_binder/having_binder.hpp
index 55f93096425a..5dbe8e8a9f85 100644
--- a/src/include/duckdb/planner/expression_binder/having_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder/having_binder.hpp
@@ -9,6 +9,7 @@
 #pragma once
 
 #include "duckdb/planner/expression_binder/select_binder.hpp"
+#include "duckdb/planner/expression_binder/column_alias_binder.hpp"
 
 namespace duckdb {
 
@@ -18,12 +19,14 @@ class HavingBinder : public SelectBinder {
 	HavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,
 	             unordered_map<string, idx_t> &alias_map);
 
-	unordered_map<string, idx_t> &alias_map;
-	bool in_alias;
-
 protected:
 	BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,
 	                          bool root_expression = false) override;
+
+private:
+	BindResult BindColumnRef(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression);
+
+	ColumnAliasBinder column_alias_binder;
 };
 
 } // namespace duckdb
diff --git a/src/include/duckdb/planner/expression_binder/where_binder.hpp b/src/include/duckdb/planner/expression_binder/where_binder.hpp
index c6c72bee9ed4..69a490c97c60 100644
--- a/src/include/duckdb/planner/expression_binder/where_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder/where_binder.hpp
@@ -12,16 +12,23 @@
 
 namespace duckdb {
 
+class ColumnAliasBinder;
+
 //! The WHERE binder is responsible for binding an expression within the WHERE clause of a SQL statement
 class WhereBinder : public ExpressionBinder {
 public:
-	WhereBinder(Binder &binder, ClientContext &context);
+	WhereBinder(Binder &binder, ClientContext &context, ColumnAliasBinder *column_alias_binder = nullptr);
 
 protected:
 	BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,
 	                          bool root_expression = false) override;
 
 	string UnsupportedAggregateMessage() override;
+
+private:
+	BindResult BindColumnRef(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression);
+
+	ColumnAliasBinder *column_alias_binder;
 };
 
 } // namespace duckdb
diff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp
index dc76d34aaff1..91a0d510e3dd 100644
--- a/src/planner/binder/query_node/bind_select_node.cpp
+++ b/src/planner/binder/query_node/bind_select_node.cpp
@@ -9,6 +9,7 @@
 #include "duckdb/parser/query_node/select_node.hpp"
 #include "duckdb/parser/tableref/joinref.hpp"
 #include "duckdb/planner/binder.hpp"
+#include "duckdb/planner/expression_binder/column_alias_binder.hpp"
 #include "duckdb/planner/expression_binder/constant_binder.hpp"
 #include "duckdb/planner/expression_binder/group_binder.hpp"
 #include "duckdb/planner/expression_binder/having_binder.hpp"
@@ -19,10 +20,6 @@
 #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
 
 namespace duckdb {
-unique_ptr<Expression> Binder::BindFilter(unique_ptr<ParsedExpression> condition) {
-	WhereBinder where_binder(*this, context);
-	return where_binder.Bind(condition);
-}
 
 unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {
 	// we treat the Distinct list as a order by
@@ -220,7 +217,10 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
 	// first visit the WHERE clause
 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
 	if (statement.where_clause) {
-		result->where_clause = BindFilter(move(statement.where_clause));
+		ColumnAliasBinder alias_binder(*result, alias_map);
+		WhereBinder where_binder(*this, context, &alias_binder);
+		unique_ptr<ParsedExpression> condition = move(statement.where_clause);
+		result->where_clause = where_binder.Bind(condition);
 	}
 
 	// now bind all the result modifiers; including DISTINCT and ORDER BY targets
diff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp
index dce2975c6189..250f92231979 100644
--- a/src/planner/expression_binder.cpp
+++ b/src/planner/expression_binder.cpp
@@ -249,8 +249,6 @@ void ExpressionBinder::BindTableNames(Binder &binder, ParsedExpression &expr, un
 			if (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {
 				// macro parameters get priority
 				colref.table_name = binder.macro_binding->alias;
-			} else if (alias_map && alias_map->find(colref.column_name) != alias_map->end()) {
-				// alias: leave unqualified
 			} else {
 				colref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);
 			}
diff --git a/src/planner/expression_binder/CMakeLists.txt b/src/planner/expression_binder/CMakeLists.txt
index 3a0c343b760f..0e9679eb5cea 100644
--- a/src/planner/expression_binder/CMakeLists.txt
+++ b/src/planner/expression_binder/CMakeLists.txt
@@ -4,6 +4,7 @@ add_library_unity(
   aggregate_binder.cpp
   alter_binder.cpp
   check_binder.cpp
+  column_alias_binder.cpp
   constant_binder.cpp
   group_binder.cpp
   having_binder.cpp
diff --git a/src/planner/expression_binder/column_alias_binder.cpp b/src/planner/expression_binder/column_alias_binder.cpp
new file mode 100644
index 000000000000..c7da48757e08
--- /dev/null
+++ b/src/planner/expression_binder/column_alias_binder.cpp
@@ -0,0 +1,33 @@
+#include "duckdb/planner/expression_binder/column_alias_binder.hpp"
+
+#include "duckdb/parser/expression/columnref_expression.hpp"
+#include "duckdb/planner/query_node/bound_select_node.hpp"
+#include "duckdb/common/string_util.hpp"
+
+namespace duckdb {
+
+ColumnAliasBinder::ColumnAliasBinder(BoundSelectNode &node, const unordered_map<string, idx_t> &alias_map)
+    : node(node), alias_map(alias_map), in_alias(false) {
+}
+
+BindResult ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,
+                                        bool root_expression) {
+	if (!expr.table_name.empty()) {
+		return BindResult(StringUtil::Format("Alias %s cannot be qualified.", expr.ToString()));
+	}
+
+	auto alias_entry = alias_map.find(expr.column_name);
+	if (alias_entry == alias_map.end()) {
+		return BindResult(StringUtil::Format("Alias %s is not found.", expr.ToString()));
+	}
+
+	// found an alias: bind the alias expression
+	D_ASSERT(!in_alias);
+	auto expression = node.original_expressions[alias_entry->second]->Copy();
+	in_alias = true;
+	auto result = enclosing_binder.BindExpression(&expression, depth, root_expression);
+	in_alias = false;
+	return result;
+}
+
+} // namespace duckdb
\ No newline at end of file
diff --git a/src/planner/expression_binder/having_binder.cpp b/src/planner/expression_binder/having_binder.cpp
index 11bfec67316c..9a55bb4cd638 100644
--- a/src/planner/expression_binder/having_binder.cpp
+++ b/src/planner/expression_binder/having_binder.cpp
@@ -10,10 +10,21 @@ namespace duckdb {
 
 HavingBinder::HavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,
                            unordered_map<string, idx_t> &alias_map)
-    : SelectBinder(binder, context, node, info), alias_map(alias_map), in_alias(false) {
+    : SelectBinder(binder, context, node, info), column_alias_binder(node, alias_map) {
 	target_type = LogicalType(LogicalTypeId::BOOLEAN);
 }
 
+BindResult HavingBinder::BindColumnRef(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {
+	auto &expr = (ColumnRefExpression &)**expr_ptr;
+	auto alias_result = column_alias_binder.BindAlias(*this, expr, depth, root_expression);
+	if (!alias_result.HasError()) {
+		return alias_result;
+	}
+
+	return BindResult(StringUtil::Format(
+	    "column %s must appear in the GROUP BY clause or be used in an aggregate function", expr.ToString()));
+}
+
 BindResult HavingBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {
 	auto &expr = **expr_ptr;
 	// check if the expression binds to one of the groups
@@ -25,22 +36,7 @@ BindResult HavingBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr,
 	case ExpressionClass::WINDOW:
 		return BindResult("HAVING clause cannot contain window functions!");
 	case ExpressionClass::COLUMN_REF:
-		if (!in_alias) {
-			auto &colref = (ColumnRefExpression &)expr;
-			if (colref.table_name.empty()) {
-				auto alias_entry = alias_map.find(colref.column_name);
-				if (alias_entry != alias_map.end()) {
-					// found an alias: bind the alias expression
-					auto expression = node.original_expressions[alias_entry->second]->Copy();
-					in_alias = true;
-					auto result = BindExpression(&expression, depth, root_expression);
-					in_alias = false;
-					return result;
-				}
-			}
-		}
-		return BindResult(StringUtil::Format(
-		    "column %s must appear in the GROUP BY clause or be used in an aggregate function", expr.ToString()));
+		return BindColumnRef(expr_ptr, depth, root_expression);
 	default:
 		return duckdb::SelectBinder::BindExpression(expr_ptr, depth);
 	}
diff --git a/src/planner/expression_binder/where_binder.cpp b/src/planner/expression_binder/where_binder.cpp
index 588dda4afd8b..3aa5d2968f39 100644
--- a/src/planner/expression_binder/where_binder.cpp
+++ b/src/planner/expression_binder/where_binder.cpp
@@ -1,11 +1,29 @@
 #include "duckdb/planner/expression_binder/where_binder.hpp"
+#include "duckdb/planner/expression_binder/column_alias_binder.hpp"
 
 namespace duckdb {
 
-WhereBinder::WhereBinder(Binder &binder, ClientContext &context) : ExpressionBinder(binder, context) {
+WhereBinder::WhereBinder(Binder &binder, ClientContext &context, ColumnAliasBinder *column_alias_binder)
+    : ExpressionBinder(binder, context), column_alias_binder(column_alias_binder) {
 	target_type = LogicalType(LogicalTypeId::BOOLEAN);
 }
 
+BindResult WhereBinder::BindColumnRef(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {
+	auto &expr = (ColumnRefExpression &)**expr_ptr;
+	auto result = ExpressionBinder::BindExpression(expr_ptr, depth);
+	if (!result.HasError() || !column_alias_binder) {
+		return result;
+	}
+
+	BindResult alias_result = column_alias_binder->BindAlias(*this, expr, depth, root_expression);
+	// This code path cannot be exercised at thispoint. #1547 might change that.
+	if (!alias_result.HasError()) {
+		return alias_result;
+	}
+
+	return result;
+}
+
 BindResult WhereBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {
 	auto &expr = **expr_ptr;
 	switch (expr.GetExpressionClass()) {
@@ -13,6 +31,8 @@ BindResult WhereBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, i
 		return BindResult("WHERE clause cannot contain DEFAULT clause");
 	case ExpressionClass::WINDOW:
 		return BindResult("WHERE clause cannot contain window functions!");
+	case ExpressionClass::COLUMN_REF:
+		return BindColumnRef(expr_ptr, depth, root_expression);
 	default:
 		return ExpressionBinder::BindExpression(expr_ptr, depth);
 	}
