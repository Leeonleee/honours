You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
column aliases in WHERE
Hi!
What are your thoughts regarding support for the use of column aliases in WHERE?

```sql
CREATE TABLE integers(i INTEGER); 
INSERT INTO integers VALUES (1), (2), (3), (NULL);
SELECT i AS k FROM integers WHERE k=1 ORDER BY k;
Error: near line 1: Unknown: Referenced column "k" not found in FROM clause!
```

It looks like it's supported in GROUP BY and ORDER BY
```sql
SELECT i AS k FROM integers GROUP BY k ORDER BY k;
k
----------

1
2
3
```

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/parser/column_definition.hpp"
13: #include "duckdb/parser/tokens.hpp"
14: #include "duckdb/planner/bind_context.hpp"
15: #include "duckdb/planner/bound_tokens.hpp"
16: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
17: #include "duckdb/planner/logical_operator.hpp"
18: #include "duckdb/planner/bound_statement.hpp"
19: #include "duckdb/common/case_insensitive_map.hpp"
20: 
21: namespace duckdb {
22: class BoundResultModifier;
23: class ClientContext;
24: class ExpressionBinder;
25: class LimitModifier;
26: class OrderBinder;
27: class TableCatalogEntry;
28: class ViewCatalogEntry;
29: 
30: struct CreateInfo;
31: struct BoundCreateTableInfo;
32: struct BoundCreateFunctionInfo;
33: struct CommonTableExpressionInfo;
34: 
35: struct CorrelatedColumnInfo {
36: 	ColumnBinding binding;
37: 	LogicalType type;
38: 	string name;
39: 	idx_t depth;
40: 
41: 	explicit CorrelatedColumnInfo(BoundColumnRefExpression &expr)
42: 	    : binding(expr.binding), type(expr.return_type), name(expr.GetName()), depth(expr.depth) {
43: 	}
44: 
45: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
46: 		return binding == rhs.binding;
47: 	}
48: };
49: 
50: //! Bind the parsed query tree to the actual columns present in the catalog.
51: /*!
52:   The binder is responsible for binding tables and columns to actual physical
53:   tables and columns in the catalog. In the process, it also resolves types of
54:   all expressions.
55: */
56: class Binder : public std::enable_shared_from_this<Binder> {
57: 	friend class ExpressionBinder;
58: 	friend class SelectBinder;
59: 	friend class RecursiveSubqueryPlanner;
60: 
61: public:
62: 	static shared_ptr<Binder> CreateBinder(ClientContext &context, Binder *parent = nullptr, bool inherit_ctes = true);
63: 
64: 	//! The client context
65: 	ClientContext &context;
66: 	//! A mapping of names to common table expressions
67: 	case_insensitive_map_t<CommonTableExpressionInfo *> CTE_bindings;
68: 	//! The CTEs that have already been bound
69: 	unordered_set<CommonTableExpressionInfo *> bound_ctes;
70: 	//! The bind context
71: 	BindContext bind_context;
72: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
73: 	//! vector)
74: 	vector<CorrelatedColumnInfo> correlated_columns;
75: 	//! The set of parameter expressions bound by this binder
76: 	vector<BoundParameterExpression *> *parameters;
77: 	//! Whether or not the bound statement is read-only
78: 	bool read_only;
79: 	//! Whether or not the statement requires a valid transaction to run
80: 	bool requires_valid_transaction;
81: 	//! Whether or not the statement can be streamed to the client
82: 	bool allow_stream_result;
83: 	//! The alias for the currently processing subquery, if it exists
84: 	string alias;
85: 	//! Macro parameter bindings (if any)
86: 	MacroBinding *macro_binding = nullptr;
87: 
88: public:
89: 	BoundStatement Bind(SQLStatement &statement);
90: 	BoundStatement Bind(QueryNode &node);
91: 
92: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
93: 	void BindCreateViewInfo(CreateViewInfo &base);
94: 	SchemaCatalogEntry *BindSchema(CreateInfo &info);
95: 	SchemaCatalogEntry *BindCreateFunctionInfo(CreateInfo &info);
96: 
97: 	//! Check usage, and cast named parameters to their types
98: 	static void BindNamedParameters(unordered_map<string, LogicalType> &types, unordered_map<string, Value> &values,
99: 	                                QueryErrorContext &error_context, string &func_name);
100: 
101: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
102: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
103: 
104: 	//! Generates an unused index for a table
105: 	idx_t GenerateTableIndex();
106: 
107: 	//! Add a common table expression to the binder
108: 	void AddCTE(const string &name, CommonTableExpressionInfo *cte);
109: 	//! Find a common table expression by name; returns nullptr if none exists
110: 	CommonTableExpressionInfo *FindCTE(const string &name, bool skip = false);
111: 
112: 	bool CTEIsAlreadyBound(CommonTableExpressionInfo *cte);
113: 
114: 	void PushExpressionBinder(ExpressionBinder *binder);
115: 	void PopExpressionBinder();
116: 	void SetActiveBinder(ExpressionBinder *binder);
117: 	ExpressionBinder *GetActiveBinder();
118: 	bool HasActiveBinder();
119: 
120: 	vector<ExpressionBinder *> &GetActiveBinders();
121: 
122: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
123: 	//! Add a correlated column to this binder (if it does not exist)
124: 	void AddCorrelatedColumn(const CorrelatedColumnInfo &info);
125: 
126: 	string FormatError(ParsedExpression &expr_context, const string &message);
127: 	string FormatError(TableRef &ref_context, const string &message);
128: 
129: 	string FormatErrorRecursive(idx_t query_location, const string &message, vector<ExceptionFormatValue> &values);
130: 	template <class T, typename... Args>
131: 	string FormatErrorRecursive(idx_t query_location, const string &msg, vector<ExceptionFormatValue> &values, T param,
132: 	                            Args... params) {
133: 		values.push_back(ExceptionFormatValue::CreateFormatValue<T>(param));
134: 		return FormatErrorRecursive(query_location, msg, values, params...);
135: 	}
136: 
137: 	template <typename... Args>
138: 	string FormatError(idx_t query_location, const string &msg, Args... params) {
139: 		vector<ExceptionFormatValue> values;
140: 		return FormatErrorRecursive(query_location, msg, values, params...);
141: 	}
142: 
143: 	static void BindLogicalType(ClientContext &context, LogicalType &type, const string &schema = "");
144: 
145: private:
146: 	//! The parent binder (if any)
147: 	shared_ptr<Binder> parent;
148: 	//! The vector of active binders
149: 	vector<ExpressionBinder *> active_binders;
150: 	//! The count of bound_tables
151: 	idx_t bound_tables;
152: 	//! Whether or not the binder has any unplanned subqueries that still need to be planned
153: 	bool has_unplanned_subqueries = false;
154: 	//! Whether or not subqueries should be planned already
155: 	bool plan_subquery = true;
156: 	//! Whether CTEs should reference the parent binder (if it exists)
157: 	bool inherit_ctes = true;
158: 	//! Whether or not the binder can contain NULLs as the root of expressions
159: 	bool can_contain_nulls = false;
160: 	//! The root statement of the query that is currently being parsed
161: 	SQLStatement *root_statement = nullptr;
162: 
163: private:
164: 	//! Bind the default values of the columns of a table
165: 	void BindDefaultValues(vector<ColumnDefinition> &columns, vector<unique_ptr<Expression>> &bound_defaults);
166: 	//! Bind a delimiter value (LIMIT or OFFSET)
167: 	unique_ptr<Expression> BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,
168: 	                                     int64_t &delimiter_value);
169: 
170: 	//! Move correlated expressions from the child binder to this binder
171: 	void MoveCorrelatedExpressions(Binder &other);
172: 
173: 	BoundStatement Bind(SelectStatement &stmt);
174: 	BoundStatement Bind(InsertStatement &stmt);
175: 	BoundStatement Bind(CopyStatement &stmt);
176: 	BoundStatement Bind(DeleteStatement &stmt);
177: 	BoundStatement Bind(UpdateStatement &stmt);
178: 	BoundStatement Bind(CreateStatement &stmt);
179: 	BoundStatement Bind(DropStatement &stmt);
180: 	BoundStatement Bind(AlterStatement &stmt);
181: 	BoundStatement Bind(TransactionStatement &stmt);
182: 	BoundStatement Bind(PragmaStatement &stmt);
183: 	BoundStatement Bind(ExplainStatement &stmt);
184: 	BoundStatement Bind(VacuumStatement &stmt);
185: 	BoundStatement Bind(RelationStatement &stmt);
186: 	BoundStatement Bind(ShowStatement &stmt);
187: 	BoundStatement Bind(CallStatement &stmt);
188: 	BoundStatement Bind(ExportStatement &stmt);
189: 	BoundStatement Bind(SetStatement &stmt);
190: 	BoundStatement Bind(LoadStatement &stmt);
191: 
192: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
193: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
194: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
195: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
196: 
197: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
198: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
199: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
200: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
201: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
202: 
203: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
204: 	unique_ptr<BoundTableRef> Bind(CrossProductRef &ref);
205: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
206: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte = nullptr);
207: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
208: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
209: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
210: 
211: 	bool BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
212: 	                            vector<Value> &parameters, unordered_map<string, Value> &named_parameters,
213: 	                            unique_ptr<BoundSubqueryRef> &subquery, string &error);
214: 
215: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
216: 	unique_ptr<LogicalOperator> CreatePlan(BoundCrossProductRef &ref);
217: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
218: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
219: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
220: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
221: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
222: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
223: 
224: 	unique_ptr<LogicalOperator> BindTable(TableCatalogEntry &table, BaseTableRef &ref);
225: 	unique_ptr<LogicalOperator> BindView(ViewCatalogEntry &view, BaseTableRef &ref);
226: 	unique_ptr<LogicalOperator> BindTableOrView(BaseTableRef &ref);
227: 
228: 	BoundStatement BindCopyTo(CopyStatement &stmt);
229: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
230: 
231: 	void BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
232: 	void BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index);
233: 
234: 	BoundStatement BindSummarize(ShowStatement &stmt);
235: 	unique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);
236: 	unique_ptr<Expression> BindFilter(unique_ptr<ParsedExpression> condition);
237: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
238: 
239: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
240: 
241: 	void PlanSubqueries(unique_ptr<Expression> *expr, unique_ptr<LogicalOperator> *root);
242: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
243: 
244: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,
245: 	                                                       vector<LogicalType> &target_types,
246: 	                                                       unique_ptr<LogicalOperator> op);
247: 
248: 	string FindBinding(const string &using_column, const string &join_side);
249: 	bool TryFindBinding(const string &using_column, const string &join_side, string &result);
250: 
251: 	void AddUsingBindingSet(unique_ptr<UsingColumnSet> set);
252: 	string RetrieveUsingBinding(Binder &current_binder, UsingColumnSet *current_set, const string &column_name,
253: 	                            const string &join_side, UsingColumnSet *new_set);
254: 
255: public:
256: 	// This should really be a private constructor, but make_shared does not allow it...
257: 	// If you are thinking about calling this, you should probably call Binder::CreateBinder
258: 	Binder(bool I_know_what_I_am_doing, ClientContext &context, shared_ptr<Binder> parent, bool inherit_ctes);
259: };
260: 
261: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/include/duckdb/planner/expression_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/exception.hpp"
12: #include "duckdb/parser/expression/bound_expression.hpp"
13: #include "duckdb/parser/parsed_expression.hpp"
14: #include "duckdb/parser/tokens.hpp"
15: #include "duckdb/planner/expression.hpp"
16: #include "duckdb/common/unordered_map.hpp"
17: 
18: namespace duckdb {
19: 
20: class Binder;
21: class ClientContext;
22: class QueryNode;
23: 
24: class ScalarFunctionCatalogEntry;
25: class AggregateFunctionCatalogEntry;
26: class MacroCatalogEntry;
27: class CatalogEntry;
28: class SimpleFunction;
29: 
30: struct MacroBinding;
31: 
32: struct BoundColumnReferenceInfo {
33: 	string name;
34: 	idx_t query_location;
35: };
36: 
37: struct BindResult {
38: 	explicit BindResult(string error) : error(error) {
39: 	}
40: 	explicit BindResult(unique_ptr<Expression> expr) : expression(move(expr)) {
41: 	}
42: 
43: 	bool HasError() {
44: 		return !error.empty();
45: 	}
46: 
47: 	unique_ptr<Expression> expression;
48: 	string error;
49: };
50: 
51: class ExpressionBinder {
52: public:
53: 	ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder = false);
54: 	virtual ~ExpressionBinder();
55: 
56: 	//! The target type that should result from the binder. If the result is not of this type, a cast to this type will
57: 	//! be added. Defaults to INVALID.
58: 	LogicalType target_type;
59: 
60: public:
61: 	unique_ptr<Expression> Bind(unique_ptr<ParsedExpression> &expr, LogicalType *result_type = nullptr,
62: 	                            bool root_expression = true);
63: 
64: 	//! Returns whether or not any columns have been bound by the expression binder
65: 	bool HasBoundColumns() {
66: 		return !bound_columns.empty();
67: 	}
68: 	const vector<BoundColumnReferenceInfo> &GetBoundColumns() {
69: 		return bound_columns;
70: 	}
71: 
72: 	string Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression = false);
73: 
74: 	// Bind table names to ColumnRefExpressions
75: 	static void BindTableNames(Binder &binder, ParsedExpression &expr,
76: 	                           unordered_map<string, idx_t> *alias_map = nullptr);
77: 	static unique_ptr<Expression> PushCollation(ClientContext &context, unique_ptr<Expression> source,
78: 	                                            const string &collation, bool equality_only = false);
79: 	static void TestCollation(ClientContext &context, const string &collation);
80: 
81: 	bool BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr);
82: 
83: 	void BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, string &error);
84: 	static void ExtractCorrelatedExpressions(Binder &binder, Expression &expr);
85: 
86: 	static bool ContainsNullType(const LogicalType &type);
87: 	static LogicalType ExchangeNullType(const LogicalType &type);
88: 	static bool ContainsType(const LogicalType &type, LogicalTypeId target);
89: 	static LogicalType ExchangeType(const LogicalType &type, LogicalTypeId target, LogicalType new_type);
90: 
91: 	static void ResolveParameterType(LogicalType &type);
92: 	static void ResolveParameterType(unique_ptr<Expression> &expr);
93: 
94: protected:
95: 	virtual BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,
96: 	                                  bool root_expression = false);
97: 
98: 	BindResult BindExpression(BetweenExpression &expr, idx_t depth);
99: 	BindResult BindExpression(CaseExpression &expr, idx_t depth);
100: 	BindResult BindExpression(CollateExpression &expr, idx_t depth);
101: 	BindResult BindExpression(CastExpression &expr, idx_t depth);
102: 	BindResult BindExpression(ColumnRefExpression &expr, idx_t depth);
103: 	BindResult BindExpression(ComparisonExpression &expr, idx_t depth);
104: 	BindResult BindExpression(ConjunctionExpression &expr, idx_t depth);
105: 	BindResult BindExpression(ConstantExpression &expr, idx_t depth);
106: 	BindResult BindExpression(FunctionExpression &expr, idx_t depth, unique_ptr<ParsedExpression> *expr_ptr);
107: 	BindResult BindExpression(LambdaExpression &expr, idx_t depth);
108: 	BindResult BindExpression(OperatorExpression &expr, idx_t depth);
109: 	BindResult BindExpression(ParameterExpression &expr, idx_t depth);
110: 	BindResult BindExpression(PositionalReferenceExpression &ref, idx_t depth);
111: 	BindResult BindExpression(StarExpression &expr, idx_t depth);
112: 	BindResult BindExpression(SubqueryExpression &expr, idx_t depth);
113: 
114: protected:
115: 	virtual BindResult BindGroupingFunction(OperatorExpression &op, idx_t depth);
116: 	virtual BindResult BindFunction(FunctionExpression &expr, ScalarFunctionCatalogEntry *function, idx_t depth);
117: 	virtual BindResult BindAggregate(FunctionExpression &expr, AggregateFunctionCatalogEntry *function, idx_t depth);
118: 	virtual BindResult BindUnnest(FunctionExpression &expr, idx_t depth);
119: 	virtual BindResult BindMacro(FunctionExpression &expr, MacroCatalogEntry *macro, idx_t depth,
120: 	                             unique_ptr<ParsedExpression> *expr_ptr);
121: 
122: 	virtual void ReplaceMacroParametersRecursive(unique_ptr<ParsedExpression> &expr);
123: 	virtual void ReplaceMacroParametersRecursive(ParsedExpression &expr, QueryNode &node);
124: 	virtual void ReplaceMacroParametersRecursive(ParsedExpression &expr, TableRef &ref);
125: 
126: 	virtual string UnsupportedAggregateMessage();
127: 	virtual string UnsupportedUnnestMessage();
128: 
129: 	Binder &binder;
130: 	ClientContext &context;
131: 	ExpressionBinder *stored_binder;
132: 	MacroBinding *macro_binding;
133: 	vector<BoundColumnReferenceInfo> bound_columns;
134: };
135: 
136: } // namespace duckdb
[end of src/include/duckdb/planner/expression_binder.hpp]
[start of src/include/duckdb/planner/expression_binder/having_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression_binder/having_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/planner/expression_binder/select_binder.hpp"
12: 
13: namespace duckdb {
14: 
15: //! The HAVING binder is responsible for binding an expression within the HAVING clause of a SQL statement
16: class HavingBinder : public SelectBinder {
17: public:
18: 	HavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,
19: 	             unordered_map<string, idx_t> &alias_map);
20: 
21: 	unordered_map<string, idx_t> &alias_map;
22: 	bool in_alias;
23: 
24: protected:
25: 	BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,
26: 	                          bool root_expression = false) override;
27: };
28: 
29: } // namespace duckdb
[end of src/include/duckdb/planner/expression_binder/having_binder.hpp]
[start of src/include/duckdb/planner/expression_binder/where_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression_binder/where_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/planner/expression_binder.hpp"
12: 
13: namespace duckdb {
14: 
15: //! The WHERE binder is responsible for binding an expression within the WHERE clause of a SQL statement
16: class WhereBinder : public ExpressionBinder {
17: public:
18: 	WhereBinder(Binder &binder, ClientContext &context);
19: 
20: protected:
21: 	BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,
22: 	                          bool root_expression = false) override;
23: 
24: 	string UnsupportedAggregateMessage() override;
25: };
26: 
27: } // namespace duckdb
[end of src/include/duckdb/planner/expression_binder/where_binder.hpp]
[start of src/planner/binder/query_node/bind_select_node.cpp]
1: #include "duckdb/common/limits.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/main/config.hpp"
5: #include "duckdb/parser/expression/columnref_expression.hpp"
6: #include "duckdb/parser/expression/comparison_expression.hpp"
7: #include "duckdb/parser/expression/constant_expression.hpp"
8: #include "duckdb/parser/expression/subquery_expression.hpp"
9: #include "duckdb/parser/query_node/select_node.hpp"
10: #include "duckdb/parser/tableref/joinref.hpp"
11: #include "duckdb/planner/binder.hpp"
12: #include "duckdb/planner/expression_binder/constant_binder.hpp"
13: #include "duckdb/planner/expression_binder/group_binder.hpp"
14: #include "duckdb/planner/expression_binder/having_binder.hpp"
15: #include "duckdb/planner/expression_binder/order_binder.hpp"
16: #include "duckdb/planner/expression_binder/select_binder.hpp"
17: #include "duckdb/planner/expression_binder/where_binder.hpp"
18: #include "duckdb/planner/query_node/bound_select_node.hpp"
19: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
20: 
21: namespace duckdb {
22: unique_ptr<Expression> Binder::BindFilter(unique_ptr<ParsedExpression> condition) {
23: 	WhereBinder where_binder(*this, context);
24: 	return where_binder.Bind(condition);
25: }
26: 
27: unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {
28: 	// we treat the Distinct list as a order by
29: 	auto bound_expr = order_binder.Bind(move(expr));
30: 	if (!bound_expr) {
31: 		// DISTINCT ON non-integer constant
32: 		// remove the expression from the DISTINCT ON list
33: 		return nullptr;
34: 	}
35: 	D_ASSERT(bound_expr->type == ExpressionType::BOUND_COLUMN_REF);
36: 	return bound_expr;
37: }
38: 
39: unique_ptr<Expression> Binder::BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,
40:                                              int64_t &delimiter_value) {
41: 	auto new_binder = Binder::CreateBinder(context, this, true);
42: 	ExpressionBinder expr_binder(*new_binder, context);
43: 	expr_binder.target_type = LogicalType::UBIGINT;
44: 	auto expr = expr_binder.Bind(delimiter);
45: 	if (expr->IsFoldable()) {
46: 		//! this is a constant
47: 		Value value = ExpressionExecutor::EvaluateScalar(*expr).CastAs(LogicalType::BIGINT);
48: 		delimiter_value = value.GetValue<int64_t>();
49: 		return nullptr;
50: 	}
51: 	return expr;
52: }
53: 
54: unique_ptr<BoundResultModifier> Binder::BindLimit(LimitModifier &limit_mod) {
55: 	auto result = make_unique<BoundLimitModifier>();
56: 	if (limit_mod.limit) {
57: 		result->limit = BindDelimiter(context, move(limit_mod.limit), result->limit_val);
58: 	}
59: 	if (limit_mod.offset) {
60: 		result->offset = BindDelimiter(context, move(limit_mod.offset), result->offset_val);
61: 	}
62: 	return move(result);
63: }
64: 
65: void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result) {
66: 	for (auto &mod : statement.modifiers) {
67: 		unique_ptr<BoundResultModifier> bound_modifier;
68: 		switch (mod->type) {
69: 		case ResultModifierType::DISTINCT_MODIFIER: {
70: 			auto &distinct = (DistinctModifier &)*mod;
71: 			auto bound_distinct = make_unique<BoundDistinctModifier>();
72: 			for (auto &distinct_on_target : distinct.distinct_on_targets) {
73: 				auto expr = BindOrderExpression(order_binder, move(distinct_on_target));
74: 				if (!expr) {
75: 					continue;
76: 				}
77: 				bound_distinct->target_distincts.push_back(move(expr));
78: 			}
79: 			bound_modifier = move(bound_distinct);
80: 			break;
81: 		}
82: 		case ResultModifierType::ORDER_MODIFIER: {
83: 			auto &order = (OrderModifier &)*mod;
84: 			auto bound_order = make_unique<BoundOrderModifier>();
85: 			auto &config = DBConfig::GetConfig(context);
86: 			for (auto &order_node : order.orders) {
87: 				auto order_expression = BindOrderExpression(order_binder, move(order_node.expression));
88: 				if (!order_expression) {
89: 					continue;
90: 				}
91: 				auto type = order_node.type == OrderType::ORDER_DEFAULT ? config.default_order_type : order_node.type;
92: 				auto null_order = order_node.null_order == OrderByNullType::ORDER_DEFAULT ? config.default_null_order
93: 				                                                                          : order_node.null_order;
94: 				bound_order->orders.emplace_back(type, null_order, move(order_expression));
95: 			}
96: 			if (!bound_order->orders.empty()) {
97: 				bound_modifier = move(bound_order);
98: 			}
99: 			break;
100: 		}
101: 		case ResultModifierType::LIMIT_MODIFIER:
102: 			bound_modifier = BindLimit((LimitModifier &)*mod);
103: 			break;
104: 		default:
105: 			throw Exception("Unsupported result modifier");
106: 		}
107: 		if (bound_modifier) {
108: 			result.modifiers.push_back(move(bound_modifier));
109: 		}
110: 	}
111: }
112: 
113: void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index) {
114: 	for (auto &bound_mod : result.modifiers) {
115: 		switch (bound_mod->type) {
116: 		case ResultModifierType::DISTINCT_MODIFIER: {
117: 			auto &distinct = (BoundDistinctModifier &)*bound_mod;
118: 			if (distinct.target_distincts.empty()) {
119: 				// DISTINCT without a target: push references to the standard select list
120: 				for (idx_t i = 0; i < sql_types.size(); i++) {
121: 					distinct.target_distincts.push_back(
122: 					    make_unique<BoundColumnRefExpression>(sql_types[i], ColumnBinding(projection_index, i)));
123: 				}
124: 			} else {
125: 				// DISTINCT with target list: set types
126: 				for (auto &expr : distinct.target_distincts) {
127: 					D_ASSERT(expr->type == ExpressionType::BOUND_COLUMN_REF);
128: 					auto &bound_colref = (BoundColumnRefExpression &)*expr;
129: 					if (bound_colref.binding.column_index == INVALID_INDEX) {
130: 						throw BinderException("Ambiguous name in DISTINCT ON!");
131: 					}
132: 					D_ASSERT(bound_colref.binding.column_index < sql_types.size());
133: 					bound_colref.return_type = sql_types[bound_colref.binding.column_index];
134: 				}
135: 			}
136: 			for (auto &target_distinct : distinct.target_distincts) {
137: 				auto &bound_colref = (BoundColumnRefExpression &)*target_distinct;
138: 				auto sql_type = sql_types[bound_colref.binding.column_index];
139: 				if (sql_type.id() == LogicalTypeId::VARCHAR) {
140: 					target_distinct = ExpressionBinder::PushCollation(context, move(target_distinct),
141: 					                                                  StringType::GetCollation(sql_type), true);
142: 				}
143: 			}
144: 			break;
145: 		}
146: 		case ResultModifierType::ORDER_MODIFIER: {
147: 			auto &order = (BoundOrderModifier &)*bound_mod;
148: 			for (auto &order_node : order.orders) {
149: 				auto &expr = order_node.expression;
150: 				D_ASSERT(expr->type == ExpressionType::BOUND_COLUMN_REF);
151: 				auto &bound_colref = (BoundColumnRefExpression &)*expr;
152: 				if (bound_colref.binding.column_index == INVALID_INDEX) {
153: 					throw BinderException("Ambiguous name in ORDER BY!");
154: 				}
155: 				D_ASSERT(bound_colref.binding.column_index < sql_types.size());
156: 				auto sql_type = sql_types[bound_colref.binding.column_index];
157: 				bound_colref.return_type = sql_types[bound_colref.binding.column_index];
158: 				if (sql_type.id() == LogicalTypeId::VARCHAR) {
159: 					order_node.expression = ExpressionBinder::PushCollation(context, move(order_node.expression),
160: 					                                                        StringType::GetCollation(sql_type));
161: 				}
162: 			}
163: 			break;
164: 		}
165: 		default:
166: 			break;
167: 		}
168: 	}
169: }
170: 
171: unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
172: 	auto result = make_unique<BoundSelectNode>();
173: 	result->projection_index = GenerateTableIndex();
174: 	result->group_index = GenerateTableIndex();
175: 	result->aggregate_index = GenerateTableIndex();
176: 	result->groupings_index = GenerateTableIndex();
177: 	result->window_index = GenerateTableIndex();
178: 	result->unnest_index = GenerateTableIndex();
179: 	result->prune_index = GenerateTableIndex();
180: 
181: 	// first bind the FROM table statement
182: 	result->from_table = Bind(*statement.from_table);
183: 
184: 	// bind the sample clause
185: 	if (statement.sample) {
186: 		result->sample_options = move(statement.sample);
187: 	}
188: 
189: 	// visit the select list and expand any "*" statements
190: 	vector<unique_ptr<ParsedExpression>> new_select_list;
191: 	for (auto &select_element : statement.select_list) {
192: 		if (select_element->GetExpressionType() == ExpressionType::STAR) {
193: 			// * statement, expand to all columns from the FROM clause
194: 			bind_context.GenerateAllColumnExpressions((StarExpression &)*select_element, new_select_list);
195: 		} else {
196: 			// regular statement, add it to the list
197: 			new_select_list.push_back(move(select_element));
198: 		}
199: 	}
200: 	if (new_select_list.empty()) {
201: 		throw BinderException("SELECT list is empty after resolving * expressions!");
202: 	}
203: 	statement.select_list = move(new_select_list);
204: 
205: 	// create a mapping of (alias -> index) and a mapping of (Expression -> index) for the SELECT list
206: 	unordered_map<string, idx_t> alias_map;
207: 	expression_map_t<idx_t> projection_map;
208: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
209: 		auto &expr = statement.select_list[i];
210: 		result->names.push_back(expr->GetName());
211: 		ExpressionBinder::BindTableNames(*this, *expr);
212: 		if (!expr->alias.empty()) {
213: 			alias_map[expr->alias] = i;
214: 			result->names[i] = expr->alias;
215: 		}
216: 		projection_map[expr.get()] = i;
217: 		result->original_expressions.push_back(expr->Copy());
218: 	}
219: 	result->column_count = statement.select_list.size();
220: 
221: 	// first visit the WHERE clause
222: 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
223: 	if (statement.where_clause) {
224: 		result->where_clause = BindFilter(move(statement.where_clause));
225: 	}
226: 
227: 	// now bind all the result modifiers; including DISTINCT and ORDER BY targets
228: 	OrderBinder order_binder({this}, result->projection_index, statement, alias_map, projection_map);
229: 	BindModifiers(order_binder, statement, *result);
230: 
231: 	vector<unique_ptr<ParsedExpression>> unbound_groups;
232: 	BoundGroupInformation info;
233: 	auto &group_expressions = statement.groups.group_expressions;
234: 	if (!group_expressions.empty()) {
235: 		// the statement has a GROUP BY clause, bind it
236: 		unbound_groups.resize(group_expressions.size());
237: 		GroupBinder group_binder(*this, context, statement, result->group_index, alias_map, info.alias_map);
238: 		for (idx_t i = 0; i < group_expressions.size(); i++) {
239: 
240: 			// we keep a copy of the unbound expression;
241: 			// we keep the unbound copy around to check for group references in the SELECT and HAVING clause
242: 			// the reason we want the unbound copy is because we want to figure out whether an expression
243: 			// is a group reference BEFORE binding in the SELECT/HAVING binder
244: 			group_binder.unbound_expression = group_expressions[i]->Copy();
245: 			group_binder.bind_index = i;
246: 
247: 			// bind the groups
248: 			LogicalType group_type;
249: 			auto bound_expr = group_binder.Bind(group_expressions[i], &group_type);
250: 			D_ASSERT(bound_expr->return_type.id() != LogicalTypeId::INVALID);
251: 
252: 			// push a potential collation, if necessary
253: 			bound_expr =
254: 			    ExpressionBinder::PushCollation(context, move(bound_expr), StringType::GetCollation(group_type), true);
255: 			result->groups.group_expressions.push_back(move(bound_expr));
256: 
257: 			// in the unbound expression we DO bind the table names of any ColumnRefs
258: 			// we do this to make sure that "table.a" and "a" are treated the same
259: 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
260: 			// hence we convert "a" -> "test.a" in the unbound expression
261: 			unbound_groups[i] = move(group_binder.unbound_expression);
262: 			ExpressionBinder::BindTableNames(*this, *unbound_groups[i]);
263: 			info.map[unbound_groups[i].get()] = i;
264: 		}
265: 	}
266: 	result->groups.grouping_sets = move(statement.groups.grouping_sets);
267: 
268: 	// bind the HAVING clause, if any
269: 	if (statement.having) {
270: 		HavingBinder having_binder(*this, context, *result, info, alias_map);
271: 		ExpressionBinder::BindTableNames(*this, *statement.having, &alias_map);
272: 		result->having = having_binder.Bind(statement.having);
273: 	}
274: 
275: 	// after that, we bind to the SELECT list
276: 	SelectBinder select_binder(*this, context, *result, info);
277: 	vector<LogicalType> internal_sql_types;
278: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
279: 		LogicalType result_type;
280: 		auto expr = select_binder.Bind(statement.select_list[i], &result_type);
281: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES && select_binder.HasBoundColumns()) {
282: 			if (select_binder.BoundAggregates()) {
283: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
284: 			}
285: 			// we are forcing aggregates, and the node has columns bound
286: 			// this entry becomes a group
287: 			auto group_ref = make_unique<BoundColumnRefExpression>(
288: 			    expr->return_type, ColumnBinding(result->group_index, result->groups.group_expressions.size()));
289: 			result->groups.group_expressions.push_back(move(expr));
290: 			expr = move(group_ref);
291: 		}
292: 		result->select_list.push_back(move(expr));
293: 		if (i < result->column_count) {
294: 			result->types.push_back(result_type);
295: 		}
296: 		internal_sql_types.push_back(result_type);
297: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
298: 			select_binder.ResetBindings();
299: 		}
300: 	}
301: 	result->need_prune = result->select_list.size() > result->column_count;
302: 
303: 	// in the normal select binder, we bind columns as if there is no aggregation
304: 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
305: 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
306: 	// we choose the former one [CONTROVERSIAL: this is the PostgreSQL behavior]
307: 	if (!result->groups.group_expressions.empty() || !result->aggregates.empty() || statement.having ||
308: 	    !result->groups.grouping_sets.empty()) {
309: 		if (statement.aggregate_handling == AggregateHandling::NO_AGGREGATES_ALLOWED) {
310: 			throw BinderException("Aggregates cannot be present in a Project relation!");
311: 		} else if (statement.aggregate_handling == AggregateHandling::STANDARD_HANDLING) {
312: 			if (select_binder.HasBoundColumns()) {
313: 				auto &bound_columns = select_binder.GetBoundColumns();
314: 				throw BinderException(
315: 				    FormatError(bound_columns[0].query_location,
316: 				                "column \"%s\" must appear in the GROUP BY clause or be used in an aggregate function",
317: 				                bound_columns[0].name));
318: 			}
319: 		}
320: 	}
321: 
322: 	// now that the SELECT list is bound, we set the types of DISTINCT/ORDER BY expressions
323: 	BindModifierTypes(*result, internal_sql_types, result->projection_index);
324: 	return move(result);
325: }
326: 
327: } // namespace duckdb
[end of src/planner/binder/query_node/bind_select_node.cpp]
[start of src/planner/expression_binder.cpp]
1: #include "duckdb/planner/expression_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/expression/positional_reference_expression.hpp"
5: #include "duckdb/parser/expression/subquery_expression.hpp"
6: #include "duckdb/parser/parsed_expression_iterator.hpp"
7: #include "duckdb/planner/binder.hpp"
8: #include "duckdb/planner/expression/bound_cast_expression.hpp"
9: #include "duckdb/planner/expression/bound_default_expression.hpp"
10: #include "duckdb/planner/expression/bound_parameter_expression.hpp"
11: #include "duckdb/planner/expression/bound_subquery_expression.hpp"
12: #include "duckdb/planner/expression_iterator.hpp"
13: 
14: namespace duckdb {
15: 
16: ExpressionBinder::ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder)
17:     : binder(binder), context(context), stored_binder(nullptr) {
18: 	if (replace_binder) {
19: 		stored_binder = binder.GetActiveBinder();
20: 		binder.SetActiveBinder(this);
21: 	} else {
22: 		binder.PushExpressionBinder(this);
23: 	}
24: }
25: 
26: ExpressionBinder::~ExpressionBinder() {
27: 	if (binder.HasActiveBinder()) {
28: 		if (stored_binder) {
29: 			binder.SetActiveBinder(stored_binder);
30: 		} else {
31: 			binder.PopExpressionBinder();
32: 		}
33: 	}
34: }
35: 
36: BindResult ExpressionBinder::BindExpression(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression) {
37: 	auto &expr_ref = **expr;
38: 	switch (expr_ref.expression_class) {
39: 	case ExpressionClass::BETWEEN:
40: 		return BindExpression((BetweenExpression &)expr_ref, depth);
41: 	case ExpressionClass::CASE:
42: 		return BindExpression((CaseExpression &)expr_ref, depth);
43: 	case ExpressionClass::CAST:
44: 		return BindExpression((CastExpression &)expr_ref, depth);
45: 	case ExpressionClass::COLLATE:
46: 		return BindExpression((CollateExpression &)expr_ref, depth);
47: 	case ExpressionClass::COLUMN_REF:
48: 		return BindExpression((ColumnRefExpression &)expr_ref, depth);
49: 	case ExpressionClass::COMPARISON:
50: 		return BindExpression((ComparisonExpression &)expr_ref, depth);
51: 	case ExpressionClass::CONJUNCTION:
52: 		return BindExpression((ConjunctionExpression &)expr_ref, depth);
53: 	case ExpressionClass::CONSTANT:
54: 		return BindExpression((ConstantExpression &)expr_ref, depth);
55: 	case ExpressionClass::FUNCTION:
56: 		// binding function expression has extra parameter needed for macro's
57: 		return BindExpression((FunctionExpression &)expr_ref, depth, expr);
58: 	case ExpressionClass::LAMBDA:
59: 		return BindExpression((LambdaExpression &)expr_ref, depth);
60: 	case ExpressionClass::OPERATOR:
61: 		return BindExpression((OperatorExpression &)expr_ref, depth);
62: 	case ExpressionClass::SUBQUERY:
63: 		return BindExpression((SubqueryExpression &)expr_ref, depth);
64: 	case ExpressionClass::PARAMETER:
65: 		return BindExpression((ParameterExpression &)expr_ref, depth);
66: 	case ExpressionClass::POSITIONAL_REFERENCE:
67: 		return BindExpression((PositionalReferenceExpression &)expr_ref, depth);
68: 	default:
69: 		throw NotImplementedException("Unimplemented expression class");
70: 	}
71: }
72: 
73: bool ExpressionBinder::BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr) {
74: 	// try to bind in one of the outer queries, if the binding error occurred in a subquery
75: 	auto &active_binders = binder.GetActiveBinders();
76: 	// make a copy of the set of binders, so we can restore it later
77: 	auto binders = active_binders;
78: 	active_binders.pop_back();
79: 	idx_t depth = 1;
80: 	bool success = false;
81: 	while (!active_binders.empty()) {
82: 		auto &next_binder = active_binders.back();
83: 		ExpressionBinder::BindTableNames(next_binder->binder, *expr);
84: 		auto bind_result = next_binder->Bind(&expr, depth);
85: 		if (bind_result.empty()) {
86: 			success = true;
87: 			break;
88: 		}
89: 		depth++;
90: 		active_binders.pop_back();
91: 	}
92: 	active_binders = binders;
93: 	return success;
94: }
95: 
96: void ExpressionBinder::BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, string &error) {
97: 	if (expr) {
98: 		string bind_error = Bind(&expr, depth);
99: 		if (error.empty()) {
100: 			error = bind_error;
101: 		}
102: 	}
103: }
104: 
105: void ExpressionBinder::ExtractCorrelatedExpressions(Binder &binder, Expression &expr) {
106: 	if (expr.type == ExpressionType::BOUND_COLUMN_REF) {
107: 		auto &bound_colref = (BoundColumnRefExpression &)expr;
108: 		if (bound_colref.depth > 0) {
109: 			binder.AddCorrelatedColumn(CorrelatedColumnInfo(bound_colref));
110: 		}
111: 	}
112: 	ExpressionIterator::EnumerateChildren(expr,
113: 	                                      [&](Expression &child) { ExtractCorrelatedExpressions(binder, child); });
114: }
115: 
116: bool ExpressionBinder::ContainsType(const LogicalType &type, LogicalTypeId target) {
117: 	if (type.id() == target) {
118: 		return true;
119: 	}
120: 	switch (type.id()) {
121: 	case LogicalTypeId::STRUCT:
122: 	case LogicalTypeId::MAP: {
123: 		auto child_count = StructType::GetChildCount(type);
124: 		for (idx_t i = 0; i < child_count; i++) {
125: 			if (ContainsType(StructType::GetChildType(type, i), target)) {
126: 				return true;
127: 			}
128: 		}
129: 		return false;
130: 	}
131: 	case LogicalTypeId::LIST:
132: 		return ContainsType(ListType::GetChildType(type), target);
133: 	default:
134: 		return false;
135: 	}
136: }
137: 
138: LogicalType ExpressionBinder::ExchangeType(const LogicalType &type, LogicalTypeId target, LogicalType new_type) {
139: 	if (type.id() == target) {
140: 		return new_type;
141: 	}
142: 	switch (type.id()) {
143: 	case LogicalTypeId::STRUCT:
144: 	case LogicalTypeId::MAP: {
145: 		// we make a copy of the child types of the struct here
146: 		auto child_types = StructType::GetChildTypes(type);
147: 		for (auto &child_type : child_types) {
148: 			child_type.second = ExchangeType(child_type.second, target, new_type);
149: 		}
150: 		return type.id() == LogicalTypeId::MAP ? LogicalType::MAP(move(child_types))
151: 		                                       : LogicalType::STRUCT(move(child_types));
152: 	}
153: 	case LogicalTypeId::LIST:
154: 		return LogicalType::LIST(ExchangeType(ListType::GetChildType(type), target, new_type));
155: 	default:
156: 		return type;
157: 	}
158: }
159: 
160: bool ExpressionBinder::ContainsNullType(const LogicalType &type) {
161: 	return ContainsType(type, LogicalTypeId::SQLNULL);
162: }
163: 
164: LogicalType ExpressionBinder::ExchangeNullType(const LogicalType &type) {
165: 	return ExchangeType(type, LogicalTypeId::SQLNULL, LogicalType::INTEGER);
166: }
167: 
168: void ExpressionBinder::ResolveParameterType(LogicalType &type) {
169: 	if (type.id() == LogicalTypeId::UNKNOWN) {
170: 		type = LogicalType::VARCHAR;
171: 	}
172: }
173: 
174: void ExpressionBinder::ResolveParameterType(unique_ptr<Expression> &expr) {
175: 	if (ContainsType(expr->return_type, LogicalTypeId::UNKNOWN)) {
176: 		auto result_type = ExchangeType(expr->return_type, LogicalTypeId::UNKNOWN, LogicalType::VARCHAR);
177: 		expr = BoundCastExpression::AddCastToType(move(expr), result_type);
178: 	}
179: }
180: 
181: unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr, LogicalType *result_type,
182:                                               bool root_expression) {
183: 	// bind the main expression
184: 	auto error_msg = Bind(&expr, 0, root_expression);
185: 	if (!error_msg.empty()) {
186: 		// failed to bind: try to bind correlated columns in the expression (if any)
187: 		bool success = BindCorrelatedColumns(expr);
188: 		if (!success) {
189: 			throw BinderException(error_msg);
190: 		}
191: 		auto bound_expr = (BoundExpression *)expr.get();
192: 		ExtractCorrelatedExpressions(binder, *bound_expr->expr);
193: 	}
194: 	D_ASSERT(expr->expression_class == ExpressionClass::BOUND_EXPRESSION);
195: 	auto bound_expr = (BoundExpression *)expr.get();
196: 	unique_ptr<Expression> result = move(bound_expr->expr);
197: 	if (target_type.id() != LogicalTypeId::INVALID) {
198: 		// the binder has a specific target type: add a cast to that type
199: 		result = BoundCastExpression::AddCastToType(move(result), target_type);
200: 	} else {
201: 		if (!binder.can_contain_nulls) {
202: 			// SQL NULL type is only used internally in the binder
203: 			// cast to INTEGER if we encounter it outside of the binder
204: 			if (ContainsNullType(result->return_type)) {
205: 				auto result_type = ExchangeNullType(result->return_type);
206: 				result = BoundCastExpression::AddCastToType(move(result), result_type);
207: 			}
208: 		}
209: 		// check if we failed to convert any parameters
210: 		// if we did, we push a cast
211: 		ExpressionBinder::ResolveParameterType(result);
212: 	}
213: 	if (result_type) {
214: 		*result_type = result->return_type;
215: 	}
216: 	return result;
217: }
218: 
219: string ExpressionBinder::Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression) {
220: 	// bind the node, but only if it has not been bound yet
221: 	auto &expression = **expr;
222: 	auto alias = expression.alias;
223: 	if (expression.GetExpressionClass() == ExpressionClass::BOUND_EXPRESSION) {
224: 		// already bound, don't bind it again
225: 		return string();
226: 	}
227: 	// bind the expression
228: 	BindResult result = BindExpression(expr, depth, root_expression);
229: 	if (result.HasError()) {
230: 		return result.error;
231: 	} else {
232: 		// successfully bound: replace the node with a BoundExpression
233: 		*expr = make_unique<BoundExpression>(move(result.expression));
234: 		auto be = (BoundExpression *)expr->get();
235: 		D_ASSERT(be);
236: 		be->alias = alias;
237: 		if (!alias.empty()) {
238: 			be->expr->alias = alias;
239: 		}
240: 		return string();
241: 	}
242: }
243: 
244: void ExpressionBinder::BindTableNames(Binder &binder, ParsedExpression &expr, unordered_map<string, idx_t> *alias_map) {
245: 	if (expr.type == ExpressionType::COLUMN_REF) {
246: 		auto &colref = (ColumnRefExpression &)expr;
247: 		if (colref.table_name.empty()) {
248: 			// no table name: find a binding that contains this
249: 			if (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {
250: 				// macro parameters get priority
251: 				colref.table_name = binder.macro_binding->alias;
252: 			} else if (alias_map && alias_map->find(colref.column_name) != alias_map->end()) {
253: 				// alias: leave unqualified
254: 			} else {
255: 				colref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);
256: 			}
257: 		}
258: 		binder.bind_context.BindColumn(colref, 0);
259: 	} else if (expr.type == ExpressionType::POSITIONAL_REFERENCE) {
260: 		auto &ref = (PositionalReferenceExpression &)expr;
261: 		if (ref.alias.empty()) {
262: 			string table_name, column_name;
263: 			auto error = binder.bind_context.BindColumn(ref, table_name, column_name);
264: 			if (error.empty()) {
265: 				ref.alias = column_name;
266: 			}
267: 		}
268: 	}
269: 	ParsedExpressionIterator::EnumerateChildren(
270: 	    expr, [&](const ParsedExpression &child) { BindTableNames(binder, (ParsedExpression &)child, alias_map); });
271: }
272: 
273: } // namespace duckdb
[end of src/planner/expression_binder.cpp]
[start of src/planner/expression_binder/CMakeLists.txt]
1: add_library_unity(
2:   duckdb_expression_binders
3:   OBJECT
4:   aggregate_binder.cpp
5:   alter_binder.cpp
6:   check_binder.cpp
7:   constant_binder.cpp
8:   group_binder.cpp
9:   having_binder.cpp
10:   index_binder.cpp
11:   insert_binder.cpp
12:   order_binder.cpp
13:   relation_binder.cpp
14:   select_binder.cpp
15:   update_binder.cpp
16:   where_binder.cpp)
17: set(ALL_OBJECT_FILES
18:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_expression_binders>
19:     PARENT_SCOPE)
[end of src/planner/expression_binder/CMakeLists.txt]
[start of src/planner/expression_binder/having_binder.cpp]
1: #include "duckdb/planner/expression_binder/having_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/planner/binder.hpp"
5: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
6: #include "duckdb/common/string_util.hpp"
7: #include "duckdb/planner/query_node/bound_select_node.hpp"
8: 
9: namespace duckdb {
10: 
11: HavingBinder::HavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,
12:                            unordered_map<string, idx_t> &alias_map)
13:     : SelectBinder(binder, context, node, info), alias_map(alias_map), in_alias(false) {
14: 	target_type = LogicalType(LogicalTypeId::BOOLEAN);
15: }
16: 
17: BindResult HavingBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {
18: 	auto &expr = **expr_ptr;
19: 	// check if the expression binds to one of the groups
20: 	auto group_index = TryBindGroup(expr, depth);
21: 	if (group_index != INVALID_INDEX) {
22: 		return BindGroup(expr, depth, group_index);
23: 	}
24: 	switch (expr.expression_class) {
25: 	case ExpressionClass::WINDOW:
26: 		return BindResult("HAVING clause cannot contain window functions!");
27: 	case ExpressionClass::COLUMN_REF:
28: 		if (!in_alias) {
29: 			auto &colref = (ColumnRefExpression &)expr;
30: 			if (colref.table_name.empty()) {
31: 				auto alias_entry = alias_map.find(colref.column_name);
32: 				if (alias_entry != alias_map.end()) {
33: 					// found an alias: bind the alias expression
34: 					auto expression = node.original_expressions[alias_entry->second]->Copy();
35: 					in_alias = true;
36: 					auto result = BindExpression(&expression, depth, root_expression);
37: 					in_alias = false;
38: 					return result;
39: 				}
40: 			}
41: 		}
42: 		return BindResult(StringUtil::Format(
43: 		    "column %s must appear in the GROUP BY clause or be used in an aggregate function", expr.ToString()));
44: 	default:
45: 		return duckdb::SelectBinder::BindExpression(expr_ptr, depth);
46: 	}
47: }
48: 
49: } // namespace duckdb
[end of src/planner/expression_binder/having_binder.cpp]
[start of src/planner/expression_binder/where_binder.cpp]
1: #include "duckdb/planner/expression_binder/where_binder.hpp"
2: 
3: namespace duckdb {
4: 
5: WhereBinder::WhereBinder(Binder &binder, ClientContext &context) : ExpressionBinder(binder, context) {
6: 	target_type = LogicalType(LogicalTypeId::BOOLEAN);
7: }
8: 
9: BindResult WhereBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {
10: 	auto &expr = **expr_ptr;
11: 	switch (expr.GetExpressionClass()) {
12: 	case ExpressionClass::DEFAULT:
13: 		return BindResult("WHERE clause cannot contain DEFAULT clause");
14: 	case ExpressionClass::WINDOW:
15: 		return BindResult("WHERE clause cannot contain window functions!");
16: 	default:
17: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
18: 	}
19: }
20: 
21: string WhereBinder::UnsupportedAggregateMessage() {
22: 	return "WHERE clause cannot contain aggregates!";
23: }
24: 
25: } // namespace duckdb
[end of src/planner/expression_binder/where_binder.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: