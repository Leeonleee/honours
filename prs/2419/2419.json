{
  "repo": "duckdb/duckdb",
  "pull_number": 2419,
  "instance_id": "duckdb__duckdb-2419",
  "issue_numbers": [
    "699"
  ],
  "base_commit": "8e2e97528127d9720690fc3097af5f3768ff9d74",
  "patch": "diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 3f309ea806cc..f5fe70b3ad65 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -20,6 +20,7 @@\n \n namespace duckdb {\n class BoundResultModifier;\n+class BoundSelectNode;\n class ClientContext;\n class ExpressionBinder;\n class LimitModifier;\n@@ -233,7 +234,6 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \n \tBoundStatement BindSummarize(ShowStatement &stmt);\n \tunique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);\n-\tunique_ptr<Expression> BindFilter(unique_ptr<ParsedExpression> condition);\n \tunique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);\n \n \tunique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 5b75b6c09278..698c1aa97b99 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -91,10 +91,12 @@ class ExpressionBinder {\n \tstatic void ResolveParameterType(LogicalType &type);\n \tstatic void ResolveParameterType(unique_ptr<Expression> &expr);\n \n-protected:\n+\t//! Bind the given expresion. Unlike Bind(), this does *not* mute the given ParsedExpression.\n+\t//! Exposed to be used from sub-binders that aren't subclasses of ExpressionBinder.\n \tvirtual BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,\n \t                                  bool root_expression = false);\n \n+protected:\n \tBindResult BindExpression(BetweenExpression &expr, idx_t depth);\n \tBindResult BindExpression(CaseExpression &expr, idx_t depth);\n \tBindResult BindExpression(CollateExpression &expr, idx_t depth);\ndiff --git a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\nnew file mode 100644\nindex 000000000000..f1a7f8c9c47c\n--- /dev/null\n+++ b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\n@@ -0,0 +1,33 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/planner/expression_binder/column_alias_binder.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/unordered_map.hpp\"\n+#include \"duckdb/planner/expression_binder.hpp\"\n+\n+namespace duckdb {\n+\n+class BoundSelectNode;\n+class ColumnRefExpression;\n+\n+//! A helper binder for WhereBinder and HavingBinder which support alias as a columnref.\n+class ColumnAliasBinder {\n+public:\n+\tColumnAliasBinder(BoundSelectNode &node, const unordered_map<string, idx_t> &alias_map);\n+\n+\tBindResult BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,\n+\t                     bool root_expression);\n+\n+private:\n+\tBoundSelectNode &node;\n+\tconst unordered_map<string, idx_t> &alias_map;\n+\tbool in_alias;\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression_binder/having_binder.hpp b/src/include/duckdb/planner/expression_binder/having_binder.hpp\nindex 55f93096425a..5dbe8e8a9f85 100644\n--- a/src/include/duckdb/planner/expression_binder/having_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/having_binder.hpp\n@@ -9,6 +9,7 @@\n #pragma once\n \n #include \"duckdb/planner/expression_binder/select_binder.hpp\"\n+#include \"duckdb/planner/expression_binder/column_alias_binder.hpp\"\n \n namespace duckdb {\n \n@@ -18,12 +19,14 @@ class HavingBinder : public SelectBinder {\n \tHavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,\n \t             unordered_map<string, idx_t> &alias_map);\n \n-\tunordered_map<string, idx_t> &alias_map;\n-\tbool in_alias;\n-\n protected:\n \tBindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,\n \t                          bool root_expression = false) override;\n+\n+private:\n+\tBindResult BindColumnRef(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression);\n+\n+\tColumnAliasBinder column_alias_binder;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression_binder/where_binder.hpp b/src/include/duckdb/planner/expression_binder/where_binder.hpp\nindex c6c72bee9ed4..69a490c97c60 100644\n--- a/src/include/duckdb/planner/expression_binder/where_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/where_binder.hpp\n@@ -12,16 +12,23 @@\n \n namespace duckdb {\n \n+class ColumnAliasBinder;\n+\n //! The WHERE binder is responsible for binding an expression within the WHERE clause of a SQL statement\n class WhereBinder : public ExpressionBinder {\n public:\n-\tWhereBinder(Binder &binder, ClientContext &context);\n+\tWhereBinder(Binder &binder, ClientContext &context, ColumnAliasBinder *column_alias_binder = nullptr);\n \n protected:\n \tBindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,\n \t                          bool root_expression = false) override;\n \n \tstring UnsupportedAggregateMessage() override;\n+\n+private:\n+\tBindResult BindColumnRef(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression);\n+\n+\tColumnAliasBinder *column_alias_binder;\n };\n \n } // namespace duckdb\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex dc76d34aaff1..91a0d510e3dd 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -9,6 +9,7 @@\n #include \"duckdb/parser/query_node/select_node.hpp\"\n #include \"duckdb/parser/tableref/joinref.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n+#include \"duckdb/planner/expression_binder/column_alias_binder.hpp\"\n #include \"duckdb/planner/expression_binder/constant_binder.hpp\"\n #include \"duckdb/planner/expression_binder/group_binder.hpp\"\n #include \"duckdb/planner/expression_binder/having_binder.hpp\"\n@@ -19,10 +20,6 @@\n #include \"duckdb/planner/expression_binder/aggregate_binder.hpp\"\n \n namespace duckdb {\n-unique_ptr<Expression> Binder::BindFilter(unique_ptr<ParsedExpression> condition) {\n-\tWhereBinder where_binder(*this, context);\n-\treturn where_binder.Bind(condition);\n-}\n \n unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {\n \t// we treat the Distinct list as a order by\n@@ -220,7 +217,10 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {\n \t// first visit the WHERE clause\n \t// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses\n \tif (statement.where_clause) {\n-\t\tresult->where_clause = BindFilter(move(statement.where_clause));\n+\t\tColumnAliasBinder alias_binder(*result, alias_map);\n+\t\tWhereBinder where_binder(*this, context, &alias_binder);\n+\t\tunique_ptr<ParsedExpression> condition = move(statement.where_clause);\n+\t\tresult->where_clause = where_binder.Bind(condition);\n \t}\n \n \t// now bind all the result modifiers; including DISTINCT and ORDER BY targets\ndiff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp\nindex dce2975c6189..250f92231979 100644\n--- a/src/planner/expression_binder.cpp\n+++ b/src/planner/expression_binder.cpp\n@@ -249,8 +249,6 @@ void ExpressionBinder::BindTableNames(Binder &binder, ParsedExpression &expr, un\n \t\t\tif (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {\n \t\t\t\t// macro parameters get priority\n \t\t\t\tcolref.table_name = binder.macro_binding->alias;\n-\t\t\t} else if (alias_map && alias_map->find(colref.column_name) != alias_map->end()) {\n-\t\t\t\t// alias: leave unqualified\n \t\t\t} else {\n \t\t\t\tcolref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);\n \t\t\t}\ndiff --git a/src/planner/expression_binder/CMakeLists.txt b/src/planner/expression_binder/CMakeLists.txt\nindex 3a0c343b760f..0e9679eb5cea 100644\n--- a/src/planner/expression_binder/CMakeLists.txt\n+++ b/src/planner/expression_binder/CMakeLists.txt\n@@ -4,6 +4,7 @@ add_library_unity(\n   aggregate_binder.cpp\n   alter_binder.cpp\n   check_binder.cpp\n+  column_alias_binder.cpp\n   constant_binder.cpp\n   group_binder.cpp\n   having_binder.cpp\ndiff --git a/src/planner/expression_binder/column_alias_binder.cpp b/src/planner/expression_binder/column_alias_binder.cpp\nnew file mode 100644\nindex 000000000000..c7da48757e08\n--- /dev/null\n+++ b/src/planner/expression_binder/column_alias_binder.cpp\n@@ -0,0 +1,33 @@\n+#include \"duckdb/planner/expression_binder/column_alias_binder.hpp\"\n+\n+#include \"duckdb/parser/expression/columnref_expression.hpp\"\n+#include \"duckdb/planner/query_node/bound_select_node.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n+\n+namespace duckdb {\n+\n+ColumnAliasBinder::ColumnAliasBinder(BoundSelectNode &node, const unordered_map<string, idx_t> &alias_map)\n+    : node(node), alias_map(alias_map), in_alias(false) {\n+}\n+\n+BindResult ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,\n+                                        bool root_expression) {\n+\tif (!expr.table_name.empty()) {\n+\t\treturn BindResult(StringUtil::Format(\"Alias %s cannot be qualified.\", expr.ToString()));\n+\t}\n+\n+\tauto alias_entry = alias_map.find(expr.column_name);\n+\tif (alias_entry == alias_map.end()) {\n+\t\treturn BindResult(StringUtil::Format(\"Alias %s is not found.\", expr.ToString()));\n+\t}\n+\n+\t// found an alias: bind the alias expression\n+\tD_ASSERT(!in_alias);\n+\tauto expression = node.original_expressions[alias_entry->second]->Copy();\n+\tin_alias = true;\n+\tauto result = enclosing_binder.BindExpression(&expression, depth, root_expression);\n+\tin_alias = false;\n+\treturn result;\n+}\n+\n+} // namespace duckdb\n\\ No newline at end of file\ndiff --git a/src/planner/expression_binder/having_binder.cpp b/src/planner/expression_binder/having_binder.cpp\nindex 11bfec67316c..9a55bb4cd638 100644\n--- a/src/planner/expression_binder/having_binder.cpp\n+++ b/src/planner/expression_binder/having_binder.cpp\n@@ -10,10 +10,21 @@ namespace duckdb {\n \n HavingBinder::HavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,\n                            unordered_map<string, idx_t> &alias_map)\n-    : SelectBinder(binder, context, node, info), alias_map(alias_map), in_alias(false) {\n+    : SelectBinder(binder, context, node, info), column_alias_binder(node, alias_map) {\n \ttarget_type = LogicalType(LogicalTypeId::BOOLEAN);\n }\n \n+BindResult HavingBinder::BindColumnRef(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {\n+\tauto &expr = (ColumnRefExpression &)**expr_ptr;\n+\tauto alias_result = column_alias_binder.BindAlias(*this, expr, depth, root_expression);\n+\tif (!alias_result.HasError()) {\n+\t\treturn alias_result;\n+\t}\n+\n+\treturn BindResult(StringUtil::Format(\n+\t    \"column %s must appear in the GROUP BY clause or be used in an aggregate function\", expr.ToString()));\n+}\n+\n BindResult HavingBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {\n \tauto &expr = **expr_ptr;\n \t// check if the expression binds to one of the groups\n@@ -25,22 +36,7 @@ BindResult HavingBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr,\n \tcase ExpressionClass::WINDOW:\n \t\treturn BindResult(\"HAVING clause cannot contain window functions!\");\n \tcase ExpressionClass::COLUMN_REF:\n-\t\tif (!in_alias) {\n-\t\t\tauto &colref = (ColumnRefExpression &)expr;\n-\t\t\tif (colref.table_name.empty()) {\n-\t\t\t\tauto alias_entry = alias_map.find(colref.column_name);\n-\t\t\t\tif (alias_entry != alias_map.end()) {\n-\t\t\t\t\t// found an alias: bind the alias expression\n-\t\t\t\t\tauto expression = node.original_expressions[alias_entry->second]->Copy();\n-\t\t\t\t\tin_alias = true;\n-\t\t\t\t\tauto result = BindExpression(&expression, depth, root_expression);\n-\t\t\t\t\tin_alias = false;\n-\t\t\t\t\treturn result;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn BindResult(StringUtil::Format(\n-\t\t    \"column %s must appear in the GROUP BY clause or be used in an aggregate function\", expr.ToString()));\n+\t\treturn BindColumnRef(expr_ptr, depth, root_expression);\n \tdefault:\n \t\treturn duckdb::SelectBinder::BindExpression(expr_ptr, depth);\n \t}\ndiff --git a/src/planner/expression_binder/where_binder.cpp b/src/planner/expression_binder/where_binder.cpp\nindex 588dda4afd8b..3aa5d2968f39 100644\n--- a/src/planner/expression_binder/where_binder.cpp\n+++ b/src/planner/expression_binder/where_binder.cpp\n@@ -1,11 +1,29 @@\n #include \"duckdb/planner/expression_binder/where_binder.hpp\"\n+#include \"duckdb/planner/expression_binder/column_alias_binder.hpp\"\n \n namespace duckdb {\n \n-WhereBinder::WhereBinder(Binder &binder, ClientContext &context) : ExpressionBinder(binder, context) {\n+WhereBinder::WhereBinder(Binder &binder, ClientContext &context, ColumnAliasBinder *column_alias_binder)\n+    : ExpressionBinder(binder, context), column_alias_binder(column_alias_binder) {\n \ttarget_type = LogicalType(LogicalTypeId::BOOLEAN);\n }\n \n+BindResult WhereBinder::BindColumnRef(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {\n+\tauto &expr = (ColumnRefExpression &)**expr_ptr;\n+\tauto result = ExpressionBinder::BindExpression(expr_ptr, depth);\n+\tif (!result.HasError() || !column_alias_binder) {\n+\t\treturn result;\n+\t}\n+\n+\tBindResult alias_result = column_alias_binder->BindAlias(*this, expr, depth, root_expression);\n+\t// This code path cannot be exercised at thispoint. #1547 might change that.\n+\tif (!alias_result.HasError()) {\n+\t\treturn alias_result;\n+\t}\n+\n+\treturn result;\n+}\n+\n BindResult WhereBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth, bool root_expression) {\n \tauto &expr = **expr_ptr;\n \tswitch (expr.GetExpressionClass()) {\n@@ -13,6 +31,8 @@ BindResult WhereBinder::BindExpression(unique_ptr<ParsedExpression> *expr_ptr, i\n \t\treturn BindResult(\"WHERE clause cannot contain DEFAULT clause\");\n \tcase ExpressionClass::WINDOW:\n \t\treturn BindResult(\"WHERE clause cannot contain window functions!\");\n+\tcase ExpressionClass::COLUMN_REF:\n+\t\treturn BindColumnRef(expr_ptr, depth, root_expression);\n \tdefault:\n \t\treturn ExpressionBinder::BindExpression(expr_ptr, depth);\n \t}\n",
  "test_patch": "diff --git a/test/sql/binder/test_having_alias.test b/test/sql/binder/test_having_alias.test\nindex cfcc4a8fa287..1218ddfdddde 100644\n--- a/test/sql/binder/test_having_alias.test\n+++ b/test/sql/binder/test_having_alias.test\n@@ -22,17 +22,13 @@ SELECT i, COUNT(*) AS k FROM integers GROUP BY i HAVING k=1 ORDER BY i;\n statement error\n SELECT i, COUNT(*) AS k FROM integers GROUP BY i HAVING integers.k=1 ORDER BY i;\n \n-# aliases take priority\n+# column name wins over the alias\n query II\n-SELECT i AS j, COUNT(*) AS i FROM integers GROUP BY j HAVING i=1 ORDER BY 1;\n+SELECT 1 AS i, COUNT(*) FROM integers GROUP BY i HAVING i=2;\n ----\n-0\t1\n 1\t1\n-2\t1\n-3\t1\n-4\t1\n \n-# unless qualified\n+# as if qualified\n query II\n SELECT i AS j, COUNT(*) AS i FROM integers GROUP BY j HAVING integers.i=1 ORDER BY i;\n ----\n@@ -49,20 +45,19 @@ SELECT COUNT(i) AS j FROM integers HAVING j=5;\n ----\n 5\n \n-# potentially recursive alias\n-query I\n+# These don't work since i in HAVING refers the column instead of the alias\n+# (SQLite says: 'Error: a GROUP BY clause is required before HAVING')\n+statement error\n SELECT COUNT(i) AS i FROM integers HAVING i=5;\n-----\n-5\n \n-query I\n+statement error\n SELECT COUNT(i) AS i FROM integers HAVING i=5 ORDER BY i;\n ----\n 5\n \n # use the same alias multiple times\n query I\n-SELECT COUNT(i) AS i FROM integers HAVING i=i;\n+SELECT COUNT(i) AS j FROM integers HAVING j=j;\n ----\n 5\n \ndiff --git a/test/sql/filter/test_alias_filter.test b/test/sql/filter/test_alias_filter.test\nindex 0f0c7f4979e7..c03c4c10ff10 100644\n--- a/test/sql/filter/test_alias_filter.test\n+++ b/test/sql/filter/test_alias_filter.test\n@@ -12,9 +12,43 @@ statement ok\n INSERT INTO integers VALUES (1), (2), (3), (NULL)\n \n # this fails in postgres and monetdb, but succeeds in sqlite\n-# for now, we have this fail as well because it simplifies our life\n-# the filter occurs before the projection, hence \"j\" is not computed until AFTER the filter normally\n-# we probably want to change this to succeed\n+query I\n+SELECT i % 2 AS k FROM integers WHERE k<>0;\n+----\n+1\n+1\n+\n+# These cases roughly follows what HAVING does.\n+# See test/sql/binder/test_having_alias.test.\n+\n+# alias cannot be qualified\n statement error\n-SELECT i % 2 AS j FROM integers WHERE j<>0;\n+SELECT i % 2 AS k FROM integers WHERE integers.k<>0;\n+\n+# columns take priority\n+query I\n+SELECT i % 2 AS i FROM integers WHERE i<>0;\n+----\n+1\n+0\n+1\n \n+# columns with qualified name\n+query I\n+SELECT i % 2 AS k FROM integers WHERE integers.i<>0;\n+----\n+1\n+0\n+1\n+\n+# use the same alias multiple times\n+query I\n+SELECT i % 2 AS k FROM integers WHERE k=k;\n+----\n+1\n+0\n+1\n+\n+# alias to an aggregate doesn't work.\n+statement error\n+SELECT i % 2 AS o, COUNT(i) AS c FROM integers WHERE c = 0 GROUP BY o;\n",
  "problem_statement": "column aliases in WHERE\nHi!\r\nWhat are your thoughts regarding support for the use of column aliases in WHERE?\r\n\r\n```sql\r\nCREATE TABLE integers(i INTEGER); \r\nINSERT INTO integers VALUES (1), (2), (3), (NULL);\r\nSELECT i AS k FROM integers WHERE k=1 ORDER BY k;\r\nError: near line 1: Unknown: Referenced column \"k\" not found in FROM clause!\r\n```\r\n\r\nIt looks like it's supported in GROUP BY and ORDER BY\r\n```sql\r\nSELECT i AS k FROM integers GROUP BY k ORDER BY k;\r\nk\r\n----------\r\n\r\n1\r\n2\r\n3\r\n```\n",
  "hints_text": "I agree this should be added; in fact I started adding this at some point in the past but got sidetracked :)\nI think i can do it.\nThanks! I will assign the issue to you then :) Let me know if you have any questions\nok, I will do it in next week! ",
  "created_at": "2021-10-13T16:29:29Z"
}