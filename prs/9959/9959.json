{
  "repo": "duckdb/duckdb",
  "pull_number": 9959,
  "instance_id": "duckdb__duckdb-9959",
  "issue_numbers": [
    "9921"
  ],
  "base_commit": "8849f97b25b3a99d99f6f6eb3d31c2e31998e939",
  "patch": "diff --git a/tools/pythonpkg/scripts/cache_data.json b/tools/pythonpkg/scripts/cache_data.json\nindex ca9c7a88c4ab..b7f57409d67d 100644\n--- a/tools/pythonpkg/scripts/cache_data.json\n+++ b/tools/pythonpkg/scripts/cache_data.json\n@@ -214,6 +214,7 @@\n         \"full_path\": \"numpy\",\n         \"name\": \"numpy\",\n         \"children\": [\n+\t\t\t\"numpy.core\",\n             \"numpy.ndarray\",\n             \"numpy.datetime64\",\n             \"numpy.generic\",\n@@ -238,6 +239,20 @@\n             \"numpy.clongdouble\"\n         ]\n     },\n+    \"numpy.core\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"numpy.core\",\n+        \"name\": \"core\",\n+        \"children\": [\n+            \"numpy.core.multiarray\"\n+        ]\n+    },\n+    \"numpy.core.multiarray\": {\n+        \"type\": \"attribute\",\n+        \"full_path\": \"numpy.core.multiarray\",\n+        \"name\": \"multiarray\",\n+        \"children\": []\n+    },\n     \"numpy.ndarray\": {\n         \"type\": \"attribute\",\n         \"full_path\": \"numpy.ndarray\",\ndiff --git a/tools/pythonpkg/scripts/imports.py b/tools/pythonpkg/scripts/imports.py\nindex 8d868cb94295..13b5f21aacf5 100644\n--- a/tools/pythonpkg/scripts/imports.py\n+++ b/tools/pythonpkg/scripts/imports.py\n@@ -42,6 +42,7 @@\n \n import numpy\n \n+numpy.core.multiarray\n numpy.ndarray\n numpy.datetime64\n numpy.generic\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp\nindex 06ef90496518..733df11fae80 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/numpy_module.hpp\n@@ -13,6 +13,18 @@\n \n namespace duckdb {\n \n+struct NumpyCoreCacheItem : public PythonImportCacheItem {\n+\n+public:\n+\tNumpyCoreCacheItem(optional_ptr<PythonImportCacheItem> parent)\n+\t    : PythonImportCacheItem(\"core\", parent), multiarray(\"multiarray\", this) {\n+\t}\n+\t~NumpyCoreCacheItem() override {\n+\t}\n+\n+\tPythonImportCacheItem multiarray;\n+};\n+\n struct NumpyCacheItem : public PythonImportCacheItem {\n \n public:\n@@ -20,7 +32,7 @@ struct NumpyCacheItem : public PythonImportCacheItem {\n \n public:\n \tNumpyCacheItem()\n-\t    : PythonImportCacheItem(\"numpy\"), ndarray(\"ndarray\", this), datetime64(\"datetime64\", this),\n+\t    : PythonImportCacheItem(\"numpy\"), core(this), ndarray(\"ndarray\", this), datetime64(\"datetime64\", this),\n \t      generic(\"generic\", this), int64(\"int64\", this), bool_(\"bool_\", this), byte(\"byte\", this),\n \t      ubyte(\"ubyte\", this), short_(\"short\", this), ushort_(\"ushort\", this), intc(\"intc\", this),\n \t      uintc(\"uintc\", this), int_(\"int_\", this), uint(\"uint\", this), longlong(\"longlong\", this),\n@@ -31,6 +43,7 @@ struct NumpyCacheItem : public PythonImportCacheItem {\n \t~NumpyCacheItem() override {\n \t}\n \n+\tNumpyCoreCacheItem core;\n \tPythonImportCacheItem ndarray;\n \tPythonImportCacheItem datetime64;\n \tPythonImportCacheItem generic;\ndiff --git a/tools/pythonpkg/src/python_udf.cpp b/tools/pythonpkg/src/python_udf.cpp\nindex 54494aeb39af..a0597235cf55 100644\n--- a/tools/pythonpkg/src/python_udf.cpp\n+++ b/tools/pythonpkg/src/python_udf.cpp\n@@ -147,7 +147,7 @@ static scalar_function_t CreateVectorizedFunction(PyObject *function, PythonExce\n \t\t// Convert the pyarrow result back to a DuckDB datachunk\n \t\tConvertPyArrowToDataChunk(python_object, result, state.GetContext(), count);\n \n-\t\tif (input.AllConstant()) {\n+\t\tif (input.size() == 1) {\n \t\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n \t\t}\n \t};\n@@ -322,6 +322,11 @@ struct PythonUDFData {\n \n \tScalarFunction GetFunction(const py::function &udf, PythonExceptionHandling exception_handling, bool side_effects,\n \t                           const ClientProperties &client_properties) {\n+\n+\t\tauto &import_cache = *DuckDBPyConnection::ImportCache();\n+\t\t// Import this module, because importing this from a non-main thread causes a segfault\n+\t\t(void)import_cache.numpy.core.multiarray();\n+\n \t\tscalar_function_t func;\n \t\tif (vectorized) {\n \t\t\tfunc = CreateVectorizedFunction(udf.ptr(), exception_handling);\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/udf/test_scalar_arrow.py b/tools/pythonpkg/tests/fast/udf/test_scalar_arrow.py\nindex c715ccce5d18..48055af7f610 100644\n--- a/tools/pythonpkg/tests/fast/udf/test_scalar_arrow.py\n+++ b/tools/pythonpkg/tests/fast/udf/test_scalar_arrow.py\n@@ -124,6 +124,30 @@ def return_too_many(col):\n         with pytest.raises(duckdb.InvalidInputException, match='Returned pyarrow table should have 1 tuples, found 5'):\n             res = con.sql(\"\"\"select too_many_tuples(5)\"\"\").fetchall()\n \n+    def test_arrow_side_effects(self, duckdb_cursor):\n+        import random as r\n+\n+        def random_arrow(x):\n+            if not hasattr(random_arrow, 'data'):\n+                random_arrow.data = 0\n+\n+            input = x.to_pylist()\n+            val = random_arrow.data\n+            output = [val + i for i in range(len(input))]\n+            random_arrow.data += len(input)\n+            return output\n+\n+        duckdb_cursor.create_function(\n+            \"random_arrow\",\n+            random_arrow,\n+            [VARCHAR],\n+            INTEGER,\n+            side_effects=True,\n+            type=\"arrow\",\n+        )\n+        res = duckdb_cursor.query(\"SELECT random_arrow('') FROM range(10)\").fetchall()\n+        assert res == [(0,), (1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,)]\n+\n     def test_return_struct(self):\n         def return_struct(col):\n             con = duckdb.connect()\n",
  "problem_statement": "Python UDF with arrow type incorrectly returns the cache result of the first row\n### What happens?\r\n\r\nWhen defining an Python UDF with `type=\"arrow\"`, e.g. \r\n```\r\nimport random as r\r\n\r\ndef random_arrow(x):\r\n        return [r.randint(0, 10) for item in x.to_pylist()]\r\n...\r\nduckdb.create_function(\r\n        \"random_arrow\",\r\n        random_arrow,\r\n        [VARCHAR],\r\n        INTEGER,\r\n        side_effects=True,\r\n        type=\"arrow\",\r\n    )\r\n```\r\nexecuting a query which call the UDF with the same argument results in incorrect results (which contains the first \"row\" duplicated up to results set size), i.e.\r\n```sql\r\nSELECT random_arrow('') FROM range(10)\r\n```\r\nreturns `[(1,), (1), (1,), ...]` instead of random numbers.\r\nThis incorrect and doesn't seems to honor the `side_effects=True` flag.\r\n\r\nNote: Using `SELECT random_arrow(range) FROM range(10)` returns correct results.\r\n\r\nAttached is a minimally reproducing test.\r\n\r\n\r\n\r\n\r\n### To Reproduce\r\n\r\n```\r\nimport duckdb\r\nimport random as r\r\n\r\nfrom duckdb.typing import INTEGER, VARCHAR\r\n\r\ndef random_arrow(x):\r\n    return [r.randint(0, 10) for item in x.to_pylist()]\r\n\r\ndef random_non_arrow(x):\r\n    return r.randint(0, 10)\r\n\r\ncon = duckdb.connect()\r\n\r\ncon.create_function(\r\n    \"random_non_arrow\",\r\n    random_non_arrow,\r\n    [VARCHAR],\r\n    INTEGER,\r\n    side_effects=True,\r\n)\r\n\r\ncon.create_function(\r\n    \"random_arrow\",\r\n    random_arrow,\r\n    [VARCHAR],\r\n    INTEGER,\r\n    side_effects=True,\r\n    type=\"arrow\",\r\n)\r\n\r\nres = con.sql(\"select random_non_arrow('') from range(10)\").fetchall()\r\nassert len(set(res)) > 1\r\n\r\nres = con.sql(\"select random_arrow(range) from range(10)\").fetchall()\r\nassert len(set(res)) > 1\r\n\r\nres = con.sql(\"select random_arrow('') from range(10)\").fetchall()\r\nassert len(set(res)) > 1 # should pass\r\n```\r\nfails \r\n```\r\n>       assert len(set(res)) > 1\r\nE       assert 1 > 1\r\nE        +  where 1 = len({(10,)})\r\nE        +    where {(10,)} = set([(10,), (10,), (10,), (10,), (10,), (10,), ...])\r\n```\r\n\r\n\r\n### OS:\r\n\r\narm64\r\n\r\n### DuckDB Version:\r\n\r\n0.9.2\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nChi Lang Ngo\r\n\r\n### Affiliation:\r\n\r\nNA\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a release build (and could not test with a main build)\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2023-12-12T09:20:22Z"
}