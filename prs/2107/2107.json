{
  "repo": "duckdb/duckdb",
  "pull_number": 2107,
  "instance_id": "duckdb__duckdb-2107",
  "issue_numbers": [
    "2058"
  ],
  "base_commit": "7e98323abb6114abd89db6f1b574cf958ad05fa6",
  "patch": "diff --git a/src/include/duckdb.h b/src/include/duckdb.h\nindex c8bf22dee3cc..a7699b701741 100644\n--- a/src/include/duckdb.h\n+++ b/src/include/duckdb.h\n@@ -4,7 +4,6 @@\n //\n // duckdb.h\n //\n-// Author: Mark Raasveldt\n //\n //===----------------------------------------------------------------------===//\n \n@@ -28,6 +27,9 @@\n extern \"C\" {\n #endif\n \n+//===--------------------------------------------------------------------===//\n+// Type Information\n+//===--------------------------------------------------------------------===//\n typedef uint64_t idx_t;\n \n typedef enum DUCKDB_TYPE {\n@@ -76,24 +78,42 @@ typedef enum DUCKDB_TYPE {\n \tDUCKDB_TYPE_BLOB\n } duckdb_type;\n \n+//! Days are stored as days since 1970-01-01\n+//! Use the duckdb_from_date/duckdb_to_date function to extract individual information\n+typedef struct {\n+\tint32_t days;\n+} duckdb_date;\n+\n typedef struct {\n \tint32_t year;\n \tint8_t month;\n \tint8_t day;\n-} duckdb_date;\n+} duckdb_date_struct;\n+\n+//! Time is stored as microseconds since 00:00:00\n+//! Use the duckdb_from_time/duckdb_to_time function to extract individual information\n+typedef struct {\n+\tint64_t micros;\n+} duckdb_time;\n \n typedef struct {\n \tint8_t hour;\n \tint8_t min;\n \tint8_t sec;\n \tint32_t micros;\n-} duckdb_time;\n+} duckdb_time_struct;\n \n+//! Timestamps are stored as microseconds since 1970-01-01\n+//! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information\n typedef struct {\n-\tduckdb_date date;\n-\tduckdb_time time;\n+\tint64_t micros;\n } duckdb_timestamp;\n \n+typedef struct {\n+\tduckdb_date_struct date;\n+\tduckdb_time_struct time;\n+} duckdb_timestamp_struct;\n+\n typedef struct {\n \tint32_t months;\n \tint32_t days;\n@@ -131,47 +151,14 @@ typedef void *duckdb_prepared_statement;\n typedef void *duckdb_appender;\n typedef void *duckdb_arrow;\n typedef void *duckdb_config;\n-// we don't need to spell out the schema/array in here\n-// because it's a common interface, users can consume\n-// the data in their own logic.\n typedef void *duckdb_arrow_schema;\n typedef void *duckdb_arrow_array;\n \n typedef enum { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;\n \n-//! query duckdb result as arrow data structure\n-DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);\n-//! get arrow schema\n-DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);\n-//! get arrow data array\n-//! This function can be called multiple time to get next chunks, which will free the previous out_array.\n-//! So consume the out_array before call this function again\n-DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);\n-//! get arrow row count\n-DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);\n-//! get arrow column count\n-DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);\n-//! get arrow rows changed\n-DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);\n-//! get arrow error message\n-DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);\n-//! Destroys the arrow result\n-DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);\n-\n-//! Creates a DuckDB configuration object. The created object must be destroyed with duckdb_destroy_config.\n-DUCKDB_API duckdb_state duckdb_create_config(duckdb_config *out_config);\n-//! Returns the amount of config options available.\n-//! Should not be called in a loop as it internally loops over all the options.\n-DUCKDB_API size_t duckdb_config_count();\n-//! Returns the config name and description for the config at the specified index\n-//! The result MUST NOT be freed\n-//! Returns failure if the index is out of range (i.e. >= duckdb_config_count)\n-DUCKDB_API duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description);\n-//! Sets the specified config option for the configuration\n-DUCKDB_API duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option);\n-//! Destroys a config object created with duckdb_create_config\n-DUCKDB_API void duckdb_destroy_config(duckdb_config *config);\n-\n+//===--------------------------------------------------------------------===//\n+// Open/Connect\n+//===--------------------------------------------------------------------===//\n //! Opens a database file at the given path (nullptr for in-memory). Returns DuckDBSuccess on success, or DuckDBError on\n //! failure. [OUT: database]\n DUCKDB_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);\n@@ -196,7 +183,28 @@ DUCKDB_API void duckdb_destroy_result(duckdb_result *result);\n //! the column names will automatically be destroyed when the result is destroyed.\n DUCKDB_API const char *duckdb_column_name(duckdb_result *result, idx_t col);\n \n-// SAFE fetch functions\n+//===--------------------------------------------------------------------===//\n+// Configuration\n+//===--------------------------------------------------------------------===//\n+//! Creates a DuckDB configuration object. The created object must be destroyed with duckdb_destroy_config.\n+DUCKDB_API duckdb_state duckdb_create_config(duckdb_config *out_config);\n+//! Returns the amount of config options available.\n+//! Should not be called in a loop as it internally loops over all the options.\n+DUCKDB_API size_t duckdb_config_count();\n+//! Returns the config name and description for the config at the specified index\n+//! The result MUST NOT be freed\n+//! Returns failure if the index is out of range (i.e. >= duckdb_config_count)\n+DUCKDB_API duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description);\n+//! Sets the specified config option for the configuration\n+DUCKDB_API duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option);\n+//! Destroys a config object created with duckdb_create_config\n+DUCKDB_API void duckdb_destroy_config(duckdb_config *config);\n+\n+//===--------------------------------------------------------------------===//\n+// Result Functions\n+//===--------------------------------------------------------------------===//\n+\n+// Safe fetch functions\n // These functions will perform conversions if necessary. On failure (e.g. if conversion cannot be performed) a special\n // value is returned.\n \n@@ -210,18 +218,30 @@ DUCKDB_API int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t ro\n DUCKDB_API int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row);\n //! Converts the specified value to an int64_t. Returns 0 on failure or NULL.\n DUCKDB_API int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row);\n+\n //! Converts the specified value to an uint8_t. Returns 0 on failure or NULL.\n DUCKDB_API uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row);\n //! Converts the specified value to an uint16_t. Returns 0 on failure or NULL.\n DUCKDB_API uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row);\n-//! Converts the specified value to an uint64_t. Returns 0 on failure or NULL.\n+//! Converts the specified value to an uint32_t. Returns 0 on failure or NULL.\n DUCKDB_API uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row);\n //! Converts the specified value to an uint64_t. Returns 0 on failure or NULL.\n DUCKDB_API uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row);\n+\n //! Converts the specified value to a float. Returns 0.0 on failure or NULL.\n DUCKDB_API float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row);\n //! Converts the specified value to a double. Returns 0.0 on failure or NULL.\n DUCKDB_API double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row);\n+\n+//! Converts the specified value to an uint16_t. Returns 0 on failure or NULL.\n+DUCKDB_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);\n+//! Converts the specified value to an duckdb_time. Returns 0 on failure or NULL.\n+DUCKDB_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);\n+//! Converts the specified value to an duckdb_timestamp. Returns 0 on failure or NULL.\n+DUCKDB_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);\n+//! Converts the specified value to an duckdb_interval. Returns 0 on failure or NULL.\n+DUCKDB_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);\n+\n //! Converts the specified value to a string. Returns nullptr on failure or NULL. The result must be freed with\n //! duckdb_free.\n DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);\n@@ -229,14 +249,30 @@ DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t ro\n //! resulting \"blob.data\" must be freed with duckdb_free.\n DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);\n \n+//===--------------------------------------------------------------------===//\n+// Helpers\n+//===--------------------------------------------------------------------===//\n //! Allocate [size] amounts of memory using the duckdb internal malloc function. Any memory allocated in this manner\n //! should be freed using duckdb_free\n DUCKDB_API void *duckdb_malloc(size_t size);\n //! Free a value returned from duckdb_malloc, duckdb_value_varchar or duckdb_value_blob\n DUCKDB_API void duckdb_free(void *ptr);\n \n-// Prepared Statements\n+//===--------------------------------------------------------------------===//\n+// Date/Time/Timestamp Helpers\n+//===--------------------------------------------------------------------===//\n+DUCKDB_API duckdb_date_struct duckdb_from_date(duckdb_date date);\n+DUCKDB_API duckdb_date duckdb_to_date(duckdb_date_struct date);\n+\n+DUCKDB_API duckdb_time_struct duckdb_from_time(duckdb_time time);\n+DUCKDB_API duckdb_time duckdb_to_time(duckdb_time_struct time);\n \n+DUCKDB_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp time);\n+DUCKDB_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct time);\n+\n+//===--------------------------------------------------------------------===//\n+// Prepared Statements\n+//===--------------------------------------------------------------------===//\n //! prepares the specified SQL query in the specified connection handle. [OUT: prepared statement descriptor]\n DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,\n                                        duckdb_prepared_statement *out_prepared_statement);\n@@ -250,12 +286,24 @@ DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_stat\n DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);\n DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);\n DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);\n-DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);\n-DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);\n+\n+DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);\n+DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val);\n DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);\n DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);\n+\n DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);\n DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);\n+\n+DUCKDB_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                         duckdb_date val);\n+DUCKDB_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                         duckdb_time val);\n+DUCKDB_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                              duckdb_timestamp val);\n+DUCKDB_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                             duckdb_interval val);\n+\n DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n                                             const char *val);\n DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n@@ -275,6 +323,9 @@ DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement\n //! Destroys the specified prepared statement descriptor\n DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);\n \n+//===--------------------------------------------------------------------===//\n+// Appender\n+//===--------------------------------------------------------------------===//\n DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,\n                                                duckdb_appender *out_appender);\n \n@@ -296,6 +347,11 @@ DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t\n DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);\n DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);\n \n+DUCKDB_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);\n+DUCKDB_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);\n+DUCKDB_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);\n+DUCKDB_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);\n+\n DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);\n DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);\n DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);\n@@ -307,6 +363,28 @@ DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);\n \n DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);\n \n+//===--------------------------------------------------------------------===//\n+// Arrow Interface\n+//===--------------------------------------------------------------------===//\n+//! query duckdb result as arrow data structure\n+DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);\n+//! get arrow schema\n+DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);\n+//! get arrow data array\n+//! This function can be called multiple time to get next chunks, which will free the previous out_array.\n+//! So consume the out_array before call this function again\n+DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);\n+//! get arrow row count\n+DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);\n+//! get arrow column count\n+DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);\n+//! get arrow rows changed\n+DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);\n+//! get arrow error message\n+DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);\n+//! Destroys the arrow result\n+DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);\n+\n #ifdef __cplusplus\n }\n #endif\ndiff --git a/src/include/duckdb/main/appender.hpp b/src/include/duckdb/main/appender.hpp\nindex 79cfbcf331db..241bc0240112 100644\n--- a/src/include/duckdb/main/appender.hpp\n+++ b/src/include/duckdb/main/appender.hpp\n@@ -128,6 +128,8 @@ void DUCKDB_API Appender::Append(dtime_t value);\n template <>\n void DUCKDB_API Appender::Append(timestamp_t value);\n template <>\n+void DUCKDB_API Appender::Append(interval_t value);\n+template <>\n void DUCKDB_API Appender::Append(const char *value);\n template <>\n void DUCKDB_API Appender::Append(string_t value);\ndiff --git a/src/include/duckdb/main/capi_internal.hpp b/src/include/duckdb/main/capi_internal.hpp\nnew file mode 100644\nindex 000000000000..8b4b5bee4d0b\n--- /dev/null\n+++ b/src/include/duckdb/main/capi_internal.hpp\n@@ -0,0 +1,53 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/main/capi_internal.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb.h\"\n+#include \"duckdb.hpp\"\n+#include \"duckdb/common/types/data_chunk.hpp\"\n+#include \"duckdb/main/appender.hpp\"\n+#include <cstring>\n+#include <cassert>\n+\n+#ifdef _WIN32\n+#ifndef strdup\n+#define strdup _strdup\n+#endif\n+#endif\n+\n+#ifdef GetCValue\n+#undef GetCValue\n+#endif\n+\n+namespace duckdb {\n+\n+struct DatabaseData {\n+\tunique_ptr<DuckDB> database;\n+};\n+\n+struct PreparedStatementWrapper {\n+\tunique_ptr<PreparedStatement> statement;\n+\tvector<Value> values;\n+};\n+\n+struct ArrowResultWrapper {\n+\tunique_ptr<MaterializedQueryResult> result;\n+\tunique_ptr<DataChunk> current_chunk;\n+};\n+\n+struct AppenderWrapper {\n+\tunique_ptr<Appender> appender;\n+\tstring error;\n+};\n+\n+duckdb_type ConvertCPPTypeToC(LogicalType type);\n+idx_t GetCTypeSize(duckdb_type type);\n+duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out);\n+\n+} // namespace duckdb\ndiff --git a/src/main/CMakeLists.txt b/src/main/CMakeLists.txt\nindex c05c128fb547..e9b0bed83c5c 100644\n--- a/src/main/CMakeLists.txt\n+++ b/src/main/CMakeLists.txt\n@@ -1,28 +1,27 @@\n+if(NOT CLANG_TIDY)\n+  add_subdirectory(capi)\n+endif()\n add_subdirectory(relation)\n \n if(FORCE_QUERY_LOG)\n   add_definitions(-DDUCKDB_FORCE_QUERY_LOG=\"\\\"\"${FORCE_QUERY_LOG}\"\\\"\")\n endif()\n \n-set(DUCKDB_MAIN_FILES\n-    appender.cpp\n-    client_context.cpp\n-    config.cpp\n-    connection.cpp\n-    database.cpp\n-    materialized_query_result.cpp\n-    prepared_statement.cpp\n-    prepared_statement_data.cpp\n-    relation.cpp\n-    query_profiler.cpp\n-    query_result.cpp\n-    stream_query_result.cpp)\n-\n-if(NOT CLANG_TIDY)\n-  set(DUCKDB_MAIN_FILES ${DUCKDB_MAIN_FILES} duckdb-c.cpp)\n-endif()\n-\n-add_library_unity(duckdb_main OBJECT ${DUCKDB_MAIN_FILES})\n+add_library_unity(\n+  duckdb_main\n+  OBJECT\n+  appender.cpp\n+  client_context.cpp\n+  config.cpp\n+  connection.cpp\n+  database.cpp\n+  materialized_query_result.cpp\n+  prepared_statement.cpp\n+  prepared_statement_data.cpp\n+  relation.cpp\n+  query_profiler.cpp\n+  query_result.cpp\n+  stream_query_result.cpp)\n set(ALL_OBJECT_FILES\n     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_main>\n     PARENT_SCOPE)\ndiff --git a/src/main/appender.cpp b/src/main/appender.cpp\nindex 880d8c6957d6..210e64bdff98 100644\n--- a/src/main/appender.cpp\n+++ b/src/main/appender.cpp\n@@ -202,6 +202,11 @@ void Appender::Append(timestamp_t value) {\n \tAppendValueInternal<int64_t>(value.value);\n }\n \n+template <>\n+void Appender::Append(interval_t value) {\n+\tAppendValueInternal<interval_t>(value);\n+}\n+\n template <>\n void Appender::Append(Value value) { // NOLINT: template shtuff\n \tif (column >= chunk->ColumnCount()) {\ndiff --git a/src/main/capi/CMakeLists.txt b/src/main/capi/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..314b9d5bfafd\n--- /dev/null\n+++ b/src/main/capi/CMakeLists.txt\n@@ -0,0 +1,16 @@\n+add_library_unity(\n+  duckdb_main_capi\n+  OBJECT\n+  appender-c.cpp\n+  arrow-c.cpp\n+  config-c.cpp\n+  datetime-c.cpp\n+  duckdb-c.cpp\n+  helper-c.cpp\n+  prepared-c.cpp\n+  result-c.cpp\n+  value-c.cpp)\n+\n+set(ALL_OBJECT_FILES\n+    ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_main_capi>\n+    PARENT_SCOPE)\ndiff --git a/src/main/capi/appender-c.cpp b/src/main/capi/appender-c.cpp\nnew file mode 100644\nindex 000000000000..eb07c8a42768\n--- /dev/null\n+++ b/src/main/capi/appender-c.cpp\n@@ -0,0 +1,184 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+\n+using duckdb::Appender;\n+using duckdb::AppenderWrapper;\n+using duckdb::Connection;\n+using duckdb::date_t;\n+using duckdb::dtime_t;\n+using duckdb::interval_t;\n+using duckdb::string_t;\n+using duckdb::timestamp_t;\n+\n+duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,\n+                                    duckdb_appender *out_appender) {\n+\tConnection *conn = (Connection *)connection;\n+\n+\tif (!connection || !table || !out_appender) {\n+\t\treturn DuckDBError;\n+\t}\n+\tif (schema == nullptr) {\n+\t\tschema = DEFAULT_SCHEMA;\n+\t}\n+\tauto wrapper = new AppenderWrapper();\n+\t*out_appender = (duckdb_appender)wrapper;\n+\ttry {\n+\t\twrapper->appender = duckdb::make_unique<Appender>(*conn, schema, table);\n+\t} catch (std::exception &ex) {\n+\t\twrapper->error = ex.what();\n+\t\treturn DuckDBError;\n+\t} catch (...) { // LCOV_EXCL_START\n+\t\twrapper->error = \"Unknown create appender error\";\n+\t\treturn DuckDBError;\n+\t} // LCOV_EXCL_STOP\n+\treturn DuckDBSuccess;\n+}\n+\n+duckdb_state duckdb_appender_destroy(duckdb_appender *appender) {\n+\tif (!appender || !*appender) {\n+\t\treturn DuckDBError;\n+\t}\n+\tauto wrapper = (AppenderWrapper *)*appender;\n+\tif (wrapper) {\n+\t\tdelete wrapper;\n+\t}\n+\t*appender = nullptr;\n+\treturn DuckDBSuccess;\n+}\n+\n+template <class FUN>\n+duckdb_state duckdb_appender_run_function(duckdb_appender appender, FUN &&function) {\n+\tif (!appender) {\n+\t\treturn DuckDBError;\n+\t}\n+\tauto wrapper = (AppenderWrapper *)appender;\n+\ttry {\n+\t\tfunction(*wrapper->appender);\n+\t} catch (std::exception &ex) {\n+\t\twrapper->error = ex.what();\n+\t\treturn DuckDBError;\n+\t} catch (...) { // LCOV_EXCL_START\n+\t\twrapper->error = \"Unknown error\";\n+\t\treturn DuckDBError;\n+\t} // LCOV_EXCL_STOP\n+\treturn DuckDBSuccess;\n+}\n+\n+const char *duckdb_appender_error(duckdb_appender appender) {\n+\tif (!appender) {\n+\t\treturn nullptr;\n+\t}\n+\tauto wrapper = (AppenderWrapper *)appender;\n+\tif (wrapper->error.empty()) {\n+\t\treturn nullptr;\n+\t}\n+\treturn strdup(wrapper->error.c_str());\n+}\n+\n+duckdb_state duckdb_appender_begin_row(duckdb_appender appender) {\n+\treturn duckdb_appender_run_function(appender, [&](Appender &appender) { appender.BeginRow(); });\n+}\n+\n+duckdb_state duckdb_appender_end_row(duckdb_appender appender) {\n+\treturn duckdb_appender_run_function(appender, [&](Appender &appender) { appender.EndRow(); });\n+}\n+\n+template <class T>\n+duckdb_state duckdb_append_internal(duckdb_appender appender, T value) {\n+\tif (!appender) {\n+\t\treturn DuckDBError;\n+\t}\n+\tauto *appender_instance = (AppenderWrapper *)appender;\n+\ttry {\n+\t\tappender_instance->appender->Append<T>(value);\n+\t} catch (...) {\n+\t\treturn DuckDBError;\n+\t}\n+\treturn DuckDBSuccess;\n+}\n+\n+duckdb_state duckdb_append_bool(duckdb_appender appender, bool value) {\n+\treturn duckdb_append_internal<bool>(appender, value);\n+}\n+\n+duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value) {\n+\treturn duckdb_append_internal<int8_t>(appender, value);\n+}\n+\n+duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value) {\n+\treturn duckdb_append_internal<int16_t>(appender, value);\n+}\n+\n+duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value) {\n+\treturn duckdb_append_internal<int32_t>(appender, value);\n+}\n+\n+duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value) {\n+\treturn duckdb_append_internal<int64_t>(appender, value);\n+}\n+\n+duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value) {\n+\treturn duckdb_append_internal<uint8_t>(appender, value);\n+}\n+\n+duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value) {\n+\treturn duckdb_append_internal<uint16_t>(appender, value);\n+}\n+\n+duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value) {\n+\treturn duckdb_append_internal<uint32_t>(appender, value);\n+}\n+\n+duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value) {\n+\treturn duckdb_append_internal<uint64_t>(appender, value);\n+}\n+\n+duckdb_state duckdb_append_float(duckdb_appender appender, float value) {\n+\treturn duckdb_append_internal<float>(appender, value);\n+}\n+\n+duckdb_state duckdb_append_double(duckdb_appender appender, double value) {\n+\treturn duckdb_append_internal<double>(appender, value);\n+}\n+\n+duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value) {\n+\treturn duckdb_append_internal<date_t>(appender, date_t(value.days));\n+}\n+\n+duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value) {\n+\treturn duckdb_append_internal<dtime_t>(appender, dtime_t(value.micros));\n+}\n+\n+duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value) {\n+\treturn duckdb_append_internal<timestamp_t>(appender, timestamp_t(value.micros));\n+}\n+\n+duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value) {\n+\tinterval_t interval;\n+\tinterval.months = value.months;\n+\tinterval.days = value.days;\n+\tinterval.micros = value.micros;\n+\treturn duckdb_append_internal<interval_t>(appender, interval);\n+}\n+\n+duckdb_state duckdb_append_null(duckdb_appender appender) {\n+\treturn duckdb_append_internal<std::nullptr_t>(appender, nullptr);\n+}\n+\n+duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val) {\n+\treturn duckdb_append_internal<const char *>(appender, val);\n+}\n+\n+duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length) {\n+\treturn duckdb_append_internal<string_t>(appender, string_t(val, length));\n+}\n+duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length) {\n+\treturn duckdb_append_internal<string_t>(appender, string_t((const char *)data, length));\n+}\n+\n+duckdb_state duckdb_appender_flush(duckdb_appender appender) {\n+\treturn duckdb_appender_run_function(appender, [&](Appender &appender) { appender.Flush(); });\n+}\n+\n+duckdb_state duckdb_appender_close(duckdb_appender appender) {\n+\treturn duckdb_appender_run_function(appender, [&](Appender &appender) { appender.Close(); });\n+}\ndiff --git a/src/main/capi/arrow-c.cpp b/src/main/capi/arrow-c.cpp\nnew file mode 100644\nindex 000000000000..c2f233dcc249\n--- /dev/null\n+++ b/src/main/capi/arrow-c.cpp\n@@ -0,0 +1,92 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+\n+using duckdb::ArrowResultWrapper;\n+using duckdb::Connection;\n+using duckdb::DataChunk;\n+using duckdb::LogicalType;\n+using duckdb::MaterializedQueryResult;\n+using duckdb::PreparedStatementWrapper;\n+using duckdb::QueryResult;\n+using duckdb::QueryResultType;\n+\n+duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result) {\n+\tConnection *conn = (Connection *)connection;\n+\tauto wrapper = new ArrowResultWrapper();\n+\twrapper->result = conn->Query(query);\n+\t*out_result = (duckdb_arrow)wrapper;\n+\treturn wrapper->result->success ? DuckDBSuccess : DuckDBError;\n+}\n+\n+duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema) {\n+\tif (!out_schema) {\n+\t\treturn DuckDBSuccess;\n+\t}\n+\tauto wrapper = (ArrowResultWrapper *)result;\n+\twrapper->result->ToArrowSchema((ArrowSchema *)*out_schema);\n+\treturn DuckDBSuccess;\n+}\n+\n+duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array) {\n+\tif (!out_array) {\n+\t\treturn DuckDBSuccess;\n+\t}\n+\tauto wrapper = (ArrowResultWrapper *)result;\n+\tauto success = wrapper->result->TryFetch(wrapper->current_chunk, wrapper->result->error);\n+\tif (!success) { // LCOV_EXCL_START\n+\t\treturn DuckDBError;\n+\t} // LCOV_EXCL_STOP\n+\tif (!wrapper->current_chunk || wrapper->current_chunk->size() == 0) {\n+\t\treturn DuckDBSuccess;\n+\t}\n+\twrapper->current_chunk->ToArrowArray((ArrowArray *)*out_array);\n+\treturn DuckDBSuccess;\n+}\n+\n+idx_t duckdb_arrow_row_count(duckdb_arrow result) {\n+\tauto wrapper = (ArrowResultWrapper *)result;\n+\treturn wrapper->result->collection.Count();\n+}\n+\n+idx_t duckdb_arrow_column_count(duckdb_arrow result) {\n+\tauto wrapper = (ArrowResultWrapper *)result;\n+\treturn wrapper->result->types.size();\n+}\n+\n+idx_t duckdb_arrow_rows_changed(duckdb_arrow result) {\n+\tauto wrapper = (ArrowResultWrapper *)result;\n+\tidx_t rows_changed = 0;\n+\tidx_t row_count = wrapper->result->collection.Count();\n+\tif (row_count > 0 && StatementTypeReturnChanges(wrapper->result->statement_type)) {\n+\t\tauto row_changes = wrapper->result->GetValue(0, 0);\n+\t\tif (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {\n+\t\t\trows_changed = row_changes.GetValue<int64_t>();\n+\t\t}\n+\t}\n+\treturn rows_changed;\n+}\n+\n+const char *duckdb_query_arrow_error(duckdb_arrow result) {\n+\tauto wrapper = (ArrowResultWrapper *)result;\n+\treturn strdup(wrapper->result->error.c_str());\n+}\n+\n+void duckdb_destroy_arrow(duckdb_arrow *result) {\n+\tif (*result) {\n+\t\tauto wrapper = (ArrowResultWrapper *)*result;\n+\t\tdelete wrapper;\n+\t\t*result = nullptr;\n+\t}\n+}\n+\n+duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement, duckdb_arrow *out_result) {\n+\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n+\tif (!wrapper || !wrapper->statement || !wrapper->statement->success || !out_result) {\n+\t\treturn DuckDBError;\n+\t}\n+\tauto arrow_wrapper = new ArrowResultWrapper();\n+\tauto result = wrapper->statement->Execute(wrapper->values, false);\n+\tD_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);\n+\tarrow_wrapper->result = duckdb::unique_ptr_cast<QueryResult, MaterializedQueryResult>(move(result));\n+\t*out_result = (duckdb_arrow)arrow_wrapper;\n+\treturn arrow_wrapper->result->success ? DuckDBSuccess : DuckDBError;\n+}\ndiff --git a/src/main/capi/config-c.cpp b/src/main/capi/config-c.cpp\nnew file mode 100644\nindex 000000000000..2a89c89f51e2\n--- /dev/null\n+++ b/src/main/capi/config-c.cpp\n@@ -0,0 +1,67 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+#include \"duckdb/main/config.hpp\"\n+#include \"duckdb/common/types/value.hpp\"\n+\n+using duckdb::DBConfig;\n+using duckdb::Value;\n+\n+// config\n+duckdb_state duckdb_create_config(duckdb_config *out_config) {\n+\tif (!out_config) {\n+\t\treturn DuckDBError;\n+\t}\n+\tDBConfig *config;\n+\ttry {\n+\t\tconfig = new DBConfig();\n+\t} catch (...) { // LCOV_EXCL_START\n+\t\treturn DuckDBError;\n+\t} // LCOV_EXCL_STOP\n+\t*out_config = (duckdb_config)config;\n+\treturn DuckDBSuccess;\n+}\n+\n+size_t duckdb_config_count() {\n+\treturn DBConfig::GetOptionCount();\n+}\n+\n+duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description) {\n+\tauto option = DBConfig::GetOptionByIndex(index);\n+\tif (!option) {\n+\t\treturn DuckDBError;\n+\t}\n+\tif (out_name) {\n+\t\t*out_name = option->name;\n+\t}\n+\tif (out_description) {\n+\t\t*out_description = option->description;\n+\t}\n+\treturn DuckDBSuccess;\n+}\n+\n+duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option) {\n+\tif (!config || !name || !option) {\n+\t\treturn DuckDBError;\n+\t}\n+\tauto config_option = DBConfig::GetOptionByName(name);\n+\tif (!config_option) {\n+\t\treturn DuckDBError;\n+\t}\n+\ttry {\n+\t\tauto db_config = (DBConfig *)config;\n+\t\tdb_config->SetOption(*config_option, Value(option));\n+\t} catch (...) {\n+\t\treturn DuckDBError;\n+\t}\n+\treturn DuckDBSuccess;\n+}\n+\n+void duckdb_destroy_config(duckdb_config *config) {\n+\tif (!config) {\n+\t\treturn;\n+\t}\n+\tif (*config) {\n+\t\tauto db_config = (DBConfig *)*config;\n+\t\tdelete db_config;\n+\t\t*config = nullptr;\n+\t}\n+}\ndiff --git a/src/main/capi/datetime-c.cpp b/src/main/capi/datetime-c.cpp\nnew file mode 100644\nindex 000000000000..a26fa5bb74bb\n--- /dev/null\n+++ b/src/main/capi/datetime-c.cpp\n@@ -0,0 +1,73 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+#include \"duckdb/common/types/date.hpp\"\n+#include \"duckdb/common/types/time.hpp\"\n+#include \"duckdb/common/types/timestamp.hpp\"\n+\n+using duckdb::Date;\n+using duckdb::Time;\n+using duckdb::Timestamp;\n+\n+using duckdb::date_t;\n+using duckdb::dtime_t;\n+using duckdb::timestamp_t;\n+\n+duckdb_date_struct duckdb_from_date(duckdb_date date) {\n+\tint32_t year, month, day;\n+\tDate::Convert(date_t(date.days), year, month, day);\n+\n+\tduckdb_date_struct result;\n+\tresult.year = year;\n+\tresult.month = month;\n+\tresult.day = day;\n+\treturn result;\n+}\n+\n+duckdb_date duckdb_to_date(duckdb_date_struct date) {\n+\tduckdb_date result;\n+\tresult.days = Date::FromDate(date.year, date.month, date.day).days;\n+\treturn result;\n+}\n+\n+duckdb_time_struct duckdb_from_time(duckdb_time time) {\n+\tint32_t hour, minute, second, micros;\n+\tTime::Convert(dtime_t(time.micros), hour, minute, second, micros);\n+\n+\tduckdb_time_struct result;\n+\tresult.hour = hour;\n+\tresult.min = minute;\n+\tresult.sec = second;\n+\tresult.micros = micros;\n+\treturn result;\n+}\n+\n+duckdb_time duckdb_to_time(duckdb_time_struct time) {\n+\tduckdb_time result;\n+\tresult.micros = Time::FromTime(time.hour, time.min, time.sec, time.micros).micros;\n+\treturn result;\n+}\n+\n+duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts) {\n+\tdate_t date;\n+\tdtime_t time;\n+\tTimestamp::Convert(timestamp_t(ts.micros), date, time);\n+\n+\tduckdb_date ddate;\n+\tddate.days = date.days;\n+\n+\tduckdb_time dtime;\n+\tdtime.micros = time.micros;\n+\n+\tduckdb_timestamp_struct result;\n+\tresult.date = duckdb_from_date(ddate);\n+\tresult.time = duckdb_from_time(dtime);\n+\treturn result;\n+}\n+\n+duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts) {\n+\tdate_t date = date_t(duckdb_to_date(ts.date).days);\n+\tdtime_t time = dtime_t(duckdb_to_time(ts.time).micros);\n+\n+\tduckdb_timestamp result;\n+\tresult.micros = Timestamp::FromDatetime(date, time).value;\n+\treturn result;\n+}\ndiff --git a/src/main/capi/duckdb-c.cpp b/src/main/capi/duckdb-c.cpp\nnew file mode 100644\nindex 000000000000..cfb9d00f8055\n--- /dev/null\n+++ b/src/main/capi/duckdb-c.cpp\n@@ -0,0 +1,111 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+\n+using duckdb::Connection;\n+using duckdb::DatabaseData;\n+using duckdb::DBConfig;\n+using duckdb::DuckDB;\n+\n+duckdb_state duckdb_open_ext(const char *path, duckdb_database *out, duckdb_config config, char **error) {\n+\tauto wrapper = new DatabaseData();\n+\ttry {\n+\t\tauto db_config = (DBConfig *)config;\n+\t\twrapper->database = duckdb::make_unique<DuckDB>(path, db_config);\n+\t} catch (std::exception &ex) {\n+\t\tif (error) {\n+\t\t\t*error = strdup(ex.what());\n+\t\t}\n+\t\tdelete wrapper;\n+\t\treturn DuckDBError;\n+\t} catch (...) { // LCOV_EXCL_START\n+\t\tif (error) {\n+\t\t\t*error = strdup(\"Unknown error\");\n+\t\t}\n+\t\tdelete wrapper;\n+\t\treturn DuckDBError;\n+\t} // LCOV_EXCL_STOP\n+\t*out = (duckdb_database)wrapper;\n+\treturn DuckDBSuccess;\n+}\n+\n+duckdb_state duckdb_open(const char *path, duckdb_database *out) {\n+\treturn duckdb_open_ext(path, out, nullptr, nullptr);\n+}\n+\n+void duckdb_close(duckdb_database *database) {\n+\tif (database && *database) {\n+\t\tauto wrapper = (DatabaseData *)*database;\n+\t\tdelete wrapper;\n+\t\t*database = nullptr;\n+\t}\n+}\n+\n+duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out) {\n+\tif (!database || !out) {\n+\t\treturn DuckDBError;\n+\t}\n+\tauto wrapper = (DatabaseData *)database;\n+\tConnection *connection;\n+\ttry {\n+\t\tconnection = new Connection(*wrapper->database);\n+\t} catch (...) { // LCOV_EXCL_START\n+\t\treturn DuckDBError;\n+\t} // LCOV_EXCL_STOP\n+\t*out = (duckdb_connection)connection;\n+\treturn DuckDBSuccess;\n+}\n+\n+void duckdb_disconnect(duckdb_connection *connection) {\n+\tif (connection && *connection) {\n+\t\tConnection *conn = (Connection *)*connection;\n+\t\tdelete conn;\n+\t\t*connection = nullptr;\n+\t}\n+}\n+\n+duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out) {\n+\tConnection *conn = (Connection *)connection;\n+\tauto result = conn->Query(query);\n+\treturn duckdb_translate_result(result.get(), out);\n+}\n+\n+static void duckdb_destroy_column(duckdb_column column, idx_t count) {\n+\tif (column.data) {\n+\t\tif (column.type == DUCKDB_TYPE_VARCHAR) {\n+\t\t\t// varchar, delete individual strings\n+\t\t\tauto data = (char **)column.data;\n+\t\t\tfor (idx_t i = 0; i < count; i++) {\n+\t\t\t\tif (data[i]) {\n+\t\t\t\t\tfree(data[i]);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else if (column.type == DUCKDB_TYPE_BLOB) {\n+\t\t\t// blob, delete individual blobs\n+\t\t\tauto data = (duckdb_blob *)column.data;\n+\t\t\tfor (idx_t i = 0; i < count; i++) {\n+\t\t\t\tif (data[i].data) {\n+\t\t\t\t\tfree((void *)data[i].data);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tfree(column.data);\n+\t}\n+\tif (column.nullmask) {\n+\t\tfree(column.nullmask);\n+\t}\n+\tif (column.name) {\n+\t\tfree(column.name);\n+\t}\n+}\n+\n+void duckdb_destroy_result(duckdb_result *result) {\n+\tif (result->error_message) {\n+\t\tfree(result->error_message);\n+\t}\n+\tif (result->columns) {\n+\t\tfor (idx_t i = 0; i < result->column_count; i++) {\n+\t\t\tduckdb_destroy_column(result->columns[i], result->row_count);\n+\t\t}\n+\t\tfree(result->columns);\n+\t}\n+\tmemset(result, 0, sizeof(duckdb_result));\n+}\ndiff --git a/src/main/capi/helper-c.cpp b/src/main/capi/helper-c.cpp\nnew file mode 100644\nindex 000000000000..5a2ab40fd62a\n--- /dev/null\n+++ b/src/main/capi/helper-c.cpp\n@@ -0,0 +1,110 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+\n+namespace duckdb {\n+\n+duckdb_type ConvertCPPTypeToC(LogicalType sql_type) {\n+\tswitch (sql_type.id()) {\n+\tcase LogicalTypeId::BOOLEAN:\n+\t\treturn DUCKDB_TYPE_BOOLEAN;\n+\tcase LogicalTypeId::TINYINT:\n+\t\treturn DUCKDB_TYPE_TINYINT;\n+\tcase LogicalTypeId::SMALLINT:\n+\t\treturn DUCKDB_TYPE_SMALLINT;\n+\tcase LogicalTypeId::INTEGER:\n+\t\treturn DUCKDB_TYPE_INTEGER;\n+\tcase LogicalTypeId::BIGINT:\n+\t\treturn DUCKDB_TYPE_BIGINT;\n+\tcase LogicalTypeId::UTINYINT:\n+\t\treturn DUCKDB_TYPE_UTINYINT;\n+\tcase LogicalTypeId::USMALLINT:\n+\t\treturn DUCKDB_TYPE_USMALLINT;\n+\tcase LogicalTypeId::UINTEGER:\n+\t\treturn DUCKDB_TYPE_UINTEGER;\n+\tcase LogicalTypeId::UBIGINT:\n+\t\treturn DUCKDB_TYPE_UBIGINT;\n+\tcase LogicalTypeId::HUGEINT:\n+\t\treturn DUCKDB_TYPE_HUGEINT;\n+\tcase LogicalTypeId::FLOAT:\n+\t\treturn DUCKDB_TYPE_FLOAT;\n+\tcase LogicalTypeId::DOUBLE:\n+\t\treturn DUCKDB_TYPE_DOUBLE;\n+\tcase LogicalTypeId::TIMESTAMP:\n+\t\treturn DUCKDB_TYPE_TIMESTAMP;\n+\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\treturn DUCKDB_TYPE_TIMESTAMP_S;\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\treturn DUCKDB_TYPE_TIMESTAMP_MS;\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\treturn DUCKDB_TYPE_TIMESTAMP_NS;\n+\tcase LogicalTypeId::DATE:\n+\t\treturn DUCKDB_TYPE_DATE;\n+\tcase LogicalTypeId::TIME:\n+\t\treturn DUCKDB_TYPE_TIME;\n+\tcase LogicalTypeId::VARCHAR:\n+\t\treturn DUCKDB_TYPE_VARCHAR;\n+\tcase LogicalTypeId::BLOB:\n+\t\treturn DUCKDB_TYPE_BLOB;\n+\tcase LogicalTypeId::INTERVAL:\n+\t\treturn DUCKDB_TYPE_INTERVAL;\n+\tdefault: // LCOV_EXCL_START\n+\t\tD_ASSERT(0);\n+\t\treturn DUCKDB_TYPE_INVALID;\n+\t} // LCOV_EXCL_STOP\n+}\n+idx_t GetCTypeSize(duckdb_type type) {\n+\tswitch (type) {\n+\tcase DUCKDB_TYPE_BOOLEAN:\n+\t\treturn sizeof(bool);\n+\tcase DUCKDB_TYPE_TINYINT:\n+\t\treturn sizeof(int8_t);\n+\tcase DUCKDB_TYPE_SMALLINT:\n+\t\treturn sizeof(int16_t);\n+\tcase DUCKDB_TYPE_INTEGER:\n+\t\treturn sizeof(int32_t);\n+\tcase DUCKDB_TYPE_BIGINT:\n+\t\treturn sizeof(int64_t);\n+\tcase DUCKDB_TYPE_UTINYINT:\n+\t\treturn sizeof(uint8_t);\n+\tcase DUCKDB_TYPE_USMALLINT:\n+\t\treturn sizeof(uint16_t);\n+\tcase DUCKDB_TYPE_UINTEGER:\n+\t\treturn sizeof(uint32_t);\n+\tcase DUCKDB_TYPE_UBIGINT:\n+\t\treturn sizeof(uint64_t);\n+\tcase DUCKDB_TYPE_HUGEINT:\n+\t\treturn sizeof(duckdb_hugeint);\n+\tcase DUCKDB_TYPE_FLOAT:\n+\t\treturn sizeof(float);\n+\tcase DUCKDB_TYPE_DOUBLE:\n+\t\treturn sizeof(double);\n+\tcase DUCKDB_TYPE_DATE:\n+\t\treturn sizeof(duckdb_date);\n+\tcase DUCKDB_TYPE_TIME:\n+\t\treturn sizeof(duckdb_time);\n+\tcase DUCKDB_TYPE_TIMESTAMP:\n+\tcase DUCKDB_TYPE_TIMESTAMP_NS:\n+\tcase DUCKDB_TYPE_TIMESTAMP_MS:\n+\tcase DUCKDB_TYPE_TIMESTAMP_S:\n+\t\treturn sizeof(duckdb_timestamp);\n+\tcase DUCKDB_TYPE_VARCHAR:\n+\t\treturn sizeof(const char *);\n+\tcase DUCKDB_TYPE_BLOB:\n+\t\treturn sizeof(duckdb_blob);\n+\tcase DUCKDB_TYPE_INTERVAL:\n+\t\treturn sizeof(duckdb_interval);\n+\tdefault: // LCOV_EXCL_START\n+\t\t// unsupported type\n+\t\tD_ASSERT(0);\n+\t\treturn sizeof(const char *);\n+\t} // LCOV_EXCL_STOP\n+}\n+\n+} // namespace duckdb\n+\n+void *duckdb_malloc(size_t size) {\n+\treturn malloc(size);\n+}\n+\n+void duckdb_free(void *ptr) {\n+\tfree(ptr);\n+}\ndiff --git a/src/main/capi/prepared-c.cpp b/src/main/capi/prepared-c.cpp\nnew file mode 100644\nindex 000000000000..905f42109fee\n--- /dev/null\n+++ b/src/main/capi/prepared-c.cpp\n@@ -0,0 +1,157 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+#include \"duckdb/common/assert.hpp\"\n+#include \"duckdb/main/query_result.hpp\"\n+\n+using duckdb::Connection;\n+using duckdb::date_t;\n+using duckdb::dtime_t;\n+using duckdb::MaterializedQueryResult;\n+using duckdb::PreparedStatementWrapper;\n+using duckdb::QueryResultType;\n+using duckdb::timestamp_t;\n+using duckdb::Value;\n+\n+duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,\n+                            duckdb_prepared_statement *out_prepared_statement) {\n+\tif (!connection || !query || !out_prepared_statement) {\n+\t\treturn DuckDBError;\n+\t}\n+\tauto wrapper = new PreparedStatementWrapper();\n+\tConnection *conn = (Connection *)connection;\n+\twrapper->statement = conn->Prepare(query);\n+\t*out_prepared_statement = (duckdb_prepared_statement)wrapper;\n+\treturn wrapper->statement->success ? DuckDBSuccess : DuckDBError;\n+}\n+\n+const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement) {\n+\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n+\tif (!wrapper || !wrapper->statement || wrapper->statement->success) {\n+\t\treturn nullptr;\n+\t}\n+\treturn strdup(wrapper->statement->error.c_str());\n+}\n+\n+duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out) {\n+\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n+\tif (!wrapper || !wrapper->statement || !wrapper->statement->success || !nparams_out) {\n+\t\treturn DuckDBError;\n+\t}\n+\t*nparams_out = wrapper->statement->n_param;\n+\treturn DuckDBSuccess;\n+}\n+\n+static duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_statement, idx_t param_idx, Value val) {\n+\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n+\tif (!wrapper || !wrapper->statement || !wrapper->statement->success) {\n+\t\treturn DuckDBError;\n+\t}\n+\tif (param_idx > wrapper->statement->n_param) {\n+\t\treturn DuckDBError;\n+\t}\n+\tif (param_idx > wrapper->values.size()) {\n+\t\twrapper->values.resize(param_idx);\n+\t}\n+\twrapper->values[param_idx - 1] = val;\n+\treturn DuckDBSuccess;\n+}\n+\n+duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::BOOLEAN(val));\n+}\n+\n+duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::TINYINT(val));\n+}\n+\n+duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::SMALLINT(val));\n+}\n+\n+duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::INTEGER(val));\n+}\n+\n+duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::BIGINT(val));\n+}\n+\n+duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::UTINYINT(val));\n+}\n+\n+duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::USMALLINT(val));\n+}\n+\n+duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::UINTEGER(val));\n+}\n+\n+duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::UBIGINT(val));\n+}\n+\n+duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value(val));\n+}\n+\n+duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value(val));\n+}\n+\n+duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx, duckdb_date val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::DATE(date_t(val.days)));\n+}\n+\n+duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx, duckdb_time val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::TIME(dtime_t(val.micros)));\n+}\n+\n+duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                   duckdb_timestamp val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::TIMESTAMP(timestamp_t(val.micros)));\n+}\n+\n+duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx, duckdb_interval val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::INTERVAL(val.months, val.days, val.micros));\n+}\n+\n+duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value(val));\n+}\n+\n+duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val,\n+                                        idx_t length) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value(std::string(val, length)));\n+}\n+\n+duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx, const void *data,\n+                              idx_t length) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value::BLOB((duckdb::const_data_ptr_t)data, length));\n+}\n+\n+duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx) {\n+\treturn duckdb_bind_value(prepared_statement, param_idx, Value());\n+}\n+\n+duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement, duckdb_result *out_result) {\n+\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n+\tif (!wrapper || !wrapper->statement || !wrapper->statement->success) {\n+\t\treturn DuckDBError;\n+\t}\n+\tauto result = wrapper->statement->Execute(wrapper->values, false);\n+\tD_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);\n+\tauto mat_res = (MaterializedQueryResult *)result.get();\n+\treturn duckdb_translate_result(mat_res, out_result);\n+}\n+\n+void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement) {\n+\tif (!prepared_statement) {\n+\t\treturn;\n+\t}\n+\tauto wrapper = (PreparedStatementWrapper *)*prepared_statement;\n+\tif (wrapper) {\n+\t\tdelete wrapper;\n+\t}\n+\t*prepared_statement = nullptr;\n+}\ndiff --git a/src/main/capi/result-c.cpp b/src/main/capi/result-c.cpp\nnew file mode 100644\nindex 000000000000..c7d85cfea4bc\n--- /dev/null\n+++ b/src/main/capi/result-c.cpp\n@@ -0,0 +1,221 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+#include \"duckdb/common/types/timestamp.hpp\"\n+\n+namespace duckdb {\n+\n+template <class T>\n+void WriteData(duckdb_result *out, ChunkCollection &source, idx_t col) {\n+\tidx_t row = 0;\n+\tauto target = (T *)out->columns[col].data;\n+\tfor (auto &chunk : source.Chunks()) {\n+\t\tauto source = FlatVector::GetData<T>(chunk->data[col]);\n+\t\tauto &mask = FlatVector::Validity(chunk->data[col]);\n+\n+\t\tfor (idx_t k = 0; k < chunk->size(); k++, row++) {\n+\t\t\tif (!mask.RowIsValid(k)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\ttarget[row] = source[k];\n+\t\t}\n+\t}\n+}\n+\n+duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out) {\n+\tD_ASSERT(result);\n+\tif (!out) {\n+\t\t// no result to write to, only return the status\n+\t\treturn result->success ? DuckDBSuccess : DuckDBError;\n+\t}\n+\tmemset(out, 0, sizeof(duckdb_result));\n+\tif (!result->success) {\n+\t\t// write the error message\n+\t\tout->error_message = strdup(result->error.c_str());\n+\t\treturn DuckDBError;\n+\t}\n+\t// copy the data\n+\t// first write the meta data\n+\tout->column_count = result->types.size();\n+\tout->row_count = result->collection.Count();\n+\tout->rows_changed = 0;\n+\tif (out->row_count > 0 && StatementTypeReturnChanges(result->statement_type)) {\n+\t\t// update total changes\n+\t\tauto row_changes = result->GetValue(0, 0);\n+\t\tif (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {\n+\t\t\tout->rows_changed = row_changes.GetValue<int64_t>();\n+\t\t}\n+\t}\n+\tout->columns = (duckdb_column *)malloc(sizeof(duckdb_column) * out->column_count);\n+\tif (!out->columns) { // LCOV_EXCL_START\n+\t\t// malloc failure\n+\t\treturn DuckDBError;\n+\t} // LCOV_EXCL_STOP\n+\n+\t// zero initialize the columns (so we can cleanly delete it in case a malloc fails)\n+\tmemset(out->columns, 0, sizeof(duckdb_column) * out->column_count);\n+\tfor (idx_t i = 0; i < out->column_count; i++) {\n+\t\tout->columns[i].type = ConvertCPPTypeToC(result->types[i]);\n+\t\tout->columns[i].name = strdup(result->names[i].c_str());\n+\t\tout->columns[i].nullmask = (bool *)malloc(sizeof(bool) * out->row_count);\n+\t\tout->columns[i].data = malloc(GetCTypeSize(out->columns[i].type) * out->row_count);\n+\t\tif (!out->columns[i].nullmask || !out->columns[i].name || !out->columns[i].data) { // LCOV_EXCL_START\n+\t\t\t// malloc failure\n+\t\t\treturn DuckDBError;\n+\t\t} // LCOV_EXCL_STOP\n+\t\t// memset data to 0 for VARCHAR columns for safe deletion later\n+\t\tif (result->types[i].InternalType() == PhysicalType::VARCHAR) {\n+\t\t\tmemset(out->columns[i].data, 0, GetCTypeSize(out->columns[i].type) * out->row_count);\n+\t\t}\n+\t}\n+\t// now write the data\n+\tfor (idx_t col = 0; col < out->column_count; col++) {\n+\t\t// first set the nullmask\n+\t\tidx_t row = 0;\n+\t\tfor (auto &chunk : result->collection.Chunks()) {\n+\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\tout->columns[col].nullmask[row++] = FlatVector::IsNull(chunk->data[col], k);\n+\t\t\t}\n+\t\t}\n+\t\t// then write the data\n+\t\tswitch (result->types[col].id()) {\n+\t\tcase LogicalTypeId::BOOLEAN:\n+\t\t\tWriteData<bool>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::TINYINT:\n+\t\t\tWriteData<int8_t>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::SMALLINT:\n+\t\t\tWriteData<int16_t>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::INTEGER:\n+\t\t\tWriteData<int32_t>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::BIGINT:\n+\t\t\tWriteData<int64_t>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::UTINYINT:\n+\t\t\tWriteData<uint8_t>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::USMALLINT:\n+\t\t\tWriteData<uint16_t>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::UINTEGER:\n+\t\t\tWriteData<uint32_t>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::UBIGINT:\n+\t\t\tWriteData<uint64_t>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::FLOAT:\n+\t\t\tWriteData<float>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::DOUBLE:\n+\t\t\tWriteData<double>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::DATE:\n+\t\t\tWriteData<date_t>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::TIME:\n+\t\t\tWriteData<dtime_t>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::TIMESTAMP:\n+\t\t\tWriteData<timestamp_t>(out, result->collection, col);\n+\t\t\tbreak;\n+\t\tcase LogicalTypeId::VARCHAR: {\n+\t\t\tidx_t row = 0;\n+\t\t\tauto target = (const char **)out->columns[col].data;\n+\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n+\t\t\t\tauto source = FlatVector::GetData<string_t>(chunk->data[col]);\n+\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\t\ttarget[row] = (char *)malloc(source[k].GetSize() + 1);\n+\t\t\t\t\t\tassert(target[row]);\n+\t\t\t\t\t\tmemcpy((void *)target[row], source[k].GetDataUnsafe(), source[k].GetSize());\n+\t\t\t\t\t\tauto write_arr = (char *)target[row];\n+\t\t\t\t\t\twrite_arr[source[k].GetSize()] = '\\0';\n+\t\t\t\t\t}\n+\t\t\t\t\trow++;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase LogicalTypeId::BLOB: {\n+\t\t\tidx_t row = 0;\n+\t\t\tauto target = (duckdb_blob *)out->columns[col].data;\n+\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n+\t\t\t\tauto source = FlatVector::GetData<string_t>(chunk->data[col]);\n+\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\t\ttarget[row].data = (char *)malloc(source[k].GetSize());\n+\t\t\t\t\t\ttarget[row].size = source[k].GetSize();\n+\t\t\t\t\t\tassert(target[row].data);\n+\t\t\t\t\t\tmemcpy((void *)target[row].data, source[k].GetDataUnsafe(), source[k].GetSize());\n+\t\t\t\t\t}\n+\t\t\t\t\trow++;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\tcase LogicalTypeId::TIMESTAMP_SEC: {\n+\t\t\tidx_t row = 0;\n+\t\t\tauto target = (timestamp_t *)out->columns[col].data;\n+\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n+\t\t\t\tauto source = FlatVector::GetData<timestamp_t>(chunk->data[col]);\n+\n+\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\t\tif (result->types[col].id() == LogicalTypeId::TIMESTAMP_NS) {\n+\t\t\t\t\t\t\ttarget[row] = Timestamp::FromEpochNanoSeconds(source[k].value);\n+\t\t\t\t\t\t} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_MS) {\n+\t\t\t\t\t\t\ttarget[row] = Timestamp::FromEpochMs(source[k].value);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tD_ASSERT(result->types[col].id() == LogicalTypeId::TIMESTAMP_SEC);\n+\t\t\t\t\t\t\ttarget[row] = Timestamp::FromEpochSeconds(source[k].value);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\trow++;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase LogicalTypeId::HUGEINT: {\n+\t\t\tidx_t row = 0;\n+\t\t\tauto target = (duckdb_hugeint *)out->columns[col].data;\n+\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n+\t\t\t\tauto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);\n+\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\t\ttarget[row].lower = source[k].lower;\n+\t\t\t\t\t\ttarget[row].upper = source[k].upper;\n+\t\t\t\t\t}\n+\t\t\t\t\trow++;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase LogicalTypeId::INTERVAL: {\n+\t\t\tidx_t row = 0;\n+\t\t\tauto target = (duckdb_interval *)out->columns[col].data;\n+\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n+\t\t\t\tauto source = FlatVector::GetData<interval_t>(chunk->data[col]);\n+\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n+\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n+\t\t\t\t\t\ttarget[row].days = source[k].days;\n+\t\t\t\t\t\ttarget[row].months = source[k].months;\n+\t\t\t\t\t\ttarget[row].micros = source[k].micros;\n+\t\t\t\t\t}\n+\t\t\t\t\trow++;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tdefault: // LCOV_EXCL_START\n+\t\t\t// unsupported type for C API\n+\t\t\tD_ASSERT(0);\n+\t\t\treturn DuckDBError;\n+\t\t} // LCOV_EXCL_STOP\n+\t}\n+\treturn DuckDBSuccess;\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/main/capi/value-c.cpp b/src/main/capi/value-c.cpp\nnew file mode 100644\nindex 000000000000..f879192139e4\n--- /dev/null\n+++ b/src/main/capi/value-c.cpp\n@@ -0,0 +1,273 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+#include \"duckdb/common/types/date.hpp\"\n+#include \"duckdb/common/types/time.hpp\"\n+#include \"duckdb/common/types/timestamp.hpp\"\n+\n+using duckdb::const_data_ptr_t;\n+using duckdb::Date;\n+using duckdb::date_t;\n+using duckdb::dtime_t;\n+using duckdb::hugeint_t;\n+using duckdb::interval_t;\n+using duckdb::LogicalType;\n+using duckdb::string;\n+using duckdb::Time;\n+using duckdb::Timestamp;\n+using duckdb::timestamp_t;\n+using duckdb::Value;\n+\n+template <class T>\n+T UnsafeFetch(duckdb_result *result, idx_t col, idx_t row) {\n+\tD_ASSERT(row < result->row_count);\n+\treturn ((T *)result->columns[col].data)[row];\n+}\n+\n+static Value GetCValue(duckdb_result *result, idx_t col, idx_t row) {\n+\tif (col >= result->column_count) {\n+\t\treturn Value();\n+\t}\n+\tif (row >= result->row_count) {\n+\t\treturn Value();\n+\t}\n+\tif (result->columns[col].nullmask[row]) {\n+\t\treturn Value();\n+\t}\n+\tswitch (result->columns[col].type) {\n+\tcase DUCKDB_TYPE_BOOLEAN:\n+\t\treturn Value::BOOLEAN(UnsafeFetch<bool>(result, col, row));\n+\tcase DUCKDB_TYPE_TINYINT:\n+\t\treturn Value::TINYINT(UnsafeFetch<int8_t>(result, col, row));\n+\tcase DUCKDB_TYPE_SMALLINT:\n+\t\treturn Value::SMALLINT(UnsafeFetch<int16_t>(result, col, row));\n+\tcase DUCKDB_TYPE_INTEGER:\n+\t\treturn Value::INTEGER(UnsafeFetch<int32_t>(result, col, row));\n+\tcase DUCKDB_TYPE_BIGINT:\n+\t\treturn Value::BIGINT(UnsafeFetch<int64_t>(result, col, row));\n+\tcase DUCKDB_TYPE_UTINYINT:\n+\t\treturn Value::TINYINT(UnsafeFetch<uint8_t>(result, col, row));\n+\tcase DUCKDB_TYPE_USMALLINT:\n+\t\treturn Value::SMALLINT(UnsafeFetch<uint16_t>(result, col, row));\n+\tcase DUCKDB_TYPE_UINTEGER:\n+\t\treturn Value::INTEGER(UnsafeFetch<uint32_t>(result, col, row));\n+\tcase DUCKDB_TYPE_UBIGINT:\n+\t\treturn Value::BIGINT(UnsafeFetch<uint64_t>(result, col, row));\n+\tcase DUCKDB_TYPE_FLOAT:\n+\t\treturn Value(UnsafeFetch<float>(result, col, row));\n+\tcase DUCKDB_TYPE_DOUBLE:\n+\t\treturn Value(UnsafeFetch<double>(result, col, row));\n+\tcase DUCKDB_TYPE_DATE: {\n+\t\tauto date = UnsafeFetch<duckdb_date>(result, col, row);\n+\t\treturn Value::DATE(date_t(date.days));\n+\t}\n+\tcase DUCKDB_TYPE_TIME: {\n+\t\tauto time = UnsafeFetch<duckdb_time>(result, col, row);\n+\t\treturn Value::TIME(dtime_t(time.micros));\n+\t}\n+\tcase DUCKDB_TYPE_TIMESTAMP_NS:\n+\tcase DUCKDB_TYPE_TIMESTAMP_MS:\n+\tcase DUCKDB_TYPE_TIMESTAMP_S:\n+\tcase DUCKDB_TYPE_TIMESTAMP: {\n+\t\tauto timestamp = UnsafeFetch<duckdb_timestamp>(result, col, row);\n+\t\treturn Value::TIMESTAMP(timestamp_t(timestamp.micros));\n+\t}\n+\tcase DUCKDB_TYPE_HUGEINT: {\n+\t\thugeint_t val;\n+\t\tauto hugeint = UnsafeFetch<duckdb_hugeint>(result, col, row);\n+\t\tval.lower = hugeint.lower;\n+\t\tval.upper = hugeint.upper;\n+\t\treturn Value::HUGEINT(val);\n+\t}\n+\tcase DUCKDB_TYPE_INTERVAL: {\n+\t\tinterval_t val;\n+\t\tauto interval = UnsafeFetch<duckdb_interval>(result, col, row);\n+\t\tval.days = interval.days;\n+\t\tval.months = interval.months;\n+\t\tval.micros = interval.micros;\n+\t\treturn Value::INTERVAL(val);\n+\t}\n+\tcase DUCKDB_TYPE_VARCHAR:\n+\t\treturn Value(string(UnsafeFetch<const char *>(result, col, row)));\n+\tcase DUCKDB_TYPE_BLOB: {\n+\t\tauto blob = UnsafeFetch<duckdb_blob>(result, col, row);\n+\t\treturn Value::BLOB((const_data_ptr_t)blob.data, blob.size);\n+\t}\n+\tdefault: // LCOV_EXCL_START\n+\t\t// invalid type for C to C++ conversion\n+\t\tD_ASSERT(0);\n+\t\treturn Value();\n+\t} // LCOV_EXCL_STOP\n+}\n+\n+const char *duckdb_column_name(duckdb_result *result, idx_t col) {\n+\tif (!result || col >= result->column_count) {\n+\t\treturn nullptr;\n+\t}\n+\treturn result->columns[col].name;\n+}\n+\n+bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tif (val.is_null) {\n+\t\treturn false;\n+\t} else {\n+\t\treturn val.GetValue<bool>();\n+\t}\n+}\n+\n+int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tif (val.is_null) {\n+\t\treturn 0;\n+\t} else {\n+\t\treturn val.GetValue<int8_t>();\n+\t}\n+}\n+\n+int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tif (val.is_null) {\n+\t\treturn 0;\n+\t} else {\n+\t\treturn val.GetValue<int16_t>();\n+\t}\n+}\n+\n+int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tif (val.is_null) {\n+\t\treturn 0;\n+\t} else {\n+\t\treturn val.GetValue<int32_t>();\n+\t}\n+}\n+\n+int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tif (val.is_null) {\n+\t\treturn 0;\n+\t} else {\n+\t\treturn val.GetValue<int64_t>();\n+\t}\n+}\n+\n+uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tif (val.is_null) {\n+\t\treturn 0;\n+\t} else {\n+\t\treturn val.GetValue<uint8_t>();\n+\t}\n+}\n+\n+uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tif (val.is_null) {\n+\t\treturn 0;\n+\t} else {\n+\t\treturn val.GetValue<uint16_t>();\n+\t}\n+}\n+\n+uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tif (val.is_null) {\n+\t\treturn 0;\n+\t} else {\n+\t\treturn val.GetValue<uint32_t>();\n+\t}\n+}\n+\n+uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tif (val.is_null) {\n+\t\treturn 0;\n+\t} else {\n+\t\treturn val.GetValue<uint64_t>();\n+\t}\n+}\n+\n+float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tif (val.is_null) {\n+\t\treturn 0.0;\n+\t} else {\n+\t\treturn val.GetValue<float>();\n+\t}\n+}\n+\n+double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tif (val.is_null) {\n+\t\treturn 0.0;\n+\t} else {\n+\t\treturn val.GetValue<double>();\n+\t}\n+}\n+\n+duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tduckdb_date date;\n+\tif (val.is_null) {\n+\t\tdate.days = 0;\n+\t} else {\n+\t\tdate.days = val.GetValue<date_t>().days;\n+\t}\n+\treturn date;\n+}\n+\n+duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tduckdb_time time;\n+\tif (val.is_null) {\n+\t\ttime.micros = 0;\n+\t} else {\n+\t\ttime.micros = val.GetValue<dtime_t>().micros;\n+\t}\n+\treturn time;\n+}\n+\n+duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tduckdb_timestamp ts;\n+\tif (val.is_null) {\n+\t\tts.micros = 0;\n+\t} else {\n+\t\tts.micros = val.GetValue<timestamp_t>().value;\n+\t}\n+\treturn ts;\n+}\n+\n+duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\tduckdb_interval interval;\n+\tif (val.is_null) {\n+\t\tinterval.months = 0;\n+\t\tinterval.days = 0;\n+\t\tinterval.micros = 0;\n+\t} else {\n+\t\tauto dinterval = val.GetValue<interval_t>();\n+\t\tinterval.months = dinterval.months;\n+\t\tinterval.days = dinterval.days;\n+\t\tinterval.micros = dinterval.micros;\n+\t}\n+\treturn interval;\n+}\n+\n+char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row) {\n+\tValue val = GetCValue(result, col, row);\n+\treturn strdup(val.ToString().c_str());\n+}\n+\n+duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row) {\n+\tduckdb_blob blob;\n+\tValue val = GetCValue(result, col, row).CastAs(LogicalType::BLOB);\n+\tif (val.is_null) {\n+\t\tblob.data = nullptr;\n+\t\tblob.size = 0;\n+\t} else {\n+\t\tblob.data = malloc(val.str_value.size());\n+\t\tmemcpy((void *)blob.data, val.str_value.c_str(), val.str_value.size());\n+\t\tblob.size = val.str_value.size();\n+\t}\n+\treturn blob;\n+}\ndiff --git a/src/main/duckdb-c.cpp b/src/main/duckdb-c.cpp\ndeleted file mode 100644\nindex ed6592099a21..000000000000\n--- a/src/main/duckdb-c.cpp\n+++ /dev/null\n@@ -1,1177 +0,0 @@\n-#include \"duckdb/common/types/date.hpp\"\n-#include \"duckdb/common/types/time.hpp\"\n-#include \"duckdb/common/types/timestamp.hpp\"\n-#include \"duckdb/common/arrow.hpp\"\n-#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n-#include \"duckdb/main/appender.hpp\"\n-#include \"duckdb/main/config.hpp\"\n-\n-#include \"duckdb.h\"\n-#include \"duckdb.hpp\"\n-\n-#include <cstring>\n-#include <cassert>\n-\n-#ifdef _WIN32\n-#define strdup _strdup\n-#endif\n-\n-#ifdef GetCValue\n-#undef GetCValue\n-#endif\n-\n-using namespace duckdb;\n-\n-static duckdb_type ConvertCPPTypeToC(LogicalType type);\n-static idx_t GetCTypeSize(duckdb_type type);\n-namespace duckdb {\n-struct DatabaseData {\n-\tDatabaseData() : database(nullptr) {\n-\t}\n-\t~DatabaseData() {\n-\t\tif (database) {\n-\t\t\tdelete database;\n-\t\t}\n-\t}\n-\n-\tDuckDB *database;\n-};\n-} // namespace duckdb\n-\n-// config\n-duckdb_state duckdb_create_config(duckdb_config *out_config) {\n-\tif (!out_config) {\n-\t\treturn DuckDBError;\n-\t}\n-\tDBConfig *config;\n-\ttry {\n-\t\tconfig = new DBConfig();\n-\t} catch (...) { // LCOV_EXCL_START\n-\t\treturn DuckDBError;\n-\t} // LCOV_EXCL_STOP\n-\t*out_config = (duckdb_config)config;\n-\treturn DuckDBSuccess;\n-}\n-\n-size_t duckdb_config_count() {\n-\treturn DBConfig::GetOptionCount();\n-}\n-\n-duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description) {\n-\tauto option = DBConfig::GetOptionByIndex(index);\n-\tif (!option) {\n-\t\treturn DuckDBError;\n-\t}\n-\tif (out_name) {\n-\t\t*out_name = option->name;\n-\t}\n-\tif (out_description) {\n-\t\t*out_description = option->description;\n-\t}\n-\treturn DuckDBSuccess;\n-}\n-\n-duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option) {\n-\tif (!config || !name || !option) {\n-\t\treturn DuckDBError;\n-\t}\n-\tauto config_option = DBConfig::GetOptionByName(name);\n-\tif (!config_option) {\n-\t\treturn DuckDBError;\n-\t}\n-\ttry {\n-\t\tauto db_config = (DBConfig *)config;\n-\t\tdb_config->SetOption(*config_option, Value(option));\n-\t} catch (...) {\n-\t\treturn DuckDBError;\n-\t}\n-\treturn DuckDBSuccess;\n-}\n-\n-void duckdb_destroy_config(duckdb_config *config) {\n-\tif (!config) {\n-\t\treturn;\n-\t}\n-\tif (*config) {\n-\t\tauto db_config = (DBConfig *)*config;\n-\t\tdelete db_config;\n-\t\t*config = nullptr;\n-\t}\n-}\n-\n-duckdb_state duckdb_open_ext(const char *path, duckdb_database *out, duckdb_config config, char **error) {\n-\tauto wrapper = new DatabaseData();\n-\ttry {\n-\t\tauto db_config = (DBConfig *)config;\n-\t\twrapper->database = new DuckDB(path, db_config);\n-\t} catch (std::exception &ex) {\n-\t\tif (error) {\n-\t\t\t*error = strdup(ex.what());\n-\t\t}\n-\t\tdelete wrapper;\n-\t\treturn DuckDBError;\n-\t} catch (...) { // LCOV_EXCL_START\n-\t\tif (error) {\n-\t\t\t*error = strdup(\"Unknown error\");\n-\t\t}\n-\t\tdelete wrapper;\n-\t\treturn DuckDBError;\n-\t} // LCOV_EXCL_STOP\n-\t*out = (duckdb_database)wrapper;\n-\treturn DuckDBSuccess;\n-}\n-\n-duckdb_state duckdb_open(const char *path, duckdb_database *out) {\n-\treturn duckdb_open_ext(path, out, nullptr, nullptr);\n-}\n-\n-void duckdb_close(duckdb_database *database) {\n-\tif (*database) {\n-\t\tauto wrapper = (DatabaseData *)*database;\n-\t\tdelete wrapper;\n-\t\t*database = nullptr;\n-\t}\n-}\n-\n-duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out) {\n-\tauto wrapper = (DatabaseData *)database;\n-\tConnection *connection;\n-\ttry {\n-\t\tconnection = new Connection(*wrapper->database);\n-\t} catch (...) {\n-\t\treturn DuckDBError;\n-\t}\n-\t*out = (duckdb_connection)connection;\n-\treturn DuckDBSuccess;\n-}\n-\n-void duckdb_disconnect(duckdb_connection *connection) {\n-\tif (*connection) {\n-\t\tConnection *conn = (Connection *)*connection;\n-\t\tdelete conn;\n-\t\t*connection = nullptr;\n-\t}\n-}\n-\n-template <class T>\n-void WriteData(duckdb_result *out, ChunkCollection &source, idx_t col) {\n-\tidx_t row = 0;\n-\tauto target = (T *)out->columns[col].data;\n-\tfor (auto &chunk : source.Chunks()) {\n-\t\tauto source = FlatVector::GetData<T>(chunk->data[col]);\n-\t\tauto &mask = FlatVector::Validity(chunk->data[col]);\n-\n-\t\tfor (idx_t k = 0; k < chunk->size(); k++, row++) {\n-\t\t\tif (!mask.RowIsValid(k)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\ttarget[row] = source[k];\n-\t\t}\n-\t}\n-}\n-\n-static duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out) {\n-\tD_ASSERT(result);\n-\tif (!out) {\n-\t\t// no result to write to, only return the status\n-\t\treturn result->success ? DuckDBSuccess : DuckDBError;\n-\t}\n-\tout->error_message = nullptr;\n-\tif (!result->success) {\n-\t\t// write the error message\n-\t\tout->error_message = strdup(result->error.c_str());\n-\t\treturn DuckDBError;\n-\t}\n-\t// copy the data\n-\t// first write the meta data\n-\tout->column_count = result->types.size();\n-\tout->row_count = result->collection.Count();\n-\tout->rows_changed = 0;\n-\tif (out->row_count > 0 && StatementTypeReturnChanges(result->statement_type)) {\n-\t\t// update total changes\n-\t\tauto row_changes = result->GetValue(0, 0);\n-\t\tif (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {\n-\t\t\tout->rows_changed = row_changes.GetValue<int64_t>();\n-\t\t}\n-\t}\n-\tout->columns = (duckdb_column *)malloc(sizeof(duckdb_column) * out->column_count);\n-\tif (!out->columns) { // LCOV_EXCL_START\n-\t\t// malloc failure\n-\t\treturn DuckDBError;\n-\t} // LCOV_EXCL_STOP\n-\n-\t// zero initialize the columns (so we can cleanly delete it in case a malloc fails)\n-\tmemset(out->columns, 0, sizeof(duckdb_column) * out->column_count);\n-\tfor (idx_t i = 0; i < out->column_count; i++) {\n-\t\tout->columns[i].type = ConvertCPPTypeToC(result->types[i]);\n-\t\tout->columns[i].name = strdup(result->names[i].c_str());\n-\t\tout->columns[i].nullmask = (bool *)malloc(sizeof(bool) * out->row_count);\n-\t\tout->columns[i].data = malloc(GetCTypeSize(out->columns[i].type) * out->row_count);\n-\t\tif (!out->columns[i].nullmask || !out->columns[i].name || !out->columns[i].data) { // LCOV_EXCL_START\n-\t\t\t// malloc failure\n-\t\t\treturn DuckDBError;\n-\t\t} // LCOV_EXCL_STOP\n-\t\t// memset data to 0 for VARCHAR columns for safe deletion later\n-\t\tif (result->types[i].InternalType() == PhysicalType::VARCHAR) {\n-\t\t\tmemset(out->columns[i].data, 0, GetCTypeSize(out->columns[i].type) * out->row_count);\n-\t\t}\n-\t}\n-\t// now write the data\n-\tfor (idx_t col = 0; col < out->column_count; col++) {\n-\t\t// first set the nullmask\n-\t\tidx_t row = 0;\n-\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\tout->columns[col].nullmask[row++] = FlatVector::IsNull(chunk->data[col], k);\n-\t\t\t}\n-\t\t}\n-\t\t// then write the data\n-\t\tswitch (result->types[col].id()) {\n-\t\tcase LogicalTypeId::BOOLEAN:\n-\t\t\tWriteData<bool>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::TINYINT:\n-\t\t\tWriteData<int8_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::SMALLINT:\n-\t\t\tWriteData<int16_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::INTEGER:\n-\t\t\tWriteData<int32_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::BIGINT:\n-\t\t\tWriteData<int64_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::UTINYINT:\n-\t\t\tWriteData<uint8_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::USMALLINT:\n-\t\t\tWriteData<uint16_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::UINTEGER:\n-\t\t\tWriteData<uint32_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::UBIGINT:\n-\t\t\tWriteData<uint64_t>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::FLOAT:\n-\t\t\tWriteData<float>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::DOUBLE:\n-\t\t\tWriteData<double>(out, result->collection, col);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::VARCHAR: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (const char **)out->columns[col].data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<string_t>(chunk->data[col]);\n-\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\ttarget[row] = (char *)malloc(source[k].GetSize() + 1);\n-\t\t\t\t\t\tassert(target[row]);\n-\t\t\t\t\t\tmemcpy((void *)target[row], source[k].GetDataUnsafe(), source[k].GetSize());\n-\t\t\t\t\t\tauto write_arr = (char *)target[row];\n-\t\t\t\t\t\twrite_arr[source[k].GetSize()] = '\\0';\n-\t\t\t\t\t}\n-\t\t\t\t\trow++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase LogicalTypeId::BLOB: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (duckdb_blob *)out->columns[col].data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<string_t>(chunk->data[col]);\n-\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\ttarget[row].data = (char *)malloc(source[k].GetSize());\n-\t\t\t\t\t\ttarget[row].size = source[k].GetSize();\n-\t\t\t\t\t\tassert(target[row].data);\n-\t\t\t\t\t\tmemcpy((void *)target[row].data, source[k].GetDataUnsafe(), source[k].GetSize());\n-\t\t\t\t\t}\n-\t\t\t\t\trow++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase LogicalTypeId::DATE: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (duckdb_date *)out->columns[col].data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<date_t>(chunk->data[col]);\n-\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\tint32_t year, month, day;\n-\t\t\t\t\t\tDate::Convert(source[k], year, month, day);\n-\t\t\t\t\t\ttarget[row].year = year;\n-\t\t\t\t\t\ttarget[row].month = month;\n-\t\t\t\t\t\ttarget[row].day = day;\n-\t\t\t\t\t}\n-\t\t\t\t\trow++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase LogicalTypeId::TIME: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (duckdb_time *)out->columns[col].data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<dtime_t>(chunk->data[col]);\n-\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\tint32_t hour, min, sec, micros;\n-\t\t\t\t\t\tTime::Convert(source[k], hour, min, sec, micros);\n-\t\t\t\t\t\ttarget[row].hour = hour;\n-\t\t\t\t\t\ttarget[row].min = min;\n-\t\t\t\t\t\ttarget[row].sec = sec;\n-\t\t\t\t\t\ttarget[row].micros = micros;\n-\t\t\t\t\t}\n-\t\t\t\t\trow++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase LogicalTypeId::TIMESTAMP:\n-\t\tcase LogicalTypeId::TIMESTAMP_NS:\n-\t\tcase LogicalTypeId::TIMESTAMP_MS:\n-\t\tcase LogicalTypeId::TIMESTAMP_SEC: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (duckdb_timestamp *)out->columns[col].data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<timestamp_t>(chunk->data[col]);\n-\n-\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\tdate_t date;\n-\t\t\t\t\t\tdtime_t time;\n-\t\t\t\t\t\tauto source_value = source[k];\n-\t\t\t\t\t\tif (result->types[col].id() == LogicalTypeId::TIMESTAMP_NS) {\n-\t\t\t\t\t\t\tsource_value = Timestamp::FromEpochNanoSeconds(source[k].value);\n-\t\t\t\t\t\t} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_MS) {\n-\t\t\t\t\t\t\tsource_value = Timestamp::FromEpochMs(source[k].value);\n-\t\t\t\t\t\t} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_SEC) {\n-\t\t\t\t\t\t\tsource_value = Timestamp::FromEpochSeconds(source[k].value);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tTimestamp::Convert(source_value, date, time);\n-\n-\t\t\t\t\t\tint32_t year, month, day;\n-\t\t\t\t\t\tDate::Convert(date, year, month, day);\n-\n-\t\t\t\t\t\tint32_t hour, min, sec, micros;\n-\t\t\t\t\t\tTime::Convert(time, hour, min, sec, micros);\n-\n-\t\t\t\t\t\ttarget[row].date.year = year;\n-\t\t\t\t\t\ttarget[row].date.month = month;\n-\t\t\t\t\t\ttarget[row].date.day = day;\n-\t\t\t\t\t\ttarget[row].time.hour = hour;\n-\t\t\t\t\t\ttarget[row].time.min = min;\n-\t\t\t\t\t\ttarget[row].time.sec = sec;\n-\t\t\t\t\t\ttarget[row].time.micros = micros;\n-\t\t\t\t\t}\n-\t\t\t\t\trow++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase LogicalTypeId::HUGEINT: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (duckdb_hugeint *)out->columns[col].data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);\n-\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\ttarget[row].lower = source[k].lower;\n-\t\t\t\t\t\ttarget[row].upper = source[k].upper;\n-\t\t\t\t\t}\n-\t\t\t\t\trow++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase LogicalTypeId::INTERVAL: {\n-\t\t\tidx_t row = 0;\n-\t\t\tauto target = (duckdb_interval *)out->columns[col].data;\n-\t\t\tfor (auto &chunk : result->collection.Chunks()) {\n-\t\t\t\tauto source = FlatVector::GetData<interval_t>(chunk->data[col]);\n-\t\t\t\tfor (idx_t k = 0; k < chunk->size(); k++) {\n-\t\t\t\t\tif (!FlatVector::IsNull(chunk->data[col], k)) {\n-\t\t\t\t\t\ttarget[row].days = source[k].days;\n-\t\t\t\t\t\ttarget[row].months = source[k].months;\n-\t\t\t\t\t\ttarget[row].micros = source[k].micros;\n-\t\t\t\t\t}\n-\t\t\t\t\trow++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tdefault:\n-\t\t\t// unsupported type for C API\n-\t\t\tD_ASSERT(0);\n-\t\t\treturn DuckDBError;\n-\t\t}\n-\t}\n-\treturn DuckDBSuccess;\n-}\n-\n-duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out) {\n-\tConnection *conn = (Connection *)connection;\n-\tauto result = conn->Query(query);\n-\treturn duckdb_translate_result(result.get(), out);\n-}\n-\n-namespace duckdb {\n-struct ArrowResultWrapper {\n-\tArrowResultWrapper() : result(nullptr), current_chunk(nullptr) {\n-\t}\n-\t~ArrowResultWrapper() {\n-\t}\n-\tunique_ptr<MaterializedQueryResult> result;\n-\tunique_ptr<DataChunk> current_chunk;\n-};\n-} // namespace duckdb\n-\n-duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result) {\n-\tConnection *conn = (Connection *)connection;\n-\tauto wrapper = new ArrowResultWrapper();\n-\twrapper->result = conn->Query(query);\n-\t*out_result = (duckdb_arrow)wrapper;\n-\treturn wrapper->result->success ? DuckDBSuccess : DuckDBError;\n-}\n-\n-duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema) {\n-\tif (!out_schema) {\n-\t\treturn DuckDBSuccess;\n-\t}\n-\tauto wrapper = (ArrowResultWrapper *)result;\n-\twrapper->result->ToArrowSchema((ArrowSchema *)*out_schema);\n-\treturn DuckDBSuccess;\n-}\n-\n-duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array) {\n-\tif (!out_array) {\n-\t\treturn DuckDBSuccess;\n-\t}\n-\tauto wrapper = (ArrowResultWrapper *)result;\n-\tauto success = wrapper->result->TryFetch(wrapper->current_chunk, wrapper->result->error);\n-\tif (!success) {\n-\t\treturn DuckDBError;\n-\t}\n-\tif (!wrapper->current_chunk || wrapper->current_chunk->size() == 0) {\n-\t\treturn DuckDBSuccess;\n-\t}\n-\twrapper->current_chunk->ToArrowArray((ArrowArray *)*out_array);\n-\treturn DuckDBSuccess;\n-}\n-\n-idx_t duckdb_arrow_row_count(duckdb_arrow result) {\n-\tauto wrapper = (ArrowResultWrapper *)result;\n-\treturn wrapper->result->collection.Count();\n-}\n-\n-idx_t duckdb_arrow_column_count(duckdb_arrow result) {\n-\tauto wrapper = (ArrowResultWrapper *)result;\n-\treturn wrapper->result->types.size();\n-}\n-\n-idx_t duckdb_arrow_rows_changed(duckdb_arrow result) {\n-\tauto wrapper = (ArrowResultWrapper *)result;\n-\tidx_t rows_changed = 0;\n-\tidx_t row_count = wrapper->result->collection.Count();\n-\tif (row_count > 0 && StatementTypeReturnChanges(wrapper->result->statement_type)) {\n-\t\tauto row_changes = wrapper->result->GetValue(0, 0);\n-\t\tif (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {\n-\t\t\trows_changed = row_changes.GetValue<int64_t>();\n-\t\t}\n-\t}\n-\treturn rows_changed;\n-}\n-\n-const char *duckdb_query_arrow_error(duckdb_arrow result) {\n-\tauto wrapper = (ArrowResultWrapper *)result;\n-\treturn strdup(wrapper->result->error.c_str());\n-}\n-\n-void duckdb_destroy_arrow(duckdb_arrow *result) {\n-\tif (*result) {\n-\t\tauto wrapper = (ArrowResultWrapper *)*result;\n-\t\tdelete wrapper;\n-\t\t*result = nullptr;\n-\t}\n-}\n-\n-static void duckdb_destroy_column(duckdb_column column, idx_t count) {\n-\tif (column.data) {\n-\t\tif (column.type == DUCKDB_TYPE_VARCHAR) {\n-\t\t\t// varchar, delete individual strings\n-\t\t\tauto data = (char **)column.data;\n-\t\t\tfor (idx_t i = 0; i < count; i++) {\n-\t\t\t\tif (data[i]) {\n-\t\t\t\t\tfree(data[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else if (column.type == DUCKDB_TYPE_BLOB) {\n-\t\t\t// blob, delete individual blobs\n-\t\t\tauto data = (duckdb_blob *)column.data;\n-\t\t\tfor (idx_t i = 0; i < count; i++) {\n-\t\t\t\tif (data[i].data) {\n-\t\t\t\t\tfree((void *)data[i].data);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tfree(column.data);\n-\t}\n-\tif (column.nullmask) {\n-\t\tfree(column.nullmask);\n-\t}\n-\tif (column.name) {\n-\t\tfree(column.name);\n-\t}\n-}\n-\n-void duckdb_destroy_result(duckdb_result *result) {\n-\tif (result->error_message) {\n-\t\tfree(result->error_message);\n-\t}\n-\tif (result->columns) {\n-\t\tfor (idx_t i = 0; i < result->column_count; i++) {\n-\t\t\tduckdb_destroy_column(result->columns[i], result->row_count);\n-\t\t}\n-\t\tfree(result->columns);\n-\t}\n-\tmemset(result, 0, sizeof(duckdb_result));\n-}\n-namespace duckdb {\n-struct PreparedStatementWrapper {\n-\tPreparedStatementWrapper() : statement(nullptr) {\n-\t}\n-\t~PreparedStatementWrapper() {\n-\t}\n-\tunique_ptr<PreparedStatement> statement;\n-\tvector<Value> values;\n-};\n-} // namespace duckdb\n-duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,\n-                            duckdb_prepared_statement *out_prepared_statement) {\n-\tif (!connection || !query) {\n-\t\treturn DuckDBError;\n-\t}\n-\tauto wrapper = new PreparedStatementWrapper();\n-\tConnection *conn = (Connection *)connection;\n-\twrapper->statement = conn->Prepare(query);\n-\t*out_prepared_statement = (duckdb_prepared_statement)wrapper;\n-\treturn wrapper->statement->success ? DuckDBSuccess : DuckDBError;\n-}\n-\n-const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement) {\n-\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n-\tif (!wrapper || !wrapper->statement || wrapper->statement->success) {\n-\t\treturn nullptr;\n-\t}\n-\treturn strdup(wrapper->statement->error.c_str());\n-}\n-\n-duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out) {\n-\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n-\tif (!wrapper || !wrapper->statement || !wrapper->statement->success) {\n-\t\treturn DuckDBError;\n-\t}\n-\t*nparams_out = wrapper->statement->n_param;\n-\treturn DuckDBSuccess;\n-}\n-\n-static duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_statement, idx_t param_idx, Value val) {\n-\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n-\tif (!wrapper || !wrapper->statement || !wrapper->statement->success) {\n-\t\treturn DuckDBError;\n-\t}\n-\tif (param_idx > wrapper->statement->n_param) {\n-\t\treturn DuckDBError;\n-\t}\n-\tif (param_idx > wrapper->values.size()) {\n-\t\twrapper->values.resize(param_idx);\n-\t}\n-\twrapper->values[param_idx - 1] = val;\n-\treturn DuckDBSuccess;\n-}\n-\n-duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value::BOOLEAN(val));\n-}\n-\n-duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value::TINYINT(val));\n-}\n-\n-duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value::SMALLINT(val));\n-}\n-\n-duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value::INTEGER(val));\n-}\n-\n-duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value::BIGINT(val));\n-}\n-\n-duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value::UTINYINT(val));\n-}\n-\n-duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value::USMALLINT(val));\n-}\n-\n-duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value::UINTEGER(val));\n-}\n-\n-duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value::UBIGINT(val));\n-}\n-\n-duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value(val));\n-}\n-\n-duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value(val));\n-}\n-\n-duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value(val));\n-}\n-\n-duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val,\n-                                        idx_t length) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value(string(val, length)));\n-}\n-\n-duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx, const void *data,\n-                              idx_t length) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value::BLOB((const_data_ptr_t)data, length));\n-}\n-\n-duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx) {\n-\treturn duckdb_bind_value(prepared_statement, param_idx, Value());\n-}\n-\n-duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement, duckdb_result *out_result) {\n-\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n-\tif (!wrapper || !wrapper->statement || !wrapper->statement->success) {\n-\t\treturn DuckDBError;\n-\t}\n-\tauto result = wrapper->statement->Execute(wrapper->values, false);\n-\tD_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);\n-\tauto mat_res = (MaterializedQueryResult *)result.get();\n-\treturn duckdb_translate_result(mat_res, out_result);\n-}\n-\n-duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement, duckdb_arrow *out_result) {\n-\tauto wrapper = (PreparedStatementWrapper *)prepared_statement;\n-\tif (!wrapper || !wrapper->statement || !wrapper->statement->success) {\n-\t\treturn DuckDBError;\n-\t}\n-\tauto arrow_wrapper = new ArrowResultWrapper();\n-\tauto result = wrapper->statement->Execute(wrapper->values, false);\n-\tD_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);\n-\tarrow_wrapper->result =\n-\t    unique_ptr<MaterializedQueryResult>(static_cast<MaterializedQueryResult *>(result.release()));\n-\t*out_result = (duckdb_arrow)arrow_wrapper;\n-\treturn arrow_wrapper->result->success ? DuckDBSuccess : DuckDBError;\n-}\n-\n-void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement) {\n-\tif (!prepared_statement) {\n-\t\treturn;\n-\t}\n-\tauto wrapper = (PreparedStatementWrapper *)*prepared_statement;\n-\tif (wrapper) {\n-\t\tdelete wrapper;\n-\t}\n-\t*prepared_statement = nullptr;\n-}\n-\n-duckdb_type ConvertCPPTypeToC(LogicalType sql_type) {\n-\tswitch (sql_type.id()) {\n-\tcase LogicalTypeId::BOOLEAN:\n-\t\treturn DUCKDB_TYPE_BOOLEAN;\n-\tcase LogicalTypeId::TINYINT:\n-\t\treturn DUCKDB_TYPE_TINYINT;\n-\tcase LogicalTypeId::SMALLINT:\n-\t\treturn DUCKDB_TYPE_SMALLINT;\n-\tcase LogicalTypeId::INTEGER:\n-\t\treturn DUCKDB_TYPE_INTEGER;\n-\tcase LogicalTypeId::BIGINT:\n-\t\treturn DUCKDB_TYPE_BIGINT;\n-\tcase LogicalTypeId::UTINYINT:\n-\t\treturn DUCKDB_TYPE_UTINYINT;\n-\tcase LogicalTypeId::USMALLINT:\n-\t\treturn DUCKDB_TYPE_USMALLINT;\n-\tcase LogicalTypeId::UINTEGER:\n-\t\treturn DUCKDB_TYPE_UINTEGER;\n-\tcase LogicalTypeId::UBIGINT:\n-\t\treturn DUCKDB_TYPE_UBIGINT;\n-\tcase LogicalTypeId::HUGEINT:\n-\t\treturn DUCKDB_TYPE_HUGEINT;\n-\tcase LogicalTypeId::FLOAT:\n-\t\treturn DUCKDB_TYPE_FLOAT;\n-\tcase LogicalTypeId::DOUBLE:\n-\t\treturn DUCKDB_TYPE_DOUBLE;\n-\tcase LogicalTypeId::TIMESTAMP:\n-\t\treturn DUCKDB_TYPE_TIMESTAMP;\n-\tcase LogicalTypeId::TIMESTAMP_SEC:\n-\t\treturn DUCKDB_TYPE_TIMESTAMP_S;\n-\tcase LogicalTypeId::TIMESTAMP_MS:\n-\t\treturn DUCKDB_TYPE_TIMESTAMP_MS;\n-\tcase LogicalTypeId::TIMESTAMP_NS:\n-\t\treturn DUCKDB_TYPE_TIMESTAMP_NS;\n-\tcase LogicalTypeId::DATE:\n-\t\treturn DUCKDB_TYPE_DATE;\n-\tcase LogicalTypeId::TIME:\n-\t\treturn DUCKDB_TYPE_TIME;\n-\tcase LogicalTypeId::VARCHAR:\n-\t\treturn DUCKDB_TYPE_VARCHAR;\n-\tcase LogicalTypeId::BLOB:\n-\t\treturn DUCKDB_TYPE_BLOB;\n-\tcase LogicalTypeId::INTERVAL:\n-\t\treturn DUCKDB_TYPE_INTERVAL;\n-\tdefault:\n-\t\tD_ASSERT(0);\n-\t\treturn DUCKDB_TYPE_INVALID;\n-\t}\n-}\n-\n-idx_t GetCTypeSize(duckdb_type type) {\n-\tswitch (type) {\n-\tcase DUCKDB_TYPE_BOOLEAN:\n-\t\treturn sizeof(bool);\n-\tcase DUCKDB_TYPE_TINYINT:\n-\t\treturn sizeof(int8_t);\n-\tcase DUCKDB_TYPE_SMALLINT:\n-\t\treturn sizeof(int16_t);\n-\tcase DUCKDB_TYPE_INTEGER:\n-\t\treturn sizeof(int32_t);\n-\tcase DUCKDB_TYPE_BIGINT:\n-\t\treturn sizeof(int64_t);\n-\tcase DUCKDB_TYPE_UTINYINT:\n-\t\treturn sizeof(uint8_t);\n-\tcase DUCKDB_TYPE_USMALLINT:\n-\t\treturn sizeof(uint16_t);\n-\tcase DUCKDB_TYPE_UINTEGER:\n-\t\treturn sizeof(uint32_t);\n-\tcase DUCKDB_TYPE_UBIGINT:\n-\t\treturn sizeof(uint64_t);\n-\tcase DUCKDB_TYPE_HUGEINT:\n-\t\treturn sizeof(duckdb_hugeint);\n-\tcase DUCKDB_TYPE_FLOAT:\n-\t\treturn sizeof(float);\n-\tcase DUCKDB_TYPE_DOUBLE:\n-\t\treturn sizeof(double);\n-\tcase DUCKDB_TYPE_DATE:\n-\t\treturn sizeof(duckdb_date);\n-\tcase DUCKDB_TYPE_TIME:\n-\t\treturn sizeof(duckdb_time);\n-\tcase DUCKDB_TYPE_TIMESTAMP:\n-\tcase DUCKDB_TYPE_TIMESTAMP_NS:\n-\tcase DUCKDB_TYPE_TIMESTAMP_MS:\n-\tcase DUCKDB_TYPE_TIMESTAMP_S:\n-\t\treturn sizeof(duckdb_timestamp);\n-\tcase DUCKDB_TYPE_VARCHAR:\n-\t\treturn sizeof(const char *);\n-\tcase DUCKDB_TYPE_BLOB:\n-\t\treturn sizeof(duckdb_blob);\n-\tcase DUCKDB_TYPE_INTERVAL:\n-\t\treturn sizeof(duckdb_interval);\n-\tdefault:\n-\t\t// unsupported type\n-\t\tD_ASSERT(0);\n-\t\treturn sizeof(const char *);\n-\t}\n-}\n-\n-template <class T>\n-T UnsafeFetch(duckdb_result *result, idx_t col, idx_t row) {\n-\tD_ASSERT(row < result->row_count);\n-\treturn ((T *)result->columns[col].data)[row];\n-}\n-\n-static Value GetCValue(duckdb_result *result, idx_t col, idx_t row) {\n-\tif (col >= result->column_count) {\n-\t\treturn Value();\n-\t}\n-\tif (row >= result->row_count) {\n-\t\treturn Value();\n-\t}\n-\tif (result->columns[col].nullmask[row]) {\n-\t\treturn Value();\n-\t}\n-\tswitch (result->columns[col].type) {\n-\tcase DUCKDB_TYPE_BOOLEAN:\n-\t\treturn Value::BOOLEAN(UnsafeFetch<bool>(result, col, row));\n-\tcase DUCKDB_TYPE_TINYINT:\n-\t\treturn Value::TINYINT(UnsafeFetch<int8_t>(result, col, row));\n-\tcase DUCKDB_TYPE_SMALLINT:\n-\t\treturn Value::SMALLINT(UnsafeFetch<int16_t>(result, col, row));\n-\tcase DUCKDB_TYPE_INTEGER:\n-\t\treturn Value::INTEGER(UnsafeFetch<int32_t>(result, col, row));\n-\tcase DUCKDB_TYPE_BIGINT:\n-\t\treturn Value::BIGINT(UnsafeFetch<int64_t>(result, col, row));\n-\tcase DUCKDB_TYPE_UTINYINT:\n-\t\treturn Value::TINYINT(UnsafeFetch<uint8_t>(result, col, row));\n-\tcase DUCKDB_TYPE_USMALLINT:\n-\t\treturn Value::SMALLINT(UnsafeFetch<uint16_t>(result, col, row));\n-\tcase DUCKDB_TYPE_UINTEGER:\n-\t\treturn Value::INTEGER(UnsafeFetch<uint32_t>(result, col, row));\n-\tcase DUCKDB_TYPE_UBIGINT:\n-\t\treturn Value::BIGINT(UnsafeFetch<uint64_t>(result, col, row));\n-\tcase DUCKDB_TYPE_FLOAT:\n-\t\treturn Value(UnsafeFetch<float>(result, col, row));\n-\tcase DUCKDB_TYPE_DOUBLE:\n-\t\treturn Value(UnsafeFetch<double>(result, col, row));\n-\tcase DUCKDB_TYPE_DATE: {\n-\t\tauto date = UnsafeFetch<duckdb_date>(result, col, row);\n-\t\treturn Value::DATE(date.year, date.month, date.day);\n-\t}\n-\tcase DUCKDB_TYPE_TIME: {\n-\t\tauto time = UnsafeFetch<duckdb_time>(result, col, row);\n-\t\treturn Value::TIME(time.hour, time.min, time.sec, time.micros);\n-\t}\n-\tcase DUCKDB_TYPE_TIMESTAMP_NS:\n-\tcase DUCKDB_TYPE_TIMESTAMP_MS:\n-\tcase DUCKDB_TYPE_TIMESTAMP_S:\n-\tcase DUCKDB_TYPE_TIMESTAMP: {\n-\t\tauto timestamp = UnsafeFetch<duckdb_timestamp>(result, col, row);\n-\t\treturn Value::TIMESTAMP(timestamp.date.year, timestamp.date.month, timestamp.date.day, timestamp.time.hour,\n-\t\t                        timestamp.time.min, timestamp.time.sec, timestamp.time.micros);\n-\t}\n-\tcase DUCKDB_TYPE_HUGEINT: {\n-\t\thugeint_t val;\n-\t\tauto hugeint = UnsafeFetch<duckdb_hugeint>(result, col, row);\n-\t\tval.lower = hugeint.lower;\n-\t\tval.upper = hugeint.upper;\n-\t\treturn Value::HUGEINT(val);\n-\t}\n-\tcase DUCKDB_TYPE_INTERVAL: {\n-\t\tinterval_t val;\n-\t\tauto interval = UnsafeFetch<duckdb_interval>(result, col, row);\n-\t\tval.days = interval.days;\n-\t\tval.months = interval.months;\n-\t\tval.micros = interval.micros;\n-\t\treturn Value::INTERVAL(val);\n-\t}\n-\tcase DUCKDB_TYPE_VARCHAR:\n-\t\treturn Value(string(UnsafeFetch<const char *>(result, col, row)));\n-\tcase DUCKDB_TYPE_BLOB: {\n-\t\tauto blob = UnsafeFetch<duckdb_blob>(result, col, row);\n-\t\treturn Value::BLOB((const_data_ptr_t)blob.data, blob.size);\n-\t}\n-\tdefault:\n-\t\t// invalid type for C to C++ conversion\n-\t\tD_ASSERT(0);\n-\t\treturn Value();\n-\t}\n-}\n-\n-const char *duckdb_column_name(duckdb_result *result, idx_t col) {\n-\tif (!result || col >= result->column_count) {\n-\t\treturn nullptr;\n-\t}\n-\treturn result->columns[col].name;\n-}\n-\n-bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\tif (val.is_null) {\n-\t\treturn false;\n-\t} else {\n-\t\treturn val.GetValue<bool>();\n-\t}\n-}\n-\n-int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\tif (val.is_null) {\n-\t\treturn 0;\n-\t} else {\n-\t\treturn val.GetValue<int8_t>();\n-\t}\n-}\n-\n-int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\tif (val.is_null) {\n-\t\treturn 0;\n-\t} else {\n-\t\treturn val.GetValue<int16_t>();\n-\t}\n-}\n-\n-int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\tif (val.is_null) {\n-\t\treturn 0;\n-\t} else {\n-\t\treturn val.GetValue<int32_t>();\n-\t}\n-}\n-\n-int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\tif (val.is_null) {\n-\t\treturn 0;\n-\t} else {\n-\t\treturn val.GetValue<int64_t>();\n-\t}\n-}\n-\n-uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\tif (val.is_null) {\n-\t\treturn 0;\n-\t} else {\n-\t\treturn val.GetValue<uint8_t>();\n-\t}\n-}\n-\n-uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\tif (val.is_null) {\n-\t\treturn 0;\n-\t} else {\n-\t\treturn val.GetValue<uint16_t>();\n-\t}\n-}\n-\n-uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\tif (val.is_null) {\n-\t\treturn 0;\n-\t} else {\n-\t\treturn val.GetValue<uint32_t>();\n-\t}\n-}\n-\n-uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\tif (val.is_null) {\n-\t\treturn 0;\n-\t} else {\n-\t\treturn val.GetValue<uint64_t>();\n-\t}\n-}\n-\n-float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\tif (val.is_null) {\n-\t\treturn 0.0;\n-\t} else {\n-\t\treturn val.GetValue<float>();\n-\t}\n-}\n-\n-double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\tif (val.is_null) {\n-\t\treturn 0.0;\n-\t} else {\n-\t\treturn val.GetValue<double>();\n-\t}\n-}\n-\n-char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row) {\n-\tValue val = GetCValue(result, col, row);\n-\treturn strdup(val.ToString().c_str());\n-}\n-\n-duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row) {\n-\tduckdb_blob blob;\n-\tValue val = GetCValue(result, col, row).CastAs(LogicalType::BLOB);\n-\tif (val.is_null) {\n-\t\tblob.data = nullptr;\n-\t\tblob.size = 0;\n-\t} else {\n-\t\tblob.data = malloc(val.str_value.size());\n-\t\tmemcpy((void *)blob.data, val.str_value.c_str(), val.str_value.size());\n-\t\tblob.size = val.str_value.size();\n-\t}\n-\treturn blob;\n-}\n-\n-void *duckdb_malloc(size_t size) {\n-\treturn malloc(size);\n-}\n-\n-void duckdb_free(void *ptr) {\n-\tfree(ptr);\n-}\n-\n-namespace duckdb {\n-struct AppenderWrapper {\n-\tAppenderWrapper() : appender(nullptr) {\n-\t}\n-\t~AppenderWrapper() {\n-\t}\n-\tunique_ptr<Appender> appender;\n-\tstring error;\n-};\n-} // namespace duckdb\n-\n-duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,\n-                                    duckdb_appender *out_appender) {\n-\tConnection *conn = (Connection *)connection;\n-\n-\tif (!connection || !table || !out_appender) {\n-\t\treturn DuckDBError;\n-\t}\n-\tif (schema == nullptr) {\n-\t\tschema = DEFAULT_SCHEMA;\n-\t}\n-\tauto wrapper = new AppenderWrapper();\n-\t*out_appender = (duckdb_appender)wrapper;\n-\ttry {\n-\t\twrapper->appender = make_unique<Appender>(*conn, schema, table);\n-\t} catch (std::exception &ex) {\n-\t\twrapper->error = ex.what();\n-\t\treturn DuckDBError;\n-\t} catch (...) {\n-\t\twrapper->error = \"Unknown create appender error\";\n-\t\treturn DuckDBError;\n-\t}\n-\treturn DuckDBSuccess;\n-}\n-\n-duckdb_state duckdb_appender_destroy(duckdb_appender *appender) {\n-\tif (!appender || !*appender) {\n-\t\treturn DuckDBError;\n-\t}\n-\tauto wrapper = (AppenderWrapper *)*appender;\n-\tif (wrapper) {\n-\t\tdelete wrapper;\n-\t}\n-\t*appender = nullptr;\n-\treturn DuckDBSuccess;\n-}\n-\n-template <class FUN>\n-duckdb_state duckdb_appender_run_function(duckdb_appender appender, FUN &&function) {\n-\tif (!appender) {\n-\t\treturn DuckDBError;\n-\t}\n-\tauto wrapper = (AppenderWrapper *)appender;\n-\ttry {\n-\t\tfunction(wrapper->appender.get());\n-\t} catch (std::exception &ex) {\n-\t\twrapper->error = ex.what();\n-\t\treturn DuckDBError;\n-\t} catch (...) {\n-\t\twrapper->error = \"Unknown error\";\n-\t\treturn DuckDBError;\n-\t}\n-\treturn DuckDBSuccess;\n-}\n-\n-duckdb_state duckdb_appender_begin_row(duckdb_appender appender) {\n-\treturn duckdb_appender_run_function(appender, [&](Appender *appender) { appender->BeginRow(); });\n-}\n-\n-duckdb_state duckdb_appender_end_row(duckdb_appender appender) {\n-\treturn duckdb_appender_run_function(appender, [&](Appender *appender) { appender->EndRow(); });\n-}\n-\n-template <class T>\n-duckdb_state duckdb_append_internal(duckdb_appender appender, T value) {\n-\tif (!appender) {\n-\t\treturn DuckDBError;\n-\t}\n-\tauto wrapper = (AppenderWrapper *)appender;\n-\ttry {\n-\t\twrapper->appender->Append<T>(value);\n-\t} catch (std::exception &ex) {\n-\t\twrapper->error = ex.what();\n-\t\treturn DuckDBError;\n-\t} catch (...) {\n-\t\twrapper->error = \"Unknown error\";\n-\t\treturn DuckDBError;\n-\t}\n-\treturn DuckDBSuccess;\n-}\n-\n-duckdb_state duckdb_append_bool(duckdb_appender appender, bool value) {\n-\treturn duckdb_append_internal<bool>(appender, value);\n-}\n-\n-duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value) {\n-\treturn duckdb_append_internal<int8_t>(appender, value);\n-}\n-\n-duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value) {\n-\treturn duckdb_append_internal<int16_t>(appender, value);\n-}\n-\n-duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value) {\n-\treturn duckdb_append_internal<int32_t>(appender, value);\n-}\n-\n-duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value) {\n-\treturn duckdb_append_internal<int64_t>(appender, value);\n-}\n-\n-duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value) {\n-\treturn duckdb_append_internal<uint8_t>(appender, value);\n-}\n-\n-duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value) {\n-\treturn duckdb_append_internal<uint16_t>(appender, value);\n-}\n-\n-duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value) {\n-\treturn duckdb_append_internal<uint32_t>(appender, value);\n-}\n-\n-duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value) {\n-\treturn duckdb_append_internal<uint64_t>(appender, value);\n-}\n-\n-duckdb_state duckdb_append_float(duckdb_appender appender, float value) {\n-\treturn duckdb_append_internal<float>(appender, value);\n-}\n-\n-duckdb_state duckdb_append_double(duckdb_appender appender, double value) {\n-\treturn duckdb_append_internal<double>(appender, value);\n-}\n-\n-duckdb_state duckdb_append_null(duckdb_appender appender) {\n-\treturn duckdb_append_internal<std::nullptr_t>(appender, nullptr);\n-}\n-\n-duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val) {\n-\treturn duckdb_append_internal<const char *>(appender, val);\n-}\n-\n-duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length) {\n-\treturn duckdb_append_internal<string_t>(appender, string_t(val, length));\n-}\n-duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length) {\n-\treturn duckdb_append_internal<string_t>(appender, string_t((const char *)data, length));\n-}\n-\n-const char *duckdb_appender_error(duckdb_appender appender) {\n-\tif (!appender) {\n-\t\treturn nullptr;\n-\t}\n-\tauto wrapper = (AppenderWrapper *)appender;\n-\tif (wrapper->error.empty()) {\n-\t\treturn nullptr;\n-\t}\n-\treturn strdup(wrapper->error.c_str());\n-}\n-\n-duckdb_state duckdb_appender_flush(duckdb_appender appender) {\n-\treturn duckdb_appender_run_function(appender, [&](Appender *appender) { appender->Flush(); });\n-}\n-\n-duckdb_state duckdb_appender_close(duckdb_appender appender) {\n-\treturn duckdb_appender_run_function(appender, [&](Appender *appender) { appender->Close(); });\n-}\n",
  "test_patch": "diff --git a/test/api/capi/test_capi.cpp b/test/api/capi/test_capi.cpp\nindex d977e9ede181..65613c4df19d 100644\n--- a/test/api/capi/test_capi.cpp\n+++ b/test/api/capi/test_capi.cpp\n@@ -134,6 +134,11 @@ duckdb_timestamp CAPIResult::Fetch(idx_t col, idx_t row) {\n \treturn data[row];\n }\n \n+template <>\n+duckdb_interval CAPIResult::Fetch(idx_t col, idx_t row) {\n+\treturn duckdb_value_interval(&result, col, row);\n+}\n+\n template <>\n duckdb_blob CAPIResult::Fetch(idx_t col, idx_t row) {\n \tauto data = (duckdb_blob *)result.columns[col].data;\n@@ -148,6 +153,24 @@ string CAPIResult::Fetch(idx_t col, idx_t row) {\n \treturn strval;\n }\n \n+template <>\n+duckdb_date_struct CAPIResult::Fetch(idx_t col, idx_t row) {\n+\tauto value = duckdb_value_date(&result, col, row);\n+\treturn duckdb_from_date(value);\n+}\n+\n+template <>\n+duckdb_time_struct CAPIResult::Fetch(idx_t col, idx_t row) {\n+\tauto value = duckdb_value_time(&result, col, row);\n+\treturn duckdb_from_time(value);\n+}\n+\n+template <>\n+duckdb_timestamp_struct CAPIResult::Fetch(idx_t col, idx_t row) {\n+\tauto value = duckdb_value_timestamp(&result, col, row);\n+\treturn duckdb_from_timestamp(value);\n+}\n+\n class CAPITester {\n public:\n \tCAPITester() : database(nullptr), connection(nullptr) {\n@@ -202,6 +225,9 @@ TEST_CASE(\"Basic test of C API\", \"[capi]\") {\n \tREQUIRE(result->row_count() == 1);\n \tREQUIRE(result->Fetch<int64_t>(0, 0) == 42);\n \tREQUIRE(!result->IsNull(0, 0));\n+\t// out of range fetch\n+\tREQUIRE(result->Fetch<int64_t>(1, 0) == 0);\n+\tREQUIRE(result->Fetch<int64_t>(0, 1) == 0);\n \n \t// select scalar NULL\n \tresult = tester.Query(\"SELECT NULL\");\n@@ -341,12 +367,12 @@ TEST_CASE(\"Test different types of C API\", \"[capi]\") {\n \tresult = tester.Query(\"SELECT * FROM dates ORDER BY d\");\n \tREQUIRE_NO_FAIL(*result);\n \tREQUIRE(result->IsNull(0, 0));\n-\tduckdb_date date = result->Fetch<duckdb_date>(0, 1);\n+\tduckdb_date_struct date = duckdb_from_date(result->Fetch<duckdb_date>(0, 1));\n \tREQUIRE(date.year == 1992);\n \tREQUIRE(date.month == 9);\n \tREQUIRE(date.day == 20);\n \tREQUIRE(result->Fetch<string>(0, 1) == Value::DATE(1992, 9, 20).ToString());\n-\tdate = result->Fetch<duckdb_date>(0, 2);\n+\tdate = duckdb_from_date(result->Fetch<duckdb_date>(0, 2));\n \tREQUIRE(date.year == 30000);\n \tREQUIRE(date.month == 9);\n \tREQUIRE(date.day == 20);\n@@ -366,7 +392,7 @@ TEST_CASE(\"Test different types of C API\", \"[capi]\") {\n \tREQUIRE(result->IsNull(2, 0));\n \tREQUIRE(result->IsNull(3, 0));\n \tfor (idx_t i = 0; i < 4; i++) {\n-\t\tduckdb_timestamp stamp = result->Fetch<duckdb_timestamp>(i, 1);\n+\t\tduckdb_timestamp_struct stamp = duckdb_from_timestamp(result->Fetch<duckdb_timestamp>(i, 1));\n \t\tREQUIRE(stamp.date.year == 1992);\n \t\tREQUIRE(stamp.date.month == 9);\n \t\tREQUIRE(stamp.date.day == 20);\n@@ -386,13 +412,13 @@ TEST_CASE(\"Test different types of C API\", \"[capi]\") {\n \tresult = tester.Query(\"SELECT * FROM times ORDER BY d\");\n \tREQUIRE_NO_FAIL(*result);\n \tREQUIRE(result->IsNull(0, 0));\n-\tduckdb_time time_val = result->Fetch<duckdb_time>(0, 1);\n+\tduckdb_time_struct time_val = duckdb_from_time(result->Fetch<duckdb_time>(0, 1));\n \tREQUIRE(time_val.hour == 2);\n \tREQUIRE(time_val.min == 30);\n \tREQUIRE(time_val.sec == 1);\n \tREQUIRE(time_val.micros == 0);\n \tREQUIRE(result->Fetch<string>(0, 1) == Value::TIME(2, 30, 1, 0).ToString());\n-\ttime_val = result->Fetch<duckdb_time>(0, 2);\n+\ttime_val = duckdb_from_time(result->Fetch<duckdb_time>(0, 2));\n \tREQUIRE(time_val.hour == 12);\n \tREQUIRE(time_val.min == 0);\n \tREQUIRE(time_val.sec == 30);\n@@ -449,6 +475,7 @@ TEST_CASE(\"Test errors in C API\", \"[capi]\") {\n \tREQUIRE(stmt == nullptr);\n \n \tREQUIRE(duckdb_prepare(tester.connection, \"SELECT * from INVALID_TABLE\", &stmt) == DuckDBError);\n+\tREQUIRE(duckdb_prepare_error(nullptr) == nullptr);\n \tREQUIRE(stmt != nullptr);\n \tauto err_msg = duckdb_prepare_error(stmt);\n \tREQUIRE(err_msg != nullptr);\n@@ -466,6 +493,10 @@ TEST_CASE(\"Test errors in C API\", \"[capi]\") {\n \tREQUIRE(err_msg != nullptr);\n \tduckdb_free((void *)err_msg);\n \tduckdb_destroy_arrow(&out_arrow);\n+\n+\t// various edge cases/nullptrs\n+\tREQUIRE(duckdb_query_arrow_schema(out_arrow, nullptr) == DuckDBSuccess);\n+\tREQUIRE(duckdb_query_arrow_array(out_arrow, nullptr) == DuckDBSuccess);\n }\n \n TEST_CASE(\"Test prepared statements in C API\", \"[capi]\") {\n@@ -516,6 +547,30 @@ TEST_CASE(\"Test prepared statements in C API\", \"[capi]\") {\n \tREQUIRE(duckdb_value_int64(&res, 0, 0) == 64);\n \tduckdb_destroy_result(&res);\n \n+\tduckdb_bind_uint8(stmt, 1, 8);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_uint8(&res, 0, 0) == 8);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_uint16(stmt, 1, 8);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_uint16(&res, 0, 0) == 8);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_uint32(stmt, 1, 8);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_uint32(&res, 0, 0) == 8);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_bind_uint64(stmt, 1, 8);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_value_uint64(&res, 0, 0) == 8);\n+\tduckdb_destroy_result(&res);\n+\n \tduckdb_bind_float(stmt, 1, 42.0);\n \tstatus = duckdb_execute_prepared(stmt, &res);\n \tREQUIRE(status == DuckDBSuccess);\n@@ -565,6 +620,58 @@ TEST_CASE(\"Test prepared statements in C API\", \"[capi]\") {\n \tduckdb_free(value);\n \tduckdb_destroy_result(&res);\n \n+\tduckdb_date_struct date_struct;\n+\tdate_struct.year = 1992;\n+\tdate_struct.month = 9;\n+\tdate_struct.day = 3;\n+\n+\tduckdb_bind_date(stmt, 1, duckdb_to_date(date_struct));\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tvalue = duckdb_value_varchar(&res, 0, 0);\n+\tREQUIRE(string(value) == \"1992-09-03\");\n+\tduckdb_free(value);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_time_struct time_struct;\n+\ttime_struct.hour = 12;\n+\ttime_struct.min = 22;\n+\ttime_struct.sec = 33;\n+\ttime_struct.micros = 123400;\n+\n+\tduckdb_bind_time(stmt, 1, duckdb_to_time(time_struct));\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tvalue = duckdb_value_varchar(&res, 0, 0);\n+\tREQUIRE(string(value) == \"12:22:33.1234\");\n+\tduckdb_free(value);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_timestamp_struct ts;\n+\tts.date = date_struct;\n+\tts.time = time_struct;\n+\n+\tduckdb_bind_timestamp(stmt, 1, duckdb_to_timestamp(ts));\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tvalue = duckdb_value_varchar(&res, 0, 0);\n+\tREQUIRE(string(value) == \"1992-09-03 12:22:33.1234\");\n+\tduckdb_free(value);\n+\tduckdb_destroy_result(&res);\n+\n+\tduckdb_interval interval;\n+\tinterval.months = 3;\n+\tinterval.days = 0;\n+\tinterval.micros = 0;\n+\n+\tduckdb_bind_interval(stmt, 1, interval);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tvalue = duckdb_value_varchar(&res, 0, 0);\n+\tREQUIRE(string(value) == \"3 months\");\n+\tduckdb_free(value);\n+\tduckdb_destroy_result(&res);\n+\n \tduckdb_destroy_prepare(&stmt);\n \n \tstatus = duckdb_query(tester.connection, \"CREATE TABLE a (i INTEGER)\", NULL);\n@@ -574,6 +681,8 @@ TEST_CASE(\"Test prepared statements in C API\", \"[capi]\") {\n \tREQUIRE(status == DuckDBSuccess);\n \tREQUIRE(stmt != nullptr);\n \tidx_t nparams;\n+\tREQUIRE(duckdb_nparams(nullptr, &nparams) == DuckDBError);\n+\tREQUIRE(duckdb_nparams(stmt, nullptr) == DuckDBError);\n \tREQUIRE(duckdb_nparams(stmt, &nparams) == DuckDBSuccess);\n \tREQUIRE(nparams == 1);\n \n@@ -641,6 +750,7 @@ TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n \n \tstatus = duckdb_appender_create(tester.connection, nullptr, \"test\", &appender);\n \tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(duckdb_appender_error(appender) == nullptr);\n \n \tstatus = duckdb_appender_begin_row(appender);\n \tREQUIRE(status == DuckDBSuccess);\n@@ -754,7 +864,8 @@ TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n \n \t// many types\n \tREQUIRE_NO_FAIL(tester.Query(\"CREATE TABLE many_types(bool boolean, t TINYINT, s SMALLINT, b BIGINT, ut UTINYINT, \"\n-\t                             \"us USMALLINT, ui UINTEGER, ub UBIGINT, uf REAL, ud DOUBLE, txt VARCHAR, blb BLOB)\"));\n+\t                             \"us USMALLINT, ui UINTEGER, ub UBIGINT, uf REAL, ud DOUBLE, txt VARCHAR, blb BLOB, dt \"\n+\t                             \"DATE, tm TIME, ts TIMESTAMP, ival INTERVAL)\"));\n \tduckdb_appender tappender;\n \n \tstatus = duckdb_appender_create(tester.connection, nullptr, \"many_types\", &tappender);\n@@ -790,17 +901,49 @@ TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n \tstatus = duckdb_append_float(tappender, 0.5f);\n \tREQUIRE(status == DuckDBSuccess);\n \n-\tstatus = duckdb_append_null(tappender);\n+\tstatus = duckdb_append_double(tappender, 0.5);\n \tREQUIRE(status == DuckDBSuccess);\n \n \tstatus = duckdb_append_varchar_length(tappender, \"hello world\", 5);\n \tREQUIRE(status == DuckDBSuccess);\n \n+\tduckdb_date_struct date_struct;\n+\tdate_struct.year = 1992;\n+\tdate_struct.month = 9;\n+\tdate_struct.day = 3;\n+\n \tauto str = strdup(\"hello world this is my long string\");\n \tstatus = duckdb_append_blob(tappender, str, strlen(str));\n \tfree(str);\n \tREQUIRE(status == DuckDBSuccess);\n \n+\tstatus = duckdb_append_date(tappender, duckdb_to_date(date_struct));\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tduckdb_time_struct time_struct;\n+\ttime_struct.hour = 12;\n+\ttime_struct.min = 22;\n+\ttime_struct.sec = 33;\n+\ttime_struct.micros = 1234;\n+\n+\tstatus = duckdb_append_time(tappender, duckdb_to_time(time_struct));\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tduckdb_timestamp_struct ts;\n+\tts.date = date_struct;\n+\tts.time = time_struct;\n+\n+\tstatus = duckdb_append_timestamp(tappender, duckdb_to_timestamp(ts));\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tduckdb_interval interval;\n+\tinterval.months = 3;\n+\tinterval.days = 0;\n+\tinterval.micros = 0;\n+\n+\tstatus = duckdb_append_interval(tappender, interval);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n \tstatus = duckdb_appender_end_row(tappender);\n \tREQUIRE(status == DuckDBSuccess);\n \n@@ -843,6 +986,18 @@ TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n \tstatus = duckdb_append_null(tappender);\n \tREQUIRE(status == DuckDBSuccess);\n \n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n+\tstatus = duckdb_append_null(tappender);\n+\tREQUIRE(status == DuckDBSuccess);\n+\n \tstatus = duckdb_appender_end_row(tappender);\n \tREQUIRE(status == DuckDBSuccess);\n \n@@ -866,7 +1021,7 @@ TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n \tREQUIRE(result->Fetch<uint32_t>(6, 0) == 1);\n \tREQUIRE(result->Fetch<uint64_t>(7, 0) == 1);\n \tREQUIRE(result->Fetch<float>(8, 0) == 0.5f);\n-\tREQUIRE(result->IsNull(9, 0));\n+\tREQUIRE(result->Fetch<double>(9, 0) == 0.5);\n \tREQUIRE(result->Fetch<string>(10, 0) == \"hello\");\n \n \tauto blob = duckdb_value_blob(&result->InternalResult(), 11, 0);\n@@ -874,6 +1029,31 @@ TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n \tREQUIRE(memcmp(blob.data, \"hello world this is my long string\", 34) == 0);\n \tduckdb_free(blob.data);\n \n+\tauto date = result->Fetch<duckdb_date_struct>(12, 0);\n+\tREQUIRE(date.year == 1992);\n+\tREQUIRE(date.month == 9);\n+\tREQUIRE(date.day == 3);\n+\n+\tauto time = result->Fetch<duckdb_time_struct>(13, 0);\n+\tREQUIRE(time.hour == 12);\n+\tREQUIRE(time.min == 22);\n+\tREQUIRE(time.sec == 33);\n+\tREQUIRE(time.micros == 1234);\n+\n+\tauto timestamp = result->Fetch<duckdb_timestamp_struct>(14, 0);\n+\tREQUIRE(timestamp.date.year == 1992);\n+\tREQUIRE(timestamp.date.month == 9);\n+\tREQUIRE(timestamp.date.day == 3);\n+\tREQUIRE(timestamp.time.hour == 12);\n+\tREQUIRE(timestamp.time.min == 22);\n+\tREQUIRE(timestamp.time.sec == 33);\n+\tREQUIRE(timestamp.time.micros == 1234);\n+\n+\tinterval = result->Fetch<duckdb_interval>(15, 0);\n+\tREQUIRE(interval.months == 3);\n+\tREQUIRE(interval.days == 0);\n+\tREQUIRE(interval.micros == 0);\n+\n \tREQUIRE(result->IsNull(0, 1));\n \tREQUIRE(result->IsNull(1, 1));\n \tREQUIRE(result->IsNull(2, 1));\n@@ -886,6 +1066,38 @@ TEST_CASE(\"Test appender statements in C API\", \"[capi]\") {\n \tREQUIRE(result->IsNull(9, 1));\n \tREQUIRE(result->IsNull(10, 1));\n \tREQUIRE(result->IsNull(11, 1));\n+\tREQUIRE(result->IsNull(12, 1));\n+\tREQUIRE(result->IsNull(13, 1));\n+\tREQUIRE(result->IsNull(14, 1));\n+\tREQUIRE(result->IsNull(15, 1));\n+\n+\tREQUIRE(result->Fetch<bool>(0, 1) == false);\n+\tREQUIRE(result->Fetch<int8_t>(1, 1) == 0);\n+\tREQUIRE(result->Fetch<int16_t>(2, 1) == 0);\n+\tREQUIRE(result->Fetch<int64_t>(3, 1) == 0);\n+\tREQUIRE(result->Fetch<uint8_t>(4, 1) == 0);\n+\tREQUIRE(result->Fetch<uint16_t>(5, 1) == 0);\n+\tREQUIRE(result->Fetch<uint32_t>(6, 1) == 0);\n+\tREQUIRE(result->Fetch<uint64_t>(7, 1) == 0);\n+\tREQUIRE(result->Fetch<float>(8, 1) == 0);\n+\tREQUIRE(result->Fetch<double>(9, 1) == 0);\n+\tREQUIRE(result->Fetch<string>(10, 1) == \"NULL\");\n+\n+\tblob = duckdb_value_blob(&result->InternalResult(), 11, 1);\n+\tREQUIRE(blob.size == 0);\n+\n+\tdate = result->Fetch<duckdb_date_struct>(12, 1);\n+\tREQUIRE(date.year == 1970);\n+\n+\ttime = result->Fetch<duckdb_time_struct>(13, 1);\n+\tREQUIRE(time.hour == 0);\n+\n+\ttimestamp = result->Fetch<duckdb_timestamp_struct>(14, 1);\n+\tREQUIRE(timestamp.date.year == 1970);\n+\tREQUIRE(timestamp.time.hour == 0);\n+\n+\tinterval = result->Fetch<duckdb_interval>(15, 1);\n+\tREQUIRE(interval.months == 0);\n }\n \n TEST_CASE(\"Test arrow in C API\", \"[capi]\") {\n@@ -981,6 +1193,7 @@ TEST_CASE(\"Test arrow in C API\", \"[capi]\") {\n \t\tREQUIRE(duckdb_prepare(tester.connection, \"SELECT CAST($1 AS BIGINT)\", &stmt) == DuckDBSuccess);\n \t\tREQUIRE(stmt != nullptr);\n \t\tREQUIRE(duckdb_bind_int64(stmt, 1, 42) == DuckDBSuccess);\n+\t\tREQUIRE(duckdb_execute_prepared_arrow(stmt, nullptr) == DuckDBError);\n \t\tREQUIRE(duckdb_execute_prepared_arrow(stmt, &arrow_result) == DuckDBSuccess);\n \n \t\tArrowSchema *arrow_schema = new ArrowSchema();\n@@ -1053,6 +1266,8 @@ TEST_CASE(\"Test C API config\", \"[capi]\") {\n \tduckdb_destroy_config(&config);\n \tduckdb_destroy_config(&config);\n \n+\tREQUIRE(duckdb_connect(db, nullptr) == DuckDBError);\n+\tREQUIRE(duckdb_connect(nullptr, &con) == DuckDBError);\n \tREQUIRE(duckdb_connect(db, &con) == DuckDBSuccess);\n \n \t// we can query\n@@ -1077,3 +1292,25 @@ TEST_CASE(\"Test C API config\", \"[capi]\") {\n \tduckdb_destroy_config(nullptr);\n \tduckdb_destroy_config(nullptr);\n }\n+\n+TEST_CASE(\"Issue #2058: Cleanup after execution of invalid SQL statement causes segmentation fault\", \"[capi]\") {\n+\tduckdb_database db;\n+\tduckdb_connection con;\n+\tduckdb_result result;\n+\tduckdb_result result_count;\n+\n+\tREQUIRE(duckdb_open(NULL, &db) != DuckDBError);\n+\tREQUIRE(duckdb_connect(db, &con) != DuckDBError);\n+\n+\tREQUIRE(duckdb_query(con, \"CREATE TABLE integers(i INTEGER, j INTEGER);\", NULL) != DuckDBError);\n+\tREQUIRE((duckdb_query(con, \"SELECT count(*) FROM integers;\", &result_count) != DuckDBError));\n+\n+\tduckdb_destroy_result(&result_count);\n+\n+\tREQUIRE(duckdb_query(con, \"non valid SQL\", &result) == DuckDBError);\n+\n+\tduckdb_destroy_result(&result); // segmentation failure happens here\n+\n+\tduckdb_disconnect(&con);\n+\tduckdb_close(&db);\n+}\n",
  "problem_statement": "Cleanup after execution of invalid SQL statement causes segmentation fault\n**What does happen?**\r\nAfter execution of invalid SQL statement any attempt to cleanup  \"duckdb_result\" structure with function `duckdb_destroy_result`  leads into segmentation fault. This happens only if we already perform any query returning data.\r\n\r\n**What should happen?**\r\nThere should be no segmentation fault and execution of program should continue.\r\n\r\n**To Reproduce**\r\nPlease compile and run following code snippet, during execution of line \"duckdb_destroy_result(&result); // segmentation failure happens here\"  segmentation fault occurs: \r\n\r\n```c\r\n#include \"duckdb.h\"\r\n#include <string.h>\r\n\r\nint main() {\r\n    duckdb_database db;\r\n    duckdb_connection con;\r\n    duckdb_result result;\r\n    duckdb_result result_count;\r\n\r\n    if (duckdb_open(NULL, &db) == DuckDBError) {\r\n        // handle error\r\n    }\r\n    if (duckdb_connect(db, &con) == DuckDBError) {\r\n        // handle error\r\n    }\r\n\r\n    // create a table\r\n    if (duckdb_query(con, \"CREATE TABLE integers(i INTEGER, j INTEGER);\", NULL) == DuckDBError) {\r\n        // handle error\r\n    }\r\n\r\n     // insert three rows into the table\r\n    if (duckdb_query(con, \"SELECT count(*) FROM integers;\", &result_count) == DuckDBError) {\r\n        // handle error\r\n    }\r\n\r\n    duckdb_destroy_result(&result_count);\r\n\r\n    if (duckdb_query(con, \"non valid SQL\", &result) == DuckDBError) {\r\n        duckdb_destroy_result(&result); // segmentation failure happens here\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Linux, Ubuntu 20.4\r\n - DuckDB Version: 0.2.7, fails also on master (I used precompiled binaries)\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2021-08-06T20:15:48Z"
}