You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Cleanup after execution of invalid SQL statement causes segmentation fault
**What does happen?**
After execution of invalid SQL statement any attempt to cleanup  "duckdb_result" structure with function `duckdb_destroy_result`  leads into segmentation fault. This happens only if we already perform any query returning data.

**What should happen?**
There should be no segmentation fault and execution of program should continue.

**To Reproduce**
Please compile and run following code snippet, during execution of line "duckdb_destroy_result(&result); // segmentation failure happens here"  segmentation fault occurs: 

```c
#include "duckdb.h"
#include <string.h>

int main() {
    duckdb_database db;
    duckdb_connection con;
    duckdb_result result;
    duckdb_result result_count;

    if (duckdb_open(NULL, &db) == DuckDBError) {
        // handle error
    }
    if (duckdb_connect(db, &con) == DuckDBError) {
        // handle error
    }

    // create a table
    if (duckdb_query(con, "CREATE TABLE integers(i INTEGER, j INTEGER);", NULL) == DuckDBError) {
        // handle error
    }

     // insert three rows into the table
    if (duckdb_query(con, "SELECT count(*) FROM integers;", &result_count) == DuckDBError) {
        // handle error
    }

    duckdb_destroy_result(&result_count);

    if (duckdb_query(con, "non valid SQL", &result) == DuckDBError) {
        duckdb_destroy_result(&result); // segmentation failure happens here
    }

    return 0;
}
```

**Environment (please complete the following information):**
 - OS: Linux, Ubuntu 20.4
 - DuckDB Version: 0.2.7, fails also on master (I used precompiled binaries)



</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![codecov](https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN)](https://codecov.io/gh/duckdb/duckdb)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/include/duckdb.h]
1: //===----------------------------------------------------------------------===//
2: //
3: //                         DuckDB
4: //
5: // duckdb.h
6: //
7: // Author: Mark Raasveldt
8: //
9: //===----------------------------------------------------------------------===//
10: 
11: #pragma once
12: 
13: #ifdef _WIN32
14: #ifdef DUCKDB_BUILD_LIBRARY
15: #define DUCKDB_API __declspec(dllexport)
16: #else
17: #define DUCKDB_API __declspec(dllimport)
18: #endif
19: #else
20: #define DUCKDB_API
21: #endif
22: 
23: #include <stdbool.h>
24: #include <stdint.h>
25: #include <stdlib.h>
26: 
27: #ifdef __cplusplus
28: extern "C" {
29: #endif
30: 
31: typedef uint64_t idx_t;
32: 
33: typedef enum DUCKDB_TYPE {
34: 	DUCKDB_TYPE_INVALID = 0,
35: 	// bool
36: 	DUCKDB_TYPE_BOOLEAN,
37: 	// int8_t
38: 	DUCKDB_TYPE_TINYINT,
39: 	// int16_t
40: 	DUCKDB_TYPE_SMALLINT,
41: 	// int32_t
42: 	DUCKDB_TYPE_INTEGER,
43: 	// int64_t
44: 	DUCKDB_TYPE_BIGINT,
45: 	// uint8_t
46: 	DUCKDB_TYPE_UTINYINT,
47: 	// uint16_t
48: 	DUCKDB_TYPE_USMALLINT,
49: 	// uint32_t
50: 	DUCKDB_TYPE_UINTEGER,
51: 	// uint64_t
52: 	DUCKDB_TYPE_UBIGINT,
53: 	// float
54: 	DUCKDB_TYPE_FLOAT,
55: 	// double
56: 	DUCKDB_TYPE_DOUBLE,
57: 	// duckdb_timestamp (us)
58: 	DUCKDB_TYPE_TIMESTAMP,
59: 	// duckdb_timestamp (s)
60: 	DUCKDB_TYPE_TIMESTAMP_S,
61: 	// duckdb_timestamp (ns)
62: 	DUCKDB_TYPE_TIMESTAMP_NS,
63: 	// duckdb_timestamp (ms)
64: 	DUCKDB_TYPE_TIMESTAMP_MS,
65: 	// duckdb_date
66: 	DUCKDB_TYPE_DATE,
67: 	// duckdb_time
68: 	DUCKDB_TYPE_TIME,
69: 	// duckdb_interval
70: 	DUCKDB_TYPE_INTERVAL,
71: 	// duckdb_hugeint
72: 	DUCKDB_TYPE_HUGEINT,
73: 	// const char*
74: 	DUCKDB_TYPE_VARCHAR,
75: 	// duckdb_blob
76: 	DUCKDB_TYPE_BLOB
77: } duckdb_type;
78: 
79: typedef struct {
80: 	int32_t year;
81: 	int8_t month;
82: 	int8_t day;
83: } duckdb_date;
84: 
85: typedef struct {
86: 	int8_t hour;
87: 	int8_t min;
88: 	int8_t sec;
89: 	int32_t micros;
90: } duckdb_time;
91: 
92: typedef struct {
93: 	duckdb_date date;
94: 	duckdb_time time;
95: } duckdb_timestamp;
96: 
97: typedef struct {
98: 	int32_t months;
99: 	int32_t days;
100: 	int64_t micros;
101: } duckdb_interval;
102: 
103: typedef struct {
104: 	uint64_t lower;
105: 	int64_t upper;
106: } duckdb_hugeint;
107: 
108: typedef struct {
109: 	void *data;
110: 	idx_t size;
111: } duckdb_blob;
112: 
113: typedef struct {
114: 	void *data;
115: 	bool *nullmask;
116: 	duckdb_type type;
117: 	char *name;
118: } duckdb_column;
119: 
120: typedef struct {
121: 	idx_t column_count;
122: 	idx_t row_count;
123: 	idx_t rows_changed;
124: 	duckdb_column *columns;
125: 	char *error_message;
126: } duckdb_result;
127: 
128: typedef void *duckdb_database;
129: typedef void *duckdb_connection;
130: typedef void *duckdb_prepared_statement;
131: typedef void *duckdb_appender;
132: typedef void *duckdb_arrow;
133: typedef void *duckdb_config;
134: // we don't need to spell out the schema/array in here
135: // because it's a common interface, users can consume
136: // the data in their own logic.
137: typedef void *duckdb_arrow_schema;
138: typedef void *duckdb_arrow_array;
139: 
140: typedef enum { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;
141: 
142: //! query duckdb result as arrow data structure
143: DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);
144: //! get arrow schema
145: DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);
146: //! get arrow data array
147: //! This function can be called multiple time to get next chunks, which will free the previous out_array.
148: //! So consume the out_array before call this function again
149: DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);
150: //! get arrow row count
151: DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);
152: //! get arrow column count
153: DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);
154: //! get arrow rows changed
155: DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);
156: //! get arrow error message
157: DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);
158: //! Destroys the arrow result
159: DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
160: 
161: //! Creates a DuckDB configuration object. The created object must be destroyed with duckdb_destroy_config.
162: DUCKDB_API duckdb_state duckdb_create_config(duckdb_config *out_config);
163: //! Returns the amount of config options available.
164: //! Should not be called in a loop as it internally loops over all the options.
165: DUCKDB_API size_t duckdb_config_count();
166: //! Returns the config name and description for the config at the specified index
167: //! The result MUST NOT be freed
168: //! Returns failure if the index is out of range (i.e. >= duckdb_config_count)
169: DUCKDB_API duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description);
170: //! Sets the specified config option for the configuration
171: DUCKDB_API duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option);
172: //! Destroys a config object created with duckdb_create_config
173: DUCKDB_API void duckdb_destroy_config(duckdb_config *config);
174: 
175: //! Opens a database file at the given path (nullptr for in-memory). Returns DuckDBSuccess on success, or DuckDBError on
176: //! failure. [OUT: database]
177: DUCKDB_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);
178: //! Opens a database file at the given path using the specified configuration
179: //! If error is set the error will be reported
180: DUCKDB_API duckdb_state duckdb_open_ext(const char *path, duckdb_database *out_database, duckdb_config config,
181:                                         char **error);
182: //! Closes the database.
183: DUCKDB_API void duckdb_close(duckdb_database *database);
184: 
185: //! Creates a connection to the specified database. [OUT: connection]
186: DUCKDB_API duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out_connection);
187: //! Closes the specified connection handle
188: DUCKDB_API void duckdb_disconnect(duckdb_connection *connection);
189: 
190: //! Executes the specified SQL query in the specified connection handle. [OUT: result descriptor]
191: DUCKDB_API duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out_result);
192: //! Destroys the specified result
193: DUCKDB_API void duckdb_destroy_result(duckdb_result *result);
194: 
195: //! Returns the column name of the specified column. The result does not need to be freed;
196: //! the column names will automatically be destroyed when the result is destroyed.
197: DUCKDB_API const char *duckdb_column_name(duckdb_result *result, idx_t col);
198: 
199: // SAFE fetch functions
200: // These functions will perform conversions if necessary. On failure (e.g. if conversion cannot be performed) a special
201: // value is returned.
202: 
203: //! Converts the specified value to a bool. Returns false on failure or NULL.
204: DUCKDB_API bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row);
205: //! Converts the specified value to an int8_t. Returns 0 on failure or NULL.
206: DUCKDB_API int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row);
207: //! Converts the specified value to an int16_t. Returns 0 on failure or NULL.
208: DUCKDB_API int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row);
209: //! Converts the specified value to an int64_t. Returns 0 on failure or NULL.
210: DUCKDB_API int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row);
211: //! Converts the specified value to an int64_t. Returns 0 on failure or NULL.
212: DUCKDB_API int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row);
213: //! Converts the specified value to an uint8_t. Returns 0 on failure or NULL.
214: DUCKDB_API uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row);
215: //! Converts the specified value to an uint16_t. Returns 0 on failure or NULL.
216: DUCKDB_API uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row);
217: //! Converts the specified value to an uint64_t. Returns 0 on failure or NULL.
218: DUCKDB_API uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row);
219: //! Converts the specified value to an uint64_t. Returns 0 on failure or NULL.
220: DUCKDB_API uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row);
221: //! Converts the specified value to a float. Returns 0.0 on failure or NULL.
222: DUCKDB_API float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row);
223: //! Converts the specified value to a double. Returns 0.0 on failure or NULL.
224: DUCKDB_API double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row);
225: //! Converts the specified value to a string. Returns nullptr on failure or NULL. The result must be freed with
226: //! duckdb_free.
227: DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);
228: //! Fetches a blob from a result set column. Returns a blob with blob.data set to nullptr on failure or NULL. The
229: //! resulting "blob.data" must be freed with duckdb_free.
230: DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);
231: 
232: //! Allocate [size] amounts of memory using the duckdb internal malloc function. Any memory allocated in this manner
233: //! should be freed using duckdb_free
234: DUCKDB_API void *duckdb_malloc(size_t size);
235: //! Free a value returned from duckdb_malloc, duckdb_value_varchar or duckdb_value_blob
236: DUCKDB_API void duckdb_free(void *ptr);
237: 
238: // Prepared Statements
239: 
240: //! prepares the specified SQL query in the specified connection handle. [OUT: prepared statement descriptor]
241: DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
242:                                        duckdb_prepared_statement *out_prepared_statement);
243: 
244: DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);
245: DUCKDB_API duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out);
246: 
247: //! binds parameters to prepared statement
248: DUCKDB_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);
249: DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
250: DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
251: DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);
252: DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);
253: DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
254: DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
255: DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);
256: DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);
257: DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);
258: DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);
259: DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,
260:                                             const char *val);
261: DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,
262:                                                    const char *val, idx_t length);
263: DUCKDB_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,
264:                                          const void *data, idx_t length);
265: DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);
266: 
267: //! Executes the prepared statements with currently bound parameters
268: DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,
269:                                                 duckdb_result *out_result);
270: 
271: //! Executes the prepared statements with currently bound parameters and return arrow result
272: DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,
273:                                                       duckdb_arrow *out_result);
274: 
275: //! Destroys the specified prepared statement descriptor
276: DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);
277: 
278: DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
279:                                                duckdb_appender *out_appender);
280: 
281: DUCKDB_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);
282: DUCKDB_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);
283: 
284: DUCKDB_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);
285: 
286: DUCKDB_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);
287: DUCKDB_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);
288: DUCKDB_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);
289: DUCKDB_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);
290: 
291: DUCKDB_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);
292: DUCKDB_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);
293: DUCKDB_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);
294: DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);
295: 
296: DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);
297: DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);
298: 
299: DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);
300: DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);
301: DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);
302: DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);
303: 
304: DUCKDB_API const char *duckdb_appender_error(duckdb_appender appender);
305: DUCKDB_API duckdb_state duckdb_appender_flush(duckdb_appender appender);
306: DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);
307: 
308: DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);
309: 
310: #ifdef __cplusplus
311: }
312: #endif
[end of src/include/duckdb.h]
[start of src/include/duckdb/main/appender.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/appender.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/types/data_chunk.hpp"
12: #include "duckdb/common/winapi.hpp"
13: #include "duckdb/main/table_description.hpp"
14: #include "duckdb/common/types/chunk_collection.hpp"
15: 
16: namespace duckdb {
17: 
18: class ClientContext;
19: class DuckDB;
20: class TableCatalogEntry;
21: class Connection;
22: 
23: //! The Appender class can be used to append elements to a table.
24: class Appender {
25: 	//! The amount of chunks that will be gathered in the chunk collection before flushing
26: 	static constexpr const idx_t FLUSH_COUNT = 100;
27: 
28: 	//! A reference to a database connection that created this appender
29: 	shared_ptr<ClientContext> context;
30: 	//! The table description (including column names)
31: 	unique_ptr<TableDescription> description;
32: 	//! The append types
33: 	vector<LogicalType> types;
34: 	//! The buffered data for the append
35: 	ChunkCollection collection;
36: 	//! Internal chunk used for appends
37: 	unique_ptr<DataChunk> chunk;
38: 	//! The current column to append to
39: 	idx_t column = 0;
40: 
41: public:
42: 	DUCKDB_API Appender(Connection &con, const string &schema_name, const string &table_name);
43: 	DUCKDB_API Appender(Connection &con, const string &table_name);
44: 	DUCKDB_API ~Appender();
45: 
46: 	//! Begins a new row append, after calling this the other AppendX() functions
47: 	//! should be called the correct amount of times. After that,
48: 	//! EndRow() should be called.
49: 	DUCKDB_API void BeginRow();
50: 	//! Finishes appending the current row.
51: 	DUCKDB_API void EndRow();
52: 
53: 	// Append functions
54: 	template <class T>
55: 	void Append(T value) {
56: 		throw Exception("Undefined type for Appender::Append!");
57: 	}
58: 
59: 	DUCKDB_API void Append(const char *value, uint32_t length);
60: 
61: 	// prepared statements
62: 	template <typename... Args>
63: 	void AppendRow(Args... args) {
64: 		BeginRow();
65: 		AppendRowRecursive(args...);
66: 	}
67: 
68: 	//! Commit the changes made by the appender.
69: 	DUCKDB_API void Flush();
70: 	//! Flush the changes made by the appender and close it. The appender cannot be used after this point
71: 	DUCKDB_API void Close();
72: 
73: 	DUCKDB_API vector<LogicalType> &GetTypes() {
74: 		return types;
75: 	}
76: 	DUCKDB_API idx_t CurrentColumn() {
77: 		return column;
78: 	}
79: 
80: private:
81: 	void InitializeChunk();
82: 	void FlushChunk();
83: 
84: 	template <class T>
85: 	void AppendValueInternal(T value);
86: 	template <class SRC, class DST>
87: 	void AppendValueInternal(Vector &vector, SRC input);
88: 
89: 	void AppendRowRecursive() {
90: 		EndRow();
91: 	}
92: 
93: 	template <typename T, typename... Args>
94: 	void AppendRowRecursive(T value, Args... args) {
95: 		Append<T>(value);
96: 		AppendRowRecursive(args...);
97: 	}
98: 
99: 	void AppendValue(const Value &value);
100: };
101: 
102: template <>
103: void DUCKDB_API Appender::Append(bool value);
104: template <>
105: void DUCKDB_API Appender::Append(int8_t value);
106: template <>
107: void DUCKDB_API Appender::Append(int16_t value);
108: template <>
109: void DUCKDB_API Appender::Append(int32_t value);
110: template <>
111: void DUCKDB_API Appender::Append(int64_t value);
112: template <>
113: void DUCKDB_API Appender::Append(uint8_t value);
114: template <>
115: void DUCKDB_API Appender::Append(uint16_t value);
116: template <>
117: void DUCKDB_API Appender::Append(uint32_t value);
118: template <>
119: void DUCKDB_API Appender::Append(uint64_t value);
120: template <>
121: void DUCKDB_API Appender::Append(float value);
122: template <>
123: void DUCKDB_API Appender::Append(double value);
124: template <>
125: void DUCKDB_API Appender::Append(date_t value);
126: template <>
127: void DUCKDB_API Appender::Append(dtime_t value);
128: template <>
129: void DUCKDB_API Appender::Append(timestamp_t value);
130: template <>
131: void DUCKDB_API Appender::Append(const char *value);
132: template <>
133: void DUCKDB_API Appender::Append(string_t value);
134: template <>
135: void DUCKDB_API Appender::Append(Value value);
136: template <>
137: void DUCKDB_API Appender::Append(std::nullptr_t value);
138: 
139: } // namespace duckdb
[end of src/include/duckdb/main/appender.hpp]
[start of src/main/CMakeLists.txt]
1: add_subdirectory(relation)
2: 
3: if(FORCE_QUERY_LOG)
4:   add_definitions(-DDUCKDB_FORCE_QUERY_LOG="\""${FORCE_QUERY_LOG}"\"")
5: endif()
6: 
7: set(DUCKDB_MAIN_FILES
8:     appender.cpp
9:     client_context.cpp
10:     config.cpp
11:     connection.cpp
12:     database.cpp
13:     materialized_query_result.cpp
14:     prepared_statement.cpp
15:     prepared_statement_data.cpp
16:     relation.cpp
17:     query_profiler.cpp
18:     query_result.cpp
19:     stream_query_result.cpp)
20: 
21: if(NOT CLANG_TIDY)
22:   set(DUCKDB_MAIN_FILES ${DUCKDB_MAIN_FILES} duckdb-c.cpp)
23: endif()
24: 
25: add_library_unity(duckdb_main OBJECT ${DUCKDB_MAIN_FILES})
26: set(ALL_OBJECT_FILES
27:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_main>
28:     PARENT_SCOPE)
[end of src/main/CMakeLists.txt]
[start of src/main/appender.cpp]
1: #include "duckdb/main/appender.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
4: #include "duckdb/common/exception.hpp"
5: #include "duckdb/main/connection.hpp"
6: #include "duckdb/main/client_context.hpp"
7: #include "duckdb/main/database.hpp"
8: #include "duckdb/storage/data_table.hpp"
9: #include "duckdb/common/string_util.hpp"
10: #include "duckdb/common/operator/cast_operators.hpp"
11: #include "duckdb/common/operator/string_cast.hpp"
12: 
13: namespace duckdb {
14: 
15: Appender::Appender(Connection &con, const string &schema_name, const string &table_name)
16:     : context(con.context), column(0) {
17: 	description = con.TableInfo(schema_name, table_name);
18: 	if (!description) {
19: 		// table could not be found
20: 		throw CatalogException(StringUtil::Format("Table \"%s.%s\" could not be found", schema_name, table_name));
21: 	}
22: 	for (auto &column : description->columns) {
23: 		types.push_back(column.type);
24: 	}
25: 	InitializeChunk();
26: }
27: 
28: Appender::Appender(Connection &con, const string &table_name) : Appender(con, DEFAULT_SCHEMA, table_name) {
29: }
30: 
31: Appender::~Appender() {
32: 	// flush any remaining chunks
33: 	// wrapped in a try/catch because Close() can throw if the table was dropped in the meantime
34: 	try {
35: 		Close();
36: 	} catch (...) {
37: 	}
38: }
39: 
40: void Appender::InitializeChunk() {
41: 	chunk = make_unique<DataChunk>();
42: 	chunk->Initialize(types);
43: }
44: 
45: void Appender::BeginRow() {
46: }
47: 
48: void Appender::EndRow() {
49: 	// check that all rows have been appended to
50: 	if (column != chunk->ColumnCount()) {
51: 		throw InvalidInputException("Call to EndRow before all rows have been appended to!");
52: 	}
53: 	column = 0;
54: 	chunk->SetCardinality(chunk->size() + 1);
55: 	if (chunk->size() >= STANDARD_VECTOR_SIZE) {
56: 		FlushChunk();
57: 	}
58: }
59: 
60: template <class SRC, class DST>
61: void Appender::AppendValueInternal(Vector &col, SRC input) {
62: 	FlatVector::GetData<DST>(col)[chunk->size()] = Cast::Operation<SRC, DST>(input);
63: }
64: 
65: template <class T>
66: void Appender::AppendValueInternal(T input) {
67: 	if (column >= types.size()) {
68: 		throw InvalidInputException("Too many appends for chunk!");
69: 	}
70: 	auto &col = chunk->data[column];
71: 	switch (col.GetType().InternalType()) {
72: 	case PhysicalType::BOOL:
73: 		AppendValueInternal<T, bool>(col, input);
74: 		break;
75: 	case PhysicalType::UINT8:
76: 		AppendValueInternal<T, uint8_t>(col, input);
77: 		break;
78: 	case PhysicalType::INT8:
79: 		AppendValueInternal<T, int8_t>(col, input);
80: 		break;
81: 	case PhysicalType::UINT16:
82: 		AppendValueInternal<T, uint16_t>(col, input);
83: 		break;
84: 	case PhysicalType::INT16:
85: 		AppendValueInternal<T, int16_t>(col, input);
86: 		break;
87: 	case PhysicalType::UINT32:
88: 		AppendValueInternal<T, uint32_t>(col, input);
89: 		break;
90: 	case PhysicalType::INT32:
91: 		AppendValueInternal<T, int32_t>(col, input);
92: 		break;
93: 	case PhysicalType::UINT64:
94: 		AppendValueInternal<T, uint64_t>(col, input);
95: 		break;
96: 	case PhysicalType::INT64:
97: 		AppendValueInternal<T, int64_t>(col, input);
98: 		break;
99: 	case PhysicalType::FLOAT:
100: 		AppendValueInternal<T, float>(col, input);
101: 		break;
102: 	case PhysicalType::DOUBLE:
103: 		AppendValueInternal<T, double>(col, input);
104: 		break;
105: 	case PhysicalType::VARCHAR:
106: 		FlatVector::GetData<string_t>(col)[chunk->size()] = StringCast::Operation<T>(input, col);
107: 		break;
108: 	default:
109: 		AppendValue(Value::CreateValue<T>(input));
110: 		return;
111: 	}
112: 	column++;
113: }
114: 
115: template <>
116: void Appender::Append(bool value) {
117: 	AppendValueInternal<bool>(value);
118: }
119: 
120: template <>
121: void Appender::Append(int8_t value) {
122: 	AppendValueInternal<int8_t>(value);
123: }
124: 
125: template <>
126: void Appender::Append(int16_t value) {
127: 	AppendValueInternal<int16_t>(value);
128: }
129: 
130: template <>
131: void Appender::Append(int32_t value) {
132: 	AppendValueInternal<int32_t>(value);
133: }
134: 
135: template <>
136: void Appender::Append(int64_t value) {
137: 	AppendValueInternal<int64_t>(value);
138: }
139: 
140: template <>
141: void Appender::Append(uint8_t value) {
142: 	AppendValueInternal<uint8_t>(value);
143: }
144: 
145: template <>
146: void Appender::Append(uint16_t value) {
147: 	AppendValueInternal<uint16_t>(value);
148: }
149: 
150: template <>
151: void Appender::Append(uint32_t value) {
152: 	AppendValueInternal<uint32_t>(value);
153: }
154: 
155: template <>
156: void Appender::Append(uint64_t value) {
157: 	AppendValueInternal<uint64_t>(value);
158: }
159: 
160: template <>
161: void Appender::Append(const char *value) {
162: 	AppendValueInternal<string_t>(string_t(value));
163: }
164: 
165: void Appender::Append(const char *value, uint32_t length) {
166: 	AppendValueInternal<string_t>(string_t(value, length));
167: }
168: 
169: template <>
170: void Appender::Append(string_t value) {
171: 	AppendValueInternal<string_t>(value);
172: }
173: 
174: template <>
175: void Appender::Append(float value) {
176: 	if (!Value::FloatIsValid(value)) {
177: 		throw InvalidInputException("Float value is out of range!");
178: 	}
179: 	AppendValueInternal<float>(value);
180: }
181: 
182: template <>
183: void Appender::Append(double value) {
184: 	if (!Value::DoubleIsValid(value)) {
185: 		throw InvalidInputException("Double value is out of range!");
186: 	}
187: 	AppendValueInternal<double>(value);
188: }
189: 
190: template <>
191: void Appender::Append(date_t value) {
192: 	AppendValueInternal<int32_t>(value.days);
193: }
194: 
195: template <>
196: void Appender::Append(dtime_t value) {
197: 	AppendValueInternal<int64_t>(value.micros);
198: }
199: 
200: template <>
201: void Appender::Append(timestamp_t value) {
202: 	AppendValueInternal<int64_t>(value.value);
203: }
204: 
205: template <>
206: void Appender::Append(Value value) { // NOLINT: template shtuff
207: 	if (column >= chunk->ColumnCount()) {
208: 		throw InvalidInputException("Too many appends for chunk!");
209: 	}
210: 	AppendValue(value);
211: }
212: 
213: template <>
214: void Appender::Append(std::nullptr_t value) {
215: 	if (column >= chunk->ColumnCount()) {
216: 		throw InvalidInputException("Too many appends for chunk!");
217: 	}
218: 	auto &col = chunk->data[column++];
219: 	FlatVector::SetNull(col, chunk->size(), true);
220: }
221: 
222: void Appender::AppendValue(const Value &value) {
223: 	chunk->SetValue(column, chunk->size(), value);
224: 	column++;
225: }
226: 
227: void Appender::FlushChunk() {
228: 	if (chunk->size() == 0) {
229: 		return;
230: 	}
231: 	collection.Append(move(chunk));
232: 	InitializeChunk();
233: 	if (collection.ChunkCount() >= FLUSH_COUNT) {
234: 		Flush();
235: 	}
236: }
237: 
238: void Appender::Flush() {
239: 	// check that all vectors have the same length before appending
240: 	if (column != 0) {
241: 		throw InvalidInputException("Failed to Flush appender: incomplete append to row!");
242: 	}
243: 
244: 	FlushChunk();
245: 	if (collection.Count() == 0) {
246: 		return;
247: 	}
248: 	context->Append(*description, collection);
249: 
250: 	collection.Reset();
251: 	column = 0;
252: }
253: 
254: void Appender::Close() {
255: 	if (column == 0 || column == types.size()) {
256: 		Flush();
257: 	}
258: }
259: 
260: } // namespace duckdb
[end of src/main/appender.cpp]
[start of src/main/duckdb-c.cpp]
1: #include "duckdb/common/types/date.hpp"
2: #include "duckdb/common/types/time.hpp"
3: #include "duckdb/common/types/timestamp.hpp"
4: #include "duckdb/common/arrow.hpp"
5: #include "duckdb/common/vector_operations/vector_operations.hpp"
6: #include "duckdb/main/appender.hpp"
7: #include "duckdb/main/config.hpp"
8: 
9: #include "duckdb.h"
10: #include "duckdb.hpp"
11: 
12: #include <cstring>
13: #include <cassert>
14: 
15: #ifdef _WIN32
16: #define strdup _strdup
17: #endif
18: 
19: #ifdef GetCValue
20: #undef GetCValue
21: #endif
22: 
23: using namespace duckdb;
24: 
25: static duckdb_type ConvertCPPTypeToC(LogicalType type);
26: static idx_t GetCTypeSize(duckdb_type type);
27: namespace duckdb {
28: struct DatabaseData {
29: 	DatabaseData() : database(nullptr) {
30: 	}
31: 	~DatabaseData() {
32: 		if (database) {
33: 			delete database;
34: 		}
35: 	}
36: 
37: 	DuckDB *database;
38: };
39: } // namespace duckdb
40: 
41: // config
42: duckdb_state duckdb_create_config(duckdb_config *out_config) {
43: 	if (!out_config) {
44: 		return DuckDBError;
45: 	}
46: 	DBConfig *config;
47: 	try {
48: 		config = new DBConfig();
49: 	} catch (...) { // LCOV_EXCL_START
50: 		return DuckDBError;
51: 	} // LCOV_EXCL_STOP
52: 	*out_config = (duckdb_config)config;
53: 	return DuckDBSuccess;
54: }
55: 
56: size_t duckdb_config_count() {
57: 	return DBConfig::GetOptionCount();
58: }
59: 
60: duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description) {
61: 	auto option = DBConfig::GetOptionByIndex(index);
62: 	if (!option) {
63: 		return DuckDBError;
64: 	}
65: 	if (out_name) {
66: 		*out_name = option->name;
67: 	}
68: 	if (out_description) {
69: 		*out_description = option->description;
70: 	}
71: 	return DuckDBSuccess;
72: }
73: 
74: duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option) {
75: 	if (!config || !name || !option) {
76: 		return DuckDBError;
77: 	}
78: 	auto config_option = DBConfig::GetOptionByName(name);
79: 	if (!config_option) {
80: 		return DuckDBError;
81: 	}
82: 	try {
83: 		auto db_config = (DBConfig *)config;
84: 		db_config->SetOption(*config_option, Value(option));
85: 	} catch (...) {
86: 		return DuckDBError;
87: 	}
88: 	return DuckDBSuccess;
89: }
90: 
91: void duckdb_destroy_config(duckdb_config *config) {
92: 	if (!config) {
93: 		return;
94: 	}
95: 	if (*config) {
96: 		auto db_config = (DBConfig *)*config;
97: 		delete db_config;
98: 		*config = nullptr;
99: 	}
100: }
101: 
102: duckdb_state duckdb_open_ext(const char *path, duckdb_database *out, duckdb_config config, char **error) {
103: 	auto wrapper = new DatabaseData();
104: 	try {
105: 		auto db_config = (DBConfig *)config;
106: 		wrapper->database = new DuckDB(path, db_config);
107: 	} catch (std::exception &ex) {
108: 		if (error) {
109: 			*error = strdup(ex.what());
110: 		}
111: 		delete wrapper;
112: 		return DuckDBError;
113: 	} catch (...) { // LCOV_EXCL_START
114: 		if (error) {
115: 			*error = strdup("Unknown error");
116: 		}
117: 		delete wrapper;
118: 		return DuckDBError;
119: 	} // LCOV_EXCL_STOP
120: 	*out = (duckdb_database)wrapper;
121: 	return DuckDBSuccess;
122: }
123: 
124: duckdb_state duckdb_open(const char *path, duckdb_database *out) {
125: 	return duckdb_open_ext(path, out, nullptr, nullptr);
126: }
127: 
128: void duckdb_close(duckdb_database *database) {
129: 	if (*database) {
130: 		auto wrapper = (DatabaseData *)*database;
131: 		delete wrapper;
132: 		*database = nullptr;
133: 	}
134: }
135: 
136: duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out) {
137: 	auto wrapper = (DatabaseData *)database;
138: 	Connection *connection;
139: 	try {
140: 		connection = new Connection(*wrapper->database);
141: 	} catch (...) {
142: 		return DuckDBError;
143: 	}
144: 	*out = (duckdb_connection)connection;
145: 	return DuckDBSuccess;
146: }
147: 
148: void duckdb_disconnect(duckdb_connection *connection) {
149: 	if (*connection) {
150: 		Connection *conn = (Connection *)*connection;
151: 		delete conn;
152: 		*connection = nullptr;
153: 	}
154: }
155: 
156: template <class T>
157: void WriteData(duckdb_result *out, ChunkCollection &source, idx_t col) {
158: 	idx_t row = 0;
159: 	auto target = (T *)out->columns[col].data;
160: 	for (auto &chunk : source.Chunks()) {
161: 		auto source = FlatVector::GetData<T>(chunk->data[col]);
162: 		auto &mask = FlatVector::Validity(chunk->data[col]);
163: 
164: 		for (idx_t k = 0; k < chunk->size(); k++, row++) {
165: 			if (!mask.RowIsValid(k)) {
166: 				continue;
167: 			}
168: 			target[row] = source[k];
169: 		}
170: 	}
171: }
172: 
173: static duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out) {
174: 	D_ASSERT(result);
175: 	if (!out) {
176: 		// no result to write to, only return the status
177: 		return result->success ? DuckDBSuccess : DuckDBError;
178: 	}
179: 	out->error_message = nullptr;
180: 	if (!result->success) {
181: 		// write the error message
182: 		out->error_message = strdup(result->error.c_str());
183: 		return DuckDBError;
184: 	}
185: 	// copy the data
186: 	// first write the meta data
187: 	out->column_count = result->types.size();
188: 	out->row_count = result->collection.Count();
189: 	out->rows_changed = 0;
190: 	if (out->row_count > 0 && StatementTypeReturnChanges(result->statement_type)) {
191: 		// update total changes
192: 		auto row_changes = result->GetValue(0, 0);
193: 		if (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {
194: 			out->rows_changed = row_changes.GetValue<int64_t>();
195: 		}
196: 	}
197: 	out->columns = (duckdb_column *)malloc(sizeof(duckdb_column) * out->column_count);
198: 	if (!out->columns) { // LCOV_EXCL_START
199: 		// malloc failure
200: 		return DuckDBError;
201: 	} // LCOV_EXCL_STOP
202: 
203: 	// zero initialize the columns (so we can cleanly delete it in case a malloc fails)
204: 	memset(out->columns, 0, sizeof(duckdb_column) * out->column_count);
205: 	for (idx_t i = 0; i < out->column_count; i++) {
206: 		out->columns[i].type = ConvertCPPTypeToC(result->types[i]);
207: 		out->columns[i].name = strdup(result->names[i].c_str());
208: 		out->columns[i].nullmask = (bool *)malloc(sizeof(bool) * out->row_count);
209: 		out->columns[i].data = malloc(GetCTypeSize(out->columns[i].type) * out->row_count);
210: 		if (!out->columns[i].nullmask || !out->columns[i].name || !out->columns[i].data) { // LCOV_EXCL_START
211: 			// malloc failure
212: 			return DuckDBError;
213: 		} // LCOV_EXCL_STOP
214: 		// memset data to 0 for VARCHAR columns for safe deletion later
215: 		if (result->types[i].InternalType() == PhysicalType::VARCHAR) {
216: 			memset(out->columns[i].data, 0, GetCTypeSize(out->columns[i].type) * out->row_count);
217: 		}
218: 	}
219: 	// now write the data
220: 	for (idx_t col = 0; col < out->column_count; col++) {
221: 		// first set the nullmask
222: 		idx_t row = 0;
223: 		for (auto &chunk : result->collection.Chunks()) {
224: 			for (idx_t k = 0; k < chunk->size(); k++) {
225: 				out->columns[col].nullmask[row++] = FlatVector::IsNull(chunk->data[col], k);
226: 			}
227: 		}
228: 		// then write the data
229: 		switch (result->types[col].id()) {
230: 		case LogicalTypeId::BOOLEAN:
231: 			WriteData<bool>(out, result->collection, col);
232: 			break;
233: 		case LogicalTypeId::TINYINT:
234: 			WriteData<int8_t>(out, result->collection, col);
235: 			break;
236: 		case LogicalTypeId::SMALLINT:
237: 			WriteData<int16_t>(out, result->collection, col);
238: 			break;
239: 		case LogicalTypeId::INTEGER:
240: 			WriteData<int32_t>(out, result->collection, col);
241: 			break;
242: 		case LogicalTypeId::BIGINT:
243: 			WriteData<int64_t>(out, result->collection, col);
244: 			break;
245: 		case LogicalTypeId::UTINYINT:
246: 			WriteData<uint8_t>(out, result->collection, col);
247: 			break;
248: 		case LogicalTypeId::USMALLINT:
249: 			WriteData<uint16_t>(out, result->collection, col);
250: 			break;
251: 		case LogicalTypeId::UINTEGER:
252: 			WriteData<uint32_t>(out, result->collection, col);
253: 			break;
254: 		case LogicalTypeId::UBIGINT:
255: 			WriteData<uint64_t>(out, result->collection, col);
256: 			break;
257: 		case LogicalTypeId::FLOAT:
258: 			WriteData<float>(out, result->collection, col);
259: 			break;
260: 		case LogicalTypeId::DOUBLE:
261: 			WriteData<double>(out, result->collection, col);
262: 			break;
263: 		case LogicalTypeId::VARCHAR: {
264: 			idx_t row = 0;
265: 			auto target = (const char **)out->columns[col].data;
266: 			for (auto &chunk : result->collection.Chunks()) {
267: 				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
268: 				for (idx_t k = 0; k < chunk->size(); k++) {
269: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
270: 						target[row] = (char *)malloc(source[k].GetSize() + 1);
271: 						assert(target[row]);
272: 						memcpy((void *)target[row], source[k].GetDataUnsafe(), source[k].GetSize());
273: 						auto write_arr = (char *)target[row];
274: 						write_arr[source[k].GetSize()] = '\0';
275: 					}
276: 					row++;
277: 				}
278: 			}
279: 			break;
280: 		}
281: 		case LogicalTypeId::BLOB: {
282: 			idx_t row = 0;
283: 			auto target = (duckdb_blob *)out->columns[col].data;
284: 			for (auto &chunk : result->collection.Chunks()) {
285: 				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
286: 				for (idx_t k = 0; k < chunk->size(); k++) {
287: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
288: 						target[row].data = (char *)malloc(source[k].GetSize());
289: 						target[row].size = source[k].GetSize();
290: 						assert(target[row].data);
291: 						memcpy((void *)target[row].data, source[k].GetDataUnsafe(), source[k].GetSize());
292: 					}
293: 					row++;
294: 				}
295: 			}
296: 			break;
297: 		}
298: 		case LogicalTypeId::DATE: {
299: 			idx_t row = 0;
300: 			auto target = (duckdb_date *)out->columns[col].data;
301: 			for (auto &chunk : result->collection.Chunks()) {
302: 				auto source = FlatVector::GetData<date_t>(chunk->data[col]);
303: 				for (idx_t k = 0; k < chunk->size(); k++) {
304: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
305: 						int32_t year, month, day;
306: 						Date::Convert(source[k], year, month, day);
307: 						target[row].year = year;
308: 						target[row].month = month;
309: 						target[row].day = day;
310: 					}
311: 					row++;
312: 				}
313: 			}
314: 			break;
315: 		}
316: 		case LogicalTypeId::TIME: {
317: 			idx_t row = 0;
318: 			auto target = (duckdb_time *)out->columns[col].data;
319: 			for (auto &chunk : result->collection.Chunks()) {
320: 				auto source = FlatVector::GetData<dtime_t>(chunk->data[col]);
321: 				for (idx_t k = 0; k < chunk->size(); k++) {
322: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
323: 						int32_t hour, min, sec, micros;
324: 						Time::Convert(source[k], hour, min, sec, micros);
325: 						target[row].hour = hour;
326: 						target[row].min = min;
327: 						target[row].sec = sec;
328: 						target[row].micros = micros;
329: 					}
330: 					row++;
331: 				}
332: 			}
333: 			break;
334: 		}
335: 		case LogicalTypeId::TIMESTAMP:
336: 		case LogicalTypeId::TIMESTAMP_NS:
337: 		case LogicalTypeId::TIMESTAMP_MS:
338: 		case LogicalTypeId::TIMESTAMP_SEC: {
339: 			idx_t row = 0;
340: 			auto target = (duckdb_timestamp *)out->columns[col].data;
341: 			for (auto &chunk : result->collection.Chunks()) {
342: 				auto source = FlatVector::GetData<timestamp_t>(chunk->data[col]);
343: 
344: 				for (idx_t k = 0; k < chunk->size(); k++) {
345: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
346: 						date_t date;
347: 						dtime_t time;
348: 						auto source_value = source[k];
349: 						if (result->types[col].id() == LogicalTypeId::TIMESTAMP_NS) {
350: 							source_value = Timestamp::FromEpochNanoSeconds(source[k].value);
351: 						} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_MS) {
352: 							source_value = Timestamp::FromEpochMs(source[k].value);
353: 						} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_SEC) {
354: 							source_value = Timestamp::FromEpochSeconds(source[k].value);
355: 						}
356: 						Timestamp::Convert(source_value, date, time);
357: 
358: 						int32_t year, month, day;
359: 						Date::Convert(date, year, month, day);
360: 
361: 						int32_t hour, min, sec, micros;
362: 						Time::Convert(time, hour, min, sec, micros);
363: 
364: 						target[row].date.year = year;
365: 						target[row].date.month = month;
366: 						target[row].date.day = day;
367: 						target[row].time.hour = hour;
368: 						target[row].time.min = min;
369: 						target[row].time.sec = sec;
370: 						target[row].time.micros = micros;
371: 					}
372: 					row++;
373: 				}
374: 			}
375: 			break;
376: 		}
377: 		case LogicalTypeId::HUGEINT: {
378: 			idx_t row = 0;
379: 			auto target = (duckdb_hugeint *)out->columns[col].data;
380: 			for (auto &chunk : result->collection.Chunks()) {
381: 				auto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);
382: 				for (idx_t k = 0; k < chunk->size(); k++) {
383: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
384: 						target[row].lower = source[k].lower;
385: 						target[row].upper = source[k].upper;
386: 					}
387: 					row++;
388: 				}
389: 			}
390: 			break;
391: 		}
392: 		case LogicalTypeId::INTERVAL: {
393: 			idx_t row = 0;
394: 			auto target = (duckdb_interval *)out->columns[col].data;
395: 			for (auto &chunk : result->collection.Chunks()) {
396: 				auto source = FlatVector::GetData<interval_t>(chunk->data[col]);
397: 				for (idx_t k = 0; k < chunk->size(); k++) {
398: 					if (!FlatVector::IsNull(chunk->data[col], k)) {
399: 						target[row].days = source[k].days;
400: 						target[row].months = source[k].months;
401: 						target[row].micros = source[k].micros;
402: 					}
403: 					row++;
404: 				}
405: 			}
406: 			break;
407: 		}
408: 		default:
409: 			// unsupported type for C API
410: 			D_ASSERT(0);
411: 			return DuckDBError;
412: 		}
413: 	}
414: 	return DuckDBSuccess;
415: }
416: 
417: duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out) {
418: 	Connection *conn = (Connection *)connection;
419: 	auto result = conn->Query(query);
420: 	return duckdb_translate_result(result.get(), out);
421: }
422: 
423: namespace duckdb {
424: struct ArrowResultWrapper {
425: 	ArrowResultWrapper() : result(nullptr), current_chunk(nullptr) {
426: 	}
427: 	~ArrowResultWrapper() {
428: 	}
429: 	unique_ptr<MaterializedQueryResult> result;
430: 	unique_ptr<DataChunk> current_chunk;
431: };
432: } // namespace duckdb
433: 
434: duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result) {
435: 	Connection *conn = (Connection *)connection;
436: 	auto wrapper = new ArrowResultWrapper();
437: 	wrapper->result = conn->Query(query);
438: 	*out_result = (duckdb_arrow)wrapper;
439: 	return wrapper->result->success ? DuckDBSuccess : DuckDBError;
440: }
441: 
442: duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema) {
443: 	if (!out_schema) {
444: 		return DuckDBSuccess;
445: 	}
446: 	auto wrapper = (ArrowResultWrapper *)result;
447: 	wrapper->result->ToArrowSchema((ArrowSchema *)*out_schema);
448: 	return DuckDBSuccess;
449: }
450: 
451: duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array) {
452: 	if (!out_array) {
453: 		return DuckDBSuccess;
454: 	}
455: 	auto wrapper = (ArrowResultWrapper *)result;
456: 	auto success = wrapper->result->TryFetch(wrapper->current_chunk, wrapper->result->error);
457: 	if (!success) {
458: 		return DuckDBError;
459: 	}
460: 	if (!wrapper->current_chunk || wrapper->current_chunk->size() == 0) {
461: 		return DuckDBSuccess;
462: 	}
463: 	wrapper->current_chunk->ToArrowArray((ArrowArray *)*out_array);
464: 	return DuckDBSuccess;
465: }
466: 
467: idx_t duckdb_arrow_row_count(duckdb_arrow result) {
468: 	auto wrapper = (ArrowResultWrapper *)result;
469: 	return wrapper->result->collection.Count();
470: }
471: 
472: idx_t duckdb_arrow_column_count(duckdb_arrow result) {
473: 	auto wrapper = (ArrowResultWrapper *)result;
474: 	return wrapper->result->types.size();
475: }
476: 
477: idx_t duckdb_arrow_rows_changed(duckdb_arrow result) {
478: 	auto wrapper = (ArrowResultWrapper *)result;
479: 	idx_t rows_changed = 0;
480: 	idx_t row_count = wrapper->result->collection.Count();
481: 	if (row_count > 0 && StatementTypeReturnChanges(wrapper->result->statement_type)) {
482: 		auto row_changes = wrapper->result->GetValue(0, 0);
483: 		if (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {
484: 			rows_changed = row_changes.GetValue<int64_t>();
485: 		}
486: 	}
487: 	return rows_changed;
488: }
489: 
490: const char *duckdb_query_arrow_error(duckdb_arrow result) {
491: 	auto wrapper = (ArrowResultWrapper *)result;
492: 	return strdup(wrapper->result->error.c_str());
493: }
494: 
495: void duckdb_destroy_arrow(duckdb_arrow *result) {
496: 	if (*result) {
497: 		auto wrapper = (ArrowResultWrapper *)*result;
498: 		delete wrapper;
499: 		*result = nullptr;
500: 	}
501: }
502: 
503: static void duckdb_destroy_column(duckdb_column column, idx_t count) {
504: 	if (column.data) {
505: 		if (column.type == DUCKDB_TYPE_VARCHAR) {
506: 			// varchar, delete individual strings
507: 			auto data = (char **)column.data;
508: 			for (idx_t i = 0; i < count; i++) {
509: 				if (data[i]) {
510: 					free(data[i]);
511: 				}
512: 			}
513: 		} else if (column.type == DUCKDB_TYPE_BLOB) {
514: 			// blob, delete individual blobs
515: 			auto data = (duckdb_blob *)column.data;
516: 			for (idx_t i = 0; i < count; i++) {
517: 				if (data[i].data) {
518: 					free((void *)data[i].data);
519: 				}
520: 			}
521: 		}
522: 		free(column.data);
523: 	}
524: 	if (column.nullmask) {
525: 		free(column.nullmask);
526: 	}
527: 	if (column.name) {
528: 		free(column.name);
529: 	}
530: }
531: 
532: void duckdb_destroy_result(duckdb_result *result) {
533: 	if (result->error_message) {
534: 		free(result->error_message);
535: 	}
536: 	if (result->columns) {
537: 		for (idx_t i = 0; i < result->column_count; i++) {
538: 			duckdb_destroy_column(result->columns[i], result->row_count);
539: 		}
540: 		free(result->columns);
541: 	}
542: 	memset(result, 0, sizeof(duckdb_result));
543: }
544: namespace duckdb {
545: struct PreparedStatementWrapper {
546: 	PreparedStatementWrapper() : statement(nullptr) {
547: 	}
548: 	~PreparedStatementWrapper() {
549: 	}
550: 	unique_ptr<PreparedStatement> statement;
551: 	vector<Value> values;
552: };
553: } // namespace duckdb
554: duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
555:                             duckdb_prepared_statement *out_prepared_statement) {
556: 	if (!connection || !query) {
557: 		return DuckDBError;
558: 	}
559: 	auto wrapper = new PreparedStatementWrapper();
560: 	Connection *conn = (Connection *)connection;
561: 	wrapper->statement = conn->Prepare(query);
562: 	*out_prepared_statement = (duckdb_prepared_statement)wrapper;
563: 	return wrapper->statement->success ? DuckDBSuccess : DuckDBError;
564: }
565: 
566: const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement) {
567: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
568: 	if (!wrapper || !wrapper->statement || wrapper->statement->success) {
569: 		return nullptr;
570: 	}
571: 	return strdup(wrapper->statement->error.c_str());
572: }
573: 
574: duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out) {
575: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
576: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
577: 		return DuckDBError;
578: 	}
579: 	*nparams_out = wrapper->statement->n_param;
580: 	return DuckDBSuccess;
581: }
582: 
583: static duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_statement, idx_t param_idx, Value val) {
584: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
585: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
586: 		return DuckDBError;
587: 	}
588: 	if (param_idx > wrapper->statement->n_param) {
589: 		return DuckDBError;
590: 	}
591: 	if (param_idx > wrapper->values.size()) {
592: 		wrapper->values.resize(param_idx);
593: 	}
594: 	wrapper->values[param_idx - 1] = val;
595: 	return DuckDBSuccess;
596: }
597: 
598: duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val) {
599: 	return duckdb_bind_value(prepared_statement, param_idx, Value::BOOLEAN(val));
600: }
601: 
602: duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val) {
603: 	return duckdb_bind_value(prepared_statement, param_idx, Value::TINYINT(val));
604: }
605: 
606: duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val) {
607: 	return duckdb_bind_value(prepared_statement, param_idx, Value::SMALLINT(val));
608: }
609: 
610: duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val) {
611: 	return duckdb_bind_value(prepared_statement, param_idx, Value::INTEGER(val));
612: }
613: 
614: duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val) {
615: 	return duckdb_bind_value(prepared_statement, param_idx, Value::BIGINT(val));
616: }
617: 
618: duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val) {
619: 	return duckdb_bind_value(prepared_statement, param_idx, Value::UTINYINT(val));
620: }
621: 
622: duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val) {
623: 	return duckdb_bind_value(prepared_statement, param_idx, Value::USMALLINT(val));
624: }
625: 
626: duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val) {
627: 	return duckdb_bind_value(prepared_statement, param_idx, Value::UINTEGER(val));
628: }
629: 
630: duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val) {
631: 	return duckdb_bind_value(prepared_statement, param_idx, Value::UBIGINT(val));
632: }
633: 
634: duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val) {
635: 	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
636: }
637: 
638: duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val) {
639: 	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
640: }
641: 
642: duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val) {
643: 	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
644: }
645: 
646: duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val,
647:                                         idx_t length) {
648: 	return duckdb_bind_value(prepared_statement, param_idx, Value(string(val, length)));
649: }
650: 
651: duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx, const void *data,
652:                               idx_t length) {
653: 	return duckdb_bind_value(prepared_statement, param_idx, Value::BLOB((const_data_ptr_t)data, length));
654: }
655: 
656: duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx) {
657: 	return duckdb_bind_value(prepared_statement, param_idx, Value());
658: }
659: 
660: duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement, duckdb_result *out_result) {
661: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
662: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
663: 		return DuckDBError;
664: 	}
665: 	auto result = wrapper->statement->Execute(wrapper->values, false);
666: 	D_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);
667: 	auto mat_res = (MaterializedQueryResult *)result.get();
668: 	return duckdb_translate_result(mat_res, out_result);
669: }
670: 
671: duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement, duckdb_arrow *out_result) {
672: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
673: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
674: 		return DuckDBError;
675: 	}
676: 	auto arrow_wrapper = new ArrowResultWrapper();
677: 	auto result = wrapper->statement->Execute(wrapper->values, false);
678: 	D_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);
679: 	arrow_wrapper->result =
680: 	    unique_ptr<MaterializedQueryResult>(static_cast<MaterializedQueryResult *>(result.release()));
681: 	*out_result = (duckdb_arrow)arrow_wrapper;
682: 	return arrow_wrapper->result->success ? DuckDBSuccess : DuckDBError;
683: }
684: 
685: void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement) {
686: 	if (!prepared_statement) {
687: 		return;
688: 	}
689: 	auto wrapper = (PreparedStatementWrapper *)*prepared_statement;
690: 	if (wrapper) {
691: 		delete wrapper;
692: 	}
693: 	*prepared_statement = nullptr;
694: }
695: 
696: duckdb_type ConvertCPPTypeToC(LogicalType sql_type) {
697: 	switch (sql_type.id()) {
698: 	case LogicalTypeId::BOOLEAN:
699: 		return DUCKDB_TYPE_BOOLEAN;
700: 	case LogicalTypeId::TINYINT:
701: 		return DUCKDB_TYPE_TINYINT;
702: 	case LogicalTypeId::SMALLINT:
703: 		return DUCKDB_TYPE_SMALLINT;
704: 	case LogicalTypeId::INTEGER:
705: 		return DUCKDB_TYPE_INTEGER;
706: 	case LogicalTypeId::BIGINT:
707: 		return DUCKDB_TYPE_BIGINT;
708: 	case LogicalTypeId::UTINYINT:
709: 		return DUCKDB_TYPE_UTINYINT;
710: 	case LogicalTypeId::USMALLINT:
711: 		return DUCKDB_TYPE_USMALLINT;
712: 	case LogicalTypeId::UINTEGER:
713: 		return DUCKDB_TYPE_UINTEGER;
714: 	case LogicalTypeId::UBIGINT:
715: 		return DUCKDB_TYPE_UBIGINT;
716: 	case LogicalTypeId::HUGEINT:
717: 		return DUCKDB_TYPE_HUGEINT;
718: 	case LogicalTypeId::FLOAT:
719: 		return DUCKDB_TYPE_FLOAT;
720: 	case LogicalTypeId::DOUBLE:
721: 		return DUCKDB_TYPE_DOUBLE;
722: 	case LogicalTypeId::TIMESTAMP:
723: 		return DUCKDB_TYPE_TIMESTAMP;
724: 	case LogicalTypeId::TIMESTAMP_SEC:
725: 		return DUCKDB_TYPE_TIMESTAMP_S;
726: 	case LogicalTypeId::TIMESTAMP_MS:
727: 		return DUCKDB_TYPE_TIMESTAMP_MS;
728: 	case LogicalTypeId::TIMESTAMP_NS:
729: 		return DUCKDB_TYPE_TIMESTAMP_NS;
730: 	case LogicalTypeId::DATE:
731: 		return DUCKDB_TYPE_DATE;
732: 	case LogicalTypeId::TIME:
733: 		return DUCKDB_TYPE_TIME;
734: 	case LogicalTypeId::VARCHAR:
735: 		return DUCKDB_TYPE_VARCHAR;
736: 	case LogicalTypeId::BLOB:
737: 		return DUCKDB_TYPE_BLOB;
738: 	case LogicalTypeId::INTERVAL:
739: 		return DUCKDB_TYPE_INTERVAL;
740: 	default:
741: 		D_ASSERT(0);
742: 		return DUCKDB_TYPE_INVALID;
743: 	}
744: }
745: 
746: idx_t GetCTypeSize(duckdb_type type) {
747: 	switch (type) {
748: 	case DUCKDB_TYPE_BOOLEAN:
749: 		return sizeof(bool);
750: 	case DUCKDB_TYPE_TINYINT:
751: 		return sizeof(int8_t);
752: 	case DUCKDB_TYPE_SMALLINT:
753: 		return sizeof(int16_t);
754: 	case DUCKDB_TYPE_INTEGER:
755: 		return sizeof(int32_t);
756: 	case DUCKDB_TYPE_BIGINT:
757: 		return sizeof(int64_t);
758: 	case DUCKDB_TYPE_UTINYINT:
759: 		return sizeof(uint8_t);
760: 	case DUCKDB_TYPE_USMALLINT:
761: 		return sizeof(uint16_t);
762: 	case DUCKDB_TYPE_UINTEGER:
763: 		return sizeof(uint32_t);
764: 	case DUCKDB_TYPE_UBIGINT:
765: 		return sizeof(uint64_t);
766: 	case DUCKDB_TYPE_HUGEINT:
767: 		return sizeof(duckdb_hugeint);
768: 	case DUCKDB_TYPE_FLOAT:
769: 		return sizeof(float);
770: 	case DUCKDB_TYPE_DOUBLE:
771: 		return sizeof(double);
772: 	case DUCKDB_TYPE_DATE:
773: 		return sizeof(duckdb_date);
774: 	case DUCKDB_TYPE_TIME:
775: 		return sizeof(duckdb_time);
776: 	case DUCKDB_TYPE_TIMESTAMP:
777: 	case DUCKDB_TYPE_TIMESTAMP_NS:
778: 	case DUCKDB_TYPE_TIMESTAMP_MS:
779: 	case DUCKDB_TYPE_TIMESTAMP_S:
780: 		return sizeof(duckdb_timestamp);
781: 	case DUCKDB_TYPE_VARCHAR:
782: 		return sizeof(const char *);
783: 	case DUCKDB_TYPE_BLOB:
784: 		return sizeof(duckdb_blob);
785: 	case DUCKDB_TYPE_INTERVAL:
786: 		return sizeof(duckdb_interval);
787: 	default:
788: 		// unsupported type
789: 		D_ASSERT(0);
790: 		return sizeof(const char *);
791: 	}
792: }
793: 
794: template <class T>
795: T UnsafeFetch(duckdb_result *result, idx_t col, idx_t row) {
796: 	D_ASSERT(row < result->row_count);
797: 	return ((T *)result->columns[col].data)[row];
798: }
799: 
800: static Value GetCValue(duckdb_result *result, idx_t col, idx_t row) {
801: 	if (col >= result->column_count) {
802: 		return Value();
803: 	}
804: 	if (row >= result->row_count) {
805: 		return Value();
806: 	}
807: 	if (result->columns[col].nullmask[row]) {
808: 		return Value();
809: 	}
810: 	switch (result->columns[col].type) {
811: 	case DUCKDB_TYPE_BOOLEAN:
812: 		return Value::BOOLEAN(UnsafeFetch<bool>(result, col, row));
813: 	case DUCKDB_TYPE_TINYINT:
814: 		return Value::TINYINT(UnsafeFetch<int8_t>(result, col, row));
815: 	case DUCKDB_TYPE_SMALLINT:
816: 		return Value::SMALLINT(UnsafeFetch<int16_t>(result, col, row));
817: 	case DUCKDB_TYPE_INTEGER:
818: 		return Value::INTEGER(UnsafeFetch<int32_t>(result, col, row));
819: 	case DUCKDB_TYPE_BIGINT:
820: 		return Value::BIGINT(UnsafeFetch<int64_t>(result, col, row));
821: 	case DUCKDB_TYPE_UTINYINT:
822: 		return Value::TINYINT(UnsafeFetch<uint8_t>(result, col, row));
823: 	case DUCKDB_TYPE_USMALLINT:
824: 		return Value::SMALLINT(UnsafeFetch<uint16_t>(result, col, row));
825: 	case DUCKDB_TYPE_UINTEGER:
826: 		return Value::INTEGER(UnsafeFetch<uint32_t>(result, col, row));
827: 	case DUCKDB_TYPE_UBIGINT:
828: 		return Value::BIGINT(UnsafeFetch<uint64_t>(result, col, row));
829: 	case DUCKDB_TYPE_FLOAT:
830: 		return Value(UnsafeFetch<float>(result, col, row));
831: 	case DUCKDB_TYPE_DOUBLE:
832: 		return Value(UnsafeFetch<double>(result, col, row));
833: 	case DUCKDB_TYPE_DATE: {
834: 		auto date = UnsafeFetch<duckdb_date>(result, col, row);
835: 		return Value::DATE(date.year, date.month, date.day);
836: 	}
837: 	case DUCKDB_TYPE_TIME: {
838: 		auto time = UnsafeFetch<duckdb_time>(result, col, row);
839: 		return Value::TIME(time.hour, time.min, time.sec, time.micros);
840: 	}
841: 	case DUCKDB_TYPE_TIMESTAMP_NS:
842: 	case DUCKDB_TYPE_TIMESTAMP_MS:
843: 	case DUCKDB_TYPE_TIMESTAMP_S:
844: 	case DUCKDB_TYPE_TIMESTAMP: {
845: 		auto timestamp = UnsafeFetch<duckdb_timestamp>(result, col, row);
846: 		return Value::TIMESTAMP(timestamp.date.year, timestamp.date.month, timestamp.date.day, timestamp.time.hour,
847: 		                        timestamp.time.min, timestamp.time.sec, timestamp.time.micros);
848: 	}
849: 	case DUCKDB_TYPE_HUGEINT: {
850: 		hugeint_t val;
851: 		auto hugeint = UnsafeFetch<duckdb_hugeint>(result, col, row);
852: 		val.lower = hugeint.lower;
853: 		val.upper = hugeint.upper;
854: 		return Value::HUGEINT(val);
855: 	}
856: 	case DUCKDB_TYPE_INTERVAL: {
857: 		interval_t val;
858: 		auto interval = UnsafeFetch<duckdb_interval>(result, col, row);
859: 		val.days = interval.days;
860: 		val.months = interval.months;
861: 		val.micros = interval.micros;
862: 		return Value::INTERVAL(val);
863: 	}
864: 	case DUCKDB_TYPE_VARCHAR:
865: 		return Value(string(UnsafeFetch<const char *>(result, col, row)));
866: 	case DUCKDB_TYPE_BLOB: {
867: 		auto blob = UnsafeFetch<duckdb_blob>(result, col, row);
868: 		return Value::BLOB((const_data_ptr_t)blob.data, blob.size);
869: 	}
870: 	default:
871: 		// invalid type for C to C++ conversion
872: 		D_ASSERT(0);
873: 		return Value();
874: 	}
875: }
876: 
877: const char *duckdb_column_name(duckdb_result *result, idx_t col) {
878: 	if (!result || col >= result->column_count) {
879: 		return nullptr;
880: 	}
881: 	return result->columns[col].name;
882: }
883: 
884: bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row) {
885: 	Value val = GetCValue(result, col, row);
886: 	if (val.is_null) {
887: 		return false;
888: 	} else {
889: 		return val.GetValue<bool>();
890: 	}
891: }
892: 
893: int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row) {
894: 	Value val = GetCValue(result, col, row);
895: 	if (val.is_null) {
896: 		return 0;
897: 	} else {
898: 		return val.GetValue<int8_t>();
899: 	}
900: }
901: 
902: int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row) {
903: 	Value val = GetCValue(result, col, row);
904: 	if (val.is_null) {
905: 		return 0;
906: 	} else {
907: 		return val.GetValue<int16_t>();
908: 	}
909: }
910: 
911: int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row) {
912: 	Value val = GetCValue(result, col, row);
913: 	if (val.is_null) {
914: 		return 0;
915: 	} else {
916: 		return val.GetValue<int32_t>();
917: 	}
918: }
919: 
920: int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row) {
921: 	Value val = GetCValue(result, col, row);
922: 	if (val.is_null) {
923: 		return 0;
924: 	} else {
925: 		return val.GetValue<int64_t>();
926: 	}
927: }
928: 
929: uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row) {
930: 	Value val = GetCValue(result, col, row);
931: 	if (val.is_null) {
932: 		return 0;
933: 	} else {
934: 		return val.GetValue<uint8_t>();
935: 	}
936: }
937: 
938: uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row) {
939: 	Value val = GetCValue(result, col, row);
940: 	if (val.is_null) {
941: 		return 0;
942: 	} else {
943: 		return val.GetValue<uint16_t>();
944: 	}
945: }
946: 
947: uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row) {
948: 	Value val = GetCValue(result, col, row);
949: 	if (val.is_null) {
950: 		return 0;
951: 	} else {
952: 		return val.GetValue<uint32_t>();
953: 	}
954: }
955: 
956: uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row) {
957: 	Value val = GetCValue(result, col, row);
958: 	if (val.is_null) {
959: 		return 0;
960: 	} else {
961: 		return val.GetValue<uint64_t>();
962: 	}
963: }
964: 
965: float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row) {
966: 	Value val = GetCValue(result, col, row);
967: 	if (val.is_null) {
968: 		return 0.0;
969: 	} else {
970: 		return val.GetValue<float>();
971: 	}
972: }
973: 
974: double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row) {
975: 	Value val = GetCValue(result, col, row);
976: 	if (val.is_null) {
977: 		return 0.0;
978: 	} else {
979: 		return val.GetValue<double>();
980: 	}
981: }
982: 
983: char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row) {
984: 	Value val = GetCValue(result, col, row);
985: 	return strdup(val.ToString().c_str());
986: }
987: 
988: duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row) {
989: 	duckdb_blob blob;
990: 	Value val = GetCValue(result, col, row).CastAs(LogicalType::BLOB);
991: 	if (val.is_null) {
992: 		blob.data = nullptr;
993: 		blob.size = 0;
994: 	} else {
995: 		blob.data = malloc(val.str_value.size());
996: 		memcpy((void *)blob.data, val.str_value.c_str(), val.str_value.size());
997: 		blob.size = val.str_value.size();
998: 	}
999: 	return blob;
1000: }
1001: 
1002: void *duckdb_malloc(size_t size) {
1003: 	return malloc(size);
1004: }
1005: 
1006: void duckdb_free(void *ptr) {
1007: 	free(ptr);
1008: }
1009: 
1010: namespace duckdb {
1011: struct AppenderWrapper {
1012: 	AppenderWrapper() : appender(nullptr) {
1013: 	}
1014: 	~AppenderWrapper() {
1015: 	}
1016: 	unique_ptr<Appender> appender;
1017: 	string error;
1018: };
1019: } // namespace duckdb
1020: 
1021: duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
1022:                                     duckdb_appender *out_appender) {
1023: 	Connection *conn = (Connection *)connection;
1024: 
1025: 	if (!connection || !table || !out_appender) {
1026: 		return DuckDBError;
1027: 	}
1028: 	if (schema == nullptr) {
1029: 		schema = DEFAULT_SCHEMA;
1030: 	}
1031: 	auto wrapper = new AppenderWrapper();
1032: 	*out_appender = (duckdb_appender)wrapper;
1033: 	try {
1034: 		wrapper->appender = make_unique<Appender>(*conn, schema, table);
1035: 	} catch (std::exception &ex) {
1036: 		wrapper->error = ex.what();
1037: 		return DuckDBError;
1038: 	} catch (...) {
1039: 		wrapper->error = "Unknown create appender error";
1040: 		return DuckDBError;
1041: 	}
1042: 	return DuckDBSuccess;
1043: }
1044: 
1045: duckdb_state duckdb_appender_destroy(duckdb_appender *appender) {
1046: 	if (!appender || !*appender) {
1047: 		return DuckDBError;
1048: 	}
1049: 	auto wrapper = (AppenderWrapper *)*appender;
1050: 	if (wrapper) {
1051: 		delete wrapper;
1052: 	}
1053: 	*appender = nullptr;
1054: 	return DuckDBSuccess;
1055: }
1056: 
1057: template <class FUN>
1058: duckdb_state duckdb_appender_run_function(duckdb_appender appender, FUN &&function) {
1059: 	if (!appender) {
1060: 		return DuckDBError;
1061: 	}
1062: 	auto wrapper = (AppenderWrapper *)appender;
1063: 	try {
1064: 		function(wrapper->appender.get());
1065: 	} catch (std::exception &ex) {
1066: 		wrapper->error = ex.what();
1067: 		return DuckDBError;
1068: 	} catch (...) {
1069: 		wrapper->error = "Unknown error";
1070: 		return DuckDBError;
1071: 	}
1072: 	return DuckDBSuccess;
1073: }
1074: 
1075: duckdb_state duckdb_appender_begin_row(duckdb_appender appender) {
1076: 	return duckdb_appender_run_function(appender, [&](Appender *appender) { appender->BeginRow(); });
1077: }
1078: 
1079: duckdb_state duckdb_appender_end_row(duckdb_appender appender) {
1080: 	return duckdb_appender_run_function(appender, [&](Appender *appender) { appender->EndRow(); });
1081: }
1082: 
1083: template <class T>
1084: duckdb_state duckdb_append_internal(duckdb_appender appender, T value) {
1085: 	if (!appender) {
1086: 		return DuckDBError;
1087: 	}
1088: 	auto wrapper = (AppenderWrapper *)appender;
1089: 	try {
1090: 		wrapper->appender->Append<T>(value);
1091: 	} catch (std::exception &ex) {
1092: 		wrapper->error = ex.what();
1093: 		return DuckDBError;
1094: 	} catch (...) {
1095: 		wrapper->error = "Unknown error";
1096: 		return DuckDBError;
1097: 	}
1098: 	return DuckDBSuccess;
1099: }
1100: 
1101: duckdb_state duckdb_append_bool(duckdb_appender appender, bool value) {
1102: 	return duckdb_append_internal<bool>(appender, value);
1103: }
1104: 
1105: duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value) {
1106: 	return duckdb_append_internal<int8_t>(appender, value);
1107: }
1108: 
1109: duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value) {
1110: 	return duckdb_append_internal<int16_t>(appender, value);
1111: }
1112: 
1113: duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value) {
1114: 	return duckdb_append_internal<int32_t>(appender, value);
1115: }
1116: 
1117: duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value) {
1118: 	return duckdb_append_internal<int64_t>(appender, value);
1119: }
1120: 
1121: duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value) {
1122: 	return duckdb_append_internal<uint8_t>(appender, value);
1123: }
1124: 
1125: duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value) {
1126: 	return duckdb_append_internal<uint16_t>(appender, value);
1127: }
1128: 
1129: duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value) {
1130: 	return duckdb_append_internal<uint32_t>(appender, value);
1131: }
1132: 
1133: duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value) {
1134: 	return duckdb_append_internal<uint64_t>(appender, value);
1135: }
1136: 
1137: duckdb_state duckdb_append_float(duckdb_appender appender, float value) {
1138: 	return duckdb_append_internal<float>(appender, value);
1139: }
1140: 
1141: duckdb_state duckdb_append_double(duckdb_appender appender, double value) {
1142: 	return duckdb_append_internal<double>(appender, value);
1143: }
1144: 
1145: duckdb_state duckdb_append_null(duckdb_appender appender) {
1146: 	return duckdb_append_internal<std::nullptr_t>(appender, nullptr);
1147: }
1148: 
1149: duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val) {
1150: 	return duckdb_append_internal<const char *>(appender, val);
1151: }
1152: 
1153: duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length) {
1154: 	return duckdb_append_internal<string_t>(appender, string_t(val, length));
1155: }
1156: duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length) {
1157: 	return duckdb_append_internal<string_t>(appender, string_t((const char *)data, length));
1158: }
1159: 
1160: const char *duckdb_appender_error(duckdb_appender appender) {
1161: 	if (!appender) {
1162: 		return nullptr;
1163: 	}
1164: 	auto wrapper = (AppenderWrapper *)appender;
1165: 	if (wrapper->error.empty()) {
1166: 		return nullptr;
1167: 	}
1168: 	return strdup(wrapper->error.c_str());
1169: }
1170: 
1171: duckdb_state duckdb_appender_flush(duckdb_appender appender) {
1172: 	return duckdb_appender_run_function(appender, [&](Appender *appender) { appender->Flush(); });
1173: }
1174: 
1175: duckdb_state duckdb_appender_close(duckdb_appender appender) {
1176: 	return duckdb_appender_run_function(appender, [&](Appender *appender) { appender->Close(); });
1177: }
[end of src/main/duckdb-c.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: