diff --git a/src/include/duckdb.h b/src/include/duckdb.h
index c8bf22dee3cc..a7699b701741 100644
--- a/src/include/duckdb.h
+++ b/src/include/duckdb.h
@@ -4,7 +4,6 @@
 //
 // duckdb.h
 //
-// Author: Mark Raasveldt
 //
 //===----------------------------------------------------------------------===//
 
@@ -28,6 +27,9 @@
 extern "C" {
 #endif
 
+//===--------------------------------------------------------------------===//
+// Type Information
+//===--------------------------------------------------------------------===//
 typedef uint64_t idx_t;
 
 typedef enum DUCKDB_TYPE {
@@ -76,24 +78,42 @@ typedef enum DUCKDB_TYPE {
 	DUCKDB_TYPE_BLOB
 } duckdb_type;
 
+//! Days are stored as days since 1970-01-01
+//! Use the duckdb_from_date/duckdb_to_date function to extract individual information
+typedef struct {
+	int32_t days;
+} duckdb_date;
+
 typedef struct {
 	int32_t year;
 	int8_t month;
 	int8_t day;
-} duckdb_date;
+} duckdb_date_struct;
+
+//! Time is stored as microseconds since 00:00:00
+//! Use the duckdb_from_time/duckdb_to_time function to extract individual information
+typedef struct {
+	int64_t micros;
+} duckdb_time;
 
 typedef struct {
 	int8_t hour;
 	int8_t min;
 	int8_t sec;
 	int32_t micros;
-} duckdb_time;
+} duckdb_time_struct;
 
+//! Timestamps are stored as microseconds since 1970-01-01
+//! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information
 typedef struct {
-	duckdb_date date;
-	duckdb_time time;
+	int64_t micros;
 } duckdb_timestamp;
 
+typedef struct {
+	duckdb_date_struct date;
+	duckdb_time_struct time;
+} duckdb_timestamp_struct;
+
 typedef struct {
 	int32_t months;
 	int32_t days;
@@ -131,47 +151,14 @@ typedef void *duckdb_prepared_statement;
 typedef void *duckdb_appender;
 typedef void *duckdb_arrow;
 typedef void *duckdb_config;
-// we don't need to spell out the schema/array in here
-// because it's a common interface, users can consume
-// the data in their own logic.
 typedef void *duckdb_arrow_schema;
 typedef void *duckdb_arrow_array;
 
 typedef enum { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;
 
-//! query duckdb result as arrow data structure
-DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);
-//! get arrow schema
-DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);
-//! get arrow data array
-//! This function can be called multiple time to get next chunks, which will free the previous out_array.
-//! So consume the out_array before call this function again
-DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);
-//! get arrow row count
-DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);
-//! get arrow column count
-DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);
-//! get arrow rows changed
-DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);
-//! get arrow error message
-DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);
-//! Destroys the arrow result
-DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
-
-//! Creates a DuckDB configuration object. The created object must be destroyed with duckdb_destroy_config.
-DUCKDB_API duckdb_state duckdb_create_config(duckdb_config *out_config);
-//! Returns the amount of config options available.
-//! Should not be called in a loop as it internally loops over all the options.
-DUCKDB_API size_t duckdb_config_count();
-//! Returns the config name and description for the config at the specified index
-//! The result MUST NOT be freed
-//! Returns failure if the index is out of range (i.e. >= duckdb_config_count)
-DUCKDB_API duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description);
-//! Sets the specified config option for the configuration
-DUCKDB_API duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option);
-//! Destroys a config object created with duckdb_create_config
-DUCKDB_API void duckdb_destroy_config(duckdb_config *config);
-
+//===--------------------------------------------------------------------===//
+// Open/Connect
+//===--------------------------------------------------------------------===//
 //! Opens a database file at the given path (nullptr for in-memory). Returns DuckDBSuccess on success, or DuckDBError on
 //! failure. [OUT: database]
 DUCKDB_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);
@@ -196,7 +183,28 @@ DUCKDB_API void duckdb_destroy_result(duckdb_result *result);
 //! the column names will automatically be destroyed when the result is destroyed.
 DUCKDB_API const char *duckdb_column_name(duckdb_result *result, idx_t col);
 
-// SAFE fetch functions
+//===--------------------------------------------------------------------===//
+// Configuration
+//===--------------------------------------------------------------------===//
+//! Creates a DuckDB configuration object. The created object must be destroyed with duckdb_destroy_config.
+DUCKDB_API duckdb_state duckdb_create_config(duckdb_config *out_config);
+//! Returns the amount of config options available.
+//! Should not be called in a loop as it internally loops over all the options.
+DUCKDB_API size_t duckdb_config_count();
+//! Returns the config name and description for the config at the specified index
+//! The result MUST NOT be freed
+//! Returns failure if the index is out of range (i.e. >= duckdb_config_count)
+DUCKDB_API duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description);
+//! Sets the specified config option for the configuration
+DUCKDB_API duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option);
+//! Destroys a config object created with duckdb_create_config
+DUCKDB_API void duckdb_destroy_config(duckdb_config *config);
+
+//===--------------------------------------------------------------------===//
+// Result Functions
+//===--------------------------------------------------------------------===//
+
+// Safe fetch functions
 // These functions will perform conversions if necessary. On failure (e.g. if conversion cannot be performed) a special
 // value is returned.
 
@@ -210,18 +218,30 @@ DUCKDB_API int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t ro
 DUCKDB_API int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row);
 //! Converts the specified value to an int64_t. Returns 0 on failure or NULL.
 DUCKDB_API int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row);
+
 //! Converts the specified value to an uint8_t. Returns 0 on failure or NULL.
 DUCKDB_API uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row);
 //! Converts the specified value to an uint16_t. Returns 0 on failure or NULL.
 DUCKDB_API uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row);
-//! Converts the specified value to an uint64_t. Returns 0 on failure or NULL.
+//! Converts the specified value to an uint32_t. Returns 0 on failure or NULL.
 DUCKDB_API uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row);
 //! Converts the specified value to an uint64_t. Returns 0 on failure or NULL.
 DUCKDB_API uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row);
+
 //! Converts the specified value to a float. Returns 0.0 on failure or NULL.
 DUCKDB_API float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row);
 //! Converts the specified value to a double. Returns 0.0 on failure or NULL.
 DUCKDB_API double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row);
+
+//! Converts the specified value to an uint16_t. Returns 0 on failure or NULL.
+DUCKDB_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);
+//! Converts the specified value to an duckdb_time. Returns 0 on failure or NULL.
+DUCKDB_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);
+//! Converts the specified value to an duckdb_timestamp. Returns 0 on failure or NULL.
+DUCKDB_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);
+//! Converts the specified value to an duckdb_interval. Returns 0 on failure or NULL.
+DUCKDB_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);
+
 //! Converts the specified value to a string. Returns nullptr on failure or NULL. The result must be freed with
 //! duckdb_free.
 DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);
@@ -229,14 +249,30 @@ DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t ro
 //! resulting "blob.data" must be freed with duckdb_free.
 DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);
 
+//===--------------------------------------------------------------------===//
+// Helpers
+//===--------------------------------------------------------------------===//
 //! Allocate [size] amounts of memory using the duckdb internal malloc function. Any memory allocated in this manner
 //! should be freed using duckdb_free
 DUCKDB_API void *duckdb_malloc(size_t size);
 //! Free a value returned from duckdb_malloc, duckdb_value_varchar or duckdb_value_blob
 DUCKDB_API void duckdb_free(void *ptr);
 
-// Prepared Statements
+//===--------------------------------------------------------------------===//
+// Date/Time/Timestamp Helpers
+//===--------------------------------------------------------------------===//
+DUCKDB_API duckdb_date_struct duckdb_from_date(duckdb_date date);
+DUCKDB_API duckdb_date duckdb_to_date(duckdb_date_struct date);
+
+DUCKDB_API duckdb_time_struct duckdb_from_time(duckdb_time time);
+DUCKDB_API duckdb_time duckdb_to_time(duckdb_time_struct time);
 
+DUCKDB_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp time);
+DUCKDB_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct time);
+
+//===--------------------------------------------------------------------===//
+// Prepared Statements
+//===--------------------------------------------------------------------===//
 //! prepares the specified SQL query in the specified connection handle. [OUT: prepared statement descriptor]
 DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
                                        duckdb_prepared_statement *out_prepared_statement);
@@ -250,12 +286,24 @@ DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_stat
 DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
 DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);
 DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);
-DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
-DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
+
+DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);
+DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val);
 DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);
 DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);
+
 DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);
 DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);
+
+DUCKDB_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                         duckdb_date val);
+DUCKDB_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                         duckdb_time val);
+DUCKDB_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                              duckdb_timestamp val);
+DUCKDB_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                             duckdb_interval val);
+
 DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,
                                             const char *val);
 DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,
@@ -275,6 +323,9 @@ DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement
 //! Destroys the specified prepared statement descriptor
 DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);
 
+//===--------------------------------------------------------------------===//
+// Appender
+//===--------------------------------------------------------------------===//
 DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
                                                duckdb_appender *out_appender);
 
@@ -296,6 +347,11 @@ DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t
 DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);
 DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);
 
+DUCKDB_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);
+DUCKDB_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);
+DUCKDB_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);
+DUCKDB_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);
+
 DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);
 DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);
 DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);
@@ -307,6 +363,28 @@ DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);
 
 DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);
 
+//===--------------------------------------------------------------------===//
+// Arrow Interface
+//===--------------------------------------------------------------------===//
+//! query duckdb result as arrow data structure
+DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);
+//! get arrow schema
+DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);
+//! get arrow data array
+//! This function can be called multiple time to get next chunks, which will free the previous out_array.
+//! So consume the out_array before call this function again
+DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);
+//! get arrow row count
+DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);
+//! get arrow column count
+DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);
+//! get arrow rows changed
+DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);
+//! get arrow error message
+DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);
+//! Destroys the arrow result
+DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/include/duckdb/main/appender.hpp b/src/include/duckdb/main/appender.hpp
index 79cfbcf331db..241bc0240112 100644
--- a/src/include/duckdb/main/appender.hpp
+++ b/src/include/duckdb/main/appender.hpp
@@ -128,6 +128,8 @@ void DUCKDB_API Appender::Append(dtime_t value);
 template <>
 void DUCKDB_API Appender::Append(timestamp_t value);
 template <>
+void DUCKDB_API Appender::Append(interval_t value);
+template <>
 void DUCKDB_API Appender::Append(const char *value);
 template <>
 void DUCKDB_API Appender::Append(string_t value);
diff --git a/src/include/duckdb/main/capi_internal.hpp b/src/include/duckdb/main/capi_internal.hpp
new file mode 100644
index 000000000000..8b4b5bee4d0b
--- /dev/null
+++ b/src/include/duckdb/main/capi_internal.hpp
@@ -0,0 +1,53 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// duckdb/main/capi_internal.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include "duckdb.h"
+#include "duckdb.hpp"
+#include "duckdb/common/types/data_chunk.hpp"
+#include "duckdb/main/appender.hpp"
+#include <cstring>
+#include <cassert>
+
+#ifdef _WIN32
+#ifndef strdup
+#define strdup _strdup
+#endif
+#endif
+
+#ifdef GetCValue
+#undef GetCValue
+#endif
+
+namespace duckdb {
+
+struct DatabaseData {
+	unique_ptr<DuckDB> database;
+};
+
+struct PreparedStatementWrapper {
+	unique_ptr<PreparedStatement> statement;
+	vector<Value> values;
+};
+
+struct ArrowResultWrapper {
+	unique_ptr<MaterializedQueryResult> result;
+	unique_ptr<DataChunk> current_chunk;
+};
+
+struct AppenderWrapper {
+	unique_ptr<Appender> appender;
+	string error;
+};
+
+duckdb_type ConvertCPPTypeToC(LogicalType type);
+idx_t GetCTypeSize(duckdb_type type);
+duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out);
+
+} // namespace duckdb
diff --git a/src/main/CMakeLists.txt b/src/main/CMakeLists.txt
index c05c128fb547..e9b0bed83c5c 100644
--- a/src/main/CMakeLists.txt
+++ b/src/main/CMakeLists.txt
@@ -1,28 +1,27 @@
+if(NOT CLANG_TIDY)
+  add_subdirectory(capi)
+endif()
 add_subdirectory(relation)
 
 if(FORCE_QUERY_LOG)
   add_definitions(-DDUCKDB_FORCE_QUERY_LOG="\""${FORCE_QUERY_LOG}"\"")
 endif()
 
-set(DUCKDB_MAIN_FILES
-    appender.cpp
-    client_context.cpp
-    config.cpp
-    connection.cpp
-    database.cpp
-    materialized_query_result.cpp
-    prepared_statement.cpp
-    prepared_statement_data.cpp
-    relation.cpp
-    query_profiler.cpp
-    query_result.cpp
-    stream_query_result.cpp)
-
-if(NOT CLANG_TIDY)
-  set(DUCKDB_MAIN_FILES ${DUCKDB_MAIN_FILES} duckdb-c.cpp)
-endif()
-
-add_library_unity(duckdb_main OBJECT ${DUCKDB_MAIN_FILES})
+add_library_unity(
+  duckdb_main
+  OBJECT
+  appender.cpp
+  client_context.cpp
+  config.cpp
+  connection.cpp
+  database.cpp
+  materialized_query_result.cpp
+  prepared_statement.cpp
+  prepared_statement_data.cpp
+  relation.cpp
+  query_profiler.cpp
+  query_result.cpp
+  stream_query_result.cpp)
 set(ALL_OBJECT_FILES
     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_main>
     PARENT_SCOPE)
diff --git a/src/main/appender.cpp b/src/main/appender.cpp
index 880d8c6957d6..210e64bdff98 100644
--- a/src/main/appender.cpp
+++ b/src/main/appender.cpp
@@ -202,6 +202,11 @@ void Appender::Append(timestamp_t value) {
 	AppendValueInternal<int64_t>(value.value);
 }
 
+template <>
+void Appender::Append(interval_t value) {
+	AppendValueInternal<interval_t>(value);
+}
+
 template <>
 void Appender::Append(Value value) { // NOLINT: template shtuff
 	if (column >= chunk->ColumnCount()) {
diff --git a/src/main/capi/CMakeLists.txt b/src/main/capi/CMakeLists.txt
new file mode 100644
index 000000000000..314b9d5bfafd
--- /dev/null
+++ b/src/main/capi/CMakeLists.txt
@@ -0,0 +1,16 @@
+add_library_unity(
+  duckdb_main_capi
+  OBJECT
+  appender-c.cpp
+  arrow-c.cpp
+  config-c.cpp
+  datetime-c.cpp
+  duckdb-c.cpp
+  helper-c.cpp
+  prepared-c.cpp
+  result-c.cpp
+  value-c.cpp)
+
+set(ALL_OBJECT_FILES
+    ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_main_capi>
+    PARENT_SCOPE)
diff --git a/src/main/capi/appender-c.cpp b/src/main/capi/appender-c.cpp
new file mode 100644
index 000000000000..eb07c8a42768
--- /dev/null
+++ b/src/main/capi/appender-c.cpp
@@ -0,0 +1,184 @@
+#include "duckdb/main/capi_internal.hpp"
+
+using duckdb::Appender;
+using duckdb::AppenderWrapper;
+using duckdb::Connection;
+using duckdb::date_t;
+using duckdb::dtime_t;
+using duckdb::interval_t;
+using duckdb::string_t;
+using duckdb::timestamp_t;
+
+duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
+                                    duckdb_appender *out_appender) {
+	Connection *conn = (Connection *)connection;
+
+	if (!connection || !table || !out_appender) {
+		return DuckDBError;
+	}
+	if (schema == nullptr) {
+		schema = DEFAULT_SCHEMA;
+	}
+	auto wrapper = new AppenderWrapper();
+	*out_appender = (duckdb_appender)wrapper;
+	try {
+		wrapper->appender = duckdb::make_unique<Appender>(*conn, schema, table);
+	} catch (std::exception &ex) {
+		wrapper->error = ex.what();
+		return DuckDBError;
+	} catch (...) { // LCOV_EXCL_START
+		wrapper->error = "Unknown create appender error";
+		return DuckDBError;
+	} // LCOV_EXCL_STOP
+	return DuckDBSuccess;
+}
+
+duckdb_state duckdb_appender_destroy(duckdb_appender *appender) {
+	if (!appender || !*appender) {
+		return DuckDBError;
+	}
+	auto wrapper = (AppenderWrapper *)*appender;
+	if (wrapper) {
+		delete wrapper;
+	}
+	*appender = nullptr;
+	return DuckDBSuccess;
+}
+
+template <class FUN>
+duckdb_state duckdb_appender_run_function(duckdb_appender appender, FUN &&function) {
+	if (!appender) {
+		return DuckDBError;
+	}
+	auto wrapper = (AppenderWrapper *)appender;
+	try {
+		function(*wrapper->appender);
+	} catch (std::exception &ex) {
+		wrapper->error = ex.what();
+		return DuckDBError;
+	} catch (...) { // LCOV_EXCL_START
+		wrapper->error = "Unknown error";
+		return DuckDBError;
+	} // LCOV_EXCL_STOP
+	return DuckDBSuccess;
+}
+
+const char *duckdb_appender_error(duckdb_appender appender) {
+	if (!appender) {
+		return nullptr;
+	}
+	auto wrapper = (AppenderWrapper *)appender;
+	if (wrapper->error.empty()) {
+		return nullptr;
+	}
+	return strdup(wrapper->error.c_str());
+}
+
+duckdb_state duckdb_appender_begin_row(duckdb_appender appender) {
+	return duckdb_appender_run_function(appender, [&](Appender &appender) { appender.BeginRow(); });
+}
+
+duckdb_state duckdb_appender_end_row(duckdb_appender appender) {
+	return duckdb_appender_run_function(appender, [&](Appender &appender) { appender.EndRow(); });
+}
+
+template <class T>
+duckdb_state duckdb_append_internal(duckdb_appender appender, T value) {
+	if (!appender) {
+		return DuckDBError;
+	}
+	auto *appender_instance = (AppenderWrapper *)appender;
+	try {
+		appender_instance->appender->Append<T>(value);
+	} catch (...) {
+		return DuckDBError;
+	}
+	return DuckDBSuccess;
+}
+
+duckdb_state duckdb_append_bool(duckdb_appender appender, bool value) {
+	return duckdb_append_internal<bool>(appender, value);
+}
+
+duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value) {
+	return duckdb_append_internal<int8_t>(appender, value);
+}
+
+duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value) {
+	return duckdb_append_internal<int16_t>(appender, value);
+}
+
+duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value) {
+	return duckdb_append_internal<int32_t>(appender, value);
+}
+
+duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value) {
+	return duckdb_append_internal<int64_t>(appender, value);
+}
+
+duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value) {
+	return duckdb_append_internal<uint8_t>(appender, value);
+}
+
+duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value) {
+	return duckdb_append_internal<uint16_t>(appender, value);
+}
+
+duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value) {
+	return duckdb_append_internal<uint32_t>(appender, value);
+}
+
+duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value) {
+	return duckdb_append_internal<uint64_t>(appender, value);
+}
+
+duckdb_state duckdb_append_float(duckdb_appender appender, float value) {
+	return duckdb_append_internal<float>(appender, value);
+}
+
+duckdb_state duckdb_append_double(duckdb_appender appender, double value) {
+	return duckdb_append_internal<double>(appender, value);
+}
+
+duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value) {
+	return duckdb_append_internal<date_t>(appender, date_t(value.days));
+}
+
+duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value) {
+	return duckdb_append_internal<dtime_t>(appender, dtime_t(value.micros));
+}
+
+duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value) {
+	return duckdb_append_internal<timestamp_t>(appender, timestamp_t(value.micros));
+}
+
+duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value) {
+	interval_t interval;
+	interval.months = value.months;
+	interval.days = value.days;
+	interval.micros = value.micros;
+	return duckdb_append_internal<interval_t>(appender, interval);
+}
+
+duckdb_state duckdb_append_null(duckdb_appender appender) {
+	return duckdb_append_internal<std::nullptr_t>(appender, nullptr);
+}
+
+duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val) {
+	return duckdb_append_internal<const char *>(appender, val);
+}
+
+duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length) {
+	return duckdb_append_internal<string_t>(appender, string_t(val, length));
+}
+duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length) {
+	return duckdb_append_internal<string_t>(appender, string_t((const char *)data, length));
+}
+
+duckdb_state duckdb_appender_flush(duckdb_appender appender) {
+	return duckdb_appender_run_function(appender, [&](Appender &appender) { appender.Flush(); });
+}
+
+duckdb_state duckdb_appender_close(duckdb_appender appender) {
+	return duckdb_appender_run_function(appender, [&](Appender &appender) { appender.Close(); });
+}
diff --git a/src/main/capi/arrow-c.cpp b/src/main/capi/arrow-c.cpp
new file mode 100644
index 000000000000..c2f233dcc249
--- /dev/null
+++ b/src/main/capi/arrow-c.cpp
@@ -0,0 +1,92 @@
+#include "duckdb/main/capi_internal.hpp"
+
+using duckdb::ArrowResultWrapper;
+using duckdb::Connection;
+using duckdb::DataChunk;
+using duckdb::LogicalType;
+using duckdb::MaterializedQueryResult;
+using duckdb::PreparedStatementWrapper;
+using duckdb::QueryResult;
+using duckdb::QueryResultType;
+
+duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result) {
+	Connection *conn = (Connection *)connection;
+	auto wrapper = new ArrowResultWrapper();
+	wrapper->result = conn->Query(query);
+	*out_result = (duckdb_arrow)wrapper;
+	return wrapper->result->success ? DuckDBSuccess : DuckDBError;
+}
+
+duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema) {
+	if (!out_schema) {
+		return DuckDBSuccess;
+	}
+	auto wrapper = (ArrowResultWrapper *)result;
+	wrapper->result->ToArrowSchema((ArrowSchema *)*out_schema);
+	return DuckDBSuccess;
+}
+
+duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array) {
+	if (!out_array) {
+		return DuckDBSuccess;
+	}
+	auto wrapper = (ArrowResultWrapper *)result;
+	auto success = wrapper->result->TryFetch(wrapper->current_chunk, wrapper->result->error);
+	if (!success) { // LCOV_EXCL_START
+		return DuckDBError;
+	} // LCOV_EXCL_STOP
+	if (!wrapper->current_chunk || wrapper->current_chunk->size() == 0) {
+		return DuckDBSuccess;
+	}
+	wrapper->current_chunk->ToArrowArray((ArrowArray *)*out_array);
+	return DuckDBSuccess;
+}
+
+idx_t duckdb_arrow_row_count(duckdb_arrow result) {
+	auto wrapper = (ArrowResultWrapper *)result;
+	return wrapper->result->collection.Count();
+}
+
+idx_t duckdb_arrow_column_count(duckdb_arrow result) {
+	auto wrapper = (ArrowResultWrapper *)result;
+	return wrapper->result->types.size();
+}
+
+idx_t duckdb_arrow_rows_changed(duckdb_arrow result) {
+	auto wrapper = (ArrowResultWrapper *)result;
+	idx_t rows_changed = 0;
+	idx_t row_count = wrapper->result->collection.Count();
+	if (row_count > 0 && StatementTypeReturnChanges(wrapper->result->statement_type)) {
+		auto row_changes = wrapper->result->GetValue(0, 0);
+		if (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {
+			rows_changed = row_changes.GetValue<int64_t>();
+		}
+	}
+	return rows_changed;
+}
+
+const char *duckdb_query_arrow_error(duckdb_arrow result) {
+	auto wrapper = (ArrowResultWrapper *)result;
+	return strdup(wrapper->result->error.c_str());
+}
+
+void duckdb_destroy_arrow(duckdb_arrow *result) {
+	if (*result) {
+		auto wrapper = (ArrowResultWrapper *)*result;
+		delete wrapper;
+		*result = nullptr;
+	}
+}
+
+duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement, duckdb_arrow *out_result) {
+	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
+	if (!wrapper || !wrapper->statement || !wrapper->statement->success || !out_result) {
+		return DuckDBError;
+	}
+	auto arrow_wrapper = new ArrowResultWrapper();
+	auto result = wrapper->statement->Execute(wrapper->values, false);
+	D_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);
+	arrow_wrapper->result = duckdb::unique_ptr_cast<QueryResult, MaterializedQueryResult>(move(result));
+	*out_result = (duckdb_arrow)arrow_wrapper;
+	return arrow_wrapper->result->success ? DuckDBSuccess : DuckDBError;
+}
diff --git a/src/main/capi/config-c.cpp b/src/main/capi/config-c.cpp
new file mode 100644
index 000000000000..2a89c89f51e2
--- /dev/null
+++ b/src/main/capi/config-c.cpp
@@ -0,0 +1,67 @@
+#include "duckdb/main/capi_internal.hpp"
+#include "duckdb/main/config.hpp"
+#include "duckdb/common/types/value.hpp"
+
+using duckdb::DBConfig;
+using duckdb::Value;
+
+// config
+duckdb_state duckdb_create_config(duckdb_config *out_config) {
+	if (!out_config) {
+		return DuckDBError;
+	}
+	DBConfig *config;
+	try {
+		config = new DBConfig();
+	} catch (...) { // LCOV_EXCL_START
+		return DuckDBError;
+	} // LCOV_EXCL_STOP
+	*out_config = (duckdb_config)config;
+	return DuckDBSuccess;
+}
+
+size_t duckdb_config_count() {
+	return DBConfig::GetOptionCount();
+}
+
+duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description) {
+	auto option = DBConfig::GetOptionByIndex(index);
+	if (!option) {
+		return DuckDBError;
+	}
+	if (out_name) {
+		*out_name = option->name;
+	}
+	if (out_description) {
+		*out_description = option->description;
+	}
+	return DuckDBSuccess;
+}
+
+duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option) {
+	if (!config || !name || !option) {
+		return DuckDBError;
+	}
+	auto config_option = DBConfig::GetOptionByName(name);
+	if (!config_option) {
+		return DuckDBError;
+	}
+	try {
+		auto db_config = (DBConfig *)config;
+		db_config->SetOption(*config_option, Value(option));
+	} catch (...) {
+		return DuckDBError;
+	}
+	return DuckDBSuccess;
+}
+
+void duckdb_destroy_config(duckdb_config *config) {
+	if (!config) {
+		return;
+	}
+	if (*config) {
+		auto db_config = (DBConfig *)*config;
+		delete db_config;
+		*config = nullptr;
+	}
+}
diff --git a/src/main/capi/datetime-c.cpp b/src/main/capi/datetime-c.cpp
new file mode 100644
index 000000000000..a26fa5bb74bb
--- /dev/null
+++ b/src/main/capi/datetime-c.cpp
@@ -0,0 +1,73 @@
+#include "duckdb/main/capi_internal.hpp"
+#include "duckdb/common/types/date.hpp"
+#include "duckdb/common/types/time.hpp"
+#include "duckdb/common/types/timestamp.hpp"
+
+using duckdb::Date;
+using duckdb::Time;
+using duckdb::Timestamp;
+
+using duckdb::date_t;
+using duckdb::dtime_t;
+using duckdb::timestamp_t;
+
+duckdb_date_struct duckdb_from_date(duckdb_date date) {
+	int32_t year, month, day;
+	Date::Convert(date_t(date.days), year, month, day);
+
+	duckdb_date_struct result;
+	result.year = year;
+	result.month = month;
+	result.day = day;
+	return result;
+}
+
+duckdb_date duckdb_to_date(duckdb_date_struct date) {
+	duckdb_date result;
+	result.days = Date::FromDate(date.year, date.month, date.day).days;
+	return result;
+}
+
+duckdb_time_struct duckdb_from_time(duckdb_time time) {
+	int32_t hour, minute, second, micros;
+	Time::Convert(dtime_t(time.micros), hour, minute, second, micros);
+
+	duckdb_time_struct result;
+	result.hour = hour;
+	result.min = minute;
+	result.sec = second;
+	result.micros = micros;
+	return result;
+}
+
+duckdb_time duckdb_to_time(duckdb_time_struct time) {
+	duckdb_time result;
+	result.micros = Time::FromTime(time.hour, time.min, time.sec, time.micros).micros;
+	return result;
+}
+
+duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts) {
+	date_t date;
+	dtime_t time;
+	Timestamp::Convert(timestamp_t(ts.micros), date, time);
+
+	duckdb_date ddate;
+	ddate.days = date.days;
+
+	duckdb_time dtime;
+	dtime.micros = time.micros;
+
+	duckdb_timestamp_struct result;
+	result.date = duckdb_from_date(ddate);
+	result.time = duckdb_from_time(dtime);
+	return result;
+}
+
+duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts) {
+	date_t date = date_t(duckdb_to_date(ts.date).days);
+	dtime_t time = dtime_t(duckdb_to_time(ts.time).micros);
+
+	duckdb_timestamp result;
+	result.micros = Timestamp::FromDatetime(date, time).value;
+	return result;
+}
diff --git a/src/main/capi/duckdb-c.cpp b/src/main/capi/duckdb-c.cpp
new file mode 100644
index 000000000000..cfb9d00f8055
--- /dev/null
+++ b/src/main/capi/duckdb-c.cpp
@@ -0,0 +1,111 @@
+#include "duckdb/main/capi_internal.hpp"
+
+using duckdb::Connection;
+using duckdb::DatabaseData;
+using duckdb::DBConfig;
+using duckdb::DuckDB;
+
+duckdb_state duckdb_open_ext(const char *path, duckdb_database *out, duckdb_config config, char **error) {
+	auto wrapper = new DatabaseData();
+	try {
+		auto db_config = (DBConfig *)config;
+		wrapper->database = duckdb::make_unique<DuckDB>(path, db_config);
+	} catch (std::exception &ex) {
+		if (error) {
+			*error = strdup(ex.what());
+		}
+		delete wrapper;
+		return DuckDBError;
+	} catch (...) { // LCOV_EXCL_START
+		if (error) {
+			*error = strdup("Unknown error");
+		}
+		delete wrapper;
+		return DuckDBError;
+	} // LCOV_EXCL_STOP
+	*out = (duckdb_database)wrapper;
+	return DuckDBSuccess;
+}
+
+duckdb_state duckdb_open(const char *path, duckdb_database *out) {
+	return duckdb_open_ext(path, out, nullptr, nullptr);
+}
+
+void duckdb_close(duckdb_database *database) {
+	if (database && *database) {
+		auto wrapper = (DatabaseData *)*database;
+		delete wrapper;
+		*database = nullptr;
+	}
+}
+
+duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out) {
+	if (!database || !out) {
+		return DuckDBError;
+	}
+	auto wrapper = (DatabaseData *)database;
+	Connection *connection;
+	try {
+		connection = new Connection(*wrapper->database);
+	} catch (...) { // LCOV_EXCL_START
+		return DuckDBError;
+	} // LCOV_EXCL_STOP
+	*out = (duckdb_connection)connection;
+	return DuckDBSuccess;
+}
+
+void duckdb_disconnect(duckdb_connection *connection) {
+	if (connection && *connection) {
+		Connection *conn = (Connection *)*connection;
+		delete conn;
+		*connection = nullptr;
+	}
+}
+
+duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out) {
+	Connection *conn = (Connection *)connection;
+	auto result = conn->Query(query);
+	return duckdb_translate_result(result.get(), out);
+}
+
+static void duckdb_destroy_column(duckdb_column column, idx_t count) {
+	if (column.data) {
+		if (column.type == DUCKDB_TYPE_VARCHAR) {
+			// varchar, delete individual strings
+			auto data = (char **)column.data;
+			for (idx_t i = 0; i < count; i++) {
+				if (data[i]) {
+					free(data[i]);
+				}
+			}
+		} else if (column.type == DUCKDB_TYPE_BLOB) {
+			// blob, delete individual blobs
+			auto data = (duckdb_blob *)column.data;
+			for (idx_t i = 0; i < count; i++) {
+				if (data[i].data) {
+					free((void *)data[i].data);
+				}
+			}
+		}
+		free(column.data);
+	}
+	if (column.nullmask) {
+		free(column.nullmask);
+	}
+	if (column.name) {
+		free(column.name);
+	}
+}
+
+void duckdb_destroy_result(duckdb_result *result) {
+	if (result->error_message) {
+		free(result->error_message);
+	}
+	if (result->columns) {
+		for (idx_t i = 0; i < result->column_count; i++) {
+			duckdb_destroy_column(result->columns[i], result->row_count);
+		}
+		free(result->columns);
+	}
+	memset(result, 0, sizeof(duckdb_result));
+}
diff --git a/src/main/capi/helper-c.cpp b/src/main/capi/helper-c.cpp
new file mode 100644
index 000000000000..5a2ab40fd62a
--- /dev/null
+++ b/src/main/capi/helper-c.cpp
@@ -0,0 +1,110 @@
+#include "duckdb/main/capi_internal.hpp"
+
+namespace duckdb {
+
+duckdb_type ConvertCPPTypeToC(LogicalType sql_type) {
+	switch (sql_type.id()) {
+	case LogicalTypeId::BOOLEAN:
+		return DUCKDB_TYPE_BOOLEAN;
+	case LogicalTypeId::TINYINT:
+		return DUCKDB_TYPE_TINYINT;
+	case LogicalTypeId::SMALLINT:
+		return DUCKDB_TYPE_SMALLINT;
+	case LogicalTypeId::INTEGER:
+		return DUCKDB_TYPE_INTEGER;
+	case LogicalTypeId::BIGINT:
+		return DUCKDB_TYPE_BIGINT;
+	case LogicalTypeId::UTINYINT:
+		return DUCKDB_TYPE_UTINYINT;
+	case LogicalTypeId::USMALLINT:
+		return DUCKDB_TYPE_USMALLINT;
+	case LogicalTypeId::UINTEGER:
+		return DUCKDB_TYPE_UINTEGER;
+	case LogicalTypeId::UBIGINT:
+		return DUCKDB_TYPE_UBIGINT;
+	case LogicalTypeId::HUGEINT:
+		return DUCKDB_TYPE_HUGEINT;
+	case LogicalTypeId::FLOAT:
+		return DUCKDB_TYPE_FLOAT;
+	case LogicalTypeId::DOUBLE:
+		return DUCKDB_TYPE_DOUBLE;
+	case LogicalTypeId::TIMESTAMP:
+		return DUCKDB_TYPE_TIMESTAMP;
+	case LogicalTypeId::TIMESTAMP_SEC:
+		return DUCKDB_TYPE_TIMESTAMP_S;
+	case LogicalTypeId::TIMESTAMP_MS:
+		return DUCKDB_TYPE_TIMESTAMP_MS;
+	case LogicalTypeId::TIMESTAMP_NS:
+		return DUCKDB_TYPE_TIMESTAMP_NS;
+	case LogicalTypeId::DATE:
+		return DUCKDB_TYPE_DATE;
+	case LogicalTypeId::TIME:
+		return DUCKDB_TYPE_TIME;
+	case LogicalTypeId::VARCHAR:
+		return DUCKDB_TYPE_VARCHAR;
+	case LogicalTypeId::BLOB:
+		return DUCKDB_TYPE_BLOB;
+	case LogicalTypeId::INTERVAL:
+		return DUCKDB_TYPE_INTERVAL;
+	default: // LCOV_EXCL_START
+		D_ASSERT(0);
+		return DUCKDB_TYPE_INVALID;
+	} // LCOV_EXCL_STOP
+}
+idx_t GetCTypeSize(duckdb_type type) {
+	switch (type) {
+	case DUCKDB_TYPE_BOOLEAN:
+		return sizeof(bool);
+	case DUCKDB_TYPE_TINYINT:
+		return sizeof(int8_t);
+	case DUCKDB_TYPE_SMALLINT:
+		return sizeof(int16_t);
+	case DUCKDB_TYPE_INTEGER:
+		return sizeof(int32_t);
+	case DUCKDB_TYPE_BIGINT:
+		return sizeof(int64_t);
+	case DUCKDB_TYPE_UTINYINT:
+		return sizeof(uint8_t);
+	case DUCKDB_TYPE_USMALLINT:
+		return sizeof(uint16_t);
+	case DUCKDB_TYPE_UINTEGER:
+		return sizeof(uint32_t);
+	case DUCKDB_TYPE_UBIGINT:
+		return sizeof(uint64_t);
+	case DUCKDB_TYPE_HUGEINT:
+		return sizeof(duckdb_hugeint);
+	case DUCKDB_TYPE_FLOAT:
+		return sizeof(float);
+	case DUCKDB_TYPE_DOUBLE:
+		return sizeof(double);
+	case DUCKDB_TYPE_DATE:
+		return sizeof(duckdb_date);
+	case DUCKDB_TYPE_TIME:
+		return sizeof(duckdb_time);
+	case DUCKDB_TYPE_TIMESTAMP:
+	case DUCKDB_TYPE_TIMESTAMP_NS:
+	case DUCKDB_TYPE_TIMESTAMP_MS:
+	case DUCKDB_TYPE_TIMESTAMP_S:
+		return sizeof(duckdb_timestamp);
+	case DUCKDB_TYPE_VARCHAR:
+		return sizeof(const char *);
+	case DUCKDB_TYPE_BLOB:
+		return sizeof(duckdb_blob);
+	case DUCKDB_TYPE_INTERVAL:
+		return sizeof(duckdb_interval);
+	default: // LCOV_EXCL_START
+		// unsupported type
+		D_ASSERT(0);
+		return sizeof(const char *);
+	} // LCOV_EXCL_STOP
+}
+
+} // namespace duckdb
+
+void *duckdb_malloc(size_t size) {
+	return malloc(size);
+}
+
+void duckdb_free(void *ptr) {
+	free(ptr);
+}
diff --git a/src/main/capi/prepared-c.cpp b/src/main/capi/prepared-c.cpp
new file mode 100644
index 000000000000..905f42109fee
--- /dev/null
+++ b/src/main/capi/prepared-c.cpp
@@ -0,0 +1,157 @@
+#include "duckdb/main/capi_internal.hpp"
+#include "duckdb/common/assert.hpp"
+#include "duckdb/main/query_result.hpp"
+
+using duckdb::Connection;
+using duckdb::date_t;
+using duckdb::dtime_t;
+using duckdb::MaterializedQueryResult;
+using duckdb::PreparedStatementWrapper;
+using duckdb::QueryResultType;
+using duckdb::timestamp_t;
+using duckdb::Value;
+
+duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
+                            duckdb_prepared_statement *out_prepared_statement) {
+	if (!connection || !query || !out_prepared_statement) {
+		return DuckDBError;
+	}
+	auto wrapper = new PreparedStatementWrapper();
+	Connection *conn = (Connection *)connection;
+	wrapper->statement = conn->Prepare(query);
+	*out_prepared_statement = (duckdb_prepared_statement)wrapper;
+	return wrapper->statement->success ? DuckDBSuccess : DuckDBError;
+}
+
+const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement) {
+	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
+	if (!wrapper || !wrapper->statement || wrapper->statement->success) {
+		return nullptr;
+	}
+	return strdup(wrapper->statement->error.c_str());
+}
+
+duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out) {
+	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
+	if (!wrapper || !wrapper->statement || !wrapper->statement->success || !nparams_out) {
+		return DuckDBError;
+	}
+	*nparams_out = wrapper->statement->n_param;
+	return DuckDBSuccess;
+}
+
+static duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_statement, idx_t param_idx, Value val) {
+	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
+	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
+		return DuckDBError;
+	}
+	if (param_idx > wrapper->statement->n_param) {
+		return DuckDBError;
+	}
+	if (param_idx > wrapper->values.size()) {
+		wrapper->values.resize(param_idx);
+	}
+	wrapper->values[param_idx - 1] = val;
+	return DuckDBSuccess;
+}
+
+duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::BOOLEAN(val));
+}
+
+duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::TINYINT(val));
+}
+
+duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::SMALLINT(val));
+}
+
+duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::INTEGER(val));
+}
+
+duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::BIGINT(val));
+}
+
+duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::UTINYINT(val));
+}
+
+duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::USMALLINT(val));
+}
+
+duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::UINTEGER(val));
+}
+
+duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::UBIGINT(val));
+}
+
+duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
+}
+
+duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
+}
+
+duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx, duckdb_date val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::DATE(date_t(val.days)));
+}
+
+duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx, duckdb_time val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::TIME(dtime_t(val.micros)));
+}
+
+duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,
+                                   duckdb_timestamp val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::TIMESTAMP(timestamp_t(val.micros)));
+}
+
+duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx, duckdb_interval val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::INTERVAL(val.months, val.days, val.micros));
+}
+
+duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
+}
+
+duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val,
+                                        idx_t length) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value(std::string(val, length)));
+}
+
+duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx, const void *data,
+                              idx_t length) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value::BLOB((duckdb::const_data_ptr_t)data, length));
+}
+
+duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx) {
+	return duckdb_bind_value(prepared_statement, param_idx, Value());
+}
+
+duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement, duckdb_result *out_result) {
+	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
+	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
+		return DuckDBError;
+	}
+	auto result = wrapper->statement->Execute(wrapper->values, false);
+	D_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);
+	auto mat_res = (MaterializedQueryResult *)result.get();
+	return duckdb_translate_result(mat_res, out_result);
+}
+
+void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement) {
+	if (!prepared_statement) {
+		return;
+	}
+	auto wrapper = (PreparedStatementWrapper *)*prepared_statement;
+	if (wrapper) {
+		delete wrapper;
+	}
+	*prepared_statement = nullptr;
+}
diff --git a/src/main/capi/result-c.cpp b/src/main/capi/result-c.cpp
new file mode 100644
index 000000000000..c7d85cfea4bc
--- /dev/null
+++ b/src/main/capi/result-c.cpp
@@ -0,0 +1,221 @@
+#include "duckdb/main/capi_internal.hpp"
+#include "duckdb/common/types/timestamp.hpp"
+
+namespace duckdb {
+
+template <class T>
+void WriteData(duckdb_result *out, ChunkCollection &source, idx_t col) {
+	idx_t row = 0;
+	auto target = (T *)out->columns[col].data;
+	for (auto &chunk : source.Chunks()) {
+		auto source = FlatVector::GetData<T>(chunk->data[col]);
+		auto &mask = FlatVector::Validity(chunk->data[col]);
+
+		for (idx_t k = 0; k < chunk->size(); k++, row++) {
+			if (!mask.RowIsValid(k)) {
+				continue;
+			}
+			target[row] = source[k];
+		}
+	}
+}
+
+duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out) {
+	D_ASSERT(result);
+	if (!out) {
+		// no result to write to, only return the status
+		return result->success ? DuckDBSuccess : DuckDBError;
+	}
+	memset(out, 0, sizeof(duckdb_result));
+	if (!result->success) {
+		// write the error message
+		out->error_message = strdup(result->error.c_str());
+		return DuckDBError;
+	}
+	// copy the data
+	// first write the meta data
+	out->column_count = result->types.size();
+	out->row_count = result->collection.Count();
+	out->rows_changed = 0;
+	if (out->row_count > 0 && StatementTypeReturnChanges(result->statement_type)) {
+		// update total changes
+		auto row_changes = result->GetValue(0, 0);
+		if (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {
+			out->rows_changed = row_changes.GetValue<int64_t>();
+		}
+	}
+	out->columns = (duckdb_column *)malloc(sizeof(duckdb_column) * out->column_count);
+	if (!out->columns) { // LCOV_EXCL_START
+		// malloc failure
+		return DuckDBError;
+	} // LCOV_EXCL_STOP
+
+	// zero initialize the columns (so we can cleanly delete it in case a malloc fails)
+	memset(out->columns, 0, sizeof(duckdb_column) * out->column_count);
+	for (idx_t i = 0; i < out->column_count; i++) {
+		out->columns[i].type = ConvertCPPTypeToC(result->types[i]);
+		out->columns[i].name = strdup(result->names[i].c_str());
+		out->columns[i].nullmask = (bool *)malloc(sizeof(bool) * out->row_count);
+		out->columns[i].data = malloc(GetCTypeSize(out->columns[i].type) * out->row_count);
+		if (!out->columns[i].nullmask || !out->columns[i].name || !out->columns[i].data) { // LCOV_EXCL_START
+			// malloc failure
+			return DuckDBError;
+		} // LCOV_EXCL_STOP
+		// memset data to 0 for VARCHAR columns for safe deletion later
+		if (result->types[i].InternalType() == PhysicalType::VARCHAR) {
+			memset(out->columns[i].data, 0, GetCTypeSize(out->columns[i].type) * out->row_count);
+		}
+	}
+	// now write the data
+	for (idx_t col = 0; col < out->column_count; col++) {
+		// first set the nullmask
+		idx_t row = 0;
+		for (auto &chunk : result->collection.Chunks()) {
+			for (idx_t k = 0; k < chunk->size(); k++) {
+				out->columns[col].nullmask[row++] = FlatVector::IsNull(chunk->data[col], k);
+			}
+		}
+		// then write the data
+		switch (result->types[col].id()) {
+		case LogicalTypeId::BOOLEAN:
+			WriteData<bool>(out, result->collection, col);
+			break;
+		case LogicalTypeId::TINYINT:
+			WriteData<int8_t>(out, result->collection, col);
+			break;
+		case LogicalTypeId::SMALLINT:
+			WriteData<int16_t>(out, result->collection, col);
+			break;
+		case LogicalTypeId::INTEGER:
+			WriteData<int32_t>(out, result->collection, col);
+			break;
+		case LogicalTypeId::BIGINT:
+			WriteData<int64_t>(out, result->collection, col);
+			break;
+		case LogicalTypeId::UTINYINT:
+			WriteData<uint8_t>(out, result->collection, col);
+			break;
+		case LogicalTypeId::USMALLINT:
+			WriteData<uint16_t>(out, result->collection, col);
+			break;
+		case LogicalTypeId::UINTEGER:
+			WriteData<uint32_t>(out, result->collection, col);
+			break;
+		case LogicalTypeId::UBIGINT:
+			WriteData<uint64_t>(out, result->collection, col);
+			break;
+		case LogicalTypeId::FLOAT:
+			WriteData<float>(out, result->collection, col);
+			break;
+		case LogicalTypeId::DOUBLE:
+			WriteData<double>(out, result->collection, col);
+			break;
+		case LogicalTypeId::DATE:
+			WriteData<date_t>(out, result->collection, col);
+			break;
+		case LogicalTypeId::TIME:
+			WriteData<dtime_t>(out, result->collection, col);
+			break;
+		case LogicalTypeId::TIMESTAMP:
+			WriteData<timestamp_t>(out, result->collection, col);
+			break;
+		case LogicalTypeId::VARCHAR: {
+			idx_t row = 0;
+			auto target = (const char **)out->columns[col].data;
+			for (auto &chunk : result->collection.Chunks()) {
+				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
+				for (idx_t k = 0; k < chunk->size(); k++) {
+					if (!FlatVector::IsNull(chunk->data[col], k)) {
+						target[row] = (char *)malloc(source[k].GetSize() + 1);
+						assert(target[row]);
+						memcpy((void *)target[row], source[k].GetDataUnsafe(), source[k].GetSize());
+						auto write_arr = (char *)target[row];
+						write_arr[source[k].GetSize()] = '\0';
+					}
+					row++;
+				}
+			}
+			break;
+		}
+		case LogicalTypeId::BLOB: {
+			idx_t row = 0;
+			auto target = (duckdb_blob *)out->columns[col].data;
+			for (auto &chunk : result->collection.Chunks()) {
+				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
+				for (idx_t k = 0; k < chunk->size(); k++) {
+					if (!FlatVector::IsNull(chunk->data[col], k)) {
+						target[row].data = (char *)malloc(source[k].GetSize());
+						target[row].size = source[k].GetSize();
+						assert(target[row].data);
+						memcpy((void *)target[row].data, source[k].GetDataUnsafe(), source[k].GetSize());
+					}
+					row++;
+				}
+			}
+			break;
+		}
+		case LogicalTypeId::TIMESTAMP_NS:
+		case LogicalTypeId::TIMESTAMP_MS:
+		case LogicalTypeId::TIMESTAMP_SEC: {
+			idx_t row = 0;
+			auto target = (timestamp_t *)out->columns[col].data;
+			for (auto &chunk : result->collection.Chunks()) {
+				auto source = FlatVector::GetData<timestamp_t>(chunk->data[col]);
+
+				for (idx_t k = 0; k < chunk->size(); k++) {
+					if (!FlatVector::IsNull(chunk->data[col], k)) {
+						if (result->types[col].id() == LogicalTypeId::TIMESTAMP_NS) {
+							target[row] = Timestamp::FromEpochNanoSeconds(source[k].value);
+						} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_MS) {
+							target[row] = Timestamp::FromEpochMs(source[k].value);
+						} else {
+							D_ASSERT(result->types[col].id() == LogicalTypeId::TIMESTAMP_SEC);
+							target[row] = Timestamp::FromEpochSeconds(source[k].value);
+						}
+					}
+					row++;
+				}
+			}
+			break;
+		}
+		case LogicalTypeId::HUGEINT: {
+			idx_t row = 0;
+			auto target = (duckdb_hugeint *)out->columns[col].data;
+			for (auto &chunk : result->collection.Chunks()) {
+				auto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);
+				for (idx_t k = 0; k < chunk->size(); k++) {
+					if (!FlatVector::IsNull(chunk->data[col], k)) {
+						target[row].lower = source[k].lower;
+						target[row].upper = source[k].upper;
+					}
+					row++;
+				}
+			}
+			break;
+		}
+		case LogicalTypeId::INTERVAL: {
+			idx_t row = 0;
+			auto target = (duckdb_interval *)out->columns[col].data;
+			for (auto &chunk : result->collection.Chunks()) {
+				auto source = FlatVector::GetData<interval_t>(chunk->data[col]);
+				for (idx_t k = 0; k < chunk->size(); k++) {
+					if (!FlatVector::IsNull(chunk->data[col], k)) {
+						target[row].days = source[k].days;
+						target[row].months = source[k].months;
+						target[row].micros = source[k].micros;
+					}
+					row++;
+				}
+			}
+			break;
+		}
+		default: // LCOV_EXCL_START
+			// unsupported type for C API
+			D_ASSERT(0);
+			return DuckDBError;
+		} // LCOV_EXCL_STOP
+	}
+	return DuckDBSuccess;
+}
+
+} // namespace duckdb
diff --git a/src/main/capi/value-c.cpp b/src/main/capi/value-c.cpp
new file mode 100644
index 000000000000..f879192139e4
--- /dev/null
+++ b/src/main/capi/value-c.cpp
@@ -0,0 +1,273 @@
+#include "duckdb/main/capi_internal.hpp"
+#include "duckdb/common/types/date.hpp"
+#include "duckdb/common/types/time.hpp"
+#include "duckdb/common/types/timestamp.hpp"
+
+using duckdb::const_data_ptr_t;
+using duckdb::Date;
+using duckdb::date_t;
+using duckdb::dtime_t;
+using duckdb::hugeint_t;
+using duckdb::interval_t;
+using duckdb::LogicalType;
+using duckdb::string;
+using duckdb::Time;
+using duckdb::Timestamp;
+using duckdb::timestamp_t;
+using duckdb::Value;
+
+template <class T>
+T UnsafeFetch(duckdb_result *result, idx_t col, idx_t row) {
+	D_ASSERT(row < result->row_count);
+	return ((T *)result->columns[col].data)[row];
+}
+
+static Value GetCValue(duckdb_result *result, idx_t col, idx_t row) {
+	if (col >= result->column_count) {
+		return Value();
+	}
+	if (row >= result->row_count) {
+		return Value();
+	}
+	if (result->columns[col].nullmask[row]) {
+		return Value();
+	}
+	switch (result->columns[col].type) {
+	case DUCKDB_TYPE_BOOLEAN:
+		return Value::BOOLEAN(UnsafeFetch<bool>(result, col, row));
+	case DUCKDB_TYPE_TINYINT:
+		return Value::TINYINT(UnsafeFetch<int8_t>(result, col, row));
+	case DUCKDB_TYPE_SMALLINT:
+		return Value::SMALLINT(UnsafeFetch<int16_t>(result, col, row));
+	case DUCKDB_TYPE_INTEGER:
+		return Value::INTEGER(UnsafeFetch<int32_t>(result, col, row));
+	case DUCKDB_TYPE_BIGINT:
+		return Value::BIGINT(UnsafeFetch<int64_t>(result, col, row));
+	case DUCKDB_TYPE_UTINYINT:
+		return Value::TINYINT(UnsafeFetch<uint8_t>(result, col, row));
+	case DUCKDB_TYPE_USMALLINT:
+		return Value::SMALLINT(UnsafeFetch<uint16_t>(result, col, row));
+	case DUCKDB_TYPE_UINTEGER:
+		return Value::INTEGER(UnsafeFetch<uint32_t>(result, col, row));
+	case DUCKDB_TYPE_UBIGINT:
+		return Value::BIGINT(UnsafeFetch<uint64_t>(result, col, row));
+	case DUCKDB_TYPE_FLOAT:
+		return Value(UnsafeFetch<float>(result, col, row));
+	case DUCKDB_TYPE_DOUBLE:
+		return Value(UnsafeFetch<double>(result, col, row));
+	case DUCKDB_TYPE_DATE: {
+		auto date = UnsafeFetch<duckdb_date>(result, col, row);
+		return Value::DATE(date_t(date.days));
+	}
+	case DUCKDB_TYPE_TIME: {
+		auto time = UnsafeFetch<duckdb_time>(result, col, row);
+		return Value::TIME(dtime_t(time.micros));
+	}
+	case DUCKDB_TYPE_TIMESTAMP_NS:
+	case DUCKDB_TYPE_TIMESTAMP_MS:
+	case DUCKDB_TYPE_TIMESTAMP_S:
+	case DUCKDB_TYPE_TIMESTAMP: {
+		auto timestamp = UnsafeFetch<duckdb_timestamp>(result, col, row);
+		return Value::TIMESTAMP(timestamp_t(timestamp.micros));
+	}
+	case DUCKDB_TYPE_HUGEINT: {
+		hugeint_t val;
+		auto hugeint = UnsafeFetch<duckdb_hugeint>(result, col, row);
+		val.lower = hugeint.lower;
+		val.upper = hugeint.upper;
+		return Value::HUGEINT(val);
+	}
+	case DUCKDB_TYPE_INTERVAL: {
+		interval_t val;
+		auto interval = UnsafeFetch<duckdb_interval>(result, col, row);
+		val.days = interval.days;
+		val.months = interval.months;
+		val.micros = interval.micros;
+		return Value::INTERVAL(val);
+	}
+	case DUCKDB_TYPE_VARCHAR:
+		return Value(string(UnsafeFetch<const char *>(result, col, row)));
+	case DUCKDB_TYPE_BLOB: {
+		auto blob = UnsafeFetch<duckdb_blob>(result, col, row);
+		return Value::BLOB((const_data_ptr_t)blob.data, blob.size);
+	}
+	default: // LCOV_EXCL_START
+		// invalid type for C to C++ conversion
+		D_ASSERT(0);
+		return Value();
+	} // LCOV_EXCL_STOP
+}
+
+const char *duckdb_column_name(duckdb_result *result, idx_t col) {
+	if (!result || col >= result->column_count) {
+		return nullptr;
+	}
+	return result->columns[col].name;
+}
+
+bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	if (val.is_null) {
+		return false;
+	} else {
+		return val.GetValue<bool>();
+	}
+}
+
+int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	if (val.is_null) {
+		return 0;
+	} else {
+		return val.GetValue<int8_t>();
+	}
+}
+
+int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	if (val.is_null) {
+		return 0;
+	} else {
+		return val.GetValue<int16_t>();
+	}
+}
+
+int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	if (val.is_null) {
+		return 0;
+	} else {
+		return val.GetValue<int32_t>();
+	}
+}
+
+int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	if (val.is_null) {
+		return 0;
+	} else {
+		return val.GetValue<int64_t>();
+	}
+}
+
+uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	if (val.is_null) {
+		return 0;
+	} else {
+		return val.GetValue<uint8_t>();
+	}
+}
+
+uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	if (val.is_null) {
+		return 0;
+	} else {
+		return val.GetValue<uint16_t>();
+	}
+}
+
+uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	if (val.is_null) {
+		return 0;
+	} else {
+		return val.GetValue<uint32_t>();
+	}
+}
+
+uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	if (val.is_null) {
+		return 0;
+	} else {
+		return val.GetValue<uint64_t>();
+	}
+}
+
+float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	if (val.is_null) {
+		return 0.0;
+	} else {
+		return val.GetValue<float>();
+	}
+}
+
+double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	if (val.is_null) {
+		return 0.0;
+	} else {
+		return val.GetValue<double>();
+	}
+}
+
+duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	duckdb_date date;
+	if (val.is_null) {
+		date.days = 0;
+	} else {
+		date.days = val.GetValue<date_t>().days;
+	}
+	return date;
+}
+
+duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	duckdb_time time;
+	if (val.is_null) {
+		time.micros = 0;
+	} else {
+		time.micros = val.GetValue<dtime_t>().micros;
+	}
+	return time;
+}
+
+duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	duckdb_timestamp ts;
+	if (val.is_null) {
+		ts.micros = 0;
+	} else {
+		ts.micros = val.GetValue<timestamp_t>().value;
+	}
+	return ts;
+}
+
+duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	duckdb_interval interval;
+	if (val.is_null) {
+		interval.months = 0;
+		interval.days = 0;
+		interval.micros = 0;
+	} else {
+		auto dinterval = val.GetValue<interval_t>();
+		interval.months = dinterval.months;
+		interval.days = dinterval.days;
+		interval.micros = dinterval.micros;
+	}
+	return interval;
+}
+
+char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row) {
+	Value val = GetCValue(result, col, row);
+	return strdup(val.ToString().c_str());
+}
+
+duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row) {
+	duckdb_blob blob;
+	Value val = GetCValue(result, col, row).CastAs(LogicalType::BLOB);
+	if (val.is_null) {
+		blob.data = nullptr;
+		blob.size = 0;
+	} else {
+		blob.data = malloc(val.str_value.size());
+		memcpy((void *)blob.data, val.str_value.c_str(), val.str_value.size());
+		blob.size = val.str_value.size();
+	}
+	return blob;
+}
diff --git a/src/main/duckdb-c.cpp b/src/main/duckdb-c.cpp
deleted file mode 100644
index ed6592099a21..000000000000
--- a/src/main/duckdb-c.cpp
+++ /dev/null
@@ -1,1177 +0,0 @@
-#include "duckdb/common/types/date.hpp"
-#include "duckdb/common/types/time.hpp"
-#include "duckdb/common/types/timestamp.hpp"
-#include "duckdb/common/arrow.hpp"
-#include "duckdb/common/vector_operations/vector_operations.hpp"
-#include "duckdb/main/appender.hpp"
-#include "duckdb/main/config.hpp"
-
-#include "duckdb.h"
-#include "duckdb.hpp"
-
-#include <cstring>
-#include <cassert>
-
-#ifdef _WIN32
-#define strdup _strdup
-#endif
-
-#ifdef GetCValue
-#undef GetCValue
-#endif
-
-using namespace duckdb;
-
-static duckdb_type ConvertCPPTypeToC(LogicalType type);
-static idx_t GetCTypeSize(duckdb_type type);
-namespace duckdb {
-struct DatabaseData {
-	DatabaseData() : database(nullptr) {
-	}
-	~DatabaseData() {
-		if (database) {
-			delete database;
-		}
-	}
-
-	DuckDB *database;
-};
-} // namespace duckdb
-
-// config
-duckdb_state duckdb_create_config(duckdb_config *out_config) {
-	if (!out_config) {
-		return DuckDBError;
-	}
-	DBConfig *config;
-	try {
-		config = new DBConfig();
-	} catch (...) { // LCOV_EXCL_START
-		return DuckDBError;
-	} // LCOV_EXCL_STOP
-	*out_config = (duckdb_config)config;
-	return DuckDBSuccess;
-}
-
-size_t duckdb_config_count() {
-	return DBConfig::GetOptionCount();
-}
-
-duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description) {
-	auto option = DBConfig::GetOptionByIndex(index);
-	if (!option) {
-		return DuckDBError;
-	}
-	if (out_name) {
-		*out_name = option->name;
-	}
-	if (out_description) {
-		*out_description = option->description;
-	}
-	return DuckDBSuccess;
-}
-
-duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option) {
-	if (!config || !name || !option) {
-		return DuckDBError;
-	}
-	auto config_option = DBConfig::GetOptionByName(name);
-	if (!config_option) {
-		return DuckDBError;
-	}
-	try {
-		auto db_config = (DBConfig *)config;
-		db_config->SetOption(*config_option, Value(option));
-	} catch (...) {
-		return DuckDBError;
-	}
-	return DuckDBSuccess;
-}
-
-void duckdb_destroy_config(duckdb_config *config) {
-	if (!config) {
-		return;
-	}
-	if (*config) {
-		auto db_config = (DBConfig *)*config;
-		delete db_config;
-		*config = nullptr;
-	}
-}
-
-duckdb_state duckdb_open_ext(const char *path, duckdb_database *out, duckdb_config config, char **error) {
-	auto wrapper = new DatabaseData();
-	try {
-		auto db_config = (DBConfig *)config;
-		wrapper->database = new DuckDB(path, db_config);
-	} catch (std::exception &ex) {
-		if (error) {
-			*error = strdup(ex.what());
-		}
-		delete wrapper;
-		return DuckDBError;
-	} catch (...) { // LCOV_EXCL_START
-		if (error) {
-			*error = strdup("Unknown error");
-		}
-		delete wrapper;
-		return DuckDBError;
-	} // LCOV_EXCL_STOP
-	*out = (duckdb_database)wrapper;
-	return DuckDBSuccess;
-}
-
-duckdb_state duckdb_open(const char *path, duckdb_database *out) {
-	return duckdb_open_ext(path, out, nullptr, nullptr);
-}
-
-void duckdb_close(duckdb_database *database) {
-	if (*database) {
-		auto wrapper = (DatabaseData *)*database;
-		delete wrapper;
-		*database = nullptr;
-	}
-}
-
-duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out) {
-	auto wrapper = (DatabaseData *)database;
-	Connection *connection;
-	try {
-		connection = new Connection(*wrapper->database);
-	} catch (...) {
-		return DuckDBError;
-	}
-	*out = (duckdb_connection)connection;
-	return DuckDBSuccess;
-}
-
-void duckdb_disconnect(duckdb_connection *connection) {
-	if (*connection) {
-		Connection *conn = (Connection *)*connection;
-		delete conn;
-		*connection = nullptr;
-	}
-}
-
-template <class T>
-void WriteData(duckdb_result *out, ChunkCollection &source, idx_t col) {
-	idx_t row = 0;
-	auto target = (T *)out->columns[col].data;
-	for (auto &chunk : source.Chunks()) {
-		auto source = FlatVector::GetData<T>(chunk->data[col]);
-		auto &mask = FlatVector::Validity(chunk->data[col]);
-
-		for (idx_t k = 0; k < chunk->size(); k++, row++) {
-			if (!mask.RowIsValid(k)) {
-				continue;
-			}
-			target[row] = source[k];
-		}
-	}
-}
-
-static duckdb_state duckdb_translate_result(MaterializedQueryResult *result, duckdb_result *out) {
-	D_ASSERT(result);
-	if (!out) {
-		// no result to write to, only return the status
-		return result->success ? DuckDBSuccess : DuckDBError;
-	}
-	out->error_message = nullptr;
-	if (!result->success) {
-		// write the error message
-		out->error_message = strdup(result->error.c_str());
-		return DuckDBError;
-	}
-	// copy the data
-	// first write the meta data
-	out->column_count = result->types.size();
-	out->row_count = result->collection.Count();
-	out->rows_changed = 0;
-	if (out->row_count > 0 && StatementTypeReturnChanges(result->statement_type)) {
-		// update total changes
-		auto row_changes = result->GetValue(0, 0);
-		if (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {
-			out->rows_changed = row_changes.GetValue<int64_t>();
-		}
-	}
-	out->columns = (duckdb_column *)malloc(sizeof(duckdb_column) * out->column_count);
-	if (!out->columns) { // LCOV_EXCL_START
-		// malloc failure
-		return DuckDBError;
-	} // LCOV_EXCL_STOP
-
-	// zero initialize the columns (so we can cleanly delete it in case a malloc fails)
-	memset(out->columns, 0, sizeof(duckdb_column) * out->column_count);
-	for (idx_t i = 0; i < out->column_count; i++) {
-		out->columns[i].type = ConvertCPPTypeToC(result->types[i]);
-		out->columns[i].name = strdup(result->names[i].c_str());
-		out->columns[i].nullmask = (bool *)malloc(sizeof(bool) * out->row_count);
-		out->columns[i].data = malloc(GetCTypeSize(out->columns[i].type) * out->row_count);
-		if (!out->columns[i].nullmask || !out->columns[i].name || !out->columns[i].data) { // LCOV_EXCL_START
-			// malloc failure
-			return DuckDBError;
-		} // LCOV_EXCL_STOP
-		// memset data to 0 for VARCHAR columns for safe deletion later
-		if (result->types[i].InternalType() == PhysicalType::VARCHAR) {
-			memset(out->columns[i].data, 0, GetCTypeSize(out->columns[i].type) * out->row_count);
-		}
-	}
-	// now write the data
-	for (idx_t col = 0; col < out->column_count; col++) {
-		// first set the nullmask
-		idx_t row = 0;
-		for (auto &chunk : result->collection.Chunks()) {
-			for (idx_t k = 0; k < chunk->size(); k++) {
-				out->columns[col].nullmask[row++] = FlatVector::IsNull(chunk->data[col], k);
-			}
-		}
-		// then write the data
-		switch (result->types[col].id()) {
-		case LogicalTypeId::BOOLEAN:
-			WriteData<bool>(out, result->collection, col);
-			break;
-		case LogicalTypeId::TINYINT:
-			WriteData<int8_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::SMALLINT:
-			WriteData<int16_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::INTEGER:
-			WriteData<int32_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::BIGINT:
-			WriteData<int64_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::UTINYINT:
-			WriteData<uint8_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::USMALLINT:
-			WriteData<uint16_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::UINTEGER:
-			WriteData<uint32_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::UBIGINT:
-			WriteData<uint64_t>(out, result->collection, col);
-			break;
-		case LogicalTypeId::FLOAT:
-			WriteData<float>(out, result->collection, col);
-			break;
-		case LogicalTypeId::DOUBLE:
-			WriteData<double>(out, result->collection, col);
-			break;
-		case LogicalTypeId::VARCHAR: {
-			idx_t row = 0;
-			auto target = (const char **)out->columns[col].data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
-				for (idx_t k = 0; k < chunk->size(); k++) {
-					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						target[row] = (char *)malloc(source[k].GetSize() + 1);
-						assert(target[row]);
-						memcpy((void *)target[row], source[k].GetDataUnsafe(), source[k].GetSize());
-						auto write_arr = (char *)target[row];
-						write_arr[source[k].GetSize()] = '\0';
-					}
-					row++;
-				}
-			}
-			break;
-		}
-		case LogicalTypeId::BLOB: {
-			idx_t row = 0;
-			auto target = (duckdb_blob *)out->columns[col].data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<string_t>(chunk->data[col]);
-				for (idx_t k = 0; k < chunk->size(); k++) {
-					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						target[row].data = (char *)malloc(source[k].GetSize());
-						target[row].size = source[k].GetSize();
-						assert(target[row].data);
-						memcpy((void *)target[row].data, source[k].GetDataUnsafe(), source[k].GetSize());
-					}
-					row++;
-				}
-			}
-			break;
-		}
-		case LogicalTypeId::DATE: {
-			idx_t row = 0;
-			auto target = (duckdb_date *)out->columns[col].data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<date_t>(chunk->data[col]);
-				for (idx_t k = 0; k < chunk->size(); k++) {
-					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						int32_t year, month, day;
-						Date::Convert(source[k], year, month, day);
-						target[row].year = year;
-						target[row].month = month;
-						target[row].day = day;
-					}
-					row++;
-				}
-			}
-			break;
-		}
-		case LogicalTypeId::TIME: {
-			idx_t row = 0;
-			auto target = (duckdb_time *)out->columns[col].data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<dtime_t>(chunk->data[col]);
-				for (idx_t k = 0; k < chunk->size(); k++) {
-					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						int32_t hour, min, sec, micros;
-						Time::Convert(source[k], hour, min, sec, micros);
-						target[row].hour = hour;
-						target[row].min = min;
-						target[row].sec = sec;
-						target[row].micros = micros;
-					}
-					row++;
-				}
-			}
-			break;
-		}
-		case LogicalTypeId::TIMESTAMP:
-		case LogicalTypeId::TIMESTAMP_NS:
-		case LogicalTypeId::TIMESTAMP_MS:
-		case LogicalTypeId::TIMESTAMP_SEC: {
-			idx_t row = 0;
-			auto target = (duckdb_timestamp *)out->columns[col].data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<timestamp_t>(chunk->data[col]);
-
-				for (idx_t k = 0; k < chunk->size(); k++) {
-					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						date_t date;
-						dtime_t time;
-						auto source_value = source[k];
-						if (result->types[col].id() == LogicalTypeId::TIMESTAMP_NS) {
-							source_value = Timestamp::FromEpochNanoSeconds(source[k].value);
-						} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_MS) {
-							source_value = Timestamp::FromEpochMs(source[k].value);
-						} else if (result->types[col].id() == LogicalTypeId::TIMESTAMP_SEC) {
-							source_value = Timestamp::FromEpochSeconds(source[k].value);
-						}
-						Timestamp::Convert(source_value, date, time);
-
-						int32_t year, month, day;
-						Date::Convert(date, year, month, day);
-
-						int32_t hour, min, sec, micros;
-						Time::Convert(time, hour, min, sec, micros);
-
-						target[row].date.year = year;
-						target[row].date.month = month;
-						target[row].date.day = day;
-						target[row].time.hour = hour;
-						target[row].time.min = min;
-						target[row].time.sec = sec;
-						target[row].time.micros = micros;
-					}
-					row++;
-				}
-			}
-			break;
-		}
-		case LogicalTypeId::HUGEINT: {
-			idx_t row = 0;
-			auto target = (duckdb_hugeint *)out->columns[col].data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<hugeint_t>(chunk->data[col]);
-				for (idx_t k = 0; k < chunk->size(); k++) {
-					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						target[row].lower = source[k].lower;
-						target[row].upper = source[k].upper;
-					}
-					row++;
-				}
-			}
-			break;
-		}
-		case LogicalTypeId::INTERVAL: {
-			idx_t row = 0;
-			auto target = (duckdb_interval *)out->columns[col].data;
-			for (auto &chunk : result->collection.Chunks()) {
-				auto source = FlatVector::GetData<interval_t>(chunk->data[col]);
-				for (idx_t k = 0; k < chunk->size(); k++) {
-					if (!FlatVector::IsNull(chunk->data[col], k)) {
-						target[row].days = source[k].days;
-						target[row].months = source[k].months;
-						target[row].micros = source[k].micros;
-					}
-					row++;
-				}
-			}
-			break;
-		}
-		default:
-			// unsupported type for C API
-			D_ASSERT(0);
-			return DuckDBError;
-		}
-	}
-	return DuckDBSuccess;
-}
-
-duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out) {
-	Connection *conn = (Connection *)connection;
-	auto result = conn->Query(query);
-	return duckdb_translate_result(result.get(), out);
-}
-
-namespace duckdb {
-struct ArrowResultWrapper {
-	ArrowResultWrapper() : result(nullptr), current_chunk(nullptr) {
-	}
-	~ArrowResultWrapper() {
-	}
-	unique_ptr<MaterializedQueryResult> result;
-	unique_ptr<DataChunk> current_chunk;
-};
-} // namespace duckdb
-
-duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result) {
-	Connection *conn = (Connection *)connection;
-	auto wrapper = new ArrowResultWrapper();
-	wrapper->result = conn->Query(query);
-	*out_result = (duckdb_arrow)wrapper;
-	return wrapper->result->success ? DuckDBSuccess : DuckDBError;
-}
-
-duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema) {
-	if (!out_schema) {
-		return DuckDBSuccess;
-	}
-	auto wrapper = (ArrowResultWrapper *)result;
-	wrapper->result->ToArrowSchema((ArrowSchema *)*out_schema);
-	return DuckDBSuccess;
-}
-
-duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array) {
-	if (!out_array) {
-		return DuckDBSuccess;
-	}
-	auto wrapper = (ArrowResultWrapper *)result;
-	auto success = wrapper->result->TryFetch(wrapper->current_chunk, wrapper->result->error);
-	if (!success) {
-		return DuckDBError;
-	}
-	if (!wrapper->current_chunk || wrapper->current_chunk->size() == 0) {
-		return DuckDBSuccess;
-	}
-	wrapper->current_chunk->ToArrowArray((ArrowArray *)*out_array);
-	return DuckDBSuccess;
-}
-
-idx_t duckdb_arrow_row_count(duckdb_arrow result) {
-	auto wrapper = (ArrowResultWrapper *)result;
-	return wrapper->result->collection.Count();
-}
-
-idx_t duckdb_arrow_column_count(duckdb_arrow result) {
-	auto wrapper = (ArrowResultWrapper *)result;
-	return wrapper->result->types.size();
-}
-
-idx_t duckdb_arrow_rows_changed(duckdb_arrow result) {
-	auto wrapper = (ArrowResultWrapper *)result;
-	idx_t rows_changed = 0;
-	idx_t row_count = wrapper->result->collection.Count();
-	if (row_count > 0 && StatementTypeReturnChanges(wrapper->result->statement_type)) {
-		auto row_changes = wrapper->result->GetValue(0, 0);
-		if (!row_changes.is_null && row_changes.TryCastAs(LogicalType::BIGINT)) {
-			rows_changed = row_changes.GetValue<int64_t>();
-		}
-	}
-	return rows_changed;
-}
-
-const char *duckdb_query_arrow_error(duckdb_arrow result) {
-	auto wrapper = (ArrowResultWrapper *)result;
-	return strdup(wrapper->result->error.c_str());
-}
-
-void duckdb_destroy_arrow(duckdb_arrow *result) {
-	if (*result) {
-		auto wrapper = (ArrowResultWrapper *)*result;
-		delete wrapper;
-		*result = nullptr;
-	}
-}
-
-static void duckdb_destroy_column(duckdb_column column, idx_t count) {
-	if (column.data) {
-		if (column.type == DUCKDB_TYPE_VARCHAR) {
-			// varchar, delete individual strings
-			auto data = (char **)column.data;
-			for (idx_t i = 0; i < count; i++) {
-				if (data[i]) {
-					free(data[i]);
-				}
-			}
-		} else if (column.type == DUCKDB_TYPE_BLOB) {
-			// blob, delete individual blobs
-			auto data = (duckdb_blob *)column.data;
-			for (idx_t i = 0; i < count; i++) {
-				if (data[i].data) {
-					free((void *)data[i].data);
-				}
-			}
-		}
-		free(column.data);
-	}
-	if (column.nullmask) {
-		free(column.nullmask);
-	}
-	if (column.name) {
-		free(column.name);
-	}
-}
-
-void duckdb_destroy_result(duckdb_result *result) {
-	if (result->error_message) {
-		free(result->error_message);
-	}
-	if (result->columns) {
-		for (idx_t i = 0; i < result->column_count; i++) {
-			duckdb_destroy_column(result->columns[i], result->row_count);
-		}
-		free(result->columns);
-	}
-	memset(result, 0, sizeof(duckdb_result));
-}
-namespace duckdb {
-struct PreparedStatementWrapper {
-	PreparedStatementWrapper() : statement(nullptr) {
-	}
-	~PreparedStatementWrapper() {
-	}
-	unique_ptr<PreparedStatement> statement;
-	vector<Value> values;
-};
-} // namespace duckdb
-duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
-                            duckdb_prepared_statement *out_prepared_statement) {
-	if (!connection || !query) {
-		return DuckDBError;
-	}
-	auto wrapper = new PreparedStatementWrapper();
-	Connection *conn = (Connection *)connection;
-	wrapper->statement = conn->Prepare(query);
-	*out_prepared_statement = (duckdb_prepared_statement)wrapper;
-	return wrapper->statement->success ? DuckDBSuccess : DuckDBError;
-}
-
-const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement) {
-	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
-	if (!wrapper || !wrapper->statement || wrapper->statement->success) {
-		return nullptr;
-	}
-	return strdup(wrapper->statement->error.c_str());
-}
-
-duckdb_state duckdb_nparams(duckdb_prepared_statement prepared_statement, idx_t *nparams_out) {
-	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
-	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
-		return DuckDBError;
-	}
-	*nparams_out = wrapper->statement->n_param;
-	return DuckDBSuccess;
-}
-
-static duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_statement, idx_t param_idx, Value val) {
-	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
-	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
-		return DuckDBError;
-	}
-	if (param_idx > wrapper->statement->n_param) {
-		return DuckDBError;
-	}
-	if (param_idx > wrapper->values.size()) {
-		wrapper->values.resize(param_idx);
-	}
-	wrapper->values[param_idx - 1] = val;
-	return DuckDBSuccess;
-}
-
-duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value::BOOLEAN(val));
-}
-
-duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value::TINYINT(val));
-}
-
-duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value::SMALLINT(val));
-}
-
-duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value::INTEGER(val));
-}
-
-duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value::BIGINT(val));
-}
-
-duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value::UTINYINT(val));
-}
-
-duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value::USMALLINT(val));
-}
-
-duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value::UINTEGER(val));
-}
-
-duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value::UBIGINT(val));
-}
-
-duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
-}
-
-duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
-}
-
-duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value(val));
-}
-
-duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val,
-                                        idx_t length) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value(string(val, length)));
-}
-
-duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx, const void *data,
-                              idx_t length) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value::BLOB((const_data_ptr_t)data, length));
-}
-
-duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx) {
-	return duckdb_bind_value(prepared_statement, param_idx, Value());
-}
-
-duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement, duckdb_result *out_result) {
-	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
-	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
-		return DuckDBError;
-	}
-	auto result = wrapper->statement->Execute(wrapper->values, false);
-	D_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);
-	auto mat_res = (MaterializedQueryResult *)result.get();
-	return duckdb_translate_result(mat_res, out_result);
-}
-
-duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement, duckdb_arrow *out_result) {
-	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
-	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
-		return DuckDBError;
-	}
-	auto arrow_wrapper = new ArrowResultWrapper();
-	auto result = wrapper->statement->Execute(wrapper->values, false);
-	D_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);
-	arrow_wrapper->result =
-	    unique_ptr<MaterializedQueryResult>(static_cast<MaterializedQueryResult *>(result.release()));
-	*out_result = (duckdb_arrow)arrow_wrapper;
-	return arrow_wrapper->result->success ? DuckDBSuccess : DuckDBError;
-}
-
-void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement) {
-	if (!prepared_statement) {
-		return;
-	}
-	auto wrapper = (PreparedStatementWrapper *)*prepared_statement;
-	if (wrapper) {
-		delete wrapper;
-	}
-	*prepared_statement = nullptr;
-}
-
-duckdb_type ConvertCPPTypeToC(LogicalType sql_type) {
-	switch (sql_type.id()) {
-	case LogicalTypeId::BOOLEAN:
-		return DUCKDB_TYPE_BOOLEAN;
-	case LogicalTypeId::TINYINT:
-		return DUCKDB_TYPE_TINYINT;
-	case LogicalTypeId::SMALLINT:
-		return DUCKDB_TYPE_SMALLINT;
-	case LogicalTypeId::INTEGER:
-		return DUCKDB_TYPE_INTEGER;
-	case LogicalTypeId::BIGINT:
-		return DUCKDB_TYPE_BIGINT;
-	case LogicalTypeId::UTINYINT:
-		return DUCKDB_TYPE_UTINYINT;
-	case LogicalTypeId::USMALLINT:
-		return DUCKDB_TYPE_USMALLINT;
-	case LogicalTypeId::UINTEGER:
-		return DUCKDB_TYPE_UINTEGER;
-	case LogicalTypeId::UBIGINT:
-		return DUCKDB_TYPE_UBIGINT;
-	case LogicalTypeId::HUGEINT:
-		return DUCKDB_TYPE_HUGEINT;
-	case LogicalTypeId::FLOAT:
-		return DUCKDB_TYPE_FLOAT;
-	case LogicalTypeId::DOUBLE:
-		return DUCKDB_TYPE_DOUBLE;
-	case LogicalTypeId::TIMESTAMP:
-		return DUCKDB_TYPE_TIMESTAMP;
-	case LogicalTypeId::TIMESTAMP_SEC:
-		return DUCKDB_TYPE_TIMESTAMP_S;
-	case LogicalTypeId::TIMESTAMP_MS:
-		return DUCKDB_TYPE_TIMESTAMP_MS;
-	case LogicalTypeId::TIMESTAMP_NS:
-		return DUCKDB_TYPE_TIMESTAMP_NS;
-	case LogicalTypeId::DATE:
-		return DUCKDB_TYPE_DATE;
-	case LogicalTypeId::TIME:
-		return DUCKDB_TYPE_TIME;
-	case LogicalTypeId::VARCHAR:
-		return DUCKDB_TYPE_VARCHAR;
-	case LogicalTypeId::BLOB:
-		return DUCKDB_TYPE_BLOB;
-	case LogicalTypeId::INTERVAL:
-		return DUCKDB_TYPE_INTERVAL;
-	default:
-		D_ASSERT(0);
-		return DUCKDB_TYPE_INVALID;
-	}
-}
-
-idx_t GetCTypeSize(duckdb_type type) {
-	switch (type) {
-	case DUCKDB_TYPE_BOOLEAN:
-		return sizeof(bool);
-	case DUCKDB_TYPE_TINYINT:
-		return sizeof(int8_t);
-	case DUCKDB_TYPE_SMALLINT:
-		return sizeof(int16_t);
-	case DUCKDB_TYPE_INTEGER:
-		return sizeof(int32_t);
-	case DUCKDB_TYPE_BIGINT:
-		return sizeof(int64_t);
-	case DUCKDB_TYPE_UTINYINT:
-		return sizeof(uint8_t);
-	case DUCKDB_TYPE_USMALLINT:
-		return sizeof(uint16_t);
-	case DUCKDB_TYPE_UINTEGER:
-		return sizeof(uint32_t);
-	case DUCKDB_TYPE_UBIGINT:
-		return sizeof(uint64_t);
-	case DUCKDB_TYPE_HUGEINT:
-		return sizeof(duckdb_hugeint);
-	case DUCKDB_TYPE_FLOAT:
-		return sizeof(float);
-	case DUCKDB_TYPE_DOUBLE:
-		return sizeof(double);
-	case DUCKDB_TYPE_DATE:
-		return sizeof(duckdb_date);
-	case DUCKDB_TYPE_TIME:
-		return sizeof(duckdb_time);
-	case DUCKDB_TYPE_TIMESTAMP:
-	case DUCKDB_TYPE_TIMESTAMP_NS:
-	case DUCKDB_TYPE_TIMESTAMP_MS:
-	case DUCKDB_TYPE_TIMESTAMP_S:
-		return sizeof(duckdb_timestamp);
-	case DUCKDB_TYPE_VARCHAR:
-		return sizeof(const char *);
-	case DUCKDB_TYPE_BLOB:
-		return sizeof(duckdb_blob);
-	case DUCKDB_TYPE_INTERVAL:
-		return sizeof(duckdb_interval);
-	default:
-		// unsupported type
-		D_ASSERT(0);
-		return sizeof(const char *);
-	}
-}
-
-template <class T>
-T UnsafeFetch(duckdb_result *result, idx_t col, idx_t row) {
-	D_ASSERT(row < result->row_count);
-	return ((T *)result->columns[col].data)[row];
-}
-
-static Value GetCValue(duckdb_result *result, idx_t col, idx_t row) {
-	if (col >= result->column_count) {
-		return Value();
-	}
-	if (row >= result->row_count) {
-		return Value();
-	}
-	if (result->columns[col].nullmask[row]) {
-		return Value();
-	}
-	switch (result->columns[col].type) {
-	case DUCKDB_TYPE_BOOLEAN:
-		return Value::BOOLEAN(UnsafeFetch<bool>(result, col, row));
-	case DUCKDB_TYPE_TINYINT:
-		return Value::TINYINT(UnsafeFetch<int8_t>(result, col, row));
-	case DUCKDB_TYPE_SMALLINT:
-		return Value::SMALLINT(UnsafeFetch<int16_t>(result, col, row));
-	case DUCKDB_TYPE_INTEGER:
-		return Value::INTEGER(UnsafeFetch<int32_t>(result, col, row));
-	case DUCKDB_TYPE_BIGINT:
-		return Value::BIGINT(UnsafeFetch<int64_t>(result, col, row));
-	case DUCKDB_TYPE_UTINYINT:
-		return Value::TINYINT(UnsafeFetch<uint8_t>(result, col, row));
-	case DUCKDB_TYPE_USMALLINT:
-		return Value::SMALLINT(UnsafeFetch<uint16_t>(result, col, row));
-	case DUCKDB_TYPE_UINTEGER:
-		return Value::INTEGER(UnsafeFetch<uint32_t>(result, col, row));
-	case DUCKDB_TYPE_UBIGINT:
-		return Value::BIGINT(UnsafeFetch<uint64_t>(result, col, row));
-	case DUCKDB_TYPE_FLOAT:
-		return Value(UnsafeFetch<float>(result, col, row));
-	case DUCKDB_TYPE_DOUBLE:
-		return Value(UnsafeFetch<double>(result, col, row));
-	case DUCKDB_TYPE_DATE: {
-		auto date = UnsafeFetch<duckdb_date>(result, col, row);
-		return Value::DATE(date.year, date.month, date.day);
-	}
-	case DUCKDB_TYPE_TIME: {
-		auto time = UnsafeFetch<duckdb_time>(result, col, row);
-		return Value::TIME(time.hour, time.min, time.sec, time.micros);
-	}
-	case DUCKDB_TYPE_TIMESTAMP_NS:
-	case DUCKDB_TYPE_TIMESTAMP_MS:
-	case DUCKDB_TYPE_TIMESTAMP_S:
-	case DUCKDB_TYPE_TIMESTAMP: {
-		auto timestamp = UnsafeFetch<duckdb_timestamp>(result, col, row);
-		return Value::TIMESTAMP(timestamp.date.year, timestamp.date.month, timestamp.date.day, timestamp.time.hour,
-		                        timestamp.time.min, timestamp.time.sec, timestamp.time.micros);
-	}
-	case DUCKDB_TYPE_HUGEINT: {
-		hugeint_t val;
-		auto hugeint = UnsafeFetch<duckdb_hugeint>(result, col, row);
-		val.lower = hugeint.lower;
-		val.upper = hugeint.upper;
-		return Value::HUGEINT(val);
-	}
-	case DUCKDB_TYPE_INTERVAL: {
-		interval_t val;
-		auto interval = UnsafeFetch<duckdb_interval>(result, col, row);
-		val.days = interval.days;
-		val.months = interval.months;
-		val.micros = interval.micros;
-		return Value::INTERVAL(val);
-	}
-	case DUCKDB_TYPE_VARCHAR:
-		return Value(string(UnsafeFetch<const char *>(result, col, row)));
-	case DUCKDB_TYPE_BLOB: {
-		auto blob = UnsafeFetch<duckdb_blob>(result, col, row);
-		return Value::BLOB((const_data_ptr_t)blob.data, blob.size);
-	}
-	default:
-		// invalid type for C to C++ conversion
-		D_ASSERT(0);
-		return Value();
-	}
-}
-
-const char *duckdb_column_name(duckdb_result *result, idx_t col) {
-	if (!result || col >= result->column_count) {
-		return nullptr;
-	}
-	return result->columns[col].name;
-}
-
-bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	if (val.is_null) {
-		return false;
-	} else {
-		return val.GetValue<bool>();
-	}
-}
-
-int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	if (val.is_null) {
-		return 0;
-	} else {
-		return val.GetValue<int8_t>();
-	}
-}
-
-int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	if (val.is_null) {
-		return 0;
-	} else {
-		return val.GetValue<int16_t>();
-	}
-}
-
-int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	if (val.is_null) {
-		return 0;
-	} else {
-		return val.GetValue<int32_t>();
-	}
-}
-
-int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	if (val.is_null) {
-		return 0;
-	} else {
-		return val.GetValue<int64_t>();
-	}
-}
-
-uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	if (val.is_null) {
-		return 0;
-	} else {
-		return val.GetValue<uint8_t>();
-	}
-}
-
-uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	if (val.is_null) {
-		return 0;
-	} else {
-		return val.GetValue<uint16_t>();
-	}
-}
-
-uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	if (val.is_null) {
-		return 0;
-	} else {
-		return val.GetValue<uint32_t>();
-	}
-}
-
-uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	if (val.is_null) {
-		return 0;
-	} else {
-		return val.GetValue<uint64_t>();
-	}
-}
-
-float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	if (val.is_null) {
-		return 0.0;
-	} else {
-		return val.GetValue<float>();
-	}
-}
-
-double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	if (val.is_null) {
-		return 0.0;
-	} else {
-		return val.GetValue<double>();
-	}
-}
-
-char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row) {
-	Value val = GetCValue(result, col, row);
-	return strdup(val.ToString().c_str());
-}
-
-duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row) {
-	duckdb_blob blob;
-	Value val = GetCValue(result, col, row).CastAs(LogicalType::BLOB);
-	if (val.is_null) {
-		blob.data = nullptr;
-		blob.size = 0;
-	} else {
-		blob.data = malloc(val.str_value.size());
-		memcpy((void *)blob.data, val.str_value.c_str(), val.str_value.size());
-		blob.size = val.str_value.size();
-	}
-	return blob;
-}
-
-void *duckdb_malloc(size_t size) {
-	return malloc(size);
-}
-
-void duckdb_free(void *ptr) {
-	free(ptr);
-}
-
-namespace duckdb {
-struct AppenderWrapper {
-	AppenderWrapper() : appender(nullptr) {
-	}
-	~AppenderWrapper() {
-	}
-	unique_ptr<Appender> appender;
-	string error;
-};
-} // namespace duckdb
-
-duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
-                                    duckdb_appender *out_appender) {
-	Connection *conn = (Connection *)connection;
-
-	if (!connection || !table || !out_appender) {
-		return DuckDBError;
-	}
-	if (schema == nullptr) {
-		schema = DEFAULT_SCHEMA;
-	}
-	auto wrapper = new AppenderWrapper();
-	*out_appender = (duckdb_appender)wrapper;
-	try {
-		wrapper->appender = make_unique<Appender>(*conn, schema, table);
-	} catch (std::exception &ex) {
-		wrapper->error = ex.what();
-		return DuckDBError;
-	} catch (...) {
-		wrapper->error = "Unknown create appender error";
-		return DuckDBError;
-	}
-	return DuckDBSuccess;
-}
-
-duckdb_state duckdb_appender_destroy(duckdb_appender *appender) {
-	if (!appender || !*appender) {
-		return DuckDBError;
-	}
-	auto wrapper = (AppenderWrapper *)*appender;
-	if (wrapper) {
-		delete wrapper;
-	}
-	*appender = nullptr;
-	return DuckDBSuccess;
-}
-
-template <class FUN>
-duckdb_state duckdb_appender_run_function(duckdb_appender appender, FUN &&function) {
-	if (!appender) {
-		return DuckDBError;
-	}
-	auto wrapper = (AppenderWrapper *)appender;
-	try {
-		function(wrapper->appender.get());
-	} catch (std::exception &ex) {
-		wrapper->error = ex.what();
-		return DuckDBError;
-	} catch (...) {
-		wrapper->error = "Unknown error";
-		return DuckDBError;
-	}
-	return DuckDBSuccess;
-}
-
-duckdb_state duckdb_appender_begin_row(duckdb_appender appender) {
-	return duckdb_appender_run_function(appender, [&](Appender *appender) { appender->BeginRow(); });
-}
-
-duckdb_state duckdb_appender_end_row(duckdb_appender appender) {
-	return duckdb_appender_run_function(appender, [&](Appender *appender) { appender->EndRow(); });
-}
-
-template <class T>
-duckdb_state duckdb_append_internal(duckdb_appender appender, T value) {
-	if (!appender) {
-		return DuckDBError;
-	}
-	auto wrapper = (AppenderWrapper *)appender;
-	try {
-		wrapper->appender->Append<T>(value);
-	} catch (std::exception &ex) {
-		wrapper->error = ex.what();
-		return DuckDBError;
-	} catch (...) {
-		wrapper->error = "Unknown error";
-		return DuckDBError;
-	}
-	return DuckDBSuccess;
-}
-
-duckdb_state duckdb_append_bool(duckdb_appender appender, bool value) {
-	return duckdb_append_internal<bool>(appender, value);
-}
-
-duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value) {
-	return duckdb_append_internal<int8_t>(appender, value);
-}
-
-duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value) {
-	return duckdb_append_internal<int16_t>(appender, value);
-}
-
-duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value) {
-	return duckdb_append_internal<int32_t>(appender, value);
-}
-
-duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value) {
-	return duckdb_append_internal<int64_t>(appender, value);
-}
-
-duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value) {
-	return duckdb_append_internal<uint8_t>(appender, value);
-}
-
-duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value) {
-	return duckdb_append_internal<uint16_t>(appender, value);
-}
-
-duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value) {
-	return duckdb_append_internal<uint32_t>(appender, value);
-}
-
-duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value) {
-	return duckdb_append_internal<uint64_t>(appender, value);
-}
-
-duckdb_state duckdb_append_float(duckdb_appender appender, float value) {
-	return duckdb_append_internal<float>(appender, value);
-}
-
-duckdb_state duckdb_append_double(duckdb_appender appender, double value) {
-	return duckdb_append_internal<double>(appender, value);
-}
-
-duckdb_state duckdb_append_null(duckdb_appender appender) {
-	return duckdb_append_internal<std::nullptr_t>(appender, nullptr);
-}
-
-duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val) {
-	return duckdb_append_internal<const char *>(appender, val);
-}
-
-duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length) {
-	return duckdb_append_internal<string_t>(appender, string_t(val, length));
-}
-duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length) {
-	return duckdb_append_internal<string_t>(appender, string_t((const char *)data, length));
-}
-
-const char *duckdb_appender_error(duckdb_appender appender) {
-	if (!appender) {
-		return nullptr;
-	}
-	auto wrapper = (AppenderWrapper *)appender;
-	if (wrapper->error.empty()) {
-		return nullptr;
-	}
-	return strdup(wrapper->error.c_str());
-}
-
-duckdb_state duckdb_appender_flush(duckdb_appender appender) {
-	return duckdb_appender_run_function(appender, [&](Appender *appender) { appender->Flush(); });
-}
-
-duckdb_state duckdb_appender_close(duckdb_appender appender) {
-	return duckdb_appender_run_function(appender, [&](Appender *appender) { appender->Close(); });
-}
