{
  "repo": "duckdb/duckdb",
  "pull_number": 3757,
  "instance_id": "duckdb__duckdb-3757",
  "issue_numbers": [
    "3756",
    "3756"
  ],
  "base_commit": "d0303108bb935844bc2a0b3606e307588e0b07b7",
  "patch": "diff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp\nindex 650d7ce16fec..afa27aa9c8cc 100644\n--- a/src/common/types/vector.cpp\n+++ b/src/common/types/vector.cpp\n@@ -1131,7 +1131,6 @@ const SelectionVector *ConstantVector::ZeroSelectionVector(idx_t count, Selectio\n }\n \n void ConstantVector::Reference(Vector &vector, Vector &source, idx_t position, idx_t count) {\n-\tD_ASSERT(position < count);\n \tauto &source_type = source.GetType();\n \tswitch (source_type.InternalType()) {\n \tcase PhysicalType::LIST: {\n@@ -1179,7 +1178,7 @@ void ConstantVector::Reference(Vector &vector, Vector &source, idx_t position, i\n \t\tauto &source_entries = StructVector::GetEntries(source);\n \t\tauto &target_entries = StructVector::GetEntries(vector);\n \t\tfor (idx_t i = 0; i < source_entries.size(); i++) {\n-\t\t\tConstantVector::Reference(*target_entries[i], *source_entries[i], position, count);\n+\t\t\tConstantVector::Reference(*target_entries[i], *source_entries[i], struct_index, count);\n \t\t}\n \t\tvector.SetVectorType(VectorType::CONSTANT_VECTOR);\n \t\tbreak;\ndiff --git a/src/common/vector_operations/vector_hash.cpp b/src/common/vector_operations/vector_hash.cpp\nindex d36db561588f..073cd5310ced 100644\n--- a/src/common/vector_operations/vector_hash.cpp\n+++ b/src/common/vector_operations/vector_hash.cpp\n@@ -63,6 +63,7 @@ static inline void TemplatedLoopHash(Vector &input, Vector &result, const Select\n \n template <bool HAS_RSEL, bool FIRST_HASH>\n static inline void StructLoopHash(Vector &input, Vector &hashes, const SelectionVector *rsel, idx_t count) {\n+\tinput.Normalify(count);\n \tauto &children = StructVector::GetEntries(input);\n \n \tD_ASSERT(!children.empty());\n",
  "test_patch": "diff --git a/test/sql/join/test_complex_join_structs.test b/test/sql/join/test_complex_join_structs.test\nnew file mode 100644\nindex 000000000000..7d27c161eef4\n--- /dev/null\n+++ b/test/sql/join/test_complex_join_structs.test\n@@ -0,0 +1,149 @@\n+# name: test/sql/join/test_complex_join_structs.test\n+# description: Test complex joins and count distincts with structs\n+# group: [join]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE structs AS SELECT i id, {'i': i} s, i%3 j FROM generate_series(0,99,1) tbl(i), generate_series(0,1,1);\n+\n+statement ok\n+CREATE TABLE other_table AS SELECT i id, i%3 j FROM generate_series(0,99,1) tbl(i) WHERE i%2=0;\n+\n+# count distinct\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs;\n+----\n+200\t200\t100\t100\n+\n+#count distinct with a filter\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs WHERE id%2<>0;\n+----\n+100\t100\t50\t50\n+\n+# count distinct with a join\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs JOIN other_table USING (id);\n+----\n+100\t100\t50\t50\n+\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs LEFT JOIN other_table USING (id);\n+----\n+200\t200\t100\t100\n+\n+# count distinct with a complex join condition\n+query IIIII\n+SELECT structs.j, COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id)\n+FROM structs\n+LEFT JOIN other_table o1 USING (id)\n+CROSS JOIN other_table\n+WHERE ((structs.j IN (0, 1) AND (structs.id=other_table.id)) OR (structs.j=2 AND structs.id+1=other_table.id))\n+GROUP BY ALL\n+ORDER BY ALL\n+----\n+0\t34\t34\t17\t17\n+1\t32\t32\t16\t16\n+2\t32\t32\t16\t16\n+\n+# now with lists\n+statement ok\n+DROP TABLE structs;\n+\n+statement ok\n+DROP TABLE other_table\n+\n+statement ok\n+CREATE TABLE structs AS SELECT i id, {'i': [i, i + 1, i + 2], 'j': CASE WHEN i%4=1 THEN NULL ELSE [i, i] END} s, i%3 j FROM generate_series(0,99,1) tbl(i), generate_series(0,1,1);\n+\n+statement ok\n+CREATE TABLE other_table AS SELECT i id, i%3 j FROM generate_series(0,99,1) tbl(i) WHERE i%2=0;\n+\n+# count distinct\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs;\n+----\n+200\t200\t100\t100\n+\n+#count distinct with a filter\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs WHERE id%2<>0;\n+----\n+100\t100\t50\t50\n+\n+# count distinct with a join\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs JOIN other_table USING (id);\n+----\n+100\t100\t50\t50\n+\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs LEFT JOIN other_table USING (id);\n+----\n+200\t200\t100\t100\n+\n+# count distinct with a complex join condition\n+query IIIII\n+SELECT structs.j, COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id)\n+FROM structs\n+LEFT JOIN other_table o1 USING (id)\n+CROSS JOIN other_table\n+WHERE ((structs.j IN (0, 1) AND (structs.id=other_table.id)) OR (structs.j=2 AND structs.id+1=other_table.id))\n+GROUP BY ALL\n+ORDER BY ALL\n+----\n+0\t34\t34\t17\t17\n+1\t32\t32\t16\t16\n+2\t32\t32\t16\t16\n+\n+# more complex nested structs\n+statement ok\n+DROP TABLE structs;\n+\n+statement ok\n+DROP TABLE other_table\n+\n+statement ok\n+CREATE TABLE structs AS SELECT i id, {'i': {'j': [i + 1, i + 2, i + 3], 'k': i}, 'l': NULL} s, i%3 j FROM generate_series(0,99,1) tbl(i), generate_series(0,1,1);\n+\n+statement ok\n+CREATE TABLE other_table AS SELECT i id, i%3 j FROM generate_series(0,99,1) tbl(i) WHERE i%2=0;\n+\n+# count distinct\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs;\n+----\n+200\t200\t100\t100\n+\n+#count distinct with a filter\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs WHERE id%2<>0;\n+----\n+100\t100\t50\t50\n+\n+# count distinct with a join\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs JOIN other_table USING (id);\n+----\n+100\t100\t50\t50\n+\n+query IIII\n+SELECT COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id) FROM structs LEFT JOIN other_table USING (id);\n+----\n+200\t200\t100\t100\n+\n+# count distinct with a complex join condition\n+query IIIII\n+SELECT structs.j, COUNT(*), COUNT(s), COUNT(DISTINCT s), COUNT(DISTINCT structs.id)\n+FROM structs\n+LEFT JOIN other_table o1 USING (id)\n+CROSS JOIN other_table\n+WHERE ((structs.j IN (0, 1) AND (structs.id=other_table.id)) OR (structs.j=2 AND structs.id+1=other_table.id))\n+GROUP BY ALL\n+ORDER BY ALL\n+----\n+0\t34\t34\t17\t17\n+1\t32\t32\t16\t16\n+2\t32\t32\t16\t16\n",
  "problem_statement": "Incorrect Aggregate Calculation\nThe data in this test can be found by cloning \r\n\r\n```\r\ngit clone git@github.com:lloydtabb/imdb_malloy.git\r\nmake\r\n```\r\n\r\nIt seems there is a bug in DISTINCTing.  Not sure exactly where.\r\n\r\n```\r\nSELECT\r\n    group_set,\r\n    COUNT(DISTINCT concat(movies_queries.tconst, '|', IFNULL(movies_queries.ratings.numVotes,0)::varchar) )  as all_movie_votes,\r\n    case when group_set = 0 THEN\r\n      COUNT(DISTINCT concat(movies_queries.tconst, '|', IFNULL(movies_queries.ratings.numVotes,0)::varchar) )\r\n    END as movie_votes0,\r\n    case when group_set = 1 THEN\r\n      COUNT(DISTINCT concat(movies_queries.tconst, '|', IFNULL(movies_queries.ratings.numVotes,0)::varchar) )\r\n    END as movie_votes1\r\n\r\n  FROM 'titles.parquet' as movies_queries\r\n  LEFT JOIN 'principals.parquet' AS principals_0\r\n    ON movies_queries.tconst=principals_0.tconst\r\n  -- comment out the line below to make the bug go away\r\n  LEFT JOIN 'names.parquet' AS people_0 ON principals_0.nconst=people_0.nconst\r\n  CROSS JOIN (SELECT UNNEST(GENERATE_SERIES(0,1,1)) as group_set  ) as group_set\r\n  WHERE (movies_queries.ratings.numVotes>30000)\r\n     -- comment the line below to make the bug go away.\r\n     AND ((group_set NOT IN (1) OR (group_set IN (1) AND principals_0.category='director')))\r\n  GROUP BY 1\r\n  ```\r\n\r\nThe proper result is 6094 distinct movies.  There should be nothing a join can do to change the calculation of a count distinct, yet it does.  The where clause  should only effect calulations in group_set= 1, yet it effects calculations in group_set=0\r\n\r\nChanging either of the lines below the comment will produce an accurate calculation.\r\n\r\n![image](https://user-images.githubusercontent.com/1093458/171655646-5ebe92f3-2806-4877-ae12-7ea074550a77.png)\r\n\r\n\nIncorrect Aggregate Calculation\nThe data in this test can be found by cloning \r\n\r\n```\r\ngit clone git@github.com:lloydtabb/imdb_malloy.git\r\nmake\r\n```\r\n\r\nIt seems there is a bug in DISTINCTing.  Not sure exactly where.\r\n\r\n```\r\nSELECT\r\n    group_set,\r\n    COUNT(DISTINCT concat(movies_queries.tconst, '|', IFNULL(movies_queries.ratings.numVotes,0)::varchar) )  as all_movie_votes,\r\n    case when group_set = 0 THEN\r\n      COUNT(DISTINCT concat(movies_queries.tconst, '|', IFNULL(movies_queries.ratings.numVotes,0)::varchar) )\r\n    END as movie_votes0,\r\n    case when group_set = 1 THEN\r\n      COUNT(DISTINCT concat(movies_queries.tconst, '|', IFNULL(movies_queries.ratings.numVotes,0)::varchar) )\r\n    END as movie_votes1\r\n\r\n  FROM 'titles.parquet' as movies_queries\r\n  LEFT JOIN 'principals.parquet' AS principals_0\r\n    ON movies_queries.tconst=principals_0.tconst\r\n  -- comment out the line below to make the bug go away\r\n  LEFT JOIN 'names.parquet' AS people_0 ON principals_0.nconst=people_0.nconst\r\n  CROSS JOIN (SELECT UNNEST(GENERATE_SERIES(0,1,1)) as group_set  ) as group_set\r\n  WHERE (movies_queries.ratings.numVotes>30000)\r\n     -- comment the line below to make the bug go away.\r\n     AND ((group_set NOT IN (1) OR (group_set IN (1) AND principals_0.category='director')))\r\n  GROUP BY 1\r\n  ```\r\n\r\nThe proper result is 6094 distinct movies.  There should be nothing a join can do to change the calculation of a count distinct, yet it does.  The where clause  should only effect calulations in group_set= 1, yet it effects calculations in group_set=0\r\n\r\nChanging either of the lines below the comment will produce an accurate calculation.\r\n\r\n![image](https://user-images.githubusercontent.com/1093458/171655646-5ebe92f3-2806-4877-ae12-7ea074550a77.png)\r\n\r\n\n",
  "hints_text": "Does this still occur on master? We had an issue with OR pushdown and have disabled it for now.\nYes, it still happens on master...\r\n![image](https://user-images.githubusercontent.com/1093458/171665746-7eb5b52b-6b69-4095-baa1-78648c1de1a6.png)\r\n\nThanks for the report! I can confirm that this appears to be broken. I will investigate.\nDoes this still occur on master? We had an issue with OR pushdown and have disabled it for now.\nYes, it still happens on master...\r\n![image](https://user-images.githubusercontent.com/1093458/171665746-7eb5b52b-6b69-4095-baa1-78648c1de1a6.png)\r\n\nThanks for the report! I can confirm that this appears to be broken. I will investigate.",
  "created_at": "2022-06-02T18:42:19Z"
}