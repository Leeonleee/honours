You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Undefined behavior at bitwise.cpp:148:38 (maybe not a bug)
#### What happens?
```
duckdb/src/function/scalar/operators/bitwise.cpp:148:38: runtime error: left shift of 1000 by 55 places cannot be represented in type 'long'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /root/duckdb/src/function/scalar/operators/bitwise.cpp:148:38 in
```

#### To Reproduce
```sql
SELECT MIN(1000::bigint<<55);
```

#### Environment (please complete the following information):
 - OS: linux
 - DuckDB Version: v0.3.3-dev1399 7c5ba6c0e
 - DuckDB Client: /usr/local/bin/duckdb

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

Undefined behavior at bitwise.cpp:148:38 (maybe not a bug)
#### What happens?
```
duckdb/src/function/scalar/operators/bitwise.cpp:148:38: runtime error: left shift of 1000 by 55 places cannot be represented in type 'long'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /root/duckdb/src/function/scalar/operators/bitwise.cpp:148:38 in
```

#### To Reproduce
```sql
SELECT MIN(1000::bigint<<55);
```

#### Environment (please complete the following information):
 - OS: linux
 - DuckDB Version: v0.3.3-dev1399 7c5ba6c0e
 - DuckDB Client: /usr/local/bin/duckdb

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of src/common/exception_format_value.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/common/types.hpp"
3: #include "fmt/format.h"
4: #include "fmt/printf.h"
5: 
6: namespace duckdb {
7: 
8: ExceptionFormatValue::ExceptionFormatValue(double dbl_val)
9:     : type(ExceptionFormatValueType::FORMAT_VALUE_TYPE_DOUBLE), dbl_val(dbl_val) {
10: }
11: ExceptionFormatValue::ExceptionFormatValue(int64_t int_val)
12:     : type(ExceptionFormatValueType::FORMAT_VALUE_TYPE_INTEGER), int_val(int_val) {
13: }
14: ExceptionFormatValue::ExceptionFormatValue(string str_val)
15:     : type(ExceptionFormatValueType::FORMAT_VALUE_TYPE_STRING), str_val(move(str_val)) {
16: }
17: 
18: template <>
19: ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(PhysicalType value) {
20: 	return ExceptionFormatValue(TypeIdToString(value));
21: }
22: template <>
23: ExceptionFormatValue
24: ExceptionFormatValue::CreateFormatValue(LogicalType value) { // NOLINT: templating requires us to copy value here
25: 	return ExceptionFormatValue(value.ToString());
26: }
27: template <>
28: ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(float value) {
29: 	return ExceptionFormatValue(double(value));
30: }
31: template <>
32: ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(double value) {
33: 	return ExceptionFormatValue(double(value));
34: }
35: template <>
36: ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(string value) {
37: 	return ExceptionFormatValue(move(value));
38: }
39: template <>
40: ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(const char *value) {
41: 	return ExceptionFormatValue(string(value));
42: }
43: template <>
44: ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(char *value) {
45: 	return ExceptionFormatValue(string(value));
46: }
47: 
48: string ExceptionFormatValue::Format(const string &msg, vector<ExceptionFormatValue> &values) {
49: 	std::vector<duckdb_fmt::basic_format_arg<duckdb_fmt::printf_context>> format_args;
50: 	for (auto &val : values) {
51: 		switch (val.type) {
52: 		case ExceptionFormatValueType::FORMAT_VALUE_TYPE_DOUBLE:
53: 			format_args.push_back(duckdb_fmt::internal::make_arg<duckdb_fmt::printf_context>(val.dbl_val));
54: 			break;
55: 		case ExceptionFormatValueType::FORMAT_VALUE_TYPE_INTEGER:
56: 			format_args.push_back(duckdb_fmt::internal::make_arg<duckdb_fmt::printf_context>(val.int_val));
57: 			break;
58: 		case ExceptionFormatValueType::FORMAT_VALUE_TYPE_STRING:
59: 			format_args.push_back(duckdb_fmt::internal::make_arg<duckdb_fmt::printf_context>(val.str_val));
60: 			break;
61: 		}
62: 	}
63: 	return duckdb_fmt::vsprintf(msg, duckdb_fmt::basic_format_args<duckdb_fmt::printf_context>(
64: 	                                     format_args.data(), static_cast<int>(format_args.size())));
65: }
66: 
67: } // namespace duckdb
[end of src/common/exception_format_value.cpp]
[start of src/common/types/cast_helpers.cpp]
1: #include "duckdb/common/types/cast_helpers.hpp"
2: 
3: namespace duckdb {
4: 
5: const int64_t NumericHelper::POWERS_OF_TEN[] {1,
6:                                               10,
7:                                               100,
8:                                               1000,
9:                                               10000,
10:                                               100000,
11:                                               1000000,
12:                                               10000000,
13:                                               100000000,
14:                                               1000000000,
15:                                               10000000000,
16:                                               100000000000,
17:                                               1000000000000,
18:                                               10000000000000,
19:                                               100000000000000,
20:                                               1000000000000000,
21:                                               10000000000000000,
22:                                               100000000000000000,
23:                                               1000000000000000000};
24: 
25: const double NumericHelper::DOUBLE_POWERS_OF_TEN[] {1e0,  1e1,  1e2,  1e3,  1e4,  1e5,  1e6,  1e7,  1e8,  1e9,
26:                                                     1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
27:                                                     1e20, 1e21, 1e22, 1e23, 1e24, 1e25, 1e26, 1e27, 1e28, 1e29,
28:                                                     1e30, 1e31, 1e32, 1e33, 1e34, 1e35, 1e36, 1e37, 1e38, 1e39};
29: 
30: template <>
31: int NumericHelper::UnsignedLength(uint8_t value) {
32: 	int length = 1;
33: 	length += value >= 10;
34: 	length += value >= 100;
35: 	return length;
36: }
37: 
38: template <>
39: int NumericHelper::UnsignedLength(uint16_t value) {
40: 	int length = 1;
41: 	length += value >= 10;
42: 	length += value >= 100;
43: 	length += value >= 1000;
44: 	length += value >= 10000;
45: 	return length;
46: }
47: 
48: template <>
49: int NumericHelper::UnsignedLength(uint32_t value) {
50: 	if (value >= 10000) {
51: 		int length = 5;
52: 		length += value >= 100000;
53: 		length += value >= 1000000;
54: 		length += value >= 10000000;
55: 		length += value >= 100000000;
56: 		length += value >= 1000000000;
57: 		return length;
58: 	} else {
59: 		int length = 1;
60: 		length += value >= 10;
61: 		length += value >= 100;
62: 		length += value >= 1000;
63: 		return length;
64: 	}
65: }
66: 
67: template <>
68: int NumericHelper::UnsignedLength(uint64_t value) {
69: 	if (value >= 10000000000ULL) {
70: 		if (value >= 1000000000000000ULL) {
71: 			int length = 16;
72: 			length += value >= 10000000000000000ULL;
73: 			length += value >= 100000000000000000ULL;
74: 			length += value >= 1000000000000000000ULL;
75: 			length += value >= 10000000000000000000ULL;
76: 			return length;
77: 		} else {
78: 			int length = 11;
79: 			length += value >= 100000000000ULL;
80: 			length += value >= 1000000000000ULL;
81: 			length += value >= 10000000000000ULL;
82: 			length += value >= 100000000000000ULL;
83: 			return length;
84: 		}
85: 	} else {
86: 		if (value >= 100000ULL) {
87: 			int length = 6;
88: 			length += value >= 1000000ULL;
89: 			length += value >= 10000000ULL;
90: 			length += value >= 100000000ULL;
91: 			length += value >= 1000000000ULL;
92: 			return length;
93: 		} else {
94: 			int length = 1;
95: 			length += value >= 10ULL;
96: 			length += value >= 100ULL;
97: 			length += value >= 1000ULL;
98: 			length += value >= 10000ULL;
99: 			return length;
100: 		}
101: 	}
102: }
103: 
104: } // namespace duckdb
[end of src/common/types/cast_helpers.cpp]
[start of src/function/scalar/operators/bitwise.cpp]
1: #include "duckdb/function/scalar/operators.hpp"
2: #include "duckdb/common/vector_operations/vector_operations.hpp"
3: 
4: namespace duckdb {
5: 
6: template <class OP>
7: static scalar_function_t GetScalarIntegerUnaryFunction(const LogicalType &type) {
8: 	scalar_function_t function;
9: 	switch (type.id()) {
10: 	case LogicalTypeId::TINYINT:
11: 		function = &ScalarFunction::UnaryFunction<int8_t, int8_t, OP>;
12: 		break;
13: 	case LogicalTypeId::SMALLINT:
14: 		function = &ScalarFunction::UnaryFunction<int16_t, int16_t, OP>;
15: 		break;
16: 	case LogicalTypeId::INTEGER:
17: 		function = &ScalarFunction::UnaryFunction<int32_t, int32_t, OP>;
18: 		break;
19: 	case LogicalTypeId::BIGINT:
20: 		function = &ScalarFunction::UnaryFunction<int64_t, int64_t, OP>;
21: 		break;
22: 	case LogicalTypeId::UTINYINT:
23: 		function = &ScalarFunction::UnaryFunction<uint8_t, uint8_t, OP>;
24: 		break;
25: 	case LogicalTypeId::USMALLINT:
26: 		function = &ScalarFunction::UnaryFunction<uint16_t, uint16_t, OP>;
27: 		break;
28: 	case LogicalTypeId::UINTEGER:
29: 		function = &ScalarFunction::UnaryFunction<uint32_t, uint32_t, OP>;
30: 		break;
31: 	case LogicalTypeId::UBIGINT:
32: 		function = &ScalarFunction::UnaryFunction<uint64_t, uint64_t, OP>;
33: 		break;
34: 	case LogicalTypeId::HUGEINT:
35: 		function = &ScalarFunction::UnaryFunction<hugeint_t, hugeint_t, OP>;
36: 		break;
37: 	default:
38: 		throw NotImplementedException("Unimplemented type for GetScalarIntegerUnaryFunction");
39: 	}
40: 	return function;
41: }
42: 
43: template <class OP>
44: static scalar_function_t GetScalarIntegerBinaryFunction(const LogicalType &type) {
45: 	scalar_function_t function;
46: 	switch (type.id()) {
47: 	case LogicalTypeId::TINYINT:
48: 		function = &ScalarFunction::BinaryFunction<int8_t, int8_t, int8_t, OP>;
49: 		break;
50: 	case LogicalTypeId::SMALLINT:
51: 		function = &ScalarFunction::BinaryFunction<int16_t, int16_t, int16_t, OP>;
52: 		break;
53: 	case LogicalTypeId::INTEGER:
54: 		function = &ScalarFunction::BinaryFunction<int32_t, int32_t, int32_t, OP>;
55: 		break;
56: 	case LogicalTypeId::BIGINT:
57: 		function = &ScalarFunction::BinaryFunction<int64_t, int64_t, int64_t, OP>;
58: 		break;
59: 	case LogicalTypeId::UTINYINT:
60: 		function = &ScalarFunction::BinaryFunction<uint8_t, uint8_t, uint8_t, OP>;
61: 		break;
62: 	case LogicalTypeId::USMALLINT:
63: 		function = &ScalarFunction::BinaryFunction<uint16_t, uint16_t, uint16_t, OP>;
64: 		break;
65: 	case LogicalTypeId::UINTEGER:
66: 		function = &ScalarFunction::BinaryFunction<uint32_t, uint32_t, uint32_t, OP>;
67: 		break;
68: 	case LogicalTypeId::UBIGINT:
69: 		function = &ScalarFunction::BinaryFunction<uint64_t, uint64_t, uint64_t, OP>;
70: 		break;
71: 	case LogicalTypeId::HUGEINT:
72: 		function = &ScalarFunction::BinaryFunction<hugeint_t, hugeint_t, hugeint_t, OP>;
73: 		break;
74: 	default:
75: 		throw NotImplementedException("Unimplemented type for GetScalarIntegerBinaryFunction");
76: 	}
77: 	return function;
78: }
79: 
80: //===--------------------------------------------------------------------===//
81: // & [bitwise_and]
82: //===--------------------------------------------------------------------===//
83: struct BitwiseANDOperator {
84: 	template <class TA, class TB, class TR>
85: 	static inline TR Operation(TA left, TB right) {
86: 		return left & right;
87: 	}
88: };
89: 
90: void BitwiseAndFun::RegisterFunction(BuiltinFunctions &set) {
91: 	ScalarFunctionSet functions("&");
92: 	for (auto &type : LogicalType::Integral()) {
93: 		functions.AddFunction(
94: 		    ScalarFunction({type, type}, type, GetScalarIntegerBinaryFunction<BitwiseANDOperator>(type)));
95: 	}
96: 	set.AddFunction(functions);
97: }
98: 
99: //===--------------------------------------------------------------------===//
100: // | [bitwise_or]
101: //===--------------------------------------------------------------------===//
102: struct BitwiseOROperator {
103: 	template <class TA, class TB, class TR>
104: 	static inline TR Operation(TA left, TB right) {
105: 		return left | right;
106: 	}
107: };
108: 
109: void BitwiseOrFun::RegisterFunction(BuiltinFunctions &set) {
110: 	ScalarFunctionSet functions("|");
111: 	for (auto &type : LogicalType::Integral()) {
112: 		functions.AddFunction(
113: 		    ScalarFunction({type, type}, type, GetScalarIntegerBinaryFunction<BitwiseOROperator>(type)));
114: 	}
115: 	set.AddFunction(functions);
116: }
117: 
118: //===--------------------------------------------------------------------===//
119: // # [bitwise_xor]
120: //===--------------------------------------------------------------------===//
121: struct BitwiseXOROperator {
122: 	template <class TA, class TB, class TR>
123: 	static inline TR Operation(TA left, TB right) {
124: 		return left ^ right;
125: 	}
126: };
127: 
128: void BitwiseXorFun::RegisterFunction(BuiltinFunctions &set) {
129: 	ScalarFunctionSet functions("xor");
130: 	for (auto &type : LogicalType::Integral()) {
131: 		functions.AddFunction(
132: 		    ScalarFunction({type, type}, type, GetScalarIntegerBinaryFunction<BitwiseXOROperator>(type)));
133: 	}
134: 	set.AddFunction(functions);
135: }
136: 
137: //===--------------------------------------------------------------------===//
138: // << [bitwise_left_shift]
139: //===--------------------------------------------------------------------===//
140: template <class T>
141: bool ShiftInRange(T shift) {
142: 	return shift >= 0 && shift < T(sizeof(T) * 8);
143: }
144: 
145: struct BitwiseShiftLeftOperator {
146: 	template <class TA, class TB, class TR>
147: 	static inline TR Operation(TA input, TB shift) {
148: 		return ShiftInRange(shift) ? input << shift : 0;
149: 	}
150: };
151: 
152: void LeftShiftFun::RegisterFunction(BuiltinFunctions &set) {
153: 	ScalarFunctionSet functions("<<");
154: 	for (auto &type : LogicalType::Integral()) {
155: 		functions.AddFunction(
156: 		    ScalarFunction({type, type}, type, GetScalarIntegerBinaryFunction<BitwiseShiftLeftOperator>(type)));
157: 	}
158: 	set.AddFunction(functions);
159: }
160: 
161: //===--------------------------------------------------------------------===//
162: // >> [bitwise_right_shift]
163: //===--------------------------------------------------------------------===//
164: struct BitwiseShiftRightOperator {
165: 	template <class TA, class TB, class TR>
166: 	static inline TR Operation(TA input, TB shift) {
167: 		return ShiftInRange(shift) ? input >> shift : 0;
168: 	}
169: };
170: 
171: void RightShiftFun::RegisterFunction(BuiltinFunctions &set) {
172: 	ScalarFunctionSet functions(">>");
173: 	for (auto &type : LogicalType::Integral()) {
174: 		functions.AddFunction(
175: 		    ScalarFunction({type, type}, type, GetScalarIntegerBinaryFunction<BitwiseShiftRightOperator>(type)));
176: 	}
177: 	set.AddFunction(functions);
178: }
179: 
180: //===--------------------------------------------------------------------===//
181: // ~ [bitwise_not]
182: //===--------------------------------------------------------------------===//
183: struct BitwiseNotOperator {
184: 	template <class TA, class TR>
185: 	static inline TR Operation(TA input) {
186: 		return ~input;
187: 	}
188: };
189: 
190: void BitwiseNotFun::RegisterFunction(BuiltinFunctions &set) {
191: 	ScalarFunctionSet functions("~");
192: 	for (auto &type : LogicalType::Integral()) {
193: 		functions.AddFunction(ScalarFunction({type}, type, GetScalarIntegerUnaryFunction<BitwiseNotOperator>(type)));
194: 	}
195: 	set.AddFunction(functions);
196: }
197: 
198: } // namespace duckdb
[end of src/function/scalar/operators/bitwise.cpp]
[start of src/include/duckdb/common/exception_format_value.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/exception_format_value.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types.hpp"
13: 
14: namespace duckdb {
15: 
16: enum class ExceptionFormatValueType : uint8_t {
17: 	FORMAT_VALUE_TYPE_DOUBLE,
18: 	FORMAT_VALUE_TYPE_INTEGER,
19: 	FORMAT_VALUE_TYPE_STRING
20: };
21: 
22: struct ExceptionFormatValue {
23: 	DUCKDB_API ExceptionFormatValue(double dbl_val);  // NOLINT
24: 	DUCKDB_API ExceptionFormatValue(int64_t int_val); // NOLINT
25: 	DUCKDB_API ExceptionFormatValue(string str_val);  // NOLINT
26: 
27: 	ExceptionFormatValueType type;
28: 
29: 	double dbl_val;
30: 	int64_t int_val;
31: 	string str_val;
32: 
33: public:
34: 	template <class T>
35: 	static ExceptionFormatValue CreateFormatValue(T value) {
36: 		return int64_t(value);
37: 	}
38: 	static string Format(const string &msg, vector<ExceptionFormatValue> &values);
39: };
40: 
41: template <>
42: DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(PhysicalType value);
43: template <>
44: DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(LogicalType value);
45: template <>
46: DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(float value);
47: template <>
48: DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(double value);
49: template <>
50: DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(string value);
51: template <>
52: DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(const char *value);
53: template <>
54: DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(char *value);
55: 
56: } // namespace duckdb
[end of src/include/duckdb/common/exception_format_value.hpp]
[start of src/include/duckdb/common/types/cast_helpers.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/cast_helpers.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types/string_type.hpp"
13: #include "duckdb/common/types/decimal.hpp"
14: #include "duckdb/common/types/interval.hpp"
15: #include "duckdb/common/types/hugeint.hpp"
16: #include "duckdb/common/types/vector.hpp"
17: #include "fmt/format.h"
18: 
19: namespace duckdb {
20: 
21: //! NumericHelper is a static class that holds helper functions for integers/doubles
22: class NumericHelper {
23: public:
24: 	static const int64_t POWERS_OF_TEN[20];
25: 	static const double DOUBLE_POWERS_OF_TEN[40];
26: 
27: public:
28: 	template <class T>
29: 	static int UnsignedLength(T value);
30: 	template <class SIGNED, class UNSIGNED>
31: 	static int SignedLength(SIGNED value) {
32: 		int sign = -(value < 0);
33: 		UNSIGNED unsigned_value = (value ^ sign) - sign;
34: 		return UnsignedLength(unsigned_value) - sign;
35: 	}
36: 
37: 	// Formats value in reverse and returns a pointer to the beginning.
38: 	template <class T>
39: 	static char *FormatUnsigned(T value, char *ptr) {
40: 		while (value >= 100) {
41: 			// Integer division is slow so do it for a group of two digits instead
42: 			// of for every digit. The idea comes from the talk by Alexandrescu
43: 			// "Three Optimization Tips for C++".
44: 			auto index = static_cast<unsigned>((value % 100) * 2);
45: 			value /= 100;
46: 			*--ptr = duckdb_fmt::internal::data::digits[index + 1];
47: 			*--ptr = duckdb_fmt::internal::data::digits[index];
48: 		}
49: 		if (value < 10) {
50: 			*--ptr = static_cast<char>('0' + value);
51: 			return ptr;
52: 		}
53: 		auto index = static_cast<unsigned>(value * 2);
54: 		*--ptr = duckdb_fmt::internal::data::digits[index + 1];
55: 		*--ptr = duckdb_fmt::internal::data::digits[index];
56: 		return ptr;
57: 	}
58: 
59: 	template <class SIGNED, class UNSIGNED>
60: 	static string_t FormatSigned(SIGNED value, Vector &vector) {
61: 		int sign = -(value < 0);
62: 		UNSIGNED unsigned_value = UNSIGNED(value ^ sign) - sign;
63: 		int length = UnsignedLength<UNSIGNED>(unsigned_value) - sign;
64: 		string_t result = StringVector::EmptyString(vector, length);
65: 		auto dataptr = result.GetDataWriteable();
66: 		auto endptr = dataptr + length;
67: 		endptr = FormatUnsigned(unsigned_value, endptr);
68: 		if (sign) {
69: 			*--endptr = '-';
70: 		}
71: 		result.Finalize();
72: 		return result;
73: 	}
74: };
75: 
76: template <>
77: int NumericHelper::UnsignedLength(uint8_t value);
78: template <>
79: int NumericHelper::UnsignedLength(uint16_t value);
80: template <>
81: int NumericHelper::UnsignedLength(uint32_t value);
82: template <>
83: int NumericHelper::UnsignedLength(uint64_t value);
84: 
85: struct DecimalToString {
86: 	template <class SIGNED, class UNSIGNED>
87: 	static int DecimalLength(SIGNED value, uint8_t scale) {
88: 		if (scale == 0) {
89: 			// scale is 0: regular number
90: 			return NumericHelper::SignedLength<SIGNED, UNSIGNED>(value);
91: 		}
92: 		// length is max of either:
93: 		// scale + 2 OR
94: 		// integer length + 1
95: 		// scale + 2 happens when the number is in the range of (-1, 1)
96: 		// in that case we print "0.XXX", which is the scale, plus "0." (2 chars)
97: 		// integer length + 1 happens when the number is outside of that range
98: 		// in that case we print the integer number, but with one extra character ('.')
99: 		return MaxValue(scale + 2 + (value < 0 ? 1 : 0), NumericHelper::SignedLength<SIGNED, UNSIGNED>(value) + 1);
100: 	}
101: 
102: 	template <class SIGNED, class UNSIGNED>
103: 	static void FormatDecimal(SIGNED value, uint8_t scale, char *dst, idx_t len) {
104: 		char *end = dst + len;
105: 		if (value < 0) {
106: 			value = -value;
107: 			*dst = '-';
108: 		}
109: 		if (scale == 0) {
110: 			NumericHelper::FormatUnsigned<UNSIGNED>(value, end);
111: 			return;
112: 		}
113: 		// we write two numbers:
114: 		// the numbers BEFORE the decimal (major)
115: 		// and the numbers AFTER the decimal (minor)
116: 		UNSIGNED minor = value % (UNSIGNED)NumericHelper::POWERS_OF_TEN[scale];
117: 		UNSIGNED major = value / (UNSIGNED)NumericHelper::POWERS_OF_TEN[scale];
118: 		// write the number after the decimal
119: 		dst = NumericHelper::FormatUnsigned<UNSIGNED>(minor, end);
120: 		// (optionally) pad with zeros and add the decimal point
121: 		while (dst > (end - scale)) {
122: 			*--dst = '0';
123: 		}
124: 		*--dst = '.';
125: 		// now write the part before the decimal
126: 		dst = NumericHelper::FormatUnsigned<UNSIGNED>(major, dst);
127: 	}
128: 
129: 	template <class SIGNED, class UNSIGNED>
130: 	static string_t Format(SIGNED value, uint8_t scale, Vector &vector) {
131: 		int len = DecimalLength<SIGNED, UNSIGNED>(value, scale);
132: 		string_t result = StringVector::EmptyString(vector, len);
133: 		FormatDecimal<SIGNED, UNSIGNED>(value, scale, result.GetDataWriteable(), len);
134: 		result.Finalize();
135: 		return result;
136: 	}
137: };
138: 
139: struct HugeintToStringCast {
140: 	static int UnsignedLength(hugeint_t value) {
141: 		D_ASSERT(value.upper >= 0);
142: 		if (value.upper == 0) {
143: 			return NumericHelper::UnsignedLength<uint64_t>(value.lower);
144: 		}
145: 		// search the length using the POWERS_OF_TEN array
146: 		// the length has to be between [17] and [38], because the hugeint is bigger than 2^63
147: 		// we use the same approach as above, but split a bit more because comparisons for hugeints are more expensive
148: 		if (value >= Hugeint::POWERS_OF_TEN[27]) {
149: 			// [27..38]
150: 			if (value >= Hugeint::POWERS_OF_TEN[32]) {
151: 				if (value >= Hugeint::POWERS_OF_TEN[36]) {
152: 					int length = 37;
153: 					length += value >= Hugeint::POWERS_OF_TEN[37];
154: 					length += value >= Hugeint::POWERS_OF_TEN[38];
155: 					return length;
156: 				} else {
157: 					int length = 33;
158: 					length += value >= Hugeint::POWERS_OF_TEN[33];
159: 					length += value >= Hugeint::POWERS_OF_TEN[34];
160: 					length += value >= Hugeint::POWERS_OF_TEN[35];
161: 					return length;
162: 				}
163: 			} else {
164: 				if (value >= Hugeint::POWERS_OF_TEN[30]) {
165: 					int length = 31;
166: 					length += value >= Hugeint::POWERS_OF_TEN[31];
167: 					length += value >= Hugeint::POWERS_OF_TEN[32];
168: 					return length;
169: 				} else {
170: 					int length = 28;
171: 					length += value >= Hugeint::POWERS_OF_TEN[28];
172: 					length += value >= Hugeint::POWERS_OF_TEN[29];
173: 					return length;
174: 				}
175: 			}
176: 		} else {
177: 			// [17..27]
178: 			if (value >= Hugeint::POWERS_OF_TEN[22]) {
179: 				// [22..27]
180: 				if (value >= Hugeint::POWERS_OF_TEN[25]) {
181: 					int length = 26;
182: 					length += value >= Hugeint::POWERS_OF_TEN[26];
183: 					return length;
184: 				} else {
185: 					int length = 23;
186: 					length += value >= Hugeint::POWERS_OF_TEN[23];
187: 					length += value >= Hugeint::POWERS_OF_TEN[24];
188: 					return length;
189: 				}
190: 			} else {
191: 				// [17..22]
192: 				if (value >= Hugeint::POWERS_OF_TEN[20]) {
193: 					int length = 21;
194: 					length += value >= Hugeint::POWERS_OF_TEN[21];
195: 					return length;
196: 				} else {
197: 					int length = 18;
198: 					length += value >= Hugeint::POWERS_OF_TEN[18];
199: 					length += value >= Hugeint::POWERS_OF_TEN[19];
200: 					return length;
201: 				}
202: 			}
203: 		}
204: 	}
205: 
206: 	// Formats value in reverse and returns a pointer to the beginning.
207: 	static char *FormatUnsigned(hugeint_t value, char *ptr) {
208: 		while (value.upper > 0) {
209: 			// while integer division is slow, hugeint division is MEGA slow
210: 			// we want to avoid doing as many divisions as possible
211: 			// for that reason we start off doing a division by a large power of ten that uint64_t can hold
212: 			// (100000000000000000) - this is the third largest
213: 			// the reason we don't use the largest is because that can result in an overflow inside the division
214: 			// function
215: 			uint64_t remainder;
216: 			value = Hugeint::DivModPositive(value, 100000000000000000ULL, remainder);
217: 
218: 			auto startptr = ptr;
219: 			// now we format the remainder: note that we need to pad with zero's in case
220: 			// the remainder is small (i.e. less than 10000000000000000)
221: 			ptr = NumericHelper::FormatUnsigned<uint64_t>(remainder, ptr);
222: 
223: 			int format_length = startptr - ptr;
224: 			// pad with zero
225: 			for (int i = format_length; i < 17; i++) {
226: 				*--ptr = '0';
227: 			}
228: 		}
229: 		// once the value falls in the range of a uint64_t, fallback to formatting as uint64_t to avoid hugeint division
230: 		return NumericHelper::FormatUnsigned<uint64_t>(value.lower, ptr);
231: 	}
232: 
233: 	static string_t FormatSigned(hugeint_t value, Vector &vector) {
234: 		int negative = value.upper < 0;
235: 		if (negative) {
236: 			Hugeint::NegateInPlace(value);
237: 		}
238: 		int length = UnsignedLength(value) + negative;
239: 		string_t result = StringVector::EmptyString(vector, length);
240: 		auto dataptr = result.GetDataWriteable();
241: 		auto endptr = dataptr + length;
242: 		if (value.upper == 0) {
243: 			// small value: format as uint64_t
244: 			endptr = NumericHelper::FormatUnsigned<uint64_t>(value.lower, endptr);
245: 		} else {
246: 			endptr = FormatUnsigned(value, endptr);
247: 		}
248: 		if (negative) {
249: 			*--endptr = '-';
250: 		}
251: 		D_ASSERT(endptr == dataptr);
252: 		result.Finalize();
253: 		return result;
254: 	}
255: 
256: 	static int DecimalLength(hugeint_t value, uint8_t scale) {
257: 		int negative;
258: 		if (value.upper < 0) {
259: 			Hugeint::NegateInPlace(value);
260: 			negative = 1;
261: 		} else {
262: 			negative = 0;
263: 		}
264: 		if (scale == 0) {
265: 			// scale is 0: regular number
266: 			return UnsignedLength(value) + negative;
267: 		}
268: 		// length is max of either:
269: 		// scale + 2 OR
270: 		// integer length + 1
271: 		// scale + 2 happens when the number is in the range of (-1, 1)
272: 		// in that case we print "0.XXX", which is the scale, plus "0." (2 chars)
273: 		// integer length + 1 happens when the number is outside of that range
274: 		// in that case we print the integer number, but with one extra character ('.')
275: 		return MaxValue(scale + 2, UnsignedLength(value) + 1) + negative;
276: 	}
277: 
278: 	static void FormatDecimal(hugeint_t value, uint8_t scale, char *dst, int len) {
279: 		auto endptr = dst + len;
280: 
281: 		int negative = value.upper < 0;
282: 		if (negative) {
283: 			Hugeint::NegateInPlace(value);
284: 			*dst = '-';
285: 			dst++;
286: 		}
287: 		if (scale == 0) {
288: 			// with scale=0 we format the number as a regular number
289: 			FormatUnsigned(value, endptr);
290: 			return;
291: 		}
292: 
293: 		// we write two numbers:
294: 		// the numbers BEFORE the decimal (major)
295: 		// and the numbers AFTER the decimal (minor)
296: 		hugeint_t minor;
297: 		hugeint_t major = Hugeint::DivMod(value, Hugeint::POWERS_OF_TEN[scale], minor);
298: 
299: 		// write the number after the decimal
300: 		dst = FormatUnsigned(minor, endptr);
301: 		// (optionally) pad with zeros and add the decimal point
302: 		while (dst > (endptr - scale)) {
303: 			*--dst = '0';
304: 		}
305: 		*--dst = '.';
306: 		// now write the part before the decimal
307: 		dst = FormatUnsigned(major, dst);
308: 	}
309: 
310: 	static string_t FormatDecimal(hugeint_t value, uint8_t scale, Vector &vector) {
311: 		int length = DecimalLength(value, scale);
312: 		string_t result = StringVector::EmptyString(vector, length);
313: 
314: 		auto dst = result.GetDataWriteable();
315: 
316: 		FormatDecimal(value, scale, dst, length);
317: 
318: 		result.Finalize();
319: 		return result;
320: 	}
321: };
322: 
323: struct DateToStringCast {
324: 	static idx_t Length(int32_t date[], idx_t &year_length, bool &add_bc) {
325: 		// format is YYYY-MM-DD with optional (BC) at the end
326: 		// regular length is 10
327: 		idx_t length = 6;
328: 		year_length = 4;
329: 		add_bc = false;
330: 		if (date[0] <= 0) {
331: 			// add (BC) suffix
332: 			length += 5;
333: 			date[0] = -date[0] + 1;
334: 			add_bc = true;
335: 		}
336: 
337: 		// potentially add extra characters depending on length of year
338: 		year_length += date[0] >= 10000;
339: 		year_length += date[0] >= 100000;
340: 		year_length += date[0] >= 1000000;
341: 		year_length += date[0] >= 10000000;
342: 		length += year_length;
343: 		return length;
344: 	}
345: 
346: 	static void Format(char *data, int32_t date[], idx_t year_length, bool add_bc) {
347: 		// now we write the string, first write the year
348: 		auto endptr = data + year_length;
349: 		endptr = NumericHelper::FormatUnsigned(date[0], endptr);
350: 		// add optional leading zeros
351: 		while (endptr > data) {
352: 			*--endptr = '0';
353: 		}
354: 		// now write the month and day
355: 		auto ptr = data + year_length;
356: 		for (int i = 1; i <= 2; i++) {
357: 			ptr[0] = '-';
358: 			if (date[i] < 10) {
359: 				ptr[1] = '0';
360: 				ptr[2] = '0' + date[i];
361: 			} else {
362: 				auto index = static_cast<unsigned>(date[i] * 2);
363: 				ptr[1] = duckdb_fmt::internal::data::digits[index];
364: 				ptr[2] = duckdb_fmt::internal::data::digits[index + 1];
365: 			}
366: 			ptr += 3;
367: 		}
368: 		// optionally add BC to the end of the date
369: 		if (add_bc) {
370: 			memcpy(ptr, " (BC)", 5);
371: 		}
372: 	}
373: };
374: 
375: struct TimeToStringCast {
376: 	//! Format microseconds to a buffer of length 6. Returns the number of trailing zeros
377: 	static int32_t FormatMicros(uint32_t microseconds, char micro_buffer[]) {
378: 		char *endptr = micro_buffer + 6;
379: 		endptr = NumericHelper::FormatUnsigned<uint32_t>(microseconds, endptr);
380: 		while (endptr > micro_buffer) {
381: 			*--endptr = '0';
382: 		}
383: 		idx_t trailing_zeros = 0;
384: 		for (idx_t i = 5; i > 0; i--) {
385: 			if (micro_buffer[i] != '0') {
386: 				break;
387: 			}
388: 			trailing_zeros++;
389: 		}
390: 		return trailing_zeros;
391: 	}
392: 
393: 	static idx_t Length(int32_t time[], char micro_buffer[]) {
394: 		// format is HH:MM:DD.MS
395: 		// microseconds come after the time with a period separator
396: 		idx_t length;
397: 		if (time[3] == 0) {
398: 			// no microseconds
399: 			// format is HH:MM:DD
400: 			length = 8;
401: 		} else {
402: 			length = 15;
403: 			// for microseconds, we truncate any trailing zeros (i.e. "90000" becomes ".9")
404: 			// first write the microseconds to the microsecond buffer
405: 			// we write backwards and pad with zeros to the left
406: 			// now we figure out how many digits we need to include by looking backwards
407: 			// and checking how many zeros we encounter
408: 			length -= FormatMicros(time[3], micro_buffer);
409: 		}
410: 		return length;
411: 	}
412: 
413: 	static void FormatTwoDigits(char *ptr, int32_t value) {
414: 		D_ASSERT(value >= 0 && value <= 99);
415: 		if (value < 10) {
416: 			ptr[0] = '0';
417: 			ptr[1] = '0' + value;
418: 		} else {
419: 			auto index = static_cast<unsigned>(value * 2);
420: 			ptr[0] = duckdb_fmt::internal::data::digits[index];
421: 			ptr[1] = duckdb_fmt::internal::data::digits[index + 1];
422: 		}
423: 	}
424: 
425: 	static void Format(char *data, idx_t length, int32_t time[], char micro_buffer[]) {
426: 		// first write hour, month and day
427: 		auto ptr = data;
428: 		ptr[2] = ':';
429: 		ptr[5] = ':';
430: 		for (int i = 0; i <= 2; i++) {
431: 			FormatTwoDigits(ptr, time[i]);
432: 			ptr += 3;
433: 		}
434: 		if (length > 8) {
435: 			// write the micro seconds at the end
436: 			data[8] = '.';
437: 			memcpy(data + 9, micro_buffer, length - 9);
438: 		}
439: 	}
440: };
441: 
442: struct IntervalToStringCast {
443: 	static void FormatSignedNumber(int64_t value, char buffer[], idx_t &length) {
444: 		int sign = -(value < 0);
445: 		uint64_t unsigned_value = (value ^ sign) - sign;
446: 		length += NumericHelper::UnsignedLength<uint64_t>(unsigned_value) - sign;
447: 		auto endptr = buffer + length;
448: 		endptr = NumericHelper::FormatUnsigned<uint64_t>(unsigned_value, endptr);
449: 		if (sign) {
450: 			*--endptr = '-';
451: 		}
452: 	}
453: 
454: 	static void FormatTwoDigits(int64_t value, char buffer[], idx_t &length) {
455: 		TimeToStringCast::FormatTwoDigits(buffer + length, value);
456: 		length += 2;
457: 	}
458: 
459: 	static void FormatIntervalValue(int32_t value, char buffer[], idx_t &length, const char *name, idx_t name_len) {
460: 		if (value == 0) {
461: 			return;
462: 		}
463: 		if (length != 0) {
464: 			// space if there is already something in the buffer
465: 			buffer[length++] = ' ';
466: 		}
467: 		FormatSignedNumber(value, buffer, length);
468: 		// append the name together with a potential "s" (for plurals)
469: 		memcpy(buffer + length, name, name_len);
470: 		length += name_len;
471: 		if (value != 1) {
472: 			buffer[length++] = 's';
473: 		}
474: 	}
475: 
476: 	//! Formats an interval to a buffer, the buffer should be >=70 characters
477: 	//! years: 17 characters (max value: "-2147483647 years")
478: 	//! months: 9 (max value: "12 months")
479: 	//! days: 16 characters (max value: "-2147483647 days")
480: 	//! time: 24 characters (max value: -2562047788:00:00.123456)
481: 	//! spaces between all characters (+3 characters)
482: 	//! Total: 70 characters
483: 	//! Returns the length of the interval
484: 	static idx_t Format(interval_t interval, char buffer[]) {
485: 		idx_t length = 0;
486: 		if (interval.months != 0) {
487: 			int32_t years = interval.months / 12;
488: 			int32_t months = interval.months - years * 12;
489: 			// format the years and months
490: 			FormatIntervalValue(years, buffer, length, " year", 5);
491: 			FormatIntervalValue(months, buffer, length, " month", 6);
492: 		}
493: 		if (interval.days != 0) {
494: 			// format the days
495: 			FormatIntervalValue(interval.days, buffer, length, " day", 4);
496: 		}
497: 		if (interval.micros != 0) {
498: 			if (length != 0) {
499: 				// space if there is already something in the buffer
500: 				buffer[length++] = ' ';
501: 			}
502: 			int64_t micros = interval.micros;
503: 			if (micros < 0) {
504: 				// negative time: append negative sign
505: 				buffer[length++] = '-';
506: 				micros = -micros;
507: 			}
508: 			int64_t hour = micros / Interval::MICROS_PER_HOUR;
509: 			micros -= hour * Interval::MICROS_PER_HOUR;
510: 			int64_t min = micros / Interval::MICROS_PER_MINUTE;
511: 			micros -= min * Interval::MICROS_PER_MINUTE;
512: 			int64_t sec = micros / Interval::MICROS_PER_SEC;
513: 			micros -= sec * Interval::MICROS_PER_SEC;
514: 
515: 			if (hour < 10) {
516: 				buffer[length++] = '0';
517: 			}
518: 			FormatSignedNumber(hour, buffer, length);
519: 			buffer[length++] = ':';
520: 			FormatTwoDigits(min, buffer, length);
521: 			buffer[length++] = ':';
522: 			FormatTwoDigits(sec, buffer, length);
523: 			if (micros != 0) {
524: 				buffer[length++] = '.';
525: 				auto trailing_zeros = TimeToStringCast::FormatMicros(micros, buffer + length);
526: 				length += 6 - trailing_zeros;
527: 			}
528: 		} else if (length == 0) {
529: 			// empty interval: default to 00:00:00
530: 			memcpy(buffer, "00:00:00", 8);
531: 			return 8;
532: 		}
533: 		return length;
534: 	}
535: };
536: 
537: } // namespace duckdb
[end of src/include/duckdb/common/types/cast_helpers.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: