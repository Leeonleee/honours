{
  "repo": "duckdb/duckdb",
  "pull_number": 3965,
  "instance_id": "duckdb__duckdb-3965",
  "issue_numbers": [
    "3942",
    "3942"
  ],
  "base_commit": "7e97a4a158d930d13122e89a1c8ffc7d60acf24b",
  "patch": "diff --git a/extension/httpfs/httpfs.cpp b/extension/httpfs/httpfs.cpp\nindex be0d585defe1..0b602a0fa15a 100644\n--- a/extension/httpfs/httpfs.cpp\n+++ b/extension/httpfs/httpfs.cpp\n@@ -311,7 +311,7 @@ bool HTTPFileSystem::FileExists(const string &filename) {\n \t\tauto handle = OpenFile(filename.c_str(), FileFlags::FILE_FLAGS_READ);\n \t\tauto &sfh = (HTTPFileHandle &)handle;\n \t\tif (sfh.length == 0) {\n-\t\t\tthrow std::runtime_error(\"not there this file\");\n+\t\t\treturn false;\n \t\t}\n \t\treturn true;\n \t} catch (...) {\ndiff --git a/extension/httpfs/include/s3fs.hpp b/extension/httpfs/include/s3fs.hpp\nindex ccf64ba0dba6..646769061c2c 100644\n--- a/extension/httpfs/include/s3fs.hpp\n+++ b/extension/httpfs/include/s3fs.hpp\n@@ -73,9 +73,9 @@ class S3FileHandle : public HTTPFileHandle {\n \tfriend class S3FileSystem;\n \n public:\n-\tS3FileHandle(FileSystem &fs, std::string path, uint8_t flags, const HTTPParams &http_params,\n+\tS3FileHandle(FileSystem &fs, std::string path_p, uint8_t flags, const HTTPParams &http_params,\n \t             const S3AuthParams &auth_params_p, const S3ConfigParams &config_params_p)\n-\t    : HTTPFileHandle(fs, std::move(path), flags, http_params), auth_params(auth_params_p),\n+\t    : HTTPFileHandle(fs, std::move(path_p), flags, http_params), auth_params(auth_params_p),\n \t      config_params(config_params_p) {\n \n \t\tif (flags & FileFlags::FILE_FLAGS_WRITE && flags & FileFlags::FILE_FLAGS_READ) {\ndiff --git a/third_party/httplib/httplib.hpp b/third_party/httplib/httplib.hpp\nindex 714fd324e9c1..7cb6324b3f27 100644\n--- a/third_party/httplib/httplib.hpp\n+++ b/third_party/httplib/httplib.hpp\n@@ -6072,7 +6072,7 @@ inline bool ClientImpl::redirect(Request &req, Response &res, Error &error) {\n \t\treturn false;\n \t}\n \n-\tauto location = detail::decode_url(res.get_header_value(\"location\"), true);\n+\tauto location = detail::decode_url(res.get_header_value(\"location\"), false);\n \tif (location.empty()) { return false; }\n \n \tconst static Regex re(\n",
  "test_patch": "diff --git a/test/sql/copy/parquet/test_parquet_remote.test b/test/sql/copy/parquet/test_parquet_remote.test\nindex 6fe9a8bc4490..e38e9285f0f5 100644\n--- a/test/sql/copy/parquet/test_parquet_remote.test\n+++ b/test/sql/copy/parquet/test_parquet_remote.test\n@@ -66,4 +66,19 @@ SELECT id, first_name, last_name, email FROM PARQUET_SCAN('https://github.com:44\n 7\tSamuel\tHolmes\tsholmes6@foxnews.com\n 8\tHarry\tHowell\thhowell7@eepurl.com\n 9\tJose\tFoster\tjfoster8@yelp.com\n-10\tEmily\tStewart\testewart9@opensource.org\n\\ No newline at end of file\n+10\tEmily\tStewart\testewart9@opensource.org\n+\n+# with a + in the path\n+query IIII\n+SELECT id, first_name, last_name, email FROM PARQUET_SCAN('https://github.com/cwida/duckdb-data/releases/download/v1.0/us+er+da+ta.parquet') LIMIT 10;\n+----\n+1\tAmanda\tJordan\tajordan0@com.com\n+2\tAlbert\tFreeman\tafreeman1@is.gd\n+3\tEvelyn\tMorgan\temorgan2@altervista.org\n+4\tDenise\tRiley\tdriley3@gmpg.org\n+5\tCarlos\tBurns\tcburns4@miitbeian.gov.cn\n+6\tKathryn\tWhite\tkwhite5@google.com\n+7\tSamuel\tHolmes\tsholmes6@foxnews.com\n+8\tHarry\tHowell\thhowell7@eepurl.com\n+9\tJose\tFoster\tjfoster8@yelp.com\n+10\tEmily\tStewart\testewart9@opensource.org\n",
  "problem_statement": "Write CSV with timestamp columns in ISO 8601 strings\nRight now, if I write a CSV with either `COPY` or `EXPORT DATABASE` statements, the only format I can get for timestamp columns is not ISO-8601 compliant, e.g. `2021-02-01 13:00:00`.  I'd like to be able to tell DuckDB to write the ISO-8601 format `2021-02-01T13:00:00Z`, instead.\r\n\r\nDocumentation for both `COPY` AND `EXPORT DATABASE` suggest I might be able to set a `TIMESTAMPFORMAT` option. But when I try this, I'm told that it is not yet implemented: `Not implemented Error: Unrecognized option for CSV: TIMESTAMPFORMAT`.\r\n\r\nI [chatted with `__Alex__` about this in Discord](https://discord.com/channels/909674491309850675/921073327009853451/989378834828767313), and he suggested I file this issue. Thanks!\nWrite CSV with timestamp columns in ISO 8601 strings\nRight now, if I write a CSV with either `COPY` or `EXPORT DATABASE` statements, the only format I can get for timestamp columns is not ISO-8601 compliant, e.g. `2021-02-01 13:00:00`.  I'd like to be able to tell DuckDB to write the ISO-8601 format `2021-02-01T13:00:00Z`, instead.\r\n\r\nDocumentation for both `COPY` AND `EXPORT DATABASE` suggest I might be able to set a `TIMESTAMPFORMAT` option. But when I try this, I'm told that it is not yet implemented: `Not implemented Error: Unrecognized option for CSV: TIMESTAMPFORMAT`.\r\n\r\nI [chatted with `__Alex__` about this in Discord](https://discord.com/channels/909674491309850675/921073327009853451/989378834828767313), and he suggested I file this issue. Thanks!\n",
  "hints_text": "We should probably use the T there by default\n`TIMESTAMPFORMAT` is only supported for reading CSVs, we should implement this for writing as well.\r\n\r\n> We should probably use the T there by default\r\n\r\nPostgres does not, and I would follow them here, but we could certainly make a short-cut (e.g. `TIMESTAMPFORMAT 'iso'`).\nI think that both the middle `T` and the final `Z` are important for a fully valid ISO string.\nWe should probably use the T there by default\n`TIMESTAMPFORMAT` is only supported for reading CSVs, we should implement this for writing as well.\r\n\r\n> We should probably use the T there by default\r\n\r\nPostgres does not, and I would follow them here, but we could certainly make a short-cut (e.g. `TIMESTAMPFORMAT 'iso'`).\nI think that both the middle `T` and the final `Z` are important for a fully valid ISO string.",
  "created_at": "2022-06-25T13:19:17Z"
}