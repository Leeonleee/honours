You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
NullPointer at duckdb/src/function/function.cpp:368:29
#### What happens?
/root/duckdb/src/function/function.cpp:368:29: runtime error: member access within null pointer of type 'duckdb::Expression'

#### To Reproduce
```sql
CREATE TABLE strings(a INTEGER);
CREATE TABLE c0(test2 tinyint, s1 smallint, s2 integer, test1 bigint, i double, id real, c1 varchar);
SELECT * FROM c0 s1 INNER JOIN c0 s2 ON (SELECT s1.s2=s2 FROM c0 WHERE s2.s2=s2) ORDER BY s1.s2;
```

#### Environment (please complete the following information):
 - OS: linux
 - DuckDB Version: v0.3.3-dev1395 80ae1e12d
 - DuckDB Client: /usr/local/duckdb

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

#### ASAN  detail
```
AddressSanitizer:DEADLYSIGNAL
=================================================================
==12804==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000030 (pc 0x000001460dcb bp 0x7ffd665bc550 sp 0x7ffd665bc3a8 T0)
==12804==The signal is caused by a READ memory access.
==12804==Hint: address points to the zero page.
    #0 0x1460dcb in duckdb::LogicalType::LogicalType(duckdb::LogicalType const&) /root/duckdb/src/common/types.cpp:34:17
    #1 0xee5e64 in void __gnu_cxx::new_allocator<duckdb::LogicalType>::construct<duckdb::LogicalType, duckdb::LogicalType const&>(duckdb::LogicalType*, duckdb::LogicalType const&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/ext/new_allocator.h:147:23
    #2 0xee5e64 in void std::allocator_traits<std::allocator<duckdb::LogicalType> >::construct<duckdb::LogicalType, duckdb::LogicalType const&>(std::allocator<duckdb::LogicalType>&, duckdb::LogicalType*, duckdb::LogicalType const&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/alloc_traits.h:484:8
    #3 0xee5e64 in std::vector<duckdb::LogicalType, std::allocator<duckdb::LogicalType> >::push_back(duckdb::LogicalType const&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1189:6
    #4 0xee5e64 in duckdb::GetLogicalTypesFromExpressions(std::vector<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> >, std::allocator<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> > > >&) /root/duckdb/src/function/function.cpp:368:9
    #5 0xed8a11 in duckdb::Function::BindFunction(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::vector<duckdb::ScalarFunction, std::allocator<duckdb::ScalarFunction> >&, std::vector<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> >, std::allocator<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> > > >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) /root/duckdb/src/function/function.cpp:375:15
    #6 0xed8dd3 in duckdb::ScalarFunction::BindScalarFunction(duckdb::ClientContext&, duckdb::ScalarFunctionCatalogEntry&, std::vector<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> >, std::allocator<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> > > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, bool) /root/duckdb/src/function/function.cpp:444:24
    #7 0x1ac1042 in duckdb::ExpressionBinder::BindFunction(duckdb::FunctionExpression&, duckdb::ScalarFunctionCatalogEntry*, unsigned long) /root/duckdb/src/planner/binder/expression/bind_function_expression.cpp:61:6
    #8 0x1ac0b09 in duckdb::ExpressionBinder::BindExpression(duckdb::FunctionExpression&, unsigned long, std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*) /root/duckdb/src/planner/binder/expression/bind_function_expression.cpp:30:10
    #9 0x7359ba in duckdb::ExpressionBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:57:10
    #10 0x720097 in duckdb::WhereBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder/where_binder.cpp:37:28
    #11 0x73614a in duckdb::ExpressionBinder::Bind[abi:cxx11](std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:228:22
    #12 0x72c861 in duckdb::ExpressionBinder::BindChild(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >&, unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) /root/duckdb/src/planner/expression_binder.cpp:98:23
    #13 0x1abf5b0 in duckdb::ExpressionBinder::BindExpression(duckdb::ComparisonExpression&, unsigned long) /root/duckdb/src/planner/binder/expression/bind_comparison_expression.cpp:116:2
    #14 0x73599a in duckdb::ExpressionBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:50:10
    #15 0x720097 in duckdb::WhereBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder/where_binder.cpp:37:28
    #16 0x73614a in duckdb::ExpressionBinder::Bind[abi:cxx11](std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:228:22
    #17 0x735cd6 in duckdb::ExpressionBinder::BindCorrelatedColumns(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >&) /root/duckdb/src/planner/expression_binder.cpp:84:35
    #18 0x737e18 in duckdb::ExpressionBinder::Bind(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >&, duckdb::LogicalType*, bool) /root/duckdb/src/planner/expression_binder.cpp:187:18
    #19 0x1ad6b83 in duckdb::Binder::BindNode(duckdb::SelectNode&) /root/duckdb/src/planner/binder/query_node/bind_select_node.cpp:374:29
    #20 0x73bc5d in duckdb::Binder::BindNode(duckdb::QueryNode&) /root/duckdb/src/planner/binder.cpp:94:12
    #21 0x1ac6052 in duckdb::ExpressionBinder::BindExpression(duckdb::SubqueryExpression&, unsigned long) /root/duckdb/src/planner/binder/expression/bind_subquery_expression.cpp:40:38
    #22 0x7358ae in duckdb::ExpressionBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:63:10
    #23 0x720097 in duckdb::WhereBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder/where_binder.cpp:37:28
    #24 0x73614a in duckdb::ExpressionBinder::Bind[abi:cxx11](std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:228:22
    #25 0x737e05 in duckdb::ExpressionBinder::Bind(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >&, duckdb::LogicalType*, bool) /root/duckdb/src/planner/expression_binder.cpp:184:19
    #26 0x7067e1 in duckdb::Binder::Bind(duckdb::JoinRef&) /root/duckdb/src/planner/binder/tableref/bind_joinref.cpp:234:30
    #27 0x73c315 in duckdb::Binder::Bind(duckdb::TableRef&) /root/duckdb/src/planner/binder.cpp:142:12
    #28 0x1ad5291 in duckdb::Binder::BindNode(duckdb::SelectNode&) /root/duckdb/src/planner/binder/query_node/bind_select_node.cpp:266:23
    #29 0x73bc5d in duckdb::Binder::BindNode(duckdb::QueryNode&) /root/duckdb/src/planner/binder.cpp:94:12
    #30 0x73bd1b in duckdb::Binder::Bind(duckdb::QueryNode&) /root/duckdb/src/planner/binder.cpp:108:20
    #31 0x6c2630 in duckdb::Binder::Bind(duckdb::SelectStatement&) /root/duckdb/src/planner/binder/statement/bind_select.cpp:9:9
    #32 0x73b746 in duckdb::Binder::Bind(duckdb::SQLStatement&) /root/duckdb/src/planner/binder.cpp:44:10
    #33 0x744395 in duckdb::Planner::CreatePlan(duckdb::SQLStatement&) /root/duckdb/src/planner/planner.cpp:31:33
    #34 0x514010 in duckdb::ClientContext::CreatePreparedStatement(duckdb::ClientContextLock&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/main/client_context.cpp:251:10
    #35 0x51591e in duckdb::ClientContext::PendingStatementInternal(duckdb::ClientContextLock&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/main/client_context.cpp:482:18
    #36 0x5178af in duckdb::ClientContext::PendingStatementOrPreparedStatement(duckdb::ClientContextLock&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, std::shared_ptr<duckdb::PreparedStatementData>&, std::vector<duckdb::Value, std::allocator<duckdb::Value> >*) /root/duckdb/src/main/client_context.cpp:557:13
    #37 0x515492 in duckdb::ClientContext::PendingStatementOrPreparedStatementInternal(duckdb::ClientContextLock&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, std::shared_ptr<duckdb::PreparedStatementData>&, std::vector<duckdb::Value, std::allocator<duckdb::Value> >*) /root/duckdb/src/main/client_context.cpp:541:9
    #38 0x5341e3 in duckdb::ClientContext::PendingQueryInternal(duckdb::ClientContextLock&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, bool) /root/duckdb/src/main/client_context.cpp:692:10
    #39 0x518319 in duckdb::ClientContext::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) /root/duckdb/src/main/client_context.cpp:634:24
    #40 0x519c06 in duckdb::Connection::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /root/duckdb/src/main/connection.cpp:71:25
    #41 0x4e57c8 in duckdb_query /root/duckdb/src/main/capi/duckdb-c.cpp:67:22
    #42 0x4e10d3 in run_one_statement_new(void*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /mnt/jingzhou_workspace/sqlsim/client_new/duckdb/client_new.cpp:57:13
    #43 0x4d3984 in run_testcase(void*&, char const*, int) /root/autodriver.cpp:102:14
    #44 0x4d8601 in do_fuzz()::$_3::operator()() const /root/autodriver.cpp:227:13
    #45 0x4d809e in do_fuzz() /root/autodriver.cpp:235:13
    #46 0x4d8b43 in main /root/autodriver.cpp:292:9
    #47 0x7f107cf9e0b2 in __libc_start_main /build/glibc-sMfBJT/glibc-2.31/csu/../csu/libc-start.c:308:16
    #48 0x4247ad in _start (/root/autodriver+0x4247ad)
```
NullPointer at duckdb/src/function/function.cpp:368:29
#### What happens?
/root/duckdb/src/function/function.cpp:368:29: runtime error: member access within null pointer of type 'duckdb::Expression'

#### To Reproduce
```sql
CREATE TABLE strings(a INTEGER);
CREATE TABLE c0(test2 tinyint, s1 smallint, s2 integer, test1 bigint, i double, id real, c1 varchar);
SELECT * FROM c0 s1 INNER JOIN c0 s2 ON (SELECT s1.s2=s2 FROM c0 WHERE s2.s2=s2) ORDER BY s1.s2;
```

#### Environment (please complete the following information):
 - OS: linux
 - DuckDB Version: v0.3.3-dev1395 80ae1e12d
 - DuckDB Client: /usr/local/duckdb

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

#### ASAN  detail
```
AddressSanitizer:DEADLYSIGNAL
=================================================================
==12804==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000030 (pc 0x000001460dcb bp 0x7ffd665bc550 sp 0x7ffd665bc3a8 T0)
==12804==The signal is caused by a READ memory access.
==12804==Hint: address points to the zero page.
    #0 0x1460dcb in duckdb::LogicalType::LogicalType(duckdb::LogicalType const&) /root/duckdb/src/common/types.cpp:34:17
    #1 0xee5e64 in void __gnu_cxx::new_allocator<duckdb::LogicalType>::construct<duckdb::LogicalType, duckdb::LogicalType const&>(duckdb::LogicalType*, duckdb::LogicalType const&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/ext/new_allocator.h:147:23
    #2 0xee5e64 in void std::allocator_traits<std::allocator<duckdb::LogicalType> >::construct<duckdb::LogicalType, duckdb::LogicalType const&>(std::allocator<duckdb::LogicalType>&, duckdb::LogicalType*, duckdb::LogicalType const&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/alloc_traits.h:484:8
    #3 0xee5e64 in std::vector<duckdb::LogicalType, std::allocator<duckdb::LogicalType> >::push_back(duckdb::LogicalType const&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1189:6
    #4 0xee5e64 in duckdb::GetLogicalTypesFromExpressions(std::vector<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> >, std::allocator<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> > > >&) /root/duckdb/src/function/function.cpp:368:9
    #5 0xed8a11 in duckdb::Function::BindFunction(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::vector<duckdb::ScalarFunction, std::allocator<duckdb::ScalarFunction> >&, std::vector<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> >, std::allocator<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> > > >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) /root/duckdb/src/function/function.cpp:375:15
    #6 0xed8dd3 in duckdb::ScalarFunction::BindScalarFunction(duckdb::ClientContext&, duckdb::ScalarFunctionCatalogEntry&, std::vector<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> >, std::allocator<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> > > >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, bool) /root/duckdb/src/function/function.cpp:444:24
    #7 0x1ac1042 in duckdb::ExpressionBinder::BindFunction(duckdb::FunctionExpression&, duckdb::ScalarFunctionCatalogEntry*, unsigned long) /root/duckdb/src/planner/binder/expression/bind_function_expression.cpp:61:6
    #8 0x1ac0b09 in duckdb::ExpressionBinder::BindExpression(duckdb::FunctionExpression&, unsigned long, std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*) /root/duckdb/src/planner/binder/expression/bind_function_expression.cpp:30:10
    #9 0x7359ba in duckdb::ExpressionBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:57:10
    #10 0x720097 in duckdb::WhereBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder/where_binder.cpp:37:28
    #11 0x73614a in duckdb::ExpressionBinder::Bind[abi:cxx11](std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:228:22
    #12 0x72c861 in duckdb::ExpressionBinder::BindChild(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >&, unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) /root/duckdb/src/planner/expression_binder.cpp:98:23
    #13 0x1abf5b0 in duckdb::ExpressionBinder::BindExpression(duckdb::ComparisonExpression&, unsigned long) /root/duckdb/src/planner/binder/expression/bind_comparison_expression.cpp:116:2
    #14 0x73599a in duckdb::ExpressionBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:50:10
    #15 0x720097 in duckdb::WhereBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder/where_binder.cpp:37:28
    #16 0x73614a in duckdb::ExpressionBinder::Bind[abi:cxx11](std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:228:22
    #17 0x735cd6 in duckdb::ExpressionBinder::BindCorrelatedColumns(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >&) /root/duckdb/src/planner/expression_binder.cpp:84:35
    #18 0x737e18 in duckdb::ExpressionBinder::Bind(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >&, duckdb::LogicalType*, bool) /root/duckdb/src/planner/expression_binder.cpp:187:18
    #19 0x1ad6b83 in duckdb::Binder::BindNode(duckdb::SelectNode&) /root/duckdb/src/planner/binder/query_node/bind_select_node.cpp:374:29
    #20 0x73bc5d in duckdb::Binder::BindNode(duckdb::QueryNode&) /root/duckdb/src/planner/binder.cpp:94:12
    #21 0x1ac6052 in duckdb::ExpressionBinder::BindExpression(duckdb::SubqueryExpression&, unsigned long) /root/duckdb/src/planner/binder/expression/bind_subquery_expression.cpp:40:38
    #22 0x7358ae in duckdb::ExpressionBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:63:10
    #23 0x720097 in duckdb::WhereBinder::BindExpression(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder/where_binder.cpp:37:28
    #24 0x73614a in duckdb::ExpressionBinder::Bind[abi:cxx11](std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >*, unsigned long, bool) /root/duckdb/src/planner/expression_binder.cpp:228:22
    #25 0x737e05 in duckdb::ExpressionBinder::Bind(std::unique_ptr<duckdb::ParsedExpression, std::default_delete<duckdb::ParsedExpression> >&, duckdb::LogicalType*, bool) /root/duckdb/src/planner/expression_binder.cpp:184:19
    #26 0x7067e1 in duckdb::Binder::Bind(duckdb::JoinRef&) /root/duckdb/src/planner/binder/tableref/bind_joinref.cpp:234:30
    #27 0x73c315 in duckdb::Binder::Bind(duckdb::TableRef&) /root/duckdb/src/planner/binder.cpp:142:12
    #28 0x1ad5291 in duckdb::Binder::BindNode(duckdb::SelectNode&) /root/duckdb/src/planner/binder/query_node/bind_select_node.cpp:266:23
    #29 0x73bc5d in duckdb::Binder::BindNode(duckdb::QueryNode&) /root/duckdb/src/planner/binder.cpp:94:12
    #30 0x73bd1b in duckdb::Binder::Bind(duckdb::QueryNode&) /root/duckdb/src/planner/binder.cpp:108:20
    #31 0x6c2630 in duckdb::Binder::Bind(duckdb::SelectStatement&) /root/duckdb/src/planner/binder/statement/bind_select.cpp:9:9
    #32 0x73b746 in duckdb::Binder::Bind(duckdb::SQLStatement&) /root/duckdb/src/planner/binder.cpp:44:10
    #33 0x744395 in duckdb::Planner::CreatePlan(duckdb::SQLStatement&) /root/duckdb/src/planner/planner.cpp:31:33
    #34 0x514010 in duckdb::ClientContext::CreatePreparedStatement(duckdb::ClientContextLock&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/main/client_context.cpp:251:10
    #35 0x51591e in duckdb::ClientContext::PendingStatementInternal(duckdb::ClientContextLock&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /root/duckdb/src/main/client_context.cpp:482:18
    #36 0x5178af in duckdb::ClientContext::PendingStatementOrPreparedStatement(duckdb::ClientContextLock&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, std::shared_ptr<duckdb::PreparedStatementData>&, std::vector<duckdb::Value, std::allocator<duckdb::Value> >*) /root/duckdb/src/main/client_context.cpp:557:13
    #37 0x515492 in duckdb::ClientContext::PendingStatementOrPreparedStatementInternal(duckdb::ClientContextLock&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, std::shared_ptr<duckdb::PreparedStatementData>&, std::vector<duckdb::Value, std::allocator<duckdb::Value> >*) /root/duckdb/src/main/client_context.cpp:541:9
    #38 0x5341e3 in duckdb::ClientContext::PendingQueryInternal(duckdb::ClientContextLock&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, bool) /root/duckdb/src/main/client_context.cpp:692:10
    #39 0x518319 in duckdb::ClientContext::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) /root/duckdb/src/main/client_context.cpp:634:24
    #40 0x519c06 in duckdb::Connection::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /root/duckdb/src/main/connection.cpp:71:25
    #41 0x4e57c8 in duckdb_query /root/duckdb/src/main/capi/duckdb-c.cpp:67:22
    #42 0x4e10d3 in run_one_statement_new(void*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /mnt/jingzhou_workspace/sqlsim/client_new/duckdb/client_new.cpp:57:13
    #43 0x4d3984 in run_testcase(void*&, char const*, int) /root/autodriver.cpp:102:14
    #44 0x4d8601 in do_fuzz()::$_3::operator()() const /root/autodriver.cpp:227:13
    #45 0x4d809e in do_fuzz() /root/autodriver.cpp:235:13
    #46 0x4d8b43 in main /root/autodriver.cpp:292:9
    #47 0x7f107cf9e0b2 in __libc_start_main /build/glibc-sMfBJT/glibc-2.31/csu/../csu/libc-start.c:308:16
    #48 0x4247ad in _start (/root/autodriver+0x4247ad)
```

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of src/planner/binder/expression/bind_columnref_expression.cpp]
1: #include "duckdb/parser/expression/columnref_expression.hpp"
2: #include "duckdb/planner/binder.hpp"
3: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
4: #include "duckdb/planner/expression_binder.hpp"
5: #include "duckdb/parser/expression/operator_expression.hpp"
6: #include "duckdb/common/string_util.hpp"
7: #include "duckdb/parser/parsed_expression_iterator.hpp"
8: #include "duckdb/parser/expression/positional_reference_expression.hpp"
9: #include "duckdb/planner/binder.hpp"
10: #include "duckdb/planner/expression_binder/where_binder.hpp"
11: #include "duckdb/function/scalar/nested_functions.hpp"
12: #include "duckdb/parser/expression/constant_expression.hpp"
13: #include "duckdb/parser/expression/function_expression.hpp"
14: #include "duckdb/parser/expression/subquery_expression.hpp"
15: #include "duckdb/planner/expression/bound_constant_expression.hpp"
16: 
17: namespace duckdb {
18: 
19: unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(const string &column_name, string &error_message) {
20: 	auto using_binding = binder.bind_context.GetUsingBinding(column_name);
21: 	if (using_binding) {
22: 		// we are referencing a USING column
23: 		// check if we can refer to one of the base columns directly
24: 		unique_ptr<Expression> expression;
25: 		if (!using_binding->primary_binding.empty()) {
26: 			// we can! just assign the table name and re-bind
27: 			return make_unique<ColumnRefExpression>(column_name, using_binding->primary_binding);
28: 		} else {
29: 			// // we cannot! we need to bind this as a coalesce between all the relevant columns
30: 			auto coalesce = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
31: 			for (auto &entry : using_binding->bindings) {
32: 				coalesce->children.push_back(make_unique<ColumnRefExpression>(column_name, entry));
33: 			}
34: 			return move(coalesce);
35: 		}
36: 	}
37: 	// no table name: find a binding that contains this
38: 	if (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(column_name)) {
39: 		// priority to macro parameter bindings TODO: throw a warning when this name conflicts
40: 		D_ASSERT(!binder.macro_binding->alias.empty());
41: 		return make_unique<ColumnRefExpression>(column_name, binder.macro_binding->alias);
42: 	} else {
43: 		string table_name = binder.bind_context.GetMatchingBinding(column_name);
44: 		if (table_name.empty()) {
45: 			auto similar_bindings = binder.bind_context.GetSimilarBindings(column_name);
46: 			string candidate_str = StringUtil::CandidatesMessage(similar_bindings, "Candidate bindings");
47: 			error_message =
48: 			    StringUtil::Format("Referenced column \"%s\" not found in FROM clause!%s", column_name, candidate_str);
49: 			return nullptr;
50: 		}
51: 		return binder.bind_context.CreateColumnReference(table_name, column_name);
52: 	}
53: }
54: 
55: void ExpressionBinder::QualifyColumnNames(unique_ptr<ParsedExpression> &expr) {
56: 	switch (expr->type) {
57: 	case ExpressionType::COLUMN_REF: {
58: 		auto &colref = (ColumnRefExpression &)*expr;
59: 		string error_message;
60: 		auto new_expr = QualifyColumnName(colref, error_message);
61: 		if (new_expr) {
62: 			if (!expr->alias.empty()) {
63: 				new_expr->alias = expr->alias;
64: 			}
65: 			expr = move(new_expr);
66: 		}
67: 		break;
68: 	}
69: 	case ExpressionType::POSITIONAL_REFERENCE: {
70: 		auto &ref = (PositionalReferenceExpression &)*expr;
71: 		if (ref.alias.empty()) {
72: 			string table_name, column_name;
73: 			auto error = binder.bind_context.BindColumn(ref, table_name, column_name);
74: 			if (error.empty()) {
75: 				ref.alias = column_name;
76: 			}
77: 		}
78: 		break;
79: 	}
80: 	default:
81: 		break;
82: 	}
83: 	ParsedExpressionIterator::EnumerateChildren(
84: 	    *expr, [&](unique_ptr<ParsedExpression> &child) { QualifyColumnNames(child); });
85: }
86: 
87: void ExpressionBinder::QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr) {
88: 	WhereBinder where_binder(binder, binder.context);
89: 	where_binder.QualifyColumnNames(expr);
90: }
91: 
92: unique_ptr<ParsedExpression> ExpressionBinder::CreateStructExtract(unique_ptr<ParsedExpression> base,
93:                                                                    string field_name) {
94: 	vector<unique_ptr<ParsedExpression>> children;
95: 	children.push_back(move(base));
96: 	children.push_back(make_unique_base<ParsedExpression, ConstantExpression>(Value(move(field_name))));
97: 	auto extract_fun = make_unique<FunctionExpression>("struct_extract", move(children));
98: 	return move(extract_fun);
99: }
100: 
101: unique_ptr<ParsedExpression> ExpressionBinder::QualifyColumnName(ColumnRefExpression &colref, string &error_message) {
102: 	idx_t column_parts = colref.column_names.size();
103: 	// column names can have an arbitrary amount of dots
104: 	// here is how the resolution works:
105: 	if (column_parts == 1) {
106: 		// no dots (i.e. "part1")
107: 		// -> part1 refers to a column
108: 		// check if we can qualify the column name with the table name
109: 		return QualifyColumnName(colref.GetColumnName(), error_message);
110: 	} else if (column_parts == 2) {
111: 		// one dot (i.e. "part1.part2")
112: 		// EITHER:
113: 		// -> part1 is a table, part2 is a column
114: 		// -> part1 is a column, part2 is a property of that column (i.e. struct_extract)
115: 
116: 		// first check if part1 is a table
117: 		if (binder.HasMatchingBinding(colref.column_names[0], colref.column_names[1], error_message)) {
118: 			// it is! return the colref directly
119: 			return binder.bind_context.CreateColumnReference(colref.column_names[0], colref.column_names[1]);
120: 		} else {
121: 			// otherwise check if we can turn this into a struct extract
122: 			auto new_colref = make_unique<ColumnRefExpression>(colref.column_names[0]);
123: 			string other_error;
124: 			auto qualified_colref = QualifyColumnName(colref.column_names[0], other_error);
125: 			if (!qualified_colref) {
126: 				// we could not! bail
127: 				return nullptr;
128: 			}
129: 			// we could: create a struct extract
130: 			return CreateStructExtract(move(qualified_colref), colref.column_names[1]);
131: 		}
132: 	} else {
133: 		// two or more dots (i.e. "part1.part2.part3.part4...")
134: 		// -> part1 is a schema, part2 is a table, part3 is a column name, part4 and beyond are struct fields
135: 		// -> part1 is a table, part2 is a column name, part3 and beyond are struct fields
136: 		// -> part1 is a column, part2 and beyond are struct fields
137: 
138: 		// we always prefer the most top-level view
139: 		// i.e. in case of multiple resolution options, we resolve in order:
140: 		// -> 1. resolve "part1" as a schema
141: 		// -> 2. resolve "part1" as a table
142: 		// -> 3. resolve "part1" as a column
143: 
144: 		unique_ptr<ParsedExpression> result_expr;
145: 		idx_t struct_extract_start;
146: 		// first check if part1 is a schema
147: 		if (binder.HasMatchingBinding(colref.column_names[0], colref.column_names[1], colref.column_names[2],
148: 		                              error_message)) {
149: 			// it is! the column reference is "schema.table.column"
150: 			// any additional fields are turned into struct_extract calls
151: 			result_expr = binder.bind_context.CreateColumnReference(colref.column_names[0], colref.column_names[1],
152: 			                                                        colref.column_names[2]);
153: 			struct_extract_start = 3;
154: 		} else if (binder.HasMatchingBinding(colref.column_names[0], colref.column_names[1], error_message)) {
155: 			// part1 is a table
156: 			// the column reference is "table.column"
157: 			// any additional fields are turned into struct_extract calls
158: 			result_expr = binder.bind_context.CreateColumnReference(colref.column_names[0], colref.column_names[1]);
159: 			struct_extract_start = 2;
160: 		} else {
161: 			// part1 could be a column
162: 			string col_error;
163: 			result_expr = QualifyColumnName(colref.column_names[0], col_error);
164: 			if (!result_expr) {
165: 				// it is not! return the error
166: 				return nullptr;
167: 			}
168: 			// it is! add the struct extract calls
169: 			struct_extract_start = 1;
170: 		}
171: 		for (idx_t i = struct_extract_start; i < colref.column_names.size(); i++) {
172: 			result_expr = CreateStructExtract(move(result_expr), colref.column_names[i]);
173: 		}
174: 		return result_expr;
175: 	}
176: }
177: 
178: BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref_p, idx_t depth) {
179: 	if (binder.GetBindingMode() == BindingMode::EXTRACT_NAMES) {
180: 		return BindResult(make_unique<BoundConstantExpression>(Value(LogicalType::SQLNULL)));
181: 	}
182: 	string error_message;
183: 	auto expr = QualifyColumnName(colref_p, error_message);
184: 	if (!expr) {
185: 		return BindResult(binder.FormatError(colref_p, error_message));
186: 	}
187: 	if (expr->type != ExpressionType::COLUMN_REF) {
188: 		return BindExpression(&expr, depth);
189: 	}
190: 	auto &colref = (ColumnRefExpression &)*expr;
191: 	D_ASSERT(colref.column_names.size() == 2 || colref.column_names.size() == 3);
192: 	auto &table_name = colref.column_names.size() == 3 ? colref.column_names[1] : colref.column_names[0];
193: 	// individual column reference
194: 	// resolve to either a base table or a subquery expression
195: 	// if it was a macro parameter, let macro_binding bind it to the argument
196: 	BindResult result;
197: 	if (binder.macro_binding && table_name == binder.macro_binding->alias) {
198: 		result = binder.macro_binding->Bind(colref, depth);
199: 	} else {
200: 		result = binder.bind_context.BindColumn(colref, depth);
201: 	}
202: 	if (!result.HasError()) {
203: 		BoundColumnReferenceInfo ref;
204: 		ref.name = colref.column_names.back();
205: 		ref.query_location = colref.query_location;
206: 		bound_columns.push_back(move(ref));
207: 	} else {
208: 		result.error = binder.FormatError(colref_p, result.error);
209: 	}
210: 	return result;
211: }
212: 
213: } // namespace duckdb
[end of src/planner/binder/expression/bind_columnref_expression.cpp]
[start of src/planner/binder/expression/bind_function_expression.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/parser/expression/function_expression.hpp"
5: #include "duckdb/planner/expression/bound_cast_expression.hpp"
6: #include "duckdb/planner/expression/bound_constant_expression.hpp"
7: #include "duckdb/planner/expression/bound_function_expression.hpp"
8: #include "duckdb/planner/expression_binder.hpp"
9: #include "duckdb/planner/binder.hpp"
10: 
11: namespace duckdb {
12: 
13: BindResult ExpressionBinder::BindExpression(FunctionExpression &function, idx_t depth,
14:                                             unique_ptr<ParsedExpression> *expr_ptr) {
15: 	// lookup the function in the catalog
16: 	QueryErrorContext error_context(binder.root_statement, function.query_location);
17: 
18: 	if (function.function_name == "unnest" || function.function_name == "unlist") {
19: 		// special case, not in catalog
20: 		// TODO make sure someone does not create such a function OR
21: 		// have unnest live in catalog, too
22: 		return BindUnnest(function, depth);
23: 	}
24: 	auto &catalog = Catalog::GetCatalog(context);
25: 	auto func = catalog.GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, function.schema, function.function_name,
26: 	                             false, error_context);
27: 	switch (func->type) {
28: 	case CatalogType::SCALAR_FUNCTION_ENTRY:
29: 		// scalar function
30: 		return BindFunction(function, (ScalarFunctionCatalogEntry *)func, depth);
31: 	case CatalogType::MACRO_ENTRY:
32: 		// macro function
33: 		return BindMacro(function, (ScalarMacroCatalogEntry *)func, depth, expr_ptr);
34: 	default:
35: 		// aggregate function
36: 		return BindAggregate(function, (AggregateFunctionCatalogEntry *)func, depth);
37: 	}
38: }
39: 
40: BindResult ExpressionBinder::BindFunction(FunctionExpression &function, ScalarFunctionCatalogEntry *func, idx_t depth) {
41: 	// bind the children of the function expression
42: 	string error;
43: 	for (idx_t i = 0; i < function.children.size(); i++) {
44: 		BindChild(function.children[i], depth, error);
45: 	}
46: 	if (!error.empty()) {
47: 		return BindResult(error);
48: 	}
49: 	if (binder.GetBindingMode() == BindingMode::EXTRACT_NAMES) {
50: 		return BindResult(make_unique<BoundConstantExpression>(Value(LogicalType::SQLNULL)));
51: 	}
52: 
53: 	// all children bound successfully
54: 	// extract the children and types
55: 	vector<unique_ptr<Expression>> children;
56: 	for (idx_t i = 0; i < function.children.size(); i++) {
57: 		auto &child = (BoundExpression &)*function.children[i];
58: 		children.push_back(move(child.expr));
59: 	}
60: 	unique_ptr<Expression> result =
61: 	    ScalarFunction::BindScalarFunction(context, *func, move(children), error, function.is_operator);
62: 	if (!result) {
63: 		return BindResult(binder.FormatError(function, error));
64: 	}
65: 	return BindResult(move(result));
66: }
67: 
68: BindResult ExpressionBinder::BindAggregate(FunctionExpression &expr, AggregateFunctionCatalogEntry *function,
69:                                            idx_t depth) {
70: 	return BindResult(binder.FormatError(expr, UnsupportedAggregateMessage()));
71: }
72: 
73: BindResult ExpressionBinder::BindUnnest(FunctionExpression &expr, idx_t depth) {
74: 	return BindResult(binder.FormatError(expr, UnsupportedUnnestMessage()));
75: }
76: 
77: string ExpressionBinder::UnsupportedAggregateMessage() {
78: 	return "Aggregate functions are not supported here";
79: }
80: 
81: string ExpressionBinder::UnsupportedUnnestMessage() {
82: 	return "UNNEST not supported here";
83: }
84: 
85: } // namespace duckdb
[end of src/planner/binder/expression/bind_function_expression.cpp]
[start of src/planner/binder/expression/bind_operator_expression.cpp]
1: #include "duckdb/parser/expression/operator_expression.hpp"
2: #include "duckdb/planner/expression/bound_cast_expression.hpp"
3: #include "duckdb/planner/expression/bound_operator_expression.hpp"
4: #include "duckdb/planner/expression/bound_case_expression.hpp"
5: #include "duckdb/parser/expression/function_expression.hpp"
6: #include "duckdb/planner/expression_binder.hpp"
7: 
8: namespace duckdb {
9: 
10: static LogicalType ResolveNotType(OperatorExpression &op, vector<BoundExpression *> &children) {
11: 	// NOT expression, cast child to BOOLEAN
12: 	D_ASSERT(children.size() == 1);
13: 	children[0]->expr = BoundCastExpression::AddCastToType(move(children[0]->expr), LogicalType::BOOLEAN);
14: 	return LogicalType(LogicalTypeId::BOOLEAN);
15: }
16: 
17: static LogicalType ResolveInType(OperatorExpression &op, vector<BoundExpression *> &children) {
18: 	if (children.empty()) {
19: 		throw InternalException("IN requires at least a single child node");
20: 	}
21: 	// get the maximum type from the children
22: 	LogicalType max_type = children[0]->expr->return_type;
23: 	for (idx_t i = 1; i < children.size(); i++) {
24: 		max_type = LogicalType::MaxLogicalType(max_type, children[i]->expr->return_type);
25: 	}
26: 	ExpressionBinder::ResolveParameterType(max_type);
27: 
28: 	// cast all children to the same type
29: 	for (idx_t i = 0; i < children.size(); i++) {
30: 		children[i]->expr = BoundCastExpression::AddCastToType(move(children[i]->expr), max_type);
31: 	}
32: 	// (NOT) IN always returns a boolean
33: 	return LogicalType::BOOLEAN;
34: }
35: 
36: static LogicalType ResolveOperatorType(OperatorExpression &op, vector<BoundExpression *> &children) {
37: 	switch (op.type) {
38: 	case ExpressionType::OPERATOR_IS_NULL:
39: 	case ExpressionType::OPERATOR_IS_NOT_NULL:
40: 		// IS (NOT) NULL always returns a boolean, and does not cast its children
41: 		ExpressionBinder::ResolveParameterType(children[0]->expr);
42: 		return LogicalType::BOOLEAN;
43: 	case ExpressionType::COMPARE_IN:
44: 	case ExpressionType::COMPARE_NOT_IN:
45: 		return ResolveInType(op, children);
46: 	case ExpressionType::OPERATOR_COALESCE: {
47: 		ResolveInType(op, children);
48: 		return children[0]->expr->return_type;
49: 	}
50: 	case ExpressionType::OPERATOR_NOT:
51: 		return ResolveNotType(op, children);
52: 	default:
53: 		throw InternalException("Unrecognized expression type for ResolveOperatorType");
54: 	}
55: }
56: 
57: BindResult ExpressionBinder::BindGroupingFunction(OperatorExpression &op, idx_t depth) {
58: 	return BindResult("GROUPING function is not supported here");
59: }
60: 
61: BindResult ExpressionBinder::BindExpression(OperatorExpression &op, idx_t depth) {
62: 	if (op.type == ExpressionType::GROUPING_FUNCTION) {
63: 		return BindGroupingFunction(op, depth);
64: 	}
65: 	// bind the children of the operator expression
66: 	string error;
67: 	for (idx_t i = 0; i < op.children.size(); i++) {
68: 		BindChild(op.children[i], depth, error);
69: 	}
70: 	if (!error.empty()) {
71: 		return BindResult(error);
72: 	}
73: 	// all children bound successfully
74: 	string function_name;
75: 	switch (op.type) {
76: 	case ExpressionType::ARRAY_EXTRACT: {
77: 		D_ASSERT(op.children[0]->expression_class == ExpressionClass::BOUND_EXPRESSION);
78: 		auto &b_exp = (BoundExpression &)*op.children[0];
79: 		if (b_exp.expr->return_type.id() == LogicalTypeId::MAP) {
80: 			function_name = "map_extract";
81: 		} else {
82: 			function_name = "array_extract";
83: 		}
84: 		break;
85: 	}
86: 	case ExpressionType::ARRAY_SLICE:
87: 		function_name = "array_slice";
88: 		break;
89: 	case ExpressionType::STRUCT_EXTRACT:
90: 		function_name = "struct_extract";
91: 		break;
92: 	case ExpressionType::ARRAY_CONSTRUCTOR:
93: 		function_name = "list_value";
94: 		break;
95: 	case ExpressionType::ARROW:
96: 		function_name = "json_extract";
97: 		break;
98: 	default:
99: 		break;
100: 	}
101: 	if (!function_name.empty()) {
102: 		auto function = make_unique<FunctionExpression>(function_name, move(op.children));
103: 		return BindExpression(*function, depth, nullptr);
104: 	}
105: 
106: 	vector<BoundExpression *> children;
107: 	for (idx_t i = 0; i < op.children.size(); i++) {
108: 		D_ASSERT(op.children[i]->expression_class == ExpressionClass::BOUND_EXPRESSION);
109: 		children.push_back((BoundExpression *)op.children[i].get());
110: 	}
111: 	// now resolve the types
112: 	LogicalType result_type = ResolveOperatorType(op, children);
113: 	if (op.type == ExpressionType::OPERATOR_COALESCE) {
114: 		if (children.empty()) {
115: 			throw BinderException("COALESCE needs at least one child");
116: 		}
117: 		if (children.size() == 1) {
118: 			return BindResult(move(children[0]->expr));
119: 		}
120: 	}
121: 
122: 	auto result = make_unique<BoundOperatorExpression>(op.type, result_type);
123: 	for (auto &child : children) {
124: 		result->children.push_back(move(child->expr));
125: 	}
126: 	return BindResult(move(result));
127: }
128: 
129: } // namespace duckdb
[end of src/planner/binder/expression/bind_operator_expression.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: