{
  "repo": "duckdb/duckdb",
  "pull_number": 11399,
  "instance_id": "duckdb__duckdb-11399",
  "issue_numbers": [
    "11391"
  ],
  "base_commit": "60e89a404e46e2e8a463554d1a1e9c68a048c95b",
  "patch": "diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 5e54701f97a4..d778bedfdc70 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -136,8 +136,8 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \n \t//! Add a common table expression to the binder\n \tvoid AddCTE(const string &name, CommonTableExpressionInfo &cte);\n-\t//! Find a common table expression by name; returns nullptr if none exists\n-\toptional_ptr<CommonTableExpressionInfo> FindCTE(const string &name, bool skip = false);\n+\t//! Find all candidate common table expression by name; returns empty vector if none exists\n+\tvector<reference<CommonTableExpressionInfo>> FindCTE(const string &name, bool skip = false);\n \n \tbool CTEIsAlreadyBound(CommonTableExpressionInfo &cte);\n \ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex f9c737ef1c17..8239fd292664 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -333,17 +333,19 @@ void Binder::AddCTE(const string &name, CommonTableExpressionInfo &info) {\n \tCTE_bindings.insert(make_pair(name, reference<CommonTableExpressionInfo>(info)));\n }\n \n-optional_ptr<CommonTableExpressionInfo> Binder::FindCTE(const string &name, bool skip) {\n+vector<reference<CommonTableExpressionInfo>> Binder::FindCTE(const string &name, bool skip) {\n \tauto entry = CTE_bindings.find(name);\n+\tvector<reference<CommonTableExpressionInfo>> ctes;\n \tif (entry != CTE_bindings.end()) {\n \t\tif (!skip || entry->second.get().query->node->type == QueryNodeType::RECURSIVE_CTE_NODE) {\n-\t\t\treturn &entry->second.get();\n+\t\t\tctes.push_back(entry->second);\n \t\t}\n \t}\n \tif (parent && inherit_ctes) {\n-\t\treturn parent->FindCTE(name, name == alias);\n+\t\tauto parent_ctes = parent->FindCTE(name, name == alias);\n+\t\tctes.insert(ctes.end(), parent_ctes.begin(), parent_ctes.end());\n \t}\n-\treturn nullptr;\n+\treturn ctes;\n }\n \n bool Binder::CTEIsAlreadyBound(CommonTableExpressionInfo &cte) {\ndiff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex 7b4077ce8f18..30b2b2640eb4 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -80,61 +80,70 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \t// check if the table name refers to a CTE\n \n \t// CTE name should never be qualified (i.e. schema_name should be empty)\n-\toptional_ptr<CommonTableExpressionInfo> found_cte = nullptr;\n+\tvector<reference<CommonTableExpressionInfo>> found_ctes;\n \tif (ref.schema_name.empty()) {\n-\t\tfound_cte = FindCTE(ref.table_name, ref.table_name == alias);\n+\t\tfound_ctes = FindCTE(ref.table_name, ref.table_name == alias);\n \t}\n \n-\tif (found_cte) {\n+\tif (!found_ctes.empty()) {\n \t\t// Check if there is a CTE binding in the BindContext\n-\t\tauto &cte = *found_cte;\n-\t\tauto ctebinding = bind_context.GetCTEBinding(ref.table_name);\n-\t\tif (!ctebinding) {\n-\t\t\tif (CTEIsAlreadyBound(cte)) {\n-\t\t\t\tthrow BinderException(\n-\t\t\t\t    \"Circular reference to CTE \\\"%s\\\", There are two possible solutions. \\n1. use WITH RECURSIVE to \"\n-\t\t\t\t    \"use recursive CTEs. \\n2. If \"\n-\t\t\t\t    \"you want to use the TABLE name \\\"%s\\\" the same as the CTE name, please explicitly add \"\n-\t\t\t\t    \"\\\"SCHEMA\\\" before table name. You can try \\\"main.%s\\\" (main is the duckdb default schema)\",\n-\t\t\t\t    ref.table_name, ref.table_name, ref.table_name);\n-\t\t\t}\n-\t\t\t// Move CTE to subquery and bind recursively\n-\t\t\tSubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(cte.query->Copy()));\n-\t\t\tsubquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;\n-\t\t\tsubquery.column_name_alias = cte.aliases;\n-\t\t\tfor (idx_t i = 0; i < ref.column_name_alias.size(); i++) {\n-\t\t\t\tif (i < subquery.column_name_alias.size()) {\n-\t\t\t\t\tsubquery.column_name_alias[i] = ref.column_name_alias[i];\n-\t\t\t\t} else {\n-\t\t\t\t\tsubquery.column_name_alias.push_back(ref.column_name_alias[i]);\n+\t\tbool circular_cte = false;\n+\t\tfor (auto found_cte : found_ctes) {\n+\t\t\tauto &cte = found_cte.get();\n+\t\t\tauto ctebinding = bind_context.GetCTEBinding(ref.table_name);\n+\t\t\tif (!ctebinding) {\n+\t\t\t\tif (CTEIsAlreadyBound(cte)) {\n+\t\t\t\t\t// remember error state\n+\t\t\t\t\tcircular_cte = true;\n+\t\t\t\t\t// retry with next candidate CTE\n+\t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t}\n-\t\t\treturn Bind(subquery, found_cte);\n-\t\t} else {\n-\t\t\t// There is a CTE binding in the BindContext.\n-\t\t\t// This can only be the case if there is a recursive CTE,\n-\t\t\t// or a materialized CTE present.\n-\t\t\tauto index = GenerateTableIndex();\n-\t\t\tauto materialized = cte.materialized;\n-\t\t\tif (materialized == CTEMaterialize::CTE_MATERIALIZE_DEFAULT) {\n+\t\t\t\t// Move CTE to subquery and bind recursively\n+\t\t\t\tSubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(cte.query->Copy()));\n+\t\t\t\tsubquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;\n+\t\t\t\tsubquery.column_name_alias = cte.aliases;\n+\t\t\t\tfor (idx_t i = 0; i < ref.column_name_alias.size(); i++) {\n+\t\t\t\t\tif (i < subquery.column_name_alias.size()) {\n+\t\t\t\t\t\tsubquery.column_name_alias[i] = ref.column_name_alias[i];\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsubquery.column_name_alias.push_back(ref.column_name_alias[i]);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn Bind(subquery, &found_cte.get());\n+\t\t\t} else {\n+\t\t\t\t// There is a CTE binding in the BindContext.\n+\t\t\t\t// This can only be the case if there is a recursive CTE,\n+\t\t\t\t// or a materialized CTE present.\n+\t\t\t\tauto index = GenerateTableIndex();\n+\t\t\t\tauto materialized = cte.materialized;\n+\t\t\t\tif (materialized == CTEMaterialize::CTE_MATERIALIZE_DEFAULT) {\n #ifdef DUCKDB_ALTERNATIVE_VERIFY\n-\t\t\t\tmaterialized = CTEMaterialize::CTE_MATERIALIZE_ALWAYS;\n+\t\t\t\t\tmaterialized = CTEMaterialize::CTE_MATERIALIZE_ALWAYS;\n #else\n-\t\t\t\tmaterialized = CTEMaterialize::CTE_MATERIALIZE_NEVER;\n+\t\t\t\t\tmaterialized = CTEMaterialize::CTE_MATERIALIZE_NEVER;\n #endif\n-\t\t\t}\n-\t\t\tauto result = make_uniq<BoundCTERef>(index, ctebinding->index, materialized);\n-\t\t\tauto alias = ref.alias.empty() ? ref.table_name : ref.alias;\n-\t\t\tauto names = BindContext::AliasColumnNames(alias, ctebinding->names, ref.column_name_alias);\n+\t\t\t\t}\n+\t\t\t\tauto result = make_uniq<BoundCTERef>(index, ctebinding->index, materialized);\n+\t\t\t\tauto alias = ref.alias.empty() ? ref.table_name : ref.alias;\n+\t\t\t\tauto names = BindContext::AliasColumnNames(alias, ctebinding->names, ref.column_name_alias);\n \n-\t\t\tbind_context.AddGenericBinding(index, alias, names, ctebinding->types);\n-\t\t\t// Update references to CTE\n-\t\t\tauto cteref = bind_context.cte_references[ref.table_name];\n-\t\t\t(*cteref)++;\n+\t\t\t\tbind_context.AddGenericBinding(index, alias, names, ctebinding->types);\n+\t\t\t\t// Update references to CTE\n+\t\t\t\tauto cteref = bind_context.cte_references[ref.table_name];\n+\t\t\t\t(*cteref)++;\n \n-\t\t\tresult->types = ctebinding->types;\n-\t\t\tresult->bound_columns = std::move(names);\n-\t\t\treturn std::move(result);\n+\t\t\t\tresult->types = ctebinding->types;\n+\t\t\t\tresult->bound_columns = std::move(names);\n+\t\t\t\treturn std::move(result);\n+\t\t\t}\n+\t\t}\n+\t\tif (circular_cte) {\n+\t\t\tthrow BinderException(\n+\t\t\t    \"Circular reference to CTE \\\"%s\\\", There are two possible solutions. \\n1. use WITH RECURSIVE to \"\n+\t\t\t    \"use recursive CTEs. \\n2. If \"\n+\t\t\t    \"you want to use the TABLE name \\\"%s\\\" the same as the CTE name, please explicitly add \"\n+\t\t\t    \"\\\"SCHEMA\\\" before table name. You can try \\\"main.%s\\\" (main is the duckdb default schema)\",\n+\t\t\t    ref.table_name, ref.table_name, ref.table_name);\n \t\t}\n \t}\n \t// not a CTE\ndiff --git a/src/planner/binder/tableref/bind_subqueryref.cpp b/src/planner/binder/tableref/bind_subqueryref.cpp\nindex f674970ffac1..5acbd06b5d03 100644\n--- a/src/planner/binder/tableref/bind_subqueryref.cpp\n+++ b/src/planner/binder/tableref/bind_subqueryref.cpp\n@@ -10,8 +10,8 @@ unique_ptr<BoundTableRef> Binder::Bind(SubqueryRef &ref, optional_ptr<CommonTabl\n \tif (cte) {\n \t\tbinder->bound_ctes.insert(*cte);\n \t}\n-\tbinder->alias = ref.alias.empty() ? \"unnamed_subquery\" : ref.alias;\n \tauto subquery = binder->BindNode(*ref.subquery->node);\n+\tbinder->alias = ref.alias.empty() ? \"unnamed_subquery\" : ref.alias;\n \tidx_t bind_index = subquery->GetRootIndex();\n \tstring subquery_alias;\n \tif (ref.alias.empty()) {\n",
  "test_patch": "diff --git a/test/issues/general/test_11391.test b/test/issues/general/test_11391.test\nnew file mode 100644\nindex 000000000000..637c901a6dee\n--- /dev/null\n+++ b/test/issues/general/test_11391.test\n@@ -0,0 +1,8 @@\n+# name: test/issues/general/test_11391.test\n+# description: Issue 1091: Catalog Error with nested CTEs\n+# group: [general]\n+\n+query I\n+with foo as (with foo as (select 1) select * from foo) select * from foo;\n+----\n+1\n",
  "problem_statement": "Catalog Error with nested CTEs\n### What happens?\n\nWhen running a nested CTE with duplicate names, DuckDB inappropriately throws `Catalog Error: Table with name foo does not exist!`\n\n### To Reproduce\n\nRun the following query in the DuckDB shell\r\n```sql\r\nwith foo as (with foo as (select 1) select * from foo) select * from foo;\r\n```\r\nI expect this to return a single row `1`. I have verified that Postgres and SQLite return the expected result.\n\n### OS:\n\nOSX, Apple Silicon\n\n### DuckDB Version:\n\nv0.10.1\n\n### DuckDB Client:\n\nshell\n\n### Full Name:\n\nCarl Jackson\n\n### Affiliation:\n\nWatershed\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a release build (and could not test with a nightly build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-03-28T10:10:55Z"
}