{
  "repo": "duckdb/duckdb",
  "pull_number": 2919,
  "instance_id": "duckdb__duckdb-2919",
  "issue_numbers": [
    "2075"
  ],
  "base_commit": "18ea12e8a5d6b528bb736347299cc4e4960b271f",
  "patch": "diff --git a/examples/standalone-plan/main.cpp b/examples/standalone-plan/main.cpp\nindex 4abe05831368..0f4adcff2f52 100644\n--- a/examples/standalone-plan/main.cpp\n+++ b/examples/standalone-plan/main.cpp\n@@ -201,7 +201,7 @@ struct MyBindData : public FunctionData {\n // k: 1, 10, 20\n // (see MyScanNode)\n static unique_ptr<FunctionData> MyScanBind(ClientContext &context, vector<Value> &inputs,\n-                                           unordered_map<string, Value> &named_parameters,\n+                                           named_parameter_map_t &named_parameters,\n                                            vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n                                            vector<LogicalType> &return_types, vector<string> &names) {\n \tauto table_name = inputs[0].ToString();\ndiff --git a/extension/icu/icu-extension.cpp b/extension/icu/icu-extension.cpp\nindex 4500ddd3263d..45097f37f6b4 100644\n--- a/extension/icu/icu-extension.cpp\n+++ b/extension/icu/icu-extension.cpp\n@@ -150,7 +150,7 @@ struct ICUTimeZoneData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> ICUTimeZoneBind(ClientContext &context, vector<Value> &inputs,\n-                                                unordered_map<string, Value> &named_parameters,\n+                                                named_parameter_map_t &named_parameters,\n                                                 vector<LogicalType> &input_table_types,\n                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                 vector<string> &names) {\n@@ -236,7 +236,7 @@ struct ICUCalendarData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> ICUCalendarBind(ClientContext &context, vector<Value> &inputs,\n-                                                unordered_map<string, Value> &named_parameters,\n+                                                named_parameter_map_t &named_parameters,\n                                                 vector<LogicalType> &input_table_types,\n                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                 vector<string> &names) {\ndiff --git a/extension/parquet/parquet-extension.cpp b/extension/parquet/parquet-extension.cpp\nindex 982fd25fb498..587dee366813 100644\n--- a/extension/parquet/parquet-extension.cpp\n+++ b/extension/parquet/parquet-extension.cpp\n@@ -196,7 +196,7 @@ class ParquetScanFunction {\n \t}\n \n \tstatic unique_ptr<FunctionData> ParquetScanBind(ClientContext &context, vector<Value> &inputs,\n-\t                                                unordered_map<string, Value> &named_parameters,\n+\t                                                named_parameter_map_t &named_parameters,\n \t                                                vector<LogicalType> &input_table_types,\n \t                                                vector<string> &input_table_names,\n \t                                                vector<LogicalType> &return_types, vector<string> &names) {\n@@ -217,7 +217,7 @@ class ParquetScanFunction {\n \t}\n \n \tstatic unique_ptr<FunctionData> ParquetScanBindList(ClientContext &context, vector<Value> &inputs,\n-\t                                                    unordered_map<string, Value> &named_parameters,\n+\t                                                    named_parameter_map_t &named_parameters,\n \t                                                    vector<LogicalType> &input_table_types,\n \t                                                    vector<string> &input_table_names,\n \t                                                    vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/extension/parquet/parquet_metadata.cpp b/extension/parquet/parquet_metadata.cpp\nindex cad9551b6f27..01075e12ee34 100644\n--- a/extension/parquet/parquet_metadata.cpp\n+++ b/extension/parquet/parquet_metadata.cpp\n@@ -385,7 +385,7 @@ void ParquetMetaDataOperatorData::LoadSchemaData(ClientContext &context, const v\n \n template <bool SCHEMA>\n unique_ptr<FunctionData> ParquetMetaDataBind(ClientContext &context, vector<Value> &inputs,\n-                                             unordered_map<string, Value> &named_parameters,\n+                                             named_parameter_map_t &named_parameters,\n                                              vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n                                              vector<LogicalType> &return_types, vector<string> &names) {\n \tauto &config = DBConfig::GetConfig(context);\ndiff --git a/extension/tpcds/tpcds-extension.cpp b/extension/tpcds/tpcds-extension.cpp\nindex 5cafd2accbb1..9bd06de285cc 100644\n--- a/extension/tpcds/tpcds-extension.cpp\n+++ b/extension/tpcds/tpcds-extension.cpp\n@@ -28,7 +28,7 @@ struct DSDGenFunctionData : public TableFunctionData {\n };\n \n static unique_ptr<FunctionData> DsdgenBind(ClientContext &context, vector<Value> &inputs,\n-                                           unordered_map<string, Value> &named_parameters,\n+                                           named_parameter_map_t &named_parameters,\n                                            vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n                                            vector<LogicalType> &return_types, vector<string> &names) {\n \tauto result = make_unique<DSDGenFunctionData>();\n@@ -75,7 +75,7 @@ unique_ptr<FunctionOperatorData> TPCDSInit(ClientContext &context, const Functio\n }\n \n static unique_ptr<FunctionData> TPCDSQueryBind(ClientContext &context, vector<Value> &inputs,\n-                                               unordered_map<string, Value> &named_parameters,\n+                                               named_parameter_map_t &named_parameters,\n                                                vector<LogicalType> &input_table_types,\n                                                vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                vector<string> &names) {\n@@ -110,7 +110,7 @@ static void TPCDSQueryFunction(ClientContext &context, const FunctionData *bind_\n }\n \n static unique_ptr<FunctionData> TPCDSQueryAnswerBind(ClientContext &context, vector<Value> &inputs,\n-                                                     unordered_map<string, Value> &named_parameters,\n+                                                     named_parameter_map_t &named_parameters,\n                                                      vector<LogicalType> &input_table_types,\n                                                      vector<string> &input_table_names,\n                                                      vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/extension/tpch/tpch-extension.cpp b/extension/tpch/tpch-extension.cpp\nindex 97bbeef63278..732f2e870a4a 100644\n--- a/extension/tpch/tpch-extension.cpp\n+++ b/extension/tpch/tpch-extension.cpp\n@@ -27,7 +27,7 @@ struct DBGenFunctionData : public TableFunctionData {\n };\n \n static unique_ptr<FunctionData> DbgenBind(ClientContext &context, vector<Value> &inputs,\n-                                          unordered_map<string, Value> &named_parameters,\n+                                          named_parameter_map_t &named_parameters,\n                                           vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n                                           vector<LogicalType> &return_types, vector<string> &names) {\n \tauto result = make_unique<DBGenFunctionData>();\n@@ -72,7 +72,7 @@ unique_ptr<FunctionOperatorData> TPCHInit(ClientContext &context, const Function\n }\n \n static unique_ptr<FunctionData> TPCHQueryBind(ClientContext &context, vector<Value> &inputs,\n-                                              unordered_map<string, Value> &named_parameters,\n+                                              named_parameter_map_t &named_parameters,\n                                               vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n                                               vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"query_nr\");\n@@ -106,7 +106,7 @@ static void TPCHQueryFunction(ClientContext &context, const FunctionData *bind_d\n }\n \n static unique_ptr<FunctionData> TPCHQueryAnswerBind(ClientContext &context, vector<Value> &inputs,\n-                                                    unordered_map<string, Value> &named_parameters,\n+                                                    named_parameter_map_t &named_parameters,\n                                                     vector<LogicalType> &input_table_types,\n                                                     vector<string> &input_table_names,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/execution/operator/persistent/buffered_csv_reader.cpp b/src/execution/operator/persistent/buffered_csv_reader.cpp\nindex 200dc2807326..4b1586d8c024 100644\n--- a/src/execution/operator/persistent/buffered_csv_reader.cpp\n+++ b/src/execution/operator/persistent/buffered_csv_reader.cpp\n@@ -921,7 +921,7 @@ void BufferedCSVReader::DetectHeader(const vector<vector<LogicalType>> &best_sql\n \t// update parser info, and read, generate & set col_names based on previous findings\n \tif (((!first_row_consistent || first_row_nulls) && !options.has_header) || (options.has_header && options.header)) {\n \t\toptions.header = true;\n-\t\tunordered_map<string, idx_t> name_collision_count;\n+\t\tcase_insensitive_map_t<idx_t> name_collision_count;\n \t\t// get header names from CSV\n \t\tfor (idx_t col = 0; col < options.num_cols; col++) {\n \t\t\tconst auto &val = best_header_row.GetValue(col, 0);\ndiff --git a/src/function/function.cpp b/src/function/function.cpp\nindex c2b25e854746..40574a9f2237 100644\n--- a/src/function/function.cpp\n+++ b/src/function/function.cpp\n@@ -208,7 +208,7 @@ string Function::CallToString(const string &name, const vector<LogicalType> &arg\n }\n \n string Function::CallToString(const string &name, const vector<LogicalType> &arguments,\n-                              const unordered_map<string, LogicalType> &named_parameters) {\n+                              const named_parameter_type_map_t &named_parameters) {\n \tvector<string> input_arguments;\n \tinput_arguments.reserve(arguments.size() + named_parameters.size());\n \tfor (auto &arg : arguments) {\ndiff --git a/src/function/table/arrow.cpp b/src/function/table/arrow.cpp\nindex 2f6eca7f0f2c..2586a381fbfc 100644\n--- a/src/function/table/arrow.cpp\n+++ b/src/function/table/arrow.cpp\n@@ -161,7 +161,7 @@ LogicalType GetArrowLogicalType(ArrowSchema &schema,\n }\n \n unique_ptr<FunctionData> ArrowTableFunction::ArrowScanBind(ClientContext &context, vector<Value> &inputs,\n-                                                           unordered_map<string, Value> &named_parameters,\n+                                                           named_parameter_map_t &named_parameters,\n                                                            vector<LogicalType> &input_table_types,\n                                                            vector<string> &input_table_names,\n                                                            vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/function/table/checkpoint.cpp b/src/function/table/checkpoint.cpp\nindex 8f9712794979..a3a18964cf01 100644\n--- a/src/function/table/checkpoint.cpp\n+++ b/src/function/table/checkpoint.cpp\n@@ -6,7 +6,7 @@\n namespace duckdb {\n \n static unique_ptr<FunctionData> CheckpointBind(ClientContext &context, vector<Value> &inputs,\n-                                               unordered_map<string, Value> &named_parameters,\n+                                               named_parameter_map_t &named_parameters,\n                                                vector<LogicalType> &input_table_types,\n                                                vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                vector<string> &names) {\ndiff --git a/src/function/table/glob.cpp b/src/function/table/glob.cpp\nindex 687e0795f0d1..3cb796cb317c 100644\n--- a/src/function/table/glob.cpp\n+++ b/src/function/table/glob.cpp\n@@ -11,7 +11,7 @@ struct GlobFunctionBindData : public TableFunctionData {\n };\n \n static unique_ptr<FunctionData> GlobFunctionBind(ClientContext &context, vector<Value> &inputs,\n-                                                 unordered_map<string, Value> &named_parameters,\n+                                                 named_parameter_map_t &named_parameters,\n                                                  vector<LogicalType> &input_table_types,\n                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                  vector<string> &names) {\ndiff --git a/src/function/table/pragma_detailed_profiling_output.cpp b/src/function/table/pragma_detailed_profiling_output.cpp\nindex 74af651055fc..87620c9e9dfd 100644\n--- a/src/function/table/pragma_detailed_profiling_output.cpp\n+++ b/src/function/table/pragma_detailed_profiling_output.cpp\n@@ -22,7 +22,7 @@ struct PragmaDetailedProfilingOutputData : public TableFunctionData {\n };\n \n static unique_ptr<FunctionData> PragmaDetailedProfilingOutputBind(ClientContext &context, vector<Value> &inputs,\n-                                                                  unordered_map<string, Value> &named_parameters,\n+                                                                  named_parameter_map_t &named_parameters,\n                                                                   vector<LogicalType> &input_table_types,\n                                                                   vector<string> &input_table_names,\n                                                                   vector<LogicalType> &return_types,\ndiff --git a/src/function/table/pragma_last_profiling_output.cpp b/src/function/table/pragma_last_profiling_output.cpp\nindex eb15716da807..67d863371d3a 100644\n--- a/src/function/table/pragma_last_profiling_output.cpp\n+++ b/src/function/table/pragma_last_profiling_output.cpp\n@@ -22,12 +22,10 @@ struct PragmaLastProfilingOutputData : public TableFunctionData {\n \tvector<LogicalType> types;\n };\n \n-static unique_ptr<FunctionData> PragmaLastProfilingOutputBind(ClientContext &context, vector<Value> &inputs,\n-                                                              unordered_map<string, Value> &named_parameters,\n-                                                              vector<LogicalType> &input_table_types,\n-                                                              vector<string> &input_table_names,\n-                                                              vector<LogicalType> &return_types,\n-                                                              vector<string> &names) {\n+static unique_ptr<FunctionData>\n+PragmaLastProfilingOutputBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,\n+                              vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n+                              vector<LogicalType> &return_types, vector<string> &names) {\n \tnames.emplace_back(\"OPERATOR_ID\");\n \treturn_types.emplace_back(LogicalType::INTEGER);\n \ndiff --git a/src/function/table/range.cpp b/src/function/table/range.cpp\nindex 17d94167dd6c..ad6f66ecf5ba 100644\n--- a/src/function/table/range.cpp\n+++ b/src/function/table/range.cpp\n@@ -18,7 +18,7 @@ struct RangeFunctionBindData : public TableFunctionData {\n \n template <bool GENERATE_SERIES>\n static unique_ptr<FunctionData>\n-RangeFunctionBind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n+RangeFunctionBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,\n                   vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n                   vector<LogicalType> &return_types, vector<string> &names) {\n \tauto result = make_unique<RangeFunctionBindData>();\n@@ -129,7 +129,7 @@ struct RangeDateTimeBindData : public TableFunctionData {\n \n template <bool GENERATE_SERIES>\n static unique_ptr<FunctionData>\n-RangeDateTimeBind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n+RangeDateTimeBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,\n                   vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n                   vector<LogicalType> &return_types, vector<string> &names) {\n \tauto result = make_unique<RangeDateTimeBindData>();\ndiff --git a/src/function/table/read_csv.cpp b/src/function/table/read_csv.cpp\nindex 1c2cc238e5b6..e70dd6341d92 100644\n--- a/src/function/table/read_csv.cpp\n+++ b/src/function/table/read_csv.cpp\n@@ -15,7 +15,7 @@\n namespace duckdb {\n \n static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value> &inputs,\n-                                            unordered_map<string, Value> &named_parameters,\n+                                            named_parameter_map_t &named_parameters,\n                                             vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n                                             vector<LogicalType> &return_types, vector<string> &names) {\n \tauto &config = DBConfig::GetConfig(context);\n@@ -34,22 +34,23 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value\n \t}\n \n \tfor (auto &kv : named_parameters) {\n-\t\tif (kv.first == \"auto_detect\") {\n+\t\tauto loption = StringUtil::Lower(kv.first);\n+\t\tif (loption == \"auto_detect\") {\n \t\t\toptions.auto_detect = BooleanValue::Get(kv.second);\n-\t\t} else if (kv.first == \"sep\" || kv.first == \"delim\") {\n+\t\t} else if (loption == \"sep\" || loption == \"delim\") {\n \t\t\toptions.SetDelimiter(StringValue::Get(kv.second));\n-\t\t} else if (kv.first == \"header\") {\n+\t\t} else if (loption == \"header\") {\n \t\t\toptions.header = BooleanValue::Get(kv.second);\n \t\t\toptions.has_header = true;\n-\t\t} else if (kv.first == \"quote\") {\n+\t\t} else if (loption == \"quote\") {\n \t\t\toptions.quote = StringValue::Get(kv.second);\n \t\t\toptions.has_quote = true;\n-\t\t} else if (kv.first == \"escape\") {\n+\t\t} else if (loption == \"escape\") {\n \t\t\toptions.escape = StringValue::Get(kv.second);\n \t\t\toptions.has_escape = true;\n-\t\t} else if (kv.first == \"nullstr\") {\n+\t\t} else if (loption == \"nullstr\") {\n \t\t\toptions.null_str = StringValue::Get(kv.second);\n-\t\t} else if (kv.first == \"sample_size\") {\n+\t\t} else if (loption == \"sample_size\") {\n \t\t\tint64_t sample_size = kv.second.GetValue<int64_t>();\n \t\t\tif (sample_size < 1 && sample_size != -1) {\n \t\t\t\tthrow BinderException(\"Unsupported parameter for SAMPLE_SIZE: cannot be smaller than 1\");\n@@ -64,7 +65,7 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value\n \t\t\t\toptions.sample_chunk_size = STANDARD_VECTOR_SIZE;\n \t\t\t\toptions.sample_chunks = sample_size / STANDARD_VECTOR_SIZE;\n \t\t\t}\n-\t\t} else if (kv.first == \"sample_chunk_size\") {\n+\t\t} else if (loption == \"sample_chunk_size\") {\n \t\t\toptions.sample_chunk_size = kv.second.GetValue<int64_t>();\n \t\t\tif (options.sample_chunk_size > STANDARD_VECTOR_SIZE) {\n \t\t\t\tthrow BinderException(\n@@ -73,14 +74,14 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value\n \t\t\t} else if (options.sample_chunk_size < 1) {\n \t\t\t\tthrow BinderException(\"Unsupported parameter for SAMPLE_CHUNK_SIZE: cannot be smaller than 1\");\n \t\t\t}\n-\t\t} else if (kv.first == \"sample_chunks\") {\n+\t\t} else if (loption == \"sample_chunks\") {\n \t\t\toptions.sample_chunks = kv.second.GetValue<int64_t>();\n \t\t\tif (options.sample_chunks < 1) {\n \t\t\t\tthrow BinderException(\"Unsupported parameter for SAMPLE_CHUNKS: cannot be smaller than 1\");\n \t\t\t}\n-\t\t} else if (kv.first == \"all_varchar\") {\n+\t\t} else if (loption == \"all_varchar\") {\n \t\t\toptions.all_varchar = BooleanValue::Get(kv.second);\n-\t\t} else if (kv.first == \"dateformat\") {\n+\t\t} else if (loption == \"dateformat\") {\n \t\t\toptions.has_format[LogicalTypeId::DATE] = true;\n \t\t\tauto &date_format = options.date_format[LogicalTypeId::DATE];\n \t\t\tdate_format.format_specifier = StringValue::Get(kv.second);\n@@ -88,7 +89,7 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value\n \t\t\tif (!error.empty()) {\n \t\t\t\tthrow InvalidInputException(\"Could not parse DATEFORMAT: %s\", error.c_str());\n \t\t\t}\n-\t\t} else if (kv.first == \"timestampformat\") {\n+\t\t} else if (loption == \"timestampformat\") {\n \t\t\toptions.has_format[LogicalTypeId::TIMESTAMP] = true;\n \t\t\tauto &timestamp_format = options.date_format[LogicalTypeId::TIMESTAMP];\n \t\t\ttimestamp_format.format_specifier = StringValue::Get(kv.second);\n@@ -96,9 +97,9 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value\n \t\t\tif (!error.empty()) {\n \t\t\t\tthrow InvalidInputException(\"Could not parse TIMESTAMPFORMAT: %s\", error.c_str());\n \t\t\t}\n-\t\t} else if (kv.first == \"normalize_names\") {\n+\t\t} else if (loption == \"normalize_names\") {\n \t\t\toptions.normalize_names = BooleanValue::Get(kv.second);\n-\t\t} else if (kv.first == \"columns\") {\n+\t\t} else if (loption == \"columns\") {\n \t\t\tauto &child_type = kv.second.type();\n \t\t\tif (child_type.id() != LogicalTypeId::STRUCT) {\n \t\t\t\tthrow BinderException(\"read_csv columns requires a a struct as input\");\n@@ -117,12 +118,14 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value\n \t\t\tif (names.empty()) {\n \t\t\t\tthrow BinderException(\"read_csv requires at least a single column as input!\");\n \t\t\t}\n-\t\t} else if (kv.first == \"compression\") {\n+\t\t} else if (loption == \"compression\") {\n \t\t\toptions.compression = FileCompressionTypeFromString(StringValue::Get(kv.second));\n-\t\t} else if (kv.first == \"filename\") {\n+\t\t} else if (loption == \"filename\") {\n \t\t\tresult->include_file_name = BooleanValue::Get(kv.second);\n-\t\t} else if (kv.first == \"skip\") {\n+\t\t} else if (loption == \"skip\") {\n \t\t\toptions.skip_rows = kv.second.GetValue<int64_t>();\n+\t\t} else {\n+\t\t\tthrow InternalException(\"Unrecognized parameter %s\", kv.first);\n \t\t}\n \t}\n \tif (!options.auto_detect && return_types.empty()) {\n@@ -176,7 +179,7 @@ static unique_ptr<FunctionOperatorData> ReadCSVInit(ClientContext &context, cons\n }\n \n static unique_ptr<FunctionData> ReadCSVAutoBind(ClientContext &context, vector<Value> &inputs,\n-                                                unordered_map<string, Value> &named_parameters,\n+                                                named_parameter_map_t &named_parameters,\n                                                 vector<LogicalType> &input_table_types,\n                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                 vector<string> &names) {\ndiff --git a/src/function/table/repeat.cpp b/src/function/table/repeat.cpp\nindex 4b3e0fe6bcf6..933e0deefb18 100644\n--- a/src/function/table/repeat.cpp\n+++ b/src/function/table/repeat.cpp\n@@ -18,7 +18,7 @@ struct RepeatOperatorData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> RepeatBind(ClientContext &context, vector<Value> &inputs,\n-                                           unordered_map<string, Value> &named_parameters,\n+                                           named_parameter_map_t &named_parameters,\n                                            vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n                                            vector<LogicalType> &return_types, vector<string> &names) {\n \t// the repeat function returns the type of the first argument\ndiff --git a/src/function/table/summary.cpp b/src/function/table/summary.cpp\nindex 436cb9ce2cf7..eb8bf1189753 100644\n--- a/src/function/table/summary.cpp\n+++ b/src/function/table/summary.cpp\n@@ -8,7 +8,7 @@\n namespace duckdb {\n \n static unique_ptr<FunctionData> SummaryFunctionBind(ClientContext &context, vector<Value> &inputs,\n-                                                    unordered_map<string, Value> &named_parameters,\n+                                                    named_parameter_map_t &named_parameters,\n                                                     vector<LogicalType> &input_table_types,\n                                                     vector<string> &input_table_names,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_columns.cpp b/src/function/table/system/duckdb_columns.cpp\nindex 78a43da87d31..295cf271c478 100644\n--- a/src/function/table/system/duckdb_columns.cpp\n+++ b/src/function/table/system/duckdb_columns.cpp\n@@ -21,7 +21,7 @@ struct DuckDBColumnsData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBColumnsBind(ClientContext &context, vector<Value> &inputs,\n-                                                  unordered_map<string, Value> &named_parameters,\n+                                                  named_parameter_map_t &named_parameters,\n                                                   vector<LogicalType> &input_table_types,\n                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                   vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_constraints.cpp b/src/function/table/system/duckdb_constraints.cpp\nindex 1b28bc88e10c..44570465b24c 100644\n--- a/src/function/table/system/duckdb_constraints.cpp\n+++ b/src/function/table/system/duckdb_constraints.cpp\n@@ -25,7 +25,7 @@ struct DuckDBConstraintsData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, vector<Value> &inputs,\n-                                                      unordered_map<string, Value> &named_parameters,\n+                                                      named_parameter_map_t &named_parameters,\n                                                       vector<LogicalType> &input_table_types,\n                                                       vector<string> &input_table_names,\n                                                       vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_dependencies.cpp b/src/function/table/system/duckdb_dependencies.cpp\nindex ed6f5b680d3b..281f52361619 100644\n--- a/src/function/table/system/duckdb_dependencies.cpp\n+++ b/src/function/table/system/duckdb_dependencies.cpp\n@@ -22,7 +22,7 @@ struct DuckDBDependenciesData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBDependenciesBind(ClientContext &context, vector<Value> &inputs,\n-                                                       unordered_map<string, Value> &named_parameters,\n+                                                       named_parameter_map_t &named_parameters,\n                                                        vector<LogicalType> &input_table_types,\n                                                        vector<string> &input_table_names,\n                                                        vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_functions.cpp b/src/function/table/system/duckdb_functions.cpp\nindex c575e43e5577..8b9b38030f8b 100644\n--- a/src/function/table/system/duckdb_functions.cpp\n+++ b/src/function/table/system/duckdb_functions.cpp\n@@ -22,7 +22,7 @@ struct DuckDBFunctionsData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBFunctionsBind(ClientContext &context, vector<Value> &inputs,\n-                                                    unordered_map<string, Value> &named_parameters,\n+                                                    named_parameter_map_t &named_parameters,\n                                                     vector<LogicalType> &input_table_types,\n                                                     vector<string> &input_table_names,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_indexes.cpp b/src/function/table/system/duckdb_indexes.cpp\nindex 36a18038e30e..3f70e2b1ea13 100644\n--- a/src/function/table/system/duckdb_indexes.cpp\n+++ b/src/function/table/system/duckdb_indexes.cpp\n@@ -19,7 +19,7 @@ struct DuckDBIndexesData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBIndexesBind(ClientContext &context, vector<Value> &inputs,\n-                                                  unordered_map<string, Value> &named_parameters,\n+                                                  named_parameter_map_t &named_parameters,\n                                                   vector<LogicalType> &input_table_types,\n                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                   vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_keywords.cpp b/src/function/table/system/duckdb_keywords.cpp\nindex 460e41aac595..bf60bcf6aff9 100644\n--- a/src/function/table/system/duckdb_keywords.cpp\n+++ b/src/function/table/system/duckdb_keywords.cpp\n@@ -15,7 +15,7 @@ struct DuckDBKeywordsData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBKeywordsBind(ClientContext &context, vector<Value> &inputs,\n-                                                   unordered_map<string, Value> &named_parameters,\n+                                                   named_parameter_map_t &named_parameters,\n                                                    vector<LogicalType> &input_table_types,\n                                                    vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                    vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_schemas.cpp b/src/function/table/system/duckdb_schemas.cpp\nindex d6b069d6cdd4..8ed9495d9dee 100644\n--- a/src/function/table/system/duckdb_schemas.cpp\n+++ b/src/function/table/system/duckdb_schemas.cpp\n@@ -16,7 +16,7 @@ struct DuckDBSchemasData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBSchemasBind(ClientContext &context, vector<Value> &inputs,\n-                                                  unordered_map<string, Value> &named_parameters,\n+                                                  named_parameter_map_t &named_parameters,\n                                                   vector<LogicalType> &input_table_types,\n                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                   vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_sequences.cpp b/src/function/table/system/duckdb_sequences.cpp\nindex 182fe70f305c..46b9bd0cd387 100644\n--- a/src/function/table/system/duckdb_sequences.cpp\n+++ b/src/function/table/system/duckdb_sequences.cpp\n@@ -17,7 +17,7 @@ struct DuckDBSequencesData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBSequencesBind(ClientContext &context, vector<Value> &inputs,\n-                                                    unordered_map<string, Value> &named_parameters,\n+                                                    named_parameter_map_t &named_parameters,\n                                                     vector<LogicalType> &input_table_types,\n                                                     vector<string> &input_table_names,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_settings.cpp b/src/function/table/system/duckdb_settings.cpp\nindex d36d4a3fd757..9793d393f148 100644\n--- a/src/function/table/system/duckdb_settings.cpp\n+++ b/src/function/table/system/duckdb_settings.cpp\n@@ -21,7 +21,7 @@ struct DuckDBSettingsData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBSettingsBind(ClientContext &context, vector<Value> &inputs,\n-                                                   unordered_map<string, Value> &named_parameters,\n+                                                   named_parameter_map_t &named_parameters,\n                                                    vector<LogicalType> &input_table_types,\n                                                    vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                    vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_tables.cpp b/src/function/table/system/duckdb_tables.cpp\nindex 9a0842cde13e..7f96ac432f50 100644\n--- a/src/function/table/system/duckdb_tables.cpp\n+++ b/src/function/table/system/duckdb_tables.cpp\n@@ -20,7 +20,7 @@ struct DuckDBTablesData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBTablesBind(ClientContext &context, vector<Value> &inputs,\n-                                                 unordered_map<string, Value> &named_parameters,\n+                                                 named_parameter_map_t &named_parameters,\n                                                  vector<LogicalType> &input_table_types,\n                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                  vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_types.cpp b/src/function/table/system/duckdb_types.cpp\nindex 37959e3ac0e6..8beb5ef94c0f 100644\n--- a/src/function/table/system/duckdb_types.cpp\n+++ b/src/function/table/system/duckdb_types.cpp\n@@ -17,7 +17,7 @@ struct DuckDBTypesData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBTypesBind(ClientContext &context, vector<Value> &inputs,\n-                                                unordered_map<string, Value> &named_parameters,\n+                                                named_parameter_map_t &named_parameters,\n                                                 vector<LogicalType> &input_table_types,\n                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                 vector<string> &names) {\ndiff --git a/src/function/table/system/duckdb_views.cpp b/src/function/table/system/duckdb_views.cpp\nindex c879747af02a..05ec83c76281 100644\n--- a/src/function/table/system/duckdb_views.cpp\n+++ b/src/function/table/system/duckdb_views.cpp\n@@ -17,7 +17,7 @@ struct DuckDBViewsData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> DuckDBViewsBind(ClientContext &context, vector<Value> &inputs,\n-                                                unordered_map<string, Value> &named_parameters,\n+                                                named_parameter_map_t &named_parameters,\n                                                 vector<LogicalType> &input_table_types,\n                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                 vector<string> &names) {\ndiff --git a/src/function/table/system/pragma_collations.cpp b/src/function/table/system/pragma_collations.cpp\nindex efa76f5e5771..cdf19ef7cfb8 100644\n--- a/src/function/table/system/pragma_collations.cpp\n+++ b/src/function/table/system/pragma_collations.cpp\n@@ -16,7 +16,7 @@ struct PragmaCollateData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> PragmaCollateBind(ClientContext &context, vector<Value> &inputs,\n-                                                  unordered_map<string, Value> &named_parameters,\n+                                                  named_parameter_map_t &named_parameters,\n                                                   vector<LogicalType> &input_table_types,\n                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                   vector<string> &names) {\ndiff --git a/src/function/table/system/pragma_database_list.cpp b/src/function/table/system/pragma_database_list.cpp\nindex 6869b0a745d0..d94cf039638d 100644\n--- a/src/function/table/system/pragma_database_list.cpp\n+++ b/src/function/table/system/pragma_database_list.cpp\n@@ -12,7 +12,7 @@ struct PragmaDatabaseListData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> PragmaDatabaseListBind(ClientContext &context, vector<Value> &inputs,\n-                                                       unordered_map<string, Value> &named_parameters,\n+                                                       named_parameter_map_t &named_parameters,\n                                                        vector<LogicalType> &input_table_types,\n                                                        vector<string> &input_table_names,\n                                                        vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/function/table/system/pragma_database_size.cpp b/src/function/table/system/pragma_database_size.cpp\nindex 8898a139670a..c16bfa2ec1c4 100644\n--- a/src/function/table/system/pragma_database_size.cpp\n+++ b/src/function/table/system/pragma_database_size.cpp\n@@ -16,7 +16,7 @@ struct PragmaDatabaseSizeData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> PragmaDatabaseSizeBind(ClientContext &context, vector<Value> &inputs,\n-                                                       unordered_map<string, Value> &named_parameters,\n+                                                       named_parameter_map_t &named_parameters,\n                                                        vector<LogicalType> &input_table_types,\n                                                        vector<string> &input_table_names,\n                                                        vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/function/table/system/pragma_functions.cpp b/src/function/table/system/pragma_functions.cpp\nindex 30bfcf97525c..39f69d0eb632 100644\n--- a/src/function/table/system/pragma_functions.cpp\n+++ b/src/function/table/system/pragma_functions.cpp\n@@ -19,7 +19,7 @@ struct PragmaFunctionsData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> PragmaFunctionsBind(ClientContext &context, vector<Value> &inputs,\n-                                                    unordered_map<string, Value> &named_parameters,\n+                                                    named_parameter_map_t &named_parameters,\n                                                     vector<LogicalType> &input_table_types,\n                                                     vector<string> &input_table_names,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/function/table/system/pragma_storage_info.cpp b/src/function/table/system/pragma_storage_info.cpp\nindex a9cd03641040..563b3ef22448 100644\n--- a/src/function/table/system/pragma_storage_info.cpp\n+++ b/src/function/table/system/pragma_storage_info.cpp\n@@ -31,7 +31,7 @@ struct PragmaStorageOperatorData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> PragmaStorageInfoBind(ClientContext &context, vector<Value> &inputs,\n-                                                      unordered_map<string, Value> &named_parameters,\n+                                                      named_parameter_map_t &named_parameters,\n                                                       vector<LogicalType> &input_table_types,\n                                                       vector<string> &input_table_names,\n                                                       vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/function/table/system/pragma_table_info.cpp b/src/function/table/system/pragma_table_info.cpp\nindex 33112078302a..e022f02e5820 100644\n--- a/src/function/table/system/pragma_table_info.cpp\n+++ b/src/function/table/system/pragma_table_info.cpp\n@@ -28,7 +28,7 @@ struct PragmaTableOperatorData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> PragmaTableInfoBind(ClientContext &context, vector<Value> &inputs,\n-                                                    unordered_map<string, Value> &named_parameters,\n+                                                    named_parameter_map_t &named_parameters,\n                                                     vector<LogicalType> &input_table_types,\n                                                     vector<string> &input_table_names,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/src/function/table/unnest.cpp b/src/function/table/unnest.cpp\nindex 296c85e620f9..6786427462c5 100644\n--- a/src/function/table/unnest.cpp\n+++ b/src/function/table/unnest.cpp\n@@ -18,7 +18,7 @@ struct UnnestOperatorData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> UnnestBind(ClientContext &context, vector<Value> &inputs,\n-                                           unordered_map<string, Value> &named_parameters,\n+                                           named_parameter_map_t &named_parameters,\n                                            vector<LogicalType> &input_table_types, vector<string> &input_table_names,\n                                            vector<LogicalType> &return_types, vector<string> &names) {\n \treturn_types.push_back(ListType::GetChildType(inputs[0].type()));\ndiff --git a/src/function/table/version/pragma_version.cpp b/src/function/table/version/pragma_version.cpp\nindex 7d7ef3cc35a4..9674327d2210 100644\n--- a/src/function/table/version/pragma_version.cpp\n+++ b/src/function/table/version/pragma_version.cpp\n@@ -10,7 +10,7 @@ struct PragmaVersionData : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> PragmaVersionBind(ClientContext &context, vector<Value> &inputs,\n-                                                  unordered_map<string, Value> &named_parameters,\n+                                                  named_parameter_map_t &named_parameters,\n                                                   vector<LogicalType> &input_table_types,\n                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                   vector<string> &names) {\ndiff --git a/src/include/duckdb/common/named_parameter_map.hpp b/src/include/duckdb/common/named_parameter_map.hpp\nnew file mode 100644\nindex 000000000000..b39e81e11dc1\n--- /dev/null\n+++ b/src/include/duckdb/common/named_parameter_map.hpp\n@@ -0,0 +1,18 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/named_parameter_map.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n+#include \"duckdb/common/types.hpp\"\n+namespace duckdb {\n+\n+using named_parameter_type_map_t = case_insensitive_map_t<LogicalType>;\n+using named_parameter_map_t = case_insensitive_map_t<Value>;\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/function/function.hpp b/src/include/duckdb/function/function.hpp\nindex 0e8ac7428a59..3ea976332622 100644\n--- a/src/include/duckdb/function/function.hpp\n+++ b/src/include/duckdb/function/function.hpp\n@@ -9,7 +9,7 @@\n #pragma once\n \n #include \"duckdb/common/types/data_chunk.hpp\"\n-#include \"duckdb/common/unordered_map.hpp\"\n+#include \"duckdb/common/named_parameter_map.hpp\"\n #include \"duckdb/common/unordered_set.hpp\"\n #include \"duckdb/parser/column_definition.hpp\"\n \n@@ -47,7 +47,7 @@ struct TableFunctionData : public FunctionData {\n \n struct FunctionParameters {\n \tvector<Value> values;\n-\tunordered_map<string, Value> named_parameters;\n+\tnamed_parameter_map_t named_parameters;\n };\n \n //! Function is the base class used for any type of function (scalar, aggregate or simple function)\n@@ -67,7 +67,7 @@ class Function {\n \t                                      const LogicalType &return_type);\n \t//! Returns the formatted string name(arg1, arg2.., np1=a, np2=b, ...)\n \tDUCKDB_API static string CallToString(const string &name, const vector<LogicalType> &arguments,\n-\t                                      const unordered_map<string, LogicalType> &named_parameters);\n+\t                                      const named_parameter_type_map_t &named_parameters);\n \n \t//! Bind a scalar function from the set of functions and input arguments. Returns the index of the chosen function,\n \t//! returns DConstants::INVALID_INDEX and sets error if none could be found\n@@ -117,14 +117,14 @@ class SimpleNamedParameterFunction : public SimpleFunction {\n \tDUCKDB_API ~SimpleNamedParameterFunction() override;\n \n \t//! The named parameters of the function\n-\tunordered_map<string, LogicalType> named_parameters;\n+\tnamed_parameter_type_map_t named_parameters;\n \n public:\n \tDUCKDB_API string ToString() override;\n \tDUCKDB_API bool HasNamedParameters();\n \n \tDUCKDB_API void EvaluateInputParameters(vector<LogicalType> &arguments, vector<Value> &parameters,\n-\t                                        unordered_map<string, Value> &named_parameters,\n+\t                                        named_parameter_map_t &named_parameters,\n \t                                        vector<unique_ptr<ParsedExpression>> &children);\n };\n \ndiff --git a/src/include/duckdb/function/pragma_function.hpp b/src/include/duckdb/function/pragma_function.hpp\nindex a68a4a217c29..1fcf342bbb86 100644\n--- a/src/include/duckdb/function/pragma_function.hpp\n+++ b/src/include/duckdb/function/pragma_function.hpp\n@@ -47,7 +47,7 @@ class PragmaFunction : public SimpleNamedParameterFunction {\n \n \tpragma_query_t query;\n \tpragma_function_t function;\n-\tunordered_map<string, LogicalType> named_parameters;\n+\tnamed_parameter_type_map_t named_parameters;\n \n private:\n \tPragmaFunction(string name, PragmaType pragma_type, pragma_query_t query, pragma_function_t function,\ndiff --git a/src/include/duckdb/function/table/arrow.hpp b/src/include/duckdb/function/table/arrow.hpp\nindex e527431725a5..8e42f79221f1 100644\n--- a/src/include/duckdb/function/table/arrow.hpp\n+++ b/src/include/duckdb/function/table/arrow.hpp\n@@ -115,7 +115,7 @@ struct ArrowTableFunction {\n private:\n \t//! Binds an arrow table\n \tstatic unique_ptr<FunctionData> ArrowScanBind(ClientContext &context, vector<Value> &inputs,\n-\t                                              unordered_map<string, Value> &named_parameters,\n+\t                                              named_parameter_map_t &named_parameters,\n \t                                              vector<LogicalType> &input_table_types,\n \t                                              vector<string> &input_table_names, vector<LogicalType> &return_types,\n \t                                              vector<string> &names);\ndiff --git a/src/include/duckdb/function/table_function.hpp b/src/include/duckdb/function/table_function.hpp\nindex db9985a75221..0215e4579f25 100644\n--- a/src/include/duckdb/function/table_function.hpp\n+++ b/src/include/duckdb/function/table_function.hpp\n@@ -7,8 +7,6 @@\n //===----------------------------------------------------------------------===//\n \n #pragma once\n-\n-#include \"duckdb/common/unordered_map.hpp\"\n #include \"duckdb/function/function.hpp\"\n #include \"duckdb/storage/statistics/node_statistics.hpp\"\n \n@@ -31,7 +29,7 @@ struct TableFilterCollection {\n };\n \n typedef unique_ptr<FunctionData> (*table_function_bind_t)(ClientContext &context, vector<Value> &inputs,\n-                                                          unordered_map<string, Value> &named_parameters,\n+                                                          named_parameter_map_t &named_parameters,\n                                                           vector<LogicalType> &input_table_types,\n                                                           vector<string> &input_table_names,\n                                                           vector<LogicalType> &return_types, vector<string> &names);\ndiff --git a/src/include/duckdb/main/client_config.hpp b/src/include/duckdb/main/client_config.hpp\nindex bdb112cf6a24..5a7da65209d0 100644\n--- a/src/include/duckdb/main/client_config.hpp\n+++ b/src/include/duckdb/main/client_config.hpp\n@@ -35,6 +35,10 @@ struct ClientConfig {\n \t//! The wait time before showing the progress bar\n \tint wait_time = 2000;\n \n+\t//! Preserve identifier case while parsing.\n+\t//! If false, all unquoted identifiers are lower-cased (e.g. \"MyTable\" -> \"mytable\").\n+\tbool preserve_identifier_case = true;\n+\n \t// Whether or not aggressive query verification is enabled\n \tbool query_verification_enabled = false;\n \t//! Enable the running of optimizers\ndiff --git a/src/include/duckdb/main/client_context.hpp b/src/include/duckdb/main/client_context.hpp\nindex 9ffef60459ac..09bf8bca26dc 100644\n--- a/src/include/duckdb/main/client_context.hpp\n+++ b/src/include/duckdb/main/client_context.hpp\n@@ -42,6 +42,7 @@ class ClientContextLock;\n struct CreateScalarFunctionInfo;\n class ScalarFunctionCatalogEntry;\n struct ActiveQueryContext;\n+struct ParserOptions;\n \n //! The ClientContext holds information relevant to the current client session\n //! during execution\n@@ -159,6 +160,9 @@ class ClientContext : public std::enable_shared_from_this<ClientContext> {\n \t//! Equivalent to CURRENT_SETTING(key) SQL function.\n \tDUCKDB_API bool TryGetCurrentSetting(const std::string &key, Value &result);\n \n+\t//! Returns the parser options for this client context\n+\tDUCKDB_API ParserOptions GetParserOptions();\n+\n \tDUCKDB_API unique_ptr<DataChunk> Fetch(ClientContextLock &lock, StreamQueryResult &result);\n \n \t//! Whether or not the given result object (streaming query result or pending query result) is active\ndiff --git a/src/include/duckdb/main/connection.hpp b/src/include/duckdb/main/connection.hpp\nindex ffbd37d2468f..dc7f0c5fa3df 100644\n--- a/src/include/duckdb/main/connection.hpp\n+++ b/src/include/duckdb/main/connection.hpp\n@@ -114,7 +114,7 @@ class Connection {\n \t//! Returns a relation that calls a specified table function\n \tDUCKDB_API shared_ptr<Relation> TableFunction(const string &tname);\n \tDUCKDB_API shared_ptr<Relation> TableFunction(const string &tname, const vector<Value> &values,\n-\t                                              const unordered_map<string, Value> &named_parameters);\n+\t                                              const named_parameter_map_t &named_parameters);\n \tDUCKDB_API shared_ptr<Relation> TableFunction(const string &tname, const vector<Value> &values);\n \t//! Returns a relation that produces values\n \tDUCKDB_API shared_ptr<Relation> Values(const vector<vector<Value>> &values);\ndiff --git a/src/include/duckdb/main/relation.hpp b/src/include/duckdb/main/relation.hpp\nindex d151c6c4f84b..3398bc4562d9 100644\n--- a/src/include/duckdb/main/relation.hpp\n+++ b/src/include/duckdb/main/relation.hpp\n@@ -14,7 +14,7 @@\n #include \"duckdb/common/winapi.hpp\"\n #include \"duckdb/main/query_result.hpp\"\n #include \"duckdb/parser/column_definition.hpp\"\n-#include \"duckdb/common/unordered_map.hpp\"\n+#include \"duckdb/common/named_parameter_map.hpp\"\n \n #include <memory>\n \n@@ -122,7 +122,7 @@ class Relation : public std::enable_shared_from_this<Relation> {\n \t//! Create a relation from calling a table in/out function on the input relation\n \tDUCKDB_API shared_ptr<Relation> TableFunction(const std::string &fname, const vector<Value> &values);\n \tDUCKDB_API shared_ptr<Relation> TableFunction(const std::string &fname, const vector<Value> &values,\n-\t                                              const unordered_map<string, Value> &named_parameters);\n+\t                                              const named_parameter_map_t &named_parameters);\n \n public:\n \t//! Whether or not the relation inherits column bindings from its child or not, only relevant for binding\ndiff --git a/src/include/duckdb/main/relation/table_function_relation.hpp b/src/include/duckdb/main/relation/table_function_relation.hpp\nindex f735c4c66096..08b75de12cc3 100644\n--- a/src/include/duckdb/main/relation/table_function_relation.hpp\n+++ b/src/include/duckdb/main/relation/table_function_relation.hpp\n@@ -15,15 +15,14 @@ namespace duckdb {\n class TableFunctionRelation : public Relation {\n public:\n \tTableFunctionRelation(ClientContext &context, string name, vector<Value> parameters,\n-\t                      unordered_map<string, Value> named_parameters,\n-\t                      shared_ptr<Relation> input_relation_p = nullptr);\n+\t                      named_parameter_map_t named_parameters, shared_ptr<Relation> input_relation_p = nullptr);\n \n \tTableFunctionRelation(ClientContext &context, string name, vector<Value> parameters,\n \t                      shared_ptr<Relation> input_relation_p = nullptr);\n \n \tstring name;\n \tvector<Value> parameters;\n-\tunordered_map<string, Value> named_parameters;\n+\tnamed_parameter_map_t named_parameters;\n \tvector<ColumnDefinition> columns;\n \tshared_ptr<Relation> input_relation;\n \ndiff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp\nindex 92f9c16af500..02fb2a8b3052 100644\n--- a/src/include/duckdb/main/settings.hpp\n+++ b/src/include/duckdb/main/settings.hpp\n@@ -177,6 +177,15 @@ struct PerfectHashThresholdSetting {\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n+struct PreserveIdentifierCase {\n+\tstatic constexpr const char *Name = \"preserve_identifier_case\";\n+\tstatic constexpr const char *Description =\n+\t    \"Whether or not to preserve the identifier case, instead of always lowercasing all non-quoted identifiers\";\n+\tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n+\tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic Value GetSetting(ClientContext &context);\n+};\n+\n struct ProfilerHistorySize {\n \tstatic constexpr const char *Name = \"profiler_history_size\";\n \tstatic constexpr const char *Description = \"Sets the profiler history size\";\ndiff --git a/src/include/duckdb/parser/parsed_data/pragma_info.hpp b/src/include/duckdb/parser/parsed_data/pragma_info.hpp\nindex 50dd78faefaa..68e243eedc4e 100644\n--- a/src/include/duckdb/parser/parsed_data/pragma_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/pragma_info.hpp\n@@ -10,7 +10,7 @@\n \n #include \"duckdb/parser/parsed_data/parse_info.hpp\"\n #include \"duckdb/common/types/value.hpp\"\n-#include \"duckdb/common/unordered_map.hpp\"\n+#include \"duckdb/common/named_parameter_map.hpp\"\n #include \"duckdb/parser/parsed_expression.hpp\"\n \n namespace duckdb {\n@@ -23,7 +23,7 @@ struct PragmaInfo : public ParseInfo {\n \t//! Parameter list (if any)\n \tvector<Value> parameters;\n \t//! Named parameter list (if any)\n-\tunordered_map<string, Value> named_parameters;\n+\tnamed_parameter_map_t named_parameters;\n \n public:\n \tunique_ptr<PragmaInfo> Copy() const {\ndiff --git a/src/include/duckdb/parser/parser.hpp b/src/include/duckdb/parser/parser.hpp\nindex 18521aefa150..a7fa81cafd28 100644\n--- a/src/include/duckdb/parser/parser.hpp\n+++ b/src/include/duckdb/parser/parser.hpp\n@@ -21,12 +21,16 @@ struct PGList;\n \n namespace duckdb {\n \n+struct ParserOptions {\n+\tbool preserve_identifier_case = true;\n+};\n+\n //! The parser is responsible for parsing the query and converting it into a set\n //! of parsed statements. The parsed statements can then be converted into a\n //! plan and executed.\n class Parser {\n public:\n-\tParser();\n+\tParser(ParserOptions options = ParserOptions());\n \n \t//! The parsed SQL statements from an invocation to ParseQuery.\n \tvector<unique_ptr<SQLStatement>> statements;\n@@ -47,15 +51,21 @@ class Parser {\n \tstatic vector<ParserKeyword> KeywordList();\n \n \t//! Parses a list of expressions (i.e. the list found in a SELECT clause)\n-\tstatic vector<unique_ptr<ParsedExpression>> ParseExpressionList(const string &select_list);\n+\tstatic vector<unique_ptr<ParsedExpression>> ParseExpressionList(const string &select_list,\n+\t                                                                ParserOptions options = ParserOptions());\n \t//! Parses a list as found in an ORDER BY expression (i.e. including optional ASCENDING/DESCENDING modifiers)\n-\tstatic vector<OrderByNode> ParseOrderList(const string &select_list);\n+\tstatic vector<OrderByNode> ParseOrderList(const string &select_list, ParserOptions options = ParserOptions());\n \t//! Parses an update list (i.e. the list found in the SET clause of an UPDATE statement)\n \tstatic void ParseUpdateList(const string &update_list, vector<string> &update_columns,\n-\t                            vector<unique_ptr<ParsedExpression>> &expressions);\n+\t                            vector<unique_ptr<ParsedExpression>> &expressions,\n+\t                            ParserOptions options = ParserOptions());\n \t//! Parses a VALUES list (i.e. the list of expressions after a VALUES clause)\n-\tstatic vector<vector<unique_ptr<ParsedExpression>>> ParseValuesList(const string &value_list);\n+\tstatic vector<vector<unique_ptr<ParsedExpression>>> ParseValuesList(const string &value_list,\n+\t                                                                    ParserOptions options = ParserOptions());\n \t//! Parses a column list (i.e. as found in a CREATE TABLE statement)\n-\tstatic vector<ColumnDefinition> ParseColumnList(const string &column_list);\n+\tstatic vector<ColumnDefinition> ParseColumnList(const string &column_list, ParserOptions options = ParserOptions());\n+\n+private:\n+\tParserOptions options;\n };\n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex d8af9693ceb4..6602c67e0b3d 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -99,7 +99,7 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \tSchemaCatalogEntry *BindCreateFunctionInfo(CreateInfo &info);\n \n \t//! Check usage, and cast named parameters to their types\n-\tstatic void BindNamedParameters(unordered_map<string, LogicalType> &types, unordered_map<string, Value> &values,\n+\tstatic void BindNamedParameters(named_parameter_type_map_t &types, named_parameter_map_t &values,\n \t                                QueryErrorContext &error_context, string &func_name);\n \n \tunique_ptr<BoundTableRef> Bind(TableRef &ref);\n@@ -226,7 +226,7 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \tunique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);\n \n \tbool BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,\n-\t                            vector<Value> &parameters, unordered_map<string, Value> &named_parameters,\n+\t                            vector<Value> &parameters, named_parameter_map_t &named_parameters,\n \t                            unique_ptr<BoundSubqueryRef> &subquery, string &error);\n \n \tunique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);\ndiff --git a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\nindex f1a7f8c9c47c..9a431b16a886 100644\n--- a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\n@@ -8,7 +8,7 @@\n \n #pragma once\n \n-#include \"duckdb/common/unordered_map.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n \n namespace duckdb {\n@@ -19,14 +19,14 @@ class ColumnRefExpression;\n //! A helper binder for WhereBinder and HavingBinder which support alias as a columnref.\n class ColumnAliasBinder {\n public:\n-\tColumnAliasBinder(BoundSelectNode &node, const unordered_map<string, idx_t> &alias_map);\n+\tColumnAliasBinder(BoundSelectNode &node, const case_insensitive_map_t<idx_t> &alias_map);\n \n \tBindResult BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,\n \t                     bool root_expression);\n \n private:\n \tBoundSelectNode &node;\n-\tconst unordered_map<string, idx_t> &alias_map;\n+\tconst case_insensitive_map_t<idx_t> &alias_map;\n \tbool in_alias;\n };\n \ndiff --git a/src/include/duckdb/planner/expression_binder/group_binder.hpp b/src/include/duckdb/planner/expression_binder/group_binder.hpp\nindex 3c451560caa3..fe7ed2a54e2a 100644\n--- a/src/include/duckdb/planner/expression_binder/group_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/group_binder.hpp\n@@ -8,8 +8,7 @@\n \n #pragma once\n \n-#include \"duckdb/common/unordered_map.hpp\"\n-#include \"duckdb/common/unordered_set.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n \n namespace duckdb {\n@@ -20,7 +19,7 @@ class ColumnRefExpression;\n class GroupBinder : public ExpressionBinder {\n public:\n \tGroupBinder(Binder &binder, ClientContext &context, SelectNode &node, idx_t group_index,\n-\t            unordered_map<string, idx_t> &alias_map, unordered_map<string, idx_t> &group_alias_map);\n+\t            case_insensitive_map_t<idx_t> &alias_map, case_insensitive_map_t<idx_t> &group_alias_map);\n \n \t//! The unbound root expression\n \tunique_ptr<ParsedExpression> unbound_expression;\n@@ -37,8 +36,8 @@ class GroupBinder : public ExpressionBinder {\n \tBindResult BindConstant(ConstantExpression &expr);\n \n \tSelectNode &node;\n-\tunordered_map<string, idx_t> &alias_map;\n-\tunordered_map<string, idx_t> &group_alias_map;\n+\tcase_insensitive_map_t<idx_t> &alias_map;\n+\tcase_insensitive_map_t<idx_t> &group_alias_map;\n \tunordered_set<idx_t> used_aliases;\n \n \tidx_t group_index;\ndiff --git a/src/include/duckdb/planner/expression_binder/having_binder.hpp b/src/include/duckdb/planner/expression_binder/having_binder.hpp\nindex 5dbe8e8a9f85..4ac14b889d9c 100644\n--- a/src/include/duckdb/planner/expression_binder/having_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/having_binder.hpp\n@@ -17,7 +17,7 @@ namespace duckdb {\n class HavingBinder : public SelectBinder {\n public:\n \tHavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,\n-\t             unordered_map<string, idx_t> &alias_map);\n+\t             case_insensitive_map_t<idx_t> &alias_map);\n \n protected:\n \tBindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,\ndiff --git a/src/include/duckdb/planner/expression_binder/order_binder.hpp b/src/include/duckdb/planner/expression_binder/order_binder.hpp\nindex 7d8f71646311..da3519cf3f2c 100644\n--- a/src/include/duckdb/planner/expression_binder/order_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/order_binder.hpp\n@@ -8,7 +8,7 @@\n \n #pragma once\n \n-#include \"duckdb/common/unordered_map.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n #include \"duckdb/parser/expression_map.hpp\"\n #include \"duckdb/parser/parsed_expression.hpp\"\n #include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n@@ -21,10 +21,10 @@ class SelectNode;\n //! The ORDER binder is responsible for binding an expression within the ORDER BY clause of a SQL statement\n class OrderBinder {\n public:\n-\tOrderBinder(vector<Binder *> binders, idx_t projection_index, unordered_map<string, idx_t> &alias_map,\n+\tOrderBinder(vector<Binder *> binders, idx_t projection_index, case_insensitive_map_t<idx_t> &alias_map,\n \t            expression_map_t<idx_t> &projection_map, idx_t max_count);\n \tOrderBinder(vector<Binder *> binders, idx_t projection_index, SelectNode &node,\n-\t            unordered_map<string, idx_t> &alias_map, expression_map_t<idx_t> &projection_map);\n+\t            case_insensitive_map_t<idx_t> &alias_map, expression_map_t<idx_t> &projection_map);\n \n public:\n \tunique_ptr<Expression> Bind(unique_ptr<ParsedExpression> expr);\n@@ -41,7 +41,7 @@ class OrderBinder {\n \tidx_t projection_index;\n \tidx_t max_count;\n \tvector<unique_ptr<ParsedExpression>> *extra_list;\n-\tunordered_map<string, idx_t> &alias_map;\n+\tcase_insensitive_map_t<idx_t> &alias_map;\n \texpression_map_t<idx_t> &projection_map;\n };\n \ndiff --git a/src/include/duckdb/planner/expression_binder/qualify_binder.hpp b/src/include/duckdb/planner/expression_binder/qualify_binder.hpp\nindex 8fca9a78412b..b0dec724c2e5 100644\n--- a/src/include/duckdb/planner/expression_binder/qualify_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/qualify_binder.hpp\n@@ -17,7 +17,7 @@ namespace duckdb {\n class QualifyBinder : public SelectBinder {\n public:\n \tQualifyBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,\n-\t              unordered_map<string, idx_t> &alias_map);\n+\t              case_insensitive_map_t<idx_t> &alias_map);\n \n protected:\n \tBindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,\ndiff --git a/src/include/duckdb/planner/expression_binder/select_binder.hpp b/src/include/duckdb/planner/expression_binder/select_binder.hpp\nindex efa759830dd5..9b25eac633e2 100644\n--- a/src/include/duckdb/planner/expression_binder/select_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/select_binder.hpp\n@@ -8,7 +8,7 @@\n \n #pragma once\n \n-#include \"duckdb/common/unordered_map.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n #include \"duckdb/parser/expression_map.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n \n@@ -20,7 +20,7 @@ class BoundSelectNode;\n \n struct BoundGroupInformation {\n \texpression_map_t<idx_t> map;\n-\tunordered_map<string, idx_t> alias_map;\n+\tcase_insensitive_map_t<idx_t> alias_map;\n };\n \n //! The SELECT binder is responsible for binding an expression within the SELECT clause of a SQL statement\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex ec05db062f27..2894ddb599f0 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -364,7 +364,7 @@ vector<unique_ptr<SQLStatement>> ClientContext::ParseStatements(const string &qu\n }\n \n vector<unique_ptr<SQLStatement>> ClientContext::ParseStatementsInternal(ClientContextLock &lock, const string &query) {\n-\tParser parser;\n+\tParser parser(GetParserOptions());\n \tparser.ParseQuery(query);\n \n \tPragmaHandler handler(*this);\n@@ -1101,4 +1101,10 @@ bool ClientContext::TryGetCurrentSetting(const std::string &key, Value &result)\n \treturn true;\n }\n \n+ParserOptions ClientContext::GetParserOptions() {\n+\tParserOptions options;\n+\toptions.preserve_identifier_case = ClientConfig::GetConfig(*this).preserve_identifier_case;\n+\treturn options;\n+}\n+\n } // namespace duckdb\ndiff --git a/src/main/config.cpp b/src/main/config.cpp\nindex 2ea78415f8ea..18925b35f347 100644\n--- a/src/main/config.cpp\n+++ b/src/main/config.cpp\n@@ -43,6 +43,7 @@ static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting\n                                                  DUCKDB_GLOBAL_ALIAS(\"memory_limit\", MaximumMemorySetting),\n                                                  DUCKDB_GLOBAL_ALIAS(\"null_order\", DefaultNullOrderSetting),\n                                                  DUCKDB_LOCAL(PerfectHashThresholdSetting),\n+                                                 DUCKDB_LOCAL(PreserveIdentifierCase),\n                                                  DUCKDB_LOCAL(ProfilerHistorySize),\n                                                  DUCKDB_LOCAL(ProfileOutputSetting),\n                                                  DUCKDB_LOCAL(ProfilingModeSetting),\n@@ -82,8 +83,10 @@ ConfigurationOption *DBConfig::GetOptionByIndex(idx_t target_index) {\n }\n \n ConfigurationOption *DBConfig::GetOptionByName(const string &name) {\n+\tauto lname = StringUtil::Lower(name);\n \tfor (idx_t index = 0; internal_options[index].name; index++) {\n-\t\tif (internal_options[index].name == name) {\n+\t\tD_ASSERT(StringUtil::Lower(internal_options[index].name) == string(internal_options[index].name));\n+\t\tif (internal_options[index].name == lname) {\n \t\t\treturn internal_options + index;\n \t\t}\n \t}\ndiff --git a/src/main/connection.cpp b/src/main/connection.cpp\nindex 9df5baf7db5c..ac2922394039 100644\n--- a/src/main/connection.cpp\n+++ b/src/main/connection.cpp\n@@ -147,12 +147,12 @@ shared_ptr<Relation> Connection::View(const string &schema_name, const string &t\n \n shared_ptr<Relation> Connection::TableFunction(const string &fname) {\n \tvector<Value> values;\n-\tunordered_map<string, Value> named_parameters;\n+\tnamed_parameter_map_t named_parameters;\n \treturn TableFunction(fname, values, named_parameters);\n }\n \n shared_ptr<Relation> Connection::TableFunction(const string &fname, const vector<Value> &values,\n-                                               const unordered_map<string, Value> &named_parameters) {\n+                                               const named_parameter_map_t &named_parameters) {\n \treturn make_shared<TableFunctionRelation>(*context, fname, values, named_parameters);\n }\n \n@@ -195,7 +195,7 @@ shared_ptr<Relation> Connection::ReadCSV(const string &csv_file, const vector<st\n \t// parse columns\n \tvector<ColumnDefinition> column_list;\n \tfor (auto &column : columns) {\n-\t\tauto col_list = Parser::ParseColumnList(column);\n+\t\tauto col_list = Parser::ParseColumnList(column, context->GetParserOptions());\n \t\tif (col_list.size() != 1) {\n \t\t\tthrow ParserException(\"Expected a single column definition\");\n \t\t}\ndiff --git a/src/main/relation.cpp b/src/main/relation.cpp\nindex 8a335b8d72c5..04c0b3eb1ec1 100644\n--- a/src/main/relation.cpp\n+++ b/src/main/relation.cpp\n@@ -35,7 +35,7 @@ shared_ptr<Relation> Relation::Project(const string &expression, const string &a\n }\n \n shared_ptr<Relation> Relation::Project(const string &select_list, const vector<string> &aliases) {\n-\tauto expressions = Parser::ParseExpressionList(select_list);\n+\tauto expressions = Parser::ParseExpressionList(select_list, context.GetParserOptions());\n \treturn make_shared<ProjectionRelation>(shared_from_this(), move(expressions), aliases);\n }\n \n@@ -44,13 +44,14 @@ shared_ptr<Relation> Relation::Project(const vector<string> &expressions) {\n \treturn Project(expressions, aliases);\n }\n \n-static vector<unique_ptr<ParsedExpression>> StringListToExpressionList(const vector<string> &expressions) {\n+static vector<unique_ptr<ParsedExpression>> StringListToExpressionList(ClientContext &context,\n+                                                                       const vector<string> &expressions) {\n \tif (expressions.empty()) {\n \t\tthrow ParserException(\"Zero expressions provided\");\n \t}\n \tvector<unique_ptr<ParsedExpression>> result_list;\n \tfor (auto &expr : expressions) {\n-\t\tauto expression_list = Parser::ParseExpressionList(expr);\n+\t\tauto expression_list = Parser::ParseExpressionList(expr, context.GetParserOptions());\n \t\tif (expression_list.size() != 1) {\n \t\t\tthrow ParserException(\"Expected a single expression in the expression list\");\n \t\t}\n@@ -60,12 +61,12 @@ static vector<unique_ptr<ParsedExpression>> StringListToExpressionList(const vec\n }\n \n shared_ptr<Relation> Relation::Project(const vector<string> &expressions, const vector<string> &aliases) {\n-\tauto result_list = StringListToExpressionList(expressions);\n+\tauto result_list = StringListToExpressionList(context, expressions);\n \treturn make_shared<ProjectionRelation>(shared_from_this(), move(result_list), aliases);\n }\n \n shared_ptr<Relation> Relation::Filter(const string &expression) {\n-\tauto expression_list = Parser::ParseExpressionList(expression);\n+\tauto expression_list = Parser::ParseExpressionList(expression, context.GetParserOptions());\n \tif (expression_list.size() != 1) {\n \t\tthrow ParserException(\"Expected a single expression as filter condition\");\n \t}\n@@ -74,7 +75,7 @@ shared_ptr<Relation> Relation::Filter(const string &expression) {\n \n shared_ptr<Relation> Relation::Filter(const vector<string> &expressions) {\n \t// if there are multiple expressions, we AND them together\n-\tauto expression_list = StringListToExpressionList(expressions);\n+\tauto expression_list = StringListToExpressionList(context, expressions);\n \tD_ASSERT(!expression_list.empty());\n \n \tauto expr = move(expression_list[0]);\n@@ -90,7 +91,7 @@ shared_ptr<Relation> Relation::Limit(int64_t limit, int64_t offset) {\n }\n \n shared_ptr<Relation> Relation::Order(const string &expression) {\n-\tauto order_list = Parser::ParseOrderList(expression);\n+\tauto order_list = Parser::ParseOrderList(expression, context.GetParserOptions());\n \treturn make_shared<OrderRelation>(shared_from_this(), move(order_list));\n }\n \n@@ -100,7 +101,7 @@ shared_ptr<Relation> Relation::Order(const vector<string> &expressions) {\n \t}\n \tvector<OrderByNode> order_list;\n \tfor (auto &expression : expressions) {\n-\t\tauto inner_list = Parser::ParseOrderList(expression);\n+\t\tauto inner_list = Parser::ParseOrderList(expression, context.GetParserOptions());\n \t\tif (inner_list.size() != 1) {\n \t\t\tthrow ParserException(\"Expected a single ORDER BY expression in the expression list\");\n \t\t}\n@@ -110,7 +111,7 @@ shared_ptr<Relation> Relation::Order(const vector<string> &expressions) {\n }\n \n shared_ptr<Relation> Relation::Join(const shared_ptr<Relation> &other, const string &condition, JoinType type) {\n-\tauto expression_list = Parser::ParseExpressionList(condition);\n+\tauto expression_list = Parser::ParseExpressionList(condition, context.GetParserOptions());\n \tD_ASSERT(!expression_list.empty());\n \n \tif (expression_list.size() > 1 || expression_list[0]->type == ExpressionType::COLUMN_REF) {\n@@ -154,24 +155,24 @@ shared_ptr<Relation> Relation::Alias(const string &alias) {\n }\n \n shared_ptr<Relation> Relation::Aggregate(const string &aggregate_list) {\n-\tauto expression_list = Parser::ParseExpressionList(aggregate_list);\n+\tauto expression_list = Parser::ParseExpressionList(aggregate_list, context.GetParserOptions());\n \treturn make_shared<AggregateRelation>(shared_from_this(), move(expression_list));\n }\n \n shared_ptr<Relation> Relation::Aggregate(const string &aggregate_list, const string &group_list) {\n-\tauto expression_list = Parser::ParseExpressionList(aggregate_list);\n-\tauto groups = Parser::ParseExpressionList(group_list);\n+\tauto expression_list = Parser::ParseExpressionList(aggregate_list, context.GetParserOptions());\n+\tauto groups = Parser::ParseExpressionList(group_list, context.GetParserOptions());\n \treturn make_shared<AggregateRelation>(shared_from_this(), move(expression_list), move(groups));\n }\n \n shared_ptr<Relation> Relation::Aggregate(const vector<string> &aggregates) {\n-\tauto aggregate_list = StringListToExpressionList(aggregates);\n+\tauto aggregate_list = StringListToExpressionList(context, aggregates);\n \treturn make_shared<AggregateRelation>(shared_from_this(), move(aggregate_list));\n }\n \n shared_ptr<Relation> Relation::Aggregate(const vector<string> &aggregates, const vector<string> &groups) {\n-\tauto aggregate_list = StringListToExpressionList(aggregates);\n-\tauto group_list = StringListToExpressionList(groups);\n+\tauto aggregate_list = StringListToExpressionList(context, aggregates);\n+\tauto group_list = StringListToExpressionList(context, groups);\n \treturn make_shared<AggregateRelation>(shared_from_this(), move(aggregate_list), move(group_list));\n }\n \n@@ -265,7 +266,7 @@ void Relation::Delete(const string &condition) {\n }\n \n shared_ptr<Relation> Relation::TableFunction(const std::string &fname, const vector<Value> &values,\n-                                             const unordered_map<string, Value> &named_parameters) {\n+                                             const named_parameter_map_t &named_parameters) {\n \treturn make_shared<TableFunctionRelation>(context, fname, values, named_parameters, shared_from_this());\n }\n \ndiff --git a/src/main/relation/query_relation.cpp b/src/main/relation/query_relation.cpp\nindex 086e9f27b9c8..c2f9fb15ec2d 100644\n--- a/src/main/relation/query_relation.cpp\n+++ b/src/main/relation/query_relation.cpp\n@@ -12,7 +12,7 @@ QueryRelation::QueryRelation(ClientContext &context, string query, string alias)\n }\n \n unique_ptr<SelectStatement> QueryRelation::GetSelectStatement() {\n-\tParser parser;\n+\tParser parser(context.GetParserOptions());\n \tparser.ParseQuery(query);\n \tif (parser.statements.size() != 1) {\n \t\tthrow ParserException(\"Expected a single SELECT statement\");\ndiff --git a/src/main/relation/table_function_relation.cpp b/src/main/relation/table_function_relation.cpp\nindex d8debc6ec5a6..288ef1b74ac4 100644\n--- a/src/main/relation/table_function_relation.cpp\n+++ b/src/main/relation/table_function_relation.cpp\n@@ -13,7 +13,7 @@\n namespace duckdb {\n \n TableFunctionRelation::TableFunctionRelation(ClientContext &context, string name_p, vector<Value> parameters_p,\n-                                             unordered_map<string, Value> named_parameters,\n+                                             named_parameter_map_t named_parameters,\n                                              shared_ptr<Relation> input_relation_p)\n     : Relation(context, RelationType::TABLE_FUNCTION_RELATION), name(move(name_p)), parameters(move(parameters_p)),\n       named_parameters(move(named_parameters)), input_relation(move(input_relation_p)) {\ndiff --git a/src/main/relation/table_relation.cpp b/src/main/relation/table_relation.cpp\nindex e54271853fbc..8a4df5743297 100644\n--- a/src/main/relation/table_relation.cpp\n+++ b/src/main/relation/table_relation.cpp\n@@ -5,6 +5,7 @@\n #include \"duckdb/main/relation/delete_relation.hpp\"\n #include \"duckdb/main/relation/update_relation.hpp\"\n #include \"duckdb/parser/parser.hpp\"\n+#include \"duckdb/main/client_context.hpp\"\n \n namespace duckdb {\n \n@@ -38,9 +39,9 @@ string TableRelation::ToString(idx_t depth) {\n \treturn RenderWhitespace(depth) + \"Scan Table [\" + description->table + \"]\";\n }\n \n-static unique_ptr<ParsedExpression> ParseCondition(const string &condition) {\n+static unique_ptr<ParsedExpression> ParseCondition(ClientContext &context, const string &condition) {\n \tif (!condition.empty()) {\n-\t\tauto expression_list = Parser::ParseExpressionList(condition);\n+\t\tauto expression_list = Parser::ParseExpressionList(condition, context.GetParserOptions());\n \t\tif (expression_list.size() != 1) {\n \t\t\tthrow ParserException(\"Expected a single expression as filter condition\");\n \t\t}\n@@ -53,15 +54,15 @@ static unique_ptr<ParsedExpression> ParseCondition(const string &condition) {\n void TableRelation::Update(const string &update_list, const string &condition) {\n \tvector<string> update_columns;\n \tvector<unique_ptr<ParsedExpression>> expressions;\n-\tauto cond = ParseCondition(condition);\n-\tParser::ParseUpdateList(update_list, update_columns, expressions);\n+\tauto cond = ParseCondition(context, condition);\n+\tParser::ParseUpdateList(update_list, update_columns, expressions, context.GetParserOptions());\n \tauto update = make_shared<UpdateRelation>(context, move(cond), description->schema, description->table,\n \t                                          move(update_columns), move(expressions));\n \tupdate->Execute();\n }\n \n void TableRelation::Delete(const string &condition) {\n-\tauto cond = ParseCondition(condition);\n+\tauto cond = ParseCondition(context, condition);\n \tauto del = make_shared<DeleteRelation>(context, move(cond), description->schema, description->table);\n \tdel->Execute();\n }\ndiff --git a/src/main/relation/value_relation.cpp b/src/main/relation/value_relation.cpp\nindex 5d0b79eee8d3..138f9bf4438c 100644\n--- a/src/main/relation/value_relation.cpp\n+++ b/src/main/relation/value_relation.cpp\n@@ -25,7 +25,7 @@ ValueRelation::ValueRelation(ClientContext &context, const vector<vector<Value>>\n \n ValueRelation::ValueRelation(ClientContext &context, const string &values_list, vector<string> names_p, string alias_p)\n     : Relation(context, RelationType::VALUE_LIST_RELATION), names(move(names_p)), alias(move(alias_p)) {\n-\tthis->expressions = Parser::ParseValuesList(values_list);\n+\tthis->expressions = Parser::ParseValuesList(values_list, context.GetParserOptions());\n \tcontext.TryBindRelation(*this, this->columns);\n }\n \ndiff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp\nindex 9f1cdac2b475..d2b64f4ddde6 100644\n--- a/src/main/settings/settings.cpp\n+++ b/src/main/settings/settings.cpp\n@@ -8,6 +8,7 @@\n #include \"duckdb/planner/expression_binder.hpp\"\n #include \"duckdb/main/query_profiler.hpp\"\n #include \"duckdb/storage/storage_manager.hpp\"\n+#include \"duckdb/parser/parser.hpp\"\n \n namespace duckdb {\n \n@@ -406,6 +407,17 @@ Value PerfectHashThresholdSetting::GetSetting(ClientContext &context) {\n \treturn Value::BIGINT(ClientConfig::GetConfig(context).perfect_ht_threshold);\n }\n \n+//===--------------------------------------------------------------------===//\n+// PreserveIdentifierCase\n+//===--------------------------------------------------------------------===//\n+void PreserveIdentifierCase::SetLocal(ClientContext &context, const Value &input) {\n+\tClientConfig::GetConfig(context).preserve_identifier_case = input.GetValue<bool>();\n+}\n+\n+Value PreserveIdentifierCase::GetSetting(ClientContext &context) {\n+\treturn Value::BOOLEAN(ClientConfig::GetConfig(context).preserve_identifier_case);\n+}\n+\n //===--------------------------------------------------------------------===//\n // Profiler History Size\n //===--------------------------------------------------------------------===//\ndiff --git a/src/parser/expression/columnref_expression.cpp b/src/parser/expression/columnref_expression.cpp\nindex 897c28e8838c..490f17b42c78 100644\n--- a/src/parser/expression/columnref_expression.cpp\n+++ b/src/parser/expression/columnref_expression.cpp\n@@ -3,6 +3,7 @@\n #include \"duckdb/common/exception.hpp\"\n #include \"duckdb/common/serializer.hpp\"\n #include \"duckdb/common/types/hash.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n \n namespace duckdb {\n \n@@ -53,13 +54,24 @@ string ColumnRefExpression::ToString() const {\n }\n \n bool ColumnRefExpression::Equals(const ColumnRefExpression *a, const ColumnRefExpression *b) {\n-\treturn a->column_names == b->column_names;\n+\tif (a->column_names.size() != b->column_names.size()) {\n+\t\treturn false;\n+\t}\n+\tfor (idx_t i = 0; i < a->column_names.size(); i++) {\n+\t\tauto lcase_a = StringUtil::Lower(a->column_names[i]);\n+\t\tauto lcase_b = StringUtil::Lower(b->column_names[i]);\n+\t\tif (lcase_a != lcase_b) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\treturn true;\n }\n \n hash_t ColumnRefExpression::Hash() const {\n \thash_t result = ParsedExpression::Hash();\n \tfor (auto &column_name : column_names) {\n-\t\tresult = CombineHash(result, duckdb::Hash<const char *>(column_name.c_str()));\n+\t\tauto lcase = StringUtil::Lower(column_name);\n+\t\tresult = CombineHash(result, duckdb::Hash<const char *>(lcase.c_str()));\n \t}\n \treturn result;\n }\ndiff --git a/src/parser/parser.cpp b/src/parser/parser.cpp\nindex 8a501ae850c7..159f643c11c4 100644\n--- a/src/parser/parser.cpp\n+++ b/src/parser/parser.cpp\n@@ -14,12 +14,13 @@\n \n namespace duckdb {\n \n-Parser::Parser() {\n+Parser::Parser(ParserOptions options_p) : options(options_p) {\n }\n \n void Parser::ParseQuery(const string &query) {\n \tTransformer transformer;\n \t{\n+\t\tPostgresParser::SetPreserveIdentifierCase(options.preserve_identifier_case);\n \t\tPostgresParser parser;\n \t\tparser.Parse(query);\n \n@@ -115,11 +116,11 @@ vector<ParserKeyword> Parser::KeywordList() {\n \treturn result;\n }\n \n-vector<unique_ptr<ParsedExpression>> Parser::ParseExpressionList(const string &select_list) {\n+vector<unique_ptr<ParsedExpression>> Parser::ParseExpressionList(const string &select_list, ParserOptions options) {\n \t// construct a mock query prefixed with SELECT\n \tstring mock_query = \"SELECT \" + select_list;\n \t// parse the query\n-\tParser parser;\n+\tParser parser(options);\n \tparser.ParseQuery(mock_query);\n \t// check the statements\n \tif (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT_STATEMENT) {\n@@ -133,11 +134,11 @@ vector<unique_ptr<ParsedExpression>> Parser::ParseExpressionList(const string &s\n \treturn move(select_node.select_list);\n }\n \n-vector<OrderByNode> Parser::ParseOrderList(const string &select_list) {\n+vector<OrderByNode> Parser::ParseOrderList(const string &select_list, ParserOptions options) {\n \t// construct a mock query\n \tstring mock_query = \"SELECT * FROM tbl ORDER BY \" + select_list;\n \t// parse the query\n-\tParser parser;\n+\tParser parser(options);\n \tparser.ParseQuery(mock_query);\n \t// check the statements\n \tif (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT_STATEMENT) {\n@@ -157,11 +158,11 @@ vector<OrderByNode> Parser::ParseOrderList(const string &select_list) {\n }\n \n void Parser::ParseUpdateList(const string &update_list, vector<string> &update_columns,\n-                             vector<unique_ptr<ParsedExpression>> &expressions) {\n+                             vector<unique_ptr<ParsedExpression>> &expressions, ParserOptions options) {\n \t// construct a mock query\n \tstring mock_query = \"UPDATE tbl SET \" + update_list;\n \t// parse the query\n-\tParser parser;\n+\tParser parser(options);\n \tparser.ParseQuery(mock_query);\n \t// check the statements\n \tif (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::UPDATE_STATEMENT) {\n@@ -172,11 +173,11 @@ void Parser::ParseUpdateList(const string &update_list, vector<string> &update_c\n \texpressions = move(update.expressions);\n }\n \n-vector<vector<unique_ptr<ParsedExpression>>> Parser::ParseValuesList(const string &value_list) {\n+vector<vector<unique_ptr<ParsedExpression>>> Parser::ParseValuesList(const string &value_list, ParserOptions options) {\n \t// construct a mock query\n \tstring mock_query = \"VALUES \" + value_list;\n \t// parse the query\n-\tParser parser;\n+\tParser parser(options);\n \tparser.ParseQuery(mock_query);\n \t// check the statements\n \tif (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT_STATEMENT) {\n@@ -194,9 +195,9 @@ vector<vector<unique_ptr<ParsedExpression>>> Parser::ParseValuesList(const strin\n \treturn move(values_list.values);\n }\n \n-vector<ColumnDefinition> Parser::ParseColumnList(const string &column_list) {\n+vector<ColumnDefinition> Parser::ParseColumnList(const string &column_list, ParserOptions options) {\n \tstring mock_query = \"CREATE TABLE blabla (\" + column_list + \")\";\n-\tParser parser;\n+\tParser parser(options);\n \tparser.ParseQuery(mock_query);\n \tif (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::CREATE_STATEMENT) {\n \t\tthrow ParserException(\"Expected a single CREATE statement\");\ndiff --git a/src/planner/binder/expression/bind_comparison_expression.cpp b/src/planner/binder/expression/bind_comparison_expression.cpp\nindex e6368b6d24fb..d7d507de197e 100644\n--- a/src/planner/binder/expression/bind_comparison_expression.cpp\n+++ b/src/planner/binder/expression/bind_comparison_expression.cpp\n@@ -25,6 +25,7 @@ unique_ptr<Expression> ExpressionBinder::PushCollation(ClientContext &context, u\n \t} else {\n \t\tcollation = collation_p;\n \t}\n+\tcollation = StringUtil::Lower(collation);\n \t// bind the collation\n \tif (collation.empty() || collation == \"binary\" || collation == \"c\" || collation == \"posix\") {\n \t\t// binary collation: just skip\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 8729d43b1ee9..6a5b6bfffea7 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -253,7 +253,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {\n \tstatement.select_list = move(new_select_list);\n \n \t// create a mapping of (alias -> index) and a mapping of (Expression -> index) for the SELECT list\n-\tunordered_map<string, idx_t> alias_map;\n+\tcase_insensitive_map_t<idx_t> alias_map;\n \texpression_map_t<idx_t> projection_map;\n \tfor (idx_t i = 0; i < statement.select_list.size(); i++) {\n \t\tauto &expr = statement.select_list[i];\ndiff --git a/src/planner/binder/query_node/bind_setop_node.cpp b/src/planner/binder/query_node/bind_setop_node.cpp\nindex 07f7b33ca7ac..ca634056d0b1 100644\n--- a/src/planner/binder/query_node/bind_setop_node.cpp\n+++ b/src/planner/binder/query_node/bind_setop_node.cpp\n@@ -11,7 +11,7 @@\n \n namespace duckdb {\n \n-static void GatherAliases(BoundQueryNode &node, unordered_map<string, idx_t> &aliases,\n+static void GatherAliases(BoundQueryNode &node, case_insensitive_map_t<idx_t> &aliases,\n                           expression_map_t<idx_t> &expressions) {\n \tif (node.type == QueryNodeType::SET_OPERATION_NODE) {\n \t\t// setop, recurse\n@@ -81,7 +81,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SetOperationNode &statement) {\n \n \t\t// we recursively visit the children of this node to extract aliases and expressions that can be referenced in\n \t\t// the ORDER BY\n-\t\tunordered_map<string, idx_t> alias_map;\n+\t\tcase_insensitive_map_t<idx_t> alias_map;\n \t\texpression_map_t<idx_t> expression_map;\n \t\tGatherAliases(*result, alias_map, expression_map);\n \ndiff --git a/src/planner/binder/statement/bind_insert.cpp b/src/planner/binder/statement/bind_insert.cpp\nindex f4fbd399f9a6..ed3948976a8f 100644\n--- a/src/planner/binder/statement/bind_insert.cpp\n+++ b/src/planner/binder/statement/bind_insert.cpp\n@@ -40,7 +40,7 @@ BoundStatement Binder::Bind(InsertStatement &stmt) {\n \t\t// insertion statement specifies column list\n \n \t\t// create a mapping of (list index) -> (column index)\n-\t\tunordered_map<string, idx_t> column_name_map;\n+\t\tcase_insensitive_map_t<idx_t> column_name_map;\n \t\tfor (idx_t i = 0; i < stmt.columns.size(); i++) {\n \t\t\tcolumn_name_map[stmt.columns[i]] = i;\n \t\t\tauto entry = table->name_map.find(stmt.columns[i]);\ndiff --git a/src/planner/binder/tableref/bind_named_parameters.cpp b/src/planner/binder/tableref/bind_named_parameters.cpp\nindex 0c71e1441ee6..4b50b320c769 100644\n--- a/src/planner/binder/tableref/bind_named_parameters.cpp\n+++ b/src/planner/binder/tableref/bind_named_parameters.cpp\n@@ -2,7 +2,7 @@\n \n namespace duckdb {\n \n-void Binder::BindNamedParameters(unordered_map<string, LogicalType> &types, unordered_map<string, Value> &values,\n+void Binder::BindNamedParameters(named_parameter_type_map_t &types, named_parameter_map_t &values,\n                                  QueryErrorContext &error_context, string &func_name) {\n \tfor (auto &kv : values) {\n \t\tauto entry = types.find(kv.first);\ndiff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp\nindex 95e75a87544d..5f13518e824e 100644\n--- a/src/planner/binder/tableref/bind_table_function.cpp\n+++ b/src/planner/binder/tableref/bind_table_function.cpp\n@@ -17,7 +17,7 @@\n namespace duckdb {\n \n bool Binder::BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,\n-                                    vector<Value> &parameters, unordered_map<string, Value> &named_parameters,\n+                                    vector<Value> &parameters, named_parameter_map_t &named_parameters,\n                                     unique_ptr<BoundSubqueryRef> &subquery, string &error) {\n \tbool seen_subquery = false;\n \tfor (auto &child : expressions) {\n@@ -81,7 +81,7 @@ unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {\n \t// evaluate the input parameters to the function\n \tvector<LogicalType> arguments;\n \tvector<Value> parameters;\n-\tunordered_map<string, Value> named_parameters;\n+\tnamed_parameter_map_t named_parameters;\n \tunique_ptr<BoundSubqueryRef> subquery;\n \tstring error;\n \tif (!BindFunctionParameters(fexpr->children, arguments, parameters, named_parameters, subquery, error)) {\ndiff --git a/src/planner/expression_binder/column_alias_binder.cpp b/src/planner/expression_binder/column_alias_binder.cpp\nindex 31b9c3572f87..090b96309acd 100644\n--- a/src/planner/expression_binder/column_alias_binder.cpp\n+++ b/src/planner/expression_binder/column_alias_binder.cpp\n@@ -6,7 +6,7 @@\n \n namespace duckdb {\n \n-ColumnAliasBinder::ColumnAliasBinder(BoundSelectNode &node, const unordered_map<string, idx_t> &alias_map)\n+ColumnAliasBinder::ColumnAliasBinder(BoundSelectNode &node, const case_insensitive_map_t<idx_t> &alias_map)\n     : node(node), alias_map(alias_map), in_alias(false) {\n }\n \ndiff --git a/src/planner/expression_binder/group_binder.cpp b/src/planner/expression_binder/group_binder.cpp\nindex bc0c65049e9c..ebf981570ed6 100644\n--- a/src/planner/expression_binder/group_binder.cpp\n+++ b/src/planner/expression_binder/group_binder.cpp\n@@ -9,7 +9,7 @@\n namespace duckdb {\n \n GroupBinder::GroupBinder(Binder &binder, ClientContext &context, SelectNode &node, idx_t group_index,\n-                         unordered_map<string, idx_t> &alias_map, unordered_map<string, idx_t> &group_alias_map)\n+                         case_insensitive_map_t<idx_t> &alias_map, case_insensitive_map_t<idx_t> &group_alias_map)\n     : ExpressionBinder(binder, context), node(node), alias_map(alias_map), group_alias_map(group_alias_map),\n       group_index(group_index) {\n }\ndiff --git a/src/planner/expression_binder/having_binder.cpp b/src/planner/expression_binder/having_binder.cpp\nindex 52d9ad69bba3..cdea0b0c2b2e 100644\n--- a/src/planner/expression_binder/having_binder.cpp\n+++ b/src/planner/expression_binder/having_binder.cpp\n@@ -9,7 +9,7 @@\n namespace duckdb {\n \n HavingBinder::HavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,\n-                           unordered_map<string, idx_t> &alias_map)\n+                           case_insensitive_map_t<idx_t> &alias_map)\n     : SelectBinder(binder, context, node, info), column_alias_binder(node, alias_map) {\n \ttarget_type = LogicalType(LogicalTypeId::BOOLEAN);\n }\ndiff --git a/src/planner/expression_binder/order_binder.cpp b/src/planner/expression_binder/order_binder.cpp\nindex 7fc7ec48bab7..d68ef5352b49 100644\n--- a/src/planner/expression_binder/order_binder.cpp\n+++ b/src/planner/expression_binder/order_binder.cpp\n@@ -9,13 +9,13 @@\n \n namespace duckdb {\n \n-OrderBinder::OrderBinder(vector<Binder *> binders, idx_t projection_index, unordered_map<string, idx_t> &alias_map,\n+OrderBinder::OrderBinder(vector<Binder *> binders, idx_t projection_index, case_insensitive_map_t<idx_t> &alias_map,\n                          expression_map_t<idx_t> &projection_map, idx_t max_count)\n     : binders(move(binders)), projection_index(projection_index), max_count(max_count), extra_list(nullptr),\n       alias_map(alias_map), projection_map(projection_map) {\n }\n OrderBinder::OrderBinder(vector<Binder *> binders, idx_t projection_index, SelectNode &node,\n-                         unordered_map<string, idx_t> &alias_map, expression_map_t<idx_t> &projection_map)\n+                         case_insensitive_map_t<idx_t> &alias_map, expression_map_t<idx_t> &projection_map)\n     : binders(move(binders)), projection_index(projection_index), alias_map(alias_map), projection_map(projection_map) {\n \tthis->max_count = node.select_list.size();\n \tthis->extra_list = &node.select_list;\ndiff --git a/src/planner/expression_binder/qualify_binder.cpp b/src/planner/expression_binder/qualify_binder.cpp\nindex 6c51e7e2e13a..09b0d05b966b 100644\n--- a/src/planner/expression_binder/qualify_binder.cpp\n+++ b/src/planner/expression_binder/qualify_binder.cpp\n@@ -9,7 +9,7 @@\n namespace duckdb {\n \n QualifyBinder::QualifyBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,\n-                             unordered_map<string, idx_t> &alias_map)\n+                             case_insensitive_map_t<idx_t> &alias_map)\n     : SelectBinder(binder, context, node, info), column_alias_binder(node, alias_map) {\n \ttarget_type = LogicalType(LogicalTypeId::BOOLEAN);\n }\ndiff --git a/src/planner/pragma_handler.cpp b/src/planner/pragma_handler.cpp\nindex 781304aad3b9..31403cb149bd 100644\n--- a/src/planner/pragma_handler.cpp\n+++ b/src/planner/pragma_handler.cpp\n@@ -28,7 +28,7 @@ void PragmaHandler::HandlePragmaStatementsInternal(vector<unique_ptr<SQLStatemen\n \t\t\tif (!new_query.empty()) {\n \t\t\t\t// this PRAGMA statement gets replaced by a new query string\n \t\t\t\t// push the new query string through the parser again and add it to the transformer\n-\t\t\t\tParser parser;\n+\t\t\t\tParser parser(context.GetParserOptions());\n \t\t\t\tparser.ParseQuery(new_query);\n \t\t\t\t// insert the new statements and remove the old statement\n \t\t\t\t// FIXME: off by one here maybe?\ndiff --git a/third_party/libpg_query/include/parser/scansup.hpp b/third_party/libpg_query/include/parser/scansup.hpp\nindex e86c2de6db5f..4c87ad44e556 100755\n--- a/third_party/libpg_query/include/parser/scansup.hpp\n+++ b/third_party/libpg_query/include/parser/scansup.hpp\n@@ -24,4 +24,7 @@ char *downcase_identifier(const char *ident, int len, bool warn, bool truncate);\n \n bool scanner_isspace(char ch);\n \n+void set_preserve_identifier_case(bool downcase);\n+bool get_preserve_identifier_case();\n+\n }\n\\ No newline at end of file\ndiff --git a/third_party/libpg_query/include/postgres_parser.hpp b/third_party/libpg_query/include/postgres_parser.hpp\nindex a008907ac173..4326d53520bb 100644\n--- a/third_party/libpg_query/include/postgres_parser.hpp\n+++ b/third_party/libpg_query/include/postgres_parser.hpp\n@@ -29,5 +29,8 @@ class PostgresParser {\n \n \tstatic bool IsKeyword(const std::string &text);\n \tstatic std::vector<duckdb_libpgquery::PGKeyword> KeywordList();\n+\n+\tstatic void SetPreserveIdentifierCase(bool downcase);\n };\n+\n }\ndiff --git a/third_party/libpg_query/postgres_parser.cpp b/third_party/libpg_query/postgres_parser.cpp\nindex 1455902001dc..e307403b54f5 100644\n--- a/third_party/libpg_query/postgres_parser.cpp\n+++ b/third_party/libpg_query/postgres_parser.cpp\n@@ -2,6 +2,7 @@\n \n #include \"pg_functions.hpp\"\n #include \"parser/parser.hpp\"\n+#include \"parser/scansup.hpp\"\n #include \"common/keywords.hpp\"\n \n using namespace std;\n@@ -43,4 +44,8 @@ vector<duckdb_libpgquery::PGKeyword> PostgresParser::KeywordList() {\n \treturn duckdb_libpgquery::keyword_list();\n }\n \n+void PostgresParser::SetPreserveIdentifierCase(bool preserve) {\n+\tduckdb_libpgquery::set_preserve_identifier_case(preserve);\n+}\n+\n }\ndiff --git a/third_party/libpg_query/src_backend_parser_scansup.cpp b/third_party/libpg_query/src_backend_parser_scansup.cpp\nindex dfbafc8f6d0c..53cad6693ab6 100755\n--- a/third_party/libpg_query/src_backend_parser_scansup.cpp\n+++ b/third_party/libpg_query/src_backend_parser_scansup.cpp\n@@ -60,6 +60,16 @@ char *downcase_truncate_identifier(const char *ident, int len, bool warn) {\n \treturn downcase_identifier(ident, len, warn, true);\n }\n \n+static __thread bool pg_preserve_identifier_case = false;\n+\n+void set_preserve_identifier_case(bool preserve) {\n+\tpg_preserve_identifier_case = preserve;\n+}\n+\n+bool get_preserve_identifier_case() {\n+\treturn pg_preserve_identifier_case;\n+}\n+\n /*\n  * a workhorse for downcase_truncate_identifier\n  */\n@@ -83,10 +93,12 @@ char *downcase_identifier(const char *ident, int len, bool warn, bool truncate)\n \tfor (i = 0; i < len; i++) {\n \t\tunsigned char ch = (unsigned char)ident[i];\n \n-\t\tif (ch >= 'A' && ch <= 'Z')\n-\t\t\tch += 'a' - 'A';\n-\t\telse if (enc_is_single_byte && IS_HIGHBIT_SET(ch) && isupper(ch))\n-\t\t\tch = tolower(ch);\n+\t\tif (!get_preserve_identifier_case()) {\n+\t\t\tif (ch >= 'A' && ch <= 'Z')\n+\t\t\t\tch += 'a' - 'A';\n+\t\t\telse if (enc_is_single_byte && IS_HIGHBIT_SET(ch) && isupper(ch))\n+\t\t\t\tch = tolower(ch);\n+\t\t}\n \t\tresult[i] = (char)ch;\n \t}\n \tresult[i] = '\\0';\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/map.hpp b/tools/pythonpkg/src/include/duckdb_python/map.hpp\nindex 1ac15d3b3e00..24e5ef47ad8a 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/map.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/map.hpp\n@@ -20,7 +20,7 @@ struct MapFunction : public TableFunction {\n \tMapFunction();\n \n \tstatic unique_ptr<FunctionData> MapFunctionBind(ClientContext &context, vector<Value> &inputs,\n-\t                                                unordered_map<string, Value> &named_parameters,\n+\t                                                named_parameter_map_t &named_parameters,\n \t                                                vector<LogicalType> &input_table_types,\n \t                                                vector<string> &input_table_names,\n \t                                                vector<LogicalType> &return_types, vector<string> &names);\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp b/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp\nindex 40c940d57f33..66c71428c415 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp\n@@ -21,7 +21,7 @@ struct PandasScanFunction : public TableFunction {\n \tPandasScanFunction();\n \n \tstatic unique_ptr<FunctionData> PandasScanBind(ClientContext &context, vector<Value> &inputs,\n-\t                                               unordered_map<string, Value> &named_parameters,\n+\t                                               named_parameter_map_t &named_parameters,\n \t                                               vector<LogicalType> &input_table_types,\n \t                                               vector<string> &input_table_names, vector<LogicalType> &return_types,\n \t                                               vector<string> &names);\ndiff --git a/tools/pythonpkg/src/map.cpp b/tools/pythonpkg/src/map.cpp\nindex 92d0cf607468..67bc847ac794 100644\n--- a/tools/pythonpkg/src/map.cpp\n+++ b/tools/pythonpkg/src/map.cpp\n@@ -44,7 +44,7 @@ static py::handle FunctionCall(NumpyResultConversion &conversion, vector<string>\n // we call the passed function with a zero-row data frame to infer the output columns and their names.\n // they better not change in the actual execution ^^\n unique_ptr<FunctionData> MapFunction::MapFunctionBind(ClientContext &context, vector<Value> &inputs,\n-                                                      unordered_map<string, Value> &named_parameters,\n+                                                      named_parameter_map_t &named_parameters,\n                                                       vector<LogicalType> &input_table_types,\n                                                       vector<string> &input_table_names,\n                                                       vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/tools/pythonpkg/src/pandas_scan.cpp b/tools/pythonpkg/src/pandas_scan.cpp\nindex cc69ea30c557..65df98092fb5 100644\n--- a/tools/pythonpkg/src/pandas_scan.cpp\n+++ b/tools/pythonpkg/src/pandas_scan.cpp\n@@ -53,7 +53,7 @@ PandasScanFunction::PandasScanFunction()\n }\n \n unique_ptr<FunctionData> PandasScanFunction::PandasScanBind(ClientContext &context, vector<Value> &inputs,\n-                                                            unordered_map<string, Value> &named_parameters,\n+                                                            named_parameter_map_t &named_parameters,\n                                                             vector<LogicalType> &input_table_types,\n                                                             vector<string> &input_table_names,\n                                                             vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 730aec967b35..ab0879f7cb16 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -280,7 +280,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromParquet(const string &filen\n \t}\n \tvector<Value> params;\n \tparams.emplace_back(filename);\n-\tunordered_map<string, Value> named_parameters({{\"binary_as_string\", Value::BOOLEAN(binary_as_string)}});\n+\tnamed_parameter_map_t named_parameters({{\"binary_as_string\", Value::BOOLEAN(binary_as_string)}});\n \treturn make_unique<DuckDBPyRelation>(\n \t    connection->TableFunction(\"parquet_scan\", params, named_parameters)->Alias(filename));\n }\ndiff --git a/tools/rpkg/src/scan.cpp b/tools/rpkg/src/scan.cpp\nindex 3eba1ef34637..5563820320fd 100644\n--- a/tools/rpkg/src/scan.cpp\n+++ b/tools/rpkg/src/scan.cpp\n@@ -50,7 +50,7 @@ struct DataFrameScanState : public FunctionOperatorData {\n };\n \n static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> &inputs,\n-                                                    unordered_map<string, Value> &named_parameters,\n+                                                    named_parameter_map_t &named_parameters,\n                                                     vector<LogicalType> &input_table_types,\n                                                     vector<string> &input_table_names,\n                                                     vector<LogicalType> &return_types, vector<string> &names) {\ndiff --git a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\nindex 5c7540a2bac7..8dc55dab12b6 100644\n--- a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n+++ b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n@@ -135,7 +135,7 @@ int sqlite3_prepare_v2(sqlite3 *db,           /* Database handle */\n \t\t*pzTail = zSql + query.size();\n \t}\n \ttry {\n-\t\tParser parser;\n+\t\tParser parser(db->con->context->GetParserOptions());\n \t\tparser.ParseQuery(query);\n \t\tif (parser.statements.size() == 0) {\n \t\t\treturn SQLITE_OK;\n",
  "test_patch": "diff --git a/src/function/table/system/test_all_types.cpp b/src/function/table/system/test_all_types.cpp\nindex fb260416682c..f0ceacdd057c 100644\n--- a/src/function/table/system/test_all_types.cpp\n+++ b/src/function/table/system/test_all_types.cpp\n@@ -166,7 +166,7 @@ static vector<TestType> GetTestTypes() {\n }\n \n static unique_ptr<FunctionData> TestAllTypesBind(ClientContext &context, vector<Value> &inputs,\n-                                                 unordered_map<string, Value> &named_parameters,\n+                                                 named_parameter_map_t &named_parameters,\n                                                  vector<LogicalType> &input_table_types,\n                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,\n                                                  vector<string> &names) {\ndiff --git a/test/optimizer/pushdown/table_or_pushdown.test b/test/optimizer/pushdown/table_or_pushdown.test\nindex 5973db29c9a3..4f3fb0d3cf6d 100644\n--- a/test/optimizer/pushdown/table_or_pushdown.test\n+++ b/test/optimizer/pushdown/table_or_pushdown.test\n@@ -6,7 +6,7 @@ statement ok\n PRAGMA enable_verification\n \n statement ok\n-CREATE TABLE integers AS SELECT a as A, a as B FROM generate_series(1, 5, 1) tbl(a)\n+CREATE TABLE integers AS SELECT a as a, a as b FROM generate_series(1, 5, 1) tbl(a)\n \n #### test OR filters with multiple columns in the root OR, e.g., a=1 OR b=2\n query II\ndiff --git a/test/sql/catalog/case_insensitive_operations.test b/test/sql/catalog/case_insensitive_operations.test\nnew file mode 100644\nindex 000000000000..cdb43f916306\n--- /dev/null\n+++ b/test/sql/catalog/case_insensitive_operations.test\n@@ -0,0 +1,146 @@\n+# name: test/sql/catalog/case_insensitive_operations.test\n+# description: Test case insensitive operations\n+# group: [catalog]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+loop i 0 2\n+\n+statement ok\n+CREATE TABLE INTEGERS(I INTEGER);\n+\n+statement ok\n+INSERT INTO integers (i) VALUES (1), (2), (3), (NULL);\n+\n+query I\n+SELECT integers.i FROM integers ORDER BY i;\n+----\n+NULL\n+1\n+2\n+3\n+\n+query I\n+SELECT integers.i AS i FROM integers GROUP BY I ORDER BY \"integers\".\"I\";\n+----\n+NULL\n+1\n+2\n+3\n+\n+query I\n+SELECT integers.i AS \"ZZZ\" FROM integers GROUP BY \"zzz\" ORDER BY \"INTEGERS\".\"i\";\n+----\n+NULL\n+1\n+2\n+3\n+\n+\n+query I\n+WITH \"CTE\"(\"ZZZ\") AS (\n+\tSELECT integers.i AS \"ZZZ\" FROM integers GROUP BY \"zzz\"\n+)\n+SELECT * FROM cte ORDER BY zZz;\n+----\n+NULL\n+1\n+2\n+3\n+\n+statement error\n+WITH \"CTE\"(\"ZZZ\") AS (\n+\tSELECT integers.i AS \"ZZZ\" FROM integers GROUP BY \"zzz\"\n+),\n+\t\"cte\" AS (SELECT 42)\n+\n+query I\n+UPDATE integers SET i=integers.i+1\n+----\n+4\n+\n+query I\n+SELECT i FROM integers ORDER BY integers.i;\n+----\n+NULL\n+2\n+3\n+4\n+\n+query I\n+DELETE FROM integers WHERE i IS NULL;\n+----\n+1\n+\n+query I\n+SELECT i FROM integers ORDER BY integers.i;\n+----\n+2\n+3\n+4\n+\n+statement ok\n+ALTER TABLE integers ADD COLUMN J INTEGER;\n+\n+query II\n+SELECT i, j FROM integers ORDER BY integers.i;\n+----\n+2\tNULL\n+3\tNULL\n+4\tNULL\n+\n+query I\n+UPDATE integers SET j=integers.i;\n+----\n+3\n+\n+statement ok\n+ALTER TABLE integers DROP COLUMN i;\n+\n+query I\n+SELECT j FROM integers ORDER BY integers.j;\n+----\n+2\n+3\n+4\n+\n+query I\n+SELECT tbl.k FROM (SELECT j FROM integers) TBL(K) ORDER BY K;\n+----\n+2\n+3\n+4\n+\n+statement ok\n+DROP TABLE integers;\n+\n+# structs\n+statement ok\n+CREATE TABLE STRUCTS(S ROW(I ROW(K INTEGER)));\n+\n+statement ok\n+INSERT INTO structs VALUES ({'i': {'k': 42}});\n+\n+query III\n+SELECT structs.S.i.K, \"STRUCTS\".\"S\".\"I\".\"K\", \"structs\".\"s\".\"i\".\"k\" FROM structs\n+----\n+42\t42\t42\n+\n+query I\n+SELECT \"STRUCTS\".\"S\".\"I\".\"K\" FROM structs GROUP BY \"STRUCTS\".\"S\".\"I\".\"K\"\n+----\n+42\n+\n+query I\n+SELECT structs.S.i.K FROM structs GROUP BY structs.S.i.K\n+----\n+42\n+\n+statement ok\n+DROP TABLE structs;\n+\n+statement ok\n+PRAGMA preserve_identifier_case=false;\n+\n+endloop\ndiff --git a/test/sql/collate/test_collate_expression.test b/test/sql/collate/test_collate_expression.test\nindex 29746c26ea07..1c13c18c7811 100644\n--- a/test/sql/collate/test_collate_expression.test\n+++ b/test/sql/collate/test_collate_expression.test\n@@ -13,6 +13,16 @@ SELECT 'h\u00ebllo' COLLATE NOACCENT='hello'\n ----\n 1\n \n+query T\n+SELECT 'h\u00ebllo' COLLATE POSIX='hello'\n+----\n+0\n+\n+query T\n+SELECT 'h\u00ebllo' COLLATE C='hello'\n+----\n+0\n+\n statement ok\n SELECT * FROM collate_test WHERE s='hello'\n \ndiff --git a/test/sql/copy/csv/test_read_csv.test b/test/sql/copy/csv/test_read_csv.test\nindex 36cb9944d92e..9c2f85806a5f 100644\n--- a/test/sql/copy/csv/test_read_csv.test\n+++ b/test/sql/copy/csv/test_read_csv.test\n@@ -10,7 +10,7 @@ statement ok\n CREATE TABLE abac_tbl (a VARCHAR, b VARCHAR, c VARCHAR);\n \n query I\n-INSERT INTO abac_tbl SELECT * FROM read_csv('test/sql/copy/csv/data/abac/abac.csv', columns=STRUCT_PACK(a := 'VARCHAR', b := 'VARCHAR', c := 'VARCHAR'), sep='ABAC', auto_detect='false')\n+INSERT INTO abac_tbl SELECT * FROM read_csv('test/sql/copy/csv/data/abac/abac.csv', COLUMNS=STRUCT_PACK(a := 'VARCHAR', b := 'VARCHAR', c := 'VARCHAR'), sep='ABAC', auto_detect='false')\n ----\n 1\n \ndiff --git a/test/sql/settings/setting_preserve_identifier_case.test b/test/sql/settings/setting_preserve_identifier_case.test\nnew file mode 100644\nindex 000000000000..537a6e2b42e1\n--- /dev/null\n+++ b/test/sql/settings/setting_preserve_identifier_case.test\n@@ -0,0 +1,41 @@\n+# name: test/sql/settings/setting_preserve_identifier_case.test\n+# description: Test preserve_identifier_case setting\n+# group: [settings]\n+\n+query I\n+SELECT value FROM duckdb_settings() WHERE name='preserve_identifier_case'\n+----\n+True\n+\n+statement ok\n+CREATE SCHEMA MYSCHEMA;\n+\n+statement ok\n+CREATE TABLE MYSCHEMA.INTEGERS(I INTEGER);\n+\n+query III\n+SELECT duckdb_tables.schema_name, duckdb_tables.table_name, column_name FROM duckdb_tables JOIN duckdb_columns USING (table_oid);\n+----\n+MYSCHEMA\tINTEGERS\tI\n+\n+statement ok\n+DROP SCHEMA MYSCHEMA CASCADE\n+\n+statement ok\n+SET preserve_identifier_case TO false;\n+\n+query I\n+SELECT value FROM duckdb_settings() WHERE name='preserve_identifier_case'\n+----\n+False\n+\n+statement ok\n+CREATE SCHEMA MYSCHEMA;\n+\n+statement ok\n+CREATE TABLE MYSCHEMA.INTEGERS(I INTEGER);\n+\n+query III\n+SELECT duckdb_tables.schema_name, duckdb_tables.table_name, column_name FROM duckdb_tables JOIN duckdb_columns USING (table_oid);\n+----\n+myschema\tintegers\ti\ndiff --git a/tools/shell/shell-test.py b/tools/shell/shell-test.py\nindex d071836d24a7..8f43e8f147d4 100644\n--- a/tools/shell/shell-test.py\n+++ b/tools/shell/shell-test.py\n@@ -413,14 +413,14 @@ def tf():\n \n # .dump test\n test('''\n-CREATE TABLE a (I INTEGER);\n+CREATE TABLE a (i INTEGER);\n .changes off\n INSERT INTO a VALUES (42);\n .dump\n ''', 'CREATE TABLE a(i INTEGER)')\n \n test('''\n-CREATE TABLE a (I INTEGER);\n+CREATE TABLE a (i INTEGER);\n .changes off\n INSERT INTO a VALUES (42);\n .dump\n@@ -428,7 +428,7 @@ def tf():\n \n # .dump a specific table\n test('''\n-CREATE TABLE a (I INTEGER);\n+CREATE TABLE a (i INTEGER);\n .changes off\n INSERT INTO a VALUES (42);\n .dump a\n@@ -436,7 +436,7 @@ def tf():\n \n # .dump LIKE\n test('''\n-CREATE TABLE a (I INTEGER);\n+CREATE TABLE a (i INTEGER);\n .changes off\n INSERT INTO a VALUES (42);\n .dump a%\n",
  "problem_statement": "No Longer Convert Identifiers to Lower Case?\nA remnant from the Postgres parser is that unquoted identifiers will be automatically converted into lower case, e.g. the following create statements are equivalent\r\n\r\n```sql\r\nCREATE TABLE MyTable(MyColumn INTEGER);\r\nCREATE TABLE \"mytable\"(\"mycolumn\" INTEGER);\r\n```\r\n\r\nWe have added case insensitivity to many areas in the binder (and are adding more #2071), which makes this behavior a lot less annoying to deal with. However, when interfacing with other APIs this case folding might lead to surprising behavior.\r\n\r\nFor example, if we have a query such as this:\r\n\r\n```sql\r\nSELECT MyColumn + 1 AS MyAddition FROM MyTable\r\n```\r\n\r\nAnd then convert the result into e.g. a Pandas DataFrame, or write it to a Parquet file, the column name will be lowercased (to \"myaddition\"). This makes subsequent operations on these external structures rather confusing.\r\n\r\nThe work-around for this is to quote the values, which preserves the case. However, that is not obvious to beginners and probably not what we want to have in the first place.\r\n\r\nPerhaps we should remove this automatic lowercasing of identifiers, as we already handle case-insensitivity at the binder level we don't need to handle it in the parser/transformer.\n",
  "hints_text": "If you end up going this route, I would probably mention it in the release notes! Since Pandas is case sensitive, this could break some scripts.\r\n\r\nPersonally I like the all lowercase lifestyle, but that's me! I understand why you might want to make the change, and that you are still in Beta after all.\n> If you end up going this route, I would probably mention it in the release notes! Since Pandas is case sensitive, this could break some scripts.\r\n\r\nYes, for sure we will have to make this clear in the release notes. The fact that Pandas is case sensitive would actually be one of the main reasons for making this change!\r\n\r\nAnother would be better compatibility with SQLite, since SQLite does maintain the case as described in the query:\r\n\r\n```py\r\n>>> import sqlite3\r\n>>> con = sqlite3.connect(\":memory:\")\r\n>>> c = con.execute('select 42 as MyColumn')\r\n>>> print(c.description)\r\n(('MyColumn', None, None, None, None, None, None),)\r\n>>> pd.read_sql(\"select 42 as MyColumn\", con)\r\n   MyColumn\r\n0        42\r\n```\r\n\r\n> Personally I like the all lowercase lifestyle, but that's me! I understand why you might want to make the change, and that you are still in Beta after all.\r\n\r\nNoted! We are still contemplating whether this change is worthwhile, hence opening this issue to gather some feedback.\r\n\nA few random thoughts.\r\nThis issue made me remember that double quoted identifiers were introduced, not only to allow punctuation characters and spaces, but also to allow entities to have keywords identifiers \u201cMONTH\u201d, \u201dYEAR\u201d\u2026 \r\nWhile is understandable to relax the searching rule for \u201cmyentity\u201d and allow both \u201cmyentity\u201d and myentity to match it, or even MyEntity, it might worth to mention that Firebird uses a different relaxation rule for case insensitivity match. \u201cMYENTITY\u201d (double quoted, uppercased) will be searched using case insensitive match only if is not a keyword, it doesn\u2019t contain spaces or any other non accepted characters for identifiers ($ is accepted in Firebird).\r\nIf we agree that the purpose of `unquoted identifiers will be automatically converted into lower case` is in fact a description for the SQL language case insensitivity behavior \u201cany keyword or entity registered with an unquoted label will be identified/looked up using case insensitive match\" we separate the DuckDB SQL dialect particularities from any external interaction (import, export, libraries or languages). \r\nIMO, any case sensitivity relaxation matching rule you may want to adapt should affect only the DuckDB SQL dialect, it can be even different than SQLite, Postgres or Firebird (not advisable too revolutionary, though \u263a). Any import/export should favor, where possible, the case sensitivity preservation, double quoting entity names where needed. \r\n\nI would support keeping the case with the parser, especially for interoperability with Pandas. To make it backward compatible, maybe this can be introduced as a PRAGMA statement, e.g. `PRAGMA preserve_identifier_case;`.\nAs I think more about this, it may be a better default to carry the capitalization through. However a Pragma to revert to the old way may help!\nI am a new user to DuckDB via R who was surprised by the lowercasing of column names, and found this issue mentioning gathering feedback, so I thought that I should throw in my half-cent of my experience. \r\n\r\nIn my case I am trying to load a lot of data which was output as csv from a SQL server database. The providers gave a SQL server table creation script, so it was simple to adapt that and pass to DuckDB w/ dbExecute, and then use COPY ... FROM csv files w/ dbExecute. However, I was surprised after 2 hours loading my data that all the variables were lowercase, which was difficult to read as the original names were in CapitalCase.\r\n\r\nOverall I've been amazed at how easy it is to get started with DuckDB, thank you! And after reading this issue I think I understand what I should have done (when adapting the SQL server script, I deleted brackets which I should have changed for \"\"). Thanks for your work.\nJust my 2c as a DuckDB user: I've been experimenting with moving an app from SQLite to DuckDB, and ran into this issue.\r\n\r\nIt's not hard to work around, but was surprising to me as a DuckDB beginner FWIW.\nI\u2019m going to work on implementing this, I think it makes sense to do this sooner rather than later.",
  "created_at": "2022-01-13T13:24:14Z"
}