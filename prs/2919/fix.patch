diff --git a/examples/standalone-plan/main.cpp b/examples/standalone-plan/main.cpp
index 4abe05831368..0f4adcff2f52 100644
--- a/examples/standalone-plan/main.cpp
+++ b/examples/standalone-plan/main.cpp
@@ -201,7 +201,7 @@ struct MyBindData : public FunctionData {
 // k: 1, 10, 20
 // (see MyScanNode)
 static unique_ptr<FunctionData> MyScanBind(ClientContext &context, vector<Value> &inputs,
-                                           unordered_map<string, Value> &named_parameters,
+                                           named_parameter_map_t &named_parameters,
                                            vector<LogicalType> &input_table_types, vector<string> &input_table_names,
                                            vector<LogicalType> &return_types, vector<string> &names) {
 	auto table_name = inputs[0].ToString();
diff --git a/extension/icu/icu-extension.cpp b/extension/icu/icu-extension.cpp
index 4500ddd3263d..45097f37f6b4 100644
--- a/extension/icu/icu-extension.cpp
+++ b/extension/icu/icu-extension.cpp
@@ -150,7 +150,7 @@ struct ICUTimeZoneData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> ICUTimeZoneBind(ClientContext &context, vector<Value> &inputs,
-                                                unordered_map<string, Value> &named_parameters,
+                                                named_parameter_map_t &named_parameters,
                                                 vector<LogicalType> &input_table_types,
                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                 vector<string> &names) {
@@ -236,7 +236,7 @@ struct ICUCalendarData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> ICUCalendarBind(ClientContext &context, vector<Value> &inputs,
-                                                unordered_map<string, Value> &named_parameters,
+                                                named_parameter_map_t &named_parameters,
                                                 vector<LogicalType> &input_table_types,
                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                 vector<string> &names) {
diff --git a/extension/parquet/parquet-extension.cpp b/extension/parquet/parquet-extension.cpp
index 982fd25fb498..587dee366813 100644
--- a/extension/parquet/parquet-extension.cpp
+++ b/extension/parquet/parquet-extension.cpp
@@ -196,7 +196,7 @@ class ParquetScanFunction {
 	}
 
 	static unique_ptr<FunctionData> ParquetScanBind(ClientContext &context, vector<Value> &inputs,
-	                                                unordered_map<string, Value> &named_parameters,
+	                                                named_parameter_map_t &named_parameters,
 	                                                vector<LogicalType> &input_table_types,
 	                                                vector<string> &input_table_names,
 	                                                vector<LogicalType> &return_types, vector<string> &names) {
@@ -217,7 +217,7 @@ class ParquetScanFunction {
 	}
 
 	static unique_ptr<FunctionData> ParquetScanBindList(ClientContext &context, vector<Value> &inputs,
-	                                                    unordered_map<string, Value> &named_parameters,
+	                                                    named_parameter_map_t &named_parameters,
 	                                                    vector<LogicalType> &input_table_types,
 	                                                    vector<string> &input_table_names,
 	                                                    vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/extension/parquet/parquet_metadata.cpp b/extension/parquet/parquet_metadata.cpp
index cad9551b6f27..01075e12ee34 100644
--- a/extension/parquet/parquet_metadata.cpp
+++ b/extension/parquet/parquet_metadata.cpp
@@ -385,7 +385,7 @@ void ParquetMetaDataOperatorData::LoadSchemaData(ClientContext &context, const v
 
 template <bool SCHEMA>
 unique_ptr<FunctionData> ParquetMetaDataBind(ClientContext &context, vector<Value> &inputs,
-                                             unordered_map<string, Value> &named_parameters,
+                                             named_parameter_map_t &named_parameters,
                                              vector<LogicalType> &input_table_types, vector<string> &input_table_names,
                                              vector<LogicalType> &return_types, vector<string> &names) {
 	auto &config = DBConfig::GetConfig(context);
diff --git a/extension/tpcds/tpcds-extension.cpp b/extension/tpcds/tpcds-extension.cpp
index 5cafd2accbb1..9bd06de285cc 100644
--- a/extension/tpcds/tpcds-extension.cpp
+++ b/extension/tpcds/tpcds-extension.cpp
@@ -28,7 +28,7 @@ struct DSDGenFunctionData : public TableFunctionData {
 };
 
 static unique_ptr<FunctionData> DsdgenBind(ClientContext &context, vector<Value> &inputs,
-                                           unordered_map<string, Value> &named_parameters,
+                                           named_parameter_map_t &named_parameters,
                                            vector<LogicalType> &input_table_types, vector<string> &input_table_names,
                                            vector<LogicalType> &return_types, vector<string> &names) {
 	auto result = make_unique<DSDGenFunctionData>();
@@ -75,7 +75,7 @@ unique_ptr<FunctionOperatorData> TPCDSInit(ClientContext &context, const Functio
 }
 
 static unique_ptr<FunctionData> TPCDSQueryBind(ClientContext &context, vector<Value> &inputs,
-                                               unordered_map<string, Value> &named_parameters,
+                                               named_parameter_map_t &named_parameters,
                                                vector<LogicalType> &input_table_types,
                                                vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                vector<string> &names) {
@@ -110,7 +110,7 @@ static void TPCDSQueryFunction(ClientContext &context, const FunctionData *bind_
 }
 
 static unique_ptr<FunctionData> TPCDSQueryAnswerBind(ClientContext &context, vector<Value> &inputs,
-                                                     unordered_map<string, Value> &named_parameters,
+                                                     named_parameter_map_t &named_parameters,
                                                      vector<LogicalType> &input_table_types,
                                                      vector<string> &input_table_names,
                                                      vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/extension/tpch/tpch-extension.cpp b/extension/tpch/tpch-extension.cpp
index 97bbeef63278..732f2e870a4a 100644
--- a/extension/tpch/tpch-extension.cpp
+++ b/extension/tpch/tpch-extension.cpp
@@ -27,7 +27,7 @@ struct DBGenFunctionData : public TableFunctionData {
 };
 
 static unique_ptr<FunctionData> DbgenBind(ClientContext &context, vector<Value> &inputs,
-                                          unordered_map<string, Value> &named_parameters,
+                                          named_parameter_map_t &named_parameters,
                                           vector<LogicalType> &input_table_types, vector<string> &input_table_names,
                                           vector<LogicalType> &return_types, vector<string> &names) {
 	auto result = make_unique<DBGenFunctionData>();
@@ -72,7 +72,7 @@ unique_ptr<FunctionOperatorData> TPCHInit(ClientContext &context, const Function
 }
 
 static unique_ptr<FunctionData> TPCHQueryBind(ClientContext &context, vector<Value> &inputs,
-                                              unordered_map<string, Value> &named_parameters,
+                                              named_parameter_map_t &named_parameters,
                                               vector<LogicalType> &input_table_types, vector<string> &input_table_names,
                                               vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("query_nr");
@@ -106,7 +106,7 @@ static void TPCHQueryFunction(ClientContext &context, const FunctionData *bind_d
 }
 
 static unique_ptr<FunctionData> TPCHQueryAnswerBind(ClientContext &context, vector<Value> &inputs,
-                                                    unordered_map<string, Value> &named_parameters,
+                                                    named_parameter_map_t &named_parameters,
                                                     vector<LogicalType> &input_table_types,
                                                     vector<string> &input_table_names,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/execution/operator/persistent/buffered_csv_reader.cpp b/src/execution/operator/persistent/buffered_csv_reader.cpp
index 200dc2807326..4b1586d8c024 100644
--- a/src/execution/operator/persistent/buffered_csv_reader.cpp
+++ b/src/execution/operator/persistent/buffered_csv_reader.cpp
@@ -921,7 +921,7 @@ void BufferedCSVReader::DetectHeader(const vector<vector<LogicalType>> &best_sql
 	// update parser info, and read, generate & set col_names based on previous findings
 	if (((!first_row_consistent || first_row_nulls) && !options.has_header) || (options.has_header && options.header)) {
 		options.header = true;
-		unordered_map<string, idx_t> name_collision_count;
+		case_insensitive_map_t<idx_t> name_collision_count;
 		// get header names from CSV
 		for (idx_t col = 0; col < options.num_cols; col++) {
 			const auto &val = best_header_row.GetValue(col, 0);
diff --git a/src/function/function.cpp b/src/function/function.cpp
index c2b25e854746..40574a9f2237 100644
--- a/src/function/function.cpp
+++ b/src/function/function.cpp
@@ -208,7 +208,7 @@ string Function::CallToString(const string &name, const vector<LogicalType> &arg
 }
 
 string Function::CallToString(const string &name, const vector<LogicalType> &arguments,
-                              const unordered_map<string, LogicalType> &named_parameters) {
+                              const named_parameter_type_map_t &named_parameters) {
 	vector<string> input_arguments;
 	input_arguments.reserve(arguments.size() + named_parameters.size());
 	for (auto &arg : arguments) {
diff --git a/src/function/table/arrow.cpp b/src/function/table/arrow.cpp
index 2f6eca7f0f2c..2586a381fbfc 100644
--- a/src/function/table/arrow.cpp
+++ b/src/function/table/arrow.cpp
@@ -161,7 +161,7 @@ LogicalType GetArrowLogicalType(ArrowSchema &schema,
 }
 
 unique_ptr<FunctionData> ArrowTableFunction::ArrowScanBind(ClientContext &context, vector<Value> &inputs,
-                                                           unordered_map<string, Value> &named_parameters,
+                                                           named_parameter_map_t &named_parameters,
                                                            vector<LogicalType> &input_table_types,
                                                            vector<string> &input_table_names,
                                                            vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/function/table/checkpoint.cpp b/src/function/table/checkpoint.cpp
index 8f9712794979..a3a18964cf01 100644
--- a/src/function/table/checkpoint.cpp
+++ b/src/function/table/checkpoint.cpp
@@ -6,7 +6,7 @@
 namespace duckdb {
 
 static unique_ptr<FunctionData> CheckpointBind(ClientContext &context, vector<Value> &inputs,
-                                               unordered_map<string, Value> &named_parameters,
+                                               named_parameter_map_t &named_parameters,
                                                vector<LogicalType> &input_table_types,
                                                vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                vector<string> &names) {
diff --git a/src/function/table/glob.cpp b/src/function/table/glob.cpp
index 687e0795f0d1..3cb796cb317c 100644
--- a/src/function/table/glob.cpp
+++ b/src/function/table/glob.cpp
@@ -11,7 +11,7 @@ struct GlobFunctionBindData : public TableFunctionData {
 };
 
 static unique_ptr<FunctionData> GlobFunctionBind(ClientContext &context, vector<Value> &inputs,
-                                                 unordered_map<string, Value> &named_parameters,
+                                                 named_parameter_map_t &named_parameters,
                                                  vector<LogicalType> &input_table_types,
                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                  vector<string> &names) {
diff --git a/src/function/table/pragma_detailed_profiling_output.cpp b/src/function/table/pragma_detailed_profiling_output.cpp
index 74af651055fc..87620c9e9dfd 100644
--- a/src/function/table/pragma_detailed_profiling_output.cpp
+++ b/src/function/table/pragma_detailed_profiling_output.cpp
@@ -22,7 +22,7 @@ struct PragmaDetailedProfilingOutputData : public TableFunctionData {
 };
 
 static unique_ptr<FunctionData> PragmaDetailedProfilingOutputBind(ClientContext &context, vector<Value> &inputs,
-                                                                  unordered_map<string, Value> &named_parameters,
+                                                                  named_parameter_map_t &named_parameters,
                                                                   vector<LogicalType> &input_table_types,
                                                                   vector<string> &input_table_names,
                                                                   vector<LogicalType> &return_types,
diff --git a/src/function/table/pragma_last_profiling_output.cpp b/src/function/table/pragma_last_profiling_output.cpp
index eb15716da807..67d863371d3a 100644
--- a/src/function/table/pragma_last_profiling_output.cpp
+++ b/src/function/table/pragma_last_profiling_output.cpp
@@ -22,12 +22,10 @@ struct PragmaLastProfilingOutputData : public TableFunctionData {
 	vector<LogicalType> types;
 };
 
-static unique_ptr<FunctionData> PragmaLastProfilingOutputBind(ClientContext &context, vector<Value> &inputs,
-                                                              unordered_map<string, Value> &named_parameters,
-                                                              vector<LogicalType> &input_table_types,
-                                                              vector<string> &input_table_names,
-                                                              vector<LogicalType> &return_types,
-                                                              vector<string> &names) {
+static unique_ptr<FunctionData>
+PragmaLastProfilingOutputBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,
+                              vector<LogicalType> &input_table_types, vector<string> &input_table_names,
+                              vector<LogicalType> &return_types, vector<string> &names) {
 	names.emplace_back("OPERATOR_ID");
 	return_types.emplace_back(LogicalType::INTEGER);
 
diff --git a/src/function/table/range.cpp b/src/function/table/range.cpp
index 17d94167dd6c..ad6f66ecf5ba 100644
--- a/src/function/table/range.cpp
+++ b/src/function/table/range.cpp
@@ -18,7 +18,7 @@ struct RangeFunctionBindData : public TableFunctionData {
 
 template <bool GENERATE_SERIES>
 static unique_ptr<FunctionData>
-RangeFunctionBind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
+RangeFunctionBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,
                   vector<LogicalType> &input_table_types, vector<string> &input_table_names,
                   vector<LogicalType> &return_types, vector<string> &names) {
 	auto result = make_unique<RangeFunctionBindData>();
@@ -129,7 +129,7 @@ struct RangeDateTimeBindData : public TableFunctionData {
 
 template <bool GENERATE_SERIES>
 static unique_ptr<FunctionData>
-RangeDateTimeBind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
+RangeDateTimeBind(ClientContext &context, vector<Value> &inputs, named_parameter_map_t &named_parameters,
                   vector<LogicalType> &input_table_types, vector<string> &input_table_names,
                   vector<LogicalType> &return_types, vector<string> &names) {
 	auto result = make_unique<RangeDateTimeBindData>();
diff --git a/src/function/table/read_csv.cpp b/src/function/table/read_csv.cpp
index 1c2cc238e5b6..e70dd6341d92 100644
--- a/src/function/table/read_csv.cpp
+++ b/src/function/table/read_csv.cpp
@@ -15,7 +15,7 @@
 namespace duckdb {
 
 static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value> &inputs,
-                                            unordered_map<string, Value> &named_parameters,
+                                            named_parameter_map_t &named_parameters,
                                             vector<LogicalType> &input_table_types, vector<string> &input_table_names,
                                             vector<LogicalType> &return_types, vector<string> &names) {
 	auto &config = DBConfig::GetConfig(context);
@@ -34,22 +34,23 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value
 	}
 
 	for (auto &kv : named_parameters) {
-		if (kv.first == "auto_detect") {
+		auto loption = StringUtil::Lower(kv.first);
+		if (loption == "auto_detect") {
 			options.auto_detect = BooleanValue::Get(kv.second);
-		} else if (kv.first == "sep" || kv.first == "delim") {
+		} else if (loption == "sep" || loption == "delim") {
 			options.SetDelimiter(StringValue::Get(kv.second));
-		} else if (kv.first == "header") {
+		} else if (loption == "header") {
 			options.header = BooleanValue::Get(kv.second);
 			options.has_header = true;
-		} else if (kv.first == "quote") {
+		} else if (loption == "quote") {
 			options.quote = StringValue::Get(kv.second);
 			options.has_quote = true;
-		} else if (kv.first == "escape") {
+		} else if (loption == "escape") {
 			options.escape = StringValue::Get(kv.second);
 			options.has_escape = true;
-		} else if (kv.first == "nullstr") {
+		} else if (loption == "nullstr") {
 			options.null_str = StringValue::Get(kv.second);
-		} else if (kv.first == "sample_size") {
+		} else if (loption == "sample_size") {
 			int64_t sample_size = kv.second.GetValue<int64_t>();
 			if (sample_size < 1 && sample_size != -1) {
 				throw BinderException("Unsupported parameter for SAMPLE_SIZE: cannot be smaller than 1");
@@ -64,7 +65,7 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value
 				options.sample_chunk_size = STANDARD_VECTOR_SIZE;
 				options.sample_chunks = sample_size / STANDARD_VECTOR_SIZE;
 			}
-		} else if (kv.first == "sample_chunk_size") {
+		} else if (loption == "sample_chunk_size") {
 			options.sample_chunk_size = kv.second.GetValue<int64_t>();
 			if (options.sample_chunk_size > STANDARD_VECTOR_SIZE) {
 				throw BinderException(
@@ -73,14 +74,14 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value
 			} else if (options.sample_chunk_size < 1) {
 				throw BinderException("Unsupported parameter for SAMPLE_CHUNK_SIZE: cannot be smaller than 1");
 			}
-		} else if (kv.first == "sample_chunks") {
+		} else if (loption == "sample_chunks") {
 			options.sample_chunks = kv.second.GetValue<int64_t>();
 			if (options.sample_chunks < 1) {
 				throw BinderException("Unsupported parameter for SAMPLE_CHUNKS: cannot be smaller than 1");
 			}
-		} else if (kv.first == "all_varchar") {
+		} else if (loption == "all_varchar") {
 			options.all_varchar = BooleanValue::Get(kv.second);
-		} else if (kv.first == "dateformat") {
+		} else if (loption == "dateformat") {
 			options.has_format[LogicalTypeId::DATE] = true;
 			auto &date_format = options.date_format[LogicalTypeId::DATE];
 			date_format.format_specifier = StringValue::Get(kv.second);
@@ -88,7 +89,7 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value
 			if (!error.empty()) {
 				throw InvalidInputException("Could not parse DATEFORMAT: %s", error.c_str());
 			}
-		} else if (kv.first == "timestampformat") {
+		} else if (loption == "timestampformat") {
 			options.has_format[LogicalTypeId::TIMESTAMP] = true;
 			auto &timestamp_format = options.date_format[LogicalTypeId::TIMESTAMP];
 			timestamp_format.format_specifier = StringValue::Get(kv.second);
@@ -96,9 +97,9 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value
 			if (!error.empty()) {
 				throw InvalidInputException("Could not parse TIMESTAMPFORMAT: %s", error.c_str());
 			}
-		} else if (kv.first == "normalize_names") {
+		} else if (loption == "normalize_names") {
 			options.normalize_names = BooleanValue::Get(kv.second);
-		} else if (kv.first == "columns") {
+		} else if (loption == "columns") {
 			auto &child_type = kv.second.type();
 			if (child_type.id() != LogicalTypeId::STRUCT) {
 				throw BinderException("read_csv columns requires a a struct as input");
@@ -117,12 +118,14 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value
 			if (names.empty()) {
 				throw BinderException("read_csv requires at least a single column as input!");
 			}
-		} else if (kv.first == "compression") {
+		} else if (loption == "compression") {
 			options.compression = FileCompressionTypeFromString(StringValue::Get(kv.second));
-		} else if (kv.first == "filename") {
+		} else if (loption == "filename") {
 			result->include_file_name = BooleanValue::Get(kv.second);
-		} else if (kv.first == "skip") {
+		} else if (loption == "skip") {
 			options.skip_rows = kv.second.GetValue<int64_t>();
+		} else {
+			throw InternalException("Unrecognized parameter %s", kv.first);
 		}
 	}
 	if (!options.auto_detect && return_types.empty()) {
@@ -176,7 +179,7 @@ static unique_ptr<FunctionOperatorData> ReadCSVInit(ClientContext &context, cons
 }
 
 static unique_ptr<FunctionData> ReadCSVAutoBind(ClientContext &context, vector<Value> &inputs,
-                                                unordered_map<string, Value> &named_parameters,
+                                                named_parameter_map_t &named_parameters,
                                                 vector<LogicalType> &input_table_types,
                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                 vector<string> &names) {
diff --git a/src/function/table/repeat.cpp b/src/function/table/repeat.cpp
index 4b3e0fe6bcf6..933e0deefb18 100644
--- a/src/function/table/repeat.cpp
+++ b/src/function/table/repeat.cpp
@@ -18,7 +18,7 @@ struct RepeatOperatorData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> RepeatBind(ClientContext &context, vector<Value> &inputs,
-                                           unordered_map<string, Value> &named_parameters,
+                                           named_parameter_map_t &named_parameters,
                                            vector<LogicalType> &input_table_types, vector<string> &input_table_names,
                                            vector<LogicalType> &return_types, vector<string> &names) {
 	// the repeat function returns the type of the first argument
diff --git a/src/function/table/summary.cpp b/src/function/table/summary.cpp
index 436cb9ce2cf7..eb8bf1189753 100644
--- a/src/function/table/summary.cpp
+++ b/src/function/table/summary.cpp
@@ -8,7 +8,7 @@
 namespace duckdb {
 
 static unique_ptr<FunctionData> SummaryFunctionBind(ClientContext &context, vector<Value> &inputs,
-                                                    unordered_map<string, Value> &named_parameters,
+                                                    named_parameter_map_t &named_parameters,
                                                     vector<LogicalType> &input_table_types,
                                                     vector<string> &input_table_names,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/function/table/system/duckdb_columns.cpp b/src/function/table/system/duckdb_columns.cpp
index 78a43da87d31..295cf271c478 100644
--- a/src/function/table/system/duckdb_columns.cpp
+++ b/src/function/table/system/duckdb_columns.cpp
@@ -21,7 +21,7 @@ struct DuckDBColumnsData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBColumnsBind(ClientContext &context, vector<Value> &inputs,
-                                                  unordered_map<string, Value> &named_parameters,
+                                                  named_parameter_map_t &named_parameters,
                                                   vector<LogicalType> &input_table_types,
                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                   vector<string> &names) {
diff --git a/src/function/table/system/duckdb_constraints.cpp b/src/function/table/system/duckdb_constraints.cpp
index 1b28bc88e10c..44570465b24c 100644
--- a/src/function/table/system/duckdb_constraints.cpp
+++ b/src/function/table/system/duckdb_constraints.cpp
@@ -25,7 +25,7 @@ struct DuckDBConstraintsData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBConstraintsBind(ClientContext &context, vector<Value> &inputs,
-                                                      unordered_map<string, Value> &named_parameters,
+                                                      named_parameter_map_t &named_parameters,
                                                       vector<LogicalType> &input_table_types,
                                                       vector<string> &input_table_names,
                                                       vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/function/table/system/duckdb_dependencies.cpp b/src/function/table/system/duckdb_dependencies.cpp
index ed6f5b680d3b..281f52361619 100644
--- a/src/function/table/system/duckdb_dependencies.cpp
+++ b/src/function/table/system/duckdb_dependencies.cpp
@@ -22,7 +22,7 @@ struct DuckDBDependenciesData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBDependenciesBind(ClientContext &context, vector<Value> &inputs,
-                                                       unordered_map<string, Value> &named_parameters,
+                                                       named_parameter_map_t &named_parameters,
                                                        vector<LogicalType> &input_table_types,
                                                        vector<string> &input_table_names,
                                                        vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/function/table/system/duckdb_functions.cpp b/src/function/table/system/duckdb_functions.cpp
index c575e43e5577..8b9b38030f8b 100644
--- a/src/function/table/system/duckdb_functions.cpp
+++ b/src/function/table/system/duckdb_functions.cpp
@@ -22,7 +22,7 @@ struct DuckDBFunctionsData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBFunctionsBind(ClientContext &context, vector<Value> &inputs,
-                                                    unordered_map<string, Value> &named_parameters,
+                                                    named_parameter_map_t &named_parameters,
                                                     vector<LogicalType> &input_table_types,
                                                     vector<string> &input_table_names,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/function/table/system/duckdb_indexes.cpp b/src/function/table/system/duckdb_indexes.cpp
index 36a18038e30e..3f70e2b1ea13 100644
--- a/src/function/table/system/duckdb_indexes.cpp
+++ b/src/function/table/system/duckdb_indexes.cpp
@@ -19,7 +19,7 @@ struct DuckDBIndexesData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBIndexesBind(ClientContext &context, vector<Value> &inputs,
-                                                  unordered_map<string, Value> &named_parameters,
+                                                  named_parameter_map_t &named_parameters,
                                                   vector<LogicalType> &input_table_types,
                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                   vector<string> &names) {
diff --git a/src/function/table/system/duckdb_keywords.cpp b/src/function/table/system/duckdb_keywords.cpp
index 460e41aac595..bf60bcf6aff9 100644
--- a/src/function/table/system/duckdb_keywords.cpp
+++ b/src/function/table/system/duckdb_keywords.cpp
@@ -15,7 +15,7 @@ struct DuckDBKeywordsData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBKeywordsBind(ClientContext &context, vector<Value> &inputs,
-                                                   unordered_map<string, Value> &named_parameters,
+                                                   named_parameter_map_t &named_parameters,
                                                    vector<LogicalType> &input_table_types,
                                                    vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                    vector<string> &names) {
diff --git a/src/function/table/system/duckdb_schemas.cpp b/src/function/table/system/duckdb_schemas.cpp
index d6b069d6cdd4..8ed9495d9dee 100644
--- a/src/function/table/system/duckdb_schemas.cpp
+++ b/src/function/table/system/duckdb_schemas.cpp
@@ -16,7 +16,7 @@ struct DuckDBSchemasData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBSchemasBind(ClientContext &context, vector<Value> &inputs,
-                                                  unordered_map<string, Value> &named_parameters,
+                                                  named_parameter_map_t &named_parameters,
                                                   vector<LogicalType> &input_table_types,
                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                   vector<string> &names) {
diff --git a/src/function/table/system/duckdb_sequences.cpp b/src/function/table/system/duckdb_sequences.cpp
index 182fe70f305c..46b9bd0cd387 100644
--- a/src/function/table/system/duckdb_sequences.cpp
+++ b/src/function/table/system/duckdb_sequences.cpp
@@ -17,7 +17,7 @@ struct DuckDBSequencesData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBSequencesBind(ClientContext &context, vector<Value> &inputs,
-                                                    unordered_map<string, Value> &named_parameters,
+                                                    named_parameter_map_t &named_parameters,
                                                     vector<LogicalType> &input_table_types,
                                                     vector<string> &input_table_names,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/function/table/system/duckdb_settings.cpp b/src/function/table/system/duckdb_settings.cpp
index d36d4a3fd757..9793d393f148 100644
--- a/src/function/table/system/duckdb_settings.cpp
+++ b/src/function/table/system/duckdb_settings.cpp
@@ -21,7 +21,7 @@ struct DuckDBSettingsData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBSettingsBind(ClientContext &context, vector<Value> &inputs,
-                                                   unordered_map<string, Value> &named_parameters,
+                                                   named_parameter_map_t &named_parameters,
                                                    vector<LogicalType> &input_table_types,
                                                    vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                    vector<string> &names) {
diff --git a/src/function/table/system/duckdb_tables.cpp b/src/function/table/system/duckdb_tables.cpp
index 9a0842cde13e..7f96ac432f50 100644
--- a/src/function/table/system/duckdb_tables.cpp
+++ b/src/function/table/system/duckdb_tables.cpp
@@ -20,7 +20,7 @@ struct DuckDBTablesData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBTablesBind(ClientContext &context, vector<Value> &inputs,
-                                                 unordered_map<string, Value> &named_parameters,
+                                                 named_parameter_map_t &named_parameters,
                                                  vector<LogicalType> &input_table_types,
                                                  vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                  vector<string> &names) {
diff --git a/src/function/table/system/duckdb_types.cpp b/src/function/table/system/duckdb_types.cpp
index 37959e3ac0e6..8beb5ef94c0f 100644
--- a/src/function/table/system/duckdb_types.cpp
+++ b/src/function/table/system/duckdb_types.cpp
@@ -17,7 +17,7 @@ struct DuckDBTypesData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBTypesBind(ClientContext &context, vector<Value> &inputs,
-                                                unordered_map<string, Value> &named_parameters,
+                                                named_parameter_map_t &named_parameters,
                                                 vector<LogicalType> &input_table_types,
                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                 vector<string> &names) {
diff --git a/src/function/table/system/duckdb_views.cpp b/src/function/table/system/duckdb_views.cpp
index c879747af02a..05ec83c76281 100644
--- a/src/function/table/system/duckdb_views.cpp
+++ b/src/function/table/system/duckdb_views.cpp
@@ -17,7 +17,7 @@ struct DuckDBViewsData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> DuckDBViewsBind(ClientContext &context, vector<Value> &inputs,
-                                                unordered_map<string, Value> &named_parameters,
+                                                named_parameter_map_t &named_parameters,
                                                 vector<LogicalType> &input_table_types,
                                                 vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                 vector<string> &names) {
diff --git a/src/function/table/system/pragma_collations.cpp b/src/function/table/system/pragma_collations.cpp
index efa76f5e5771..cdf19ef7cfb8 100644
--- a/src/function/table/system/pragma_collations.cpp
+++ b/src/function/table/system/pragma_collations.cpp
@@ -16,7 +16,7 @@ struct PragmaCollateData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> PragmaCollateBind(ClientContext &context, vector<Value> &inputs,
-                                                  unordered_map<string, Value> &named_parameters,
+                                                  named_parameter_map_t &named_parameters,
                                                   vector<LogicalType> &input_table_types,
                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                   vector<string> &names) {
diff --git a/src/function/table/system/pragma_database_list.cpp b/src/function/table/system/pragma_database_list.cpp
index 6869b0a745d0..d94cf039638d 100644
--- a/src/function/table/system/pragma_database_list.cpp
+++ b/src/function/table/system/pragma_database_list.cpp
@@ -12,7 +12,7 @@ struct PragmaDatabaseListData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> PragmaDatabaseListBind(ClientContext &context, vector<Value> &inputs,
-                                                       unordered_map<string, Value> &named_parameters,
+                                                       named_parameter_map_t &named_parameters,
                                                        vector<LogicalType> &input_table_types,
                                                        vector<string> &input_table_names,
                                                        vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/function/table/system/pragma_database_size.cpp b/src/function/table/system/pragma_database_size.cpp
index 8898a139670a..c16bfa2ec1c4 100644
--- a/src/function/table/system/pragma_database_size.cpp
+++ b/src/function/table/system/pragma_database_size.cpp
@@ -16,7 +16,7 @@ struct PragmaDatabaseSizeData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> PragmaDatabaseSizeBind(ClientContext &context, vector<Value> &inputs,
-                                                       unordered_map<string, Value> &named_parameters,
+                                                       named_parameter_map_t &named_parameters,
                                                        vector<LogicalType> &input_table_types,
                                                        vector<string> &input_table_names,
                                                        vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/function/table/system/pragma_functions.cpp b/src/function/table/system/pragma_functions.cpp
index 30bfcf97525c..39f69d0eb632 100644
--- a/src/function/table/system/pragma_functions.cpp
+++ b/src/function/table/system/pragma_functions.cpp
@@ -19,7 +19,7 @@ struct PragmaFunctionsData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> PragmaFunctionsBind(ClientContext &context, vector<Value> &inputs,
-                                                    unordered_map<string, Value> &named_parameters,
+                                                    named_parameter_map_t &named_parameters,
                                                     vector<LogicalType> &input_table_types,
                                                     vector<string> &input_table_names,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/function/table/system/pragma_storage_info.cpp b/src/function/table/system/pragma_storage_info.cpp
index a9cd03641040..563b3ef22448 100644
--- a/src/function/table/system/pragma_storage_info.cpp
+++ b/src/function/table/system/pragma_storage_info.cpp
@@ -31,7 +31,7 @@ struct PragmaStorageOperatorData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> PragmaStorageInfoBind(ClientContext &context, vector<Value> &inputs,
-                                                      unordered_map<string, Value> &named_parameters,
+                                                      named_parameter_map_t &named_parameters,
                                                       vector<LogicalType> &input_table_types,
                                                       vector<string> &input_table_names,
                                                       vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/function/table/system/pragma_table_info.cpp b/src/function/table/system/pragma_table_info.cpp
index 33112078302a..e022f02e5820 100644
--- a/src/function/table/system/pragma_table_info.cpp
+++ b/src/function/table/system/pragma_table_info.cpp
@@ -28,7 +28,7 @@ struct PragmaTableOperatorData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> PragmaTableInfoBind(ClientContext &context, vector<Value> &inputs,
-                                                    unordered_map<string, Value> &named_parameters,
+                                                    named_parameter_map_t &named_parameters,
                                                     vector<LogicalType> &input_table_types,
                                                     vector<string> &input_table_names,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/src/function/table/unnest.cpp b/src/function/table/unnest.cpp
index 296c85e620f9..6786427462c5 100644
--- a/src/function/table/unnest.cpp
+++ b/src/function/table/unnest.cpp
@@ -18,7 +18,7 @@ struct UnnestOperatorData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> UnnestBind(ClientContext &context, vector<Value> &inputs,
-                                           unordered_map<string, Value> &named_parameters,
+                                           named_parameter_map_t &named_parameters,
                                            vector<LogicalType> &input_table_types, vector<string> &input_table_names,
                                            vector<LogicalType> &return_types, vector<string> &names) {
 	return_types.push_back(ListType::GetChildType(inputs[0].type()));
diff --git a/src/function/table/version/pragma_version.cpp b/src/function/table/version/pragma_version.cpp
index 7d7ef3cc35a4..9674327d2210 100644
--- a/src/function/table/version/pragma_version.cpp
+++ b/src/function/table/version/pragma_version.cpp
@@ -10,7 +10,7 @@ struct PragmaVersionData : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> PragmaVersionBind(ClientContext &context, vector<Value> &inputs,
-                                                  unordered_map<string, Value> &named_parameters,
+                                                  named_parameter_map_t &named_parameters,
                                                   vector<LogicalType> &input_table_types,
                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,
                                                   vector<string> &names) {
diff --git a/src/include/duckdb/common/named_parameter_map.hpp b/src/include/duckdb/common/named_parameter_map.hpp
new file mode 100644
index 000000000000..b39e81e11dc1
--- /dev/null
+++ b/src/include/duckdb/common/named_parameter_map.hpp
@@ -0,0 +1,18 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// duckdb/common/named_parameter_map.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include "duckdb/common/case_insensitive_map.hpp"
+#include "duckdb/common/types.hpp"
+namespace duckdb {
+
+using named_parameter_type_map_t = case_insensitive_map_t<LogicalType>;
+using named_parameter_map_t = case_insensitive_map_t<Value>;
+
+} // namespace duckdb
diff --git a/src/include/duckdb/function/function.hpp b/src/include/duckdb/function/function.hpp
index 0e8ac7428a59..3ea976332622 100644
--- a/src/include/duckdb/function/function.hpp
+++ b/src/include/duckdb/function/function.hpp
@@ -9,7 +9,7 @@
 #pragma once
 
 #include "duckdb/common/types/data_chunk.hpp"
-#include "duckdb/common/unordered_map.hpp"
+#include "duckdb/common/named_parameter_map.hpp"
 #include "duckdb/common/unordered_set.hpp"
 #include "duckdb/parser/column_definition.hpp"
 
@@ -47,7 +47,7 @@ struct TableFunctionData : public FunctionData {
 
 struct FunctionParameters {
 	vector<Value> values;
-	unordered_map<string, Value> named_parameters;
+	named_parameter_map_t named_parameters;
 };
 
 //! Function is the base class used for any type of function (scalar, aggregate or simple function)
@@ -67,7 +67,7 @@ class Function {
 	                                      const LogicalType &return_type);
 	//! Returns the formatted string name(arg1, arg2.., np1=a, np2=b, ...)
 	DUCKDB_API static string CallToString(const string &name, const vector<LogicalType> &arguments,
-	                                      const unordered_map<string, LogicalType> &named_parameters);
+	                                      const named_parameter_type_map_t &named_parameters);
 
 	//! Bind a scalar function from the set of functions and input arguments. Returns the index of the chosen function,
 	//! returns DConstants::INVALID_INDEX and sets error if none could be found
@@ -117,14 +117,14 @@ class SimpleNamedParameterFunction : public SimpleFunction {
 	DUCKDB_API ~SimpleNamedParameterFunction() override;
 
 	//! The named parameters of the function
-	unordered_map<string, LogicalType> named_parameters;
+	named_parameter_type_map_t named_parameters;
 
 public:
 	DUCKDB_API string ToString() override;
 	DUCKDB_API bool HasNamedParameters();
 
 	DUCKDB_API void EvaluateInputParameters(vector<LogicalType> &arguments, vector<Value> &parameters,
-	                                        unordered_map<string, Value> &named_parameters,
+	                                        named_parameter_map_t &named_parameters,
 	                                        vector<unique_ptr<ParsedExpression>> &children);
 };
 
diff --git a/src/include/duckdb/function/pragma_function.hpp b/src/include/duckdb/function/pragma_function.hpp
index a68a4a217c29..1fcf342bbb86 100644
--- a/src/include/duckdb/function/pragma_function.hpp
+++ b/src/include/duckdb/function/pragma_function.hpp
@@ -47,7 +47,7 @@ class PragmaFunction : public SimpleNamedParameterFunction {
 
 	pragma_query_t query;
 	pragma_function_t function;
-	unordered_map<string, LogicalType> named_parameters;
+	named_parameter_type_map_t named_parameters;
 
 private:
 	PragmaFunction(string name, PragmaType pragma_type, pragma_query_t query, pragma_function_t function,
diff --git a/src/include/duckdb/function/table/arrow.hpp b/src/include/duckdb/function/table/arrow.hpp
index e527431725a5..8e42f79221f1 100644
--- a/src/include/duckdb/function/table/arrow.hpp
+++ b/src/include/duckdb/function/table/arrow.hpp
@@ -115,7 +115,7 @@ struct ArrowTableFunction {
 private:
 	//! Binds an arrow table
 	static unique_ptr<FunctionData> ArrowScanBind(ClientContext &context, vector<Value> &inputs,
-	                                              unordered_map<string, Value> &named_parameters,
+	                                              named_parameter_map_t &named_parameters,
 	                                              vector<LogicalType> &input_table_types,
 	                                              vector<string> &input_table_names, vector<LogicalType> &return_types,
 	                                              vector<string> &names);
diff --git a/src/include/duckdb/function/table_function.hpp b/src/include/duckdb/function/table_function.hpp
index db9985a75221..0215e4579f25 100644
--- a/src/include/duckdb/function/table_function.hpp
+++ b/src/include/duckdb/function/table_function.hpp
@@ -7,8 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #pragma once
-
-#include "duckdb/common/unordered_map.hpp"
 #include "duckdb/function/function.hpp"
 #include "duckdb/storage/statistics/node_statistics.hpp"
 
@@ -31,7 +29,7 @@ struct TableFilterCollection {
 };
 
 typedef unique_ptr<FunctionData> (*table_function_bind_t)(ClientContext &context, vector<Value> &inputs,
-                                                          unordered_map<string, Value> &named_parameters,
+                                                          named_parameter_map_t &named_parameters,
                                                           vector<LogicalType> &input_table_types,
                                                           vector<string> &input_table_names,
                                                           vector<LogicalType> &return_types, vector<string> &names);
diff --git a/src/include/duckdb/main/client_config.hpp b/src/include/duckdb/main/client_config.hpp
index bdb112cf6a24..5a7da65209d0 100644
--- a/src/include/duckdb/main/client_config.hpp
+++ b/src/include/duckdb/main/client_config.hpp
@@ -35,6 +35,10 @@ struct ClientConfig {
 	//! The wait time before showing the progress bar
 	int wait_time = 2000;
 
+	//! Preserve identifier case while parsing.
+	//! If false, all unquoted identifiers are lower-cased (e.g. "MyTable" -> "mytable").
+	bool preserve_identifier_case = true;
+
 	// Whether or not aggressive query verification is enabled
 	bool query_verification_enabled = false;
 	//! Enable the running of optimizers
diff --git a/src/include/duckdb/main/client_context.hpp b/src/include/duckdb/main/client_context.hpp
index 9ffef60459ac..09bf8bca26dc 100644
--- a/src/include/duckdb/main/client_context.hpp
+++ b/src/include/duckdb/main/client_context.hpp
@@ -42,6 +42,7 @@ class ClientContextLock;
 struct CreateScalarFunctionInfo;
 class ScalarFunctionCatalogEntry;
 struct ActiveQueryContext;
+struct ParserOptions;
 
 //! The ClientContext holds information relevant to the current client session
 //! during execution
@@ -159,6 +160,9 @@ class ClientContext : public std::enable_shared_from_this<ClientContext> {
 	//! Equivalent to CURRENT_SETTING(key) SQL function.
 	DUCKDB_API bool TryGetCurrentSetting(const std::string &key, Value &result);
 
+	//! Returns the parser options for this client context
+	DUCKDB_API ParserOptions GetParserOptions();
+
 	DUCKDB_API unique_ptr<DataChunk> Fetch(ClientContextLock &lock, StreamQueryResult &result);
 
 	//! Whether or not the given result object (streaming query result or pending query result) is active
diff --git a/src/include/duckdb/main/connection.hpp b/src/include/duckdb/main/connection.hpp
index ffbd37d2468f..dc7f0c5fa3df 100644
--- a/src/include/duckdb/main/connection.hpp
+++ b/src/include/duckdb/main/connection.hpp
@@ -114,7 +114,7 @@ class Connection {
 	//! Returns a relation that calls a specified table function
 	DUCKDB_API shared_ptr<Relation> TableFunction(const string &tname);
 	DUCKDB_API shared_ptr<Relation> TableFunction(const string &tname, const vector<Value> &values,
-	                                              const unordered_map<string, Value> &named_parameters);
+	                                              const named_parameter_map_t &named_parameters);
 	DUCKDB_API shared_ptr<Relation> TableFunction(const string &tname, const vector<Value> &values);
 	//! Returns a relation that produces values
 	DUCKDB_API shared_ptr<Relation> Values(const vector<vector<Value>> &values);
diff --git a/src/include/duckdb/main/relation.hpp b/src/include/duckdb/main/relation.hpp
index d151c6c4f84b..3398bc4562d9 100644
--- a/src/include/duckdb/main/relation.hpp
+++ b/src/include/duckdb/main/relation.hpp
@@ -14,7 +14,7 @@
 #include "duckdb/common/winapi.hpp"
 #include "duckdb/main/query_result.hpp"
 #include "duckdb/parser/column_definition.hpp"
-#include "duckdb/common/unordered_map.hpp"
+#include "duckdb/common/named_parameter_map.hpp"
 
 #include <memory>
 
@@ -122,7 +122,7 @@ class Relation : public std::enable_shared_from_this<Relation> {
 	//! Create a relation from calling a table in/out function on the input relation
 	DUCKDB_API shared_ptr<Relation> TableFunction(const std::string &fname, const vector<Value> &values);
 	DUCKDB_API shared_ptr<Relation> TableFunction(const std::string &fname, const vector<Value> &values,
-	                                              const unordered_map<string, Value> &named_parameters);
+	                                              const named_parameter_map_t &named_parameters);
 
 public:
 	//! Whether or not the relation inherits column bindings from its child or not, only relevant for binding
diff --git a/src/include/duckdb/main/relation/table_function_relation.hpp b/src/include/duckdb/main/relation/table_function_relation.hpp
index f735c4c66096..08b75de12cc3 100644
--- a/src/include/duckdb/main/relation/table_function_relation.hpp
+++ b/src/include/duckdb/main/relation/table_function_relation.hpp
@@ -15,15 +15,14 @@ namespace duckdb {
 class TableFunctionRelation : public Relation {
 public:
 	TableFunctionRelation(ClientContext &context, string name, vector<Value> parameters,
-	                      unordered_map<string, Value> named_parameters,
-	                      shared_ptr<Relation> input_relation_p = nullptr);
+	                      named_parameter_map_t named_parameters, shared_ptr<Relation> input_relation_p = nullptr);
 
 	TableFunctionRelation(ClientContext &context, string name, vector<Value> parameters,
 	                      shared_ptr<Relation> input_relation_p = nullptr);
 
 	string name;
 	vector<Value> parameters;
-	unordered_map<string, Value> named_parameters;
+	named_parameter_map_t named_parameters;
 	vector<ColumnDefinition> columns;
 	shared_ptr<Relation> input_relation;
 
diff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp
index 92f9c16af500..02fb2a8b3052 100644
--- a/src/include/duckdb/main/settings.hpp
+++ b/src/include/duckdb/main/settings.hpp
@@ -177,6 +177,15 @@ struct PerfectHashThresholdSetting {
 	static Value GetSetting(ClientContext &context);
 };
 
+struct PreserveIdentifierCase {
+	static constexpr const char *Name = "preserve_identifier_case";
+	static constexpr const char *Description =
+	    "Whether or not to preserve the identifier case, instead of always lowercasing all non-quoted identifiers";
+	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
+	static void SetLocal(ClientContext &context, const Value &parameter);
+	static Value GetSetting(ClientContext &context);
+};
+
 struct ProfilerHistorySize {
 	static constexpr const char *Name = "profiler_history_size";
 	static constexpr const char *Description = "Sets the profiler history size";
diff --git a/src/include/duckdb/parser/parsed_data/pragma_info.hpp b/src/include/duckdb/parser/parsed_data/pragma_info.hpp
index 50dd78faefaa..68e243eedc4e 100644
--- a/src/include/duckdb/parser/parsed_data/pragma_info.hpp
+++ b/src/include/duckdb/parser/parsed_data/pragma_info.hpp
@@ -10,7 +10,7 @@
 
 #include "duckdb/parser/parsed_data/parse_info.hpp"
 #include "duckdb/common/types/value.hpp"
-#include "duckdb/common/unordered_map.hpp"
+#include "duckdb/common/named_parameter_map.hpp"
 #include "duckdb/parser/parsed_expression.hpp"
 
 namespace duckdb {
@@ -23,7 +23,7 @@ struct PragmaInfo : public ParseInfo {
 	//! Parameter list (if any)
 	vector<Value> parameters;
 	//! Named parameter list (if any)
-	unordered_map<string, Value> named_parameters;
+	named_parameter_map_t named_parameters;
 
 public:
 	unique_ptr<PragmaInfo> Copy() const {
diff --git a/src/include/duckdb/parser/parser.hpp b/src/include/duckdb/parser/parser.hpp
index 18521aefa150..a7fa81cafd28 100644
--- a/src/include/duckdb/parser/parser.hpp
+++ b/src/include/duckdb/parser/parser.hpp
@@ -21,12 +21,16 @@ struct PGList;
 
 namespace duckdb {
 
+struct ParserOptions {
+	bool preserve_identifier_case = true;
+};
+
 //! The parser is responsible for parsing the query and converting it into a set
 //! of parsed statements. The parsed statements can then be converted into a
 //! plan and executed.
 class Parser {
 public:
-	Parser();
+	Parser(ParserOptions options = ParserOptions());
 
 	//! The parsed SQL statements from an invocation to ParseQuery.
 	vector<unique_ptr<SQLStatement>> statements;
@@ -47,15 +51,21 @@ class Parser {
 	static vector<ParserKeyword> KeywordList();
 
 	//! Parses a list of expressions (i.e. the list found in a SELECT clause)
-	static vector<unique_ptr<ParsedExpression>> ParseExpressionList(const string &select_list);
+	static vector<unique_ptr<ParsedExpression>> ParseExpressionList(const string &select_list,
+	                                                                ParserOptions options = ParserOptions());
 	//! Parses a list as found in an ORDER BY expression (i.e. including optional ASCENDING/DESCENDING modifiers)
-	static vector<OrderByNode> ParseOrderList(const string &select_list);
+	static vector<OrderByNode> ParseOrderList(const string &select_list, ParserOptions options = ParserOptions());
 	//! Parses an update list (i.e. the list found in the SET clause of an UPDATE statement)
 	static void ParseUpdateList(const string &update_list, vector<string> &update_columns,
-	                            vector<unique_ptr<ParsedExpression>> &expressions);
+	                            vector<unique_ptr<ParsedExpression>> &expressions,
+	                            ParserOptions options = ParserOptions());
 	//! Parses a VALUES list (i.e. the list of expressions after a VALUES clause)
-	static vector<vector<unique_ptr<ParsedExpression>>> ParseValuesList(const string &value_list);
+	static vector<vector<unique_ptr<ParsedExpression>>> ParseValuesList(const string &value_list,
+	                                                                    ParserOptions options = ParserOptions());
 	//! Parses a column list (i.e. as found in a CREATE TABLE statement)
-	static vector<ColumnDefinition> ParseColumnList(const string &column_list);
+	static vector<ColumnDefinition> ParseColumnList(const string &column_list, ParserOptions options = ParserOptions());
+
+private:
+	ParserOptions options;
 };
 } // namespace duckdb
diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp
index d8af9693ceb4..6602c67e0b3d 100644
--- a/src/include/duckdb/planner/binder.hpp
+++ b/src/include/duckdb/planner/binder.hpp
@@ -99,7 +99,7 @@ class Binder : public std::enable_shared_from_this<Binder> {
 	SchemaCatalogEntry *BindCreateFunctionInfo(CreateInfo &info);
 
 	//! Check usage, and cast named parameters to their types
-	static void BindNamedParameters(unordered_map<string, LogicalType> &types, unordered_map<string, Value> &values,
+	static void BindNamedParameters(named_parameter_type_map_t &types, named_parameter_map_t &values,
 	                                QueryErrorContext &error_context, string &func_name);
 
 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
@@ -226,7 +226,7 @@ class Binder : public std::enable_shared_from_this<Binder> {
 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
 
 	bool BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
-	                            vector<Value> &parameters, unordered_map<string, Value> &named_parameters,
+	                            vector<Value> &parameters, named_parameter_map_t &named_parameters,
 	                            unique_ptr<BoundSubqueryRef> &subquery, string &error);
 
 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
diff --git a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp
index f1a7f8c9c47c..9a431b16a886 100644
--- a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "duckdb/common/unordered_map.hpp"
+#include "duckdb/common/case_insensitive_map.hpp"
 #include "duckdb/planner/expression_binder.hpp"
 
 namespace duckdb {
@@ -19,14 +19,14 @@ class ColumnRefExpression;
 //! A helper binder for WhereBinder and HavingBinder which support alias as a columnref.
 class ColumnAliasBinder {
 public:
-	ColumnAliasBinder(BoundSelectNode &node, const unordered_map<string, idx_t> &alias_map);
+	ColumnAliasBinder(BoundSelectNode &node, const case_insensitive_map_t<idx_t> &alias_map);
 
 	BindResult BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,
 	                     bool root_expression);
 
 private:
 	BoundSelectNode &node;
-	const unordered_map<string, idx_t> &alias_map;
+	const case_insensitive_map_t<idx_t> &alias_map;
 	bool in_alias;
 };
 
diff --git a/src/include/duckdb/planner/expression_binder/group_binder.hpp b/src/include/duckdb/planner/expression_binder/group_binder.hpp
index 3c451560caa3..fe7ed2a54e2a 100644
--- a/src/include/duckdb/planner/expression_binder/group_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder/group_binder.hpp
@@ -8,8 +8,7 @@
 
 #pragma once
 
-#include "duckdb/common/unordered_map.hpp"
-#include "duckdb/common/unordered_set.hpp"
+#include "duckdb/common/case_insensitive_map.hpp"
 #include "duckdb/planner/expression_binder.hpp"
 
 namespace duckdb {
@@ -20,7 +19,7 @@ class ColumnRefExpression;
 class GroupBinder : public ExpressionBinder {
 public:
 	GroupBinder(Binder &binder, ClientContext &context, SelectNode &node, idx_t group_index,
-	            unordered_map<string, idx_t> &alias_map, unordered_map<string, idx_t> &group_alias_map);
+	            case_insensitive_map_t<idx_t> &alias_map, case_insensitive_map_t<idx_t> &group_alias_map);
 
 	//! The unbound root expression
 	unique_ptr<ParsedExpression> unbound_expression;
@@ -37,8 +36,8 @@ class GroupBinder : public ExpressionBinder {
 	BindResult BindConstant(ConstantExpression &expr);
 
 	SelectNode &node;
-	unordered_map<string, idx_t> &alias_map;
-	unordered_map<string, idx_t> &group_alias_map;
+	case_insensitive_map_t<idx_t> &alias_map;
+	case_insensitive_map_t<idx_t> &group_alias_map;
 	unordered_set<idx_t> used_aliases;
 
 	idx_t group_index;
diff --git a/src/include/duckdb/planner/expression_binder/having_binder.hpp b/src/include/duckdb/planner/expression_binder/having_binder.hpp
index 5dbe8e8a9f85..4ac14b889d9c 100644
--- a/src/include/duckdb/planner/expression_binder/having_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder/having_binder.hpp
@@ -17,7 +17,7 @@ namespace duckdb {
 class HavingBinder : public SelectBinder {
 public:
 	HavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,
-	             unordered_map<string, idx_t> &alias_map);
+	             case_insensitive_map_t<idx_t> &alias_map);
 
 protected:
 	BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,
diff --git a/src/include/duckdb/planner/expression_binder/order_binder.hpp b/src/include/duckdb/planner/expression_binder/order_binder.hpp
index 7d8f71646311..da3519cf3f2c 100644
--- a/src/include/duckdb/planner/expression_binder/order_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder/order_binder.hpp
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "duckdb/common/unordered_map.hpp"
+#include "duckdb/common/case_insensitive_map.hpp"
 #include "duckdb/parser/expression_map.hpp"
 #include "duckdb/parser/parsed_expression.hpp"
 #include "duckdb/planner/expression/bound_columnref_expression.hpp"
@@ -21,10 +21,10 @@ class SelectNode;
 //! The ORDER binder is responsible for binding an expression within the ORDER BY clause of a SQL statement
 class OrderBinder {
 public:
-	OrderBinder(vector<Binder *> binders, idx_t projection_index, unordered_map<string, idx_t> &alias_map,
+	OrderBinder(vector<Binder *> binders, idx_t projection_index, case_insensitive_map_t<idx_t> &alias_map,
 	            expression_map_t<idx_t> &projection_map, idx_t max_count);
 	OrderBinder(vector<Binder *> binders, idx_t projection_index, SelectNode &node,
-	            unordered_map<string, idx_t> &alias_map, expression_map_t<idx_t> &projection_map);
+	            case_insensitive_map_t<idx_t> &alias_map, expression_map_t<idx_t> &projection_map);
 
 public:
 	unique_ptr<Expression> Bind(unique_ptr<ParsedExpression> expr);
@@ -41,7 +41,7 @@ class OrderBinder {
 	idx_t projection_index;
 	idx_t max_count;
 	vector<unique_ptr<ParsedExpression>> *extra_list;
-	unordered_map<string, idx_t> &alias_map;
+	case_insensitive_map_t<idx_t> &alias_map;
 	expression_map_t<idx_t> &projection_map;
 };
 
diff --git a/src/include/duckdb/planner/expression_binder/qualify_binder.hpp b/src/include/duckdb/planner/expression_binder/qualify_binder.hpp
index 8fca9a78412b..b0dec724c2e5 100644
--- a/src/include/duckdb/planner/expression_binder/qualify_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder/qualify_binder.hpp
@@ -17,7 +17,7 @@ namespace duckdb {
 class QualifyBinder : public SelectBinder {
 public:
 	QualifyBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,
-	              unordered_map<string, idx_t> &alias_map);
+	              case_insensitive_map_t<idx_t> &alias_map);
 
 protected:
 	BindResult BindExpression(unique_ptr<ParsedExpression> *expr_ptr, idx_t depth,
diff --git a/src/include/duckdb/planner/expression_binder/select_binder.hpp b/src/include/duckdb/planner/expression_binder/select_binder.hpp
index efa759830dd5..9b25eac633e2 100644
--- a/src/include/duckdb/planner/expression_binder/select_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder/select_binder.hpp
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "duckdb/common/unordered_map.hpp"
+#include "duckdb/common/case_insensitive_map.hpp"
 #include "duckdb/parser/expression_map.hpp"
 #include "duckdb/planner/expression_binder.hpp"
 
@@ -20,7 +20,7 @@ class BoundSelectNode;
 
 struct BoundGroupInformation {
 	expression_map_t<idx_t> map;
-	unordered_map<string, idx_t> alias_map;
+	case_insensitive_map_t<idx_t> alias_map;
 };
 
 //! The SELECT binder is responsible for binding an expression within the SELECT clause of a SQL statement
diff --git a/src/main/client_context.cpp b/src/main/client_context.cpp
index ec05db062f27..2894ddb599f0 100644
--- a/src/main/client_context.cpp
+++ b/src/main/client_context.cpp
@@ -364,7 +364,7 @@ vector<unique_ptr<SQLStatement>> ClientContext::ParseStatements(const string &qu
 }
 
 vector<unique_ptr<SQLStatement>> ClientContext::ParseStatementsInternal(ClientContextLock &lock, const string &query) {
-	Parser parser;
+	Parser parser(GetParserOptions());
 	parser.ParseQuery(query);
 
 	PragmaHandler handler(*this);
@@ -1101,4 +1101,10 @@ bool ClientContext::TryGetCurrentSetting(const std::string &key, Value &result)
 	return true;
 }
 
+ParserOptions ClientContext::GetParserOptions() {
+	ParserOptions options;
+	options.preserve_identifier_case = ClientConfig::GetConfig(*this).preserve_identifier_case;
+	return options;
+}
+
 } // namespace duckdb
diff --git a/src/main/config.cpp b/src/main/config.cpp
index 2ea78415f8ea..18925b35f347 100644
--- a/src/main/config.cpp
+++ b/src/main/config.cpp
@@ -43,6 +43,7 @@ static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting
                                                  DUCKDB_GLOBAL_ALIAS("memory_limit", MaximumMemorySetting),
                                                  DUCKDB_GLOBAL_ALIAS("null_order", DefaultNullOrderSetting),
                                                  DUCKDB_LOCAL(PerfectHashThresholdSetting),
+                                                 DUCKDB_LOCAL(PreserveIdentifierCase),
                                                  DUCKDB_LOCAL(ProfilerHistorySize),
                                                  DUCKDB_LOCAL(ProfileOutputSetting),
                                                  DUCKDB_LOCAL(ProfilingModeSetting),
@@ -82,8 +83,10 @@ ConfigurationOption *DBConfig::GetOptionByIndex(idx_t target_index) {
 }
 
 ConfigurationOption *DBConfig::GetOptionByName(const string &name) {
+	auto lname = StringUtil::Lower(name);
 	for (idx_t index = 0; internal_options[index].name; index++) {
-		if (internal_options[index].name == name) {
+		D_ASSERT(StringUtil::Lower(internal_options[index].name) == string(internal_options[index].name));
+		if (internal_options[index].name == lname) {
 			return internal_options + index;
 		}
 	}
diff --git a/src/main/connection.cpp b/src/main/connection.cpp
index 9df5baf7db5c..ac2922394039 100644
--- a/src/main/connection.cpp
+++ b/src/main/connection.cpp
@@ -147,12 +147,12 @@ shared_ptr<Relation> Connection::View(const string &schema_name, const string &t
 
 shared_ptr<Relation> Connection::TableFunction(const string &fname) {
 	vector<Value> values;
-	unordered_map<string, Value> named_parameters;
+	named_parameter_map_t named_parameters;
 	return TableFunction(fname, values, named_parameters);
 }
 
 shared_ptr<Relation> Connection::TableFunction(const string &fname, const vector<Value> &values,
-                                               const unordered_map<string, Value> &named_parameters) {
+                                               const named_parameter_map_t &named_parameters) {
 	return make_shared<TableFunctionRelation>(*context, fname, values, named_parameters);
 }
 
@@ -195,7 +195,7 @@ shared_ptr<Relation> Connection::ReadCSV(const string &csv_file, const vector<st
 	// parse columns
 	vector<ColumnDefinition> column_list;
 	for (auto &column : columns) {
-		auto col_list = Parser::ParseColumnList(column);
+		auto col_list = Parser::ParseColumnList(column, context->GetParserOptions());
 		if (col_list.size() != 1) {
 			throw ParserException("Expected a single column definition");
 		}
diff --git a/src/main/relation.cpp b/src/main/relation.cpp
index 8a335b8d72c5..04c0b3eb1ec1 100644
--- a/src/main/relation.cpp
+++ b/src/main/relation.cpp
@@ -35,7 +35,7 @@ shared_ptr<Relation> Relation::Project(const string &expression, const string &a
 }
 
 shared_ptr<Relation> Relation::Project(const string &select_list, const vector<string> &aliases) {
-	auto expressions = Parser::ParseExpressionList(select_list);
+	auto expressions = Parser::ParseExpressionList(select_list, context.GetParserOptions());
 	return make_shared<ProjectionRelation>(shared_from_this(), move(expressions), aliases);
 }
 
@@ -44,13 +44,14 @@ shared_ptr<Relation> Relation::Project(const vector<string> &expressions) {
 	return Project(expressions, aliases);
 }
 
-static vector<unique_ptr<ParsedExpression>> StringListToExpressionList(const vector<string> &expressions) {
+static vector<unique_ptr<ParsedExpression>> StringListToExpressionList(ClientContext &context,
+                                                                       const vector<string> &expressions) {
 	if (expressions.empty()) {
 		throw ParserException("Zero expressions provided");
 	}
 	vector<unique_ptr<ParsedExpression>> result_list;
 	for (auto &expr : expressions) {
-		auto expression_list = Parser::ParseExpressionList(expr);
+		auto expression_list = Parser::ParseExpressionList(expr, context.GetParserOptions());
 		if (expression_list.size() != 1) {
 			throw ParserException("Expected a single expression in the expression list");
 		}
@@ -60,12 +61,12 @@ static vector<unique_ptr<ParsedExpression>> StringListToExpressionList(const vec
 }
 
 shared_ptr<Relation> Relation::Project(const vector<string> &expressions, const vector<string> &aliases) {
-	auto result_list = StringListToExpressionList(expressions);
+	auto result_list = StringListToExpressionList(context, expressions);
 	return make_shared<ProjectionRelation>(shared_from_this(), move(result_list), aliases);
 }
 
 shared_ptr<Relation> Relation::Filter(const string &expression) {
-	auto expression_list = Parser::ParseExpressionList(expression);
+	auto expression_list = Parser::ParseExpressionList(expression, context.GetParserOptions());
 	if (expression_list.size() != 1) {
 		throw ParserException("Expected a single expression as filter condition");
 	}
@@ -74,7 +75,7 @@ shared_ptr<Relation> Relation::Filter(const string &expression) {
 
 shared_ptr<Relation> Relation::Filter(const vector<string> &expressions) {
 	// if there are multiple expressions, we AND them together
-	auto expression_list = StringListToExpressionList(expressions);
+	auto expression_list = StringListToExpressionList(context, expressions);
 	D_ASSERT(!expression_list.empty());
 
 	auto expr = move(expression_list[0]);
@@ -90,7 +91,7 @@ shared_ptr<Relation> Relation::Limit(int64_t limit, int64_t offset) {
 }
 
 shared_ptr<Relation> Relation::Order(const string &expression) {
-	auto order_list = Parser::ParseOrderList(expression);
+	auto order_list = Parser::ParseOrderList(expression, context.GetParserOptions());
 	return make_shared<OrderRelation>(shared_from_this(), move(order_list));
 }
 
@@ -100,7 +101,7 @@ shared_ptr<Relation> Relation::Order(const vector<string> &expressions) {
 	}
 	vector<OrderByNode> order_list;
 	for (auto &expression : expressions) {
-		auto inner_list = Parser::ParseOrderList(expression);
+		auto inner_list = Parser::ParseOrderList(expression, context.GetParserOptions());
 		if (inner_list.size() != 1) {
 			throw ParserException("Expected a single ORDER BY expression in the expression list");
 		}
@@ -110,7 +111,7 @@ shared_ptr<Relation> Relation::Order(const vector<string> &expressions) {
 }
 
 shared_ptr<Relation> Relation::Join(const shared_ptr<Relation> &other, const string &condition, JoinType type) {
-	auto expression_list = Parser::ParseExpressionList(condition);
+	auto expression_list = Parser::ParseExpressionList(condition, context.GetParserOptions());
 	D_ASSERT(!expression_list.empty());
 
 	if (expression_list.size() > 1 || expression_list[0]->type == ExpressionType::COLUMN_REF) {
@@ -154,24 +155,24 @@ shared_ptr<Relation> Relation::Alias(const string &alias) {
 }
 
 shared_ptr<Relation> Relation::Aggregate(const string &aggregate_list) {
-	auto expression_list = Parser::ParseExpressionList(aggregate_list);
+	auto expression_list = Parser::ParseExpressionList(aggregate_list, context.GetParserOptions());
 	return make_shared<AggregateRelation>(shared_from_this(), move(expression_list));
 }
 
 shared_ptr<Relation> Relation::Aggregate(const string &aggregate_list, const string &group_list) {
-	auto expression_list = Parser::ParseExpressionList(aggregate_list);
-	auto groups = Parser::ParseExpressionList(group_list);
+	auto expression_list = Parser::ParseExpressionList(aggregate_list, context.GetParserOptions());
+	auto groups = Parser::ParseExpressionList(group_list, context.GetParserOptions());
 	return make_shared<AggregateRelation>(shared_from_this(), move(expression_list), move(groups));
 }
 
 shared_ptr<Relation> Relation::Aggregate(const vector<string> &aggregates) {
-	auto aggregate_list = StringListToExpressionList(aggregates);
+	auto aggregate_list = StringListToExpressionList(context, aggregates);
 	return make_shared<AggregateRelation>(shared_from_this(), move(aggregate_list));
 }
 
 shared_ptr<Relation> Relation::Aggregate(const vector<string> &aggregates, const vector<string> &groups) {
-	auto aggregate_list = StringListToExpressionList(aggregates);
-	auto group_list = StringListToExpressionList(groups);
+	auto aggregate_list = StringListToExpressionList(context, aggregates);
+	auto group_list = StringListToExpressionList(context, groups);
 	return make_shared<AggregateRelation>(shared_from_this(), move(aggregate_list), move(group_list));
 }
 
@@ -265,7 +266,7 @@ void Relation::Delete(const string &condition) {
 }
 
 shared_ptr<Relation> Relation::TableFunction(const std::string &fname, const vector<Value> &values,
-                                             const unordered_map<string, Value> &named_parameters) {
+                                             const named_parameter_map_t &named_parameters) {
 	return make_shared<TableFunctionRelation>(context, fname, values, named_parameters, shared_from_this());
 }
 
diff --git a/src/main/relation/query_relation.cpp b/src/main/relation/query_relation.cpp
index 086e9f27b9c8..c2f9fb15ec2d 100644
--- a/src/main/relation/query_relation.cpp
+++ b/src/main/relation/query_relation.cpp
@@ -12,7 +12,7 @@ QueryRelation::QueryRelation(ClientContext &context, string query, string alias)
 }
 
 unique_ptr<SelectStatement> QueryRelation::GetSelectStatement() {
-	Parser parser;
+	Parser parser(context.GetParserOptions());
 	parser.ParseQuery(query);
 	if (parser.statements.size() != 1) {
 		throw ParserException("Expected a single SELECT statement");
diff --git a/src/main/relation/table_function_relation.cpp b/src/main/relation/table_function_relation.cpp
index d8debc6ec5a6..288ef1b74ac4 100644
--- a/src/main/relation/table_function_relation.cpp
+++ b/src/main/relation/table_function_relation.cpp
@@ -13,7 +13,7 @@
 namespace duckdb {
 
 TableFunctionRelation::TableFunctionRelation(ClientContext &context, string name_p, vector<Value> parameters_p,
-                                             unordered_map<string, Value> named_parameters,
+                                             named_parameter_map_t named_parameters,
                                              shared_ptr<Relation> input_relation_p)
     : Relation(context, RelationType::TABLE_FUNCTION_RELATION), name(move(name_p)), parameters(move(parameters_p)),
       named_parameters(move(named_parameters)), input_relation(move(input_relation_p)) {
diff --git a/src/main/relation/table_relation.cpp b/src/main/relation/table_relation.cpp
index e54271853fbc..8a4df5743297 100644
--- a/src/main/relation/table_relation.cpp
+++ b/src/main/relation/table_relation.cpp
@@ -5,6 +5,7 @@
 #include "duckdb/main/relation/delete_relation.hpp"
 #include "duckdb/main/relation/update_relation.hpp"
 #include "duckdb/parser/parser.hpp"
+#include "duckdb/main/client_context.hpp"
 
 namespace duckdb {
 
@@ -38,9 +39,9 @@ string TableRelation::ToString(idx_t depth) {
 	return RenderWhitespace(depth) + "Scan Table [" + description->table + "]";
 }
 
-static unique_ptr<ParsedExpression> ParseCondition(const string &condition) {
+static unique_ptr<ParsedExpression> ParseCondition(ClientContext &context, const string &condition) {
 	if (!condition.empty()) {
-		auto expression_list = Parser::ParseExpressionList(condition);
+		auto expression_list = Parser::ParseExpressionList(condition, context.GetParserOptions());
 		if (expression_list.size() != 1) {
 			throw ParserException("Expected a single expression as filter condition");
 		}
@@ -53,15 +54,15 @@ static unique_ptr<ParsedExpression> ParseCondition(const string &condition) {
 void TableRelation::Update(const string &update_list, const string &condition) {
 	vector<string> update_columns;
 	vector<unique_ptr<ParsedExpression>> expressions;
-	auto cond = ParseCondition(condition);
-	Parser::ParseUpdateList(update_list, update_columns, expressions);
+	auto cond = ParseCondition(context, condition);
+	Parser::ParseUpdateList(update_list, update_columns, expressions, context.GetParserOptions());
 	auto update = make_shared<UpdateRelation>(context, move(cond), description->schema, description->table,
 	                                          move(update_columns), move(expressions));
 	update->Execute();
 }
 
 void TableRelation::Delete(const string &condition) {
-	auto cond = ParseCondition(condition);
+	auto cond = ParseCondition(context, condition);
 	auto del = make_shared<DeleteRelation>(context, move(cond), description->schema, description->table);
 	del->Execute();
 }
diff --git a/src/main/relation/value_relation.cpp b/src/main/relation/value_relation.cpp
index 5d0b79eee8d3..138f9bf4438c 100644
--- a/src/main/relation/value_relation.cpp
+++ b/src/main/relation/value_relation.cpp
@@ -25,7 +25,7 @@ ValueRelation::ValueRelation(ClientContext &context, const vector<vector<Value>>
 
 ValueRelation::ValueRelation(ClientContext &context, const string &values_list, vector<string> names_p, string alias_p)
     : Relation(context, RelationType::VALUE_LIST_RELATION), names(move(names_p)), alias(move(alias_p)) {
-	this->expressions = Parser::ParseValuesList(values_list);
+	this->expressions = Parser::ParseValuesList(values_list, context.GetParserOptions());
 	context.TryBindRelation(*this, this->columns);
 }
 
diff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp
index 9f1cdac2b475..d2b64f4ddde6 100644
--- a/src/main/settings/settings.cpp
+++ b/src/main/settings/settings.cpp
@@ -8,6 +8,7 @@
 #include "duckdb/planner/expression_binder.hpp"
 #include "duckdb/main/query_profiler.hpp"
 #include "duckdb/storage/storage_manager.hpp"
+#include "duckdb/parser/parser.hpp"
 
 namespace duckdb {
 
@@ -406,6 +407,17 @@ Value PerfectHashThresholdSetting::GetSetting(ClientContext &context) {
 	return Value::BIGINT(ClientConfig::GetConfig(context).perfect_ht_threshold);
 }
 
+//===--------------------------------------------------------------------===//
+// PreserveIdentifierCase
+//===--------------------------------------------------------------------===//
+void PreserveIdentifierCase::SetLocal(ClientContext &context, const Value &input) {
+	ClientConfig::GetConfig(context).preserve_identifier_case = input.GetValue<bool>();
+}
+
+Value PreserveIdentifierCase::GetSetting(ClientContext &context) {
+	return Value::BOOLEAN(ClientConfig::GetConfig(context).preserve_identifier_case);
+}
+
 //===--------------------------------------------------------------------===//
 // Profiler History Size
 //===--------------------------------------------------------------------===//
diff --git a/src/parser/expression/columnref_expression.cpp b/src/parser/expression/columnref_expression.cpp
index 897c28e8838c..490f17b42c78 100644
--- a/src/parser/expression/columnref_expression.cpp
+++ b/src/parser/expression/columnref_expression.cpp
@@ -3,6 +3,7 @@
 #include "duckdb/common/exception.hpp"
 #include "duckdb/common/serializer.hpp"
 #include "duckdb/common/types/hash.hpp"
+#include "duckdb/common/string_util.hpp"
 
 namespace duckdb {
 
@@ -53,13 +54,24 @@ string ColumnRefExpression::ToString() const {
 }
 
 bool ColumnRefExpression::Equals(const ColumnRefExpression *a, const ColumnRefExpression *b) {
-	return a->column_names == b->column_names;
+	if (a->column_names.size() != b->column_names.size()) {
+		return false;
+	}
+	for (idx_t i = 0; i < a->column_names.size(); i++) {
+		auto lcase_a = StringUtil::Lower(a->column_names[i]);
+		auto lcase_b = StringUtil::Lower(b->column_names[i]);
+		if (lcase_a != lcase_b) {
+			return false;
+		}
+	}
+	return true;
 }
 
 hash_t ColumnRefExpression::Hash() const {
 	hash_t result = ParsedExpression::Hash();
 	for (auto &column_name : column_names) {
-		result = CombineHash(result, duckdb::Hash<const char *>(column_name.c_str()));
+		auto lcase = StringUtil::Lower(column_name);
+		result = CombineHash(result, duckdb::Hash<const char *>(lcase.c_str()));
 	}
 	return result;
 }
diff --git a/src/parser/parser.cpp b/src/parser/parser.cpp
index 8a501ae850c7..159f643c11c4 100644
--- a/src/parser/parser.cpp
+++ b/src/parser/parser.cpp
@@ -14,12 +14,13 @@
 
 namespace duckdb {
 
-Parser::Parser() {
+Parser::Parser(ParserOptions options_p) : options(options_p) {
 }
 
 void Parser::ParseQuery(const string &query) {
 	Transformer transformer;
 	{
+		PostgresParser::SetPreserveIdentifierCase(options.preserve_identifier_case);
 		PostgresParser parser;
 		parser.Parse(query);
 
@@ -115,11 +116,11 @@ vector<ParserKeyword> Parser::KeywordList() {
 	return result;
 }
 
-vector<unique_ptr<ParsedExpression>> Parser::ParseExpressionList(const string &select_list) {
+vector<unique_ptr<ParsedExpression>> Parser::ParseExpressionList(const string &select_list, ParserOptions options) {
 	// construct a mock query prefixed with SELECT
 	string mock_query = "SELECT " + select_list;
 	// parse the query
-	Parser parser;
+	Parser parser(options);
 	parser.ParseQuery(mock_query);
 	// check the statements
 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT_STATEMENT) {
@@ -133,11 +134,11 @@ vector<unique_ptr<ParsedExpression>> Parser::ParseExpressionList(const string &s
 	return move(select_node.select_list);
 }
 
-vector<OrderByNode> Parser::ParseOrderList(const string &select_list) {
+vector<OrderByNode> Parser::ParseOrderList(const string &select_list, ParserOptions options) {
 	// construct a mock query
 	string mock_query = "SELECT * FROM tbl ORDER BY " + select_list;
 	// parse the query
-	Parser parser;
+	Parser parser(options);
 	parser.ParseQuery(mock_query);
 	// check the statements
 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT_STATEMENT) {
@@ -157,11 +158,11 @@ vector<OrderByNode> Parser::ParseOrderList(const string &select_list) {
 }
 
 void Parser::ParseUpdateList(const string &update_list, vector<string> &update_columns,
-                             vector<unique_ptr<ParsedExpression>> &expressions) {
+                             vector<unique_ptr<ParsedExpression>> &expressions, ParserOptions options) {
 	// construct a mock query
 	string mock_query = "UPDATE tbl SET " + update_list;
 	// parse the query
-	Parser parser;
+	Parser parser(options);
 	parser.ParseQuery(mock_query);
 	// check the statements
 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::UPDATE_STATEMENT) {
@@ -172,11 +173,11 @@ void Parser::ParseUpdateList(const string &update_list, vector<string> &update_c
 	expressions = move(update.expressions);
 }
 
-vector<vector<unique_ptr<ParsedExpression>>> Parser::ParseValuesList(const string &value_list) {
+vector<vector<unique_ptr<ParsedExpression>>> Parser::ParseValuesList(const string &value_list, ParserOptions options) {
 	// construct a mock query
 	string mock_query = "VALUES " + value_list;
 	// parse the query
-	Parser parser;
+	Parser parser(options);
 	parser.ParseQuery(mock_query);
 	// check the statements
 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT_STATEMENT) {
@@ -194,9 +195,9 @@ vector<vector<unique_ptr<ParsedExpression>>> Parser::ParseValuesList(const strin
 	return move(values_list.values);
 }
 
-vector<ColumnDefinition> Parser::ParseColumnList(const string &column_list) {
+vector<ColumnDefinition> Parser::ParseColumnList(const string &column_list, ParserOptions options) {
 	string mock_query = "CREATE TABLE blabla (" + column_list + ")";
-	Parser parser;
+	Parser parser(options);
 	parser.ParseQuery(mock_query);
 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::CREATE_STATEMENT) {
 		throw ParserException("Expected a single CREATE statement");
diff --git a/src/planner/binder/expression/bind_comparison_expression.cpp b/src/planner/binder/expression/bind_comparison_expression.cpp
index e6368b6d24fb..d7d507de197e 100644
--- a/src/planner/binder/expression/bind_comparison_expression.cpp
+++ b/src/planner/binder/expression/bind_comparison_expression.cpp
@@ -25,6 +25,7 @@ unique_ptr<Expression> ExpressionBinder::PushCollation(ClientContext &context, u
 	} else {
 		collation = collation_p;
 	}
+	collation = StringUtil::Lower(collation);
 	// bind the collation
 	if (collation.empty() || collation == "binary" || collation == "c" || collation == "posix") {
 		// binary collation: just skip
diff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp
index 8729d43b1ee9..6a5b6bfffea7 100644
--- a/src/planner/binder/query_node/bind_select_node.cpp
+++ b/src/planner/binder/query_node/bind_select_node.cpp
@@ -253,7 +253,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
 	statement.select_list = move(new_select_list);
 
 	// create a mapping of (alias -> index) and a mapping of (Expression -> index) for the SELECT list
-	unordered_map<string, idx_t> alias_map;
+	case_insensitive_map_t<idx_t> alias_map;
 	expression_map_t<idx_t> projection_map;
 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
 		auto &expr = statement.select_list[i];
diff --git a/src/planner/binder/query_node/bind_setop_node.cpp b/src/planner/binder/query_node/bind_setop_node.cpp
index 07f7b33ca7ac..ca634056d0b1 100644
--- a/src/planner/binder/query_node/bind_setop_node.cpp
+++ b/src/planner/binder/query_node/bind_setop_node.cpp
@@ -11,7 +11,7 @@
 
 namespace duckdb {
 
-static void GatherAliases(BoundQueryNode &node, unordered_map<string, idx_t> &aliases,
+static void GatherAliases(BoundQueryNode &node, case_insensitive_map_t<idx_t> &aliases,
                           expression_map_t<idx_t> &expressions) {
 	if (node.type == QueryNodeType::SET_OPERATION_NODE) {
 		// setop, recurse
@@ -81,7 +81,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SetOperationNode &statement) {
 
 		// we recursively visit the children of this node to extract aliases and expressions that can be referenced in
 		// the ORDER BY
-		unordered_map<string, idx_t> alias_map;
+		case_insensitive_map_t<idx_t> alias_map;
 		expression_map_t<idx_t> expression_map;
 		GatherAliases(*result, alias_map, expression_map);
 
diff --git a/src/planner/binder/statement/bind_insert.cpp b/src/planner/binder/statement/bind_insert.cpp
index f4fbd399f9a6..ed3948976a8f 100644
--- a/src/planner/binder/statement/bind_insert.cpp
+++ b/src/planner/binder/statement/bind_insert.cpp
@@ -40,7 +40,7 @@ BoundStatement Binder::Bind(InsertStatement &stmt) {
 		// insertion statement specifies column list
 
 		// create a mapping of (list index) -> (column index)
-		unordered_map<string, idx_t> column_name_map;
+		case_insensitive_map_t<idx_t> column_name_map;
 		for (idx_t i = 0; i < stmt.columns.size(); i++) {
 			column_name_map[stmt.columns[i]] = i;
 			auto entry = table->name_map.find(stmt.columns[i]);
diff --git a/src/planner/binder/tableref/bind_named_parameters.cpp b/src/planner/binder/tableref/bind_named_parameters.cpp
index 0c71e1441ee6..4b50b320c769 100644
--- a/src/planner/binder/tableref/bind_named_parameters.cpp
+++ b/src/planner/binder/tableref/bind_named_parameters.cpp
@@ -2,7 +2,7 @@
 
 namespace duckdb {
 
-void Binder::BindNamedParameters(unordered_map<string, LogicalType> &types, unordered_map<string, Value> &values,
+void Binder::BindNamedParameters(named_parameter_type_map_t &types, named_parameter_map_t &values,
                                  QueryErrorContext &error_context, string &func_name) {
 	for (auto &kv : values) {
 		auto entry = types.find(kv.first);
diff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp
index 95e75a87544d..5f13518e824e 100644
--- a/src/planner/binder/tableref/bind_table_function.cpp
+++ b/src/planner/binder/tableref/bind_table_function.cpp
@@ -17,7 +17,7 @@
 namespace duckdb {
 
 bool Binder::BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
-                                    vector<Value> &parameters, unordered_map<string, Value> &named_parameters,
+                                    vector<Value> &parameters, named_parameter_map_t &named_parameters,
                                     unique_ptr<BoundSubqueryRef> &subquery, string &error) {
 	bool seen_subquery = false;
 	for (auto &child : expressions) {
@@ -81,7 +81,7 @@ unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {
 	// evaluate the input parameters to the function
 	vector<LogicalType> arguments;
 	vector<Value> parameters;
-	unordered_map<string, Value> named_parameters;
+	named_parameter_map_t named_parameters;
 	unique_ptr<BoundSubqueryRef> subquery;
 	string error;
 	if (!BindFunctionParameters(fexpr->children, arguments, parameters, named_parameters, subquery, error)) {
diff --git a/src/planner/expression_binder/column_alias_binder.cpp b/src/planner/expression_binder/column_alias_binder.cpp
index 31b9c3572f87..090b96309acd 100644
--- a/src/planner/expression_binder/column_alias_binder.cpp
+++ b/src/planner/expression_binder/column_alias_binder.cpp
@@ -6,7 +6,7 @@
 
 namespace duckdb {
 
-ColumnAliasBinder::ColumnAliasBinder(BoundSelectNode &node, const unordered_map<string, idx_t> &alias_map)
+ColumnAliasBinder::ColumnAliasBinder(BoundSelectNode &node, const case_insensitive_map_t<idx_t> &alias_map)
     : node(node), alias_map(alias_map), in_alias(false) {
 }
 
diff --git a/src/planner/expression_binder/group_binder.cpp b/src/planner/expression_binder/group_binder.cpp
index bc0c65049e9c..ebf981570ed6 100644
--- a/src/planner/expression_binder/group_binder.cpp
+++ b/src/planner/expression_binder/group_binder.cpp
@@ -9,7 +9,7 @@
 namespace duckdb {
 
 GroupBinder::GroupBinder(Binder &binder, ClientContext &context, SelectNode &node, idx_t group_index,
-                         unordered_map<string, idx_t> &alias_map, unordered_map<string, idx_t> &group_alias_map)
+                         case_insensitive_map_t<idx_t> &alias_map, case_insensitive_map_t<idx_t> &group_alias_map)
     : ExpressionBinder(binder, context), node(node), alias_map(alias_map), group_alias_map(group_alias_map),
       group_index(group_index) {
 }
diff --git a/src/planner/expression_binder/having_binder.cpp b/src/planner/expression_binder/having_binder.cpp
index 52d9ad69bba3..cdea0b0c2b2e 100644
--- a/src/planner/expression_binder/having_binder.cpp
+++ b/src/planner/expression_binder/having_binder.cpp
@@ -9,7 +9,7 @@
 namespace duckdb {
 
 HavingBinder::HavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,
-                           unordered_map<string, idx_t> &alias_map)
+                           case_insensitive_map_t<idx_t> &alias_map)
     : SelectBinder(binder, context, node, info), column_alias_binder(node, alias_map) {
 	target_type = LogicalType(LogicalTypeId::BOOLEAN);
 }
diff --git a/src/planner/expression_binder/order_binder.cpp b/src/planner/expression_binder/order_binder.cpp
index 7fc7ec48bab7..d68ef5352b49 100644
--- a/src/planner/expression_binder/order_binder.cpp
+++ b/src/planner/expression_binder/order_binder.cpp
@@ -9,13 +9,13 @@
 
 namespace duckdb {
 
-OrderBinder::OrderBinder(vector<Binder *> binders, idx_t projection_index, unordered_map<string, idx_t> &alias_map,
+OrderBinder::OrderBinder(vector<Binder *> binders, idx_t projection_index, case_insensitive_map_t<idx_t> &alias_map,
                          expression_map_t<idx_t> &projection_map, idx_t max_count)
     : binders(move(binders)), projection_index(projection_index), max_count(max_count), extra_list(nullptr),
       alias_map(alias_map), projection_map(projection_map) {
 }
 OrderBinder::OrderBinder(vector<Binder *> binders, idx_t projection_index, SelectNode &node,
-                         unordered_map<string, idx_t> &alias_map, expression_map_t<idx_t> &projection_map)
+                         case_insensitive_map_t<idx_t> &alias_map, expression_map_t<idx_t> &projection_map)
     : binders(move(binders)), projection_index(projection_index), alias_map(alias_map), projection_map(projection_map) {
 	this->max_count = node.select_list.size();
 	this->extra_list = &node.select_list;
diff --git a/src/planner/expression_binder/qualify_binder.cpp b/src/planner/expression_binder/qualify_binder.cpp
index 6c51e7e2e13a..09b0d05b966b 100644
--- a/src/planner/expression_binder/qualify_binder.cpp
+++ b/src/planner/expression_binder/qualify_binder.cpp
@@ -9,7 +9,7 @@
 namespace duckdb {
 
 QualifyBinder::QualifyBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,
-                             unordered_map<string, idx_t> &alias_map)
+                             case_insensitive_map_t<idx_t> &alias_map)
     : SelectBinder(binder, context, node, info), column_alias_binder(node, alias_map) {
 	target_type = LogicalType(LogicalTypeId::BOOLEAN);
 }
diff --git a/src/planner/pragma_handler.cpp b/src/planner/pragma_handler.cpp
index 781304aad3b9..31403cb149bd 100644
--- a/src/planner/pragma_handler.cpp
+++ b/src/planner/pragma_handler.cpp
@@ -28,7 +28,7 @@ void PragmaHandler::HandlePragmaStatementsInternal(vector<unique_ptr<SQLStatemen
 			if (!new_query.empty()) {
 				// this PRAGMA statement gets replaced by a new query string
 				// push the new query string through the parser again and add it to the transformer
-				Parser parser;
+				Parser parser(context.GetParserOptions());
 				parser.ParseQuery(new_query);
 				// insert the new statements and remove the old statement
 				// FIXME: off by one here maybe?
diff --git a/third_party/libpg_query/include/parser/scansup.hpp b/third_party/libpg_query/include/parser/scansup.hpp
index e86c2de6db5f..4c87ad44e556 100755
--- a/third_party/libpg_query/include/parser/scansup.hpp
+++ b/third_party/libpg_query/include/parser/scansup.hpp
@@ -24,4 +24,7 @@ char *downcase_identifier(const char *ident, int len, bool warn, bool truncate);
 
 bool scanner_isspace(char ch);
 
+void set_preserve_identifier_case(bool downcase);
+bool get_preserve_identifier_case();
+
 }
\ No newline at end of file
diff --git a/third_party/libpg_query/include/postgres_parser.hpp b/third_party/libpg_query/include/postgres_parser.hpp
index a008907ac173..4326d53520bb 100644
--- a/third_party/libpg_query/include/postgres_parser.hpp
+++ b/third_party/libpg_query/include/postgres_parser.hpp
@@ -29,5 +29,8 @@ class PostgresParser {
 
 	static bool IsKeyword(const std::string &text);
 	static std::vector<duckdb_libpgquery::PGKeyword> KeywordList();
+
+	static void SetPreserveIdentifierCase(bool downcase);
 };
+
 }
diff --git a/third_party/libpg_query/postgres_parser.cpp b/third_party/libpg_query/postgres_parser.cpp
index 1455902001dc..e307403b54f5 100644
--- a/third_party/libpg_query/postgres_parser.cpp
+++ b/third_party/libpg_query/postgres_parser.cpp
@@ -2,6 +2,7 @@
 
 #include "pg_functions.hpp"
 #include "parser/parser.hpp"
+#include "parser/scansup.hpp"
 #include "common/keywords.hpp"
 
 using namespace std;
@@ -43,4 +44,8 @@ vector<duckdb_libpgquery::PGKeyword> PostgresParser::KeywordList() {
 	return duckdb_libpgquery::keyword_list();
 }
 
+void PostgresParser::SetPreserveIdentifierCase(bool preserve) {
+	duckdb_libpgquery::set_preserve_identifier_case(preserve);
+}
+
 }
diff --git a/third_party/libpg_query/src_backend_parser_scansup.cpp b/third_party/libpg_query/src_backend_parser_scansup.cpp
index dfbafc8f6d0c..53cad6693ab6 100755
--- a/third_party/libpg_query/src_backend_parser_scansup.cpp
+++ b/third_party/libpg_query/src_backend_parser_scansup.cpp
@@ -60,6 +60,16 @@ char *downcase_truncate_identifier(const char *ident, int len, bool warn) {
 	return downcase_identifier(ident, len, warn, true);
 }
 
+static __thread bool pg_preserve_identifier_case = false;
+
+void set_preserve_identifier_case(bool preserve) {
+	pg_preserve_identifier_case = preserve;
+}
+
+bool get_preserve_identifier_case() {
+	return pg_preserve_identifier_case;
+}
+
 /*
  * a workhorse for downcase_truncate_identifier
  */
@@ -83,10 +93,12 @@ char *downcase_identifier(const char *ident, int len, bool warn, bool truncate)
 	for (i = 0; i < len; i++) {
 		unsigned char ch = (unsigned char)ident[i];
 
-		if (ch >= 'A' && ch <= 'Z')
-			ch += 'a' - 'A';
-		else if (enc_is_single_byte && IS_HIGHBIT_SET(ch) && isupper(ch))
-			ch = tolower(ch);
+		if (!get_preserve_identifier_case()) {
+			if (ch >= 'A' && ch <= 'Z')
+				ch += 'a' - 'A';
+			else if (enc_is_single_byte && IS_HIGHBIT_SET(ch) && isupper(ch))
+				ch = tolower(ch);
+		}
 		result[i] = (char)ch;
 	}
 	result[i] = '\0';
diff --git a/tools/pythonpkg/src/include/duckdb_python/map.hpp b/tools/pythonpkg/src/include/duckdb_python/map.hpp
index 1ac15d3b3e00..24e5ef47ad8a 100644
--- a/tools/pythonpkg/src/include/duckdb_python/map.hpp
+++ b/tools/pythonpkg/src/include/duckdb_python/map.hpp
@@ -20,7 +20,7 @@ struct MapFunction : public TableFunction {
 	MapFunction();
 
 	static unique_ptr<FunctionData> MapFunctionBind(ClientContext &context, vector<Value> &inputs,
-	                                                unordered_map<string, Value> &named_parameters,
+	                                                named_parameter_map_t &named_parameters,
 	                                                vector<LogicalType> &input_table_types,
 	                                                vector<string> &input_table_names,
 	                                                vector<LogicalType> &return_types, vector<string> &names);
diff --git a/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp b/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp
index 40c940d57f33..66c71428c415 100644
--- a/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp
+++ b/tools/pythonpkg/src/include/duckdb_python/pandas_scan.hpp
@@ -21,7 +21,7 @@ struct PandasScanFunction : public TableFunction {
 	PandasScanFunction();
 
 	static unique_ptr<FunctionData> PandasScanBind(ClientContext &context, vector<Value> &inputs,
-	                                               unordered_map<string, Value> &named_parameters,
+	                                               named_parameter_map_t &named_parameters,
 	                                               vector<LogicalType> &input_table_types,
 	                                               vector<string> &input_table_names, vector<LogicalType> &return_types,
 	                                               vector<string> &names);
diff --git a/tools/pythonpkg/src/map.cpp b/tools/pythonpkg/src/map.cpp
index 92d0cf607468..67bc847ac794 100644
--- a/tools/pythonpkg/src/map.cpp
+++ b/tools/pythonpkg/src/map.cpp
@@ -44,7 +44,7 @@ static py::handle FunctionCall(NumpyResultConversion &conversion, vector<string>
 // we call the passed function with a zero-row data frame to infer the output columns and their names.
 // they better not change in the actual execution ^^
 unique_ptr<FunctionData> MapFunction::MapFunctionBind(ClientContext &context, vector<Value> &inputs,
-                                                      unordered_map<string, Value> &named_parameters,
+                                                      named_parameter_map_t &named_parameters,
                                                       vector<LogicalType> &input_table_types,
                                                       vector<string> &input_table_names,
                                                       vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/tools/pythonpkg/src/pandas_scan.cpp b/tools/pythonpkg/src/pandas_scan.cpp
index cc69ea30c557..65df98092fb5 100644
--- a/tools/pythonpkg/src/pandas_scan.cpp
+++ b/tools/pythonpkg/src/pandas_scan.cpp
@@ -53,7 +53,7 @@ PandasScanFunction::PandasScanFunction()
 }
 
 unique_ptr<FunctionData> PandasScanFunction::PandasScanBind(ClientContext &context, vector<Value> &inputs,
-                                                            unordered_map<string, Value> &named_parameters,
+                                                            named_parameter_map_t &named_parameters,
                                                             vector<LogicalType> &input_table_types,
                                                             vector<string> &input_table_names,
                                                             vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp
index 730aec967b35..ab0879f7cb16 100644
--- a/tools/pythonpkg/src/pyconnection.cpp
+++ b/tools/pythonpkg/src/pyconnection.cpp
@@ -280,7 +280,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromParquet(const string &filen
 	}
 	vector<Value> params;
 	params.emplace_back(filename);
-	unordered_map<string, Value> named_parameters({{"binary_as_string", Value::BOOLEAN(binary_as_string)}});
+	named_parameter_map_t named_parameters({{"binary_as_string", Value::BOOLEAN(binary_as_string)}});
 	return make_unique<DuckDBPyRelation>(
 	    connection->TableFunction("parquet_scan", params, named_parameters)->Alias(filename));
 }
diff --git a/tools/rpkg/src/scan.cpp b/tools/rpkg/src/scan.cpp
index 3eba1ef34637..5563820320fd 100644
--- a/tools/rpkg/src/scan.cpp
+++ b/tools/rpkg/src/scan.cpp
@@ -50,7 +50,7 @@ struct DataFrameScanState : public FunctionOperatorData {
 };
 
 static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> &inputs,
-                                                    unordered_map<string, Value> &named_parameters,
+                                                    named_parameter_map_t &named_parameters,
                                                     vector<LogicalType> &input_table_types,
                                                     vector<string> &input_table_names,
                                                     vector<LogicalType> &return_types, vector<string> &names) {
diff --git a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp
index 5c7540a2bac7..8dc55dab12b6 100644
--- a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp
+++ b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp
@@ -135,7 +135,7 @@ int sqlite3_prepare_v2(sqlite3 *db,           /* Database handle */
 		*pzTail = zSql + query.size();
 	}
 	try {
-		Parser parser;
+		Parser parser(db->con->context->GetParserOptions());
 		parser.ParseQuery(query);
 		if (parser.statements.size() == 0) {
 			return SQLITE_OK;
