You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Exception messages need to escape percent signs
**What does happen?**
Error messages with percent signs are not being escaped, which can cause `printf` to throw an argument not found exception.

**What should happen?**
Describe what you expect DuckDB to do instead.

**To Reproduce**
Steps to reproduce the behavior. Bonus points if those are only SQL queries.
1. 
```sql
CREATE VIEW list_int AS
SELECT case when i%2 <> 0 then [1] else NULL end FROM range(10000) tbl(i);
```
2. 
```sql
select count(*) from list_int where l is distinct from NULL;
```

Expected: Error message referencing anonymous column with embedded `%2`
Actual: `argument index out of range`

**Environment (please complete the following information):**
 - OS: [OSX]
 - DuckDB Version [26]

**Before submitting**
- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?
- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds


</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/parser/column_definition.hpp"
13: #include "duckdb/parser/tokens.hpp"
14: #include "duckdb/planner/bind_context.hpp"
15: #include "duckdb/planner/bound_tokens.hpp"
16: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
17: #include "duckdb/planner/logical_operator.hpp"
18: #include "duckdb/planner/bound_statement.hpp"
19: 
20: namespace duckdb {
21: class BoundResultModifier;
22: class ClientContext;
23: class ExpressionBinder;
24: class LimitModifier;
25: class OrderBinder;
26: class TableCatalogEntry;
27: class ViewCatalogEntry;
28: 
29: struct CreateInfo;
30: struct BoundCreateTableInfo;
31: struct BoundCreateFunctionInfo;
32: struct CommonTableExpressionInfo;
33: 
34: struct CorrelatedColumnInfo {
35: 	ColumnBinding binding;
36: 	LogicalType type;
37: 	string name;
38: 	idx_t depth;
39: 
40: 	explicit CorrelatedColumnInfo(BoundColumnRefExpression &expr)
41: 	    : binding(expr.binding), type(expr.return_type), name(expr.GetName()), depth(expr.depth) {
42: 	}
43: 
44: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
45: 		return binding == rhs.binding;
46: 	}
47: };
48: 
49: //! Bind the parsed query tree to the actual columns present in the catalog.
50: /*!
51:   The binder is responsible for binding tables and columns to actual physical
52:   tables and columns in the catalog. In the process, it also resolves types of
53:   all expressions.
54: */
55: class Binder : public std::enable_shared_from_this<Binder> {
56: 	friend class ExpressionBinder;
57: 	friend class RecursiveSubqueryPlanner;
58: 
59: public:
60: 	static shared_ptr<Binder> CreateBinder(ClientContext &context, Binder *parent = nullptr, bool inherit_ctes = true);
61: 
62: 	//! The client context
63: 	ClientContext &context;
64: 	//! A mapping of names to common table expressions
65: 	unordered_map<string, CommonTableExpressionInfo *> CTE_bindings;
66: 	//! The CTEs that have already been bound
67: 	unordered_set<CommonTableExpressionInfo *> bound_ctes;
68: 	//! The bind context
69: 	BindContext bind_context;
70: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
71: 	//! vector)
72: 	vector<CorrelatedColumnInfo> correlated_columns;
73: 	//! The set of parameter expressions bound by this binder
74: 	vector<BoundParameterExpression *> *parameters;
75: 	//! Whether or not the bound statement is read-only
76: 	bool read_only;
77: 	//! Whether or not the statement requires a valid transaction to run
78: 	bool requires_valid_transaction;
79: 	//! Whether or not the statement can be streamed to the client
80: 	bool allow_stream_result;
81: 	//! The alias for the currently processing subquery, if it exists
82: 	string alias;
83: 	//! Macro parameter bindings (if any)
84: 	MacroBinding *macro_binding = nullptr;
85: 
86: public:
87: 	BoundStatement Bind(SQLStatement &statement);
88: 	BoundStatement Bind(QueryNode &node);
89: 
90: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
91: 	void BindCreateViewInfo(CreateViewInfo &base);
92: 	SchemaCatalogEntry *BindSchema(CreateInfo &info);
93: 	SchemaCatalogEntry *BindCreateFunctionInfo(CreateInfo &info);
94: 
95: 	//! Check usage, and cast named parameters to their types
96: 	static void BindNamedParameters(unordered_map<string, LogicalType> &types, unordered_map<string, Value> &values,
97: 	                                QueryErrorContext &error_context, string &func_name);
98: 
99: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
100: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
101: 
102: 	//! Generates an unused index for a table
103: 	idx_t GenerateTableIndex();
104: 
105: 	//! Add a common table expression to the binder
106: 	void AddCTE(const string &name, CommonTableExpressionInfo *cte);
107: 	//! Find a common table expression by name; returns nullptr if none exists
108: 	CommonTableExpressionInfo *FindCTE(const string &name, bool skip = false);
109: 
110: 	bool CTEIsAlreadyBound(CommonTableExpressionInfo *cte);
111: 
112: 	void PushExpressionBinder(ExpressionBinder *binder);
113: 	void PopExpressionBinder();
114: 	void SetActiveBinder(ExpressionBinder *binder);
115: 	ExpressionBinder *GetActiveBinder();
116: 	bool HasActiveBinder();
117: 
118: 	vector<ExpressionBinder *> &GetActiveBinders();
119: 
120: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
121: 	//! Add a correlated column to this binder (if it does not exist)
122: 	void AddCorrelatedColumn(const CorrelatedColumnInfo &info);
123: 
124: 	string FormatError(ParsedExpression &expr_context, const string &message);
125: 	string FormatError(TableRef &ref_context, const string &message);
126: 	string FormatError(idx_t query_location, const string &message);
127: 
128: private:
129: 	//! The parent binder (if any)
130: 	shared_ptr<Binder> parent;
131: 	//! The vector of active binders
132: 	vector<ExpressionBinder *> active_binders;
133: 	//! The count of bound_tables
134: 	idx_t bound_tables;
135: 	//! Whether or not the binder has any unplanned subqueries that still need to be planned
136: 	bool has_unplanned_subqueries = false;
137: 	//! Whether or not subqueries should be planned already
138: 	bool plan_subquery = true;
139: 	//! Whether CTEs should reference the parent binder (if it exists)
140: 	bool inherit_ctes = true;
141: 	//! The root statement of the query that is currently being parsed
142: 	SQLStatement *root_statement = nullptr;
143: 
144: private:
145: 	//! Bind the default values of the columns of a table
146: 	void BindDefaultValues(vector<ColumnDefinition> &columns, vector<unique_ptr<Expression>> &bound_defaults);
147: 	//! Bind a delimiter value (LIMIT or OFFSET)
148: 	unique_ptr<Expression> BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,
149: 	                                     int64_t &delimiter_value);
150: 
151: 	//! Move correlated expressions from the child binder to this binder
152: 	void MoveCorrelatedExpressions(Binder &other);
153: 
154: 	BoundStatement Bind(SelectStatement &stmt);
155: 	BoundStatement Bind(InsertStatement &stmt);
156: 	BoundStatement Bind(CopyStatement &stmt);
157: 	BoundStatement Bind(DeleteStatement &stmt);
158: 	BoundStatement Bind(UpdateStatement &stmt);
159: 	BoundStatement Bind(CreateStatement &stmt);
160: 	BoundStatement Bind(DropStatement &stmt);
161: 	BoundStatement Bind(AlterStatement &stmt);
162: 	BoundStatement Bind(TransactionStatement &stmt);
163: 	BoundStatement Bind(PragmaStatement &stmt);
164: 	BoundStatement Bind(ExplainStatement &stmt);
165: 	BoundStatement Bind(VacuumStatement &stmt);
166: 	BoundStatement Bind(RelationStatement &stmt);
167: 	BoundStatement Bind(ShowStatement &stmt);
168: 	BoundStatement Bind(CallStatement &stmt);
169: 	BoundStatement Bind(ExportStatement &stmt);
170: 	BoundStatement Bind(SetStatement &stmt);
171: 	BoundStatement Bind(LoadStatement &stmt);
172: 
173: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
174: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
175: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
176: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
177: 
178: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
179: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
180: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
181: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
182: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
183: 
184: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
185: 	unique_ptr<BoundTableRef> Bind(CrossProductRef &ref);
186: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
187: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte = nullptr);
188: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
189: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
190: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
191: 
192: 	bool BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
193: 	                            vector<Value> &parameters, unordered_map<string, Value> &named_parameters,
194: 	                            unique_ptr<BoundSubqueryRef> &subquery, string &error);
195: 
196: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
197: 	unique_ptr<LogicalOperator> CreatePlan(BoundCrossProductRef &ref);
198: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
199: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
200: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
201: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
202: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
203: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
204: 
205: 	unique_ptr<LogicalOperator> BindTable(TableCatalogEntry &table, BaseTableRef &ref);
206: 	unique_ptr<LogicalOperator> BindView(ViewCatalogEntry &view, BaseTableRef &ref);
207: 	unique_ptr<LogicalOperator> BindTableOrView(BaseTableRef &ref);
208: 
209: 	BoundStatement BindCopyTo(CopyStatement &stmt);
210: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
211: 
212: 	void BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
213: 	void BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index);
214: 
215: 	unique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);
216: 	unique_ptr<Expression> BindFilter(unique_ptr<ParsedExpression> condition);
217: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
218: 
219: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
220: 
221: 	void PlanSubqueries(unique_ptr<Expression> *expr, unique_ptr<LogicalOperator> *root);
222: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
223: 
224: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,
225: 	                                                       vector<LogicalType> &target_types,
226: 	                                                       unique_ptr<LogicalOperator> op);
227: 
228: 	string FindBinding(const string &using_column, const string &join_side);
229: 	bool TryFindBinding(const string &using_column, const string &join_side, string &result);
230: 
231: public:
232: 	// This should really be a private constructor, but make_shared does not allow it...
233: 	Binder(bool I_know_what_I_am_doing, ClientContext &context, shared_ptr<Binder> parent, bool inherit_ctes);
234: };
235: 
236: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/parser/query_error_context.cpp]
1: #include "duckdb/parser/query_error_context.hpp"
2: #include "duckdb/parser/sql_statement.hpp"
3: #include "duckdb/common/string_util.hpp"
4: #include "duckdb/common/to_string.hpp"
5: 
6: #include "utf8proc_wrapper.hpp"
7: 
8: namespace duckdb {
9: 
10: string QueryErrorContext::Format(const string &query, const string &error_message, int error_loc) {
11: 	if (error_loc < 0 || size_t(error_loc) >= query.size()) {
12: 		// no location in query provided
13: 		return error_message;
14: 	}
15: 	idx_t error_location = idx_t(error_loc);
16: 	// count the line numbers until the error location
17: 	// and set the start position as the first character of that line
18: 	idx_t start_pos = 0;
19: 	idx_t line_number = 1;
20: 	for (idx_t i = 0; i < error_location; i++) {
21: 		if (StringUtil::CharacterIsNewline(query[i])) {
22: 			line_number++;
23: 			start_pos = i + 1;
24: 		}
25: 	}
26: 	// now find either the next newline token after the query, or find the end of string
27: 	// this is the initial end position
28: 	idx_t end_pos = query.size();
29: 	for (idx_t i = error_location; i < query.size(); i++) {
30: 		if (StringUtil::CharacterIsNewline(query[i])) {
31: 			end_pos = i;
32: 			break;
33: 		}
34: 	}
35: 	// now start scanning from the start pos
36: 	// we want to figure out the start and end pos of what we are going to render
37: 	// we want to render at most 80 characters in total, with the error_location located in the middle
38: 	const char *buf = query.c_str() + start_pos;
39: 	idx_t len = end_pos - start_pos;
40: 	vector<idx_t> render_widths;
41: 	vector<idx_t> positions;
42: 	if (Utf8Proc::IsValid(buf, len)) {
43: 		// for unicode awareness, we traverse the graphemes of the current line and keep track of their render widths
44: 		// and of their position in the string
45: 		for (idx_t cpos = 0; cpos < len;) {
46: 			auto char_render_width = Utf8Proc::RenderWidth(buf, len, cpos);
47: 			positions.push_back(cpos);
48: 			render_widths.push_back(char_render_width);
49: 			cpos = Utf8Proc::NextGraphemeCluster(buf, len, cpos);
50: 		}
51: 	} else {
52: 		// invalid utf-8, we can't do much at this point
53: 		// we just assume every character is a character, and every character has a render width of 1
54: 		for (idx_t cpos = 0; cpos < len; cpos++) {
55: 			positions.push_back(cpos);
56: 			render_widths.push_back(1);
57: 		}
58: 	}
59: 	// now we want to find the (unicode aware) start and end position
60: 	idx_t epos = 0;
61: 	// start by finding the error location inside the array
62: 	for (idx_t i = 0; i < positions.size(); i++) {
63: 		if (positions[i] >= (error_location - start_pos)) {
64: 			epos = i;
65: 			break;
66: 		}
67: 	}
68: 	bool truncate_beginning = false;
69: 	bool truncate_end = false;
70: 	idx_t spos = 0;
71: 	// now we iterate backwards from the error location
72: 	// we show max 40 render width before the error location
73: 	idx_t current_render_width = 0;
74: 	for (idx_t i = epos; i > 0; i--) {
75: 		current_render_width += render_widths[i];
76: 		if (current_render_width >= 40) {
77: 			truncate_beginning = true;
78: 			start_pos = positions[i];
79: 			spos = i;
80: 			break;
81: 		}
82: 	}
83: 	// now do the same, but going forward
84: 	current_render_width = 0;
85: 	for (idx_t i = epos; i < positions.size(); i++) {
86: 		current_render_width += render_widths[i];
87: 		if (current_render_width >= 40) {
88: 			truncate_end = true;
89: 			end_pos = positions[i];
90: 			break;
91: 		}
92: 	}
93: 	string line_indicator = "LINE " + to_string(line_number) + ": ";
94: 	string begin_trunc = truncate_beginning ? "..." : "";
95: 	string end_trunc = truncate_end ? "..." : "";
96: 
97: 	// get the render width of the error indicator (i.e. how many spaces we need to insert before the ^)
98: 	idx_t error_render_width = 0;
99: 	for (idx_t i = spos; i < epos; i++) {
100: 		error_render_width += render_widths[i];
101: 	}
102: 	error_render_width += line_indicator.size() + begin_trunc.size();
103: 
104: 	// now first print the error message plus the current line (or a subset of the line)
105: 	string result = error_message;
106: 	result += "\n" + line_indicator + begin_trunc + query.substr(start_pos, end_pos - start_pos) + end_trunc;
107: 	// print an arrow pointing at the error location
108: 	result += "\n" + string(error_render_width, ' ') + "^";
109: 	return result;
110: }
111: 
112: string QueryErrorContext::FormatErrorRecursive(const string &msg, vector<ExceptionFormatValue> &values) {
113: 	string error_message = ExceptionFormatValue::Format(msg, values);
114: 	if (!statement || query_location >= statement->query.size()) {
115: 		// no statement provided or query location out of range
116: 		return error_message;
117: 	}
118: 	return Format(statement->query, error_message, query_location);
119: }
120: 
121: } // namespace duckdb
[end of src/parser/query_error_context.cpp]
[start of src/planner/binder.cpp]
1: #include "duckdb/planner/binder.hpp"
2: 
3: #include "duckdb/parser/statement/list.hpp"
4: #include "duckdb/parser/query_node/select_node.hpp"
5: #include "duckdb/planner/bound_query_node.hpp"
6: #include "duckdb/planner/bound_tableref.hpp"
7: #include "duckdb/planner/expression.hpp"
8: #include "duckdb/planner/operator/logical_sample.hpp"
9: 
10: #include <algorithm>
11: 
12: namespace duckdb {
13: 
14: shared_ptr<Binder> Binder::CreateBinder(ClientContext &context, Binder *parent, bool inherit_ctes) {
15: 	return make_shared<Binder>(true, context, parent ? parent->shared_from_this() : nullptr, inherit_ctes);
16: }
17: 
18: Binder::Binder(bool, ClientContext &context, shared_ptr<Binder> parent_p, bool inherit_ctes_p)
19:     : context(context), read_only(true), requires_valid_transaction(true), allow_stream_result(false),
20:       parent(move(parent_p)), bound_tables(0), inherit_ctes(inherit_ctes_p) {
21: 	parameters = nullptr;
22: 	if (parent) {
23: 		// We have to inherit macro parameter bindings from the parent binder, if there is a parent.
24: 		macro_binding = parent->macro_binding;
25: 		if (inherit_ctes) {
26: 			// We have to inherit CTE bindings from the parent bind_context, if there is a parent.
27: 			bind_context.SetCTEBindings(parent->bind_context.GetCTEBindings());
28: 			bind_context.cte_references = parent->bind_context.cte_references;
29: 			parameters = parent->parameters;
30: 		}
31: 	}
32: }
33: 
34: BoundStatement Binder::Bind(SQLStatement &statement) {
35: 	root_statement = &statement;
36: 	switch (statement.type) {
37: 	case StatementType::SELECT_STATEMENT:
38: 		return Bind((SelectStatement &)statement);
39: 	case StatementType::INSERT_STATEMENT:
40: 		return Bind((InsertStatement &)statement);
41: 	case StatementType::COPY_STATEMENT:
42: 		return Bind((CopyStatement &)statement);
43: 	case StatementType::DELETE_STATEMENT:
44: 		return Bind((DeleteStatement &)statement);
45: 	case StatementType::UPDATE_STATEMENT:
46: 		return Bind((UpdateStatement &)statement);
47: 	case StatementType::RELATION_STATEMENT:
48: 		return Bind((RelationStatement &)statement);
49: 	case StatementType::CREATE_STATEMENT:
50: 		return Bind((CreateStatement &)statement);
51: 	case StatementType::DROP_STATEMENT:
52: 		return Bind((DropStatement &)statement);
53: 	case StatementType::ALTER_STATEMENT:
54: 		return Bind((AlterStatement &)statement);
55: 	case StatementType::TRANSACTION_STATEMENT:
56: 		return Bind((TransactionStatement &)statement);
57: 	case StatementType::PRAGMA_STATEMENT:
58: 		return Bind((PragmaStatement &)statement);
59: 	case StatementType::EXPLAIN_STATEMENT:
60: 		return Bind((ExplainStatement &)statement);
61: 	case StatementType::VACUUM_STATEMENT:
62: 		return Bind((VacuumStatement &)statement);
63: 	case StatementType::SHOW_STATEMENT:
64: 		return Bind((ShowStatement &)statement);
65: 	case StatementType::CALL_STATEMENT:
66: 		return Bind((CallStatement &)statement);
67: 	case StatementType::EXPORT_STATEMENT:
68: 		return Bind((ExportStatement &)statement);
69: 	case StatementType::SET_STATEMENT:
70: 		return Bind((SetStatement &)statement);
71: 	case StatementType::LOAD_STATEMENT:
72: 		return Bind((LoadStatement &)statement);
73: 	default:
74: 		throw NotImplementedException("Unimplemented statement type \"%s\" for Bind",
75: 		                              StatementTypeToString(statement.type));
76: 	}
77: }
78: 
79: unique_ptr<BoundQueryNode> Binder::BindNode(QueryNode &node) {
80: 	// first we visit the set of CTEs and add them to the bind context
81: 	for (auto &cte_it : node.cte_map) {
82: 		AddCTE(cte_it.first, cte_it.second.get());
83: 	}
84: 	// now we bind the node
85: 	unique_ptr<BoundQueryNode> result;
86: 	switch (node.type) {
87: 	case QueryNodeType::SELECT_NODE:
88: 		result = BindNode((SelectNode &)node);
89: 		break;
90: 	case QueryNodeType::RECURSIVE_CTE_NODE:
91: 		result = BindNode((RecursiveCTENode &)node);
92: 		break;
93: 	default:
94: 		D_ASSERT(node.type == QueryNodeType::SET_OPERATION_NODE);
95: 		result = BindNode((SetOperationNode &)node);
96: 		break;
97: 	}
98: 	return result;
99: }
100: 
101: BoundStatement Binder::Bind(QueryNode &node) {
102: 	auto bound_node = BindNode(node);
103: 
104: 	BoundStatement result;
105: 	result.names = bound_node->names;
106: 	result.types = bound_node->types;
107: 
108: 	// and plan it
109: 	result.plan = CreatePlan(*bound_node);
110: 	return result;
111: }
112: 
113: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundQueryNode &node) {
114: 	switch (node.type) {
115: 	case QueryNodeType::SELECT_NODE:
116: 		return CreatePlan((BoundSelectNode &)node);
117: 	case QueryNodeType::SET_OPERATION_NODE:
118: 		return CreatePlan((BoundSetOperationNode &)node);
119: 	case QueryNodeType::RECURSIVE_CTE_NODE:
120: 		return CreatePlan((BoundRecursiveCTENode &)node);
121: 	default:
122: 		throw Exception("Unsupported bound query node type");
123: 	}
124: }
125: 
126: unique_ptr<BoundTableRef> Binder::Bind(TableRef &ref) {
127: 	unique_ptr<BoundTableRef> result;
128: 	switch (ref.type) {
129: 	case TableReferenceType::BASE_TABLE:
130: 		result = Bind((BaseTableRef &)ref);
131: 		break;
132: 	case TableReferenceType::CROSS_PRODUCT:
133: 		result = Bind((CrossProductRef &)ref);
134: 		break;
135: 	case TableReferenceType::JOIN:
136: 		result = Bind((JoinRef &)ref);
137: 		break;
138: 	case TableReferenceType::SUBQUERY:
139: 		result = Bind((SubqueryRef &)ref);
140: 		break;
141: 	case TableReferenceType::EMPTY:
142: 		result = Bind((EmptyTableRef &)ref);
143: 		break;
144: 	case TableReferenceType::TABLE_FUNCTION:
145: 		result = Bind((TableFunctionRef &)ref);
146: 		break;
147: 	case TableReferenceType::EXPRESSION_LIST:
148: 		result = Bind((ExpressionListRef &)ref);
149: 		break;
150: 	default:
151: 		throw Exception("Unknown table ref type");
152: 	}
153: 	result->sample = move(ref.sample);
154: 	return result;
155: }
156: 
157: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundTableRef &ref) {
158: 	unique_ptr<LogicalOperator> root;
159: 	switch (ref.type) {
160: 	case TableReferenceType::BASE_TABLE:
161: 		root = CreatePlan((BoundBaseTableRef &)ref);
162: 		break;
163: 	case TableReferenceType::SUBQUERY:
164: 		root = CreatePlan((BoundSubqueryRef &)ref);
165: 		break;
166: 	case TableReferenceType::JOIN:
167: 		root = CreatePlan((BoundJoinRef &)ref);
168: 		break;
169: 	case TableReferenceType::CROSS_PRODUCT:
170: 		root = CreatePlan((BoundCrossProductRef &)ref);
171: 		break;
172: 	case TableReferenceType::TABLE_FUNCTION:
173: 		root = CreatePlan((BoundTableFunction &)ref);
174: 		break;
175: 	case TableReferenceType::EMPTY:
176: 		root = CreatePlan((BoundEmptyTableRef &)ref);
177: 		break;
178: 	case TableReferenceType::EXPRESSION_LIST:
179: 		root = CreatePlan((BoundExpressionListRef &)ref);
180: 		break;
181: 	case TableReferenceType::CTE:
182: 		root = CreatePlan((BoundCTERef &)ref);
183: 		break;
184: 	default:
185: 		throw Exception("Unsupported bound table ref type type");
186: 	}
187: 	// plan the sample clause
188: 	if (ref.sample) {
189: 		root = make_unique<LogicalSample>(move(ref.sample), move(root));
190: 	}
191: 	return root;
192: }
193: 
194: void Binder::AddCTE(const string &name, CommonTableExpressionInfo *info) {
195: 	D_ASSERT(info);
196: 	D_ASSERT(!name.empty());
197: 	auto entry = CTE_bindings.find(name);
198: 	if (entry != CTE_bindings.end()) {
199: 		throw BinderException("Duplicate CTE \"%s\" in query!", name);
200: 	}
201: 	CTE_bindings[name] = info;
202: }
203: 
204: CommonTableExpressionInfo *Binder::FindCTE(const string &name, bool skip) {
205: 	auto entry = CTE_bindings.find(name);
206: 	if (entry != CTE_bindings.end()) {
207: 		if (!skip || entry->second->query->node->type == QueryNodeType::RECURSIVE_CTE_NODE) {
208: 			return entry->second;
209: 		}
210: 	}
211: 	if (parent && inherit_ctes) {
212: 		return parent->FindCTE(name, name == alias);
213: 	}
214: 	return nullptr;
215: }
216: 
217: bool Binder::CTEIsAlreadyBound(CommonTableExpressionInfo *cte) {
218: 	if (bound_ctes.find(cte) != bound_ctes.end()) {
219: 		return true;
220: 	}
221: 	if (parent && inherit_ctes) {
222: 		return parent->CTEIsAlreadyBound(cte);
223: 	}
224: 	return false;
225: }
226: 
227: idx_t Binder::GenerateTableIndex() {
228: 	if (parent) {
229: 		return parent->GenerateTableIndex();
230: 	}
231: 	return bound_tables++;
232: }
233: 
234: void Binder::PushExpressionBinder(ExpressionBinder *binder) {
235: 	GetActiveBinders().push_back(binder);
236: }
237: 
238: void Binder::PopExpressionBinder() {
239: 	D_ASSERT(HasActiveBinder());
240: 	GetActiveBinders().pop_back();
241: }
242: 
243: void Binder::SetActiveBinder(ExpressionBinder *binder) {
244: 	D_ASSERT(HasActiveBinder());
245: 	GetActiveBinders().back() = binder;
246: }
247: 
248: ExpressionBinder *Binder::GetActiveBinder() {
249: 	return GetActiveBinders().back();
250: }
251: 
252: bool Binder::HasActiveBinder() {
253: 	return !GetActiveBinders().empty();
254: }
255: 
256: vector<ExpressionBinder *> &Binder::GetActiveBinders() {
257: 	if (parent) {
258: 		return parent->GetActiveBinders();
259: 	}
260: 	return active_binders;
261: }
262: 
263: void Binder::MoveCorrelatedExpressions(Binder &other) {
264: 	MergeCorrelatedColumns(other.correlated_columns);
265: 	other.correlated_columns.clear();
266: }
267: 
268: void Binder::MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other) {
269: 	for (idx_t i = 0; i < other.size(); i++) {
270: 		AddCorrelatedColumn(other[i]);
271: 	}
272: }
273: 
274: void Binder::AddCorrelatedColumn(const CorrelatedColumnInfo &info) {
275: 	// we only add correlated columns to the list if they are not already there
276: 	if (std::find(correlated_columns.begin(), correlated_columns.end(), info) == correlated_columns.end()) {
277: 		correlated_columns.push_back(info);
278: 	}
279: }
280: 
281: string Binder::FormatError(ParsedExpression &expr_context, const string &message) {
282: 	return FormatError(expr_context.query_location, message);
283: }
284: 
285: string Binder::FormatError(TableRef &ref_context, const string &message) {
286: 	return FormatError(ref_context.query_location, message);
287: }
288: 
289: string Binder::FormatError(idx_t query_location, const string &message) {
290: 	QueryErrorContext context(root_statement, query_location);
291: 	return context.FormatError(message);
292: }
293: 
294: } // namespace duckdb
[end of src/planner/binder.cpp]
[start of src/planner/binder/expression/bind_columnref_expression.cpp]
1: #include "duckdb/parser/expression/columnref_expression.hpp"
2: #include "duckdb/planner/binder.hpp"
3: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
4: #include "duckdb/planner/expression_binder.hpp"
5: #include "duckdb/parser/expression/operator_expression.hpp"
6: #include "duckdb/common/string_util.hpp"
7: 
8: namespace duckdb {
9: 
10: BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref, idx_t depth) {
11: 	D_ASSERT(!colref.column_name.empty());
12: 	// individual column reference
13: 	// resolve to either a base table or a subquery expression
14: 	if (colref.table_name.empty()) {
15: 		auto using_binding = binder.bind_context.GetUsingBinding(colref.column_name);
16: 		if (using_binding) {
17: 			// we are referencing a USING column
18: 			// check if we can refer to one of the base columns directly
19: 			unique_ptr<Expression> expression;
20: 			if (!using_binding->primary_binding.empty()) {
21: 				// we can! just assign the table name and re-bind
22: 				colref.table_name = using_binding->primary_binding;
23: 				return BindExpression(colref, depth);
24: 			} else {
25: 				// we cannot! we need to bind this as a coalesce between all the relevant columns
26: 				auto coalesce = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
27: 				for (auto &entry : using_binding->bindings) {
28: 					coalesce->children.push_back(make_unique<ColumnRefExpression>(colref.column_name, entry));
29: 				}
30: 				return BindExpression(*coalesce, depth);
31: 			}
32: 		}
33: 		// no table name: find a binding that contains this
34: 		if (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {
35: 			// priority to macro parameter bindings TODO: throw a warning when this name conflicts
36: 			colref.table_name = binder.macro_binding->alias;
37: 		} else {
38: 			colref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);
39: 		}
40: 		if (colref.table_name.empty()) {
41: 			auto similar_bindings = binder.bind_context.GetSimilarBindings(colref.column_name);
42: 			string candidate_str = StringUtil::CandidatesMessage(similar_bindings, "Candidate bindings");
43: 			return BindResult(
44: 			    binder.FormatError(colref, StringUtil::Format("Referenced column \"%s\" not found in FROM clause!%s",
45: 			                                                  colref.column_name.c_str(), candidate_str)));
46: 		}
47: 	}
48: 	// if it was a macro parameter, let macro_binding bind it to the argument
49: 	BindResult result = binder.macro_binding != nullptr && colref.table_name == binder.macro_binding->alias
50: 	                        ? binder.macro_binding->Bind(colref, depth)
51: 	                        : binder.bind_context.BindColumn(colref, depth);
52: 	if (!result.HasError()) {
53: 		bound_columns = true;
54: 	} else {
55: 		result.error = binder.FormatError(colref, result.error);
56: 	}
57: 	return result;
58: }
59: 
60: } // namespace duckdb
[end of src/planner/binder/expression/bind_columnref_expression.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: