{
  "repo": "duckdb/duckdb",
  "pull_number": 10176,
  "instance_id": "duckdb__duckdb-10176",
  "issue_numbers": [
    "10057",
    "10057"
  ],
  "base_commit": "d1f40567a54d4cf0e4b8da050190c233912b1678",
  "patch": "diff --git a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\nindex ce95ac73c208..91476fe021ee 100644\n--- a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\n@@ -21,8 +21,8 @@ class ColumnAliasBinder {\n public:\n \tColumnAliasBinder(BoundSelectNode &node, const case_insensitive_map_t<idx_t> &alias_map);\n \n-\tBindResult BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,\n-\t                     bool root_expression);\n+\tbool BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth, bool root_expression,\n+\t               BindResult &result);\n \n private:\n \tBoundSelectNode &node;\ndiff --git a/src/planner/expression_binder/column_alias_binder.cpp b/src/planner/expression_binder/column_alias_binder.cpp\nindex 7dace55c51e1..6496c919a887 100644\n--- a/src/planner/expression_binder/column_alias_binder.cpp\n+++ b/src/planner/expression_binder/column_alias_binder.cpp\n@@ -12,19 +12,22 @@ ColumnAliasBinder::ColumnAliasBinder(BoundSelectNode &node, const case_insensiti\n     : node(node), alias_map(alias_map), visited_select_indexes() {\n }\n \n-BindResult ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,\n-                                        bool root_expression) {\n+bool ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,\n+                                  bool root_expression, BindResult &result) {\n \tif (expr.IsQualified()) {\n-\t\treturn BindResult(StringUtil::Format(\"Alias %s cannot be qualified.\", expr.ToString()));\n+\t\t// qualified columns cannot be aliases\n+\t\treturn false;\n \t}\n \n \tauto alias_entry = alias_map.find(expr.column_names[0]);\n \tif (alias_entry == alias_map.end()) {\n-\t\treturn BindResult(StringUtil::Format(\"Alias %s is not found.\", expr.ToString()));\n+\t\t// no alias found\n+\t\treturn false;\n \t}\n \n \tif (visited_select_indexes.find(alias_entry->second) != visited_select_indexes.end()) {\n-\t\treturn BindResult(\"Cannot resolve self-referential alias\");\n+\t\t// self-referential alias cannot be resolved\n+\t\treturn false;\n \t}\n \n \t// found an alias: bind the alias expression\n@@ -33,9 +36,9 @@ BindResult ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, Colu\n \n \t// since the alias has been found, pass a depth of 0. See Issue 4978 (#16)\n \t// ColumnAliasBinders are only in Having, Qualify and Where Binders\n-\tauto result = enclosing_binder.BindExpression(expression, depth, root_expression);\n+\tresult = enclosing_binder.BindExpression(expression, depth, root_expression);\n \tvisited_select_indexes.erase(alias_entry->second);\n-\treturn result;\n+\treturn true;\n }\n \n } // namespace duckdb\ndiff --git a/src/planner/expression_binder/having_binder.cpp b/src/planner/expression_binder/having_binder.cpp\nindex a314c579d03a..4df16339e354 100644\n--- a/src/planner/expression_binder/having_binder.cpp\n+++ b/src/planner/expression_binder/having_binder.cpp\n@@ -17,17 +17,21 @@ HavingBinder::HavingBinder(Binder &binder, ClientContext &context, BoundSelectNo\n \n BindResult HavingBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {\n \tauto &expr = expr_ptr->Cast<ColumnRefExpression>();\n-\tauto alias_result = column_alias_binder.BindAlias(*this, expr, depth, root_expression);\n-\tif (!alias_result.HasError()) {\n+\tBindResult alias_result;\n+\tauto found_alias = column_alias_binder.BindAlias(*this, expr, depth, root_expression, alias_result);\n+\tif (found_alias) {\n \t\tif (depth > 0) {\n-\t\t\tthrow BinderException(\"Having clause cannot reference alias in correlated subquery\");\n+\t\t\tthrow BinderException(\"Having clause cannot reference alias \\\"%s\\\" in correlated subquery\",\n+\t\t\t                      expr.GetColumnName());\n \t\t}\n \t\treturn alias_result;\n \t}\n \n \tif (aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {\n \t\tif (depth > 0) {\n-\t\t\tthrow BinderException(\"Having clause cannot reference column in correlated subquery and group by all\");\n+\t\t\tthrow BinderException(\n+\t\t\t    \"Having clause cannot reference column \\\"%s\\\" in correlated subquery and group by all\",\n+\t\t\t    expr.GetColumnName());\n \t\t}\n \t\tauto expr = duckdb::BaseSelectBinder::BindExpression(expr_ptr, depth);\n \t\tif (expr.HasError()) {\ndiff --git a/src/planner/expression_binder/qualify_binder.cpp b/src/planner/expression_binder/qualify_binder.cpp\nindex 59a97e617770..ceaf916a9a8c 100644\n--- a/src/planner/expression_binder/qualify_binder.cpp\n+++ b/src/planner/expression_binder/qualify_binder.cpp\n@@ -22,8 +22,9 @@ BindResult QualifyBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr,\n \t\treturn result;\n \t}\n \n-\tauto alias_result = column_alias_binder.BindAlias(*this, expr, depth, root_expression);\n-\tif (!alias_result.HasError()) {\n+\tBindResult alias_result;\n+\tauto found_alias = column_alias_binder.BindAlias(*this, expr, depth, root_expression, alias_result);\n+\tif (found_alias) {\n \t\treturn alias_result;\n \t}\n \ndiff --git a/src/planner/expression_binder/where_binder.cpp b/src/planner/expression_binder/where_binder.cpp\nindex 182687f8347d..9c868f671664 100644\n--- a/src/planner/expression_binder/where_binder.cpp\n+++ b/src/planner/expression_binder/where_binder.cpp\n@@ -16,12 +16,11 @@ BindResult WhereBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, id\n \t\treturn result;\n \t}\n \n-\tBindResult alias_result = column_alias_binder->BindAlias(*this, expr, depth, root_expression);\n-\t// This code path cannot be exercised at thispoint. #1547 might change that.\n-\tif (!alias_result.HasError()) {\n+\tBindResult alias_result;\n+\tauto found_alias = column_alias_binder->BindAlias(*this, expr, depth, root_expression, alias_result);\n+\tif (found_alias) {\n \t\treturn alias_result;\n \t}\n-\n \treturn result;\n }\n \n",
  "test_patch": "diff --git a/test/fuzzer/pedro/having_subquery_failed_to_bind.test b/test/fuzzer/pedro/having_subquery_failed_to_bind.test\nindex ab4cc5bb1abf..a1ba16ac25a1 100644\n--- a/test/fuzzer/pedro/having_subquery_failed_to_bind.test\n+++ b/test/fuzzer/pedro/having_subquery_failed_to_bind.test\n@@ -13,7 +13,7 @@ cannot reference alias\n statement error\n SELECT count() as c0 FROM (SELECT 1) t1(c2) HAVING 1 = (SELECT c0 WHERE EXISTS (SELECT 1));\n ----\n-Binder Error: column c0 must appear in the GROUP BY clause or be used in an aggregate function\n+cannot reference alias\n \n statement error\n SELECT count() as c0 FROM (SELECT 1) t1(c2) GROUP BY c0 HAVING 1 = (SELECT c0 WHERE EXISTS (SELECT 1));\n@@ -29,9 +29,9 @@ CREATE TABLE t1 (c0 INT);\n statement error\n SELECT count(*) c1 HAVING EXISTS (SELECT 1 FROM t1 WHERE c1 BETWEEN c0 AND 0);\n ----\n-Binder Error: column c1 must appear in the GROUP BY clause or be used in an aggregate function\n+cannot reference alias\n \n statement error\n SELECT count(*) c1 HAVING EXISTS (SELECT 1 FROM t1 WHERE c1 = c0);\n ----\n-Binder Error: column c1 must appear in the GROUP BY clause or be used in an aggregate function\n+cannot reference alias\ndiff --git a/test/sql/binder/alias_error_10057.test b/test/sql/binder/alias_error_10057.test\nnew file mode 100644\nindex 000000000000..839967abb52b\n--- /dev/null\n+++ b/test/sql/binder/alias_error_10057.test\n@@ -0,0 +1,14 @@\n+# name: test/sql/binder/alias_error_10057.test\n+# description: Test old_implicit_cast setting\n+# group: [binder]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement error\n+with test_data as (\n+  select 'foo' as a\n+)\n+select test_data.foobar as new_column from test_data where new_column is not null;\n+----\n+foobar\n\\ No newline at end of file\n",
  "problem_statement": "Referencing a column from your SELECT clause, pointing at a non-existent upstream column, causes the wrong error message\n### What happens?\r\n\r\nError message is \"referenced column not found in FROM clause\", but should be \"column X does not exist\".\r\n\r\n### To Reproduce\r\n\r\nRun the following in any duckdb (I ran it in motherduck)\r\n\r\n```sql\r\nwith test_data as (\r\n  select 'foo' as a\r\n)\r\n\r\nselect test_data.foobar as new_column from test_data where new_column is not null;\r\n```\r\n\r\nThe trick is defining `new_column` as some sort of reference to a non-existent column in the upstream CTE.\r\n\r\nThe error message DuckDB returns is \"referenced column new_column not found in FROM clause\", which is not the case (caused me to pull my hair out wondering about mismatched DuckDB versions and stuff). The actual error is because there is no column named `foobar` in the `test_data` CTE.\r\n\r\n### OS:\r\n\r\nLinux x64\r\n\r\n### DuckDB Version:\r\n\r\n0.9.2\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nJason Raede\r\n\r\n### Affiliation:\r\n\r\nPliable\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\nReferencing a column from your SELECT clause, pointing at a non-existent upstream column, causes the wrong error message\n### What happens?\r\n\r\nError message is \"referenced column not found in FROM clause\", but should be \"column X does not exist\".\r\n\r\n### To Reproduce\r\n\r\nRun the following in any duckdb (I ran it in motherduck)\r\n\r\n```sql\r\nwith test_data as (\r\n  select 'foo' as a\r\n)\r\n\r\nselect test_data.foobar as new_column from test_data where new_column is not null;\r\n```\r\n\r\nThe trick is defining `new_column` as some sort of reference to a non-existent column in the upstream CTE.\r\n\r\nThe error message DuckDB returns is \"referenced column new_column not found in FROM clause\", which is not the case (caused me to pull my hair out wondering about mismatched DuckDB versions and stuff). The actual error is because there is no column named `foobar` in the `test_data` CTE.\r\n\r\n### OS:\r\n\r\nLinux x64\r\n\r\n### DuckDB Version:\r\n\r\n0.9.2\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nJason Raede\r\n\r\n### Affiliation:\r\n\r\nPliable\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2024-01-09T10:02:06Z"
}