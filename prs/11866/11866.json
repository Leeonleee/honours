{
  "repo": "duckdb/duckdb",
  "pull_number": 11866,
  "instance_id": "duckdb__duckdb-11866",
  "issue_numbers": [
    "11827"
  ],
  "base_commit": "5ee76435a2ff9aa77c714d8aa3d6155235779144",
  "patch": "diff --git a/src/include/duckdb/parser/expression/function_expression.hpp b/src/include/duckdb/parser/expression/function_expression.hpp\nindex 291883df656b..f78ae7fee073 100644\n--- a/src/include/duckdb/parser/expression/function_expression.hpp\n+++ b/src/include/duckdb/parser/expression/function_expression.hpp\n@@ -61,6 +61,9 @@ class FunctionExpression : public ParsedExpression {\n \n \tvoid Verify() const override;\n \n+\t//! Returns true, if the function has a lambda expression as a child.\n+\tbool IsLambdaFunction() const;\n+\n public:\n \ttemplate <class T, class BASE, class ORDER_MODIFIER = OrderModifier>\n \tstatic string ToString(const T &entry, const string &catalog, const string &schema, const string &function_name,\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 7bfd5a9393c0..addfe3864db4 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -137,10 +137,19 @@ class ExpressionBinder {\n \tvirtual BindResult BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth,\n \t                                  bool root_expression = false);\n \n-\t//! Recursively replaces macro parameters with the provided input parameters\n+\t//! FIXME: Generalise this for extensibility.\n+\t//! Recursively replaces macro parameters with the provided input parameters.\n \tvoid ReplaceMacroParameters(unique_ptr<ParsedExpression> &expr, vector<unordered_set<string>> &lambda_params);\n-\t//! Enables special-handling of lambda parameters by tracking them in the lambda_params vector\n+\t//! Enables special-handling of lambda parameters during macro replacement by tracking them in the lambda_params\n+\t//! vector.\n \tvoid ReplaceMacroParametersInLambda(FunctionExpression &function, vector<unordered_set<string>> &lambda_params);\n+\t//! Recursively qualifies column references in ON CONFLICT DO UPDATE SET expressions.\n+\tvoid DoUpdateSetQualify(unique_ptr<ParsedExpression> &expr, const string &table_name,\n+\t                        vector<unordered_set<string>> &lambda_params);\n+\t//! Enables special-handling of lambda parameters during ON CONFLICT TO UPDATE SET qualification by tracking them in\n+\t//! the lambda_params vector.\n+\tvoid DoUpdateSetQualifyInLambda(FunctionExpression &function, const string &table_name,\n+\t                                vector<unordered_set<string>> &lambda_params);\n \n \tstatic LogicalType GetExpressionReturnType(const Expression &expr);\n \n@@ -207,9 +216,6 @@ class ExpressionBinder {\n \n \t//! Returns true if the function name is an alias for the UNNEST function\n \tstatic bool IsUnnestFunction(const string &function_name);\n-\t//! Returns true, if the function contains a lambda expression and is not the '->>' operator\n-\tstatic bool IsLambdaFunction(const FunctionExpression &function);\n-\t//! Returns the bind result of binding a lambda or JSON function\n \tBindResult TryBindLambdaOrJson(FunctionExpression &function, idx_t depth, CatalogEntry &func);\n };\n \ndiff --git a/src/parser/expression/function_expression.cpp b/src/parser/expression/function_expression.cpp\nindex 1658d0a39e28..8cd5d4c70566 100644\n--- a/src/parser/expression/function_expression.cpp\n+++ b/src/parser/expression/function_expression.cpp\n@@ -95,4 +95,18 @@ void FunctionExpression::Verify() const {\n \tD_ASSERT(!function_name.empty());\n }\n \n+bool FunctionExpression::IsLambdaFunction() const {\n+\t// Ignore the ->> operator (JSON extension).\n+\tif (function_name == \"->>\") {\n+\t\treturn false;\n+\t}\n+\t// Check the children for lambda expressions.\n+\tfor (auto &child : children) {\n+\t\tif (child->expression_class == ExpressionClass::LAMBDA) {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\treturn false;\n+}\n+\n } // namespace duckdb\ndiff --git a/src/planner/binder/expression/bind_columnref_expression.cpp b/src/planner/binder/expression/bind_columnref_expression.cpp\nindex ce6cb104b723..94d926704415 100644\n--- a/src/planner/binder/expression/bind_columnref_expression.cpp\n+++ b/src/planner/binder/expression/bind_columnref_expression.cpp\n@@ -155,10 +155,9 @@ void ExpressionBinder::QualifyColumnNames(unique_ptr<ParsedExpression> &expr,\n \t\tbreak;\n \t}\n \tcase ExpressionType::FUNCTION: {\n-\t\t// special-handling for lambdas, which are inside function expressions,\n+\t\t// Special-handling for lambdas, which are inside function expressions.\n \t\tauto &function = expr->Cast<FunctionExpression>();\n-\t\tif (IsLambdaFunction(function)) {\n-\t\t\t// special case\n+\t\tif (function.IsLambdaFunction()) {\n \t\t\treturn QualifyColumnNamesInLambda(function, lambda_params);\n \t\t}\n \ndiff --git a/src/planner/binder/expression/bind_function_expression.cpp b/src/planner/binder/expression/bind_function_expression.cpp\nindex 8eb9a8904595..f1f137a834d3 100644\n--- a/src/planner/binder/expression/bind_function_expression.cpp\n+++ b/src/planner/binder/expression/bind_function_expression.cpp\n@@ -87,9 +87,7 @@ BindResult ExpressionBinder::BindExpression(FunctionExpression &function, idx_t\n \n \tswitch (func->type) {\n \tcase CatalogType::SCALAR_FUNCTION_ENTRY: {\n-\t\t// scalar function\n-\t\tif (IsLambdaFunction(function)) {\n-\t\t\t// special case\n+\t\tif (function.IsLambdaFunction()) {\n \t\t\treturn TryBindLambdaOrJson(function, depth, *func);\n \t\t}\n \t\treturn BindFunction(function, func->Cast<ScalarFunctionCatalogEntry>(), depth);\ndiff --git a/src/planner/binder/expression/bind_macro_expression.cpp b/src/planner/binder/expression/bind_macro_expression.cpp\nindex ced09d180289..d35d9a57973a 100644\n--- a/src/planner/binder/expression/bind_macro_expression.cpp\n+++ b/src/planner/binder/expression/bind_macro_expression.cpp\n@@ -14,19 +14,18 @@ void ExpressionBinder::ReplaceMacroParametersInLambda(FunctionExpression &functi\n \n \tfor (auto &child : function.children) {\n \t\tif (child->expression_class != ExpressionClass::LAMBDA) {\n-\t\t\t// not a lambda expression\n \t\t\tReplaceMacroParameters(child, lambda_params);\n \t\t\tcontinue;\n \t\t}\n \n-\t\t// special-handling for LHS lambda parameters\n-\t\t// we do not replace them, and we add them to the lambda_params vector\n+\t\t// Special-handling for LHS lambda parameters.\n+\t\t// We do not replace them, and we add them to the lambda_params vector.\n \t\tauto &lambda_expr = child->Cast<LambdaExpression>();\n \t\tstring error_message;\n \t\tauto column_ref_expressions = lambda_expr.ExtractColumnRefExpressions(error_message);\n \n \t\tif (!error_message.empty()) {\n-\t\t\t// possibly a JSON function, replace both LHS and RHS\n+\t\t\t// Possibly a JSON function, replace both LHS and RHS.\n \t\t\tParsedExpressionIterator::EnumerateChildren(*lambda_expr.lhs, [&](unique_ptr<ParsedExpression> &child) {\n \t\t\t\tReplaceMacroParameters(child, lambda_params);\n \t\t\t});\n@@ -36,21 +35,18 @@ void ExpressionBinder::ReplaceMacroParametersInLambda(FunctionExpression &functi\n \t\t\tcontinue;\n \t\t}\n \n-\t\t// push this level\n+\t\t// Push the lambda parameter names of this level.\n \t\tlambda_params.emplace_back();\n-\n-\t\t// push the lambda parameter names\n \t\tfor (const auto &column_ref_expr : column_ref_expressions) {\n \t\t\tconst auto &column_ref = column_ref_expr.get().Cast<ColumnRefExpression>();\n \t\t\tlambda_params.back().emplace(column_ref.GetName());\n \t\t}\n \n-\t\t// only replace in RHS\n+\t\t// Only replace in the RHS of the expression.\n \t\tParsedExpressionIterator::EnumerateChildren(*lambda_expr.expr, [&](unique_ptr<ParsedExpression> &child) {\n \t\t\tReplaceMacroParameters(child, lambda_params);\n \t\t});\n \n-\t\t// pop this level\n \t\tlambda_params.pop_back();\n \t}\n }\n@@ -60,10 +56,8 @@ void ExpressionBinder::ReplaceMacroParameters(unique_ptr<ParsedExpression> &expr\n \n \tswitch (expr->GetExpressionClass()) {\n \tcase ExpressionClass::COLUMN_REF: {\n-\t\t// if the expression is a parameter, replace it with its argument\n+\t\t// If the expression is a column reference, we replace it with its argument.\n \t\tauto &col_ref = expr->Cast<ColumnRefExpression>();\n-\n-\t\t// don't replace lambda parameters\n \t\tif (LambdaExpression::IsLambdaParameter(lambda_params, col_ref.GetName())) {\n \t\t\treturn;\n \t\t}\n@@ -84,10 +78,9 @@ void ExpressionBinder::ReplaceMacroParameters(unique_ptr<ParsedExpression> &expr\n \t\treturn;\n \t}\n \tcase ExpressionClass::FUNCTION: {\n-\t\t// special-handling for lambdas, which are inside function expressions,\n+\t\t// Special-handling for lambdas, which are inside function expressions.\n \t\tauto &function = expr->Cast<FunctionExpression>();\n-\t\tif (IsLambdaFunction(function)) {\n-\t\t\t// special case\n+\t\tif (function.IsLambdaFunction()) {\n \t\t\treturn ReplaceMacroParametersInLambda(function, lambda_params);\n \t\t}\n \t\tbreak;\n@@ -98,11 +91,10 @@ void ExpressionBinder::ReplaceMacroParameters(unique_ptr<ParsedExpression> &expr\n \t\t    *sq->node, [&](unique_ptr<ParsedExpression> &child) { ReplaceMacroParameters(child, lambda_params); });\n \t\tbreak;\n \t}\n-\tdefault: // fall through\n+\tdefault:\n \t\tbreak;\n \t}\n \n-\t// replace macro parameters in child expressions\n \tParsedExpressionIterator::EnumerateChildren(\n \t    *expr, [&](unique_ptr<ParsedExpression> &child) { ReplaceMacroParameters(child, lambda_params); });\n }\ndiff --git a/src/planner/binder/statement/bind_insert.cpp b/src/planner/binder/statement/bind_insert.cpp\nindex a979da57c649..ec565c56ac15 100644\n--- a/src/planner/binder/statement/bind_insert.cpp\n+++ b/src/planner/binder/statement/bind_insert.cpp\n@@ -1,5 +1,6 @@\n #include \"duckdb/catalog/catalog.hpp\"\n #include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/expression/function_expression.hpp\"\n #include \"duckdb/parser/statement/insert_statement.hpp\"\n #include \"duckdb/parser/query_node/select_node.hpp\"\n #include \"duckdb/parser/tableref/expressionlistref.hpp\"\n@@ -12,13 +13,10 @@\n #include \"duckdb/planner/operator/logical_dummy_scan.hpp\"\n #include \"duckdb/planner/operator/logical_projection.hpp\"\n #include \"duckdb/planner/expression_iterator.hpp\"\n-#include \"duckdb/planner/expression_binder/returning_binder.hpp\"\n #include \"duckdb/planner/expression_binder/where_binder.hpp\"\n #include \"duckdb/planner/expression_binder/update_binder.hpp\"\n-#include \"duckdb/planner/operator/logical_filter.hpp\"\n #include \"duckdb/parser/statement/update_statement.hpp\"\n #include \"duckdb/planner/expression/bound_default_expression.hpp\"\n-#include \"duckdb/storage/data_table.hpp\"\n #include \"duckdb/catalog/catalog_entry/index_catalog_entry.hpp\"\n #include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n #include \"duckdb/planner/bound_tableref.hpp\"\n@@ -54,18 +52,85 @@ void ReplaceDefaultExpression(unique_ptr<ParsedExpression> &expr, const ColumnDe\n \texpr = ExpandDefaultExpression(column);\n }\n \n-void QualifyColumnReferences(unique_ptr<ParsedExpression> &expr, const string &table_name) {\n-\t// To avoid ambiguity with 'excluded', we explicitly qualify all column references\n-\tif (expr->type == ExpressionType::COLUMN_REF) {\n-\t\tauto &column_ref = expr->Cast<ColumnRefExpression>();\n-\t\tif (column_ref.IsQualified()) {\n+void ExpressionBinder::DoUpdateSetQualifyInLambda(FunctionExpression &function, const string &table_name,\n+                                                  vector<unordered_set<string>> &lambda_params) {\n+\n+\tfor (auto &child : function.children) {\n+\t\tif (child->expression_class != ExpressionClass::LAMBDA) {\n+\t\t\tDoUpdateSetQualify(child, table_name, lambda_params);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t// Special-handling for LHS lambda parameters.\n+\t\t// We do not qualify them, and we add them to the lambda_params vector.\n+\t\tauto &lambda_expr = child->Cast<LambdaExpression>();\n+\t\tstring error_message;\n+\t\tauto column_ref_expressions = lambda_expr.ExtractColumnRefExpressions(error_message);\n+\n+\t\tif (!error_message.empty()) {\n+\t\t\t// Possibly a JSON function, qualify both LHS and RHS.\n+\t\t\tParsedExpressionIterator::EnumerateChildren(*lambda_expr.lhs, [&](unique_ptr<ParsedExpression> &child) {\n+\t\t\t\tDoUpdateSetQualify(child, table_name, lambda_params);\n+\t\t\t});\n+\t\t\tParsedExpressionIterator::EnumerateChildren(*lambda_expr.expr, [&](unique_ptr<ParsedExpression> &child) {\n+\t\t\t\tDoUpdateSetQualify(child, table_name, lambda_params);\n+\t\t\t});\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t// Push the lambda parameter names of this level.\n+\t\tlambda_params.emplace_back();\n+\t\tfor (const auto &column_ref_expr : column_ref_expressions) {\n+\t\t\tconst auto &column_ref = column_ref_expr.get().Cast<ColumnRefExpression>();\n+\t\t\tlambda_params.back().emplace(column_ref.GetName());\n+\t\t}\n+\n+\t\t// Only qualify in the RHS of the expression.\n+\t\tParsedExpressionIterator::EnumerateChildren(*lambda_expr.expr, [&](unique_ptr<ParsedExpression> &child) {\n+\t\t\tDoUpdateSetQualify(child, table_name, lambda_params);\n+\t\t});\n+\n+\t\tlambda_params.pop_back();\n+\t}\n+}\n+\n+void ExpressionBinder::DoUpdateSetQualify(unique_ptr<ParsedExpression> &expr, const string &table_name,\n+                                          vector<unordered_set<string>> &lambda_params) {\n+\n+\t// We avoid ambiguity with EXCLUDED columns by qualifying all column references.\n+\tswitch (expr->GetExpressionClass()) {\n+\tcase ExpressionClass::COLUMN_REF: {\n+\t\tauto &col_ref = expr->Cast<ColumnRefExpression>();\n+\t\tif (col_ref.IsQualified()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Don't qualify lambda parameters.\n+\t\tif (LambdaExpression::IsLambdaParameter(lambda_params, col_ref.GetName())) {\n \t\t\treturn;\n \t\t}\n-\t\tauto column_name = column_ref.GetColumnName();\n-\t\texpr = make_uniq<ColumnRefExpression>(column_name, table_name);\n+\n+\t\t// Qualify the column reference.\n+\t\texpr = make_uniq<ColumnRefExpression>(col_ref.GetColumnName(), table_name);\n+\t\treturn;\n+\t}\n+\tcase ExpressionClass::FUNCTION: {\n+\t\t// Special-handling for lambdas, which are inside function expressions.\n+\t\tauto &function = expr->Cast<FunctionExpression>();\n+\t\tif (function.IsLambdaFunction()) {\n+\t\t\treturn DoUpdateSetQualifyInLambda(function, table_name, lambda_params);\n+\t\t}\n+\t\tbreak;\n \t}\n+\tcase ExpressionClass::SUBQUERY: {\n+\t\tthrow BinderException(\"DO UPDATE SET clause cannot contain a subquery\");\n+\t}\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\n \tParsedExpressionIterator::EnumerateChildren(\n-\t    *expr, [&](unique_ptr<ParsedExpression> &child) { QualifyColumnReferences(child, table_name); });\n+\t    *expr, [&](unique_ptr<ParsedExpression> &child) { DoUpdateSetQualify(child, table_name, lambda_params); });\n }\n \n // Replace binding.table_index with 'dest' if it's 'source'\n@@ -110,18 +175,17 @@ void Binder::BindDoUpdateSetExpressions(const string &table_alias, LogicalInsert\n \t\tif (expr->type == ExpressionType::VALUE_DEFAULT) {\n \t\t\texpr = ExpandDefaultExpression(column);\n \t\t}\n-\t\tUpdateBinder binder(*this, context);\n-\t\tbinder.target_type = column.Type();\n \n-\t\t// Avoid ambiguity issues\n-\t\tQualifyColumnReferences(expr, table_alias);\n+\t\t// Qualify and bind the ON CONFLICT DO UPDATE SET expression.\n+\t\tUpdateBinder update_binder(*this, context);\n+\t\tupdate_binder.target_type = column.Type();\n \n-\t\tauto bound_expr = binder.Bind(expr);\n-\t\tD_ASSERT(bound_expr);\n-\t\tif (bound_expr->expression_class == ExpressionClass::BOUND_SUBQUERY) {\n-\t\t\tthrow BinderException(\"Expression in the DO UPDATE SET clause can not be a subquery\");\n-\t\t}\n+\t\t// Avoid ambiguity between existing table columns and EXCLUDED columns.\n+\t\tvector<unordered_set<string>> lambda_params;\n+\t\tupdate_binder.DoUpdateSetQualify(expr, table_alias, lambda_params);\n \n+\t\tauto bound_expr = update_binder.Bind(expr);\n+\t\tD_ASSERT(bound_expr);\n \t\tinsert.expressions.push_back(std::move(bound_expr));\n \t}\n \n@@ -293,18 +357,17 @@ void Binder::BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &tabl\n \tbind_context.AddGenericBinding(excluded_index, \"excluded\", table_column_names, table_column_types);\n \n \tif (on_conflict.condition) {\n-\t\t// Avoid ambiguity between <table_name> binding and 'excluded'\n-\t\tQualifyColumnReferences(on_conflict.condition, table_alias);\n-\t\t// Bind the ON CONFLICT ... WHERE clause\n \t\tWhereBinder where_binder(*this, context);\n+\n+\t\t// Avoid ambiguity between existing table columns and EXCLUDED columns.\n+\t\tvector<unordered_set<string>> lambda_params;\n+\t\twhere_binder.DoUpdateSetQualify(on_conflict.condition, table_alias, lambda_params);\n+\n+\t\t// Bind the ON CONFLICT ... WHERE clause.\n \t\tauto condition = where_binder.Bind(on_conflict.condition);\n-\t\tif (condition && condition->expression_class == ExpressionClass::BOUND_SUBQUERY) {\n-\t\t\tthrow BinderException(\"conflict_target WHERE clause can not be a subquery\");\n-\t\t}\n \t\tinsert.on_conflict_condition = std::move(condition);\n \t}\n \n-\tauto bindings = insert.children[0]->GetColumnBindings();\n \toptional_idx projection_index;\n \treference<vector<unique_ptr<LogicalOperator>>> insert_child_operators = insert.children;\n \twhile (!projection_index.IsValid()) {\n@@ -363,14 +426,14 @@ void Binder::BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &tabl\n \tD_ASSERT(set_info.columns.size() == set_info.expressions.size());\n \n \tif (set_info.condition) {\n-\t\t// Avoid ambiguity between <table_name> binding and 'excluded'\n-\t\tQualifyColumnReferences(set_info.condition, table_alias);\n-\t\t// Bind the SET ... WHERE clause\n \t\tWhereBinder where_binder(*this, context);\n+\n+\t\t// Avoid ambiguity between existing table columns and EXCLUDED columns.\n+\t\tvector<unordered_set<string>> lambda_params;\n+\t\twhere_binder.DoUpdateSetQualify(set_info.condition, table_alias, lambda_params);\n+\n+\t\t// Bind the SET ... WHERE clause.\n \t\tauto condition = where_binder.Bind(set_info.condition);\n-\t\tif (condition && condition->expression_class == ExpressionClass::BOUND_SUBQUERY) {\n-\t\t\tthrow BinderException(\"conflict_target WHERE clause can not be a subquery\");\n-\t\t}\n \t\tinsert.do_update_condition = std::move(condition);\n \t}\n \n@@ -487,7 +550,7 @@ BoundStatement Binder::Bind(InsertStatement &stmt) {\n \t\texpr_list.expected_types.resize(expected_columns);\n \t\texpr_list.expected_names.resize(expected_columns);\n \n-\t\tD_ASSERT(expr_list.values.size() > 0);\n+\t\tD_ASSERT(!expr_list.values.empty());\n \t\tCheckInsertColumnCountMismatch(expected_columns, expr_list.values[0].size(), !stmt.columns.empty(),\n \t\t                               table.name.c_str());\n \ndiff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp\nindex 649ab82a8b56..4551525b62c7 100644\n--- a/src/planner/expression_binder.cpp\n+++ b/src/planner/expression_binder.cpp\n@@ -286,16 +286,4 @@ bool ExpressionBinder::IsUnnestFunction(const string &function_name) {\n \treturn function_name == \"unnest\" || function_name == \"unlist\";\n }\n \n-bool ExpressionBinder::IsLambdaFunction(const FunctionExpression &function) {\n-\t// check for lambda parameters, ignore ->> operator (JSON extension)\n-\tif (function.function_name != \"->>\") {\n-\t\tfor (auto &child : function.children) {\n-\t\t\tif (child->expression_class == ExpressionClass::LAMBDA) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn false;\n-}\n-\n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/upsert/postgres/composite_key.test b/test/sql/upsert/postgres/composite_key.test\nindex 054c8077e695..fdf5db0780ed 100644\n--- a/test/sql/upsert/postgres/composite_key.test\n+++ b/test/sql/upsert/postgres/composite_key.test\n@@ -37,7 +37,7 @@ statement error\n insert into insertconflicttest\n values (0, 'Crowberry', 0) on conflict (key, fruit) do update set other = 1 where exists (select 1 from insertconflicttest ii where ii.key = excluded.key);\n ----\n-Binder Error: conflict_target WHERE clause can not be a subquery\n+DO UPDATE SET clause cannot contain a subquery\n \n # inference succeeds:\n \ndiff --git a/test/sql/upsert/upsert_lambda.test b/test/sql/upsert/upsert_lambda.test\nnew file mode 100644\nindex 000000000000..74f5fb7fd310\n--- /dev/null\n+++ b/test/sql/upsert/upsert_lambda.test\n@@ -0,0 +1,91 @@\n+# name: test/sql/upsert/upsert_lambda.test\n+# group: [upsert]\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+statement ok\n+CREATE OR REPLACE TABLE foo (\n+\tpk_col INT PRIMARY KEY,\n+\tstr VARCHAR,\n+\tstr_list VARCHAR[],\n+\tpayload_col INT\n+);\n+\n+statement ok\n+INSERT INTO foo\n+SELECT 1, 'hello', ['x', 'y', 'z'], 40\n+ON CONFLICT DO UPDATE SET\n+\tstr = list_reduce(EXCLUDED.str_list, (x, y) -> x || '||' || y);\n+\n+query IIII\n+FROM foo;\n+----\n+1\thello\t[x, y, z]\t40\n+\n+# Use the new (excluded) list as input.\n+\n+statement ok\n+INSERT INTO foo\n+SELECT 1, 'world', ['a', 'b', 'c'], 41\n+ON CONFLICT DO UPDATE SET\n+\tstr = list_reduce(EXCLUDED.str_list, (x, y) -> x || '||' || y);\n+\n+query IIII\n+FROM foo;\n+----\n+1\ta||b||c\t[x, y, z]\t40\n+\n+# Additionally update the payload.\n+\n+statement ok\n+INSERT INTO foo\n+SELECT 1, '', ['1', '2'], 42\n+ON CONFLICT DO UPDATE SET\n+  str = list_reduce(EXCLUDED.str_list, (x, y) -> x || '||' || y), \n+  payload_col = EXCLUDED.payload_col;\n+\n+query IIII\n+FROM foo;\n+----\n+1\t1||2\t[x, y, z]\t42\n+\n+# Use the existing list as input.\n+\n+statement ok\n+INSERT INTO foo\n+SELECT 1, '', ['l', 'm', 'n'], 43\n+ON CONFLICT DO UPDATE SET\n+  str = list_reduce(str_list, (x, y) -> x || '||' || y);\n+\n+query IIII\n+FROM foo;\n+----\n+1\tx||y||z\t[x, y, z]\t42\n+\n+# Reference the existing and the new (excluded) str column without qualification.\n+\n+statement ok\n+INSERT INTO foo\n+SELECT 1, 'world', ['s', 't'], 42\n+ON CONFLICT DO UPDATE SET\n+  str = list_reduce(EXCLUDED.str_list, (x, y) -> x || str || y || EXCLUDED.str);\n+\n+query IIII\n+FROM foo;\n+----\n+1\tsx||y||ztworld\t[x, y, z]\t42\n+\n+# Lambda function in the WHERE clause.\n+\n+statement ok\n+INSERT INTO foo\n+SELECT 1, 'motorcycle', ['brrr', 'brrrrrr'], 1042\n+ON CONFLICT DO UPDATE SET\n+  str = 'black-bellied whistling duck'\n+  WHERE list_reduce(EXCLUDED.str_list, (x, y) -> x || str || y || EXCLUDED.str) = 'brrrsx||y||ztworldbrrrrrrmotorcycle';\n+\n+query IIII\n+FROM foo;\n+----\n+1\tblack-bellied whistling duck\t[x, y, z]\t42\n",
  "problem_statement": "Incorrect binder error when a lambda is used inside `on conflict do update`.\n### What happens?\n\nWhen a lambda function is used inside the `on conflict` clause, a `Binder Error: Invalid lambda parameters! Parameters must be unqualified comma-separated names like x or (x, y).` always appears.\n\n### To Reproduce\n\n```sql\r\ncreate or replace table foo(bar int primary key, baz varchar);\r\n\r\ninsert into foo\r\nselect 1, ''\r\non conflict do\r\nupdate set\r\n  baz = list_reduce(\r\n    ['a', 'b', 'c'],\r\n    (x, y) -> x || ' || ' || y\r\n  )\r\n;\r\n```\r\n\r\n```\r\nBinder Error: Invalid lambda parameters! Parameters must be unqualified comma-separated names like x or (x, y).\r\n```\r\n\r\nOr\r\n\r\n```sql\r\n insert into foo\r\n select 1, ''\r\n on conflict do\r\n update set\r\n   baz = list_filter(\r\n     ['a', 'b', 'c'],\r\n     x -> x = 'a'\r\n   )[1]\r\n ;\r\n```\r\n\r\n```\r\nBinder Error: Invalid lambda parameters! Parameters must be unqualified comma-separated names like x or (x, y).\r\n```\n\n### OS:\n\nUbuntu x64 in WSL on Windows 11\n\n### DuckDB Version:\n\nv0.10.3-dev376 d7b9ca07f2\n\n### DuckDB Client:\n\ncli and python\n\n### Full Name:\n\nM\u00edma Hlav\u00e1\u010dek\n\n### Affiliation:\n\nBlindspot.ai\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a source build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-04-29T14:06:18Z"
}