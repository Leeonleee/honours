{
  "repo": "duckdb/duckdb",
  "pull_number": 4716,
  "instance_id": "duckdb__duckdb-4716",
  "issue_numbers": [
    "4699",
    "4699"
  ],
  "base_commit": "a5b74ff1cdd60c1a64c6a5ba41e57a2dc20336c0",
  "patch": "diff --git a/data/csv/[avalon]_daily-avg.csv b/data/csv/[avalon]_daily-avg.csv\nnew file mode 100644\nindex 000000000000..8fa66371b043\n--- /dev/null\n+++ b/data/csv/[avalon]_daily-avg.csv\n@@ -0,0 +1,4 @@\n+a\tb\tc\n+1\t2\t3\n+3\t4\t5\n+4\t5\t6\n\\ No newline at end of file\ndiff --git a/src/common/local_file_system.cpp b/src/common/local_file_system.cpp\nindex 6beca78a1ba5..74699d490e12 100644\n--- a/src/common/local_file_system.cpp\n+++ b/src/common/local_file_system.cpp\n@@ -847,6 +847,26 @@ static void GlobFiles(FileSystem &fs, const string &path, const string &glob, bo\n \t});\n }\n \n+vector<string> LocalFileSystem::FetchFileWithoutGlob(const string &path, FileOpener *opener, bool absolute_path) {\n+\tvector<string> result;\n+\tif (FileExists(path) || IsPipe(path)) {\n+\t\tresult.push_back(path);\n+\t} else if (!absolute_path) {\n+\t\tValue value;\n+\t\tif (opener->TryGetCurrentSetting(\"file_search_path\", value)) {\n+\t\t\tauto search_paths_str = value.ToString();\n+\t\t\tstd::vector<std::string> search_paths = StringUtil::Split(search_paths_str, ',');\n+\t\t\tfor (const auto &search_path : search_paths) {\n+\t\t\t\tauto joined_path = JoinPath(search_path, path);\n+\t\t\t\tif (FileExists(joined_path) || IsPipe(joined_path)) {\n+\t\t\t\t\tresult.push_back(joined_path);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn result;\n+}\n+\n vector<string> LocalFileSystem::Glob(const string &path, FileOpener *opener) {\n \tif (path.empty()) {\n \t\treturn vector<string>();\n@@ -893,23 +913,7 @@ vector<string> LocalFileSystem::Glob(const string &path, FileOpener *opener) {\n \t// Check if the path has a glob at all\n \tif (!HasGlob(path)) {\n \t\t// no glob: return only the file (if it exists or is a pipe)\n-\t\tvector<string> result;\n-\t\tif (FileExists(path) || IsPipe(path)) {\n-\t\t\tresult.push_back(path);\n-\t\t} else if (!absolute_path) {\n-\t\t\tValue value;\n-\t\t\tif (opener->TryGetCurrentSetting(\"file_search_path\", value)) {\n-\t\t\t\tauto search_paths_str = value.ToString();\n-\t\t\t\tstd::vector<std::string> search_paths = StringUtil::Split(search_paths_str, ',');\n-\t\t\t\tfor (const auto &search_path : search_paths) {\n-\t\t\t\t\tauto joined_path = JoinPath(search_path, path);\n-\t\t\t\t\tif (FileExists(joined_path) || IsPipe(joined_path)) {\n-\t\t\t\t\t\tresult.push_back(joined_path);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn result;\n+\t\treturn FetchFileWithoutGlob(path, opener, absolute_path);\n \t}\n \tvector<string> previous_directories;\n \tif (absolute_path) {\n@@ -943,7 +947,12 @@ vector<string> LocalFileSystem::Glob(const string &path, FileOpener *opener) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif (is_last_chunk || result.empty()) {\n+\t\tif (result.empty()) {\n+\t\t\t// no result found that matches the glob\n+\t\t\t// last ditch effort: search the path as a string literal\n+\t\t\treturn FetchFileWithoutGlob(path, opener, absolute_path);\n+\t\t}\n+\t\tif (is_last_chunk) {\n \t\t\treturn result;\n \t\t}\n \t\tprevious_directories = move(result);\ndiff --git a/src/include/duckdb/common/local_file_system.hpp b/src/include/duckdb/common/local_file_system.hpp\nindex 99cf4016fe80..b8a8e0d668eb 100644\n--- a/src/include/duckdb/common/local_file_system.hpp\n+++ b/src/include/duckdb/common/local_file_system.hpp\n@@ -92,6 +92,8 @@ class LocalFileSystem : public FileSystem {\n \t//! Set the file pointer of a file handle to a specified location. Reads and writes will happen from this location\n \tvoid SetFilePointer(FileHandle &handle, idx_t location);\n \tidx_t GetFilePointer(FileHandle &handle);\n+\n+\tvector<string> FetchFileWithoutGlob(const string &path, FileOpener *opener, bool absolute_path);\n };\n \n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/copy/csv/csv_glob_fallback.test b/test/sql/copy/csv/csv_glob_fallback.test\nnew file mode 100644\nindex 000000000000..fb2ff06f86df\n--- /dev/null\n+++ b/test/sql/copy/csv/csv_glob_fallback.test\n@@ -0,0 +1,16 @@\n+# name: test/sql/copy/csv/csv_glob_fallback.test\n+# description: Test glob fallback (#4699)\n+# group: [csv]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query III\n+SELECT * FROM 'data/csv/[avalon]_daily-avg.csv'\n+----\n+1\t2\t3\n+3\t4\t5\n+4\t5\t6\n+\n+statement error\n+SELECT * FROM 'data/csv/[avxalon]_daily-avg.csv'\n",
  "problem_statement": "Error: IO Error: No files found that match the pattern \"[Avalon]_daily-avg.csv\"\n### What happens?\n\nI am trying to load a CSV file named `[Avalon]_daily-avg.csv` with `SELECT * FROM '[Avalon]_daily-avg.csv';` but get the error `Error: IO Error: No files found that match the pattern \"[Avalon]_daily-avg.csv\"`. \n\n### To Reproduce\n\nRun `duckdb` and then the query above. \n\n### OS:\n\nmacOS\n\n### DuckDB Version:\n\nv0.5.0 109f932c4\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nDomini Moritz\n\n### Affiliation:\n\nCMU\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nError: IO Error: No files found that match the pattern \"[Avalon]_daily-avg.csv\"\n### What happens?\n\nI am trying to load a CSV file named `[Avalon]_daily-avg.csv` with `SELECT * FROM '[Avalon]_daily-avg.csv';` but get the error `Error: IO Error: No files found that match the pattern \"[Avalon]_daily-avg.csv\"`. \n\n### To Reproduce\n\nRun `duckdb` and then the query above. \n\n### OS:\n\nmacOS\n\n### DuckDB Version:\n\nv0.5.0 109f932c4\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nDomini Moritz\n\n### Affiliation:\n\nCMU\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Could be that it's interpreted as a regex pattern, in which case you might need to escape the `[` and `]` characters\r\n```sql\r\nSELECT * FROM '\\[Avalon\\]_daily-avg.csv';\r\n```\nI tried that but I don't seem to find the right escaping yet. \r\n\r\n<img width=\"683\" alt=\"Screenshot 2022-09-13 at 14 45 23\" src=\"https://user-images.githubusercontent.com/589034/189984722-3c19e5fc-b960-47fc-aca9-aa613f6e2953.png\">\r\n\nI think wrapping it in another set of brackets should work?\r\n[[Avalon]]_daily-avg.csv\r\n\nUnfortunately not\r\n\r\n<img width=\"702\" alt=\"Screenshot 2022-09-13 at 16 58 51\" src=\"https://user-images.githubusercontent.com/589034/190007988-3862ccc1-2a99-4ef1-a690-d02fe17366ed.png\">\r\n\nThe CSV reader use [glob syntax](https://duckdb.org/docs/sql/functions/patternmatching) - brackets signify \"use any character within these brackets\". The correct way to escape this is:\r\n\r\n```sql\r\nselect * from '[[]Avalon[]]_daily-avg.csv';\r\n```\r\n\r\nPerhaps we should add a fallback where if we no matches are found we try a literal pattern instead to avoid this problem in the future?\nThat would be a great UX improvement. Great idea! \n\nWhat happens if the glob matches multiple files? Do we get a union? \nYes, the CSV files will be unioned together provided they all share the same schema. You can use most standard globbing features including `*` to match multiple files.\r\n\r\nI would say for the fallback this only happens in case the glob matches no files.\nCould be that it's interpreted as a regex pattern, in which case you might need to escape the `[` and `]` characters\r\n```sql\r\nSELECT * FROM '\\[Avalon\\]_daily-avg.csv';\r\n```\nI tried that but I don't seem to find the right escaping yet. \r\n\r\n<img width=\"683\" alt=\"Screenshot 2022-09-13 at 14 45 23\" src=\"https://user-images.githubusercontent.com/589034/189984722-3c19e5fc-b960-47fc-aca9-aa613f6e2953.png\">\r\n\nI think wrapping it in another set of brackets should work?\r\n[[Avalon]]_daily-avg.csv\r\n\nUnfortunately not\r\n\r\n<img width=\"702\" alt=\"Screenshot 2022-09-13 at 16 58 51\" src=\"https://user-images.githubusercontent.com/589034/190007988-3862ccc1-2a99-4ef1-a690-d02fe17366ed.png\">\r\n\nThe CSV reader use [glob syntax](https://duckdb.org/docs/sql/functions/patternmatching) - brackets signify \"use any character within these brackets\". The correct way to escape this is:\r\n\r\n```sql\r\nselect * from '[[]Avalon[]]_daily-avg.csv';\r\n```\r\n\r\nPerhaps we should add a fallback where if we no matches are found we try a literal pattern instead to avoid this problem in the future?\nThat would be a great UX improvement. Great idea! \n\nWhat happens if the glob matches multiple files? Do we get a union? \nYes, the CSV files will be unioned together provided they all share the same schema. You can use most standard globbing features including `*` to match multiple files.\r\n\r\nI would say for the fallback this only happens in case the glob matches no files.",
  "created_at": "2022-09-14T13:03:43Z"
}