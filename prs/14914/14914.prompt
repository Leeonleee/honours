You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Multiple pivots prior to create call have wrong/unexpected behavior
### What happens?

when you run multiple pivot statements before turning their relations into tables, all but the last get clobbered with nonsense.
I'm running linux but the same problem occurs on windows.

details in reproduction code.

### To Reproduce

```python
# demonstrate bug
import numpy as np
import pandas as pd
import duckdb
N = 1000
df = pd.DataFrame({"a":np.random.choice(["u", "v", "w"], N, True),
                   "b":np.random.choice(["x", "y", "z"], N, True),
                   "c":np.random.randn(N),})
conn = duckdb.connect()

ddf = conn.from_df(df)
ddf.create("input_data")

xx = conn.query("pivot input_data on a using max(c) group by b;")
yy = conn.query("pivot input_data on b using max(c) group by a;")
xx.create("xx")
yy.create("yy")
print(conn.query("SHOW ALL TABLES;").df())
xx_table = conn.table("xx")
yy_table = conn.table("yy")
assert set(yy.columns)==set(yy_table.columns) # Succeeds.
assert set(xx.columns)==set(xx_table.columns)  # Fails. 
# xx_table shows up with cols [b, x, y, z] and all nans in the x,y,z cols
# The first col should indeed by b, but the next 3 should be u,v,w and they shouldn't have all nans
```

### OS:

Ubuntu 22.04.5 LTS x86_64

### DuckDB Version:

1.1.1

### DuckDB Client:

python

### Hardware:

_No response_

### Full Name:

Michael Hankin

### Affiliation:

Mothball Labs

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
Scoping problem with function argument
### What happens?

Somehow, `z` seems to disappear:
```sql
create or replace function demo(n, z) as table (
  select list_transform(range(0,n), x -> z) as row
);  

from demo(3,0);
```
```
Binder Error: Referenced column "z" not found in FROM clause!
```



### To Reproduce

```sql
create or replace function demo(n, z) as table (
  select list_transform(range(0,n), x -> z) as row
);  

from demo(3,0);
```

### OS:

macos

### DuckDB Version:

v1.0, v1.1.3-dev38 │

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

Peter Koppstein

### Affiliation:

Princeton University

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a source build

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
[CSV] INTERNAL Error: Attempted to dereference unique_ptr that is NULL!
### What happens?

INTERNAL Error: Attempted to dereference unique_ptr that is NULL!
This error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.
For more information, see https://duckdb.org/docs/dev/internal_errors

===csv2tsv.csv===
```
a,"
a,"b"
```

### To Reproduce

```
select version();
create or replace table t as
from read_csv('csv2tsv.csv',
   header=false,
   quote='"',
   escape = '"',
   sep=',',
   ignore_errors=true);
```


### OS:

MacOS

### DuckDB Version:

v1.1.3-dev119

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

Peter Koppstein

### Affiliation:

Princeton University

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a nightly build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
Multiple pivots prior to create call have wrong/unexpected behavior
### What happens?

when you run multiple pivot statements before turning their relations into tables, all but the last get clobbered with nonsense.
I'm running linux but the same problem occurs on windows.

details in reproduction code.

### To Reproduce

```python
# demonstrate bug
import numpy as np
import pandas as pd
import duckdb
N = 1000
df = pd.DataFrame({"a":np.random.choice(["u", "v", "w"], N, True),
                   "b":np.random.choice(["x", "y", "z"], N, True),
                   "c":np.random.randn(N),})
conn = duckdb.connect()

ddf = conn.from_df(df)
ddf.create("input_data")

xx = conn.query("pivot input_data on a using max(c) group by b;")
yy = conn.query("pivot input_data on b using max(c) group by a;")
xx.create("xx")
yy.create("yy")
print(conn.query("SHOW ALL TABLES;").df())
xx_table = conn.table("xx")
yy_table = conn.table("yy")
assert set(yy.columns)==set(yy_table.columns) # Succeeds.
assert set(xx.columns)==set(xx_table.columns)  # Fails. 
# xx_table shows up with cols [b, x, y, z] and all nans in the x,y,z cols
# The first col should indeed by b, but the next 3 should be u,v,w and they shouldn't have all nans
```

### OS:

Ubuntu 22.04.5 LTS x86_64

### DuckDB Version:

1.1.1

### DuckDB Client:

python

### Hardware:

_No response_

### Full Name:

Michael Hankin

### Affiliation:

Mothball Labs

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
INTERNAL error when using a macro to expand json[] array (`json_each`)
### What happens?

When I use the macro defined below with a `json[]` column, it errors out, but text and json types convert correctly.

INTERNAL Error: Failed to cast logical operator to type - logical operator type mismatch
This error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.
For more information, see https://duckdb.org/docs/dev/internal_errors

### To Reproduce

From the cli:
```sh
duckdb -c "
  CREATE OR REPLACE MACRO json_each(input) AS
    TABLE (
      SELECT
          CASE json_type (val::json)
          WHEN 'ARRAY' THEN
              unnest(RANGE (json_array_length(val::json)::bigint)) ::varchar
          ELSE
              unnest(json_keys (val::json))
          END AS key,
          json_extract (val::json, key) AS value
      FROM (SELECT input as val)
    );

  FROM (SELECT '[1,2,3]' as message) CROSS JOIN json_each(message);
  FROM (SELECT '[1,2,3]'::json as message) CROSS JOIN json_each(message);
  FROM (SELECT '[1,2,3]'::json[] as message) CROSS JOIN json_each(message);
  "
```

Output:
```
┌─────────┬─────────┬───────┐
│ message │   key   │ value │
│ varchar │ varchar │ json  │
├─────────┼─────────┼───────┤
│ [1,2,3] │ 0       │ 1     │
│ [1,2,3] │ 1       │ 2     │
│ [1,2,3] │ 2       │ 3     │
└─────────┴─────────┴───────┘
┌─────────┬─────────┬───────┐
│ message │   key   │ value │
│  json   │ varchar │ json  │
├─────────┼─────────┼───────┤
│ [1,2,3] │ 0       │ 1     │
│ [1,2,3] │ 1       │ 2     │
│ [1,2,3] │ 2       │ 3     │
└─────────┴─────────┴───────┘
INTERNAL Error: Failed to cast logical operator to type - logical operator type mismatch
This error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.
For more information, see https://duckdb.org/docs/dev/internal_errors
```

### OS:

linux

### DuckDB Version:

1.0.0, 1.1.0

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

Ashkan Kiani

### Affiliation:

Jane Street

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of extension/core_functions/aggregate/holistic/reservoir_quantile.cpp]
1: #include "duckdb/execution/expression_executor.hpp"
2: #include "duckdb/execution/reservoir_sample.hpp"
3: #include "core_functions/aggregate/holistic_functions.hpp"
4: #include "duckdb/planner/expression.hpp"
5: #include "duckdb/common/queue.hpp"
6: #include "duckdb/common/serializer/serializer.hpp"
7: #include "duckdb/common/serializer/deserializer.hpp"
8: 
9: #include <algorithm>
10: #include <stdlib.h>
11: 
12: namespace duckdb {
13: 
14: template <typename T>
15: struct ReservoirQuantileState {
16: 	T *v;
17: 	idx_t len;
18: 	idx_t pos;
19: 	BaseReservoirSampling *r_samp;
20: 
21: 	void Resize(idx_t new_len) {
22: 		if (new_len <= len) {
23: 			return;
24: 		}
25: 		T *old_v = v;
26: 		v = (T *)realloc(v, new_len * sizeof(T));
27: 		if (!v) {
28: 			free(old_v);
29: 			throw InternalException("Memory allocation failure");
30: 		}
31: 		len = new_len;
32: 	}
33: 
34: 	void ReplaceElement(T &input) {
35: 		v[r_samp->min_weighted_entry_index] = input;
36: 		r_samp->ReplaceElement();
37: 	}
38: 
39: 	void FillReservoir(idx_t sample_size, T element) {
40: 		if (pos < sample_size) {
41: 			v[pos++] = element;
42: 			r_samp->InitializeReservoir(pos, len);
43: 		} else {
44: 			D_ASSERT(r_samp->next_index_to_sample >= r_samp->num_entries_to_skip_b4_next_sample);
45: 			if (r_samp->next_index_to_sample == r_samp->num_entries_to_skip_b4_next_sample) {
46: 				ReplaceElement(element);
47: 			}
48: 		}
49: 	}
50: };
51: 
52: struct ReservoirQuantileBindData : public FunctionData {
53: 	ReservoirQuantileBindData() {
54: 	}
55: 	ReservoirQuantileBindData(double quantile_p, idx_t sample_size_p)
56: 	    : quantiles(1, quantile_p), sample_size(sample_size_p) {
57: 	}
58: 
59: 	ReservoirQuantileBindData(vector<double> quantiles_p, idx_t sample_size_p)
60: 	    : quantiles(std::move(quantiles_p)), sample_size(sample_size_p) {
61: 	}
62: 
63: 	unique_ptr<FunctionData> Copy() const override {
64: 		return make_uniq<ReservoirQuantileBindData>(quantiles, sample_size);
65: 	}
66: 
67: 	bool Equals(const FunctionData &other_p) const override {
68: 		auto &other = other_p.Cast<ReservoirQuantileBindData>();
69: 		return quantiles == other.quantiles && sample_size == other.sample_size;
70: 	}
71: 
72: 	static void Serialize(Serializer &serializer, const optional_ptr<FunctionData> bind_data_p,
73: 	                      const AggregateFunction &function) {
74: 		auto &bind_data = bind_data_p->Cast<ReservoirQuantileBindData>();
75: 		serializer.WriteProperty(100, "quantiles", bind_data.quantiles);
76: 		serializer.WriteProperty(101, "sample_size", bind_data.sample_size);
77: 	}
78: 
79: 	static unique_ptr<FunctionData> Deserialize(Deserializer &deserializer, AggregateFunction &function) {
80: 		auto result = make_uniq<ReservoirQuantileBindData>();
81: 		deserializer.ReadProperty(100, "quantiles", result->quantiles);
82: 		deserializer.ReadProperty(101, "sample_size", result->sample_size);
83: 		return std::move(result);
84: 	}
85: 
86: 	vector<double> quantiles;
87: 	idx_t sample_size;
88: };
89: 
90: struct ReservoirQuantileOperation {
91: 	template <class STATE>
92: 	static void Initialize(STATE &state) {
93: 		state.v = nullptr;
94: 		state.len = 0;
95: 		state.pos = 0;
96: 		state.r_samp = nullptr;
97: 	}
98: 
99: 	template <class INPUT_TYPE, class STATE, class OP>
100: 	static void ConstantOperation(STATE &state, const INPUT_TYPE &input, AggregateUnaryInput &unary_input,
101: 	                              idx_t count) {
102: 		for (idx_t i = 0; i < count; i++) {
103: 			Operation<INPUT_TYPE, STATE, OP>(state, input, unary_input);
104: 		}
105: 	}
106: 
107: 	template <class INPUT_TYPE, class STATE, class OP>
108: 	static void Operation(STATE &state, const INPUT_TYPE &input, AggregateUnaryInput &unary_input) {
109: 		auto &bind_data = unary_input.input.bind_data->template Cast<ReservoirQuantileBindData>();
110: 		if (state.pos == 0) {
111: 			state.Resize(bind_data.sample_size);
112: 		}
113: 		if (!state.r_samp) {
114: 			state.r_samp = new BaseReservoirSampling();
115: 		}
116: 		D_ASSERT(state.v);
117: 		state.FillReservoir(bind_data.sample_size, input);
118: 	}
119: 
120: 	template <class STATE, class OP>
121: 	static void Combine(const STATE &source, STATE &target, AggregateInputData &) {
122: 		if (source.pos == 0) {
123: 			return;
124: 		}
125: 		if (target.pos == 0) {
126: 			target.Resize(source.len);
127: 		}
128: 		if (!target.r_samp) {
129: 			target.r_samp = new BaseReservoirSampling();
130: 		}
131: 		for (idx_t src_idx = 0; src_idx < source.pos; src_idx++) {
132: 			target.FillReservoir(target.len, source.v[src_idx]);
133: 		}
134: 	}
135: 
136: 	template <class STATE>
137: 	static void Destroy(STATE &state, AggregateInputData &aggr_input_data) {
138: 		if (state.v) {
139: 			free(state.v);
140: 			state.v = nullptr;
141: 		}
142: 		if (state.r_samp) {
143: 			delete state.r_samp;
144: 			state.r_samp = nullptr;
145: 		}
146: 	}
147: 
148: 	static bool IgnoreNull() {
149: 		return true;
150: 	}
151: };
152: 
153: struct ReservoirQuantileScalarOperation : public ReservoirQuantileOperation {
154: 	template <class T, class STATE>
155: 	static void Finalize(STATE &state, T &target, AggregateFinalizeData &finalize_data) {
156: 		if (state.pos == 0) {
157: 			finalize_data.ReturnNull();
158: 			return;
159: 		}
160: 		D_ASSERT(state.v);
161: 		D_ASSERT(finalize_data.input.bind_data);
162: 		auto &bind_data = finalize_data.input.bind_data->template Cast<ReservoirQuantileBindData>();
163: 		auto v_t = state.v;
164: 		D_ASSERT(bind_data.quantiles.size() == 1);
165: 		auto offset = (idx_t)((double)(state.pos - 1) * bind_data.quantiles[0]);
166: 		std::nth_element(v_t, v_t + offset, v_t + state.pos);
167: 		target = v_t[offset];
168: 	}
169: };
170: 
171: AggregateFunction GetReservoirQuantileAggregateFunction(PhysicalType type) {
172: 	switch (type) {
173: 	case PhysicalType::INT8:
174: 		return AggregateFunction::UnaryAggregateDestructor<ReservoirQuantileState<int8_t>, int8_t, int8_t,
175: 		                                                   ReservoirQuantileScalarOperation>(LogicalType::TINYINT,
176: 		                                                                                     LogicalType::TINYINT);
177: 
178: 	case PhysicalType::INT16:
179: 		return AggregateFunction::UnaryAggregateDestructor<ReservoirQuantileState<int16_t>, int16_t, int16_t,
180: 		                                                   ReservoirQuantileScalarOperation>(LogicalType::SMALLINT,
181: 		                                                                                     LogicalType::SMALLINT);
182: 
183: 	case PhysicalType::INT32:
184: 		return AggregateFunction::UnaryAggregateDestructor<ReservoirQuantileState<int32_t>, int32_t, int32_t,
185: 		                                                   ReservoirQuantileScalarOperation>(LogicalType::INTEGER,
186: 		                                                                                     LogicalType::INTEGER);
187: 
188: 	case PhysicalType::INT64:
189: 		return AggregateFunction::UnaryAggregateDestructor<ReservoirQuantileState<int64_t>, int64_t, int64_t,
190: 		                                                   ReservoirQuantileScalarOperation>(LogicalType::BIGINT,
191: 		                                                                                     LogicalType::BIGINT);
192: 
193: 	case PhysicalType::INT128:
194: 		return AggregateFunction::UnaryAggregateDestructor<ReservoirQuantileState<hugeint_t>, hugeint_t, hugeint_t,
195: 		                                                   ReservoirQuantileScalarOperation>(LogicalType::HUGEINT,
196: 		                                                                                     LogicalType::HUGEINT);
197: 	case PhysicalType::FLOAT:
198: 		return AggregateFunction::UnaryAggregateDestructor<ReservoirQuantileState<float>, float, float,
199: 		                                                   ReservoirQuantileScalarOperation>(LogicalType::FLOAT,
200: 		                                                                                     LogicalType::FLOAT);
201: 	case PhysicalType::DOUBLE:
202: 		return AggregateFunction::UnaryAggregateDestructor<ReservoirQuantileState<double>, double, double,
203: 		                                                   ReservoirQuantileScalarOperation>(LogicalType::DOUBLE,
204: 		                                                                                     LogicalType::DOUBLE);
205: 	default:
206: 		throw InternalException("Unimplemented reservoir quantile aggregate");
207: 	}
208: }
209: 
210: template <class CHILD_TYPE>
211: struct ReservoirQuantileListOperation : public ReservoirQuantileOperation {
212: 	template <class T, class STATE>
213: 	static void Finalize(STATE &state, T &target, AggregateFinalizeData &finalize_data) {
214: 		if (state.pos == 0) {
215: 			finalize_data.ReturnNull();
216: 			return;
217: 		}
218: 
219: 		D_ASSERT(finalize_data.input.bind_data);
220: 		auto &bind_data = finalize_data.input.bind_data->template Cast<ReservoirQuantileBindData>();
221: 
222: 		auto &result = ListVector::GetEntry(finalize_data.result);
223: 		auto ridx = ListVector::GetListSize(finalize_data.result);
224: 		ListVector::Reserve(finalize_data.result, ridx + bind_data.quantiles.size());
225: 		auto rdata = FlatVector::GetData<CHILD_TYPE>(result);
226: 
227: 		auto v_t = state.v;
228: 		D_ASSERT(v_t);
229: 
230: 		auto &entry = target;
231: 		entry.offset = ridx;
232: 		entry.length = bind_data.quantiles.size();
233: 		for (size_t q = 0; q < entry.length; ++q) {
234: 			const auto &quantile = bind_data.quantiles[q];
235: 			auto offset = (idx_t)((double)(state.pos - 1) * quantile);
236: 			std::nth_element(v_t, v_t + offset, v_t + state.pos);
237: 			rdata[ridx + q] = v_t[offset];
238: 		}
239: 
240: 		ListVector::SetListSize(finalize_data.result, entry.offset + entry.length);
241: 	}
242: };
243: 
244: template <class STATE, class INPUT_TYPE, class RESULT_TYPE, class OP>
245: static AggregateFunction ReservoirQuantileListAggregate(const LogicalType &input_type, const LogicalType &child_type) {
246: 	LogicalType result_type = LogicalType::LIST(child_type);
247: 	return AggregateFunction(
248: 	    {input_type}, result_type, AggregateFunction::StateSize<STATE>, AggregateFunction::StateInitialize<STATE, OP>,
249: 	    AggregateFunction::UnaryScatterUpdate<STATE, INPUT_TYPE, OP>, AggregateFunction::StateCombine<STATE, OP>,
250: 	    AggregateFunction::StateFinalize<STATE, RESULT_TYPE, OP>, AggregateFunction::UnaryUpdate<STATE, INPUT_TYPE, OP>,
251: 	    nullptr, AggregateFunction::StateDestroy<STATE, OP>);
252: }
253: 
254: template <typename INPUT_TYPE, typename SAVE_TYPE>
255: AggregateFunction GetTypedReservoirQuantileListAggregateFunction(const LogicalType &type) {
256: 	using STATE = ReservoirQuantileState<SAVE_TYPE>;
257: 	using OP = ReservoirQuantileListOperation<INPUT_TYPE>;
258: 	auto fun = ReservoirQuantileListAggregate<STATE, INPUT_TYPE, list_entry_t, OP>(type, type);
259: 	return fun;
260: }
261: 
262: AggregateFunction GetReservoirQuantileListAggregateFunction(const LogicalType &type) {
263: 	switch (type.id()) {
264: 	case LogicalTypeId::TINYINT:
265: 		return GetTypedReservoirQuantileListAggregateFunction<int8_t, int8_t>(type);
266: 	case LogicalTypeId::SMALLINT:
267: 		return GetTypedReservoirQuantileListAggregateFunction<int16_t, int16_t>(type);
268: 	case LogicalTypeId::INTEGER:
269: 		return GetTypedReservoirQuantileListAggregateFunction<int32_t, int32_t>(type);
270: 	case LogicalTypeId::BIGINT:
271: 		return GetTypedReservoirQuantileListAggregateFunction<int64_t, int64_t>(type);
272: 	case LogicalTypeId::HUGEINT:
273: 		return GetTypedReservoirQuantileListAggregateFunction<hugeint_t, hugeint_t>(type);
274: 	case LogicalTypeId::FLOAT:
275: 		return GetTypedReservoirQuantileListAggregateFunction<float, float>(type);
276: 	case LogicalTypeId::DOUBLE:
277: 		return GetTypedReservoirQuantileListAggregateFunction<double, double>(type);
278: 	case LogicalTypeId::DECIMAL:
279: 		switch (type.InternalType()) {
280: 		case PhysicalType::INT16:
281: 			return GetTypedReservoirQuantileListAggregateFunction<int16_t, int16_t>(type);
282: 		case PhysicalType::INT32:
283: 			return GetTypedReservoirQuantileListAggregateFunction<int32_t, int32_t>(type);
284: 		case PhysicalType::INT64:
285: 			return GetTypedReservoirQuantileListAggregateFunction<int64_t, int64_t>(type);
286: 		case PhysicalType::INT128:
287: 			return GetTypedReservoirQuantileListAggregateFunction<hugeint_t, hugeint_t>(type);
288: 		default:
289: 			throw NotImplementedException("Unimplemented reservoir quantile list aggregate");
290: 		}
291: 	default:
292: 		// TODO: Add quantitative temporal types
293: 		throw NotImplementedException("Unimplemented reservoir quantile list aggregate");
294: 	}
295: }
296: 
297: static double CheckReservoirQuantile(const Value &quantile_val) {
298: 	if (quantile_val.IsNull()) {
299: 		throw BinderException("RESERVOIR_QUANTILE QUANTILE parameter cannot be NULL");
300: 	}
301: 	auto quantile = quantile_val.GetValue<double>();
302: 	if (quantile < 0 || quantile > 1) {
303: 		throw BinderException("RESERVOIR_QUANTILE can only take parameters in the range [0, 1]");
304: 	}
305: 	return quantile;
306: }
307: 
308: unique_ptr<FunctionData> BindReservoirQuantile(ClientContext &context, AggregateFunction &function,
309:                                                vector<unique_ptr<Expression>> &arguments) {
310: 	D_ASSERT(arguments.size() >= 2);
311: 	if (arguments[1]->HasParameter()) {
312: 		throw ParameterNotResolvedException();
313: 	}
314: 	if (!arguments[1]->IsFoldable()) {
315: 		throw BinderException("RESERVOIR_QUANTILE can only take constant quantile parameters");
316: 	}
317: 	Value quantile_val = ExpressionExecutor::EvaluateScalar(context, *arguments[1]);
318: 	vector<double> quantiles;
319: 	if (quantile_val.type().id() != LogicalTypeId::LIST) {
320: 		quantiles.push_back(CheckReservoirQuantile(quantile_val));
321: 	} else {
322: 		for (const auto &element_val : ListValue::GetChildren(quantile_val)) {
323: 			quantiles.push_back(CheckReservoirQuantile(element_val));
324: 		}
325: 	}
326: 
327: 	if (arguments.size() == 2) {
328: 		// remove the quantile argument so we can use the unary aggregate
329: 		if (function.arguments.size() == 2) {
330: 			Function::EraseArgument(function, arguments, arguments.size() - 1);
331: 		} else {
332: 			arguments.pop_back();
333: 		}
334: 		return make_uniq<ReservoirQuantileBindData>(quantiles, 8192ULL);
335: 	}
336: 	if (!arguments[2]->IsFoldable()) {
337: 		throw BinderException("RESERVOIR_QUANTILE can only take constant sample size parameters");
338: 	}
339: 	Value sample_size_val = ExpressionExecutor::EvaluateScalar(context, *arguments[2]);
340: 	if (sample_size_val.IsNull()) {
341: 		throw BinderException("Size of the RESERVOIR_QUANTILE sample cannot be NULL");
342: 	}
343: 	auto sample_size = sample_size_val.GetValue<int32_t>();
344: 
345: 	if (sample_size_val.IsNull() || sample_size <= 0) {
346: 		throw BinderException("Size of the RESERVOIR_QUANTILE sample must be bigger than 0");
347: 	}
348: 
349: 	// remove the quantile arguments so we can use the unary aggregate
350: 	if (function.arguments.size() == arguments.size()) {
351: 		Function::EraseArgument(function, arguments, arguments.size() - 1);
352: 		Function::EraseArgument(function, arguments, arguments.size() - 1);
353: 	} else {
354: 		arguments.pop_back();
355: 		arguments.pop_back();
356: 	}
357: 	return make_uniq<ReservoirQuantileBindData>(quantiles, NumericCast<idx_t>(sample_size));
358: }
359: 
360: unique_ptr<FunctionData> BindReservoirQuantileDecimal(ClientContext &context, AggregateFunction &function,
361:                                                       vector<unique_ptr<Expression>> &arguments) {
362: 	function = GetReservoirQuantileAggregateFunction(arguments[0]->return_type.InternalType());
363: 	auto bind_data = BindReservoirQuantile(context, function, arguments);
364: 	function.name = "reservoir_quantile";
365: 	function.serialize = ReservoirQuantileBindData::Serialize;
366: 	function.deserialize = ReservoirQuantileBindData::Deserialize;
367: 	return bind_data;
368: }
369: 
370: AggregateFunction GetReservoirQuantileAggregate(PhysicalType type) {
371: 	auto fun = GetReservoirQuantileAggregateFunction(type);
372: 	fun.bind = BindReservoirQuantile;
373: 	fun.serialize = ReservoirQuantileBindData::Serialize;
374: 	fun.deserialize = ReservoirQuantileBindData::Deserialize;
375: 	// temporarily push an argument so we can bind the actual quantile
376: 	fun.arguments.emplace_back(LogicalType::DOUBLE);
377: 	return fun;
378: }
379: 
380: unique_ptr<FunctionData> BindReservoirQuantileDecimalList(ClientContext &context, AggregateFunction &function,
381:                                                           vector<unique_ptr<Expression>> &arguments) {
382: 	function = GetReservoirQuantileListAggregateFunction(arguments[0]->return_type);
383: 	auto bind_data = BindReservoirQuantile(context, function, arguments);
384: 	function.serialize = ReservoirQuantileBindData::Serialize;
385: 	function.deserialize = ReservoirQuantileBindData::Deserialize;
386: 	function.name = "reservoir_quantile";
387: 	return bind_data;
388: }
389: 
390: AggregateFunction GetReservoirQuantileListAggregate(const LogicalType &type) {
391: 	auto fun = GetReservoirQuantileListAggregateFunction(type);
392: 	fun.bind = BindReservoirQuantile;
393: 	fun.serialize = ReservoirQuantileBindData::Serialize;
394: 	fun.deserialize = ReservoirQuantileBindData::Deserialize;
395: 	// temporarily push an argument so we can bind the actual quantile
396: 	auto list_of_double = LogicalType::LIST(LogicalType::DOUBLE);
397: 	fun.arguments.push_back(list_of_double);
398: 	return fun;
399: }
400: 
401: static void DefineReservoirQuantile(AggregateFunctionSet &set, const LogicalType &type) {
402: 	//	Four versions: type, scalar/list[, count]
403: 	auto fun = GetReservoirQuantileAggregate(type.InternalType());
404: 	set.AddFunction(fun);
405: 
406: 	fun.arguments.emplace_back(LogicalType::INTEGER);
407: 	set.AddFunction(fun);
408: 
409: 	// List variants
410: 	fun = GetReservoirQuantileListAggregate(type);
411: 	set.AddFunction(fun);
412: 
413: 	fun.arguments.emplace_back(LogicalType::INTEGER);
414: 	set.AddFunction(fun);
415: }
416: 
417: static void GetReservoirQuantileDecimalFunction(AggregateFunctionSet &set, const vector<LogicalType> &arguments,
418:                                                 const LogicalType &return_value) {
419: 	AggregateFunction fun(arguments, return_value, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
420: 	                      BindReservoirQuantileDecimal);
421: 	fun.serialize = ReservoirQuantileBindData::Serialize;
422: 	fun.deserialize = ReservoirQuantileBindData::Deserialize;
423: 	set.AddFunction(fun);
424: 
425: 	fun.arguments.emplace_back(LogicalType::INTEGER);
426: 	set.AddFunction(fun);
427: }
428: 
429: AggregateFunctionSet ReservoirQuantileFun::GetFunctions() {
430: 	AggregateFunctionSet reservoir_quantile;
431: 
432: 	// DECIMAL
433: 	GetReservoirQuantileDecimalFunction(reservoir_quantile, {LogicalTypeId::DECIMAL, LogicalType::DOUBLE},
434: 	                                    LogicalTypeId::DECIMAL);
435: 	GetReservoirQuantileDecimalFunction(reservoir_quantile,
436: 	                                    {LogicalTypeId::DECIMAL, LogicalType::LIST(LogicalType::DOUBLE)},
437: 	                                    LogicalType::LIST(LogicalTypeId::DECIMAL));
438: 
439: 	DefineReservoirQuantile(reservoir_quantile, LogicalTypeId::TINYINT);
440: 	DefineReservoirQuantile(reservoir_quantile, LogicalTypeId::SMALLINT);
441: 	DefineReservoirQuantile(reservoir_quantile, LogicalTypeId::INTEGER);
442: 	DefineReservoirQuantile(reservoir_quantile, LogicalTypeId::BIGINT);
443: 	DefineReservoirQuantile(reservoir_quantile, LogicalTypeId::HUGEINT);
444: 	DefineReservoirQuantile(reservoir_quantile, LogicalTypeId::FLOAT);
445: 	DefineReservoirQuantile(reservoir_quantile, LogicalTypeId::DOUBLE);
446: 	return reservoir_quantile;
447: }
448: 
449: } // namespace duckdb
[end of extension/core_functions/aggregate/holistic/reservoir_quantile.cpp]
[start of src/catalog/catalog_entry/duck_table_entry.cpp]
1: #include "duckdb/catalog/catalog_entry/duck_table_entry.hpp"
2: 
3: #include "duckdb/common/enum_util.hpp"
4: #include "duckdb/common/exception/transaction_exception.hpp"
5: #include "duckdb/common/index_map.hpp"
6: #include "duckdb/execution/index/art/art.hpp"
7: #include "duckdb/function/table/table_scan.hpp"
8: #include "duckdb/main/database.hpp"
9: #include "duckdb/parser/constraints/list.hpp"
10: #include "duckdb/parser/parsed_data/comment_on_column_info.hpp"
11: #include "duckdb/parser/parsed_expression_iterator.hpp"
12: #include "duckdb/planner/binder.hpp"
13: #include "duckdb/planner/constraints/bound_check_constraint.hpp"
14: #include "duckdb/planner/constraints/bound_foreign_key_constraint.hpp"
15: #include "duckdb/planner/constraints/bound_not_null_constraint.hpp"
16: #include "duckdb/planner/constraints/bound_unique_constraint.hpp"
17: #include "duckdb/planner/expression/bound_reference_expression.hpp"
18: #include "duckdb/planner/expression_binder/alter_binder.hpp"
19: #include "duckdb/planner/operator/logical_get.hpp"
20: #include "duckdb/planner/operator/logical_projection.hpp"
21: #include "duckdb/planner/operator/logical_update.hpp"
22: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
23: #include "duckdb/storage/storage_manager.hpp"
24: #include "duckdb/storage/table_storage_info.hpp"
25: 
26: namespace duckdb {
27: 
28: IndexStorageInfo GetIndexInfo(const IndexConstraintType type, const bool v1_0_0_storage, unique_ptr<CreateInfo> &info,
29:                               const idx_t id) {
30: 
31: 	auto &table_info = info->Cast<CreateTableInfo>();
32: 	auto constraint_name = EnumUtil::ToString(type) + "_";
33: 	auto name = constraint_name + table_info.table + "_" + to_string(id);
34: 	IndexStorageInfo index_info(name);
35: 	if (!v1_0_0_storage) {
36: 		index_info.options.emplace("v1_0_0_storage", v1_0_0_storage);
37: 	}
38: 	return index_info;
39: }
40: 
41: DuckTableEntry::DuckTableEntry(Catalog &catalog, SchemaCatalogEntry &schema, BoundCreateTableInfo &info,
42:                                shared_ptr<DataTable> inherited_storage)
43:     : TableCatalogEntry(catalog, schema, info.Base()), storage(std::move(inherited_storage)),
44:       column_dependency_manager(std::move(info.column_dependency_manager)) {
45: 
46: 	if (storage) {
47: 		if (!info.indexes.empty()) {
48: 			storage->SetIndexStorageInfo(std::move(info.indexes));
49: 		}
50: 		return;
51: 	}
52: 
53: 	// create the physical storage
54: 	vector<ColumnDefinition> column_defs;
55: 	for (auto &col_def : columns.Physical()) {
56: 		column_defs.push_back(col_def.Copy());
57: 	}
58: 	storage = make_shared_ptr<DataTable>(catalog.GetAttached(), StorageManager::Get(catalog).GetTableIOManager(&info),
59: 	                                     schema.name, name, std::move(column_defs), std::move(info.data));
60: 
61: 	// Create the unique indexes for the UNIQUE, PRIMARY KEY, and FOREIGN KEY constraints.
62: 	idx_t indexes_idx = 0;
63: 	for (idx_t i = 0; i < constraints.size(); i++) {
64: 		auto &constraint = constraints[i];
65: 		if (constraint->type == ConstraintType::UNIQUE) {
66: 
67: 			// UNIQUE constraint: Create a unique index.
68: 			auto &unique = constraint->Cast<UniqueConstraint>();
69: 			IndexConstraintType constraint_type = IndexConstraintType::UNIQUE;
70: 			if (unique.is_primary_key) {
71: 				constraint_type = IndexConstraintType::PRIMARY;
72: 			}
73: 
74: 			auto column_indexes = unique.GetLogicalIndexes(columns);
75: 			if (info.indexes.empty()) {
76: 				auto index_info = GetIndexInfo(constraint_type, false, info.base, i);
77: 				storage->AddIndex(columns, column_indexes, constraint_type, index_info);
78: 				continue;
79: 			}
80: 
81: 			// We read the index from an old storage version applying a dummy name.
82: 			if (info.indexes[indexes_idx].name.empty()) {
83: 				auto name_info = GetIndexInfo(constraint_type, true, info.base, i);
84: 				info.indexes[indexes_idx].name = name_info.name;
85: 			}
86: 
87: 			// Now we can add the index.
88: 			storage->AddIndex(columns, column_indexes, constraint_type, info.indexes[indexes_idx++]);
89: 			continue;
90: 		}
91: 
92: 		if (constraint->type == ConstraintType::FOREIGN_KEY) {
93: 			// Create a FOREIGN KEY index.
94: 			auto &bfk = constraint->Cast<ForeignKeyConstraint>();
95: 			if (bfk.info.type == ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE ||
96: 			    bfk.info.type == ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE) {
97: 
98: 				vector<LogicalIndex> column_indexes;
99: 				for (const auto &physical_index : bfk.info.fk_keys) {
100: 					auto &col = columns.GetColumn(physical_index);
101: 					column_indexes.push_back(col.Logical());
102: 				}
103: 
104: 				if (info.indexes.empty()) {
105: 					auto constraint_type = IndexConstraintType::FOREIGN;
106: 					auto index_info = GetIndexInfo(constraint_type, false, info.base, i);
107: 					storage->AddIndex(columns, column_indexes, constraint_type, index_info);
108: 					continue;
109: 				}
110: 
111: 				// We read the index from an old storage version applying a dummy name.
112: 				if (info.indexes[indexes_idx].name.empty()) {
113: 					auto name_info = GetIndexInfo(IndexConstraintType::FOREIGN, true, info.base, i);
114: 					info.indexes[indexes_idx].name = name_info.name;
115: 				}
116: 
117: 				// Now we can add the index.
118: 				storage->AddIndex(columns, column_indexes, IndexConstraintType::FOREIGN, info.indexes[indexes_idx++]);
119: 			}
120: 		}
121: 	}
122: 
123: 	if (!info.indexes.empty()) {
124: 		storage->SetIndexStorageInfo(std::move(info.indexes));
125: 	}
126: }
127: 
128: unique_ptr<BaseStatistics> DuckTableEntry::GetStatistics(ClientContext &context, column_t column_id) {
129: 	if (column_id == COLUMN_IDENTIFIER_ROW_ID) {
130: 		return nullptr;
131: 	}
132: 	auto &column = columns.GetColumn(LogicalIndex(column_id));
133: 	if (column.Generated()) {
134: 		return nullptr;
135: 	}
136: 	return storage->GetStatistics(context, column.StorageOid());
137: }
138: 
139: unique_ptr<CatalogEntry> DuckTableEntry::AlterEntry(CatalogTransaction transaction, AlterInfo &info) {
140: 	if (transaction.HasContext()) {
141: 		return AlterEntry(transaction.GetContext(), info);
142: 	}
143: 	if (info.type != AlterType::ALTER_TABLE) {
144: 		return CatalogEntry::AlterEntry(transaction, info);
145: 	}
146: 
147: 	auto &table_info = info.Cast<AlterTableInfo>();
148: 	if (table_info.alter_table_type != AlterTableType::FOREIGN_KEY_CONSTRAINT) {
149: 		return CatalogEntry::AlterEntry(transaction, info);
150: 	}
151: 
152: 	auto &foreign_key_constraint_info = table_info.Cast<AlterForeignKeyInfo>();
153: 	if (foreign_key_constraint_info.type != AlterForeignKeyType::AFT_ADD) {
154: 		return CatalogEntry::AlterEntry(transaction, info);
155: 	}
156: 
157: 	// We add foreign key constraints without a client context during checkpoint loading.
158: 	return AddForeignKeyConstraint(nullptr, foreign_key_constraint_info);
159: }
160: 
161: unique_ptr<CatalogEntry> DuckTableEntry::AlterEntry(ClientContext &context, AlterInfo &info) {
162: 	D_ASSERT(!internal);
163: 
164: 	// Column comments have a special alter type
165: 	if (info.type == AlterType::SET_COLUMN_COMMENT) {
166: 		auto &comment_on_column_info = info.Cast<SetColumnCommentInfo>();
167: 		return SetColumnComment(context, comment_on_column_info);
168: 	}
169: 
170: 	if (info.type != AlterType::ALTER_TABLE) {
171: 		throw CatalogException("Can only modify table with ALTER TABLE statement");
172: 	}
173: 	auto &table_info = info.Cast<AlterTableInfo>();
174: 	switch (table_info.alter_table_type) {
175: 	case AlterTableType::RENAME_COLUMN: {
176: 		auto &rename_info = table_info.Cast<RenameColumnInfo>();
177: 		return RenameColumn(context, rename_info);
178: 	}
179: 	case AlterTableType::RENAME_TABLE: {
180: 		auto &rename_info = table_info.Cast<RenameTableInfo>();
181: 		auto copied_table = Copy(context);
182: 		copied_table->name = rename_info.new_table_name;
183: 		storage->SetTableName(rename_info.new_table_name);
184: 		return copied_table;
185: 	}
186: 	case AlterTableType::ADD_COLUMN: {
187: 		auto &add_info = table_info.Cast<AddColumnInfo>();
188: 		return AddColumn(context, add_info);
189: 	}
190: 	case AlterTableType::REMOVE_COLUMN: {
191: 		auto &remove_info = table_info.Cast<RemoveColumnInfo>();
192: 		return RemoveColumn(context, remove_info);
193: 	}
194: 	case AlterTableType::SET_DEFAULT: {
195: 		auto &set_default_info = table_info.Cast<SetDefaultInfo>();
196: 		return SetDefault(context, set_default_info);
197: 	}
198: 	case AlterTableType::ALTER_COLUMN_TYPE: {
199: 		auto &change_type_info = table_info.Cast<ChangeColumnTypeInfo>();
200: 		return ChangeColumnType(context, change_type_info);
201: 	}
202: 	case AlterTableType::FOREIGN_KEY_CONSTRAINT: {
203: 		auto &foreign_key_constraint_info = table_info.Cast<AlterForeignKeyInfo>();
204: 		if (foreign_key_constraint_info.type == AlterForeignKeyType::AFT_ADD) {
205: 			return AddForeignKeyConstraint(context, foreign_key_constraint_info);
206: 		} else {
207: 			return DropForeignKeyConstraint(context, foreign_key_constraint_info);
208: 		}
209: 	}
210: 	case AlterTableType::SET_NOT_NULL: {
211: 		auto &set_not_null_info = table_info.Cast<SetNotNullInfo>();
212: 		return SetNotNull(context, set_not_null_info);
213: 	}
214: 	case AlterTableType::DROP_NOT_NULL: {
215: 		auto &drop_not_null_info = table_info.Cast<DropNotNullInfo>();
216: 		return DropNotNull(context, drop_not_null_info);
217: 	}
218: 	case AlterTableType::ADD_CONSTRAINT: {
219: 		auto &add_constraint_info = table_info.Cast<AddConstraintInfo>();
220: 		return AddConstraint(context, add_constraint_info);
221: 	}
222: 	default:
223: 		throw InternalException("Unrecognized alter table type!");
224: 	}
225: }
226: 
227: void DuckTableEntry::UndoAlter(ClientContext &context, AlterInfo &info) {
228: 	D_ASSERT(!internal);
229: 	D_ASSERT(info.type == AlterType::ALTER_TABLE);
230: 	auto &table_info = info.Cast<AlterTableInfo>();
231: 	switch (table_info.alter_table_type) {
232: 	case AlterTableType::RENAME_TABLE: {
233: 		storage->SetTableName(this->name);
234: 		break;
235: 	default:
236: 		break;
237: 	}
238: 	}
239: }
240: 
241: static void RenameExpression(ParsedExpression &expr, RenameColumnInfo &info) {
242: 	if (expr.type == ExpressionType::COLUMN_REF) {
243: 		auto &colref = expr.Cast<ColumnRefExpression>();
244: 		if (colref.column_names.back() == info.old_name) {
245: 			colref.column_names.back() = info.new_name;
246: 		}
247: 	}
248: 	ParsedExpressionIterator::EnumerateChildren(
249: 	    expr, [&](const ParsedExpression &child) { RenameExpression((ParsedExpression &)child, info); });
250: }
251: 
252: unique_ptr<CatalogEntry> DuckTableEntry::RenameColumn(ClientContext &context, RenameColumnInfo &info) {
253: 	auto rename_idx = GetColumnIndex(info.old_name);
254: 	if (rename_idx.index == COLUMN_IDENTIFIER_ROW_ID) {
255: 		throw CatalogException("Cannot rename rowid column");
256: 	}
257: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
258: 	create_info->temporary = temporary;
259: 	create_info->comment = comment;
260: 	create_info->tags = tags;
261: 	for (auto &col : columns.Logical()) {
262: 		auto copy = col.Copy();
263: 		if (rename_idx == col.Logical()) {
264: 			copy.SetName(info.new_name);
265: 		}
266: 		if (col.Generated() && column_dependency_manager.IsDependencyOf(col.Logical(), rename_idx)) {
267: 			RenameExpression(copy.GeneratedExpressionMutable(), info);
268: 		}
269: 		create_info->columns.AddColumn(std::move(copy));
270: 	}
271: 	for (idx_t c_idx = 0; c_idx < constraints.size(); c_idx++) {
272: 		auto copy = constraints[c_idx]->Copy();
273: 		switch (copy->type) {
274: 		case ConstraintType::NOT_NULL:
275: 			// NOT NULL constraint: no adjustments necessary
276: 			break;
277: 		case ConstraintType::CHECK: {
278: 			// CHECK constraint: need to rename column references that refer to the renamed column
279: 			auto &check = copy->Cast<CheckConstraint>();
280: 			RenameExpression(*check.expression, info);
281: 			break;
282: 		}
283: 		case ConstraintType::UNIQUE: {
284: 			// UNIQUE constraint: possibly need to rename columns
285: 			auto &unique = copy->Cast<UniqueConstraint>();
286: 			for (auto &column_name : unique.GetColumnNamesMutable()) {
287: 				if (column_name == info.old_name) {
288: 					column_name = info.new_name;
289: 				}
290: 			}
291: 			break;
292: 		}
293: 		case ConstraintType::FOREIGN_KEY: {
294: 			// FOREIGN KEY constraint: possibly need to rename columns
295: 			auto &fk = copy->Cast<ForeignKeyConstraint>();
296: 			vector<string> columns = fk.pk_columns;
297: 			if (fk.info.type == ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE) {
298: 				columns = fk.fk_columns;
299: 			} else if (fk.info.type == ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE) {
300: 				for (idx_t i = 0; i < fk.fk_columns.size(); i++) {
301: 					columns.push_back(fk.fk_columns[i]);
302: 				}
303: 			}
304: 			for (idx_t i = 0; i < columns.size(); i++) {
305: 				if (columns[i] == info.old_name) {
306: 					throw CatalogException(
307: 					    "Cannot rename column \"%s\" because this is involved in the foreign key constraint",
308: 					    info.old_name);
309: 				}
310: 			}
311: 			break;
312: 		}
313: 		default:
314: 			throw InternalException("Unsupported constraint for entry!");
315: 		}
316: 		create_info->constraints.push_back(std::move(copy));
317: 	}
318: 	auto binder = Binder::CreateBinder(context);
319: 	auto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);
320: 	return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, storage);
321: }
322: 
323: unique_ptr<CatalogEntry> DuckTableEntry::AddColumn(ClientContext &context, AddColumnInfo &info) {
324: 	auto col_name = info.new_column.GetName();
325: 
326: 	// We're checking for the opposite condition (ADD COLUMN IF _NOT_ EXISTS ...).
327: 	if (info.if_column_not_exists && ColumnExists(col_name)) {
328: 		return nullptr;
329: 	}
330: 
331: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
332: 	create_info->temporary = temporary;
333: 	create_info->comment = comment;
334: 	create_info->tags = tags;
335: 
336: 	for (auto &col : columns.Logical()) {
337: 		create_info->columns.AddColumn(col.Copy());
338: 	}
339: 	for (auto &constraint : constraints) {
340: 		create_info->constraints.push_back(constraint->Copy());
341: 	}
342: 	auto binder = Binder::CreateBinder(context);
343: 	binder->BindLogicalType(info.new_column.TypeMutable(), &catalog, schema.name);
344: 	info.new_column.SetOid(columns.LogicalColumnCount());
345: 	info.new_column.SetStorageOid(columns.PhysicalColumnCount());
346: 	auto col = info.new_column.Copy();
347: 
348: 	create_info->columns.AddColumn(std::move(col));
349: 
350: 	vector<unique_ptr<Expression>> bound_defaults;
351: 	auto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema, bound_defaults);
352: 	auto new_storage = make_shared_ptr<DataTable>(context, *storage, info.new_column, *bound_defaults.back());
353: 	return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, new_storage);
354: }
355: 
356: void DuckTableEntry::UpdateConstraintsOnColumnDrop(const LogicalIndex &removed_index,
357:                                                    const vector<LogicalIndex> &adjusted_indices,
358:                                                    const RemoveColumnInfo &info, CreateTableInfo &create_info,
359:                                                    const vector<unique_ptr<BoundConstraint>> &bound_constraints,
360:                                                    bool is_generated) {
361: 	// handle constraints for the new table
362: 	D_ASSERT(constraints.size() == bound_constraints.size());
363: 	for (idx_t constr_idx = 0; constr_idx < constraints.size(); constr_idx++) {
364: 		auto &constraint = constraints[constr_idx];
365: 		auto &bound_constraint = bound_constraints[constr_idx];
366: 		switch (constraint->type) {
367: 		case ConstraintType::NOT_NULL: {
368: 			auto &not_null_constraint = bound_constraint->Cast<BoundNotNullConstraint>();
369: 			auto not_null_index = columns.PhysicalToLogical(not_null_constraint.index);
370: 			if (not_null_index != removed_index) {
371: 				// the constraint is not about this column: we need to copy it
372: 				// we might need to shift the index back by one though, to account for the removed column
373: 				auto new_index = adjusted_indices[not_null_index.index];
374: 				create_info.constraints.push_back(make_uniq<NotNullConstraint>(new_index));
375: 			}
376: 			break;
377: 		}
378: 		case ConstraintType::CHECK: {
379: 			// Generated columns can not be part of an index
380: 			// CHECK constraint
381: 			auto &bound_check = bound_constraint->Cast<BoundCheckConstraint>();
382: 			// check if the removed column is part of the check constraint
383: 			if (is_generated) {
384: 				// generated columns can not be referenced by constraints, we can just add the constraint back
385: 				create_info.constraints.push_back(constraint->Copy());
386: 				break;
387: 			}
388: 			auto physical_index = columns.LogicalToPhysical(removed_index);
389: 			if (bound_check.bound_columns.find(physical_index) != bound_check.bound_columns.end()) {
390: 				if (bound_check.bound_columns.size() > 1) {
391: 					// CHECK constraint that concerns mult
392: 					throw CatalogException(
393: 					    "Cannot drop column \"%s\" because there is a CHECK constraint that depends on it",
394: 					    info.removed_column);
395: 				} else {
396: 					// CHECK constraint that ONLY concerns this column, strip the constraint
397: 				}
398: 			} else {
399: 				// check constraint does not concern the removed column: simply re-add it
400: 				create_info.constraints.push_back(constraint->Copy());
401: 			}
402: 			break;
403: 		}
404: 		case ConstraintType::UNIQUE: {
405: 			auto copy = constraint->Copy();
406: 			auto &unique = copy->Cast<UniqueConstraint>();
407: 			if (unique.HasIndex()) {
408: 				if (unique.GetIndex() == removed_index) {
409: 					throw CatalogException(
410: 					    "Cannot drop column \"%s\" because there is a UNIQUE constraint that depends on it",
411: 					    info.removed_column);
412: 				}
413: 				unique.SetIndex(adjusted_indices[unique.GetIndex().index]);
414: 			}
415: 			create_info.constraints.push_back(std::move(copy));
416: 			break;
417: 		}
418: 		case ConstraintType::FOREIGN_KEY: {
419: 			auto copy = constraint->Copy();
420: 			auto &fk = copy->Cast<ForeignKeyConstraint>();
421: 			vector<string> columns = fk.pk_columns;
422: 			if (fk.info.type == ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE) {
423: 				columns = fk.fk_columns;
424: 			} else if (fk.info.type == ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE) {
425: 				for (idx_t i = 0; i < fk.fk_columns.size(); i++) {
426: 					columns.push_back(fk.fk_columns[i]);
427: 				}
428: 			}
429: 			for (idx_t i = 0; i < columns.size(); i++) {
430: 				if (columns[i] == info.removed_column) {
431: 					throw CatalogException(
432: 					    "Cannot drop column \"%s\" because there is a FOREIGN KEY constraint that depends on it",
433: 					    info.removed_column);
434: 				}
435: 			}
436: 			create_info.constraints.push_back(std::move(copy));
437: 			break;
438: 		}
439: 		default:
440: 			throw InternalException("Unsupported constraint for entry!");
441: 		}
442: 	}
443: }
444: 
445: unique_ptr<CatalogEntry> DuckTableEntry::RemoveColumn(ClientContext &context, RemoveColumnInfo &info) {
446: 	auto removed_index = GetColumnIndex(info.removed_column, info.if_column_exists);
447: 	if (!removed_index.IsValid()) {
448: 		if (!info.if_column_exists) {
449: 			throw CatalogException("Cannot drop column: rowid column cannot be dropped");
450: 		}
451: 		return nullptr;
452: 	}
453: 
454: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
455: 	create_info->temporary = temporary;
456: 	create_info->comment = comment;
457: 	create_info->tags = tags;
458: 
459: 	logical_index_set_t removed_columns;
460: 	if (column_dependency_manager.HasDependents(removed_index)) {
461: 		removed_columns = column_dependency_manager.GetDependents(removed_index);
462: 	}
463: 	if (!removed_columns.empty() && !info.cascade) {
464: 		throw CatalogException("Cannot drop column: column is a dependency of 1 or more generated column(s)");
465: 	}
466: 	bool dropped_column_is_generated = false;
467: 	for (auto &col : columns.Logical()) {
468: 		if (col.Logical() == removed_index || removed_columns.count(col.Logical())) {
469: 			if (col.Generated()) {
470: 				dropped_column_is_generated = true;
471: 			}
472: 			continue;
473: 		}
474: 		create_info->columns.AddColumn(col.Copy());
475: 	}
476: 	if (create_info->columns.empty()) {
477: 		throw CatalogException("Cannot drop column: table only has one column remaining!");
478: 	}
479: 	auto adjusted_indices = column_dependency_manager.RemoveColumn(removed_index, columns.LogicalColumnCount());
480: 
481: 	auto binder = Binder::CreateBinder(context);
482: 	auto bound_constraints = binder->BindConstraints(constraints, name, columns);
483: 
484: 	UpdateConstraintsOnColumnDrop(removed_index, adjusted_indices, info, *create_info, bound_constraints,
485: 	                              dropped_column_is_generated);
486: 
487: 	auto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);
488: 	if (columns.GetColumn(LogicalIndex(removed_index)).Generated()) {
489: 		return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, storage);
490: 	}
491: 	auto new_storage =
492: 	    make_shared_ptr<DataTable>(context, *storage, columns.LogicalToPhysical(LogicalIndex(removed_index)).index);
493: 	return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, new_storage);
494: }
495: 
496: unique_ptr<CatalogEntry> DuckTableEntry::SetDefault(ClientContext &context, SetDefaultInfo &info) {
497: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
498: 	create_info->comment = comment;
499: 	create_info->tags = tags;
500: 	auto default_idx = GetColumnIndex(info.column_name);
501: 	if (default_idx.index == COLUMN_IDENTIFIER_ROW_ID) {
502: 		throw CatalogException("Cannot SET DEFAULT for rowid column");
503: 	}
504: 
505: 	// Copy all the columns, changing the value of the one that was specified by 'column_name'
506: 	for (auto &col : columns.Logical()) {
507: 		auto copy = col.Copy();
508: 		if (default_idx == col.Logical()) {
509: 			// set the default value of this column
510: 			if (copy.Generated()) {
511: 				throw BinderException("Cannot SET DEFAULT for generated column \"%s\"", col.Name());
512: 			}
513: 			copy.SetDefaultValue(info.expression ? info.expression->Copy() : nullptr);
514: 		}
515: 		create_info->columns.AddColumn(std::move(copy));
516: 	}
517: 	// Copy all the constraints
518: 	for (idx_t i = 0; i < constraints.size(); i++) {
519: 		auto constraint = constraints[i]->Copy();
520: 		create_info->constraints.push_back(std::move(constraint));
521: 	}
522: 
523: 	auto binder = Binder::CreateBinder(context);
524: 	auto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);
525: 	return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, storage);
526: }
527: 
528: unique_ptr<CatalogEntry> DuckTableEntry::SetNotNull(ClientContext &context, SetNotNullInfo &info) {
529: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
530: 	create_info->comment = comment;
531: 	create_info->tags = tags;
532: 	create_info->columns = columns.Copy();
533: 
534: 	auto not_null_idx = GetColumnIndex(info.column_name);
535: 	if (columns.GetColumn(LogicalIndex(not_null_idx)).Generated()) {
536: 		throw BinderException("Unsupported constraint for generated column!");
537: 	}
538: 	bool has_not_null = false;
539: 	for (idx_t i = 0; i < constraints.size(); i++) {
540: 		auto constraint = constraints[i]->Copy();
541: 		if (constraint->type == ConstraintType::NOT_NULL) {
542: 			auto &not_null = constraint->Cast<NotNullConstraint>();
543: 			if (not_null.index == not_null_idx) {
544: 				has_not_null = true;
545: 			}
546: 		}
547: 		create_info->constraints.push_back(std::move(constraint));
548: 	}
549: 	if (!has_not_null) {
550: 		create_info->constraints.push_back(make_uniq<NotNullConstraint>(not_null_idx));
551: 	}
552: 	auto binder = Binder::CreateBinder(context);
553: 	auto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);
554: 
555: 	// Early return
556: 	if (has_not_null) {
557: 		return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, storage);
558: 	}
559: 
560: 	// Return with new storage info. Note that we need the bound column index here.
561: 	auto physical_columns = columns.LogicalToPhysical(LogicalIndex(not_null_idx));
562: 	auto bound_constraint = make_uniq<BoundNotNullConstraint>(physical_columns);
563: 	auto new_storage = make_shared_ptr<DataTable>(context, *storage, *bound_constraint);
564: 	return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, new_storage);
565: }
566: 
567: unique_ptr<CatalogEntry> DuckTableEntry::DropNotNull(ClientContext &context, DropNotNullInfo &info) {
568: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
569: 	create_info->comment = comment;
570: 	create_info->tags = tags;
571: 	create_info->columns = columns.Copy();
572: 
573: 	auto not_null_idx = GetColumnIndex(info.column_name);
574: 	for (idx_t i = 0; i < constraints.size(); i++) {
575: 		auto constraint = constraints[i]->Copy();
576: 		// Skip/drop not_null
577: 		if (constraint->type == ConstraintType::NOT_NULL) {
578: 			auto &not_null = constraint->Cast<NotNullConstraint>();
579: 			if (not_null.index == not_null_idx) {
580: 				continue;
581: 			}
582: 		}
583: 		create_info->constraints.push_back(std::move(constraint));
584: 	}
585: 
586: 	auto binder = Binder::CreateBinder(context);
587: 	auto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);
588: 	return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, storage);
589: }
590: 
591: unique_ptr<CatalogEntry> DuckTableEntry::ChangeColumnType(ClientContext &context, ChangeColumnTypeInfo &info) {
592: 	auto binder = Binder::CreateBinder(context);
593: 	binder->BindLogicalType(info.target_type, &catalog, schema.name);
594: 
595: 	auto change_idx = GetColumnIndex(info.column_name);
596: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
597: 	create_info->temporary = temporary;
598: 	create_info->comment = comment;
599: 	create_info->tags = tags;
600: 
601: 	// Bind the USING expression.
602: 	vector<LogicalIndex> bound_columns;
603: 	AlterBinder expr_binder(*binder, context, *this, bound_columns, info.target_type);
604: 	auto expression = info.expression->Copy();
605: 	auto bound_expression = expr_binder.Bind(expression);
606: 
607: 	// Infer the target_type from the USING expression, if not set explicitly.
608: 	if (info.target_type == LogicalType::UNKNOWN) {
609: 		info.target_type = bound_expression->return_type;
610: 	}
611: 
612: 	auto bound_constraints = binder->BindConstraints(constraints, name, columns);
613: 	for (auto &col : columns.Logical()) {
614: 		auto copy = col.Copy();
615: 		if (change_idx == col.Logical()) {
616: 			// set the type of this column
617: 			if (copy.Generated()) {
618: 				throw NotImplementedException("Changing types of generated columns is not supported yet");
619: 			}
620: 			copy.SetType(info.target_type);
621: 		}
622: 		// TODO: check if the generated_expression breaks, only delete it if it does
623: 		if (copy.Generated() && column_dependency_manager.IsDependencyOf(col.Logical(), change_idx)) {
624: 			throw BinderException(
625: 			    "This column is referenced by the generated column \"%s\", so its type can not be changed",
626: 			    copy.Name());
627: 		}
628: 		create_info->columns.AddColumn(std::move(copy));
629: 	}
630: 
631: 	for (idx_t constr_idx = 0; constr_idx < constraints.size(); constr_idx++) {
632: 		auto constraint = constraints[constr_idx]->Copy();
633: 		switch (constraint->type) {
634: 		case ConstraintType::CHECK: {
635: 			auto &bound_check = bound_constraints[constr_idx]->Cast<BoundCheckConstraint>();
636: 			auto physical_index = columns.LogicalToPhysical(change_idx);
637: 			if (bound_check.bound_columns.find(physical_index) != bound_check.bound_columns.end()) {
638: 				throw BinderException("Cannot change the type of a column that has a CHECK constraint specified");
639: 			}
640: 			break;
641: 		}
642: 		case ConstraintType::NOT_NULL:
643: 			break;
644: 		case ConstraintType::UNIQUE: {
645: 			auto &bound_unique = bound_constraints[constr_idx]->Cast<BoundUniqueConstraint>();
646: 			auto physical_index = columns.LogicalToPhysical(change_idx);
647: 			if (bound_unique.key_set.find(physical_index) != bound_unique.key_set.end()) {
648: 				throw BinderException(
649: 				    "Cannot change the type of a column that has a UNIQUE or PRIMARY KEY constraint specified");
650: 			}
651: 			break;
652: 		}
653: 		case ConstraintType::FOREIGN_KEY: {
654: 			auto &bfk = bound_constraints[constr_idx]->Cast<BoundForeignKeyConstraint>();
655: 			auto key_set = bfk.pk_key_set;
656: 			if (bfk.info.type == ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE) {
657: 				key_set = bfk.fk_key_set;
658: 			} else if (bfk.info.type == ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE) {
659: 				key_set.insert(bfk.info.fk_keys.begin(), bfk.info.fk_keys.end());
660: 			}
661: 			if (key_set.find(columns.LogicalToPhysical(change_idx)) != key_set.end()) {
662: 				throw BinderException("Cannot change the type of a column that has a FOREIGN KEY constraint specified");
663: 			}
664: 			break;
665: 		}
666: 		default:
667: 			throw InternalException("Unsupported constraint for entry!");
668: 		}
669: 		create_info->constraints.push_back(std::move(constraint));
670: 	}
671: 
672: 	auto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);
673: 
674: 	vector<StorageIndex> storage_oids;
675: 	for (idx_t i = 0; i < bound_columns.size(); i++) {
676: 		storage_oids.emplace_back(columns.LogicalToPhysical(bound_columns[i]).index);
677: 	}
678: 	if (storage_oids.empty()) {
679: 		storage_oids.emplace_back(COLUMN_IDENTIFIER_ROW_ID);
680: 	}
681: 
682: 	auto new_storage =
683: 	    make_shared_ptr<DataTable>(context, *storage, columns.LogicalToPhysical(LogicalIndex(change_idx)).index,
684: 	                               info.target_type, std::move(storage_oids), *bound_expression);
685: 	auto result = make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, new_storage);
686: 	return std::move(result);
687: }
688: 
689: unique_ptr<CatalogEntry> DuckTableEntry::SetColumnComment(ClientContext &context, SetColumnCommentInfo &info) {
690: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
691: 	create_info->comment = comment;
692: 	create_info->tags = tags;
693: 	auto default_idx = GetColumnIndex(info.column_name);
694: 	if (default_idx.index == COLUMN_IDENTIFIER_ROW_ID) {
695: 		throw CatalogException("Cannot SET DEFAULT for rowid column");
696: 	}
697: 
698: 	// Copy all the columns, changing the value of the one that was specified by 'column_name'
699: 	for (auto &col : columns.Logical()) {
700: 		auto copy = col.Copy();
701: 		if (default_idx == col.Logical()) {
702: 			copy.SetComment(info.comment_value);
703: 		}
704: 		create_info->columns.AddColumn(std::move(copy));
705: 	}
706: 	// Copy all the constraints
707: 	for (idx_t i = 0; i < constraints.size(); i++) {
708: 		auto constraint = constraints[i]->Copy();
709: 		create_info->constraints.push_back(std::move(constraint));
710: 	}
711: 
712: 	auto binder = Binder::CreateBinder(context);
713: 	auto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);
714: 	return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, storage);
715: }
716: 
717: unique_ptr<CatalogEntry> DuckTableEntry::AddForeignKeyConstraint(optional_ptr<ClientContext> context,
718:                                                                  AlterForeignKeyInfo &info) {
719: 	D_ASSERT(info.type == AlterForeignKeyType::AFT_ADD);
720: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
721: 	create_info->temporary = temporary;
722: 	create_info->comment = comment;
723: 	create_info->tags = tags;
724: 
725: 	create_info->columns = columns.Copy();
726: 	for (idx_t i = 0; i < constraints.size(); i++) {
727: 		create_info->constraints.push_back(constraints[i]->Copy());
728: 	}
729: 	ForeignKeyInfo fk_info;
730: 	fk_info.type = ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE;
731: 	fk_info.schema = info.schema;
732: 	fk_info.table = info.fk_table;
733: 	fk_info.pk_keys = info.pk_keys;
734: 	fk_info.fk_keys = info.fk_keys;
735: 	create_info->constraints.push_back(
736: 	    make_uniq<ForeignKeyConstraint>(info.pk_columns, info.fk_columns, std::move(fk_info)));
737: 
738: 	unique_ptr<BoundCreateTableInfo> bound_create_info;
739: 	if (context) {
740: 		auto binder = Binder::CreateBinder(*context);
741: 		bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);
742: 	} else {
743: 		bound_create_info = Binder::BindCreateTableCheckpoint(std::move(create_info), schema);
744: 	}
745: 	return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, storage);
746: }
747: 
748: unique_ptr<CatalogEntry> DuckTableEntry::DropForeignKeyConstraint(ClientContext &context, AlterForeignKeyInfo &info) {
749: 	D_ASSERT(info.type == AlterForeignKeyType::AFT_DELETE);
750: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
751: 	create_info->temporary = temporary;
752: 	create_info->comment = comment;
753: 	create_info->tags = tags;
754: 
755: 	create_info->columns = columns.Copy();
756: 	for (idx_t i = 0; i < constraints.size(); i++) {
757: 		auto constraint = constraints[i]->Copy();
758: 		if (constraint->type == ConstraintType::FOREIGN_KEY) {
759: 			ForeignKeyConstraint &fk = constraint->Cast<ForeignKeyConstraint>();
760: 			if (fk.info.type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE && fk.info.table == info.fk_table) {
761: 				continue;
762: 			}
763: 		}
764: 		create_info->constraints.push_back(std::move(constraint));
765: 	}
766: 
767: 	auto binder = Binder::CreateBinder(context);
768: 	auto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);
769: 	return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, storage);
770: }
771: 
772: void DuckTableEntry::Rollback(CatalogEntry &prev_entry) {
773: 	if (prev_entry.type != CatalogType::TABLE_ENTRY) {
774: 		return;
775: 	}
776: 
777: 	// Rolls back any physical index creation.
778: 	// FIXME: Currently only works for PKs.
779: 	// FIXME: Should be changed to work for any index-based constraint.
780: 
781: 	auto &table = Cast<DuckTableEntry>();
782: 	auto &prev_table = prev_entry.Cast<DuckTableEntry>();
783: 	auto &prev_info = prev_table.GetStorage().GetDataTableInfo();
784: 	auto &prev_indexes = prev_info->GetIndexes();
785: 
786: 	// Find all index-based constraints that exist in rollback_table, but not in table.
787: 	// Then, remove them.
788: 
789: 	unordered_set<string> names;
790: 	for (const auto &constraint : prev_table.GetConstraints()) {
791: 		if (constraint->type != ConstraintType::UNIQUE) {
792: 			continue;
793: 		}
794: 		const auto &unique = constraint->Cast<UniqueConstraint>();
795: 		if (unique.is_primary_key) {
796: 			auto index_name = unique.GetName(prev_table.name);
797: 			names.insert(index_name);
798: 		}
799: 	}
800: 
801: 	for (const auto &constraint : GetConstraints()) {
802: 		if (constraint->type != ConstraintType::UNIQUE) {
803: 			continue;
804: 		}
805: 		const auto &unique = constraint->Cast<UniqueConstraint>();
806: 		if (!unique.IsPrimaryKey()) {
807: 			continue;
808: 		}
809: 		auto index_name = unique.GetName(table.name);
810: 		if (names.find(index_name) == names.end()) {
811: 			prev_indexes.RemoveIndex(index_name);
812: 		}
813: 	}
814: }
815: 
816: unique_ptr<CatalogEntry> DuckTableEntry::AddConstraint(ClientContext &context, AddConstraintInfo &info) {
817: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
818: 	create_info->comment = comment;
819: 
820: 	// Copy all columns and constraints to the modified table.
821: 	create_info->columns = columns.Copy();
822: 	for (const auto &constraint : constraints) {
823: 		create_info->constraints.push_back(constraint->Copy());
824: 	}
825: 
826: 	if (info.constraint->type == ConstraintType::UNIQUE) {
827: 		const auto &unique = info.constraint->Cast<UniqueConstraint>();
828: 		const auto existing_pk = GetPrimaryKey();
829: 
830: 		if (unique.is_primary_key && existing_pk) {
831: 			auto existing_name = existing_pk->ToString();
832: 			throw CatalogException("table \"%s\" can have only one primary key: %s", name, existing_name);
833: 		}
834: 		create_info->constraints.push_back(info.constraint->Copy());
835: 
836: 	} else {
837: 		throw InternalException("unsupported constraint type in ALTER TABLE statement");
838: 	}
839: 
840: 	// We create a physical table with a new constraint and a new unique index.
841: 	const auto binder = Binder::CreateBinder(context);
842: 	const auto bound_constraint = binder->BindConstraint(*info.constraint, create_info->table, create_info->columns);
843: 	const auto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);
844: 
845: 	auto new_storage = make_shared_ptr<DataTable>(context, *storage, *bound_constraint);
846: 	auto new_entry = make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, new_storage);
847: 	return std::move(new_entry);
848: }
849: 
850: unique_ptr<CatalogEntry> DuckTableEntry::Copy(ClientContext &context) const {
851: 	auto create_info = make_uniq<CreateTableInfo>(schema, name);
852: 	create_info->comment = comment;
853: 	create_info->tags = tags;
854: 	create_info->columns = columns.Copy();
855: 
856: 	for (idx_t i = 0; i < constraints.size(); i++) {
857: 		auto constraint = constraints[i]->Copy();
858: 		create_info->constraints.push_back(std::move(constraint));
859: 	}
860: 
861: 	auto binder = Binder::CreateBinder(context);
862: 	auto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);
863: 	return make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, storage);
864: }
865: 
866: void DuckTableEntry::SetAsRoot() {
867: 	storage->SetAsRoot();
868: 	storage->SetTableName(name);
869: }
870: 
871: void DuckTableEntry::CommitAlter(string &column_name) {
872: 	D_ASSERT(!column_name.empty());
873: 	optional_idx removed_index;
874: 	for (auto &col : columns.Logical()) {
875: 		if (col.Name() == column_name) {
876: 			// No need to alter storage, removed column is generated column
877: 			if (col.Generated()) {
878: 				return;
879: 			}
880: 			removed_index = col.Oid();
881: 			break;
882: 		}
883: 	}
884: 	storage->CommitDropColumn(columns.LogicalToPhysical(LogicalIndex(removed_index.GetIndex())).index);
885: }
886: 
887: void DuckTableEntry::CommitDrop() {
888: 	storage->CommitDropTable();
889: }
890: 
891: DataTable &DuckTableEntry::GetStorage() {
892: 	return *storage;
893: }
894: 
895: TableFunction DuckTableEntry::GetScanFunction(ClientContext &context, unique_ptr<FunctionData> &bind_data) {
896: 	bind_data = make_uniq<TableScanBindData>(*this);
897: 	return TableScanFunction::GetFunction();
898: }
899: 
900: vector<ColumnSegmentInfo> DuckTableEntry::GetColumnSegmentInfo() {
901: 	return storage->GetColumnSegmentInfo();
902: }
903: 
904: TableStorageInfo DuckTableEntry::GetStorageInfo(ClientContext &context) {
905: 	return storage->GetStorageInfo();
906: }
907: 
908: } // namespace duckdb
[end of src/catalog/catalog_entry/duck_table_entry.cpp]
[start of src/catalog/catalog_entry/table_catalog_entry.cpp]
1: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
5: #include "duckdb/common/algorithm.hpp"
6: #include "duckdb/common/exception.hpp"
7: #include "duckdb/main/database.hpp"
8: #include "duckdb/parser/constraints/list.hpp"
9: #include "duckdb/parser/parsed_data/create_table_info.hpp"
10: #include "duckdb/storage/table_storage_info.hpp"
11: #include "duckdb/planner/operator/logical_update.hpp"
12: #include "duckdb/planner/operator/logical_get.hpp"
13: #include "duckdb/planner/constraints/bound_check_constraint.hpp"
14: #include "duckdb/planner/operator/logical_projection.hpp"
15: #include "duckdb/common/extra_type_info.hpp"
16: #include "duckdb/parser/expression/cast_expression.hpp"
17: 
18: #include <sstream>
19: 
20: namespace duckdb {
21: 
22: TableCatalogEntry::TableCatalogEntry(Catalog &catalog, SchemaCatalogEntry &schema, CreateTableInfo &info)
23:     : StandardEntry(CatalogType::TABLE_ENTRY, schema, catalog, info.table), columns(std::move(info.columns)),
24:       constraints(std::move(info.constraints)) {
25: 	this->temporary = info.temporary;
26: 	this->dependencies = info.dependencies;
27: 	this->comment = info.comment;
28: 	this->tags = info.tags;
29: }
30: 
31: bool TableCatalogEntry::HasGeneratedColumns() const {
32: 	return columns.LogicalColumnCount() != columns.PhysicalColumnCount();
33: }
34: 
35: LogicalIndex TableCatalogEntry::GetColumnIndex(string &column_name, bool if_exists) const {
36: 	auto entry = columns.GetColumnIndex(column_name);
37: 	if (!entry.IsValid()) {
38: 		if (if_exists) {
39: 			return entry;
40: 		}
41: 		throw BinderException("Table \"%s\" does not have a column with name \"%s\"", name, column_name);
42: 	}
43: 	return entry;
44: }
45: 
46: bool TableCatalogEntry::ColumnExists(const string &name) const {
47: 	return columns.ColumnExists(name);
48: }
49: 
50: const ColumnDefinition &TableCatalogEntry::GetColumn(const string &name) const {
51: 	return columns.GetColumn(name);
52: }
53: 
54: vector<LogicalType> TableCatalogEntry::GetTypes() const {
55: 	vector<LogicalType> types;
56: 	for (auto &col : columns.Physical()) {
57: 		types.push_back(col.Type());
58: 	}
59: 	return types;
60: }
61: 
62: unique_ptr<CreateInfo> TableCatalogEntry::GetInfo() const {
63: 	auto result = make_uniq<CreateTableInfo>();
64: 	result->catalog = catalog.GetName();
65: 	result->schema = schema.name;
66: 	result->table = name;
67: 	result->columns = columns.Copy();
68: 	result->constraints.reserve(constraints.size());
69: 	result->dependencies = dependencies;
70: 	std::for_each(constraints.begin(), constraints.end(),
71: 	              [&result](const unique_ptr<Constraint> &c) { result->constraints.emplace_back(c->Copy()); });
72: 	result->comment = comment;
73: 	result->tags = tags;
74: 	return std::move(result);
75: }
76: 
77: string TableCatalogEntry::ColumnsToSQL(const ColumnList &columns, const vector<unique_ptr<Constraint>> &constraints) {
78: 	std::stringstream ss;
79: 
80: 	ss << "(";
81: 
82: 	// find all columns that have NOT NULL specified, but are NOT primary key columns
83: 	logical_index_set_t not_null_columns;
84: 	logical_index_set_t unique_columns;
85: 	logical_index_set_t pk_columns;
86: 	unordered_set<string> multi_key_pks;
87: 	vector<string> extra_constraints;
88: 	for (auto &constraint : constraints) {
89: 		if (constraint->type == ConstraintType::NOT_NULL) {
90: 			auto &not_null = constraint->Cast<NotNullConstraint>();
91: 			not_null_columns.insert(not_null.index);
92: 		} else if (constraint->type == ConstraintType::UNIQUE) {
93: 			auto &pk = constraint->Cast<UniqueConstraint>();
94: 			if (pk.HasIndex()) {
95: 				// no columns specified: single column constraint
96: 				if (pk.IsPrimaryKey()) {
97: 					pk_columns.insert(pk.GetIndex());
98: 				} else {
99: 					unique_columns.insert(pk.GetIndex());
100: 				}
101: 			} else {
102: 				// multi-column constraint, this constraint needs to go at the end after all columns
103: 				if (pk.IsPrimaryKey()) {
104: 					// multi key pk column: insert set of columns into multi_key_pks
105: 					for (auto &col : pk.GetColumnNames()) {
106: 						multi_key_pks.insert(col);
107: 					}
108: 				}
109: 				extra_constraints.push_back(constraint->ToString());
110: 			}
111: 		} else if (constraint->type == ConstraintType::FOREIGN_KEY) {
112: 			auto &fk = constraint->Cast<ForeignKeyConstraint>();
113: 			if (fk.info.type == ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE ||
114: 			    fk.info.type == ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE) {
115: 				extra_constraints.push_back(constraint->ToString());
116: 			}
117: 		} else {
118: 			extra_constraints.push_back(constraint->ToString());
119: 		}
120: 	}
121: 
122: 	for (auto &column : columns.Logical()) {
123: 		if (column.Oid() > 0) {
124: 			ss << ", ";
125: 		}
126: 		ss << KeywordHelper::WriteOptionallyQuoted(column.Name()) << " ";
127: 		auto &column_type = column.Type();
128: 		if (column_type.id() != LogicalTypeId::ANY) {
129: 			ss << column.Type().ToString();
130: 		}
131: 		auto extra_type_info = column_type.AuxInfo();
132: 		if (extra_type_info && extra_type_info->type == ExtraTypeInfoType::STRING_TYPE_INFO) {
133: 			auto &string_info = extra_type_info->Cast<StringTypeInfo>();
134: 			if (!string_info.collation.empty()) {
135: 				ss << " COLLATE " + string_info.collation;
136: 			}
137: 		}
138: 		bool not_null = not_null_columns.find(column.Logical()) != not_null_columns.end();
139: 		bool is_single_key_pk = pk_columns.find(column.Logical()) != pk_columns.end();
140: 		bool is_multi_key_pk = multi_key_pks.find(column.Name()) != multi_key_pks.end();
141: 		bool is_unique = unique_columns.find(column.Logical()) != unique_columns.end();
142: 		if (column.Generated()) {
143: 			reference<const ParsedExpression> generated_expression = column.GeneratedExpression();
144: 			if (column_type.id() != LogicalTypeId::ANY) {
145: 				// We artificially add a cast if the type is specified, need to strip it
146: 				auto &expr = generated_expression.get();
147: 				D_ASSERT(expr.type == ExpressionType::OPERATOR_CAST);
148: 				auto &cast_expr = expr.Cast<CastExpression>();
149: 				D_ASSERT(cast_expr.cast_type.id() == column_type.id());
150: 				generated_expression = *cast_expr.child;
151: 			}
152: 			ss << " GENERATED ALWAYS AS(" << generated_expression.get().ToString() << ")";
153: 		} else if (column.HasDefaultValue()) {
154: 			ss << " DEFAULT(" << column.DefaultValue().ToString() << ")";
155: 		}
156: 		if (not_null && !is_single_key_pk && !is_multi_key_pk) {
157: 			// NOT NULL but not a primary key column
158: 			ss << " NOT NULL";
159: 		}
160: 		if (is_single_key_pk) {
161: 			// single column pk: insert constraint here
162: 			ss << " PRIMARY KEY";
163: 		}
164: 		if (is_unique) {
165: 			// single column unique: insert constraint here
166: 			ss << " UNIQUE";
167: 		}
168: 	}
169: 	// print any extra constraints that still need to be printed
170: 	for (auto &extra_constraint : extra_constraints) {
171: 		ss << ", ";
172: 		ss << extra_constraint;
173: 	}
174: 
175: 	ss << ")";
176: 	return ss.str();
177: }
178: 
179: string TableCatalogEntry::ColumnNamesToSQL(const ColumnList &columns) {
180: 	if (columns.empty()) {
181: 		return "";
182: 	}
183: 
184: 	std::stringstream ss;
185: 	ss << "(";
186: 
187: 	for (auto &column : columns.Logical()) {
188: 		if (column.Oid() > 0) {
189: 			ss << ", ";
190: 		}
191: 		ss << KeywordHelper::WriteOptionallyQuoted(column.Name()) << " ";
192: 	}
193: 	ss << ")";
194: 	return ss.str();
195: }
196: 
197: string TableCatalogEntry::ToSQL() const {
198: 	auto create_info = GetInfo();
199: 	return create_info->ToString();
200: }
201: 
202: const ColumnList &TableCatalogEntry::GetColumns() const {
203: 	return columns;
204: }
205: 
206: const ColumnDefinition &TableCatalogEntry::GetColumn(LogicalIndex idx) const {
207: 	return columns.GetColumn(idx);
208: }
209: 
210: const vector<unique_ptr<Constraint>> &TableCatalogEntry::GetConstraints() const {
211: 	return constraints;
212: }
213: 
214: // LCOV_EXCL_START
215: DataTable &TableCatalogEntry::GetStorage() {
216: 	throw InternalException("Calling GetStorage on a TableCatalogEntry that is not a DuckTableEntry");
217: }
218: // LCOV_EXCL_STOP
219: 
220: static void BindExtraColumns(TableCatalogEntry &table, LogicalGet &get, LogicalProjection &proj, LogicalUpdate &update,
221:                              physical_index_set_t &bound_columns) {
222: 	if (bound_columns.size() <= 1) {
223: 		return;
224: 	}
225: 	idx_t found_column_count = 0;
226: 	physical_index_set_t found_columns;
227: 	for (idx_t i = 0; i < update.columns.size(); i++) {
228: 		if (bound_columns.find(update.columns[i]) != bound_columns.end()) {
229: 			// this column is referenced in the CHECK constraint
230: 			found_column_count++;
231: 			found_columns.insert(update.columns[i]);
232: 		}
233: 	}
234: 	if (found_column_count > 0 && found_column_count != bound_columns.size()) {
235: 		// columns in this CHECK constraint were referenced, but not all were part of the UPDATE
236: 		// add them to the scan and update set
237: 		for (auto &check_column_id : bound_columns) {
238: 			if (found_columns.find(check_column_id) != found_columns.end()) {
239: 				// column is already projected
240: 				continue;
241: 			}
242: 			// column is not projected yet: project it by adding the clause "i=i" to the set of updated columns
243: 			auto &column = table.GetColumns().GetColumn(check_column_id);
244: 			update.expressions.push_back(make_uniq<BoundColumnRefExpression>(
245: 			    column.Type(), ColumnBinding(proj.table_index, proj.expressions.size())));
246: 			proj.expressions.push_back(make_uniq<BoundColumnRefExpression>(
247: 			    column.Type(), ColumnBinding(get.table_index, get.GetColumnIds().size())));
248: 			get.AddColumnId(check_column_id.index);
249: 			update.columns.push_back(check_column_id);
250: 		}
251: 	}
252: }
253: 
254: vector<ColumnSegmentInfo> TableCatalogEntry::GetColumnSegmentInfo() {
255: 	return {};
256: }
257: 
258: void TableCatalogEntry::BindUpdateConstraints(Binder &binder, LogicalGet &get, LogicalProjection &proj,
259:                                               LogicalUpdate &update, ClientContext &context) {
260: 	// check the constraints and indexes of the table to see if we need to project any additional columns
261: 	// we do this for indexes with multiple columns and CHECK constraints in the UPDATE clause
262: 	// suppose we have a constraint CHECK(i + j < 10); now we need both i and j to check the constraint
263: 	// if we are only updating one of the two columns we add the other one to the UPDATE set
264: 	// with a "useless" update (i.e. i=i) so we can verify that the CHECK constraint is not violated
265: 	auto bound_constraints = binder.BindConstraints(constraints, name, columns);
266: 	for (auto &constraint : bound_constraints) {
267: 		if (constraint->type == ConstraintType::CHECK) {
268: 			auto &check = constraint->Cast<BoundCheckConstraint>();
269: 			// check constraint! check if we need to add any extra columns to the UPDATE clause
270: 			BindExtraColumns(*this, get, proj, update, check.bound_columns);
271: 		}
272: 	}
273: 	if (update.return_chunk) {
274: 		physical_index_set_t all_columns;
275: 		for (auto &column : GetColumns().Physical()) {
276: 			all_columns.insert(column.Physical());
277: 		}
278: 		BindExtraColumns(*this, get, proj, update, all_columns);
279: 	}
280: 	// for index updates we always turn any update into an insert and a delete
281: 	// we thus need all the columns to be available, hence we check if the update touches any index columns
282: 	// If the returning keyword is used, we need access to the whole row in case the user requests it.
283: 	// Therefore switch the update to a delete and insert.
284: 	update.update_is_del_and_insert = false;
285: 	TableStorageInfo table_storage_info = GetStorageInfo(context);
286: 	for (auto index : table_storage_info.index_info) {
287: 		for (auto &column : update.columns) {
288: 			if (index.column_set.find(column.index) != index.column_set.end()) {
289: 				update.update_is_del_and_insert = true;
290: 				break;
291: 			}
292: 		}
293: 	};
294: 
295: 	// we also convert any updates on LIST columns into delete + insert
296: 	for (auto &col_index : update.columns) {
297: 		auto &column = GetColumns().GetColumn(col_index);
298: 		if (!column.Type().SupportsRegularUpdate()) {
299: 			update.update_is_del_and_insert = true;
300: 			break;
301: 		}
302: 	}
303: 
304: 	if (update.update_is_del_and_insert) {
305: 		// the update updates a column required by an index or requires returning the updated rows,
306: 		// push projections for all columns
307: 		physical_index_set_t all_columns;
308: 		for (auto &column : GetColumns().Physical()) {
309: 			all_columns.insert(column.Physical());
310: 		}
311: 		BindExtraColumns(*this, get, proj, update, all_columns);
312: 	}
313: }
314: 
315: optional_ptr<Constraint> TableCatalogEntry::GetPrimaryKey() const {
316: 	for (const auto &constraint : GetConstraints()) {
317: 		if (constraint->type == ConstraintType::UNIQUE) {
318: 			auto &unique = constraint->Cast<UniqueConstraint>();
319: 			if (unique.IsPrimaryKey()) {
320: 				return &unique;
321: 			}
322: 		}
323: 	}
324: 	return nullptr;
325: }
326: 
327: bool TableCatalogEntry::HasPrimaryKey() const {
328: 	return GetPrimaryKey() != nullptr;
329: }
330: 
331: } // namespace duckdb
[end of src/catalog/catalog_entry/table_catalog_entry.cpp]
[start of src/common/enum_util.cpp]
1: //-------------------------------------------------------------------------
2: // This file is automatically generated by scripts/generate_enum_util.py
3: // Do not edit this file manually, your changes will be overwritten
4: // If you want to exclude an enum from serialization, add it to the blacklist in the script
5: //
6: // Note: The generated code will only work properly if the enum is a top level item in the duckdb namespace
7: // If the enum is nested in a class, or in another namespace, the generated code will not compile.
8: // You should move the enum to the duckdb namespace, manually write a specialization or add it to the blacklist
9: //-------------------------------------------------------------------------
10: 
11: 
12: #include "duckdb/common/enum_util.hpp"
13: #include "duckdb/catalog/catalog_entry/dependency/dependency_entry.hpp"
14: #include "duckdb/catalog/catalog_entry/table_column_type.hpp"
15: #include "duckdb/common/box_renderer.hpp"
16: #include "duckdb/common/enums/access_mode.hpp"
17: #include "duckdb/common/enums/aggregate_handling.hpp"
18: #include "duckdb/common/enums/catalog_lookup_behavior.hpp"
19: #include "duckdb/common/enums/catalog_type.hpp"
20: #include "duckdb/common/enums/compression_type.hpp"
21: #include "duckdb/common/enums/copy_overwrite_mode.hpp"
22: #include "duckdb/common/enums/cte_materialize.hpp"
23: #include "duckdb/common/enums/date_part_specifier.hpp"
24: #include "duckdb/common/enums/debug_initialize.hpp"
25: #include "duckdb/common/enums/destroy_buffer_upon.hpp"
26: #include "duckdb/common/enums/explain_format.hpp"
27: #include "duckdb/common/enums/expression_type.hpp"
28: #include "duckdb/common/enums/file_compression_type.hpp"
29: #include "duckdb/common/enums/file_glob_options.hpp"
30: #include "duckdb/common/enums/filter_propagate_result.hpp"
31: #include "duckdb/common/enums/function_errors.hpp"
32: #include "duckdb/common/enums/index_constraint_type.hpp"
33: #include "duckdb/common/enums/join_type.hpp"
34: #include "duckdb/common/enums/joinref_type.hpp"
35: #include "duckdb/common/enums/logical_operator_type.hpp"
36: #include "duckdb/common/enums/memory_tag.hpp"
37: #include "duckdb/common/enums/metric_type.hpp"
38: #include "duckdb/common/enums/on_create_conflict.hpp"
39: #include "duckdb/common/enums/on_entry_not_found.hpp"
40: #include "duckdb/common/enums/operator_result_type.hpp"
41: #include "duckdb/common/enums/optimizer_type.hpp"
42: #include "duckdb/common/enums/order_preservation_type.hpp"
43: #include "duckdb/common/enums/order_type.hpp"
44: #include "duckdb/common/enums/output_type.hpp"
45: #include "duckdb/common/enums/pending_execution_result.hpp"
46: #include "duckdb/common/enums/physical_operator_type.hpp"
47: #include "duckdb/common/enums/prepared_statement_mode.hpp"
48: #include "duckdb/common/enums/profiler_format.hpp"
49: #include "duckdb/common/enums/quantile_enum.hpp"
50: #include "duckdb/common/enums/relation_type.hpp"
51: #include "duckdb/common/enums/scan_options.hpp"
52: #include "duckdb/common/enums/set_operation_type.hpp"
53: #include "duckdb/common/enums/set_scope.hpp"
54: #include "duckdb/common/enums/set_type.hpp"
55: #include "duckdb/common/enums/statement_type.hpp"
56: #include "duckdb/common/enums/stream_execution_result.hpp"
57: #include "duckdb/common/enums/subquery_type.hpp"
58: #include "duckdb/common/enums/tableref_type.hpp"
59: #include "duckdb/common/enums/undo_flags.hpp"
60: #include "duckdb/common/enums/vector_type.hpp"
61: #include "duckdb/common/enums/wal_type.hpp"
62: #include "duckdb/common/enums/window_aggregation_mode.hpp"
63: #include "duckdb/common/exception.hpp"
64: #include "duckdb/common/exception_format_value.hpp"
65: #include "duckdb/common/extra_type_info.hpp"
66: #include "duckdb/common/file_buffer.hpp"
67: #include "duckdb/common/file_open_flags.hpp"
68: #include "duckdb/common/multi_file_list.hpp"
69: #include "duckdb/common/operator/decimal_cast_operators.hpp"
70: #include "duckdb/common/printer.hpp"
71: #include "duckdb/common/sort/partition_state.hpp"
72: #include "duckdb/common/types.hpp"
73: #include "duckdb/common/types/column/column_data_scan_states.hpp"
74: #include "duckdb/common/types/column/partitioned_column_data.hpp"
75: #include "duckdb/common/types/conflict_manager.hpp"
76: #include "duckdb/common/types/hyperloglog.hpp"
77: #include "duckdb/common/types/row/partitioned_tuple_data.hpp"
78: #include "duckdb/common/types/row/tuple_data_states.hpp"
79: #include "duckdb/common/types/timestamp.hpp"
80: #include "duckdb/common/types/vector.hpp"
81: #include "duckdb/common/types/vector_buffer.hpp"
82: #include "duckdb/execution/index/art/art.hpp"
83: #include "duckdb/execution/index/art/node.hpp"
84: #include "duckdb/execution/operator/csv_scanner/csv_option.hpp"
85: #include "duckdb/execution/operator/csv_scanner/csv_state.hpp"
86: #include "duckdb/execution/operator/csv_scanner/quote_rules.hpp"
87: #include "duckdb/execution/reservoir_sample.hpp"
88: #include "duckdb/function/aggregate_state.hpp"
89: #include "duckdb/function/copy_function.hpp"
90: #include "duckdb/function/function.hpp"
91: #include "duckdb/function/macro_function.hpp"
92: #include "duckdb/function/partition_stats.hpp"
93: #include "duckdb/function/scalar/compressed_materialization_utils.hpp"
94: #include "duckdb/function/scalar/strftime_format.hpp"
95: #include "duckdb/function/table/arrow/enum/arrow_datetime_type.hpp"
96: #include "duckdb/function/table/arrow/enum/arrow_type_info_type.hpp"
97: #include "duckdb/function/table/arrow/enum/arrow_variable_size_type.hpp"
98: #include "duckdb/function/table_function.hpp"
99: #include "duckdb/main/appender.hpp"
100: #include "duckdb/main/capi/capi_internal.hpp"
101: #include "duckdb/main/client_properties.hpp"
102: #include "duckdb/main/config.hpp"
103: #include "duckdb/main/error_manager.hpp"
104: #include "duckdb/main/extension.hpp"
105: #include "duckdb/main/extension_helper.hpp"
106: #include "duckdb/main/extension_install_info.hpp"
107: #include "duckdb/main/query_result.hpp"
108: #include "duckdb/main/secret/secret.hpp"
109: #include "duckdb/main/settings.hpp"
110: #include "duckdb/parallel/interrupt.hpp"
111: #include "duckdb/parallel/meta_pipeline.hpp"
112: #include "duckdb/parallel/task.hpp"
113: #include "duckdb/parser/constraint.hpp"
114: #include "duckdb/parser/expression/parameter_expression.hpp"
115: #include "duckdb/parser/expression/window_expression.hpp"
116: #include "duckdb/parser/parsed_data/alter_info.hpp"
117: #include "duckdb/parser/parsed_data/alter_scalar_function_info.hpp"
118: #include "duckdb/parser/parsed_data/alter_table_function_info.hpp"
119: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
120: #include "duckdb/parser/parsed_data/create_sequence_info.hpp"
121: #include "duckdb/parser/parsed_data/extra_drop_info.hpp"
122: #include "duckdb/parser/parsed_data/load_info.hpp"
123: #include "duckdb/parser/parsed_data/parse_info.hpp"
124: #include "duckdb/parser/parsed_data/pragma_info.hpp"
125: #include "duckdb/parser/parsed_data/sample_options.hpp"
126: #include "duckdb/parser/parsed_data/transaction_info.hpp"
127: #include "duckdb/parser/parser_extension.hpp"
128: #include "duckdb/parser/query_node.hpp"
129: #include "duckdb/parser/result_modifier.hpp"
130: #include "duckdb/parser/simplified_token.hpp"
131: #include "duckdb/parser/statement/copy_statement.hpp"
132: #include "duckdb/parser/statement/explain_statement.hpp"
133: #include "duckdb/parser/statement/insert_statement.hpp"
134: #include "duckdb/parser/tableref/showref.hpp"
135: #include "duckdb/planner/binder.hpp"
136: #include "duckdb/planner/bound_result_modifier.hpp"
137: #include "duckdb/planner/table_filter.hpp"
138: #include "duckdb/storage/buffer/block_handle.hpp"
139: #include "duckdb/storage/compression/bitpacking.hpp"
140: #include "duckdb/storage/magic_bytes.hpp"
141: #include "duckdb/storage/statistics/base_statistics.hpp"
142: #include "duckdb/storage/table/chunk_info.hpp"
143: #include "duckdb/storage/table/column_segment.hpp"
144: #include "duckdb/storage/temporary_file_manager.hpp"
145: #include "duckdb/verification/statement_verifier.hpp"
146: 
147: namespace duckdb {
148: 
149: const StringUtil::EnumStringLiteral *GetARTAppendModeValues() {
150: 	static constexpr StringUtil::EnumStringLiteral values[] {
151: 		{ static_cast<uint32_t>(ARTAppendMode::DEFAULT), "DEFAULT" },
152: 		{ static_cast<uint32_t>(ARTAppendMode::IGNORE_DUPLICATES), "IGNORE_DUPLICATES" },
153: 		{ static_cast<uint32_t>(ARTAppendMode::INSERT_DUPLICATES), "INSERT_DUPLICATES" }
154: 	};
155: 	return values;
156: }
157: 
158: template<>
159: const char* EnumUtil::ToChars<ARTAppendMode>(ARTAppendMode value) {
160: 	return StringUtil::EnumToString(GetARTAppendModeValues(), 3, "ARTAppendMode", static_cast<uint32_t>(value));
161: }
162: 
163: template<>
164: ARTAppendMode EnumUtil::FromString<ARTAppendMode>(const char *value) {
165: 	return static_cast<ARTAppendMode>(StringUtil::StringToEnum(GetARTAppendModeValues(), 3, "ARTAppendMode", value));
166: }
167: 
168: const StringUtil::EnumStringLiteral *GetARTConflictTypeValues() {
169: 	static constexpr StringUtil::EnumStringLiteral values[] {
170: 		{ static_cast<uint32_t>(ARTConflictType::NO_CONFLICT), "NO_CONFLICT" },
171: 		{ static_cast<uint32_t>(ARTConflictType::CONSTRAINT), "CONSTRAINT" },
172: 		{ static_cast<uint32_t>(ARTConflictType::TRANSACTION), "TRANSACTION" }
173: 	};
174: 	return values;
175: }
176: 
177: template<>
178: const char* EnumUtil::ToChars<ARTConflictType>(ARTConflictType value) {
179: 	return StringUtil::EnumToString(GetARTConflictTypeValues(), 3, "ARTConflictType", static_cast<uint32_t>(value));
180: }
181: 
182: template<>
183: ARTConflictType EnumUtil::FromString<ARTConflictType>(const char *value) {
184: 	return static_cast<ARTConflictType>(StringUtil::StringToEnum(GetARTConflictTypeValues(), 3, "ARTConflictType", value));
185: }
186: 
187: const StringUtil::EnumStringLiteral *GetAccessModeValues() {
188: 	static constexpr StringUtil::EnumStringLiteral values[] {
189: 		{ static_cast<uint32_t>(AccessMode::UNDEFINED), "UNDEFINED" },
190: 		{ static_cast<uint32_t>(AccessMode::AUTOMATIC), "AUTOMATIC" },
191: 		{ static_cast<uint32_t>(AccessMode::READ_ONLY), "READ_ONLY" },
192: 		{ static_cast<uint32_t>(AccessMode::READ_WRITE), "READ_WRITE" }
193: 	};
194: 	return values;
195: }
196: 
197: template<>
198: const char* EnumUtil::ToChars<AccessMode>(AccessMode value) {
199: 	return StringUtil::EnumToString(GetAccessModeValues(), 4, "AccessMode", static_cast<uint32_t>(value));
200: }
201: 
202: template<>
203: AccessMode EnumUtil::FromString<AccessMode>(const char *value) {
204: 	return static_cast<AccessMode>(StringUtil::StringToEnum(GetAccessModeValues(), 4, "AccessMode", value));
205: }
206: 
207: const StringUtil::EnumStringLiteral *GetAggregateCombineTypeValues() {
208: 	static constexpr StringUtil::EnumStringLiteral values[] {
209: 		{ static_cast<uint32_t>(AggregateCombineType::PRESERVE_INPUT), "PRESERVE_INPUT" },
210: 		{ static_cast<uint32_t>(AggregateCombineType::ALLOW_DESTRUCTIVE), "ALLOW_DESTRUCTIVE" }
211: 	};
212: 	return values;
213: }
214: 
215: template<>
216: const char* EnumUtil::ToChars<AggregateCombineType>(AggregateCombineType value) {
217: 	return StringUtil::EnumToString(GetAggregateCombineTypeValues(), 2, "AggregateCombineType", static_cast<uint32_t>(value));
218: }
219: 
220: template<>
221: AggregateCombineType EnumUtil::FromString<AggregateCombineType>(const char *value) {
222: 	return static_cast<AggregateCombineType>(StringUtil::StringToEnum(GetAggregateCombineTypeValues(), 2, "AggregateCombineType", value));
223: }
224: 
225: const StringUtil::EnumStringLiteral *GetAggregateDistinctDependentValues() {
226: 	static constexpr StringUtil::EnumStringLiteral values[] {
227: 		{ static_cast<uint32_t>(AggregateDistinctDependent::DISTINCT_DEPENDENT), "DISTINCT_DEPENDENT" },
228: 		{ static_cast<uint32_t>(AggregateDistinctDependent::NOT_DISTINCT_DEPENDENT), "NOT_DISTINCT_DEPENDENT" }
229: 	};
230: 	return values;
231: }
232: 
233: template<>
234: const char* EnumUtil::ToChars<AggregateDistinctDependent>(AggregateDistinctDependent value) {
235: 	return StringUtil::EnumToString(GetAggregateDistinctDependentValues(), 2, "AggregateDistinctDependent", static_cast<uint32_t>(value));
236: }
237: 
238: template<>
239: AggregateDistinctDependent EnumUtil::FromString<AggregateDistinctDependent>(const char *value) {
240: 	return static_cast<AggregateDistinctDependent>(StringUtil::StringToEnum(GetAggregateDistinctDependentValues(), 2, "AggregateDistinctDependent", value));
241: }
242: 
243: const StringUtil::EnumStringLiteral *GetAggregateHandlingValues() {
244: 	static constexpr StringUtil::EnumStringLiteral values[] {
245: 		{ static_cast<uint32_t>(AggregateHandling::STANDARD_HANDLING), "STANDARD_HANDLING" },
246: 		{ static_cast<uint32_t>(AggregateHandling::NO_AGGREGATES_ALLOWED), "NO_AGGREGATES_ALLOWED" },
247: 		{ static_cast<uint32_t>(AggregateHandling::FORCE_AGGREGATES), "FORCE_AGGREGATES" }
248: 	};
249: 	return values;
250: }
251: 
252: template<>
253: const char* EnumUtil::ToChars<AggregateHandling>(AggregateHandling value) {
254: 	return StringUtil::EnumToString(GetAggregateHandlingValues(), 3, "AggregateHandling", static_cast<uint32_t>(value));
255: }
256: 
257: template<>
258: AggregateHandling EnumUtil::FromString<AggregateHandling>(const char *value) {
259: 	return static_cast<AggregateHandling>(StringUtil::StringToEnum(GetAggregateHandlingValues(), 3, "AggregateHandling", value));
260: }
261: 
262: const StringUtil::EnumStringLiteral *GetAggregateOrderDependentValues() {
263: 	static constexpr StringUtil::EnumStringLiteral values[] {
264: 		{ static_cast<uint32_t>(AggregateOrderDependent::ORDER_DEPENDENT), "ORDER_DEPENDENT" },
265: 		{ static_cast<uint32_t>(AggregateOrderDependent::NOT_ORDER_DEPENDENT), "NOT_ORDER_DEPENDENT" }
266: 	};
267: 	return values;
268: }
269: 
270: template<>
271: const char* EnumUtil::ToChars<AggregateOrderDependent>(AggregateOrderDependent value) {
272: 	return StringUtil::EnumToString(GetAggregateOrderDependentValues(), 2, "AggregateOrderDependent", static_cast<uint32_t>(value));
273: }
274: 
275: template<>
276: AggregateOrderDependent EnumUtil::FromString<AggregateOrderDependent>(const char *value) {
277: 	return static_cast<AggregateOrderDependent>(StringUtil::StringToEnum(GetAggregateOrderDependentValues(), 2, "AggregateOrderDependent", value));
278: }
279: 
280: const StringUtil::EnumStringLiteral *GetAggregateTypeValues() {
281: 	static constexpr StringUtil::EnumStringLiteral values[] {
282: 		{ static_cast<uint32_t>(AggregateType::NON_DISTINCT), "NON_DISTINCT" },
283: 		{ static_cast<uint32_t>(AggregateType::DISTINCT), "DISTINCT" }
284: 	};
285: 	return values;
286: }
287: 
288: template<>
289: const char* EnumUtil::ToChars<AggregateType>(AggregateType value) {
290: 	return StringUtil::EnumToString(GetAggregateTypeValues(), 2, "AggregateType", static_cast<uint32_t>(value));
291: }
292: 
293: template<>
294: AggregateType EnumUtil::FromString<AggregateType>(const char *value) {
295: 	return static_cast<AggregateType>(StringUtil::StringToEnum(GetAggregateTypeValues(), 2, "AggregateType", value));
296: }
297: 
298: const StringUtil::EnumStringLiteral *GetAlterForeignKeyTypeValues() {
299: 	static constexpr StringUtil::EnumStringLiteral values[] {
300: 		{ static_cast<uint32_t>(AlterForeignKeyType::AFT_ADD), "AFT_ADD" },
301: 		{ static_cast<uint32_t>(AlterForeignKeyType::AFT_DELETE), "AFT_DELETE" }
302: 	};
303: 	return values;
304: }
305: 
306: template<>
307: const char* EnumUtil::ToChars<AlterForeignKeyType>(AlterForeignKeyType value) {
308: 	return StringUtil::EnumToString(GetAlterForeignKeyTypeValues(), 2, "AlterForeignKeyType", static_cast<uint32_t>(value));
309: }
310: 
311: template<>
312: AlterForeignKeyType EnumUtil::FromString<AlterForeignKeyType>(const char *value) {
313: 	return static_cast<AlterForeignKeyType>(StringUtil::StringToEnum(GetAlterForeignKeyTypeValues(), 2, "AlterForeignKeyType", value));
314: }
315: 
316: const StringUtil::EnumStringLiteral *GetAlterScalarFunctionTypeValues() {
317: 	static constexpr StringUtil::EnumStringLiteral values[] {
318: 		{ static_cast<uint32_t>(AlterScalarFunctionType::INVALID), "INVALID" },
319: 		{ static_cast<uint32_t>(AlterScalarFunctionType::ADD_FUNCTION_OVERLOADS), "ADD_FUNCTION_OVERLOADS" }
320: 	};
321: 	return values;
322: }
323: 
324: template<>
325: const char* EnumUtil::ToChars<AlterScalarFunctionType>(AlterScalarFunctionType value) {
326: 	return StringUtil::EnumToString(GetAlterScalarFunctionTypeValues(), 2, "AlterScalarFunctionType", static_cast<uint32_t>(value));
327: }
328: 
329: template<>
330: AlterScalarFunctionType EnumUtil::FromString<AlterScalarFunctionType>(const char *value) {
331: 	return static_cast<AlterScalarFunctionType>(StringUtil::StringToEnum(GetAlterScalarFunctionTypeValues(), 2, "AlterScalarFunctionType", value));
332: }
333: 
334: const StringUtil::EnumStringLiteral *GetAlterTableFunctionTypeValues() {
335: 	static constexpr StringUtil::EnumStringLiteral values[] {
336: 		{ static_cast<uint32_t>(AlterTableFunctionType::INVALID), "INVALID" },
337: 		{ static_cast<uint32_t>(AlterTableFunctionType::ADD_FUNCTION_OVERLOADS), "ADD_FUNCTION_OVERLOADS" }
338: 	};
339: 	return values;
340: }
341: 
342: template<>
343: const char* EnumUtil::ToChars<AlterTableFunctionType>(AlterTableFunctionType value) {
344: 	return StringUtil::EnumToString(GetAlterTableFunctionTypeValues(), 2, "AlterTableFunctionType", static_cast<uint32_t>(value));
345: }
346: 
347: template<>
348: AlterTableFunctionType EnumUtil::FromString<AlterTableFunctionType>(const char *value) {
349: 	return static_cast<AlterTableFunctionType>(StringUtil::StringToEnum(GetAlterTableFunctionTypeValues(), 2, "AlterTableFunctionType", value));
350: }
351: 
352: const StringUtil::EnumStringLiteral *GetAlterTableTypeValues() {
353: 	static constexpr StringUtil::EnumStringLiteral values[] {
354: 		{ static_cast<uint32_t>(AlterTableType::INVALID), "INVALID" },
355: 		{ static_cast<uint32_t>(AlterTableType::RENAME_COLUMN), "RENAME_COLUMN" },
356: 		{ static_cast<uint32_t>(AlterTableType::RENAME_TABLE), "RENAME_TABLE" },
357: 		{ static_cast<uint32_t>(AlterTableType::ADD_COLUMN), "ADD_COLUMN" },
358: 		{ static_cast<uint32_t>(AlterTableType::REMOVE_COLUMN), "REMOVE_COLUMN" },
359: 		{ static_cast<uint32_t>(AlterTableType::ALTER_COLUMN_TYPE), "ALTER_COLUMN_TYPE" },
360: 		{ static_cast<uint32_t>(AlterTableType::SET_DEFAULT), "SET_DEFAULT" },
361: 		{ static_cast<uint32_t>(AlterTableType::FOREIGN_KEY_CONSTRAINT), "FOREIGN_KEY_CONSTRAINT" },
362: 		{ static_cast<uint32_t>(AlterTableType::SET_NOT_NULL), "SET_NOT_NULL" },
363: 		{ static_cast<uint32_t>(AlterTableType::DROP_NOT_NULL), "DROP_NOT_NULL" },
364: 		{ static_cast<uint32_t>(AlterTableType::SET_COLUMN_COMMENT), "SET_COLUMN_COMMENT" },
365: 		{ static_cast<uint32_t>(AlterTableType::ADD_CONSTRAINT), "ADD_CONSTRAINT" }
366: 	};
367: 	return values;
368: }
369: 
370: template<>
371: const char* EnumUtil::ToChars<AlterTableType>(AlterTableType value) {
372: 	return StringUtil::EnumToString(GetAlterTableTypeValues(), 12, "AlterTableType", static_cast<uint32_t>(value));
373: }
374: 
375: template<>
376: AlterTableType EnumUtil::FromString<AlterTableType>(const char *value) {
377: 	return static_cast<AlterTableType>(StringUtil::StringToEnum(GetAlterTableTypeValues(), 12, "AlterTableType", value));
378: }
379: 
380: const StringUtil::EnumStringLiteral *GetAlterTypeValues() {
381: 	static constexpr StringUtil::EnumStringLiteral values[] {
382: 		{ static_cast<uint32_t>(AlterType::INVALID), "INVALID" },
383: 		{ static_cast<uint32_t>(AlterType::ALTER_TABLE), "ALTER_TABLE" },
384: 		{ static_cast<uint32_t>(AlterType::ALTER_VIEW), "ALTER_VIEW" },
385: 		{ static_cast<uint32_t>(AlterType::ALTER_SEQUENCE), "ALTER_SEQUENCE" },
386: 		{ static_cast<uint32_t>(AlterType::CHANGE_OWNERSHIP), "CHANGE_OWNERSHIP" },
387: 		{ static_cast<uint32_t>(AlterType::ALTER_SCALAR_FUNCTION), "ALTER_SCALAR_FUNCTION" },
388: 		{ static_cast<uint32_t>(AlterType::ALTER_TABLE_FUNCTION), "ALTER_TABLE_FUNCTION" },
389: 		{ static_cast<uint32_t>(AlterType::SET_COMMENT), "SET_COMMENT" },
390: 		{ static_cast<uint32_t>(AlterType::SET_COLUMN_COMMENT), "SET_COLUMN_COMMENT" }
391: 	};
392: 	return values;
393: }
394: 
395: template<>
396: const char* EnumUtil::ToChars<AlterType>(AlterType value) {
397: 	return StringUtil::EnumToString(GetAlterTypeValues(), 9, "AlterType", static_cast<uint32_t>(value));
398: }
399: 
400: template<>
401: AlterType EnumUtil::FromString<AlterType>(const char *value) {
402: 	return static_cast<AlterType>(StringUtil::StringToEnum(GetAlterTypeValues(), 9, "AlterType", value));
403: }
404: 
405: const StringUtil::EnumStringLiteral *GetAlterViewTypeValues() {
406: 	static constexpr StringUtil::EnumStringLiteral values[] {
407: 		{ static_cast<uint32_t>(AlterViewType::INVALID), "INVALID" },
408: 		{ static_cast<uint32_t>(AlterViewType::RENAME_VIEW), "RENAME_VIEW" }
409: 	};
410: 	return values;
411: }
412: 
413: template<>
414: const char* EnumUtil::ToChars<AlterViewType>(AlterViewType value) {
415: 	return StringUtil::EnumToString(GetAlterViewTypeValues(), 2, "AlterViewType", static_cast<uint32_t>(value));
416: }
417: 
418: template<>
419: AlterViewType EnumUtil::FromString<AlterViewType>(const char *value) {
420: 	return static_cast<AlterViewType>(StringUtil::StringToEnum(GetAlterViewTypeValues(), 2, "AlterViewType", value));
421: }
422: 
423: const StringUtil::EnumStringLiteral *GetAppenderTypeValues() {
424: 	static constexpr StringUtil::EnumStringLiteral values[] {
425: 		{ static_cast<uint32_t>(AppenderType::LOGICAL), "LOGICAL" },
426: 		{ static_cast<uint32_t>(AppenderType::PHYSICAL), "PHYSICAL" }
427: 	};
428: 	return values;
429: }
430: 
431: template<>
432: const char* EnumUtil::ToChars<AppenderType>(AppenderType value) {
433: 	return StringUtil::EnumToString(GetAppenderTypeValues(), 2, "AppenderType", static_cast<uint32_t>(value));
434: }
435: 
436: template<>
437: AppenderType EnumUtil::FromString<AppenderType>(const char *value) {
438: 	return static_cast<AppenderType>(StringUtil::StringToEnum(GetAppenderTypeValues(), 2, "AppenderType", value));
439: }
440: 
441: const StringUtil::EnumStringLiteral *GetArrowDateTimeTypeValues() {
442: 	static constexpr StringUtil::EnumStringLiteral values[] {
443: 		{ static_cast<uint32_t>(ArrowDateTimeType::MILLISECONDS), "MILLISECONDS" },
444: 		{ static_cast<uint32_t>(ArrowDateTimeType::MICROSECONDS), "MICROSECONDS" },
445: 		{ static_cast<uint32_t>(ArrowDateTimeType::NANOSECONDS), "NANOSECONDS" },
446: 		{ static_cast<uint32_t>(ArrowDateTimeType::SECONDS), "SECONDS" },
447: 		{ static_cast<uint32_t>(ArrowDateTimeType::DAYS), "DAYS" },
448: 		{ static_cast<uint32_t>(ArrowDateTimeType::MONTHS), "MONTHS" },
449: 		{ static_cast<uint32_t>(ArrowDateTimeType::MONTH_DAY_NANO), "MONTH_DAY_NANO" }
450: 	};
451: 	return values;
452: }
453: 
454: template<>
455: const char* EnumUtil::ToChars<ArrowDateTimeType>(ArrowDateTimeType value) {
456: 	return StringUtil::EnumToString(GetArrowDateTimeTypeValues(), 7, "ArrowDateTimeType", static_cast<uint32_t>(value));
457: }
458: 
459: template<>
460: ArrowDateTimeType EnumUtil::FromString<ArrowDateTimeType>(const char *value) {
461: 	return static_cast<ArrowDateTimeType>(StringUtil::StringToEnum(GetArrowDateTimeTypeValues(), 7, "ArrowDateTimeType", value));
462: }
463: 
464: const StringUtil::EnumStringLiteral *GetArrowOffsetSizeValues() {
465: 	static constexpr StringUtil::EnumStringLiteral values[] {
466: 		{ static_cast<uint32_t>(ArrowOffsetSize::REGULAR), "REGULAR" },
467: 		{ static_cast<uint32_t>(ArrowOffsetSize::LARGE), "LARGE" }
468: 	};
469: 	return values;
470: }
471: 
472: template<>
473: const char* EnumUtil::ToChars<ArrowOffsetSize>(ArrowOffsetSize value) {
474: 	return StringUtil::EnumToString(GetArrowOffsetSizeValues(), 2, "ArrowOffsetSize", static_cast<uint32_t>(value));
475: }
476: 
477: template<>
478: ArrowOffsetSize EnumUtil::FromString<ArrowOffsetSize>(const char *value) {
479: 	return static_cast<ArrowOffsetSize>(StringUtil::StringToEnum(GetArrowOffsetSizeValues(), 2, "ArrowOffsetSize", value));
480: }
481: 
482: const StringUtil::EnumStringLiteral *GetArrowTypeInfoTypeValues() {
483: 	static constexpr StringUtil::EnumStringLiteral values[] {
484: 		{ static_cast<uint32_t>(ArrowTypeInfoType::LIST), "LIST" },
485: 		{ static_cast<uint32_t>(ArrowTypeInfoType::STRUCT), "STRUCT" },
486: 		{ static_cast<uint32_t>(ArrowTypeInfoType::DATE_TIME), "DATE_TIME" },
487: 		{ static_cast<uint32_t>(ArrowTypeInfoType::STRING), "STRING" },
488: 		{ static_cast<uint32_t>(ArrowTypeInfoType::ARRAY), "ARRAY" }
489: 	};
490: 	return values;
491: }
492: 
493: template<>
494: const char* EnumUtil::ToChars<ArrowTypeInfoType>(ArrowTypeInfoType value) {
495: 	return StringUtil::EnumToString(GetArrowTypeInfoTypeValues(), 5, "ArrowTypeInfoType", static_cast<uint32_t>(value));
496: }
497: 
498: template<>
499: ArrowTypeInfoType EnumUtil::FromString<ArrowTypeInfoType>(const char *value) {
500: 	return static_cast<ArrowTypeInfoType>(StringUtil::StringToEnum(GetArrowTypeInfoTypeValues(), 5, "ArrowTypeInfoType", value));
501: }
502: 
503: const StringUtil::EnumStringLiteral *GetArrowVariableSizeTypeValues() {
504: 	static constexpr StringUtil::EnumStringLiteral values[] {
505: 		{ static_cast<uint32_t>(ArrowVariableSizeType::NORMAL), "NORMAL" },
506: 		{ static_cast<uint32_t>(ArrowVariableSizeType::FIXED_SIZE), "FIXED_SIZE" },
507: 		{ static_cast<uint32_t>(ArrowVariableSizeType::SUPER_SIZE), "SUPER_SIZE" },
508: 		{ static_cast<uint32_t>(ArrowVariableSizeType::VIEW), "VIEW" }
509: 	};
510: 	return values;
511: }
512: 
513: template<>
514: const char* EnumUtil::ToChars<ArrowVariableSizeType>(ArrowVariableSizeType value) {
515: 	return StringUtil::EnumToString(GetArrowVariableSizeTypeValues(), 4, "ArrowVariableSizeType", static_cast<uint32_t>(value));
516: }
517: 
518: template<>
519: ArrowVariableSizeType EnumUtil::FromString<ArrowVariableSizeType>(const char *value) {
520: 	return static_cast<ArrowVariableSizeType>(StringUtil::StringToEnum(GetArrowVariableSizeTypeValues(), 4, "ArrowVariableSizeType", value));
521: }
522: 
523: const StringUtil::EnumStringLiteral *GetBinderTypeValues() {
524: 	static constexpr StringUtil::EnumStringLiteral values[] {
525: 		{ static_cast<uint32_t>(BinderType::REGULAR_BINDER), "REGULAR_BINDER" },
526: 		{ static_cast<uint32_t>(BinderType::VIEW_BINDER), "VIEW_BINDER" }
527: 	};
528: 	return values;
529: }
530: 
531: template<>
532: const char* EnumUtil::ToChars<BinderType>(BinderType value) {
533: 	return StringUtil::EnumToString(GetBinderTypeValues(), 2, "BinderType", static_cast<uint32_t>(value));
534: }
535: 
536: template<>
537: BinderType EnumUtil::FromString<BinderType>(const char *value) {
538: 	return static_cast<BinderType>(StringUtil::StringToEnum(GetBinderTypeValues(), 2, "BinderType", value));
539: }
540: 
541: const StringUtil::EnumStringLiteral *GetBindingModeValues() {
542: 	static constexpr StringUtil::EnumStringLiteral values[] {
543: 		{ static_cast<uint32_t>(BindingMode::STANDARD_BINDING), "STANDARD_BINDING" },
544: 		{ static_cast<uint32_t>(BindingMode::EXTRACT_NAMES), "EXTRACT_NAMES" },
545: 		{ static_cast<uint32_t>(BindingMode::EXTRACT_REPLACEMENT_SCANS), "EXTRACT_REPLACEMENT_SCANS" }
546: 	};
547: 	return values;
548: }
549: 
550: template<>
551: const char* EnumUtil::ToChars<BindingMode>(BindingMode value) {
552: 	return StringUtil::EnumToString(GetBindingModeValues(), 3, "BindingMode", static_cast<uint32_t>(value));
553: }
554: 
555: template<>
556: BindingMode EnumUtil::FromString<BindingMode>(const char *value) {
557: 	return static_cast<BindingMode>(StringUtil::StringToEnum(GetBindingModeValues(), 3, "BindingMode", value));
558: }
559: 
560: const StringUtil::EnumStringLiteral *GetBitpackingModeValues() {
561: 	static constexpr StringUtil::EnumStringLiteral values[] {
562: 		{ static_cast<uint32_t>(BitpackingMode::INVALID), "INVALID" },
563: 		{ static_cast<uint32_t>(BitpackingMode::AUTO), "AUTO" },
564: 		{ static_cast<uint32_t>(BitpackingMode::CONSTANT), "CONSTANT" },
565: 		{ static_cast<uint32_t>(BitpackingMode::CONSTANT_DELTA), "CONSTANT_DELTA" },
566: 		{ static_cast<uint32_t>(BitpackingMode::DELTA_FOR), "DELTA_FOR" },
567: 		{ static_cast<uint32_t>(BitpackingMode::FOR), "FOR" }
568: 	};
569: 	return values;
570: }
571: 
572: template<>
573: const char* EnumUtil::ToChars<BitpackingMode>(BitpackingMode value) {
574: 	return StringUtil::EnumToString(GetBitpackingModeValues(), 6, "BitpackingMode", static_cast<uint32_t>(value));
575: }
576: 
577: template<>
578: BitpackingMode EnumUtil::FromString<BitpackingMode>(const char *value) {
579: 	return static_cast<BitpackingMode>(StringUtil::StringToEnum(GetBitpackingModeValues(), 6, "BitpackingMode", value));
580: }
581: 
582: const StringUtil::EnumStringLiteral *GetBlockStateValues() {
583: 	static constexpr StringUtil::EnumStringLiteral values[] {
584: 		{ static_cast<uint32_t>(BlockState::BLOCK_UNLOADED), "BLOCK_UNLOADED" },
585: 		{ static_cast<uint32_t>(BlockState::BLOCK_LOADED), "BLOCK_LOADED" }
586: 	};
587: 	return values;
588: }
589: 
590: template<>
591: const char* EnumUtil::ToChars<BlockState>(BlockState value) {
592: 	return StringUtil::EnumToString(GetBlockStateValues(), 2, "BlockState", static_cast<uint32_t>(value));
593: }
594: 
595: template<>
596: BlockState EnumUtil::FromString<BlockState>(const char *value) {
597: 	return static_cast<BlockState>(StringUtil::StringToEnum(GetBlockStateValues(), 2, "BlockState", value));
598: }
599: 
600: const StringUtil::EnumStringLiteral *GetCAPIResultSetTypeValues() {
601: 	static constexpr StringUtil::EnumStringLiteral values[] {
602: 		{ static_cast<uint32_t>(CAPIResultSetType::CAPI_RESULT_TYPE_NONE), "CAPI_RESULT_TYPE_NONE" },
603: 		{ static_cast<uint32_t>(CAPIResultSetType::CAPI_RESULT_TYPE_MATERIALIZED), "CAPI_RESULT_TYPE_MATERIALIZED" },
604: 		{ static_cast<uint32_t>(CAPIResultSetType::CAPI_RESULT_TYPE_STREAMING), "CAPI_RESULT_TYPE_STREAMING" },
605: 		{ static_cast<uint32_t>(CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED), "CAPI_RESULT_TYPE_DEPRECATED" }
606: 	};
607: 	return values;
608: }
609: 
610: template<>
611: const char* EnumUtil::ToChars<CAPIResultSetType>(CAPIResultSetType value) {
612: 	return StringUtil::EnumToString(GetCAPIResultSetTypeValues(), 4, "CAPIResultSetType", static_cast<uint32_t>(value));
613: }
614: 
615: template<>
616: CAPIResultSetType EnumUtil::FromString<CAPIResultSetType>(const char *value) {
617: 	return static_cast<CAPIResultSetType>(StringUtil::StringToEnum(GetCAPIResultSetTypeValues(), 4, "CAPIResultSetType", value));
618: }
619: 
620: const StringUtil::EnumStringLiteral *GetCSVStateValues() {
621: 	static constexpr StringUtil::EnumStringLiteral values[] {
622: 		{ static_cast<uint32_t>(CSVState::STANDARD), "STANDARD" },
623: 		{ static_cast<uint32_t>(CSVState::DELIMITER), "DELIMITER" },
624: 		{ static_cast<uint32_t>(CSVState::DELIMITER_FIRST_BYTE), "DELIMITER_FIRST_BYTE" },
625: 		{ static_cast<uint32_t>(CSVState::DELIMITER_SECOND_BYTE), "DELIMITER_SECOND_BYTE" },
626: 		{ static_cast<uint32_t>(CSVState::DELIMITER_THIRD_BYTE), "DELIMITER_THIRD_BYTE" },
627: 		{ static_cast<uint32_t>(CSVState::RECORD_SEPARATOR), "RECORD_SEPARATOR" },
628: 		{ static_cast<uint32_t>(CSVState::CARRIAGE_RETURN), "CARRIAGE_RETURN" },
629: 		{ static_cast<uint32_t>(CSVState::QUOTED), "QUOTED" },
630: 		{ static_cast<uint32_t>(CSVState::UNQUOTED), "UNQUOTED" },
631: 		{ static_cast<uint32_t>(CSVState::ESCAPE), "ESCAPE" },
632: 		{ static_cast<uint32_t>(CSVState::INVALID), "INVALID" },
633: 		{ static_cast<uint32_t>(CSVState::NOT_SET), "NOT_SET" },
634: 		{ static_cast<uint32_t>(CSVState::QUOTED_NEW_LINE), "QUOTED_NEW_LINE" },
635: 		{ static_cast<uint32_t>(CSVState::EMPTY_SPACE), "EMPTY_SPACE" },
636: 		{ static_cast<uint32_t>(CSVState::COMMENT), "COMMENT" },
637: 		{ static_cast<uint32_t>(CSVState::STANDARD_NEWLINE), "STANDARD_NEWLINE" },
638: 		{ static_cast<uint32_t>(CSVState::UNQUOTED_ESCAPE), "UNQUOTED_ESCAPE" },
639: 		{ static_cast<uint32_t>(CSVState::ESCAPED_RETURN), "ESCAPED_RETURN" }
640: 	};
641: 	return values;
642: }
643: 
644: template<>
645: const char* EnumUtil::ToChars<CSVState>(CSVState value) {
646: 	return StringUtil::EnumToString(GetCSVStateValues(), 18, "CSVState", static_cast<uint32_t>(value));
647: }
648: 
649: template<>
650: CSVState EnumUtil::FromString<CSVState>(const char *value) {
651: 	return static_cast<CSVState>(StringUtil::StringToEnum(GetCSVStateValues(), 18, "CSVState", value));
652: }
653: 
654: const StringUtil::EnumStringLiteral *GetCTEMaterializeValues() {
655: 	static constexpr StringUtil::EnumStringLiteral values[] {
656: 		{ static_cast<uint32_t>(CTEMaterialize::CTE_MATERIALIZE_DEFAULT), "CTE_MATERIALIZE_DEFAULT" },
657: 		{ static_cast<uint32_t>(CTEMaterialize::CTE_MATERIALIZE_ALWAYS), "CTE_MATERIALIZE_ALWAYS" },
658: 		{ static_cast<uint32_t>(CTEMaterialize::CTE_MATERIALIZE_NEVER), "CTE_MATERIALIZE_NEVER" }
659: 	};
660: 	return values;
661: }
662: 
663: template<>
664: const char* EnumUtil::ToChars<CTEMaterialize>(CTEMaterialize value) {
665: 	return StringUtil::EnumToString(GetCTEMaterializeValues(), 3, "CTEMaterialize", static_cast<uint32_t>(value));
666: }
667: 
668: template<>
669: CTEMaterialize EnumUtil::FromString<CTEMaterialize>(const char *value) {
670: 	return static_cast<CTEMaterialize>(StringUtil::StringToEnum(GetCTEMaterializeValues(), 3, "CTEMaterialize", value));
671: }
672: 
673: const StringUtil::EnumStringLiteral *GetCatalogLookupBehaviorValues() {
674: 	static constexpr StringUtil::EnumStringLiteral values[] {
675: 		{ static_cast<uint32_t>(CatalogLookupBehavior::STANDARD), "STANDARD" },
676: 		{ static_cast<uint32_t>(CatalogLookupBehavior::LOWER_PRIORITY), "LOWER_PRIORITY" },
677: 		{ static_cast<uint32_t>(CatalogLookupBehavior::NEVER_LOOKUP), "NEVER_LOOKUP" }
678: 	};
679: 	return values;
680: }
681: 
682: template<>
683: const char* EnumUtil::ToChars<CatalogLookupBehavior>(CatalogLookupBehavior value) {
684: 	return StringUtil::EnumToString(GetCatalogLookupBehaviorValues(), 3, "CatalogLookupBehavior", static_cast<uint32_t>(value));
685: }
686: 
687: template<>
688: CatalogLookupBehavior EnumUtil::FromString<CatalogLookupBehavior>(const char *value) {
689: 	return static_cast<CatalogLookupBehavior>(StringUtil::StringToEnum(GetCatalogLookupBehaviorValues(), 3, "CatalogLookupBehavior", value));
690: }
691: 
692: const StringUtil::EnumStringLiteral *GetCatalogTypeValues() {
693: 	static constexpr StringUtil::EnumStringLiteral values[] {
694: 		{ static_cast<uint32_t>(CatalogType::INVALID), "INVALID" },
695: 		{ static_cast<uint32_t>(CatalogType::TABLE_ENTRY), "TABLE_ENTRY" },
696: 		{ static_cast<uint32_t>(CatalogType::SCHEMA_ENTRY), "SCHEMA_ENTRY" },
697: 		{ static_cast<uint32_t>(CatalogType::VIEW_ENTRY), "VIEW_ENTRY" },
698: 		{ static_cast<uint32_t>(CatalogType::INDEX_ENTRY), "INDEX_ENTRY" },
699: 		{ static_cast<uint32_t>(CatalogType::PREPARED_STATEMENT), "PREPARED_STATEMENT" },
700: 		{ static_cast<uint32_t>(CatalogType::SEQUENCE_ENTRY), "SEQUENCE_ENTRY" },
701: 		{ static_cast<uint32_t>(CatalogType::COLLATION_ENTRY), "COLLATION_ENTRY" },
702: 		{ static_cast<uint32_t>(CatalogType::TYPE_ENTRY), "TYPE_ENTRY" },
703: 		{ static_cast<uint32_t>(CatalogType::DATABASE_ENTRY), "DATABASE_ENTRY" },
704: 		{ static_cast<uint32_t>(CatalogType::TABLE_FUNCTION_ENTRY), "TABLE_FUNCTION_ENTRY" },
705: 		{ static_cast<uint32_t>(CatalogType::SCALAR_FUNCTION_ENTRY), "SCALAR_FUNCTION_ENTRY" },
706: 		{ static_cast<uint32_t>(CatalogType::AGGREGATE_FUNCTION_ENTRY), "AGGREGATE_FUNCTION_ENTRY" },
707: 		{ static_cast<uint32_t>(CatalogType::PRAGMA_FUNCTION_ENTRY), "PRAGMA_FUNCTION_ENTRY" },
708: 		{ static_cast<uint32_t>(CatalogType::COPY_FUNCTION_ENTRY), "COPY_FUNCTION_ENTRY" },
709: 		{ static_cast<uint32_t>(CatalogType::MACRO_ENTRY), "MACRO_ENTRY" },
710: 		{ static_cast<uint32_t>(CatalogType::TABLE_MACRO_ENTRY), "TABLE_MACRO_ENTRY" },
711: 		{ static_cast<uint32_t>(CatalogType::DELETED_ENTRY), "DELETED_ENTRY" },
712: 		{ static_cast<uint32_t>(CatalogType::RENAMED_ENTRY), "RENAMED_ENTRY" },
713: 		{ static_cast<uint32_t>(CatalogType::SECRET_ENTRY), "SECRET_ENTRY" },
714: 		{ static_cast<uint32_t>(CatalogType::SECRET_TYPE_ENTRY), "SECRET_TYPE_ENTRY" },
715: 		{ static_cast<uint32_t>(CatalogType::SECRET_FUNCTION_ENTRY), "SECRET_FUNCTION_ENTRY" },
716: 		{ static_cast<uint32_t>(CatalogType::DEPENDENCY_ENTRY), "DEPENDENCY_ENTRY" }
717: 	};
718: 	return values;
719: }
720: 
721: template<>
722: const char* EnumUtil::ToChars<CatalogType>(CatalogType value) {
723: 	return StringUtil::EnumToString(GetCatalogTypeValues(), 23, "CatalogType", static_cast<uint32_t>(value));
724: }
725: 
726: template<>
727: CatalogType EnumUtil::FromString<CatalogType>(const char *value) {
728: 	return static_cast<CatalogType>(StringUtil::StringToEnum(GetCatalogTypeValues(), 23, "CatalogType", value));
729: }
730: 
731: const StringUtil::EnumStringLiteral *GetCheckpointAbortValues() {
732: 	static constexpr StringUtil::EnumStringLiteral values[] {
733: 		{ static_cast<uint32_t>(CheckpointAbort::NO_ABORT), "NONE" },
734: 		{ static_cast<uint32_t>(CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE), "BEFORE_TRUNCATE" },
735: 		{ static_cast<uint32_t>(CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER), "BEFORE_HEADER" },
736: 		{ static_cast<uint32_t>(CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE), "AFTER_FREE_LIST_WRITE" }
737: 	};
738: 	return values;
739: }
740: 
741: template<>
742: const char* EnumUtil::ToChars<CheckpointAbort>(CheckpointAbort value) {
743: 	return StringUtil::EnumToString(GetCheckpointAbortValues(), 4, "CheckpointAbort", static_cast<uint32_t>(value));
744: }
745: 
746: template<>
747: CheckpointAbort EnumUtil::FromString<CheckpointAbort>(const char *value) {
748: 	return static_cast<CheckpointAbort>(StringUtil::StringToEnum(GetCheckpointAbortValues(), 4, "CheckpointAbort", value));
749: }
750: 
751: const StringUtil::EnumStringLiteral *GetChunkInfoTypeValues() {
752: 	static constexpr StringUtil::EnumStringLiteral values[] {
753: 		{ static_cast<uint32_t>(ChunkInfoType::CONSTANT_INFO), "CONSTANT_INFO" },
754: 		{ static_cast<uint32_t>(ChunkInfoType::VECTOR_INFO), "VECTOR_INFO" },
755: 		{ static_cast<uint32_t>(ChunkInfoType::EMPTY_INFO), "EMPTY_INFO" }
756: 	};
757: 	return values;
758: }
759: 
760: template<>
761: const char* EnumUtil::ToChars<ChunkInfoType>(ChunkInfoType value) {
762: 	return StringUtil::EnumToString(GetChunkInfoTypeValues(), 3, "ChunkInfoType", static_cast<uint32_t>(value));
763: }
764: 
765: template<>
766: ChunkInfoType EnumUtil::FromString<ChunkInfoType>(const char *value) {
767: 	return static_cast<ChunkInfoType>(StringUtil::StringToEnum(GetChunkInfoTypeValues(), 3, "ChunkInfoType", value));
768: }
769: 
770: const StringUtil::EnumStringLiteral *GetColumnDataAllocatorTypeValues() {
771: 	static constexpr StringUtil::EnumStringLiteral values[] {
772: 		{ static_cast<uint32_t>(ColumnDataAllocatorType::BUFFER_MANAGER_ALLOCATOR), "BUFFER_MANAGER_ALLOCATOR" },
773: 		{ static_cast<uint32_t>(ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR), "IN_MEMORY_ALLOCATOR" },
774: 		{ static_cast<uint32_t>(ColumnDataAllocatorType::HYBRID), "HYBRID" }
775: 	};
776: 	return values;
777: }
778: 
779: template<>
780: const char* EnumUtil::ToChars<ColumnDataAllocatorType>(ColumnDataAllocatorType value) {
781: 	return StringUtil::EnumToString(GetColumnDataAllocatorTypeValues(), 3, "ColumnDataAllocatorType", static_cast<uint32_t>(value));
782: }
783: 
784: template<>
785: ColumnDataAllocatorType EnumUtil::FromString<ColumnDataAllocatorType>(const char *value) {
786: 	return static_cast<ColumnDataAllocatorType>(StringUtil::StringToEnum(GetColumnDataAllocatorTypeValues(), 3, "ColumnDataAllocatorType", value));
787: }
788: 
789: const StringUtil::EnumStringLiteral *GetColumnDataScanPropertiesValues() {
790: 	static constexpr StringUtil::EnumStringLiteral values[] {
791: 		{ static_cast<uint32_t>(ColumnDataScanProperties::INVALID), "INVALID" },
792: 		{ static_cast<uint32_t>(ColumnDataScanProperties::ALLOW_ZERO_COPY), "ALLOW_ZERO_COPY" },
793: 		{ static_cast<uint32_t>(ColumnDataScanProperties::DISALLOW_ZERO_COPY), "DISALLOW_ZERO_COPY" }
794: 	};
795: 	return values;
796: }
797: 
798: template<>
799: const char* EnumUtil::ToChars<ColumnDataScanProperties>(ColumnDataScanProperties value) {
800: 	return StringUtil::EnumToString(GetColumnDataScanPropertiesValues(), 3, "ColumnDataScanProperties", static_cast<uint32_t>(value));
801: }
802: 
803: template<>
804: ColumnDataScanProperties EnumUtil::FromString<ColumnDataScanProperties>(const char *value) {
805: 	return static_cast<ColumnDataScanProperties>(StringUtil::StringToEnum(GetColumnDataScanPropertiesValues(), 3, "ColumnDataScanProperties", value));
806: }
807: 
808: const StringUtil::EnumStringLiteral *GetColumnSegmentTypeValues() {
809: 	static constexpr StringUtil::EnumStringLiteral values[] {
810: 		{ static_cast<uint32_t>(ColumnSegmentType::TRANSIENT), "TRANSIENT" },
811: 		{ static_cast<uint32_t>(ColumnSegmentType::PERSISTENT), "PERSISTENT" }
812: 	};
813: 	return values;
814: }
815: 
816: template<>
817: const char* EnumUtil::ToChars<ColumnSegmentType>(ColumnSegmentType value) {
818: 	return StringUtil::EnumToString(GetColumnSegmentTypeValues(), 2, "ColumnSegmentType", static_cast<uint32_t>(value));
819: }
820: 
821: template<>
822: ColumnSegmentType EnumUtil::FromString<ColumnSegmentType>(const char *value) {
823: 	return static_cast<ColumnSegmentType>(StringUtil::StringToEnum(GetColumnSegmentTypeValues(), 2, "ColumnSegmentType", value));
824: }
825: 
826: const StringUtil::EnumStringLiteral *GetCompressedMaterializationDirectionValues() {
827: 	static constexpr StringUtil::EnumStringLiteral values[] {
828: 		{ static_cast<uint32_t>(CompressedMaterializationDirection::INVALID), "INVALID" },
829: 		{ static_cast<uint32_t>(CompressedMaterializationDirection::COMPRESS), "COMPRESS" },
830: 		{ static_cast<uint32_t>(CompressedMaterializationDirection::DECOMPRESS), "DECOMPRESS" }
831: 	};
832: 	return values;
833: }
834: 
835: template<>
836: const char* EnumUtil::ToChars<CompressedMaterializationDirection>(CompressedMaterializationDirection value) {
837: 	return StringUtil::EnumToString(GetCompressedMaterializationDirectionValues(), 3, "CompressedMaterializationDirection", static_cast<uint32_t>(value));
838: }
839: 
840: template<>
841: CompressedMaterializationDirection EnumUtil::FromString<CompressedMaterializationDirection>(const char *value) {
842: 	return static_cast<CompressedMaterializationDirection>(StringUtil::StringToEnum(GetCompressedMaterializationDirectionValues(), 3, "CompressedMaterializationDirection", value));
843: }
844: 
845: const StringUtil::EnumStringLiteral *GetCompressionTypeValues() {
846: 	static constexpr StringUtil::EnumStringLiteral values[] {
847: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_AUTO), "COMPRESSION_AUTO" },
848: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_UNCOMPRESSED), "COMPRESSION_UNCOMPRESSED" },
849: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_CONSTANT), "COMPRESSION_CONSTANT" },
850: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_RLE), "COMPRESSION_RLE" },
851: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_DICTIONARY), "COMPRESSION_DICTIONARY" },
852: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_PFOR_DELTA), "COMPRESSION_PFOR_DELTA" },
853: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_BITPACKING), "COMPRESSION_BITPACKING" },
854: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_FSST), "COMPRESSION_FSST" },
855: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_CHIMP), "COMPRESSION_CHIMP" },
856: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_PATAS), "COMPRESSION_PATAS" },
857: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_ALP), "COMPRESSION_ALP" },
858: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_ALPRD), "COMPRESSION_ALPRD" },
859: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_ZSTD), "COMPRESSION_ZSTD" },
860: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_ROARING), "COMPRESSION_ROARING" },
861: 		{ static_cast<uint32_t>(CompressionType::COMPRESSION_COUNT), "COMPRESSION_COUNT" }
862: 	};
863: 	return values;
864: }
865: 
866: template<>
867: const char* EnumUtil::ToChars<CompressionType>(CompressionType value) {
868: 	return StringUtil::EnumToString(GetCompressionTypeValues(), 15, "CompressionType", static_cast<uint32_t>(value));
869: }
870: 
871: template<>
872: CompressionType EnumUtil::FromString<CompressionType>(const char *value) {
873: 	return static_cast<CompressionType>(StringUtil::StringToEnum(GetCompressionTypeValues(), 15, "CompressionType", value));
874: }
875: 
876: const StringUtil::EnumStringLiteral *GetConflictManagerModeValues() {
877: 	static constexpr StringUtil::EnumStringLiteral values[] {
878: 		{ static_cast<uint32_t>(ConflictManagerMode::SCAN), "SCAN" },
879: 		{ static_cast<uint32_t>(ConflictManagerMode::THROW), "THROW" }
880: 	};
881: 	return values;
882: }
883: 
884: template<>
885: const char* EnumUtil::ToChars<ConflictManagerMode>(ConflictManagerMode value) {
886: 	return StringUtil::EnumToString(GetConflictManagerModeValues(), 2, "ConflictManagerMode", static_cast<uint32_t>(value));
887: }
888: 
889: template<>
890: ConflictManagerMode EnumUtil::FromString<ConflictManagerMode>(const char *value) {
891: 	return static_cast<ConflictManagerMode>(StringUtil::StringToEnum(GetConflictManagerModeValues(), 2, "ConflictManagerMode", value));
892: }
893: 
894: const StringUtil::EnumStringLiteral *GetConstraintTypeValues() {
895: 	static constexpr StringUtil::EnumStringLiteral values[] {
896: 		{ static_cast<uint32_t>(ConstraintType::INVALID), "INVALID" },
897: 		{ static_cast<uint32_t>(ConstraintType::NOT_NULL), "NOT_NULL" },
898: 		{ static_cast<uint32_t>(ConstraintType::CHECK), "CHECK" },
899: 		{ static_cast<uint32_t>(ConstraintType::UNIQUE), "UNIQUE" },
900: 		{ static_cast<uint32_t>(ConstraintType::FOREIGN_KEY), "FOREIGN_KEY" }
901: 	};
902: 	return values;
903: }
904: 
905: template<>
906: const char* EnumUtil::ToChars<ConstraintType>(ConstraintType value) {
907: 	return StringUtil::EnumToString(GetConstraintTypeValues(), 5, "ConstraintType", static_cast<uint32_t>(value));
908: }
909: 
910: template<>
911: ConstraintType EnumUtil::FromString<ConstraintType>(const char *value) {
912: 	return static_cast<ConstraintType>(StringUtil::StringToEnum(GetConstraintTypeValues(), 5, "ConstraintType", value));
913: }
914: 
915: const StringUtil::EnumStringLiteral *GetCopyFunctionReturnTypeValues() {
916: 	static constexpr StringUtil::EnumStringLiteral values[] {
917: 		{ static_cast<uint32_t>(CopyFunctionReturnType::CHANGED_ROWS), "CHANGED_ROWS" },
918: 		{ static_cast<uint32_t>(CopyFunctionReturnType::CHANGED_ROWS_AND_FILE_LIST), "CHANGED_ROWS_AND_FILE_LIST" }
919: 	};
920: 	return values;
921: }
922: 
923: template<>
924: const char* EnumUtil::ToChars<CopyFunctionReturnType>(CopyFunctionReturnType value) {
925: 	return StringUtil::EnumToString(GetCopyFunctionReturnTypeValues(), 2, "CopyFunctionReturnType", static_cast<uint32_t>(value));
926: }
927: 
928: template<>
929: CopyFunctionReturnType EnumUtil::FromString<CopyFunctionReturnType>(const char *value) {
930: 	return static_cast<CopyFunctionReturnType>(StringUtil::StringToEnum(GetCopyFunctionReturnTypeValues(), 2, "CopyFunctionReturnType", value));
931: }
932: 
933: const StringUtil::EnumStringLiteral *GetCopyOverwriteModeValues() {
934: 	static constexpr StringUtil::EnumStringLiteral values[] {
935: 		{ static_cast<uint32_t>(CopyOverwriteMode::COPY_ERROR_ON_CONFLICT), "COPY_ERROR_ON_CONFLICT" },
936: 		{ static_cast<uint32_t>(CopyOverwriteMode::COPY_OVERWRITE), "COPY_OVERWRITE" },
937: 		{ static_cast<uint32_t>(CopyOverwriteMode::COPY_OVERWRITE_OR_IGNORE), "COPY_OVERWRITE_OR_IGNORE" },
938: 		{ static_cast<uint32_t>(CopyOverwriteMode::COPY_APPEND), "COPY_APPEND" }
939: 	};
940: 	return values;
941: }
942: 
943: template<>
944: const char* EnumUtil::ToChars<CopyOverwriteMode>(CopyOverwriteMode value) {
945: 	return StringUtil::EnumToString(GetCopyOverwriteModeValues(), 4, "CopyOverwriteMode", static_cast<uint32_t>(value));
946: }
947: 
948: template<>
949: CopyOverwriteMode EnumUtil::FromString<CopyOverwriteMode>(const char *value) {
950: 	return static_cast<CopyOverwriteMode>(StringUtil::StringToEnum(GetCopyOverwriteModeValues(), 4, "CopyOverwriteMode", value));
951: }
952: 
953: const StringUtil::EnumStringLiteral *GetCopyToTypeValues() {
954: 	static constexpr StringUtil::EnumStringLiteral values[] {
955: 		{ static_cast<uint32_t>(CopyToType::COPY_TO_FILE), "COPY_TO_FILE" },
956: 		{ static_cast<uint32_t>(CopyToType::EXPORT_DATABASE), "EXPORT_DATABASE" }
957: 	};
958: 	return values;
959: }
960: 
961: template<>
962: const char* EnumUtil::ToChars<CopyToType>(CopyToType value) {
963: 	return StringUtil::EnumToString(GetCopyToTypeValues(), 2, "CopyToType", static_cast<uint32_t>(value));
964: }
965: 
966: template<>
967: CopyToType EnumUtil::FromString<CopyToType>(const char *value) {
968: 	return static_cast<CopyToType>(StringUtil::StringToEnum(GetCopyToTypeValues(), 2, "CopyToType", value));
969: }
970: 
971: const StringUtil::EnumStringLiteral *GetDataFileTypeValues() {
972: 	static constexpr StringUtil::EnumStringLiteral values[] {
973: 		{ static_cast<uint32_t>(DataFileType::FILE_DOES_NOT_EXIST), "FILE_DOES_NOT_EXIST" },
974: 		{ static_cast<uint32_t>(DataFileType::DUCKDB_FILE), "DUCKDB_FILE" },
975: 		{ static_cast<uint32_t>(DataFileType::SQLITE_FILE), "SQLITE_FILE" },
976: 		{ static_cast<uint32_t>(DataFileType::PARQUET_FILE), "PARQUET_FILE" }
977: 	};
978: 	return values;
979: }
980: 
981: template<>
982: const char* EnumUtil::ToChars<DataFileType>(DataFileType value) {
983: 	return StringUtil::EnumToString(GetDataFileTypeValues(), 4, "DataFileType", static_cast<uint32_t>(value));
984: }
985: 
986: template<>
987: DataFileType EnumUtil::FromString<DataFileType>(const char *value) {
988: 	return static_cast<DataFileType>(StringUtil::StringToEnum(GetDataFileTypeValues(), 4, "DataFileType", value));
989: }
990: 
991: const StringUtil::EnumStringLiteral *GetDatePartSpecifierValues() {
992: 	static constexpr StringUtil::EnumStringLiteral values[] {
993: 		{ static_cast<uint32_t>(DatePartSpecifier::YEAR), "YEAR" },
994: 		{ static_cast<uint32_t>(DatePartSpecifier::MONTH), "MONTH" },
995: 		{ static_cast<uint32_t>(DatePartSpecifier::DAY), "DAY" },
996: 		{ static_cast<uint32_t>(DatePartSpecifier::DECADE), "DECADE" },
997: 		{ static_cast<uint32_t>(DatePartSpecifier::CENTURY), "CENTURY" },
998: 		{ static_cast<uint32_t>(DatePartSpecifier::MILLENNIUM), "MILLENNIUM" },
999: 		{ static_cast<uint32_t>(DatePartSpecifier::MICROSECONDS), "MICROSECONDS" },
1000: 		{ static_cast<uint32_t>(DatePartSpecifier::MILLISECONDS), "MILLISECONDS" },
1001: 		{ static_cast<uint32_t>(DatePartSpecifier::SECOND), "SECOND" },
1002: 		{ static_cast<uint32_t>(DatePartSpecifier::MINUTE), "MINUTE" },
1003: 		{ static_cast<uint32_t>(DatePartSpecifier::HOUR), "HOUR" },
1004: 		{ static_cast<uint32_t>(DatePartSpecifier::DOW), "DOW" },
1005: 		{ static_cast<uint32_t>(DatePartSpecifier::ISODOW), "ISODOW" },
1006: 		{ static_cast<uint32_t>(DatePartSpecifier::WEEK), "WEEK" },
1007: 		{ static_cast<uint32_t>(DatePartSpecifier::ISOYEAR), "ISOYEAR" },
1008: 		{ static_cast<uint32_t>(DatePartSpecifier::QUARTER), "QUARTER" },
1009: 		{ static_cast<uint32_t>(DatePartSpecifier::DOY), "DOY" },
1010: 		{ static_cast<uint32_t>(DatePartSpecifier::YEARWEEK), "YEARWEEK" },
1011: 		{ static_cast<uint32_t>(DatePartSpecifier::ERA), "ERA" },
1012: 		{ static_cast<uint32_t>(DatePartSpecifier::TIMEZONE), "TIMEZONE" },
1013: 		{ static_cast<uint32_t>(DatePartSpecifier::TIMEZONE_HOUR), "TIMEZONE_HOUR" },
1014: 		{ static_cast<uint32_t>(DatePartSpecifier::TIMEZONE_MINUTE), "TIMEZONE_MINUTE" },
1015: 		{ static_cast<uint32_t>(DatePartSpecifier::EPOCH), "EPOCH" },
1016: 		{ static_cast<uint32_t>(DatePartSpecifier::JULIAN_DAY), "JULIAN_DAY" },
1017: 		{ static_cast<uint32_t>(DatePartSpecifier::INVALID), "INVALID" }
1018: 	};
1019: 	return values;
1020: }
1021: 
1022: template<>
1023: const char* EnumUtil::ToChars<DatePartSpecifier>(DatePartSpecifier value) {
1024: 	return StringUtil::EnumToString(GetDatePartSpecifierValues(), 25, "DatePartSpecifier", static_cast<uint32_t>(value));
1025: }
1026: 
1027: template<>
1028: DatePartSpecifier EnumUtil::FromString<DatePartSpecifier>(const char *value) {
1029: 	return static_cast<DatePartSpecifier>(StringUtil::StringToEnum(GetDatePartSpecifierValues(), 25, "DatePartSpecifier", value));
1030: }
1031: 
1032: const StringUtil::EnumStringLiteral *GetDebugInitializeValues() {
1033: 	static constexpr StringUtil::EnumStringLiteral values[] {
1034: 		{ static_cast<uint32_t>(DebugInitialize::NO_INITIALIZE), "NO_INITIALIZE" },
1035: 		{ static_cast<uint32_t>(DebugInitialize::DEBUG_ZERO_INITIALIZE), "DEBUG_ZERO_INITIALIZE" },
1036: 		{ static_cast<uint32_t>(DebugInitialize::DEBUG_ONE_INITIALIZE), "DEBUG_ONE_INITIALIZE" }
1037: 	};
1038: 	return values;
1039: }
1040: 
1041: template<>
1042: const char* EnumUtil::ToChars<DebugInitialize>(DebugInitialize value) {
1043: 	return StringUtil::EnumToString(GetDebugInitializeValues(), 3, "DebugInitialize", static_cast<uint32_t>(value));
1044: }
1045: 
1046: template<>
1047: DebugInitialize EnumUtil::FromString<DebugInitialize>(const char *value) {
1048: 	return static_cast<DebugInitialize>(StringUtil::StringToEnum(GetDebugInitializeValues(), 3, "DebugInitialize", value));
1049: }
1050: 
1051: const StringUtil::EnumStringLiteral *GetDefaultOrderByNullTypeValues() {
1052: 	static constexpr StringUtil::EnumStringLiteral values[] {
1053: 		{ static_cast<uint32_t>(DefaultOrderByNullType::INVALID), "INVALID" },
1054: 		{ static_cast<uint32_t>(DefaultOrderByNullType::NULLS_FIRST), "NULLS_FIRST" },
1055: 		{ static_cast<uint32_t>(DefaultOrderByNullType::NULLS_LAST), "NULLS_LAST" },
1056: 		{ static_cast<uint32_t>(DefaultOrderByNullType::NULLS_FIRST_ON_ASC_LAST_ON_DESC), "NULLS_FIRST_ON_ASC_LAST_ON_DESC" },
1057: 		{ static_cast<uint32_t>(DefaultOrderByNullType::NULLS_LAST_ON_ASC_FIRST_ON_DESC), "NULLS_LAST_ON_ASC_FIRST_ON_DESC" }
1058: 	};
1059: 	return values;
1060: }
1061: 
1062: template<>
1063: const char* EnumUtil::ToChars<DefaultOrderByNullType>(DefaultOrderByNullType value) {
1064: 	return StringUtil::EnumToString(GetDefaultOrderByNullTypeValues(), 5, "DefaultOrderByNullType", static_cast<uint32_t>(value));
1065: }
1066: 
1067: template<>
1068: DefaultOrderByNullType EnumUtil::FromString<DefaultOrderByNullType>(const char *value) {
1069: 	return static_cast<DefaultOrderByNullType>(StringUtil::StringToEnum(GetDefaultOrderByNullTypeValues(), 5, "DefaultOrderByNullType", value));
1070: }
1071: 
1072: const StringUtil::EnumStringLiteral *GetDependencyEntryTypeValues() {
1073: 	static constexpr StringUtil::EnumStringLiteral values[] {
1074: 		{ static_cast<uint32_t>(DependencyEntryType::SUBJECT), "SUBJECT" },
1075: 		{ static_cast<uint32_t>(DependencyEntryType::DEPENDENT), "DEPENDENT" }
1076: 	};
1077: 	return values;
1078: }
1079: 
1080: template<>
1081: const char* EnumUtil::ToChars<DependencyEntryType>(DependencyEntryType value) {
1082: 	return StringUtil::EnumToString(GetDependencyEntryTypeValues(), 2, "DependencyEntryType", static_cast<uint32_t>(value));
1083: }
1084: 
1085: template<>
1086: DependencyEntryType EnumUtil::FromString<DependencyEntryType>(const char *value) {
1087: 	return static_cast<DependencyEntryType>(StringUtil::StringToEnum(GetDependencyEntryTypeValues(), 2, "DependencyEntryType", value));
1088: }
1089: 
1090: const StringUtil::EnumStringLiteral *GetDeprecatedIndexTypeValues() {
1091: 	static constexpr StringUtil::EnumStringLiteral values[] {
1092: 		{ static_cast<uint32_t>(DeprecatedIndexType::INVALID), "INVALID" },
1093: 		{ static_cast<uint32_t>(DeprecatedIndexType::ART), "ART" },
1094: 		{ static_cast<uint32_t>(DeprecatedIndexType::EXTENSION), "EXTENSION" }
1095: 	};
1096: 	return values;
1097: }
1098: 
1099: template<>
1100: const char* EnumUtil::ToChars<DeprecatedIndexType>(DeprecatedIndexType value) {
1101: 	return StringUtil::EnumToString(GetDeprecatedIndexTypeValues(), 3, "DeprecatedIndexType", static_cast<uint32_t>(value));
1102: }
1103: 
1104: template<>
1105: DeprecatedIndexType EnumUtil::FromString<DeprecatedIndexType>(const char *value) {
1106: 	return static_cast<DeprecatedIndexType>(StringUtil::StringToEnum(GetDeprecatedIndexTypeValues(), 3, "DeprecatedIndexType", value));
1107: }
1108: 
1109: const StringUtil::EnumStringLiteral *GetDestroyBufferUponValues() {
1110: 	static constexpr StringUtil::EnumStringLiteral values[] {
1111: 		{ static_cast<uint32_t>(DestroyBufferUpon::BLOCK), "BLOCK" },
1112: 		{ static_cast<uint32_t>(DestroyBufferUpon::EVICTION), "EVICTION" },
1113: 		{ static_cast<uint32_t>(DestroyBufferUpon::UNPIN), "UNPIN" }
1114: 	};
1115: 	return values;
1116: }
1117: 
1118: template<>
1119: const char* EnumUtil::ToChars<DestroyBufferUpon>(DestroyBufferUpon value) {
1120: 	return StringUtil::EnumToString(GetDestroyBufferUponValues(), 3, "DestroyBufferUpon", static_cast<uint32_t>(value));
1121: }
1122: 
1123: template<>
1124: DestroyBufferUpon EnumUtil::FromString<DestroyBufferUpon>(const char *value) {
1125: 	return static_cast<DestroyBufferUpon>(StringUtil::StringToEnum(GetDestroyBufferUponValues(), 3, "DestroyBufferUpon", value));
1126: }
1127: 
1128: const StringUtil::EnumStringLiteral *GetDistinctTypeValues() {
1129: 	static constexpr StringUtil::EnumStringLiteral values[] {
1130: 		{ static_cast<uint32_t>(DistinctType::DISTINCT), "DISTINCT" },
1131: 		{ static_cast<uint32_t>(DistinctType::DISTINCT_ON), "DISTINCT_ON" }
1132: 	};
1133: 	return values;
1134: }
1135: 
1136: template<>
1137: const char* EnumUtil::ToChars<DistinctType>(DistinctType value) {
1138: 	return StringUtil::EnumToString(GetDistinctTypeValues(), 2, "DistinctType", static_cast<uint32_t>(value));
1139: }
1140: 
1141: template<>
1142: DistinctType EnumUtil::FromString<DistinctType>(const char *value) {
1143: 	return static_cast<DistinctType>(StringUtil::StringToEnum(GetDistinctTypeValues(), 2, "DistinctType", value));
1144: }
1145: 
1146: const StringUtil::EnumStringLiteral *GetErrorTypeValues() {
1147: 	static constexpr StringUtil::EnumStringLiteral values[] {
1148: 		{ static_cast<uint32_t>(ErrorType::UNSIGNED_EXTENSION), "UNSIGNED_EXTENSION" },
1149: 		{ static_cast<uint32_t>(ErrorType::INVALIDATED_TRANSACTION), "INVALIDATED_TRANSACTION" },
1150: 		{ static_cast<uint32_t>(ErrorType::INVALIDATED_DATABASE), "INVALIDATED_DATABASE" },
1151: 		{ static_cast<uint32_t>(ErrorType::ERROR_COUNT), "ERROR_COUNT" },
1152: 		{ static_cast<uint32_t>(ErrorType::INVALID), "INVALID" }
1153: 	};
1154: 	return values;
1155: }
1156: 
1157: template<>
1158: const char* EnumUtil::ToChars<ErrorType>(ErrorType value) {
1159: 	return StringUtil::EnumToString(GetErrorTypeValues(), 5, "ErrorType", static_cast<uint32_t>(value));
1160: }
1161: 
1162: template<>
1163: ErrorType EnumUtil::FromString<ErrorType>(const char *value) {
1164: 	return static_cast<ErrorType>(StringUtil::StringToEnum(GetErrorTypeValues(), 5, "ErrorType", value));
1165: }
1166: 
1167: const StringUtil::EnumStringLiteral *GetExceptionFormatValueTypeValues() {
1168: 	static constexpr StringUtil::EnumStringLiteral values[] {
1169: 		{ static_cast<uint32_t>(ExceptionFormatValueType::FORMAT_VALUE_TYPE_DOUBLE), "FORMAT_VALUE_TYPE_DOUBLE" },
1170: 		{ static_cast<uint32_t>(ExceptionFormatValueType::FORMAT_VALUE_TYPE_INTEGER), "FORMAT_VALUE_TYPE_INTEGER" },
1171: 		{ static_cast<uint32_t>(ExceptionFormatValueType::FORMAT_VALUE_TYPE_STRING), "FORMAT_VALUE_TYPE_STRING" }
1172: 	};
1173: 	return values;
1174: }
1175: 
1176: template<>
1177: const char* EnumUtil::ToChars<ExceptionFormatValueType>(ExceptionFormatValueType value) {
1178: 	return StringUtil::EnumToString(GetExceptionFormatValueTypeValues(), 3, "ExceptionFormatValueType", static_cast<uint32_t>(value));
1179: }
1180: 
1181: template<>
1182: ExceptionFormatValueType EnumUtil::FromString<ExceptionFormatValueType>(const char *value) {
1183: 	return static_cast<ExceptionFormatValueType>(StringUtil::StringToEnum(GetExceptionFormatValueTypeValues(), 3, "ExceptionFormatValueType", value));
1184: }
1185: 
1186: const StringUtil::EnumStringLiteral *GetExceptionTypeValues() {
1187: 	static constexpr StringUtil::EnumStringLiteral values[] {
1188: 		{ static_cast<uint32_t>(ExceptionType::INVALID), "INVALID" },
1189: 		{ static_cast<uint32_t>(ExceptionType::OUT_OF_RANGE), "OUT_OF_RANGE" },
1190: 		{ static_cast<uint32_t>(ExceptionType::CONVERSION), "CONVERSION" },
1191: 		{ static_cast<uint32_t>(ExceptionType::UNKNOWN_TYPE), "UNKNOWN_TYPE" },
1192: 		{ static_cast<uint32_t>(ExceptionType::DECIMAL), "DECIMAL" },
1193: 		{ static_cast<uint32_t>(ExceptionType::MISMATCH_TYPE), "MISMATCH_TYPE" },
1194: 		{ static_cast<uint32_t>(ExceptionType::DIVIDE_BY_ZERO), "DIVIDE_BY_ZERO" },
1195: 		{ static_cast<uint32_t>(ExceptionType::OBJECT_SIZE), "OBJECT_SIZE" },
1196: 		{ static_cast<uint32_t>(ExceptionType::INVALID_TYPE), "INVALID_TYPE" },
1197: 		{ static_cast<uint32_t>(ExceptionType::SERIALIZATION), "SERIALIZATION" },
1198: 		{ static_cast<uint32_t>(ExceptionType::TRANSACTION), "TRANSACTION" },
1199: 		{ static_cast<uint32_t>(ExceptionType::NOT_IMPLEMENTED), "NOT_IMPLEMENTED" },
1200: 		{ static_cast<uint32_t>(ExceptionType::EXPRESSION), "EXPRESSION" },
1201: 		{ static_cast<uint32_t>(ExceptionType::CATALOG), "CATALOG" },
1202: 		{ static_cast<uint32_t>(ExceptionType::PARSER), "PARSER" },
1203: 		{ static_cast<uint32_t>(ExceptionType::PLANNER), "PLANNER" },
1204: 		{ static_cast<uint32_t>(ExceptionType::SCHEDULER), "SCHEDULER" },
1205: 		{ static_cast<uint32_t>(ExceptionType::EXECUTOR), "EXECUTOR" },
1206: 		{ static_cast<uint32_t>(ExceptionType::CONSTRAINT), "CONSTRAINT" },
1207: 		{ static_cast<uint32_t>(ExceptionType::INDEX), "INDEX" },
1208: 		{ static_cast<uint32_t>(ExceptionType::STAT), "STAT" },
1209: 		{ static_cast<uint32_t>(ExceptionType::CONNECTION), "CONNECTION" },
1210: 		{ static_cast<uint32_t>(ExceptionType::SYNTAX), "SYNTAX" },
1211: 		{ static_cast<uint32_t>(ExceptionType::SETTINGS), "SETTINGS" },
1212: 		{ static_cast<uint32_t>(ExceptionType::BINDER), "BINDER" },
1213: 		{ static_cast<uint32_t>(ExceptionType::NETWORK), "NETWORK" },
1214: 		{ static_cast<uint32_t>(ExceptionType::OPTIMIZER), "OPTIMIZER" },
1215: 		{ static_cast<uint32_t>(ExceptionType::NULL_POINTER), "NULL_POINTER" },
1216: 		{ static_cast<uint32_t>(ExceptionType::IO), "IO" },
1217: 		{ static_cast<uint32_t>(ExceptionType::INTERRUPT), "INTERRUPT" },
1218: 		{ static_cast<uint32_t>(ExceptionType::FATAL), "FATAL" },
1219: 		{ static_cast<uint32_t>(ExceptionType::INTERNAL), "INTERNAL" },
1220: 		{ static_cast<uint32_t>(ExceptionType::INVALID_INPUT), "INVALID_INPUT" },
1221: 		{ static_cast<uint32_t>(ExceptionType::OUT_OF_MEMORY), "OUT_OF_MEMORY" },
1222: 		{ static_cast<uint32_t>(ExceptionType::PERMISSION), "PERMISSION" },
1223: 		{ static_cast<uint32_t>(ExceptionType::PARAMETER_NOT_RESOLVED), "PARAMETER_NOT_RESOLVED" },
1224: 		{ static_cast<uint32_t>(ExceptionType::PARAMETER_NOT_ALLOWED), "PARAMETER_NOT_ALLOWED" },
1225: 		{ static_cast<uint32_t>(ExceptionType::DEPENDENCY), "DEPENDENCY" },
1226: 		{ static_cast<uint32_t>(ExceptionType::HTTP), "HTTP" },
1227: 		{ static_cast<uint32_t>(ExceptionType::MISSING_EXTENSION), "MISSING_EXTENSION" },
1228: 		{ static_cast<uint32_t>(ExceptionType::AUTOLOAD), "AUTOLOAD" },
1229: 		{ static_cast<uint32_t>(ExceptionType::SEQUENCE), "SEQUENCE" },
1230: 		{ static_cast<uint32_t>(ExceptionType::INVALID_CONFIGURATION), "INVALID_CONFIGURATION" }
1231: 	};
1232: 	return values;
1233: }
1234: 
1235: template<>
1236: const char* EnumUtil::ToChars<ExceptionType>(ExceptionType value) {
1237: 	return StringUtil::EnumToString(GetExceptionTypeValues(), 43, "ExceptionType", static_cast<uint32_t>(value));
1238: }
1239: 
1240: template<>
1241: ExceptionType EnumUtil::FromString<ExceptionType>(const char *value) {
1242: 	return static_cast<ExceptionType>(StringUtil::StringToEnum(GetExceptionTypeValues(), 43, "ExceptionType", value));
1243: }
1244: 
1245: const StringUtil::EnumStringLiteral *GetExplainFormatValues() {
1246: 	static constexpr StringUtil::EnumStringLiteral values[] {
1247: 		{ static_cast<uint32_t>(ExplainFormat::DEFAULT), "DEFAULT" },
1248: 		{ static_cast<uint32_t>(ExplainFormat::TEXT), "TEXT" },
1249: 		{ static_cast<uint32_t>(ExplainFormat::JSON), "JSON" },
1250: 		{ static_cast<uint32_t>(ExplainFormat::HTML), "HTML" },
1251: 		{ static_cast<uint32_t>(ExplainFormat::GRAPHVIZ), "GRAPHVIZ" }
1252: 	};
1253: 	return values;
1254: }
1255: 
1256: template<>
1257: const char* EnumUtil::ToChars<ExplainFormat>(ExplainFormat value) {
1258: 	return StringUtil::EnumToString(GetExplainFormatValues(), 5, "ExplainFormat", static_cast<uint32_t>(value));
1259: }
1260: 
1261: template<>
1262: ExplainFormat EnumUtil::FromString<ExplainFormat>(const char *value) {
1263: 	return static_cast<ExplainFormat>(StringUtil::StringToEnum(GetExplainFormatValues(), 5, "ExplainFormat", value));
1264: }
1265: 
1266: const StringUtil::EnumStringLiteral *GetExplainOutputTypeValues() {
1267: 	static constexpr StringUtil::EnumStringLiteral values[] {
1268: 		{ static_cast<uint32_t>(ExplainOutputType::ALL), "ALL" },
1269: 		{ static_cast<uint32_t>(ExplainOutputType::OPTIMIZED_ONLY), "OPTIMIZED_ONLY" },
1270: 		{ static_cast<uint32_t>(ExplainOutputType::PHYSICAL_ONLY), "PHYSICAL_ONLY" }
1271: 	};
1272: 	return values;
1273: }
1274: 
1275: template<>
1276: const char* EnumUtil::ToChars<ExplainOutputType>(ExplainOutputType value) {
1277: 	return StringUtil::EnumToString(GetExplainOutputTypeValues(), 3, "ExplainOutputType", static_cast<uint32_t>(value));
1278: }
1279: 
1280: template<>
1281: ExplainOutputType EnumUtil::FromString<ExplainOutputType>(const char *value) {
1282: 	return static_cast<ExplainOutputType>(StringUtil::StringToEnum(GetExplainOutputTypeValues(), 3, "ExplainOutputType", value));
1283: }
1284: 
1285: const StringUtil::EnumStringLiteral *GetExplainTypeValues() {
1286: 	static constexpr StringUtil::EnumStringLiteral values[] {
1287: 		{ static_cast<uint32_t>(ExplainType::EXPLAIN_STANDARD), "EXPLAIN_STANDARD" },
1288: 		{ static_cast<uint32_t>(ExplainType::EXPLAIN_ANALYZE), "EXPLAIN_ANALYZE" }
1289: 	};
1290: 	return values;
1291: }
1292: 
1293: template<>
1294: const char* EnumUtil::ToChars<ExplainType>(ExplainType value) {
1295: 	return StringUtil::EnumToString(GetExplainTypeValues(), 2, "ExplainType", static_cast<uint32_t>(value));
1296: }
1297: 
1298: template<>
1299: ExplainType EnumUtil::FromString<ExplainType>(const char *value) {
1300: 	return static_cast<ExplainType>(StringUtil::StringToEnum(GetExplainTypeValues(), 2, "ExplainType", value));
1301: }
1302: 
1303: const StringUtil::EnumStringLiteral *GetExponentTypeValues() {
1304: 	static constexpr StringUtil::EnumStringLiteral values[] {
1305: 		{ static_cast<uint32_t>(ExponentType::NONE), "NONE" },
1306: 		{ static_cast<uint32_t>(ExponentType::POSITIVE), "POSITIVE" },
1307: 		{ static_cast<uint32_t>(ExponentType::NEGATIVE), "NEGATIVE" }
1308: 	};
1309: 	return values;
1310: }
1311: 
1312: template<>
1313: const char* EnumUtil::ToChars<ExponentType>(ExponentType value) {
1314: 	return StringUtil::EnumToString(GetExponentTypeValues(), 3, "ExponentType", static_cast<uint32_t>(value));
1315: }
1316: 
1317: template<>
1318: ExponentType EnumUtil::FromString<ExponentType>(const char *value) {
1319: 	return static_cast<ExponentType>(StringUtil::StringToEnum(GetExponentTypeValues(), 3, "ExponentType", value));
1320: }
1321: 
1322: const StringUtil::EnumStringLiteral *GetExpressionClassValues() {
1323: 	static constexpr StringUtil::EnumStringLiteral values[] {
1324: 		{ static_cast<uint32_t>(ExpressionClass::INVALID), "INVALID" },
1325: 		{ static_cast<uint32_t>(ExpressionClass::AGGREGATE), "AGGREGATE" },
1326: 		{ static_cast<uint32_t>(ExpressionClass::CASE), "CASE" },
1327: 		{ static_cast<uint32_t>(ExpressionClass::CAST), "CAST" },
1328: 		{ static_cast<uint32_t>(ExpressionClass::COLUMN_REF), "COLUMN_REF" },
1329: 		{ static_cast<uint32_t>(ExpressionClass::COMPARISON), "COMPARISON" },
1330: 		{ static_cast<uint32_t>(ExpressionClass::CONJUNCTION), "CONJUNCTION" },
1331: 		{ static_cast<uint32_t>(ExpressionClass::CONSTANT), "CONSTANT" },
1332: 		{ static_cast<uint32_t>(ExpressionClass::DEFAULT), "DEFAULT" },
1333: 		{ static_cast<uint32_t>(ExpressionClass::FUNCTION), "FUNCTION" },
1334: 		{ static_cast<uint32_t>(ExpressionClass::OPERATOR), "OPERATOR" },
1335: 		{ static_cast<uint32_t>(ExpressionClass::STAR), "STAR" },
1336: 		{ static_cast<uint32_t>(ExpressionClass::SUBQUERY), "SUBQUERY" },
1337: 		{ static_cast<uint32_t>(ExpressionClass::WINDOW), "WINDOW" },
1338: 		{ static_cast<uint32_t>(ExpressionClass::PARAMETER), "PARAMETER" },
1339: 		{ static_cast<uint32_t>(ExpressionClass::COLLATE), "COLLATE" },
1340: 		{ static_cast<uint32_t>(ExpressionClass::LAMBDA), "LAMBDA" },
1341: 		{ static_cast<uint32_t>(ExpressionClass::POSITIONAL_REFERENCE), "POSITIONAL_REFERENCE" },
1342: 		{ static_cast<uint32_t>(ExpressionClass::BETWEEN), "BETWEEN" },
1343: 		{ static_cast<uint32_t>(ExpressionClass::LAMBDA_REF), "LAMBDA_REF" },
1344: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_AGGREGATE), "BOUND_AGGREGATE" },
1345: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_CASE), "BOUND_CASE" },
1346: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_CAST), "BOUND_CAST" },
1347: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_COLUMN_REF), "BOUND_COLUMN_REF" },
1348: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_COMPARISON), "BOUND_COMPARISON" },
1349: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_CONJUNCTION), "BOUND_CONJUNCTION" },
1350: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_CONSTANT), "BOUND_CONSTANT" },
1351: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_DEFAULT), "BOUND_DEFAULT" },
1352: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_FUNCTION), "BOUND_FUNCTION" },
1353: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_OPERATOR), "BOUND_OPERATOR" },
1354: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_PARAMETER), "BOUND_PARAMETER" },
1355: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_REF), "BOUND_REF" },
1356: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_SUBQUERY), "BOUND_SUBQUERY" },
1357: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_WINDOW), "BOUND_WINDOW" },
1358: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_BETWEEN), "BOUND_BETWEEN" },
1359: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_UNNEST), "BOUND_UNNEST" },
1360: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_LAMBDA), "BOUND_LAMBDA" },
1361: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_LAMBDA_REF), "BOUND_LAMBDA_REF" },
1362: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_EXPRESSION), "BOUND_EXPRESSION" },
1363: 		{ static_cast<uint32_t>(ExpressionClass::BOUND_EXPANDED), "BOUND_EXPANDED" }
1364: 	};
1365: 	return values;
1366: }
1367: 
1368: template<>
1369: const char* EnumUtil::ToChars<ExpressionClass>(ExpressionClass value) {
1370: 	return StringUtil::EnumToString(GetExpressionClassValues(), 40, "ExpressionClass", static_cast<uint32_t>(value));
1371: }
1372: 
1373: template<>
1374: ExpressionClass EnumUtil::FromString<ExpressionClass>(const char *value) {
1375: 	return static_cast<ExpressionClass>(StringUtil::StringToEnum(GetExpressionClassValues(), 40, "ExpressionClass", value));
1376: }
1377: 
1378: const StringUtil::EnumStringLiteral *GetExpressionTypeValues() {
1379: 	static constexpr StringUtil::EnumStringLiteral values[] {
1380: 		{ static_cast<uint32_t>(ExpressionType::INVALID), "INVALID" },
1381: 		{ static_cast<uint32_t>(ExpressionType::OPERATOR_CAST), "OPERATOR_CAST" },
1382: 		{ static_cast<uint32_t>(ExpressionType::OPERATOR_NOT), "OPERATOR_NOT" },
1383: 		{ static_cast<uint32_t>(ExpressionType::OPERATOR_IS_NULL), "OPERATOR_IS_NULL" },
1384: 		{ static_cast<uint32_t>(ExpressionType::OPERATOR_IS_NOT_NULL), "OPERATOR_IS_NOT_NULL" },
1385: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_EQUAL), "COMPARE_EQUAL" },
1386: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_NOTEQUAL), "COMPARE_NOTEQUAL" },
1387: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_LESSTHAN), "COMPARE_LESSTHAN" },
1388: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_GREATERTHAN), "COMPARE_GREATERTHAN" },
1389: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_LESSTHANOREQUALTO), "COMPARE_LESSTHANOREQUALTO" },
1390: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_GREATERTHANOREQUALTO), "COMPARE_GREATERTHANOREQUALTO" },
1391: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_IN), "COMPARE_IN" },
1392: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_NOT_IN), "COMPARE_NOT_IN" },
1393: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_DISTINCT_FROM), "COMPARE_DISTINCT_FROM" },
1394: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_BETWEEN), "COMPARE_BETWEEN" },
1395: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_NOT_BETWEEN), "COMPARE_NOT_BETWEEN" },
1396: 		{ static_cast<uint32_t>(ExpressionType::COMPARE_NOT_DISTINCT_FROM), "COMPARE_NOT_DISTINCT_FROM" },
1397: 		{ static_cast<uint32_t>(ExpressionType::CONJUNCTION_AND), "CONJUNCTION_AND" },
1398: 		{ static_cast<uint32_t>(ExpressionType::CONJUNCTION_OR), "CONJUNCTION_OR" },
1399: 		{ static_cast<uint32_t>(ExpressionType::VALUE_CONSTANT), "VALUE_CONSTANT" },
1400: 		{ static_cast<uint32_t>(ExpressionType::VALUE_PARAMETER), "VALUE_PARAMETER" },
1401: 		{ static_cast<uint32_t>(ExpressionType::VALUE_TUPLE), "VALUE_TUPLE" },
1402: 		{ static_cast<uint32_t>(ExpressionType::VALUE_TUPLE_ADDRESS), "VALUE_TUPLE_ADDRESS" },
1403: 		{ static_cast<uint32_t>(ExpressionType::VALUE_NULL), "VALUE_NULL" },
1404: 		{ static_cast<uint32_t>(ExpressionType::VALUE_VECTOR), "VALUE_VECTOR" },
1405: 		{ static_cast<uint32_t>(ExpressionType::VALUE_SCALAR), "VALUE_SCALAR" },
1406: 		{ static_cast<uint32_t>(ExpressionType::VALUE_DEFAULT), "VALUE_DEFAULT" },
1407: 		{ static_cast<uint32_t>(ExpressionType::AGGREGATE), "AGGREGATE" },
1408: 		{ static_cast<uint32_t>(ExpressionType::BOUND_AGGREGATE), "BOUND_AGGREGATE" },
1409: 		{ static_cast<uint32_t>(ExpressionType::GROUPING_FUNCTION), "GROUPING_FUNCTION" },
1410: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_AGGREGATE), "WINDOW_AGGREGATE" },
1411: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_RANK), "WINDOW_RANK" },
1412: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_RANK_DENSE), "WINDOW_RANK_DENSE" },
1413: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_NTILE), "WINDOW_NTILE" },
1414: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_PERCENT_RANK), "WINDOW_PERCENT_RANK" },
1415: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_CUME_DIST), "WINDOW_CUME_DIST" },
1416: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_ROW_NUMBER), "WINDOW_ROW_NUMBER" },
1417: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_FIRST_VALUE), "WINDOW_FIRST_VALUE" },
1418: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_LAST_VALUE), "WINDOW_LAST_VALUE" },
1419: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_LEAD), "WINDOW_LEAD" },
1420: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_LAG), "WINDOW_LAG" },
1421: 		{ static_cast<uint32_t>(ExpressionType::WINDOW_NTH_VALUE), "WINDOW_NTH_VALUE" },
1422: 		{ static_cast<uint32_t>(ExpressionType::FUNCTION), "FUNCTION" },
1423: 		{ static_cast<uint32_t>(ExpressionType::BOUND_FUNCTION), "BOUND_FUNCTION" },
1424: 		{ static_cast<uint32_t>(ExpressionType::CASE_EXPR), "CASE_EXPR" },
1425: 		{ static_cast<uint32_t>(ExpressionType::OPERATOR_NULLIF), "OPERATOR_NULLIF" },
1426: 		{ static_cast<uint32_t>(ExpressionType::OPERATOR_COALESCE), "OPERATOR_COALESCE" },
1427: 		{ static_cast<uint32_t>(ExpressionType::ARRAY_EXTRACT), "ARRAY_EXTRACT" },
1428: 		{ static_cast<uint32_t>(ExpressionType::ARRAY_SLICE), "ARRAY_SLICE" },
1429: 		{ static_cast<uint32_t>(ExpressionType::STRUCT_EXTRACT), "STRUCT_EXTRACT" },
1430: 		{ static_cast<uint32_t>(ExpressionType::ARRAY_CONSTRUCTOR), "ARRAY_CONSTRUCTOR" },
1431: 		{ static_cast<uint32_t>(ExpressionType::ARROW), "ARROW" },
1432: 		{ static_cast<uint32_t>(ExpressionType::SUBQUERY), "SUBQUERY" },
1433: 		{ static_cast<uint32_t>(ExpressionType::STAR), "STAR" },
1434: 		{ static_cast<uint32_t>(ExpressionType::TABLE_STAR), "TABLE_STAR" },
1435: 		{ static_cast<uint32_t>(ExpressionType::PLACEHOLDER), "PLACEHOLDER" },
1436: 		{ static_cast<uint32_t>(ExpressionType::COLUMN_REF), "COLUMN_REF" },
1437: 		{ static_cast<uint32_t>(ExpressionType::FUNCTION_REF), "FUNCTION_REF" },
1438: 		{ static_cast<uint32_t>(ExpressionType::TABLE_REF), "TABLE_REF" },
1439: 		{ static_cast<uint32_t>(ExpressionType::LAMBDA_REF), "LAMBDA_REF" },
1440: 		{ static_cast<uint32_t>(ExpressionType::CAST), "CAST" },
1441: 		{ static_cast<uint32_t>(ExpressionType::BOUND_REF), "BOUND_REF" },
1442: 		{ static_cast<uint32_t>(ExpressionType::BOUND_COLUMN_REF), "BOUND_COLUMN_REF" },
1443: 		{ static_cast<uint32_t>(ExpressionType::BOUND_UNNEST), "BOUND_UNNEST" },
1444: 		{ static_cast<uint32_t>(ExpressionType::COLLATE), "COLLATE" },
1445: 		{ static_cast<uint32_t>(ExpressionType::LAMBDA), "LAMBDA" },
1446: 		{ static_cast<uint32_t>(ExpressionType::POSITIONAL_REFERENCE), "POSITIONAL_REFERENCE" },
1447: 		{ static_cast<uint32_t>(ExpressionType::BOUND_LAMBDA_REF), "BOUND_LAMBDA_REF" },
1448: 		{ static_cast<uint32_t>(ExpressionType::BOUND_EXPANDED), "BOUND_EXPANDED" }
1449: 	};
1450: 	return values;
1451: }
1452: 
1453: template<>
1454: const char* EnumUtil::ToChars<ExpressionType>(ExpressionType value) {
1455: 	return StringUtil::EnumToString(GetExpressionTypeValues(), 69, "ExpressionType", static_cast<uint32_t>(value));
1456: }
1457: 
1458: template<>
1459: ExpressionType EnumUtil::FromString<ExpressionType>(const char *value) {
1460: 	return static_cast<ExpressionType>(StringUtil::StringToEnum(GetExpressionTypeValues(), 69, "ExpressionType", value));
1461: }
1462: 
1463: const StringUtil::EnumStringLiteral *GetExtensionABITypeValues() {
1464: 	static constexpr StringUtil::EnumStringLiteral values[] {
1465: 		{ static_cast<uint32_t>(ExtensionABIType::UNKNOWN), "UNKNOWN" },
1466: 		{ static_cast<uint32_t>(ExtensionABIType::CPP), "CPP" },
1467: 		{ static_cast<uint32_t>(ExtensionABIType::C_STRUCT), "C_STRUCT" }
1468: 	};
1469: 	return values;
1470: }
1471: 
1472: template<>
1473: const char* EnumUtil::ToChars<ExtensionABIType>(ExtensionABIType value) {
1474: 	return StringUtil::EnumToString(GetExtensionABITypeValues(), 3, "ExtensionABIType", static_cast<uint32_t>(value));
1475: }
1476: 
1477: template<>
1478: ExtensionABIType EnumUtil::FromString<ExtensionABIType>(const char *value) {
1479: 	return static_cast<ExtensionABIType>(StringUtil::StringToEnum(GetExtensionABITypeValues(), 3, "ExtensionABIType", value));
1480: }
1481: 
1482: const StringUtil::EnumStringLiteral *GetExtensionInstallModeValues() {
1483: 	static constexpr StringUtil::EnumStringLiteral values[] {
1484: 		{ static_cast<uint32_t>(ExtensionInstallMode::UNKNOWN), "UNKNOWN" },
1485: 		{ static_cast<uint32_t>(ExtensionInstallMode::REPOSITORY), "REPOSITORY" },
1486: 		{ static_cast<uint32_t>(ExtensionInstallMode::CUSTOM_PATH), "CUSTOM_PATH" },
1487: 		{ static_cast<uint32_t>(ExtensionInstallMode::STATICALLY_LINKED), "STATICALLY_LINKED" },
1488: 		{ static_cast<uint32_t>(ExtensionInstallMode::NOT_INSTALLED), "NOT_INSTALLED" }
1489: 	};
1490: 	return values;
1491: }
1492: 
1493: template<>
1494: const char* EnumUtil::ToChars<ExtensionInstallMode>(ExtensionInstallMode value) {
1495: 	return StringUtil::EnumToString(GetExtensionInstallModeValues(), 5, "ExtensionInstallMode", static_cast<uint32_t>(value));
1496: }
1497: 
1498: template<>
1499: ExtensionInstallMode EnumUtil::FromString<ExtensionInstallMode>(const char *value) {
1500: 	return static_cast<ExtensionInstallMode>(StringUtil::StringToEnum(GetExtensionInstallModeValues(), 5, "ExtensionInstallMode", value));
1501: }
1502: 
1503: const StringUtil::EnumStringLiteral *GetExtensionLoadResultValues() {
1504: 	static constexpr StringUtil::EnumStringLiteral values[] {
1505: 		{ static_cast<uint32_t>(ExtensionLoadResult::LOADED_EXTENSION), "LOADED_EXTENSION" },
1506: 		{ static_cast<uint32_t>(ExtensionLoadResult::EXTENSION_UNKNOWN), "EXTENSION_UNKNOWN" },
1507: 		{ static_cast<uint32_t>(ExtensionLoadResult::NOT_LOADED), "NOT_LOADED" }
1508: 	};
1509: 	return values;
1510: }
1511: 
1512: template<>
1513: const char* EnumUtil::ToChars<ExtensionLoadResult>(ExtensionLoadResult value) {
1514: 	return StringUtil::EnumToString(GetExtensionLoadResultValues(), 3, "ExtensionLoadResult", static_cast<uint32_t>(value));
1515: }
1516: 
1517: template<>
1518: ExtensionLoadResult EnumUtil::FromString<ExtensionLoadResult>(const char *value) {
1519: 	return static_cast<ExtensionLoadResult>(StringUtil::StringToEnum(GetExtensionLoadResultValues(), 3, "ExtensionLoadResult", value));
1520: }
1521: 
1522: const StringUtil::EnumStringLiteral *GetExtensionUpdateResultTagValues() {
1523: 	static constexpr StringUtil::EnumStringLiteral values[] {
1524: 		{ static_cast<uint32_t>(ExtensionUpdateResultTag::UNKNOWN), "UNKNOWN" },
1525: 		{ static_cast<uint32_t>(ExtensionUpdateResultTag::NO_UPDATE_AVAILABLE), "NO_UPDATE_AVAILABLE" },
1526: 		{ static_cast<uint32_t>(ExtensionUpdateResultTag::NOT_A_REPOSITORY), "NOT_A_REPOSITORY" },
1527: 		{ static_cast<uint32_t>(ExtensionUpdateResultTag::NOT_INSTALLED), "NOT_INSTALLED" },
1528: 		{ static_cast<uint32_t>(ExtensionUpdateResultTag::STATICALLY_LOADED), "STATICALLY_LOADED" },
1529: 		{ static_cast<uint32_t>(ExtensionUpdateResultTag::MISSING_INSTALL_INFO), "MISSING_INSTALL_INFO" },
1530: 		{ static_cast<uint32_t>(ExtensionUpdateResultTag::REDOWNLOADED), "REDOWNLOADED" },
1531: 		{ static_cast<uint32_t>(ExtensionUpdateResultTag::UPDATED), "UPDATED" }
1532: 	};
1533: 	return values;
1534: }
1535: 
1536: template<>
1537: const char* EnumUtil::ToChars<ExtensionUpdateResultTag>(ExtensionUpdateResultTag value) {
1538: 	return StringUtil::EnumToString(GetExtensionUpdateResultTagValues(), 8, "ExtensionUpdateResultTag", static_cast<uint32_t>(value));
1539: }
1540: 
1541: template<>
1542: ExtensionUpdateResultTag EnumUtil::FromString<ExtensionUpdateResultTag>(const char *value) {
1543: 	return static_cast<ExtensionUpdateResultTag>(StringUtil::StringToEnum(GetExtensionUpdateResultTagValues(), 8, "ExtensionUpdateResultTag", value));
1544: }
1545: 
1546: const StringUtil::EnumStringLiteral *GetExtraDropInfoTypeValues() {
1547: 	static constexpr StringUtil::EnumStringLiteral values[] {
1548: 		{ static_cast<uint32_t>(ExtraDropInfoType::INVALID), "INVALID" },
1549: 		{ static_cast<uint32_t>(ExtraDropInfoType::SECRET_INFO), "SECRET_INFO" }
1550: 	};
1551: 	return values;
1552: }
1553: 
1554: template<>
1555: const char* EnumUtil::ToChars<ExtraDropInfoType>(ExtraDropInfoType value) {
1556: 	return StringUtil::EnumToString(GetExtraDropInfoTypeValues(), 2, "ExtraDropInfoType", static_cast<uint32_t>(value));
1557: }
1558: 
1559: template<>
1560: ExtraDropInfoType EnumUtil::FromString<ExtraDropInfoType>(const char *value) {
1561: 	return static_cast<ExtraDropInfoType>(StringUtil::StringToEnum(GetExtraDropInfoTypeValues(), 2, "ExtraDropInfoType", value));
1562: }
1563: 
1564: const StringUtil::EnumStringLiteral *GetExtraTypeInfoTypeValues() {
1565: 	static constexpr StringUtil::EnumStringLiteral values[] {
1566: 		{ static_cast<uint32_t>(ExtraTypeInfoType::INVALID_TYPE_INFO), "INVALID_TYPE_INFO" },
1567: 		{ static_cast<uint32_t>(ExtraTypeInfoType::GENERIC_TYPE_INFO), "GENERIC_TYPE_INFO" },
1568: 		{ static_cast<uint32_t>(ExtraTypeInfoType::DECIMAL_TYPE_INFO), "DECIMAL_TYPE_INFO" },
1569: 		{ static_cast<uint32_t>(ExtraTypeInfoType::STRING_TYPE_INFO), "STRING_TYPE_INFO" },
1570: 		{ static_cast<uint32_t>(ExtraTypeInfoType::LIST_TYPE_INFO), "LIST_TYPE_INFO" },
1571: 		{ static_cast<uint32_t>(ExtraTypeInfoType::STRUCT_TYPE_INFO), "STRUCT_TYPE_INFO" },
1572: 		{ static_cast<uint32_t>(ExtraTypeInfoType::ENUM_TYPE_INFO), "ENUM_TYPE_INFO" },
1573: 		{ static_cast<uint32_t>(ExtraTypeInfoType::USER_TYPE_INFO), "USER_TYPE_INFO" },
1574: 		{ static_cast<uint32_t>(ExtraTypeInfoType::AGGREGATE_STATE_TYPE_INFO), "AGGREGATE_STATE_TYPE_INFO" },
1575: 		{ static_cast<uint32_t>(ExtraTypeInfoType::ARRAY_TYPE_INFO), "ARRAY_TYPE_INFO" },
1576: 		{ static_cast<uint32_t>(ExtraTypeInfoType::ANY_TYPE_INFO), "ANY_TYPE_INFO" },
1577: 		{ static_cast<uint32_t>(ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO), "INTEGER_LITERAL_TYPE_INFO" }
1578: 	};
1579: 	return values;
1580: }
1581: 
1582: template<>
1583: const char* EnumUtil::ToChars<ExtraTypeInfoType>(ExtraTypeInfoType value) {
1584: 	return StringUtil::EnumToString(GetExtraTypeInfoTypeValues(), 12, "ExtraTypeInfoType", static_cast<uint32_t>(value));
1585: }
1586: 
1587: template<>
1588: ExtraTypeInfoType EnumUtil::FromString<ExtraTypeInfoType>(const char *value) {
1589: 	return static_cast<ExtraTypeInfoType>(StringUtil::StringToEnum(GetExtraTypeInfoTypeValues(), 12, "ExtraTypeInfoType", value));
1590: }
1591: 
1592: const StringUtil::EnumStringLiteral *GetFileBufferTypeValues() {
1593: 	static constexpr StringUtil::EnumStringLiteral values[] {
1594: 		{ static_cast<uint32_t>(FileBufferType::BLOCK), "BLOCK" },
1595: 		{ static_cast<uint32_t>(FileBufferType::MANAGED_BUFFER), "MANAGED_BUFFER" },
1596: 		{ static_cast<uint32_t>(FileBufferType::TINY_BUFFER), "TINY_BUFFER" }
1597: 	};
1598: 	return values;
1599: }
1600: 
1601: template<>
1602: const char* EnumUtil::ToChars<FileBufferType>(FileBufferType value) {
1603: 	return StringUtil::EnumToString(GetFileBufferTypeValues(), 3, "FileBufferType", static_cast<uint32_t>(value));
1604: }
1605: 
1606: template<>
1607: FileBufferType EnumUtil::FromString<FileBufferType>(const char *value) {
1608: 	return static_cast<FileBufferType>(StringUtil::StringToEnum(GetFileBufferTypeValues(), 3, "FileBufferType", value));
1609: }
1610: 
1611: const StringUtil::EnumStringLiteral *GetFileCompressionTypeValues() {
1612: 	static constexpr StringUtil::EnumStringLiteral values[] {
1613: 		{ static_cast<uint32_t>(FileCompressionType::AUTO_DETECT), "AUTO_DETECT" },
1614: 		{ static_cast<uint32_t>(FileCompressionType::UNCOMPRESSED), "UNCOMPRESSED" },
1615: 		{ static_cast<uint32_t>(FileCompressionType::GZIP), "GZIP" },
1616: 		{ static_cast<uint32_t>(FileCompressionType::ZSTD), "ZSTD" }
1617: 	};
1618: 	return values;
1619: }
1620: 
1621: template<>
1622: const char* EnumUtil::ToChars<FileCompressionType>(FileCompressionType value) {
1623: 	return StringUtil::EnumToString(GetFileCompressionTypeValues(), 4, "FileCompressionType", static_cast<uint32_t>(value));
1624: }
1625: 
1626: template<>
1627: FileCompressionType EnumUtil::FromString<FileCompressionType>(const char *value) {
1628: 	return static_cast<FileCompressionType>(StringUtil::StringToEnum(GetFileCompressionTypeValues(), 4, "FileCompressionType", value));
1629: }
1630: 
1631: const StringUtil::EnumStringLiteral *GetFileExpandResultValues() {
1632: 	static constexpr StringUtil::EnumStringLiteral values[] {
1633: 		{ static_cast<uint32_t>(FileExpandResult::NO_FILES), "NO_FILES" },
1634: 		{ static_cast<uint32_t>(FileExpandResult::SINGLE_FILE), "SINGLE_FILE" },
1635: 		{ static_cast<uint32_t>(FileExpandResult::MULTIPLE_FILES), "MULTIPLE_FILES" }
1636: 	};
1637: 	return values;
1638: }
1639: 
1640: template<>
1641: const char* EnumUtil::ToChars<FileExpandResult>(FileExpandResult value) {
1642: 	return StringUtil::EnumToString(GetFileExpandResultValues(), 3, "FileExpandResult", static_cast<uint32_t>(value));
1643: }
1644: 
1645: template<>
1646: FileExpandResult EnumUtil::FromString<FileExpandResult>(const char *value) {
1647: 	return static_cast<FileExpandResult>(StringUtil::StringToEnum(GetFileExpandResultValues(), 3, "FileExpandResult", value));
1648: }
1649: 
1650: const StringUtil::EnumStringLiteral *GetFileGlobOptionsValues() {
1651: 	static constexpr StringUtil::EnumStringLiteral values[] {
1652: 		{ static_cast<uint32_t>(FileGlobOptions::DISALLOW_EMPTY), "DISALLOW_EMPTY" },
1653: 		{ static_cast<uint32_t>(FileGlobOptions::ALLOW_EMPTY), "ALLOW_EMPTY" }
1654: 	};
1655: 	return values;
1656: }
1657: 
1658: template<>
1659: const char* EnumUtil::ToChars<FileGlobOptions>(FileGlobOptions value) {
1660: 	return StringUtil::EnumToString(GetFileGlobOptionsValues(), 2, "FileGlobOptions", static_cast<uint32_t>(value));
1661: }
1662: 
1663: template<>
1664: FileGlobOptions EnumUtil::FromString<FileGlobOptions>(const char *value) {
1665: 	return static_cast<FileGlobOptions>(StringUtil::StringToEnum(GetFileGlobOptionsValues(), 2, "FileGlobOptions", value));
1666: }
1667: 
1668: const StringUtil::EnumStringLiteral *GetFileLockTypeValues() {
1669: 	static constexpr StringUtil::EnumStringLiteral values[] {
1670: 		{ static_cast<uint32_t>(FileLockType::NO_LOCK), "NO_LOCK" },
1671: 		{ static_cast<uint32_t>(FileLockType::READ_LOCK), "READ_LOCK" },
1672: 		{ static_cast<uint32_t>(FileLockType::WRITE_LOCK), "WRITE_LOCK" }
1673: 	};
1674: 	return values;
1675: }
1676: 
1677: template<>
1678: const char* EnumUtil::ToChars<FileLockType>(FileLockType value) {
1679: 	return StringUtil::EnumToString(GetFileLockTypeValues(), 3, "FileLockType", static_cast<uint32_t>(value));
1680: }
1681: 
1682: template<>
1683: FileLockType EnumUtil::FromString<FileLockType>(const char *value) {
1684: 	return static_cast<FileLockType>(StringUtil::StringToEnum(GetFileLockTypeValues(), 3, "FileLockType", value));
1685: }
1686: 
1687: const StringUtil::EnumStringLiteral *GetFilterPropagateResultValues() {
1688: 	static constexpr StringUtil::EnumStringLiteral values[] {
1689: 		{ static_cast<uint32_t>(FilterPropagateResult::NO_PRUNING_POSSIBLE), "NO_PRUNING_POSSIBLE" },
1690: 		{ static_cast<uint32_t>(FilterPropagateResult::FILTER_ALWAYS_TRUE), "FILTER_ALWAYS_TRUE" },
1691: 		{ static_cast<uint32_t>(FilterPropagateResult::FILTER_ALWAYS_FALSE), "FILTER_ALWAYS_FALSE" },
1692: 		{ static_cast<uint32_t>(FilterPropagateResult::FILTER_TRUE_OR_NULL), "FILTER_TRUE_OR_NULL" },
1693: 		{ static_cast<uint32_t>(FilterPropagateResult::FILTER_FALSE_OR_NULL), "FILTER_FALSE_OR_NULL" }
1694: 	};
1695: 	return values;
1696: }
1697: 
1698: template<>
1699: const char* EnumUtil::ToChars<FilterPropagateResult>(FilterPropagateResult value) {
1700: 	return StringUtil::EnumToString(GetFilterPropagateResultValues(), 5, "FilterPropagateResult", static_cast<uint32_t>(value));
1701: }
1702: 
1703: template<>
1704: FilterPropagateResult EnumUtil::FromString<FilterPropagateResult>(const char *value) {
1705: 	return static_cast<FilterPropagateResult>(StringUtil::StringToEnum(GetFilterPropagateResultValues(), 5, "FilterPropagateResult", value));
1706: }
1707: 
1708: const StringUtil::EnumStringLiteral *GetForeignKeyTypeValues() {
1709: 	static constexpr StringUtil::EnumStringLiteral values[] {
1710: 		{ static_cast<uint32_t>(ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE), "FK_TYPE_PRIMARY_KEY_TABLE" },
1711: 		{ static_cast<uint32_t>(ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE), "FK_TYPE_FOREIGN_KEY_TABLE" },
1712: 		{ static_cast<uint32_t>(ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE), "FK_TYPE_SELF_REFERENCE_TABLE" }
1713: 	};
1714: 	return values;
1715: }
1716: 
1717: template<>
1718: const char* EnumUtil::ToChars<ForeignKeyType>(ForeignKeyType value) {
1719: 	return StringUtil::EnumToString(GetForeignKeyTypeValues(), 3, "ForeignKeyType", static_cast<uint32_t>(value));
1720: }
1721: 
1722: template<>
1723: ForeignKeyType EnumUtil::FromString<ForeignKeyType>(const char *value) {
1724: 	return static_cast<ForeignKeyType>(StringUtil::StringToEnum(GetForeignKeyTypeValues(), 3, "ForeignKeyType", value));
1725: }
1726: 
1727: const StringUtil::EnumStringLiteral *GetFunctionCollationHandlingValues() {
1728: 	static constexpr StringUtil::EnumStringLiteral values[] {
1729: 		{ static_cast<uint32_t>(FunctionCollationHandling::PROPAGATE_COLLATIONS), "PROPAGATE_COLLATIONS" },
1730: 		{ static_cast<uint32_t>(FunctionCollationHandling::PUSH_COMBINABLE_COLLATIONS), "PUSH_COMBINABLE_COLLATIONS" },
1731: 		{ static_cast<uint32_t>(FunctionCollationHandling::IGNORE_COLLATIONS), "IGNORE_COLLATIONS" }
1732: 	};
1733: 	return values;
1734: }
1735: 
1736: template<>
1737: const char* EnumUtil::ToChars<FunctionCollationHandling>(FunctionCollationHandling value) {
1738: 	return StringUtil::EnumToString(GetFunctionCollationHandlingValues(), 3, "FunctionCollationHandling", static_cast<uint32_t>(value));
1739: }
1740: 
1741: template<>
1742: FunctionCollationHandling EnumUtil::FromString<FunctionCollationHandling>(const char *value) {
1743: 	return static_cast<FunctionCollationHandling>(StringUtil::StringToEnum(GetFunctionCollationHandlingValues(), 3, "FunctionCollationHandling", value));
1744: }
1745: 
1746: const StringUtil::EnumStringLiteral *GetFunctionErrorsValues() {
1747: 	static constexpr StringUtil::EnumStringLiteral values[] {
1748: 		{ static_cast<uint32_t>(FunctionErrors::CANNOT_ERROR), "CANNOT_ERROR" },
1749: 		{ static_cast<uint32_t>(FunctionErrors::CAN_THROW_ERROR), "CAN_THROW_ERROR" }
1750: 	};
1751: 	return values;
1752: }
1753: 
1754: template<>
1755: const char* EnumUtil::ToChars<FunctionErrors>(FunctionErrors value) {
1756: 	return StringUtil::EnumToString(GetFunctionErrorsValues(), 2, "FunctionErrors", static_cast<uint32_t>(value));
1757: }
1758: 
1759: template<>
1760: FunctionErrors EnumUtil::FromString<FunctionErrors>(const char *value) {
1761: 	return static_cast<FunctionErrors>(StringUtil::StringToEnum(GetFunctionErrorsValues(), 2, "FunctionErrors", value));
1762: }
1763: 
1764: const StringUtil::EnumStringLiteral *GetFunctionNullHandlingValues() {
1765: 	static constexpr StringUtil::EnumStringLiteral values[] {
1766: 		{ static_cast<uint32_t>(FunctionNullHandling::DEFAULT_NULL_HANDLING), "DEFAULT_NULL_HANDLING" },
1767: 		{ static_cast<uint32_t>(FunctionNullHandling::SPECIAL_HANDLING), "SPECIAL_HANDLING" }
1768: 	};
1769: 	return values;
1770: }
1771: 
1772: template<>
1773: const char* EnumUtil::ToChars<FunctionNullHandling>(FunctionNullHandling value) {
1774: 	return StringUtil::EnumToString(GetFunctionNullHandlingValues(), 2, "FunctionNullHandling", static_cast<uint32_t>(value));
1775: }
1776: 
1777: template<>
1778: FunctionNullHandling EnumUtil::FromString<FunctionNullHandling>(const char *value) {
1779: 	return static_cast<FunctionNullHandling>(StringUtil::StringToEnum(GetFunctionNullHandlingValues(), 2, "FunctionNullHandling", value));
1780: }
1781: 
1782: const StringUtil::EnumStringLiteral *GetFunctionStabilityValues() {
1783: 	static constexpr StringUtil::EnumStringLiteral values[] {
1784: 		{ static_cast<uint32_t>(FunctionStability::CONSISTENT), "CONSISTENT" },
1785: 		{ static_cast<uint32_t>(FunctionStability::VOLATILE), "VOLATILE" },
1786: 		{ static_cast<uint32_t>(FunctionStability::CONSISTENT_WITHIN_QUERY), "CONSISTENT_WITHIN_QUERY" }
1787: 	};
1788: 	return values;
1789: }
1790: 
1791: template<>
1792: const char* EnumUtil::ToChars<FunctionStability>(FunctionStability value) {
1793: 	return StringUtil::EnumToString(GetFunctionStabilityValues(), 3, "FunctionStability", static_cast<uint32_t>(value));
1794: }
1795: 
1796: template<>
1797: FunctionStability EnumUtil::FromString<FunctionStability>(const char *value) {
1798: 	return static_cast<FunctionStability>(StringUtil::StringToEnum(GetFunctionStabilityValues(), 3, "FunctionStability", value));
1799: }
1800: 
1801: const StringUtil::EnumStringLiteral *GetGateStatusValues() {
1802: 	static constexpr StringUtil::EnumStringLiteral values[] {
1803: 		{ static_cast<uint32_t>(GateStatus::GATE_NOT_SET), "GATE_NOT_SET" },
1804: 		{ static_cast<uint32_t>(GateStatus::GATE_SET), "GATE_SET" }
1805: 	};
1806: 	return values;
1807: }
1808: 
1809: template<>
1810: const char* EnumUtil::ToChars<GateStatus>(GateStatus value) {
1811: 	return StringUtil::EnumToString(GetGateStatusValues(), 2, "GateStatus", static_cast<uint32_t>(value));
1812: }
1813: 
1814: template<>
1815: GateStatus EnumUtil::FromString<GateStatus>(const char *value) {
1816: 	return static_cast<GateStatus>(StringUtil::StringToEnum(GetGateStatusValues(), 2, "GateStatus", value));
1817: }
1818: 
1819: const StringUtil::EnumStringLiteral *GetHLLStorageTypeValues() {
1820: 	static constexpr StringUtil::EnumStringLiteral values[] {
1821: 		{ static_cast<uint32_t>(HLLStorageType::HLL_V1), "HLL_V1" },
1822: 		{ static_cast<uint32_t>(HLLStorageType::HLL_V2), "HLL_V2" }
1823: 	};
1824: 	return values;
1825: }
1826: 
1827: template<>
1828: const char* EnumUtil::ToChars<HLLStorageType>(HLLStorageType value) {
1829: 	return StringUtil::EnumToString(GetHLLStorageTypeValues(), 2, "HLLStorageType", static_cast<uint32_t>(value));
1830: }
1831: 
1832: template<>
1833: HLLStorageType EnumUtil::FromString<HLLStorageType>(const char *value) {
1834: 	return static_cast<HLLStorageType>(StringUtil::StringToEnum(GetHLLStorageTypeValues(), 2, "HLLStorageType", value));
1835: }
1836: 
1837: const StringUtil::EnumStringLiteral *GetIndexConstraintTypeValues() {
1838: 	static constexpr StringUtil::EnumStringLiteral values[] {
1839: 		{ static_cast<uint32_t>(IndexConstraintType::NONE), "NONE" },
1840: 		{ static_cast<uint32_t>(IndexConstraintType::UNIQUE), "UNIQUE" },
1841: 		{ static_cast<uint32_t>(IndexConstraintType::PRIMARY), "PRIMARY" },
1842: 		{ static_cast<uint32_t>(IndexConstraintType::FOREIGN), "FOREIGN" }
1843: 	};
1844: 	return values;
1845: }
1846: 
1847: template<>
1848: const char* EnumUtil::ToChars<IndexConstraintType>(IndexConstraintType value) {
1849: 	return StringUtil::EnumToString(GetIndexConstraintTypeValues(), 4, "IndexConstraintType", static_cast<uint32_t>(value));
1850: }
1851: 
1852: template<>
1853: IndexConstraintType EnumUtil::FromString<IndexConstraintType>(const char *value) {
1854: 	return static_cast<IndexConstraintType>(StringUtil::StringToEnum(GetIndexConstraintTypeValues(), 4, "IndexConstraintType", value));
1855: }
1856: 
1857: const StringUtil::EnumStringLiteral *GetInsertColumnOrderValues() {
1858: 	static constexpr StringUtil::EnumStringLiteral values[] {
1859: 		{ static_cast<uint32_t>(InsertColumnOrder::INSERT_BY_POSITION), "INSERT_BY_POSITION" },
1860: 		{ static_cast<uint32_t>(InsertColumnOrder::INSERT_BY_NAME), "INSERT_BY_NAME" }
1861: 	};
1862: 	return values;
1863: }
1864: 
1865: template<>
1866: const char* EnumUtil::ToChars<InsertColumnOrder>(InsertColumnOrder value) {
1867: 	return StringUtil::EnumToString(GetInsertColumnOrderValues(), 2, "InsertColumnOrder", static_cast<uint32_t>(value));
1868: }
1869: 
1870: template<>
1871: InsertColumnOrder EnumUtil::FromString<InsertColumnOrder>(const char *value) {
1872: 	return static_cast<InsertColumnOrder>(StringUtil::StringToEnum(GetInsertColumnOrderValues(), 2, "InsertColumnOrder", value));
1873: }
1874: 
1875: const StringUtil::EnumStringLiteral *GetInterruptModeValues() {
1876: 	static constexpr StringUtil::EnumStringLiteral values[] {
1877: 		{ static_cast<uint32_t>(InterruptMode::NO_INTERRUPTS), "NO_INTERRUPTS" },
1878: 		{ static_cast<uint32_t>(InterruptMode::TASK), "TASK" },
1879: 		{ static_cast<uint32_t>(InterruptMode::BLOCKING), "BLOCKING" }
1880: 	};
1881: 	return values;
1882: }
1883: 
1884: template<>
1885: const char* EnumUtil::ToChars<InterruptMode>(InterruptMode value) {
1886: 	return StringUtil::EnumToString(GetInterruptModeValues(), 3, "InterruptMode", static_cast<uint32_t>(value));
1887: }
1888: 
1889: template<>
1890: InterruptMode EnumUtil::FromString<InterruptMode>(const char *value) {
1891: 	return static_cast<InterruptMode>(StringUtil::StringToEnum(GetInterruptModeValues(), 3, "InterruptMode", value));
1892: }
1893: 
1894: const StringUtil::EnumStringLiteral *GetJoinRefTypeValues() {
1895: 	static constexpr StringUtil::EnumStringLiteral values[] {
1896: 		{ static_cast<uint32_t>(JoinRefType::REGULAR), "REGULAR" },
1897: 		{ static_cast<uint32_t>(JoinRefType::NATURAL), "NATURAL" },
1898: 		{ static_cast<uint32_t>(JoinRefType::CROSS), "CROSS" },
1899: 		{ static_cast<uint32_t>(JoinRefType::POSITIONAL), "POSITIONAL" },
1900: 		{ static_cast<uint32_t>(JoinRefType::ASOF), "ASOF" },
1901: 		{ static_cast<uint32_t>(JoinRefType::DEPENDENT), "DEPENDENT" }
1902: 	};
1903: 	return values;
1904: }
1905: 
1906: template<>
1907: const char* EnumUtil::ToChars<JoinRefType>(JoinRefType value) {
1908: 	return StringUtil::EnumToString(GetJoinRefTypeValues(), 6, "JoinRefType", static_cast<uint32_t>(value));
1909: }
1910: 
1911: template<>
1912: JoinRefType EnumUtil::FromString<JoinRefType>(const char *value) {
1913: 	return static_cast<JoinRefType>(StringUtil::StringToEnum(GetJoinRefTypeValues(), 6, "JoinRefType", value));
1914: }
1915: 
1916: const StringUtil::EnumStringLiteral *GetJoinTypeValues() {
1917: 	static constexpr StringUtil::EnumStringLiteral values[] {
1918: 		{ static_cast<uint32_t>(JoinType::INVALID), "INVALID" },
1919: 		{ static_cast<uint32_t>(JoinType::LEFT), "LEFT" },
1920: 		{ static_cast<uint32_t>(JoinType::RIGHT), "RIGHT" },
1921: 		{ static_cast<uint32_t>(JoinType::INNER), "INNER" },
1922: 		{ static_cast<uint32_t>(JoinType::OUTER), "FULL" },
1923: 		{ static_cast<uint32_t>(JoinType::SEMI), "SEMI" },
1924: 		{ static_cast<uint32_t>(JoinType::ANTI), "ANTI" },
1925: 		{ static_cast<uint32_t>(JoinType::MARK), "MARK" },
1926: 		{ static_cast<uint32_t>(JoinType::SINGLE), "SINGLE" },
1927: 		{ static_cast<uint32_t>(JoinType::RIGHT_SEMI), "RIGHT_SEMI" },
1928: 		{ static_cast<uint32_t>(JoinType::RIGHT_ANTI), "RIGHT_ANTI" }
1929: 	};
1930: 	return values;
1931: }
1932: 
1933: template<>
1934: const char* EnumUtil::ToChars<JoinType>(JoinType value) {
1935: 	return StringUtil::EnumToString(GetJoinTypeValues(), 11, "JoinType", static_cast<uint32_t>(value));
1936: }
1937: 
1938: template<>
1939: JoinType EnumUtil::FromString<JoinType>(const char *value) {
1940: 	return static_cast<JoinType>(StringUtil::StringToEnum(GetJoinTypeValues(), 11, "JoinType", value));
1941: }
1942: 
1943: const StringUtil::EnumStringLiteral *GetKeywordCategoryValues() {
1944: 	static constexpr StringUtil::EnumStringLiteral values[] {
1945: 		{ static_cast<uint32_t>(KeywordCategory::KEYWORD_RESERVED), "KEYWORD_RESERVED" },
1946: 		{ static_cast<uint32_t>(KeywordCategory::KEYWORD_UNRESERVED), "KEYWORD_UNRESERVED" },
1947: 		{ static_cast<uint32_t>(KeywordCategory::KEYWORD_TYPE_FUNC), "KEYWORD_TYPE_FUNC" },
1948: 		{ static_cast<uint32_t>(KeywordCategory::KEYWORD_COL_NAME), "KEYWORD_COL_NAME" },
1949: 		{ static_cast<uint32_t>(KeywordCategory::KEYWORD_NONE), "KEYWORD_NONE" }
1950: 	};
1951: 	return values;
1952: }
1953: 
1954: template<>
1955: const char* EnumUtil::ToChars<KeywordCategory>(KeywordCategory value) {
1956: 	return StringUtil::EnumToString(GetKeywordCategoryValues(), 5, "KeywordCategory", static_cast<uint32_t>(value));
1957: }
1958: 
1959: template<>
1960: KeywordCategory EnumUtil::FromString<KeywordCategory>(const char *value) {
1961: 	return static_cast<KeywordCategory>(StringUtil::StringToEnum(GetKeywordCategoryValues(), 5, "KeywordCategory", value));
1962: }
1963: 
1964: const StringUtil::EnumStringLiteral *GetLimitNodeTypeValues() {
1965: 	static constexpr StringUtil::EnumStringLiteral values[] {
1966: 		{ static_cast<uint32_t>(LimitNodeType::UNSET), "UNSET" },
1967: 		{ static_cast<uint32_t>(LimitNodeType::CONSTANT_VALUE), "CONSTANT_VALUE" },
1968: 		{ static_cast<uint32_t>(LimitNodeType::CONSTANT_PERCENTAGE), "CONSTANT_PERCENTAGE" },
1969: 		{ static_cast<uint32_t>(LimitNodeType::EXPRESSION_VALUE), "EXPRESSION_VALUE" },
1970: 		{ static_cast<uint32_t>(LimitNodeType::EXPRESSION_PERCENTAGE), "EXPRESSION_PERCENTAGE" }
1971: 	};
1972: 	return values;
1973: }
1974: 
1975: template<>
1976: const char* EnumUtil::ToChars<LimitNodeType>(LimitNodeType value) {
1977: 	return StringUtil::EnumToString(GetLimitNodeTypeValues(), 5, "LimitNodeType", static_cast<uint32_t>(value));
1978: }
1979: 
1980: template<>
1981: LimitNodeType EnumUtil::FromString<LimitNodeType>(const char *value) {
1982: 	return static_cast<LimitNodeType>(StringUtil::StringToEnum(GetLimitNodeTypeValues(), 5, "LimitNodeType", value));
1983: }
1984: 
1985: const StringUtil::EnumStringLiteral *GetLoadTypeValues() {
1986: 	static constexpr StringUtil::EnumStringLiteral values[] {
1987: 		{ static_cast<uint32_t>(LoadType::LOAD), "LOAD" },
1988: 		{ static_cast<uint32_t>(LoadType::INSTALL), "INSTALL" },
1989: 		{ static_cast<uint32_t>(LoadType::FORCE_INSTALL), "FORCE_INSTALL" }
1990: 	};
1991: 	return values;
1992: }
1993: 
1994: template<>
1995: const char* EnumUtil::ToChars<LoadType>(LoadType value) {
1996: 	return StringUtil::EnumToString(GetLoadTypeValues(), 3, "LoadType", static_cast<uint32_t>(value));
1997: }
1998: 
1999: template<>
2000: LoadType EnumUtil::FromString<LoadType>(const char *value) {
2001: 	return static_cast<LoadType>(StringUtil::StringToEnum(GetLoadTypeValues(), 3, "LoadType", value));
2002: }
2003: 
2004: const StringUtil::EnumStringLiteral *GetLogicalOperatorTypeValues() {
2005: 	static constexpr StringUtil::EnumStringLiteral values[] {
2006: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_INVALID), "LOGICAL_INVALID" },
2007: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_PROJECTION), "LOGICAL_PROJECTION" },
2008: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_FILTER), "LOGICAL_FILTER" },
2009: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY), "LOGICAL_AGGREGATE_AND_GROUP_BY" },
2010: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_WINDOW), "LOGICAL_WINDOW" },
2011: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_UNNEST), "LOGICAL_UNNEST" },
2012: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_LIMIT), "LOGICAL_LIMIT" },
2013: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_ORDER_BY), "LOGICAL_ORDER_BY" },
2014: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_TOP_N), "LOGICAL_TOP_N" },
2015: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_COPY_TO_FILE), "LOGICAL_COPY_TO_FILE" },
2016: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_DISTINCT), "LOGICAL_DISTINCT" },
2017: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_SAMPLE), "LOGICAL_SAMPLE" },
2018: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_PIVOT), "LOGICAL_PIVOT" },
2019: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_COPY_DATABASE), "LOGICAL_COPY_DATABASE" },
2020: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_GET), "LOGICAL_GET" },
2021: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_CHUNK_GET), "LOGICAL_CHUNK_GET" },
2022: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_DELIM_GET), "LOGICAL_DELIM_GET" },
2023: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_EXPRESSION_GET), "LOGICAL_EXPRESSION_GET" },
2024: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_DUMMY_SCAN), "LOGICAL_DUMMY_SCAN" },
2025: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_EMPTY_RESULT), "LOGICAL_EMPTY_RESULT" },
2026: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_CTE_REF), "LOGICAL_CTE_REF" },
2027: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_JOIN), "LOGICAL_JOIN" },
2028: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_DELIM_JOIN), "LOGICAL_DELIM_JOIN" },
2029: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_COMPARISON_JOIN), "LOGICAL_COMPARISON_JOIN" },
2030: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_ANY_JOIN), "LOGICAL_ANY_JOIN" },
2031: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_CROSS_PRODUCT), "LOGICAL_CROSS_PRODUCT" },
2032: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_POSITIONAL_JOIN), "LOGICAL_POSITIONAL_JOIN" },
2033: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_ASOF_JOIN), "LOGICAL_ASOF_JOIN" },
2034: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_DEPENDENT_JOIN), "LOGICAL_DEPENDENT_JOIN" },
2035: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_UNION), "LOGICAL_UNION" },
2036: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_EXCEPT), "LOGICAL_EXCEPT" },
2037: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_INTERSECT), "LOGICAL_INTERSECT" },
2038: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_RECURSIVE_CTE), "LOGICAL_RECURSIVE_CTE" },
2039: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_MATERIALIZED_CTE), "LOGICAL_MATERIALIZED_CTE" },
2040: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_INSERT), "LOGICAL_INSERT" },
2041: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_DELETE), "LOGICAL_DELETE" },
2042: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_UPDATE), "LOGICAL_UPDATE" },
2043: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_ALTER), "LOGICAL_ALTER" },
2044: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_CREATE_TABLE), "LOGICAL_CREATE_TABLE" },
2045: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_CREATE_INDEX), "LOGICAL_CREATE_INDEX" },
2046: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_CREATE_SEQUENCE), "LOGICAL_CREATE_SEQUENCE" },
2047: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_CREATE_VIEW), "LOGICAL_CREATE_VIEW" },
2048: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_CREATE_SCHEMA), "LOGICAL_CREATE_SCHEMA" },
2049: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_CREATE_MACRO), "LOGICAL_CREATE_MACRO" },
2050: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_DROP), "LOGICAL_DROP" },
2051: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_PRAGMA), "LOGICAL_PRAGMA" },
2052: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_TRANSACTION), "LOGICAL_TRANSACTION" },
2053: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_CREATE_TYPE), "LOGICAL_CREATE_TYPE" },
2054: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_ATTACH), "LOGICAL_ATTACH" },
2055: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_DETACH), "LOGICAL_DETACH" },
2056: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_EXPLAIN), "LOGICAL_EXPLAIN" },
2057: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_PREPARE), "LOGICAL_PREPARE" },
2058: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_EXECUTE), "LOGICAL_EXECUTE" },
2059: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_EXPORT), "LOGICAL_EXPORT" },
2060: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_VACUUM), "LOGICAL_VACUUM" },
2061: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_SET), "LOGICAL_SET" },
2062: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_LOAD), "LOGICAL_LOAD" },
2063: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_RESET), "LOGICAL_RESET" },
2064: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_UPDATE_EXTENSIONS), "LOGICAL_UPDATE_EXTENSIONS" },
2065: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_CREATE_SECRET), "LOGICAL_CREATE_SECRET" },
2066: 		{ static_cast<uint32_t>(LogicalOperatorType::LOGICAL_EXTENSION_OPERATOR), "LOGICAL_EXTENSION_OPERATOR" }
2067: 	};
2068: 	return values;
2069: }
2070: 
2071: template<>
2072: const char* EnumUtil::ToChars<LogicalOperatorType>(LogicalOperatorType value) {
2073: 	return StringUtil::EnumToString(GetLogicalOperatorTypeValues(), 61, "LogicalOperatorType", static_cast<uint32_t>(value));
2074: }
2075: 
2076: template<>
2077: LogicalOperatorType EnumUtil::FromString<LogicalOperatorType>(const char *value) {
2078: 	return static_cast<LogicalOperatorType>(StringUtil::StringToEnum(GetLogicalOperatorTypeValues(), 61, "LogicalOperatorType", value));
2079: }
2080: 
2081: const StringUtil::EnumStringLiteral *GetLogicalTypeIdValues() {
2082: 	static constexpr StringUtil::EnumStringLiteral values[] {
2083: 		{ static_cast<uint32_t>(LogicalTypeId::INVALID), "INVALID" },
2084: 		{ static_cast<uint32_t>(LogicalTypeId::SQLNULL), "NULL" },
2085: 		{ static_cast<uint32_t>(LogicalTypeId::UNKNOWN), "UNKNOWN" },
2086: 		{ static_cast<uint32_t>(LogicalTypeId::ANY), "ANY" },
2087: 		{ static_cast<uint32_t>(LogicalTypeId::USER), "USER" },
2088: 		{ static_cast<uint32_t>(LogicalTypeId::BOOLEAN), "BOOLEAN" },
2089: 		{ static_cast<uint32_t>(LogicalTypeId::TINYINT), "TINYINT" },
2090: 		{ static_cast<uint32_t>(LogicalTypeId::SMALLINT), "SMALLINT" },
2091: 		{ static_cast<uint32_t>(LogicalTypeId::INTEGER), "INTEGER" },
2092: 		{ static_cast<uint32_t>(LogicalTypeId::BIGINT), "BIGINT" },
2093: 		{ static_cast<uint32_t>(LogicalTypeId::DATE), "DATE" },
2094: 		{ static_cast<uint32_t>(LogicalTypeId::TIME), "TIME" },
2095: 		{ static_cast<uint32_t>(LogicalTypeId::TIMESTAMP_SEC), "TIMESTAMP_S" },
2096: 		{ static_cast<uint32_t>(LogicalTypeId::TIMESTAMP_MS), "TIMESTAMP_MS" },
2097: 		{ static_cast<uint32_t>(LogicalTypeId::TIMESTAMP), "TIMESTAMP" },
2098: 		{ static_cast<uint32_t>(LogicalTypeId::TIMESTAMP_NS), "TIMESTAMP_NS" },
2099: 		{ static_cast<uint32_t>(LogicalTypeId::DECIMAL), "DECIMAL" },
2100: 		{ static_cast<uint32_t>(LogicalTypeId::FLOAT), "FLOAT" },
2101: 		{ static_cast<uint32_t>(LogicalTypeId::DOUBLE), "DOUBLE" },
2102: 		{ static_cast<uint32_t>(LogicalTypeId::CHAR), "CHAR" },
2103: 		{ static_cast<uint32_t>(LogicalTypeId::VARCHAR), "VARCHAR" },
2104: 		{ static_cast<uint32_t>(LogicalTypeId::BLOB), "BLOB" },
2105: 		{ static_cast<uint32_t>(LogicalTypeId::INTERVAL), "INTERVAL" },
2106: 		{ static_cast<uint32_t>(LogicalTypeId::UTINYINT), "UTINYINT" },
2107: 		{ static_cast<uint32_t>(LogicalTypeId::USMALLINT), "USMALLINT" },
2108: 		{ static_cast<uint32_t>(LogicalTypeId::UINTEGER), "UINTEGER" },
2109: 		{ static_cast<uint32_t>(LogicalTypeId::UBIGINT), "UBIGINT" },
2110: 		{ static_cast<uint32_t>(LogicalTypeId::TIMESTAMP_TZ), "TIMESTAMP WITH TIME ZONE" },
2111: 		{ static_cast<uint32_t>(LogicalTypeId::TIME_TZ), "TIME WITH TIME ZONE" },
2112: 		{ static_cast<uint32_t>(LogicalTypeId::BIT), "BIT" },
2113: 		{ static_cast<uint32_t>(LogicalTypeId::STRING_LITERAL), "STRING_LITERAL" },
2114: 		{ static_cast<uint32_t>(LogicalTypeId::INTEGER_LITERAL), "INTEGER_LITERAL" },
2115: 		{ static_cast<uint32_t>(LogicalTypeId::VARINT), "VARINT" },
2116: 		{ static_cast<uint32_t>(LogicalTypeId::UHUGEINT), "UHUGEINT" },
2117: 		{ static_cast<uint32_t>(LogicalTypeId::HUGEINT), "HUGEINT" },
2118: 		{ static_cast<uint32_t>(LogicalTypeId::POINTER), "POINTER" },
2119: 		{ static_cast<uint32_t>(LogicalTypeId::VALIDITY), "VALIDITY" },
2120: 		{ static_cast<uint32_t>(LogicalTypeId::UUID), "UUID" },
2121: 		{ static_cast<uint32_t>(LogicalTypeId::STRUCT), "STRUCT" },
2122: 		{ static_cast<uint32_t>(LogicalTypeId::LIST), "LIST" },
2123: 		{ static_cast<uint32_t>(LogicalTypeId::MAP), "MAP" },
2124: 		{ static_cast<uint32_t>(LogicalTypeId::TABLE), "TABLE" },
2125: 		{ static_cast<uint32_t>(LogicalTypeId::ENUM), "ENUM" },
2126: 		{ static_cast<uint32_t>(LogicalTypeId::AGGREGATE_STATE), "AGGREGATE_STATE" },
2127: 		{ static_cast<uint32_t>(LogicalTypeId::LAMBDA), "LAMBDA" },
2128: 		{ static_cast<uint32_t>(LogicalTypeId::UNION), "UNION" },
2129: 		{ static_cast<uint32_t>(LogicalTypeId::ARRAY), "ARRAY" }
2130: 	};
2131: 	return values;
2132: }
2133: 
2134: template<>
2135: const char* EnumUtil::ToChars<LogicalTypeId>(LogicalTypeId value) {
2136: 	return StringUtil::EnumToString(GetLogicalTypeIdValues(), 47, "LogicalTypeId", static_cast<uint32_t>(value));
2137: }
2138: 
2139: template<>
2140: LogicalTypeId EnumUtil::FromString<LogicalTypeId>(const char *value) {
2141: 	return static_cast<LogicalTypeId>(StringUtil::StringToEnum(GetLogicalTypeIdValues(), 47, "LogicalTypeId", value));
2142: }
2143: 
2144: const StringUtil::EnumStringLiteral *GetLookupResultTypeValues() {
2145: 	static constexpr StringUtil::EnumStringLiteral values[] {
2146: 		{ static_cast<uint32_t>(LookupResultType::LOOKUP_MISS), "LOOKUP_MISS" },
2147: 		{ static_cast<uint32_t>(LookupResultType::LOOKUP_HIT), "LOOKUP_HIT" },
2148: 		{ static_cast<uint32_t>(LookupResultType::LOOKUP_NULL), "LOOKUP_NULL" }
2149: 	};
2150: 	return values;
2151: }
2152: 
2153: template<>
2154: const char* EnumUtil::ToChars<LookupResultType>(LookupResultType value) {
2155: 	return StringUtil::EnumToString(GetLookupResultTypeValues(), 3, "LookupResultType", static_cast<uint32_t>(value));
2156: }
2157: 
2158: template<>
2159: LookupResultType EnumUtil::FromString<LookupResultType>(const char *value) {
2160: 	return static_cast<LookupResultType>(StringUtil::StringToEnum(GetLookupResultTypeValues(), 3, "LookupResultType", value));
2161: }
2162: 
2163: const StringUtil::EnumStringLiteral *GetMacroTypeValues() {
2164: 	static constexpr StringUtil::EnumStringLiteral values[] {
2165: 		{ static_cast<uint32_t>(MacroType::VOID_MACRO), "VOID_MACRO" },
2166: 		{ static_cast<uint32_t>(MacroType::TABLE_MACRO), "TABLE_MACRO" },
2167: 		{ static_cast<uint32_t>(MacroType::SCALAR_MACRO), "SCALAR_MACRO" }
2168: 	};
2169: 	return values;
2170: }
2171: 
2172: template<>
2173: const char* EnumUtil::ToChars<MacroType>(MacroType value) {
2174: 	return StringUtil::EnumToString(GetMacroTypeValues(), 3, "MacroType", static_cast<uint32_t>(value));
2175: }
2176: 
2177: template<>
2178: MacroType EnumUtil::FromString<MacroType>(const char *value) {
2179: 	return static_cast<MacroType>(StringUtil::StringToEnum(GetMacroTypeValues(), 3, "MacroType", value));
2180: }
2181: 
2182: const StringUtil::EnumStringLiteral *GetMapInvalidReasonValues() {
2183: 	static constexpr StringUtil::EnumStringLiteral values[] {
2184: 		{ static_cast<uint32_t>(MapInvalidReason::VALID), "VALID" },
2185: 		{ static_cast<uint32_t>(MapInvalidReason::NULL_KEY), "NULL_KEY" },
2186: 		{ static_cast<uint32_t>(MapInvalidReason::DUPLICATE_KEY), "DUPLICATE_KEY" },
2187: 		{ static_cast<uint32_t>(MapInvalidReason::NOT_ALIGNED), "NOT_ALIGNED" },
2188: 		{ static_cast<uint32_t>(MapInvalidReason::INVALID_PARAMS), "INVALID_PARAMS" }
2189: 	};
2190: 	return values;
2191: }
2192: 
2193: template<>
2194: const char* EnumUtil::ToChars<MapInvalidReason>(MapInvalidReason value) {
2195: 	return StringUtil::EnumToString(GetMapInvalidReasonValues(), 5, "MapInvalidReason", static_cast<uint32_t>(value));
2196: }
2197: 
2198: template<>
2199: MapInvalidReason EnumUtil::FromString<MapInvalidReason>(const char *value) {
2200: 	return static_cast<MapInvalidReason>(StringUtil::StringToEnum(GetMapInvalidReasonValues(), 5, "MapInvalidReason", value));
2201: }
2202: 
2203: const StringUtil::EnumStringLiteral *GetMemoryTagValues() {
2204: 	static constexpr StringUtil::EnumStringLiteral values[] {
2205: 		{ static_cast<uint32_t>(MemoryTag::BASE_TABLE), "BASE_TABLE" },
2206: 		{ static_cast<uint32_t>(MemoryTag::HASH_TABLE), "HASH_TABLE" },
2207: 		{ static_cast<uint32_t>(MemoryTag::PARQUET_READER), "PARQUET_READER" },
2208: 		{ static_cast<uint32_t>(MemoryTag::CSV_READER), "CSV_READER" },
2209: 		{ static_cast<uint32_t>(MemoryTag::ORDER_BY), "ORDER_BY" },
2210: 		{ static_cast<uint32_t>(MemoryTag::ART_INDEX), "ART_INDEX" },
2211: 		{ static_cast<uint32_t>(MemoryTag::COLUMN_DATA), "COLUMN_DATA" },
2212: 		{ static_cast<uint32_t>(MemoryTag::METADATA), "METADATA" },
2213: 		{ static_cast<uint32_t>(MemoryTag::OVERFLOW_STRINGS), "OVERFLOW_STRINGS" },
2214: 		{ static_cast<uint32_t>(MemoryTag::IN_MEMORY_TABLE), "IN_MEMORY_TABLE" },
2215: 		{ static_cast<uint32_t>(MemoryTag::ALLOCATOR), "ALLOCATOR" },
2216: 		{ static_cast<uint32_t>(MemoryTag::EXTENSION), "EXTENSION" },
2217: 		{ static_cast<uint32_t>(MemoryTag::TRANSACTION), "TRANSACTION" }
2218: 	};
2219: 	return values;
2220: }
2221: 
2222: template<>
2223: const char* EnumUtil::ToChars<MemoryTag>(MemoryTag value) {
2224: 	return StringUtil::EnumToString(GetMemoryTagValues(), 13, "MemoryTag", static_cast<uint32_t>(value));
2225: }
2226: 
2227: template<>
2228: MemoryTag EnumUtil::FromString<MemoryTag>(const char *value) {
2229: 	return static_cast<MemoryTag>(StringUtil::StringToEnum(GetMemoryTagValues(), 13, "MemoryTag", value));
2230: }
2231: 
2232: const StringUtil::EnumStringLiteral *GetMetaPipelineTypeValues() {
2233: 	static constexpr StringUtil::EnumStringLiteral values[] {
2234: 		{ static_cast<uint32_t>(MetaPipelineType::REGULAR), "REGULAR" },
2235: 		{ static_cast<uint32_t>(MetaPipelineType::JOIN_BUILD), "JOIN_BUILD" }
2236: 	};
2237: 	return values;
2238: }
2239: 
2240: template<>
2241: const char* EnumUtil::ToChars<MetaPipelineType>(MetaPipelineType value) {
2242: 	return StringUtil::EnumToString(GetMetaPipelineTypeValues(), 2, "MetaPipelineType", static_cast<uint32_t>(value));
2243: }
2244: 
2245: template<>
2246: MetaPipelineType EnumUtil::FromString<MetaPipelineType>(const char *value) {
2247: 	return static_cast<MetaPipelineType>(StringUtil::StringToEnum(GetMetaPipelineTypeValues(), 2, "MetaPipelineType", value));
2248: }
2249: 
2250: const StringUtil::EnumStringLiteral *GetMetricsTypeValues() {
2251: 	static constexpr StringUtil::EnumStringLiteral values[] {
2252: 		{ static_cast<uint32_t>(MetricsType::QUERY_NAME), "QUERY_NAME" },
2253: 		{ static_cast<uint32_t>(MetricsType::BLOCKED_THREAD_TIME), "BLOCKED_THREAD_TIME" },
2254: 		{ static_cast<uint32_t>(MetricsType::CPU_TIME), "CPU_TIME" },
2255: 		{ static_cast<uint32_t>(MetricsType::EXTRA_INFO), "EXTRA_INFO" },
2256: 		{ static_cast<uint32_t>(MetricsType::CUMULATIVE_CARDINALITY), "CUMULATIVE_CARDINALITY" },
2257: 		{ static_cast<uint32_t>(MetricsType::OPERATOR_TYPE), "OPERATOR_TYPE" },
2258: 		{ static_cast<uint32_t>(MetricsType::OPERATOR_CARDINALITY), "OPERATOR_CARDINALITY" },
2259: 		{ static_cast<uint32_t>(MetricsType::CUMULATIVE_ROWS_SCANNED), "CUMULATIVE_ROWS_SCANNED" },
2260: 		{ static_cast<uint32_t>(MetricsType::OPERATOR_ROWS_SCANNED), "OPERATOR_ROWS_SCANNED" },
2261: 		{ static_cast<uint32_t>(MetricsType::OPERATOR_TIMING), "OPERATOR_TIMING" },
2262: 		{ static_cast<uint32_t>(MetricsType::RESULT_SET_SIZE), "RESULT_SET_SIZE" },
2263: 		{ static_cast<uint32_t>(MetricsType::LATENCY), "LATENCY" },
2264: 		{ static_cast<uint32_t>(MetricsType::ROWS_RETURNED), "ROWS_RETURNED" },
2265: 		{ static_cast<uint32_t>(MetricsType::OPERATOR_NAME), "OPERATOR_NAME" },
2266: 		{ static_cast<uint32_t>(MetricsType::ALL_OPTIMIZERS), "ALL_OPTIMIZERS" },
2267: 		{ static_cast<uint32_t>(MetricsType::CUMULATIVE_OPTIMIZER_TIMING), "CUMULATIVE_OPTIMIZER_TIMING" },
2268: 		{ static_cast<uint32_t>(MetricsType::PLANNER), "PLANNER" },
2269: 		{ static_cast<uint32_t>(MetricsType::PLANNER_BINDING), "PLANNER_BINDING" },
2270: 		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER), "PHYSICAL_PLANNER" },
2271: 		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING), "PHYSICAL_PLANNER_COLUMN_BINDING" },
2272: 		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES), "PHYSICAL_PLANNER_RESOLVE_TYPES" },
2273: 		{ static_cast<uint32_t>(MetricsType::PHYSICAL_PLANNER_CREATE_PLAN), "PHYSICAL_PLANNER_CREATE_PLAN" },
2274: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_EXPRESSION_REWRITER), "OPTIMIZER_EXPRESSION_REWRITER" },
2275: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_FILTER_PULLUP), "OPTIMIZER_FILTER_PULLUP" },
2276: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_FILTER_PUSHDOWN), "OPTIMIZER_FILTER_PUSHDOWN" },
2277: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_EMPTY_RESULT_PULLUP), "OPTIMIZER_EMPTY_RESULT_PULLUP" },
2278: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_CTE_FILTER_PUSHER), "OPTIMIZER_CTE_FILTER_PUSHER" },
2279: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_REGEX_RANGE), "OPTIMIZER_REGEX_RANGE" },
2280: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_IN_CLAUSE), "OPTIMIZER_IN_CLAUSE" },
2281: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_JOIN_ORDER), "OPTIMIZER_JOIN_ORDER" },
2282: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_DELIMINATOR), "OPTIMIZER_DELIMINATOR" },
2283: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_UNNEST_REWRITER), "OPTIMIZER_UNNEST_REWRITER" },
2284: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_UNUSED_COLUMNS), "OPTIMIZER_UNUSED_COLUMNS" },
2285: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_STATISTICS_PROPAGATION), "OPTIMIZER_STATISTICS_PROPAGATION" },
2286: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COMMON_SUBEXPRESSIONS), "OPTIMIZER_COMMON_SUBEXPRESSIONS" },
2287: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COMMON_AGGREGATE), "OPTIMIZER_COMMON_AGGREGATE" },
2288: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COLUMN_LIFETIME), "OPTIMIZER_COLUMN_LIFETIME" },
2289: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_BUILD_SIDE_PROBE_SIDE), "OPTIMIZER_BUILD_SIDE_PROBE_SIDE" },
2290: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_LIMIT_PUSHDOWN), "OPTIMIZER_LIMIT_PUSHDOWN" },
2291: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_TOP_N), "OPTIMIZER_TOP_N" },
2292: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_COMPRESSED_MATERIALIZATION), "OPTIMIZER_COMPRESSED_MATERIALIZATION" },
2293: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_DUPLICATE_GROUPS), "OPTIMIZER_DUPLICATE_GROUPS" },
2294: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_REORDER_FILTER), "OPTIMIZER_REORDER_FILTER" },
2295: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_SAMPLING_PUSHDOWN), "OPTIMIZER_SAMPLING_PUSHDOWN" },
2296: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_JOIN_FILTER_PUSHDOWN), "OPTIMIZER_JOIN_FILTER_PUSHDOWN" },
2297: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_EXTENSION), "OPTIMIZER_EXTENSION" },
2298: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_MATERIALIZED_CTE), "OPTIMIZER_MATERIALIZED_CTE" },
2299: 		{ static_cast<uint32_t>(MetricsType::OPTIMIZER_SUM_REWRITER), "OPTIMIZER_SUM_REWRITER" }
2300: 	};
2301: 	return values;
2302: }
2303: 
2304: template<>
2305: const char* EnumUtil::ToChars<MetricsType>(MetricsType value) {
2306: 	return StringUtil::EnumToString(GetMetricsTypeValues(), 48, "MetricsType", static_cast<uint32_t>(value));
2307: }
2308: 
2309: template<>
2310: MetricsType EnumUtil::FromString<MetricsType>(const char *value) {
2311: 	return static_cast<MetricsType>(StringUtil::StringToEnum(GetMetricsTypeValues(), 48, "MetricsType", value));
2312: }
2313: 
2314: const StringUtil::EnumStringLiteral *GetNTypeValues() {
2315: 	static constexpr StringUtil::EnumStringLiteral values[] {
2316: 		{ static_cast<uint32_t>(NType::PREFIX), "PREFIX" },
2317: 		{ static_cast<uint32_t>(NType::LEAF), "LEAF" },
2318: 		{ static_cast<uint32_t>(NType::NODE_4), "NODE_4" },
2319: 		{ static_cast<uint32_t>(NType::NODE_16), "NODE_16" },
2320: 		{ static_cast<uint32_t>(NType::NODE_48), "NODE_48" },
2321: 		{ static_cast<uint32_t>(NType::NODE_256), "NODE_256" },
2322: 		{ static_cast<uint32_t>(NType::LEAF_INLINED), "LEAF_INLINED" },
2323: 		{ static_cast<uint32_t>(NType::NODE_7_LEAF), "NODE_7_LEAF" },
2324: 		{ static_cast<uint32_t>(NType::NODE_15_LEAF), "NODE_15_LEAF" },
2325: 		{ static_cast<uint32_t>(NType::NODE_256_LEAF), "NODE_256_LEAF" }
2326: 	};
2327: 	return values;
2328: }
2329: 
2330: template<>
2331: const char* EnumUtil::ToChars<NType>(NType value) {
2332: 	return StringUtil::EnumToString(GetNTypeValues(), 10, "NType", static_cast<uint32_t>(value));
2333: }
2334: 
2335: template<>
2336: NType EnumUtil::FromString<NType>(const char *value) {
2337: 	return static_cast<NType>(StringUtil::StringToEnum(GetNTypeValues(), 10, "NType", value));
2338: }
2339: 
2340: const StringUtil::EnumStringLiteral *GetNewLineIdentifierValues() {
2341: 	static constexpr StringUtil::EnumStringLiteral values[] {
2342: 		{ static_cast<uint32_t>(NewLineIdentifier::SINGLE_N), "SINGLE_N" },
2343: 		{ static_cast<uint32_t>(NewLineIdentifier::CARRY_ON), "CARRY_ON" },
2344: 		{ static_cast<uint32_t>(NewLineIdentifier::NOT_SET), "NOT_SET" },
2345: 		{ static_cast<uint32_t>(NewLineIdentifier::SINGLE_R), "SINGLE_R" }
2346: 	};
2347: 	return values;
2348: }
2349: 
2350: template<>
2351: const char* EnumUtil::ToChars<NewLineIdentifier>(NewLineIdentifier value) {
2352: 	return StringUtil::EnumToString(GetNewLineIdentifierValues(), 4, "NewLineIdentifier", static_cast<uint32_t>(value));
2353: }
2354: 
2355: template<>
2356: NewLineIdentifier EnumUtil::FromString<NewLineIdentifier>(const char *value) {
2357: 	return static_cast<NewLineIdentifier>(StringUtil::StringToEnum(GetNewLineIdentifierValues(), 4, "NewLineIdentifier", value));
2358: }
2359: 
2360: const StringUtil::EnumStringLiteral *GetOnConflictActionValues() {
2361: 	static constexpr StringUtil::EnumStringLiteral values[] {
2362: 		{ static_cast<uint32_t>(OnConflictAction::THROW), "THROW" },
2363: 		{ static_cast<uint32_t>(OnConflictAction::NOTHING), "NOTHING" },
2364: 		{ static_cast<uint32_t>(OnConflictAction::UPDATE), "UPDATE" },
2365: 		{ static_cast<uint32_t>(OnConflictAction::REPLACE), "REPLACE" }
2366: 	};
2367: 	return values;
2368: }
2369: 
2370: template<>
2371: const char* EnumUtil::ToChars<OnConflictAction>(OnConflictAction value) {
2372: 	return StringUtil::EnumToString(GetOnConflictActionValues(), 4, "OnConflictAction", static_cast<uint32_t>(value));
2373: }
2374: 
2375: template<>
2376: OnConflictAction EnumUtil::FromString<OnConflictAction>(const char *value) {
2377: 	return static_cast<OnConflictAction>(StringUtil::StringToEnum(GetOnConflictActionValues(), 4, "OnConflictAction", value));
2378: }
2379: 
2380: const StringUtil::EnumStringLiteral *GetOnCreateConflictValues() {
2381: 	static constexpr StringUtil::EnumStringLiteral values[] {
2382: 		{ static_cast<uint32_t>(OnCreateConflict::ERROR_ON_CONFLICT), "ERROR_ON_CONFLICT" },
2383: 		{ static_cast<uint32_t>(OnCreateConflict::IGNORE_ON_CONFLICT), "IGNORE_ON_CONFLICT" },
2384: 		{ static_cast<uint32_t>(OnCreateConflict::REPLACE_ON_CONFLICT), "REPLACE_ON_CONFLICT" },
2385: 		{ static_cast<uint32_t>(OnCreateConflict::ALTER_ON_CONFLICT), "ALTER_ON_CONFLICT" }
2386: 	};
2387: 	return values;
2388: }
2389: 
2390: template<>
2391: const char* EnumUtil::ToChars<OnCreateConflict>(OnCreateConflict value) {
2392: 	return StringUtil::EnumToString(GetOnCreateConflictValues(), 4, "OnCreateConflict", static_cast<uint32_t>(value));
2393: }
2394: 
2395: template<>
2396: OnCreateConflict EnumUtil::FromString<OnCreateConflict>(const char *value) {
2397: 	return static_cast<OnCreateConflict>(StringUtil::StringToEnum(GetOnCreateConflictValues(), 4, "OnCreateConflict", value));
2398: }
2399: 
2400: const StringUtil::EnumStringLiteral *GetOnEntryNotFoundValues() {
2401: 	static constexpr StringUtil::EnumStringLiteral values[] {
2402: 		{ static_cast<uint32_t>(OnEntryNotFound::THROW_EXCEPTION), "THROW_EXCEPTION" },
2403: 		{ static_cast<uint32_t>(OnEntryNotFound::RETURN_NULL), "RETURN_NULL" }
2404: 	};
2405: 	return values;
2406: }
2407: 
2408: template<>
2409: const char* EnumUtil::ToChars<OnEntryNotFound>(OnEntryNotFound value) {
2410: 	return StringUtil::EnumToString(GetOnEntryNotFoundValues(), 2, "OnEntryNotFound", static_cast<uint32_t>(value));
2411: }
2412: 
2413: template<>
2414: OnEntryNotFound EnumUtil::FromString<OnEntryNotFound>(const char *value) {
2415: 	return static_cast<OnEntryNotFound>(StringUtil::StringToEnum(GetOnEntryNotFoundValues(), 2, "OnEntryNotFound", value));
2416: }
2417: 
2418: const StringUtil::EnumStringLiteral *GetOperatorFinalizeResultTypeValues() {
2419: 	static constexpr StringUtil::EnumStringLiteral values[] {
2420: 		{ static_cast<uint32_t>(OperatorFinalizeResultType::HAVE_MORE_OUTPUT), "HAVE_MORE_OUTPUT" },
2421: 		{ static_cast<uint32_t>(OperatorFinalizeResultType::FINISHED), "FINISHED" }
2422: 	};
2423: 	return values;
2424: }
2425: 
2426: template<>
2427: const char* EnumUtil::ToChars<OperatorFinalizeResultType>(OperatorFinalizeResultType value) {
2428: 	return StringUtil::EnumToString(GetOperatorFinalizeResultTypeValues(), 2, "OperatorFinalizeResultType", static_cast<uint32_t>(value));
2429: }
2430: 
2431: template<>
2432: OperatorFinalizeResultType EnumUtil::FromString<OperatorFinalizeResultType>(const char *value) {
2433: 	return static_cast<OperatorFinalizeResultType>(StringUtil::StringToEnum(GetOperatorFinalizeResultTypeValues(), 2, "OperatorFinalizeResultType", value));
2434: }
2435: 
2436: const StringUtil::EnumStringLiteral *GetOperatorResultTypeValues() {
2437: 	static constexpr StringUtil::EnumStringLiteral values[] {
2438: 		{ static_cast<uint32_t>(OperatorResultType::NEED_MORE_INPUT), "NEED_MORE_INPUT" },
2439: 		{ static_cast<uint32_t>(OperatorResultType::HAVE_MORE_OUTPUT), "HAVE_MORE_OUTPUT" },
2440: 		{ static_cast<uint32_t>(OperatorResultType::FINISHED), "FINISHED" },
2441: 		{ static_cast<uint32_t>(OperatorResultType::BLOCKED), "BLOCKED" }
2442: 	};
2443: 	return values;
2444: }
2445: 
2446: template<>
2447: const char* EnumUtil::ToChars<OperatorResultType>(OperatorResultType value) {
2448: 	return StringUtil::EnumToString(GetOperatorResultTypeValues(), 4, "OperatorResultType", static_cast<uint32_t>(value));
2449: }
2450: 
2451: template<>
2452: OperatorResultType EnumUtil::FromString<OperatorResultType>(const char *value) {
2453: 	return static_cast<OperatorResultType>(StringUtil::StringToEnum(GetOperatorResultTypeValues(), 4, "OperatorResultType", value));
2454: }
2455: 
2456: const StringUtil::EnumStringLiteral *GetOptimizerTypeValues() {
2457: 	static constexpr StringUtil::EnumStringLiteral values[] {
2458: 		{ static_cast<uint32_t>(OptimizerType::INVALID), "INVALID" },
2459: 		{ static_cast<uint32_t>(OptimizerType::EXPRESSION_REWRITER), "EXPRESSION_REWRITER" },
2460: 		{ static_cast<uint32_t>(OptimizerType::FILTER_PULLUP), "FILTER_PULLUP" },
2461: 		{ static_cast<uint32_t>(OptimizerType::FILTER_PUSHDOWN), "FILTER_PUSHDOWN" },
2462: 		{ static_cast<uint32_t>(OptimizerType::EMPTY_RESULT_PULLUP), "EMPTY_RESULT_PULLUP" },
2463: 		{ static_cast<uint32_t>(OptimizerType::CTE_FILTER_PUSHER), "CTE_FILTER_PUSHER" },
2464: 		{ static_cast<uint32_t>(OptimizerType::REGEX_RANGE), "REGEX_RANGE" },
2465: 		{ static_cast<uint32_t>(OptimizerType::IN_CLAUSE), "IN_CLAUSE" },
2466: 		{ static_cast<uint32_t>(OptimizerType::JOIN_ORDER), "JOIN_ORDER" },
2467: 		{ static_cast<uint32_t>(OptimizerType::DELIMINATOR), "DELIMINATOR" },
2468: 		{ static_cast<uint32_t>(OptimizerType::UNNEST_REWRITER), "UNNEST_REWRITER" },
2469: 		{ static_cast<uint32_t>(OptimizerType::UNUSED_COLUMNS), "UNUSED_COLUMNS" },
2470: 		{ static_cast<uint32_t>(OptimizerType::STATISTICS_PROPAGATION), "STATISTICS_PROPAGATION" },
2471: 		{ static_cast<uint32_t>(OptimizerType::COMMON_SUBEXPRESSIONS), "COMMON_SUBEXPRESSIONS" },
2472: 		{ static_cast<uint32_t>(OptimizerType::COMMON_AGGREGATE), "COMMON_AGGREGATE" },
2473: 		{ static_cast<uint32_t>(OptimizerType::COLUMN_LIFETIME), "COLUMN_LIFETIME" },
2474: 		{ static_cast<uint32_t>(OptimizerType::BUILD_SIDE_PROBE_SIDE), "BUILD_SIDE_PROBE_SIDE" },
2475: 		{ static_cast<uint32_t>(OptimizerType::LIMIT_PUSHDOWN), "LIMIT_PUSHDOWN" },
2476: 		{ static_cast<uint32_t>(OptimizerType::TOP_N), "TOP_N" },
2477: 		{ static_cast<uint32_t>(OptimizerType::COMPRESSED_MATERIALIZATION), "COMPRESSED_MATERIALIZATION" },
2478: 		{ static_cast<uint32_t>(OptimizerType::DUPLICATE_GROUPS), "DUPLICATE_GROUPS" },
2479: 		{ static_cast<uint32_t>(OptimizerType::REORDER_FILTER), "REORDER_FILTER" },
2480: 		{ static_cast<uint32_t>(OptimizerType::SAMPLING_PUSHDOWN), "SAMPLING_PUSHDOWN" },
2481: 		{ static_cast<uint32_t>(OptimizerType::JOIN_FILTER_PUSHDOWN), "JOIN_FILTER_PUSHDOWN" },
2482: 		{ static_cast<uint32_t>(OptimizerType::EXTENSION), "EXTENSION" },
2483: 		{ static_cast<uint32_t>(OptimizerType::MATERIALIZED_CTE), "MATERIALIZED_CTE" },
2484: 		{ static_cast<uint32_t>(OptimizerType::SUM_REWRITER), "SUM_REWRITER" }
2485: 	};
2486: 	return values;
2487: }
2488: 
2489: template<>
2490: const char* EnumUtil::ToChars<OptimizerType>(OptimizerType value) {
2491: 	return StringUtil::EnumToString(GetOptimizerTypeValues(), 27, "OptimizerType", static_cast<uint32_t>(value));
2492: }
2493: 
2494: template<>
2495: OptimizerType EnumUtil::FromString<OptimizerType>(const char *value) {
2496: 	return static_cast<OptimizerType>(StringUtil::StringToEnum(GetOptimizerTypeValues(), 27, "OptimizerType", value));
2497: }
2498: 
2499: const StringUtil::EnumStringLiteral *GetOrderByNullTypeValues() {
2500: 	static constexpr StringUtil::EnumStringLiteral values[] {
2501: 		{ static_cast<uint32_t>(OrderByNullType::INVALID), "INVALID" },
2502: 		{ static_cast<uint32_t>(OrderByNullType::ORDER_DEFAULT), "ORDER_DEFAULT" },
2503: 		{ static_cast<uint32_t>(OrderByNullType::ORDER_DEFAULT), "DEFAULT" },
2504: 		{ static_cast<uint32_t>(OrderByNullType::NULLS_FIRST), "NULLS_FIRST" },
2505: 		{ static_cast<uint32_t>(OrderByNullType::NULLS_FIRST), "NULLS FIRST" },
2506: 		{ static_cast<uint32_t>(OrderByNullType::NULLS_LAST), "NULLS_LAST" },
2507: 		{ static_cast<uint32_t>(OrderByNullType::NULLS_LAST), "NULLS LAST" }
2508: 	};
2509: 	return values;
2510: }
2511: 
2512: template<>
2513: const char* EnumUtil::ToChars<OrderByNullType>(OrderByNullType value) {
2514: 	return StringUtil::EnumToString(GetOrderByNullTypeValues(), 7, "OrderByNullType", static_cast<uint32_t>(value));
2515: }
2516: 
2517: template<>
2518: OrderByNullType EnumUtil::FromString<OrderByNullType>(const char *value) {
2519: 	return static_cast<OrderByNullType>(StringUtil::StringToEnum(GetOrderByNullTypeValues(), 7, "OrderByNullType", value));
2520: }
2521: 
2522: const StringUtil::EnumStringLiteral *GetOrderPreservationTypeValues() {
2523: 	static constexpr StringUtil::EnumStringLiteral values[] {
2524: 		{ static_cast<uint32_t>(OrderPreservationType::NO_ORDER), "NO_ORDER" },
2525: 		{ static_cast<uint32_t>(OrderPreservationType::INSERTION_ORDER), "INSERTION_ORDER" },
2526: 		{ static_cast<uint32_t>(OrderPreservationType::FIXED_ORDER), "FIXED_ORDER" }
2527: 	};
2528: 	return values;
2529: }
2530: 
2531: template<>
2532: const char* EnumUtil::ToChars<OrderPreservationType>(OrderPreservationType value) {
2533: 	return StringUtil::EnumToString(GetOrderPreservationTypeValues(), 3, "OrderPreservationType", static_cast<uint32_t>(value));
2534: }
2535: 
2536: template<>
2537: OrderPreservationType EnumUtil::FromString<OrderPreservationType>(const char *value) {
2538: 	return static_cast<OrderPreservationType>(StringUtil::StringToEnum(GetOrderPreservationTypeValues(), 3, "OrderPreservationType", value));
2539: }
2540: 
2541: const StringUtil::EnumStringLiteral *GetOrderTypeValues() {
2542: 	static constexpr StringUtil::EnumStringLiteral values[] {
2543: 		{ static_cast<uint32_t>(OrderType::INVALID), "INVALID" },
2544: 		{ static_cast<uint32_t>(OrderType::ORDER_DEFAULT), "ORDER_DEFAULT" },
2545: 		{ static_cast<uint32_t>(OrderType::ORDER_DEFAULT), "DEFAULT" },
2546: 		{ static_cast<uint32_t>(OrderType::ASCENDING), "ASCENDING" },
2547: 		{ static_cast<uint32_t>(OrderType::ASCENDING), "ASC" },
2548: 		{ static_cast<uint32_t>(OrderType::DESCENDING), "DESCENDING" },
2549: 		{ static_cast<uint32_t>(OrderType::DESCENDING), "DESC" }
2550: 	};
2551: 	return values;
2552: }
2553: 
2554: template<>
2555: const char* EnumUtil::ToChars<OrderType>(OrderType value) {
2556: 	return StringUtil::EnumToString(GetOrderTypeValues(), 7, "OrderType", static_cast<uint32_t>(value));
2557: }
2558: 
2559: template<>
2560: OrderType EnumUtil::FromString<OrderType>(const char *value) {
2561: 	return static_cast<OrderType>(StringUtil::StringToEnum(GetOrderTypeValues(), 7, "OrderType", value));
2562: }
2563: 
2564: const StringUtil::EnumStringLiteral *GetOutputStreamValues() {
2565: 	static constexpr StringUtil::EnumStringLiteral values[] {
2566: 		{ static_cast<uint32_t>(OutputStream::STREAM_STDOUT), "STREAM_STDOUT" },
2567: 		{ static_cast<uint32_t>(OutputStream::STREAM_STDERR), "STREAM_STDERR" }
2568: 	};
2569: 	return values;
2570: }
2571: 
2572: template<>
2573: const char* EnumUtil::ToChars<OutputStream>(OutputStream value) {
2574: 	return StringUtil::EnumToString(GetOutputStreamValues(), 2, "OutputStream", static_cast<uint32_t>(value));
2575: }
2576: 
2577: template<>
2578: OutputStream EnumUtil::FromString<OutputStream>(const char *value) {
2579: 	return static_cast<OutputStream>(StringUtil::StringToEnum(GetOutputStreamValues(), 2, "OutputStream", value));
2580: }
2581: 
2582: const StringUtil::EnumStringLiteral *GetParseInfoTypeValues() {
2583: 	static constexpr StringUtil::EnumStringLiteral values[] {
2584: 		{ static_cast<uint32_t>(ParseInfoType::ALTER_INFO), "ALTER_INFO" },
2585: 		{ static_cast<uint32_t>(ParseInfoType::ATTACH_INFO), "ATTACH_INFO" },
2586: 		{ static_cast<uint32_t>(ParseInfoType::COPY_INFO), "COPY_INFO" },
2587: 		{ static_cast<uint32_t>(ParseInfoType::CREATE_INFO), "CREATE_INFO" },
2588: 		{ static_cast<uint32_t>(ParseInfoType::CREATE_SECRET_INFO), "CREATE_SECRET_INFO" },
2589: 		{ static_cast<uint32_t>(ParseInfoType::DETACH_INFO), "DETACH_INFO" },
2590: 		{ static_cast<uint32_t>(ParseInfoType::DROP_INFO), "DROP_INFO" },
2591: 		{ static_cast<uint32_t>(ParseInfoType::BOUND_EXPORT_DATA), "BOUND_EXPORT_DATA" },
2592: 		{ static_cast<uint32_t>(ParseInfoType::LOAD_INFO), "LOAD_INFO" },
2593: 		{ static_cast<uint32_t>(ParseInfoType::PRAGMA_INFO), "PRAGMA_INFO" },
2594: 		{ static_cast<uint32_t>(ParseInfoType::SHOW_SELECT_INFO), "SHOW_SELECT_INFO" },
2595: 		{ static_cast<uint32_t>(ParseInfoType::TRANSACTION_INFO), "TRANSACTION_INFO" },
2596: 		{ static_cast<uint32_t>(ParseInfoType::VACUUM_INFO), "VACUUM_INFO" },
2597: 		{ static_cast<uint32_t>(ParseInfoType::COMMENT_ON_INFO), "COMMENT_ON_INFO" },
2598: 		{ static_cast<uint32_t>(ParseInfoType::COMMENT_ON_COLUMN_INFO), "COMMENT_ON_COLUMN_INFO" },
2599: 		{ static_cast<uint32_t>(ParseInfoType::COPY_DATABASE_INFO), "COPY_DATABASE_INFO" },
2600: 		{ static_cast<uint32_t>(ParseInfoType::UPDATE_EXTENSIONS_INFO), "UPDATE_EXTENSIONS_INFO" }
2601: 	};
2602: 	return values;
2603: }
2604: 
2605: template<>
2606: const char* EnumUtil::ToChars<ParseInfoType>(ParseInfoType value) {
2607: 	return StringUtil::EnumToString(GetParseInfoTypeValues(), 17, "ParseInfoType", static_cast<uint32_t>(value));
2608: }
2609: 
2610: template<>
2611: ParseInfoType EnumUtil::FromString<ParseInfoType>(const char *value) {
2612: 	return static_cast<ParseInfoType>(StringUtil::StringToEnum(GetParseInfoTypeValues(), 17, "ParseInfoType", value));
2613: }
2614: 
2615: const StringUtil::EnumStringLiteral *GetParserExtensionResultTypeValues() {
2616: 	static constexpr StringUtil::EnumStringLiteral values[] {
2617: 		{ static_cast<uint32_t>(ParserExtensionResultType::PARSE_SUCCESSFUL), "PARSE_SUCCESSFUL" },
2618: 		{ static_cast<uint32_t>(ParserExtensionResultType::DISPLAY_ORIGINAL_ERROR), "DISPLAY_ORIGINAL_ERROR" },
2619: 		{ static_cast<uint32_t>(ParserExtensionResultType::DISPLAY_EXTENSION_ERROR), "DISPLAY_EXTENSION_ERROR" }
2620: 	};
2621: 	return values;
2622: }
2623: 
2624: template<>
2625: const char* EnumUtil::ToChars<ParserExtensionResultType>(ParserExtensionResultType value) {
2626: 	return StringUtil::EnumToString(GetParserExtensionResultTypeValues(), 3, "ParserExtensionResultType", static_cast<uint32_t>(value));
2627: }
2628: 
2629: template<>
2630: ParserExtensionResultType EnumUtil::FromString<ParserExtensionResultType>(const char *value) {
2631: 	return static_cast<ParserExtensionResultType>(StringUtil::StringToEnum(GetParserExtensionResultTypeValues(), 3, "ParserExtensionResultType", value));
2632: }
2633: 
2634: const StringUtil::EnumStringLiteral *GetPartitionSortStageValues() {
2635: 	static constexpr StringUtil::EnumStringLiteral values[] {
2636: 		{ static_cast<uint32_t>(PartitionSortStage::INIT), "INIT" },
2637: 		{ static_cast<uint32_t>(PartitionSortStage::SCAN), "SCAN" },
2638: 		{ static_cast<uint32_t>(PartitionSortStage::PREPARE), "PREPARE" },
2639: 		{ static_cast<uint32_t>(PartitionSortStage::MERGE), "MERGE" },
2640: 		{ static_cast<uint32_t>(PartitionSortStage::SORTED), "SORTED" },
2641: 		{ static_cast<uint32_t>(PartitionSortStage::FINISHED), "FINISHED" }
2642: 	};
2643: 	return values;
2644: }
2645: 
2646: template<>
2647: const char* EnumUtil::ToChars<PartitionSortStage>(PartitionSortStage value) {
2648: 	return StringUtil::EnumToString(GetPartitionSortStageValues(), 6, "PartitionSortStage", static_cast<uint32_t>(value));
2649: }
2650: 
2651: template<>
2652: PartitionSortStage EnumUtil::FromString<PartitionSortStage>(const char *value) {
2653: 	return static_cast<PartitionSortStage>(StringUtil::StringToEnum(GetPartitionSortStageValues(), 6, "PartitionSortStage", value));
2654: }
2655: 
2656: const StringUtil::EnumStringLiteral *GetPartitionedColumnDataTypeValues() {
2657: 	static constexpr StringUtil::EnumStringLiteral values[] {
2658: 		{ static_cast<uint32_t>(PartitionedColumnDataType::INVALID), "INVALID" },
2659: 		{ static_cast<uint32_t>(PartitionedColumnDataType::RADIX), "RADIX" },
2660: 		{ static_cast<uint32_t>(PartitionedColumnDataType::HIVE), "HIVE" }
2661: 	};
2662: 	return values;
2663: }
2664: 
2665: template<>
2666: const char* EnumUtil::ToChars<PartitionedColumnDataType>(PartitionedColumnDataType value) {
2667: 	return StringUtil::EnumToString(GetPartitionedColumnDataTypeValues(), 3, "PartitionedColumnDataType", static_cast<uint32_t>(value));
2668: }
2669: 
2670: template<>
2671: PartitionedColumnDataType EnumUtil::FromString<PartitionedColumnDataType>(const char *value) {
2672: 	return static_cast<PartitionedColumnDataType>(StringUtil::StringToEnum(GetPartitionedColumnDataTypeValues(), 3, "PartitionedColumnDataType", value));
2673: }
2674: 
2675: const StringUtil::EnumStringLiteral *GetPartitionedTupleDataTypeValues() {
2676: 	static constexpr StringUtil::EnumStringLiteral values[] {
2677: 		{ static_cast<uint32_t>(PartitionedTupleDataType::INVALID), "INVALID" },
2678: 		{ static_cast<uint32_t>(PartitionedTupleDataType::RADIX), "RADIX" }
2679: 	};
2680: 	return values;
2681: }
2682: 
2683: template<>
2684: const char* EnumUtil::ToChars<PartitionedTupleDataType>(PartitionedTupleDataType value) {
2685: 	return StringUtil::EnumToString(GetPartitionedTupleDataTypeValues(), 2, "PartitionedTupleDataType", static_cast<uint32_t>(value));
2686: }
2687: 
2688: template<>
2689: PartitionedTupleDataType EnumUtil::FromString<PartitionedTupleDataType>(const char *value) {
2690: 	return static_cast<PartitionedTupleDataType>(StringUtil::StringToEnum(GetPartitionedTupleDataTypeValues(), 2, "PartitionedTupleDataType", value));
2691: }
2692: 
2693: const StringUtil::EnumStringLiteral *GetPendingExecutionResultValues() {
2694: 	static constexpr StringUtil::EnumStringLiteral values[] {
2695: 		{ static_cast<uint32_t>(PendingExecutionResult::RESULT_READY), "RESULT_READY" },
2696: 		{ static_cast<uint32_t>(PendingExecutionResult::RESULT_NOT_READY), "RESULT_NOT_READY" },
2697: 		{ static_cast<uint32_t>(PendingExecutionResult::EXECUTION_ERROR), "EXECUTION_ERROR" },
2698: 		{ static_cast<uint32_t>(PendingExecutionResult::BLOCKED), "BLOCKED" },
2699: 		{ static_cast<uint32_t>(PendingExecutionResult::NO_TASKS_AVAILABLE), "NO_TASKS_AVAILABLE" },
2700: 		{ static_cast<uint32_t>(PendingExecutionResult::EXECUTION_FINISHED), "EXECUTION_FINISHED" }
2701: 	};
2702: 	return values;
2703: }
2704: 
2705: template<>
2706: const char* EnumUtil::ToChars<PendingExecutionResult>(PendingExecutionResult value) {
2707: 	return StringUtil::EnumToString(GetPendingExecutionResultValues(), 6, "PendingExecutionResult", static_cast<uint32_t>(value));
2708: }
2709: 
2710: template<>
2711: PendingExecutionResult EnumUtil::FromString<PendingExecutionResult>(const char *value) {
2712: 	return static_cast<PendingExecutionResult>(StringUtil::StringToEnum(GetPendingExecutionResultValues(), 6, "PendingExecutionResult", value));
2713: }
2714: 
2715: const StringUtil::EnumStringLiteral *GetPhysicalOperatorTypeValues() {
2716: 	static constexpr StringUtil::EnumStringLiteral values[] {
2717: 		{ static_cast<uint32_t>(PhysicalOperatorType::INVALID), "INVALID" },
2718: 		{ static_cast<uint32_t>(PhysicalOperatorType::ORDER_BY), "ORDER_BY" },
2719: 		{ static_cast<uint32_t>(PhysicalOperatorType::LIMIT), "LIMIT" },
2720: 		{ static_cast<uint32_t>(PhysicalOperatorType::STREAMING_LIMIT), "STREAMING_LIMIT" },
2721: 		{ static_cast<uint32_t>(PhysicalOperatorType::LIMIT_PERCENT), "LIMIT_PERCENT" },
2722: 		{ static_cast<uint32_t>(PhysicalOperatorType::TOP_N), "TOP_N" },
2723: 		{ static_cast<uint32_t>(PhysicalOperatorType::WINDOW), "WINDOW" },
2724: 		{ static_cast<uint32_t>(PhysicalOperatorType::UNNEST), "UNNEST" },
2725: 		{ static_cast<uint32_t>(PhysicalOperatorType::UNGROUPED_AGGREGATE), "UNGROUPED_AGGREGATE" },
2726: 		{ static_cast<uint32_t>(PhysicalOperatorType::HASH_GROUP_BY), "HASH_GROUP_BY" },
2727: 		{ static_cast<uint32_t>(PhysicalOperatorType::PERFECT_HASH_GROUP_BY), "PERFECT_HASH_GROUP_BY" },
2728: 		{ static_cast<uint32_t>(PhysicalOperatorType::PARTITIONED_AGGREGATE), "PARTITIONED_AGGREGATE" },
2729: 		{ static_cast<uint32_t>(PhysicalOperatorType::FILTER), "FILTER" },
2730: 		{ static_cast<uint32_t>(PhysicalOperatorType::PROJECTION), "PROJECTION" },
2731: 		{ static_cast<uint32_t>(PhysicalOperatorType::COPY_TO_FILE), "COPY_TO_FILE" },
2732: 		{ static_cast<uint32_t>(PhysicalOperatorType::BATCH_COPY_TO_FILE), "BATCH_COPY_TO_FILE" },
2733: 		{ static_cast<uint32_t>(PhysicalOperatorType::RESERVOIR_SAMPLE), "RESERVOIR_SAMPLE" },
2734: 		{ static_cast<uint32_t>(PhysicalOperatorType::STREAMING_SAMPLE), "STREAMING_SAMPLE" },
2735: 		{ static_cast<uint32_t>(PhysicalOperatorType::STREAMING_WINDOW), "STREAMING_WINDOW" },
2736: 		{ static_cast<uint32_t>(PhysicalOperatorType::PIVOT), "PIVOT" },
2737: 		{ static_cast<uint32_t>(PhysicalOperatorType::COPY_DATABASE), "COPY_DATABASE" },
2738: 		{ static_cast<uint32_t>(PhysicalOperatorType::TABLE_SCAN), "TABLE_SCAN" },
2739: 		{ static_cast<uint32_t>(PhysicalOperatorType::DUMMY_SCAN), "DUMMY_SCAN" },
2740: 		{ static_cast<uint32_t>(PhysicalOperatorType::COLUMN_DATA_SCAN), "COLUMN_DATA_SCAN" },
2741: 		{ static_cast<uint32_t>(PhysicalOperatorType::CHUNK_SCAN), "CHUNK_SCAN" },
2742: 		{ static_cast<uint32_t>(PhysicalOperatorType::RECURSIVE_CTE_SCAN), "RECURSIVE_CTE_SCAN" },
2743: 		{ static_cast<uint32_t>(PhysicalOperatorType::CTE_SCAN), "CTE_SCAN" },
2744: 		{ static_cast<uint32_t>(PhysicalOperatorType::DELIM_SCAN), "DELIM_SCAN" },
2745: 		{ static_cast<uint32_t>(PhysicalOperatorType::EXPRESSION_SCAN), "EXPRESSION_SCAN" },
2746: 		{ static_cast<uint32_t>(PhysicalOperatorType::POSITIONAL_SCAN), "POSITIONAL_SCAN" },
2747: 		{ static_cast<uint32_t>(PhysicalOperatorType::BLOCKWISE_NL_JOIN), "BLOCKWISE_NL_JOIN" },
2748: 		{ static_cast<uint32_t>(PhysicalOperatorType::NESTED_LOOP_JOIN), "NESTED_LOOP_JOIN" },
2749: 		{ static_cast<uint32_t>(PhysicalOperatorType::HASH_JOIN), "HASH_JOIN" },
2750: 		{ static_cast<uint32_t>(PhysicalOperatorType::CROSS_PRODUCT), "CROSS_PRODUCT" },
2751: 		{ static_cast<uint32_t>(PhysicalOperatorType::PIECEWISE_MERGE_JOIN), "PIECEWISE_MERGE_JOIN" },
2752: 		{ static_cast<uint32_t>(PhysicalOperatorType::IE_JOIN), "IE_JOIN" },
2753: 		{ static_cast<uint32_t>(PhysicalOperatorType::LEFT_DELIM_JOIN), "LEFT_DELIM_JOIN" },
2754: 		{ static_cast<uint32_t>(PhysicalOperatorType::RIGHT_DELIM_JOIN), "RIGHT_DELIM_JOIN" },
2755: 		{ static_cast<uint32_t>(PhysicalOperatorType::POSITIONAL_JOIN), "POSITIONAL_JOIN" },
2756: 		{ static_cast<uint32_t>(PhysicalOperatorType::ASOF_JOIN), "ASOF_JOIN" },
2757: 		{ static_cast<uint32_t>(PhysicalOperatorType::UNION), "UNION" },
2758: 		{ static_cast<uint32_t>(PhysicalOperatorType::RECURSIVE_CTE), "RECURSIVE_CTE" },
2759: 		{ static_cast<uint32_t>(PhysicalOperatorType::CTE), "CTE" },
2760: 		{ static_cast<uint32_t>(PhysicalOperatorType::INSERT), "INSERT" },
2761: 		{ static_cast<uint32_t>(PhysicalOperatorType::BATCH_INSERT), "BATCH_INSERT" },
2762: 		{ static_cast<uint32_t>(PhysicalOperatorType::DELETE_OPERATOR), "DELETE_OPERATOR" },
2763: 		{ static_cast<uint32_t>(PhysicalOperatorType::UPDATE), "UPDATE" },
2764: 		{ static_cast<uint32_t>(PhysicalOperatorType::CREATE_TABLE), "CREATE_TABLE" },
2765: 		{ static_cast<uint32_t>(PhysicalOperatorType::CREATE_TABLE_AS), "CREATE_TABLE_AS" },
2766: 		{ static_cast<uint32_t>(PhysicalOperatorType::BATCH_CREATE_TABLE_AS), "BATCH_CREATE_TABLE_AS" },
2767: 		{ static_cast<uint32_t>(PhysicalOperatorType::CREATE_INDEX), "CREATE_INDEX" },
2768: 		{ static_cast<uint32_t>(PhysicalOperatorType::ALTER), "ALTER" },
2769: 		{ static_cast<uint32_t>(PhysicalOperatorType::CREATE_SEQUENCE), "CREATE_SEQUENCE" },
2770: 		{ static_cast<uint32_t>(PhysicalOperatorType::CREATE_VIEW), "CREATE_VIEW" },
2771: 		{ static_cast<uint32_t>(PhysicalOperatorType::CREATE_SCHEMA), "CREATE_SCHEMA" },
2772: 		{ static_cast<uint32_t>(PhysicalOperatorType::CREATE_MACRO), "CREATE_MACRO" },
2773: 		{ static_cast<uint32_t>(PhysicalOperatorType::DROP), "DROP" },
2774: 		{ static_cast<uint32_t>(PhysicalOperatorType::PRAGMA), "PRAGMA" },
2775: 		{ static_cast<uint32_t>(PhysicalOperatorType::TRANSACTION), "TRANSACTION" },
2776: 		{ static_cast<uint32_t>(PhysicalOperatorType::CREATE_TYPE), "CREATE_TYPE" },
2777: 		{ static_cast<uint32_t>(PhysicalOperatorType::ATTACH), "ATTACH" },
2778: 		{ static_cast<uint32_t>(PhysicalOperatorType::DETACH), "DETACH" },
2779: 		{ static_cast<uint32_t>(PhysicalOperatorType::EXPLAIN), "EXPLAIN" },
2780: 		{ static_cast<uint32_t>(PhysicalOperatorType::EXPLAIN_ANALYZE), "EXPLAIN_ANALYZE" },
2781: 		{ static_cast<uint32_t>(PhysicalOperatorType::EMPTY_RESULT), "EMPTY_RESULT" },
2782: 		{ static_cast<uint32_t>(PhysicalOperatorType::EXECUTE), "EXECUTE" },
2783: 		{ static_cast<uint32_t>(PhysicalOperatorType::PREPARE), "PREPARE" },
2784: 		{ static_cast<uint32_t>(PhysicalOperatorType::VACUUM), "VACUUM" },
2785: 		{ static_cast<uint32_t>(PhysicalOperatorType::EXPORT), "EXPORT" },
2786: 		{ static_cast<uint32_t>(PhysicalOperatorType::SET), "SET" },
2787: 		{ static_cast<uint32_t>(PhysicalOperatorType::SET_VARIABLE), "SET_VARIABLE" },
2788: 		{ static_cast<uint32_t>(PhysicalOperatorType::LOAD), "LOAD" },
2789: 		{ static_cast<uint32_t>(PhysicalOperatorType::INOUT_FUNCTION), "INOUT_FUNCTION" },
2790: 		{ static_cast<uint32_t>(PhysicalOperatorType::RESULT_COLLECTOR), "RESULT_COLLECTOR" },
2791: 		{ static_cast<uint32_t>(PhysicalOperatorType::RESET), "RESET" },
2792: 		{ static_cast<uint32_t>(PhysicalOperatorType::EXTENSION), "EXTENSION" },
2793: 		{ static_cast<uint32_t>(PhysicalOperatorType::VERIFY_VECTOR), "VERIFY_VECTOR" },
2794: 		{ static_cast<uint32_t>(PhysicalOperatorType::UPDATE_EXTENSIONS), "UPDATE_EXTENSIONS" },
2795: 		{ static_cast<uint32_t>(PhysicalOperatorType::CREATE_SECRET), "CREATE_SECRET" }
2796: 	};
2797: 	return values;
2798: }
2799: 
2800: template<>
2801: const char* EnumUtil::ToChars<PhysicalOperatorType>(PhysicalOperatorType value) {
2802: 	return StringUtil::EnumToString(GetPhysicalOperatorTypeValues(), 79, "PhysicalOperatorType", static_cast<uint32_t>(value));
2803: }
2804: 
2805: template<>
2806: PhysicalOperatorType EnumUtil::FromString<PhysicalOperatorType>(const char *value) {
2807: 	return static_cast<PhysicalOperatorType>(StringUtil::StringToEnum(GetPhysicalOperatorTypeValues(), 79, "PhysicalOperatorType", value));
2808: }
2809: 
2810: const StringUtil::EnumStringLiteral *GetPhysicalTypeValues() {
2811: 	static constexpr StringUtil::EnumStringLiteral values[] {
2812: 		{ static_cast<uint32_t>(PhysicalType::BOOL), "BOOL" },
2813: 		{ static_cast<uint32_t>(PhysicalType::UINT8), "UINT8" },
2814: 		{ static_cast<uint32_t>(PhysicalType::INT8), "INT8" },
2815: 		{ static_cast<uint32_t>(PhysicalType::UINT16), "UINT16" },
2816: 		{ static_cast<uint32_t>(PhysicalType::INT16), "INT16" },
2817: 		{ static_cast<uint32_t>(PhysicalType::UINT32), "UINT32" },
2818: 		{ static_cast<uint32_t>(PhysicalType::INT32), "INT32" },
2819: 		{ static_cast<uint32_t>(PhysicalType::UINT64), "UINT64" },
2820: 		{ static_cast<uint32_t>(PhysicalType::INT64), "INT64" },
2821: 		{ static_cast<uint32_t>(PhysicalType::FLOAT), "FLOAT" },
2822: 		{ static_cast<uint32_t>(PhysicalType::DOUBLE), "DOUBLE" },
2823: 		{ static_cast<uint32_t>(PhysicalType::INTERVAL), "INTERVAL" },
2824: 		{ static_cast<uint32_t>(PhysicalType::LIST), "LIST" },
2825: 		{ static_cast<uint32_t>(PhysicalType::STRUCT), "STRUCT" },
2826: 		{ static_cast<uint32_t>(PhysicalType::ARRAY), "ARRAY" },
2827: 		{ static_cast<uint32_t>(PhysicalType::VARCHAR), "VARCHAR" },
2828: 		{ static_cast<uint32_t>(PhysicalType::UINT128), "UINT128" },
2829: 		{ static_cast<uint32_t>(PhysicalType::INT128), "INT128" },
2830: 		{ static_cast<uint32_t>(PhysicalType::UNKNOWN), "UNKNOWN" },
2831: 		{ static_cast<uint32_t>(PhysicalType::BIT), "BIT" },
2832: 		{ static_cast<uint32_t>(PhysicalType::INVALID), "INVALID" }
2833: 	};
2834: 	return values;
2835: }
2836: 
2837: template<>
2838: const char* EnumUtil::ToChars<PhysicalType>(PhysicalType value) {
2839: 	return StringUtil::EnumToString(GetPhysicalTypeValues(), 21, "PhysicalType", static_cast<uint32_t>(value));
2840: }
2841: 
2842: template<>
2843: PhysicalType EnumUtil::FromString<PhysicalType>(const char *value) {
2844: 	return static_cast<PhysicalType>(StringUtil::StringToEnum(GetPhysicalTypeValues(), 21, "PhysicalType", value));
2845: }
2846: 
2847: const StringUtil::EnumStringLiteral *GetPragmaTypeValues() {
2848: 	static constexpr StringUtil::EnumStringLiteral values[] {
2849: 		{ static_cast<uint32_t>(PragmaType::PRAGMA_STATEMENT), "PRAGMA_STATEMENT" },
2850: 		{ static_cast<uint32_t>(PragmaType::PRAGMA_CALL), "PRAGMA_CALL" }
2851: 	};
2852: 	return values;
2853: }
2854: 
2855: template<>
2856: const char* EnumUtil::ToChars<PragmaType>(PragmaType value) {
2857: 	return StringUtil::EnumToString(GetPragmaTypeValues(), 2, "PragmaType", static_cast<uint32_t>(value));
2858: }
2859: 
2860: template<>
2861: PragmaType EnumUtil::FromString<PragmaType>(const char *value) {
2862: 	return static_cast<PragmaType>(StringUtil::StringToEnum(GetPragmaTypeValues(), 2, "PragmaType", value));
2863: }
2864: 
2865: const StringUtil::EnumStringLiteral *GetPreparedParamTypeValues() {
2866: 	static constexpr StringUtil::EnumStringLiteral values[] {
2867: 		{ static_cast<uint32_t>(PreparedParamType::AUTO_INCREMENT), "AUTO_INCREMENT" },
2868: 		{ static_cast<uint32_t>(PreparedParamType::POSITIONAL), "POSITIONAL" },
2869: 		{ static_cast<uint32_t>(PreparedParamType::NAMED), "NAMED" },
2870: 		{ static_cast<uint32_t>(PreparedParamType::INVALID), "INVALID" }
2871: 	};
2872: 	return values;
2873: }
2874: 
2875: template<>
2876: const char* EnumUtil::ToChars<PreparedParamType>(PreparedParamType value) {
2877: 	return StringUtil::EnumToString(GetPreparedParamTypeValues(), 4, "PreparedParamType", static_cast<uint32_t>(value));
2878: }
2879: 
2880: template<>
2881: PreparedParamType EnumUtil::FromString<PreparedParamType>(const char *value) {
2882: 	return static_cast<PreparedParamType>(StringUtil::StringToEnum(GetPreparedParamTypeValues(), 4, "PreparedParamType", value));
2883: }
2884: 
2885: const StringUtil::EnumStringLiteral *GetPreparedStatementModeValues() {
2886: 	static constexpr StringUtil::EnumStringLiteral values[] {
2887: 		{ static_cast<uint32_t>(PreparedStatementMode::PREPARE_ONLY), "PREPARE_ONLY" },
2888: 		{ static_cast<uint32_t>(PreparedStatementMode::PREPARE_AND_EXECUTE), "PREPARE_AND_EXECUTE" }
2889: 	};
2890: 	return values;
2891: }
2892: 
2893: template<>
2894: const char* EnumUtil::ToChars<PreparedStatementMode>(PreparedStatementMode value) {
2895: 	return StringUtil::EnumToString(GetPreparedStatementModeValues(), 2, "PreparedStatementMode", static_cast<uint32_t>(value));
2896: }
2897: 
2898: template<>
2899: PreparedStatementMode EnumUtil::FromString<PreparedStatementMode>(const char *value) {
2900: 	return static_cast<PreparedStatementMode>(StringUtil::StringToEnum(GetPreparedStatementModeValues(), 2, "PreparedStatementMode", value));
2901: }
2902: 
2903: const StringUtil::EnumStringLiteral *GetProfilerPrintFormatValues() {
2904: 	static constexpr StringUtil::EnumStringLiteral values[] {
2905: 		{ static_cast<uint32_t>(ProfilerPrintFormat::QUERY_TREE), "QUERY_TREE" },
2906: 		{ static_cast<uint32_t>(ProfilerPrintFormat::JSON), "JSON" },
2907: 		{ static_cast<uint32_t>(ProfilerPrintFormat::QUERY_TREE_OPTIMIZER), "QUERY_TREE_OPTIMIZER" },
2908: 		{ static_cast<uint32_t>(ProfilerPrintFormat::NO_OUTPUT), "NO_OUTPUT" },
2909: 		{ static_cast<uint32_t>(ProfilerPrintFormat::HTML), "HTML" },
2910: 		{ static_cast<uint32_t>(ProfilerPrintFormat::GRAPHVIZ), "GRAPHVIZ" }
2911: 	};
2912: 	return values;
2913: }
2914: 
2915: template<>
2916: const char* EnumUtil::ToChars<ProfilerPrintFormat>(ProfilerPrintFormat value) {
2917: 	return StringUtil::EnumToString(GetProfilerPrintFormatValues(), 6, "ProfilerPrintFormat", static_cast<uint32_t>(value));
2918: }
2919: 
2920: template<>
2921: ProfilerPrintFormat EnumUtil::FromString<ProfilerPrintFormat>(const char *value) {
2922: 	return static_cast<ProfilerPrintFormat>(StringUtil::StringToEnum(GetProfilerPrintFormatValues(), 6, "ProfilerPrintFormat", value));
2923: }
2924: 
2925: const StringUtil::EnumStringLiteral *GetQuantileSerializationTypeValues() {
2926: 	static constexpr StringUtil::EnumStringLiteral values[] {
2927: 		{ static_cast<uint32_t>(QuantileSerializationType::NON_DECIMAL), "NON_DECIMAL" },
2928: 		{ static_cast<uint32_t>(QuantileSerializationType::DECIMAL_DISCRETE), "DECIMAL_DISCRETE" },
2929: 		{ static_cast<uint32_t>(QuantileSerializationType::DECIMAL_DISCRETE_LIST), "DECIMAL_DISCRETE_LIST" },
2930: 		{ static_cast<uint32_t>(QuantileSerializationType::DECIMAL_CONTINUOUS), "DECIMAL_CONTINUOUS" },
2931: 		{ static_cast<uint32_t>(QuantileSerializationType::DECIMAL_CONTINUOUS_LIST), "DECIMAL_CONTINUOUS_LIST" }
2932: 	};
2933: 	return values;
2934: }
2935: 
2936: template<>
2937: const char* EnumUtil::ToChars<QuantileSerializationType>(QuantileSerializationType value) {
2938: 	return StringUtil::EnumToString(GetQuantileSerializationTypeValues(), 5, "QuantileSerializationType", static_cast<uint32_t>(value));
2939: }
2940: 
2941: template<>
2942: QuantileSerializationType EnumUtil::FromString<QuantileSerializationType>(const char *value) {
2943: 	return static_cast<QuantileSerializationType>(StringUtil::StringToEnum(GetQuantileSerializationTypeValues(), 5, "QuantileSerializationType", value));
2944: }
2945: 
2946: const StringUtil::EnumStringLiteral *GetQueryNodeTypeValues() {
2947: 	static constexpr StringUtil::EnumStringLiteral values[] {
2948: 		{ static_cast<uint32_t>(QueryNodeType::SELECT_NODE), "SELECT_NODE" },
2949: 		{ static_cast<uint32_t>(QueryNodeType::SET_OPERATION_NODE), "SET_OPERATION_NODE" },
2950: 		{ static_cast<uint32_t>(QueryNodeType::BOUND_SUBQUERY_NODE), "BOUND_SUBQUERY_NODE" },
2951: 		{ static_cast<uint32_t>(QueryNodeType::RECURSIVE_CTE_NODE), "RECURSIVE_CTE_NODE" },
2952: 		{ static_cast<uint32_t>(QueryNodeType::CTE_NODE), "CTE_NODE" }
2953: 	};
2954: 	return values;
2955: }
2956: 
2957: template<>
2958: const char* EnumUtil::ToChars<QueryNodeType>(QueryNodeType value) {
2959: 	return StringUtil::EnumToString(GetQueryNodeTypeValues(), 5, "QueryNodeType", static_cast<uint32_t>(value));
2960: }
2961: 
2962: template<>
2963: QueryNodeType EnumUtil::FromString<QueryNodeType>(const char *value) {
2964: 	return static_cast<QueryNodeType>(StringUtil::StringToEnum(GetQueryNodeTypeValues(), 5, "QueryNodeType", value));
2965: }
2966: 
2967: const StringUtil::EnumStringLiteral *GetQueryResultTypeValues() {
2968: 	static constexpr StringUtil::EnumStringLiteral values[] {
2969: 		{ static_cast<uint32_t>(QueryResultType::MATERIALIZED_RESULT), "MATERIALIZED_RESULT" },
2970: 		{ static_cast<uint32_t>(QueryResultType::STREAM_RESULT), "STREAM_RESULT" },
2971: 		{ static_cast<uint32_t>(QueryResultType::PENDING_RESULT), "PENDING_RESULT" },
2972: 		{ static_cast<uint32_t>(QueryResultType::ARROW_RESULT), "ARROW_RESULT" }
2973: 	};
2974: 	return values;
2975: }
2976: 
2977: template<>
2978: const char* EnumUtil::ToChars<QueryResultType>(QueryResultType value) {
2979: 	return StringUtil::EnumToString(GetQueryResultTypeValues(), 4, "QueryResultType", static_cast<uint32_t>(value));
2980: }
2981: 
2982: template<>
2983: QueryResultType EnumUtil::FromString<QueryResultType>(const char *value) {
2984: 	return static_cast<QueryResultType>(StringUtil::StringToEnum(GetQueryResultTypeValues(), 4, "QueryResultType", value));
2985: }
2986: 
2987: const StringUtil::EnumStringLiteral *GetQuoteRuleValues() {
2988: 	static constexpr StringUtil::EnumStringLiteral values[] {
2989: 		{ static_cast<uint32_t>(QuoteRule::QUOTES_RFC), "QUOTES_RFC" },
2990: 		{ static_cast<uint32_t>(QuoteRule::QUOTES_OTHER), "QUOTES_OTHER" },
2991: 		{ static_cast<uint32_t>(QuoteRule::NO_QUOTES), "NO_QUOTES" }
2992: 	};
2993: 	return values;
2994: }
2995: 
2996: template<>
2997: const char* EnumUtil::ToChars<QuoteRule>(QuoteRule value) {
2998: 	return StringUtil::EnumToString(GetQuoteRuleValues(), 3, "QuoteRule", static_cast<uint32_t>(value));
2999: }
3000: 
3001: template<>
3002: QuoteRule EnumUtil::FromString<QuoteRule>(const char *value) {
3003: 	return static_cast<QuoteRule>(StringUtil::StringToEnum(GetQuoteRuleValues(), 3, "QuoteRule", value));
3004: }
3005: 
3006: const StringUtil::EnumStringLiteral *GetRelationTypeValues() {
3007: 	static constexpr StringUtil::EnumStringLiteral values[] {
3008: 		{ static_cast<uint32_t>(RelationType::INVALID_RELATION), "INVALID_RELATION" },
3009: 		{ static_cast<uint32_t>(RelationType::TABLE_RELATION), "TABLE_RELATION" },
3010: 		{ static_cast<uint32_t>(RelationType::PROJECTION_RELATION), "PROJECTION_RELATION" },
3011: 		{ static_cast<uint32_t>(RelationType::FILTER_RELATION), "FILTER_RELATION" },
3012: 		{ static_cast<uint32_t>(RelationType::EXPLAIN_RELATION), "EXPLAIN_RELATION" },
3013: 		{ static_cast<uint32_t>(RelationType::CROSS_PRODUCT_RELATION), "CROSS_PRODUCT_RELATION" },
3014: 		{ static_cast<uint32_t>(RelationType::JOIN_RELATION), "JOIN_RELATION" },
3015: 		{ static_cast<uint32_t>(RelationType::AGGREGATE_RELATION), "AGGREGATE_RELATION" },
3016: 		{ static_cast<uint32_t>(RelationType::SET_OPERATION_RELATION), "SET_OPERATION_RELATION" },
3017: 		{ static_cast<uint32_t>(RelationType::DISTINCT_RELATION), "DISTINCT_RELATION" },
3018: 		{ static_cast<uint32_t>(RelationType::LIMIT_RELATION), "LIMIT_RELATION" },
3019: 		{ static_cast<uint32_t>(RelationType::ORDER_RELATION), "ORDER_RELATION" },
3020: 		{ static_cast<uint32_t>(RelationType::CREATE_VIEW_RELATION), "CREATE_VIEW_RELATION" },
3021: 		{ static_cast<uint32_t>(RelationType::CREATE_TABLE_RELATION), "CREATE_TABLE_RELATION" },
3022: 		{ static_cast<uint32_t>(RelationType::INSERT_RELATION), "INSERT_RELATION" },
3023: 		{ static_cast<uint32_t>(RelationType::VALUE_LIST_RELATION), "VALUE_LIST_RELATION" },
3024: 		{ static_cast<uint32_t>(RelationType::MATERIALIZED_RELATION), "MATERIALIZED_RELATION" },
3025: 		{ static_cast<uint32_t>(RelationType::DELETE_RELATION), "DELETE_RELATION" },
3026: 		{ static_cast<uint32_t>(RelationType::UPDATE_RELATION), "UPDATE_RELATION" },
3027: 		{ static_cast<uint32_t>(RelationType::WRITE_CSV_RELATION), "WRITE_CSV_RELATION" },
3028: 		{ static_cast<uint32_t>(RelationType::WRITE_PARQUET_RELATION), "WRITE_PARQUET_RELATION" },
3029: 		{ static_cast<uint32_t>(RelationType::READ_CSV_RELATION), "READ_CSV_RELATION" },
3030: 		{ static_cast<uint32_t>(RelationType::SUBQUERY_RELATION), "SUBQUERY_RELATION" },
3031: 		{ static_cast<uint32_t>(RelationType::TABLE_FUNCTION_RELATION), "TABLE_FUNCTION_RELATION" },
3032: 		{ static_cast<uint32_t>(RelationType::VIEW_RELATION), "VIEW_RELATION" },
3033: 		{ static_cast<uint32_t>(RelationType::QUERY_RELATION), "QUERY_RELATION" },
3034: 		{ static_cast<uint32_t>(RelationType::DELIM_JOIN_RELATION), "DELIM_JOIN_RELATION" },
3035: 		{ static_cast<uint32_t>(RelationType::DELIM_GET_RELATION), "DELIM_GET_RELATION" }
3036: 	};
3037: 	return values;
3038: }
3039: 
3040: template<>
3041: const char* EnumUtil::ToChars<RelationType>(RelationType value) {
3042: 	return StringUtil::EnumToString(GetRelationTypeValues(), 28, "RelationType", static_cast<uint32_t>(value));
3043: }
3044: 
3045: template<>
3046: RelationType EnumUtil::FromString<RelationType>(const char *value) {
3047: 	return static_cast<RelationType>(StringUtil::StringToEnum(GetRelationTypeValues(), 28, "RelationType", value));
3048: }
3049: 
3050: const StringUtil::EnumStringLiteral *GetRenderModeValues() {
3051: 	static constexpr StringUtil::EnumStringLiteral values[] {
3052: 		{ static_cast<uint32_t>(RenderMode::ROWS), "ROWS" },
3053: 		{ static_cast<uint32_t>(RenderMode::COLUMNS), "COLUMNS" }
3054: 	};
3055: 	return values;
3056: }
3057: 
3058: template<>
3059: const char* EnumUtil::ToChars<RenderMode>(RenderMode value) {
3060: 	return StringUtil::EnumToString(GetRenderModeValues(), 2, "RenderMode", static_cast<uint32_t>(value));
3061: }
3062: 
3063: template<>
3064: RenderMode EnumUtil::FromString<RenderMode>(const char *value) {
3065: 	return static_cast<RenderMode>(StringUtil::StringToEnum(GetRenderModeValues(), 2, "RenderMode", value));
3066: }
3067: 
3068: const StringUtil::EnumStringLiteral *GetResultModifierTypeValues() {
3069: 	static constexpr StringUtil::EnumStringLiteral values[] {
3070: 		{ static_cast<uint32_t>(ResultModifierType::LIMIT_MODIFIER), "LIMIT_MODIFIER" },
3071: 		{ static_cast<uint32_t>(ResultModifierType::ORDER_MODIFIER), "ORDER_MODIFIER" },
3072: 		{ static_cast<uint32_t>(ResultModifierType::DISTINCT_MODIFIER), "DISTINCT_MODIFIER" },
3073: 		{ static_cast<uint32_t>(ResultModifierType::LIMIT_PERCENT_MODIFIER), "LIMIT_PERCENT_MODIFIER" }
3074: 	};
3075: 	return values;
3076: }
3077: 
3078: template<>
3079: const char* EnumUtil::ToChars<ResultModifierType>(ResultModifierType value) {
3080: 	return StringUtil::EnumToString(GetResultModifierTypeValues(), 4, "ResultModifierType", static_cast<uint32_t>(value));
3081: }
3082: 
3083: template<>
3084: ResultModifierType EnumUtil::FromString<ResultModifierType>(const char *value) {
3085: 	return static_cast<ResultModifierType>(StringUtil::StringToEnum(GetResultModifierTypeValues(), 4, "ResultModifierType", value));
3086: }
3087: 
3088: const StringUtil::EnumStringLiteral *GetSampleMethodValues() {
3089: 	static constexpr StringUtil::EnumStringLiteral values[] {
3090: 		{ static_cast<uint32_t>(SampleMethod::SYSTEM_SAMPLE), "System" },
3091: 		{ static_cast<uint32_t>(SampleMethod::BERNOULLI_SAMPLE), "Bernoulli" },
3092: 		{ static_cast<uint32_t>(SampleMethod::RESERVOIR_SAMPLE), "Reservoir" },
3093: 		{ static_cast<uint32_t>(SampleMethod::INVALID), "INVALID" }
3094: 	};
3095: 	return values;
3096: }
3097: 
3098: template<>
3099: const char* EnumUtil::ToChars<SampleMethod>(SampleMethod value) {
3100: 	return StringUtil::EnumToString(GetSampleMethodValues(), 4, "SampleMethod", static_cast<uint32_t>(value));
3101: }
3102: 
3103: template<>
3104: SampleMethod EnumUtil::FromString<SampleMethod>(const char *value) {
3105: 	return static_cast<SampleMethod>(StringUtil::StringToEnum(GetSampleMethodValues(), 4, "SampleMethod", value));
3106: }
3107: 
3108: const StringUtil::EnumStringLiteral *GetSampleTypeValues() {
3109: 	static constexpr StringUtil::EnumStringLiteral values[] {
3110: 		{ static_cast<uint32_t>(SampleType::BLOCKING_SAMPLE), "BLOCKING_SAMPLE" },
3111: 		{ static_cast<uint32_t>(SampleType::RESERVOIR_SAMPLE), "RESERVOIR_SAMPLE" },
3112: 		{ static_cast<uint32_t>(SampleType::RESERVOIR_PERCENTAGE_SAMPLE), "RESERVOIR_PERCENTAGE_SAMPLE" }
3113: 	};
3114: 	return values;
3115: }
3116: 
3117: template<>
3118: const char* EnumUtil::ToChars<SampleType>(SampleType value) {
3119: 	return StringUtil::EnumToString(GetSampleTypeValues(), 3, "SampleType", static_cast<uint32_t>(value));
3120: }
3121: 
3122: template<>
3123: SampleType EnumUtil::FromString<SampleType>(const char *value) {
3124: 	return static_cast<SampleType>(StringUtil::StringToEnum(GetSampleTypeValues(), 3, "SampleType", value));
3125: }
3126: 
3127: const StringUtil::EnumStringLiteral *GetScanTypeValues() {
3128: 	static constexpr StringUtil::EnumStringLiteral values[] {
3129: 		{ static_cast<uint32_t>(ScanType::TABLE), "TABLE" },
3130: 		{ static_cast<uint32_t>(ScanType::PARQUET), "PARQUET" },
3131: 		{ static_cast<uint32_t>(ScanType::EXTERNAL), "EXTERNAL" }
3132: 	};
3133: 	return values;
3134: }
3135: 
3136: template<>
3137: const char* EnumUtil::ToChars<ScanType>(ScanType value) {
3138: 	return StringUtil::EnumToString(GetScanTypeValues(), 3, "ScanType", static_cast<uint32_t>(value));
3139: }
3140: 
3141: template<>
3142: ScanType EnumUtil::FromString<ScanType>(const char *value) {
3143: 	return static_cast<ScanType>(StringUtil::StringToEnum(GetScanTypeValues(), 3, "ScanType", value));
3144: }
3145: 
3146: const StringUtil::EnumStringLiteral *GetSecretDisplayTypeValues() {
3147: 	static constexpr StringUtil::EnumStringLiteral values[] {
3148: 		{ static_cast<uint32_t>(SecretDisplayType::REDACTED), "REDACTED" },
3149: 		{ static_cast<uint32_t>(SecretDisplayType::UNREDACTED), "UNREDACTED" }
3150: 	};
3151: 	return values;
3152: }
3153: 
3154: template<>
3155: const char* EnumUtil::ToChars<SecretDisplayType>(SecretDisplayType value) {
3156: 	return StringUtil::EnumToString(GetSecretDisplayTypeValues(), 2, "SecretDisplayType", static_cast<uint32_t>(value));
3157: }
3158: 
3159: template<>
3160: SecretDisplayType EnumUtil::FromString<SecretDisplayType>(const char *value) {
3161: 	return static_cast<SecretDisplayType>(StringUtil::StringToEnum(GetSecretDisplayTypeValues(), 2, "SecretDisplayType", value));
3162: }
3163: 
3164: const StringUtil::EnumStringLiteral *GetSecretPersistTypeValues() {
3165: 	static constexpr StringUtil::EnumStringLiteral values[] {
3166: 		{ static_cast<uint32_t>(SecretPersistType::DEFAULT), "DEFAULT" },
3167: 		{ static_cast<uint32_t>(SecretPersistType::TEMPORARY), "TEMPORARY" },
3168: 		{ static_cast<uint32_t>(SecretPersistType::PERSISTENT), "PERSISTENT" }
3169: 	};
3170: 	return values;
3171: }
3172: 
3173: template<>
3174: const char* EnumUtil::ToChars<SecretPersistType>(SecretPersistType value) {
3175: 	return StringUtil::EnumToString(GetSecretPersistTypeValues(), 3, "SecretPersistType", static_cast<uint32_t>(value));
3176: }
3177: 
3178: template<>
3179: SecretPersistType EnumUtil::FromString<SecretPersistType>(const char *value) {
3180: 	return static_cast<SecretPersistType>(StringUtil::StringToEnum(GetSecretPersistTypeValues(), 3, "SecretPersistType", value));
3181: }
3182: 
3183: const StringUtil::EnumStringLiteral *GetSecretSerializationTypeValues() {
3184: 	static constexpr StringUtil::EnumStringLiteral values[] {
3185: 		{ static_cast<uint32_t>(SecretSerializationType::CUSTOM), "CUSTOM" },
3186: 		{ static_cast<uint32_t>(SecretSerializationType::KEY_VALUE_SECRET), "KEY_VALUE_SECRET" }
3187: 	};
3188: 	return values;
3189: }
3190: 
3191: template<>
3192: const char* EnumUtil::ToChars<SecretSerializationType>(SecretSerializationType value) {
3193: 	return StringUtil::EnumToString(GetSecretSerializationTypeValues(), 2, "SecretSerializationType", static_cast<uint32_t>(value));
3194: }
3195: 
3196: template<>
3197: SecretSerializationType EnumUtil::FromString<SecretSerializationType>(const char *value) {
3198: 	return static_cast<SecretSerializationType>(StringUtil::StringToEnum(GetSecretSerializationTypeValues(), 2, "SecretSerializationType", value));
3199: }
3200: 
3201: const StringUtil::EnumStringLiteral *GetSequenceInfoValues() {
3202: 	static constexpr StringUtil::EnumStringLiteral values[] {
3203: 		{ static_cast<uint32_t>(SequenceInfo::SEQ_START), "SEQ_START" },
3204: 		{ static_cast<uint32_t>(SequenceInfo::SEQ_INC), "SEQ_INC" },
3205: 		{ static_cast<uint32_t>(SequenceInfo::SEQ_MIN), "SEQ_MIN" },
3206: 		{ static_cast<uint32_t>(SequenceInfo::SEQ_MAX), "SEQ_MAX" },
3207: 		{ static_cast<uint32_t>(SequenceInfo::SEQ_CYCLE), "SEQ_CYCLE" },
3208: 		{ static_cast<uint32_t>(SequenceInfo::SEQ_OWN), "SEQ_OWN" }
3209: 	};
3210: 	return values;
3211: }
3212: 
3213: template<>
3214: const char* EnumUtil::ToChars<SequenceInfo>(SequenceInfo value) {
3215: 	return StringUtil::EnumToString(GetSequenceInfoValues(), 6, "SequenceInfo", static_cast<uint32_t>(value));
3216: }
3217: 
3218: template<>
3219: SequenceInfo EnumUtil::FromString<SequenceInfo>(const char *value) {
3220: 	return static_cast<SequenceInfo>(StringUtil::StringToEnum(GetSequenceInfoValues(), 6, "SequenceInfo", value));
3221: }
3222: 
3223: const StringUtil::EnumStringLiteral *GetSetOperationTypeValues() {
3224: 	static constexpr StringUtil::EnumStringLiteral values[] {
3225: 		{ static_cast<uint32_t>(SetOperationType::NONE), "NONE" },
3226: 		{ static_cast<uint32_t>(SetOperationType::UNION), "UNION" },
3227: 		{ static_cast<uint32_t>(SetOperationType::EXCEPT), "EXCEPT" },
3228: 		{ static_cast<uint32_t>(SetOperationType::INTERSECT), "INTERSECT" },
3229: 		{ static_cast<uint32_t>(SetOperationType::UNION_BY_NAME), "UNION_BY_NAME" }
3230: 	};
3231: 	return values;
3232: }
3233: 
3234: template<>
3235: const char* EnumUtil::ToChars<SetOperationType>(SetOperationType value) {
3236: 	return StringUtil::EnumToString(GetSetOperationTypeValues(), 5, "SetOperationType", static_cast<uint32_t>(value));
3237: }
3238: 
3239: template<>
3240: SetOperationType EnumUtil::FromString<SetOperationType>(const char *value) {
3241: 	return static_cast<SetOperationType>(StringUtil::StringToEnum(GetSetOperationTypeValues(), 5, "SetOperationType", value));
3242: }
3243: 
3244: const StringUtil::EnumStringLiteral *GetSetScopeValues() {
3245: 	static constexpr StringUtil::EnumStringLiteral values[] {
3246: 		{ static_cast<uint32_t>(SetScope::AUTOMATIC), "AUTOMATIC" },
3247: 		{ static_cast<uint32_t>(SetScope::LOCAL), "LOCAL" },
3248: 		{ static_cast<uint32_t>(SetScope::SESSION), "SESSION" },
3249: 		{ static_cast<uint32_t>(SetScope::GLOBAL), "GLOBAL" },
3250: 		{ static_cast<uint32_t>(SetScope::VARIABLE), "VARIABLE" }
3251: 	};
3252: 	return values;
3253: }
3254: 
3255: template<>
3256: const char* EnumUtil::ToChars<SetScope>(SetScope value) {
3257: 	return StringUtil::EnumToString(GetSetScopeValues(), 5, "SetScope", static_cast<uint32_t>(value));
3258: }
3259: 
3260: template<>
3261: SetScope EnumUtil::FromString<SetScope>(const char *value) {
3262: 	return static_cast<SetScope>(StringUtil::StringToEnum(GetSetScopeValues(), 5, "SetScope", value));
3263: }
3264: 
3265: const StringUtil::EnumStringLiteral *GetSetTypeValues() {
3266: 	static constexpr StringUtil::EnumStringLiteral values[] {
3267: 		{ static_cast<uint32_t>(SetType::SET), "SET" },
3268: 		{ static_cast<uint32_t>(SetType::RESET), "RESET" }
3269: 	};
3270: 	return values;
3271: }
3272: 
3273: template<>
3274: const char* EnumUtil::ToChars<SetType>(SetType value) {
3275: 	return StringUtil::EnumToString(GetSetTypeValues(), 2, "SetType", static_cast<uint32_t>(value));
3276: }
3277: 
3278: template<>
3279: SetType EnumUtil::FromString<SetType>(const char *value) {
3280: 	return static_cast<SetType>(StringUtil::StringToEnum(GetSetTypeValues(), 2, "SetType", value));
3281: }
3282: 
3283: const StringUtil::EnumStringLiteral *GetSettingScopeValues() {
3284: 	static constexpr StringUtil::EnumStringLiteral values[] {
3285: 		{ static_cast<uint32_t>(SettingScope::GLOBAL), "GLOBAL" },
3286: 		{ static_cast<uint32_t>(SettingScope::LOCAL), "LOCAL" },
3287: 		{ static_cast<uint32_t>(SettingScope::SECRET), "SECRET" },
3288: 		{ static_cast<uint32_t>(SettingScope::INVALID), "INVALID" }
3289: 	};
3290: 	return values;
3291: }
3292: 
3293: template<>
3294: const char* EnumUtil::ToChars<SettingScope>(SettingScope value) {
3295: 	return StringUtil::EnumToString(GetSettingScopeValues(), 4, "SettingScope", static_cast<uint32_t>(value));
3296: }
3297: 
3298: template<>
3299: SettingScope EnumUtil::FromString<SettingScope>(const char *value) {
3300: 	return static_cast<SettingScope>(StringUtil::StringToEnum(GetSettingScopeValues(), 4, "SettingScope", value));
3301: }
3302: 
3303: const StringUtil::EnumStringLiteral *GetShowTypeValues() {
3304: 	static constexpr StringUtil::EnumStringLiteral values[] {
3305: 		{ static_cast<uint32_t>(ShowType::SUMMARY), "SUMMARY" },
3306: 		{ static_cast<uint32_t>(ShowType::DESCRIBE), "DESCRIBE" }
3307: 	};
3308: 	return values;
3309: }
3310: 
3311: template<>
3312: const char* EnumUtil::ToChars<ShowType>(ShowType value) {
3313: 	return StringUtil::EnumToString(GetShowTypeValues(), 2, "ShowType", static_cast<uint32_t>(value));
3314: }
3315: 
3316: template<>
3317: ShowType EnumUtil::FromString<ShowType>(const char *value) {
3318: 	return static_cast<ShowType>(StringUtil::StringToEnum(GetShowTypeValues(), 2, "ShowType", value));
3319: }
3320: 
3321: const StringUtil::EnumStringLiteral *GetSimplifiedTokenTypeValues() {
3322: 	static constexpr StringUtil::EnumStringLiteral values[] {
3323: 		{ static_cast<uint32_t>(SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER), "SIMPLIFIED_TOKEN_IDENTIFIER" },
3324: 		{ static_cast<uint32_t>(SimplifiedTokenType::SIMPLIFIED_TOKEN_NUMERIC_CONSTANT), "SIMPLIFIED_TOKEN_NUMERIC_CONSTANT" },
3325: 		{ static_cast<uint32_t>(SimplifiedTokenType::SIMPLIFIED_TOKEN_STRING_CONSTANT), "SIMPLIFIED_TOKEN_STRING_CONSTANT" },
3326: 		{ static_cast<uint32_t>(SimplifiedTokenType::SIMPLIFIED_TOKEN_OPERATOR), "SIMPLIFIED_TOKEN_OPERATOR" },
3327: 		{ static_cast<uint32_t>(SimplifiedTokenType::SIMPLIFIED_TOKEN_KEYWORD), "SIMPLIFIED_TOKEN_KEYWORD" },
3328: 		{ static_cast<uint32_t>(SimplifiedTokenType::SIMPLIFIED_TOKEN_COMMENT), "SIMPLIFIED_TOKEN_COMMENT" },
3329: 		{ static_cast<uint32_t>(SimplifiedTokenType::SIMPLIFIED_TOKEN_ERROR), "SIMPLIFIED_TOKEN_ERROR" }
3330: 	};
3331: 	return values;
3332: }
3333: 
3334: template<>
3335: const char* EnumUtil::ToChars<SimplifiedTokenType>(SimplifiedTokenType value) {
3336: 	return StringUtil::EnumToString(GetSimplifiedTokenTypeValues(), 7, "SimplifiedTokenType", static_cast<uint32_t>(value));
3337: }
3338: 
3339: template<>
3340: SimplifiedTokenType EnumUtil::FromString<SimplifiedTokenType>(const char *value) {
3341: 	return static_cast<SimplifiedTokenType>(StringUtil::StringToEnum(GetSimplifiedTokenTypeValues(), 7, "SimplifiedTokenType", value));
3342: }
3343: 
3344: const StringUtil::EnumStringLiteral *GetSinkCombineResultTypeValues() {
3345: 	static constexpr StringUtil::EnumStringLiteral values[] {
3346: 		{ static_cast<uint32_t>(SinkCombineResultType::FINISHED), "FINISHED" },
3347: 		{ static_cast<uint32_t>(SinkCombineResultType::BLOCKED), "BLOCKED" }
3348: 	};
3349: 	return values;
3350: }
3351: 
3352: template<>
3353: const char* EnumUtil::ToChars<SinkCombineResultType>(SinkCombineResultType value) {
3354: 	return StringUtil::EnumToString(GetSinkCombineResultTypeValues(), 2, "SinkCombineResultType", static_cast<uint32_t>(value));
3355: }
3356: 
3357: template<>
3358: SinkCombineResultType EnumUtil::FromString<SinkCombineResultType>(const char *value) {
3359: 	return static_cast<SinkCombineResultType>(StringUtil::StringToEnum(GetSinkCombineResultTypeValues(), 2, "SinkCombineResultType", value));
3360: }
3361: 
3362: const StringUtil::EnumStringLiteral *GetSinkFinalizeTypeValues() {
3363: 	static constexpr StringUtil::EnumStringLiteral values[] {
3364: 		{ static_cast<uint32_t>(SinkFinalizeType::READY), "READY" },
3365: 		{ static_cast<uint32_t>(SinkFinalizeType::NO_OUTPUT_POSSIBLE), "NO_OUTPUT_POSSIBLE" },
3366: 		{ static_cast<uint32_t>(SinkFinalizeType::BLOCKED), "BLOCKED" }
3367: 	};
3368: 	return values;
3369: }
3370: 
3371: template<>
3372: const char* EnumUtil::ToChars<SinkFinalizeType>(SinkFinalizeType value) {
3373: 	return StringUtil::EnumToString(GetSinkFinalizeTypeValues(), 3, "SinkFinalizeType", static_cast<uint32_t>(value));
3374: }
3375: 
3376: template<>
3377: SinkFinalizeType EnumUtil::FromString<SinkFinalizeType>(const char *value) {
3378: 	return static_cast<SinkFinalizeType>(StringUtil::StringToEnum(GetSinkFinalizeTypeValues(), 3, "SinkFinalizeType", value));
3379: }
3380: 
3381: const StringUtil::EnumStringLiteral *GetSinkNextBatchTypeValues() {
3382: 	static constexpr StringUtil::EnumStringLiteral values[] {
3383: 		{ static_cast<uint32_t>(SinkNextBatchType::READY), "READY" },
3384: 		{ static_cast<uint32_t>(SinkNextBatchType::BLOCKED), "BLOCKED" }
3385: 	};
3386: 	return values;
3387: }
3388: 
3389: template<>
3390: const char* EnumUtil::ToChars<SinkNextBatchType>(SinkNextBatchType value) {
3391: 	return StringUtil::EnumToString(GetSinkNextBatchTypeValues(), 2, "SinkNextBatchType", static_cast<uint32_t>(value));
3392: }
3393: 
3394: template<>
3395: SinkNextBatchType EnumUtil::FromString<SinkNextBatchType>(const char *value) {
3396: 	return static_cast<SinkNextBatchType>(StringUtil::StringToEnum(GetSinkNextBatchTypeValues(), 2, "SinkNextBatchType", value));
3397: }
3398: 
3399: const StringUtil::EnumStringLiteral *GetSinkResultTypeValues() {
3400: 	static constexpr StringUtil::EnumStringLiteral values[] {
3401: 		{ static_cast<uint32_t>(SinkResultType::NEED_MORE_INPUT), "NEED_MORE_INPUT" },
3402: 		{ static_cast<uint32_t>(SinkResultType::FINISHED), "FINISHED" },
3403: 		{ static_cast<uint32_t>(SinkResultType::BLOCKED), "BLOCKED" }
3404: 	};
3405: 	return values;
3406: }
3407: 
3408: template<>
3409: const char* EnumUtil::ToChars<SinkResultType>(SinkResultType value) {
3410: 	return StringUtil::EnumToString(GetSinkResultTypeValues(), 3, "SinkResultType", static_cast<uint32_t>(value));
3411: }
3412: 
3413: template<>
3414: SinkResultType EnumUtil::FromString<SinkResultType>(const char *value) {
3415: 	return static_cast<SinkResultType>(StringUtil::StringToEnum(GetSinkResultTypeValues(), 3, "SinkResultType", value));
3416: }
3417: 
3418: const StringUtil::EnumStringLiteral *GetSourceResultTypeValues() {
3419: 	static constexpr StringUtil::EnumStringLiteral values[] {
3420: 		{ static_cast<uint32_t>(SourceResultType::HAVE_MORE_OUTPUT), "HAVE_MORE_OUTPUT" },
3421: 		{ static_cast<uint32_t>(SourceResultType::FINISHED), "FINISHED" },
3422: 		{ static_cast<uint32_t>(SourceResultType::BLOCKED), "BLOCKED" }
3423: 	};
3424: 	return values;
3425: }
3426: 
3427: template<>
3428: const char* EnumUtil::ToChars<SourceResultType>(SourceResultType value) {
3429: 	return StringUtil::EnumToString(GetSourceResultTypeValues(), 3, "SourceResultType", static_cast<uint32_t>(value));
3430: }
3431: 
3432: template<>
3433: SourceResultType EnumUtil::FromString<SourceResultType>(const char *value) {
3434: 	return static_cast<SourceResultType>(StringUtil::StringToEnum(GetSourceResultTypeValues(), 3, "SourceResultType", value));
3435: }
3436: 
3437: const StringUtil::EnumStringLiteral *GetStatementReturnTypeValues() {
3438: 	static constexpr StringUtil::EnumStringLiteral values[] {
3439: 		{ static_cast<uint32_t>(StatementReturnType::QUERY_RESULT), "QUERY_RESULT" },
3440: 		{ static_cast<uint32_t>(StatementReturnType::CHANGED_ROWS), "CHANGED_ROWS" },
3441: 		{ static_cast<uint32_t>(StatementReturnType::NOTHING), "NOTHING" }
3442: 	};
3443: 	return values;
3444: }
3445: 
3446: template<>
3447: const char* EnumUtil::ToChars<StatementReturnType>(StatementReturnType value) {
3448: 	return StringUtil::EnumToString(GetStatementReturnTypeValues(), 3, "StatementReturnType", static_cast<uint32_t>(value));
3449: }
3450: 
3451: template<>
3452: StatementReturnType EnumUtil::FromString<StatementReturnType>(const char *value) {
3453: 	return static_cast<StatementReturnType>(StringUtil::StringToEnum(GetStatementReturnTypeValues(), 3, "StatementReturnType", value));
3454: }
3455: 
3456: const StringUtil::EnumStringLiteral *GetStatementTypeValues() {
3457: 	static constexpr StringUtil::EnumStringLiteral values[] {
3458: 		{ static_cast<uint32_t>(StatementType::INVALID_STATEMENT), "INVALID_STATEMENT" },
3459: 		{ static_cast<uint32_t>(StatementType::SELECT_STATEMENT), "SELECT_STATEMENT" },
3460: 		{ static_cast<uint32_t>(StatementType::INSERT_STATEMENT), "INSERT_STATEMENT" },
3461: 		{ static_cast<uint32_t>(StatementType::UPDATE_STATEMENT), "UPDATE_STATEMENT" },
3462: 		{ static_cast<uint32_t>(StatementType::CREATE_STATEMENT), "CREATE_STATEMENT" },
3463: 		{ static_cast<uint32_t>(StatementType::DELETE_STATEMENT), "DELETE_STATEMENT" },
3464: 		{ static_cast<uint32_t>(StatementType::PREPARE_STATEMENT), "PREPARE_STATEMENT" },
3465: 		{ static_cast<uint32_t>(StatementType::EXECUTE_STATEMENT), "EXECUTE_STATEMENT" },
3466: 		{ static_cast<uint32_t>(StatementType::ALTER_STATEMENT), "ALTER_STATEMENT" },
3467: 		{ static_cast<uint32_t>(StatementType::TRANSACTION_STATEMENT), "TRANSACTION_STATEMENT" },
3468: 		{ static_cast<uint32_t>(StatementType::COPY_STATEMENT), "COPY_STATEMENT" },
3469: 		{ static_cast<uint32_t>(StatementType::ANALYZE_STATEMENT), "ANALYZE_STATEMENT" },
3470: 		{ static_cast<uint32_t>(StatementType::VARIABLE_SET_STATEMENT), "VARIABLE_SET_STATEMENT" },
3471: 		{ static_cast<uint32_t>(StatementType::CREATE_FUNC_STATEMENT), "CREATE_FUNC_STATEMENT" },
3472: 		{ static_cast<uint32_t>(StatementType::EXPLAIN_STATEMENT), "EXPLAIN_STATEMENT" },
3473: 		{ static_cast<uint32_t>(StatementType::DROP_STATEMENT), "DROP_STATEMENT" },
3474: 		{ static_cast<uint32_t>(StatementType::EXPORT_STATEMENT), "EXPORT_STATEMENT" },
3475: 		{ static_cast<uint32_t>(StatementType::PRAGMA_STATEMENT), "PRAGMA_STATEMENT" },
3476: 		{ static_cast<uint32_t>(StatementType::VACUUM_STATEMENT), "VACUUM_STATEMENT" },
3477: 		{ static_cast<uint32_t>(StatementType::CALL_STATEMENT), "CALL_STATEMENT" },
3478: 		{ static_cast<uint32_t>(StatementType::SET_STATEMENT), "SET_STATEMENT" },
3479: 		{ static_cast<uint32_t>(StatementType::LOAD_STATEMENT), "LOAD_STATEMENT" },
3480: 		{ static_cast<uint32_t>(StatementType::RELATION_STATEMENT), "RELATION_STATEMENT" },
3481: 		{ static_cast<uint32_t>(StatementType::EXTENSION_STATEMENT), "EXTENSION_STATEMENT" },
3482: 		{ static_cast<uint32_t>(StatementType::LOGICAL_PLAN_STATEMENT), "LOGICAL_PLAN_STATEMENT" },
3483: 		{ static_cast<uint32_t>(StatementType::ATTACH_STATEMENT), "ATTACH_STATEMENT" },
3484: 		{ static_cast<uint32_t>(StatementType::DETACH_STATEMENT), "DETACH_STATEMENT" },
3485: 		{ static_cast<uint32_t>(StatementType::MULTI_STATEMENT), "MULTI_STATEMENT" },
3486: 		{ static_cast<uint32_t>(StatementType::COPY_DATABASE_STATEMENT), "COPY_DATABASE_STATEMENT" },
3487: 		{ static_cast<uint32_t>(StatementType::UPDATE_EXTENSIONS_STATEMENT), "UPDATE_EXTENSIONS_STATEMENT" }
3488: 	};
3489: 	return values;
3490: }
3491: 
3492: template<>
3493: const char* EnumUtil::ToChars<StatementType>(StatementType value) {
3494: 	return StringUtil::EnumToString(GetStatementTypeValues(), 30, "StatementType", static_cast<uint32_t>(value));
3495: }
3496: 
3497: template<>
3498: StatementType EnumUtil::FromString<StatementType>(const char *value) {
3499: 	return static_cast<StatementType>(StringUtil::StringToEnum(GetStatementTypeValues(), 30, "StatementType", value));
3500: }
3501: 
3502: const StringUtil::EnumStringLiteral *GetStatisticsTypeValues() {
3503: 	static constexpr StringUtil::EnumStringLiteral values[] {
3504: 		{ static_cast<uint32_t>(StatisticsType::NUMERIC_STATS), "NUMERIC_STATS" },
3505: 		{ static_cast<uint32_t>(StatisticsType::STRING_STATS), "STRING_STATS" },
3506: 		{ static_cast<uint32_t>(StatisticsType::LIST_STATS), "LIST_STATS" },
3507: 		{ static_cast<uint32_t>(StatisticsType::STRUCT_STATS), "STRUCT_STATS" },
3508: 		{ static_cast<uint32_t>(StatisticsType::BASE_STATS), "BASE_STATS" },
3509: 		{ static_cast<uint32_t>(StatisticsType::ARRAY_STATS), "ARRAY_STATS" }
3510: 	};
3511: 	return values;
3512: }
3513: 
3514: template<>
3515: const char* EnumUtil::ToChars<StatisticsType>(StatisticsType value) {
3516: 	return StringUtil::EnumToString(GetStatisticsTypeValues(), 6, "StatisticsType", static_cast<uint32_t>(value));
3517: }
3518: 
3519: template<>
3520: StatisticsType EnumUtil::FromString<StatisticsType>(const char *value) {
3521: 	return static_cast<StatisticsType>(StringUtil::StringToEnum(GetStatisticsTypeValues(), 6, "StatisticsType", value));
3522: }
3523: 
3524: const StringUtil::EnumStringLiteral *GetStatsInfoValues() {
3525: 	static constexpr StringUtil::EnumStringLiteral values[] {
3526: 		{ static_cast<uint32_t>(StatsInfo::CAN_HAVE_NULL_VALUES), "CAN_HAVE_NULL_VALUES" },
3527: 		{ static_cast<uint32_t>(StatsInfo::CANNOT_HAVE_NULL_VALUES), "CANNOT_HAVE_NULL_VALUES" },
3528: 		{ static_cast<uint32_t>(StatsInfo::CAN_HAVE_VALID_VALUES), "CAN_HAVE_VALID_VALUES" },
3529: 		{ static_cast<uint32_t>(StatsInfo::CANNOT_HAVE_VALID_VALUES), "CANNOT_HAVE_VALID_VALUES" },
3530: 		{ static_cast<uint32_t>(StatsInfo::CAN_HAVE_NULL_AND_VALID_VALUES), "CAN_HAVE_NULL_AND_VALID_VALUES" }
3531: 	};
3532: 	return values;
3533: }
3534: 
3535: template<>
3536: const char* EnumUtil::ToChars<StatsInfo>(StatsInfo value) {
3537: 	return StringUtil::EnumToString(GetStatsInfoValues(), 5, "StatsInfo", static_cast<uint32_t>(value));
3538: }
3539: 
3540: template<>
3541: StatsInfo EnumUtil::FromString<StatsInfo>(const char *value) {
3542: 	return static_cast<StatsInfo>(StringUtil::StringToEnum(GetStatsInfoValues(), 5, "StatsInfo", value));
3543: }
3544: 
3545: const StringUtil::EnumStringLiteral *GetStrTimeSpecifierValues() {
3546: 	static constexpr StringUtil::EnumStringLiteral values[] {
3547: 		{ static_cast<uint32_t>(StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME), "ABBREVIATED_WEEKDAY_NAME" },
3548: 		{ static_cast<uint32_t>(StrTimeSpecifier::FULL_WEEKDAY_NAME), "FULL_WEEKDAY_NAME" },
3549: 		{ static_cast<uint32_t>(StrTimeSpecifier::WEEKDAY_DECIMAL), "WEEKDAY_DECIMAL" },
3550: 		{ static_cast<uint32_t>(StrTimeSpecifier::DAY_OF_MONTH_PADDED), "DAY_OF_MONTH_PADDED" },
3551: 		{ static_cast<uint32_t>(StrTimeSpecifier::DAY_OF_MONTH), "DAY_OF_MONTH" },
3552: 		{ static_cast<uint32_t>(StrTimeSpecifier::ABBREVIATED_MONTH_NAME), "ABBREVIATED_MONTH_NAME" },
3553: 		{ static_cast<uint32_t>(StrTimeSpecifier::FULL_MONTH_NAME), "FULL_MONTH_NAME" },
3554: 		{ static_cast<uint32_t>(StrTimeSpecifier::MONTH_DECIMAL_PADDED), "MONTH_DECIMAL_PADDED" },
3555: 		{ static_cast<uint32_t>(StrTimeSpecifier::MONTH_DECIMAL), "MONTH_DECIMAL" },
3556: 		{ static_cast<uint32_t>(StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED), "YEAR_WITHOUT_CENTURY_PADDED" },
3557: 		{ static_cast<uint32_t>(StrTimeSpecifier::YEAR_WITHOUT_CENTURY), "YEAR_WITHOUT_CENTURY" },
3558: 		{ static_cast<uint32_t>(StrTimeSpecifier::YEAR_DECIMAL), "YEAR_DECIMAL" },
3559: 		{ static_cast<uint32_t>(StrTimeSpecifier::HOUR_24_PADDED), "HOUR_24_PADDED" },
3560: 		{ static_cast<uint32_t>(StrTimeSpecifier::HOUR_24_DECIMAL), "HOUR_24_DECIMAL" },
3561: 		{ static_cast<uint32_t>(StrTimeSpecifier::HOUR_12_PADDED), "HOUR_12_PADDED" },
3562: 		{ static_cast<uint32_t>(StrTimeSpecifier::HOUR_12_DECIMAL), "HOUR_12_DECIMAL" },
3563: 		{ static_cast<uint32_t>(StrTimeSpecifier::AM_PM), "AM_PM" },
3564: 		{ static_cast<uint32_t>(StrTimeSpecifier::MINUTE_PADDED), "MINUTE_PADDED" },
3565: 		{ static_cast<uint32_t>(StrTimeSpecifier::MINUTE_DECIMAL), "MINUTE_DECIMAL" },
3566: 		{ static_cast<uint32_t>(StrTimeSpecifier::SECOND_PADDED), "SECOND_PADDED" },
3567: 		{ static_cast<uint32_t>(StrTimeSpecifier::SECOND_DECIMAL), "SECOND_DECIMAL" },
3568: 		{ static_cast<uint32_t>(StrTimeSpecifier::MICROSECOND_PADDED), "MICROSECOND_PADDED" },
3569: 		{ static_cast<uint32_t>(StrTimeSpecifier::MILLISECOND_PADDED), "MILLISECOND_PADDED" },
3570: 		{ static_cast<uint32_t>(StrTimeSpecifier::UTC_OFFSET), "UTC_OFFSET" },
3571: 		{ static_cast<uint32_t>(StrTimeSpecifier::TZ_NAME), "TZ_NAME" },
3572: 		{ static_cast<uint32_t>(StrTimeSpecifier::DAY_OF_YEAR_PADDED), "DAY_OF_YEAR_PADDED" },
3573: 		{ static_cast<uint32_t>(StrTimeSpecifier::DAY_OF_YEAR_DECIMAL), "DAY_OF_YEAR_DECIMAL" },
3574: 		{ static_cast<uint32_t>(StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST), "WEEK_NUMBER_PADDED_SUN_FIRST" },
3575: 		{ static_cast<uint32_t>(StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST), "WEEK_NUMBER_PADDED_MON_FIRST" },
3576: 		{ static_cast<uint32_t>(StrTimeSpecifier::LOCALE_APPROPRIATE_DATE_AND_TIME), "LOCALE_APPROPRIATE_DATE_AND_TIME" },
3577: 		{ static_cast<uint32_t>(StrTimeSpecifier::LOCALE_APPROPRIATE_DATE), "LOCALE_APPROPRIATE_DATE" },
3578: 		{ static_cast<uint32_t>(StrTimeSpecifier::LOCALE_APPROPRIATE_TIME), "LOCALE_APPROPRIATE_TIME" },
3579: 		{ static_cast<uint32_t>(StrTimeSpecifier::NANOSECOND_PADDED), "NANOSECOND_PADDED" },
3580: 		{ static_cast<uint32_t>(StrTimeSpecifier::YEAR_ISO), "YEAR_ISO" },
3581: 		{ static_cast<uint32_t>(StrTimeSpecifier::WEEKDAY_ISO), "WEEKDAY_ISO" },
3582: 		{ static_cast<uint32_t>(StrTimeSpecifier::WEEK_NUMBER_ISO), "WEEK_NUMBER_ISO" }
3583: 	};
3584: 	return values;
3585: }
3586: 
3587: template<>
3588: const char* EnumUtil::ToChars<StrTimeSpecifier>(StrTimeSpecifier value) {
3589: 	return StringUtil::EnumToString(GetStrTimeSpecifierValues(), 36, "StrTimeSpecifier", static_cast<uint32_t>(value));
3590: }
3591: 
3592: template<>
3593: StrTimeSpecifier EnumUtil::FromString<StrTimeSpecifier>(const char *value) {
3594: 	return static_cast<StrTimeSpecifier>(StringUtil::StringToEnum(GetStrTimeSpecifierValues(), 36, "StrTimeSpecifier", value));
3595: }
3596: 
3597: const StringUtil::EnumStringLiteral *GetStreamExecutionResultValues() {
3598: 	static constexpr StringUtil::EnumStringLiteral values[] {
3599: 		{ static_cast<uint32_t>(StreamExecutionResult::CHUNK_READY), "CHUNK_READY" },
3600: 		{ static_cast<uint32_t>(StreamExecutionResult::CHUNK_NOT_READY), "CHUNK_NOT_READY" },
3601: 		{ static_cast<uint32_t>(StreamExecutionResult::EXECUTION_ERROR), "EXECUTION_ERROR" },
3602: 		{ static_cast<uint32_t>(StreamExecutionResult::EXECUTION_CANCELLED), "EXECUTION_CANCELLED" },
3603: 		{ static_cast<uint32_t>(StreamExecutionResult::BLOCKED), "BLOCKED" },
3604: 		{ static_cast<uint32_t>(StreamExecutionResult::NO_TASKS_AVAILABLE), "NO_TASKS_AVAILABLE" },
3605: 		{ static_cast<uint32_t>(StreamExecutionResult::EXECUTION_FINISHED), "EXECUTION_FINISHED" }
3606: 	};
3607: 	return values;
3608: }
3609: 
3610: template<>
3611: const char* EnumUtil::ToChars<StreamExecutionResult>(StreamExecutionResult value) {
3612: 	return StringUtil::EnumToString(GetStreamExecutionResultValues(), 7, "StreamExecutionResult", static_cast<uint32_t>(value));
3613: }
3614: 
3615: template<>
3616: StreamExecutionResult EnumUtil::FromString<StreamExecutionResult>(const char *value) {
3617: 	return static_cast<StreamExecutionResult>(StringUtil::StringToEnum(GetStreamExecutionResultValues(), 7, "StreamExecutionResult", value));
3618: }
3619: 
3620: const StringUtil::EnumStringLiteral *GetSubqueryTypeValues() {
3621: 	static constexpr StringUtil::EnumStringLiteral values[] {
3622: 		{ static_cast<uint32_t>(SubqueryType::INVALID), "INVALID" },
3623: 		{ static_cast<uint32_t>(SubqueryType::SCALAR), "SCALAR" },
3624: 		{ static_cast<uint32_t>(SubqueryType::EXISTS), "EXISTS" },
3625: 		{ static_cast<uint32_t>(SubqueryType::NOT_EXISTS), "NOT_EXISTS" },
3626: 		{ static_cast<uint32_t>(SubqueryType::ANY), "ANY" }
3627: 	};
3628: 	return values;
3629: }
3630: 
3631: template<>
3632: const char* EnumUtil::ToChars<SubqueryType>(SubqueryType value) {
3633: 	return StringUtil::EnumToString(GetSubqueryTypeValues(), 5, "SubqueryType", static_cast<uint32_t>(value));
3634: }
3635: 
3636: template<>
3637: SubqueryType EnumUtil::FromString<SubqueryType>(const char *value) {
3638: 	return static_cast<SubqueryType>(StringUtil::StringToEnum(GetSubqueryTypeValues(), 5, "SubqueryType", value));
3639: }
3640: 
3641: const StringUtil::EnumStringLiteral *GetTableColumnTypeValues() {
3642: 	static constexpr StringUtil::EnumStringLiteral values[] {
3643: 		{ static_cast<uint32_t>(TableColumnType::STANDARD), "STANDARD" },
3644: 		{ static_cast<uint32_t>(TableColumnType::GENERATED), "GENERATED" }
3645: 	};
3646: 	return values;
3647: }
3648: 
3649: template<>
3650: const char* EnumUtil::ToChars<TableColumnType>(TableColumnType value) {
3651: 	return StringUtil::EnumToString(GetTableColumnTypeValues(), 2, "TableColumnType", static_cast<uint32_t>(value));
3652: }
3653: 
3654: template<>
3655: TableColumnType EnumUtil::FromString<TableColumnType>(const char *value) {
3656: 	return static_cast<TableColumnType>(StringUtil::StringToEnum(GetTableColumnTypeValues(), 2, "TableColumnType", value));
3657: }
3658: 
3659: const StringUtil::EnumStringLiteral *GetTableFilterTypeValues() {
3660: 	static constexpr StringUtil::EnumStringLiteral values[] {
3661: 		{ static_cast<uint32_t>(TableFilterType::CONSTANT_COMPARISON), "CONSTANT_COMPARISON" },
3662: 		{ static_cast<uint32_t>(TableFilterType::IS_NULL), "IS_NULL" },
3663: 		{ static_cast<uint32_t>(TableFilterType::IS_NOT_NULL), "IS_NOT_NULL" },
3664: 		{ static_cast<uint32_t>(TableFilterType::CONJUNCTION_OR), "CONJUNCTION_OR" },
3665: 		{ static_cast<uint32_t>(TableFilterType::CONJUNCTION_AND), "CONJUNCTION_AND" },
3666: 		{ static_cast<uint32_t>(TableFilterType::STRUCT_EXTRACT), "STRUCT_EXTRACT" },
3667: 		{ static_cast<uint32_t>(TableFilterType::OPTIONAL_FILTER), "OPTIONAL_FILTER" },
3668: 		{ static_cast<uint32_t>(TableFilterType::IN_FILTER), "IN_FILTER" },
3669: 		{ static_cast<uint32_t>(TableFilterType::DYNAMIC_FILTER), "DYNAMIC_FILTER" }
3670: 	};
3671: 	return values;
3672: }
3673: 
3674: template<>
3675: const char* EnumUtil::ToChars<TableFilterType>(TableFilterType value) {
3676: 	return StringUtil::EnumToString(GetTableFilterTypeValues(), 9, "TableFilterType", static_cast<uint32_t>(value));
3677: }
3678: 
3679: template<>
3680: TableFilterType EnumUtil::FromString<TableFilterType>(const char *value) {
3681: 	return static_cast<TableFilterType>(StringUtil::StringToEnum(GetTableFilterTypeValues(), 9, "TableFilterType", value));
3682: }
3683: 
3684: const StringUtil::EnumStringLiteral *GetTablePartitionInfoValues() {
3685: 	static constexpr StringUtil::EnumStringLiteral values[] {
3686: 		{ static_cast<uint32_t>(TablePartitionInfo::NOT_PARTITIONED), "NOT_PARTITIONED" },
3687: 		{ static_cast<uint32_t>(TablePartitionInfo::SINGLE_VALUE_PARTITIONS), "SINGLE_VALUE_PARTITIONS" },
3688: 		{ static_cast<uint32_t>(TablePartitionInfo::OVERLAPPING_PARTITIONS), "OVERLAPPING_PARTITIONS" },
3689: 		{ static_cast<uint32_t>(TablePartitionInfo::DISJOINT_PARTITIONS), "DISJOINT_PARTITIONS" }
3690: 	};
3691: 	return values;
3692: }
3693: 
3694: template<>
3695: const char* EnumUtil::ToChars<TablePartitionInfo>(TablePartitionInfo value) {
3696: 	return StringUtil::EnumToString(GetTablePartitionInfoValues(), 4, "TablePartitionInfo", static_cast<uint32_t>(value));
3697: }
3698: 
3699: template<>
3700: TablePartitionInfo EnumUtil::FromString<TablePartitionInfo>(const char *value) {
3701: 	return static_cast<TablePartitionInfo>(StringUtil::StringToEnum(GetTablePartitionInfoValues(), 4, "TablePartitionInfo", value));
3702: }
3703: 
3704: const StringUtil::EnumStringLiteral *GetTableReferenceTypeValues() {
3705: 	static constexpr StringUtil::EnumStringLiteral values[] {
3706: 		{ static_cast<uint32_t>(TableReferenceType::INVALID), "INVALID" },
3707: 		{ static_cast<uint32_t>(TableReferenceType::BASE_TABLE), "BASE_TABLE" },
3708: 		{ static_cast<uint32_t>(TableReferenceType::SUBQUERY), "SUBQUERY" },
3709: 		{ static_cast<uint32_t>(TableReferenceType::JOIN), "JOIN" },
3710: 		{ static_cast<uint32_t>(TableReferenceType::TABLE_FUNCTION), "TABLE_FUNCTION" },
3711: 		{ static_cast<uint32_t>(TableReferenceType::EXPRESSION_LIST), "EXPRESSION_LIST" },
3712: 		{ static_cast<uint32_t>(TableReferenceType::CTE), "CTE" },
3713: 		{ static_cast<uint32_t>(TableReferenceType::EMPTY_FROM), "EMPTY" },
3714: 		{ static_cast<uint32_t>(TableReferenceType::PIVOT), "PIVOT" },
3715: 		{ static_cast<uint32_t>(TableReferenceType::SHOW_REF), "SHOW_REF" },
3716: 		{ static_cast<uint32_t>(TableReferenceType::COLUMN_DATA), "COLUMN_DATA" },
3717: 		{ static_cast<uint32_t>(TableReferenceType::DELIM_GET), "DELIM_GET" }
3718: 	};
3719: 	return values;
3720: }
3721: 
3722: template<>
3723: const char* EnumUtil::ToChars<TableReferenceType>(TableReferenceType value) {
3724: 	return StringUtil::EnumToString(GetTableReferenceTypeValues(), 12, "TableReferenceType", static_cast<uint32_t>(value));
3725: }
3726: 
3727: template<>
3728: TableReferenceType EnumUtil::FromString<TableReferenceType>(const char *value) {
3729: 	return static_cast<TableReferenceType>(StringUtil::StringToEnum(GetTableReferenceTypeValues(), 12, "TableReferenceType", value));
3730: }
3731: 
3732: const StringUtil::EnumStringLiteral *GetTableScanTypeValues() {
3733: 	static constexpr StringUtil::EnumStringLiteral values[] {
3734: 		{ static_cast<uint32_t>(TableScanType::TABLE_SCAN_REGULAR), "TABLE_SCAN_REGULAR" },
3735: 		{ static_cast<uint32_t>(TableScanType::TABLE_SCAN_COMMITTED_ROWS), "TABLE_SCAN_COMMITTED_ROWS" },
3736: 		{ static_cast<uint32_t>(TableScanType::TABLE_SCAN_COMMITTED_ROWS_DISALLOW_UPDATES), "TABLE_SCAN_COMMITTED_ROWS_DISALLOW_UPDATES" },
3737: 		{ static_cast<uint32_t>(TableScanType::TABLE_SCAN_COMMITTED_ROWS_OMIT_PERMANENTLY_DELETED), "TABLE_SCAN_COMMITTED_ROWS_OMIT_PERMANENTLY_DELETED" },
3738: 		{ static_cast<uint32_t>(TableScanType::TABLE_SCAN_LATEST_COMMITTED_ROWS), "TABLE_SCAN_LATEST_COMMITTED_ROWS" }
3739: 	};
3740: 	return values;
3741: }
3742: 
3743: template<>
3744: const char* EnumUtil::ToChars<TableScanType>(TableScanType value) {
3745: 	return StringUtil::EnumToString(GetTableScanTypeValues(), 5, "TableScanType", static_cast<uint32_t>(value));
3746: }
3747: 
3748: template<>
3749: TableScanType EnumUtil::FromString<TableScanType>(const char *value) {
3750: 	return static_cast<TableScanType>(StringUtil::StringToEnum(GetTableScanTypeValues(), 5, "TableScanType", value));
3751: }
3752: 
3753: const StringUtil::EnumStringLiteral *GetTaskExecutionModeValues() {
3754: 	static constexpr StringUtil::EnumStringLiteral values[] {
3755: 		{ static_cast<uint32_t>(TaskExecutionMode::PROCESS_ALL), "PROCESS_ALL" },
3756: 		{ static_cast<uint32_t>(TaskExecutionMode::PROCESS_PARTIAL), "PROCESS_PARTIAL" }
3757: 	};
3758: 	return values;
3759: }
3760: 
3761: template<>
3762: const char* EnumUtil::ToChars<TaskExecutionMode>(TaskExecutionMode value) {
3763: 	return StringUtil::EnumToString(GetTaskExecutionModeValues(), 2, "TaskExecutionMode", static_cast<uint32_t>(value));
3764: }
3765: 
3766: template<>
3767: TaskExecutionMode EnumUtil::FromString<TaskExecutionMode>(const char *value) {
3768: 	return static_cast<TaskExecutionMode>(StringUtil::StringToEnum(GetTaskExecutionModeValues(), 2, "TaskExecutionMode", value));
3769: }
3770: 
3771: const StringUtil::EnumStringLiteral *GetTaskExecutionResultValues() {
3772: 	static constexpr StringUtil::EnumStringLiteral values[] {
3773: 		{ static_cast<uint32_t>(TaskExecutionResult::TASK_FINISHED), "TASK_FINISHED" },
3774: 		{ static_cast<uint32_t>(TaskExecutionResult::TASK_NOT_FINISHED), "TASK_NOT_FINISHED" },
3775: 		{ static_cast<uint32_t>(TaskExecutionResult::TASK_ERROR), "TASK_ERROR" },
3776: 		{ static_cast<uint32_t>(TaskExecutionResult::TASK_BLOCKED), "TASK_BLOCKED" }
3777: 	};
3778: 	return values;
3779: }
3780: 
3781: template<>
3782: const char* EnumUtil::ToChars<TaskExecutionResult>(TaskExecutionResult value) {
3783: 	return StringUtil::EnumToString(GetTaskExecutionResultValues(), 4, "TaskExecutionResult", static_cast<uint32_t>(value));
3784: }
3785: 
3786: template<>
3787: TaskExecutionResult EnumUtil::FromString<TaskExecutionResult>(const char *value) {
3788: 	return static_cast<TaskExecutionResult>(StringUtil::StringToEnum(GetTaskExecutionResultValues(), 4, "TaskExecutionResult", value));
3789: }
3790: 
3791: const StringUtil::EnumStringLiteral *GetTemporaryBufferSizeValues() {
3792: 	static constexpr StringUtil::EnumStringLiteral values[] {
3793: 		{ static_cast<uint32_t>(TemporaryBufferSize::INVALID), "INVALID" },
3794: 		{ static_cast<uint32_t>(TemporaryBufferSize::S32K), "S32K" },
3795: 		{ static_cast<uint32_t>(TemporaryBufferSize::S64K), "S64K" },
3796: 		{ static_cast<uint32_t>(TemporaryBufferSize::S96K), "S96K" },
3797: 		{ static_cast<uint32_t>(TemporaryBufferSize::S128K), "S128K" },
3798: 		{ static_cast<uint32_t>(TemporaryBufferSize::S160K), "S160K" },
3799: 		{ static_cast<uint32_t>(TemporaryBufferSize::S192K), "S192K" },
3800: 		{ static_cast<uint32_t>(TemporaryBufferSize::S224K), "S224K" },
3801: 		{ static_cast<uint32_t>(TemporaryBufferSize::DEFAULT), "DEFAULT" }
3802: 	};
3803: 	return values;
3804: }
3805: 
3806: template<>
3807: const char* EnumUtil::ToChars<TemporaryBufferSize>(TemporaryBufferSize value) {
3808: 	return StringUtil::EnumToString(GetTemporaryBufferSizeValues(), 9, "TemporaryBufferSize", static_cast<uint32_t>(value));
3809: }
3810: 
3811: template<>
3812: TemporaryBufferSize EnumUtil::FromString<TemporaryBufferSize>(const char *value) {
3813: 	return static_cast<TemporaryBufferSize>(StringUtil::StringToEnum(GetTemporaryBufferSizeValues(), 9, "TemporaryBufferSize", value));
3814: }
3815: 
3816: const StringUtil::EnumStringLiteral *GetTemporaryCompressionLevelValues() {
3817: 	static constexpr StringUtil::EnumStringLiteral values[] {
3818: 		{ static_cast<uint32_t>(TemporaryCompressionLevel::ZSTD_MINUS_FIVE), "ZSTD_MINUS_FIVE" },
3819: 		{ static_cast<uint32_t>(TemporaryCompressionLevel::ZSTD_MINUS_THREE), "ZSTD_MINUS_THREE" },
3820: 		{ static_cast<uint32_t>(TemporaryCompressionLevel::ZSTD_MINUS_ONE), "ZSTD_MINUS_ONE" },
3821: 		{ static_cast<uint32_t>(TemporaryCompressionLevel::UNCOMPRESSED), "UNCOMPRESSED" },
3822: 		{ static_cast<uint32_t>(TemporaryCompressionLevel::ZSTD_ONE), "ZSTD_ONE" },
3823: 		{ static_cast<uint32_t>(TemporaryCompressionLevel::ZSTD_THREE), "ZSTD_THREE" },
3824: 		{ static_cast<uint32_t>(TemporaryCompressionLevel::ZSTD_FIVE), "ZSTD_FIVE" }
3825: 	};
3826: 	return values;
3827: }
3828: 
3829: template<>
3830: const char* EnumUtil::ToChars<TemporaryCompressionLevel>(TemporaryCompressionLevel value) {
3831: 	return StringUtil::EnumToString(GetTemporaryCompressionLevelValues(), 7, "TemporaryCompressionLevel", static_cast<uint32_t>(value));
3832: }
3833: 
3834: template<>
3835: TemporaryCompressionLevel EnumUtil::FromString<TemporaryCompressionLevel>(const char *value) {
3836: 	return static_cast<TemporaryCompressionLevel>(StringUtil::StringToEnum(GetTemporaryCompressionLevelValues(), 7, "TemporaryCompressionLevel", value));
3837: }
3838: 
3839: const StringUtil::EnumStringLiteral *GetTimestampCastResultValues() {
3840: 	static constexpr StringUtil::EnumStringLiteral values[] {
3841: 		{ static_cast<uint32_t>(TimestampCastResult::SUCCESS), "SUCCESS" },
3842: 		{ static_cast<uint32_t>(TimestampCastResult::ERROR_INCORRECT_FORMAT), "ERROR_INCORRECT_FORMAT" },
3843: 		{ static_cast<uint32_t>(TimestampCastResult::ERROR_NON_UTC_TIMEZONE), "ERROR_NON_UTC_TIMEZONE" }
3844: 	};
3845: 	return values;
3846: }
3847: 
3848: template<>
3849: const char* EnumUtil::ToChars<TimestampCastResult>(TimestampCastResult value) {
3850: 	return StringUtil::EnumToString(GetTimestampCastResultValues(), 3, "TimestampCastResult", static_cast<uint32_t>(value));
3851: }
3852: 
3853: template<>
3854: TimestampCastResult EnumUtil::FromString<TimestampCastResult>(const char *value) {
3855: 	return static_cast<TimestampCastResult>(StringUtil::StringToEnum(GetTimestampCastResultValues(), 3, "TimestampCastResult", value));
3856: }
3857: 
3858: const StringUtil::EnumStringLiteral *GetTransactionModifierTypeValues() {
3859: 	static constexpr StringUtil::EnumStringLiteral values[] {
3860: 		{ static_cast<uint32_t>(TransactionModifierType::TRANSACTION_DEFAULT_MODIFIER), "TRANSACTION_DEFAULT_MODIFIER" },
3861: 		{ static_cast<uint32_t>(TransactionModifierType::TRANSACTION_READ_ONLY), "TRANSACTION_READ_ONLY" },
3862: 		{ static_cast<uint32_t>(TransactionModifierType::TRANSACTION_READ_WRITE), "TRANSACTION_READ_WRITE" }
3863: 	};
3864: 	return values;
3865: }
3866: 
3867: template<>
3868: const char* EnumUtil::ToChars<TransactionModifierType>(TransactionModifierType value) {
3869: 	return StringUtil::EnumToString(GetTransactionModifierTypeValues(), 3, "TransactionModifierType", static_cast<uint32_t>(value));
3870: }
3871: 
3872: template<>
3873: TransactionModifierType EnumUtil::FromString<TransactionModifierType>(const char *value) {
3874: 	return static_cast<TransactionModifierType>(StringUtil::StringToEnum(GetTransactionModifierTypeValues(), 3, "TransactionModifierType", value));
3875: }
3876: 
3877: const StringUtil::EnumStringLiteral *GetTransactionTypeValues() {
3878: 	static constexpr StringUtil::EnumStringLiteral values[] {
3879: 		{ static_cast<uint32_t>(TransactionType::INVALID), "INVALID" },
3880: 		{ static_cast<uint32_t>(TransactionType::BEGIN_TRANSACTION), "BEGIN_TRANSACTION" },
3881: 		{ static_cast<uint32_t>(TransactionType::COMMIT), "COMMIT" },
3882: 		{ static_cast<uint32_t>(TransactionType::ROLLBACK), "ROLLBACK" }
3883: 	};
3884: 	return values;
3885: }
3886: 
3887: template<>
3888: const char* EnumUtil::ToChars<TransactionType>(TransactionType value) {
3889: 	return StringUtil::EnumToString(GetTransactionTypeValues(), 4, "TransactionType", static_cast<uint32_t>(value));
3890: }
3891: 
3892: template<>
3893: TransactionType EnumUtil::FromString<TransactionType>(const char *value) {
3894: 	return static_cast<TransactionType>(StringUtil::StringToEnum(GetTransactionTypeValues(), 4, "TransactionType", value));
3895: }
3896: 
3897: const StringUtil::EnumStringLiteral *GetTupleDataPinPropertiesValues() {
3898: 	static constexpr StringUtil::EnumStringLiteral values[] {
3899: 		{ static_cast<uint32_t>(TupleDataPinProperties::INVALID), "INVALID" },
3900: 		{ static_cast<uint32_t>(TupleDataPinProperties::KEEP_EVERYTHING_PINNED), "KEEP_EVERYTHING_PINNED" },
3901: 		{ static_cast<uint32_t>(TupleDataPinProperties::UNPIN_AFTER_DONE), "UNPIN_AFTER_DONE" },
3902: 		{ static_cast<uint32_t>(TupleDataPinProperties::DESTROY_AFTER_DONE), "DESTROY_AFTER_DONE" },
3903: 		{ static_cast<uint32_t>(TupleDataPinProperties::ALREADY_PINNED), "ALREADY_PINNED" }
3904: 	};
3905: 	return values;
3906: }
3907: 
3908: template<>
3909: const char* EnumUtil::ToChars<TupleDataPinProperties>(TupleDataPinProperties value) {
3910: 	return StringUtil::EnumToString(GetTupleDataPinPropertiesValues(), 5, "TupleDataPinProperties", static_cast<uint32_t>(value));
3911: }
3912: 
3913: template<>
3914: TupleDataPinProperties EnumUtil::FromString<TupleDataPinProperties>(const char *value) {
3915: 	return static_cast<TupleDataPinProperties>(StringUtil::StringToEnum(GetTupleDataPinPropertiesValues(), 5, "TupleDataPinProperties", value));
3916: }
3917: 
3918: const StringUtil::EnumStringLiteral *GetUndoFlagsValues() {
3919: 	static constexpr StringUtil::EnumStringLiteral values[] {
3920: 		{ static_cast<uint32_t>(UndoFlags::EMPTY_ENTRY), "EMPTY_ENTRY" },
3921: 		{ static_cast<uint32_t>(UndoFlags::CATALOG_ENTRY), "CATALOG_ENTRY" },
3922: 		{ static_cast<uint32_t>(UndoFlags::INSERT_TUPLE), "INSERT_TUPLE" },
3923: 		{ static_cast<uint32_t>(UndoFlags::DELETE_TUPLE), "DELETE_TUPLE" },
3924: 		{ static_cast<uint32_t>(UndoFlags::UPDATE_TUPLE), "UPDATE_TUPLE" },
3925: 		{ static_cast<uint32_t>(UndoFlags::SEQUENCE_VALUE), "SEQUENCE_VALUE" }
3926: 	};
3927: 	return values;
3928: }
3929: 
3930: template<>
3931: const char* EnumUtil::ToChars<UndoFlags>(UndoFlags value) {
3932: 	return StringUtil::EnumToString(GetUndoFlagsValues(), 6, "UndoFlags", static_cast<uint32_t>(value));
3933: }
3934: 
3935: template<>
3936: UndoFlags EnumUtil::FromString<UndoFlags>(const char *value) {
3937: 	return static_cast<UndoFlags>(StringUtil::StringToEnum(GetUndoFlagsValues(), 6, "UndoFlags", value));
3938: }
3939: 
3940: const StringUtil::EnumStringLiteral *GetUnionInvalidReasonValues() {
3941: 	static constexpr StringUtil::EnumStringLiteral values[] {
3942: 		{ static_cast<uint32_t>(UnionInvalidReason::VALID), "VALID" },
3943: 		{ static_cast<uint32_t>(UnionInvalidReason::TAG_OUT_OF_RANGE), "TAG_OUT_OF_RANGE" },
3944: 		{ static_cast<uint32_t>(UnionInvalidReason::NO_MEMBERS), "NO_MEMBERS" },
3945: 		{ static_cast<uint32_t>(UnionInvalidReason::VALIDITY_OVERLAP), "VALIDITY_OVERLAP" },
3946: 		{ static_cast<uint32_t>(UnionInvalidReason::TAG_MISMATCH), "TAG_MISMATCH" },
3947: 		{ static_cast<uint32_t>(UnionInvalidReason::NULL_TAG), "NULL_TAG" }
3948: 	};
3949: 	return values;
3950: }
3951: 
3952: template<>
3953: const char* EnumUtil::ToChars<UnionInvalidReason>(UnionInvalidReason value) {
3954: 	return StringUtil::EnumToString(GetUnionInvalidReasonValues(), 6, "UnionInvalidReason", static_cast<uint32_t>(value));
3955: }
3956: 
3957: template<>
3958: UnionInvalidReason EnumUtil::FromString<UnionInvalidReason>(const char *value) {
3959: 	return static_cast<UnionInvalidReason>(StringUtil::StringToEnum(GetUnionInvalidReasonValues(), 6, "UnionInvalidReason", value));
3960: }
3961: 
3962: const StringUtil::EnumStringLiteral *GetVectorAuxiliaryDataTypeValues() {
3963: 	static constexpr StringUtil::EnumStringLiteral values[] {
3964: 		{ static_cast<uint32_t>(VectorAuxiliaryDataType::ARROW_AUXILIARY), "ARROW_AUXILIARY" }
3965: 	};
3966: 	return values;
3967: }
3968: 
3969: template<>
3970: const char* EnumUtil::ToChars<VectorAuxiliaryDataType>(VectorAuxiliaryDataType value) {
3971: 	return StringUtil::EnumToString(GetVectorAuxiliaryDataTypeValues(), 1, "VectorAuxiliaryDataType", static_cast<uint32_t>(value));
3972: }
3973: 
3974: template<>
3975: VectorAuxiliaryDataType EnumUtil::FromString<VectorAuxiliaryDataType>(const char *value) {
3976: 	return static_cast<VectorAuxiliaryDataType>(StringUtil::StringToEnum(GetVectorAuxiliaryDataTypeValues(), 1, "VectorAuxiliaryDataType", value));
3977: }
3978: 
3979: const StringUtil::EnumStringLiteral *GetVectorBufferTypeValues() {
3980: 	static constexpr StringUtil::EnumStringLiteral values[] {
3981: 		{ static_cast<uint32_t>(VectorBufferType::STANDARD_BUFFER), "STANDARD_BUFFER" },
3982: 		{ static_cast<uint32_t>(VectorBufferType::DICTIONARY_BUFFER), "DICTIONARY_BUFFER" },
3983: 		{ static_cast<uint32_t>(VectorBufferType::VECTOR_CHILD_BUFFER), "VECTOR_CHILD_BUFFER" },
3984: 		{ static_cast<uint32_t>(VectorBufferType::STRING_BUFFER), "STRING_BUFFER" },
3985: 		{ static_cast<uint32_t>(VectorBufferType::FSST_BUFFER), "FSST_BUFFER" },
3986: 		{ static_cast<uint32_t>(VectorBufferType::STRUCT_BUFFER), "STRUCT_BUFFER" },
3987: 		{ static_cast<uint32_t>(VectorBufferType::LIST_BUFFER), "LIST_BUFFER" },
3988: 		{ static_cast<uint32_t>(VectorBufferType::MANAGED_BUFFER), "MANAGED_BUFFER" },
3989: 		{ static_cast<uint32_t>(VectorBufferType::OPAQUE_BUFFER), "OPAQUE_BUFFER" },
3990: 		{ static_cast<uint32_t>(VectorBufferType::ARRAY_BUFFER), "ARRAY_BUFFER" }
3991: 	};
3992: 	return values;
3993: }
3994: 
3995: template<>
3996: const char* EnumUtil::ToChars<VectorBufferType>(VectorBufferType value) {
3997: 	return StringUtil::EnumToString(GetVectorBufferTypeValues(), 10, "VectorBufferType", static_cast<uint32_t>(value));
3998: }
3999: 
4000: template<>
4001: VectorBufferType EnumUtil::FromString<VectorBufferType>(const char *value) {
4002: 	return static_cast<VectorBufferType>(StringUtil::StringToEnum(GetVectorBufferTypeValues(), 10, "VectorBufferType", value));
4003: }
4004: 
4005: const StringUtil::EnumStringLiteral *GetVectorTypeValues() {
4006: 	static constexpr StringUtil::EnumStringLiteral values[] {
4007: 		{ static_cast<uint32_t>(VectorType::FLAT_VECTOR), "FLAT_VECTOR" },
4008: 		{ static_cast<uint32_t>(VectorType::FSST_VECTOR), "FSST_VECTOR" },
4009: 		{ static_cast<uint32_t>(VectorType::CONSTANT_VECTOR), "CONSTANT_VECTOR" },
4010: 		{ static_cast<uint32_t>(VectorType::DICTIONARY_VECTOR), "DICTIONARY_VECTOR" },
4011: 		{ static_cast<uint32_t>(VectorType::SEQUENCE_VECTOR), "SEQUENCE_VECTOR" }
4012: 	};
4013: 	return values;
4014: }
4015: 
4016: template<>
4017: const char* EnumUtil::ToChars<VectorType>(VectorType value) {
4018: 	return StringUtil::EnumToString(GetVectorTypeValues(), 5, "VectorType", static_cast<uint32_t>(value));
4019: }
4020: 
4021: template<>
4022: VectorType EnumUtil::FromString<VectorType>(const char *value) {
4023: 	return static_cast<VectorType>(StringUtil::StringToEnum(GetVectorTypeValues(), 5, "VectorType", value));
4024: }
4025: 
4026: const StringUtil::EnumStringLiteral *GetVerificationTypeValues() {
4027: 	static constexpr StringUtil::EnumStringLiteral values[] {
4028: 		{ static_cast<uint32_t>(VerificationType::ORIGINAL), "ORIGINAL" },
4029: 		{ static_cast<uint32_t>(VerificationType::COPIED), "COPIED" },
4030: 		{ static_cast<uint32_t>(VerificationType::DESERIALIZED), "DESERIALIZED" },
4031: 		{ static_cast<uint32_t>(VerificationType::PARSED), "PARSED" },
4032: 		{ static_cast<uint32_t>(VerificationType::UNOPTIMIZED), "UNOPTIMIZED" },
4033: 		{ static_cast<uint32_t>(VerificationType::NO_OPERATOR_CACHING), "NO_OPERATOR_CACHING" },
4034: 		{ static_cast<uint32_t>(VerificationType::PREPARED), "PREPARED" },
4035: 		{ static_cast<uint32_t>(VerificationType::EXTERNAL), "EXTERNAL" },
4036: 		{ static_cast<uint32_t>(VerificationType::FETCH_ROW_AS_SCAN), "FETCH_ROW_AS_SCAN" },
4037: 		{ static_cast<uint32_t>(VerificationType::INVALID), "INVALID" }
4038: 	};
4039: 	return values;
4040: }
4041: 
4042: template<>
4043: const char* EnumUtil::ToChars<VerificationType>(VerificationType value) {
4044: 	return StringUtil::EnumToString(GetVerificationTypeValues(), 10, "VerificationType", static_cast<uint32_t>(value));
4045: }
4046: 
4047: template<>
4048: VerificationType EnumUtil::FromString<VerificationType>(const char *value) {
4049: 	return static_cast<VerificationType>(StringUtil::StringToEnum(GetVerificationTypeValues(), 10, "VerificationType", value));
4050: }
4051: 
4052: const StringUtil::EnumStringLiteral *GetVerifyExistenceTypeValues() {
4053: 	static constexpr StringUtil::EnumStringLiteral values[] {
4054: 		{ static_cast<uint32_t>(VerifyExistenceType::APPEND), "APPEND" },
4055: 		{ static_cast<uint32_t>(VerifyExistenceType::APPEND_FK), "APPEND_FK" },
4056: 		{ static_cast<uint32_t>(VerifyExistenceType::DELETE_FK), "DELETE_FK" }
4057: 	};
4058: 	return values;
4059: }
4060: 
4061: template<>
4062: const char* EnumUtil::ToChars<VerifyExistenceType>(VerifyExistenceType value) {
4063: 	return StringUtil::EnumToString(GetVerifyExistenceTypeValues(), 3, "VerifyExistenceType", static_cast<uint32_t>(value));
4064: }
4065: 
4066: template<>
4067: VerifyExistenceType EnumUtil::FromString<VerifyExistenceType>(const char *value) {
4068: 	return static_cast<VerifyExistenceType>(StringUtil::StringToEnum(GetVerifyExistenceTypeValues(), 3, "VerifyExistenceType", value));
4069: }
4070: 
4071: const StringUtil::EnumStringLiteral *GetWALTypeValues() {
4072: 	static constexpr StringUtil::EnumStringLiteral values[] {
4073: 		{ static_cast<uint32_t>(WALType::INVALID), "INVALID" },
4074: 		{ static_cast<uint32_t>(WALType::CREATE_TABLE), "CREATE_TABLE" },
4075: 		{ static_cast<uint32_t>(WALType::DROP_TABLE), "DROP_TABLE" },
4076: 		{ static_cast<uint32_t>(WALType::CREATE_SCHEMA), "CREATE_SCHEMA" },
4077: 		{ static_cast<uint32_t>(WALType::DROP_SCHEMA), "DROP_SCHEMA" },
4078: 		{ static_cast<uint32_t>(WALType::CREATE_VIEW), "CREATE_VIEW" },
4079: 		{ static_cast<uint32_t>(WALType::DROP_VIEW), "DROP_VIEW" },
4080: 		{ static_cast<uint32_t>(WALType::CREATE_SEQUENCE), "CREATE_SEQUENCE" },
4081: 		{ static_cast<uint32_t>(WALType::DROP_SEQUENCE), "DROP_SEQUENCE" },
4082: 		{ static_cast<uint32_t>(WALType::SEQUENCE_VALUE), "SEQUENCE_VALUE" },
4083: 		{ static_cast<uint32_t>(WALType::CREATE_MACRO), "CREATE_MACRO" },
4084: 		{ static_cast<uint32_t>(WALType::DROP_MACRO), "DROP_MACRO" },
4085: 		{ static_cast<uint32_t>(WALType::CREATE_TYPE), "CREATE_TYPE" },
4086: 		{ static_cast<uint32_t>(WALType::DROP_TYPE), "DROP_TYPE" },
4087: 		{ static_cast<uint32_t>(WALType::ALTER_INFO), "ALTER_INFO" },
4088: 		{ static_cast<uint32_t>(WALType::CREATE_TABLE_MACRO), "CREATE_TABLE_MACRO" },
4089: 		{ static_cast<uint32_t>(WALType::DROP_TABLE_MACRO), "DROP_TABLE_MACRO" },
4090: 		{ static_cast<uint32_t>(WALType::CREATE_INDEX), "CREATE_INDEX" },
4091: 		{ static_cast<uint32_t>(WALType::DROP_INDEX), "DROP_INDEX" },
4092: 		{ static_cast<uint32_t>(WALType::USE_TABLE), "USE_TABLE" },
4093: 		{ static_cast<uint32_t>(WALType::INSERT_TUPLE), "INSERT_TUPLE" },
4094: 		{ static_cast<uint32_t>(WALType::DELETE_TUPLE), "DELETE_TUPLE" },
4095: 		{ static_cast<uint32_t>(WALType::UPDATE_TUPLE), "UPDATE_TUPLE" },
4096: 		{ static_cast<uint32_t>(WALType::ROW_GROUP_DATA), "ROW_GROUP_DATA" },
4097: 		{ static_cast<uint32_t>(WALType::WAL_VERSION), "WAL_VERSION" },
4098: 		{ static_cast<uint32_t>(WALType::CHECKPOINT), "CHECKPOINT" },
4099: 		{ static_cast<uint32_t>(WALType::WAL_FLUSH), "WAL_FLUSH" }
4100: 	};
4101: 	return values;
4102: }
4103: 
4104: template<>
4105: const char* EnumUtil::ToChars<WALType>(WALType value) {
4106: 	return StringUtil::EnumToString(GetWALTypeValues(), 27, "WALType", static_cast<uint32_t>(value));
4107: }
4108: 
4109: template<>
4110: WALType EnumUtil::FromString<WALType>(const char *value) {
4111: 	return static_cast<WALType>(StringUtil::StringToEnum(GetWALTypeValues(), 27, "WALType", value));
4112: }
4113: 
4114: const StringUtil::EnumStringLiteral *GetWindowAggregationModeValues() {
4115: 	static constexpr StringUtil::EnumStringLiteral values[] {
4116: 		{ static_cast<uint32_t>(WindowAggregationMode::WINDOW), "WINDOW" },
4117: 		{ static_cast<uint32_t>(WindowAggregationMode::COMBINE), "COMBINE" },
4118: 		{ static_cast<uint32_t>(WindowAggregationMode::SEPARATE), "SEPARATE" }
4119: 	};
4120: 	return values;
4121: }
4122: 
4123: template<>
4124: const char* EnumUtil::ToChars<WindowAggregationMode>(WindowAggregationMode value) {
4125: 	return StringUtil::EnumToString(GetWindowAggregationModeValues(), 3, "WindowAggregationMode", static_cast<uint32_t>(value));
4126: }
4127: 
4128: template<>
4129: WindowAggregationMode EnumUtil::FromString<WindowAggregationMode>(const char *value) {
4130: 	return static_cast<WindowAggregationMode>(StringUtil::StringToEnum(GetWindowAggregationModeValues(), 3, "WindowAggregationMode", value));
4131: }
4132: 
4133: const StringUtil::EnumStringLiteral *GetWindowBoundaryValues() {
4134: 	static constexpr StringUtil::EnumStringLiteral values[] {
4135: 		{ static_cast<uint32_t>(WindowBoundary::INVALID), "INVALID" },
4136: 		{ static_cast<uint32_t>(WindowBoundary::UNBOUNDED_PRECEDING), "UNBOUNDED_PRECEDING" },
4137: 		{ static_cast<uint32_t>(WindowBoundary::UNBOUNDED_FOLLOWING), "UNBOUNDED_FOLLOWING" },
4138: 		{ static_cast<uint32_t>(WindowBoundary::CURRENT_ROW_RANGE), "CURRENT_ROW_RANGE" },
4139: 		{ static_cast<uint32_t>(WindowBoundary::CURRENT_ROW_ROWS), "CURRENT_ROW_ROWS" },
4140: 		{ static_cast<uint32_t>(WindowBoundary::EXPR_PRECEDING_ROWS), "EXPR_PRECEDING_ROWS" },
4141: 		{ static_cast<uint32_t>(WindowBoundary::EXPR_FOLLOWING_ROWS), "EXPR_FOLLOWING_ROWS" },
4142: 		{ static_cast<uint32_t>(WindowBoundary::EXPR_PRECEDING_RANGE), "EXPR_PRECEDING_RANGE" },
4143: 		{ static_cast<uint32_t>(WindowBoundary::EXPR_FOLLOWING_RANGE), "EXPR_FOLLOWING_RANGE" }
4144: 	};
4145: 	return values;
4146: }
4147: 
4148: template<>
4149: const char* EnumUtil::ToChars<WindowBoundary>(WindowBoundary value) {
4150: 	return StringUtil::EnumToString(GetWindowBoundaryValues(), 9, "WindowBoundary", static_cast<uint32_t>(value));
4151: }
4152: 
4153: template<>
4154: WindowBoundary EnumUtil::FromString<WindowBoundary>(const char *value) {
4155: 	return static_cast<WindowBoundary>(StringUtil::StringToEnum(GetWindowBoundaryValues(), 9, "WindowBoundary", value));
4156: }
4157: 
4158: const StringUtil::EnumStringLiteral *GetWindowExcludeModeValues() {
4159: 	static constexpr StringUtil::EnumStringLiteral values[] {
4160: 		{ static_cast<uint32_t>(WindowExcludeMode::NO_OTHER), "NO_OTHER" },
4161: 		{ static_cast<uint32_t>(WindowExcludeMode::CURRENT_ROW), "CURRENT_ROW" },
4162: 		{ static_cast<uint32_t>(WindowExcludeMode::GROUP), "GROUP" },
4163: 		{ static_cast<uint32_t>(WindowExcludeMode::TIES), "TIES" }
4164: 	};
4165: 	return values;
4166: }
4167: 
4168: template<>
4169: const char* EnumUtil::ToChars<WindowExcludeMode>(WindowExcludeMode value) {
4170: 	return StringUtil::EnumToString(GetWindowExcludeModeValues(), 4, "WindowExcludeMode", static_cast<uint32_t>(value));
4171: }
4172: 
4173: template<>
4174: WindowExcludeMode EnumUtil::FromString<WindowExcludeMode>(const char *value) {
4175: 	return static_cast<WindowExcludeMode>(StringUtil::StringToEnum(GetWindowExcludeModeValues(), 4, "WindowExcludeMode", value));
4176: }
4177: 
4178: }
4179: 
[end of src/common/enum_util.cpp]
[start of src/common/random_engine.cpp]
1: #include "duckdb/common/random_engine.hpp"
2: #include "duckdb/common/numeric_utils.hpp"
3: #include "pcg_random.hpp"
4: #include <random>
5: 
6: namespace duckdb {
7: 
8: struct RandomState {
9: 	RandomState() {
10: 	}
11: 
12: 	pcg32 pcg;
13: };
14: 
15: RandomEngine::RandomEngine(int64_t seed) : random_state(make_uniq<RandomState>()) {
16: 	if (seed < 0) {
17: 		random_state->pcg.seed(pcg_extras::seed_seq_from<std::random_device>());
18: 	} else {
19: 		random_state->pcg.seed(NumericCast<uint64_t>(seed));
20: 	}
21: }
22: 
23: RandomEngine::~RandomEngine() {
24: }
25: 
26: double RandomEngine::NextRandom(double min, double max) {
27: 	D_ASSERT(max >= min);
28: 	return min + (NextRandom() * (max - min));
29: }
30: 
31: double RandomEngine::NextRandom() {
32: 	auto uint64 = NextRandomInteger64();
33: 	return std::ldexp(uint64, -64);
34: }
35: 
36: double RandomEngine::NextRandom32(double min, double max) {
37: 	D_ASSERT(max >= min);
38: 	return min + (NextRandom32() * (max - min));
39: }
40: 
41: double RandomEngine::NextRandom32() {
42: 	auto uint32 = NextRandomInteger();
43: 	return std::ldexp(uint32, -32);
44: }
45: 
46: uint32_t RandomEngine::NextRandomInteger() {
47: 	return random_state->pcg();
48: }
49: 
50: uint64_t RandomEngine::NextRandomInteger64() {
51: 	return (static_cast<uint64_t>(NextRandomInteger()) << UINT64_C(32)) | static_cast<uint64_t>(NextRandomInteger());
52: }
53: 
54: uint32_t RandomEngine::NextRandomInteger(uint32_t min, uint32_t max) {
55: 	return min + static_cast<uint32_t>(NextRandom() * double(max - min));
56: }
57: 
58: void RandomEngine::SetSeed(uint32_t seed) {
59: 	random_state->pcg.seed(seed);
60: }
61: 
62: } // namespace duckdb
[end of src/common/random_engine.cpp]
[start of src/execution/CMakeLists.txt]
1: add_subdirectory(expression_executor)
2: add_subdirectory(nested_loop_join)
3: add_subdirectory(operator)
4: add_subdirectory(physical_plan)
5: add_subdirectory(index)
6: 
7: add_library_unity(
8:   duckdb_execution
9:   OBJECT
10:   adaptive_filter.cpp
11:   aggregate_hashtable.cpp
12:   base_aggregate_hashtable.cpp
13:   column_binding_resolver.cpp
14:   expression_executor.cpp
15:   expression_executor_state.cpp
16:   join_hashtable.cpp
17:   perfect_aggregate_hashtable.cpp
18:   physical_operator.cpp
19:   physical_plan_generator.cpp
20:   radix_partitioned_hashtable.cpp
21:   reservoir_sample.cpp)
22: set(ALL_OBJECT_FILES
23:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_execution>
24:     PARENT_SCOPE)
[end of src/execution/CMakeLists.txt]
[start of src/execution/reservoir_sample.cpp]
1: #include "duckdb/execution/reservoir_sample.hpp"
2: #include "duckdb/common/types/data_chunk.hpp"
3: #include "duckdb/common/pair.hpp"
4: 
5: namespace duckdb {
6: 
7: void ReservoirChunk::Serialize(Serializer &serializer) const {
8: 	chunk.Serialize(serializer);
9: }
10: 
11: unique_ptr<ReservoirChunk> ReservoirChunk::Deserialize(Deserializer &deserializer) {
12: 	auto result = make_uniq<ReservoirChunk>();
13: 	result->chunk.Deserialize(deserializer);
14: 	return result;
15: }
16: 
17: ReservoirSample::ReservoirSample(Allocator &allocator, idx_t sample_count, int64_t seed)
18:     : BlockingSample(seed), allocator(allocator), sample_count(sample_count), reservoir_initialized(false) {
19: }
20: 
21: ReservoirSample::ReservoirSample(idx_t sample_count, int64_t seed)
22:     : ReservoirSample(Allocator::DefaultAllocator(), sample_count, seed) {
23: }
24: 
25: void ReservoirSample::AddToReservoir(DataChunk &input) {
26: 	if (sample_count == 0) {
27: 		// sample count is 0, means no samples were requested
28: 		return;
29: 	}
30: 	old_base_reservoir_sample.num_entries_seen_total += input.size();
31: 	// Input: A population V of n weighted items
32: 	// Output: A reservoir R with a size m
33: 	// 1: The first m items of V are inserted into R
34: 	// first we need to check if the reservoir already has "m" elements
35: 	if (!reservoir_data_chunk || reservoir_data_chunk->size() < sample_count) {
36: 		if (FillReservoir(input) == 0) {
37: 			// entire chunk was consumed by reservoir
38: 			return;
39: 		}
40: 	}
41: 	D_ASSERT(reservoir_data_chunk);
42: 	D_ASSERT(reservoir_data_chunk->size() == sample_count);
43: 	// Initialize the weights if they have not been already
44: 	if (old_base_reservoir_sample.reservoir_weights.empty()) {
45: 		old_base_reservoir_sample.InitializeReservoir(reservoir_data_chunk->size(), sample_count);
46: 	}
47: 	// find the position of next_index_to_sample relative to number of seen entries (num_entries_to_skip_b4_next_sample)
48: 	idx_t remaining = input.size();
49: 	idx_t base_offset = 0;
50: 	while (true) {
51: 		idx_t offset = old_base_reservoir_sample.next_index_to_sample -
52: 		               old_base_reservoir_sample.num_entries_to_skip_b4_next_sample;
53: 		if (offset >= remaining) {
54: 			// not in this chunk! increment current count and go to the next chunk
55: 			old_base_reservoir_sample.num_entries_to_skip_b4_next_sample += remaining;
56: 			return;
57: 		}
58: 		// in this chunk! replace the element
59: 		ReplaceElement(input, base_offset + offset);
60: 		// shift the chunk forward
61: 		remaining -= offset;
62: 		base_offset += offset;
63: 	}
64: }
65: 
66: unique_ptr<DataChunk> ReservoirSample::GetChunk() {
67: 	if (!reservoir_data_chunk || reservoir_data_chunk->size() == 0) {
68: 		return nullptr;
69: 	}
70: 	auto collected_sample_count = reservoir_data_chunk->size();
71: 	if (collected_sample_count > STANDARD_VECTOR_SIZE) {
72: 		// get from the back to avoid creating two selection vectors
73: 		// one to return the first STANDARD_VECTOR_SIZE
74: 		// another to replace the reservoir_data_chunk with the first STANDARD VECTOR SIZE missing
75: 		auto ret = make_uniq<DataChunk>();
76: 		auto samples_remaining = collected_sample_count - STANDARD_VECTOR_SIZE;
77: 		auto reservoir_types = reservoir_data_chunk->GetTypes();
78: 		SelectionVector sel(STANDARD_VECTOR_SIZE);
79: 		for (idx_t i = samples_remaining; i < collected_sample_count; i++) {
80: 			sel.set_index(i - samples_remaining, i);
81: 		}
82: 		ret->Initialize(allocator, reservoir_types);
83: 		ret->Slice(*reservoir_data_chunk, sel, STANDARD_VECTOR_SIZE);
84: 		ret->SetCardinality(STANDARD_VECTOR_SIZE);
85: 		// reduce capacity and cardinality of the sample data chunk
86: 		reservoir_data_chunk->SetCardinality(samples_remaining);
87: 		return ret;
88: 	}
89: 	return std::move(reservoir_data_chunk);
90: }
91: 
92: void ReservoirSample::ReplaceElement(DataChunk &input, idx_t index_in_chunk, double with_weight) {
93: 	// replace the entry in the reservoir
94: 	// 8. The item in R with the minimum key is replaced by item vi
95: 	D_ASSERT(input.ColumnCount() == reservoir_data_chunk->ColumnCount());
96: 	for (idx_t col_idx = 0; col_idx < input.ColumnCount(); col_idx++) {
97: 		reservoir_data_chunk->SetValue(col_idx, old_base_reservoir_sample.min_weighted_entry_index,
98: 		                               input.GetValue(col_idx, index_in_chunk));
99: 	}
100: 	old_base_reservoir_sample.ReplaceElement(with_weight);
101: }
102: 
103: void ReservoirSample::InitializeReservoir(DataChunk &input) {
104: 	reservoir_data_chunk = make_uniq<DataChunk>();
105: 	reservoir_data_chunk->Initialize(allocator, input.GetTypes(), sample_count);
106: 	for (idx_t col_idx = 0; col_idx < reservoir_data_chunk->ColumnCount(); col_idx++) {
107: 		FlatVector::Validity(reservoir_data_chunk->data[col_idx]).Initialize(sample_count);
108: 	}
109: 	reservoir_initialized = true;
110: }
111: 
112: idx_t ReservoirSample::FillReservoir(DataChunk &input) {
113: 	idx_t chunk_count = input.size();
114: 	input.Flatten();
115: 	auto num_added_samples = reservoir_data_chunk ? reservoir_data_chunk->size() : 0;
116: 	D_ASSERT(num_added_samples <= sample_count);
117: 
118: 	// required count is what we still need to add to the reservoir
119: 	idx_t required_count;
120: 	if (num_added_samples + chunk_count >= sample_count) {
121: 		// have to limit the count of the chunk
122: 		required_count = sample_count - num_added_samples;
123: 	} else {
124: 		// we copy the entire chunk
125: 		required_count = chunk_count;
126: 	}
127: 	input.SetCardinality(required_count);
128: 
129: 	// initialize the reservoir
130: 	if (!reservoir_initialized) {
131: 		InitializeReservoir(input);
132: 	}
133: 	reservoir_data_chunk->Append(input, false, nullptr, required_count);
134: 	old_base_reservoir_sample.InitializeReservoir(required_count, sample_count);
135: 
136: 	// check if there are still elements remaining in the Input data chunk that should be
137: 	// randomly sampled and potentially added. This happens if we are on a boundary
138: 	// for example, input.size() is 1024, but our sample size is 10
139: 	if (required_count == chunk_count) {
140: 		// we are done here
141: 		return 0;
142: 	}
143: 	// we still need to process a part of the chunk
144: 	// create a selection vector of the remaining elements
145: 	SelectionVector sel(STANDARD_VECTOR_SIZE);
146: 	for (idx_t i = required_count; i < chunk_count; i++) {
147: 		sel.set_index(i - required_count, i);
148: 	}
149: 	// slice the input vector and continue
150: 	input.Slice(sel, chunk_count - required_count);
151: 	return input.size();
152: }
153: 
154: void ReservoirSample::Finalize() {
155: 	return;
156: }
157: 
158: ReservoirSamplePercentage::ReservoirSamplePercentage(Allocator &allocator, double percentage, int64_t seed)
159:     : BlockingSample(seed), allocator(allocator), sample_percentage(percentage / 100.0), current_count(0),
160:       is_finalized(false) {
161: 	reservoir_sample_size = idx_t(sample_percentage * RESERVOIR_THRESHOLD);
162: 	current_sample = make_uniq<ReservoirSample>(allocator, reservoir_sample_size, random.NextRandomInteger());
163: }
164: 
165: ReservoirSamplePercentage::ReservoirSamplePercentage(double percentage, int64_t seed)
166:     : ReservoirSamplePercentage(Allocator::DefaultAllocator(), percentage, seed) {
167: }
168: 
169: void ReservoirSamplePercentage::AddToReservoir(DataChunk &input) {
170: 	old_base_reservoir_sample.num_entries_seen_total += input.size();
171: 	if (current_count + input.size() > RESERVOIR_THRESHOLD) {
172: 		// we don't have enough space in our current reservoir
173: 		// first check what we still need to append to the current sample
174: 		idx_t append_to_current_sample_count = RESERVOIR_THRESHOLD - current_count;
175: 		idx_t append_to_next_sample = input.size() - append_to_current_sample_count;
176: 		if (append_to_current_sample_count > 0) {
177: 			// we have elements remaining, first add them to the current sample
178: 			if (append_to_next_sample > 0) {
179: 				// we need to also add to the next sample
180: 				DataChunk new_chunk;
181: 				new_chunk.InitializeEmpty(input.GetTypes());
182: 				new_chunk.Slice(input, *FlatVector::IncrementalSelectionVector(), append_to_current_sample_count);
183: 				new_chunk.Flatten();
184: 				current_sample->AddToReservoir(new_chunk);
185: 			} else {
186: 				input.Flatten();
187: 				input.SetCardinality(append_to_current_sample_count);
188: 				current_sample->AddToReservoir(input);
189: 			}
190: 		}
191: 		if (append_to_next_sample > 0) {
192: 			// slice the input for the remainder
193: 			SelectionVector sel(append_to_next_sample);
194: 			for (idx_t i = append_to_current_sample_count; i < append_to_next_sample + append_to_current_sample_count;
195: 			     i++) {
196: 				sel.set_index(i - append_to_current_sample_count, i);
197: 			}
198: 			input.Slice(sel, append_to_next_sample);
199: 		}
200: 		// now our first sample is filled: append it to the set of finished samples
201: 		finished_samples.push_back(std::move(current_sample));
202: 
203: 		// allocate a new sample, and potentially add the remainder of the current input to that sample
204: 		current_sample = make_uniq<ReservoirSample>(allocator, reservoir_sample_size, random.NextRandomInteger());
205: 		if (append_to_next_sample > 0) {
206: 			current_sample->AddToReservoir(input);
207: 		}
208: 		current_count = append_to_next_sample;
209: 	} else {
210: 		// we can just append to the current sample
211: 		current_count += input.size();
212: 		current_sample->AddToReservoir(input);
213: 	}
214: }
215: 
216: unique_ptr<DataChunk> ReservoirSamplePercentage::GetChunk() {
217: 	if (!is_finalized) {
218: 		Finalize();
219: 	}
220: 	while (!finished_samples.empty()) {
221: 		auto &front = finished_samples.front();
222: 		auto chunk = front->GetChunk();
223: 		if (chunk && chunk->size() > 0) {
224: 			return chunk;
225: 		}
226: 		// move to the next sample
227: 		finished_samples.erase(finished_samples.begin());
228: 	}
229: 	return nullptr;
230: }
231: 
232: void ReservoirSamplePercentage::Finalize() {
233: 	// need to finalize the current sample, if any
234: 	// we are finializing, so we are starting to return chunks. Our last chunk has
235: 	// sample_percentage * RESERVOIR_THRESHOLD entries that hold samples.
236: 	// if our current count is less than the sample_percentage * RESERVOIR_THRESHOLD
237: 	// then we have sampled too much for the current_sample and we need to redo the sample
238: 	// otherwise we can just push the current sample back
239: 	// Imagine sampling 70% of 100 rows (so 70 rows). We allocate sample_percentage * RESERVOIR_THRESHOLD
240: 	// -----------------------------------------
241: 	auto sampled_more_than_required =
242: 	    static_cast<double>(current_count) > sample_percentage * RESERVOIR_THRESHOLD || finished_samples.empty();
243: 	if (current_count > 0 && sampled_more_than_required) {
244: 		// create a new sample
245: 		auto new_sample_size = idx_t(round(sample_percentage * static_cast<double>(current_count)));
246: 		auto new_sample = make_uniq<ReservoirSample>(allocator, new_sample_size, random.NextRandomInteger());
247: 		while (true) {
248: 			auto chunk = current_sample->GetChunk();
249: 			if (!chunk || chunk->size() == 0) {
250: 				break;
251: 			}
252: 			new_sample->AddToReservoir(*chunk);
253: 		}
254: 		finished_samples.push_back(std::move(new_sample));
255: 	} else {
256: 		finished_samples.push_back(std::move(current_sample));
257: 	}
258: 	// when finalizing, current_sample is null. All samples are now in finished samples.
259: 	current_sample = nullptr;
260: 	is_finalized = true;
261: }
262: 
263: BaseReservoirSampling::BaseReservoirSampling(int64_t seed) : random(seed) {
264: 	next_index_to_sample = 0;
265: 	min_weight_threshold = 0;
266: 	min_weighted_entry_index = 0;
267: 	num_entries_to_skip_b4_next_sample = 0;
268: 	num_entries_seen_total = 0;
269: }
270: 
271: BaseReservoirSampling::BaseReservoirSampling() : BaseReservoirSampling(-1) {
272: }
273: 
274: void BaseReservoirSampling::InitializeReservoir(idx_t cur_size, idx_t sample_size) {
275: 	//! 1: The first m items of V are inserted into R
276: 	//! first we need to check if the reservoir already has "m" elements
277: 	if (cur_size == sample_size) {
278: 		//! 2. For each item vi ∈ R: Calculate a key ki = random(0, 1)
279: 		//! we then define the threshold to enter the reservoir T_w as the minimum key of R
280: 		//! we use a priority queue to extract the minimum key in O(1) time
281: 		for (idx_t i = 0; i < sample_size; i++) {
282: 			double k_i = random.NextRandom();
283: 			reservoir_weights.emplace(-k_i, i);
284: 		}
285: 		SetNextEntry();
286: 	}
287: }
288: 
289: void BaseReservoirSampling::SetNextEntry() {
290: 	//! 4. Let r = random(0, 1) and Xw = log(r) / log(T_w)
291: 	auto &min_key = reservoir_weights.top();
292: 	double t_w = -min_key.first;
293: 	double r = random.NextRandom();
294: 	double x_w = log(r) / log(t_w);
295: 	//! 5. From the current item vc skip items until item vi , such that:
296: 	//! 6. wc +wc+1 +···+wi−1 < Xw <= wc +wc+1 +···+wi−1 +wi
297: 	//! since all our weights are 1 (uniform sampling), we can just determine the amount of elements to skip
298: 	min_weight_threshold = t_w;
299: 	min_weighted_entry_index = min_key.second;
300: 	next_index_to_sample = MaxValue<idx_t>(1, idx_t(round(x_w)));
301: 	num_entries_to_skip_b4_next_sample = 0;
302: }
303: 
304: void BaseReservoirSampling::ReplaceElement(double with_weight) {
305: 	//! replace the entry in the reservoir
306: 	//! pop the minimum entry
307: 	reservoir_weights.pop();
308: 	//! now update the reservoir
309: 	//! 8. Let tw = Tw i , r2 = random(tw,1) and vi’s key: ki = (r2)1/wi
310: 	//! 9. The new threshold Tw is the new minimum key of R
311: 	//! we generate a random number between (min_weight_threshold, 1)
312: 	double r2 = random.NextRandom(min_weight_threshold, 1);
313: 
314: 	//! if we are merging two reservoir samples use the weight passed
315: 	if (with_weight >= 0) {
316: 		r2 = with_weight;
317: 	}
318: 	//! now we insert the new weight into the reservoir
319: 	reservoir_weights.emplace(-r2, min_weighted_entry_index);
320: 	//! we update the min entry with the new min entry in the reservoir
321: 	SetNextEntry();
322: }
323: 
324: } // namespace duckdb
[end of src/execution/reservoir_sample.cpp]
[start of src/function/table/system/CMakeLists.txt]
1: add_library_unity(
2:   duckdb_table_func_system
3:   OBJECT
4:   duckdb_columns.cpp
5:   duckdb_constraints.cpp
6:   duckdb_databases.cpp
7:   duckdb_dependencies.cpp
8:   duckdb_extensions.cpp
9:   duckdb_functions.cpp
10:   duckdb_keywords.cpp
11:   duckdb_indexes.cpp
12:   duckdb_memory.cpp
13:   duckdb_optimizers.cpp
14:   duckdb_schemas.cpp
15:   duckdb_secrets.cpp
16:   duckdb_which_secret.cpp
17:   duckdb_sequences.cpp
18:   duckdb_settings.cpp
19:   duckdb_tables.cpp
20:   duckdb_temporary_files.cpp
21:   duckdb_types.cpp
22:   duckdb_variables.cpp
23:   duckdb_views.cpp
24:   pragma_collations.cpp
25:   pragma_database_size.cpp
26:   pragma_metadata_info.cpp
27:   pragma_storage_info.cpp
28:   pragma_table_info.cpp
29:   pragma_user_agent.cpp
30:   test_all_types.cpp
31:   test_vector_types.cpp)
32: set(ALL_OBJECT_FILES
33:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_table_func_system>
34:     PARENT_SCOPE)
[end of src/function/table/system/CMakeLists.txt]
[start of src/function/table/system_functions.cpp]
1: #include "duckdb/function/table/system_functions.hpp"
2: #include "duckdb/parser/parsed_data/create_view_info.hpp"
3: #include "duckdb/parser/query_node/select_node.hpp"
4: #include "duckdb/parser/expression/star_expression.hpp"
5: #include "duckdb/parser/tableref/table_function_ref.hpp"
6: #include "duckdb/parser/expression/function_expression.hpp"
7: #include "duckdb/catalog/catalog.hpp"
8: 
9: namespace duckdb {
10: 
11: void BuiltinFunctions::RegisterSQLiteFunctions() {
12: 	PragmaVersion::RegisterFunction(*this);
13: 	PragmaPlatform::RegisterFunction(*this);
14: 	PragmaCollations::RegisterFunction(*this);
15: 	PragmaTableInfo::RegisterFunction(*this);
16: 	PragmaStorageInfo::RegisterFunction(*this);
17: 	PragmaMetadataInfo::RegisterFunction(*this);
18: 	PragmaDatabaseSize::RegisterFunction(*this);
19: 	PragmaUserAgent::RegisterFunction(*this);
20: 
21: 	DuckDBColumnsFun::RegisterFunction(*this);
22: 	DuckDBConstraintsFun::RegisterFunction(*this);
23: 	DuckDBDatabasesFun::RegisterFunction(*this);
24: 	DuckDBFunctionsFun::RegisterFunction(*this);
25: 	DuckDBKeywordsFun::RegisterFunction(*this);
26: 	DuckDBIndexesFun::RegisterFunction(*this);
27: 	DuckDBSchemasFun::RegisterFunction(*this);
28: 	DuckDBDependenciesFun::RegisterFunction(*this);
29: 	DuckDBExtensionsFun::RegisterFunction(*this);
30: 	DuckDBMemoryFun::RegisterFunction(*this);
31: 	DuckDBOptimizersFun::RegisterFunction(*this);
32: 	DuckDBSecretsFun::RegisterFunction(*this);
33: 	DuckDBWhichSecretFun::RegisterFunction(*this);
34: 	DuckDBSequencesFun::RegisterFunction(*this);
35: 	DuckDBSettingsFun::RegisterFunction(*this);
36: 	DuckDBTablesFun::RegisterFunction(*this);
37: 	DuckDBTemporaryFilesFun::RegisterFunction(*this);
38: 	DuckDBTypesFun::RegisterFunction(*this);
39: 	DuckDBVariablesFun::RegisterFunction(*this);
40: 	DuckDBViewsFun::RegisterFunction(*this);
41: 	TestAllTypesFun::RegisterFunction(*this);
42: 	TestVectorTypesFun::RegisterFunction(*this);
43: }
44: 
45: } // namespace duckdb
[end of src/function/table/system_functions.cpp]
[start of src/include/duckdb/catalog/catalog_entry/duck_table_entry.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/catalog/catalog_entry/duck_table_entry.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
12: #include "duckdb/parser/constraints/unique_constraint.hpp"
13: #include "duckdb/planner/constraints/bound_unique_constraint.hpp"
14: 
15: namespace duckdb {
16: 
17: struct AddConstraintInfo;
18: 
19: //! A table catalog entry
20: class DuckTableEntry : public TableCatalogEntry {
21: public:
22: 	//! Create a TableCatalogEntry and initialize storage for it
23: 	DuckTableEntry(Catalog &catalog, SchemaCatalogEntry &schema, BoundCreateTableInfo &info,
24: 	               shared_ptr<DataTable> inherited_storage = nullptr);
25: 
26: public:
27: 	unique_ptr<CatalogEntry> AlterEntry(ClientContext &context, AlterInfo &info) override;
28: 	unique_ptr<CatalogEntry> AlterEntry(CatalogTransaction, AlterInfo &info) override;
29: 	void UndoAlter(ClientContext &context, AlterInfo &info) override;
30: 	void Rollback(CatalogEntry &prev_entry) override;
31: 
32: 	//! Returns the underlying storage of the table
33: 	DataTable &GetStorage() override;
34: 
35: 	//! Get statistics of a column (physical or virtual) within the table
36: 	unique_ptr<BaseStatistics> GetStatistics(ClientContext &context, column_t column_id) override;
37: 
38: 	unique_ptr<CatalogEntry> Copy(ClientContext &context) const override;
39: 
40: 	void SetAsRoot() override;
41: 
42: 	void CommitAlter(string &column_name);
43: 	void CommitDrop();
44: 
45: 	TableFunction GetScanFunction(ClientContext &context, unique_ptr<FunctionData> &bind_data) override;
46: 
47: 	vector<ColumnSegmentInfo> GetColumnSegmentInfo() override;
48: 
49: 	TableStorageInfo GetStorageInfo(ClientContext &context) override;
50: 
51: 	bool IsDuckTable() const override {
52: 		return true;
53: 	}
54: 
55: private:
56: 	unique_ptr<CatalogEntry> RenameColumn(ClientContext &context, RenameColumnInfo &info);
57: 	unique_ptr<CatalogEntry> AddColumn(ClientContext &context, AddColumnInfo &info);
58: 	unique_ptr<CatalogEntry> RemoveColumn(ClientContext &context, RemoveColumnInfo &info);
59: 	unique_ptr<CatalogEntry> SetDefault(ClientContext &context, SetDefaultInfo &info);
60: 	unique_ptr<CatalogEntry> ChangeColumnType(ClientContext &context, ChangeColumnTypeInfo &info);
61: 	unique_ptr<CatalogEntry> SetNotNull(ClientContext &context, SetNotNullInfo &info);
62: 	unique_ptr<CatalogEntry> DropNotNull(ClientContext &context, DropNotNullInfo &info);
63: 	unique_ptr<CatalogEntry> AddForeignKeyConstraint(optional_ptr<ClientContext> context, AlterForeignKeyInfo &info);
64: 	unique_ptr<CatalogEntry> DropForeignKeyConstraint(ClientContext &context, AlterForeignKeyInfo &info);
65: 	unique_ptr<CatalogEntry> SetColumnComment(ClientContext &context, SetColumnCommentInfo &info);
66: 	unique_ptr<CatalogEntry> AddConstraint(ClientContext &context, AddConstraintInfo &info);
67: 
68: 	void UpdateConstraintsOnColumnDrop(const LogicalIndex &removed_index, const vector<LogicalIndex> &adjusted_indices,
69: 	                                   const RemoveColumnInfo &info, CreateTableInfo &create_info,
70: 	                                   const vector<unique_ptr<BoundConstraint>> &bound_constraints, bool is_generated);
71: 
72: private:
73: 	//! A reference to the underlying storage unit used for this table
74: 	shared_ptr<DataTable> storage;
75: 	//! Manages dependencies of the individual columns of the table
76: 	ColumnDependencyManager column_dependency_manager;
77: };
78: } // namespace duckdb
[end of src/include/duckdb/catalog/catalog_entry/duck_table_entry.hpp]
[start of src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/catalog/catalog_entry/table_catalog_entry.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/standard_entry.hpp"
12: #include "duckdb/common/unordered_map.hpp"
13: #include "duckdb/parser/column_list.hpp"
14: #include "duckdb/parser/constraint.hpp"
15: #include "duckdb/planner/bound_constraint.hpp"
16: #include "duckdb/planner/expression.hpp"
17: #include "duckdb/common/case_insensitive_map.hpp"
18: #include "duckdb/catalog/catalog_entry/table_column_type.hpp"
19: #include "duckdb/catalog/catalog_entry/column_dependency_manager.hpp"
20: 
21: namespace duckdb {
22: 
23: class DataTable;
24: 
25: struct RenameColumnInfo;
26: struct AddColumnInfo;
27: struct RemoveColumnInfo;
28: struct SetDefaultInfo;
29: struct ChangeColumnTypeInfo;
30: struct AlterForeignKeyInfo;
31: struct SetNotNullInfo;
32: struct DropNotNullInfo;
33: struct SetColumnCommentInfo;
34: struct CreateTableInfo;
35: struct BoundCreateTableInfo;
36: 
37: class TableFunction;
38: struct FunctionData;
39: 
40: class Binder;
41: struct ColumnSegmentInfo;
42: class TableStorageInfo;
43: 
44: class LogicalGet;
45: class LogicalProjection;
46: class LogicalUpdate;
47: 
48: //! A table catalog entry
49: class TableCatalogEntry : public StandardEntry {
50: public:
51: 	static constexpr const CatalogType Type = CatalogType::TABLE_ENTRY;
52: 	static constexpr const char *Name = "table";
53: 
54: public:
55: 	//! Create a TableCatalogEntry and initialize storage for it
56: 	DUCKDB_API TableCatalogEntry(Catalog &catalog, SchemaCatalogEntry &schema, CreateTableInfo &info);
57: 
58: public:
59: 	DUCKDB_API unique_ptr<CreateInfo> GetInfo() const override;
60: 
61: 	DUCKDB_API bool HasGeneratedColumns() const;
62: 
63: 	//! Returns whether or not a column with the given name exists
64: 	DUCKDB_API bool ColumnExists(const string &name) const;
65: 	//! Returns a reference to the column of the specified name. Throws an
66: 	//! exception if the column does not exist.
67: 	DUCKDB_API const ColumnDefinition &GetColumn(const string &name) const;
68: 	//! Returns a reference to the column of the specified logical index. Throws an
69: 	//! exception if the column does not exist.
70: 	DUCKDB_API const ColumnDefinition &GetColumn(LogicalIndex idx) const;
71: 	//! Returns a list of types of the table, excluding generated columns
72: 	DUCKDB_API vector<LogicalType> GetTypes() const;
73: 	//! Returns a list of the columns of the table
74: 	DUCKDB_API const ColumnList &GetColumns() const;
75: 	//! Returns the underlying storage of the table
76: 	virtual DataTable &GetStorage();
77: 
78: 	//! Returns a list of the constraints of the table
79: 	DUCKDB_API const vector<unique_ptr<Constraint>> &GetConstraints() const;
80: 	DUCKDB_API string ToSQL() const override;
81: 
82: 	//! Get statistics of a column (physical or virtual) within the table
83: 	virtual unique_ptr<BaseStatistics> GetStatistics(ClientContext &context, column_t column_id) = 0;
84: 
85: 	//! Returns the column index of the specified column name.
86: 	//! If the column does not exist:
87: 	//! If if_column_exists is true, returns DConstants::INVALID_INDEX
88: 	//! If if_column_exists is false, throws an exception
89: 	DUCKDB_API LogicalIndex GetColumnIndex(string &name, bool if_exists = false) const;
90: 
91: 	//! Returns the scan function that can be used to scan the given table
92: 	virtual TableFunction GetScanFunction(ClientContext &context, unique_ptr<FunctionData> &bind_data) = 0;
93: 
94: 	virtual bool IsDuckTable() const {
95: 		return false;
96: 	}
97: 
98: 	DUCKDB_API static string ColumnsToSQL(const ColumnList &columns, const vector<unique_ptr<Constraint>> &constraints);
99: 
100: 	//! Returns the expression string list of the column names e.g. (col1, col2, col3)
101: 	static string ColumnNamesToSQL(const ColumnList &columns);
102: 
103: 	//! Returns a list of segment information for this table, if exists
104: 	virtual vector<ColumnSegmentInfo> GetColumnSegmentInfo();
105: 
106: 	//! Returns the storage info of this table
107: 	virtual TableStorageInfo GetStorageInfo(ClientContext &context) = 0;
108: 
109: 	virtual void BindUpdateConstraints(Binder &binder, LogicalGet &get, LogicalProjection &proj, LogicalUpdate &update,
110: 	                                   ClientContext &context);
111: 
112: 	//! Returns a pointer to the table's primary key, if exists, else nullptr.
113: 	optional_ptr<Constraint> GetPrimaryKey() const;
114: 	//! Returns true, if the table has a primary key, else false.
115: 	bool HasPrimaryKey() const;
116: 
117: protected:
118: 	//! A list of columns that are part of this table
119: 	ColumnList columns;
120: 	//! A list of constraints that are part of this table
121: 	vector<unique_ptr<Constraint>> constraints;
122: };
123: } // namespace duckdb
[end of src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp]
[start of src/include/duckdb/common/enum_util.hpp]
1: //-------------------------------------------------------------------------
2: // This file is automatically generated by scripts/generate_enum_util.py
3: // Do not edit this file manually, your changes will be overwritten
4: // If you want to exclude an enum from serialization, add it to the blacklist in the script
5: //
6: // Note: The generated code will only work properly if the enum is a top level item in the duckdb namespace
7: // If the enum is nested in a class, or in another namespace, the generated code will not compile.
8: // You should move the enum to the duckdb namespace, manually write a specialization or add it to the blacklist
9: //-------------------------------------------------------------------------
10: 
11: 
12: #pragma once
13: 
14: #include <stdint.h>
15: #include "duckdb/common/string.hpp"
16: 
17: namespace duckdb {
18: 
19: struct EnumUtil {
20:     // String -> Enum
21:     template <class T>
22:     static T FromString(const char *value) = delete;
23: 
24:     template <class T>
25:     static T FromString(const string &value) { return FromString<T>(value.c_str()); }
26: 
27:     // Enum -> String
28:     template <class T>
29:     static const char *ToChars(T value) = delete;
30: 
31:     template <class T>
32:     static string ToString(T value) { return string(ToChars<T>(value)); }
33: };
34: 
35: enum class ARTAppendMode : uint8_t;
36: 
37: enum class ARTConflictType : uint8_t;
38: 
39: enum class AccessMode : uint8_t;
40: 
41: enum class AggregateCombineType : uint8_t;
42: 
43: enum class AggregateDistinctDependent : uint8_t;
44: 
45: enum class AggregateHandling : uint8_t;
46: 
47: enum class AggregateOrderDependent : uint8_t;
48: 
49: enum class AggregateType : uint8_t;
50: 
51: enum class AlterForeignKeyType : uint8_t;
52: 
53: enum class AlterScalarFunctionType : uint8_t;
54: 
55: enum class AlterTableFunctionType : uint8_t;
56: 
57: enum class AlterTableType : uint8_t;
58: 
59: enum class AlterType : uint8_t;
60: 
61: enum class AlterViewType : uint8_t;
62: 
63: enum class AppenderType : uint8_t;
64: 
65: enum class ArrowDateTimeType : uint8_t;
66: 
67: enum class ArrowOffsetSize : uint8_t;
68: 
69: enum class ArrowTypeInfoType : uint8_t;
70: 
71: enum class ArrowVariableSizeType : uint8_t;
72: 
73: enum class BinderType : uint8_t;
74: 
75: enum class BindingMode : uint8_t;
76: 
77: enum class BitpackingMode : uint8_t;
78: 
79: enum class BlockState : uint8_t;
80: 
81: enum class CAPIResultSetType : uint8_t;
82: 
83: enum class CSVState : uint8_t;
84: 
85: enum class CTEMaterialize : uint8_t;
86: 
87: enum class CatalogLookupBehavior : uint8_t;
88: 
89: enum class CatalogType : uint8_t;
90: 
91: enum class CheckpointAbort : uint8_t;
92: 
93: enum class ChunkInfoType : uint8_t;
94: 
95: enum class ColumnDataAllocatorType : uint8_t;
96: 
97: enum class ColumnDataScanProperties : uint8_t;
98: 
99: enum class ColumnSegmentType : uint8_t;
100: 
101: enum class CompressedMaterializationDirection : uint8_t;
102: 
103: enum class CompressionType : uint8_t;
104: 
105: enum class ConflictManagerMode : uint8_t;
106: 
107: enum class ConstraintType : uint8_t;
108: 
109: enum class CopyFunctionReturnType : uint8_t;
110: 
111: enum class CopyOverwriteMode : uint8_t;
112: 
113: enum class CopyToType : uint8_t;
114: 
115: enum class DataFileType : uint8_t;
116: 
117: enum class DatePartSpecifier : uint8_t;
118: 
119: enum class DebugInitialize : uint8_t;
120: 
121: enum class DefaultOrderByNullType : uint8_t;
122: 
123: enum class DependencyEntryType : uint8_t;
124: 
125: enum class DeprecatedIndexType : uint8_t;
126: 
127: enum class DestroyBufferUpon : uint8_t;
128: 
129: enum class DistinctType : uint8_t;
130: 
131: enum class ErrorType : uint16_t;
132: 
133: enum class ExceptionFormatValueType : uint8_t;
134: 
135: enum class ExceptionType : uint8_t;
136: 
137: enum class ExplainFormat : uint8_t;
138: 
139: enum class ExplainOutputType : uint8_t;
140: 
141: enum class ExplainType : uint8_t;
142: 
143: enum class ExponentType : uint8_t;
144: 
145: enum class ExpressionClass : uint8_t;
146: 
147: enum class ExpressionType : uint8_t;
148: 
149: enum class ExtensionABIType : uint8_t;
150: 
151: enum class ExtensionInstallMode : uint8_t;
152: 
153: enum class ExtensionLoadResult : uint8_t;
154: 
155: enum class ExtensionUpdateResultTag : uint8_t;
156: 
157: enum class ExtraDropInfoType : uint8_t;
158: 
159: enum class ExtraTypeInfoType : uint8_t;
160: 
161: enum class FileBufferType : uint8_t;
162: 
163: enum class FileCompressionType : uint8_t;
164: 
165: enum class FileExpandResult : uint8_t;
166: 
167: enum class FileGlobOptions : uint8_t;
168: 
169: enum class FileLockType : uint8_t;
170: 
171: enum class FilterPropagateResult : uint8_t;
172: 
173: enum class ForeignKeyType : uint8_t;
174: 
175: enum class FunctionCollationHandling : uint8_t;
176: 
177: enum class FunctionErrors : uint8_t;
178: 
179: enum class FunctionNullHandling : uint8_t;
180: 
181: enum class FunctionStability : uint8_t;
182: 
183: enum class GateStatus : uint8_t;
184: 
185: enum class HLLStorageType : uint8_t;
186: 
187: enum class IndexConstraintType : uint8_t;
188: 
189: enum class InsertColumnOrder : uint8_t;
190: 
191: enum class InterruptMode : uint8_t;
192: 
193: enum class JoinRefType : uint8_t;
194: 
195: enum class JoinType : uint8_t;
196: 
197: enum class KeywordCategory : uint8_t;
198: 
199: enum class LimitNodeType : uint8_t;
200: 
201: enum class LoadType : uint8_t;
202: 
203: enum class LogicalOperatorType : uint8_t;
204: 
205: enum class LogicalTypeId : uint8_t;
206: 
207: enum class LookupResultType : uint8_t;
208: 
209: enum class MacroType : uint8_t;
210: 
211: enum class MapInvalidReason : uint8_t;
212: 
213: enum class MemoryTag : uint8_t;
214: 
215: enum class MetaPipelineType : uint8_t;
216: 
217: enum class MetricsType : uint8_t;
218: 
219: enum class NType : uint8_t;
220: 
221: enum class NewLineIdentifier : uint8_t;
222: 
223: enum class OnConflictAction : uint8_t;
224: 
225: enum class OnCreateConflict : uint8_t;
226: 
227: enum class OnEntryNotFound : uint8_t;
228: 
229: enum class OperatorFinalizeResultType : uint8_t;
230: 
231: enum class OperatorResultType : uint8_t;
232: 
233: enum class OptimizerType : uint32_t;
234: 
235: enum class OrderByNullType : uint8_t;
236: 
237: enum class OrderPreservationType : uint8_t;
238: 
239: enum class OrderType : uint8_t;
240: 
241: enum class OutputStream : uint8_t;
242: 
243: enum class ParseInfoType : uint8_t;
244: 
245: enum class ParserExtensionResultType : uint8_t;
246: 
247: enum class PartitionSortStage : uint8_t;
248: 
249: enum class PartitionedColumnDataType : uint8_t;
250: 
251: enum class PartitionedTupleDataType : uint8_t;
252: 
253: enum class PendingExecutionResult : uint8_t;
254: 
255: enum class PhysicalOperatorType : uint8_t;
256: 
257: enum class PhysicalType : uint8_t;
258: 
259: enum class PragmaType : uint8_t;
260: 
261: enum class PreparedParamType : uint8_t;
262: 
263: enum class PreparedStatementMode : uint8_t;
264: 
265: enum class ProfilerPrintFormat : uint8_t;
266: 
267: enum class QuantileSerializationType : uint8_t;
268: 
269: enum class QueryNodeType : uint8_t;
270: 
271: enum class QueryResultType : uint8_t;
272: 
273: enum class QuoteRule : uint8_t;
274: 
275: enum class RelationType : uint8_t;
276: 
277: enum class RenderMode : uint8_t;
278: 
279: enum class ResultModifierType : uint8_t;
280: 
281: enum class SampleMethod : uint8_t;
282: 
283: enum class SampleType : uint8_t;
284: 
285: enum class ScanType : uint8_t;
286: 
287: enum class SecretDisplayType : uint8_t;
288: 
289: enum class SecretPersistType : uint8_t;
290: 
291: enum class SecretSerializationType : uint8_t;
292: 
293: enum class SequenceInfo : uint8_t;
294: 
295: enum class SetOperationType : uint8_t;
296: 
297: enum class SetScope : uint8_t;
298: 
299: enum class SetType : uint8_t;
300: 
301: enum class SettingScope : uint8_t;
302: 
303: enum class ShowType : uint8_t;
304: 
305: enum class SimplifiedTokenType : uint8_t;
306: 
307: enum class SinkCombineResultType : uint8_t;
308: 
309: enum class SinkFinalizeType : uint8_t;
310: 
311: enum class SinkNextBatchType : uint8_t;
312: 
313: enum class SinkResultType : uint8_t;
314: 
315: enum class SourceResultType : uint8_t;
316: 
317: enum class StatementReturnType : uint8_t;
318: 
319: enum class StatementType : uint8_t;
320: 
321: enum class StatisticsType : uint8_t;
322: 
323: enum class StatsInfo : uint8_t;
324: 
325: enum class StrTimeSpecifier : uint8_t;
326: 
327: enum class StreamExecutionResult : uint8_t;
328: 
329: enum class SubqueryType : uint8_t;
330: 
331: enum class TableColumnType : uint8_t;
332: 
333: enum class TableFilterType : uint8_t;
334: 
335: enum class TablePartitionInfo : uint8_t;
336: 
337: enum class TableReferenceType : uint8_t;
338: 
339: enum class TableScanType : uint8_t;
340: 
341: enum class TaskExecutionMode : uint8_t;
342: 
343: enum class TaskExecutionResult : uint8_t;
344: 
345: enum class TemporaryBufferSize : uint64_t;
346: 
347: enum class TemporaryCompressionLevel : int;
348: 
349: enum class TimestampCastResult : uint8_t;
350: 
351: enum class TransactionModifierType : uint8_t;
352: 
353: enum class TransactionType : uint8_t;
354: 
355: enum class TupleDataPinProperties : uint8_t;
356: 
357: enum class UndoFlags : uint32_t;
358: 
359: enum class UnionInvalidReason : uint8_t;
360: 
361: enum class VectorAuxiliaryDataType : uint8_t;
362: 
363: enum class VectorBufferType : uint8_t;
364: 
365: enum class VectorType : uint8_t;
366: 
367: enum class VerificationType : uint8_t;
368: 
369: enum class VerifyExistenceType : uint8_t;
370: 
371: enum class WALType : uint8_t;
372: 
373: enum class WindowAggregationMode : uint32_t;
374: 
375: enum class WindowBoundary : uint8_t;
376: 
377: enum class WindowExcludeMode : uint8_t;
378: 
379: 
380: template<>
381: const char* EnumUtil::ToChars<ARTAppendMode>(ARTAppendMode value);
382: 
383: template<>
384: const char* EnumUtil::ToChars<ARTConflictType>(ARTConflictType value);
385: 
386: template<>
387: const char* EnumUtil::ToChars<AccessMode>(AccessMode value);
388: 
389: template<>
390: const char* EnumUtil::ToChars<AggregateCombineType>(AggregateCombineType value);
391: 
392: template<>
393: const char* EnumUtil::ToChars<AggregateDistinctDependent>(AggregateDistinctDependent value);
394: 
395: template<>
396: const char* EnumUtil::ToChars<AggregateHandling>(AggregateHandling value);
397: 
398: template<>
399: const char* EnumUtil::ToChars<AggregateOrderDependent>(AggregateOrderDependent value);
400: 
401: template<>
402: const char* EnumUtil::ToChars<AggregateType>(AggregateType value);
403: 
404: template<>
405: const char* EnumUtil::ToChars<AlterForeignKeyType>(AlterForeignKeyType value);
406: 
407: template<>
408: const char* EnumUtil::ToChars<AlterScalarFunctionType>(AlterScalarFunctionType value);
409: 
410: template<>
411: const char* EnumUtil::ToChars<AlterTableFunctionType>(AlterTableFunctionType value);
412: 
413: template<>
414: const char* EnumUtil::ToChars<AlterTableType>(AlterTableType value);
415: 
416: template<>
417: const char* EnumUtil::ToChars<AlterType>(AlterType value);
418: 
419: template<>
420: const char* EnumUtil::ToChars<AlterViewType>(AlterViewType value);
421: 
422: template<>
423: const char* EnumUtil::ToChars<AppenderType>(AppenderType value);
424: 
425: template<>
426: const char* EnumUtil::ToChars<ArrowDateTimeType>(ArrowDateTimeType value);
427: 
428: template<>
429: const char* EnumUtil::ToChars<ArrowOffsetSize>(ArrowOffsetSize value);
430: 
431: template<>
432: const char* EnumUtil::ToChars<ArrowTypeInfoType>(ArrowTypeInfoType value);
433: 
434: template<>
435: const char* EnumUtil::ToChars<ArrowVariableSizeType>(ArrowVariableSizeType value);
436: 
437: template<>
438: const char* EnumUtil::ToChars<BinderType>(BinderType value);
439: 
440: template<>
441: const char* EnumUtil::ToChars<BindingMode>(BindingMode value);
442: 
443: template<>
444: const char* EnumUtil::ToChars<BitpackingMode>(BitpackingMode value);
445: 
446: template<>
447: const char* EnumUtil::ToChars<BlockState>(BlockState value);
448: 
449: template<>
450: const char* EnumUtil::ToChars<CAPIResultSetType>(CAPIResultSetType value);
451: 
452: template<>
453: const char* EnumUtil::ToChars<CSVState>(CSVState value);
454: 
455: template<>
456: const char* EnumUtil::ToChars<CTEMaterialize>(CTEMaterialize value);
457: 
458: template<>
459: const char* EnumUtil::ToChars<CatalogLookupBehavior>(CatalogLookupBehavior value);
460: 
461: template<>
462: const char* EnumUtil::ToChars<CatalogType>(CatalogType value);
463: 
464: template<>
465: const char* EnumUtil::ToChars<CheckpointAbort>(CheckpointAbort value);
466: 
467: template<>
468: const char* EnumUtil::ToChars<ChunkInfoType>(ChunkInfoType value);
469: 
470: template<>
471: const char* EnumUtil::ToChars<ColumnDataAllocatorType>(ColumnDataAllocatorType value);
472: 
473: template<>
474: const char* EnumUtil::ToChars<ColumnDataScanProperties>(ColumnDataScanProperties value);
475: 
476: template<>
477: const char* EnumUtil::ToChars<ColumnSegmentType>(ColumnSegmentType value);
478: 
479: template<>
480: const char* EnumUtil::ToChars<CompressedMaterializationDirection>(CompressedMaterializationDirection value);
481: 
482: template<>
483: const char* EnumUtil::ToChars<CompressionType>(CompressionType value);
484: 
485: template<>
486: const char* EnumUtil::ToChars<ConflictManagerMode>(ConflictManagerMode value);
487: 
488: template<>
489: const char* EnumUtil::ToChars<ConstraintType>(ConstraintType value);
490: 
491: template<>
492: const char* EnumUtil::ToChars<CopyFunctionReturnType>(CopyFunctionReturnType value);
493: 
494: template<>
495: const char* EnumUtil::ToChars<CopyOverwriteMode>(CopyOverwriteMode value);
496: 
497: template<>
498: const char* EnumUtil::ToChars<CopyToType>(CopyToType value);
499: 
500: template<>
501: const char* EnumUtil::ToChars<DataFileType>(DataFileType value);
502: 
503: template<>
504: const char* EnumUtil::ToChars<DatePartSpecifier>(DatePartSpecifier value);
505: 
506: template<>
507: const char* EnumUtil::ToChars<DebugInitialize>(DebugInitialize value);
508: 
509: template<>
510: const char* EnumUtil::ToChars<DefaultOrderByNullType>(DefaultOrderByNullType value);
511: 
512: template<>
513: const char* EnumUtil::ToChars<DependencyEntryType>(DependencyEntryType value);
514: 
515: template<>
516: const char* EnumUtil::ToChars<DeprecatedIndexType>(DeprecatedIndexType value);
517: 
518: template<>
519: const char* EnumUtil::ToChars<DestroyBufferUpon>(DestroyBufferUpon value);
520: 
521: template<>
522: const char* EnumUtil::ToChars<DistinctType>(DistinctType value);
523: 
524: template<>
525: const char* EnumUtil::ToChars<ErrorType>(ErrorType value);
526: 
527: template<>
528: const char* EnumUtil::ToChars<ExceptionFormatValueType>(ExceptionFormatValueType value);
529: 
530: template<>
531: const char* EnumUtil::ToChars<ExceptionType>(ExceptionType value);
532: 
533: template<>
534: const char* EnumUtil::ToChars<ExplainFormat>(ExplainFormat value);
535: 
536: template<>
537: const char* EnumUtil::ToChars<ExplainOutputType>(ExplainOutputType value);
538: 
539: template<>
540: const char* EnumUtil::ToChars<ExplainType>(ExplainType value);
541: 
542: template<>
543: const char* EnumUtil::ToChars<ExponentType>(ExponentType value);
544: 
545: template<>
546: const char* EnumUtil::ToChars<ExpressionClass>(ExpressionClass value);
547: 
548: template<>
549: const char* EnumUtil::ToChars<ExpressionType>(ExpressionType value);
550: 
551: template<>
552: const char* EnumUtil::ToChars<ExtensionABIType>(ExtensionABIType value);
553: 
554: template<>
555: const char* EnumUtil::ToChars<ExtensionInstallMode>(ExtensionInstallMode value);
556: 
557: template<>
558: const char* EnumUtil::ToChars<ExtensionLoadResult>(ExtensionLoadResult value);
559: 
560: template<>
561: const char* EnumUtil::ToChars<ExtensionUpdateResultTag>(ExtensionUpdateResultTag value);
562: 
563: template<>
564: const char* EnumUtil::ToChars<ExtraDropInfoType>(ExtraDropInfoType value);
565: 
566: template<>
567: const char* EnumUtil::ToChars<ExtraTypeInfoType>(ExtraTypeInfoType value);
568: 
569: template<>
570: const char* EnumUtil::ToChars<FileBufferType>(FileBufferType value);
571: 
572: template<>
573: const char* EnumUtil::ToChars<FileCompressionType>(FileCompressionType value);
574: 
575: template<>
576: const char* EnumUtil::ToChars<FileExpandResult>(FileExpandResult value);
577: 
578: template<>
579: const char* EnumUtil::ToChars<FileGlobOptions>(FileGlobOptions value);
580: 
581: template<>
582: const char* EnumUtil::ToChars<FileLockType>(FileLockType value);
583: 
584: template<>
585: const char* EnumUtil::ToChars<FilterPropagateResult>(FilterPropagateResult value);
586: 
587: template<>
588: const char* EnumUtil::ToChars<ForeignKeyType>(ForeignKeyType value);
589: 
590: template<>
591: const char* EnumUtil::ToChars<FunctionCollationHandling>(FunctionCollationHandling value);
592: 
593: template<>
594: const char* EnumUtil::ToChars<FunctionErrors>(FunctionErrors value);
595: 
596: template<>
597: const char* EnumUtil::ToChars<FunctionNullHandling>(FunctionNullHandling value);
598: 
599: template<>
600: const char* EnumUtil::ToChars<FunctionStability>(FunctionStability value);
601: 
602: template<>
603: const char* EnumUtil::ToChars<GateStatus>(GateStatus value);
604: 
605: template<>
606: const char* EnumUtil::ToChars<HLLStorageType>(HLLStorageType value);
607: 
608: template<>
609: const char* EnumUtil::ToChars<IndexConstraintType>(IndexConstraintType value);
610: 
611: template<>
612: const char* EnumUtil::ToChars<InsertColumnOrder>(InsertColumnOrder value);
613: 
614: template<>
615: const char* EnumUtil::ToChars<InterruptMode>(InterruptMode value);
616: 
617: template<>
618: const char* EnumUtil::ToChars<JoinRefType>(JoinRefType value);
619: 
620: template<>
621: const char* EnumUtil::ToChars<JoinType>(JoinType value);
622: 
623: template<>
624: const char* EnumUtil::ToChars<KeywordCategory>(KeywordCategory value);
625: 
626: template<>
627: const char* EnumUtil::ToChars<LimitNodeType>(LimitNodeType value);
628: 
629: template<>
630: const char* EnumUtil::ToChars<LoadType>(LoadType value);
631: 
632: template<>
633: const char* EnumUtil::ToChars<LogicalOperatorType>(LogicalOperatorType value);
634: 
635: template<>
636: const char* EnumUtil::ToChars<LogicalTypeId>(LogicalTypeId value);
637: 
638: template<>
639: const char* EnumUtil::ToChars<LookupResultType>(LookupResultType value);
640: 
641: template<>
642: const char* EnumUtil::ToChars<MacroType>(MacroType value);
643: 
644: template<>
645: const char* EnumUtil::ToChars<MapInvalidReason>(MapInvalidReason value);
646: 
647: template<>
648: const char* EnumUtil::ToChars<MemoryTag>(MemoryTag value);
649: 
650: template<>
651: const char* EnumUtil::ToChars<MetaPipelineType>(MetaPipelineType value);
652: 
653: template<>
654: const char* EnumUtil::ToChars<MetricsType>(MetricsType value);
655: 
656: template<>
657: const char* EnumUtil::ToChars<NType>(NType value);
658: 
659: template<>
660: const char* EnumUtil::ToChars<NewLineIdentifier>(NewLineIdentifier value);
661: 
662: template<>
663: const char* EnumUtil::ToChars<OnConflictAction>(OnConflictAction value);
664: 
665: template<>
666: const char* EnumUtil::ToChars<OnCreateConflict>(OnCreateConflict value);
667: 
668: template<>
669: const char* EnumUtil::ToChars<OnEntryNotFound>(OnEntryNotFound value);
670: 
671: template<>
672: const char* EnumUtil::ToChars<OperatorFinalizeResultType>(OperatorFinalizeResultType value);
673: 
674: template<>
675: const char* EnumUtil::ToChars<OperatorResultType>(OperatorResultType value);
676: 
677: template<>
678: const char* EnumUtil::ToChars<OptimizerType>(OptimizerType value);
679: 
680: template<>
681: const char* EnumUtil::ToChars<OrderByNullType>(OrderByNullType value);
682: 
683: template<>
684: const char* EnumUtil::ToChars<OrderPreservationType>(OrderPreservationType value);
685: 
686: template<>
687: const char* EnumUtil::ToChars<OrderType>(OrderType value);
688: 
689: template<>
690: const char* EnumUtil::ToChars<OutputStream>(OutputStream value);
691: 
692: template<>
693: const char* EnumUtil::ToChars<ParseInfoType>(ParseInfoType value);
694: 
695: template<>
696: const char* EnumUtil::ToChars<ParserExtensionResultType>(ParserExtensionResultType value);
697: 
698: template<>
699: const char* EnumUtil::ToChars<PartitionSortStage>(PartitionSortStage value);
700: 
701: template<>
702: const char* EnumUtil::ToChars<PartitionedColumnDataType>(PartitionedColumnDataType value);
703: 
704: template<>
705: const char* EnumUtil::ToChars<PartitionedTupleDataType>(PartitionedTupleDataType value);
706: 
707: template<>
708: const char* EnumUtil::ToChars<PendingExecutionResult>(PendingExecutionResult value);
709: 
710: template<>
711: const char* EnumUtil::ToChars<PhysicalOperatorType>(PhysicalOperatorType value);
712: 
713: template<>
714: const char* EnumUtil::ToChars<PhysicalType>(PhysicalType value);
715: 
716: template<>
717: const char* EnumUtil::ToChars<PragmaType>(PragmaType value);
718: 
719: template<>
720: const char* EnumUtil::ToChars<PreparedParamType>(PreparedParamType value);
721: 
722: template<>
723: const char* EnumUtil::ToChars<PreparedStatementMode>(PreparedStatementMode value);
724: 
725: template<>
726: const char* EnumUtil::ToChars<ProfilerPrintFormat>(ProfilerPrintFormat value);
727: 
728: template<>
729: const char* EnumUtil::ToChars<QuantileSerializationType>(QuantileSerializationType value);
730: 
731: template<>
732: const char* EnumUtil::ToChars<QueryNodeType>(QueryNodeType value);
733: 
734: template<>
735: const char* EnumUtil::ToChars<QueryResultType>(QueryResultType value);
736: 
737: template<>
738: const char* EnumUtil::ToChars<QuoteRule>(QuoteRule value);
739: 
740: template<>
741: const char* EnumUtil::ToChars<RelationType>(RelationType value);
742: 
743: template<>
744: const char* EnumUtil::ToChars<RenderMode>(RenderMode value);
745: 
746: template<>
747: const char* EnumUtil::ToChars<ResultModifierType>(ResultModifierType value);
748: 
749: template<>
750: const char* EnumUtil::ToChars<SampleMethod>(SampleMethod value);
751: 
752: template<>
753: const char* EnumUtil::ToChars<SampleType>(SampleType value);
754: 
755: template<>
756: const char* EnumUtil::ToChars<ScanType>(ScanType value);
757: 
758: template<>
759: const char* EnumUtil::ToChars<SecretDisplayType>(SecretDisplayType value);
760: 
761: template<>
762: const char* EnumUtil::ToChars<SecretPersistType>(SecretPersistType value);
763: 
764: template<>
765: const char* EnumUtil::ToChars<SecretSerializationType>(SecretSerializationType value);
766: 
767: template<>
768: const char* EnumUtil::ToChars<SequenceInfo>(SequenceInfo value);
769: 
770: template<>
771: const char* EnumUtil::ToChars<SetOperationType>(SetOperationType value);
772: 
773: template<>
774: const char* EnumUtil::ToChars<SetScope>(SetScope value);
775: 
776: template<>
777: const char* EnumUtil::ToChars<SetType>(SetType value);
778: 
779: template<>
780: const char* EnumUtil::ToChars<SettingScope>(SettingScope value);
781: 
782: template<>
783: const char* EnumUtil::ToChars<ShowType>(ShowType value);
784: 
785: template<>
786: const char* EnumUtil::ToChars<SimplifiedTokenType>(SimplifiedTokenType value);
787: 
788: template<>
789: const char* EnumUtil::ToChars<SinkCombineResultType>(SinkCombineResultType value);
790: 
791: template<>
792: const char* EnumUtil::ToChars<SinkFinalizeType>(SinkFinalizeType value);
793: 
794: template<>
795: const char* EnumUtil::ToChars<SinkNextBatchType>(SinkNextBatchType value);
796: 
797: template<>
798: const char* EnumUtil::ToChars<SinkResultType>(SinkResultType value);
799: 
800: template<>
801: const char* EnumUtil::ToChars<SourceResultType>(SourceResultType value);
802: 
803: template<>
804: const char* EnumUtil::ToChars<StatementReturnType>(StatementReturnType value);
805: 
806: template<>
807: const char* EnumUtil::ToChars<StatementType>(StatementType value);
808: 
809: template<>
810: const char* EnumUtil::ToChars<StatisticsType>(StatisticsType value);
811: 
812: template<>
813: const char* EnumUtil::ToChars<StatsInfo>(StatsInfo value);
814: 
815: template<>
816: const char* EnumUtil::ToChars<StrTimeSpecifier>(StrTimeSpecifier value);
817: 
818: template<>
819: const char* EnumUtil::ToChars<StreamExecutionResult>(StreamExecutionResult value);
820: 
821: template<>
822: const char* EnumUtil::ToChars<SubqueryType>(SubqueryType value);
823: 
824: template<>
825: const char* EnumUtil::ToChars<TableColumnType>(TableColumnType value);
826: 
827: template<>
828: const char* EnumUtil::ToChars<TableFilterType>(TableFilterType value);
829: 
830: template<>
831: const char* EnumUtil::ToChars<TablePartitionInfo>(TablePartitionInfo value);
832: 
833: template<>
834: const char* EnumUtil::ToChars<TableReferenceType>(TableReferenceType value);
835: 
836: template<>
837: const char* EnumUtil::ToChars<TableScanType>(TableScanType value);
838: 
839: template<>
840: const char* EnumUtil::ToChars<TaskExecutionMode>(TaskExecutionMode value);
841: 
842: template<>
843: const char* EnumUtil::ToChars<TaskExecutionResult>(TaskExecutionResult value);
844: 
845: template<>
846: const char* EnumUtil::ToChars<TemporaryBufferSize>(TemporaryBufferSize value);
847: 
848: template<>
849: const char* EnumUtil::ToChars<TemporaryCompressionLevel>(TemporaryCompressionLevel value);
850: 
851: template<>
852: const char* EnumUtil::ToChars<TimestampCastResult>(TimestampCastResult value);
853: 
854: template<>
855: const char* EnumUtil::ToChars<TransactionModifierType>(TransactionModifierType value);
856: 
857: template<>
858: const char* EnumUtil::ToChars<TransactionType>(TransactionType value);
859: 
860: template<>
861: const char* EnumUtil::ToChars<TupleDataPinProperties>(TupleDataPinProperties value);
862: 
863: template<>
864: const char* EnumUtil::ToChars<UndoFlags>(UndoFlags value);
865: 
866: template<>
867: const char* EnumUtil::ToChars<UnionInvalidReason>(UnionInvalidReason value);
868: 
869: template<>
870: const char* EnumUtil::ToChars<VectorAuxiliaryDataType>(VectorAuxiliaryDataType value);
871: 
872: template<>
873: const char* EnumUtil::ToChars<VectorBufferType>(VectorBufferType value);
874: 
875: template<>
876: const char* EnumUtil::ToChars<VectorType>(VectorType value);
877: 
878: template<>
879: const char* EnumUtil::ToChars<VerificationType>(VerificationType value);
880: 
881: template<>
882: const char* EnumUtil::ToChars<VerifyExistenceType>(VerifyExistenceType value);
883: 
884: template<>
885: const char* EnumUtil::ToChars<WALType>(WALType value);
886: 
887: template<>
888: const char* EnumUtil::ToChars<WindowAggregationMode>(WindowAggregationMode value);
889: 
890: template<>
891: const char* EnumUtil::ToChars<WindowBoundary>(WindowBoundary value);
892: 
893: template<>
894: const char* EnumUtil::ToChars<WindowExcludeMode>(WindowExcludeMode value);
895: 
896: 
897: template<>
898: ARTAppendMode EnumUtil::FromString<ARTAppendMode>(const char *value);
899: 
900: template<>
901: ARTConflictType EnumUtil::FromString<ARTConflictType>(const char *value);
902: 
903: template<>
904: AccessMode EnumUtil::FromString<AccessMode>(const char *value);
905: 
906: template<>
907: AggregateCombineType EnumUtil::FromString<AggregateCombineType>(const char *value);
908: 
909: template<>
910: AggregateDistinctDependent EnumUtil::FromString<AggregateDistinctDependent>(const char *value);
911: 
912: template<>
913: AggregateHandling EnumUtil::FromString<AggregateHandling>(const char *value);
914: 
915: template<>
916: AggregateOrderDependent EnumUtil::FromString<AggregateOrderDependent>(const char *value);
917: 
918: template<>
919: AggregateType EnumUtil::FromString<AggregateType>(const char *value);
920: 
921: template<>
922: AlterForeignKeyType EnumUtil::FromString<AlterForeignKeyType>(const char *value);
923: 
924: template<>
925: AlterScalarFunctionType EnumUtil::FromString<AlterScalarFunctionType>(const char *value);
926: 
927: template<>
928: AlterTableFunctionType EnumUtil::FromString<AlterTableFunctionType>(const char *value);
929: 
930: template<>
931: AlterTableType EnumUtil::FromString<AlterTableType>(const char *value);
932: 
933: template<>
934: AlterType EnumUtil::FromString<AlterType>(const char *value);
935: 
936: template<>
937: AlterViewType EnumUtil::FromString<AlterViewType>(const char *value);
938: 
939: template<>
940: AppenderType EnumUtil::FromString<AppenderType>(const char *value);
941: 
942: template<>
943: ArrowDateTimeType EnumUtil::FromString<ArrowDateTimeType>(const char *value);
944: 
945: template<>
946: ArrowOffsetSize EnumUtil::FromString<ArrowOffsetSize>(const char *value);
947: 
948: template<>
949: ArrowTypeInfoType EnumUtil::FromString<ArrowTypeInfoType>(const char *value);
950: 
951: template<>
952: ArrowVariableSizeType EnumUtil::FromString<ArrowVariableSizeType>(const char *value);
953: 
954: template<>
955: BinderType EnumUtil::FromString<BinderType>(const char *value);
956: 
957: template<>
958: BindingMode EnumUtil::FromString<BindingMode>(const char *value);
959: 
960: template<>
961: BitpackingMode EnumUtil::FromString<BitpackingMode>(const char *value);
962: 
963: template<>
964: BlockState EnumUtil::FromString<BlockState>(const char *value);
965: 
966: template<>
967: CAPIResultSetType EnumUtil::FromString<CAPIResultSetType>(const char *value);
968: 
969: template<>
970: CSVState EnumUtil::FromString<CSVState>(const char *value);
971: 
972: template<>
973: CTEMaterialize EnumUtil::FromString<CTEMaterialize>(const char *value);
974: 
975: template<>
976: CatalogLookupBehavior EnumUtil::FromString<CatalogLookupBehavior>(const char *value);
977: 
978: template<>
979: CatalogType EnumUtil::FromString<CatalogType>(const char *value);
980: 
981: template<>
982: CheckpointAbort EnumUtil::FromString<CheckpointAbort>(const char *value);
983: 
984: template<>
985: ChunkInfoType EnumUtil::FromString<ChunkInfoType>(const char *value);
986: 
987: template<>
988: ColumnDataAllocatorType EnumUtil::FromString<ColumnDataAllocatorType>(const char *value);
989: 
990: template<>
991: ColumnDataScanProperties EnumUtil::FromString<ColumnDataScanProperties>(const char *value);
992: 
993: template<>
994: ColumnSegmentType EnumUtil::FromString<ColumnSegmentType>(const char *value);
995: 
996: template<>
997: CompressedMaterializationDirection EnumUtil::FromString<CompressedMaterializationDirection>(const char *value);
998: 
999: template<>
1000: CompressionType EnumUtil::FromString<CompressionType>(const char *value);
1001: 
1002: template<>
1003: ConflictManagerMode EnumUtil::FromString<ConflictManagerMode>(const char *value);
1004: 
1005: template<>
1006: ConstraintType EnumUtil::FromString<ConstraintType>(const char *value);
1007: 
1008: template<>
1009: CopyFunctionReturnType EnumUtil::FromString<CopyFunctionReturnType>(const char *value);
1010: 
1011: template<>
1012: CopyOverwriteMode EnumUtil::FromString<CopyOverwriteMode>(const char *value);
1013: 
1014: template<>
1015: CopyToType EnumUtil::FromString<CopyToType>(const char *value);
1016: 
1017: template<>
1018: DataFileType EnumUtil::FromString<DataFileType>(const char *value);
1019: 
1020: template<>
1021: DatePartSpecifier EnumUtil::FromString<DatePartSpecifier>(const char *value);
1022: 
1023: template<>
1024: DebugInitialize EnumUtil::FromString<DebugInitialize>(const char *value);
1025: 
1026: template<>
1027: DefaultOrderByNullType EnumUtil::FromString<DefaultOrderByNullType>(const char *value);
1028: 
1029: template<>
1030: DependencyEntryType EnumUtil::FromString<DependencyEntryType>(const char *value);
1031: 
1032: template<>
1033: DeprecatedIndexType EnumUtil::FromString<DeprecatedIndexType>(const char *value);
1034: 
1035: template<>
1036: DestroyBufferUpon EnumUtil::FromString<DestroyBufferUpon>(const char *value);
1037: 
1038: template<>
1039: DistinctType EnumUtil::FromString<DistinctType>(const char *value);
1040: 
1041: template<>
1042: ErrorType EnumUtil::FromString<ErrorType>(const char *value);
1043: 
1044: template<>
1045: ExceptionFormatValueType EnumUtil::FromString<ExceptionFormatValueType>(const char *value);
1046: 
1047: template<>
1048: ExceptionType EnumUtil::FromString<ExceptionType>(const char *value);
1049: 
1050: template<>
1051: ExplainFormat EnumUtil::FromString<ExplainFormat>(const char *value);
1052: 
1053: template<>
1054: ExplainOutputType EnumUtil::FromString<ExplainOutputType>(const char *value);
1055: 
1056: template<>
1057: ExplainType EnumUtil::FromString<ExplainType>(const char *value);
1058: 
1059: template<>
1060: ExponentType EnumUtil::FromString<ExponentType>(const char *value);
1061: 
1062: template<>
1063: ExpressionClass EnumUtil::FromString<ExpressionClass>(const char *value);
1064: 
1065: template<>
1066: ExpressionType EnumUtil::FromString<ExpressionType>(const char *value);
1067: 
1068: template<>
1069: ExtensionABIType EnumUtil::FromString<ExtensionABIType>(const char *value);
1070: 
1071: template<>
1072: ExtensionInstallMode EnumUtil::FromString<ExtensionInstallMode>(const char *value);
1073: 
1074: template<>
1075: ExtensionLoadResult EnumUtil::FromString<ExtensionLoadResult>(const char *value);
1076: 
1077: template<>
1078: ExtensionUpdateResultTag EnumUtil::FromString<ExtensionUpdateResultTag>(const char *value);
1079: 
1080: template<>
1081: ExtraDropInfoType EnumUtil::FromString<ExtraDropInfoType>(const char *value);
1082: 
1083: template<>
1084: ExtraTypeInfoType EnumUtil::FromString<ExtraTypeInfoType>(const char *value);
1085: 
1086: template<>
1087: FileBufferType EnumUtil::FromString<FileBufferType>(const char *value);
1088: 
1089: template<>
1090: FileCompressionType EnumUtil::FromString<FileCompressionType>(const char *value);
1091: 
1092: template<>
1093: FileExpandResult EnumUtil::FromString<FileExpandResult>(const char *value);
1094: 
1095: template<>
1096: FileGlobOptions EnumUtil::FromString<FileGlobOptions>(const char *value);
1097: 
1098: template<>
1099: FileLockType EnumUtil::FromString<FileLockType>(const char *value);
1100: 
1101: template<>
1102: FilterPropagateResult EnumUtil::FromString<FilterPropagateResult>(const char *value);
1103: 
1104: template<>
1105: ForeignKeyType EnumUtil::FromString<ForeignKeyType>(const char *value);
1106: 
1107: template<>
1108: FunctionCollationHandling EnumUtil::FromString<FunctionCollationHandling>(const char *value);
1109: 
1110: template<>
1111: FunctionErrors EnumUtil::FromString<FunctionErrors>(const char *value);
1112: 
1113: template<>
1114: FunctionNullHandling EnumUtil::FromString<FunctionNullHandling>(const char *value);
1115: 
1116: template<>
1117: FunctionStability EnumUtil::FromString<FunctionStability>(const char *value);
1118: 
1119: template<>
1120: GateStatus EnumUtil::FromString<GateStatus>(const char *value);
1121: 
1122: template<>
1123: HLLStorageType EnumUtil::FromString<HLLStorageType>(const char *value);
1124: 
1125: template<>
1126: IndexConstraintType EnumUtil::FromString<IndexConstraintType>(const char *value);
1127: 
1128: template<>
1129: InsertColumnOrder EnumUtil::FromString<InsertColumnOrder>(const char *value);
1130: 
1131: template<>
1132: InterruptMode EnumUtil::FromString<InterruptMode>(const char *value);
1133: 
1134: template<>
1135: JoinRefType EnumUtil::FromString<JoinRefType>(const char *value);
1136: 
1137: template<>
1138: JoinType EnumUtil::FromString<JoinType>(const char *value);
1139: 
1140: template<>
1141: KeywordCategory EnumUtil::FromString<KeywordCategory>(const char *value);
1142: 
1143: template<>
1144: LimitNodeType EnumUtil::FromString<LimitNodeType>(const char *value);
1145: 
1146: template<>
1147: LoadType EnumUtil::FromString<LoadType>(const char *value);
1148: 
1149: template<>
1150: LogicalOperatorType EnumUtil::FromString<LogicalOperatorType>(const char *value);
1151: 
1152: template<>
1153: LogicalTypeId EnumUtil::FromString<LogicalTypeId>(const char *value);
1154: 
1155: template<>
1156: LookupResultType EnumUtil::FromString<LookupResultType>(const char *value);
1157: 
1158: template<>
1159: MacroType EnumUtil::FromString<MacroType>(const char *value);
1160: 
1161: template<>
1162: MapInvalidReason EnumUtil::FromString<MapInvalidReason>(const char *value);
1163: 
1164: template<>
1165: MemoryTag EnumUtil::FromString<MemoryTag>(const char *value);
1166: 
1167: template<>
1168: MetaPipelineType EnumUtil::FromString<MetaPipelineType>(const char *value);
1169: 
1170: template<>
1171: MetricsType EnumUtil::FromString<MetricsType>(const char *value);
1172: 
1173: template<>
1174: NType EnumUtil::FromString<NType>(const char *value);
1175: 
1176: template<>
1177: NewLineIdentifier EnumUtil::FromString<NewLineIdentifier>(const char *value);
1178: 
1179: template<>
1180: OnConflictAction EnumUtil::FromString<OnConflictAction>(const char *value);
1181: 
1182: template<>
1183: OnCreateConflict EnumUtil::FromString<OnCreateConflict>(const char *value);
1184: 
1185: template<>
1186: OnEntryNotFound EnumUtil::FromString<OnEntryNotFound>(const char *value);
1187: 
1188: template<>
1189: OperatorFinalizeResultType EnumUtil::FromString<OperatorFinalizeResultType>(const char *value);
1190: 
1191: template<>
1192: OperatorResultType EnumUtil::FromString<OperatorResultType>(const char *value);
1193: 
1194: template<>
1195: OptimizerType EnumUtil::FromString<OptimizerType>(const char *value);
1196: 
1197: template<>
1198: OrderByNullType EnumUtil::FromString<OrderByNullType>(const char *value);
1199: 
1200: template<>
1201: OrderPreservationType EnumUtil::FromString<OrderPreservationType>(const char *value);
1202: 
1203: template<>
1204: OrderType EnumUtil::FromString<OrderType>(const char *value);
1205: 
1206: template<>
1207: OutputStream EnumUtil::FromString<OutputStream>(const char *value);
1208: 
1209: template<>
1210: ParseInfoType EnumUtil::FromString<ParseInfoType>(const char *value);
1211: 
1212: template<>
1213: ParserExtensionResultType EnumUtil::FromString<ParserExtensionResultType>(const char *value);
1214: 
1215: template<>
1216: PartitionSortStage EnumUtil::FromString<PartitionSortStage>(const char *value);
1217: 
1218: template<>
1219: PartitionedColumnDataType EnumUtil::FromString<PartitionedColumnDataType>(const char *value);
1220: 
1221: template<>
1222: PartitionedTupleDataType EnumUtil::FromString<PartitionedTupleDataType>(const char *value);
1223: 
1224: template<>
1225: PendingExecutionResult EnumUtil::FromString<PendingExecutionResult>(const char *value);
1226: 
1227: template<>
1228: PhysicalOperatorType EnumUtil::FromString<PhysicalOperatorType>(const char *value);
1229: 
1230: template<>
1231: PhysicalType EnumUtil::FromString<PhysicalType>(const char *value);
1232: 
1233: template<>
1234: PragmaType EnumUtil::FromString<PragmaType>(const char *value);
1235: 
1236: template<>
1237: PreparedParamType EnumUtil::FromString<PreparedParamType>(const char *value);
1238: 
1239: template<>
1240: PreparedStatementMode EnumUtil::FromString<PreparedStatementMode>(const char *value);
1241: 
1242: template<>
1243: ProfilerPrintFormat EnumUtil::FromString<ProfilerPrintFormat>(const char *value);
1244: 
1245: template<>
1246: QuantileSerializationType EnumUtil::FromString<QuantileSerializationType>(const char *value);
1247: 
1248: template<>
1249: QueryNodeType EnumUtil::FromString<QueryNodeType>(const char *value);
1250: 
1251: template<>
1252: QueryResultType EnumUtil::FromString<QueryResultType>(const char *value);
1253: 
1254: template<>
1255: QuoteRule EnumUtil::FromString<QuoteRule>(const char *value);
1256: 
1257: template<>
1258: RelationType EnumUtil::FromString<RelationType>(const char *value);
1259: 
1260: template<>
1261: RenderMode EnumUtil::FromString<RenderMode>(const char *value);
1262: 
1263: template<>
1264: ResultModifierType EnumUtil::FromString<ResultModifierType>(const char *value);
1265: 
1266: template<>
1267: SampleMethod EnumUtil::FromString<SampleMethod>(const char *value);
1268: 
1269: template<>
1270: SampleType EnumUtil::FromString<SampleType>(const char *value);
1271: 
1272: template<>
1273: ScanType EnumUtil::FromString<ScanType>(const char *value);
1274: 
1275: template<>
1276: SecretDisplayType EnumUtil::FromString<SecretDisplayType>(const char *value);
1277: 
1278: template<>
1279: SecretPersistType EnumUtil::FromString<SecretPersistType>(const char *value);
1280: 
1281: template<>
1282: SecretSerializationType EnumUtil::FromString<SecretSerializationType>(const char *value);
1283: 
1284: template<>
1285: SequenceInfo EnumUtil::FromString<SequenceInfo>(const char *value);
1286: 
1287: template<>
1288: SetOperationType EnumUtil::FromString<SetOperationType>(const char *value);
1289: 
1290: template<>
1291: SetScope EnumUtil::FromString<SetScope>(const char *value);
1292: 
1293: template<>
1294: SetType EnumUtil::FromString<SetType>(const char *value);
1295: 
1296: template<>
1297: SettingScope EnumUtil::FromString<SettingScope>(const char *value);
1298: 
1299: template<>
1300: ShowType EnumUtil::FromString<ShowType>(const char *value);
1301: 
1302: template<>
1303: SimplifiedTokenType EnumUtil::FromString<SimplifiedTokenType>(const char *value);
1304: 
1305: template<>
1306: SinkCombineResultType EnumUtil::FromString<SinkCombineResultType>(const char *value);
1307: 
1308: template<>
1309: SinkFinalizeType EnumUtil::FromString<SinkFinalizeType>(const char *value);
1310: 
1311: template<>
1312: SinkNextBatchType EnumUtil::FromString<SinkNextBatchType>(const char *value);
1313: 
1314: template<>
1315: SinkResultType EnumUtil::FromString<SinkResultType>(const char *value);
1316: 
1317: template<>
1318: SourceResultType EnumUtil::FromString<SourceResultType>(const char *value);
1319: 
1320: template<>
1321: StatementReturnType EnumUtil::FromString<StatementReturnType>(const char *value);
1322: 
1323: template<>
1324: StatementType EnumUtil::FromString<StatementType>(const char *value);
1325: 
1326: template<>
1327: StatisticsType EnumUtil::FromString<StatisticsType>(const char *value);
1328: 
1329: template<>
1330: StatsInfo EnumUtil::FromString<StatsInfo>(const char *value);
1331: 
1332: template<>
1333: StrTimeSpecifier EnumUtil::FromString<StrTimeSpecifier>(const char *value);
1334: 
1335: template<>
1336: StreamExecutionResult EnumUtil::FromString<StreamExecutionResult>(const char *value);
1337: 
1338: template<>
1339: SubqueryType EnumUtil::FromString<SubqueryType>(const char *value);
1340: 
1341: template<>
1342: TableColumnType EnumUtil::FromString<TableColumnType>(const char *value);
1343: 
1344: template<>
1345: TableFilterType EnumUtil::FromString<TableFilterType>(const char *value);
1346: 
1347: template<>
1348: TablePartitionInfo EnumUtil::FromString<TablePartitionInfo>(const char *value);
1349: 
1350: template<>
1351: TableReferenceType EnumUtil::FromString<TableReferenceType>(const char *value);
1352: 
1353: template<>
1354: TableScanType EnumUtil::FromString<TableScanType>(const char *value);
1355: 
1356: template<>
1357: TaskExecutionMode EnumUtil::FromString<TaskExecutionMode>(const char *value);
1358: 
1359: template<>
1360: TaskExecutionResult EnumUtil::FromString<TaskExecutionResult>(const char *value);
1361: 
1362: template<>
1363: TemporaryBufferSize EnumUtil::FromString<TemporaryBufferSize>(const char *value);
1364: 
1365: template<>
1366: TemporaryCompressionLevel EnumUtil::FromString<TemporaryCompressionLevel>(const char *value);
1367: 
1368: template<>
1369: TimestampCastResult EnumUtil::FromString<TimestampCastResult>(const char *value);
1370: 
1371: template<>
1372: TransactionModifierType EnumUtil::FromString<TransactionModifierType>(const char *value);
1373: 
1374: template<>
1375: TransactionType EnumUtil::FromString<TransactionType>(const char *value);
1376: 
1377: template<>
1378: TupleDataPinProperties EnumUtil::FromString<TupleDataPinProperties>(const char *value);
1379: 
1380: template<>
1381: UndoFlags EnumUtil::FromString<UndoFlags>(const char *value);
1382: 
1383: template<>
1384: UnionInvalidReason EnumUtil::FromString<UnionInvalidReason>(const char *value);
1385: 
1386: template<>
1387: VectorAuxiliaryDataType EnumUtil::FromString<VectorAuxiliaryDataType>(const char *value);
1388: 
1389: template<>
1390: VectorBufferType EnumUtil::FromString<VectorBufferType>(const char *value);
1391: 
1392: template<>
1393: VectorType EnumUtil::FromString<VectorType>(const char *value);
1394: 
1395: template<>
1396: VerificationType EnumUtil::FromString<VerificationType>(const char *value);
1397: 
1398: template<>
1399: VerifyExistenceType EnumUtil::FromString<VerifyExistenceType>(const char *value);
1400: 
1401: template<>
1402: WALType EnumUtil::FromString<WALType>(const char *value);
1403: 
1404: template<>
1405: WindowAggregationMode EnumUtil::FromString<WindowAggregationMode>(const char *value);
1406: 
1407: template<>
1408: WindowBoundary EnumUtil::FromString<WindowBoundary>(const char *value);
1409: 
1410: template<>
1411: WindowExcludeMode EnumUtil::FromString<WindowExcludeMode>(const char *value);
1412: 
1413: 
1414: }
[end of src/include/duckdb/common/enum_util.hpp]
[start of src/include/duckdb/common/random_engine.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/random_engine.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/limits.hpp"
13: #include "duckdb/common/mutex.hpp"
14: 
15: #include <random>
16: 
17: namespace duckdb {
18: class ClientContext;
19: struct RandomState;
20: 
21: struct RandomEngine {
22: 	explicit RandomEngine(int64_t seed = -1);
23: 	~RandomEngine();
24: 
25: public:
26: 	//! Generate a random number between min and max
27: 	double NextRandom(double min, double max);
28: 
29: 	//! Generate a random number between 0 and 1
30: 	double NextRandom();
31: 	//! Generate a random number between 0 and 1, using 32-bits as a base
32: 	double NextRandom32();
33: 	double NextRandom32(double min, double max);
34: 	uint32_t NextRandomInteger();
35: 	uint32_t NextRandomInteger(uint32_t min, uint32_t max);
36: 	uint64_t NextRandomInteger64();
37: 
38: 	void SetSeed(uint32_t seed);
39: 
40: 	static RandomEngine &Get(ClientContext &context);
41: 
42: 	mutex lock;
43: 
44: private:
45: 	unique_ptr<RandomState> random_state;
46: };
47: 
48: } // namespace duckdb
[end of src/include/duckdb/common/random_engine.hpp]
[start of src/include/duckdb/common/serializer/serializer.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/serializer/serializer.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/enum_util.hpp"
12: #include "duckdb/common/serializer/serialization_traits.hpp"
13: #include "duckdb/common/serializer/serialization_data.hpp"
14: #include "duckdb/common/types/interval.hpp"
15: #include "duckdb/common/types/string_type.hpp"
16: #include "duckdb/common/types/uhugeint.hpp"
17: #include "duckdb/common/unordered_map.hpp"
18: #include "duckdb/common/unordered_set.hpp"
19: #include "duckdb/common/optional_idx.hpp"
20: #include "duckdb/common/optionally_owned_ptr.hpp"
21: #include "duckdb/common/value_operations/value_operations.hpp"
22: #include "duckdb/execution/operator/csv_scanner/csv_option.hpp"
23: #include "duckdb/main/config.hpp"
24: #include "duckdb/common/insertion_order_preserving_map.hpp"
25: 
26: namespace duckdb {
27: 
28: class SerializationOptions {
29: public:
30: 	bool serialize_enum_as_string = false;
31: 	bool serialize_default_values = false;
32: 	SerializationCompatibility serialization_compatibility = SerializationCompatibility::Default();
33: };
34: 
35: class Serializer {
36: protected:
37: 	SerializationOptions options;
38: 	SerializationData data;
39: 
40: public:
41: 	virtual ~Serializer() {
42: 	}
43: 
44: 	bool ShouldSerialize(idx_t version_added) {
45: 		return options.serialization_compatibility.Compare(version_added);
46: 	}
47: 
48: 	class List {
49: 		friend Serializer;
50: 
51: 	private:
52: 		Serializer &serializer;
53: 		explicit List(Serializer &serializer) : serializer(serializer) {
54: 		}
55: 
56: 	public:
57: 		// Serialize an element
58: 		template <class T>
59: 		void WriteElement(const T &value);
60: 
61: 		//! Serialize bytes
62: 		void WriteElement(data_ptr_t ptr, idx_t size);
63: 
64: 		// Serialize an object
65: 		template <class FUNC>
66: 		void WriteObject(FUNC f);
67: 	};
68: 
69: public:
70: 	SerializationData &GetSerializationData() {
71: 		return data;
72: 	}
73: 
74: 	void SetSerializationData(const SerializationData &other) {
75: 		data = other;
76: 	}
77: 
78: 	// Serialize a value
79: 	template <class T>
80: 	void WriteProperty(const field_id_t field_id, const char *tag, const T &value) {
81: 		OnPropertyBegin(field_id, tag);
82: 		WriteValue(value);
83: 		OnPropertyEnd();
84: 	}
85: 
86: 	// Default value
87: 	template <class T>
88: 	void WritePropertyWithDefault(const field_id_t field_id, const char *tag, const T &value) {
89: 		// If current value is default, don't write it
90: 		if (!options.serialize_default_values && SerializationDefaultValue::IsDefault<T>(value)) {
91: 			OnOptionalPropertyBegin(field_id, tag, false);
92: 			OnOptionalPropertyEnd(false);
93: 			return;
94: 		}
95: 		OnOptionalPropertyBegin(field_id, tag, true);
96: 		WriteValue(value);
97: 		OnOptionalPropertyEnd(true);
98: 	}
99: 
100: 	template <class T>
101: 	void WritePropertyWithDefault(const field_id_t field_id, const char *tag, const T &value, const T &&default_value) {
102: 		// If current value is default, don't write it
103: 		if (!options.serialize_default_values && (value == default_value)) {
104: 			OnOptionalPropertyBegin(field_id, tag, false);
105: 			OnOptionalPropertyEnd(false);
106: 			return;
107: 		}
108: 		OnOptionalPropertyBegin(field_id, tag, true);
109: 		WriteValue(value);
110: 		OnOptionalPropertyEnd(true);
111: 	}
112: 
113: 	// Specialization for Value (default Value comparison throws when comparing nulls)
114: 	template <class T>
115: 	void WritePropertyWithDefault(const field_id_t field_id, const char *tag, const CSVOption<T> &value,
116: 	                              const T &&default_value) {
117: 		// If current value is default, don't write it
118: 		if (!options.serialize_default_values && (value == default_value)) {
119: 			OnOptionalPropertyBegin(field_id, tag, false);
120: 			OnOptionalPropertyEnd(false);
121: 			return;
122: 		}
123: 		OnOptionalPropertyBegin(field_id, tag, true);
124: 		WriteValue(value.GetValue());
125: 		OnOptionalPropertyEnd(true);
126: 	}
127: 
128: 	// Special case: data_ptr_T
129: 	void WriteProperty(const field_id_t field_id, const char *tag, const_data_ptr_t ptr, idx_t count) {
130: 		OnPropertyBegin(field_id, tag);
131: 		WriteDataPtr(ptr, count);
132: 		OnPropertyEnd();
133: 	}
134: 
135: 	// Manually begin an object
136: 	template <class FUNC>
137: 	void WriteObject(const field_id_t field_id, const char *tag, FUNC f) {
138: 		OnPropertyBegin(field_id, tag);
139: 		OnObjectBegin();
140: 		f(*this);
141: 		OnObjectEnd();
142: 		OnPropertyEnd();
143: 	}
144: 
145: 	template <class FUNC>
146: 	void WriteList(const field_id_t field_id, const char *tag, idx_t count, FUNC func) {
147: 		OnPropertyBegin(field_id, tag);
148: 		OnListBegin(count);
149: 		List list {*this};
150: 		for (idx_t i = 0; i < count; i++) {
151: 			func(list, i);
152: 		}
153: 		OnListEnd();
154: 		OnPropertyEnd();
155: 	}
156: 
157: protected:
158: 	template <typename T>
159: 	typename std::enable_if<std::is_enum<T>::value, void>::type WriteValue(const T value) {
160: 		if (options.serialize_enum_as_string) {
161: 			// Use the enum serializer to lookup tostring function
162: 			auto str = EnumUtil::ToChars(value);
163: 			WriteValue(str);
164: 		} else {
165: 			// Use the underlying type
166: 			WriteValue(static_cast<typename std::underlying_type<T>::type>(value));
167: 		}
168: 	}
169: 
170: 	// Optionally Owned Pointer Ref
171: 	template <typename T>
172: 	void WriteValue(const optionally_owned_ptr<T> &ptr) {
173: 		WriteValue(ptr.get());
174: 	}
175: 
176: 	// Unique Pointer Ref
177: 	template <typename T>
178: 	void WriteValue(const unique_ptr<T> &ptr) {
179: 		WriteValue(ptr.get());
180: 	}
181: 
182: 	// Shared Pointer Ref
183: 	template <typename T>
184: 	void WriteValue(const shared_ptr<T> &ptr) {
185: 		WriteValue(ptr.get());
186: 	}
187: 
188: 	// Pointer
189: 	template <typename T>
190: 	void WriteValue(const T *ptr) {
191: 		if (ptr == nullptr) {
192: 			OnNullableBegin(false);
193: 			OnNullableEnd();
194: 		} else {
195: 			OnNullableBegin(true);
196: 			WriteValue(*ptr);
197: 			OnNullableEnd();
198: 		}
199: 	}
200: 
201: 	// Pair
202: 	template <class K, class V>
203: 	void WriteValue(const std::pair<K, V> &pair) {
204: 		OnObjectBegin();
205: 		WriteProperty(0, "first", pair.first);
206: 		WriteProperty(1, "second", pair.second);
207: 		OnObjectEnd();
208: 	}
209: 
210: 	// Reference Wrapper
211: 	template <class T>
212: 	void WriteValue(const reference<T> ref) {
213: 		WriteValue(ref.get());
214: 	}
215: 
216: 	// Vector
217: 	template <class T>
218: 	void WriteValue(const vector<T> &vec) {
219: 		auto count = vec.size();
220: 		OnListBegin(count);
221: 		for (auto &item : vec) {
222: 			WriteValue(item);
223: 		}
224: 		OnListEnd();
225: 	}
226: 
227: 	template <class T>
228: 	void WriteValue(const unsafe_vector<T> &vec) {
229: 		auto count = vec.size();
230: 		OnListBegin(count);
231: 		for (auto &item : vec) {
232: 			WriteValue(item);
233: 		}
234: 		OnListEnd();
235: 	}
236: 
237: 	// UnorderedSet
238: 	// Serialized the same way as a list/vector
239: 	template <class T, class HASH, class CMP>
240: 	void WriteValue(const duckdb::unordered_set<T, HASH, CMP> &set) {
241: 		auto count = set.size();
242: 		OnListBegin(count);
243: 		for (auto &item : set) {
244: 			WriteValue(item);
245: 		}
246: 		OnListEnd();
247: 	}
248: 
249: 	// Set
250: 	// Serialized the same way as a list/vector
251: 	template <class T, class HASH, class CMP>
252: 	void WriteValue(const duckdb::set<T, HASH, CMP> &set) {
253: 		auto count = set.size();
254: 		OnListBegin(count);
255: 		for (auto &item : set) {
256: 			WriteValue(item);
257: 		}
258: 		OnListEnd();
259: 	}
260: 
261: 	// Map
262: 	// serialized as a list of pairs
263: 	template <class K, class V, class HASH, class CMP>
264: 	void WriteValue(const duckdb::unordered_map<K, V, HASH, CMP> &map) {
265: 		auto count = map.size();
266: 		OnListBegin(count);
267: 		for (auto &item : map) {
268: 			OnObjectBegin();
269: 			WriteProperty(0, "key", item.first);
270: 			WriteProperty(1, "value", item.second);
271: 			OnObjectEnd();
272: 		}
273: 		OnListEnd();
274: 	}
275: 
276: 	// Map
277: 	// serialized as a list of pairs
278: 	template <class K, class V, class HASH, class CMP>
279: 	void WriteValue(const duckdb::map<K, V, HASH, CMP> &map) {
280: 		auto count = map.size();
281: 		OnListBegin(count);
282: 		for (auto &item : map) {
283: 			OnObjectBegin();
284: 			WriteProperty(0, "key", item.first);
285: 			WriteProperty(1, "value", item.second);
286: 			OnObjectEnd();
287: 		}
288: 		OnListEnd();
289: 	}
290: 
291: 	// Insertion Order Preserving Map
292: 	// serialized as a list of pairs
293: 	template <class V>
294: 	void WriteValue(const duckdb::InsertionOrderPreservingMap<V> &map) {
295: 		auto count = map.size();
296: 		OnListBegin(count);
297: 		for (auto &entry : map) {
298: 			OnObjectBegin();
299: 			WriteProperty(0, "key", entry.first);
300: 			WriteProperty(1, "value", entry.second);
301: 			OnObjectEnd();
302: 		}
303: 		OnListEnd();
304: 	}
305: 
306: 	// priority queue
307: 	template <typename T>
308: 	void WriteValue(const std::priority_queue<T> &queue) {
309: 		vector<T> placeholder;
310: 		auto queue_copy = std::priority_queue<T>(queue);
311: 		while (queue_copy.size() > 0) {
312: 			placeholder.emplace_back(queue_copy.top());
313: 			queue_copy.pop();
314: 		}
315: 		WriteValue(placeholder);
316: 	}
317: 
318: 	// class or struct implementing `Serialize(Serializer& Serializer)`;
319: 	template <typename T>
320: 	typename std::enable_if<has_serialize<T>::value>::type WriteValue(const T &value) {
321: 		OnObjectBegin();
322: 		value.Serialize(*this);
323: 		OnObjectEnd();
324: 	}
325: 
326: protected:
327: 	// Hooks for subclasses to override to implement custom behavior
328: 	virtual void OnPropertyBegin(const field_id_t field_id, const char *tag) = 0;
329: 	virtual void OnPropertyEnd() = 0;
330: 	virtual void OnOptionalPropertyBegin(const field_id_t field_id, const char *tag, bool present) = 0;
331: 	virtual void OnOptionalPropertyEnd(bool present) = 0;
332: 	virtual void OnObjectBegin() = 0;
333: 	virtual void OnObjectEnd() = 0;
334: 	virtual void OnListBegin(idx_t count) = 0;
335: 	virtual void OnListEnd() = 0;
336: 	virtual void OnNullableBegin(bool present) = 0;
337: 	virtual void OnNullableEnd() = 0;
338: 
339: 	// Handle primitive types, a serializer needs to implement these.
340: 	virtual void WriteNull() = 0;
341: 	virtual void WriteValue(char value) {
342: 		throw NotImplementedException("Write char value not implemented");
343: 	}
344: 	virtual void WriteValue(bool value) = 0;
345: 	virtual void WriteValue(uint8_t value) = 0;
346: 	virtual void WriteValue(int8_t value) = 0;
347: 	virtual void WriteValue(uint16_t value) = 0;
348: 	virtual void WriteValue(int16_t value) = 0;
349: 	virtual void WriteValue(uint32_t value) = 0;
350: 	virtual void WriteValue(int32_t value) = 0;
351: 	virtual void WriteValue(uint64_t value) = 0;
352: 	virtual void WriteValue(int64_t value) = 0;
353: 	virtual void WriteValue(hugeint_t value) = 0;
354: 	virtual void WriteValue(uhugeint_t value) = 0;
355: 	virtual void WriteValue(float value) = 0;
356: 	virtual void WriteValue(double value) = 0;
357: 	virtual void WriteValue(const string_t value) = 0;
358: 	virtual void WriteValue(const string &value) = 0;
359: 	virtual void WriteValue(const char *str) = 0;
360: 	virtual void WriteDataPtr(const_data_ptr_t ptr, idx_t count) = 0;
361: 	void WriteValue(LogicalIndex value) {
362: 		WriteValue(value.index);
363: 	}
364: 	void WriteValue(PhysicalIndex value) {
365: 		WriteValue(value.index);
366: 	}
367: 	void WriteValue(optional_idx value) {
368: 		WriteValue(value.IsValid() ? value.GetIndex() : DConstants::INVALID_INDEX);
369: 	}
370: };
371: 
372: // We need to special case vector<bool> because elements of vector<bool> cannot be referenced
373: template <>
374: void Serializer::WriteValue(const vector<bool> &vec);
375: 
376: // Specialization for Value (default Value comparison throws when comparing nulls)
377: template <>
378: void Serializer::WritePropertyWithDefault<Value>(const field_id_t field_id, const char *tag, const Value &value,
379:                                                  const Value &&default_value);
380: 
381: // List Impl
382: template <class FUNC>
383: void Serializer::List::WriteObject(FUNC f) {
384: 	serializer.OnObjectBegin();
385: 	f(serializer);
386: 	serializer.OnObjectEnd();
387: }
388: 
389: template <class T>
390: void Serializer::List::WriteElement(const T &value) {
391: 	serializer.WriteValue(value);
392: }
393: 
394: } // namespace duckdb
[end of src/include/duckdb/common/serializer/serializer.hpp]
[start of src/include/duckdb/common/types/uuid.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/uuid.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/types.hpp"
12: #include "duckdb/common/types/string_type.hpp"
13: 
14: namespace duckdb {
15: class ClientContext;
16: struct RandomEngine;
17: 
18: //! The UUID class contains static operations for the UUID type
19: class UUID {
20: public:
21: 	constexpr static const uint8_t STRING_SIZE = 36;
22: 	//! Convert a uuid string to a hugeint object
23: 	static bool FromString(const string &str, hugeint_t &result);
24: 	//! Convert a uuid string to a hugeint object
25: 	static bool FromCString(const char *str, idx_t len, hugeint_t &result) {
26: 		return FromString(string(str, 0, len), result);
27: 	}
28: 	//! Convert a hugeint object to a uuid style string
29: 	static void ToString(hugeint_t input, char *buf);
30: 
31: 	//! Convert a uhugeint_t object to a uuid value
32: 	static hugeint_t FromUHugeint(uhugeint_t input);
33: 	//! Convert a uuid value to a uhugeint_t object
34: 	static uhugeint_t ToUHugeint(hugeint_t input);
35: 
36: 	//! Convert a hugeint object to a uuid style string
37: 	static hugeint_t GenerateRandomUUID(RandomEngine &engine);
38: 	static hugeint_t GenerateRandomUUID();
39: 
40: 	//! Convert a hugeint object to a uuid style string
41: 	static string ToString(hugeint_t input) {
42: 		char buff[STRING_SIZE];
43: 		ToString(input, buff);
44: 		return string(buff, STRING_SIZE);
45: 	}
46: 
47: 	static hugeint_t FromString(const string &str) {
48: 		hugeint_t result;
49: 		FromString(str, result);
50: 		return result;
51: 	}
52: };
53: 
54: } // namespace duckdb
[end of src/include/duckdb/common/types/uuid.hpp]
[start of src/include/duckdb/execution/physical_operator.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/physical_operator.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/catalog.hpp"
12: #include "duckdb/common/common.hpp"
13: #include "duckdb/common/enums/operator_result_type.hpp"
14: #include "duckdb/common/enums/physical_operator_type.hpp"
15: #include "duckdb/common/enums/explain_format.hpp"
16: #include "duckdb/common/types/data_chunk.hpp"
17: #include "duckdb/execution/execution_context.hpp"
18: #include "duckdb/execution/progress_data.hpp"
19: #include "duckdb/optimizer/join_order/join_node.hpp"
20: #include "duckdb/common/optional_idx.hpp"
21: #include "duckdb/execution/physical_operator_states.hpp"
22: #include "duckdb/common/enums/order_preservation_type.hpp"
23: #include "duckdb/common/case_insensitive_map.hpp"
24: #include "duckdb/execution/partition_info.hpp"
25: 
26: namespace duckdb {
27: class Event;
28: class Executor;
29: class PhysicalOperator;
30: class Pipeline;
31: class PipelineBuildState;
32: class MetaPipeline;
33: 
34: //! PhysicalOperator is the base class of the physical operators present in the
35: //! execution plan
36: class PhysicalOperator {
37: public:
38: 	static constexpr const PhysicalOperatorType TYPE = PhysicalOperatorType::INVALID;
39: 
40: public:
41: 	PhysicalOperator(PhysicalOperatorType type, vector<LogicalType> types, idx_t estimated_cardinality)
42: 	    : type(type), types(std::move(types)), estimated_cardinality(estimated_cardinality) {
43: 	}
44: 
45: 	virtual ~PhysicalOperator() {
46: 	}
47: 
48: 	//! The physical operator type
49: 	PhysicalOperatorType type;
50: 	//! The set of children of the operator
51: 	vector<unique_ptr<PhysicalOperator>> children;
52: 	//! The types returned by this physical operator
53: 	vector<LogicalType> types;
54: 	//! The estimated cardinality of this physical operator
55: 	idx_t estimated_cardinality;
56: 
57: 	//! The global sink state of this operator
58: 	unique_ptr<GlobalSinkState> sink_state;
59: 	//! The global state of this operator
60: 	unique_ptr<GlobalOperatorState> op_state;
61: 	//! Lock for (re)setting any of the operator states
62: 	mutex lock;
63: 
64: public:
65: 	virtual string GetName() const;
66: 	virtual InsertionOrderPreservingMap<string> ParamsToString() const {
67: 		return InsertionOrderPreservingMap<string>();
68: 	}
69: 	static void SetEstimatedCardinality(InsertionOrderPreservingMap<string> &result, idx_t estimated_cardinality);
70: 	virtual string ToString(ExplainFormat format = ExplainFormat::DEFAULT) const;
71: 	void Print() const;
72: 	virtual vector<const_reference<PhysicalOperator>> GetChildren() const;
73: 
74: 	//! Return a vector of the types that will be returned by this operator
75: 	const vector<LogicalType> &GetTypes() const {
76: 		return types;
77: 	}
78: 
79: 	virtual bool Equals(const PhysicalOperator &other) const {
80: 		return false;
81: 	}
82: 
83: 	//! Functions to help decide how to set up pipeline dependencies
84: 	idx_t EstimatedThreadCount() const;
85: 	bool CanSaturateThreads(ClientContext &context) const;
86: 
87: 	virtual void Verify();
88: 
89: public:
90: 	// Operator interface
91: 	virtual unique_ptr<OperatorState> GetOperatorState(ExecutionContext &context) const;
92: 	virtual unique_ptr<GlobalOperatorState> GetGlobalOperatorState(ClientContext &context) const;
93: 	virtual OperatorResultType Execute(ExecutionContext &context, DataChunk &input, DataChunk &chunk,
94: 	                                   GlobalOperatorState &gstate, OperatorState &state) const;
95: 	virtual OperatorFinalizeResultType FinalExecute(ExecutionContext &context, DataChunk &chunk,
96: 	                                                GlobalOperatorState &gstate, OperatorState &state) const;
97: 
98: 	virtual bool ParallelOperator() const {
99: 		return false;
100: 	}
101: 
102: 	virtual bool RequiresFinalExecute() const {
103: 		return false;
104: 	}
105: 
106: 	//! The influence the operator has on order (insertion order means no influence)
107: 	virtual OrderPreservationType OperatorOrder() const {
108: 		return OrderPreservationType::INSERTION_ORDER;
109: 	}
110: 
111: public:
112: 	// Source interface
113: 	virtual unique_ptr<LocalSourceState> GetLocalSourceState(ExecutionContext &context,
114: 	                                                         GlobalSourceState &gstate) const;
115: 	virtual unique_ptr<GlobalSourceState> GetGlobalSourceState(ClientContext &context) const;
116: 	virtual SourceResultType GetData(ExecutionContext &context, DataChunk &chunk, OperatorSourceInput &input) const;
117: 
118: 	virtual OperatorPartitionData GetPartitionData(ExecutionContext &context, DataChunk &chunk,
119: 	                                               GlobalSourceState &gstate, LocalSourceState &lstate,
120: 	                                               const OperatorPartitionInfo &partition_info) const;
121: 
122: 	virtual bool IsSource() const {
123: 		return false;
124: 	}
125: 
126: 	virtual bool ParallelSource() const {
127: 		return false;
128: 	}
129: 
130: 	virtual bool SupportsPartitioning(const OperatorPartitionInfo &partition_info) const {
131: 		if (partition_info.AnyRequired()) {
132: 			return false;
133: 		}
134: 		return true;
135: 	}
136: 
137: 	//! The type of order emitted by the operator (as a source)
138: 	virtual OrderPreservationType SourceOrder() const {
139: 		return OrderPreservationType::INSERTION_ORDER;
140: 	}
141: 
142: 	//! Returns the current progress percentage, or a negative value if progress bars are not supported
143: 	virtual ProgressData GetProgress(ClientContext &context, GlobalSourceState &gstate) const;
144: 
145: 	//! Returns the current progress percentage, or a negative value if progress bars are not supported
146: 	virtual ProgressData GetSinkProgress(ClientContext &context, GlobalSinkState &gstate,
147: 	                                     const ProgressData source_progress) const {
148: 		return source_progress;
149: 	}
150: 
151: public:
152: 	// Sink interface
153: 
154: 	//! The sink method is called constantly with new input, as long as new input is available. Note that this method
155: 	//! CAN be called in parallel, proper locking is needed when accessing dat
156: 	//! a inside the GlobalSinkState.
157: 	virtual SinkResultType Sink(ExecutionContext &context, DataChunk &chunk, OperatorSinkInput &input) const;
158: 	//! The combine is called when a single thread has completed execution of its part of the pipeline, it is the final
159: 	//! time that a specific LocalSinkState is accessible. This method can be called in parallel while other Sink() or
160: 	//! Combine() calls are active on the same GlobalSinkState.
161: 	virtual SinkCombineResultType Combine(ExecutionContext &context, OperatorSinkCombineInput &input) const;
162: 	//! (optional) function that will be called before Finalize
163: 	//! For now, its only use is to to communicate memory usage in multi-join pipelines through TemporaryMemoryManager
164: 	virtual void PrepareFinalize(ClientContext &context, GlobalSinkState &sink_state) const;
165: 	//! The finalize is called when ALL threads are finished execution. It is called only once per pipeline, and is
166: 	//! entirely single threaded.
167: 	//! If Finalize returns SinkResultType::FINISHED, the sink is marked as finished
168: 	virtual SinkFinalizeType Finalize(Pipeline &pipeline, Event &event, ClientContext &context,
169: 	                                  OperatorSinkFinalizeInput &input) const;
170: 	//! For sinks with RequiresBatchIndex set to true, when a new batch starts being processed this method is called
171: 	//! This allows flushing of the current batch (e.g. to disk)
172: 	virtual SinkNextBatchType NextBatch(ExecutionContext &context, OperatorSinkNextBatchInput &input) const;
173: 
174: 	virtual unique_ptr<LocalSinkState> GetLocalSinkState(ExecutionContext &context) const;
175: 	virtual unique_ptr<GlobalSinkState> GetGlobalSinkState(ClientContext &context) const;
176: 
177: 	//! The maximum amount of memory the operator should use per thread.
178: 	static idx_t GetMaxThreadMemory(ClientContext &context);
179: 
180: 	//! Whether operator caching is allowed in the current execution context
181: 	static bool OperatorCachingAllowed(ExecutionContext &context);
182: 
183: 	virtual bool IsSink() const {
184: 		return false;
185: 	}
186: 
187: 	virtual bool ParallelSink() const {
188: 		return false;
189: 	}
190: 
191: 	virtual OperatorPartitionInfo RequiredPartitionInfo() const {
192: 		return OperatorPartitionInfo::NoPartitionInfo();
193: 	}
194: 
195: 	//! Whether or not the sink operator depends on the order of the input chunks
196: 	//! If this is set to true, we cannot do things like caching intermediate vectors
197: 	virtual bool SinkOrderDependent() const {
198: 		return false;
199: 	}
200: 
201: public:
202: 	// Pipeline construction
203: 	virtual vector<const_reference<PhysicalOperator>> GetSources() const;
204: 	bool AllSourcesSupportBatchIndex() const;
205: 
206: 	virtual void BuildPipelines(Pipeline &current, MetaPipeline &meta_pipeline);
207: 
208: public:
209: 	template <class TARGET>
210: 	TARGET &Cast() {
211: 		if (TARGET::TYPE != PhysicalOperatorType::INVALID && type != TARGET::TYPE) {
212: 			throw InternalException("Failed to cast physical operator to type - physical operator type mismatch");
213: 		}
214: 		return reinterpret_cast<TARGET &>(*this);
215: 	}
216: 
217: 	template <class TARGET>
218: 	const TARGET &Cast() const {
219: 		if (TARGET::TYPE != PhysicalOperatorType::INVALID && type != TARGET::TYPE) {
220: 			throw InternalException("Failed to cast physical operator to type - physical operator type mismatch");
221: 		}
222: 		return reinterpret_cast<const TARGET &>(*this);
223: 	}
224: };
225: 
226: //! Contains state for the CachingPhysicalOperator
227: class CachingOperatorState : public OperatorState {
228: public:
229: 	~CachingOperatorState() override {
230: 	}
231: 
232: 	void Finalize(const PhysicalOperator &op, ExecutionContext &context) override {
233: 	}
234: 
235: 	unique_ptr<DataChunk> cached_chunk;
236: 	bool initialized = false;
237: 	//! Whether or not the chunk can be cached
238: 	bool can_cache_chunk = false;
239: };
240: 
241: //! Base class that caches output from child Operator class. Note that Operators inheriting from this class should also
242: //! inherit their state class from the CachingOperatorState.
243: class CachingPhysicalOperator : public PhysicalOperator {
244: public:
245: 	static constexpr const idx_t CACHE_THRESHOLD = 64;
246: 	CachingPhysicalOperator(PhysicalOperatorType type, vector<LogicalType> types, idx_t estimated_cardinality);
247: 
248: 	bool caching_supported;
249: 
250: public:
251: 	//! This Execute will prevent small chunks from entering the pipeline, buffering them until a bigger chunk is
252: 	//! created.
253: 	OperatorResultType Execute(ExecutionContext &context, DataChunk &input, DataChunk &chunk,
254: 	                           GlobalOperatorState &gstate, OperatorState &state) const final;
255: 	//! FinalExecute is used here to send out the remainder of the chunk (< STANDARD_VECTOR_SIZE) that we still had
256: 	//! cached.
257: 	OperatorFinalizeResultType FinalExecute(ExecutionContext &context, DataChunk &chunk, GlobalOperatorState &gstate,
258: 	                                        OperatorState &state) const final;
259: 
260: 	bool RequiresFinalExecute() const final {
261: 		return caching_supported;
262: 	}
263: 
264: protected:
265: 	//! Child classes need to implement the ExecuteInternal method instead of the Execute
266: 	virtual OperatorResultType ExecuteInternal(ExecutionContext &context, DataChunk &input, DataChunk &chunk,
267: 	                                           GlobalOperatorState &gstate, OperatorState &state) const = 0;
268: 
269: private:
270: 	bool CanCacheType(const LogicalType &type);
271: };
272: 
273: } // namespace duckdb
[end of src/include/duckdb/execution/physical_operator.hpp]
[start of src/include/duckdb/execution/reservoir_sample.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/reservoir_sample.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/allocator.hpp"
12: #include "duckdb/common/common.hpp"
13: #include "duckdb/common/random_engine.hpp"
14: #include "duckdb/common/types/data_chunk.hpp"
15: 
16: #include "duckdb/common/queue.hpp"
17: 
18: namespace duckdb {
19: 
20: enum class SampleType : uint8_t { BLOCKING_SAMPLE = 0, RESERVOIR_SAMPLE = 1, RESERVOIR_PERCENTAGE_SAMPLE = 2 };
21: 
22: class BaseReservoirSampling {
23: public:
24: 	explicit BaseReservoirSampling(int64_t seed);
25: 	BaseReservoirSampling();
26: 
27: 	void InitializeReservoir(idx_t cur_size, idx_t sample_size);
28: 
29: 	void SetNextEntry();
30: 
31: 	void ReplaceElement(double with_weight = -1);
32: 	//! The random generator
33: 	RandomEngine random;
34: 	//! The next element to sample
35: 	idx_t next_index_to_sample;
36: 	//! The reservoir threshold of the current min entry
37: 	double min_weight_threshold;
38: 	//! The reservoir index of the current min entry
39: 	idx_t min_weighted_entry_index;
40: 	//! The current count towards next index (i.e. we will replace an entry in next_index - current_count tuples)
41: 	//! The number of entries "seen" before choosing one that will go in our reservoir sample.
42: 	idx_t num_entries_to_skip_b4_next_sample;
43: 	//! when collecting a sample in parallel, we want to know how many values each thread has seen
44: 	//! so we can collect the samples from the thread local states in a uniform manner
45: 	idx_t num_entries_seen_total;
46: 	//! Priority queue of [random element, index] for each of the elements in the sample
47: 	std::priority_queue<std::pair<double, idx_t>> reservoir_weights;
48: 
49: 	void Serialize(Serializer &serializer) const;
50: 	static unique_ptr<BaseReservoirSampling> Deserialize(Deserializer &deserializer);
51: };
52: 
53: class BlockingSample {
54: public:
55: 	static constexpr const SampleType TYPE = SampleType::BLOCKING_SAMPLE;
56: 
57: 	unique_ptr<BaseReservoirSampling> base_reservoir_sample;
58: 	//! The sample type
59: 	SampleType type;
60: 	//! has the sample been destroyed due to updates to the referenced table
61: 	bool destroyed;
62: 
63: public:
64: 	explicit BlockingSample(int64_t seed) : old_base_reservoir_sample(seed), random(old_base_reservoir_sample.random) {
65: 		base_reservoir_sample = nullptr;
66: 	}
67: 	virtual ~BlockingSample() {
68: 	}
69: 
70: 	//! Add a chunk of data to the sample
71: 	virtual void AddToReservoir(DataChunk &input) = 0;
72: 
73: 	virtual void Finalize() = 0;
74: 	//! Fetches a chunk from the sample. Note that this method is destructive and should only be used after the
75: 	//! sample is completely built.
76: 	virtual unique_ptr<DataChunk> GetChunk() = 0;
77: 	BaseReservoirSampling old_base_reservoir_sample;
78: 
79: 	virtual void Serialize(Serializer &serializer) const;
80: 	static unique_ptr<BlockingSample> Deserialize(Deserializer &deserializer);
81: 
82: public:
83: 	template <class TARGET>
84: 	TARGET &Cast() {
85: 		if (type != TARGET::TYPE && TARGET::TYPE != SampleType::BLOCKING_SAMPLE) {
86: 			throw InternalException("Failed to cast sample to type - sample type mismatch");
87: 		}
88: 		return reinterpret_cast<TARGET &>(*this);
89: 	}
90: 
91: 	template <class TARGET>
92: 	const TARGET &Cast() const {
93: 		if (type != TARGET::TYPE && TARGET::TYPE != SampleType::BLOCKING_SAMPLE) {
94: 			throw InternalException("Failed to cast sample to type - sample type mismatch");
95: 		}
96: 		return reinterpret_cast<const TARGET &>(*this);
97: 	}
98: 	//! The reservoir sampling
99: 	RandomEngine &random;
100: };
101: 
102: class ReservoirChunk {
103: public:
104: 	ReservoirChunk() {
105: 	}
106: 
107: 	DataChunk chunk;
108: 	void Serialize(Serializer &serializer) const;
109: 	static unique_ptr<ReservoirChunk> Deserialize(Deserializer &deserializer);
110: };
111: 
112: //! The reservoir sample class maintains a streaming sample of fixed size "sample_count"
113: class ReservoirSample : public BlockingSample {
114: public:
115: 	static constexpr const SampleType TYPE = SampleType::RESERVOIR_SAMPLE;
116: 
117: public:
118: 	ReservoirSample(Allocator &allocator, idx_t sample_count, int64_t seed = 1);
119: 	explicit ReservoirSample(idx_t sample_count, int64_t seed = 1);
120: 
121: 	//! Add a chunk of data to the sample
122: 	void AddToReservoir(DataChunk &input) override;
123: 
124: 	//! Fetches a chunk from the sample. Note that this method is destructive and should only be used after the
125: 	//! sample is completely built.
126: 	unique_ptr<DataChunk> GetChunk() override;
127: 	void Finalize() override;
128: 	void Serialize(Serializer &serializer) const override;
129: 	static unique_ptr<BlockingSample> Deserialize(Deserializer &deserializer);
130: 
131: private:
132: 	//! Replace a single element of the input
133: 	void ReplaceElement(DataChunk &input, idx_t index_in_chunk, double with_weight = -1);
134: 	void InitializeReservoir(DataChunk &input);
135: 	//! Fills the reservoir up until sample_count entries, returns how many entries are still required
136: 	idx_t FillReservoir(DataChunk &input);
137: 
138: public:
139: 	Allocator &allocator;
140: 	//! The size of the reservoir sample.
141: 	//! when calculating percentages, it is set to reservoir_threshold * percentage
142: 	//! when explicit number used, sample_count = number
143: 	idx_t sample_count;
144: 	bool reservoir_initialized;
145: 
146: 	//! The current reservoir
147: 	unique_ptr<DataChunk> reservoir_data_chunk;
148: 	unique_ptr<ReservoirChunk> reservoir_chunk;
149: };
150: 
151: //! The reservoir sample sample_size class maintains a streaming sample of variable size
152: class ReservoirSamplePercentage : public BlockingSample {
153: 	constexpr static idx_t RESERVOIR_THRESHOLD = 100000;
154: 
155: public:
156: 	static constexpr const SampleType TYPE = SampleType::RESERVOIR_PERCENTAGE_SAMPLE;
157: 
158: public:
159: 	ReservoirSamplePercentage(Allocator &allocator, double percentage, int64_t seed = -1);
160: 	explicit ReservoirSamplePercentage(double percentage, int64_t seed = -1);
161: 
162: 	//! Add a chunk of data to the sample
163: 	void AddToReservoir(DataChunk &input) override;
164: 
165: 	//! Fetches a chunk from the sample. Note that this method is destructive and should only be used after the
166: 	//! sample is completely built.
167: 	unique_ptr<DataChunk> GetChunk() override;
168: 	void Finalize() override;
169: 
170: 	void Serialize(Serializer &serializer) const override;
171: 	static unique_ptr<BlockingSample> Deserialize(Deserializer &deserializer);
172: 
173: private:
174: 	Allocator &allocator;
175: 	//! The sample_size to sample
176: 	double sample_percentage;
177: 	//! The fixed sample size of the sub-reservoirs
178: 	idx_t reservoir_sample_size;
179: 
180: 	//! The current sample
181: 	unique_ptr<ReservoirSample> current_sample;
182: 
183: 	//! The set of finished samples of the reservoir sample
184: 	vector<unique_ptr<ReservoirSample>> finished_samples;
185: 	//! The amount of tuples that have been processed so far (not put in the reservoir, just processed)
186: 	idx_t current_count = 0;
187: 	//! Whether or not the stream is finalized. The stream is automatically finalized on the first call to GetChunk();
188: 	bool is_finalized;
189: };
190: 
191: } // namespace duckdb
[end of src/include/duckdb/execution/reservoir_sample.hpp]
[start of src/include/duckdb/function/table/system_functions.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/table/system_functions.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/table_function.hpp"
12: #include "duckdb/function/built_in_functions.hpp"
13: 
14: namespace duckdb {
15: 
16: struct PragmaCollations {
17: 	static void RegisterFunction(BuiltinFunctions &set);
18: };
19: 
20: struct PragmaTableInfo {
21: 	static void GetColumnInfo(TableCatalogEntry &table, const ColumnDefinition &column, DataChunk &output, idx_t index);
22: 
23: 	static void RegisterFunction(BuiltinFunctions &set);
24: };
25: 
26: struct PragmaStorageInfo {
27: 	static void RegisterFunction(BuiltinFunctions &set);
28: };
29: 
30: struct PragmaMetadataInfo {
31: 	static void RegisterFunction(BuiltinFunctions &set);
32: };
33: 
34: struct PragmaVersion {
35: 	static void RegisterFunction(BuiltinFunctions &set);
36: };
37: 
38: struct PragmaPlatform {
39: 	static void RegisterFunction(BuiltinFunctions &set);
40: };
41: 
42: struct PragmaDatabaseSize {
43: 	static void RegisterFunction(BuiltinFunctions &set);
44: };
45: 
46: struct DuckDBSchemasFun {
47: 	static void RegisterFunction(BuiltinFunctions &set);
48: };
49: 
50: struct DuckDBColumnsFun {
51: 	static void RegisterFunction(BuiltinFunctions &set);
52: };
53: 
54: struct DuckDBConstraintsFun {
55: 	static void RegisterFunction(BuiltinFunctions &set);
56: };
57: 
58: struct DuckDBSecretsFun {
59: 	static void RegisterFunction(BuiltinFunctions &set);
60: };
61: 
62: struct DuckDBWhichSecretFun {
63: 	static void RegisterFunction(BuiltinFunctions &set);
64: };
65: 
66: struct DuckDBDatabasesFun {
67: 	static void RegisterFunction(BuiltinFunctions &set);
68: };
69: 
70: struct DuckDBDependenciesFun {
71: 	static void RegisterFunction(BuiltinFunctions &set);
72: };
73: 
74: struct DuckDBExtensionsFun {
75: 	static void RegisterFunction(BuiltinFunctions &set);
76: };
77: 
78: struct DuckDBFunctionsFun {
79: 	static void RegisterFunction(BuiltinFunctions &set);
80: };
81: 
82: struct DuckDBKeywordsFun {
83: 	static void RegisterFunction(BuiltinFunctions &set);
84: };
85: 
86: struct DuckDBIndexesFun {
87: 	static void RegisterFunction(BuiltinFunctions &set);
88: };
89: 
90: struct DuckDBMemoryFun {
91: 	static void RegisterFunction(BuiltinFunctions &set);
92: };
93: 
94: struct DuckDBOptimizersFun {
95: 	static void RegisterFunction(BuiltinFunctions &set);
96: };
97: 
98: struct DuckDBSequencesFun {
99: 	static void RegisterFunction(BuiltinFunctions &set);
100: };
101: 
102: struct DuckDBSettingsFun {
103: 	static void RegisterFunction(BuiltinFunctions &set);
104: };
105: 
106: struct DuckDBTablesFun {
107: 	static void RegisterFunction(BuiltinFunctions &set);
108: };
109: 
110: struct DuckDBTemporaryFilesFun {
111: 	static void RegisterFunction(BuiltinFunctions &set);
112: };
113: 
114: struct DuckDBTypesFun {
115: 	static void RegisterFunction(BuiltinFunctions &set);
116: };
117: 
118: struct DuckDBVariablesFun {
119: 	static void RegisterFunction(BuiltinFunctions &set);
120: };
121: 
122: struct DuckDBViewsFun {
123: 	static void RegisterFunction(BuiltinFunctions &set);
124: };
125: 
126: struct TestType {
127: 	TestType(LogicalType type_p, string name_p)
128: 	    : type(std::move(type_p)), name(std::move(name_p)), min_value(Value::MinimumValue(type)),
129: 	      max_value(Value::MaximumValue(type)) {
130: 	}
131: 	TestType(LogicalType type_p, string name_p, Value min, Value max)
132: 	    : type(std::move(type_p)), name(std::move(name_p)), min_value(std::move(min)), max_value(std::move(max)) {
133: 	}
134: 
135: 	LogicalType type;
136: 	string name;
137: 	Value min_value;
138: 	Value max_value;
139: };
140: 
141: struct TestAllTypesFun {
142: 	static void RegisterFunction(BuiltinFunctions &set);
143: 	static vector<TestType> GetTestTypes(bool large_enum = false);
144: };
145: 
146: struct TestVectorTypesFun {
147: 	static void RegisterFunction(BuiltinFunctions &set);
148: };
149: 
150: struct PragmaUserAgent {
151: 	static void RegisterFunction(BuiltinFunctions &set);
152: };
153: 
154: } // namespace duckdb
[end of src/include/duckdb/function/table/system_functions.hpp]
[start of src/include/duckdb/main/client_data.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/client_data.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/enums/output_type.hpp"
13: #include "duckdb/common/types/value.hpp"
14: #include "duckdb/common/case_insensitive_map.hpp"
15: #include "duckdb/common/atomic.hpp"
16: #include "duckdb/execution/operator/csv_scanner/csv_state_machine_cache.hpp"
17: 
18: namespace duckdb {
19: class AttachedDatabase;
20: class BufferedFileWriter;
21: class ClientContext;
22: class CatalogSearchPath;
23: class FileOpener;
24: class FileSystem;
25: class HTTPState;
26: class QueryProfiler;
27: class PreparedStatementData;
28: class SchemaCatalogEntry;
29: class HTTPLogger;
30: struct RandomEngine;
31: 
32: struct ClientData {
33: 	explicit ClientData(ClientContext &context);
34: 	~ClientData();
35: 
36: 	//! Query profiler
37: 	shared_ptr<QueryProfiler> profiler;
38: 
39: 	//! HTTP logger
40: 	shared_ptr<HTTPLogger> http_logger;
41: 
42: 	//! The set of temporary objects that belong to this client
43: 	shared_ptr<AttachedDatabase> temporary_objects;
44: 	//! The set of bound prepared statements that belong to this client
45: 	case_insensitive_map_t<shared_ptr<PreparedStatementData>> prepared_statements;
46: 
47: 	//! The writer used to log queries (if logging is enabled)
48: 	unique_ptr<BufferedFileWriter> log_query_writer;
49: 	//! The random generator used by random(). Its seed value can be set by setseed().
50: 	unique_ptr<RandomEngine> random_engine;
51: 
52: 	//! The catalog search path
53: 	unique_ptr<CatalogSearchPath> catalog_search_path;
54: 
55: 	//! The file opener of the client context
56: 	unique_ptr<FileOpener> file_opener;
57: 
58: 	//! The clients' file system wrapper
59: 	unique_ptr<FileSystem> client_file_system;
60: 
61: 	//! The file search path
62: 	string file_search_path;
63: 
64: 	//! The Max Line Length Size of Last Query Executed on a CSV File. (Only used for testing)
65: 	//! FIXME: this should not be done like this
66: 	bool debug_set_max_line_length = false;
67: 	idx_t debug_max_line_length = 0;
68: 
69: public:
70: 	DUCKDB_API static ClientData &Get(ClientContext &context);
71: 	DUCKDB_API static const ClientData &Get(const ClientContext &context);
72: };
73: 
74: } // namespace duckdb
[end of src/include/duckdb/main/client_data.hpp]
[start of src/include/duckdb/storage/data_table.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/storage/data_table.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/enums/index_constraint_type.hpp"
12: #include "duckdb/common/types/data_chunk.hpp"
13: #include "duckdb/common/unique_ptr.hpp"
14: #include "duckdb/storage/index.hpp"
15: #include "duckdb/storage/statistics/column_statistics.hpp"
16: #include "duckdb/storage/table/column_segment.hpp"
17: #include "duckdb/storage/table/data_table_info.hpp"
18: #include "duckdb/storage/table/persistent_table_data.hpp"
19: #include "duckdb/storage/table/row_group.hpp"
20: #include "duckdb/storage/table/row_group_collection.hpp"
21: #include "duckdb/storage/table/table_statistics.hpp"
22: #include "duckdb/transaction/local_storage.hpp"
23: 
24: namespace duckdb {
25: 
26: class BoundForeignKeyConstraint;
27: class ClientContext;
28: class ColumnDataCollection;
29: class ColumnDefinition;
30: class DataTable;
31: class DuckTransaction;
32: class OptimisticDataWriter;
33: class RowGroup;
34: class StorageManager;
35: class TableCatalogEntry;
36: class TableIOManager;
37: class Transaction;
38: class WriteAheadLog;
39: class TableDataWriter;
40: class ConflictManager;
41: class TableScanState;
42: struct TableDeleteState;
43: struct ConstraintState;
44: struct TableUpdateState;
45: enum class VerifyExistenceType : uint8_t;
46: 
47: //! DataTable represents a physical table on disk
48: class DataTable {
49: public:
50: 	//! Constructs a new data table from an (optional) set of persistent segments
51: 	DataTable(AttachedDatabase &db, shared_ptr<TableIOManager> table_io_manager, const string &schema,
52: 	          const string &table, vector<ColumnDefinition> column_definitions_p,
53: 	          unique_ptr<PersistentTableData> data = nullptr);
54: 	//! Constructs a DataTable as a delta on an existing data table with a newly added column
55: 	DataTable(ClientContext &context, DataTable &parent, ColumnDefinition &new_column, Expression &default_value);
56: 	//! Constructs a DataTable as a delta on an existing data table but with one column removed
57: 	DataTable(ClientContext &context, DataTable &parent, idx_t removed_column);
58: 	//! Constructs a DataTable as a delta on an existing data table but with one column changed type
59: 	DataTable(ClientContext &context, DataTable &parent, idx_t changed_idx, const LogicalType &target_type,
60: 	          const vector<StorageIndex> &bound_columns, Expression &cast_expr);
61: 	//! Constructs a DataTable as a delta on an existing data table but with one column added new constraint
62: 	DataTable(ClientContext &context, DataTable &parent, BoundConstraint &constraint);
63: 
64: 	//! A reference to the database instance
65: 	AttachedDatabase &db;
66: 
67: public:
68: 	AttachedDatabase &GetAttached();
69: 	TableIOManager &GetTableIOManager();
70: 
71: 	bool IsTemporary() const;
72: 
73: 	//! Returns a list of types of the table
74: 	vector<LogicalType> GetTypes();
75: 	const vector<ColumnDefinition> &Columns() const;
76: 
77: 	void InitializeScan(DuckTransaction &transaction, TableScanState &state, const vector<StorageIndex> &column_ids,
78: 	                    TableFilterSet *table_filters = nullptr);
79: 
80: 	//! Returns the maximum amount of threads that should be assigned to scan this data table
81: 	idx_t MaxThreads(ClientContext &context) const;
82: 	void InitializeParallelScan(ClientContext &context, ParallelTableScanState &state);
83: 	bool NextParallelScan(ClientContext &context, ParallelTableScanState &state, TableScanState &scan_state);
84: 
85: 	//! Scans up to STANDARD_VECTOR_SIZE elements from the table starting
86: 	//! from offset and store them in result. Offset is incremented with how many
87: 	//! elements were returned.
88: 	//! Returns true if all pushed down filters were executed during data fetching
89: 	void Scan(DuckTransaction &transaction, DataChunk &result, TableScanState &state);
90: 
91: 	//! Fetch data from the specific row identifiers from the base table
92: 	void Fetch(DuckTransaction &transaction, DataChunk &result, const vector<StorageIndex> &column_ids,
93: 	           const Vector &row_ids, idx_t fetch_count, ColumnFetchState &state);
94: 
95: 	//! Initializes appending to transaction-local storage
96: 	void InitializeLocalAppend(LocalAppendState &state, TableCatalogEntry &table, ClientContext &context,
97: 	                           const vector<unique_ptr<BoundConstraint>> &bound_constraints);
98: 	//! Initializes only the delete-indexes of the transaction-local storage
99: 	void InitializeLocalStorage(LocalAppendState &state, TableCatalogEntry &table, ClientContext &context,
100: 	                            const vector<unique_ptr<BoundConstraint>> &bound_constraints);
101: 	//! Append a DataChunk to the transaction-local storage of the table.
102: 	void LocalAppend(LocalAppendState &state, ClientContext &context, DataChunk &chunk, bool unsafe);
103: 	//! Finalizes a transaction-local append
104: 	void FinalizeLocalAppend(LocalAppendState &state);
105: 	//! Append a chunk to the transaction-local storage of this table and update the delete indexes.
106: 	void LocalAppend(TableCatalogEntry &table, ClientContext &context, DataChunk &chunk,
107: 	                 const vector<unique_ptr<BoundConstraint>> &bound_constraints, Vector &row_ids,
108: 	                 DataChunk &delete_chunk);
109: 	//! Append a chunk to the transaction-local storage of this table.
110: 	void LocalAppend(TableCatalogEntry &table, ClientContext &context, DataChunk &chunk,
111: 	                 const vector<unique_ptr<BoundConstraint>> &bound_constraints);
112: 	//! Append a column data collection with default values to the transaction-local storage of this table.
113: 	void LocalAppend(TableCatalogEntry &table, ClientContext &context, ColumnDataCollection &collection,
114: 	                 const vector<unique_ptr<BoundConstraint>> &bound_constraints,
115: 	                 optional_ptr<const vector<LogicalIndex>> column_ids);
116: 	//! Merge a row group collection into the transaction-local storage
117: 	void LocalMerge(ClientContext &context, RowGroupCollection &collection);
118: 	//! Creates an optimistic writer for this table - used for optimistically writing parallel appends
119: 	OptimisticDataWriter &CreateOptimisticWriter(ClientContext &context);
120: 	void FinalizeOptimisticWriter(ClientContext &context, OptimisticDataWriter &writer);
121: 
122: 	unique_ptr<TableDeleteState> InitializeDelete(TableCatalogEntry &table, ClientContext &context,
123: 	                                              const vector<unique_ptr<BoundConstraint>> &bound_constraints);
124: 	//! Delete the entries with the specified row identifier from the table
125: 	idx_t Delete(TableDeleteState &state, ClientContext &context, Vector &row_ids, idx_t count);
126: 
127: 	unique_ptr<TableUpdateState> InitializeUpdate(TableCatalogEntry &table, ClientContext &context,
128: 	                                              const vector<unique_ptr<BoundConstraint>> &bound_constraints);
129: 	//! Update the entries with the specified row identifier from the table
130: 	void Update(TableUpdateState &state, ClientContext &context, Vector &row_ids,
131: 	            const vector<PhysicalIndex> &column_ids, DataChunk &data);
132: 	//! Update a single (sub-)column along a column path
133: 	//! The column_path vector is a *path* towards a column within the table
134: 	//! i.e. if we have a table with a single column S STRUCT(A INT, B INT)
135: 	//! and we update the validity mask of "S.B"
136: 	//! the column path is:
137: 	//! 0 (first column of table)
138: 	//! -> 1 (second subcolumn of struct)
139: 	//! -> 0 (first subcolumn of INT)
140: 	//! This method should only be used from the WAL replay. It does not verify update constraints.
141: 	void UpdateColumn(TableCatalogEntry &table, ClientContext &context, Vector &row_ids,
142: 	                  const vector<column_t> &column_path, DataChunk &updates);
143: 
144: 	//! Fetches an append lock
145: 	void AppendLock(TableAppendState &state);
146: 	//! Begin appending structs to this table, obtaining necessary locks, etc
147: 	void InitializeAppend(DuckTransaction &transaction, TableAppendState &state);
148: 	//! Append a chunk to the table using the AppendState obtained from InitializeAppend
149: 	void Append(DataChunk &chunk, TableAppendState &state);
150: 	//! Finalize an append
151: 	void FinalizeAppend(DuckTransaction &transaction, TableAppendState &state);
152: 	//! Commit the append
153: 	void CommitAppend(transaction_t commit_id, idx_t row_start, idx_t count);
154: 	//! Write a segment of the table to the WAL
155: 	void WriteToLog(DuckTransaction &transaction, WriteAheadLog &log, idx_t row_start, idx_t count,
156: 	                optional_ptr<StorageCommitState> commit_state);
157: 	//! Revert a set of appends made by the given AppendState, used to revert appends in the event of an error during
158: 	//! commit (e.g. because of an I/O exception)
159: 	void RevertAppend(DuckTransaction &transaction, idx_t start_row, idx_t count);
160: 	void RevertAppendInternal(idx_t start_row);
161: 
162: 	void ScanTableSegment(DuckTransaction &transaction, idx_t start_row, idx_t count,
163: 	                      const std::function<void(DataChunk &chunk)> &function);
164: 
165: 	//! Merge a row group collection directly into this table - appending it to the end of the table without copying
166: 	void MergeStorage(RowGroupCollection &data, TableIndexList &indexes, optional_ptr<StorageCommitState> commit_state);
167: 
168: 	//! Append a chunk with the row ids [row_start, ..., row_start + chunk.size()] to all indexes of the table.
169: 	//! Returns empty ErrorData, if the append was successful.
170: 	ErrorData AppendToIndexes(optional_ptr<TableIndexList> delete_indexes, DataChunk &chunk, row_t row_start);
171: 	static ErrorData AppendToIndexes(TableIndexList &indexes, optional_ptr<TableIndexList> delete_indexes,
172: 	                                 DataChunk &chunk, row_t row_start);
173: 	//! Remove a chunk with the row ids [row_start, ..., row_start + chunk.size()] from all indexes of the table
174: 	void RemoveFromIndexes(TableAppendState &state, DataChunk &chunk, row_t row_start);
175: 	//! Remove the chunk with the specified set of row identifiers from all indexes of the table
176: 	void RemoveFromIndexes(TableAppendState &state, DataChunk &chunk, Vector &row_identifiers);
177: 	//! Remove the row identifiers from all the indexes of the table
178: 	void RemoveFromIndexes(Vector &row_identifiers, idx_t count);
179: 
180: 	void SetAsRoot() {
181: 		this->is_root = true;
182: 	}
183: 
184: 	bool IsRoot() {
185: 		return this->is_root;
186: 	}
187: 
188: 	//! Get statistics of a physical column within the table
189: 	unique_ptr<BaseStatistics> GetStatistics(ClientContext &context, column_t column_id);
190: 	//! Sets statistics of a physical column within the table
191: 	void SetDistinct(column_t column_id, unique_ptr<DistinctStatistics> distinct_stats);
192: 
193: 	//! Obtains a shared lock to prevent checkpointing while operations are running
194: 	unique_ptr<StorageLockKey> GetSharedCheckpointLock();
195: 	//! Obtains a lock during a checkpoint operation that prevents other threads from reading this table
196: 	unique_ptr<StorageLockKey> GetCheckpointLock();
197: 	//! Checkpoint the table to the specified table data writer
198: 	void Checkpoint(TableDataWriter &writer, Serializer &serializer);
199: 	void CommitDropTable();
200: 	void CommitDropColumn(idx_t index);
201: 
202: 	idx_t ColumnCount() const;
203: 	idx_t GetTotalRows() const;
204: 
205: 	vector<ColumnSegmentInfo> GetColumnSegmentInfo();
206: 	static bool IsForeignKeyIndex(const vector<PhysicalIndex> &fk_keys, Index &index, ForeignKeyType fk_type);
207: 
208: 	//! Scans the next chunk for the CREATE INDEX operator
209: 	bool CreateIndexScan(TableScanState &state, DataChunk &result, TableScanType type);
210: 	//! Returns true, if the index name is unique (i.e., no PK, UNIQUE, FK constraint has the same name)
211: 	//! FIXME: This is only necessary until we treat all indexes as catalog entries, allowing to alter constraints
212: 	bool IndexNameIsUnique(const string &name);
213: 
214: 	//! Initialize constraint verification state
215: 	unique_ptr<ConstraintState> InitializeConstraintState(TableCatalogEntry &table,
216: 	                                                      const vector<unique_ptr<BoundConstraint>> &bound_constraints);
217: 	//! Verify constraints with a chunk from the Append containing all columns of the table
218: 	void VerifyAppendConstraints(ConstraintState &constraint_state, ClientContext &context, DataChunk &chunk,
219: 	                             optional_ptr<LocalTableStorage> local_storage, optional_ptr<ConflictManager> manager);
220: 
221: 	shared_ptr<DataTableInfo> &GetDataTableInfo();
222: 
223: 	void InitializeIndexes(ClientContext &context);
224: 	bool HasIndexes() const;
225: 	bool HasUniqueIndexes() const;
226: 	bool HasForeignKeyIndex(const vector<PhysicalIndex> &keys, ForeignKeyType type);
227: 	void SetIndexStorageInfo(vector<IndexStorageInfo> index_storage_info);
228: 	void VacuumIndexes();
229: 	void CleanupAppend(transaction_t lowest_transaction, idx_t start, idx_t count);
230: 
231: 	string GetTableName() const;
232: 	void SetTableName(string new_name);
233: 
234: 	TableStorageInfo GetStorageInfo();
235: 
236: 	idx_t GetRowGroupSize() const;
237: 
238: 	static void VerifyUniqueIndexes(TableIndexList &indexes, optional_ptr<LocalTableStorage> storage, DataChunk &chunk,
239: 	                                optional_ptr<ConflictManager> manager);
240: 
241: 	//! AddIndex initializes an index and adds it to the table's index list.
242: 	//! It is either empty, or initialized via its index storage information.
243: 	void AddIndex(const ColumnList &columns, const vector<LogicalIndex> &column_indexes, const IndexConstraintType type,
244: 	              const IndexStorageInfo &info);
245: 	//! AddIndex moves an index to this table's index list.
246: 	void AddIndex(unique_ptr<Index> index);
247: 
248: 	//! Returns a list of the partition stats
249: 	vector<PartitionStatistics> GetPartitionStats(ClientContext &context);
250: 
251: private:
252: 	//! Verify the new added constraints against current persistent&local data
253: 	void VerifyNewConstraint(LocalStorage &local_storage, DataTable &parent, const BoundConstraint &constraint);
254: 
255: 	//! Verify constraints with a chunk from the Update containing only the specified column_ids
256: 	void VerifyUpdateConstraints(ConstraintState &state, ClientContext &context, DataChunk &chunk,
257: 	                             const vector<PhysicalIndex> &column_ids);
258: 	//! Verify constraints with a chunk from the Delete containing all columns of the table
259: 	void VerifyDeleteConstraints(TableDeleteState &state, ClientContext &context, DataChunk &chunk);
260: 
261: 	void InitializeScanWithOffset(DuckTransaction &transaction, TableScanState &state,
262: 	                              const vector<StorageIndex> &column_ids, idx_t start_row, idx_t end_row);
263: 
264: 	void VerifyForeignKeyConstraint(const BoundForeignKeyConstraint &bfk, ClientContext &context, DataChunk &chunk,
265: 	                                VerifyExistenceType verify_type);
266: 	void VerifyAppendForeignKeyConstraint(const BoundForeignKeyConstraint &bfk, ClientContext &context,
267: 	                                      DataChunk &chunk);
268: 	void VerifyDeleteForeignKeyConstraint(const BoundForeignKeyConstraint &bfk, ClientContext &context,
269: 	                                      DataChunk &chunk);
270: 
271: private:
272: 	//! The table info
273: 	shared_ptr<DataTableInfo> info;
274: 	//! The set of physical columns stored by this DataTable
275: 	vector<ColumnDefinition> column_definitions;
276: 	//! Lock for appending entries to the table
277: 	mutex append_lock;
278: 	//! The row groups of the table
279: 	shared_ptr<RowGroupCollection> row_groups;
280: 	//! Whether or not the data table is the root DataTable for this table; the root DataTable is the newest version
281: 	//! that can be appended to
282: 	atomic<bool> is_root;
283: };
284: } // namespace duckdb
[end of src/include/duckdb/storage/data_table.hpp]
[start of src/include/duckdb/storage/serialization/nodes.json]
1: [
2:   {
3:     "class": "LogicalType",
4:     "includes": [
5:       "duckdb/common/types.hpp",
6:       "duckdb/common/extra_type_info.hpp"
7:     ],
8:     "members": [
9:       {
10:         "id": 100,
11:         "name": "id",
12:         "type": "LogicalTypeId",
13:         "serialize_property": "id_"
14:       },
15:       {
16:         "id": 101,
17:         "name": "type_info",
18:         "type": "shared_ptr<ExtraTypeInfo>",
19:         "serialize_property": "type_info_"
20:       }
21:     ],
22:     "pointer_type": "none",
23:     "constructor": ["id", "type_info"]
24:   },
25:   {
26:     "class": "CommonTableExpressionInfo",
27:     "includes": [
28:       "duckdb/parser/common_table_expression_info.hpp"
29:     ],
30:     "members": [
31:       {
32:         "id": 100,
33:         "name": "aliases",
34:         "type": "vector<string>"
35:       },
36:       {
37:         "id": 101,
38:         "name": "query",
39:         "type": "SelectStatement*"
40:       },
41:       {
42:         "id": 102,
43:         "name": "materialized",
44:         "type": "CTEMaterialize"
45:       }
46:     ]
47:   },
48:   {
49:     "class": "CommonTableExpressionMap",
50:     "includes": [
51:       "duckdb/parser/query_node.hpp"
52:     ],
53:     "members": [
54:       {
55:         "id": 100,
56:         "name": "map",
57:         "type": "InsertionOrderPreservingMap<CommonTableExpressionInfo*>"
58:       }
59:     ],
60:     "pointer_type": "none"
61:   },
62:   {
63:     "class": "OrderByNode",
64:     "includes": [
65:       "duckdb/parser/result_modifier.hpp"
66:     ],
67:     "members": [
68:       {
69:         "id": 100,
70:         "name": "type",
71:         "type": "OrderType"
72:       },
73:       {
74:         "id": 101,
75:         "name": "null_order",
76:         "type": "OrderByNullType"
77:       },
78:       {
79:         "id": 102,
80:         "name": "expression",
81:         "type": "ParsedExpression*"
82:       }
83:     ],
84:     "pointer_type": "none",
85:     "constructor": ["type", "null_order", "expression"]
86:   },
87:   {
88:     "class": "BoundOrderByNode",
89:     "includes": [
90:       "duckdb/planner/bound_result_modifier.hpp"
91:     ],
92:     "members": [
93:       {
94:         "id": 100,
95:         "name": "type",
96:         "type": "OrderType"
97:       },
98:       {
99:         "id": 101,
100:         "name": "null_order",
101:         "type": "OrderByNullType"
102:       },
103:       {
104:         "id": 102,
105:         "name": "expression",
106:         "type": "Expression*"
107:       }
108:     ],
109:     "pointer_type": "none",
110:     "constructor": ["type", "null_order", "expression"]
111:   },
112:   {
113:     "class": "BoundLimitNode",
114:     "members": [
115:       {
116:         "id": 100,
117:         "name": "type",
118:         "type": "LimitNodeType"
119:       },
120:       {
121:         "id": 101,
122:         "name": "constant_integer",
123:         "type": "idx_t"
124:       },
125:       {
126:         "id": 102,
127:         "name": "constant_percentage",
128:         "type": "double"
129:       },
130:       {
131:         "id": 103,
132:         "name": "expression",
133:         "type": "Expression*"
134:       }
135:     ],
136:     "pointer_type": "none",
137:     "constructor": ["type", "constant_integer", "constant_percentage", "expression"]
138:   },
139:   {
140:     "class": "CaseCheck",
141:     "includes": [
142:       "duckdb/parser/expression/case_expression.hpp"
143:     ],
144:     "members": [
145:       {
146:         "id": 100,
147:         "name": "when_expr",
148:         "type": "ParsedExpression*"
149:       },
150:       {
151:         "id": 101,
152:         "name": "then_expr",
153:         "type": "ParsedExpression*"
154:       }
155:     ],
156:     "pointer_type": "none"
157:   },
158:   {
159:     "class": "BoundCaseCheck",
160:     "includes": [
161:       "duckdb/planner/expression/bound_case_expression.hpp"
162:     ],
163:     "members": [
164:       {
165:         "id": 100,
166:         "name": "when_expr",
167:         "type": "Expression*"
168:       },
169:       {
170:         "id": 101,
171:         "name": "then_expr",
172:         "type": "Expression*"
173:       }
174:     ],
175:     "pointer_type": "none"
176:   },
177:   {
178:     "class": "SampleOptions",
179:       "includes": [
180:       "duckdb/parser/parsed_data/sample_options.hpp"
181:     ],
182:       "members": [
183:       {
184:         "id": 100,
185:         "name": "sample_size",
186:         "type": "Value"
187:       },
188:       {
189:         "id": 101,
190:         "name": "is_percentage",
191:         "type": "bool"
192:       },
193:       {
194:         "id": 102,
195:         "name": "method",
196:         "type": "SampleMethod"
197:       },
198:       {
199:         "id": 103,
200:         "name": "seed",
201:         "type": "int64_t",
202:         "serialize_property": "GetSeed()"
203:       }
204:     ],
205:     "constructor": ["seed"]
206:   },
207:   {
208:     "class": "BaseReservoirSampling",
209:     "includes": [
210:       "duckdb/execution/reservoir_sample.hpp",
211:       "duckdb/common/queue.hpp"
212:     ],
213:     "members": [
214:       {
215:         "id": 100,
216:         "name": "next_index_to_sample",
217:         "type": "idx_t"
218:       },
219:       {
220:         "id": 101,
221:         "name": "min_weight_threshold",
222:         "type": "double"
223:       },
224:       {
225:         "id": 102,
226:         "name": "min_weighted_entry_index",
227:         "type": "idx_t"
228:       },
229:       {
230:         "id": 103,
231:         "name": "num_entries_to_skip_b4_next_sample",
232:         "type": "idx_t"
233:       },
234:       {
235:         "id": 104,
236:         "name": "num_entries_seen_total",
237:         "type": "idx_t"
238:       },
239:       {
240:         "id": 105,
241:         "name": "reservoir_weights",
242:         "type": "std::priority_queue<std::pair<double, idx_t>>"
243:       }
244:     ]
245:   },
246:   {
247:     "class": "BlockingSample",
248:     "class_type": "type",
249:     "members": [
250:       {
251:         "id" : 100,
252:         "name" : "base_reservoir_sample",
253:         "type" : "unique_ptr<BaseReservoirSampling>"
254:       },
255:       {
256:         "id" : 101,
257:         "name": "type",
258:         "type": "SampleType"
259:       },
260:       {
261:         "id": 102,
262:         "name": "destroyed",
263:         "type": "bool"
264:       }
265:     ]
266:   },
267:   {
268:     "class": "ReservoirSample",
269:     "base": "BlockingSample",
270:     "enum": "RESERVOIR_SAMPLE",
271:     "includes": [],
272:     "members": [
273:       {
274:         "id": 200,
275:         "name": "sample_count",
276:         "type": "idx_t"
277:       },
278:       {
279:         "id": 201,
280:         "name": "reservoir_chunk",
281:         "type": "unique_ptr<ReservoirChunk>"
282:       }
283:     ],
284:     "constructor": ["sample_count"]
285:   },
286:   {
287:     "class": "ReservoirSamplePercentage",
288:     "base": "BlockingSample",
289:     "enum": "RESERVOIR_PERCENTAGE_SAMPLE",
290:     "includes": [],
291:     "members": [
292:       {
293:         "id": 200,
294:         "name": "sample_percentage",
295:         "type": "double"
296:       },
297:       {
298:         "id": 201,
299:         "name": "reservoir_sample_size",
300:         "type": "idx_t"
301:       }
302:     ],
303:     "constructor": ["sample_percentage"]
304:   },
305:   {
306:     "class": "PivotColumn",
307:     "includes": [
308:       "duckdb/parser/tableref/pivotref.hpp"
309:     ],
310:     "members": [
311:       {
312:         "id": 100,
313:         "name": "pivot_expressions",
314:         "type": "vector<ParsedExpression*>"
315:       },
316:       {
317:         "id": 101,
318:         "name": "unpivot_names",
319:         "type": "vector<string>"
320:       },
321:       {
322:         "id": 102,
323:         "name": "entries",
324:         "type": "vector<PivotColumnEntry>"
325:       },
326:       {
327:         "id": 103,
328:         "name": "pivot_enum",
329:         "type": "string"
330:       }
331:     ],
332:     "pointer_type": "none"
333:   },
334: 
335:   {
336:     "class": "PivotColumnEntry",
337:     "members": [
338:       {
339:         "id": 100,
340:         "name": "values",
341:         "type": "vector<Value>"
342:       },
343:       {
344:         "id": 101,
345:         "name": "star_expr",
346:         "type": "ParsedExpression*",
347:         "property": "expr"
348:       },
349:       {
350:         "id": 102,
351:         "name": "alias",
352:         "type": "string"
353:       }
354:     ],
355:     "pointer_type": "none"
356:   },
357:   {
358:     "class": "BoundPivotInfo",
359:     "includes": [
360:       "duckdb/planner/tableref/bound_pivotref.hpp"
361:     ],
362:     "members": [
363:       {
364:         "id": 100,
365:         "name": "group_count",
366:         "type": "idx_t"
367:       },
368:       {
369:         "id": 101,
370:         "name": "types",
371:         "type": "vector<LogicalType>"
372:       },
373:       {
374:         "id": 102,
375:         "name": "pivot_values",
376:         "type": "vector<string>"
377:       },
378:       {
379:         "id": 103,
380:         "name": "aggregates",
381:         "type": "vector<Expression*>"
382:       }
383:     ],
384:     "pointer_type": "none"
385:   },
386:   {
387:     "class": "ColumnDefinition",
388:     "includes": [
389:       "duckdb/parser/column_definition.hpp"
390:     ],
391:     "members": [
392:       {
393:         "id": 100,
394:         "name": "name",
395:         "type": "string"
396:       },
397:       {
398:         "id": 101,
399:         "name": "type",
400:         "type": "LogicalType"
401:       },
402:       {
403:         "id": 102,
404:         "name": "expression",
405:         "type": "ParsedExpression*"
406:       },
407:       {
408:         "id": 103,
409:         "name": "category",
410:         "type": "TableColumnType"
411:       },
412:       {
413:         "id": 104,
414:         "name": "compression_type",
415:         "type": "duckdb::CompressionType"
416:       },
417:       {
418:         "id": 105,
419:         "name": "comment",
420:         "type": "Value",
421:         "default": "Value()"
422:       },
423:       {
424:         "id": 106,
425:         "name": "tags",
426:         "type": "unordered_map<string, string>",
427:         "default": "unordered_map<string, string>()"
428:       }
429:     ],
430:     "constructor": ["name", "type", "expression", "category"],
431:     "pointer_type": "none"
432:   },
433:   {
434:     "class": "ColumnList",
435:     "includes": [
436:       "duckdb/parser/column_list.hpp"
437:     ],
438:     "members": [
439:       {
440:         "id": 100,
441:         "name": "columns",
442:         "type": "vector<ColumnDefinition>"
443:       }
444:     ],
445:     "constructor": ["columns"],
446:     "pointer_type": "none"
447:   },
448:   {
449:     "class": "ColumnBinding",
450:     "includes": [
451:       "duckdb/planner/column_binding.hpp"
452:     ],
453:     "members": [
454:       {
455:         "id": 100,
456:         "name": "table_index",
457:         "type": "idx_t"
458:       },
459:       {
460:         "id": 101,
461:         "name": "column_index",
462:         "type": "idx_t"
463:       }
464:     ],
465:     "pointer_type": "none"
466:   },
467:   {
468:     "class": "BoundParameterData",
469:     "includes": [
470:       "duckdb/planner/expression/bound_parameter_data.hpp"
471:     ],
472:     "members": [
473:       {
474:         "id": 100,
475:         "name": "value",
476:         "type": "Value"
477:       },
478:       {
479:         "id": 101,
480:         "name": "return_type",
481:         "type": "LogicalType"
482:       }
483:     ],
484:     "constructor": ["value"],
485:     "pointer_type": "shared_ptr"
486:   },
487:   {
488:     "class": "JoinCondition",
489:     "includes": [
490:       "duckdb/planner/joinside.hpp"
491:     ],
492:     "members": [
493:       {
494:         "id": 100,
495:         "name": "left",
496:         "type": "Expression*"
497:       },
498:       {
499:         "id": 101,
500:         "name": "right",
501:         "type": "Expression*"
502:       },
503:       {
504:         "id": 102,
505:         "name": "comparison",
506:         "type": "ExpressionType"
507:       }
508:     ],
509:     "pointer_type": "none"
510:   },
511:   {
512:     "class": "VacuumOptions",
513:     "includes": [
514:       "duckdb/parser/parsed_data/vacuum_info.hpp"
515:     ],
516:     "members": [
517:       {
518:         "id": 100,
519:         "name": "vacuum",
520:         "type": "bool"
521:       },
522:       {
523:         "id": 101,
524:         "name": "analyze",
525:         "type": "bool"
526:       }
527:     ],
528:     "pointer_type": "none"
529:   },
530:   {
531:     "class": "TableFilterSet",
532:     "includes": [
533:       "duckdb/planner/table_filter.hpp"
534:     ],
535:     "members": [
536:       {
537:         "id": 100,
538:         "name": "filters",
539:         "type": "unordered_map<idx_t, TableFilter*>"
540:       }
541:     ],
542:     "pointer_type": "none"
543:   },
544:   {
545:     "class": "MultiFileReaderOptions",
546:     "includes": [
547:       "duckdb/common/multi_file_reader_options.hpp"
548:     ],
549:     "members": [
550:       {
551:         "id": 100,
552:         "name": "filename",
553:         "type": "bool"
554:       },
555:       {
556:         "id": 101,
557:         "name": "hive_partitioning",
558:         "type": "bool"
559:       },
560:       {
561:         "id": 102,
562:         "name": "auto_detect_hive_partitioning",
563:         "type": "bool"
564:       },
565:       {
566:         "id": 103,
567:         "name": "union_by_name",
568:         "type": "bool"
569:       },
570:       {
571:         "id": 104,
572:         "name": "hive_types_autocast",
573:         "type": "bool"
574:       },
575:       {
576:         "id": 105,
577:         "name": "hive_types_schema",
578:         "type": "case_insensitive_map_t<LogicalType>"
579:       },
580:       {
581:         "id": 106,
582:         "name": "filename_column",
583:         "type": "string",
584:         "default": "MultiFileReaderOptions::DEFAULT_FILENAME_COLUMN"
585:       }
586:     ],
587:     "pointer_type": "none"
588:   },
589:   {
590:     "class": "MultiFileReaderBindData",
591:     "includes": [
592:       "duckdb/common/multi_file_reader.hpp"
593:     ],
594:     "members": [
595:       {
596:         "id": 100,
597:         "name": "filename_idx",
598:         "type": "idx_t"
599:       },
600:       {
601:         "id": 101,
602:         "name": "hive_partitioning_indexes",
603:         "type": "vector<HivePartitioningIndex>"
604:       }
605:     ],
606:     "pointer_type": "none"
607:   },
608:   {
609:     "class": "HivePartitioningIndex",
610:     "members": [
611:       {
612:         "id": 100,
613:         "name": "value",
614:         "type": "string"
615:       },
616:       {
617:         "id": 101,
618:         "name": "index",
619:         "type": "idx_t"
620:       }
621:     ],
622:     "pointer_type": "none",
623:     "constructor": ["value", "index"]
624:   },
625:   {
626:     "class": "CSVOption<T>",
627:     "includes": [
628:       "duckdb/execution/operator/csv_scanner/csv_option.hpp"
629:     ],
630:     "members": [
631:       {
632:         "id": 100,
633:         "name": "set_by_user",
634:         "type": "bool"
635:       },
636:       {
637:         "id": 101,
638:         "name": "value",
639:         "type": "T"
640:       }
641:     ],
642:     "pointer_type": "none"
643:   },
644:   {
645:     "class": "CSVReaderOptions",
646:     "includes": [
647:       "duckdb/execution/operator/csv_scanner/csv_reader_options.hpp"
648:     ],
649:     "members": [
650:       {"id": 100,
651:         "name": "ignore_errors",
652:         "type": "bool",
653:         "default": "false"
654:       },
655:       {"id": 101,
656:         "name": "buffer_sample_size",
657:         "type": "idx_t"
658:       },
659:       {"id": 102,
660:         "name": "null_str",
661:         "type": "vector<string>"
662:       },
663:       {"id": 103,
664:         "name": "compression",
665:         "type": "FileCompressionType"
666:       },
667:       {"id": 104,
668:         "name": "allow_quoted_nulls",
669:         "type": "bool"
670:       },
671:       {"id": 105,
672:         "name": "maximum_line_size",
673:         "type": "idx_t"
674:       },
675:       {"id": 106,
676:         "name": "normalize_names",
677:         "type": "bool"
678:       },
679:       {"id": 107,
680:         "name": "force_not_null",
681:         "type": "vector<bool>"
682:       },
683:       {"id": 108,
684:         "name": "all_varchar",
685:         "type": "bool"
686:       },
687:       {"id": 109,
688:         "name": "sample_size_chunks",
689:         "type": "idx_t"
690:       },
691:       {"id": 110,
692:         "name": "auto_detect",
693:         "type": "bool"
694:       },
695:       {"id": 111,
696:         "name": "file_path",
697:         "type": "string"
698:       },
699:       {"id": 112,
700:         "name": "decimal_separator",
701:         "type": "string"
702:       },
703:       {"id": 113,
704:         "name": "null_padding",
705:         "type": "bool"
706:       },
707:       {"id": 114,
708:         "name": "buffer_size",
709:         "type": "idx_t"
710:       },
711:       {"id": 115,
712:         "name": "file_options",
713:         "type": "MultiFileReaderOptions"
714:       },
715:       {"id": 116,
716:         "name": "force_quote",
717:         "type": "vector<bool>"
718:       },
719:       {"id": 117,
720:         "name": "rejects_table_name",
721:         "type": "string",
722:         "default": "\"reject_errors\""
723:       },
724:       {"id": 118,
725:         "name": "rejects_limit",
726:         "type": "idx_t"
727:       },
728:       {"id": 119,
729:         "name": "rejects_recovery_columns",
730:         "type": "vector<string>",
731:         "deleted": true
732:       },
733:       {"id": 120,
734:         "name": "rejects_recovery_column_ids",
735:         "type": "vector<idx_t>",
736:         "deleted": true
737:       },
738:       {"id": 121,
739:         "name": "delimiter",
740:         "property": "dialect_options.state_machine_options.delimiter",
741:         "type": "CSVOption<char>",
742:         "serialize_property": "GetSingleByteDelimiter()"
743:       },
744:       {"id": 122,
745:         "name": "quote",
746:         "property": "dialect_options.state_machine_options.quote",
747:         "type": "CSVOption<char>"
748:       },
749:       {"id": 123,
750:         "name": "escape",
751:         "property": "dialect_options.state_machine_options.escape",
752:         "type": "CSVOption<char>"
753:       },
754:       {"id": 124,
755:         "name": "header",
756:         "property": "dialect_options.header",
757:         "type": "CSVOption<bool>"
758:       },
759:       {"id": 125,
760:         "name": "num_cols",
761:         "property": "dialect_options.num_cols",
762:         "type": "idx_t"
763:       },
764:       {"id": 126,
765:         "name": "new_line",
766:         "property": "dialect_options.state_machine_options.new_line",
767:         "type": "CSVOption<NewLineIdentifier>"
768:       },
769:       {"id": 127,
770:         "name": "skip_rows",
771:         "property": "dialect_options.skip_rows",
772:         "type": "CSVOption<idx_t>"
773:       },
774:       {"id": 128,
775:         "name": "date_format",
776:         "property": "dialect_options.date_format",
777:         "type": "map<LogicalTypeId, CSVOption<StrpTimeFormat>>"
778:       },
779:       {"id": 129,
780:         "name": "sniffer_user_mismatch_error",
781:         "type": "string"
782:       },
783:       {"id": 130,
784:         "name": "parallel",
785:         "type": "bool"
786:       },
787:       {"id": 131,
788:         "name": "was_type_manually_set",
789:         "type": "vector<bool>"
790:       },
791:       {"id": 132,
792:         "name": "rejects_scan_name",
793:         "type": "CSVOption<string>",
794:         "default": "{\"reject_scans\"}"
795:       },
796:       {"id": 133,
797:         "name": "name_list",
798:         "type": "vector<string>"
799:       },
800:       {"id": 134,
801:         "name": "sql_type_list",
802:         "type": "vector<LogicalType>"
803:       },
804:       {"id": 135,
805:         "name": "sql_types_per_column",
806:         "type": "case_insensitive_map_t<idx_t>"
807:       },
808:       {"id": 136,
809:         "name": "columns_set",
810:         "type": "bool",
811:         "default": "false"
812:       },
813:       {"id": 137,
814:         "name": "comment",
815:         "property": "dialect_options.state_machine_options.comment",
816:         "type": "CSVOption<char>",
817:         "default": "CSVOption<char>('\\0')"
818:       },
819:       {"id": 138,
820:         "name": "rows_until_header",
821:         "property": "dialect_options.rows_until_header",
822:         "type": "idx_t"
823:       },
824:       {"id": 139,
825:         "name": "encoding",
826:         "type": "string"
827:       },
828:       {"id": 140,
829:         "name": "rfc_4180",
830:         "property": "dialect_options.state_machine_options.rfc_4180",
831:         "type": "CSVOption<bool>"
832:       },
833:       {"id": 141,
834:         "name": "multi_byte_delimiter",
835:         "type": "CSVOption<string>",
836:         "serialize_property": "GetMultiByteDelimiter()"
837:       }
838:     ],
839:     "constructor": ["delimiter", "multi_byte_delimiter"],
840:     "pointer_type": "none"
841:   },
842:   {
843:     "class": "StrpTimeFormat",
844:     "includes": [
845:       "duckdb/function/scalar/strftime_format.hpp"
846:     ],
847:     "members": [
848:       {
849:         "id": 100,
850:         "name": "format_specifier",
851:         "type": "string"
852:       }
853:     ],
854:     "constructor": ["format_specifier&"],
855:     "pointer_type": "none"
856:   },
857:   {
858:     "class": "ReadCSVData",
859:     "includes": [
860:       "duckdb/function/table/read_csv.hpp"
861:     ],
862:     "members": [
863:       {
864:         "id": 100,
865:         "name": "files",
866:         "type": "vector<string>"
867:       },
868:       {
869:         "id": 101,
870:         "name": "csv_types",
871:         "type": "vector<LogicalType>"
872:       },
873:       {
874:         "id": 102,
875:         "name": "csv_names",
876:         "type": "vector<string>"
877:       },
878:       {
879:         "id": 103,
880:         "name": "return_types",
881:         "type": "vector<LogicalType>"
882:       },
883:       {
884:         "id": 104,
885:         "name": "return_names",
886:         "type": "vector<string>"
887:       },
888:       {
889:         "id": 105,
890:         "name": "filename_col_idx",
891:         "type": "idx_t"
892:       },
893:       {
894:         "id": 106,
895:         "name": "options",
896:         "type": "CSVReaderOptions"
897:       },
898:       {
899:         "id": 107,
900:         "name": "reader_bind",
901:         "type": "MultiFileReaderBindData"
902:       },
903:       {
904:         "id": 108,
905:         "name": "column_info",
906:         "type": "vector<ColumnInfo>"
907:       }
908:     ]
909:   },
910:   {
911:     "class": "ColumnInfo",
912:     "members": [
913:       {
914:         "id": 100,
915:         "name": "names",
916:         "type": "vector<string>"
917:       },
918:       {
919:         "id": 101,
920:         "name": "types",
921:         "type": "vector<LogicalType>"
922:       }
923:     ],
924:     "pointer_type": "none"
925:   },
926:   {
927:     "class": "interval_t",
928:     "includes": [
929:       "duckdb/common/types/interval.hpp"
930:     ],
931:     "members": [
932:       {
933:         "id": 1,
934:         "name": "months",
935:         "type": "int32_t"
936:       },
937:       {
938:         "id": 2,
939:         "name": "days",
940:         "type": "int32_t"
941:       },
942:       {
943:         "id": 3,
944:         "name": "micros",
945:         "type": "int64_t"
946:       }
947:     ],
948:     "pointer_type": "none"
949:   },
950:   {
951:     "class": "QualifiedColumnName",
952:     "includes": [
953:       "duckdb/parser/qualified_name.hpp"
954:     ],
955:     "members": [
956:       {
957:         "id": 100,
958:         "name": "catalog",
959:         "type": "string"
960:       },
961:       {
962:         "id": 101,
963:         "name": "schema",
964:         "type": "string"
965:       },
966:       {
967:         "id": 102,
968:         "name": "table",
969:         "type": "string"
970:       },
971:       {
972:         "id": 103,
973:         "name": "column",
974:         "type": "string"
975:       }
976:     ],
977:     "pointer_type": "none"
978:   },
979:   {
980:     "class": "ExportedTableInfo",
981:     "includes": [
982:       "duckdb/parser/parsed_data/exported_table_data.hpp"
983:     ],
984:     "members": [
985:       {
986:         "id": 1,
987:         "name": "table_data",
988:         "type": "ExportedTableData"
989:       }
990:     ],
991:     "constructor": ["$ClientContext", "table_data"],
992:     "pointer_type": "none"
993:   },
994:   {
995:     "class": "ExportedTableData",
996:     "includes": [
997:       "duckdb/parser/parsed_data/exported_table_data.hpp"
998:     ],
999:     "members": [
1000:       {
1001:         "id": 1,
1002:         "name": "table_name",
1003:         "type": "string"
1004:       },
1005:       {
1006:         "id": 2,
1007:         "name": "schema_name",
1008:         "type": "string"
1009:       },
1010:       {
1011:         "id": 3,
1012:         "name": "database_name",
1013:         "type": "string"
1014:       },
1015:       {
1016:         "id": 4,
1017:         "name": "file_path",
1018:         "type": "string"
1019:       },
1020:       {
1021:         "id": 5,
1022:         "name": "not_null_columns",
1023:         "type": "vector<string>"
1024:       }
1025:     ],
1026:     "pointer_type": "none"
1027:   },
1028:   {
1029:     "class": "ColumnIndex",
1030:     "includes": [
1031:       "duckdb/common/column_index.hpp"
1032:     ],
1033:     "members": [
1034:       {
1035:         "id": 1,
1036:         "name": "index",
1037:         "type": "idx_t"
1038:       },
1039:       {
1040:         "id": 2,
1041:         "name": "child_indexes",
1042:         "type": "vector<ColumnIndex>"
1043:       }
1044:     ],
1045:     "pointer_type": "none"
1046:   }
1047: ]
[end of src/include/duckdb/storage/serialization/nodes.json]
[start of src/include/duckdb/storage/table/row_group_collection.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/storage/table/row_group_collection.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/storage/table/row_group.hpp"
12: #include "duckdb/storage/table/segment_tree.hpp"
13: #include "duckdb/storage/statistics/column_statistics.hpp"
14: #include "duckdb/storage/table/table_statistics.hpp"
15: #include "duckdb/storage/storage_index.hpp"
16: 
17: namespace duckdb {
18: 
19: struct ParallelTableScanState;
20: struct ParallelCollectionScanState;
21: class CreateIndexScanState;
22: class CollectionScanState;
23: class PersistentTableData;
24: class TableDataWriter;
25: class TableIndexList;
26: class TableStatistics;
27: struct TableAppendState;
28: class DuckTransaction;
29: class BoundConstraint;
30: class RowGroupSegmentTree;
31: class StorageCommitState;
32: struct ColumnSegmentInfo;
33: class MetadataManager;
34: struct VacuumState;
35: struct CollectionCheckpointState;
36: struct PersistentCollectionData;
37: class CheckpointTask;
38: class TableIOManager;
39: 
40: class RowGroupCollection {
41: public:
42: 	RowGroupCollection(shared_ptr<DataTableInfo> info, TableIOManager &io_manager, vector<LogicalType> types,
43: 	                   idx_t row_start, idx_t total_rows = 0);
44: 	RowGroupCollection(shared_ptr<DataTableInfo> info, BlockManager &block_manager, vector<LogicalType> types,
45: 	                   idx_t row_start, idx_t total_rows, idx_t row_group_size);
46: 
47: public:
48: 	idx_t GetTotalRows() const;
49: 	Allocator &GetAllocator() const;
50: 
51: 	void Initialize(PersistentCollectionData &data);
52: 	void Initialize(PersistentTableData &data);
53: 	void InitializeEmpty();
54: 
55: 	bool IsEmpty() const;
56: 
57: 	void AppendRowGroup(SegmentLock &l, idx_t start_row);
58: 	//! Get the nth row-group, negative numbers start from the back (so -1 is the last row group, etc)
59: 	RowGroup *GetRowGroup(int64_t index);
60: 	void Verify();
61: 
62: 	void InitializeScan(CollectionScanState &state, const vector<StorageIndex> &column_ids,
63: 	                    TableFilterSet *table_filters);
64: 	void InitializeCreateIndexScan(CreateIndexScanState &state);
65: 	void InitializeScanWithOffset(CollectionScanState &state, const vector<StorageIndex> &column_ids, idx_t start_row,
66: 	                              idx_t end_row);
67: 	static bool InitializeScanInRowGroup(CollectionScanState &state, RowGroupCollection &collection,
68: 	                                     RowGroup &row_group, idx_t vector_index, idx_t max_row);
69: 	void InitializeParallelScan(ParallelCollectionScanState &state);
70: 	bool NextParallelScan(ClientContext &context, ParallelCollectionScanState &state, CollectionScanState &scan_state);
71: 
72: 	bool Scan(DuckTransaction &transaction, const vector<StorageIndex> &column_ids,
73: 	          const std::function<bool(DataChunk &chunk)> &fun);
74: 	bool Scan(DuckTransaction &transaction, const std::function<bool(DataChunk &chunk)> &fun);
75: 
76: 	void Fetch(TransactionData transaction, DataChunk &result, const vector<StorageIndex> &column_ids,
77: 	           const Vector &row_identifiers, idx_t fetch_count, ColumnFetchState &state);
78: 
79: 	//! Initialize an append of a variable number of rows. FinalizeAppend must be called after appending is done.
80: 	void InitializeAppend(TableAppendState &state);
81: 	//! Initialize an append with a variable number of rows. FinalizeAppend should not be called after appending is
82: 	//! done.
83: 	void InitializeAppend(TransactionData transaction, TableAppendState &state);
84: 	//! Appends to the row group collection. Returns true if a new row group has been created to append to
85: 	bool Append(DataChunk &chunk, TableAppendState &state);
86: 	//! FinalizeAppend flushes an append with a variable number of rows.
87: 	void FinalizeAppend(TransactionData transaction, TableAppendState &state);
88: 	void CommitAppend(transaction_t commit_id, idx_t row_start, idx_t count);
89: 	void RevertAppendInternal(idx_t start_row);
90: 	void CleanupAppend(transaction_t lowest_transaction, idx_t start, idx_t count);
91: 
92: 	void MergeStorage(RowGroupCollection &data, optional_ptr<DataTable> table,
93: 	                  optional_ptr<StorageCommitState> commit_state);
94: 	bool IsPersistent() const;
95: 
96: 	void RemoveFromIndexes(TableIndexList &indexes, Vector &row_identifiers, idx_t count);
97: 
98: 	idx_t Delete(TransactionData transaction, DataTable &table, row_t *ids, idx_t count);
99: 	void Update(TransactionData transaction, row_t *ids, const vector<PhysicalIndex> &column_ids, DataChunk &updates);
100: 	void UpdateColumn(TransactionData transaction, Vector &row_ids, const vector<column_t> &column_path,
101: 	                  DataChunk &updates);
102: 
103: 	void Checkpoint(TableDataWriter &writer, TableStatistics &global_stats);
104: 
105: 	void InitializeVacuumState(CollectionCheckpointState &checkpoint_state, VacuumState &state,
106: 	                           vector<SegmentNode<RowGroup>> &segments);
107: 	bool ScheduleVacuumTasks(CollectionCheckpointState &checkpoint_state, VacuumState &state, idx_t segment_idx,
108: 	                         bool schedule_vacuum);
109: 	unique_ptr<CheckpointTask> GetCheckpointTask(CollectionCheckpointState &checkpoint_state, idx_t segment_idx);
110: 
111: 	void CommitDropColumn(idx_t index);
112: 	void CommitDropTable();
113: 
114: 	vector<PartitionStatistics> GetPartitionStats() const;
115: 	vector<ColumnSegmentInfo> GetColumnSegmentInfo();
116: 	const vector<LogicalType> &GetTypes() const;
117: 
118: 	shared_ptr<RowGroupCollection> AddColumn(ClientContext &context, ColumnDefinition &new_column,
119: 	                                         ExpressionExecutor &default_executor);
120: 	shared_ptr<RowGroupCollection> RemoveColumn(idx_t col_idx);
121: 	shared_ptr<RowGroupCollection> AlterType(ClientContext &context, idx_t changed_idx, const LogicalType &target_type,
122: 	                                         vector<StorageIndex> bound_columns, Expression &cast_expr);
123: 	void VerifyNewConstraint(DataTable &parent, const BoundConstraint &constraint);
124: 
125: 	void CopyStats(TableStatistics &stats);
126: 	unique_ptr<BaseStatistics> CopyStats(column_t column_id);
127: 	void SetDistinct(column_t column_id, unique_ptr<DistinctStatistics> distinct_stats);
128: 
129: 	AttachedDatabase &GetAttached();
130: 	BlockManager &GetBlockManager() {
131: 		return block_manager;
132: 	}
133: 	MetadataManager &GetMetadataManager();
134: 	DataTableInfo &GetTableInfo() {
135: 		return *info;
136: 	}
137: 
138: 	idx_t GetAllocationSize() const {
139: 		return allocation_size;
140: 	}
141: 
142: 	idx_t GetRowGroupSize() const {
143: 		return row_group_size;
144: 	}
145: 
146: private:
147: 	bool IsEmpty(SegmentLock &) const;
148: 
149: private:
150: 	//! BlockManager
151: 	BlockManager &block_manager;
152: 	//! The row group size of the row group collection
153: 	const idx_t row_group_size;
154: 	//! The number of rows in the table
155: 	atomic<idx_t> total_rows;
156: 	//! The data table info
157: 	shared_ptr<DataTableInfo> info;
158: 	//! The column types of the row group collection
159: 	vector<LogicalType> types;
160: 	idx_t row_start;
161: 	//! The segment trees holding the various row_groups of the table
162: 	shared_ptr<RowGroupSegmentTree> row_groups;
163: 	//! Table statistics
164: 	TableStatistics stats;
165: 	//! Allocation size, only tracked for appends
166: 	idx_t allocation_size;
167: };
168: 
169: } // namespace duckdb
[end of src/include/duckdb/storage/table/row_group_collection.hpp]
[start of src/include/duckdb/storage/table/table_statistics.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/storage/table/table_statistics.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types/data_chunk.hpp"
13: #include "duckdb/execution/reservoir_sample.hpp"
14: #include "duckdb/common/mutex.hpp"
15: #include "duckdb/storage/statistics/column_statistics.hpp"
16: 
17: namespace duckdb {
18: class ColumnList;
19: class PersistentTableData;
20: class Serializer;
21: class Deserializer;
22: 
23: class TableStatisticsLock {
24: public:
25: 	explicit TableStatisticsLock(mutex &l) : guard(l) {
26: 	}
27: 
28: 	lock_guard<mutex> guard;
29: };
30: 
31: class TableStatistics {
32: public:
33: 	void Initialize(const vector<LogicalType> &types, PersistentTableData &data);
34: 	void InitializeEmpty(const vector<LogicalType> &types);
35: 
36: 	void InitializeAddColumn(TableStatistics &parent, const LogicalType &new_column_type);
37: 	void InitializeRemoveColumn(TableStatistics &parent, idx_t removed_column);
38: 	void InitializeAlterType(TableStatistics &parent, idx_t changed_idx, const LogicalType &new_type);
39: 	void InitializeAddConstraint(TableStatistics &parent);
40: 
41: 	void MergeStats(TableStatistics &other);
42: 	void MergeStats(idx_t i, BaseStatistics &stats);
43: 	void MergeStats(TableStatisticsLock &lock, idx_t i, BaseStatistics &stats);
44: 
45: 	void CopyStats(TableStatistics &other);
46: 	void CopyStats(TableStatisticsLock &lock, TableStatistics &other);
47: 	unique_ptr<BaseStatistics> CopyStats(idx_t i);
48: 	//! Get a reference to the stats - this requires us to hold the lock.
49: 	//! The reference can only be safely accessed while the lock is held
50: 	ColumnStatistics &GetStats(TableStatisticsLock &lock, idx_t i);
51: 
52: 	bool Empty();
53: 
54: 	unique_ptr<TableStatisticsLock> GetLock();
55: 
56: 	void Serialize(Serializer &serializer) const;
57: 	void Deserialize(Deserializer &deserializer, ColumnList &columns);
58: 
59: private:
60: 	//! The statistics lock
61: 	shared_ptr<mutex> stats_lock;
62: 	//! Column statistics
63: 	vector<shared_ptr<ColumnStatistics>> column_stats;
64: 	//! The table sample
65: 	//! Sample for table
66: 	unique_ptr<BlockingSample> table_sample;
67: };
68: 
69: } // namespace duckdb
[end of src/include/duckdb/storage/table/table_statistics.hpp]
[start of src/storage/data_table.cpp]
1: #include "duckdb/storage/data_table.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
4: #include "duckdb/common/chrono.hpp"
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/common/exception/transaction_exception.hpp"
7: #include "duckdb/common/helper.hpp"
8: #include "duckdb/common/types/conflict_manager.hpp"
9: #include "duckdb/common/types/constraint_conflict_info.hpp"
10: #include "duckdb/common/vector_operations/vector_operations.hpp"
11: #include "duckdb/execution/expression_executor.hpp"
12: #include "duckdb/main/attached_database.hpp"
13: #include "duckdb/main/client_context.hpp"
14: #include "duckdb/parser/constraints/list.hpp"
15: #include "duckdb/planner/constraints/list.hpp"
16: #include "duckdb/planner/expression/bound_constant_expression.hpp"
17: #include "duckdb/planner/expression/bound_reference_expression.hpp"
18: #include "duckdb/planner/expression_binder/check_binder.hpp"
19: #include "duckdb/planner/expression_binder/constant_binder.hpp"
20: #include "duckdb/planner/table_filter.hpp"
21: #include "duckdb/storage/checkpoint/table_data_writer.hpp"
22: #include "duckdb/storage/storage_manager.hpp"
23: #include "duckdb/storage/table/append_state.hpp"
24: #include "duckdb/storage/table/delete_state.hpp"
25: #include "duckdb/storage/table/persistent_table_data.hpp"
26: #include "duckdb/storage/table/row_group.hpp"
27: #include "duckdb/storage/table/scan_state.hpp"
28: #include "duckdb/storage/table/standard_column_data.hpp"
29: #include "duckdb/storage/table/update_state.hpp"
30: #include "duckdb/storage/table_storage_info.hpp"
31: #include "duckdb/transaction/duck_transaction.hpp"
32: 
33: namespace duckdb {
34: 
35: DataTableInfo::DataTableInfo(AttachedDatabase &db, shared_ptr<TableIOManager> table_io_manager_p, string schema,
36:                              string table)
37:     : db(db), table_io_manager(std::move(table_io_manager_p)), schema(std::move(schema)), table(std::move(table)) {
38: }
39: 
40: void DataTableInfo::InitializeIndexes(ClientContext &context, const char *index_type) {
41: 	indexes.InitializeIndexes(context, *this, index_type);
42: }
43: 
44: bool DataTableInfo::IsTemporary() const {
45: 	return db.IsTemporary();
46: }
47: 
48: DataTable::DataTable(AttachedDatabase &db, shared_ptr<TableIOManager> table_io_manager_p, const string &schema,
49:                      const string &table, vector<ColumnDefinition> column_definitions_p,
50:                      unique_ptr<PersistentTableData> data)
51:     : db(db), info(make_shared_ptr<DataTableInfo>(db, std::move(table_io_manager_p), schema, table)),
52:       column_definitions(std::move(column_definitions_p)), is_root(true) {
53: 	// initialize the table with the existing data from disk, if any
54: 	auto types = GetTypes();
55: 	auto &io_manager = TableIOManager::Get(*this);
56: 	this->row_groups = make_shared_ptr<RowGroupCollection>(info, io_manager, types, 0);
57: 	if (data && data->row_group_count > 0) {
58: 		this->row_groups->Initialize(*data);
59: 	} else {
60: 		this->row_groups->InitializeEmpty();
61: 		D_ASSERT(row_groups->GetTotalRows() == 0);
62: 	}
63: 	row_groups->Verify();
64: }
65: 
66: DataTable::DataTable(ClientContext &context, DataTable &parent, ColumnDefinition &new_column, Expression &default_value)
67:     : db(parent.db), info(parent.info), is_root(true) {
68: 	// add the column definitions from this DataTable
69: 	for (auto &column_def : parent.column_definitions) {
70: 		column_definitions.emplace_back(column_def.Copy());
71: 	}
72: 	column_definitions.emplace_back(new_column.Copy());
73: 
74: 	auto &local_storage = LocalStorage::Get(context, db);
75: 
76: 	ExpressionExecutor default_executor(context);
77: 	default_executor.AddExpression(default_value);
78: 
79: 	// prevent any new tuples from being added to the parent
80: 	lock_guard<mutex> parent_lock(parent.append_lock);
81: 
82: 	this->row_groups = parent.row_groups->AddColumn(context, new_column, default_executor);
83: 
84: 	// also add this column to client local storage
85: 	local_storage.AddColumn(parent, *this, new_column, default_executor);
86: 
87: 	// this table replaces the previous table, hence the parent is no longer the root DataTable
88: 	parent.is_root = false;
89: }
90: 
91: DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t removed_column)
92:     : db(parent.db), info(parent.info), is_root(true) {
93: 	// prevent any new tuples from being added to the parent
94: 	auto &local_storage = LocalStorage::Get(context, db);
95: 	lock_guard<mutex> parent_lock(parent.append_lock);
96: 
97: 	for (auto &column_def : parent.column_definitions) {
98: 		column_definitions.emplace_back(column_def.Copy());
99: 	}
100: 
101: 	info->InitializeIndexes(context);
102: 
103: 	// first check if there are any indexes that exist that point to the removed column
104: 	info->indexes.Scan([&](Index &index) {
105: 		for (auto &column_id : index.GetColumnIds()) {
106: 			if (column_id == removed_column) {
107: 				throw CatalogException("Cannot drop this column: an index depends on it!");
108: 			} else if (column_id > removed_column) {
109: 				throw CatalogException("Cannot drop this column: an index depends on a column after it!");
110: 			}
111: 		}
112: 		return false;
113: 	});
114: 
115: 	// erase the column definitions from this DataTable
116: 	D_ASSERT(removed_column < column_definitions.size());
117: 	column_definitions.erase_at(removed_column);
118: 
119: 	storage_t storage_idx = 0;
120: 	for (idx_t i = 0; i < column_definitions.size(); i++) {
121: 		auto &col = column_definitions[i];
122: 		col.SetOid(i);
123: 		if (col.Generated()) {
124: 			continue;
125: 		}
126: 		col.SetStorageOid(storage_idx++);
127: 	}
128: 
129: 	// alter the row_groups and remove the column from each of them
130: 	this->row_groups = parent.row_groups->RemoveColumn(removed_column);
131: 
132: 	// scan the original table, and fill the new column with the transformed value
133: 	local_storage.DropColumn(parent, *this, removed_column);
134: 
135: 	// this table replaces the previous table, hence the parent is no longer the root DataTable
136: 	parent.is_root = false;
137: }
138: 
139: DataTable::DataTable(ClientContext &context, DataTable &parent, BoundConstraint &constraint)
140:     : db(parent.db), info(parent.info), row_groups(parent.row_groups), is_root(true) {
141: 
142: 	// ALTER COLUMN to add a new constraint.
143: 
144: 	// Clone the storage info vector or the table.
145: 	for (const auto &index_info : parent.info->index_storage_infos) {
146: 		info->index_storage_infos.push_back(IndexStorageInfo(index_info.name));
147: 	}
148: 	info->InitializeIndexes(context);
149: 
150: 	auto &local_storage = LocalStorage::Get(context, db);
151: 	lock_guard<mutex> parent_lock(parent.append_lock);
152: 	for (auto &column_def : parent.column_definitions) {
153: 		column_definitions.emplace_back(column_def.Copy());
154: 	}
155: 
156: 	if (constraint.type != ConstraintType::UNIQUE) {
157: 		VerifyNewConstraint(local_storage, parent, constraint);
158: 	}
159: 	local_storage.MoveStorage(parent, *this);
160: 	parent.is_root = false;
161: }
162: 
163: DataTable::DataTable(ClientContext &context, DataTable &parent, idx_t changed_idx, const LogicalType &target_type,
164:                      const vector<StorageIndex> &bound_columns, Expression &cast_expr)
165:     : db(parent.db), info(parent.info), is_root(true) {
166: 	auto &local_storage = LocalStorage::Get(context, db);
167: 	// prevent any tuples from being added to the parent
168: 	lock_guard<mutex> lock(append_lock);
169: 	for (auto &column_def : parent.column_definitions) {
170: 		column_definitions.emplace_back(column_def.Copy());
171: 	}
172: 
173: 	info->InitializeIndexes(context);
174: 
175: 	// first check if there are any indexes that exist that point to the changed column
176: 	info->indexes.Scan([&](Index &index) {
177: 		for (auto &column_id : index.GetColumnIds()) {
178: 			if (column_id == changed_idx) {
179: 				throw CatalogException("Cannot change the type of this column: an index depends on it!");
180: 			}
181: 		}
182: 		return false;
183: 	});
184: 
185: 	// change the type in this DataTable
186: 	column_definitions[changed_idx].SetType(target_type);
187: 
188: 	// set up the statistics for the table
189: 	// the column that had its type changed will have the new statistics computed during conversion
190: 	this->row_groups = parent.row_groups->AlterType(context, changed_idx, target_type, bound_columns, cast_expr);
191: 
192: 	// scan the original table, and fill the new column with the transformed value
193: 	local_storage.ChangeType(parent, *this, changed_idx, target_type, bound_columns, cast_expr);
194: 
195: 	// this table replaces the previous table, hence the parent is no longer the root DataTable
196: 	parent.is_root = false;
197: }
198: 
199: vector<LogicalType> DataTable::GetTypes() {
200: 	vector<LogicalType> types;
201: 	for (auto &it : column_definitions) {
202: 		types.push_back(it.Type());
203: 	}
204: 	return types;
205: }
206: 
207: bool DataTable::IsTemporary() const {
208: 	return info->IsTemporary();
209: }
210: 
211: AttachedDatabase &DataTable::GetAttached() {
212: 	D_ASSERT(RefersToSameObject(db, info->db));
213: 	return db;
214: }
215: 
216: const vector<ColumnDefinition> &DataTable::Columns() const {
217: 	return column_definitions;
218: }
219: 
220: TableIOManager &DataTable::GetTableIOManager() {
221: 	return *info->table_io_manager;
222: }
223: 
224: TableIOManager &TableIOManager::Get(DataTable &table) {
225: 	return table.GetTableIOManager();
226: }
227: 
228: //===--------------------------------------------------------------------===//
229: // Scan
230: //===--------------------------------------------------------------------===//
231: void DataTable::InitializeScan(DuckTransaction &transaction, TableScanState &state,
232:                                const vector<StorageIndex> &column_ids, TableFilterSet *table_filters) {
233: 	state.checkpoint_lock = transaction.SharedLockTable(*info);
234: 	auto &local_storage = LocalStorage::Get(transaction);
235: 	state.Initialize(column_ids, table_filters);
236: 	row_groups->InitializeScan(state.table_state, column_ids, table_filters);
237: 	local_storage.InitializeScan(*this, state.local_state, table_filters);
238: }
239: 
240: void DataTable::InitializeScanWithOffset(DuckTransaction &transaction, TableScanState &state,
241:                                          const vector<StorageIndex> &column_ids, idx_t start_row, idx_t end_row) {
242: 	state.checkpoint_lock = transaction.SharedLockTable(*info);
243: 	state.Initialize(column_ids);
244: 	row_groups->InitializeScanWithOffset(state.table_state, column_ids, start_row, end_row);
245: }
246: 
247: idx_t DataTable::GetRowGroupSize() const {
248: 	return row_groups->GetRowGroupSize();
249: }
250: 
251: vector<PartitionStatistics> DataTable::GetPartitionStats(ClientContext &context) {
252: 	auto result = row_groups->GetPartitionStats();
253: 	auto &local_storage = LocalStorage::Get(context, db);
254: 	auto local_partitions = local_storage.GetPartitionStats(*this);
255: 	result.insert(result.end(), local_partitions.begin(), local_partitions.end());
256: 	return result;
257: }
258: 
259: idx_t DataTable::MaxThreads(ClientContext &context) const {
260: 	idx_t row_group_size = GetRowGroupSize();
261: 	idx_t parallel_scan_vector_count = row_group_size / STANDARD_VECTOR_SIZE;
262: 	if (ClientConfig::GetConfig(context).verify_parallelism) {
263: 		parallel_scan_vector_count = 1;
264: 	}
265: 	idx_t parallel_scan_tuple_count = STANDARD_VECTOR_SIZE * parallel_scan_vector_count;
266: 	return GetTotalRows() / parallel_scan_tuple_count + 1;
267: }
268: 
269: void DataTable::InitializeParallelScan(ClientContext &context, ParallelTableScanState &state) {
270: 	auto &local_storage = LocalStorage::Get(context, db);
271: 	auto &transaction = DuckTransaction::Get(context, db);
272: 	state.checkpoint_lock = transaction.SharedLockTable(*info);
273: 	row_groups->InitializeParallelScan(state.scan_state);
274: 
275: 	local_storage.InitializeParallelScan(*this, state.local_state);
276: }
277: 
278: bool DataTable::NextParallelScan(ClientContext &context, ParallelTableScanState &state, TableScanState &scan_state) {
279: 	if (row_groups->NextParallelScan(context, state.scan_state, scan_state.table_state)) {
280: 		return true;
281: 	}
282: 	auto &local_storage = LocalStorage::Get(context, db);
283: 	if (local_storage.NextParallelScan(context, *this, state.local_state, scan_state.local_state)) {
284: 		return true;
285: 	} else {
286: 		// finished all scans: no more scans remaining
287: 		return false;
288: 	}
289: }
290: 
291: void DataTable::Scan(DuckTransaction &transaction, DataChunk &result, TableScanState &state) {
292: 	// scan the persistent segments
293: 	if (state.table_state.Scan(transaction, result)) {
294: 		D_ASSERT(result.size() > 0);
295: 		return;
296: 	}
297: 
298: 	// scan the transaction-local segments
299: 	auto &local_storage = LocalStorage::Get(transaction);
300: 	local_storage.Scan(state.local_state, state.GetColumnIds(), result);
301: }
302: 
303: bool DataTable::CreateIndexScan(TableScanState &state, DataChunk &result, TableScanType type) {
304: 	return state.table_state.ScanCommitted(result, type);
305: }
306: 
307: //===--------------------------------------------------------------------===//
308: // Index Methods
309: //===--------------------------------------------------------------------===//
310: shared_ptr<DataTableInfo> &DataTable::GetDataTableInfo() {
311: 	return info;
312: }
313: 
314: void DataTable::InitializeIndexes(ClientContext &context) {
315: 	info->InitializeIndexes(context);
316: }
317: 
318: bool DataTable::HasIndexes() const {
319: 	return !info->indexes.Empty();
320: }
321: 
322: bool DataTable::HasUniqueIndexes() const {
323: 	if (!HasIndexes()) {
324: 		return false;
325: 	}
326: 	bool has_unique_index = false;
327: 	info->indexes.Scan([&](Index &index) {
328: 		if (index.IsUnique()) {
329: 			has_unique_index = true;
330: 			return true;
331: 		}
332: 		return false;
333: 	});
334: 	return has_unique_index;
335: }
336: 
337: void DataTable::AddIndex(unique_ptr<Index> index) {
338: 	info->indexes.AddIndex(std::move(index));
339: }
340: 
341: bool DataTable::HasForeignKeyIndex(const vector<PhysicalIndex> &keys, ForeignKeyType type) {
342: 	return info->indexes.FindForeignKeyIndex(keys, type) != nullptr;
343: }
344: 
345: void DataTable::SetIndexStorageInfo(vector<IndexStorageInfo> index_storage_info) {
346: 	info->index_storage_infos = std::move(index_storage_info);
347: }
348: 
349: void DataTable::VacuumIndexes() {
350: 	info->indexes.Scan([&](Index &index) {
351: 		if (index.IsBound()) {
352: 			index.Cast<BoundIndex>().Vacuum();
353: 		}
354: 		return false;
355: 	});
356: }
357: 
358: void DataTable::CleanupAppend(transaction_t lowest_transaction, idx_t start, idx_t count) {
359: 	row_groups->CleanupAppend(lowest_transaction, start, count);
360: }
361: 
362: bool DataTable::IndexNameIsUnique(const string &name) {
363: 	return info->indexes.NameIsUnique(name);
364: }
365: 
366: string DataTableInfo::GetSchemaName() {
367: 	return schema;
368: }
369: 
370: string DataTableInfo::GetTableName() {
371: 	lock_guard<mutex> l(name_lock);
372: 	return table;
373: }
374: 
375: void DataTableInfo::SetTableName(string name) {
376: 	lock_guard<mutex> l(name_lock);
377: 	table = std::move(name);
378: }
379: 
380: string DataTable::GetTableName() const {
381: 	return info->GetTableName();
382: }
383: 
384: void DataTable::SetTableName(string new_name) {
385: 	info->SetTableName(std::move(new_name));
386: }
387: 
388: TableStorageInfo DataTable::GetStorageInfo() {
389: 	TableStorageInfo result;
390: 	result.cardinality = GetTotalRows();
391: 	info->indexes.Scan([&](Index &index) {
392: 		IndexInfo index_info;
393: 		index_info.is_primary = index.IsPrimary();
394: 		index_info.is_unique = index.IsUnique() || index_info.is_primary;
395: 		index_info.is_foreign = index.IsForeign();
396: 		index_info.column_set = index.GetColumnIdSet();
397: 		result.index_info.push_back(std::move(index_info));
398: 		return false;
399: 	});
400: 	return result;
401: }
402: 
403: //===--------------------------------------------------------------------===//
404: // Fetch
405: //===--------------------------------------------------------------------===//
406: void DataTable::Fetch(DuckTransaction &transaction, DataChunk &result, const vector<StorageIndex> &column_ids,
407:                       const Vector &row_identifiers, idx_t fetch_count, ColumnFetchState &state) {
408: 	auto lock = info->checkpoint_lock.GetSharedLock();
409: 	row_groups->Fetch(transaction, result, column_ids, row_identifiers, fetch_count, state);
410: }
411: 
412: //===--------------------------------------------------------------------===//
413: // Append
414: //===--------------------------------------------------------------------===//
415: static void VerifyNotNullConstraint(TableCatalogEntry &table, Vector &vector, idx_t count, const string &col_name) {
416: 	if (!VectorOperations::HasNull(vector, count)) {
417: 		return;
418: 	}
419: 
420: 	throw ConstraintException("NOT NULL constraint failed: %s.%s", table.name, col_name);
421: }
422: 
423: // To avoid throwing an error at SELECT, instead this moves the error detection to INSERT
424: static void VerifyGeneratedExpressionSuccess(ClientContext &context, TableCatalogEntry &table, DataChunk &chunk,
425:                                              Expression &expr, column_t index) {
426: 	auto &col = table.GetColumn(LogicalIndex(index));
427: 	D_ASSERT(col.Generated());
428: 	ExpressionExecutor executor(context, expr);
429: 	Vector result(col.Type());
430: 	try {
431: 		executor.ExecuteExpression(chunk, result);
432: 	} catch (InternalException &ex) {
433: 		throw;
434: 	} catch (std::exception &ex) {
435: 		ErrorData error(ex);
436: 		throw ConstraintException("Incorrect value for generated column \"%s %s AS (%s)\" : %s", col.Name(),
437: 		                          col.Type().ToString(), col.GeneratedExpression().ToString(), error.RawMessage());
438: 	}
439: }
440: 
441: static void VerifyCheckConstraint(ClientContext &context, TableCatalogEntry &table, Expression &expr, DataChunk &chunk,
442:                                   CheckConstraint &check) {
443: 	ExpressionExecutor executor(context, expr);
444: 	Vector result(LogicalType::INTEGER);
445: 	try {
446: 		executor.ExecuteExpression(chunk, result);
447: 	} catch (std::exception &ex) {
448: 		ErrorData error(ex);
449: 		throw ConstraintException("CHECK constraint failed on table %s with expression %s (Error: %s)", table.name,
450: 		                          check.ToString(), error.RawMessage());
451: 	} catch (...) {
452: 		// LCOV_EXCL_START
453: 		throw ConstraintException("CHECK constraint failed on table %s with expression %s (Unknown Error)", table.name,
454: 		                          check.ToString());
455: 	} // LCOV_EXCL_STOP
456: 	UnifiedVectorFormat vdata;
457: 	result.ToUnifiedFormat(chunk.size(), vdata);
458: 
459: 	auto dataptr = UnifiedVectorFormat::GetData<int32_t>(vdata);
460: 	for (idx_t i = 0; i < chunk.size(); i++) {
461: 		auto idx = vdata.sel->get_index(i);
462: 		if (vdata.validity.RowIsValid(idx) && dataptr[idx] == 0) {
463: 			throw ConstraintException("CHECK constraint failed on table %s with expression %s", table.name,
464: 			                          check.ToString());
465: 		}
466: 	}
467: }
468: 
469: bool DataTable::IsForeignKeyIndex(const vector<PhysicalIndex> &fk_keys, Index &index, ForeignKeyType fk_type) {
470: 	if (fk_type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE ? !index.IsUnique() : !index.IsForeign()) {
471: 		return false;
472: 	}
473: 	if (fk_keys.size() != index.GetColumnIds().size()) {
474: 		return false;
475: 	}
476: 	for (auto &fk_key : fk_keys) {
477: 		bool is_found = false;
478: 		for (auto &index_key : index.GetColumnIds()) {
479: 			if (fk_key.index == index_key) {
480: 				is_found = true;
481: 				break;
482: 			}
483: 		}
484: 		if (!is_found) {
485: 			return false;
486: 		}
487: 	}
488: 	return true;
489: }
490: 
491: // Find the first index that is not null, and did not find a match
492: static idx_t FirstMissingMatch(const ManagedSelection &matches) {
493: 	idx_t match_idx = 0;
494: 
495: 	for (idx_t i = 0; i < matches.Size(); i++) {
496: 		auto match = matches.IndexMapsToLocation(match_idx, i);
497: 		match_idx += match;
498: 		if (!match) {
499: 			// This index is missing in the matches vector
500: 			return i;
501: 		}
502: 	}
503: 	return DConstants::INVALID_INDEX;
504: }
505: 
506: idx_t LocateErrorIndex(bool is_append, const ManagedSelection &matches) {
507: 	// We expected to find nothing, so the first error is the first match.
508: 	if (!is_append) {
509: 		return matches[0];
510: 	}
511: 	// We expected to find matches for all of them, so the first missing match is the first error.
512: 	return FirstMissingMatch(matches);
513: }
514: 
515: [[noreturn]] static void ThrowForeignKeyConstraintError(idx_t failed_index, bool is_append, Index &conflict_index,
516:                                                         DataChunk &input) {
517: 	// The index that caused the conflict has to be bound by this point (or we would not have gotten here)
518: 	D_ASSERT(conflict_index.IsBound());
519: 	auto &index = conflict_index.Cast<BoundIndex>();
520: 	auto verify_type = is_append ? VerifyExistenceType::APPEND_FK : VerifyExistenceType::DELETE_FK;
521: 	D_ASSERT(failed_index != DConstants::INVALID_INDEX);
522: 	auto message = index.GetConstraintViolationMessage(verify_type, failed_index, input);
523: 	throw ConstraintException(message);
524: }
525: 
526: bool IsForeignKeyConstraintError(bool is_append, idx_t input_count, const ManagedSelection &matches) {
527: 	if (is_append) {
528: 		// We need to find a match for all values
529: 		return matches.Count() != input_count;
530: 	} else {
531: 		// We should not find any matches
532: 		return matches.Count() != 0;
533: 	}
534: }
535: 
536: static bool IsAppend(VerifyExistenceType verify_type) {
537: 	return verify_type == VerifyExistenceType::APPEND_FK;
538: }
539: 
540: void DataTable::VerifyForeignKeyConstraint(const BoundForeignKeyConstraint &bfk, ClientContext &context,
541:                                            DataChunk &chunk, VerifyExistenceType verify_type) {
542: 	const vector<PhysicalIndex> *src_keys_ptr = &bfk.info.fk_keys;
543: 	const vector<PhysicalIndex> *dst_keys_ptr = &bfk.info.pk_keys;
544: 
545: 	bool is_append = IsAppend(verify_type);
546: 	if (!is_append) {
547: 		src_keys_ptr = &bfk.info.pk_keys;
548: 		dst_keys_ptr = &bfk.info.fk_keys;
549: 	}
550: 
551: 	auto &table_entry_ptr =
552: 	    Catalog::GetEntry<TableCatalogEntry>(context, db.GetName(), bfk.info.schema, bfk.info.table);
553: 	// make the data chunk to check
554: 	vector<LogicalType> types;
555: 	for (auto &col : table_entry_ptr.GetColumns().Physical()) {
556: 		types.emplace_back(col.Type());
557: 	}
558: 	DataChunk dst_chunk;
559: 	dst_chunk.InitializeEmpty(types);
560: 	for (idx_t i = 0; i < src_keys_ptr->size(); i++) {
561: 		dst_chunk.data[(*dst_keys_ptr)[i].index].Reference(chunk.data[(*src_keys_ptr)[i].index]);
562: 	}
563: 	dst_chunk.SetCardinality(chunk.size());
564: 	auto &data_table = table_entry_ptr.GetStorage();
565: 
566: 	idx_t count = dst_chunk.size();
567: 	if (count <= 0) {
568: 		return;
569: 	}
570: 
571: 	// Set up a way to record conflicts, rather than directly throw on them
572: 	unordered_set<column_t> empty_column_list;
573: 	ConflictInfo empty_conflict_info(empty_column_list, false);
574: 	ConflictManager regular_conflicts(verify_type, count, &empty_conflict_info);
575: 	ConflictManager transaction_conflicts(verify_type, count, &empty_conflict_info);
576: 	regular_conflicts.SetMode(ConflictManagerMode::SCAN);
577: 	transaction_conflicts.SetMode(ConflictManagerMode::SCAN);
578: 
579: 	data_table.info->indexes.VerifyForeignKey(*dst_keys_ptr, dst_chunk, regular_conflicts);
580: 	regular_conflicts.Finalize();
581: 	auto &regular_matches = regular_conflicts.Conflicts();
582: 
583: 	// check if we can insert the chunk into the reference table's local storage
584: 	auto &local_storage = LocalStorage::Get(context, db);
585: 	bool error = IsForeignKeyConstraintError(is_append, count, regular_matches);
586: 	bool transaction_error = false;
587: 	bool transaction_check = local_storage.Find(data_table);
588: 
589: 	if (transaction_check) {
590: 		auto &transact_index = local_storage.GetIndexes(data_table);
591: 		transact_index.VerifyForeignKey(*dst_keys_ptr, dst_chunk, transaction_conflicts);
592: 		transaction_conflicts.Finalize();
593: 		auto &transaction_matches = transaction_conflicts.Conflicts();
594: 		transaction_error = IsForeignKeyConstraintError(is_append, count, transaction_matches);
595: 	}
596: 
597: 	if (!transaction_error && !error) {
598: 		// No error occurred;
599: 		return;
600: 	}
601: 
602: 	// Some error occurred, and we likely want to throw
603: 	optional_ptr<Index> index;
604: 	optional_ptr<Index> transaction_index;
605: 
606: 	auto fk_type = is_append ? ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE : ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE;
607: 	// check whether or not the chunk can be inserted or deleted into the referenced table' storage
608: 	index = data_table.info->indexes.FindForeignKeyIndex(*dst_keys_ptr, fk_type);
609: 	if (transaction_check) {
610: 		auto &transact_index = local_storage.GetIndexes(data_table);
611: 		// check whether or not the chunk can be inserted or deleted into the referenced table' storage
612: 		transaction_index = transact_index.FindForeignKeyIndex(*dst_keys_ptr, fk_type);
613: 	}
614: 
615: 	if (!transaction_check) {
616: 		// Only local state is checked, throw the error
617: 		D_ASSERT(error);
618: 		auto failed_index = LocateErrorIndex(is_append, regular_matches);
619: 		D_ASSERT(failed_index != DConstants::INVALID_INDEX);
620: 		ThrowForeignKeyConstraintError(failed_index, is_append, *index, dst_chunk);
621: 	}
622: 	if (transaction_error && error && is_append) {
623: 		// When we want to do an append, we only throw if the foreign key does not exist in both transaction and local
624: 		// storage
625: 		auto &transaction_matches = transaction_conflicts.Conflicts();
626: 		idx_t failed_index = DConstants::INVALID_INDEX;
627: 		idx_t regular_idx = 0;
628: 		idx_t transaction_idx = 0;
629: 		for (idx_t i = 0; i < count; i++) {
630: 			bool in_regular = regular_matches.IndexMapsToLocation(regular_idx, i);
631: 			regular_idx += in_regular;
632: 			bool in_transaction = transaction_matches.IndexMapsToLocation(transaction_idx, i);
633: 			transaction_idx += in_transaction;
634: 
635: 			if (!in_regular && !in_transaction) {
636: 				// We need to find a match for all of the input values
637: 				// The failed index is i, it does not show up in either regular or transaction storage
638: 				failed_index = i;
639: 				break;
640: 			}
641: 		}
642: 		if (failed_index == DConstants::INVALID_INDEX) {
643: 			// We don't throw, every value was present in either regular or transaction storage
644: 			return;
645: 		}
646: 		ThrowForeignKeyConstraintError(failed_index, true, *index, dst_chunk);
647: 	}
648: 	if (!is_append) {
649: 		D_ASSERT(transaction_check);
650: 		auto &transaction_matches = transaction_conflicts.Conflicts();
651: 		if (error) {
652: 			auto failed_index = LocateErrorIndex(false, regular_matches);
653: 			D_ASSERT(failed_index != DConstants::INVALID_INDEX);
654: 			ThrowForeignKeyConstraintError(failed_index, false, *index, dst_chunk);
655: 		} else {
656: 			D_ASSERT(transaction_error);
657: 			D_ASSERT(transaction_matches.Count() != DConstants::INVALID_INDEX);
658: 			auto failed_index = LocateErrorIndex(false, transaction_matches);
659: 			D_ASSERT(failed_index != DConstants::INVALID_INDEX);
660: 			ThrowForeignKeyConstraintError(failed_index, false, *transaction_index, dst_chunk);
661: 		}
662: 	}
663: }
664: 
665: void DataTable::VerifyAppendForeignKeyConstraint(const BoundForeignKeyConstraint &bfk, ClientContext &context,
666:                                                  DataChunk &chunk) {
667: 	VerifyForeignKeyConstraint(bfk, context, chunk, VerifyExistenceType::APPEND_FK);
668: }
669: 
670: void DataTable::VerifyDeleteForeignKeyConstraint(const BoundForeignKeyConstraint &bfk, ClientContext &context,
671:                                                  DataChunk &chunk) {
672: 	VerifyForeignKeyConstraint(bfk, context, chunk, VerifyExistenceType::DELETE_FK);
673: }
674: 
675: void DataTable::VerifyNewConstraint(LocalStorage &local_storage, DataTable &parent, const BoundConstraint &constraint) {
676: 	if (constraint.type != ConstraintType::NOT_NULL) {
677: 		throw NotImplementedException("FIXME: ALTER COLUMN with such constraint is not supported yet");
678: 	}
679: 
680: 	parent.row_groups->VerifyNewConstraint(parent, constraint);
681: 	local_storage.VerifyNewConstraint(parent, constraint);
682: }
683: 
684: void DataTable::VerifyUniqueIndexes(TableIndexList &indexes, optional_ptr<LocalTableStorage> storage, DataChunk &chunk,
685:                                     optional_ptr<ConflictManager> manager) {
686: 	// Verify the constraint without a conflict manager.
687: 	if (!manager) {
688: 		return indexes.ScanBound<ART>([&](ART &art) {
689: 			if (!art.IsUnique()) {
690: 				return false;
691: 			}
692: 
693: 			if (storage) {
694: 				auto delete_index = storage->delete_indexes.Find(art.GetIndexName());
695: 				art.VerifyAppend(chunk, delete_index, nullptr);
696: 			} else {
697: 				art.VerifyAppend(chunk, nullptr, nullptr);
698: 			}
699: 			return false;
700: 		});
701: 	}
702: 
703: 	// The conflict manager is only provided for statements containing ON CONFLICT.
704: 	auto &conflict_info = manager->GetConflictInfo();
705: 
706: 	// Find all indexes matching the conflict target.
707: 	indexes.ScanBound<ART>([&](ART &art) {
708: 		if (!art.IsUnique()) {
709: 			return false;
710: 		}
711: 		if (!conflict_info.ConflictTargetMatches(art)) {
712: 			return false;
713: 		}
714: 
715: 		if (storage) {
716: 			auto delete_index = storage->delete_indexes.Find(art.GetIndexName());
717: 			manager->AddIndex(art, delete_index);
718: 		} else {
719: 			manager->AddIndex(art, nullptr);
720: 		}
721: 		return false;
722: 	});
723: 
724: 	// Verify indexes matching the conflict target.
725: 	manager->SetMode(ConflictManagerMode::SCAN);
726: 	auto &matched_indexes = manager->MatchedIndexes();
727: 	auto &matched_delete_indexes = manager->MatchedDeleteIndexes();
728: 	for (idx_t i = 0; i < matched_indexes.size(); i++) {
729: 		matched_indexes[i].get().VerifyAppend(chunk, matched_delete_indexes[i], *manager);
730: 	}
731: 
732: 	// Scan the other indexes and throw, if there are any conflicts.
733: 	manager->SetMode(ConflictManagerMode::THROW);
734: 	indexes.ScanBound<ART>([&](ART &art) {
735: 		if (!art.IsUnique()) {
736: 			return false;
737: 		}
738: 		if (manager->MatchedIndex(art)) {
739: 			return false;
740: 		}
741: 
742: 		if (storage) {
743: 			auto delete_index = storage->delete_indexes.Find(art.GetIndexName());
744: 			art.VerifyAppend(chunk, delete_index, *manager);
745: 		} else {
746: 			art.VerifyAppend(chunk, nullptr, *manager);
747: 		}
748: 		return false;
749: 	});
750: }
751: 
752: void DataTable::VerifyAppendConstraints(ConstraintState &constraint_state, ClientContext &context, DataChunk &chunk,
753:                                         optional_ptr<LocalTableStorage> storage,
754:                                         optional_ptr<ConflictManager> manager) {
755: 
756: 	auto &table = constraint_state.table;
757: 
758: 	if (table.HasGeneratedColumns()) {
759: 		// Verify the generated columns against the inserted values.
760: 		auto binder = Binder::CreateBinder(context);
761: 		physical_index_set_t bound_columns;
762: 		CheckBinder generated_check_binder(*binder, context, table.name, table.GetColumns(), bound_columns);
763: 		for (auto &col : table.GetColumns().Logical()) {
764: 			if (!col.Generated()) {
765: 				continue;
766: 			}
767: 			D_ASSERT(col.Type().id() != LogicalTypeId::ANY);
768: 			generated_check_binder.target_type = col.Type();
769: 			auto to_be_bound_expression = col.GeneratedExpression().Copy();
770: 			auto bound_expression = generated_check_binder.Bind(to_be_bound_expression);
771: 			VerifyGeneratedExpressionSuccess(context, table, chunk, *bound_expression, col.Oid());
772: 		}
773: 	}
774: 
775: 	if (HasUniqueIndexes()) {
776: 		VerifyUniqueIndexes(info->indexes, storage, chunk, manager);
777: 	}
778: 
779: 	auto &constraints = table.GetConstraints();
780: 	for (idx_t i = 0; i < constraint_state.bound_constraints.size(); i++) {
781: 		auto &base_constraint = constraints[i];
782: 		auto &constraint = constraint_state.bound_constraints[i];
783: 		switch (base_constraint->type) {
784: 		case ConstraintType::NOT_NULL: {
785: 			auto &bound_not_null = constraint->Cast<BoundNotNullConstraint>();
786: 			auto &not_null = base_constraint->Cast<NotNullConstraint>();
787: 			auto &col = table.GetColumns().GetColumn(LogicalIndex(not_null.index));
788: 			VerifyNotNullConstraint(table, chunk.data[bound_not_null.index.index], chunk.size(), col.Name());
789: 			break;
790: 		}
791: 		case ConstraintType::CHECK: {
792: 			auto &check = base_constraint->Cast<CheckConstraint>();
793: 			auto &bound_check = constraint->Cast<BoundCheckConstraint>();
794: 			VerifyCheckConstraint(context, table, *bound_check.expression, chunk, check);
795: 			break;
796: 		}
797: 		case ConstraintType::UNIQUE: {
798: 			// These were handled earlier.
799: 			break;
800: 		}
801: 		case ConstraintType::FOREIGN_KEY: {
802: 			auto &bfk = constraint->Cast<BoundForeignKeyConstraint>();
803: 			if (bfk.info.type == ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE ||
804: 			    bfk.info.type == ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE) {
805: 				VerifyAppendForeignKeyConstraint(bfk, context, chunk);
806: 			}
807: 			break;
808: 		}
809: 		default:
810: 			throw InternalException("invalid constraint type");
811: 		}
812: 	}
813: }
814: 
815: unique_ptr<ConstraintState>
816: DataTable::InitializeConstraintState(TableCatalogEntry &table,
817:                                      const vector<unique_ptr<BoundConstraint>> &bound_constraints) {
818: 	return make_uniq<ConstraintState>(table, bound_constraints);
819: }
820: 
821: void DataTable::InitializeLocalAppend(LocalAppendState &state, TableCatalogEntry &table, ClientContext &context,
822:                                       const vector<unique_ptr<BoundConstraint>> &bound_constraints) {
823: 	if (!is_root) {
824: 		throw TransactionException("Transaction conflict: adding entries to a table that has been altered!");
825: 	}
826: 	auto &local_storage = LocalStorage::Get(context, db);
827: 	local_storage.InitializeAppend(state, *this);
828: 	state.constraint_state = InitializeConstraintState(table, bound_constraints);
829: }
830: 
831: void DataTable::InitializeLocalStorage(LocalAppendState &state, TableCatalogEntry &table, ClientContext &context,
832:                                        const vector<unique_ptr<BoundConstraint>> &bound_constraints) {
833: 	if (!is_root) {
834: 		throw TransactionException("Transaction conflict: adding entries to a table that has been altered!");
835: 	}
836: 
837: 	auto &local_storage = LocalStorage::Get(context, db);
838: 	local_storage.InitializeStorage(state, *this);
839: 	state.constraint_state = InitializeConstraintState(table, bound_constraints);
840: }
841: 
842: void DataTable::LocalAppend(LocalAppendState &state, ClientContext &context, DataChunk &chunk, bool unsafe) {
843: 	if (chunk.size() == 0) {
844: 		return;
845: 	}
846: 	if (!is_root) {
847: 		throw TransactionException("write conflict: adding entries to a table that has been altered");
848: 	}
849: 	chunk.Verify();
850: 
851: 	// Insert any row ids into the DELETE ART and verify constraints afterward.
852: 	// This happens only for the global indexes.
853: 	if (!unsafe) {
854: 		auto &constraint_state = *state.constraint_state;
855: 		VerifyAppendConstraints(constraint_state, context, chunk, *state.storage, nullptr);
856: 	}
857: 
858: 	// Append to the transaction-local data.
859: 	LocalStorage::Append(state, chunk);
860: }
861: 
862: void DataTable::FinalizeLocalAppend(LocalAppendState &state) {
863: 	LocalStorage::FinalizeAppend(state);
864: }
865: 
866: OptimisticDataWriter &DataTable::CreateOptimisticWriter(ClientContext &context) {
867: 	auto &local_storage = LocalStorage::Get(context, db);
868: 	return local_storage.CreateOptimisticWriter(*this);
869: }
870: 
871: void DataTable::FinalizeOptimisticWriter(ClientContext &context, OptimisticDataWriter &writer) {
872: 	auto &local_storage = LocalStorage::Get(context, db);
873: 	local_storage.FinalizeOptimisticWriter(*this, writer);
874: }
875: 
876: void DataTable::LocalMerge(ClientContext &context, RowGroupCollection &collection) {
877: 	auto &local_storage = LocalStorage::Get(context, db);
878: 	local_storage.LocalMerge(*this, collection);
879: }
880: 
881: void DataTable::LocalAppend(TableCatalogEntry &table, ClientContext &context, DataChunk &chunk,
882:                             const vector<unique_ptr<BoundConstraint>> &bound_constraints) {
883: 	LocalAppendState append_state;
884: 	auto &storage = table.GetStorage();
885: 	storage.InitializeLocalAppend(append_state, table, context, bound_constraints);
886: 
887: 	storage.LocalAppend(append_state, context, chunk, false);
888: 	storage.FinalizeLocalAppend(append_state);
889: }
890: 
891: void DataTable::LocalAppend(TableCatalogEntry &table, ClientContext &context, DataChunk &chunk,
892:                             const vector<unique_ptr<BoundConstraint>> &bound_constraints, Vector &row_ids,
893:                             DataChunk &delete_chunk) {
894: 	LocalAppendState append_state;
895: 	auto &storage = table.GetStorage();
896: 	storage.InitializeLocalAppend(append_state, table, context, bound_constraints);
897: 	append_state.storage->AppendToDeleteIndexes(row_ids, delete_chunk);
898: 
899: 	storage.LocalAppend(append_state, context, chunk, false);
900: 	storage.FinalizeLocalAppend(append_state);
901: }
902: 
903: void DataTable::LocalAppend(TableCatalogEntry &table, ClientContext &context, ColumnDataCollection &collection,
904:                             const vector<unique_ptr<BoundConstraint>> &bound_constraints,
905:                             optional_ptr<const vector<LogicalIndex>> column_ids) {
906: 
907: 	LocalAppendState append_state;
908: 	auto &storage = table.GetStorage();
909: 	storage.InitializeLocalAppend(append_state, table, context, bound_constraints);
910: 
911: 	if (!column_ids || column_ids->empty()) {
912: 		for (auto &chunk : collection.Chunks()) {
913: 			storage.LocalAppend(append_state, context, chunk, false);
914: 		}
915: 		storage.FinalizeLocalAppend(append_state);
916: 		return;
917: 	}
918: 
919: 	auto &column_list = table.GetColumns();
920: 	map<PhysicalIndex, unique_ptr<Expression>> active_expressions;
921: 	for (idx_t i = 0; i < column_ids->size(); i++) {
922: 		auto &col = column_list.GetColumn((*column_ids)[i]);
923: 		auto expr = make_uniq<BoundReferenceExpression>(col.Name(), col.Type(), i);
924: 		active_expressions[col.Physical()] = std::move(expr);
925: 	}
926: 
927: 	auto binder = Binder::CreateBinder(context);
928: 	ConstantBinder default_binder(*binder, context, "DEFAULT value");
929: 	vector<unique_ptr<Expression>> expressions;
930: 	for (idx_t i = 0; i < column_list.PhysicalColumnCount(); i++) {
931: 		auto expr = active_expressions.find(PhysicalIndex(i));
932: 		if (expr != active_expressions.end()) {
933: 			expressions.push_back(std::move(expr->second));
934: 			continue;
935: 		}
936: 
937: 		auto &col = column_list.GetColumn(PhysicalIndex(i));
938: 		if (!col.HasDefaultValue()) {
939: 			auto null_expr = make_uniq<BoundConstantExpression>(Value(col.Type()));
940: 			expressions.push_back(std::move(null_expr));
941: 			continue;
942: 		}
943: 
944: 		auto default_copy = col.DefaultValue().Copy();
945: 		default_binder.target_type = col.Type();
946: 		auto bound_default = default_binder.Bind(default_copy);
947: 		expressions.push_back(std::move(bound_default));
948: 	}
949: 
950: 	ExpressionExecutor expression_executor(context, expressions);
951: 	DataChunk result;
952: 	result.Initialize(context, table.GetTypes());
953: 
954: 	for (auto &chunk : collection.Chunks()) {
955: 		expression_executor.Execute(chunk, result);
956: 		storage.LocalAppend(append_state, context, result, false);
957: 		result.Reset();
958: 	}
959: 	storage.FinalizeLocalAppend(append_state);
960: }
961: 
962: void DataTable::AppendLock(TableAppendState &state) {
963: 	state.append_lock = unique_lock<mutex>(append_lock);
964: 	if (!is_root) {
965: 		throw TransactionException("Transaction conflict: adding entries to a table that has been altered!");
966: 	}
967: 	state.row_start = NumericCast<row_t>(row_groups->GetTotalRows());
968: 	state.current_row = state.row_start;
969: }
970: 
971: void DataTable::InitializeAppend(DuckTransaction &transaction, TableAppendState &state) {
972: 	// obtain the append lock for this table
973: 	if (!state.append_lock) {
974: 		throw InternalException("DataTable::AppendLock should be called before DataTable::InitializeAppend");
975: 	}
976: 	row_groups->InitializeAppend(transaction, state);
977: }
978: 
979: void DataTable::Append(DataChunk &chunk, TableAppendState &state) {
980: 	D_ASSERT(is_root);
981: 	row_groups->Append(chunk, state);
982: }
983: 
984: void DataTable::FinalizeAppend(DuckTransaction &transaction, TableAppendState &state) {
985: 	row_groups->FinalizeAppend(transaction, state);
986: }
987: 
988: void DataTable::ScanTableSegment(DuckTransaction &transaction, idx_t row_start, idx_t count,
989:                                  const std::function<void(DataChunk &chunk)> &function) {
990: 	if (count == 0) {
991: 		return;
992: 	}
993: 	idx_t end = row_start + count;
994: 
995: 	vector<StorageIndex> column_ids;
996: 	vector<LogicalType> types;
997: 	for (idx_t i = 0; i < this->column_definitions.size(); i++) {
998: 		auto &col = this->column_definitions[i];
999: 		column_ids.emplace_back(i);
1000: 		types.push_back(col.Type());
1001: 	}
1002: 	DataChunk chunk;
1003: 	chunk.Initialize(Allocator::Get(db), types);
1004: 
1005: 	CreateIndexScanState state;
1006: 
1007: 	InitializeScanWithOffset(transaction, state, column_ids, row_start, row_start + count);
1008: 	auto row_start_aligned = state.table_state.row_group->start + state.table_state.vector_index * STANDARD_VECTOR_SIZE;
1009: 
1010: 	idx_t current_row = row_start_aligned;
1011: 	while (current_row < end) {
1012: 		state.table_state.ScanCommitted(chunk, TableScanType::TABLE_SCAN_COMMITTED_ROWS);
1013: 		if (chunk.size() == 0) {
1014: 			break;
1015: 		}
1016: 		idx_t end_row = current_row + chunk.size();
1017: 		// start of chunk is current_row
1018: 		// end of chunk is end_row
1019: 		// figure out if we need to write the entire chunk or just part of it
1020: 		idx_t chunk_start = MaxValue<idx_t>(current_row, row_start);
1021: 		idx_t chunk_end = MinValue<idx_t>(end_row, end);
1022: 		D_ASSERT(chunk_start < chunk_end);
1023: 		idx_t chunk_count = chunk_end - chunk_start;
1024: 		if (chunk_count != chunk.size()) {
1025: 			D_ASSERT(chunk_count <= chunk.size());
1026: 			// need to slice the chunk before insert
1027: 			idx_t start_in_chunk;
1028: 			if (current_row >= row_start) {
1029: 				start_in_chunk = 0;
1030: 			} else {
1031: 				start_in_chunk = row_start - current_row;
1032: 			}
1033: 			SelectionVector sel(start_in_chunk, chunk_count);
1034: 			chunk.Slice(sel, chunk_count);
1035: 			chunk.Verify();
1036: 		}
1037: 		function(chunk);
1038: 		chunk.Reset();
1039: 		current_row = end_row;
1040: 	}
1041: }
1042: 
1043: void DataTable::MergeStorage(RowGroupCollection &data, TableIndexList &,
1044:                              optional_ptr<StorageCommitState> commit_state) {
1045: 	row_groups->MergeStorage(data, this, commit_state);
1046: 	row_groups->Verify();
1047: }
1048: 
1049: void DataTable::WriteToLog(DuckTransaction &transaction, WriteAheadLog &log, idx_t row_start, idx_t count,
1050:                            optional_ptr<StorageCommitState> commit_state) {
1051: 	log.WriteSetTable(info->schema, info->table);
1052: 	if (commit_state) {
1053: 		idx_t optimistic_count = 0;
1054: 		auto entry = commit_state->GetRowGroupData(*this, row_start, optimistic_count);
1055: 		if (entry) {
1056: 			D_ASSERT(optimistic_count > 0);
1057: 			log.WriteRowGroupData(*entry);
1058: 			if (optimistic_count > count) {
1059: 				throw InternalException(
1060: 				    "Optimistically written count cannot exceed actual count (got %llu, but expected count is %llu)",
1061: 				    optimistic_count, count);
1062: 			}
1063: 			// write any remaining (non-optimistically written) rows to the WAL normally
1064: 			row_start += optimistic_count;
1065: 			count -= optimistic_count;
1066: 			if (count == 0) {
1067: 				return;
1068: 			}
1069: 		}
1070: 	}
1071: 	ScanTableSegment(transaction, row_start, count, [&](DataChunk &chunk) { log.WriteInsert(chunk); });
1072: }
1073: 
1074: void DataTable::CommitAppend(transaction_t commit_id, idx_t row_start, idx_t count) {
1075: 	lock_guard<mutex> lock(append_lock);
1076: 	row_groups->CommitAppend(commit_id, row_start, count);
1077: }
1078: 
1079: void DataTable::RevertAppendInternal(idx_t start_row) {
1080: 	D_ASSERT(is_root);
1081: 	// revert appends made to row_groups
1082: 	row_groups->RevertAppendInternal(start_row);
1083: }
1084: 
1085: void DataTable::RevertAppend(DuckTransaction &transaction, idx_t start_row, idx_t count) {
1086: 	lock_guard<mutex> lock(append_lock);
1087: 
1088: 	// revert any appends to indexes
1089: 	if (!info->indexes.Empty()) {
1090: 		idx_t current_row_base = start_row;
1091: 		row_t row_data[STANDARD_VECTOR_SIZE];
1092: 		Vector row_identifiers(LogicalType::ROW_TYPE, data_ptr_cast(row_data));
1093: 		idx_t scan_count = MinValue<idx_t>(count, row_groups->GetTotalRows() - start_row);
1094: 		ScanTableSegment(transaction, start_row, scan_count, [&](DataChunk &chunk) {
1095: 			for (idx_t i = 0; i < chunk.size(); i++) {
1096: 				row_data[i] = NumericCast<row_t>(current_row_base + i);
1097: 			}
1098: 			info->indexes.Scan([&](Index &index) {
1099: 				// We cant add to unbound indexes anyways, so there is no need to revert them
1100: 				if (index.IsBound()) {
1101: 					index.Cast<BoundIndex>().Delete(chunk, row_identifiers);
1102: 				}
1103: 				return false;
1104: 			});
1105: 			current_row_base += chunk.size();
1106: 		});
1107: 	}
1108: 
1109: 	// we need to vacuum the indexes to remove any buffers that are now empty
1110: 	// due to reverting the appends
1111: 	info->indexes.Scan([&](Index &index) {
1112: 		// We cant add to unbound indexes anyway, so there is no need to vacuum them
1113: 		if (index.IsBound()) {
1114: 			index.Cast<BoundIndex>().Vacuum();
1115: 		}
1116: 		return false;
1117: 	});
1118: 
1119: 	// revert the data table append
1120: 	RevertAppendInternal(start_row);
1121: }
1122: 
1123: //===--------------------------------------------------------------------===//
1124: // Indexes
1125: //===--------------------------------------------------------------------===//
1126: ErrorData DataTable::AppendToIndexes(TableIndexList &indexes, optional_ptr<TableIndexList> delete_indexes,
1127:                                      DataChunk &chunk, row_t row_start) {
1128: 	ErrorData error;
1129: 	if (indexes.Empty()) {
1130: 		return error;
1131: 	}
1132: 
1133: 	// first generate the vector of row identifiers
1134: 	Vector row_ids(LogicalType::ROW_TYPE);
1135: 	VectorOperations::GenerateSequence(row_ids, chunk.size(), row_start, 1);
1136: 
1137: 	vector<BoundIndex *> already_appended;
1138: 	bool append_failed = false;
1139: 	// now append the entries to the indices
1140: 	indexes.Scan([&](Index &index_to_append) {
1141: 		if (!index_to_append.IsBound()) {
1142: 			throw InternalException("unbound index in DataTable::AppendToIndexes");
1143: 		}
1144: 		auto &index = index_to_append.Cast<BoundIndex>();
1145: 
1146: 		// Find the matching delete index.
1147: 		optional_ptr<BoundIndex> delete_index;
1148: 		if (index.IsUnique()) {
1149: 			if (delete_indexes) {
1150: 				delete_index = delete_indexes->Find(index.name);
1151: 			}
1152: 		}
1153: 
1154: 		try {
1155: 			error = index.AppendWithDeleteIndex(chunk, row_ids, delete_index);
1156: 		} catch (std::exception &ex) {
1157: 			error = ErrorData(ex);
1158: 		}
1159: 
1160: 		if (error.HasError()) {
1161: 			append_failed = true;
1162: 			return true;
1163: 		}
1164: 		already_appended.push_back(&index);
1165: 		return false;
1166: 	});
1167: 
1168: 	if (append_failed) {
1169: 		// constraint violation!
1170: 		// remove any appended entries from previous indexes (if any)
1171: 		for (auto *index : already_appended) {
1172: 			index->Delete(chunk, row_ids);
1173: 		}
1174: 	}
1175: 	return error;
1176: }
1177: 
1178: ErrorData DataTable::AppendToIndexes(optional_ptr<TableIndexList> delete_indexes, DataChunk &chunk, row_t row_start) {
1179: 	D_ASSERT(is_root);
1180: 	return AppendToIndexes(info->indexes, delete_indexes, chunk, row_start);
1181: }
1182: 
1183: void DataTable::RemoveFromIndexes(TableAppendState &state, DataChunk &chunk, row_t row_start) {
1184: 	D_ASSERT(is_root);
1185: 	if (info->indexes.Empty()) {
1186: 		return;
1187: 	}
1188: 	// first generate the vector of row identifiers
1189: 	Vector row_identifiers(LogicalType::ROW_TYPE);
1190: 	VectorOperations::GenerateSequence(row_identifiers, chunk.size(), row_start, 1);
1191: 
1192: 	// now remove the entries from the indices
1193: 	RemoveFromIndexes(state, chunk, row_identifiers);
1194: }
1195: 
1196: void DataTable::RemoveFromIndexes(TableAppendState &state, DataChunk &chunk, Vector &row_identifiers) {
1197: 	D_ASSERT(is_root);
1198: 	info->indexes.Scan([&](Index &index) {
1199: 		if (!index.IsBound()) {
1200: 			throw InternalException("Unbound index found in DataTable::RemoveFromIndexes");
1201: 		}
1202: 		index.Cast<BoundIndex>().Delete(chunk, row_identifiers);
1203: 		return false;
1204: 	});
1205: }
1206: 
1207: void DataTable::RemoveFromIndexes(Vector &row_identifiers, idx_t count) {
1208: 	D_ASSERT(is_root);
1209: 	row_groups->RemoveFromIndexes(info->indexes, row_identifiers, count);
1210: }
1211: 
1212: //===--------------------------------------------------------------------===//
1213: // Delete
1214: //===--------------------------------------------------------------------===//
1215: static bool TableHasDeleteConstraints(TableCatalogEntry &table) {
1216: 	for (auto &constraint : table.GetConstraints()) {
1217: 		switch (constraint->type) {
1218: 		case ConstraintType::NOT_NULL:
1219: 		case ConstraintType::CHECK:
1220: 		case ConstraintType::UNIQUE:
1221: 			break;
1222: 		case ConstraintType::FOREIGN_KEY: {
1223: 			auto &bfk = constraint->Cast<ForeignKeyConstraint>();
1224: 			if (bfk.info.type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE ||
1225: 			    bfk.info.type == ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE) {
1226: 				return true;
1227: 			}
1228: 			break;
1229: 		}
1230: 		default:
1231: 			throw NotImplementedException("Constraint type not implemented!");
1232: 		}
1233: 	}
1234: 	return false;
1235: }
1236: 
1237: void DataTable::VerifyDeleteConstraints(TableDeleteState &state, ClientContext &context, DataChunk &chunk) {
1238: 	for (auto &constraint : state.constraint_state->bound_constraints) {
1239: 		switch (constraint->type) {
1240: 		case ConstraintType::NOT_NULL:
1241: 		case ConstraintType::CHECK:
1242: 		case ConstraintType::UNIQUE:
1243: 			break;
1244: 		case ConstraintType::FOREIGN_KEY: {
1245: 			auto &bfk = constraint->Cast<BoundForeignKeyConstraint>();
1246: 			if (bfk.info.type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE ||
1247: 			    bfk.info.type == ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE) {
1248: 				VerifyDeleteForeignKeyConstraint(bfk, context, chunk);
1249: 			}
1250: 			break;
1251: 		}
1252: 		default:
1253: 			throw NotImplementedException("Constraint type not implemented!");
1254: 		}
1255: 	}
1256: }
1257: 
1258: unique_ptr<TableDeleteState> DataTable::InitializeDelete(TableCatalogEntry &table, ClientContext &context,
1259:                                                          const vector<unique_ptr<BoundConstraint>> &bound_constraints) {
1260: 	// initialize indexes (if any)
1261: 	info->InitializeIndexes(context);
1262: 
1263: 	auto binder = Binder::CreateBinder(context);
1264: 	vector<LogicalType> types;
1265: 	auto result = make_uniq<TableDeleteState>();
1266: 	result->has_delete_constraints = TableHasDeleteConstraints(table);
1267: 	if (result->has_delete_constraints) {
1268: 		// initialize the chunk if there are any constraints to verify
1269: 		for (idx_t i = 0; i < column_definitions.size(); i++) {
1270: 			result->col_ids.emplace_back(column_definitions[i].StorageOid());
1271: 			types.emplace_back(column_definitions[i].Type());
1272: 		}
1273: 		result->verify_chunk.Initialize(Allocator::Get(context), types);
1274: 		result->constraint_state = make_uniq<ConstraintState>(table, bound_constraints);
1275: 	}
1276: 	return result;
1277: }
1278: 
1279: idx_t DataTable::Delete(TableDeleteState &state, ClientContext &context, Vector &row_identifiers, idx_t count) {
1280: 	D_ASSERT(row_identifiers.GetType().InternalType() == ROW_TYPE);
1281: 	if (count == 0) {
1282: 		return 0;
1283: 	}
1284: 
1285: 	auto &transaction = DuckTransaction::Get(context, db);
1286: 	auto &local_storage = LocalStorage::Get(transaction);
1287: 
1288: 	row_identifiers.Flatten(count);
1289: 	auto ids = FlatVector::GetData<row_t>(row_identifiers);
1290: 
1291: 	idx_t pos = 0;
1292: 	idx_t delete_count = 0;
1293: 	while (pos < count) {
1294: 		idx_t start = pos;
1295: 		bool is_transaction_delete = ids[pos] >= MAX_ROW_ID;
1296: 		// figure out which batch of rows to delete now
1297: 		for (pos++; pos < count; pos++) {
1298: 			bool row_is_transaction_delete = ids[pos] >= MAX_ROW_ID;
1299: 			if (row_is_transaction_delete != is_transaction_delete) {
1300: 				break;
1301: 			}
1302: 		}
1303: 		idx_t current_offset = start;
1304: 		idx_t current_count = pos - start;
1305: 
1306: 		Vector offset_ids(row_identifiers, current_offset, pos);
1307: 
1308: 		// This is a transaction-local DELETE.
1309: 		if (is_transaction_delete) {
1310: 			if (state.has_delete_constraints) {
1311: 				// perform the constraint verification
1312: 				ColumnFetchState fetch_state;
1313: 				local_storage.FetchChunk(*this, offset_ids, current_count, state.col_ids, state.verify_chunk,
1314: 				                         fetch_state);
1315: 				VerifyDeleteConstraints(state, context, state.verify_chunk);
1316: 			}
1317: 			delete_count += local_storage.Delete(*this, offset_ids, current_count);
1318: 			continue;
1319: 		}
1320: 
1321: 		// This is a regular DELETE.
1322: 		if (state.has_delete_constraints) {
1323: 			// perform the constraint verification
1324: 			ColumnFetchState fetch_state;
1325: 			Fetch(transaction, state.verify_chunk, state.col_ids, offset_ids, current_count, fetch_state);
1326: 			VerifyDeleteConstraints(state, context, state.verify_chunk);
1327: 		}
1328: 		delete_count += row_groups->Delete(transaction, *this, ids + current_offset, current_count);
1329: 	}
1330: 	return delete_count;
1331: }
1332: 
1333: //===--------------------------------------------------------------------===//
1334: // Update
1335: //===--------------------------------------------------------------------===//
1336: static void CreateMockChunk(vector<LogicalType> &types, const vector<PhysicalIndex> &column_ids, DataChunk &chunk,
1337:                             DataChunk &mock_chunk) {
1338: 	// construct a mock DataChunk
1339: 	mock_chunk.InitializeEmpty(types);
1340: 	for (column_t i = 0; i < column_ids.size(); i++) {
1341: 		mock_chunk.data[column_ids[i].index].Reference(chunk.data[i]);
1342: 	}
1343: 	mock_chunk.SetCardinality(chunk.size());
1344: }
1345: 
1346: static bool CreateMockChunk(TableCatalogEntry &table, const vector<PhysicalIndex> &column_ids,
1347:                             physical_index_set_t &desired_column_ids, DataChunk &chunk, DataChunk &mock_chunk) {
1348: 	idx_t found_columns = 0;
1349: 	// check whether the desired columns are present in the UPDATE clause
1350: 	for (column_t i = 0; i < column_ids.size(); i++) {
1351: 		if (desired_column_ids.find(column_ids[i]) != desired_column_ids.end()) {
1352: 			found_columns++;
1353: 		}
1354: 	}
1355: 	if (found_columns == 0) {
1356: 		// no columns were found: no need to check the constraint again
1357: 		return false;
1358: 	}
1359: 	if (found_columns != desired_column_ids.size()) {
1360: 		// not all columns in UPDATE clause are present!
1361: 		// this should not be triggered at all as the binder should add these columns
1362: 		throw InternalException("Not all columns required for the CHECK constraint are present in the UPDATED chunk!");
1363: 	}
1364: 	// construct a mock DataChunk
1365: 	auto types = table.GetTypes();
1366: 	CreateMockChunk(types, column_ids, chunk, mock_chunk);
1367: 	return true;
1368: }
1369: 
1370: void DataTable::VerifyUpdateConstraints(ConstraintState &state, ClientContext &context, DataChunk &chunk,
1371:                                         const vector<PhysicalIndex> &column_ids) {
1372: 	auto &table = state.table;
1373: 	auto &constraints = table.GetConstraints();
1374: 	auto &bound_constraints = state.bound_constraints;
1375: 	for (idx_t constr_idx = 0; constr_idx < bound_constraints.size(); constr_idx++) {
1376: 		auto &base_constraint = constraints[constr_idx];
1377: 		auto &constraint = bound_constraints[constr_idx];
1378: 		switch (constraint->type) {
1379: 		case ConstraintType::NOT_NULL: {
1380: 			auto &bound_not_null = constraint->Cast<BoundNotNullConstraint>();
1381: 			auto &not_null = base_constraint->Cast<NotNullConstraint>();
1382: 			// check if the constraint is in the list of column_ids
1383: 			for (idx_t col_idx = 0; col_idx < column_ids.size(); col_idx++) {
1384: 				if (column_ids[col_idx] == bound_not_null.index) {
1385: 					// found the column id: check the data in
1386: 					auto &col = table.GetColumn(LogicalIndex(not_null.index));
1387: 					VerifyNotNullConstraint(table, chunk.data[col_idx], chunk.size(), col.Name());
1388: 					break;
1389: 				}
1390: 			}
1391: 			break;
1392: 		}
1393: 		case ConstraintType::CHECK: {
1394: 			auto &check = base_constraint->Cast<CheckConstraint>();
1395: 			auto &bound_check = constraint->Cast<BoundCheckConstraint>();
1396: 
1397: 			DataChunk mock_chunk;
1398: 			if (CreateMockChunk(table, column_ids, bound_check.bound_columns, chunk, mock_chunk)) {
1399: 				VerifyCheckConstraint(context, table, *bound_check.expression, mock_chunk, check);
1400: 			}
1401: 			break;
1402: 		}
1403: 		case ConstraintType::UNIQUE:
1404: 		case ConstraintType::FOREIGN_KEY:
1405: 			break;
1406: 		default:
1407: 			throw NotImplementedException("Constraint type not implemented!");
1408: 		}
1409: 	}
1410: 
1411: #ifdef DEBUG
1412: 	// Ensure that we never call UPDATE for indexed columns.
1413: 	// Instead, we must rewrite these updates into DELETE + INSERT.
1414: 	info->indexes.Scan([&](Index &index) {
1415: 		D_ASSERT(index.IsBound());
1416: 		D_ASSERT(!index.Cast<BoundIndex>().IndexIsUpdated(column_ids));
1417: 		return false;
1418: 	});
1419: #endif
1420: }
1421: 
1422: unique_ptr<TableUpdateState> DataTable::InitializeUpdate(TableCatalogEntry &table, ClientContext &context,
1423:                                                          const vector<unique_ptr<BoundConstraint>> &bound_constraints) {
1424: 	// check that there are no unknown indexes
1425: 	info->InitializeIndexes(context);
1426: 
1427: 	auto result = make_uniq<TableUpdateState>();
1428: 	result->constraint_state = InitializeConstraintState(table, bound_constraints);
1429: 	return result;
1430: }
1431: 
1432: void DataTable::Update(TableUpdateState &state, ClientContext &context, Vector &row_ids,
1433:                        const vector<PhysicalIndex> &column_ids, DataChunk &updates) {
1434: 	D_ASSERT(row_ids.GetType().InternalType() == ROW_TYPE);
1435: 	D_ASSERT(column_ids.size() == updates.ColumnCount());
1436: 	updates.Verify();
1437: 
1438: 	auto count = updates.size();
1439: 	if (count == 0) {
1440: 		return;
1441: 	}
1442: 
1443: 	if (!is_root) {
1444: 		throw TransactionException("Transaction conflict: cannot update a table that has been altered!");
1445: 	}
1446: 
1447: 	// first verify that no constraints are violated
1448: 	VerifyUpdateConstraints(*state.constraint_state, context, updates, column_ids);
1449: 
1450: 	// now perform the actual update
1451: 	Vector max_row_id_vec(Value::BIGINT(MAX_ROW_ID));
1452: 	Vector row_ids_slice(LogicalType::BIGINT);
1453: 	DataChunk updates_slice;
1454: 	updates_slice.InitializeEmpty(updates.GetTypes());
1455: 
1456: 	SelectionVector sel_local_update(count), sel_global_update(count);
1457: 	auto n_local_update = VectorOperations::GreaterThanEquals(row_ids, max_row_id_vec, nullptr, count,
1458: 	                                                          &sel_local_update, &sel_global_update);
1459: 	auto n_global_update = count - n_local_update;
1460: 
1461: 	// row id > MAX_ROW_ID? transaction-local storage
1462: 	if (n_local_update > 0) {
1463: 		updates_slice.Slice(updates, sel_local_update, n_local_update);
1464: 		updates_slice.Flatten();
1465: 		row_ids_slice.Slice(row_ids, sel_local_update, n_local_update);
1466: 		row_ids_slice.Flatten(n_local_update);
1467: 
1468: 		LocalStorage::Get(context, db).Update(*this, row_ids_slice, column_ids, updates_slice);
1469: 	}
1470: 
1471: 	// otherwise global storage
1472: 	if (n_global_update > 0) {
1473: 		auto &transaction = DuckTransaction::Get(context, db);
1474: 		updates_slice.Slice(updates, sel_global_update, n_global_update);
1475: 		updates_slice.Flatten();
1476: 		row_ids_slice.Slice(row_ids, sel_global_update, n_global_update);
1477: 		row_ids_slice.Flatten(n_global_update);
1478: 
1479: 		transaction.UpdateCollection(row_groups);
1480: 		row_groups->Update(transaction, FlatVector::GetData<row_t>(row_ids_slice), column_ids, updates_slice);
1481: 	}
1482: }
1483: 
1484: void DataTable::UpdateColumn(TableCatalogEntry &table, ClientContext &context, Vector &row_ids,
1485:                              const vector<column_t> &column_path, DataChunk &updates) {
1486: 	D_ASSERT(row_ids.GetType().InternalType() == ROW_TYPE);
1487: 	D_ASSERT(updates.ColumnCount() == 1);
1488: 	updates.Verify();
1489: 	if (updates.size() == 0) {
1490: 		return;
1491: 	}
1492: 
1493: 	if (!is_root) {
1494: 		throw TransactionException("Transaction conflict: cannot update a table that has been altered!");
1495: 	}
1496: 
1497: 	// now perform the actual update
1498: 	auto &transaction = DuckTransaction::Get(context, db);
1499: 
1500: 	updates.Flatten();
1501: 	row_ids.Flatten(updates.size());
1502: 	row_groups->UpdateColumn(transaction, row_ids, column_path, updates);
1503: }
1504: 
1505: //===--------------------------------------------------------------------===//
1506: // Statistics
1507: //===--------------------------------------------------------------------===//
1508: unique_ptr<BaseStatistics> DataTable::GetStatistics(ClientContext &context, column_t column_id) {
1509: 	if (column_id == COLUMN_IDENTIFIER_ROW_ID) {
1510: 		return nullptr;
1511: 	}
1512: 	return row_groups->CopyStats(column_id);
1513: }
1514: 
1515: void DataTable::SetDistinct(column_t column_id, unique_ptr<DistinctStatistics> distinct_stats) {
1516: 	D_ASSERT(column_id != COLUMN_IDENTIFIER_ROW_ID);
1517: 	row_groups->SetDistinct(column_id, std::move(distinct_stats));
1518: }
1519: 
1520: //===--------------------------------------------------------------------===//
1521: // Checkpoint
1522: //===--------------------------------------------------------------------===//
1523: unique_ptr<StorageLockKey> DataTable::GetSharedCheckpointLock() {
1524: 	return info->checkpoint_lock.GetSharedLock();
1525: }
1526: 
1527: unique_ptr<StorageLockKey> DataTable::GetCheckpointLock() {
1528: 	return info->checkpoint_lock.GetExclusiveLock();
1529: }
1530: 
1531: void DataTable::Checkpoint(TableDataWriter &writer, Serializer &serializer) {
1532: 	// checkpoint each individual row group
1533: 	TableStatistics global_stats;
1534: 	row_groups->CopyStats(global_stats);
1535: 	row_groups->Checkpoint(writer, global_stats);
1536: 
1537: 	// The row group payload data has been written. Now write:
1538: 	//   column stats
1539: 	//   row-group pointers
1540: 	//   table pointer
1541: 	//   index data
1542: 	writer.FinalizeTable(global_stats, info.get(), serializer);
1543: }
1544: 
1545: void DataTable::CommitDropColumn(idx_t index) {
1546: 	row_groups->CommitDropColumn(index);
1547: }
1548: 
1549: idx_t DataTable::ColumnCount() const {
1550: 	return column_definitions.size();
1551: }
1552: 
1553: idx_t DataTable::GetTotalRows() const {
1554: 	return row_groups->GetTotalRows();
1555: }
1556: 
1557: void DataTable::CommitDropTable() {
1558: 	// commit a drop of this table: mark all blocks as modified, so they can be reclaimed later on
1559: 	row_groups->CommitDropTable();
1560: 
1561: 	// propagate dropping this table to its indexes: frees all index memory
1562: 	info->indexes.Scan([&](Index &index) {
1563: 		D_ASSERT(index.IsBound());
1564: 		index.Cast<BoundIndex>().CommitDrop();
1565: 		return false;
1566: 	});
1567: }
1568: 
1569: //===--------------------------------------------------------------------===//
1570: // Column Segment Info
1571: //===--------------------------------------------------------------------===//
1572: vector<ColumnSegmentInfo> DataTable::GetColumnSegmentInfo() {
1573: 	auto lock = GetSharedCheckpointLock();
1574: 	return row_groups->GetColumnSegmentInfo();
1575: }
1576: 
1577: //===--------------------------------------------------------------------===//
1578: // Index Constraint Creation
1579: //===--------------------------------------------------------------------===//
1580: void DataTable::AddIndex(const ColumnList &columns, const vector<LogicalIndex> &column_indexes,
1581:                          const IndexConstraintType type, const IndexStorageInfo &index_info) {
1582: 	if (!IsRoot()) {
1583: 		throw TransactionException("cannot add an index to a table that has been altered!");
1584: 	}
1585: 
1586: 	// Fetch the column types and create bound column reference expressions.
1587: 	vector<column_t> physical_ids;
1588: 	vector<unique_ptr<Expression>> expressions;
1589: 
1590: 	for (const auto column_index : column_indexes) {
1591: 		auto binding = ColumnBinding(0, physical_ids.size());
1592: 		auto &col = columns.GetColumn(column_index);
1593: 		auto ref = make_uniq<BoundColumnRefExpression>(col.Name(), col.Type(), binding);
1594: 		expressions.push_back(std::move(ref));
1595: 		physical_ids.push_back(col.Physical().index);
1596: 	}
1597: 
1598: 	// Create an ART around the expressions.
1599: 	auto &io_manager = TableIOManager::Get(*this);
1600: 	auto art = make_uniq<ART>(index_info.name, type, physical_ids, io_manager, std::move(expressions), db, nullptr,
1601: 	                          index_info);
1602: 	info->indexes.AddIndex(std::move(art));
1603: }
1604: 
1605: } // namespace duckdb
[end of src/storage/data_table.cpp]
[start of src/storage/serialization/serialize_nodes.cpp]
1: //===----------------------------------------------------------------------===//
2: // This file is automatically generated by scripts/generate_serialization.py
3: // Do not edit this file manually, your changes will be overwritten
4: //===----------------------------------------------------------------------===//
5: 
6: #include "duckdb/common/serializer/serializer.hpp"
7: #include "duckdb/common/serializer/deserializer.hpp"
8: #include "duckdb/common/types.hpp"
9: #include "duckdb/common/extra_type_info.hpp"
10: #include "duckdb/parser/common_table_expression_info.hpp"
11: #include "duckdb/parser/query_node.hpp"
12: #include "duckdb/parser/result_modifier.hpp"
13: #include "duckdb/planner/bound_result_modifier.hpp"
14: #include "duckdb/parser/expression/case_expression.hpp"
15: #include "duckdb/planner/expression/bound_case_expression.hpp"
16: #include "duckdb/parser/parsed_data/sample_options.hpp"
17: #include "duckdb/execution/reservoir_sample.hpp"
18: #include "duckdb/common/queue.hpp"
19: #include "duckdb/parser/tableref/pivotref.hpp"
20: #include "duckdb/planner/tableref/bound_pivotref.hpp"
21: #include "duckdb/parser/column_definition.hpp"
22: #include "duckdb/parser/column_list.hpp"
23: #include "duckdb/planner/column_binding.hpp"
24: #include "duckdb/planner/expression/bound_parameter_data.hpp"
25: #include "duckdb/planner/joinside.hpp"
26: #include "duckdb/parser/parsed_data/vacuum_info.hpp"
27: #include "duckdb/planner/table_filter.hpp"
28: #include "duckdb/common/multi_file_reader_options.hpp"
29: #include "duckdb/common/multi_file_reader.hpp"
30: #include "duckdb/execution/operator/csv_scanner/csv_option.hpp"
31: #include "duckdb/execution/operator/csv_scanner/csv_reader_options.hpp"
32: #include "duckdb/function/scalar/strftime_format.hpp"
33: #include "duckdb/function/table/read_csv.hpp"
34: #include "duckdb/common/types/interval.hpp"
35: #include "duckdb/parser/qualified_name.hpp"
36: #include "duckdb/parser/parsed_data/exported_table_data.hpp"
37: #include "duckdb/common/column_index.hpp"
38: 
39: namespace duckdb {
40: 
41: void BlockingSample::Serialize(Serializer &serializer) const {
42: 	serializer.WritePropertyWithDefault<unique_ptr<BaseReservoirSampling>>(100, "base_reservoir_sample", base_reservoir_sample);
43: 	serializer.WriteProperty<SampleType>(101, "type", type);
44: 	serializer.WritePropertyWithDefault<bool>(102, "destroyed", destroyed);
45: }
46: 
47: unique_ptr<BlockingSample> BlockingSample::Deserialize(Deserializer &deserializer) {
48: 	auto base_reservoir_sample = deserializer.ReadPropertyWithDefault<unique_ptr<BaseReservoirSampling>>(100, "base_reservoir_sample");
49: 	auto type = deserializer.ReadProperty<SampleType>(101, "type");
50: 	auto destroyed = deserializer.ReadPropertyWithDefault<bool>(102, "destroyed");
51: 	unique_ptr<BlockingSample> result;
52: 	switch (type) {
53: 	case SampleType::RESERVOIR_PERCENTAGE_SAMPLE:
54: 		result = ReservoirSamplePercentage::Deserialize(deserializer);
55: 		break;
56: 	case SampleType::RESERVOIR_SAMPLE:
57: 		result = ReservoirSample::Deserialize(deserializer);
58: 		break;
59: 	default:
60: 		throw SerializationException("Unsupported type for deserialization of BlockingSample!");
61: 	}
62: 	result->base_reservoir_sample = std::move(base_reservoir_sample);
63: 	result->destroyed = destroyed;
64: 	return result;
65: }
66: 
67: void BaseReservoirSampling::Serialize(Serializer &serializer) const {
68: 	serializer.WritePropertyWithDefault<idx_t>(100, "next_index_to_sample", next_index_to_sample);
69: 	serializer.WriteProperty<double>(101, "min_weight_threshold", min_weight_threshold);
70: 	serializer.WritePropertyWithDefault<idx_t>(102, "min_weighted_entry_index", min_weighted_entry_index);
71: 	serializer.WritePropertyWithDefault<idx_t>(103, "num_entries_to_skip_b4_next_sample", num_entries_to_skip_b4_next_sample);
72: 	serializer.WritePropertyWithDefault<idx_t>(104, "num_entries_seen_total", num_entries_seen_total);
73: 	serializer.WritePropertyWithDefault<std::priority_queue<std::pair<double, idx_t>>>(105, "reservoir_weights", reservoir_weights);
74: }
75: 
76: unique_ptr<BaseReservoirSampling> BaseReservoirSampling::Deserialize(Deserializer &deserializer) {
77: 	auto result = duckdb::unique_ptr<BaseReservoirSampling>(new BaseReservoirSampling());
78: 	deserializer.ReadPropertyWithDefault<idx_t>(100, "next_index_to_sample", result->next_index_to_sample);
79: 	deserializer.ReadProperty<double>(101, "min_weight_threshold", result->min_weight_threshold);
80: 	deserializer.ReadPropertyWithDefault<idx_t>(102, "min_weighted_entry_index", result->min_weighted_entry_index);
81: 	deserializer.ReadPropertyWithDefault<idx_t>(103, "num_entries_to_skip_b4_next_sample", result->num_entries_to_skip_b4_next_sample);
82: 	deserializer.ReadPropertyWithDefault<idx_t>(104, "num_entries_seen_total", result->num_entries_seen_total);
83: 	deserializer.ReadPropertyWithDefault<std::priority_queue<std::pair<double, idx_t>>>(105, "reservoir_weights", result->reservoir_weights);
84: 	return result;
85: }
86: 
87: void BoundCaseCheck::Serialize(Serializer &serializer) const {
88: 	serializer.WritePropertyWithDefault<unique_ptr<Expression>>(100, "when_expr", when_expr);
89: 	serializer.WritePropertyWithDefault<unique_ptr<Expression>>(101, "then_expr", then_expr);
90: }
91: 
92: BoundCaseCheck BoundCaseCheck::Deserialize(Deserializer &deserializer) {
93: 	BoundCaseCheck result;
94: 	deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(100, "when_expr", result.when_expr);
95: 	deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(101, "then_expr", result.then_expr);
96: 	return result;
97: }
98: 
99: void BoundLimitNode::Serialize(Serializer &serializer) const {
100: 	serializer.WriteProperty<LimitNodeType>(100, "type", type);
101: 	serializer.WritePropertyWithDefault<idx_t>(101, "constant_integer", constant_integer);
102: 	serializer.WriteProperty<double>(102, "constant_percentage", constant_percentage);
103: 	serializer.WritePropertyWithDefault<unique_ptr<Expression>>(103, "expression", expression);
104: }
105: 
106: BoundLimitNode BoundLimitNode::Deserialize(Deserializer &deserializer) {
107: 	auto type = deserializer.ReadProperty<LimitNodeType>(100, "type");
108: 	auto constant_integer = deserializer.ReadPropertyWithDefault<idx_t>(101, "constant_integer");
109: 	auto constant_percentage = deserializer.ReadProperty<double>(102, "constant_percentage");
110: 	auto expression = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(103, "expression");
111: 	BoundLimitNode result(type, constant_integer, constant_percentage, std::move(expression));
112: 	return result;
113: }
114: 
115: void BoundOrderByNode::Serialize(Serializer &serializer) const {
116: 	serializer.WriteProperty<OrderType>(100, "type", type);
117: 	serializer.WriteProperty<OrderByNullType>(101, "null_order", null_order);
118: 	serializer.WritePropertyWithDefault<unique_ptr<Expression>>(102, "expression", expression);
119: }
120: 
121: BoundOrderByNode BoundOrderByNode::Deserialize(Deserializer &deserializer) {
122: 	auto type = deserializer.ReadProperty<OrderType>(100, "type");
123: 	auto null_order = deserializer.ReadProperty<OrderByNullType>(101, "null_order");
124: 	auto expression = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(102, "expression");
125: 	BoundOrderByNode result(type, null_order, std::move(expression));
126: 	return result;
127: }
128: 
129: void BoundParameterData::Serialize(Serializer &serializer) const {
130: 	serializer.WriteProperty<Value>(100, "value", value);
131: 	serializer.WriteProperty<LogicalType>(101, "return_type", return_type);
132: }
133: 
134: shared_ptr<BoundParameterData> BoundParameterData::Deserialize(Deserializer &deserializer) {
135: 	auto value = deserializer.ReadProperty<Value>(100, "value");
136: 	auto result = duckdb::shared_ptr<BoundParameterData>(new BoundParameterData(value));
137: 	deserializer.ReadProperty<LogicalType>(101, "return_type", result->return_type);
138: 	return result;
139: }
140: 
141: void BoundPivotInfo::Serialize(Serializer &serializer) const {
142: 	serializer.WritePropertyWithDefault<idx_t>(100, "group_count", group_count);
143: 	serializer.WritePropertyWithDefault<vector<LogicalType>>(101, "types", types);
144: 	serializer.WritePropertyWithDefault<vector<string>>(102, "pivot_values", pivot_values);
145: 	serializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(103, "aggregates", aggregates);
146: }
147: 
148: BoundPivotInfo BoundPivotInfo::Deserialize(Deserializer &deserializer) {
149: 	BoundPivotInfo result;
150: 	deserializer.ReadPropertyWithDefault<idx_t>(100, "group_count", result.group_count);
151: 	deserializer.ReadPropertyWithDefault<vector<LogicalType>>(101, "types", result.types);
152: 	deserializer.ReadPropertyWithDefault<vector<string>>(102, "pivot_values", result.pivot_values);
153: 	deserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(103, "aggregates", result.aggregates);
154: 	return result;
155: }
156: 
157: template <typename T>
158: void CSVOption<T>::Serialize(Serializer &serializer) const {
159: 	serializer.WritePropertyWithDefault<bool>(100, "set_by_user", set_by_user);
160: 	serializer.WriteProperty<T>(101, "value", value);
161: }
162: 
163: template <typename T>
164: CSVOption<T> CSVOption<T>::Deserialize(Deserializer &deserializer) {
165: 	CSVOption<T> result;
166: 	deserializer.ReadPropertyWithDefault<bool>(100, "set_by_user", result.set_by_user);
167: 	deserializer.ReadProperty<T>(101, "value", result.value);
168: 	return result;
169: }
170: 
171: void CSVReaderOptions::Serialize(Serializer &serializer) const {
172: 	serializer.WritePropertyWithDefault<bool>(100, "ignore_errors", ignore_errors, false);
173: 	serializer.WritePropertyWithDefault<idx_t>(101, "buffer_sample_size", buffer_sample_size);
174: 	serializer.WritePropertyWithDefault<vector<string>>(102, "null_str", null_str);
175: 	serializer.WriteProperty<FileCompressionType>(103, "compression", compression);
176: 	serializer.WritePropertyWithDefault<bool>(104, "allow_quoted_nulls", allow_quoted_nulls);
177: 	serializer.WritePropertyWithDefault<idx_t>(105, "maximum_line_size", maximum_line_size);
178: 	serializer.WritePropertyWithDefault<bool>(106, "normalize_names", normalize_names);
179: 	serializer.WritePropertyWithDefault<vector<bool>>(107, "force_not_null", force_not_null);
180: 	serializer.WritePropertyWithDefault<bool>(108, "all_varchar", all_varchar);
181: 	serializer.WritePropertyWithDefault<idx_t>(109, "sample_size_chunks", sample_size_chunks);
182: 	serializer.WritePropertyWithDefault<bool>(110, "auto_detect", auto_detect);
183: 	serializer.WritePropertyWithDefault<string>(111, "file_path", file_path);
184: 	serializer.WritePropertyWithDefault<string>(112, "decimal_separator", decimal_separator);
185: 	serializer.WritePropertyWithDefault<bool>(113, "null_padding", null_padding);
186: 	serializer.WritePropertyWithDefault<idx_t>(114, "buffer_size", buffer_size);
187: 	serializer.WriteProperty<MultiFileReaderOptions>(115, "file_options", file_options);
188: 	serializer.WritePropertyWithDefault<vector<bool>>(116, "force_quote", force_quote);
189: 	serializer.WritePropertyWithDefault<string>(117, "rejects_table_name", rejects_table_name, "reject_errors");
190: 	serializer.WritePropertyWithDefault<idx_t>(118, "rejects_limit", rejects_limit);
191: 	/* [Deleted] (vector<string>) "rejects_recovery_columns" */
192: 	/* [Deleted] (vector<idx_t>) "rejects_recovery_column_ids" */
193: 	serializer.WriteProperty<CSVOption<char>>(121, "delimiter", GetSingleByteDelimiter());
194: 	serializer.WriteProperty<CSVOption<char>>(122, "quote", dialect_options.state_machine_options.quote);
195: 	serializer.WriteProperty<CSVOption<char>>(123, "escape", dialect_options.state_machine_options.escape);
196: 	serializer.WriteProperty<CSVOption<bool>>(124, "header", dialect_options.header);
197: 	serializer.WritePropertyWithDefault<idx_t>(125, "num_cols", dialect_options.num_cols);
198: 	serializer.WriteProperty<CSVOption<NewLineIdentifier>>(126, "new_line", dialect_options.state_machine_options.new_line);
199: 	serializer.WriteProperty<CSVOption<idx_t>>(127, "skip_rows", dialect_options.skip_rows);
200: 	serializer.WriteProperty<map<LogicalTypeId, CSVOption<StrpTimeFormat>>>(128, "date_format", dialect_options.date_format);
201: 	serializer.WritePropertyWithDefault<string>(129, "sniffer_user_mismatch_error", sniffer_user_mismatch_error);
202: 	serializer.WritePropertyWithDefault<bool>(130, "parallel", parallel);
203: 	serializer.WritePropertyWithDefault<vector<bool>>(131, "was_type_manually_set", was_type_manually_set);
204: 	serializer.WritePropertyWithDefault<CSVOption<string>>(132, "rejects_scan_name", rejects_scan_name, {"reject_scans"});
205: 	serializer.WritePropertyWithDefault<vector<string>>(133, "name_list", name_list);
206: 	serializer.WritePropertyWithDefault<vector<LogicalType>>(134, "sql_type_list", sql_type_list);
207: 	serializer.WritePropertyWithDefault<case_insensitive_map_t<idx_t>>(135, "sql_types_per_column", sql_types_per_column);
208: 	serializer.WritePropertyWithDefault<bool>(136, "columns_set", columns_set, false);
209: 	serializer.WritePropertyWithDefault<CSVOption<char>>(137, "comment", dialect_options.state_machine_options.comment, CSVOption<char>('\0'));
210: 	serializer.WritePropertyWithDefault<idx_t>(138, "rows_until_header", dialect_options.rows_until_header);
211: 	serializer.WritePropertyWithDefault<string>(139, "encoding", encoding);
212: 	serializer.WriteProperty<CSVOption<bool>>(140, "rfc_4180", dialect_options.state_machine_options.rfc_4180);
213: 	serializer.WriteProperty<CSVOption<string>>(141, "multi_byte_delimiter", GetMultiByteDelimiter());
214: }
215: 
216: CSVReaderOptions CSVReaderOptions::Deserialize(Deserializer &deserializer) {
217: 	auto ignore_errors = deserializer.ReadPropertyWithExplicitDefault<bool>(100, "ignore_errors", false);
218: 	auto buffer_sample_size = deserializer.ReadPropertyWithDefault<idx_t>(101, "buffer_sample_size");
219: 	auto null_str = deserializer.ReadPropertyWithDefault<vector<string>>(102, "null_str");
220: 	auto compression = deserializer.ReadProperty<FileCompressionType>(103, "compression");
221: 	auto allow_quoted_nulls = deserializer.ReadPropertyWithDefault<bool>(104, "allow_quoted_nulls");
222: 	auto maximum_line_size = deserializer.ReadPropertyWithDefault<idx_t>(105, "maximum_line_size");
223: 	auto normalize_names = deserializer.ReadPropertyWithDefault<bool>(106, "normalize_names");
224: 	auto force_not_null = deserializer.ReadPropertyWithDefault<vector<bool>>(107, "force_not_null");
225: 	auto all_varchar = deserializer.ReadPropertyWithDefault<bool>(108, "all_varchar");
226: 	auto sample_size_chunks = deserializer.ReadPropertyWithDefault<idx_t>(109, "sample_size_chunks");
227: 	auto auto_detect = deserializer.ReadPropertyWithDefault<bool>(110, "auto_detect");
228: 	auto file_path = deserializer.ReadPropertyWithDefault<string>(111, "file_path");
229: 	auto decimal_separator = deserializer.ReadPropertyWithDefault<string>(112, "decimal_separator");
230: 	auto null_padding = deserializer.ReadPropertyWithDefault<bool>(113, "null_padding");
231: 	auto buffer_size = deserializer.ReadPropertyWithDefault<idx_t>(114, "buffer_size");
232: 	auto file_options = deserializer.ReadProperty<MultiFileReaderOptions>(115, "file_options");
233: 	auto force_quote = deserializer.ReadPropertyWithDefault<vector<bool>>(116, "force_quote");
234: 	auto rejects_table_name = deserializer.ReadPropertyWithExplicitDefault<string>(117, "rejects_table_name", "reject_errors");
235: 	auto rejects_limit = deserializer.ReadPropertyWithDefault<idx_t>(118, "rejects_limit");
236: 	deserializer.ReadDeletedProperty<vector<string>>(119, "rejects_recovery_columns");
237: 	deserializer.ReadDeletedProperty<vector<idx_t>>(120, "rejects_recovery_column_ids");
238: 	auto dialect_options_state_machine_options_delimiter = deserializer.ReadProperty<CSVOption<char>>(121, "delimiter");
239: 	auto dialect_options_state_machine_options_quote = deserializer.ReadProperty<CSVOption<char>>(122, "quote");
240: 	auto dialect_options_state_machine_options_escape = deserializer.ReadProperty<CSVOption<char>>(123, "escape");
241: 	auto dialect_options_header = deserializer.ReadProperty<CSVOption<bool>>(124, "header");
242: 	auto dialect_options_num_cols = deserializer.ReadPropertyWithDefault<idx_t>(125, "num_cols");
243: 	auto dialect_options_state_machine_options_new_line = deserializer.ReadProperty<CSVOption<NewLineIdentifier>>(126, "new_line");
244: 	auto dialect_options_skip_rows = deserializer.ReadProperty<CSVOption<idx_t>>(127, "skip_rows");
245: 	auto dialect_options_date_format = deserializer.ReadProperty<map<LogicalTypeId, CSVOption<StrpTimeFormat>>>(128, "date_format");
246: 	auto sniffer_user_mismatch_error = deserializer.ReadPropertyWithDefault<string>(129, "sniffer_user_mismatch_error");
247: 	auto parallel = deserializer.ReadPropertyWithDefault<bool>(130, "parallel");
248: 	auto was_type_manually_set = deserializer.ReadPropertyWithDefault<vector<bool>>(131, "was_type_manually_set");
249: 	auto rejects_scan_name = deserializer.ReadPropertyWithExplicitDefault<CSVOption<string>>(132, "rejects_scan_name", {"reject_scans"});
250: 	auto name_list = deserializer.ReadPropertyWithDefault<vector<string>>(133, "name_list");
251: 	auto sql_type_list = deserializer.ReadPropertyWithDefault<vector<LogicalType>>(134, "sql_type_list");
252: 	auto sql_types_per_column = deserializer.ReadPropertyWithDefault<case_insensitive_map_t<idx_t>>(135, "sql_types_per_column");
253: 	auto columns_set = deserializer.ReadPropertyWithExplicitDefault<bool>(136, "columns_set", false);
254: 	auto dialect_options_state_machine_options_comment = deserializer.ReadPropertyWithExplicitDefault<CSVOption<char>>(137, "comment", CSVOption<char>('\0'));
255: 	auto dialect_options_rows_until_header = deserializer.ReadPropertyWithDefault<idx_t>(138, "rows_until_header");
256: 	auto encoding = deserializer.ReadPropertyWithDefault<string>(139, "encoding");
257: 	auto dialect_options_state_machine_options_rfc_4180 = deserializer.ReadProperty<CSVOption<bool>>(140, "rfc_4180");
258: 	auto multi_byte_delimiter = deserializer.ReadProperty<CSVOption<string>>(141, "multi_byte_delimiter");
259: 	CSVReaderOptions result(dialect_options_state_machine_options_delimiter, multi_byte_delimiter);
260: 	result.ignore_errors = ignore_errors;
261: 	result.buffer_sample_size = buffer_sample_size;
262: 	result.null_str = std::move(null_str);
263: 	result.compression = compression;
264: 	result.allow_quoted_nulls = allow_quoted_nulls;
265: 	result.maximum_line_size = maximum_line_size;
266: 	result.normalize_names = normalize_names;
267: 	result.force_not_null = std::move(force_not_null);
268: 	result.all_varchar = all_varchar;
269: 	result.sample_size_chunks = sample_size_chunks;
270: 	result.auto_detect = auto_detect;
271: 	result.file_path = std::move(file_path);
272: 	result.decimal_separator = std::move(decimal_separator);
273: 	result.null_padding = null_padding;
274: 	result.buffer_size = buffer_size;
275: 	result.file_options = file_options;
276: 	result.force_quote = std::move(force_quote);
277: 	result.rejects_table_name = std::move(rejects_table_name);
278: 	result.rejects_limit = rejects_limit;
279: 	result.dialect_options.state_machine_options.quote = dialect_options_state_machine_options_quote;
280: 	result.dialect_options.state_machine_options.escape = dialect_options_state_machine_options_escape;
281: 	result.dialect_options.header = dialect_options_header;
282: 	result.dialect_options.num_cols = dialect_options_num_cols;
283: 	result.dialect_options.state_machine_options.new_line = dialect_options_state_machine_options_new_line;
284: 	result.dialect_options.skip_rows = dialect_options_skip_rows;
285: 	result.dialect_options.date_format = dialect_options_date_format;
286: 	result.sniffer_user_mismatch_error = std::move(sniffer_user_mismatch_error);
287: 	result.parallel = parallel;
288: 	result.was_type_manually_set = std::move(was_type_manually_set);
289: 	result.rejects_scan_name = rejects_scan_name;
290: 	result.name_list = std::move(name_list);
291: 	result.sql_type_list = std::move(sql_type_list);
292: 	result.sql_types_per_column = std::move(sql_types_per_column);
293: 	result.columns_set = columns_set;
294: 	result.dialect_options.state_machine_options.comment = dialect_options_state_machine_options_comment;
295: 	result.dialect_options.rows_until_header = dialect_options_rows_until_header;
296: 	result.encoding = std::move(encoding);
297: 	result.dialect_options.state_machine_options.rfc_4180 = dialect_options_state_machine_options_rfc_4180;
298: 	return result;
299: }
300: 
301: void CaseCheck::Serialize(Serializer &serializer) const {
302: 	serializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(100, "when_expr", when_expr);
303: 	serializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(101, "then_expr", then_expr);
304: }
305: 
306: CaseCheck CaseCheck::Deserialize(Deserializer &deserializer) {
307: 	CaseCheck result;
308: 	deserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(100, "when_expr", result.when_expr);
309: 	deserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(101, "then_expr", result.then_expr);
310: 	return result;
311: }
312: 
313: void ColumnBinding::Serialize(Serializer &serializer) const {
314: 	serializer.WritePropertyWithDefault<idx_t>(100, "table_index", table_index);
315: 	serializer.WritePropertyWithDefault<idx_t>(101, "column_index", column_index);
316: }
317: 
318: ColumnBinding ColumnBinding::Deserialize(Deserializer &deserializer) {
319: 	ColumnBinding result;
320: 	deserializer.ReadPropertyWithDefault<idx_t>(100, "table_index", result.table_index);
321: 	deserializer.ReadPropertyWithDefault<idx_t>(101, "column_index", result.column_index);
322: 	return result;
323: }
324: 
325: void ColumnDefinition::Serialize(Serializer &serializer) const {
326: 	serializer.WritePropertyWithDefault<string>(100, "name", name);
327: 	serializer.WriteProperty<LogicalType>(101, "type", type);
328: 	serializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(102, "expression", expression);
329: 	serializer.WriteProperty<TableColumnType>(103, "category", category);
330: 	serializer.WriteProperty<duckdb::CompressionType>(104, "compression_type", compression_type);
331: 	serializer.WritePropertyWithDefault<Value>(105, "comment", comment, Value());
332: 	serializer.WritePropertyWithDefault<unordered_map<string, string>>(106, "tags", tags, unordered_map<string, string>());
333: }
334: 
335: ColumnDefinition ColumnDefinition::Deserialize(Deserializer &deserializer) {
336: 	auto name = deserializer.ReadPropertyWithDefault<string>(100, "name");
337: 	auto type = deserializer.ReadProperty<LogicalType>(101, "type");
338: 	auto expression = deserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(102, "expression");
339: 	auto category = deserializer.ReadProperty<TableColumnType>(103, "category");
340: 	ColumnDefinition result(std::move(name), std::move(type), std::move(expression), category);
341: 	deserializer.ReadProperty<duckdb::CompressionType>(104, "compression_type", result.compression_type);
342: 	deserializer.ReadPropertyWithExplicitDefault<Value>(105, "comment", result.comment, Value());
343: 	deserializer.ReadPropertyWithExplicitDefault<unordered_map<string, string>>(106, "tags", result.tags, unordered_map<string, string>());
344: 	return result;
345: }
346: 
347: void ColumnIndex::Serialize(Serializer &serializer) const {
348: 	serializer.WritePropertyWithDefault<idx_t>(1, "index", index);
349: 	serializer.WritePropertyWithDefault<vector<ColumnIndex>>(2, "child_indexes", child_indexes);
350: }
351: 
352: ColumnIndex ColumnIndex::Deserialize(Deserializer &deserializer) {
353: 	ColumnIndex result;
354: 	deserializer.ReadPropertyWithDefault<idx_t>(1, "index", result.index);
355: 	deserializer.ReadPropertyWithDefault<vector<ColumnIndex>>(2, "child_indexes", result.child_indexes);
356: 	return result;
357: }
358: 
359: void ColumnInfo::Serialize(Serializer &serializer) const {
360: 	serializer.WritePropertyWithDefault<vector<string>>(100, "names", names);
361: 	serializer.WritePropertyWithDefault<vector<LogicalType>>(101, "types", types);
362: }
363: 
364: ColumnInfo ColumnInfo::Deserialize(Deserializer &deserializer) {
365: 	ColumnInfo result;
366: 	deserializer.ReadPropertyWithDefault<vector<string>>(100, "names", result.names);
367: 	deserializer.ReadPropertyWithDefault<vector<LogicalType>>(101, "types", result.types);
368: 	return result;
369: }
370: 
371: void ColumnList::Serialize(Serializer &serializer) const {
372: 	serializer.WritePropertyWithDefault<vector<ColumnDefinition>>(100, "columns", columns);
373: }
374: 
375: ColumnList ColumnList::Deserialize(Deserializer &deserializer) {
376: 	auto columns = deserializer.ReadPropertyWithDefault<vector<ColumnDefinition>>(100, "columns");
377: 	ColumnList result(std::move(columns));
378: 	return result;
379: }
380: 
381: void CommonTableExpressionInfo::Serialize(Serializer &serializer) const {
382: 	serializer.WritePropertyWithDefault<vector<string>>(100, "aliases", aliases);
383: 	serializer.WritePropertyWithDefault<unique_ptr<SelectStatement>>(101, "query", query);
384: 	serializer.WriteProperty<CTEMaterialize>(102, "materialized", materialized);
385: }
386: 
387: unique_ptr<CommonTableExpressionInfo> CommonTableExpressionInfo::Deserialize(Deserializer &deserializer) {
388: 	auto result = duckdb::unique_ptr<CommonTableExpressionInfo>(new CommonTableExpressionInfo());
389: 	deserializer.ReadPropertyWithDefault<vector<string>>(100, "aliases", result->aliases);
390: 	deserializer.ReadPropertyWithDefault<unique_ptr<SelectStatement>>(101, "query", result->query);
391: 	deserializer.ReadProperty<CTEMaterialize>(102, "materialized", result->materialized);
392: 	return result;
393: }
394: 
395: void CommonTableExpressionMap::Serialize(Serializer &serializer) const {
396: 	serializer.WritePropertyWithDefault<InsertionOrderPreservingMap<unique_ptr<CommonTableExpressionInfo>>>(100, "map", map);
397: }
398: 
399: CommonTableExpressionMap CommonTableExpressionMap::Deserialize(Deserializer &deserializer) {
400: 	CommonTableExpressionMap result;
401: 	deserializer.ReadPropertyWithDefault<InsertionOrderPreservingMap<unique_ptr<CommonTableExpressionInfo>>>(100, "map", result.map);
402: 	return result;
403: }
404: 
405: void ExportedTableData::Serialize(Serializer &serializer) const {
406: 	serializer.WritePropertyWithDefault<string>(1, "table_name", table_name);
407: 	serializer.WritePropertyWithDefault<string>(2, "schema_name", schema_name);
408: 	serializer.WritePropertyWithDefault<string>(3, "database_name", database_name);
409: 	serializer.WritePropertyWithDefault<string>(4, "file_path", file_path);
410: 	serializer.WritePropertyWithDefault<vector<string>>(5, "not_null_columns", not_null_columns);
411: }
412: 
413: ExportedTableData ExportedTableData::Deserialize(Deserializer &deserializer) {
414: 	ExportedTableData result;
415: 	deserializer.ReadPropertyWithDefault<string>(1, "table_name", result.table_name);
416: 	deserializer.ReadPropertyWithDefault<string>(2, "schema_name", result.schema_name);
417: 	deserializer.ReadPropertyWithDefault<string>(3, "database_name", result.database_name);
418: 	deserializer.ReadPropertyWithDefault<string>(4, "file_path", result.file_path);
419: 	deserializer.ReadPropertyWithDefault<vector<string>>(5, "not_null_columns", result.not_null_columns);
420: 	return result;
421: }
422: 
423: void ExportedTableInfo::Serialize(Serializer &serializer) const {
424: 	serializer.WriteProperty<ExportedTableData>(1, "table_data", table_data);
425: }
426: 
427: ExportedTableInfo ExportedTableInfo::Deserialize(Deserializer &deserializer) {
428: 	auto table_data = deserializer.ReadProperty<ExportedTableData>(1, "table_data");
429: 	ExportedTableInfo result(deserializer.Get<ClientContext &>(), table_data);
430: 	return result;
431: }
432: 
433: void HivePartitioningIndex::Serialize(Serializer &serializer) const {
434: 	serializer.WritePropertyWithDefault<string>(100, "value", value);
435: 	serializer.WritePropertyWithDefault<idx_t>(101, "index", index);
436: }
437: 
438: HivePartitioningIndex HivePartitioningIndex::Deserialize(Deserializer &deserializer) {
439: 	auto value = deserializer.ReadPropertyWithDefault<string>(100, "value");
440: 	auto index = deserializer.ReadPropertyWithDefault<idx_t>(101, "index");
441: 	HivePartitioningIndex result(std::move(value), index);
442: 	return result;
443: }
444: 
445: void JoinCondition::Serialize(Serializer &serializer) const {
446: 	serializer.WritePropertyWithDefault<unique_ptr<Expression>>(100, "left", left);
447: 	serializer.WritePropertyWithDefault<unique_ptr<Expression>>(101, "right", right);
448: 	serializer.WriteProperty<ExpressionType>(102, "comparison", comparison);
449: }
450: 
451: JoinCondition JoinCondition::Deserialize(Deserializer &deserializer) {
452: 	JoinCondition result;
453: 	deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(100, "left", result.left);
454: 	deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(101, "right", result.right);
455: 	deserializer.ReadProperty<ExpressionType>(102, "comparison", result.comparison);
456: 	return result;
457: }
458: 
459: void LogicalType::Serialize(Serializer &serializer) const {
460: 	serializer.WriteProperty<LogicalTypeId>(100, "id", id_);
461: 	serializer.WritePropertyWithDefault<shared_ptr<ExtraTypeInfo>>(101, "type_info", type_info_);
462: }
463: 
464: LogicalType LogicalType::Deserialize(Deserializer &deserializer) {
465: 	auto id = deserializer.ReadProperty<LogicalTypeId>(100, "id");
466: 	auto type_info = deserializer.ReadPropertyWithDefault<shared_ptr<ExtraTypeInfo>>(101, "type_info");
467: 	LogicalType result(id, std::move(type_info));
468: 	return result;
469: }
470: 
471: void MultiFileReaderBindData::Serialize(Serializer &serializer) const {
472: 	serializer.WritePropertyWithDefault<idx_t>(100, "filename_idx", filename_idx);
473: 	serializer.WritePropertyWithDefault<vector<HivePartitioningIndex>>(101, "hive_partitioning_indexes", hive_partitioning_indexes);
474: }
475: 
476: MultiFileReaderBindData MultiFileReaderBindData::Deserialize(Deserializer &deserializer) {
477: 	MultiFileReaderBindData result;
478: 	deserializer.ReadPropertyWithDefault<idx_t>(100, "filename_idx", result.filename_idx);
479: 	deserializer.ReadPropertyWithDefault<vector<HivePartitioningIndex>>(101, "hive_partitioning_indexes", result.hive_partitioning_indexes);
480: 	return result;
481: }
482: 
483: void MultiFileReaderOptions::Serialize(Serializer &serializer) const {
484: 	serializer.WritePropertyWithDefault<bool>(100, "filename", filename);
485: 	serializer.WritePropertyWithDefault<bool>(101, "hive_partitioning", hive_partitioning);
486: 	serializer.WritePropertyWithDefault<bool>(102, "auto_detect_hive_partitioning", auto_detect_hive_partitioning);
487: 	serializer.WritePropertyWithDefault<bool>(103, "union_by_name", union_by_name);
488: 	serializer.WritePropertyWithDefault<bool>(104, "hive_types_autocast", hive_types_autocast);
489: 	serializer.WritePropertyWithDefault<case_insensitive_map_t<LogicalType>>(105, "hive_types_schema", hive_types_schema);
490: 	serializer.WritePropertyWithDefault<string>(106, "filename_column", filename_column, MultiFileReaderOptions::DEFAULT_FILENAME_COLUMN);
491: }
492: 
493: MultiFileReaderOptions MultiFileReaderOptions::Deserialize(Deserializer &deserializer) {
494: 	MultiFileReaderOptions result;
495: 	deserializer.ReadPropertyWithDefault<bool>(100, "filename", result.filename);
496: 	deserializer.ReadPropertyWithDefault<bool>(101, "hive_partitioning", result.hive_partitioning);
497: 	deserializer.ReadPropertyWithDefault<bool>(102, "auto_detect_hive_partitioning", result.auto_detect_hive_partitioning);
498: 	deserializer.ReadPropertyWithDefault<bool>(103, "union_by_name", result.union_by_name);
499: 	deserializer.ReadPropertyWithDefault<bool>(104, "hive_types_autocast", result.hive_types_autocast);
500: 	deserializer.ReadPropertyWithDefault<case_insensitive_map_t<LogicalType>>(105, "hive_types_schema", result.hive_types_schema);
501: 	deserializer.ReadPropertyWithExplicitDefault<string>(106, "filename_column", result.filename_column, MultiFileReaderOptions::DEFAULT_FILENAME_COLUMN);
502: 	return result;
503: }
504: 
505: void OrderByNode::Serialize(Serializer &serializer) const {
506: 	serializer.WriteProperty<OrderType>(100, "type", type);
507: 	serializer.WriteProperty<OrderByNullType>(101, "null_order", null_order);
508: 	serializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(102, "expression", expression);
509: }
510: 
511: OrderByNode OrderByNode::Deserialize(Deserializer &deserializer) {
512: 	auto type = deserializer.ReadProperty<OrderType>(100, "type");
513: 	auto null_order = deserializer.ReadProperty<OrderByNullType>(101, "null_order");
514: 	auto expression = deserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(102, "expression");
515: 	OrderByNode result(type, null_order, std::move(expression));
516: 	return result;
517: }
518: 
519: void PivotColumn::Serialize(Serializer &serializer) const {
520: 	serializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(100, "pivot_expressions", pivot_expressions);
521: 	serializer.WritePropertyWithDefault<vector<string>>(101, "unpivot_names", unpivot_names);
522: 	serializer.WritePropertyWithDefault<vector<PivotColumnEntry>>(102, "entries", entries);
523: 	serializer.WritePropertyWithDefault<string>(103, "pivot_enum", pivot_enum);
524: }
525: 
526: PivotColumn PivotColumn::Deserialize(Deserializer &deserializer) {
527: 	PivotColumn result;
528: 	deserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(100, "pivot_expressions", result.pivot_expressions);
529: 	deserializer.ReadPropertyWithDefault<vector<string>>(101, "unpivot_names", result.unpivot_names);
530: 	deserializer.ReadPropertyWithDefault<vector<PivotColumnEntry>>(102, "entries", result.entries);
531: 	deserializer.ReadPropertyWithDefault<string>(103, "pivot_enum", result.pivot_enum);
532: 	return result;
533: }
534: 
535: void PivotColumnEntry::Serialize(Serializer &serializer) const {
536: 	serializer.WritePropertyWithDefault<vector<Value>>(100, "values", values);
537: 	serializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(101, "star_expr", expr);
538: 	serializer.WritePropertyWithDefault<string>(102, "alias", alias);
539: }
540: 
541: PivotColumnEntry PivotColumnEntry::Deserialize(Deserializer &deserializer) {
542: 	PivotColumnEntry result;
543: 	deserializer.ReadPropertyWithDefault<vector<Value>>(100, "values", result.values);
544: 	deserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(101, "star_expr", result.expr);
545: 	deserializer.ReadPropertyWithDefault<string>(102, "alias", result.alias);
546: 	return result;
547: }
548: 
549: void QualifiedColumnName::Serialize(Serializer &serializer) const {
550: 	serializer.WritePropertyWithDefault<string>(100, "catalog", catalog);
551: 	serializer.WritePropertyWithDefault<string>(101, "schema", schema);
552: 	serializer.WritePropertyWithDefault<string>(102, "table", table);
553: 	serializer.WritePropertyWithDefault<string>(103, "column", column);
554: }
555: 
556: QualifiedColumnName QualifiedColumnName::Deserialize(Deserializer &deserializer) {
557: 	QualifiedColumnName result;
558: 	deserializer.ReadPropertyWithDefault<string>(100, "catalog", result.catalog);
559: 	deserializer.ReadPropertyWithDefault<string>(101, "schema", result.schema);
560: 	deserializer.ReadPropertyWithDefault<string>(102, "table", result.table);
561: 	deserializer.ReadPropertyWithDefault<string>(103, "column", result.column);
562: 	return result;
563: }
564: 
565: void ReadCSVData::Serialize(Serializer &serializer) const {
566: 	serializer.WritePropertyWithDefault<vector<string>>(100, "files", files);
567: 	serializer.WritePropertyWithDefault<vector<LogicalType>>(101, "csv_types", csv_types);
568: 	serializer.WritePropertyWithDefault<vector<string>>(102, "csv_names", csv_names);
569: 	serializer.WritePropertyWithDefault<vector<LogicalType>>(103, "return_types", return_types);
570: 	serializer.WritePropertyWithDefault<vector<string>>(104, "return_names", return_names);
571: 	serializer.WritePropertyWithDefault<idx_t>(105, "filename_col_idx", filename_col_idx);
572: 	serializer.WriteProperty<CSVReaderOptions>(106, "options", options);
573: 	serializer.WriteProperty<MultiFileReaderBindData>(107, "reader_bind", reader_bind);
574: 	serializer.WritePropertyWithDefault<vector<ColumnInfo>>(108, "column_info", column_info);
575: }
576: 
577: unique_ptr<ReadCSVData> ReadCSVData::Deserialize(Deserializer &deserializer) {
578: 	auto result = duckdb::unique_ptr<ReadCSVData>(new ReadCSVData());
579: 	deserializer.ReadPropertyWithDefault<vector<string>>(100, "files", result->files);
580: 	deserializer.ReadPropertyWithDefault<vector<LogicalType>>(101, "csv_types", result->csv_types);
581: 	deserializer.ReadPropertyWithDefault<vector<string>>(102, "csv_names", result->csv_names);
582: 	deserializer.ReadPropertyWithDefault<vector<LogicalType>>(103, "return_types", result->return_types);
583: 	deserializer.ReadPropertyWithDefault<vector<string>>(104, "return_names", result->return_names);
584: 	deserializer.ReadPropertyWithDefault<idx_t>(105, "filename_col_idx", result->filename_col_idx);
585: 	deserializer.ReadProperty<CSVReaderOptions>(106, "options", result->options);
586: 	deserializer.ReadProperty<MultiFileReaderBindData>(107, "reader_bind", result->reader_bind);
587: 	deserializer.ReadPropertyWithDefault<vector<ColumnInfo>>(108, "column_info", result->column_info);
588: 	return result;
589: }
590: 
591: void ReservoirSample::Serialize(Serializer &serializer) const {
592: 	BlockingSample::Serialize(serializer);
593: 	serializer.WritePropertyWithDefault<idx_t>(200, "sample_count", sample_count);
594: 	serializer.WritePropertyWithDefault<unique_ptr<ReservoirChunk>>(201, "reservoir_chunk", reservoir_chunk);
595: }
596: 
597: unique_ptr<BlockingSample> ReservoirSample::Deserialize(Deserializer &deserializer) {
598: 	auto sample_count = deserializer.ReadPropertyWithDefault<idx_t>(200, "sample_count");
599: 	auto result = duckdb::unique_ptr<ReservoirSample>(new ReservoirSample(sample_count));
600: 	deserializer.ReadPropertyWithDefault<unique_ptr<ReservoirChunk>>(201, "reservoir_chunk", result->reservoir_chunk);
601: 	return std::move(result);
602: }
603: 
604: void ReservoirSamplePercentage::Serialize(Serializer &serializer) const {
605: 	BlockingSample::Serialize(serializer);
606: 	serializer.WriteProperty<double>(200, "sample_percentage", sample_percentage);
607: 	serializer.WritePropertyWithDefault<idx_t>(201, "reservoir_sample_size", reservoir_sample_size);
608: }
609: 
610: unique_ptr<BlockingSample> ReservoirSamplePercentage::Deserialize(Deserializer &deserializer) {
611: 	auto sample_percentage = deserializer.ReadProperty<double>(200, "sample_percentage");
612: 	auto result = duckdb::unique_ptr<ReservoirSamplePercentage>(new ReservoirSamplePercentage(sample_percentage));
613: 	deserializer.ReadPropertyWithDefault<idx_t>(201, "reservoir_sample_size", result->reservoir_sample_size);
614: 	return std::move(result);
615: }
616: 
617: void SampleOptions::Serialize(Serializer &serializer) const {
618: 	serializer.WriteProperty<Value>(100, "sample_size", sample_size);
619: 	serializer.WritePropertyWithDefault<bool>(101, "is_percentage", is_percentage);
620: 	serializer.WriteProperty<SampleMethod>(102, "method", method);
621: 	serializer.WritePropertyWithDefault<int64_t>(103, "seed", GetSeed());
622: }
623: 
624: unique_ptr<SampleOptions> SampleOptions::Deserialize(Deserializer &deserializer) {
625: 	auto sample_size = deserializer.ReadProperty<Value>(100, "sample_size");
626: 	auto is_percentage = deserializer.ReadPropertyWithDefault<bool>(101, "is_percentage");
627: 	auto method = deserializer.ReadProperty<SampleMethod>(102, "method");
628: 	auto seed = deserializer.ReadPropertyWithDefault<int64_t>(103, "seed");
629: 	auto result = duckdb::unique_ptr<SampleOptions>(new SampleOptions(seed));
630: 	result->sample_size = sample_size;
631: 	result->is_percentage = is_percentage;
632: 	result->method = method;
633: 	return result;
634: }
635: 
636: void StrpTimeFormat::Serialize(Serializer &serializer) const {
637: 	serializer.WritePropertyWithDefault<string>(100, "format_specifier", format_specifier);
638: }
639: 
640: StrpTimeFormat StrpTimeFormat::Deserialize(Deserializer &deserializer) {
641: 	auto format_specifier = deserializer.ReadPropertyWithDefault<string>(100, "format_specifier");
642: 	StrpTimeFormat result(format_specifier);
643: 	return result;
644: }
645: 
646: void TableFilterSet::Serialize(Serializer &serializer) const {
647: 	serializer.WritePropertyWithDefault<unordered_map<idx_t, unique_ptr<TableFilter>>>(100, "filters", filters);
648: }
649: 
650: TableFilterSet TableFilterSet::Deserialize(Deserializer &deserializer) {
651: 	TableFilterSet result;
652: 	deserializer.ReadPropertyWithDefault<unordered_map<idx_t, unique_ptr<TableFilter>>>(100, "filters", result.filters);
653: 	return result;
654: }
655: 
656: void VacuumOptions::Serialize(Serializer &serializer) const {
657: 	serializer.WritePropertyWithDefault<bool>(100, "vacuum", vacuum);
658: 	serializer.WritePropertyWithDefault<bool>(101, "analyze", analyze);
659: }
660: 
661: VacuumOptions VacuumOptions::Deserialize(Deserializer &deserializer) {
662: 	VacuumOptions result;
663: 	deserializer.ReadPropertyWithDefault<bool>(100, "vacuum", result.vacuum);
664: 	deserializer.ReadPropertyWithDefault<bool>(101, "analyze", result.analyze);
665: 	return result;
666: }
667: 
668: void interval_t::Serialize(Serializer &serializer) const {
669: 	serializer.WritePropertyWithDefault<int32_t>(1, "months", months);
670: 	serializer.WritePropertyWithDefault<int32_t>(2, "days", days);
671: 	serializer.WritePropertyWithDefault<int64_t>(3, "micros", micros);
672: }
673: 
674: interval_t interval_t::Deserialize(Deserializer &deserializer) {
675: 	interval_t result;
676: 	deserializer.ReadPropertyWithDefault<int32_t>(1, "months", result.months);
677: 	deserializer.ReadPropertyWithDefault<int32_t>(2, "days", result.days);
678: 	deserializer.ReadPropertyWithDefault<int64_t>(3, "micros", result.micros);
679: 	return result;
680: }
681: 
682: } // namespace duckdb
[end of src/storage/serialization/serialize_nodes.cpp]
[start of src/storage/table/row_group_collection.cpp]
1: #include "duckdb/storage/table/row_group_collection.hpp"
2: 
3: #include "duckdb/common/serializer/binary_deserializer.hpp"
4: #include "duckdb/execution/expression_executor.hpp"
5: #include "duckdb/execution/index/bound_index.hpp"
6: #include "duckdb/execution/task_error_manager.hpp"
7: #include "duckdb/main/client_context.hpp"
8: #include "duckdb/parallel/task_executor.hpp"
9: #include "duckdb/planner/constraints/bound_not_null_constraint.hpp"
10: #include "duckdb/storage/checkpoint/table_data_writer.hpp"
11: #include "duckdb/storage/data_table.hpp"
12: #include "duckdb/storage/metadata/metadata_reader.hpp"
13: #include "duckdb/storage/table/append_state.hpp"
14: #include "duckdb/storage/table/column_checkpoint_state.hpp"
15: #include "duckdb/storage/table/persistent_table_data.hpp"
16: #include "duckdb/storage/table/row_group_segment_tree.hpp"
17: #include "duckdb/storage/table/scan_state.hpp"
18: #include "duckdb/storage/table_storage_info.hpp"
19: 
20: namespace duckdb {
21: 
22: //===--------------------------------------------------------------------===//
23: // Row Group Segment Tree
24: //===--------------------------------------------------------------------===//
25: RowGroupSegmentTree::RowGroupSegmentTree(RowGroupCollection &collection)
26:     : SegmentTree<RowGroup, true>(), collection(collection), current_row_group(0), max_row_group(0) {
27: }
28: RowGroupSegmentTree::~RowGroupSegmentTree() {
29: }
30: 
31: void RowGroupSegmentTree::Initialize(PersistentTableData &data) {
32: 	D_ASSERT(data.row_group_count > 0);
33: 	current_row_group = 0;
34: 	max_row_group = data.row_group_count;
35: 	finished_loading = false;
36: 	reader = make_uniq<MetadataReader>(collection.GetMetadataManager(), data.block_pointer);
37: }
38: 
39: unique_ptr<RowGroup> RowGroupSegmentTree::LoadSegment() {
40: 	if (current_row_group >= max_row_group) {
41: 		reader.reset();
42: 		finished_loading = true;
43: 		return nullptr;
44: 	}
45: 	BinaryDeserializer deserializer(*reader);
46: 	deserializer.Begin();
47: 	auto row_group_pointer = RowGroup::Deserialize(deserializer);
48: 	deserializer.End();
49: 	current_row_group++;
50: 	return make_uniq<RowGroup>(collection, std::move(row_group_pointer));
51: }
52: 
53: //===--------------------------------------------------------------------===//
54: // Row Group Collection
55: //===--------------------------------------------------------------------===//
56: RowGroupCollection::RowGroupCollection(shared_ptr<DataTableInfo> info_p, TableIOManager &io_manager,
57:                                        vector<LogicalType> types_p, idx_t row_start, idx_t total_rows)
58:     : RowGroupCollection(std::move(info_p), io_manager.GetBlockManagerForRowData(), std::move(types_p), row_start,
59:                          total_rows, io_manager.GetRowGroupSize()) {
60: }
61: 
62: RowGroupCollection::RowGroupCollection(shared_ptr<DataTableInfo> info_p, BlockManager &block_manager,
63:                                        vector<LogicalType> types_p, idx_t row_start_p, idx_t total_rows_p,
64:                                        idx_t row_group_size_p)
65:     : block_manager(block_manager), row_group_size(row_group_size_p), total_rows(total_rows_p), info(std::move(info_p)),
66:       types(std::move(types_p)), row_start(row_start_p), allocation_size(0) {
67: 	row_groups = make_shared_ptr<RowGroupSegmentTree>(*this);
68: }
69: 
70: idx_t RowGroupCollection::GetTotalRows() const {
71: 	return total_rows.load();
72: }
73: 
74: const vector<LogicalType> &RowGroupCollection::GetTypes() const {
75: 	return types;
76: }
77: 
78: Allocator &RowGroupCollection::GetAllocator() const {
79: 	return Allocator::Get(info->GetDB());
80: }
81: 
82: AttachedDatabase &RowGroupCollection::GetAttached() {
83: 	return GetTableInfo().GetDB();
84: }
85: 
86: MetadataManager &RowGroupCollection::GetMetadataManager() {
87: 	return GetBlockManager().GetMetadataManager();
88: }
89: 
90: //===--------------------------------------------------------------------===//
91: // Initialize
92: //===--------------------------------------------------------------------===//
93: void RowGroupCollection::Initialize(PersistentTableData &data) {
94: 	D_ASSERT(this->row_start == 0);
95: 	auto l = row_groups->Lock();
96: 	this->total_rows = data.total_rows;
97: 	row_groups->Initialize(data);
98: 	stats.Initialize(types, data);
99: }
100: 
101: void RowGroupCollection::Initialize(PersistentCollectionData &data) {
102: 	stats.InitializeEmpty(types);
103: 	auto l = row_groups->Lock();
104: 	for (auto &row_group_data : data.row_group_data) {
105: 		auto row_group = make_uniq<RowGroup>(*this, row_group_data);
106: 		row_group->MergeIntoStatistics(stats);
107: 		total_rows += row_group->count;
108: 		row_groups->AppendSegment(l, std::move(row_group));
109: 	}
110: }
111: 
112: void RowGroupCollection::InitializeEmpty() {
113: 	stats.InitializeEmpty(types);
114: }
115: 
116: void RowGroupCollection::AppendRowGroup(SegmentLock &l, idx_t start_row) {
117: 	D_ASSERT(start_row >= row_start);
118: 	auto new_row_group = make_uniq<RowGroup>(*this, start_row, 0U);
119: 	new_row_group->InitializeEmpty(types);
120: 	row_groups->AppendSegment(l, std::move(new_row_group));
121: }
122: 
123: RowGroup *RowGroupCollection::GetRowGroup(int64_t index) {
124: 	return (RowGroup *)row_groups->GetSegmentByIndex(index);
125: }
126: 
127: void RowGroupCollection::Verify() {
128: #ifdef DEBUG
129: 	idx_t current_total_rows = 0;
130: 	row_groups->Verify();
131: 	for (auto &row_group : row_groups->Segments()) {
132: 		row_group.Verify();
133: 		D_ASSERT(&row_group.GetCollection() == this);
134: 		D_ASSERT(row_group.start == this->row_start + current_total_rows);
135: 		current_total_rows += row_group.count;
136: 	}
137: 	D_ASSERT(current_total_rows == total_rows.load());
138: #endif
139: }
140: 
141: //===--------------------------------------------------------------------===//
142: // Scan
143: //===--------------------------------------------------------------------===//
144: void RowGroupCollection::InitializeScan(CollectionScanState &state, const vector<StorageIndex> &column_ids,
145:                                         TableFilterSet *table_filters) {
146: 	auto row_group = row_groups->GetRootSegment();
147: 	D_ASSERT(row_group);
148: 	state.row_groups = row_groups.get();
149: 	state.max_row = row_start + total_rows;
150: 	state.Initialize(GetTypes());
151: 	while (row_group && !row_group->InitializeScan(state)) {
152: 		row_group = row_groups->GetNextSegment(row_group);
153: 	}
154: }
155: 
156: void RowGroupCollection::InitializeCreateIndexScan(CreateIndexScanState &state) {
157: 	state.segment_lock = row_groups->Lock();
158: }
159: 
160: void RowGroupCollection::InitializeScanWithOffset(CollectionScanState &state, const vector<StorageIndex> &column_ids,
161:                                                   idx_t start_row, idx_t end_row) {
162: 	auto row_group = row_groups->GetSegment(start_row);
163: 	D_ASSERT(row_group);
164: 	state.row_groups = row_groups.get();
165: 	state.max_row = end_row;
166: 	state.Initialize(GetTypes());
167: 	idx_t start_vector = (start_row - row_group->start) / STANDARD_VECTOR_SIZE;
168: 	if (!row_group->InitializeScanWithOffset(state, start_vector)) {
169: 		throw InternalException("Failed to initialize row group scan with offset");
170: 	}
171: }
172: 
173: bool RowGroupCollection::InitializeScanInRowGroup(CollectionScanState &state, RowGroupCollection &collection,
174:                                                   RowGroup &row_group, idx_t vector_index, idx_t max_row) {
175: 	state.max_row = max_row;
176: 	state.row_groups = collection.row_groups.get();
177: 	if (!state.column_scans) {
178: 		// initialize the scan state
179: 		state.Initialize(collection.GetTypes());
180: 	}
181: 	return row_group.InitializeScanWithOffset(state, vector_index);
182: }
183: 
184: void RowGroupCollection::InitializeParallelScan(ParallelCollectionScanState &state) {
185: 	state.collection = this;
186: 	state.current_row_group = row_groups->GetRootSegment();
187: 	state.vector_index = 0;
188: 	state.max_row = row_start + total_rows;
189: 	state.batch_index = 0;
190: 	state.processed_rows = 0;
191: }
192: 
193: bool RowGroupCollection::NextParallelScan(ClientContext &context, ParallelCollectionScanState &state,
194:                                           CollectionScanState &scan_state) {
195: 	while (true) {
196: 		idx_t vector_index;
197: 		idx_t max_row;
198: 		RowGroupCollection *collection;
199: 		RowGroup *row_group;
200: 		{
201: 			// select the next row group to scan from the parallel state
202: 			lock_guard<mutex> l(state.lock);
203: 			if (!state.current_row_group || state.current_row_group->count == 0) {
204: 				// no more data left to scan
205: 				break;
206: 			}
207: 			collection = state.collection;
208: 			row_group = state.current_row_group;
209: 			if (ClientConfig::GetConfig(context).verify_parallelism) {
210: 				vector_index = state.vector_index;
211: 				max_row = state.current_row_group->start +
212: 				          MinValue<idx_t>(state.current_row_group->count,
213: 				                          STANDARD_VECTOR_SIZE * state.vector_index + STANDARD_VECTOR_SIZE);
214: 				D_ASSERT(vector_index * STANDARD_VECTOR_SIZE < state.current_row_group->count);
215: 				state.vector_index++;
216: 				if (state.vector_index * STANDARD_VECTOR_SIZE >= state.current_row_group->count) {
217: 					state.current_row_group = row_groups->GetNextSegment(state.current_row_group);
218: 					state.vector_index = 0;
219: 				}
220: 			} else {
221: 				state.processed_rows += state.current_row_group->count;
222: 				vector_index = 0;
223: 				max_row = state.current_row_group->start + state.current_row_group->count;
224: 				state.current_row_group = row_groups->GetNextSegment(state.current_row_group);
225: 			}
226: 			max_row = MinValue<idx_t>(max_row, state.max_row);
227: 			scan_state.batch_index = ++state.batch_index;
228: 		}
229: 		D_ASSERT(collection);
230: 		D_ASSERT(row_group);
231: 
232: 		// initialize the scan for this row group
233: 		bool need_to_scan = InitializeScanInRowGroup(scan_state, *collection, *row_group, vector_index, max_row);
234: 		if (!need_to_scan) {
235: 			// skip this row group
236: 			continue;
237: 		}
238: 		return true;
239: 	}
240: 	lock_guard<mutex> l(state.lock);
241: 	scan_state.batch_index = state.batch_index;
242: 	return false;
243: }
244: 
245: bool RowGroupCollection::Scan(DuckTransaction &transaction, const vector<StorageIndex> &column_ids,
246:                               const std::function<bool(DataChunk &chunk)> &fun) {
247: 	vector<LogicalType> scan_types;
248: 	for (idx_t i = 0; i < column_ids.size(); i++) {
249: 		scan_types.push_back(types[column_ids[i].GetPrimaryIndex()]);
250: 	}
251: 	DataChunk chunk;
252: 	chunk.Initialize(GetAllocator(), scan_types);
253: 
254: 	// initialize the scan
255: 	TableScanState state;
256: 	state.Initialize(column_ids, nullptr);
257: 	InitializeScan(state.local_state, column_ids, nullptr);
258: 
259: 	while (true) {
260: 		chunk.Reset();
261: 		state.local_state.Scan(transaction, chunk);
262: 		if (chunk.size() == 0) {
263: 			return true;
264: 		}
265: 		if (!fun(chunk)) {
266: 			return false;
267: 		}
268: 	}
269: }
270: 
271: bool RowGroupCollection::Scan(DuckTransaction &transaction, const std::function<bool(DataChunk &chunk)> &fun) {
272: 	vector<StorageIndex> column_ids;
273: 	column_ids.reserve(types.size());
274: 	for (idx_t i = 0; i < types.size(); i++) {
275: 		column_ids.emplace_back(i);
276: 	}
277: 	return Scan(transaction, column_ids, fun);
278: }
279: 
280: //===--------------------------------------------------------------------===//
281: // Fetch
282: //===--------------------------------------------------------------------===//
283: void RowGroupCollection::Fetch(TransactionData transaction, DataChunk &result, const vector<StorageIndex> &column_ids,
284:                                const Vector &row_identifiers, idx_t fetch_count, ColumnFetchState &state) {
285: 	// figure out which row_group to fetch from
286: 	auto row_ids = FlatVector::GetData<row_t>(row_identifiers);
287: 	idx_t count = 0;
288: 	for (idx_t i = 0; i < fetch_count; i++) {
289: 		auto row_id = row_ids[i];
290: 		RowGroup *row_group;
291: 		{
292: 			idx_t segment_index;
293: 			auto l = row_groups->Lock();
294: 			if (!row_groups->TryGetSegmentIndex(l, UnsafeNumericCast<idx_t>(row_id), segment_index)) {
295: 				// in parallel append scenarios it is possible for the row_id
296: 				continue;
297: 			}
298: 			row_group = row_groups->GetSegmentByIndex(l, UnsafeNumericCast<int64_t>(segment_index));
299: 		}
300: 		if (!row_group->Fetch(transaction, UnsafeNumericCast<idx_t>(row_id) - row_group->start)) {
301: 			continue;
302: 		}
303: 		row_group->FetchRow(transaction, state, column_ids, row_id, result, count);
304: 		count++;
305: 	}
306: 	result.SetCardinality(count);
307: }
308: 
309: //===--------------------------------------------------------------------===//
310: // Append
311: //===--------------------------------------------------------------------===//
312: TableAppendState::TableAppendState()
313:     : row_group_append_state(*this), total_append_count(0), start_row_group(nullptr), transaction(0, 0),
314:       hashes(LogicalType::HASH) {
315: }
316: 
317: TableAppendState::~TableAppendState() {
318: }
319: 
320: bool RowGroupCollection::IsEmpty() const {
321: 	auto l = row_groups->Lock();
322: 	return IsEmpty(l);
323: }
324: 
325: bool RowGroupCollection::IsEmpty(SegmentLock &l) const {
326: 	return row_groups->IsEmpty(l);
327: }
328: 
329: void RowGroupCollection::InitializeAppend(TransactionData transaction, TableAppendState &state) {
330: 	state.row_start = UnsafeNumericCast<row_t>(total_rows.load());
331: 	state.current_row = state.row_start;
332: 	state.total_append_count = 0;
333: 
334: 	// start writing to the row_groups
335: 	auto l = row_groups->Lock();
336: 	if (IsEmpty(l)) {
337: 		// empty row group collection: empty first row group
338: 		AppendRowGroup(l, row_start);
339: 	}
340: 	state.start_row_group = row_groups->GetLastSegment(l);
341: 	D_ASSERT(this->row_start + total_rows == state.start_row_group->start + state.start_row_group->count);
342: 	state.start_row_group->InitializeAppend(state.row_group_append_state);
343: 	state.transaction = transaction;
344: 
345: 	// initialize thread-local stats so we have less lock contention when updating distinct statistics
346: 	state.stats = TableStatistics();
347: 	state.stats.InitializeEmpty(types);
348: }
349: 
350: void RowGroupCollection::InitializeAppend(TableAppendState &state) {
351: 	TransactionData tdata(0, 0);
352: 	InitializeAppend(tdata, state);
353: }
354: 
355: bool RowGroupCollection::Append(DataChunk &chunk, TableAppendState &state) {
356: 	const idx_t row_group_size = GetRowGroupSize();
357: 	D_ASSERT(chunk.ColumnCount() == types.size());
358: 	chunk.Verify();
359: 
360: 	bool new_row_group = false;
361: 	idx_t total_append_count = chunk.size();
362: 	idx_t remaining = chunk.size();
363: 	state.total_append_count += total_append_count;
364: 	while (true) {
365: 		auto current_row_group = state.row_group_append_state.row_group;
366: 		// check how much we can fit into the current row_group
367: 		idx_t append_count =
368: 		    MinValue<idx_t>(remaining, row_group_size - state.row_group_append_state.offset_in_row_group);
369: 		if (append_count > 0) {
370: 			auto previous_allocation_size = current_row_group->GetAllocationSize();
371: 			current_row_group->Append(state.row_group_append_state, chunk, append_count);
372: 			allocation_size += current_row_group->GetAllocationSize() - previous_allocation_size;
373: 			// merge the stats
374: 			current_row_group->MergeIntoStatistics(stats);
375: 		}
376: 		remaining -= append_count;
377: 		if (remaining > 0) {
378: 			// we expect max 1 iteration of this loop (i.e. a single chunk should never overflow more than one
379: 			// row_group)
380: 			D_ASSERT(chunk.size() == remaining + append_count);
381: 			// slice the input chunk
382: 			if (remaining < chunk.size()) {
383: 				chunk.Slice(append_count, remaining);
384: 			}
385: 			// append a new row_group
386: 			new_row_group = true;
387: 			auto next_start = current_row_group->start + state.row_group_append_state.offset_in_row_group;
388: 
389: 			auto l = row_groups->Lock();
390: 			AppendRowGroup(l, next_start);
391: 			// set up the append state for this row_group
392: 			auto last_row_group = row_groups->GetLastSegment(l);
393: 			last_row_group->InitializeAppend(state.row_group_append_state);
394: 			continue;
395: 		} else {
396: 			break;
397: 		}
398: 	}
399: 	state.current_row += row_t(total_append_count);
400: 	auto local_stats_lock = state.stats.GetLock();
401: 	for (idx_t col_idx = 0; col_idx < types.size(); col_idx++) {
402: 		auto &column_stats = state.stats.GetStats(*local_stats_lock, col_idx);
403: 		column_stats.UpdateDistinctStatistics(chunk.data[col_idx], chunk.size(), state.hashes);
404: 	}
405: 	return new_row_group;
406: }
407: 
408: void RowGroupCollection::FinalizeAppend(TransactionData transaction, TableAppendState &state) {
409: 	const idx_t row_group_size = GetRowGroupSize();
410: 
411: 	auto remaining = state.total_append_count;
412: 	auto row_group = state.start_row_group;
413: 	while (remaining > 0) {
414: 		auto append_count = MinValue<idx_t>(remaining, row_group_size - row_group->count);
415: 		row_group->AppendVersionInfo(transaction, append_count);
416: 		remaining -= append_count;
417: 		row_group = row_groups->GetNextSegment(row_group);
418: 	}
419: 	total_rows += state.total_append_count;
420: 
421: 	state.total_append_count = 0;
422: 	state.start_row_group = nullptr;
423: 
424: 	auto global_stats_lock = stats.GetLock();
425: 	auto local_stats_lock = state.stats.GetLock();
426: 	for (idx_t col_idx = 0; col_idx < types.size(); col_idx++) {
427: 		auto &global_stats = stats.GetStats(*global_stats_lock, col_idx);
428: 		if (!global_stats.HasDistinctStats()) {
429: 			continue;
430: 		}
431: 		auto &local_stats = state.stats.GetStats(*local_stats_lock, col_idx);
432: 		if (!local_stats.HasDistinctStats()) {
433: 			continue;
434: 		}
435: 		global_stats.DistinctStats().Merge(local_stats.DistinctStats());
436: 	}
437: 
438: 	Verify();
439: }
440: 
441: void RowGroupCollection::CommitAppend(transaction_t commit_id, idx_t row_start, idx_t count) {
442: 	auto row_group = row_groups->GetSegment(row_start);
443: 	D_ASSERT(row_group);
444: 	idx_t current_row = row_start;
445: 	idx_t remaining = count;
446: 	while (true) {
447: 		idx_t start_in_row_group = current_row - row_group->start;
448: 		idx_t append_count = MinValue<idx_t>(row_group->count - start_in_row_group, remaining);
449: 
450: 		row_group->CommitAppend(commit_id, start_in_row_group, append_count);
451: 
452: 		current_row += append_count;
453: 		remaining -= append_count;
454: 		if (remaining == 0) {
455: 			break;
456: 		}
457: 		row_group = row_groups->GetNextSegment(row_group);
458: 	}
459: }
460: 
461: void RowGroupCollection::RevertAppendInternal(idx_t start_row) {
462: 	total_rows = start_row;
463: 
464: 	auto l = row_groups->Lock();
465: 	idx_t segment_count = row_groups->GetSegmentCount(l);
466: 	if (segment_count == 0) {
467: 		// we have no segments to revert
468: 		return;
469: 	}
470: 	idx_t segment_index;
471: 	// find the segment index that the start row belongs to
472: 	if (!row_groups->TryGetSegmentIndex(l, start_row, segment_index)) {
473: 		// revert from the last segment
474: 		segment_index = segment_count - 1;
475: 	}
476: 	auto &segment = *row_groups->GetSegmentByIndex(l, UnsafeNumericCast<int64_t>(segment_index));
477: 
478: 	// remove any segments AFTER this segment: they should be deleted entirely
479: 	row_groups->EraseSegments(l, segment_index);
480: 
481: 	segment.next = nullptr;
482: 	segment.RevertAppend(start_row);
483: }
484: 
485: void RowGroupCollection::CleanupAppend(transaction_t lowest_transaction, idx_t start, idx_t count) {
486: 	auto row_group = row_groups->GetSegment(start);
487: 	D_ASSERT(row_group);
488: 	idx_t current_row = start;
489: 	idx_t remaining = count;
490: 	while (true) {
491: 		idx_t start_in_row_group = current_row - row_group->start;
492: 		idx_t append_count = MinValue<idx_t>(row_group->count - start_in_row_group, remaining);
493: 
494: 		row_group->CleanupAppend(lowest_transaction, start_in_row_group, append_count);
495: 
496: 		current_row += append_count;
497: 		remaining -= append_count;
498: 		if (remaining == 0) {
499: 			break;
500: 		}
501: 		row_group = row_groups->GetNextSegment(row_group);
502: 	}
503: }
504: 
505: bool RowGroupCollection::IsPersistent() const {
506: 	for (auto &row_group : row_groups->Segments()) {
507: 		if (!row_group.IsPersistent()) {
508: 			return false;
509: 		}
510: 	}
511: 	return true;
512: }
513: 
514: void RowGroupCollection::MergeStorage(RowGroupCollection &data, optional_ptr<DataTable> table,
515:                                       optional_ptr<StorageCommitState> commit_state) {
516: 	D_ASSERT(data.types == types);
517: 	auto start_index = row_start + total_rows.load();
518: 	auto index = start_index;
519: 	auto segments = data.row_groups->MoveSegments();
520: 
521: 	// check if the row groups we are merging are optimistically written
522: 	// if all row groups are optimistically written we keep around the block pointers
523: 	unique_ptr<PersistentCollectionData> row_group_data;
524: 	idx_t optimistically_written_count = 0;
525: 	if (commit_state) {
526: 		for (auto &entry : segments) {
527: 			auto &row_group = *entry.node;
528: 			if (!row_group.IsPersistent()) {
529: 				break;
530: 			}
531: 			optimistically_written_count += row_group.count;
532: 		}
533: 		if (optimistically_written_count > 0) {
534: 			row_group_data = make_uniq<PersistentCollectionData>();
535: 		}
536: 	}
537: 	for (auto &entry : segments) {
538: 		auto &row_group = entry.node;
539: 		row_group->MoveToCollection(*this, index);
540: 
541: 		if (commit_state && (index - start_index) < optimistically_written_count) {
542: 			// serialize the block pointers of this row group
543: 			auto persistent_data = row_group->SerializeRowGroupInfo();
544: 			persistent_data.types = types;
545: 			row_group_data->row_group_data.push_back(std::move(persistent_data));
546: 		}
547: 		index += row_group->count;
548: 		row_groups->AppendSegment(std::move(row_group));
549: 	}
550: 	if (commit_state && optimistically_written_count > 0) {
551: 		// if we have serialized the row groups - push the serialized block pointers into the commit state
552: 		commit_state->AddRowGroupData(*table, start_index, optimistically_written_count, std::move(row_group_data));
553: 	}
554: 	stats.MergeStats(data.stats);
555: 	total_rows += data.total_rows.load();
556: }
557: 
558: //===--------------------------------------------------------------------===//
559: // Delete
560: //===--------------------------------------------------------------------===//
561: idx_t RowGroupCollection::Delete(TransactionData transaction, DataTable &table, row_t *ids, idx_t count) {
562: 	idx_t delete_count = 0;
563: 	// delete is in the row groups
564: 	// we need to figure out for each id to which row group it belongs
565: 	// usually all (or many) ids belong to the same row group
566: 	// we iterate over the ids and check for every id if it belongs to the same row group as their predecessor
567: 	idx_t pos = 0;
568: 	do {
569: 		idx_t start = pos;
570: 		auto row_group = row_groups->GetSegment(UnsafeNumericCast<idx_t>(ids[start]));
571: 		for (pos++; pos < count; pos++) {
572: 			D_ASSERT(ids[pos] >= 0);
573: 			// check if this id still belongs to this row group
574: 			if (idx_t(ids[pos]) < row_group->start) {
575: 				// id is before row_group start -> it does not
576: 				break;
577: 			}
578: 			if (idx_t(ids[pos]) >= row_group->start + row_group->count) {
579: 				// id is after row group end -> it does not
580: 				break;
581: 			}
582: 		}
583: 		delete_count += row_group->Delete(transaction, table, ids + start, pos - start);
584: 	} while (pos < count);
585: 	return delete_count;
586: }
587: 
588: //===--------------------------------------------------------------------===//
589: // Update
590: //===--------------------------------------------------------------------===//
591: void RowGroupCollection::Update(TransactionData transaction, row_t *ids, const vector<PhysicalIndex> &column_ids,
592:                                 DataChunk &updates) {
593: 	idx_t pos = 0;
594: 	do {
595: 		idx_t start = pos;
596: 		auto row_group = row_groups->GetSegment(UnsafeNumericCast<idx_t>(ids[pos]));
597: 		row_t base_id =
598: 		    UnsafeNumericCast<row_t>(row_group->start + ((UnsafeNumericCast<idx_t>(ids[pos]) - row_group->start) /
599: 		                                                 STANDARD_VECTOR_SIZE * STANDARD_VECTOR_SIZE));
600: 		auto max_id = MinValue<row_t>(base_id + STANDARD_VECTOR_SIZE,
601: 		                              UnsafeNumericCast<row_t>(row_group->start + row_group->count));
602: 		for (pos++; pos < updates.size(); pos++) {
603: 			D_ASSERT(ids[pos] >= 0);
604: 			// check if this id still belongs to this vector in this row group
605: 			if (ids[pos] < base_id) {
606: 				// id is before vector start -> it does not
607: 				break;
608: 			}
609: 			if (ids[pos] >= max_id) {
610: 				// id is after the maximum id in this vector -> it does not
611: 				break;
612: 			}
613: 		}
614: 		row_group->Update(transaction, updates, ids, start, pos - start, column_ids);
615: 
616: 		auto l = stats.GetLock();
617: 		for (idx_t i = 0; i < column_ids.size(); i++) {
618: 			auto column_id = column_ids[i];
619: 			stats.MergeStats(*l, column_id.index, *row_group->GetStatistics(column_id.index));
620: 		}
621: 	} while (pos < updates.size());
622: }
623: 
624: void RowGroupCollection::RemoveFromIndexes(TableIndexList &indexes, Vector &row_identifiers, idx_t count) {
625: 	auto row_ids = FlatVector::GetData<row_t>(row_identifiers);
626: 
627: 	// initialize the fetch state
628: 	// FIXME: we do not need to fetch all columns, only the columns required by the indices!
629: 	TableScanState state;
630: 	vector<StorageIndex> column_ids;
631: 	column_ids.reserve(types.size());
632: 	for (idx_t i = 0; i < types.size(); i++) {
633: 		column_ids.emplace_back(i);
634: 	}
635: 	state.Initialize(std::move(column_ids));
636: 	state.table_state.max_row = row_start + total_rows;
637: 
638: 	// initialize the fetch chunk
639: 	DataChunk result;
640: 	result.Initialize(GetAllocator(), types);
641: 
642: 	SelectionVector sel(STANDARD_VECTOR_SIZE);
643: 	// now iterate over the row ids
644: 	for (idx_t r = 0; r < count;) {
645: 		result.Reset();
646: 		// figure out which row_group to fetch from
647: 		auto row_id = row_ids[r];
648: 		auto row_group = row_groups->GetSegment(UnsafeNumericCast<idx_t>(row_id));
649: 		auto row_group_vector_idx = (UnsafeNumericCast<idx_t>(row_id) - row_group->start) / STANDARD_VECTOR_SIZE;
650: 		auto base_row_id = row_group_vector_idx * STANDARD_VECTOR_SIZE + row_group->start;
651: 
652: 		// fetch the current vector
653: 		state.table_state.Initialize(GetTypes());
654: 		row_group->InitializeScanWithOffset(state.table_state, row_group_vector_idx);
655: 		row_group->ScanCommitted(state.table_state, result, TableScanType::TABLE_SCAN_COMMITTED_ROWS);
656: 		result.Verify();
657: 
658: 		// check for any remaining row ids if they also fall into this vector
659: 		// we try to fetch handle as many rows as possible at the same time
660: 		idx_t sel_count = 0;
661: 		for (; r < count; r++) {
662: 			idx_t current_row = idx_t(row_ids[r]);
663: 			if (current_row < base_row_id || current_row >= base_row_id + result.size()) {
664: 				// this row-id does not fall into the current chunk - break
665: 				break;
666: 			}
667: 			auto row_in_vector = current_row - base_row_id;
668: 			D_ASSERT(row_in_vector < result.size());
669: 			sel.set_index(sel_count++, row_in_vector);
670: 		}
671: 		D_ASSERT(sel_count > 0);
672: 		// slice the vector with all rows that are present in this vector and erase from the index
673: 		result.Slice(sel, sel_count);
674: 
675: 		indexes.Scan([&](Index &index) {
676: 			if (index.IsBound()) {
677: 				index.Cast<BoundIndex>().Delete(result, row_identifiers);
678: 			} else {
679: 				throw MissingExtensionException(
680: 				    "Cannot delete from index '%s', unknown index type '%s'. You need to load the "
681: 				    "extension that provides this index type before table '%s' can be modified.",
682: 				    index.GetIndexName(), index.GetIndexType(), info->GetTableName());
683: 			}
684: 			return false;
685: 		});
686: 	}
687: }
688: 
689: void RowGroupCollection::UpdateColumn(TransactionData transaction, Vector &row_ids, const vector<column_t> &column_path,
690:                                       DataChunk &updates) {
691: 	auto first_id = FlatVector::GetValue<row_t>(row_ids, 0);
692: 	if (first_id >= MAX_ROW_ID) {
693: 		throw NotImplementedException("Cannot update a column-path on transaction local data");
694: 	}
695: 	// find the row_group this id belongs to
696: 	auto primary_column_idx = column_path[0];
697: 	auto row_group = row_groups->GetSegment(UnsafeNumericCast<idx_t>(first_id));
698: 	row_group->UpdateColumn(transaction, updates, row_ids, column_path);
699: 
700: 	auto lock = stats.GetLock();
701: 	row_group->MergeIntoStatistics(primary_column_idx, stats.GetStats(*lock, primary_column_idx).Statistics());
702: }
703: 
704: //===--------------------------------------------------------------------===//
705: // Checkpoint State
706: //===--------------------------------------------------------------------===//
707: struct CollectionCheckpointState {
708: 	CollectionCheckpointState(RowGroupCollection &collection, TableDataWriter &writer,
709: 	                          vector<SegmentNode<RowGroup>> &segments, TableStatistics &global_stats)
710: 	    : collection(collection), writer(writer), executor(writer.GetScheduler()), segments(segments),
711: 	      global_stats(global_stats) {
712: 		writers.resize(segments.size());
713: 		write_data.resize(segments.size());
714: 	}
715: 
716: 	RowGroupCollection &collection;
717: 	TableDataWriter &writer;
718: 	TaskExecutor executor;
719: 	vector<SegmentNode<RowGroup>> &segments;
720: 	vector<unique_ptr<RowGroupWriter>> writers;
721: 	vector<RowGroupWriteData> write_data;
722: 	TableStatistics &global_stats;
723: 	mutex write_lock;
724: };
725: 
726: class BaseCheckpointTask : public BaseExecutorTask {
727: public:
728: 	explicit BaseCheckpointTask(CollectionCheckpointState &checkpoint_state)
729: 	    : BaseExecutorTask(checkpoint_state.executor), checkpoint_state(checkpoint_state) {
730: 	}
731: 
732: protected:
733: 	CollectionCheckpointState &checkpoint_state;
734: };
735: 
736: class CheckpointTask : public BaseCheckpointTask {
737: public:
738: 	CheckpointTask(CollectionCheckpointState &checkpoint_state, idx_t index)
739: 	    : BaseCheckpointTask(checkpoint_state), index(index) {
740: 	}
741: 
742: 	void ExecuteTask() override {
743: 		auto &entry = checkpoint_state.segments[index];
744: 		auto &row_group = *entry.node;
745: 		checkpoint_state.writers[index] = checkpoint_state.writer.GetRowGroupWriter(*entry.node);
746: 		checkpoint_state.write_data[index] = row_group.WriteToDisk(*checkpoint_state.writers[index]);
747: 	}
748: 
749: private:
750: 	idx_t index;
751: };
752: 
753: //===--------------------------------------------------------------------===//
754: // Vacuum
755: //===--------------------------------------------------------------------===//
756: struct VacuumState {
757: 	bool can_vacuum_deletes = false;
758: 	idx_t row_start = 0;
759: 	idx_t next_vacuum_idx = 0;
760: 	vector<idx_t> row_group_counts;
761: };
762: 
763: class VacuumTask : public BaseCheckpointTask {
764: public:
765: 	VacuumTask(CollectionCheckpointState &checkpoint_state, VacuumState &vacuum_state, idx_t segment_idx,
766: 	           idx_t merge_count, idx_t target_count, idx_t merge_rows, idx_t row_start)
767: 	    : BaseCheckpointTask(checkpoint_state), vacuum_state(vacuum_state), segment_idx(segment_idx),
768: 	      merge_count(merge_count), target_count(target_count), merge_rows(merge_rows), row_start(row_start) {
769: 	}
770: 
771: 	void ExecuteTask() override {
772: 		auto &collection = checkpoint_state.collection;
773: 		const idx_t row_group_size = collection.GetRowGroupSize();
774: 		auto &types = collection.GetTypes();
775: 		// create the new set of target row groups (initially empty)
776: 		vector<unique_ptr<RowGroup>> new_row_groups;
777: 		vector<idx_t> append_counts;
778: 		idx_t row_group_rows = merge_rows;
779: 		idx_t start = row_start;
780: 		for (idx_t target_idx = 0; target_idx < target_count; target_idx++) {
781: 			idx_t current_row_group_rows = MinValue<idx_t>(row_group_rows, row_group_size);
782: 			auto new_row_group = make_uniq<RowGroup>(collection, start, current_row_group_rows);
783: 			new_row_group->InitializeEmpty(types);
784: 			new_row_groups.push_back(std::move(new_row_group));
785: 			append_counts.push_back(0);
786: 
787: 			row_group_rows -= current_row_group_rows;
788: 			start += current_row_group_rows;
789: 		}
790: 
791: 		DataChunk scan_chunk;
792: 		scan_chunk.Initialize(Allocator::DefaultAllocator(), types);
793: 
794: 		vector<StorageIndex> column_ids;
795: 		for (idx_t c = 0; c < types.size(); c++) {
796: 			column_ids.emplace_back(c);
797: 		}
798: 
799: 		idx_t current_append_idx = 0;
800: 
801: 		// fill the new row group with the merged rows
802: 		TableAppendState append_state;
803: 		new_row_groups[current_append_idx]->InitializeAppend(append_state.row_group_append_state);
804: 
805: 		TableScanState scan_state;
806: 		scan_state.Initialize(column_ids);
807: 		scan_state.table_state.Initialize(types);
808: 		scan_state.table_state.max_row = idx_t(-1);
809: 		idx_t merged_groups = 0;
810: 		idx_t total_row_groups = vacuum_state.row_group_counts.size();
811: 		for (idx_t c_idx = segment_idx; merged_groups < merge_count && c_idx < total_row_groups; c_idx++) {
812: 			if (vacuum_state.row_group_counts[c_idx] == 0) {
813: 				continue;
814: 			}
815: 			merged_groups++;
816: 
817: 			auto &current_row_group = *checkpoint_state.segments[c_idx].node;
818: 
819: 			current_row_group.InitializeScan(scan_state.table_state);
820: 			while (true) {
821: 				scan_chunk.Reset();
822: 
823: 				current_row_group.ScanCommitted(scan_state.table_state, scan_chunk,
824: 				                                TableScanType::TABLE_SCAN_LATEST_COMMITTED_ROWS);
825: 				if (scan_chunk.size() == 0) {
826: 					break;
827: 				}
828: 				scan_chunk.Flatten();
829: 				idx_t remaining = scan_chunk.size();
830: 				while (remaining > 0) {
831: 					idx_t append_count = MinValue<idx_t>(remaining, row_group_size - append_counts[current_append_idx]);
832: 					new_row_groups[current_append_idx]->Append(append_state.row_group_append_state, scan_chunk,
833: 					                                           append_count);
834: 					append_counts[current_append_idx] += append_count;
835: 					remaining -= append_count;
836: 					const bool row_group_full = append_counts[current_append_idx] == row_group_size;
837: 					const bool last_row_group = current_append_idx + 1 >= new_row_groups.size();
838: 					if (remaining > 0 || (row_group_full && !last_row_group)) {
839: 						// move to the next row group
840: 						current_append_idx++;
841: 						new_row_groups[current_append_idx]->InitializeAppend(append_state.row_group_append_state);
842: 						// slice chunk for the next append
843: 						scan_chunk.Slice(append_count, remaining);
844: 					}
845: 				}
846: 			}
847: 			// drop the row group after merging
848: 			current_row_group.CommitDrop();
849: 			checkpoint_state.segments[c_idx].node.reset();
850: 		}
851: 		idx_t total_append_count = 0;
852: 		for (idx_t target_idx = 0; target_idx < target_count; target_idx++) {
853: 			auto &row_group = new_row_groups[target_idx];
854: 			row_group->Verify();
855: 
856: 			// assign the new row group to the current segment
857: 			checkpoint_state.segments[segment_idx + target_idx].node = std::move(row_group);
858: 			total_append_count += append_counts[target_idx];
859: 		}
860: 		if (total_append_count != merge_rows) {
861: 			throw InternalException("Mismatch in row group count vs verify count in RowGroupCollection::Checkpoint");
862: 		}
863: 		// merging is complete - execute checkpoint tasks of the target row groups
864: 		for (idx_t i = 0; i < target_count; i++) {
865: 			auto checkpoint_task = collection.GetCheckpointTask(checkpoint_state, segment_idx + i);
866: 			checkpoint_task->ExecuteTask();
867: 		}
868: 	}
869: 
870: private:
871: 	VacuumState &vacuum_state;
872: 	idx_t segment_idx;
873: 	idx_t merge_count;
874: 	idx_t target_count;
875: 	idx_t merge_rows;
876: 	idx_t row_start;
877: };
878: 
879: void RowGroupCollection::InitializeVacuumState(CollectionCheckpointState &checkpoint_state, VacuumState &state,
880:                                                vector<SegmentNode<RowGroup>> &segments) {
881: 	bool is_full_checkpoint = checkpoint_state.writer.GetCheckpointType() == CheckpointType::FULL_CHECKPOINT;
882: 	// currently we can only vacuum deletes if we are doing a full checkpoint and there are no indexes
883: 	state.can_vacuum_deletes = info->GetIndexes().Empty() && is_full_checkpoint;
884: 	if (!state.can_vacuum_deletes) {
885: 		return;
886: 	}
887: 	// obtain the set of committed row counts for each row group
888: 	state.row_group_counts.reserve(segments.size());
889: 	for (auto &entry : segments) {
890: 		auto &row_group = *entry.node;
891: 		auto row_group_count = row_group.GetCommittedRowCount();
892: 		if (row_group_count == 0) {
893: 			// empty row group - we can drop it entirely
894: 			row_group.CommitDrop();
895: 			entry.node.reset();
896: 		}
897: 		state.row_group_counts.push_back(row_group_count);
898: 	}
899: }
900: 
901: bool RowGroupCollection::ScheduleVacuumTasks(CollectionCheckpointState &checkpoint_state, VacuumState &state,
902:                                              idx_t segment_idx, bool schedule_vacuum) {
903: 	static constexpr const idx_t MAX_MERGE_COUNT = 3;
904: 
905: 	if (!state.can_vacuum_deletes) {
906: 		// we cannot vacuum deletes - cannot vacuum
907: 		return false;
908: 	}
909: 	if (segment_idx < state.next_vacuum_idx) {
910: 		// this segment is being vacuumed by a previously scheduled task
911: 		return true;
912: 	}
913: 	if (state.row_group_counts[segment_idx] == 0) {
914: 		// segment was already dropped - skip
915: 		D_ASSERT(!checkpoint_state.segments[segment_idx].node);
916: 		return false;
917: 	}
918: 	if (!schedule_vacuum) {
919: 		return false;
920: 	}
921: 	idx_t merge_rows;
922: 	idx_t next_idx = 0;
923: 	idx_t merge_count;
924: 	idx_t target_count;
925: 	bool perform_merge = false;
926: 	// check if we can merge row groups adjacent to the current segment_idx
927: 	// we try merging row groups into batches of 1-3 row groups
928: 	// our goal is to reduce the amount of row groups
929: 	// hence we target_count should be less than merge_count for a marge to be worth it
930: 	// we greedily prefer to merge to the lowest target_count
931: 	// i.e. we prefer to merge 2 row groups into 1, than 3 row groups into 2
932: 	const idx_t row_group_size = GetRowGroupSize();
933: 	for (target_count = 1; target_count <= MAX_MERGE_COUNT; target_count++) {
934: 		auto total_target_size = target_count * row_group_size;
935: 		merge_count = 0;
936: 		merge_rows = 0;
937: 		for (next_idx = segment_idx; next_idx < checkpoint_state.segments.size(); next_idx++) {
938: 			if (state.row_group_counts[next_idx] == 0) {
939: 				continue;
940: 			}
941: 			if (merge_rows + state.row_group_counts[next_idx] > total_target_size) {
942: 				// does not fit
943: 				break;
944: 			}
945: 			// we can merge this row group together with the other row group
946: 			merge_rows += state.row_group_counts[next_idx];
947: 			merge_count++;
948: 		}
949: 		if (target_count < merge_count) {
950: 			// we can reduce "merge_count" row groups to "target_count"
951: 			// perform the merge at this level
952: 			perform_merge = true;
953: 			break;
954: 		}
955: 	}
956: 	if (!perform_merge) {
957: 		return false;
958: 	}
959: 	// schedule the vacuum task
960: 	auto vacuum_task = make_uniq<VacuumTask>(checkpoint_state, state, segment_idx, merge_count, target_count,
961: 	                                         merge_rows, state.row_start);
962: 	checkpoint_state.executor.ScheduleTask(std::move(vacuum_task));
963: 	// skip vacuuming by the row groups we have merged
964: 	state.next_vacuum_idx = next_idx;
965: 	state.row_start += merge_rows;
966: 	return true;
967: }
968: 
969: //===--------------------------------------------------------------------===//
970: // Checkpoint
971: //===--------------------------------------------------------------------===//
972: unique_ptr<CheckpointTask> RowGroupCollection::GetCheckpointTask(CollectionCheckpointState &checkpoint_state,
973:                                                                  idx_t segment_idx) {
974: 	return make_uniq<CheckpointTask>(checkpoint_state, segment_idx);
975: }
976: 
977: void RowGroupCollection::Checkpoint(TableDataWriter &writer, TableStatistics &global_stats) {
978: 	auto l = row_groups->Lock();
979: 	auto segments = row_groups->MoveSegments(l);
980: 
981: 	CollectionCheckpointState checkpoint_state(*this, writer, segments, global_stats);
982: 
983: 	VacuumState vacuum_state;
984: 	InitializeVacuumState(checkpoint_state, vacuum_state, segments);
985: 
986: 	try {
987: 		// schedule tasks
988: 		idx_t total_vacuum_tasks = 0;
989: 		auto &config = DBConfig::GetConfig(writer.GetDatabase());
990: 
991: 		for (idx_t segment_idx = 0; segment_idx < segments.size(); segment_idx++) {
992: 			auto &entry = segments[segment_idx];
993: 			auto vacuum_tasks = ScheduleVacuumTasks(checkpoint_state, vacuum_state, segment_idx,
994: 			                                        total_vacuum_tasks < config.options.max_vacuum_tasks);
995: 			if (vacuum_tasks) {
996: 				// vacuum tasks were scheduled - don't schedule a checkpoint task yet
997: 				total_vacuum_tasks++;
998: 				continue;
999: 			}
1000: 			if (!entry.node) {
1001: 				// row group was vacuumed/dropped - skip
1002: 				continue;
1003: 			}
1004: 			// schedule a checkpoint task for this row group
1005: 			entry.node->MoveToCollection(*this, vacuum_state.row_start);
1006: 			auto checkpoint_task = GetCheckpointTask(checkpoint_state, segment_idx);
1007: 			checkpoint_state.executor.ScheduleTask(std::move(checkpoint_task));
1008: 			vacuum_state.row_start += entry.node->count;
1009: 		}
1010: 	} catch (const std::exception &e) {
1011: 		ErrorData error(e);
1012: 		checkpoint_state.executor.PushError(std::move(error));
1013: 		checkpoint_state.executor.WorkOnTasks(); // ensure all tasks have completed first before rethrowing
1014: 		throw;
1015: 	}
1016: 	// all tasks have been successfully scheduled - execute tasks until we are done
1017: 	checkpoint_state.executor.WorkOnTasks();
1018: 
1019: 	// no errors - finalize the row groups
1020: 	idx_t new_total_rows = 0;
1021: 	for (idx_t segment_idx = 0; segment_idx < segments.size(); segment_idx++) {
1022: 		auto &entry = segments[segment_idx];
1023: 		if (!entry.node) {
1024: 			// row group was vacuumed/dropped - skip
1025: 			continue;
1026: 		}
1027: 		auto &row_group = *entry.node;
1028: 		auto row_group_writer = std::move(checkpoint_state.writers[segment_idx]);
1029: 		if (!row_group_writer) {
1030: 			throw InternalException("Missing row group writer for index %llu", segment_idx);
1031: 		}
1032: 		auto pointer =
1033: 		    row_group.Checkpoint(std::move(checkpoint_state.write_data[segment_idx]), *row_group_writer, global_stats);
1034: 		writer.AddRowGroup(std::move(pointer), std::move(row_group_writer));
1035: 		row_groups->AppendSegment(l, std::move(entry.node));
1036: 		new_total_rows += row_group.count;
1037: 	}
1038: 	total_rows = new_total_rows;
1039: }
1040: 
1041: //===--------------------------------------------------------------------===//
1042: // CommitDrop
1043: //===--------------------------------------------------------------------===//
1044: void RowGroupCollection::CommitDropColumn(idx_t index) {
1045: 	for (auto &row_group : row_groups->Segments()) {
1046: 		row_group.CommitDropColumn(index);
1047: 	}
1048: }
1049: 
1050: void RowGroupCollection::CommitDropTable() {
1051: 	for (auto &row_group : row_groups->Segments()) {
1052: 		row_group.CommitDrop();
1053: 	}
1054: }
1055: 
1056: //===--------------------------------------------------------------------===//
1057: // GetPartitionStats
1058: //===--------------------------------------------------------------------===//
1059: vector<PartitionStatistics> RowGroupCollection::GetPartitionStats() const {
1060: 	vector<PartitionStatistics> result;
1061: 	for (auto &row_group : row_groups->Segments()) {
1062: 		result.push_back(row_group.GetPartitionStats());
1063: 	}
1064: 	return result;
1065: }
1066: 
1067: //===--------------------------------------------------------------------===//
1068: // GetColumnSegmentInfo
1069: //===--------------------------------------------------------------------===//
1070: vector<ColumnSegmentInfo> RowGroupCollection::GetColumnSegmentInfo() {
1071: 	vector<ColumnSegmentInfo> result;
1072: 	for (auto &row_group : row_groups->Segments()) {
1073: 		row_group.GetColumnSegmentInfo(row_group.index, result);
1074: 	}
1075: 	return result;
1076: }
1077: 
1078: //===--------------------------------------------------------------------===//
1079: // Alter
1080: //===--------------------------------------------------------------------===//
1081: shared_ptr<RowGroupCollection> RowGroupCollection::AddColumn(ClientContext &context, ColumnDefinition &new_column,
1082:                                                              ExpressionExecutor &default_executor) {
1083: 	idx_t new_column_idx = types.size();
1084: 	auto new_types = types;
1085: 	new_types.push_back(new_column.GetType());
1086: 	auto result = make_shared_ptr<RowGroupCollection>(info, block_manager, std::move(new_types), row_start,
1087: 	                                                  total_rows.load(), row_group_size);
1088: 
1089: 	DataChunk dummy_chunk;
1090: 	Vector default_vector(new_column.GetType());
1091: 
1092: 	result->stats.InitializeAddColumn(stats, new_column.GetType());
1093: 	auto lock = result->stats.GetLock();
1094: 	auto &new_column_stats = result->stats.GetStats(*lock, new_column_idx);
1095: 
1096: 	// fill the column with its DEFAULT value, or NULL if none is specified
1097: 	auto new_stats = make_uniq<SegmentStatistics>(new_column.GetType());
1098: 	for (auto &current_row_group : row_groups->Segments()) {
1099: 		auto new_row_group = current_row_group.AddColumn(*result, new_column, default_executor, default_vector);
1100: 		// merge in the statistics
1101: 		new_row_group->MergeIntoStatistics(new_column_idx, new_column_stats.Statistics());
1102: 
1103: 		result->row_groups->AppendSegment(std::move(new_row_group));
1104: 	}
1105: 	return result;
1106: }
1107: 
1108: shared_ptr<RowGroupCollection> RowGroupCollection::RemoveColumn(idx_t col_idx) {
1109: 	D_ASSERT(col_idx < types.size());
1110: 	auto new_types = types;
1111: 	new_types.erase_at(col_idx);
1112: 
1113: 	auto result = make_shared_ptr<RowGroupCollection>(info, block_manager, std::move(new_types), row_start,
1114: 	                                                  total_rows.load(), row_group_size);
1115: 	result->stats.InitializeRemoveColumn(stats, col_idx);
1116: 
1117: 	for (auto &current_row_group : row_groups->Segments()) {
1118: 		auto new_row_group = current_row_group.RemoveColumn(*result, col_idx);
1119: 		result->row_groups->AppendSegment(std::move(new_row_group));
1120: 	}
1121: 	return result;
1122: }
1123: 
1124: shared_ptr<RowGroupCollection> RowGroupCollection::AlterType(ClientContext &context, idx_t changed_idx,
1125:                                                              const LogicalType &target_type,
1126:                                                              vector<StorageIndex> bound_columns,
1127:                                                              Expression &cast_expr) {
1128: 	D_ASSERT(changed_idx < types.size());
1129: 	auto new_types = types;
1130: 	new_types[changed_idx] = target_type;
1131: 
1132: 	auto result = make_shared_ptr<RowGroupCollection>(info, block_manager, std::move(new_types), row_start,
1133: 	                                                  total_rows.load(), row_group_size);
1134: 	result->stats.InitializeAlterType(stats, changed_idx, target_type);
1135: 
1136: 	vector<LogicalType> scan_types;
1137: 	for (idx_t i = 0; i < bound_columns.size(); i++) {
1138: 		if (bound_columns[i].IsRowIdColumn()) {
1139: 			scan_types.emplace_back(LogicalType::ROW_TYPE);
1140: 		} else {
1141: 			scan_types.push_back(types[bound_columns[i].GetPrimaryIndex()]);
1142: 		}
1143: 	}
1144: 	DataChunk scan_chunk;
1145: 	scan_chunk.Initialize(GetAllocator(), scan_types);
1146: 
1147: 	ExpressionExecutor executor(context);
1148: 	executor.AddExpression(cast_expr);
1149: 
1150: 	TableScanState scan_state;
1151: 	scan_state.Initialize(bound_columns);
1152: 	scan_state.table_state.max_row = row_start + total_rows;
1153: 
1154: 	// now alter the type of the column within all of the row_groups individually
1155: 	auto lock = result->stats.GetLock();
1156: 	auto &changed_stats = result->stats.GetStats(*lock, changed_idx);
1157: 	for (auto &current_row_group : row_groups->Segments()) {
1158: 		auto new_row_group = current_row_group.AlterType(*result, target_type, changed_idx, executor,
1159: 		                                                 scan_state.table_state, scan_chunk);
1160: 		new_row_group->MergeIntoStatistics(changed_idx, changed_stats.Statistics());
1161: 		result->row_groups->AppendSegment(std::move(new_row_group));
1162: 	}
1163: 
1164: 	return result;
1165: }
1166: 
1167: void RowGroupCollection::VerifyNewConstraint(DataTable &parent, const BoundConstraint &constraint) {
1168: 	if (total_rows == 0) {
1169: 		return;
1170: 	}
1171: 
1172: 	// Scan the original table for NULL values.
1173: 	auto &not_null_constraint = constraint.Cast<BoundNotNullConstraint>();
1174: 	vector<LogicalType> scan_types;
1175: 	auto physical_index = not_null_constraint.index.index;
1176: 	D_ASSERT(physical_index < types.size());
1177: 
1178: 	scan_types.push_back(types[physical_index]);
1179: 	DataChunk scan_chunk;
1180: 	scan_chunk.Initialize(GetAllocator(), scan_types);
1181: 
1182: 	vector<StorageIndex> column_ids;
1183: 	column_ids.emplace_back(physical_index);
1184: 
1185: 	// Use SCAN_COMMITTED to scan the latest data.
1186: 	CreateIndexScanState state;
1187: 	auto scan_type = TableScanType::TABLE_SCAN_COMMITTED_ROWS_OMIT_PERMANENTLY_DELETED;
1188: 	state.Initialize(column_ids, nullptr);
1189: 	InitializeScan(state.table_state, column_ids, nullptr);
1190: 
1191: 	InitializeCreateIndexScan(state);
1192: 
1193: 	while (true) {
1194: 		scan_chunk.Reset();
1195: 		state.table_state.ScanCommitted(scan_chunk, state.segment_lock, scan_type);
1196: 		if (scan_chunk.size() == 0) {
1197: 			break;
1198: 		}
1199: 
1200: 		// Verify the NOT NULL constraint.
1201: 		if (VectorOperations::HasNull(scan_chunk.data[0], scan_chunk.size())) {
1202: 			auto name = parent.Columns()[physical_index].GetName();
1203: 			throw ConstraintException("NOT NULL constraint failed: %s.%s", info->GetTableName(), name);
1204: 		}
1205: 	}
1206: }
1207: 
1208: //===--------------------------------------------------------------------===//
1209: // Statistics
1210: //===--------------------------------------------------------------------===//
1211: void RowGroupCollection::CopyStats(TableStatistics &other_stats) {
1212: 	stats.CopyStats(other_stats);
1213: }
1214: 
1215: unique_ptr<BaseStatistics> RowGroupCollection::CopyStats(column_t column_id) {
1216: 	return stats.CopyStats(column_id);
1217: }
1218: 
1219: void RowGroupCollection::SetDistinct(column_t column_id, unique_ptr<DistinctStatistics> distinct_stats) {
1220: 	D_ASSERT(column_id != COLUMN_IDENTIFIER_ROW_ID);
1221: 	auto stats_lock = stats.GetLock();
1222: 	stats.GetStats(*stats_lock, column_id).SetDistinct(std::move(distinct_stats));
1223: }
1224: 
1225: } // namespace duckdb
[end of src/storage/table/row_group_collection.cpp]
[start of src/storage/table/table_statistics.cpp]
1: #include "duckdb/storage/table/table_statistics.hpp"
2: #include "duckdb/storage/table/persistent_table_data.hpp"
3: #include "duckdb/common/serializer/serializer.hpp"
4: #include "duckdb/common/serializer/deserializer.hpp"
5: #include "duckdb/execution/reservoir_sample.hpp"
6: 
7: namespace duckdb {
8: 
9: void TableStatistics::Initialize(const vector<LogicalType> &types, PersistentTableData &data) {
10: 	D_ASSERT(Empty());
11: 
12: 	stats_lock = make_shared_ptr<mutex>();
13: 	column_stats = std::move(data.table_stats.column_stats);
14: 	if (column_stats.size() != types.size()) { // LCOV_EXCL_START
15: 		throw IOException("Table statistics column count is not aligned with table column count. Corrupt file?");
16: 	} // LCOV_EXCL_STOP
17: }
18: 
19: void TableStatistics::InitializeEmpty(const vector<LogicalType> &types) {
20: 	D_ASSERT(Empty());
21: 
22: 	stats_lock = make_shared_ptr<mutex>();
23: 	for (auto &type : types) {
24: 		column_stats.push_back(ColumnStatistics::CreateEmptyStats(type));
25: 	}
26: }
27: 
28: void TableStatistics::InitializeAddColumn(TableStatistics &parent, const LogicalType &new_column_type) {
29: 	D_ASSERT(Empty());
30: 	D_ASSERT(parent.stats_lock);
31: 
32: 	stats_lock = parent.stats_lock;
33: 	lock_guard<mutex> lock(*stats_lock);
34: 	for (idx_t i = 0; i < parent.column_stats.size(); i++) {
35: 		column_stats.push_back(parent.column_stats[i]);
36: 	}
37: 	column_stats.push_back(ColumnStatistics::CreateEmptyStats(new_column_type));
38: }
39: 
40: void TableStatistics::InitializeRemoveColumn(TableStatistics &parent, idx_t removed_column) {
41: 	D_ASSERT(Empty());
42: 	D_ASSERT(parent.stats_lock);
43: 
44: 	stats_lock = parent.stats_lock;
45: 	lock_guard<mutex> lock(*stats_lock);
46: 	for (idx_t i = 0; i < parent.column_stats.size(); i++) {
47: 		if (i != removed_column) {
48: 			column_stats.push_back(parent.column_stats[i]);
49: 		}
50: 	}
51: }
52: 
53: void TableStatistics::InitializeAlterType(TableStatistics &parent, idx_t changed_idx, const LogicalType &new_type) {
54: 	D_ASSERT(Empty());
55: 	D_ASSERT(parent.stats_lock);
56: 
57: 	stats_lock = parent.stats_lock;
58: 	lock_guard<mutex> lock(*stats_lock);
59: 	for (idx_t i = 0; i < parent.column_stats.size(); i++) {
60: 		if (i == changed_idx) {
61: 			column_stats.push_back(ColumnStatistics::CreateEmptyStats(new_type));
62: 		} else {
63: 			column_stats.push_back(parent.column_stats[i]);
64: 		}
65: 	}
66: }
67: 
68: void TableStatistics::InitializeAddConstraint(TableStatistics &parent) {
69: 	D_ASSERT(Empty());
70: 	D_ASSERT(parent.stats_lock);
71: 
72: 	stats_lock = parent.stats_lock;
73: 	lock_guard<mutex> lock(*stats_lock);
74: 	for (idx_t i = 0; i < parent.column_stats.size(); i++) {
75: 		column_stats.push_back(parent.column_stats[i]);
76: 	}
77: }
78: 
79: void TableStatistics::MergeStats(TableStatistics &other) {
80: 	auto l = GetLock();
81: 	D_ASSERT(column_stats.size() == other.column_stats.size());
82: 	for (idx_t i = 0; i < column_stats.size(); i++) {
83: 		if (column_stats[i]) {
84: 			D_ASSERT(other.column_stats[i]);
85: 			column_stats[i]->Merge(*other.column_stats[i]);
86: 		}
87: 	}
88: }
89: 
90: void TableStatistics::MergeStats(idx_t i, BaseStatistics &stats) {
91: 	auto l = GetLock();
92: 	MergeStats(*l, i, stats);
93: }
94: 
95: void TableStatistics::MergeStats(TableStatisticsLock &lock, idx_t i, BaseStatistics &stats) {
96: 	column_stats[i]->Statistics().Merge(stats);
97: }
98: 
99: ColumnStatistics &TableStatistics::GetStats(TableStatisticsLock &lock, idx_t i) {
100: 	return *column_stats[i];
101: }
102: 
103: unique_ptr<BaseStatistics> TableStatistics::CopyStats(idx_t i) {
104: 	lock_guard<mutex> l(*stats_lock);
105: 	auto result = column_stats[i]->Statistics().Copy();
106: 	if (column_stats[i]->HasDistinctStats()) {
107: 		result.SetDistinctCount(column_stats[i]->DistinctStats().GetCount());
108: 	}
109: 	return result.ToUnique();
110: }
111: 
112: void TableStatistics::CopyStats(TableStatistics &other) {
113: 	TableStatisticsLock lock(*stats_lock);
114: 	CopyStats(lock, other);
115: }
116: 
117: void TableStatistics::CopyStats(TableStatisticsLock &lock, TableStatistics &other) {
118: 	D_ASSERT(other.Empty());
119: 	other.stats_lock = make_shared_ptr<mutex>();
120: 	for (auto &stats : column_stats) {
121: 		other.column_stats.push_back(stats->Copy());
122: 	}
123: }
124: 
125: void TableStatistics::Serialize(Serializer &serializer) const {
126: 	serializer.WriteProperty(100, "column_stats", column_stats);
127: 	serializer.WritePropertyWithDefault<unique_ptr<BlockingSample>>(101, "table_sample", table_sample, nullptr);
128: }
129: 
130: void TableStatistics::Deserialize(Deserializer &deserializer, ColumnList &columns) {
131: 	auto physical_columns = columns.Physical();
132: 
133: 	auto iter = physical_columns.begin();
134: 	deserializer.ReadList(100, "column_stats", [&](Deserializer::List &list, idx_t i) {
135: 		auto &col = *iter;
136: 		iter.operator++();
137: 
138: 		auto type = col.GetType();
139: 		deserializer.Set<LogicalType &>(type);
140: 
141: 		column_stats.push_back(list.ReadElement<shared_ptr<ColumnStatistics>>());
142: 
143: 		deserializer.Unset<LogicalType>();
144: 	});
145: 	table_sample =
146: 	    deserializer.ReadPropertyWithExplicitDefault<unique_ptr<BlockingSample>>(101, "table_sample", nullptr);
147: }
148: 
149: unique_ptr<TableStatisticsLock> TableStatistics::GetLock() {
150: 	D_ASSERT(stats_lock);
151: 	return make_uniq<TableStatisticsLock>(*stats_lock);
152: }
153: 
154: bool TableStatistics::Empty() {
155: 	D_ASSERT(column_stats.empty() == (stats_lock.get() == nullptr));
156: 	return column_stats.empty();
157: }
158: 
159: } // namespace duckdb
[end of src/storage/table/table_statistics.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: