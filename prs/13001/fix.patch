diff --git a/src/common/exception/binder_exception.cpp b/src/common/exception/binder_exception.cpp
index 458c563c0ea8..55db8386a17d 100644
--- a/src/common/exception/binder_exception.cpp
+++ b/src/common/exception/binder_exception.cpp
@@ -44,4 +44,9 @@ BinderException BinderException::NoMatchingFunction(const string &name, const ve
 	    extra_info);
 }
 
+BinderException BinderException::Unsupported(ParsedExpression &expr, const string &message) {
+	auto extra_info = Exception::InitializeExtraInfo("UNSUPPORTED", expr.query_location);
+	return BinderException(message, extra_info);
+}
+
 } // namespace duckdb
diff --git a/src/include/duckdb/common/exception/binder_exception.hpp b/src/include/duckdb/common/exception/binder_exception.hpp
index cd5bfe9ff1e7..59e1b5e73129 100644
--- a/src/include/duckdb/common/exception/binder_exception.hpp
+++ b/src/include/duckdb/common/exception/binder_exception.hpp
@@ -46,6 +46,7 @@ class BinderException : public Exception {
 	                                      QueryErrorContext context = QueryErrorContext());
 	static BinderException NoMatchingFunction(const string &name, const vector<LogicalType> &arguments,
 	                                          const vector<string> &candidates);
+	static BinderException Unsupported(ParsedExpression &expr, const string &message);
 };
 
 } // namespace duckdb
diff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp
index 394750ccb812..1131d545a340 100644
--- a/src/include/duckdb/planner/expression_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder.hpp
@@ -193,6 +193,8 @@ class ExpressionBinder {
 	LogicalType ResolveCoalesceType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);
 	LogicalType ResolveNotType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);
 
+	BindResult BindUnsupportedExpression(ParsedExpression &expr, idx_t depth, const string &message);
+
 protected:
 	virtual BindResult BindGroupingFunction(OperatorExpression &op, idx_t depth);
 	virtual BindResult BindFunction(FunctionExpression &expr, ScalarFunctionCatalogEntry &function, idx_t depth);
diff --git a/src/planner/binder/expression/bind_function_expression.cpp b/src/planner/binder/expression/bind_function_expression.cpp
index f1f137a834d3..e550c9d175d3 100644
--- a/src/planner/binder/expression/bind_function_expression.cpp
+++ b/src/planner/binder/expression/bind_function_expression.cpp
@@ -263,11 +263,11 @@ BindResult ExpressionBinder::BindLambdaFunction(FunctionExpression &function, Sc
 
 BindResult ExpressionBinder::BindAggregate(FunctionExpression &expr, AggregateFunctionCatalogEntry &function,
                                            idx_t depth) {
-	return BindResult(BinderException(expr, UnsupportedAggregateMessage()));
+	return BindUnsupportedExpression(expr, depth, UnsupportedAggregateMessage());
 }
 
 BindResult ExpressionBinder::BindUnnest(FunctionExpression &expr, idx_t depth, bool root_expression) {
-	return BindResult(BinderException(expr, UnsupportedUnnestMessage()));
+	return BindUnsupportedExpression(expr, depth, UnsupportedUnnestMessage());
 }
 
 string ExpressionBinder::UnsupportedAggregateMessage() {
diff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp
index 4551525b62c7..3cf5c339f9c8 100644
--- a/src/planner/expression_binder.cpp
+++ b/src/planner/expression_binder.cpp
@@ -6,6 +6,7 @@
 #include "duckdb/planner/binder.hpp"
 #include "duckdb/planner/expression/list.hpp"
 #include "duckdb/planner/expression_iterator.hpp"
+#include "duckdb/common/operator/cast_operators.hpp"
 
 namespace duckdb {
 
@@ -95,12 +96,100 @@ BindResult ExpressionBinder::BindExpression(unique_ptr<ParsedExpression> &expr,
 		return BindPositionalReference(expr, depth, root_expression);
 	}
 	case ExpressionClass::STAR:
-		return BindResult(BinderException(expr_ref, "STAR expression is not supported here"));
+		return BindResult(BinderException::Unsupported(expr_ref, "STAR expression is not supported here"));
 	default:
 		throw NotImplementedException("Unimplemented expression class");
 	}
 }
 
+static bool CombineMissingColumns(ErrorData &current, ErrorData new_error) {
+	auto &current_info = current.ExtraInfo();
+	auto &new_info = new_error.ExtraInfo();
+	auto current_entry = current_info.find("error_subtype");
+	auto new_entry = new_info.find("error_subtype");
+	if (current_entry == current_info.end() || new_entry == new_info.end()) {
+		// no subtype info in either expression
+		return false;
+	}
+	if (current_entry->second != "COLUMN_NOT_FOUND" || new_entry->second != "COLUMN_NOT_FOUND") {
+		// either info is not a `COLUMN_NOT_FOUND`
+		return false;
+	}
+	current_entry = current_info.find("name");
+	new_entry = new_info.find("name");
+	if (current_entry == current_info.end() || new_entry == new_info.end()) {
+		// no candidate info in either column
+		return false;
+	}
+	if (current_entry->second != new_entry->second) {
+		// error does not concern the same name/column
+		return false;
+	}
+	auto column_name = current_entry->second;
+	current_entry = current_info.find("candidates");
+	new_entry = new_info.find("candidates");
+	if (current_entry == current_info.end()) {
+		// no current candidates - use new candidates
+		current = std::move(new_error);
+		return true;
+	}
+	if (new_entry == new_info.end()) {
+		// no new candidates - use current candidates
+		return true;
+	}
+	// both errors have candidates - combine the candidates
+	auto current_candidates = StringUtil::Split(current_entry->second, ",");
+	auto new_candidates = StringUtil::Split(new_entry->second, ",");
+	current_candidates.insert(current_candidates.end(), new_candidates.begin(), new_candidates.end());
+
+	// run the similarity ranking on both sets of candidates
+	unordered_set<string> candidates;
+	vector<pair<string, double>> scores;
+	for (auto &candidate : current_candidates) {
+		// split by "." since the candidates might be in the form "table.column"
+		auto column_splits = StringUtil::Split(candidate, ".");
+		if (column_splits.empty()) {
+			continue;
+		}
+		auto &candidate_column = column_splits.back();
+		auto entry = candidates.find(candidate);
+		if (entry != candidates.end()) {
+			// already found
+			continue;
+		}
+		auto score = StringUtil::SimilarityRating(candidate_column, column_name);
+		candidates.insert(candidate);
+		scores.emplace_back(make_pair(std::move(candidate), score));
+	}
+	// get a new top-n
+	auto top_candidates = StringUtil::TopNStrings(scores);
+	// get query location
+	QueryErrorContext context;
+	current_entry = current_info.find("position");
+	new_entry = current_info.find("position");
+	uint64_t position;
+	if (current_entry != current_info.end() &&
+	    TryCast::Operation<string_t, uint64_t>(current_entry->second, position)) {
+		context = QueryErrorContext(position);
+	} else if (new_entry != new_info.end() && TryCast::Operation<string_t, uint64_t>(new_entry->second, position)) {
+		context = QueryErrorContext(position);
+	}
+	// generate a new (combined) error
+	current = BinderException::ColumnNotFound(column_name, top_candidates, context);
+	return true;
+}
+
+static void CombineErrors(ErrorData &current, ErrorData new_error) {
+	// try to combine missing column exceptions in order to pick the most relevant one
+	if (CombineMissingColumns(current, new_error)) {
+		// keep the old info
+		return;
+	}
+
+	// override the error with the new one
+	current = std::move(new_error);
+}
+
 BindResult ExpressionBinder::BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr, ErrorData error_message) {
 	// try to bind in one of the outer queries, if the binding error occurred in a subquery
 	auto &active_binders = binder.GetActiveBinders();
@@ -113,10 +202,12 @@ BindResult ExpressionBinder::BindCorrelatedColumns(unique_ptr<ParsedExpression>
 	while (!active_binders.empty()) {
 		auto &next_binder = active_binders.back().get();
 		ExpressionBinder::QualifyColumnNames(next_binder.binder, expr);
-		bind_error = next_binder.Bind(expr, depth);
-		if (!bind_error.HasError()) {
+		auto next_error = next_binder.Bind(expr, depth);
+		if (!next_error.HasError()) {
+			bind_error = std::move(next_error);
 			break;
 		}
+		CombineErrors(bind_error, std::move(next_error));
 		depth++;
 		active_binders.pop_back();
 	}
@@ -228,7 +319,8 @@ unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr
 		// aggregate with constant input must be bound to a root node.
 		auto result = BindCorrelatedColumns(expr, error_msg);
 		if (result.HasError()) {
-			result.error.Throw();
+			CombineErrors(error_msg, std::move(result.error));
+			error_msg.Throw();
 		}
 		auto &bound_expr = expr->Cast<BoundExpression>();
 		ExtractCorrelatedExpressions(binder, *bound_expr.expr);
@@ -282,6 +374,19 @@ ErrorData ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr, idx_t depth
 	return ErrorData();
 }
 
+BindResult ExpressionBinder::BindUnsupportedExpression(ParsedExpression &expr, idx_t depth, const string &message) {
+	// we always prefer to throw an error if it occurs in a child expression
+	// since that error might be more descriptive
+	// bind all children
+	ErrorData result;
+	ParsedExpressionIterator::EnumerateChildren(
+	    expr, [&](unique_ptr<ParsedExpression> &child) { BindChild(child, depth, result); });
+	if (result.HasError()) {
+		return BindResult(std::move(result));
+	}
+	return BindResult(BinderException::Unsupported(expr, message));
+}
+
 bool ExpressionBinder::IsUnnestFunction(const string &function_name) {
 	return function_name == "unnest" || function_name == "unlist";
 }
diff --git a/src/planner/expression_binder/aggregate_binder.cpp b/src/planner/expression_binder/aggregate_binder.cpp
index cf17293482b5..353002b5a84c 100644
--- a/src/planner/expression_binder/aggregate_binder.cpp
+++ b/src/planner/expression_binder/aggregate_binder.cpp
@@ -11,7 +11,7 @@ BindResult AggregateBinder::BindExpression(unique_ptr<ParsedExpression> &expr_pt
 	auto &expr = *expr_ptr;
 	switch (expr.expression_class) {
 	case ExpressionClass::WINDOW:
-		throw ParserException("aggregate function calls cannot contain window function calls");
+		throw BinderException::Unsupported(expr, "aggregate function calls cannot contain window function calls");
 	default:
 		return ExpressionBinder::BindExpression(expr_ptr, depth);
 	}
diff --git a/src/planner/expression_binder/alter_binder.cpp b/src/planner/expression_binder/alter_binder.cpp
index e8c4d547066e..797e37111640 100644
--- a/src/planner/expression_binder/alter_binder.cpp
+++ b/src/planner/expression_binder/alter_binder.cpp
@@ -23,9 +23,9 @@ BindResult AlterBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, i
 	auto &expr = *expr_ptr;
 	switch (expr.GetExpressionClass()) {
 	case ExpressionClass::WINDOW:
-		return BindResult("window functions are not allowed in alter statement");
+		return BindResult(BinderException::Unsupported(expr, "window functions are not allowed in alter statement"));
 	case ExpressionClass::SUBQUERY:
-		return BindResult("cannot use subquery in alter statement");
+		return BindResult(BinderException::Unsupported(expr, "cannot use subquery in alter statement"));
 	case ExpressionClass::COLUMN_REF:
 		return BindColumnReference(expr.Cast<ColumnRefExpression>(), depth);
 	default:
diff --git a/src/planner/expression_binder/base_select_binder.cpp b/src/planner/expression_binder/base_select_binder.cpp
index 30a1eeaaa269..a8b1addc0889 100644
--- a/src/planner/expression_binder/base_select_binder.cpp
+++ b/src/planner/expression_binder/base_select_binder.cpp
@@ -31,7 +31,7 @@ BindResult BaseSelectBinder::BindExpression(unique_ptr<ParsedExpression> &expr_p
 	case ExpressionClass::COLUMN_REF:
 		return BindColumnRef(expr_ptr, depth, root_expression);
 	case ExpressionClass::DEFAULT:
-		return BindResult("SELECT clause cannot contain DEFAULT clause");
+		return BindResult(BinderException::Unsupported(expr, "SELECT clause cannot contain DEFAULT clause"));
 	case ExpressionClass::WINDOW:
 		return BindWindow(expr.Cast<WindowExpression>(), depth);
 	default:
diff --git a/src/planner/expression_binder/constant_binder.cpp b/src/planner/expression_binder/constant_binder.cpp
index fb93f363429a..97a65ba311d8 100644
--- a/src/planner/expression_binder/constant_binder.cpp
+++ b/src/planner/expression_binder/constant_binder.cpp
@@ -19,14 +19,14 @@ BindResult ConstantBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr
 				return BindExpression(expr_ptr, depth, root_expression);
 			}
 		}
-		return BindResult(clause + " cannot contain column names");
+		return BindUnsupportedExpression(expr, depth, clause + " cannot contain column names");
 	}
 	case ExpressionClass::SUBQUERY:
 		throw BinderException(clause + " cannot contain subqueries");
 	case ExpressionClass::DEFAULT:
-		return BindResult(clause + " cannot contain DEFAULT clause");
+		return BindUnsupportedExpression(expr, depth, clause + " cannot contain DEFAULT clause");
 	case ExpressionClass::WINDOW:
-		return BindResult(clause + " cannot contain window functions!");
+		return BindUnsupportedExpression(expr, depth, clause + " cannot contain window functions!");
 	default:
 		return ExpressionBinder::BindExpression(expr_ptr, depth);
 	}
diff --git a/src/planner/expression_binder/group_binder.cpp b/src/planner/expression_binder/group_binder.cpp
index cbf25d76d649..2514a8b675e2 100644
--- a/src/planner/expression_binder/group_binder.cpp
+++ b/src/planner/expression_binder/group_binder.cpp
@@ -31,9 +31,9 @@ BindResult GroupBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, i
 	}
 	switch (expr.expression_class) {
 	case ExpressionClass::DEFAULT:
-		return BindResult("GROUP BY clause cannot contain DEFAULT clause");
+		return BindUnsupportedExpression(expr, depth, "GROUP BY clause cannot contain DEFAULT clause");
 	case ExpressionClass::WINDOW:
-		return BindResult("GROUP BY clause cannot contain window functions!");
+		return BindUnsupportedExpression(expr, depth, "GROUP BY clause cannot contain window functions!");
 	default:
 		return ExpressionBinder::BindExpression(expr_ptr, depth);
 	}
diff --git a/src/planner/expression_binder/having_binder.cpp b/src/planner/expression_binder/having_binder.cpp
index 937c36c25e50..27b0124bcb93 100644
--- a/src/planner/expression_binder/having_binder.cpp
+++ b/src/planner/expression_binder/having_binder.cpp
@@ -1,6 +1,7 @@
 #include "duckdb/planner/expression_binder/having_binder.hpp"
 
 #include "duckdb/parser/expression/columnref_expression.hpp"
+#include "duckdb/parser/expression/window_expression.hpp"
 #include "duckdb/planner/binder.hpp"
 #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
 #include "duckdb/common/string_util.hpp"
@@ -74,7 +75,7 @@ BindResult HavingBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, i
 }
 
 BindResult HavingBinder::BindWindow(WindowExpression &expr, idx_t depth) {
-	return BindResult("HAVING clause cannot contain window functions!");
+	return BindResult(BinderException::Unsupported(expr, "HAVING clause cannot contain window functions!"));
 }
 
 } // namespace duckdb
diff --git a/src/planner/expression_binder/index_binder.cpp b/src/planner/expression_binder/index_binder.cpp
index 988948ae4066..e0138ecb3671 100644
--- a/src/planner/expression_binder/index_binder.cpp
+++ b/src/planner/expression_binder/index_binder.cpp
@@ -49,9 +49,9 @@ BindResult IndexBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, i
 	auto &expr = *expr_ptr;
 	switch (expr.expression_class) {
 	case ExpressionClass::WINDOW:
-		return BindResult("window functions are not allowed in index expressions");
+		return BindResult(BinderException::Unsupported(expr, "window functions are not allowed in index expressions"));
 	case ExpressionClass::SUBQUERY:
-		return BindResult("cannot use subquery in index expressions");
+		return BindResult(BinderException::Unsupported(expr, "cannot use subquery in index expressions"));
 	default:
 		return ExpressionBinder::BindExpression(expr_ptr, depth);
 	}
diff --git a/src/planner/expression_binder/insert_binder.cpp b/src/planner/expression_binder/insert_binder.cpp
index 84cd2a4f68ad..6b7d7450219f 100644
--- a/src/planner/expression_binder/insert_binder.cpp
+++ b/src/planner/expression_binder/insert_binder.cpp
@@ -11,9 +11,9 @@ BindResult InsertBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr,
 	auto &expr = *expr_ptr;
 	switch (expr.GetExpressionClass()) {
 	case ExpressionClass::DEFAULT:
-		return BindResult("DEFAULT is not allowed here!");
+		return BindResult(BinderException::Unsupported(expr, "DEFAULT is not allowed here!"));
 	case ExpressionClass::WINDOW:
-		return BindResult("INSERT statement cannot contain window functions!");
+		return BindResult(BinderException::Unsupported(expr, "INSERT statement cannot contain window functions!"));
 	default:
 		return ExpressionBinder::BindExpression(expr_ptr, depth);
 	}
diff --git a/src/planner/expression_binder/lateral_binder.cpp b/src/planner/expression_binder/lateral_binder.cpp
index 21ceb4e50c3f..a2c56611fee5 100644
--- a/src/planner/expression_binder/lateral_binder.cpp
+++ b/src/planner/expression_binder/lateral_binder.cpp
@@ -40,9 +40,9 @@ BindResult LateralBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr,
 	auto &expr = *expr_ptr;
 	switch (expr.GetExpressionClass()) {
 	case ExpressionClass::DEFAULT:
-		return BindResult("LATERAL join cannot contain DEFAULT clause");
+		return BindUnsupportedExpression(expr, depth, "LATERAL join cannot contain DEFAULT clause!");
 	case ExpressionClass::WINDOW:
-		return BindResult("LATERAL join cannot contain window functions!");
+		return BindUnsupportedExpression(expr, depth, "LATERAL join cannot contain window functions!");
 	case ExpressionClass::COLUMN_REF:
 		return BindColumnRef(expr_ptr, depth, root_expression);
 	default:
diff --git a/src/planner/expression_binder/qualify_binder.cpp b/src/planner/expression_binder/qualify_binder.cpp
index e778c2034b1b..7b251a52d0cf 100644
--- a/src/planner/expression_binder/qualify_binder.cpp
+++ b/src/planner/expression_binder/qualify_binder.cpp
@@ -30,8 +30,8 @@ BindResult QualifyBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr,
 		return alias_result;
 	}
 
-	return BindResult(
-	    StringUtil::Format("Referenced column %s not found in FROM clause and can't find in alias map.", expr_string));
+	return BindResult(BinderException(
+	    *expr_ptr, "Referenced column %s not found in FROM clause and can't find in alias map.", expr_string));
 }
 
 } // namespace duckdb
diff --git a/src/planner/expression_binder/relation_binder.cpp b/src/planner/expression_binder/relation_binder.cpp
index 4e0415742f76..d6cfe83cbaf9 100644
--- a/src/planner/expression_binder/relation_binder.cpp
+++ b/src/planner/expression_binder/relation_binder.cpp
@@ -10,13 +10,13 @@ BindResult RelationBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr
 	auto &expr = *expr_ptr;
 	switch (expr.expression_class) {
 	case ExpressionClass::AGGREGATE:
-		return BindResult("aggregate functions are not allowed in " + op);
+		return BindResult(BinderException::Unsupported(expr, "aggregate functions are not allowed in " + op));
 	case ExpressionClass::DEFAULT:
-		return BindResult(op + " cannot contain DEFAULT clause");
+		return BindResult(BinderException::Unsupported(expr, op + " cannot contain DEFAULT clause"));
 	case ExpressionClass::SUBQUERY:
-		return BindResult("subqueries are not allowed in " + op);
+		return BindResult(BinderException::Unsupported(expr, "subqueries are not allowed in " + op));
 	case ExpressionClass::WINDOW:
-		return BindResult("window functions are not allowed in " + op);
+		return BindResult(BinderException::Unsupported(expr, "window functions are not allowed in " + op));
 	default:
 		return ExpressionBinder::BindExpression(expr_ptr, depth);
 	}
diff --git a/src/planner/expression_binder/returning_binder.cpp b/src/planner/expression_binder/returning_binder.cpp
index 8d731b21b2b6..684bebc5396c 100644
--- a/src/planner/expression_binder/returning_binder.cpp
+++ b/src/planner/expression_binder/returning_binder.cpp
@@ -11,9 +11,10 @@ BindResult ReturningBinder::BindExpression(unique_ptr<ParsedExpression> &expr_pt
 	auto &expr = *expr_ptr;
 	switch (expr.GetExpressionClass()) {
 	case ExpressionClass::SUBQUERY:
-		return BindResult("SUBQUERY is not supported in returning statements");
+		return BindResult(BinderException::Unsupported(expr, "SUBQUERY is not supported in returning statements"));
 	case ExpressionClass::BOUND_SUBQUERY:
-		return BindResult("BOUND SUBQUERY is not supported in returning statements");
+		return BindResult(
+		    BinderException::Unsupported(expr, "BOUND SUBQUERY is not supported in returning statements"));
 	case ExpressionClass::COLUMN_REF:
 		return ExpressionBinder::BindExpression(expr_ptr, depth);
 	default:
diff --git a/src/planner/expression_binder/update_binder.cpp b/src/planner/expression_binder/update_binder.cpp
index 4537957e12a0..b3f7e6389a6f 100644
--- a/src/planner/expression_binder/update_binder.cpp
+++ b/src/planner/expression_binder/update_binder.cpp
@@ -9,7 +9,7 @@ BindResult UpdateBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr,
 	auto &expr = *expr_ptr;
 	switch (expr.expression_class) {
 	case ExpressionClass::WINDOW:
-		return BindResult("window functions are not allowed in UPDATE");
+		return BindResult(BinderException::Unsupported(expr, "window functions are not allowed in UPDATE"));
 	default:
 		return ExpressionBinder::BindExpression(expr_ptr, depth);
 	}
diff --git a/src/planner/expression_binder/where_binder.cpp b/src/planner/expression_binder/where_binder.cpp
index 92b94cdb96e8..b8cf24ea27e0 100644
--- a/src/planner/expression_binder/where_binder.cpp
+++ b/src/planner/expression_binder/where_binder.cpp
@@ -29,9 +29,9 @@ BindResult WhereBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, i
 	auto &expr = *expr_ptr;
 	switch (expr.GetExpressionClass()) {
 	case ExpressionClass::DEFAULT:
-		return BindResult("WHERE clause cannot contain DEFAULT clause");
+		return BindUnsupportedExpression(expr, depth, "WHERE clause cannot contain DEFAULT clause");
 	case ExpressionClass::WINDOW:
-		return BindResult("WHERE clause cannot contain window functions!");
+		return BindUnsupportedExpression(expr, depth, "WHERE clause cannot contain window functions!");
 	case ExpressionClass::COLUMN_REF:
 		return BindColumnRef(expr_ptr, depth, root_expression);
 	default:
