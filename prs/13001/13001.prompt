You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Improper error message: LATERAL join cannot contain window functions
### What happens?

```sql
  create table customers (name varchar, age integer, something_easy_to_type_wrong integer, city varchar);
  create table zipcodes (city varchar, zipcode varchar);
  insert into customers values ('Alice', 24, 7, 'Seattle'),
                              ('Bob', 34, 2, 'Portland'),
                              ('Charlie', 23, 3, 'Seattle'),
                              ('David', 36, 9, 'Portland'),
                              ('Sam', 35, 5, 'Seattle');

  insert into zipcodes values ('Seattle', '98101'), 
                              ('Portland', '97201');

  with cte as (
      select *,
          rank() over (order by something_easy_to_typo_wrong) as rk
      from customers
      where age <= 42
  )
  select *
  from zipcodes
  join cte
  using (city)
```
The above SQL query emits the following error message:
```
 Binder Error: LATERAL join cannot contain window functions!
```
If we switch the join order as `from cte join zipcodes` (i.e., put the subquery `cte` on the LHS of the join), a super-friendly error message is produced:
```
Binder Error: Referenced column "something_easy_to_typo_wrong" not found in FROM clause!
Candidate bindings: "customers.something_easy_to_type_wrong"
LINE 15:             rank() over (order by something_easy_to_typo_wrong) as rk
                                           ^
```
The latter is exactly what everybody wants. Super helpful (thanks to the AMAZING effort the DuckDB team has done)! For the former case, however, if there are tons of (aggregate) window expressions in the subquery, we will have a poor chance of recognizing the problem.

### To Reproduce

See the description above.

### OS:

Ubuntu 22.04.2 LTS, aarch64

### DuckDB Version:

1.0.0

### DuckDB Client:

Python

### Full Name:

Mark

### Affiliation:

bq

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

No - Other reason (please specify in the issue body)

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [ ] Yes, I have
Improper error message: LATERAL join cannot contain window functions
### What happens?

```sql
  create table customers (name varchar, age integer, something_easy_to_type_wrong integer, city varchar);
  create table zipcodes (city varchar, zipcode varchar);
  insert into customers values ('Alice', 24, 7, 'Seattle'),
                              ('Bob', 34, 2, 'Portland'),
                              ('Charlie', 23, 3, 'Seattle'),
                              ('David', 36, 9, 'Portland'),
                              ('Sam', 35, 5, 'Seattle');

  insert into zipcodes values ('Seattle', '98101'), 
                              ('Portland', '97201');

  with cte as (
      select *,
          rank() over (order by something_easy_to_typo_wrong) as rk
      from customers
      where age <= 42
  )
  select *
  from zipcodes
  join cte
  using (city)
```
The above SQL query emits the following error message:
```
 Binder Error: LATERAL join cannot contain window functions!
```
If we switch the join order as `from cte join zipcodes` (i.e., put the subquery `cte` on the LHS of the join), a super-friendly error message is produced:
```
Binder Error: Referenced column "something_easy_to_typo_wrong" not found in FROM clause!
Candidate bindings: "customers.something_easy_to_type_wrong"
LINE 15:             rank() over (order by something_easy_to_typo_wrong) as rk
                                           ^
```
The latter is exactly what everybody wants. Super helpful (thanks to the AMAZING effort the DuckDB team has done)! For the former case, however, if there are tons of (aggregate) window expressions in the subquery, we will have a poor chance of recognizing the problem.

### To Reproduce

See the description above.

### OS:

Ubuntu 22.04.2 LTS, aarch64

### DuckDB Version:

1.0.0

### DuckDB Client:

Python

### Full Name:

Mark

### Affiliation:

bq

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

No - Other reason (please specify in the issue body)

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [ ] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/common/exception/binder_exception.cpp]
1: #include "duckdb/common/exception/binder_exception.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/function/function.hpp"
4: 
5: namespace duckdb {
6: 
7: BinderException::BinderException(const string &msg) : Exception(ExceptionType::BINDER, msg) {
8: }
9: 
10: BinderException::BinderException(const string &msg, const unordered_map<string, string> &extra_info)
11:     : Exception(ExceptionType::BINDER, msg, extra_info) {
12: }
13: 
14: BinderException BinderException::ColumnNotFound(const string &name, const vector<string> &similar_bindings,
15:                                                 QueryErrorContext context) {
16: 	auto extra_info = Exception::InitializeExtraInfo("COLUMN_NOT_FOUND", context.query_location);
17: 	string candidate_str = StringUtil::CandidatesMessage(similar_bindings, "Candidate bindings");
18: 	extra_info["name"] = name;
19: 	if (!similar_bindings.empty()) {
20: 		extra_info["candidates"] = StringUtil::Join(similar_bindings, ",");
21: 	}
22: 	return BinderException(
23: 	    StringUtil::Format("Referenced column \"%s\" not found in FROM clause!%s", name, candidate_str), extra_info);
24: }
25: 
26: BinderException BinderException::NoMatchingFunction(const string &name, const vector<LogicalType> &arguments,
27:                                                     const vector<string> &candidates) {
28: 	auto extra_info = Exception::InitializeExtraInfo("NO_MATCHING_FUNCTION", optional_idx());
29: 	// no matching function was found, throw an error
30: 	string call_str = Function::CallToString(name, arguments);
31: 	string candidate_str;
32: 	for (auto &candidate : candidates) {
33: 		candidate_str += "\t" + candidate + "\n";
34: 	}
35: 	extra_info["name"] = name;
36: 	extra_info["call"] = call_str;
37: 	if (!candidates.empty()) {
38: 		extra_info["candidates"] = StringUtil::Join(candidates, ",");
39: 	}
40: 	return BinderException(
41: 	    StringUtil::Format("No function matches the given name and argument types '%s'. You might need to add "
42: 	                       "explicit type casts.\n\tCandidate functions:\n%s",
43: 	                       call_str, candidate_str),
44: 	    extra_info);
45: }
46: 
47: } // namespace duckdb
[end of src/common/exception/binder_exception.cpp]
[start of src/include/duckdb/common/exception/binder_exception.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/exception/binder_exception.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/exception.hpp"
12: #include "duckdb/parser/query_error_context.hpp"
13: 
14: namespace duckdb {
15: 
16: class BinderException : public Exception {
17: public:
18: 	DUCKDB_API explicit BinderException(const string &msg, const unordered_map<string, string> &extra_info);
19: 	DUCKDB_API explicit BinderException(const string &msg);
20: 
21: 	template <typename... ARGS>
22: 	explicit BinderException(const string &msg, ARGS... params) : BinderException(ConstructMessage(msg, params...)) {
23: 	}
24: 	template <typename... ARGS>
25: 	explicit BinderException(const TableRef &ref, const string &msg, ARGS... params)
26: 	    : BinderException(ConstructMessage(msg, params...), Exception::InitializeExtraInfo(ref)) {
27: 	}
28: 	template <typename... ARGS>
29: 	explicit BinderException(const ParsedExpression &expr, const string &msg, ARGS... params)
30: 	    : BinderException(ConstructMessage(msg, params...), Exception::InitializeExtraInfo(expr)) {
31: 	}
32: 	template <typename... ARGS>
33: 	explicit BinderException(const Expression &expr, const string &msg, ARGS... params)
34: 	    : BinderException(ConstructMessage(msg, params...), Exception::InitializeExtraInfo(expr)) {
35: 	}
36: 	template <typename... ARGS>
37: 	explicit BinderException(QueryErrorContext error_context, const string &msg, ARGS... params)
38: 	    : BinderException(ConstructMessage(msg, params...), Exception::InitializeExtraInfo(error_context)) {
39: 	}
40: 	template <typename... ARGS>
41: 	explicit BinderException(optional_idx error_location, const string &msg, ARGS... params)
42: 	    : BinderException(ConstructMessage(msg, params...), Exception::InitializeExtraInfo(error_location)) {
43: 	}
44: 
45: 	static BinderException ColumnNotFound(const string &name, const vector<string> &similar_bindings,
46: 	                                      QueryErrorContext context = QueryErrorContext());
47: 	static BinderException NoMatchingFunction(const string &name, const vector<LogicalType> &arguments,
48: 	                                          const vector<string> &candidates);
49: };
50: 
51: } // namespace duckdb
[end of src/include/duckdb/common/exception/binder_exception.hpp]
[start of src/include/duckdb/planner/expression_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/exception.hpp"
12: #include "duckdb/common/stack_checker.hpp"
13: #include "duckdb/common/exception/binder_exception.hpp"
14: #include "duckdb/common/error_data.hpp"
15: #include "duckdb/common/unordered_map.hpp"
16: #include "duckdb/parser/expression/bound_expression.hpp"
17: #include "duckdb/parser/expression/lambdaref_expression.hpp"
18: #include "duckdb/parser/parsed_expression.hpp"
19: #include "duckdb/parser/tokens.hpp"
20: #include "duckdb/planner/expression.hpp"
21: #include "duckdb/catalog/catalog_entry_retriever.hpp"
22: #include "duckdb/planner/expression/bound_lambda_expression.hpp"
23: #include "duckdb/function/scalar_function.hpp"
24: 
25: namespace duckdb {
26: 
27: class Binder;
28: class ClientContext;
29: class QueryNode;
30: 
31: class ScalarFunctionCatalogEntry;
32: class AggregateFunctionCatalogEntry;
33: class ScalarMacroCatalogEntry;
34: class CatalogEntry;
35: class SimpleFunction;
36: 
37: struct DummyBinding;
38: struct SelectBindState;
39: 
40: struct BoundColumnReferenceInfo {
41: 	string name;
42: 	optional_idx query_location;
43: };
44: 
45: struct BindResult {
46: 	BindResult() {
47: 	}
48: 	explicit BindResult(const Exception &ex) : error(ex) {
49: 	}
50: 	explicit BindResult(const string &error_msg) : error(ExceptionType::BINDER, error_msg) {
51: 	}
52: 	explicit BindResult(ErrorData error) : error(std::move(error)) {
53: 	}
54: 	explicit BindResult(unique_ptr<Expression> expr) : expression(std::move(expr)) {
55: 	}
56: 
57: 	bool HasError() const {
58: 		return error.HasError();
59: 	}
60: 	void SetError(const string &error_message) {
61: 		error = ErrorData(ExceptionType::BINDER, error_message);
62: 	}
63: 
64: 	unique_ptr<Expression> expression;
65: 	ErrorData error;
66: };
67: 
68: class ExpressionBinder {
69: 	friend class StackChecker<ExpressionBinder>;
70: 
71: public:
72: 	ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder = false);
73: 	virtual ~ExpressionBinder();
74: 
75: 	//! The target type that should result from the binder. If the result is not of this type, a cast to this type will
76: 	//! be added. Defaults to INVALID.
77: 	LogicalType target_type;
78: 
79: 	optional_ptr<DummyBinding> macro_binding;
80: 	optional_ptr<vector<DummyBinding>> lambda_bindings;
81: 
82: public:
83: 	unique_ptr<Expression> Bind(unique_ptr<ParsedExpression> &expr, optional_ptr<LogicalType> result_type = nullptr,
84: 	                            bool root_expression = true);
85: 
86: 	//! Returns whether or not any columns have been bound by the expression binder
87: 	bool HasBoundColumns() {
88: 		return !bound_columns.empty();
89: 	}
90: 	const vector<BoundColumnReferenceInfo> &GetBoundColumns() {
91: 		return bound_columns;
92: 	}
93: 
94: 	void SetCatalogLookupCallback(catalog_entry_callback_t callback);
95: 	ErrorData Bind(unique_ptr<ParsedExpression> &expr, idx_t depth, bool root_expression = false);
96: 
97: 	//! Returns the STRUCT_EXTRACT operator expression
98: 	unique_ptr<ParsedExpression> CreateStructExtract(unique_ptr<ParsedExpression> base, const string &field_name);
99: 	//! Returns a STRUCT_PACK function expression
100: 	unique_ptr<ParsedExpression> CreateStructPack(ColumnRefExpression &col_ref);
101: 
102: 	BindResult BindQualifiedColumnName(ColumnRefExpression &colref, const string &table_name);
103: 
104: 	//! Returns a qualified column reference from a column name
105: 	unique_ptr<ParsedExpression> QualifyColumnName(const string &column_name, ErrorData &error);
106: 	//! Returns a qualified column reference from a column reference with column_names.size() > 2
107: 	unique_ptr<ParsedExpression> QualifyColumnNameWithManyDots(ColumnRefExpression &col_ref, ErrorData &error);
108: 	//! Returns a qualified column reference from a column reference
109: 	unique_ptr<ParsedExpression> QualifyColumnName(ColumnRefExpression &col_ref, ErrorData &error);
110: 	//! Enables special-handling of lambda parameters by tracking them in the lambda_params vector
111: 	void QualifyColumnNamesInLambda(FunctionExpression &function, vector<unordered_set<string>> &lambda_params);
112: 	//! Recursively qualifies the column references in the (children) of the expression. Passes on the
113: 	//! within_function_expression state from outer expressions, or sets it
114: 	void QualifyColumnNames(unique_ptr<ParsedExpression> &expr, vector<unordered_set<string>> &lambda_params,
115: 	                        const bool within_function_expression = false);
116: 	//! Entry point for qualifying the column references of the expression
117: 	static void QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr);
118: 
119: 	static bool PushCollation(ClientContext &context, unique_ptr<Expression> &source, const LogicalType &sql_type);
120: 	static void TestCollation(ClientContext &context, const string &collation);
121: 
122: 	BindResult BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr, ErrorData error_message);
123: 
124: 	void BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, ErrorData &error);
125: 	static void ExtractCorrelatedExpressions(Binder &binder, Expression &expr);
126: 
127: 	static bool ContainsNullType(const LogicalType &type);
128: 	static LogicalType ExchangeNullType(const LogicalType &type);
129: 	static bool ContainsType(const LogicalType &type, LogicalTypeId target);
130: 	static LogicalType ExchangeType(const LogicalType &type, LogicalTypeId target, LogicalType new_type);
131: 
132: 	virtual bool QualifyColumnAlias(const ColumnRefExpression &colref);
133: 
134: 	//! Bind the given expression. Unlike Bind(), this does *not* mute the given ParsedExpression.
135: 	//! Exposed to be used from sub-binders that aren't subclasses of ExpressionBinder.
136: 	virtual BindResult BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth,
137: 	                                  bool root_expression = false);
138: 
139: 	//! FIXME: Generalise this for extensibility.
140: 	//! Recursively replaces macro parameters with the provided input parameters.
141: 	void ReplaceMacroParameters(unique_ptr<ParsedExpression> &expr, vector<unordered_set<string>> &lambda_params);
142: 	//! Enables special-handling of lambda parameters during macro replacement by tracking them in the lambda_params
143: 	//! vector.
144: 	void ReplaceMacroParametersInLambda(FunctionExpression &function, vector<unordered_set<string>> &lambda_params);
145: 	//! Recursively qualifies column references in ON CONFLICT DO UPDATE SET expressions.
146: 	void DoUpdateSetQualify(unique_ptr<ParsedExpression> &expr, const string &table_name,
147: 	                        vector<unordered_set<string>> &lambda_params);
148: 	//! Enables special-handling of lambda parameters during ON CONFLICT TO UPDATE SET qualification by tracking them in
149: 	//! the lambda_params vector.
150: 	void DoUpdateSetQualifyInLambda(FunctionExpression &function, const string &table_name,
151: 	                                vector<unordered_set<string>> &lambda_params);
152: 
153: 	static LogicalType GetExpressionReturnType(const Expression &expr);
154: 
155: private:
156: 	//! Maximum stack depth
157: 	static constexpr const idx_t MAXIMUM_STACK_DEPTH = 128;
158: 	//! Current stack depth
159: 	idx_t stack_depth = DConstants::INVALID_INDEX;
160: 
161: 	void InitializeStackCheck();
162: 	StackChecker<ExpressionBinder> StackCheck(const ParsedExpression &expr, idx_t extra_stack = 1);
163: 
164: protected:
165: 	BindResult BindExpression(BetweenExpression &expr, idx_t depth);
166: 	BindResult BindExpression(CaseExpression &expr, idx_t depth);
167: 	BindResult BindExpression(CollateExpression &expr, idx_t depth);
168: 	BindResult BindExpression(CastExpression &expr, idx_t depth);
169: 	BindResult BindExpression(ColumnRefExpression &expr, idx_t depth);
170: 	BindResult BindExpression(LambdaRefExpression &expr, idx_t depth);
171: 	BindResult BindExpression(ComparisonExpression &expr, idx_t depth);
172: 	BindResult BindExpression(ConjunctionExpression &expr, idx_t depth);
173: 	BindResult BindExpression(ConstantExpression &expr, idx_t depth);
174: 	BindResult BindExpression(FunctionExpression &expr, idx_t depth, unique_ptr<ParsedExpression> &expr_ptr);
175: 	BindResult BindExpression(LambdaExpression &expr, idx_t depth, const LogicalType &list_child_type,
176: 	                          optional_ptr<bind_lambda_function_t> bind_lambda_function);
177: 	BindResult BindExpression(OperatorExpression &expr, idx_t depth);
178: 	BindResult BindExpression(ParameterExpression &expr, idx_t depth);
179: 	BindResult BindExpression(SubqueryExpression &expr, idx_t depth);
180: 	BindResult BindPositionalReference(unique_ptr<ParsedExpression> &expr, idx_t depth, bool root_expression);
181: 
182: 	void TransformCapturedLambdaColumn(unique_ptr<Expression> &original, unique_ptr<Expression> &replacement,
183: 	                                   BoundLambdaExpression &bound_lambda_expr,
184: 	                                   const optional_ptr<bind_lambda_function_t> bind_lambda_function,
185: 	                                   const LogicalType &list_child_type);
186: 	void CaptureLambdaColumns(BoundLambdaExpression &bound_lambda_expr, unique_ptr<Expression> &expr,
187: 	                          const optional_ptr<bind_lambda_function_t> bind_lambda_function,
188: 	                          const LogicalType &list_child_type);
189: 
190: 	static unique_ptr<ParsedExpression> GetSQLValueFunction(const string &column_name);
191: 
192: 	LogicalType ResolveOperatorType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);
193: 	LogicalType ResolveCoalesceType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);
194: 	LogicalType ResolveNotType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);
195: 
196: protected:
197: 	virtual BindResult BindGroupingFunction(OperatorExpression &op, idx_t depth);
198: 	virtual BindResult BindFunction(FunctionExpression &expr, ScalarFunctionCatalogEntry &function, idx_t depth);
199: 	virtual BindResult BindLambdaFunction(FunctionExpression &expr, ScalarFunctionCatalogEntry &function, idx_t depth);
200: 	virtual BindResult BindAggregate(FunctionExpression &expr, AggregateFunctionCatalogEntry &function, idx_t depth);
201: 	virtual BindResult BindUnnest(FunctionExpression &expr, idx_t depth, bool root_expression);
202: 	virtual BindResult BindMacro(FunctionExpression &expr, ScalarMacroCatalogEntry &macro, idx_t depth,
203: 	                             unique_ptr<ParsedExpression> &expr_ptr);
204: 
205: 	virtual string UnsupportedAggregateMessage();
206: 	virtual string UnsupportedUnnestMessage();
207: 	optional_ptr<CatalogEntry> GetCatalogEntry(CatalogType type, const string &catalog, const string &schema,
208: 	                                           const string &name, OnEntryNotFound on_entry_not_found,
209: 	                                           QueryErrorContext &error_context);
210: 
211: 	Binder &binder;
212: 	ClientContext &context;
213: 	optional_ptr<ExpressionBinder> stored_binder;
214: 	vector<BoundColumnReferenceInfo> bound_columns;
215: 
216: 	//! Returns true if the function name is an alias for the UNNEST function
217: 	static bool IsUnnestFunction(const string &function_name);
218: 	BindResult TryBindLambdaOrJson(FunctionExpression &function, idx_t depth, CatalogEntry &func);
219: };
220: 
221: } // namespace duckdb
[end of src/include/duckdb/planner/expression_binder.hpp]
[start of src/planner/binder/expression/bind_function_expression.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp"
3: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/scalar_macro_catalog_entry.hpp"
5: #include "duckdb/execution/expression_executor.hpp"
6: #include "duckdb/function/function_binder.hpp"
7: #include "duckdb/parser/expression/function_expression.hpp"
8: #include "duckdb/parser/expression/lambda_expression.hpp"
9: #include "duckdb/planner/binder.hpp"
10: #include "duckdb/planner/expression/bound_cast_expression.hpp"
11: #include "duckdb/planner/expression/bound_constant_expression.hpp"
12: #include "duckdb/planner/expression/bound_function_expression.hpp"
13: #include "duckdb/planner/expression/bound_lambda_expression.hpp"
14: #include "duckdb/planner/expression/bound_reference_expression.hpp"
15: #include "duckdb/planner/expression_binder.hpp"
16: 
17: namespace duckdb {
18: 
19: BindResult ExpressionBinder::TryBindLambdaOrJson(FunctionExpression &function, idx_t depth, CatalogEntry &func) {
20: 
21: 	auto lambda_bind_result = BindLambdaFunction(function, func.Cast<ScalarFunctionCatalogEntry>(), depth);
22: 	if (!lambda_bind_result.HasError()) {
23: 		return lambda_bind_result;
24: 	}
25: 
26: 	auto json_bind_result = BindFunction(function, func.Cast<ScalarFunctionCatalogEntry>(), depth);
27: 	if (!json_bind_result.HasError()) {
28: 		return json_bind_result;
29: 	}
30: 
31: 	return BindResult("failed to bind function, either: " + lambda_bind_result.error.RawMessage() +
32: 	                  "\n"
33: 	                  " or: " +
34: 	                  json_bind_result.error.RawMessage());
35: }
36: 
37: BindResult ExpressionBinder::BindExpression(FunctionExpression &function, idx_t depth,
38:                                             unique_ptr<ParsedExpression> &expr_ptr) {
39: 	// lookup the function in the catalog
40: 	QueryErrorContext error_context(function.query_location);
41: 	binder.BindSchemaOrCatalog(function.catalog, function.schema);
42: 	auto func = GetCatalogEntry(CatalogType::SCALAR_FUNCTION_ENTRY, function.catalog, function.schema,
43: 	                            function.function_name, OnEntryNotFound::RETURN_NULL, error_context);
44: 	if (!func) {
45: 		// function was not found - check if we this is a table function
46: 		auto table_func = GetCatalogEntry(CatalogType::TABLE_FUNCTION_ENTRY, function.catalog, function.schema,
47: 		                                  function.function_name, OnEntryNotFound::RETURN_NULL, error_context);
48: 		if (table_func) {
49: 			throw BinderException(function,
50: 			                      "Function \"%s\" is a table function but it was used as a scalar function. This "
51: 			                      "function has to be called in a FROM clause (similar to a table).",
52: 			                      function.function_name);
53: 		}
54: 		// not a table function - check if the schema is set
55: 		if (!function.schema.empty()) {
56: 			// the schema is set - check if we can turn this the schema into a column ref
57: 			ErrorData error;
58: 			unique_ptr<ColumnRefExpression> colref;
59: 			if (function.catalog.empty()) {
60: 				colref = make_uniq<ColumnRefExpression>(function.schema);
61: 			} else {
62: 				colref = make_uniq<ColumnRefExpression>(function.schema, function.catalog);
63: 			}
64: 			auto new_colref = QualifyColumnName(*colref, error);
65: 			bool is_col = !error.HasError();
66: 			bool is_col_alias = QualifyColumnAlias(*colref);
67: 
68: 			if (is_col || is_col_alias) {
69: 				// we can! transform this into a function call on the column
70: 				// i.e. "x.lower()" becomes "lower(x)"
71: 				function.children.insert(function.children.begin(), std::move(colref));
72: 				function.catalog = INVALID_CATALOG;
73: 				function.schema = INVALID_SCHEMA;
74: 			}
75: 		}
76: 		// rebind the function
77: 		func = GetCatalogEntry(CatalogType::SCALAR_FUNCTION_ENTRY, function.catalog, function.schema,
78: 		                       function.function_name, OnEntryNotFound::THROW_EXCEPTION, error_context);
79: 	}
80: 
81: 	if (func->type != CatalogType::AGGREGATE_FUNCTION_ENTRY &&
82: 	    (function.distinct || function.filter || !function.order_bys->orders.empty())) {
83: 		throw InvalidInputException("Function \"%s\" is a %s. \"DISTINCT\", \"FILTER\", and \"ORDER BY\" are only "
84: 		                            "applicable to aggregate functions.",
85: 		                            function.function_name, CatalogTypeToString(func->type));
86: 	}
87: 
88: 	switch (func->type) {
89: 	case CatalogType::SCALAR_FUNCTION_ENTRY: {
90: 		if (function.IsLambdaFunction()) {
91: 			return TryBindLambdaOrJson(function, depth, *func);
92: 		}
93: 		return BindFunction(function, func->Cast<ScalarFunctionCatalogEntry>(), depth);
94: 	}
95: 	case CatalogType::MACRO_ENTRY:
96: 		// macro function
97: 		return BindMacro(function, func->Cast<ScalarMacroCatalogEntry>(), depth, expr_ptr);
98: 	default:
99: 		// aggregate function
100: 		return BindAggregate(function, func->Cast<AggregateFunctionCatalogEntry>(), depth);
101: 	}
102: }
103: 
104: BindResult ExpressionBinder::BindFunction(FunctionExpression &function, ScalarFunctionCatalogEntry &func, idx_t depth) {
105: 	// bind the children of the function expression
106: 	ErrorData error;
107: 
108: 	// bind of each child
109: 	for (idx_t i = 0; i < function.children.size(); i++) {
110: 		BindChild(function.children[i], depth, error);
111: 	}
112: 
113: 	if (error.HasError()) {
114: 		return BindResult(std::move(error));
115: 	}
116: 	if (binder.GetBindingMode() == BindingMode::EXTRACT_NAMES) {
117: 		return BindResult(make_uniq<BoundConstantExpression>(Value(LogicalType::SQLNULL)));
118: 	}
119: 
120: 	// all children bound successfully
121: 	// extract the children and types
122: 	vector<unique_ptr<Expression>> children;
123: 	for (idx_t i = 0; i < function.children.size(); i++) {
124: 		auto &child = BoundExpression::GetExpression(*function.children[i]);
125: 		children.push_back(std::move(child));
126: 	}
127: 
128: 	FunctionBinder function_binder(context);
129: 	auto result = function_binder.BindScalarFunction(func, std::move(children), error, function.is_operator, &binder);
130: 	if (!result) {
131: 		error.AddQueryLocation(function);
132: 		error.Throw();
133: 	}
134: 	if (result->type == ExpressionType::BOUND_FUNCTION) {
135: 		auto &bound_function = result->Cast<BoundFunctionExpression>();
136: 		if (bound_function.function.stability == FunctionStability::CONSISTENT_WITHIN_QUERY) {
137: 			binder.SetAlwaysRequireRebind();
138: 		}
139: 	}
140: 	return BindResult(std::move(result));
141: }
142: 
143: BindResult ExpressionBinder::BindLambdaFunction(FunctionExpression &function, ScalarFunctionCatalogEntry &func,
144:                                                 idx_t depth) {
145: 
146: 	// scalar functions with lambdas can never be overloaded
147: 	if (func.functions.functions.size() != 1) {
148: 		return BindResult("This scalar function does not support lambdas!");
149: 	}
150: 
151: 	// get the callback function for the lambda parameter types
152: 	auto &scalar_function = func.functions.functions.front();
153: 	auto &bind_lambda_function = scalar_function.bind_lambda;
154: 	if (!bind_lambda_function) {
155: 		return BindResult("This scalar function does not support lambdas!");
156: 	}
157: 
158: 	if (function.children.size() != 2) {
159: 		return BindResult("Invalid number of function arguments!");
160: 	}
161: 	D_ASSERT(function.children[1]->GetExpressionClass() == ExpressionClass::LAMBDA);
162: 
163: 	// bind the list parameter
164: 	ErrorData error;
165: 	BindChild(function.children[0], depth, error);
166: 	if (error.HasError()) {
167: 		return BindResult(std::move(error));
168: 	}
169: 
170: 	// get the logical type of the children of the list
171: 	auto &list_child = BoundExpression::GetExpression(*function.children[0]);
172: 	if (list_child->return_type.id() != LogicalTypeId::LIST && list_child->return_type.id() != LogicalTypeId::ARRAY &&
173: 	    list_child->return_type.id() != LogicalTypeId::SQLNULL &&
174: 	    list_child->return_type.id() != LogicalTypeId::UNKNOWN) {
175: 		return BindResult("Invalid LIST argument during lambda function binding!");
176: 	}
177: 
178: 	LogicalType list_child_type = list_child->return_type.id();
179: 	if (list_child->return_type.id() != LogicalTypeId::SQLNULL &&
180: 	    list_child->return_type.id() != LogicalTypeId::UNKNOWN) {
181: 
182: 		if (list_child->return_type.id() == LogicalTypeId::ARRAY) {
183: 			list_child_type = ArrayType::GetChildType(list_child->return_type);
184: 		} else {
185: 			list_child_type = ListType::GetChildType(list_child->return_type);
186: 		}
187: 	}
188: 
189: 	// bind the lambda parameter
190: 	auto &lambda_expr = function.children[1]->Cast<LambdaExpression>();
191: 	BindResult bind_lambda_result = BindExpression(lambda_expr, depth, list_child_type, &bind_lambda_function);
192: 
193: 	if (bind_lambda_result.HasError()) {
194: 		return BindResult(bind_lambda_result.error);
195: 	}
196: 
197: 	// successfully bound: replace the node with a BoundExpression
198: 	auto alias = function.children[1]->alias;
199: 	bind_lambda_result.expression->alias = alias;
200: 	if (!alias.empty()) {
201: 		bind_lambda_result.expression->alias = alias;
202: 	}
203: 	function.children[1] = make_uniq<BoundExpression>(std::move(bind_lambda_result.expression));
204: 
205: 	if (binder.GetBindingMode() == BindingMode::EXTRACT_NAMES) {
206: 		return BindResult(make_uniq<BoundConstantExpression>(Value(LogicalType::SQLNULL)));
207: 	}
208: 
209: 	// all children bound successfully
210: 	// extract the children and types
211: 	vector<unique_ptr<Expression>> children;
212: 	for (idx_t i = 0; i < function.children.size(); i++) {
213: 		auto &child = BoundExpression::GetExpression(*function.children[i]);
214: 		children.push_back(std::move(child));
215: 	}
216: 
217: 	// capture the (lambda) columns
218: 	auto &bound_lambda_expr = children.back()->Cast<BoundLambdaExpression>();
219: 	CaptureLambdaColumns(bound_lambda_expr, bound_lambda_expr.lambda_expr, &bind_lambda_function, list_child_type);
220: 
221: 	FunctionBinder function_binder(context);
222: 	unique_ptr<Expression> result =
223: 	    function_binder.BindScalarFunction(func, std::move(children), error, function.is_operator, &binder);
224: 	if (!result) {
225: 		error.AddQueryLocation(function);
226: 		error.Throw();
227: 	}
228: 
229: 	auto &bound_function_expr = result->Cast<BoundFunctionExpression>();
230: 	D_ASSERT(bound_function_expr.children.size() == 2);
231: 
232: 	// remove the lambda expression from the children
233: 	auto lambda = std::move(bound_function_expr.children.back());
234: 	bound_function_expr.children.pop_back();
235: 	auto &bound_lambda = lambda->Cast<BoundLambdaExpression>();
236: 
237: 	// push back (in reverse order) any nested lambda parameters so that we can later use them in the lambda
238: 	// expression (rhs). This happens after we bound the lambda expression of this depth. So it is relevant for
239: 	// correctly binding lambdas one level 'out'. Therefore, the current parameter count does not matter here.
240: 	idx_t offset = 0;
241: 	if (lambda_bindings) {
242: 		for (idx_t i = lambda_bindings->size(); i > 0; i--) {
243: 
244: 			auto &binding = (*lambda_bindings)[i - 1];
245: 			D_ASSERT(binding.names.size() == binding.types.size());
246: 
247: 			for (idx_t column_idx = binding.names.size(); column_idx > 0; column_idx--) {
248: 				auto bound_lambda_param = make_uniq<BoundReferenceExpression>(binding.names[column_idx - 1],
249: 				                                                              binding.types[column_idx - 1], offset);
250: 				offset++;
251: 				bound_function_expr.children.push_back(std::move(bound_lambda_param));
252: 			}
253: 		}
254: 	}
255: 
256: 	// push back the captures into the children vector
257: 	for (auto &capture : bound_lambda.captures) {
258: 		bound_function_expr.children.push_back(std::move(capture));
259: 	}
260: 
261: 	return BindResult(std::move(result));
262: }
263: 
264: BindResult ExpressionBinder::BindAggregate(FunctionExpression &expr, AggregateFunctionCatalogEntry &function,
265:                                            idx_t depth) {
266: 	return BindResult(BinderException(expr, UnsupportedAggregateMessage()));
267: }
268: 
269: BindResult ExpressionBinder::BindUnnest(FunctionExpression &expr, idx_t depth, bool root_expression) {
270: 	return BindResult(BinderException(expr, UnsupportedUnnestMessage()));
271: }
272: 
273: string ExpressionBinder::UnsupportedAggregateMessage() {
274: 	return "Aggregate functions are not supported here";
275: }
276: 
277: string ExpressionBinder::UnsupportedUnnestMessage() {
278: 	return "UNNEST not supported here";
279: }
280: 
281: optional_ptr<CatalogEntry> ExpressionBinder::GetCatalogEntry(CatalogType type, const string &catalog,
282:                                                              const string &schema, const string &name,
283:                                                              OnEntryNotFound on_entry_not_found,
284:                                                              QueryErrorContext &error_context) {
285: 	return binder.GetCatalogEntry(type, catalog, schema, name, on_entry_not_found, error_context);
286: }
287: 
288: } // namespace duckdb
[end of src/planner/binder/expression/bind_function_expression.cpp]
[start of src/planner/expression_binder.cpp]
1: #include "duckdb/planner/expression_binder.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
4: #include "duckdb/parser/expression/list.hpp"
5: #include "duckdb/parser/parsed_expression_iterator.hpp"
6: #include "duckdb/planner/binder.hpp"
7: #include "duckdb/planner/expression/list.hpp"
8: #include "duckdb/planner/expression_iterator.hpp"
9: 
10: namespace duckdb {
11: 
12: void ExpressionBinder::SetCatalogLookupCallback(catalog_entry_callback_t callback) {
13: 	binder.SetCatalogLookupCallback(std::move(callback));
14: }
15: 
16: ExpressionBinder::ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder)
17:     : binder(binder), context(context) {
18: 	InitializeStackCheck();
19: 	if (replace_binder) {
20: 		stored_binder = &binder.GetActiveBinder();
21: 		binder.SetActiveBinder(*this);
22: 	} else {
23: 		binder.PushExpressionBinder(*this);
24: 	}
25: }
26: 
27: ExpressionBinder::~ExpressionBinder() {
28: 	if (binder.HasActiveBinder()) {
29: 		if (stored_binder) {
30: 			binder.SetActiveBinder(*stored_binder);
31: 		} else {
32: 			binder.PopExpressionBinder();
33: 		}
34: 	}
35: }
36: 
37: void ExpressionBinder::InitializeStackCheck() {
38: 	if (binder.HasActiveBinder()) {
39: 		stack_depth = binder.GetActiveBinder().stack_depth;
40: 	} else {
41: 		stack_depth = 0;
42: 	}
43: }
44: 
45: StackChecker<ExpressionBinder> ExpressionBinder::StackCheck(const ParsedExpression &expr, idx_t extra_stack) {
46: 	D_ASSERT(stack_depth != DConstants::INVALID_INDEX);
47: 	if (stack_depth + extra_stack >= MAXIMUM_STACK_DEPTH) {
48: 		throw BinderException("Maximum recursion depth exceeded (Maximum: %llu) while binding \"%s\"",
49: 		                      MAXIMUM_STACK_DEPTH, expr.ToString());
50: 	}
51: 	return StackChecker<ExpressionBinder>(*this, extra_stack);
52: }
53: 
54: BindResult ExpressionBinder::BindExpression(unique_ptr<ParsedExpression> &expr, idx_t depth, bool root_expression) {
55: 	auto stack_checker = StackCheck(*expr);
56: 
57: 	auto &expr_ref = *expr;
58: 	switch (expr_ref.expression_class) {
59: 	case ExpressionClass::BETWEEN:
60: 		return BindExpression(expr_ref.Cast<BetweenExpression>(), depth);
61: 	case ExpressionClass::CASE:
62: 		return BindExpression(expr_ref.Cast<CaseExpression>(), depth);
63: 	case ExpressionClass::CAST:
64: 		return BindExpression(expr_ref.Cast<CastExpression>(), depth);
65: 	case ExpressionClass::COLLATE:
66: 		return BindExpression(expr_ref.Cast<CollateExpression>(), depth);
67: 	case ExpressionClass::COLUMN_REF:
68: 		return BindExpression(expr_ref.Cast<ColumnRefExpression>(), depth);
69: 	case ExpressionClass::LAMBDA_REF:
70: 		return BindExpression(expr_ref.Cast<LambdaRefExpression>(), depth);
71: 	case ExpressionClass::COMPARISON:
72: 		return BindExpression(expr_ref.Cast<ComparisonExpression>(), depth);
73: 	case ExpressionClass::CONJUNCTION:
74: 		return BindExpression(expr_ref.Cast<ConjunctionExpression>(), depth);
75: 	case ExpressionClass::CONSTANT:
76: 		return BindExpression(expr_ref.Cast<ConstantExpression>(), depth);
77: 	case ExpressionClass::FUNCTION: {
78: 		auto &function = expr_ref.Cast<FunctionExpression>();
79: 		if (IsUnnestFunction(function.function_name)) {
80: 			// special case, not in catalog
81: 			return BindUnnest(function, depth, root_expression);
82: 		}
83: 		// binding a function expression requires an extra parameter for macros
84: 		return BindExpression(function, depth, expr);
85: 	}
86: 	case ExpressionClass::LAMBDA:
87: 		return BindExpression(expr_ref.Cast<LambdaExpression>(), depth, LogicalTypeId::INVALID, nullptr);
88: 	case ExpressionClass::OPERATOR:
89: 		return BindExpression(expr_ref.Cast<OperatorExpression>(), depth);
90: 	case ExpressionClass::SUBQUERY:
91: 		return BindExpression(expr_ref.Cast<SubqueryExpression>(), depth);
92: 	case ExpressionClass::PARAMETER:
93: 		return BindExpression(expr_ref.Cast<ParameterExpression>(), depth);
94: 	case ExpressionClass::POSITIONAL_REFERENCE: {
95: 		return BindPositionalReference(expr, depth, root_expression);
96: 	}
97: 	case ExpressionClass::STAR:
98: 		return BindResult(BinderException(expr_ref, "STAR expression is not supported here"));
99: 	default:
100: 		throw NotImplementedException("Unimplemented expression class");
101: 	}
102: }
103: 
104: BindResult ExpressionBinder::BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr, ErrorData error_message) {
105: 	// try to bind in one of the outer queries, if the binding error occurred in a subquery
106: 	auto &active_binders = binder.GetActiveBinders();
107: 	// make a copy of the set of binders, so we can restore it later
108: 	auto binders = active_binders;
109: 	auto bind_error = std::move(error_message);
110: 	// we already failed with the current binder
111: 	active_binders.pop_back();
112: 	idx_t depth = 1;
113: 	while (!active_binders.empty()) {
114: 		auto &next_binder = active_binders.back().get();
115: 		ExpressionBinder::QualifyColumnNames(next_binder.binder, expr);
116: 		bind_error = next_binder.Bind(expr, depth);
117: 		if (!bind_error.HasError()) {
118: 			break;
119: 		}
120: 		depth++;
121: 		active_binders.pop_back();
122: 	}
123: 	active_binders = binders;
124: 	return BindResult(bind_error);
125: }
126: 
127: void ExpressionBinder::BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, ErrorData &error) {
128: 	if (expr) {
129: 		ErrorData bind_error = Bind(expr, depth);
130: 		if (!error.HasError()) {
131: 			error = std::move(bind_error);
132: 		}
133: 	}
134: }
135: 
136: void ExpressionBinder::ExtractCorrelatedExpressions(Binder &binder, Expression &expr) {
137: 	if (expr.type == ExpressionType::BOUND_COLUMN_REF) {
138: 		auto &bound_colref = expr.Cast<BoundColumnRefExpression>();
139: 		if (bound_colref.depth > 0) {
140: 			binder.AddCorrelatedColumn(CorrelatedColumnInfo(bound_colref));
141: 		}
142: 	}
143: 	ExpressionIterator::EnumerateChildren(expr,
144: 	                                      [&](Expression &child) { ExtractCorrelatedExpressions(binder, child); });
145: }
146: 
147: bool ExpressionBinder::ContainsType(const LogicalType &type, LogicalTypeId target) {
148: 	if (type.id() == target) {
149: 		return true;
150: 	}
151: 	switch (type.id()) {
152: 	case LogicalTypeId::STRUCT: {
153: 		auto child_count = StructType::GetChildCount(type);
154: 		for (idx_t i = 0; i < child_count; i++) {
155: 			if (ContainsType(StructType::GetChildType(type, i), target)) {
156: 				return true;
157: 			}
158: 		}
159: 		return false;
160: 	}
161: 	case LogicalTypeId::UNION: {
162: 		auto member_count = UnionType::GetMemberCount(type);
163: 		for (idx_t i = 0; i < member_count; i++) {
164: 			if (ContainsType(UnionType::GetMemberType(type, i), target)) {
165: 				return true;
166: 			}
167: 		}
168: 		return false;
169: 	}
170: 	case LogicalTypeId::LIST:
171: 	case LogicalTypeId::MAP:
172: 		return ContainsType(ListType::GetChildType(type), target);
173: 	case LogicalTypeId::ARRAY:
174: 		return ContainsType(ArrayType::GetChildType(type), target);
175: 	default:
176: 		return false;
177: 	}
178: }
179: 
180: LogicalType ExpressionBinder::ExchangeType(const LogicalType &type, LogicalTypeId target, LogicalType new_type) {
181: 	if (type.id() == target) {
182: 		return new_type;
183: 	}
184: 	switch (type.id()) {
185: 	case LogicalTypeId::STRUCT: {
186: 		// we make a copy of the child types of the struct here
187: 		auto child_types = StructType::GetChildTypes(type);
188: 		for (auto &child_type : child_types) {
189: 			child_type.second = ExchangeType(child_type.second, target, new_type);
190: 		}
191: 		return LogicalType::STRUCT(child_types);
192: 	}
193: 	case LogicalTypeId::UNION: {
194: 		auto member_types = UnionType::CopyMemberTypes(type);
195: 		for (auto &member_type : member_types) {
196: 			member_type.second = ExchangeType(member_type.second, target, new_type);
197: 		}
198: 		return LogicalType::UNION(std::move(member_types));
199: 	}
200: 	case LogicalTypeId::LIST:
201: 		return LogicalType::LIST(ExchangeType(ListType::GetChildType(type), target, new_type));
202: 	case LogicalTypeId::MAP:
203: 		return LogicalType::MAP(ExchangeType(ListType::GetChildType(type), target, new_type));
204: 	case LogicalTypeId::ARRAY:
205: 		return LogicalType::ARRAY(ExchangeType(ArrayType::GetChildType(type), target, new_type),
206: 		                          ArrayType::GetSize(type));
207: 	default:
208: 		return type;
209: 	}
210: }
211: 
212: bool ExpressionBinder::ContainsNullType(const LogicalType &type) {
213: 	return ContainsType(type, LogicalTypeId::SQLNULL);
214: }
215: 
216: LogicalType ExpressionBinder::ExchangeNullType(const LogicalType &type) {
217: 	return ExchangeType(type, LogicalTypeId::SQLNULL, LogicalType::INTEGER);
218: }
219: 
220: unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr, optional_ptr<LogicalType> result_type,
221:                                               bool root_expression) {
222: 	// bind the main expression
223: 	auto error_msg = Bind(expr, 0, root_expression);
224: 	if (error_msg.HasError()) {
225: 		// Try binding the correlated column. If binding the correlated column
226: 		// has error messages, those should be propagated up. So for the test case
227: 		// having subquery failed to bind:14 the real error message should be something like
228: 		// aggregate with constant input must be bound to a root node.
229: 		auto result = BindCorrelatedColumns(expr, error_msg);
230: 		if (result.HasError()) {
231: 			result.error.Throw();
232: 		}
233: 		auto &bound_expr = expr->Cast<BoundExpression>();
234: 		ExtractCorrelatedExpressions(binder, *bound_expr.expr);
235: 	}
236: 	auto &bound_expr = expr->Cast<BoundExpression>();
237: 	unique_ptr<Expression> result = std::move(bound_expr.expr);
238: 	if (target_type.id() != LogicalTypeId::INVALID) {
239: 		// the binder has a specific target type: add a cast to that type
240: 		result = BoundCastExpression::AddCastToType(context, std::move(result), target_type);
241: 	} else {
242: 		if (!binder.can_contain_nulls) {
243: 			// SQL NULL type is only used internally in the binder
244: 			// cast to INTEGER if we encounter it outside of the binder
245: 			if (ContainsNullType(result->return_type)) {
246: 				auto exchanged_type = ExchangeNullType(result->return_type);
247: 				result = BoundCastExpression::AddCastToType(context, std::move(result), exchanged_type);
248: 			}
249: 		}
250: 		if (result->return_type.id() == LogicalTypeId::UNKNOWN) {
251: 			throw ParameterNotResolvedException();
252: 		}
253: 	}
254: 	if (result_type) {
255: 		*result_type = result->return_type;
256: 	}
257: 	return result;
258: }
259: 
260: ErrorData ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr, idx_t depth, bool root_expression) {
261: 	// bind the node, but only if it has not been bound yet
262: 	auto query_location = expr->query_location;
263: 	auto &expression = *expr;
264: 	auto alias = expression.alias;
265: 	if (expression.GetExpressionClass() == ExpressionClass::BOUND_EXPRESSION) {
266: 		// already bound, don't bind it again
267: 		return ErrorData();
268: 	}
269: 	// bind the expression
270: 	BindResult result = BindExpression(expr, depth, root_expression);
271: 	if (result.HasError()) {
272: 		return std::move(result.error);
273: 	}
274: 	// successfully bound: replace the node with a BoundExpression
275: 	result.expression->query_location = query_location;
276: 	expr = make_uniq<BoundExpression>(std::move(result.expression));
277: 	auto &be = expr->Cast<BoundExpression>();
278: 	be.alias = alias;
279: 	if (!alias.empty()) {
280: 		be.expr->alias = alias;
281: 	}
282: 	return ErrorData();
283: }
284: 
285: bool ExpressionBinder::IsUnnestFunction(const string &function_name) {
286: 	return function_name == "unnest" || function_name == "unlist";
287: }
288: 
289: } // namespace duckdb
[end of src/planner/expression_binder.cpp]
[start of src/planner/expression_binder/aggregate_binder.cpp]
1: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
2: 
3: #include "duckdb/planner/binder.hpp"
4: 
5: namespace duckdb {
6: 
7: AggregateBinder::AggregateBinder(Binder &binder, ClientContext &context) : ExpressionBinder(binder, context, true) {
8: }
9: 
10: BindResult AggregateBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
11: 	auto &expr = *expr_ptr;
12: 	switch (expr.expression_class) {
13: 	case ExpressionClass::WINDOW:
14: 		throw ParserException("aggregate function calls cannot contain window function calls");
15: 	default:
16: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
17: 	}
18: }
19: 
20: string AggregateBinder::UnsupportedAggregateMessage() {
21: 	return "aggregate function calls cannot be nested";
22: }
23: } // namespace duckdb
[end of src/planner/expression_binder/aggregate_binder.cpp]
[start of src/planner/expression_binder/alter_binder.cpp]
1: #include "duckdb/planner/expression_binder/alter_binder.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
4: #include "duckdb/parser/expression/columnref_expression.hpp"
5: #include "duckdb/planner/expression/bound_reference_expression.hpp"
6: #include "duckdb/planner/table_binding.hpp"
7: 
8: namespace duckdb {
9: 
10: AlterBinder::AlterBinder(Binder &binder, ClientContext &context, TableCatalogEntry &table,
11:                          vector<LogicalIndex> &bound_columns, LogicalType target_type)
12:     : ExpressionBinder(binder, context), table(table), bound_columns(bound_columns) {
13: 	this->target_type = std::move(target_type);
14: }
15: 
16: BindResult AlterBinder::BindLambdaReference(LambdaRefExpression &expr, idx_t depth) {
17: 	D_ASSERT(lambda_bindings && expr.lambda_idx < lambda_bindings->size());
18: 	auto &lambda_ref = expr.Cast<LambdaRefExpression>();
19: 	return (*lambda_bindings)[expr.lambda_idx].Bind(lambda_ref, depth);
20: }
21: 
22: BindResult AlterBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
23: 	auto &expr = *expr_ptr;
24: 	switch (expr.GetExpressionClass()) {
25: 	case ExpressionClass::WINDOW:
26: 		return BindResult("window functions are not allowed in alter statement");
27: 	case ExpressionClass::SUBQUERY:
28: 		return BindResult("cannot use subquery in alter statement");
29: 	case ExpressionClass::COLUMN_REF:
30: 		return BindColumnReference(expr.Cast<ColumnRefExpression>(), depth);
31: 	default:
32: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
33: 	}
34: }
35: 
36: string AlterBinder::UnsupportedAggregateMessage() {
37: 	return "aggregate functions are not allowed in alter statement";
38: }
39: 
40: BindResult AlterBinder::BindColumnReference(ColumnRefExpression &col_ref, idx_t depth) {
41: 
42: 	// try binding as a lambda parameter
43: 	if (!col_ref.IsQualified()) {
44: 		auto lambda_ref = LambdaRefExpression::FindMatchingBinding(lambda_bindings, col_ref.GetName());
45: 		if (lambda_ref) {
46: 			return BindLambdaReference(lambda_ref->Cast<LambdaRefExpression>(), depth);
47: 		}
48: 	}
49: 
50: 	if (col_ref.column_names.size() > 1) {
51: 		return BindQualifiedColumnName(col_ref, table.name);
52: 	}
53: 
54: 	auto idx = table.GetColumnIndex(col_ref.column_names[0], true);
55: 	if (!idx.IsValid()) {
56: 		throw BinderException("Table does not contain column %s referenced in alter statement!",
57: 		                      col_ref.column_names[0]);
58: 	}
59: 	if (table.GetColumn(idx).Generated()) {
60: 		throw BinderException("Using generated columns in alter statement not supported");
61: 	}
62: 	bound_columns.push_back(idx);
63: 	return BindResult(make_uniq<BoundReferenceExpression>(table.GetColumn(idx).Type(), bound_columns.size() - 1));
64: }
65: 
66: } // namespace duckdb
[end of src/planner/expression_binder/alter_binder.cpp]
[start of src/planner/expression_binder/base_select_binder.cpp]
1: #include "duckdb/planner/expression_binder/base_select_binder.hpp"
2: 
3: #include "duckdb/common/string_util.hpp"
4: #include "duckdb/parser/expression/columnref_expression.hpp"
5: #include "duckdb/parser/expression/operator_expression.hpp"
6: #include "duckdb/planner/expression/bound_operator_expression.hpp"
7: #include "duckdb/planner/expression/bound_constant_expression.hpp"
8: #include "duckdb/parser/expression/window_expression.hpp"
9: #include "duckdb/planner/binder.hpp"
10: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
11: #include "duckdb/planner/expression/bound_case_expression.hpp"
12: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
13: #include "duckdb/planner/query_node/bound_select_node.hpp"
14: #include "duckdb/planner/expression_binder/select_bind_state.hpp"
15: 
16: namespace duckdb {
17: 
18: BaseSelectBinder::BaseSelectBinder(Binder &binder, ClientContext &context, BoundSelectNode &node,
19:                                    BoundGroupInformation &info)
20:     : ExpressionBinder(binder, context), inside_window(false), node(node), info(info) {
21: }
22: 
23: BindResult BaseSelectBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
24: 	auto &expr = *expr_ptr;
25: 	// check if the expression binds to one of the groups
26: 	auto group_index = TryBindGroup(expr);
27: 	if (group_index != DConstants::INVALID_INDEX) {
28: 		return BindGroup(expr, depth, group_index);
29: 	}
30: 	switch (expr.expression_class) {
31: 	case ExpressionClass::COLUMN_REF:
32: 		return BindColumnRef(expr_ptr, depth, root_expression);
33: 	case ExpressionClass::DEFAULT:
34: 		return BindResult("SELECT clause cannot contain DEFAULT clause");
35: 	case ExpressionClass::WINDOW:
36: 		return BindWindow(expr.Cast<WindowExpression>(), depth);
37: 	default:
38: 		return ExpressionBinder::BindExpression(expr_ptr, depth, root_expression);
39: 	}
40: }
41: 
42: idx_t BaseSelectBinder::TryBindGroup(ParsedExpression &expr) {
43: 	// first check the group alias map, if expr is a ColumnRefExpression
44: 	if (expr.type == ExpressionType::COLUMN_REF) {
45: 		auto &colref = expr.Cast<ColumnRefExpression>();
46: 		if (!colref.IsQualified()) {
47: 			auto alias_entry = info.alias_map.find(colref.column_names[0]);
48: 			if (alias_entry != info.alias_map.end()) {
49: 				// found entry!
50: 				return alias_entry->second;
51: 			}
52: 		}
53: 	}
54: 	// no alias reference found
55: 	// check the list of group columns for a match
56: 	auto entry = info.map.find(expr);
57: 	if (entry != info.map.end()) {
58: 		return entry->second;
59: 	}
60: #ifdef DEBUG
61: 	for (auto map_entry : info.map) {
62: 		D_ASSERT(!map_entry.first.get().Equals(expr));
63: 		D_ASSERT(!expr.Equals(map_entry.first.get()));
64: 	}
65: #endif
66: 	return DConstants::INVALID_INDEX;
67: }
68: 
69: BindResult BaseSelectBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
70: 	return ExpressionBinder::BindExpression(expr_ptr, depth);
71: }
72: 
73: BindResult BaseSelectBinder::BindGroupingFunction(OperatorExpression &op, idx_t depth) {
74: 	if (op.children.empty()) {
75: 		throw InternalException("GROUPING requires at least one child");
76: 	}
77: 	if (node.groups.group_expressions.empty()) {
78: 		return BindResult(BinderException(op, "GROUPING statement cannot be used without groups"));
79: 	}
80: 	if (op.children.size() >= 64) {
81: 		return BindResult(BinderException(op, "GROUPING statement cannot have more than 64 groups"));
82: 	}
83: 	vector<idx_t> group_indexes;
84: 	group_indexes.reserve(op.children.size());
85: 	for (auto &child : op.children) {
86: 		ExpressionBinder::QualifyColumnNames(binder, child);
87: 		auto idx = TryBindGroup(*child);
88: 		if (idx == DConstants::INVALID_INDEX) {
89: 			return BindResult(BinderException(op, "GROUPING child \"%s\" must be a grouping column", child->GetName()));
90: 		}
91: 		group_indexes.push_back(idx);
92: 	}
93: 	auto col_idx = node.grouping_functions.size();
94: 	node.grouping_functions.push_back(std::move(group_indexes));
95: 	return BindResult(make_uniq<BoundColumnRefExpression>(op.GetName(), LogicalType::BIGINT,
96: 	                                                      ColumnBinding(node.groupings_index, col_idx), depth));
97: }
98: 
99: BindResult BaseSelectBinder::BindGroup(ParsedExpression &expr, idx_t depth, idx_t group_index) {
100: 	auto it = info.collated_groups.find(group_index);
101: 	if (it != info.collated_groups.end()) {
102: 		// This is an implicitly collated group, so we need to refer to the first() aggregate
103: 		const auto &aggr_index = it->second;
104: 		auto uncollated_first_expression =
105: 		    make_uniq<BoundColumnRefExpression>(expr.GetName(), node.aggregates[aggr_index]->return_type,
106: 		                                        ColumnBinding(node.aggregate_index, aggr_index), depth);
107: 
108: 		if (node.groups.grouping_sets.size() <= 1) {
109: 			// if there are no more than two grouping sets, you can return the uncollated first expression.
110: 			// "first" meaning the aggreagte function.
111: 			return BindResult(std::move(uncollated_first_expression));
112: 		}
113: 
114: 		// otherwise we insert a case statement to return NULL when the collated group expression is NULL
115: 		// otherwise you can return the "first" of the uncollated expression.
116: 		auto &group = node.groups.group_expressions[group_index];
117: 		auto collated_group_expression = make_uniq<BoundColumnRefExpression>(
118: 		    expr.GetName(), group->return_type, ColumnBinding(node.group_index, group_index), depth);
119: 
120: 		auto sql_null = make_uniq<BoundConstantExpression>(Value(LogicalType::VARCHAR));
121: 		auto when_expr = make_uniq<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NULL, LogicalType::BOOLEAN);
122: 		when_expr->children.push_back(std::move(collated_group_expression));
123: 		auto then_expr = make_uniq<BoundConstantExpression>(Value(LogicalType::VARCHAR));
124: 		auto else_expr = std::move(uncollated_first_expression);
125: 		auto case_expr =
126: 		    make_uniq<BoundCaseExpression>(std::move(when_expr), std::move(then_expr), std::move(else_expr));
127: 		return BindResult(std::move(case_expr));
128: 	} else {
129: 		auto &group = node.groups.group_expressions[group_index];
130: 		return BindResult(make_uniq<BoundColumnRefExpression>(expr.GetName(), group->return_type,
131: 		                                                      ColumnBinding(node.group_index, group_index), depth));
132: 	}
133: }
134: 
135: } // namespace duckdb
[end of src/planner/expression_binder/base_select_binder.cpp]
[start of src/planner/expression_binder/constant_binder.cpp]
1: #include "duckdb/planner/expression_binder/constant_binder.hpp"
2: #include "duckdb/parser/expression/columnref_expression.hpp"
3: 
4: namespace duckdb {
5: 
6: ConstantBinder::ConstantBinder(Binder &binder, ClientContext &context, string clause)
7:     : ExpressionBinder(binder, context), clause(std::move(clause)) {
8: }
9: 
10: BindResult ConstantBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
11: 	auto &expr = *expr_ptr;
12: 	switch (expr.GetExpressionClass()) {
13: 	case ExpressionClass::COLUMN_REF: {
14: 		auto &colref = expr.Cast<ColumnRefExpression>();
15: 		if (!colref.IsQualified()) {
16: 			auto value_function = GetSQLValueFunction(colref.GetColumnName());
17: 			if (value_function) {
18: 				expr_ptr = std::move(value_function);
19: 				return BindExpression(expr_ptr, depth, root_expression);
20: 			}
21: 		}
22: 		return BindResult(clause + " cannot contain column names");
23: 	}
24: 	case ExpressionClass::SUBQUERY:
25: 		throw BinderException(clause + " cannot contain subqueries");
26: 	case ExpressionClass::DEFAULT:
27: 		return BindResult(clause + " cannot contain DEFAULT clause");
28: 	case ExpressionClass::WINDOW:
29: 		return BindResult(clause + " cannot contain window functions!");
30: 	default:
31: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
32: 	}
33: }
34: 
35: string ConstantBinder::UnsupportedAggregateMessage() {
36: 	return clause + " cannot contain aggregates!";
37: }
38: 
39: } // namespace duckdb
[end of src/planner/expression_binder/constant_binder.cpp]
[start of src/planner/expression_binder/group_binder.cpp]
1: #include "duckdb/planner/expression_binder/group_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/expression/constant_expression.hpp"
5: #include "duckdb/parser/query_node/select_node.hpp"
6: #include "duckdb/planner/expression/bound_constant_expression.hpp"
7: #include "duckdb/planner/expression_binder/select_bind_state.hpp"
8: #include "duckdb/common/to_string.hpp"
9: 
10: namespace duckdb {
11: 
12: GroupBinder::GroupBinder(Binder &binder, ClientContext &context, SelectNode &node, idx_t group_index,
13:                          SelectBindState &bind_state, case_insensitive_map_t<idx_t> &group_alias_map)
14:     : ExpressionBinder(binder, context), node(node), bind_state(bind_state), group_alias_map(group_alias_map),
15:       group_index(group_index) {
16: }
17: 
18: BindResult GroupBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
19: 	auto &expr = *expr_ptr;
20: 	if (root_expression && depth == 0) {
21: 		switch (expr.expression_class) {
22: 		case ExpressionClass::COLUMN_REF:
23: 			return BindColumnRef(expr.Cast<ColumnRefExpression>());
24: 		case ExpressionClass::CONSTANT:
25: 			return BindConstant(expr.Cast<ConstantExpression>());
26: 		case ExpressionClass::PARAMETER:
27: 			throw ParameterNotAllowedException("Parameter not supported in GROUP BY clause");
28: 		default:
29: 			break;
30: 		}
31: 	}
32: 	switch (expr.expression_class) {
33: 	case ExpressionClass::DEFAULT:
34: 		return BindResult("GROUP BY clause cannot contain DEFAULT clause");
35: 	case ExpressionClass::WINDOW:
36: 		return BindResult("GROUP BY clause cannot contain window functions!");
37: 	default:
38: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
39: 	}
40: }
41: 
42: string GroupBinder::UnsupportedAggregateMessage() {
43: 	return "GROUP BY clause cannot contain aggregates!";
44: }
45: 
46: BindResult GroupBinder::BindSelectRef(idx_t entry) {
47: 	if (used_aliases.find(entry) != used_aliases.end()) {
48: 		// the alias has already been bound to before!
49: 		// this happens if we group on the same alias twice
50: 		// e.g. GROUP BY k, k or GROUP BY 1, 1
51: 		// in this case, we can just replace the grouping with a constant since the second grouping has no effect
52: 		// (the constant grouping will be optimized out later)
53: 		return BindResult(make_uniq<BoundConstantExpression>(Value::INTEGER(42)));
54: 	}
55: 	if (entry >= node.select_list.size()) {
56: 		throw BinderException("GROUP BY term out of range - should be between 1 and %d", (int)node.select_list.size());
57: 	}
58: 	// we replace the root expression, also replace the unbound expression
59: 	unbound_expression = node.select_list[entry]->Copy();
60: 	// move the expression that this refers to here and bind it
61: 	auto select_entry = std::move(node.select_list[entry]);
62: 	auto binding = Bind(select_entry, nullptr, false);
63: 	// now replace the original expression in the select list with a reference to this group
64: 	group_alias_map[to_string(entry)] = bind_index;
65: 	node.select_list[entry] = make_uniq<ColumnRefExpression>(to_string(entry));
66: 	// insert into the set of used aliases
67: 	used_aliases.insert(entry);
68: 	return BindResult(std::move(binding));
69: }
70: 
71: BindResult GroupBinder::BindConstant(ConstantExpression &constant) {
72: 	// constant as root expression
73: 	if (!constant.value.type().IsIntegral()) {
74: 		// non-integral expression, we just leave the constant here.
75: 		return ExpressionBinder::BindExpression(constant, 0);
76: 	}
77: 	// INTEGER constant: we use the integer as an index into the select list (e.g. GROUP BY 1)
78: 	auto index = (idx_t)constant.value.GetValue<int64_t>();
79: 	return BindSelectRef(index - 1);
80: }
81: 
82: BindResult GroupBinder::BindColumnRef(ColumnRefExpression &colref) {
83: 	// columns in GROUP BY clauses:
84: 	// FIRST refer to the original tables, and
85: 	// THEN if no match is found refer to aliases in the SELECT list
86: 	// THEN if no match is found, refer to outer queries
87: 
88: 	// first try to bind to the base columns (original tables)
89: 	auto result = ExpressionBinder::BindExpression(colref, 0);
90: 	if (result.HasError()) {
91: 		if (colref.IsQualified()) {
92: 			// explicit table name: not an alias reference
93: 			return result;
94: 		}
95: 		// failed to bind the column and the node is the root expression with depth = 0
96: 		// check if refers to an alias in the select clause
97: 		auto alias_name = colref.column_names[0];
98: 		auto entry = bind_state.alias_map.find(alias_name);
99: 		if (entry == bind_state.alias_map.end()) {
100: 			// no matching alias found
101: 			return result;
102: 		}
103: 		result = BindResult(BindSelectRef(entry->second));
104: 		if (!result.HasError()) {
105: 			group_alias_map[alias_name] = bind_index;
106: 		}
107: 	}
108: 	return result;
109: }
110: 
111: } // namespace duckdb
[end of src/planner/expression_binder/group_binder.cpp]
[start of src/planner/expression_binder/having_binder.cpp]
1: #include "duckdb/planner/expression_binder/having_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/planner/binder.hpp"
5: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
6: #include "duckdb/common/string_util.hpp"
7: #include "duckdb/planner/query_node/bound_select_node.hpp"
8: 
9: namespace duckdb {
10: 
11: HavingBinder::HavingBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info,
12:                            AggregateHandling aggregate_handling)
13:     : BaseSelectBinder(binder, context, node, info), column_alias_binder(node.bind_state),
14:       aggregate_handling(aggregate_handling) {
15: 	target_type = LogicalType(LogicalTypeId::BOOLEAN);
16: }
17: 
18: BindResult HavingBinder::BindLambdaReference(LambdaRefExpression &expr, idx_t depth) {
19: 	D_ASSERT(lambda_bindings && expr.lambda_idx < lambda_bindings->size());
20: 	auto &lambda_ref = expr.Cast<LambdaRefExpression>();
21: 	return (*lambda_bindings)[expr.lambda_idx].Bind(lambda_ref, depth);
22: }
23: 
24: BindResult HavingBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
25: 
26: 	// Keep the original column name to return a meaningful error message.
27: 	auto col_ref = expr_ptr->Cast<ColumnRefExpression>();
28: 	const auto &column_name = col_ref.GetColumnName();
29: 
30: 	// Try binding as a lambda parameter
31: 	if (!col_ref.IsQualified()) {
32: 		auto lambda_ref = LambdaRefExpression::FindMatchingBinding(lambda_bindings, col_ref.GetName());
33: 		if (lambda_ref) {
34: 			return BindLambdaReference(lambda_ref->Cast<LambdaRefExpression>(), depth);
35: 		}
36: 		// column was not found - check if it is a SQL value function
37: 		auto value_function = GetSQLValueFunction(col_ref.GetColumnName());
38: 		if (value_function) {
39: 			return BindExpression(value_function, depth);
40: 		}
41: 	}
42: 
43: 	// Bind the alias.
44: 	BindResult alias_result;
45: 	auto found_alias = column_alias_binder.BindAlias(*this, expr_ptr, depth, root_expression, alias_result);
46: 	if (found_alias) {
47: 		if (depth > 0) {
48: 			throw BinderException("Having clause cannot reference alias \"%s\" in correlated subquery", column_name);
49: 		}
50: 		return alias_result;
51: 	}
52: 
53: 	if (aggregate_handling != AggregateHandling::FORCE_AGGREGATES) {
54: 		return BindResult(StringUtil::Format(
55: 		    "column %s must appear in the GROUP BY clause or be used in an aggregate function", column_name));
56: 	}
57: 
58: 	if (depth > 0) {
59: 		throw BinderException("Having clause cannot reference column \"%s\" in correlated subquery and group by all",
60: 		                      column_name);
61: 	}
62: 
63: 	auto expr = duckdb::BaseSelectBinder::BindColumnRef(expr_ptr, depth, root_expression);
64: 	if (expr.HasError()) {
65: 		return expr;
66: 	}
67: 
68: 	// Return a GROUP BY column reference expression.
69: 	auto return_type = expr.expression->return_type;
70: 	auto column_binding = ColumnBinding(node.group_index, node.groups.group_expressions.size());
71: 	auto group_ref = make_uniq<BoundColumnRefExpression>(return_type, column_binding);
72: 	node.groups.group_expressions.push_back(std::move(expr.expression));
73: 	return BindResult(std::move(group_ref));
74: }
75: 
76: BindResult HavingBinder::BindWindow(WindowExpression &expr, idx_t depth) {
77: 	return BindResult("HAVING clause cannot contain window functions!");
78: }
79: 
80: } // namespace duckdb
[end of src/planner/expression_binder/having_binder.cpp]
[start of src/planner/expression_binder/index_binder.cpp]
1: #include "duckdb/planner/expression_binder/index_binder.hpp"
2: 
3: #include "duckdb/parser/parsed_data/create_index_info.hpp"
4: #include "duckdb/parser/expression/columnref_expression.hpp"
5: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
6: #include "duckdb/planner/column_binding.hpp"
7: #include "duckdb/execution/index/bound_index.hpp"
8: #include "duckdb/execution/index/unbound_index.hpp"
9: #include "duckdb/main/config.hpp"
10: #include "duckdb/main/database.hpp"
11: 
12: namespace duckdb {
13: 
14: IndexBinder::IndexBinder(Binder &binder, ClientContext &context, optional_ptr<TableCatalogEntry> table,
15:                          optional_ptr<CreateIndexInfo> info)
16:     : ExpressionBinder(binder, context), table(table), info(info) {
17: }
18: 
19: unique_ptr<BoundIndex> IndexBinder::BindIndex(const UnboundIndex &unbound_index) {
20: 	auto &index_type_name = unbound_index.GetIndexType();
21: 	// Do we know the type of this index now?
22: 	auto index_type = context.db->config.GetIndexTypes().FindByName(index_type_name);
23: 	if (!index_type) {
24: 		throw MissingExtensionException("Cannot bind index '%s', unknown index type '%s'. You need to load the "
25: 		                                "extension that provides this index type before table '%s' can be modified.",
26: 		                                unbound_index.GetTableName(), index_type_name, unbound_index.GetTableName());
27: 	}
28: 
29: 	auto &create_info = unbound_index.GetCreateInfo();
30: 	auto &storage_info = unbound_index.GetStorageInfo();
31: 	auto &parsed_expressions = unbound_index.GetParsedExpressions();
32: 
33: 	// bind the parsed expressions to create unbound expressions
34: 	vector<unique_ptr<Expression>> unbound_expressions;
35: 	unbound_expressions.reserve(parsed_expressions.size());
36: 	for (auto &expr : parsed_expressions) {
37: 		auto copy = expr->Copy();
38: 		unbound_expressions.push_back(Bind(copy));
39: 	}
40: 
41: 	CreateIndexInput input(unbound_index.table_io_manager, unbound_index.db, create_info.constraint_type,
42: 	                       create_info.index_name, create_info.column_ids, unbound_expressions, storage_info,
43: 	                       create_info.options);
44: 
45: 	return index_type->create_instance(input);
46: }
47: 
48: BindResult IndexBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
49: 	auto &expr = *expr_ptr;
50: 	switch (expr.expression_class) {
51: 	case ExpressionClass::WINDOW:
52: 		return BindResult("window functions are not allowed in index expressions");
53: 	case ExpressionClass::SUBQUERY:
54: 		return BindResult("cannot use subquery in index expressions");
55: 	default:
56: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
57: 	}
58: }
59: 
60: string IndexBinder::UnsupportedAggregateMessage() {
61: 	return "aggregate functions are not allowed in index expressions";
62: }
63: 
64: } // namespace duckdb
[end of src/planner/expression_binder/index_binder.cpp]
[start of src/planner/expression_binder/insert_binder.cpp]
1: #include "duckdb/planner/expression_binder/insert_binder.hpp"
2: 
3: #include "duckdb/planner/expression/bound_default_expression.hpp"
4: 
5: namespace duckdb {
6: 
7: InsertBinder::InsertBinder(Binder &binder, ClientContext &context) : ExpressionBinder(binder, context) {
8: }
9: 
10: BindResult InsertBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
11: 	auto &expr = *expr_ptr;
12: 	switch (expr.GetExpressionClass()) {
13: 	case ExpressionClass::DEFAULT:
14: 		return BindResult("DEFAULT is not allowed here!");
15: 	case ExpressionClass::WINDOW:
16: 		return BindResult("INSERT statement cannot contain window functions!");
17: 	default:
18: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
19: 	}
20: }
21: 
22: string InsertBinder::UnsupportedAggregateMessage() {
23: 	return "INSERT statement cannot contain aggregates!";
24: }
25: 
26: } // namespace duckdb
[end of src/planner/expression_binder/insert_binder.cpp]
[start of src/planner/expression_binder/lateral_binder.cpp]
1: #include "duckdb/planner/expression_binder/lateral_binder.hpp"
2: #include "duckdb/planner/expression_iterator.hpp"
3: #include "duckdb/planner/logical_operator_visitor.hpp"
4: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
5: #include "duckdb/planner/expression/bound_subquery_expression.hpp"
6: #include "duckdb/planner/tableref/bound_joinref.hpp"
7: 
8: namespace duckdb {
9: 
10: LateralBinder::LateralBinder(Binder &binder, ClientContext &context) : ExpressionBinder(binder, context) {
11: }
12: 
13: void LateralBinder::ExtractCorrelatedColumns(Expression &expr) {
14: 	if (expr.type == ExpressionType::BOUND_COLUMN_REF) {
15: 		auto &bound_colref = expr.Cast<BoundColumnRefExpression>();
16: 		if (bound_colref.depth > 0) {
17: 			// add the correlated column info
18: 			CorrelatedColumnInfo info(bound_colref);
19: 			if (std::find(correlated_columns.begin(), correlated_columns.end(), info) == correlated_columns.end()) {
20: 				correlated_columns.push_back(std::move(info));
21: 			}
22: 		}
23: 	}
24: 	ExpressionIterator::EnumerateChildren(expr, [&](Expression &child) { ExtractCorrelatedColumns(child); });
25: }
26: 
27: BindResult LateralBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
28: 	if (depth == 0) {
29: 		throw InternalException("Lateral binder can only bind correlated columns");
30: 	}
31: 	auto result = ExpressionBinder::BindExpression(expr_ptr, depth);
32: 	if (result.HasError()) {
33: 		return result;
34: 	}
35: 	ExtractCorrelatedColumns(*result.expression);
36: 	return result;
37: }
38: 
39: BindResult LateralBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
40: 	auto &expr = *expr_ptr;
41: 	switch (expr.GetExpressionClass()) {
42: 	case ExpressionClass::DEFAULT:
43: 		return BindResult("LATERAL join cannot contain DEFAULT clause");
44: 	case ExpressionClass::WINDOW:
45: 		return BindResult("LATERAL join cannot contain window functions!");
46: 	case ExpressionClass::COLUMN_REF:
47: 		return BindColumnRef(expr_ptr, depth, root_expression);
48: 	default:
49: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
50: 	}
51: }
52: 
53: string LateralBinder::UnsupportedAggregateMessage() {
54: 	return "LATERAL join cannot contain aggregates!";
55: }
56: 
57: static void ReduceColumnRefDepth(BoundColumnRefExpression &expr,
58:                                  const vector<CorrelatedColumnInfo> &correlated_columns) {
59: 	// don't need to reduce this
60: 	if (expr.depth == 0) {
61: 		return;
62: 	}
63: 	for (auto &correlated : correlated_columns) {
64: 		if (correlated.binding == expr.binding) {
65: 			D_ASSERT(expr.depth > 1);
66: 			expr.depth--;
67: 			break;
68: 		}
69: 	}
70: }
71: 
72: static void ReduceColumnDepth(vector<CorrelatedColumnInfo> &columns,
73:                               const vector<CorrelatedColumnInfo> &affected_columns) {
74: 	for (auto &s_correlated : columns) {
75: 		for (auto &affected : affected_columns) {
76: 			if (affected == s_correlated) {
77: 				s_correlated.depth--;
78: 				break;
79: 			}
80: 		}
81: 	}
82: }
83: 
84: class ExpressionDepthReducerRecursive : public BoundNodeVisitor {
85: public:
86: 	explicit ExpressionDepthReducerRecursive(const vector<CorrelatedColumnInfo> &correlated)
87: 	    : correlated_columns(correlated) {
88: 	}
89: 
90: 	void VisitExpression(unique_ptr<Expression> &expression) override {
91: 		if (expression->type == ExpressionType::BOUND_COLUMN_REF) {
92: 			ReduceColumnRefDepth(expression->Cast<BoundColumnRefExpression>(), correlated_columns);
93: 		} else if (expression->type == ExpressionType::SUBQUERY) {
94: 			ReduceExpressionSubquery(expression->Cast<BoundSubqueryExpression>(), correlated_columns);
95: 		}
96: 		BoundNodeVisitor::VisitExpression(expression);
97: 	}
98: 
99: 	void VisitBoundTableRef(BoundTableRef &ref) override {
100: 		if (ref.type == TableReferenceType::JOIN) {
101: 			// rewrite correlated columns in child joins
102: 			auto &bound_join = ref.Cast<BoundJoinRef>();
103: 			ReduceColumnDepth(bound_join.correlated_columns, correlated_columns);
104: 		}
105: 		// visit the children of the table ref
106: 		BoundNodeVisitor::VisitBoundTableRef(ref);
107: 	}
108: 
109: 	static void ReduceExpressionSubquery(BoundSubqueryExpression &expr,
110: 	                                     const vector<CorrelatedColumnInfo> &correlated_columns) {
111: 		ReduceColumnDepth(expr.binder->correlated_columns, correlated_columns);
112: 		ExpressionDepthReducerRecursive recursive(correlated_columns);
113: 		recursive.VisitBoundQueryNode(*expr.subquery);
114: 	}
115: 
116: private:
117: 	const vector<CorrelatedColumnInfo> &correlated_columns;
118: };
119: 
120: class ExpressionDepthReducer : public LogicalOperatorVisitor {
121: public:
122: 	explicit ExpressionDepthReducer(const vector<CorrelatedColumnInfo> &correlated) : correlated_columns(correlated) {
123: 	}
124: 
125: protected:
126: 	unique_ptr<Expression> VisitReplace(BoundColumnRefExpression &expr, unique_ptr<Expression> *expr_ptr) override {
127: 		ReduceColumnRefDepth(expr, correlated_columns);
128: 		return nullptr;
129: 	}
130: 
131: 	unique_ptr<Expression> VisitReplace(BoundSubqueryExpression &expr, unique_ptr<Expression> *expr_ptr) override {
132: 		ExpressionDepthReducerRecursive::ReduceExpressionSubquery(expr, correlated_columns);
133: 		return nullptr;
134: 	}
135: 
136: 	const vector<CorrelatedColumnInfo> &correlated_columns;
137: };
138: 
139: void LateralBinder::ReduceExpressionDepth(LogicalOperator &op, const vector<CorrelatedColumnInfo> &correlated) {
140: 	ExpressionDepthReducer depth_reducer(correlated);
141: 	depth_reducer.VisitOperator(op);
142: }
143: 
144: } // namespace duckdb
[end of src/planner/expression_binder/lateral_binder.cpp]
[start of src/planner/expression_binder/qualify_binder.cpp]
1: #include "duckdb/planner/expression_binder/qualify_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/planner/binder.hpp"
5: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
6: #include "duckdb/common/string_util.hpp"
7: #include "duckdb/planner/query_node/bound_select_node.hpp"
8: #include "duckdb/parser/expression/window_expression.hpp"
9: 
10: namespace duckdb {
11: 
12: QualifyBinder::QualifyBinder(Binder &binder, ClientContext &context, BoundSelectNode &node, BoundGroupInformation &info)
13:     : BaseSelectBinder(binder, context, node, info), column_alias_binder(node.bind_state) {
14: 	target_type = LogicalType(LogicalTypeId::BOOLEAN);
15: }
16: 
17: BindResult QualifyBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
18: 	auto result = duckdb::BaseSelectBinder::BindColumnRef(expr_ptr, depth, root_expression);
19: 	if (!result.HasError()) {
20: 		return result;
21: 	}
22: 
23: 	// Keep the original column reference's string to return a meaningful error message.
24: 	auto expr_string = expr_ptr->Cast<ColumnRefExpression>().ToString();
25: 
26: 	// Try to bind as an alias.
27: 	BindResult alias_result;
28: 	auto found_alias = column_alias_binder.BindAlias(*this, expr_ptr, depth, root_expression, alias_result);
29: 	if (found_alias) {
30: 		return alias_result;
31: 	}
32: 
33: 	return BindResult(
34: 	    StringUtil::Format("Referenced column %s not found in FROM clause and can't find in alias map.", expr_string));
35: }
36: 
37: } // namespace duckdb
[end of src/planner/expression_binder/qualify_binder.cpp]
[start of src/planner/expression_binder/relation_binder.cpp]
1: #include "duckdb/planner/expression_binder/relation_binder.hpp"
2: 
3: namespace duckdb {
4: 
5: RelationBinder::RelationBinder(Binder &binder, ClientContext &context, string op)
6:     : ExpressionBinder(binder, context), op(std::move(op)) {
7: }
8: 
9: BindResult RelationBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
10: 	auto &expr = *expr_ptr;
11: 	switch (expr.expression_class) {
12: 	case ExpressionClass::AGGREGATE:
13: 		return BindResult("aggregate functions are not allowed in " + op);
14: 	case ExpressionClass::DEFAULT:
15: 		return BindResult(op + " cannot contain DEFAULT clause");
16: 	case ExpressionClass::SUBQUERY:
17: 		return BindResult("subqueries are not allowed in " + op);
18: 	case ExpressionClass::WINDOW:
19: 		return BindResult("window functions are not allowed in " + op);
20: 	default:
21: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
22: 	}
23: }
24: 
25: string RelationBinder::UnsupportedAggregateMessage() {
26: 	return "aggregate functions are not allowed in " + op;
27: }
28: 
29: } // namespace duckdb
[end of src/planner/expression_binder/relation_binder.cpp]
[start of src/planner/expression_binder/returning_binder.cpp]
1: #include "duckdb/planner/expression_binder/returning_binder.hpp"
2: 
3: #include "duckdb/planner/expression/bound_default_expression.hpp"
4: 
5: namespace duckdb {
6: 
7: ReturningBinder::ReturningBinder(Binder &binder, ClientContext &context) : ExpressionBinder(binder, context) {
8: }
9: 
10: BindResult ReturningBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
11: 	auto &expr = *expr_ptr;
12: 	switch (expr.GetExpressionClass()) {
13: 	case ExpressionClass::SUBQUERY:
14: 		return BindResult("SUBQUERY is not supported in returning statements");
15: 	case ExpressionClass::BOUND_SUBQUERY:
16: 		return BindResult("BOUND SUBQUERY is not supported in returning statements");
17: 	case ExpressionClass::COLUMN_REF:
18: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
19: 	default:
20: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
21: 	}
22: }
23: 
24: } // namespace duckdb
[end of src/planner/expression_binder/returning_binder.cpp]
[start of src/planner/expression_binder/update_binder.cpp]
1: #include "duckdb/planner/expression_binder/update_binder.hpp"
2: 
3: namespace duckdb {
4: 
5: UpdateBinder::UpdateBinder(Binder &binder, ClientContext &context) : ExpressionBinder(binder, context) {
6: }
7: 
8: BindResult UpdateBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
9: 	auto &expr = *expr_ptr;
10: 	switch (expr.expression_class) {
11: 	case ExpressionClass::WINDOW:
12: 		return BindResult("window functions are not allowed in UPDATE");
13: 	default:
14: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
15: 	}
16: }
17: 
18: string UpdateBinder::UnsupportedAggregateMessage() {
19: 	return "aggregate functions are not allowed in UPDATE";
20: }
21: 
22: } // namespace duckdb
[end of src/planner/expression_binder/update_binder.cpp]
[start of src/planner/expression_binder/where_binder.cpp]
1: #include "duckdb/planner/expression_binder/where_binder.hpp"
2: #include "duckdb/planner/expression_binder/column_alias_binder.hpp"
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: 
5: namespace duckdb {
6: 
7: WhereBinder::WhereBinder(Binder &binder, ClientContext &context, optional_ptr<ColumnAliasBinder> column_alias_binder)
8:     : ExpressionBinder(binder, context), column_alias_binder(column_alias_binder) {
9: 	target_type = LogicalType(LogicalTypeId::BOOLEAN);
10: }
11: 
12: BindResult WhereBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
13: 
14: 	auto result = ExpressionBinder::BindExpression(expr_ptr, depth);
15: 	if (!result.HasError() || !column_alias_binder) {
16: 		return result;
17: 	}
18: 
19: 	BindResult alias_result;
20: 	auto found_alias = column_alias_binder->BindAlias(*this, expr_ptr, depth, root_expression, alias_result);
21: 	if (found_alias) {
22: 		return alias_result;
23: 	}
24: 
25: 	return result;
26: }
27: 
28: BindResult WhereBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {
29: 	auto &expr = *expr_ptr;
30: 	switch (expr.GetExpressionClass()) {
31: 	case ExpressionClass::DEFAULT:
32: 		return BindResult("WHERE clause cannot contain DEFAULT clause");
33: 	case ExpressionClass::WINDOW:
34: 		return BindResult("WHERE clause cannot contain window functions!");
35: 	case ExpressionClass::COLUMN_REF:
36: 		return BindColumnRef(expr_ptr, depth, root_expression);
37: 	default:
38: 		return ExpressionBinder::BindExpression(expr_ptr, depth);
39: 	}
40: }
41: 
42: string WhereBinder::UnsupportedAggregateMessage() {
43: 	return "WHERE clause cannot contain aggregates!";
44: }
45: 
46: } // namespace duckdb
[end of src/planner/expression_binder/where_binder.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: