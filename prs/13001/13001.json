{
  "repo": "duckdb/duckdb",
  "pull_number": 13001,
  "instance_id": "duckdb__duckdb-13001",
  "issue_numbers": [
    "12988",
    "12988"
  ],
  "base_commit": "5d97fdf44e2fbbc557f2d27f97e67b695a24aef3",
  "patch": "diff --git a/src/common/exception/binder_exception.cpp b/src/common/exception/binder_exception.cpp\nindex 458c563c0ea8..55db8386a17d 100644\n--- a/src/common/exception/binder_exception.cpp\n+++ b/src/common/exception/binder_exception.cpp\n@@ -44,4 +44,9 @@ BinderException BinderException::NoMatchingFunction(const string &name, const ve\n \t    extra_info);\n }\n \n+BinderException BinderException::Unsupported(ParsedExpression &expr, const string &message) {\n+\tauto extra_info = Exception::InitializeExtraInfo(\"UNSUPPORTED\", expr.query_location);\n+\treturn BinderException(message, extra_info);\n+}\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/common/exception/binder_exception.hpp b/src/include/duckdb/common/exception/binder_exception.hpp\nindex cd5bfe9ff1e7..59e1b5e73129 100644\n--- a/src/include/duckdb/common/exception/binder_exception.hpp\n+++ b/src/include/duckdb/common/exception/binder_exception.hpp\n@@ -46,6 +46,7 @@ class BinderException : public Exception {\n \t                                      QueryErrorContext context = QueryErrorContext());\n \tstatic BinderException NoMatchingFunction(const string &name, const vector<LogicalType> &arguments,\n \t                                          const vector<string> &candidates);\n+\tstatic BinderException Unsupported(ParsedExpression &expr, const string &message);\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 394750ccb812..1131d545a340 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -193,6 +193,8 @@ class ExpressionBinder {\n \tLogicalType ResolveCoalesceType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);\n \tLogicalType ResolveNotType(OperatorExpression &op, vector<unique_ptr<Expression>> &children);\n \n+\tBindResult BindUnsupportedExpression(ParsedExpression &expr, idx_t depth, const string &message);\n+\n protected:\n \tvirtual BindResult BindGroupingFunction(OperatorExpression &op, idx_t depth);\n \tvirtual BindResult BindFunction(FunctionExpression &expr, ScalarFunctionCatalogEntry &function, idx_t depth);\ndiff --git a/src/planner/binder/expression/bind_function_expression.cpp b/src/planner/binder/expression/bind_function_expression.cpp\nindex f1f137a834d3..e550c9d175d3 100644\n--- a/src/planner/binder/expression/bind_function_expression.cpp\n+++ b/src/planner/binder/expression/bind_function_expression.cpp\n@@ -263,11 +263,11 @@ BindResult ExpressionBinder::BindLambdaFunction(FunctionExpression &function, Sc\n \n BindResult ExpressionBinder::BindAggregate(FunctionExpression &expr, AggregateFunctionCatalogEntry &function,\n                                            idx_t depth) {\n-\treturn BindResult(BinderException(expr, UnsupportedAggregateMessage()));\n+\treturn BindUnsupportedExpression(expr, depth, UnsupportedAggregateMessage());\n }\n \n BindResult ExpressionBinder::BindUnnest(FunctionExpression &expr, idx_t depth, bool root_expression) {\n-\treturn BindResult(BinderException(expr, UnsupportedUnnestMessage()));\n+\treturn BindUnsupportedExpression(expr, depth, UnsupportedUnnestMessage());\n }\n \n string ExpressionBinder::UnsupportedAggregateMessage() {\ndiff --git a/src/planner/expression_binder.cpp b/src/planner/expression_binder.cpp\nindex 4551525b62c7..3cf5c339f9c8 100644\n--- a/src/planner/expression_binder.cpp\n+++ b/src/planner/expression_binder.cpp\n@@ -6,6 +6,7 @@\n #include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/planner/expression/list.hpp\"\n #include \"duckdb/planner/expression_iterator.hpp\"\n+#include \"duckdb/common/operator/cast_operators.hpp\"\n \n namespace duckdb {\n \n@@ -95,12 +96,100 @@ BindResult ExpressionBinder::BindExpression(unique_ptr<ParsedExpression> &expr,\n \t\treturn BindPositionalReference(expr, depth, root_expression);\n \t}\n \tcase ExpressionClass::STAR:\n-\t\treturn BindResult(BinderException(expr_ref, \"STAR expression is not supported here\"));\n+\t\treturn BindResult(BinderException::Unsupported(expr_ref, \"STAR expression is not supported here\"));\n \tdefault:\n \t\tthrow NotImplementedException(\"Unimplemented expression class\");\n \t}\n }\n \n+static bool CombineMissingColumns(ErrorData &current, ErrorData new_error) {\n+\tauto &current_info = current.ExtraInfo();\n+\tauto &new_info = new_error.ExtraInfo();\n+\tauto current_entry = current_info.find(\"error_subtype\");\n+\tauto new_entry = new_info.find(\"error_subtype\");\n+\tif (current_entry == current_info.end() || new_entry == new_info.end()) {\n+\t\t// no subtype info in either expression\n+\t\treturn false;\n+\t}\n+\tif (current_entry->second != \"COLUMN_NOT_FOUND\" || new_entry->second != \"COLUMN_NOT_FOUND\") {\n+\t\t// either info is not a `COLUMN_NOT_FOUND`\n+\t\treturn false;\n+\t}\n+\tcurrent_entry = current_info.find(\"name\");\n+\tnew_entry = new_info.find(\"name\");\n+\tif (current_entry == current_info.end() || new_entry == new_info.end()) {\n+\t\t// no candidate info in either column\n+\t\treturn false;\n+\t}\n+\tif (current_entry->second != new_entry->second) {\n+\t\t// error does not concern the same name/column\n+\t\treturn false;\n+\t}\n+\tauto column_name = current_entry->second;\n+\tcurrent_entry = current_info.find(\"candidates\");\n+\tnew_entry = new_info.find(\"candidates\");\n+\tif (current_entry == current_info.end()) {\n+\t\t// no current candidates - use new candidates\n+\t\tcurrent = std::move(new_error);\n+\t\treturn true;\n+\t}\n+\tif (new_entry == new_info.end()) {\n+\t\t// no new candidates - use current candidates\n+\t\treturn true;\n+\t}\n+\t// both errors have candidates - combine the candidates\n+\tauto current_candidates = StringUtil::Split(current_entry->second, \",\");\n+\tauto new_candidates = StringUtil::Split(new_entry->second, \",\");\n+\tcurrent_candidates.insert(current_candidates.end(), new_candidates.begin(), new_candidates.end());\n+\n+\t// run the similarity ranking on both sets of candidates\n+\tunordered_set<string> candidates;\n+\tvector<pair<string, double>> scores;\n+\tfor (auto &candidate : current_candidates) {\n+\t\t// split by \".\" since the candidates might be in the form \"table.column\"\n+\t\tauto column_splits = StringUtil::Split(candidate, \".\");\n+\t\tif (column_splits.empty()) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tauto &candidate_column = column_splits.back();\n+\t\tauto entry = candidates.find(candidate);\n+\t\tif (entry != candidates.end()) {\n+\t\t\t// already found\n+\t\t\tcontinue;\n+\t\t}\n+\t\tauto score = StringUtil::SimilarityRating(candidate_column, column_name);\n+\t\tcandidates.insert(candidate);\n+\t\tscores.emplace_back(make_pair(std::move(candidate), score));\n+\t}\n+\t// get a new top-n\n+\tauto top_candidates = StringUtil::TopNStrings(scores);\n+\t// get query location\n+\tQueryErrorContext context;\n+\tcurrent_entry = current_info.find(\"position\");\n+\tnew_entry = current_info.find(\"position\");\n+\tuint64_t position;\n+\tif (current_entry != current_info.end() &&\n+\t    TryCast::Operation<string_t, uint64_t>(current_entry->second, position)) {\n+\t\tcontext = QueryErrorContext(position);\n+\t} else if (new_entry != new_info.end() && TryCast::Operation<string_t, uint64_t>(new_entry->second, position)) {\n+\t\tcontext = QueryErrorContext(position);\n+\t}\n+\t// generate a new (combined) error\n+\tcurrent = BinderException::ColumnNotFound(column_name, top_candidates, context);\n+\treturn true;\n+}\n+\n+static void CombineErrors(ErrorData &current, ErrorData new_error) {\n+\t// try to combine missing column exceptions in order to pick the most relevant one\n+\tif (CombineMissingColumns(current, new_error)) {\n+\t\t// keep the old info\n+\t\treturn;\n+\t}\n+\n+\t// override the error with the new one\n+\tcurrent = std::move(new_error);\n+}\n+\n BindResult ExpressionBinder::BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr, ErrorData error_message) {\n \t// try to bind in one of the outer queries, if the binding error occurred in a subquery\n \tauto &active_binders = binder.GetActiveBinders();\n@@ -113,10 +202,12 @@ BindResult ExpressionBinder::BindCorrelatedColumns(unique_ptr<ParsedExpression>\n \twhile (!active_binders.empty()) {\n \t\tauto &next_binder = active_binders.back().get();\n \t\tExpressionBinder::QualifyColumnNames(next_binder.binder, expr);\n-\t\tbind_error = next_binder.Bind(expr, depth);\n-\t\tif (!bind_error.HasError()) {\n+\t\tauto next_error = next_binder.Bind(expr, depth);\n+\t\tif (!next_error.HasError()) {\n+\t\t\tbind_error = std::move(next_error);\n \t\t\tbreak;\n \t\t}\n+\t\tCombineErrors(bind_error, std::move(next_error));\n \t\tdepth++;\n \t\tactive_binders.pop_back();\n \t}\n@@ -228,7 +319,8 @@ unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr\n \t\t// aggregate with constant input must be bound to a root node.\n \t\tauto result = BindCorrelatedColumns(expr, error_msg);\n \t\tif (result.HasError()) {\n-\t\t\tresult.error.Throw();\n+\t\t\tCombineErrors(error_msg, std::move(result.error));\n+\t\t\terror_msg.Throw();\n \t\t}\n \t\tauto &bound_expr = expr->Cast<BoundExpression>();\n \t\tExtractCorrelatedExpressions(binder, *bound_expr.expr);\n@@ -282,6 +374,19 @@ ErrorData ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr, idx_t depth\n \treturn ErrorData();\n }\n \n+BindResult ExpressionBinder::BindUnsupportedExpression(ParsedExpression &expr, idx_t depth, const string &message) {\n+\t// we always prefer to throw an error if it occurs in a child expression\n+\t// since that error might be more descriptive\n+\t// bind all children\n+\tErrorData result;\n+\tParsedExpressionIterator::EnumerateChildren(\n+\t    expr, [&](unique_ptr<ParsedExpression> &child) { BindChild(child, depth, result); });\n+\tif (result.HasError()) {\n+\t\treturn BindResult(std::move(result));\n+\t}\n+\treturn BindResult(BinderException::Unsupported(expr, message));\n+}\n+\n bool ExpressionBinder::IsUnnestFunction(const string &function_name) {\n \treturn function_name == \"unnest\" || function_name == \"unlist\";\n }\ndiff --git a/src/planner/expression_binder/aggregate_binder.cpp b/src/planner/expression_binder/aggregate_binder.cpp\nindex cf17293482b5..353002b5a84c 100644\n--- a/src/planner/expression_binder/aggregate_binder.cpp\n+++ b/src/planner/expression_binder/aggregate_binder.cpp\n@@ -11,7 +11,7 @@ BindResult AggregateBinder::BindExpression(unique_ptr<ParsedExpression> &expr_pt\n \tauto &expr = *expr_ptr;\n \tswitch (expr.expression_class) {\n \tcase ExpressionClass::WINDOW:\n-\t\tthrow ParserException(\"aggregate function calls cannot contain window function calls\");\n+\t\tthrow BinderException::Unsupported(expr, \"aggregate function calls cannot contain window function calls\");\n \tdefault:\n \t\treturn ExpressionBinder::BindExpression(expr_ptr, depth);\n \t}\ndiff --git a/src/planner/expression_binder/alter_binder.cpp b/src/planner/expression_binder/alter_binder.cpp\nindex e8c4d547066e..797e37111640 100644\n--- a/src/planner/expression_binder/alter_binder.cpp\n+++ b/src/planner/expression_binder/alter_binder.cpp\n@@ -23,9 +23,9 @@ BindResult AlterBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, i\n \tauto &expr = *expr_ptr;\n \tswitch (expr.GetExpressionClass()) {\n \tcase ExpressionClass::WINDOW:\n-\t\treturn BindResult(\"window functions are not allowed in alter statement\");\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"window functions are not allowed in alter statement\"));\n \tcase ExpressionClass::SUBQUERY:\n-\t\treturn BindResult(\"cannot use subquery in alter statement\");\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"cannot use subquery in alter statement\"));\n \tcase ExpressionClass::COLUMN_REF:\n \t\treturn BindColumnReference(expr.Cast<ColumnRefExpression>(), depth);\n \tdefault:\ndiff --git a/src/planner/expression_binder/base_select_binder.cpp b/src/planner/expression_binder/base_select_binder.cpp\nindex 30a1eeaaa269..a8b1addc0889 100644\n--- a/src/planner/expression_binder/base_select_binder.cpp\n+++ b/src/planner/expression_binder/base_select_binder.cpp\n@@ -31,7 +31,7 @@ BindResult BaseSelectBinder::BindExpression(unique_ptr<ParsedExpression> &expr_p\n \tcase ExpressionClass::COLUMN_REF:\n \t\treturn BindColumnRef(expr_ptr, depth, root_expression);\n \tcase ExpressionClass::DEFAULT:\n-\t\treturn BindResult(\"SELECT clause cannot contain DEFAULT clause\");\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"SELECT clause cannot contain DEFAULT clause\"));\n \tcase ExpressionClass::WINDOW:\n \t\treturn BindWindow(expr.Cast<WindowExpression>(), depth);\n \tdefault:\ndiff --git a/src/planner/expression_binder/constant_binder.cpp b/src/planner/expression_binder/constant_binder.cpp\nindex fb93f363429a..97a65ba311d8 100644\n--- a/src/planner/expression_binder/constant_binder.cpp\n+++ b/src/planner/expression_binder/constant_binder.cpp\n@@ -19,14 +19,14 @@ BindResult ConstantBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr\n \t\t\t\treturn BindExpression(expr_ptr, depth, root_expression);\n \t\t\t}\n \t\t}\n-\t\treturn BindResult(clause + \" cannot contain column names\");\n+\t\treturn BindUnsupportedExpression(expr, depth, clause + \" cannot contain column names\");\n \t}\n \tcase ExpressionClass::SUBQUERY:\n \t\tthrow BinderException(clause + \" cannot contain subqueries\");\n \tcase ExpressionClass::DEFAULT:\n-\t\treturn BindResult(clause + \" cannot contain DEFAULT clause\");\n+\t\treturn BindUnsupportedExpression(expr, depth, clause + \" cannot contain DEFAULT clause\");\n \tcase ExpressionClass::WINDOW:\n-\t\treturn BindResult(clause + \" cannot contain window functions!\");\n+\t\treturn BindUnsupportedExpression(expr, depth, clause + \" cannot contain window functions!\");\n \tdefault:\n \t\treturn ExpressionBinder::BindExpression(expr_ptr, depth);\n \t}\ndiff --git a/src/planner/expression_binder/group_binder.cpp b/src/planner/expression_binder/group_binder.cpp\nindex cbf25d76d649..2514a8b675e2 100644\n--- a/src/planner/expression_binder/group_binder.cpp\n+++ b/src/planner/expression_binder/group_binder.cpp\n@@ -31,9 +31,9 @@ BindResult GroupBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, i\n \t}\n \tswitch (expr.expression_class) {\n \tcase ExpressionClass::DEFAULT:\n-\t\treturn BindResult(\"GROUP BY clause cannot contain DEFAULT clause\");\n+\t\treturn BindUnsupportedExpression(expr, depth, \"GROUP BY clause cannot contain DEFAULT clause\");\n \tcase ExpressionClass::WINDOW:\n-\t\treturn BindResult(\"GROUP BY clause cannot contain window functions!\");\n+\t\treturn BindUnsupportedExpression(expr, depth, \"GROUP BY clause cannot contain window functions!\");\n \tdefault:\n \t\treturn ExpressionBinder::BindExpression(expr_ptr, depth);\n \t}\ndiff --git a/src/planner/expression_binder/having_binder.cpp b/src/planner/expression_binder/having_binder.cpp\nindex 937c36c25e50..27b0124bcb93 100644\n--- a/src/planner/expression_binder/having_binder.cpp\n+++ b/src/planner/expression_binder/having_binder.cpp\n@@ -1,6 +1,7 @@\n #include \"duckdb/planner/expression_binder/having_binder.hpp\"\n \n #include \"duckdb/parser/expression/columnref_expression.hpp\"\n+#include \"duckdb/parser/expression/window_expression.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/planner/expression_binder/aggregate_binder.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n@@ -74,7 +75,7 @@ BindResult HavingBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, i\n }\n \n BindResult HavingBinder::BindWindow(WindowExpression &expr, idx_t depth) {\n-\treturn BindResult(\"HAVING clause cannot contain window functions!\");\n+\treturn BindResult(BinderException::Unsupported(expr, \"HAVING clause cannot contain window functions!\"));\n }\n \n } // namespace duckdb\ndiff --git a/src/planner/expression_binder/index_binder.cpp b/src/planner/expression_binder/index_binder.cpp\nindex 988948ae4066..e0138ecb3671 100644\n--- a/src/planner/expression_binder/index_binder.cpp\n+++ b/src/planner/expression_binder/index_binder.cpp\n@@ -49,9 +49,9 @@ BindResult IndexBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, i\n \tauto &expr = *expr_ptr;\n \tswitch (expr.expression_class) {\n \tcase ExpressionClass::WINDOW:\n-\t\treturn BindResult(\"window functions are not allowed in index expressions\");\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"window functions are not allowed in index expressions\"));\n \tcase ExpressionClass::SUBQUERY:\n-\t\treturn BindResult(\"cannot use subquery in index expressions\");\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"cannot use subquery in index expressions\"));\n \tdefault:\n \t\treturn ExpressionBinder::BindExpression(expr_ptr, depth);\n \t}\ndiff --git a/src/planner/expression_binder/insert_binder.cpp b/src/planner/expression_binder/insert_binder.cpp\nindex 84cd2a4f68ad..6b7d7450219f 100644\n--- a/src/planner/expression_binder/insert_binder.cpp\n+++ b/src/planner/expression_binder/insert_binder.cpp\n@@ -11,9 +11,9 @@ BindResult InsertBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr,\n \tauto &expr = *expr_ptr;\n \tswitch (expr.GetExpressionClass()) {\n \tcase ExpressionClass::DEFAULT:\n-\t\treturn BindResult(\"DEFAULT is not allowed here!\");\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"DEFAULT is not allowed here!\"));\n \tcase ExpressionClass::WINDOW:\n-\t\treturn BindResult(\"INSERT statement cannot contain window functions!\");\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"INSERT statement cannot contain window functions!\"));\n \tdefault:\n \t\treturn ExpressionBinder::BindExpression(expr_ptr, depth);\n \t}\ndiff --git a/src/planner/expression_binder/lateral_binder.cpp b/src/planner/expression_binder/lateral_binder.cpp\nindex 21ceb4e50c3f..a2c56611fee5 100644\n--- a/src/planner/expression_binder/lateral_binder.cpp\n+++ b/src/planner/expression_binder/lateral_binder.cpp\n@@ -40,9 +40,9 @@ BindResult LateralBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr,\n \tauto &expr = *expr_ptr;\n \tswitch (expr.GetExpressionClass()) {\n \tcase ExpressionClass::DEFAULT:\n-\t\treturn BindResult(\"LATERAL join cannot contain DEFAULT clause\");\n+\t\treturn BindUnsupportedExpression(expr, depth, \"LATERAL join cannot contain DEFAULT clause!\");\n \tcase ExpressionClass::WINDOW:\n-\t\treturn BindResult(\"LATERAL join cannot contain window functions!\");\n+\t\treturn BindUnsupportedExpression(expr, depth, \"LATERAL join cannot contain window functions!\");\n \tcase ExpressionClass::COLUMN_REF:\n \t\treturn BindColumnRef(expr_ptr, depth, root_expression);\n \tdefault:\ndiff --git a/src/planner/expression_binder/qualify_binder.cpp b/src/planner/expression_binder/qualify_binder.cpp\nindex e778c2034b1b..7b251a52d0cf 100644\n--- a/src/planner/expression_binder/qualify_binder.cpp\n+++ b/src/planner/expression_binder/qualify_binder.cpp\n@@ -30,8 +30,8 @@ BindResult QualifyBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr,\n \t\treturn alias_result;\n \t}\n \n-\treturn BindResult(\n-\t    StringUtil::Format(\"Referenced column %s not found in FROM clause and can't find in alias map.\", expr_string));\n+\treturn BindResult(BinderException(\n+\t    *expr_ptr, \"Referenced column %s not found in FROM clause and can't find in alias map.\", expr_string));\n }\n \n } // namespace duckdb\ndiff --git a/src/planner/expression_binder/relation_binder.cpp b/src/planner/expression_binder/relation_binder.cpp\nindex 4e0415742f76..d6cfe83cbaf9 100644\n--- a/src/planner/expression_binder/relation_binder.cpp\n+++ b/src/planner/expression_binder/relation_binder.cpp\n@@ -10,13 +10,13 @@ BindResult RelationBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr\n \tauto &expr = *expr_ptr;\n \tswitch (expr.expression_class) {\n \tcase ExpressionClass::AGGREGATE:\n-\t\treturn BindResult(\"aggregate functions are not allowed in \" + op);\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"aggregate functions are not allowed in \" + op));\n \tcase ExpressionClass::DEFAULT:\n-\t\treturn BindResult(op + \" cannot contain DEFAULT clause\");\n+\t\treturn BindResult(BinderException::Unsupported(expr, op + \" cannot contain DEFAULT clause\"));\n \tcase ExpressionClass::SUBQUERY:\n-\t\treturn BindResult(\"subqueries are not allowed in \" + op);\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"subqueries are not allowed in \" + op));\n \tcase ExpressionClass::WINDOW:\n-\t\treturn BindResult(\"window functions are not allowed in \" + op);\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"window functions are not allowed in \" + op));\n \tdefault:\n \t\treturn ExpressionBinder::BindExpression(expr_ptr, depth);\n \t}\ndiff --git a/src/planner/expression_binder/returning_binder.cpp b/src/planner/expression_binder/returning_binder.cpp\nindex 8d731b21b2b6..684bebc5396c 100644\n--- a/src/planner/expression_binder/returning_binder.cpp\n+++ b/src/planner/expression_binder/returning_binder.cpp\n@@ -11,9 +11,10 @@ BindResult ReturningBinder::BindExpression(unique_ptr<ParsedExpression> &expr_pt\n \tauto &expr = *expr_ptr;\n \tswitch (expr.GetExpressionClass()) {\n \tcase ExpressionClass::SUBQUERY:\n-\t\treturn BindResult(\"SUBQUERY is not supported in returning statements\");\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"SUBQUERY is not supported in returning statements\"));\n \tcase ExpressionClass::BOUND_SUBQUERY:\n-\t\treturn BindResult(\"BOUND SUBQUERY is not supported in returning statements\");\n+\t\treturn BindResult(\n+\t\t    BinderException::Unsupported(expr, \"BOUND SUBQUERY is not supported in returning statements\"));\n \tcase ExpressionClass::COLUMN_REF:\n \t\treturn ExpressionBinder::BindExpression(expr_ptr, depth);\n \tdefault:\ndiff --git a/src/planner/expression_binder/update_binder.cpp b/src/planner/expression_binder/update_binder.cpp\nindex 4537957e12a0..b3f7e6389a6f 100644\n--- a/src/planner/expression_binder/update_binder.cpp\n+++ b/src/planner/expression_binder/update_binder.cpp\n@@ -9,7 +9,7 @@ BindResult UpdateBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr,\n \tauto &expr = *expr_ptr;\n \tswitch (expr.expression_class) {\n \tcase ExpressionClass::WINDOW:\n-\t\treturn BindResult(\"window functions are not allowed in UPDATE\");\n+\t\treturn BindResult(BinderException::Unsupported(expr, \"window functions are not allowed in UPDATE\"));\n \tdefault:\n \t\treturn ExpressionBinder::BindExpression(expr_ptr, depth);\n \t}\ndiff --git a/src/planner/expression_binder/where_binder.cpp b/src/planner/expression_binder/where_binder.cpp\nindex 92b94cdb96e8..b8cf24ea27e0 100644\n--- a/src/planner/expression_binder/where_binder.cpp\n+++ b/src/planner/expression_binder/where_binder.cpp\n@@ -29,9 +29,9 @@ BindResult WhereBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, i\n \tauto &expr = *expr_ptr;\n \tswitch (expr.GetExpressionClass()) {\n \tcase ExpressionClass::DEFAULT:\n-\t\treturn BindResult(\"WHERE clause cannot contain DEFAULT clause\");\n+\t\treturn BindUnsupportedExpression(expr, depth, \"WHERE clause cannot contain DEFAULT clause\");\n \tcase ExpressionClass::WINDOW:\n-\t\treturn BindResult(\"WHERE clause cannot contain window functions!\");\n+\t\treturn BindUnsupportedExpression(expr, depth, \"WHERE clause cannot contain window functions!\");\n \tcase ExpressionClass::COLUMN_REF:\n \t\treturn BindColumnRef(expr_ptr, depth, root_expression);\n \tdefault:\n",
  "test_patch": "diff --git a/test/sql/aggregate/aggregates/histogram_table_function.test b/test/sql/aggregate/aggregates/histogram_table_function.test\nindex e6b9b876cec7..e5cbb5307c40 100644\n--- a/test/sql/aggregate/aggregates/histogram_table_function.test\n+++ b/test/sql/aggregate/aggregates/histogram_table_function.test\n@@ -22,6 +22,12 @@ SELECT * FROM histogram_values(integers, i, bin_count := 2)\n 80\t0\n 100\t1\n \n+# missing column\n+statement error\n+SELECT * FROM histogram_values(integers, k)\n+----\n+not found in FROM clause\n+\n statement ok\n INSERT INTO integers FROM range(127)\n \ndiff --git a/test/sql/binder/missing_column_error.test b/test/sql/binder/missing_column_error.test\nnew file mode 100644\nindex 000000000000..a50047454eaa\n--- /dev/null\n+++ b/test/sql/binder/missing_column_error.test\n@@ -0,0 +1,26 @@\n+# name: test/sql/binder/missing_column_error.test\n+# description: Correctly report missing column errors instead of lateral joins\n+# group: [binder]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create table customers (name varchar, age integer, something_easy_to_type_wrong integer, city varchar);\n+\n+statement ok\n+create table zipcodes (city varchar, zipcode varchar);\n+\n+statement error\n+with cte as (\n+  select *,\n+\t  rank() over (order by something_easy_to_typo_wrong) as rk\n+  from customers\n+  where age <= 42\n+)\n+select *\n+from zipcodes\n+join cte\n+using (city);\n+----\n+something_easy_to_type_wrong\ndiff --git a/test/sql/subquery/scalar/correlated_missing_columns.test b/test/sql/subquery/scalar/correlated_missing_columns.test\nnew file mode 100644\nindex 000000000000..1b89ee436ae6\n--- /dev/null\n+++ b/test/sql/subquery/scalar/correlated_missing_columns.test\n@@ -0,0 +1,57 @@\n+# name: test/sql/subquery/scalar/correlated_missing_columns.test\n+# description: Test correlated missing columns\n+# group: [scalar]\n+\n+require tpch\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CALL dbgen(sf=0);\n+\n+# verify that we can grab missing columns from either the correlated subquery or the outer (uncorrelated) subquery\n+statement error\n+SELECT (SELECT l_linestat FROM orders) FROM lineitem\n+----\n+lineitem.l_linestatus\n+\n+statement error\n+SELECT (SELECT l_returnfla FROM orders) FROM lineitem\n+----\n+lineitem.l_returnflag\n+\n+statement error\n+SELECT (SELECT o_totalp FROM orders) FROM lineitem\n+----\n+orders.o_totalprice\n+\n+# column exists in outer query but is used in an aggregate\n+statement error\n+SELECT * FROM lineitem WHERE (SELECT SUM(l_orderkey) > 0)\n+----\n+cannot contain aggregates\n+\n+# prefer missing column over unsupported\n+# where clause\n+statement error\n+SELECT * FROM lineitem WHERE (SELECT SUM(o_orderke) FROM orders)\n+----\n+o_orderkey\n+\n+statement error\n+SELECT * FROM lineitem WHERE (SELECT SUM(o_orderke) OVER () FROM orders)\n+----\n+o_orderkey\n+\n+# group by\n+statement error\n+SELECT * FROM lineitem GROUP BY (SELECT SUM(o_orderke) OVER () FROM orders)\n+----\n+o_orderkey\n+\n+# limit\n+statement error\n+SELECT * FROM lineitem LIMIT (SELECT SUM(o_orderke) FROM orders LIMIT 1)\n+----\n+o_orderkey\n",
  "problem_statement": "Improper error message: LATERAL join cannot contain window functions\n### What happens?\r\n\r\n```sql\r\n  create table customers (name varchar, age integer, something_easy_to_type_wrong integer, city varchar);\r\n  create table zipcodes (city varchar, zipcode varchar);\r\n  insert into customers values ('Alice', 24, 7, 'Seattle'),\r\n                              ('Bob', 34, 2, 'Portland'),\r\n                              ('Charlie', 23, 3, 'Seattle'),\r\n                              ('David', 36, 9, 'Portland'),\r\n                              ('Sam', 35, 5, 'Seattle');\r\n\r\n  insert into zipcodes values ('Seattle', '98101'), \r\n                              ('Portland', '97201');\r\n\r\n  with cte as (\r\n      select *,\r\n          rank() over (order by something_easy_to_typo_wrong) as rk\r\n      from customers\r\n      where age <= 42\r\n  )\r\n  select *\r\n  from zipcodes\r\n  join cte\r\n  using (city)\r\n```\r\nThe above SQL query emits the following error message:\r\n```\r\n Binder Error: LATERAL join cannot contain window functions!\r\n```\r\nIf we switch the join order as `from cte join zipcodes` (i.e., put the subquery `cte` on the LHS of the join), a super-friendly error message is produced:\r\n```\r\nBinder Error: Referenced column \"something_easy_to_typo_wrong\" not found in FROM clause!\r\nCandidate bindings: \"customers.something_easy_to_type_wrong\"\r\nLINE 15:             rank() over (order by something_easy_to_typo_wrong) as rk\r\n                                           ^\r\n```\r\nThe latter is exactly what everybody wants. Super helpful (thanks to the AMAZING effort the DuckDB team has done)! For the former case, however, if there are tons of (aggregate) window expressions in the subquery, we will have a poor chance of recognizing the problem.\r\n\r\n### To Reproduce\r\n\r\nSee the description above.\r\n\r\n### OS:\r\n\r\nUbuntu 22.04.2 LTS, aarch64\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nMark\r\n\r\n### Affiliation:\r\n\r\nbq\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have not tested with any build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNo - Other reason (please specify in the issue body)\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [ ] Yes, I have\nImproper error message: LATERAL join cannot contain window functions\n### What happens?\r\n\r\n```sql\r\n  create table customers (name varchar, age integer, something_easy_to_type_wrong integer, city varchar);\r\n  create table zipcodes (city varchar, zipcode varchar);\r\n  insert into customers values ('Alice', 24, 7, 'Seattle'),\r\n                              ('Bob', 34, 2, 'Portland'),\r\n                              ('Charlie', 23, 3, 'Seattle'),\r\n                              ('David', 36, 9, 'Portland'),\r\n                              ('Sam', 35, 5, 'Seattle');\r\n\r\n  insert into zipcodes values ('Seattle', '98101'), \r\n                              ('Portland', '97201');\r\n\r\n  with cte as (\r\n      select *,\r\n          rank() over (order by something_easy_to_typo_wrong) as rk\r\n      from customers\r\n      where age <= 42\r\n  )\r\n  select *\r\n  from zipcodes\r\n  join cte\r\n  using (city)\r\n```\r\nThe above SQL query emits the following error message:\r\n```\r\n Binder Error: LATERAL join cannot contain window functions!\r\n```\r\nIf we switch the join order as `from cte join zipcodes` (i.e., put the subquery `cte` on the LHS of the join), a super-friendly error message is produced:\r\n```\r\nBinder Error: Referenced column \"something_easy_to_typo_wrong\" not found in FROM clause!\r\nCandidate bindings: \"customers.something_easy_to_type_wrong\"\r\nLINE 15:             rank() over (order by something_easy_to_typo_wrong) as rk\r\n                                           ^\r\n```\r\nThe latter is exactly what everybody wants. Super helpful (thanks to the AMAZING effort the DuckDB team has done)! For the former case, however, if there are tons of (aggregate) window expressions in the subquery, we will have a poor chance of recognizing the problem.\r\n\r\n### To Reproduce\r\n\r\nSee the description above.\r\n\r\n### OS:\r\n\r\nUbuntu 22.04.2 LTS, aarch64\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nMark\r\n\r\n### Affiliation:\r\n\r\nbq\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have not tested with any build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNo - Other reason (please specify in the issue body)\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [ ] Yes, I have\n",
  "hints_text": "Thanks for reporting this, the error message there could indeed be improved.\nThanks for reporting this, the error message there could indeed be improved.",
  "created_at": "2024-07-15T21:04:56Z"
}