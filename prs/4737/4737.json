{
  "repo": "duckdb/duckdb",
  "pull_number": 4737,
  "instance_id": "duckdb__duckdb-4737",
  "issue_numbers": [
    "4679",
    "4696",
    "4696"
  ],
  "base_commit": "a991beaf1ba592595dc5ad159b2c5a4f0c2af5e0",
  "patch": "diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp\nindex 99988e5af2c2..777fffa2477e 100644\n--- a/src/catalog/catalog_entry/table_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp\n@@ -246,6 +246,9 @@ static void RenameExpression(ParsedExpression &expr, RenameColumnInfo &info) {\n \n unique_ptr<CatalogEntry> TableCatalogEntry::RenameColumn(ClientContext &context, RenameColumnInfo &info) {\n \tauto rename_idx = GetColumnIndex(info.old_name);\n+\tif (rename_idx == COLUMN_IDENTIFIER_ROW_ID) {\n+\t\tthrow CatalogException(\"Cannot rename rowid column\");\n+\t}\n \tauto create_info = make_unique<CreateTableInfo>(schema->name, name);\n \tcreate_info->temporary = temporary;\n \tfor (idx_t i = 0; i < columns.size(); i++) {\n@@ -348,6 +351,9 @@ unique_ptr<CatalogEntry> TableCatalogEntry::AddColumn(ClientContext &context, Ad\n unique_ptr<CatalogEntry> TableCatalogEntry::RemoveColumn(ClientContext &context, RemoveColumnInfo &info) {\n \tauto removed_index = GetColumnIndex(info.removed_column, info.if_column_exists);\n \tif (removed_index == DConstants::INVALID_INDEX) {\n+\t\tif (!info.if_column_exists) {\n+\t\t\tthrow CatalogException(\"Cannot drop column: rowid column cannot be dropped\");\n+\t\t}\n \t\treturn nullptr;\n \t}\n \n@@ -462,6 +468,9 @@ unique_ptr<CatalogEntry> TableCatalogEntry::RemoveColumn(ClientContext &context,\n unique_ptr<CatalogEntry> TableCatalogEntry::SetDefault(ClientContext &context, SetDefaultInfo &info) {\n \tauto create_info = make_unique<CreateTableInfo>(schema->name, name);\n \tauto default_idx = GetColumnIndex(info.column_name);\n+\tif (default_idx == COLUMN_IDENTIFIER_ROW_ID) {\n+\t\tthrow CatalogException(\"Cannot SET DEFAULT for rowid column\");\n+\t}\n \n \t// Copy all the columns, changing the value of the one that was specified by 'column_name'\n \tfor (idx_t i = 0; i < columns.size(); i++) {\ndiff --git a/src/catalog/catalog_set.cpp b/src/catalog/catalog_set.cpp\nindex 1bfe114d72c9..06d6f9c3c861 100644\n--- a/src/catalog/catalog_set.cpp\n+++ b/src/catalog/catalog_set.cpp\n@@ -192,8 +192,6 @@ bool CatalogSet::AlterEntry(ClientContext &context, const string &name, AlterInf\n \t\t\t}\n \t\t}\n \t}\n-\t//! Check the dependency manager to verify that there are no conflicting dependencies with this alter\n-\tcatalog.dependency_manager->AlterObject(context, entry, value.get());\n \n \tif (value->name != original_name) {\n \t\t// Do PutMapping and DeleteMapping after dependency check\n@@ -211,10 +209,18 @@ bool CatalogSet::AlterEntry(ClientContext &context, const string &name, AlterInf\n \talter_info->Serialize(serializer);\n \tBinaryData serialized_alter = serializer.GetData();\n \n+\tauto new_entry = value.get();\n+\n \t// push the old entry in the undo buffer for this transaction\n \ttransaction.PushCatalogEntry(value->child.get(), serialized_alter.data.get(), serialized_alter.size);\n \tentries[entry_index] = move(value);\n \n+\t// Check the dependency manager to verify that there are no conflicting dependencies with this alter\n+\t// Note that we do this AFTER the new entry has been entirely set up in the catalog set\n+\t// that is because in case the alter fails because of a dependency conflict, we need to be able to cleanly roll back\n+\t// to the old entry.\n+\tcatalog.dependency_manager->AlterObject(context, entry, new_entry);\n+\n \treturn true;\n }\n \ndiff --git a/src/common/exception.cpp b/src/common/exception.cpp\nindex 6fdb02c8591d..53b59251c687 100644\n--- a/src/common/exception.cpp\n+++ b/src/common/exception.cpp\n@@ -164,6 +164,8 @@ void Exception::ThrowAsTypeWithMessage(ExceptionType type, const string &message\n \t\tthrow ParameterNotAllowedException(message);\n \tcase ExceptionType::PARAMETER_NOT_RESOLVED:\n \t\tthrow ParameterNotResolvedException();\n+\tcase ExceptionType::FATAL:\n+\t\tthrow FatalException(message);\n \tdefault:\n \t\tthrow Exception(type, message);\n \t}\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex a991a3b9e433..602ebf7b81e6 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -405,6 +405,11 @@ PendingExecutionResult ClientContext::ExecuteTaskInternal(ClientContextLock &loc\n \t\t\tquery_progress = active_query->progress_bar->GetCurrentPercentage();\n \t\t}\n \t\treturn result;\n+\t} catch (FatalException &ex) {\n+\t\t// fatal exceptions invalidate the entire database\n+\t\tresult.SetError(PreservedError(ex));\n+\t\tauto &db = DatabaseInstance::GetDatabase(*this);\n+\t\tdb.Invalidate();\n \t} catch (const Exception &ex) {\n \t\tresult.SetError(PreservedError(ex));\n \t} catch (std::exception &ex) {\ndiff --git a/src/planner/binder/statement/bind_insert.cpp b/src/planner/binder/statement/bind_insert.cpp\nindex 7a8decb9f04f..12ce959aa2e7 100644\n--- a/src/planner/binder/statement/bind_insert.cpp\n+++ b/src/planner/binder/statement/bind_insert.cpp\n@@ -138,7 +138,10 @@ BoundStatement Binder::Bind(InsertStatement &stmt) {\n \t}\n \n \t// parse select statement and add to logical plan\n-\tauto root_select = Bind(*stmt.select_statement);\n+\tauto select_binder = Binder::CreateBinder(context, this);\n+\tauto root_select = select_binder->Bind(*stmt.select_statement);\n+\tMoveCorrelatedExpressions(*select_binder);\n+\n \tCheckInsertColumnCountMismatch(expected_columns, root_select.types.size(), !stmt.columns.empty(),\n \t                               table->name.c_str());\n \ndiff --git a/src/planner/binder/tableref/bind_joinref.cpp b/src/planner/binder/tableref/bind_joinref.cpp\nindex fc7627f7bd29..ba74f92f14e4 100644\n--- a/src/planner/binder/tableref/bind_joinref.cpp\n+++ b/src/planner/binder/tableref/bind_joinref.cpp\n@@ -103,6 +103,18 @@ string Binder::RetrieveUsingBinding(Binder &current_binder, UsingColumnSet *curr\n \treturn binding;\n }\n \n+static vector<string> RemoveDuplicateUsingColumns(const vector<string> &using_columns) {\n+\tvector<string> result;\n+\tcase_insensitive_set_t handled_columns;\n+\tfor (auto &using_column : using_columns) {\n+\t\tif (handled_columns.find(using_column) == handled_columns.end()) {\n+\t\t\thandled_columns.insert(using_column);\n+\t\t\tresult.push_back(using_column);\n+\t\t}\n+\t}\n+\treturn result;\n+}\n+\n unique_ptr<BoundTableRef> Binder::Bind(JoinRef &ref) {\n \tauto result = make_unique<BoundJoinRef>();\n \tresult->left_binder = Binder::CreateBinder(context, this);\n@@ -172,6 +184,8 @@ unique_ptr<BoundTableRef> Binder::Bind(JoinRef &ref) {\n \t\tD_ASSERT(!result->condition);\n \t\textra_using_columns = ref.using_columns;\n \t}\n+\textra_using_columns = RemoveDuplicateUsingColumns(extra_using_columns);\n+\n \tif (!extra_using_columns.empty()) {\n \t\tvector<UsingColumnSet *> left_using_bindings;\n \t\tvector<UsingColumnSet *> right_using_bindings;\ndiff --git a/src/planner/subquery/flatten_dependent_join.cpp b/src/planner/subquery/flatten_dependent_join.cpp\nindex 934243097cea..a9b99914dac7 100644\n--- a/src/planner/subquery/flatten_dependent_join.cpp\n+++ b/src/planner/subquery/flatten_dependent_join.cpp\n@@ -482,6 +482,9 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \tcase LogicalOperatorType::LOGICAL_ORDER_BY:\n \t\tplan->children[0] = PushDownDependentJoin(move(plan->children[0]));\n \t\treturn plan;\n+\tcase LogicalOperatorType::LOGICAL_RECURSIVE_CTE: {\n+\t\tthrow ParserException(\"Recursive CTEs not supported in correlated subquery\");\n+\t}\n \tdefault:\n \t\tthrow InternalException(\"Logical operator type \\\"%s\\\" for dependent join\", LogicalOperatorToString(plan->type));\n \t}\ndiff --git a/src/storage/checkpoint_manager.cpp b/src/storage/checkpoint_manager.cpp\nindex 9c763a280652..d0851d1e89aa 100644\n--- a/src/storage/checkpoint_manager.cpp\n+++ b/src/storage/checkpoint_manager.cpp\n@@ -81,7 +81,7 @@ void CheckpointManager::CreateCheckpoint() {\n \twal->Flush();\n \n \tif (config.options.checkpoint_abort == CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER) {\n-\t\tthrow IOException(\"Checkpoint aborted before header write because of PRAGMA checkpoint_abort flag\");\n+\t\tthrow FatalException(\"Checkpoint aborted before header write because of PRAGMA checkpoint_abort flag\");\n \t}\n \n \t// finally write the updated header\n@@ -90,7 +90,7 @@ void CheckpointManager::CreateCheckpoint() {\n \tblock_manager.WriteHeader(header);\n \n \tif (config.options.checkpoint_abort == CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE) {\n-\t\tthrow IOException(\"Checkpoint aborted before truncate because of PRAGMA checkpoint_abort flag\");\n+\t\tthrow FatalException(\"Checkpoint aborted before truncate because of PRAGMA checkpoint_abort flag\");\n \t}\n \n \t// truncate the WAL\ndiff --git a/src/storage/single_file_block_manager.cpp b/src/storage/single_file_block_manager.cpp\nindex cb7267d9c779..f272439b0268 100644\n--- a/src/storage/single_file_block_manager.cpp\n+++ b/src/storage/single_file_block_manager.cpp\n@@ -377,7 +377,7 @@ void SingleFileBlockManager::WriteHeader(DatabaseHeader header) {\n \n \tauto &config = DBConfig::GetConfig(db);\n \tif (config.options.checkpoint_abort == CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE) {\n-\t\tthrow IOException(\"Checkpoint aborted after free list write because of PRAGMA checkpoint_abort flag\");\n+\t\tthrow FatalException(\"Checkpoint aborted after free list write because of PRAGMA checkpoint_abort flag\");\n \t}\n \n \tif (!use_direct_io) {\n",
  "test_patch": "diff --git a/test/fuzzer/pedro/alter_dependency_conflict.test b/test/fuzzer/pedro/alter_dependency_conflict.test\nnew file mode 100644\nindex 000000000000..8d195f2e585c\n--- /dev/null\n+++ b/test/fuzzer/pedro/alter_dependency_conflict.test\n@@ -0,0 +1,28 @@\n+# name: test/fuzzer/pedro/alter_dependency_conflict.test\n+# description: Issue #4696: Alter table dependency conflict\n+# group: [pedro]\n+\n+load __TEST_DIR__/alter_dependency_conflict.db\n+\n+statement ok\n+CREATE TABLE t4 (c0 DATE, c3 VARCHAR(10));\n+\n+statement ok\n+CREATE INDEX i2 ON t4 (c3);\n+\n+# Catalog Error: Cannot alter entry \"t4\" because there are entries that depend on it.\n+statement error\n+ALTER TABLE t4 ADD c1 BLOB;\n+\n+# the table should still be in a usable state after the alter\n+statement ok\n+INSERT INTO t4 VALUES (NULL, NULL)\n+\n+statement ok\n+START TRANSACTION;\n+\n+statement ok\n+CREATE INDEX i3 ON t4 (c3);\n+\n+statement ok\n+COMMIT;\ndiff --git a/test/fuzzer/pedro/alter_table_rowid.test b/test/fuzzer/pedro/alter_table_rowid.test\nnew file mode 100644\nindex 000000000000..a1a7dc8e1fd7\n--- /dev/null\n+++ b/test/fuzzer/pedro/alter_table_rowid.test\n@@ -0,0 +1,21 @@\n+# name: test/fuzzer/pedro/alter_table_rowid.test\n+# description: Issue #4587: Alter table statements with rowid column\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t0(c0 INTEGER, c1 INTEGER);\n+\n+statement error\n+ALTER TABLE t0 DROP COLUMN rowid;\n+\n+statement error\n+ALTER TABLE t0 RENAME rowid TO ups;\n+\n+statement error\n+ALTER TABLE t0 ALTER rowid TYPE VARCHAR;\n+\n+statement error\n+ALTER TABLE t0 ALTER rowidx SET DEFAULT 0;\ndiff --git a/test/fuzzer/pedro/duplicate_cte.test b/test/fuzzer/pedro/duplicate_cte.test\nnew file mode 100644\nindex 000000000000..ce09b2195b6e\n--- /dev/null\n+++ b/test/fuzzer/pedro/duplicate_cte.test\n@@ -0,0 +1,17 @@\n+# name: test/fuzzer/pedro/duplicate_cte.test\n+# description: Issue #4571: Duplicate table name at CTE in INSERT statement\n+# group: [pedro]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE t0(c0 INT);\n+\n+statement ok\n+WITH t0 AS (SELECT 2) INSERT INTO t0 (WITH t0 AS (SELECT 2) SELECT 2);\n+\n+query I\n+SELECT * FROM t0\n+----\n+2\ndiff --git a/test/fuzzer/pedro/duplicate_using_clause.test b/test/fuzzer/pedro/duplicate_using_clause.test\nnew file mode 100644\nindex 000000000000..f201b1f38e08\n--- /dev/null\n+++ b/test/fuzzer/pedro/duplicate_using_clause.test\n@@ -0,0 +1,47 @@\n+# name: test/fuzzer/pedro/duplicate_using_clause.test\n+# description: Issue #4561: Binding assertion error\n+# group: [pedro]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE TABLE t1(c0 INT);\n+\n+query I\n+SELECT * FROM t1 JOIN t1 t2 USING (c0, c0)\n+----\n+\n+query II\n+SELECT * FROM (t1 JOIN t1 t2 USING (c0)), (SELECT 42)\n+----\n+\n+query II\n+SELECT * FROM (t1 JOIN t1 t2 USING (c0, c0)), (SELECT 42)\n+----\n+\n+statement ok\n+create table tbl as select 42 AS i;\n+\n+query I\n+select * from tbl t1 join tbl t2 using (i) join tbl t3 using (i);\n+----\n+42\n+\n+query I\n+select * from tbl t1 join tbl t2 using (i, i) join tbl t3 using (i, i, i);\n+----\n+42\n+\n+statement ok\n+create or replace table tbl as select 42 AS i, 84 as j;\n+\n+query II\n+select * from tbl t1 join tbl t2 using (i, j) join tbl t3 using (i, j);\n+----\n+42\t84\n+\n+query II\n+select * from tbl t1 join tbl t2 using (i, j, i) join tbl t3 using (i, i, i, j, i);\n+----\n+42\t84\ndiff --git a/test/fuzzer/pedro/incomplete_checkpoint.test b/test/fuzzer/pedro/incomplete_checkpoint.test\nnew file mode 100644\nindex 000000000000..3369662bd4c0\n--- /dev/null\n+++ b/test/fuzzer/pedro/incomplete_checkpoint.test\n@@ -0,0 +1,44 @@\n+# name: test/fuzzer/pedro/incomplete_checkpoint.test\n+# description: Issue #4644: Incomplete checkpoints issue\n+# group: [pedro]\n+\n+load __TEST_DIR__/incomplete_checkpoint.db\n+\n+require skip_reload\n+\n+statement ok\n+PRAGMA wal_autocheckpoint='1TB';\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE SCHEMA s1;\n+\n+statement ok\n+CHECKPOINT;\n+\n+statement ok\n+DROP SCHEMA s1;\n+\n+statement ok\n+CHECKPOINT;\n+\n+statement ok\n+PRAGMA DEBUG_CHECKPOINT_ABORT = 'after_free_list_write';\n+\n+statement ok\n+CREATE SCHEMA s3;\n+\n+# error IO Error: Checkpoint aborted after free list write because of PRAGMA checkpoint_abort flag\n+statement error\n+CHECKPOINT;\n+\n+# error IO Error: Checkpoint aborted after free list write because of PRAGMA checkpoint_abort flag\n+statement error\n+CHECKPOINT;\n+\n+restart\n+\n+statement ok\n+CREATE TABLE s3.integers(i INTEGER)\ndiff --git a/test/fuzzer/pedro/index_on_altered_table.test b/test/fuzzer/pedro/index_on_altered_table.test\nnew file mode 100644\nindex 000000000000..3696187fe85e\n--- /dev/null\n+++ b/test/fuzzer/pedro/index_on_altered_table.test\n@@ -0,0 +1,23 @@\n+# name: test/fuzzer/pedro/index_on_altered_table.test\n+# description: Issue #4696: Alter table transaction conflict\n+# group: [pedro]\n+\n+load __TEST_DIR__/index_on_altered_table.db\n+\n+statement ok\n+CREATE TABLE t4 (c0 DATE, c3 VARCHAR(10));\n+\n+statement ok con1\n+BEGIN TRANSACTION\n+\n+statement ok con1\n+ALTER TABLE t4 ADD c1 BLOB;\n+\n+statement error\n+CREATE INDEX i3 ON t4 (c3);\n+\n+statement ok con1\n+COMMIT;\n+\n+statement ok\n+CHECKPOINT\ndiff --git a/test/fuzzer/pedro/recursive_cte_dependent_join.test b/test/fuzzer/pedro/recursive_cte_dependent_join.test\nnew file mode 100644\nindex 000000000000..34a878f3c7d2\n--- /dev/null\n+++ b/test/fuzzer/pedro/recursive_cte_dependent_join.test\n@@ -0,0 +1,9 @@\n+# name: test/fuzzer/pedro/recursive_cte_dependent_join.test\n+# description: Issue #4679: Recursive CTE dependent join internal error\n+# group: [pedro]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement error\n+SELECT (WITH RECURSIVE t1 AS (SELECT 1 UNION SELECT 1 FROM t1 WHERE c2 < 3) SELECT 2 FROM t1) FROM (SELECT 1 c2) t1;\ndiff --git a/test/helpers/test_helpers.cpp b/test/helpers/test_helpers.cpp\nindex 7b24d33745e8..11d3c4f1358e 100644\n--- a/test/helpers/test_helpers.cpp\n+++ b/test/helpers/test_helpers.cpp\n@@ -33,15 +33,21 @@ bool NO_FAIL(unique_ptr<QueryResult> result) {\n \n void TestDeleteDirectory(string path) {\n \tunique_ptr<FileSystem> fs = FileSystem::CreateLocal();\n-\tif (fs->DirectoryExists(path)) {\n-\t\tfs->RemoveDirectory(path);\n+\ttry {\n+\t\tif (fs->DirectoryExists(path)) {\n+\t\t\tfs->RemoveDirectory(path);\n+\t\t}\n+\t} catch (...) {\n \t}\n }\n \n void TestDeleteFile(string path) {\n \tunique_ptr<FileSystem> fs = FileSystem::CreateLocal();\n-\tif (fs->FileExists(path)) {\n-\t\tfs->RemoveFile(path);\n+\ttry {\n+\t\tif (fs->FileExists(path)) {\n+\t\t\tfs->RemoveFile(path);\n+\t\t}\n+\t} catch (...) {\n \t}\n }\n \ndiff --git a/test/sql/storage/checkpoint_abort.test_slow b/test/sql/storage/checkpoint_abort.test_slow\nindex a436f8213b61..040bfbfcc5b6 100644\n--- a/test/sql/storage/checkpoint_abort.test_slow\n+++ b/test/sql/storage/checkpoint_abort.test_slow\n@@ -46,11 +46,6 @@ SELECT MIN(i), MAX(i), COUNT(*) FROM integers\n statement error\n CHECKPOINT;\n \n-query III\n-SELECT MIN(i), MAX(i), COUNT(*) FROM integers\n-----\n-1\t200000\t200000\n-\n restart\n \n # verify that the change was correctly loaded from disk\ndiff --git a/test/unittest.cpp b/test/unittest.cpp\nindex e54e172b37a1..16c80c3e0505 100644\n--- a/test/unittest.cpp\n+++ b/test/unittest.cpp\n@@ -28,7 +28,7 @@ int main(int argc, char *argv[]) {\n \tfor (int i = 0; i < argc; i++) {\n \t\tif (string(argv[i]) == \"--force-storage\") {\n \t\t\ttest_force_storage = true;\n-\t\t} else if (string(argv[i]) == \"--force-reload\") {\n+\t\t} else if (string(argv[i]) == \"--force-reload\" || string(argv[i]) == \"--force-restart\") {\n \t\t\ttest_force_reload = true;\n \t\t} else if (string(argv[i]) == \"--test-dir\") {\n \t\t\ttest_directory = string(argv[++i]);\n",
  "problem_statement": "[Fuzzer] Recursive CTE dependent join internal error\n### What happens?\n\nRun the statement:\r\n```\r\nSELECT (WITH RECURSIVE t1 AS (SELECT 1 UNION SELECT 1 FROM t1 WHERE c2 < 3) SELECT 2 FROM t1) FROM (SELECT 1 c2) t1;\r\n```\r\nI will throw an internal error: Logical operator type \"REC_CTE\" for dependent join\r\nThe query should output 2.\r\n\r\nAnother statement with a similar error:\r\n```\r\nSELECT (SELECT 1 FROM (SELECT 1) t2(c2) JOIN (SELECT 1 FROM (SELECT 1) t2(c2) WHERE t2.c2 > t1.c2) t3 ON TRUE USING SAMPLE 0) FROM (SELECT 1) t1(c2);\r\n```\r\nInternal error: Logical operator type \"SAMPLE\" for dependent join\r\n\r\nA single NULL value is expected.\r\n\n\n### To Reproduce\n\nRun the statements above.\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\nlatest from sources\n\n### DuckDB Client:\n\nShell\n\n### Full Name:\n\nPedro Ferreira\n\n### Affiliation:\n\nHuawei\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n[Fuzzer] Checkpoint manager error\n### What happens?\r\n\r\nOn a persisted database run the following statements:\r\n```\r\nCREATE TABLE t4 (c0 DATE, c3 VARCHAR(10));\r\nCREATE INDEX i2 ON t4 (c3);\r\nALTER TABLE t4 ADD c1 BLOB; --Catalog Error: Cannot alter entry \"t4\" because there are entries that depend on it.\r\nSTART TRANSACTION;\r\nCREATE INDEX i3 ON t4 (c3); --TransactionContext Error: Transaction conflict: cannot add an index to a table that has been altered!\r\nCOMMIT;\r\n```\r\n\r\nWhile the client exists the following undefined behavior sanitizer error occurs: src/storage/checkpoint_manager.cpp:320:42: runtime error: member call on address 0x61200000b140 which does not point to an object of type 'duckdb::Index'\r\n0x61200000b140: note: object has invalid vptr\r\n\r\n### To Reproduce\r\n\r\nRun the statements above.\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\nlatest from sources\r\n\r\n### DuckDB Client:\r\n\r\nShell\r\n\r\n### Full Name:\r\n\r\nPedro Ferreira\r\n\r\n### Affiliation:\r\n\r\nHuawei\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n[Fuzzer] Checkpoint manager error\n### What happens?\r\n\r\nOn a persisted database run the following statements:\r\n```\r\nCREATE TABLE t4 (c0 DATE, c3 VARCHAR(10));\r\nCREATE INDEX i2 ON t4 (c3);\r\nALTER TABLE t4 ADD c1 BLOB; --Catalog Error: Cannot alter entry \"t4\" because there are entries that depend on it.\r\nSTART TRANSACTION;\r\nCREATE INDEX i3 ON t4 (c3); --TransactionContext Error: Transaction conflict: cannot add an index to a table that has been altered!\r\nCOMMIT;\r\n```\r\n\r\nWhile the client exists the following undefined behavior sanitizer error occurs: src/storage/checkpoint_manager.cpp:320:42: runtime error: member call on address 0x61200000b140 which does not point to an object of type 'duckdb::Index'\r\n0x61200000b140: note: object has invalid vptr\r\n\r\n### To Reproduce\r\n\r\nRun the statements above.\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\nlatest from sources\r\n\r\n### DuckDB Client:\r\n\r\nShell\r\n\r\n### Full Name:\r\n\r\nPedro Ferreira\r\n\r\n### Affiliation:\r\n\r\nHuawei\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "\n\n",
  "created_at": "2022-09-16T15:53:38Z"
}