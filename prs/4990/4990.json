{
  "repo": "duckdb/duckdb",
  "pull_number": 4990,
  "instance_id": "duckdb__duckdb-4990",
  "issue_numbers": [
    "4988"
  ],
  "base_commit": "e322d56ff9ff4005f728073fda541b1bc3ab6c81",
  "patch": "diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBConnection.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBConnection.java\nindex fae4b86c22b0..5dc510b57393 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBConnection.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBConnection.java\n@@ -35,6 +35,7 @@ public DuckDBConnection(DuckDBDatabase db) throws SQLException {\n \t\tconn_ref = DuckDBNative.duckdb_jdbc_connect(db.db_ref);\n \t\tDuckDBNative.duckdb_jdbc_set_auto_commit(conn_ref, true);\n \t\tthis.db = db;\n+\t\tdb.incrementConnections();\n \t}\n \t\n \tpublic Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)\n@@ -99,6 +100,7 @@ public synchronized void close() throws SQLException {\n \t\tif (conn_ref != null) {\n \t\t\tDuckDBNative.duckdb_jdbc_disconnect(conn_ref);\n \t\t\tconn_ref = null;\n+\t\t\tdb.maybeShutdown();\n \t\t}\n \t\tdb = null;\n \t}\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabase.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabase.java\nindex 0d018c595af4..02e95a80a280 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabase.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBDatabase.java\n@@ -4,11 +4,13 @@\n import java.nio.charset.StandardCharsets;\n import java.sql.SQLException;\n import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n public class DuckDBDatabase {\n \n \tprotected String url;\n \tprotected boolean read_only;\n+\tprivate AtomicInteger connections;\n \n \tpublic DuckDBDatabase(String url, boolean read_only, Properties props) throws SQLException {\n \t\tif (!url.startsWith(\"jdbc:duckdb\")) {\n@@ -21,6 +23,7 @@ public DuckDBDatabase(String url, boolean read_only, Properties props) throws SQ\n \t\t}\n \t\tthis.read_only = read_only;\n \t\tdb_ref = DuckDBNative.duckdb_jdbc_startup(db_dir.getBytes(StandardCharsets.UTF_8), read_only, props);\n+\t\tconnections = new AtomicInteger();\n \t}\n \n \tpublic void shutdown() {\n@@ -39,4 +42,16 @@ protected synchronized void finalize() throws Throwable {\n \n \tprotected ByteBuffer db_ref;\n \n+\tvoid incrementConnections() {\n+\t\tthis.connections.incrementAndGet();\n+\t}\n+\tvoid maybeShutdown() {\n+\t\tif (this.connections.decrementAndGet() == 0) {\n+\t\t\tthis.shutdown();\n+\t\t}\n+\t}\n+\n+\tpublic boolean isShutdown() {\n+\t\treturn db_ref == null;\n+\t}\n }\n",
  "test_patch": "diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex 4130d037c8c6..4175e2eef857 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -2389,6 +2389,18 @@ public static void test_describe() throws Exception {\n \t\t}\n \t}\n \n+\tpublic static void test_dont_leak_database() throws Exception {\n+\t\tDuckDBDatabase database;\n+\n+\t\ttry (DuckDBConnection conn = (DuckDBConnection) DriverManager.getConnection(\"jdbc:duckdb:\")) {\n+\t\t\tconn.duplicate().close();\n+\n+\t\t\tdatabase = conn.getDatabase();\n+\t\t}\n+\n+\t\tassertTrue(database.isShutdown());\n+\t}\n+\n \tpublic static void main(String[] args) throws Exception {\n \t\t// Woo I can do reflection too, take this, JUnit!\n \t\tMethod[] methods = TestDuckDBJDBC.class.getMethods();\n",
  "problem_statement": "JDBC - rss and threads not being released\nHello,\r\n\r\nIt looks like there is an issue somewhere in the JDBC driver where the resident memory and thread count of the process just continues to rise.  I am able to reproduce this using this simple loop:\r\n\r\n```\r\nfor (int i = 0; i < 500; i++) {\r\n    Connection conn = DriverManager.getConnection(\"jdbc:duckdb:test-database.db\");\r\n    conn.close();\r\n}\r\n```\r\n\r\nIt gets significantly worse if I also grab a result set (I am testing with a fairly large database) and am able to spike the rss usage quite high with just a handful of iterations.\r\n\r\nFrom what I've noticed, the thread count of the process - at least according to osx - doesn't decrease, and the rss continues to rise, until I trigger a manual java garbage collection.\r\n\r\nThe java heap never gets particularly large... even with an rss of ~3gb, the heap is reported to only be 35mb... which might explain why the GC isn't kicking in. :)\r\n\r\nI've tried the latest master build, since I know there was recently a \"connection closing\" jdbc issue fixed.\n",
  "hints_text": "Looks like this is a duplicate of #1683\n> Looks like this is a duplicate of #1683\r\n\r\nInteresting; yes, that does look like that could be the cause.  I'm not quite sure how the GC would fix it, unless somehow the GC process triggers the disconnect?\nThis _appears_ to fix my little test loop:\r\n```\r\n((DuckDBConnection) conn).getDatabase().shutdown();\r\nconn.close();\r\n```\nYeah, looks like we're just not shutting down the database after the last connection is closed",
  "created_at": "2022-10-14T06:04:10Z"
}