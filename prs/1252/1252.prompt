You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Support for gamma function?
Hi,  it would be really swell if DuckDB had support for the [gamma function](https://en.cppreference.com/w/cpp/numeric/math/tgamma) and [log gamma function](https://en.cppreference.com/w/cpp/numeric/math/lgamma).  There are a lot of super useful statistical functions that can be implemented once you have the gamma function, and I don't think it would be a huge amount of work to implement because it's in `cmath.h`.  I'd be happy to make a pull request.

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of src/function/scalar/math/numeric.cpp]
1: #include "duckdb/function/scalar/math_functions.hpp"
2: #include "duckdb/common/vector_operations/vector_operations.hpp"
3: #include "duckdb/function/scalar/trigonometric_functions.hpp"
4: #include "duckdb/common/types/hugeint.hpp"
5: #include "duckdb/common/types/cast_helpers.hpp"
6: #include "duckdb/planner/expression/bound_function_expression.hpp"
7: #include "duckdb/common/algorithm.hpp"
8: #include "duckdb/execution/expression_executor.hpp"
9: #include <cmath>
10: #include <errno.h>
11: 
12: namespace duckdb {
13: 
14: template <class TR, class OP> static scalar_function_t GetScalarIntegerUnaryFunctionFixedReturn(LogicalType type) {
15: 	scalar_function_t function;
16: 	switch (type.id()) {
17: 	case LogicalTypeId::TINYINT:
18: 		function = &ScalarFunction::UnaryFunction<int8_t, TR, OP>;
19: 		break;
20: 	case LogicalTypeId::SMALLINT:
21: 		function = &ScalarFunction::UnaryFunction<int16_t, TR, OP>;
22: 		break;
23: 	case LogicalTypeId::INTEGER:
24: 		function = &ScalarFunction::UnaryFunction<int32_t, TR, OP>;
25: 		break;
26: 	case LogicalTypeId::BIGINT:
27: 		function = &ScalarFunction::UnaryFunction<int64_t, TR, OP>;
28: 		break;
29: 	case LogicalTypeId::HUGEINT:
30: 		function = &ScalarFunction::UnaryFunction<hugeint_t, TR, OP>;
31: 		break;
32: 	default:
33: 		throw NotImplementedException("Unimplemented type for GetScalarIntegerUnaryFunctionFixedReturn");
34: 	}
35: 	return function;
36: }
37: 
38: struct UnaryDoubleWrapper {
39: 	template <class FUNC, class OP, class INPUT_TYPE, class RESULT_TYPE>
40: 	static inline RESULT_TYPE Operation(FUNC fun, INPUT_TYPE input, nullmask_t &nullmask, idx_t idx) {
41: 		RESULT_TYPE result = OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input);
42: 		if (std::isnan(result) || std::isinf(result) || errno != 0) {
43: 			errno = 0;
44: 			nullmask[idx] = true;
45: 			return 0;
46: 		}
47: 		return result;
48: 	}
49: };
50: 
51: template <class T, class OP>
52: static void UnaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {
53: 	D_ASSERT(input.ColumnCount() >= 1);
54: 	errno = 0;
55: 	UnaryExecutor::Execute<T, T, OP, true, UnaryDoubleWrapper>(input.data[0], result, input.size());
56: }
57: 
58: struct BinaryDoubleWrapper {
59: 	template <class FUNC, class OP, class TA, class TB, class TR>
60: 	static inline TR Operation(FUNC fun, TA left, TB right, nullmask_t &nullmask, idx_t idx) {
61: 		TR result = OP::template Operation<TA, TB, TR>(left, right);
62: 		if (std::isnan(result) || std::isinf(result) || errno != 0) {
63: 			errno = 0;
64: 			nullmask[idx] = true;
65: 			return 0;
66: 		}
67: 		return result;
68: 	}
69: };
70: 
71: template <class T, class OP>
72: static void BinaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {
73: 	D_ASSERT(input.ColumnCount() >= 2);
74: 	errno = 0;
75: 	BinaryExecutor::Execute<T, T, T, OP, true, BinaryDoubleWrapper>(input.data[0], input.data[1], result, input.size());
76: }
77: 
78: //===--------------------------------------------------------------------===//
79: // abs
80: //===--------------------------------------------------------------------===//
81: struct AbsOperator {
82: 	template <class TA, class TR> static inline TR Operation(TA input) {
83: 		return input < 0 ? -input : input;
84: 	}
85: };
86: 
87: template <class OP>
88: unique_ptr<FunctionData> decimal_unary_op_bind(ClientContext &context, ScalarFunction &bound_function,
89:                                                vector<unique_ptr<Expression>> &arguments) {
90: 	auto decimal_type = arguments[0]->return_type;
91: 	switch (decimal_type.InternalType()) {
92: 	case PhysicalType::INT16:
93: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::SMALLINT);
94: 		break;
95: 	case PhysicalType::INT32:
96: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::INTEGER);
97: 		break;
98: 	case PhysicalType::INT64:
99: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::BIGINT);
100: 		break;
101: 	default:
102: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::HUGEINT);
103: 		break;
104: 	}
105: 	bound_function.arguments[0] = decimal_type;
106: 	bound_function.return_type = decimal_type;
107: 	return nullptr;
108: }
109: 
110: void AbsFun::RegisterFunction(BuiltinFunctions &set) {
111: 	ScalarFunctionSet abs("abs");
112: 	for (auto &type : LogicalType::NUMERIC) {
113: 		if (type.id() == LogicalTypeId::DECIMAL) {
114: 			abs.AddFunction(ScalarFunction({type}, type, nullptr, false, decimal_unary_op_bind<AbsOperator>));
115: 		} else {
116: 			abs.AddFunction(ScalarFunction({type}, type, ScalarFunction::GetScalarUnaryFunction<AbsOperator>(type)));
117: 		}
118: 	}
119: 	set.AddFunction(abs);
120: }
121: 
122: //===--------------------------------------------------------------------===//
123: // bit_count
124: //===--------------------------------------------------------------------===//
125: struct BitCntOperator {
126: 	template <class TA, class TR> static inline TR Operation(TA input) {
127: 		using TU = typename std::make_unsigned<TA>::type;
128: 		TR count = 0;
129: 		for (auto value = TU(input); value > 0; value >>= 1) {
130: 			count += TR(value & 1);
131: 		}
132: 		return count;
133: 	}
134: };
135: 
136: void BitCountFun::RegisterFunction(BuiltinFunctions &set) {
137: 	ScalarFunctionSet functions("bit_count");
138: 	functions.AddFunction(ScalarFunction({LogicalType::TINYINT}, LogicalType::TINYINT,
139: 	                                     ScalarFunction::UnaryFunction<int8_t, int8_t, BitCntOperator>));
140: 	functions.AddFunction(ScalarFunction({LogicalType::SMALLINT}, LogicalType::TINYINT,
141: 	                                     ScalarFunction::UnaryFunction<int16_t, int8_t, BitCntOperator>));
142: 	functions.AddFunction(ScalarFunction({LogicalType::INTEGER}, LogicalType::TINYINT,
143: 	                                     ScalarFunction::UnaryFunction<int32_t, int8_t, BitCntOperator>));
144: 	functions.AddFunction(ScalarFunction({LogicalType::BIGINT}, LogicalType::TINYINT,
145: 	                                     ScalarFunction::UnaryFunction<int64_t, int8_t, BitCntOperator>));
146: 	set.AddFunction(functions);
147: }
148: 
149: //===--------------------------------------------------------------------===//
150: // sign
151: //===--------------------------------------------------------------------===//
152: struct SignOperator {
153: 	template <class TA, class TR> static inline TR Operation(TA left) {
154: 		if (left == TA(0))
155: 			return 0;
156: 		else if (left > TA(0))
157: 			return 1;
158: 		else
159: 			return -1;
160: 	}
161: };
162: 
163: void SignFun::RegisterFunction(BuiltinFunctions &set) {
164: 	ScalarFunctionSet sign("sign");
165: 	for (auto &type : LogicalType::NUMERIC) {
166: 		if (type.id() == LogicalTypeId::DECIMAL) {
167: 			continue;
168: 		} else {
169: 			sign.AddFunction(
170: 			    ScalarFunction({type}, LogicalType::TINYINT,
171: 			                   ScalarFunction::GetScalarUnaryFunctionFixedReturn<int8_t, SignOperator>(type)));
172: 		}
173: 	}
174: 	set.AddFunction(sign);
175: }
176: 
177: //===--------------------------------------------------------------------===//
178: // ceil
179: //===--------------------------------------------------------------------===//
180: struct CeilOperator {
181: 	template <class TA, class TR> static inline TR Operation(TA left) {
182: 		return ceil(left);
183: 	}
184: };
185: 
186: template <class T, class POWERS_OF_TEN, class OP>
187: static void generic_round_function_decimal(DataChunk &input, ExpressionState &state, Vector &result) {
188: 	auto &func_expr = (BoundFunctionExpression &)state.expr;
189: 	OP::template Operation<T, POWERS_OF_TEN>(input, func_expr.children[0]->return_type.scale(), result);
190: }
191: 
192: template <class OP>
193: unique_ptr<FunctionData> bind_generic_round_function_decimal(ClientContext &context, ScalarFunction &bound_function,
194:                                                              vector<unique_ptr<Expression>> &arguments) {
195: 	// ceil essentially removes the scale
196: 	auto decimal_type = arguments[0]->return_type;
197: 	if (decimal_type.scale() == 0) {
198: 		bound_function.function = ScalarFunction::NopFunction;
199: 	} else {
200: 		switch (decimal_type.InternalType()) {
201: 		case PhysicalType::INT16:
202: 			bound_function.function = generic_round_function_decimal<int16_t, NumericHelper, OP>;
203: 			break;
204: 		case PhysicalType::INT32:
205: 			bound_function.function = generic_round_function_decimal<int32_t, NumericHelper, OP>;
206: 			break;
207: 		case PhysicalType::INT64:
208: 			bound_function.function = generic_round_function_decimal<int64_t, NumericHelper, OP>;
209: 			break;
210: 		default:
211: 			bound_function.function = generic_round_function_decimal<hugeint_t, Hugeint, OP>;
212: 			break;
213: 		}
214: 	}
215: 	bound_function.arguments[0] = decimal_type;
216: 	bound_function.return_type = LogicalType(LogicalTypeId::DECIMAL, decimal_type.width(), 0);
217: 	return nullptr;
218: }
219: 
220: struct CeilDecimalOperator {
221: 	template <class T, class POWERS_OF_TEN> static void Operation(DataChunk &input, uint8_t scale, Vector &result) {
222: 		T power_of_ten = POWERS_OF_TEN::PowersOfTen[scale];
223: 		UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
224: 			if (input < 0) {
225: 				// below 0 we floor the number (e.g. -10.5 -> -10)
226: 				return input / power_of_ten;
227: 			} else {
228: 				// above 0 we ceil the number
229: 				return ((input - 1) / power_of_ten) + 1;
230: 			}
231: 		});
232: 	}
233: };
234: 
235: void CeilFun::RegisterFunction(BuiltinFunctions &set) {
236: 	ScalarFunctionSet ceil("ceil");
237: 	for (auto &type : LogicalType::NUMERIC) {
238: 		scalar_function_t func = nullptr;
239: 		bind_scalar_function_t bind_func = nullptr;
240: 		if (type.IsIntegral()) {
241: 			// no ceil for integral numbers
242: 			continue;
243: 		}
244: 		switch (type.id()) {
245: 		case LogicalTypeId::FLOAT:
246: 			func = ScalarFunction::UnaryFunction<float, float, CeilOperator>;
247: 			break;
248: 		case LogicalTypeId::DOUBLE:
249: 			func = ScalarFunction::UnaryFunction<double, double, CeilOperator>;
250: 			break;
251: 		case LogicalTypeId::DECIMAL:
252: 			bind_func = bind_generic_round_function_decimal<CeilDecimalOperator>;
253: 			break;
254: 		default:
255: 			throw NotImplementedException("Unimplemented numeric type for function \"ceil\"");
256: 		}
257: 		ceil.AddFunction(ScalarFunction({type}, type, func, false, bind_func));
258: 	}
259: 
260: 	set.AddFunction(ceil);
261: 	ceil.name = "ceiling";
262: 	set.AddFunction(ceil);
263: }
264: 
265: //===--------------------------------------------------------------------===//
266: // floor
267: //===--------------------------------------------------------------------===//
268: struct FloorOperator {
269: 	template <class TA, class TR> static inline TR Operation(TA left) {
270: 		return floor(left);
271: 	}
272: };
273: 
274: struct FloorDecimalOperator {
275: 	template <class T, class POWERS_OF_TEN> static void Operation(DataChunk &input, uint8_t scale, Vector &result) {
276: 		T power_of_ten = POWERS_OF_TEN::PowersOfTen[scale];
277: 		UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
278: 			if (input < 0) {
279: 				// below 0 we ceil the number (e.g. -10.5 -> -11)
280: 				return ((input + 1) / power_of_ten) - 1;
281: 			} else {
282: 				// above 0 we floor the number
283: 				return input / power_of_ten;
284: 			}
285: 		});
286: 	}
287: };
288: 
289: void FloorFun::RegisterFunction(BuiltinFunctions &set) {
290: 	ScalarFunctionSet floor("floor");
291: 	for (auto &type : LogicalType::NUMERIC) {
292: 		scalar_function_t func = nullptr;
293: 		bind_scalar_function_t bind_func = nullptr;
294: 		if (type.IsIntegral()) {
295: 			// no floor for integral numbers
296: 			continue;
297: 		}
298: 		switch (type.id()) {
299: 		case LogicalTypeId::FLOAT:
300: 			func = ScalarFunction::UnaryFunction<float, float, FloorOperator>;
301: 			break;
302: 		case LogicalTypeId::DOUBLE:
303: 			func = ScalarFunction::UnaryFunction<double, double, FloorOperator>;
304: 			break;
305: 		case LogicalTypeId::DECIMAL:
306: 			bind_func = bind_generic_round_function_decimal<FloorDecimalOperator>;
307: 			break;
308: 		default:
309: 			throw NotImplementedException("Unimplemented numeric type for function \"floor\"");
310: 		}
311: 		floor.AddFunction(ScalarFunction({type}, type, func, false, bind_func));
312: 	}
313: 	set.AddFunction(floor);
314: }
315: 
316: //===--------------------------------------------------------------------===//
317: // round
318: //===--------------------------------------------------------------------===//
319: struct RoundOperatorPrecision {
320: 	template <class TA, class TB, class TR> static inline TR Operation(TA input, TB precision) {
321: 		double rounded_value;
322: 		if (precision < 0) {
323: 			double modifier = pow(10, -precision);
324: 			rounded_value = (round(input / modifier)) * modifier;
325: 			if (std::isinf(rounded_value) || std::isnan(rounded_value)) {
326: 				return 0;
327: 			}
328: 		} else {
329: 			double modifier = pow(10, precision);
330: 			rounded_value = (round(input * modifier)) / modifier;
331: 			if (std::isinf(rounded_value) || std::isnan(rounded_value)) {
332: 				return input;
333: 			}
334: 		}
335: 		return rounded_value;
336: 	}
337: };
338: 
339: struct RoundOperator {
340: 	template <class TA, class TR> static inline TR Operation(TA input) {
341: 		double rounded_value = round(input);
342: 		if (std::isinf(rounded_value) || std::isnan(rounded_value)) {
343: 			return input;
344: 		}
345: 		return rounded_value;
346: 	}
347: };
348: 
349: struct RoundDecimalOperator {
350: 	template <class T, class POWERS_OF_TEN> static void Operation(DataChunk &input, uint8_t scale, Vector &result) {
351: 		T power_of_ten = POWERS_OF_TEN::PowersOfTen[scale];
352: 		T addition = power_of_ten / 2;
353: 		// regular round rounds towards the nearest number
354: 		// in case of a tie we round away from zero
355: 		// i.e. -10.5 -> -11, 10.5 -> 11
356: 		// we implement this by adding (positive) or subtracting (negative) 0.5
357: 		// and then flooring the number
358: 		// e.g. 10.5 + 0.5 = 11, floor(11) = 11
359: 		//      10.4 + 0.5 = 10.9, floor(10.9) = 10
360: 		UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
361: 			if (input < 0) {
362: 				input -= addition;
363: 			} else {
364: 				input += addition;
365: 			}
366: 			return input / power_of_ten;
367: 		});
368: 	}
369: };
370: 
371: struct RoundPrecisionFunctionData : public FunctionData {
372: 	RoundPrecisionFunctionData(int32_t target_scale) : target_scale(target_scale) {
373: 	}
374: 
375: 	int32_t target_scale;
376: 
377: 	unique_ptr<FunctionData> Copy() override {
378: 		return make_unique<RoundPrecisionFunctionData>(target_scale);
379: 	}
380: };
381: 
382: template <class T, class POWERS_OF_TEN>
383: static void decimal_round_negative_precision_function(DataChunk &input, ExpressionState &state, Vector &result) {
384: 	auto &func_expr = (BoundFunctionExpression &)state.expr;
385: 	auto &info = (RoundPrecisionFunctionData &)*func_expr.bind_info;
386: 	auto source_scale = func_expr.children[0]->return_type.scale();
387: 	if (-info.target_scale >= func_expr.children[0]->return_type.width()) {
388: 		// scale too big for width
389: 		result.vector_type = VectorType::CONSTANT_VECTOR;
390: 		result.SetValue(0, Value::INTEGER(0));
391: 		return;
392: 	}
393: 	T divide_power_of_ten = POWERS_OF_TEN::PowersOfTen[-info.target_scale + source_scale];
394: 	T multiply_power_of_ten = POWERS_OF_TEN::PowersOfTen[-info.target_scale];
395: 	T addition = divide_power_of_ten / 2;
396: 	UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
397: 		if (input < 0) {
398: 			input -= addition;
399: 		} else {
400: 			input += addition;
401: 		}
402: 		return input / divide_power_of_ten * multiply_power_of_ten;
403: 	});
404: }
405: 
406: template <class T, class POWERS_OF_TEN>
407: static void decimal_round_positive_precision_function(DataChunk &input, ExpressionState &state, Vector &result) {
408: 	auto &func_expr = (BoundFunctionExpression &)state.expr;
409: 	auto &info = (RoundPrecisionFunctionData &)*func_expr.bind_info;
410: 	auto source_scale = func_expr.children[0]->return_type.scale();
411: 	T power_of_ten = POWERS_OF_TEN::PowersOfTen[source_scale - info.target_scale];
412: 	T addition = power_of_ten / 2;
413: 	UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
414: 		if (input < 0) {
415: 			input -= addition;
416: 		} else {
417: 			input += addition;
418: 		}
419: 		return input / power_of_ten;
420: 	});
421: }
422: 
423: unique_ptr<FunctionData> bind_decimal_round_precision(ClientContext &context, ScalarFunction &bound_function,
424:                                                       vector<unique_ptr<Expression>> &arguments) {
425: 	auto decimal_type = arguments[0]->return_type;
426: 	if (!arguments[1]->IsFoldable()) {
427: 		throw NotImplementedException("ROUND(DECIMAL, INTEGER) with non-constant precision is not supported");
428: 	}
429: 	Value val = ExpressionExecutor::EvaluateScalar(*arguments[1]).CastAs(LogicalType::INTEGER);
430: 	if (val.is_null) {
431: 		throw NotImplementedException("ROUND(DECIMAL, INTEGER) expected a numeric precision field");
432: 	}
433: 	// our new precision becomes the round value
434: 	// e.g. ROUND(DECIMAL(18,3), 1) -> DECIMAL(18,1)
435: 	// but ONLY if the round value is positive
436: 	// if it is negative the scale becomes zero
437: 	// i.e. ROUND(DECIMAL(18,3), -1) -> DECIMAL(18,0)
438: 	int32_t round_value = val.value_.integer;
439: 	uint8_t target_scale;
440: 	if (round_value < 0) {
441: 		target_scale = 0;
442: 		switch (decimal_type.InternalType()) {
443: 		case PhysicalType::INT16:
444: 			bound_function.function = decimal_round_negative_precision_function<int16_t, NumericHelper>;
445: 			break;
446: 		case PhysicalType::INT32:
447: 			bound_function.function = decimal_round_negative_precision_function<int32_t, NumericHelper>;
448: 			break;
449: 		case PhysicalType::INT64:
450: 			bound_function.function = decimal_round_negative_precision_function<int64_t, NumericHelper>;
451: 			break;
452: 		default:
453: 			bound_function.function = decimal_round_negative_precision_function<hugeint_t, Hugeint>;
454: 			break;
455: 		}
456: 	} else {
457: 		if (round_value >= (int32_t)decimal_type.scale()) {
458: 			// if round_value is bigger than or equal to scale we do nothing
459: 			bound_function.function = ScalarFunction::NopFunction;
460: 			target_scale = decimal_type.scale();
461: 		} else {
462: 			target_scale = round_value;
463: 			switch (decimal_type.InternalType()) {
464: 			case PhysicalType::INT16:
465: 				bound_function.function = decimal_round_positive_precision_function<int16_t, NumericHelper>;
466: 				break;
467: 			case PhysicalType::INT32:
468: 				bound_function.function = decimal_round_positive_precision_function<int32_t, NumericHelper>;
469: 				break;
470: 			case PhysicalType::INT64:
471: 				bound_function.function = decimal_round_positive_precision_function<int64_t, NumericHelper>;
472: 				break;
473: 			default:
474: 				bound_function.function = decimal_round_positive_precision_function<hugeint_t, Hugeint>;
475: 				break;
476: 			}
477: 		}
478: 	}
479: 	bound_function.arguments[0] = decimal_type;
480: 	bound_function.return_type = LogicalType(LogicalTypeId::DECIMAL, decimal_type.width(), target_scale);
481: 	return make_unique<RoundPrecisionFunctionData>(round_value);
482: }
483: 
484: void RoundFun::RegisterFunction(BuiltinFunctions &set) {
485: 	ScalarFunctionSet round("round");
486: 	for (auto &type : LogicalType::NUMERIC) {
487: 		scalar_function_t round_prec_func = nullptr;
488: 		scalar_function_t round_func = nullptr;
489: 		bind_scalar_function_t bind_func = nullptr;
490: 		bind_scalar_function_t bind_prec_func = nullptr;
491: 		if (type.IsIntegral()) {
492: 			// no round for integral numbers
493: 			continue;
494: 		}
495: 		switch (type.id()) {
496: 		case LogicalTypeId::FLOAT:
497: 			round_func = ScalarFunction::UnaryFunction<float, float, RoundOperator>;
498: 			round_prec_func = ScalarFunction::BinaryFunction<float, int32_t, float, RoundOperatorPrecision>;
499: 			break;
500: 		case LogicalTypeId::DOUBLE:
501: 			round_func = ScalarFunction::UnaryFunction<double, double, RoundOperator>;
502: 			round_prec_func = ScalarFunction::BinaryFunction<double, int32_t, double, RoundOperatorPrecision>;
503: 			break;
504: 		case LogicalTypeId::DECIMAL:
505: 			bind_func = bind_generic_round_function_decimal<RoundDecimalOperator>;
506: 			bind_prec_func = bind_decimal_round_precision;
507: 			break;
508: 		default:
509: 			throw NotImplementedException("Unimplemented numeric type for function \"floor\"");
510: 		}
511: 		round.AddFunction(ScalarFunction({type}, type, round_func, false, bind_func));
512: 		round.AddFunction(ScalarFunction({type, LogicalType::INTEGER}, type, round_prec_func, false, bind_prec_func));
513: 	}
514: 	set.AddFunction(round);
515: }
516: 
517: //===--------------------------------------------------------------------===//
518: // exp
519: //===--------------------------------------------------------------------===//
520: struct ExpOperator {
521: 	template <class TA, class TR> static inline TR Operation(TA left) {
522: 		return exp(left);
523: 	}
524: };
525: 
526: void ExpFun::RegisterFunction(BuiltinFunctions &set) {
527: 	set.AddFunction(ScalarFunction("exp", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
528: 	                               UnaryDoubleFunctionWrapper<double, ExpOperator>));
529: }
530: 
531: //===--------------------------------------------------------------------===//
532: // pow
533: //===--------------------------------------------------------------------===//
534: struct PowOperator {
535: 	template <class TA, class TB, class TR> static inline TR Operation(TA base, TB exponent) {
536: 		return pow(base, exponent);
537: 	}
538: };
539: 
540: void PowFun::RegisterFunction(BuiltinFunctions &set) {
541: 	ScalarFunction power_function("pow", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,
542: 	                              BinaryDoubleFunctionWrapper<double, PowOperator>);
543: 	set.AddFunction(power_function);
544: 	power_function.name = "power";
545: 	set.AddFunction(power_function);
546: 	power_function.name = "**";
547: 	set.AddFunction(power_function);
548: }
549: 
550: //===--------------------------------------------------------------------===//
551: // sqrt
552: //===--------------------------------------------------------------------===//
553: struct SqrtOperator {
554: 	template <class TA, class TR> static inline TR Operation(TA left) {
555: 		return sqrt(left);
556: 	}
557: };
558: 
559: void SqrtFun::RegisterFunction(BuiltinFunctions &set) {
560: 	set.AddFunction(ScalarFunction("sqrt", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
561: 	                               UnaryDoubleFunctionWrapper<double, SqrtOperator>));
562: }
563: 
564: //===--------------------------------------------------------------------===//
565: // cbrt
566: //===--------------------------------------------------------------------===//
567: struct CbRtOperator {
568: 	template <class TA, class TR> static inline TR Operation(TA left) {
569: 		return cbrt(left);
570: 	}
571: };
572: 
573: void CbrtFun::RegisterFunction(BuiltinFunctions &set) {
574: 	set.AddFunction(ScalarFunction("cbrt", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
575: 	                               UnaryDoubleFunctionWrapper<double, CbRtOperator>));
576: }
577: 
578: //===--------------------------------------------------------------------===//
579: // ln
580: //===--------------------------------------------------------------------===//
581: 
582: struct LnOperator {
583: 	template <class TA, class TR> static inline TR Operation(TA left) {
584: 		return log(left);
585: 	}
586: };
587: 
588: void LnFun::RegisterFunction(BuiltinFunctions &set) {
589: 	set.AddFunction(ScalarFunction("ln", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
590: 	                               UnaryDoubleFunctionWrapper<double, LnOperator>));
591: }
592: 
593: //===--------------------------------------------------------------------===//
594: // log
595: //===--------------------------------------------------------------------===//
596: struct Log10Operator {
597: 	template <class TA, class TR> static inline TR Operation(TA left) {
598: 		return log10(left);
599: 	}
600: };
601: 
602: void Log10Fun::RegisterFunction(BuiltinFunctions &set) {
603: 	set.AddFunction({"log10", "log"}, ScalarFunction({LogicalType::DOUBLE}, LogicalType::DOUBLE,
604: 	                                                 UnaryDoubleFunctionWrapper<double, Log10Operator>));
605: }
606: 
607: //===--------------------------------------------------------------------===//
608: // log2
609: //===--------------------------------------------------------------------===//
610: struct Log2Operator {
611: 	template <class TA, class TR> static inline TR Operation(TA left) {
612: 		return log2(left);
613: 	}
614: };
615: 
616: void Log2Fun::RegisterFunction(BuiltinFunctions &set) {
617: 	set.AddFunction(ScalarFunction("log2", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
618: 	                               UnaryDoubleFunctionWrapper<double, Log2Operator>));
619: }
620: 
621: //===--------------------------------------------------------------------===//
622: // pi
623: //===--------------------------------------------------------------------===//
624: static void pi_function(DataChunk &args, ExpressionState &state, Vector &result) {
625: 	D_ASSERT(args.ColumnCount() == 0);
626: 	Value pi_value = Value::DOUBLE(PI);
627: 	result.Reference(pi_value);
628: }
629: 
630: void PiFun::RegisterFunction(BuiltinFunctions &set) {
631: 	set.AddFunction(ScalarFunction("pi", {}, LogicalType::DOUBLE, pi_function));
632: }
633: 
634: //===--------------------------------------------------------------------===//
635: // degrees
636: //===--------------------------------------------------------------------===//
637: struct DegreesOperator {
638: 	template <class TA, class TR> static inline TR Operation(TA left) {
639: 		return left * (180 / PI);
640: 	}
641: };
642: 
643: void DegreesFun::RegisterFunction(BuiltinFunctions &set) {
644: 	set.AddFunction(ScalarFunction("degrees", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
645: 	                               UnaryDoubleFunctionWrapper<double, DegreesOperator>));
646: }
647: 
648: //===--------------------------------------------------------------------===//
649: // radians
650: //===--------------------------------------------------------------------===//
651: struct RadiansOperator {
652: 	template <class TA, class TR> static inline TR Operation(TA left) {
653: 		return left * (PI / 180);
654: 	}
655: };
656: 
657: void RadiansFun::RegisterFunction(BuiltinFunctions &set) {
658: 	set.AddFunction(ScalarFunction("radians", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
659: 	                               UnaryDoubleFunctionWrapper<double, RadiansOperator>));
660: }
661: 
662: //===--------------------------------------------------------------------===//
663: // sin
664: //===--------------------------------------------------------------------===//
665: struct SinOperator {
666: 	template <class TA, class TR> static inline TR Operation(TA input) {
667: 		return sin(input);
668: 	}
669: };
670: 
671: void SinFun::RegisterFunction(BuiltinFunctions &set) {
672: 	set.AddFunction(ScalarFunction("sin", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
673: 	                               UnaryDoubleFunctionWrapper<double, SinOperator>));
674: }
675: 
676: //===--------------------------------------------------------------------===//
677: // cos
678: //===--------------------------------------------------------------------===//
679: struct CosOperator {
680: 	template <class TA, class TR> static inline TR Operation(TA input) {
681: 		return (double)cos(input);
682: 	}
683: };
684: 
685: void CosFun::RegisterFunction(BuiltinFunctions &set) {
686: 	set.AddFunction(ScalarFunction("cos", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
687: 	                               UnaryDoubleFunctionWrapper<double, CosOperator>));
688: }
689: 
690: //===--------------------------------------------------------------------===//
691: // tan
692: //===--------------------------------------------------------------------===//
693: struct TanOperator {
694: 	template <class TA, class TR> static inline TR Operation(TA input) {
695: 		return (double)tan(input);
696: 	}
697: };
698: 
699: void TanFun::RegisterFunction(BuiltinFunctions &set) {
700: 	set.AddFunction(ScalarFunction("tan", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
701: 	                               UnaryDoubleFunctionWrapper<double, TanOperator>));
702: }
703: 
704: //===--------------------------------------------------------------------===//
705: // asin
706: //===--------------------------------------------------------------------===//
707: struct ASinOperator {
708: 	template <class TA, class TR> static inline TR Operation(TA input) {
709: 		if (input < -1 || input > 1) {
710: 			throw Exception("ASIN is undefined outside [-1,1]");
711: 		}
712: 		return (double)asin(input);
713: 	}
714: };
715: 
716: void AsinFun::RegisterFunction(BuiltinFunctions &set) {
717: 	set.AddFunction(ScalarFunction("asin", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
718: 	                               UnaryDoubleFunctionWrapper<double, ASinOperator>));
719: }
720: 
721: //===--------------------------------------------------------------------===//
722: // atan
723: //===--------------------------------------------------------------------===//
724: struct ATanOperator {
725: 	template <class TA, class TR> static inline TR Operation(TA input) {
726: 		return (double)atan(input);
727: 	}
728: };
729: 
730: void AtanFun::RegisterFunction(BuiltinFunctions &set) {
731: 	set.AddFunction(ScalarFunction("atan", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
732: 	                               UnaryDoubleFunctionWrapper<double, ATanOperator>));
733: }
734: 
735: //===--------------------------------------------------------------------===//
736: // atan2
737: //===--------------------------------------------------------------------===//
738: struct ATan2 {
739: 	template <class TA, class TB, class TR> static inline TR Operation(TA left, TB right) {
740: 		return (double)atan2(left, right);
741: 	}
742: };
743: 
744: void Atan2Fun::RegisterFunction(BuiltinFunctions &set) {
745: 	set.AddFunction(ScalarFunction("atan2", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,
746: 	                               BinaryDoubleFunctionWrapper<double, ATan2>));
747: }
748: 
749: //===--------------------------------------------------------------------===//
750: // acos
751: //===--------------------------------------------------------------------===//
752: struct ACos {
753: 	template <class TA, class TR> static inline TR Operation(TA input) {
754: 		return (double)acos(input);
755: 	}
756: };
757: 
758: void AcosFun::RegisterFunction(BuiltinFunctions &set) {
759: 	set.AddFunction(
760: 	    ScalarFunction("acos", {LogicalType::DOUBLE}, LogicalType::DOUBLE, UnaryDoubleFunctionWrapper<double, ACos>));
761: }
762: 
763: //===--------------------------------------------------------------------===//
764: // cot
765: //===--------------------------------------------------------------------===//
766: struct CotOperator {
767: 	template <class TA, class TR> static inline TR Operation(TA input) {
768: 		return 1.0 / (double)tan(input);
769: 	}
770: };
771: 
772: void CotFun::RegisterFunction(BuiltinFunctions &set) {
773: 	set.AddFunction(ScalarFunction("cot", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
774: 	                               UnaryDoubleFunctionWrapper<double, CotOperator>));
775: }
776: 
777: } // namespace duckdb
[end of src/function/scalar/math/numeric.cpp]
[start of src/function/scalar/math_functions.cpp]
1: #include "duckdb/function/scalar/math_functions.hpp"
2: #include "duckdb/common/exception.hpp"
3: 
4: namespace duckdb {
5: 
6: void BuiltinFunctions::RegisterMathFunctions() {
7: 	Register<AbsFun>();
8: 	Register<SignFun>();
9: 
10: 	Register<CeilFun>();
11: 	Register<FloorFun>();
12: 	Register<RoundFun>();
13: 
14: 	Register<DegreesFun>();
15: 	Register<RadiansFun>();
16: 
17: 	Register<CbrtFun>();
18: 	Register<ExpFun>();
19: 	Register<Log2Fun>();
20: 	Register<Log10Fun>();
21: 	Register<LnFun>();
22: 	Register<PowFun>();
23: 	Register<RandomFun>();
24: 	Register<SetseedFun>();
25: 	Register<SqrtFun>();
26: 
27: 	Register<PiFun>();
28: 
29: 	Register<BitCountFun>();
30: }
31: 
32: } // namespace duckdb
[end of src/function/scalar/math_functions.cpp]
[start of src/include/duckdb/function/scalar/math_functions.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/scalar/math_functions.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/scalar_function.hpp"
12: #include "duckdb/function/function_set.hpp"
13: 
14: namespace duckdb {
15: 
16: struct AbsFun {
17: 	static void RegisterFunction(BuiltinFunctions &set);
18: };
19: 
20: struct SignFun {
21: 	static void RegisterFunction(BuiltinFunctions &set);
22: };
23: 
24: struct CeilFun {
25: 	static void RegisterFunction(BuiltinFunctions &set);
26: };
27: 
28: struct FloorFun {
29: 	static void RegisterFunction(BuiltinFunctions &set);
30: };
31: 
32: struct RoundFun {
33: 	static void RegisterFunction(BuiltinFunctions &set);
34: };
35: 
36: struct DegreesFun {
37: 	static void RegisterFunction(BuiltinFunctions &set);
38: };
39: 
40: struct RadiansFun {
41: 	static void RegisterFunction(BuiltinFunctions &set);
42: };
43: 
44: struct RandomFun {
45: 	static void RegisterFunction(BuiltinFunctions &set);
46: };
47: 
48: struct SetseedFun {
49: 	static void RegisterFunction(BuiltinFunctions &set);
50: };
51: 
52: struct CbrtFun {
53: 	static void RegisterFunction(BuiltinFunctions &set);
54: };
55: 
56: struct ExpFun {
57: 	static void RegisterFunction(BuiltinFunctions &set);
58: };
59: 
60: struct Log2Fun {
61: 	static void RegisterFunction(BuiltinFunctions &set);
62: };
63: 
64: struct Log10Fun {
65: 	static void RegisterFunction(BuiltinFunctions &set);
66: };
67: 
68: struct LnFun {
69: 	static void RegisterFunction(BuiltinFunctions &set);
70: };
71: 
72: struct PowFun {
73: 	static void RegisterFunction(BuiltinFunctions &set);
74: };
75: 
76: struct SqrtFun {
77: 	static void RegisterFunction(BuiltinFunctions &set);
78: };
79: 
80: struct PiFun {
81: 	static void RegisterFunction(BuiltinFunctions &set);
82: };
83: 
84: struct BitCountFun {
85: 	static void RegisterFunction(BuiltinFunctions &set);
86: };
87: 
88: } // namespace duckdb
[end of src/include/duckdb/function/scalar/math_functions.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: