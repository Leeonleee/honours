{
  "repo": "duckdb/duckdb",
  "pull_number": 4799,
  "instance_id": "duckdb__duckdb-4799",
  "issue_numbers": [
    "4796"
  ],
  "base_commit": "a0fc1e9cd0c9b03020b4ed9c7ba61fcd67d54681",
  "patch": "diff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp\nindex d89617b00ce1..11345bae9609 100644\n--- a/tools/jdbc/src/jni/duckdb_java.cpp\n+++ b/tools/jdbc/src/jni/duckdb_java.cpp\n@@ -135,8 +135,9 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {\n \tJ_DuckResultSetMeta = (jclass)env->NewGlobalRef(tmpLocalRef);\n \tenv->DeleteLocalRef(tmpLocalRef);\n \n-\tJ_DuckResultSetMeta_init = env->GetMethodID(J_DuckResultSetMeta, \"<init>\",\n-\t                                            \"(II[Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)V\");\n+\tJ_DuckResultSetMeta_init =\n+\t    env->GetMethodID(J_DuckResultSetMeta, \"<init>\",\n+\t                     \"(II[Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;)V\");\n \n \ttmpLocalRef = env->FindClass(\"org/duckdb/DuckDBVector\");\n \tJ_DuckVector = (jclass)env->NewGlobalRef(tmpLocalRef);\n@@ -530,8 +531,11 @@ JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1meta(JNIEnv\n \t\t                           env->NewStringUTF(type_to_jduckdb_type(types[col_idx]).c_str()));\n \t}\n \n+\tauto return_type =\n+\t    env->NewStringUTF(StatementReturnTypeToString(stmt_ref->stmt->GetStatementProperties().return_type).c_str());\n+\n \treturn env->NewObject(J_DuckResultSetMeta, J_DuckResultSetMeta_init, stmt_ref->stmt->n_param, column_count,\n-\t                      name_array, type_array, type_detail_array);\n+\t                      name_array, type_array, type_detail_array, return_type);\n }\n \n JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(JNIEnv *env, jclass,\n@@ -691,17 +695,6 @@ JNIEXPORT jint JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch_1size(JN\n \treturn STANDARD_VECTOR_SIZE;\n }\n \n-JNIEXPORT jstring JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1prepare_1type(JNIEnv *env, jclass,\n-                                                                                   jobject stmt_ref_buf) {\n-\n-\tauto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);\n-\tif (!stmt_ref || !stmt_ref->stmt || stmt_ref->stmt->HasError()) {\n-\t\tenv->ThrowNew(J_SQLException, \"Invalid statement\");\n-\t\treturn nullptr;\n-\t}\n-\treturn env->NewStringUTF(StatementTypeToString(stmt_ref->stmt->GetStatementType()).c_str());\n-}\n-\n JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1create_1appender(JNIEnv *env, jclass,\n                                                                                       jobject conn_ref_buf,\n                                                                                       jbyteArray schema_name_j,\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java\nindex 7d40f703d6b1..d2dd4cfae591 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java\n@@ -82,8 +82,6 @@ public class DuckDBNative {\n \t// returns stmt_ref result reference object\n \tprotected static native ByteBuffer duckdb_jdbc_prepare(ByteBuffer conn_ref, byte[] query) throws SQLException;\n \n-\tprotected static native String duckdb_jdbc_prepare_type(ByteBuffer stmt_ref) throws SQLException;\n-\n \tprotected static native void duckdb_jdbc_release(ByteBuffer stmt_ref);\n \n \tprotected static native DuckDBResultSetMetaData duckdb_jdbc_meta(ByteBuffer stmt_ref) throws SQLException;\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java\nindex 86319df74f62..ce041c95ef90 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java\n@@ -41,7 +41,9 @@ public class DuckDBPreparedStatement implements PreparedStatement {\n \tprivate ByteBuffer stmt_ref = null;\n \tprivate DuckDBResultSet select_result = null;\n \tprivate int update_result = 0;\n-\tprivate boolean is_update = false;\n+\tprivate boolean returnsChangedRows = false;\n+\tprivate boolean returnsNothing = false;\n+\tprivate boolean returnsResultSet = false;\n \tprivate Object[] params = new Object[0];\n \tprivate DuckDBResultSetMetaData meta = null;\n \n@@ -101,9 +103,9 @@ private void prepare(String sql) throws SQLException {\n \t\t\tstmt_ref = DuckDBNative.duckdb_jdbc_prepare(conn.conn_ref, sql.getBytes(StandardCharsets.UTF_8));\n \t\t\tmeta = DuckDBNative.duckdb_jdbc_meta(stmt_ref);\n \t\t\tparams = new Object[0];\n-\t\t\t// TODO add query type to meta\n-\t\t\tString query_type = DuckDBNative.duckdb_jdbc_prepare_type(stmt_ref);\n-\t\t\tis_update = !query_type.equals(\"SELECT\") && !query_type.equals(\"PRAGMA\") && !query_type.equals(\"EXPLAIN\");\n+\t\t\treturnsResultSet = meta.return_type.equals(StatementReturnType.QUERY_RESULT);\n+\t\t\treturnsChangedRows = meta.return_type.equals(StatementReturnType.CHANGED_ROWS);\n+\t\t\treturnsNothing = meta.return_type.equals(StatementReturnType.NOTHING);\n \t\t}\n \t\tcatch (SQLException e) {\n \t\t\t// Delete stmt_ref as it might already be allocated\n@@ -141,13 +143,13 @@ else if (result_ref != null) {\n \t\t\tclose();\n \t\t\tthrow new SQLException(e);\n \t\t}\n-\t\treturn !is_update;\n+\t\treturn returnsResultSet;\n \t}\n \n \t@Override\n \tpublic ResultSet executeQuery() throws SQLException {\n-\t\tif (is_update) {\n-\t\t\tthrow new SQLException(\"executeQuery() can only be used with SELECT queries\");\n+\t\tif (!returnsResultSet) {\n+\t\t\tthrow new SQLException(\"executeQuery() can only be used with queries that return a ResultSet\");\n \t\t}\n \t\texecute();\n \t\treturn getResultSet();\n@@ -155,8 +157,8 @@ public ResultSet executeQuery() throws SQLException {\n \n \t@Override\n \tpublic int executeUpdate() throws SQLException {\n-\t\tif (!is_update) {\n-\t\t\tthrow new SQLException(\"executeUpdate() cannot be used with SELECT queries\");\n+\t\tif (!(returnsChangedRows || returnsNothing)) {\n+\t\t\tthrow new SQLException(\"executeUpdate() can only be used with queries that return nothing (eg, a DDL statement), or update rows\");\n \t\t}\n \t\texecute();\n \t\tupdate_result = 0;\n@@ -351,7 +353,7 @@ public ResultSet getResultSet() throws SQLException {\n \t\t\tthrow new SQLException(\"Prepare something first\");\n \t\t}\n \n-\t\tif (is_update) {\n+\t\tif (!returnsResultSet) {\n \t\t\treturn null;\n \t\t}\n \t\treturn select_result;\n@@ -366,7 +368,7 @@ public int getUpdateCount() throws SQLException {\n \t\t\tthrow new SQLException(\"Prepare something first\");\n \t\t}\n \n-\t\tif (!is_update || update_result == 0) {\n+\t\tif (!returnsChangedRows || update_result == 0) {\n \t\t\treturn -1;\n \t\t}\n \t\treturn update_result;\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\nindex 7995e4fbf42a..6c90c4f58568 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\n@@ -16,10 +16,11 @@\n public class DuckDBResultSetMetaData implements ResultSetMetaData {\n \n \tpublic DuckDBResultSetMetaData(int param_count, int column_count, String[] column_names,\n-\t\t\tString[] column_types_string, String[] column_types_details) {\n+\t\t\t\t\t\t\t\t   String[] column_types_string, String[] column_types_details, String return_type) {\n \t\tthis.param_count = param_count;\n \t\tthis.column_count = column_count;\n \t\tthis.column_names = column_names;\n+\t\tthis.return_type = StatementReturnType.valueOf(return_type);\n \t\tthis.column_types_string = column_types_string;\n \t\tthis.column_types_details = column_types_details;\n \t\tArrayList<DuckDBColumnType> column_types_al = new ArrayList<DuckDBColumnType>(column_count);\n@@ -59,6 +60,7 @@ public static DuckDBColumnType TypeNameToType(String type_name) {\n \tprotected String[] column_types_details;\n \tprotected DuckDBColumnType[] column_types;\n \tprotected DuckDBColumnTypeMetaData[] column_types_meta;\n+\tprotected final StatementReturnType return_type;\n \n \tpublic int getColumnCount() throws SQLException {\n \t\treturn column_count;\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/StatementReturnType.java b/tools/jdbc/src/main/java/org/duckdb/StatementReturnType.java\nnew file mode 100644\nindex 000000000000..8048217eeb9a\n--- /dev/null\n+++ b/tools/jdbc/src/main/java/org/duckdb/StatementReturnType.java\n@@ -0,0 +1,7 @@\n+package org.duckdb;\n+\n+public enum StatementReturnType {\n+    QUERY_RESULT, // the statement returns a query result (e.g. for display to the user)\n+    CHANGED_ROWS, // the statement returns a single row containing the number of changed rows (e.g. an insert stmt)\n+    NOTHING       // the statement returns nothing\n+}\n",
  "test_patch": "diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex 6d0cc85f2d7c..3917fb51f772 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -2311,6 +2311,23 @@ public static void test_bug966_typeof() throws Exception {\n \t\tassertEquals(rs.getString(1), \"INTEGER\");\n \t}\n \n+\tpublic static void test_describe() throws Exception {\n+\t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n+\n+\t\ttry (Statement stmt = conn.createStatement()) {\n+\t\t\tstmt.execute(\"CREATE TABLE TEST (COL INT DEFAULT 42)\");\n+\n+\t\t\tResultSet rs = stmt.executeQuery(\"DESCRIBE SELECT * FROM TEST\");\n+\t\t\trs.next();\n+\t\t\tassertEquals(rs.getString(\"column_name\"), \"COL\");\n+\t\t\tassertEquals(rs.getString(\"column_type\"), \"INTEGER\");\n+\t\t\tassertEquals(rs.getString(\"null\"), \"YES\");\n+\t\t\tassertNull(rs.getString(\"key\"));\n+\t\t\tassertNull(rs.getString(\"default\"));\n+\t\t\tassertNull(rs.getString(\"extra\"));\n+\t\t}\n+\t}\n+\n \tpublic static void main(String[] args) throws Exception {\n \t\t// Woo I can do reflection too, take this, JUnit!\n \t\tMethod[] methods = TestDuckDBJDBC.class.getMethods();\n",
  "problem_statement": "DBeaver does not support DESCRIBE SELECT * FROM \"path\"\n### What happens?\n\nWhen running query `DESCRIBE SELECT * FROM \"path\"` there is no results (0 rows fetched).\r\nIt works fine with tables.\r\n\r\nDBeaver Version 22.2.0.202209051344\r\nJDBC driver with DuckDB downloaded via DBeaver dialog (i think it downloads from Maven?) version 0.5.1\n\n### To Reproduce\n\nRun `DESCRIBE SELECT * FROM \"path\"` on any file (tested with csv and parquet in an inmemory database).\n\n### OS:\n\nLinux and Windows\n\n### DuckDB Version:\n\n0.5.1\n\n### DuckDB Client:\n\nDBeaver JDBC driver\n\n### Full Name:\n\nTomasz Tara\u015b\n\n### Affiliation:\n\nDXC\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2022-09-26T06:59:58Z"
}