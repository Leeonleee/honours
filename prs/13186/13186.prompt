You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Scalar function without input parameters
### What happens?

When I register a scalar function without any parameters, the chunk that I get in the callback has size 1 no matter how many rows there are in the table.

### To Reproduce

```c
int main()
{
	duckdb_database db;
	duckdb_connection con;
	duckdb_state state;
	duckdb_result result;
	duckdb_prepared_statement preparedStatement;

	duckdb_open(NULL, &db);
	duckdb_connect(db, &con);

	std::cout << duckdb_library_version();
	state = duckdb_query(con, "CREATE TABLE big_table_1 AS SELECT (greatest(random(), 0.1) * 1000)::BIGINT i FROM range(1000) t(i);", &result);

	auto scalar_function = duckdb_create_scalar_function();
	duckdb_scalar_function_set_name(scalar_function, "my_random");

	//duckdb_scalar_function_add_parameter(scalar_function, duckdb_create_logical_type(DUCKDB_TYPE_BIGINT));

	duckdb_scalar_function_set_return_type(scalar_function, duckdb_create_logical_type(DUCKDB_TYPE_INTEGER));
	duckdb_scalar_function_set_function(scalar_function, my_random);

	state = duckdb_register_scalar_function(con, scalar_function);

	state = duckdb_query(con, "select my_random() from big_table_1;", &result);
	//state = duckdb_query(con, "select my_random(i) from big_table_1;", &result);

	duckdb_disconnect(&con);
	duckdb_close(&db);
}

void my_random(duckdb_function_info, duckdb_data_chunk input, duckdb_vector output) {
	auto size = duckdb_data_chunk_get_size(input);  --Size is 1 after this call
}
```

If you uncomment the commented lines, `size` will be 1000 in the `my_random` calllback

### OS:

Windows 11 x64

### DuckDB Version:

1.0.1-dev3196

### DuckDB Client:

C Api

### Full Name:

Giorgi Dalakishvili

### Affiliation:

Space International

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a nightly build

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/include/duckdb.h]
1: //===----------------------------------------------------------------------===//
2: //
3: //                         DuckDB
4: //
5: // duckdb.h
6: //
7: //
8: //===----------------------------------------------------------------------===//
9: 
10: #pragma once
11: 
12: //! duplicate of duckdb/main/winapi.hpp
13: #ifndef DUCKDB_API
14: #ifdef _WIN32
15: #if defined(DUCKDB_BUILD_LIBRARY) && !defined(DUCKDB_BUILD_LOADABLE_EXTENSION)
16: #define DUCKDB_API __declspec(dllexport)
17: #else
18: #define DUCKDB_API __declspec(dllimport)
19: #endif
20: #else
21: #define DUCKDB_API
22: #endif
23: #endif
24: 
25: //! duplicate of duckdb/main/winapi.hpp
26: #ifndef DUCKDB_EXTENSION_API
27: #ifdef _WIN32
28: #ifdef DUCKDB_BUILD_LOADABLE_EXTENSION
29: #define DUCKDB_EXTENSION_API __declspec(dllexport)
30: #else
31: #define DUCKDB_EXTENSION_API
32: #endif
33: #else
34: #define DUCKDB_EXTENSION_API __attribute__((visibility("default")))
35: #endif
36: #endif
37: 
38: //! In the future, we are planning to move extension functions to a separate header. For now you can set the define
39: //! below to remove the functions that are planned to be moved out of this header.
40: // #define DUCKDB_NO_EXTENSION_FUNCTIONS
41: 
42: //! Set the define below to remove all functions that are deprecated or planned to be deprecated
43: // #define DUCKDB_API_NO_DEPRECATED
44: 
45: //! API versions
46: //! If no explicit API version is defined, the latest API version is used.
47: //! Note that using older API versions (i.e. not using DUCKDB_API_LATEST) is deprecated.
48: //! These will not be supported long-term, and will be removed in future versions.
49: #ifndef DUCKDB_API_0_3_1
50: #define DUCKDB_API_0_3_1 1
51: #endif
52: #ifndef DUCKDB_API_0_3_2
53: #define DUCKDB_API_0_3_2 2
54: #endif
55: #ifndef DUCKDB_API_LATEST
56: #define DUCKDB_API_LATEST DUCKDB_API_0_3_2
57: #endif
58: 
59: #ifndef DUCKDB_API_VERSION
60: #define DUCKDB_API_VERSION DUCKDB_API_LATEST
61: #endif
62: 
63: #include <stdbool.h>
64: #include <stdint.h>
65: #include <stddef.h>
66: 
67: #ifdef __cplusplus
68: extern "C" {
69: #endif
70: 
71: //===--------------------------------------------------------------------===//
72: // Enums
73: //===--------------------------------------------------------------------===//
74: // WARNING: the numbers of these enums should not be changed, as changing the numbers breaks ABI compatibility
75: // Always add enums at the END of the enum
76: //! An enum over DuckDB's internal types.
77: typedef enum DUCKDB_TYPE {
78: 	DUCKDB_TYPE_INVALID = 0,
79: 	// bool
80: 	DUCKDB_TYPE_BOOLEAN = 1,
81: 	// int8_t
82: 	DUCKDB_TYPE_TINYINT = 2,
83: 	// int16_t
84: 	DUCKDB_TYPE_SMALLINT = 3,
85: 	// int32_t
86: 	DUCKDB_TYPE_INTEGER = 4,
87: 	// int64_t
88: 	DUCKDB_TYPE_BIGINT = 5,
89: 	// uint8_t
90: 	DUCKDB_TYPE_UTINYINT = 6,
91: 	// uint16_t
92: 	DUCKDB_TYPE_USMALLINT = 7,
93: 	// uint32_t
94: 	DUCKDB_TYPE_UINTEGER = 8,
95: 	// uint64_t
96: 	DUCKDB_TYPE_UBIGINT = 9,
97: 	// float
98: 	DUCKDB_TYPE_FLOAT = 10,
99: 	// double
100: 	DUCKDB_TYPE_DOUBLE = 11,
101: 	// duckdb_timestamp, in microseconds
102: 	DUCKDB_TYPE_TIMESTAMP = 12,
103: 	// duckdb_date
104: 	DUCKDB_TYPE_DATE = 13,
105: 	// duckdb_time
106: 	DUCKDB_TYPE_TIME = 14,
107: 	// duckdb_interval
108: 	DUCKDB_TYPE_INTERVAL = 15,
109: 	// duckdb_hugeint
110: 	DUCKDB_TYPE_HUGEINT = 16,
111: 	// duckdb_uhugeint
112: 	DUCKDB_TYPE_UHUGEINT = 32,
113: 	// const char*
114: 	DUCKDB_TYPE_VARCHAR = 17,
115: 	// duckdb_blob
116: 	DUCKDB_TYPE_BLOB = 18,
117: 	// decimal
118: 	DUCKDB_TYPE_DECIMAL = 19,
119: 	// duckdb_timestamp, in seconds
120: 	DUCKDB_TYPE_TIMESTAMP_S = 20,
121: 	// duckdb_timestamp, in milliseconds
122: 	DUCKDB_TYPE_TIMESTAMP_MS = 21,
123: 	// duckdb_timestamp, in nanoseconds
124: 	DUCKDB_TYPE_TIMESTAMP_NS = 22,
125: 	// enum type, only useful as logical type
126: 	DUCKDB_TYPE_ENUM = 23,
127: 	// list type, only useful as logical type
128: 	DUCKDB_TYPE_LIST = 24,
129: 	// struct type, only useful as logical type
130: 	DUCKDB_TYPE_STRUCT = 25,
131: 	// map type, only useful as logical type
132: 	DUCKDB_TYPE_MAP = 26,
133: 	// duckdb_array, only useful as logical type
134: 	DUCKDB_TYPE_ARRAY = 33,
135: 	// duckdb_hugeint
136: 	DUCKDB_TYPE_UUID = 27,
137: 	// union type, only useful as logical type
138: 	DUCKDB_TYPE_UNION = 28,
139: 	// duckdb_bit
140: 	DUCKDB_TYPE_BIT = 29,
141: 	// duckdb_time_tz
142: 	DUCKDB_TYPE_TIME_TZ = 30,
143: 	// duckdb_timestamp
144: 	DUCKDB_TYPE_TIMESTAMP_TZ = 31,
145: 	// ANY type
146: 	DUCKDB_TYPE_ANY = 34,
147: 	// duckdb_varint
148: 	DUCKDB_TYPE_VARINT = 35,
149: } duckdb_type;
150: //! An enum over the returned state of different functions.
151: typedef enum duckdb_state { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;
152: //! An enum over the pending state of a pending query result.
153: typedef enum duckdb_pending_state {
154: 	DUCKDB_PENDING_RESULT_READY = 0,
155: 	DUCKDB_PENDING_RESULT_NOT_READY = 1,
156: 	DUCKDB_PENDING_ERROR = 2,
157: 	DUCKDB_PENDING_NO_TASKS_AVAILABLE = 3
158: } duckdb_pending_state;
159: //! An enum over DuckDB's different result types.
160: typedef enum duckdb_result_type {
161: 	DUCKDB_RESULT_TYPE_INVALID = 0,
162: 	DUCKDB_RESULT_TYPE_CHANGED_ROWS = 1,
163: 	DUCKDB_RESULT_TYPE_NOTHING = 2,
164: 	DUCKDB_RESULT_TYPE_QUERY_RESULT = 3,
165: } duckdb_result_type;
166: //! An enum over DuckDB's different statement types.
167: typedef enum duckdb_statement_type {
168: 	DUCKDB_STATEMENT_TYPE_INVALID = 0,
169: 	DUCKDB_STATEMENT_TYPE_SELECT = 1,
170: 	DUCKDB_STATEMENT_TYPE_INSERT = 2,
171: 	DUCKDB_STATEMENT_TYPE_UPDATE = 3,
172: 	DUCKDB_STATEMENT_TYPE_EXPLAIN = 4,
173: 	DUCKDB_STATEMENT_TYPE_DELETE = 5,
174: 	DUCKDB_STATEMENT_TYPE_PREPARE = 6,
175: 	DUCKDB_STATEMENT_TYPE_CREATE = 7,
176: 	DUCKDB_STATEMENT_TYPE_EXECUTE = 8,
177: 	DUCKDB_STATEMENT_TYPE_ALTER = 9,
178: 	DUCKDB_STATEMENT_TYPE_TRANSACTION = 10,
179: 	DUCKDB_STATEMENT_TYPE_COPY = 11,
180: 	DUCKDB_STATEMENT_TYPE_ANALYZE = 12,
181: 	DUCKDB_STATEMENT_TYPE_VARIABLE_SET = 13,
182: 	DUCKDB_STATEMENT_TYPE_CREATE_FUNC = 14,
183: 	DUCKDB_STATEMENT_TYPE_DROP = 15,
184: 	DUCKDB_STATEMENT_TYPE_EXPORT = 16,
185: 	DUCKDB_STATEMENT_TYPE_PRAGMA = 17,
186: 	DUCKDB_STATEMENT_TYPE_VACUUM = 18,
187: 	DUCKDB_STATEMENT_TYPE_CALL = 19,
188: 	DUCKDB_STATEMENT_TYPE_SET = 20,
189: 	DUCKDB_STATEMENT_TYPE_LOAD = 21,
190: 	DUCKDB_STATEMENT_TYPE_RELATION = 22,
191: 	DUCKDB_STATEMENT_TYPE_EXTENSION = 23,
192: 	DUCKDB_STATEMENT_TYPE_LOGICAL_PLAN = 24,
193: 	DUCKDB_STATEMENT_TYPE_ATTACH = 25,
194: 	DUCKDB_STATEMENT_TYPE_DETACH = 26,
195: 	DUCKDB_STATEMENT_TYPE_MULTI = 27,
196: } duckdb_statement_type;
197: //! An enum over DuckDB's different result types.
198: typedef enum duckdb_error_type {
199: 	DUCKDB_ERROR_INVALID = 0,
200: 	DUCKDB_ERROR_OUT_OF_RANGE = 1,
201: 	DUCKDB_ERROR_CONVERSION = 2,
202: 	DUCKDB_ERROR_UNKNOWN_TYPE = 3,
203: 	DUCKDB_ERROR_DECIMAL = 4,
204: 	DUCKDB_ERROR_MISMATCH_TYPE = 5,
205: 	DUCKDB_ERROR_DIVIDE_BY_ZERO = 6,
206: 	DUCKDB_ERROR_OBJECT_SIZE = 7,
207: 	DUCKDB_ERROR_INVALID_TYPE = 8,
208: 	DUCKDB_ERROR_SERIALIZATION = 9,
209: 	DUCKDB_ERROR_TRANSACTION = 10,
210: 	DUCKDB_ERROR_NOT_IMPLEMENTED = 11,
211: 	DUCKDB_ERROR_EXPRESSION = 12,
212: 	DUCKDB_ERROR_CATALOG = 13,
213: 	DUCKDB_ERROR_PARSER = 14,
214: 	DUCKDB_ERROR_PLANNER = 15,
215: 	DUCKDB_ERROR_SCHEDULER = 16,
216: 	DUCKDB_ERROR_EXECUTOR = 17,
217: 	DUCKDB_ERROR_CONSTRAINT = 18,
218: 	DUCKDB_ERROR_INDEX = 19,
219: 	DUCKDB_ERROR_STAT = 20,
220: 	DUCKDB_ERROR_CONNECTION = 21,
221: 	DUCKDB_ERROR_SYNTAX = 22,
222: 	DUCKDB_ERROR_SETTINGS = 23,
223: 	DUCKDB_ERROR_BINDER = 24,
224: 	DUCKDB_ERROR_NETWORK = 25,
225: 	DUCKDB_ERROR_OPTIMIZER = 26,
226: 	DUCKDB_ERROR_NULL_POINTER = 27,
227: 	DUCKDB_ERROR_IO = 28,
228: 	DUCKDB_ERROR_INTERRUPT = 29,
229: 	DUCKDB_ERROR_FATAL = 30,
230: 	DUCKDB_ERROR_INTERNAL = 31,
231: 	DUCKDB_ERROR_INVALID_INPUT = 32,
232: 	DUCKDB_ERROR_OUT_OF_MEMORY = 33,
233: 	DUCKDB_ERROR_PERMISSION = 34,
234: 	DUCKDB_ERROR_PARAMETER_NOT_RESOLVED = 35,
235: 	DUCKDB_ERROR_PARAMETER_NOT_ALLOWED = 36,
236: 	DUCKDB_ERROR_DEPENDENCY = 37,
237: 	DUCKDB_ERROR_HTTP = 38,
238: 	DUCKDB_ERROR_MISSING_EXTENSION = 39,
239: 	DUCKDB_ERROR_AUTOLOAD = 40,
240: 	DUCKDB_ERROR_SEQUENCE = 41
241: } duckdb_error_type;
242: 
243: //===--------------------------------------------------------------------===//
244: // General type definitions
245: //===--------------------------------------------------------------------===//
246: 
247: //! DuckDB's index type.
248: typedef uint64_t idx_t;
249: 
250: //! The callback that will be called to destroy data, e.g.,
251: //! bind data (if any), init data (if any), extra data for replacement scans (if any)
252: typedef void (*duckdb_delete_callback_t)(void *data);
253: 
254: //! Used for threading, contains a task state. Must be destroyed with `duckdb_destroy_state`.
255: typedef void *duckdb_task_state;
256: 
257: //===--------------------------------------------------------------------===//
258: // Types (no explicit freeing)
259: //===--------------------------------------------------------------------===//
260: 
261: //! Days are stored as days since 1970-01-01
262: //! Use the duckdb_from_date/duckdb_to_date function to extract individual information
263: typedef struct {
264: 	int32_t days;
265: } duckdb_date;
266: typedef struct {
267: 	int32_t year;
268: 	int8_t month;
269: 	int8_t day;
270: } duckdb_date_struct;
271: 
272: //! Time is stored as microseconds since 00:00:00
273: //! Use the duckdb_from_time/duckdb_to_time function to extract individual information
274: typedef struct {
275: 	int64_t micros;
276: } duckdb_time;
277: typedef struct {
278: 	int8_t hour;
279: 	int8_t min;
280: 	int8_t sec;
281: 	int32_t micros;
282: } duckdb_time_struct;
283: 
284: //! TIME_TZ is stored as 40 bits for int64_t micros, and 24 bits for int32_t offset
285: typedef struct {
286: 	uint64_t bits;
287: } duckdb_time_tz;
288: typedef struct {
289: 	duckdb_time_struct time;
290: 	int32_t offset;
291: } duckdb_time_tz_struct;
292: 
293: //! Timestamps are stored as microseconds since 1970-01-01
294: //! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information
295: typedef struct {
296: 	int64_t micros;
297: } duckdb_timestamp;
298: typedef struct {
299: 	duckdb_date_struct date;
300: 	duckdb_time_struct time;
301: } duckdb_timestamp_struct;
302: typedef struct {
303: 	int32_t months;
304: 	int32_t days;
305: 	int64_t micros;
306: } duckdb_interval;
307: 
308: //! Hugeints are composed of a (lower, upper) component
309: //! The value of the hugeint is upper * 2^64 + lower
310: //! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended
311: typedef struct {
312: 	uint64_t lower;
313: 	int64_t upper;
314: } duckdb_hugeint;
315: typedef struct {
316: 	uint64_t lower;
317: 	uint64_t upper;
318: } duckdb_uhugeint;
319: 
320: //! Decimals are composed of a width and a scale, and are stored in a hugeint
321: typedef struct {
322: 	uint8_t width;
323: 	uint8_t scale;
324: 	duckdb_hugeint value;
325: } duckdb_decimal;
326: 
327: //! A type holding information about the query execution progress
328: typedef struct {
329: 	double percentage;
330: 	uint64_t rows_processed;
331: 	uint64_t total_rows_to_process;
332: } duckdb_query_progress_type;
333: 
334: //! The internal representation of a VARCHAR (string_t). If the VARCHAR does not
335: //! exceed 12 characters, then we inline it. Otherwise, we inline a prefix for faster
336: //! string comparisons and store a pointer to the remaining characters. This is a non-
337: //! owning structure, i.e., it does not have to be freed.
338: typedef struct {
339: 	union {
340: 		struct {
341: 			uint32_t length;
342: 			char prefix[4];
343: 			char *ptr;
344: 		} pointer;
345: 		struct {
346: 			uint32_t length;
347: 			char inlined[12];
348: 		} inlined;
349: 	} value;
350: } duckdb_string_t;
351: 
352: //! The internal representation of a list metadata entry contains the list's offset in
353: //! the child vector, and its length. The parent vector holds these metadata entries,
354: //! whereas the child vector holds the data
355: typedef struct {
356: 	uint64_t offset;
357: 	uint64_t length;
358: } duckdb_list_entry;
359: 
360: //! A column consists of a pointer to its internal data. Don't operate on this type directly.
361: //! Instead, use functions such as duckdb_column_data, duckdb_nullmask_data,
362: //! duckdb_column_type, and duckdb_column_name, which take the result and the column index
363: //! as their parameters
364: typedef struct {
365: #if DUCKDB_API_VERSION < DUCKDB_API_0_3_2
366: 	void *data;
367: 	bool *nullmask;
368: 	duckdb_type type;
369: 	char *name;
370: #else
371: 	// deprecated, use duckdb_column_data
372: 	void *__deprecated_data;
373: 	// deprecated, use duckdb_nullmask_data
374: 	bool *__deprecated_nullmask;
375: 	// deprecated, use duckdb_column_type
376: 	duckdb_type __deprecated_type;
377: 	// deprecated, use duckdb_column_name
378: 	char *__deprecated_name;
379: #endif
380: 	void *internal_data;
381: } duckdb_column;
382: 
383: //! A vector to a specified column in a data chunk. Lives as long as the
384: //! data chunk lives, i.e., must not be destroyed.
385: typedef struct _duckdb_vector {
386: 	void *__vctr;
387: } * duckdb_vector;
388: 
389: //===--------------------------------------------------------------------===//
390: // Types (explicit freeing/destroying)
391: //===--------------------------------------------------------------------===//
392: 
393: //! Strings are composed of a char pointer and a size. You must free string.data
394: //! with `duckdb_free`.
395: typedef struct {
396: 	char *data;
397: 	idx_t size;
398: } duckdb_string;
399: 
400: //! BLOBs are composed of a byte pointer and a size. You must free blob.data
401: //! with `duckdb_free`.
402: typedef struct {
403: 	void *data;
404: 	idx_t size;
405: } duckdb_blob;
406: 
407: //! A query result consists of a pointer to its internal data.
408: //! Must be freed with 'duckdb_destroy_result'.
409: typedef struct {
410: #if DUCKDB_API_VERSION < DUCKDB_API_0_3_2
411: 	idx_t column_count;
412: 	idx_t row_count;
413: 	idx_t rows_changed;
414: 	duckdb_column *columns;
415: 	char *error_message;
416: #else
417: 	// deprecated, use duckdb_column_count
418: 	idx_t __deprecated_column_count;
419: 	// deprecated, use duckdb_row_count
420: 	idx_t __deprecated_row_count;
421: 	// deprecated, use duckdb_rows_changed
422: 	idx_t __deprecated_rows_changed;
423: 	// deprecated, use duckdb_column_*-family of functions
424: 	duckdb_column *__deprecated_columns;
425: 	// deprecated, use duckdb_result_error
426: 	char *__deprecated_error_message;
427: #endif
428: 	void *internal_data;
429: } duckdb_result;
430: 
431: //! A database object. Should be closed with `duckdb_close`.
432: typedef struct _duckdb_database {
433: 	void *__db;
434: } * duckdb_database;
435: 
436: //! A connection to a duckdb database. Must be closed with `duckdb_disconnect`.
437: typedef struct _duckdb_connection {
438: 	void *__conn;
439: } * duckdb_connection;
440: 
441: //! A prepared statement is a parameterized query that allows you to bind parameters to it.
442: //! Must be destroyed with `duckdb_destroy_prepare`.
443: typedef struct _duckdb_prepared_statement {
444: 	void *__prep;
445: } * duckdb_prepared_statement;
446: 
447: //! Extracted statements. Must be destroyed with `duckdb_destroy_extracted`.
448: typedef struct _duckdb_extracted_statements {
449: 	void *__extrac;
450: } * duckdb_extracted_statements;
451: 
452: //! The pending result represents an intermediate structure for a query that is not yet fully executed.
453: //! Must be destroyed with `duckdb_destroy_pending`.
454: typedef struct _duckdb_pending_result {
455: 	void *__pend;
456: } * duckdb_pending_result;
457: 
458: //! The appender enables fast data loading into DuckDB.
459: //! Must be destroyed with `duckdb_appender_destroy`.
460: typedef struct _duckdb_appender {
461: 	void *__appn;
462: } * duckdb_appender;
463: 
464: //! The table description allows querying info about the table.
465: //! Must be destroyed with `duckdb_table_description_destroy`.
466: typedef struct _duckdb_table_description {
467: 	void *__tabledesc;
468: } * duckdb_table_description;
469: 
470: //! Can be used to provide start-up options for the DuckDB instance.
471: //! Must be destroyed with `duckdb_destroy_config`.
472: typedef struct _duckdb_config {
473: 	void *__cnfg;
474: } * duckdb_config;
475: 
476: //! Holds an internal logical type.
477: //! Must be destroyed with `duckdb_destroy_logical_type`.
478: typedef struct _duckdb_logical_type {
479: 	void *__lglt;
480: } * duckdb_logical_type;
481: 
482: //! Contains a data chunk from a duckdb_result.
483: //! Must be destroyed with `duckdb_destroy_data_chunk`.
484: typedef struct _duckdb_data_chunk {
485: 	void *__dtck;
486: } * duckdb_data_chunk;
487: 
488: //! Holds a DuckDB value, which wraps a type.
489: //! Must be destroyed with `duckdb_destroy_value`.
490: typedef struct _duckdb_value {
491: 	void *__val;
492: } * duckdb_value;
493: 
494: //! Holds a recursive tree that matches the query plan.
495: typedef struct _duckdb_profiling_info {
496: 	void *__prof;
497: } * duckdb_profiling_info;
498: 
499: //===--------------------------------------------------------------------===//
500: // Function types
501: //===--------------------------------------------------------------------===//
502: //! Additional function info. When setting this info, it is necessary to pass a destroy-callback function.
503: typedef struct _duckdb_function_info {
504: 	void *__val;
505: } * duckdb_function_info;
506: 
507: //===--------------------------------------------------------------------===//
508: // Scalar function types
509: //===--------------------------------------------------------------------===//
510: //! A scalar function. Must be destroyed with `duckdb_destroy_scalar_function`.
511: typedef struct _duckdb_scalar_function {
512: 	void *__val;
513: } * duckdb_scalar_function;
514: 
515: //! The main function of the scalar function.
516: typedef void (*duckdb_scalar_function_t)(duckdb_function_info info, duckdb_data_chunk input, duckdb_vector output);
517: 
518: //===--------------------------------------------------------------------===//
519: // Table function types
520: //===--------------------------------------------------------------------===//
521: 
522: #ifndef DUCKDB_NO_EXTENSION_FUNCTIONS
523: //! A table function. Must be destroyed with `duckdb_destroy_table_function`.
524: typedef struct _duckdb_table_function {
525: 	void *__val;
526: } * duckdb_table_function;
527: 
528: //! The bind info of the function. When setting this info, it is necessary to pass a destroy-callback function.
529: typedef struct _duckdb_bind_info {
530: 	void *__val;
531: } * duckdb_bind_info;
532: 
533: //! Additional function init info. When setting this info, it is necessary to pass a destroy-callback function.
534: typedef struct _duckdb_init_info {
535: 	void *__val;
536: } * duckdb_init_info;
537: 
538: //! The bind function of the table function.
539: typedef void (*duckdb_table_function_bind_t)(duckdb_bind_info info);
540: 
541: //! The (possibly thread-local) init function of the table function.
542: typedef void (*duckdb_table_function_init_t)(duckdb_init_info info);
543: 
544: //! The main function of the table function.
545: typedef void (*duckdb_table_function_t)(duckdb_function_info info, duckdb_data_chunk output);
546: 
547: //===--------------------------------------------------------------------===//
548: // Replacement scan types
549: //===--------------------------------------------------------------------===//
550: 
551: //! Additional replacement scan info. When setting this info, it is necessary to pass a destroy-callback function.
552: typedef struct _duckdb_replacement_scan_info {
553: 	void *__val;
554: } * duckdb_replacement_scan_info;
555: 
556: //! A replacement scan function that can be added to a database.
557: typedef void (*duckdb_replacement_callback_t)(duckdb_replacement_scan_info info, const char *table_name, void *data);
558: #endif
559: 
560: //===--------------------------------------------------------------------===//
561: // Arrow-related types
562: //===--------------------------------------------------------------------===//
563: 
564: //! Holds an arrow query result. Must be destroyed with `duckdb_destroy_arrow`.
565: typedef struct _duckdb_arrow {
566: 	void *__arrw;
567: } * duckdb_arrow;
568: 
569: //! Holds an arrow array stream. Must be destroyed with `duckdb_destroy_arrow_stream`.
570: typedef struct _duckdb_arrow_stream {
571: 	void *__arrwstr;
572: } * duckdb_arrow_stream;
573: 
574: //! Holds an arrow schema. Remember to release the respective ArrowSchema object.
575: typedef struct _duckdb_arrow_schema {
576: 	void *__arrs;
577: } * duckdb_arrow_schema;
578: 
579: //! Holds an arrow array. Remember to release the respective ArrowArray object.
580: typedef struct _duckdb_arrow_array {
581: 	void *__arra;
582: } * duckdb_arrow_array;
583: 
584: //===--------------------------------------------------------------------===//
585: // Functions
586: //===--------------------------------------------------------------------===//
587: 
588: //===--------------------------------------------------------------------===//
589: // Open/Connect
590: //===--------------------------------------------------------------------===//
591: 
592: /*!
593: Creates a new database or opens an existing database file stored at the given path.
594: If no path is given a new in-memory database is created instead.
595: The instantiated database should be closed with 'duckdb_close'.
596: 
597: * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
598: * out_database: The result database object.
599: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
600: */
601: DUCKDB_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);
602: 
603: /*!
604: Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the given path.
605: The instantiated database should be closed with 'duckdb_close'.
606: 
607: * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
608: * out_database: The result database object.
609: * config: (Optional) configuration used to start up the database system.
610: * out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.
611: Note that the error must be freed using `duckdb_free`.
612: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
613: */
614: DUCKDB_API duckdb_state duckdb_open_ext(const char *path, duckdb_database *out_database, duckdb_config config,
615:                                         char **out_error);
616: 
617: /*!
618: Closes the specified database and de-allocates all memory allocated for that database.
619: This should be called after you are done with any database allocated through `duckdb_open` or `duckdb_open_ext`.
620: Note that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.
621: Still, it is recommended to always correctly close a database object after you are done with it.
622: 
623: * database: The database object to shut down.
624: */
625: DUCKDB_API void duckdb_close(duckdb_database *database);
626: 
627: /*!
628: Opens a connection to a database. Connections are required to query the database, and store transactional state
629: associated with the connection.
630: The instantiated connection should be closed using 'duckdb_disconnect'.
631: 
632: * database: The database file to connect to.
633: * out_connection: The result connection object.
634: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
635: */
636: DUCKDB_API duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out_connection);
637: 
638: /*!
639: Interrupt running query
640: 
641: * connection: The connection to interrupt
642: */
643: DUCKDB_API void duckdb_interrupt(duckdb_connection connection);
644: 
645: /*!
646: Get progress of the running query
647: 
648: * connection: The working connection
649: * returns: -1 if no progress or a percentage of the progress
650: */
651: DUCKDB_API duckdb_query_progress_type duckdb_query_progress(duckdb_connection connection);
652: 
653: /*!
654: Closes the specified connection and de-allocates all memory allocated for that connection.
655: 
656: * connection: The connection to close.
657: */
658: DUCKDB_API void duckdb_disconnect(duckdb_connection *connection);
659: 
660: /*!
661: Returns the version of the linked DuckDB, with a version postfix for dev versions
662: 
663: Usually used for developing C extensions that must return this for a compatibility check.
664: */
665: DUCKDB_API const char *duckdb_library_version();
666: 
667: //===--------------------------------------------------------------------===//
668: // Configuration
669: //===--------------------------------------------------------------------===//
670: 
671: /*!
672: Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance
673: through `duckdb_open_ext`.
674: The duckdb_config must be destroyed using 'duckdb_destroy_config'
675: 
676: This will always succeed unless there is a malloc failure.
677: 
678: Note that `duckdb_destroy_config` should always be called on the resulting config, even if the function returns
679: `DuckDBError`.
680: 
681: * out_config: The result configuration object.
682: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
683: */
684: DUCKDB_API duckdb_state duckdb_create_config(duckdb_config *out_config);
685: 
686: /*!
687: This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.
688: 
689: This should not be called in a loop as it internally loops over all the options.
690: 
691: * returns: The amount of config options available.
692: */
693: DUCKDB_API size_t duckdb_config_count();
694: 
695: /*!
696: Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.
697: display configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).
698: 
699: The result name or description MUST NOT be freed.
700: 
701: * index: The index of the configuration option (between 0 and `duckdb_config_count`)
702: * out_name: A name of the configuration flag.
703: * out_description: A description of the configuration flag.
704: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
705: */
706: DUCKDB_API duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description);
707: 
708: /*!
709: Sets the specified option for the specified configuration. The configuration option is indicated by name.
710: To obtain a list of config options, see `duckdb_get_config_flag`.
711: 
712: In the source code, configuration options are defined in `config.cpp`.
713: 
714: This can fail if either the name is invalid, or if the value provided for the option is invalid.
715: 
716: * duckdb_config: The configuration object to set the option on.
717: * name: The name of the configuration flag to set.
718: * option: The value to set the configuration flag to.
719: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
720: */
721: DUCKDB_API duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option);
722: 
723: /*!
724: Destroys the specified configuration object and de-allocates all memory allocated for the object.
725: 
726: * config: The configuration object to destroy.
727: */
728: DUCKDB_API void duckdb_destroy_config(duckdb_config *config);
729: 
730: //===--------------------------------------------------------------------===//
731: // Query Execution
732: //===--------------------------------------------------------------------===//
733: 
734: /*!
735: Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.
736: If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
737: `duckdb_result_error`.
738: 
739: Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the
740: query fails, otherwise the error stored within the result will not be freed correctly.
741: 
742: * connection: The connection to perform the query in.
743: * query: The SQL query to run.
744: * out_result: The query result.
745: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
746: */
747: DUCKDB_API duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out_result);
748: 
749: /*!
750: Closes the result and de-allocates all memory allocated for that connection.
751: 
752: * result: The result to destroy.
753: */
754: DUCKDB_API void duckdb_destroy_result(duckdb_result *result);
755: 
756: /*!
757: Returns the column name of the specified column. The result should not need to be freed; the column names will
758: automatically be destroyed when the result is destroyed.
759: 
760: Returns `NULL` if the column is out of range.
761: 
762: * result: The result object to fetch the column name from.
763: * col: The column index.
764: * returns: The column name of the specified column.
765: */
766: DUCKDB_API const char *duckdb_column_name(duckdb_result *result, idx_t col);
767: 
768: /*!
769: Returns the column type of the specified column.
770: 
771: Returns `DUCKDB_TYPE_INVALID` if the column is out of range.
772: 
773: * result: The result object to fetch the column type from.
774: * col: The column index.
775: * returns: The column type of the specified column.
776: */
777: DUCKDB_API duckdb_type duckdb_column_type(duckdb_result *result, idx_t col);
778: 
779: /*!
780: Returns the statement type of the statement that was executed
781: 
782: * result: The result object to fetch the statement type from.
783:  * returns: duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID
784:  */
785: DUCKDB_API duckdb_statement_type duckdb_result_statement_type(duckdb_result result);
786: 
787: /*!
788: Returns the logical column type of the specified column.
789: 
790: The return type of this call should be destroyed with `duckdb_destroy_logical_type`.
791: 
792: Returns `NULL` if the column is out of range.
793: 
794: * result: The result object to fetch the column type from.
795: * col: The column index.
796: * returns: The logical column type of the specified column.
797: */
798: DUCKDB_API duckdb_logical_type duckdb_column_logical_type(duckdb_result *result, idx_t col);
799: 
800: /*!
801: Returns the number of columns present in a the result object.
802: 
803: * result: The result object.
804: * returns: The number of columns present in the result object.
805: */
806: DUCKDB_API idx_t duckdb_column_count(duckdb_result *result);
807: 
808: #ifndef DUCKDB_API_NO_DEPRECATED
809: /*!
810: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
811: 
812: Returns the number of rows present in the result object.
813: 
814: * result: The result object.
815: * returns: The number of rows present in the result object.
816: */
817: DUCKDB_API idx_t duckdb_row_count(duckdb_result *result);
818: #endif
819: 
820: /*!
821: Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE
822: queries. For other queries the rows_changed will be 0.
823: 
824: * result: The result object.
825: * returns: The number of rows changed.
826: */
827: DUCKDB_API idx_t duckdb_rows_changed(duckdb_result *result);
828: 
829: #ifndef DUCKDB_API_NO_DEPRECATED
830: /*!
831: **DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.
832: 
833: Returns the data of a specific column of a result in columnar format.
834: 
835: The function returns a dense array which contains the result data. The exact type stored in the array depends on the
836: corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
837: accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.
838: 
839: For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:
840: ```c
841: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
842: printf("Data for row %d: %d\n", row, data[row]);
843: ```
844: 
845: * result: The result object to fetch the column data from.
846: * col: The column index.
847: * returns: The column data of the specified column.
848: */
849: DUCKDB_API void *duckdb_column_data(duckdb_result *result, idx_t col);
850: 
851: /*!
852: **DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.
853: 
854: Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
855: whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
856: by `duckdb_column_data` are undefined.
857: 
858: ```c
859: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
860: bool *nullmask = duckdb_nullmask_data(&result, 0);
861: if (nullmask[row]) {
862:     printf("Data for row %d: NULL\n", row);
863: } else {
864:     printf("Data for row %d: %d\n", row, data[row]);
865: }
866: ```
867: 
868: * result: The result object to fetch the nullmask from.
869: * col: The column index.
870: * returns: The nullmask of the specified column.
871: */
872: DUCKDB_API bool *duckdb_nullmask_data(duckdb_result *result, idx_t col);
873: #endif
874: 
875: /*!
876: Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.
877: 
878: The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.
879: 
880: * result: The result object to fetch the error from.
881: * returns: The error of the result.
882: */
883: DUCKDB_API const char *duckdb_result_error(duckdb_result *result);
884: 
885: /*!
886: Returns the result error type contained within the result. The error is only set if `duckdb_query` returns
887: `DuckDBError`.
888: 
889: * result: The result object to fetch the error from.
890: * returns: The error type of the result.
891: */
892: DUCKDB_API duckdb_error_type duckdb_result_error_type(duckdb_result *result);
893: 
894: //===--------------------------------------------------------------------===//
895: // Result Functions
896: //===--------------------------------------------------------------------===//
897: #ifndef DUCKDB_API_NO_DEPRECATED
898: /*!
899: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
900: 
901: Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.
902: 
903: The result must be destroyed with `duckdb_destroy_data_chunk`.
904: 
905: This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data`
906: functions. It results in significantly better performance, and should be preferred in newer code-bases.
907: 
908: If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be
909: mixed with the legacy result functions).
910: 
911: Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.
912: 
913: * result: The result object to fetch the data chunk from.
914: * chunk_index: The chunk index to fetch from.
915: * returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
916: */
917: DUCKDB_API duckdb_data_chunk duckdb_result_get_chunk(duckdb_result result, idx_t chunk_index);
918: 
919: /*!
920: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
921: 
922: Checks if the type of the internal result is StreamQueryResult.
923: 
924: * result: The result object to check.
925: * returns: Whether or not the result object is of the type StreamQueryResult
926: */
927: DUCKDB_API bool duckdb_result_is_streaming(duckdb_result result);
928: 
929: /*!
930: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
931: 
932: Returns the number of data chunks present in the result.
933: 
934: * result: The result object
935: * returns: Number of data chunks present in the result.
936: */
937: DUCKDB_API idx_t duckdb_result_chunk_count(duckdb_result result);
938: #endif
939: 
940: /*!
941: Returns the return_type of the given result, or DUCKDB_RETURN_TYPE_INVALID on error
942: 
943: * result: The result object
944: * returns: The return_type
945:  */
946: DUCKDB_API duckdb_result_type duckdb_result_return_type(duckdb_result result);
947: 
948: #ifndef DUCKDB_API_NO_DEPRECATED
949: //===--------------------------------------------------------------------===//
950: // Safe fetch functions
951: //===--------------------------------------------------------------------===//
952: 
953: // These functions will perform conversions if necessary.
954: // On failure (e.g. if conversion cannot be performed or if the value is NULL) a default value is returned.
955: // Note that these functions are slow since they perform bounds checking and conversion
956: // For fast access of values prefer using `duckdb_result_get_chunk`
957: 
958: /*!
959: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
960: 
961:  * returns: The boolean value at the specified location, or false if the value cannot be converted.
962:  */
963: DUCKDB_API bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row);
964: 
965: /*!
966: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
967: 
968:  * returns: The int8_t value at the specified location, or 0 if the value cannot be converted.
969:  */
970: DUCKDB_API int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row);
971: 
972: /*!
973: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
974: 
975:  * returns: The int16_t value at the specified location, or 0 if the value cannot be converted.
976:  */
977: DUCKDB_API int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row);
978: 
979: /*!
980: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
981: 
982:  * returns: The int32_t value at the specified location, or 0 if the value cannot be converted.
983:  */
984: DUCKDB_API int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row);
985: 
986: /*!
987: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
988: 
989:  * returns: The int64_t value at the specified location, or 0 if the value cannot be converted.
990:  */
991: DUCKDB_API int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row);
992: 
993: /*!
994: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
995: 
996:  * returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.
997:  */
998: DUCKDB_API duckdb_hugeint duckdb_value_hugeint(duckdb_result *result, idx_t col, idx_t row);
999: 
1000: /*!
1001: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1002: 
1003:  * returns: The duckdb_uhugeint value at the specified location, or 0 if the value cannot be converted.
1004:  */
1005: DUCKDB_API duckdb_uhugeint duckdb_value_uhugeint(duckdb_result *result, idx_t col, idx_t row);
1006: 
1007: /*!
1008: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1009: 
1010:  * returns: The duckdb_decimal value at the specified location, or 0 if the value cannot be converted.
1011:  */
1012: DUCKDB_API duckdb_decimal duckdb_value_decimal(duckdb_result *result, idx_t col, idx_t row);
1013: 
1014: /*!
1015: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1016: 
1017:  * returns: The uint8_t value at the specified location, or 0 if the value cannot be converted.
1018:  */
1019: DUCKDB_API uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row);
1020: 
1021: /*!
1022: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1023: 
1024:  * returns: The uint16_t value at the specified location, or 0 if the value cannot be converted.
1025:  */
1026: DUCKDB_API uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row);
1027: 
1028: /*!
1029: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1030: 
1031:  * returns: The uint32_t value at the specified location, or 0 if the value cannot be converted.
1032:  */
1033: DUCKDB_API uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row);
1034: 
1035: /*!
1036: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1037: 
1038:  * returns: The uint64_t value at the specified location, or 0 if the value cannot be converted.
1039:  */
1040: DUCKDB_API uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row);
1041: 
1042: /*!
1043: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1044: 
1045:  * returns: The float value at the specified location, or 0 if the value cannot be converted.
1046:  */
1047: DUCKDB_API float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row);
1048: 
1049: /*!
1050: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1051: 
1052:  * returns: The double value at the specified location, or 0 if the value cannot be converted.
1053:  */
1054: DUCKDB_API double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row);
1055: 
1056: /*!
1057: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1058: 
1059:  * returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted.
1060:  */
1061: DUCKDB_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);
1062: 
1063: /*!
1064: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1065: 
1066:  * returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted.
1067:  */
1068: DUCKDB_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);
1069: 
1070: /*!
1071: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1072: 
1073:  * returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.
1074:  */
1075: DUCKDB_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);
1076: 
1077: /*!
1078: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1079: 
1080:  * returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted.
1081:  */
1082: DUCKDB_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);
1083: 
1084: /*!
1085: * DEPRECATED: use duckdb_value_string instead. This function does not work correctly if the string contains null bytes.
1086: * returns: The text value at the specified location as a null-terminated string, or nullptr if the value cannot be
1087: converted. The result must be freed with `duckdb_free`.
1088: */
1089: DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);
1090: 
1091: /*!
1092: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1093: 
1094:  * returns: The string value at the specified location. Attempts to cast the result value to string.
1095:  * No support for nested types, and for other complex types.
1096:  * The resulting field "string.data" must be freed with `duckdb_free.`
1097:  */
1098: DUCKDB_API duckdb_string duckdb_value_string(duckdb_result *result, idx_t col, idx_t row);
1099: 
1100: /*!
1101: * DEPRECATED: use duckdb_value_string_internal instead. This function does not work correctly if the string contains
1102: null bytes.
1103: * returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
1104: If the column is NOT a VARCHAR column this function will return NULL.
1105: 
1106: The result must NOT be freed.
1107: */
1108: DUCKDB_API char *duckdb_value_varchar_internal(duckdb_result *result, idx_t col, idx_t row);
1109: 
1110: /*!
1111: * DEPRECATED: use duckdb_value_string_internal instead. This function does not work correctly if the string contains
1112: null bytes.
1113: * returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
1114: If the column is NOT a VARCHAR column this function will return NULL.
1115: 
1116: The result must NOT be freed.
1117: */
1118: DUCKDB_API duckdb_string duckdb_value_string_internal(duckdb_result *result, idx_t col, idx_t row);
1119: 
1120: /*!
1121: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1122: 
1123: * returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the
1124: value cannot be converted. The resulting field "blob.data" must be freed with `duckdb_free.`
1125: */
1126: DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);
1127: 
1128: /*!
1129: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1130: 
1131:  * returns: Returns true if the value at the specified index is NULL, and false otherwise.
1132:  */
1133: DUCKDB_API bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row);
1134: #endif
1135: 
1136: //===--------------------------------------------------------------------===//
1137: // Helpers
1138: //===--------------------------------------------------------------------===//
1139: 
1140: /*!
1141: Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner
1142: should be freed using `duckdb_free`.
1143: 
1144: * size: The number of bytes to allocate.
1145: * returns: A pointer to the allocated memory region.
1146: */
1147: DUCKDB_API void *duckdb_malloc(size_t size);
1148: 
1149: /*!
1150: Free a value returned from `duckdb_malloc`, `duckdb_value_varchar`, `duckdb_value_blob`, or
1151: `duckdb_value_string`.
1152: 
1153: * ptr: The memory region to de-allocate.
1154: */
1155: DUCKDB_API void duckdb_free(void *ptr);
1156: 
1157: /*!
1158: The internal vector size used by DuckDB.
1159: This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.
1160: 
1161: * returns: The vector size.
1162: */
1163: DUCKDB_API idx_t duckdb_vector_size();
1164: 
1165: /*!
1166: Whether or not the duckdb_string_t value is inlined.
1167: This means that the data of the string does not have a separate allocation.
1168: 
1169: */
1170: DUCKDB_API bool duckdb_string_is_inlined(duckdb_string_t string);
1171: 
1172: //===--------------------------------------------------------------------===//
1173: // Date/Time/Timestamp Helpers
1174: //===--------------------------------------------------------------------===//
1175: 
1176: /*!
1177: Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).
1178: 
1179: * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
1180: * returns: The `duckdb_date_struct` with the decomposed elements.
1181: */
1182: DUCKDB_API duckdb_date_struct duckdb_from_date(duckdb_date date);
1183: 
1184: /*!
1185: Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).
1186: 
1187: * date: The year, month and date stored in a `duckdb_date_struct`.
1188: * returns: The `duckdb_date` element.
1189: */
1190: DUCKDB_API duckdb_date duckdb_to_date(duckdb_date_struct date);
1191: 
1192: /*!
1193: Test a `duckdb_date` to see if it is a finite value.
1194: 
1195: * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
1196: * returns: True if the date is finite, false if it is infinity.
1197: */
1198: DUCKDB_API bool duckdb_is_finite_date(duckdb_date date);
1199: 
1200: /*!
1201: Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).
1202: 
1203: * time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.
1204: * returns: The `duckdb_time_struct` with the decomposed elements.
1205: */
1206: DUCKDB_API duckdb_time_struct duckdb_from_time(duckdb_time time);
1207: 
1208: /*!
1209: Create a `duckdb_time_tz` object from micros and a timezone offset.
1210: 
1211: * micros: The microsecond component of the time.
1212: * offset: The timezone offset component of the time.
1213: * returns: The `duckdb_time_tz` element.
1214: */
1215: DUCKDB_API duckdb_time_tz duckdb_create_time_tz(int64_t micros, int32_t offset);
1216: 
1217: /*!
1218: Decompose a TIME_TZ objects into micros and a timezone offset.
1219: 
1220: Use `duckdb_from_time` to further decompose the micros into hour, minute, second and microsecond.
1221: 
1222: * micros: The time object, as obtained from a `DUCKDB_TYPE_TIME_TZ` column.
1223: * out_micros: The microsecond component of the time.
1224: * out_offset: The timezone offset component of the time.
1225: */
1226: DUCKDB_API duckdb_time_tz_struct duckdb_from_time_tz(duckdb_time_tz micros);
1227: 
1228: /*!
1229: Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).
1230: 
1231: * time: The hour, minute, second and microsecond in a `duckdb_time_struct`.
1232: * returns: The `duckdb_time` element.
1233: */
1234: DUCKDB_API duckdb_time duckdb_to_time(duckdb_time_struct time);
1235: 
1236: /*!
1237: Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.
1238: 
1239: * ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
1240: * returns: The `duckdb_timestamp_struct` with the decomposed elements.
1241: */
1242: DUCKDB_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts);
1243: 
1244: /*!
1245: Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.
1246: 
1247: * ts: The de-composed elements in a `duckdb_timestamp_struct`.
1248: * returns: The `duckdb_timestamp` element.
1249: */
1250: DUCKDB_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts);
1251: 
1252: /*!
1253: Test a `duckdb_timestamp` to see if it is a finite value.
1254: 
1255: * ts: The timestamp object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
1256: * returns: True if the timestamp is finite, false if it is infinity.
1257: */
1258: DUCKDB_API bool duckdb_is_finite_timestamp(duckdb_timestamp ts);
1259: 
1260: //===--------------------------------------------------------------------===//
1261: // Hugeint Helpers
1262: //===--------------------------------------------------------------------===//
1263: 
1264: /*!
1265: Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.
1266: 
1267: * val: The hugeint value.
1268: * returns: The converted `double` element.
1269: */
1270: DUCKDB_API double duckdb_hugeint_to_double(duckdb_hugeint val);
1271: 
1272: /*!
1273: Converts a double value to a duckdb_hugeint object.
1274: 
1275: If the conversion fails because the double value is too big the result will be 0.
1276: 
1277: * val: The double value.
1278: * returns: The converted `duckdb_hugeint` element.
1279: */
1280: DUCKDB_API duckdb_hugeint duckdb_double_to_hugeint(double val);
1281: 
1282: //===--------------------------------------------------------------------===//
1283: // Unsigned Hugeint Helpers
1284: //===--------------------------------------------------------------------===//
1285: 
1286: /*!
1287: Converts a duckdb_uhugeint object (as obtained from a `DUCKDB_TYPE_UHUGEINT` column) into a double.
1288: 
1289: * val: The uhugeint value.
1290: * returns: The converted `double` element.
1291: */
1292: DUCKDB_API double duckdb_uhugeint_to_double(duckdb_uhugeint val);
1293: 
1294: /*!
1295: Converts a double value to a duckdb_uhugeint object.
1296: 
1297: If the conversion fails because the double value is too big the result will be 0.
1298: 
1299: * val: The double value.
1300: * returns: The converted `duckdb_uhugeint` element.
1301: */
1302: DUCKDB_API duckdb_uhugeint duckdb_double_to_uhugeint(double val);
1303: 
1304: //===--------------------------------------------------------------------===//
1305: // Decimal Helpers
1306: //===--------------------------------------------------------------------===//
1307: 
1308: /*!
1309: Converts a double value to a duckdb_decimal object.
1310: 
1311: If the conversion fails because the double value is too big, or the width/scale are invalid the result will be 0.
1312: 
1313: * val: The double value.
1314: * returns: The converted `duckdb_decimal` element.
1315: */
1316: DUCKDB_API duckdb_decimal duckdb_double_to_decimal(double val, uint8_t width, uint8_t scale);
1317: 
1318: /*!
1319: Converts a duckdb_decimal object (as obtained from a `DUCKDB_TYPE_DECIMAL` column) into a double.
1320: 
1321: * val: The decimal value.
1322: * returns: The converted `double` element.
1323: */
1324: DUCKDB_API double duckdb_decimal_to_double(duckdb_decimal val);
1325: 
1326: //===--------------------------------------------------------------------===//
1327: // Prepared Statements
1328: //===--------------------------------------------------------------------===//
1329: 
1330: // A prepared statement is a parameterized query that allows you to bind parameters to it.
1331: // * This is useful to easily supply parameters to functions and avoid SQL injection attacks.
1332: // * This is useful to speed up queries that you will execute several times with different parameters.
1333: // Because the query will only be parsed, bound, optimized and planned once during the prepare stage,
1334: // rather than once per execution.
1335: // For example:
1336: //   SELECT * FROM tbl WHERE id=?
1337: // Or a query with multiple parameters:
1338: //   SELECT * FROM tbl WHERE id=$1 OR name=$2
1339: 
1340: /*!
1341: Create a prepared statement object from a query.
1342: 
1343: Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using
1344: `duckdb_destroy_prepare`, even if the prepare fails.
1345: 
1346: If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
1347: 
1348: * connection: The connection object
1349: * query: The SQL query to prepare
1350: * out_prepared_statement: The resulting prepared statement object
1351: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1352: */
1353: DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
1354:                                        duckdb_prepared_statement *out_prepared_statement);
1355: 
1356: /*!
1357: Closes the prepared statement and de-allocates all memory allocated for the statement.
1358: 
1359: * prepared_statement: The prepared statement to destroy.
1360: */
1361: DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);
1362: 
1363: /*!
1364: Returns the error message associated with the given prepared statement.
1365: If the prepared statement has no error message, this returns `nullptr` instead.
1366: 
1367: The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.
1368: 
1369: * prepared_statement: The prepared statement to obtain the error from.
1370: * returns: The error message, or `nullptr` if there is none.
1371: */
1372: DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);
1373: 
1374: /*!
1375: Returns the number of parameters that can be provided to the given prepared statement.
1376: 
1377: Returns 0 if the query was not successfully prepared.
1378: 
1379: * prepared_statement: The prepared statement to obtain the number of parameters for.
1380: */
1381: DUCKDB_API idx_t duckdb_nparams(duckdb_prepared_statement prepared_statement);
1382: 
1383: /*!
1384: Returns the name used to identify the parameter
1385: The returned string should be freed using `duckdb_free`.
1386: 
1387: Returns NULL if the index is out of range for the provided prepared statement.
1388: 
1389: * prepared_statement: The prepared statement for which to get the parameter name from.
1390: */
1391: DUCKDB_API const char *duckdb_parameter_name(duckdb_prepared_statement prepared_statement, idx_t index);
1392: 
1393: /*!
1394: Returns the parameter type for the parameter at the given index.
1395: 
1396: Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.
1397: 
1398: * prepared_statement: The prepared statement.
1399: * param_idx: The parameter index.
1400: * returns: The parameter type
1401: */
1402: DUCKDB_API duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_t param_idx);
1403: 
1404: /*!
1405: Clear the params bind to the prepared statement.
1406: */
1407: DUCKDB_API duckdb_state duckdb_clear_bindings(duckdb_prepared_statement prepared_statement);
1408: 
1409: /*!
1410: Returns the statement type of the statement to be executed
1411: 
1412:  * statement: The prepared statement.
1413:  * returns: duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID
1414:  */
1415: DUCKDB_API duckdb_statement_type duckdb_prepared_statement_type(duckdb_prepared_statement statement);
1416: 
1417: //===--------------------------------------------------------------------===//
1418: // Bind Values to Prepared Statements
1419: //===--------------------------------------------------------------------===//
1420: 
1421: /*!
1422: Binds a value to the prepared statement at the specified index.
1423: */
1424: DUCKDB_API duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1425:                                           duckdb_value val);
1426: 
1427: /*!
1428: Retrieve the index of the parameter for the prepared statement, identified by name
1429: */
1430: DUCKDB_API duckdb_state duckdb_bind_parameter_index(duckdb_prepared_statement prepared_statement, idx_t *param_idx_out,
1431:                                                     const char *name);
1432: 
1433: /*!
1434: Binds a bool value to the prepared statement at the specified index.
1435: */
1436: DUCKDB_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);
1437: 
1438: /*!
1439: Binds an int8_t value to the prepared statement at the specified index.
1440: */
1441: DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
1442: 
1443: /*!
1444: Binds an int16_t value to the prepared statement at the specified index.
1445: */
1446: DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
1447: 
1448: /*!
1449: Binds an int32_t value to the prepared statement at the specified index.
1450: */
1451: DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);
1452: 
1453: /*!
1454: Binds an int64_t value to the prepared statement at the specified index.
1455: */
1456: DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);
1457: 
1458: /*!
1459: Binds a duckdb_hugeint value to the prepared statement at the specified index.
1460: */
1461: DUCKDB_API duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1462:                                             duckdb_hugeint val);
1463: /*!
1464: Binds an duckdb_uhugeint value to the prepared statement at the specified index.
1465: */
1466: DUCKDB_API duckdb_state duckdb_bind_uhugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1467:                                              duckdb_uhugeint val);
1468: /*!
1469: Binds a duckdb_decimal value to the prepared statement at the specified index.
1470: */
1471: DUCKDB_API duckdb_state duckdb_bind_decimal(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1472:                                             duckdb_decimal val);
1473: 
1474: /*!
1475: Binds an uint8_t value to the prepared statement at the specified index.
1476: */
1477: DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);
1478: 
1479: /*!
1480: Binds an uint16_t value to the prepared statement at the specified index.
1481: */
1482: DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val);
1483: 
1484: /*!
1485: Binds an uint32_t value to the prepared statement at the specified index.
1486: */
1487: DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);
1488: 
1489: /*!
1490: Binds an uint64_t value to the prepared statement at the specified index.
1491: */
1492: DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);
1493: 
1494: /*!
1495: Binds a float value to the prepared statement at the specified index.
1496: */
1497: DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);
1498: 
1499: /*!
1500: Binds a double value to the prepared statement at the specified index.
1501: */
1502: DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);
1503: 
1504: /*!
1505: Binds a duckdb_date value to the prepared statement at the specified index.
1506: */
1507: DUCKDB_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1508:                                          duckdb_date val);
1509: 
1510: /*!
1511: Binds a duckdb_time value to the prepared statement at the specified index.
1512: */
1513: DUCKDB_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1514:                                          duckdb_time val);
1515: 
1516: /*!
1517: Binds a duckdb_timestamp value to the prepared statement at the specified index.
1518: */
1519: DUCKDB_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1520:                                               duckdb_timestamp val);
1521: 
1522: /*!
1523: Binds a duckdb_timestamp value to the prepared statement at the specified index.
1524: */
1525: DUCKDB_API duckdb_state duckdb_bind_timestamp_tz(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1526:                                                  duckdb_timestamp val);
1527: 
1528: /*!
1529: Binds a duckdb_interval value to the prepared statement at the specified index.
1530: */
1531: DUCKDB_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1532:                                              duckdb_interval val);
1533: 
1534: /*!
1535: Binds a null-terminated varchar value to the prepared statement at the specified index.
1536: */
1537: DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1538:                                             const char *val);
1539: 
1540: /*!
1541: Binds a varchar value to the prepared statement at the specified index.
1542: */
1543: DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1544:                                                    const char *val, idx_t length);
1545: 
1546: /*!
1547: Binds a blob value to the prepared statement at the specified index.
1548: */
1549: DUCKDB_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1550:                                          const void *data, idx_t length);
1551: 
1552: /*!
1553: Binds a NULL value to the prepared statement at the specified index.
1554: */
1555: DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);
1556: 
1557: //===--------------------------------------------------------------------===//
1558: // Execute Prepared Statements
1559: //===--------------------------------------------------------------------===//
1560: 
1561: /*!
1562: Executes the prepared statement with the given bound parameters, and returns a materialized query result.
1563: 
1564: This method can be called multiple times for each prepared statement, and the parameters can be modified
1565: between calls to this function.
1566: 
1567: Note that the result must be freed with `duckdb_destroy_result`.
1568: 
1569: * prepared_statement: The prepared statement to execute.
1570: * out_result: The query result.
1571: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1572: */
1573: DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,
1574:                                                 duckdb_result *out_result);
1575: 
1576: #ifndef DUCKDB_API_NO_DEPRECATED
1577: /*!
1578: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1579: 
1580: Executes the prepared statement with the given bound parameters, and returns an optionally-streaming query result.
1581: To determine if the resulting query was in fact streamed, use `duckdb_result_is_streaming`
1582: 
1583: This method can be called multiple times for each prepared statement, and the parameters can be modified
1584: between calls to this function.
1585: 
1586: Note that the result must be freed with `duckdb_destroy_result`.
1587: 
1588: * prepared_statement: The prepared statement to execute.
1589: * out_result: The query result.
1590: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1591: */
1592: DUCKDB_API duckdb_state duckdb_execute_prepared_streaming(duckdb_prepared_statement prepared_statement,
1593:                                                           duckdb_result *out_result);
1594: #endif
1595: 
1596: //===--------------------------------------------------------------------===//
1597: // Extract Statements
1598: //===--------------------------------------------------------------------===//
1599: 
1600: // A query string can be extracted into multiple SQL statements. Each statement can be prepared and executed separately.
1601: 
1602: /*!
1603: Extract all statements from a query.
1604: Note that after calling `duckdb_extract_statements`, the extracted statements should always be destroyed using
1605: `duckdb_destroy_extracted`, even if no statements were extracted.
1606: 
1607: If the extract fails, `duckdb_extract_statements_error` can be called to obtain the reason why the extract failed.
1608: 
1609: * connection: The connection object
1610: * query: The SQL query to extract
1611: * out_extracted_statements: The resulting extracted statements object
1612: * returns: The number of extracted statements or 0 on failure.
1613: */
1614: DUCKDB_API idx_t duckdb_extract_statements(duckdb_connection connection, const char *query,
1615:                                            duckdb_extracted_statements *out_extracted_statements);
1616: 
1617: /*!
1618: Prepare an extracted statement.
1619: Note that after calling `duckdb_prepare_extracted_statement`, the prepared statement should always be destroyed using
1620: `duckdb_destroy_prepare`, even if the prepare fails.
1621: 
1622: If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
1623: 
1624: * connection: The connection object
1625: * extracted_statements: The extracted statements object
1626: * index: The index of the extracted statement to prepare
1627: * out_prepared_statement: The resulting prepared statement object
1628: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1629: */
1630: DUCKDB_API duckdb_state duckdb_prepare_extracted_statement(duckdb_connection connection,
1631:                                                            duckdb_extracted_statements extracted_statements,
1632:                                                            idx_t index,
1633:                                                            duckdb_prepared_statement *out_prepared_statement);
1634: /*!
1635: Returns the error message contained within the extracted statements.
1636: The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_extracted` is called.
1637: 
1638: * result: The extracted statements to fetch the error from.
1639: * returns: The error of the extracted statements.
1640: */
1641: DUCKDB_API const char *duckdb_extract_statements_error(duckdb_extracted_statements extracted_statements);
1642: 
1643: /*!
1644: De-allocates all memory allocated for the extracted statements.
1645: * extracted_statements: The extracted statements to destroy.
1646: */
1647: DUCKDB_API void duckdb_destroy_extracted(duckdb_extracted_statements *extracted_statements);
1648: 
1649: //===--------------------------------------------------------------------===//
1650: // Pending Result Interface
1651: //===--------------------------------------------------------------------===//
1652: 
1653: /*!
1654: Executes the prepared statement with the given bound parameters, and returns a pending result.
1655: The pending result represents an intermediate structure for a query that is not yet fully executed.
1656: The pending result can be used to incrementally execute a query, returning control to the client between tasks.
1657: 
1658: Note that after calling `duckdb_pending_prepared`, the pending result should always be destroyed using
1659: `duckdb_destroy_pending`, even if this function returns DuckDBError.
1660: 
1661: * prepared_statement: The prepared statement to execute.
1662: * out_result: The pending query result.
1663: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1664: */
1665: DUCKDB_API duckdb_state duckdb_pending_prepared(duckdb_prepared_statement prepared_statement,
1666:                                                 duckdb_pending_result *out_result);
1667: #ifndef DUCKDB_API_NO_DEPRECATED
1668: /*!
1669: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
1670: 
1671: Executes the prepared statement with the given bound parameters, and returns a pending result.
1672: This pending result will create a streaming duckdb_result when executed.
1673: The pending result represents an intermediate structure for a query that is not yet fully executed.
1674: 
1675: Note that after calling `duckdb_pending_prepared_streaming`, the pending result should always be destroyed using
1676: `duckdb_destroy_pending`, even if this function returns DuckDBError.
1677: 
1678: * prepared_statement: The prepared statement to execute.
1679: * out_result: The pending query result.
1680: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1681: */
1682: DUCKDB_API duckdb_state duckdb_pending_prepared_streaming(duckdb_prepared_statement prepared_statement,
1683:                                                           duckdb_pending_result *out_result);
1684: #endif
1685: 
1686: /*!
1687: Closes the pending result and de-allocates all memory allocated for the result.
1688: 
1689: * pending_result: The pending result to destroy.
1690: */
1691: DUCKDB_API void duckdb_destroy_pending(duckdb_pending_result *pending_result);
1692: 
1693: /*!
1694: Returns the error message contained within the pending result.
1695: 
1696: The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_pending` is called.
1697: 
1698: * result: The pending result to fetch the error from.
1699: * returns: The error of the pending result.
1700: */
1701: DUCKDB_API const char *duckdb_pending_error(duckdb_pending_result pending_result);
1702: 
1703: /*!
1704: Executes a single task within the query, returning whether or not the query is ready.
1705: 
1706: If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.
1707: If this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_task function should be called again.
1708: If this returns DUCKDB_PENDING_ERROR, an error occurred during execution.
1709: 
1710: The error message can be obtained by calling duckdb_pending_error on the pending_result.
1711: 
1712: * pending_result: The pending result to execute a task within.
1713: * returns: The state of the pending result after the execution.
1714: */
1715: DUCKDB_API duckdb_pending_state duckdb_pending_execute_task(duckdb_pending_result pending_result);
1716: 
1717: /*!
1718: If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.
1719: If this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_check_state function should be called again.
1720: If this returns DUCKDB_PENDING_ERROR, an error occurred during execution.
1721: 
1722: The error message can be obtained by calling duckdb_pending_error on the pending_result.
1723: 
1724: * pending_result: The pending result.
1725: * returns: The state of the pending result.
1726: */
1727: DUCKDB_API duckdb_pending_state duckdb_pending_execute_check_state(duckdb_pending_result pending_result);
1728: 
1729: /*!
1730: Fully execute a pending query result, returning the final query result.
1731: 
1732: If duckdb_pending_execute_task has been called until DUCKDB_PENDING_RESULT_READY was returned, this will return fast.
1733: Otherwise, all remaining tasks must be executed first.
1734: 
1735: Note that the result must be freed with `duckdb_destroy_result`.
1736: 
1737: * pending_result: The pending result to execute.
1738: * out_result: The result object.
1739: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1740: */
1741: DUCKDB_API duckdb_state duckdb_execute_pending(duckdb_pending_result pending_result, duckdb_result *out_result);
1742: 
1743: /*!
1744: Returns whether a duckdb_pending_state is finished executing. For example if `pending_state` is
1745: DUCKDB_PENDING_RESULT_READY, this function will return true.
1746: 
1747: * pending_state: The pending state on which to decide whether to finish execution.
1748: * returns: Boolean indicating pending execution should be considered finished.
1749: */
1750: DUCKDB_API bool duckdb_pending_execution_is_finished(duckdb_pending_state pending_state);
1751: 
1752: //===--------------------------------------------------------------------===//
1753: // Value Interface
1754: //===--------------------------------------------------------------------===//
1755: 
1756: /*!
1757: Destroys the value and de-allocates all memory allocated for that type.
1758: 
1759: * value: The value to destroy.
1760: */
1761: DUCKDB_API void duckdb_destroy_value(duckdb_value *value);
1762: 
1763: /*!
1764: Creates a value from a null-terminated string
1765: 
1766: * value: The null-terminated string
1767: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
1768: */
1769: DUCKDB_API duckdb_value duckdb_create_varchar(const char *text);
1770: 
1771: /*!
1772: Creates a value from a string
1773: 
1774: * value: The text
1775: * length: The length of the text
1776: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
1777: */
1778: DUCKDB_API duckdb_value duckdb_create_varchar_length(const char *text, idx_t length);
1779: 
1780: /*!
1781: Creates a value from an int64
1782: 
1783: * value: The bigint value
1784: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
1785: */
1786: DUCKDB_API duckdb_value duckdb_create_int64(int64_t val);
1787: 
1788: /*!
1789: Creates a struct value from a type and an array of values. Must be destroyed with `duckdb_destroy_value`.
1790: 
1791: * @param type The type of the struct.
1792: * @param values The values for the struct fields.
1793: * @return The struct value, or nullptr, if any child type is `DUCKDB_TYPE_ANY` or `DUCKDB_TYPE_INVALID`.
1794: */
1795: DUCKDB_API duckdb_value duckdb_create_struct_value(duckdb_logical_type type, duckdb_value *values);
1796: 
1797: /*!
1798: Creates a list value from a child (element) type and an array of values of length `value_count`.
1799: Must be destroyed with `duckdb_destroy_value`.
1800: 
1801: * @param type The child type of the list.
1802: * @param values The values for the list.
1803: * @param value_count The number of values in the list.
1804: * @return The list value, or nullptr, if the child type is `DUCKDB_TYPE_ANY` or `DUCKDB_TYPE_INVALID`.
1805: */
1806: DUCKDB_API duckdb_value duckdb_create_list_value(duckdb_logical_type type, duckdb_value *values, idx_t value_count);
1807: 
1808: /*!
1809: Creates an array value from a child (element) type and an array of values of length `value_count`.
1810: Must be destroyed with `duckdb_destroy_value`.
1811: 
1812: * @param type The type of the array.
1813: * @param values The values for the array.
1814: * @param value_count The number of values in the array.
1815: * @return The array value, or nullptr, if the child type is `DUCKDB_TYPE_ANY` or `DUCKDB_TYPE_INVALID`.
1816: */
1817: DUCKDB_API duckdb_value duckdb_create_array_value(duckdb_logical_type type, duckdb_value *values, idx_t value_count);
1818: 
1819: /*!
1820: Obtains a string representation of the given value.
1821: The result must be destroyed with `duckdb_free`.
1822: 
1823: * value: The value
1824: * returns: The string value. This must be destroyed with `duckdb_free`.
1825: */
1826: DUCKDB_API char *duckdb_get_varchar(duckdb_value value);
1827: 
1828: /*!
1829: Obtains an int64 of the given value.
1830: 
1831: * value: The value
1832: * returns: The int64 value, or 0 if no conversion is possible
1833: */
1834: DUCKDB_API int64_t duckdb_get_int64(duckdb_value value);
1835: 
1836: //===--------------------------------------------------------------------===//
1837: // Logical Type Interface
1838: //===--------------------------------------------------------------------===//
1839: 
1840: /*!
1841: Creates a `duckdb_logical_type` from a primitive type.
1842: The resulting logical type must be destroyed with `duckdb_destroy_logical_type`.
1843: 
1844: Returns an invalid logical type, if type is: `DUCKDB_TYPE_INVALID`, `DUCKDB_TYPE_DECIMAL`, `DUCKDB_TYPE_ENUM`,
1845: `DUCKDB_TYPE_LIST`, `DUCKDB_TYPE_STRUCT`, `DUCKDB_TYPE_MAP`, `DUCKDB_TYPE_ARRAY`, or `DUCKDB_TYPE_UNION`.
1846: 
1847: * @param type The primitive type to create.
1848: * @return The logical type.
1849: */
1850: DUCKDB_API duckdb_logical_type duckdb_create_logical_type(duckdb_type type);
1851: 
1852: /*!
1853: Returns the alias of a duckdb_logical_type, if set, else `nullptr`.
1854: The result must be destroyed with `duckdb_free`.
1855: 
1856: * @param type The logical type.
1857: * @return The alias or `nullptr`.
1858:  */
1859: DUCKDB_API char *duckdb_logical_type_get_alias(duckdb_logical_type type);
1860: 
1861: /*!
1862: Creates a LIST type from its child type.
1863: The return type must be destroyed with `duckdb_destroy_logical_type`.
1864: 
1865: * @param type The child type of the list.
1866: * @return The logical type.
1867: */
1868: DUCKDB_API duckdb_logical_type duckdb_create_list_type(duckdb_logical_type type);
1869: 
1870: /*!
1871: Creates an ARRAY type from its child type.
1872: The return type must be destroyed with `duckdb_destroy_logical_type`.
1873: 
1874: * @param type The child type of the array.
1875: * @param array_size The number of elements in the array.
1876: * @return The logical type.
1877: */
1878: DUCKDB_API duckdb_logical_type duckdb_create_array_type(duckdb_logical_type type, idx_t array_size);
1879: 
1880: /*!
1881: Creates a MAP type from its key type and value type.
1882: The return type must be destroyed with `duckdb_destroy_logical_type`.
1883: 
1884: * @param key_type The map's key type.
1885: * @param value_type The map's value type.
1886: * @return The logical type.
1887: */
1888: DUCKDB_API duckdb_logical_type duckdb_create_map_type(duckdb_logical_type key_type, duckdb_logical_type value_type);
1889: 
1890: /*!
1891: Creates a UNION type from the passed arrays.
1892: The return type must be destroyed with `duckdb_destroy_logical_type`.
1893: 
1894: * @param member_types The array of union member types.
1895: * @param member_names The union member names.
1896: * @param member_count The number of union members.
1897: * @param return The logical type.
1898: */
1899: DUCKDB_API duckdb_logical_type duckdb_create_union_type(duckdb_logical_type *member_types, const char **member_names,
1900:                                                         idx_t member_count);
1901: 
1902: /*!
1903: Creates a STRUCT type based on the member types and names.
1904: The resulting type must be destroyed with `duckdb_destroy_logical_type`.
1905: 
1906: * @param member_types The array of types of the struct members.
1907: * @param member_names The array of names of the struct members.
1908: * @param member_count The number of members of the struct.
1909: * @return The logical type.
1910: */
1911: DUCKDB_API duckdb_logical_type duckdb_create_struct_type(duckdb_logical_type *member_types, const char **member_names,
1912:                                                          idx_t member_count);
1913: 
1914: /*!
1915: Creates an ENUM type from the passed member name array.
1916: The resulting type should be destroyed with `duckdb_destroy_logical_type`.
1917: 
1918: * enum_name: The name of the enum.
1919: * member_names: The array of names that the enum should consist of.
1920: * member_count: The number of elements that were specified in the array.
1921: * returns: The logical type.
1922: */
1923: DUCKDB_API duckdb_logical_type duckdb_create_enum_type(const char **member_names, idx_t member_count);
1924: 
1925: /*!
1926: Creates a DECIMAL type with the specified width and scale.
1927: The resulting type should be destroyed with `duckdb_destroy_logical_type`.
1928: 
1929: * width: The width of the decimal type
1930: * scale: The scale of the decimal type
1931: * returns: The logical type.
1932: */
1933: DUCKDB_API duckdb_logical_type duckdb_create_decimal_type(uint8_t width, uint8_t scale);
1934: 
1935: /*!
1936: Retrieves the enum `duckdb_type` of a `duckdb_logical_type`.
1937: 
1938: * @param type The logical type.
1939: * @return The `duckdb_type` id.
1940: */
1941: DUCKDB_API duckdb_type duckdb_get_type_id(duckdb_logical_type type);
1942: 
1943: /*!
1944: Retrieves the width of a decimal type.
1945: 
1946: * type: The logical type object
1947: * returns: The width of the decimal type
1948: */
1949: DUCKDB_API uint8_t duckdb_decimal_width(duckdb_logical_type type);
1950: 
1951: /*!
1952: Retrieves the scale of a decimal type.
1953: 
1954: * type: The logical type object
1955: * returns: The scale of the decimal type
1956: */
1957: DUCKDB_API uint8_t duckdb_decimal_scale(duckdb_logical_type type);
1958: 
1959: /*!
1960: Retrieves the internal storage type of a decimal type.
1961: 
1962: * type: The logical type object
1963: * returns: The internal type of the decimal type
1964: */
1965: DUCKDB_API duckdb_type duckdb_decimal_internal_type(duckdb_logical_type type);
1966: 
1967: /*!
1968: Retrieves the internal storage type of an enum type.
1969: 
1970: * type: The logical type object
1971: * returns: The internal type of the enum type
1972: */
1973: DUCKDB_API duckdb_type duckdb_enum_internal_type(duckdb_logical_type type);
1974: 
1975: /*!
1976: Retrieves the dictionary size of the enum type.
1977: 
1978: * type: The logical type object
1979: * returns: The dictionary size of the enum type
1980: */
1981: DUCKDB_API uint32_t duckdb_enum_dictionary_size(duckdb_logical_type type);
1982: 
1983: /*!
1984: Retrieves the dictionary value at the specified position from the enum.
1985: 
1986: The result must be freed with `duckdb_free`.
1987: 
1988: * type: The logical type object
1989: * index: The index in the dictionary
1990: * returns: The string value of the enum type. Must be freed with `duckdb_free`.
1991: */
1992: DUCKDB_API char *duckdb_enum_dictionary_value(duckdb_logical_type type, idx_t index);
1993: 
1994: /*!
1995: Retrieves the child type of the given LIST type. Also accepts MAP types.
1996: The result must be freed with `duckdb_destroy_logical_type`.
1997: 
1998: * @param type The logical type, either LIST or MAP.
1999: * @return The child type of the LIST or MAP type.
2000: */
2001: DUCKDB_API duckdb_logical_type duckdb_list_type_child_type(duckdb_logical_type type);
2002: 
2003: /*!
2004: Retrieves the child type of the given ARRAY type.
2005: The result must be freed with `duckdb_destroy_logical_type`.
2006: 
2007: * @param type The logical type. Must be ARRAY.
2008: * @return The child type of the ARRAY type.
2009: */
2010: DUCKDB_API duckdb_logical_type duckdb_array_type_child_type(duckdb_logical_type type);
2011: 
2012: /*!
2013: Retrieves the array size of the given array type.
2014: 
2015: * type: The logical type object
2016: * returns: The fixed number of elements the values of this array type can store.
2017: */
2018: DUCKDB_API idx_t duckdb_array_type_array_size(duckdb_logical_type type);
2019: 
2020: /*!
2021: Retrieves the key type of the given map type.
2022: 
2023: The result must be freed with `duckdb_destroy_logical_type`.
2024: 
2025: * type: The logical type object
2026: * returns: The key type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.
2027: */
2028: DUCKDB_API duckdb_logical_type duckdb_map_type_key_type(duckdb_logical_type type);
2029: 
2030: /*!
2031: Retrieves the value type of the given map type.
2032: 
2033: The result must be freed with `duckdb_destroy_logical_type`.
2034: 
2035: * type: The logical type object
2036: * returns: The value type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.
2037: */
2038: DUCKDB_API duckdb_logical_type duckdb_map_type_value_type(duckdb_logical_type type);
2039: 
2040: /*!
2041: Returns the number of children of a struct type.
2042: 
2043: * type: The logical type object
2044: * returns: The number of children of a struct type.
2045: */
2046: DUCKDB_API idx_t duckdb_struct_type_child_count(duckdb_logical_type type);
2047: 
2048: /*!
2049: Retrieves the name of the struct child.
2050: 
2051: The result must be freed with `duckdb_free`.
2052: 
2053: * type: The logical type object
2054: * index: The child index
2055: * returns: The name of the struct type. Must be freed with `duckdb_free`.
2056: */
2057: DUCKDB_API char *duckdb_struct_type_child_name(duckdb_logical_type type, idx_t index);
2058: 
2059: /*!
2060: Retrieves the child type of the given struct type at the specified index.
2061: 
2062: The result must be freed with `duckdb_destroy_logical_type`.
2063: 
2064: * type: The logical type object
2065: * index: The child index
2066: * returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.
2067: */
2068: DUCKDB_API duckdb_logical_type duckdb_struct_type_child_type(duckdb_logical_type type, idx_t index);
2069: 
2070: /*!
2071: Returns the number of members that the union type has.
2072: 
2073: * type: The logical type (union) object
2074: * returns: The number of members of a union type.
2075: */
2076: DUCKDB_API idx_t duckdb_union_type_member_count(duckdb_logical_type type);
2077: 
2078: /*!
2079: Retrieves the name of the union member.
2080: 
2081: The result must be freed with `duckdb_free`.
2082: 
2083: * type: The logical type object
2084: * index: The child index
2085: * returns: The name of the union member. Must be freed with `duckdb_free`.
2086: */
2087: DUCKDB_API char *duckdb_union_type_member_name(duckdb_logical_type type, idx_t index);
2088: 
2089: /*!
2090: Retrieves the child type of the given union member at the specified index.
2091: 
2092: The result must be freed with `duckdb_destroy_logical_type`.
2093: 
2094: * type: The logical type object
2095: * index: The child index
2096: * returns: The child type of the union member. Must be destroyed with `duckdb_destroy_logical_type`.
2097: */
2098: DUCKDB_API duckdb_logical_type duckdb_union_type_member_type(duckdb_logical_type type, idx_t index);
2099: 
2100: /*!
2101: Destroys the logical type and de-allocates all memory allocated for that type.
2102: 
2103: * type: The logical type to destroy.
2104: */
2105: DUCKDB_API void duckdb_destroy_logical_type(duckdb_logical_type *type);
2106: 
2107: //===--------------------------------------------------------------------===//
2108: // Data Chunk Interface
2109: //===--------------------------------------------------------------------===//
2110: 
2111: /*!
2112: Creates an empty data chunk with the specified column types.
2113: The result must be destroyed with `duckdb_destroy_data_chunk`.
2114: 
2115: * @param types An array of column types. Column types can not contain ANY and INVALID types.
2116: * @param column_count The number of columns.
2117: * @return The data chunk.
2118: */
2119: DUCKDB_API duckdb_data_chunk duckdb_create_data_chunk(duckdb_logical_type *types, idx_t column_count);
2120: 
2121: /*!
2122: Destroys the data chunk and de-allocates all memory allocated for that chunk.
2123: 
2124: * chunk: The data chunk to destroy.
2125: */
2126: DUCKDB_API void duckdb_destroy_data_chunk(duckdb_data_chunk *chunk);
2127: 
2128: /*!
2129: Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.
2130: After calling this method, you must call `duckdb_vector_get_validity` and `duckdb_vector_get_data` to obtain current
2131: data and validity pointers
2132: 
2133: * chunk: The data chunk to reset.
2134: */
2135: DUCKDB_API void duckdb_data_chunk_reset(duckdb_data_chunk chunk);
2136: 
2137: /*!
2138: Retrieves the number of columns in a data chunk.
2139: 
2140: * chunk: The data chunk to get the data from
2141: * returns: The number of columns in the data chunk
2142: */
2143: DUCKDB_API idx_t duckdb_data_chunk_get_column_count(duckdb_data_chunk chunk);
2144: 
2145: /*!
2146: Retrieves the vector at the specified column index in the data chunk.
2147: 
2148: The pointer to the vector is valid for as long as the chunk is alive.
2149: It does NOT need to be destroyed.
2150: 
2151: * chunk: The data chunk to get the data from
2152: * returns: The vector
2153: */
2154: DUCKDB_API duckdb_vector duckdb_data_chunk_get_vector(duckdb_data_chunk chunk, idx_t col_idx);
2155: 
2156: /*!
2157: Retrieves the current number of tuples in a data chunk.
2158: 
2159: * chunk: The data chunk to get the data from
2160: * returns: The number of tuples in the data chunk
2161: */
2162: DUCKDB_API idx_t duckdb_data_chunk_get_size(duckdb_data_chunk chunk);
2163: 
2164: /*!
2165: Sets the current number of tuples in a data chunk.
2166: 
2167: * chunk: The data chunk to set the size in
2168: * size: The number of tuples in the data chunk
2169: */
2170: DUCKDB_API void duckdb_data_chunk_set_size(duckdb_data_chunk chunk, idx_t size);
2171: 
2172: //===--------------------------------------------------------------------===//
2173: // Vector Interface
2174: //===--------------------------------------------------------------------===//
2175: 
2176: /*!
2177: Retrieves the column type of the specified vector.
2178: 
2179: The result must be destroyed with `duckdb_destroy_logical_type`.
2180: 
2181: * vector: The vector get the data from
2182: * returns: The type of the vector
2183: */
2184: DUCKDB_API duckdb_logical_type duckdb_vector_get_column_type(duckdb_vector vector);
2185: 
2186: /*!
2187: Retrieves the data pointer of the vector.
2188: 
2189: The data pointer can be used to read or write values from the vector.
2190: How to read or write values depends on the type of the vector.
2191: 
2192: * vector: The vector to get the data from
2193: * returns: The data pointer
2194: */
2195: DUCKDB_API void *duckdb_vector_get_data(duckdb_vector vector);
2196: 
2197: /*!
2198: Retrieves the validity mask pointer of the specified vector.
2199: 
2200: If all values are valid, this function MIGHT return NULL!
2201: 
2202: The validity mask is a bitset that signifies null-ness within the data chunk.
2203: It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.
2204: The bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).
2205: 
2206: Validity of a specific value can be obtained like this:
2207: 
2208: idx_t entry_idx = row_idx / 64;
2209: idx_t idx_in_entry = row_idx % 64;
2210: bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);
2211: 
2212: Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.
2213: 
2214: * vector: The vector to get the data from
2215: * returns: The pointer to the validity mask, or NULL if no validity mask is present
2216: */
2217: DUCKDB_API uint64_t *duckdb_vector_get_validity(duckdb_vector vector);
2218: 
2219: /*!
2220: Ensures the validity mask is writable by allocating it.
2221: 
2222: After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.
2223: This allows null values to be written to the vector, regardless of whether a validity mask was present before.
2224: 
2225: * vector: The vector to alter
2226: */
2227: DUCKDB_API void duckdb_vector_ensure_validity_writable(duckdb_vector vector);
2228: 
2229: /*!
2230: Assigns a string element in the vector at the specified location.
2231: 
2232: * vector: The vector to alter
2233: * index: The row position in the vector to assign the string to
2234: * str: The null-terminated string
2235: */
2236: DUCKDB_API void duckdb_vector_assign_string_element(duckdb_vector vector, idx_t index, const char *str);
2237: 
2238: /*!
2239: Assigns a string element in the vector at the specified location. You may also use this function to assign BLOBs.
2240: 
2241: * vector: The vector to alter
2242: * index: The row position in the vector to assign the string to
2243: * str: The string
2244: * str_len: The length of the string (in bytes)
2245: */
2246: DUCKDB_API void duckdb_vector_assign_string_element_len(duckdb_vector vector, idx_t index, const char *str,
2247:                                                         idx_t str_len);
2248: 
2249: /*!
2250: Retrieves the child vector of a list vector.
2251: 
2252: The resulting vector is valid as long as the parent vector is valid.
2253: 
2254: * vector: The vector
2255: * returns: The child vector
2256: */
2257: DUCKDB_API duckdb_vector duckdb_list_vector_get_child(duckdb_vector vector);
2258: 
2259: /*!
2260: Returns the size of the child vector of the list.
2261: 
2262: * vector: The vector
2263: * returns: The size of the child list
2264: */
2265: DUCKDB_API idx_t duckdb_list_vector_get_size(duckdb_vector vector);
2266: 
2267: /*!
2268: Sets the total size of the underlying child-vector of a list vector.
2269: 
2270: * vector: The list vector.
2271: * size: The size of the child list.
2272: * returns: The duckdb state. Returns DuckDBError if the vector is nullptr.
2273: */
2274: DUCKDB_API duckdb_state duckdb_list_vector_set_size(duckdb_vector vector, idx_t size);
2275: 
2276: /*!
2277: Sets the total capacity of the underlying child-vector of a list.
2278: 
2279: After calling this method, you must call `duckdb_vector_get_validity` and `duckdb_vector_get_data` to obtain current
2280: data and validity pointers
2281: 
2282: * vector: The list vector.
2283: * required_capacity: the total capacity to reserve.
2284: * return: The duckdb state. Returns DuckDBError if the vector is nullptr.
2285: */
2286: DUCKDB_API duckdb_state duckdb_list_vector_reserve(duckdb_vector vector, idx_t required_capacity);
2287: 
2288: /*!
2289: Retrieves the child vector of a struct vector.
2290: 
2291: The resulting vector is valid as long as the parent vector is valid.
2292: 
2293: * vector: The vector
2294: * index: The child index
2295: * returns: The child vector
2296: */
2297: DUCKDB_API duckdb_vector duckdb_struct_vector_get_child(duckdb_vector vector, idx_t index);
2298: 
2299: /*!
2300: Retrieves the child vector of a array vector.
2301: 
2302: The resulting vector is valid as long as the parent vector is valid.
2303: The resulting vector has the size of the parent vector multiplied by the array size.
2304: 
2305: * vector: The vector
2306: * returns: The child vector
2307: */
2308: DUCKDB_API duckdb_vector duckdb_array_vector_get_child(duckdb_vector vector);
2309: 
2310: //===--------------------------------------------------------------------===//
2311: // Validity Mask Functions
2312: //===--------------------------------------------------------------------===//
2313: 
2314: /*!
2315: Returns whether or not a row is valid (i.e. not NULL) in the given validity mask.
2316: 
2317: * validity: The validity mask, as obtained through `duckdb_vector_get_validity`
2318: * row: The row index
2319: * returns: true if the row is valid, false otherwise
2320: */
2321: DUCKDB_API bool duckdb_validity_row_is_valid(uint64_t *validity, idx_t row);
2322: 
2323: /*!
2324: In a validity mask, sets a specific row to either valid or invalid.
2325: 
2326: Note that `duckdb_vector_ensure_validity_writable` should be called before calling `duckdb_vector_get_validity`,
2327: to ensure that there is a validity mask to write to.
2328: 
2329: * validity: The validity mask, as obtained through `duckdb_vector_get_validity`.
2330: * row: The row index
2331: * valid: Whether or not to set the row to valid, or invalid
2332: */
2333: DUCKDB_API void duckdb_validity_set_row_validity(uint64_t *validity, idx_t row, bool valid);
2334: 
2335: /*!
2336: In a validity mask, sets a specific row to invalid.
2337: 
2338: Equivalent to `duckdb_validity_set_row_validity` with valid set to false.
2339: 
2340: * validity: The validity mask
2341: * row: The row index
2342: */
2343: DUCKDB_API void duckdb_validity_set_row_invalid(uint64_t *validity, idx_t row);
2344: 
2345: /*!
2346: In a validity mask, sets a specific row to valid.
2347: 
2348: Equivalent to `duckdb_validity_set_row_validity` with valid set to true.
2349: 
2350: * validity: The validity mask
2351: * row: The row index
2352: */
2353: DUCKDB_API void duckdb_validity_set_row_valid(uint64_t *validity, idx_t row);
2354: 
2355: #ifndef DUCKDB_NO_EXTENSION_FUNCTIONS
2356: //===--------------------------------------------------------------------===//
2357: // Scalar Functions
2358: //===--------------------------------------------------------------------===//
2359: /*!
2360: Creates a new empty scalar function.
2361: 
2362: The return value should be destroyed with `duckdb_destroy_scalar_function`.
2363: 
2364: * returns: The scalar function object.
2365: */
2366: DUCKDB_API duckdb_scalar_function duckdb_create_scalar_function();
2367: 
2368: /*!
2369: Destroys the given scalar function object.
2370: 
2371: * scalar_function: The scalar function to destroy
2372: */
2373: DUCKDB_API void duckdb_destroy_scalar_function(duckdb_scalar_function *scalar_function);
2374: 
2375: /*!
2376: Sets the name of the given scalar function.
2377: 
2378: * scalar_function: The scalar function
2379: * name: The name of the scalar function
2380: */
2381: DUCKDB_API void duckdb_scalar_function_set_name(duckdb_scalar_function scalar_function, const char *name);
2382: 
2383: /*!
2384: Sets the parameters of the given scalar function to varargs. Does not require adding parameters with
2385: duckdb_scalar_function_add_parameter.
2386: 
2387: * @param scalar_function: The scalar function;
2388: * @param type The type of the arguments.
2389: */
2390: DUCKDB_API void duckdb_scalar_function_set_varargs(duckdb_scalar_function scalar_function, duckdb_logical_type type);
2391: 
2392: /*!
2393: Sets the NULL handling of the scalar function to SPECIAL_HANDLING.
2394: 
2395: * scalar_function: The scalar function
2396: */
2397: DUCKDB_API void duckdb_scalar_function_set_special_handling(duckdb_scalar_function scalar_function);
2398: 
2399: /*!
2400: Adds a parameter to the scalar function.
2401: 
2402: * @param scalar_function The scalar function.
2403: * @param type The parameter type. Cannot contain INVALID.
2404: */
2405: DUCKDB_API void duckdb_scalar_function_add_parameter(duckdb_scalar_function scalar_function, duckdb_logical_type type);
2406: 
2407: /*!
2408: Sets the return type of the scalar function.
2409: 
2410: * @param scalar_function The scalar function.
2411: * @param type The return type. Cannot contain INVALID or ANY.
2412: */
2413: DUCKDB_API void duckdb_scalar_function_set_return_type(duckdb_scalar_function scalar_function,
2414:                                                        duckdb_logical_type type);
2415: 
2416: /*!
2417: Assigns extra information to the scalar function that can be fetched during binding, etc.
2418: 
2419: * scalar_function: The scalar function
2420: * extra_info: The extra information
2421: * destroy: The callback that will be called to destroy the bind data (if any)
2422: */
2423: DUCKDB_API void duckdb_scalar_function_set_extra_info(duckdb_scalar_function scalar_function, void *extra_info,
2424:                                                       duckdb_delete_callback_t destroy);
2425: 
2426: /*!
2427: Sets the main function of the scalar function.
2428: 
2429: * scalar_function: The scalar function
2430: * function: The function
2431: */
2432: DUCKDB_API void duckdb_scalar_function_set_function(duckdb_scalar_function scalar_function,
2433:                                                     duckdb_scalar_function_t function);
2434: 
2435: /*!
2436: Register the scalar function object within the given connection.
2437: 
2438: The function requires at least a name, a function and a return type.
2439: 
2440: If the function is incomplete or a function with this name already exists DuckDBError is returned.
2441: 
2442: * con: The connection to register it in.
2443: * function: The function pointer
2444: * returns: Whether or not the registration was successful.
2445: */
2446: DUCKDB_API duckdb_state duckdb_register_scalar_function(duckdb_connection con, duckdb_scalar_function scalar_function);
2447: 
2448: /*!
2449: Retrieves the extra info of the function as set in `duckdb_scalar_function_set_extra_info`.
2450: 
2451: * info: The info object
2452: * returns: The extra info
2453: */
2454: DUCKDB_API void *duckdb_scalar_function_get_extra_info(duckdb_function_info info);
2455: 
2456: /*!
2457: Report that an error has occurred while executing the scalar function.
2458: 
2459: * info: The info object
2460: * error: The error message
2461: */
2462: DUCKDB_API void duckdb_scalar_function_set_error(duckdb_function_info info, const char *error);
2463: 
2464: //===--------------------------------------------------------------------===//
2465: // Table Functions
2466: //===--------------------------------------------------------------------===//
2467: 
2468: /*!
2469: Creates a new empty table function.
2470: 
2471: The return value should be destroyed with `duckdb_destroy_table_function`.
2472: 
2473: * returns: The table function object.
2474: */
2475: DUCKDB_API duckdb_table_function duckdb_create_table_function();
2476: 
2477: /*!
2478: Destroys the given table function object.
2479: 
2480: * table_function: The table function to destroy
2481: */
2482: DUCKDB_API void duckdb_destroy_table_function(duckdb_table_function *table_function);
2483: 
2484: /*!
2485: Sets the name of the given table function.
2486: 
2487: * table_function: The table function
2488: * name: The name of the table function
2489: */
2490: DUCKDB_API void duckdb_table_function_set_name(duckdb_table_function table_function, const char *name);
2491: 
2492: /*!
2493: Adds a parameter to the table function.
2494: 
2495: * @param table_function The table function.
2496: * @param type The parameter type. Cannot contain INVALID.
2497: */
2498: DUCKDB_API void duckdb_table_function_add_parameter(duckdb_table_function table_function, duckdb_logical_type type);
2499: 
2500: /*!
2501: Adds a named parameter to the table function.
2502: 
2503: * @param table_function The table function.
2504: * @param name The parameter name.
2505: * @param type The parameter type. Cannot contain INVALID.
2506: */
2507: DUCKDB_API void duckdb_table_function_add_named_parameter(duckdb_table_function table_function, const char *name,
2508:                                                           duckdb_logical_type type);
2509: 
2510: /*!
2511: Assigns extra information to the table function that can be fetched during binding, etc.
2512: 
2513: * table_function: The table function
2514: * extra_info: The extra information
2515: * destroy: The callback that will be called to destroy the bind data (if any)
2516: */
2517: DUCKDB_API void duckdb_table_function_set_extra_info(duckdb_table_function table_function, void *extra_info,
2518:                                                      duckdb_delete_callback_t destroy);
2519: 
2520: /*!
2521: Sets the bind function of the table function.
2522: 
2523: * table_function: The table function
2524: * bind: The bind function
2525: */
2526: DUCKDB_API void duckdb_table_function_set_bind(duckdb_table_function table_function, duckdb_table_function_bind_t bind);
2527: 
2528: /*!
2529: Sets the init function of the table function.
2530: 
2531: * table_function: The table function
2532: * init: The init function
2533: */
2534: DUCKDB_API void duckdb_table_function_set_init(duckdb_table_function table_function, duckdb_table_function_init_t init);
2535: 
2536: /*!
2537: Sets the thread-local init function of the table function.
2538: 
2539: * table_function: The table function
2540: * init: The init function
2541: */
2542: DUCKDB_API void duckdb_table_function_set_local_init(duckdb_table_function table_function,
2543:                                                      duckdb_table_function_init_t init);
2544: 
2545: /*!
2546: Sets the main function of the table function.
2547: 
2548: * table_function: The table function
2549: * function: The function
2550: */
2551: DUCKDB_API void duckdb_table_function_set_function(duckdb_table_function table_function,
2552:                                                    duckdb_table_function_t function);
2553: 
2554: /*!
2555: Sets whether or not the given table function supports projection pushdown.
2556: 
2557: If this is set to true, the system will provide a list of all required columns in the `init` stage through
2558: the `duckdb_init_get_column_count` and `duckdb_init_get_column_index` functions.
2559: If this is set to false (the default), the system will expect all columns to be projected.
2560: 
2561: * table_function: The table function
2562: * pushdown: True if the table function supports projection pushdown, false otherwise.
2563: */
2564: DUCKDB_API void duckdb_table_function_supports_projection_pushdown(duckdb_table_function table_function, bool pushdown);
2565: 
2566: /*!
2567: Register the table function object within the given connection.
2568: 
2569: The function requires at least a name, a bind function, an init function and a main function.
2570: 
2571: If the function is incomplete or a function with this name already exists DuckDBError is returned.
2572: 
2573: * con: The connection to register it in.
2574: * function: The function pointer
2575: * returns: Whether or not the registration was successful.
2576: */
2577: DUCKDB_API duckdb_state duckdb_register_table_function(duckdb_connection con, duckdb_table_function function);
2578: 
2579: //===--------------------------------------------------------------------===//
2580: // Table Function Bind
2581: //===--------------------------------------------------------------------===//
2582: 
2583: /*!
2584: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.
2585: 
2586: * info: The info object
2587: * returns: The extra info
2588: */
2589: DUCKDB_API void *duckdb_bind_get_extra_info(duckdb_bind_info info);
2590: 
2591: /*!
2592: Adds a result column to the output of the table function.
2593: 
2594: * @param info The table function's bind info.
2595: * @param name The column name.
2596: * @param type The logical column type.
2597: */
2598: DUCKDB_API void duckdb_bind_add_result_column(duckdb_bind_info info, const char *name, duckdb_logical_type type);
2599: 
2600: /*!
2601: Retrieves the number of regular (non-named) parameters to the function.
2602: 
2603: * info: The info object
2604: * returns: The number of parameters
2605: */
2606: DUCKDB_API idx_t duckdb_bind_get_parameter_count(duckdb_bind_info info);
2607: 
2608: /*!
2609: Retrieves the parameter at the given index.
2610: 
2611: The result must be destroyed with `duckdb_destroy_value`.
2612: 
2613: * info: The info object
2614: * index: The index of the parameter to get
2615: * returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
2616: */
2617: DUCKDB_API duckdb_value duckdb_bind_get_parameter(duckdb_bind_info info, idx_t index);
2618: 
2619: /*!
2620: Retrieves a named parameter with the given name.
2621: 
2622: The result must be destroyed with `duckdb_destroy_value`.
2623: 
2624: * info: The info object
2625: * name: The name of the parameter
2626: * returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
2627: */
2628: DUCKDB_API duckdb_value duckdb_bind_get_named_parameter(duckdb_bind_info info, const char *name);
2629: 
2630: /*!
2631: Sets the user-provided bind data in the bind object. This object can be retrieved again during execution.
2632: 
2633: * info: The info object
2634: * extra_data: The bind data object.
2635: * destroy: The callback that will be called to destroy the bind data (if any)
2636: */
2637: DUCKDB_API void duckdb_bind_set_bind_data(duckdb_bind_info info, void *bind_data, duckdb_delete_callback_t destroy);
2638: 
2639: /*!
2640: Sets the cardinality estimate for the table function, used for optimization.
2641: 
2642: * info: The bind data object.
2643: * is_exact: Whether or not the cardinality estimate is exact, or an approximation
2644: */
2645: DUCKDB_API void duckdb_bind_set_cardinality(duckdb_bind_info info, idx_t cardinality, bool is_exact);
2646: 
2647: /*!
2648: Report that an error has occurred while calling bind.
2649: 
2650: * info: The info object
2651: * error: The error message
2652: */
2653: DUCKDB_API void duckdb_bind_set_error(duckdb_bind_info info, const char *error);
2654: 
2655: //===--------------------------------------------------------------------===//
2656: // Table Function Init
2657: //===--------------------------------------------------------------------===//
2658: 
2659: /*!
2660: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.
2661: 
2662: * info: The info object
2663: * returns: The extra info
2664: */
2665: DUCKDB_API void *duckdb_init_get_extra_info(duckdb_init_info info);
2666: 
2667: /*!
2668: Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
2669: 
2670: Note that the bind data should be considered as read-only.
2671: For tracking state, use the init data instead.
2672: 
2673: * info: The info object
2674: * returns: The bind data object
2675: */
2676: DUCKDB_API void *duckdb_init_get_bind_data(duckdb_init_info info);
2677: 
2678: /*!
2679: Sets the user-provided init data in the init object. This object can be retrieved again during execution.
2680: 
2681: * info: The info object
2682: * extra_data: The init data object.
2683: * destroy: The callback that will be called to destroy the init data (if any)
2684: */
2685: DUCKDB_API void duckdb_init_set_init_data(duckdb_init_info info, void *init_data, duckdb_delete_callback_t destroy);
2686: 
2687: /*!
2688: Returns the number of projected columns.
2689: 
2690: This function must be used if projection pushdown is enabled to figure out which columns to emit.
2691: 
2692: * info: The info object
2693: * returns: The number of projected columns.
2694: */
2695: DUCKDB_API idx_t duckdb_init_get_column_count(duckdb_init_info info);
2696: 
2697: /*!
2698: Returns the column index of the projected column at the specified position.
2699: 
2700: This function must be used if projection pushdown is enabled to figure out which columns to emit.
2701: 
2702: * info: The info object
2703: * column_index: The index at which to get the projected column index, from 0..duckdb_init_get_column_count(info)
2704: * returns: The column index of the projected column.
2705: */
2706: DUCKDB_API idx_t duckdb_init_get_column_index(duckdb_init_info info, idx_t column_index);
2707: 
2708: /*!
2709: Sets how many threads can process this table function in parallel (default: 1)
2710: 
2711: * info: The info object
2712: * max_threads: The maximum amount of threads that can process this table function
2713: */
2714: DUCKDB_API void duckdb_init_set_max_threads(duckdb_init_info info, idx_t max_threads);
2715: 
2716: /*!
2717: Report that an error has occurred while calling init.
2718: 
2719: * info: The info object
2720: * error: The error message
2721: */
2722: DUCKDB_API void duckdb_init_set_error(duckdb_init_info info, const char *error);
2723: 
2724: //===--------------------------------------------------------------------===//
2725: // Table Function
2726: //===--------------------------------------------------------------------===//
2727: 
2728: /*!
2729: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`.
2730: 
2731: * info: The info object
2732: * returns: The extra info
2733: */
2734: DUCKDB_API void *duckdb_function_get_extra_info(duckdb_function_info info);
2735: 
2736: /*!
2737: Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
2738: 
2739: Note that the bind data should be considered as read-only.
2740: For tracking state, use the init data instead.
2741: 
2742: * info: The info object
2743: * returns: The bind data object
2744: */
2745: DUCKDB_API void *duckdb_function_get_bind_data(duckdb_function_info info);
2746: 
2747: /*!
2748: Gets the init data set by `duckdb_init_set_init_data` during the init.
2749: 
2750: * info: The info object
2751: * returns: The init data object
2752: */
2753: DUCKDB_API void *duckdb_function_get_init_data(duckdb_function_info info);
2754: 
2755: /*!
2756: Gets the thread-local init data set by `duckdb_init_set_init_data` during the local_init.
2757: 
2758: * info: The info object
2759: * returns: The init data object
2760: */
2761: DUCKDB_API void *duckdb_function_get_local_init_data(duckdb_function_info info);
2762: 
2763: /*!
2764: Report that an error has occurred while executing the function.
2765: 
2766: * info: The info object
2767: * error: The error message
2768: */
2769: DUCKDB_API void duckdb_function_set_error(duckdb_function_info info, const char *error);
2770: 
2771: //===--------------------------------------------------------------------===//
2772: // Replacement Scans
2773: //===--------------------------------------------------------------------===//
2774: 
2775: /*!
2776: Add a replacement scan definition to the specified database.
2777: 
2778: * db: The database object to add the replacement scan to
2779: * replacement: The replacement scan callback
2780: * extra_data: Extra data that is passed back into the specified callback
2781: * delete_callback: The delete callback to call on the extra data, if any
2782: */
2783: DUCKDB_API void duckdb_add_replacement_scan(duckdb_database db, duckdb_replacement_callback_t replacement,
2784:                                             void *extra_data, duckdb_delete_callback_t delete_callback);
2785: 
2786: /*!
2787: Sets the replacement function name. If this function is called in the replacement callback,
2788: the replacement scan is performed. If it is not called, the replacement callback is not performed.
2789: 
2790: * info: The info object
2791: * function_name: The function name to substitute.
2792: */
2793: DUCKDB_API void duckdb_replacement_scan_set_function_name(duckdb_replacement_scan_info info, const char *function_name);
2794: 
2795: /*!
2796: Adds a parameter to the replacement scan function.
2797: 
2798: * info: The info object
2799: * parameter: The parameter to add.
2800: */
2801: DUCKDB_API void duckdb_replacement_scan_add_parameter(duckdb_replacement_scan_info info, duckdb_value parameter);
2802: 
2803: /*!
2804: Report that an error has occurred while executing the replacement scan.
2805: 
2806: * info: The info object
2807: * error: The error message
2808: */
2809: DUCKDB_API void duckdb_replacement_scan_set_error(duckdb_replacement_scan_info info, const char *error);
2810: #endif
2811: 
2812: //===--------------------------------------------------------------------===//
2813: // Profiling Info
2814: //===--------------------------------------------------------------------===//
2815: 
2816: /*!
2817: Returns the root node from the profiling information. Returns NULL if profiling is not enabled
2818: 
2819: * @param connection A connection object
2820: * @return A profiling information object
2821: */
2822: DUCKDB_API duckdb_profiling_info duckdb_get_profiling_info(duckdb_connection connection);
2823: 
2824: /*!
2825: Returns the value of the setting key of the current profiling info node. If the setting does not exist or is not
2826: enabled, nullptr is returned.
2827: 
2828: * @param info A profiling information object
2829: * @param key The name of the metric setting to return the value for
2830: * @return The value of the metric setting. Must be freed with `duckdb_free`.
2831: */
2832: DUCKDB_API const char *duckdb_profiling_info_get_value(duckdb_profiling_info info, const char *key);
2833: 
2834: /*!
2835: Returns the number of children in the current profiling info node.
2836: 
2837: * @param info A profiling information object
2838: * @return The number of children in the current node
2839: */
2840: DUCKDB_API idx_t duckdb_profiling_info_get_child_count(duckdb_profiling_info info);
2841: 
2842: /*!
2843: Returns the child node at the specified index.
2844: 
2845: * @param info A profiling information object
2846: * @param index The index of the child node to return
2847: * @return The child node at the specified index
2848: */
2849: DUCKDB_API duckdb_profiling_info duckdb_profiling_info_get_child(duckdb_profiling_info info, idx_t index);
2850: 
2851: /*! Returns the operator name of the current profiling info node, if the node is an Operator Node.
2852:  *
2853:  * @param info A profiling information object
2854:  * @return The name of the operator of the current node. Returns a nullptr if the node is not an Operator Node. The
2855:  * result must be freed with `duckdb_free`.
2856:  */
2857: DUCKDB_API const char *duckdb_profiling_info_get_name(duckdb_profiling_info info);
2858: 
2859: /*!
2860: Returns the query of the current profiling info node, if the node the query root node.
2861: 
2862: * @param info A profiling information object
2863: * @return The query of the current node. Returns a nullptr if the node is not a Query Node. The result must be freed
2864: with `duckdb_free`.
2865: */
2866: DUCKDB_API const char *duckdb_profiling_info_get_query(duckdb_profiling_info info);
2867: 
2868: //===--------------------------------------------------------------------===//
2869: // Appender
2870: //===--------------------------------------------------------------------===//
2871: 
2872: // Appenders are the most efficient way of loading data into DuckDB from within the C interface, and are recommended for
2873: // fast data loading. The appender is much faster than using prepared statements or individual `INSERT INTO` statements.
2874: 
2875: // Appends are made in row-wise format. For every column, a `duckdb_append_[type]` call should be made, after which
2876: // the row should be finished by calling `duckdb_appender_end_row`. After all rows have been appended,
2877: // `duckdb_appender_destroy` should be used to finalize the appender and clean up the resulting memory.
2878: 
2879: // Instead of appending rows with `duckdb_appender_end_row`, it is also possible to fill and append
2880: // chunks-at-a-time.
2881: 
2882: // Note that `duckdb_appender_destroy` should always be called on the resulting appender, even if the function returns
2883: // `DuckDBError`.
2884: 
2885: /*!
2886: Creates an appender object.
2887: 
2888: Note that the object must be destroyed with `duckdb_appender_destroy`.
2889: 
2890: * connection: The connection context to create the appender in.
2891: * schema: The schema of the table to append to, or `nullptr` for the default schema.
2892: * table: The table name to append to.
2893: * out_appender: The resulting appender object.
2894: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2895: */
2896: DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
2897:                                                duckdb_appender *out_appender);
2898: 
2899: /*!
2900: Returns the number of columns in the table that belongs to the appender.
2901: 
2902: * appender The appender to get the column count from.
2903: * returns: The number of columns in the table.
2904: */
2905: DUCKDB_API idx_t duckdb_appender_column_count(duckdb_appender appender);
2906: 
2907: /*!
2908: Returns the type of the column at the specified index.
2909: 
2910: Note: The resulting type should be destroyed with `duckdb_destroy_logical_type`.
2911: 
2912: * appender The appender to get the column type from.
2913: * col_idx The index of the column to get the type of.
2914: * returns: The duckdb_logical_type of the column.
2915: */
2916: DUCKDB_API duckdb_logical_type duckdb_appender_column_type(duckdb_appender appender, idx_t col_idx);
2917: 
2918: /*!
2919: Returns the error message associated with the given appender.
2920: If the appender has no error message, this returns `nullptr` instead.
2921: 
2922: The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.
2923: 
2924: * appender: The appender to get the error from.
2925: * returns: The error message, or `nullptr` if there is none.
2926: */
2927: DUCKDB_API const char *duckdb_appender_error(duckdb_appender appender);
2928: 
2929: /*!
2930: Flush the appender to the table, forcing the cache of the appender to be cleared. If flushing the data triggers a
2931: constraint violation or any other error, then all data is invalidated, and this function returns DuckDBError.
2932: It is not possible to append more values. Call duckdb_appender_error to obtain the error message followed by
2933: duckdb_appender_destroy to destroy the invalidated appender.
2934: 
2935: * appender: The appender to flush.
2936: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2937: */
2938: DUCKDB_API duckdb_state duckdb_appender_flush(duckdb_appender appender);
2939: 
2940: /*!
2941: Closes the appender by flushing all intermediate states and closing it for further appends. If flushing the data
2942: triggers a constraint violation or any other error, then all data is invalidated, and this function returns DuckDBError.
2943: Call duckdb_appender_error to obtain the error message followed by duckdb_appender_destroy to destroy the invalidated
2944: appender.
2945: 
2946: * appender: The appender to flush and close.
2947: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2948: */
2949: DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);
2950: 
2951: /*!
2952: Closes the appender by flushing all intermediate states to the table and destroying it. By destroying it, this function
2953: de-allocates all memory associated with the appender. If flushing the data triggers a constraint violation,
2954: then all data is invalidated, and this function returns DuckDBError. Due to the destruction of the appender, it is no
2955: longer possible to obtain the specific error message with duckdb_appender_error. Therefore, call duckdb_appender_close
2956: before destroying the appender, if you need insights into the specific error.
2957: 
2958: * appender: The appender to flush, close and destroy.
2959: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2960: */
2961: DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);
2962: 
2963: /*!
2964: A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.
2965: */
2966: DUCKDB_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);
2967: 
2968: /*!
2969: Finish the current row of appends. After end_row is called, the next row can be appended.
2970: 
2971: * appender: The appender.
2972: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2973: */
2974: DUCKDB_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);
2975: 
2976: /*!
2977: Append a DEFAULT value (NULL if DEFAULT not available for column) to the appender.
2978: */
2979: DUCKDB_API duckdb_state duckdb_append_default(duckdb_appender appender);
2980: 
2981: /*!
2982: Append a bool value to the appender.
2983: */
2984: DUCKDB_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);
2985: 
2986: /*!
2987: Append an int8_t value to the appender.
2988: */
2989: DUCKDB_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);
2990: 
2991: /*!
2992: Append an int16_t value to the appender.
2993: */
2994: DUCKDB_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);
2995: 
2996: /*!
2997: Append an int32_t value to the appender.
2998: */
2999: DUCKDB_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);
3000: 
3001: /*!
3002: Append an int64_t value to the appender.
3003: */
3004: DUCKDB_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);
3005: 
3006: /*!
3007: Append a duckdb_hugeint value to the appender.
3008: */
3009: DUCKDB_API duckdb_state duckdb_append_hugeint(duckdb_appender appender, duckdb_hugeint value);
3010: 
3011: /*!
3012: Append a uint8_t value to the appender.
3013: */
3014: DUCKDB_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);
3015: 
3016: /*!
3017: Append a uint16_t value to the appender.
3018: */
3019: DUCKDB_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);
3020: 
3021: /*!
3022: Append a uint32_t value to the appender.
3023: */
3024: DUCKDB_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);
3025: 
3026: /*!
3027: Append a uint64_t value to the appender.
3028: */
3029: DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);
3030: 
3031: /*!
3032: Append a duckdb_uhugeint value to the appender.
3033: */
3034: DUCKDB_API duckdb_state duckdb_append_uhugeint(duckdb_appender appender, duckdb_uhugeint value);
3035: 
3036: /*!
3037: Append a float value to the appender.
3038: */
3039: DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);
3040: 
3041: /*!
3042: Append a double value to the appender.
3043: */
3044: DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);
3045: 
3046: /*!
3047: Append a duckdb_date value to the appender.
3048: */
3049: DUCKDB_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);
3050: 
3051: /*!
3052: Append a duckdb_time value to the appender.
3053: */
3054: DUCKDB_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);
3055: 
3056: /*!
3057: Append a duckdb_timestamp value to the appender.
3058: */
3059: DUCKDB_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);
3060: 
3061: /*!
3062: Append a duckdb_interval value to the appender.
3063: */
3064: DUCKDB_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);
3065: 
3066: /*!
3067: Append a varchar value to the appender.
3068: */
3069: DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);
3070: 
3071: /*!
3072: Append a varchar value to the appender.
3073: */
3074: DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);
3075: 
3076: /*!
3077: Append a blob value to the appender.
3078: */
3079: DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);
3080: 
3081: /*!
3082: Append a NULL value to the appender (of any type).
3083: */
3084: DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);
3085: 
3086: /*!
3087: Appends a pre-filled data chunk to the specified appender.
3088: 
3089: The types of the data chunk must exactly match the types of the table, no casting is performed.
3090: If the types do not match or the appender is in an invalid state, DuckDBError is returned.
3091: If the append is successful, DuckDBSuccess is returned.
3092: 
3093: * appender: The appender to append to.
3094: * chunk: The data chunk to append.
3095: * returns: The return state.
3096: */
3097: DUCKDB_API duckdb_state duckdb_append_data_chunk(duckdb_appender appender, duckdb_data_chunk chunk);
3098: 
3099: //===--------------------------------------------------------------------===//
3100: // TableDescription
3101: //===--------------------------------------------------------------------===//
3102: 
3103: /*!
3104: Creates a table description object.
3105: Note that `duckdb_table_description_destroy` should always be called on the resulting table_description, even if the
3106: function returns `DuckDBError`.
3107: * connection: The connection context.
3108: * schema: The schema of the table, or `nullptr` for the default schema.
3109: * table: The table name.
3110: * out: The resulting table description object.
3111: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
3112: */
3113: DUCKDB_API duckdb_state duckdb_table_description_create(duckdb_connection connection, const char *schema,
3114:                                                         const char *table, duckdb_table_description *out);
3115: 
3116: /*!
3117: Destroy the TableDescription object.
3118: * table: The table_description to destroy.
3119: */
3120: DUCKDB_API void duckdb_table_description_destroy(duckdb_table_description *table_description);
3121: 
3122: /*!
3123: Returns the error message associated with the given table_description.
3124: If the table_description has no error message, this returns `nullptr` instead.
3125: The error message should not be freed. It will be de-allocated when `duckdb_table_description_destroy` is called.
3126: * table_description: The table_description to get the error from.
3127: * returns: The error message, or `nullptr` if there is none.
3128: */
3129: DUCKDB_API const char *duckdb_table_description_error(duckdb_table_description table);
3130: 
3131: /*!
3132: Check if the column at 'index' index of the table has a DEFAULT expression.
3133: * table: The table_description to query.
3134: * index: The index of the column to query.
3135: * out: The out-parameter used to store the result.
3136: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
3137: */
3138: DUCKDB_API duckdb_state duckdb_column_has_default(duckdb_table_description table_description, idx_t index, bool *out);
3139: 
3140: #ifndef DUCKDB_API_NO_DEPRECATED
3141: //===--------------------------------------------------------------------===//
3142: // Arrow Interface
3143: //===--------------------------------------------------------------------===//
3144: 
3145: /*!
3146: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3147: 
3148: Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.
3149: If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
3150: `duckdb_query_arrow_error`.
3151: 
3152: Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the
3153: query fails, otherwise the error stored within the result will not be freed correctly.
3154: 
3155: * connection: The connection to perform the query in.
3156: * query: The SQL query to run.
3157: * out_result: The query result.
3158: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
3159: */
3160: DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);
3161: 
3162: /*!
3163: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3164: 
3165: Fetch the internal arrow schema from the arrow result. Remember to call release on the respective
3166: ArrowSchema object.
3167: 
3168: * result: The result to fetch the schema from.
3169: * out_schema: The output schema.
3170: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
3171: */
3172: DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);
3173: 
3174: /*!
3175: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3176: 
3177: Fetch the internal arrow schema from the prepared statement. Remember to call release on the respective
3178: ArrowSchema object.
3179: 
3180: * result: The prepared statement to fetch the schema from.
3181: * out_schema: The output schema.
3182: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
3183: */
3184: DUCKDB_API duckdb_state duckdb_prepared_arrow_schema(duckdb_prepared_statement prepared,
3185:                                                      duckdb_arrow_schema *out_schema);
3186: /*!
3187: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3188: 
3189: Convert a data chunk into an arrow struct array. Remember to call release on the respective
3190: ArrowArray object.
3191: 
3192: * result: The result object the data chunk have been fetched from.
3193: * chunk: The data chunk to convert.
3194: * out_array: The output array.
3195: */
3196: DUCKDB_API void duckdb_result_arrow_array(duckdb_result result, duckdb_data_chunk chunk, duckdb_arrow_array *out_array);
3197: 
3198: /*!
3199: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3200: 
3201: Fetch an internal arrow struct array from the arrow result. Remember to call release on the respective
3202: ArrowArray object.
3203: 
3204: This function can be called multiple time to get next chunks, which will free the previous out_array.
3205: So consume the out_array before calling this function again.
3206: 
3207: * result: The result to fetch the array from.
3208: * out_array: The output array.
3209: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
3210: */
3211: DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);
3212: 
3213: /*!
3214: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3215: 
3216: Returns the number of columns present in the arrow result object.
3217: 
3218: * result: The result object.
3219: * returns: The number of columns present in the result object.
3220: */
3221: DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);
3222: 
3223: /*!
3224: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3225: 
3226: Returns the number of rows present in the arrow result object.
3227: 
3228: * result: The result object.
3229: * returns: The number of rows present in the result object.
3230: */
3231: DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);
3232: 
3233: /*!
3234: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3235: 
3236: Returns the number of rows changed by the query stored in the arrow result. This is relevant only for
3237: INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.
3238: 
3239: * result: The result object.
3240: * returns: The number of rows changed.
3241: */
3242: DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);
3243: 
3244: /*!
3245: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3246: 
3247:  Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns
3248: `DuckDBError`.
3249: 
3250: The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.
3251: 
3252: * result: The result object to fetch the error from.
3253: * returns: The error of the result.
3254: */
3255: DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);
3256: 
3257: /*!
3258: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3259: 
3260: Closes the result and de-allocates all memory allocated for the arrow result.
3261: 
3262: * result: The result to destroy.
3263: */
3264: DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
3265: 
3266: /*!
3267: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3268: 
3269: Releases the arrow array stream and de-allocates its memory.
3270: 
3271: * stream: The arrow array stream to destroy.
3272: */
3273: DUCKDB_API void duckdb_destroy_arrow_stream(duckdb_arrow_stream *stream_p);
3274: 
3275: /*!
3276: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3277: 
3278: Executes the prepared statement with the given bound parameters, and returns an arrow query result.
3279: Note that after running `duckdb_execute_prepared_arrow`, `duckdb_destroy_arrow` must be called on the result object.
3280: 
3281: * prepared_statement: The prepared statement to execute.
3282: * out_result: The query result.
3283: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
3284: */
3285: DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,
3286:                                                       duckdb_arrow *out_result);
3287: 
3288: /*!
3289: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3290: 
3291: Scans the Arrow stream and creates a view with the given name.
3292: 
3293: * connection: The connection on which to execute the scan.
3294: * table_name: Name of the temporary view to create.
3295: * arrow: Arrow stream wrapper.
3296: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
3297: */
3298: DUCKDB_API duckdb_state duckdb_arrow_scan(duckdb_connection connection, const char *table_name,
3299:                                           duckdb_arrow_stream arrow);
3300: 
3301: /*!
3302: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3303: 
3304: Scans the Arrow array and creates a view with the given name.
3305: Note that after running `duckdb_arrow_array_scan`, `duckdb_destroy_arrow_stream` must be called on the out stream.
3306: 
3307: * connection: The connection on which to execute the scan.
3308: * table_name: Name of the temporary view to create.
3309: * arrow_schema: Arrow schema wrapper.
3310: * arrow_array: Arrow array wrapper.
3311: * out_stream: Output array stream that wraps around the passed schema, for releasing/deleting once done.
3312: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
3313: */
3314: DUCKDB_API duckdb_state duckdb_arrow_array_scan(duckdb_connection connection, const char *table_name,
3315:                                                 duckdb_arrow_schema arrow_schema, duckdb_arrow_array arrow_array,
3316:                                                 duckdb_arrow_stream *out_stream);
3317: #endif
3318: 
3319: #ifndef DUCKDB_NO_EXTENSION_FUNCTIONS
3320: //===--------------------------------------------------------------------===//
3321: // Threading Information
3322: //===--------------------------------------------------------------------===//
3323: 
3324: /*!
3325: Execute DuckDB tasks on this thread.
3326: 
3327: Will return after `max_tasks` have been executed, or if there are no more tasks present.
3328: 
3329: * database: The database object to execute tasks for
3330: * max_tasks: The maximum amount of tasks to execute
3331: */
3332: DUCKDB_API void duckdb_execute_tasks(duckdb_database database, idx_t max_tasks);
3333: 
3334: /*!
3335: Creates a task state that can be used with duckdb_execute_tasks_state to execute tasks until
3336: `duckdb_finish_execution` is called on the state.
3337: 
3338: `duckdb_destroy_state` must be called on the result.
3339: 
3340: * database: The database object to create the task state for
3341: * returns: The task state that can be used with duckdb_execute_tasks_state.
3342: */
3343: DUCKDB_API duckdb_task_state duckdb_create_task_state(duckdb_database database);
3344: 
3345: /*!
3346: Execute DuckDB tasks on this thread.
3347: 
3348: The thread will keep on executing tasks forever, until duckdb_finish_execution is called on the state.
3349: Multiple threads can share the same duckdb_task_state.
3350: 
3351: * state: The task state of the executor
3352: */
3353: DUCKDB_API void duckdb_execute_tasks_state(duckdb_task_state state);
3354: 
3355: /*!
3356: Execute DuckDB tasks on this thread.
3357: 
3358: The thread will keep on executing tasks until either duckdb_finish_execution is called on the state,
3359: max_tasks tasks have been executed or there are no more tasks to be executed.
3360: 
3361: Multiple threads can share the same duckdb_task_state.
3362: 
3363: * state: The task state of the executor
3364: * max_tasks: The maximum amount of tasks to execute
3365: * returns: The amount of tasks that have actually been executed
3366: */
3367: DUCKDB_API idx_t duckdb_execute_n_tasks_state(duckdb_task_state state, idx_t max_tasks);
3368: 
3369: /*!
3370: Finish execution on a specific task.
3371: 
3372: * state: The task state to finish execution
3373: */
3374: DUCKDB_API void duckdb_finish_execution(duckdb_task_state state);
3375: 
3376: /*!
3377: Check if the provided duckdb_task_state has finished execution
3378: 
3379: * state: The task state to inspect
3380: * returns: Whether or not duckdb_finish_execution has been called on the task state
3381: */
3382: DUCKDB_API bool duckdb_task_state_is_finished(duckdb_task_state state);
3383: 
3384: /*!
3385: Destroys the task state returned from duckdb_create_task_state.
3386: 
3387: Note that this should not be called while there is an active duckdb_execute_tasks_state running
3388: on the task state.
3389: 
3390: * state: The task state to clean up
3391: */
3392: DUCKDB_API void duckdb_destroy_task_state(duckdb_task_state state);
3393: 
3394: /*!
3395: Returns true if the execution of the current query is finished.
3396: 
3397: * con: The connection on which to check
3398: */
3399: DUCKDB_API bool duckdb_execution_is_finished(duckdb_connection con);
3400: #endif
3401: 
3402: //===--------------------------------------------------------------------===//
3403: // Streaming Result Interface
3404: //===--------------------------------------------------------------------===//
3405: #ifndef DUCKDB_API_NO_DEPRECATED
3406: /*!
3407: **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.
3408: 
3409: Fetches a data chunk from the (streaming) duckdb_result. This function should be called repeatedly until the result is
3410: exhausted.
3411: 
3412: The result must be destroyed with `duckdb_destroy_data_chunk`.
3413: 
3414: This function can only be used on duckdb_results created with 'duckdb_pending_prepared_streaming'
3415: 
3416: If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be
3417: mixed with the legacy result functions or the materialized result functions).
3418: 
3419: It is not known beforehand how many chunks will be returned by this result.
3420: 
3421: * result: The result object to fetch the data chunk from.
3422: * returns: The resulting data chunk. Returns `NULL` if the result has an error.
3423: */
3424: DUCKDB_API duckdb_data_chunk duckdb_stream_fetch_chunk(duckdb_result result);
3425: #endif
3426: 
3427: /*!
3428: Fetches a data chunk from a duckdb_result. This function should be called repeatedly until the result is exhausted.
3429: 
3430: The result must be destroyed with `duckdb_destroy_data_chunk`.
3431: 
3432: It is not known beforehand how many chunks will be returned by this result.
3433: 
3434: * result: The result object to fetch the data chunk from.
3435: * returns: The resulting data chunk. Returns `NULL` if the result has an error.
3436: */
3437: DUCKDB_API duckdb_data_chunk duckdb_fetch_chunk(duckdb_result result);
3438: 
3439: #ifdef __cplusplus
3440: }
3441: #endif
[end of src/include/duckdb.h]
[start of src/main/capi/scalar_function-c.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/common/type_visitor.hpp"
3: #include "duckdb/common/types.hpp"
4: #include "duckdb/function/function.hpp"
5: #include "duckdb/function/scalar_function.hpp"
6: #include "duckdb/main/capi/capi_internal.hpp"
7: #include "duckdb/main/client_context.hpp"
8: #include "duckdb/parser/parsed_data/create_scalar_function_info.hpp"
9: #include "duckdb/planner/expression/bound_function_expression.hpp"
10: 
11: namespace duckdb {
12: 
13: struct CScalarFunctionInfo : public ScalarFunctionInfo {
14: 	~CScalarFunctionInfo() override {
15: 		if (extra_info && delete_callback) {
16: 			delete_callback(extra_info);
17: 		}
18: 		extra_info = nullptr;
19: 		delete_callback = nullptr;
20: 	}
21: 
22: 	duckdb_scalar_function_t function = nullptr;
23: 	duckdb_function_info extra_info = nullptr;
24: 	duckdb_delete_callback_t delete_callback = nullptr;
25: 	bool success = true;
26: 	string error;
27: };
28: 
29: struct CScalarFunctionBindData : public FunctionData {
30: 	explicit CScalarFunctionBindData(CScalarFunctionInfo &info) : info(info) {
31: 	}
32: 
33: 	unique_ptr<FunctionData> Copy() const override {
34: 		return make_uniq<CScalarFunctionBindData>(info);
35: 	}
36: 	bool Equals(const FunctionData &other_p) const override {
37: 		auto &other = other_p.Cast<CScalarFunctionBindData>();
38: 		return info.extra_info == other.info.extra_info && info.function == other.info.function;
39: 	}
40: 
41: 	CScalarFunctionInfo &info;
42: };
43: 
44: duckdb::ScalarFunction &GetCScalarFunction(duckdb_scalar_function function) {
45: 	return *reinterpret_cast<duckdb::ScalarFunction *>(function);
46: }
47: 
48: unique_ptr<FunctionData> BindCAPIScalarFunction(ClientContext &, ScalarFunction &bound_function,
49:                                                 vector<unique_ptr<Expression>> &arguments) {
50: 	auto &info = bound_function.function_info->Cast<CScalarFunctionInfo>();
51: 	return make_uniq<CScalarFunctionBindData>(info);
52: }
53: 
54: void CAPIScalarFunction(DataChunk &input, ExpressionState &state, Vector &result) {
55: 	auto &bind_info = state.expr.Cast<BoundFunctionExpression>().bind_info;
56: 	auto &c_bind_info = bind_info->Cast<CScalarFunctionBindData>();
57: 
58: 	auto all_const = input.AllConstant();
59: 	input.Flatten();
60: 	auto c_input = reinterpret_cast<duckdb_data_chunk>(&input);
61: 	auto c_result = reinterpret_cast<duckdb_vector>(&result);
62: 	auto c_function_info = reinterpret_cast<duckdb_function_info>(&c_bind_info.info);
63: 	c_bind_info.info.function(c_function_info, c_input, c_result);
64: 	if (!c_bind_info.info.success) {
65: 		throw InvalidInputException(c_bind_info.info.error);
66: 	}
67: 	if (all_const) {
68: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
69: 	}
70: }
71: 
72: } // namespace duckdb
73: 
74: using duckdb::GetCScalarFunction;
75: 
76: duckdb_scalar_function duckdb_create_scalar_function() {
77: 	auto function = new duckdb::ScalarFunction("", {}, duckdb::LogicalType::INVALID, duckdb::CAPIScalarFunction,
78: 	                                           duckdb::BindCAPIScalarFunction);
79: 	function->function_info = duckdb::make_shared_ptr<duckdb::CScalarFunctionInfo>();
80: 	return reinterpret_cast<duckdb_scalar_function>(function);
81: }
82: 
83: void duckdb_destroy_scalar_function(duckdb_scalar_function *function) {
84: 	if (function && *function) {
85: 		auto scalar_function = reinterpret_cast<duckdb::ScalarFunction *>(*function);
86: 		delete scalar_function;
87: 		*function = nullptr;
88: 	}
89: }
90: 
91: void duckdb_scalar_function_set_name(duckdb_scalar_function function, const char *name) {
92: 	if (!function || !name) {
93: 		return;
94: 	}
95: 	auto &scalar_function = GetCScalarFunction(function);
96: 	scalar_function.name = name;
97: }
98: 
99: void duckdb_scalar_function_set_varargs(duckdb_scalar_function function, duckdb_logical_type type) {
100: 	if (!function || !type) {
101: 		return;
102: 	}
103: 	auto &scalar_function = GetCScalarFunction(function);
104: 	auto logical_type = reinterpret_cast<duckdb::LogicalType *>(type);
105: 	scalar_function.varargs = *logical_type;
106: }
107: 
108: void duckdb_scalar_function_set_special_handling(duckdb_scalar_function function) {
109: 	if (!function) {
110: 		return;
111: 	}
112: 	auto &scalar_function = GetCScalarFunction(function);
113: 	scalar_function.null_handling = duckdb::FunctionNullHandling::SPECIAL_HANDLING;
114: }
115: 
116: void duckdb_scalar_function_add_parameter(duckdb_scalar_function function, duckdb_logical_type type) {
117: 	if (!function || !type) {
118: 		return;
119: 	}
120: 	auto &scalar_function = GetCScalarFunction(function);
121: 	auto logical_type = reinterpret_cast<duckdb::LogicalType *>(type);
122: 	scalar_function.arguments.push_back(*logical_type);
123: }
124: 
125: void duckdb_scalar_function_set_return_type(duckdb_scalar_function function, duckdb_logical_type type) {
126: 	if (!function || !type) {
127: 		return;
128: 	}
129: 	auto &scalar_function = GetCScalarFunction(function);
130: 	auto logical_type = reinterpret_cast<duckdb::LogicalType *>(type);
131: 	scalar_function.return_type = *logical_type;
132: }
133: 
134: duckdb::CScalarFunctionInfo &GetCScalarFunctionInfo(duckdb_function_info info) {
135: 	D_ASSERT(info);
136: 	return *reinterpret_cast<duckdb::CScalarFunctionInfo *>(info);
137: }
138: 
139: void *duckdb_scalar_function_get_extra_info(duckdb_function_info info) {
140: 	if (!info) {
141: 		return nullptr;
142: 	}
143: 	auto &scalar_function = GetCScalarFunctionInfo(info);
144: 	return scalar_function.extra_info;
145: }
146: 
147: void duckdb_scalar_function_set_error(duckdb_function_info info, const char *error) {
148: 	if (!info || !error) {
149: 		return;
150: 	}
151: 	auto &scalar_function = GetCScalarFunctionInfo(info);
152: 	scalar_function.error = error;
153: 	scalar_function.success = false;
154: }
155: 
156: void duckdb_scalar_function_set_extra_info(duckdb_scalar_function function, void *extra_info,
157:                                            duckdb_delete_callback_t destroy) {
158: 	if (!function || !extra_info) {
159: 		return;
160: 	}
161: 	auto &scalar_function = GetCScalarFunction(function);
162: 	auto &info = scalar_function.function_info->Cast<duckdb::CScalarFunctionInfo>();
163: 	info.extra_info = reinterpret_cast<duckdb_function_info>(extra_info);
164: 	info.delete_callback = destroy;
165: }
166: 
167: void duckdb_scalar_function_set_function(duckdb_scalar_function function, duckdb_scalar_function_t execute_func) {
168: 	if (!function || !execute_func) {
169: 		return;
170: 	}
171: 	auto &scalar_function = GetCScalarFunction(function);
172: 	auto &info = scalar_function.function_info->Cast<duckdb::CScalarFunctionInfo>();
173: 	info.function = execute_func;
174: }
175: 
176: duckdb_state duckdb_register_scalar_function(duckdb_connection connection, duckdb_scalar_function function) {
177: 	if (!connection || !function) {
178: 		return DuckDBError;
179: 	}
180: 	auto &scalar_function = GetCScalarFunction(function);
181: 	auto &info = scalar_function.function_info->Cast<duckdb::CScalarFunctionInfo>();
182: 
183: 	if (scalar_function.name.empty() || !info.function) {
184: 		return DuckDBError;
185: 	}
186: 	if (duckdb::TypeVisitor::Contains(scalar_function.return_type, duckdb::LogicalTypeId::INVALID) ||
187: 	    duckdb::TypeVisitor::Contains(scalar_function.return_type, duckdb::LogicalTypeId::ANY)) {
188: 		return DuckDBError;
189: 	}
190: 	for (const auto &argument : scalar_function.arguments) {
191: 		if (duckdb::TypeVisitor::Contains(argument, duckdb::LogicalTypeId::INVALID)) {
192: 			return DuckDBError;
193: 		}
194: 	}
195: 
196: 	try {
197: 		auto con = reinterpret_cast<duckdb::Connection *>(connection);
198: 		con->context->RunFunctionInTransaction([&]() {
199: 			auto &catalog = duckdb::Catalog::GetSystemCatalog(*con->context);
200: 			duckdb::CreateScalarFunctionInfo sf_info(scalar_function);
201: 			catalog.CreateFunction(*con->context, sf_info);
202: 		});
203: 	} catch (...) {
204: 		return DuckDBError;
205: 	}
206: 	return DuckDBSuccess;
207: }
[end of src/main/capi/scalar_function-c.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: