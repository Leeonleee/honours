{
  "repo": "duckdb/duckdb",
  "pull_number": 4266,
  "instance_id": "duckdb__duckdb-4266",
  "issue_numbers": [
    "3718",
    "3704"
  ],
  "base_commit": "a1892a1d0767e8078acd1521919cfc991303cf50",
  "patch": "diff --git a/tools/rpkg/NAMESPACE b/tools/rpkg/NAMESPACE\nindex fd12acf88a9f..c2da22dc1c2e 100644\n--- a/tools/rpkg/NAMESPACE\n+++ b/tools/rpkg/NAMESPACE\n@@ -61,6 +61,7 @@ exportMethods(dbHasCompleted)\n exportMethods(dbIsValid)\n exportMethods(dbListFields)\n exportMethods(dbListTables)\n+exportMethods(dbQuoteIdentifier)\n exportMethods(dbQuoteLiteral)\n exportMethods(dbRemoveTable)\n exportMethods(dbRollback)\ndiff --git a/tools/rpkg/R/Connection.R b/tools/rpkg/R/Connection.R\nindex 758c983e23a3..43793886791d 100644\n--- a/tools/rpkg/R/Connection.R\n+++ b/tools/rpkg/R/Connection.R\n@@ -21,12 +21,13 @@ setClass(\"duckdb_connection\",\n     driver = \"duckdb_driver\",\n     debug = \"logical\",\n     timezone_out = \"character\",\n-    tz_out_convert = \"character\"\n+    tz_out_convert = \"character\",\n+    reserved_words = \"character\"\n   )\n )\n \n duckdb_connection <- function(duckdb_driver, debug) {\n-  new(\n+  out <- new(\n     \"duckdb_connection\",\n     conn_ref = rapi_connect(duckdb_driver@database_ref),\n     driver = duckdb_driver,\n@@ -34,6 +35,8 @@ duckdb_connection <- function(duckdb_driver, debug) {\n     timezone_out = \"UTC\",\n     tz_out_convert = \"with\"\n   )\n+  out@reserved_words <- get_reserved_words(out)\n+  out\n }\n \n duckdb_random_string <- function(x) {\ndiff --git a/tools/rpkg/R/dbQuoteIdentifier__duckdb_connection.R b/tools/rpkg/R/dbQuoteIdentifier__duckdb_connection.R\nnew file mode 100644\nindex 000000000000..68a23cbba50a\n--- /dev/null\n+++ b/tools/rpkg/R/dbQuoteIdentifier__duckdb_connection.R\n@@ -0,0 +1,48 @@\n+dbQuoteIdentifier__duckdb_connection <- function(conn, x, ...) {\n+  if (is(x, \"SQL\")) {\n+    return(x)\n+  }\n+  if (is(x, \"Id\")) {\n+    return(SQL(paste0(dbQuoteIdentifier(conn, x@name), collapse = \".\")))\n+  }\n+\n+  if (any(is.na(x))) {\n+    stop(\"Cannot pass NA to dbQuoteIdentifier()\")\n+  }\n+\n+  x <- enc2utf8(x)\n+  needs_escape <- !grepl(\"^[a-zA-Z0-9_]+$\", x) | tolower(x) %in% reserved_words(conn)\n+  x[needs_escape] <- paste0('\"', gsub('\"', '\"\"', x[needs_escape]), '\"')\n+\n+  SQL(x, names = names(x))\n+}\n+\n+#' @rdname duckdb_connection-class\n+#' @export\n+setMethod(\"dbQuoteIdentifier\", signature(\"duckdb_connection\"), dbQuoteIdentifier__duckdb_connection)\n+#' @rdname duckdb_connection-class\n+#' @usage NULL\n+setMethod(\"dbQuoteIdentifier\", signature(\"duckdb_connection\", \"character\"), dbQuoteIdentifier__duckdb_connection)\n+#' @rdname duckdb_connection-class\n+#' @usage NULL\n+setMethod(\"dbQuoteIdentifier\", signature(\"duckdb_connection\", \"SQL\"), dbQuoteIdentifier__duckdb_connection)\n+#' @rdname duckdb_connection-class\n+#' @usage NULL\n+setMethod(\"dbQuoteIdentifier\", signature(\"duckdb_connection\", \"Id\"), dbQuoteIdentifier__duckdb_connection)\n+\n+reserved_words <- function(con) {\n+  if (!isS4(con)) {\n+    con <- dbConnect(duckdb())\n+    on.exit(dbDisconnect(con, shutdown = TRUE))\n+    return(get_reserved_words(con))\n+  }\n+\n+  con@reserved_words\n+}\n+\n+get_reserved_words <- function(con) {\n+  rs <- dbSendQuery__duckdb_connection_character(con, \"SELECT * FROM duckdb_keywords()\")\n+  on.exit(dbClearResult__duckdb_result(rs))\n+\n+  dbFetch__duckdb_result(rs)[[1]]\n+}\ndiff --git a/tools/rpkg/R/zzz.R b/tools/rpkg/R/zzz.R\nindex 02c28dc51f61..f5cc61e8a344 100644\n--- a/tools/rpkg/R/zzz.R\n+++ b/tools/rpkg/R/zzz.R\n@@ -7,4 +7,6 @@\n   s3_register(\"dbplyr::sql_escape_date\", \"duckdb_connection\")\n   s3_register(\"dbplyr::sql_escape_datetime\", \"duckdb_connection\")\n   s3_register(\"dplyr::tbl\", \"duckdb_connection\")\n-}\n\\ No newline at end of file\n+\n+  invisible()\n+}\ndiff --git a/tools/rpkg/man/duckdb_connection-class.Rd b/tools/rpkg/man/duckdb_connection-class.Rd\nindex 18d38889ad8b..7ef0b0b33d76 100644\n--- a/tools/rpkg/man/duckdb_connection-class.Rd\n+++ b/tools/rpkg/man/duckdb_connection-class.Rd\n@@ -5,7 +5,9 @@\n %   R/dbExistsTable__duckdb_connection_character.R,\n %   R/dbGetInfo__duckdb_connection.R, R/dbIsValid__duckdb_connection.R,\n %   R/dbListFields__duckdb_connection_character.R,\n-%   R/dbListTables__duckdb_connection.R, R/dbQuoteLiteral__duckdb_connection.R,\n+%   R/dbListTables__duckdb_connection.R,\n+%   R/dbQuoteIdentifier__duckdb_connection.R,\n+%   R/dbQuoteLiteral__duckdb_connection.R,\n %   R/dbRemoveTable__duckdb_connection_character.R,\n %   R/dbRollback__duckdb_connection.R,\n %   R/dbSendQuery__duckdb_connection_character.R,\n@@ -33,6 +35,10 @@\n \\alias{dbListFields,duckdb_connection,character-method}\n \\alias{dbListTables__duckdb_connection}\n \\alias{dbListTables,duckdb_connection-method}\n+\\alias{dbQuoteIdentifier,duckdb_connection,ANY-method}\n+\\alias{dbQuoteIdentifier,duckdb_connection,character-method}\n+\\alias{dbQuoteIdentifier,duckdb_connection,SQL-method}\n+\\alias{dbQuoteIdentifier,duckdb_connection,Id-method}\n \\alias{dbQuoteLiteral__duckdb_connection}\n \\alias{dbQuoteLiteral,duckdb_connection-method}\n \\alias{dbRemoveTable__duckdb_connection_character}\n@@ -65,6 +71,8 @@\n \n \\S4method{dbListTables}{duckdb_connection}(conn, ...)\n \n+\\S4method{dbQuoteIdentifier}{duckdb_connection,ANY}(conn, x, ...)\n+\n \\S4method{dbQuoteLiteral}{duckdb_connection}(conn, x, ...)\n \n \\S4method{dbRemoveTable}{duckdb_connection,character}(conn, name, ..., fail_if_missing = TRUE)\n",
  "test_patch": "diff --git a/tools/rpkg/tests/testthat/_snaps/backend-dbplyr__duckdb_connection.md b/tools/rpkg/tests/testthat/_snaps/backend-dbplyr__duckdb_connection.md\nindex 5aefbfe2ce20..54a30467122c 100644\n--- a/tools/rpkg/tests/testthat/_snaps/backend-dbplyr__duckdb_connection.md\n+++ b/tools/rpkg/tests/testthat/_snaps/backend-dbplyr__duckdb_connection.md\n@@ -55,15 +55,15 @@\n     Code\n       translate(iris[[\"sepal_length\"]])\n     Output\n-      <SQL> \"iris\".\"sepal_length\"\n+      <SQL> iris.sepal_length\n     Code\n       translate(iris[[1]])\n     Output\n-      <SQL> \"iris\"[1]\n+      <SQL> iris[1]\n     Code\n       translate(cot(x))\n     Output\n-      <SQL> COT(\"x\")\n+      <SQL> COT(x)\n     Code\n       translate(substr(\"test\", 2, 3))\n     Output\n@@ -90,63 +90,63 @@\n     Code\n       translate(bitwOr(x, 128L))\n     Output\n-      <SQL> (CAST(\"x\" AS INTEGER)) | (CAST(128 AS INTEGER))\n+      <SQL> (CAST(x AS INTEGER)) | (CAST(128 AS INTEGER))\n     Code\n       translate(bitwAnd(x, 128))\n     Output\n-      <SQL> (CAST(\"x\" AS INTEGER)) & (CAST(128.0 AS INTEGER))\n+      <SQL> (CAST(x AS INTEGER)) & (CAST(128.0 AS INTEGER))\n     Code\n       translate(bitwXor(x, 128L))\n     Output\n-      <SQL> XOR((CAST(\"x\" AS INTEGER)), (CAST(128 AS INTEGER)))\n+      <SQL> XOR((CAST(x AS INTEGER)), (CAST(128 AS INTEGER)))\n     Code\n       translate(bitwNot(x))\n     Output\n-      <SQL> ~(CAST(\"x\" AS INTEGER))\n+      <SQL> ~(CAST(x AS INTEGER))\n     Code\n       translate(bitwShiftL(x, 5L))\n     Output\n-      <SQL> (CAST(\"x\" AS INTEGER)) << (CAST(5 AS INTEGER))\n+      <SQL> (CAST(x AS INTEGER)) << (CAST(5 AS INTEGER))\n     Code\n       translate(bitwShiftR(x, 4L))\n     Output\n-      <SQL> (CAST(\"x\" AS INTEGER)) >> (CAST(4 AS INTEGER))\n+      <SQL> (CAST(x AS INTEGER)) >> (CAST(4 AS INTEGER))\n     Code\n       translate(log(x))\n     Output\n-      <SQL> LN(\"x\")\n+      <SQL> LN(x)\n     Code\n       translate(log(x, base = 5))\n     Output\n-      <SQL> LOG(\"x\") / LOG(5.0)\n+      <SQL> LOG(x) / LOG(5.0)\n     Code\n       translate(log(x, base = 10))\n     Output\n-      <SQL> LOG10(\"x\")\n+      <SQL> LOG10(x)\n     Code\n       translate(log(x, base = 2))\n     Output\n-      <SQL> LOG2(\"x\")\n+      <SQL> LOG2(x)\n     Code\n       translate(log10(x))\n     Output\n-      <SQL> LOG10(\"x\")\n+      <SQL> LOG10(x)\n     Code\n       translate(log2(x))\n     Output\n-      <SQL> LOG2(\"x\")\n+      <SQL> LOG2(x)\n     Code\n       translate(is.nan(var1))\n     Output\n-      <SQL> (\"var1\" IS NOT NULL AND PRINTF('%f', \"var1\") = 'nan')\n+      <SQL> (var1 IS NOT NULL AND PRINTF('%f', var1) = 'nan')\n     Code\n       translate(is.infinite(var1))\n     Output\n-      <SQL> (\"var1\" IS NOT NULL AND REGEXP_MATCHES(PRINTF('%f', \"var1\"), 'inf'))\n+      <SQL> (var1 IS NOT NULL AND REGEXP_MATCHES(PRINTF('%f', var1), 'inf'))\n     Code\n       translate(is.finite(var1))\n     Output\n-      <SQL> (NOT (\"var1\" IS NULL OR REGEXP_MATCHES(PRINTF('%f', \"var1\"), 'inf|nan')))\n+      <SQL> (NOT (var1 IS NULL OR REGEXP_MATCHES(PRINTF('%f', var1), 'inf|nan')))\n     Code\n       translate(grepl(\"pattern\", text))\n     Output\n@@ -162,7 +162,7 @@\n     Code\n       translate(round(x, digits = 1.1))\n     Output\n-      <SQL> ROUND(\"x\", CAST(ROUND(1.1, 0) AS INTEGER))\n+      <SQL> ROUND(x, CAST(ROUND(1.1, 0) AS INTEGER))\n     Code\n       translate(as.Date(\"2019-01-01\"))\n     Output\n@@ -189,185 +189,185 @@\n     Code\n       translate(paste(x, y), window = FALSE)\n     Output\n-      <SQL> CONCAT_WS(' ', \"x\", \"y\")\n+      <SQL> CONCAT_WS(' ', x, y)\n     Code\n       translate(paste0(x, y), window = FALSE)\n     Output\n-      <SQL> CONCAT_WS('', \"x\", \"y\")\n+      <SQL> CONCAT_WS('', x, y)\n \n # snapshots for custom lubridate functions translated correctly\n \n     Code\n       translate(yday(x))\n     Output\n-      <SQL> EXTRACT(DOY FROM \"x\")\n+      <SQL> EXTRACT(DOY FROM x)\n     Code\n       translate(quarter(x))\n     Output\n-      <SQL> EXTRACT(QUARTER FROM \"x\")\n+      <SQL> EXTRACT(QUARTER FROM x)\n     Code\n       translate(quarter(x))\n     Output\n-      <SQL> EXTRACT(QUARTER FROM \"x\")\n+      <SQL> EXTRACT(QUARTER FROM x)\n     Code\n       translate(quarter(x, type = \"year.quarter\"))\n     Output\n-      <SQL> (EXTRACT(YEAR FROM \"x\") || '.' || EXTRACT(QUARTER FROM \"x\"))\n+      <SQL> (EXTRACT(YEAR FROM x) || '.' || EXTRACT(QUARTER FROM x))\n     Code\n       translate(quarter(x, type = \"quarter\"))\n     Output\n-      <SQL> EXTRACT(QUARTER FROM \"x\")\n+      <SQL> EXTRACT(QUARTER FROM x)\n     Code\n       translate(quarter(x, type = TRUE))\n     Output\n-      <SQL> (EXTRACT(YEAR FROM \"x\") || '.' || EXTRACT(QUARTER FROM \"x\"))\n+      <SQL> (EXTRACT(YEAR FROM x) || '.' || EXTRACT(QUARTER FROM x))\n     Code\n       translate(quarter(x, type = FALSE))\n     Output\n-      <SQL> EXTRACT(QUARTER FROM \"x\")\n+      <SQL> EXTRACT(QUARTER FROM x)\n     Code\n       translate(quarter(x, type = \"date_first\"))\n     Output\n-      <SQL> (CAST(DATE_TRUNC('QUARTER', \"x\") AS DATE))\n+      <SQL> (CAST(DATE_TRUNC('QUARTER', x) AS DATE))\n     Code\n       translate(quarter(x, type = \"date_last\"))\n     Output\n-      <SQL> (CAST((DATE_TRUNC('QUARTER', \"x\") + INTERVAL '1 QUARTER' - INTERVAL '1 DAY') AS DATE))\n+      <SQL> (CAST((DATE_TRUNC('QUARTER', x) + INTERVAL '1 QUARTER' - INTERVAL '1 DAY') AS DATE))\n     Code\n       translate(month(x, label = FALSE))\n     Output\n-      <SQL> EXTRACT(MONTH FROM \"x\")\n+      <SQL> EXTRACT(MONTH FROM x)\n     Code\n       translate(month(x, label = TRUE))\n     Output\n-      <SQL> STRFTIME(\"x\", '%b')\n+      <SQL> STRFTIME(x, '%b')\n     Code\n       translate(month(x, label = TRUE, abbr = FALSE))\n     Output\n-      <SQL> STRFTIME(\"x\", '%B')\n+      <SQL> STRFTIME(x, '%B')\n     Code\n       translate(qday(x))\n     Output\n-      <SQL> DATE_DIFF('DAYS', DATE_TRUNC('QUARTER', CAST((\"x\") AS DATE)), (CAST((\"x\") AS DATE) + INTERVAL '1 DAY'))\n+      <SQL> DATE_DIFF('DAYS', DATE_TRUNC('QUARTER', CAST((x) AS DATE)), (CAST((x) AS DATE) + INTERVAL '1 DAY'))\n     Code\n       translate(wday(x))\n     Output\n-      <SQL> EXTRACT('dow' FROM CAST(\"x\" AS DATE) + 0) + 1\n+      <SQL> EXTRACT('dow' FROM CAST(x AS DATE) + 0) + 1\n     Code\n       translate(wday(x, week_start = 4))\n     Output\n-      <SQL> EXTRACT('dow' FROM CAST(\"x\" AS DATE) + 3) + 1\n+      <SQL> EXTRACT('dow' FROM CAST(x AS DATE) + 3) + 1\n     Code\n       translate(wday(x, label = TRUE))\n     Output\n-      <SQL> STRFTIME(\"x\", '%a')\n+      <SQL> STRFTIME(x, '%a')\n     Code\n       translate(wday(x, label = TRUE, abbr = FALSE))\n     Output\n-      <SQL> STRFTIME(\"x\", '%A')\n+      <SQL> STRFTIME(x, '%A')\n     Code\n       translate(seconds(x))\n     Output\n-      <SQL> TO_SECONDS(CAST(\"x\" AS BIGINT))\n+      <SQL> TO_SECONDS(CAST(x AS BIGINT))\n     Code\n       translate(minutes(x))\n     Output\n-      <SQL> TO_MINUTES(CAST(\"x\" AS BIGINT))\n+      <SQL> TO_MINUTES(CAST(x AS BIGINT))\n     Code\n       translate(hours(x))\n     Output\n-      <SQL> TO_HOURS(CAST(\"x\" AS BIGINT))\n+      <SQL> TO_HOURS(CAST(x AS BIGINT))\n     Code\n       translate(days(x))\n     Output\n-      <SQL> TO_DAYS(CAST(\"x\" AS INTEGER))\n+      <SQL> TO_DAYS(CAST(x AS INTEGER))\n     Code\n       translate(weeks(x))\n     Output\n-      <SQL> TO_DAYS(7 * CAST(\"x\" AS INTEGER))\n+      <SQL> TO_DAYS(7 * CAST(x AS INTEGER))\n     Code\n       translate(months(x))\n     Output\n-      <SQL> TO_MONTHS(CAST(\"x\" AS INTEGER))\n+      <SQL> TO_MONTHS(CAST(x AS INTEGER))\n     Code\n       translate(years(x))\n     Output\n-      <SQL> TO_YEARS(CAST(\"x\" AS INTEGER))\n+      <SQL> TO_YEARS(CAST(x AS INTEGER))\n     Code\n       translate(floor_date(x, \"month\"))\n     Output\n-      <SQL> DATE_TRUNC('month', \"x\")\n+      <SQL> DATE_TRUNC('month', x)\n     Code\n       translate(floor_date(x, \"week\"))\n     Output\n-      <SQL> CAST(\"x\" AS DATE) - CAST(EXTRACT('dow' FROM CAST(\"x\" AS DATE) + 0) AS INTEGER)\n+      <SQL> CAST(x AS DATE) - CAST(EXTRACT('dow' FROM CAST(x AS DATE) + 0) AS INTEGER)\n     Code\n       translate(floor_date(x, \"week\", week_start = 1))\n     Output\n-      <SQL> DATE_TRUNC('week', \"x\")\n+      <SQL> DATE_TRUNC('week', x)\n     Code\n       translate(floor_date(x, \"week\", week_start = 4))\n     Output\n-      <SQL> CAST(\"x\" AS DATE) - CAST(EXTRACT('dow' FROM CAST(\"x\" AS DATE) + 3) AS INTEGER)\n+      <SQL> CAST(x AS DATE) - CAST(EXTRACT('dow' FROM CAST(x AS DATE) + 3) AS INTEGER)\n \n # snapshots for custom stringr functions translated correctly\n \n     Code\n       translate(str_c(x, y))\n     Output\n-      <SQL> CONCAT_WS('', \"x\", \"y\")\n+      <SQL> CONCAT_WS('', x, y)\n     Code\n       translate(str_detect(x, y))\n     Output\n-      <SQL> REGEXP_MATCHES(\"x\", \"y\")\n+      <SQL> REGEXP_MATCHES(x, y)\n     Code\n       translate(str_detect(x, y, negate = TRUE))\n     Output\n-      <SQL> (NOT(REGEXP_MATCHES(\"x\", \"y\")))\n+      <SQL> (NOT(REGEXP_MATCHES(x, y)))\n     Code\n       translate(str_replace(x, y, z))\n     Output\n-      <SQL> REGEXP_REPLACE(\"x\", \"y\", \"z\")\n+      <SQL> REGEXP_REPLACE(x, y, z)\n     Code\n       translate(str_replace_all(x, y, z))\n     Output\n-      <SQL> REGEXP_REPLACE(\"x\", \"y\", \"z\", 'g')\n+      <SQL> REGEXP_REPLACE(x, y, z, 'g')\n     Code\n       translate(str_squish(x))\n     Output\n-      <SQL> TRIM(REGEXP_REPLACE(\"x\", '\\s+', ' ', 'g'))\n+      <SQL> TRIM(REGEXP_REPLACE(x, '\\s+', ' ', 'g'))\n     Code\n       translate(str_remove(x, y))\n     Output\n-      <SQL> REGEXP_REPLACE(\"x\", \"y\", '')\n+      <SQL> REGEXP_REPLACE(x, y, '')\n     Code\n       translate(str_remove_all(x, y))\n     Output\n-      <SQL> REGEXP_REPLACE(\"x\", \"y\", '', 'g')\n+      <SQL> REGEXP_REPLACE(x, y, '', 'g')\n     Code\n       translate(str_to_sentence(x))\n     Output\n-      <SQL> (UPPER(\"x\"[0]) || \"x\"[1:NULL])\n+      <SQL> (UPPER(x[0]) || x[1:NULL])\n     Code\n       translate(str_starts(x, y))\n     Output\n-      <SQL> REGEXP_MATCHES(\"x\",'^(?:'||\"y\"))\n+      <SQL> REGEXP_MATCHES(x,'^(?:'||y))\n     Code\n       translate(str_ends(x, y))\n     Output\n-      <SQL> REGEXP_MATCHES((?:\"x\",\"y\"||')$')\n+      <SQL> REGEXP_MATCHES((?:x,y||')$')\n     Code\n       translate(str_pad(x, width = 10))\n     Output\n-      <SQL> LPAD(\"x\", CAST(GREATEST(10, LENGTH(\"x\")) AS INTEGER), ' ')\n+      <SQL> LPAD(x, CAST(GREATEST(10, LENGTH(x)) AS INTEGER), ' ')\n     Code\n       translate(str_pad(x, width = 10, side = \"right\"))\n     Output\n-      <SQL> RPAD(\"x\", CAST(GREATEST(10, LENGTH(\"x\")) AS INTEGER), ' ')\n+      <SQL> RPAD(x, CAST(GREATEST(10, LENGTH(x)) AS INTEGER), ' ')\n     Code\n       translate(str_pad(x, width = 10, side = \"both\", pad = \"<\"))\n     Output\n-      <SQL> RPAD(REPEAT('<', (10 - LENGTH(\"x\")) / 2) || \"x\", CAST(GREATEST(10, LENGTH(\"x\")) AS INTEGER), '<')\n+      <SQL> RPAD(REPEAT('<', (10 - LENGTH(x)) / 2) || x, CAST(GREATEST(10, LENGTH(x)) AS INTEGER), '<')\n \n # snapshots datetime escaping working as in DBI\n \n@@ -404,11 +404,11 @@\n     Code\n       translate(cor(x, y), window = FALSE)\n     Output\n-      <SQL> CORR(\"x\", \"y\")\n+      <SQL> CORR(x, y)\n     Code\n       translate(cor(x, y), window = TRUE)\n     Output\n-      <SQL> CORR(\"x\", \"y\") OVER ()\n+      <SQL> CORR(x, y) OVER ()\n \n # these should give errors\n \ndiff --git a/tools/rpkg/tests/testthat/test-dbQuoteIdentifier__duckdb_connection.R b/tools/rpkg/tests/testthat/test-dbQuoteIdentifier__duckdb_connection.R\nnew file mode 100644\nindex 000000000000..c5bd90be4ff1\n--- /dev/null\n+++ b/tools/rpkg/tests/testthat/test-dbQuoteIdentifier__duckdb_connection.R\n@@ -0,0 +1,27 @@\n+test_that(\"only quotes where needed\", {\n+  con <- dbConnect(duckdb())\n+  on.exit(dbDisconnect(con, shutdown = TRUE))\n+\n+  expect_equal(\n+    dbQuoteIdentifier(con, c(\"x y\", \"select\", \"SELECT\", \"x\")),\n+    SQL(c('\"x y\"', '\"select\"', '\"SELECT\"', \"x\"))\n+  )\n+})\n+\n+test_that(\"preserves expected DBI behaviour\", {\n+  con <- dbConnect(duckdb())\n+  on.exit(dbDisconnect(con, shutdown = TRUE))\n+\n+  expect_equal(dbQuoteIdentifier(con, SQL(\"SELECT\")), SQL(\"SELECT\"))\n+  expect_equal(dbQuoteIdentifier(con, character()), SQL(character()))\n+  expect_equal(dbQuoteIdentifier(con, c(a = \"a\")), SQL(\"a\", names = \"a\"))\n+\n+  expect_equal(\n+    dbQuoteIdentifier(con, Id(schema = \"a\", table = \"b\")),\n+    SQL(\"a.b\")\n+  )\n+  expect_equal(\n+    dbQuoteIdentifier(con, Id(schema = \"SELECT\", table = \"b\")),\n+    SQL('\"SELECT\".b')\n+  )\n+})\ndiff --git a/tools/rpkg/tests/testthat/test_backend-dbplyr__duckdb_connection.R b/tools/rpkg/tests/testthat/test_backend-dbplyr__duckdb_connection.R\nindex ab11b04fc56f..231cfbe9af05 100644\n--- a/tools/rpkg/tests/testthat/test_backend-dbplyr__duckdb_connection.R\n+++ b/tools/rpkg/tests/testthat/test_backend-dbplyr__duckdb_connection.R\n@@ -23,9 +23,9 @@ test_that(\"dbplyr generic scalars translated correctly\", {\n   expect_equal(translate(pmin(1, 2, na.rm = TRUE)), sql(r\"{LEAST(1.0, 2.0)}\"))\n   expect_equal(translate(as.character(\"2020-01-01\")), sql(r\"{CAST('2020-01-01' AS TEXT)}\"))\n   expect_equal(translate(c(\"2020-01-01\", \"2020-13-02\")), sql(r\"{('2020-01-01', '2020-13-02')}\"))\n-  expect_equal(translate(iris[[\"sepal_length\"]]), sql(r\"{\"iris\".\"sepal_length\"}\"))\n-  expect_equal(translate(iris[[1]]), sql(r\"{\"iris\"[1]}\"))\n-  expect_equal(translate(cot(x)), sql(r\"{COT(\"x\")}\"))\n+  expect_equal(translate(iris[[\"sepal_length\"]]), sql(r\"{iris.sepal_length}\"))\n+  expect_equal(translate(iris[[1]]), sql(r\"{iris[1]}\"))\n+  expect_equal(translate(cot(x)), sql(r\"{COT(x)}\"))\n   expect_equal(translate(substr(\"test\", 2, 3)), sql(r\"{SUBSTR('test', 2, 2)}\"))\n })\n \n@@ -40,26 +40,26 @@ test_that(\"duckdb custom scalars translated correctly\", {\n   expect_equal(translate(13 %% 5), sql(r\"{FMOD(13.0, 5.0)}\"))\n   expect_equal(translate(35.8 %/% 4), sql(r\"{FDIV(35.8, 4.0)}\"))\n   expect_equal(translate(35.8^2.51), sql(r\"{POW(35.8, 2.51)}\"))\n-  expect_equal(translate(bitwOr(x, 128L)), sql(r\"{(CAST(\"x\" AS INTEGER)) | (CAST(128 AS INTEGER))}\"))\n-  expect_equal(translate(bitwAnd(x, 128)), sql(r\"{(CAST(\"x\" AS INTEGER)) & (CAST(128.0 AS INTEGER))}\"))\n-  expect_equal(translate(bitwXor(x, 128L)), sql(r\"{XOR((CAST(\"x\" AS INTEGER)), (CAST(128 AS INTEGER)))}\"))\n-  expect_equal(translate(bitwNot(x)), sql(r\"{~(CAST(\"x\" AS INTEGER))}\"))\n-  expect_equal(translate(bitwShiftL(x, 5L)), sql(r\"{(CAST(\"x\" AS INTEGER)) << (CAST(5 AS INTEGER))}\"))\n-  expect_equal(translate(bitwShiftR(x, 4L)), sql(r\"{(CAST(\"x\" AS INTEGER)) >> (CAST(4 AS INTEGER))}\"))\n-  expect_equal(translate(log(x)), sql(r\"{LN(\"x\")}\"))\n-  expect_equal(translate(log(x, base = 5)), sql(r\"{LOG(\"x\") / LOG(5.0)}\"))\n-  expect_equal(translate(log(x, base = 10)), sql(r\"{LOG10(\"x\")}\"))\n-  expect_equal(translate(log(x, base = 2)), sql(r\"{LOG2(\"x\")}\"))\n-  expect_equal(translate(log10(x)), sql(r\"{LOG10(\"x\")}\"))\n-  expect_equal(translate(log2(x)), sql(r\"{LOG2(\"x\")}\"))\n-  expect_equal(translate(is.nan(var1)), sql(r\"{(\"var1\" IS NOT NULL AND PRINTF('%f', \"var1\") = 'nan')}\"))\n-  expect_equal(translate(is.infinite(var1)), sql(r\"{(\"var1\" IS NOT NULL AND REGEXP_MATCHES(PRINTF('%f', \"var1\"), 'inf'))}\"))\n-  expect_equal(translate(is.finite(var1)), sql(r\"{(NOT (\"var1\" IS NULL OR REGEXP_MATCHES(PRINTF('%f', \"var1\"), 'inf|nan')))}\"))\n+  expect_equal(translate(bitwOr(x, 128L)), sql(r\"{(CAST(x AS INTEGER)) | (CAST(128 AS INTEGER))}\"))\n+  expect_equal(translate(bitwAnd(x, 128)), sql(r\"{(CAST(x AS INTEGER)) & (CAST(128.0 AS INTEGER))}\"))\n+  expect_equal(translate(bitwXor(x, 128L)), sql(r\"{XOR((CAST(x AS INTEGER)), (CAST(128 AS INTEGER)))}\"))\n+  expect_equal(translate(bitwNot(x)), sql(r\"{~(CAST(x AS INTEGER))}\"))\n+  expect_equal(translate(bitwShiftL(x, 5L)), sql(r\"{(CAST(x AS INTEGER)) << (CAST(5 AS INTEGER))}\"))\n+  expect_equal(translate(bitwShiftR(x, 4L)), sql(r\"{(CAST(x AS INTEGER)) >> (CAST(4 AS INTEGER))}\"))\n+  expect_equal(translate(log(x)), sql(r\"{LN(x)}\"))\n+  expect_equal(translate(log(x, base = 5)), sql(r\"{LOG(x) / LOG(5.0)}\"))\n+  expect_equal(translate(log(x, base = 10)), sql(r\"{LOG10(x)}\"))\n+  expect_equal(translate(log(x, base = 2)), sql(r\"{LOG2(x)}\"))\n+  expect_equal(translate(log10(x)), sql(r\"{LOG10(x)}\"))\n+  expect_equal(translate(log2(x)), sql(r\"{LOG2(x)}\"))\n+  expect_equal(translate(is.nan(var1)), sql(r\"{(var1 IS NOT NULL AND PRINTF('%f', var1) = 'nan')}\"))\n+  expect_equal(translate(is.infinite(var1)), sql(r\"{(var1 IS NOT NULL AND REGEXP_MATCHES(PRINTF('%f', var1), 'inf'))}\"))\n+  expect_equal(translate(is.finite(var1)), sql(r\"{(NOT (var1 IS NULL OR REGEXP_MATCHES(PRINTF('%f', var1), 'inf|nan')))}\"))\n   expect_equal(translate(grepl(\"pattern\", text)), sql(r\"{REGEXP_MATCHES(\"text\", 'pattern')}\"))\n   expect_equal(translate(grepl(\"pattern\", text, ignore.case = TRUE)), sql(r\"{REGEXP_MATCHES(\"text\", '(?i)pattern')}\"))\n   expect_error(translate(grepl(\"dummy\", txt, perl = TRUE)))\n   expect_equal(translate(regexpr(\"pattern\", text)), sql(r\"{(CASE WHEN REGEXP_MATCHES(\"text\", 'pattern') THEN (LENGTH(LIST_EXTRACT(STRING_SPLIT_REGEX(\"text\", 'pattern'), 0))+1) ELSE -1 END)}\"))\n-  expect_equal(translate(round(x, digits = 1.1)), sql(r\"{ROUND(\"x\", CAST(ROUND(1.1, 0) AS INTEGER))}\"))\n+  expect_equal(translate(round(x, digits = 1.1)), sql(r\"{ROUND(x, CAST(ROUND(1.1, 0) AS INTEGER))}\"))\n   expect_equal(translate(as.Date(\"2019-01-01\")), sql(r\"{CAST('2019-01-01' AS DATE)}\"))\n   expect_equal(translate(as.POSIXct(\"2019-01-01 01:01:01\")), sql(r\"{CAST('2019-01-01 01:01:01' AS TIMESTAMP)}\"))\n })\n@@ -76,8 +76,8 @@ test_that(\"pasting translated correctly\", {\n   expect_equal(translate(paste(\"hi\", \"bye\", sep = \"-\")), sql(r\"{CONCAT_WS('-', 'hi', 'bye')}\"))\n   expect_equal(translate(paste0(\"hi\", \"bye\")), sql(r\"{CONCAT_WS('', 'hi', 'bye')}\"))\n \n-  expect_equal(translate(paste(x, y), window = FALSE), sql(r\"{CONCAT_WS(' ', \"x\", \"y\")}\"))\n-  expect_equal(translate(paste0(x, y), window = FALSE), sql(r\"{CONCAT_WS('', \"x\", \"y\")}\"))\n+  expect_equal(translate(paste(x, y), window = FALSE), sql(r\"{CONCAT_WS(' ', x, y)}\"))\n+  expect_equal(translate(paste0(x, y), window = FALSE), sql(r\"{CONCAT_WS('', x, y)}\"))\n \n #   expect_error(translate(paste0(x, collapse = \"\"), window = FALSE), \"`collapse` not supported\")\n })\n@@ -91,36 +91,36 @@ test_that(\"custom lubridate functions translated correctly\", {\n   translate <- function(...) dbplyr::translate_sql(..., con = duckdb::translate_duckdb())\n   sql <- function(...) dbplyr::sql(...)\n \n-  expect_equal(translate(yday(x)), sql(r\"{EXTRACT(DOY FROM \"x\")}\"))\n-  expect_equal(translate(quarter(x)), sql(r\"{EXTRACT(QUARTER FROM \"x\")}\"))\n-  expect_equal(translate(quarter(x, with_year = TRUE)), sql(r\"{(EXTRACT(YEAR FROM \"x\") || '.' || EXTRACT(QUARTER FROM \"x\"))}\"))\n-  expect_equal(translate(quarter(x, type = \"year.quarter\")), sql(r\"{(EXTRACT(YEAR FROM \"x\") || '.' || EXTRACT(QUARTER FROM \"x\"))}\"))\n-  expect_equal(translate(quarter(x, type = \"quarter\")), sql(r\"{EXTRACT(QUARTER FROM \"x\")}\"))\n-  expect_equal(translate(quarter(x, type = TRUE)), sql(r\"{(EXTRACT(YEAR FROM \"x\") || '.' || EXTRACT(QUARTER FROM \"x\"))}\"))\n-  expect_equal(translate(quarter(x, type = FALSE)), sql(r\"{EXTRACT(QUARTER FROM \"x\")}\"))\n-  expect_equal(translate(quarter(x, type = \"date_first\")), sql(r\"{(CAST(DATE_TRUNC('QUARTER', \"x\") AS DATE))}\"))\n-  expect_equal(translate(quarter(x, type = \"date_last\")), sql(r\"{(CAST((DATE_TRUNC('QUARTER', \"x\") + INTERVAL '1 QUARTER' - INTERVAL '1 DAY') AS DATE))}\"))\n+  expect_equal(translate(yday(x)), sql(r\"{EXTRACT(DOY FROM x)}\"))\n+  expect_equal(translate(quarter(x)), sql(r\"{EXTRACT(QUARTER FROM x)}\"))\n+  expect_equal(translate(quarter(x, with_year = TRUE)), sql(r\"{(EXTRACT(YEAR FROM x) || '.' || EXTRACT(QUARTER FROM x))}\"))\n+  expect_equal(translate(quarter(x, type = \"year.quarter\")), sql(r\"{(EXTRACT(YEAR FROM x) || '.' || EXTRACT(QUARTER FROM x))}\"))\n+  expect_equal(translate(quarter(x, type = \"quarter\")), sql(r\"{EXTRACT(QUARTER FROM x)}\"))\n+  expect_equal(translate(quarter(x, type = TRUE)), sql(r\"{(EXTRACT(YEAR FROM x) || '.' || EXTRACT(QUARTER FROM x))}\"))\n+  expect_equal(translate(quarter(x, type = FALSE)), sql(r\"{EXTRACT(QUARTER FROM x)}\"))\n+  expect_equal(translate(quarter(x, type = \"date_first\")), sql(r\"{(CAST(DATE_TRUNC('QUARTER', x) AS DATE))}\"))\n+  expect_equal(translate(quarter(x, type = \"date_last\")), sql(r\"{(CAST((DATE_TRUNC('QUARTER', x) + INTERVAL '1 QUARTER' - INTERVAL '1 DAY') AS DATE))}\"))\n   expect_error(translate(quarter(x, type = \"other\")))\n   expect_error(translate(quarter(x, fiscal_start = 2)))\n-  expect_equal(translate(month(x, label = FALSE)), sql(r\"{EXTRACT(MONTH FROM \"x\")}\"))\n-  expect_equal(translate(month(x, label = TRUE)), sql(r\"{STRFTIME(\"x\", '%b')}\"))\n-  expect_equal(translate(month(x, label = TRUE, abbr = FALSE)), sql(r\"{STRFTIME(\"x\", '%B')}\"))\n-  expect_equal(translate(qday(x)), sql(r\"{DATE_DIFF('DAYS', DATE_TRUNC('QUARTER', CAST((\"x\") AS DATE)), (CAST((\"x\") AS DATE) + INTERVAL '1 DAY'))}\"))\n-  expect_equal(translate(wday(x)), sql(r\"{EXTRACT('dow' FROM CAST(\"x\" AS DATE) + 0) + 1}\"))\n-  expect_equal(translate(wday(x, week_start = 4)), sql(r\"{EXTRACT('dow' FROM CAST(\"x\" AS DATE) + 3) + 1}\"))\n-  expect_equal(translate(wday(x, label = TRUE)), sql(r\"{STRFTIME(\"x\", '%a')}\"))\n-  expect_equal(translate(wday(x, label = TRUE, abbr = FALSE)), sql(r\"{STRFTIME(\"x\", '%A')}\"))\n-  expect_equal(translate(seconds(x)), sql(r\"{TO_SECONDS(CAST(\"x\" AS BIGINT))}\"))\n-  expect_equal(translate(minutes(x)), sql(r\"{TO_MINUTES(CAST(\"x\" AS BIGINT))}\"))\n-  expect_equal(translate(hours(x)), sql(r\"{TO_HOURS(CAST(\"x\" AS BIGINT))}\"))\n-  expect_equal(translate(days(x)), sql(r\"{TO_DAYS(CAST(\"x\" AS INTEGER))}\"))\n-  expect_equal(translate(weeks(x)), sql(r\"{TO_DAYS(7 * CAST(\"x\" AS INTEGER))}\"))\n-  expect_equal(translate(months(x)), sql(r\"{TO_MONTHS(CAST(\"x\" AS INTEGER))}\"))\n-  expect_equal(translate(years(x)), sql(r\"{TO_YEARS(CAST(\"x\" AS INTEGER))}\"))\n-  expect_equal(translate(floor_date(x, \"month\")), sql(r\"{DATE_TRUNC('month', \"x\")}\"))\n-  expect_equal(translate(floor_date(x, \"week\")), sql(r\"{CAST(\"x\" AS DATE) - CAST(EXTRACT('dow' FROM CAST(\"x\" AS DATE) + 0) AS INTEGER)}\"))\n-  expect_equal(translate(floor_date(x, \"week\", week_start = 1)), sql(r\"{DATE_TRUNC('week', \"x\")}\"))\n-  expect_equal(translate(floor_date(x, \"week\", week_start = 4)), sql(r\"{CAST(\"x\" AS DATE) - CAST(EXTRACT('dow' FROM CAST(\"x\" AS DATE) + 3) AS INTEGER)}\"))\n+  expect_equal(translate(month(x, label = FALSE)), sql(r\"{EXTRACT(MONTH FROM x)}\"))\n+  expect_equal(translate(month(x, label = TRUE)), sql(r\"{STRFTIME(x, '%b')}\"))\n+  expect_equal(translate(month(x, label = TRUE, abbr = FALSE)), sql(r\"{STRFTIME(x, '%B')}\"))\n+  expect_equal(translate(qday(x)), sql(r\"{DATE_DIFF('DAYS', DATE_TRUNC('QUARTER', CAST((x) AS DATE)), (CAST((x) AS DATE) + INTERVAL '1 DAY'))}\"))\n+  expect_equal(translate(wday(x)), sql(r\"{EXTRACT('dow' FROM CAST(x AS DATE) + 0) + 1}\"))\n+  expect_equal(translate(wday(x, week_start = 4)), sql(r\"{EXTRACT('dow' FROM CAST(x AS DATE) + 3) + 1}\"))\n+  expect_equal(translate(wday(x, label = TRUE)), sql(r\"{STRFTIME(x, '%a')}\"))\n+  expect_equal(translate(wday(x, label = TRUE, abbr = FALSE)), sql(r\"{STRFTIME(x, '%A')}\"))\n+  expect_equal(translate(seconds(x)), sql(r\"{TO_SECONDS(CAST(x AS BIGINT))}\"))\n+  expect_equal(translate(minutes(x)), sql(r\"{TO_MINUTES(CAST(x AS BIGINT))}\"))\n+  expect_equal(translate(hours(x)), sql(r\"{TO_HOURS(CAST(x AS BIGINT))}\"))\n+  expect_equal(translate(days(x)), sql(r\"{TO_DAYS(CAST(x AS INTEGER))}\"))\n+  expect_equal(translate(weeks(x)), sql(r\"{TO_DAYS(7 * CAST(x AS INTEGER))}\"))\n+  expect_equal(translate(months(x)), sql(r\"{TO_MONTHS(CAST(x AS INTEGER))}\"))\n+  expect_equal(translate(years(x)), sql(r\"{TO_YEARS(CAST(x AS INTEGER))}\"))\n+  expect_equal(translate(floor_date(x, \"month\")), sql(r\"{DATE_TRUNC('month', x)}\"))\n+  expect_equal(translate(floor_date(x, \"week\")), sql(r\"{CAST(x AS DATE) - CAST(EXTRACT('dow' FROM CAST(x AS DATE) + 0) AS INTEGER)}\"))\n+  expect_equal(translate(floor_date(x, \"week\", week_start = 1)), sql(r\"{DATE_TRUNC('week', x)}\"))\n+  expect_equal(translate(floor_date(x, \"week\", week_start = 4)), sql(r\"{CAST(x AS DATE) - CAST(EXTRACT('dow' FROM CAST(x AS DATE) + 3) AS INTEGER)}\"))\n })\n \n # stringr functions\n@@ -131,21 +131,21 @@ test_that(\"custom stringr functions translated correctly\", {\n   translate <- function(...) dbplyr::translate_sql(..., con = duckdb::translate_duckdb())\n   sql <- function(...) dbplyr::sql(...)\n \n-  expect_equal(translate(str_c(x, y)), sql(r\"{CONCAT_WS('', \"x\", \"y\")}\"))\n+  expect_equal(translate(str_c(x, y)), sql(r\"{CONCAT_WS('', x, y)}\"))\n #   expect_error(translate(str_c(x, collapse = \"\")), \"`collapse` not supported\")\n-  expect_equal(translate(str_detect(x, y)), sql(r\"{REGEXP_MATCHES(\"x\", \"y\")}\"))\n-  expect_equal(translate(str_detect(x, y, negate = TRUE)), sql(r\"{(NOT(REGEXP_MATCHES(\"x\", \"y\")))}\"))\n-  expect_equal(translate(str_replace(x, y, z)), sql(r\"{REGEXP_REPLACE(\"x\", \"y\", \"z\")}\"))\n-  expect_equal(translate(str_replace_all(x, y, z)), sql(r\"{REGEXP_REPLACE(\"x\", \"y\", \"z\", 'g')}\"))\n-  expect_equal(translate(str_squish(x)), sql(r\"{TRIM(REGEXP_REPLACE(\"x\", '\\s+', ' ', 'g'))}\"))\n-  expect_equal(translate(str_remove(x, y)), sql(r\"{REGEXP_REPLACE(\"x\", \"y\", '')}\"))\n-  expect_equal(translate(str_remove_all(x, y)), sql(r\"{REGEXP_REPLACE(\"x\", \"y\", '', 'g')}\"))\n-  expect_equal(translate(str_to_sentence(x)), sql(r\"{(UPPER(\"x\"[0]) || \"x\"[1:NULL])}\"))\n-  expect_equal(translate(str_starts(x, y)), sql(r\"{REGEXP_MATCHES(\"x\",'^(?:'||\"y\"))}\"))\n-  expect_equal(translate(str_ends(x, y)), sql(r\"{REGEXP_MATCHES((?:\"x\",\"y\"||')$')}\"))\n-  expect_equal(translate(str_pad(x, width = 10)), sql(r\"{LPAD(\"x\", CAST(GREATEST(10, LENGTH(\"x\")) AS INTEGER), ' ')}\"))\n-  expect_equal(translate(str_pad(x, width = 10, side = \"right\")), sql(r\"{RPAD(\"x\", CAST(GREATEST(10, LENGTH(\"x\")) AS INTEGER), ' ')}\"))\n-  expect_equal(translate(str_pad(x, width = 10, side = \"both\", pad = \"<\")), sql(r\"{RPAD(REPEAT('<', (10 - LENGTH(\"x\")) / 2) || \"x\", CAST(GREATEST(10, LENGTH(\"x\")) AS INTEGER), '<')}\"))\n+  expect_equal(translate(str_detect(x, y)), sql(r\"{REGEXP_MATCHES(x, y)}\"))\n+  expect_equal(translate(str_detect(x, y, negate = TRUE)), sql(r\"{(NOT(REGEXP_MATCHES(x, y)))}\"))\n+  expect_equal(translate(str_replace(x, y, z)), sql(r\"{REGEXP_REPLACE(x, y, z)}\"))\n+  expect_equal(translate(str_replace_all(x, y, z)), sql(r\"{REGEXP_REPLACE(x, y, z, 'g')}\"))\n+  expect_equal(translate(str_squish(x)), sql(r\"{TRIM(REGEXP_REPLACE(x, '\\s+', ' ', 'g'))}\"))\n+  expect_equal(translate(str_remove(x, y)), sql(r\"{REGEXP_REPLACE(x, y, '')}\"))\n+  expect_equal(translate(str_remove_all(x, y)), sql(r\"{REGEXP_REPLACE(x, y, '', 'g')}\"))\n+  expect_equal(translate(str_to_sentence(x)), sql(r\"{(UPPER(x[0]) || x[1:NULL])}\"))\n+  expect_equal(translate(str_starts(x, y)), sql(r\"{REGEXP_MATCHES(x,'^(?:'||y))}\"))\n+  expect_equal(translate(str_ends(x, y)), sql(r\"{REGEXP_MATCHES((?:x,y||')$')}\"))\n+  expect_equal(translate(str_pad(x, width = 10)), sql(r\"{LPAD(x, CAST(GREATEST(10, LENGTH(x)) AS INTEGER), ' ')}\"))\n+  expect_equal(translate(str_pad(x, width = 10, side = \"right\")), sql(r\"{RPAD(x, CAST(GREATEST(10, LENGTH(x)) AS INTEGER), ' ')}\"))\n+  expect_equal(translate(str_pad(x, width = 10, side = \"both\", pad = \"<\")), sql(r\"{RPAD(REPEAT('<', (10 - LENGTH(x)) / 2) || x, CAST(GREATEST(10, LENGTH(x)) AS INTEGER), '<')}\"))\n   expect_error(translate(str_pad(x, width = 10, side = \"other\")))\n })\n \n@@ -175,8 +175,8 @@ test_that(\"two variable aggregates are translated correctly\", {\n   translate <- function(...) dbplyr::translate_sql(..., con = duckdb::translate_duckdb())\n   sql <- function(...) dbplyr::sql(...)\n \n-  expect_equal(translate(cor(x, y), window = FALSE), sql(r\"{CORR(\"x\", \"y\")}\"))\n-  expect_equal(translate(cor(x, y), window = TRUE), sql(r\"{CORR(\"x\", \"y\") OVER ()}\"))\n+  expect_equal(translate(cor(x, y), window = FALSE), sql(r\"{CORR(x, y)}\"))\n+  expect_equal(translate(cor(x, y), window = TRUE), sql(r\"{CORR(x, y) OVER ()}\"))\n })\n \n \n",
  "problem_statement": "Only quote non-syntactic and reserved words\nFixes #3704\r\n\r\nLet me know if I missed any project conventions.\nMake `dbQuoteIdentifier()` only quote when necessary?\nFor teaching, it'd be cool if instead of:\r\n\r\n```sql\r\nSELECT \"carat\", \"cut\", \"color\", \"clarity\", \"price\"\r\nFROM \"diamonds\"\r\nWHERE (\"price\" > 15000.0)\r\n```\r\n\r\nduckdb could generate:\r\n\r\n```SQL\r\nSELECT carat, cut, color, clarity, price\r\nFROM diamonds\r\nWHERE (\"price\" > 15000.0)\r\n```\r\n\r\nI think duckdb is better placed to do this than the other database backends since it's easier for you to keep the reserved words in sync. \r\n\r\nI'd be happy to implement this if you can give a few hints as to how to reliably form a list of the reserved words and otherwise what constraints a table/field name must follow. (I'm guessing only letters + digits + underscore, and must start with a letter. But is letter ASCII or unicode?) (Do you allow (eg.) U+FE4D, the dashed low-line, which I think the standard allows?)\n",
  "hints_text": "\nAgreed this would be great. Internally we have a [C++ function that does this for us](https://github.com/duckdb/duckdb/blob/master/src/parser/keyword_helper.cpp), but this function is relatively conservative. Currently the behavior is that the word must (1) start with an ASCII letter or underscore, (2) contain only ASCII letters, digits or underscores, and (3) not be a keyword.\r\n\r\nMany unicode characters should work without quotes as well, the [lexer](https://github.com/duckdb/duckdb/blob/master/third_party/libpg_query/scan.l) holds the more detailed code on what requires quotes and what does not.\r\n\r\nThere is a table function you can use to query the keywords which are automatically sampled from the parser (unreserved keywords are also returned, but those don't need to be quoted):\r\n\r\n```sql\r\nD SELECT * FROM duckdb_keywords() WHERE keyword_category<>'unreserved' LIMIT 5;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 keyword_name \u2502 keyword_category \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 all          \u2502 reserved         \u2502\r\n\u2502 analyse      \u2502 reserved         \u2502\r\n\u2502 analyze      \u2502 reserved         \u2502\r\n\u2502 and          \u2502 reserved         \u2502\r\n\u2502 any          \u2502 reserved         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n\r\n\r\n",
  "created_at": "2022-08-01T14:23:07Z"
}