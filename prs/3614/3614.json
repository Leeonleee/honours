{
  "repo": "duckdb/duckdb",
  "pull_number": 3614,
  "instance_id": "duckdb__duckdb-3614",
  "issue_numbers": [
    "3548",
    "3548"
  ],
  "base_commit": "d8a2743d8848376c27bfe6b2b37eb39ac4ae42f7",
  "patch": "diff --git a/src/common/enums/statement_type.cpp b/src/common/enums/statement_type.cpp\nindex bdaaa9bcde1e..f21ae56eb87a 100644\n--- a/src/common/enums/statement_type.cpp\n+++ b/src/common/enums/statement_type.cpp\n@@ -58,15 +58,4 @@ string StatementTypeToString(StatementType type) {\n }\n // LCOV_EXCL_STOP\n \n-bool StatementTypeReturnChanges(StatementType type) {\n-\tswitch (type) {\n-\tcase StatementType::INSERT_STATEMENT:\n-\tcase StatementType::UPDATE_STATEMENT:\n-\tcase StatementType::DELETE_STATEMENT:\n-\t\treturn true;\n-\tdefault:\n-\t\treturn false;\n-\t}\n-}\n-\n } // namespace duckdb\ndiff --git a/src/include/duckdb/common/enums/statement_type.hpp b/src/include/duckdb/common/enums/statement_type.hpp\nindex a892ec118547..947446846ac3 100644\n--- a/src/include/duckdb/common/enums/statement_type.hpp\n+++ b/src/include/duckdb/common/enums/statement_type.hpp\n@@ -43,6 +43,31 @@ enum class StatementType : uint8_t {\n };\n \n string StatementTypeToString(StatementType type);\n-bool StatementTypeReturnChanges(StatementType type);\n+\n+enum class StatementReturnType : uint8_t {\n+\tQUERY_RESULT, // the statement returns a query result (e.g. for display to the user)\n+\tCHANGED_ROWS, // the statement returns a single row containing the number of changed rows (e.g. an insert stmt)\n+\tNOTHING       // the statement returns nothing\n+};\n+\n+//! A struct containing various properties of a SQL statement\n+struct StatementProperties {\n+\tStatementProperties()\n+\t    : read_only(true), requires_valid_transaction(true), allow_stream_result(false), bound_all_parameters(true),\n+\t      return_type(StatementReturnType::QUERY_RESULT) {\n+\t}\n+\n+\t//! Whether or not the statement is a read-only statement, or whether it can result in changes to the database\n+\tbool read_only;\n+\t//! Whether or not the statement requires a valid transaction. Almost all statements require this, with the\n+\t//! exception of\n+\tbool requires_valid_transaction;\n+\t//! Whether or not the result can be streamed to the client\n+\tbool allow_stream_result;\n+\t//! Whether or not all parameters have successfully had their types determined\n+\tbool bound_all_parameters;\n+\t//! What type of data the statement returns\n+\tStatementReturnType return_type;\n+};\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/main/materialized_query_result.hpp b/src/include/duckdb/main/materialized_query_result.hpp\nindex 40fc5ed58ad9..90edf939c595 100644\n--- a/src/include/duckdb/main/materialized_query_result.hpp\n+++ b/src/include/duckdb/main/materialized_query_result.hpp\n@@ -16,10 +16,9 @@ namespace duckdb {\n \n class MaterializedQueryResult : public QueryResult {\n public:\n-\t//! Creates an empty successful query result\n-\tDUCKDB_API explicit MaterializedQueryResult(StatementType statement_type);\n \t//! Creates a successful query result with the specified names and types\n-\tDUCKDB_API MaterializedQueryResult(StatementType statement_type, vector<LogicalType> types, vector<string> names);\n+\tDUCKDB_API MaterializedQueryResult(StatementType statement_type, StatementProperties properties,\n+\t                                   vector<LogicalType> types, vector<string> names);\n \t//! Creates an unsuccessful query result with error condition\n \tDUCKDB_API explicit MaterializedQueryResult(string error);\n \ndiff --git a/src/include/duckdb/main/prepared_statement.hpp b/src/include/duckdb/main/prepared_statement.hpp\nindex 4bb0c868c750..c3a1cf639d88 100644\n--- a/src/include/duckdb/main/prepared_statement.hpp\n+++ b/src/include/duckdb/main/prepared_statement.hpp\n@@ -46,6 +46,8 @@ class PreparedStatement {\n \tidx_t ColumnCount();\n \t//! Returns the statement type of the underlying prepared statement object\n \tStatementType GetStatementType();\n+\t//! Returns the underlying statement properties\n+\tStatementProperties GetStatementProperties();\n \t//! Returns the result SQL types of the prepared statement\n \tconst vector<LogicalType> &GetTypes();\n \t//! Returns the result names of the prepared statement\ndiff --git a/src/include/duckdb/main/prepared_statement_data.hpp b/src/include/duckdb/main/prepared_statement_data.hpp\nindex f56222ae05ce..a39acfc3988a 100644\n--- a/src/include/duckdb/main/prepared_statement_data.hpp\n+++ b/src/include/duckdb/main/prepared_statement_data.hpp\n@@ -37,15 +37,8 @@ class PreparedStatementData {\n \t//! The result types of the transaction\n \tvector<LogicalType> types;\n \n-\t//! Whether or not the statement is a read-only statement, or whether it can result in changes to the database\n-\tbool read_only;\n-\t//! Whether or not the statement requires a valid transaction. Almost all statements require this, with the\n-\t//! exception of\n-\tbool requires_valid_transaction;\n-\t//! Whether or not the result can be streamed to the client\n-\tbool allow_stream_result;\n-\t//! Whether or not all parameters have successfully had their types determined\n-\tbool bound_all_parameters;\n+\t//! The statement properties\n+\tStatementProperties properties;\n \n \t//! The catalog version of when the prepared statement was bound\n \t//! If this version is lower than the current catalog version, we have to rebind the prepared statement\ndiff --git a/src/include/duckdb/main/query_result.hpp b/src/include/duckdb/main/query_result.hpp\nindex 4b7ffe05dc4d..42e4a2d6f367 100644\n--- a/src/include/duckdb/main/query_result.hpp\n+++ b/src/include/duckdb/main/query_result.hpp\n@@ -20,11 +20,9 @@ enum class QueryResultType : uint8_t { MATERIALIZED_RESULT, STREAM_RESULT, PENDI\n \n class BaseQueryResult {\n public:\n-\t//! Creates a successful empty query result\n-\tDUCKDB_API BaseQueryResult(QueryResultType type, StatementType statement_type);\n \t//! Creates a successful query result with the specified names and types\n-\tDUCKDB_API BaseQueryResult(QueryResultType type, StatementType statement_type, vector<LogicalType> types,\n-\t                           vector<string> names);\n+\tDUCKDB_API BaseQueryResult(QueryResultType type, StatementType statement_type, StatementProperties properties,\n+\t                           vector<LogicalType> types, vector<string> names);\n \t//! Creates an unsuccessful query result with error condition\n \tDUCKDB_API BaseQueryResult(QueryResultType type, string error);\n \tDUCKDB_API virtual ~BaseQueryResult();\n@@ -33,6 +31,8 @@ class BaseQueryResult {\n \tQueryResultType type;\n \t//! The type of the statement that created this result\n \tStatementType statement_type;\n+\t//! Properties of the statement\n+\tStatementProperties properties;\n \t//! The SQL types of the result\n \tvector<LogicalType> types;\n \t//! The names of the result\n@@ -53,11 +53,9 @@ class BaseQueryResult {\n //! incrementally fetch data from the database.\n class QueryResult : public BaseQueryResult {\n public:\n-\t//! Creates a successful empty query result\n-\tDUCKDB_API QueryResult(QueryResultType type, StatementType statement_type);\n \t//! Creates a successful query result with the specified names and types\n-\tDUCKDB_API QueryResult(QueryResultType type, StatementType statement_type, vector<LogicalType> types,\n-\t                       vector<string> names);\n+\tDUCKDB_API QueryResult(QueryResultType type, StatementType statement_type, StatementProperties properties,\n+\t                       vector<LogicalType> types, vector<string> names);\n \t//! Creates an unsuccessful query result with error condition\n \tDUCKDB_API QueryResult(QueryResultType type, string error);\n \tDUCKDB_API virtual ~QueryResult() override;\ndiff --git a/src/include/duckdb/main/stream_query_result.hpp b/src/include/duckdb/main/stream_query_result.hpp\nindex 89a4aec3e86d..ecfff1b672e4 100644\n--- a/src/include/duckdb/main/stream_query_result.hpp\n+++ b/src/include/duckdb/main/stream_query_result.hpp\n@@ -25,8 +25,8 @@ class StreamQueryResult : public QueryResult {\n public:\n \t//! Create a successful StreamQueryResult. StreamQueryResults should always be successful initially (it makes no\n \t//! sense to stream an error).\n-\tDUCKDB_API StreamQueryResult(StatementType statement_type, shared_ptr<ClientContext> context,\n-\t                             vector<LogicalType> types, vector<string> names);\n+\tDUCKDB_API StreamQueryResult(StatementType statement_type, StatementProperties properties,\n+\t                             shared_ptr<ClientContext> context, vector<LogicalType> types, vector<string> names);\n \tDUCKDB_API ~StreamQueryResult() override;\n \n public:\ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex e3a00b8553eb..460d3ee942d9 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -18,8 +18,7 @@\n #include \"duckdb/planner/bound_statement.hpp\"\n #include \"duckdb/common/case_insensitive_map.hpp\"\n #include \"duckdb/parser/result_modifier.hpp\"\n-\n-//#include \"duckdb/catalog/catalog_entry/table_macro_catalog_entry.hpp\"\n+#include \"duckdb/common/enums/statement_type.hpp\"\n \n namespace duckdb {\n class BoundResultModifier;\n@@ -83,12 +82,8 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \tvector<BoundParameterExpression *> *parameters;\n \t//! The types of the prepared statement parameters, if any\n \tvector<LogicalType> *parameter_types;\n-\t//! Whether or not the bound statement is read-only\n-\tbool read_only;\n-\t//! Whether or not the statement requires a valid transaction to run\n-\tbool requires_valid_transaction;\n-\t//! Whether or not the statement can be streamed to the client\n-\tbool allow_stream_result;\n+\t//! Statement properties\n+\tStatementProperties properties;\n \t//! The alias for the currently processing subquery, if it exists\n \tstring alias;\n \t//! Macro parameter bindings (if any)\ndiff --git a/src/include/duckdb/planner/planner.hpp b/src/include/duckdb/planner/planner.hpp\nindex 62aeff267d46..4cfac0833974 100644\n--- a/src/include/duckdb/planner/planner.hpp\n+++ b/src/include/duckdb/planner/planner.hpp\n@@ -33,10 +33,7 @@ class Planner {\n \tshared_ptr<Binder> binder;\n \tClientContext &context;\n \n-\tbool read_only;\n-\tbool requires_valid_transaction;\n-\tbool allow_stream_result;\n-\tbool bound_all_parameters;\n+\tStatementProperties properties;\n \n private:\n \tvoid CreatePlan(SQLStatement &statement);\ndiff --git a/src/main/capi/arrow-c.cpp b/src/main/capi/arrow-c.cpp\nindex 270e33845376..e36859964df4 100644\n--- a/src/main/capi/arrow-c.cpp\n+++ b/src/main/capi/arrow-c.cpp\n@@ -56,7 +56,7 @@ idx_t duckdb_arrow_rows_changed(duckdb_arrow result) {\n \tauto wrapper = (ArrowResultWrapper *)result;\n \tidx_t rows_changed = 0;\n \tidx_t row_count = wrapper->result->collection.Count();\n-\tif (row_count > 0 && StatementTypeReturnChanges(wrapper->result->statement_type)) {\n+\tif (row_count > 0 && wrapper->result->properties.return_type == duckdb::StatementReturnType::CHANGED_ROWS) {\n \t\tauto row_changes = wrapper->result->GetValue(0, 0);\n \t\tif (!row_changes.IsNull() && row_changes.TryCastAs(LogicalType::BIGINT)) {\n \t\t\trows_changed = row_changes.GetValue<int64_t>();\ndiff --git a/src/main/capi/result-c.cpp b/src/main/capi/result-c.cpp\nindex d65f590c1045..063ddba18757 100644\n--- a/src/main/capi/result-c.cpp\n+++ b/src/main/capi/result-c.cpp\n@@ -314,7 +314,8 @@ bool deprecated_materialize_result(duckdb_result *result) {\n \t\tresult->__deprecated_columns[i].__deprecated_name = (char *)result_data->result->names[i].c_str();\n \t}\n \tresult->__deprecated_row_count = materialized.collection.Count();\n-\tif (result->__deprecated_row_count > 0 && StatementTypeReturnChanges(materialized.statement_type)) {\n+\tif (result->__deprecated_row_count > 0 &&\n+\t    materialized.properties.return_type == StatementReturnType::CHANGED_ROWS) {\n \t\t// update total changes\n \t\tauto row_changes = materialized.GetValue(0, 0);\n \t\tif (!row_changes.IsNull() && row_changes.TryCastAs(LogicalType::BIGINT)) {\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex 2e04a66eb9f5..7065215602da 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -205,20 +205,22 @@ unique_ptr<QueryResult> ClientContext::FetchResultInternal(ClientContextLock &lo\n \tD_ASSERT(active_query->open_result == &pending);\n \tD_ASSERT(active_query->prepared);\n \tauto &prepared = *active_query->prepared;\n-\tbool create_stream_result = prepared.allow_stream_result && allow_stream_result;\n+\tbool create_stream_result = prepared.properties.allow_stream_result && allow_stream_result;\n \tif (create_stream_result) {\n \t\tactive_query->progress_bar.reset();\n \t\tquery_progress = -1;\n \n \t\t// successfully compiled SELECT clause and it is the last statement\n \t\t// return a StreamQueryResult so the client can call Fetch() on it and stream the result\n-\t\tauto stream_result =\n-\t\t    make_unique<StreamQueryResult>(pending.statement_type, shared_from_this(), pending.types, pending.names);\n+\t\tauto stream_result = make_unique<StreamQueryResult>(pending.statement_type, pending.properties,\n+\t\t                                                    shared_from_this(), pending.types, pending.names);\n \t\tactive_query->open_result = stream_result.get();\n \t\treturn move(stream_result);\n \t}\n \t// create a materialized result by continuously fetching\n-\tauto result = make_unique<MaterializedQueryResult>(pending.statement_type, pending.types, pending.names);\n+\tauto result =\n+\t    make_unique<MaterializedQueryResult>(pending.statement_type, pending.properties, pending.types, pending.names);\n+\tresult->properties = pending.properties;\n \twhile (true) {\n \t\tauto chunk = FetchInternal(lock, GetExecutor(), *result);\n \t\tif (!chunk || chunk->size() == 0) {\n@@ -259,14 +261,11 @@ shared_ptr<PreparedStatementData> ClientContext::CreatePreparedStatement(ClientC\n \tplan->Verify();\n #endif\n \t// extract the result column names from the plan\n-\tresult->read_only = planner.read_only;\n-\tresult->requires_valid_transaction = planner.requires_valid_transaction;\n-\tresult->allow_stream_result = planner.allow_stream_result;\n+\tresult->properties = planner.properties;\n \tresult->names = planner.names;\n \tresult->types = planner.types;\n \tresult->value_map = move(planner.value_map);\n \tresult->catalog_version = Transaction::GetTransaction(*this).catalog_version;\n-\tresult->bound_all_parameters = planner.bound_all_parameters;\n \n \tif (config.enable_optimizer) {\n \t\tprofiler.StartPhase(\"optimizer\");\n@@ -302,11 +301,11 @@ unique_ptr<PendingQueryResult> ClientContext::PendingPreparedStatement(ClientCon\n                                                                        vector<Value> bound_values) {\n \tD_ASSERT(active_query);\n \tauto &statement = *statement_p;\n-\tif (ActiveTransaction().IsInvalidated() && statement.requires_valid_transaction) {\n+\tif (ActiveTransaction().IsInvalidated() && statement.properties.requires_valid_transaction) {\n \t\tthrow Exception(\"Current transaction is aborted (please ROLLBACK)\");\n \t}\n \tauto &db_config = DBConfig::GetConfig(*this);\n-\tif (db_config.access_mode == AccessMode::READ_ONLY && !statement.read_only) {\n+\tif (db_config.access_mode == AccessMode::READ_ONLY && !statement.properties.read_only) {\n \t\tthrow Exception(StringUtil::Format(\"Cannot execute statement of type \\\"%s\\\" in read-only mode!\",\n \t\t                                   StatementTypeToString(statement.statement_type)));\n \t}\n@@ -575,17 +574,17 @@ ClientContext::PendingStatementOrPreparedStatement(ClientContextLock &lock, cons\n \t\t\tresult = PendingStatementInternal(lock, query, move(statement));\n \t\t} else {\n \t\t\tauto &catalog = Catalog::GetCatalog(*this);\n-\t\t\tif (prepared->unbound_statement &&\n-\t\t\t    (catalog.GetCatalogVersion() != prepared->catalog_version || !prepared->bound_all_parameters)) {\n+\t\t\tif (prepared->unbound_statement && (catalog.GetCatalogVersion() != prepared->catalog_version ||\n+\t\t\t                                    !prepared->properties.bound_all_parameters)) {\n \t\t\t\t// catalog was modified: rebind the statement before execution\n \t\t\t\tauto new_prepared = CreatePreparedStatement(lock, query, prepared->unbound_statement->Copy(), values);\n-\t\t\t\tif (prepared->types != new_prepared->types && prepared->bound_all_parameters) {\n+\t\t\t\tif (prepared->types != new_prepared->types && prepared->properties.bound_all_parameters) {\n \t\t\t\t\tthrow BinderException(\"Rebinding statement after catalog change resulted in change of types\");\n \t\t\t\t}\n-\t\t\t\tD_ASSERT(new_prepared->bound_all_parameters);\n+\t\t\t\tD_ASSERT(new_prepared->properties.bound_all_parameters);\n \t\t\t\tnew_prepared->unbound_statement = move(prepared->unbound_statement);\n \t\t\t\tprepared = move(new_prepared);\n-\t\t\t\tprepared->bound_all_parameters = false;\n+\t\t\t\tprepared->properties.bound_all_parameters = false;\n \t\t\t}\n \t\t\tresult = PendingPreparedStatement(lock, prepared, *values);\n \t\t}\n@@ -643,7 +642,11 @@ unique_ptr<QueryResult> ClientContext::Query(const string &query, bool allow_str\n \t}\n \tif (statements.empty()) {\n \t\t// no statements, return empty successful result\n-\t\treturn make_unique<MaterializedQueryResult>(StatementType::INVALID_STATEMENT);\n+\t\tStatementProperties properties;\n+\t\tvector<LogicalType> types;\n+\t\tvector<string> names;\n+\t\treturn make_unique<MaterializedQueryResult>(StatementType::INVALID_STATEMENT, properties, move(types),\n+\t\t                                            move(names));\n \t}\n \n \tunique_ptr<QueryResult> result;\ndiff --git a/src/main/materialized_query_result.cpp b/src/main/materialized_query_result.cpp\nindex 55638822de08..5824a8df0570 100644\n--- a/src/main/materialized_query_result.cpp\n+++ b/src/main/materialized_query_result.cpp\n@@ -3,13 +3,9 @@\n \n namespace duckdb {\n \n-MaterializedQueryResult::MaterializedQueryResult(StatementType statement_type)\n-    : QueryResult(QueryResultType::MATERIALIZED_RESULT, statement_type) {\n-}\n-\n-MaterializedQueryResult::MaterializedQueryResult(StatementType statement_type, vector<LogicalType> types,\n-                                                 vector<string> names)\n-    : QueryResult(QueryResultType::MATERIALIZED_RESULT, statement_type, move(types), move(names)) {\n+MaterializedQueryResult::MaterializedQueryResult(StatementType statement_type, StatementProperties properties,\n+                                                 vector<LogicalType> types, vector<string> names)\n+    : QueryResult(QueryResultType::MATERIALIZED_RESULT, statement_type, properties, move(types), move(names)) {\n }\n \n MaterializedQueryResult::MaterializedQueryResult(string error)\ndiff --git a/src/main/pending_query_result.cpp b/src/main/pending_query_result.cpp\nindex 9906d9786f13..37365e3368fc 100644\n--- a/src/main/pending_query_result.cpp\n+++ b/src/main/pending_query_result.cpp\n@@ -6,7 +6,8 @@ namespace duckdb {\n \n PendingQueryResult::PendingQueryResult(shared_ptr<ClientContext> context_p, PreparedStatementData &statement,\n                                        vector<LogicalType> types_p)\n-    : BaseQueryResult(QueryResultType::PENDING_RESULT, statement.statement_type, move(types_p), statement.names),\n+    : BaseQueryResult(QueryResultType::PENDING_RESULT, statement.statement_type, statement.properties, move(types_p),\n+                      statement.names),\n       context(move(context_p)) {\n }\n \ndiff --git a/src/main/prepared_statement.cpp b/src/main/prepared_statement.cpp\nindex a647d793001b..8ea3dd5aca8b 100644\n--- a/src/main/prepared_statement.cpp\n+++ b/src/main/prepared_statement.cpp\n@@ -27,6 +27,11 @@ StatementType PreparedStatement::GetStatementType() {\n \treturn data->statement_type;\n }\n \n+StatementProperties PreparedStatement::GetStatementProperties() {\n+\tD_ASSERT(data);\n+\treturn data->properties;\n+}\n+\n const vector<LogicalType> &PreparedStatement::GetTypes() {\n \tD_ASSERT(data);\n \treturn data->types;\n@@ -42,7 +47,7 @@ unique_ptr<QueryResult> PreparedStatement::Execute(vector<Value> &values, bool a\n \tif (!pending->success) {\n \t\treturn make_unique<MaterializedQueryResult>(pending->error);\n \t}\n-\treturn pending->Execute(allow_stream_result && data->allow_stream_result);\n+\treturn pending->Execute(allow_stream_result && data->properties.allow_stream_result);\n }\n \n unique_ptr<PendingQueryResult> PreparedStatement::PendingQuery(vector<Value> &values) {\ndiff --git a/src/main/prepared_statement_data.cpp b/src/main/prepared_statement_data.cpp\nindex 700945a8aab8..eeae2c1024ac 100644\n--- a/src/main/prepared_statement_data.cpp\n+++ b/src/main/prepared_statement_data.cpp\n@@ -4,9 +4,7 @@\n \n namespace duckdb {\n \n-PreparedStatementData::PreparedStatementData(StatementType type)\n-    : statement_type(type), read_only(true), requires_valid_transaction(true), allow_stream_result(false),\n-      bound_all_parameters(true) {\n+PreparedStatementData::PreparedStatementData(StatementType type) : statement_type(type) {\n }\n \n PreparedStatementData::~PreparedStatementData() {\ndiff --git a/src/main/query_result.cpp b/src/main/query_result.cpp\nindex e8e0bdc576e4..3ca73825e9d3 100644\n--- a/src/main/query_result.cpp\n+++ b/src/main/query_result.cpp\n@@ -6,13 +6,10 @@\n \n namespace duckdb {\n \n-BaseQueryResult::BaseQueryResult(QueryResultType type, StatementType statement_type)\n-    : type(type), statement_type(statement_type), success(true) {\n-}\n-\n-BaseQueryResult::BaseQueryResult(QueryResultType type, StatementType statement_type, vector<LogicalType> types_p,\n-                                 vector<string> names_p)\n-    : type(type), statement_type(statement_type), types(move(types_p)), names(move(names_p)), success(true) {\n+BaseQueryResult::BaseQueryResult(QueryResultType type, StatementType statement_type, StatementProperties properties,\n+                                 vector<LogicalType> types_p, vector<string> names_p)\n+    : type(type), statement_type(statement_type), properties(properties), types(move(types_p)), names(move(names_p)),\n+      success(true) {\n \tD_ASSERT(types.size() == names.size());\n }\n \n@@ -32,12 +29,9 @@ idx_t BaseQueryResult::ColumnCount() {\n \treturn types.size();\n }\n \n-QueryResult::QueryResult(QueryResultType type, StatementType statement_type) : BaseQueryResult(type, statement_type) {\n-}\n-\n-QueryResult::QueryResult(QueryResultType type, StatementType statement_type, vector<LogicalType> types_p,\n-                         vector<string> names_p)\n-    : BaseQueryResult(type, statement_type, move(types_p), move(names_p)) {\n+QueryResult::QueryResult(QueryResultType type, StatementType statement_type, StatementProperties properties,\n+                         vector<LogicalType> types_p, vector<string> names_p)\n+    : BaseQueryResult(type, statement_type, properties, move(types_p), move(names_p)) {\n }\n \n QueryResult::QueryResult(QueryResultType type, string error) : BaseQueryResult(type, move(error)) {\ndiff --git a/src/main/stream_query_result.cpp b/src/main/stream_query_result.cpp\nindex 3ec82e7f0aa4..4bbd7a0e09d8 100644\n--- a/src/main/stream_query_result.cpp\n+++ b/src/main/stream_query_result.cpp\n@@ -5,9 +5,10 @@\n \n namespace duckdb {\n \n-StreamQueryResult::StreamQueryResult(StatementType statement_type, shared_ptr<ClientContext> context,\n-                                     vector<LogicalType> types, vector<string> names)\n-    : QueryResult(QueryResultType::STREAM_RESULT, statement_type, move(types), move(names)), context(move(context)) {\n+StreamQueryResult::StreamQueryResult(StatementType statement_type, StatementProperties properties,\n+                                     shared_ptr<ClientContext> context, vector<LogicalType> types, vector<string> names)\n+    : QueryResult(QueryResultType::STREAM_RESULT, statement_type, properties, move(types), move(names)),\n+      context(move(context)) {\n }\n \n StreamQueryResult::~StreamQueryResult() {\n@@ -57,7 +58,7 @@ unique_ptr<MaterializedQueryResult> StreamQueryResult::Materialize() {\n \tif (!success) {\n \t\treturn make_unique<MaterializedQueryResult>(error);\n \t}\n-\tauto result = make_unique<MaterializedQueryResult>(statement_type, types, names);\n+\tauto result = make_unique<MaterializedQueryResult>(statement_type, properties, types, names);\n \twhile (true) {\n \t\tauto chunk = Fetch();\n \t\tif (!chunk || chunk->size() == 0) {\ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex 8b28a7848505..13641c559551 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -22,8 +22,7 @@ shared_ptr<Binder> Binder::CreateBinder(ClientContext &context, Binder *parent,\n }\n \n Binder::Binder(bool, ClientContext &context, shared_ptr<Binder> parent_p, bool inherit_ctes_p)\n-    : context(context), read_only(true), requires_valid_transaction(true), allow_stream_result(false),\n-      parent(move(parent_p)), bound_tables(0), inherit_ctes(inherit_ctes_p) {\n+    : context(context), parent(move(parent_p)), bound_tables(0), inherit_ctes(inherit_ctes_p) {\n \tparameters = nullptr;\n \tparameter_types = nullptr;\n \tif (parent) {\n@@ -424,7 +423,8 @@ BoundStatement Binder::BindReturning(vector<unique_ptr<ParsedExpression>> return\n \tprojection->AddChild(move(child_operator));\n \tD_ASSERT(result.types.size() == result.names.size());\n \tresult.plan = move(projection);\n-\tthis->allow_stream_result = true;\n+\tproperties.allow_stream_result = true;\n+\tproperties.return_type = StatementReturnType::QUERY_RESULT;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_call.cpp b/src/planner/binder/statement/bind_call.cpp\nindex c8240583d8ed..582c764fc987 100644\n--- a/src/planner/binder/statement/bind_call.cpp\n+++ b/src/planner/binder/statement/bind_call.cpp\n@@ -23,6 +23,7 @@ BoundStatement Binder::Bind(CallStatement &stmt) {\n \tresult.types = get.returned_types;\n \tresult.names = get.names;\n \tresult.plan = CreatePlan(*bound_func);\n+\tproperties.return_type = StatementReturnType::QUERY_RESULT;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_copy.cpp b/src/planner/binder/statement/bind_copy.cpp\nindex 01664fc5246d..cdd8a255657b 100644\n--- a/src/planner/binder/statement/bind_copy.cpp\n+++ b/src/planner/binder/statement/bind_copy.cpp\n@@ -140,7 +140,8 @@ BoundStatement Binder::Bind(CopyStatement &stmt) {\n \t\t}\n \t\tstmt.select_statement = move(statement);\n \t}\n-\tthis->allow_stream_result = false;\n+\tproperties.allow_stream_result = false;\n+\tproperties.return_type = StatementReturnType::CHANGED_ROWS;\n \tif (stmt.info->is_from) {\n \t\treturn BindCopyFrom(stmt);\n \t} else {\ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex 3f421c7cc026..a95719bcd443 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -42,7 +42,7 @@ SchemaCatalogEntry *Binder::BindSchema(CreateInfo &info) {\n \t\tif (info.schema == TEMP_SCHEMA) {\n \t\t\tthrow ParserException(\"Only TEMPORARY table names can use the \\\"temp\\\" schema\");\n \t\t}\n-\t\tthis->read_only = false;\n+\t\tproperties.read_only = false;\n \t} else {\n \t\tif (info.schema != TEMP_SCHEMA) {\n \t\t\tthrow ParserException(\"TEMPORARY table names can *only* use the \\\"%s\\\" schema\", TEMP_SCHEMA);\n@@ -187,6 +187,7 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {\n \tBoundStatement result;\n \tresult.names = {\"Count\"};\n \tresult.types = {LogicalType::BIGINT};\n+\tproperties.return_type = StatementReturnType::NOTHING;\n \n \tauto catalog_type = stmt.info->type;\n \tswitch (catalog_type) {\n@@ -297,6 +298,8 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {\n \t\tauto &schema = bound_info->schema;\n \t\tauto create_table = make_unique<LogicalCreateTable>(schema, move(bound_info));\n \t\tif (root) {\n+\t\t\t// CREATE TABLE AS\n+\t\t\tproperties.return_type = StatementReturnType::CHANGED_ROWS;\n \t\t\tcreate_table->children.push_back(move(root));\n \t\t}\n \t\tresult.plan = move(create_table);\n@@ -310,7 +313,7 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {\n \tdefault:\n \t\tthrow Exception(\"Unrecognized type!\");\n \t}\n-\tthis->allow_stream_result = false;\n+\tproperties.allow_stream_result = false;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_create_table.cpp b/src/planner/binder/statement/bind_create_table.cpp\nindex 14cd22f16776..75a6a16d4d99 100644\n--- a/src/planner/binder/statement/bind_create_table.cpp\n+++ b/src/planner/binder/statement/bind_create_table.cpp\n@@ -208,7 +208,7 @@ unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateIn\n \t\t\t}\n \t\t}\n \t}\n-\tthis->allow_stream_result = false;\n+\tproperties.allow_stream_result = false;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_delete.cpp b/src/planner/binder/statement/bind_delete.cpp\nindex 13469a8956ad..266d503043bd 100644\n--- a/src/planner/binder/statement/bind_delete.cpp\n+++ b/src/planner/binder/statement/bind_delete.cpp\n@@ -28,7 +28,7 @@ BoundStatement Binder::Bind(DeleteStatement &stmt) {\n \n \tif (!table->temporary) {\n \t\t// delete from persistent table: not read only!\n-\t\tthis->read_only = false;\n+\t\tproperties.read_only = false;\n \t}\n \n \t// plan any tables from the various using clauses\n@@ -89,7 +89,8 @@ BoundStatement Binder::Bind(DeleteStatement &stmt) {\n \t\tresult.plan = move(del);\n \t\tresult.names = {\"Count\"};\n \t\tresult.types = {LogicalType::BIGINT};\n-\t\tthis->allow_stream_result = false;\n+\t\tproperties.allow_stream_result = false;\n+\t\tproperties.return_type = StatementReturnType::CHANGED_ROWS;\n \t}\n \treturn result;\n }\ndiff --git a/src/planner/binder/statement/bind_drop.cpp b/src/planner/binder/statement/bind_drop.cpp\nindex e9f301a46e9e..66da6aab3a0f 100644\n--- a/src/planner/binder/statement/bind_drop.cpp\n+++ b/src/planner/binder/statement/bind_drop.cpp\n@@ -14,11 +14,11 @@ BoundStatement Binder::Bind(DropStatement &stmt) {\n \tcase CatalogType::PREPARED_STATEMENT:\n \t\t// dropping prepared statements is always possible\n \t\t// it also does not require a valid transaction\n-\t\tthis->requires_valid_transaction = false;\n+\t\tproperties.requires_valid_transaction = false;\n \t\tbreak;\n \tcase CatalogType::SCHEMA_ENTRY:\n \t\t// dropping a schema is never read-only because there are no temporary schemas\n-\t\tthis->read_only = false;\n+\t\tproperties.read_only = false;\n \t\tbreak;\n \tcase CatalogType::VIEW_ENTRY:\n \tcase CatalogType::SEQUENCE_ENTRY:\n@@ -34,7 +34,7 @@ BoundStatement Binder::Bind(DropStatement &stmt) {\n \t\t}\n \t\tif (!entry->temporary) {\n \t\t\t// we can only drop temporary tables in read-only mode\n-\t\t\tthis->read_only = false;\n+\t\t\tproperties.read_only = false;\n \t\t}\n \t\tstmt.info->schema = entry->schema->name;\n \t\tbreak;\n@@ -45,7 +45,8 @@ BoundStatement Binder::Bind(DropStatement &stmt) {\n \tresult.plan = make_unique<LogicalSimple>(LogicalOperatorType::LOGICAL_DROP, move(stmt.info));\n \tresult.names = {\"Success\"};\n \tresult.types = {LogicalType::BOOLEAN};\n-\tthis->allow_stream_result = false;\n+\tproperties.allow_stream_result = false;\n+\tproperties.return_type = StatementReturnType::NOTHING;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_explain.cpp b/src/planner/binder/statement/bind_explain.cpp\nindex 2a06c5d34687..625f7ddbe5c8 100644\n--- a/src/planner/binder/statement/bind_explain.cpp\n+++ b/src/planner/binder/statement/bind_explain.cpp\n@@ -17,6 +17,7 @@ BoundStatement Binder::Bind(ExplainStatement &stmt) {\n \tresult.plan = move(explain);\n \tresult.names = {\"explain_key\", \"explain_value\"};\n \tresult.types = {LogicalType::VARCHAR, LogicalType::VARCHAR};\n+\tproperties.return_type = StatementReturnType::QUERY_RESULT;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_export.cpp b/src/planner/binder/statement/bind_export.cpp\nindex f66f34a2661d..5926cf39bd3f 100644\n--- a/src/planner/binder/statement/bind_export.cpp\n+++ b/src/planner/binder/statement/bind_export.cpp\n@@ -197,7 +197,8 @@ BoundStatement Binder::Bind(ExportStatement &stmt) {\n \t}\n \n \tresult.plan = move(export_node);\n-\tthis->allow_stream_result = false;\n+\tproperties.allow_stream_result = false;\n+\tproperties.return_type = StatementReturnType::NOTHING;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_insert.cpp b/src/planner/binder/statement/bind_insert.cpp\nindex b9616a178b9a..958dbd0abada 100644\n--- a/src/planner/binder/statement/bind_insert.cpp\n+++ b/src/planner/binder/statement/bind_insert.cpp\n@@ -34,7 +34,7 @@ BoundStatement Binder::Bind(InsertStatement &stmt) {\n \tD_ASSERT(table);\n \tif (!table->temporary) {\n \t\t// inserting into a non-temporary table: alters underlying database\n-\t\tthis->read_only = false;\n+\t\tproperties.read_only = false;\n \t}\n \n \tauto insert = make_unique<LogicalInsert>(table);\n@@ -140,7 +140,8 @@ BoundStatement Binder::Bind(InsertStatement &stmt) {\n \t} else {\n \t\tD_ASSERT(result.types.size() == result.names.size());\n \t\tresult.plan = move(insert);\n-\t\tthis->allow_stream_result = false;\n+\t\tproperties.allow_stream_result = false;\n+\t\tproperties.return_type = StatementReturnType::CHANGED_ROWS;\n \t\treturn result;\n \t}\n }\ndiff --git a/src/planner/binder/statement/bind_load.cpp b/src/planner/binder/statement/bind_load.cpp\nindex 6f24cc3bc78d..916183ad3820 100644\n--- a/src/planner/binder/statement/bind_load.cpp\n+++ b/src/planner/binder/statement/bind_load.cpp\n@@ -11,7 +11,8 @@ BoundStatement Binder::Bind(LoadStatement &stmt) {\n \tresult.names = {\"Success\"};\n \n \tresult.plan = make_unique<LogicalSimple>(LogicalOperatorType::LOGICAL_LOAD, move(stmt.info));\n-\tthis->allow_stream_result = false;\n+\tproperties.allow_stream_result = false;\n+\tproperties.return_type = StatementReturnType::NOTHING;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_pragma.cpp b/src/planner/binder/statement/bind_pragma.cpp\nindex 78b99c36e95e..5a931952fed5 100644\n--- a/src/planner/binder/statement/bind_pragma.cpp\n+++ b/src/planner/binder/statement/bind_pragma.cpp\n@@ -29,6 +29,7 @@ BoundStatement Binder::Bind(PragmaStatement &stmt) {\n \tresult.names = {\"Success\"};\n \tresult.types = {LogicalType::BOOLEAN};\n \tresult.plan = make_unique<LogicalPragma>(bound_function, *stmt.info);\n+\tproperties.return_type = StatementReturnType::QUERY_RESULT;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_select.cpp b/src/planner/binder/statement/bind_select.cpp\nindex 3b993004f3cd..711a07c573b3 100644\n--- a/src/planner/binder/statement/bind_select.cpp\n+++ b/src/planner/binder/statement/bind_select.cpp\n@@ -5,7 +5,8 @@\n namespace duckdb {\n \n BoundStatement Binder::Bind(SelectStatement &stmt) {\n-\tthis->allow_stream_result = true;\n+\tproperties.allow_stream_result = true;\n+\tproperties.return_type = StatementReturnType::QUERY_RESULT;\n \treturn Bind(*stmt.node);\n }\n \ndiff --git a/src/planner/binder/statement/bind_set.cpp b/src/planner/binder/statement/bind_set.cpp\nindex 2348d27c6eba..c300541390d1 100644\n--- a/src/planner/binder/statement/bind_set.cpp\n+++ b/src/planner/binder/statement/bind_set.cpp\n@@ -11,6 +11,7 @@ BoundStatement Binder::Bind(SetStatement &stmt) {\n \tresult.names = {\"Success\"};\n \n \tresult.plan = make_unique<LogicalSet>(stmt.name, stmt.value, stmt.scope);\n+\tproperties.return_type = StatementReturnType::NOTHING;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_show.cpp b/src/planner/binder/statement/bind_show.cpp\nindex 11e58163ea5a..3979449e1391 100644\n--- a/src/planner/binder/statement/bind_show.cpp\n+++ b/src/planner/binder/statement/bind_show.cpp\n@@ -23,6 +23,7 @@ BoundStatement Binder::Bind(ShowStatement &stmt) {\n \tresult.names = {\"column_name\", \"column_type\", \"null\", \"key\", \"default\", \"extra\"};\n \tresult.types = {LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR,\n \t                LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};\n+\tproperties.return_type = StatementReturnType::QUERY_RESULT;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_simple.cpp b/src/planner/binder/statement/bind_simple.cpp\nindex ce405870297b..0cdcf5ea024a 100644\n--- a/src/planner/binder/statement/bind_simple.cpp\n+++ b/src/planner/binder/statement/bind_simple.cpp\n@@ -19,20 +19,22 @@ BoundStatement Binder::Bind(AlterStatement &stmt) {\n \tauto entry = catalog.GetEntry(context, stmt.info->GetCatalogType(), stmt.info->schema, stmt.info->name, true);\n \tif (entry && !entry->temporary) {\n \t\t// we can only alter temporary tables/views in read-only mode\n-\t\tthis->read_only = false;\n+\t\tproperties.read_only = false;\n \t}\n \tresult.plan = make_unique<LogicalSimple>(LogicalOperatorType::LOGICAL_ALTER, move(stmt.info));\n+\tproperties.return_type = StatementReturnType::NOTHING;\n \treturn result;\n }\n \n BoundStatement Binder::Bind(TransactionStatement &stmt) {\n \t// transaction statements do not require a valid transaction\n-\tthis->requires_valid_transaction = false;\n+\tproperties.requires_valid_transaction = false;\n \n \tBoundStatement result;\n \tresult.names = {\"Success\"};\n \tresult.types = {LogicalType::BOOLEAN};\n \tresult.plan = make_unique<LogicalSimple>(LogicalOperatorType::LOGICAL_TRANSACTION, move(stmt.info));\n+\tproperties.return_type = StatementReturnType::NOTHING;\n \treturn result;\n }\n \ndiff --git a/src/planner/binder/statement/bind_summarize.cpp b/src/planner/binder/statement/bind_summarize.cpp\nindex 1aec506dfbb6..8452c1f03c10 100644\n--- a/src/planner/binder/statement/bind_summarize.cpp\n+++ b/src/planner/binder/statement/bind_summarize.cpp\n@@ -128,6 +128,7 @@ BoundStatement Binder::BindSummarize(ShowStatement &stmt) {\n \tselect_node->select_list.push_back(SummarizeWrapUnnest(null_percentage_children, \"null_percentage\"));\n \tselect_node->from_table = move(subquery_ref);\n \n+\tproperties.return_type = StatementReturnType::QUERY_RESULT;\n \treturn Bind(*select_node);\n }\n \ndiff --git a/src/planner/binder/statement/bind_update.cpp b/src/planner/binder/statement/bind_update.cpp\nindex efb00aa27115..df7d0c6f39e3 100644\n--- a/src/planner/binder/statement/bind_update.cpp\n+++ b/src/planner/binder/statement/bind_update.cpp\n@@ -144,7 +144,7 @@ BoundStatement Binder::Bind(UpdateStatement &stmt) {\n \n \tif (!table->temporary) {\n \t\t// update of persistent table: not read only!\n-\t\tthis->read_only = false;\n+\t\tproperties.read_only = false;\n \t}\n \tauto update = make_unique<LogicalUpdate>(table);\n \n@@ -225,7 +225,8 @@ BoundStatement Binder::Bind(UpdateStatement &stmt) {\n \t\tresult.names = {\"Count\"};\n \t\tresult.types = {LogicalType::BIGINT};\n \t\tresult.plan = move(update);\n-\t\tthis->allow_stream_result = false;\n+\t\tproperties.allow_stream_result = false;\n+\t\tproperties.return_type = StatementReturnType::CHANGED_ROWS;\n \t}\n \treturn result;\n }\ndiff --git a/src/planner/binder/statement/bind_vacuum.cpp b/src/planner/binder/statement/bind_vacuum.cpp\nindex 707afa5b3687..f056088cd486 100644\n--- a/src/planner/binder/statement/bind_vacuum.cpp\n+++ b/src/planner/binder/statement/bind_vacuum.cpp\n@@ -9,6 +9,7 @@ BoundStatement Binder::Bind(VacuumStatement &stmt) {\n \tresult.names = {\"Success\"};\n \tresult.types = {LogicalType::BOOLEAN};\n \tresult.plan = make_unique<LogicalSimple>(LogicalOperatorType::LOGICAL_VACUUM, move(stmt.info));\n+\tproperties.return_type = StatementReturnType::NOTHING;\n \treturn result;\n }\n \ndiff --git a/src/planner/planner.cpp b/src/planner/planner.cpp\nindex e9bed48206f3..e410ad528664 100644\n--- a/src/planner/planner.cpp\n+++ b/src/planner/planner.cpp\n@@ -33,19 +33,17 @@ void Planner::CreatePlan(SQLStatement &statement) {\n \tauto bound_statement = binder->Bind(statement);\n \tprofiler.EndPhase();\n \n-\tthis->read_only = binder->read_only;\n-\tthis->requires_valid_transaction = binder->requires_valid_transaction;\n-\tthis->allow_stream_result = binder->allow_stream_result;\n+\tthis->properties = binder->properties;\n \tthis->names = bound_statement.names;\n \tthis->types = bound_statement.types;\n \tthis->plan = move(bound_statement.plan);\n-\tthis->bound_all_parameters = true;\n+\tproperties.bound_all_parameters = true;\n \n \t// set up a map of parameter number -> value entries\n \tfor (auto &expr : bound_parameters) {\n \t\t// check if the type of the parameter could be resolved\n \t\tif (expr->return_type.id() == LogicalTypeId::INVALID || expr->return_type.id() == LogicalTypeId::UNKNOWN) {\n-\t\t\tthis->bound_all_parameters = false;\n+\t\t\tproperties.bound_all_parameters = false;\n \t\t\tcontinue;\n \t\t}\n \t\tauto value = make_unique<Value>(expr->return_type);\n@@ -73,11 +71,8 @@ shared_ptr<PreparedStatementData> Planner::PrepareSQLStatement(unique_ptr<SQLSta\n \tprepared_data->names = names;\n \tprepared_data->types = types;\n \tprepared_data->value_map = move(value_map);\n-\tprepared_data->read_only = this->read_only;\n-\tprepared_data->requires_valid_transaction = this->requires_valid_transaction;\n-\tprepared_data->allow_stream_result = this->allow_stream_result;\n+\tprepared_data->properties = properties;\n \tprepared_data->catalog_version = Transaction::GetTransaction(context).catalog_version;\n-\tprepared_data->bound_all_parameters = this->bound_all_parameters;\n \treturn prepared_data;\n }\n \n@@ -107,7 +102,7 @@ void Planner::PlanExecute(unique_ptr<SQLStatement> statement) {\n \t\tValue value = ExpressionExecutor::EvaluateScalar(*bound_expr);\n \t\tbind_values.push_back(move(value));\n \t}\n-\tbool all_bound = prepared->bound_all_parameters;\n+\tbool all_bound = prepared->properties.bound_all_parameters;\n \tif (catalog.GetCatalogVersion() != entry->second->catalog_version || !all_bound) {\n \t\t// catalog was modified or statement does not have clear types: rebind the statement before running the execute\n \t\tfor (auto &value : bind_values) {\n@@ -118,7 +113,7 @@ void Planner::PlanExecute(unique_ptr<SQLStatement> statement) {\n \t\t\tthrow BinderException(\"Rebinding statement \\\"%s\\\" after catalog change resulted in change of types\",\n \t\t\t                      stmt.name);\n \t\t}\n-\t\tD_ASSERT(prepared->bound_all_parameters);\n+\t\tD_ASSERT(prepared->properties.bound_all_parameters);\n \t\trebound = true;\n \t}\n \t// add casts to the prepared statement parameters as required\n@@ -138,12 +133,9 @@ void Planner::PlanExecute(unique_ptr<SQLStatement> statement) {\n \t}\n \n \t// copy the properties of the prepared statement into the planner\n-\tthis->read_only = prepared->read_only;\n-\tthis->requires_valid_transaction = prepared->requires_valid_transaction;\n-\tthis->allow_stream_result = prepared->allow_stream_result;\n+\tthis->properties = prepared->properties;\n \tthis->names = prepared->names;\n \tthis->types = prepared->types;\n-\tthis->bound_all_parameters = prepared->bound_all_parameters;\n \tthis->plan = make_unique<LogicalExecute>(move(prepared));\n }\n \n@@ -153,12 +145,13 @@ void Planner::PlanPrepare(unique_ptr<SQLStatement> statement) {\n \n \tauto prepare = make_unique<LogicalPrepare>(stmt.name, move(prepared_data), move(plan));\n \t// we can prepare in read-only mode: prepared statements are not written to the catalog\n-\tthis->read_only = true;\n+\tproperties.read_only = true;\n \t// we can always prepare, even if the transaction has been invalidated\n \t// this is required because most clients ALWAYS invoke prepared statements\n-\tthis->requires_valid_transaction = false;\n-\tthis->allow_stream_result = false;\n-\tthis->bound_all_parameters = true;\n+\tproperties.requires_valid_transaction = false;\n+\tproperties.allow_stream_result = false;\n+\tproperties.bound_all_parameters = true;\n+\tproperties.return_type = StatementReturnType::NOTHING;\n \tthis->names = {\"Success\"};\n \tthis->types = {LogicalType::BOOLEAN};\n \tthis->plan = move(prepare);\ndiff --git a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\nindex 70ea23c16af9..adf05d41a971 100644\n--- a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n+++ b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n@@ -192,20 +192,6 @@ int sqlite3_prepare_v2(sqlite3 *db,           /* Database handle */\n \t}\n }\n \n-bool sqlite3_display_result(StatementType type) {\n-\tswitch (type) {\n-\tcase StatementType::EXECUTE_STATEMENT:\n-\tcase StatementType::EXPLAIN_STATEMENT:\n-\tcase StatementType::PRAGMA_STATEMENT:\n-\tcase StatementType::SELECT_STATEMENT:\n-\tcase StatementType::SHOW_STATEMENT:\n-\tcase StatementType::CALL_STATEMENT:\n-\t\treturn true;\n-\tdefault:\n-\t\treturn false;\n-\t}\n-}\n-\n /* Prepare the next result to be retrieved */\n int sqlite3_step(sqlite3_stmt *pStmt) {\n \tif (!pStmt) {\n@@ -233,8 +219,9 @@ int sqlite3_step(sqlite3_stmt *pStmt) {\n \n \t\tpStmt->current_row = -1;\n \n-\t\tauto statement_type = pStmt->prepared->GetStatementType();\n-\t\tif (StatementTypeReturnChanges(statement_type) && pStmt->current_chunk && pStmt->current_chunk->size() > 0) {\n+\t\tauto properties = pStmt->prepared->GetStatementProperties();\n+\t\tif (properties.return_type == StatementReturnType::CHANGED_ROWS && pStmt->current_chunk &&\n+\t\t    pStmt->current_chunk->size() > 0) {\n \t\t\t// update total changes\n \t\t\tauto row_changes = pStmt->current_chunk->GetValue(0, 0);\n \t\t\tif (!row_changes.IsNull() && row_changes.TryCastAs(LogicalType::BIGINT)) {\n@@ -242,7 +229,7 @@ int sqlite3_step(sqlite3_stmt *pStmt) {\n \t\t\t\tpStmt->db->total_changes += row_changes.GetValue<int64_t>();\n \t\t\t}\n \t\t}\n-\t\tif (!sqlite3_display_result(statement_type)) {\n+\t\tif (properties.return_type != StatementReturnType::QUERY_RESULT) {\n \t\t\t// only SELECT statements return results\n \t\t\tsqlite3_reset(pStmt);\n \t\t}\n",
  "test_patch": "diff --git a/tools/shell/shell-test.py b/tools/shell/shell-test.py\nindex 7b3f93fc01af..b6b157b5c2b8 100644\n--- a/tools/shell/shell-test.py\n+++ b/tools/shell/shell-test.py\n@@ -173,6 +173,36 @@ def tf():\n test('explain select sum(i) from range(1000) tbl(i)', out='RANGE')\n test('explain analyze select sum(i) from range(1000) tbl(i)', out='RANGE')\n \n+# test returning insert\n+test('''\n+CREATE TABLE table1 (a INTEGER DEFAULT -1, b INTEGER DEFAULT -2, c INTEGER DEFAULT -3);\n+INSERT INTO table1 VALUES (1, 2, 3) RETURNING *;\n+SELECT COUNT(*) FROM table1;\n+''', out='1')\n+\n+# test display of pragmas\n+test('''\n+CREATE TABLE table1 (mylittlecolumn INTEGER);\n+pragma table_info('table1');\n+''', out='mylittlecolumn')\n+\n+# test display of show\n+test('''\n+CREATE TABLE table1 (mylittlecolumn INTEGER);\n+show table1;\n+''', out='mylittlecolumn')\n+\n+# test display of call\n+test('''\n+CALL range(4);\n+''', out='3')\n+\n+# test display of prepare/execute\n+test('''\n+PREPARE v1 AS SELECT ?::INT;\n+EXECUTE v1(42);\n+''', out='42')\n+\n \n # this should be fixed\n test('.selftest', err='sqlite3_table_column_metadata')\n",
  "problem_statement": "`INSERT` with `RETURNING` performs no insertion.\n#### What happens?\r\n\r\n`INSERT` with `RETURNING` performs no insertion.\r\n\r\n#### To Reproduce\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n\r\n```sql\r\n CREATE TABLE table1 (a INTEGER DEFAULT -1, b INTEGER DEFAULT -2, c INTEGER DEFAULT -3);\r\n INSERT INTO table1 VALUES (1, 2, 3) RETURNING *;\r\n SELECT COUNT(*) FROM table1;\r\n```\r\nThe last SQL query should return 1.\r\n\r\n![image](https://user-images.githubusercontent.com/28505034/166136304-f548a8d2-23d1-4b25-8aac-f5a34a7e3bae.png)\r\n\r\n\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: 0.3.4\r\n - DuckDB Client: CLI\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n`INSERT` with `RETURNING` performs no insertion.\n#### What happens?\r\n\r\n`INSERT` with `RETURNING` performs no insertion.\r\n\r\n#### To Reproduce\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n\r\n```sql\r\n CREATE TABLE table1 (a INTEGER DEFAULT -1, b INTEGER DEFAULT -2, c INTEGER DEFAULT -3);\r\n INSERT INTO table1 VALUES (1, 2, 3) RETURNING *;\r\n SELECT COUNT(*) FROM table1;\r\n```\r\nThe last SQL query should return 1.\r\n\r\n![image](https://user-images.githubusercontent.com/28505034/166136304-f548a8d2-23d1-4b25-8aac-f5a34a7e3bae.png)\r\n\r\n\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: 0.3.4\r\n - DuckDB Client: CLI\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "@Tmonster maybe you can have a look here?\nyup! will take a look on Monday\nJust had a chat with @lnkuiper and we have a strong feeling that this issue is because of the SQLite shell. The issue isn't reproducible using duckdb in python, or when creating a unit test with the exact same sql. The sqlite shell code is pretty complex so going to wait for @Mytherin to come back from vacation before investigating further\n@Tmonster maybe you can have a look here?\nyup! will take a look on Monday\nJust had a chat with @lnkuiper and we have a strong feeling that this issue is because of the SQLite shell. The issue isn't reproducible using duckdb in python, or when creating a unit test with the exact same sql. The sqlite shell code is pretty complex so going to wait for @Mytherin to come back from vacation before investigating further",
  "created_at": "2022-05-10T16:48:22Z"
}