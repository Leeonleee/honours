diff --git a/src/include/duckdb/parser/constraints/unique_constraint.hpp b/src/include/duckdb/parser/constraints/unique_constraint.hpp
index a3811160ae66..ded23b0d3bfd 100644
--- a/src/include/duckdb/parser/constraints/unique_constraint.hpp
+++ b/src/include/duckdb/parser/constraints/unique_constraint.hpp
@@ -22,6 +22,7 @@ class UniqueConstraint : public Constraint {
 
 public:
 	DUCKDB_API UniqueConstraint(const LogicalIndex index, const bool is_primary_key);
+	DUCKDB_API UniqueConstraint(const LogicalIndex index, string column_name, const bool is_primary_key);
 	DUCKDB_API UniqueConstraint(vector<string> columns, const bool is_primary_key);
 
 public:
@@ -46,8 +47,6 @@ class UniqueConstraint : public Constraint {
 	vector<LogicalIndex> GetLogicalIndexes(const ColumnList &columns) const;
 	//! Get the name of the constraint.
 	string GetName(const string &table_name) const;
-	//! Sets a single column name. Does nothing, if the name is already set.
-	void SetColumnName(const string &name);
 
 private:
 	UniqueConstraint();
diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp
index 717d69979383..6a1e8dcc3187 100644
--- a/src/include/duckdb/planner/binder.hpp
+++ b/src/include/duckdb/planner/binder.hpp
@@ -134,8 +134,9 @@ class Binder : public enable_shared_from_this<Binder> {
 	vector<unique_ptr<BoundConstraint>> BindConstraints(const TableCatalogEntry &table);
 	vector<unique_ptr<BoundConstraint>> BindNewConstraints(vector<unique_ptr<Constraint>> &constraints,
 	                                                       const string &table_name, const ColumnList &columns);
-	unique_ptr<BoundConstraint> BindConstraint(Constraint &constraint, const string &table, const ColumnList &columns);
-	unique_ptr<BoundConstraint> BindUniqueConstraint(Constraint &constraint, const string &table,
+	unique_ptr<BoundConstraint> BindConstraint(const Constraint &constraint, const string &table,
+	                                           const ColumnList &columns);
+	unique_ptr<BoundConstraint> BindUniqueConstraint(const Constraint &constraint, const string &table,
 	                                                 const ColumnList &columns);
 
 	BoundStatement BindAlterAddIndex(BoundStatement &result, CatalogEntry &entry, unique_ptr<AlterInfo> alter_info);
diff --git a/src/parser/constraints/unique_constraint.cpp b/src/parser/constraints/unique_constraint.cpp
index 51c4631b39c6..d3379be42b91 100644
--- a/src/parser/constraints/unique_constraint.cpp
+++ b/src/parser/constraints/unique_constraint.cpp
@@ -10,6 +10,10 @@ UniqueConstraint::UniqueConstraint() : Constraint(ConstraintType::UNIQUE), index
 UniqueConstraint::UniqueConstraint(const LogicalIndex index, const bool is_primary_key)
     : Constraint(ConstraintType::UNIQUE), index(index), is_primary_key(is_primary_key) {
 }
+UniqueConstraint::UniqueConstraint(const LogicalIndex index, string column_name_p, const bool is_primary_key)
+    : UniqueConstraint(index, is_primary_key) {
+	columns.push_back(std::move(column_name_p));
+}
 
 UniqueConstraint::UniqueConstraint(vector<string> columns, const bool is_primary_key)
     : Constraint(ConstraintType::UNIQUE), index(DConstants::INVALID_INDEX), columns(std::move(columns)),
@@ -32,10 +36,7 @@ unique_ptr<Constraint> UniqueConstraint::Copy() const {
 		return make_uniq<UniqueConstraint>(columns, is_primary_key);
 	}
 
-	auto result = make_uniq<UniqueConstraint>(index, is_primary_key);
-	if (!columns.empty()) {
-		result->columns.push_back(columns[0]);
-	}
+	auto result = make_uniq<UniqueConstraint>(index, columns.empty() ? string() : columns[0], is_primary_key);
 	return std::move(result);
 }
 
@@ -95,11 +96,4 @@ string UniqueConstraint::GetName(const string &table_name) const {
 	return type_name + "_" + table_name + name;
 }
 
-void UniqueConstraint::SetColumnName(const string &column_name) {
-	if (!columns.empty()) {
-		return;
-	}
-	columns.push_back(column_name);
-}
-
 } // namespace duckdb
diff --git a/src/parser/transform/constraint/transform_constraint.cpp b/src/parser/transform/constraint/transform_constraint.cpp
index 8439fc863258..e73b15cdc47a 100644
--- a/src/parser/transform/constraint/transform_constraint.cpp
+++ b/src/parser/transform/constraint/transform_constraint.cpp
@@ -105,9 +105,9 @@ unique_ptr<Constraint> Transformer::TransformConstraint(duckdb_libpgquery::PGCon
 	case duckdb_libpgquery::PG_CONSTR_CHECK:
 		return TransformConstraint(constraint);
 	case duckdb_libpgquery::PG_CONSTR_PRIMARY:
-		return make_uniq<UniqueConstraint>(LogicalIndex(index), true);
+		return make_uniq<UniqueConstraint>(LogicalIndex(index), column.GetName(), true);
 	case duckdb_libpgquery::PG_CONSTR_UNIQUE:
-		return make_uniq<UniqueConstraint>(LogicalIndex(index), false);
+		return make_uniq<UniqueConstraint>(LogicalIndex(index), column.GetName(), false);
 	case duckdb_libpgquery::PG_CONSTR_NULL:
 		return nullptr;
 	case duckdb_libpgquery::PG_CONSTR_GENERATED_VIRTUAL: {
diff --git a/src/planner/binder/statement/bind_create_table.cpp b/src/planner/binder/statement/bind_create_table.cpp
index 15a553b81605..4a6eccf8040e 100644
--- a/src/planner/binder/statement/bind_create_table.cpp
+++ b/src/planner/binder/statement/bind_create_table.cpp
@@ -102,7 +102,7 @@ vector<unique_ptr<BoundConstraint>> Binder::BindNewConstraints(vector<unique_ptr
 	return bound_constraints;
 }
 
-unique_ptr<BoundConstraint> BindCheckConstraint(Binder &binder, Constraint &constraint, const string &table,
+unique_ptr<BoundConstraint> BindCheckConstraint(Binder &binder, const Constraint &constraint, const string &table,
                                                 const ColumnList &columns) {
 	auto bound_constraint = make_uniq<BoundCheckConstraint>();
 	auto &bound_check = bound_constraint->Cast<BoundCheckConstraint>();
@@ -112,15 +112,14 @@ unique_ptr<BoundConstraint> BindCheckConstraint(Binder &binder, Constraint &cons
 	auto &check = constraint.Cast<CheckConstraint>();
 
 	// Create a copy of the unbound expression because binding can invalidate it.
-	auto unbound_expression = check.expression->Copy();
+	auto check_copy = check.expression->Copy();
 
 	// Bind the constraint and reset the original expression.
-	bound_check.expression = check_binder.Bind(check.expression);
-	check.expression = std::move(unbound_expression);
+	bound_check.expression = check_binder.Bind(check_copy);
 	return std::move(bound_constraint);
 }
 
-unique_ptr<BoundConstraint> Binder::BindUniqueConstraint(Constraint &constraint, const string &table,
+unique_ptr<BoundConstraint> Binder::BindUniqueConstraint(const Constraint &constraint, const string &table,
                                                          const ColumnList &columns) {
 	auto &unique = constraint.Cast<UniqueConstraint>();
 
@@ -132,7 +131,6 @@ unique_ptr<BoundConstraint> Binder::BindUniqueConstraint(Constraint &constraint,
 	// If set, then the UNIQUE constraint is defined on a single column.
 	if (unique.HasIndex()) {
 		auto &col = columns.GetColumn(unique.GetIndex());
-		unique.SetColumnName(col.Name());
 		indexes.push_back(col.Physical());
 		index_set.insert(col.Physical());
 		return make_uniq<BoundUniqueConstraint>(std::move(indexes), std::move(index_set), unique.IsPrimaryKey());
@@ -159,7 +157,7 @@ unique_ptr<BoundConstraint> Binder::BindUniqueConstraint(Constraint &constraint,
 	return make_uniq<BoundUniqueConstraint>(std::move(indexes), std::move(index_set), unique.IsPrimaryKey());
 }
 
-unique_ptr<BoundConstraint> BindForeignKey(Constraint &constraint) {
+unique_ptr<BoundConstraint> BindForeignKey(const Constraint &constraint) {
 	auto &fk = constraint.Cast<ForeignKeyConstraint>();
 	D_ASSERT((fk.info.type == ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE && !fk.info.pk_keys.empty()) ||
 	         (fk.info.type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE && !fk.info.pk_keys.empty()) ||
@@ -184,7 +182,7 @@ unique_ptr<BoundConstraint> BindForeignKey(Constraint &constraint) {
 	return make_uniq<BoundForeignKeyConstraint>(fk.info, std::move(pk_key_set), std::move(fk_key_set));
 }
 
-unique_ptr<BoundConstraint> Binder::BindConstraint(Constraint &constraint, const string &table,
+unique_ptr<BoundConstraint> Binder::BindConstraint(const Constraint &constraint, const string &table,
                                                    const ColumnList &columns) {
 	switch (constraint.type) {
 	case ConstraintType::CHECK: {
