You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
"Cannot copy bound expression" random error
### What happens?

 In the test.ddb database, 
 
 ```SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
 FROM pg_catalog. pg_constraint c
 INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
```
 
If I do this sentence over and over again, I get random errors.

The test.ddb datafile is available for download below.
https://github.com/goosedb-net/goosedb-download/releases/download/test/test.tgz



__STAGE__$ cat /etc/os-release 
PRETTY_NAME="Ubuntu 24.04.1 LTS"
NAME="Ubuntu"
VERSION_ID="24.04"
VERSION="24.04.1 LTS (Noble Numbat)"
VERSION_CODENAME=noble
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=noble
LOGO=ubuntu-logo
(myenv) [goose@tnt-factory:/tmp/test]
__STAGE__$ 


```
#################################################################################################################################
# case 1
#################################################################################################################################

__STAGE__$ duckdb test.ddb 
v1.2.1 8e52ec4395
Enter ".help" for usage hints.
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
  FROM pg_catalog.pg_constraint c
  INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬───┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ … │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼───┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴───┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                28 columns (13 shown) │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
  FROM pg_catalog.pg_constraint c
  INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬───┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ … │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼───┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴───┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                28 columns (13 shown) │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
  FROM pg_catalog.pg_constraint c
  INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬───┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ … │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼───┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴───┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                28 columns (13 shown) │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
  FROM pg_catalog.pg_constraint c
  INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
Segmentation fault (core dumped)
(myenv) [goose@tnt-factory:/tmp/test]
__STAGE__$


#################################################################################################################################
# case 2
#################################################################################################################################

__STAGE__$ duckdb test.ddb 
v1.2.1 8e52ec4395
Enter ".help" for usage hints.
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
Serialization Error:
Cannot copy bound expression
D 

__STAGE__$ 

#################################################################################################################################
# case 3
#################################################################################################################################


__STAGE__$ duckdb test.ddb 
v1.2.1 8e52ec4395
Enter ".help" for usage hints.
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
Serialization Error:
Cannot copy bound expression
D 


#################################################################################################################################
# case 4
#################################################################################################################################

__STAGE__$ duckdb test.ddb 
v1.2.1 8e52ec4395
Enter ".help" for usage hints.
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 593000003 │ 593000003 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 695000007 │ 695000007 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 701000011 │ 701000011 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 707000015 │ 707000015 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
│ 713000016 │ 713000016 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_branches  │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
Serialization Error:
Cannot copy bound expression
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
Serialization Error:
Cannot copy bound expression
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 593000003 │ 593000003 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 695000007 │ 695000007 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 701000011 │ 701000011 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 707000015 │ 707000015 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
│ 713000016 │ 713000016 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_branches  │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
```

### To Reproduce

in test.ddb database, 
 
 "SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
 FROM pg_catalog. pg_constraint c
 INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;" 
 
If I do this sentence over and over again, I get random errors.

### OS:

Ubuntu 24.04.1 LTS

### DuckDB Version:

1.2.1

### DuckDB Client:

cli

### Hardware:

8core 16gb

### Full Name:

SeongSik

### Affiliation:

OraScope

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [x] Yes, I have
"Cannot copy bound expression" random error
### What happens?

 In the test.ddb database, 
 
 ```SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
 FROM pg_catalog. pg_constraint c
 INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
```
 
If I do this sentence over and over again, I get random errors.

The test.ddb datafile is available for download below.
https://github.com/goosedb-net/goosedb-download/releases/download/test/test.tgz



__STAGE__$ cat /etc/os-release 
PRETTY_NAME="Ubuntu 24.04.1 LTS"
NAME="Ubuntu"
VERSION_ID="24.04"
VERSION="24.04.1 LTS (Noble Numbat)"
VERSION_CODENAME=noble
ID=ubuntu
ID_LIKE=debian
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
UBUNTU_CODENAME=noble
LOGO=ubuntu-logo
(myenv) [goose@tnt-factory:/tmp/test]
__STAGE__$ 


```
#################################################################################################################################
# case 1
#################################################################################################################################

__STAGE__$ duckdb test.ddb 
v1.2.1 8e52ec4395
Enter ".help" for usage hints.
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
  FROM pg_catalog.pg_constraint c
  INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬───┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ … │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼───┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴───┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                28 columns (13 shown) │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
  FROM pg_catalog.pg_constraint c
  INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬───┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ … │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼───┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴───┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                28 columns (13 shown) │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
  FROM pg_catalog.pg_constraint c
  INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬───┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ … │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼───┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ … │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴───┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                28 columns (13 shown) │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
  FROM pg_catalog.pg_constraint c
  INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
Segmentation fault (core dumped)
(myenv) [goose@tnt-factory:/tmp/test]
__STAGE__$


#################################################################################################################################
# case 2
#################################################################################################################################

__STAGE__$ duckdb test.ddb 
v1.2.1 8e52ec4395
Enter ".help" for usage hints.
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
Serialization Error:
Cannot copy bound expression
D 

__STAGE__$ 

#################################################################################################################################
# case 3
#################################################################################################################################


__STAGE__$ duckdb test.ddb 
v1.2.1 8e52ec4395
Enter ".help" for usage hints.
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 552000002 │ 552000002 │ NOT NULL │          550 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ postgres_type     │ NULL        │
│ 763000006 │ 763000006 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 865000010 │ 865000010 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 871000014 │ 871000014 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 877000018 │ 877000018 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
      FROM pg_catalog.pg_constraint c
      INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
Serialization Error:
Cannot copy bound expression
D 


#################################################################################################################################
# case 4
#################################################################################################################################

__STAGE__$ duckdb test.ddb 
v1.2.1 8e52ec4395
Enter ".help" for usage hints.
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 593000003 │ 593000003 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 695000007 │ 695000007 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 701000011 │ 701000011 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 707000015 │ 707000015 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
│ 713000016 │ 713000016 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_branches  │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
Serialization Error:
Cannot copy bound expression
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
Serialization Error:
Cannot copy bound expression
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
┌───────────┬───────────┬──────────┬──────────────┬─────────┬───────────────┬─────────────┬──────────────┬───┬───────────┬───────────┬───────────┬───────────┬─────────┬───────────────────┬─────────────┐
│    oid    │    oid    │ conname  │ connamespace │ contype │ condeferrable │ condeferred │ convalidated │ … │ conpfeqop │ conppeqop │ conffeqop │ conexclop │ conbin  │    tabrelname     │ consrc_copy │
│   int64   │   int64   │ varchar  │    int64     │ varchar │    boolean    │   boolean   │   boolean    │   │   int32   │   int32   │   int32   │   int32   │ varchar │      varchar      │   varchar   │
├───────────┼───────────┼──────────┼──────────────┼─────────┼───────────────┼─────────────┼──────────────┼───┼───────────┼───────────┼───────────┼───────────┼─────────┼───────────────────┼─────────────┤
│ 593000003 │ 593000003 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ example           │ NULL        │
│ 695000007 │ 695000007 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts1 │ NULL        │
│ 701000011 │ 701000011 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts2 │ NULL        │
│ 707000015 │ 707000015 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_accounts3 │ NULL        │
│ 713000016 │ 713000016 │ NOT NULL │          548 │ x       │ false         │ false       │ true         │ … │      NULL │      NULL │      NULL │      NULL │ NULL    │ pgbench_branches  │ NULL        │
├───────────┴───────────┴──────────┴──────────────┴─────────┴───────────────┴─────────────┴──────────────┴───┴───────────┴───────────┴───────────┴───────────┴─────────┴───────────────────┴─────────────┤
│ 5 rows                                                                                                                                                                           28 columns (15 shown) │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
D SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
    FROM pg_catalog.pg_constraint c
    INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;
```

### To Reproduce

in test.ddb database, 
 
 "SELECT c.oid,c.*,t.relname as tabrelname, case when c.contype='c' then substring(pg_get_constraintdef(c.oid), 7) else null end consrc_copy
 FROM pg_catalog. pg_constraint c
 INNER JOIN pg_catalog.pg_class t ON t.oid=c.conrelid limit 5;" 
 
If I do this sentence over and over again, I get random errors.

### OS:

Ubuntu 24.04.1 LTS

### DuckDB Version:

1.2.1

### DuckDB Client:

cli

### Hardware:

8core 16gb

### Full Name:

SeongSik

### Affiliation:

OraScope

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [x] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdb.org/docs/api/r#duckplyr-dplyr-api).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/include/duckdb/parser/constraints/unique_constraint.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parser/constraints/unique_constraint.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/enum_util.hpp"
12: #include "duckdb/common/enums/index_constraint_type.hpp"
13: #include "duckdb/common/vector.hpp"
14: #include "duckdb/parser/column_list.hpp"
15: #include "duckdb/parser/constraint.hpp"
16: 
17: namespace duckdb {
18: 
19: class UniqueConstraint : public Constraint {
20: public:
21: 	static constexpr const ConstraintType TYPE = ConstraintType::UNIQUE;
22: 
23: public:
24: 	DUCKDB_API UniqueConstraint(const LogicalIndex index, const bool is_primary_key);
25: 	DUCKDB_API UniqueConstraint(vector<string> columns, const bool is_primary_key);
26: 
27: public:
28: 	DUCKDB_API string ToString() const override;
29: 	DUCKDB_API unique_ptr<Constraint> Copy() const override;
30: 	DUCKDB_API void Serialize(Serializer &serializer) const override;
31: 	DUCKDB_API static unique_ptr<Constraint> Deserialize(Deserializer &deserializer);
32: 
33: 	//! Returns true, if the constraint is a PRIMARY KEY constraint.
34: 	bool IsPrimaryKey() const;
35: 	//! Returns true, if the constraint is defined on a single column.
36: 	bool HasIndex() const;
37: 	//! Returns the column index on which the constraint is defined.
38: 	LogicalIndex GetIndex() const;
39: 	//! Sets the column index of the constraint.
40: 	void SetIndex(const LogicalIndex new_index);
41: 	//! Returns a constant reference to the column names on which the constraint is defined.
42: 	const vector<string> &GetColumnNames() const;
43: 	//! Returns a mutable reference to the column names on which the constraint is defined.
44: 	vector<string> &GetColumnNamesMutable();
45: 	//! Returns the column indexes on which the constraint is defined.
46: 	vector<LogicalIndex> GetLogicalIndexes(const ColumnList &columns) const;
47: 	//! Get the name of the constraint.
48: 	string GetName(const string &table_name) const;
49: 	//! Sets a single column name. Does nothing, if the name is already set.
50: 	void SetColumnName(const string &name);
51: 
52: private:
53: 	UniqueConstraint();
54: 
55: #ifdef DUCKDB_API_1_0
56: private:
57: #else
58: public:
59: #endif
60: 
61: 	//! The indexed column of the constraint. Only used for single-column constraints, invalid otherwise.
62: 	LogicalIndex index;
63: 	//! The names of the columns on which this constraint is defined. Only set if the index field is not set.
64: 	vector<string> columns;
65: 	//! Whether this is a PRIMARY KEY constraint, or a UNIQUE constraint.
66: 	bool is_primary_key;
67: };
68: 
69: } // namespace duckdb
[end of src/include/duckdb/parser/constraints/unique_constraint.hpp]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/case_insensitive_map.hpp"
12: #include "duckdb/common/enums/join_type.hpp"
13: #include "duckdb/common/enums/statement_type.hpp"
14: #include "duckdb/common/exception/binder_exception.hpp"
15: #include "duckdb/common/reference_map.hpp"
16: #include "duckdb/common/unordered_map.hpp"
17: #include "duckdb/parser/column_definition.hpp"
18: #include "duckdb/parser/query_node.hpp"
19: #include "duckdb/parser/result_modifier.hpp"
20: #include "duckdb/parser/tableref/delimgetref.hpp"
21: #include "duckdb/parser/tokens.hpp"
22: #include "duckdb/planner/bind_context.hpp"
23: #include "duckdb/planner/bound_statement.hpp"
24: #include "duckdb/planner/bound_tokens.hpp"
25: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
26: #include "duckdb/planner/joinside.hpp"
27: #include "duckdb/planner/bound_constraint.hpp"
28: #include "duckdb/planner/logical_operator.hpp"
29: #include "duckdb/planner/tableref/bound_delimgetref.hpp"
30: 
31: namespace duckdb {
32: class BoundResultModifier;
33: class BoundSelectNode;
34: class ClientContext;
35: class ExpressionBinder;
36: class LimitModifier;
37: class OrderBinder;
38: class TableCatalogEntry;
39: class ViewCatalogEntry;
40: class TableMacroCatalogEntry;
41: class UpdateSetInfo;
42: class LogicalProjection;
43: class LogicalVacuum;
44: 
45: class ColumnList;
46: class ExternalDependency;
47: class TableFunction;
48: class TableStorageInfo;
49: class BoundConstraint;
50: 
51: struct CreateInfo;
52: struct BoundCreateTableInfo;
53: struct CommonTableExpressionInfo;
54: struct BoundParameterMap;
55: struct BoundPragmaInfo;
56: struct BoundLimitNode;
57: struct PivotColumnEntry;
58: struct UnpivotEntry;
59: 
60: enum class BindingMode : uint8_t { STANDARD_BINDING, EXTRACT_NAMES, EXTRACT_REPLACEMENT_SCANS };
61: enum class BinderType : uint8_t { REGULAR_BINDER, VIEW_BINDER };
62: 
63: struct CorrelatedColumnInfo {
64: 	ColumnBinding binding;
65: 	LogicalType type;
66: 	string name;
67: 	idx_t depth;
68: 
69: 	// NOLINTNEXTLINE - work-around bug in clang-tidy
70: 	CorrelatedColumnInfo(ColumnBinding binding, LogicalType type_p, string name_p, idx_t depth)
71: 	    : binding(binding), type(std::move(type_p)), name(std::move(name_p)), depth(depth) {
72: 	}
73: 	explicit CorrelatedColumnInfo(BoundColumnRefExpression &expr)
74: 	    : CorrelatedColumnInfo(expr.binding, expr.return_type, expr.GetName(), expr.depth) {
75: 	}
76: 
77: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
78: 		return binding == rhs.binding;
79: 	}
80: };
81: 
82: //! Bind the parsed query tree to the actual columns present in the catalog.
83: /*!
84:   The binder is responsible for binding tables and columns to actual physical
85:   tables and columns in the catalog. In the process, it also resolves types of
86:   all expressions.
87: */
88: class Binder : public enable_shared_from_this<Binder> {
89: 	friend class ExpressionBinder;
90: 	friend class RecursiveDependentJoinPlanner;
91: 
92: public:
93: 	DUCKDB_API static shared_ptr<Binder> CreateBinder(ClientContext &context, optional_ptr<Binder> parent = nullptr,
94: 	                                                  BinderType binder_type = BinderType::REGULAR_BINDER);
95: 
96: 	//! The client context
97: 	ClientContext &context;
98: 	//! A mapping of names to common table expressions
99: 	case_insensitive_map_t<reference<CommonTableExpressionInfo>> CTE_bindings; // NOLINT
100: 	//! The CTEs that have already been bound
101: 	reference_set_t<CommonTableExpressionInfo> bound_ctes;
102: 	//! The bind context
103: 	BindContext bind_context;
104: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
105: 	//! vector)
106: 	vector<CorrelatedColumnInfo> correlated_columns;
107: 	//! The set of parameter expressions bound by this binder
108: 	optional_ptr<BoundParameterMap> parameters;
109: 	//! The alias for the currently processing subquery, if it exists
110: 	string alias;
111: 	//! Macro parameter bindings (if any)
112: 	optional_ptr<DummyBinding> macro_binding;
113: 	//! The intermediate lambda bindings to bind nested lambdas (if any)
114: 	optional_ptr<vector<DummyBinding>> lambda_bindings;
115: 
116: 	unordered_map<idx_t, LogicalOperator *> recursive_ctes;
117: 
118: public:
119: 	DUCKDB_API BoundStatement Bind(SQLStatement &statement);
120: 	DUCKDB_API BoundStatement Bind(QueryNode &node);
121: 
122: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
123: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info, SchemaCatalogEntry &schema);
124: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info, SchemaCatalogEntry &schema,
125: 	                                                     vector<unique_ptr<Expression>> &bound_defaults);
126: 	static unique_ptr<BoundCreateTableInfo> BindCreateTableCheckpoint(unique_ptr<CreateInfo> info,
127: 	                                                                  SchemaCatalogEntry &schema);
128: 
129: 	static vector<unique_ptr<BoundConstraint>> BindConstraints(ClientContext &context,
130: 	                                                           const vector<unique_ptr<Constraint>> &constraints,
131: 	                                                           const string &table_name, const ColumnList &columns);
132: 	vector<unique_ptr<BoundConstraint>> BindConstraints(const vector<unique_ptr<Constraint>> &constraints,
133: 	                                                    const string &table_name, const ColumnList &columns);
134: 	vector<unique_ptr<BoundConstraint>> BindConstraints(const TableCatalogEntry &table);
135: 	vector<unique_ptr<BoundConstraint>> BindNewConstraints(vector<unique_ptr<Constraint>> &constraints,
136: 	                                                       const string &table_name, const ColumnList &columns);
137: 	unique_ptr<BoundConstraint> BindConstraint(Constraint &constraint, const string &table, const ColumnList &columns);
138: 	unique_ptr<BoundConstraint> BindUniqueConstraint(Constraint &constraint, const string &table,
139: 	                                                 const ColumnList &columns);
140: 
141: 	BoundStatement BindAlterAddIndex(BoundStatement &result, CatalogEntry &entry, unique_ptr<AlterInfo> alter_info);
142: 
143: 	void SetCatalogLookupCallback(catalog_entry_callback_t callback);
144: 	void BindCreateViewInfo(CreateViewInfo &base);
145: 	SchemaCatalogEntry &BindSchema(CreateInfo &info);
146: 	SchemaCatalogEntry &BindCreateFunctionInfo(CreateInfo &info);
147: 
148: 	//! Check usage, and cast named parameters to their types
149: 	static void BindNamedParameters(named_parameter_type_map_t &types, named_parameter_map_t &values,
150: 	                                QueryErrorContext &error_context, string &func_name);
151: 	unique_ptr<BoundPragmaInfo> BindPragma(PragmaInfo &info, QueryErrorContext error_context);
152: 
153: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
154: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
155: 
156: 	//! Generates an unused index for a table
157: 	idx_t GenerateTableIndex();
158: 
159: 	optional_ptr<CatalogEntry> GetCatalogEntry(CatalogType type, const string &catalog, const string &schema,
160: 	                                           const string &name, OnEntryNotFound on_entry_not_found,
161: 	                                           QueryErrorContext &error_context);
162: 
163: 	//! Add a common table expression to the binder
164: 	void AddCTE(const string &name, CommonTableExpressionInfo &cte);
165: 	//! Find all candidate common table expression by name; returns empty vector if none exists
166: 	vector<reference<CommonTableExpressionInfo>> FindCTE(const string &name, bool skip = false);
167: 
168: 	bool CTEIsAlreadyBound(CommonTableExpressionInfo &cte);
169: 
170: 	//! Add the view to the set of currently bound views - used for detecting recursive view definitions
171: 	void AddBoundView(ViewCatalogEntry &view);
172: 
173: 	void PushExpressionBinder(ExpressionBinder &binder);
174: 	void PopExpressionBinder();
175: 	void SetActiveBinder(ExpressionBinder &binder);
176: 	ExpressionBinder &GetActiveBinder();
177: 	bool HasActiveBinder();
178: 
179: 	vector<reference<ExpressionBinder>> &GetActiveBinders();
180: 
181: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
182: 	//! Add a correlated column to this binder (if it does not exist)
183: 	void AddCorrelatedColumn(const CorrelatedColumnInfo &info);
184: 
185: 	unique_ptr<LogicalOperator> BindUpdateSet(LogicalOperator &op, unique_ptr<LogicalOperator> root,
186: 	                                          UpdateSetInfo &set_info, TableCatalogEntry &table,
187: 	                                          vector<PhysicalIndex> &columns);
188: 	void BindDoUpdateSetExpressions(const string &table_alias, LogicalInsert &insert, UpdateSetInfo &set_info,
189: 	                                TableCatalogEntry &table, TableStorageInfo &storage_info);
190: 	void BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &table, InsertStatement &stmt);
191: 
192: 	void BindVacuumTable(LogicalVacuum &vacuum, unique_ptr<LogicalOperator> &root);
193: 
194: 	static void BindSchemaOrCatalog(ClientContext &context, string &catalog, string &schema);
195: 	void BindLogicalType(LogicalType &type, optional_ptr<Catalog> catalog = nullptr,
196: 	                     const string &schema = INVALID_SCHEMA);
197: 
198: 	optional_ptr<Binding> GetMatchingBinding(const string &table_name, const string &column_name, ErrorData &error);
199: 	optional_ptr<Binding> GetMatchingBinding(const string &schema_name, const string &table_name,
200: 	                                         const string &column_name, ErrorData &error);
201: 	optional_ptr<Binding> GetMatchingBinding(const string &catalog_name, const string &schema_name,
202: 	                                         const string &table_name, const string &column_name, ErrorData &error);
203: 
204: 	void SetBindingMode(BindingMode mode);
205: 	BindingMode GetBindingMode();
206: 	void AddTableName(string table_name);
207: 	void AddReplacementScan(const string &table_name, unique_ptr<TableRef> replacement);
208: 	const unordered_set<string> &GetTableNames();
209: 	case_insensitive_map_t<unique_ptr<TableRef>> &GetReplacementScans();
210: 	optional_ptr<SQLStatement> GetRootStatement() {
211: 		return root_statement;
212: 	}
213: 	CatalogEntryRetriever &EntryRetriever() {
214: 		return entry_retriever;
215: 	}
216: 	//! Returns a ColumnRefExpression after it was resolved (i.e. past the STAR expression/USING clauses)
217: 	static optional_ptr<ParsedExpression> GetResolvedColumnExpression(ParsedExpression &root_expr);
218: 
219: 	void SetCanContainNulls(bool can_contain_nulls);
220: 	void SetAlwaysRequireRebind();
221: 
222: 	StatementProperties &GetStatementProperties();
223: 
224: private:
225: 	//! The parent binder (if any)
226: 	shared_ptr<Binder> parent;
227: 	//! The vector of active binders
228: 	vector<reference<ExpressionBinder>> active_binders;
229: 	//! The count of bound_tables
230: 	idx_t bound_tables;
231: 	//! Whether or not the binder has any unplanned dependent joins that still need to be planned/flattened
232: 	bool has_unplanned_dependent_joins = false;
233: 	//! Whether or not outside dependent joins have been planned and flattened
234: 	bool is_outside_flattened = true;
235: 	//! What kind of node we are binding using this binder
236: 	BinderType binder_type = BinderType::REGULAR_BINDER;
237: 	//! Whether or not the binder can contain NULLs as the root of expressions
238: 	bool can_contain_nulls = false;
239: 	//! The root statement of the query that is currently being parsed
240: 	optional_ptr<SQLStatement> root_statement;
241: 	//! Binding mode
242: 	BindingMode mode = BindingMode::STANDARD_BINDING;
243: 	//! Table names extracted for BindingMode::EXTRACT_NAMES
244: 	unordered_set<string> table_names;
245: 	//! Replacement Scans extracted for BindingMode::EXTRACT_REPLACEMENT_SCANS
246: 	case_insensitive_map_t<unique_ptr<TableRef>> replacement_scans;
247: 	//! The set of bound views
248: 	reference_set_t<ViewCatalogEntry> bound_views;
249: 	//! Used to retrieve CatalogEntry's
250: 	CatalogEntryRetriever entry_retriever;
251: 	//! Unnamed subquery index
252: 	idx_t unnamed_subquery_index = 1;
253: 	//! Statement properties
254: 	StatementProperties prop;
255: 
256: private:
257: 	//! Get the root binder (binder with no parent)
258: 	Binder &GetRootBinder();
259: 	//! Determine the depth of the binder
260: 	idx_t GetBinderDepth() const;
261: 	//! Bind the expressions of generated columns to check for errors
262: 	void BindGeneratedColumns(BoundCreateTableInfo &info);
263: 	//! Bind the default values of the columns of a table
264: 	void BindDefaultValues(const ColumnList &columns, vector<unique_ptr<Expression>> &bound_defaults,
265: 	                       const string &catalog = "", const string &schema = "");
266: 	//! Bind a limit value (LIMIT or OFFSET)
267: 	BoundLimitNode BindLimitValue(OrderBinder &order_binder, unique_ptr<ParsedExpression> limit_val, bool is_percentage,
268: 	                              bool is_offset);
269: 
270: 	//! Move correlated expressions from the child binder to this binder
271: 	void MoveCorrelatedExpressions(Binder &other);
272: 
273: 	//! Tries to bind the table name with replacement scans
274: 	unique_ptr<BoundTableRef> BindWithReplacementScan(ClientContext &context, BaseTableRef &ref);
275: 
276: 	template <class T>
277: 	BoundStatement BindWithCTE(T &statement);
278: 	BoundStatement Bind(SelectStatement &stmt);
279: 	BoundStatement Bind(InsertStatement &stmt);
280: 	BoundStatement Bind(CopyStatement &stmt, CopyToType copy_to_type);
281: 	BoundStatement Bind(DeleteStatement &stmt);
282: 	BoundStatement Bind(UpdateStatement &stmt);
283: 	BoundStatement Bind(CreateStatement &stmt);
284: 	BoundStatement Bind(DropStatement &stmt);
285: 	BoundStatement Bind(AlterStatement &stmt);
286: 	BoundStatement Bind(PrepareStatement &stmt);
287: 	BoundStatement Bind(ExecuteStatement &stmt);
288: 	BoundStatement Bind(TransactionStatement &stmt);
289: 	BoundStatement Bind(PragmaStatement &stmt);
290: 	BoundStatement Bind(ExplainStatement &stmt);
291: 	BoundStatement Bind(VacuumStatement &stmt);
292: 	BoundStatement Bind(RelationStatement &stmt);
293: 	BoundStatement Bind(CallStatement &stmt);
294: 	BoundStatement Bind(ExportStatement &stmt);
295: 	BoundStatement Bind(ExtensionStatement &stmt);
296: 	BoundStatement Bind(SetStatement &stmt);
297: 	BoundStatement Bind(SetVariableStatement &stmt);
298: 	BoundStatement Bind(ResetVariableStatement &stmt);
299: 	BoundStatement Bind(LoadStatement &stmt);
300: 	BoundStatement Bind(LogicalPlanStatement &stmt);
301: 	BoundStatement Bind(AttachStatement &stmt);
302: 	BoundStatement Bind(DetachStatement &stmt);
303: 	BoundStatement Bind(CopyDatabaseStatement &stmt);
304: 	BoundStatement Bind(UpdateExtensionsStatement &stmt);
305: 
306: 	BoundStatement BindReturning(vector<unique_ptr<ParsedExpression>> returning_list, TableCatalogEntry &table,
307: 	                             const string &alias, idx_t update_table_index,
308: 	                             unique_ptr<LogicalOperator> child_operator, BoundStatement result);
309: 
310: 	unique_ptr<QueryNode> BindTableMacro(FunctionExpression &function, TableMacroCatalogEntry &macro_func, idx_t depth);
311: 
312: 	unique_ptr<BoundCTENode> BindMaterializedCTE(CommonTableExpressionMap &cte_map);
313: 	unique_ptr<BoundCTENode> BindCTE(CTENode &statement);
314: 	//! Materializes CTEs if this is expected to improve performance
315: 	bool OptimizeCTEs(QueryNode &node);
316: 
317: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
318: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
319: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
320: 	unique_ptr<BoundQueryNode> BindNode(CTENode &node);
321: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
322: 
323: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
324: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
325: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTENode &node);
326: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTENode &node, unique_ptr<LogicalOperator> base);
327: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
328: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
329: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
330: 
331: 	unique_ptr<BoundTableRef> BindJoin(Binder &parent, TableRef &ref);
332: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
333: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
334: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref, optional_ptr<CommonTableExpressionInfo> cte = nullptr);
335: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
336: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
337: 	unique_ptr<BoundTableRef> Bind(DelimGetRef &ref);
338: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
339: 	unique_ptr<BoundTableRef> Bind(ColumnDataRef &ref);
340: 	unique_ptr<BoundTableRef> Bind(PivotRef &expr);
341: 	unique_ptr<BoundTableRef> Bind(ShowRef &ref);
342: 
343: 	unique_ptr<SelectNode> BindPivot(PivotRef &expr, vector<unique_ptr<ParsedExpression>> all_columns);
344: 	unique_ptr<SelectNode> BindUnpivot(Binder &child_binder, PivotRef &expr,
345: 	                                   vector<unique_ptr<ParsedExpression>> all_columns,
346: 	                                   unique_ptr<ParsedExpression> &where_clause);
347: 	unique_ptr<BoundTableRef> BindBoundPivot(PivotRef &expr);
348: 	void ExtractUnpivotEntries(Binder &child_binder, PivotColumnEntry &entry, vector<UnpivotEntry> &unpivot_entries);
349: 	void ExtractUnpivotColumnName(ParsedExpression &expr, vector<string> &result);
350: 
351: 	bool BindTableFunctionParameters(TableFunctionCatalogEntry &table_function,
352: 	                                 vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
353: 	                                 vector<Value> &parameters, named_parameter_map_t &named_parameters,
354: 	                                 unique_ptr<BoundSubqueryRef> &subquery, ErrorData &error);
355: 	void BindTableInTableOutFunction(vector<unique_ptr<ParsedExpression>> &expressions,
356: 	                                 unique_ptr<BoundSubqueryRef> &subquery);
357: 	unique_ptr<LogicalOperator> BindTableFunction(TableFunction &function, vector<Value> parameters);
358: 	unique_ptr<LogicalOperator> BindTableFunctionInternal(TableFunction &table_function, const TableFunctionRef &ref,
359: 	                                                      vector<Value> parameters,
360: 	                                                      named_parameter_map_t named_parameters,
361: 	                                                      vector<LogicalType> input_table_types,
362: 	                                                      vector<string> input_table_names);
363: 
364: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
365: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
366: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
367: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
368: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
369: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
370: 	unique_ptr<LogicalOperator> CreatePlan(BoundColumnDataRef &ref);
371: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
372: 	unique_ptr<LogicalOperator> CreatePlan(BoundPivotRef &ref);
373: 	unique_ptr<LogicalOperator> CreatePlan(BoundDelimGetRef &ref);
374: 
375: 	BoundStatement BindCopyTo(CopyStatement &stmt, CopyToType copy_to_type);
376: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
377: 
378: 	void PrepareModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
379: 	void BindModifiers(BoundQueryNode &result, idx_t table_index, const vector<string> &names,
380: 	                   const vector<LogicalType> &sql_types, const SelectBindState &bind_state);
381: 
382: 	unique_ptr<BoundResultModifier> BindLimit(OrderBinder &order_binder, LimitModifier &limit_mod);
383: 	unique_ptr<BoundResultModifier> BindLimitPercent(OrderBinder &order_binder, LimitPercentModifier &limit_mod);
384: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
385: 
386: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
387: 
388: 	void PlanSubqueries(unique_ptr<Expression> &expr, unique_ptr<LogicalOperator> &root);
389: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
390: 	unique_ptr<LogicalOperator> PlanLateralJoin(unique_ptr<LogicalOperator> left, unique_ptr<LogicalOperator> right,
391: 	                                            vector<CorrelatedColumnInfo> &correlated_columns,
392: 	                                            JoinType join_type = JoinType::INNER,
393: 	                                            unique_ptr<Expression> condition = nullptr);
394: 
395: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,
396: 	                                                       vector<LogicalType> &target_types,
397: 	                                                       unique_ptr<LogicalOperator> op);
398: 
399: 	BindingAlias FindBinding(const string &using_column, const string &join_side);
400: 	bool TryFindBinding(const string &using_column, const string &join_side, BindingAlias &result);
401: 
402: 	void AddUsingBindingSet(unique_ptr<UsingColumnSet> set);
403: 	BindingAlias RetrieveUsingBinding(Binder &current_binder, optional_ptr<UsingColumnSet> current_set,
404: 	                                  const string &column_name, const string &join_side);
405: 
406: 	void AddCTEMap(CommonTableExpressionMap &cte_map);
407: 
408: 	void ExpandStarExpressions(vector<unique_ptr<ParsedExpression>> &select_list,
409: 	                           vector<unique_ptr<ParsedExpression>> &new_select_list);
410: 	void ExpandStarExpression(unique_ptr<ParsedExpression> expr, vector<unique_ptr<ParsedExpression>> &new_select_list);
411: 	bool FindStarExpression(unique_ptr<ParsedExpression> &expr, StarExpression **star, bool is_root, bool in_columns);
412: 	void ReplaceUnpackedStarExpression(unique_ptr<ParsedExpression> &expr,
413: 	                                   vector<unique_ptr<ParsedExpression>> &replacements);
414: 	void ReplaceStarExpression(unique_ptr<ParsedExpression> &expr, unique_ptr<ParsedExpression> &replacement);
415: 	void BindWhereStarExpression(unique_ptr<ParsedExpression> &expr);
416: 
417: 	//! If only a schema name is provided (e.g. "a.b") then figure out if "a" is a schema or a catalog name
418: 	void BindSchemaOrCatalog(string &catalog_name, string &schema_name);
419: 	const string BindCatalog(string &catalog_name);
420: 	SchemaCatalogEntry &BindCreateSchema(CreateInfo &info);
421: 
422: 	vector<CatalogSearchEntry> GetSearchPath(Catalog &catalog, const string &schema_name);
423: 
424: 	LogicalType BindLogicalTypeInternal(const LogicalType &type, optional_ptr<Catalog> catalog, const string &schema);
425: 
426: 	unique_ptr<BoundQueryNode> BindSelectNode(SelectNode &statement, unique_ptr<BoundTableRef> from_table);
427: 
428: 	unique_ptr<LogicalOperator> BindCopyDatabaseSchema(Catalog &source_catalog, const string &target_database_name);
429: 	unique_ptr<LogicalOperator> BindCopyDatabaseData(Catalog &source_catalog, const string &target_database_name);
430: 
431: 	unique_ptr<BoundTableRef> BindShowQuery(ShowRef &ref);
432: 	unique_ptr<BoundTableRef> BindShowTable(ShowRef &ref);
433: 	unique_ptr<BoundTableRef> BindSummarize(ShowRef &ref);
434: 
435: 	unique_ptr<LogicalOperator> UnionOperators(vector<unique_ptr<LogicalOperator>> nodes);
436: 
437: private:
438: 	Binder(ClientContext &context, shared_ptr<Binder> parent, BinderType binder_type);
439: };
440: 
441: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/parser/constraints/unique_constraint.cpp]
1: #include "duckdb/parser/constraints/unique_constraint.hpp"
2: 
3: #include "duckdb/parser/keyword_helper.hpp"
4: 
5: namespace duckdb {
6: 
7: UniqueConstraint::UniqueConstraint() : Constraint(ConstraintType::UNIQUE), index(DConstants::INVALID_INDEX) {
8: }
9: 
10: UniqueConstraint::UniqueConstraint(const LogicalIndex index, const bool is_primary_key)
11:     : Constraint(ConstraintType::UNIQUE), index(index), is_primary_key(is_primary_key) {
12: }
13: 
14: UniqueConstraint::UniqueConstraint(vector<string> columns, const bool is_primary_key)
15:     : Constraint(ConstraintType::UNIQUE), index(DConstants::INVALID_INDEX), columns(std::move(columns)),
16:       is_primary_key(is_primary_key) {
17: }
18: 
19: string UniqueConstraint::ToString() const {
20: 	string base = is_primary_key ? "PRIMARY KEY(" : "UNIQUE(";
21: 	for (idx_t i = 0; i < columns.size(); i++) {
22: 		if (i > 0) {
23: 			base += ", ";
24: 		}
25: 		base += KeywordHelper::WriteOptionallyQuoted(columns[i]);
26: 	}
27: 	return base + ")";
28: }
29: 
30: unique_ptr<Constraint> UniqueConstraint::Copy() const {
31: 	if (!HasIndex()) {
32: 		return make_uniq<UniqueConstraint>(columns, is_primary_key);
33: 	}
34: 
35: 	auto result = make_uniq<UniqueConstraint>(index, is_primary_key);
36: 	if (!columns.empty()) {
37: 		result->columns.push_back(columns[0]);
38: 	}
39: 	return std::move(result);
40: }
41: 
42: bool UniqueConstraint::IsPrimaryKey() const {
43: 	return is_primary_key;
44: }
45: 
46: bool UniqueConstraint::HasIndex() const {
47: 	return index.index != DConstants::INVALID_INDEX;
48: }
49: 
50: LogicalIndex UniqueConstraint::GetIndex() const {
51: 	if (!HasIndex()) {
52: 		throw InternalException("UniqueConstraint::GetIndex called on a unique constraint without an index");
53: 	}
54: 	return index;
55: }
56: 
57: void UniqueConstraint::SetIndex(const LogicalIndex new_index) {
58: 	D_ASSERT(new_index.index != DConstants::INVALID_INDEX);
59: 	index = new_index;
60: }
61: 
62: const vector<string> &UniqueConstraint::GetColumnNames() const {
63: 	D_ASSERT(!columns.empty());
64: 	return columns;
65: }
66: 
67: vector<string> &UniqueConstraint::GetColumnNamesMutable() {
68: 	D_ASSERT(!columns.empty());
69: 	return columns;
70: }
71: 
72: vector<LogicalIndex> UniqueConstraint::GetLogicalIndexes(const ColumnList &column_list) const {
73: 	if (HasIndex()) {
74: 		return {GetIndex()};
75: 	}
76: 
77: 	vector<LogicalIndex> indexes;
78: 	for (auto &col_name : GetColumnNames()) {
79: 		D_ASSERT(column_list.ColumnExists(col_name));
80: 		auto &col = column_list.GetColumn(col_name);
81: 		D_ASSERT(!col.Generated());
82: 		indexes.push_back(col.Logical());
83: 	}
84: 	return indexes;
85: }
86: 
87: string UniqueConstraint::GetName(const string &table_name) const {
88: 	auto type = IsPrimaryKey() ? IndexConstraintType::PRIMARY : IndexConstraintType::UNIQUE;
89: 	auto type_name = EnumUtil::ToString(type);
90: 
91: 	string name;
92: 	for (const auto &column_name : GetColumnNames()) {
93: 		name += "_" + column_name;
94: 	}
95: 	return type_name + "_" + table_name + name;
96: }
97: 
98: void UniqueConstraint::SetColumnName(const string &column_name) {
99: 	if (!columns.empty()) {
100: 		return;
101: 	}
102: 	columns.push_back(column_name);
103: }
104: 
105: } // namespace duckdb
[end of src/parser/constraints/unique_constraint.cpp]
[start of src/parser/transform/constraint/transform_constraint.cpp]
1: #include "duckdb/parser/column_definition.hpp"
2: #include "duckdb/parser/constraint.hpp"
3: #include "duckdb/parser/constraints/list.hpp"
4: #include "duckdb/parser/transformer.hpp"
5: 
6: namespace duckdb {
7: 
8: static void ParseSchemaTableNameFK(duckdb_libpgquery::PGRangeVar &input, ForeignKeyInfo &fk_info) {
9: 	if (input.catalogname) {
10: 		throw ParserException("FOREIGN KEY constraints cannot be defined cross-database");
11: 	}
12: 	fk_info.schema = input.schemaname ? input.schemaname : "";
13: 	fk_info.table = input.relname;
14: }
15: 
16: static bool ForeignKeyActionSupported(char action) {
17: 	switch (action) {
18: 	case PG_FKCONSTR_ACTION_NOACTION:
19: 	case PG_FKCONSTR_ACTION_RESTRICT:
20: 		return true;
21: 	case PG_FKCONSTR_ACTION_CASCADE:
22: 	case PG_FKCONSTR_ACTION_SETDEFAULT:
23: 	case PG_FKCONSTR_ACTION_SETNULL:
24: 		return false;
25: 	default:
26: 		D_ASSERT(false);
27: 	}
28: 	return false;
29: }
30: 
31: static unique_ptr<ForeignKeyConstraint>
32: TransformForeignKeyConstraint(duckdb_libpgquery::PGConstraint &constraint,
33:                               optional_ptr<const string> override_fk_column = nullptr) {
34: 	if (!ForeignKeyActionSupported(constraint.fk_upd_action) || !ForeignKeyActionSupported(constraint.fk_del_action)) {
35: 		throw ParserException("FOREIGN KEY constraints cannot use CASCADE, SET NULL or SET DEFAULT");
36: 	}
37: 
38: 	ForeignKeyInfo fk_info;
39: 	fk_info.type = ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE;
40: 	ParseSchemaTableNameFK(*constraint.pktable, fk_info);
41: 
42: 	vector<string> pk_columns;
43: 	vector<string> fk_columns;
44: 
45: 	if (override_fk_column) {
46: 		D_ASSERT(!constraint.fk_attrs);
47: 		fk_columns.emplace_back(*override_fk_column);
48: 
49: 	} else if (constraint.fk_attrs) {
50: 		for (auto kc = constraint.fk_attrs->head; kc; kc = kc->next) {
51: 			auto value = Transformer::PGPointerCast<duckdb_libpgquery::PGValue>(kc->data.ptr_value);
52: 			fk_columns.emplace_back(value->val.str);
53: 		}
54: 	}
55: 
56: 	if (constraint.pk_attrs) {
57: 		for (auto kc = constraint.pk_attrs->head; kc; kc = kc->next) {
58: 			auto value = Transformer::PGPointerCast<duckdb_libpgquery::PGValue>(kc->data.ptr_value);
59: 			pk_columns.emplace_back(value->val.str);
60: 		}
61: 	}
62: 	if (!pk_columns.empty() && pk_columns.size() != fk_columns.size()) {
63: 		throw ParserException("The number of referencing and referenced columns for foreign keys must be the same");
64: 	}
65: 	if (fk_columns.empty()) {
66: 		throw ParserException("The set of referencing and referenced columns for foreign keys must be not empty");
67: 	}
68: 	return make_uniq<ForeignKeyConstraint>(pk_columns, fk_columns, std::move(fk_info));
69: }
70: 
71: unique_ptr<Constraint> Transformer::TransformConstraint(duckdb_libpgquery::PGConstraint &constraint) {
72: 	switch (constraint.contype) {
73: 	case duckdb_libpgquery::PG_CONSTR_UNIQUE:
74: 	case duckdb_libpgquery::PG_CONSTR_PRIMARY: {
75: 		bool is_primary_key = constraint.contype == duckdb_libpgquery::PG_CONSTR_PRIMARY;
76: 		if (!constraint.keys) {
77: 			throw ParserException("UNIQUE USING INDEX is not supported");
78: 		}
79: 		vector<string> columns;
80: 		for (auto kc = constraint.keys->head; kc; kc = kc->next) {
81: 			auto value = PGPointerCast<duckdb_libpgquery::PGValue>(kc->data.ptr_value);
82: 			columns.emplace_back(value->val.str);
83: 		}
84: 		return make_uniq<UniqueConstraint>(columns, is_primary_key);
85: 	}
86: 	case duckdb_libpgquery::PG_CONSTR_CHECK: {
87: 		auto expression = TransformExpression(constraint.raw_expr);
88: 		if (expression->HasSubquery()) {
89: 			throw ParserException("subqueries prohibited in CHECK constraints");
90: 		}
91: 		return make_uniq<CheckConstraint>(TransformExpression(constraint.raw_expr));
92: 	}
93: 	case duckdb_libpgquery::PG_CONSTR_FOREIGN:
94: 		return TransformForeignKeyConstraint(constraint);
95: 	default:
96: 		throw NotImplementedException("Constraint type not handled yet!");
97: 	}
98: }
99: 
100: unique_ptr<Constraint> Transformer::TransformConstraint(duckdb_libpgquery::PGConstraint &constraint,
101:                                                         ColumnDefinition &column, idx_t index) {
102: 	switch (constraint.contype) {
103: 	case duckdb_libpgquery::PG_CONSTR_NOTNULL:
104: 		return make_uniq<NotNullConstraint>(LogicalIndex(index));
105: 	case duckdb_libpgquery::PG_CONSTR_CHECK:
106: 		return TransformConstraint(constraint);
107: 	case duckdb_libpgquery::PG_CONSTR_PRIMARY:
108: 		return make_uniq<UniqueConstraint>(LogicalIndex(index), true);
109: 	case duckdb_libpgquery::PG_CONSTR_UNIQUE:
110: 		return make_uniq<UniqueConstraint>(LogicalIndex(index), false);
111: 	case duckdb_libpgquery::PG_CONSTR_NULL:
112: 		return nullptr;
113: 	case duckdb_libpgquery::PG_CONSTR_GENERATED_VIRTUAL: {
114: 		if (column.HasDefaultValue()) {
115: 			throw InvalidInputException("\"%s\" has a DEFAULT value set, it can not become a GENERATED column",
116: 			                            column.Name());
117: 		}
118: 		column.SetGeneratedExpression(TransformExpression(constraint.raw_expr));
119: 		return nullptr;
120: 	}
121: 	case duckdb_libpgquery::PG_CONSTR_GENERATED_STORED:
122: 		throw InvalidInputException("Can not create a STORED generated column!");
123: 	case duckdb_libpgquery::PG_CONSTR_DEFAULT:
124: 		column.SetDefaultValue(TransformExpression(constraint.raw_expr));
125: 		return nullptr;
126: 	case duckdb_libpgquery::PG_CONSTR_COMPRESSION:
127: 		column.SetCompressionType(CompressionTypeFromString(constraint.compression_name));
128: 		if (column.CompressionType() == CompressionType::COMPRESSION_AUTO) {
129: 			throw ParserException("Unrecognized option for column compression, expected none, uncompressed, rle, "
130: 			                      "dictionary, pfor, bitpacking or fsst");
131: 		}
132: 		return nullptr;
133: 	case duckdb_libpgquery::PG_CONSTR_FOREIGN:
134: 		return TransformForeignKeyConstraint(constraint, &column.Name());
135: 	default:
136: 		throw NotImplementedException("Constraint not implemented!");
137: 	}
138: }
139: 
140: } // namespace duckdb
[end of src/parser/transform/constraint/transform_constraint.cpp]
[start of src/planner/binder/statement/bind_create_table.cpp]
1: #include "duckdb/parser/constraints/list.hpp"
2: #include "duckdb/parser/expression/cast_expression.hpp"
3: #include "duckdb/planner/binder.hpp"
4: #include "duckdb/planner/constraints/list.hpp"
5: #include "duckdb/planner/expression/bound_constant_expression.hpp"
6: #include "duckdb/planner/expression/bound_function_expression.hpp"
7: #include "duckdb/planner/expression_binder/check_binder.hpp"
8: #include "duckdb/planner/expression_binder/constant_binder.hpp"
9: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
10: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
11: #include "duckdb/catalog/dependency_manager.hpp"
12: #include "duckdb/function/table/table_scan.hpp"
13: #include "duckdb/planner/operator/logical_get.hpp"
14: #include "duckdb/common/string.hpp"
15: #include "duckdb/common/queue.hpp"
16: #include "duckdb/parser/expression/list.hpp"
17: #include "duckdb/common/index_map.hpp"
18: #include "duckdb/planner/expression_iterator.hpp"
19: #include "duckdb/planner/expression_binder/index_binder.hpp"
20: #include "duckdb/parser/parsed_data/create_index_info.hpp"
21: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
22: #include "duckdb/parser/parsed_expression_iterator.hpp"
23: #include "duckdb/storage/data_table.hpp"
24: 
25: namespace duckdb {
26: 
27: static void CreateColumnDependencyManager(BoundCreateTableInfo &info) {
28: 	auto &base = info.base->Cast<CreateTableInfo>();
29: 	for (auto &col : base.columns.Logical()) {
30: 		if (!col.Generated()) {
31: 			continue;
32: 		}
33: 		info.column_dependency_manager.AddGeneratedColumn(col, base.columns);
34: 	}
35: }
36: 
37: vector<unique_ptr<BoundConstraint>> Binder::BindConstraints(ClientContext &context,
38:                                                             const vector<unique_ptr<Constraint>> &constraints,
39:                                                             const string &table_name, const ColumnList &columns) {
40: 	auto binder = Binder::CreateBinder(context);
41: 	return binder->BindConstraints(constraints, table_name, columns);
42: }
43: 
44: vector<unique_ptr<BoundConstraint>> Binder::BindConstraints(const TableCatalogEntry &table) {
45: 	return BindConstraints(table.GetConstraints(), table.name, table.GetColumns());
46: }
47: 
48: vector<unique_ptr<BoundConstraint>> Binder::BindConstraints(const vector<unique_ptr<Constraint>> &constraints,
49:                                                             const string &table_name, const ColumnList &columns) {
50: 	vector<unique_ptr<BoundConstraint>> bound_constraints;
51: 	for (const auto &constr : constraints) {
52: 		bound_constraints.push_back(BindConstraint(*constr, table_name, columns));
53: 	}
54: 	return bound_constraints;
55: }
56: 
57: vector<unique_ptr<BoundConstraint>> Binder::BindNewConstraints(vector<unique_ptr<Constraint>> &constraints,
58:                                                                const string &table_name, const ColumnList &columns) {
59: 	auto bound_constraints = BindConstraints(constraints, table_name, columns);
60: 
61: 	// Handle PK and NOT NULL constraints.
62: 	bool has_primary_key = false;
63: 	physical_index_set_t not_null_columns;
64: 	vector<PhysicalIndex> primary_keys;
65: 
66: 	for (const auto &bound_constr : bound_constraints) {
67: 		switch (bound_constr->type) {
68: 		case ConstraintType::NOT_NULL: {
69: 			auto &not_null = bound_constr->Cast<BoundNotNullConstraint>();
70: 			not_null_columns.insert(not_null.index);
71: 			break;
72: 		}
73: 		case ConstraintType::UNIQUE: {
74: 			const auto &unique = bound_constr->Cast<BoundUniqueConstraint>();
75: 			if (unique.is_primary_key) {
76: 				if (has_primary_key) {
77: 					throw ParserException("table \"%s\" has more than one primary key", table_name);
78: 				}
79: 				has_primary_key = true;
80: 				primary_keys = unique.keys;
81: 			}
82: 			break;
83: 		}
84: 		default:
85: 			break;
86: 		}
87: 	}
88: 
89: 	if (has_primary_key) {
90: 		// Create a PK constraint, and a NOT NULL constraint for each indexed column.
91: 		for (auto &column_index : primary_keys) {
92: 			if (not_null_columns.count(column_index) != 0) {
93: 				continue;
94: 			}
95: 
96: 			auto logical_index = columns.PhysicalToLogical(column_index);
97: 			constraints.push_back(make_uniq<NotNullConstraint>(logical_index));
98: 			bound_constraints.push_back(make_uniq<BoundNotNullConstraint>(column_index));
99: 		}
100: 	}
101: 
102: 	return bound_constraints;
103: }
104: 
105: unique_ptr<BoundConstraint> BindCheckConstraint(Binder &binder, Constraint &constraint, const string &table,
106:                                                 const ColumnList &columns) {
107: 	auto bound_constraint = make_uniq<BoundCheckConstraint>();
108: 	auto &bound_check = bound_constraint->Cast<BoundCheckConstraint>();
109: 
110: 	// Bind the CHECK expression.
111: 	CheckBinder check_binder(binder, binder.context, table, columns, bound_check.bound_columns);
112: 	auto &check = constraint.Cast<CheckConstraint>();
113: 
114: 	// Create a copy of the unbound expression because binding can invalidate it.
115: 	auto unbound_expression = check.expression->Copy();
116: 
117: 	// Bind the constraint and reset the original expression.
118: 	bound_check.expression = check_binder.Bind(check.expression);
119: 	check.expression = std::move(unbound_expression);
120: 	return std::move(bound_constraint);
121: }
122: 
123: unique_ptr<BoundConstraint> Binder::BindUniqueConstraint(Constraint &constraint, const string &table,
124:                                                          const ColumnList &columns) {
125: 	auto &unique = constraint.Cast<UniqueConstraint>();
126: 
127: 	// Resolve the columns.
128: 	vector<PhysicalIndex> indexes;
129: 	physical_index_set_t index_set;
130: 
131: 	// HasIndex refers to a column index, not an index(-structure).
132: 	// If set, then the UNIQUE constraint is defined on a single column.
133: 	if (unique.HasIndex()) {
134: 		auto &col = columns.GetColumn(unique.GetIndex());
135: 		unique.SetColumnName(col.Name());
136: 		indexes.push_back(col.Physical());
137: 		index_set.insert(col.Physical());
138: 		return make_uniq<BoundUniqueConstraint>(std::move(indexes), std::move(index_set), unique.IsPrimaryKey());
139: 	}
140: 
141: 	// The UNIQUE constraint is defined on a list of columns.
142: 	for (auto &col_name : unique.GetColumnNames()) {
143: 		if (!columns.ColumnExists(col_name)) {
144: 			throw CatalogException("table \"%s\" does not have a column named \"%s\"", table, col_name);
145: 		}
146: 		auto &col = columns.GetColumn(col_name);
147: 		if (col.Generated()) {
148: 			throw BinderException("cannot create a PRIMARY KEY on a generated column: %s", col.GetName());
149: 		}
150: 
151: 		auto physical_index = col.Physical();
152: 		if (index_set.find(physical_index) != index_set.end()) {
153: 			throw ParserException("column \"%s\" appears twice in primary key constraint", col_name);
154: 		}
155: 		indexes.push_back(physical_index);
156: 		index_set.insert(physical_index);
157: 	}
158: 
159: 	return make_uniq<BoundUniqueConstraint>(std::move(indexes), std::move(index_set), unique.IsPrimaryKey());
160: }
161: 
162: unique_ptr<BoundConstraint> BindForeignKey(Constraint &constraint) {
163: 	auto &fk = constraint.Cast<ForeignKeyConstraint>();
164: 	D_ASSERT((fk.info.type == ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE && !fk.info.pk_keys.empty()) ||
165: 	         (fk.info.type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE && !fk.info.pk_keys.empty()) ||
166: 	         fk.info.type == ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE);
167: 
168: 	physical_index_set_t pk_key_set;
169: 	for (auto &pk_key : fk.info.pk_keys) {
170: 		if (pk_key_set.find(pk_key) != pk_key_set.end()) {
171: 			throw ParserException("duplicate primary key referenced in FOREIGN KEY constraint");
172: 		}
173: 		pk_key_set.insert(pk_key);
174: 	}
175: 
176: 	physical_index_set_t fk_key_set;
177: 	for (auto &fk_key : fk.info.fk_keys) {
178: 		if (fk_key_set.find(fk_key) != fk_key_set.end()) {
179: 			throw ParserException("duplicate key specified in FOREIGN KEY constraint");
180: 		}
181: 		fk_key_set.insert(fk_key);
182: 	}
183: 
184: 	return make_uniq<BoundForeignKeyConstraint>(fk.info, std::move(pk_key_set), std::move(fk_key_set));
185: }
186: 
187: unique_ptr<BoundConstraint> Binder::BindConstraint(Constraint &constraint, const string &table,
188:                                                    const ColumnList &columns) {
189: 	switch (constraint.type) {
190: 	case ConstraintType::CHECK: {
191: 		return BindCheckConstraint(*this, constraint, table, columns);
192: 	}
193: 	case ConstraintType::NOT_NULL: {
194: 		auto &not_null = constraint.Cast<NotNullConstraint>();
195: 		auto &col = columns.GetColumn(not_null.index);
196: 		return make_uniq<BoundNotNullConstraint>(col.Physical());
197: 	}
198: 	case ConstraintType::UNIQUE: {
199: 		return BindUniqueConstraint(constraint, table, columns);
200: 	}
201: 	case ConstraintType::FOREIGN_KEY: {
202: 		return BindForeignKey(constraint);
203: 	}
204: 	default:
205: 		throw NotImplementedException("unrecognized constraint type in bind");
206: 	}
207: }
208: 
209: void Binder::BindGeneratedColumns(BoundCreateTableInfo &info) {
210: 	auto &base = info.base->Cast<CreateTableInfo>();
211: 
212: 	vector<string> names;
213: 	vector<LogicalType> types;
214: 
215: 	D_ASSERT(base.type == CatalogType::TABLE_ENTRY);
216: 	for (auto &col : base.columns.Logical()) {
217: 		names.push_back(col.Name());
218: 		types.push_back(col.Type());
219: 	}
220: 	auto table_index = GenerateTableIndex();
221: 
222: 	// Create a new binder because we dont need (or want) these bindings in this scope
223: 	auto binder = Binder::CreateBinder(context);
224: 	binder->SetCatalogLookupCallback(entry_retriever.GetCallback());
225: 	binder->bind_context.AddGenericBinding(table_index, base.table, names, types);
226: 	auto expr_binder = ExpressionBinder(*binder, context);
227: 	ErrorData ignore;
228: 	auto table_binding = binder->bind_context.GetBinding(base.table, ignore);
229: 	D_ASSERT(table_binding && !ignore.HasError());
230: 
231: 	auto bind_order = info.column_dependency_manager.GetBindOrder(base.columns);
232: 	logical_index_set_t bound_indices;
233: 
234: 	while (!bind_order.empty()) {
235: 		auto i = bind_order.top();
236: 		bind_order.pop();
237: 		auto &col = base.columns.GetColumnMutable(i);
238: 
239: 		//! Already bound this previously
240: 		//! This can not be optimized out of the GetBindOrder function
241: 		//! These occurrences happen because we need to make sure that ALL dependencies of a column are resolved before
242: 		//! it gets resolved
243: 		if (bound_indices.count(i)) {
244: 			continue;
245: 		}
246: 		D_ASSERT(col.Generated());
247: 		auto expression = col.GeneratedExpression().Copy();
248: 
249: 		auto bound_expression = expr_binder.Bind(expression);
250: 		D_ASSERT(bound_expression);
251: 		if (bound_expression->HasSubquery()) {
252: 			throw BinderException("Failed to bind generated column '%s' because the expression contains a subquery",
253: 			                      col.Name());
254: 		}
255: 		if (col.Type().id() == LogicalTypeId::ANY) {
256: 			// Do this before changing the type, so we know it's the first time the type is set
257: 			col.ChangeGeneratedExpressionType(bound_expression->return_type);
258: 			col.SetType(bound_expression->return_type);
259: 
260: 			// Update the type in the binding, for future expansions
261: 			table_binding->types[i.index] = col.Type();
262: 		}
263: 		bound_indices.insert(i);
264: 	}
265: }
266: 
267: void Binder::BindDefaultValues(const ColumnList &columns, vector<unique_ptr<Expression>> &bound_defaults,
268:                                const string &catalog_name, const string &schema_p) {
269: 	string schema_name = schema_p;
270: 	if (schema_p.empty()) {
271: 		schema_name = DEFAULT_SCHEMA;
272: 	}
273: 
274: 	vector<CatalogSearchEntry> defaults_search_path;
275: 	defaults_search_path.emplace_back(catalog_name, schema_name);
276: 	if (schema_name != DEFAULT_SCHEMA) {
277: 		defaults_search_path.emplace_back(catalog_name, DEFAULT_SCHEMA);
278: 	}
279: 
280: 	auto default_binder = Binder::CreateBinder(context, *this);
281: 	default_binder->entry_retriever.SetSearchPath(std::move(defaults_search_path));
282: 
283: 	for (auto &column : columns.Physical()) {
284: 		unique_ptr<Expression> bound_default;
285: 		if (column.HasDefaultValue()) {
286: 			// we bind a copy of the DEFAULT value because binding is destructive
287: 			// and we want to keep the original expression around for serialization
288: 			auto default_copy = column.DefaultValue().Copy();
289: 			if (default_copy->HasParameter()) {
290: 				throw BinderException("DEFAULT values cannot contain parameters");
291: 			}
292: 			ConstantBinder default_value_binder(*default_binder, context, "DEFAULT value");
293: 			default_value_binder.target_type = column.Type();
294: 			bound_default = default_value_binder.Bind(default_copy);
295: 		} else {
296: 			// no default value specified: push a default value of constant null
297: 			bound_default = make_uniq<BoundConstantExpression>(Value(column.Type()));
298: 		}
299: 		bound_defaults.push_back(std::move(bound_default));
300: 	}
301: }
302: 
303: unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateInfo> info, SchemaCatalogEntry &schema) {
304: 	vector<unique_ptr<Expression>> bound_defaults;
305: 	return BindCreateTableInfo(std::move(info), schema, bound_defaults);
306: }
307: 
308: unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableCheckpoint(unique_ptr<CreateInfo> info,
309:                                                                    SchemaCatalogEntry &schema) {
310: 	auto result = make_uniq<BoundCreateTableInfo>(schema, std::move(info));
311: 	CreateColumnDependencyManager(*result);
312: 	return result;
313: }
314: 
315: void ExpressionContainsGeneratedColumn(const ParsedExpression &expr, const unordered_set<string> &gcols,
316:                                        bool &contains_gcol) {
317: 	if (contains_gcol) {
318: 		return;
319: 	}
320: 	if (expr.GetExpressionType() == ExpressionType::COLUMN_REF) {
321: 		auto &column_ref = expr.Cast<ColumnRefExpression>();
322: 		auto &name = column_ref.GetColumnName();
323: 		if (gcols.count(name)) {
324: 			contains_gcol = true;
325: 			return;
326: 		}
327: 	}
328: 	ParsedExpressionIterator::EnumerateChildren(
329: 	    expr, [&](const ParsedExpression &child) { ExpressionContainsGeneratedColumn(child, gcols, contains_gcol); });
330: }
331: 
332: static bool AnyConstraintReferencesGeneratedColumn(CreateTableInfo &table_info) {
333: 	unordered_set<string> generated_columns;
334: 	for (auto &col : table_info.columns.Logical()) {
335: 		if (!col.Generated()) {
336: 			continue;
337: 		}
338: 		generated_columns.insert(col.Name());
339: 	}
340: 	if (generated_columns.empty()) {
341: 		return false;
342: 	}
343: 
344: 	for (auto &constr : table_info.constraints) {
345: 		switch (constr->type) {
346: 		case ConstraintType::CHECK: {
347: 			auto &constraint = constr->Cast<CheckConstraint>();
348: 			auto &expr = constraint.expression;
349: 			bool contains_generated_column = false;
350: 			ExpressionContainsGeneratedColumn(*expr, generated_columns, contains_generated_column);
351: 			if (contains_generated_column) {
352: 				return true;
353: 			}
354: 			break;
355: 		}
356: 		case ConstraintType::NOT_NULL: {
357: 			auto &constraint = constr->Cast<NotNullConstraint>();
358: 			if (table_info.columns.GetColumn(constraint.index).Generated()) {
359: 				return true;
360: 			}
361: 			break;
362: 		}
363: 		case ConstraintType::UNIQUE: {
364: 			auto &constraint = constr->Cast<UniqueConstraint>();
365: 			if (!constraint.HasIndex()) {
366: 				for (auto &col : constraint.GetColumnNames()) {
367: 					if (generated_columns.count(col)) {
368: 						return true;
369: 					}
370: 				}
371: 			} else {
372: 				if (table_info.columns.GetColumn(constraint.GetIndex()).Generated()) {
373: 					return true;
374: 				}
375: 			}
376: 			break;
377: 		}
378: 		case ConstraintType::FOREIGN_KEY: {
379: 			// If it contained a generated column, an exception would have been thrown inside AddDataTableIndex earlier
380: 			break;
381: 		}
382: 		default: {
383: 			throw NotImplementedException("ConstraintType not implemented");
384: 		}
385: 		}
386: 	}
387: 	return false;
388: }
389: 
390: static void FindForeignKeyIndexes(const ColumnList &columns, const vector<string> &names,
391:                                   vector<PhysicalIndex> &indexes) {
392: 	D_ASSERT(indexes.empty());
393: 	D_ASSERT(!names.empty());
394: 	for (auto &name : names) {
395: 		if (!columns.ColumnExists(name)) {
396: 			throw BinderException("column \"%s\" named in key does not exist", name);
397: 		}
398: 		auto &column = columns.GetColumn(name);
399: 		if (column.Generated()) {
400: 			throw BinderException("Failed to create foreign key: referenced column \"%s\" is a generated column",
401: 			                      column.Name());
402: 		}
403: 		indexes.push_back(column.Physical());
404: 	}
405: }
406: 
407: static void FindMatchingPrimaryKeyColumns(const ColumnList &columns, const vector<unique_ptr<Constraint>> &constraints,
408:                                           ForeignKeyConstraint &fk) {
409: 	// find the matching primary key constraint
410: 	bool found_constraint = false;
411: 	// if no columns are defined, we will automatically try to bind to the primary key
412: 	bool find_primary_key = fk.pk_columns.empty();
413: 	for (auto &constr : constraints) {
414: 		if (constr->type != ConstraintType::UNIQUE) {
415: 			continue;
416: 		}
417: 		auto &unique = constr->Cast<UniqueConstraint>();
418: 		if (find_primary_key && !unique.IsPrimaryKey()) {
419: 			continue;
420: 		}
421: 		found_constraint = true;
422: 
423: 		vector<string> pk_names;
424: 		if (unique.HasIndex()) {
425: 			pk_names.push_back(columns.GetColumn(LogicalIndex(unique.GetIndex())).Name());
426: 		} else {
427: 			pk_names = unique.GetColumnNames();
428: 		}
429: 		if (find_primary_key) {
430: 			// found matching primary key
431: 			if (pk_names.size() != fk.fk_columns.size()) {
432: 				auto pk_name_str = StringUtil::Join(pk_names, ",");
433: 				auto fk_name_str = StringUtil::Join(fk.fk_columns, ",");
434: 				throw BinderException(
435: 				    "Failed to create foreign key: number of referencing (%s) and referenced columns (%s) differ",
436: 				    fk_name_str, pk_name_str);
437: 			}
438: 			fk.pk_columns = pk_names;
439: 			return;
440: 		}
441: 		if (pk_names.size() != fk.fk_columns.size()) {
442: 			// the number of referencing and referenced columns for foreign keys must be the same
443: 			continue;
444: 		}
445: 		bool equals = true;
446: 		for (idx_t i = 0; i < fk.pk_columns.size(); i++) {
447: 			if (!StringUtil::CIEquals(fk.pk_columns[i], pk_names[i])) {
448: 				equals = false;
449: 				break;
450: 			}
451: 		}
452: 		if (!equals) {
453: 			continue;
454: 		}
455: 		// found match
456: 		return;
457: 	}
458: 	// no match found! examine why
459: 	if (!found_constraint) {
460: 		// no unique constraint or primary key
461: 		string search_term = find_primary_key ? "primary key" : "primary key or unique constraint";
462: 		throw BinderException("Failed to create foreign key: there is no %s for referenced table \"%s\"", search_term,
463: 		                      fk.info.table);
464: 	}
465: 	// check if all the columns exist
466: 	for (auto &name : fk.pk_columns) {
467: 		bool found = columns.ColumnExists(name);
468: 		if (!found) {
469: 			throw BinderException(
470: 			    "Failed to create foreign key: referenced table \"%s\" does not have a column named \"%s\"",
471: 			    fk.info.table, name);
472: 		}
473: 	}
474: 	auto fk_names = StringUtil::Join(fk.pk_columns, ",");
475: 	throw BinderException("Failed to create foreign key: referenced table \"%s\" does not have a primary key or unique "
476: 	                      "constraint on the columns %s",
477: 	                      fk.info.table, fk_names);
478: }
479: 
480: static void CheckForeignKeyTypes(const ColumnList &pk_columns, const ColumnList &fk_columns, ForeignKeyConstraint &fk) {
481: 	D_ASSERT(fk.info.pk_keys.size() == fk.info.fk_keys.size());
482: 	for (idx_t c_idx = 0; c_idx < fk.info.pk_keys.size(); c_idx++) {
483: 		auto &pk_col = pk_columns.GetColumn(fk.info.pk_keys[c_idx]);
484: 		auto &fk_col = fk_columns.GetColumn(fk.info.fk_keys[c_idx]);
485: 		if (pk_col.Type() != fk_col.Type()) {
486: 			throw BinderException("Failed to create foreign key: incompatible types between column \"%s\" (\"%s\") and "
487: 			                      "column \"%s\" (\"%s\")",
488: 			                      pk_col.Name(), pk_col.Type().ToString(), fk_col.Name(), fk_col.Type().ToString());
489: 		}
490: 	}
491: }
492: 
493: static void BindCreateTableConstraints(CreateTableInfo &create_info, CatalogEntryRetriever &entry_retriever,
494:                                        SchemaCatalogEntry &schema) {
495: 	// If there is a foreign key constraint, resolve primary key column's index from primary key column's name
496: 	reference_set_t<SchemaCatalogEntry> fk_schemas;
497: 	for (idx_t i = 0; i < create_info.constraints.size(); i++) {
498: 		auto &cond = create_info.constraints[i];
499: 		if (cond->type != ConstraintType::FOREIGN_KEY) {
500: 			continue;
501: 		}
502: 		auto &fk = cond->Cast<ForeignKeyConstraint>();
503: 		if (fk.info.type != ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE) {
504: 			continue;
505: 		}
506: 		if (!fk.info.pk_keys.empty() && !fk.info.fk_keys.empty()) {
507: 			return;
508: 		}
509: 		D_ASSERT(fk.info.pk_keys.empty());
510: 		D_ASSERT(fk.info.fk_keys.empty());
511: 		FindForeignKeyIndexes(create_info.columns, fk.fk_columns, fk.info.fk_keys);
512: 
513: 		// Resolve the self-reference.
514: 		if (StringUtil::CIEquals(create_info.table, fk.info.table)) {
515: 			fk.info.type = ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE;
516: 			FindMatchingPrimaryKeyColumns(create_info.columns, create_info.constraints, fk);
517: 			FindForeignKeyIndexes(create_info.columns, fk.pk_columns, fk.info.pk_keys);
518: 			CheckForeignKeyTypes(create_info.columns, create_info.columns, fk);
519: 			continue;
520: 		}
521: 
522: 		// Resolve the table reference.
523: 		auto table_entry =
524: 		    entry_retriever.GetEntry(CatalogType::TABLE_ENTRY, INVALID_CATALOG, fk.info.schema, fk.info.table);
525: 		if (table_entry->type == CatalogType::VIEW_ENTRY) {
526: 			throw BinderException("cannot reference a VIEW with a FOREIGN KEY");
527: 		}
528: 
529: 		auto &pk_table_entry_ptr = table_entry->Cast<TableCatalogEntry>();
530: 		if (&pk_table_entry_ptr.schema != &schema) {
531: 			throw BinderException("Creating foreign keys across different schemas or catalogs is not supported");
532: 		}
533: 		FindMatchingPrimaryKeyColumns(pk_table_entry_ptr.GetColumns(), pk_table_entry_ptr.GetConstraints(), fk);
534: 		FindForeignKeyIndexes(pk_table_entry_ptr.GetColumns(), fk.pk_columns, fk.info.pk_keys);
535: 		CheckForeignKeyTypes(pk_table_entry_ptr.GetColumns(), create_info.columns, fk);
536: 		auto &storage = pk_table_entry_ptr.GetStorage();
537: 
538: 		if (!storage.HasForeignKeyIndex(fk.info.pk_keys, ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE)) {
539: 			auto fk_column_names = StringUtil::Join(fk.pk_columns, ",");
540: 			throw BinderException("Failed to create foreign key on %s(%s): no UNIQUE or PRIMARY KEY constraint "
541: 			                      "present on these columns",
542: 			                      pk_table_entry_ptr.name, fk_column_names);
543: 		}
544: 
545: 		D_ASSERT(fk.info.pk_keys.size() == fk.info.fk_keys.size());
546: 		D_ASSERT(fk.info.pk_keys.size() == fk.pk_columns.size());
547: 		D_ASSERT(fk.info.fk_keys.size() == fk.fk_columns.size());
548: 	}
549: }
550: 
551: unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateInfo> info, SchemaCatalogEntry &schema,
552:                                                              vector<unique_ptr<Expression>> &bound_defaults) {
553: 	auto &base = info->Cast<CreateTableInfo>();
554: 	auto result = make_uniq<BoundCreateTableInfo>(schema, std::move(info));
555: 	auto &dependencies = result->dependencies;
556: 
557: 	vector<unique_ptr<BoundConstraint>> bound_constraints;
558: 	if (base.query) {
559: 		// construct the result object
560: 		auto query_obj = Bind(*base.query);
561: 		base.query.reset();
562: 		result->query = std::move(query_obj.plan);
563: 
564: 		// construct the set of columns based on the names and types of the query
565: 		auto &names = query_obj.names;
566: 		auto &sql_types = query_obj.types;
567: 		// e.g. create table (col1 ,col2) as QUERY
568: 		// col1 and col2 are the target_col_names
569: 		auto target_col_names = base.columns.GetColumnNames();
570: 		// TODO check  types and target_col_names are mismatch in size
571: 		D_ASSERT(names.size() == sql_types.size());
572: 		base.columns.SetAllowDuplicates(true);
573: 		if (!target_col_names.empty()) {
574: 			if (target_col_names.size() > sql_types.size()) {
575: 				throw BinderException("Target table has more colum names than query result.");
576: 			} else if (target_col_names.size() < sql_types.size()) {
577: 				// filled the target_col_names with the name of query names
578: 				for (idx_t i = target_col_names.size(); i < sql_types.size(); i++) {
579: 					target_col_names.push_back(names[i]);
580: 				}
581: 			}
582: 			ColumnList new_colums;
583: 			for (idx_t i = 0; i < target_col_names.size(); i++) {
584: 				new_colums.AddColumn(ColumnDefinition(target_col_names[i], sql_types[i]));
585: 			}
586: 			base.columns = std::move(new_colums);
587: 		} else {
588: 			for (idx_t i = 0; i < names.size(); i++) {
589: 				base.columns.AddColumn(ColumnDefinition(names[i], sql_types[i]));
590: 			}
591: 		}
592: 		// bind collations to detect any unsupported collation errors
593: 		for (idx_t i = 0; i < base.columns.PhysicalColumnCount(); i++) {
594: 			auto &column = base.columns.GetColumnMutable(PhysicalIndex(i));
595: 			if (column.Type().id() == LogicalTypeId::VARCHAR) {
596: 				ExpressionBinder::TestCollation(context, StringType::GetCollation(column.Type()));
597: 			}
598: 			BindLogicalType(column.TypeMutable(), &result->schema.catalog, result->schema.name);
599: 		}
600: 	} else {
601: 		SetCatalogLookupCallback([&dependencies, &schema](CatalogEntry &entry) {
602: 			if (&schema.ParentCatalog() != &entry.ParentCatalog()) {
603: 				// Don't register dependencies between catalogs
604: 				return;
605: 			}
606: 			dependencies.AddDependency(entry);
607: 		});
608: 		CreateColumnDependencyManager(*result);
609: 		// bind the generated column expressions
610: 		BindGeneratedColumns(*result);
611: 		// bind any constraints
612: 
613: 		// bind collations to detect any unsupported collation errors
614: 		for (idx_t i = 0; i < base.columns.PhysicalColumnCount(); i++) {
615: 			auto &column = base.columns.GetColumnMutable(PhysicalIndex(i));
616: 			if (column.Type().id() == LogicalTypeId::VARCHAR) {
617: 				ExpressionBinder::TestCollation(context, StringType::GetCollation(column.Type()));
618: 			}
619: 			BindLogicalType(column.TypeMutable(), &result->schema.catalog, result->schema.name);
620: 		}
621: 		BindCreateTableConstraints(base, entry_retriever, schema);
622: 
623: 		if (AnyConstraintReferencesGeneratedColumn(base)) {
624: 			throw BinderException("Constraints on generated columns are not supported yet");
625: 		}
626: 		bound_constraints = BindNewConstraints(base.constraints, base.table, base.columns);
627: 		// bind the default values
628: 		auto &catalog_name = schema.ParentCatalog().GetName();
629: 		auto &schema_name = schema.name;
630: 		BindDefaultValues(base.columns, bound_defaults, catalog_name, schema_name);
631: 	}
632: 
633: 	if (base.columns.PhysicalColumnCount() == 0) {
634: 		throw BinderException("Creating a table without physical (non-generated) columns is not supported");
635: 	}
636: 
637: 	result->dependencies.VerifyDependencies(schema.catalog, result->Base().table);
638: 
639: 	auto &properties = GetStatementProperties();
640: 	properties.allow_stream_result = false;
641: 	return result;
642: }
643: 
644: unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateInfo> info) {
645: 	auto &base = info->Cast<CreateTableInfo>();
646: 	auto &schema = BindCreateSchema(base);
647: 	return BindCreateTableInfo(std::move(info), schema);
648: }
649: 
650: } // namespace duckdb
[end of src/planner/binder/statement/bind_create_table.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: