diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp
index 59469812eca9..4d4f21b44858 100644
--- a/src/include/duckdb/planner/binder.hpp
+++ b/src/include/duckdb/planner/binder.hpp
@@ -63,6 +63,8 @@ class Binder {
 	ClientContext &context;
 	//! A mapping of names to common table expressions
 	unordered_map<string, CommonTableExpressionInfo *> CTE_bindings;
+	//! The CTEs that have already been bound
+	unordered_set<CommonTableExpressionInfo*> bound_ctes;
 	//! The bind context
 	BindContext bind_context;
 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
@@ -105,6 +107,8 @@ class Binder {
 	//! Find a common table expression by name; returns nullptr if none exists
 	CommonTableExpressionInfo *FindCTE(const string &name, bool skip = false);
 
+	bool CTEIsAlreadyBound(CommonTableExpressionInfo* cte);
+
 	void PushExpressionBinder(ExpressionBinder *binder);
 	void PopExpressionBinder();
 	void SetActiveBinder(ExpressionBinder *binder);
@@ -175,7 +179,7 @@ class Binder {
 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
 	unique_ptr<BoundTableRef> Bind(CrossProductRef &ref);
 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
-	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref);
+	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte = nullptr);
 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
diff --git a/src/planner/binder.cpp b/src/planner/binder.cpp
index 807bb6ce7505..8725c5071c84 100644
--- a/src/planner/binder.cpp
+++ b/src/planner/binder.cpp
@@ -108,6 +108,7 @@ unique_ptr<LogicalOperator> Binder::CreatePlan(BoundQueryNode &node) {
 		throw Exception("Unsupported bound query node type");
 	}
 }
+
 unique_ptr<BoundTableRef> Binder::Bind(TableRef &ref) {
 	unique_ptr<BoundTableRef> result;
 	switch (ref.type) {
@@ -199,6 +200,16 @@ CommonTableExpressionInfo *Binder::FindCTE(const string &name, bool skip) {
 	return nullptr;
 }
 
+bool Binder::CTEIsAlreadyBound(CommonTableExpressionInfo* cte) {
+	if (bound_ctes.find(cte) != bound_ctes.end()) {
+		return true;
+	}
+	if (parent && inherit_ctes) {
+		return parent->CTEIsAlreadyBound(cte);
+	}
+	return false;
+}
+
 idx_t Binder::GenerateTableIndex() {
 	if (parent) {
 		return parent->GenerateTableIndex();
diff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp
index 509c5e1d094d..bbda544daae1 100644
--- a/src/planner/binder/tableref/bind_basetableref.cpp
+++ b/src/planner/binder/tableref/bind_basetableref.cpp
@@ -20,6 +20,9 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {
 		// Check if there is a CTE binding in the BindContext
 		auto ctebinding = bind_context.GetCTEBinding(ref.table_name);
 		if (!ctebinding) {
+			if (CTEIsAlreadyBound(cte)) {
+				throw BinderException("Circular reference to CTE \"%s\", use WITH RECURSIVE to use recursive CTEs", ref.table_name);
+			}
 			// Move CTE to subquery and bind recursively
 			SubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(cte->query->Copy()));
 			subquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;
@@ -31,7 +34,7 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {
 					subquery.column_name_alias.push_back(ref.column_name_alias[i]);
 				}
 			}
-			return Bind(subquery);
+			return Bind(subquery, cte);
 		} else {
 			// There is a CTE binding in the BindContext.
 			// This can only be the case if there is a recursive CTE present.
diff --git a/src/planner/binder/tableref/bind_subqueryref.cpp b/src/planner/binder/tableref/bind_subqueryref.cpp
index d89fba9fc659..5f61104941f4 100644
--- a/src/planner/binder/tableref/bind_subqueryref.cpp
+++ b/src/planner/binder/tableref/bind_subqueryref.cpp
@@ -4,8 +4,11 @@
 
 namespace duckdb {
 
-unique_ptr<BoundTableRef> Binder::Bind(SubqueryRef &ref) {
+unique_ptr<BoundTableRef> Binder::Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte) {
 	auto binder = make_unique<Binder>(context, this);
+	if (cte) {
+		binder->bound_ctes.insert(cte);
+	}
 	binder->alias = ref.alias;
 	for (auto &cte_it : ref.subquery->cte_map) {
 		binder->AddCTE(cte_it.first, cte_it.second.get());
