{
  "repo": "duckdb/duckdb",
  "pull_number": 1278,
  "instance_id": "duckdb__duckdb-1278",
  "issue_numbers": [
    "1248"
  ],
  "base_commit": "8cf7abc06649953b89f54e349f1df34b7840cbe1",
  "patch": "diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 59469812eca9..4d4f21b44858 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -63,6 +63,8 @@ class Binder {\n \tClientContext &context;\n \t//! A mapping of names to common table expressions\n \tunordered_map<string, CommonTableExpressionInfo *> CTE_bindings;\n+\t//! The CTEs that have already been bound\n+\tunordered_set<CommonTableExpressionInfo*> bound_ctes;\n \t//! The bind context\n \tBindContext bind_context;\n \t//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a\n@@ -105,6 +107,8 @@ class Binder {\n \t//! Find a common table expression by name; returns nullptr if none exists\n \tCommonTableExpressionInfo *FindCTE(const string &name, bool skip = false);\n \n+\tbool CTEIsAlreadyBound(CommonTableExpressionInfo* cte);\n+\n \tvoid PushExpressionBinder(ExpressionBinder *binder);\n \tvoid PopExpressionBinder();\n \tvoid SetActiveBinder(ExpressionBinder *binder);\n@@ -175,7 +179,7 @@ class Binder {\n \tunique_ptr<BoundTableRef> Bind(BaseTableRef &ref);\n \tunique_ptr<BoundTableRef> Bind(CrossProductRef &ref);\n \tunique_ptr<BoundTableRef> Bind(JoinRef &ref);\n-\tunique_ptr<BoundTableRef> Bind(SubqueryRef &ref);\n+\tunique_ptr<BoundTableRef> Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte = nullptr);\n \tunique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);\n \tunique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);\n \tunique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);\ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex 807bb6ce7505..8725c5071c84 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -108,6 +108,7 @@ unique_ptr<LogicalOperator> Binder::CreatePlan(BoundQueryNode &node) {\n \t\tthrow Exception(\"Unsupported bound query node type\");\n \t}\n }\n+\n unique_ptr<BoundTableRef> Binder::Bind(TableRef &ref) {\n \tunique_ptr<BoundTableRef> result;\n \tswitch (ref.type) {\n@@ -199,6 +200,16 @@ CommonTableExpressionInfo *Binder::FindCTE(const string &name, bool skip) {\n \treturn nullptr;\n }\n \n+bool Binder::CTEIsAlreadyBound(CommonTableExpressionInfo* cte) {\n+\tif (bound_ctes.find(cte) != bound_ctes.end()) {\n+\t\treturn true;\n+\t}\n+\tif (parent && inherit_ctes) {\n+\t\treturn parent->CTEIsAlreadyBound(cte);\n+\t}\n+\treturn false;\n+}\n+\n idx_t Binder::GenerateTableIndex() {\n \tif (parent) {\n \t\treturn parent->GenerateTableIndex();\ndiff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex 509c5e1d094d..bbda544daae1 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -20,6 +20,9 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \t\t// Check if there is a CTE binding in the BindContext\n \t\tauto ctebinding = bind_context.GetCTEBinding(ref.table_name);\n \t\tif (!ctebinding) {\n+\t\t\tif (CTEIsAlreadyBound(cte)) {\n+\t\t\t\tthrow BinderException(\"Circular reference to CTE \\\"%s\\\", use WITH RECURSIVE to use recursive CTEs\", ref.table_name);\n+\t\t\t}\n \t\t\t// Move CTE to subquery and bind recursively\n \t\t\tSubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(cte->query->Copy()));\n \t\t\tsubquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;\n@@ -31,7 +34,7 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \t\t\t\t\tsubquery.column_name_alias.push_back(ref.column_name_alias[i]);\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn Bind(subquery);\n+\t\t\treturn Bind(subquery, cte);\n \t\t} else {\n \t\t\t// There is a CTE binding in the BindContext.\n \t\t\t// This can only be the case if there is a recursive CTE present.\ndiff --git a/src/planner/binder/tableref/bind_subqueryref.cpp b/src/planner/binder/tableref/bind_subqueryref.cpp\nindex d89fba9fc659..5f61104941f4 100644\n--- a/src/planner/binder/tableref/bind_subqueryref.cpp\n+++ b/src/planner/binder/tableref/bind_subqueryref.cpp\n@@ -4,8 +4,11 @@\n \n namespace duckdb {\n \n-unique_ptr<BoundTableRef> Binder::Bind(SubqueryRef &ref) {\n+unique_ptr<BoundTableRef> Binder::Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte) {\n \tauto binder = make_unique<Binder>(context, this);\n+\tif (cte) {\n+\t\tbinder->bound_ctes.insert(cte);\n+\t}\n \tbinder->alias = ref.alias;\n \tfor (auto &cte_it : ref.subquery->cte_map) {\n \t\tbinder->AddCTE(cte_it.first, cte_it.second.get());\n",
  "test_patch": "diff --git a/test/issues/general/test_1248.test b/test/issues/general/test_1248.test\nnew file mode 100644\nindex 000000000000..22fddd925012\n--- /dev/null\n+++ b/test/issues/general/test_1248.test\n@@ -0,0 +1,106 @@\n+# name: test/issues/general/test_1248.test\n+# description: Issue 1248: Segmentation fault on subselects with \"recursive\"\n+# group: [general]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement error\n+with test(round) as (\n+    select 0\n+    union all\n+    select round+1 from test where round <= 20\n+)\n+select test.round\n+from\n+    (select round from test limit 1) as subselect, \n+    test;\n+\n+query I\n+with test(round) as (\n+    select 0\n+)\n+select test.round\n+from\n+    (select round from test limit 1) as subselect, \n+    test;\n+----\n+0\n+\n+query II\n+with test(round) as (\n+    select 0\n+)\n+select *\n+from\n+    test t1,\n+    test t2;\n+----\n+0\t0\n+\n+query I\n+with recursive test(round) as (\n+    select 0\n+    union all\n+    select round+1 from test where round <= 20\n+)\n+select test.round\n+from\n+    test;\n+----\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10\n+11\n+12\n+13\n+14\n+15\n+16\n+17\n+18\n+19\n+20\n+21\n+\n+query II\n+with recursive test(round) as (\n+    select 0\n+    union all\n+    select round+1 from test where round <= 20\n+)\n+select *\n+from\n+    (select round from test limit 1) as subselect, \n+    test;\n+----\n+0\t0\n+0\t1\n+0\t2\n+0\t3\n+0\t4\n+0\t5\n+0\t6\n+0\t7\n+0\t8\n+0\t9\n+0\t10\n+0\t11\n+0\t12\n+0\t13\n+0\t14\n+0\t15\n+0\t16\n+0\t17\n+0\t18\n+0\t19\n+0\t20\n+0\t21\n",
  "problem_statement": "Segmentation fault on subselects with \"recursive\"\nHi,\r\n\r\nExpected: `\"Error: near line 1: Catalog Error: Table with name test does not exist!\"` (because it should be `with recursive test(...)`)\r\n\r\nGot: Segmentation fault.\r\n\r\n### Query to reproduce\r\n\r\n```\r\nwith test(round) as (\r\n    select 0\r\n    union all\r\n    select round+1 from test where round <= 20\r\n)\r\n\r\nselect test.round\r\nfrom\r\n    -- delete the subselect line and it gives the expected error\r\n    (select round from test limit 1) as subselect, \r\n    test;\r\n```\n",
  "hints_text": "This looks like an infinite recursion in `FindCTE`",
  "created_at": "2021-01-08T17:12:52Z"
}