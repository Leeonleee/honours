You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Segmentation fault on subselects with "recursive"
Hi,

Expected: `"Error: near line 1: Catalog Error: Table with name test does not exist!"` (because it should be `with recursive test(...)`)

Got: Segmentation fault.

### Query to reproduce

```
with test(round) as (
    select 0
    union all
    select round+1 from test where round <= 20
)

select test.round
from
    -- delete the subselect line and it gives the expected error
    (select round from test limit 1) as subselect, 
    test;
```

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/parser/column_definition.hpp"
13: #include "duckdb/parser/tokens.hpp"
14: #include "duckdb/planner/bind_context.hpp"
15: #include "duckdb/planner/bound_tokens.hpp"
16: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
17: #include "duckdb/planner/logical_operator.hpp"
18: #include "duckdb/planner/bound_statement.hpp"
19: 
20: namespace duckdb {
21: class BoundResultModifier;
22: class ClientContext;
23: class ExpressionBinder;
24: class LimitModifier;
25: class OrderBinder;
26: class TableCatalogEntry;
27: class ViewCatalogEntry;
28: 
29: struct CreateInfo;
30: struct BoundCreateTableInfo;
31: struct BoundCreateFunctionInfo;
32: struct CommonTableExpressionInfo;
33: 
34: struct CorrelatedColumnInfo {
35: 	ColumnBinding binding;
36: 	LogicalType type;
37: 	string name;
38: 	idx_t depth;
39: 
40: 	CorrelatedColumnInfo(BoundColumnRefExpression &expr)
41: 	    : binding(expr.binding), type(expr.return_type), name(expr.GetName()), depth(expr.depth) {
42: 	}
43: 
44: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
45: 		return binding == rhs.binding;
46: 	}
47: };
48: 
49: //! Bind the parsed query tree to the actual columns present in the catalog.
50: /*!
51:   The binder is responsible for binding tables and columns to actual physical
52:   tables and columns in the catalog. In the process, it also resolves types of
53:   all expressions.
54: */
55: class Binder {
56: 	friend class ExpressionBinder;
57: 	friend class RecursiveSubqueryPlanner;
58: 
59: public:
60: 	Binder(ClientContext &context, Binder *parent = nullptr, bool inherit_ctes = true);
61: 
62: 	//! The client context
63: 	ClientContext &context;
64: 	//! A mapping of names to common table expressions
65: 	unordered_map<string, CommonTableExpressionInfo *> CTE_bindings;
66: 	//! The bind context
67: 	BindContext bind_context;
68: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
69: 	//! vector)
70: 	vector<CorrelatedColumnInfo> correlated_columns;
71: 	//! The set of parameter expressions bound by this binder
72: 	vector<BoundParameterExpression *> *parameters;
73: 	//! Whether or not the bound statement is read-only
74: 	bool read_only;
75: 	//! Whether or not the statement requires a valid transaction to run
76: 	bool requires_valid_transaction;
77: 	//! Whether or not the statement can be streamed to the client
78: 	bool allow_stream_result;
79: 	//! The alias for the currently processing subquery, if it exists
80: 	string alias;
81: 	//! Macro parameter bindings (if any)
82: 	MacroBinding *macro_binding = nullptr;
83: 
84: public:
85: 	BoundStatement Bind(SQLStatement &statement);
86: 	BoundStatement Bind(QueryNode &node);
87: 
88: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
89: 	void BindCreateViewInfo(CreateViewInfo &base);
90: 	SchemaCatalogEntry *BindSchema(CreateInfo &info);
91: 	SchemaCatalogEntry *BindCreateFunctionInfo(CreateInfo &info);
92: 
93: 	//! Check usage, and cast named parameters to their types
94: 	static void BindNamedParameters(unordered_map<string, LogicalType> &types, unordered_map<string, Value> &values,
95: 	                                QueryErrorContext &error_context, string &func_name);
96: 
97: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
98: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
99: 
100: 	//! Generates an unused index for a table
101: 	idx_t GenerateTableIndex();
102: 
103: 	//! Add a common table expression to the binder
104: 	void AddCTE(const string &name, CommonTableExpressionInfo *cte);
105: 	//! Find a common table expression by name; returns nullptr if none exists
106: 	CommonTableExpressionInfo *FindCTE(const string &name, bool skip = false);
107: 
108: 	void PushExpressionBinder(ExpressionBinder *binder);
109: 	void PopExpressionBinder();
110: 	void SetActiveBinder(ExpressionBinder *binder);
111: 	ExpressionBinder *GetActiveBinder();
112: 	bool HasActiveBinder();
113: 
114: 	vector<ExpressionBinder *> &GetActiveBinders();
115: 
116: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
117: 	//! Add a correlated column to this binder (if it does not exist)
118: 	void AddCorrelatedColumn(CorrelatedColumnInfo info);
119: 
120: 	string FormatError(ParsedExpression &expr_context, string message);
121: 	string FormatError(TableRef &ref_context, string message);
122: 	string FormatError(idx_t query_location, string message);
123: 
124: private:
125: 	//! The parent binder (if any)
126: 	Binder *parent;
127: 	//! The vector of active binders
128: 	vector<ExpressionBinder *> active_binders;
129: 	//! The count of bound_tables
130: 	idx_t bound_tables;
131: 	//! Whether or not the binder has any unplanned subqueries that still need to be planned
132: 	bool has_unplanned_subqueries = false;
133: 	//! Whether or not subqueries should be planned already
134: 	bool plan_subquery = true;
135: 	//! Whether CTEs should reference the parent binder (if it exists)
136: 	bool inherit_ctes = true;
137: 	//! The root statement of the query that is currently being parsed
138: 	SQLStatement *root_statement = nullptr;
139: 
140: private:
141: 	//! Bind the default values of the columns of a table
142: 	void BindDefaultValues(vector<ColumnDefinition> &columns, vector<unique_ptr<Expression>> &bound_defaults);
143: 
144: 	//! Move correlated expressions from the child binder to this binder
145: 	void MoveCorrelatedExpressions(Binder &other);
146: 
147: 	BoundStatement Bind(SelectStatement &stmt);
148: 	BoundStatement Bind(InsertStatement &stmt);
149: 	BoundStatement Bind(CopyStatement &stmt);
150: 	BoundStatement Bind(DeleteStatement &stmt);
151: 	BoundStatement Bind(UpdateStatement &stmt);
152: 	BoundStatement Bind(CreateStatement &stmt);
153: 	BoundStatement Bind(DropStatement &stmt);
154: 	BoundStatement Bind(AlterStatement &stmt);
155: 	BoundStatement Bind(TransactionStatement &stmt);
156: 	BoundStatement Bind(PragmaStatement &stmt);
157: 	BoundStatement Bind(ExplainStatement &stmt);
158: 	BoundStatement Bind(VacuumStatement &stmt);
159: 	BoundStatement Bind(RelationStatement &stmt);
160: 	BoundStatement Bind(ShowStatement &stmt);
161: 	BoundStatement Bind(CallStatement &stmt);
162: 	BoundStatement Bind(ExportStatement &stmt);
163: 
164: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
165: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
166: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
167: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
168: 
169: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
170: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
171: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
172: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
173: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
174: 
175: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
176: 	unique_ptr<BoundTableRef> Bind(CrossProductRef &ref);
177: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
178: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref);
179: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
180: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
181: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
182: 
183: 	bool BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
184: 	                            vector<Value> &parameters, unordered_map<string, Value> &named_parameters,
185: 	                            string &error);
186: 
187: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
188: 	unique_ptr<LogicalOperator> CreatePlan(BoundCrossProductRef &ref);
189: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
190: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
191: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
192: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
193: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
194: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
195: 
196: 	unique_ptr<LogicalOperator> BindTable(TableCatalogEntry &table, BaseTableRef &ref);
197: 	unique_ptr<LogicalOperator> BindView(ViewCatalogEntry &view, BaseTableRef &ref);
198: 	unique_ptr<LogicalOperator> BindTableOrView(BaseTableRef &ref);
199: 
200: 	BoundStatement BindCopyTo(CopyStatement &stmt);
201: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
202: 
203: 	void BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
204: 	void BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index);
205: 
206: 	unique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);
207: 	unique_ptr<Expression> BindFilter(unique_ptr<ParsedExpression> condition);
208: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
209: 
210: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
211: 
212: 	void PlanSubqueries(unique_ptr<Expression> *expr, unique_ptr<LogicalOperator> *root);
213: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
214: 
215: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,
216: 	                                                       vector<LogicalType> &target_types,
217: 	                                                       unique_ptr<LogicalOperator> op);
218: };
219: 
220: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/planner/binder.cpp]
1: #include "duckdb/planner/binder.hpp"
2: 
3: #include "duckdb/parser/statement/list.hpp"
4: #include "duckdb/planner/bound_query_node.hpp"
5: #include "duckdb/planner/bound_tableref.hpp"
6: #include "duckdb/planner/expression.hpp"
7: #include "duckdb/planner/operator/logical_sample.hpp"
8: 
9: #include <algorithm>
10: 
11: namespace duckdb {
12: 
13: Binder::Binder(ClientContext &context, Binder *parent_, bool inherit_ctes_)
14:     : context(context), read_only(true), requires_valid_transaction(true), allow_stream_result(false), parent(parent_),
15:       bound_tables(0), inherit_ctes(inherit_ctes_) {
16: 	if (parent_) {
17: 		// We have to inherit macro parameter bindings from the parent binder, if there is a parent.
18: 		macro_binding = parent_->macro_binding;
19: 		if (inherit_ctes_) {
20: 			// We have to inherit CTE bindings from the parent bind_context, if there is a parent.
21: 			bind_context.SetCTEBindings(parent_->bind_context.GetCTEBindings());
22: 			bind_context.cte_references = parent_->bind_context.cte_references;
23: 			parameters = parent_->parameters;
24: 		}
25: 	}
26: }
27: 
28: BoundStatement Binder::Bind(SQLStatement &statement) {
29: 	root_statement = &statement;
30: 	switch (statement.type) {
31: 	case StatementType::SELECT_STATEMENT:
32: 		return Bind((SelectStatement &)statement);
33: 	case StatementType::INSERT_STATEMENT:
34: 		return Bind((InsertStatement &)statement);
35: 	case StatementType::COPY_STATEMENT:
36: 		return Bind((CopyStatement &)statement);
37: 	case StatementType::DELETE_STATEMENT:
38: 		return Bind((DeleteStatement &)statement);
39: 	case StatementType::UPDATE_STATEMENT:
40: 		return Bind((UpdateStatement &)statement);
41: 	case StatementType::RELATION_STATEMENT:
42: 		return Bind((RelationStatement &)statement);
43: 	case StatementType::CREATE_STATEMENT:
44: 		return Bind((CreateStatement &)statement);
45: 	case StatementType::DROP_STATEMENT:
46: 		return Bind((DropStatement &)statement);
47: 	case StatementType::ALTER_STATEMENT:
48: 		return Bind((AlterStatement &)statement);
49: 	case StatementType::TRANSACTION_STATEMENT:
50: 		return Bind((TransactionStatement &)statement);
51: 	case StatementType::PRAGMA_STATEMENT:
52: 		return Bind((PragmaStatement &)statement);
53: 	case StatementType::EXPLAIN_STATEMENT:
54: 		return Bind((ExplainStatement &)statement);
55: 	case StatementType::VACUUM_STATEMENT:
56: 		return Bind((VacuumStatement &)statement);
57:   case StatementType::SHOW_STATEMENT:
58:     return Bind((ShowStatement &)statement);
59: 	case StatementType::CALL_STATEMENT:
60: 		return Bind((CallStatement &)statement);
61: 	case StatementType::EXPORT_STATEMENT:
62: 		return Bind((ExportStatement &)statement);
63: 	default:
64: 		throw NotImplementedException("Unimplemented statement type \"%s\" for Bind",
65: 		                              StatementTypeToString(statement.type));
66: 	}
67: }
68: 
69: unique_ptr<BoundQueryNode> Binder::BindNode(QueryNode &node) {
70: 	unique_ptr<BoundQueryNode> result;
71: 	switch (node.type) {
72: 	case QueryNodeType::SELECT_NODE:
73: 		result = BindNode((SelectNode &)node);
74: 		break;
75: 	case QueryNodeType::RECURSIVE_CTE_NODE:
76: 		result = BindNode((RecursiveCTENode &)node);
77: 		break;
78: 	default:
79: 		D_ASSERT(node.type == QueryNodeType::SET_OPERATION_NODE);
80: 		result = BindNode((SetOperationNode &)node);
81: 		break;
82: 	}
83: 	return result;
84: }
85: 
86: BoundStatement Binder::Bind(QueryNode &node) {
87: 	BoundStatement result;
88: 	// bind the node
89: 	auto bound_node = BindNode(node);
90: 
91: 	result.names = bound_node->names;
92: 	result.types = bound_node->types;
93: 
94: 	// and plan it
95: 	result.plan = CreatePlan(*bound_node);
96: 	return result;
97: }
98: 
99: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundQueryNode &node) {
100: 	switch (node.type) {
101: 	case QueryNodeType::SELECT_NODE:
102: 		return CreatePlan((BoundSelectNode &)node);
103: 	case QueryNodeType::SET_OPERATION_NODE:
104: 		return CreatePlan((BoundSetOperationNode &)node);
105: 	case QueryNodeType::RECURSIVE_CTE_NODE:
106: 		return CreatePlan((BoundRecursiveCTENode &)node);
107: 	default:
108: 		throw Exception("Unsupported bound query node type");
109: 	}
110: }
111: unique_ptr<BoundTableRef> Binder::Bind(TableRef &ref) {
112: 	unique_ptr<BoundTableRef> result;
113: 	switch (ref.type) {
114: 	case TableReferenceType::BASE_TABLE:
115: 		result = Bind((BaseTableRef &)ref);
116: 		break;
117: 	case TableReferenceType::CROSS_PRODUCT:
118: 		result = Bind((CrossProductRef &)ref);
119: 		break;
120: 	case TableReferenceType::JOIN:
121: 		result = Bind((JoinRef &)ref);
122: 		break;
123: 	case TableReferenceType::SUBQUERY:
124: 		result = Bind((SubqueryRef &)ref);
125: 		break;
126: 	case TableReferenceType::EMPTY:
127: 		result = Bind((EmptyTableRef &)ref);
128: 		break;
129: 	case TableReferenceType::TABLE_FUNCTION:
130: 		result = Bind((TableFunctionRef &)ref);
131: 		break;
132: 	case TableReferenceType::EXPRESSION_LIST:
133: 		result = Bind((ExpressionListRef &)ref);
134: 		break;
135: 	default:
136: 		throw Exception("Unknown table ref type");
137: 	}
138: 	result->sample = move(ref.sample);
139: 	return result;
140: }
141: 
142: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundTableRef &ref) {
143: 	unique_ptr<LogicalOperator> root;
144: 	switch (ref.type) {
145: 	case TableReferenceType::BASE_TABLE:
146: 		root = CreatePlan((BoundBaseTableRef &)ref);
147: 		break;
148: 	case TableReferenceType::SUBQUERY:
149: 		root = CreatePlan((BoundSubqueryRef &)ref);
150: 		break;
151: 	case TableReferenceType::JOIN:
152: 		root = CreatePlan((BoundJoinRef &)ref);
153: 		break;
154: 	case TableReferenceType::CROSS_PRODUCT:
155: 		root = CreatePlan((BoundCrossProductRef &)ref);
156: 		break;
157: 	case TableReferenceType::TABLE_FUNCTION:
158: 		root = CreatePlan((BoundTableFunction &)ref);
159: 		break;
160: 	case TableReferenceType::EMPTY:
161: 		root = CreatePlan((BoundEmptyTableRef &)ref);
162: 		break;
163: 	case TableReferenceType::EXPRESSION_LIST:
164: 		root = CreatePlan((BoundExpressionListRef &)ref);
165: 		break;
166: 	case TableReferenceType::CTE:
167: 		root = CreatePlan((BoundCTERef &)ref);
168: 		break;
169: 	default:
170: 		throw Exception("Unsupported bound table ref type type");
171: 	}
172: 	// plan the sample clause
173: 	if (ref.sample) {
174: 		root = make_unique<LogicalSample>(move(ref.sample), move(root));
175: 	}
176: 	return root;
177: }
178: 
179: void Binder::AddCTE(const string &name, CommonTableExpressionInfo *info) {
180: 	D_ASSERT(info);
181: 	D_ASSERT(!name.empty());
182: 	auto entry = CTE_bindings.find(name);
183: 	if (entry != CTE_bindings.end()) {
184: 		throw BinderException("Duplicate CTE \"%s\" in query!", name);
185: 	}
186: 	CTE_bindings[name] = info;
187: }
188: 
189: CommonTableExpressionInfo *Binder::FindCTE(const string &name, bool skip) {
190: 	auto entry = CTE_bindings.find(name);
191: 	if (entry != CTE_bindings.end()) {
192: 		if (!skip || entry->second->query->node->type == QueryNodeType::RECURSIVE_CTE_NODE) {
193: 			return entry->second;
194: 		}
195: 	}
196: 	if (parent && inherit_ctes) {
197: 		return parent->FindCTE(name, name == alias);
198: 	}
199: 	return nullptr;
200: }
201: 
202: idx_t Binder::GenerateTableIndex() {
203: 	if (parent) {
204: 		return parent->GenerateTableIndex();
205: 	}
206: 	return bound_tables++;
207: }
208: 
209: void Binder::PushExpressionBinder(ExpressionBinder *binder) {
210: 	GetActiveBinders().push_back(binder);
211: }
212: 
213: void Binder::PopExpressionBinder() {
214: 	D_ASSERT(HasActiveBinder());
215: 	GetActiveBinders().pop_back();
216: }
217: 
218: void Binder::SetActiveBinder(ExpressionBinder *binder) {
219: 	D_ASSERT(HasActiveBinder());
220: 	GetActiveBinders().back() = binder;
221: }
222: 
223: ExpressionBinder *Binder::GetActiveBinder() {
224: 	return GetActiveBinders().back();
225: }
226: 
227: bool Binder::HasActiveBinder() {
228: 	return GetActiveBinders().size() > 0;
229: }
230: 
231: vector<ExpressionBinder *> &Binder::GetActiveBinders() {
232: 	if (parent) {
233: 		return parent->GetActiveBinders();
234: 	}
235: 	return active_binders;
236: }
237: 
238: void Binder::MoveCorrelatedExpressions(Binder &other) {
239: 	MergeCorrelatedColumns(other.correlated_columns);
240: 	other.correlated_columns.clear();
241: }
242: 
243: void Binder::MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other) {
244: 	for (idx_t i = 0; i < other.size(); i++) {
245: 		AddCorrelatedColumn(other[i]);
246: 	}
247: }
248: 
249: void Binder::AddCorrelatedColumn(CorrelatedColumnInfo info) {
250: 	// we only add correlated columns to the list if they are not already there
251: 	if (std::find(correlated_columns.begin(), correlated_columns.end(), info) == correlated_columns.end()) {
252: 		correlated_columns.push_back(info);
253: 	}
254: }
255: 
256: string Binder::FormatError(ParsedExpression &expr_context, string message) {
257: 	return FormatError(expr_context.query_location, message);
258: }
259: 
260: string Binder::FormatError(TableRef &ref_context, string message) {
261: 	return FormatError(ref_context.query_location, message);
262: }
263: 
264: string Binder::FormatError(idx_t query_location, string message) {
265: 	QueryErrorContext context(root_statement, query_location);
266: 	return context.FormatError(message);
267: }
268: 
269: } // namespace duckdb
[end of src/planner/binder.cpp]
[start of src/planner/binder/tableref/bind_basetableref.cpp]
1: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
2: #include "duckdb/parser/tableref/basetableref.hpp"
3: #include "duckdb/parser/tableref/subqueryref.hpp"
4: #include "duckdb/planner/binder.hpp"
5: #include "duckdb/planner/tableref/bound_basetableref.hpp"
6: #include "duckdb/planner/tableref/bound_subqueryref.hpp"
7: #include "duckdb/planner/tableref/bound_cteref.hpp"
8: #include "duckdb/planner/operator/logical_get.hpp"
9: #include "duckdb/parser/statement/select_statement.hpp"
10: #include "duckdb/function/table/table_scan.hpp"
11: 
12: namespace duckdb {
13: 
14: unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {
15: 	QueryErrorContext error_context(root_statement, ref.query_location);
16: 	// CTEs and views are also referred to using BaseTableRefs, hence need to distinguish here
17: 	// check if the table name refers to a CTE
18: 	auto cte = FindCTE(ref.table_name, ref.table_name == alias);
19: 	if (cte) {
20: 		// Check if there is a CTE binding in the BindContext
21: 		auto ctebinding = bind_context.GetCTEBinding(ref.table_name);
22: 		if (!ctebinding) {
23: 			// Move CTE to subquery and bind recursively
24: 			SubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(cte->query->Copy()));
25: 			subquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;
26: 			subquery.column_name_alias = cte->aliases;
27: 			for (idx_t i = 0; i < ref.column_name_alias.size(); i++) {
28: 				if (i < subquery.column_name_alias.size()) {
29: 					subquery.column_name_alias[i] = ref.column_name_alias[i];
30: 				} else {
31: 					subquery.column_name_alias.push_back(ref.column_name_alias[i]);
32: 				}
33: 			}
34: 			return Bind(subquery);
35: 		} else {
36: 			// There is a CTE binding in the BindContext.
37: 			// This can only be the case if there is a recursive CTE present.
38: 			auto index = GenerateTableIndex();
39: 			auto result = make_unique<BoundCTERef>(index, ctebinding->index);
40: 			auto b = ctebinding;
41: 			auto alias = ref.alias.empty() ? ref.table_name : ref.alias;
42: 			auto names = BindContext::AliasColumnNames(alias, b->names, ref.column_name_alias);
43: 
44: 			bind_context.AddGenericBinding(index, alias, names, b->types);
45: 			// Update references to CTE
46: 			auto cteref = bind_context.cte_references[ref.table_name];
47: 			(*cteref)++;
48: 
49: 			result->types = b->types;
50: 			result->bound_columns = move(names);
51: 			return move(result);
52: 		}
53: 	}
54: 	// not a CTE
55: 	// extract a table or view from the catalog
56: 	auto table_or_view = Catalog::GetCatalog(context).GetEntry(context, CatalogType::TABLE_ENTRY, ref.schema_name,
57: 	                                                           ref.table_name, false, error_context);
58: 	switch (table_or_view->type) {
59: 	case CatalogType::TABLE_ENTRY: {
60: 		// base table: create the BoundBaseTableRef node
61: 		auto table_index = GenerateTableIndex();
62: 		auto table = (TableCatalogEntry *)table_or_view;
63: 
64: 		auto scan_function = TableScanFunction::GetFunction();
65: 		auto bind_data = make_unique<TableScanBindData>(table);
66: 		auto alias = ref.alias.empty() ? ref.table_name : ref.alias;
67: 		vector<LogicalType> table_types;
68: 		vector<string> table_names;
69: 		for (auto &col : table->columns) {
70: 			table_types.push_back(col.type);
71: 			table_names.push_back(col.name);
72: 		}
73: 		table_names = BindContext::AliasColumnNames(alias, table_names, ref.column_name_alias);
74: 
75: 		auto logical_get =
76: 		    make_unique<LogicalGet>(table_index, scan_function, move(bind_data), table_types, table_names);
77: 		bind_context.AddBaseTable(table_index, alias, move(table_names), move(table_types), *logical_get);
78: 		return make_unique_base<BoundTableRef, BoundBaseTableRef>(table, move(logical_get));
79: 	}
80: 	case CatalogType::VIEW_ENTRY: {
81: 		// the node is a view: get the query that the view represents
82: 		auto view_catalog_entry = (ViewCatalogEntry *)table_or_view;
83: 		// We need to use a new binder for the view that doesn't reference any CTEs
84: 		// defined for this binder so there are no collisions between the CTEs defined
85: 		// for the view and for the current query
86: 		bool inherit_ctes = false;
87: 		Binder view_binder(context, this, inherit_ctes);
88: 		SubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(view_catalog_entry->query->Copy()));
89: 		subquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;
90: 		subquery.column_name_alias =
91: 		    BindContext::AliasColumnNames(subquery.alias, view_catalog_entry->aliases, ref.column_name_alias);
92: 		// bind the child subquery
93: 		auto bound_child = view_binder.Bind(subquery);
94: 		D_ASSERT(bound_child->type == TableReferenceType::SUBQUERY);
95: 		// verify that the types and names match up with the expected types and names
96: 		auto &bound_subquery = (BoundSubqueryRef &)*bound_child;
97: 		if (bound_subquery.subquery->types != view_catalog_entry->types) {
98: 			throw BinderException("Contents of view were altered: types don't match!");
99: 		}
100: 		bind_context.AddSubquery(bound_subquery.subquery->GetRootIndex(), subquery.alias, subquery,
101: 		                         *bound_subquery.subquery);
102: 		return bound_child;
103: 	}
104: 	default:
105: 		throw InternalException("Catalog entry type");
106: 	}
107: }
108: } // namespace duckdb
[end of src/planner/binder/tableref/bind_basetableref.cpp]
[start of src/planner/binder/tableref/bind_subqueryref.cpp]
1: #include "duckdb/parser/tableref/subqueryref.hpp"
2: #include "duckdb/planner/binder.hpp"
3: #include "duckdb/planner/tableref/bound_subqueryref.hpp"
4: 
5: namespace duckdb {
6: 
7: unique_ptr<BoundTableRef> Binder::Bind(SubqueryRef &ref) {
8: 	auto binder = make_unique<Binder>(context, this);
9: 	binder->alias = ref.alias;
10: 	for (auto &cte_it : ref.subquery->cte_map) {
11: 		binder->AddCTE(cte_it.first, cte_it.second.get());
12: 	}
13: 	auto subquery = binder->BindNode(*ref.subquery->node);
14: 	idx_t bind_index = subquery->GetRootIndex();
15: 	auto result = make_unique<BoundSubqueryRef>(move(binder), move(subquery));
16: 
17: 	bind_context.AddSubquery(bind_index, ref.alias, ref, *result->subquery);
18: 	MoveCorrelatedExpressions(*result->binder);
19: 	return move(result);
20: }
21: 
22: } // namespace duckdb
[end of src/planner/binder/tableref/bind_subqueryref.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: