You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Add support for EVEN (Fix #2478)
I fixed the error in implementation of even function and added testcase into SQLLogicTests.
I closed previous PR and created this PR.

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/function/scalar/math/numeric.cpp]
1: #include "duckdb/function/scalar/math_functions.hpp"
2: #include "duckdb/common/vector_operations/vector_operations.hpp"
3: #include "duckdb/function/scalar/trigonometric_functions.hpp"
4: #include "duckdb/common/types/hugeint.hpp"
5: #include "duckdb/common/types/cast_helpers.hpp"
6: #include "duckdb/planner/expression/bound_function_expression.hpp"
7: #include "duckdb/common/algorithm.hpp"
8: #include "duckdb/execution/expression_executor.hpp"
9: #include <cmath>
10: #include <errno.h>
11: 
12: namespace duckdb {
13: 
14: template <class TR, class OP>
15: static scalar_function_t GetScalarIntegerUnaryFunctionFixedReturn(const LogicalType &type) {
16: 	scalar_function_t function;
17: 	switch (type.id()) {
18: 	case LogicalTypeId::TINYINT:
19: 		function = &ScalarFunction::UnaryFunction<int8_t, TR, OP>;
20: 		break;
21: 	case LogicalTypeId::SMALLINT:
22: 		function = &ScalarFunction::UnaryFunction<int16_t, TR, OP>;
23: 		break;
24: 	case LogicalTypeId::INTEGER:
25: 		function = &ScalarFunction::UnaryFunction<int32_t, TR, OP>;
26: 		break;
27: 	case LogicalTypeId::BIGINT:
28: 		function = &ScalarFunction::UnaryFunction<int64_t, TR, OP>;
29: 		break;
30: 	case LogicalTypeId::HUGEINT:
31: 		function = &ScalarFunction::UnaryFunction<hugeint_t, TR, OP>;
32: 		break;
33: 	default:
34: 		throw NotImplementedException("Unimplemented type for GetScalarIntegerUnaryFunctionFixedReturn");
35: 	}
36: 	return function;
37: }
38: 
39: template <class OP>
40: struct UnaryDoubleWrapper {
41: 	template <class INPUT_TYPE, class RESULT_TYPE>
42: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
43: 		RESULT_TYPE result = OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input);
44: 		if (std::isnan(result) || std::isinf(result) || errno != 0) {
45: 			errno = 0;
46: 			mask.SetInvalid(idx);
47: 			return 0;
48: 		}
49: 		return result;
50: 	}
51: };
52: 
53: template <class T, class OP>
54: static void UnaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {
55: 	D_ASSERT(input.ColumnCount() >= 1);
56: 	errno = 0;
57: 	UnaryExecutor::GenericExecute<T, T, UnaryDoubleWrapper<OP>>(input.data[0], result, input.size(), nullptr, true);
58: }
59: 
60: struct BinaryDoubleWrapper {
61: 	template <class FUNC, class OP, class TA, class TB, class TR>
62: 	static inline TR Operation(FUNC fun, TA left, TB right, ValidityMask &mask, idx_t idx) {
63: 		TR result = OP::template Operation<TA, TB, TR>(left, right);
64: 		if (std::isnan(result) || std::isinf(result) || errno != 0) {
65: 			errno = 0;
66: 			mask.SetInvalid(idx);
67: 			return 0;
68: 		}
69: 		return result;
70: 	}
71: 
72: 	static bool AddsNulls() {
73: 		return true;
74: 	}
75: };
76: 
77: template <class T, class OP>
78: static void BinaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {
79: 	D_ASSERT(input.ColumnCount() >= 2);
80: 	errno = 0;
81: 	BinaryExecutor::Execute<T, T, T, OP, BinaryDoubleWrapper>(input.data[0], input.data[1], result, input.size());
82: }
83: 
84: //===--------------------------------------------------------------------===//
85: // nextafter
86: //===--------------------------------------------------------------------===//
87: 
88: struct NextAfterOperator {
89: 	template <class TA, class TB, class TR>
90: 	static inline TR Operation(TA base, TB exponent) {
91: 		throw NotImplementedException("Unimplemented type for NextAfter Function");
92: 	}
93: 
94: 	template <class TA, class TB, class TR>
95: 	static inline double Operation(double input, double approximate_to) {
96: 		return nextafter(input, approximate_to);
97: 	}
98: 	template <class TA, class TB, class TR>
99: 	static inline float Operation(float input, float approximate_to) {
100: 		return nextafterf(input, approximate_to);
101: 	}
102: };
103: 
104: unique_ptr<FunctionData> BindNextAfter(ClientContext &context, ScalarFunction &function,
105:                                        vector<unique_ptr<Expression>> &arguments) {
106: 	if ((arguments[0]->return_type != arguments[1]->return_type) ||
107: 	    (arguments[0]->return_type != LogicalType::FLOAT && arguments[0]->return_type != LogicalType::DOUBLE)) {
108: 		throw NotImplementedException("Unimplemented type for NextAfter Function");
109: 	}
110: 	return nullptr;
111: }
112: 
113: void NextAfterFun::RegisterFunction(BuiltinFunctions &set) {
114: 	ScalarFunctionSet next_after_fun("nextafter");
115: 	next_after_fun.AddFunction(
116: 	    ScalarFunction("nextafter", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,
117: 	                   BinaryDoubleFunctionWrapper<double, NextAfterOperator>, false, BindNextAfter));
118: 	next_after_fun.AddFunction(ScalarFunction("nextafter", {LogicalType::FLOAT, LogicalType::FLOAT}, LogicalType::FLOAT,
119: 	                                          BinaryDoubleFunctionWrapper<float, NextAfterOperator>, false,
120: 	                                          BindNextAfter));
121: 	set.AddFunction(next_after_fun);
122: }
123: 
124: //===--------------------------------------------------------------------===//
125: // abs
126: //===--------------------------------------------------------------------===//
127: struct AbsOperator {
128: 	template <class TA, class TR>
129: 	static inline TR Operation(TA input) {
130: 		return input < 0 ? -input : input;
131: 	}
132: };
133: 
134: template <class OP>
135: unique_ptr<FunctionData> DecimalUnaryOpBind(ClientContext &context, ScalarFunction &bound_function,
136:                                             vector<unique_ptr<Expression>> &arguments) {
137: 	auto decimal_type = arguments[0]->return_type;
138: 	switch (decimal_type.InternalType()) {
139: 	case PhysicalType::INT16:
140: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::SMALLINT);
141: 		break;
142: 	case PhysicalType::INT32:
143: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::INTEGER);
144: 		break;
145: 	case PhysicalType::INT64:
146: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::BIGINT);
147: 		break;
148: 	default:
149: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::HUGEINT);
150: 		break;
151: 	}
152: 	bound_function.arguments[0] = decimal_type;
153: 	bound_function.return_type = decimal_type;
154: 	return nullptr;
155: }
156: 
157: void AbsFun::RegisterFunction(BuiltinFunctions &set) {
158: 	ScalarFunctionSet abs("abs");
159: 	for (auto &type : LogicalType::NUMERIC) {
160: 		if (type.id() == LogicalTypeId::DECIMAL) {
161: 			abs.AddFunction(ScalarFunction({type}, type, nullptr, false, DecimalUnaryOpBind<AbsOperator>));
162: 		} else {
163: 			abs.AddFunction(ScalarFunction({type}, type, ScalarFunction::GetScalarUnaryFunction<AbsOperator>(type)));
164: 		}
165: 	}
166: 	set.AddFunction(abs);
167: 	abs.name = "@";
168: 	set.AddFunction(abs);
169: }
170: 
171: //===--------------------------------------------------------------------===//
172: // bit_count
173: //===--------------------------------------------------------------------===//
174: struct BitCntOperator {
175: 	template <class TA, class TR>
176: 	static inline TR Operation(TA input) {
177: 		using TU = typename std::make_unsigned<TA>::type;
178: 		TR count = 0;
179: 		for (auto value = TU(input); value > 0; value >>= 1) {
180: 			count += TR(value & 1);
181: 		}
182: 		return count;
183: 	}
184: };
185: 
186: void BitCountFun::RegisterFunction(BuiltinFunctions &set) {
187: 	ScalarFunctionSet functions("bit_count");
188: 	functions.AddFunction(ScalarFunction({LogicalType::TINYINT}, LogicalType::TINYINT,
189: 	                                     ScalarFunction::UnaryFunction<int8_t, int8_t, BitCntOperator>));
190: 	functions.AddFunction(ScalarFunction({LogicalType::SMALLINT}, LogicalType::TINYINT,
191: 	                                     ScalarFunction::UnaryFunction<int16_t, int8_t, BitCntOperator>));
192: 	functions.AddFunction(ScalarFunction({LogicalType::INTEGER}, LogicalType::TINYINT,
193: 	                                     ScalarFunction::UnaryFunction<int32_t, int8_t, BitCntOperator>));
194: 	functions.AddFunction(ScalarFunction({LogicalType::BIGINT}, LogicalType::TINYINT,
195: 	                                     ScalarFunction::UnaryFunction<int64_t, int8_t, BitCntOperator>));
196: 	set.AddFunction(functions);
197: }
198: 
199: //===--------------------------------------------------------------------===//
200: // sign
201: //===--------------------------------------------------------------------===//
202: struct SignOperator {
203: 	template <class TA, class TR>
204: 	static inline TR Operation(TA left) {
205: 		if (left == TA(0)) {
206: 			return 0;
207: 		} else if (left > TA(0)) {
208: 			return 1;
209: 		} else {
210: 			return -1;
211: 		}
212: 	}
213: };
214: 
215: void SignFun::RegisterFunction(BuiltinFunctions &set) {
216: 	ScalarFunctionSet sign("sign");
217: 	for (auto &type : LogicalType::NUMERIC) {
218: 		if (type.id() == LogicalTypeId::DECIMAL) {
219: 			continue;
220: 		} else {
221: 			sign.AddFunction(
222: 			    ScalarFunction({type}, LogicalType::TINYINT,
223: 			                   ScalarFunction::GetScalarUnaryFunctionFixedReturn<int8_t, SignOperator>(type)));
224: 		}
225: 	}
226: 	set.AddFunction(sign);
227: }
228: 
229: //===--------------------------------------------------------------------===//
230: // ceil
231: //===--------------------------------------------------------------------===//
232: struct CeilOperator {
233: 	template <class TA, class TR>
234: 	static inline TR Operation(TA left) {
235: 		return std::ceil(left);
236: 	}
237: };
238: 
239: template <class T, class POWERS_OF_TEN, class OP>
240: static void GenericRoundFunctionDecimal(DataChunk &input, ExpressionState &state, Vector &result) {
241: 	auto &func_expr = (BoundFunctionExpression &)state.expr;
242: 	OP::template Operation<T, POWERS_OF_TEN>(input, DecimalType::GetScale(func_expr.children[0]->return_type), result);
243: }
244: 
245: template <class OP>
246: unique_ptr<FunctionData> BindGenericRoundFunctionDecimal(ClientContext &context, ScalarFunction &bound_function,
247:                                                          vector<unique_ptr<Expression>> &arguments) {
248: 	// ceil essentially removes the scale
249: 	auto &decimal_type = arguments[0]->return_type;
250: 	auto scale = DecimalType::GetScale(decimal_type);
251: 	auto width = DecimalType::GetWidth(decimal_type);
252: 	if (scale == 0) {
253: 		bound_function.function = ScalarFunction::NopFunction;
254: 	} else {
255: 		switch (decimal_type.InternalType()) {
256: 		case PhysicalType::INT16:
257: 			bound_function.function = GenericRoundFunctionDecimal<int16_t, NumericHelper, OP>;
258: 			break;
259: 		case PhysicalType::INT32:
260: 			bound_function.function = GenericRoundFunctionDecimal<int32_t, NumericHelper, OP>;
261: 			break;
262: 		case PhysicalType::INT64:
263: 			bound_function.function = GenericRoundFunctionDecimal<int64_t, NumericHelper, OP>;
264: 			break;
265: 		default:
266: 			bound_function.function = GenericRoundFunctionDecimal<hugeint_t, Hugeint, OP>;
267: 			break;
268: 		}
269: 	}
270: 	bound_function.arguments[0] = decimal_type;
271: 	bound_function.return_type = LogicalType::DECIMAL(width, 0);
272: 	return nullptr;
273: }
274: 
275: struct CeilDecimalOperator {
276: 	template <class T, class POWERS_OF_TEN_CLASS>
277: 	static void Operation(DataChunk &input, uint8_t scale, Vector &result) {
278: 		T power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[scale];
279: 		UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
280: 			if (input < 0) {
281: 				// below 0 we floor the number (e.g. -10.5 -> -10)
282: 				return input / power_of_ten;
283: 			} else {
284: 				// above 0 we ceil the number
285: 				return ((input - 1) / power_of_ten) + 1;
286: 			}
287: 		});
288: 	}
289: };
290: 
291: void CeilFun::RegisterFunction(BuiltinFunctions &set) {
292: 	ScalarFunctionSet ceil("ceil");
293: 	for (auto &type : LogicalType::NUMERIC) {
294: 		scalar_function_t func = nullptr;
295: 		bind_scalar_function_t bind_func = nullptr;
296: 		if (type.IsIntegral()) {
297: 			// no ceil for integral numbers
298: 			continue;
299: 		}
300: 		switch (type.id()) {
301: 		case LogicalTypeId::FLOAT:
302: 			func = ScalarFunction::UnaryFunction<float, float, CeilOperator>;
303: 			break;
304: 		case LogicalTypeId::DOUBLE:
305: 			func = ScalarFunction::UnaryFunction<double, double, CeilOperator>;
306: 			break;
307: 		case LogicalTypeId::DECIMAL:
308: 			bind_func = BindGenericRoundFunctionDecimal<CeilDecimalOperator>;
309: 			break;
310: 		default:
311: 			throw InternalException("Unimplemented numeric type for function \"ceil\"");
312: 		}
313: 		ceil.AddFunction(ScalarFunction({type}, type, func, false, bind_func));
314: 	}
315: 
316: 	set.AddFunction(ceil);
317: 	ceil.name = "ceiling";
318: 	set.AddFunction(ceil);
319: }
320: 
321: //===--------------------------------------------------------------------===//
322: // floor
323: //===--------------------------------------------------------------------===//
324: struct FloorOperator {
325: 	template <class TA, class TR>
326: 	static inline TR Operation(TA left) {
327: 		return std::floor(left);
328: 	}
329: };
330: 
331: struct FloorDecimalOperator {
332: 	template <class T, class POWERS_OF_TEN_CLASS>
333: 	static void Operation(DataChunk &input, uint8_t scale, Vector &result) {
334: 		T power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[scale];
335: 		UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
336: 			if (input < 0) {
337: 				// below 0 we ceil the number (e.g. -10.5 -> -11)
338: 				return ((input + 1) / power_of_ten) - 1;
339: 			} else {
340: 				// above 0 we floor the number
341: 				return input / power_of_ten;
342: 			}
343: 		});
344: 	}
345: };
346: 
347: void FloorFun::RegisterFunction(BuiltinFunctions &set) {
348: 	ScalarFunctionSet floor("floor");
349: 	for (auto &type : LogicalType::NUMERIC) {
350: 		scalar_function_t func = nullptr;
351: 		bind_scalar_function_t bind_func = nullptr;
352: 		if (type.IsIntegral()) {
353: 			// no floor for integral numbers
354: 			continue;
355: 		}
356: 		switch (type.id()) {
357: 		case LogicalTypeId::FLOAT:
358: 			func = ScalarFunction::UnaryFunction<float, float, FloorOperator>;
359: 			break;
360: 		case LogicalTypeId::DOUBLE:
361: 			func = ScalarFunction::UnaryFunction<double, double, FloorOperator>;
362: 			break;
363: 		case LogicalTypeId::DECIMAL:
364: 			bind_func = BindGenericRoundFunctionDecimal<FloorDecimalOperator>;
365: 			break;
366: 		default:
367: 			throw InternalException("Unimplemented numeric type for function \"floor\"");
368: 		}
369: 		floor.AddFunction(ScalarFunction({type}, type, func, false, bind_func));
370: 	}
371: 	set.AddFunction(floor);
372: }
373: 
374: //===--------------------------------------------------------------------===//
375: // round
376: //===--------------------------------------------------------------------===//
377: struct RoundOperatorPrecision {
378: 	template <class TA, class TB, class TR>
379: 	static inline TR Operation(TA input, TB precision) {
380: 		double rounded_value;
381: 		if (precision < 0) {
382: 			double modifier = std::pow(10, -precision);
383: 			rounded_value = (std::round(input / modifier)) * modifier;
384: 			if (std::isinf(rounded_value) || std::isnan(rounded_value)) {
385: 				return 0;
386: 			}
387: 		} else {
388: 			double modifier = std::pow(10, precision);
389: 			rounded_value = (std::round(input * modifier)) / modifier;
390: 			if (std::isinf(rounded_value) || std::isnan(rounded_value)) {
391: 				return input;
392: 			}
393: 		}
394: 		return rounded_value;
395: 	}
396: };
397: 
398: struct RoundOperator {
399: 	template <class TA, class TR>
400: 	static inline TR Operation(TA input) {
401: 		double rounded_value = round(input);
402: 		if (std::isinf(rounded_value) || std::isnan(rounded_value)) {
403: 			return input;
404: 		}
405: 		return rounded_value;
406: 	}
407: };
408: 
409: struct RoundDecimalOperator {
410: 	template <class T, class POWERS_OF_TEN_CLASS>
411: 	static void Operation(DataChunk &input, uint8_t scale, Vector &result) {
412: 		T power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[scale];
413: 		T addition = power_of_ten / 2;
414: 		// regular round rounds towards the nearest number
415: 		// in case of a tie we round away from zero
416: 		// i.e. -10.5 -> -11, 10.5 -> 11
417: 		// we implement this by adding (positive) or subtracting (negative) 0.5
418: 		// and then flooring the number
419: 		// e.g. 10.5 + 0.5 = 11, floor(11) = 11
420: 		//      10.4 + 0.5 = 10.9, floor(10.9) = 10
421: 		UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
422: 			if (input < 0) {
423: 				input -= addition;
424: 			} else {
425: 				input += addition;
426: 			}
427: 			return input / power_of_ten;
428: 		});
429: 	}
430: };
431: 
432: struct RoundPrecisionFunctionData : public FunctionData {
433: 	explicit RoundPrecisionFunctionData(int32_t target_scale) : target_scale(target_scale) {
434: 	}
435: 
436: 	int32_t target_scale;
437: 
438: 	unique_ptr<FunctionData> Copy() override {
439: 		return make_unique<RoundPrecisionFunctionData>(target_scale);
440: 	}
441: };
442: 
443: template <class T, class POWERS_OF_TEN_CLASS>
444: static void DecimalRoundNegativePrecisionFunction(DataChunk &input, ExpressionState &state, Vector &result) {
445: 	auto &func_expr = (BoundFunctionExpression &)state.expr;
446: 	auto &info = (RoundPrecisionFunctionData &)*func_expr.bind_info;
447: 	auto source_scale = DecimalType::GetScale(func_expr.children[0]->return_type);
448: 	auto width = DecimalType::GetWidth(func_expr.children[0]->return_type);
449: 	if (-info.target_scale >= width) {
450: 		// scale too big for width
451: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
452: 		result.SetValue(0, Value::INTEGER(0));
453: 		return;
454: 	}
455: 	T divide_power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[-info.target_scale + source_scale];
456: 	T multiply_power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[-info.target_scale];
457: 	T addition = divide_power_of_ten / 2;
458: 
459: 	UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
460: 		if (input < 0) {
461: 			input -= addition;
462: 		} else {
463: 			input += addition;
464: 		}
465: 		return input / divide_power_of_ten * multiply_power_of_ten;
466: 	});
467: }
468: 
469: template <class T, class POWERS_OF_TEN_CLASS>
470: static void DecimalRoundPositivePrecisionFunction(DataChunk &input, ExpressionState &state, Vector &result) {
471: 	auto &func_expr = (BoundFunctionExpression &)state.expr;
472: 	auto &info = (RoundPrecisionFunctionData &)*func_expr.bind_info;
473: 	auto source_scale = DecimalType::GetScale(func_expr.children[0]->return_type);
474: 	T power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[source_scale - info.target_scale];
475: 	T addition = power_of_ten / 2;
476: 	UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
477: 		if (input < 0) {
478: 			input -= addition;
479: 		} else {
480: 			input += addition;
481: 		}
482: 		return input / power_of_ten;
483: 	});
484: }
485: 
486: unique_ptr<FunctionData> BindDecimalRoundPrecision(ClientContext &context, ScalarFunction &bound_function,
487:                                                    vector<unique_ptr<Expression>> &arguments) {
488: 	auto &decimal_type = arguments[0]->return_type;
489: 	if (!arguments[1]->IsFoldable()) {
490: 		throw NotImplementedException("ROUND(DECIMAL, INTEGER) with non-constant precision is not supported");
491: 	}
492: 	Value val = ExpressionExecutor::EvaluateScalar(*arguments[1]).CastAs(LogicalType::INTEGER);
493: 	if (val.is_null) {
494: 		throw NotImplementedException("ROUND(DECIMAL, INTEGER) with non-constant precision is not supported");
495: 	}
496: 	// our new precision becomes the round value
497: 	// e.g. ROUND(DECIMAL(18,3), 1) -> DECIMAL(18,1)
498: 	// but ONLY if the round value is positive
499: 	// if it is negative the scale becomes zero
500: 	// i.e. ROUND(DECIMAL(18,3), -1) -> DECIMAL(18,0)
501: 	int32_t round_value = val.value_.integer;
502: 	uint8_t target_scale;
503: 	auto width = DecimalType::GetWidth(decimal_type);
504: 	auto scale = DecimalType::GetScale(decimal_type);
505: 	if (round_value < 0) {
506: 		target_scale = 0;
507: 		switch (decimal_type.InternalType()) {
508: 		case PhysicalType::INT16:
509: 			bound_function.function = DecimalRoundNegativePrecisionFunction<int16_t, NumericHelper>;
510: 			break;
511: 		case PhysicalType::INT32:
512: 			bound_function.function = DecimalRoundNegativePrecisionFunction<int32_t, NumericHelper>;
513: 			break;
514: 		case PhysicalType::INT64:
515: 			bound_function.function = DecimalRoundNegativePrecisionFunction<int64_t, NumericHelper>;
516: 			break;
517: 		default:
518: 			bound_function.function = DecimalRoundNegativePrecisionFunction<hugeint_t, Hugeint>;
519: 			break;
520: 		}
521: 	} else {
522: 		if (round_value >= (int32_t)scale) {
523: 			// if round_value is bigger than or equal to scale we do nothing
524: 			bound_function.function = ScalarFunction::NopFunction;
525: 			target_scale = scale;
526: 		} else {
527: 			target_scale = round_value;
528: 			switch (decimal_type.InternalType()) {
529: 			case PhysicalType::INT16:
530: 				bound_function.function = DecimalRoundPositivePrecisionFunction<int16_t, NumericHelper>;
531: 				break;
532: 			case PhysicalType::INT32:
533: 				bound_function.function = DecimalRoundPositivePrecisionFunction<int32_t, NumericHelper>;
534: 				break;
535: 			case PhysicalType::INT64:
536: 				bound_function.function = DecimalRoundPositivePrecisionFunction<int64_t, NumericHelper>;
537: 				break;
538: 			default:
539: 				bound_function.function = DecimalRoundPositivePrecisionFunction<hugeint_t, Hugeint>;
540: 				break;
541: 			}
542: 		}
543: 	}
544: 	bound_function.arguments[0] = decimal_type;
545: 	bound_function.return_type = LogicalType::DECIMAL(width, target_scale);
546: 	return make_unique<RoundPrecisionFunctionData>(round_value);
547: }
548: 
549: void RoundFun::RegisterFunction(BuiltinFunctions &set) {
550: 	ScalarFunctionSet round("round");
551: 	for (auto &type : LogicalType::NUMERIC) {
552: 		scalar_function_t round_prec_func = nullptr;
553: 		scalar_function_t round_func = nullptr;
554: 		bind_scalar_function_t bind_func = nullptr;
555: 		bind_scalar_function_t bind_prec_func = nullptr;
556: 		if (type.IsIntegral()) {
557: 			// no round for integral numbers
558: 			continue;
559: 		}
560: 		switch (type.id()) {
561: 		case LogicalTypeId::FLOAT:
562: 			round_func = ScalarFunction::UnaryFunction<float, float, RoundOperator>;
563: 			round_prec_func = ScalarFunction::BinaryFunction<float, int32_t, float, RoundOperatorPrecision>;
564: 			break;
565: 		case LogicalTypeId::DOUBLE:
566: 			round_func = ScalarFunction::UnaryFunction<double, double, RoundOperator>;
567: 			round_prec_func = ScalarFunction::BinaryFunction<double, int32_t, double, RoundOperatorPrecision>;
568: 			break;
569: 		case LogicalTypeId::DECIMAL:
570: 			bind_func = BindGenericRoundFunctionDecimal<RoundDecimalOperator>;
571: 			bind_prec_func = BindDecimalRoundPrecision;
572: 			break;
573: 		default:
574: 			throw InternalException("Unimplemented numeric type for function \"floor\"");
575: 		}
576: 		round.AddFunction(ScalarFunction({type}, type, round_func, false, bind_func));
577: 		round.AddFunction(ScalarFunction({type, LogicalType::INTEGER}, type, round_prec_func, false, bind_prec_func));
578: 	}
579: 	set.AddFunction(round);
580: }
581: 
582: //===--------------------------------------------------------------------===//
583: // exp
584: //===--------------------------------------------------------------------===//
585: struct ExpOperator {
586: 	template <class TA, class TR>
587: 	static inline TR Operation(TA left) {
588: 		return std::exp(left);
589: 	}
590: };
591: 
592: void ExpFun::RegisterFunction(BuiltinFunctions &set) {
593: 	set.AddFunction(ScalarFunction("exp", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
594: 	                               UnaryDoubleFunctionWrapper<double, ExpOperator>));
595: }
596: 
597: //===--------------------------------------------------------------------===//
598: // pow
599: //===--------------------------------------------------------------------===//
600: struct PowOperator {
601: 	template <class TA, class TB, class TR>
602: 	static inline TR Operation(TA base, TB exponent) {
603: 		return std::pow(base, exponent);
604: 	}
605: };
606: 
607: void PowFun::RegisterFunction(BuiltinFunctions &set) {
608: 	ScalarFunction power_function("pow", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,
609: 	                              BinaryDoubleFunctionWrapper<double, PowOperator>);
610: 	set.AddFunction(power_function);
611: 	power_function.name = "power";
612: 	set.AddFunction(power_function);
613: 	power_function.name = "**";
614: 	set.AddFunction(power_function);
615: 	power_function.name = "^";
616: 	set.AddFunction(power_function);
617: }
618: 
619: //===--------------------------------------------------------------------===//
620: // sqrt
621: //===--------------------------------------------------------------------===//
622: struct SqrtOperator {
623: 	template <class TA, class TR>
624: 	static inline TR Operation(TA left) {
625: 		return std::sqrt(left);
626: 	}
627: };
628: 
629: void SqrtFun::RegisterFunction(BuiltinFunctions &set) {
630: 	set.AddFunction(ScalarFunction("sqrt", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
631: 	                               UnaryDoubleFunctionWrapper<double, SqrtOperator>));
632: }
633: 
634: //===--------------------------------------------------------------------===//
635: // cbrt
636: //===--------------------------------------------------------------------===//
637: struct CbRtOperator {
638: 	template <class TA, class TR>
639: 	static inline TR Operation(TA left) {
640: 		return std::cbrt(left);
641: 	}
642: };
643: 
644: void CbrtFun::RegisterFunction(BuiltinFunctions &set) {
645: 	set.AddFunction(ScalarFunction("cbrt", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
646: 	                               UnaryDoubleFunctionWrapper<double, CbRtOperator>));
647: }
648: 
649: //===--------------------------------------------------------------------===//
650: // ln
651: //===--------------------------------------------------------------------===//
652: 
653: struct LnOperator {
654: 	template <class TA, class TR>
655: 	static inline TR Operation(TA left) {
656: 		return std::log(left);
657: 	}
658: };
659: 
660: void LnFun::RegisterFunction(BuiltinFunctions &set) {
661: 	set.AddFunction(ScalarFunction("ln", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
662: 	                               UnaryDoubleFunctionWrapper<double, LnOperator>));
663: }
664: 
665: //===--------------------------------------------------------------------===//
666: // log
667: //===--------------------------------------------------------------------===//
668: struct Log10Operator {
669: 	template <class TA, class TR>
670: 	static inline TR Operation(TA left) {
671: 		return std::log10(left);
672: 	}
673: };
674: 
675: void Log10Fun::RegisterFunction(BuiltinFunctions &set) {
676: 	set.AddFunction({"log10", "log"}, ScalarFunction({LogicalType::DOUBLE}, LogicalType::DOUBLE,
677: 	                                                 UnaryDoubleFunctionWrapper<double, Log10Operator>));
678: }
679: 
680: //===--------------------------------------------------------------------===//
681: // log2
682: //===--------------------------------------------------------------------===//
683: struct Log2Operator {
684: 	template <class TA, class TR>
685: 	static inline TR Operation(TA left) {
686: 		return std::log2(left);
687: 	}
688: };
689: 
690: void Log2Fun::RegisterFunction(BuiltinFunctions &set) {
691: 	set.AddFunction(ScalarFunction("log2", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
692: 	                               UnaryDoubleFunctionWrapper<double, Log2Operator>));
693: }
694: 
695: //===--------------------------------------------------------------------===//
696: // pi
697: //===--------------------------------------------------------------------===//
698: static void PiFunction(DataChunk &args, ExpressionState &state, Vector &result) {
699: 	D_ASSERT(args.ColumnCount() == 0);
700: 	Value pi_value = Value::DOUBLE(PI);
701: 	result.Reference(pi_value);
702: }
703: 
704: void PiFun::RegisterFunction(BuiltinFunctions &set) {
705: 	set.AddFunction(ScalarFunction("pi", {}, LogicalType::DOUBLE, PiFunction));
706: }
707: 
708: //===--------------------------------------------------------------------===//
709: // degrees
710: //===--------------------------------------------------------------------===//
711: struct DegreesOperator {
712: 	template <class TA, class TR>
713: 	static inline TR Operation(TA left) {
714: 		return left * (180 / PI);
715: 	}
716: };
717: 
718: void DegreesFun::RegisterFunction(BuiltinFunctions &set) {
719: 	set.AddFunction(ScalarFunction("degrees", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
720: 	                               UnaryDoubleFunctionWrapper<double, DegreesOperator>));
721: }
722: 
723: //===--------------------------------------------------------------------===//
724: // radians
725: //===--------------------------------------------------------------------===//
726: struct RadiansOperator {
727: 	template <class TA, class TR>
728: 	static inline TR Operation(TA left) {
729: 		return left * (PI / 180);
730: 	}
731: };
732: 
733: void RadiansFun::RegisterFunction(BuiltinFunctions &set) {
734: 	set.AddFunction(ScalarFunction("radians", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
735: 	                               UnaryDoubleFunctionWrapper<double, RadiansOperator>));
736: }
737: 
738: //===--------------------------------------------------------------------===//
739: // sin
740: //===--------------------------------------------------------------------===//
741: struct SinOperator {
742: 	template <class TA, class TR>
743: 	static inline TR Operation(TA input) {
744: 		return std::sin(input);
745: 	}
746: };
747: 
748: void SinFun::RegisterFunction(BuiltinFunctions &set) {
749: 	set.AddFunction(ScalarFunction("sin", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
750: 	                               UnaryDoubleFunctionWrapper<double, SinOperator>));
751: }
752: 
753: //===--------------------------------------------------------------------===//
754: // cos
755: //===--------------------------------------------------------------------===//
756: struct CosOperator {
757: 	template <class TA, class TR>
758: 	static inline TR Operation(TA input) {
759: 		return (double)std::cos(input);
760: 	}
761: };
762: 
763: void CosFun::RegisterFunction(BuiltinFunctions &set) {
764: 	set.AddFunction(ScalarFunction("cos", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
765: 	                               UnaryDoubleFunctionWrapper<double, CosOperator>));
766: }
767: 
768: //===--------------------------------------------------------------------===//
769: // tan
770: //===--------------------------------------------------------------------===//
771: struct TanOperator {
772: 	template <class TA, class TR>
773: 	static inline TR Operation(TA input) {
774: 		return (double)std::tan(input);
775: 	}
776: };
777: 
778: void TanFun::RegisterFunction(BuiltinFunctions &set) {
779: 	set.AddFunction(ScalarFunction("tan", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
780: 	                               UnaryDoubleFunctionWrapper<double, TanOperator>));
781: }
782: 
783: //===--------------------------------------------------------------------===//
784: // asin
785: //===--------------------------------------------------------------------===//
786: struct ASinOperator {
787: 	template <class TA, class TR>
788: 	static inline TR Operation(TA input) {
789: 		if (input < -1 || input > 1) {
790: 			throw Exception("ASIN is undefined outside [-1,1]");
791: 		}
792: 		return (double)std::asin(input);
793: 	}
794: };
795: 
796: void AsinFun::RegisterFunction(BuiltinFunctions &set) {
797: 	set.AddFunction(ScalarFunction("asin", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
798: 	                               UnaryDoubleFunctionWrapper<double, ASinOperator>));
799: }
800: 
801: //===--------------------------------------------------------------------===//
802: // atan
803: //===--------------------------------------------------------------------===//
804: struct ATanOperator {
805: 	template <class TA, class TR>
806: 	static inline TR Operation(TA input) {
807: 		return (double)std::atan(input);
808: 	}
809: };
810: 
811: void AtanFun::RegisterFunction(BuiltinFunctions &set) {
812: 	set.AddFunction(ScalarFunction("atan", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
813: 	                               UnaryDoubleFunctionWrapper<double, ATanOperator>));
814: }
815: 
816: //===--------------------------------------------------------------------===//
817: // atan2
818: //===--------------------------------------------------------------------===//
819: struct ATan2 {
820: 	template <class TA, class TB, class TR>
821: 	static inline TR Operation(TA left, TB right) {
822: 		return (double)std::atan2(left, right);
823: 	}
824: };
825: 
826: void Atan2Fun::RegisterFunction(BuiltinFunctions &set) {
827: 	set.AddFunction(ScalarFunction("atan2", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,
828: 	                               BinaryDoubleFunctionWrapper<double, ATan2>));
829: }
830: 
831: //===--------------------------------------------------------------------===//
832: // acos
833: //===--------------------------------------------------------------------===//
834: struct ACos {
835: 	template <class TA, class TR>
836: 	static inline TR Operation(TA input) {
837: 		return (double)std::acos(input);
838: 	}
839: };
840: 
841: void AcosFun::RegisterFunction(BuiltinFunctions &set) {
842: 	set.AddFunction(
843: 	    ScalarFunction("acos", {LogicalType::DOUBLE}, LogicalType::DOUBLE, UnaryDoubleFunctionWrapper<double, ACos>));
844: }
845: 
846: //===--------------------------------------------------------------------===//
847: // cot
848: //===--------------------------------------------------------------------===//
849: struct CotOperator {
850: 	template <class TA, class TR>
851: 	static inline TR Operation(TA input) {
852: 		return 1.0 / (double)std::tan(input);
853: 	}
854: };
855: 
856: void CotFun::RegisterFunction(BuiltinFunctions &set) {
857: 	set.AddFunction(ScalarFunction("cot", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
858: 	                               UnaryDoubleFunctionWrapper<double, CotOperator>));
859: }
860: 
861: //===--------------------------------------------------------------------===//
862: // gamma
863: //===--------------------------------------------------------------------===//
864: struct GammaOperator {
865: 	template <class TA, class TR>
866: 	static inline TR Operation(TA left) {
867: 		return std::tgamma(left);
868: 	}
869: };
870: 
871: void GammaFun::RegisterFunction(BuiltinFunctions &set) {
872: 	set.AddFunction(ScalarFunction("gamma", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
873: 	                               UnaryDoubleFunctionWrapper<double, GammaOperator>));
874: }
875: 
876: //===--------------------------------------------------------------------===//
877: // gamma
878: //===--------------------------------------------------------------------===//
879: struct LogGammaOperator {
880: 	template <class TA, class TR>
881: 	static inline TR Operation(TA left) {
882: 		return std::lgamma(left);
883: 	}
884: };
885: 
886: void LogGammaFun::RegisterFunction(BuiltinFunctions &set) {
887: 	set.AddFunction(ScalarFunction("lgamma", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
888: 	                               UnaryDoubleFunctionWrapper<double, LogGammaOperator>));
889: }
890: 
891: //===--------------------------------------------------------------------===//
892: // factorial(), !
893: //===--------------------------------------------------------------------===//
894: 
895: struct FactorialOperator {
896: 	template <class TA, class TR>
897: 	static inline TR Operation(TA left) {
898: 		TR ret = 1;
899: 		for (TA i = 2; i <= left; i++) {
900: 			ret *= i;
901: 		}
902: 		return ret;
903: 	}
904: };
905: 
906: void FactorialFun::RegisterFunction(BuiltinFunctions &set) {
907: 	auto fun = ScalarFunction({LogicalType::INTEGER}, LogicalType::HUGEINT,
908: 	                          ScalarFunction::UnaryFunction<int32_t, hugeint_t, FactorialOperator>);
909: 
910: 	set.AddFunction({"factorial", "!__postfix"}, fun);
911: }
912: 
913: } // namespace duckdb
[end of src/function/scalar/math/numeric.cpp]
[start of src/function/scalar/math_functions.cpp]
1: #include "duckdb/function/scalar/math_functions.hpp"
2: #include "duckdb/common/exception.hpp"
3: 
4: namespace duckdb {
5: 
6: void BuiltinFunctions::RegisterMathFunctions() {
7: 	Register<AbsFun>();
8: 	Register<SignFun>();
9: 
10: 	Register<CeilFun>();
11: 	Register<FloorFun>();
12: 	Register<RoundFun>();
13: 
14: 	Register<DegreesFun>();
15: 	Register<RadiansFun>();
16: 
17: 	Register<CbrtFun>();
18: 	Register<ExpFun>();
19: 	Register<Log2Fun>();
20: 	Register<Log10Fun>();
21: 	Register<LnFun>();
22: 	Register<PowFun>();
23: 	Register<RandomFun>();
24: 	Register<SetseedFun>();
25: 	Register<SqrtFun>();
26: 
27: 	Register<PiFun>();
28: 
29: 	Register<BitCountFun>();
30: 
31: 	Register<GammaFun>();
32: 	Register<LogGammaFun>();
33: 
34: 	Register<FactorialFun>();
35: 
36: 	Register<NextAfterFun>();
37: }
38: 
39: } // namespace duckdb
[end of src/function/scalar/math_functions.cpp]
[start of src/include/duckdb/function/scalar/math_functions.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/scalar/math_functions.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/scalar_function.hpp"
12: #include "duckdb/function/function_set.hpp"
13: 
14: namespace duckdb {
15: 
16: struct AbsFun {
17: 	static void RegisterFunction(BuiltinFunctions &set);
18: };
19: 
20: struct SignFun {
21: 	static void RegisterFunction(BuiltinFunctions &set);
22: };
23: 
24: struct CeilFun {
25: 	static void RegisterFunction(BuiltinFunctions &set);
26: };
27: 
28: struct FloorFun {
29: 	static void RegisterFunction(BuiltinFunctions &set);
30: };
31: 
32: struct RoundFun {
33: 	static void RegisterFunction(BuiltinFunctions &set);
34: };
35: 
36: struct DegreesFun {
37: 	static void RegisterFunction(BuiltinFunctions &set);
38: };
39: 
40: struct RadiansFun {
41: 	static void RegisterFunction(BuiltinFunctions &set);
42: };
43: 
44: struct RandomFun {
45: 	static void RegisterFunction(BuiltinFunctions &set);
46: };
47: 
48: struct SetseedFun {
49: 	static void RegisterFunction(BuiltinFunctions &set);
50: };
51: 
52: struct CbrtFun {
53: 	static void RegisterFunction(BuiltinFunctions &set);
54: };
55: 
56: struct ExpFun {
57: 	static void RegisterFunction(BuiltinFunctions &set);
58: };
59: 
60: struct Log2Fun {
61: 	static void RegisterFunction(BuiltinFunctions &set);
62: };
63: 
64: struct Log10Fun {
65: 	static void RegisterFunction(BuiltinFunctions &set);
66: };
67: 
68: struct LnFun {
69: 	static void RegisterFunction(BuiltinFunctions &set);
70: };
71: 
72: struct PowFun {
73: 	static void RegisterFunction(BuiltinFunctions &set);
74: };
75: 
76: struct SqrtFun {
77: 	static void RegisterFunction(BuiltinFunctions &set);
78: };
79: 
80: struct PiFun {
81: 	static void RegisterFunction(BuiltinFunctions &set);
82: };
83: 
84: struct BitCountFun {
85: 	static void RegisterFunction(BuiltinFunctions &set);
86: };
87: 
88: struct GammaFun {
89: 	static void RegisterFunction(BuiltinFunctions &set);
90: };
91: 
92: struct LogGammaFun {
93: 	static void RegisterFunction(BuiltinFunctions &set);
94: };
95: 
96: struct FactorialFun {
97: 	static void RegisterFunction(BuiltinFunctions &set);
98: };
99: 
100: struct NextAfterFun {
101: 	static void RegisterFunction(BuiltinFunctions &set);
102: };
103: 
104: } // namespace duckdb
[end of src/include/duckdb/function/scalar/math_functions.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: