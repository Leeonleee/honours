{
  "repo": "duckdb/duckdb",
  "pull_number": 8073,
  "instance_id": "duckdb__duckdb-8073",
  "issue_numbers": [
    "8062"
  ],
  "base_commit": "da69aeaad72d7f72c54b1c7ebec380b7974d1a69",
  "patch": "diff --git a/src/planner/binder/statement/bind_create_table.cpp b/src/planner/binder/statement/bind_create_table.cpp\nindex 098135ee7a75..f85fd915b1b2 100644\n--- a/src/planner/binder/statement/bind_create_table.cpp\n+++ b/src/planner/binder/statement/bind_create_table.cpp\n@@ -297,10 +297,9 @@ unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateIn\n \n \t\tif (type_dependency) {\n \t\t\t// Only if the USER comes from a create type\n-\t\t\tif (!schema.catalog.IsTemporaryCatalog()) {\n-\t\t\t\t// If it is not a TEMP table we add a dependency\n-\t\t\t\tresult->dependencies.AddDependency(*type_dependency);\n-\t\t\t} else {\n+\t\t\tif (schema.catalog.IsTemporaryCatalog() && column.Type().id() == LogicalTypeId::ENUM) {\n+\t\t\t\t// for enum types that are used in tables in the temp catalog, we need to\n+\t\t\t\t// make a copy of the enum type definition that is accessible there\n \t\t\t\tauto enum_type = type_dependency->user_type;\n \t\t\t\tauto &enum_entries = EnumType::GetValuesInsertOrder(enum_type);\n \t\t\t\tauto enum_size = EnumType::GetSize(enum_type);\n@@ -313,6 +312,8 @@ unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateIn\n \t\t\t\t}\n \t\t\t\tauto copy_type = LogicalType::ENUM(EnumType::GetTypeName(enum_type), copy_enum_entries_vec, enum_size);\n \t\t\t\tcolumn.SetType(copy_type);\n+\t\t\t} else {\n+\t\t\t\tresult->dependencies.AddDependency(*type_dependency);\n \t\t\t}\n \t\t}\n \t}\n",
  "test_patch": "diff --git a/test/sql/json/test_json_temp_8062.test b/test/sql/json/test_json_temp_8062.test\nnew file mode 100644\nindex 000000000000..89186548d221\n--- /dev/null\n+++ b/test/sql/json/test_json_temp_8062.test\n@@ -0,0 +1,17 @@\n+# name: test/sql/json/test_json_temp_8062.test\n+# description: Test JSON fields in temporary tables for issue 8062\n+# group: [json]\n+\n+# Can't do reload tests with temp tables\n+require skip_reload\n+\n+require json\n+\n+statement ok\n+CREATE TEMP TABLE j1(x json);\n+\n+statement ok\n+INSERT INTO j1(x) VALUES ('[1, 2, 3]');\n+\n+statement ok\n+SELECT * FROM j1;\n",
  "problem_statement": "Cannot insert JSON values into TEMPORARY tables (Conversion Error)\n### What happens?\n\nInserting a string value into a _temporary_ table that has a JSON-typed column fails with a conversion error. (Non-temporary tables work fine.)\n\n### To Reproduce\n\n```\r\nCREATE TEMP TABLE foo (c_array json);\r\nINSERT INTO foo VALUES ('[1, 2, 3]');\r\n```\r\n\r\nThe insert statement will throw the error: ```Error: Conversion Error: Could not convert string '[1, 2, 3]' to UINT8```\n\n### OS:\n\nOS X\n\n### DuckDB Version:\n\n0.8.1\n\n### DuckDB Client:\n\nCLI and Python\n\n### Full Name:\n\nJosh Wills\n\n### Affiliation:\n\nUnaffiliated\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "FYI I'm going to try to fix this one myself as it has been a long time since I've fixed anything in here \u2764\ufe0f \r\n\r\n(if it's very obvious to one of you what's going on here, lmk and I will stop myself)\nI'm running into this too, where it's blocking an 0.8.1 upgrade. From nodejs and the duckdb shell. \r\n\r\nWe're also seeing `Assertion failed: (type.id() == LogicalTypeId::ENUM), function GetValuesInsertOrder, file types.cpp, line 1527.` in some cases, which might be related\nNoting that I wrote a test like this to try to repro the error:\r\n\r\n```\r\n# name: test/sql/json/test_json_temp_table.test\r\n# description: Test JSON fields in temporary tables\r\n# group: [json]\r\n\r\nrequire json\r\n\r\nstatement ok\r\nCREATE TEMP TABLE j1(x json);\r\n\r\nstatement ok\r\nINSERT INTO j1(x) VALUES ('[1, 2, 3]');\r\n\r\nstatement ok\r\nSELECT * FROM j1;\r\n```\r\n\r\n...but it passes instead of failing b/c it seems like somehow the `require json` makes the operation work, much to my confusion.\nSo it has to be that when the json extension registers its type info with the system catalog via `ExtensionUtil::RegisterType`, that information isn't getting propagated to the `TEMP_CATALOG` anymore, whereas it used to (somehow)\nconfirms that it must be something like this b/c I see the same problem with `spatial` types:\r\n\r\n```\r\nD INSTALL spatial;\r\nD LOAD spatial;\r\nD create table foo (g geometry);\r\nD DESCRIBE foo;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 column_name \u2502 column_type \u2502  null   \u2502   key   \u2502 default \u2502 extra \u2502\r\n\u2502   varchar   \u2502   varchar   \u2502 varchar \u2502 varchar \u2502 varchar \u2502 int32 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 g           \u2502 GEOMETRY    \u2502 YES     \u2502         \u2502         \u2502       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD CREATE temp table bar (g geometry);\r\nError: Invalid Error: std::bad_alloc\r\n```\nI'm suspicious of https://github.com/duckdb/duckdb/pull/7641 and am hacking on stuff in that general area of the code\nokay yeah, #7641 needs to be updated (somehow, not immediately obvious to me b/c it looks kind of complicated) to handle non-enum user-defined types, I think? When I just do a debug build with the json extension enabled and try to run my test queries, I get:\r\n\r\n```\r\njwills@Joshs-MBP duckdb % build/debug/duckdb\r\nv0.3.3-dev15642 da69aeaad7\r\nEnter \".help\" for usage hints.\r\nConnected to a transient in-memory database.\r\nUse \".open FILENAME\" to reopen on a persistent database.\r\nD load json;\r\nD CREATE TABLE foo (c1 json);\r\nD CREATE TEMP TABLE bar (c1 json);\r\nError: INTERNAL Error: Assertion triggered in file \"/Users/jwills/dev/duckdb/src/common/types.cpp\" on line 1527: type.id() == LogicalTypeId::ENUM\r\n```\r\n\r\n...and when I hack this line to be `if (true) {` then everything works as expected for the json fields in temp tables: https://github.com/duckdb/duckdb/blob/master/src/planner/binder/statement/bind_create_table.cpp#L300",
  "created_at": "2023-06-24T14:30:41Z"
}