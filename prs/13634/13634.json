{
  "repo": "duckdb/duckdb",
  "pull_number": 13634,
  "instance_id": "duckdb__duckdb-13634",
  "issue_numbers": [
    "10617"
  ],
  "base_commit": "48a8b81d5264adae02777b80b73d69be6ea6aa36",
  "patch": "diff --git a/src/common/enums/file_compression_type.cpp b/src/common/enums/file_compression_type.cpp\nindex 5df6add19cb3..44066f32c743 100644\n--- a/src/common/enums/file_compression_type.cpp\n+++ b/src/common/enums/file_compression_type.cpp\n@@ -19,4 +19,28 @@ FileCompressionType FileCompressionTypeFromString(const string &input) {\n \t}\n }\n \n+string CompressionExtensionFromType(const FileCompressionType type) {\n+\tswitch (type) {\n+\tcase FileCompressionType::GZIP:\n+\t\treturn \".gz\";\n+\tcase FileCompressionType::ZSTD:\n+\t\treturn \".zst\";\n+\tdefault:\n+\t\tthrow NotImplementedException(\"Compression Extension of file compression type is not implemented\");\n+\t}\n+}\n+\n+bool IsFileCompressed(string path, FileCompressionType type) {\n+\tauto extension = CompressionExtensionFromType(type);\n+\tstd::size_t question_mark_pos = std::string::npos;\n+\tif (!StringUtil::StartsWith(path, \"\\\\\\\\?\\\\\")) {\n+\t\tquestion_mark_pos = path.find('?');\n+\t}\n+\tpath = path.substr(0, question_mark_pos);\n+\tif (StringUtil::EndsWith(path, extension)) {\n+\t\treturn true;\n+\t}\n+\treturn false;\n+}\n+\n } // namespace duckdb\ndiff --git a/src/common/virtual_file_system.cpp b/src/common/virtual_file_system.cpp\nindex 3bc099a2bd01..74892a4e0590 100644\n--- a/src/common/virtual_file_system.cpp\n+++ b/src/common/virtual_file_system.cpp\n@@ -13,15 +13,15 @@ unique_ptr<FileHandle> VirtualFileSystem::OpenFile(const string &path, FileOpenF\n                                                    optional_ptr<FileOpener> opener) {\n \tauto compression = flags.Compression();\n \tif (compression == FileCompressionType::AUTO_DETECT) {\n-\t\t// auto detect compression settings based on file name\n+\t\t// auto-detect compression settings based on file name\n \t\tauto lower_path = StringUtil::Lower(path);\n \t\tif (StringUtil::EndsWith(lower_path, \".tmp\")) {\n \t\t\t// strip .tmp\n \t\t\tlower_path = lower_path.substr(0, lower_path.length() - 4);\n \t\t}\n-\t\tif (StringUtil::EndsWith(lower_path, \".gz\")) {\n+\t\tif (IsFileCompressed(path, FileCompressionType::GZIP)) {\n \t\t\tcompression = FileCompressionType::GZIP;\n-\t\t} else if (StringUtil::EndsWith(lower_path, \".zst\")) {\n+\t\t} else if (IsFileCompressed(path, FileCompressionType::ZSTD)) {\n \t\t\tcompression = FileCompressionType::ZSTD;\n \t\t} else {\n \t\t\tcompression = FileCompressionType::UNCOMPRESSED;\ndiff --git a/src/function/table/copy_csv.cpp b/src/function/table/copy_csv.cpp\nindex a94df0b7a6ad..b2c16a671721 100644\n--- a/src/function/table/copy_csv.cpp\n+++ b/src/function/table/copy_csv.cpp\n@@ -182,13 +182,13 @@ static unique_ptr<FunctionData> WriteCSVBind(ClientContext &context, CopyFunctio\n \n \tswitch (bind_data->options.compression) {\n \tcase FileCompressionType::GZIP:\n-\t\tif (!StringUtil::EndsWith(input.file_extension, \".gz\")) {\n-\t\t\tinput.file_extension += \".gz\";\n+\t\tif (!IsFileCompressed(input.file_extension, FileCompressionType::GZIP)) {\n+\t\t\tinput.file_extension += CompressionExtensionFromType(FileCompressionType::GZIP);\n \t\t}\n \t\tbreak;\n \tcase FileCompressionType::ZSTD:\n-\t\tif (!StringUtil::EndsWith(input.file_extension, \".zst\")) {\n-\t\t\tinput.file_extension += \".zst\";\n+\t\tif (!IsFileCompressed(input.file_extension, FileCompressionType::ZSTD)) {\n+\t\t\tinput.file_extension += CompressionExtensionFromType(FileCompressionType::ZSTD);\n \t\t}\n \t\tbreak;\n \tdefault:\ndiff --git a/src/function/table/read_csv.cpp b/src/function/table/read_csv.cpp\nindex 7d78c8f23561..934641567e87 100644\n--- a/src/function/table/read_csv.cpp\n+++ b/src/function/table/read_csv.cpp\n@@ -390,9 +390,9 @@ unique_ptr<TableRef> ReadCSVReplacement(ClientContext &context, ReplacementScanI\n \tauto table_name = ReplacementScan::GetFullPath(input);\n \tauto lower_name = StringUtil::Lower(table_name);\n \t// remove any compression\n-\tif (StringUtil::EndsWith(lower_name, \".gz\")) {\n+\tif (StringUtil::EndsWith(lower_name, CompressionExtensionFromType(FileCompressionType::GZIP))) {\n \t\tlower_name = lower_name.substr(0, lower_name.size() - 3);\n-\t} else if (StringUtil::EndsWith(lower_name, \".zst\")) {\n+\t} else if (StringUtil::EndsWith(lower_name, CompressionExtensionFromType(FileCompressionType::ZSTD))) {\n \t\tif (!Catalog::TryAutoLoad(context, \"parquet\")) {\n \t\t\tthrow MissingExtensionException(\"parquet extension is required for reading zst compressed file\");\n \t\t}\ndiff --git a/src/function/table/sniff_csv.cpp b/src/function/table/sniff_csv.cpp\nindex 0df333517afd..56aa4a957c5a 100644\n--- a/src/function/table/sniff_csv.cpp\n+++ b/src/function/table/sniff_csv.cpp\n@@ -110,13 +110,14 @@ static void CSVSniffFunction(ClientContext &context, TableFunctionInput &data_p,\n \tconst CSVSniffFunctionData &data = data_p.bind_data->Cast<CSVSniffFunctionData>();\n \tauto &fs = duckdb::FileSystem::GetFileSystem(context);\n \n-\tif (data.path.rfind(\"http://\", 0) != 0 && data.path.rfind(\"https://\", 0) != 0 && fs.HasGlob(data.path)) {\n-\t\tthrow NotImplementedException(\"sniff_csv does not operate on globs yet\");\n+\tauto paths = fs.GlobFiles(data.path, context, FileGlobOptions::DISALLOW_EMPTY);\n+\tif (paths.size() > 1) {\n+\t\tthrow NotImplementedException(\"sniff_csv does not operate on more than one file yet\");\n \t}\n \n \t// We must run the sniffer.\n \tauto sniffer_options = data.options;\n-\tsniffer_options.file_path = data.path;\n+\tsniffer_options.file_path = paths[0];\n \n \tauto buffer_manager = make_shared_ptr<CSVBufferManager>(context, sniffer_options, sniffer_options.file_path, 0);\n \tif (sniffer_options.name_list.empty()) {\n@@ -204,7 +205,7 @@ static void CSVSniffFunction(ClientContext &context, TableFunctionInput &data_p,\n \tstd::ostringstream csv_read;\n \n \t// Base, Path and auto_detect=false\n-\tcsv_read << \"FROM read_csv('\" << data.path << \"'\" << separator << \"auto_detect=false\" << separator;\n+\tcsv_read << \"FROM read_csv('\" << paths[0] << \"'\" << separator << \"auto_detect=false\" << separator;\n \t// 10.1. Delimiter\n \tif (!sniffer_options.dialect_options.state_machine_options.delimiter.IsSetByUser()) {\n \t\tcsv_read << \"delim=\"\ndiff --git a/src/include/duckdb/common/enums/file_compression_type.hpp b/src/include/duckdb/common/enums/file_compression_type.hpp\nindex 98fe5e75c532..77b66b3920d4 100644\n--- a/src/include/duckdb/common/enums/file_compression_type.hpp\n+++ b/src/include/duckdb/common/enums/file_compression_type.hpp\n@@ -16,4 +16,8 @@ enum class FileCompressionType : uint8_t { AUTO_DETECT = 0, UNCOMPRESSED = 1, GZ\n \n FileCompressionType FileCompressionTypeFromString(const string &input);\n \n+string CompressionExtensionFromType(const FileCompressionType type);\n+\n+bool IsFileCompressed(string path, FileCompressionType type);\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/function/replacement_scan.hpp b/src/include/duckdb/function/replacement_scan.hpp\nindex edaf455e56b2..75ce069a846e 100644\n--- a/src/include/duckdb/function/replacement_scan.hpp\n+++ b/src/include/duckdb/function/replacement_scan.hpp\n@@ -10,6 +10,7 @@\n \n #include \"duckdb/common/common.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/common/enums/file_compression_type.hpp\"\n \n namespace duckdb {\n \n@@ -59,9 +60,9 @@ struct ReplacementScan {\n \tstatic bool CanReplace(const string &table_name, const vector<string> &extensions) {\n \t\tauto lower_name = StringUtil::Lower(table_name);\n \n-\t\tif (StringUtil::EndsWith(lower_name, \".gz\")) {\n+\t\tif (StringUtil::EndsWith(lower_name, CompressionExtensionFromType(FileCompressionType::GZIP))) {\n \t\t\tlower_name = lower_name.substr(0, lower_name.size() - 3);\n-\t\t} else if (StringUtil::EndsWith(lower_name, \".zst\")) {\n+\t\t} else if (StringUtil::EndsWith(lower_name, CompressionExtensionFromType(FileCompressionType::ZSTD))) {\n \t\t\tlower_name = lower_name.substr(0, lower_name.size() - 4);\n \t\t}\n \ndiff --git a/src/main/extension/extension_install.cpp b/src/main/extension/extension_install.cpp\nindex af93a0dd613c..f45f3413cc9d 100644\n--- a/src/main/extension/extension_install.cpp\n+++ b/src/main/extension/extension_install.cpp\n@@ -209,7 +209,7 @@ string ExtensionHelper::ExtensionUrlTemplate(optional_ptr<const DatabaseInstance\n \tversioned_path = versioned_path + \".wasm\";\n #else\n \tstring default_endpoint = ExtensionRepository::DEFAULT_REPOSITORY_URL;\n-\tversioned_path = versioned_path + \".gz\";\n+\tversioned_path = versioned_path + CompressionExtensionFromType(FileCompressionType::GZIP);\n #endif\n \tstring url_template = repository.path + versioned_path;\n \treturn url_template;\n@@ -290,7 +290,7 @@ static unique_ptr<ExtensionInstallInfo> DirectInstallExtension(DatabaseInstance\n \tbool exists = fs.FileExists(file);\n \n \t// Recheck without .gz\n-\tif (!exists && StringUtil::EndsWith(file, \".gz\")) {\n+\tif (!exists && StringUtil::EndsWith(file, CompressionExtensionFromType(FileCompressionType::GZIP))) {\n \t\tfile = file.substr(0, file.size() - 3);\n \t\texists = fs.FileExists(file);\n \t}\n",
  "test_patch": "diff --git a/test/sql/copy/csv/test_sniff_csv.test b/test/sql/copy/csv/test_sniff_csv.test\nindex 1b4ba47f0b06..ed65b4f06796 100644\n--- a/test/sql/copy/csv/test_sniff_csv.test\n+++ b/test/sql/copy/csv/test_sniff_csv.test\n@@ -27,7 +27,7 @@ FROM sniff_csv('data/csv/real/lineitem_sample.csv');\n statement error\n FROM sniff_csv('data/csv/real/non_ecziste.csv');\n ----\n-Cannot open file \"data/csv/real/non_ecziste.csv\": No such file or directory\n+No files found that match the pattern \"data/csv/real/non_ecziste.csv\"\n \n # Test different sample sizes\n \ndiff --git a/test/sql/copy/csv/test_sniff_csv_options.test b/test/sql/copy/csv/test_sniff_csv_options.test\nindex e19e72adcf1d..da8cdaa66f03 100644\n--- a/test/sql/copy/csv/test_sniff_csv_options.test\n+++ b/test/sql/copy/csv/test_sniff_csv_options.test\n@@ -118,7 +118,7 @@ FROM read_csv('data/csv/autotypecandidates.csv', auto_detect=false, delim='|', q\n statement error\n FROM sniff_csv('data/csv/hive-partitioning/simple/*/*/test.csv');\n ----\n-sniff_csv does not operate on globs yet\n+Not implemented Error: sniff_csv does not operate on more than one file yet\n \n # don't accept madeup options\n statement error\ndiff --git a/test/sql/copy/csv/test_sniff_httpfs.test b/test/sql/copy/csv/test_sniff_httpfs.test\nnew file mode 100644\nindex 000000000000..ea36b9be17ab\n--- /dev/null\n+++ b/test/sql/copy/csv/test_sniff_httpfs.test\n@@ -0,0 +1,14 @@\n+# name: test/sql/copy/csv/test_sniff_httpfs.test\n+# description: Test sniff_csv functions over httpfs with auto-detection on compression\n+# group: [csv]\n+\n+require httpfs\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+from sniff_csv('https://github.com/duckdb/duckdb/raw/main/data/csv/who.csv.gz');\n+\n+statement ok\n+from sniff_csv('https://github.com/duckdb/duckdb/raw/main/data/csv/who.csv.gz?v=1');\ndiff --git a/test/sqlite/sqllogic_test_runner.cpp b/test/sqlite/sqllogic_test_runner.cpp\nindex 762928175ac3..daf384750bee 100644\n--- a/test/sqlite/sqllogic_test_runner.cpp\n+++ b/test/sqlite/sqllogic_test_runner.cpp\n@@ -893,7 +893,7 @@ void SQLLogicTestRunner::ExecuteFile(string script) {\n \n \t\t\t// file name\n \t\t\tidx_t filename_start_pos = input_path.find_last_of(\"/\") + 1;\n-\t\t\tif (!StringUtil::EndsWith(input_path, \".gz\")) {\n+\t\t\tif (!StringUtil::EndsWith(input_path, CompressionExtensionFromType(FileCompressionType::GZIP))) {\n \t\t\t\tparser.Fail(\"unzip: input has not a GZIP extension\");\n \t\t\t}\n \t\t\tstring filename = input_path.substr(filename_start_pos, input_path.size() - filename_start_pos - 3);\n",
  "problem_statement": "sniff_csv fails to detect compression when reading from a url that has a query string\n### What happens?\n\n`sniff_csv` fails to  detect compression when reading from a url that has a query string.\r\n\r\nFor example this statement\r\n```sql\r\nfrom sniff_csv('https://github.com/duckdb/duckdb/raw/main/data/csv/who.csv.gz?v=1');\r\n```\r\nFails withs this error\r\n```text\r\nError: Invalid Input Error: Invalid unicode (byte sequence mismatch) detected in value construction\r\n```\r\n\r\nbut this statement succeeds\r\n```sql\r\nfrom sniff_csv('https://github.com/duckdb/duckdb/raw/main/data/csv/who.csv.gz');\r\n```\r\n\r\nThe root cause of this is in the file at line src/common/virtual_file_system.cpp at line 15 https://github.com/duckdb/duckdb/blob/4d24f5c660a205bf22a7fd99e36efece798452c4/src/common/virtual_file_system.cpp#L15 and could be fixed with a check for url and remove the query string path.\r\n\r\n\r\nI will open a PR for this.\r\n\n\n### To Reproduce\n\nRun this statement\r\n```sql\r\nfrom sniff_csv('https://github.com/duckdb/duckdb/raw/main/data/csv/who.csv.gz?v=1');\r\n```\n\n### OS:\n\nall\n\n### DuckDB Version:\n\n0.9.3\n\n### DuckDB Client:\n\nall\n\n### Full Name:\n\nGabriel Hodoroaga\n\n### Affiliation:\n\nBobsled\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a nightly build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "> I will open a PR for this.\r\n\r\nPlease don't do that today, we're trying to not put unnecessary pressure on the CI as we're looking to release later today\nThis issue is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.\nThis issue was closed because it has been stale for 30 days with no activity.",
  "created_at": "2024-08-29T15:39:52Z"
}