You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
dbWriteTable not escaping column names in 0.3.1 release
#### What happens?

Version 0.3.1, using ``dbWriteTable()`` with a ``name`` column in ``field.types`` specified results in invalid SQL being generated.

This has been picked up by CRAN package checks on the downstream MFDB package: https://cran.r-project.org/web/checks/check_results_mfdb.html

#### To Reproduce

```
> db <- DBI::dbConnect(duckdb::duckdb())
> DBI::dbWriteTable(db, basename(tempfile("temp_")),
+     data.frame(id = 1:3, name = c("cuthbert", "dibble", "grubb")),
+     field.types = c(id = "INTEGER", name = "VARCHAR"))
Error in .local(conn, statement, ...) :
  duckdb_prepare_R: Failed to prepare query CREATE  TABLE "temp_226be6a3dc5d1" AS SELECT #1::INTEGER id,#2::VARCHAR name FROM _duckdb_write_view_vcxzjonvgn
Error: Parser Error: syntax error at or near "name"
LINE 1: ..." AS SELECT #1::INTEGER id,#2::VARCHAR name FROM _duckdb_write_view_vcxzjonvgn
                                                  ^
Environment:
  1: DBI::dbWriteTable(db, basename(tempfile("temp_")), data.frame(id = 1:3, name = c("cuthbert", "dibble", "grubb")), field.types = c(id = "INTEGER",
  2: DBI::dbWriteTable(db, basename(tempfile("temp_")), data.frame(id = 1:3, name = c("cuthbert", "dibble", "grubb")), field.types = c(id = "INTEGER",
  3: .local(conn, name, value, ...)
  4: dbExecute(conn, SQL(sprintf("CREATE %s TABLE %s AS SELECT %s FROM %s", temp_str, table_name, paste(cols, collapse = ","), view_name)))
  5: dbExecute(conn, SQL(sprintf("CREATE %s TABLE %s AS SELECT %s FROM %s", temp_str, table_name, paste(cols, collapse = ","), view_name)))
  6: dbSendStatement(conn, statement, ...)
  7: dbSendStatement(conn, statement, ...)
  8: dbSendQuery(conn, statement, ...)
  9: dbSendQuery(conn, statement, ...)
  10: .local(conn, statement, ...)
```

The command-line thinks this is invalid SQL too (and is fair enough IMO, name is probably a reserved word):

```
v0.3.1 88aa81c6b
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
D CREATE TABLE moo (moo_id INTEGER, name VARCHAR);
D SELECT #1::INTEGER, #2::VARCHAR name FROM moo;
Error: Parser Error: syntax error at or near "name"
LINE 1: SELECT #1::INTEGER, #2::VARCHAR name FROM moo;
```

If you ask me the bug is here, the SQL generation isn't escaping the column name:

https://github.com/duckdb/duckdb/blob/9fd0403b69f768bb6dca03aa5a841a96cd306348/tools/rpkg/R/Connection.R#L184

this was added in this commit, part of 0.3.1 https://github.com/duckdb/duckdb/commit/8aed295921e65ea4320348026e74f461708bc043. I can make a pull request to add some escaping here if that's useful?

Cheers!

#### Environment (please complete the following information):
 - OS: ``Debian GNU/Linux 10 (buster)``
 - DuckDB Version: ``0.3.2``
 - DuckDB Client: ``R version 4.1.1 (2021-08-10)``

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of tools/rpkg/R/Connection.R]
1: #' DuckDB driver class
2: #'
3: #' Implements \linkS4class{DBIDriver}.
4: #'
5: #' @aliases duckdb_driver
6: #' @keywords internal
7: #' @export
8: setClass("duckdb_driver", contains = "DBIDriver", slots = list(database_ref = "externalptr", dbdir = "character", read_only = "logical"))
9: 
10: #' DuckDB connection class
11: #'
12: #' Implements \linkS4class{DBIConnection}.
13: #'
14: #' @aliases duckdb_connection
15: #' @keywords internal
16: #' @export
17: setClass("duckdb_connection",
18:   contains = "DBIConnection",
19:   slots = list(conn_ref = "externalptr",
20:                driver = "duckdb_driver",
21:                debug = "logical",
22:                timezone_out = "character",
23:                tz_out_convert = "character")
24: )
25: 
26: duckdb_connection <- function(duckdb_driver, debug) {
27:   new(
28:     "duckdb_connection",
29:     conn_ref = .Call(duckdb_connect_R, duckdb_driver@database_ref),
30:     driver = duckdb_driver,
31:     debug = debug,
32:     timezone_out = "UTC",
33:     tz_out_convert = "with"
34:   )
35: }
36: 
37: #' @rdname duckdb_connection-class
38: #' @inheritParams methods::show
39: #' @export
40: setMethod(
41:   "show", "duckdb_connection",
42:   function(object) {
43:     message(sprintf("<duckdb_connection %s driver=%s>", extptr_str(object@conn_ref), drv_to_string(object@driver)))
44:     invisible(NULL)
45:   }
46: )
47: 
48: #' @rdname duckdb_connection-class
49: #' @inheritParams DBI::dbIsValid
50: #' @export
51: setMethod(
52:   "dbIsValid", "duckdb_connection",
53:   function(dbObj, ...) {
54:     valid <- FALSE
55:     tryCatch(
56:       {
57:         dbGetQuery(dbObj, SQL("SELECT 1"))
58:         valid <- TRUE
59:       },
60:       error = function(c) {
61:       }
62:     )
63:     valid
64:   }
65: )
66: 
67: #' @rdname duckdb_connection-class
68: #' @inheritParams DBI::dbSendQuery
69: #' @inheritParams DBI::dbBind
70: #' @param arrow Whether the query should be returned as an Arrow Table
71: #' @export
72: setMethod(
73:   "dbSendQuery", c("duckdb_connection", "character"),
74:   function(conn, statement, params = NULL, ..., arrow=FALSE) {
75:     if (conn@debug) {
76:       message("Q ", statement)
77:     }
78:     statement <- enc2utf8(statement)
79:     stmt_lst <- .Call(duckdb_prepare_R, conn@conn_ref, statement)
80: 
81:     res <- duckdb_result(
82:       connection = conn,
83:       stmt_lst = stmt_lst,
84:       arrow = arrow
85:     )
86:     if (length(params) > 0) {
87:       dbBind(res, params)
88:     }
89:     return(res)
90:   }
91: )
92: 
93: #' @rdname duckdb_connection-class
94: #' @inheritParams DBI::dbDataType
95: #' @export
96: setMethod(
97:   "dbDataType", "duckdb_connection",
98:   function(dbObj, obj, ...) {
99:     dbDataType(dbObj@driver, obj, ...)
100:   }
101: )
102: 
103: duckdb_random_string <- function(x) {
104:   paste(sample(letters, 10, replace = TRUE), collapse = "")
105: }
106: 
107: #' @rdname duckdb_connection-class
108: #' @inheritParams DBI::dbWriteTable
109: #' @param row.names Whether the row.names of the data.frame should be preserved
110: #' @param overwrite If a table with the given name already exists, should it be overwritten?
111: #' @param append If a table with the given name already exists, just try to append the passed data to it
112: #' @param field.types Override the auto-generated SQL types
113: #' @param temporary Should the created table be temporary?
114: #' @export
115: setMethod(
116:   "dbWriteTable", c("duckdb_connection", "character", "data.frame"),
117:   function(conn,
118:            name,
119:            value,
120:            row.names = FALSE,
121:            overwrite = FALSE,
122:            append = FALSE,
123:            field.types = NULL,
124:            temporary = FALSE,
125:            ...) {
126:     check_flag(overwrite)
127:     check_flag(append)
128:     check_flag(temporary)
129: 
130:     # TODO: start a transaction if one is not already running
131: 
132:     if (overwrite && append) {
133:       stop("Setting both overwrite and append makes no sense")
134:     }
135: 
136:     if (!is.null(field.types)) {
137:       if (!(is.character(field.types) && !is.null(names(field.types)) && !anyDuplicated(names(field.types)))) {
138:         stop("`field.types` must be a named character vector with unique names, or NULL")
139:       }
140:     }
141:     if (append && !is.null(field.types)) {
142:       stop("Cannot specify `field.types` with `append = TRUE`")
143:     }
144: 
145:     value <- as.data.frame(value)
146:     if (!is.data.frame(value)) {
147:       stop("need a data frame as parameter")
148:     }
149: 
150:     # use Kirill's magic, convert rownames to additional column
151:     value <- sqlRownamesToColumn(value, row.names)
152: 
153:     if (dbExistsTable(conn, name)) {
154:       if (overwrite) {
155:         dbRemoveTable(conn, name)
156:       }
157:       if (!overwrite && !append) {
158:         stop(
159:           "Table ",
160:           name,
161:           " already exists. Set `overwrite = TRUE` if you want to remove the existing table. ",
162:           "Set `append = TRUE` if you would like to add the new data to the existing table."
163:         )
164:       }
165:     }
166:     table_name <- dbQuoteIdentifier(conn, name)
167: 
168:     if (!dbExistsTable(conn, name)) {
169:         view_name <- sprintf("_duckdb_write_view_%s", duckdb_random_string())
170:         on.exit(duckdb_unregister(conn, view_name))
171:         duckdb_register(conn, view_name, value)
172: 
173:         temp_str <- ""
174:         if (temporary) temp_str <- "TEMPORARY"
175: 
176:         col_names <- dbGetQuery(conn, SQL(sprintf(
177:           "DESCRIBE %s", view_name
178:         )))$Field
179: 
180:         cols <- character()
181:         col_idx <- 1
182:         for (name in col_names) {
183:             if (name %in% names(field.types)) {
184:                 cols <- c(cols, sprintf("#%d::%s %s", col_idx, field.types[name], name))
185:             }
186:             else {
187:                 cols <- c(cols, sprintf("#%d", col_idx))
188:             }
189:             col_idx <- col_idx + 1
190:          }
191:         dbExecute(conn, SQL(sprintf("CREATE %s TABLE %s AS SELECT %s FROM %s", temp_str, table_name, paste(cols, collapse=","), view_name)))
192:         rs_on_connection_updated(conn, hint=paste0("Create table'", table_name,"'"))
193:     } else {
194:         dbAppendTable(conn, name, value)
195:     }
196:     invisible(TRUE)
197:   }
198: )
199: 
200: #' @rdname duckdb_connection-class
201: #' @inheritParams DBI::dbAppendTable
202: #' @export
203: setMethod(
204:   "dbAppendTable", "duckdb_connection",
205:   function(conn, name, value, ..., row.names = NULL) {
206:     if (!is.null(row.names)) {
207:       stop("Can't pass `row.names` to `dbAppendTable()`")
208:     }
209: 
210:     target_names <- dbListFields(conn, name)
211: 
212:     if (!all(names(value) %in% target_names)) {
213:       stop("Column `", setdiff(names(value), target_names)[[1]], "` does not exist in target table.")
214:     }
215: 
216:     if (nrow(value)) {
217:       table_name <- dbQuoteIdentifier(conn, name)
218: 
219:       view_name <- sprintf("_duckdb_append_view_%s", duckdb_random_string())
220:       on.exit(duckdb_unregister(conn, view_name))
221:       duckdb_register(conn, view_name, value)
222: 
223:       sql <- paste0(
224:         "INSERT INTO ", table_name, "\n",
225:         "(", paste(dbQuoteIdentifier(conn, names(value)), collapse = ", "), ")\n",
226:         "SELECT * FROM ", view_name
227:       )
228: 
229:       dbExecute(conn, sql)
230: 
231:       rs_on_connection_updated(conn, hint=paste0("Updated table'", table_name,"'"))
232:     }
233: 
234:     invisible(nrow(value))
235:   }
236: )
237: 
238: 
239: #' @rdname duckdb_connection-class
240: #' @inheritParams DBI::dbListTables
241: #' @export
242: setMethod(
243:   "dbListTables", "duckdb_connection",
244:   function(conn, ...) {
245:     dbGetQuery(
246:       conn,
247:       SQL(
248:         "SELECT name FROM sqlite_master WHERE type='table' OR type='view' ORDER BY name"
249:       )
250:     )[[1]]
251:   }
252: )
253: 
254: #' @rdname duckdb_connection-class
255: #' @inheritParams DBI::dbExistsTable
256: #' @export
257: setMethod(
258:   "dbExistsTable", c("duckdb_connection", "character"),
259:   function(conn, name, ...) {
260:     if (!dbIsValid(conn)) {
261:       stop("Invalid connection")
262:     }
263:     if (length(name) != 1) {
264:       stop("Can only have a single name argument")
265:     }
266:     exists <- FALSE
267:     tryCatch(
268:       {
269:         dbGetQuery(
270:           conn,
271:           sqlInterpolate(
272:             conn,
273:             "SELECT * FROM ? WHERE FALSE",
274:             dbQuoteIdentifier(conn, name)
275:           )
276:         )
277:         exists <- TRUE
278:       },
279:       error = function(c) {
280:       }
281:     )
282:     exists
283:   }
284: )
285: 
286: #' @rdname duckdb_connection-class
287: #' @inheritParams DBI::dbListFields
288: #' @export
289: setMethod(
290:   "dbListFields", c("duckdb_connection", "character"),
291:   function(conn, name, ...) {
292:     names(dbGetQuery(
293:       conn,
294:       sqlInterpolate(
295:         conn,
296:         "SELECT * FROM ? WHERE FALSE",
297:         dbQuoteIdentifier(conn, name)
298:       )
299:     ))
300:   }
301: )
302: 
303: #' @rdname duckdb_connection-class
304: #' @inheritParams DBI::dbRemoveTable
305: #' @export
306: setMethod(
307:   "dbRemoveTable", c("duckdb_connection", "character"),
308:   function(conn, name, ..., fail_if_missing = TRUE) {
309:     sql <- paste0("DROP TABLE ", if (!fail_if_missing) "IF EXISTS ", "?")
310:     dbExecute(
311:       conn,
312:       sqlInterpolate(conn, sql, dbQuoteIdentifier(conn, name))
313:     )
314:     rs_on_connection_updated(conn, "Table removed")
315:     invisible(TRUE)
316:   }
317: )
318: 
319: #' @rdname duckdb_connection-class
320: #' @inheritParams DBI::dbGetInfo
321: #' @export
322: setMethod(
323:   "dbGetInfo", "duckdb_connection",
324:   function(dbObj, ...) {
325:     info <- dbGetInfo(dbObj@driver)
326:     list(
327:       dbname = info$dbname,
328:       db.version = info$driver.version,
329:       username = NA,
330:       host = NA,
331:       port = NA
332:     )
333:   }
334: )
335: 
336: #' @rdname duckdb_connection-class
337: #' @inheritParams DBI::dbBegin
338: #' @export
339: setMethod(
340:   "dbBegin", "duckdb_connection",
341:   function(conn, ...) {
342:     dbExecute(conn, SQL("BEGIN TRANSACTION"))
343:     invisible(TRUE)
344:   }
345: )
346: 
347: #' @rdname duckdb_connection-class
348: #' @inheritParams DBI::dbCommit
349: #' @export
350: setMethod(
351:   "dbCommit", "duckdb_connection",
352:   function(conn, ...) {
353:     dbExecute(conn, SQL("COMMIT"))
354:     invisible(TRUE)
355:   }
356: )
357: 
358: #' @rdname duckdb_connection-class
359: #' @inheritParams DBI::dbRollback
360: #' @export
361: setMethod(
362:   "dbRollback", "duckdb_connection",
363:   function(conn, ...) {
364:     dbExecute(conn, SQL("ROLLBACK"))
365:     invisible(TRUE)
366:   }
367: )
368: 
369: #' @rdname duckdb_connection-class
370: #' @export
371: setMethod(
372:   "dbQuoteLiteral", signature("duckdb_connection"),
373:   function(conn, x, ...) {
374:     # Switchpatching to avoid ambiguous S4 dispatch, so that our method
375:     # is used only if no alternatives are available.
376: 
377:     if (is(x, "SQL")) {
378:       return(x)
379:     }
380: 
381:     if (is.factor(x)) {
382:       return(dbQuoteString(conn, as.character(x)))
383:     }
384: 
385:     if (is.character(x)) {
386:       return(dbQuoteString(conn, x))
387:     }
388: 
389:     if (inherits(x, "POSIXt")) {
390:       out <- dbQuoteString(
391:         conn,
392:         strftime(as.POSIXct(x), "%Y-%m-%d %H:%M:%S", tz = "UTC")
393:       )
394: 
395:       return(SQL(paste0(out, "::timestamp")))
396:     }
397: 
398:     if (inherits(x, "Date")) {
399:       out <- callNextMethod()
400:       return(SQL(paste0(out, "::date")))
401:     }
402: 
403:     if (inherits(x, "difftime")) {
404:       out <- callNextMethod()
405:       return(SQL(paste0(out, "::time")))
406:     }
407: 
408:     if (is.list(x)) {
409:       blob_data <- vapply(
410:         x,
411:         function(x) {
412:           if (is.null(x)) {
413:             "NULL"
414:           } else if (is.raw(x)) {
415:             paste0("X'", paste(format(x), collapse = ""), "'")
416:           } else {
417:             stop("Lists must contain raw vectors or NULL", call. = FALSE)
418:           }
419:         },
420:         character(1)
421:       )
422:       return(SQL(blob_data, names = names(x)))
423:     }
424: 
425:     x <- as.character(x)
426:     x[is.na(x)] <- "NULL"
427:     SQL(x, names = names(x))
428:   }
429: )
[end of tools/rpkg/R/Connection.R]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: