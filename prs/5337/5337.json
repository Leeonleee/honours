{
  "repo": "duckdb/duckdb",
  "pull_number": 5337,
  "instance_id": "duckdb__duckdb-5337",
  "issue_numbers": [
    "5196"
  ],
  "base_commit": "cd887699028518c91cc81ec34dd32dec2437bdfc",
  "patch": "diff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp\nindex 83dfb687fca7..0a85cb17c045 100644\n--- a/src/common/operator/cast_operators.cpp\n+++ b/src/common/operator/cast_operators.cpp\n@@ -821,6 +821,16 @@ struct IntegerCastOperation {\n \t\treturn true;\n \t}\n \n+\ttemplate <class T, bool NEGATIVE>\n+\tstatic bool HandleBinaryDigit(T &state, uint8_t digit) {\n+\t\tusing result_t = typename T::Result;\n+\t\tif (state.result > (NumericLimits<result_t>::Maximum() - digit) / 2) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tstate.result = state.result * 2 + digit;\n+\t\treturn true;\n+\t}\n+\n \ttemplate <class T, bool NEGATIVE>\n \tstatic bool HandleExponent(T &state, int32_t exponent) {\n \t\tusing result_t = typename T::Result;\n@@ -975,6 +985,43 @@ static bool IntegerHexCastLoop(const char *buf, idx_t len, T &result, bool stric\n \treturn pos > start_pos;\n }\n \n+template <class T, bool NEGATIVE, bool ALLOW_EXPONENT, class OP = IntegerCastOperation>\n+static bool IntegerBinaryCastLoop(const char *buf, idx_t len, T &result, bool strict) {\n+\tif (ALLOW_EXPONENT || NEGATIVE) {\n+\t\treturn false;\n+\t}\n+\tidx_t start_pos = 1;\n+\tidx_t pos = start_pos;\n+\tuint8_t digit;\n+\tchar current_char;\n+\twhile (pos < len) {\n+\t\tcurrent_char = buf[pos];\n+\t\tif (current_char == '_' && pos > start_pos) {\n+\t\t\t// skip underscore, if it is not the first character\n+\t\t\tpos++;\n+\t\t\tif (pos == len) {\n+\t\t\t\t// we cant end on an underscore either\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tcontinue;\n+\t\t} else if (current_char == '0') {\n+\t\t\tdigit = 0;\n+\t\t} else if (current_char == '1') {\n+\t\t\tdigit = 1;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t\tpos++;\n+\t\tif (!OP::template HandleBinaryDigit<T, NEGATIVE>(result, digit)) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\tif (!OP::template Finalize<T, NEGATIVE>(result)) {\n+\t\treturn false;\n+\t}\n+\treturn pos > start_pos;\n+}\n+\n template <class T, bool IS_SIGNED = true, bool ALLOW_EXPONENT = true, class OP = IntegerCastOperation,\n           bool ZERO_INITIALIZE = true>\n static bool TryIntegerCast(const char *buf, idx_t len, T &result, bool strict) {\n@@ -986,24 +1033,11 @@ static bool TryIntegerCast(const char *buf, idx_t len, T &result, bool strict) {\n \tif (len == 0) {\n \t\treturn false;\n \t}\n-\tint negative = *buf == '-';\n-\n-\t// If it starts with 0x or 0X, we parse it as a hex value\n-\tint hex = len > 1 && *buf == '0' && (buf[1] == 'x' || buf[1] == 'X');\n-\n \tif (ZERO_INITIALIZE) {\n \t\tmemset(&result, 0, sizeof(T));\n \t}\n-\tif (!negative) {\n-\t\tif (hex) {\n-\t\t\t// Skip the 0x\n-\t\t\tbuf++;\n-\t\t\tlen--;\n-\t\t\treturn IntegerHexCastLoop<T, false, false, OP>(buf, len, result, strict);\n-\t\t} else {\n-\t\t\treturn IntegerCastLoop<T, false, ALLOW_EXPONENT, OP>(buf, len, result, strict);\n-\t\t}\n-\t} else {\n+\t// if the number is negative, we set the negative flag and skip the negative sign\n+\tif (*buf == '-') {\n \t\tif (!IS_SIGNED) {\n \t\t\t// Need to check if its not -0\n \t\t\tidx_t pos = 1;\n@@ -1015,6 +1049,22 @@ static bool TryIntegerCast(const char *buf, idx_t len, T &result, bool strict) {\n \t\t}\n \t\treturn IntegerCastLoop<T, true, ALLOW_EXPONENT, OP>(buf, len, result, strict);\n \t}\n+\t// If it starts with 0x or 0X, we parse it as a hex value\n+\telse if (len > 1 && *buf == '0' && (buf[1] == 'x' || buf[1] == 'X')) {\n+\t\t// Skip the 0x\n+\t\tbuf++;\n+\t\tlen--;\n+\t\treturn IntegerHexCastLoop<T, false, false, OP>(buf, len, result, strict);\n+\t}\n+\t// If it starts with 0b or 0B, we parse it as a binary value\n+\telse if (len > 1 && *buf == '0' && (buf[1] == 'b' || buf[1] == 'B')) {\n+\t\t// Skip the 0b\n+\t\tbuf++;\n+\t\tlen--;\n+\t\treturn IntegerBinaryCastLoop<T, false, false, OP>(buf, len, result, strict);\n+\t} else {\n+\t\treturn IntegerCastLoop<T, false, ALLOW_EXPONENT, OP>(buf, len, result, strict);\n+\t}\n }\n \n template <typename T, bool IS_SIGNED = true>\n@@ -1514,6 +1564,19 @@ struct HugeIntegerCastOperation {\n \t\treturn false;\n \t}\n \n+\ttemplate <class T, bool NEGATIVE>\n+\tstatic bool HandleBinaryDigit(T &result, uint8_t digit) {\n+\t\tif (result.intermediate > (NumericLimits<int64_t>::Maximum() - digit) / 2) {\n+\t\t\t// intermediate is full: need to flush it\n+\t\t\tif (!result.Flush()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\tresult.intermediate = result.intermediate * 2 + digit;\n+\t\tresult.digits++;\n+\t\treturn true;\n+\t}\n+\n \ttemplate <class T, bool NEGATIVE>\n \tstatic bool HandleExponent(T &result, int32_t exponent) {\n \t\tif (!result.Flush()) {\n@@ -1621,6 +1684,11 @@ struct DecimalCastOperation {\n \t\treturn false;\n \t}\n \n+\ttemplate <class T, bool NEGATIVE>\n+\tstatic bool HandleBinaryDigit(T &state, uint8_t digit) {\n+\t\treturn false;\n+\t}\n+\n \ttemplate <class T, bool NEGATIVE>\n \tstatic void RoundUpResult(T &state) {\n \t\tif (NEGATIVE) {\n",
  "test_patch": "diff --git a/test/sql/cast/test_string_binary_cast.test b/test/sql/cast/test_string_binary_cast.test\nnew file mode 100644\nindex 000000000000..0bdf007b4078\n--- /dev/null\n+++ b/test/sql/cast/test_string_binary_cast.test\n@@ -0,0 +1,142 @@\n+# name: test/sql/cast/test_string_binary_cast.test\n+# group: [cast]\n+\n+foreach prefix 0b 0B\n+\n+# Empty binary should fail\n+statement error\n+SELECT '${prefix}'::INT\n+\n+# Binary with invalid characters should fail\n+statement error\n+SELECT '${prefix}2'::INT\n+\n+statement error\n+SELECT '${prefix}10105'::INT\n+\n+# Negative binary should fail\n+statement error\n+SELECT '${prefix}-1'::INT\n+\n+statement error\n+SELECT '-${prefix}1'::INT\n+\n+# Basic asserts\n+query I\n+SELECT '${prefix}1'::INT\n+----\n+1\n+\n+query I\n+SELECT '${prefix}10'::INT\n+----\n+2\n+\n+query I\n+SELECT '${prefix}11'::INT\n+----\n+3\n+\n+query I\n+SELECT '${prefix}0000000'::INT\n+----\n+0\n+\n+# Allow underscores as digit separators\n+query I\n+SELECT '${prefix}1_0'::INT\n+----\n+2\n+\n+query I\n+SELECT '${prefix}1_0_0'::INT\n+----\n+4\n+\n+query I\n+SELECT '${prefix}11110000_11110000'::INT\n+----\n+61680\n+\n+# But dont allow them at the start or end\n+statement error\n+SELECT '${prefix}_1'::INT\n+\n+statement error\n+SELECT '${prefix}1_'::INT\n+\n+statement error\n+SELECT '${prefix}1_0_'::INT\n+\n+statement error\n+SELECT '${prefix}_1_0'::INT\n+\n+\n+# Property check! \n+foreach binary 1 01 00 0_0 10 10101 1001 0001 1111 1111_1111 01111111111111111111111111111111 01111111_11111111_11111111_11111111\n+\n+query I\n+WITH binary_string as (select replace('${binary}', '_', '') as str)\n+SELECT \n+\tlist_sum([ (CASE WHEN str[i+1] = '0' THEN 0 ELSE 1 END) * (2 ** (len(str)-(i+1))) for i in range(len(str))])::INT\n+\t==\n+\t'${prefix}${binary}'::INT\n+FROM binary_string\n+----\n+true\n+\n+endloop\n+\n+\n+# Test limits\n+query I\n+SELECT '${prefix}0000000000000000000000000000000001111111'::TINYINT\n+----\n+127\n+\n+query I\n+SELECT '${prefix}0000000000000000000000000000000011111111'::UINT8\n+----\n+255\n+\n+statement error\n+SELECT '${prefix}00000000000000000000000000000000111111111'::TINYINT\n+\n+query I\n+SELECT '${prefix}1111111111111111111111111111111'::INT\n+----\n+2147483647\n+\n+statement error\n+SELECT '${prefix}11111111111111111111111111111111'::INT\n+\n+query I\n+SELECT '${prefix}01111111111111111111111111111111'::UINT32\n+----\n+2147483647\n+\n+query I\n+SELECT '${prefix}11111111111111111111111111111111'::UINT32\n+----\n+4294967295\n+\n+query I\n+SELECT '${prefix}11111111111111111111111111111111'::BIGINT\n+----\n+4294967295\n+\n+query I\n+SELECT '${prefix}111111111111111111111111111111111111111111111111111111111111111'::BIGINT\n+----\n+9223372036854775807\n+\n+statement error\n+SELECT '${prefix}1111111111111111111111111111111111111111111111111111111111111111'::BIGINT\n+\n+query I\n+SELECT '${prefix}1111111111111111111111111111111111111111111111111111111111111111'::UINT64\n+----\n+18446744073709551615\n+\n+\n+endloop\n\\ No newline at end of file\n",
  "problem_statement": "Support binary integer notation\nIn the same trend as #5074 \r\n\r\nWe should also support :\r\n```sql\r\nselect b'01010100'::int;\r\n-- 84\r\n```\r\n\r\nOr as a first step, similar to #5160 we can add a casting rule for it first\r\n```sql\r\nselect '0b01010100'::int;\r\n-- 84\r\n```\r\n\r\nFor no reason whatsoever I made this cursed (probably not very efficient) sql query to do this conversion for anyone looking for this functionality before it's implemented into the system:\r\n```sql\r\nwith binary_string as (select '011010110101' as str)\r\nselect list_sum([ (CASE WHEN str[i+1] = '0' THEN 0 ELSE 1 END) * (2 ** (len(str)-(i+1))) for i in range(len(str))]) from binary_string\r\n-- 1717.0\r\n```\n",
  "hints_text": "A general bit type would also be great",
  "created_at": "2022-11-14T17:32:05Z"
}