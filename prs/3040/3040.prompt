You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Wrong result on using limit after order by on null data
#### What happens?
Several row values are missing (when compared with the same query on other SQL engines) when using limit in the below given query. I'm not a 100% sure whether this is a bug or this is the intended behaviour. Note that this happens on data with null values.

#### To Reproduce
```
        select o_orderkey, o_clerk, o_orderstatus, o_totalprice from orders
                    order by o_orderkey NULLS FIRST,
                    o_clerk NULLS FIRST, o_orderstatus NULLS FIRST,
                    o_totalprice DESC NULLS LAST limit 540
```
This gives the wrong result. To get the correct result, I had to change the query to the one given below
```
        WITH result as (
          select o_orderkey, o_clerk, o_orderstatus, o_totalprice from orders
            order by o_orderkey NULLS FIRST,
            o_clerk NULLS FIRST, o_orderstatus NULLS FIRST,
            o_totalprice DESC NULLS LAST
        )
        SELECT * from result limit 540
```

#### Environment (please complete the following information):
 - OS: Ubuntu 20.04
 - DuckDB Version: 0.3.1
 - DuckDB Client: Python

#### Before Submitting

- [ ] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [ ] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

Wrong result on using limit after order by on null data
#### What happens?
Several row values are missing (when compared with the same query on other SQL engines) when using limit in the below given query. I'm not a 100% sure whether this is a bug or this is the intended behaviour. Note that this happens on data with null values.

#### To Reproduce
```
        select o_orderkey, o_clerk, o_orderstatus, o_totalprice from orders
                    order by o_orderkey NULLS FIRST,
                    o_clerk NULLS FIRST, o_orderstatus NULLS FIRST,
                    o_totalprice DESC NULLS LAST limit 540
```
This gives the wrong result. To get the correct result, I had to change the query to the one given below
```
        WITH result as (
          select o_orderkey, o_clerk, o_orderstatus, o_totalprice from orders
            order by o_orderkey NULLS FIRST,
            o_clerk NULLS FIRST, o_orderstatus NULLS FIRST,
            o_totalprice DESC NULLS LAST
        )
        SELECT * from result limit 540
```

#### Environment (please complete the following information):
 - OS: Ubuntu 20.04
 - DuckDB Version: 0.3.1
 - DuckDB Client: Python

#### Before Submitting

- [ ] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [ ] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of src/common/vector_operations/is_distinct_from.cpp]
1: #include "duckdb/common/vector_operations/vector_operations.hpp"
2: #include "duckdb/common/operator/comparison_operators.hpp"
3: 
4: namespace duckdb {
5: 
6: struct DistinctBinaryLambdaWrapper {
7: 	template <class OP, class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE>
8: 	static inline RESULT_TYPE Operation(LEFT_TYPE left, RIGHT_TYPE right, bool is_left_null, bool is_right_null) {
9: 		return OP::template Operation<LEFT_TYPE>(left, right, is_left_null, is_right_null);
10: 	}
11: };
12: 
13: template <class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE, class OP>
14: static void DistinctExecuteGenericLoop(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
15:                                        RESULT_TYPE *__restrict result_data, const SelectionVector *__restrict lsel,
16:                                        const SelectionVector *__restrict rsel, idx_t count, ValidityMask &lmask,
17:                                        ValidityMask &rmask, ValidityMask &result_mask) {
18: 	for (idx_t i = 0; i < count; i++) {
19: 		auto lindex = lsel->get_index(i);
20: 		auto rindex = rsel->get_index(i);
21: 		auto lentry = ldata[lindex];
22: 		auto rentry = rdata[rindex];
23: 		result_data[i] =
24: 		    OP::template Operation<LEFT_TYPE>(lentry, rentry, !lmask.RowIsValid(lindex), !rmask.RowIsValid(rindex));
25: 	}
26: }
27: 
28: template <class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE, class OP>
29: static void DistinctExecuteConstant(Vector &left, Vector &right, Vector &result) {
30: 	result.SetVectorType(VectorType::CONSTANT_VECTOR);
31: 
32: 	auto ldata = ConstantVector::GetData<LEFT_TYPE>(left);
33: 	auto rdata = ConstantVector::GetData<RIGHT_TYPE>(right);
34: 	auto result_data = ConstantVector::GetData<RESULT_TYPE>(result);
35: 	*result_data =
36: 	    OP::template Operation<LEFT_TYPE>(*ldata, *rdata, ConstantVector::IsNull(left), ConstantVector::IsNull(right));
37: }
38: 
39: template <class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE, class OP>
40: static void DistinctExecuteGeneric(Vector &left, Vector &right, Vector &result, idx_t count) {
41: 	if (left.GetVectorType() == VectorType::CONSTANT_VECTOR && right.GetVectorType() == VectorType::CONSTANT_VECTOR) {
42: 		DistinctExecuteConstant<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE, OP>(left, right, result);
43: 	} else {
44: 		VectorData ldata, rdata;
45: 
46: 		left.Orrify(count, ldata);
47: 		right.Orrify(count, rdata);
48: 
49: 		result.SetVectorType(VectorType::FLAT_VECTOR);
50: 		auto result_data = FlatVector::GetData<RESULT_TYPE>(result);
51: 		DistinctExecuteGenericLoop<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE, OP>(
52: 		    (LEFT_TYPE *)ldata.data, (RIGHT_TYPE *)rdata.data, result_data, ldata.sel, rdata.sel, count, ldata.validity,
53: 		    rdata.validity, FlatVector::Validity(result));
54: 	}
55: }
56: 
57: template <class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE, class OP>
58: static void DistinctExecuteSwitch(Vector &left, Vector &right, Vector &result, idx_t count) {
59: 	DistinctExecuteGeneric<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE, OP>(left, right, result, count);
60: }
61: 
62: template <class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE, class OP>
63: static void DistinctExecute(Vector &left, Vector &right, Vector &result, idx_t count) {
64: 	DistinctExecuteSwitch<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE, OP>(left, right, result, count);
65: }
66: 
67: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool DENSE, bool NO_NULL, bool HAS_TRUE_SEL, bool HAS_FALSE_SEL>
68: static inline idx_t
69: DistinctSelectGenericLoop(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
70:                           const SelectionVector *__restrict lsel, const SelectionVector *__restrict rsel,
71:                           const SelectionVector *__restrict result_sel, idx_t count, ValidityMask &lmask,
72:                           ValidityMask &rmask, SelectionVector *true_sel, SelectionVector *false_sel) {
73: 	idx_t true_count = 0, false_count = 0;
74: 	for (idx_t i = 0; i < count; i++) {
75: 		auto result_idx = result_sel->get_index(i);
76: 		const auto idx = DENSE ? i : result_idx;
77: 		auto lindex = lsel->get_index(idx);
78: 		auto rindex = rsel->get_index(idx);
79: 		if (NO_NULL) {
80: 			if (OP::Operation(ldata[lindex], rdata[rindex], false, false)) {
81: 				if (HAS_TRUE_SEL) {
82: 					true_sel->set_index(true_count++, result_idx);
83: 				}
84: 			} else {
85: 				if (HAS_FALSE_SEL) {
86: 					false_sel->set_index(false_count++, result_idx);
87: 				}
88: 			}
89: 		} else {
90: 			if (OP::Operation(ldata[lindex], rdata[rindex], !lmask.RowIsValid(lindex), !rmask.RowIsValid(rindex))) {
91: 				if (HAS_TRUE_SEL) {
92: 					true_sel->set_index(true_count++, result_idx);
93: 				}
94: 			} else {
95: 				if (HAS_FALSE_SEL) {
96: 					false_sel->set_index(false_count++, result_idx);
97: 				}
98: 			}
99: 		}
100: 	}
101: 	if (HAS_TRUE_SEL) {
102: 		return true_count;
103: 	} else {
104: 		return count - false_count;
105: 	}
106: }
107: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool DENSE, bool NO_NULL>
108: static inline idx_t
109: DistinctSelectGenericLoopSelSwitch(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
110:                                    const SelectionVector *__restrict lsel, const SelectionVector *__restrict rsel,
111:                                    const SelectionVector *__restrict result_sel, idx_t count, ValidityMask &lmask,
112:                                    ValidityMask &rmask, SelectionVector *true_sel, SelectionVector *false_sel) {
113: 	if (true_sel && false_sel) {
114: 		return DistinctSelectGenericLoop<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, NO_NULL, true, true>(
115: 		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
116: 	} else if (true_sel) {
117: 		return DistinctSelectGenericLoop<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, NO_NULL, true, false>(
118: 		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
119: 	} else {
120: 		D_ASSERT(false_sel);
121: 		return DistinctSelectGenericLoop<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, NO_NULL, false, true>(
122: 		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
123: 	}
124: }
125: 
126: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool DENSE>
127: static inline idx_t
128: DistinctSelectGenericLoopSwitch(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
129:                                 const SelectionVector *__restrict lsel, const SelectionVector *__restrict rsel,
130:                                 const SelectionVector *__restrict result_sel, idx_t count, ValidityMask &lmask,
131:                                 ValidityMask &rmask, SelectionVector *true_sel, SelectionVector *false_sel) {
132: 	if (!lmask.AllValid() || rmask.AllValid()) {
133: 		return DistinctSelectGenericLoopSelSwitch<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, false>(
134: 		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
135: 	} else {
136: 		return DistinctSelectGenericLoopSelSwitch<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, true>(
137: 		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
138: 	}
139: }
140: 
141: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool DENSE>
142: static idx_t DistinctSelectGeneric(Vector &left, Vector &right, idx_t vcount, const SelectionVector *sel, idx_t count,
143:                                    SelectionVector *true_sel, SelectionVector *false_sel) {
144: 	VectorData ldata, rdata;
145: 
146: 	left.Orrify(vcount, ldata);
147: 	right.Orrify(vcount, rdata);
148: 
149: 	return DistinctSelectGenericLoopSwitch<LEFT_TYPE, RIGHT_TYPE, OP, DENSE>(
150: 	    (LEFT_TYPE *)ldata.data, (RIGHT_TYPE *)rdata.data, ldata.sel, rdata.sel, sel, count, ldata.validity,
151: 	    rdata.validity, true_sel, false_sel);
152: }
153: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool DENSE, bool LEFT_CONSTANT, bool RIGHT_CONSTANT,
154:           bool NO_NULL, bool HAS_TRUE_SEL, bool HAS_FALSE_SEL>
155: static inline idx_t DistinctSelectFlatLoop(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
156:                                            const SelectionVector *sel, idx_t count, ValidityMask &lmask,
157:                                            ValidityMask &rmask, SelectionVector *true_sel, SelectionVector *false_sel) {
158: 	idx_t true_count = 0, false_count = 0;
159: 	for (idx_t i = 0; i < count; i++) {
160: 		idx_t result_idx = sel->get_index(i);
161: 		const auto idx = DENSE ? i : result_idx;
162: 		idx_t lidx = LEFT_CONSTANT ? 0 : idx;
163: 		idx_t ridx = RIGHT_CONSTANT ? 0 : idx;
164: 		const bool lnull = !lmask.RowIsValid(lidx);
165: 		const bool rnull = !rmask.RowIsValid(ridx);
166: 		bool comparison_result = OP::Operation(ldata[lidx], rdata[ridx], lnull, rnull);
167: 		if (HAS_TRUE_SEL) {
168: 			true_sel->set_index(true_count, result_idx);
169: 			true_count += comparison_result;
170: 		}
171: 		if (HAS_FALSE_SEL) {
172: 			false_sel->set_index(false_count, result_idx);
173: 			false_count += !comparison_result;
174: 		}
175: 	}
176: 	if (HAS_TRUE_SEL) {
177: 		return true_count;
178: 	} else {
179: 		return count - false_count;
180: 	}
181: }
182: 
183: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool DENSE, bool LEFT_CONSTANT, bool RIGHT_CONSTANT,
184:           bool NO_NULL>
185: static inline idx_t DistinctSelectFlatLoopSelSwitch(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
186:                                                     const SelectionVector *sel, idx_t count, ValidityMask &lmask,
187:                                                     ValidityMask &rmask, SelectionVector *true_sel,
188:                                                     SelectionVector *false_sel) {
189: 	if (true_sel && false_sel) {
190: 		return DistinctSelectFlatLoop<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, LEFT_CONSTANT, RIGHT_CONSTANT, NO_NULL, true,
191: 		                              true>(ldata, rdata, sel, count, lmask, rmask, true_sel, false_sel);
192: 	} else if (true_sel) {
193: 		return DistinctSelectFlatLoop<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, LEFT_CONSTANT, RIGHT_CONSTANT, NO_NULL, true,
194: 		                              false>(ldata, rdata, sel, count, lmask, rmask, true_sel, false_sel);
195: 	} else {
196: 		D_ASSERT(false_sel);
197: 		return DistinctSelectFlatLoop<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, LEFT_CONSTANT, RIGHT_CONSTANT, NO_NULL, false,
198: 		                              true>(ldata, rdata, sel, count, lmask, rmask, true_sel, false_sel);
199: 	}
200: }
201: 
202: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool DENSE, bool LEFT_CONSTANT, bool RIGHT_CONSTANT>
203: static inline idx_t DistinctSelectFlatLoopSwitch(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
204:                                                  const SelectionVector *sel, idx_t count, ValidityMask &lmask,
205:                                                  ValidityMask &rmask, SelectionVector *true_sel,
206:                                                  SelectionVector *false_sel) {
207: 	return DistinctSelectFlatLoopSelSwitch<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, LEFT_CONSTANT, RIGHT_CONSTANT, true>(
208: 	    ldata, rdata, sel, count, lmask, rmask, true_sel, false_sel);
209: }
210: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool DENSE, bool LEFT_CONSTANT, bool RIGHT_CONSTANT>
211: static idx_t DistinctSelectFlat(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
212:                                 SelectionVector *true_sel, SelectionVector *false_sel) {
213: 	auto ldata = FlatVector::GetData<LEFT_TYPE>(left);
214: 	auto rdata = FlatVector::GetData<RIGHT_TYPE>(right);
215: 	if (LEFT_CONSTANT) {
216: 		ValidityMask validity;
217: 		if (ConstantVector::IsNull(left)) {
218: 			validity.SetAllInvalid(1);
219: 		}
220: 		return DistinctSelectFlatLoopSwitch<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, LEFT_CONSTANT, RIGHT_CONSTANT>(
221: 		    ldata, rdata, sel, count, validity, FlatVector::Validity(right), true_sel, false_sel);
222: 	} else if (RIGHT_CONSTANT) {
223: 		ValidityMask validity;
224: 		if (ConstantVector::IsNull(right)) {
225: 			validity.SetAllInvalid(1);
226: 		}
227: 		return DistinctSelectFlatLoopSwitch<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, LEFT_CONSTANT, RIGHT_CONSTANT>(
228: 		    ldata, rdata, sel, count, FlatVector::Validity(left), validity, true_sel, false_sel);
229: 	} else {
230: 		return DistinctSelectFlatLoopSwitch<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, LEFT_CONSTANT, RIGHT_CONSTANT>(
231: 		    ldata, rdata, sel, count, FlatVector::Validity(left), FlatVector::Validity(right), true_sel, false_sel);
232: 	}
233: }
234: template <class LEFT_TYPE, class RIGHT_TYPE, class OP>
235: static idx_t DistinctSelectConstant(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
236:                                     SelectionVector *true_sel, SelectionVector *false_sel) {
237: 	auto ldata = ConstantVector::GetData<LEFT_TYPE>(left);
238: 	auto rdata = ConstantVector::GetData<RIGHT_TYPE>(right);
239: 
240: 	// both sides are constant, return either 0 or the count
241: 	// in this case we do not fill in the result selection vector at all
242: 	if (!OP::Operation(*ldata, *rdata, ConstantVector::IsNull(left), ConstantVector::IsNull(right))) {
243: 		if (false_sel) {
244: 			for (idx_t i = 0; i < count; i++) {
245: 				false_sel->set_index(i, sel->get_index(i));
246: 			}
247: 		}
248: 		return 0;
249: 	} else {
250: 		if (true_sel) {
251: 			for (idx_t i = 0; i < count; i++) {
252: 				true_sel->set_index(i, sel->get_index(i));
253: 			}
254: 		}
255: 		return count;
256: 	}
257: }
258: 
259: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool DENSE>
260: static idx_t DistinctSelect(Vector &left, Vector &right, idx_t vcount, const SelectionVector *sel, idx_t count,
261:                             SelectionVector *true_sel, SelectionVector *false_sel) {
262: 	SelectionVector owned_sel;
263: 	if (!sel) {
264: 		sel = FlatVector::IncrementalSelectionVector(count, owned_sel);
265: 	}
266: 	if (left.GetVectorType() == VectorType::CONSTANT_VECTOR && right.GetVectorType() == VectorType::CONSTANT_VECTOR) {
267: 		return DistinctSelectConstant<LEFT_TYPE, RIGHT_TYPE, OP>(left, right, sel, count, true_sel, false_sel);
268: 	} else if (left.GetVectorType() == VectorType::CONSTANT_VECTOR &&
269: 	           right.GetVectorType() == VectorType::FLAT_VECTOR) {
270: 		return DistinctSelectFlat<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, true, false>(left, right, sel, count, true_sel,
271: 		                                                                         false_sel);
272: 	} else if (left.GetVectorType() == VectorType::FLAT_VECTOR &&
273: 	           right.GetVectorType() == VectorType::CONSTANT_VECTOR) {
274: 		return DistinctSelectFlat<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, false, true>(left, right, sel, count, true_sel,
275: 		                                                                         false_sel);
276: 	} else if (left.GetVectorType() == VectorType::FLAT_VECTOR && right.GetVectorType() == VectorType::FLAT_VECTOR) {
277: 		return DistinctSelectFlat<LEFT_TYPE, RIGHT_TYPE, OP, DENSE, false, false>(left, right, sel, count, true_sel,
278: 		                                                                          false_sel);
279: 	} else {
280: 		return DistinctSelectGeneric<LEFT_TYPE, RIGHT_TYPE, OP, DENSE>(left, right, vcount, sel, count, true_sel,
281: 		                                                               false_sel);
282: 	}
283: }
284: 
285: template <class OP>
286: static idx_t DistinctSelectNotNull(VectorData &lvdata, VectorData &rvdata, const idx_t count, idx_t &true_count,
287:                                    const SelectionVector &sel, SelectionVector &maybe_vec, OptionalSelection &true_vec,
288:                                    OptionalSelection &false_vec) {
289: 	auto &lmask = lvdata.validity;
290: 	auto &rmask = rvdata.validity;
291: 
292: 	idx_t remaining = 0;
293: 	if (lmask.AllValid() && rmask.AllValid()) {
294: 		//	None are NULL, distinguish values.
295: 		for (idx_t i = 0; i < count; ++i) {
296: 			const auto idx = sel.get_index(i);
297: 			maybe_vec.set_index(remaining++, idx);
298: 		}
299: 		return remaining;
300: 	}
301: 
302: 	idx_t false_count = 0;
303: 	for (idx_t i = 0; i < count; ++i) {
304: 		const auto idx = sel.get_index(i);
305: 		const auto lidx = lvdata.sel->get_index(idx);
306: 		const auto ridx = rvdata.sel->get_index(idx);
307: 		const auto lnull = !lmask.RowIsValid(lidx);
308: 		const auto rnull = !rmask.RowIsValid(ridx);
309: 		if (lnull || rnull) {
310: 			// If either is NULL then we can major distinguish them
311: 			if (!OP::Operation(false, false, lnull, rnull)) {
312: 				false_vec.Append(false_count, idx);
313: 			} else {
314: 				true_vec.Append(true_count, idx);
315: 			}
316: 		} else {
317: 			//	Neither is NULL, distinguish values.
318: 			maybe_vec.set_index(remaining++, idx);
319: 		}
320: 	}
321: 	true_vec.Advance(true_count);
322: 	false_vec.Advance(false_count);
323: 
324: 	return remaining;
325: }
326: 
327: template <bool DENSE>
328: static inline void ScatterSelection(SelectionVector *target, const idx_t count, const SelectionVector &sel,
329:                                     const SelectionVector &dense_vec) {
330: 	if (DENSE && target) {
331: 		for (idx_t i = 0; i < count; ++i) {
332: 			target->set_index(i, sel.get_index(dense_vec.get_index(i)));
333: 		}
334: 	}
335: }
336: 
337: struct PositionComparator {
338: 	// Select the rows that definitely match.
339: 	// Default to the same as the final row
340: 	template <typename OP>
341: 	static idx_t Definite(Vector &left, Vector &right, idx_t vcount, const SelectionVector &sel, idx_t count,
342: 	                      SelectionVector *true_sel, SelectionVector &false_sel) {
343: 		return Final<OP>(left, right, vcount, sel, count, true_sel, &false_sel);
344: 	}
345: 
346: 	// Select the possible rows that need further testing.
347: 	// Usually this means Is Not Distinct, as those are the semantics used by Postges
348: 	template <typename OP>
349: 	static idx_t Possible(Vector &left, Vector &right, idx_t vcount, const SelectionVector &sel, idx_t count,
350: 	                      SelectionVector &true_sel, SelectionVector *false_sel) {
351: 		return VectorOperations::NestedEquals(left, right, vcount, sel, count, &true_sel, false_sel);
352: 	}
353: 
354: 	// Select the matching rows for the final position.
355: 	// This needs to be specialised.
356: 	template <typename OP>
357: 	static idx_t Final(Vector &left, Vector &right, idx_t vcount, const SelectionVector &sel, idx_t count,
358: 	                   SelectionVector *true_sel, SelectionVector *false_sel) {
359: 		return 0;
360: 	}
361: 
362: 	// Tie-break based on length when one of the sides has been exhausted, returning true if the LHS matches.
363: 	// This essentially means that the existing positions compare equal.
364: 	// Default to the same semantics as the OP for idx_t. This works in most cases.
365: 	template <typename OP>
366: 	static bool TieBreak(const idx_t lpos, const idx_t rpos) {
367: 		return OP::Operation(lpos, rpos, false, false);
368: 	}
369: };
370: 
371: // NotDistinctFrom must always check every column
372: template <>
373: idx_t PositionComparator::Definite<duckdb::NotDistinctFrom>(Vector &left, Vector &right, idx_t vcount,
374:                                                             const SelectionVector &sel, idx_t count,
375:                                                             SelectionVector *true_sel, SelectionVector &false_sel) {
376: 	return 0;
377: }
378: 
379: template <>
380: idx_t PositionComparator::Final<duckdb::NotDistinctFrom>(Vector &left, Vector &right, idx_t vcount,
381:                                                          const SelectionVector &sel, idx_t count,
382:                                                          SelectionVector *true_sel, SelectionVector *false_sel) {
383: 	return VectorOperations::NestedEquals(left, right, vcount, sel, count, true_sel, false_sel);
384: }
385: 
386: // DistinctFrom must check everything that matched
387: template <>
388: idx_t PositionComparator::Possible<duckdb::DistinctFrom>(Vector &left, Vector &right, idx_t vcount,
389:                                                          const SelectionVector &sel, idx_t count,
390:                                                          SelectionVector &true_sel, SelectionVector *false_sel) {
391: 	return count;
392: }
393: 
394: template <>
395: idx_t PositionComparator::Final<duckdb::DistinctFrom>(Vector &left, Vector &right, idx_t vcount,
396:                                                       const SelectionVector &sel, idx_t count,
397:                                                       SelectionVector *true_sel, SelectionVector *false_sel) {
398: 	return VectorOperations::NestedNotEquals(left, right, vcount, sel, count, true_sel, false_sel);
399: }
400: 
401: // Non-strict inequalities must use strict comparisons for Definite
402: template <>
403: idx_t PositionComparator::Definite<duckdb::DistinctLessThanEquals>(Vector &left, Vector &right, idx_t vcount,
404:                                                                    const SelectionVector &sel, idx_t count,
405:                                                                    SelectionVector *true_sel,
406:                                                                    SelectionVector &false_sel) {
407: 	return VectorOperations::NestedLessThan(left, right, vcount, sel, count, true_sel, &false_sel);
408: }
409: 
410: template <>
411: idx_t PositionComparator::Final<duckdb::DistinctLessThanEquals>(Vector &left, Vector &right, idx_t vcount,
412:                                                                 const SelectionVector &sel, idx_t count,
413:                                                                 SelectionVector *true_sel, SelectionVector *false_sel) {
414: 	return VectorOperations::NestedLessThanEquals(left, right, vcount, sel, count, true_sel, false_sel);
415: }
416: 
417: template <>
418: idx_t PositionComparator::Definite<duckdb::DistinctGreaterThanEquals>(Vector &left, Vector &right, idx_t vcount,
419:                                                                       const SelectionVector &sel, idx_t count,
420:                                                                       SelectionVector *true_sel,
421:                                                                       SelectionVector &false_sel) {
422: 	return VectorOperations::NestedGreaterThan(left, right, vcount, sel, count, true_sel, &false_sel);
423: }
424: 
425: template <>
426: idx_t PositionComparator::Final<duckdb::DistinctGreaterThanEquals>(Vector &left, Vector &right, idx_t vcount,
427:                                                                    const SelectionVector &sel, idx_t count,
428:                                                                    SelectionVector *true_sel,
429:                                                                    SelectionVector *false_sel) {
430: 	return VectorOperations::NestedGreaterThanEquals(left, right, vcount, sel, count, true_sel, false_sel);
431: }
432: 
433: // Strict inequalities just use strict for both Definite and Final
434: template <>
435: idx_t PositionComparator::Final<duckdb::DistinctLessThan>(Vector &left, Vector &right, idx_t vcount,
436:                                                           const SelectionVector &sel, idx_t count,
437:                                                           SelectionVector *true_sel, SelectionVector *false_sel) {
438: 	return VectorOperations::NestedLessThan(left, right, vcount, sel, count, true_sel, false_sel);
439: }
440: 
441: template <>
442: idx_t PositionComparator::Final<duckdb::DistinctGreaterThan>(Vector &left, Vector &right, idx_t vcount,
443:                                                              const SelectionVector &sel, idx_t count,
444:                                                              SelectionVector *true_sel, SelectionVector *false_sel) {
445: 	return VectorOperations::NestedGreaterThan(left, right, vcount, sel, count, true_sel, false_sel);
446: }
447: 
448: using StructEntries = vector<unique_ptr<Vector>>;
449: 
450: static StructEntries &StructVectorGetSlicedEntries(Vector &parent, StructEntries &sliced, const idx_t vcount) {
451: 	// We have to manually slice STRUCT dictionaries.
452: 	auto &children = StructVector::GetEntries(parent);
453: 	if (parent.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
454: 		auto &dict_sel = DictionaryVector::SelVector(parent);
455: 		for (auto &child : children) {
456: 			auto v = make_unique<Vector>(*child, dict_sel, vcount);
457: 			sliced.push_back(move(v));
458: 		}
459: 
460: 		return sliced;
461: 	}
462: 
463: 	return children;
464: }
465: 
466: template <class OP>
467: static idx_t DistinctSelectStruct(Vector &left, Vector &right, idx_t vcount, VectorData &lvdata, VectorData &rvdata,
468:                                   idx_t count, SelectionVector &maybe_vec, OptionalSelection &true_opt,
469:                                   OptionalSelection &false_opt) {
470: 	// Avoid allocating in the 99% of the cases where we don't need to.
471: 	StructEntries lsliced, rsliced;
472: 	auto &lchildren = StructVectorGetSlicedEntries(left, lsliced, vcount);
473: 	auto &rchildren = StructVectorGetSlicedEntries(right, rsliced, vcount);
474: 	D_ASSERT(lchildren.size() == rchildren.size());
475: 
476: 	idx_t match_count = 0;
477: 	for (idx_t col_no = 0; col_no < lchildren.size(); ++col_no) {
478: 		auto &lchild = *lchildren[col_no];
479: 		auto &rchild = *rchildren[col_no];
480: 
481: 		// Find everything that definitely matches
482: 		auto true_count =
483: 		    PositionComparator::Definite<OP>(lchild, rchild, vcount, maybe_vec, count, true_opt, maybe_vec);
484: 		if (true_count > 0) {
485: 			true_opt.Advance(true_count);
486: 			match_count += true_count;
487: 			count -= true_count;
488: 		}
489: 
490: 		if (col_no != lchildren.size() - 1) {
491: 			// Find what might match on the next position
492: 			true_count =
493: 			    PositionComparator::Possible<OP>(lchild, rchild, vcount, maybe_vec, count, maybe_vec, false_opt);
494: 			auto false_count = count - true_count;
495: 			false_opt.Advance(false_count);
496: 			count = true_count;
497: 		} else {
498: 			true_count = PositionComparator::Final<OP>(lchild, rchild, vcount, maybe_vec, count, true_opt, false_opt);
499: 			match_count += true_count;
500: 		}
501: 	}
502: 
503: 	return match_count;
504: }
505: 
506: static void PositionListCursor(SelectionVector &cursor, VectorData &vdata, const idx_t pos,
507:                                const SelectionVector &maybe_vec, const idx_t count) {
508: 	const auto data = (const list_entry_t *)vdata.data;
509: 	for (idx_t i = 0; i < count; ++i) {
510: 		const auto idx = maybe_vec.get_index(i);
511: 
512: 		const auto lidx = vdata.sel->get_index(idx);
513: 		const auto &entry = data[lidx];
514: 		cursor.set_index(idx, entry.offset + pos);
515: 	}
516: }
517: 
518: template <class OP>
519: static idx_t DistinctSelectList(Vector &left, Vector &right, idx_t vcount, VectorData &lvdata, VectorData &rvdata,
520:                                 idx_t count, SelectionVector &maybe_vec, OptionalSelection &true_opt,
521:                                 OptionalSelection &false_opt) {
522: 	if (count == 0) {
523: 		return count;
524: 	}
525: 
526: 	// We use them to create dictionary views of the children so we can vectorise the positional comparisons.
527: 	SelectionVector lcursor(vcount);
528: 	SelectionVector rcursor(vcount);
529: 
530: 	Vector lchild(ListVector::GetEntry(left), lcursor, count);
531: 	Vector rchild(ListVector::GetEntry(right), rcursor, count);
532: 
533: 	// To perform the positional comparison, we use a vectorisation of the following algorithm:
534: 	// bool CompareLists(T *left, idx_t nleft, T *right, nright) {
535: 	// 	for (idx_t pos = 0; ; ++pos) {
536: 	// 		if (nleft == pos || nright == pos)
537: 	// 			return OP::TieBreak(nleft, nright);
538: 	// 		if (OP::Definite(*left, *right))
539: 	// 			return true;
540: 	// 		if (!OP::Maybe(*left, *right))
541: 	// 			return false;
542: 	// 		}
543: 	//	 	++left, ++right;
544: 	// 	}
545: 	// }
546: 	const auto ldata = (const list_entry_t *)lvdata.data;
547: 	const auto rdata = (const list_entry_t *)rvdata.data;
548: 
549: 	idx_t match_count = 0;
550: 	for (idx_t pos = 0; count > 0; ++pos) {
551: 		// Set up the cursors for the current position
552: 		PositionListCursor(lcursor, lvdata, pos, maybe_vec, count);
553: 		PositionListCursor(rcursor, rvdata, pos, maybe_vec, count);
554: 
555: 		// Tie-break the pairs where one of the LISTs is exhausted.
556: 		idx_t true_count = 0;
557: 		idx_t false_count = 0;
558: 		idx_t maybe_count = 0;
559: 		for (idx_t i = 0; i < count; ++i) {
560: 			const auto idx = maybe_vec.get_index(i);
561: 			const auto lidx = lvdata.sel->get_index(idx);
562: 			const auto &lentry = ldata[lidx];
563: 			const auto ridx = rvdata.sel->get_index(idx);
564: 			const auto &rentry = rdata[ridx];
565: 			if (lentry.length == pos || rentry.length == pos) {
566: 				if (PositionComparator::TieBreak<OP>(lentry.length, rentry.length)) {
567: 					true_opt.Append(true_count, idx);
568: 				} else {
569: 					false_opt.Append(false_count, idx);
570: 				}
571: 			} else {
572: 				maybe_vec.set_index(maybe_count++, idx);
573: 			}
574: 		}
575: 		true_opt.Advance(true_count);
576: 		false_opt.Advance(false_count);
577: 		count = maybe_count;
578: 		match_count += true_count;
579: 
580: 		// Find everything that definitely matches
581: 		true_count = PositionComparator::Definite<OP>(lchild, rchild, vcount, maybe_vec, count, true_opt, maybe_vec);
582: 		true_opt.Advance(true_count);
583: 		match_count += true_count;
584: 		count -= true_count;
585: 
586: 		// Find what might match on the next position
587: 		maybe_count = PositionComparator::Possible<OP>(lchild, rchild, vcount, maybe_vec, count, maybe_vec, false_opt);
588: 		false_count = count - maybe_count;
589: 		false_opt.Advance(false_count);
590: 		count = maybe_count;
591: 	}
592: 
593: 	return match_count;
594: }
595: 
596: template <class OP, bool DENSE, class OPNESTED>
597: static idx_t DistinctSelectNested(Vector &left, Vector &right, idx_t vcount, const SelectionVector *sel, idx_t count,
598:                                   SelectionVector *true_sel, SelectionVector *false_sel) {
599: 	// We need multiple, real selections
600: 	SelectionVector owned_sel;
601: 	if (!sel) {
602: 		sel = FlatVector::IncrementalSelectionVector(count, owned_sel);
603: 	}
604: 
605: 	SelectionVector true_vec;
606: 	SelectionVector false_vec;
607: 	if (DENSE) {
608: 		true_vec.Initialize(vcount);
609: 		false_vec.Initialize(vcount);
610: 	}
611: 
612: 	OptionalSelection true_opt(DENSE ? &true_vec : true_sel);
613: 	OptionalSelection false_opt(DENSE ? &false_vec : false_sel);
614: 
615: 	// Handle NULL STRUCTs
616: 	VectorData lvdata, rvdata;
617: 	left.Orrify(vcount, lvdata);
618: 	right.Orrify(vcount, rvdata);
619: 
620: 	sel_t maybe_one;
621: 	SelectionVector maybe_vec(&maybe_one);
622: 	if (count > 1) {
623: 		maybe_vec.Initialize(count);
624: 	}
625: 	idx_t match_count = 0;
626: 	idx_t no_match_count = count;
627: 	count = DistinctSelectNotNull<OP>(lvdata, rvdata, count, match_count, *sel, maybe_vec, true_opt, false_opt);
628: 	no_match_count -= (count + match_count);
629: 
630: 	idx_t true_count = 0;
631: 	if (PhysicalType::LIST == left.GetType().InternalType()) {
632: 		true_count =
633: 		    DistinctSelectList<OPNESTED>(left, right, vcount, lvdata, rvdata, count, maybe_vec, true_opt, false_opt);
634: 	} else {
635: 		true_count =
636: 		    DistinctSelectStruct<OPNESTED>(left, right, vcount, lvdata, rvdata, count, maybe_vec, true_opt, false_opt);
637: 	}
638: 
639: 	auto false_count = count - true_count;
640: 	match_count += true_count;
641: 	no_match_count += false_count;
642: 
643: 	ScatterSelection<DENSE>(true_sel, match_count, *sel, true_vec);
644: 	ScatterSelection<DENSE>(false_sel, no_match_count, *sel, false_vec);
645: 
646: 	return match_count;
647: }
648: 
649: template <typename OP>
650: static void NestedDistinctExecute(Vector &left, Vector &right, Vector &result, idx_t count);
651: 
652: template <class T, class OP>
653: static inline void TemplatedDistinctExecute(Vector &left, Vector &right, Vector &result, idx_t count) {
654: 	DistinctExecute<T, T, bool, OP>(left, right, result, count);
655: }
656: template <class OP>
657: static void ExecuteDistinct(Vector &left, Vector &right, Vector &result, idx_t count) {
658: 	D_ASSERT(left.GetType() == right.GetType() && result.GetType() == LogicalType::BOOLEAN);
659: 	// the inplace loops take the result as the last parameter
660: 	switch (left.GetType().InternalType()) {
661: 	case PhysicalType::BOOL:
662: 	case PhysicalType::INT8:
663: 		TemplatedDistinctExecute<int8_t, OP>(left, right, result, count);
664: 		break;
665: 	case PhysicalType::INT16:
666: 		TemplatedDistinctExecute<int16_t, OP>(left, right, result, count);
667: 		break;
668: 	case PhysicalType::INT32:
669: 		TemplatedDistinctExecute<int32_t, OP>(left, right, result, count);
670: 		break;
671: 	case PhysicalType::INT64:
672: 		TemplatedDistinctExecute<int64_t, OP>(left, right, result, count);
673: 		break;
674: 	case PhysicalType::UINT8:
675: 		TemplatedDistinctExecute<uint8_t, OP>(left, right, result, count);
676: 		break;
677: 	case PhysicalType::UINT16:
678: 		TemplatedDistinctExecute<uint16_t, OP>(left, right, result, count);
679: 		break;
680: 	case PhysicalType::UINT32:
681: 		TemplatedDistinctExecute<uint32_t, OP>(left, right, result, count);
682: 		break;
683: 	case PhysicalType::UINT64:
684: 		TemplatedDistinctExecute<uint64_t, OP>(left, right, result, count);
685: 		break;
686: 	case PhysicalType::INT128:
687: 		TemplatedDistinctExecute<hugeint_t, OP>(left, right, result, count);
688: 		break;
689: 	case PhysicalType::FLOAT:
690: 		TemplatedDistinctExecute<float, OP>(left, right, result, count);
691: 		break;
692: 	case PhysicalType::DOUBLE:
693: 		TemplatedDistinctExecute<double, OP>(left, right, result, count);
694: 		break;
695: 	case PhysicalType::INTERVAL:
696: 		TemplatedDistinctExecute<interval_t, OP>(left, right, result, count);
697: 		break;
698: 	case PhysicalType::VARCHAR:
699: 		TemplatedDistinctExecute<string_t, OP>(left, right, result, count);
700: 		break;
701: 	case PhysicalType::LIST:
702: 	case PhysicalType::MAP:
703: 	case PhysicalType::STRUCT:
704: 		NestedDistinctExecute<OP>(left, right, result, count);
705: 		break;
706: 	default:
707: 		throw InternalException("Invalid type for distinct comparison");
708: 	}
709: }
710: 
711: template <class OP, bool DENSE, class OPNESTED = OP>
712: static idx_t TemplatedDistinctSelectOperation(Vector &left, Vector &right, idx_t vcount, const SelectionVector *sel,
713:                                               idx_t count, SelectionVector *true_sel, SelectionVector *false_sel) {
714: 	// the inplace loops take the result as the last parameter
715: 	switch (left.GetType().InternalType()) {
716: 	case PhysicalType::BOOL:
717: 	case PhysicalType::INT8:
718: 		return DistinctSelect<int8_t, int8_t, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
719: 	case PhysicalType::INT16:
720: 		return DistinctSelect<int16_t, int16_t, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
721: 	case PhysicalType::INT32:
722: 		return DistinctSelect<int32_t, int32_t, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
723: 	case PhysicalType::INT64:
724: 		return DistinctSelect<int64_t, int64_t, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
725: 	case PhysicalType::UINT8:
726: 		return DistinctSelect<uint8_t, uint8_t, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
727: 	case PhysicalType::UINT16:
728: 		return DistinctSelect<uint16_t, uint16_t, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
729: 	case PhysicalType::UINT32:
730: 		return DistinctSelect<uint32_t, uint32_t, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
731: 	case PhysicalType::UINT64:
732: 		return DistinctSelect<uint64_t, uint64_t, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
733: 	case PhysicalType::INT128:
734: 		return DistinctSelect<hugeint_t, hugeint_t, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
735: 	case PhysicalType::FLOAT:
736: 		return DistinctSelect<float, float, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
737: 	case PhysicalType::DOUBLE:
738: 		return DistinctSelect<double, double, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
739: 	case PhysicalType::INTERVAL:
740: 		return DistinctSelect<interval_t, interval_t, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
741: 	case PhysicalType::VARCHAR:
742: 		return DistinctSelect<string_t, string_t, OP, DENSE>(left, right, vcount, sel, count, true_sel, false_sel);
743: 	case PhysicalType::MAP:
744: 	case PhysicalType::STRUCT:
745: 	case PhysicalType::LIST:
746: 		return DistinctSelectNested<OP, DENSE, OPNESTED>(left, right, vcount, sel, count, true_sel, false_sel);
747: 	default:
748: 		throw InternalException("Invalid type for distinct selection");
749: 	}
750: }
751: 
752: template <typename OP>
753: static void NestedDistinctExecute(Vector &left, Vector &right, Vector &result, idx_t count) {
754: 	const auto left_constant = left.GetVectorType() == VectorType::CONSTANT_VECTOR;
755: 	const auto right_constant = right.GetVectorType() == VectorType::CONSTANT_VECTOR;
756: 
757: 	if (left_constant && right_constant) {
758: 		// both sides are constant, so just compare one element.
759: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
760: 		auto result_data = ConstantVector::GetData<bool>(result);
761: 		SelectionVector true_sel(1);
762: 		auto match_count = TemplatedDistinctSelectOperation<OP, true>(left, right, 1, nullptr, 1, &true_sel, nullptr);
763: 		result_data[0] = match_count > 0;
764: 		return;
765: 	}
766: 
767: 	SelectionVector true_sel(count);
768: 	SelectionVector false_sel(count);
769: 
770: 	// DISTINCT is either true or false
771: 	idx_t match_count =
772: 	    TemplatedDistinctSelectOperation<OP, true>(left, right, count, nullptr, count, &true_sel, &false_sel);
773: 
774: 	result.SetVectorType(VectorType::FLAT_VECTOR);
775: 	auto result_data = FlatVector::GetData<bool>(result);
776: 
777: 	for (idx_t i = 0; i < match_count; ++i) {
778: 		const auto idx = true_sel.get_index(i);
779: 		result_data[idx] = true;
780: 	}
781: 
782: 	const idx_t no_match_count = count - match_count;
783: 	for (idx_t i = 0; i < no_match_count; ++i) {
784: 		const auto idx = false_sel.get_index(i);
785: 		result_data[idx] = false;
786: 	}
787: }
788: 
789: void VectorOperations::DistinctFrom(Vector &left, Vector &right, Vector &result, idx_t count) {
790: 	ExecuteDistinct<duckdb::DistinctFrom>(left, right, result, count);
791: }
792: 
793: void VectorOperations::NotDistinctFrom(Vector &left, Vector &right, Vector &result, idx_t count) {
794: 	ExecuteDistinct<duckdb::NotDistinctFrom>(left, right, result, count);
795: }
796: 
797: // true := A != B with nulls being equal
798: idx_t VectorOperations::DistinctFrom(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
799:                                      SelectionVector *true_sel, SelectionVector *false_sel) {
800: 	return TemplatedDistinctSelectOperation<duckdb::DistinctFrom, true>(left, right, count, sel, count, true_sel,
801: 	                                                                    false_sel);
802: }
803: // true := A == B with nulls being equal
804: idx_t VectorOperations::NotDistinctFrom(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
805:                                         SelectionVector *true_sel, SelectionVector *false_sel) {
806: 	return TemplatedDistinctSelectOperation<duckdb::NotDistinctFrom, true>(left, right, count, sel, count, true_sel,
807: 	                                                                       false_sel);
808: }
809: 
810: // true := A > B with nulls being maximal
811: idx_t VectorOperations::DistinctGreaterThan(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
812:                                             SelectionVector *true_sel, SelectionVector *false_sel) {
813: 	return TemplatedDistinctSelectOperation<duckdb::DistinctGreaterThan, true>(left, right, count, sel, count, true_sel,
814: 	                                                                           false_sel);
815: }
816: 
817: // true := A > B with nulls being minimal
818: idx_t VectorOperations::DistinctGreaterThanNullsFirst(Vector &left, Vector &right, const SelectionVector *sel,
819:                                                       idx_t count, SelectionVector *true_sel,
820:                                                       SelectionVector *false_sel) {
821: 	return TemplatedDistinctSelectOperation<duckdb::DistinctGreaterThanNullsFirst, true, duckdb::DistinctGreaterThan>(
822: 	    left, right, count, sel, count, true_sel, false_sel);
823: }
824: // true := A >= B with nulls being maximal
825: idx_t VectorOperations::DistinctGreaterThanEquals(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
826:                                                   SelectionVector *true_sel, SelectionVector *false_sel) {
827: 	return TemplatedDistinctSelectOperation<duckdb::DistinctGreaterThanEquals, true>(left, right, count, sel, count,
828: 	                                                                                 true_sel, false_sel);
829: }
830: // true := A < B with nulls being maximal
831: idx_t VectorOperations::DistinctLessThan(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
832:                                          SelectionVector *true_sel, SelectionVector *false_sel) {
833: 	return TemplatedDistinctSelectOperation<duckdb::DistinctLessThan, true>(left, right, count, sel, count, true_sel,
834: 	                                                                        false_sel);
835: }
836: 
837: // true := A < B with nulls being minimal
838: idx_t VectorOperations::DistinctLessThanNullsFirst(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
839:                                                    SelectionVector *true_sel, SelectionVector *false_sel) {
840: 	return TemplatedDistinctSelectOperation<duckdb::DistinctLessThanNullsFirst, true, duckdb::DistinctLessThan>(
841: 	    left, right, count, sel, count, true_sel, false_sel);
842: }
843: 
844: // true := A <= B with nulls being maximal
845: idx_t VectorOperations::DistinctLessThanEquals(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
846:                                                SelectionVector *true_sel, SelectionVector *false_sel) {
847: 	return TemplatedDistinctSelectOperation<duckdb::DistinctLessThanEquals, true>(left, right, count, sel, count,
848: 	                                                                              true_sel, false_sel);
849: }
850: 
851: // true := A != B with nulls being equal, inputs selected
852: idx_t VectorOperations::NestedNotEquals(Vector &left, Vector &right, idx_t vcount, const SelectionVector &sel,
853:                                         idx_t count, SelectionVector *true_sel, SelectionVector *false_sel) {
854: 	return TemplatedDistinctSelectOperation<duckdb::DistinctFrom, false>(left, right, vcount, &sel, count, true_sel,
855: 	                                                                     false_sel);
856: }
857: // true := A == B with nulls being equal, inputs selected
858: idx_t VectorOperations::NestedEquals(Vector &left, Vector &right, idx_t vcount, const SelectionVector &sel, idx_t count,
859:                                      SelectionVector *true_sel, SelectionVector *false_sel) {
860: 	return TemplatedDistinctSelectOperation<duckdb::NotDistinctFrom, false>(left, right, vcount, &sel, count, true_sel,
861: 	                                                                        false_sel);
862: }
863: // true := A > B with nulls being maximal, inputs selected
864: idx_t VectorOperations::NestedGreaterThan(Vector &left, Vector &right, idx_t vcount, const SelectionVector &sel,
865:                                           idx_t count, SelectionVector *true_sel, SelectionVector *false_sel) {
866: 	return TemplatedDistinctSelectOperation<duckdb::DistinctGreaterThan, false>(left, right, vcount, &sel, count,
867: 	                                                                            true_sel, false_sel);
868: }
869: // true := A >= B with nulls being maximal, inputs selected
870: idx_t VectorOperations::NestedGreaterThanEquals(Vector &left, Vector &right, idx_t vcount, const SelectionVector &sel,
871:                                                 idx_t count, SelectionVector *true_sel, SelectionVector *false_sel) {
872: 	return TemplatedDistinctSelectOperation<duckdb::DistinctGreaterThanEquals, false>(left, right, vcount, &sel, count,
873: 	                                                                                  true_sel, false_sel);
874: }
875: // true := A < B with nulls being maximal, inputs selected
876: idx_t VectorOperations::NestedLessThan(Vector &left, Vector &right, idx_t vcount, const SelectionVector &sel,
877:                                        idx_t count, SelectionVector *true_sel, SelectionVector *false_sel) {
878: 	return TemplatedDistinctSelectOperation<duckdb::DistinctLessThan, false>(left, right, vcount, &sel, count, true_sel,
879: 	                                                                         false_sel);
880: }
881: // true := A <= B with nulls being maximal, inputs selected
882: idx_t VectorOperations::NestedLessThanEquals(Vector &left, Vector &right, idx_t vcount, const SelectionVector &sel,
883:                                              idx_t count, SelectionVector *true_sel, SelectionVector *false_sel) {
884: 	return TemplatedDistinctSelectOperation<duckdb::DistinctLessThanEquals, false>(left, right, vcount, &sel, count,
885: 	                                                                               true_sel, false_sel);
886: }
887: 
888: } // namespace duckdb
[end of src/common/vector_operations/is_distinct_from.cpp]
[start of src/execution/operator/order/physical_top_n.cpp]
1: #include "duckdb/execution/operator/order/physical_top_n.hpp"
2: 
3: #include "duckdb/common/assert.hpp"
4: #include "duckdb/common/value_operations/value_operations.hpp"
5: #include "duckdb/common/vector_operations/vector_operations.hpp"
6: #include "duckdb/execution/expression_executor.hpp"
7: #include "duckdb/storage/data_table.hpp"
8: #include "duckdb/common/sort/sort.hpp"
9: #include "duckdb/common/types/row_layout.hpp"
10: 
11: namespace duckdb {
12: 
13: PhysicalTopN::PhysicalTopN(vector<LogicalType> types, vector<BoundOrderByNode> orders, idx_t limit, idx_t offset,
14:                            idx_t estimated_cardinality)
15:     : PhysicalOperator(PhysicalOperatorType::TOP_N, move(types), estimated_cardinality), orders(move(orders)),
16:       limit(limit), offset(offset) {
17: }
18: 
19: //===--------------------------------------------------------------------===//
20: // Heaps
21: //===--------------------------------------------------------------------===//
22: class TopNHeap;
23: 
24: struct TopNScanState {
25: 	unique_ptr<PayloadScanner> scanner;
26: 	idx_t pos;
27: 	bool exclude_offset;
28: };
29: 
30: class TopNSortState {
31: public:
32: 	explicit TopNSortState(TopNHeap &heap);
33: 
34: 	TopNHeap &heap;
35: 	unique_ptr<LocalSortState> local_state;
36: 	unique_ptr<GlobalSortState> global_state;
37: 	idx_t count;
38: 	bool is_sorted;
39: 
40: public:
41: 	void Initialize();
42: 	void Append(DataChunk &sort_chunk, DataChunk &payload);
43: 
44: 	void Sink(DataChunk &input);
45: 	void Finalize();
46: 
47: 	void Move(TopNSortState &other);
48: 
49: 	void InitializeScan(TopNScanState &state, bool exclude_offset);
50: 	void Scan(TopNScanState &state, DataChunk &chunk);
51: };
52: 
53: class TopNHeap {
54: public:
55: 	TopNHeap(ClientContext &context, const vector<LogicalType> &payload_types, const vector<BoundOrderByNode> &orders,
56: 	         idx_t limit, idx_t offset);
57: 
58: 	ClientContext &context;
59: 	const vector<LogicalType> &payload_types;
60: 	const vector<BoundOrderByNode> &orders;
61: 	idx_t limit;
62: 	idx_t offset;
63: 	TopNSortState sort_state;
64: 	ExpressionExecutor executor;
65: 	DataChunk sort_chunk;
66: 	DataChunk compare_chunk;
67: 	DataChunk payload_chunk;
68: 	//! A set of boundary values that determine either the minimum or the maximum value we have to consider for our
69: 	//! top-n
70: 	DataChunk boundary_values;
71: 	//! Whether or not the boundary_values has been set. The boundary_values are only set after a reduce step
72: 	bool has_boundary_values;
73: 
74: 	SelectionVector final_sel;
75: 	SelectionVector true_sel;
76: 	SelectionVector false_sel;
77: 	SelectionVector new_remaining_sel;
78: 
79: public:
80: 	void Sink(DataChunk &input);
81: 	void Combine(TopNHeap &other);
82: 	void Reduce();
83: 	void Finalize();
84: 
85: 	void ExtractBoundaryValues(DataChunk &current_chunk, DataChunk &prev_chunk);
86: 
87: 	void InitializeScan(TopNScanState &state, bool exclude_offset);
88: 	void Scan(TopNScanState &state, DataChunk &chunk);
89: 
90: 	bool CheckBoundaryValues(DataChunk &sort_chunk, DataChunk &payload);
91: };
92: 
93: //===--------------------------------------------------------------------===//
94: // TopNSortState
95: //===--------------------------------------------------------------------===//
96: TopNSortState::TopNSortState(TopNHeap &heap) : heap(heap), count(0), is_sorted(false) {
97: }
98: 
99: void TopNSortState::Initialize() {
100: 	RowLayout layout;
101: 	layout.Initialize(heap.payload_types);
102: 	auto &buffer_manager = BufferManager::GetBufferManager(heap.context);
103: 	global_state = make_unique<GlobalSortState>(buffer_manager, heap.orders, layout);
104: 	local_state = make_unique<LocalSortState>();
105: 	local_state->Initialize(*global_state, buffer_manager);
106: }
107: 
108: void TopNSortState::Append(DataChunk &sort_chunk, DataChunk &payload) {
109: 	D_ASSERT(!is_sorted);
110: 	if (heap.has_boundary_values) {
111: 		if (!heap.CheckBoundaryValues(sort_chunk, payload)) {
112: 			return;
113: 		}
114: 	}
115: 
116: 	local_state->SinkChunk(sort_chunk, payload);
117: 	count += payload.size();
118: }
119: 
120: void TopNSortState::Sink(DataChunk &input) {
121: 	// compute the ordering values for the new chunk
122: 	heap.sort_chunk.Reset();
123: 	heap.executor.Execute(input, heap.sort_chunk);
124: 
125: 	// append the new chunk to what we have already
126: 	Append(heap.sort_chunk, input);
127: }
128: 
129: void TopNSortState::Move(TopNSortState &other) {
130: 	local_state = move(other.local_state);
131: 	global_state = move(other.global_state);
132: 	count = other.count;
133: 	is_sorted = other.is_sorted;
134: }
135: 
136: void TopNSortState::Finalize() {
137: 	D_ASSERT(!is_sorted);
138: 	global_state->AddLocalState(*local_state);
139: 
140: 	global_state->PrepareMergePhase();
141: 	while (global_state->sorted_blocks.size() > 1) {
142: 		MergeSorter merge_sorter(*global_state, BufferManager::GetBufferManager(heap.context));
143: 		merge_sorter.PerformInMergeRound();
144: 		global_state->CompleteMergeRound();
145: 	}
146: 	is_sorted = true;
147: }
148: 
149: void TopNSortState::InitializeScan(TopNScanState &state, bool exclude_offset) {
150: 	D_ASSERT(is_sorted);
151: 	if (global_state->sorted_blocks.empty()) {
152: 		state.scanner = nullptr;
153: 	} else {
154: 		D_ASSERT(global_state->sorted_blocks.size() == 1);
155: 		state.scanner = make_unique<PayloadScanner>(*global_state->sorted_blocks[0]->payload_data, *global_state);
156: 	}
157: 	state.pos = 0;
158: 	state.exclude_offset = exclude_offset && heap.offset > 0;
159: }
160: 
161: void TopNSortState::Scan(TopNScanState &state, DataChunk &chunk) {
162: 	if (!state.scanner) {
163: 		return;
164: 	}
165: 	auto offset = heap.offset;
166: 	auto limit = heap.limit;
167: 	D_ASSERT(is_sorted);
168: 	while (chunk.size() == 0) {
169: 		state.scanner->Scan(chunk);
170: 		if (chunk.size() == 0) {
171: 			break;
172: 		}
173: 		idx_t start = state.pos;
174: 		idx_t end = state.pos + chunk.size();
175: 		state.pos = end;
176: 
177: 		idx_t chunk_start = 0;
178: 		idx_t chunk_end = chunk.size();
179: 		if (state.exclude_offset) {
180: 			// we need to exclude all tuples before the OFFSET
181: 			// check if we should include anything
182: 			if (end <= offset) {
183: 				// end is smaller than offset: include nothing!
184: 				chunk.Reset();
185: 				continue;
186: 			} else if (start < offset) {
187: 				// we need to slice
188: 				chunk_start = offset - start;
189: 			}
190: 		}
191: 		// check if we need to truncate at the offset + limit mark
192: 		if (start >= offset + limit) {
193: 			// we are finished
194: 			chunk_end = 0;
195: 		} else if (end > offset + limit) {
196: 			// the end extends past the offset + limit
197: 			// truncate the current chunk
198: 			chunk_end = offset + limit - start;
199: 		}
200: 		D_ASSERT(chunk_end - chunk_start <= STANDARD_VECTOR_SIZE);
201: 		if (chunk_end == chunk_start) {
202: 			chunk.Reset();
203: 			break;
204: 		} else if (chunk_start > 0) {
205: 			SelectionVector sel(STANDARD_VECTOR_SIZE);
206: 			for (idx_t i = chunk_start; i < chunk_end; i++) {
207: 				sel.set_index(i - chunk_start, i);
208: 			}
209: 			chunk.Slice(sel, chunk_end - chunk_start);
210: 		} else if (chunk_end != chunk.size()) {
211: 			chunk.SetCardinality(chunk_end);
212: 		}
213: 	}
214: }
215: 
216: //===--------------------------------------------------------------------===//
217: // TopNHeap
218: //===--------------------------------------------------------------------===//
219: TopNHeap::TopNHeap(ClientContext &context_p, const vector<LogicalType> &payload_types_p,
220:                    const vector<BoundOrderByNode> &orders_p, idx_t limit, idx_t offset)
221:     : context(context_p), payload_types(payload_types_p), orders(orders_p), limit(limit), offset(offset),
222:       sort_state(*this), has_boundary_values(false), final_sel(STANDARD_VECTOR_SIZE), true_sel(STANDARD_VECTOR_SIZE),
223:       false_sel(STANDARD_VECTOR_SIZE), new_remaining_sel(STANDARD_VECTOR_SIZE) {
224: 	// initialize the executor and the sort_chunk
225: 	vector<LogicalType> sort_types;
226: 	for (auto &order : orders) {
227: 		auto &expr = order.expression;
228: 		sort_types.push_back(expr->return_type);
229: 		executor.AddExpression(*expr);
230: 	}
231: 	payload_chunk.Initialize(payload_types);
232: 	sort_chunk.Initialize(sort_types);
233: 	compare_chunk.Initialize(sort_types);
234: 	boundary_values.Initialize(sort_types);
235: 	sort_state.Initialize();
236: }
237: 
238: void TopNHeap::Sink(DataChunk &input) {
239: 	sort_state.Sink(input);
240: }
241: 
242: void TopNHeap::Combine(TopNHeap &other) {
243: 	other.Finalize();
244: 
245: 	TopNScanState state;
246: 	other.InitializeScan(state, false);
247: 	while (true) {
248: 		payload_chunk.Reset();
249: 		other.Scan(state, payload_chunk);
250: 		if (payload_chunk.size() == 0) {
251: 			break;
252: 		}
253: 		Sink(payload_chunk);
254: 	}
255: 	Reduce();
256: }
257: 
258: void TopNHeap::Finalize() {
259: 	sort_state.Finalize();
260: }
261: 
262: void TopNHeap::Reduce() {
263: 	idx_t min_sort_threshold = MaxValue<idx_t>(STANDARD_VECTOR_SIZE * 5, 2 * (limit + offset));
264: 	if (sort_state.count < min_sort_threshold) {
265: 		// only reduce when we pass two times the limit + offset, or 5 vectors (whichever comes first)
266: 		return;
267: 	}
268: 	sort_state.Finalize();
269: 	TopNSortState new_state(*this);
270: 	new_state.Initialize();
271: 
272: 	TopNScanState state;
273: 	sort_state.InitializeScan(state, false);
274: 
275: 	DataChunk new_chunk;
276: 	new_chunk.Initialize(payload_types);
277: 
278: 	DataChunk *current_chunk = &new_chunk;
279: 	DataChunk *prev_chunk = &payload_chunk;
280: 	has_boundary_values = false;
281: 	while (true) {
282: 		current_chunk->Reset();
283: 		Scan(state, *current_chunk);
284: 		if (current_chunk->size() == 0) {
285: 			ExtractBoundaryValues(*current_chunk, *prev_chunk);
286: 			break;
287: 		}
288: 		new_state.Sink(*current_chunk);
289: 		std::swap(current_chunk, prev_chunk);
290: 	}
291: 
292: 	sort_state.Move(new_state);
293: }
294: 
295: void TopNHeap::ExtractBoundaryValues(DataChunk &current_chunk, DataChunk &prev_chunk) {
296: 	// extract the last entry of the prev_chunk and set as minimum value
297: 	D_ASSERT(prev_chunk.size() > 0);
298: 	for (idx_t col_idx = 0; col_idx < current_chunk.ColumnCount(); col_idx++) {
299: 		ConstantVector::Reference(current_chunk.data[col_idx], prev_chunk.data[col_idx], prev_chunk.size() - 1,
300: 		                          prev_chunk.size());
301: 	}
302: 	current_chunk.SetCardinality(1);
303: 	sort_chunk.Reset();
304: 	executor.Execute(&current_chunk, sort_chunk);
305: 
306: 	boundary_values.Reset();
307: 	boundary_values.Append(sort_chunk);
308: 	boundary_values.SetCardinality(1);
309: 	for (idx_t i = 0; i < boundary_values.ColumnCount(); i++) {
310: 		boundary_values.data[i].SetVectorType(VectorType::CONSTANT_VECTOR);
311: 	}
312: 	has_boundary_values = true;
313: }
314: 
315: bool TopNHeap::CheckBoundaryValues(DataChunk &sort_chunk, DataChunk &payload) {
316: 	// we have boundary values
317: 	// from these boundary values, determine which values we should insert (if any)
318: 	idx_t final_count = 0;
319: 
320: 	SelectionVector remaining_sel(nullptr);
321: 	idx_t remaining_count = sort_chunk.size();
322: 	for (idx_t i = 0; i < orders.size(); i++) {
323: 		if (remaining_sel.data()) {
324: 			compare_chunk.data[i].Slice(sort_chunk.data[i], remaining_sel, remaining_count);
325: 		} else {
326: 			compare_chunk.data[i].Reference(sort_chunk.data[i]);
327: 		}
328: 		bool is_last = i + 1 == orders.size();
329: 		idx_t true_count;
330: 		if (orders[i].null_order == OrderByNullType::NULLS_LAST) {
331: 			if (orders[i].type == OrderType::ASCENDING) {
332: 				true_count = VectorOperations::DistinctLessThan(compare_chunk.data[i], boundary_values.data[i],
333: 				                                                &remaining_sel, remaining_count, &true_sel, &false_sel);
334: 			} else {
335: 				true_count = VectorOperations::DistinctGreaterThanNullsFirst(compare_chunk.data[i],
336: 				                                                             boundary_values.data[i], &remaining_sel,
337: 				                                                             remaining_count, &true_sel, &false_sel);
338: 			}
339: 		} else {
340: 			D_ASSERT(orders[i].null_order == OrderByNullType::NULLS_FIRST);
341: 			if (orders[i].type == OrderType::ASCENDING) {
342: 				true_count = VectorOperations::DistinctLessThanNullsFirst(compare_chunk.data[i],
343: 				                                                          boundary_values.data[i], &remaining_sel,
344: 				                                                          remaining_count, &true_sel, &false_sel);
345: 			} else {
346: 				true_count =
347: 				    VectorOperations::DistinctGreaterThan(compare_chunk.data[i], boundary_values.data[i],
348: 				                                          &remaining_sel, remaining_count, &true_sel, &false_sel);
349: 			}
350: 		}
351: 
352: 		if (true_count > 0) {
353: 			memcpy(final_sel.data() + final_count, true_sel.data(), true_count * sizeof(sel_t));
354: 			final_count += true_count;
355: 		}
356: 		idx_t false_count = remaining_count - true_count;
357: 		if (false_count > 0) {
358: 			// check what we should continue to check
359: 			remaining_count = VectorOperations::NotDistinctFrom(compare_chunk.data[i], boundary_values.data[i],
360: 			                                                    &false_sel, false_count, &new_remaining_sel, nullptr);
361: 			if (is_last) {
362: 				memcpy(final_sel.data() + final_count, new_remaining_sel.data(), remaining_count * sizeof(sel_t));
363: 				final_count += remaining_count;
364: 			} else {
365: 				remaining_sel.Initialize(new_remaining_sel);
366: 			}
367: 		} else {
368: 			break;
369: 		}
370: 	}
371: 	if (final_count == 0) {
372: 		return false;
373: 	}
374: 	if (final_count < sort_chunk.size()) {
375: 		sort_chunk.Slice(final_sel, final_count);
376: 		payload.Slice(final_sel, final_count);
377: 	}
378: 	return true;
379: }
380: 
381: void TopNHeap::InitializeScan(TopNScanState &state, bool exclude_offset) {
382: 	sort_state.InitializeScan(state, exclude_offset);
383: }
384: 
385: void TopNHeap::Scan(TopNScanState &state, DataChunk &chunk) {
386: 	sort_state.Scan(state, chunk);
387: }
388: 
389: class TopNGlobalState : public GlobalSinkState {
390: public:
391: 	TopNGlobalState(ClientContext &context, const vector<LogicalType> &payload_types,
392: 	                const vector<BoundOrderByNode> &orders, idx_t limit, idx_t offset)
393: 	    : heap(context, payload_types, orders, limit, offset) {
394: 	}
395: 
396: 	mutex lock;
397: 	TopNHeap heap;
398: };
399: 
400: class TopNLocalState : public LocalSinkState {
401: public:
402: 	TopNLocalState(ClientContext &context, const vector<LogicalType> &payload_types,
403: 	               const vector<BoundOrderByNode> &orders, idx_t limit, idx_t offset)
404: 	    : heap(context, payload_types, orders, limit, offset) {
405: 	}
406: 
407: 	TopNHeap heap;
408: };
409: 
410: unique_ptr<LocalSinkState> PhysicalTopN::GetLocalSinkState(ExecutionContext &context) const {
411: 	return make_unique<TopNLocalState>(context.client, types, orders, limit, offset);
412: }
413: 
414: unique_ptr<GlobalSinkState> PhysicalTopN::GetGlobalSinkState(ClientContext &context) const {
415: 	return make_unique<TopNGlobalState>(context, types, orders, limit, offset);
416: }
417: 
418: //===--------------------------------------------------------------------===//
419: // Sink
420: //===--------------------------------------------------------------------===//
421: SinkResultType PhysicalTopN::Sink(ExecutionContext &context, GlobalSinkState &state, LocalSinkState &lstate,
422:                                   DataChunk &input) const {
423: 	// append to the local sink state
424: 	auto &sink = (TopNLocalState &)lstate;
425: 	sink.heap.Sink(input);
426: 	sink.heap.Reduce();
427: 	return SinkResultType::NEED_MORE_INPUT;
428: }
429: 
430: //===--------------------------------------------------------------------===//
431: // Combine
432: //===--------------------------------------------------------------------===//
433: void PhysicalTopN::Combine(ExecutionContext &context, GlobalSinkState &state, LocalSinkState &lstate_p) const {
434: 	auto &gstate = (TopNGlobalState &)state;
435: 	auto &lstate = (TopNLocalState &)lstate_p;
436: 
437: 	// scan the local top N and append it to the global heap
438: 	lock_guard<mutex> glock(gstate.lock);
439: 	gstate.heap.Combine(lstate.heap);
440: }
441: 
442: //===--------------------------------------------------------------------===//
443: // Finalize
444: //===--------------------------------------------------------------------===//
445: SinkFinalizeType PhysicalTopN::Finalize(Pipeline &pipeline, Event &event, ClientContext &context,
446:                                         GlobalSinkState &gstate_p) const {
447: 	auto &gstate = (TopNGlobalState &)gstate_p;
448: 	// global finalize: compute the final top N
449: 	gstate.heap.Finalize();
450: 	return SinkFinalizeType::READY;
451: }
452: 
453: //===--------------------------------------------------------------------===//
454: // Source
455: //===--------------------------------------------------------------------===//
456: class TopNOperatorState : public GlobalSourceState {
457: public:
458: 	TopNScanState state;
459: 	bool initialized = false;
460: };
461: 
462: unique_ptr<GlobalSourceState> PhysicalTopN::GetGlobalSourceState(ClientContext &context) const {
463: 	return make_unique<TopNOperatorState>();
464: }
465: 
466: void PhysicalTopN::GetData(ExecutionContext &context, DataChunk &chunk, GlobalSourceState &gstate_p,
467:                            LocalSourceState &lstate) const {
468: 	if (limit == 0) {
469: 		return;
470: 	}
471: 	auto &state = (TopNOperatorState &)gstate_p;
472: 	auto &gstate = (TopNGlobalState &)*sink_state;
473: 
474: 	if (!state.initialized) {
475: 		gstate.heap.InitializeScan(state.state, true);
476: 		state.initialized = true;
477: 	}
478: 	gstate.heap.Scan(state.state, chunk);
479: }
480: 
481: string PhysicalTopN::ParamsToString() const {
482: 	string result;
483: 	result += "Top " + to_string(limit);
484: 	if (offset > 0) {
485: 		result += "\n";
486: 		result += "Offset " + to_string(offset);
487: 	}
488: 	result += "\n[INFOSEPARATOR]";
489: 	for (idx_t i = 0; i < orders.size(); i++) {
490: 		result += "\n";
491: 		result += orders[i].expression->ToString() + " ";
492: 		result += orders[i].type == OrderType::DESCENDING ? "DESC" : "ASC";
493: 	}
494: 	return result;
495: }
496: 
497: } // namespace duckdb
[end of src/execution/operator/order/physical_top_n.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: