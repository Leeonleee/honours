diff --git a/src/function/table/system/CMakeLists.txt b/src/function/table/system/CMakeLists.txt
index baa4854d17be..4b1813a15ab0 100644
--- a/src/function/table/system/CMakeLists.txt
+++ b/src/function/table/system/CMakeLists.txt
@@ -5,6 +5,7 @@ add_library_unity(
   duckdb_constraints.cpp
   duckdb_dependencies.cpp
   duckdb_functions.cpp
+  duckdb_keywords.cpp
   duckdb_indexes.cpp
   duckdb_schemas.cpp
   duckdb_sequences.cpp
diff --git a/src/function/table/system/duckdb_keywords.cpp b/src/function/table/system/duckdb_keywords.cpp
new file mode 100644
index 000000000000..460e41aac595
--- /dev/null
+++ b/src/function/table/system/duckdb_keywords.cpp
@@ -0,0 +1,84 @@
+#include "duckdb/function/table/system_functions.hpp"
+
+#include "duckdb/common/exception.hpp"
+#include "duckdb/main/client_context.hpp"
+#include "duckdb/parser/parser.hpp"
+
+namespace duckdb {
+
+struct DuckDBKeywordsData : public FunctionOperatorData {
+	DuckDBKeywordsData() : offset(0) {
+	}
+
+	vector<ParserKeyword> entries;
+	idx_t offset;
+};
+
+static unique_ptr<FunctionData> DuckDBKeywordsBind(ClientContext &context, vector<Value> &inputs,
+                                                   unordered_map<string, Value> &named_parameters,
+                                                   vector<LogicalType> &input_table_types,
+                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,
+                                                   vector<string> &names) {
+	names.emplace_back("keyword_name");
+	return_types.emplace_back(LogicalType::VARCHAR);
+
+	names.emplace_back("keyword_category");
+	return_types.emplace_back(LogicalType::VARCHAR);
+
+	return nullptr;
+}
+
+unique_ptr<FunctionOperatorData> DuckDBKeywordsInit(ClientContext &context, const FunctionData *bind_data,
+                                                    const vector<column_t> &column_ids,
+                                                    TableFilterCollection *filters) {
+	auto result = make_unique<DuckDBKeywordsData>();
+	result->entries = Parser::KeywordList();
+	return move(result);
+}
+
+void DuckDBKeywordsFunction(ClientContext &context, const FunctionData *bind_data, FunctionOperatorData *operator_state,
+                            DataChunk *input, DataChunk &output) {
+	auto &data = (DuckDBKeywordsData &)*operator_state;
+	if (data.offset >= data.entries.size()) {
+		// finished returning values
+		return;
+	}
+	// start returning values
+	// either fill up the chunk or return all the remaining columns
+	idx_t count = 0;
+	while (data.offset < data.entries.size() && count < STANDARD_VECTOR_SIZE) {
+		auto &entry = data.entries[data.offset++];
+
+		// keyword_name, VARCHAR
+		output.SetValue(0, count, Value(entry.name));
+		// keyword_category, VARCHAR
+		string category_name;
+		switch (entry.category) {
+		case KeywordCategory::KEYWORD_RESERVED:
+			category_name = "reserved";
+			break;
+		case KeywordCategory::KEYWORD_UNRESERVED:
+			category_name = "unreserved";
+			break;
+		case KeywordCategory::KEYWORD_TYPE_FUNC:
+			category_name = "type_function";
+			break;
+		case KeywordCategory::KEYWORD_COL_NAME:
+			category_name = "column_name";
+			break;
+		default:
+			throw InternalException("Unrecognized keyword category");
+		}
+		output.SetValue(1, count, Value(move(category_name)));
+
+		count++;
+	}
+	output.SetCardinality(count);
+}
+
+void DuckDBKeywordsFun::RegisterFunction(BuiltinFunctions &set) {
+	set.AddFunction(
+	    TableFunction("duckdb_keywords", {}, DuckDBKeywordsFunction, DuckDBKeywordsBind, DuckDBKeywordsInit));
+}
+
+} // namespace duckdb
diff --git a/src/function/table/system_functions.cpp b/src/function/table/system_functions.cpp
index 43daf637f548..a6ac76065e61 100644
--- a/src/function/table/system_functions.cpp
+++ b/src/function/table/system_functions.cpp
@@ -22,6 +22,7 @@ void BuiltinFunctions::RegisterSQLiteFunctions() {
 	DuckDBColumnsFun::RegisterFunction(*this);
 	DuckDBConstraintsFun::RegisterFunction(*this);
 	DuckDBFunctionsFun::RegisterFunction(*this);
+	DuckDBKeywordsFun::RegisterFunction(*this);
 	DuckDBIndexesFun::RegisterFunction(*this);
 	DuckDBSchemasFun::RegisterFunction(*this);
 	DuckDBDependenciesFun::RegisterFunction(*this);
diff --git a/src/include/duckdb/function/table/system_functions.hpp b/src/include/duckdb/function/table/system_functions.hpp
index 916c7d6f79e8..a22ead0d1581 100644
--- a/src/include/duckdb/function/table/system_functions.hpp
+++ b/src/include/duckdb/function/table/system_functions.hpp
@@ -68,6 +68,10 @@ struct DuckDBFunctionsFun {
 	static void RegisterFunction(BuiltinFunctions &set);
 };
 
+struct DuckDBKeywordsFun {
+	static void RegisterFunction(BuiltinFunctions &set);
+};
+
 struct DuckDBIndexesFun {
 	static void RegisterFunction(BuiltinFunctions &set);
 };
diff --git a/src/include/duckdb/parser/parser.hpp b/src/include/duckdb/parser/parser.hpp
index 737964440a28..18521aefa150 100644
--- a/src/include/duckdb/parser/parser.hpp
+++ b/src/include/duckdb/parser/parser.hpp
@@ -28,6 +28,10 @@ class Parser {
 public:
 	Parser();
 
+	//! The parsed SQL statements from an invocation to ParseQuery.
+	vector<unique_ptr<SQLStatement>> statements;
+
+public:
 	//! Attempts to parse a query into a series of SQL statements. Returns
 	//! whether or not the parsing was successful. If the parsing was
 	//! successful, the parsed statements will be stored in the statements
@@ -39,6 +43,8 @@ class Parser {
 
 	//! Returns true if the given text matches a keyword of the parser
 	static bool IsKeyword(const string &text);
+	//! Returns a list of all keywords in the parser
+	static vector<ParserKeyword> KeywordList();
 
 	//! Parses a list of expressions (i.e. the list found in a SELECT clause)
 	static vector<unique_ptr<ParsedExpression>> ParseExpressionList(const string &select_list);
@@ -51,14 +57,5 @@ class Parser {
 	static vector<vector<unique_ptr<ParsedExpression>>> ParseValuesList(const string &value_list);
 	//! Parses a column list (i.e. as found in a CREATE TABLE statement)
 	static vector<ColumnDefinition> ParseColumnList(const string &column_list);
-
-	//! The parsed SQL statements from an invocation to ParseQuery.
-	vector<unique_ptr<SQLStatement>> statements;
-
-private:
-	//! Transform a Postgres parse tree into a set of SQL Statements
-	bool TransformList(duckdb_libpgquery::PGList *tree);
-	//! Transform a single Postgres parse node into a SQL Statement.
-	unique_ptr<SQLStatement> TransformNode(duckdb_libpgquery::PGNode *stmt);
 };
 } // namespace duckdb
diff --git a/src/include/duckdb/parser/simplified_token.hpp b/src/include/duckdb/parser/simplified_token.hpp
index 968e4534480e..e79938719aee 100644
--- a/src/include/duckdb/parser/simplified_token.hpp
+++ b/src/include/duckdb/parser/simplified_token.hpp
@@ -28,4 +28,11 @@ struct SimplifiedToken {
 	idx_t start;
 };
 
+enum class KeywordCategory : uint8_t { KEYWORD_RESERVED, KEYWORD_UNRESERVED, KEYWORD_TYPE_FUNC, KEYWORD_COL_NAME };
+
+struct ParserKeyword {
+	string name;
+	KeywordCategory category;
+};
+
 } // namespace duckdb
diff --git a/src/parser/parser.cpp b/src/parser/parser.cpp
index 516dd14aa381..8a501ae850c7 100644
--- a/src/parser/parser.cpp
+++ b/src/parser/parser.cpp
@@ -75,6 +75,8 @@ vector<SimplifiedToken> Parser::Tokenize(const string &query) {
 		case duckdb_libpgquery::PGSimplifiedTokenType::PG_SIMPLIFIED_TOKEN_COMMENT: // LCOV_EXCL_START
 			token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_COMMENT;
 			break;
+		default:
+			throw InternalException("Unrecognized token category");
 		} // LCOV_EXCL_STOP
 		token.start = pg_token.start;
 		result.push_back(token);
@@ -86,6 +88,33 @@ bool Parser::IsKeyword(const string &text) {
 	return PostgresParser::IsKeyword(text);
 }
 
+vector<ParserKeyword> Parser::KeywordList() {
+	auto keywords = PostgresParser::KeywordList();
+	vector<ParserKeyword> result;
+	for (auto &kw : keywords) {
+		ParserKeyword res;
+		res.name = kw.text;
+		switch (kw.category) {
+		case duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_RESERVED:
+			res.category = KeywordCategory::KEYWORD_RESERVED;
+			break;
+		case duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_UNRESERVED:
+			res.category = KeywordCategory::KEYWORD_UNRESERVED;
+			break;
+		case duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_TYPE_FUNC:
+			res.category = KeywordCategory::KEYWORD_TYPE_FUNC;
+			break;
+		case duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_COL_NAME:
+			res.category = KeywordCategory::KEYWORD_COL_NAME;
+			break;
+		default:
+			throw InternalException("Unrecognized keyword category");
+		}
+		result.push_back(res);
+	}
+	return result;
+}
+
 vector<unique_ptr<ParsedExpression>> Parser::ParseExpressionList(const string &select_list) {
 	// construct a mock query prefixed with SELECT
 	string mock_query = "SELECT " + select_list;
diff --git a/third_party/libpg_query/include/parser/parser.hpp b/third_party/libpg_query/include/parser/parser.hpp
index 376fb795d57e..b5413565473f 100755
--- a/third_party/libpg_query/include/parser/parser.hpp
+++ b/third_party/libpg_query/include/parser/parser.hpp
@@ -30,6 +30,7 @@ typedef enum PGBackslashQuoteType {
 PGList *raw_parser(const char *str);
 
 bool is_keyword(const char *str);
+std::vector<PGKeyword> keyword_list();
 
 std::vector<PGSimplifiedToken> tokenize(const char *str);
 
diff --git a/third_party/libpg_query/include/pg_simplified_token.hpp b/third_party/libpg_query/include/pg_simplified_token.hpp
index b4a5d9c97743..da656bef0d83 100644
--- a/third_party/libpg_query/include/pg_simplified_token.hpp
+++ b/third_party/libpg_query/include/pg_simplified_token.hpp
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <cstdint>
+#include <string>
 
 namespace duckdb_libpgquery {
 
@@ -18,4 +19,16 @@ struct PGSimplifiedToken {
 	int32_t start;
 };
 
+enum class PGKeywordCategory : uint8_t {
+	PG_KEYWORD_RESERVED,
+	PG_KEYWORD_UNRESERVED,
+	PG_KEYWORD_TYPE_FUNC,
+	PG_KEYWORD_COL_NAME
+};
+
+struct PGKeyword {
+	std::string text;
+	PGKeywordCategory category;
+};
+
 }
diff --git a/third_party/libpg_query/include/postgres_parser.hpp b/third_party/libpg_query/include/postgres_parser.hpp
index d19ec1a0be19..a008907ac173 100644
--- a/third_party/libpg_query/include/postgres_parser.hpp
+++ b/third_party/libpg_query/include/postgres_parser.hpp
@@ -28,5 +28,6 @@ class PostgresParser {
 	static std::vector<duckdb_libpgquery::PGSimplifiedToken> Tokenize(const std::string &query);
 
 	static bool IsKeyword(const std::string &text);
+	static std::vector<duckdb_libpgquery::PGKeyword> KeywordList();
 };
 }
diff --git a/third_party/libpg_query/postgres_parser.cpp b/third_party/libpg_query/postgres_parser.cpp
index b19d07924334..1455902001dc 100644
--- a/third_party/libpg_query/postgres_parser.cpp
+++ b/third_party/libpg_query/postgres_parser.cpp
@@ -39,4 +39,8 @@ bool PostgresParser::IsKeyword(const std::string &text) {
 	return duckdb_libpgquery::is_keyword(text.c_str());
 }
 
+vector<duckdb_libpgquery::PGKeyword> PostgresParser::KeywordList() {
+	return duckdb_libpgquery::keyword_list();
+}
+
 }
diff --git a/third_party/libpg_query/src_backend_parser_parser.cpp b/third_party/libpg_query/src_backend_parser_parser.cpp
index 039505cce916..e2a1529324b1 100755
--- a/third_party/libpg_query/src_backend_parser_parser.cpp
+++ b/third_party/libpg_query/src_backend_parser_parser.cpp
@@ -72,6 +72,30 @@ bool is_keyword(const char *text) {
 	return ScanKeywordLookup(text, ScanKeywords, NumScanKeywords) != NULL;
 }
 
+std::vector<PGKeyword> keyword_list() {
+    std::vector<PGKeyword> result;
+	for(size_t i = 0; i < NumScanKeywords; i++) {
+		PGKeyword keyword;
+		keyword.text = ScanKeywords[i].name;
+		switch(ScanKeywords[i].category) {
+		case UNRESERVED_KEYWORD:
+			keyword.category = PGKeywordCategory::PG_KEYWORD_UNRESERVED;
+			break;
+		case RESERVED_KEYWORD:
+			keyword.category = PGKeywordCategory::PG_KEYWORD_RESERVED;
+			break;
+		case TYPE_FUNC_NAME_KEYWORD:
+			keyword.category = PGKeywordCategory::PG_KEYWORD_TYPE_FUNC;
+			break;
+		case COL_NAME_KEYWORD:
+			keyword.category = PGKeywordCategory::PG_KEYWORD_COL_NAME;
+			break;
+		}
+		result.push_back(keyword);
+	}
+	return result;
+}
+
 std::vector<PGSimplifiedToken> tokenize(const char *str) {
 	core_yyscan_t yyscanner;
 	base_yy_extra_type yyextra;
