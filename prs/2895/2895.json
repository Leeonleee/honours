{
  "repo": "duckdb/duckdb",
  "pull_number": 2895,
  "instance_id": "duckdb__duckdb-2895",
  "issue_numbers": [
    "2891"
  ],
  "base_commit": "e77e3ab5c5975f54e7023600b6d377a8bccc32d6",
  "patch": "diff --git a/src/function/table/system/CMakeLists.txt b/src/function/table/system/CMakeLists.txt\nindex baa4854d17be..4b1813a15ab0 100644\n--- a/src/function/table/system/CMakeLists.txt\n+++ b/src/function/table/system/CMakeLists.txt\n@@ -5,6 +5,7 @@ add_library_unity(\n   duckdb_constraints.cpp\n   duckdb_dependencies.cpp\n   duckdb_functions.cpp\n+  duckdb_keywords.cpp\n   duckdb_indexes.cpp\n   duckdb_schemas.cpp\n   duckdb_sequences.cpp\ndiff --git a/src/function/table/system/duckdb_keywords.cpp b/src/function/table/system/duckdb_keywords.cpp\nnew file mode 100644\nindex 000000000000..460e41aac595\n--- /dev/null\n+++ b/src/function/table/system/duckdb_keywords.cpp\n@@ -0,0 +1,84 @@\n+#include \"duckdb/function/table/system_functions.hpp\"\n+\n+#include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/main/client_context.hpp\"\n+#include \"duckdb/parser/parser.hpp\"\n+\n+namespace duckdb {\n+\n+struct DuckDBKeywordsData : public FunctionOperatorData {\n+\tDuckDBKeywordsData() : offset(0) {\n+\t}\n+\n+\tvector<ParserKeyword> entries;\n+\tidx_t offset;\n+};\n+\n+static unique_ptr<FunctionData> DuckDBKeywordsBind(ClientContext &context, vector<Value> &inputs,\n+                                                   unordered_map<string, Value> &named_parameters,\n+                                                   vector<LogicalType> &input_table_types,\n+                                                   vector<string> &input_table_names, vector<LogicalType> &return_types,\n+                                                   vector<string> &names) {\n+\tnames.emplace_back(\"keyword_name\");\n+\treturn_types.emplace_back(LogicalType::VARCHAR);\n+\n+\tnames.emplace_back(\"keyword_category\");\n+\treturn_types.emplace_back(LogicalType::VARCHAR);\n+\n+\treturn nullptr;\n+}\n+\n+unique_ptr<FunctionOperatorData> DuckDBKeywordsInit(ClientContext &context, const FunctionData *bind_data,\n+                                                    const vector<column_t> &column_ids,\n+                                                    TableFilterCollection *filters) {\n+\tauto result = make_unique<DuckDBKeywordsData>();\n+\tresult->entries = Parser::KeywordList();\n+\treturn move(result);\n+}\n+\n+void DuckDBKeywordsFunction(ClientContext &context, const FunctionData *bind_data, FunctionOperatorData *operator_state,\n+                            DataChunk *input, DataChunk &output) {\n+\tauto &data = (DuckDBKeywordsData &)*operator_state;\n+\tif (data.offset >= data.entries.size()) {\n+\t\t// finished returning values\n+\t\treturn;\n+\t}\n+\t// start returning values\n+\t// either fill up the chunk or return all the remaining columns\n+\tidx_t count = 0;\n+\twhile (data.offset < data.entries.size() && count < STANDARD_VECTOR_SIZE) {\n+\t\tauto &entry = data.entries[data.offset++];\n+\n+\t\t// keyword_name, VARCHAR\n+\t\toutput.SetValue(0, count, Value(entry.name));\n+\t\t// keyword_category, VARCHAR\n+\t\tstring category_name;\n+\t\tswitch (entry.category) {\n+\t\tcase KeywordCategory::KEYWORD_RESERVED:\n+\t\t\tcategory_name = \"reserved\";\n+\t\t\tbreak;\n+\t\tcase KeywordCategory::KEYWORD_UNRESERVED:\n+\t\t\tcategory_name = \"unreserved\";\n+\t\t\tbreak;\n+\t\tcase KeywordCategory::KEYWORD_TYPE_FUNC:\n+\t\t\tcategory_name = \"type_function\";\n+\t\t\tbreak;\n+\t\tcase KeywordCategory::KEYWORD_COL_NAME:\n+\t\t\tcategory_name = \"column_name\";\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow InternalException(\"Unrecognized keyword category\");\n+\t\t}\n+\t\toutput.SetValue(1, count, Value(move(category_name)));\n+\n+\t\tcount++;\n+\t}\n+\toutput.SetCardinality(count);\n+}\n+\n+void DuckDBKeywordsFun::RegisterFunction(BuiltinFunctions &set) {\n+\tset.AddFunction(\n+\t    TableFunction(\"duckdb_keywords\", {}, DuckDBKeywordsFunction, DuckDBKeywordsBind, DuckDBKeywordsInit));\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/function/table/system_functions.cpp b/src/function/table/system_functions.cpp\nindex 43daf637f548..a6ac76065e61 100644\n--- a/src/function/table/system_functions.cpp\n+++ b/src/function/table/system_functions.cpp\n@@ -22,6 +22,7 @@ void BuiltinFunctions::RegisterSQLiteFunctions() {\n \tDuckDBColumnsFun::RegisterFunction(*this);\n \tDuckDBConstraintsFun::RegisterFunction(*this);\n \tDuckDBFunctionsFun::RegisterFunction(*this);\n+\tDuckDBKeywordsFun::RegisterFunction(*this);\n \tDuckDBIndexesFun::RegisterFunction(*this);\n \tDuckDBSchemasFun::RegisterFunction(*this);\n \tDuckDBDependenciesFun::RegisterFunction(*this);\ndiff --git a/src/include/duckdb/function/table/system_functions.hpp b/src/include/duckdb/function/table/system_functions.hpp\nindex 916c7d6f79e8..a22ead0d1581 100644\n--- a/src/include/duckdb/function/table/system_functions.hpp\n+++ b/src/include/duckdb/function/table/system_functions.hpp\n@@ -68,6 +68,10 @@ struct DuckDBFunctionsFun {\n \tstatic void RegisterFunction(BuiltinFunctions &set);\n };\n \n+struct DuckDBKeywordsFun {\n+\tstatic void RegisterFunction(BuiltinFunctions &set);\n+};\n+\n struct DuckDBIndexesFun {\n \tstatic void RegisterFunction(BuiltinFunctions &set);\n };\ndiff --git a/src/include/duckdb/parser/parser.hpp b/src/include/duckdb/parser/parser.hpp\nindex 737964440a28..18521aefa150 100644\n--- a/src/include/duckdb/parser/parser.hpp\n+++ b/src/include/duckdb/parser/parser.hpp\n@@ -28,6 +28,10 @@ class Parser {\n public:\n \tParser();\n \n+\t//! The parsed SQL statements from an invocation to ParseQuery.\n+\tvector<unique_ptr<SQLStatement>> statements;\n+\n+public:\n \t//! Attempts to parse a query into a series of SQL statements. Returns\n \t//! whether or not the parsing was successful. If the parsing was\n \t//! successful, the parsed statements will be stored in the statements\n@@ -39,6 +43,8 @@ class Parser {\n \n \t//! Returns true if the given text matches a keyword of the parser\n \tstatic bool IsKeyword(const string &text);\n+\t//! Returns a list of all keywords in the parser\n+\tstatic vector<ParserKeyword> KeywordList();\n \n \t//! Parses a list of expressions (i.e. the list found in a SELECT clause)\n \tstatic vector<unique_ptr<ParsedExpression>> ParseExpressionList(const string &select_list);\n@@ -51,14 +57,5 @@ class Parser {\n \tstatic vector<vector<unique_ptr<ParsedExpression>>> ParseValuesList(const string &value_list);\n \t//! Parses a column list (i.e. as found in a CREATE TABLE statement)\n \tstatic vector<ColumnDefinition> ParseColumnList(const string &column_list);\n-\n-\t//! The parsed SQL statements from an invocation to ParseQuery.\n-\tvector<unique_ptr<SQLStatement>> statements;\n-\n-private:\n-\t//! Transform a Postgres parse tree into a set of SQL Statements\n-\tbool TransformList(duckdb_libpgquery::PGList *tree);\n-\t//! Transform a single Postgres parse node into a SQL Statement.\n-\tunique_ptr<SQLStatement> TransformNode(duckdb_libpgquery::PGNode *stmt);\n };\n } // namespace duckdb\ndiff --git a/src/include/duckdb/parser/simplified_token.hpp b/src/include/duckdb/parser/simplified_token.hpp\nindex 968e4534480e..e79938719aee 100644\n--- a/src/include/duckdb/parser/simplified_token.hpp\n+++ b/src/include/duckdb/parser/simplified_token.hpp\n@@ -28,4 +28,11 @@ struct SimplifiedToken {\n \tidx_t start;\n };\n \n+enum class KeywordCategory : uint8_t { KEYWORD_RESERVED, KEYWORD_UNRESERVED, KEYWORD_TYPE_FUNC, KEYWORD_COL_NAME };\n+\n+struct ParserKeyword {\n+\tstring name;\n+\tKeywordCategory category;\n+};\n+\n } // namespace duckdb\ndiff --git a/src/parser/parser.cpp b/src/parser/parser.cpp\nindex 516dd14aa381..8a501ae850c7 100644\n--- a/src/parser/parser.cpp\n+++ b/src/parser/parser.cpp\n@@ -75,6 +75,8 @@ vector<SimplifiedToken> Parser::Tokenize(const string &query) {\n \t\tcase duckdb_libpgquery::PGSimplifiedTokenType::PG_SIMPLIFIED_TOKEN_COMMENT: // LCOV_EXCL_START\n \t\t\ttoken.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_COMMENT;\n \t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow InternalException(\"Unrecognized token category\");\n \t\t} // LCOV_EXCL_STOP\n \t\ttoken.start = pg_token.start;\n \t\tresult.push_back(token);\n@@ -86,6 +88,33 @@ bool Parser::IsKeyword(const string &text) {\n \treturn PostgresParser::IsKeyword(text);\n }\n \n+vector<ParserKeyword> Parser::KeywordList() {\n+\tauto keywords = PostgresParser::KeywordList();\n+\tvector<ParserKeyword> result;\n+\tfor (auto &kw : keywords) {\n+\t\tParserKeyword res;\n+\t\tres.name = kw.text;\n+\t\tswitch (kw.category) {\n+\t\tcase duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_RESERVED:\n+\t\t\tres.category = KeywordCategory::KEYWORD_RESERVED;\n+\t\t\tbreak;\n+\t\tcase duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_UNRESERVED:\n+\t\t\tres.category = KeywordCategory::KEYWORD_UNRESERVED;\n+\t\t\tbreak;\n+\t\tcase duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_TYPE_FUNC:\n+\t\t\tres.category = KeywordCategory::KEYWORD_TYPE_FUNC;\n+\t\t\tbreak;\n+\t\tcase duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_COL_NAME:\n+\t\t\tres.category = KeywordCategory::KEYWORD_COL_NAME;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow InternalException(\"Unrecognized keyword category\");\n+\t\t}\n+\t\tresult.push_back(res);\n+\t}\n+\treturn result;\n+}\n+\n vector<unique_ptr<ParsedExpression>> Parser::ParseExpressionList(const string &select_list) {\n \t// construct a mock query prefixed with SELECT\n \tstring mock_query = \"SELECT \" + select_list;\ndiff --git a/third_party/libpg_query/include/parser/parser.hpp b/third_party/libpg_query/include/parser/parser.hpp\nindex 376fb795d57e..b5413565473f 100755\n--- a/third_party/libpg_query/include/parser/parser.hpp\n+++ b/third_party/libpg_query/include/parser/parser.hpp\n@@ -30,6 +30,7 @@ typedef enum PGBackslashQuoteType {\n PGList *raw_parser(const char *str);\n \n bool is_keyword(const char *str);\n+std::vector<PGKeyword> keyword_list();\n \n std::vector<PGSimplifiedToken> tokenize(const char *str);\n \ndiff --git a/third_party/libpg_query/include/pg_simplified_token.hpp b/third_party/libpg_query/include/pg_simplified_token.hpp\nindex b4a5d9c97743..da656bef0d83 100644\n--- a/third_party/libpg_query/include/pg_simplified_token.hpp\n+++ b/third_party/libpg_query/include/pg_simplified_token.hpp\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <cstdint>\n+#include <string>\n \n namespace duckdb_libpgquery {\n \n@@ -18,4 +19,16 @@ struct PGSimplifiedToken {\n \tint32_t start;\n };\n \n+enum class PGKeywordCategory : uint8_t {\n+\tPG_KEYWORD_RESERVED,\n+\tPG_KEYWORD_UNRESERVED,\n+\tPG_KEYWORD_TYPE_FUNC,\n+\tPG_KEYWORD_COL_NAME\n+};\n+\n+struct PGKeyword {\n+\tstd::string text;\n+\tPGKeywordCategory category;\n+};\n+\n }\ndiff --git a/third_party/libpg_query/include/postgres_parser.hpp b/third_party/libpg_query/include/postgres_parser.hpp\nindex d19ec1a0be19..a008907ac173 100644\n--- a/third_party/libpg_query/include/postgres_parser.hpp\n+++ b/third_party/libpg_query/include/postgres_parser.hpp\n@@ -28,5 +28,6 @@ class PostgresParser {\n \tstatic std::vector<duckdb_libpgquery::PGSimplifiedToken> Tokenize(const std::string &query);\n \n \tstatic bool IsKeyword(const std::string &text);\n+\tstatic std::vector<duckdb_libpgquery::PGKeyword> KeywordList();\n };\n }\ndiff --git a/third_party/libpg_query/postgres_parser.cpp b/third_party/libpg_query/postgres_parser.cpp\nindex b19d07924334..1455902001dc 100644\n--- a/third_party/libpg_query/postgres_parser.cpp\n+++ b/third_party/libpg_query/postgres_parser.cpp\n@@ -39,4 +39,8 @@ bool PostgresParser::IsKeyword(const std::string &text) {\n \treturn duckdb_libpgquery::is_keyword(text.c_str());\n }\n \n+vector<duckdb_libpgquery::PGKeyword> PostgresParser::KeywordList() {\n+\treturn duckdb_libpgquery::keyword_list();\n+}\n+\n }\ndiff --git a/third_party/libpg_query/src_backend_parser_parser.cpp b/third_party/libpg_query/src_backend_parser_parser.cpp\nindex 039505cce916..e2a1529324b1 100755\n--- a/third_party/libpg_query/src_backend_parser_parser.cpp\n+++ b/third_party/libpg_query/src_backend_parser_parser.cpp\n@@ -72,6 +72,30 @@ bool is_keyword(const char *text) {\n \treturn ScanKeywordLookup(text, ScanKeywords, NumScanKeywords) != NULL;\n }\n \n+std::vector<PGKeyword> keyword_list() {\n+    std::vector<PGKeyword> result;\n+\tfor(size_t i = 0; i < NumScanKeywords; i++) {\n+\t\tPGKeyword keyword;\n+\t\tkeyword.text = ScanKeywords[i].name;\n+\t\tswitch(ScanKeywords[i].category) {\n+\t\tcase UNRESERVED_KEYWORD:\n+\t\t\tkeyword.category = PGKeywordCategory::PG_KEYWORD_UNRESERVED;\n+\t\t\tbreak;\n+\t\tcase RESERVED_KEYWORD:\n+\t\t\tkeyword.category = PGKeywordCategory::PG_KEYWORD_RESERVED;\n+\t\t\tbreak;\n+\t\tcase TYPE_FUNC_NAME_KEYWORD:\n+\t\t\tkeyword.category = PGKeywordCategory::PG_KEYWORD_TYPE_FUNC;\n+\t\t\tbreak;\n+\t\tcase COL_NAME_KEYWORD:\n+\t\t\tkeyword.category = PGKeywordCategory::PG_KEYWORD_COL_NAME;\n+\t\t\tbreak;\n+\t\t}\n+\t\tresult.push_back(keyword);\n+\t}\n+\treturn result;\n+}\n+\n std::vector<PGSimplifiedToken> tokenize(const char *str) {\n \tcore_yyscan_t yyscanner;\n \tbase_yy_extra_type yyextra;\n",
  "test_patch": "diff --git a/test/sql/table_function/duckdb_keywords.test b/test/sql/table_function/duckdb_keywords.test\nnew file mode 100644\nindex 000000000000..650510f56f8a\n--- /dev/null\n+++ b/test/sql/table_function/duckdb_keywords.test\n@@ -0,0 +1,9 @@\n+# name: test/sql/table_function/duckdb_keywords.test\n+# description: Test duckdb_keywords function\n+# group: [table_function]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+SELECT * FROM duckdb_keywords();\n",
  "problem_statement": "how to find the reserved words list\nI tried to name a column alias to including and failed. \r\nI want to know what words is not reserved. \r\n```\r\nD select 'am',12345 including; \r\nError: Parser Error: syntax error at or near \"including\"\r\nLINE 1: select 'am',12345 including;\r\n                          ^\r\nD select 'am',12345 includin;\r\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 am \u2502 includin \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 am \u2502 12345    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "A workaround is to wrap your column name alias in double quotes.\nAlso, here are the reserved keywords!\r\n[Lists of keywords for parser](https://github.com/duckdb/duckdb/tree/ff7f24fd8e3128d94371827523dae85ebaf58713/third_party/libpg_query/grammar/keywords)",
  "created_at": "2022-01-09T21:07:10Z"
}