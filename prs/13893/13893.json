{
  "repo": "duckdb/duckdb",
  "pull_number": 13893,
  "instance_id": "duckdb__duckdb-13893",
  "issue_numbers": [
    "13863"
  ],
  "base_commit": "1d7e05c9737821fdb2c8eba996642c9953de52f6",
  "patch": "diff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 9f3c92a0f91c..dfaa0092dc93 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -1396,6 +1396,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(const py::object &name_\n \n void DuckDBPyConnection::ExecuteImmediately(vector<unique_ptr<SQLStatement>> statements) {\n \tauto &connection = con.GetConnection();\n+\tpy::gil_scoped_release release;\n \tif (statements.empty()) {\n \t\treturn;\n \t}\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_duckdb_execute.py b/tools/pythonpkg/tests/fast/api/test_duckdb_execute.py\nindex 4a4d95d5c297..fba01a0cf38e 100644\n--- a/tools/pythonpkg/tests/fast/api/test_duckdb_execute.py\n+++ b/tools/pythonpkg/tests/fast/api/test_duckdb_execute.py\n@@ -74,3 +74,14 @@ def to_insert_from_generator(what):\n         duckdb_cursor.execute(\"CREATE TABLE unittest_generator (a INTEGER);\")\n         duckdb_cursor.executemany(\"INSERT into unittest_generator (a) VALUES (?)\", gen)\n         assert duckdb_cursor.table('unittest_generator').fetchall() == [(1,), (2,), (3,)]\n+\n+    def test_execute_multiple_statements(self, duckdb_cursor):\n+        pd = pytest.importorskip(\"pandas\")\n+        df = pd.DataFrame({'a': [5, 6, 7, 8]})\n+        sql = \"\"\"\n+            select * from df;\n+            select * from VALUES (1),(2),(3),(4) t(a);\n+        \"\"\"\n+        duckdb_cursor.execute(sql)\n+        res = duckdb_cursor.fetchall()\n+        assert res == [(1,), (2,), (3,), (4,)]\n",
  "problem_statement": "`duckdb.duckdb.InvalidInputException: Invalid Input Error: PandasScan called but GIL was already held!` on recursive python calls\n### What happens?\r\n\r\nA code previously working until duckdb 1.0.0 started erroring out in duckdb 1.1 by raising following error:\r\n\r\n```\r\n    res = eval(code, gs, ns)\r\n          ^^^^^^^^^^^^^^^^^^\r\n  File \"<string>\", line 1, in <module>\r\nduckdb.duckdb.InvalidInputException: Invalid Input Error: PandasScan called but GIL was already held!\r\n```\r\n\r\n\r\n### To Reproduce\r\n\r\n```\r\nimport pandas as pd\r\nimport duckdb\r\n\r\nget_data = lambda start, N=10: pd.DataFrame({'a':range(N), 'b':[f'{i+1}' for i in range(start, start+N)]})\r\n\r\ntab1 = get_data(65)\r\ntab2 = get_data(66)\r\n\r\ndb = duckdb.connect()\r\nsql = '''\r\ncreate table fixed_ids as\r\nwith recursive fanout as (\r\n    SELECT c1.a as node_id, c2.a as comp_id2,\r\n        from tab1 c1\r\n        inner JOIN tab2 c2 on c1.b = c2.b\r\n        inner JOIN tab2 c2l2 on c2.a = c2l2.a\r\n    UNION all\r\n    SELECT fo.comp_id2 as node_id, c2l1.b as comp_id2\r\n        FROM tab1 c1 inner JOIN fanout fo ON fo.comp_id2 = c1.a\r\n        inner JOIN tab2 c2l1 on c1.b = c2l1.b\r\n)\r\nSELECT node_id, first(comp_id2)::uint64 as fixed_id from fanout group by node_id;\r\n\r\nSELECT * from fixed_ids\r\n'''\r\nif 0: # Enable to run sql statement-by-statement to workaround https://github.com/duckdb/duckdb/issues/13863\r\n    stmts = db.extract_statements(sql)\r\n    for stmt in stmts[:-1]:\r\n        db.execute(stmt.query)\r\n    sql = stmts[-1].query\r\nprint(db.execute(sql).df())\r\n```\r\n\r\n\r\n\r\n### OS:\r\n\r\nRH8\r\n\r\n### DuckDB Version:\r\n\r\n1.1.0\r\n\r\n### DuckDB Client:\r\n\r\npython\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nPankaj Pandey\r\n\r\n### Affiliation:\r\n\r\nCadence\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nTested with duckdb 1.1 release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Thanks for the report! A reproducer would be very helpful to track this down.\nI have spent an inordinately long time to get a reproducible example!\r\n\r\n1. The error happens in a recursive CTE when it it used to create a table and queried at the same time. Nothing to do with the \"virtual computed table\" implementation in OP (can update the description)\r\n2. I was able to work around the error by splitting the multi-statement query into individual statements in my wrapper function:\r\n```\r\nimport pandas as pd\r\nimport duckdb\r\n\r\nget_data = lambda start, N=10: pd.DataFrame({'a':range(N), 'b':[f'{i+1}' for i in range(start, start+N)]})\r\n\r\ntab1 = get_data(65)\r\ntab2 = get_data(66)\r\n\r\ndb = duckdb.connect()\r\nsql = '''\r\ncreate table fixed_ids as\r\nwith recursive fanout as (\r\n    SELECT c1.a as node_id, c2.a as comp_id2,\r\n        from tab1 c1\r\n        inner JOIN tab2 c2 on c1.b = c2.b\r\n        inner JOIN tab2 c2l2 on c2.a = c2l2.a\r\n    UNION all\r\n    SELECT fo.comp_id2 as node_id, c2l1.b as comp_id2\r\n        FROM tab1 c1 inner JOIN fanout fo ON fo.comp_id2 = c1.a\r\n        inner JOIN tab2 c2l1 on c1.b = c2l1.b\r\n)\r\nSELECT node_id, first(comp_id2)::uint64 as fixed_id from fanout group by node_id;\r\n\r\nSELECT * from fixed_ids\r\n'''\r\nif 0: # Enable to run sql statement-by-statement to workaround https://github.com/duckdb/duckdb/issues/13863\r\n    stmts = db.extract_statements(sql)\r\n    for stmt in stmts[:-1]:\r\n        db.execute(stmt.query)\r\n    sql = stmts[-1].query\r\nprint(db.execute(sql).df())\r\n\r\n```\r\n\nThanks for the reproduction!\r\nEspecially the detail that multiple statements are run with a single `.execute` call will be helpful and gives me a good idea of where to search for the issue \ud83d\udc4d ",
  "created_at": "2024-09-12T08:27:14Z"
}