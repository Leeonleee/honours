{
  "repo": "duckdb/duckdb",
  "pull_number": 4654,
  "instance_id": "duckdb__duckdb-4654",
  "issue_numbers": [
    "4055"
  ],
  "base_commit": "70b2c7359ae7dfeb32d0780affe5e935f1aeb7e2",
  "patch": "diff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\nindex 6b619c760a19..7995e4fbf42a 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\n@@ -115,7 +115,7 @@ public static int type_to_int(DuckDBColumnType type) throws SQLException {\n \t\tcase TIMESTAMP_NS:\n \t\t\treturn Types.TIMESTAMP;\n \t\tcase TIMESTAMP_WITH_TIME_ZONE:\n-\t\t\treturn Types.TIME_WITH_TIMEZONE;\n+\t\t\treturn Types.TIMESTAMP_WITH_TIMEZONE;\n \t\tcase INTERVAL:\n \t\t\treturn Types.JAVA_OBJECT;\n \t\tcase BLOB:\n@@ -157,7 +157,7 @@ public String getColumnClassName(int column) throws SQLException {\n \t\t\treturn Date.class.toString();\n \t\tcase Types.TIMESTAMP:\n \t\t\treturn Timestamp.class.toString();\n-\t\tcase Types.TIME_WITH_TIMEZONE:\n+\t\tcase Types.TIMESTAMP_WITH_TIMEZONE:\n \t\t\treturn OffsetDateTime.class.toString();\n \t\tcase Types.BLOB:\n \t\t\treturn DuckDBBlobResult.class.toString();\n",
  "test_patch": "diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex 6ed34a298a27..6d0cc85f2d7c 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -427,7 +427,7 @@ public static void test_timestamp_tz() throws Exception {\n \t\tassertTrue(((OffsetDateTime) rs.getObject(2)).isEqual(odt2Rounded));\n \n \t\t// Metadata tests\n-\t\tassertEquals(Types.TIME_WITH_TIMEZONE,\n+\t\tassertEquals(Types.TIMESTAMP_WITH_TIMEZONE,\n \t\t\t\t((DuckDBResultSetMetaData) meta).type_to_int(DuckDBColumnType.TIMESTAMP_WITH_TIME_ZONE));\n \t\tassertTrue(OffsetDateTime.class.toString().equals(meta.getColumnClassName(2)));\n \n",
  "problem_statement": "strptime uses wrong timezone\n#### What happens?\r\nI am converting a user input to a epoch value like this:\r\n\r\nSELECT date_part('epoch', strptime('2022-06-06 00:00 +0200', '%Y-%m-%d %H:%M  %z'))*1000;\r\n\r\nI would expect +0200 to be the offset from UTC and return:\r\n\r\nGMT: Sunday 5. June 2022 22:00:00\r\n6. june 2022 kl. 00:00:00 [GMT+02:00]DST\r\n\r\nBut it returns:\r\n\r\nGMT: Monday 6. June 2022 00:00:00\r\nWhich is\r\n6. june 2022 kl. 02:00:00 [GMT+02:00]DST\r\n\r\nThis is not an issue in 0.3.2 and 0.3.3. Only in 0.4.0.\r\n\r\n#### To Reproduce\r\nJust use SELECT date_part('epoch', strptime('2022-06-06 00:00 +0400', '%Y-%m-%d %H:%M  %z'))*1000;\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Windows\r\n - DuckDB Version: 0.4.0\r\n - DuckDB Client: DBeaver and java jdbc\r\n\r\n#### Identity Disclosure:\r\n - Full Name: Kim Madsen\r\n - Affiliation: Ramboll\r\n\n",
  "hints_text": "Hi @kiliconsult - I'm a bit confused here. `DATE_PART('epoch', ...)` returns a number not a timestamp?\nWhen I try this query on head:\r\n\r\n```sql\r\nselect strptime('2022-06-06 00:00 +0200', '%Y-%m-%d %H:%M %z');\r\n```\r\nI get `2022-06-05 22:00:00+00`, which is what I would expect (an instant at the corresponding time in GMT).\nHi @hawkfish \r\n\r\n> Hi @kiliconsult - I'm a bit confused here. `DATE_PART('epoch', ...)` returns a number not a timestamp?\r\nYeah. I converted the epoch to something readable\r\n\r\nDBeaver actully gives me an exception when I run a select on strptime directly.\r\n\r\n![image](https://user-images.githubusercontent.com/46249372/177936505-e1e5e4b6-18fb-4d02-8104-1e2aedea2996.png)\r\n\r\n\r\nBut it allows me run it when wrapped in date_part.\r\n![image](https://user-images.githubusercontent.com/46249372/177936691-ac5b8dd3-d5a9-4618-8bbf-754661295bf6.png)\r\n\r\n\nSounds like DBeaver isn't binding to our `TIMESTAMP` type correctly. If you are returning the epoch, be aware that it is an integral number of seconds and will lose fractional parts.  And it will be seconds since `1970-01-01 00:00:00+00`.\nWhen you wrap the call in `date_part`, the result of `strptime` is now handled internally by DuckDB and the result is an integer, which DBeaver seems to handle. I would say this is a DBeaver bug.\nOr possibly a DuckDB JDBC issue? I think we've had some issues with binding `TIMESTAMP` results.",
  "created_at": "2022-09-08T11:45:15Z"
}