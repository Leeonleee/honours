{
  "repo": "duckdb/duckdb",
  "pull_number": 15724,
  "instance_id": "duckdb__duckdb-15724",
  "issue_numbers": [
    "15659",
    "15659"
  ],
  "base_commit": "677a8e7cd679f89748f8e05b668c7496255d5430",
  "patch": "diff --git a/src/include/duckdb/planner/expression/bound_parameter_data.hpp b/src/include/duckdb/planner/expression/bound_parameter_data.hpp\nindex 181751c1e58a..0467e37c54de 100644\n--- a/src/include/duckdb/planner/expression/bound_parameter_data.hpp\n+++ b/src/include/duckdb/planner/expression/bound_parameter_data.hpp\n@@ -17,7 +17,7 @@ struct BoundParameterData {\n public:\n \tBoundParameterData() {\n \t}\n-\texplicit BoundParameterData(Value val) : value(std::move(val)), return_type(value.type()) {\n+\texplicit BoundParameterData(Value val) : value(std::move(val)), return_type(GetDefaultType(value.type())) {\n \t}\n \tBoundParameterData(Value val, LogicalType type_p) : value(std::move(val)), return_type(std::move(type_p)) {\n \t}\n@@ -39,6 +39,14 @@ struct BoundParameterData {\n \n \tvoid Serialize(Serializer &serializer) const;\n \tstatic shared_ptr<BoundParameterData> Deserialize(Deserializer &deserializer);\n+\n+private:\n+\tLogicalType GetDefaultType(const LogicalType &type) {\n+\t\tif (value.type().id() == LogicalTypeId::VARCHAR && StringType::GetCollation(type).empty()) {\n+\t\t\treturn LogicalTypeId::STRING_LITERAL;\n+\t\t}\n+\t\treturn value.type();\n+\t}\n };\n \n } // namespace duckdb\ndiff --git a/src/planner/binder/expression/bind_comparison_expression.cpp b/src/planner/binder/expression/bind_comparison_expression.cpp\nindex cd490f4333c0..525dd3c620f1 100644\n--- a/src/planner/binder/expression/bind_comparison_expression.cpp\n+++ b/src/planner/binder/expression/bind_comparison_expression.cpp\n@@ -28,6 +28,7 @@ void ExpressionBinder::TestCollation(ClientContext &context, const string &colla\n \n static bool SwitchVarcharComparison(const LogicalType &type) {\n \tswitch (type.id()) {\n+\tcase LogicalTypeId::BOOLEAN:\n \tcase LogicalTypeId::TINYINT:\n \tcase LogicalTypeId::SMALLINT:\n \tcase LogicalTypeId::INTEGER:\ndiff --git a/src/planner/binder/statement/bind_execute.cpp b/src/planner/binder/statement/bind_execute.cpp\nindex 3e3af4d6ab76..86799dc9514c 100644\n--- a/src/planner/binder/statement/bind_execute.cpp\n+++ b/src/planner/binder/statement/bind_execute.cpp\n@@ -54,7 +54,8 @@ BoundStatement Binder::Bind(ExecuteStatement &stmt) {\n \t\t\tparameter_data = BoundParameterData(std::move(constant.value), std::move(return_type));\n \t\t} else {\n \t\t\tauto value = ExpressionExecutor::EvaluateScalar(context, *bound_expr, true);\n-\t\t\tparameter_data = BoundParameterData(std::move(value));\n+\t\t\tauto value_type = value.type();\n+\t\t\tparameter_data = BoundParameterData(std::move(value), std::move(value_type));\n \t\t}\n \t\tbind_values[pair.first] = std::move(parameter_data);\n \t}\n",
  "test_patch": "diff --git a/test/sql/cast/boolean_autocast.test b/test/sql/cast/boolean_autocast.test\nindex e26c1c1f1523..ac18988e325b 100644\n--- a/test/sql/cast/boolean_autocast.test\n+++ b/test/sql/cast/boolean_autocast.test\n@@ -52,6 +52,11 @@ SELECT true='1';\n ----\n true\n \n+query T\n+SELECT true='1'::VARCHAR;\n+----\n+true\n+\n query T\n SELECT true='0';\n ----\ndiff --git a/test/sql/collate/collate_filter_pushdown.test b/test/sql/collate/collate_filter_pushdown.test\nindex 19a4e599a701..732915a7b865 100644\n--- a/test/sql/collate/collate_filter_pushdown.test\n+++ b/test/sql/collate/collate_filter_pushdown.test\n@@ -20,4 +20,4 @@ insert into t63(c0) values ('1');\n query I\n SELECT t63.c0 FROM t0 NATURAL LEFT JOIN t63;\n ----\n-NULL\n+1\ndiff --git a/tools/pythonpkg/tests/fast/test_parameter_list.py b/tools/pythonpkg/tests/fast/test_parameter_list.py\nindex 6db0325c42be..032b1b9c875a 100644\n--- a/tools/pythonpkg/tests/fast/test_parameter_list.py\n+++ b/tools/pythonpkg/tests/fast/test_parameter_list.py\n@@ -28,3 +28,18 @@ def test_explicit_nan_param(self):\n         con = duckdb.default_connection()\n         res = con.execute('select isnan(cast(? as double))', (float(\"nan\"),))\n         assert res.fetchone()[0] == True\n+\n+    def test_string_parameter(self, duckdb_cursor):\n+        conn = duckdb.connect()\n+        conn.execute(\"create table orders (o_orderdate date)\")\n+        conn.execute(\"insert into orders values (date '1992-01-01'), (date '1994-01-01')\")\n+        conn.execute(\n+            \"\"\"\n+            SELECT COUNT(*)\n+            FROM ORDERS\n+            WHERE O_ORDERDATE BETWEEN ? AND ?\n+            \"\"\",\n+            [\"1994-01-01\", \"1996-01-01\"],\n+        )\n+        res = conn.fetchall()\n+        assert res == [(1,)]\n",
  "problem_statement": "Regression in parameterized BETWEEN clause in 1.1\n### What happens?\n\nIt appears that duckdb 1.1 requires explicitly casting parameters to a BETWEEN clause when it did not previously, and which it does not require if the parameters are specified (still as strings) withinin the query instead of as parameters. I could not find any mention of this change in the \"Breaking SQL Changes\" section of the [1.1 release post](https://duckdb.org/2024/09/09/announcing-duckdb-110.html#breaking-sql-changes) or elsewhere.\n\n### To Reproduce\n\n```python\r\nimport duckdb\r\n\r\nwith duckdb.connect() as conn:\r\n    conn.execute(\"CALL dbgen(sf = 0.1);\")\r\n    print(\r\n        conn.execute(\r\n            \"\"\"\r\n            SELECT COUNT(*)\r\n            FROM ORDERS\r\n            WHERE O_ORDERDATE BETWEEN ? AND ?\r\n            \"\"\",\r\n            [\"1994-01-01\", \"1996-01-01\"],\r\n        ).fetchone()\r\n    )\r\n```\r\n\r\nOn duckdb 1.0 the query executes correctly, but on 1.1 it raises\r\n\r\n```\r\nBinderException: Binder Error: Cannot mix values of type DATE and VARCHAR in BETWEEN clause - an explicit cast is required\r\nLINE 4:             WHERE O_ORDERDATE BETWEEN ? AND ?\r\n```\r\n\r\nAnd strangely the query works on 1.1 if you inline the parameters but still specify them as strings, i.e.\r\n\r\n```\r\nSELECT COUNT(*)\r\nFROM ORDERS\r\nWHERE O_ORDERDATE BETWEEN '1994-01-01' AND '1996-01-01'\r\n```\n\n### OS:\n\nmacOS, Linux\n\n### DuckDB Version:\n\n1.1.3\n\n### DuckDB Client:\n\nPython, Java\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nDylan Scott\n\n### Affiliation:\n\nHex Technologies\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\nRegression in parameterized BETWEEN clause in 1.1\n### What happens?\n\nIt appears that duckdb 1.1 requires explicitly casting parameters to a BETWEEN clause when it did not previously, and which it does not require if the parameters are specified (still as strings) withinin the query instead of as parameters. I could not find any mention of this change in the \"Breaking SQL Changes\" section of the [1.1 release post](https://duckdb.org/2024/09/09/announcing-duckdb-110.html#breaking-sql-changes) or elsewhere.\n\n### To Reproduce\n\n```python\r\nimport duckdb\r\n\r\nwith duckdb.connect() as conn:\r\n    conn.execute(\"CALL dbgen(sf = 0.1);\")\r\n    print(\r\n        conn.execute(\r\n            \"\"\"\r\n            SELECT COUNT(*)\r\n            FROM ORDERS\r\n            WHERE O_ORDERDATE BETWEEN ? AND ?\r\n            \"\"\",\r\n            [\"1994-01-01\", \"1996-01-01\"],\r\n        ).fetchone()\r\n    )\r\n```\r\n\r\nOn duckdb 1.0 the query executes correctly, but on 1.1 it raises\r\n\r\n```\r\nBinderException: Binder Error: Cannot mix values of type DATE and VARCHAR in BETWEEN clause - an explicit cast is required\r\nLINE 4:             WHERE O_ORDERDATE BETWEEN ? AND ?\r\n```\r\n\r\nAnd strangely the query works on 1.1 if you inline the parameters but still specify them as strings, i.e.\r\n\r\n```\r\nSELECT COUNT(*)\r\nFROM ORDERS\r\nWHERE O_ORDERDATE BETWEEN '1994-01-01' AND '1996-01-01'\r\n```\n\n### OS:\n\nmacOS, Linux\n\n### DuckDB Version:\n\n1.1.3\n\n### DuckDB Client:\n\nPython, Java\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nDylan Scott\n\n### Affiliation:\n\nHex Technologies\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2025-01-15T11:55:48Z"
}