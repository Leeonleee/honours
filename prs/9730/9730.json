{
  "repo": "duckdb/duckdb",
  "pull_number": 9730,
  "instance_id": "duckdb__duckdb-9730",
  "issue_numbers": [
    "6576"
  ],
  "base_commit": "a1e01c3e3e21aa1487492b84c2fe43c67f036b9b",
  "patch": "diff --git a/src/planner/binder/statement/bind_insert.cpp b/src/planner/binder/statement/bind_insert.cpp\nindex 599b23aa9b6c..3a42dc6851be 100644\n--- a/src/planner/binder/statement/bind_insert.cpp\n+++ b/src/planner/binder/statement/bind_insert.cpp\n@@ -269,12 +269,13 @@ void Binder::BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &tabl\n \t\tif (!found_matching_indexes) {\n \t\t\tthrow BinderException(\n \t\t\t    \"There are no UNIQUE/PRIMARY KEY Indexes that refer to this table, ON CONFLICT is a no-op\");\n-\t\t}\n-\t\tif (insert.action_type != OnConflictAction::NOTHING && found_matching_indexes != 1) {\n-\t\t\t// When no conflict target is provided, and the action type is UPDATE,\n-\t\t\t// we only allow the operation when only a single Index exists\n-\t\t\tthrow BinderException(\"Conflict target has to be provided for a DO UPDATE operation when the table has \"\n-\t\t\t                      \"multiple UNIQUE/PRIMARY KEY constraints\");\n+\t\t} else if (storage_info.index_info.size() != 1) {\n+\t\t\tif (insert.action_type != OnConflictAction::NOTHING) {\n+\t\t\t\t// When no conflict target is provided, and the action type is UPDATE,\n+\t\t\t\t// we only allow the operation when only a single Index exists\n+\t\t\t\tthrow BinderException(\"Conflict target has to be provided for a DO UPDATE operation when the table has \"\n+\t\t\t\t                      \"multiple UNIQUE/PRIMARY KEY constraints\");\n+\t\t\t}\n \t\t}\n \t}\n \n",
  "test_patch": "diff --git a/test/sql/upsert/insert_or_replace_ambiguity.test b/test/sql/upsert/insert_or_replace_ambiguity.test\nnew file mode 100644\nindex 000000000000..0e25f4ec3c41\n--- /dev/null\n+++ b/test/sql/upsert/insert_or_replace_ambiguity.test\n@@ -0,0 +1,84 @@\n+# name: test/sql/upsert/insert_or_replace_ambiguity.test\n+# group: [upsert]\n+\n+# Single primary key on multiple columns\n+statement ok\n+create table single_pk(\n+\ta int,\n+\tb int,\n+\tc int,\n+\tprimary key(a,b,c)\n+);\n+\n+statement ok\n+insert or replace into single_pk values (1,2,3);\n+\n+statement ok\n+insert or replace into single_pk values (1,2,3);\n+\n+query III\n+select * from single_pk;\n+----\n+1\t2\t3\n+\n+# Single UNIQUE INDEX\n+statement ok\n+create table using_index(\n+\ta int,\n+\tb int,\n+\tc int\n+);\n+\n+statement ok\n+create UNIQUE index idx2 on using_index(a, b);\n+\n+statement ok\n+insert or replace into using_index values (1,2,3);\n+\n+statement ok\n+insert or replace into using_index values (1,2,3);\n+\n+query III\n+select * from using_index;\n+----\n+1\t2\t3\n+\n+# Multiple UNIQUE INDEXes\n+statement ok\n+create unique index idx3 on using_index(b, c);\n+\n+statement error\n+insert or replace into using_index values (1,2,3);\n+----\n+Binder Error: Conflict target has to be provided for a DO UPDATE operation when the table has multiple UNIQUE/PRIMARY KEY constraints\n+\n+# Single UNIQUE CONSTRAINT\n+statement ok\n+create table single_unique(\n+\ta int unique,\n+\tb int\n+);\n+\n+statement ok\n+insert or replace into single_unique values(1, 2);\n+\n+statement ok\n+insert or replace into single_unique values(1, 2);\n+\n+query II\n+select * from single_unique;\n+----\n+1\t2\n+\n+# Multiple UNIQUE CONSTRAINTs\n+statement ok\n+create table multiple_unique(\n+\ta int unique,\n+\tb int unique,\n+\tc int\n+);\n+\n+statement error\n+insert or replace into multiple_unique values(1, 2, 3);\n+----\n+Binder Error: Conflict target has to be provided for a DO UPDATE operation when the table has multiple UNIQUE/PRIMARY KEY constraints\n",
  "problem_statement": "Conflict target required when table has multiple primary key columns\n### What happens?\n\n`insert or replace` on a table with multiple primary keys requires a conflict_target. However the [docs](https://duckdb.org/docs/sql/statements/insert#on-conflict-clause) state it's optional and *all* keys will be targeted when there's no conflict_target:\r\n\r\n> Optionally you can provide a conflict_target, which is a group of columns that an Index indexes on, or if left out, all UNIQUE or PRIMARY KEY constraint(s) on the table are targeted.\n\n### To Reproduce\n\nWithout a conflict target,\r\n```\r\nD create table foo(a int, b int, c int, d int, primary key(a,b,c));\r\nD insert or replace into foo values (1,2,3,4);\r\nError: Binder Error: Conflict target has to be provided for a DO UPDATE operation when the table has multiple UNIQUE/PRIMARY KEY constraints\r\n```\r\n\r\nOnly works with a conflict target, eg:\r\n```\r\nD insert into foo values (1,2,3,4) on conflict(a,b,c) do update set d=4;\r\n```\n\n### OS:\n\nmacos\n\n### DuckDB Version:\n\nv0.7.1 b00b93f0b1\n\n### DuckDB Client:\n\ncli\n\n### Full Name:\n\nOliver Mannion\n\n### Affiliation:\n\nXero\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Hey thanks for raising the issue, we need to update the docs!\r\n\r\nThe reason this is not supported for DO UPDATE is because:\r\n> Not supported because:\r\nIt's because one insert row could violate multiple different unique constraints,\r\nwith it being a different row for each of the constraints that's causing the violation,\r\nand the upsert is only intended to update a single row.\r\n\r\n[from here](https://sqlite.org/forum/info/45cf84d3e89d590d)\r\nWhen there is only one unique/primary key constraint, we have opted to allow this because it doesn't cause this issue\nCan be closed once we merge https://github.com/duckdb/duckdb-web/pull/791\nClosed by https://github.com/duckdb/duckdb-web/pull/791 \nJust ran in to this and I'm not sure I agree with this statement for a table having a _single_ multi-column (composite) index (which is what @tekumara, the poster on sqlite.org, and myself all have):\r\n\r\n> It's because one insert row could violate multiple different unique constraints,\r\n\r\nFor _multiple_ unique constraints I completely agree, but with a single multi-column unique constraint there must be _exactly_ zero or one matching rows, surely?\r\n\r\nMultiple rows might be matched by different columns which make up the composite, and again it would make sense that you couldn't update without a target if the constraints were separate, but for a composite it either matches all columns (and so you have exactly row to update) or it matches zero (and so you insert)?   \ud83e\udd14 \nJust ran into this as well when converting a self-contained analytics platform from sqlite to duckdb (I'm converting a 100 GB sqlite management system because we're still too stubborn to just use a full database server).\r\n\r\nThe composite primary key upsert worked as expected on sqlite for years, but converting the interface to duckdb broke our simple `INSERT OR REPLACE` syntax because we have `PRIMARY KEY (name, timestamp)`.\r\n\r\nA table with a single composite primary key is generating this error even though it's perfectly logical to just use \"INSERT OR REPLACE\" because the index is defined to be singular and unique. \ud83e\udd37\u200d\u2642\ufe0f",
  "created_at": "2023-11-20T11:26:43Z"
}