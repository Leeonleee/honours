{
  "repo": "duckdb/duckdb",
  "pull_number": 14395,
  "instance_id": "duckdb__duckdb-14395",
  "issue_numbers": [
    "14386"
  ],
  "base_commit": "4756244efa04d204be6f20d55036fc503b7ed49c",
  "patch": "diff --git a/src/function/table/arrow_conversion.cpp b/src/function/table/arrow_conversion.cpp\nindex 827479f6f8d7..1b329b0f4b91 100644\n--- a/src/function/table/arrow_conversion.cpp\n+++ b/src/function/table/arrow_conversion.cpp\n@@ -765,14 +765,12 @@ static void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowArraySca\n \tcase LogicalTypeId::BOOLEAN: {\n \t\t//! Arrow bit-packs boolean values\n \t\t//! Lets first figure out where we are in the source array\n-\t\tauto src_ptr = ArrowBufferData<uint8_t>(array, 1) +\n-\t\t               GetEffectiveOffset(array, NumericCast<int64_t>(parent_offset), scan_state, nested_offset) / 8;\n+\t\tauto effective_offset =\n+\t\t    GetEffectiveOffset(array, NumericCast<int64_t>(parent_offset), scan_state, nested_offset);\n+\t\tauto src_ptr = ArrowBufferData<uint8_t>(array, 1) + effective_offset / 8;\n \t\tauto tgt_ptr = (uint8_t *)FlatVector::GetData(vector);\n \t\tint src_pos = 0;\n-\t\tidx_t cur_bit = scan_state.chunk_offset % 8;\n-\t\tif (nested_offset != -1) {\n-\t\t\tcur_bit = NumericCast<idx_t>(nested_offset % 8);\n-\t\t}\n+\t\tidx_t cur_bit = effective_offset % 8;\n \t\tfor (idx_t row = 0; row < size; row++) {\n \t\t\tif ((src_ptr[src_pos] & (1 << cur_bit)) == 0) {\n \t\t\t\ttgt_ptr[row] = 0;\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/arrow/test_arrow_offsets.py b/tools/pythonpkg/tests/fast/arrow/test_arrow_offsets.py\nindex fe34a7e1c06a..782a68042561 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_arrow_offsets.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_arrow_offsets.py\n@@ -671,3 +671,17 @@ def test_struct_of_list(self, duckdb_cursor, col1_null):\n             assert res[0] == None\n         else:\n             assert res[0]['a'][-1] == '131072'\n+\n+    def test_bools_with_offset(self, duckdb_cursor):\n+        bools = [False, False, False, False, True, False, False, False, False, False]\n+        bool_array = pa.array(bools, type=pa.bool_())\n+\n+        # Create schema using the same fields as the C++ version\n+        schema = pa.schema([pa.field(\"bools\", pa.bool_())])\n+\n+        # Create a RecordBatch with the arrays\n+        record_batch = pa.RecordBatch.from_arrays([bool_array], schema=schema)\n+\n+        temp_record = record_batch.slice(4, 1)\n+        res = duckdb_cursor.sql(\"select bools from temp_record\").fetchall()\n+        assert res == [(True,)]\n",
  "problem_statement": "DuckDb does not insert arrow correctly if the record batch has been sliced\n### What happens?\r\n\r\nIf a record batch is created from slicing a different record batch it seems that boolean columns are not created correctly in duckdb. I have made a simple test where we upload a record batch into duck db as table \"__record_batch__\" then we can query \r\n```\r\n\"select * from __record_batch__\";\r\n```\r\nYou would expect the record batch returned to be equal to the record batch put in. However, this is not always true.  have noticed if the record batch was created by calling \"slice\" that the booelean columns seem to be in-accurate. If i do a deep copy of the record batch before putting into the db it is accurate.\r\n\r\n### To Reproduce\r\n\r\n```\r\n#include <cstdlib>\r\n#include <arrow/api.h>\r\n#include <arrow/io/api.h>\r\n#include <arrow/ipc/api.h>\r\n#include <arrow/c/bridge.h>\r\n#include <adbc.h>\r\n#include <iostream>\r\nstd::string kDuckDbDriver = \"/home/path_to/libduckdb.so\";\r\n\r\n#define CHECK_ARROW_FATAL(EXPR)                      \\\r\n  if (arrow::Status status = (EXPR); !status.ok()) { \\\r\n    std::cout << status.ToString() <<std::endl;       \\\r\n    exit(1);                                         \\\r\n  }\r\n\r\n#define CHECK_ADBC_FATAL(EXPR)                                    \\\r\n  if (AdbcStatusCode status = (EXPR); status != ADBC_STATUS_OK) { \\\r\n    std::cout <<                          \\\r\n        \"AdbcStatusCode \" <<(int)status << \" \"<<(error.message ? error.message : \"\"); \\\r\n  }\r\n\r\n\r\n\r\nclass ReadOneBatchReader : public arrow::RecordBatchReader {\r\n public:\r\n  ReadOneBatchReader(const std::shared_ptr<arrow::RecordBatch>& batch) : batch_(batch) {}\r\n  virtual arrow::Status ReadNext(std::shared_ptr<arrow::RecordBatch>* batch) override {\r\n    if (already_read) {\r\n      *batch = nullptr;\r\n      return arrow::Status::OK();\r\n    }\r\n    *batch = batch_;\r\n    already_read = true;\r\n    return arrow::Status::OK();\r\n  }\r\n  std::shared_ptr<arrow::Schema> schema() const override { return batch_->schema(); }\r\n\r\n private:\r\n  std::shared_ptr<arrow::RecordBatch> batch_;\r\n  bool already_read = false;\r\n};\r\n\r\narrow::Result<std::shared_ptr<arrow::RecordBatchReader>> Query(std::shared_ptr<arrow::RecordBatch>& batch, AdbcConnection connection) noexcept {\r\n  std::string query = \"select * from __record_batch__\";\r\n  ArrowArrayStream array;\r\n  auto status =\r\n      arrow::ExportRecordBatchReader(std::make_shared<ReadOneBatchReader>(batch), &array);\r\n  if (!status.ok()) {\r\n    return status;\r\n  }\r\n  auto clean = [array_ptr = &array, &connection]() {\r\n    AdbcStatement statement = {};\r\n    AdbcError error = {};\r\n    CHECK_ADBC_FATAL(AdbcStatementNew(&connection, &statement, &error));\r\n    CHECK_ADBC_FATAL(AdbcStatementSetSqlQuery(\r\n        &statement, \"drop table __record_batch__\", &error));\r\n    CHECK_ADBC_FATAL(AdbcStatementExecuteQuery(&statement, nullptr, nullptr, &error));\r\n    CHECK_ADBC_FATAL(AdbcStatementRelease(&statement, &error));\r\n    if (array_ptr->release) {\r\n      array_ptr->release(array_ptr);\r\n    }\r\n  };\r\n  AdbcError error = {};\r\n  AdbcStatement statement = {};\r\n  CHECK_ADBC_FATAL(AdbcStatementNew(&connection, &statement, &error));\r\n  CHECK_ADBC_FATAL(AdbcStatementSetOption(\r\n      &statement, ADBC_INGEST_OPTION_TARGET_TABLE, \"__record_batch__\", &error));\r\n  CHECK_ADBC_FATAL(AdbcStatementBindStream(&statement, &array, &error));\r\n  CHECK_ADBC_FATAL(AdbcStatementExecuteQuery(&statement, nullptr, nullptr, &error));\r\n  CHECK_ADBC_FATAL(AdbcStatementRelease(&statement, &error));\r\n\r\n  statement = {};\r\n  CHECK_ADBC_FATAL(AdbcStatementNew(&connection, &statement, &error));\r\n  auto adbc_status = AdbcStatementSetSqlQuery(&statement, query.c_str(), &error);\r\n  if (adbc_status != ADBC_STATUS_OK) {\r\n    clean();\r\n    return arrow::Status::UnknownError(error.message ? error.message : \"\");\r\n  }\r\n  ArrowArrayStream array_result;\r\n  int64_t rows_affected;\r\n  adbc_status =\r\n      AdbcStatementExecuteQuery(&statement, &array_result, &rows_affected, &error);\r\n  if (adbc_status != ADBC_STATUS_OK) {\r\n    clean();\r\n    AdbcStatementRelease(&statement, &error);\r\n    return arrow::Status::UnknownError(error.message ? error.message : \"\");\r\n  }\r\n  CHECK_ADBC_FATAL(AdbcStatementRelease(&statement, &error));\r\n  auto reader_result = arrow::ImportRecordBatchReader(&array_result);\r\n  clean();\r\n  return reader_result;\r\n}\r\n\r\nint main() {\r\n    arrow::MemoryPool* pool = arrow::default_memory_pool();\r\n\r\n    // Create Builders for each column\r\n    arrow::StringBuilder date_builder(pool);\r\n    arrow::Int64Builder time_builder(pool);\r\n    arrow::DictionaryBuilder<arrow::StringType> source_builder(pool);\r\n    arrow::Int32Builder channel_builder(pool);\r\n    arrow::DictionaryBuilder<arrow::StringType> b_symbol_builder(pool);\r\n    arrow::DictionaryBuilder<arrow::StringType> symbol_builder(pool);\r\n    arrow::DictionaryBuilder<arrow::StringType> prime_symbol_builder(pool);\r\n    arrow::Int64Builder event_id_builder(pool);\r\n    arrow::BooleanBuilder bool_0_builder(pool);\r\n    arrow::BooleanBuilder bool_1_builder(pool);\r\n    arrow::BooleanBuilder is_string_builder(pool);\r\n    arrow::Int64Builder id_builder(pool);\r\n    arrow::Int32Builder qty_builder(pool);\r\n    arrow::Int32Builder b_total_qty_builder(pool);\r\n    arrow::DoubleBuilder price_builder(pool);\r\n    arrow::Int32Builder qty_3_builder(pool);\r\n    arrow::BooleanBuilder bool4_builder(pool);\r\n    arrow::BooleanBuilder is_stop_builder(pool);\r\n\r\n    // Populate with the example data\r\n    std::vector<std::string> dates = {\"2024-10-14\", \"2024-10-14\", \"2024-10-14\", \"2024-10-14\", \"2024-10-14\", \r\n                                            \"2024-10-14\", \"2024-10-14\", \"2024-10-14\", \"2024-10-14\", \"2024-10-14\"};\r\n    std::vector<int64_t> times = {1728856800040503141, 1728856800040503141, 1728856800040503141, 1728856800052961261, \r\n                                  1728856800055141669, 1728856800063910245, 1728856800074775351, 1728856800080599547, \r\n                                  1728856800086024633, 1728856800097860063};\r\n    std::vector<std::string> sources = {\"SOURCE\", \"SOURCE\", \"SOURCE\", \"SOURCE\", \"SOURCE\", \r\n                                             \"SOURCE\", \"SOURCE\", \"SOURCE\", \"SOURCE\", \"SOURCE\"};\r\n    std::vector<int32_t> channels = {207, 207, 207, 207, 207, 207, 207, 207, 207, 207};\r\n    std::vector<std::string> b_symbols = {\"symbol\", \"symbol\", \"symbol\", \"symbol\", \"symbol\", \r\n                                                  \"symbol\", \"symbol\", \"symbol\", \"symbol\", \"symbol\"};\r\n    std::vector<std::string> symbols = {\"symbol\", \"symbol\", \"symbol\", \"symbol\", \"symbol\", \r\n                                        \"symbol\", \"symbol\", \"symbol\", \"symbol\", \"symbol\"};\r\n    std::vector<std::string> prime_symbols = {\"STRING@0\", \"STRING@0\", \"STRING@0\", \"STRING@0\", \"STRING@0\", \r\n                                              \"STRING@0\", \"STRING@0\", \"STRING@0\", \"STRING@0\", \"STRING@0\"};\r\n    std::vector<int64_t> event_ids = {733, 733, 733, 755, 793, 803, 810, 815, 818, 825};\r\n    std::vector<bool> bool_0s = {false, false, false, true, true, true, true, false, false, true};\r\n    std::vector<bool> bool_1 = {false, false, false, false, false, false, false, false, false, false};\r\n    std::vector<bool> is_string = {false, false, false, false, false, false, false, false, false, false};\r\n    std::vector<int64_t> ids = {6413949158507, 6413949158507, 6413949158507, 6413949158776, \r\n                                      6413949158812, 6413949158817, 6413949158821, 6413949158825, \r\n                                      6413949158826, 6413949158833};\r\n    std::vector<int32_t> qtys = {1, 3, 4, 1, 1, 2, 1, 1, 1, 1};\r\n    std::vector<int32_t> qty_2 = {8, 8, 8, 1, 1, 2, 1, 1, 1, 1};\r\n    std::vector<double> prices = {585450.0, 585475.0, 585500.0, 585425.0, 585425.0, \r\n                                  585425.0, 585425.0, 585450.0, 585450.0, 585425.0};\r\n    std::vector<int32_t> qty_3s = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\r\n    std::vector<bool> bool4 = {true, true, true, false, false, false, false, false, false, false};\r\n    std::vector<bool> is_stop = {false, false, false, false, false, false, false, false, false, false};\r\n\r\n    // Insert values into builders\r\n    for (size_t i = 0; i < dates.size(); ++i) {\r\n        (void)date_builder.Append(dates[i]);\r\n        (void)time_builder.Append(times[i]);\r\n        (void)source_builder.Append(sources[i]);\r\n        (void)channel_builder.Append(channels[i]);\r\n        (void)b_symbol_builder.Append(b_symbols[i]);\r\n        (void)symbol_builder.Append(symbols[i]);\r\n        (void)prime_symbol_builder.Append(prime_symbols[i]);\r\n        (void)event_id_builder.Append(event_ids[i]);\r\n        (void)bool_0_builder.Append(bool_0s[i]);\r\n        (void)bool_1_builder.Append(bool_1[i]);\r\n        (void)is_string_builder.Append(is_string[i]);\r\n        (void)id_builder.Append(ids[i]);\r\n        (void)qty_builder.Append(qtys[i]);\r\n        (void)b_total_qty_builder.Append(qty_2[i]);\r\n        (void)price_builder.Append(prices[i]);\r\n        (void)qty_3_builder.Append(qty_3s[i]);\r\n        (void)bool4_builder.Append(bool4[i]);\r\n        (void)is_stop_builder.Append(is_stop[i]);\r\n    }\r\n\r\n    // Finish builders to create Arrays\r\n    std::shared_ptr<arrow::Array> date_array;\r\n    std::shared_ptr<arrow::Array> time_array;\r\n    std::shared_ptr<arrow::Array> source_array;\r\n    std::shared_ptr<arrow::Array> channel_array;\r\n    std::shared_ptr<arrow::Array> b_symbol_array;\r\n    std::shared_ptr<arrow::Array> symbol_array;\r\n    std::shared_ptr<arrow::Array> prime_symbol_array;\r\n    std::shared_ptr<arrow::Array> event_id_array;\r\n    std::shared_ptr<arrow::Array> bool_0_array;\r\n    std::shared_ptr<arrow::Array> bool_1_array;\r\n    std::shared_ptr<arrow::Array> is_string_array;\r\n    std::shared_ptr<arrow::Array> id_array;\r\n    std::shared_ptr<arrow::Array> qty_array;\r\n    std::shared_ptr<arrow::Array> b_total_qty_array;\r\n    std::shared_ptr<arrow::Array> price_array;\r\n    std::shared_ptr<arrow::Array> qty_3_array;\r\n    std::shared_ptr<arrow::Array> bool4_array;\r\n    std::shared_ptr<arrow::Array> is_stop_array;\r\n\r\n    (void)date_builder.Finish(&date_array);\r\n    (void)time_builder.Finish(&time_array);\r\n    (void)source_builder.Finish(&source_array);\r\n    (void)channel_builder.Finish(&channel_array);\r\n    (void)b_symbol_builder.Finish(&b_symbol_array);\r\n    (void)symbol_builder.Finish(&symbol_array);\r\n    (void)prime_symbol_builder.Finish(&prime_symbol_array);\r\n    (void)event_id_builder.Finish(&event_id_array);\r\n    (void)bool_0_builder.Finish(&bool_0_array);\r\n    (void)bool_1_builder.Finish(&bool_1_array);\r\n    (void)is_string_builder.Finish(&is_string_array);\r\n    (void)id_builder.Finish(&id_array);\r\n    (void)qty_builder.Finish(&qty_array);\r\n    (void)b_total_qty_builder.Finish(&b_total_qty_array);\r\n    (void)price_builder.Finish(&price_array);\r\n    (void)qty_3_builder.Finish(&qty_3_array);\r\n    (void)bool4_builder.Finish(&bool4_array);\r\n    (void)is_stop_builder.Finish(&is_stop_array);\r\n\r\n    // Create Schema\r\n    std::vector<std::shared_ptr<arrow::Field>> schema_fields = {\r\n        arrow::field(\"Date\", arrow::utf8()),\r\n        arrow::field(\"Time\", arrow::int64()),\r\n        arrow::field(\"Source\", arrow::dictionary(arrow::int32(), arrow::utf8())),\r\n        arrow::field(\"Channel\", arrow::int32()),\r\n        arrow::field(\"bSymbol\", arrow::dictionary(arrow::int32(), arrow::utf8())),\r\n        arrow::field(\"Symbol\", arrow::dictionary(arrow::int32(), arrow::utf8())),\r\n        arrow::field(\"PrimeSymbol\", arrow::dictionary(arrow::int32(), arrow::utf8())),\r\n        arrow::field(\"EventId\", arrow::int64()),\r\n        arrow::field(\"bool0\", arrow::boolean()),\r\n        arrow::field(\"bool1\", arrow::boolean()),\r\n        arrow::field(\"Isstring\", arrow::boolean()),\r\n        arrow::field(\"aId\", arrow::int64()),\r\n        arrow::field(\"Qty\", arrow::int32()),\r\n        arrow::field(\"bTotalQty\", arrow::int32()),\r\n        arrow::field(\"Price\", arrow::float64()),\r\n        arrow::field(\"Qty3\", arrow::int32()),\r\n        arrow::field(\"bool4\", arrow::boolean()),\r\n        arrow::field(\"IsStop\", arrow::boolean())\r\n    };\r\n\r\n    auto schema = std::make_shared<arrow::Schema>(schema_fields);\r\n\r\n    // Create RecordBatch\r\n    auto record_batch = arrow::RecordBatch::Make(schema, dates.size(),\r\n                                                 {date_array, time_array, source_array, channel_array,\r\n                                                  b_symbol_array, symbol_array, prime_symbol_array, event_id_array,\r\n                                                  bool_0_array, bool_1_array, is_string_array, id_array,\r\n                                                  qty_array, b_total_qty_array, price_array, qty_3_array,\r\n                                                  bool4_array, is_stop_array});\r\n\r\n  AdbcError error = {};\r\n  AdbcDatabase database;\r\n  assert(AdbcDatabaseNew(&database, &error) == 0);\r\n  assert(AdbcDatabaseSetOption(&database, \"driver\", kDuckDbDriver.c_str(), &error) == 0);\r\n  assert(AdbcDatabaseSetOption(&database, \"entrypoint\", \"duckdb_adbc_init\", &error) == 0);\r\n  assert(AdbcDatabaseInit(&database, &error) == 0);\r\n  AdbcConnection connection;\r\n  assert(AdbcConnectionNew(&connection, &error) == 0);\r\n  assert(AdbcConnectionInit(&connection, &database, &error) == 0);\r\n\r\n  auto temp_record = record_batch->Slice(4,1);\r\n  auto res = *(*arrow::Table::FromRecordBatchReader(((*Query(temp_record, connection)).get())))->CombineChunksToBatch();\r\n  std::cout << \"-----------------temp_record-----------------\" << std::endl;\r\n  std::cout << temp_record->ToString()<< std::endl;\r\n  std::cout << \"-----------------res-----------------\" << std::endl;\r\n  std::cout << res->ToString()<< std::endl;\r\n  assert(res->Equals(*record_batch));\r\n  return 0;\r\n}\r\n\r\n````\r\n\r\nyou will see that column `bool0` is different in `temp_record` compared to `res`\r\n\r\n### OS:\r\n\r\nrhel8\r\n\r\n### DuckDB Version:\r\n\r\n1.1.2\r\n\r\n### DuckDB Client:\r\n\r\nc++, libduckdb.so\r\n\r\n### Hardware:\r\n\r\nintel\r\n\r\n### Full Name:\r\n\r\nMaxwell Gomez\r\n\r\n### Affiliation:\r\n\r\nTrading Firm (please DM for name)\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNo - Other reason (please specify in the issue body)\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-10-16T09:21:23Z"
}