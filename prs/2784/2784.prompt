You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
PRAGMA table_info returns Data type error on node.js environment
Hello,
I tried executing PRAGMA table_info using the node.js environment and it returned a Data type error. Other commands seem to work fine.

Code used (file main.js):
```javascript
var duckdb = require('duckdb');

var db = new duckdb.Database('database.duckdb');
var con = db.connect();

var n_rows = 20;

// Create a new table
console.log('Creating table.')
con.run('CREATE TABLE a (i INTEGER, j INTEGER)');
var stmt = con.prepare('INSERT INTO a VALUES (?, ?)');
for (var i = 0; i < n_rows; i++) {
  stmt.run(i, i*10);
}
stmt.finalize();

console.log('Table created, now getting its info.')
// Iterate over the tables and get their info
con.all('PRAGMA show_tables;', function(err, res){
  if (err){
    throw err;
  }
  res.forEach(e => {
    console.log(e['name'])
    con.all(`PRAGMA table_info(${e['name']})`, function(err, res){
      if (err){
        throw err;
      }
      console.log(res);
    });
  });
})
```

Command executed:
```bash
node main.js
```

Output:
```
Creating table.
Table created, now getting its info.
a
undefined:0
Error: Data type is not supported BOOLEAN
```
PRAGMA table_info seems to work fine when the table **is not** present. But, it returns an error with a table that **is** present.
I searched the issues page but couldn't find anything related. Is this a bug (or known issue), or is it a problem somewhere on my side?

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of tools/nodejs/package.json]
1: {
2:   "name": "duckdb",
3:   "main": "./lib/duckdb.js",
4:   "version": "0.2.4",
5:   "description": "DuckDB node.js API",
6:   "gypfile": true,
7:   "dependencies": {
8:     "@mapbox/node-pre-gyp": "^1.0.0",
9:     "node-addon-api": "*",
10:     "node-gyp": "^7.1.2"
11:   },
12:   "binary": {
13:     "module_name": "duckdb",
14:     "module_path": "./lib/binding/",
15:     "host": "https://duckdb-node.s3.amazonaws.com"
16:   },
17:   "scripts": {
18:     "install": "node-pre-gyp install --fallback-to-build",
19:     "pretest": "node test/support/createdb.js",
20:     "test": "mocha -R spec --timeout 480000",
21:     "pack": "node-pre-gyp package"
22:   },
23:   "directories": {
24:     "lib": "lib",
25:     "test": "test"
26:   },
27:   "devDependencies": {
28:     "mocha": "^8.3.0",
29:     "aws-sdk": "^2.790.0"
30:   },
31:   "repository": {
32:     "type": "git",
33:     "url": "git+https://github.com/cwida/duckdb.git"
34:   },
35:   "keywords": [
36:     "database",
37:     "sql",
38:     "duckdb"
39:   ],
40:   "author": "Hannes MÃ¼hleisen",
41:   "license": "MPL-2.0",
42:   "bugs": {
43:     "url": "https://github.com/cwida/duckdb/issues"
44:   },
45:   "homepage": "https://www.duckdb.org"
46: }
[end of tools/nodejs/package.json]
[start of tools/nodejs/src/statement.cpp]
1: #include "duckdb_node.hpp"
2: 
3: namespace node_duckdb {
4: 
5: Napi::FunctionReference Statement::constructor;
6: 
7: Napi::Object Statement::Init(Napi::Env env, Napi::Object exports) {
8: 	Napi::HandleScope scope(env);
9: 
10: 	Napi::Function t =
11: 	    DefineClass(env, "Statement",
12: 	                {InstanceMethod("run", &Statement::Run), InstanceMethod("all", &Statement::All),
13: 	                 InstanceMethod("each", &Statement::Each), InstanceMethod("finalize", &Statement::Finalize_)});
14: 
15: 	constructor = Napi::Persistent(t);
16: 	constructor.SuppressDestruct();
17: 
18: 	exports.Set("Statement", t);
19: 	return exports;
20: }
21: 
22: struct PrepareTask : public Task {
23: 	PrepareTask(Statement &statement_, Napi::Function callback_) : Task(statement_, callback_) {
24: 	}
25: 
26: 	void DoWork() override {
27: 		auto &statement = Get<Statement>();
28: 		statement.statement = statement.connection_ref->connection->Prepare(statement.sql);
29: 	}
30: 
31: 	void Callback() override {
32: 		auto &statement = Get<Statement>();
33: 		auto env = statement.Env();
34: 		Napi::HandleScope scope(env);
35: 
36: 		auto cb = callback.Value();
37: 		if (!statement.statement->success) {
38: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, statement.statement->error)});
39: 			return;
40: 		}
41: 		cb.MakeCallback(statement.Value(), {env.Null(), statement.Value()});
42: 	}
43: };
44: 
45: Statement::Statement(const Napi::CallbackInfo &info) : Napi::ObjectWrap<Statement>(info) {
46: 
47: 	Napi::Env env = info.Env();
48: 	int length = info.Length();
49: 
50: 	if (length <= 0 || !Connection::HasInstance(info[0])) {
51: 		Napi::TypeError::New(env, "Connection object expected").ThrowAsJavaScriptException();
52: 		return;
53: 	} else if (length <= 1 || !info[1].IsString()) {
54: 		Napi::TypeError::New(env, "SQL query expected").ThrowAsJavaScriptException();
55: 		return;
56: 	}
57: 
58: 	connection_ref = Napi::ObjectWrap<Connection>::Unwrap(info[0].As<Napi::Object>());
59: 	connection_ref->Ref();
60: 
61: 	sql = info[1].As<Napi::String>();
62: 
63: 	Napi::Function callback;
64: 	if (info.Length() > 1 && info[2].IsFunction()) {
65: 		callback = info[2].As<Napi::Function>();
66: 	}
67: 
68: 	// TODO we can have parameters here as well. Forward if that is the case.
69: 	Value().As<Napi::Object>().DefineProperty(
70: 	    Napi::PropertyDescriptor::Value("sql", info[1].As<Napi::String>(), napi_default));
71: 	connection_ref->database_ref->Schedule(env, duckdb::make_unique<PrepareTask>(*this, callback));
72: }
73: 
74: Statement::~Statement() {
75: 	connection_ref->Unref();
76: 	connection_ref = nullptr;
77: }
78: 
79: // A Napi InstanceOf for Javascript Objects "Date" and "RegExp"
80: static bool other_instance_of(Napi::Object source, const char *object_type) {
81: 	if (strcmp(object_type, "Date") == 0) {
82: 		return source.InstanceOf(source.Env().Global().Get(object_type).As<Napi::Function>());
83: 	} else if (strcmp(object_type, "RegExp") == 0) {
84: 		return source.InstanceOf(source.Env().Global().Get(object_type).As<Napi::Function>());
85: 	}
86: 
87: 	return false;
88: }
89: 
90: static duckdb::Value bind_parameter(const Napi::Value source) {
91: 	if (source.IsString()) {
92: 		return duckdb::Value(source.As<Napi::String>().Utf8Value());
93: 	} else if (other_instance_of(source.As<Napi::Object>(), "RegExp")) {
94: 		return duckdb::Value(source.ToString().Utf8Value());
95: 	} else if (source.IsNumber()) {
96: 		if (Utils::OtherIsInt(source.As<Napi::Number>())) {
97: 			return duckdb::Value::INTEGER(source.As<Napi::Number>().Int32Value());
98: 		} else {
99: 			return duckdb::Value::DOUBLE(source.As<Napi::Number>().DoubleValue());
100: 		}
101: 	} else if (source.IsBoolean()) {
102: 		return duckdb::Value::BOOLEAN(source.As<Napi::Boolean>().Value());
103: 	} else if (source.IsNull()) {
104: 		return duckdb::Value();
105: 	} else if (source.IsBuffer()) {
106: 		Napi::Buffer<char> buffer = source.As<Napi::Buffer<char>>();
107: 		return duckdb::Value::BLOB(std::string(buffer.Data(), buffer.Length()));
108: #if (NAPI_VERSION > 4)
109: 	} else if (source.IsDate()) {
110: 		const auto micros = int64_t(source.As<Napi::Date>().ValueOf()) * duckdb::Interval::MICROS_PER_MSEC;
111: 		if (micros % duckdb::Interval::MICROS_PER_DAY) {
112: 			return duckdb::Value::TIMESTAMP(duckdb::timestamp_t(micros));
113: 		} else {
114: 			const auto days = int32_t(micros / duckdb::Interval::MICROS_PER_DAY);
115: 			return duckdb::Value::DATE(duckdb::date_t(days));
116: 		}
117: #endif
118: 	} else if (source.IsObject()) {
119: 		return duckdb::Value(source.ToString().Utf8Value());
120: 	}
121: 	return duckdb::Value();
122: }
123: 
124: static Napi::Value convert_chunk(Napi::Env &env, std::vector<std::string> names, duckdb::DataChunk &chunk) {
125: 	Napi::EscapableHandleScope scope(env);
126: 	std::vector<Napi::String> node_names;
127: 	assert(names.size() == chunk.ColumnCount());
128: 	for (auto &name : names) {
129: 		node_names.push_back(Napi::String::New(env, name));
130: 	}
131: 	Napi::Array result(Napi::Array::New(env, chunk.size()));
132: 
133: 	for (duckdb::idx_t row_idx = 0; row_idx < chunk.size(); row_idx++) {
134: 		Napi::Object row_result = Napi::Object::New(env);
135: 
136: 		for (duckdb::idx_t col_idx = 0; col_idx < chunk.ColumnCount(); col_idx++) {
137: 			Napi::Value value;
138: 
139: 			auto dval = chunk.GetValue(col_idx, row_idx);
140: 			if (dval.is_null) {
141: 				row_result.Set(node_names[col_idx], env.Null());
142: 				continue;
143: 			}
144: 
145: 			// TODO templateroo here
146: 			switch (chunk.data[col_idx].GetType().id()) {
147: 			case duckdb::LogicalTypeId::INTEGER: {
148: 				value = Napi::Number::New(env, dval.value_.integer);
149: 			} break;
150: 			case duckdb::LogicalTypeId::FLOAT: {
151: 				value = Napi::Number::New(env, dval.value_.float_);
152: 			} break;
153: 			case duckdb::LogicalTypeId::DOUBLE: {
154: 				value = Napi::Number::New(env, dval.value_.double_);
155: 			} break;
156: 			case duckdb::LogicalTypeId::BIGINT: {
157: 				value = Napi::Number::New(env, dval.value_.bigint);
158: 			} break;
159: 			case duckdb::LogicalTypeId::HUGEINT: {
160: 				value = Napi::Number::New(env, dval.GetValue<double>());
161: 			} break;
162: #if (NAPI_VERSION > 4)
163: 			case duckdb::LogicalTypeId::DATE: {
164: 				const auto scale = duckdb::Interval::SECS_PER_DAY * duckdb::Interval::MSECS_PER_SEC;
165: 				value = Napi::Date::New(env, double(dval.GetValue<int32_t>() * scale));
166: 			} break;
167: 			case duckdb::LogicalTypeId::TIMESTAMP: {
168: 				value = Napi::Date::New(env, double(dval.GetValue<int64_t>() / duckdb::Interval::MICROS_PER_MSEC));
169: 			} break;
170: #endif
171: 			case duckdb::LogicalTypeId::VARCHAR: {
172: 				value = Napi::String::New(env, dval.str_value);
173: 			} break;
174: 			case duckdb::LogicalTypeId::BLOB: {
175: 				value = Napi::Buffer<char>::Copy(env, dval.str_value.c_str(), dval.str_value.length());
176: 			} break;
177: 			case duckdb::LogicalTypeId::SQLNULL: {
178: 				value = env.Null();
179: 			} break;
180: 			default:
181: 				Napi::Error::New(env, "Data type is not supported " + dval.type().ToString())
182: 				    .ThrowAsJavaScriptException();
183: 				return env.Null();
184: 			}
185: 			row_result.Set(node_names[col_idx], value);
186: 		}
187: 		result.Set(row_idx, row_result);
188: 	}
189: 
190: 	return scope.Escape(result);
191: }
192: 
193: enum RunType { RUN, EACH, ALL };
194: 
195: struct StatementParam {
196: 	std::vector<duckdb::Value> params;
197: 	Napi::Function callback;
198: 	Napi::Function complete;
199: };
200: 
201: struct RunPreparedTask : public Task {
202: 	RunPreparedTask(Statement &statement_, duckdb::unique_ptr<StatementParam> params_, RunType run_type_)
203: 	    : Task(statement_, params_->callback), params(move(params_)), run_type(run_type_) {
204: 	}
205: 
206: 	void DoWork() override {
207: 		auto &statement = Get<Statement>();
208: 		// ignorant folk arrive here without caring about the prepare callback error
209: 		if (!statement.statement || !statement.statement->success) {
210: 			return;
211: 		}
212: 
213: 		result = statement.statement->Execute(params->params, run_type != RunType::ALL);
214: 	}
215: 
216: 	void Callback() override {
217: 		auto &statement = Get<Statement>();
218: 		Napi::Env env = statement.Env();
219: 		Napi::HandleScope scope(env);
220: 
221: 		auto cb = callback.Value();
222: 		// if there was an error we need to say so
223: 		if (!statement.statement) {
224: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, "statement was finalized")});
225: 			return;
226: 		}
227: 		if (!statement.statement->success) {
228: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, statement.statement->error)});
229: 			return;
230: 		}
231: 		if (!statement.statement->success) {
232: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, statement.statement->error)});
233: 			return;
234: 		}
235: 		if (!result->success) {
236: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, result->error)});
237: 			return;
238: 		}
239: 
240: 		switch (run_type) {
241: 		case RunType::RUN:
242: 			cb.MakeCallback(statement.Value(), {env.Null()});
243: 			break;
244: 		case RunType::EACH: {
245: 			duckdb::idx_t count = 0;
246: 			while (true) {
247: 				auto chunk = result->Fetch();
248: 				if (!chunk || chunk->size() == 0) {
249: 					break;
250: 				}
251: 
252: 				auto chunk_converted = convert_chunk(env, result->names, *chunk).ToObject();
253: 				if (!chunk_converted.IsArray()) {
254: 					// error was set before
255: 					return;
256: 				}
257: 				for (duckdb::idx_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
258: 					cb.MakeCallback(statement.Value(), {env.Null(), chunk_converted.Get(row_idx)});
259: 					count++;
260: 				}
261: 			}
262: 			if (!params->complete.IsUndefined() && params->complete.IsFunction()) {
263: 				params->complete.MakeCallback(statement.Value(), {env.Null(), Napi::Number::New(env, count)});
264: 			}
265: 			break;
266: 		}
267: 		case RunType::ALL: {
268: 			auto materialized_result = (duckdb::MaterializedQueryResult *)result.get();
269: 			Napi::Array result_arr(Napi::Array::New(env, materialized_result->collection.Count()));
270: 
271: 			duckdb::idx_t out_idx = 0;
272: 			while (true) {
273: 				auto chunk = result->Fetch();
274: 				if (!chunk || chunk->size() == 0) {
275: 					break;
276: 				}
277: 				// ToObject has to happen here otherwise the converted chunk gets garbage collected for some reason
278: 				auto chunk_converted = convert_chunk(env, result->names, *chunk).ToObject();
279: 				if (!chunk_converted.IsArray()) {
280: 					// error was set before
281: 					return;
282: 				}
283: 				for (duckdb::idx_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
284: 					result_arr.Set(out_idx++, chunk_converted.Get(row_idx));
285: 				}
286: 			}
287: 
288: 			cb.MakeCallback(statement.Value(), {env.Null(), result_arr});
289: 		} break;
290: 		}
291: 	}
292: 	std::unique_ptr<duckdb::QueryResult> result;
293: 	duckdb::unique_ptr<StatementParam> params;
294: 	RunType run_type;
295: };
296: 
297: duckdb::unique_ptr<StatementParam> Statement::HandleArgs(const Napi::CallbackInfo &info) {
298: 	size_t start_idx = ignore_first_param ? 1 : 0;
299: 	auto params = duckdb::make_unique<StatementParam>();
300: 
301: 	for (auto i = start_idx; i < info.Length(); i++) {
302: 		auto &p = info[i];
303: 		if (p.IsFunction()) {
304: 			if (!params->callback.IsUndefined()) { // we already saw a callback, so this is the finalizer
305: 				params->complete = p.As<Napi::Function>();
306: 			} else {
307: 				params->callback = p.As<Napi::Function>();
308: 			}
309: 			continue;
310: 		}
311: 		if (p.IsUndefined()) {
312: 			continue;
313: 		}
314: 		params->params.push_back(bind_parameter(p));
315: 	}
316: 	return params;
317: }
318: 
319: Napi::Value Statement::All(const Napi::CallbackInfo &info) {
320: 	connection_ref->database_ref->Schedule(info.Env(),
321: 	                                       duckdb::make_unique<RunPreparedTask>(*this, HandleArgs(info), RunType::ALL));
322: 	return info.This();
323: }
324: 
325: Napi::Value Statement::Run(const Napi::CallbackInfo &info) {
326: 	auto params = HandleArgs(info);
327: 	connection_ref->database_ref->Schedule(info.Env(),
328: 	                                       duckdb::make_unique<RunPreparedTask>(*this, HandleArgs(info), RunType::RUN));
329: 	return info.This();
330: }
331: 
332: Napi::Value Statement::Each(const Napi::CallbackInfo &info) {
333: 	auto params = HandleArgs(info);
334: 	connection_ref->database_ref->Schedule(
335: 	    info.Env(), duckdb::make_unique<RunPreparedTask>(*this, HandleArgs(info), RunType::EACH));
336: 	return info.This();
337: }
338: 
339: struct FinalizeTask : public Task {
340: 	FinalizeTask(Statement &statement_, Napi::Function callback_) : Task(statement_, callback_) {
341: 	}
342: 
343: 	void DoWork() override {
344: 		// TODO why does this break stuff?
345: 		// Get<Statement>().statement.reset();
346: 	}
347: };
348: 
349: Napi::Value Statement::Finalize_(const Napi::CallbackInfo &info) {
350: 	Napi::Env env = info.Env();
351: 	Napi::HandleScope scope(env);
352: 
353: 	Napi::Function callback;
354: 
355: 	if (info.Length() > 0 && info[0].IsFunction()) {
356: 		callback = info[0].As<Napi::Function>();
357: 	}
358: 
359: 	connection_ref->database_ref->Schedule(env, duckdb::make_unique<FinalizeTask>(*this, callback));
360: 	return env.Null();
361: }
362: 
363: } // namespace node_duckdb
[end of tools/nodejs/src/statement.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: