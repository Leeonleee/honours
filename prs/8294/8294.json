{
  "repo": "duckdb/duckdb",
  "pull_number": 8294,
  "instance_id": "duckdb__duckdb-8294",
  "issue_numbers": [
    "8143"
  ],
  "base_commit": "eeb87ed067971dbc5369c5f161c3899123eea3e6",
  "patch": "diff --git a/src/include/duckdb/common/types/timestamp.hpp b/src/include/duckdb/common/types/timestamp.hpp\nindex 1d5f5d962e6a..f6f427d4a2fe 100644\n--- a/src/include/duckdb/common/types/timestamp.hpp\n+++ b/src/include/duckdb/common/types/timestamp.hpp\n@@ -26,7 +26,7 @@ struct timestamp_t { // NOLINT\n \tint64_t value;\n \n \ttimestamp_t() = default;\n-\texplicit inline timestamp_t(int64_t value_p) : value(value_p) {\n+\texplicit inline constexpr timestamp_t(int64_t value_p) : value(value_p) {\n \t}\n \tinline timestamp_t &operator=(int64_t value_p) {\n \t\tvalue = value_p;\n@@ -67,21 +67,25 @@ struct timestamp_t { // NOLINT\n \ttimestamp_t &operator-=(const int64_t &delta);\n \n \t// special values\n-\tstatic timestamp_t infinity() { // NOLINT\n+\tstatic constexpr timestamp_t infinity() { // NOLINT\n \t\treturn timestamp_t(NumericLimits<int64_t>::Maximum());\n-\t}                                // NOLINT\n-\tstatic timestamp_t ninfinity() { // NOLINT\n+\t}                                          // NOLINT\n+\tstatic constexpr timestamp_t ninfinity() { // NOLINT\n \t\treturn timestamp_t(-NumericLimits<int64_t>::Maximum());\n-\t}                                   // NOLINT\n-\tstatic inline timestamp_t epoch() { // NOLINT\n+\t}                                             // NOLINT\n+\tstatic constexpr inline timestamp_t epoch() { // NOLINT\n \t\treturn timestamp_t(0);\n \t} // NOLINT\n };\n \n-struct timestamp_tz_t : public timestamp_t {};  // NOLINT\n-struct timestamp_ns_t : public timestamp_t {};  // NOLINT\n-struct timestamp_ms_t : public timestamp_t {};  // NOLINT\n-struct timestamp_sec_t : public timestamp_t {}; // NOLINT\n+struct timestamp_tz_t : public timestamp_t { // NOLINT\n+};\n+struct timestamp_ns_t : public timestamp_t { // NOLINT\n+};\n+struct timestamp_ms_t : public timestamp_t { // NOLINT\n+};\n+struct timestamp_sec_t : public timestamp_t { // NOLINT\n+};\n \n enum class TimestampCastResult : uint8_t { SUCCESS, ERROR_INCORRECT_FORMAT, ERROR_NON_UTC_TIMEZONE };\n \ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/datetime_module.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/datetime_module.hpp\nindex 2a7b6f0d3dff..8fe2b79ebbef 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/datetime_module.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/datetime_module.hpp\n@@ -12,6 +12,40 @@\n \n namespace duckdb {\n \n+struct DatetimeDatetimeCacheItem : public PythonImportCacheItem {\n+public:\n+\tstatic constexpr const char *Name = \"datetime.datetime\";\n+\n+public:\n+\t~DatetimeDatetimeCacheItem() override {\n+\t}\n+\tvirtual void LoadSubtypes(PythonImportCache &cache) override {\n+\t\tmax.LoadAttribute(\"max\", cache, *this);\n+\t\tmin.LoadAttribute(\"min\", cache, *this);\n+\t}\n+\n+public:\n+\tPythonImportCacheItem max;\n+\tPythonImportCacheItem min;\n+};\n+\n+struct DatetimeDateCacheItem : public PythonImportCacheItem {\n+public:\n+\tstatic constexpr const char *Name = \"datetime.date\";\n+\n+public:\n+\t~DatetimeDateCacheItem() override {\n+\t}\n+\tvirtual void LoadSubtypes(PythonImportCache &cache) override {\n+\t\tmax.LoadAttribute(\"max\", cache, *this);\n+\t\tmin.LoadAttribute(\"min\", cache, *this);\n+\t}\n+\n+public:\n+\tPythonImportCacheItem max;\n+\tPythonImportCacheItem min;\n+};\n+\n struct DatetimeCacheItem : public PythonImportCacheItem {\n public:\n \tstatic constexpr const char *Name = \"datetime\";\n@@ -27,8 +61,8 @@ struct DatetimeCacheItem : public PythonImportCacheItem {\n \t}\n \n public:\n-\tPythonImportCacheItem datetime;\n-\tPythonImportCacheItem date;\n+\tDatetimeDatetimeCacheItem datetime;\n+\tDatetimeDateCacheItem date;\n \tPythonImportCacheItem time;\n \tPythonImportCacheItem timedelta;\n };\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp b/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\nindex 0abaabb2cbd7..4072e1bd58bd 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\n@@ -162,6 +162,8 @@ struct PyDateTime {\n \tdate_t ToDate();\n \tdtime_t ToDuckTime();\n \tValue ToDuckValue(const LogicalType &target_type);\n+\tbool IsPositiveInfinity() const;\n+\tbool IsNegativeInfinity() const;\n \n public:\n \tstatic int32_t GetYears(PyObject *obj);\n@@ -183,6 +185,8 @@ struct PyDate {\n \n public:\n \tValue ToDuckValue();\n+\tbool IsPositiveInfinity() const;\n+\tbool IsNegativeInfinity() const;\n };\n \n struct PyTimezone {\ndiff --git a/tools/pythonpkg/src/native/python_objects.cpp b/tools/pythonpkg/src/native/python_objects.cpp\nindex 64e2e251ccee..530a13fd16c4 100644\n--- a/tools/pythonpkg/src/native/python_objects.cpp\n+++ b/tools/pythonpkg/src/native/python_objects.cpp\n@@ -277,7 +277,23 @@ timestamp_t PyDateTime::ToTimestamp() {\n \treturn Timestamp::FromDatetime(date, time);\n }\n \n+bool PyDateTime::IsPositiveInfinity() const {\n+\treturn year == 9999 && month == 12 && day == 31 && hour == 23 && minute == 59 && second == 59 && micros == 999999;\n+}\n+\n+bool PyDateTime::IsNegativeInfinity() const {\n+\treturn year == 1 && month == 1 && day == 1 && hour == 0 && minute == 0 && second == 0 && micros == 0;\n+}\n+\n Value PyDateTime::ToDuckValue(const LogicalType &target_type) {\n+\tif (IsPositiveInfinity()) {\n+\t\t// FIXME: respect the target_type ?\n+\t\treturn Value::TIMESTAMP(timestamp_t::infinity());\n+\t}\n+\tif (IsNegativeInfinity()) {\n+\t\t// FIXME: respect the target_type ?\n+\t\treturn Value::TIMESTAMP(timestamp_t::ninfinity());\n+\t}\n \tauto timestamp = ToTimestamp();\n \tif (tzone_obj != Py_None) {\n \t\tauto utc_offset = PyTimezone::GetUTCOffset(tzone_obj);\n@@ -350,13 +366,39 @@ PyDate::PyDate(py::handle &ele) {\n }\n \n Value PyDate::ToDuckValue() {\n+\tif (IsPositiveInfinity()) {\n+\t\treturn Value::DATE(date_t::infinity());\n+\t}\n+\tif (IsNegativeInfinity()) {\n+\t\treturn Value::DATE(date_t::ninfinity());\n+\t}\n \treturn Value::DATE(year, month, day);\n }\n \n+bool PyDate::IsPositiveInfinity() const {\n+\treturn year == 9999 && month == 12 && day == 31;\n+}\n+\n+bool PyDate::IsNegativeInfinity() const {\n+\treturn year == 1 && month == 1 && day == 1;\n+}\n+\n void PythonObject::Initialize() {\n \tPyDateTime_IMPORT; // NOLINT: Python datetime initialize #2\n }\n \n+enum class InfinityType : uint8_t { NONE, POSITIVE, NEGATIVE };\n+\n+InfinityType GetTimestampInfinityType(timestamp_t &timestamp) {\n+\tif (timestamp == timestamp_t::infinity()) {\n+\t\treturn InfinityType::POSITIVE;\n+\t}\n+\tif (timestamp == timestamp_t::ninfinity()) {\n+\t\treturn InfinityType::NEGATIVE;\n+\t}\n+\treturn InfinityType::NONE;\n+}\n+\n py::object PythonObject::FromValue(const Value &val, const LogicalType &type) {\n \tauto &import_cache = *DuckDBPyConnection::ImportCache();\n \tif (val.IsNull()) {\n@@ -408,6 +450,8 @@ py::object PythonObject::FromValue(const Value &val, const LogicalType &type) {\n \tcase LogicalTypeId::TIMESTAMP_TZ: {\n \t\tD_ASSERT(type.InternalType() == PhysicalType::INT64);\n \t\tauto timestamp = val.GetValueUnsafe<timestamp_t>();\n+\n+\t\tInfinityType infinity = InfinityType::NONE;\n \t\tif (type.id() == LogicalTypeId::TIMESTAMP_MS) {\n \t\t\ttimestamp = Timestamp::FromEpochMs(timestamp.value);\n \t\t} else if (type.id() == LogicalTypeId::TIMESTAMP_NS) {\n@@ -415,6 +459,19 @@ py::object PythonObject::FromValue(const Value &val, const LogicalType &type) {\n \t\t} else if (type.id() == LogicalTypeId::TIMESTAMP_SEC) {\n \t\t\ttimestamp = Timestamp::FromEpochSeconds(timestamp.value);\n \t\t}\n+\t\tinfinity = GetTimestampInfinityType(timestamp);\n+\n+\t\t// Deal with infinity\n+\t\tswitch (infinity) {\n+\t\tcase InfinityType::POSITIVE: {\n+\t\t\treturn py::reinterpret_borrow<py::object>(import_cache.datetime().datetime.max());\n+\t\t}\n+\t\tcase InfinityType::NEGATIVE: {\n+\t\t\treturn py::reinterpret_borrow<py::object>(import_cache.datetime().datetime.min());\n+\t\t}\n+\t\tcase InfinityType::NONE:\n+\t\t\tbreak;\n+\t\t}\n \t\tint32_t year, month, day, hour, min, sec, micros;\n \t\tdate_t date;\n \t\tdtime_t time;\n@@ -437,6 +494,12 @@ py::object PythonObject::FromValue(const Value &val, const LogicalType &type) {\n \n \t\tauto date = val.GetValueUnsafe<date_t>();\n \t\tint32_t year, month, day;\n+\t\tif (!duckdb::Date::IsFinite(date)) {\n+\t\t\tif (date == date_t::infinity()) {\n+\t\t\t\treturn py::reinterpret_borrow<py::object>(import_cache.datetime().date.max());\n+\t\t\t}\n+\t\t\treturn py::reinterpret_borrow<py::object>(import_cache.datetime().date.min());\n+\t\t}\n \t\tduckdb::Date::Convert(date, year, month, day);\n \t\treturn py::reinterpret_steal<py::object>(PyDate_FromDate(year, month, day));\n \t}\ndiff --git a/tools/pythonpkg/src/pyrelation.cpp b/tools/pythonpkg/src/pyrelation.cpp\nindex 984c09a089b5..02aee6bf1fb1 100644\n--- a/tools/pythonpkg/src/pyrelation.cpp\n+++ b/tools/pythonpkg/src/pyrelation.cpp\n@@ -634,7 +634,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyRelation::GetAttribute(const string &name)\n \t\treturn make_uniq<DuckDBPyRelation>(rel->Project({StringUtil::Format(\"%s.%s\", names[0], name)}));\n \t}\n \tif (ContainsColumnByName(name)) {\n-\t\treturn make_uniq<DuckDBPyRelation>(rel->Project({name}));\n+\t\treturn make_uniq<DuckDBPyRelation>(rel->Project({StringUtil::Format(\"\\\"%s\\\"\", name)}));\n \t}\n \tthrow py::attribute_error(StringUtil::Format(\"This relation does not contain a column by the name of '%s'\", name));\n }\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_attribute_getter.py b/tools/pythonpkg/tests/fast/api/test_attribute_getter.py\nindex dd2955db1d09..3ad1e027d66e 100644\n--- a/tools/pythonpkg/tests/fast/api/test_attribute_getter.py\n+++ b/tools/pythonpkg/tests/fast/api/test_attribute_getter.py\n@@ -53,3 +53,7 @@ def test_getattr_struct(self):\n         rel = duckdb.sql(\"select {'a':5, 'b':6} as a, 5 as b\")\n         assert rel.a.a.fetchall()[0][0] == 5\n         assert rel.a.b.fetchall()[0][0] == 6\n+\n+    def test_getattr_spaces(self):\n+        rel = duckdb.sql('select 42 as \"hello world\"')\n+        assert rel['hello world'].fetchall()[0][0] == 42\ndiff --git a/tools/pythonpkg/tests/fast/types/test_datetime_date.py b/tools/pythonpkg/tests/fast/types/test_datetime_date.py\nnew file mode 100644\nindex 000000000000..83973be40224\n--- /dev/null\n+++ b/tools/pythonpkg/tests/fast/types/test_datetime_date.py\n@@ -0,0 +1,30 @@\n+import duckdb\n+import datetime\n+\n+\n+class TestDateTimeDate(object):\n+    def test_date_infinity(self):\n+        con = duckdb.connect()\n+        # Positive infinity\n+        con.execute(\"SELECT 'infinity'::DATE\")\n+        result = con.fetchall()\n+        # datetime.date.max\n+        assert result == [(datetime.date(9999, 12, 31),)]\n+\n+        con.execute(\"SELECT '-infinity'::DATE\")\n+        result = con.fetchall()\n+        # datetime.date.min\n+        assert result == [(datetime.date(1, 1, 1),)]\n+\n+    def test_date_infinity_roundtrip(self):\n+        con = duckdb.connect()\n+\n+        # positive infinity\n+        con.execute(\"select $1, $1 = 'infinity'::DATE\", [datetime.date.max])\n+        res = con.fetchall()\n+        assert res == [(datetime.date.max, True)]\n+\n+        # negative infinity\n+        con.execute(\"select $1, $1 = '-infinity'::DATE\", [datetime.date.min])\n+        res = con.fetchall()\n+        assert res == [(datetime.date.min, True)]\ndiff --git a/tools/pythonpkg/tests/fast/types/test_datetime_datetime.py b/tools/pythonpkg/tests/fast/types/test_datetime_datetime.py\nnew file mode 100644\nindex 000000000000..45aff1fca0fe\n--- /dev/null\n+++ b/tools/pythonpkg/tests/fast/types/test_datetime_datetime.py\n@@ -0,0 +1,49 @@\n+import duckdb\n+import datetime\n+import pytest\n+\n+\n+def create_query(positive, type):\n+    inf = 'infinity' if positive else '-infinity'\n+    return f\"\"\"\n+        select '{inf}'::{type}\n+    \"\"\"\n+\n+\n+class TestDateTimeDateTime(object):\n+    @pytest.mark.parametrize('positive', [True, False])\n+    @pytest.mark.parametrize(\n+        'type',\n+        [\n+            'TIMESTAMP',\n+            'TIMESTAMP_S',\n+            'TIMESTAMP_MS',\n+            'TIMESTAMP_NS',\n+            'TIMESTAMPTZ',\n+            'TIMESTAMP_US',\n+        ],\n+    )\n+    def test_timestamp_infinity(self, positive, type):\n+        con = duckdb.connect()\n+\n+        if type in ['TIMESTAMP_S', 'TIMESTAMP_MS', 'TIMESTAMP_NS']:\n+            # Infinity (both positive and negative) is not supported for non-usecond timetamps\n+            return\n+\n+        expected_val = datetime.datetime.max if positive else datetime.datetime.min\n+        query = create_query(positive, type)\n+        res = con.sql(query).fetchall()[0][0]\n+        assert res == expected_val\n+\n+    def test_timestamp_infinity_roundtrip(self):\n+        con = duckdb.connect()\n+\n+        # positive infinity\n+        con.execute(\"select $1, $1 = 'infinity'::TIMESTAMP\", [datetime.datetime.max])\n+        res = con.fetchall()\n+        assert res == [(datetime.datetime.max, True)]\n+\n+        # negative infinity\n+        con.execute(\"select $1, $1 = '-infinity'::TIMESTAMP\", [datetime.datetime.min])\n+        res = con.fetchall()\n+        assert res == [(datetime.datetime.min, True)]\n",
  "problem_statement": "TIMESTAMP field with infinity value breaks DuckDBPyRelation fetchall() method.\n### What happens?\n\nWhen trying to extract the Relation content via fetchall, I get the following error:\r\n```\r\n>>> flist.fetchall()\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nduckdb.ConversionException: Conversion Error: Date out of range in timestamp conversion\r\n\r\n```\n\n### To Reproduce\n\nRun the following Python code on console\r\n```\r\nimport duckdb\r\ncon = duckdb.connect(':default:')\r\ncon.execute(\"\"\"CREATE TABLE fset(\r\n    filename VARCHAR,\r\n    path VARCHAR[],\r\n    origin VARCHAR,\r\n    tags VARCHAR[],\r\n    created TIMESTAMP,\r\n    removed TIMESTAMP,\r\n    hidden BOOLEAN,\r\n    processed BOOLEAN,\r\n    owner VARCHAR,\r\n    changed_by VARCHAR,\r\n    read_user VARCHAR[],\r\n    read_group VARCHAR[],\r\n    change_user VARCHAR[],\r\n    change_group VARCHAR[])\"\"\"\r\n)\r\ncon.execute(\"INSERT INTO fset SELECT * FROM read_json('file01.json', auto_detect=true, union_by_name=true)\")\r\nflist = con.sql(\"select * from fset\")\r\ncon.sql(\"select removed from flist\")\r\nflist.fetchall()\r\n```\r\n\r\nfile01.json\r\n```\r\n[\r\n\t{\r\n\t\t\"filename\" : \"file0001.json\",\r\n\t\t\"path\" : [\"json\"],\r\n\t\t\"origin\" : [\"json\"],\r\n\t\t\"tags\" : [ \"tag01\", \"tag02\" ],\r\n\t\t\"created\" : \"2023-06-28 15:26:53.51-03\",\r\n\t\t\"removed\" : \"infinity\",\r\n\t\t\"hidden\" : false,\r\n\t\t\"processed\" : true,\r\n\t\t\"owner\" : \"user0001\",\r\n\t\t\"changed_by\" : \"user0001\",\r\n\t\t\"read_user\" : [\"user0001\"],\r\n\t\t\"read_group\" : [\"group0001\"],\r\n\t\t\"change_user\" : [\"user0001\"],\r\n\t\t\"change_group\" : [\"group0001\"]\r\n\t}\r\n]\r\n```\r\n\r\n\r\n\r\n\r\n\n\n### OS:\n\nosx\n\n### DuckDB Version:\n\nduckdb==0.8.1\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nCaio Klein\n\n### Affiliation:\n\nSkyOne\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Thanks for the reproduction example, it's really helpful!\r\n\r\nI've found the root of the problem, but I'm not entirely sure what the intended behavior is here.\r\n`datetime.datetime` does not have a representation for `infinity`\r\n\r\nWhat do you propose should be returned here?\nWe could return a `float('inf')` maybe.\r\n(same as `math.inf`)\r\n\r\nOr return a `decimal.Decimal('inf')`\r\n\r\nBoth of those aren't great because then the data could randomly contain something that isn't a `datetime.datetime` value\r\n\r\nAnother option would be to use `datetime.datetime.max`, though I believe that's not guaranteed to be properly recognized as infinity by other systems, I'm not sure if we even recognize it as infinity so it wouldn't roundtrip without additional work\nHi Tishj,\r\nI was playing with the alternatives you mentioned and `datetime.datetime.max` seems to be the best. As you already mentioned, it a valid `datetime.datetime`.\r\nHowever I was wondering if  `str('infinity')` is an option. This is how I have imported 'infinity' in the first place from the json file.\r\nThanks ",
  "created_at": "2023-07-18T12:23:35Z"
}