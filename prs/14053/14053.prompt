You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
max_by/min_by() new behavior - feature or bug?
### What happens?

The behavior of min_by() and max_by() has changed in the new 1.1.0 release. `max_by(a, b)` seems to now return `a` if there is a `null` in `b`, instead of returning `null` like in the previous version (I tested at least until 0.8.1). Returning null is the behavior of other engines like Presto (and perhaps the most intuitive for users?)

Was the change a feature or a bug? (please close in case the change was intentional)

### To Reproduce

```
pedroerp@fedora:~/Github/duck-0.8.1$ ./duckdb 
v0.8.1 6536a77232
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
```
```sql
SELECT max_by(c0, c1) FROM (values (1, null)) t(c0,c1);
```
```
┌────────────────┐
│ max_by(c0, c1) │
│     int32      │
├────────────────┤
│                │
└────────────────┘
```
```
pedroerp@fedora:~/Github/duck-0.8.1$ cd ../duck-1.1.0/
pedroerp@fedora:~/Github/duck-1.1.0$ ./duckdb 
v1.1.0 fa5c2fe15f
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
```
```sql
SELECT max_by(c0, c1) FROM (values (1, null)) t(c0,c1);
```
```
┌────────────────┐
│ max_by(c0, c1) │
│     int32      │
├────────────────┤
│              1 │
└────────────────┘
```

### OS:

Fedora

### DuckDB Version:

1.1.0 and 0.8.1

### DuckDB Client:

Command line client

### Hardware:

_No response_

### Full Name:

Pedro Pedreira

### Affiliation:

Meta

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
max_by/min_by() new behavior - feature or bug?
### What happens?

The behavior of min_by() and max_by() has changed in the new 1.1.0 release. `max_by(a, b)` seems to now return `a` if there is a `null` in `b`, instead of returning `null` like in the previous version (I tested at least until 0.8.1). Returning null is the behavior of other engines like Presto (and perhaps the most intuitive for users?)

Was the change a feature or a bug? (please close in case the change was intentional)

### To Reproduce

```
pedroerp@fedora:~/Github/duck-0.8.1$ ./duckdb 
v0.8.1 6536a77232
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
```
```sql
SELECT max_by(c0, c1) FROM (values (1, null)) t(c0,c1);
```
```
┌────────────────┐
│ max_by(c0, c1) │
│     int32      │
├────────────────┤
│                │
└────────────────┘
```
```
pedroerp@fedora:~/Github/duck-0.8.1$ cd ../duck-1.1.0/
pedroerp@fedora:~/Github/duck-1.1.0$ ./duckdb 
v1.1.0 fa5c2fe15f
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
```
```sql
SELECT max_by(c0, c1) FROM (values (1, null)) t(c0,c1);
```
```
┌────────────────┐
│ max_by(c0, c1) │
│     int32      │
├────────────────┤
│              1 │
└────────────────┘
```

### OS:

Fedora

### DuckDB Version:

1.1.0 and 0.8.1

### DuckDB Client:

Command line client

### Hardware:

_No response_

### Full Name:

Pedro Pedreira

### Affiliation:

Meta

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/core_functions/aggregate/distributive/arg_min_max.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/common/operator/comparison_operators.hpp"
3: #include "duckdb/common/vector_operations/vector_operations.hpp"
4: #include "duckdb/core_functions/aggregate/distributive_functions.hpp"
5: #include "duckdb/function/cast/cast_function_set.hpp"
6: #include "duckdb/function/function_set.hpp"
7: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
8: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
9: #include "duckdb/planner/expression_binder.hpp"
10: #include "duckdb/core_functions/create_sort_key.hpp"
11: #include "duckdb/core_functions/aggregate/minmax_n_helpers.hpp"
12: 
13: namespace duckdb {
14: 
15: struct ArgMinMaxStateBase {
16: 	ArgMinMaxStateBase() : is_initialized(false), arg_null(false) {
17: 	}
18: 
19: 	template <class T>
20: 	static inline void CreateValue(T &value) {
21: 	}
22: 
23: 	template <class T>
24: 	static inline void DestroyValue(T &value) {
25: 	}
26: 
27: 	template <class T>
28: 	static inline void AssignValue(T &target, T new_value) {
29: 		target = new_value;
30: 	}
31: 
32: 	template <typename T>
33: 	static inline void ReadValue(Vector &result, T &arg, T &target) {
34: 		target = arg;
35: 	}
36: 
37: 	bool is_initialized;
38: 	bool arg_null;
39: };
40: 
41: // Out-of-line specialisations
42: template <>
43: void ArgMinMaxStateBase::CreateValue(string_t &value) {
44: 	value = string_t(uint32_t(0));
45: }
46: 
47: template <>
48: void ArgMinMaxStateBase::DestroyValue(string_t &value) {
49: 	if (!value.IsInlined()) {
50: 		delete[] value.GetData();
51: 	}
52: }
53: 
54: template <>
55: void ArgMinMaxStateBase::AssignValue(string_t &target, string_t new_value) {
56: 	DestroyValue(target);
57: 	if (new_value.IsInlined()) {
58: 		target = new_value;
59: 	} else {
60: 		// non-inlined string, need to allocate space for it
61: 		auto len = new_value.GetSize();
62: 		auto ptr = new char[len];
63: 		memcpy(ptr, new_value.GetData(), len);
64: 
65: 		target = string_t(ptr, UnsafeNumericCast<uint32_t>(len));
66: 	}
67: }
68: 
69: template <>
70: void ArgMinMaxStateBase::ReadValue(Vector &result, string_t &arg, string_t &target) {
71: 	target = StringVector::AddStringOrBlob(result, arg);
72: }
73: 
74: template <class A, class B>
75: struct ArgMinMaxState : public ArgMinMaxStateBase {
76: 	using ARG_TYPE = A;
77: 	using BY_TYPE = B;
78: 
79: 	ARG_TYPE arg;
80: 	BY_TYPE value;
81: 
82: 	ArgMinMaxState() {
83: 		CreateValue(arg);
84: 		CreateValue(value);
85: 	}
86: 
87: 	~ArgMinMaxState() {
88: 		if (is_initialized) {
89: 			DestroyValue(arg);
90: 			DestroyValue(value);
91: 			is_initialized = false;
92: 		}
93: 	}
94: };
95: 
96: template <class COMPARATOR, bool IGNORE_NULL>
97: struct ArgMinMaxBase {
98: 	template <class STATE>
99: 	static void Initialize(STATE &state) {
100: 		new (&state) STATE;
101: 	}
102: 
103: 	template <class STATE>
104: 	static void Destroy(STATE &state, AggregateInputData &aggr_input_data) {
105: 		state.~STATE();
106: 	}
107: 
108: 	template <class A_TYPE, class B_TYPE, class STATE>
109: 	static void Assign(STATE &state, const A_TYPE &x, const B_TYPE &y, const bool x_null) {
110: 		if (IGNORE_NULL) {
111: 			STATE::template AssignValue<A_TYPE>(state.arg, x);
112: 			STATE::template AssignValue<B_TYPE>(state.value, y);
113: 		} else {
114: 			state.arg_null = x_null;
115: 			if (!state.arg_null) {
116: 				STATE::template AssignValue<A_TYPE>(state.arg, x);
117: 			}
118: 			STATE::template AssignValue<B_TYPE>(state.value, y);
119: 		}
120: 	}
121: 
122: 	template <class A_TYPE, class B_TYPE, class STATE, class OP>
123: 	static void Operation(STATE &state, const A_TYPE &x, const B_TYPE &y, AggregateBinaryInput &binary) {
124: 		if (!state.is_initialized) {
125: 			if (IGNORE_NULL || binary.right_mask.RowIsValid(binary.ridx)) {
126: 				Assign(state, x, y, !binary.left_mask.RowIsValid(binary.lidx));
127: 				state.is_initialized = true;
128: 			}
129: 		} else {
130: 			OP::template Execute<A_TYPE, B_TYPE, STATE>(state, x, y, binary);
131: 		}
132: 	}
133: 
134: 	template <class A_TYPE, class B_TYPE, class STATE>
135: 	static void Execute(STATE &state, A_TYPE x_data, B_TYPE y_data, AggregateBinaryInput &binary) {
136: 		if ((IGNORE_NULL || binary.right_mask.RowIsValid(binary.ridx)) && COMPARATOR::Operation(y_data, state.value)) {
137: 			Assign(state, x_data, y_data, !binary.left_mask.RowIsValid(binary.lidx));
138: 		}
139: 	}
140: 
141: 	template <class STATE, class OP>
142: 	static void Combine(const STATE &source, STATE &target, AggregateInputData &) {
143: 		if (!source.is_initialized) {
144: 			return;
145: 		}
146: 		if (!target.is_initialized || COMPARATOR::Operation(source.value, target.value)) {
147: 			Assign(target, source.arg, source.value, source.arg_null);
148: 			target.is_initialized = true;
149: 		}
150: 	}
151: 
152: 	template <class T, class STATE>
153: 	static void Finalize(STATE &state, T &target, AggregateFinalizeData &finalize_data) {
154: 		if (!state.is_initialized || state.arg_null) {
155: 			finalize_data.ReturnNull();
156: 		} else {
157: 			STATE::template ReadValue<T>(finalize_data.result, state.arg, target);
158: 		}
159: 	}
160: 
161: 	static bool IgnoreNull() {
162: 		return IGNORE_NULL;
163: 	}
164: 
165: 	static unique_ptr<FunctionData> Bind(ClientContext &context, AggregateFunction &function,
166: 	                                     vector<unique_ptr<Expression>> &arguments) {
167: 		if (arguments[1]->return_type.InternalType() == PhysicalType::VARCHAR) {
168: 			ExpressionBinder::PushCollation(context, arguments[1], arguments[1]->return_type);
169: 		}
170: 		function.arguments[0] = arguments[0]->return_type;
171: 		function.return_type = arguments[0]->return_type;
172: 		return nullptr;
173: 	}
174: };
175: 
176: struct SpecializedGenericArgMinMaxState {
177: 	static bool CreateExtraState(idx_t count) {
178: 		// nop extra state
179: 		return false;
180: 	}
181: 
182: 	static void PrepareData(Vector &by, idx_t count, bool &, UnifiedVectorFormat &result) {
183: 		by.ToUnifiedFormat(count, result);
184: 	}
185: };
186: 
187: template <OrderType ORDER_TYPE>
188: struct GenericArgMinMaxState {
189: 	static Vector CreateExtraState(idx_t count) {
190: 		return Vector(LogicalType::BLOB, count);
191: 	}
192: 
193: 	static void PrepareData(Vector &by, idx_t count, Vector &extra_state, UnifiedVectorFormat &result) {
194: 		OrderModifiers modifiers(ORDER_TYPE, OrderByNullType::NULLS_LAST);
195: 		CreateSortKeyHelpers::CreateSortKey(by, count, modifiers, extra_state);
196: 		extra_state.ToUnifiedFormat(count, result);
197: 	}
198: };
199: 
200: template <typename COMPARATOR, bool IGNORE_NULL, OrderType ORDER_TYPE,
201:           class UPDATE_TYPE = SpecializedGenericArgMinMaxState>
202: struct VectorArgMinMaxBase : ArgMinMaxBase<COMPARATOR, IGNORE_NULL> {
203: 	template <class STATE>
204: 	static void Update(Vector inputs[], AggregateInputData &, idx_t input_count, Vector &state_vector, idx_t count) {
205: 		auto &arg = inputs[0];
206: 		UnifiedVectorFormat adata;
207: 		arg.ToUnifiedFormat(count, adata);
208: 
209: 		using ARG_TYPE = typename STATE::ARG_TYPE;
210: 		using BY_TYPE = typename STATE::BY_TYPE;
211: 		auto &by = inputs[1];
212: 		UnifiedVectorFormat bdata;
213: 		auto extra_state = UPDATE_TYPE::CreateExtraState(count);
214: 		UPDATE_TYPE::PrepareData(by, count, extra_state, bdata);
215: 		const auto bys = UnifiedVectorFormat::GetData<BY_TYPE>(bdata);
216: 
217: 		UnifiedVectorFormat sdata;
218: 		state_vector.ToUnifiedFormat(count, sdata);
219: 
220: 		STATE *last_state = nullptr;
221: 		sel_t assign_sel[STANDARD_VECTOR_SIZE];
222: 		idx_t assign_count = 0;
223: 
224: 		auto states = UnifiedVectorFormat::GetData<STATE *>(sdata);
225: 		for (idx_t i = 0; i < count; i++) {
226: 			const auto bidx = bdata.sel->get_index(i);
227: 			if (!bdata.validity.RowIsValid(bidx)) {
228: 				continue;
229: 			}
230: 			const auto bval = bys[bidx];
231: 
232: 			const auto aidx = adata.sel->get_index(i);
233: 			const auto arg_null = !adata.validity.RowIsValid(aidx);
234: 			if (IGNORE_NULL && arg_null) {
235: 				continue;
236: 			}
237: 
238: 			const auto sidx = sdata.sel->get_index(i);
239: 			auto &state = *states[sidx];
240: 			if (!state.is_initialized || COMPARATOR::template Operation<BY_TYPE>(bval, state.value)) {
241: 				STATE::template AssignValue<BY_TYPE>(state.value, bval);
242: 				state.arg_null = arg_null;
243: 				// micro-adaptivity: it is common we overwrite the same state repeatedly
244: 				// e.g. when running arg_max(val, ts) and ts is sorted in ascending order
245: 				// this check essentially says:
246: 				// "if we are overriding the same state as the last row, the last write was pointless"
247: 				// hence we skip the last write altogether
248: 				if (!arg_null) {
249: 					if (&state == last_state) {
250: 						assign_count--;
251: 					}
252: 					assign_sel[assign_count++] = UnsafeNumericCast<sel_t>(i);
253: 					last_state = &state;
254: 				}
255: 				state.is_initialized = true;
256: 			}
257: 		}
258: 		if (assign_count == 0) {
259: 			// no need to assign anything: nothing left to do
260: 			return;
261: 		}
262: 		Vector sort_key(LogicalType::BLOB);
263: 		auto modifiers = OrderModifiers(ORDER_TYPE, OrderByNullType::NULLS_LAST);
264: 		// slice with a selection vector and generate sort keys
265: 		SelectionVector sel(assign_sel);
266: 		Vector sliced_input(arg, sel, assign_count);
267: 		CreateSortKeyHelpers::CreateSortKey(sliced_input, assign_count, modifiers, sort_key);
268: 		auto sort_key_data = FlatVector::GetData<string_t>(sort_key);
269: 
270: 		// now assign sort keys
271: 		for (idx_t i = 0; i < assign_count; i++) {
272: 			const auto sidx = sdata.sel->get_index(sel.get_index(i));
273: 			auto &state = *states[sidx];
274: 			STATE::template AssignValue<ARG_TYPE>(state.arg, sort_key_data[i]);
275: 		}
276: 	}
277: 
278: 	template <class STATE, class OP>
279: 	static void Combine(const STATE &source, STATE &target, AggregateInputData &) {
280: 		if (!source.is_initialized) {
281: 			return;
282: 		}
283: 		if (!target.is_initialized || COMPARATOR::Operation(source.value, target.value)) {
284: 			STATE::template AssignValue<typename STATE::BY_TYPE>(target.value, source.value);
285: 			target.arg_null = source.arg_null;
286: 			if (!target.arg_null) {
287: 				STATE::template AssignValue<typename STATE::ARG_TYPE>(target.arg, source.arg);
288: 				;
289: 			}
290: 			target.is_initialized = true;
291: 		}
292: 	}
293: 
294: 	template <class STATE>
295: 	static void Finalize(STATE &state, AggregateFinalizeData &finalize_data) {
296: 		if (!state.is_initialized || state.arg_null) {
297: 			finalize_data.ReturnNull();
298: 		} else {
299: 			CreateSortKeyHelpers::DecodeSortKey(state.arg, finalize_data.result, finalize_data.result_idx,
300: 			                                    OrderModifiers(ORDER_TYPE, OrderByNullType::NULLS_LAST));
301: 		}
302: 	}
303: 
304: 	static unique_ptr<FunctionData> Bind(ClientContext &context, AggregateFunction &function,
305: 	                                     vector<unique_ptr<Expression>> &arguments) {
306: 		function.arguments[0] = arguments[0]->return_type;
307: 		function.return_type = arguments[0]->return_type;
308: 		return nullptr;
309: 	}
310: };
311: 
312: template <class OP, class ARG_TYPE, class BY_TYPE>
313: AggregateFunction GetVectorArgMinMaxFunctionInternal(const LogicalType &by_type, const LogicalType &type) {
314: 	using STATE = ArgMinMaxState<ARG_TYPE, BY_TYPE>;
315: 	return AggregateFunction(
316: 	    {type, by_type}, type, AggregateFunction::StateSize<STATE>, AggregateFunction::StateInitialize<STATE, OP>,
317: 	    OP::template Update<STATE>, AggregateFunction::StateCombine<STATE, OP>,
318: 	    AggregateFunction::StateVoidFinalize<STATE, OP>, nullptr, OP::Bind, AggregateFunction::StateDestroy<STATE, OP>);
319: }
320: 
321: template <class OP, class ARG_TYPE>
322: AggregateFunction GetVectorArgMinMaxFunctionBy(const LogicalType &by_type, const LogicalType &type) {
323: 	switch (by_type.InternalType()) {
324: 	case PhysicalType::INT32:
325: 		return GetVectorArgMinMaxFunctionInternal<OP, ARG_TYPE, int32_t>(by_type, type);
326: 	case PhysicalType::INT64:
327: 		return GetVectorArgMinMaxFunctionInternal<OP, ARG_TYPE, int64_t>(by_type, type);
328: 	case PhysicalType::INT128:
329: 		return GetVectorArgMinMaxFunctionInternal<OP, ARG_TYPE, hugeint_t>(by_type, type);
330: 	case PhysicalType::DOUBLE:
331: 		return GetVectorArgMinMaxFunctionInternal<OP, ARG_TYPE, double>(by_type, type);
332: 	case PhysicalType::VARCHAR:
333: 		return GetVectorArgMinMaxFunctionInternal<OP, ARG_TYPE, string_t>(by_type, type);
334: 	default:
335: 		throw InternalException("Unimplemented arg_min/arg_max aggregate");
336: 	}
337: }
338: 
339: static const vector<LogicalType> ArgMaxByTypes() {
340: 	vector<LogicalType> types = {LogicalType::INTEGER,   LogicalType::BIGINT,       LogicalType::HUGEINT,
341: 	                             LogicalType::DOUBLE,    LogicalType::VARCHAR,      LogicalType::DATE,
342: 	                             LogicalType::TIMESTAMP, LogicalType::TIMESTAMP_TZ, LogicalType::BLOB};
343: 	return types;
344: }
345: 
346: template <class OP, class ARG_TYPE>
347: void AddVectorArgMinMaxFunctionBy(AggregateFunctionSet &fun, const LogicalType &type) {
348: 	auto by_types = ArgMaxByTypes();
349: 	for (const auto &by_type : by_types) {
350: 		fun.AddFunction(GetVectorArgMinMaxFunctionBy<OP, ARG_TYPE>(by_type, type));
351: 	}
352: }
353: 
354: template <class OP, class ARG_TYPE, class BY_TYPE>
355: AggregateFunction GetArgMinMaxFunctionInternal(const LogicalType &by_type, const LogicalType &type) {
356: 	using STATE = ArgMinMaxState<ARG_TYPE, BY_TYPE>;
357: 	auto function = AggregateFunction::BinaryAggregate<STATE, ARG_TYPE, BY_TYPE, ARG_TYPE, OP>(type, by_type, type);
358: 	if (type.InternalType() == PhysicalType::VARCHAR || by_type.InternalType() == PhysicalType::VARCHAR) {
359: 		function.destructor = AggregateFunction::StateDestroy<STATE, OP>;
360: 	}
361: 	function.bind = OP::Bind;
362: 	return function;
363: }
364: 
365: template <class OP, class ARG_TYPE>
366: AggregateFunction GetArgMinMaxFunctionBy(const LogicalType &by_type, const LogicalType &type) {
367: 	switch (by_type.InternalType()) {
368: 	case PhysicalType::INT32:
369: 		return GetArgMinMaxFunctionInternal<OP, ARG_TYPE, int32_t>(by_type, type);
370: 	case PhysicalType::INT64:
371: 		return GetArgMinMaxFunctionInternal<OP, ARG_TYPE, int64_t>(by_type, type);
372: 	case PhysicalType::INT128:
373: 		return GetArgMinMaxFunctionInternal<OP, ARG_TYPE, hugeint_t>(by_type, type);
374: 	case PhysicalType::DOUBLE:
375: 		return GetArgMinMaxFunctionInternal<OP, ARG_TYPE, double>(by_type, type);
376: 	case PhysicalType::VARCHAR:
377: 		return GetArgMinMaxFunctionInternal<OP, ARG_TYPE, string_t>(by_type, type);
378: 	default:
379: 		throw InternalException("Unimplemented arg_min/arg_max by aggregate");
380: 	}
381: }
382: 
383: template <class OP, class ARG_TYPE>
384: void AddArgMinMaxFunctionBy(AggregateFunctionSet &fun, const LogicalType &type) {
385: 	auto by_types = ArgMaxByTypes();
386: 	for (const auto &by_type : by_types) {
387: 		fun.AddFunction(GetArgMinMaxFunctionBy<OP, ARG_TYPE>(by_type, type));
388: 	}
389: }
390: 
391: template <class OP>
392: static AggregateFunction GetDecimalArgMinMaxFunction(const LogicalType &by_type, const LogicalType &type) {
393: 	D_ASSERT(type.id() == LogicalTypeId::DECIMAL);
394: 	switch (type.InternalType()) {
395: 	case PhysicalType::INT16:
396: 		return GetArgMinMaxFunctionBy<OP, int16_t>(by_type, type);
397: 	case PhysicalType::INT32:
398: 		return GetArgMinMaxFunctionBy<OP, int32_t>(by_type, type);
399: 	case PhysicalType::INT64:
400: 		return GetArgMinMaxFunctionBy<OP, int64_t>(by_type, type);
401: 	default:
402: 		return GetArgMinMaxFunctionBy<OP, hugeint_t>(by_type, type);
403: 	}
404: }
405: 
406: template <class OP>
407: static unique_ptr<FunctionData> BindDecimalArgMinMax(ClientContext &context, AggregateFunction &function,
408:                                                      vector<unique_ptr<Expression>> &arguments) {
409: 	auto decimal_type = arguments[0]->return_type;
410: 	auto by_type = arguments[1]->return_type;
411: 
412: 	// To avoid a combinatorial explosion, cast the ordering argument to one from the list
413: 	auto by_types = ArgMaxByTypes();
414: 	idx_t best_target = DConstants::INVALID_INDEX;
415: 	int64_t lowest_cost = NumericLimits<int64_t>::Maximum();
416: 	for (idx_t i = 0; i < by_types.size(); ++i) {
417: 		// Before falling back to casting, check for a physical type match for the by_type
418: 		if (by_types[i].InternalType() == by_type.InternalType()) {
419: 			lowest_cost = 0;
420: 			best_target = DConstants::INVALID_INDEX;
421: 			break;
422: 		}
423: 
424: 		auto cast_cost = CastFunctionSet::Get(context).ImplicitCastCost(by_type, by_types[i]);
425: 		if (cast_cost < 0) {
426: 			continue;
427: 		}
428: 		if (cast_cost < lowest_cost) {
429: 			best_target = i;
430: 		}
431: 	}
432: 
433: 	if (best_target != DConstants::INVALID_INDEX) {
434: 		by_type = by_types[best_target];
435: 	}
436: 
437: 	auto name = std::move(function.name);
438: 	function = GetDecimalArgMinMaxFunction<OP>(by_type, decimal_type);
439: 	function.name = std::move(name);
440: 	function.return_type = decimal_type;
441: 	return nullptr;
442: }
443: 
444: template <class OP>
445: void AddDecimalArgMinMaxFunctionBy(AggregateFunctionSet &fun, const LogicalType &by_type) {
446: 	fun.AddFunction(AggregateFunction({LogicalTypeId::DECIMAL, by_type}, LogicalTypeId::DECIMAL, nullptr, nullptr,
447: 	                                  nullptr, nullptr, nullptr, nullptr, BindDecimalArgMinMax<OP>));
448: }
449: 
450: template <class OP>
451: void AddGenericArgMinMaxFunction(AggregateFunctionSet &fun) {
452: 	using STATE = ArgMinMaxState<string_t, string_t>;
453: 	fun.AddFunction(
454: 	    AggregateFunction({LogicalType::ANY, LogicalType::ANY}, LogicalType::ANY, AggregateFunction::StateSize<STATE>,
455: 	                      AggregateFunction::StateInitialize<STATE, OP>, OP::template Update<STATE>,
456: 	                      AggregateFunction::StateCombine<STATE, OP>, AggregateFunction::StateVoidFinalize<STATE, OP>,
457: 	                      nullptr, OP::Bind, AggregateFunction::StateDestroy<STATE, OP>));
458: }
459: 
460: template <class COMPARATOR, bool IGNORE_NULL, OrderType ORDER_TYPE>
461: static void AddArgMinMaxFunctions(AggregateFunctionSet &fun) {
462: 	using OP = ArgMinMaxBase<COMPARATOR, IGNORE_NULL>;
463: 	AddArgMinMaxFunctionBy<OP, int32_t>(fun, LogicalType::INTEGER);
464: 	AddArgMinMaxFunctionBy<OP, int64_t>(fun, LogicalType::BIGINT);
465: 	AddArgMinMaxFunctionBy<OP, double>(fun, LogicalType::DOUBLE);
466: 	AddArgMinMaxFunctionBy<OP, string_t>(fun, LogicalType::VARCHAR);
467: 	AddArgMinMaxFunctionBy<OP, date_t>(fun, LogicalType::DATE);
468: 	AddArgMinMaxFunctionBy<OP, timestamp_t>(fun, LogicalType::TIMESTAMP);
469: 	AddArgMinMaxFunctionBy<OP, timestamp_t>(fun, LogicalType::TIMESTAMP_TZ);
470: 	AddArgMinMaxFunctionBy<OP, string_t>(fun, LogicalType::BLOB);
471: 
472: 	auto by_types = ArgMaxByTypes();
473: 	for (const auto &by_type : by_types) {
474: 		AddDecimalArgMinMaxFunctionBy<OP>(fun, by_type);
475: 	}
476: 
477: 	using VECTOR_OP = VectorArgMinMaxBase<COMPARATOR, IGNORE_NULL, ORDER_TYPE>;
478: 	AddVectorArgMinMaxFunctionBy<VECTOR_OP, string_t>(fun, LogicalType::ANY);
479: 
480: 	// we always use LessThan when using sort keys because the ORDER_TYPE takes care of selecting the lowest or highest
481: 	using GENERIC_VECTOR_OP = VectorArgMinMaxBase<LessThan, IGNORE_NULL, ORDER_TYPE, GenericArgMinMaxState<ORDER_TYPE>>;
482: 	AddGenericArgMinMaxFunction<GENERIC_VECTOR_OP>(fun);
483: }
484: 
485: //------------------------------------------------------------------------------
486: // ArgMinMax(N) Function
487: //------------------------------------------------------------------------------
488: //------------------------------------------------------------------------------
489: // State
490: //------------------------------------------------------------------------------
491: 
492: template <class A, class B, class COMPARATOR>
493: class ArgMinMaxNState {
494: public:
495: 	using VAL_TYPE = A;
496: 	using ARG_TYPE = B;
497: 
498: 	using V = typename VAL_TYPE::TYPE;
499: 	using K = typename ARG_TYPE::TYPE;
500: 
501: 	BinaryAggregateHeap<K, V, COMPARATOR> heap;
502: 
503: 	bool is_initialized = false;
504: 	void Initialize(idx_t nval) {
505: 		heap.Initialize(nval);
506: 		is_initialized = true;
507: 	}
508: };
509: 
510: //------------------------------------------------------------------------------
511: // Operation
512: //------------------------------------------------------------------------------
513: template <class STATE>
514: static void ArgMinMaxNUpdate(Vector inputs[], AggregateInputData &aggr_input, idx_t input_count, Vector &state_vector,
515:                              idx_t count) {
516: 
517: 	auto &val_vector = inputs[0];
518: 	auto &arg_vector = inputs[1];
519: 	auto &n_vector = inputs[2];
520: 
521: 	UnifiedVectorFormat val_format;
522: 	UnifiedVectorFormat arg_format;
523: 	UnifiedVectorFormat n_format;
524: 	UnifiedVectorFormat state_format;
525: 
526: 	auto val_extra_state = STATE::VAL_TYPE::CreateExtraState(val_vector, count);
527: 	auto arg_extra_state = STATE::ARG_TYPE::CreateExtraState(arg_vector, count);
528: 
529: 	STATE::VAL_TYPE::PrepareData(val_vector, count, val_extra_state, val_format);
530: 	STATE::ARG_TYPE::PrepareData(arg_vector, count, arg_extra_state, arg_format);
531: 
532: 	n_vector.ToUnifiedFormat(count, n_format);
533: 	state_vector.ToUnifiedFormat(count, state_format);
534: 
535: 	auto states = UnifiedVectorFormat::GetData<STATE *>(state_format);
536: 
537: 	for (idx_t i = 0; i < count; i++) {
538: 		const auto arg_idx = arg_format.sel->get_index(i);
539: 		const auto val_idx = val_format.sel->get_index(i);
540: 		if (!arg_format.validity.RowIsValid(arg_idx) || !val_format.validity.RowIsValid(val_idx)) {
541: 			continue;
542: 		}
543: 		const auto state_idx = state_format.sel->get_index(i);
544: 		auto &state = *states[state_idx];
545: 
546: 		// Initialize the heap if necessary and add the input to the heap
547: 		if (!state.is_initialized) {
548: 			static constexpr int64_t MAX_N = 1000000;
549: 			const auto nidx = n_format.sel->get_index(i);
550: 			if (!n_format.validity.RowIsValid(nidx)) {
551: 				throw InvalidInputException("Invalid input for arg_min/arg_max: n value cannot be NULL");
552: 			}
553: 			const auto nval = UnifiedVectorFormat::GetData<int64_t>(n_format)[nidx];
554: 			if (nval <= 0) {
555: 				throw InvalidInputException("Invalid input for arg_min/arg_max: n value must be > 0");
556: 			}
557: 			if (nval >= MAX_N) {
558: 				throw InvalidInputException("Invalid input for arg_min/arg_max: n value must be < %d", MAX_N);
559: 			}
560: 			state.Initialize(UnsafeNumericCast<idx_t>(nval));
561: 		}
562: 
563: 		// Now add the input to the heap
564: 		auto arg_val = STATE::ARG_TYPE::Create(arg_format, arg_idx);
565: 		auto val_val = STATE::VAL_TYPE::Create(val_format, val_idx);
566: 
567: 		state.heap.Insert(aggr_input.allocator, arg_val, val_val);
568: 	}
569: }
570: 
571: //------------------------------------------------------------------------------
572: // Bind
573: //------------------------------------------------------------------------------
574: template <class VAL_TYPE, class ARG_TYPE, class COMPARATOR>
575: static void SpecializeArgMinMaxNFunction(AggregateFunction &function) {
576: 	using STATE = ArgMinMaxNState<VAL_TYPE, ARG_TYPE, COMPARATOR>;
577: 	using OP = MinMaxNOperation;
578: 
579: 	function.state_size = AggregateFunction::StateSize<STATE>;
580: 	function.initialize = AggregateFunction::StateInitialize<STATE, OP>;
581: 	function.combine = AggregateFunction::StateCombine<STATE, OP>;
582: 	function.destructor = AggregateFunction::StateDestroy<STATE, OP>;
583: 
584: 	function.finalize = MinMaxNOperation::Finalize<STATE>;
585: 	function.update = ArgMinMaxNUpdate<STATE>;
586: }
587: 
588: template <class VAL_TYPE, class COMPARATOR>
589: static void SpecializeArgMinMaxNFunction(PhysicalType arg_type, AggregateFunction &function) {
590: 	switch (arg_type) {
591: 	case PhysicalType::VARCHAR:
592: 		SpecializeArgMinMaxNFunction<VAL_TYPE, MinMaxStringValue, COMPARATOR>(function);
593: 		break;
594: 	case PhysicalType::INT32:
595: 		SpecializeArgMinMaxNFunction<VAL_TYPE, MinMaxFixedValue<int32_t>, COMPARATOR>(function);
596: 		break;
597: 	case PhysicalType::INT64:
598: 		SpecializeArgMinMaxNFunction<VAL_TYPE, MinMaxFixedValue<int64_t>, COMPARATOR>(function);
599: 		break;
600: 	case PhysicalType::FLOAT:
601: 		SpecializeArgMinMaxNFunction<VAL_TYPE, MinMaxFixedValue<float>, COMPARATOR>(function);
602: 		break;
603: 	case PhysicalType::DOUBLE:
604: 		SpecializeArgMinMaxNFunction<VAL_TYPE, MinMaxFixedValue<double>, COMPARATOR>(function);
605: 		break;
606: 	default:
607: 		SpecializeArgMinMaxNFunction<VAL_TYPE, MinMaxFallbackValue, COMPARATOR>(function);
608: 		break;
609: 	}
610: }
611: 
612: template <class COMPARATOR>
613: static void SpecializeArgMinMaxNFunction(PhysicalType val_type, PhysicalType arg_type, AggregateFunction &function) {
614: 	switch (val_type) {
615: 	case PhysicalType::VARCHAR:
616: 		SpecializeArgMinMaxNFunction<MinMaxStringValue, COMPARATOR>(arg_type, function);
617: 		break;
618: 	case PhysicalType::INT32:
619: 		SpecializeArgMinMaxNFunction<MinMaxFixedValue<int32_t>, COMPARATOR>(arg_type, function);
620: 		break;
621: 	case PhysicalType::INT64:
622: 		SpecializeArgMinMaxNFunction<MinMaxFixedValue<int64_t>, COMPARATOR>(arg_type, function);
623: 		break;
624: 	case PhysicalType::FLOAT:
625: 		SpecializeArgMinMaxNFunction<MinMaxFixedValue<float>, COMPARATOR>(arg_type, function);
626: 		break;
627: 	case PhysicalType::DOUBLE:
628: 		SpecializeArgMinMaxNFunction<MinMaxFixedValue<double>, COMPARATOR>(arg_type, function);
629: 		break;
630: 	default:
631: 		SpecializeArgMinMaxNFunction<MinMaxFallbackValue, COMPARATOR>(arg_type, function);
632: 		break;
633: 	}
634: }
635: 
636: template <class COMPARATOR>
637: unique_ptr<FunctionData> ArgMinMaxNBind(ClientContext &context, AggregateFunction &function,
638:                                         vector<unique_ptr<Expression>> &arguments) {
639: 	for (auto &arg : arguments) {
640: 		if (arg->return_type.id() == LogicalTypeId::UNKNOWN) {
641: 			throw ParameterNotResolvedException();
642: 		}
643: 	}
644: 
645: 	const auto val_type = arguments[0]->return_type.InternalType();
646: 	const auto arg_type = arguments[1]->return_type.InternalType();
647: 
648: 	// Specialize the function based on the input types
649: 	SpecializeArgMinMaxNFunction<COMPARATOR>(val_type, arg_type, function);
650: 
651: 	function.return_type = LogicalType::LIST(arguments[0]->return_type);
652: 	return nullptr;
653: }
654: 
655: template <class COMPARATOR>
656: static void AddArgMinMaxNFunction(AggregateFunctionSet &set) {
657: 	AggregateFunction function({LogicalTypeId::ANY, LogicalTypeId::ANY, LogicalType::BIGINT},
658: 	                           LogicalType::LIST(LogicalType::ANY), nullptr, nullptr, nullptr, nullptr, nullptr,
659: 	                           nullptr, ArgMinMaxNBind<COMPARATOR>);
660: 
661: 	return set.AddFunction(function);
662: }
663: 
664: //------------------------------------------------------------------------------
665: // Function Registration
666: //------------------------------------------------------------------------------
667: 
668: AggregateFunctionSet ArgMinFun::GetFunctions() {
669: 	AggregateFunctionSet fun;
670: 	AddArgMinMaxFunctions<LessThan, true, OrderType::ASCENDING>(fun);
671: 	AddArgMinMaxNFunction<LessThan>(fun);
672: 	return fun;
673: }
674: 
675: AggregateFunctionSet ArgMaxFun::GetFunctions() {
676: 	AggregateFunctionSet fun;
677: 	AddArgMinMaxFunctions<GreaterThan, true, OrderType::DESCENDING>(fun);
678: 	AddArgMinMaxNFunction<GreaterThan>(fun);
679: 	return fun;
680: }
681: 
682: AggregateFunctionSet ArgMinNullFun::GetFunctions() {
683: 	AggregateFunctionSet fun;
684: 	AddArgMinMaxFunctions<LessThan, false, OrderType::ASCENDING>(fun);
685: 	return fun;
686: }
687: 
688: AggregateFunctionSet ArgMaxNullFun::GetFunctions() {
689: 	AggregateFunctionSet fun;
690: 	AddArgMinMaxFunctions<GreaterThan, false, OrderType::DESCENDING>(fun);
691: 	return fun;
692: }
693: 
694: } // namespace duckdb
[end of src/core_functions/aggregate/distributive/arg_min_max.cpp]
[start of src/include/duckdb/core_functions/aggregate/minmax_n_helpers.hpp]
1: #pragma once
2: 
3: #include "duckdb/common/vector.hpp"
4: #include "duckdb/common/algorithm.hpp"
5: 
6: namespace duckdb {
7: 
8: // For basic types
9: template <class T>
10: struct HeapEntry {
11: 	T value;
12: 
13: 	void Assign(ArenaAllocator &allocator, const T &val) {
14: 		value = val;
15: 	}
16: };
17: 
18: // For strings that require arena allocation
19: template <>
20: struct HeapEntry<string_t> {
21: 	string_t value;
22: 	uint32_t capacity;
23: 	data_ptr_t allocated_data;
24: 
25: 	HeapEntry() : value(), capacity(0), allocated_data(nullptr) {
26: 	}
27: 
28: 	// Not copyable
29: 	HeapEntry(const HeapEntry &other) = delete;
30: 	HeapEntry &operator=(const HeapEntry &other) = delete;
31: 
32: 	// But movable
33: 	HeapEntry(HeapEntry &&other) noexcept {
34: 		if (other.value.IsInlined()) {
35: 			value = other.value;
36: 		} else {
37: 			capacity = other.capacity;
38: 			allocated_data = other.allocated_data;
39: 			value = string_t(const_char_ptr_cast(allocated_data), UnsafeNumericCast<uint32_t>(other.value.GetSize()));
40: 			other.allocated_data = nullptr;
41: 		}
42: 	}
43: 
44: 	HeapEntry &operator=(HeapEntry &&other) noexcept {
45: 		if (other.value.IsInlined()) {
46: 			value = other.value;
47: 		} else {
48: 			capacity = other.capacity;
49: 			allocated_data = other.allocated_data;
50: 			value = string_t(const_char_ptr_cast(allocated_data), UnsafeNumericCast<uint32_t>(other.value.GetSize()));
51: 			other.allocated_data = nullptr;
52: 		}
53: 		return *this;
54: 	}
55: 
56: 	void Assign(ArenaAllocator &allocator, const string_t &new_val) {
57: 		if (new_val.IsInlined()) {
58: 			value = new_val;
59: 			return;
60: 		}
61: 
62: 		// Short path for first assignment
63: 		if (allocated_data == nullptr) {
64: 			auto new_size = UnsafeNumericCast<uint32_t>(new_val.GetSize());
65: 			auto new_capacity = NextPowerOfTwo(new_size);
66: 			if (new_capacity > string_t::MAX_STRING_SIZE) {
67: 				throw InvalidInputException("Resulting string/blob too large!");
68: 			}
69: 			capacity = UnsafeNumericCast<uint32_t>(new_capacity);
70: 			allocated_data = allocator.Allocate(capacity);
71: 			memcpy(allocated_data, new_val.GetData(), new_size);
72: 			value = string_t(const_char_ptr_cast(allocated_data), new_size);
73: 			return;
74: 		}
75: 
76: 		// double allocation until value fits
77: 		if (capacity < new_val.GetSize()) {
78: 			auto old_size = capacity;
79: 			capacity *= 2;
80: 			while (capacity < new_val.GetSize()) {
81: 				capacity *= 2;
82: 			}
83: 			allocated_data = allocator.Reallocate(allocated_data, old_size, capacity);
84: 		}
85: 		auto new_size = UnsafeNumericCast<uint32_t>(new_val.GetSize());
86: 		memcpy(allocated_data, new_val.GetData(), new_size);
87: 		value = string_t(const_char_ptr_cast(allocated_data), new_size);
88: 	}
89: };
90: 
91: template <class T, class T_COMPARATOR>
92: class UnaryAggregateHeap {
93: public:
94: 	UnaryAggregateHeap() = default;
95: 
96: 	explicit UnaryAggregateHeap(idx_t capacity_p) : capacity(capacity_p) {
97: 		heap.reserve(capacity);
98: 	}
99: 
100: 	void Initialize(const idx_t capacity_p) {
101: 		capacity = capacity_p;
102: 		heap.reserve(capacity);
103: 	}
104: 
105: 	bool IsEmpty() const {
106: 		return heap.empty();
107: 	}
108: 	idx_t Size() const {
109: 		return heap.size();
110: 	}
111: 	idx_t Capacity() const {
112: 		return capacity;
113: 	}
114: 
115: 	void Insert(ArenaAllocator &allocator, const T &value) {
116: 		D_ASSERT(capacity != 0); // must be initialized
117: 
118: 		// If the heap is not full, insert the value into a new slot
119: 		if (heap.size() < capacity) {
120: 			heap.emplace_back();
121: 			heap.back().Assign(allocator, value);
122: 			std::push_heap(heap.begin(), heap.end(), Compare);
123: 		}
124: 		// If the heap is full, check if the value is greater than the smallest value in the heap
125: 		// If it is, assign the new value to the slot and re-heapify
126: 		else if (T_COMPARATOR::Operation(value, heap.front().value)) {
127: 			std::pop_heap(heap.begin(), heap.end(), Compare);
128: 			heap.back().Assign(allocator, value);
129: 			std::push_heap(heap.begin(), heap.end(), Compare);
130: 		}
131: 		D_ASSERT(std::is_heap(heap.begin(), heap.end(), Compare));
132: 	}
133: 
134: 	void Insert(ArenaAllocator &allocator, const UnaryAggregateHeap &other) {
135: 		for (auto &slot : other.heap) {
136: 			Insert(allocator, slot.value);
137: 		}
138: 	}
139: 
140: 	vector<HeapEntry<T>> &SortAndGetHeap() {
141: 		std::sort_heap(heap.begin(), heap.end(), Compare);
142: 		return heap;
143: 	}
144: 
145: 	static const T &GetValue(const HeapEntry<T> &slot) {
146: 		return slot.value;
147: 	}
148: 
149: private:
150: 	static bool Compare(const HeapEntry<T> &left, const HeapEntry<T> &right) {
151: 		return T_COMPARATOR::Operation(left.value, right.value);
152: 	}
153: 
154: 	vector<HeapEntry<T>> heap;
155: 	idx_t capacity;
156: };
157: 
158: template <class K, class V, class K_COMPARATOR>
159: class BinaryAggregateHeap {
160: 	using STORAGE_TYPE = pair<HeapEntry<K>, HeapEntry<V>>;
161: 
162: public:
163: 	BinaryAggregateHeap() = default;
164: 
165: 	explicit BinaryAggregateHeap(idx_t capacity_p) : capacity(capacity_p) {
166: 		heap.reserve(capacity);
167: 	}
168: 
169: 	void Initialize(const idx_t capacity_p) {
170: 		capacity = capacity_p;
171: 		heap.reserve(capacity);
172: 	}
173: 
174: 	bool IsEmpty() const {
175: 		return heap.empty();
176: 	}
177: 	idx_t Size() const {
178: 		return heap.size();
179: 	}
180: 	idx_t Capacity() const {
181: 		return capacity;
182: 	}
183: 
184: 	void Insert(ArenaAllocator &allocator, const K &key, const V &value) {
185: 		D_ASSERT(capacity != 0); // must be initialized
186: 
187: 		// If the heap is not full, insert the value into a new slot
188: 		if (heap.size() < capacity) {
189: 			heap.emplace_back();
190: 			heap.back().first.Assign(allocator, key);
191: 			heap.back().second.Assign(allocator, value);
192: 			std::push_heap(heap.begin(), heap.end(), Compare);
193: 		}
194: 		// If the heap is full, check if the value is greater than the smallest value in the heap
195: 		// If it is, assign the new value to the slot and re-heapify
196: 		else if (K_COMPARATOR::Operation(key, heap.front().first.value)) {
197: 			std::pop_heap(heap.begin(), heap.end(), Compare);
198: 			heap.back().first.Assign(allocator, key);
199: 			heap.back().second.Assign(allocator, value);
200: 			std::push_heap(heap.begin(), heap.end(), Compare);
201: 		}
202: 		D_ASSERT(std::is_heap(heap.begin(), heap.end(), Compare));
203: 	}
204: 
205: 	void Insert(ArenaAllocator &allocator, const BinaryAggregateHeap &other) {
206: 		for (auto &slot : other.heap) {
207: 			Insert(allocator, slot.first.value, slot.second.value);
208: 		}
209: 	}
210: 
211: 	vector<STORAGE_TYPE> &SortAndGetHeap() {
212: 		std::sort_heap(heap.begin(), heap.end(), Compare);
213: 		return heap;
214: 	}
215: 
216: 	static const V &GetValue(const STORAGE_TYPE &slot) {
217: 		return slot.second.value;
218: 	}
219: 
220: private:
221: 	static bool Compare(const STORAGE_TYPE &left, const STORAGE_TYPE &right) {
222: 		return K_COMPARATOR::Operation(left.first.value, right.first.value);
223: 	}
224: 
225: 	vector<STORAGE_TYPE> heap;
226: 	idx_t capacity;
227: };
228: 
229: //------------------------------------------------------------------------------
230: // Specializations for fixed size types, strings, and anything else (using sortkey)
231: //------------------------------------------------------------------------------
232: template <class T>
233: struct MinMaxFixedValue {
234: 	using TYPE = T;
235: 	using EXTRA_STATE = bool;
236: 
237: 	static TYPE Create(const UnifiedVectorFormat &format, const idx_t idx) {
238: 		return UnifiedVectorFormat::GetData<T>(format)[idx];
239: 	}
240: 
241: 	static void Assign(Vector &vector, const idx_t idx, const TYPE &value) {
242: 		FlatVector::GetData<T>(vector)[idx] = value;
243: 	}
244: 
245: 	// Nothing to do here
246: 	static EXTRA_STATE CreateExtraState(Vector &input, idx_t count) {
247: 		return false;
248: 	}
249: 
250: 	static void PrepareData(Vector &input, const idx_t count, EXTRA_STATE &, UnifiedVectorFormat &format) {
251: 		input.ToUnifiedFormat(count, format);
252: 	}
253: };
254: 
255: struct MinMaxStringValue {
256: 	using TYPE = string_t;
257: 	using EXTRA_STATE = bool;
258: 
259: 	static TYPE Create(const UnifiedVectorFormat &format, const idx_t idx) {
260: 		return UnifiedVectorFormat::GetData<string_t>(format)[idx];
261: 	}
262: 
263: 	static void Assign(Vector &vector, const idx_t idx, const TYPE &value) {
264: 		FlatVector::GetData<string_t>(vector)[idx] = StringVector::AddStringOrBlob(vector, value);
265: 	}
266: 
267: 	// Nothing to do here
268: 	static EXTRA_STATE CreateExtraState(Vector &input, idx_t count) {
269: 		return false;
270: 	}
271: 
272: 	static void PrepareData(Vector &input, const idx_t count, EXTRA_STATE &, UnifiedVectorFormat &format) {
273: 		input.ToUnifiedFormat(count, format);
274: 	}
275: };
276: 
277: // Use sort key to serialize/deserialize values
278: struct MinMaxFallbackValue {
279: 	using TYPE = string_t;
280: 	using EXTRA_STATE = Vector;
281: 
282: 	static TYPE Create(const UnifiedVectorFormat &format, const idx_t idx) {
283: 		return UnifiedVectorFormat::GetData<string_t>(format)[idx];
284: 	}
285: 
286: 	static void Assign(Vector &vector, const idx_t idx, const TYPE &value) {
287: 		OrderModifiers modifiers(OrderType::ASCENDING, OrderByNullType::NULLS_LAST);
288: 		CreateSortKeyHelpers::DecodeSortKey(value, vector, idx, modifiers);
289: 	}
290: 
291: 	static EXTRA_STATE CreateExtraState(Vector &input, idx_t count) {
292: 		return Vector(LogicalTypeId::BLOB);
293: 	}
294: 
295: 	static void PrepareData(Vector &input, const idx_t count, EXTRA_STATE &extra_state, UnifiedVectorFormat &format) {
296: 		const OrderModifiers modifiers(OrderType::ASCENDING, OrderByNullType::NULLS_LAST);
297: 		CreateSortKeyHelpers::CreateSortKey(input, count, modifiers, extra_state);
298: 		input.Flatten(count);
299: 		extra_state.Flatten(count);
300: 		// Ensure the validity vectors match, because we want to ignore nulls
301: 		FlatVector::Validity(extra_state).Initialize(FlatVector::Validity(input));
302: 		extra_state.ToUnifiedFormat(count, format);
303: 	}
304: };
305: 
306: //------------------------------------------------------------------------------
307: // MinMaxN Operation (common for both ArgMinMaxN and MinMaxN)
308: //------------------------------------------------------------------------------
309: struct MinMaxNOperation {
310: 	template <class STATE>
311: 	static void Initialize(STATE &state) {
312: 		new (&state) STATE();
313: 	}
314: 
315: 	template <class STATE, class OP>
316: 	static void Combine(const STATE &source, STATE &target, AggregateInputData &aggr_input) {
317: 		if (!source.is_initialized) {
318: 			// source is empty, nothing to do
319: 			return;
320: 		}
321: 
322: 		if (!target.is_initialized) {
323: 			target.Initialize(source.heap.Capacity());
324: 		} else if (source.heap.Capacity() != target.heap.Capacity()) {
325: 			throw InvalidInputException("Mismatched n values in min/max/arg_min/arg_max");
326: 		}
327: 
328: 		// Merge the heaps
329: 		target.heap.Insert(aggr_input.allocator, source.heap);
330: 	}
331: 
332: 	template <class STATE>
333: 	static void Finalize(Vector &state_vector, AggregateInputData &, Vector &result, idx_t count, idx_t offset) {
334: 
335: 		UnifiedVectorFormat state_format;
336: 		state_vector.ToUnifiedFormat(count, state_format);
337: 
338: 		const auto states = UnifiedVectorFormat::GetData<STATE *>(state_format);
339: 		auto &mask = FlatVector::Validity(result);
340: 
341: 		const auto old_len = ListVector::GetListSize(result);
342: 
343: 		// Count the number of new entries
344: 		idx_t new_entries = 0;
345: 		for (idx_t i = 0; i < count; i++) {
346: 			const auto state_idx = state_format.sel->get_index(i);
347: 			auto &state = *states[state_idx];
348: 			new_entries += state.heap.Size();
349: 		}
350: 
351: 		// Resize the list vector to fit the new entries
352: 		ListVector::Reserve(result, old_len + new_entries);
353: 
354: 		const auto list_entries = FlatVector::GetData<list_entry_t>(result);
355: 		auto &child_data = ListVector::GetEntry(result);
356: 
357: 		idx_t current_offset = old_len;
358: 		for (idx_t i = 0; i < count; i++) {
359: 			const auto rid = i + offset;
360: 			const auto state_idx = state_format.sel->get_index(i);
361: 			auto &state = *states[state_idx];
362: 
363: 			if (!state.is_initialized || state.heap.IsEmpty()) {
364: 				mask.SetInvalid(rid);
365: 				continue;
366: 			}
367: 
368: 			// Add the entries to the list vector
369: 			auto &list_entry = list_entries[rid];
370: 			list_entry.offset = current_offset;
371: 			list_entry.length = state.heap.Size();
372: 
373: 			// Turn the heap into a sorted list, invalidating the heap property
374: 			auto &heap = state.heap.SortAndGetHeap();
375: 
376: 			for (const auto &slot : heap) {
377: 				STATE::VAL_TYPE::Assign(child_data, current_offset++, state.heap.GetValue(slot));
378: 			}
379: 		}
380: 
381: 		D_ASSERT(current_offset == old_len + new_entries);
382: 		ListVector::SetListSize(result, current_offset);
383: 		result.Verify(count);
384: 	}
385: 
386: 	template <class STATE>
387: 	static void Destroy(STATE &state, AggregateInputData &aggr_input_data) {
388: 		state.~STATE();
389: 	}
390: 
391: 	static bool IgnoreNull() {
392: 		return true;
393: 	}
394: };
395: 
396: } // namespace duckdb
[end of src/include/duckdb/core_functions/aggregate/minmax_n_helpers.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: