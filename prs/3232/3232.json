{
  "repo": "duckdb/duckdb",
  "pull_number": 3232,
  "instance_id": "duckdb__duckdb-3232",
  "issue_numbers": [
    "3223",
    "3223"
  ],
  "base_commit": "b651228285e430d5e70731ac62beb66d6c1803e4",
  "patch": "diff --git a/src/include/duckdb/optimizer/filter_pushdown.hpp b/src/include/duckdb/optimizer/filter_pushdown.hpp\nindex 8a207602dbad..394448aec750 100644\n--- a/src/include/duckdb/optimizer/filter_pushdown.hpp\n+++ b/src/include/duckdb/optimizer/filter_pushdown.hpp\n@@ -53,6 +53,8 @@ class FilterPushdown {\n \tunique_ptr<LogicalOperator> PushdownSetOperation(unique_ptr<LogicalOperator> op);\n \t//! Push down a LogicalGet op\n \tunique_ptr<LogicalOperator> PushdownGet(unique_ptr<LogicalOperator> op);\n+\t//! Push down a LogicalLimit op\n+\tunique_ptr<LogicalOperator> PushdownLimit(unique_ptr<LogicalOperator> op);\n \t// Pushdown an inner join\n \tunique_ptr<LogicalOperator> PushdownInnerJoin(unique_ptr<LogicalOperator> op, unordered_set<idx_t> &left_bindings,\n \t                                              unordered_set<idx_t> &right_bindings);\ndiff --git a/src/optimizer/filter_pushdown.cpp b/src/optimizer/filter_pushdown.cpp\nindex 42eaa57a24f8..72f3cc7dbf2c 100644\n--- a/src/optimizer/filter_pushdown.cpp\n+++ b/src/optimizer/filter_pushdown.cpp\n@@ -35,6 +35,8 @@ unique_ptr<LogicalOperator> FilterPushdown::Rewrite(unique_ptr<LogicalOperator>\n \t}\n \tcase LogicalOperatorType::LOGICAL_GET:\n \t\treturn PushdownGet(move(op));\n+\tcase LogicalOperatorType::LOGICAL_LIMIT:\n+\t\treturn PushdownLimit(move(op));\n \tdefault:\n \t\treturn FinishPushdown(move(op));\n \t}\ndiff --git a/src/optimizer/pushdown/CMakeLists.txt b/src/optimizer/pushdown/CMakeLists.txt\nindex a514ac7e4718..1c2ff2e4f141 100644\n--- a/src/optimizer/pushdown/CMakeLists.txt\n+++ b/src/optimizer/pushdown/CMakeLists.txt\n@@ -6,6 +6,7 @@ add_library_unity(\n   pushdown_filter.cpp\n   pushdown_get.cpp\n   pushdown_inner_join.cpp\n+  pushdown_limit.cpp\n   pushdown_left_join.cpp\n   pushdown_mark_join.cpp\n   pushdown_projection.cpp\ndiff --git a/src/optimizer/pushdown/pushdown_limit.cpp b/src/optimizer/pushdown/pushdown_limit.cpp\nnew file mode 100644\nindex 000000000000..047898e02e4b\n--- /dev/null\n+++ b/src/optimizer/pushdown/pushdown_limit.cpp\n@@ -0,0 +1,19 @@\n+#include \"duckdb/optimizer/filter_pushdown.hpp\"\n+#include \"duckdb/optimizer/optimizer.hpp\"\n+#include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n+#include \"duckdb/planner/operator/logical_empty_result.hpp\"\n+#include \"duckdb/planner/operator/logical_limit.hpp\"\n+\n+namespace duckdb {\n+\n+unique_ptr<LogicalOperator> FilterPushdown::PushdownLimit(unique_ptr<LogicalOperator> op) {\n+\tauto &limit = (LogicalLimit &)*op;\n+\n+\tif (!limit.limit && limit.limit_val == 0) {\n+\t\treturn make_unique<LogicalEmptyResult>(move(op));\n+\t}\n+\n+\treturn FinishPushdown(move(op));\n+}\n+\n+} // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/limit/test_limit0.test b/test/sql/limit/test_limit0.test\nnew file mode 100644\nindex 000000000000..862350764e81\n--- /dev/null\n+++ b/test/sql/limit/test_limit0.test\n@@ -0,0 +1,17 @@\n+# name: test/sql/limit/test_limit0.test\n+# description: Test limit 0\n+# group: [limit]\n+\n+# not running with verification on purpose, since running this without the optimizer will take forever\n+query I\n+SELECT * FROM (SELECT SUM(i) FROM range(100000000000) tbl(i)) LIMIT 0;\n+----\n+\n+statement ok\n+PRAGMA explain_output='OPTIMIZED_ONLY'\n+\n+query II nosort emptyset\n+EXPLAIN SELECT * FROM (SELECT SUM(i) FROM range(100000000000) tbl(i)) LIMIT 0;\n+\n+query II nosort emptyset\n+EXPLAIN SELECT * FROM (SELECT SUM(i) FROM range(100000000000) tbl(i)) WHERE 1=0;\n",
  "problem_statement": "Optimize queries with `LIMIT 0`\nAn optimizer for short-circuiting the execution of queries with `LIMIT 0` would be a nice feature. It would allow you to do some nice stuff as a DuckDB library user:\r\n\r\n* Easily determine the query's schema, not only in SQL but also the equivalent schema in `arrow` and/or `pandas`. Then you could do stuff like `relation.limit(0).to_df()` and `relation.limit(0).to_arrow_table()`.\r\n* Create an empty relation which is still `UNION`-compatible with other non-empty relations, without incurring a runtime cost. Allowing you to use such empty relations like a [null object](https://en.wikipedia.org/wiki/Null_object_pattern) of sorts.\r\n\r\nIf the use cases are unclear, I can write up some better examples \u263a\ufe0f \nOptimize queries with `LIMIT 0`\nAn optimizer for short-circuiting the execution of queries with `LIMIT 0` would be a nice feature. It would allow you to do some nice stuff as a DuckDB library user:\r\n\r\n* Easily determine the query's schema, not only in SQL but also the equivalent schema in `arrow` and/or `pandas`. Then you could do stuff like `relation.limit(0).to_df()` and `relation.limit(0).to_arrow_table()`.\r\n* Create an empty relation which is still `UNION`-compatible with other non-empty relations, without incurring a runtime cost. Allowing you to use such empty relations like a [null object](https://en.wikipedia.org/wiki/Null_object_pattern) of sorts.\r\n\r\nIf the use cases are unclear, I can write up some better examples \u263a\ufe0f \n",
  "hints_text": "\n",
  "created_at": "2022-03-15T09:33:48Z"
}