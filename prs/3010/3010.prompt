You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
  duckdb_prepare_R: Unknown column type for prepare: TIMESTAMP (NS)
#### What happens?

`arrow::to_duckdb()` fails to handle TIMESTAMP data in NS format in parquet files which duckdb created.  

#### To Reproduce

- I export data from duckdb to parquet; works as expected.
- I read the parquet with `arrow::open_dataset` from R, works as expected
- I try `arrow::to_duckb()` and get the error on any timestamp-type column

```
  duckdb_prepare_R: Unknown column type for prepare: TIMESTAMP (NS)
```

(Guessing this is a just a datatype that still needs to be implemented on the parquet reader, at least for the R client?  lemme know if a copy-paste example of R would help)

#### Environment (please complete the following information):
 - OS: Linux
 - DuckDB Version: current
 - DuckDB Client: R

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of tools/rpkg/src/statement.cpp]
1: #include "rapi.hpp"
2: #include "typesr.hpp"
3: #include "altrepstring.hpp"
4: 
5: #include "duckdb/common/arrow.hpp"
6: #include "duckdb/common/types/timestamp.hpp"
7: #include "duckdb/common/arrow_wrapper.hpp"
8: #include "duckdb/common/result_arrow_wrapper.hpp"
9: 
10: using namespace duckdb;
11: 
12: // converter for primitive types
13: template <class SRC, class DEST>
14: static void VectorToR(Vector &src_vec, size_t count, void *dest, uint64_t dest_offset, DEST na_val) {
15: 	auto src_ptr = FlatVector::GetData<SRC>(src_vec);
16: 	auto &mask = FlatVector::Validity(src_vec);
17: 	auto dest_ptr = ((DEST *)dest) + dest_offset;
18: 	for (size_t row_idx = 0; row_idx < count; row_idx++) {
19: 		dest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? na_val : src_ptr[row_idx];
20: 	}
21: }
22: 
23: SEXP RApi::Release(SEXP stmtsexp) {
24: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
25: 		cpp11::stop("duckdb_release_R: Need external pointer parameter");
26: 	}
27: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
28: 	if (stmtsexp) {
29: 		R_ClearExternalPtr(stmtsexp);
30: 		delete stmtholder;
31: 	}
32: 	return R_NilValue;
33: }
34: 
35: static SEXP duckdb_finalize_statement_R(SEXP stmtsexp) {
36: 	return RApi::Release(stmtsexp);
37: }
38: 
39: SEXP RApi::Prepare(SEXP connsexp, SEXP querysexp) {
40: 	RProtector r;
41: 	if (TYPEOF(querysexp) != STRSXP || Rf_length(querysexp) != 1) {
42: 		cpp11::stop("duckdb_prepare_R: Need single string parameter for query");
43: 	}
44: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
45: 		cpp11::stop("duckdb_prepare_R: Need external pointer parameter for connections");
46: 	}
47: 
48: 	char *query = (char *)CHAR(STRING_ELT(querysexp, 0));
49: 	if (!query) {
50: 		cpp11::stop("duckdb_prepare_R: No query");
51: 	}
52: 
53: 	auto conn_wrapper = (ConnWrapper *)R_ExternalPtrAddr(connsexp);
54: 	if (!conn_wrapper || !conn_wrapper->conn) {
55: 		cpp11::stop("duckdb_prepare_R: Invalid connection");
56: 	}
57: 
58: 	auto stmt = conn_wrapper->conn->Prepare(query);
59: 	if (!stmt->success) {
60: 		cpp11::stop("duckdb_prepare_R: Failed to prepare query %s\nError: %s", query, stmt->error.c_str());
61: 	}
62: 
63: 	auto stmtholder = new RStatement();
64: 	stmtholder->stmt = move(stmt);
65: 
66: 	cpp11::list retlist(NEW_LIST(6));
67: 
68: 	SEXP stmtsexp = r.Protect(R_MakeExternalPtr(stmtholder, R_NilValue, R_NilValue));
69: 	R_RegisterCFinalizer(stmtsexp, (void (*)(SEXP))duckdb_finalize_statement_R);
70: 
71: 	SET_NAMES(retlist, RStrings::get().str_ref_type_names_rtypes_n_param_str);
72: 
73: 	SET_VECTOR_ELT(retlist, 0, querysexp);
74: 	SET_VECTOR_ELT(retlist, 1, stmtsexp);
75: 
76: 	SEXP stmt_type = RApi::StringsToSexp({StatementTypeToString(stmtholder->stmt->GetStatementType())});
77: 	SET_VECTOR_ELT(retlist, 2, stmt_type);
78: 
79: 	SEXP col_names = RApi::StringsToSexp(stmtholder->stmt->GetNames());
80: 	SET_VECTOR_ELT(retlist, 3, col_names);
81: 
82: 	vector<string> rtypes;
83: 
84: 	for (auto &stype : stmtholder->stmt->GetTypes()) {
85: 		string rtype = "";
86: 		switch (stype.id()) {
87: 		case LogicalTypeId::BOOLEAN:
88: 			rtype = "logical";
89: 			break;
90: 		case LogicalTypeId::UTINYINT:
91: 		case LogicalTypeId::TINYINT:
92: 		case LogicalTypeId::USMALLINT:
93: 		case LogicalTypeId::SMALLINT:
94: 		case LogicalTypeId::INTEGER:
95: 			rtype = "integer";
96: 			break;
97: 		case LogicalTypeId::TIMESTAMP:
98: 			rtype = "POSIXct";
99: 			break;
100: 		case LogicalTypeId::DATE:
101: 			rtype = "Date";
102: 			break;
103: 		case LogicalTypeId::TIME:
104: 			rtype = "difftime";
105: 			break;
106: 		case LogicalTypeId::UINTEGER:
107: 		case LogicalTypeId::UBIGINT:
108: 		case LogicalTypeId::BIGINT:
109: 		case LogicalTypeId::HUGEINT:
110: 		case LogicalTypeId::FLOAT:
111: 		case LogicalTypeId::DOUBLE:
112: 		case LogicalTypeId::DECIMAL:
113: 			rtype = "numeric";
114: 			break;
115: 		case LogicalTypeId::VARCHAR:
116: 			rtype = "character";
117: 			break;
118: 		case LogicalTypeId::BLOB:
119: 			rtype = "raw";
120: 			break;
121: 		case LogicalTypeId::LIST:
122: 			rtype = "list";
123: 			break;
124: 		case LogicalTypeId::ENUM:
125: 			rtype = "factor";
126: 			break;
127: 		default:
128: 			cpp11::stop("duckdb_prepare_R: Unknown column type for prepare: %s", stype.ToString().c_str());
129: 			break;
130: 		}
131: 		rtypes.push_back(rtype);
132: 	}
133: 
134: 	SEXP rtypessexp = StringsToSexp(rtypes);
135: 	SET_VECTOR_ELT(retlist, 4, rtypessexp);
136: 
137: 	SET_VECTOR_ELT(retlist, 5, Rf_ScalarInteger(stmtholder->stmt->n_param));
138: 
139: 	return retlist;
140: }
141: 
142: SEXP RApi::Bind(SEXP stmtsexp, SEXP paramsexp, SEXP arrowsexp) {
143: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
144: 		cpp11::stop("duckdb_bind_R: Need external pointer parameter");
145: 	}
146: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
147: 	if (!stmtholder || !stmtholder->stmt) {
148: 		cpp11::stop("duckdb_bind_R: Invalid statement");
149: 	}
150: 
151: 	stmtholder->parameters.clear();
152: 	stmtholder->parameters.resize(stmtholder->stmt->n_param);
153: 
154: 	if (stmtholder->stmt->n_param == 0) {
155: 		cpp11::stop("duckdb_bind_R: dbBind called but query takes no parameters");
156: 	}
157: 
158: 	if (TYPEOF(paramsexp) != VECSXP || (idx_t)Rf_length(paramsexp) != stmtholder->stmt->n_param) {
159: 		cpp11::stop("duckdb_bind_R: bind parameters need to be a list of length %i", stmtholder->stmt->n_param);
160: 	}
161: 
162: 	if (TYPEOF(arrowsexp) != LGLSXP) {
163: 		cpp11::stop("duckdb_bind_R: Need logical for third parameter");
164: 	}
165: 
166: 	bool arrow_fetch = LOGICAL_POINTER(arrowsexp)[0] != 0;
167: 
168: 	R_len_t n_rows = Rf_length(VECTOR_ELT(paramsexp, 0));
169: 
170: 	for (idx_t param_idx = 1; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {
171: 		SEXP valsexp = VECTOR_ELT(paramsexp, param_idx);
172: 		if (Rf_length(valsexp) != n_rows) {
173: 			cpp11::stop("duckdb_bind_R: bind parameter values need to have the same length");
174: 		}
175: 	}
176: 
177: 	if (n_rows != 1 && arrow_fetch) {
178: 		cpp11::stop("duckdb_bind_R: bind parameter values need to have length one for arrow queries");
179: 	}
180: 
181: 	cpp11::list out(NEW_LIST(n_rows));
182: 
183: 	for (idx_t row_idx = 0; row_idx < (size_t)n_rows; ++row_idx) {
184: 		for (idx_t param_idx = 0; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {
185: 			SEXP valsexp = VECTOR_ELT(paramsexp, param_idx);
186: 			auto val = RApiTypes::SexpToValue(valsexp, row_idx);
187: 			stmtholder->parameters[param_idx] = val;
188: 		}
189: 
190: 		// No protection, assigned immediately
191: 		auto exec_result = RApi::Execute(stmtsexp, arrowsexp);
192: 		SET_VECTOR_ELT(out, row_idx, exec_result);
193: 	}
194: 
195: 	return out;
196: }
197: 
198: static SEXP allocate(const LogicalType &type, RProtector &r_varvalue, idx_t nrows) {
199: 	SEXP varvalue = NULL;
200: 	switch (type.id()) {
201: 	case LogicalTypeId::BOOLEAN:
202: 		varvalue = r_varvalue.Protect(NEW_LOGICAL(nrows));
203: 		break;
204: 	case LogicalTypeId::UTINYINT:
205: 	case LogicalTypeId::TINYINT:
206: 	case LogicalTypeId::SMALLINT:
207: 	case LogicalTypeId::USMALLINT:
208: 	case LogicalTypeId::INTEGER:
209: 		varvalue = r_varvalue.Protect(NEW_INTEGER(nrows));
210: 		break;
211: 	case LogicalTypeId::UINTEGER:
212: 	case LogicalTypeId::UBIGINT:
213: 	case LogicalTypeId::BIGINT:
214: 	case LogicalTypeId::HUGEINT:
215: 	case LogicalTypeId::FLOAT:
216: 	case LogicalTypeId::DOUBLE:
217: 	case LogicalTypeId::DECIMAL:
218: 	case LogicalTypeId::TIMESTAMP:
219: 	case LogicalTypeId::DATE:
220: 	case LogicalTypeId::TIME:
221: 		varvalue = r_varvalue.Protect(NEW_NUMERIC(nrows));
222: 		break;
223: 	case LogicalTypeId::LIST:
224: 		varvalue = r_varvalue.Protect(NEW_LIST(nrows));
225: 		break;
226: 	case LogicalTypeId::VARCHAR: {
227: 		auto wrapper = new DuckDBAltrepStringWrapper();
228: 		wrapper->length = nrows;
229: 
230: 		auto ptr = PROTECT(R_MakeExternalPtr((void *)wrapper, R_NilValue, R_NilValue));
231: 		R_RegisterCFinalizer(ptr, AltrepString::Finalize);
232: 		varvalue = r_varvalue.Protect(R_new_altrep(AltrepString::rclass, ptr, R_NilValue));
233: 		UNPROTECT(1);
234: 		break;
235: 	}
236: 
237: 	case LogicalTypeId::BLOB:
238: 		varvalue = r_varvalue.Protect(NEW_LIST(nrows));
239: 		break;
240: 	case LogicalTypeId::ENUM:
241: 		varvalue = r_varvalue.Protect(NEW_INTEGER(nrows));
242: 		break;
243: 	default:
244: 		cpp11::stop("duckdb_execute_R: Unknown column type for execute: %s", type.ToString().c_str());
245: 	}
246: 	if (!varvalue) {
247: 		throw std::bad_alloc();
248: 	}
249: 	return varvalue;
250: }
251: 
252: static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n) {
253: 	switch (src_vec.GetType().id()) {
254: 	case LogicalTypeId::BOOLEAN:
255: 		VectorToR<int8_t, uint32_t>(src_vec, n, LOGICAL_POINTER(dest), dest_offset, NA_LOGICAL);
256: 		break;
257: 	case LogicalTypeId::UTINYINT:
258: 		VectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
259: 		break;
260: 	case LogicalTypeId::TINYINT:
261: 		VectorToR<int8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
262: 		break;
263: 	case LogicalTypeId::USMALLINT:
264: 		VectorToR<uint16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
265: 		break;
266: 	case LogicalTypeId::SMALLINT:
267: 		VectorToR<int16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
268: 		break;
269: 	case LogicalTypeId::INTEGER:
270: 		VectorToR<int32_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
271: 		break;
272: 	case LogicalTypeId::TIMESTAMP: {
273: 		auto src_data = FlatVector::GetData<timestamp_t>(src_vec);
274: 		auto &mask = FlatVector::Validity(src_vec);
275: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
276: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
277: 			dest_ptr[row_idx] =
278: 			    !mask.RowIsValid(row_idx) ? NA_REAL : (double)Timestamp::GetEpochSeconds(src_data[row_idx]);
279: 		}
280: 
281: 		// some dresssup for R
282: 		SET_CLASS(dest, RStrings::get().POSIXct_POSIXt_str);
283: 		Rf_setAttrib(dest, RStrings::get().tzone_sym, RStrings::get().UTC_str);
284: 		break;
285: 	}
286: 	case LogicalTypeId::DATE: {
287: 		auto src_data = FlatVector::GetData<date_t>(src_vec);
288: 		auto &mask = FlatVector::Validity(src_vec);
289: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
290: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
291: 			dest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? NA_REAL : (double)int32_t(src_data[row_idx]);
292: 		}
293: 
294: 		// some dresssup for R
295: 		SET_CLASS(dest, RStrings::get().Date_str);
296: 		break;
297: 	}
298: 	case LogicalTypeId::TIME: {
299: 		auto src_data = FlatVector::GetData<dtime_t>(src_vec);
300: 		auto &mask = FlatVector::Validity(src_vec);
301: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
302: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
303: 			if (!mask.RowIsValid(row_idx)) {
304: 				dest_ptr[row_idx] = NA_REAL;
305: 			} else {
306: 				dtime_t n = src_data[row_idx];
307: 				dest_ptr[row_idx] = n.micros / Interval::MICROS_PER_SEC;
308: 			}
309: 		}
310: 
311: 		// some dress-up for R
312: 		SET_CLASS(dest, RStrings::get().difftime_str);
313: 		Rf_setAttrib(dest, RStrings::get().units_sym, RStrings::get().secs_str);
314: 		break;
315: 	}
316: 	case LogicalTypeId::UINTEGER:
317: 		VectorToR<uint32_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
318: 		break;
319: 	case LogicalTypeId::UBIGINT:
320: 		VectorToR<uint64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
321: 		break;
322: 	case LogicalTypeId::BIGINT:
323: 		VectorToR<int64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
324: 		break;
325: 	case LogicalTypeId::HUGEINT: {
326: 		auto src_data = FlatVector::GetData<hugeint_t>(src_vec);
327: 		auto &mask = FlatVector::Validity(src_vec);
328: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
329: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
330: 			if (!mask.RowIsValid(row_idx)) {
331: 				dest_ptr[row_idx] = NA_REAL;
332: 			} else {
333: 				Hugeint::TryCast(src_data[row_idx], dest_ptr[row_idx]);
334: 			}
335: 		}
336: 		break;
337: 	}
338: 	case LogicalTypeId::DECIMAL: {
339: 		auto &decimal_type = src_vec.GetType();
340: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
341: 		auto dec_scale = DecimalType::GetScale(decimal_type);
342: 		switch (decimal_type.InternalType()) {
343: 		case PhysicalType::INT16:
344: 			RDecimalCastLoop<int16_t>(src_vec, n, dest_ptr, dec_scale);
345: 			break;
346: 		case PhysicalType::INT32:
347: 			RDecimalCastLoop<int32_t>(src_vec, n, dest_ptr, dec_scale);
348: 			break;
349: 		case PhysicalType::INT64:
350: 			RDecimalCastLoop<int64_t>(src_vec, n, dest_ptr, dec_scale);
351: 			break;
352: 		case PhysicalType::INT128:
353: 			RDecimalCastLoop<hugeint_t>(src_vec, n, dest_ptr, dec_scale);
354: 			break;
355: 		default:
356: 			throw NotImplementedException("Unimplemented internal type for DECIMAL");
357: 		}
358: 		break;
359: 	}
360: 	case LogicalTypeId::FLOAT:
361: 		VectorToR<float, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
362: 		break;
363: 
364: 	case LogicalTypeId::DOUBLE:
365: 		VectorToR<double, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
366: 		break;
367: 	case LogicalTypeId::VARCHAR: {
368: 		auto wrapper = (DuckDBAltrepStringWrapper *)R_ExternalPtrAddr(R_altrep_data1(dest));
369: 		wrapper->vectors.emplace_back(LogicalType::VARCHAR, nullptr);
370: 		wrapper->vectors.back().Reference(src_vec);
371: 		break;
372: 	}
373: 	case LogicalTypeId::LIST: {
374: 		// figure out the total and max element length of the list vector child
375: 		auto src_data = ListVector::GetData(src_vec);
376: 		auto &child_type = ListType::GetChildType(src_vec.GetType());
377: 		Vector child_vector(child_type, nullptr);
378: 
379: 		// actual loop over rows
380: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
381: 			if (!FlatVector::Validity(src_vec).RowIsValid(row_idx)) {
382: 				SET_ELEMENT(dest, dest_offset + row_idx, Rf_ScalarLogical(NA_LOGICAL));
383: 			} else {
384: 				child_vector.Slice(ListVector::GetEntry(src_vec), src_data[row_idx].offset);
385: 
386: 				RProtector ele_prot;
387: 				// transform the list child vector to a single R SEXP
388: 				auto list_element =
389: 				    allocate(ListType::GetChildType(src_vec.GetType()), ele_prot, src_data[row_idx].length);
390: 				transform(child_vector, list_element, 0, src_data[row_idx].length);
391: 
392: 				// call R's own extract subset method
393: 				SET_ELEMENT(dest, dest_offset + row_idx, list_element);
394: 			}
395: 		}
396: 		break;
397: 	}
398: 	case LogicalTypeId::BLOB: {
399: 		auto src_ptr = FlatVector::GetData<string_t>(src_vec);
400: 		auto &mask = FlatVector::Validity(src_vec);
401: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
402: 			if (!mask.RowIsValid(row_idx)) {
403: 				SET_VECTOR_ELT(dest, dest_offset + row_idx, Rf_ScalarLogical(NA_LOGICAL));
404: 			} else {
405: 				SEXP rawval = NEW_RAW(src_ptr[row_idx].GetSize());
406: 				if (!rawval) {
407: 					throw std::bad_alloc();
408: 				}
409: 				memcpy(RAW_POINTER(rawval), src_ptr[row_idx].GetDataUnsafe(), src_ptr[row_idx].GetSize());
410: 				SET_VECTOR_ELT(dest, dest_offset + row_idx, rawval);
411: 			}
412: 		}
413: 		break;
414: 	}
415: 	case LogicalTypeId::ENUM: {
416: 		auto physical_type = src_vec.GetType().InternalType();
417: 
418: 		switch (physical_type) {
419: 		case PhysicalType::UINT8:
420: 			VectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
421: 			break;
422: 
423: 		case PhysicalType::UINT16:
424: 			VectorToR<uint16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
425: 			break;
426: 
427: 		case PhysicalType::UINT32:
428: 			VectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
429: 			break;
430: 
431: 		default:
432: 			cpp11::stop("duckdb_execute_R: Unknown enum type for convert: %s", TypeIdToString(physical_type).c_str());
433: 		}
434: 		// increment by one cause R factor offsets start at 1
435: 		auto dest_ptr = ((int32_t *)INTEGER_POINTER(dest)) + dest_offset;
436: 		for (idx_t i = 0; i < n; i++) {
437: 			if (dest_ptr[i] == NA_INTEGER) {
438: 				continue;
439: 			}
440: 			dest_ptr[i]++;
441: 		}
442: 
443: 		auto &str_vec = EnumType::GetValuesInsertOrder(src_vec.GetType());
444: 		auto size = EnumType::GetSize(src_vec.GetType());
445: 		vector<string> str_c_vec(size);
446: 		for (idx_t i = 0; i < size; i++) {
447: 			str_c_vec[i] = str_vec.GetValue(i).ToString();
448: 		}
449: 
450: 		SET_LEVELS(dest, RApi::StringsToSexp(str_c_vec));
451: 		SET_CLASS(dest, RStrings::get().factor_str);
452: 		break;
453: 	}
454: 	default:
455: 		cpp11::stop("duckdb_execute_R: Unknown column type for convert: %s", src_vec.GetType().ToString().c_str());
456: 		break;
457: 	}
458: }
459: 
460: static SEXP duckdb_execute_R_impl(MaterializedQueryResult *result) {
461: 	// step 2: create result data frame and allocate columns
462: 	uint32_t ncols = result->types.size();
463: 	if (ncols == 0) {
464: 		return Rf_ScalarReal(0); // no need for protection because no allocation can happen afterwards
465: 	}
466: 
467: 	uint64_t nrows = result->collection.Count();
468: 	cpp11::list retlist(NEW_LIST(ncols));
469: 	SET_NAMES(retlist, RApi::StringsToSexp(result->names));
470: 
471: 	for (size_t col_idx = 0; col_idx < ncols; col_idx++) {
472: 		// TODO move the protector to allocate?
473: 		RProtector r_varvalue;
474: 		auto varvalue = allocate(result->types[col_idx], r_varvalue, nrows);
475: 		SET_VECTOR_ELT(retlist, col_idx, varvalue);
476: 	}
477: 
478: 	// at this point retlist is fully allocated and the only protected SEXP
479: 
480: 	// step 3: set values from chunks
481: 	uint64_t dest_offset = 0;
482: 	idx_t chunk_idx = 0;
483: 	while (true) {
484: 		auto chunk = result->Fetch();
485: 		if (!chunk || chunk->size() == 0) {
486: 			break;
487: 		}
488: 
489: 		D_ASSERT(chunk->ColumnCount() == ncols);
490: 		D_ASSERT(chunk->ColumnCount() == (idx_t)Rf_length(retlist));
491: 		for (size_t col_idx = 0; col_idx < chunk->ColumnCount(); col_idx++) {
492: 			SEXP dest = VECTOR_ELT(retlist, col_idx);
493: 			transform(chunk->data[col_idx], dest, dest_offset, chunk->size());
494: 		}
495: 		dest_offset += chunk->size();
496: 		chunk_idx++;
497: 	}
498: 
499: 	D_ASSERT(dest_offset == nrows);
500: 	return retlist;
501: }
502: 
503: struct AppendableRList {
504: 	AppendableRList() {
505: 		the_list = r.Protect(NEW_LIST(capacity));
506: 	}
507: 	void PrepAppend() {
508: 		if (size >= capacity) {
509: 			capacity = capacity * 2;
510: 			SEXP new_list = r.Protect(NEW_LIST(capacity));
511: 			D_ASSERT(new_list);
512: 			for (idx_t i = 0; i < size; i++) {
513: 				SET_VECTOR_ELT(new_list, i, VECTOR_ELT(the_list, i));
514: 			}
515: 			the_list = new_list;
516: 		}
517: 	}
518: 
519: 	void Append(SEXP val) {
520: 		D_ASSERT(size < capacity);
521: 		D_ASSERT(the_list != R_NilValue);
522: 		SET_VECTOR_ELT(the_list, size++, val);
523: 	}
524: 	SEXP the_list;
525: 	idx_t capacity = 1000;
526: 	idx_t size = 0;
527: 	RProtector r;
528: };
529: 
530: struct RQueryResult {
531: 	unique_ptr<QueryResult> result;
532: };
533: 
534: bool FetchArrowChunk(QueryResult *result, AppendableRList &batches_list, ArrowArray &arrow_data,
535:                      ArrowSchema &arrow_schema, SEXP batch_import_from_c, SEXP arrow_namespace) {
536: 	if (result->type == QueryResultType::STREAM_RESULT) {
537: 		auto stream_result = (StreamQueryResult *)result;
538: 		if (!stream_result->IsOpen()) {
539: 			return false;
540: 		}
541: 	}
542: 	unique_ptr<DataChunk> data_chunk = result->Fetch();
543: 	if (!data_chunk || data_chunk->size() == 0) {
544: 		return false;
545: 	}
546: 	result->ToArrowSchema(&arrow_schema);
547: 	data_chunk->ToArrowArray(&arrow_data);
548: 	batches_list.PrepAppend();
549: 	batches_list.Append(cpp11::safe[Rf_eval](batch_import_from_c, arrow_namespace));
550: 	return true;
551: }
552: 
553: // Turn a DuckDB result set into an Arrow Table
554: SEXP RApi::DuckDBExecuteArrow(SEXP query_resultsexp, SEXP streamsexp, SEXP vector_per_chunksexp,
555:                               SEXP return_tablesexp) {
556: 	RQueryResult *query_result_holder = (RQueryResult *)R_ExternalPtrAddr(query_resultsexp);
557: 	auto result = query_result_holder->result.get();
558: 	// somewhat dark magic below
559: 	cpp11::function getNamespace = RStrings::get().getNamespace_sym;
560: 	cpp11::sexp arrow_namespace(getNamespace(RStrings::get().arrow_str));
561: 
562: 	bool stream = LOGICAL_POINTER(streamsexp)[0] != 0;
563: 	int num_of_vectors = NUMERIC_POINTER(vector_per_chunksexp)[0];
564: 	bool return_table = LOGICAL_POINTER(return_tablesexp)[0] != 0;
565: 	if (TYPEOF(streamsexp) != LGLSXP || LENGTH(streamsexp) != 1) {
566: 		cpp11::stop("stream parameter needs to be single-value logical");
567: 	}
568: 	if (TYPEOF(return_tablesexp) != LGLSXP || LENGTH(return_tablesexp) != 1) {
569: 		cpp11::stop("return_table parameter needs to be single-value logical");
570: 	}
571: 	if (TYPEOF(vector_per_chunksexp) != REALSXP || LENGTH(vector_per_chunksexp) != 1) {
572: 		cpp11::stop("vector_per_chunks parameter needs to be single-value numeric");
573: 	}
574: 	// export schema setup
575: 	ArrowSchema arrow_schema;
576: 	cpp11::doubles schema_ptr_sexp(Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&arrow_schema))));
577: 	cpp11::sexp schema_import_from_c(Rf_lang2(RStrings::get().ImportSchema_sym, schema_ptr_sexp));
578: 
579: 	// export data setup
580: 	ArrowArray arrow_data;
581: 	cpp11::doubles data_ptr_sexp(Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&arrow_data))));
582: 	cpp11::sexp batch_import_from_c(Rf_lang3(RStrings::get().ImportRecordBatch_sym, data_ptr_sexp, schema_ptr_sexp));
583: 	// create data batches
584: 	AppendableRList batches_list;
585: 	if (stream) {
586: 		for (idx_t i = 0; i < (size_t)num_of_vectors; i++) {
587: 			if (!FetchArrowChunk(result, batches_list, arrow_data, arrow_schema, batch_import_from_c,
588: 			                     arrow_namespace)) {
589: 				break;
590: 			}
591: 		}
592: 	} else {
593: 		while (FetchArrowChunk(result, batches_list, arrow_data, arrow_schema, batch_import_from_c, arrow_namespace)) {
594: 		}
595: 	}
596: 
597: 	SET_LENGTH(batches_list.the_list, batches_list.size);
598: 
599: 	result->ToArrowSchema(&arrow_schema);
600: 	cpp11::sexp schema_arrow_obj(cpp11::safe[Rf_eval](schema_import_from_c, arrow_namespace));
601: 
602: 	// create arrow::Table
603: 	if (return_table) {
604: 		cpp11::sexp from_record_batches(
605: 		    Rf_lang3(RStrings::get().Table__from_record_batches_sym, batches_list.the_list, schema_arrow_obj));
606: 		return cpp11::safe[Rf_eval](from_record_batches, arrow_namespace);
607: 	}
608: 	return batches_list.the_list;
609: }
610: 
611: // Turn a DuckDB result set into an RecordBatchReader
612: SEXP RApi::DuckDBRecordBatchR(SEXP query_resultsexp, SEXP approx_batch_sizeexp) {
613: 	RQueryResult *query_result_holder = (RQueryResult *)R_ExternalPtrAddr(query_resultsexp);
614: 	int approx_batch_size = NUMERIC_POINTER(approx_batch_sizeexp)[0];
615: 	if (TYPEOF(approx_batch_sizeexp) != REALSXP || LENGTH(approx_batch_sizeexp) != 1) {
616: 		cpp11::stop("vector_per_chunks parameter needs to be single-value numeric");
617: 	}
618: 	// somewhat dark magic below
619: 	cpp11::function getNamespace = RStrings::get().getNamespace_sym;
620: 	cpp11::sexp arrow_namespace(getNamespace(RStrings::get().arrow_str));
621: 
622: 	ResultArrowArrayStreamWrapper *result_stream =
623: 	    new ResultArrowArrayStreamWrapper(move(query_result_holder->result), approx_batch_size);
624: 	cpp11::sexp stream_ptr_sexp(
625: 	    Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&result_stream->stream))));
626: 	cpp11::sexp record_batch_reader(Rf_lang2(RStrings::get().ImportRecordBatchReader_sym, stream_ptr_sexp));
627: 	return cpp11::safe[Rf_eval](record_batch_reader, arrow_namespace);
628: }
629: 
630: static SEXP DuckDBFinalizeQueryR(SEXP query_resultsexp) {
631: 	RQueryResult *query_result_holder = (RQueryResult *)R_ExternalPtrAddr(query_resultsexp);
632: 	if (query_resultsexp) {
633: 		R_ClearExternalPtr(query_resultsexp);
634: 		delete query_result_holder;
635: 	}
636: 	return R_NilValue;
637: }
638: 
639: SEXP RApi::Execute(SEXP stmtsexp, SEXP arrowsexp) {
640: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
641: 		cpp11::stop("duckdb_execute_R: Need external pointer for first parameter");
642: 	}
643: 	if (TYPEOF(arrowsexp) != LGLSXP) {
644: 		cpp11::stop("duckdb_execute_R: Need logical for second parameter");
645: 	}
646: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
647: 	if (!stmtholder || !stmtholder->stmt) {
648: 		cpp11::stop("duckdb_execute_R: Invalid statement");
649: 	}
650: 
651: 	bool arrow_fetch = LOGICAL_POINTER(arrowsexp)[0] != 0;
652: 	auto generic_result = stmtholder->stmt->Execute(stmtholder->parameters, arrow_fetch);
653: 	if (!generic_result->success) {
654: 		cpp11::stop("duckdb_execute_R: Failed to run query\nError: %s", generic_result->error.c_str());
655: 	}
656: 
657: 	if (arrow_fetch) {
658: 		RProtector r;
659: 		auto query_result = new RQueryResult();
660: 		query_result->result = move(generic_result);
661: 		SEXP query_resultexp = r.Protect(R_MakeExternalPtr(query_result, R_NilValue, R_NilValue));
662: 		R_RegisterCFinalizer(query_resultexp, (void (*)(SEXP))DuckDBFinalizeQueryR);
663: 		return query_resultexp;
664: 	} else {
665: 		D_ASSERT(generic_result->type == QueryResultType::MATERIALIZED_RESULT);
666: 		MaterializedQueryResult *result = (MaterializedQueryResult *)generic_result.get();
667: 		return duckdb_execute_R_impl(result);
668: 	}
669: }
[end of tools/rpkg/src/statement.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: