You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
JDBC: some emoji character will make the result string shorten
First, thanks for this great project.

When I use duckdb to develop a ETL tool to sync data with some processing between different database, I find some emoji will cause wrong data returned.

It was found when I import some json string from one database into "jsonb" column of postgresql. most records work ok, but one failed with "wrong json format", after investigate more, I found the content returned from duckdb was truncated to shorter string, which cause invalid json error.

Then, I find this is related with JDBC Fetch string column from duckdb, and it is related with some emoji character. 

To reproduce, we can execute the following SQL:

`

select 'ðŸ¦„à¾€à½²123456789'

`

The result will be:


+------------+
|Ã°ÂŸÂ¦Â„à¾€à½²123456|
+------------+
|Ã°ÂŸÂ¦Â„à¾€à½²123456|
+------------+

The ending 3 characters (7,8,9) will missing


If I debug in Intellij Idea,  the correct data for that emoji read from source database is:

'\uD83E' 55358
'\uDD84' 56708

the wrong data from duckdb will be (2 characters longer)

'Ã°' 240
'\u009F' 159
'Â¦' 166
'\u0084' 132



Do you have any clue where maybe wrong, thanks a lot



</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of tools/jdbc/src/jni/duckdb_java.cpp]
1: #include "org_duckdb_DuckDBNative.h"
2: #include "duckdb.hpp"
3: #include "duckdb/main/client_context.hpp"
4: #include "duckdb/main/appender.hpp"
5: #include "parquet-extension.hpp"
6: 
7: using namespace duckdb;
8: using namespace std;
9: 
10: static string byte_array_to_string(JNIEnv *env, jbyteArray ba_j) {
11: 	idx_t len = env->GetArrayLength(ba_j);
12: 	string ret;
13: 	ret.resize(len);
14: 
15: 	jbyte *bytes = (jbyte *)env->GetByteArrayElements(ba_j, NULL);
16: 
17: 	for (idx_t i = 0; i < len; i++) {
18: 		ret[i] = bytes[i];
19: 	}
20: 	env->ReleaseByteArrayElements(ba_j, bytes, 0);
21: 
22: 	return ret;
23: }
24: 
25: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1startup(JNIEnv *env, jclass, jbyteArray database_j,
26:                                                                              jboolean read_only) {
27: 	auto database = byte_array_to_string(env, database_j);
28: 	DBConfig config;
29: 	if (read_only) {
30: 		config.access_mode = AccessMode::READ_ONLY;
31: 	}
32: 	try {
33: 		auto db = new DuckDB(database, &config);
34: 		db->LoadExtension<ParquetExtension>();
35: 		return env->NewDirectByteBuffer(db, 0);
36: 	} catch (exception &e) {
37: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
38: 	}
39: 	return nullptr;
40: }
41: 
42: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1shutdown(JNIEnv *env, jclass, jobject db_ref_buf) {
43: 	auto db_ref = (DuckDB *)env->GetDirectBufferAddress(db_ref_buf);
44: 	if (db_ref) {
45: 		delete db_ref;
46: 	}
47: }
48: 
49: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1connect(JNIEnv *env, jclass, jobject db_ref_buf) {
50: 	auto db_ref = (DuckDB *)env->GetDirectBufferAddress(db_ref_buf);
51: 	try {
52: 		auto conn = new Connection(*db_ref);
53: 		return env->NewDirectByteBuffer(conn, 0);
54: 	} catch (exception &e) {
55: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
56: 	}
57: 	return nullptr;
58: }
59: 
60: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1set_1auto_1commit(JNIEnv *env, jclass,
61:                                                                                     jobject conn_ref_buf,
62:                                                                                     jboolean auto_commit) {
63: 	auto conn_ref = (Connection *)env->GetDirectBufferAddress(conn_ref_buf);
64: 	if (!conn_ref || !conn_ref->context) {
65: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid connection");
66: 	}
67: 	conn_ref->context->RunFunctionInTransaction([&]() { conn_ref->SetAutoCommit(auto_commit); });
68: }
69: 
70: JNIEXPORT jboolean JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1get_1auto_1commit(JNIEnv *env, jclass,
71:                                                                                         jobject conn_ref_buf) {
72: 	auto conn_ref = (Connection *)env->GetDirectBufferAddress(conn_ref_buf);
73: 	if (!conn_ref) {
74: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid connection");
75: 	}
76: 	return conn_ref->IsAutoCommit();
77: }
78: 
79: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1disconnect(JNIEnv *env, jclass,
80:                                                                              jobject conn_ref_buf) {
81: 	auto conn_ref = (Connection *)env->GetDirectBufferAddress(conn_ref_buf);
82: 	if (conn_ref) {
83: 		delete conn_ref;
84: 	}
85: }
86: 
87: struct StatementHolder {
88: 	unique_ptr<PreparedStatement> stmt;
89: };
90: 
91: #include "utf8proc_wrapper.hpp"
92: 
93: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1prepare(JNIEnv *env, jclass, jobject conn_ref_buf,
94:                                                                              jbyteArray query_j) {
95: 	auto conn_ref = (Connection *)env->GetDirectBufferAddress(conn_ref_buf);
96: 	if (!conn_ref) {
97: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid connection");
98: 	}
99: 
100: 	auto query = byte_array_to_string(env, query_j);
101: 
102: 	auto stmt_ref = new StatementHolder();
103: 	stmt_ref->stmt = conn_ref->Prepare(query);
104: 	if (!stmt_ref->stmt->success) {
105: 		string error_msg = string(stmt_ref->stmt->error);
106: 		stmt_ref->stmt = nullptr;
107: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), error_msg.c_str());
108: 	}
109: 	return env->NewDirectByteBuffer(stmt_ref, 0);
110: }
111: 
112: struct ResultHolder {
113: 	unique_ptr<QueryResult> res;
114: 	unique_ptr<DataChunk> chunk;
115: };
116: 
117: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1execute(JNIEnv *env, jclass, jobject stmt_ref_buf,
118:                                                                              jobjectArray params) {
119: 	auto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);
120: 	if (!stmt_ref) {
121: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid statement");
122: 	}
123: 	auto res_ref = new ResultHolder();
124: 	vector<Value> duckdb_params;
125: 
126: 	idx_t param_len = env->GetArrayLength(params);
127: 	if (param_len != stmt_ref->stmt->n_param) {
128: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Parameter count mismatch");
129: 	}
130: 
131: 	if (param_len > 0) {
132: 		auto bool_class = env->FindClass("java/lang/Boolean");
133: 		auto byte_class = env->FindClass("java/lang/Byte");
134: 		auto short_class = env->FindClass("java/lang/Short");
135: 		auto integer_class = env->FindClass("java/lang/Integer");
136: 		auto long_class = env->FindClass("java/lang/Long");
137: 		auto float_class = env->FindClass("java/lang/Float");
138: 		auto double_class = env->FindClass("java/lang/Double");
139: 		auto string_class = env->FindClass("java/lang/String");
140: 
141: 		for (idx_t i = 0; i < param_len; i++) {
142: 			auto param = env->GetObjectArrayElement(params, i);
143: 			if (param == nullptr) {
144: 				duckdb_params.push_back(Value());
145: 				continue;
146: 			} else if (env->IsInstanceOf(param, bool_class)) {
147: 				duckdb_params.push_back(
148: 				    Value::BOOLEAN(env->CallBooleanMethod(param, env->GetMethodID(bool_class, "booleanValue", "()Z"))));
149: 				continue;
150: 			} else if (env->IsInstanceOf(param, byte_class)) {
151: 				duckdb_params.push_back(
152: 				    Value::TINYINT(env->CallByteMethod(param, env->GetMethodID(byte_class, "byteValue", "()B"))));
153: 				continue;
154: 			} else if (env->IsInstanceOf(param, short_class)) {
155: 				duckdb_params.push_back(
156: 				    Value::SMALLINT(env->CallShortMethod(param, env->GetMethodID(short_class, "shortValue", "()S"))));
157: 				continue;
158: 			} else if (env->IsInstanceOf(param, integer_class)) {
159: 				duckdb_params.push_back(
160: 				    Value::INTEGER(env->CallIntMethod(param, env->GetMethodID(integer_class, "intValue", "()I"))));
161: 				continue;
162: 			} else if (env->IsInstanceOf(param, long_class)) {
163: 				duckdb_params.push_back(
164: 				    Value::BIGINT(env->CallLongMethod(param, env->GetMethodID(long_class, "longValue", "()J"))));
165: 				continue;
166: 			} else if (env->IsInstanceOf(param, float_class)) {
167: 				duckdb_params.push_back(
168: 				    Value::FLOAT(env->CallFloatMethod(param, env->GetMethodID(float_class, "floatValue", "()F"))));
169: 				continue;
170: 			} else if (env->IsInstanceOf(param, double_class)) {
171: 				duckdb_params.push_back(
172: 				    Value::DOUBLE(env->CallDoubleMethod(param, env->GetMethodID(double_class, "doubleValue", "()D"))));
173: 				continue;
174: 			} else if (env->IsInstanceOf(param, string_class)) {
175: 				auto *param_string = env->GetStringUTFChars((jstring)param, 0);
176: 				duckdb_params.push_back(Value(param_string));
177: 				env->ReleaseStringUTFChars((jstring)param, param_string);
178: 				continue;
179: 			} else {
180: 				env->ThrowNew(env->FindClass("java/sql/SQLException"), "Unsupported parameter type");
181: 			}
182: 		}
183: 	}
184: 
185: 	res_ref->res = stmt_ref->stmt->Execute(duckdb_params, false);
186: 	if (!res_ref->res->success) {
187: 		string error_msg = string(res_ref->res->error);
188: 		res_ref->res = nullptr;
189: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), error_msg.c_str());
190: 	}
191: 	return env->NewDirectByteBuffer(res_ref, 0);
192: }
193: 
194: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1release(JNIEnv *env, jclass, jobject stmt_ref_buf) {
195: 	auto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);
196: 	if (stmt_ref) {
197: 		delete stmt_ref;
198: 	}
199: }
200: 
201: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1free_1result(JNIEnv *env, jclass,
202:                                                                                jobject res_ref_buf) {
203: 	auto res_ref = (ResultHolder *)env->GetDirectBufferAddress(res_ref_buf);
204: 	if (res_ref) {
205: 		delete res_ref;
206: 	}
207: }
208: 
209: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1meta(JNIEnv *env, jclass, jobject stmt_ref_buf) {
210: 
211: 	auto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);
212: 	if (!stmt_ref || !stmt_ref->stmt || !stmt_ref->stmt->success) {
213: 		jclass Exception = env->FindClass("java/sql/SQLException");
214: 		env->ThrowNew(Exception, "Invalid statement");
215: 	}
216: 
217: 	jclass meta = env->FindClass("org/duckdb/DuckDBResultSetMetaData");
218: 	jmethodID meta_construct = env->GetMethodID(meta, "<init>", "(II[Ljava/lang/String;[Ljava/lang/String;)V");
219: 
220: 	auto column_count = stmt_ref->stmt->ColumnCount();
221: 	auto &names = stmt_ref->stmt->GetNames();
222: 	auto &types = stmt_ref->stmt->GetTypes();
223: 
224: 	auto name_array = env->NewObjectArray(column_count, env->FindClass("java/lang/String"), nullptr);
225: 	auto type_array = env->NewObjectArray(column_count, env->FindClass("java/lang/String"), nullptr);
226: 
227: 	for (idx_t col_idx = 0; col_idx < column_count; col_idx++) {
228: 		env->SetObjectArrayElement(name_array, col_idx, env->NewStringUTF(names[col_idx].c_str()));
229: 		env->SetObjectArrayElement(type_array, col_idx, env->NewStringUTF(types[col_idx].ToString().c_str()));
230: 	}
231: 
232: 	return env->NewObject(meta, meta_construct, stmt_ref->stmt->n_param, column_count, name_array, type_array);
233: }
234: 
235: JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(JNIEnv *env, jclass,
236:                                                                                 jobject res_ref_buf) {
237: 	auto res_ref = (ResultHolder *)env->GetDirectBufferAddress(res_ref_buf);
238: 	if (!res_ref || !res_ref->res || !res_ref->res->success) {
239: 		jclass Exception = env->FindClass("java/sql/SQLException");
240: 		env->ThrowNew(Exception, "Invalid result set");
241: 	}
242: 
243: 	res_ref->chunk = res_ref->res->Fetch();
244: 	if (!res_ref->chunk) {
245: 		res_ref->chunk = make_unique<DataChunk>();
246: 	}
247: 	auto row_count = res_ref->chunk->size();
248: 
249: 	// ugh
250: 	jclass charset_class = env->FindClass("java/nio/charset/Charset");
251: 	jclass charbuffer_class = env->FindClass("java/nio/CharBuffer");
252: 	jmethodID for_name =
253: 	    env->GetStaticMethodID(charset_class, "forName", "(Ljava/lang/String;)Ljava/nio/charset/Charset;");
254: 	jobject charset = env->CallStaticObjectMethod(charset_class, for_name, env->NewStringUTF("UTF-8"));
255: 	jmethodID charset_decode =
256: 	    env->GetMethodID(charset_class, "decode", "(Ljava/nio/ByteBuffer;)Ljava/nio/CharBuffer;");
257: 	jmethodID charbuffer_to_string = env->GetMethodID(charbuffer_class, "toString", "()Ljava/lang/String;");
258: 	jclass string_class = env->FindClass("java/lang/String");
259: 	// eough
260: 
261: 	auto vec_array = (jobjectArray)env->NewObjectArray(res_ref->chunk->ColumnCount(),
262: 	                                                   env->FindClass("org/duckdb/DuckDBVector"), nullptr);
263: 	for (idx_t col_idx = 0; col_idx < res_ref->chunk->ColumnCount(); col_idx++) {
264: 		auto &vec = res_ref->chunk->data[col_idx];
265: 		auto type_str = env->NewStringUTF(vec.type.ToString().c_str());
266: 		// construct nullmask
267: 		auto null_array = env->NewBooleanArray(row_count);
268: 		jboolean *null_array_ptr = env->GetBooleanArrayElements(null_array, nullptr);
269: 		for (idx_t row_idx = 0; row_idx < row_count; row_idx++) {
270: 			null_array_ptr[row_idx] = FlatVector::Nullmask(vec)[row_idx];
271: 		}
272: 		env->ReleaseBooleanArrayElements(null_array, null_array_ptr, 0);
273: 
274: 		jclass vec_class = env->FindClass("org/duckdb/DuckDBVector");
275: 		jmethodID vec_construct = env->GetMethodID(vec_class, "<init>", "(Ljava/lang/String;I[Z)V");
276: 		auto jvec = env->NewObject(vec_class, vec_construct, type_str, (int)row_count, null_array);
277: 
278: 		jobject constlen_data = nullptr;
279: 		jobjectArray varlen_data = nullptr;
280: 
281: 		switch (vec.type.id()) {
282: 		case LogicalTypeId::BOOLEAN:
283: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(bool));
284: 			break;
285: 		case LogicalTypeId::TINYINT:
286: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(int8_t));
287: 			break;
288: 		case LogicalTypeId::SMALLINT:
289: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(int16_t));
290: 			break;
291: 		case LogicalTypeId::INTEGER:
292: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(int32_t));
293: 			break;
294: 		case LogicalTypeId::BIGINT:
295: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(int64_t));
296: 			break;
297: 		case LogicalTypeId::HUGEINT:
298: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(hugeint_t));
299: 			break;
300: 		case LogicalTypeId::FLOAT:
301: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(float));
302: 			break;
303: 		case LogicalTypeId::DECIMAL: {
304: 			Vector double_vec(LogicalType::DOUBLE);
305: 			VectorOperations::Cast(vec, double_vec, row_count);
306: 			vec.Reference(double_vec);
307: 			// fall through on purpose
308: 		}
309: 		case LogicalTypeId::DOUBLE:
310: 			constlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(double));
311: 			break;
312: 		case LogicalTypeId::TIME:
313: 		case LogicalTypeId::DATE:
314: 		case LogicalTypeId::TIMESTAMP:
315: 		case LogicalTypeId::INTERVAL: {
316: 			Vector string_vec(LogicalType::VARCHAR);
317: 			VectorOperations::Cast(vec, string_vec, row_count);
318: 			vec.Reference(string_vec);
319: 			// fall through on purpose
320: 		}
321: 		case LogicalTypeId::VARCHAR:
322: 			varlen_data = env->NewObjectArray(row_count, string_class, nullptr);
323: 			for (idx_t row_idx = 0; row_idx < row_count; row_idx++) {
324: 				if (FlatVector::Nullmask(vec)[row_idx]) {
325: 					continue;
326: 				}
327: 				// omg
328: 				auto d_str = ((string_t *)FlatVector::GetData(vec))[row_idx];
329: 				auto bb = env->NewDirectByteBuffer((void *)d_str.GetDataUnsafe(), d_str.GetSize());
330: 				auto j_cb = env->CallObjectMethod(charset, charset_decode, bb);
331: 				auto j_str = env->CallObjectMethod(j_cb, charbuffer_to_string);
332: 
333: 				env->SetObjectArrayElement(varlen_data, row_idx, j_str);
334: 			}
335: 			break;
336: 		default:
337: 			jclass Exception = env->FindClass("java/sql/SQLException");
338: 			env->ThrowNew(Exception, ("Unsupported result column type " + vec.type.ToString()).c_str());
339: 		}
340: 
341: 		jfieldID constlen_data_field = env->GetFieldID(vec_class, "constlen_data", "Ljava/nio/ByteBuffer;");
342: 		jfieldID varlen_data_field = env->GetFieldID(vec_class, "varlen_data", "[Ljava/lang/Object;");
343: 
344: 		env->SetObjectField(jvec, constlen_data_field, constlen_data);
345: 		env->SetObjectField(jvec, varlen_data_field, varlen_data);
346: 
347: 		env->SetObjectArrayElement(vec_array, col_idx, jvec);
348: 	}
349: 
350: 	return vec_array;
351: }
352: 
353: JNIEXPORT jint JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch_1size(JNIEnv *, jclass) {
354: 	return STANDARD_VECTOR_SIZE;
355: }
356: 
357: JNIEXPORT jstring JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1prepare_1type(JNIEnv *env, jclass,
358:                                                                                    jobject stmt_ref_buf) {
359: 
360: 	auto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);
361: 	if (!stmt_ref || !stmt_ref->stmt || !stmt_ref->stmt->success) {
362: 		jclass Exception = env->FindClass("java/sql/SQLException");
363: 		env->ThrowNew(Exception, "Invalid statement");
364: 	}
365: 	return env->NewStringUTF(StatementTypeToString(stmt_ref->stmt->GetStatementType()).c_str());
366: }
367: 
368: JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1create_1appender(JNIEnv *env, jclass,
369:                                                                                       jobject conn_ref_buf,
370:                                                                                       jbyteArray schema_name_j,
371:                                                                                       jbyteArray table_name_j) {
372: 
373: 	auto conn_ref = (Connection *)env->GetDirectBufferAddress(conn_ref_buf);
374: 	if (!conn_ref || !conn_ref->context) {
375: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid connection");
376: 	}
377: 	auto schema_name = byte_array_to_string(env, schema_name_j);
378: 	auto table_name = byte_array_to_string(env, table_name_j);
379: 	try {
380: 		auto appender = new Appender(*conn_ref, schema_name, table_name);
381: 		return env->NewDirectByteBuffer(appender, 0);
382: 	} catch (exception &e) {
383: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
384: 	}
385: 	return nullptr;
386: }
387: 
388: static Appender *get_appender(JNIEnv *env, jobject appender_ref_buf) {
389: 	auto appender_ref = (Appender *)env->GetDirectBufferAddress(appender_ref_buf);
390: 	if (!appender_ref) {
391: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), "Invalid appender");
392: 	}
393: 	return appender_ref;
394: }
395: 
396: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1begin_1row(JNIEnv *env, jclass,
397:                                                                                        jobject appender_ref_buf) {
398: 	try {
399: 		get_appender(env, appender_ref_buf)->BeginRow();
400: 	} catch (exception &e) {
401: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
402: 	}
403: }
404: 
405: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1end_1row(JNIEnv *env, jclass,
406:                                                                                      jobject appender_ref_buf) {
407: 	try {
408: 		get_appender(env, appender_ref_buf)->EndRow();
409: 	} catch (exception &e) {
410: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
411: 	}
412: }
413: 
414: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1flush(JNIEnv *env, jclass,
415:                                                                                   jobject appender_ref_buf) {
416: 	try {
417: 		get_appender(env, appender_ref_buf)->Flush();
418: 	} catch (exception &e) {
419: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
420: 	}
421: }
422: 
423: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1close(JNIEnv *env, jclass,
424:                                                                                   jobject appender_ref_buf) {
425: 	try {
426: 		auto appender = get_appender(env, appender_ref_buf);
427: 		appender->Close();
428: 		delete appender;
429: 	} catch (exception &e) {
430: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
431: 	}
432: }
433: 
434: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1boolean(JNIEnv *env, jclass,
435:                                                                                             jobject appender_ref_buf,
436:                                                                                             jboolean value) {
437: 	try {
438: 		get_appender(env, appender_ref_buf)->Append((bool)value);
439: 	} catch (exception &e) {
440: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
441: 	}
442: }
443: 
444: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1byte(JNIEnv *env, jclass,
445:                                                                                          jobject appender_ref_buf,
446:                                                                                          jbyte value) {
447: 	try {
448: 		get_appender(env, appender_ref_buf)->Append((int8_t)value);
449: 	} catch (exception &e) {
450: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
451: 	}
452: }
453: 
454: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1short(JNIEnv *env, jclass,
455:                                                                                           jobject appender_ref_buf,
456:                                                                                           jshort value) {
457: 	try {
458: 		get_appender(env, appender_ref_buf)->Append((int16_t)value);
459: 	} catch (exception &e) {
460: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
461: 	}
462: }
463: 
464: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1int(JNIEnv *env, jclass,
465:                                                                                         jobject appender_ref_buf,
466:                                                                                         jint value) {
467: 	try {
468: 		get_appender(env, appender_ref_buf)->Append((int32_t)value);
469: 	} catch (exception &e) {
470: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
471: 	}
472: }
473: 
474: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1long(JNIEnv *env, jclass,
475:                                                                                          jobject appender_ref_buf,
476:                                                                                          jlong value) {
477: 	try {
478: 		get_appender(env, appender_ref_buf)->Append((int64_t)value);
479: 	} catch (exception &e) {
480: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
481: 	}
482: }
483: 
484: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1float(JNIEnv *env, jclass,
485:                                                                                           jobject appender_ref_buf,
486:                                                                                           jfloat value) {
487: 	try {
488: 		get_appender(env, appender_ref_buf)->Append((float)value);
489: 	} catch (exception &e) {
490: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
491: 	}
492: }
493: 
494: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1double(JNIEnv *env, jclass,
495:                                                                                            jobject appender_ref_buf,
496:                                                                                            jdouble value) {
497: 	try {
498: 		get_appender(env, appender_ref_buf)->Append((double)value);
499: 	} catch (exception &e) {
500: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
501: 	}
502: }
503: 
504: JNIEXPORT void JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1appender_1append_1string(JNIEnv *env, jclass,
505:                                                                                            jobject appender_ref_buf,
506:                                                                                            jbyteArray value) {
507: 	try {
508: 		auto string_value = byte_array_to_string(env, value);
509: 		get_appender(env, appender_ref_buf)->Append(string_value.c_str());
510: 	} catch (exception &e) {
511: 		env->ThrowNew(env->FindClass("java/sql/SQLException"), e.what());
512: 	}
513: }
[end of tools/jdbc/src/jni/duckdb_java.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: