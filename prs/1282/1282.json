{
  "repo": "duckdb/duckdb",
  "pull_number": 1282,
  "instance_id": "duckdb__duckdb-1282",
  "issue_numbers": [
    "1271"
  ],
  "base_commit": "7a8dd094503ef4f3bc1d9ed9910619066d353813",
  "patch": "diff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp\nindex 155389074d7f..4c9642a6a53a 100644\n--- a/tools/jdbc/src/jni/duckdb_java.cpp\n+++ b/tools/jdbc/src/jni/duckdb_java.cpp\n@@ -22,6 +22,22 @@ static string byte_array_to_string(JNIEnv *env, jbyteArray ba_j) {\n \treturn ret;\n }\n \n+static jobject decode_charbuffer_to_jstring(JNIEnv *env, const char *d_str, idx_t d_str_len) {\n+\tjclass charset_class = env->FindClass(\"java/nio/charset/Charset\");\n+\tjclass charbuffer_class = env->FindClass(\"java/nio/CharBuffer\");\n+\tjmethodID for_name =\n+\t\tenv->GetStaticMethodID(charset_class, \"forName\", \"(Ljava/lang/String;)Ljava/nio/charset/Charset;\");\n+\tjobject charset = env->CallStaticObjectMethod(charset_class, for_name, env->NewStringUTF(\"UTF-8\"));\n+\tjmethodID charset_decode =\n+\t\tenv->GetMethodID(charset_class, \"decode\", \"(Ljava/nio/ByteBuffer;)Ljava/nio/CharBuffer;\");\n+\tjmethodID charbuffer_to_string = env->GetMethodID(charbuffer_class, \"toString\", \"()Ljava/lang/String;\");\n+\n+\tauto bb = env->NewDirectByteBuffer((void *)d_str, d_str_len);\n+\tauto j_cb = env->CallObjectMethod(charset, charset_decode, bb);\n+\tauto j_str = env->CallObjectMethod(j_cb, charbuffer_to_string);\n+\treturn j_str;\n+}\n+\n JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1startup(JNIEnv *env, jclass, jbyteArray database_j,\n                                                                              jboolean read_only) {\n \tauto database = byte_array_to_string(env, database_j);\n@@ -225,7 +241,7 @@ JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1meta(JNIEnv\n \tauto type_array = env->NewObjectArray(column_count, env->FindClass(\"java/lang/String\"), nullptr);\n \n \tfor (idx_t col_idx = 0; col_idx < column_count; col_idx++) {\n-\t\tenv->SetObjectArrayElement(name_array, col_idx, env->NewStringUTF(names[col_idx].c_str()));\n+\t\tenv->SetObjectArrayElement(name_array, col_idx, decode_charbuffer_to_jstring(env, names[col_idx].c_str(), names[col_idx].length()));\n \t\tenv->SetObjectArrayElement(type_array, col_idx, env->NewStringUTF(types[col_idx].ToString().c_str()));\n \t}\n \n@@ -246,18 +262,6 @@ JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(\n \t}\n \tauto row_count = res_ref->chunk->size();\n \n-\t// ugh\n-\tjclass charset_class = env->FindClass(\"java/nio/charset/Charset\");\n-\tjclass charbuffer_class = env->FindClass(\"java/nio/CharBuffer\");\n-\tjmethodID for_name =\n-\t    env->GetStaticMethodID(charset_class, \"forName\", \"(Ljava/lang/String;)Ljava/nio/charset/Charset;\");\n-\tjobject charset = env->CallStaticObjectMethod(charset_class, for_name, env->NewStringUTF(\"UTF-8\"));\n-\tjmethodID charset_decode =\n-\t    env->GetMethodID(charset_class, \"decode\", \"(Ljava/nio/ByteBuffer;)Ljava/nio/CharBuffer;\");\n-\tjmethodID charbuffer_to_string = env->GetMethodID(charbuffer_class, \"toString\", \"()Ljava/lang/String;\");\n-\tjclass string_class = env->FindClass(\"java/lang/String\");\n-\t// eough\n-\n \tauto vec_array = (jobjectArray)env->NewObjectArray(res_ref->chunk->ColumnCount(),\n \t                                                   env->FindClass(\"org/duckdb/DuckDBVector\"), nullptr);\n \tfor (idx_t col_idx = 0; col_idx < res_ref->chunk->ColumnCount(); col_idx++) {\n@@ -319,17 +323,13 @@ JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(\n \t\t\t// fall through on purpose\n \t\t}\n \t\tcase LogicalTypeId::VARCHAR:\n-\t\t\tvarlen_data = env->NewObjectArray(row_count, string_class, nullptr);\n+\t\t\tvarlen_data = env->NewObjectArray(row_count, env->FindClass(\"java/lang/String\"), nullptr);\n \t\t\tfor (idx_t row_idx = 0; row_idx < row_count; row_idx++) {\n \t\t\t\tif (FlatVector::Nullmask(vec)[row_idx]) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\t// omg\n \t\t\t\tauto d_str = ((string_t *)FlatVector::GetData(vec))[row_idx];\n-\t\t\t\tauto bb = env->NewDirectByteBuffer((void *)d_str.GetDataUnsafe(), d_str.GetSize());\n-\t\t\t\tauto j_cb = env->CallObjectMethod(charset, charset_decode, bb);\n-\t\t\t\tauto j_str = env->CallObjectMethod(j_cb, charbuffer_to_string);\n-\n+\t\t\t\tauto j_str = decode_charbuffer_to_jstring(env, d_str.GetDataUnsafe(), d_str.GetSize());\n \t\t\t\tenv->SetObjectArrayElement(varlen_data, row_idx, j_str);\n \t\t\t}\n \t\t\tbreak;\n",
  "test_patch": "diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex aaebc706f05b..86e9ac53f648 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -1288,6 +1288,10 @@ public static void test_utf_string_bug1271() throws Exception {\n \t\tStatement stmt = conn.createStatement();\n \n \t\tResultSet rs = stmt.executeQuery(\"SELECT 'M\u00fchleisen', '\ud83e\udd86', '\ud83e\udd84\u0f80\u0f72123456789'\");\n+\t\tassertEquals(rs.getMetaData().getColumnName(1), \"M\u00fchleisen\");\n+\t\tassertEquals(rs.getMetaData().getColumnName(2), \"\ud83e\udd86\");\n+\t\tassertEquals(rs.getMetaData().getColumnName(3), \"\ud83e\udd84\u0f80\u0f72123456789\");\n+\n \t\tassertTrue(rs.next());\n \n \t\tassertEquals(rs.getString(1), \"M\u00fchleisen\");\n",
  "problem_statement": "JDBC: some emoji character will make the result string shorten\nFirst, thanks for this great project.\r\n\r\nWhen I use duckdb to develop a ETL tool to sync data with some processing between different database, I find some emoji will cause wrong data returned.\r\n\r\nIt was found when I import some json string from one database into \"jsonb\" column of postgresql. most records work ok, but one failed with \"wrong json format\", after investigate more, I found the content returned from duckdb was truncated to shorter string, which cause invalid json error.\r\n\r\nThen, I find this is related with JDBC Fetch string column from duckdb, and it is related with some emoji character. \r\n\r\nTo reproduce, we can execute the following SQL:\r\n\r\n`\r\n\r\nselect '\ud83e\udd84\u0f80\u0f72123456789'\r\n\r\n`\r\n\r\nThe result will be:\r\n\r\n\r\n+------------+\r\n|\u00f0\u009f\u00a6\u0084\u0f80\u0f72123456|\r\n+------------+\r\n|\u00f0\u009f\u00a6\u0084\u0f80\u0f72123456|\r\n+------------+\r\n\r\nThe ending 3 characters (7,8,9) will missing\r\n\r\n\r\nIf I debug in Intellij Idea,  the correct data for that emoji read from source database is:\r\n\r\n'\\uD83E' 55358\r\n'\\uDD84' 56708\r\n\r\nthe wrong data from duckdb will be (2 characters longer)\r\n\r\n'\u00f0' 240\r\n'\\u009F' 159\r\n'\u00a6' 166\r\n'\\u0084' 132\r\n\r\n\r\n\r\nDo you have any clue where maybe wrong, thanks a lot\r\n\r\n\n",
  "hints_text": "Will have a look\nWe merged a fix for this, can you please check whether this is fixed with the JDBC driver from the master branch? The binaries are here: https://github.com/cwida/duckdb/releases/tag/master-builds\n> We merged a fix for this, can you please check whether this is fixed with the JDBC driver from the master branch? The binaries are here: https://github.com/cwida/duckdb/releases/tag/master-builds\r\n\r\nHi, hannesmuehleisen, thanks a lot. I verified the jdbc cell value works correctly.\r\n\r\nThough the column name returned is still wrong.  Can you also help fix the column name returned from ResultSetMetadata\r\n\r\nresultSet.getMetaData().getColumnName()     and   resultSet.getMetaData().getColumnLabel()\r\n\r\nAlthough it is rare to have emoji in column names.\r\n\r\n\r\ncurrently, the same sql's result on my machine is: (the first line is column name or label)\r\n\r\n+-------------+\r\n| \u00f0\u009f\u00a6\u0084\u0f80\u0f72123456|\r\n+-------------+\r\n|\ud83e\udd84\u0f80\u0f72123456789|\r\n+-------------+\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n \r\n\r\n\r\n",
  "created_at": "2021-01-09T06:40:41Z"
}