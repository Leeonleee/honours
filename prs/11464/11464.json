{
  "repo": "duckdb/duckdb",
  "pull_number": 11464,
  "instance_id": "duckdb__duckdb-11464",
  "issue_numbers": [
    "11410"
  ],
  "base_commit": "f41419fa88585f929bd818d287c0e91f67a59482",
  "patch": "diff --git a/src/function/table/arrow.cpp b/src/function/table/arrow.cpp\nindex a65257a8363b..dd742b78f14e 100644\n--- a/src/function/table/arrow.cpp\n+++ b/src/function/table/arrow.cpp\n@@ -125,6 +125,10 @@ static unique_ptr<ArrowType> GetArrowLogicalTypeNoDictionary(ArrowSchema &schema\n \t} else if (format == \"+s\") {\n \t\tchild_list_t<LogicalType> child_types;\n \t\tvector<unique_ptr<ArrowType>> children;\n+\t\tif (schema.n_children == 0) {\n+\t\t\tthrow InvalidInputException(\n+\t\t\t    \"Attempted to convert a STRUCT with no fields to DuckDB which is not supported\");\n+\t\t}\n \t\tfor (idx_t type_idx = 0; type_idx < (idx_t)schema.n_children; type_idx++) {\n \t\t\tchildren.emplace_back(ArrowTableFunction::GetArrowLogicalType(*schema.children[type_idx]));\n \t\t\tchild_types.emplace_back(schema.children[type_idx]->name, children.back()->GetDuckType());\n@@ -144,6 +148,9 @@ static unique_ptr<ArrowType> GetArrowLogicalTypeNoDictionary(ArrowSchema &schema\n \n \t\tchild_list_t<LogicalType> members;\n \t\tvector<unique_ptr<ArrowType>> children;\n+\t\tif (schema.n_children == 0) {\n+\t\t\tthrow InvalidInputException(\"Attempted to convert a UNION with no fields to DuckDB which is not supported\");\n+\t\t}\n \t\tfor (idx_t type_idx = 0; type_idx < (idx_t)schema.n_children; type_idx++) {\n \t\t\tauto type = schema.children[type_idx];\n \n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/arrow/test_arrow_types.py b/tools/pythonpkg/tests/fast/arrow/test_arrow_types.py\nindex 379f517167ae..24f10ea87b96 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_arrow_types.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_arrow_types.py\n@@ -1,23 +1,16 @@\n import duckdb\n+import pytest\n \n-try:\n-    import pyarrow as pa\n-    import pyarrow.dataset as ds\n-\n-    can_run = True\n-except:\n-    can_run = False\n+pa = pytest.importorskip(\"pyarrow\")\n+ds = pytest.importorskip(\"pyarrow.dataset\")\n \n \n class TestArrowTypes(object):\n     def test_null_type(self, duckdb_cursor):\n-        if not can_run:\n-            return\n         schema = pa.schema([(\"data\", pa.null())])\n         inputs = [pa.array([None, None, None], type=pa.null())]\n         arrow_table = pa.Table.from_arrays(inputs, schema=schema)\n-        duckdb_conn = duckdb.connect()\n-        duckdb_conn.register(\"testarrow\", arrow_table)\n+        duckdb_cursor.register(\"testarrow\", arrow_table)\n         rel = duckdb.from_arrow(arrow_table).arrow()\n         # We turn it to an array of int32 nulls\n         schema = pa.schema([(\"data\", pa.int32())])\n@@ -25,3 +18,30 @@ def test_null_type(self, duckdb_cursor):\n         arrow_table = pa.Table.from_arrays(inputs, schema=schema)\n \n         assert rel['data'] == arrow_table['data']\n+\n+    def test_invalid_struct(self, duckdb_cursor):\n+        empty_struct_type = pa.struct([])\n+\n+        # Create an empty array with the defined struct type\n+        empty_array = pa.array([], type=empty_struct_type)\n+        arrow_table = pa.Table.from_arrays([empty_array], schema=pa.schema([(\"data\", empty_struct_type)]))\n+        with pytest.raises(\n+            duckdb.InvalidInputException,\n+            match='Attempted to convert a STRUCT with no fields to DuckDB which is not supported',\n+        ):\n+            duckdb_cursor.register('invalid_struct', arrow_table)\n+\n+    def test_invalid_union(self, duckdb_cursor):\n+        # Create a sparse union array from dense arrays\n+        types = pa.array([0, 1, 1], type=pa.int8())\n+        sparse_union_array = pa.UnionArray.from_sparse(types, [], type_codes=[])\n+\n+        arrow_table = pa.Table.from_arrays([sparse_union_array], schema=pa.schema([(\"data\", sparse_union_array.type)]))\n+        with pytest.raises(\n+            duckdb.InvalidInputException,\n+            match='Attempted to convert a UNION with no fields to DuckDB which is not supported',\n+        ):\n+            duckdb_cursor.register('invalid_union', arrow_table)\n+\n+            res = duckdb_cursor.sql(\"select * from invalid_union\").fetchall()\n+            print(res)\n",
  "problem_statement": "Export to arrow fails when the data contains empty struct\n### What happens?\r\n\r\nWhen data contains empty struct, `con.sql(\"SELECT * FROM t;\").arrow()` fails with INTERNAL ERROR.\r\n\r\n### To Reproduce\r\n\r\n```bash\r\npip install ibis-framework[duckdb]\r\n```\r\n```\r\nPython 3.11.8 | packaged by conda-forge | (main, Feb 16 2024, 20:49:36) [Clang 16.0.6 ] on darwin\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n```\r\n```python\r\nimport duckdb\r\nimport ibis\r\nimport pandas as pd\r\nimport pyarrow as pa\r\nfrom ibis.formats.pyarrow import PyArrowSchema\r\n\r\ndf = pd.DataFrame.from_dict({\r\n        'year': ['2024'],\r\n        'value': ['3.7'],\r\n        'footnotes': [[{}]]\r\n})\r\n\r\ncon = duckdb.connect()\r\npyarrow_schema = PyArrowSchema.from_ibis(ibis.schema({\"year\": \"string\", \"value\": \"string\", \"footnotes\": \"array<struct<>>\"}))\r\npyarrow_table = pa.Table.from_pandas(df, schema=pyarrow_schema)\r\ncon.register(\"t\", pyarrow_table)\r\ncon.sql(\"SELECT * FROM t;\").show()\r\n# \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n# \u2502  year   \u2502  value  \u2502 footnotes  \u2502\r\n# \u2502 varchar \u2502 varchar \u2502 struct()[] \u2502\r\n# \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n# \u2502 2024    \u2502 3.7     \u2502 [{}]       \u2502\r\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\ncon.sql(\"SELECT * FROM t;\").arrow()\r\n# Traceback (most recent call last):\r\n#   File \"<stdin>\", line 1, in <module>\r\n# duckdb.duckdb.InternalException: INTERNAL Error: Attempted to access index 0 within vector of size 0\r\ncon.sql(\"SELECT * FROM t;\").df()\r\n#    year value footnotes\r\n# 0  2024   3.7      [{}]\r\n```\r\n\r\n### OS:\r\n\r\narm64\r\n\r\n### DuckDB Version:\r\n\r\n0.10.1\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nChloe He\r\n\r\n### Affiliation:\r\n\r\nIbis\r\n\r\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\r\n\r\nI have tested with a release build (and could not test with a nightly build)\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-04-02T10:12:56Z"
}