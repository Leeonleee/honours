{
  "repo": "duckdb/duckdb",
  "pull_number": 8280,
  "instance_id": "duckdb__duckdb-8280",
  "issue_numbers": [
    "6767"
  ],
  "base_commit": "90ec89c0872ee8eecd4774353377cdfc14626931",
  "patch": "diff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp\nindex e841a5641912..d6629ac1675d 100644\n--- a/tools/jdbc/src/jni/duckdb_java.cpp\n+++ b/tools/jdbc/src/jni/duckdb_java.cpp\n@@ -317,7 +317,7 @@ JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1startup(JNI\n \n \t\t\ttry {\n \t\t\t\tconfig.SetOptionByName(key_str, Value(value_str));\n-\t\t\t} catch (Exception e) {\n+\t\t\t} catch (const Exception &e) {\n \t\t\t\tthrow CatalogException(\"Failed to set configuration option \\\"%s\\\"\", key_str, e.what());\n \t\t\t}\n \t\t}\n@@ -657,18 +657,8 @@ static std::string type_to_jduckdb_type(LogicalType logical_type) {\n \t}\n }\n \n-JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1meta(JNIEnv *env, jclass, jobject stmt_ref_buf) {\n-\n-\tauto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);\n-\tif (!stmt_ref || !stmt_ref->stmt || stmt_ref->stmt->HasError()) {\n-\t\tenv->ThrowNew(J_SQLException, \"Invalid statement\");\n-\t\treturn nullptr;\n-\t}\n-\n-\tauto column_count = stmt_ref->stmt->ColumnCount();\n-\tauto &names = stmt_ref->stmt->GetNames();\n-\tauto &types = stmt_ref->stmt->GetTypes();\n-\n+static jobject build_meta(JNIEnv *env, size_t column_count, size_t n_param, const duckdb::vector<string> &names,\n+                          const duckdb::vector<LogicalType> &types, StatementProperties properties) {\n \tauto name_array = env->NewObjectArray(column_count, J_String, nullptr);\n \tauto type_array = env->NewObjectArray(column_count, J_String, nullptr);\n \tauto type_detail_array = env->NewObjectArray(column_count, J_String, nullptr);\n@@ -688,11 +678,39 @@ JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1meta(JNIEnv\n \t\t                           env->NewStringUTF(type_to_jduckdb_type(types[col_idx]).c_str()));\n \t}\n \n-\tauto return_type =\n-\t    env->NewStringUTF(StatementReturnTypeToString(stmt_ref->stmt->GetStatementProperties().return_type).c_str());\n+\tauto return_type = env->NewStringUTF(StatementReturnTypeToString(properties.return_type).c_str());\n+\n+\treturn env->NewObject(J_DuckResultSetMeta, J_DuckResultSetMeta_init, n_param, column_count, name_array, type_array,\n+\t                      type_detail_array, return_type);\n+}\n+\n+JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1query_1result_1meta(JNIEnv *env, jclass,\n+                                                                                         jobject res_ref_buf) {\n+\tauto res_ref = (ResultHolder *)env->GetDirectBufferAddress(res_ref_buf);\n+\tif (!res_ref || !res_ref->res || res_ref->res->HasError()) {\n+\t\tenv->ThrowNew(J_SQLException, \"Invalid result set\");\n+\t\treturn nullptr;\n+\t}\n+\tauto &result = res_ref->res;\n+\n+\tauto n_param = -1; // no params now\n+\n+\treturn build_meta(env, result->ColumnCount(), n_param, result->names, result->types, result->properties);\n+}\n+\n+JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1prepared_1statement_1meta(JNIEnv *env, jclass,\n+                                                                                               jobject stmt_ref_buf) {\n+\n+\tauto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);\n+\tif (!stmt_ref || !stmt_ref->stmt || stmt_ref->stmt->HasError()) {\n+\t\tenv->ThrowNew(J_SQLException, \"Invalid statement\");\n+\t\treturn nullptr;\n+\t}\n+\n+\tauto &stmt = stmt_ref->stmt;\n \n-\treturn env->NewObject(J_DuckResultSetMeta, J_DuckResultSetMeta_init, stmt_ref->stmt->n_param, column_count,\n-\t                      name_array, type_array, type_detail_array, return_type);\n+\treturn build_meta(env, stmt->ColumnCount(), stmt->n_param, stmt->GetNames(), stmt->GetTypes(),\n+\t                  stmt->GetStatementProperties());\n }\n \n jobject ProcessVector(JNIEnv *env, Connection *conn_ref, Vector &vec, idx_t row_count);\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java\nindex 18582b25f080..a90cc56bd24d 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBNative.java\n@@ -88,7 +88,9 @@ public class DuckDBNative {\n \n \tprotected static native void duckdb_jdbc_release(ByteBuffer stmt_ref);\n \n-\tprotected static native DuckDBResultSetMetaData duckdb_jdbc_meta(ByteBuffer stmt_ref) throws SQLException;\n+\tprotected static native DuckDBResultSetMetaData duckdb_jdbc_query_result_meta(ByteBuffer result_ref) throws SQLException;\n+\n+\tprotected static native DuckDBResultSetMetaData duckdb_jdbc_prepared_statement_meta(ByteBuffer stmt_ref) throws SQLException;\n \n \t// returns res_ref result reference object\n \tprotected static native ByteBuffer duckdb_jdbc_execute(ByteBuffer stmt_ref, Object[] params) throws SQLException;\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java\nindex 13a71a53dbe5..64016b3423bc 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java\n@@ -105,11 +105,8 @@ private void prepare(String sql) throws SQLException {\n \n \t\ttry {\n \t\t\tstmt_ref = DuckDBNative.duckdb_jdbc_prepare(conn.conn_ref, sql.getBytes(StandardCharsets.UTF_8));\n-\t\t\tmeta = DuckDBNative.duckdb_jdbc_meta(stmt_ref);\n+\t\t\tmeta = DuckDBNative.duckdb_jdbc_prepared_statement_meta(stmt_ref);\n \t\t\tparams = new Object[0];\n-\t\t\treturnsResultSet = meta.return_type.equals(StatementReturnType.QUERY_RESULT);\n-\t\t\treturnsChangedRows = meta.return_type.equals(StatementReturnType.CHANGED_ROWS);\n-\t\t\treturnsNothing = meta.return_type.equals(StatementReturnType.NOTHING);\n \t\t}\n \t\tcatch (SQLException e) {\n \t\t\t// Delete stmt_ref as it might already be allocated\n@@ -136,7 +133,11 @@ public boolean execute() throws SQLException {\n \t\ttry {\n \t\t\tstartTransaction();\n \t\t\tresult_ref = DuckDBNative.duckdb_jdbc_execute(stmt_ref, params);\n-\t\t\tselect_result = new DuckDBResultSet(this, meta, result_ref, conn.conn_ref);\n+\t\t\tDuckDBResultSetMetaData result_meta = DuckDBNative.duckdb_jdbc_query_result_meta(result_ref);\n+\t\t\tselect_result = new DuckDBResultSet(this, result_meta, result_ref, conn.conn_ref);\n+\t\t\treturnsResultSet = result_meta.return_type.equals(StatementReturnType.QUERY_RESULT);\n+\t\t\treturnsChangedRows = result_meta.return_type.equals(StatementReturnType.CHANGED_ROWS);\n+\t\t\treturnsNothing = result_meta.return_type.equals(StatementReturnType.NOTHING);\n \t\t}\n \t\tcatch (SQLException e) {\n \t\t\t// Delete stmt_ref as it cannot be used anymore and \n@@ -164,19 +165,19 @@ else if (result_ref != null) {\n \n \t@Override\n \tpublic ResultSet executeQuery() throws SQLException {\n+\t\texecute();\n \t\tif (!returnsResultSet) {\n \t\t\tthrow new SQLException(\"executeQuery() can only be used with queries that return a ResultSet\");\n \t\t}\n-\t\texecute();\n \t\treturn getResultSet();\n \t}\n \n \t@Override\n \tpublic int executeUpdate() throws SQLException {\n+\t\texecute();\n \t\tif (!(returnsChangedRows || returnsNothing)) {\n \t\t\tthrow new SQLException(\"executeUpdate() can only be used with queries that return nothing (eg, a DDL statement), or update rows\");\n \t\t}\n-\t\texecute();\n \t\treturn getUpdateCount();\n \t}\n \n@@ -203,10 +204,10 @@ public ResultSetMetaData getMetaData() throws SQLException {\n \t\tif (isClosed()) {\n \t\t\tthrow new SQLException(\"Statement was closed\");\n \t\t}\n-\t\tif (stmt_ref == null || select_result == null) {\n-\t\t\tthrow new SQLException(\"Prepare and execute something first\");\n+\t\tif (meta == null) {\n+\t\t\tthrow new SQLException(\"Prepare something first\");\n \t\t}\n-\t\treturn select_result.getMetaData();\n+\t\treturn meta;\n \t}\n \n \t@Override\n",
  "test_patch": "diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex b5f350b92776..e042319a86e7 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -3611,6 +3611,89 @@ public static void test_cancel() throws Exception {\n \t\t}\n \t}\n \n+\tpublic static void test_prepared_statement_metadata() throws Exception {\n+\t\ttry (Connection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\t\t PreparedStatement stmt = conn.prepareStatement(\"SELECT 'hello' as world\")) {\n+\t\t\tResultSetMetaData metadata = stmt.getMetaData();\n+\t\t\tassertEquals(metadata.getColumnCount(), 1);\n+\t\t\tassertEquals(metadata.getColumnName(1), \"world\");\n+\t\t\tassertEquals(metadata.getColumnType(1), Types.VARCHAR);\n+\t\t}\n+\t}\n+\n+\tpublic static void test_unbindable_query() throws Exception {\n+\t\ttry (Connection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\t\t PreparedStatement stmt = conn.prepareStatement(\"SELECT ?, ?\")) {\n+\t\t\tstmt.setString(1, \"word1\");\n+\t\t\tstmt.setInt(2, 42);\n+\n+\t\t\tResultSetMetaData meta = stmt.getMetaData();\n+\t\t\tassertEquals(meta.getColumnCount(), 1);\n+\t\t\tassertEquals(meta.getColumnName(1), \"unknown\");\n+\t\t\tassertEquals(meta.getColumnTypeName(1), \"UNKNOWN\");\n+\t\t\tassertEquals(meta.getColumnType(1), Types.JAVA_OBJECT);\n+\n+\t\t\ttry (ResultSet resultSet = stmt.executeQuery()) {\n+\t\t\t\tResultSetMetaData metadata = resultSet.getMetaData();\n+\n+\t\t\t\tassertEquals(metadata.getColumnCount(), 2);\n+\n+\t\t\t\tassertEquals(metadata.getColumnName(1), \"$1\");\n+\t\t\t\tassertEquals(metadata.getColumnTypeName(1), \"VARCHAR\");\n+\t\t\t\tassertEquals(metadata.getColumnType(1), Types.VARCHAR);\n+\n+\t\t\t\tassertEquals(metadata.getColumnName(2), \"$2\");\n+\t\t\t\tassertEquals(metadata.getColumnTypeName(2), \"INTEGER\");\n+\t\t\t\tassertEquals(metadata.getColumnType(2), Types.INTEGER);\n+\n+\t\t\t\tresultSet.next();\n+\t\t\t\tassertEquals(resultSet.getString(1), \"word1\");\n+\t\t\t\tassertEquals(resultSet.getInt(2), 42);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static void test_labels_with_prepped_statement() throws Exception {\n+\t\ttry (Connection conn = DriverManager.getConnection(\"jdbc:duckdb:\")) {\n+\t\t\ttry (PreparedStatement stmt = conn.prepareStatement(\"SELECT ? as result\")) {\n+\t\t\t\tstmt.setString(1, \"Quack\");\n+\t\t\t\ttry (ResultSet rs = stmt.executeQuery()) {\n+\t\t\t\t\twhile (rs.next()) {\n+\t\t\t\t\t\tassertEquals(rs.getObject(\"result\"), \"Quack\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static void test_execute_updated_on_prep_stmt() throws SQLException {\n+\t\ttry (Connection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\t\t Statement s = conn.createStatement()) {\n+\t\t\ts.executeUpdate(\"create table t (i int)\");\n+\n+\t\t\ttry (PreparedStatement p = conn.prepareStatement(\"insert into t (i) select ?\")) {\n+\t\t\t\tp.setInt(1, 1);\n+\t\t\t\tp.executeUpdate();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static void test_invalid_execute_calls() throws Exception {\n+\t\ttry (Connection conn = DriverManager.getConnection(\"jdbc:duckdb:\")) {\n+\t\t\ttry (Statement s = conn.createStatement()) {\n+\t\t\t\ts.execute(\"create table test (id int)\");\n+\t\t\t}\n+\t\t\ttry (PreparedStatement s = conn.prepareStatement(\"select 1\")) {\n+\t\t\t\tString msg = assertThrows(s::executeUpdate, SQLException.class);\n+\t\t\t\tassertTrue(msg.contains(\"can only be used with queries that return nothing\") && msg.contains(\"or update rows\"));\n+\t\t\t}\n+\t\t\ttry (PreparedStatement s = conn.prepareStatement(\"insert into test values (1)\")) {\n+\t\t\t\tString msg = assertThrows(s::executeQuery, SQLException.class);\n+\t\t\t\tassertTrue(msg.contains(\"can only be used with queries that return a ResultSet\"));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tpublic static void main(String[] args) throws Exception {\n \t\t// Woo I can do reflection too, take this, JUnit!\n \t\tMethod[] methods = TestDuckDBJDBC.class.getMethods();\n",
  "problem_statement": "DuckDB JDBC Driver doesn't seem to support column name/label for PreparedStatemetns\n### What happens?\n\njbang run duck\r\n[jbang] Building jar...\r\n// stmt.execute(\"select 42 as result\");\r\nlabel: result name: result\r\nGot: 42\r\n// psmt.executeQuery(\"SELECT ? AS result\");\r\nlabel: unknown name: unknown\r\nException in thread \"main\" java.sql.SQLException: Could not find column with label result\r\n\tat org.duckdb.DuckDBResultSet.findColumn(DuckDBResultSet.java:445)\r\n\tat org.duckdb.DuckDBResultSet.getObject(DuckDBResultSet.java:481)\r\n\tat duck.handleResult(duck.java:31)\r\n\tat duck.main(duck.java:22)\n\n### To Reproduce\n\n///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\r\n//DEPS org.duckdb:duckdb_jdbc:0.7.1\r\n\r\nimport static java.lang.System.*;\r\nimport java.sql.*;\r\n\r\npublic class duck {\r\n\r\n    private static String QUERY = \"\"\"\r\n        SELECT ? as result\r\n    \"\"\";\r\n    public static void main(String... args) throws Exception {\r\n        try (var conn = DriverManager.getConnection(\"jdbc:duckdb:\")) {\r\n            try (var stmt = conn.createStatement()) {\r\n                try (var rs = stmt.executeQuery(\"SELECT 42 AS result\")) {\r\n                    handleResult(rs);\r\n                 }\r\n            }\r\n            try (var stmt = conn.prepareStatement(QUERY)) {\r\n                stmt.setString(1, args.length > 0 ? args[0] : \"Quack\");\r\n                try (var rs = stmt.executeQuery()) {\r\n                    handleResult(rs);\r\n                 }\r\n            }\r\n        }\r\n    }\r\n    private static void handleResult(ResultSet rs) throws Exception {\r\n        var md = rs.getMetaData();\r\n            out.println(\"label: \"+md.getColumnLabel(1)+ \" name: \"+ md.getColumnName(1));\r\n            while (rs.next()) {\r\n                var result = rs.getObject(\"result\");\r\n                out.println(\"Got: \"+result);\r\n            }\r\n    }\r\n}\r\n\n\n### OS:\n\nOSX\n\n### DuckDB Version:\n\n0.7.1\n\n### DuckDB Client:\n\nJava\n\n### Full Name:\n\nMichael Hunger\n\n### Affiliation:\n\nNeo4j, Inc.\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "I think you should develop a sql editor for duckdb. As far as I know, there is one called rill developer, which unfortunately does not support the windows platform. Best wishes!\n> \u6211\u8ba4\u4e3a\u4f60\u5e94\u8be5\u4e3aduckdb\u5f00\u53d1\u4e00\u4e2asql\u7f16\u8f91\u5668\u3002\u636e\u6211\u6240\u77e5\uff0c\u6709\u4e00\u4e2a\u53eb\u505a rill developer\uff0c\u4e0d\u5e78\u7684\u662f\u5b83\u4e0d\u652f\u6301 Windows \u5e73\u53f0\u3002\u613f\u4f60\u5b89\u597d\uff01\r\n\r\nI just heard back from the rill development team. They will provide stable, maintainable binary versions of windows in the near future. I wish you all the best, come on!",
  "created_at": "2023-07-17T15:38:18Z"
}