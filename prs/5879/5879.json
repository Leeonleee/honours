{
  "repo": "duckdb/duckdb",
  "pull_number": 5879,
  "instance_id": "duckdb__duckdb-5879",
  "issue_numbers": [
    "5870"
  ],
  "base_commit": "b3f6a8f16dd37efd2218a4dc09797aed1eca5c3f",
  "patch": "diff --git a/src/function/aggregate/distributive/arg_min_max.cpp b/src/function/aggregate/distributive/arg_min_max.cpp\nindex 94f66b9f0b88..e6d44e66e5cb 100644\n--- a/src/function/aggregate/distributive/arg_min_max.cpp\n+++ b/src/function/aggregate/distributive/arg_min_max.cpp\n@@ -7,33 +7,54 @@\n \n namespace duckdb {\n \n-template <class T, class T2>\n-struct ArgMinMaxState {\n-\tT arg;\n-\tT2 value;\n+struct ArgMinMaxStateBase {\n+\tArgMinMaxStateBase() : is_initialized(false) {\n+\t}\n+\n+\ttemplate <class T>\n+\tstatic inline void CreateValue(T &value) {\n+\t}\n+\n+\ttemplate <class T>\n+\tstatic inline void DestroyValue(T &value) {\n+\t}\n+\n+\ttemplate <class T>\n+\tstatic inline void AssignValue(T &target, T new_value, bool is_initialized) {\n+\t\ttarget = new_value;\n+\t}\n+\n+\ttemplate <typename T>\n+\tstatic inline void ReadValue(Vector &result, T &arg, T *target, idx_t idx) {\n+\t\ttarget[idx] = arg;\n+\t}\n+\n \tbool is_initialized;\n };\n \n-template <class T>\n-static void ArgMinMaxDestroyValue(T value) {\n+// Out-of-line specialisations\n+template <>\n+void ArgMinMaxStateBase::CreateValue(Vector *&value) {\n+\tvalue = nullptr;\n }\n \n template <>\n-void ArgMinMaxDestroyValue(string_t value) {\n+void ArgMinMaxStateBase::DestroyValue(string_t &value) {\n \tif (!value.IsInlined()) {\n \t\tdelete[] value.GetDataUnsafe();\n \t}\n }\n \n-template <class T>\n-static void ArgMinMaxAssignValue(T &target, T new_value, bool is_initialized) {\n-\ttarget = new_value;\n+template <>\n+void ArgMinMaxStateBase::DestroyValue(Vector *&value) {\n+\tdelete value;\n+\tvalue = nullptr;\n }\n \n template <>\n-void ArgMinMaxAssignValue(string_t &target, string_t new_value, bool is_initialized) {\n+void ArgMinMaxStateBase::AssignValue(string_t &target, string_t new_value, bool is_initialized) {\n \tif (is_initialized) {\n-\t\tArgMinMaxDestroyValue(target);\n+\t\tDestroyValue(target);\n \t}\n \tif (new_value.IsInlined()) {\n \t\ttarget = new_value;\n@@ -47,27 +68,51 @@ void ArgMinMaxAssignValue(string_t &target, string_t new_value, bool is_initiali\n \t}\n }\n \n+template <>\n+void ArgMinMaxStateBase::ReadValue(Vector &result, string_t &arg, string_t *target, idx_t idx) {\n+\ttarget[idx] = StringVector::AddStringOrBlob(result, arg);\n+}\n+\n+template <class A, class B>\n+struct ArgMinMaxState : public ArgMinMaxStateBase {\n+\tusing ARG_TYPE = A;\n+\tusing BY_TYPE = B;\n+\n+\tARG_TYPE arg;\n+\tBY_TYPE value;\n+\n+\tArgMinMaxState() {\n+\t\tCreateValue(arg);\n+\t\tCreateValue(value);\n+\t}\n+\n+\t~ArgMinMaxState() {\n+\t\tif (is_initialized) {\n+\t\t\tDestroyValue(arg);\n+\t\t\tDestroyValue(value);\n+\t\t\tis_initialized = false;\n+\t\t}\n+\t}\n+};\n+\n template <class COMPARATOR>\n struct ArgMinMaxBase {\n \ttemplate <class STATE>\n \tstatic void Destroy(STATE *state) {\n-\t\tif (state->is_initialized) {\n-\t\t\tArgMinMaxDestroyValue(state->arg);\n-\t\t\tArgMinMaxDestroyValue(state->value);\n-\t\t}\n+\t\tstate->~STATE();\n \t}\n \n \ttemplate <class STATE>\n \tstatic void Initialize(STATE *state) {\n-\t\tstate->is_initialized = false;\n+\t\tnew (state) STATE;\n \t}\n \n \ttemplate <class A_TYPE, class B_TYPE, class STATE, class OP>\n \tstatic void Operation(STATE *state, AggregateInputData &, A_TYPE *x_data, B_TYPE *y_data, ValidityMask &amask,\n \t                      ValidityMask &bmask, idx_t xidx, idx_t yidx) {\n \t\tif (!state->is_initialized) {\n-\t\t\tArgMinMaxAssignValue<A_TYPE>(state->arg, x_data[xidx], false);\n-\t\t\tArgMinMaxAssignValue<B_TYPE>(state->value, y_data[yidx], false);\n+\t\t\tSTATE::template AssignValue<A_TYPE>(state->arg, x_data[xidx], false);\n+\t\t\tSTATE::template AssignValue<B_TYPE>(state->value, y_data[yidx], false);\n \t\t\tstate->is_initialized = true;\n \t\t} else {\n \t\t\tOP::template Execute<A_TYPE, B_TYPE, STATE>(state, x_data[xidx], y_data[yidx]);\n@@ -77,8 +122,8 @@ struct ArgMinMaxBase {\n \ttemplate <class A_TYPE, class B_TYPE, class STATE>\n \tstatic void Execute(STATE *state, A_TYPE x_data, B_TYPE y_data) {\n \t\tif (COMPARATOR::Operation(y_data, state->value)) {\n-\t\t\tArgMinMaxAssignValue<A_TYPE>(state->arg, x_data, true);\n-\t\t\tArgMinMaxAssignValue<B_TYPE>(state->value, y_data, true);\n+\t\t\tSTATE::template AssignValue<A_TYPE>(state->arg, x_data, true);\n+\t\t\tSTATE::template AssignValue<B_TYPE>(state->value, y_data, true);\n \t\t}\n \t}\n \n@@ -88,97 +133,213 @@ struct ArgMinMaxBase {\n \t\t\treturn;\n \t\t}\n \t\tif (!target->is_initialized || COMPARATOR::Operation(source.value, target->value)) {\n-\t\t\tArgMinMaxAssignValue(target->arg, source.arg, target->is_initialized);\n-\t\t\tArgMinMaxAssignValue(target->value, source.value, target->is_initialized);\n+\t\t\tSTATE::template AssignValue(target->arg, source.arg, target->is_initialized);\n+\t\t\tSTATE::template AssignValue(target->value, source.value, target->is_initialized);\n \t\t\ttarget->is_initialized = true;\n \t\t}\n \t}\n \n-\tstatic bool IgnoreNull() {\n-\t\treturn true;\n-\t}\n-};\n-\n-template <class COMPARATOR>\n-struct StringArgMinMax : public ArgMinMaxBase<COMPARATOR> {\n \ttemplate <class T, class STATE>\n \tstatic void Finalize(Vector &result, AggregateInputData &, STATE *state, T *target, ValidityMask &mask, idx_t idx) {\n \t\tif (!state->is_initialized) {\n \t\t\tmask.SetInvalid(idx);\n \t\t} else {\n-\t\t\ttarget[idx] = StringVector::AddStringOrBlob(result, state->arg);\n+\t\t\tSTATE::template ReadValue(result, state->arg, target, idx);\n \t\t}\n \t}\n+\n+\tstatic bool IgnoreNull() {\n+\t\treturn true;\n+\t}\n };\n \n-template <class COMPARATOR>\n-struct NumericArgMinMax : public ArgMinMaxBase<COMPARATOR> {\n+template <typename COMPARATOR>\n+struct VectorArgMinMaxBase : ArgMinMaxBase<COMPARATOR> {\n+\ttemplate <class STATE>\n+\tstatic void AssignVector(STATE *state, Vector &arg, const idx_t idx) {\n+\t\tif (!state->is_initialized) {\n+\t\t\tstate->arg = new Vector(arg.GetType());\n+\t\t\tstate->arg->SetVectorType(VectorType::CONSTANT_VECTOR);\n+\t\t}\n+\t\tsel_t selv = idx;\n+\t\tSelectionVector sel(&selv);\n+\t\tVectorOperations::Copy(arg, *state->arg, sel, 1, 0, 0);\n+\t}\n+\n+\ttemplate <class STATE>\n+\tstatic void Update(Vector inputs[], AggregateInputData &, idx_t input_count, Vector &state_vector, idx_t count) {\n+\t\tauto &arg = inputs[0];\n+\t\tUnifiedVectorFormat adata;\n+\t\targ.ToUnifiedFormat(count, adata);\n+\n+\t\tusing BY_TYPE = typename STATE::BY_TYPE;\n+\t\tauto &by = inputs[1];\n+\t\tUnifiedVectorFormat bdata;\n+\t\tby.ToUnifiedFormat(count, bdata);\n+\t\tconst auto bys = (BY_TYPE *)bdata.data;\n+\n+\t\tUnifiedVectorFormat sdata;\n+\t\tstate_vector.ToUnifiedFormat(count, sdata);\n+\n+\t\tauto states = (STATE **)sdata.data;\n+\t\tfor (idx_t i = 0; i < count; i++) {\n+\t\t\tconst auto aidx = adata.sel->get_index(i);\n+\t\t\tconst auto bidx = bdata.sel->get_index(i);\n+\t\t\tif (!bdata.validity.RowIsValid(bidx)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tconst auto bval = bys[bidx];\n+\n+\t\t\tconst auto sidx = sdata.sel->get_index(i);\n+\t\t\tauto state = states[sidx];\n+\t\t\tif (!state->is_initialized) {\n+\t\t\t\tSTATE::template AssignValue<BY_TYPE>(state->value, bval, false);\n+\t\t\t\tAssignVector(state, arg, aidx);\n+\t\t\t\tstate->is_initialized = true;\n+\n+\t\t\t} else if (COMPARATOR::template Operation<BY_TYPE>(bval, state->value)) {\n+\t\t\t\tSTATE::template AssignValue<BY_TYPE>(state->value, bval, true);\n+\t\t\t\tAssignVector(state, arg, aidx);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\ttemplate <class STATE, class OP>\n+\tstatic void Combine(const STATE &source, STATE *target, AggregateInputData &) {\n+\t\tif (!source.is_initialized) {\n+\t\t\treturn;\n+\t\t}\n+\t\tif (!target->is_initialized || COMPARATOR::Operation(source.value, target->value)) {\n+\t\t\tSTATE::template AssignValue(target->value, source.value, target->is_initialized);\n+\t\t\tAssignVector(target, *source.arg, 0);\n+\t\t\ttarget->is_initialized = true;\n+\t\t}\n+\t}\n+\n \ttemplate <class T, class STATE>\n \tstatic void Finalize(Vector &result, AggregateInputData &, STATE *state, T *target, ValidityMask &mask, idx_t idx) {\n \t\tif (!state->is_initialized) {\n-\t\t\tmask.SetInvalid(idx);\n+\t\t\t// we need to use SetNull here\n+\t\t\t// since for STRUCT columns only setting the validity mask of the struct is incorrect\n+\t\t\t// as for a struct column, we need to also set ALL child columns to NULL\n+\t\t\tswitch (result.GetVectorType()) {\n+\t\t\tcase VectorType::FLAT_VECTOR:\n+\t\t\t\tFlatVector::SetNull(result, idx, true);\n+\t\t\t\tbreak;\n+\t\t\tcase VectorType::CONSTANT_VECTOR:\n+\t\t\t\tConstantVector::SetNull(result, true);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow InternalException(\"Invalid result vector type for nested arg_min/max\");\n+\t\t\t}\n \t\t} else {\n-\t\t\ttarget[idx] = state->arg;\n+\t\t\tVectorOperations::Copy(*state->arg, result, 1, 0, idx);\n \t\t}\n \t}\n+\n+\tstatic unique_ptr<FunctionData> Bind(ClientContext &context, AggregateFunction &function,\n+\t                                     vector<unique_ptr<Expression>> &arguments) {\n+\t\tfunction.arguments[0] = arguments[0]->return_type;\n+\t\tfunction.return_type = arguments[0]->return_type;\n+\t\treturn nullptr;\n+\t}\n };\n \n-using NumericArgMinOperation = NumericArgMinMax<LessThan>;\n-using NumericArgMaxOperation = NumericArgMinMax<GreaterThan>;\n-using StringArgMinOperation = StringArgMinMax<LessThan>;\n-using StringArgMaxOperation = StringArgMinMax<GreaterThan>;\n+template <class OP, class ARG_TYPE, class BY_TYPE>\n+AggregateFunction GetVectorArgMinMaxFunctionInternal(const LogicalType &by_type, const LogicalType &type) {\n+\tusing STATE = ArgMinMaxState<ARG_TYPE, BY_TYPE>;\n+\treturn AggregateFunction({type, by_type}, type, AggregateFunction::StateSize<STATE>,\n+\t                         AggregateFunction::StateInitialize<STATE, OP>, OP::template Update<STATE>,\n+\t                         AggregateFunction::StateCombine<STATE, OP>,\n+\t                         AggregateFunction::StateFinalize<STATE, void, OP>, nullptr, OP::Bind,\n+\t                         AggregateFunction::StateDestroy<STATE, OP>);\n+}\n \n-template <class OP, class T, class T2>\n-AggregateFunction GetArgMinMaxFunctionInternal(const LogicalType &arg_2, const LogicalType &arg) {\n-\tauto function = AggregateFunction::BinaryAggregate<ArgMinMaxState<T, T2>, T, T2, T, OP>(arg, arg_2, arg);\n-\tif (arg.InternalType() == PhysicalType::VARCHAR || arg_2.InternalType() == PhysicalType::VARCHAR) {\n-\t\tfunction.destructor = AggregateFunction::StateDestroy<ArgMinMaxState<T, T2>, OP>;\n+template <class OP, class ARG_TYPE>\n+AggregateFunction GetVectorArgMinMaxFunctionBy(const LogicalType &by_type, const LogicalType &type) {\n+\tswitch (by_type.InternalType()) {\n+\tcase PhysicalType::INT32:\n+\t\treturn GetVectorArgMinMaxFunctionInternal<OP, ARG_TYPE, int32_t>(by_type, type);\n+\tcase PhysicalType::INT64:\n+\t\treturn GetVectorArgMinMaxFunctionInternal<OP, ARG_TYPE, int64_t>(by_type, type);\n+\tcase PhysicalType::DOUBLE:\n+\t\treturn GetVectorArgMinMaxFunctionInternal<OP, ARG_TYPE, double>(by_type, type);\n+\tcase PhysicalType::VARCHAR:\n+\t\treturn GetVectorArgMinMaxFunctionInternal<OP, ARG_TYPE, string_t>(by_type, type);\n+\tdefault:\n+\t\tthrow InternalException(\"Unimplemented arg_min/arg_max aggregate\");\n+\t}\n+}\n+\n+template <class OP, class ARG_TYPE>\n+void AddVectorArgMinMaxFunctionBy(AggregateFunctionSet &fun, const LogicalType &type) {\n+\tfun.AddFunction(GetVectorArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::INTEGER, type));\n+\tfun.AddFunction(GetVectorArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::BIGINT, type));\n+\tfun.AddFunction(GetVectorArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::DOUBLE, type));\n+\tfun.AddFunction(GetVectorArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::VARCHAR, type));\n+\tfun.AddFunction(GetVectorArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::DATE, type));\n+\tfun.AddFunction(GetVectorArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::TIMESTAMP, type));\n+\tfun.AddFunction(GetVectorArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::TIMESTAMP_TZ, type));\n+\tfun.AddFunction(GetVectorArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::BLOB, type));\n+}\n+\n+template <class OP, class ARG_TYPE, class BY_TYPE>\n+AggregateFunction GetArgMinMaxFunctionInternal(const LogicalType &by_type, const LogicalType &type) {\n+\tusing STATE = ArgMinMaxState<ARG_TYPE, BY_TYPE>;\n+\tauto function = AggregateFunction::BinaryAggregate<STATE, ARG_TYPE, BY_TYPE, ARG_TYPE, OP>(type, by_type, type);\n+\tif (type.InternalType() == PhysicalType::VARCHAR || by_type.InternalType() == PhysicalType::VARCHAR) {\n+\t\tfunction.destructor = AggregateFunction::StateDestroy<STATE, OP>;\n \t}\n \treturn function;\n }\n-template <class OP, class T>\n-AggregateFunction GetArgMinMaxFunctionArg2(const LogicalType &arg_2, const LogicalType &arg) {\n-\tswitch (arg_2.InternalType()) {\n+\n+template <class OP, class ARG_TYPE>\n+AggregateFunction GetArgMinMaxFunctionBy(const LogicalType &by_type, const LogicalType &type) {\n+\tswitch (by_type.InternalType()) {\n \tcase PhysicalType::INT32:\n-\t\treturn GetArgMinMaxFunctionInternal<OP, T, int32_t>(arg_2, arg);\n+\t\treturn GetArgMinMaxFunctionInternal<OP, ARG_TYPE, int32_t>(by_type, type);\n \tcase PhysicalType::INT64:\n-\t\treturn GetArgMinMaxFunctionInternal<OP, T, int64_t>(arg_2, arg);\n+\t\treturn GetArgMinMaxFunctionInternal<OP, ARG_TYPE, int64_t>(by_type, type);\n \tcase PhysicalType::DOUBLE:\n-\t\treturn GetArgMinMaxFunctionInternal<OP, T, double>(arg_2, arg);\n+\t\treturn GetArgMinMaxFunctionInternal<OP, ARG_TYPE, double>(by_type, type);\n \tcase PhysicalType::VARCHAR:\n-\t\treturn GetArgMinMaxFunctionInternal<OP, T, string_t>(arg_2, arg);\n+\t\treturn GetArgMinMaxFunctionInternal<OP, ARG_TYPE, string_t>(by_type, type);\n \tdefault:\n \t\tthrow InternalException(\"Unimplemented arg_min/arg_max aggregate\");\n \t}\n }\n \n-template <class OP, class T>\n-void AddArgMinMaxFunctionArg2(AggregateFunctionSet &fun, const LogicalType &arg) {\n-\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::INTEGER, arg));\n-\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::BIGINT, arg));\n-\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::DOUBLE, arg));\n-\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::VARCHAR, arg));\n-\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::DATE, arg));\n-\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::TIMESTAMP, arg));\n-\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::TIMESTAMP_TZ, arg));\n-\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::BLOB, arg));\n+template <class OP, class ARG_TYPE>\n+void AddArgMinMaxFunctionBy(AggregateFunctionSet &fun, const LogicalType &type) {\n+\tfun.AddFunction(GetArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::INTEGER, type));\n+\tfun.AddFunction(GetArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::BIGINT, type));\n+\tfun.AddFunction(GetArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::DOUBLE, type));\n+\tfun.AddFunction(GetArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::VARCHAR, type));\n+\tfun.AddFunction(GetArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::DATE, type));\n+\tfun.AddFunction(GetArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::TIMESTAMP, type));\n+\tfun.AddFunction(GetArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::TIMESTAMP_TZ, type));\n+\tfun.AddFunction(GetArgMinMaxFunctionBy<OP, ARG_TYPE>(LogicalType::BLOB, type));\n }\n \n-template <class OP, class STRING_OP>\n+template <class COMPARATOR>\n static void AddArgMinMaxFunctions(AggregateFunctionSet &fun) {\n-\tAddArgMinMaxFunctionArg2<OP, int32_t>(fun, LogicalType::INTEGER);\n-\tAddArgMinMaxFunctionArg2<OP, int64_t>(fun, LogicalType::BIGINT);\n-\tAddArgMinMaxFunctionArg2<OP, double>(fun, LogicalType::DOUBLE);\n-\tAddArgMinMaxFunctionArg2<STRING_OP, string_t>(fun, LogicalType::VARCHAR);\n-\tAddArgMinMaxFunctionArg2<OP, date_t>(fun, LogicalType::DATE);\n-\tAddArgMinMaxFunctionArg2<OP, timestamp_t>(fun, LogicalType::TIMESTAMP);\n-\tAddArgMinMaxFunctionArg2<OP, timestamp_t>(fun, LogicalType::TIMESTAMP_TZ);\n-\tAddArgMinMaxFunctionArg2<STRING_OP, string_t>(fun, LogicalType::BLOB);\n+\tusing OP = ArgMinMaxBase<COMPARATOR>;\n+\tAddArgMinMaxFunctionBy<OP, int32_t>(fun, LogicalType::INTEGER);\n+\tAddArgMinMaxFunctionBy<OP, int64_t>(fun, LogicalType::BIGINT);\n+\tAddArgMinMaxFunctionBy<OP, double>(fun, LogicalType::DOUBLE);\n+\tAddArgMinMaxFunctionBy<OP, string_t>(fun, LogicalType::VARCHAR);\n+\tAddArgMinMaxFunctionBy<OP, date_t>(fun, LogicalType::DATE);\n+\tAddArgMinMaxFunctionBy<OP, timestamp_t>(fun, LogicalType::TIMESTAMP);\n+\tAddArgMinMaxFunctionBy<OP, timestamp_t>(fun, LogicalType::TIMESTAMP_TZ);\n+\tAddArgMinMaxFunctionBy<OP, string_t>(fun, LogicalType::BLOB);\n+\n+\tusing VECTOR_OP = VectorArgMinMaxBase<COMPARATOR>;\n+\tAddVectorArgMinMaxFunctionBy<VECTOR_OP, Vector *>(fun, LogicalType::ANY);\n }\n \n void ArgMinFun::RegisterFunction(BuiltinFunctions &set) {\n \tAggregateFunctionSet fun(\"argmin\");\n-\tAddArgMinMaxFunctions<NumericArgMinOperation, StringArgMinOperation>(fun);\n+\tAddArgMinMaxFunctions<LessThan>(fun);\n \tset.AddFunction(fun);\n \n \t//! Add min_by alias\n@@ -192,7 +353,7 @@ void ArgMinFun::RegisterFunction(BuiltinFunctions &set) {\n \n void ArgMaxFun::RegisterFunction(BuiltinFunctions &set) {\n \tAggregateFunctionSet fun(\"argmax\");\n-\tAddArgMinMaxFunctions<NumericArgMaxOperation, StringArgMaxOperation>(fun);\n+\tAddArgMinMaxFunctions<GreaterThan>(fun);\n \tset.AddFunction(fun);\n \n \t//! Add max_by alias\n",
  "test_patch": "diff --git a/scripts/run_test_list.py b/scripts/run_test_list.py\nindex fc793a681858..2810bedb72eb 100644\n--- a/scripts/run_test_list.py\n+++ b/scripts/run_test_list.py\n@@ -21,11 +21,7 @@\n \n \n test_cases = []\n-first_line = True\n for line in sys.stdin:\n-\tif first_line:\n-\t\tfirst_line = False\n-\t\tcontinue\n \tif len(line.strip()) == 0:\n \t\tcontinue\n \tsplits = line.rsplit('\\t', 1)\n@@ -34,7 +30,8 @@\n test_count = len(test_cases)\n return_code = 0\n for test_number in range(test_count):\n-\tprint(\"[\" + str(test_number) + \"/\" + str(test_count) + \"]: \" + test_cases[test_number])\n+\tsys.stdout.write(\"[\" + str(test_number) + \"/\" + str(test_count) + \"]: \" + test_cases[test_number])\n+\tsys.stdout.flush()\n \tres = subprocess.run([unittest_program, test_cases[test_number]], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n \tstdout = res.stdout.decode('utf8')\n \tstderr = res.stderr.decode('utf8')\ndiff --git a/test/sql/aggregate/aggregates/test_arg_min_max_nested.test b/test/sql/aggregate/aggregates/test_arg_min_max_nested.test\nnew file mode 100644\nindex 000000000000..f270cfd48151\n--- /dev/null\n+++ b/test/sql/aggregate/aggregates/test_arg_min_max_nested.test\n@@ -0,0 +1,141 @@\n+# name: test/sql/aggregate/aggregates/test_arg_min_max_nested.test\n+# description: Test arg_min/arg_max with nested types\n+# group: [aggregates]\n+\n+statement ok\n+SELECT SETSEED(0.8675309);\n+\n+statement ok\n+CREATE TABLE tbl(\n+\t\"DATE\" DATE,\n+\t\"TIMESTAMP\" TIMESTAMP,\n+\t\"INTEGER\" INTEGER,\n+\t\"BIGINT\" BIGINT,\n+\t\"DOUBLE\" DOUBLE,\n+\t\"VARCHAR\" VARCHAR);\n+\n+# fill up the table with some random gunk in the middle\n+statement ok\n+INSERT INTO tbl\n+\tSELECT\n+\t\tDATE '1992-01-02' + INTERVAL ((RANDOM() * 300)::INT) DAYS d,\n+\t\tTIMESTAMP '1992-01-02 23:20:11' + INTERVAL ((RANDOM() * 300)::INT) DAYS + INTERVAL ((RANDOM() * 60 * 60)::INT) SECONDS ts,\n+\t\t50 + (RANDOM() * 6000)::INT i,\n+\t\t10 + (RANDOM() * 899999999)::BIGINT bi,\n+\t\t1 + RANDOM() * 99 dbl,\n+\t\tconcat(chr(98 + (RANDOM() * 24)::INT), chr(98 + (RANDOM() * 24)::INT), chr(98 + (RANDOM() * 24)::INT), chr(98 + (RANDOM() * 24)::INT), repeat(chr(98 + (RANDOM() * 24)::INT), 29)) str\n+\tFROM\n+\t\trange(10000);\n+\n+# insert the min and the max values\n+statement ok\n+INSERT INTO tbl VALUES (\n+\tDATE '1992-01-01',\n+\tTIMESTAMP '1992-01-01 23:20:11',\n+\t42,\n+\t0,\n+\t0.5,\n+\t'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n+)\n+\n+statement ok\n+INSERT INTO tbl VALUES (\n+\tDATE '1993-01-01',\n+\tTIMESTAMP '1993-01-01 23:20:11',\n+\t8400,\n+\t999999999,\n+\t100.5,\n+\t'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'\n+)\n+\n+#\n+# STRUCTs\n+#\n+\n+# By VARCHAR\n+query I\n+SELECT arg_min({d: \"DATE\", ts: \"TIMESTAMP\", i: \"INTEGER\", b: \"BIGINT\", f: \"DOUBLE\"}, \"VARCHAR\")\n+FROM tbl;\n+----\n+{'d': 1992-01-01, 'ts': 1992-01-01 23:20:11, 'i': 42, 'b': 0, 'f': 0.5}\n+\n+query I\n+SELECT arg_max({d: \"DATE\", ts: \"TIMESTAMP\", i: \"INTEGER\", b: \"BIGINT\", f: \"DOUBLE\"}, \"VARCHAR\")\n+FROM tbl;\n+----\n+{'d': 1993-01-01, 'ts': 1993-01-01 23:20:11, 'i': 8400, 'b': 999999999, 'f': 100.5}\n+\n+# By Scalar\n+query I\n+SELECT arg_min({d: \"DATE\", ts: \"TIMESTAMP\", i: \"INTEGER\", b: \"BIGINT\", s: \"VARCHAR\"}, \"DOUBLE\")\n+FROM tbl;\n+----\n+{'d': 1992-01-01, 'ts': 1992-01-01 23:20:11, 'i': 42, 'b': 0, 's': aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}\n+\n+query I\n+SELECT arg_max({d: \"DATE\", ts: \"TIMESTAMP\", i: \"INTEGER\", b: \"BIGINT\", s: \"VARCHAR\"}, \"DOUBLE\")\n+FROM tbl;\n+----\n+{'d': 1993-01-01, 'ts': 1993-01-01 23:20:11, 'i': 8400, 'b': 999999999, 's': zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz}\n+\n+#\n+# Lists\n+#\n+\n+# By VARCHAR\n+query I\n+SELECT arg_min([\"DATE\", \"DATE\" + INTERVAL 1 DAY, NULL, \"TIMESTAMP\"], \"VARCHAR\")\n+FROM tbl;\n+----\n+[1992-01-01 00:00:00, 1992-01-02 00:00:00, NULL, 1992-01-01 23:20:11]\n+\n+query I\n+SELECT arg_max([\"DATE\", \"DATE\" + INTERVAL 1 DAY, NULL, \"TIMESTAMP\"], \"VARCHAR\")\n+FROM tbl;\n+----\n+[1993-01-01 00:00:00, 1993-01-02 00:00:00, NULL, 1993-01-01 23:20:11]\n+\n+\n+# By Scalar\n+query I\n+SELECT arg_min([\"DATE\", \"DATE\" + INTERVAL 1 DAY, NULL, \"TIMESTAMP\"], \"DOUBLE\")\n+FROM tbl;\n+----\n+[1992-01-01 00:00:00, 1992-01-02 00:00:00, NULL, 1992-01-01 23:20:11]\n+\n+query I\n+SELECT arg_max([\"DATE\", \"DATE\" + INTERVAL 1 DAY, NULL, \"TIMESTAMP\"], \"DOUBLE\")\n+FROM tbl;\n+----\n+[1993-01-01 00:00:00, 1993-01-02 00:00:00, NULL, 1993-01-01 23:20:11]\n+\n+#\n+# Nested\n+#\n+\n+# By VARCHAR\n+query I\n+SELECT arg_min({l: [\"DATE\", \"DATE\" + INTERVAL 1 DAY, NULL, \"TIMESTAMP\"], i: \"INTEGER\", b: \"BIGINT\", f: \"DOUBLE\"}, \"VARCHAR\")\n+FROM tbl;\n+----\n+{'l': [1992-01-01 00:00:00, 1992-01-02 00:00:00, NULL, 1992-01-01 23:20:11], 'i': 42, 'b': 0, 'f': 0.5}\n+\n+query I\n+SELECT arg_max({l: [\"DATE\", \"DATE\" + INTERVAL 1 DAY, NULL, \"TIMESTAMP\"], i: \"INTEGER\", b: \"BIGINT\", f: \"DOUBLE\"}, \"VARCHAR\")\n+FROM tbl;\n+----\n+{'l': [1993-01-01 00:00:00, 1993-01-02 00:00:00, NULL, 1993-01-01 23:20:11], 'i': 8400, 'b': 999999999, 'f': 100.5}\n+\n+\n+# By Scalar\n+query I\n+SELECT arg_min({l: [\"DATE\", \"DATE\" + INTERVAL 1 DAY, NULL, \"TIMESTAMP\"], i: \"INTEGER\", b: \"BIGINT\", s: \"VARCHAR\"}, \"DOUBLE\")\n+FROM tbl;\n+----\n+{'l': [1992-01-01 00:00:00, 1992-01-02 00:00:00, NULL, 1992-01-01 23:20:11], 'i': 42, 'b': 0, 's': aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}\n+\n+query I\n+SELECT arg_max({l: [\"DATE\", \"DATE\" + INTERVAL 1 DAY, NULL, \"TIMESTAMP\"], i: \"INTEGER\", b: \"BIGINT\", s: \"VARCHAR\"}, \"DOUBLE\")\n+FROM tbl;\n+----\n+{'l': [1993-01-01 00:00:00, 1993-01-02 00:00:00, NULL, 1993-01-01 23:20:11], 'i': 8400, 'b': 999999999, 's': zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz}\n",
  "problem_statement": "arg_min/arg_max of a struct returns varchar\n### What happens?\n\nBug report requested by @hawkfish! \r\n\r\nWhen the arg_min/max (min_by/max_by) function is passed a struct as the first parameter, a varchar is returned rather than a struct as expected. \r\n\r\nThe benefit of this method would be to do the possibly expensive min/max operation once, but record up to the entire row of information in struct format at that min/max row (rather than calling arg_min many times with different column names to retrieve).\r\n\r\nAs a note, a struct can also be passed in as the second argument, which is used when calculating the min or max. I'm not sure if that is behaving as a struct, or being converted to a varchar first. The benefit of that approach would be to effectively sort by multiple columns.\n\n### To Reproduce\n\n```sql\r\ncreate or replace table times as \r\n    select current_timestamp as ts, 2 as tiebreaker, 'second from min' as value \r\n    union all \r\n    select current_timestamp, 1, 'min' \r\n    union all \r\n    select current_timestamp + interval 1 minute, 1 as tiebreaker, 'max!';\r\n\r\nselect \r\n    arg_min({ts:ts, tiebreaker:tiebreaker,value:value},{ts:ts, tiebreaker: tiebreaker}) as result \r\nfrom times;\r\n\r\nselect \r\n    typeof(\r\n        arg_min({ts:ts, tiebreaker:tiebreaker,value:value},{ts:ts, tiebreaker: tiebreaker})\r\n    ) as typeof_result \r\nfrom times;\r\n```\r\n```markdown\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                              result                               \u2502\r\n\u2502                              varchar                              \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 {'ts': 2023-01-09 13:25:17.191-07, 'tiebreaker': 1, 'value': min} \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 typeof_result \u2502\r\n\u2502    varchar    \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 VARCHAR       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n\n### OS:\n\nWindows 10\n\n### DuckDB Version:\n\n0.6.1\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nAlex Monahan\n\n### Affiliation:\n\nIntel and DuckDB Labs\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-01-10T19:21:26Z"
}