You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
DuckDB crash when preparing too long sql
#### What happens?
When the DuckDB executes a too-long SQL containing more than 3000 CASE WHEN statements, DuckDB will crash.
My Java program process is also finished.

```
Process finished with exit code -1073741571 (0xC00000FD)
```

According to my research, the error code represents that maximum recursion depth exceeded.
In debug mode, I found the issue happened in [DuckDBNative.duckdb_jdbc_prepare](https://github.com/duckdb/duckdb/blob/master/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java#L73).

I also asked a question in Discusstions, please refer to [DuckDB crash when preparing too long sql](https://github.com/duckdb/duckdb/discussions/2571).

#### To Reproduce
Execute a too-long SQL containing more than 3000 CASE WHEN statements.

#### Environment (please complete the following information):
 - OS: Windows 10
 - DuckDB Version: 0.3.0
 - DuckDB Client: Java

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

DuckDB crash when preparing too long sql
#### What happens?
When the DuckDB executes a too-long SQL containing more than 3000 CASE WHEN statements, DuckDB will crash.
My Java program process is also finished.

```
Process finished with exit code -1073741571 (0xC00000FD)
```

According to my research, the error code represents that maximum recursion depth exceeded.
In debug mode, I found the issue happened in [DuckDBNative.duckdb_jdbc_prepare](https://github.com/duckdb/duckdb/blob/master/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java#L73).

I also asked a question in Discusstions, please refer to [DuckDB crash when preparing too long sql](https://github.com/duckdb/duckdb/discussions/2571).

#### To Reproduce
Execute a too-long SQL containing more than 3000 CASE WHEN statements.

#### Environment (please complete the following information):
 - OS: Windows 10
 - DuckDB Version: 0.3.0
 - DuckDB Client: Java

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/execution/expression_executor/execute_case.cpp]
1: #include "duckdb/common/vector_operations/vector_operations.hpp"
2: #include "duckdb/execution/expression_executor.hpp"
3: #include "duckdb/planner/expression/bound_case_expression.hpp"
4: #include "duckdb/common/types/chunk_collection.hpp"
5: 
6: namespace duckdb {
7: 
8: struct CaseExpressionState : public ExpressionState {
9: 	CaseExpressionState(const Expression &expr, ExpressionExecutorState &root)
10: 	    : ExpressionState(expr, root), true_sel(STANDARD_VECTOR_SIZE), false_sel(STANDARD_VECTOR_SIZE) {
11: 	}
12: 
13: 	SelectionVector true_sel;
14: 	SelectionVector false_sel;
15: };
16: 
17: unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const BoundCaseExpression &expr,
18:                                                                 ExpressionExecutorState &root) {
19: 	auto result = make_unique<CaseExpressionState>(expr, root);
20: 	result->AddChild(expr.check.get());
21: 	result->AddChild(expr.result_if_true.get());
22: 	result->AddChild(expr.result_if_false.get());
23: 	result->Finalize();
24: 	return move(result);
25: }
26: 
27: void ExpressionExecutor::Execute(const BoundCaseExpression &expr, ExpressionState *state_p, const SelectionVector *sel,
28:                                  idx_t count, Vector &result) {
29: 	auto state = (CaseExpressionState *)state_p;
30: 
31: 	state->intermediate_chunk.Reset();
32: 	auto &res_true = state->intermediate_chunk.data[1];
33: 	auto &res_false = state->intermediate_chunk.data[2];
34: 
35: 	auto check_state = state->child_states[0].get();
36: 	auto res_true_state = state->child_states[1].get();
37: 	auto res_false_state = state->child_states[2].get();
38: 
39: 	// first execute the check expression
40: 	auto &true_sel = state->true_sel;
41: 	auto &false_sel = state->false_sel;
42: 	idx_t tcount = Select(*expr.check, check_state, sel, count, &true_sel, &false_sel);
43: 	idx_t fcount = count - tcount;
44: 	if (fcount == 0) {
45: 		// everything is true, only execute TRUE side
46: 		Execute(*expr.result_if_true, res_true_state, sel, count, result);
47: 	} else if (tcount == 0) {
48: 		// everything is false, only execute FALSE side
49: 		Execute(*expr.result_if_false, res_false_state, sel, count, result);
50: 	} else {
51: 		// have to execute both and mix and match
52: 		Execute(*expr.result_if_true, res_true_state, &true_sel, tcount, res_true);
53: 		Execute(*expr.result_if_false, res_false_state, &false_sel, fcount, res_false);
54: 
55: 		FillSwitch(res_true, result, true_sel, tcount);
56: 		FillSwitch(res_false, result, false_sel, fcount);
57: 		if (sel) {
58: 			result.Slice(*sel, count);
59: 		}
60: 	}
61: }
62: 
63: template <class T>
64: void TemplatedFillLoop(Vector &vector, Vector &result, SelectionVector &sel, sel_t count) {
65: 	result.SetVectorType(VectorType::FLAT_VECTOR);
66: 	auto res = FlatVector::GetData<T>(result);
67: 	auto &result_mask = FlatVector::Validity(result);
68: 	if (vector.GetVectorType() == VectorType::CONSTANT_VECTOR) {
69: 		auto data = ConstantVector::GetData<T>(vector);
70: 		if (ConstantVector::IsNull(vector)) {
71: 			for (idx_t i = 0; i < count; i++) {
72: 				result_mask.SetInvalid(sel.get_index(i));
73: 			}
74: 		} else {
75: 			for (idx_t i = 0; i < count; i++) {
76: 				res[sel.get_index(i)] = *data;
77: 			}
78: 		}
79: 	} else {
80: 		VectorData vdata;
81: 		vector.Orrify(count, vdata);
82: 		auto data = (T *)vdata.data;
83: 		for (idx_t i = 0; i < count; i++) {
84: 			auto source_idx = vdata.sel->get_index(i);
85: 			auto res_idx = sel.get_index(i);
86: 
87: 			res[res_idx] = data[source_idx];
88: 			result_mask.Set(res_idx, vdata.validity.RowIsValid(source_idx));
89: 		}
90: 	}
91: }
92: 
93: void ValidityFillLoop(Vector &vector, Vector &result, SelectionVector &sel, sel_t count) {
94: 	result.SetVectorType(VectorType::FLAT_VECTOR);
95: 	auto &result_mask = FlatVector::Validity(result);
96: 	if (vector.GetVectorType() == VectorType::CONSTANT_VECTOR) {
97: 		if (ConstantVector::IsNull(vector)) {
98: 			for (idx_t i = 0; i < count; i++) {
99: 				result_mask.SetInvalid(sel.get_index(i));
100: 			}
101: 		}
102: 	} else {
103: 		VectorData vdata;
104: 		vector.Orrify(count, vdata);
105: 		for (idx_t i = 0; i < count; i++) {
106: 			auto source_idx = vdata.sel->get_index(i);
107: 			auto res_idx = sel.get_index(i);
108: 
109: 			result_mask.Set(res_idx, vdata.validity.RowIsValid(source_idx));
110: 		}
111: 	}
112: }
113: 
114: void ExpressionExecutor::FillSwitch(Vector &vector, Vector &result, SelectionVector &sel, sel_t count) {
115: 	switch (result.GetType().InternalType()) {
116: 	case PhysicalType::BOOL:
117: 	case PhysicalType::INT8:
118: 		TemplatedFillLoop<int8_t>(vector, result, sel, count);
119: 		break;
120: 	case PhysicalType::INT16:
121: 		TemplatedFillLoop<int16_t>(vector, result, sel, count);
122: 		break;
123: 	case PhysicalType::INT32:
124: 		TemplatedFillLoop<int32_t>(vector, result, sel, count);
125: 		break;
126: 	case PhysicalType::INT64:
127: 		TemplatedFillLoop<int64_t>(vector, result, sel, count);
128: 		break;
129: 	case PhysicalType::UINT8:
130: 		TemplatedFillLoop<uint8_t>(vector, result, sel, count);
131: 		break;
132: 	case PhysicalType::UINT16:
133: 		TemplatedFillLoop<uint16_t>(vector, result, sel, count);
134: 		break;
135: 	case PhysicalType::UINT32:
136: 		TemplatedFillLoop<uint32_t>(vector, result, sel, count);
137: 		break;
138: 	case PhysicalType::UINT64:
139: 		TemplatedFillLoop<uint64_t>(vector, result, sel, count);
140: 		break;
141: 	case PhysicalType::INT128:
142: 		TemplatedFillLoop<hugeint_t>(vector, result, sel, count);
143: 		break;
144: 	case PhysicalType::FLOAT:
145: 		TemplatedFillLoop<float>(vector, result, sel, count);
146: 		break;
147: 	case PhysicalType::DOUBLE:
148: 		TemplatedFillLoop<double>(vector, result, sel, count);
149: 		break;
150: 	case PhysicalType::INTERVAL:
151: 		TemplatedFillLoop<interval_t>(vector, result, sel, count);
152: 		break;
153: 	case PhysicalType::VARCHAR:
154: 		TemplatedFillLoop<string_t>(vector, result, sel, count);
155: 		StringVector::AddHeapReference(result, vector);
156: 		break;
157: 	case PhysicalType::STRUCT: {
158: 		auto &vector_entries = StructVector::GetEntries(vector);
159: 		auto &result_entries = StructVector::GetEntries(result);
160: 		ValidityFillLoop(vector, result, sel, count);
161: 		D_ASSERT(vector_entries.size() == result_entries.size());
162: 		for (idx_t i = 0; i < vector_entries.size(); i++) {
163: 			FillSwitch(*vector_entries[i], *result_entries[i], sel, count);
164: 		}
165: 		break;
166: 	}
167: 	case PhysicalType::LIST: {
168: 		idx_t offset = ListVector::GetListSize(result);
169: 		auto &list_child = ListVector::GetEntry(vector);
170: 		ListVector::Append(result, list_child, ListVector::GetListSize(vector));
171: 
172: 		// all the false offsets need to be incremented by true_child.count
173: 		TemplatedFillLoop<list_entry_t>(vector, result, sel, count);
174: 		if (offset == 0) {
175: 			break;
176: 		}
177: 
178: 		auto result_data = FlatVector::GetData<list_entry_t>(result);
179: 		for (idx_t i = 0; i < count; i++) {
180: 			auto result_idx = sel.get_index(i);
181: 			result_data[result_idx].offset += offset;
182: 		}
183: 
184: 		result.Verify(sel, count);
185: 		break;
186: 	}
187: 	default:
188: 		throw NotImplementedException("Unimplemented type for case expression: %s", result.GetType().ToString());
189: 	}
190: }
191: 
192: } // namespace duckdb
[end of src/execution/expression_executor/execute_case.cpp]
[start of src/include/duckdb/execution/expression_executor.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/expression_executor.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/execution/expression_executor_state.hpp"
13: #include "duckdb/planner/bound_tokens.hpp"
14: #include "duckdb/planner/expression.hpp"
15: 
16: namespace duckdb {
17: class ExecutionContext;
18: //! ExpressionExecutor is responsible for executing a set of expressions and storing the result in a data chunk
19: class ExpressionExecutor {
20: public:
21: 	ExpressionExecutor();
22: 	explicit ExpressionExecutor(const Expression *expression);
23: 	explicit ExpressionExecutor(const Expression &expression);
24: 	explicit ExpressionExecutor(const vector<unique_ptr<Expression>> &expressions);
25: 
26: 	//! Add an expression to the set of to-be-executed expressions of the executor
27: 	void AddExpression(const Expression &expr);
28: 
29: 	//! Execute the set of expressions with the given input chunk and store the result in the output chunk
30: 	void Execute(DataChunk *input, DataChunk &result);
31: 	void Execute(DataChunk &input, DataChunk &result) {
32: 		Execute(&input, result);
33: 	}
34: 	void Execute(DataChunk &result) {
35: 		Execute(nullptr, result);
36: 	}
37: 
38: 	//! Execute the ExpressionExecutor and put the result in the result vector; this should only be used for expression
39: 	//! executors with a single expression
40: 	void ExecuteExpression(DataChunk &input, Vector &result);
41: 	//! Execute the ExpressionExecutor and put the result in the result vector; this should only be used for expression
42: 	//! executors with a single expression
43: 	void ExecuteExpression(Vector &result);
44: 	//! Execute the ExpressionExecutor and generate a selection vector from all true values in the result; this should
45: 	//! only be used with a single boolean expression
46: 	idx_t SelectExpression(DataChunk &input, SelectionVector &sel);
47: 
48: 	//! Execute the expression with index `expr_idx` and store the result in the result vector
49: 	void ExecuteExpression(idx_t expr_idx, Vector &result);
50: 	//! Evaluate a scalar expression and fold it into a single value
51: 	static Value EvaluateScalar(const Expression &expr);
52: 	//! Try to evaluate a scalar expression and fold it into a single value, returns false if an exception is thrown
53: 	static bool TryEvaluateScalar(const Expression &expr, Value &result);
54: 
55: 	//! Initialize the state of a given expression
56: 	static unique_ptr<ExpressionState> InitializeState(const Expression &expr, ExpressionExecutorState &state);
57: 
58: 	void SetChunk(DataChunk *chunk) {
59: 		this->chunk = chunk;
60: 	}
61: 	void SetChunk(DataChunk &chunk) {
62: 		SetChunk(&chunk);
63: 	}
64: 
65: 	vector<unique_ptr<ExpressionExecutorState>> &GetStates();
66: 
67: 	//! The expressions of the executor
68: 	vector<const Expression *> expressions;
69: 	//! The data chunk of the current physical operator, used to resolve
70: 	//! column references and determines the output cardinality
71: 	DataChunk *chunk = nullptr;
72: 
73: protected:
74: 	void Initialize(const Expression &expr, ExpressionExecutorState &state);
75: 
76: 	static unique_ptr<ExpressionState> InitializeState(const BoundReferenceExpression &expr,
77: 	                                                   ExpressionExecutorState &state);
78: 	static unique_ptr<ExpressionState> InitializeState(const BoundBetweenExpression &expr,
79: 	                                                   ExpressionExecutorState &state);
80: 	static unique_ptr<ExpressionState> InitializeState(const BoundCaseExpression &expr, ExpressionExecutorState &state);
81: 	static unique_ptr<ExpressionState> InitializeState(const BoundCastExpression &expr, ExpressionExecutorState &state);
82: 	static unique_ptr<ExpressionState> InitializeState(const BoundComparisonExpression &expr,
83: 	                                                   ExpressionExecutorState &state);
84: 	static unique_ptr<ExpressionState> InitializeState(const BoundConjunctionExpression &expr,
85: 	                                                   ExpressionExecutorState &state);
86: 	static unique_ptr<ExpressionState> InitializeState(const BoundConstantExpression &expr,
87: 	                                                   ExpressionExecutorState &state);
88: 	static unique_ptr<ExpressionState> InitializeState(const BoundFunctionExpression &expr,
89: 	                                                   ExpressionExecutorState &state);
90: 	static unique_ptr<ExpressionState> InitializeState(const BoundOperatorExpression &expr,
91: 	                                                   ExpressionExecutorState &state);
92: 	static unique_ptr<ExpressionState> InitializeState(const BoundParameterExpression &expr,
93: 	                                                   ExpressionExecutorState &state);
94: 
95: 	void Execute(const Expression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
96: 	             Vector &result);
97: 
98: 	void Execute(const BoundBetweenExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
99: 	             Vector &result);
100: 	void Execute(const BoundCaseExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
101: 	             Vector &result);
102: 	void Execute(const BoundCastExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
103: 	             Vector &result);
104: 
105: 	void Execute(const BoundComparisonExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
106: 	             Vector &result);
107: 	void Execute(const BoundConjunctionExpression &expr, ExpressionState *state, const SelectionVector *sel,
108: 	             idx_t count, Vector &result);
109: 	void Execute(const BoundConstantExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
110: 	             Vector &result);
111: 	void Execute(const BoundFunctionExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
112: 	             Vector &result);
113: 	void Execute(const BoundOperatorExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
114: 	             Vector &result);
115: 	void Execute(const BoundParameterExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
116: 	             Vector &result);
117: 	void Execute(const BoundReferenceExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
118: 	             Vector &result);
119: 
120: 	//! Execute the (boolean-returning) expression and generate a selection vector with all entries that are "true" in
121: 	//! the result
122: 	idx_t Select(const Expression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
123: 	             SelectionVector *true_sel, SelectionVector *false_sel);
124: 	idx_t DefaultSelect(const Expression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
125: 	                    SelectionVector *true_sel, SelectionVector *false_sel);
126: 
127: 	idx_t Select(const BoundBetweenExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
128: 	             SelectionVector *true_sel, SelectionVector *false_sel);
129: 	idx_t Select(const BoundComparisonExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
130: 	             SelectionVector *true_sel, SelectionVector *false_sel);
131: 	idx_t Select(const BoundConjunctionExpression &expr, ExpressionState *state, const SelectionVector *sel,
132: 	             idx_t count, SelectionVector *true_sel, SelectionVector *false_sel);
133: 
134: 	//! Verify that the output of a step in the ExpressionExecutor is correct
135: 	void Verify(const Expression &expr, Vector &result, idx_t count);
136: 
137: 	void FillSwitch(Vector &vector, Vector &result, SelectionVector &sel, sel_t count);
138: 
139: private:
140: 	//! The states of the expression executor; this holds any intermediates and temporary states of expressions
141: 	vector<unique_ptr<ExpressionExecutorState>> states;
142: };
143: } // namespace duckdb
[end of src/include/duckdb/execution/expression_executor.hpp]
[start of src/include/duckdb/optimizer/matcher/expression_matcher.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/optimizer/matcher/expression_matcher.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/exception.hpp"
12: #include "duckdb/optimizer/matcher/expression_type_matcher.hpp"
13: #include "duckdb/optimizer/matcher/set_matcher.hpp"
14: #include "duckdb/optimizer/matcher/type_matcher.hpp"
15: #include "duckdb/optimizer/matcher/function_matcher.hpp"
16: #include "duckdb/planner/logical_operator.hpp"
17: 
18: namespace duckdb {
19: 
20: //! The ExpressionMatcher class contains a set of matchers that can be used to pattern match Expressions
21: class ExpressionMatcher {
22: public:
23: 	explicit ExpressionMatcher(ExpressionClass type = ExpressionClass::INVALID) : expr_class(type) {
24: 	}
25: 	virtual ~ExpressionMatcher() {
26: 	}
27: 
28: 	//! Checks if the given expression matches this ExpressionMatcher. If it does, the expression is appended to the
29: 	//! bindings list and true is returned. Otherwise, false is returned.
30: 	virtual bool Match(Expression *expr, vector<Expression *> &bindings);
31: 
32: 	//! The ExpressionClass of the to-be-matched expression. ExpressionClass::INVALID for ANY.
33: 	ExpressionClass expr_class;
34: 	//! Matcher for the ExpressionType of the operator (nullptr for ANY)
35: 	unique_ptr<ExpressionTypeMatcher> expr_type;
36: 	//! Matcher for the return_type of the expression (nullptr for ANY)
37: 	unique_ptr<TypeMatcher> type;
38: };
39: 
40: //! The ExpressionEqualityMatcher matches on equality with another (given) expression
41: class ExpressionEqualityMatcher : public ExpressionMatcher {
42: public:
43: 	explicit ExpressionEqualityMatcher(Expression *expr)
44: 	    : ExpressionMatcher(ExpressionClass::INVALID), expression(expr) {
45: 	}
46: 
47: 	bool Match(Expression *expr, vector<Expression *> &bindings) override;
48: 
49: private:
50: 	Expression *expression;
51: };
52: 
53: class ConstantExpressionMatcher : public ExpressionMatcher {
54: public:
55: 	ConstantExpressionMatcher() : ExpressionMatcher(ExpressionClass::BOUND_CONSTANT) {
56: 	}
57: };
58: 
59: class CaseExpressionMatcher : public ExpressionMatcher {
60: public:
61: 	CaseExpressionMatcher() : ExpressionMatcher(ExpressionClass::BOUND_CASE) {
62: 	}
63: 	//! The check expression to match (if any)
64: 	unique_ptr<ExpressionMatcher> check;
65: 	//! The result_if_true expression to match (if any)
66: 	unique_ptr<ExpressionMatcher> result_if_true;
67: 	//! The result_if_false expression to match (if any)
68: 	unique_ptr<ExpressionMatcher> result_if_false;
69: 
70: 	bool Match(Expression *expr_, vector<Expression *> &bindings) override;
71: };
72: 
73: class ComparisonExpressionMatcher : public ExpressionMatcher {
74: public:
75: 	ComparisonExpressionMatcher() : ExpressionMatcher(ExpressionClass::BOUND_COMPARISON) {
76: 	}
77: 	//! The matchers for the child expressions
78: 	vector<unique_ptr<ExpressionMatcher>> matchers;
79: 	//! The set matcher matching policy to use
80: 	SetMatcher::Policy policy;
81: 
82: 	bool Match(Expression *expr_, vector<Expression *> &bindings) override;
83: };
84: 
85: class CastExpressionMatcher : public ExpressionMatcher {
86: public:
87: 	CastExpressionMatcher() : ExpressionMatcher(ExpressionClass::BOUND_CAST) {
88: 	}
89: 	//! The matcher for the child expressions
90: 	unique_ptr<ExpressionMatcher> matcher;
91: 
92: 	bool Match(Expression *expr_, vector<Expression *> &bindings) override;
93: };
94: 
95: class InClauseExpressionMatcher : public ExpressionMatcher {
96: public:
97: 	InClauseExpressionMatcher() : ExpressionMatcher(ExpressionClass::BOUND_OPERATOR) {
98: 	}
99: 	//! The matchers for the child expressions
100: 	vector<unique_ptr<ExpressionMatcher>> matchers;
101: 	//! The set matcher matching policy to use
102: 	SetMatcher::Policy policy;
103: 
104: 	bool Match(Expression *expr_, vector<Expression *> &bindings) override;
105: };
106: 
107: class ConjunctionExpressionMatcher : public ExpressionMatcher {
108: public:
109: 	ConjunctionExpressionMatcher() : ExpressionMatcher(ExpressionClass::BOUND_CONJUNCTION) {
110: 	}
111: 	//! The matchers for the child expressions
112: 	vector<unique_ptr<ExpressionMatcher>> matchers;
113: 	//! The set matcher matching policy to use
114: 	SetMatcher::Policy policy;
115: 
116: 	bool Match(Expression *expr_, vector<Expression *> &bindings) override;
117: };
118: 
119: class FunctionExpressionMatcher : public ExpressionMatcher {
120: public:
121: 	FunctionExpressionMatcher() : ExpressionMatcher(ExpressionClass::BOUND_FUNCTION) {
122: 	}
123: 	//! The matchers for the child expressions
124: 	vector<unique_ptr<ExpressionMatcher>> matchers;
125: 	//! The set matcher matching policy to use
126: 	SetMatcher::Policy policy;
127: 	//! The function name to match
128: 	unique_ptr<FunctionMatcher> function;
129: 
130: 	bool Match(Expression *expr_, vector<Expression *> &bindings) override;
131: };
132: 
133: //! The FoldableConstant matcher matches any expression that is foldable into a constant by the ExpressionExecutor (i.e.
134: //! scalar but not aggregate/window/parameter)
135: class FoldableConstantMatcher : public ExpressionMatcher {
136: public:
137: 	FoldableConstantMatcher() : ExpressionMatcher(ExpressionClass::INVALID) {
138: 	}
139: 
140: 	bool Match(Expression *expr, vector<Expression *> &bindings) override;
141: };
142: 
143: } // namespace duckdb
[end of src/include/duckdb/optimizer/matcher/expression_matcher.hpp]
[start of src/include/duckdb/planner/expression/bound_case_expression.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression/bound_case_expression.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/planner/expression.hpp"
12: 
13: namespace duckdb {
14: 
15: class BoundCaseExpression : public Expression {
16: public:
17: 	BoundCaseExpression(LogicalType type);
18: 	BoundCaseExpression(unique_ptr<Expression> check, unique_ptr<Expression> res_if_true,
19: 	                    unique_ptr<Expression> res_if_false);
20: 
21: 	unique_ptr<Expression> check;
22: 	unique_ptr<Expression> result_if_true;
23: 	unique_ptr<Expression> result_if_false;
24: 
25: public:
26: 	string ToString() const override;
27: 
28: 	bool Equals(const BaseExpression *other) const override;
29: 
30: 	unique_ptr<Expression> Copy() override;
31: };
32: } // namespace duckdb
[end of src/include/duckdb/planner/expression/bound_case_expression.hpp]
[start of src/optimizer/expression_heuristics.cpp]
1: #include "duckdb/optimizer/expression_heuristics.hpp"
2: #include "duckdb/planner/expression/list.hpp"
3: 
4: namespace duckdb {
5: 
6: unique_ptr<LogicalOperator> ExpressionHeuristics::Rewrite(unique_ptr<LogicalOperator> op) {
7: 	VisitOperator(*op);
8: 	return op;
9: }
10: 
11: void ExpressionHeuristics::VisitOperator(LogicalOperator &op) {
12: 	if (op.type == LogicalOperatorType::LOGICAL_FILTER) {
13: 		// reorder all filter expressions
14: 		if (op.expressions.size() > 1) {
15: 			ReorderExpressions(op.expressions);
16: 		}
17: 	}
18: 
19: 	// traverse recursively through the operator tree
20: 	VisitOperatorChildren(op);
21: 	VisitOperatorExpressions(op);
22: }
23: 
24: unique_ptr<Expression> ExpressionHeuristics::VisitReplace(BoundConjunctionExpression &expr,
25:                                                           unique_ptr<Expression> *expr_ptr) {
26: 	ReorderExpressions(expr.children);
27: 	return nullptr;
28: }
29: 
30: void ExpressionHeuristics::ReorderExpressions(vector<unique_ptr<Expression>> &expressions) {
31: 
32: 	struct ExpressionCosts {
33: 		unique_ptr<Expression> expr;
34: 		idx_t cost;
35: 
36: 		bool operator==(const ExpressionCosts &p) const {
37: 			return cost == p.cost;
38: 		}
39: 		bool operator<(const ExpressionCosts &p) const {
40: 			return cost < p.cost;
41: 		}
42: 	};
43: 
44: 	vector<ExpressionCosts> expression_costs;
45: 	// iterate expressions, get cost for each one
46: 	for (idx_t i = 0; i < expressions.size(); i++) {
47: 		idx_t cost = Cost(*expressions[i]);
48: 		expression_costs.push_back({move(expressions[i]), cost});
49: 	}
50: 
51: 	// sort by cost and put back in place
52: 	sort(expression_costs.begin(), expression_costs.end());
53: 	for (idx_t i = 0; i < expression_costs.size(); i++) {
54: 		expressions[i] = move(expression_costs[i].expr);
55: 	}
56: }
57: 
58: idx_t ExpressionHeuristics::ExpressionCost(BoundBetweenExpression &expr) {
59: 	return Cost(*expr.input) + Cost(*expr.lower) + Cost(*expr.upper) + 10;
60: }
61: 
62: idx_t ExpressionHeuristics::ExpressionCost(BoundCaseExpression &expr) {
63: 	// CASE WHEN check THEN result_if_true ELSE result_if_false END
64: 	return Cost(*expr.check) + Cost(*expr.result_if_true) + Cost(*expr.result_if_false) + 5;
65: }
66: 
67: idx_t ExpressionHeuristics::ExpressionCost(BoundCastExpression &expr) {
68: 	// OPERATOR_CAST
69: 	// determine cast cost by comparing cast_expr.source_type and cast_expr_target_type
70: 	idx_t cast_cost = 0;
71: 	if (expr.return_type != expr.source_type()) {
72: 		// if cast from or to varchar
73: 		// TODO: we might want to add more cases
74: 		if (expr.return_type.id() == LogicalTypeId::VARCHAR || expr.source_type().id() == LogicalTypeId::VARCHAR ||
75: 		    expr.return_type.id() == LogicalTypeId::BLOB || expr.source_type().id() == LogicalTypeId::BLOB) {
76: 			cast_cost = 200;
77: 		} else {
78: 			cast_cost = 5;
79: 		}
80: 	}
81: 	return Cost(*expr.child) + cast_cost;
82: }
83: 
84: idx_t ExpressionHeuristics::ExpressionCost(BoundComparisonExpression &expr) {
85: 	// COMPARE_EQUAL, COMPARE_NOTEQUAL, COMPARE_GREATERTHAN, COMPARE_GREATERTHANOREQUALTO, COMPARE_LESSTHAN,
86: 	// COMPARE_LESSTHANOREQUALTO
87: 	return Cost(*expr.left) + 5 + Cost(*expr.right);
88: }
89: 
90: idx_t ExpressionHeuristics::ExpressionCost(BoundConjunctionExpression &expr) {
91: 	// CONJUNCTION_AND, CONJUNCTION_OR
92: 	idx_t cost = 5;
93: 	for (auto &child : expr.children) {
94: 		cost += Cost(*child);
95: 	}
96: 	return cost;
97: }
98: 
99: idx_t ExpressionHeuristics::ExpressionCost(BoundFunctionExpression &expr) {
100: 	idx_t cost_children = 0;
101: 	for (auto &child : expr.children) {
102: 		cost_children += Cost(*child);
103: 	}
104: 
105: 	auto cost_function = function_costs.find(expr.function.name);
106: 	if (cost_function != function_costs.end()) {
107: 		return cost_children + cost_function->second;
108: 	} else {
109: 		return cost_children + 1000;
110: 	}
111: }
112: 
113: idx_t ExpressionHeuristics::ExpressionCost(BoundOperatorExpression &expr, ExpressionType &expr_type) {
114: 	idx_t sum = 0;
115: 	for (auto &child : expr.children) {
116: 		sum += Cost(*child);
117: 	}
118: 
119: 	// OPERATOR_IS_NULL, OPERATOR_IS_NOT_NULL
120: 	if (expr_type == ExpressionType::OPERATOR_IS_NULL || expr_type == ExpressionType::OPERATOR_IS_NOT_NULL) {
121: 		return sum + 5;
122: 	} else if (expr_type == ExpressionType::COMPARE_IN || expr_type == ExpressionType::COMPARE_NOT_IN) {
123: 		// COMPARE_IN, COMPARE_NOT_IN
124: 		return sum + (expr.children.size() - 1) * 100;
125: 	} else if (expr_type == ExpressionType::OPERATOR_NOT) {
126: 		// OPERATOR_NOT
127: 		return sum + 10; // TODO: evaluate via measured runtimes
128: 	} else {
129: 		return sum + 1000;
130: 	}
131: }
132: 
133: idx_t ExpressionHeuristics::ExpressionCost(PhysicalType return_type, idx_t multiplier) {
134: 	// TODO: ajust values according to benchmark results
135: 	switch (return_type) {
136: 	case PhysicalType::VARCHAR:
137: 		return 5 * multiplier;
138: 	case PhysicalType::FLOAT:
139: 	case PhysicalType::DOUBLE:
140: 		return 2 * multiplier;
141: 	default:
142: 		return 1 * multiplier;
143: 	}
144: }
145: 
146: idx_t ExpressionHeuristics::Cost(Expression &expr) {
147: 	switch (expr.expression_class) {
148: 	case ExpressionClass::BOUND_CASE: {
149: 		auto &case_expr = (BoundCaseExpression &)expr;
150: 		return ExpressionCost(case_expr);
151: 	}
152: 	case ExpressionClass::BOUND_BETWEEN: {
153: 		auto &between_expr = (BoundBetweenExpression &)expr;
154: 		return ExpressionCost(between_expr);
155: 	}
156: 	case ExpressionClass::BOUND_CAST: {
157: 		auto &cast_expr = (BoundCastExpression &)expr;
158: 		return ExpressionCost(cast_expr);
159: 	}
160: 	case ExpressionClass::BOUND_COMPARISON: {
161: 		auto &comp_expr = (BoundComparisonExpression &)expr;
162: 		return ExpressionCost(comp_expr);
163: 	}
164: 	case ExpressionClass::BOUND_CONJUNCTION: {
165: 		auto &conj_expr = (BoundConjunctionExpression &)expr;
166: 		return ExpressionCost(conj_expr);
167: 	}
168: 	case ExpressionClass::BOUND_FUNCTION: {
169: 		auto &func_expr = (BoundFunctionExpression &)expr;
170: 		return ExpressionCost(func_expr);
171: 	}
172: 	case ExpressionClass::BOUND_OPERATOR: {
173: 		auto &op_expr = (BoundOperatorExpression &)expr;
174: 		return ExpressionCost(op_expr, expr.type);
175: 	}
176: 	case ExpressionClass::BOUND_COLUMN_REF: {
177: 		auto &col_expr = (BoundColumnRefExpression &)expr;
178: 		return ExpressionCost(col_expr.return_type.InternalType(), 8);
179: 	}
180: 	case ExpressionClass::BOUND_CONSTANT: {
181: 		auto &const_expr = (BoundConstantExpression &)expr;
182: 		return ExpressionCost(const_expr.return_type.InternalType(), 1);
183: 	}
184: 	case ExpressionClass::BOUND_PARAMETER: {
185: 		auto &const_expr = (BoundParameterExpression &)expr;
186: 		return ExpressionCost(const_expr.return_type.InternalType(), 1);
187: 	}
188: 	case ExpressionClass::BOUND_REF: {
189: 		auto &col_expr = (BoundColumnRefExpression &)expr;
190: 		return ExpressionCost(col_expr.return_type.InternalType(), 8);
191: 	}
192: 	default: {
193: 		break;
194: 	}
195: 	}
196: 
197: 	// return a very high value if nothing matches
198: 	return 1000;
199: }
200: 
201: } // namespace duckdb
[end of src/optimizer/expression_heuristics.cpp]
[start of src/optimizer/matcher/expression_matcher.cpp]
1: #include "duckdb/optimizer/matcher/expression_matcher.hpp"
2: 
3: #include "duckdb/planner/expression/list.hpp"
4: 
5: namespace duckdb {
6: 
7: bool ExpressionMatcher::Match(Expression *expr, vector<Expression *> &bindings) {
8: 	if (type && !type->Match(expr->return_type)) {
9: 		return false;
10: 	}
11: 	if (expr_type && !expr_type->Match(expr->type)) {
12: 		return false;
13: 	}
14: 	if (expr_class != ExpressionClass::INVALID && expr_class != expr->GetExpressionClass()) {
15: 		return false;
16: 	}
17: 	bindings.push_back(expr);
18: 	return true;
19: }
20: 
21: bool ExpressionEqualityMatcher::Match(Expression *expr, vector<Expression *> &bindings) {
22: 	if (!Expression::Equals(expression, expr)) {
23: 		return false;
24: 	}
25: 	bindings.push_back(expr);
26: 	return true;
27: }
28: 
29: bool CaseExpressionMatcher::Match(Expression *expr_p, vector<Expression *> &bindings) {
30: 	if (!ExpressionMatcher::Match(expr_p, bindings)) {
31: 		return false;
32: 	}
33: 	auto expr = (BoundCaseExpression *)expr_p;
34: 	if (check && !check->Match(expr->check.get(), bindings)) {
35: 		return false;
36: 	}
37: 	if (result_if_true && !result_if_true->Match(expr->result_if_true.get(), bindings)) {
38: 		return false;
39: 	}
40: 	if (result_if_false && !result_if_false->Match(expr->result_if_false.get(), bindings)) {
41: 		return false;
42: 	}
43: 	return true;
44: }
45: 
46: bool ComparisonExpressionMatcher::Match(Expression *expr_p, vector<Expression *> &bindings) {
47: 	if (!ExpressionMatcher::Match(expr_p, bindings)) {
48: 		return false;
49: 	}
50: 	auto expr = (BoundComparisonExpression *)expr_p;
51: 	vector<Expression *> expressions = {expr->left.get(), expr->right.get()};
52: 	return SetMatcher::Match(matchers, expressions, bindings, policy);
53: }
54: 
55: bool CastExpressionMatcher::Match(Expression *expr_p, vector<Expression *> &bindings) {
56: 	if (!ExpressionMatcher::Match(expr_p, bindings)) {
57: 		return false;
58: 	}
59: 	if (!matcher) {
60: 		return true;
61: 	}
62: 	auto expr = (BoundCastExpression *)expr_p;
63: 	return matcher->Match(expr->child.get(), bindings);
64: }
65: 
66: bool InClauseExpressionMatcher::Match(Expression *expr_p, vector<Expression *> &bindings) {
67: 	if (!ExpressionMatcher::Match(expr_p, bindings)) {
68: 		return false;
69: 	}
70: 	auto expr = (BoundOperatorExpression *)expr_p;
71: 	if (expr->type != ExpressionType::COMPARE_IN || expr->type == ExpressionType::COMPARE_NOT_IN) {
72: 		return false;
73: 	}
74: 	return SetMatcher::Match(matchers, expr->children, bindings, policy);
75: }
76: 
77: bool ConjunctionExpressionMatcher::Match(Expression *expr_p, vector<Expression *> &bindings) {
78: 	if (!ExpressionMatcher::Match(expr_p, bindings)) {
79: 		return false;
80: 	}
81: 	auto expr = (BoundConjunctionExpression *)expr_p;
82: 	if (!SetMatcher::Match(matchers, expr->children, bindings, policy)) {
83: 		return false;
84: 	}
85: 	return true;
86: }
87: 
88: bool FunctionExpressionMatcher::Match(Expression *expr_p, vector<Expression *> &bindings) {
89: 	if (!ExpressionMatcher::Match(expr_p, bindings)) {
90: 		return false;
91: 	}
92: 	auto expr = (BoundFunctionExpression *)expr_p;
93: 	if (!FunctionMatcher::Match(function, expr->function.name)) {
94: 		return false;
95: 	}
96: 	if (!SetMatcher::Match(matchers, expr->children, bindings, policy)) {
97: 		return false;
98: 	}
99: 	return true;
100: }
101: 
102: bool FoldableConstantMatcher::Match(Expression *expr, vector<Expression *> &bindings) {
103: 	// we match on ANY expression that is a scalar expression
104: 	if (!expr->IsFoldable()) {
105: 		return false;
106: 	}
107: 	bindings.push_back(expr);
108: 	return true;
109: }
110: 
111: } // namespace duckdb
[end of src/optimizer/matcher/expression_matcher.cpp]
[start of src/optimizer/rule/case_simplification.cpp]
1: #include "duckdb/optimizer/rule/case_simplification.hpp"
2: 
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/planner/expression/bound_case_expression.hpp"
5: 
6: namespace duckdb {
7: 
8: CaseSimplificationRule::CaseSimplificationRule(ExpressionRewriter &rewriter) : Rule(rewriter) {
9: 	// match on a CaseExpression that has a ConstantExpression as a check
10: 	auto op = make_unique<CaseExpressionMatcher>();
11: 	op->check = make_unique<FoldableConstantMatcher>();
12: 	root = move(op);
13: }
14: 
15: unique_ptr<Expression> CaseSimplificationRule::Apply(LogicalOperator &op, vector<Expression *> &bindings,
16:                                                      bool &changes_made, bool is_root) {
17: 	auto root = (BoundCaseExpression *)bindings[0];
18: 	auto constant_expr = bindings[1];
19: 	// the constant_expr is a scalar expression that we have to fold
20: 	D_ASSERT(constant_expr->IsFoldable());
21: 
22: 	// use an ExpressionExecutor to execute the expression
23: 	auto constant_value = ExpressionExecutor::EvaluateScalar(*constant_expr);
24: 
25: 	// fold based on the constant condition
26: 	auto condition = constant_value.CastAs(LogicalType::BOOLEAN);
27: 	if (condition.is_null || !condition.value_.boolean) {
28: 		return move(root->result_if_false);
29: 	} else {
30: 		return move(root->result_if_true);
31: 	}
32: }
33: 
34: } // namespace duckdb
[end of src/optimizer/rule/case_simplification.cpp]
[start of src/optimizer/statistics/expression/propagate_case.cpp]
1: #include "duckdb/optimizer/statistics_propagator.hpp"
2: #include "duckdb/planner/expression/bound_case_expression.hpp"
3: 
4: namespace duckdb {
5: 
6: unique_ptr<BaseStatistics> StatisticsPropagator::PropagateExpression(BoundCaseExpression &bound_case,
7:                                                                      unique_ptr<Expression> *expr_ptr) {
8: 	// propagate in all the children
9: 	auto check_stats = PropagateExpression(bound_case.check);
10: 	auto res_if_true_stats = PropagateExpression(bound_case.result_if_true);
11: 	auto res_if_false_stats = PropagateExpression(bound_case.result_if_false);
12: 	// for a case statement, the resulting stats are the merged stats of the two children
13: 	if (!res_if_true_stats || !res_if_false_stats) {
14: 		return nullptr;
15: 	}
16: 	res_if_true_stats->Merge(*res_if_false_stats);
17: 	return res_if_true_stats;
18: }
19: 
20: } // namespace duckdb
[end of src/optimizer/statistics/expression/propagate_case.cpp]
[start of src/planner/binder/expression/bind_case_expression.cpp]
1: #include "duckdb/parser/expression/case_expression.hpp"
2: #include "duckdb/planner/expression/bound_case_expression.hpp"
3: #include "duckdb/planner/expression/bound_cast_expression.hpp"
4: #include "duckdb/planner/expression_binder.hpp"
5: 
6: namespace duckdb {
7: 
8: BindResult ExpressionBinder::BindExpression(CaseExpression &expr, idx_t depth) {
9: 	// first try to bind the children of the case expression
10: 	string error;
11: 	for (auto &check : expr.case_checks) {
12: 		BindChild(check.when_expr, depth, error);
13: 		BindChild(check.then_expr, depth, error);
14: 	}
15: 	BindChild(expr.else_expr, depth, error);
16: 	if (!error.empty()) {
17: 		return BindResult(error);
18: 	}
19: 	// the children have been successfully resolved
20: 	// figure out the result type of the CASE expression
21: 	auto return_type = ((BoundExpression &)*expr.else_expr).expr->return_type;
22: 	for (auto &check : expr.case_checks) {
23: 		auto &then_expr = (BoundExpression &)*check.then_expr;
24: 		return_type = LogicalType::MaxLogicalType(return_type, then_expr.expr->return_type);
25: 	}
26: 	ExpressionBinder::ResolveParameterType(return_type);
27: 
28: 	// now rewrite the case into a chain of cases
29: 
30: 	// CASE WHEN e1 THEN r1 WHEN w2 THEN r2 ELSE r3 is rewritten to
31: 	// CASE WHEN e1 THEN r1 ELSE CASE WHEN e2 THEN r2 ELSE r3
32: 
33: 	auto root = make_unique<BoundCaseExpression>(return_type);
34: 	auto current_root = root.get();
35: 	for (idx_t i = 0; i < expr.case_checks.size(); i++) {
36: 		auto &check = expr.case_checks[i];
37: 		auto &when_expr = (BoundExpression &)*check.when_expr;
38: 		auto &then_expr = (BoundExpression &)*check.then_expr;
39: 		current_root->check = BoundCastExpression::AddCastToType(move(when_expr.expr), LogicalType::BOOLEAN);
40: 		current_root->result_if_true = BoundCastExpression::AddCastToType(move(then_expr.expr), return_type);
41: 		if (i + 1 == expr.case_checks.size()) {
42: 			// finished all cases
43: 			// res_false is the default result
44: 			auto &else_expr = (BoundExpression &)*expr.else_expr;
45: 			current_root->result_if_false = BoundCastExpression::AddCastToType(move(else_expr.expr), return_type);
46: 		} else {
47: 			// more cases remain, create a case statement within the FALSE branch
48: 			auto next_case = make_unique<BoundCaseExpression>(return_type);
49: 			auto case_ptr = next_case.get();
50: 			current_root->result_if_false = move(next_case);
51: 			current_root = case_ptr;
52: 		}
53: 	}
54: 	return BindResult(move(root));
55: }
56: } // namespace duckdb
[end of src/planner/binder/expression/bind_case_expression.cpp]
[start of src/planner/expression/bound_case_expression.cpp]
1: #include "duckdb/planner/expression/bound_case_expression.hpp"
2: 
3: namespace duckdb {
4: 
5: BoundCaseExpression::BoundCaseExpression(LogicalType type)
6:     : Expression(ExpressionType::CASE_EXPR, ExpressionClass::BOUND_CASE, move(type)) {
7: }
8: 
9: BoundCaseExpression::BoundCaseExpression(unique_ptr<Expression> check, unique_ptr<Expression> res_if_true,
10:                                          unique_ptr<Expression> res_if_false)
11:     : Expression(ExpressionType::CASE_EXPR, ExpressionClass::BOUND_CASE, res_if_true->return_type), check(move(check)),
12:       result_if_true(move(res_if_true)), result_if_false(move(res_if_false)) {
13: }
14: 
15: string BoundCaseExpression::ToString() const {
16: 	return "CASE WHEN (" + check->GetName() + ") THEN (" + result_if_true->GetName() + ") ELSE (" +
17: 	       result_if_false->GetName() + ")";
18: }
19: 
20: bool BoundCaseExpression::Equals(const BaseExpression *other_p) const {
21: 	if (!Expression::Equals(other_p)) {
22: 		return false;
23: 	}
24: 	auto other = (BoundCaseExpression *)other_p;
25: 	if (!Expression::Equals(check.get(), other->check.get())) {
26: 		return false;
27: 	}
28: 	if (!Expression::Equals(result_if_true.get(), other->result_if_true.get())) {
29: 		return false;
30: 	}
31: 	if (!Expression::Equals(result_if_false.get(), other->result_if_false.get())) {
32: 		return false;
33: 	}
34: 	return true;
35: }
36: 
37: unique_ptr<Expression> BoundCaseExpression::Copy() {
38: 	auto new_case = make_unique<BoundCaseExpression>(check->Copy(), result_if_true->Copy(), result_if_false->Copy());
39: 	new_case->CopyProperties(*this);
40: 	return move(new_case);
41: }
42: 
43: } // namespace duckdb
[end of src/planner/expression/bound_case_expression.cpp]
[start of src/planner/expression_iterator.cpp]
1: #include "duckdb/planner/expression_iterator.hpp"
2: 
3: #include "duckdb/planner/bound_query_node.hpp"
4: #include "duckdb/planner/expression/list.hpp"
5: #include "duckdb/planner/query_node/bound_select_node.hpp"
6: #include "duckdb/planner/query_node/bound_set_operation_node.hpp"
7: #include "duckdb/planner/tableref/list.hpp"
8: 
9: namespace duckdb {
10: 
11: void ExpressionIterator::EnumerateChildren(const Expression &expr,
12:                                            const std::function<void(const Expression &child)> &callback) {
13: 	EnumerateChildren((Expression &)expr, [&](unique_ptr<Expression> &child) { callback(*child); });
14: }
15: 
16: void ExpressionIterator::EnumerateChildren(Expression &expr, const std::function<void(Expression &child)> &callback) {
17: 	EnumerateChildren(expr, [&](unique_ptr<Expression> &child) { callback(*child); });
18: }
19: 
20: void ExpressionIterator::EnumerateChildren(Expression &expr,
21:                                            const std::function<void(unique_ptr<Expression> &child)> &callback) {
22: 	switch (expr.expression_class) {
23: 	case ExpressionClass::BOUND_AGGREGATE: {
24: 		auto &aggr_expr = (BoundAggregateExpression &)expr;
25: 		for (auto &child : aggr_expr.children) {
26: 			callback(child);
27: 		}
28: 		if (aggr_expr.filter) {
29: 			callback(aggr_expr.filter);
30: 		}
31: 		break;
32: 	}
33: 	case ExpressionClass::BOUND_BETWEEN: {
34: 		auto &between_expr = (BoundBetweenExpression &)expr;
35: 		callback(between_expr.input);
36: 		callback(between_expr.lower);
37: 		callback(between_expr.upper);
38: 		break;
39: 	}
40: 	case ExpressionClass::BOUND_CASE: {
41: 		auto &case_expr = (BoundCaseExpression &)expr;
42: 		callback(case_expr.check);
43: 		callback(case_expr.result_if_true);
44: 		callback(case_expr.result_if_false);
45: 		break;
46: 	}
47: 	case ExpressionClass::BOUND_CAST: {
48: 		auto &cast_expr = (BoundCastExpression &)expr;
49: 		callback(cast_expr.child);
50: 		break;
51: 	}
52: 	case ExpressionClass::BOUND_COMPARISON: {
53: 		auto &comp_expr = (BoundComparisonExpression &)expr;
54: 		callback(comp_expr.left);
55: 		callback(comp_expr.right);
56: 		break;
57: 	}
58: 	case ExpressionClass::BOUND_CONJUNCTION: {
59: 		auto &conj_expr = (BoundConjunctionExpression &)expr;
60: 		for (auto &child : conj_expr.children) {
61: 			callback(child);
62: 		}
63: 		break;
64: 	}
65: 	case ExpressionClass::BOUND_FUNCTION: {
66: 		auto &func_expr = (BoundFunctionExpression &)expr;
67: 		for (auto &child : func_expr.children) {
68: 			callback(child);
69: 		}
70: 		break;
71: 	}
72: 	case ExpressionClass::BOUND_OPERATOR: {
73: 		auto &op_expr = (BoundOperatorExpression &)expr;
74: 		for (auto &child : op_expr.children) {
75: 			callback(child);
76: 		}
77: 		break;
78: 	}
79: 	case ExpressionClass::BOUND_SUBQUERY: {
80: 		auto &subquery_expr = (BoundSubqueryExpression &)expr;
81: 		if (subquery_expr.child) {
82: 			callback(subquery_expr.child);
83: 		}
84: 		break;
85: 	}
86: 	case ExpressionClass::BOUND_WINDOW: {
87: 		auto &window_expr = (BoundWindowExpression &)expr;
88: 		for (auto &partition : window_expr.partitions) {
89: 			callback(partition);
90: 		}
91: 		for (auto &order : window_expr.orders) {
92: 			callback(order.expression);
93: 		}
94: 		for (auto &child : window_expr.children) {
95: 			callback(child);
96: 		}
97: 		if (window_expr.start_expr) {
98: 			callback(window_expr.start_expr);
99: 		}
100: 		if (window_expr.end_expr) {
101: 			callback(window_expr.end_expr);
102: 		}
103: 		if (window_expr.offset_expr) {
104: 			callback(window_expr.offset_expr);
105: 		}
106: 		if (window_expr.default_expr) {
107: 			callback(window_expr.default_expr);
108: 		}
109: 		break;
110: 	}
111: 	case ExpressionClass::BOUND_UNNEST: {
112: 		auto &unnest_expr = (BoundUnnestExpression &)expr;
113: 		callback(unnest_expr.child);
114: 		break;
115: 	}
116: 	case ExpressionClass::BOUND_COLUMN_REF:
117: 	case ExpressionClass::BOUND_CONSTANT:
118: 	case ExpressionClass::BOUND_DEFAULT:
119: 	case ExpressionClass::BOUND_PARAMETER:
120: 	case ExpressionClass::BOUND_REF:
121: 		// these node types have no children
122: 		break;
123: 	default:
124: 		throw InternalException("ExpressionIterator used on unbound expression");
125: 	}
126: }
127: 
128: void ExpressionIterator::EnumerateExpression(unique_ptr<Expression> &expr,
129:                                              const std::function<void(Expression &child)> &callback) {
130: 	if (!expr) {
131: 		return;
132: 	}
133: 	callback(*expr);
134: 	ExpressionIterator::EnumerateChildren(*expr,
135: 	                                      [&](unique_ptr<Expression> &child) { EnumerateExpression(child, callback); });
136: }
137: 
138: void ExpressionIterator::EnumerateTableRefChildren(BoundTableRef &ref,
139:                                                    const std::function<void(Expression &child)> &callback) {
140: 	switch (ref.type) {
141: 	case TableReferenceType::CROSS_PRODUCT: {
142: 		auto &bound_crossproduct = (BoundCrossProductRef &)ref;
143: 		EnumerateTableRefChildren(*bound_crossproduct.left, callback);
144: 		EnumerateTableRefChildren(*bound_crossproduct.right, callback);
145: 		break;
146: 	}
147: 	case TableReferenceType::JOIN: {
148: 		auto &bound_join = (BoundJoinRef &)ref;
149: 		EnumerateExpression(bound_join.condition, callback);
150: 		EnumerateTableRefChildren(*bound_join.left, callback);
151: 		EnumerateTableRefChildren(*bound_join.right, callback);
152: 		break;
153: 	}
154: 	case TableReferenceType::SUBQUERY: {
155: 		auto &bound_subquery = (BoundSubqueryRef &)ref;
156: 		EnumerateQueryNodeChildren(*bound_subquery.subquery, callback);
157: 		break;
158: 	}
159: 	default:
160: 		D_ASSERT(ref.type == TableReferenceType::TABLE_FUNCTION || ref.type == TableReferenceType::BASE_TABLE ||
161: 		         ref.type == TableReferenceType::EMPTY);
162: 		break;
163: 	}
164: }
165: 
166: void ExpressionIterator::EnumerateQueryNodeChildren(BoundQueryNode &node,
167:                                                     const std::function<void(Expression &child)> &callback) {
168: 	switch (node.type) {
169: 	case QueryNodeType::SET_OPERATION_NODE: {
170: 		auto &bound_setop = (BoundSetOperationNode &)node;
171: 		EnumerateQueryNodeChildren(*bound_setop.left, callback);
172: 		EnumerateQueryNodeChildren(*bound_setop.right, callback);
173: 		break;
174: 	}
175: 	default:
176: 		D_ASSERT(node.type == QueryNodeType::SELECT_NODE);
177: 		auto &bound_select = (BoundSelectNode &)node;
178: 		for (idx_t i = 0; i < bound_select.select_list.size(); i++) {
179: 			EnumerateExpression(bound_select.select_list[i], callback);
180: 		}
181: 		EnumerateExpression(bound_select.where_clause, callback);
182: 		for (idx_t i = 0; i < bound_select.groups.group_expressions.size(); i++) {
183: 			EnumerateExpression(bound_select.groups.group_expressions[i], callback);
184: 		}
185: 		EnumerateExpression(bound_select.having, callback);
186: 		for (idx_t i = 0; i < bound_select.aggregates.size(); i++) {
187: 			EnumerateExpression(bound_select.aggregates[i], callback);
188: 		}
189: 		for (idx_t i = 0; i < bound_select.unnests.size(); i++) {
190: 			EnumerateExpression(bound_select.unnests[i], callback);
191: 		}
192: 		for (idx_t i = 0; i < bound_select.windows.size(); i++) {
193: 			EnumerateExpression(bound_select.windows[i], callback);
194: 		}
195: 		if (bound_select.from_table) {
196: 			EnumerateTableRefChildren(*bound_select.from_table, callback);
197: 		}
198: 		break;
199: 	}
200: 	for (idx_t i = 0; i < node.modifiers.size(); i++) {
201: 		switch (node.modifiers[i]->type) {
202: 		case ResultModifierType::DISTINCT_MODIFIER:
203: 			for (auto &expr : ((BoundDistinctModifier &)*node.modifiers[i]).target_distincts) {
204: 				EnumerateExpression(expr, callback);
205: 			}
206: 			break;
207: 		case ResultModifierType::ORDER_MODIFIER:
208: 			for (auto &order : ((BoundOrderModifier &)*node.modifiers[i]).orders) {
209: 				EnumerateExpression(order.expression, callback);
210: 			}
211: 			break;
212: 		default:
213: 			break;
214: 		}
215: 	}
216: }
217: 
218: } // namespace duckdb
[end of src/planner/expression_iterator.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: