{
  "repo": "duckdb/duckdb",
  "pull_number": 3528,
  "instance_id": "duckdb__duckdb-3528",
  "issue_numbers": [
    "2942"
  ],
  "base_commit": "991d06596f4aa8b75c5e9c77642ce3bdcaccad0e",
  "patch": "diff --git a/.github/workflows/Julia.yml b/.github/workflows/Julia.yml\nindex 87d0a9d53def..586e97331d18 100644\n--- a/.github/workflows/Julia.yml\n+++ b/.github/workflows/Julia.yml\n@@ -72,6 +72,7 @@ jobs:\n       - name: Run Tests\n         run: |\n           export JULIA_DUCKDB_LIBRARY=\"`pwd`/build/release/src/libduckdb.so\"\n+          export JULIA_NUM_THREADS=2\n           ls $JULIA_DUCKDB_LIBRARY\n           cd tools/juliapkg\n           julia -e \"import Pkg; Pkg.activate(\\\".\\\"); Pkg.instantiate(); include(\\\"test/runtests.jl\\\")\"\n\\ No newline at end of file\ndiff --git a/src/include/duckdb.h b/src/include/duckdb.h\nindex 46a0d97fed55..fee68e3d572d 100644\n--- a/src/include/duckdb.h\n+++ b/src/include/duckdb.h\n@@ -1921,6 +1921,19 @@ Closes the result and de-allocates all memory allocated for the arrow result.\n */\n DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);\n \n+//===--------------------------------------------------------------------===//\n+// Threading Information\n+//===--------------------------------------------------------------------===//\n+/*!\n+Execute DuckDB tasks on this thread.\n+\n+Will return after `max_tasks` have been executed, or if there are no more tasks present.\n+\n+* database: The database object to execute tasks for\n+* max_tasks: The maximum amount of tasks to execute\n+*/\n+DUCKDB_API void duckdb_execute_tasks(duckdb_database database, idx_t max_tasks);\n+\n #ifdef __cplusplus\n }\n #endif\ndiff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp\nindex 82693d0f750c..c4576e3795cc 100644\n--- a/src/include/duckdb/main/config.hpp\n+++ b/src/include/duckdb/main/config.hpp\n@@ -90,6 +90,8 @@ struct DBConfig {\n \tidx_t maximum_memory = (idx_t)-1;\n \t//! The maximum amount of CPU threads used by the database system. Default: all available.\n \tidx_t maximum_threads = (idx_t)-1;\n+\t//! The number of external threads that work on DuckDB tasks. Default: none.\n+\tidx_t external_threads = 0;\n \t//! Whether or not to create and use a temporary directory to store intermediates that do not fit in memory\n \tbool use_temporary_directory = true;\n \t//! Directory to store temporary structures that do not fit in memory\ndiff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp\nindex 02fb2a8b3052..f5878e155c03 100644\n--- a/src/include/duckdb/main/settings.hpp\n+++ b/src/include/duckdb/main/settings.hpp\n@@ -144,6 +144,14 @@ struct ExplainOutputSetting {\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n+struct ExternalThreadsSetting {\n+\tstatic constexpr const char *Name = \"external_threads\";\n+\tstatic constexpr const char *Description = \"The number of external threads that work on DuckDB tasks.\";\n+\tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;\n+\tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic Value GetSetting(ClientContext &context);\n+};\n+\n struct ForceCompressionSetting {\n \tstatic constexpr const char *Name = \"force_compression\";\n \tstatic constexpr const char *Description = \"DEBUG SETTING: forces a specific compression method to be used\";\ndiff --git a/src/include/duckdb/parallel/task_scheduler.hpp b/src/include/duckdb/parallel/task_scheduler.hpp\nindex f2e8f2d74ff7..f827f016df98 100644\n--- a/src/include/duckdb/parallel/task_scheduler.hpp\n+++ b/src/include/duckdb/parallel/task_scheduler.hpp\n@@ -35,11 +35,11 @@ struct ProducerToken {\n \n //! The TaskScheduler is responsible for managing tasks and threads\n class TaskScheduler {\n-\t// timeout for semaphore wait, default 50ms\n-\tconstexpr static int64_t TASK_TIMEOUT_USECS = 50000;\n+\t// timeout for semaphore wait, default 5ms\n+\tconstexpr static int64_t TASK_TIMEOUT_USECS = 5000;\n \n public:\n-\tTaskScheduler();\n+\tTaskScheduler(DatabaseInstance &db);\n \t~TaskScheduler();\n \n \tstatic TaskScheduler &GetScheduler(ClientContext &context);\n@@ -52,6 +52,8 @@ class TaskScheduler {\n \tbool GetTaskFromProducer(ProducerToken &token, unique_ptr<Task> &task);\n \t//! Run tasks forever until \"marker\" is set to false, \"marker\" must remain valid until the thread is joined\n \tvoid ExecuteForever(atomic<bool> *marker);\n+\t//! Run tasks until `max_tasks` have been completed, or until there are no more tasks available\n+\tvoid ExecuteTasks(idx_t max_tasks);\n \n \t//! Sets the amount of active threads executing tasks for the system; n-1 background threads will be launched.\n \t//! The main thread will also be used for execution\n@@ -62,6 +64,8 @@ class TaskScheduler {\n private:\n \tvoid SetThreadsInternal(int32_t n);\n \n+private:\n+\tDatabaseInstance &db;\n \t//! The task queue\n \tunique_ptr<ConcurrentQueue> queue;\n \t//! The active background threads of the task scheduler\ndiff --git a/src/main/capi/CMakeLists.txt b/src/main/capi/CMakeLists.txt\nindex fbab937b5cdc..05c3fbfc155d 100644\n--- a/src/main/capi/CMakeLists.txt\n+++ b/src/main/capi/CMakeLists.txt\n@@ -15,6 +15,7 @@ add_library_unity(\n   replacement_scan-c.cpp\n   result-c.cpp\n   table_function-c.cpp\n+  threading-c.cpp\n   value-c.cpp)\n \n set(ALL_OBJECT_FILES\ndiff --git a/src/main/capi/threading-c.cpp b/src/main/capi/threading-c.cpp\nnew file mode 100644\nindex 000000000000..ff11c7128093\n--- /dev/null\n+++ b/src/main/capi/threading-c.cpp\n@@ -0,0 +1,13 @@\n+#include \"duckdb/main/capi_internal.hpp\"\n+#include \"duckdb/parallel/task_scheduler.hpp\"\n+\n+using duckdb::DatabaseData;\n+\n+void duckdb_execute_tasks(duckdb_database database, idx_t max_tasks) {\n+\tif (!database) {\n+\t\treturn;\n+\t}\n+\tauto wrapper = (DatabaseData *)database;\n+\tauto &scheduler = duckdb::TaskScheduler::GetScheduler(*wrapper->database->instance);\n+\tscheduler.ExecuteTasks(max_tasks);\n+}\ndiff --git a/src/main/config.cpp b/src/main/config.cpp\nindex 18925b35f347..8d131f331deb 100644\n--- a/src/main/config.cpp\n+++ b/src/main/config.cpp\n@@ -37,6 +37,7 @@ static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting\n                                                  DUCKDB_LOCAL(EnableProfilingSetting),\n                                                  DUCKDB_LOCAL(EnableProgressBarSetting),\n                                                  DUCKDB_LOCAL(ExplainOutputSetting),\n+                                                 DUCKDB_GLOBAL(ExternalThreadsSetting),\n                                                  DUCKDB_GLOBAL(ForceCompressionSetting),\n                                                  DUCKDB_LOCAL(LogQueryPathSetting),\n                                                  DUCKDB_GLOBAL(MaximumMemorySetting),\ndiff --git a/src/main/database.cpp b/src/main/database.cpp\nindex c766abf3c60b..fa60d0e117a8 100644\n--- a/src/main/database.cpp\n+++ b/src/main/database.cpp\n@@ -126,7 +126,7 @@ void DatabaseInstance::Initialize(const char *path, DBConfig *new_config) {\n \t    make_unique<StorageManager>(*this, path ? string(path) : string(), config.access_mode == AccessMode::READ_ONLY);\n \tcatalog = make_unique<Catalog>(*this);\n \ttransaction_manager = make_unique<TransactionManager>(*this);\n-\tscheduler = make_unique<TaskScheduler>();\n+\tscheduler = make_unique<TaskScheduler>(*this);\n \tobject_cache = make_unique<ObjectCache>();\n \tconnection_manager = make_unique<ConnectionManager>();\n \n@@ -216,6 +216,7 @@ void DatabaseInstance::Configure(DBConfig &new_config) {\n \t} else {\n \t\tconfig.maximum_threads = new_config.maximum_threads;\n \t}\n+\tconfig.external_threads = new_config.external_threads;\n \tconfig.load_extensions = new_config.load_extensions;\n \tconfig.force_compression = new_config.force_compression;\n \tconfig.allocator = move(new_config.allocator);\ndiff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp\nindex d2b64f4ddde6..309b2bcf2a0f 100644\n--- a/src/main/settings/settings.cpp\n+++ b/src/main/settings/settings.cpp\n@@ -337,6 +337,18 @@ Value ExplainOutputSetting::GetSetting(ClientContext &context) {\n \t}\n }\n \n+//===--------------------------------------------------------------------===//\n+// External Threads Setting\n+//===--------------------------------------------------------------------===//\n+void ExternalThreadsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {\n+\tconfig.external_threads = input.GetValue<int64_t>();\n+}\n+\n+Value ExternalThreadsSetting::GetSetting(ClientContext &context) {\n+\tauto &config = DBConfig::GetConfig(context);\n+\treturn Value::BIGINT(config.external_threads);\n+}\n+\n //===--------------------------------------------------------------------===//\n // Force Compression\n //===--------------------------------------------------------------------===//\ndiff --git a/src/parallel/task_scheduler.cpp b/src/parallel/task_scheduler.cpp\nindex 3fa78d6e94a9..4868c3c26aca 100644\n--- a/src/parallel/task_scheduler.cpp\n+++ b/src/parallel/task_scheduler.cpp\n@@ -93,7 +93,7 @@ ProducerToken::ProducerToken(TaskScheduler &scheduler, unique_ptr<QueueProducerT\n ProducerToken::~ProducerToken() {\n }\n \n-TaskScheduler::TaskScheduler() : queue(make_unique<ConcurrentQueue>()) {\n+TaskScheduler::TaskScheduler(DatabaseInstance &db) : db(db), queue(make_unique<ConcurrentQueue>()) {\n }\n \n TaskScheduler::~TaskScheduler() {\n@@ -130,7 +130,7 @@ void TaskScheduler::ExecuteForever(atomic<bool> *marker) {\n \t// loop until the marker is set to false\n \twhile (*marker) {\n \t\t// wait for a signal with a timeout; the timeout allows us to periodically check\n-\t\tqueue->semaphore.wait(TASK_TIMEOUT_USECS);\n+\t\tqueue->semaphore.wait();\n \t\tif (queue->q.try_dequeue(task)) {\n \t\t\ttask->Execute(TaskExecutionMode::PROCESS_ALL);\n \t\t\ttask.reset();\n@@ -141,6 +141,26 @@ void TaskScheduler::ExecuteForever(atomic<bool> *marker) {\n #endif\n }\n \n+void TaskScheduler::ExecuteTasks(idx_t max_tasks) {\n+#ifndef DUCKDB_NO_THREADS\n+\tunique_ptr<Task> task;\n+\tfor (idx_t i = 0; i < max_tasks; i++) {\n+\t\tqueue->semaphore.wait(TASK_TIMEOUT_USECS);\n+\t\tif (!queue->q.try_dequeue(task)) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttry {\n+\t\t\ttask->Execute(TaskExecutionMode::PROCESS_ALL);\n+\t\t\ttask.reset();\n+\t\t} catch (...) {\n+\t\t\treturn;\n+\t\t}\n+\t}\n+#else\n+\tthrow NotImplementedException(\"DuckDB was compiled without threads! Background thread loop is not allowed.\");\n+#endif\n+}\n+\n #ifndef DUCKDB_NO_THREADS\n static void ThreadExecuteTasks(TaskScheduler *scheduler, atomic<bool> *marker) {\n \tscheduler->ExecuteForever(marker);\n@@ -148,7 +168,8 @@ static void ThreadExecuteTasks(TaskScheduler *scheduler, atomic<bool> *marker) {\n #endif\n \n int32_t TaskScheduler::NumberOfThreads() {\n-\treturn threads.size() + 1;\n+\tauto &config = DBConfig::GetConfig(db);\n+\treturn threads.size() + config.external_threads + 1;\n }\n \n void TaskScheduler::SetThreads(int32_t n) {\n@@ -170,6 +191,20 @@ void TaskScheduler::SetThreadsInternal(int32_t n) {\n \t\treturn;\n \t}\n \tidx_t new_thread_count = n - 1;\n+\tif (threads.size() > new_thread_count) {\n+\t\t// we are reducing the number of threads: clear all threads first\n+\t\tfor (idx_t i = 0; i < threads.size(); i++) {\n+\t\t\t*markers[i] = false;\n+\t\t}\n+\t\tqueue->semaphore.signal(threads.size());\n+\t\t// now join the threads to ensure they are fully stopped before erasing them\n+\t\tfor (idx_t i = 0; i < threads.size(); i++) {\n+\t\t\tthreads[i]->internal_thread->join();\n+\t\t}\n+\t\t// erase the threads/markers\n+\t\tthreads.clear();\n+\t\tmarkers.clear();\n+\t}\n \tif (threads.size() < new_thread_count) {\n \t\t// we are increasing the number of threads: launch them and run tasks on them\n \t\tidx_t create_new_threads = new_thread_count - threads.size();\n@@ -182,18 +217,6 @@ void TaskScheduler::SetThreadsInternal(int32_t n) {\n \t\t\tthreads.push_back(move(thread_wrapper));\n \t\t\tmarkers.push_back(move(marker));\n \t\t}\n-\t} else if (threads.size() > new_thread_count) {\n-\t\t// we are reducing the number of threads: cancel any threads exceeding new_thread_count\n-\t\tfor (idx_t i = new_thread_count; i < threads.size(); i++) {\n-\t\t\t*markers[i] = false;\n-\t\t}\n-\t\t// now join the threads to ensure they are fully stopped before erasing them\n-\t\tfor (idx_t i = new_thread_count; i < threads.size(); i++) {\n-\t\t\tthreads[i]->internal_thread->join();\n-\t\t}\n-\t\t// erase the threads/markers\n-\t\tthreads.resize(new_thread_count);\n-\t\tmarkers.resize(new_thread_count);\n \t}\n #endif\n }\ndiff --git a/tools/juliapkg/src/api.jl b/tools/juliapkg/src/api.jl\nindex 557994085bc8..883b16989c20 100644\n--- a/tools/juliapkg/src/api.jl\n+++ b/tools/juliapkg/src/api.jl\n@@ -2513,3 +2513,18 @@ end\n # function duckdb_destroy_arrow(result)\n #     return ccall((:duckdb_destroy_arrow, libduckdb), Cvoid, (Ptr{Ptr{Cvoid}},), result)\n # end\n+\n+#=\n+//===--------------------------------------------------------------------===//\n+// Threading Interface\n+//===--------------------------------------------------------------------===//\n+=#\n+# Execute DuckDB tasks on this thread.\n+#\n+# Will return after `max_tasks` have been executed, or if there are no more tasks present.\n+#\n+# * database: The database object to execute tasks for\n+# * max_tasks: The maximum amount of tasks to execute\n+function duckdb_execute_tasks(handle, max_tasks)\n+    return ccall((:duckdb_execute_tasks, libduckdb), Cvoid, (duckdb_database, UInt64), handle, max_tasks)\n+end\ndiff --git a/tools/juliapkg/src/database.jl b/tools/juliapkg/src/database.jl\nindex 17db1b80f85e..562793d10034 100644\n--- a/tools/juliapkg/src/database.jl\n+++ b/tools/juliapkg/src/database.jl\n@@ -78,6 +78,7 @@ mutable struct DB <: DBInterface.Connection\n \n     function DB(f::AbstractString, config::Config)\n         set_config(config, \"threads\", \"1\")\n+        set_config(config, \"external_threads\", string(Threads.nthreads() - 1))\n         handle = DuckDBHandle(f, config)\n         main_connection = Connection(handle)\n \ndiff --git a/tools/juliapkg/src/result.jl b/tools/juliapkg/src/result.jl\nindex fd1764fca809..d7d5f25c4553 100644\n--- a/tools/juliapkg/src/result.jl\n+++ b/tools/juliapkg/src/result.jl\n@@ -1,3 +1,4 @@\n+import Base.Threads.@spawn\n \n mutable struct QueryResult\n     handle::Ref{duckdb_result}\n@@ -496,11 +497,36 @@ function toDataFrame(result::Ref{duckdb_result})::DataFrame\n     return df\n end\n \n+function execute_tasks(db::DuckDBHandle)\n+    duckdb_execute_tasks(db.handle, typemax(UInt64))\n+    return\n+end\n+\n+function cleanup_tasks(tasks)\n+    for task in tasks\n+        Base.wait(task)\n+    end\n+end\n+\n function execute(stmt::Stmt, params::DBInterface.StatementParams = ())\n     bind_parameters(stmt, params)\n \n     handle = Ref{duckdb_result}()\n-    if duckdb_execute_prepared(stmt.handle, handle) != DuckDBSuccess\n+    # if multi-threading is enabled, launch tasks\n+    tasks = []\n+    for i in 2:Threads.nthreads()\n+        task_val = @spawn execute_tasks(stmt.con.db)\n+        push!(tasks, task_val)\n+    end\n+    ret = DuckDBSuccess\n+    try\n+        ret = duckdb_execute_prepared(stmt.handle, handle)\n+    catch ex\n+        cleanup_tasks(tasks)\n+        throw(ex)\n+    end\n+    cleanup_tasks(tasks)\n+    if ret != DuckDBSuccess\n         error_ptr = duckdb_result_error(handle)\n         if error_ptr == C_NULL\n             error_message = string(\"Execute of query \\\"\", stmt.sql, \"\\\" failed: unknown error\")\n",
  "test_patch": "diff --git a/test/sql/parallelism/modify_thread_settings.test b/test/sql/parallelism/modify_thread_settings.test\nnew file mode 100644\nindex 000000000000..ac0560ab54d1\n--- /dev/null\n+++ b/test/sql/parallelism/modify_thread_settings.test\n@@ -0,0 +1,19 @@\n+# name: test/sql/parallelism/modify_thread_settings.test\n+# description: Test modifying the number of threads repeatedly\n+# group: [parallelism]\n+\n+loop i 0 10\n+\n+statement ok\n+SET threads=8\n+\n+statement ok\n+SET threads=4\n+\n+statement ok\n+SET threads=4\n+\n+statement ok\n+SET threads=1\n+\n+endloop\ndiff --git a/tools/juliapkg/test.sh b/tools/juliapkg/test.sh\nindex dc05bf5c876f..dfdd45611934 100755\n--- a/tools/juliapkg/test.sh\n+++ b/tools/juliapkg/test.sh\n@@ -5,4 +5,5 @@ set -e\n export JULIA_DUCKDB_LIBRARY=\"`pwd`/../../build/debug/src/libduckdb.dylib\"\n #export JULIA_DUCKDB_LIBRARY=\"/Users/myth/Programs/duckdb-bugfix/build/release/src/libduckdb.dylib\"\n \n+export JULIA_NUM_THREADS=4\n julia -e \"import Pkg; Pkg.activate(\\\".\\\"); include(\\\"test/runtests.jl\\\")\" $1\ndiff --git a/tools/juliapkg/test/runtests.jl b/tools/juliapkg/test/runtests.jl\nindex 1c3ad894445b..3cd403faa26a 100644\n--- a/tools/juliapkg/test/runtests.jl\n+++ b/tools/juliapkg/test/runtests.jl\n@@ -18,7 +18,8 @@ test_files = [\n     \"test_table_function.jl\",\n     \"test_old_interface.jl\",\n     \"test_all_types.jl\",\n-    \"test_decimals.jl\"\n+    \"test_decimals.jl\",\n+    \"test_threading.jl\"\n ]\n \n if size(ARGS)[1] > 0\ndiff --git a/tools/juliapkg/test/test_threading.jl b/tools/juliapkg/test/test_threading.jl\nnew file mode 100644\nindex 000000000000..d9519b80fa88\n--- /dev/null\n+++ b/tools/juliapkg/test/test_threading.jl\n@@ -0,0 +1,12 @@\n+# test_threading.jl\n+\n+@testset \"Test threading\" begin\n+    con = DBInterface.connect(DuckDB.DB)\n+\n+    DBInterface.execute(con, \"CREATE TABLE integers AS SELECT * FROM range(100000000) t(i)\")\n+    results = DBInterface.execute(con, \"SELECT SUM(i) sum FROM integers\")\n+    df = DataFrame(results)\n+    @test df.sum == [4999999950000000]\n+\n+    DBInterface.close!(con)\n+end\n",
  "problem_statement": "[R]: Polling thread started by duckdb::duckdb()?\n#### What happens?\r\n\r\nI'm observing small but noticeable CPU usage after running `duckdb::duckdb()`. The load is reduced after the duckdb connector is garbage-collected. Is this expected? Does duckdb start a polling thread of sorts?\r\n\r\n#### To Reproduce\r\n\r\n``` r\r\nlibrary(duckdb)\r\n#> Loading required package: DBI\r\n\r\nSys.sleep(5)\r\nsystem('ps -Ao \"%cpu comm\" | grep \"/R$\"', intern = TRUE)\r\n#> [1] \"  0.0 /Library/Frameworks/R.framework/Resources/bin/exec/R\"\r\n\r\nduck <- duckdb()\r\nSys.sleep(5)\r\nsystem('ps -Ao \"%cpu comm\" | grep \"/R$\"', intern = TRUE)\r\n#> [1] \"  2.2 /Library/Frameworks/R.framework/Resources/bin/exec/R\"\r\n\r\nrm(duck)\r\ngc()\r\n#>           used (Mb) gc trigger (Mb) limit (Mb) max used (Mb)\r\n#> Ncells  849164 45.4    1323022 70.7         NA  1323022 70.7\r\n#> Vcells 1551623 11.9    8388608 64.0      16384  2927822 22.4\r\nSys.sleep(10)\r\nsystem('ps -Ao \"%cpu comm\" | grep \"/R$\"', intern = TRUE)\r\n#> [1] \"  0.0 /Library/Frameworks/R.framework/Resources/bin/exec/R\"\r\n```\r\n\r\n<sup>Created on 2022-01-18 by the [reprex package](https://reprex.tidyverse.org) (v2.0.1)</sup>\r\n\r\n#### Environment (please complete the following information):\r\n - OS: macOS\r\n - DuckDB Version: 1114055090353edd6a998150d6e6388d612cd689\r\n - DuckDB Client: R\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\r\nCC @nbenn.\n",
  "hints_text": "DuckDB starts some background threads that wait for work to appear. These shouldn\u2019t be doing anything but waiting for tasks to be available, however. Perhaps something happening there?",
  "created_at": "2022-04-28T20:26:49Z"
}