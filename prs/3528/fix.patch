diff --git a/.github/workflows/Julia.yml b/.github/workflows/Julia.yml
index 87d0a9d53def..586e97331d18 100644
--- a/.github/workflows/Julia.yml
+++ b/.github/workflows/Julia.yml
@@ -72,6 +72,7 @@ jobs:
       - name: Run Tests
         run: |
           export JULIA_DUCKDB_LIBRARY="`pwd`/build/release/src/libduckdb.so"
+          export JULIA_NUM_THREADS=2
           ls $JULIA_DUCKDB_LIBRARY
           cd tools/juliapkg
           julia -e "import Pkg; Pkg.activate(\".\"); Pkg.instantiate(); include(\"test/runtests.jl\")"
\ No newline at end of file
diff --git a/src/include/duckdb.h b/src/include/duckdb.h
index 46a0d97fed55..fee68e3d572d 100644
--- a/src/include/duckdb.h
+++ b/src/include/duckdb.h
@@ -1921,6 +1921,19 @@ Closes the result and de-allocates all memory allocated for the arrow result.
 */
 DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
 
+//===--------------------------------------------------------------------===//
+// Threading Information
+//===--------------------------------------------------------------------===//
+/*!
+Execute DuckDB tasks on this thread.
+
+Will return after `max_tasks` have been executed, or if there are no more tasks present.
+
+* database: The database object to execute tasks for
+* max_tasks: The maximum amount of tasks to execute
+*/
+DUCKDB_API void duckdb_execute_tasks(duckdb_database database, idx_t max_tasks);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp
index 82693d0f750c..c4576e3795cc 100644
--- a/src/include/duckdb/main/config.hpp
+++ b/src/include/duckdb/main/config.hpp
@@ -90,6 +90,8 @@ struct DBConfig {
 	idx_t maximum_memory = (idx_t)-1;
 	//! The maximum amount of CPU threads used by the database system. Default: all available.
 	idx_t maximum_threads = (idx_t)-1;
+	//! The number of external threads that work on DuckDB tasks. Default: none.
+	idx_t external_threads = 0;
 	//! Whether or not to create and use a temporary directory to store intermediates that do not fit in memory
 	bool use_temporary_directory = true;
 	//! Directory to store temporary structures that do not fit in memory
diff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp
index 02fb2a8b3052..f5878e155c03 100644
--- a/src/include/duckdb/main/settings.hpp
+++ b/src/include/duckdb/main/settings.hpp
@@ -144,6 +144,14 @@ struct ExplainOutputSetting {
 	static Value GetSetting(ClientContext &context);
 };
 
+struct ExternalThreadsSetting {
+	static constexpr const char *Name = "external_threads";
+	static constexpr const char *Description = "The number of external threads that work on DuckDB tasks.";
+	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
+	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
+	static Value GetSetting(ClientContext &context);
+};
+
 struct ForceCompressionSetting {
 	static constexpr const char *Name = "force_compression";
 	static constexpr const char *Description = "DEBUG SETTING: forces a specific compression method to be used";
diff --git a/src/include/duckdb/parallel/task_scheduler.hpp b/src/include/duckdb/parallel/task_scheduler.hpp
index f2e8f2d74ff7..f827f016df98 100644
--- a/src/include/duckdb/parallel/task_scheduler.hpp
+++ b/src/include/duckdb/parallel/task_scheduler.hpp
@@ -35,11 +35,11 @@ struct ProducerToken {
 
 //! The TaskScheduler is responsible for managing tasks and threads
 class TaskScheduler {
-	// timeout for semaphore wait, default 50ms
-	constexpr static int64_t TASK_TIMEOUT_USECS = 50000;
+	// timeout for semaphore wait, default 5ms
+	constexpr static int64_t TASK_TIMEOUT_USECS = 5000;
 
 public:
-	TaskScheduler();
+	TaskScheduler(DatabaseInstance &db);
 	~TaskScheduler();
 
 	static TaskScheduler &GetScheduler(ClientContext &context);
@@ -52,6 +52,8 @@ class TaskScheduler {
 	bool GetTaskFromProducer(ProducerToken &token, unique_ptr<Task> &task);
 	//! Run tasks forever until "marker" is set to false, "marker" must remain valid until the thread is joined
 	void ExecuteForever(atomic<bool> *marker);
+	//! Run tasks until `max_tasks` have been completed, or until there are no more tasks available
+	void ExecuteTasks(idx_t max_tasks);
 
 	//! Sets the amount of active threads executing tasks for the system; n-1 background threads will be launched.
 	//! The main thread will also be used for execution
@@ -62,6 +64,8 @@ class TaskScheduler {
 private:
 	void SetThreadsInternal(int32_t n);
 
+private:
+	DatabaseInstance &db;
 	//! The task queue
 	unique_ptr<ConcurrentQueue> queue;
 	//! The active background threads of the task scheduler
diff --git a/src/main/capi/CMakeLists.txt b/src/main/capi/CMakeLists.txt
index fbab937b5cdc..05c3fbfc155d 100644
--- a/src/main/capi/CMakeLists.txt
+++ b/src/main/capi/CMakeLists.txt
@@ -15,6 +15,7 @@ add_library_unity(
   replacement_scan-c.cpp
   result-c.cpp
   table_function-c.cpp
+  threading-c.cpp
   value-c.cpp)
 
 set(ALL_OBJECT_FILES
diff --git a/src/main/capi/threading-c.cpp b/src/main/capi/threading-c.cpp
new file mode 100644
index 000000000000..ff11c7128093
--- /dev/null
+++ b/src/main/capi/threading-c.cpp
@@ -0,0 +1,13 @@
+#include "duckdb/main/capi_internal.hpp"
+#include "duckdb/parallel/task_scheduler.hpp"
+
+using duckdb::DatabaseData;
+
+void duckdb_execute_tasks(duckdb_database database, idx_t max_tasks) {
+	if (!database) {
+		return;
+	}
+	auto wrapper = (DatabaseData *)database;
+	auto &scheduler = duckdb::TaskScheduler::GetScheduler(*wrapper->database->instance);
+	scheduler.ExecuteTasks(max_tasks);
+}
diff --git a/src/main/config.cpp b/src/main/config.cpp
index 18925b35f347..8d131f331deb 100644
--- a/src/main/config.cpp
+++ b/src/main/config.cpp
@@ -37,6 +37,7 @@ static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting
                                                  DUCKDB_LOCAL(EnableProfilingSetting),
                                                  DUCKDB_LOCAL(EnableProgressBarSetting),
                                                  DUCKDB_LOCAL(ExplainOutputSetting),
+                                                 DUCKDB_GLOBAL(ExternalThreadsSetting),
                                                  DUCKDB_GLOBAL(ForceCompressionSetting),
                                                  DUCKDB_LOCAL(LogQueryPathSetting),
                                                  DUCKDB_GLOBAL(MaximumMemorySetting),
diff --git a/src/main/database.cpp b/src/main/database.cpp
index c766abf3c60b..fa60d0e117a8 100644
--- a/src/main/database.cpp
+++ b/src/main/database.cpp
@@ -126,7 +126,7 @@ void DatabaseInstance::Initialize(const char *path, DBConfig *new_config) {
 	    make_unique<StorageManager>(*this, path ? string(path) : string(), config.access_mode == AccessMode::READ_ONLY);
 	catalog = make_unique<Catalog>(*this);
 	transaction_manager = make_unique<TransactionManager>(*this);
-	scheduler = make_unique<TaskScheduler>();
+	scheduler = make_unique<TaskScheduler>(*this);
 	object_cache = make_unique<ObjectCache>();
 	connection_manager = make_unique<ConnectionManager>();
 
@@ -216,6 +216,7 @@ void DatabaseInstance::Configure(DBConfig &new_config) {
 	} else {
 		config.maximum_threads = new_config.maximum_threads;
 	}
+	config.external_threads = new_config.external_threads;
 	config.load_extensions = new_config.load_extensions;
 	config.force_compression = new_config.force_compression;
 	config.allocator = move(new_config.allocator);
diff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp
index d2b64f4ddde6..309b2bcf2a0f 100644
--- a/src/main/settings/settings.cpp
+++ b/src/main/settings/settings.cpp
@@ -337,6 +337,18 @@ Value ExplainOutputSetting::GetSetting(ClientContext &context) {
 	}
 }
 
+//===--------------------------------------------------------------------===//
+// External Threads Setting
+//===--------------------------------------------------------------------===//
+void ExternalThreadsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
+	config.external_threads = input.GetValue<int64_t>();
+}
+
+Value ExternalThreadsSetting::GetSetting(ClientContext &context) {
+	auto &config = DBConfig::GetConfig(context);
+	return Value::BIGINT(config.external_threads);
+}
+
 //===--------------------------------------------------------------------===//
 // Force Compression
 //===--------------------------------------------------------------------===//
diff --git a/src/parallel/task_scheduler.cpp b/src/parallel/task_scheduler.cpp
index 3fa78d6e94a9..4868c3c26aca 100644
--- a/src/parallel/task_scheduler.cpp
+++ b/src/parallel/task_scheduler.cpp
@@ -93,7 +93,7 @@ ProducerToken::ProducerToken(TaskScheduler &scheduler, unique_ptr<QueueProducerT
 ProducerToken::~ProducerToken() {
 }
 
-TaskScheduler::TaskScheduler() : queue(make_unique<ConcurrentQueue>()) {
+TaskScheduler::TaskScheduler(DatabaseInstance &db) : db(db), queue(make_unique<ConcurrentQueue>()) {
 }
 
 TaskScheduler::~TaskScheduler() {
@@ -130,7 +130,7 @@ void TaskScheduler::ExecuteForever(atomic<bool> *marker) {
 	// loop until the marker is set to false
 	while (*marker) {
 		// wait for a signal with a timeout; the timeout allows us to periodically check
-		queue->semaphore.wait(TASK_TIMEOUT_USECS);
+		queue->semaphore.wait();
 		if (queue->q.try_dequeue(task)) {
 			task->Execute(TaskExecutionMode::PROCESS_ALL);
 			task.reset();
@@ -141,6 +141,26 @@ void TaskScheduler::ExecuteForever(atomic<bool> *marker) {
 #endif
 }
 
+void TaskScheduler::ExecuteTasks(idx_t max_tasks) {
+#ifndef DUCKDB_NO_THREADS
+	unique_ptr<Task> task;
+	for (idx_t i = 0; i < max_tasks; i++) {
+		queue->semaphore.wait(TASK_TIMEOUT_USECS);
+		if (!queue->q.try_dequeue(task)) {
+			return;
+		}
+		try {
+			task->Execute(TaskExecutionMode::PROCESS_ALL);
+			task.reset();
+		} catch (...) {
+			return;
+		}
+	}
+#else
+	throw NotImplementedException("DuckDB was compiled without threads! Background thread loop is not allowed.");
+#endif
+}
+
 #ifndef DUCKDB_NO_THREADS
 static void ThreadExecuteTasks(TaskScheduler *scheduler, atomic<bool> *marker) {
 	scheduler->ExecuteForever(marker);
@@ -148,7 +168,8 @@ static void ThreadExecuteTasks(TaskScheduler *scheduler, atomic<bool> *marker) {
 #endif
 
 int32_t TaskScheduler::NumberOfThreads() {
-	return threads.size() + 1;
+	auto &config = DBConfig::GetConfig(db);
+	return threads.size() + config.external_threads + 1;
 }
 
 void TaskScheduler::SetThreads(int32_t n) {
@@ -170,6 +191,20 @@ void TaskScheduler::SetThreadsInternal(int32_t n) {
 		return;
 	}
 	idx_t new_thread_count = n - 1;
+	if (threads.size() > new_thread_count) {
+		// we are reducing the number of threads: clear all threads first
+		for (idx_t i = 0; i < threads.size(); i++) {
+			*markers[i] = false;
+		}
+		queue->semaphore.signal(threads.size());
+		// now join the threads to ensure they are fully stopped before erasing them
+		for (idx_t i = 0; i < threads.size(); i++) {
+			threads[i]->internal_thread->join();
+		}
+		// erase the threads/markers
+		threads.clear();
+		markers.clear();
+	}
 	if (threads.size() < new_thread_count) {
 		// we are increasing the number of threads: launch them and run tasks on them
 		idx_t create_new_threads = new_thread_count - threads.size();
@@ -182,18 +217,6 @@ void TaskScheduler::SetThreadsInternal(int32_t n) {
 			threads.push_back(move(thread_wrapper));
 			markers.push_back(move(marker));
 		}
-	} else if (threads.size() > new_thread_count) {
-		// we are reducing the number of threads: cancel any threads exceeding new_thread_count
-		for (idx_t i = new_thread_count; i < threads.size(); i++) {
-			*markers[i] = false;
-		}
-		// now join the threads to ensure they are fully stopped before erasing them
-		for (idx_t i = new_thread_count; i < threads.size(); i++) {
-			threads[i]->internal_thread->join();
-		}
-		// erase the threads/markers
-		threads.resize(new_thread_count);
-		markers.resize(new_thread_count);
 	}
 #endif
 }
diff --git a/tools/juliapkg/src/api.jl b/tools/juliapkg/src/api.jl
index 557994085bc8..883b16989c20 100644
--- a/tools/juliapkg/src/api.jl
+++ b/tools/juliapkg/src/api.jl
@@ -2513,3 +2513,18 @@ end
 # function duckdb_destroy_arrow(result)
 #     return ccall((:duckdb_destroy_arrow, libduckdb), Cvoid, (Ptr{Ptr{Cvoid}},), result)
 # end
+
+#=
+//===--------------------------------------------------------------------===//
+// Threading Interface
+//===--------------------------------------------------------------------===//
+=#
+# Execute DuckDB tasks on this thread.
+#
+# Will return after `max_tasks` have been executed, or if there are no more tasks present.
+#
+# * database: The database object to execute tasks for
+# * max_tasks: The maximum amount of tasks to execute
+function duckdb_execute_tasks(handle, max_tasks)
+    return ccall((:duckdb_execute_tasks, libduckdb), Cvoid, (duckdb_database, UInt64), handle, max_tasks)
+end
diff --git a/tools/juliapkg/src/database.jl b/tools/juliapkg/src/database.jl
index 17db1b80f85e..562793d10034 100644
--- a/tools/juliapkg/src/database.jl
+++ b/tools/juliapkg/src/database.jl
@@ -78,6 +78,7 @@ mutable struct DB <: DBInterface.Connection
 
     function DB(f::AbstractString, config::Config)
         set_config(config, "threads", "1")
+        set_config(config, "external_threads", string(Threads.nthreads() - 1))
         handle = DuckDBHandle(f, config)
         main_connection = Connection(handle)
 
diff --git a/tools/juliapkg/src/result.jl b/tools/juliapkg/src/result.jl
index fd1764fca809..d7d5f25c4553 100644
--- a/tools/juliapkg/src/result.jl
+++ b/tools/juliapkg/src/result.jl
@@ -1,3 +1,4 @@
+import Base.Threads.@spawn
 
 mutable struct QueryResult
     handle::Ref{duckdb_result}
@@ -496,11 +497,36 @@ function toDataFrame(result::Ref{duckdb_result})::DataFrame
     return df
 end
 
+function execute_tasks(db::DuckDBHandle)
+    duckdb_execute_tasks(db.handle, typemax(UInt64))
+    return
+end
+
+function cleanup_tasks(tasks)
+    for task in tasks
+        Base.wait(task)
+    end
+end
+
 function execute(stmt::Stmt, params::DBInterface.StatementParams = ())
     bind_parameters(stmt, params)
 
     handle = Ref{duckdb_result}()
-    if duckdb_execute_prepared(stmt.handle, handle) != DuckDBSuccess
+    # if multi-threading is enabled, launch tasks
+    tasks = []
+    for i in 2:Threads.nthreads()
+        task_val = @spawn execute_tasks(stmt.con.db)
+        push!(tasks, task_val)
+    end
+    ret = DuckDBSuccess
+    try
+        ret = duckdb_execute_prepared(stmt.handle, handle)
+    catch ex
+        cleanup_tasks(tasks)
+        throw(ex)
+    end
+    cleanup_tasks(tasks)
+    if ret != DuckDBSuccess
         error_ptr = duckdb_result_error(handle)
         if error_ptr == C_NULL
             error_message = string("Execute of query \"", stmt.sql, "\" failed: unknown error")
