You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
[R]: Polling thread started by duckdb::duckdb()?
#### What happens?

I'm observing small but noticeable CPU usage after running `duckdb::duckdb()`. The load is reduced after the duckdb connector is garbage-collected. Is this expected? Does duckdb start a polling thread of sorts?

#### To Reproduce

``` r
library(duckdb)
#> Loading required package: DBI

Sys.sleep(5)
system('ps -Ao "%cpu comm" | grep "/R$"', intern = TRUE)
#> [1] "  0.0 /Library/Frameworks/R.framework/Resources/bin/exec/R"

duck <- duckdb()
Sys.sleep(5)
system('ps -Ao "%cpu comm" | grep "/R$"', intern = TRUE)
#> [1] "  2.2 /Library/Frameworks/R.framework/Resources/bin/exec/R"

rm(duck)
gc()
#>           used (Mb) gc trigger (Mb) limit (Mb) max used (Mb)
#> Ncells  849164 45.4    1323022 70.7         NA  1323022 70.7
#> Vcells 1551623 11.9    8388608 64.0      16384  2927822 22.4
Sys.sleep(10)
system('ps -Ao "%cpu comm" | grep "/R$"', intern = TRUE)
#> [1] "  0.0 /Library/Frameworks/R.framework/Resources/bin/exec/R"
```

<sup>Created on 2022-01-18 by the [reprex package](https://reprex.tidyverse.org) (v2.0.1)</sup>

#### Environment (please complete the following information):
 - OS: macOS
 - DuckDB Version: 1114055090353edd6a998150d6e6388d612cd689
 - DuckDB Client: R

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

CC @nbenn.

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of .github/workflows/Julia.yml]
1: name: Julia
2: on:
3:    push:
4:      paths-ignore:
5:        - '**.md'
6:    pull_request:
7:      paths-ignore:
8:        - '**.md'
9:        - 'examples/**'
10:        - 'test/**'
11:        - 'tools/nodejs/**'
12:        - 'tools/pythonpkg/**'
13:        - 'tools/rpkg/**'
14:        - '.github/workflows/**'
15:        - '!.github/workflows/Julia.yml'
16: concurrency:
17:   group: ${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/master' || github.sha }}
18:   cancel-in-progress: true
19: 
20: defaults:
21:   run:
22:     shell: bash
23: 
24: jobs:
25:   format_check:
26:     name: Julia Format Check
27:     runs-on: ubuntu-latest
28:     steps:
29:       - uses: actions/checkout@v3
30:         with:
31:           fetch-depth: 0
32: 
33:       - uses: julia-actions/setup-julia@v1
34:         with:
35:           version: 1.7
36:           arch: x64
37: 
38:       - name: Format Check
39:         run: |
40:             cd tools/juliapkg
41:             julia -e "import Pkg; Pkg.add(\"JuliaFormatter\")"
42:             ./format_check.sh
43: 
44:   main_julia:
45:     name: Julia ${{ matrix.version }}
46:     runs-on: ${{ matrix.os }}
47:     strategy:
48:       fail-fast: false
49:       matrix:
50:         version:
51:           - '1.6'
52:           - '1.7'
53:           - 'nightly'
54:         os:
55:           - ubuntu-latest
56:         arch:
57:           - x64
58:     steps:
59:       - uses: actions/checkout@v3
60:         with:
61:           fetch-depth: 0
62: 
63:       - uses: julia-actions/setup-julia@v1
64:         with:
65:           version: ${{ matrix.version }}
66:           arch: ${{ matrix.arch }}
67: 
68:       - name: Build DuckDB
69:         run: |
70:             make
71: 
72:       - name: Run Tests
73:         run: |
74:           export JULIA_DUCKDB_LIBRARY="`pwd`/build/release/src/libduckdb.so"
75:           ls $JULIA_DUCKDB_LIBRARY
76:           cd tools/juliapkg
77:           julia -e "import Pkg; Pkg.activate(\".\"); Pkg.instantiate(); include(\"test/runtests.jl\")"
[end of .github/workflows/Julia.yml]
[start of src/include/duckdb.h]
1: //===----------------------------------------------------------------------===//
2: //
3: //                         DuckDB
4: //
5: // duckdb.h
6: //
7: //
8: //===----------------------------------------------------------------------===//
9: 
10: #pragma once
11: 
12: // duplicate of duckdb/main/winapi.hpp
13: #ifndef DUCKDB_API
14: #ifdef _WIN32
15: #if defined(DUCKDB_BUILD_LIBRARY) && !defined(DUCKDB_BUILD_LOADABLE_EXTENSION)
16: #define DUCKDB_API __declspec(dllexport)
17: #else
18: #define DUCKDB_API __declspec(dllimport)
19: #endif
20: #else
21: #define DUCKDB_API
22: #endif
23: #endif
24: 
25: // duplicate of duckdb/common/constants.hpp
26: #ifndef DUCKDB_API_0_3_1
27: #define DUCKDB_API_0_3_1 1
28: #endif
29: #ifndef DUCKDB_API_0_3_2
30: #define DUCKDB_API_0_3_2 2
31: #endif
32: #ifndef DUCKDB_API_LATEST
33: #define DUCKDB_API_LATEST DUCKDB_API_0_3_2
34: #endif
35: 
36: #ifndef DUCKDB_API_VERSION
37: #define DUCKDB_API_VERSION DUCKDB_API_LATEST
38: #endif
39: 
40: #include <stdbool.h>
41: #include <stdint.h>
42: #include <stdlib.h>
43: 
44: #ifdef __cplusplus
45: extern "C" {
46: #endif
47: 
48: //===--------------------------------------------------------------------===//
49: // Type Information
50: //===--------------------------------------------------------------------===//
51: typedef uint64_t idx_t;
52: 
53: typedef enum DUCKDB_TYPE {
54: 	DUCKDB_TYPE_INVALID = 0,
55: 	// bool
56: 	DUCKDB_TYPE_BOOLEAN,
57: 	// int8_t
58: 	DUCKDB_TYPE_TINYINT,
59: 	// int16_t
60: 	DUCKDB_TYPE_SMALLINT,
61: 	// int32_t
62: 	DUCKDB_TYPE_INTEGER,
63: 	// int64_t
64: 	DUCKDB_TYPE_BIGINT,
65: 	// uint8_t
66: 	DUCKDB_TYPE_UTINYINT,
67: 	// uint16_t
68: 	DUCKDB_TYPE_USMALLINT,
69: 	// uint32_t
70: 	DUCKDB_TYPE_UINTEGER,
71: 	// uint64_t
72: 	DUCKDB_TYPE_UBIGINT,
73: 	// float
74: 	DUCKDB_TYPE_FLOAT,
75: 	// double
76: 	DUCKDB_TYPE_DOUBLE,
77: 	// duckdb_timestamp, in microseconds
78: 	DUCKDB_TYPE_TIMESTAMP,
79: 	// duckdb_date
80: 	DUCKDB_TYPE_DATE,
81: 	// duckdb_time
82: 	DUCKDB_TYPE_TIME,
83: 	// duckdb_interval
84: 	DUCKDB_TYPE_INTERVAL,
85: 	// duckdb_hugeint
86: 	DUCKDB_TYPE_HUGEINT,
87: 	// const char*
88: 	DUCKDB_TYPE_VARCHAR,
89: 	// duckdb_blob
90: 	DUCKDB_TYPE_BLOB,
91: 	// decimal
92: 	DUCKDB_TYPE_DECIMAL,
93: 	// duckdb_timestamp, in seconds
94: 	DUCKDB_TYPE_TIMESTAMP_S,
95: 	// duckdb_timestamp, in milliseconds
96: 	DUCKDB_TYPE_TIMESTAMP_MS,
97: 	// duckdb_timestamp, in nanoseconds
98: 	DUCKDB_TYPE_TIMESTAMP_NS,
99: 	// enum type, only useful as logical type
100: 	DUCKDB_TYPE_ENUM,
101: 	// list type, only useful as logical type
102: 	DUCKDB_TYPE_LIST,
103: 	// struct type, only useful as logical type
104: 	DUCKDB_TYPE_STRUCT,
105: 	// map type, only useful as logical type
106: 	DUCKDB_TYPE_MAP,
107: 	// duckdb_hugeint
108: 	DUCKDB_TYPE_UUID,
109: 	// const char*
110: 	DUCKDB_TYPE_JSON,
111: } duckdb_type;
112: 
113: //! Days are stored as days since 1970-01-01
114: //! Use the duckdb_from_date/duckdb_to_date function to extract individual information
115: typedef struct {
116: 	int32_t days;
117: } duckdb_date;
118: 
119: typedef struct {
120: 	int32_t year;
121: 	int8_t month;
122: 	int8_t day;
123: } duckdb_date_struct;
124: 
125: //! Time is stored as microseconds since 00:00:00
126: //! Use the duckdb_from_time/duckdb_to_time function to extract individual information
127: typedef struct {
128: 	int64_t micros;
129: } duckdb_time;
130: 
131: typedef struct {
132: 	int8_t hour;
133: 	int8_t min;
134: 	int8_t sec;
135: 	int32_t micros;
136: } duckdb_time_struct;
137: 
138: //! Timestamps are stored as microseconds since 1970-01-01
139: //! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information
140: typedef struct {
141: 	int64_t micros;
142: } duckdb_timestamp;
143: 
144: typedef struct {
145: 	duckdb_date_struct date;
146: 	duckdb_time_struct time;
147: } duckdb_timestamp_struct;
148: 
149: typedef struct {
150: 	int32_t months;
151: 	int32_t days;
152: 	int64_t micros;
153: } duckdb_interval;
154: 
155: //! Hugeints are composed in a (lower, upper) component
156: //! The value of the hugeint is upper * 2^64 + lower
157: //! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended
158: typedef struct {
159: 	uint64_t lower;
160: 	int64_t upper;
161: } duckdb_hugeint;
162: 
163: typedef struct {
164: 	uint8_t width;
165: 	uint8_t scale;
166: 
167: 	duckdb_hugeint value;
168: } duckdb_decimal;
169: 
170: typedef struct {
171: 	void *data;
172: 	idx_t size;
173: } duckdb_blob;
174: 
175: typedef struct {
176: #if DUCKDB_API_VERSION < DUCKDB_API_0_3_2
177: 	void *data;
178: 	bool *nullmask;
179: 	duckdb_type type;
180: 	char *name;
181: #else
182: 	// deprecated, use duckdb_column_data
183: 	void *__deprecated_data;
184: 	// deprecated, use duckdb_nullmask_data
185: 	bool *__deprecated_nullmask;
186: 	// deprecated, use duckdb_column_type
187: 	duckdb_type __deprecated_type;
188: 	// deprecated, use duckdb_column_name
189: 	char *__deprecated_name;
190: #endif
191: 	void *internal_data;
192: } duckdb_column;
193: 
194: typedef struct {
195: #if DUCKDB_API_VERSION < DUCKDB_API_0_3_2
196: 	idx_t column_count;
197: 	idx_t row_count;
198: 	idx_t rows_changed;
199: 	duckdb_column *columns;
200: 	char *error_message;
201: #else
202: 	// deprecated, use duckdb_column_count
203: 	idx_t __deprecated_column_count;
204: 	// deprecated, use duckdb_row_count
205: 	idx_t __deprecated_row_count;
206: 	// deprecated, use duckdb_rows_changed
207: 	idx_t __deprecated_rows_changed;
208: 	// deprecated, use duckdb_column_ family of functions
209: 	duckdb_column *__deprecated_columns;
210: 	// deprecated, use duckdb_result_error
211: 	char *__deprecated_error_message;
212: #endif
213: 	void *internal_data;
214: } duckdb_result;
215: 
216: typedef void *duckdb_database;
217: typedef void *duckdb_connection;
218: typedef void *duckdb_prepared_statement;
219: typedef void *duckdb_appender;
220: typedef void *duckdb_arrow;
221: typedef void *duckdb_config;
222: typedef void *duckdb_arrow_schema;
223: typedef void *duckdb_arrow_array;
224: typedef void *duckdb_logical_type;
225: typedef void *duckdb_data_chunk;
226: typedef void *duckdb_vector;
227: typedef void *duckdb_value;
228: 
229: typedef enum { DuckDBSuccess = 0, DuckDBError = 1 } duckdb_state;
230: 
231: //===--------------------------------------------------------------------===//
232: // Open/Connect
233: //===--------------------------------------------------------------------===//
234: 
235: /*!
236: Creates a new database or opens an existing database file stored at the the given path.
237: If no path is given a new in-memory database is created instead.
238: 
239: * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
240: * out_database: The result database object.
241: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
242: */
243: DUCKDB_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);
244: 
245: /*!
246: Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the the given path.
247: 
248: * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
249: * out_database: The result database object.
250: * config: (Optional) configuration used to start up the database system.
251: * out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.
252: Note that the error must be freed using `duckdb_free`.
253: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
254: */
255: DUCKDB_API duckdb_state duckdb_open_ext(const char *path, duckdb_database *out_database, duckdb_config config,
256:                                         char **out_error);
257: 
258: /*!
259: Closes the specified database and de-allocates all memory allocated for that database.
260: This should be called after you are done with any database allocated through `duckdb_open`.
261: Note that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.
262: Still it is recommended to always correctly close a database object after you are done with it.
263: 
264: * database: The database object to shut down.
265: */
266: DUCKDB_API void duckdb_close(duckdb_database *database);
267: 
268: /*!
269: Opens a connection to a database. Connections are required to query the database, and store transactional state
270: associated with the connection.
271: 
272: * database: The database file to connect to.
273: * out_connection: The result connection object.
274: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
275: */
276: DUCKDB_API duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out_connection);
277: 
278: /*!
279: Closes the specified connection and de-allocates all memory allocated for that connection.
280: 
281: * connection: The connection to close.
282: */
283: DUCKDB_API void duckdb_disconnect(duckdb_connection *connection);
284: 
285: //===--------------------------------------------------------------------===//
286: // Configuration
287: //===--------------------------------------------------------------------===//
288: /*!
289: Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance
290: through `duckdb_open_ext`.
291: 
292: This will always succeed unless there is a malloc failure.
293: 
294: * out_config: The result configuration object.
295: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
296: */
297: DUCKDB_API duckdb_state duckdb_create_config(duckdb_config *out_config);
298: 
299: /*!
300: This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.
301: 
302: This should not be called in a loop as it internally loops over all the options.
303: 
304: * returns: The amount of config options available.
305: */
306: DUCKDB_API size_t duckdb_config_count();
307: 
308: /*!
309: Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.
310: display configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).
311: 
312: The result name or description MUST NOT be freed.
313: 
314: * index: The index of the configuration option (between 0 and `duckdb_config_count`)
315: * out_name: A name of the configuration flag.
316: * out_description: A description of the configuration flag.
317: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
318: */
319: DUCKDB_API duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description);
320: 
321: /*!
322: Sets the specified option for the specified configuration. The configuration option is indicated by name.
323: To obtain a list of config options, see `duckdb_get_config_flag`.
324: 
325: In the source code, configuration options are defined in `config.cpp`.
326: 
327: This can fail if either the name is invalid, or if the value provided for the option is invalid.
328: 
329: * duckdb_config: The configuration object to set the option on.
330: * name: The name of the configuration flag to set.
331: * option: The value to set the configuration flag to.
332: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
333: */
334: DUCKDB_API duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option);
335: 
336: /*!
337: Destroys the specified configuration option and de-allocates all memory allocated for the object.
338: 
339: * config: The configuration object to destroy.
340: */
341: DUCKDB_API void duckdb_destroy_config(duckdb_config *config);
342: 
343: //===--------------------------------------------------------------------===//
344: // Query Execution
345: //===--------------------------------------------------------------------===//
346: /*!
347: Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.
348: If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
349: `duckdb_result_error`.
350: 
351: Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the
352: query fails, otherwise the error stored within the result will not be freed correctly.
353: 
354: * connection: The connection to perform the query in.
355: * query: The SQL query to run.
356: * out_result: The query result.
357: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
358: */
359: DUCKDB_API duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out_result);
360: 
361: /*!
362: Closes the result and de-allocates all memory allocated for that connection.
363: 
364: * result: The result to destroy.
365: */
366: DUCKDB_API void duckdb_destroy_result(duckdb_result *result);
367: 
368: /*!
369: Returns the column name of the specified column. The result should not need be freed; the column names will
370: automatically be destroyed when the result is destroyed.
371: 
372: Returns `NULL` if the column is out of range.
373: 
374: * result: The result object to fetch the column name from.
375: * col: The column index.
376: * returns: The column name of the specified column.
377: */
378: DUCKDB_API const char *duckdb_column_name(duckdb_result *result, idx_t col);
379: 
380: /*!
381: Returns the column type of the specified column.
382: 
383: Returns `DUCKDB_TYPE_INVALID` if the column is out of range.
384: 
385: * result: The result object to fetch the column type from.
386: * col: The column index.
387: * returns: The column type of the specified column.
388: */
389: DUCKDB_API duckdb_type duckdb_column_type(duckdb_result *result, idx_t col);
390: 
391: /*!
392: Returns the logical column type of the specified column.
393: 
394: The return type of this call should be destroyed with `duckdb_destroy_logical_type`.
395: 
396: Returns `NULL` if the column is out of range.
397: 
398: * result: The result object to fetch the column type from.
399: * col: The column index.
400: * returns: The logical column type of the specified column.
401: */
402: DUCKDB_API duckdb_logical_type duckdb_column_logical_type(duckdb_result *result, idx_t col);
403: 
404: /*!
405: Returns the number of columns present in a the result object.
406: 
407: * result: The result object.
408: * returns: The number of columns present in the result object.
409: */
410: DUCKDB_API idx_t duckdb_column_count(duckdb_result *result);
411: 
412: /*!
413: Returns the number of rows present in a the result object.
414: 
415: * result: The result object.
416: * returns: The number of rows present in the result object.
417: */
418: DUCKDB_API idx_t duckdb_row_count(duckdb_result *result);
419: 
420: /*!
421: Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE
422: queries. For other queries the rows_changed will be 0.
423: 
424: * result: The result object.
425: * returns: The number of rows changed.
426: */
427: DUCKDB_API idx_t duckdb_rows_changed(duckdb_result *result);
428: 
429: /*!
430: **DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.
431: 
432: Returns the data of a specific column of a result in columnar format.
433: 
434: The function returns a dense array which contains the result data. The exact type stored in the array depends on the
435: corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
436: accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.
437: 
438: For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:
439: ```c
440: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
441: printf("Data for row %d: %d\n", row, data[row]);
442: ```
443: 
444: * result: The result object to fetch the column data from.
445: * col: The column index.
446: * returns: The column data of the specified column.
447: */
448: DUCKDB_API void *duckdb_column_data(duckdb_result *result, idx_t col);
449: 
450: /*!
451: **DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.
452: 
453: Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
454: whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
455: by `duckdb_column_data` are undefined.
456: 
457: ```c
458: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
459: bool *nullmask = duckdb_nullmask_data(&result, 0);
460: if (nullmask[row]) {
461:     printf("Data for row %d: NULL\n", row);
462: } else {
463:     printf("Data for row %d: %d\n", row, data[row]);
464: }
465: ```
466: 
467: * result: The result object to fetch the nullmask from.
468: * col: The column index.
469: * returns: The nullmask of the specified column.
470: */
471: DUCKDB_API bool *duckdb_nullmask_data(duckdb_result *result, idx_t col);
472: 
473: /*!
474: Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.
475: 
476: The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.
477: 
478: * result: The result object to fetch the nullmask from.
479: * returns: The error of the result.
480: */
481: DUCKDB_API const char *duckdb_result_error(duckdb_result *result);
482: 
483: //===--------------------------------------------------------------------===//
484: // Result Functions
485: //===--------------------------------------------------------------------===//
486: 
487: /*!
488: Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.
489: 
490: This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data`
491: functions. It results in significantly better performance, and should be preferred in newer code-bases.
492: 
493: If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be
494: mixed with the legacy result functions).
495: 
496: Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.
497: 
498: * result: The result object to fetch the data chunk from.
499: * chunk_index: The chunk index to fetch from.
500: * returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
501: */
502: DUCKDB_API duckdb_data_chunk duckdb_result_get_chunk(duckdb_result result, idx_t chunk_index);
503: 
504: /*!
505: Returns the number of data chunks present in the result.
506: 
507: * result: The result object
508: * returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
509: */
510: DUCKDB_API idx_t duckdb_result_chunk_count(duckdb_result result);
511: 
512: // Safe fetch functions
513: // These functions will perform conversions if necessary.
514: // On failure (e.g. if conversion cannot be performed or if the value is NULL) a default value is returned.
515: // Note that these functions are slow since they perform bounds checking and conversion
516: // For fast access of values prefer using `duckdb_result_get_chunk`
517: 
518: /*!
519:  * returns: The boolean value at the specified location, or false if the value cannot be converted.
520:  */
521: DUCKDB_API bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row);
522: 
523: /*!
524:  * returns: The int8_t value at the specified location, or 0 if the value cannot be converted.
525:  */
526: DUCKDB_API int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row);
527: 
528: /*!
529:  * returns: The int16_t value at the specified location, or 0 if the value cannot be converted.
530:  */
531: DUCKDB_API int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row);
532: 
533: /*!
534:  * returns: The int32_t value at the specified location, or 0 if the value cannot be converted.
535:  */
536: DUCKDB_API int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row);
537: 
538: /*!
539:  * returns: The int64_t value at the specified location, or 0 if the value cannot be converted.
540:  */
541: DUCKDB_API int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row);
542: 
543: /*!
544:  * returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.
545:  */
546: DUCKDB_API duckdb_hugeint duckdb_value_hugeint(duckdb_result *result, idx_t col, idx_t row);
547: 
548: /*!
549:  * returns: The duckdb_decimal value at the specified location, or 0 if the value cannot be converted.
550:  */
551: DUCKDB_API duckdb_decimal duckdb_value_decimal(duckdb_result *result, idx_t col, idx_t row);
552: 
553: /*!
554:  * returns: The uint8_t value at the specified location, or 0 if the value cannot be converted.
555:  */
556: DUCKDB_API uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row);
557: 
558: /*!
559:  * returns: The uint16_t value at the specified location, or 0 if the value cannot be converted.
560:  */
561: DUCKDB_API uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row);
562: 
563: /*!
564:  * returns: The uint32_t value at the specified location, or 0 if the value cannot be converted.
565:  */
566: DUCKDB_API uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row);
567: 
568: /*!
569:  * returns: The uint64_t value at the specified location, or 0 if the value cannot be converted.
570:  */
571: DUCKDB_API uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row);
572: 
573: /*!
574:  * returns: The float value at the specified location, or 0 if the value cannot be converted.
575:  */
576: DUCKDB_API float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row);
577: 
578: /*!
579:  * returns: The double value at the specified location, or 0 if the value cannot be converted.
580:  */
581: DUCKDB_API double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row);
582: 
583: /*!
584:  * returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted.
585:  */
586: DUCKDB_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);
587: 
588: /*!
589:  * returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted.
590:  */
591: DUCKDB_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);
592: 
593: /*!
594:  * returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.
595:  */
596: DUCKDB_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);
597: 
598: /*!
599:  * returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted.
600:  */
601: DUCKDB_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);
602: 
603: /*!
604: * returns: The char* value at the specified location, or nullptr if the value cannot be converted.
605: The result must be freed with `duckdb_free`.
606: */
607: DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);
608: 
609: /*!
610: * returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
611: If the column is NOT a VARCHAR column this function will return NULL.
612: 
613: The result must NOT be freed.
614: */
615: DUCKDB_API char *duckdb_value_varchar_internal(duckdb_result *result, idx_t col, idx_t row);
616: 
617: /*!
618: * returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the
619: value cannot be converted. The resulting "blob.data" must be freed with `duckdb_free.`
620: */
621: DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);
622: 
623: /*!
624:  * returns: Returns true if the value at the specified index is NULL, and false otherwise.
625:  */
626: DUCKDB_API bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row);
627: 
628: //===--------------------------------------------------------------------===//
629: // Helpers
630: //===--------------------------------------------------------------------===//
631: /*!
632: Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner
633: should be freed using `duckdb_free`.
634: 
635: * size: The number of bytes to allocate.
636: * returns: A pointer to the allocated memory region.
637: */
638: DUCKDB_API void *duckdb_malloc(size_t size);
639: 
640: /*!
641: Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_value_blob`.
642: 
643: * ptr: The memory region to de-allocate.
644: */
645: DUCKDB_API void duckdb_free(void *ptr);
646: 
647: /*!
648: The internal vector size used by DuckDB.
649: This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.
650: 
651: * returns: The vector size.
652: */
653: DUCKDB_API idx_t duckdb_vector_size();
654: 
655: //===--------------------------------------------------------------------===//
656: // Date/Time/Timestamp Helpers
657: //===--------------------------------------------------------------------===//
658: /*!
659: Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).
660: 
661: * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
662: * returns: The `duckdb_date_struct` with the decomposed elements.
663: */
664: DUCKDB_API duckdb_date_struct duckdb_from_date(duckdb_date date);
665: 
666: /*!
667: Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).
668: 
669: * date: The year, month and date stored in a `duckdb_date_struct`.
670: * returns: The `duckdb_date` element.
671: */
672: DUCKDB_API duckdb_date duckdb_to_date(duckdb_date_struct date);
673: 
674: /*!
675: Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).
676: 
677: * time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.
678: * returns: The `duckdb_time_struct` with the decomposed elements.
679: */
680: DUCKDB_API duckdb_time_struct duckdb_from_time(duckdb_time time);
681: 
682: /*!
683: Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).
684: 
685: * time: The hour, minute, second and microsecond in a `duckdb_time_struct`.
686: * returns: The `duckdb_time` element.
687: */
688: DUCKDB_API duckdb_time duckdb_to_time(duckdb_time_struct time);
689: 
690: /*!
691: Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.
692: 
693: * ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
694: * returns: The `duckdb_timestamp_struct` with the decomposed elements.
695: */
696: DUCKDB_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts);
697: 
698: /*!
699: Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.
700: 
701: * ts: The de-composed elements in a `duckdb_timestamp_struct`.
702: * returns: The `duckdb_timestamp` element.
703: */
704: DUCKDB_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts);
705: 
706: //===--------------------------------------------------------------------===//
707: // Hugeint Helpers
708: //===--------------------------------------------------------------------===//
709: /*!
710: Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.
711: 
712: * val: The hugeint value.
713: * returns: The converted `double` element.
714: */
715: DUCKDB_API double duckdb_hugeint_to_double(duckdb_hugeint val);
716: 
717: /*!
718: Converts a double value to a duckdb_hugeint object.
719: 
720: If the conversion fails because the double value is too big the result will be 0.
721: 
722: * val: The double value.
723: * returns: The converted `duckdb_hugeint` element.
724: */
725: DUCKDB_API duckdb_hugeint duckdb_double_to_hugeint(double val);
726: 
727: //===--------------------------------------------------------------------===//
728: // Decimal Helpers
729: //===--------------------------------------------------------------------===//
730: /*!
731: Converts a duckdb_decimal object (as obtained from a `DUCKDB_TYPE_DECIMAL` column) into a double.
732: 
733: * val: The decimal value.
734: * returns: The converted `double` element.
735: */
736: DUCKDB_API double duckdb_decimal_to_double(duckdb_decimal val);
737: 
738: //===--------------------------------------------------------------------===//
739: // Prepared Statements
740: //===--------------------------------------------------------------------===//
741: // A prepared statement is a parameterized query that allows you to bind parameters to it.
742: // * This is useful to easily supply parameters to functions and avoid SQL injection attacks.
743: // * This is useful to speed up queries that you will execute several times with different parameters.
744: // Because the query will only be parsed, bound, optimized and planned once during the prepare stage,
745: // rather than once per execution.
746: // For example:
747: //   SELECT * FROM tbl WHERE id=?
748: // Or a query with multiple parameters:
749: //   SELECT * FROM tbl WHERE id=$1 OR name=$2
750: 
751: /*!
752: Create a prepared statement object from a query.
753: 
754: Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using
755: `duckdb_destroy_prepare`, even if the prepare fails.
756: 
757: If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
758: 
759: * connection: The connection object
760: * query: The SQL query to prepare
761: * out_prepared_statement: The resulting prepared statement object
762: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
763: */
764: DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
765:                                        duckdb_prepared_statement *out_prepared_statement);
766: 
767: /*!
768: Closes the prepared statement and de-allocates all memory allocated for the statement.
769: 
770: * prepared_statement: The prepared statement to destroy.
771: */
772: DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);
773: 
774: /*!
775: Returns the error message associated with the given prepared statement.
776: If the prepared statement has no error message, this returns `nullptr` instead.
777: 
778: The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.
779: 
780: * prepared_statement: The prepared statement to obtain the error from.
781: * returns: The error message, or `nullptr` if there is none.
782: */
783: DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);
784: 
785: /*!
786: Returns the number of parameters that can be provided to the given prepared statement.
787: 
788: Returns 0 if the query was not successfully prepared.
789: 
790: * prepared_statement: The prepared statement to obtain the number of parameters for.
791: */
792: DUCKDB_API idx_t duckdb_nparams(duckdb_prepared_statement prepared_statement);
793: 
794: /*!
795: Returns the parameter type for the parameter at the given index.
796: 
797: Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.
798: 
799: * prepared_statement: The prepared statement.
800: * param_idx: The parameter index.
801: * returns: The parameter type
802: */
803: DUCKDB_API duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_t param_idx);
804: 
805: /*!
806: Binds a bool value to the prepared statement at the specified index.
807: */
808: DUCKDB_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);
809: 
810: /*!
811: Binds an int8_t value to the prepared statement at the specified index.
812: */
813: DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
814: 
815: /*!
816: Binds an int16_t value to the prepared statement at the specified index.
817: */
818: DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
819: 
820: /*!
821: Binds an int32_t value to the prepared statement at the specified index.
822: */
823: DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);
824: 
825: /*!
826: Binds an int64_t value to the prepared statement at the specified index.
827: */
828: DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);
829: 
830: /*!
831: Binds an duckdb_hugeint value to the prepared statement at the specified index.
832: */
833: DUCKDB_API duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,
834:                                             duckdb_hugeint val);
835: 
836: /*!
837: Binds an uint8_t value to the prepared statement at the specified index.
838: */
839: DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);
840: 
841: /*!
842: Binds an uint16_t value to the prepared statement at the specified index.
843: */
844: DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val);
845: 
846: /*!
847: Binds an uint32_t value to the prepared statement at the specified index.
848: */
849: DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);
850: 
851: /*!
852: Binds an uint64_t value to the prepared statement at the specified index.
853: */
854: DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);
855: 
856: /*!
857: Binds an float value to the prepared statement at the specified index.
858: */
859: DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);
860: 
861: /*!
862: Binds an double value to the prepared statement at the specified index.
863: */
864: DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);
865: 
866: /*!
867: Binds a duckdb_date value to the prepared statement at the specified index.
868: */
869: DUCKDB_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,
870:                                          duckdb_date val);
871: 
872: /*!
873: Binds a duckdb_time value to the prepared statement at the specified index.
874: */
875: DUCKDB_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,
876:                                          duckdb_time val);
877: 
878: /*!
879: Binds a duckdb_timestamp value to the prepared statement at the specified index.
880: */
881: DUCKDB_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,
882:                                               duckdb_timestamp val);
883: 
884: /*!
885: Binds a duckdb_interval value to the prepared statement at the specified index.
886: */
887: DUCKDB_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,
888:                                              duckdb_interval val);
889: 
890: /*!
891: Binds a null-terminated varchar value to the prepared statement at the specified index.
892: */
893: DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,
894:                                             const char *val);
895: 
896: /*!
897: Binds a varchar value to the prepared statement at the specified index.
898: */
899: DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,
900:                                                    const char *val, idx_t length);
901: 
902: /*!
903: Binds a blob value to the prepared statement at the specified index.
904: */
905: DUCKDB_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,
906:                                          const void *data, idx_t length);
907: 
908: /*!
909: Binds a NULL value to the prepared statement at the specified index.
910: */
911: DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);
912: 
913: /*!
914: Executes the prepared statement with the given bound parameters, and returns a materialized query result.
915: 
916: This method can be called multiple times for each prepared statement, and the parameters can be modified
917: between calls to this function.
918: 
919: * prepared_statement: The prepared statement to execute.
920: * out_result: The query result.
921: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
922: */
923: DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,
924:                                                 duckdb_result *out_result);
925: 
926: /*!
927: Executes the prepared statement with the given bound parameters, and returns an arrow query result.
928: 
929: * prepared_statement: The prepared statement to execute.
930: * out_result: The query result.
931: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
932: */
933: DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,
934:                                                       duckdb_arrow *out_result);
935: 
936: //===--------------------------------------------------------------------===//
937: // Value Interface
938: //===--------------------------------------------------------------------===//
939: /*!
940: Destroys the value and de-allocates all memory allocated for that type.
941: 
942: * value: The value to destroy.
943: */
944: DUCKDB_API void duckdb_destroy_value(duckdb_value *value);
945: 
946: /*!
947: Creates a value from a null-terminated string
948: 
949: * value: The null-terminated string
950: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
951: */
952: DUCKDB_API duckdb_value duckdb_create_varchar(const char *text);
953: 
954: /*!
955: Creates a value from a string
956: 
957: * value: The text
958: * length: The length of the text
959: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
960: */
961: DUCKDB_API duckdb_value duckdb_create_varchar_length(const char *text, idx_t length);
962: 
963: /*!
964: Creates a value from an int64
965: 
966: * value: The bigint value
967: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
968: */
969: DUCKDB_API duckdb_value duckdb_create_int64(int64_t val);
970: 
971: /*!
972: Obtains a string representation of the given value.
973: The result must be destroyed with `duckdb_free`.
974: 
975: * value: The value
976: * returns: The string value. This must be destroyed with `duckdb_free`.
977: */
978: DUCKDB_API char *duckdb_get_varchar(duckdb_value value);
979: 
980: /*!
981: Obtains an int64 of the given value.
982: 
983: * value: The value
984: * returns: The int64 value, or 0 if no conversion is possible
985: */
986: DUCKDB_API int64_t duckdb_get_int64(duckdb_value value);
987: 
988: //===--------------------------------------------------------------------===//
989: // Logical Type Interface
990: //===--------------------------------------------------------------------===//
991: 
992: /*!
993: Creates a `duckdb_logical_type` from a standard primitive type.
994: The resulting type should be destroyed with `duckdb_destroy_logical_type`.
995: 
996: This should not be used with `DUCKDB_TYPE_DECIMAL`.
997: 
998: * type: The primitive type to create.
999: * returns: The logical type.
1000: */
1001: DUCKDB_API duckdb_logical_type duckdb_create_logical_type(duckdb_type type);
1002: 
1003: /*!
1004: Creates a list type from its child type.
1005: The resulting type should be destroyed with `duckdb_destroy_logical_type`.
1006: 
1007: * type: The child type of list type to create.
1008: * returns: The logical type.
1009: */
1010: DUCKDB_API duckdb_logical_type duckdb_create_list_type(duckdb_logical_type type);
1011: 
1012: /*!
1013: Creates a map type from its key type and value type.
1014: The resulting type should be destroyed with `duckdb_destroy_logical_type`.
1015: 
1016: * type: The key type and value type of map type to create.
1017: * returns: The logical type.
1018: */
1019: DUCKDB_API duckdb_logical_type duckdb_create_map_type(duckdb_logical_type key_type, duckdb_logical_type value_type);
1020: 
1021: /*!
1022: Creates a `duckdb_logical_type` of type decimal with the specified width and scale
1023: The resulting type should be destroyed with `duckdb_destroy_logical_type`.
1024: 
1025: * width: The width of the decimal type
1026: * scale: The scale of the decimal type
1027: * returns: The logical type.
1028: */
1029: DUCKDB_API duckdb_logical_type duckdb_create_decimal_type(uint8_t width, uint8_t scale);
1030: 
1031: /*!
1032: Retrieves the type class of a `duckdb_logical_type`.
1033: 
1034: * type: The logical type object
1035: * returns: The type id
1036: */
1037: DUCKDB_API duckdb_type duckdb_get_type_id(duckdb_logical_type type);
1038: 
1039: /*!
1040: Retrieves the width of a decimal type.
1041: 
1042: * type: The logical type object
1043: * returns: The width of the decimal type
1044: */
1045: DUCKDB_API uint8_t duckdb_decimal_width(duckdb_logical_type type);
1046: 
1047: /*!
1048: Retrieves the scale of a decimal type.
1049: 
1050: * type: The logical type object
1051: * returns: The scale of the decimal type
1052: */
1053: DUCKDB_API uint8_t duckdb_decimal_scale(duckdb_logical_type type);
1054: 
1055: /*!
1056: Retrieves the internal storage type of a decimal type.
1057: 
1058: * type: The logical type object
1059: * returns: The internal type of the decimal type
1060: */
1061: DUCKDB_API duckdb_type duckdb_decimal_internal_type(duckdb_logical_type type);
1062: 
1063: /*!
1064: Retrieves the internal storage type of an enum type.
1065: 
1066: * type: The logical type object
1067: * returns: The internal type of the enum type
1068: */
1069: DUCKDB_API duckdb_type duckdb_enum_internal_type(duckdb_logical_type type);
1070: 
1071: /*!
1072: Retrieves the dictionary size of the enum type
1073: 
1074: * type: The logical type object
1075: * returns: The dictionary size of the enum type
1076: */
1077: DUCKDB_API uint32_t duckdb_enum_dictionary_size(duckdb_logical_type type);
1078: 
1079: /*!
1080: Retrieves the dictionary value at the specified position from the enum.
1081: 
1082: The result must be freed with `duckdb_free`
1083: 
1084: * type: The logical type object
1085: * index: The index in the dictionary
1086: * returns: The string value of the enum type. Must be freed with `duckdb_free`.
1087: */
1088: DUCKDB_API char *duckdb_enum_dictionary_value(duckdb_logical_type type, idx_t index);
1089: 
1090: /*!
1091: Retrieves the child type of the given list type.
1092: 
1093: The result must be freed with `duckdb_destroy_logical_type`
1094: 
1095: * type: The logical type object
1096: * returns: The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`.
1097: */
1098: DUCKDB_API duckdb_logical_type duckdb_list_type_child_type(duckdb_logical_type type);
1099: 
1100: /*!
1101: Retrieves the key type of the given map type.
1102: 
1103: The result must be freed with `duckdb_destroy_logical_type`
1104: 
1105: * type: The logical type object
1106: * returns: The key type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.
1107: */
1108: DUCKDB_API duckdb_logical_type duckdb_map_type_key_type(duckdb_logical_type type);
1109: 
1110: /*!
1111: Retrieves the value type of the given map type.
1112: 
1113: The result must be freed with `duckdb_destroy_logical_type`
1114: 
1115: * type: The logical type object
1116: * returns: The value type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.
1117: */
1118: DUCKDB_API duckdb_logical_type duckdb_map_type_value_type(duckdb_logical_type type);
1119: 
1120: /*!
1121: Returns the number of children of a struct type.
1122: 
1123: * type: The logical type object
1124: * returns: The number of children of a struct type.
1125: */
1126: DUCKDB_API idx_t duckdb_struct_type_child_count(duckdb_logical_type type);
1127: 
1128: /*!
1129: Retrieves the name of the struct child.
1130: 
1131: The result must be freed with `duckdb_free`
1132: 
1133: * type: The logical type object
1134: * index: The child index
1135: * returns: The name of the struct type. Must be freed with `duckdb_free`.
1136: */
1137: DUCKDB_API char *duckdb_struct_type_child_name(duckdb_logical_type type, idx_t index);
1138: 
1139: /*!
1140: Retrieves the child type of the given struct type at the specified index.
1141: 
1142: The result must be freed with `duckdb_destroy_logical_type`
1143: 
1144: * type: The logical type object
1145: * index: The child index
1146: * returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.
1147: */
1148: DUCKDB_API duckdb_logical_type duckdb_struct_type_child_type(duckdb_logical_type type, idx_t index);
1149: 
1150: /*!
1151: Destroys the logical type and de-allocates all memory allocated for that type.
1152: 
1153: * type: The logical type to destroy.
1154: */
1155: DUCKDB_API void duckdb_destroy_logical_type(duckdb_logical_type *type);
1156: 
1157: //===--------------------------------------------------------------------===//
1158: // Data Chunk Interface
1159: //===--------------------------------------------------------------------===//
1160: /*!
1161: Creates an empty DataChunk with the specified set of types.
1162: 
1163: * types: An array of types of the data chunk.
1164: * column_count: The number of columns.
1165: * returns: The data chunk.
1166: */
1167: DUCKDB_API duckdb_data_chunk duckdb_create_data_chunk(duckdb_logical_type *types, idx_t column_count);
1168: 
1169: /*!
1170: Destroys the data chunk and de-allocates all memory allocated for that chunk.
1171: 
1172: * chunk: The data chunk to destroy.
1173: */
1174: DUCKDB_API void duckdb_destroy_data_chunk(duckdb_data_chunk *chunk);
1175: 
1176: /*!
1177: Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.
1178: 
1179: * chunk: The data chunk to reset.
1180: */
1181: DUCKDB_API void duckdb_data_chunk_reset(duckdb_data_chunk chunk);
1182: 
1183: /*!
1184: Retrieves the number of columns in a data chunk.
1185: 
1186: * chunk: The data chunk to get the data from
1187: * returns: The number of columns in the data chunk
1188: */
1189: DUCKDB_API idx_t duckdb_data_chunk_get_column_count(duckdb_data_chunk chunk);
1190: 
1191: /*!
1192: Retrieves the vector at the specified column index in the data chunk.
1193: 
1194: The pointer to the vector is valid for as long as the chunk is alive.
1195: It does NOT need to be destroyed.
1196: 
1197: * chunk: The data chunk to get the data from
1198: * returns: The vector
1199: */
1200: DUCKDB_API duckdb_vector duckdb_data_chunk_get_vector(duckdb_data_chunk chunk, idx_t col_idx);
1201: 
1202: /*!
1203: Retrieves the current number of tuples in a data chunk.
1204: 
1205: * chunk: The data chunk to get the data from
1206: * returns: The number of tuples in the data chunk
1207: */
1208: DUCKDB_API idx_t duckdb_data_chunk_get_size(duckdb_data_chunk chunk);
1209: 
1210: /*!
1211: Sets the current number of tuples in a data chunk.
1212: 
1213: * chunk: The data chunk to set the size in
1214: * size: The number of tuples in the data chunk
1215: */
1216: DUCKDB_API void duckdb_data_chunk_set_size(duckdb_data_chunk chunk, idx_t size);
1217: 
1218: //===--------------------------------------------------------------------===//
1219: // Vector Interface
1220: //===--------------------------------------------------------------------===//
1221: /*!
1222: Retrieves the column type of the specified vector.
1223: 
1224: The result must be destroyed with `duckdb_destroy_logical_type`.
1225: 
1226: * vector: The vector get the data from
1227: * returns: The type of the vector
1228: */
1229: DUCKDB_API duckdb_logical_type duckdb_vector_get_column_type(duckdb_vector vector);
1230: 
1231: /*!
1232: Retrieves the data pointer of the vector.
1233: 
1234: The data pointer can be used to read or write values from the vector.
1235: How to read or write values depends on the type of the vector.
1236: 
1237: * vector: The vector to get the data from
1238: * returns: The data pointer
1239: */
1240: DUCKDB_API void *duckdb_vector_get_data(duckdb_vector vector);
1241: 
1242: /*!
1243: Retrieves the validity mask pointer of the specified vector.
1244: 
1245: If all values are valid, this function MIGHT return NULL!
1246: 
1247: The validity mask is a bitset that signifies null-ness within the data chunk.
1248: It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.
1249: The bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).
1250: 
1251: Validity of a specific value can be obtained like this:
1252: 
1253: idx_t entry_idx = row_idx / 64;
1254: idx_t idx_in_entry = row_idx % 64;
1255: bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);
1256: 
1257: Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.
1258: 
1259: * vector: The vector to get the data from
1260: * returns: The pointer to the validity mask, or NULL if no validity mask is present
1261: */
1262: DUCKDB_API uint64_t *duckdb_vector_get_validity(duckdb_vector vector);
1263: 
1264: /*!
1265: Ensures the validity mask is writable by allocating it.
1266: 
1267: After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.
1268: This allows null values to be written to the vector, regardless of whether a validity mask was present before.
1269: 
1270: * vector: The vector to alter
1271: */
1272: DUCKDB_API void duckdb_vector_ensure_validity_writable(duckdb_vector vector);
1273: 
1274: /*!
1275: Assigns a string element in the vector at the specified location.
1276: 
1277: * vector: The vector to alter
1278: * index: The row position in the vector to assign the string to
1279: * str: The null-terminated string
1280: */
1281: DUCKDB_API void duckdb_vector_assign_string_element(duckdb_vector vector, idx_t index, const char *str);
1282: 
1283: /*!
1284: Assigns a string element in the vector at the specified location.
1285: 
1286: * vector: The vector to alter
1287: * index: The row position in the vector to assign the string to
1288: * str: The string
1289: * str_len: The length of the string (in bytes)
1290: */
1291: DUCKDB_API void duckdb_vector_assign_string_element_len(duckdb_vector vector, idx_t index, const char *str,
1292:                                                         idx_t str_len);
1293: 
1294: /*!
1295: Retrieves the child vector of a list vector.
1296: 
1297: The resulting vector is valid as long as the parent vector is valid.
1298: 
1299: * vector: The vector
1300: * returns: The child vector
1301: */
1302: DUCKDB_API duckdb_vector duckdb_list_vector_get_child(duckdb_vector vector);
1303: 
1304: /*!
1305: Returns the size of the child vector of the list
1306: 
1307: * vector: The vector
1308: * returns: The size of the child list
1309: */
1310: DUCKDB_API idx_t duckdb_list_vector_get_size(duckdb_vector vector);
1311: 
1312: /*!
1313: Retrieves the child vector of a struct vector.
1314: 
1315: The resulting vector is valid as long as the parent vector is valid.
1316: 
1317: * vector: The vector
1318: * index: The child index
1319: * returns: The child vector
1320: */
1321: DUCKDB_API duckdb_vector duckdb_struct_vector_get_child(duckdb_vector vector, idx_t index);
1322: 
1323: //===--------------------------------------------------------------------===//
1324: // Validity Mask Functions
1325: //===--------------------------------------------------------------------===//
1326: /*!
1327: Returns whether or not a row is valid (i.e. not NULL) in the given validity mask.
1328: 
1329: * validity: The validity mask, as obtained through `duckdb_data_chunk_get_validity`
1330: * row: The row index
1331: * returns: true if the row is valid, false otherwise
1332: */
1333: DUCKDB_API bool duckdb_validity_row_is_valid(uint64_t *validity, idx_t row);
1334: 
1335: /*!
1336: In a validity mask, sets a specific row to either valid or invalid.
1337: 
1338: Note that `duckdb_data_chunk_ensure_validity_writable` should be called before calling `duckdb_data_chunk_get_validity`,
1339: to ensure that there is a validity mask to write to.
1340: 
1341: * validity: The validity mask, as obtained through `duckdb_data_chunk_get_validity`.
1342: * row: The row index
1343: * valid: Whether or not to set the row to valid, or invalid
1344: */
1345: DUCKDB_API void duckdb_validity_set_row_validity(uint64_t *validity, idx_t row, bool valid);
1346: 
1347: /*!
1348: In a validity mask, sets a specific row to invalid.
1349: 
1350: Equivalent to `duckdb_validity_set_row_validity` with valid set to false.
1351: 
1352: * validity: The validity mask
1353: * row: The row index
1354: */
1355: DUCKDB_API void duckdb_validity_set_row_invalid(uint64_t *validity, idx_t row);
1356: 
1357: /*!
1358: In a validity mask, sets a specific row to valid.
1359: 
1360: Equivalent to `duckdb_validity_set_row_validity` with valid set to true.
1361: 
1362: * validity: The validity mask
1363: * row: The row index
1364: */
1365: DUCKDB_API void duckdb_validity_set_row_valid(uint64_t *validity, idx_t row);
1366: 
1367: //===--------------------------------------------------------------------===//
1368: // Table Functions
1369: //===--------------------------------------------------------------------===//
1370: typedef void *duckdb_table_function;
1371: typedef void *duckdb_bind_info;
1372: typedef void *duckdb_init_info;
1373: typedef void *duckdb_function_info;
1374: 
1375: typedef void (*duckdb_table_function_bind_t)(duckdb_bind_info info);
1376: typedef void (*duckdb_table_function_init_t)(duckdb_init_info info);
1377: typedef void (*duckdb_table_function_t)(duckdb_function_info info, duckdb_data_chunk output);
1378: typedef void (*duckdb_delete_callback_t)(void *data);
1379: 
1380: /*!
1381: Creates a new empty table function.
1382: 
1383: The return value should be destroyed with `duckdb_destroy_table_function`.
1384: 
1385: * returns: The table function object.
1386: */
1387: DUCKDB_API duckdb_table_function duckdb_create_table_function();
1388: 
1389: /*!
1390: Destroys the given table function object.
1391: 
1392: * table_function: The table function to destroy
1393: */
1394: DUCKDB_API void duckdb_destroy_table_function(duckdb_table_function *table_function);
1395: 
1396: /*!
1397: Sets the name of the given table function.
1398: 
1399: * table_function: The table function
1400: * name: The name of the table function
1401: */
1402: DUCKDB_API void duckdb_table_function_set_name(duckdb_table_function table_function, const char *name);
1403: 
1404: /*!
1405: Adds a parameter to the table function.
1406: 
1407: * table_function: The table function
1408: * type: The type of the parameter to add.
1409: */
1410: DUCKDB_API void duckdb_table_function_add_parameter(duckdb_table_function table_function, duckdb_logical_type type);
1411: 
1412: /*!
1413: Assigns extra information to the table function that can be fetched during binding, etc.
1414: 
1415: * table_function: The table function
1416: * extra_info: The extra information
1417: * destroy: The callback that will be called to destroy the bind data (if any)
1418: */
1419: DUCKDB_API void duckdb_table_function_set_extra_info(duckdb_table_function table_function, void *extra_info,
1420:                                                      duckdb_delete_callback_t destroy);
1421: 
1422: /*!
1423: Sets the bind function of the table function
1424: 
1425: * table_function: The table function
1426: * bind: The bind function
1427: */
1428: DUCKDB_API void duckdb_table_function_set_bind(duckdb_table_function table_function, duckdb_table_function_bind_t bind);
1429: 
1430: /*!
1431: Sets the init function of the table function
1432: 
1433: * table_function: The table function
1434: * init: The init function
1435: */
1436: DUCKDB_API void duckdb_table_function_set_init(duckdb_table_function table_function, duckdb_table_function_init_t init);
1437: 
1438: /*!
1439: Sets the main function of the table function
1440: 
1441: * table_function: The table function
1442: * function: The function
1443: */
1444: DUCKDB_API void duckdb_table_function_set_function(duckdb_table_function table_function,
1445:                                                    duckdb_table_function_t function);
1446: 
1447: /*!
1448: Sets whether or not the given table function supports projection pushdown.
1449: 
1450: If this is set to true, the system will provide a list of all required columns in the `init` stage through
1451: the `duckdb_init_get_column_count` and `duckdb_init_get_column_index` functions.
1452: If this is set to false (the default), the system will expect all columns to be projected.
1453: 
1454: * table_function: The table function
1455: * pushdown: True if the table function supports projection pushdown, false otherwise.
1456: */
1457: DUCKDB_API void duckdb_table_function_supports_projection_pushdown(duckdb_table_function table_function, bool pushdown);
1458: 
1459: /*!
1460: Register the table function object within the given connection.
1461: 
1462: The function requires at least a name, a bind function, an init function and a main function.
1463: 
1464: If the function is incomplete or a function with this name already exists DuckDBError is returned.
1465: 
1466: * con: The connection to register it in.
1467: * function: The function pointer
1468: * returns: Whether or not the registration was successful.
1469: */
1470: DUCKDB_API duckdb_state duckdb_register_table_function(duckdb_connection con, duckdb_table_function function);
1471: 
1472: //===--------------------------------------------------------------------===//
1473: // Table Function Bind
1474: //===--------------------------------------------------------------------===//
1475: /*!
1476: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
1477: 
1478: * info: The info object
1479: * returns: The extra info
1480: */
1481: DUCKDB_API void *duckdb_bind_get_extra_info(duckdb_bind_info info);
1482: 
1483: /*!
1484: Adds a result column to the output of the table function.
1485: 
1486: * info: The info object
1487: * name: The name of the column
1488: * type: The logical type of the column
1489: */
1490: DUCKDB_API void duckdb_bind_add_result_column(duckdb_bind_info info, const char *name, duckdb_logical_type type);
1491: 
1492: /*!
1493: Retrieves the number of regular (non-named) parameters to the function.
1494: 
1495: * info: The info object
1496: * returns: The number of parameters
1497: */
1498: DUCKDB_API idx_t duckdb_bind_get_parameter_count(duckdb_bind_info info);
1499: 
1500: /*!
1501: Retrieves the parameter at the given index.
1502: 
1503: The result must be destroyed with `duckdb_destroy_value`.
1504: 
1505: * info: The info object
1506: * index: The index of the parameter to get
1507: * returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
1508: */
1509: DUCKDB_API duckdb_value duckdb_bind_get_parameter(duckdb_bind_info info, idx_t index);
1510: 
1511: /*!
1512: Sets the user-provided bind data in the bind object. This object can be retrieved again during execution.
1513: 
1514: * info: The info object
1515: * extra_data: The bind data object.
1516: * destroy: The callback that will be called to destroy the bind data (if any)
1517: */
1518: DUCKDB_API void duckdb_bind_set_bind_data(duckdb_bind_info info, void *bind_data, duckdb_delete_callback_t destroy);
1519: 
1520: /*!
1521: Report that an error has occurred while calling bind.
1522: 
1523: * info: The info object
1524: * error: The error message
1525: */
1526: DUCKDB_API void duckdb_bind_set_error(duckdb_bind_info info, const char *error);
1527: 
1528: //===--------------------------------------------------------------------===//
1529: // Table Function Init
1530: //===--------------------------------------------------------------------===//
1531: 
1532: /*!
1533: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
1534: 
1535: * info: The info object
1536: * returns: The extra info
1537: */
1538: DUCKDB_API void *duckdb_init_get_extra_info(duckdb_init_info info);
1539: 
1540: /*!
1541: Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
1542: 
1543: Note that the bind data should be considered as read-only.
1544: For tracking state, use the init data instead.
1545: 
1546: * info: The info object
1547: * returns: The bind data object
1548: */
1549: DUCKDB_API void *duckdb_init_get_bind_data(duckdb_init_info info);
1550: 
1551: /*!
1552: Sets the user-provided init data in the init object. This object can be retrieved again during execution.
1553: 
1554: * info: The info object
1555: * extra_data: The init data object.
1556: * destroy: The callback that will be called to destroy the init data (if any)
1557: */
1558: DUCKDB_API void duckdb_init_set_init_data(duckdb_init_info info, void *init_data, duckdb_delete_callback_t destroy);
1559: 
1560: /*!
1561: Returns the number of projected columns.
1562: 
1563: This function must be used if projection pushdown is enabled to figure out which columns to emit.
1564: 
1565: * info: The info object
1566: * returns: The number of projected columns.
1567: */
1568: DUCKDB_API idx_t duckdb_init_get_column_count(duckdb_init_info info);
1569: 
1570: /*!
1571: Returns the column index of the projected column at the specified position.
1572: 
1573: This function must be used if projection pushdown is enabled to figure out which columns to emit.
1574: 
1575: * info: The info object
1576: * column_index: The index at which to get the projected column index, from 0..duckdb_init_get_column_count(info)
1577: * returns: The column index of the projected column.
1578: */
1579: DUCKDB_API idx_t duckdb_init_get_column_index(duckdb_init_info info, idx_t column_index);
1580: 
1581: /*!
1582: Report that an error has occurred while calling init.
1583: 
1584: * info: The info object
1585: * error: The error message
1586: */
1587: DUCKDB_API void duckdb_init_set_error(duckdb_init_info info, const char *error);
1588: 
1589: //===--------------------------------------------------------------------===//
1590: // Table Function
1591: //===--------------------------------------------------------------------===//
1592: 
1593: /*!
1594: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
1595: 
1596: * info: The info object
1597: * returns: The extra info
1598: */
1599: DUCKDB_API void *duckdb_function_get_extra_info(duckdb_function_info info);
1600: /*!
1601: Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
1602: 
1603: Note that the bind data should be considered as read-only.
1604: For tracking state, use the init data instead.
1605: 
1606: * info: The info object
1607: * returns: The bind data object
1608: */
1609: DUCKDB_API void *duckdb_function_get_bind_data(duckdb_function_info info);
1610: 
1611: /*!
1612: Gets the init data set by `duckdb_bind_set_init_data` during the bind.
1613: 
1614: * info: The info object
1615: * returns: The init data object
1616: */
1617: DUCKDB_API void *duckdb_function_get_init_data(duckdb_function_info info);
1618: 
1619: /*!
1620: Report that an error has occurred while executing the function.
1621: 
1622: * info: The info object
1623: * error: The error message
1624: */
1625: DUCKDB_API void duckdb_function_set_error(duckdb_function_info info, const char *error);
1626: 
1627: //===--------------------------------------------------------------------===//
1628: // Replacement Scans
1629: //===--------------------------------------------------------------------===//
1630: typedef void *duckdb_replacement_scan_info;
1631: 
1632: typedef void (*duckdb_replacement_callback_t)(duckdb_replacement_scan_info info, const char *table_name, void *data);
1633: 
1634: /*!
1635: Add a replacement scan definition to the specified database
1636: 
1637: * db: The database object to add the replacement scan to
1638: * replacement: The replacement scan callback
1639: * extra_data: Extra data that is passed back into the specified callback
1640: * delete_callback: The delete callback to call on the extra data, if any
1641: */
1642: DUCKDB_API void duckdb_add_replacement_scan(duckdb_database db, duckdb_replacement_callback_t replacement,
1643:                                             void *extra_data, duckdb_delete_callback_t delete_callback);
1644: 
1645: /*!
1646: Sets the replacement function name to use. If this function is called in the replacement callback,
1647:  the replacement scan is performed. If it is not called, the replacement callback is not performed.
1648: 
1649: * info: The info object
1650: * function_name: The function name to substitute.
1651: */
1652: DUCKDB_API void duckdb_replacement_scan_set_function_name(duckdb_replacement_scan_info info, const char *function_name);
1653: 
1654: /*!
1655: Adds a parameter to the replacement scan function.
1656: 
1657: * info: The info object
1658: * parameter: The parameter to add.
1659: */
1660: DUCKDB_API void duckdb_replacement_scan_add_parameter(duckdb_replacement_scan_info info, duckdb_value parameter);
1661: 
1662: //===--------------------------------------------------------------------===//
1663: // Appender
1664: //===--------------------------------------------------------------------===//
1665: 
1666: // Appenders are the most efficient way of loading data into DuckDB from within the C interface, and are recommended for
1667: // fast data loading. The appender is much faster than using prepared statements or individual `INSERT INTO` statements.
1668: 
1669: // Appends are made in row-wise format. For every column, a `duckdb_append_[type]` call should be made, after which
1670: // the row should be finished by calling `duckdb_appender_end_row`. After all rows have been appended,
1671: // `duckdb_appender_destroy` should be used to finalize the appender and clean up the resulting memory.
1672: 
1673: // Note that `duckdb_appender_destroy` should always be called on the resulting appender, even if the function returns
1674: // `DuckDBError`.
1675: 
1676: /*!
1677: Creates an appender object.
1678: 
1679: * connection: The connection context to create the appender in.
1680: * schema: The schema of the table to append to, or `nullptr` for the default schema.
1681: * table: The table name to append to.
1682: * out_appender: The resulting appender object.
1683: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1684: */
1685: DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
1686:                                                duckdb_appender *out_appender);
1687: 
1688: /*!
1689: Returns the error message associated with the given appender.
1690: If the appender has no error message, this returns `nullptr` instead.
1691: 
1692: The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.
1693: 
1694: * appender: The appender to get the error from.
1695: * returns: The error message, or `nullptr` if there is none.
1696: */
1697: DUCKDB_API const char *duckdb_appender_error(duckdb_appender appender);
1698: 
1699: /*!
1700: Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the
1701: base table.
1702: 
1703: This should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you
1704: are done with the appender.
1705: 
1706: * appender: The appender to flush.
1707: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1708: */
1709: DUCKDB_API duckdb_state duckdb_appender_flush(duckdb_appender appender);
1710: 
1711: /*!
1712: Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.
1713: 
1714: This is generally not necessary. Call `duckdb_appender_destroy` instead.
1715: 
1716: * appender: The appender to flush and close.
1717: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1718: */
1719: DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);
1720: 
1721: /*!
1722: Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating
1723: all memory associated with the appender.
1724: 
1725: * appender: The appender to flush, close and destroy.
1726: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1727: */
1728: DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);
1729: 
1730: /*!
1731: A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.
1732: */
1733: DUCKDB_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);
1734: 
1735: /*!
1736: Finish the current row of appends. After end_row is called, the next row can be appended.
1737: 
1738: * appender: The appender.
1739: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1740: */
1741: DUCKDB_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);
1742: 
1743: /*!
1744: Append a bool value to the appender.
1745: */
1746: DUCKDB_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);
1747: 
1748: /*!
1749: Append an int8_t value to the appender.
1750: */
1751: DUCKDB_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);
1752: /*!
1753: Append an int16_t value to the appender.
1754: */
1755: DUCKDB_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);
1756: /*!
1757: Append an int32_t value to the appender.
1758: */
1759: DUCKDB_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);
1760: /*!
1761: Append an int64_t value to the appender.
1762: */
1763: DUCKDB_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);
1764: /*!
1765: Append a duckdb_hugeint value to the appender.
1766: */
1767: DUCKDB_API duckdb_state duckdb_append_hugeint(duckdb_appender appender, duckdb_hugeint value);
1768: 
1769: /*!
1770: Append a uint8_t value to the appender.
1771: */
1772: DUCKDB_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);
1773: /*!
1774: Append a uint16_t value to the appender.
1775: */
1776: DUCKDB_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);
1777: /*!
1778: Append a uint32_t value to the appender.
1779: */
1780: DUCKDB_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);
1781: /*!
1782: Append a uint64_t value to the appender.
1783: */
1784: DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);
1785: 
1786: /*!
1787: Append a float value to the appender.
1788: */
1789: DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);
1790: /*!
1791: Append a double value to the appender.
1792: */
1793: DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);
1794: 
1795: /*!
1796: Append a duckdb_date value to the appender.
1797: */
1798: DUCKDB_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);
1799: /*!
1800: Append a duckdb_time value to the appender.
1801: */
1802: DUCKDB_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);
1803: /*!
1804: Append a duckdb_timestamp value to the appender.
1805: */
1806: DUCKDB_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);
1807: /*!
1808: Append a duckdb_interval value to the appender.
1809: */
1810: DUCKDB_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);
1811: 
1812: /*!
1813: Append a varchar value to the appender.
1814: */
1815: DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);
1816: /*!
1817: Append a varchar value to the appender.
1818: */
1819: DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);
1820: /*!
1821: Append a blob value to the appender.
1822: */
1823: DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);
1824: /*!
1825: Append a NULL value to the appender (of any type).
1826: */
1827: DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);
1828: 
1829: /*!
1830: Appends a pre-filled data chunk to the specified appender.
1831: 
1832: The types of the data chunk must exactly match the types of the table, no casting is performed.
1833: If the types do not match or the appender is in an invalid state, DuckDBError is returned.
1834: If the append is successful, DuckDBSuccess is returned.
1835: 
1836: * appender: The appender to append to.
1837: * chunk: The data chunk to append.
1838: * returns: The return state.
1839: */
1840: DUCKDB_API duckdb_state duckdb_append_data_chunk(duckdb_appender appender, duckdb_data_chunk chunk);
1841: 
1842: //===--------------------------------------------------------------------===//
1843: // Arrow Interface
1844: //===--------------------------------------------------------------------===//
1845: /*!
1846: Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.
1847: If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
1848: `duckdb_query_arrow_error`.
1849: 
1850: Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the
1851: query fails, otherwise the error stored within the result will not be freed correctly.
1852: 
1853: * connection: The connection to perform the query in.
1854: * query: The SQL query to run.
1855: * out_result: The query result.
1856: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1857: */
1858: DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);
1859: 
1860: /*!
1861: Fetch the internal arrow schema from the arrow result.
1862: 
1863: * result: The result to fetch the schema from.
1864: * out_schema: The output schema.
1865: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1866: */
1867: DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);
1868: 
1869: /*!
1870: Fetch an internal arrow array from the arrow result.
1871: 
1872: This function can be called multiple time to get next chunks, which will free the previous out_array.
1873: So consume the out_array before calling this function again.
1874: 
1875: * result: The result to fetch the array from.
1876: * out_array: The output array.
1877: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1878: */
1879: DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);
1880: 
1881: /*!
1882: Returns the number of columns present in a the arrow result object.
1883: 
1884: * result: The result object.
1885: * returns: The number of columns present in the result object.
1886: */
1887: DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);
1888: 
1889: /*!
1890: Returns the number of rows present in a the arrow result object.
1891: 
1892: * result: The result object.
1893: * returns: The number of rows present in the result object.
1894: */
1895: DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);
1896: 
1897: /*!
1898: Returns the number of rows changed by the query stored in the arrow result. This is relevant only for
1899: INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.
1900: 
1901: * result: The result object.
1902: * returns: The number of rows changed.
1903: */
1904: DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);
1905: 
1906: /*!
1907: Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns
1908: `DuckDBError`.
1909: 
1910: The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.
1911: 
1912: * result: The result object to fetch the nullmask from.
1913: * returns: The error of the result.
1914: */
1915: DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);
1916: 
1917: /*!
1918: Closes the result and de-allocates all memory allocated for the arrow result.
1919: 
1920: * result: The result to destroy.
1921: */
1922: DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
1923: 
1924: #ifdef __cplusplus
1925: }
1926: #endif
[end of src/include/duckdb.h]
[start of src/include/duckdb/main/config.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/config.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/allocator.hpp"
12: #include "duckdb/common/case_insensitive_map.hpp"
13: #include "duckdb/common/common.hpp"
14: #include "duckdb/common/enums/order_type.hpp"
15: #include "duckdb/common/file_system.hpp"
16: #include "duckdb/common/winapi.hpp"
17: #include "duckdb/common/types/value.hpp"
18: #include "duckdb/common/vector.hpp"
19: #include "duckdb/function/replacement_scan.hpp"
20: #include "duckdb/common/set.hpp"
21: #include "duckdb/common/enums/compression_type.hpp"
22: #include "duckdb/common/enums/optimizer_type.hpp"
23: #include "duckdb/common/enums/window_aggregation_mode.hpp"
24: #include "duckdb/common/enums/set_scope.hpp"
25: 
26: namespace duckdb {
27: class ClientContext;
28: class TableFunctionRef;
29: class CompressionFunction;
30: 
31: struct CompressionFunctionSet;
32: struct DBConfig;
33: 
34: enum class AccessMode : uint8_t { UNDEFINED = 0, AUTOMATIC = 1, READ_ONLY = 2, READ_WRITE = 3 };
35: 
36: enum class CheckpointAbort : uint8_t {
37: 	NO_ABORT = 0,
38: 	DEBUG_ABORT_BEFORE_TRUNCATE = 1,
39: 	DEBUG_ABORT_BEFORE_HEADER = 2,
40: 	DEBUG_ABORT_AFTER_FREE_LIST_WRITE = 3
41: };
42: 
43: typedef void (*set_global_function_t)(DatabaseInstance *db, DBConfig &config, const Value &parameter);
44: typedef void (*set_local_function_t)(ClientContext &context, const Value &parameter);
45: typedef Value (*get_setting_function_t)(ClientContext &context);
46: 
47: struct ConfigurationOption {
48: 	const char *name;
49: 	const char *description;
50: 	LogicalTypeId parameter_type;
51: 	set_global_function_t set_global;
52: 	set_local_function_t set_local;
53: 	get_setting_function_t get_setting;
54: };
55: 
56: typedef void (*set_option_callback_t)(ClientContext &context, SetScope scope, Value &parameter);
57: 
58: struct ExtensionOption {
59: 	ExtensionOption(string description_p, LogicalType type_p, set_option_callback_t set_function_p)
60: 	    : description(move(description_p)), type(move(type_p)), set_function(set_function_p) {
61: 	}
62: 
63: 	string description;
64: 	LogicalType type;
65: 	set_option_callback_t set_function;
66: };
67: 
68: struct DBConfig {
69: 	friend class DatabaseInstance;
70: 	friend class StorageManager;
71: 
72: public:
73: 	DUCKDB_API DBConfig();
74: 	DUCKDB_API ~DBConfig();
75: 
76: 	//! Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE)
77: 	AccessMode access_mode = AccessMode::AUTOMATIC;
78: 	//! The allocator used by the system
79: 	Allocator allocator;
80: 	// Checkpoint when WAL reaches this size (default: 16MB)
81: 	idx_t checkpoint_wal_size = 1 << 24;
82: 	//! Whether or not to use Direct IO, bypassing operating system buffers
83: 	bool use_direct_io = false;
84: 	//! Whether extensions should be loaded on start-up
85: 	bool load_extensions = true;
86: 	//! The FileSystem to use, can be overwritten to allow for injecting custom file systems for testing purposes (e.g.
87: 	//! RamFS or something similar)
88: 	unique_ptr<FileSystem> file_system;
89: 	//! The maximum memory used by the database system (in bytes). Default: 80% of System available memory
90: 	idx_t maximum_memory = (idx_t)-1;
91: 	//! The maximum amount of CPU threads used by the database system. Default: all available.
92: 	idx_t maximum_threads = (idx_t)-1;
93: 	//! Whether or not to create and use a temporary directory to store intermediates that do not fit in memory
94: 	bool use_temporary_directory = true;
95: 	//! Directory to store temporary structures that do not fit in memory
96: 	string temporary_directory;
97: 	//! The collation type of the database
98: 	string collation = string();
99: 	//! The order type used when none is specified (default: ASC)
100: 	OrderType default_order_type = OrderType::ASCENDING;
101: 	//! Null ordering used when none is specified (default: NULLS FIRST)
102: 	OrderByNullType default_null_order = OrderByNullType::NULLS_FIRST;
103: 	//! enable COPY and related commands
104: 	bool enable_external_access = true;
105: 	//! Whether or not object cache is used
106: 	bool object_cache_enable = false;
107: 	//! Force checkpoint when CHECKPOINT is called or on shutdown, even if no changes have been made
108: 	bool force_checkpoint = false;
109: 	//! Run a checkpoint on successful shutdown and delete the WAL, to leave only a single database file behind
110: 	bool checkpoint_on_shutdown = true;
111: 	//! Debug flag that decides when a checkpoing should be aborted. Only used for testing purposes.
112: 	CheckpointAbort checkpoint_abort = CheckpointAbort::NO_ABORT;
113: 	//! Replacement table scans are automatically attempted when a table name cannot be found in the schema
114: 	vector<ReplacementScan> replacement_scans;
115: 	//! Initialize the database with the standard set of DuckDB functions
116: 	//! You should probably not touch this unless you know what you are doing
117: 	bool initialize_default_database = true;
118: 	//! The set of disabled optimizers (default empty)
119: 	set<OptimizerType> disabled_optimizers;
120: 	//! Force a specific compression method to be used when checkpointing (if available)
121: 	CompressionType force_compression = CompressionType::COMPRESSION_AUTO;
122: 	//! Debug flag that adds additional (unnecessary) free_list blocks to the storage
123: 	bool debug_many_free_list_blocks = false;
124: 	//! Debug setting for window aggregation mode: (window, combine, separate)
125: 	WindowAggregationMode window_mode = WindowAggregationMode::WINDOW;
126: 
127: 	//! Extra parameters that can be SET for loaded extensions
128: 	case_insensitive_map_t<ExtensionOption> extension_parameters;
129: 	//! Database configuration variables as controlled by SET
130: 	case_insensitive_map_t<Value> set_variables;
131: 
132: 	DUCKDB_API void AddExtensionOption(string name, string description, LogicalType parameter,
133: 	                                   set_option_callback_t function = nullptr);
134: 
135: public:
136: 	DUCKDB_API static DBConfig &GetConfig(ClientContext &context);
137: 	DUCKDB_API static DBConfig &GetConfig(DatabaseInstance &db);
138: 	DUCKDB_API static vector<ConfigurationOption> GetOptions();
139: 	DUCKDB_API static idx_t GetOptionCount();
140: 
141: 	//! Fetch an option by index. Returns a pointer to the option, or nullptr if out of range
142: 	DUCKDB_API static ConfigurationOption *GetOptionByIndex(idx_t index);
143: 	//! Fetch an option by name. Returns a pointer to the option, or nullptr if none exists.
144: 	DUCKDB_API static ConfigurationOption *GetOptionByName(const string &name);
145: 
146: 	DUCKDB_API void SetOption(const ConfigurationOption &option, const Value &value);
147: 
148: 	DUCKDB_API static idx_t ParseMemoryLimit(const string &arg);
149: 
150: 	//! Return the list of possible compression functions for the specific physical type
151: 	DUCKDB_API vector<CompressionFunction *> GetCompressionFunctions(PhysicalType data_type);
152: 	//! Return the compression function for the specified compression type/physical type combo
153: 	DUCKDB_API CompressionFunction *GetCompressionFunction(CompressionType type, PhysicalType data_type);
154: 
155: private:
156: 	unique_ptr<CompressionFunctionSet> compression_functions;
157: };
158: 
159: } // namespace duckdb
[end of src/include/duckdb/main/config.hpp]
[start of src/include/duckdb/main/settings.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/settings.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types/value.hpp"
13: 
14: namespace duckdb {
15: class ClientContext;
16: class DatabaseInstance;
17: struct DBConfig;
18: 
19: struct AccessModeSetting {
20: 	static constexpr const char *Name = "access_mode";
21: 	static constexpr const char *Description = "Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE)";
22: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
23: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
24: 	static Value GetSetting(ClientContext &context);
25: };
26: 
27: struct CheckpointThresholdSetting {
28: 	static constexpr const char *Name = "checkpoint_threshold";
29: 	static constexpr const char *Description =
30: 	    "The WAL size threshold at which to automatically trigger a checkpoint (e.g. 1GB)";
31: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
32: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
33: 	static Value GetSetting(ClientContext &context);
34: };
35: 
36: struct DebugCheckpointAbort {
37: 	static constexpr const char *Name = "debug_checkpoint_abort";
38: 	static constexpr const char *Description =
39: 	    "DEBUG SETTING: trigger an abort while checkpointing for testing purposes";
40: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
41: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
42: 	static Value GetSetting(ClientContext &context);
43: };
44: 
45: struct DebugForceExternal {
46: 	static constexpr const char *Name = "debug_force_external";
47: 	static constexpr const char *Description =
48: 	    "DEBUG SETTING: force out-of-core computation for operators that support it, used for testing";
49: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
50: 	static void SetLocal(ClientContext &context, const Value &parameter);
51: 	static Value GetSetting(ClientContext &context);
52: };
53: 
54: struct DebugManyFreeListBlocks {
55: 	static constexpr const char *Name = "debug_many_free_list_blocks";
56: 	static constexpr const char *Description = "DEBUG SETTING: add additional blocks to the free list";
57: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
58: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
59: 	static Value GetSetting(ClientContext &context);
60: };
61: 
62: struct DebugWindowMode {
63: 	static constexpr const char *Name = "debug_window_mode";
64: 	static constexpr const char *Description = "DEBUG SETTING: switch window mode to use";
65: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
66: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
67: 	static Value GetSetting(ClientContext &context);
68: };
69: 
70: struct DefaultCollationSetting {
71: 	static constexpr const char *Name = "default_collation";
72: 	static constexpr const char *Description = "The collation setting used when none is specified";
73: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
74: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
75: 	static void SetLocal(ClientContext &context, const Value &parameter);
76: 	static Value GetSetting(ClientContext &context);
77: };
78: 
79: struct DefaultOrderSetting {
80: 	static constexpr const char *Name = "default_order";
81: 	static constexpr const char *Description = "The order type used when none is specified (ASC or DESC)";
82: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
83: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
84: 	static Value GetSetting(ClientContext &context);
85: };
86: 
87: struct DefaultNullOrderSetting {
88: 	static constexpr const char *Name = "default_null_order";
89: 	static constexpr const char *Description = "Null ordering used when none is specified (NULLS_FIRST or NULLS_LAST)";
90: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
91: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
92: 	static Value GetSetting(ClientContext &context);
93: };
94: 
95: struct DisabledOptimizersSetting {
96: 	static constexpr const char *Name = "disabled_optimizers";
97: 	static constexpr const char *Description = "DEBUG SETTING: disable a specific set of optimizers (comma separated)";
98: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
99: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
100: 	static Value GetSetting(ClientContext &context);
101: };
102: 
103: struct EnableExternalAccessSetting {
104: 	static constexpr const char *Name = "enable_external_access";
105: 	static constexpr const char *Description =
106: 	    "Allow the database to access external state (through e.g. loading/installing modules, COPY TO/FROM, CSV "
107: 	    "readers, pandas replacement scans, etc)";
108: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
109: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
110: 	static Value GetSetting(ClientContext &context);
111: };
112: 
113: struct EnableObjectCacheSetting {
114: 	static constexpr const char *Name = "enable_object_cache";
115: 	static constexpr const char *Description = "Whether or not object cache is used to cache e.g. Parquet metadata";
116: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
117: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
118: 	static Value GetSetting(ClientContext &context);
119: };
120: 
121: struct EnableProfilingSetting {
122: 	static constexpr const char *Name = "enable_profiling";
123: 	static constexpr const char *Description =
124: 	    "Enables profiling, and sets the output format (JSON, QUERY_TREE, QUERY_TREE_OPTIMIZER)";
125: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
126: 	static void SetLocal(ClientContext &context, const Value &parameter);
127: 	static Value GetSetting(ClientContext &context);
128: };
129: 
130: struct EnableProgressBarSetting {
131: 	static constexpr const char *Name = "enable_progress_bar";
132: 	static constexpr const char *Description =
133: 	    "Enables the progress bar, printing progress to the terminal for long queries";
134: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
135: 	static void SetLocal(ClientContext &context, const Value &parameter);
136: 	static Value GetSetting(ClientContext &context);
137: };
138: 
139: struct ExplainOutputSetting {
140: 	static constexpr const char *Name = "explain_output";
141: 	static constexpr const char *Description = "Output of EXPLAIN statements (ALL, OPTIMIZED_ONLY, PHYSICAL_ONLY)";
142: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
143: 	static void SetLocal(ClientContext &context, const Value &parameter);
144: 	static Value GetSetting(ClientContext &context);
145: };
146: 
147: struct ForceCompressionSetting {
148: 	static constexpr const char *Name = "force_compression";
149: 	static constexpr const char *Description = "DEBUG SETTING: forces a specific compression method to be used";
150: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
151: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
152: 	static Value GetSetting(ClientContext &context);
153: };
154: 
155: struct LogQueryPathSetting {
156: 	static constexpr const char *Name = "log_query_path";
157: 	static constexpr const char *Description =
158: 	    "Specifies the path to which queries should be logged (default: empty string, queries are not logged)";
159: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
160: 	static void SetLocal(ClientContext &context, const Value &parameter);
161: 	static Value GetSetting(ClientContext &context);
162: };
163: 
164: struct MaximumMemorySetting {
165: 	static constexpr const char *Name = "max_memory";
166: 	static constexpr const char *Description = "The maximum memory of the system (e.g. 1GB)";
167: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
168: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
169: 	static Value GetSetting(ClientContext &context);
170: };
171: 
172: struct PerfectHashThresholdSetting {
173: 	static constexpr const char *Name = "perfect_ht_threshold";
174: 	static constexpr const char *Description = "Threshold in bytes for when to use a perfect hash table (default: 12)";
175: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
176: 	static void SetLocal(ClientContext &context, const Value &parameter);
177: 	static Value GetSetting(ClientContext &context);
178: };
179: 
180: struct PreserveIdentifierCase {
181: 	static constexpr const char *Name = "preserve_identifier_case";
182: 	static constexpr const char *Description =
183: 	    "Whether or not to preserve the identifier case, instead of always lowercasing all non-quoted identifiers";
184: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
185: 	static void SetLocal(ClientContext &context, const Value &parameter);
186: 	static Value GetSetting(ClientContext &context);
187: };
188: 
189: struct ProfilerHistorySize {
190: 	static constexpr const char *Name = "profiler_history_size";
191: 	static constexpr const char *Description = "Sets the profiler history size";
192: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
193: 	static void SetLocal(ClientContext &context, const Value &parameter);
194: 	static Value GetSetting(ClientContext &context);
195: };
196: 
197: struct ProfileOutputSetting {
198: 	static constexpr const char *Name = "profile_output";
199: 	static constexpr const char *Description =
200: 	    "The file to which profile output should be saved, or empty to print to the terminal";
201: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
202: 	static void SetLocal(ClientContext &context, const Value &parameter);
203: 	static Value GetSetting(ClientContext &context);
204: };
205: 
206: struct ProfilingModeSetting {
207: 	static constexpr const char *Name = "profiling_mode";
208: 	static constexpr const char *Description = "The profiling mode (STANDARD or DETAILED)";
209: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
210: 	static void SetLocal(ClientContext &context, const Value &parameter);
211: 	static Value GetSetting(ClientContext &context);
212: };
213: 
214: struct ProgressBarTimeSetting {
215: 	static constexpr const char *Name = "progress_bar_time";
216: 	static constexpr const char *Description =
217: 	    "Sets the time (in milliseconds) how long a query needs to take before we start printing a progress bar";
218: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
219: 	static void SetLocal(ClientContext &context, const Value &parameter);
220: 	static Value GetSetting(ClientContext &context);
221: };
222: 
223: struct SchemaSetting {
224: 	static constexpr const char *Name = "schema";
225: 	static constexpr const char *Description =
226: 	    "Sets the default search schema. Equivalent to setting search_path to a single value.";
227: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
228: 	static void SetLocal(ClientContext &context, const Value &parameter);
229: 	static Value GetSetting(ClientContext &context);
230: };
231: 
232: struct SearchPathSetting {
233: 	static constexpr const char *Name = "search_path";
234: 	static constexpr const char *Description =
235: 	    "Sets the default search search path as a comma-separated list of values";
236: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
237: 	static void SetLocal(ClientContext &context, const Value &parameter);
238: 	static Value GetSetting(ClientContext &context);
239: };
240: 
241: struct TempDirectorySetting {
242: 	static constexpr const char *Name = "temp_directory";
243: 	static constexpr const char *Description = "Set the directory to which to write temp files";
244: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
245: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
246: 	static Value GetSetting(ClientContext &context);
247: };
248: 
249: struct ThreadsSetting {
250: 	static constexpr const char *Name = "threads";
251: 	static constexpr const char *Description = "The number of total threads used by the system.";
252: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
253: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
254: 	static Value GetSetting(ClientContext &context);
255: };
256: 
257: } // namespace duckdb
[end of src/include/duckdb/main/settings.hpp]
[start of src/include/duckdb/parallel/task_scheduler.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parallel/task_scheduler.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/mutex.hpp"
13: #include "duckdb/common/vector.hpp"
14: #include "duckdb/parallel/task.hpp"
15: #include "duckdb/common/atomic.hpp"
16: 
17: namespace duckdb {
18: 
19: struct ConcurrentQueue;
20: struct QueueProducerToken;
21: class ClientContext;
22: class DatabaseInstance;
23: class TaskScheduler;
24: 
25: struct SchedulerThread;
26: 
27: struct ProducerToken {
28: 	ProducerToken(TaskScheduler &scheduler, unique_ptr<QueueProducerToken> token);
29: 	~ProducerToken();
30: 
31: 	TaskScheduler &scheduler;
32: 	unique_ptr<QueueProducerToken> token;
33: 	mutex producer_lock;
34: };
35: 
36: //! The TaskScheduler is responsible for managing tasks and threads
37: class TaskScheduler {
38: 	// timeout for semaphore wait, default 50ms
39: 	constexpr static int64_t TASK_TIMEOUT_USECS = 50000;
40: 
41: public:
42: 	TaskScheduler();
43: 	~TaskScheduler();
44: 
45: 	static TaskScheduler &GetScheduler(ClientContext &context);
46: 	static TaskScheduler &GetScheduler(DatabaseInstance &db);
47: 
48: 	unique_ptr<ProducerToken> CreateProducer();
49: 	//! Schedule a task to be executed by the task scheduler
50: 	void ScheduleTask(ProducerToken &producer, unique_ptr<Task> task);
51: 	//! Fetches a task from a specific producer, returns true if successful or false if no tasks were available
52: 	bool GetTaskFromProducer(ProducerToken &token, unique_ptr<Task> &task);
53: 	//! Run tasks forever until "marker" is set to false, "marker" must remain valid until the thread is joined
54: 	void ExecuteForever(atomic<bool> *marker);
55: 
56: 	//! Sets the amount of active threads executing tasks for the system; n-1 background threads will be launched.
57: 	//! The main thread will also be used for execution
58: 	void SetThreads(int32_t n);
59: 	//! Returns the number of threads
60: 	int32_t NumberOfThreads();
61: 
62: private:
63: 	void SetThreadsInternal(int32_t n);
64: 
65: 	//! The task queue
66: 	unique_ptr<ConcurrentQueue> queue;
67: 	//! The active background threads of the task scheduler
68: 	vector<unique_ptr<SchedulerThread>> threads;
69: 	//! Markers used by the various threads, if the markers are set to "false" the thread execution is stopped
70: 	vector<unique_ptr<atomic<bool>>> markers;
71: };
72: 
73: } // namespace duckdb
[end of src/include/duckdb/parallel/task_scheduler.hpp]
[start of src/main/capi/CMakeLists.txt]
1: add_library_unity(
2:   duckdb_main_capi
3:   OBJECT
4:   appender-c.cpp
5:   arrow-c.cpp
6:   config-c.cpp
7:   data_chunk-c.cpp
8:   datetime-c.cpp
9:   duckdb-c.cpp
10:   duckdb_value-c.cpp
11:   helper-c.cpp
12:   hugeint-c.cpp
13:   logical_types-c.cpp
14:   prepared-c.cpp
15:   replacement_scan-c.cpp
16:   result-c.cpp
17:   table_function-c.cpp
18:   value-c.cpp)
19: 
20: set(ALL_OBJECT_FILES
21:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_main_capi>
22:     PARENT_SCOPE)
[end of src/main/capi/CMakeLists.txt]
[start of src/main/config.cpp]
1: #include "duckdb/main/config.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/common/operator/cast_operators.hpp"
4: #include "duckdb/main/settings.hpp"
5: 
6: namespace duckdb {
7: 
8: #define DUCKDB_GLOBAL(_PARAM)                                                                                          \
9: 	{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::GetSetting }
10: #define DUCKDB_GLOBAL_ALIAS(_ALIAS, _PARAM)                                                                            \
11: 	{ _ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::GetSetting }
12: 
13: #define DUCKDB_LOCAL(_PARAM)                                                                                           \
14: 	{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, _PARAM::GetSetting }
15: #define DUCKDB_LOCAL_ALIAS(_ALIAS, _PARAM)                                                                             \
16: 	{ _ALIAS, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, _PARAM::GetSetting }
17: 
18: #define DUCKDB_GLOBAL_LOCAL(_PARAM)                                                                                    \
19: 	{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal, _PARAM::GetSetting }
20: #define DUCKDB_GLOBAL_LOCAL_ALIAS(_ALIAS, _PARAM)                                                                      \
21: 	{ _ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal, _PARAM::GetSetting }
22: #define FINAL_SETTING                                                                                                  \
23: 	{ nullptr, nullptr, LogicalTypeId::INVALID, nullptr, nullptr, nullptr }
24: 
25: static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting),
26:                                                  DUCKDB_GLOBAL(CheckpointThresholdSetting),
27:                                                  DUCKDB_GLOBAL(DebugCheckpointAbort),
28:                                                  DUCKDB_LOCAL(DebugForceExternal),
29:                                                  DUCKDB_GLOBAL(DebugManyFreeListBlocks),
30:                                                  DUCKDB_GLOBAL(DebugWindowMode),
31:                                                  DUCKDB_GLOBAL_LOCAL(DefaultCollationSetting),
32:                                                  DUCKDB_GLOBAL(DefaultOrderSetting),
33:                                                  DUCKDB_GLOBAL(DefaultNullOrderSetting),
34:                                                  DUCKDB_GLOBAL(DisabledOptimizersSetting),
35:                                                  DUCKDB_GLOBAL(EnableExternalAccessSetting),
36:                                                  DUCKDB_GLOBAL(EnableObjectCacheSetting),
37:                                                  DUCKDB_LOCAL(EnableProfilingSetting),
38:                                                  DUCKDB_LOCAL(EnableProgressBarSetting),
39:                                                  DUCKDB_LOCAL(ExplainOutputSetting),
40:                                                  DUCKDB_GLOBAL(ForceCompressionSetting),
41:                                                  DUCKDB_LOCAL(LogQueryPathSetting),
42:                                                  DUCKDB_GLOBAL(MaximumMemorySetting),
43:                                                  DUCKDB_GLOBAL_ALIAS("memory_limit", MaximumMemorySetting),
44:                                                  DUCKDB_GLOBAL_ALIAS("null_order", DefaultNullOrderSetting),
45:                                                  DUCKDB_LOCAL(PerfectHashThresholdSetting),
46:                                                  DUCKDB_LOCAL(PreserveIdentifierCase),
47:                                                  DUCKDB_LOCAL(ProfilerHistorySize),
48:                                                  DUCKDB_LOCAL(ProfileOutputSetting),
49:                                                  DUCKDB_LOCAL(ProfilingModeSetting),
50:                                                  DUCKDB_LOCAL_ALIAS("profiling_output", ProfileOutputSetting),
51:                                                  DUCKDB_LOCAL(ProgressBarTimeSetting),
52:                                                  DUCKDB_LOCAL(SchemaSetting),
53:                                                  DUCKDB_LOCAL(SearchPathSetting),
54:                                                  DUCKDB_GLOBAL(TempDirectorySetting),
55:                                                  DUCKDB_GLOBAL(ThreadsSetting),
56:                                                  DUCKDB_GLOBAL_ALIAS("wal_autocheckpoint", CheckpointThresholdSetting),
57:                                                  DUCKDB_GLOBAL_ALIAS("worker_threads", ThreadsSetting),
58:                                                  FINAL_SETTING};
59: 
60: vector<ConfigurationOption> DBConfig::GetOptions() {
61: 	vector<ConfigurationOption> options;
62: 	for (idx_t index = 0; internal_options[index].name; index++) {
63: 		options.push_back(internal_options[index]);
64: 	}
65: 	return options;
66: }
67: 
68: idx_t DBConfig::GetOptionCount() {
69: 	idx_t count = 0;
70: 	for (idx_t index = 0; internal_options[index].name; index++) {
71: 		count++;
72: 	}
73: 	return count;
74: }
75: 
76: ConfigurationOption *DBConfig::GetOptionByIndex(idx_t target_index) {
77: 	for (idx_t index = 0; internal_options[index].name; index++) {
78: 		if (index == target_index) {
79: 			return internal_options + index;
80: 		}
81: 	}
82: 	return nullptr;
83: }
84: 
85: ConfigurationOption *DBConfig::GetOptionByName(const string &name) {
86: 	auto lname = StringUtil::Lower(name);
87: 	for (idx_t index = 0; internal_options[index].name; index++) {
88: 		D_ASSERT(StringUtil::Lower(internal_options[index].name) == string(internal_options[index].name));
89: 		if (internal_options[index].name == lname) {
90: 			return internal_options + index;
91: 		}
92: 	}
93: 	return nullptr;
94: }
95: 
96: void DBConfig::SetOption(const ConfigurationOption &option, const Value &value) {
97: 	if (!option.set_global) {
98: 		throw InternalException("Could not set option \"%s\" as a global option", option.name);
99: 	}
100: 	Value input = value.CastAs(option.parameter_type);
101: 	option.set_global(nullptr, *this, input);
102: }
103: 
104: void DBConfig::AddExtensionOption(string name, string description, LogicalType parameter,
105:                                   set_option_callback_t function) {
106: 	extension_parameters.insert(make_pair(move(name), ExtensionOption(move(description), move(parameter), function)));
107: }
108: 
109: idx_t DBConfig::ParseMemoryLimit(const string &arg) {
110: 	if (arg[0] == '-' || arg == "null" || arg == "none") {
111: 		return DConstants::INVALID_INDEX;
112: 	}
113: 	// split based on the number/non-number
114: 	idx_t idx = 0;
115: 	while (StringUtil::CharacterIsSpace(arg[idx])) {
116: 		idx++;
117: 	}
118: 	idx_t num_start = idx;
119: 	while ((arg[idx] >= '0' && arg[idx] <= '9') || arg[idx] == '.' || arg[idx] == 'e' || arg[idx] == 'E' ||
120: 	       arg[idx] == '-') {
121: 		idx++;
122: 	}
123: 	if (idx == num_start) {
124: 		throw ParserException("Memory limit must have a number (e.g. SET memory_limit=1GB");
125: 	}
126: 	string number = arg.substr(num_start, idx - num_start);
127: 
128: 	// try to parse the number
129: 	double limit = Cast::Operation<string_t, double>(string_t(number));
130: 
131: 	// now parse the memory limit unit (e.g. bytes, gb, etc)
132: 	while (StringUtil::CharacterIsSpace(arg[idx])) {
133: 		idx++;
134: 	}
135: 	idx_t start = idx;
136: 	while (idx < arg.size() && !StringUtil::CharacterIsSpace(arg[idx])) {
137: 		idx++;
138: 	}
139: 	if (limit < 0) {
140: 		// limit < 0, set limit to infinite
141: 		return (idx_t)-1;
142: 	}
143: 	string unit = StringUtil::Lower(arg.substr(start, idx - start));
144: 	idx_t multiplier;
145: 	if (unit == "byte" || unit == "bytes" || unit == "b") {
146: 		multiplier = 1;
147: 	} else if (unit == "kilobyte" || unit == "kilobytes" || unit == "kb" || unit == "k") {
148: 		multiplier = 1000LL;
149: 	} else if (unit == "megabyte" || unit == "megabytes" || unit == "mb" || unit == "m") {
150: 		multiplier = 1000LL * 1000LL;
151: 	} else if (unit == "gigabyte" || unit == "gigabytes" || unit == "gb" || unit == "g") {
152: 		multiplier = 1000LL * 1000LL * 1000LL;
153: 	} else if (unit == "terabyte" || unit == "terabytes" || unit == "tb" || unit == "t") {
154: 		multiplier = 1000LL * 1000LL * 1000LL * 1000LL;
155: 	} else {
156: 		throw ParserException("Unknown unit for memory_limit: %s (expected: b, mb, gb or tb)", unit);
157: 	}
158: 	return (idx_t)multiplier * limit;
159: }
160: 
161: } // namespace duckdb
[end of src/main/config.cpp]
[start of src/main/database.cpp]
1: #include "duckdb/main/database.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/common/virtual_file_system.hpp"
5: #include "duckdb/main/client_context.hpp"
6: #include "duckdb/parallel/task_scheduler.hpp"
7: #include "duckdb/storage/storage_manager.hpp"
8: #include "duckdb/storage/object_cache.hpp"
9: #include "duckdb/transaction/transaction_manager.hpp"
10: #include "duckdb/main/connection_manager.hpp"
11: #include "duckdb/function/compression_function.hpp"
12: #include "duckdb/main/extension_helper.hpp"
13: 
14: #ifndef DUCKDB_NO_THREADS
15: #include "duckdb/common/thread.hpp"
16: #endif
17: 
18: namespace duckdb {
19: 
20: DBConfig::DBConfig() {
21: 	compression_functions = make_unique<CompressionFunctionSet>();
22: }
23: 
24: DBConfig::~DBConfig() {
25: }
26: 
27: DatabaseInstance::DatabaseInstance() {
28: }
29: 
30: DatabaseInstance::~DatabaseInstance() {
31: 	if (Exception::UncaughtException()) {
32: 		return;
33: 	}
34: 
35: 	// shutting down: attempt to checkpoint the database
36: 	// but only if we are not cleaning up as part of an exception unwind
37: 	try {
38: 		auto &storage = StorageManager::GetStorageManager(*this);
39: 		if (!storage.InMemory()) {
40: 			auto &config = storage.db.config;
41: 			if (!config.checkpoint_on_shutdown) {
42: 				return;
43: 			}
44: 			storage.CreateCheckpoint(true);
45: 		}
46: 	} catch (...) {
47: 	}
48: }
49: 
50: BufferManager &BufferManager::GetBufferManager(DatabaseInstance &db) {
51: 	return *db.GetStorageManager().buffer_manager;
52: }
53: 
54: BlockManager &BlockManager::GetBlockManager(DatabaseInstance &db) {
55: 	return *db.GetStorageManager().block_manager;
56: }
57: 
58: BlockManager &BlockManager::GetBlockManager(ClientContext &context) {
59: 	return BlockManager::GetBlockManager(DatabaseInstance::GetDatabase(context));
60: }
61: 
62: DatabaseInstance &DatabaseInstance::GetDatabase(ClientContext &context) {
63: 	return *context.db;
64: }
65: 
66: StorageManager &StorageManager::GetStorageManager(DatabaseInstance &db) {
67: 	return db.GetStorageManager();
68: }
69: 
70: Catalog &Catalog::GetCatalog(DatabaseInstance &db) {
71: 	return db.GetCatalog();
72: }
73: 
74: FileSystem &FileSystem::GetFileSystem(DatabaseInstance &db) {
75: 	return db.GetFileSystem();
76: }
77: 
78: DBConfig &DBConfig::GetConfig(DatabaseInstance &db) {
79: 	return db.config;
80: }
81: 
82: ClientConfig &ClientConfig::GetConfig(ClientContext &context) {
83: 	return context.config;
84: }
85: 
86: TransactionManager &TransactionManager::Get(ClientContext &context) {
87: 	return TransactionManager::Get(DatabaseInstance::GetDatabase(context));
88: }
89: 
90: TransactionManager &TransactionManager::Get(DatabaseInstance &db) {
91: 	return db.GetTransactionManager();
92: }
93: 
94: ConnectionManager &ConnectionManager::Get(DatabaseInstance &db) {
95: 	return db.GetConnectionManager();
96: }
97: 
98: ConnectionManager &ConnectionManager::Get(ClientContext &context) {
99: 	return ConnectionManager::Get(DatabaseInstance::GetDatabase(context));
100: }
101: 
102: void DatabaseInstance::Initialize(const char *path, DBConfig *new_config) {
103: 	if (new_config) {
104: 		// user-supplied configuration
105: 		Configure(*new_config);
106: 	} else {
107: 		// default configuration
108: 		DBConfig config;
109: 		Configure(config);
110: 	}
111: 	if (config.temporary_directory.empty() && path) {
112: 		// no directory specified: use default temp path
113: 		config.temporary_directory = string(path) + ".tmp";
114: 
115: 		// special treatment for in-memory mode
116: 		if (strcmp(path, ":memory:") == 0) {
117: 			config.temporary_directory = ".tmp";
118: 		}
119: 	}
120: 	if (new_config && !new_config->use_temporary_directory) {
121: 		// temporary directories explicitly disabled
122: 		config.temporary_directory = string();
123: 	}
124: 
125: 	storage =
126: 	    make_unique<StorageManager>(*this, path ? string(path) : string(), config.access_mode == AccessMode::READ_ONLY);
127: 	catalog = make_unique<Catalog>(*this);
128: 	transaction_manager = make_unique<TransactionManager>(*this);
129: 	scheduler = make_unique<TaskScheduler>();
130: 	object_cache = make_unique<ObjectCache>();
131: 	connection_manager = make_unique<ConnectionManager>();
132: 
133: 	// initialize the database
134: 	storage->Initialize();
135: 
136: 	// only increase thread count after storage init because we get races on catalog otherwise
137: 	scheduler->SetThreads(config.maximum_threads);
138: }
139: 
140: DuckDB::DuckDB(const char *path, DBConfig *new_config) : instance(make_shared<DatabaseInstance>()) {
141: 	instance->Initialize(path, new_config);
142: 	if (instance->config.load_extensions) {
143: 		ExtensionHelper::LoadAllExtensions(*this);
144: 	}
145: }
146: 
147: DuckDB::DuckDB(const string &path, DBConfig *config) : DuckDB(path.c_str(), config) {
148: }
149: 
150: DuckDB::DuckDB(DatabaseInstance &instance_p) : instance(instance_p.shared_from_this()) {
151: }
152: 
153: DuckDB::~DuckDB() {
154: }
155: 
156: StorageManager &DatabaseInstance::GetStorageManager() {
157: 	return *storage;
158: }
159: 
160: Catalog &DatabaseInstance::GetCatalog() {
161: 	return *catalog;
162: }
163: 
164: TransactionManager &DatabaseInstance::GetTransactionManager() {
165: 	return *transaction_manager;
166: }
167: 
168: TaskScheduler &DatabaseInstance::GetScheduler() {
169: 	return *scheduler;
170: }
171: 
172: ObjectCache &DatabaseInstance::GetObjectCache() {
173: 	return *object_cache;
174: }
175: 
176: FileSystem &DatabaseInstance::GetFileSystem() {
177: 	return *config.file_system;
178: }
179: 
180: ConnectionManager &DatabaseInstance::GetConnectionManager() {
181: 	return *connection_manager;
182: }
183: 
184: FileSystem &DuckDB::GetFileSystem() {
185: 	return instance->GetFileSystem();
186: }
187: 
188: Allocator &Allocator::Get(ClientContext &context) {
189: 	return Allocator::Get(*context.db);
190: }
191: 
192: Allocator &Allocator::Get(DatabaseInstance &db) {
193: 	return db.config.allocator;
194: }
195: 
196: void DatabaseInstance::Configure(DBConfig &new_config) {
197: 	config.access_mode = AccessMode::READ_WRITE;
198: 	if (new_config.access_mode != AccessMode::UNDEFINED) {
199: 		config.access_mode = new_config.access_mode;
200: 	}
201: 	if (new_config.file_system) {
202: 		config.file_system = move(new_config.file_system);
203: 	} else {
204: 		config.file_system = make_unique<VirtualFileSystem>();
205: 	}
206: 	config.maximum_memory = new_config.maximum_memory;
207: 	if (config.maximum_memory == (idx_t)-1) {
208: 		config.maximum_memory = FileSystem::GetAvailableMemory() * 8 / 10;
209: 	}
210: 	if (new_config.maximum_threads == (idx_t)-1) {
211: #ifndef DUCKDB_NO_THREADS
212: 		config.maximum_threads = std::thread::hardware_concurrency();
213: #else
214: 		config.maximum_threads = 1;
215: #endif
216: 	} else {
217: 		config.maximum_threads = new_config.maximum_threads;
218: 	}
219: 	config.load_extensions = new_config.load_extensions;
220: 	config.force_compression = new_config.force_compression;
221: 	config.allocator = move(new_config.allocator);
222: 	config.checkpoint_wal_size = new_config.checkpoint_wal_size;
223: 	config.use_direct_io = new_config.use_direct_io;
224: 	config.temporary_directory = new_config.temporary_directory;
225: 	config.collation = new_config.collation;
226: 	config.default_order_type = new_config.default_order_type;
227: 	config.default_null_order = new_config.default_null_order;
228: 	config.enable_external_access = new_config.enable_external_access;
229: 	config.replacement_scans = move(new_config.replacement_scans);
230: 	config.initialize_default_database = new_config.initialize_default_database;
231: 	config.disabled_optimizers = move(new_config.disabled_optimizers);
232: }
233: 
234: DBConfig &DBConfig::GetConfig(ClientContext &context) {
235: 	return context.db->config;
236: }
237: 
238: idx_t DatabaseInstance::NumberOfThreads() {
239: 	return scheduler->NumberOfThreads();
240: }
241: 
242: idx_t DuckDB::NumberOfThreads() {
243: 	return instance->NumberOfThreads();
244: }
245: 
246: bool DuckDB::ExtensionIsLoaded(const std::string &name) {
247: 	return instance->loaded_extensions.find(name) != instance->loaded_extensions.end();
248: }
249: void DuckDB::SetExtensionLoaded(const std::string &name) {
250: 	instance->loaded_extensions.insert(name);
251: }
252: 
253: } // namespace duckdb
[end of src/main/database.cpp]
[start of src/main/settings/settings.cpp]
1: #include "duckdb/main/settings.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/main/config.hpp"
4: #include "duckdb/main/client_context.hpp"
5: #include "duckdb/main/client_data.hpp"
6: #include "duckdb/catalog/catalog_search_path.hpp"
7: #include "duckdb/storage/buffer_manager.hpp"
8: #include "duckdb/parallel/task_scheduler.hpp"
9: #include "duckdb/planner/expression_binder.hpp"
10: #include "duckdb/main/query_profiler.hpp"
11: #include "duckdb/storage/storage_manager.hpp"
12: #include "duckdb/parser/parser.hpp"
13: 
14: namespace duckdb {
15: 
16: //===--------------------------------------------------------------------===//
17: // Access Mode
18: //===--------------------------------------------------------------------===//
19: void AccessModeSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
20: 	auto parameter = StringUtil::Lower(input.ToString());
21: 	if (parameter == "automatic") {
22: 		config.access_mode = AccessMode::AUTOMATIC;
23: 	} else if (parameter == "read_only") {
24: 		config.access_mode = AccessMode::READ_ONLY;
25: 	} else if (parameter == "read_write") {
26: 		config.access_mode = AccessMode::READ_WRITE;
27: 	} else {
28: 		throw InvalidInputException(
29: 		    "Unrecognized parameter for option ACCESS_MODE \"%s\". Expected READ_ONLY or READ_WRITE.", parameter);
30: 	}
31: }
32: 
33: Value AccessModeSetting::GetSetting(ClientContext &context) {
34: 	auto &config = DBConfig::GetConfig(context);
35: 	switch (config.access_mode) {
36: 	case AccessMode::AUTOMATIC:
37: 		return "automatic";
38: 	case AccessMode::READ_ONLY:
39: 		return "read_only";
40: 	case AccessMode::READ_WRITE:
41: 		return "read_write";
42: 	default:
43: 		throw InternalException("Unknown access mode setting");
44: 	}
45: }
46: 
47: //===--------------------------------------------------------------------===//
48: // Checkpoint Threshold
49: //===--------------------------------------------------------------------===//
50: void CheckpointThresholdSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
51: 	idx_t new_limit = DBConfig::ParseMemoryLimit(input.ToString());
52: 	config.checkpoint_wal_size = new_limit;
53: }
54: 
55: Value CheckpointThresholdSetting::GetSetting(ClientContext &context) {
56: 	auto &config = DBConfig::GetConfig(context);
57: 	return Value(StringUtil::BytesToHumanReadableString(config.checkpoint_wal_size));
58: }
59: 
60: //===--------------------------------------------------------------------===//
61: // Debug Checkpoint Abort
62: //===--------------------------------------------------------------------===//
63: void DebugCheckpointAbort::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
64: 	auto checkpoint_abort = StringUtil::Lower(input.ToString());
65: 	if (checkpoint_abort == "none") {
66: 		config.checkpoint_abort = CheckpointAbort::NO_ABORT;
67: 	} else if (checkpoint_abort == "before_truncate") {
68: 		config.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE;
69: 	} else if (checkpoint_abort == "before_header") {
70: 		config.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER;
71: 	} else if (checkpoint_abort == "after_free_list_write") {
72: 		config.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE;
73: 	} else {
74: 		throw ParserException(
75: 		    "Unrecognized option for PRAGMA debug_checkpoint_abort, expected none, before_truncate or before_header");
76: 	}
77: }
78: 
79: Value DebugCheckpointAbort::GetSetting(ClientContext &context) {
80: 	return Value();
81: }
82: 
83: //===--------------------------------------------------------------------===//
84: // Debug Force External
85: //===--------------------------------------------------------------------===//
86: void DebugForceExternal::SetLocal(ClientContext &context, const Value &input) {
87: 	ClientConfig::GetConfig(context).force_external = input.GetValue<bool>();
88: }
89: 
90: Value DebugForceExternal::GetSetting(ClientContext &context) {
91: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).force_external);
92: }
93: 
94: //===--------------------------------------------------------------------===//
95: // Debug Many Free List blocks
96: //===--------------------------------------------------------------------===//
97: void DebugManyFreeListBlocks::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
98: 	config.debug_many_free_list_blocks = input.GetValue<bool>();
99: }
100: 
101: Value DebugManyFreeListBlocks::GetSetting(ClientContext &context) {
102: 	auto &config = DBConfig::GetConfig(context);
103: 	return Value::BOOLEAN(config.debug_many_free_list_blocks);
104: }
105: 
106: //===--------------------------------------------------------------------===//
107: // Debug Window Mode
108: //===--------------------------------------------------------------------===//
109: void DebugWindowMode::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
110: 	auto param = StringUtil::Lower(input.ToString());
111: 	if (param == "window") {
112: 		config.window_mode = WindowAggregationMode::WINDOW;
113: 	} else if (param == "combine") {
114: 		config.window_mode = WindowAggregationMode::COMBINE;
115: 	} else if (param == "separate") {
116: 		config.window_mode = WindowAggregationMode::SEPARATE;
117: 	} else {
118: 		throw ParserException("Unrecognized option for PRAGMA debug_window_mode, expected window, combine or separate");
119: 	}
120: }
121: 
122: Value DebugWindowMode::GetSetting(ClientContext &context) {
123: 	return Value();
124: }
125: 
126: //===--------------------------------------------------------------------===//
127: // Default Collation
128: //===--------------------------------------------------------------------===//
129: void DefaultCollationSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
130: 	auto parameter = StringUtil::Lower(input.ToString());
131: 	config.collation = parameter;
132: }
133: 
134: void DefaultCollationSetting::SetLocal(ClientContext &context, const Value &input) {
135: 	auto parameter = input.ToString();
136: 	// bind the collation to verify that it exists
137: 	ExpressionBinder::TestCollation(context, parameter);
138: 	auto &config = DBConfig::GetConfig(context);
139: 	config.collation = parameter;
140: }
141: 
142: Value DefaultCollationSetting::GetSetting(ClientContext &context) {
143: 	auto &config = DBConfig::GetConfig(context);
144: 	return Value(config.collation);
145: }
146: 
147: //===--------------------------------------------------------------------===//
148: // Default Order
149: //===--------------------------------------------------------------------===//
150: void DefaultOrderSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
151: 	auto parameter = StringUtil::Lower(input.ToString());
152: 	if (parameter == "ascending" || parameter == "asc") {
153: 		config.default_order_type = OrderType::ASCENDING;
154: 	} else if (parameter == "descending" || parameter == "desc") {
155: 		config.default_order_type = OrderType::DESCENDING;
156: 	} else {
157: 		throw InvalidInputException("Unrecognized parameter for option DEFAULT_ORDER \"%s\". Expected ASC or DESC.",
158: 		                            parameter);
159: 	}
160: }
161: 
162: Value DefaultOrderSetting::GetSetting(ClientContext &context) {
163: 	auto &config = DBConfig::GetConfig(context);
164: 	switch (config.default_order_type) {
165: 	case OrderType::ASCENDING:
166: 		return "asc";
167: 	case OrderType::DESCENDING:
168: 		return "desc";
169: 	default:
170: 		throw InternalException("Unknown order type setting");
171: 	}
172: }
173: 
174: //===--------------------------------------------------------------------===//
175: // Default Null Order
176: //===--------------------------------------------------------------------===//
177: void DefaultNullOrderSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
178: 	auto parameter = StringUtil::Lower(input.ToString());
179: 
180: 	if (parameter == "nulls_first" || parameter == "nulls first" || parameter == "null first" || parameter == "first") {
181: 		config.default_null_order = OrderByNullType::NULLS_FIRST;
182: 	} else if (parameter == "nulls_last" || parameter == "nulls last" || parameter == "null last" ||
183: 	           parameter == "last") {
184: 		config.default_null_order = OrderByNullType::NULLS_LAST;
185: 	} else {
186: 		throw ParserException(
187: 		    "Unrecognized parameter for option NULL_ORDER \"%s\", expected either NULLS FIRST or NULLS LAST",
188: 		    parameter);
189: 	}
190: }
191: 
192: Value DefaultNullOrderSetting::GetSetting(ClientContext &context) {
193: 	auto &config = DBConfig::GetConfig(context);
194: 	switch (config.default_null_order) {
195: 	case OrderByNullType::NULLS_FIRST:
196: 		return "nulls_first";
197: 	case OrderByNullType::NULLS_LAST:
198: 		return "nulls_last";
199: 	default:
200: 		throw InternalException("Unknown null order setting");
201: 	}
202: }
203: 
204: //===--------------------------------------------------------------------===//
205: // Disabled Optimizer
206: //===--------------------------------------------------------------------===//
207: void DisabledOptimizersSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
208: 	auto list = StringUtil::Split(input.ToString(), ",");
209: 	set<OptimizerType> disabled_optimizers;
210: 	for (auto &entry : list) {
211: 		auto param = StringUtil::Lower(entry);
212: 		StringUtil::Trim(param);
213: 		if (param.empty()) {
214: 			continue;
215: 		}
216: 		disabled_optimizers.insert(OptimizerTypeFromString(param));
217: 	}
218: 	config.disabled_optimizers = move(disabled_optimizers);
219: }
220: 
221: Value DisabledOptimizersSetting::GetSetting(ClientContext &context) {
222: 	auto &config = DBConfig::GetConfig(context);
223: 	string result;
224: 	for (auto &optimizer : config.disabled_optimizers) {
225: 		if (!result.empty()) {
226: 			result += ",";
227: 		}
228: 		result += OptimizerTypeToString(optimizer);
229: 	}
230: 	return Value(result);
231: }
232: 
233: //===--------------------------------------------------------------------===//
234: // Enable External Access
235: //===--------------------------------------------------------------------===//
236: void EnableExternalAccessSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
237: 	auto new_value = input.GetValue<bool>();
238: 	if (db && new_value) {
239: 		throw InvalidInputException("Cannot change enable_external_access setting while database is running");
240: 	}
241: 	config.enable_external_access = new_value;
242: }
243: 
244: Value EnableExternalAccessSetting::GetSetting(ClientContext &context) {
245: 	auto &config = DBConfig::GetConfig(context);
246: 	return Value::BOOLEAN(config.enable_external_access);
247: }
248: 
249: //===--------------------------------------------------------------------===//
250: // Enable Object Cache
251: //===--------------------------------------------------------------------===//
252: void EnableObjectCacheSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
253: 	config.object_cache_enable = input.GetValue<bool>();
254: }
255: 
256: Value EnableObjectCacheSetting::GetSetting(ClientContext &context) {
257: 	auto &config = DBConfig::GetConfig(context);
258: 	return Value::BOOLEAN(config.object_cache_enable);
259: }
260: 
261: //===--------------------------------------------------------------------===//
262: // Enable Profiling
263: //===--------------------------------------------------------------------===//
264: void EnableProfilingSetting::SetLocal(ClientContext &context, const Value &input) {
265: 	auto parameter = StringUtil::Lower(input.ToString());
266: 
267: 	auto &config = ClientConfig::GetConfig(context);
268: 	if (parameter == "json") {
269: 		config.profiler_print_format = ProfilerPrintFormat::JSON;
270: 	} else if (parameter == "query_tree") {
271: 		config.profiler_print_format = ProfilerPrintFormat::QUERY_TREE;
272: 	} else if (parameter == "query_tree_optimizer") {
273: 		config.profiler_print_format = ProfilerPrintFormat::QUERY_TREE_OPTIMIZER;
274: 	} else {
275: 		throw ParserException(
276: 		    "Unrecognized print format %s, supported formats: [json, query_tree, query_tree_optimizer]", parameter);
277: 	}
278: 	config.enable_profiler = true;
279: }
280: 
281: Value EnableProfilingSetting::GetSetting(ClientContext &context) {
282: 	auto &config = ClientConfig::GetConfig(context);
283: 	if (!config.enable_profiler) {
284: 		return Value();
285: 	}
286: 	switch (config.profiler_print_format) {
287: 	case ProfilerPrintFormat::NONE:
288: 		return Value("none");
289: 	case ProfilerPrintFormat::JSON:
290: 		return Value("json");
291: 	case ProfilerPrintFormat::QUERY_TREE:
292: 		return Value("query_tree");
293: 	case ProfilerPrintFormat::QUERY_TREE_OPTIMIZER:
294: 		return Value("query_tree_optimizer");
295: 	default:
296: 		throw InternalException("Unsupported profiler print format");
297: 	}
298: }
299: 
300: //===--------------------------------------------------------------------===//
301: // Enable Progress Bar
302: //===--------------------------------------------------------------------===//
303: void EnableProgressBarSetting::SetLocal(ClientContext &context, const Value &input) {
304: 	ClientConfig::GetConfig(context).enable_progress_bar = input.GetValue<bool>();
305: }
306: 
307: Value EnableProgressBarSetting::GetSetting(ClientContext &context) {
308: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).enable_progress_bar);
309: }
310: 
311: //===--------------------------------------------------------------------===//
312: // Explain Output
313: //===--------------------------------------------------------------------===//
314: void ExplainOutputSetting::SetLocal(ClientContext &context, const Value &input) {
315: 	auto parameter = StringUtil::Lower(input.ToString());
316: 	if (parameter == "all") {
317: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::ALL;
318: 	} else if (parameter == "optimized_only") {
319: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::OPTIMIZED_ONLY;
320: 	} else if (parameter == "physical_only") {
321: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::PHYSICAL_ONLY;
322: 	} else {
323: 		throw ParserException("Unrecognized output type \"%s\", expected either ALL, OPTIMIZED_ONLY or PHYSICAL_ONLY",
324: 		                      parameter);
325: 	}
326: }
327: 
328: Value ExplainOutputSetting::GetSetting(ClientContext &context) {
329: 	switch (ClientConfig::GetConfig(context).explain_output_type) {
330: 	case ExplainOutputType::ALL:
331: 		return "all";
332: 	case ExplainOutputType::OPTIMIZED_ONLY:
333: 		return "optimized_only";
334: 	case ExplainOutputType::PHYSICAL_ONLY:
335: 		return "physical_only";
336: 	default:
337: 		throw InternalException("Unrecognized explain output type");
338: 	}
339: }
340: 
341: //===--------------------------------------------------------------------===//
342: // Force Compression
343: //===--------------------------------------------------------------------===//
344: void ForceCompressionSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
345: 	auto compression = StringUtil::Lower(input.ToString());
346: 	if (compression == "none") {
347: 		config.force_compression = CompressionType::COMPRESSION_AUTO;
348: 	} else {
349: 		auto compression_type = CompressionTypeFromString(compression);
350: 		if (compression_type == CompressionType::COMPRESSION_AUTO) {
351: 			throw ParserException("Unrecognized option for PRAGMA force_compression, expected none, uncompressed, rle, "
352: 			                      "dictionary, pfor, bitpacking or fsst");
353: 		}
354: 		config.force_compression = compression_type;
355: 	}
356: }
357: 
358: Value ForceCompressionSetting::GetSetting(ClientContext &context) {
359: 	return Value();
360: }
361: 
362: //===--------------------------------------------------------------------===//
363: // Log Query Path
364: //===--------------------------------------------------------------------===//
365: void LogQueryPathSetting::SetLocal(ClientContext &context, const Value &input) {
366: 	auto &client_data = ClientData::Get(context);
367: 	auto path = input.ToString();
368: 	if (path.empty()) {
369: 		// empty path: clean up query writer
370: 		client_data.log_query_writer = nullptr;
371: 	} else {
372: 		client_data.log_query_writer =
373: 		    make_unique<BufferedFileWriter>(FileSystem::GetFileSystem(context), path,
374: 		                                    BufferedFileWriter::DEFAULT_OPEN_FLAGS, client_data.file_opener.get());
375: 	}
376: }
377: 
378: Value LogQueryPathSetting::GetSetting(ClientContext &context) {
379: 	auto &client_data = ClientData::Get(context);
380: 	return client_data.log_query_writer ? Value(client_data.log_query_writer->path) : Value();
381: }
382: 
383: //===--------------------------------------------------------------------===//
384: // Maximum Memory
385: //===--------------------------------------------------------------------===//
386: void MaximumMemorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
387: 	config.maximum_memory = DBConfig::ParseMemoryLimit(input.ToString());
388: 	if (db) {
389: 		BufferManager::GetBufferManager(*db).SetLimit(config.maximum_memory);
390: 	}
391: }
392: 
393: Value MaximumMemorySetting::GetSetting(ClientContext &context) {
394: 	auto &config = DBConfig::GetConfig(context);
395: 	return Value(StringUtil::BytesToHumanReadableString(config.maximum_memory));
396: }
397: 
398: //===--------------------------------------------------------------------===//
399: // Perfect Hash Threshold
400: //===--------------------------------------------------------------------===//
401: void PerfectHashThresholdSetting::SetLocal(ClientContext &context, const Value &input) {
402: 	auto bits = input.GetValue<int32_t>();
403: 	if (bits < 0 || bits > 32) {
404: 		throw ParserException("Perfect HT threshold out of range: should be within range 0 - 32");
405: 	}
406: 	ClientConfig::GetConfig(context).perfect_ht_threshold = bits;
407: }
408: 
409: Value PerfectHashThresholdSetting::GetSetting(ClientContext &context) {
410: 	return Value::BIGINT(ClientConfig::GetConfig(context).perfect_ht_threshold);
411: }
412: 
413: //===--------------------------------------------------------------------===//
414: // PreserveIdentifierCase
415: //===--------------------------------------------------------------------===//
416: void PreserveIdentifierCase::SetLocal(ClientContext &context, const Value &input) {
417: 	ClientConfig::GetConfig(context).preserve_identifier_case = input.GetValue<bool>();
418: }
419: 
420: Value PreserveIdentifierCase::GetSetting(ClientContext &context) {
421: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).preserve_identifier_case);
422: }
423: 
424: //===--------------------------------------------------------------------===//
425: // Profiler History Size
426: //===--------------------------------------------------------------------===//
427: void ProfilerHistorySize::SetLocal(ClientContext &context, const Value &input) {
428: 	auto size = input.GetValue<int64_t>();
429: 	if (size <= 0) {
430: 		throw ParserException("Size should be >= 0");
431: 	}
432: 	auto &client_data = ClientData::Get(context);
433: 	client_data.query_profiler_history->SetProfilerHistorySize(size);
434: }
435: 
436: Value ProfilerHistorySize::GetSetting(ClientContext &context) {
437: 	return Value();
438: }
439: 
440: //===--------------------------------------------------------------------===//
441: // Profile Output
442: //===--------------------------------------------------------------------===//
443: void ProfileOutputSetting::SetLocal(ClientContext &context, const Value &input) {
444: 	auto &config = ClientConfig::GetConfig(context);
445: 	auto parameter = input.ToString();
446: 	config.profiler_save_location = parameter;
447: }
448: 
449: Value ProfileOutputSetting::GetSetting(ClientContext &context) {
450: 	auto &config = ClientConfig::GetConfig(context);
451: 	return Value(config.profiler_save_location);
452: }
453: 
454: //===--------------------------------------------------------------------===//
455: // Profiling Mode
456: //===--------------------------------------------------------------------===//
457: void ProfilingModeSetting::SetLocal(ClientContext &context, const Value &input) {
458: 	auto parameter = StringUtil::Lower(input.ToString());
459: 	auto &config = ClientConfig::GetConfig(context);
460: 	if (parameter == "standard") {
461: 		config.enable_profiler = true;
462: 		config.enable_detailed_profiling = false;
463: 	} else if (parameter == "detailed") {
464: 		config.enable_profiler = true;
465: 		config.enable_detailed_profiling = true;
466: 	} else {
467: 		throw ParserException("Unrecognized profiling mode \"%s\", supported formats: [standard, detailed]", parameter);
468: 	}
469: }
470: 
471: Value ProfilingModeSetting::GetSetting(ClientContext &context) {
472: 	auto &config = ClientConfig::GetConfig(context);
473: 	if (!config.enable_profiler) {
474: 		return Value();
475: 	}
476: 	return Value(config.enable_detailed_profiling ? "detailed" : "standard");
477: }
478: 
479: //===--------------------------------------------------------------------===//
480: // Progress Bar Time
481: //===--------------------------------------------------------------------===//
482: void ProgressBarTimeSetting::SetLocal(ClientContext &context, const Value &input) {
483: 	ClientConfig::GetConfig(context).wait_time = input.GetValue<int32_t>();
484: 	ClientConfig::GetConfig(context).enable_progress_bar = true;
485: }
486: 
487: Value ProgressBarTimeSetting::GetSetting(ClientContext &context) {
488: 	return Value::BIGINT(ClientConfig::GetConfig(context).wait_time);
489: }
490: 
491: //===--------------------------------------------------------------------===//
492: // Schema
493: //===--------------------------------------------------------------------===//
494: void SchemaSetting::SetLocal(ClientContext &context, const Value &input) {
495: 	auto parameter = input.ToString();
496: 	auto &client_data = ClientData::Get(context);
497: 	client_data.catalog_search_path->Set(parameter, true);
498: }
499: 
500: Value SchemaSetting::GetSetting(ClientContext &context) {
501: 	return SearchPathSetting::GetSetting(context);
502: }
503: 
504: //===--------------------------------------------------------------------===//
505: // Search Path
506: //===--------------------------------------------------------------------===//
507: void SearchPathSetting::SetLocal(ClientContext &context, const Value &input) {
508: 	auto parameter = input.ToString();
509: 	auto &client_data = ClientData::Get(context);
510: 	client_data.catalog_search_path->Set(parameter, false);
511: }
512: 
513: Value SearchPathSetting::GetSetting(ClientContext &context) {
514: 	auto &client_data = ClientData::Get(context);
515: 	return Value(StringUtil::Join(client_data.catalog_search_path->GetSetPaths(), ","));
516: }
517: 
518: //===--------------------------------------------------------------------===//
519: // Temp Directory
520: //===--------------------------------------------------------------------===//
521: void TempDirectorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
522: 	config.temporary_directory = input.ToString();
523: 	config.use_temporary_directory = !config.temporary_directory.empty();
524: 	if (db) {
525: 		auto &buffer_manager = BufferManager::GetBufferManager(*db);
526: 		buffer_manager.SetTemporaryDirectory(config.temporary_directory);
527: 	}
528: }
529: 
530: Value TempDirectorySetting::GetSetting(ClientContext &context) {
531: 	auto &buffer_manager = BufferManager::GetBufferManager(context);
532: 	return Value(buffer_manager.GetTemporaryDirectory());
533: }
534: 
535: //===--------------------------------------------------------------------===//
536: // Threads Setting
537: //===--------------------------------------------------------------------===//
538: void ThreadsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
539: 	config.maximum_threads = input.GetValue<int64_t>();
540: 	if (db) {
541: 		TaskScheduler::GetScheduler(*db).SetThreads(config.maximum_threads);
542: 	}
543: }
544: 
545: Value ThreadsSetting::GetSetting(ClientContext &context) {
546: 	auto &config = DBConfig::GetConfig(context);
547: 	return Value::BIGINT(config.maximum_threads);
548: }
549: 
550: } // namespace duckdb
[end of src/main/settings/settings.cpp]
[start of src/parallel/task_scheduler.cpp]
1: #include "duckdb/parallel/task_scheduler.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/main/client_context.hpp"
5: #include "duckdb/main/database.hpp"
6: 
7: #ifndef DUCKDB_NO_THREADS
8: #include "concurrentqueue.h"
9: #include "lightweightsemaphore.h"
10: #include "duckdb/common/thread.hpp"
11: #else
12: #include <queue>
13: #endif
14: 
15: namespace duckdb {
16: 
17: struct SchedulerThread {
18: #ifndef DUCKDB_NO_THREADS
19: 	explicit SchedulerThread(unique_ptr<thread> thread_p) : internal_thread(move(thread_p)) {
20: 	}
21: 
22: 	unique_ptr<thread> internal_thread;
23: #endif
24: };
25: 
26: #ifndef DUCKDB_NO_THREADS
27: typedef duckdb_moodycamel::ConcurrentQueue<unique_ptr<Task>> concurrent_queue_t;
28: typedef duckdb_moodycamel::LightweightSemaphore lightweight_semaphore_t;
29: 
30: struct ConcurrentQueue {
31: 	concurrent_queue_t q;
32: 	lightweight_semaphore_t semaphore;
33: 
34: 	void Enqueue(ProducerToken &token, unique_ptr<Task> task);
35: 	bool DequeueFromProducer(ProducerToken &token, unique_ptr<Task> &task);
36: };
37: 
38: struct QueueProducerToken {
39: 	explicit QueueProducerToken(ConcurrentQueue &queue) : queue_token(queue.q) {
40: 	}
41: 
42: 	duckdb_moodycamel::ProducerToken queue_token;
43: };
44: 
45: void ConcurrentQueue::Enqueue(ProducerToken &token, unique_ptr<Task> task) {
46: 	lock_guard<mutex> producer_lock(token.producer_lock);
47: 	if (q.enqueue(token.token->queue_token, move(task))) {
48: 		semaphore.signal();
49: 	} else {
50: 		throw InternalException("Could not schedule task!");
51: 	}
52: }
53: 
54: bool ConcurrentQueue::DequeueFromProducer(ProducerToken &token, unique_ptr<Task> &task) {
55: 	lock_guard<mutex> producer_lock(token.producer_lock);
56: 	return q.try_dequeue_from_producer(token.token->queue_token, task);
57: }
58: 
59: #else
60: struct ConcurrentQueue {
61: 	std::queue<std::unique_ptr<Task>> q;
62: 	mutex qlock;
63: 
64: 	void Enqueue(ProducerToken &token, unique_ptr<Task> task);
65: 	bool DequeueFromProducer(ProducerToken &token, unique_ptr<Task> &task);
66: };
67: 
68: void ConcurrentQueue::Enqueue(ProducerToken &token, unique_ptr<Task> task) {
69: 	lock_guard<mutex> lock(qlock);
70: 	q.push(move(task));
71: }
72: 
73: bool ConcurrentQueue::DequeueFromProducer(ProducerToken &token, unique_ptr<Task> &task) {
74: 	lock_guard<mutex> lock(qlock);
75: 	if (q.empty()) {
76: 		return false;
77: 	}
78: 	task = move(q.front());
79: 	q.pop();
80: 	return true;
81: }
82: 
83: struct QueueProducerToken {
84: 	QueueProducerToken(ConcurrentQueue &queue) {
85: 	}
86: };
87: #endif
88: 
89: ProducerToken::ProducerToken(TaskScheduler &scheduler, unique_ptr<QueueProducerToken> token)
90:     : scheduler(scheduler), token(move(token)) {
91: }
92: 
93: ProducerToken::~ProducerToken() {
94: }
95: 
96: TaskScheduler::TaskScheduler() : queue(make_unique<ConcurrentQueue>()) {
97: }
98: 
99: TaskScheduler::~TaskScheduler() {
100: #ifndef DUCKDB_NO_THREADS
101: 	SetThreadsInternal(1);
102: #endif
103: }
104: 
105: TaskScheduler &TaskScheduler::GetScheduler(ClientContext &context) {
106: 	return TaskScheduler::GetScheduler(DatabaseInstance::GetDatabase(context));
107: }
108: 
109: TaskScheduler &TaskScheduler::GetScheduler(DatabaseInstance &db) {
110: 	return db.GetScheduler();
111: }
112: 
113: unique_ptr<ProducerToken> TaskScheduler::CreateProducer() {
114: 	auto token = make_unique<QueueProducerToken>(*queue);
115: 	return make_unique<ProducerToken>(*this, move(token));
116: }
117: 
118: void TaskScheduler::ScheduleTask(ProducerToken &token, unique_ptr<Task> task) {
119: 	// Enqueue a task for the given producer token and signal any sleeping threads
120: 	queue->Enqueue(token, move(task));
121: }
122: 
123: bool TaskScheduler::GetTaskFromProducer(ProducerToken &token, unique_ptr<Task> &task) {
124: 	return queue->DequeueFromProducer(token, task);
125: }
126: 
127: void TaskScheduler::ExecuteForever(atomic<bool> *marker) {
128: #ifndef DUCKDB_NO_THREADS
129: 	unique_ptr<Task> task;
130: 	// loop until the marker is set to false
131: 	while (*marker) {
132: 		// wait for a signal with a timeout; the timeout allows us to periodically check
133: 		queue->semaphore.wait(TASK_TIMEOUT_USECS);
134: 		if (queue->q.try_dequeue(task)) {
135: 			task->Execute(TaskExecutionMode::PROCESS_ALL);
136: 			task.reset();
137: 		}
138: 	}
139: #else
140: 	throw NotImplementedException("DuckDB was compiled without threads! Background thread loop is not allowed.");
141: #endif
142: }
143: 
144: #ifndef DUCKDB_NO_THREADS
145: static void ThreadExecuteTasks(TaskScheduler *scheduler, atomic<bool> *marker) {
146: 	scheduler->ExecuteForever(marker);
147: }
148: #endif
149: 
150: int32_t TaskScheduler::NumberOfThreads() {
151: 	return threads.size() + 1;
152: }
153: 
154: void TaskScheduler::SetThreads(int32_t n) {
155: #ifndef DUCKDB_NO_THREADS
156: 	if (n < 1) {
157: 		throw SyntaxException("Must have at least 1 thread!");
158: 	}
159: 	SetThreadsInternal(n);
160: #else
161: 	if (n != 1) {
162: 		throw NotImplementedException("DuckDB was compiled without threads! Setting threads > 1 is not allowed.");
163: 	}
164: #endif
165: }
166: 
167: void TaskScheduler::SetThreadsInternal(int32_t n) {
168: #ifndef DUCKDB_NO_THREADS
169: 	if (threads.size() == idx_t(n - 1)) {
170: 		return;
171: 	}
172: 	idx_t new_thread_count = n - 1;
173: 	if (threads.size() < new_thread_count) {
174: 		// we are increasing the number of threads: launch them and run tasks on them
175: 		idx_t create_new_threads = new_thread_count - threads.size();
176: 		for (idx_t i = 0; i < create_new_threads; i++) {
177: 			// launch a thread and assign it a cancellation marker
178: 			auto marker = unique_ptr<atomic<bool>>(new atomic<bool>(true));
179: 			auto worker_thread = make_unique<thread>(ThreadExecuteTasks, this, marker.get());
180: 			auto thread_wrapper = make_unique<SchedulerThread>(move(worker_thread));
181: 
182: 			threads.push_back(move(thread_wrapper));
183: 			markers.push_back(move(marker));
184: 		}
185: 	} else if (threads.size() > new_thread_count) {
186: 		// we are reducing the number of threads: cancel any threads exceeding new_thread_count
187: 		for (idx_t i = new_thread_count; i < threads.size(); i++) {
188: 			*markers[i] = false;
189: 		}
190: 		// now join the threads to ensure they are fully stopped before erasing them
191: 		for (idx_t i = new_thread_count; i < threads.size(); i++) {
192: 			threads[i]->internal_thread->join();
193: 		}
194: 		// erase the threads/markers
195: 		threads.resize(new_thread_count);
196: 		markers.resize(new_thread_count);
197: 	}
198: #endif
199: }
200: 
201: } // namespace duckdb
[end of src/parallel/task_scheduler.cpp]
[start of tools/juliapkg/src/api.jl]
1: using Base.Libc
2: 
3: if "JULIA_DUCKDB_LIBRARY" in keys(ENV)
4:     libduckdb = ENV["JULIA_DUCKDB_LIBRARY"]
5: else
6:     using DuckDB_jll
7: end
8: 
9: #=//===--------------------------------------------------------------------===//
10: // Open/Connect
11: //===--------------------------------------------------------------------===//
12: =#
13: """
14: 	duckdb_open(path, out_database)
15: Creates a new database or opens an existing database file stored at the the given path.
16: If no path is given a new in-memory database is created instead.
17: * `path`: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
18: * `out_database`: The result database object.
19: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
20: """
21: function duckdb_open(path, out_database)
22:     return ccall((:duckdb_open, libduckdb), duckdb_state, (Ptr{UInt8}, Ref{duckdb_database}), path, out_database)
23: end
24: """
25: 	Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the the given path.
26: 
27:     * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
28:     * out_database: The result database object.
29:     * config: (Optional) configuration used to start up the database system.
30:     * out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.
31:     Note that the error must be freed using `duckdb_free`.
32:     * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
33: """
34: function duckdb_open_ext(path, out_database, config, out_error)
35:     return ccall(
36:         (:duckdb_open_ext, libduckdb),
37:         duckdb_state,
38:         (Ptr{UInt8}, Ref{duckdb_database}, duckdb_config, Ptr{Ptr{UInt8}}),
39:         path,
40:         out_database,
41:         config,
42:         out_error
43:     )
44: end
45: """
46: 	duckdb_close(database)
47: Closes the specified database and de-allocates all memory allocated for that database.
48: This should be called after you are done with any database allocated through `duckdb_open`.
49: Note that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.
50: Still it is recommended to always correctly close a database object after you are done with it.
51: * `database`: The database object to shut down.
52: """
53: function duckdb_close(database)
54:     return ccall((:duckdb_close, libduckdb), Cvoid, (Ref{duckdb_database},), database)
55: end
56: """
57: 	duckdb_connect(database, out_connection)
58: Opens a connection to a database. Connections are required to query the database, and store transactional state
59: associated with the connection.
60: * `database`: The database file to connect to.
61: * `out_connection`: The result connection object.
62: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
63: """
64: function duckdb_connect(database, out_connection)
65:     return ccall(
66:         (:duckdb_connect, libduckdb),
67:         duckdb_state,
68:         (duckdb_database, Ref{duckdb_connection}),
69:         database,
70:         out_connection
71:     )
72: end
73: 
74: """
75: 	duckdb_disconnect(connection)
76: Closes the specified connection and de-allocates all memory allocated for that connection.
77: * `connection`: The connection to close.
78: """
79: function duckdb_disconnect(connection)
80:     return ccall((:duckdb_disconnect, libduckdb), Cvoid, (Ref{duckdb_connection},), connection)
81: end
82: 
83: #=
84: //===--------------------------------------------------------------------===//
85: // Configuration
86: //===--------------------------------------------------------------------===//
87: =#
88: 
89: """
90: 	duckdb_create_config(config)
91: Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance
92: through `duckdb_open_ext`.
93: This will always succeed unless there is a malloc failure.
94: * `out_config`: The result configuration object.
95: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
96: """
97: function duckdb_create_config(config)
98:     return ccall((:duckdb_create_config, libduckdb), duckdb_state, (Ref{duckdb_config},), config)
99: end
100: 
101: """
102: 	duckdb_config_count()
103: This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.
104: This should not be called in a loop as it internally loops over all the options.
105: * returns: The amount of config options available.
106: """
107: function duckdb_config_count()
108:     return ccall((:duckdb_config_count, libduckdb), Int32, ())
109: end
110: 
111: """
112: 	duckdb_get_config_flag(index,out_name,out_description)
113: Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.
114: display configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).
115: The result name or description MUST NOT be freed.
116: * `index`: The index of the configuration option (between 0 and `duckdb_config_count`)
117: * `out_name`: A name of the configuration flag.
118: * `out_description`: A description of the configuration flag.
119: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
120: """
121: function duckdb_get_config_flag(index, out_name, out_description)
122:     return ccall(
123:         (:duckdb_get_config_flag, libduckdb),
124:         duckdb_state,
125:         (Int32, Ptr{Ptr{UInt8}}, Ptr{Ptr{UInt8}}),
126:         index,
127:         out_name,
128:         out_description
129:     )
130: end
131: 
132: """
133: 	duckdb_set_config(config,name,option)
134: Sets the specified option for the specified configuration. The configuration option is indicated by name.
135: To obtain a list of config options, see `duckdb_get_config_flag`.
136: In the source code, configuration options are defined in `config.cpp`.
137: This can fail if either the name is invalid, or if the value provided for the option is invalid.
138: * `duckdb_config`: The configuration object to set the option on.
139: * `name`: The name of the configuration flag to set.
140: * `option`: The value to set the configuration flag to.
141: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
142: """
143: function duckdb_set_config(config, name, option)
144:     return ccall(
145:         (:duckdb_set_config, libduckdb),
146:         duckdb_state,
147:         (duckdb_config, Ptr{UInt8}, Ptr{UInt8}),
148:         config,
149:         name,
150:         option
151:     )
152: end
153: 
154: """
155: 	duckdb_destroy_config(config)
156: Destroys the specified configuration option and de-allocates all memory allocated for the object.
157: * `config`: The configuration object to destroy.
158: """
159: function duckdb_destroy_config(config)
160:     return ccall((:duckdb_destroy_config, libduckdb), Cvoid, (Ref{duckdb_config},), config)
161: end
162: 
163: # #=
164: # //===--------------------------------------------------------------------===//
165: # // Query Execution
166: # //===--------------------------------------------------------------------===//
167: # =#
168: #
169: # """
170: # 	duckdb_query(connection,query,out_result)
171: # Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.
172: # If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
173: # `duckdb_result_error`.
174: # Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the
175: # query fails, otherwise the error stored within the result will not be freed correctly.
176: # * `connection`: The connection to perform the query in.
177: # * `query`: The SQL query to run.
178: # * `out_result`: The query result.
179: # * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
180: # """
181: # function duckdb_query(connection, query, out_result)
182: #     return ccall(
183: #         (:duckdb_query, libduckdb),
184: #         Int32,
185: #         (Ptr{Cvoid}, Ptr{UInt8}, Ptr{Cvoid}),
186: #         connection[],
187: #         query,
188: #         out_result,
189: #     )
190: # end
191: #
192: """
193: 	duckdb_destroy_result(result)
194: Closes the result and de-allocates all memory allocated for that connection.
195: * `result`: The result to destroy.
196: """
197: function duckdb_destroy_result(result)
198:     return ccall((:duckdb_destroy_result, libduckdb), Cvoid, (Ref{duckdb_result},), result)
199: end
200: 
201: """
202: 	duckdb_column_name(result,col)
203: Returns the column name of the specified column. The result should not need be freed; the column names will
204: automatically be destroyed when the result is destroyed.
205: Returns `NULL` if the column is out of range.
206: * `result`: The result object to fetch the column name from.
207: * `col`: The column index.
208: * returns: The column name of the specified column.
209: """
210: function duckdb_column_name(result, col)
211:     return ccall((:duckdb_column_name, libduckdb), Ptr{UInt8}, (Ref{duckdb_result}, Int32), result, col - 1)
212: end
213: 
214: """
215: 	duckdb_column_type(result,col)
216: Returns the column type of the specified column.
217: Returns `DUCKDB_TYPE_INVALID` if the column is out of range.
218: * `result`: The result object to fetch the column type from.
219: * `col`: The column index.
220: * returns: The column type of the specified column.
221: """
222: function duckdb_column_type(result, col)
223:     return ccall((:duckdb_column_type, libduckdb), DUCKDB_TYPE, (Ref{duckdb_result}, Int32), result, col - 1)
224: end
225: 
226: """
227: Returns the logical column type of the specified column.
228: 
229: The return type of this call should be destroyed with `duckdb_destroy_logical_type`.
230: 
231: Returns `NULL` if the column is out of range.
232: 
233: * result: The result object to fetch the column type from.
234: * col: The column index.
235: * returns: The logical column type of the specified column.
236: """
237: function duckdb_column_logical_type(result, col)
238:     return ccall(
239:         (:duckdb_column_logical_type, libduckdb),
240:         duckdb_logical_type,
241:         (Ref{duckdb_result}, Int32),
242:         result,
243:         col - 1
244:     )
245: end
246: 
247: """
248: 	duckdb_column_count(result)
249: Returns the number of columns present in a the result object.
250: * `result`: The result object.
251: * returns: The number of columns present in the result object.
252: """
253: function duckdb_column_count(result)
254:     return ccall((:duckdb_column_count, libduckdb), Int32, (Ref{duckdb_result},), result)
255: end
256: 
257: """
258: 	duckdb_row_count(result)
259: Returns the number of rows present in a the result object.
260: * `result`: The result object.
261: * returns: The number of rows present in the result object.
262: """
263: function duckdb_row_count(result)
264:     return ccall((:duckdb_row_count, libduckdb), Int64, (Ref{duckdb_result},), result)
265: end
266: 
267: """
268: 	duckdb_rows_changed(result)
269: Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE
270: queries. For other queries the rows_changed will be 0.
271: * `result`: The result object.
272: * returns: The number of rows changed.
273: """
274: function duckdb_rows_changed(result)
275:     return ccall((:duckdb_rows_changed, libduckdb), Int64, (Ptr{Cvoid},), result)
276: end
277: 
278: """
279: 	duckdb_column_data(result,col)
280: Returns the data of a specific column of a result in columnar format. This is the fastest way of accessing data in a
281: query result, as no conversion or type checking must be performed (outside of the original switch). If performance
282: is a concern, it is recommended to use this API over the `duckdb_value` functions.
283: The function returns a dense array which contains the result data. The exact type stored in the array depends on the
284: corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
285: accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.
286: For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:
287: ```c
288: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
289: printf("Data for row %d: %d\\n", row, data[row]);
290: ```
291: * `result`: The result object to fetch the column data from.
292: * `col`: The column index.
293: * returns: The column data of the specified column.
294: """
295: function duckdb_column_data(result, col)
296:     return ccall((:duckdb_column_data, libduckdb), Ptr{Cvoid}, (Ref{duckdb_result}, Int32), result, col - 1)
297: end
298: 
299: """
300: 	duckdb_nullmask_data(result,col)
301: Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
302: whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
303: by `duckdb_column_data` are undefined.
304: ```c
305: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
306: bool *nullmask = duckdb_nullmask_data(&result, 0);
307: if (nullmask[row]) {
308:     printf("Data for row %d: NULL\n", row);
309: } else {
310:     printf("Data for row %d: %d\n", row, data[row]);
311: }
312: ```
313: * `result`: The result object to fetch the nullmask from.
314: * `col`: The column index.
315: * returns: The nullmask of the specified column.
316: """
317: function duckdb_nullmask_data(result, col)
318:     return ccall((:duckdb_nullmask_data, libduckdb), Ptr{Int32}, (Ref{duckdb_result}, Int32), result, col - 1)
319: end
320: 
321: """
322: 	duckdb_result_error(result)
323: Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.
324: The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.
325: * `result`: The result object to fetch the nullmask from.
326: * returns: The error of the result.
327: """
328: function duckdb_result_error(result)
329:     return ccall((:duckdb_result_error, libduckdb), Ptr{UInt8}, (Ref{duckdb_result},), result)
330: end
331: 
332: #=
333: //===--------------------------------------------------------------------===//
334: // Result Functions
335: //===--------------------------------------------------------------------===//
336: =#
337: 
338: """
339: Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.
340: 
341: This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data` functions.
342: It results in significantly better performance, and should be preferred in newer code-bases.
343: 
344: If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be mixed with the legacy result functions).
345: 
346: Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.
347: 
348: * result: The result object to fetch the data chunk from.
349: * chunk_index: The chunk index to fetch from.
350: * returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
351: """
352: function duckdb_result_get_chunk(result, chunk_index)
353:     return ccall(
354:         (:duckdb_result_get_chunk, libduckdb),
355:         duckdb_data_chunk,
356:         (duckdb_result, UInt64),
357:         result,
358:         chunk_index - 1
359:     )
360: end
361: 
362: """
363: Returns the number of data chunks present in the result.
364: 
365: * result: The result object
366: * returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
367: """
368: function duckdb_result_chunk_count(result)
369:     return ccall((:duckdb_result_chunk_count, libduckdb), UInt64, (duckdb_result,), result)
370: end
371: 
372: 
373: """
374: 	duckdb_value_boolean(result,col,row)
375: * returns: The boolean value at the specified location, or false if the value cannot be converted.
376: """
377: function duckdb_value_boolean(result, col, row)
378:     return ccall(
379:         (:duckdb_value_boolean, libduckdb),
380:         Int32,
381:         (Ref{duckdb_result}, Int32, Int32),
382:         result,
383:         col - 1,
384:         row - 1
385:     )
386: end
387: 
388: """
389: 	duckdb_value_int8(result,col,row)
390: * returns: The int8_t value at the specified location, or 0 if the value cannot be converted.
391: """
392: function duckdb_value_int8(result, col, row)
393:     return ccall((:duckdb_value_int8, libduckdb), Int8, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
394: end
395: 
396: """
397: 	duckdb_value_int16(result,col,row)
398:  * returns: The int16_t value at the specified location, or 0 if the value cannot be converted.
399: """
400: function duckdb_value_int16(result, col, row)
401:     return ccall((:duckdb_value_int16, libduckdb), Int16, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
402: end
403: 
404: """
405: 	duckdb_value_int32(result,col,row)
406:  * returns: The int32_t value at the specified location, or 0 if the value cannot be converted.
407: """
408: function duckdb_value_int32(result, col, row)
409:     return ccall((:duckdb_value_int32, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
410: end
411: 
412: """
413: 	duckdb_value_int64(result,col,row)
414:  * returns: The int64_t value at the specified location, or 0 if the value cannot be converted.
415: """
416: function duckdb_value_int64(result, col, row)
417:     return ccall((:duckdb_value_int64, libduckdb), Int64, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
418: end
419: 
420: """
421: 	duckdb_value_hugeint(result,col,row)
422:  * returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.
423: """
424: function duckdb_value_hugeint(result, col, row)
425:     return ccall(
426:         (:duckdb_value_hugeint, libduckdb),
427:         Int64,
428:         (Ref{duckdb_result}, Int32, Int32),
429:         result,
430:         col - 1,
431:         row - 1
432:     )
433: end
434: 
435: """
436: 	duckdb_value_uint8(result,col,row)
437:  * returns: The uint8_t value at the specified location, or 0 if the value cannot be converted.
438: 
439: """
440: function duckdb_value_uint8(result, col, row)
441:     return ccall((:duckdb_value_uint8, libduckdb), UInt8, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
442: end
443: 
444: """
445: 	duckdb_value_uint16(result,col,row)
446:  * returns: The uint16_t value at the specified location, or 0 if the value cannot be converted.
447: """
448: function duckdb_value_uint16(result, col, row)
449:     return ccall(
450:         (:duckdb_value_uint16, libduckdb),
451:         UInt16,
452:         (Ref{duckdb_result}, Int32, Int32),
453:         result,
454:         col - 1,
455:         row - 1
456:     )
457: end
458: 
459: """
460: 	duckdb_value_uint32(result,col,row)
461:  * returns: The uint32_t value at the specified location, or 0 if the value cannot be converted.
462: """
463: function duckdb_value_uint32(result, col, row)
464:     return ccall(
465:         (:duckdb_value_uint32, libduckdb),
466:         UInt32,
467:         (Ref{duckdb_result}, Int32, Int32),
468:         result,
469:         col - 1,
470:         row - 1
471:     )
472: end
473: 
474: """
475: 	duckdb_value_uint64(result,col,row)
476: * returns: The uint64_t value at the specified location, or 0 if the value cannot be converted.
477: """
478: function duckdb_value_uint64(result, col, row)
479:     return ccall(
480:         (:duckdb_value_uint64, libduckdb),
481:         UInt64,
482:         (Ref{duckdb_result}, Int32, Int32),
483:         result,
484:         col - 1,
485:         row - 1
486:     )
487: end
488: 
489: """
490: 	duckdb_value_float(result,col,row)
491:  * returns: The float value at the specified location, or 0 if the value cannot be converted.
492: """
493: function duckdb_value_float(result, col, row)
494:     return ccall(
495:         (:duckdb_value_float, libduckdb),
496:         Float32,
497:         (Ref{duckdb_result}, Int32, Int32),
498:         result,
499:         col - 1,
500:         row - 1
501:     )
502: end
503: 
504: """
505: 	duckdb_value_double(result,col,row)
506:  * returns: The double value at the specified location, or 0 if the value cannot be converted.
507: """
508: function duckdb_value_double(result, col, row)
509:     return ccall(
510:         (:duckdb_value_double, libduckdb),
511:         Float64,
512:         (Ref{duckdb_result}, Int32, Int32),
513:         result,
514:         col - 1,
515:         row - 1
516:     )
517: end
518: 
519: """
520: duckdb_value_date(result,col,row)
521:  * returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted.
522: DUCKDB_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);
523: """
524: function duckdb_value_date(result, col, row)
525:     return ccall((:duckdb_value_date, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
526: end
527: 
528: """
529: duckdb_value_time(result,col,row)
530:  * returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted.
531: DUCKDB_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);
532: """
533: function duckdb_value_time(result, col, row)
534:     return ccall((:duckdb_value_time, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
535: end
536: 
537: """
538: duckdb_value_timestamp(result,col,row)
539:  * returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.
540: DUCKDB_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);
541: """
542: function duckdb_value_timestamp(result, col, row)
543:     return ccall(
544:         (:duckdb_value_timestamp, libduckdb),
545:         Int32,
546:         (Ref{duckdb_result}, Int32, Int32),
547:         result,
548:         col - 1,
549:         row - 1
550:     )
551: end
552: 
553: """
554: duckdb_value_interval(result,col,row)
555:  * returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted.
556: DUCKDB_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);
557: """
558: function duckdb_value_interval(result, col, row)
559:     return ccall(
560:         (:duckdb_value_interval, libduckdb),
561:         Int32,
562:         (Ref{duckdb_result}, Int32, Int32),
563:         result,
564:         col - 1,
565:         row - 1
566:     )
567: end
568: 
569: """
570: duckdb_value_varchar(result,col,row)
571: * returns: The char* value at the specified location, or nullptr if the value cannot be converted.
572: The result must be freed with `duckdb_free`.
573: DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);
574: """
575: function duckdb_value_varchar(result, col, row)
576:     return ccall(
577:         (:duckdb_value_varchar, libduckdb),
578:         Ptr{UInt8},
579:         (Ref{duckdb_result}, Int32, Int32),
580:         result,
581:         col - 1,
582:         row - 1
583:     )
584: end
585: 
586: """
587: duckdb_value_varchar_internal(result,col,row)
588: * returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
589: If the column is NOT a VARCHAR column this function will return NULL.
590: The result must NOT be freed.
591: DUCKDB_API char *duckdb_value_varchar_internal(duckdb_result *result, idx_t col, idx_t row);
592: """
593: function duckdb_value_varchar_internal(result, col, row)
594:     return ccall(
595:         (:duckdb_value_varchar_internal, libduckdb),
596:         Ptr{UInt8},
597:         (Ref{duckdb_result}, Int32, Int32),
598:         result,
599:         col - 1,
600:         row - 1
601:     )
602: end
603: 
604: # """
605: # duckdb_value_blob(result,col,row)
606: # * returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the
607: # value cannot be converted. The resulting "blob.data" must be freed with `duckdb_free.`
608: # DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);
609: # """
610: # function duckdb_value_blob(result, col, row)
611: #     return ccall(
612: #         (:duckdb_value_blob, libduckdb),
613: #         Ptr{Cvoid},
614: #         (Ptr{Cvoid}, Int32, Int32),
615: #         result,
616: #         col - 1,
617: #         row - 1,
618: #     )
619: # end
620: 
621: """
622: duckdb_value_is_null(result,col,row)
623:  * returns: Returns true if the value at the specified index is NULL, and false otherwise.
624: DUCKDB_API bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row);
625: """
626: function duckdb_value_is_null(result, col, row)
627:     return ccall((:duckdb_value_is_null, libduckdb), Bool, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
628: end
629: 
630: #=
631: //===--------------------------------------------------------------------===//
632: // Helpers
633: //===--------------------------------------------------------------------===//
634: =#
635: 
636: 
637: """
638: duckdb_malloc(size)
639: 
640: Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner
641: should be freed using `duckdb_free`.
642: * size: The number of bytes to allocate.
643: * returns: A pointer to the allocated memory region.
644: DUCKDB_API void *duckdb_malloc(size_t size);
645: """
646: function duckdb_malloc(size)
647:     return ccall((:duckdb_malloc, libduckdb), Cvoid, (Csize_t,), size)
648: end
649: 
650: """
651: duckdb_free(ptr)
652: Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_value_blob`.
653: * ptr: The memory region to de-allocate.
654: DUCKDB_API void duckdb_free(void *ptr);
655: """
656: function duckdb_free(ptr)
657:     return ccall((:duckdb_malloc, libduckdb), Cvoid, (Ptr{Cvoid},), ptr)
658: end
659: 
660: """
661: The internal vector size used by DuckDB.
662: This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.
663: 
664: * returns: The vector size.
665: """
666: function duckdb_vector_size()
667:     return ccall((:duckdb_vector_size, libduckdb), UInt64, ())
668: end
669: 
670: # #=
671: # //===--------------------------------------------------------------------===//
672: # // Date/Time/Timestamp Helpers
673: # //===--------------------------------------------------------------------===//
674: # =#
675: #
676: #
677: # """
678: # duckdb_from_date(date)
679: # Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).
680: # * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
681: # * returns: The `duckdb_date_struct` with the decomposed elements.
682: # DUCKDB_API duckdb_date_struct duckdb_from_date(duckdb_date date);
683: # """
684: # function duckdb_from_date(date)
685: #     return ccall((:duckdb_from_date, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), date)
686: # end
687: #
688: # """
689: # duckdb_to_date(date)
690: # Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).
691: # * date: The year, month and date stored in a `duckdb_date_struct`.
692: # * returns: The `duckdb_date` element.
693: # DUCKDB_API duckdb_date duckdb_to_date(duckdb_date_struct date);
694: # """
695: # function duckdb_to_date(date)
696: #     return ccall((:duckdb_to_date, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), date)
697: # end
698: #
699: # """
700: # duckdb_from_time(time)
701: # Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).
702: # * time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.
703: # * returns: The `duckdb_time_struct` with the decomposed elements.
704: # DUCKDB_API duckdb_time_struct duckdb_from_time(duckdb_time time);
705: # """
706: # function duckdb_from_time(time)
707: #     return ccall((:duckdb_from_time, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), time)
708: # end
709: #
710: # """
711: # duckdb_to_time(time)
712: # Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).
713: # * time: The hour, minute, second and microsecond in a `duckdb_time_struct`.
714: # * returns: The `duckdb_time` element.
715: # DUCKDB_API duckdb_time duckdb_to_time(duckdb_time_struct time);
716: # """
717: # function duckdb_to_time(time)
718: #     return ccall((:duckdb_to_time, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), time)
719: # end
720: #
721: # """
722: # duckdb_from_timestamp(ts)
723: # Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.
724: # * ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
725: # * returns: The `duckdb_timestamp_struct` with the decomposed elements.
726: # DUCKDB_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts);
727: # """
728: # function duckdb_from_timestamp(ts)
729: #     return ccall((:duckdb_from_timestamp, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), ts)
730: # end
731: #
732: # """
733: # duckdb_to_timestamp(ts)
734: # Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.
735: # * ts: The de-composed elements in a `duckdb_timestamp_struct`.
736: # * returns: The `duckdb_timestamp` element.
737: # */
738: # DUCKDB_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts);
739: # """
740: # function duckdb_to_timestamp(ts)
741: #     return ccall((:duckdb_to_timestamp, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), ts)
742: # end
743: #
744: # #=
745: # //===--------------------------------------------------------------------===//
746: # // Hugeint Helpers
747: # //===--------------------------------------------------------------------===//
748: # =#
749: #
750: #
751: # """
752: # duckdb_hugeint_to_double(val)
753: # Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.
754: # * val: The hugeint value.
755: # * returns: The converted `double` element.
756: # DUCKDB_API double duckdb_hugeint_to_double(duckdb_hugeint val);
757: # """
758: # function duckdb_hugeint_to_double(val)
759: #     return ccall((:duckdb_hugeint_to_double, libduckdb), Float64, (Int64,), val)
760: # end
761: #
762: # """
763: # duckdb_double_to_hugeint(val)
764: # Converts a double value to a duckdb_hugeint object.
765: # If the conversion fails because the double value is too big the result will be 0.
766: # * val: The double value.
767: # * returns: The converted `duckdb_hugeint` element.
768: # DUCKDB_API duckdb_hugeint duckdb_double_to_hugeint(double val);
769: # """
770: # function duckdb_double_to_hugeint(val)
771: #     return ccall((:duckdb_double_to_hugeint, libduckdb), Int64, (Float64,), val)
772: # end
773: #
774: # #=
775: # //===--------------------------------------------------------------------===//
776: # // Prepared Statements
777: # //===--------------------------------------------------------------------===//
778: # // A prepared statement is a parameterized query that allows you to bind parameters to it.
779: # // * This is useful to easily supply parameters to functions and avoid SQL injection attacks.
780: # // * This is useful to speed up queries that you will execute several times with different parameters.
781: # // Because the query will only be parsed, bound, optimized and planned once during the prepare stage,
782: # // rather than once per execution.
783: # // For example:
784: # //   SELECT * FROM tbl WHERE id=?
785: # // Or a query with multiple parameters:
786: # //   SELECT * FROM tbl WHERE id=$1 OR name=$2
787: # =#
788: 
789: 
790: """
791: Create a prepared statement object from a query.
792: Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using
793: `duckdb_destroy_prepare`, even if the prepare fails.
794: If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
795: * connection: The connection object
796: * query: The SQL query to prepare
797: * out_prepared_statement: The resulting prepared statement object
798: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
799: DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
800:                                        duckdb_prepared_statement *out_prepared_statement);
801: """
802: function duckdb_prepare(connection, query, out_prepared_statement)
803:     return ccall(
804:         (:duckdb_prepare, libduckdb),
805:         duckdb_state,
806:         (duckdb_connection, Ptr{UInt8}, Ref{duckdb_prepared_statement}),
807:         connection,
808:         query,
809:         out_prepared_statement
810:     )
811: end
812: 
813: """
814: Closes the prepared statement and de-allocates all memory allocated for that connection.
815: * prepared_statement: The prepared statement to destroy.
816: DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);
817: """
818: function duckdb_destroy_prepare(prepared_statement)
819:     return ccall((:duckdb_destroy_prepare, libduckdb), Cvoid, (Ref{duckdb_prepared_statement},), prepared_statement)
820: end
821: 
822: """
823: Returns the error message associated with the given prepared statement.
824: If the prepared statement has no error message, this returns `nullptr` instead.
825: The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.
826: * prepared_statement: The prepared statement to obtain the error from.
827: * returns: The error message, or `nullptr` if there is none.
828: DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);
829: """
830: function duckdb_prepare_error(prepared_statement)
831:     return ccall((:duckdb_prepare_error, libduckdb), Ptr{UInt8}, (duckdb_prepared_statement,), prepared_statement[])
832: end
833: 
834: """
835: Returns the number of parameters that can be provided to the given prepared statement.
836: Returns 0 if the query was not successfully prepared.
837: * prepared_statement: The prepared statement to obtain the number of parameters for.
838: DUCKDB_API idx_t duckdb_nparams(duckdb_prepared_statement prepared_statement);
839: """
840: function duckdb_nparams(prepared_statement)
841:     return ccall((:duckdb_nparams, libduckdb), Int32, (duckdb_prepared_statement,), prepared_statement)
842: end
843: 
844: """
845: Returns the parameter type for the parameter at the given index.
846: Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.
847: * prepared_statement: The prepared statement.
848: * param_idx: The parameter index.
849: * returns: The parameter type
850: DUCKDB_API duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_t param_idx);
851: """
852: function duckdb_param_type(prepared_statement, param_idx)
853:     return ccall(
854:         (:duckdb_param_type, libduckdb),
855:         Int32,
856:         (duckdb_prepared_statement, Int32),
857:         prepared_statement,
858:         param_idx
859:     )
860: end
861: 
862: """
863: Binds a bool value to the prepared statement at the specified index.
864: DUCKDB_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);
865: """
866: function duckdb_bind_boolean(prepared_statement, param_idx, val)
867:     return ccall(
868:         (:duckdb_bind_boolean, libduckdb),
869:         duckdb_state,
870:         (duckdb_prepared_statement, Int32, Int32),
871:         prepared_statement,
872:         param_idx,
873:         val
874:     )
875: end
876: 
877: """
878: Binds an int8_t value to the prepared statement at the specified index.
879: DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
880: """
881: function duckdb_bind_int8(prepared_statement, param_idx, val)
882:     return ccall(
883:         (:duckdb_bind_int8, libduckdb),
884:         duckdb_state,
885:         (duckdb_prepared_statement, Int32, Int8),
886:         prepared_statement,
887:         param_idx,
888:         val
889:     )
890: end
891: 
892: """
893: Binds an int16_t value to the prepared statement at the specified index.
894: DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
895: """
896: function duckdb_bind_int16(prepared_statement, param_idx, val)
897:     return ccall(
898:         (:duckdb_bind_int16, libduckdb),
899:         duckdb_state,
900:         (duckdb_prepared_statement, Int32, Int16),
901:         prepared_statement,
902:         param_idx,
903:         val
904:     )
905: end
906: 
907: """
908: Binds an int32_t value to the prepared statement at the specified index.
909: DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);
910: """
911: function duckdb_bind_int32(prepared_statement, param_idx, val)
912:     return ccall(
913:         (:duckdb_bind_int32, libduckdb),
914:         duckdb_state,
915:         (duckdb_prepared_statement, Int32, Int32),
916:         prepared_statement,
917:         param_idx,
918:         val
919:     )
920: end
921: 
922: """
923: Binds an int64_t value to the prepared statement at the specified index.
924: DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);
925: """
926: function duckdb_bind_int64(prepared_statement, param_idx, val)
927:     return ccall(
928:         (:duckdb_bind_int64, libduckdb),
929:         duckdb_state,
930:         (duckdb_prepared_statement, Int32, Int64),
931:         prepared_statement,
932:         param_idx,
933:         val
934:     )
935: end
936: 
937: """
938: Binds an duckdb_hugeint value to the prepared statement at the specified index.
939: */
940: DUCKDB_API duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,
941:                                             duckdb_hugeint val);
942: """
943: function duckdb_bind_hugeint(prepared_statement, param_idx, val)
944:     return ccall(
945:         (:duckdb_bind_hugeint, libduckdb),
946:         duckdb_state,
947:         (duckdb_prepared_statement, Int32, duckdb_hugeint),
948:         prepared_statement,
949:         param_idx,
950:         val
951:     )
952: end
953: 
954: """
955: Binds an uint8_t value to the prepared statement at the specified index.
956: DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);
957: """
958: function duckdb_bind_uint8(prepared_statement, param_idx, val)
959:     return ccall(
960:         (:duckdb_bind_uint8, libduckdb),
961:         duckdb_state,
962:         (duckdb_prepared_statement, Int32, UInt8),
963:         prepared_statement,
964:         param_idx,
965:         val
966:     )
967: end
968: 
969: """
970: Binds an uint16_t value to the prepared statement at the specified index.
971: DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val);
972: """
973: function duckdb_bind_uint16(prepared_statement, param_idx, val)
974:     return ccall(
975:         (:duckdb_bind_uint16, libduckdb),
976:         duckdb_state,
977:         (duckdb_prepared_statement, Int32, UInt16),
978:         prepared_statement,
979:         param_idx,
980:         val
981:     )
982: end
983: 
984: """
985: Binds an uint32_t value to the prepared statement at the specified index.
986: DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);
987: """
988: function duckdb_bind_uint32(prepared_statement, param_idx, val)
989:     return ccall(
990:         (:duckdb_bind_uint32, libduckdb),
991:         duckdb_state,
992:         (duckdb_prepared_statement, Int32, UInt32),
993:         prepared_statement,
994:         param_idx,
995:         val
996:     )
997: end
998: 
999: """
1000: Binds an uint64_t value to the prepared statement at the specified index.
1001: DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);
1002: """
1003: function duckdb_bind_uint64(prepared_statement, param_idx, val)
1004:     return ccall(
1005:         (:duckdb_bind_uint64, libduckdb),
1006:         duckdb_state,
1007:         (duckdb_prepared_statement, Int32, UInt64),
1008:         prepared_statement,
1009:         param_idx,
1010:         val
1011:     )
1012: end
1013: 
1014: """
1015: Binds an float value to the prepared statement at the specified index.
1016: DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);
1017: """
1018: function duckdb_bind_float(prepared_statement, param_idx, val)
1019:     return ccall(
1020:         (:duckdb_bind_float, libduckdb),
1021:         duckdb_state,
1022:         (duckdb_prepared_statement, Int32, Float32),
1023:         prepared_statement,
1024:         param_idx,
1025:         val
1026:     )
1027: end
1028: 
1029: """
1030: Binds an double value to the prepared statement at the specified index.
1031: DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);
1032: """
1033: function duckdb_bind_double(prepared_statement, param_idx, val)
1034:     return ccall(
1035:         (:duckdb_bind_double, libduckdb),
1036:         duckdb_state,
1037:         (duckdb_prepared_statement, Int32, Float64),
1038:         prepared_statement,
1039:         param_idx,
1040:         val
1041:     )
1042: end
1043: 
1044: """
1045: Binds a duckdb_date value to the prepared statement at the specified index.
1046: DUCKDB_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1047:                                          duckdb_date val);
1048: """
1049: function duckdb_bind_date(prepared_statement, param_idx, val)
1050:     return ccall(
1051:         (:duckdb_bind_date, libduckdb),
1052:         duckdb_state,
1053:         (duckdb_prepared_statement, Int32, Int32),
1054:         prepared_statement,
1055:         param_idx,
1056:         val
1057:     )
1058: end
1059: 
1060: """
1061: Binds a duckdb_time value to the prepared statement at the specified index.
1062: DUCKDB_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1063:                                          duckdb_time val);
1064: """
1065: function duckdb_bind_time(prepared_statement, param_idx, val)
1066:     return ccall(
1067:         (:duckdb_bind_time, libduckdb),
1068:         duckdb_state,
1069:         (duckdb_prepared_statement, Int32, Int64),
1070:         prepared_statement,
1071:         param_idx,
1072:         val
1073:     )
1074: end
1075: 
1076: """
1077: Binds a duckdb_timestamp value to the prepared statement at the specified index.
1078: DUCKDB_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1079:                                               duckdb_timestamp val);
1080: """
1081: function duckdb_bind_timestamp(prepared_statement, param_idx, val)
1082:     return ccall(
1083:         (:duckdb_bind_timestamp, libduckdb),
1084:         duckdb_state,
1085:         (duckdb_prepared_statement, Int32, Int64),
1086:         prepared_statement,
1087:         param_idx,
1088:         val
1089:     )
1090: end
1091: 
1092: """
1093: Binds a duckdb_interval value to the prepared statement at the specified index.
1094: DUCKDB_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1095:                                              duckdb_interval val);
1096: """
1097: function duckdb_bind_interval(prepared_statement, param_idx, val)
1098:     return ccall(
1099:         (:duckdb_bind_interval, libduckdb),
1100:         duckdb_state,
1101:         (duckdb_prepared_statement, Int32, Int32),
1102:         prepared_statement,
1103:         param_idx,
1104:         val
1105:     )
1106: end
1107: 
1108: """
1109: Binds a null-terminated varchar value to the prepared statement at the specified index.
1110: DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1111:                                             const char *val);
1112: """
1113: function duckdb_bind_varchar(prepared_statement, param_idx, val)
1114:     return ccall(
1115:         (:duckdb_bind_varchar, libduckdb),
1116:         duckdb_state,
1117:         (duckdb_prepared_statement, Int32, Ptr{UInt8}),
1118:         prepared_statement,
1119:         param_idx,
1120:         val
1121:     )
1122: end
1123: 
1124: """
1125: Binds a varchar value to the prepared statement at the specified index.
1126: DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1127:                                                    const char *val, idx_t length);
1128: """
1129: function duckdb_bind_varchar_length(prepared_statement, param_idx, val, length)
1130:     return ccall(
1131:         (:duckdb_bind_varchar_length, libduckdb),
1132:         duckdb_state,
1133:         (duckdb_prepared_statement, Int32, Ptr{UInt8}, Int32),
1134:         prepared_statement,
1135:         param_idx,
1136:         val,
1137:         length
1138:     )
1139: end
1140: 
1141: """
1142: Binds a blob value to the prepared statement at the specified index.
1143: DUCKDB_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1144:                                          const void *data, idx_t length);
1145: """
1146: function duckdb_bind_blob(prepared_statement, param_idx, val, length)
1147:     return ccall(
1148:         (:duckdb_bind_blob, libduckdb),
1149:         duckdb_state,
1150:         (duckdb_prepared_statement, Int32, Ptr{Cvoid}, Int32),
1151:         prepared_statement,
1152:         param_idx,
1153:         data,
1154:         length
1155:     )
1156: end
1157: 
1158: """
1159: Binds a NULL value to the prepared statement at the specified index.
1160: DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);
1161: """
1162: function duckdb_bind_null(prepared_statement, param_idx)
1163:     return ccall(
1164:         (:duckdb_bind_null, libduckdb),
1165:         duckdb_state,
1166:         (duckdb_prepared_statement, Int32),
1167:         prepared_statement,
1168:         param_idx
1169:     )
1170: end
1171: 
1172: """
1173: Executes the prepared statement with the given bound parameters, and returns a materialized query result.
1174: This method can be called multiple times for each prepared statement, and the parameters can be modified
1175: between calls to this function.
1176: * prepared_statement: The prepared statement to execute.
1177: * out_result: The query result.
1178: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1179: DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,
1180:                                                 duckdb_result *out_result);
1181: """
1182: function duckdb_execute_prepared(prepared_statement, out_result)
1183:     return ccall(
1184:         (:duckdb_execute_prepared, libduckdb),
1185:         duckdb_state,
1186:         (duckdb_prepared_statement, Ref{duckdb_result}),
1187:         prepared_statement,
1188:         out_result
1189:     )
1190: end
1191: 
1192: # """
1193: # Executes the prepared statement with the given bound parameters, and returns an arrow query result.
1194: # * prepared_statement: The prepared statement to execute.
1195: # * out_result: The query result.
1196: # * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1197: # DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,
1198: #                                                       duckdb_arrow *out_result);
1199: # """
1200: # function duckdb_execute_prepared_arrow(prepared_statement, out_result)
1201: #     return ccall(
1202: #         (:duckdb_execute_prepared_arrow, libduckdb),
1203: #         duckdb_state,
1204: #         (Ptr{Cvoid}, Ptr{Cvoid}),
1205: #         prepared_statement,
1206: #         out_result,
1207: #     )
1208: # end
1209: 
1210: 
1211: #=
1212: //===--------------------------------------------------------------------===//
1213: // Value Interface
1214: //===--------------------------------------------------------------------===//
1215: =#
1216: """
1217: Destroys the value and de-allocates all memory allocated for that type.
1218: 
1219: * value: The value to destroy.
1220: """
1221: function duckdb_destroy_value(handle)
1222:     return ccall((:duckdb_destroy_value, libduckdb), Cvoid, (Ref{duckdb_value},), handle)
1223: end
1224: 
1225: """
1226: Creates a value from a null-terminated string
1227: 
1228: * value: The null-terminated string
1229: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
1230: """
1231: function duckdb_create_varchar(handle)
1232:     return ccall((:duckdb_create_varchar, libduckdb), duckdb_value, (Ptr{UInt8},), handle)
1233: end
1234: 
1235: """
1236: Creates a value from a string
1237: 
1238: * value: The text
1239: * length: The length of the text
1240: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
1241: """
1242: function duckdb_create_varchar_length(text, len)
1243:     return ccall((:duckdb_create_varchar_length, libduckdb), duckdb_value, (Ptr{UInt8}, UInt64), text, len)
1244: end
1245: 
1246: 
1247: """
1248: Creates a value from an int64
1249: 
1250: * value: The bigint value
1251: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
1252: """
1253: function duckdb_create_int64(handle)
1254:     return ccall((:duckdb_create_int64, libduckdb), duckdb_value, (Int64,), handle)
1255: end
1256: 
1257: """
1258: Obtains a string representation of the given value.
1259: The result must be destroyed with `duckdb_free`.
1260: 
1261: * value: The value
1262: * returns: The string value. This must be destroyed with `duckdb_free`.
1263: """
1264: function duckdb_get_varchar(handle)
1265:     return ccall((:duckdb_get_varchar, libduckdb), Ptr{UInt8}, (duckdb_value,), handle)
1266: end
1267: 
1268: """
1269: Obtains an int64 of the given value.
1270: 
1271: * value: The value
1272: * returns: The int64 value, or 0 if no conversion is possible
1273: """
1274: function duckdb_get_int64(handle)
1275:     return ccall((:duckdb_get_int64, libduckdb), Int64, (duckdb_value,), handle)
1276: end
1277: 
1278: #=
1279: //===--------------------------------------------------------------------===//
1280: // Logical Type Interface
1281: //===--------------------------------------------------------------------===//
1282: =#
1283: """
1284: Creates a `duckdb_logical_type` from a standard primitive type.
1285: The resulting type should be destroyed with `duckdb_destroy_logical_type`.
1286: 
1287: This should not be used with `DUCKDB_TYPE_DECIMAL`.
1288: 
1289: * type: The primitive type to create.
1290: * returns: The logical type type.
1291: """
1292: function duckdb_create_logical_type(type)
1293:     return ccall((:duckdb_create_logical_type, libduckdb), duckdb_logical_type, (Int32,), type)
1294: end
1295: 
1296: """
1297: Creates a `duckdb_logical_type` of type decimal with the specified width and scale
1298: The resulting type should be destroyed with `duckdb_destroy_logical_type`.
1299: 
1300: * width: The width of the decimal type
1301: * scale: The scale of the decimal type
1302: * returns: The logical type.
1303: """
1304: function duckdb_create_decimal_type(width, scale)
1305:     return ccall((:duckdb_create_decimal_type, libduckdb), duckdb_logical_type, (UInt8, UInt8), width, scale)
1306: end
1307: 
1308: 
1309: """
1310: Retrieves the type class of a `duckdb_logical_type`.
1311: 
1312: * type: The logical type object
1313: * returns: The type id
1314: """
1315: function duckdb_get_type_id(handle)
1316:     return ccall((:duckdb_get_type_id, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)
1317: end
1318: 
1319: """
1320: Retrieves the width of a decimal type.
1321: 
1322: * type: The logical type object
1323: * returns: The width of the decimal type
1324: """
1325: function duckdb_decimal_width(handle)
1326:     return ccall((:duckdb_decimal_width, libduckdb), UInt8, (duckdb_logical_type,), handle)
1327: end
1328: 
1329: """
1330: Retrieves the scale of a decimal type.
1331: 
1332: * type: The logical type object
1333: * returns: The scale of the decimal type
1334: """
1335: function duckdb_decimal_scale(handle)
1336:     return ccall((:duckdb_decimal_scale, libduckdb), UInt8, (duckdb_logical_type,), handle)
1337: end
1338: 
1339: """
1340: Retrieves the internal storage type of a decimal type.
1341: 
1342: * type: The logical type object
1343: * returns: The internal type of the decimal type
1344: """
1345: function duckdb_decimal_internal_type(handle)
1346:     return ccall((:duckdb_decimal_internal_type, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)
1347: end
1348: 
1349: """
1350: Retrieves the internal storage type of an enum type.
1351: 
1352: * type: The logical type object
1353: * returns: The internal type of the enum type
1354: """
1355: function duckdb_enum_internal_type(handle)
1356:     return ccall((:duckdb_enum_internal_type, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)
1357: end
1358: 
1359: """
1360: Retrieves the dictionary size of the enum type
1361: 
1362: * type: The logical type object
1363: * returns: The dictionary size of the enum type
1364: """
1365: function duckdb_enum_dictionary_size(handle)
1366:     return ccall((:duckdb_enum_dictionary_size, libduckdb), UInt32, (duckdb_logical_type,), handle)
1367: end
1368: 
1369: """
1370: Retrieves the dictionary value at the specified position from the enum.
1371: 
1372: The result must be freed with `duckdb_free`
1373: 
1374: * type: The logical type object
1375: * index: The index in the dictionary
1376: * returns: The string value of the enum type. Must be freed with `duckdb_free`.
1377: """
1378: function duckdb_enum_dictionary_value(handle, index)
1379:     return ccall(
1380:         (:duckdb_enum_dictionary_value, libduckdb),
1381:         Ptr{UInt8},
1382:         (duckdb_logical_type, UInt64),
1383:         handle,
1384:         index - 1
1385:     )
1386: end
1387: 
1388: """
1389: Retrieves the child type of the given list type.
1390: 
1391: The result must be freed with `duckdb_destroy_logical_type`
1392: 
1393: * type: The logical type object
1394: * returns: The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`.
1395: """
1396: function duckdb_list_type_child_type(handle)
1397:     return ccall((:duckdb_list_type_child_type, libduckdb), duckdb_logical_type, (duckdb_logical_type,), handle)
1398: end
1399: 
1400: """
1401: Returns the number of children of a struct type.
1402: 
1403: * type: The logical type object
1404: * returns: The number of children of a struct type.
1405: """
1406: function duckdb_struct_type_child_count(handle)
1407:     return ccall((:duckdb_struct_type_child_count, libduckdb), UInt64, (duckdb_logical_type,), handle)
1408: end
1409: 
1410: """
1411: Retrieves the name of the struct child.
1412: 
1413: The result must be freed with `duckdb_free`
1414: 
1415: * type: The logical type object
1416: * index: The child index
1417: * returns: The name of the struct type. Must be freed with `duckdb_free`.
1418: """
1419: function duckdb_struct_type_child_name(handle, index)
1420:     return ccall(
1421:         (:duckdb_struct_type_child_name, libduckdb),
1422:         Ptr{UInt8},
1423:         (duckdb_logical_type, UInt64),
1424:         handle,
1425:         index - 1
1426:     )
1427: end
1428: 
1429: """
1430: Retrieves the child type of the given struct type at the specified index.
1431: 
1432: The result must be freed with `duckdb_destroy_logical_type`
1433: 
1434: * type: The logical type object
1435: * index: The child index
1436: * returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.
1437: """
1438: function duckdb_struct_type_child_type(handle, index)
1439:     return ccall(
1440:         (:duckdb_struct_type_child_type, libduckdb),
1441:         duckdb_logical_type,
1442:         (duckdb_logical_type, UInt64),
1443:         handle,
1444:         index - 1
1445:     )
1446: end
1447: 
1448: """
1449: Destroys the logical type and de-allocates all memory allocated for that type.
1450: 
1451: * type: The logical type to destroy.
1452: """
1453: function duckdb_destroy_logical_type(handle)
1454:     return ccall((:duckdb_destroy_logical_type, libduckdb), Cvoid, (Ref{duckdb_logical_type},), handle)
1455: end
1456: 
1457: #=
1458: //===--------------------------------------------------------------------===//
1459: // Data Chunk Interface
1460: //===--------------------------------------------------------------------===//
1461: =#
1462: """
1463: Creates an empty DataChunk with the specified set of types.
1464: 
1465: * types: An array of types of the data chunk.
1466: * column_count: The number of columns.
1467: * returns: The data chunk.
1468: """
1469: function duckdb_create_data_chunk(types, column_count)
1470:     return ccall(
1471:         (:duckdb_create_data_chunk, libduckdb),
1472:         duckdb_data_chunk,
1473:         (Ptr{duckdb_logical_type}, UInt64),
1474:         types,
1475:         column_count
1476:     )
1477: end
1478: 
1479: """
1480: Destroys the data chunk and de-allocates all memory allocated for that chunk.
1481: 
1482: * chunk: The data chunk to destroy.
1483: """
1484: function duckdb_destroy_data_chunk(chunk)
1485:     return ccall((:duckdb_destroy_data_chunk, libduckdb), Cvoid, (Ref{duckdb_data_chunk},), chunk)
1486: end
1487: 
1488: """
1489: Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.
1490: 
1491: * chunk: The data chunk to reset.
1492: """
1493: function duckdb_data_chunk_reset(chunk)
1494:     return ccall((:duckdb_data_chunk_reset, libduckdb), Cvoid, (duckdb_data_chunk,), chunk)
1495: end
1496: 
1497: """
1498: Retrieves the number of columns in a data chunk.
1499: 
1500: * chunk: The data chunk to get the data from
1501: * returns: The number of columns in the data chunk
1502: """
1503: function duckdb_data_chunk_get_column_count(chunk)
1504:     return ccall((:duckdb_data_chunk_get_column_count, libduckdb), UInt64, (duckdb_data_chunk,), chunk)
1505: end
1506: 
1507: 
1508: """
1509: Retrieves the current number of tuples in a data chunk.
1510: 
1511: * chunk: The data chunk to get the data from
1512: * returns: The number of tuples in the data chunk
1513: """
1514: function duckdb_data_chunk_get_size(chunk)
1515:     return ccall((:duckdb_data_chunk_get_size, libduckdb), UInt64, (duckdb_data_chunk,), chunk)
1516: end
1517: 
1518: """
1519: Sets the current number of tuples in a data chunk.
1520: 
1521: * chunk: The data chunk to set the size in
1522: * size: The number of tuples in the data chunk
1523: """
1524: function duckdb_data_chunk_set_size(chunk, size)
1525:     return ccall((:duckdb_data_chunk_set_size, libduckdb), Cvoid, (duckdb_data_chunk, UInt64), chunk, size)
1526: end
1527: 
1528: """
1529: Retrieves the vector at the specified column index in the data chunk.
1530: 
1531: The pointer to the vector is valid for as long as the chunk is alive.
1532: It does NOT need to be destroyed.
1533: 
1534: * chunk: The data chunk to get the data from
1535: * returns: The vector
1536: """
1537: function duckdb_data_chunk_get_vector(chunk, col_idx)
1538:     return ccall(
1539:         (:duckdb_data_chunk_get_vector, libduckdb),
1540:         duckdb_vector,
1541:         (duckdb_data_chunk, UInt64),
1542:         chunk,
1543:         col_idx - 1
1544:     )
1545: end
1546: 
1547: #=
1548: //===--------------------------------------------------------------------===//
1549: // Vector Functions
1550: //===--------------------------------------------------------------------===//
1551: =#
1552: """
1553: Retrieves the column type of the specified vector.
1554: 
1555: The result must be destroyed with `duckdb_destroy_logical_type`.
1556: 
1557: * vector: The vector get the data from
1558: * returns: The type of the vector
1559: """
1560: function duckdb_vector_get_column_type(vector)
1561:     return ccall((:duckdb_vector_get_column_type, libduckdb), duckdb_logical_type, (duckdb_vector,), vector)
1562: end
1563: 
1564: """
1565: Retrieves the data pointer of the vector.
1566: 
1567: The data pointer can be used to read or write values from the vector.
1568: How to read or write values depends on the type of the vector.
1569: 
1570: * vector: The vector to get the data from
1571: * returns: The data pointer
1572: """
1573: function duckdb_vector_get_data(vector)
1574:     return ccall((:duckdb_vector_get_data, libduckdb), Ptr{Cvoid}, (duckdb_vector,), vector)
1575: end
1576: 
1577: """
1578: Retrieves the validity mask pointer of the specified vector.
1579: 
1580: If all values are valid, this function MIGHT return NULL!
1581: 
1582: The validity mask is a bitset that signifies null-ness within the data chunk.
1583: It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.
1584: The bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).
1585: 
1586: Validity of a specific value can be obtained like this:
1587: 
1588: idx_t entry_idx = row_idx / 64;
1589: idx_t idx_in_entry = row_idx % 64;
1590: bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);
1591: 
1592: Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.
1593: 
1594: * vector: The vector to get the data from
1595: * returns: The pointer to the validity mask, or NULL if no validity mask is present
1596: """
1597: function duckdb_vector_get_validity(vector)
1598:     return ccall((:duckdb_vector_get_validity, libduckdb), Ptr{UInt64}, (duckdb_vector,), vector)
1599: end
1600: 
1601: """
1602: Ensures the validity mask is writable by allocating it.
1603: 
1604: After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.
1605: This allows null values to be written to the vector, regardless of whether a validity mask was present before.
1606: 
1607: * vector: The vector to alter
1608: """
1609: function duckdb_vector_ensure_validity_writable(vector)
1610:     return ccall((:duckdb_vector_ensure_validity_writable, libduckdb), Cvoid, (duckdb_vector,), vector)
1611: end
1612: 
1613: """
1614: Retrieves the child vector of a list vector.
1615: 
1616: The resulting vector is valid as long as the parent vector is valid.
1617: 
1618: * vector: The vector
1619: * returns: The child vector
1620: """
1621: function duckdb_list_vector_get_child(vector)
1622:     return ccall((:duckdb_list_vector_get_child, libduckdb), duckdb_vector, (duckdb_vector,), vector)
1623: end
1624: 
1625: """
1626: Returns the size of the child vector of the list
1627: 
1628: * vector: The vector
1629: * returns: The size of the child list
1630: """
1631: function duckdb_list_vector_get_size(vector)
1632:     return ccall((:duckdb_list_vector_get_size, libduckdb), UInt64, (duckdb_vector,), vector)
1633: end
1634: 
1635: """
1636: Retrieves the child vector of a struct vector.
1637: 
1638: The resulting vector is valid as long as the parent vector is valid.
1639: 
1640: * vector: The vector
1641: * index: The child index
1642: * returns: The child vector
1643: """
1644: function duckdb_struct_vector_get_child(vector, index)
1645:     return ccall(
1646:         (:duckdb_struct_vector_get_child, libduckdb),
1647:         duckdb_vector,
1648:         (duckdb_vector, UInt64),
1649:         vector,
1650:         index - 1
1651:     )
1652: end
1653: 
1654: """
1655: Assigns a string element in the vector at the specified location.
1656: 
1657: * vector: The vector to alter
1658: * index: The row position in the vector to assign the string to
1659: * str: The null-terminated string
1660: """
1661: function duckdb_vector_assign_string_element(vector, index, str)
1662:     return ccall(
1663:         (:duckdb_vector_assign_string_element, libduckdb),
1664:         Cvoid,
1665:         (duckdb_vector, UInt64, Ptr{UInt8}),
1666:         vector,
1667:         index - 1,
1668:         str
1669:     )
1670: end
1671: """
1672: Assigns a string element in the vector at the specified location.
1673: 
1674: * vector: The vector to alter
1675: * index: The row position in the vector to assign the string to
1676: * str: The null-terminated string
1677: * str_len: The string length
1678: """
1679: function duckdb_vector_assign_string_element_len(vector, index, str, str_len)
1680:     return ccall(
1681:         (:duckdb_vector_assign_string_element_len, libduckdb),
1682:         Cvoid,
1683:         (duckdb_vector, UInt64, Ptr{UInt8}, UInt64),
1684:         vector,
1685:         index - 1,
1686:         str,
1687:         str_len
1688:     )
1689: end
1690: 
1691: #=
1692: //===--------------------------------------------------------------------===//
1693: // Table Functions
1694: //===--------------------------------------------------------------------===//
1695: =#
1696: """
1697: Creates a new empty table function.
1698: 
1699: The return value should be destroyed with `duckdb_destroy_table_function`.
1700: 
1701: * returns: The table function object.
1702: """
1703: function duckdb_create_table_function()
1704:     return ccall((:duckdb_create_table_function, libduckdb), duckdb_table_function, ())
1705: end
1706: 
1707: """
1708: Destroys the given table function object.
1709: 
1710: * table_function: The table function to destroy
1711: """
1712: function duckdb_destroy_table_function(func)
1713:     return ccall((:duckdb_destroy_table_function, libduckdb), Cvoid, (Ref{duckdb_table_function},), func)
1714: end
1715: 
1716: """
1717: Sets the name of the given table function.
1718: 
1719: * table_function: The table function
1720: * name: The name of the table function
1721: """
1722: function duckdb_table_function_set_name(func, name)
1723:     return ccall((:duckdb_table_function_set_name, libduckdb), Cvoid, (duckdb_table_function, Ptr{UInt8}), func, name)
1724: end
1725: 
1726: """
1727: Adds a parameter to the table function.
1728: 
1729: * table_function: The table function
1730: * type: The type of the parameter to add.
1731: """
1732: function duckdb_table_function_add_parameter(func, type)
1733:     return ccall(
1734:         (:duckdb_table_function_add_parameter, libduckdb),
1735:         Cvoid,
1736:         (duckdb_table_function, duckdb_logical_type),
1737:         func,
1738:         type
1739:     )
1740: end
1741: 
1742: """
1743: Assigns extra information to the table function that can be fetched during binding, etc.
1744: 
1745: * table_function: The table function
1746: * extra_info: The extra information
1747: * destroy: The callback that will be called to destroy the bind data (if any)
1748: """
1749: function duckdb_table_function_set_extra_info(table_func, extra_data)
1750:     return ccall(
1751:         (:duckdb_table_function_set_extra_info, libduckdb),
1752:         Cvoid,
1753:         (duckdb_table_function, Ptr{Cvoid}, Ptr{Cvoid}),
1754:         table_func,
1755:         extra_data,
1756:         C_NULL
1757:     )
1758: end
1759: 
1760: """
1761: Sets the bind function of the table function
1762: 
1763: * table_function: The table function
1764: * bind: The bind function
1765: """
1766: function duckdb_table_function_set_bind(table_func, bind_func)
1767:     return ccall(
1768:         (:duckdb_table_function_set_bind, libduckdb),
1769:         Cvoid,
1770:         (duckdb_table_function, Ptr{Cvoid}),
1771:         table_func,
1772:         bind_func
1773:     )
1774: end
1775: 
1776: """
1777: Sets the init function of the table function
1778: 
1779: * table_function: The table function
1780: * init: The init function
1781: """
1782: function duckdb_table_function_set_init(table_func, init_func)
1783:     return ccall(
1784:         (:duckdb_table_function_set_init, libduckdb),
1785:         Cvoid,
1786:         (duckdb_table_function, Ptr{Cvoid}),
1787:         table_func,
1788:         init_func
1789:     )
1790: end
1791: 
1792: 
1793: """
1794: Sets the main function of the table function
1795: 
1796: * table_function: The table function
1797: * function: The function
1798: """
1799: function duckdb_table_function_set_function(table_func, func)
1800:     return ccall(
1801:         (:duckdb_table_function_set_function, libduckdb),
1802:         Cvoid,
1803:         (duckdb_table_function, Ptr{Cvoid}),
1804:         table_func,
1805:         func
1806:     )
1807: end
1808: 
1809: """
1810: Sets whether or not the given table function supports projection pushdown.
1811: 
1812: If this is set to true, the system will provide a list of all required columns in the `init` stage through
1813: the `duckdb_init_get_column_count` and `duckdb_init_get_column_index` functions.
1814: If this is set to false (the default), the system will expect all columns to be projected.
1815: 
1816: * table_function: The table function
1817: * pushdown: True if the table function supports projection pushdown, false otherwise.
1818: """
1819: function duckdb_table_function_supports_projection_pushdown(table_func, pushdown)
1820:     return ccall(
1821:         (:duckdb_table_function_supports_projection_pushdown, libduckdb),
1822:         Cvoid,
1823:         (duckdb_table_function, Bool),
1824:         table_func,
1825:         pushdown
1826:     )
1827: end
1828: 
1829: """
1830: Register the table function object within the given connection.
1831: 
1832: The function requires at least a name, a bind function, an init function and a main function.
1833: 
1834: If the function is incomplete or a function with this name already exists DuckDBError is returned.
1835: 
1836: * con: The connection to register it in.
1837: * function: The function pointer
1838: * returns: Whether or not the registration was successful.
1839: """
1840: function duckdb_register_table_function(con, func)
1841:     return ccall(
1842:         (:duckdb_register_table_function, libduckdb),
1843:         Int32,
1844:         (duckdb_connection, duckdb_table_function),
1845:         con,
1846:         func
1847:     )
1848: end
1849: 
1850: #=
1851: //===--------------------------------------------------------------------===//
1852: // Table Function Bind
1853: //===--------------------------------------------------------------------===//
1854: =#
1855: 
1856: """
1857: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
1858: 
1859: * info: The info object
1860: * returns: The extra info
1861: """
1862: function duckdb_bind_get_extra_info(bind_info)
1863:     return ccall((:duckdb_bind_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_bind_info,), bind_info)
1864: end
1865: 
1866: """
1867: Adds a result column to the output of the table function.
1868: 
1869: * info: The info object
1870: * name: The name of the column
1871: * type: The logical type of the column
1872: """
1873: function duckdb_bind_add_result_column(bind_info, name, type)
1874:     return ccall(
1875:         (:duckdb_bind_add_result_column, libduckdb),
1876:         Cvoid,
1877:         (duckdb_bind_info, Ptr{UInt8}, duckdb_logical_type),
1878:         bind_info,
1879:         name,
1880:         type
1881:     )
1882: end
1883: 
1884: """
1885: Retrieves the number of regular (non-named) parameters to the function.
1886: 
1887: * info: The info object
1888: * returns: The number of parameters
1889: """
1890: function duckdb_bind_get_parameter_count(bind_info)
1891:     return ccall((:duckdb_bind_get_parameter_count, libduckdb), Int32, (duckdb_bind_info,), bind_info)
1892: end
1893: 
1894: """
1895: Retrieves the parameter at the given index.
1896: 
1897: The result must be destroyed with `duckdb_destroy_value`.
1898: 
1899: * info: The info object
1900: * index: The index of the parameter to get
1901: * returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
1902: """
1903: function duckdb_bind_get_parameter(bind_info, index)
1904:     return ccall((:duckdb_bind_get_parameter, libduckdb), duckdb_value, (duckdb_bind_info, Int32), bind_info, index)
1905: end
1906: 
1907: """
1908: Retrieves the parameter at the given index.
1909: 
1910: The result must be destroyed with `duckdb_destroy_value`.
1911: 
1912: * info: The info object
1913: * index: The index of the parameter to get
1914: * returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
1915: """
1916: function duckdb_bind_set_bind_data(bind_info, bind_data, delete_callback)
1917:     return ccall(
1918:         (:duckdb_bind_set_bind_data, libduckdb),
1919:         Cvoid,
1920:         (duckdb_bind_info, Ptr{Cvoid}, Ptr{Cvoid}),
1921:         bind_info,
1922:         bind_data,
1923:         delete_callback
1924:     )
1925: end
1926: 
1927: """
1928: Report that an error has occurred during bind.
1929: 
1930: * info: The info object
1931: * error: The error message
1932: """
1933: function duckdb_bind_set_error(info, error_message)
1934:     return ccall((:duckdb_bind_set_error, libduckdb), Cvoid, (duckdb_bind_info, Ptr{UInt8}), info, error_message)
1935: end
1936: 
1937: #=
1938: //===--------------------------------------------------------------------===//
1939: // Table Function Init
1940: //===--------------------------------------------------------------------===//
1941: =#
1942: """
1943: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
1944: 
1945: * info: The info object
1946: * returns: The extra info
1947: """
1948: function duckdb_init_get_extra_info(info)
1949:     return ccall((:duckdb_init_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_init_info,), info)
1950: end
1951: 
1952: """
1953: Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
1954: 
1955: Note that the bind data should be considered as read-only.
1956: For tracking state, use the init data instead.
1957: 
1958: * info: The info object
1959: * returns: The bind data object
1960: """
1961: function duckdb_init_get_bind_data(info)
1962:     return ccall((:duckdb_init_get_bind_data, libduckdb), Ptr{Cvoid}, (duckdb_init_info,), info)
1963: end
1964: 
1965: """
1966: Sets the user-provided init data in the init object. This object can be retrieved again during execution.
1967: 
1968: * info: The info object
1969: * extra_data: The init data object.
1970: * destroy: The callback that will be called to destroy the init data (if any)
1971: """
1972: function duckdb_init_set_init_data(init_info, init_data, delete_callback)
1973:     return ccall(
1974:         (:duckdb_init_set_init_data, libduckdb),
1975:         Cvoid,
1976:         (duckdb_init_info, Ptr{Cvoid}, Ptr{Cvoid}),
1977:         init_info,
1978:         init_data,
1979:         delete_callback
1980:     )
1981: end
1982: 
1983: 
1984: """
1985: Returns the number of projected columns.
1986: 
1987: This function must be used if projection pushdown is enabled to figure out which columns to emit.
1988: 
1989: * info: The info object
1990: * returns: The number of projected columns.
1991: """
1992: function duckdb_init_get_column_count(info)
1993:     return ccall((:duckdb_init_get_column_count, libduckdb), UInt64, (duckdb_init_info,), info)
1994: end
1995: 
1996: """
1997: Returns the column index of the projected column at the specified position.
1998: 
1999: This function must be used if projection pushdown is enabled to figure out which columns to emit.
2000: 
2001: * info: The info object
2002: * column_index: The index at which to get the projected column index, from 0..duckdb_init_get_column_count(info)
2003: * returns: The column index of the projected column.
2004: """
2005: function duckdb_init_get_column_index(info, index)
2006:     return ccall((:duckdb_init_get_column_index, libduckdb), UInt64, (duckdb_init_info, UInt64), info, index - 1) + 1
2007: end
2008: 
2009: """
2010: Report that an error has occurred during init.
2011: 
2012: * info: The info object
2013: * error: The error message
2014: """
2015: function duckdb_init_set_error(info, error_message)
2016:     return ccall((:duckdb_init_set_error, libduckdb), Cvoid, (duckdb_init_info, Ptr{UInt8}), info, error_message)
2017: end
2018: 
2019: #=
2020: //===--------------------------------------------------------------------===//
2021: // Table Function
2022: //===--------------------------------------------------------------------===//
2023: =#
2024: """
2025: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
2026: 
2027: * info: The info object
2028: * returns: The extra info
2029: """
2030: function duckdb_function_get_extra_info(info)
2031:     return ccall((:duckdb_function_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)
2032: end
2033: 
2034: """
2035: Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
2036: 
2037: Note that the bind data should be considered as read-only.
2038: For tracking state, use the init data instead.
2039: 
2040: * info: The info object
2041: * returns: The bind data object
2042: """
2043: function duckdb_function_get_bind_data(info)
2044:     return ccall((:duckdb_function_get_bind_data, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)
2045: end
2046: 
2047: """
2048: Gets the init data set by `duckdb_bind_set_init_data` during the bind.
2049: 
2050: * info: The info object
2051: * returns: The init data object
2052: """
2053: function duckdb_function_get_init_data(info)
2054:     return ccall((:duckdb_function_get_init_data, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)
2055: end
2056: 
2057: """
2058: Report that an error has occurred while executing the function.
2059: 
2060: * info: The info object
2061: * error: The error message
2062: """
2063: function duckdb_function_set_error(info, error_message)
2064:     return ccall(
2065:         (:duckdb_function_set_error, libduckdb),
2066:         Cvoid,
2067:         (duckdb_function_info, Ptr{UInt8}),
2068:         info,
2069:         error_message
2070:     )
2071: end
2072: 
2073: #=
2074: //===--------------------------------------------------------------------===//
2075: // Replacement scans
2076: //===--------------------------------------------------------------------===//
2077: =#
2078: """
2079: Add a replacement scan definition to the specified database
2080: 
2081: * db: The database object to add the replacement scan to
2082: * replacement: The replacement scan callback
2083: * extra_data: Extra data that is passed back into the specified callback
2084: * delete_callback: The delete callback to call on the extra data, if any
2085: """
2086: function duckdb_add_replacement_scan(db, replacement, extra_data, delete_callback)
2087:     return ccall(
2088:         (:duckdb_add_replacement_scan, libduckdb),
2089:         Cvoid,
2090:         (duckdb_database, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}),
2091:         db,
2092:         replacement,
2093:         extra_data,
2094:         delete_callback
2095:     )
2096: end
2097: 
2098: """
2099: Sets the replacement function name to use. If this function is called in the replacement callback,
2100:  the replacement scan is performed. If it is not called, the replacement callback is not performed.
2101: 
2102: * info: The info object
2103: * function_name: The function name to substitute.
2104: """
2105: function duckdb_replacement_scan_set_function_name(info, function_name)
2106:     return ccall(
2107:         (:duckdb_replacement_scan_set_function_name, libduckdb),
2108:         Cvoid,
2109:         (duckdb_replacement_scan_info, Ptr{UInt8}),
2110:         info,
2111:         function_name
2112:     )
2113: end
2114: 
2115: 
2116: """
2117: Adds a parameter to the replacement scan function.
2118: 
2119: * info: The info object
2120: * parameter: The parameter to add. The function will call `duckdb_destroy_value` on the parameter.
2121: """
2122: function duckdb_replacement_scan_add_parameter(info, parameter)
2123:     return ccall(
2124:         (:duckdb_replacement_scan_add_parameter, libduckdb),
2125:         Cvoid,
2126:         (duckdb_replacement_scan_info, duckdb_value),
2127:         info,
2128:         parameter
2129:     )
2130: end
2131: 
2132: #=
2133: //===--------------------------------------------------------------------===//
2134: // Appender
2135: //===--------------------------------------------------------------------===//
2136: =#
2137: 
2138: """
2139: Creates an appender object.
2140: * connection: The connection context to create the appender in.
2141: * schema: The schema of the table to append to, or `nullptr` for the default schema.
2142: * table: The table name to append to.
2143: * out_appender: The resulting appender object.
2144: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2145: DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
2146:                                                duckdb_appender *out_appender);
2147: """
2148: function duckdb_appender_create(connection, schema, table, out_appender)
2149:     return ccall(
2150:         (:duckdb_appender_create, libduckdb),
2151:         Int32,
2152:         (duckdb_connection, Ptr{UInt8}, Ptr{UInt8}, Ref{duckdb_appender}),
2153:         connection,
2154:         schema,
2155:         table,
2156:         out_appender
2157:     )
2158: end
2159: 
2160: """
2161: Returns the error message associated with the given appender.
2162: If the appender has no error message, this returns `nullptr` instead.
2163: The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.
2164: * appender: The appender to get the error from.
2165: * returns: The error message, or `nullptr` if there is none.
2166: DUCKDB_API const char *duckdb_appender_error(duckdb_appender appender);
2167: """
2168: function duckdb_appender_error(appender)
2169:     return ccall((:duckdb_appender_error, libduckdb), Ptr{UInt8}, (duckdb_appender,), appender)
2170: end
2171: 
2172: """
2173: Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the
2174: base table.
2175: This should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you
2176: are done with the appender.
2177: * appender: The appender to flush.
2178: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2179: DUCKDB_API duckdb_state duckdb_appender_flush(duckdb_appender appender);
2180: """
2181: function duckdb_appender_flush(appender)
2182:     return ccall((:duckdb_appender_flush, libduckdb), duckdb_state, (duckdb_appender,), appender)
2183: end
2184: 
2185: """
2186: Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.
2187: This is generally not necessary. Call `duckdb_appender_destroy` instead.
2188: * appender: The appender to flush and close.
2189: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2190: DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);
2191: """
2192: function duckdb_appender_close(appender)
2193:     return ccall((:duckdb_appender_close, libduckdb), duckdb_state, (duckdb_appender,), appender)
2194: end
2195: 
2196: """
2197: Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating
2198: all memory associated with the appender.
2199: * appender: The appender to flush, close and destroy.
2200: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2201: DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);
2202: """
2203: function duckdb_appender_destroy(appender)
2204:     return ccall((:duckdb_appender_destroy, libduckdb), duckdb_state, (Ref{duckdb_appender},), appender)
2205: end
2206: 
2207: """
2208: A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.
2209: DUCKDB_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);
2210: """
2211: function duckdb_appender_begin_row(appender)
2212:     return ccall((:duckdb_appender_begin_row, libduckdb), duckdb_state, (duckdb_appender,), appender)
2213: end
2214: 
2215: """
2216: Finish the current row of appends. After end_row is called, the next row can be appended.
2217: * appender: The appender.
2218: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2219: DUCKDB_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);
2220: """
2221: function duckdb_appender_end_row(appender)
2222:     return ccall((:duckdb_appender_end_row, libduckdb), duckdb_state, (duckdb_appender,), appender)
2223: end
2224: 
2225: """
2226: Append a bool value to the appender.
2227: DUCKDB_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);
2228: """
2229: function duckdb_append_bool(appender, value)
2230:     return ccall((:duckdb_append_bool, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
2231: end
2232: 
2233: """
2234: Append an int8_t value to the appender.
2235: DUCKDB_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);
2236: """
2237: function duckdb_append_int8(appender, value)
2238:     return ccall((:duckdb_append_int8, libduckdb), duckdb_state, (duckdb_appender, Int16), appender, value)
2239: end
2240: 
2241: """
2242: Append an int16_t value to the appender.
2243: DUCKDB_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);
2244: """
2245: function duckdb_append_int16(appender, value)
2246:     return ccall((:duckdb_append_int16, libduckdb), duckdb_state, (duckdb_appender, Int16), appender, value)
2247: end
2248: 
2249: """
2250: Append an int32_t value to the appender.
2251: DUCKDB_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);
2252: """
2253: function duckdb_append_int32(appender, value)
2254:     return ccall((:duckdb_append_int16, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
2255: end
2256: 
2257: """
2258: Append an int64_t value to the appender.
2259: DUCKDB_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);
2260: """
2261: function duckdb_append_int64(appender, value)
2262:     return ccall((:duckdb_append_int64, libduckdb), duckdb_state, (duckdb_appender, Int64), appender, value)
2263: end
2264: 
2265: """
2266: Append a duckdb_hugeint value to the appender.
2267: DUCKDB_API duckdb_state duckdb_append_hugeint(duckdb_appender appender, duckdb_hugeint value);
2268: """
2269: function duckdb_append_hugeint(appender, value)
2270:     return ccall((:duckdb_append_hugeint, libduckdb), duckdb_state, (duckdb_appender, Int64), appender, value)
2271: end
2272: 
2273: """
2274: Append a uint8_t value to the appender.
2275: DUCKDB_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);
2276: """
2277: function duckdb_append_uint8(appender, value)
2278:     return ccall((:duckdb_append_uint8, libduckdb), duckdb_state, (duckdb_appender, UInt16), appender, value)
2279: end
2280: 
2281: """
2282: Append a uint16_t value to the appender.
2283: DUCKDB_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);
2284: """
2285: function duckdb_append_uint16(appender, value)
2286:     return ccall((:duckdb_append_uint16, libduckdb), duckdb_state, (duckdb_appender, UInt16), appender, value)
2287: end
2288: 
2289: """
2290: Append a uint32_t value to the appender.
2291: DUCKDB_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);
2292: """
2293: function duckdb_append_uint32(appender, value)
2294:     return ccall((:duckdb_append_uint32, libduckdb), duckdb_state, (duckdb_appender, UInt32), appender, value)
2295: end
2296: 
2297: """
2298: Append a uint64_t value to the appender.
2299: DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);
2300: """
2301: function duckdb_append_uint64(appender, value)
2302:     return ccall((:duckdb_append_uint64, libduckdb), duckdb_state, (duckdb_appender, UInt64), appender, value)
2303: end
2304: 
2305: """
2306: Append a float value to the appender.
2307: DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);
2308: """
2309: function duckdb_append_float(appender, value)
2310:     return ccall((:duckdb_append_float, libduckdb), duckdb_state, (duckdb_appender, Float32), appender, value)
2311: end
2312: 
2313: """
2314: Append a double value to the appender.
2315: DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);
2316: """
2317: function duckdb_append_double(appender, value)
2318:     return ccall((:duckdb_append_double, libduckdb), duckdb_state, (duckdb_appender, Float64), appender, value)
2319: end
2320: 
2321: """
2322: Append a duckdb_date value to the appender.
2323: DUCKDB_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);
2324: """
2325: function duckdb_append_date(appender, value)
2326:     return ccall((:duckdb_append_date, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
2327: end
2328: 
2329: """
2330: Append a duckdb_time value to the appender.
2331: DUCKDB_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);
2332: """
2333: function duckdb_append_time(appender, value)
2334:     return ccall((:duckdb_append_time, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
2335: end
2336: 
2337: """
2338: Append a duckdb_timestamp value to the appender.
2339: DUCKDB_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);
2340: """
2341: function duckdb_append_timestamp(appender, value)
2342:     return ccall((:duckdb_append_timestamp, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
2343: end
2344: 
2345: """
2346: Append a duckdb_interval value to the appender.
2347: DUCKDB_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);
2348: """
2349: function duckdb_append_interval(appender, value)
2350:     return ccall((:duckdb_append_interval, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
2351: end
2352: 
2353: """
2354: Append a varchar value to the appender.
2355: DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);
2356: """
2357: function duckdb_append_varchar(appender, value)
2358:     return ccall((:duckdb_append_varchar, libduckdb), duckdb_state, (duckdb_appender, Ptr{UInt8}), appender, value)
2359: end
2360: 
2361: """
2362: Append a varchar value to the appender.
2363: DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);
2364: """
2365: function duckdb_append_varchar_length(appender, value, length)
2366:     return ccall(
2367:         (:duckdb_append_varchar_length, libduckdb),
2368:         duckdb_state,
2369:         (duckdb_appender, Ptr{UInt8}, Int32),
2370:         appender,
2371:         value,
2372:         length
2373:     )
2374: end
2375: 
2376: """
2377: Append a blob value to the appender.
2378: DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);
2379: """
2380: function duckdb_append_blob(appender, data, length)
2381:     return ccall(
2382:         (:duckdb_append_blob, libduckdb),
2383:         duckdb_state,
2384:         (duckdb_appender, Ptr{Cvoid}, Int32),
2385:         appender,
2386:         data,
2387:         length
2388:     )
2389: end
2390: 
2391: """
2392: Append a NULL value to the appender (of any type).
2393: DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);
2394: """
2395: function duckdb_append_null(appender)
2396:     return ccall((:duckdb_append_null, libduckdb), duckdb_state, (duckdb_appender,), appender)
2397: end
2398: 
2399: # #=
2400: # //===--------------------------------------------------------------------===//
2401: # // Arrow Interface
2402: # //===--------------------------------------------------------------------===//
2403: # =#
2404: #
2405: #
2406: # """
2407: # Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.
2408: # If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
2409: # `duckdb_query_arrow_error`.
2410: # Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the
2411: # query fails, otherwise the error stored within the result will not be freed correctly.
2412: # * connection: The connection to perform the query in.
2413: # * query: The SQL query to run.
2414: # * out_result: The query result.
2415: # * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2416: # DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);
2417: # """
2418: # function duckdb_query_arrow(connection, query, out_result)
2419: #     return ccall(
2420: #         (:duckdb_query_arrow, libduckdb),
2421: #         Int32,
2422: #         (Ptr{Cvoid}, Ptr{UInt8}, Ptr{Cvoid}),
2423: #         connection[],
2424: #         query,
2425: #         out_result,
2426: #     )
2427: # end
2428: #
2429: # """
2430: # Fetch the internal arrow schema from the arrow result.
2431: # * result: The result to fetch the schema from.
2432: # * out_schema: The output schema.
2433: # * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2434: # DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);
2435: # """
2436: # function duckdb_query_arrow_schema(result, out_schema)
2437: #     return ccall(
2438: #         (:duckdb_query_arrow_schema, libduckdb),
2439: #         duckdb_state,
2440: #         (Ptr{Cvoid}, Ptr{UInt8}),
2441: #         result,
2442: #         out_schema,
2443: #     )
2444: # end
2445: #
2446: # """
2447: # Fetch an internal arrow array from the arrow result.
2448: # This function can be called multiple time to get next chunks, which will free the previous out_array.
2449: # So consume the out_array before calling this function again.
2450: # * result: The result to fetch the array from.
2451: # * out_array: The output array.
2452: # * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2453: # DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);
2454: # """
2455: # function duckdb_query_arrow_array(result, out_array)
2456: #     return ccall(
2457: #         (:duckdb_query_arrow_array, libduckdb),
2458: #         duckdb_state,
2459: #         (Ptr{Cvoid}, Ptr{Cvoid}),
2460: #         result,
2461: #         out_array,
2462: #     )
2463: # end
2464: #
2465: # """
2466: # Returns the number of columns present in a the arrow result object.
2467: # * result: The result object.
2468: # * returns: The number of columns present in the result object.
2469: # DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);
2470: # """
2471: # function duckdb_arrow_column_count(result)
2472: #     return ccall((:duckdb_arrow_column_count, libduckdb), Int32, (Ptr{Cvoid},), result)
2473: # end
2474: #
2475: # """
2476: # Returns the number of rows present in a the arrow result object.
2477: # * result: The result object.
2478: # * returns: The number of rows present in the result object.
2479: # DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);
2480: # """
2481: # function duckdb_arrow_row_count(result)
2482: #     return ccall((:duckdb_arrow_row_count, libduckdb), Int64, (Ptr{Cvoid},), result)
2483: # end
2484: #
2485: # """
2486: # Returns the number of rows changed by the query stored in the arrow result. This is relevant only for
2487: # INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.
2488: # * result: The result object.
2489: # * returns: The number of rows changed.
2490: # DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);
2491: # """
2492: # function duckdb_arrow_rows_changed(result)
2493: #     return ccall((:duckdb_arrow_rows_changed, libduckdb), Int64, (Ptr{Cvoid},), result)
2494: # end
2495: #
2496: # """
2497: # Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns
2498: # `DuckDBError`.
2499: # The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.
2500: # * result: The result object to fetch the nullmask from.
2501: # * returns: The error of the result.
2502: # DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);
2503: # """
2504: # function duckdb_query_arrow_error(result)
2505: #     return ccall((:duckdb_query_arrow_error, libduckdb), Ptr{UInt8}, (Ptr{Cvoid},), result)
2506: # end
2507: #
2508: # """
2509: # Closes the result and de-allocates all memory allocated for the arrow result.
2510: # * result: The result to destroy.
2511: # DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
2512: # """
2513: # function duckdb_destroy_arrow(result)
2514: #     return ccall((:duckdb_destroy_arrow, libduckdb), Cvoid, (Ptr{Ptr{Cvoid}},), result)
2515: # end
[end of tools/juliapkg/src/api.jl]
[start of tools/juliapkg/src/database.jl]
1: """
2: Internal DuckDB database handle.
3: """
4: mutable struct DuckDBHandle
5:     file::String
6:     handle::duckdb_database
7:     functions::Vector{Any}
8:     registered_objects::Dict{Any, Any}
9: 
10:     function DuckDBHandle(f::AbstractString, config::Config)
11:         f = String(isempty(f) ? f : expanduser(f))
12:         handle = Ref{duckdb_database}()
13:         error = Ref{Ptr{UInt8}}()
14:         if duckdb_open_ext(f, handle, config.handle, error) != DuckDBSuccess
15:             error_message = unsafe_string(error[])
16:             duckdb_free(error[])
17:             throw(ConnectionException(error_message))
18:         end
19: 
20:         db = new(f, handle[], Vector(), Dict())
21:         finalizer(_close_database, db)
22:         return db
23:     end
24: end
25: 
26: function _close_database(db::DuckDBHandle)
27:     # disconnect from DB
28:     if db.handle != C_NULL
29:         duckdb_close(db.handle)
30:     end
31:     return db.handle = C_NULL
32: end
33: 
34: """
35: A connection object to a DuckDB database.
36: 
37: Transaction contexts are local to a single connection.
38: 
39: A connection can only run a single query concurrently.
40: It is possible to open multiple connections to a single DuckDB database instance.
41: Multiple connections can run multiple queries concurrently.
42: """
43: mutable struct Connection
44:     db::DuckDBHandle
45:     handle::duckdb_connection
46: 
47:     function Connection(db::DuckDBHandle)
48:         handle = Ref{duckdb_connection}()
49:         if duckdb_connect(db.handle, handle) != DuckDBSuccess
50:             throw(ConnectionException("Failed to open connection"))
51:         end
52:         con = new(db, handle[])
53:         finalizer(_close_connection, con)
54:         return con
55:     end
56: end
57: 
58: function _close_connection(con::Connection)
59:     # disconnect
60:     if con.handle != C_NULL
61:         duckdb_disconnect(con.handle)
62:     end
63:     con.handle = C_NULL
64:     return
65: end
66: 
67: """
68: A DuckDB database object.
69: 
70: By default a DuckDB database object has an open connection object (db.main_connection).
71: When the database object is used directly in queries, it is actually the underlying main_connection that is used.
72: 
73: It is possible to open new connections to a single database instance using DBInterface.connect(db).
74: """
75: mutable struct DB <: DBInterface.Connection
76:     handle::DuckDBHandle
77:     main_connection::Connection
78: 
79:     function DB(f::AbstractString, config::Config)
80:         set_config(config, "threads", "1")
81:         handle = DuckDBHandle(f, config)
82:         main_connection = Connection(handle)
83: 
84:         db = new(handle, main_connection)
85:         _add_data_frame_scan(db)
86:         return db
87:     end
88:     function DB(f::AbstractString)
89:         return DB(f, Config())
90:     end
91: end
92: 
93: function close_database(db::DB)
94:     _close_connection(db.main_connection)
95:     _close_database(db.handle)
96:     return
97: end
98: 
99: const VECTOR_SIZE = duckdb_vector_size()
100: 
101: DB() = DB(":memory:")
102: DBInterface.connect(::Type{DB}) = DB()
103: DBInterface.connect(::Type{DB}, f::AbstractString) = DB(f)
104: DBInterface.connect(::Type{DB}, f::AbstractString, config::Config) = DB(f, config)
105: DBInterface.connect(db::DB) = Connection(db.handle)
106: DBInterface.close!(db::DB) = close_database(db)
107: DBInterface.close!(con::Connection) = _close_connection(con)
108: Base.close(db::DB) = close_database(db)
109: Base.isopen(db::DB) = db.handle != C_NULL
110: 
111: Base.show(io::IO, db::DuckDB.DB) = print(io, string("DuckDB.DB(", "\"$(db.handle.file)\"", ")"))
112: Base.show(io::IO, con::DuckDB.Connection) = print(io, string("DuckDB.Connection(", "\"$(con.db.file)\"", ")"))
[end of tools/juliapkg/src/database.jl]
[start of tools/juliapkg/src/result.jl]
1: 
2: mutable struct QueryResult
3:     handle::Ref{duckdb_result}
4:     df::DataFrame
5: 
6:     function QueryResult(handle::Ref{duckdb_result})
7:         df = toDataFrame(handle)
8: 
9:         result = new(handle, df)
10:         finalizer(_close_result, result)
11:         return result
12:     end
13: end
14: 
15: function _close_result(result::QueryResult)
16:     return duckdb_destroy_result(result.handle)
17: end
18: 
19: mutable struct ColumnConversionData
20:     chunks::Vector{DataChunk}
21:     col_idx::Int64
22:     logical_type::LogicalType
23:     conversion_data::Any
24: end
25: 
26: mutable struct ListConversionData
27:     conversion_func::Function
28:     conversion_loop_func::Function
29:     child_type::LogicalType
30:     internal_type::Type
31:     target_type::Type
32:     child_conversion_data::Any
33: end
34: 
35: mutable struct StructConversionData
36:     tuple_type::Any
37:     child_conversion_data::Vector{ListConversionData}
38: end
39: 
40: function nop_convert(column_data::ColumnConversionData, val)
41:     return val
42: end
43: 
44: function convert_string(column_data::ColumnConversionData, val::Ptr{Cvoid}, idx::UInt64)
45:     base_ptr = val + (idx - 1) * sizeof(duckdb_string_t)
46:     length_ptr = Base.unsafe_convert(Ptr{Int32}, base_ptr)
47:     length = unsafe_load(length_ptr)
48:     if length <= STRING_INLINE_LENGTH
49:         prefix_ptr = Base.unsafe_convert(Ptr{UInt8}, base_ptr + sizeof(Int32))
50:         return unsafe_string(prefix_ptr, length)
51:     else
52:         ptr_ptr = Base.unsafe_convert(Ptr{Ptr{UInt8}}, base_ptr + sizeof(Int32) * 2)
53:         data_ptr = Base.unsafe_load(ptr_ptr)
54:         return unsafe_string(data_ptr, length)
55:     end
56: end
57: 
58: function convert_blob(column_data::ColumnConversionData, val::Ptr{Cvoid}, idx::UInt64)::Base.CodeUnits{UInt8, String}
59:     return Base.codeunits(convert_string(column_data, val, idx))
60: end
61: 
62: function convert_date(column_data::ColumnConversionData, val::Int32)::Date
63:     return Dates.epochdays2date(val + ROUNDING_EPOCH_TO_UNIX_EPOCH_DAYS)
64: end
65: 
66: function convert_time(column_data::ColumnConversionData, val::Int64)::Time
67:     return Dates.Time(Dates.Nanosecond(val * 1000))
68: end
69: 
70: function convert_timestamp(column_data::ColumnConversionData, val::Int64)::DateTime
71:     return Dates.epochms2datetime((val  1000) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)
72: end
73: 
74: function convert_timestamp_s(column_data::ColumnConversionData, val::Int64)::DateTime
75:     return Dates.epochms2datetime((val * 1000) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)
76: end
77: 
78: function convert_timestamp_ms(column_data::ColumnConversionData, val::Int64)::DateTime
79:     return Dates.epochms2datetime((val) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)
80: end
81: 
82: function convert_timestamp_ns(column_data::ColumnConversionData, val::Int64)::DateTime
83:     return Dates.epochms2datetime((val  1000000) + ROUNDING_EPOCH_TO_UNIX_EPOCH_MS)
84: end
85: 
86: function convert_interval(column_data::ColumnConversionData, val::duckdb_interval)::Dates.CompoundPeriod
87:     return Dates.CompoundPeriod(Dates.Month(val.months), Dates.Day(val.days), Dates.Microsecond(val.micros))
88: end
89: 
90: function convert_hugeint(column_data::ColumnConversionData, val::duckdb_hugeint)::Int128
91:     return Int128(val.lower) + Int128(val.upper) << 64
92: end
93: 
94: function convert_uuid(column_data::ColumnConversionData, val::duckdb_hugeint)::UUID
95:     hugeint = convert_hugeint(column_data, val)
96:     base_value = Int128(170141183460469231731687303715884105727)
97:     if hugeint < 0
98:         return UUID(UInt128(hugeint + base_value) + 1)
99:     else
100:         return UUID(UInt128(hugeint) + base_value + 1)
101:     end
102: end
103: 
104: function convert_enum(column_data::ColumnConversionData, val)::String
105:     return column_data.conversion_data[val + 1]
106: end
107: 
108: function convert_decimal_hugeint(column_data::ColumnConversionData, val::duckdb_hugeint)
109:     return Base.reinterpret(column_data.conversion_data, convert_hugeint(column_data, val))
110: end
111: 
112: function convert_decimal(column_data::ColumnConversionData, val)
113:     return Base.reinterpret(column_data.conversion_data, val)
114: end
115: 
116: function convert_vector(
117:     column_data::ColumnConversionData,
118:     vector::Vec,
119:     size::UInt64,
120:     convert_func::Function,
121:     result,
122:     position,
123:     all_valid,
124:     ::Type{SRC},
125:     ::Type{DST}
126: ) where {SRC, DST}
127:     array = get_array(vector, SRC)
128:     if !all_valid
129:         validity = get_validity(vector)
130:     end
131:     for i in 1:size
132:         if all_valid || isvalid(validity, i)
133:             result[position] = convert_func(column_data, array[i])
134:         end
135:         position += 1
136:     end
137:     return size
138: end
139: 
140: function convert_vector_string(
141:     column_data::ColumnConversionData,
142:     vector::Vec,
143:     size::UInt64,
144:     convert_func::Function,
145:     result,
146:     position,
147:     all_valid,
148:     ::Type{SRC},
149:     ::Type{DST}
150: ) where {SRC, DST}
151:     raw_ptr = duckdb_vector_get_data(vector.handle)
152:     ptr = Base.unsafe_convert(Ptr{duckdb_string_t}, raw_ptr)
153:     if !all_valid
154:         validity = get_validity(vector)
155:     end
156:     for i in 1:size
157:         if all_valid || isvalid(validity, i)
158:             result[position] = convert_func(column_data, raw_ptr, i)
159:         end
160:         position += 1
161:     end
162:     return size
163: end
164: 
165: function convert_vector_list(
166:     column_data::ColumnConversionData,
167:     vector::Vec,
168:     size::UInt64,
169:     convert_func::Function,
170:     result,
171:     position,
172:     all_valid,
173:     ::Type{SRC},
174:     ::Type{DST}
175: ) where {SRC, DST}
176:     child_vector = list_child(vector)
177:     lsize = list_size(vector)
178: 
179:     # convert the child vector
180:     ldata = column_data.conversion_data
181: 
182:     child_column_data =
183:         ColumnConversionData(column_data.chunks, column_data.col_idx, ldata.child_type, ldata.child_conversion_data)
184:     child_array = Array{Union{Missing, ldata.target_type}}(missing, lsize)
185:     ldata.conversion_loop_func(
186:         child_column_data,
187:         child_vector,
188:         lsize,
189:         ldata.conversion_func,
190:         child_array,
191:         1,
192:         false,
193:         ldata.internal_type,
194:         ldata.target_type
195:     )
196: 
197:     array = get_array(vector, SRC)
198:     if !all_valid
199:         validity = get_validity(vector)
200:     end
201:     for i in 1:size
202:         if all_valid || isvalid(validity, i)
203:             start_offset::UInt64 = array[i].offset + 1
204:             end_offset::UInt64 = array[i].offset + array[i].length
205:             result[position] = child_array[start_offset:end_offset]
206:         end
207:         position += 1
208:     end
209:     return size
210: end
211: 
212: function convert_struct_children(column_data::ColumnConversionData, vector::Vec, size::UInt64)
213:     # convert the child vectors of the struct
214:     child_count = get_struct_child_count(column_data.logical_type)
215:     child_arrays = Vector()
216:     for i in 1:child_count
217:         child_vector = struct_child(vector, i)
218:         ldata = column_data.conversion_data.child_conversion_data[i]
219: 
220:         child_column_data =
221:             ColumnConversionData(column_data.chunks, column_data.col_idx, ldata.child_type, ldata.child_conversion_data)
222:         child_array = Array{Union{Missing, ldata.target_type}}(missing, size)
223:         ldata.conversion_loop_func(
224:             child_column_data,
225:             child_vector,
226:             size,
227:             ldata.conversion_func,
228:             child_array,
229:             1,
230:             false,
231:             ldata.internal_type,
232:             ldata.target_type
233:         )
234:         push!(child_arrays, child_array)
235:     end
236:     return child_arrays
237: end
238: 
239: 
240: function convert_vector_struct(
241:     column_data::ColumnConversionData,
242:     vector::Vec,
243:     size::UInt64,
244:     convert_func::Function,
245:     result,
246:     position,
247:     all_valid,
248:     ::Type{SRC},
249:     ::Type{DST}
250: ) where {SRC, DST}
251:     child_count = get_struct_child_count(column_data.logical_type)
252:     child_arrays = convert_struct_children(column_data, vector, size)
253: 
254:     if !all_valid
255:         validity = get_validity(vector)
256:     end
257:     for i in 1:size
258:         if all_valid || isvalid(validity, i)
259:             result_tuple = Vector()
260:             for child_idx in 1:child_count
261:                 push!(result_tuple, child_arrays[child_idx][i])
262:             end
263:             result[position] = NamedTuple{column_data.conversion_data.tuple_type}(result_tuple)
264:         end
265:         position += 1
266:     end
267:     return size
268: end
269: 
270: function convert_vector_map(
271:     column_data::ColumnConversionData,
272:     vector::Vec,
273:     size::UInt64,
274:     convert_func::Function,
275:     result,
276:     position,
277:     all_valid,
278:     ::Type{SRC},
279:     ::Type{DST}
280: ) where {SRC, DST}
281:     child_arrays = convert_struct_children(column_data, vector, size)
282:     keys = child_arrays[1]
283:     values = child_arrays[2]
284: 
285:     if !all_valid
286:         validity = get_validity(vector)
287:     end
288:     for i in 1:size
289:         if all_valid || isvalid(validity, i)
290:             result_dict = Dict()
291:             key_count = length(keys[i])
292:             for key_idx in 1:key_count
293:                 result_dict[keys[i][key_idx]] = values[i][key_idx]
294:             end
295:             result[position] = result_dict
296:         end
297:         position += 1
298:     end
299:     return size
300: end
301: 
302: function convert_column_loop(
303:     column_data::ColumnConversionData,
304:     convert_func::Function,
305:     ::Type{SRC},
306:     ::Type{DST},
307:     convert_vector_func::Function
308: ) where {SRC, DST}
309:     # first check if there are null values in any chunks
310:     has_missing = false
311:     row_count = 0
312:     for chunk in column_data.chunks
313:         if !all_valid(chunk, column_data.col_idx)
314:             has_missing = true
315:         end
316:         row_count += get_size(chunk)
317:     end
318:     if has_missing
319:         # missing values
320:         result = Array{Union{Missing, DST}}(missing, row_count)
321:         position = 1
322:         for chunk in column_data.chunks
323:             position += convert_vector_func(
324:                 column_data,
325:                 get_vector(chunk, column_data.col_idx),
326:                 get_size(chunk),
327:                 convert_func,
328:                 result,
329:                 position,
330:                 all_valid(chunk, column_data.col_idx),
331:                 SRC,
332:                 DST
333:             )
334:         end
335:     else
336:         # no missing values
337:         result = Array{DST}(undef, row_count)
338:         position = 1
339:         for chunk in column_data.chunks
340:             position += convert_vector_func(
341:                 column_data,
342:                 get_vector(chunk, column_data.col_idx),
343:                 get_size(chunk),
344:                 convert_func,
345:                 result,
346:                 position,
347:                 true,
348:                 SRC,
349:                 DST
350:             )
351:         end
352:     end
353:     return result
354: end
355: 
356: function create_child_conversion_data(child_type::LogicalType)
357:     internal_type_id = get_internal_type_id(child_type)
358:     internal_type = duckdb_type_to_internal_type(internal_type_id)
359:     target_type = duckdb_type_to_julia_type(child_type)
360: 
361:     conversion_func = get_conversion_function(child_type)
362:     conversion_loop_func = get_conversion_loop_function(child_type)
363:     child_conversion_data = init_conversion_loop(child_type)
364:     return ListConversionData(
365:         conversion_func,
366:         conversion_loop_func,
367:         child_type,
368:         internal_type,
369:         target_type,
370:         child_conversion_data
371:     )
372: end
373: 
374: function init_conversion_loop(logical_type::LogicalType)
375:     type = get_type_id(logical_type)
376:     if type == DUCKDB_TYPE_DECIMAL
377:         return duckdb_type_to_julia_type(logical_type)
378:     elseif type == DUCKDB_TYPE_ENUM
379:         return get_enum_dictionary(logical_type)
380:     elseif type == DUCKDB_TYPE_LIST
381:         child_type = get_list_child_type(logical_type)
382:         return create_child_conversion_data(child_type)
383:     elseif type == DUCKDB_TYPE_STRUCT || type == DUCKDB_TYPE_MAP
384:         child_count = get_struct_child_count(logical_type)
385:         child_symbols::Vector{Symbol} = Vector()
386:         child_data::Vector{ListConversionData} = Vector()
387:         for i in 1:child_count
388:             child_symbol = Symbol(get_struct_child_name(logical_type, i))
389:             child_type = get_struct_child_type(logical_type, i)
390:             child_conv_data = create_child_conversion_data(child_type)
391:             push!(child_symbols, child_symbol)
392:             push!(child_data, child_conv_data)
393:         end
394:         return StructConversionData(Tuple(x for x in child_symbols), child_data)
395:     else
396:         return nothing
397:     end
398: end
399: 
400: function get_conversion_function(logical_type::LogicalType)::Function
401:     type = get_type_id(logical_type)
402:     if type == DUCKDB_TYPE_VARCHAR || type == DUCKDB_TYPE_JSON
403:         return convert_string
404:     elseif type == DUCKDB_TYPE_BLOB
405:         return convert_blob
406:     elseif type == DUCKDB_TYPE_DATE
407:         return convert_date
408:     elseif type == DUCKDB_TYPE_TIME
409:         return convert_time
410:     elseif type == DUCKDB_TYPE_TIMESTAMP
411:         return convert_timestamp
412:     elseif type == DUCKDB_TYPE_TIMESTAMP_S
413:         return convert_timestamp_s
414:     elseif type == DUCKDB_TYPE_TIMESTAMP_MS
415:         return convert_timestamp_ms
416:     elseif type == DUCKDB_TYPE_TIMESTAMP_NS
417:         return convert_timestamp_ns
418:     elseif type == DUCKDB_TYPE_INTERVAL
419:         return convert_interval
420:     elseif type == DUCKDB_TYPE_HUGEINT
421:         return convert_hugeint
422:     elseif type == DUCKDB_TYPE_UUID
423:         return convert_uuid
424:     elseif type == DUCKDB_TYPE_DECIMAL
425:         internal_type_id = get_internal_type_id(logical_type)
426:         if internal_type_id == DUCKDB_TYPE_HUGEINT
427:             return convert_decimal_hugeint
428:         else
429:             return convert_decimal
430:         end
431:     elseif type == DUCKDB_TYPE_ENUM
432:         return convert_enum
433:     else
434:         return nop_convert
435:     end
436: end
437: 
438: function get_conversion_loop_function(logical_type::LogicalType)::Function
439:     type = get_type_id(logical_type)
440:     if type == DUCKDB_TYPE_VARCHAR || type == DUCKDB_TYPE_BLOB || type == DUCKDB_TYPE_JSON
441:         return convert_vector_string
442:     elseif type == DUCKDB_TYPE_LIST
443:         return convert_vector_list
444:     elseif type == DUCKDB_TYPE_STRUCT
445:         return convert_vector_struct
446:     elseif type == DUCKDB_TYPE_MAP
447:         return convert_vector_map
448:     else
449:         return convert_vector
450:     end
451: end
452: 
453: function convert_column(column_data::ColumnConversionData)
454:     internal_type_id = get_internal_type_id(column_data.logical_type)
455:     internal_type = duckdb_type_to_internal_type(internal_type_id)
456:     target_type = duckdb_type_to_julia_type(column_data.logical_type)
457: 
458:     conversion_func = get_conversion_function(column_data.logical_type)
459:     conversion_loop_func = get_conversion_loop_function(column_data.logical_type)
460: 
461:     column_data.conversion_data = init_conversion_loop(column_data.logical_type)
462:     return convert_column_loop(column_data, conversion_func, internal_type, target_type, conversion_loop_func)
463: end
464: 
465: function toDataFrame(result::Ref{duckdb_result})::DataFrame
466:     column_count = duckdb_column_count(result)
467:     # duplicate eliminate the names
468:     names = Vector{Symbol}(undef, column_count)
469:     for i in 1:column_count
470:         name = sym(duckdb_column_name(result, i))
471:         if name in view(names, 1:(i - 1))
472:             j = 1
473:             new_name = Symbol(name, :_, j)
474:             while new_name in view(names, 1:(i - 1))
475:                 j += 1
476:                 new_name = Symbol(name, :_, j)
477:             end
478:             name = new_name
479:         end
480:         names[i] = name
481:     end
482:     # gather all the data chunks
483:     chunk_count = duckdb_result_chunk_count(result[])
484:     chunks::Vector{DataChunk} = []
485:     for i in 1:chunk_count
486:         push!(chunks, DataChunk(duckdb_result_get_chunk(result[], i), true))
487:     end
488: 
489:     df = DataFrame()
490:     for i in 1:column_count
491:         name = names[i]
492:         logical_type = LogicalType(duckdb_column_logical_type(result, i))
493:         column_data = ColumnConversionData(chunks, i, logical_type, nothing)
494:         df[!, name] = convert_column(column_data)
495:     end
496:     return df
497: end
498: 
499: function execute(stmt::Stmt, params::DBInterface.StatementParams = ())
500:     bind_parameters(stmt, params)
501: 
502:     handle = Ref{duckdb_result}()
503:     if duckdb_execute_prepared(stmt.handle, handle) != DuckDBSuccess
504:         error_ptr = duckdb_result_error(handle)
505:         if error_ptr == C_NULL
506:             error_message = string("Execute of query \"", stmt.sql, "\" failed: unknown error")
507:         else
508:             error_message = string("Execute of query \"", stmt.sql, "\" failed: ", unsafe_string(error_ptr))
509:         end
510:         duckdb_destroy_result(handle)
511:         throw(QueryException(error_message))
512:     end
513:     return QueryResult(handle)
514: end
515: 
516: # explicitly close prepared statement
517: function DBInterface.close!(stmt::Stmt)
518:     return _close_stmt(stmt)
519: end
520: 
521: function execute(con::Connection, sql::AbstractString, params::DBInterface.StatementParams)
522:     stmt = Stmt(con, sql)
523:     try
524:         return execute(stmt, params)
525:     finally
526:         _close_stmt(stmt) # immediately close, don't wait for GC
527:     end
528: end
529: 
530: execute(con::Connection, sql::AbstractString; kwargs...) = execute(con, sql, values(kwargs))
531: execute(db::DB, sql::AbstractString, params::DBInterface.StatementParams) = execute(db.main_connection, sql, params)
532: execute(db::DB, sql::AbstractString; kwargs...) = execute(db.main_connection, sql, values(kwargs))
533: 
534: Tables.isrowtable(::Type{QueryResult}) = true
535: Tables.columnnames(q::QueryResult) = Tables.columnnames(q.df)
536: 
537: function Tables.schema(q::QueryResult)
538:     return Tables.schema(q.df)
539: end
540: 
541: Base.IteratorSize(::Type{QueryResult}) = Base.SizeUnknown()
542: Base.eltype(q::QueryResult) = Any
543: 
544: function DBInterface.close!(q::QueryResult)
545:     return _close_result(q)
546: end
547: 
548: function Base.iterate(q::QueryResult)
549:     return Base.iterate(eachrow(q.df))
550: end
551: 
552: function Base.iterate(q::QueryResult, state)
553:     return Base.iterate(eachrow(q.df), state)
554: end
555: 
556: DataFrames.DataFrame(q::QueryResult) = DataFrame(q.df)
557: 
558: "Return the last row insert id from the executed statement"
559: function DBInterface.lastrowid(con::Connection)
560:     throw(NotImplementedException("Unimplemented: lastrowid"))
561: end
562: 
563: DBInterface.lastrowid(db::DB) = DBInterface.lastrowid(db.main_connection)
564: 
565: """
566:     DBInterface.prepare(db::DuckDB.DB, sql::AbstractString)
567: 
568: Prepare an SQL statement given as a string in the DuckDB database; returns a `DuckDB.Stmt` object.
569: See `DBInterface.execute`(@ref) for information on executing a prepared statement and passing parameters to bind.
570: A `DuckDB.Stmt` object can be closed (resources freed) using `DBInterface.close!`(@ref).
571: """
572: DBInterface.prepare(con::Connection, sql::AbstractString) = Stmt(con, sql)
573: DBInterface.prepare(db::DB, sql::AbstractString) = DBInterface.prepare(db.main_connection, sql)
574: 
575: """
576:     DBInterface.execute(db::DuckDB.DB, sql::String, [params])
577:     DBInterface.execute(stmt::SQLite.Stmt, [params])
578: 
579: Bind any positional (`params` as `Vector` or `Tuple`) or named (`params` as `NamedTuple` or `Dict`) parameters to an SQL statement, given by `db` and `sql` or
580: as an already prepared statement `stmt`, execute the query and return an iterator of result rows.
581: 
582: Note that the returned result row iterator only supports a single-pass, forward-only iteration of the result rows.
583: Calling `SQLite.reset!(result)` will re-execute the query and reset the iterator back to the beginning.
584: 
585: The resultset iterator supports the [Tables.jl](https://github.com/JuliaData/Tables.jl) interface, so results can be collected in any Tables.jl-compatible sink,
586: like `DataFrame(results)`, `CSV.write("results.csv", results)`, etc.
587: """
588: function DBInterface.execute(stmt::Stmt, params::DBInterface.StatementParams)
589:     return execute(stmt, params)
590: end
591: 
592: function DBInterface.execute(con::Connection, sql::AbstractString)
593:     return execute(Stmt(con, sql))
594: end
595: 
596: Base.show(io::IO, result::DuckDB.QueryResult) = print(io, result.df)
[end of tools/juliapkg/src/result.jl]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: