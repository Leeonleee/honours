diff --git a/test/optimizer/test_filter_pushdown_optimizer.cpp b/test/optimizer/test_filter_pushdown_optimizer.cpp
index 76f081e9fa3c..0da65916c6cd 100644
--- a/test/optimizer/test_filter_pushdown_optimizer.cpp
+++ b/test/optimizer/test_filter_pushdown_optimizer.cpp
@@ -53,7 +53,7 @@ TEST_CASE("Test Table Filter Push Down Multiple Filters", "[filterpushdown-optim
 }
 
 TEST_CASE("Test Table Filter All Numeric Data Types", "[filterpushdown-optimizer]") {
-	vector<string> data_types{"tinyint", "smallint", "integer", "bigint", "numeric", "real", "date"};
+	vector<string> data_types{"tinyint", "smallint", "integer", "bigint", "numeric", "real"};
 	ExpressionHelper helper;
 	auto &con = helper.con;
 	Binder binder(*con.context);
diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp
index 187bd896f522..b65378d383ae 100644
--- a/test/rigger/test_rigger.cpp
+++ b/test/rigger/test_rigger.cpp
@@ -331,4 +331,113 @@ TEST_CASE("Tests found by Rigger", "[rigger]") {
 		REQUIRE(CHECK_COLUMN(result, 0, {-1, 0, 0, 1}));
 		REQUIRE(CHECK_COLUMN(result, 1, {Value(), Value(), Value(), 0}));
 	}
+	SECTION("521") {
+		// ROUND() evaluates to -nan
+		result = con.Query("SELECT ROUND(0.1, 1000);");
+		REQUIRE(CHECK_COLUMN(result, 0, {0.1}));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (0);"));
+		result = con.Query("SELECT * FROM t0 WHERE t0.c0 > ROUND(0.1, 1000);");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+		result = con.Query("SELECT * FROM t0 WHERE t0.c0 <= ROUND(0.1, 1000);");
+		REQUIRE(CHECK_COLUMN(result, 0, {0}));
+	}
+	SECTION("522") {
+		// Casting a large number to REAL and multiplying it with zero results in -nan
+		// REQUIRE_FAIL(con.Query("SELECT 1e100::real*0;"));
+	}
+	SECTION("523") {
+		// The trigonometric functions can result in -nan
+		// REQUIRE_FAIL(con.Query("SELECT SIN(1e1000);"));
+	}
+	SECTION("525") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 FLOAT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (1), (0);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t1(c0) VALUES (1);"));
+		result = con.Query("SELECT t1.c0 FROM t1 JOIN t0 ON t1.c0 IN (t0.c0) WHERE t1.c0<=t0.c0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {1.0}));
+	}
+	SECTION("526") {
+		// Query that uses the CONCAT() function and OR expression crashes
+		// FIXME: #398
+		con.DisableQueryVerification();
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 REAL);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 INT2);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t2(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0 VALUES (-1);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t1 VALUES (0);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t2 VALUES (0), (0);"));
+		result = con.Query("SELECT * FROM t1, t2, t0 WHERE CONCAT(t1.c0) OR t0.c0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {0, 0}));
+		REQUIRE(CHECK_COLUMN(result, 1, {0, 0}));
+		REQUIRE(CHECK_COLUMN(result, 2, {-1.0, -1.0}));
+	}
+	SECTION("527") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0 VALUES (0);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t1 VALUES (1), (1);"));
+		result = con.Query("SELECT t0.c0 FROM t0 JOIN t1 ON t0.c0=(t1.c0 IS NULL) WHERE t0.c0 NOT IN (t1.c0);");
+		REQUIRE(CHECK_COLUMN(result, 0, {0, 0}));
+		result = con.Query("SELECT t0.c0 FROM t0 JOIN t1 ON t0.c0=(t1.c0 IS NULL);");
+		REQUIRE(CHECK_COLUMN(result, 0, {0, 0}));
+	}
+	SECTION("528") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 VARCHAR);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (0.1);"));
+		result = con.Query("SELECT * FROM t0 WHERE REGEXP_MATCHES(t0.c0, '1');");
+		REQUIRE(CHECK_COLUMN(result, 0, {"0.1"}));
+		result = con.Query("SELECT * FROM t0 WHERE NOT REGEXP_MATCHES(t0.c0, '1');");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+		result = con.Query("SELECT REGEXP_MATCHES(t0.c0, '1') FROM t0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {true}));
+
+		result = con.Query("SELECT * FROM t0 WHERE REGEXP_FULL_MATCH(t0.c0, '1');");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+		result = con.Query("SELECT * FROM t0 WHERE NOT REGEXP_FULL_MATCH(t0.c0, '1');");
+		REQUIRE(CHECK_COLUMN(result, 0, {"0.1"}));
+		result = con.Query("SELECT REGEXP_FULL_MATCH(t0.c0, '1') FROM t0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {false}));
+	}
+	SECTION("531") {
+		// SELECT on DATE column with a large negative value results in a "double free or corruption"
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 DATE);"));
+		REQUIRE_FAIL(con.Query("INSERT INTO t0 VALUES (-10000000);"));
+		REQUIRE_FAIL(con.Query("SELECT (-10000000)::DATE;"));
+	}
+	SECTION("533") {
+		// Overflow when casting from REAL to INT results in "Invalid TypeId -1"
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 REAL);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (10000000000);"));
+		REQUIRE_FAIL(con.Query("SELECT t0.c0 ::INT FROM t0;"));
+	}
+	SECTION("534") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 VARCHAR, c1 DOUBLE UNIQUE);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (NULL);"));
+		REQUIRE_NO_FAIL(con.Query("UPDATE t0 SET c0=0;"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0, c1) VALUES (0, 0);"));
+		result = con.Query("SELECT * FROM t0 WHERE 1 > c1;");
+		REQUIRE(CHECK_COLUMN(result, 0, {"0"}));
+		REQUIRE(CHECK_COLUMN(result, 1, {0}));
+	}
+	SECTION("535") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 NUMERIC);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (-515965088);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (1), (-5.15965088E8);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE INDEX i0 ON t0(c0);"));
+		result = con.Query("SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0) ORDER BY 1;");
+		REQUIRE(CHECK_COLUMN(result, 0, {-515965088, 1}));
+	}
+	SECTION("536") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 VARCHAR);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t1 VALUES (0.9201898334673894), (0);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0 VALUES (0);"));
+		result = con.Query("SELECT * FROM t0, t1 GROUP BY t0.c0, t1.c0 HAVING t1.c0!=MAX(t1.c0);");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+		result = con.Query("SELECT * FROM t0, t1 GROUP BY t0.c0, t1.c0 HAVING t1.c0!=MAX(t1.c0) UNION ALL SELECT * FROM t0, t1 GROUP BY t0.c0, t1.c0 HAVING NOT t1.c0>MAX(t1.c0) ORDER BY 1, 2;");
+		REQUIRE(CHECK_COLUMN(result, 0, {0, 0}));
+		REQUIRE(CHECK_COLUMN(result, 1, {"0", "0.9201898334673894"}));
+	}
 }
diff --git a/test/sql/prepared/test_prepared.cpp b/test/sql/prepared/test_prepared.cpp
index e6deac2e2435..36d036328dba 100644
--- a/test/sql/prepared/test_prepared.cpp
+++ b/test/sql/prepared/test_prepared.cpp
@@ -157,6 +157,28 @@ TEST_CASE("PREPARE for INSERT", "[prepared]") {
 	REQUIRE_NO_FAIL(con.Query("DROP TABLE c"));
 }
 
+TEST_CASE("PREPARE for INSERT with dates", "[prepared]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db);
+
+	// prepared DATE insert
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE dates(d DATE)"));
+	REQUIRE_NO_FAIL(con.Query("PREPARE s1 AS INSERT INTO dates VALUES ($1)"));
+	REQUIRE_NO_FAIL(con.Query("EXECUTE s1 (DATE '1992-01-01')"));
+
+	result = con.Query("SELECT * FROM dates");
+	REQUIRE(CHECK_COLUMN(result, 0, {Value::DATE(1992, 1, 1)}));
+
+	REQUIRE_NO_FAIL(con.Query("DELETE FROM dates"));
+
+	auto prepared = con.Prepare("INSERT INTO dates VALUES ($1)");
+	REQUIRE_NO_FAIL(prepared->Execute(Value::DATE(1992, 1, 3)));
+
+	result = con.Query("SELECT * FROM dates");
+	REQUIRE(CHECK_COLUMN(result, 0, {Value::DATE(1992, 1, 3)}));
+}
+
 TEST_CASE("PREPARE for DELETE/UPDATE", "[prepared]") {
 	unique_ptr<QueryResult> result;
 	DuckDB db(nullptr);
