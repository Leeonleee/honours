{
  "repo": "duckdb/duckdb",
  "pull_number": 529,
  "instance_id": "duckdb__duckdb-529",
  "issue_numbers": [
    "535"
  ],
  "base_commit": "3f0eb5134512c6097805998ccc5eb44476534736",
  "patch": "diff --git a/src/common/types/value.cpp b/src/common/types/value.cpp\nindex 967c593bbc4b..4989ec303dcb 100644\n--- a/src/common/types/value.cpp\n+++ b/src/common/types/value.cpp\n@@ -172,24 +172,40 @@ Value Value::POINTER(uintptr_t value) {\n \treturn result;\n }\n \n+Value Value::DATE(date_t date) {\n+\tauto val = Value::INTEGER(date);\n+\tval.sql_type = SQLType::DATE;\n+\treturn val;\n+}\n+\n Value Value::DATE(int32_t year, int32_t month, int32_t day) {\n-\treturn Value::INTEGER(Date::FromDate(year, month, day));\n+\tauto val = Value::INTEGER(Date::FromDate(year, month, day));\n+\tval.sql_type = SQLType::DATE;\n+\treturn val;\n }\n \n Value Value::TIME(int32_t hour, int32_t min, int32_t sec, int32_t msec) {\n-\treturn Value::INTEGER(Time::FromTime(hour, min, sec, msec));\n+\tauto val = Value::INTEGER(Time::FromTime(hour, min, sec, msec));\n+\tval.sql_type = SQLType::TIME;\n+\treturn val;\n }\n \n Value Value::TIMESTAMP(timestamp_t timestamp) {\n-\treturn Value::BIGINT(timestamp);\n+\tauto val = Value::BIGINT(timestamp);\n+\tval.sql_type = SQLType::TIMESTAMP;\n+\treturn val;\n }\n \n Value Value::TIMESTAMP(date_t date, dtime_t time) {\n-\treturn Value::BIGINT(Timestamp::FromDatetime(date, time));\n+\tauto val = Value::BIGINT(Timestamp::FromDatetime(date, time));\n+\tval.sql_type = SQLType::TIMESTAMP;\n+\treturn val;\n }\n \n Value Value::TIMESTAMP(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t min, int32_t sec, int32_t msec) {\n-\treturn Value::TIMESTAMP(Date::FromDate(year, month, day), Time::FromTime(hour, min, sec, msec));\n+\tauto val = Value::TIMESTAMP(Date::FromDate(year, month, day), Time::FromTime(hour, min, sec, msec));\n+\tval.sql_type = SQLType::TIMESTAMP;\n+\treturn val;\n }\n \n Value Value::STRUCT(child_list_t<Value> values) {\n@@ -249,6 +265,9 @@ template <> Value Value::CreateValue(double value) {\n \treturn Value::DOUBLE(value);\n }\n \n+template <> Value Value::CreateValue(Value value) {\n+\treturn value;\n+}\n //===--------------------------------------------------------------------===//\n // GetValue\n //===--------------------------------------------------------------------===//\ndiff --git a/src/execution/expression_executor.cpp b/src/execution/expression_executor.cpp\nindex 14007d747de3..ea6d5c2c54df 100644\n--- a/src/execution/expression_executor.cpp\n+++ b/src/execution/expression_executor.cpp\n@@ -117,6 +117,9 @@ unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(Expression &expr\n \n void ExpressionExecutor::Execute(Expression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,\n                                  Vector &result) {\n+\tif (count == 0) {\n+\t\treturn;\n+\t}\n \tswitch (expr.expression_class) {\n \tcase ExpressionClass::BOUND_BETWEEN:\n \t\tExecute((BoundBetweenExpression &)expr, state, sel, count, result);\n@@ -156,6 +159,9 @@ void ExpressionExecutor::Execute(Expression &expr, ExpressionState *state, const\n \n idx_t ExpressionExecutor::Select(Expression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,\n                                  SelectionVector *true_sel, SelectionVector *false_sel) {\n+\tif (count == 0) {\n+\t\treturn 0;\n+\t}\n \tassert(true_sel || false_sel);\n \tassert(expr.return_type == TypeId::BOOL);\n \tswitch (expr.expression_class) {\ndiff --git a/src/execution/expression_executor/execute_cast.cpp b/src/execution/expression_executor/execute_cast.cpp\nindex 42cf5b51ab56..440649b9e2f6 100644\n--- a/src/execution/expression_executor/execute_cast.cpp\n+++ b/src/execution/expression_executor/execute_cast.cpp\n@@ -19,7 +19,7 @@ void ExpressionExecutor::Execute(BoundCastExpression &expr, ExpressionState *sta\n \tauto child_state = state->child_states[0].get();\n \n \tExecute(*expr.child, child_state, sel, count, child);\n-\tif (child.type == expr.return_type) {\n+\tif (expr.source_type == expr.target_type) {\n \t\t// NOP cast\n \t\tresult.Reference(child);\n \t} else {\ndiff --git a/src/execution/physical_plan/plan_filter.cpp b/src/execution/physical_plan/plan_filter.cpp\nindex 4480626b2459..8f436fa0f56a 100644\n--- a/src/execution/physical_plan/plan_filter.cpp\n+++ b/src/execution/physical_plan/plan_filter.cpp\n@@ -19,17 +19,16 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalFilter &op\n \t\tauto filter = make_unique<PhysicalFilter>(op.children[0]->types, move(op.expressions));\n \t\tfilter->children.push_back(move(plan));\n \t\tplan = move(filter);\n-\n-\t\tif (op.projection_map.size() > 0) {\n-\t\t\t// there is a projection map, generate a physical projection\n-\t\t\tvector<unique_ptr<Expression>> select_list;\n-\t\t\tfor (idx_t i = 0; i < op.projection_map.size(); i++) {\n-\t\t\t\tselect_list.push_back(make_unique<BoundReferenceExpression>(op.types[i], op.projection_map[i]));\n-\t\t\t}\n-\t\t\tauto proj = make_unique<PhysicalProjection>(op.types, move(select_list));\n-\t\t\tproj->children.push_back(move(plan));\n-\t\t\tplan = move(proj);\n+\t}\n+\tif (op.projection_map.size() > 0) {\n+\t\t// there is a projection map, generate a physical projection\n+\t\tvector<unique_ptr<Expression>> select_list;\n+\t\tfor (idx_t i = 0; i < op.projection_map.size(); i++) {\n+\t\t\tselect_list.push_back(make_unique<BoundReferenceExpression>(op.types[i], op.projection_map[i]));\n \t\t}\n+\t\tauto proj = make_unique<PhysicalProjection>(op.types, move(select_list));\n+\t\tproj->children.push_back(move(plan));\n+\t\tplan = move(proj);\n \t}\n \treturn plan;\n }\ndiff --git a/src/function/aggregate/distributive/minmax.cpp b/src/function/aggregate/distributive/minmax.cpp\nindex 66eebfed1998..502aad06b1dd 100644\n--- a/src/function/aggregate/distributive/minmax.cpp\n+++ b/src/function/aggregate/distributive/minmax.cpp\n@@ -22,7 +22,14 @@ struct MinMaxBase : public StandardDistributiveFunction {\n \t}\n };\n \n-struct MinOperation : public MinMaxBase {\n+struct NumericMinMaxBase : public MinMaxBase {\n+\ttemplate <class INPUT_TYPE, class STATE>\n+\tstatic void Assign(STATE *state, INPUT_TYPE input) {\n+\t\t*state = input;\n+\t}\n+};\n+\n+struct MinOperation : public NumericMinMaxBase {\n \ttemplate <class INPUT_TYPE, class STATE> static void Execute(STATE *state, INPUT_TYPE input) {\n \t\tif (LessThan::Operation<INPUT_TYPE>(input, *state)) {\n \t\t\t*state = input;\n@@ -30,7 +37,7 @@ struct MinOperation : public MinMaxBase {\n \t}\n };\n \n-struct MaxOperation : public MinMaxBase {\n+struct MaxOperation : public NumericMinMaxBase {\n \ttemplate <class INPUT_TYPE, class STATE> static void Execute(STATE *state, INPUT_TYPE input) {\n \t\tif (GreaterThan::Operation<INPUT_TYPE>(input, *state)) {\n \t\t\t*state = input;\n@@ -38,19 +45,66 @@ struct MaxOperation : public MinMaxBase {\n \t}\n };\n \n-void MinFun::RegisterFunction(BuiltinFunctions &set) {\n-\tAggregateFunctionSet min(\"min\");\n+struct StringMinMaxBase : public MinMaxBase {\n+\ttemplate <class STATE> static void Destroy(STATE *state) {\n+\t\tif (!state->IsInlined()) {\n+\t\t\tdelete[] state->GetData();\n+\t\t}\n+\t}\n+\n+\ttemplate <class INPUT_TYPE, class STATE>\n+\tstatic void Assign(STATE *state, INPUT_TYPE input) {\n+\t\tif (input.IsInlined()) {\n+\t\t\t*state = input;\n+\t\t} else {\n+\t\t\t// non-inlined string, need to allocate space for it\n+\t\t\tauto len = input.GetSize();\n+\t\t\tauto ptr = new char[len + 1];\n+\t\t\tmemcpy(ptr, input.GetData(), len + 1);\n+\n+\t\t\t*state = string_t(ptr, len);\n+\t\t}\n+\t}\n+};\n+\n+struct MinOperationString : public StringMinMaxBase {\n+\ttemplate <class INPUT_TYPE, class STATE>\n+\tstatic void Execute(STATE *state, INPUT_TYPE input) {\n+\t\tif (LessThan::Operation<INPUT_TYPE>(input, *state)) {\n+\t\t\tAssign(state, input);\n+\t\t}\n+\t}\n+};\n+\n+struct MaxOperationString : public StringMinMaxBase {\n+\ttemplate <class INPUT_TYPE, class STATE>\n+\tstatic void Execute(STATE *state, INPUT_TYPE input) {\n+\t\tif (GreaterThan::Operation<INPUT_TYPE>(input, *state)) {\n+\t\t\tAssign(state, input);\n+\t\t}\n+\t}\n+};\n+\n+template<class OP, class OP_STRING>\n+static void AddMinMaxOperator(AggregateFunctionSet &set) {\n \tfor (auto type : SQLType::ALL_TYPES) {\n-\t\tmin.AddFunction(AggregateFunction::GetUnaryAggregate<MinOperation>(type));\n+\t\tif (type.id == SQLTypeId::VARCHAR) {\n+\t\t\tset.AddFunction(AggregateFunction::UnaryAggregateDestructor<string_t, string_t, string_t, OP_STRING>(SQLType::VARCHAR, SQLType::VARCHAR));\n+\t\t} else {\n+\t\t\tset.AddFunction(AggregateFunction::GetUnaryAggregate<OP>(type));\n+\t\t}\n \t}\n+}\n+\n+void MinFun::RegisterFunction(BuiltinFunctions &set) {\n+\tAggregateFunctionSet min(\"min\");\n+\tAddMinMaxOperator<MinOperation, MinOperationString>(min);\n \tset.AddFunction(min);\n }\n \n void MaxFun::RegisterFunction(BuiltinFunctions &set) {\n \tAggregateFunctionSet max(\"max\");\n-\tfor (auto type : SQLType::ALL_TYPES) {\n-\t\tmax.AddFunction(AggregateFunction::GetUnaryAggregate<MaxOperation>(type));\n-\t}\n+\tAddMinMaxOperator<MaxOperation, MaxOperationString>(max);\n \tset.AddFunction(max);\n }\n \ndiff --git a/src/function/aggregate/distributive/sum.cpp b/src/function/aggregate/distributive/sum.cpp\nindex ac1f03d9cc72..08a0f5090c63 100644\n--- a/src/function/aggregate/distributive/sum.cpp\n+++ b/src/function/aggregate/distributive/sum.cpp\n@@ -10,6 +10,11 @@ using namespace std;\n namespace duckdb {\n \n struct SumOperation : public StandardDistributiveFunction {\n+\ttemplate <class INPUT_TYPE, class STATE>\n+\tstatic void Assign(STATE *state, INPUT_TYPE input) {\n+\t\t*state = input;\n+\t}\n+\n \ttemplate <class INPUT_TYPE, class STATE> static void Execute(STATE *state, INPUT_TYPE input) {\n \t\t*state += input;\n \t}\ndiff --git a/src/function/scalar/math/numeric.cpp b/src/function/scalar/math/numeric.cpp\nindex b5d4c284ef5a..5ce54c6844d1 100644\n--- a/src/function/scalar/math/numeric.cpp\n+++ b/src/function/scalar/math/numeric.cpp\n@@ -106,8 +106,12 @@ struct RoundOperator {\n \t\tif (precision < 0) {\n \t\t\tprecision = 0;\n \t\t}\n-\t\tTA modifier = pow(10, precision);\n-\t\treturn (round(input * modifier)) / modifier;\n+\t\tdouble modifier = pow(10, precision);\n+\t\tdouble rounded_value = (round(input * modifier)) / modifier;\n+\t\tif (std::isinf(rounded_value) || std::isnan(rounded_value)) {\n+\t\t\treturn input;\n+\t\t}\n+\t\treturn rounded_value;\n \t}\n };\n \ndiff --git a/src/function/scalar/string/reverse.cpp b/src/function/scalar/string/reverse.cpp\nindex e2a3fa9d0167..92749f048142 100644\n--- a/src/function/scalar/string/reverse.cpp\n+++ b/src/function/scalar/string/reverse.cpp\n@@ -44,6 +44,7 @@ static void reverse_chunk_function(DataChunk &args, ExpressionState &state, Vect\n \n \t\tauto target = StringVector::EmptyString(result, input_length);\n \t\tstrreverse(input_data, input_length, target.GetData());\n+\t\ttarget.Finalize();\n \t\treturn target;\n \t});\n }\ndiff --git a/src/include/duckdb/common/types.hpp b/src/include/duckdb/common/types.hpp\nindex e9c9d8101797..fed224333049 100644\n--- a/src/include/duckdb/common/types.hpp\n+++ b/src/include/duckdb/common/types.hpp\n@@ -273,6 +273,8 @@ template <class T> TypeId GetTypeId() {\n \t\treturn TypeId::HASH;\n \t} else if (std::is_same<T, uintptr_t>()) {\n \t\treturn TypeId::POINTER;\n+\t} else if (std::is_same<T, float>()) {\n+\t\treturn TypeId::FLOAT;\n \t} else if (std::is_same<T, double>()) {\n \t\treturn TypeId::DOUBLE;\n \t} else if (std::is_same<T, const char *>() || std::is_same<T, char *>()) {\ndiff --git a/src/include/duckdb/common/types/value.hpp b/src/include/duckdb/common/types/value.hpp\nindex 84d1b361b409..f97531072552 100644\n--- a/src/include/duckdb/common/types/value.hpp\n+++ b/src/include/duckdb/common/types/value.hpp\n@@ -69,6 +69,8 @@ class Value {\n \t//! Create a pointer Value from a specified value\n \tstatic Value POINTER(uintptr_t value);\n \t//! Create a date Value from a specified date\n+\tstatic Value DATE(date_t date);\n+\t//! Create a date Value from a specified date\n \tstatic Value DATE(int32_t year, int32_t month, int32_t day);\n \t//! Create a time Value from a specified date\n \tstatic Value TIME(int32_t hour, int32_t min, int32_t sec, int32_t msec);\n@@ -116,6 +118,10 @@ class Value {\n \t//! Whether or not the value is NULL\n \tbool is_null;\n \n+\tSQLType GetSQLType() {\n+\t\treturn sql_type.id == SQLTypeId::INVALID ? SQLTypeFromInternalType(type) : sql_type;\n+\t}\n+\n \t//! The value of the object, if it is of a constant size Type\n \tunion Val {\n \t\tint8_t boolean;\n@@ -178,6 +184,9 @@ class Value {\n \t}\n \tvoid Print();\n \n+private:\n+\tSQLType sql_type = SQLType(SQLTypeId::INVALID);\n+\n private:\n \ttemplate <class T> T GetValueInternal();\n \t//! Templated helper function for casting\n@@ -201,6 +210,7 @@ template <> Value Value::CreateValue(string value);\n template <> Value Value::CreateValue(string_t value);\n template <> Value Value::CreateValue(float value);\n template <> Value Value::CreateValue(double value);\n+template <> Value Value::CreateValue(Value value);\n \n template <> bool Value::GetValue();\n template <> int8_t Value::GetValue();\ndiff --git a/src/include/duckdb/function/aggregate/distributive_functions.hpp b/src/include/duckdb/function/aggregate/distributive_functions.hpp\nindex 877f8dbb7120..eb9ac20a1674 100644\n--- a/src/include/duckdb/function/aggregate/distributive_functions.hpp\n+++ b/src/include/duckdb/function/aggregate/distributive_functions.hpp\n@@ -22,7 +22,7 @@ struct StandardDistributiveFunction {\n \ttemplate <class INPUT_TYPE, class STATE, class OP>\n \tstatic void Operation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t idx) {\n \t\tif (IsNullValue<INPUT_TYPE>(*state)) {\n-\t\t\t*state = input[idx];\n+\t\t\tOP::template Assign<INPUT_TYPE, STATE>(state, input[idx]);\n \t\t} else {\n \t\t\tOP::template Execute<INPUT_TYPE, STATE>(state, input[idx]);\n \t\t}\ndiff --git a/src/include/duckdb/main/connection.hpp b/src/include/duckdb/main/connection.hpp\nindex d8513e8c1e22..421f870012d4 100644\n--- a/src/include/duckdb/main/connection.hpp\n+++ b/src/include/duckdb/main/connection.hpp\n@@ -51,6 +51,7 @@ class Connection {\n \n \t//! Enable aggressive verification/testing of queries, should only be used in testing\n \tvoid EnableQueryVerification();\n+\tvoid DisableQueryVerification();\n \n \t//! Issues a query to the database and returns a QueryResult. This result can be either a StreamQueryResult or a\n \t//! MaterializedQueryResult. The result can be stepped through with calls to Fetch(). Note that there can only be\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex b85a38bc9de3..fb1b5dfc5ffc 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -298,7 +298,7 @@ unique_ptr<QueryResult> ClientContext::Execute(string name, vector<Value> &value\n \tauto execute = make_unique<ExecuteStatement>();\n \texecute->name = name;\n \tfor (auto &val : values) {\n-\t\texecute->values.push_back(make_unique<ConstantExpression>(SQLTypeFromInternalType(val.type), val));\n+\t\texecute->values.push_back(make_unique<ConstantExpression>(val.GetSQLType(), val));\n \t}\n \n \treturn RunStatement(query, move(execute), allow_stream_result);\ndiff --git a/src/main/connection.cpp b/src/main/connection.cpp\nindex a81be518bc46..aaf775a463b4 100644\n--- a/src/main/connection.cpp\n+++ b/src/main/connection.cpp\n@@ -50,9 +50,11 @@ void Connection::DisableProfiling() {\n }\n \n void Connection::EnableQueryVerification() {\n-#ifdef DEBUG\n \tcontext->query_verification_enabled = true;\n-#endif\n+}\n+\n+void Connection::DisableQueryVerification() {\n+\tcontext->query_verification_enabled = false;\n }\n \n unique_ptr<QueryResult> Connection::SendQuery(string query) {\ndiff --git a/src/optimizer/regex_range_filter.cpp b/src/optimizer/regex_range_filter.cpp\nindex 0372e9c73f38..68dbc7f59fe0 100644\n--- a/src/optimizer/regex_range_filter.cpp\n+++ b/src/optimizer/regex_range_filter.cpp\n@@ -29,7 +29,7 @@ unique_ptr<LogicalOperator> RegexRangeFilter::Rewrite(unique_ptr<LogicalOperator\n \tfor (auto &expr : op->expressions) {\n \t\tif (expr->type == ExpressionType::BOUND_FUNCTION) {\n \t\t\tauto &func = (BoundFunctionExpression &)*expr.get();\n-\t\t\tif (func.function.name != \"regexp_matches\" || func.children.size() != 2) {\n+\t\t\tif (func.function.name != \"regexp_full_match\" || func.children.size() != 2) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tauto &info = (RegexpMatchesBindData &)*func.bind_info;\ndiff --git a/src/parser/transform/statement/transform_prepare.cpp b/src/parser/transform/statement/transform_prepare.cpp\nindex 6fd25c2ad8b5..fedf4ad9d8ca 100644\n--- a/src/parser/transform/statement/transform_prepare.cpp\n+++ b/src/parser/transform/statement/transform_prepare.cpp\n@@ -31,12 +31,10 @@ unique_ptr<ExecuteStatement> Transformer::TransformExecute(PGNode *node) {\n \n \tTransformExpressionList(stmt->params, result->values);\n \tfor (auto &expr : result->values) {\n-\t\tif (expr->GetExpressionType() != ExpressionType::VALUE_CONSTANT &&\n-\t\t    expr->GetExpressionType() != ExpressionType::VALUE_NULL) {\n+\t\tif (!expr->IsScalar()) {\n \t\t\tthrow Exception(\"Only scalar parameters or NULL supported for EXECUTE\");\n \t\t}\n \t}\n-\n \treturn result;\n }\n \ndiff --git a/src/storage/string_segment.cpp b/src/storage/string_segment.cpp\nindex 08a427842407..53c372f4e6c9 100644\n--- a/src/storage/string_segment.cpp\n+++ b/src/storage/string_segment.cpp\n@@ -253,25 +253,24 @@ void StringSegment::FetchRow(ColumnFetchState &state, Transaction &transaction,\n \t\t\t}\n \t\t});\n \t}\n-\tif (!found_data) {\n-\t\t// there was no updated version to be fetched: fetch the base version instead\n-\t\tif (string_updates && string_updates[vector_index]) {\n-\t\t\t// there are updates: check if we should use them\n-\t\t\tauto &info = *string_updates[vector_index];\n-\t\t\tfor (idx_t i = 0; i < info.count; i++) {\n-\t\t\t\tif (info.ids[i] == id_in_vector) {\n-\t\t\t\t\t// use the update\n-\t\t\t\t\tresult_data[result_idx] = ReadString(state.handles, info.block_ids[i], info.offsets[i]);\n-\t\t\t\t\tbreak;\n-\t\t\t\t} else if (info.ids[i] > id_in_vector) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tif (!found_data && string_updates && string_updates[vector_index]) {\n+\t\t// there are updates: check if we should use them\n+\t\tauto &info = *string_updates[vector_index];\n+\t\tfor (idx_t i = 0; i < info.count; i++) {\n+\t\t\tif (info.ids[i] == id_in_vector) {\n+\t\t\t\t// use the update\n+\t\t\t\tresult_data[result_idx] = ReadString(state.handles, info.block_ids[i], info.offsets[i]);\n+\t\t\t\tfound_data = true;\n+\t\t\t\tbreak;\n+\t\t\t} else if (info.ids[i] > id_in_vector) {\n+\t\t\t\tbreak;\n \t\t\t}\n-\t\t} else {\n-\t\t\t// no version was found yet: fetch base table version\n-\t\t\tresult_data[result_idx] = FetchStringFromDict(state.handles, baseptr, base_data[id_in_vector]);\n \t\t}\n \t}\n+\tif (!found_data) {\n+\t\t// no version was found yet: fetch base table version\n+\t\tresult_data[result_idx] = FetchStringFromDict(state.handles, baseptr, base_data[id_in_vector]);\n+\t}\n \tresult_mask[result_idx] = base_nullmask[id_in_vector];\n }\n \ndiff --git a/tools/rpkg/src/duckdbr.cpp b/tools/rpkg/src/duckdbr.cpp\nindex 39a1f7cd13e7..0e0536982963 100644\n--- a/tools/rpkg/src/duckdbr.cpp\n+++ b/tools/rpkg/src/duckdbr.cpp\n@@ -357,7 +357,7 @@ SEXP duckdb_bind_R(SEXP stmtsexp, SEXP paramsexp) {\n \t\t}\n \t\tcase RType::DATE: {\n \t\t\tauto d_val = NUMERIC_POINTER(valsexp)[0];\n-\t\t\tval = Value::INTEGER(RDateType::Convert(d_val));\n+\t\t\tval = Value::DATE(RDateType::Convert(d_val));\n \t\t\tval.is_null = RDateType::IsNull(d_val);\n \t\t\tbreak;\n \t\t}\n",
  "test_patch": "diff --git a/test/optimizer/test_filter_pushdown_optimizer.cpp b/test/optimizer/test_filter_pushdown_optimizer.cpp\nindex 76f081e9fa3c..0da65916c6cd 100644\n--- a/test/optimizer/test_filter_pushdown_optimizer.cpp\n+++ b/test/optimizer/test_filter_pushdown_optimizer.cpp\n@@ -53,7 +53,7 @@ TEST_CASE(\"Test Table Filter Push Down Multiple Filters\", \"[filterpushdown-optim\n }\n \n TEST_CASE(\"Test Table Filter All Numeric Data Types\", \"[filterpushdown-optimizer]\") {\n-\tvector<string> data_types{\"tinyint\", \"smallint\", \"integer\", \"bigint\", \"numeric\", \"real\", \"date\"};\n+\tvector<string> data_types{\"tinyint\", \"smallint\", \"integer\", \"bigint\", \"numeric\", \"real\"};\n \tExpressionHelper helper;\n \tauto &con = helper.con;\n \tBinder binder(*con.context);\ndiff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp\nindex 187bd896f522..b65378d383ae 100644\n--- a/test/rigger/test_rigger.cpp\n+++ b/test/rigger/test_rigger.cpp\n@@ -331,4 +331,113 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {-1, 0, 0, 1}));\n \t\tREQUIRE(CHECK_COLUMN(result, 1, {Value(), Value(), Value(), 0}));\n \t}\n+\tSECTION(\"521\") {\n+\t\t// ROUND() evaluates to -nan\n+\t\tresult = con.Query(\"SELECT ROUND(0.1, 1000);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {0.1}));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 > ROUND(0.1, 1000);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 <= ROUND(0.1, 1000);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {0}));\n+\t}\n+\tSECTION(\"522\") {\n+\t\t// Casting a large number to REAL and multiplying it with zero results in -nan\n+\t\t// REQUIRE_FAIL(con.Query(\"SELECT 1e100::real*0;\"));\n+\t}\n+\tSECTION(\"523\") {\n+\t\t// The trigonometric functions can result in -nan\n+\t\t// REQUIRE_FAIL(con.Query(\"SELECT SIN(1e1000);\"));\n+\t}\n+\tSECTION(\"525\") {\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 FLOAT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (1), (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1(c0) VALUES (1);\"));\n+\t\tresult = con.Query(\"SELECT t1.c0 FROM t1 JOIN t0 ON t1.c0 IN (t0.c0) WHERE t1.c0<=t0.c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {1.0}));\n+\t}\n+\tSECTION(\"526\") {\n+\t\t// Query that uses the CONCAT() function and OR expression crashes\n+\t\t// FIXME: #398\n+\t\tcon.DisableQueryVerification();\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 REAL);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 INT2);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t2(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (-1);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1 VALUES (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t2 VALUES (0), (0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t1, t2, t0 WHERE CONCAT(t1.c0) OR t0.c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {0, 0}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {0, 0}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 2, {-1.0, -1.0}));\n+\t}\n+\tSECTION(\"527\") {\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1 VALUES (1), (1);\"));\n+\t\tresult = con.Query(\"SELECT t0.c0 FROM t0 JOIN t1 ON t0.c0=(t1.c0 IS NULL) WHERE t0.c0 NOT IN (t1.c0);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {0, 0}));\n+\t\tresult = con.Query(\"SELECT t0.c0 FROM t0 JOIN t1 ON t0.c0=(t1.c0 IS NULL);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {0, 0}));\n+\t}\n+\tSECTION(\"528\") {\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 VARCHAR);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0.1);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE REGEXP_MATCHES(t0.c0, '1');\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"0.1\"}));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE NOT REGEXP_MATCHES(t0.c0, '1');\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t\tresult = con.Query(\"SELECT REGEXP_MATCHES(t0.c0, '1') FROM t0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {true}));\n+\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE REGEXP_FULL_MATCH(t0.c0, '1');\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE NOT REGEXP_FULL_MATCH(t0.c0, '1');\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"0.1\"}));\n+\t\tresult = con.Query(\"SELECT REGEXP_FULL_MATCH(t0.c0, '1') FROM t0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {false}));\n+\t}\n+\tSECTION(\"531\") {\n+\t\t// SELECT on DATE column with a large negative value results in a \"double free or corruption\"\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 DATE);\"));\n+\t\tREQUIRE_FAIL(con.Query(\"INSERT INTO t0 VALUES (-10000000);\"));\n+\t\tREQUIRE_FAIL(con.Query(\"SELECT (-10000000)::DATE;\"));\n+\t}\n+\tSECTION(\"533\") {\n+\t\t// Overflow when casting from REAL to INT results in \"Invalid TypeId -1\"\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 REAL);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (10000000000);\"));\n+\t\tREQUIRE_FAIL(con.Query(\"SELECT t0.c0 ::INT FROM t0;\"));\n+\t}\n+\tSECTION(\"534\") {\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 VARCHAR, c1 DOUBLE UNIQUE);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (NULL);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"UPDATE t0 SET c0=0;\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0, c1) VALUES (0, 0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE 1 > c1;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"0\"}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {0}));\n+\t}\n+\tSECTION(\"535\") {\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 NUMERIC);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (-515965088);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (1), (-5.15965088E8);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE INDEX i0 ON t0(c0);\"));\n+\t\tresult = con.Query(\"SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0) ORDER BY 1;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {-515965088, 1}));\n+\t}\n+\tSECTION(\"536\") {\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 VARCHAR);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1 VALUES (0.9201898334673894), (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0, t1 GROUP BY t0.c0, t1.c0 HAVING t1.c0!=MAX(t1.c0);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t\tresult = con.Query(\"SELECT * FROM t0, t1 GROUP BY t0.c0, t1.c0 HAVING t1.c0!=MAX(t1.c0) UNION ALL SELECT * FROM t0, t1 GROUP BY t0.c0, t1.c0 HAVING NOT t1.c0>MAX(t1.c0) ORDER BY 1, 2;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {0, 0}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {\"0\", \"0.9201898334673894\"}));\n+\t}\n }\ndiff --git a/test/sql/prepared/test_prepared.cpp b/test/sql/prepared/test_prepared.cpp\nindex e6deac2e2435..36d036328dba 100644\n--- a/test/sql/prepared/test_prepared.cpp\n+++ b/test/sql/prepared/test_prepared.cpp\n@@ -157,6 +157,28 @@ TEST_CASE(\"PREPARE for INSERT\", \"[prepared]\") {\n \tREQUIRE_NO_FAIL(con.Query(\"DROP TABLE c\"));\n }\n \n+TEST_CASE(\"PREPARE for INSERT with dates\", \"[prepared]\") {\n+\tunique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\t// prepared DATE insert\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE dates(d DATE)\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"PREPARE s1 AS INSERT INTO dates VALUES ($1)\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"EXECUTE s1 (DATE '1992-01-01')\"));\n+\n+\tresult = con.Query(\"SELECT * FROM dates\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::DATE(1992, 1, 1)}));\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"DELETE FROM dates\"));\n+\n+\tauto prepared = con.Prepare(\"INSERT INTO dates VALUES ($1)\");\n+\tREQUIRE_NO_FAIL(prepared->Execute(Value::DATE(1992, 1, 3)));\n+\n+\tresult = con.Query(\"SELECT * FROM dates\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::DATE(1992, 1, 3)}));\n+}\n+\n TEST_CASE(\"PREPARE for DELETE/UPDATE\", \"[prepared]\") {\n \tunique_ptr<QueryResult> result;\n \tDuckDB db(nullptr);\n",
  "problem_statement": "GROUP BY clause results in non-deterministic result\nConsider the following statements:\r\n```sql\r\nCREATE TABLE t0(c0 NUMERIC);\r\nINSERT INTO t0(c0) VALUES (-515965088);\r\nINSERT INTO t0(c0) VALUES (1), (-5.15965088E8);\r\nCREATE INDEX i0 ON t0(c0);\r\nSELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0); -- non-deterministic result\r\n```\r\nUnexpectedly, the query's result set is non-deterministic. In most executions, `-515965088.0` is contained twice in the result set, but sometimes it is contained only once.\r\n\r\nFor example, the following console output demonstrates that the result can change:\r\n```\r\nsqlite> SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0);\r\n-515965088.0\r\n-515965088.0\r\n1.0\r\nsqlite> SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0);\r\n-515965088.0\r\n-515965088.0\r\n1.0\r\nsqlite> SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0);\r\n-515965088.0\r\n-515965088.0\r\n1.0\r\nsqlite> SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0);\r\n-515965088.0\r\n1.0\r\nsqlite> SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0);\r\n-515965088.0\r\n1.0\r\nsqlite> SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0);\r\n-515965088.0\r\n```\r\nWhen executing this based on a debug build, an assertion error occurs:\r\n```sql\r\nsqlite> SELECT t0.c0 FROM t0 GROUP BY t0.c0, REVERSE(t0.c0); -- cardinality: 27;\r\nduckdb_cli: /duckdb/src/common/types/string_type.cpp:27: void duckdb::string_t::Verify(): Assertion `prefix[i] == dataptr[i]' failed.\r\nAborted\r\n```\r\nI can reproduce this on the latest master commit (3f0eb5134512c6097805998ccc5eb44476534736).\n",
  "hints_text": "",
  "created_at": "2020-04-12T11:28:36Z"
}