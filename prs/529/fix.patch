diff --git a/src/common/types/value.cpp b/src/common/types/value.cpp
index 967c593bbc4b..4989ec303dcb 100644
--- a/src/common/types/value.cpp
+++ b/src/common/types/value.cpp
@@ -172,24 +172,40 @@ Value Value::POINTER(uintptr_t value) {
 	return result;
 }
 
+Value Value::DATE(date_t date) {
+	auto val = Value::INTEGER(date);
+	val.sql_type = SQLType::DATE;
+	return val;
+}
+
 Value Value::DATE(int32_t year, int32_t month, int32_t day) {
-	return Value::INTEGER(Date::FromDate(year, month, day));
+	auto val = Value::INTEGER(Date::FromDate(year, month, day));
+	val.sql_type = SQLType::DATE;
+	return val;
 }
 
 Value Value::TIME(int32_t hour, int32_t min, int32_t sec, int32_t msec) {
-	return Value::INTEGER(Time::FromTime(hour, min, sec, msec));
+	auto val = Value::INTEGER(Time::FromTime(hour, min, sec, msec));
+	val.sql_type = SQLType::TIME;
+	return val;
 }
 
 Value Value::TIMESTAMP(timestamp_t timestamp) {
-	return Value::BIGINT(timestamp);
+	auto val = Value::BIGINT(timestamp);
+	val.sql_type = SQLType::TIMESTAMP;
+	return val;
 }
 
 Value Value::TIMESTAMP(date_t date, dtime_t time) {
-	return Value::BIGINT(Timestamp::FromDatetime(date, time));
+	auto val = Value::BIGINT(Timestamp::FromDatetime(date, time));
+	val.sql_type = SQLType::TIMESTAMP;
+	return val;
 }
 
 Value Value::TIMESTAMP(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t min, int32_t sec, int32_t msec) {
-	return Value::TIMESTAMP(Date::FromDate(year, month, day), Time::FromTime(hour, min, sec, msec));
+	auto val = Value::TIMESTAMP(Date::FromDate(year, month, day), Time::FromTime(hour, min, sec, msec));
+	val.sql_type = SQLType::TIMESTAMP;
+	return val;
 }
 
 Value Value::STRUCT(child_list_t<Value> values) {
@@ -249,6 +265,9 @@ template <> Value Value::CreateValue(double value) {
 	return Value::DOUBLE(value);
 }
 
+template <> Value Value::CreateValue(Value value) {
+	return value;
+}
 //===--------------------------------------------------------------------===//
 // GetValue
 //===--------------------------------------------------------------------===//
diff --git a/src/execution/expression_executor.cpp b/src/execution/expression_executor.cpp
index 14007d747de3..ea6d5c2c54df 100644
--- a/src/execution/expression_executor.cpp
+++ b/src/execution/expression_executor.cpp
@@ -117,6 +117,9 @@ unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(Expression &expr
 
 void ExpressionExecutor::Execute(Expression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
                                  Vector &result) {
+	if (count == 0) {
+		return;
+	}
 	switch (expr.expression_class) {
 	case ExpressionClass::BOUND_BETWEEN:
 		Execute((BoundBetweenExpression &)expr, state, sel, count, result);
@@ -156,6 +159,9 @@ void ExpressionExecutor::Execute(Expression &expr, ExpressionState *state, const
 
 idx_t ExpressionExecutor::Select(Expression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
                                  SelectionVector *true_sel, SelectionVector *false_sel) {
+	if (count == 0) {
+		return 0;
+	}
 	assert(true_sel || false_sel);
 	assert(expr.return_type == TypeId::BOOL);
 	switch (expr.expression_class) {
diff --git a/src/execution/expression_executor/execute_cast.cpp b/src/execution/expression_executor/execute_cast.cpp
index 42cf5b51ab56..440649b9e2f6 100644
--- a/src/execution/expression_executor/execute_cast.cpp
+++ b/src/execution/expression_executor/execute_cast.cpp
@@ -19,7 +19,7 @@ void ExpressionExecutor::Execute(BoundCastExpression &expr, ExpressionState *sta
 	auto child_state = state->child_states[0].get();
 
 	Execute(*expr.child, child_state, sel, count, child);
-	if (child.type == expr.return_type) {
+	if (expr.source_type == expr.target_type) {
 		// NOP cast
 		result.Reference(child);
 	} else {
diff --git a/src/execution/physical_plan/plan_filter.cpp b/src/execution/physical_plan/plan_filter.cpp
index 4480626b2459..8f436fa0f56a 100644
--- a/src/execution/physical_plan/plan_filter.cpp
+++ b/src/execution/physical_plan/plan_filter.cpp
@@ -19,17 +19,16 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalFilter &op
 		auto filter = make_unique<PhysicalFilter>(op.children[0]->types, move(op.expressions));
 		filter->children.push_back(move(plan));
 		plan = move(filter);
-
-		if (op.projection_map.size() > 0) {
-			// there is a projection map, generate a physical projection
-			vector<unique_ptr<Expression>> select_list;
-			for (idx_t i = 0; i < op.projection_map.size(); i++) {
-				select_list.push_back(make_unique<BoundReferenceExpression>(op.types[i], op.projection_map[i]));
-			}
-			auto proj = make_unique<PhysicalProjection>(op.types, move(select_list));
-			proj->children.push_back(move(plan));
-			plan = move(proj);
+	}
+	if (op.projection_map.size() > 0) {
+		// there is a projection map, generate a physical projection
+		vector<unique_ptr<Expression>> select_list;
+		for (idx_t i = 0; i < op.projection_map.size(); i++) {
+			select_list.push_back(make_unique<BoundReferenceExpression>(op.types[i], op.projection_map[i]));
 		}
+		auto proj = make_unique<PhysicalProjection>(op.types, move(select_list));
+		proj->children.push_back(move(plan));
+		plan = move(proj);
 	}
 	return plan;
 }
diff --git a/src/function/aggregate/distributive/minmax.cpp b/src/function/aggregate/distributive/minmax.cpp
index 66eebfed1998..502aad06b1dd 100644
--- a/src/function/aggregate/distributive/minmax.cpp
+++ b/src/function/aggregate/distributive/minmax.cpp
@@ -22,7 +22,14 @@ struct MinMaxBase : public StandardDistributiveFunction {
 	}
 };
 
-struct MinOperation : public MinMaxBase {
+struct NumericMinMaxBase : public MinMaxBase {
+	template <class INPUT_TYPE, class STATE>
+	static void Assign(STATE *state, INPUT_TYPE input) {
+		*state = input;
+	}
+};
+
+struct MinOperation : public NumericMinMaxBase {
 	template <class INPUT_TYPE, class STATE> static void Execute(STATE *state, INPUT_TYPE input) {
 		if (LessThan::Operation<INPUT_TYPE>(input, *state)) {
 			*state = input;
@@ -30,7 +37,7 @@ struct MinOperation : public MinMaxBase {
 	}
 };
 
-struct MaxOperation : public MinMaxBase {
+struct MaxOperation : public NumericMinMaxBase {
 	template <class INPUT_TYPE, class STATE> static void Execute(STATE *state, INPUT_TYPE input) {
 		if (GreaterThan::Operation<INPUT_TYPE>(input, *state)) {
 			*state = input;
@@ -38,19 +45,66 @@ struct MaxOperation : public MinMaxBase {
 	}
 };
 
-void MinFun::RegisterFunction(BuiltinFunctions &set) {
-	AggregateFunctionSet min("min");
+struct StringMinMaxBase : public MinMaxBase {
+	template <class STATE> static void Destroy(STATE *state) {
+		if (!state->IsInlined()) {
+			delete[] state->GetData();
+		}
+	}
+
+	template <class INPUT_TYPE, class STATE>
+	static void Assign(STATE *state, INPUT_TYPE input) {
+		if (input.IsInlined()) {
+			*state = input;
+		} else {
+			// non-inlined string, need to allocate space for it
+			auto len = input.GetSize();
+			auto ptr = new char[len + 1];
+			memcpy(ptr, input.GetData(), len + 1);
+
+			*state = string_t(ptr, len);
+		}
+	}
+};
+
+struct MinOperationString : public StringMinMaxBase {
+	template <class INPUT_TYPE, class STATE>
+	static void Execute(STATE *state, INPUT_TYPE input) {
+		if (LessThan::Operation<INPUT_TYPE>(input, *state)) {
+			Assign(state, input);
+		}
+	}
+};
+
+struct MaxOperationString : public StringMinMaxBase {
+	template <class INPUT_TYPE, class STATE>
+	static void Execute(STATE *state, INPUT_TYPE input) {
+		if (GreaterThan::Operation<INPUT_TYPE>(input, *state)) {
+			Assign(state, input);
+		}
+	}
+};
+
+template<class OP, class OP_STRING>
+static void AddMinMaxOperator(AggregateFunctionSet &set) {
 	for (auto type : SQLType::ALL_TYPES) {
-		min.AddFunction(AggregateFunction::GetUnaryAggregate<MinOperation>(type));
+		if (type.id == SQLTypeId::VARCHAR) {
+			set.AddFunction(AggregateFunction::UnaryAggregateDestructor<string_t, string_t, string_t, OP_STRING>(SQLType::VARCHAR, SQLType::VARCHAR));
+		} else {
+			set.AddFunction(AggregateFunction::GetUnaryAggregate<OP>(type));
+		}
 	}
+}
+
+void MinFun::RegisterFunction(BuiltinFunctions &set) {
+	AggregateFunctionSet min("min");
+	AddMinMaxOperator<MinOperation, MinOperationString>(min);
 	set.AddFunction(min);
 }
 
 void MaxFun::RegisterFunction(BuiltinFunctions &set) {
 	AggregateFunctionSet max("max");
-	for (auto type : SQLType::ALL_TYPES) {
-		max.AddFunction(AggregateFunction::GetUnaryAggregate<MaxOperation>(type));
-	}
+	AddMinMaxOperator<MaxOperation, MaxOperationString>(max);
 	set.AddFunction(max);
 }
 
diff --git a/src/function/aggregate/distributive/sum.cpp b/src/function/aggregate/distributive/sum.cpp
index ac1f03d9cc72..08a0f5090c63 100644
--- a/src/function/aggregate/distributive/sum.cpp
+++ b/src/function/aggregate/distributive/sum.cpp
@@ -10,6 +10,11 @@ using namespace std;
 namespace duckdb {
 
 struct SumOperation : public StandardDistributiveFunction {
+	template <class INPUT_TYPE, class STATE>
+	static void Assign(STATE *state, INPUT_TYPE input) {
+		*state = input;
+	}
+
 	template <class INPUT_TYPE, class STATE> static void Execute(STATE *state, INPUT_TYPE input) {
 		*state += input;
 	}
diff --git a/src/function/scalar/math/numeric.cpp b/src/function/scalar/math/numeric.cpp
index b5d4c284ef5a..5ce54c6844d1 100644
--- a/src/function/scalar/math/numeric.cpp
+++ b/src/function/scalar/math/numeric.cpp
@@ -106,8 +106,12 @@ struct RoundOperator {
 		if (precision < 0) {
 			precision = 0;
 		}
-		TA modifier = pow(10, precision);
-		return (round(input * modifier)) / modifier;
+		double modifier = pow(10, precision);
+		double rounded_value = (round(input * modifier)) / modifier;
+		if (std::isinf(rounded_value) || std::isnan(rounded_value)) {
+			return input;
+		}
+		return rounded_value;
 	}
 };
 
diff --git a/src/function/scalar/string/reverse.cpp b/src/function/scalar/string/reverse.cpp
index e2a3fa9d0167..92749f048142 100644
--- a/src/function/scalar/string/reverse.cpp
+++ b/src/function/scalar/string/reverse.cpp
@@ -44,6 +44,7 @@ static void reverse_chunk_function(DataChunk &args, ExpressionState &state, Vect
 
 		auto target = StringVector::EmptyString(result, input_length);
 		strreverse(input_data, input_length, target.GetData());
+		target.Finalize();
 		return target;
 	});
 }
diff --git a/src/include/duckdb/common/types.hpp b/src/include/duckdb/common/types.hpp
index e9c9d8101797..fed224333049 100644
--- a/src/include/duckdb/common/types.hpp
+++ b/src/include/duckdb/common/types.hpp
@@ -273,6 +273,8 @@ template <class T> TypeId GetTypeId() {
 		return TypeId::HASH;
 	} else if (std::is_same<T, uintptr_t>()) {
 		return TypeId::POINTER;
+	} else if (std::is_same<T, float>()) {
+		return TypeId::FLOAT;
 	} else if (std::is_same<T, double>()) {
 		return TypeId::DOUBLE;
 	} else if (std::is_same<T, const char *>() || std::is_same<T, char *>()) {
diff --git a/src/include/duckdb/common/types/value.hpp b/src/include/duckdb/common/types/value.hpp
index 84d1b361b409..f97531072552 100644
--- a/src/include/duckdb/common/types/value.hpp
+++ b/src/include/duckdb/common/types/value.hpp
@@ -69,6 +69,8 @@ class Value {
 	//! Create a pointer Value from a specified value
 	static Value POINTER(uintptr_t value);
 	//! Create a date Value from a specified date
+	static Value DATE(date_t date);
+	//! Create a date Value from a specified date
 	static Value DATE(int32_t year, int32_t month, int32_t day);
 	//! Create a time Value from a specified date
 	static Value TIME(int32_t hour, int32_t min, int32_t sec, int32_t msec);
@@ -116,6 +118,10 @@ class Value {
 	//! Whether or not the value is NULL
 	bool is_null;
 
+	SQLType GetSQLType() {
+		return sql_type.id == SQLTypeId::INVALID ? SQLTypeFromInternalType(type) : sql_type;
+	}
+
 	//! The value of the object, if it is of a constant size Type
 	union Val {
 		int8_t boolean;
@@ -178,6 +184,9 @@ class Value {
 	}
 	void Print();
 
+private:
+	SQLType sql_type = SQLType(SQLTypeId::INVALID);
+
 private:
 	template <class T> T GetValueInternal();
 	//! Templated helper function for casting
@@ -201,6 +210,7 @@ template <> Value Value::CreateValue(string value);
 template <> Value Value::CreateValue(string_t value);
 template <> Value Value::CreateValue(float value);
 template <> Value Value::CreateValue(double value);
+template <> Value Value::CreateValue(Value value);
 
 template <> bool Value::GetValue();
 template <> int8_t Value::GetValue();
diff --git a/src/include/duckdb/function/aggregate/distributive_functions.hpp b/src/include/duckdb/function/aggregate/distributive_functions.hpp
index 877f8dbb7120..eb9ac20a1674 100644
--- a/src/include/duckdb/function/aggregate/distributive_functions.hpp
+++ b/src/include/duckdb/function/aggregate/distributive_functions.hpp
@@ -22,7 +22,7 @@ struct StandardDistributiveFunction {
 	template <class INPUT_TYPE, class STATE, class OP>
 	static void Operation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t idx) {
 		if (IsNullValue<INPUT_TYPE>(*state)) {
-			*state = input[idx];
+			OP::template Assign<INPUT_TYPE, STATE>(state, input[idx]);
 		} else {
 			OP::template Execute<INPUT_TYPE, STATE>(state, input[idx]);
 		}
diff --git a/src/include/duckdb/main/connection.hpp b/src/include/duckdb/main/connection.hpp
index d8513e8c1e22..421f870012d4 100644
--- a/src/include/duckdb/main/connection.hpp
+++ b/src/include/duckdb/main/connection.hpp
@@ -51,6 +51,7 @@ class Connection {
 
 	//! Enable aggressive verification/testing of queries, should only be used in testing
 	void EnableQueryVerification();
+	void DisableQueryVerification();
 
 	//! Issues a query to the database and returns a QueryResult. This result can be either a StreamQueryResult or a
 	//! MaterializedQueryResult. The result can be stepped through with calls to Fetch(). Note that there can only be
diff --git a/src/main/client_context.cpp b/src/main/client_context.cpp
index b85a38bc9de3..fb1b5dfc5ffc 100644
--- a/src/main/client_context.cpp
+++ b/src/main/client_context.cpp
@@ -298,7 +298,7 @@ unique_ptr<QueryResult> ClientContext::Execute(string name, vector<Value> &value
 	auto execute = make_unique<ExecuteStatement>();
 	execute->name = name;
 	for (auto &val : values) {
-		execute->values.push_back(make_unique<ConstantExpression>(SQLTypeFromInternalType(val.type), val));
+		execute->values.push_back(make_unique<ConstantExpression>(val.GetSQLType(), val));
 	}
 
 	return RunStatement(query, move(execute), allow_stream_result);
diff --git a/src/main/connection.cpp b/src/main/connection.cpp
index a81be518bc46..aaf775a463b4 100644
--- a/src/main/connection.cpp
+++ b/src/main/connection.cpp
@@ -50,9 +50,11 @@ void Connection::DisableProfiling() {
 }
 
 void Connection::EnableQueryVerification() {
-#ifdef DEBUG
 	context->query_verification_enabled = true;
-#endif
+}
+
+void Connection::DisableQueryVerification() {
+	context->query_verification_enabled = false;
 }
 
 unique_ptr<QueryResult> Connection::SendQuery(string query) {
diff --git a/src/optimizer/regex_range_filter.cpp b/src/optimizer/regex_range_filter.cpp
index 0372e9c73f38..68dbc7f59fe0 100644
--- a/src/optimizer/regex_range_filter.cpp
+++ b/src/optimizer/regex_range_filter.cpp
@@ -29,7 +29,7 @@ unique_ptr<LogicalOperator> RegexRangeFilter::Rewrite(unique_ptr<LogicalOperator
 	for (auto &expr : op->expressions) {
 		if (expr->type == ExpressionType::BOUND_FUNCTION) {
 			auto &func = (BoundFunctionExpression &)*expr.get();
-			if (func.function.name != "regexp_matches" || func.children.size() != 2) {
+			if (func.function.name != "regexp_full_match" || func.children.size() != 2) {
 				continue;
 			}
 			auto &info = (RegexpMatchesBindData &)*func.bind_info;
diff --git a/src/parser/transform/statement/transform_prepare.cpp b/src/parser/transform/statement/transform_prepare.cpp
index 6fd25c2ad8b5..fedf4ad9d8ca 100644
--- a/src/parser/transform/statement/transform_prepare.cpp
+++ b/src/parser/transform/statement/transform_prepare.cpp
@@ -31,12 +31,10 @@ unique_ptr<ExecuteStatement> Transformer::TransformExecute(PGNode *node) {
 
 	TransformExpressionList(stmt->params, result->values);
 	for (auto &expr : result->values) {
-		if (expr->GetExpressionType() != ExpressionType::VALUE_CONSTANT &&
-		    expr->GetExpressionType() != ExpressionType::VALUE_NULL) {
+		if (!expr->IsScalar()) {
 			throw Exception("Only scalar parameters or NULL supported for EXECUTE");
 		}
 	}
-
 	return result;
 }
 
diff --git a/src/storage/string_segment.cpp b/src/storage/string_segment.cpp
index 08a427842407..53c372f4e6c9 100644
--- a/src/storage/string_segment.cpp
+++ b/src/storage/string_segment.cpp
@@ -253,25 +253,24 @@ void StringSegment::FetchRow(ColumnFetchState &state, Transaction &transaction,
 			}
 		});
 	}
-	if (!found_data) {
-		// there was no updated version to be fetched: fetch the base version instead
-		if (string_updates && string_updates[vector_index]) {
-			// there are updates: check if we should use them
-			auto &info = *string_updates[vector_index];
-			for (idx_t i = 0; i < info.count; i++) {
-				if (info.ids[i] == id_in_vector) {
-					// use the update
-					result_data[result_idx] = ReadString(state.handles, info.block_ids[i], info.offsets[i]);
-					break;
-				} else if (info.ids[i] > id_in_vector) {
-					break;
-				}
+	if (!found_data && string_updates && string_updates[vector_index]) {
+		// there are updates: check if we should use them
+		auto &info = *string_updates[vector_index];
+		for (idx_t i = 0; i < info.count; i++) {
+			if (info.ids[i] == id_in_vector) {
+				// use the update
+				result_data[result_idx] = ReadString(state.handles, info.block_ids[i], info.offsets[i]);
+				found_data = true;
+				break;
+			} else if (info.ids[i] > id_in_vector) {
+				break;
 			}
-		} else {
-			// no version was found yet: fetch base table version
-			result_data[result_idx] = FetchStringFromDict(state.handles, baseptr, base_data[id_in_vector]);
 		}
 	}
+	if (!found_data) {
+		// no version was found yet: fetch base table version
+		result_data[result_idx] = FetchStringFromDict(state.handles, baseptr, base_data[id_in_vector]);
+	}
 	result_mask[result_idx] = base_nullmask[id_in_vector];
 }
 
diff --git a/tools/rpkg/src/duckdbr.cpp b/tools/rpkg/src/duckdbr.cpp
index 39a1f7cd13e7..0e0536982963 100644
--- a/tools/rpkg/src/duckdbr.cpp
+++ b/tools/rpkg/src/duckdbr.cpp
@@ -357,7 +357,7 @@ SEXP duckdb_bind_R(SEXP stmtsexp, SEXP paramsexp) {
 		}
 		case RType::DATE: {
 			auto d_val = NUMERIC_POINTER(valsexp)[0];
-			val = Value::INTEGER(RDateType::Convert(d_val));
+			val = Value::DATE(RDateType::Convert(d_val));
 			val.is_null = RDateType::IsNull(d_val);
 			break;
 		}
