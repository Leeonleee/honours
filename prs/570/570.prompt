You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
REVERSE() on special character results in "Assertion `strcmp(dataptr, normalized) == 0' failed."
Consider the following statement:

```sql
SELECT REVERSE('S̈a︍'); --  Assertion `strcmp(dataptr, normalized) == 0' failed.
```
Unexpectedly, the `SELECT` results in an assertion error:
```
/duckdb/src/common/types/string_type.cpp:18: void duckdb::string_t::Verify(): Assertion `strcmp(dataptr, normalized) == 0' failed.
```
I found this based on commit cc5e3f29bb1b4ea1acf185b19b57b5b009b33067.

</issue>
<code>
[start of README.md]
1: <img align="left" src="logo/duckdb-logo.png" height="120">
2: 
3: # DuckDB, the SQLite for Analytics
4: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
5: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
6: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
7: 
8: <br>
9: 
10: 
11: # Requirements
12: DuckDB requires [CMake](https://cmake.org) to be installed and a `C++11` compliant compiler. GCC 4.9 and newer, Clang 3.9 and newer and VisualStudio 2017 are tested on each revision.
13: 
14: ## Compiling
15: Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You may run `make unit` and `make allunit` to verify that your version works properly after making changes.
16: 
17: # Usage
18: A command line utility based on `sqlite3` can be found in either `build/release/duckdb_cli` (release, the default) or `build/debug/duckdb_cli` (debug).
19: 
20: # Embedding
21: As DuckDB is an embedded database, there is no database server to launch or client to connect to a running server. However, the database server can be embedded directly into an application using the C or C++ bindings. The main build process creates the shared library `build/release/src/libduckdb.[so|dylib|dll]` that can be linked against. A static library is built as well.
22: 
23: For examples on how to embed DuckDB into your application, see the [examples](https://github.com/cwida/duckdb/tree/master/examples) folder.
24: 
25: ## Benchmarks
26: After compiling, benchmarks can be executed from the root directory by executing `./build/release/benchmark/benchmark_runner`.
27: 
28: ## Standing on the Shoulders of Giants
29: DuckDB is implemented in C++ 11, should compile with GCC and clang, uses CMake to build and [Catch2](https://github.com/catchorg/Catch2) for testing. DuckDB uses some components from various Open-Source databases and draws inspiration from scientific publications. Here is an overview:
30: 
31: * Parser: We use the PostgreSQL parser that was [repackaged as a stand-alone library](https://github.com/lfittl/libpg_query). The translation to our own parse tree is inspired by [Peloton](https://pelotondb.io).
32: * Shell: We have adapted the [SQLite shell](https://sqlite.org/cli.html) to work with DuckDB.
33: * Tests: We use the [SQL Logic Tests from SQLite](https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki) to test DuckDB.
34: * Query fuzzing: We use [SQLsmith](https://github.com/anse1/sqlsmith) to generate random queries for additional testing.
35: * Date Math: We use the date math component from [MonetDB](https://www.monetdb.org).
36: * SQL Window Functions: DuckDB's window functions implementation uses Segment Tree Aggregation as described in the paper "Efficient Processing of Window Functions in Analytical SQL Queries" by Viktor Leis, Kan Kundhikanjana, Alfons Kemper and Thomas Neumann.
37: * Execution engine: The vectorized execution engine is inspired by the paper "MonetDB/X100: Hyper-Pipelining Query Execution" by Peter Boncz, Marcin Zukowski and Niels Nes.
38: * Optimizer: DuckDB's optimizer draws inspiration from the papers "Dynamic programming strikes back" by Guido Moerkotte and Thomas Neumman as well as "Unnesting Arbitrary Queries" by Thomas Neumann and Alfons Kemper.
39: * Concurrency control: Our MVCC implementation is inspired by the paper "Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems" by Thomas Neumann, Tobias Mühlbauer and Alfons Kemper.
40: * Regular Expression: DuckDB uses Google's [RE2](https://github.com/google/re2) regular expression engine.
41: 
42: ## Other pages
43: * [Continuous Benchmarking (CB™)](https://www.duckdb.org/benchmarks/index.html), runs TPC-H, TPC-DS and some microbenchmarks on every commit
[end of README.md]
[start of .travis.yml]
1: language: cpp
2: script: make unit
3: dist: trusty
4: 
5: before_install:
6:   - eval "${MATRIX_EVAL}"
7: 
8: env:
9:   global:
10:     - CIBW_BUILD='cp37-* cp27-*'
11:     - CIBW_TEST_REQUIRES='pytest'
12:     - CIBW_BEFORE_BUILD='pip install "numpy>=1.16" && pip install "pandas>=0.24" && pip install "pytest>=4.3" && pip install "cmake==3.13.3" && pip install "pybind11>=2.4"'
13:     - CIBW_TEST_COMMAND='python -m pytest {project}/tests'
14: 
15: 
16: matrix:
17:   include:
18: 
19:     - os: linux
20:       dist: bionic
21:       name: GCC 9
22:       python: 3.7
23: 
24:       addons:
25:         apt:
26:           sources:
27:             - sourceline: 'ppa:ubuntu-toolchain-r/test'
28:             - sourceline: 'ppa:deadsnakes/ppa'
29:           packages:
30:             - g++-9 python3.7
31:       env:
32:         - MATRIX_EVAL="CC=gcc-9 && CXX=g++-9"
33:       before_install:
34:         - eval "${MATRIX_EVAL}"
35:         - pip install --user boto3
36:       script:
37:         - mkdir -p build/release
38:         - (cd build/release && cmake -DCMAKE_BUILD_TYPE=Release -DJDBC_DRIVER=1 ../.. && cmake --build .)
39:         - build/release/test/unittest "*"
40:         - python3.7 tools/shell/shell-test.py build/release/duckdb_cli
41:         - (cd examples/embedded-c; make)
42:         - (cd examples/embedded-c++; make)
43:         - (cd examples/programmatic-querying; make)
44:         - java -cp build/release/tools/jdbc/DuckDBJ.jar nl.cwi.da.duckdb.test.TestDuckDBJDBC
45: 
46:       after_success:
47:         - python tools/upload-s3.py lib-linux-amd64 build/release/src/libduckdb*.so build/release/src/libduckdb*.a build/release/duckdb_cli build/release/tools/jdbc/DuckDBJ.jar
48: 
49:     - os: osx
50:       name: Xcode 11.3
51: 
52:       osx_image: xcode11.3
53: 
54:       before_install:
55:         - curl https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py
56:         - python3 /tmp/get-pip.py
57:         - python3 -m pip install --user boto3
58: 
59:       script:
60:         - (mkdir -p build/release && cd build/release && cmake -DCMAKE_BUILD_TYPE=Release -DJDBC_DRIVER=1 ../.. && cmake --build .)
61:         - build/release/test/unittest
62:         - python3 tools/shell/shell-test.py build/release/duckdb_cli
63:         - java -cp build/release/tools/jdbc/DuckDBJ.jar nl.cwi.da.duckdb.test.TestDuckDBJDBC
64: 
65:       after_success:
66:         - python3 tools/upload-s3.py lib-osx build/release/src/libduckdb.dylib build/release/src/libduckdb_static.a build/release/duckdb_cli build/release/tools/jdbc/DuckDBJ.jar
67: 
68: 
69:     - os: windows
70:       name: VS 2017
71:       filter_secrets: false
72: 
73:       language: c
74: 
75:       before_script:
76:         - choco install python3 --version 3.7.3 -y --params "/InstallDir:C:\Python37-x64"
77:         - choco install jdk8 --version 8.0.211 -y --force
78: 
79:       script:
80:         - cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_GENERATOR_PLATFORM=x64 -DJDBC_DRIVER=1
81:         - cmake --build . --target duckdb --config Release
82:         - cmake --build . --target unittest --config Release
83:         - cmake --build . --target shell --config Release
84:         - cmake --build . --target jdbc --config Release
85:         - test/Release/unittest.exe
86:         - C:/Python37-x64/python.exe tools/shell/shell-test.py Release/duckdb_cli.exe
87:         - C:/Program\ Files/Java/jdk1.8.0_211/bin/java -cp tools/jdbc/DuckDBJ.jar nl.cwi.da.duckdb.test.TestDuckDBJDBC
88: 
89:       after_success:
90:         - C:/Python37-x64/python.exe tools/upload-s3.py lib-windows-amd64 src/Release/duckdb.dll Release/duckdb_cli.exe tools/jdbc/DuckDBJ.jar
91: 
92: 
93: # checks: debug mode (with sanitizers), coveralls, valgrind, vector sizes
94: 
95:     - os: linux
96:       dist: xenial
97:       name: GCC 9 Debug
98: 
99:       addons:
100:         apt:
101:           sources:
102:             - ubuntu-toolchain-r-test
103:           packages:
104:             - g++-9
105:       env:
106:         - MATRIX_EVAL="CC=gcc-9 && CXX=g++-9"
107:         - TREAT_WARNINGS_AS_ERRORS=1
108: 
109:     - os: osx
110:       name: Xcode 11.3 Debug
111:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
112: 
113:       osx_image: xcode11.3
114: 
115: 
116:     - os: linux
117:       dist: xenial
118:       name: Code Coverage
119:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
120: 
121:       addons:
122:         apt:
123:           sources:
124:             - ubuntu-toolchain-r-test
125: 
126:       before_install:
127:         - pip install --user cpp-coveralls
128: 
129:       script:
130:         - mkdir -p build/coverage
131:         - (cd build/coverage && cmake -E env CXXFLAGS="--coverage" cmake -DCMAKE_BUILD_TYPE=Debug ../.. && make)
132:         - build/coverage/test/unittest
133: 
134:       after_success:
135:         - coveralls -b build/coverage -E '.*CMakeCXXCompilerId.cpp' --exclude tools --exclude benchmark --exclude examples --exclude third_party --exclude test --exclude src/common/enums --exclude src/parser/transform/helpers/nodetype_to_string.cpp --exclude build/coverage/third_party/libpg_query/grammar --gcov-options '\-lp'
136: 
137: 
138:     - os: linux
139:       dist: bionic
140:       name: Valgrind
141:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
142: 
143:       addons:
144:         apt:
145:           sources:
146:             - ubuntu-toolchain-r-test
147:           packages:
148:             - valgrind
149: 
150:       script:
151:         - mkdir -p build/debug
152:         - (cd build/debug && cmake -DCMAKE_BUILD_TYPE=Debug -DENABLE_SANITIZER=FALSE ../.. && cmake --build .)
153:         - valgrind ./build/debug/test/unittest -s "Test TPC-H SF0.01"
154: 
155: 
156:     - os: linux
157:       dist: bionic
158:       name: GCC 9 (Vector Sizes)
159:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
160: 
161:       python: 3.7
162: 
163:       addons:
164:         apt:
165:           sources:
166:             - ubuntu-toolchain-r-test
167:       script:
168:         - python3 scripts/test_vector_sizes.py
169: 
170: 
171: # old compilers
172: 
173:     - os: linux
174:       name: Clang 6
175:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
176:       dist: xenial
177:       addons:
178:         apt:
179:           sources:
180:             - ubuntu-toolchain-r-test
181:           packages:
182:             - clang-6.0
183:       env:
184:         - MATRIX_EVAL="CC=clang-6.0 && CXX=clang++-6.0"
185:         - TREAT_WARNINGS_AS_ERRORS=1
186:         - DISABLE_UNITY=1
187: 
188: 
189:     - os: linux
190:       name: GCC 4.9
191:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
192:       addons:
193:          apt:
194:           sources:
195:             - ubuntu-toolchain-r-test
196:           packages:
197:             - g++-4.9 binutils-2.26
198:       env:
199:          - MATRIX_EVAL="CC=gcc-4.9 && CXX=g++-4.9"
200: 
201: 
202: # amalgamations
203: 
204:     - os: linux
205:       dist: xenial
206:       name: GCC 9 (Amalgamation)
207:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
208: 
209:       addons:
210:         apt:
211:           sources:
212:             - ubuntu-toolchain-r-test
213:           packages:
214:             - g++-9
215:       env:
216:         - MATRIX_EVAL="CC=gcc-9 && CXX=g++-9"
217:       before_install:
218:         - eval "${MATRIX_EVAL}"
219:       script:
220:         - python scripts/amalgamation.py
221:         - mkdir -p build/release
222:         - (cd build/release && cmake -DAMALGAMATION_BUILD=1 -DCMAKE_BUILD_TYPE=Release ../.. && cmake --build .)
223:         - build/release/test/unittest "*"
224: 
225:       after_success:
226:         - (cd src/amalgamation; zip ../../build/duckdb.zip duckdb.*)
227:         - python tools/upload-s3.py src-amalgamation build/duckdb.zip
228: 
229: 
230:     - os: osx
231:       name: Xcode 11.3 (Amalgamation)
232:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
233: 
234:       osx_image: xcode11.3
235:       script:
236:         - python3 scripts/amalgamation.py
237:         - (mkdir -p build/release && cd build/release && cmake -DAMALGAMATION_BUILD=1 -DCMAKE_BUILD_TYPE=Release ../.. && cmake --build .)
238:         - build/release/test/unittest
239: 
240: 
241:     - os: windows
242:       name: VS 2017 (Amalgamation)
243:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
244: 
245:       filter_secrets: false
246:       language: c
247:       before_script:
248:         - choco install python3 --version 3.7.3 -y --params "/InstallDir:C:\Python37-x64"
249:       script:
250:         - C:/Python37-x64/python.exe scripts/amalgamation.py
251:         - cmake -DAMALGAMATION_BUILD=1 -DCMAKE_BUILD_TYPE=Release -DCMAKE_GENERATOR_PLATFORM=x64
252:         - cmake --build . --target duckdb --config Release
253:         - cmake --build . --target unittest --config Release
254:         - test/Release/unittest.exe
255: 
256: 
257: # weird platforms: 32 bit linux & windows, arm, solaris, openbsd
258: 
259: 
260:     - os: linux
261:       dist: xenial
262:       name: GCC 9 32 Bit
263:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
264: 
265:       addons:
266:         apt:
267:           sources:
268:             - ubuntu-toolchain-r-test
269:           packages:
270:             - g++-9 libc6-dev-i386 g++-9-multilib gcc-9-multilib gcc-multilib g++-multilib lib32readline6-dev lib32readline6
271: 
272:       env:
273:         - MATRIX_EVAL="CC=gcc-9 && CXX=g++-9"
274:       before_install:
275:         - eval "${MATRIX_EVAL}"
276:         - pip install --user boto3
277:       script:
278:         - mkdir -p build/release
279:         - (cd build/release && cmake -DFORCE_32_BIT=1 -DCMAKE_BUILD_TYPE=Release ../.. && cmake --build .)
280:         - build/release/test/unittest "*"
281: 
282:       after_success:
283:         - python tools/upload-s3.py lib-linux-i386 build/release/src/libduckdb*.so build/release/src/libduckdb*.a build/release/duckdb_cli
284: 
285: 
286:     - os: windows
287:       name: VS 2017 32 Bit
288:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
289: 
290:       filter_secrets: false
291: 
292:       language: c
293: 
294:       before_script:
295:         - choco install python3 --version 3.7.3 -y --params "/InstallDir:C:\Python37-x64"
296:         - choco install curl -y --force
297: 
298:       script:
299:         - cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_GENERATOR_PLATFORM=Win32
300:         - cmake --build . --target duckdb --config Release
301:         - cmake --build . --target unittest --config Release
302:         - cmake --build . --target shell --config Release
303:         - test/Release/unittest.exe
304:         - C:/Python37-x64/python.exe tools/shell/shell-test.py Release/duckdb_cli.exe
305: 
306:       after_success:
307:         - C:/Python37-x64/python.exe tools/upload-s3.py lib-windows-i386 src/Release/duckdb.dll Release/duckdb_cli.exe
308: 
309: 
310:     - os: linux
311:       dist: xenial
312:       name: GCC 5 (ARM64)
313:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
314: 
315:       arch: arm64
316: 
317:       script:
318:         - mkdir -p build/debug
319:         - (cd build/debug && cmake -DEXPLICIT_EXCEPTIONS=TRUE -DCMAKE_BUILD_TYPE=Debug ../.. && cmake --build .)
320:         - build/debug/test/unittest -s "[tpch]"
321: 
322: 
323:     - os: linux
324:       dist: bionic
325:       name: Solaris VM
326:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
327:       sudo: true
328: 
329:       install:
330:         - wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -
331:         - echo -e "\ndeb [arch=amd64] https://download.virtualbox.org/virtualbox/debian bionic contrib\n" | sudo tee -a /etc/apt/sources.list
332:         - sudo apt-get update > /dev/null
333:         - sudo apt-get install -y linux-headers-$(uname -r) virtualbox-5.2 rsync
334:         - wget -q "https://homepages.cwi.nl/~hannes/86Cv27lf5353lJR/Solaris10_1-13-2.ova"
335:         - VBoxManage import Solaris10_1-13-2.ova
336:         - rm Solaris10_1-13-2.ova
337:         - VBoxManage modifyvm "Solaris10_1-13" --usb off --usbehci off --usbxhci off --cpus 2 --hwvirtex on --memory 6114
338:         - VBoxManage startvm "Solaris10_1-13" --type headless
339:         - echo -e "-----BEGIN OPENSSH PRIVATE KEY-----\nb3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABFwAAAAdzc2gtcn\nNhAAAAAwEAAQAAAQEArPN99L/D9jXUwtFjoAzhnzA5a7t/YJiSrcTm+hKSxPp/nklfu1Km\ntDbMBOrXsAqLRcMz5JZoF8G1jebXOO3u2LRB+INFsxqDV76TZjUC1y4SAX17h5UvstT3sn\naPPt+TzwX3PmF8ooN+L8hDIZpvty6m+7b09QRFx4l7+j30MgO+kjwNHUyocn7qokoyH2p4\nfzvtoWePNyL191O9GNg6LmjneG25nN/NBoFYc/Zu+XfDY3gMECNurGHVV3W4ZNpoqjpZWU\nFx4eG0tShBZ+pvuFPy669+H8b5laNEjPGYclInW8unW6T9nuaoQjc/metBwaODgkOsAR0u\nddRxR8nIUwAAA9C2NMXdtjTF3QAAAAdzc2gtcnNhAAABAQCs8330v8P2NdTC0WOgDOGfMD\nlru39gmJKtxOb6EpLE+n+eSV+7Uqa0NswE6tewCotFwzPklmgXwbWN5tc47e7YtEH4g0Wz\nGoNXvpNmNQLXLhIBfXuHlS+y1Peydo8+35PPBfc+YXyig34vyEMhmm+3Lqb7tvT1BEXHiX\nv6PfQyA76SPA0dTKhyfuqiSjIfanh/O+2hZ483IvX3U70Y2DouaOd4bbmc380GgVhz9m75\nd8NjeAwQI26sYdVXdbhk2miqOllZQXHh4bS1KEFn6m+4U/Lrr34fxvmVo0SM8ZhyUidby6\ndbpP2e5qhCNz+Z60HBo4OCQ6wBHS511HFHychTAAAAAwEAAQAAAQEAl3IwnZ0+z96bjG0m\nvAQLngXwgjIRfFieOKPvTpPtCagBEG5X8gSSDcTeKoAqlvDkvBYO3uAGDqeFf9jgJe3T9N\ncD3cW1xvw0fyVWlW1eK2cgRUXIYhV1SzfKHvBKx1eoauRieLGNHhHe8aB/iHFf2hx0BH9V\nSSiQogX2Fk8iAphr9qLuR+M0eMtsZmq9nNpk0iXiohw7b3xNb1QrewoeiXiSI4xANdbkmx\n7R2Jnm132toa+ofPZWbpRptYyzv5TWRhEob4GQSknEvS7NEep3cxnv71d1wQvCfhkMKLXH\nKrIck4X46fLa+65OV8Bq37x91kRagOl4VFBZBT61Y9+DoQAAAIEAltUA8Zx5ETlUOXdGCQ\n+ftbCLZlmlPGGabFdg/EKM+M96Q3sj7L2lIP0Htt5w/HmM3Hz9uLk/d/m20zPq8xkltwCo\nF4R80K5HA38Q26fPRpJzDhch+k7AYuQwjziPSH1uzP3BdQo74KVuyvaTk+9VoeeFslF13P\njflhvUmCyquNkAAACBANtkmGdXwaMHrFKAibQreQuQD9CBRFRDRYNWOP4nPOp7YyCY4xbf\n02kHfFUmf7UqvY36v+jTC4RJ1mJH9KVlqJOB/JLhb6Wrv3xuddcxbwaMwb6dGgsZM+iB7G\nqBlcHlrxnWi6bXXK9WpQWaLNYdE4MKgRvKTSq20glezRWDijznAAAAgQDJzyCedgs5ibpb\nhvtNy5TGXPyX2lI9qoMDV2LSJZhp5TPL/mZqITUrehs0siM9IQ4DqhL4DgKBkYOLI/W6mW\nCXkQVFkGGLovzFUMM/wpK1Ua20k+0XakblI11yK3fjd0XJ0K5FyQ1YzG9XXZ8EuZo/2p2A\n8Y/K54JYuMflOJVftQAAABZoYW5uZXNAZGFrYXIuZGEuY3dpLm5sAQID\n-----END OPENSSH PRIVATE KEY-----\n" > id_rsa_solaris
340:         - chmod 400 id_rsa_solaris
341:         - export SSHFLAGS="-o LogLevel=ERROR -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i id_rsa_solaris"
342:         - export SCMD="ssh $SSHFLAGS -p 2222 root@localhost"
343:         - sleep 60
344:         - while ! $SCMD ls ; do sleep 30 ; done
345:         - $SCMD 'bash -c "echo 'nameserver 8.8.8.8' > /etc/resolv.conf"'
346: 
347:       script:
348:         - python scripts/amalgamation.py > /dev/null
349:         - rsync -a -e "ssh $SSHFLAGS -p 2222" --exclude=.git --exclude=build --exclude=third_party/sqllogictest --exclude=third_party/imdb .  root@localhost:/duckdb
350:         - $SCMD 'rm -rf /duckdb/build && mkdir -p /duckdb/build && cd /duckdb/build && export PATH=/opt/csw/bin/:$PATH CXX=g++ CC=gcc  && cmake -DCMAKE_AR=/opt/csw/bin/gar -DCMAKE_BUILD_TYPE=Debug -DAMALGAMATION_BUILD=1 .. && gmake -j2'
351:         - $SCMD /duckdb/build/test/unittest "~[copy]~[file_system]~[.]"
352: 
353: 
354:     - os: linux
355:       dist: bionic
356:       name: OpenBSD VM
357:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
358:       sudo: true
359: 
360:       install:
361:         - wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -
362:         - echo -e "\ndeb [arch=amd64] https://download.virtualbox.org/virtualbox/debian bionic contrib\n" | sudo tee -a /etc/apt/sources.list
363:         - sudo apt-get update > /dev/null
364:         - sudo apt-get install -y linux-headers-$(uname -r) virtualbox-5.2 rsync
365:         - wget -q "https://homepages.cwi.nl/~hannes/86Cv27lf5353lJR/OpenBSD.ova"
366:         - VBoxManage import OpenBSD.ova
367:         - rm OpenBSD.ova
368:         - VBoxManage modifyvm "OpenBSD" --usb off --usbehci off --usbxhci off --cpus 2 --hwvirtex on --memory 6114
369:         - VBoxManage startvm "OpenBSD" --type headless
370:         - echo -e "-----BEGIN OPENSSH PRIVATE KEY-----\nb3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABFwAAAAdzc2gtcn\nNhAAAAAwEAAQAAAQEA0I/POwsFY/l5DGvybl1amd9pqzP5ADPQGWupcNuKbSYq+sD4g5Jr\nqZ0vG9sULeYlZZFHzdbUqzdbK9rMZZOUwUwHbxViS2UlhCo0onB9bbzm6kQ2gSBaXxa8SC\nwllEdHq6c/kK50MZKVwqpBrxIJtGN08pNauhMPNMdniQZD5slkKrneTgGYnm30xNtkHStB\nY/btURWNlVd8Qedx8gSEV5628cAeKJAPOn4nrCYvy7uMWBOYqrqZii38uxdrhnZKKKENcA\ndUuFRdmFDK/0d+/0PeUYUacZm3HRU5F21440u51OdBMzBYe9AaQXQGrwKwY+YxlczlVh8g\n9XMWYBzJ3wAAA9B959FqfefRagAAAAdzc2gtcnNhAAABAQDQj887CwVj+XkMa/JuXVqZ32\nmrM/kAM9AZa6lw24ptJir6wPiDkmupnS8b2xQt5iVlkUfN1tSrN1sr2sxlk5TBTAdvFWJL\nZSWEKjSicH1tvObqRDaBIFpfFrxILCWUR0erpz+QrnQxkpXCqkGvEgm0Y3Tyk1q6Ew80x2\neJBkPmyWQqud5OAZiebfTE22QdK0Fj9u1RFY2VV3xB53HyBIRXnrbxwB4okA86fiesJi/L\nu4xYE5iqupmKLfy7F2uGdkoooQ1wB1S4VF2YUMr/R37/Q95RhRpxmbcdFTkXbXjjS7nU50\nEzMFh70BpBdAavArBj5jGVzOVWHyD1cxZgHMnfAAAAAwEAAQAAAQB6iVPfQ81p/MRDKRUq\nBM1bhKkH/qQ4mziUBu5psYN2N6ue4kvgueFpqUFpY2FKymKEd0QxyxvucLqvXIEk2P3YR/\nxCJtU2qPnO2iFMozz+gbNGRsejPEf8gFYlLVLy+KJCVySAtA7upUo6MmAfJUDwbFLkxvDS\nTKptfw70seqpJ/CdUXqrd/YAfwqGO0ZgQC59MDTGS1rXViRbTEMOxbWg9TMmvWb36vJG8i\nvSGimXL0gvhB7himZzK0z9tl8r3gHIHpiKy+67tzXyDdzXxpTJ7krBIwVgMgHwZpSy++c6\n9e6ag9LH217gWSDX4C0tAnHhjc5QqlCBwZVe/n2Kyg3pAAAAgQC1zeKHT3XLt9NfBVjhfq\nS3lMByGNCR90RS1vZe+wYVuChFCs7ztraWgMX9n7m3HvaGj+lqDPBD6mkoaYFCqKVr5GcH\nq1fij2sZeEpymhOUjX/aWGr9kdnxkvpSzYt33OU7hQIv34ViSXuyiEVb/SYXxqmwaYhCbW\noAlXqS57U3ZAAAAIEA58ImmEbbHDbA+mUZ1xugtb2heIQyVm+B1FtWtOY3B7LKgfgP5kaw\nhhVAlOfpxSyn/aNWdokE6JsFU/Vs/eiEXmn253ofF0J2kQuVD8+0m+yUMkbDYbfyc9FPsR\n1OS4cqjM8ET77EvLiqIHXO8aWr4eCOJxjDJLC0xVKOicgk/JUAAACBAOZghEZOuUgLjB1K\nQ0kMX+CTNvyKB44eY24kbp22KI4hsEw4BwyqPvCyRZsx7EBGXdGO0giVc41T6WJxwLVCbW\nmG1AC03KQ/lPXf/lzuwT4/N52hw+s4EmHlcPfoPyRFtbZuUyJqlhL4txWZdI31Ot0jxiQK\nxePoxUuMva2261ujAAAAFWhhbm5lc0BoZXJiZXJ0Mi5sb2NhbAECAwQF\n-----END OPENSSH PRIVATE KEY-----\n" > id_rsa_openbsd
371:         - chmod 400 id_rsa_openbsd
372:         - export SSHFLAGS="-o LogLevel=ERROR -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i id_rsa_openbsd"
373:         - export SCMD="ssh $SSHFLAGS -p 2222 root@localhost"
374:         - sleep 60
375:         - while ! $SCMD ls ; do sleep 30 ; done
376:         - $SCMD pkg_add gmake rsync-3.1.3
377: 
378:       script:
379:         - python scripts/amalgamation.py > /dev/null
380:         - rsync -a -e "ssh $SSHFLAGS -p 2222" --exclude=.git --exclude=build --exclude=third_party/sqllogictest .  root@localhost:/home/duckdb
381:         - travis_wait 30 $SCMD 'rm -rf /home/duckdb/build && mkdir -p /home/duckdb/build && cd /home/duckdb/build && cmake -DCMAKE_BUILD_TYPE=Debug -DAMALGAMATION_BUILD=1 .. && gmake -j2'
382:         - $SCMD /home/duckdb/build/test/unittest "~[copy]~[sqlitelogic]~[sqlserver]~[parquet]~[.]"
383: 
384: 
385: # APIs: REST, r / python packages
386: 
387: 
388:     - os: linux
389:       dist: xenial
390:       name: REST Server
391:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
392: 
393:       before_install:
394:         - pip install --user boto3
395: 
396:       script:
397:         - cd tools/rest
398:         - python3 test_the_rest.py
399: 
400:       # after_success:
401:       #   - python tools/upload-s3.py lib-linux-amd64 build/release/src/libduckdb*.so build/release/src/libduckdb*.a
402: 
403: 
404:     - os: linux
405:       dist: xenial
406:       name: JDBC Compliance
407:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
408: 
409:       env:
410:         - JAVA_HOME='/usr/lib/jvm/java-8-openjdk-amd64'
411: 
412:       before_install:
413:         - sudo apt-get update > /dev/null
414:         - sudo apt-get install -y openjdk-8-jdk openjdk-8-jre
415: 
416:       script:
417:         - mkdir -p build/release
418:         - (cd build/release && cmake -DCMAKE_BUILD_TYPE=Release -DJDBC_DRIVER=1 ../.. && cmake --build .)
419:         - java -cp build/release/tools/jdbc/DuckDBJ.jar nl.cwi.da.duckdb.test.TestDuckDBJDBC
420:         - git clone https://github.com/cwida/jdbccts.git
421:         - (cd jdbccts && make DUCKDB_JAR=../build/release/tools/jdbc/DuckDBJ.jar test)
422: 
423:     - os: linux
424:       name: R Package
425: 
426:       dist: xenial
427:       language: r
428:       r: devel
429: 
430:       before_install:
431:         - pip install --user boto3
432:         - cd tools/rpkg
433:         - R -f dependencies.R
434: 
435:       install:
436:         - ./configure
437:         - R CMD build .
438:         - R CMD INSTALL duckdb_*.tar.gz
439: 
440:       script:
441:         - (cd tests && R -f testthat.R)
442:         - R -f ../../examples/R/dbi.R
443:         - R -f ../../examples/R/dplyr.R
444: 
445:       after_success:
446:         - R -e "tools::write_PACKAGES(dir = '.', type = 'source')"
447:         - python ../upload-s3.py rstats/src/contrib duckdb_*.tar.gz PACKAGES*
448:         - python ../upload-s3.py rstats duckdb_*.tar.gz
449: 
450: 
451:     - os: osx
452:       osx_image: xcode11.3
453:       name: R Package
454:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
455: 
456:       language: r
457:       #r: devel
458: 
459:       before_install:
460:         - curl https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py
461:         - python3 /tmp/get-pip.py
462:         - python3 -m pip install --user boto3
463:         - cd tools/rpkg
464:         - R -f dependencies.R
465: 
466:       install:
467:         - ./configure
468:         - R CMD build .
469:         - R CMD INSTALL --build duckdb_*.tar.gz
470:         - R CMD INSTALL duckdb_*.tgz
471: 
472:       script:
473:         - (cd tests && R -f testthat.R)
474: 
475:       after_success:
476:         - R -e "tools::write_PACKAGES(dir = '.', type = 'mac.binary')"
477:         - python3 ../upload-s3.py rstats/bin/macosx/el-capitan/contrib/3.6 duckdb_*.tgz PACKAGES*
478:         - python3 ../upload-s3.py rstats duckdb_*.tgz
479: 
480: 
481:     - os: windows
482:       name: R Package
483:       filter_secrets: false
484:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
485: 
486:       language: cpp
487: 
488:       before_script:
489:         - choco install r.project -y --version 3.6.0
490:         - wget "https://github.com/hannesmuehleisen/choco-rtools/raw/master/rtools.3.5.0.nupkg"
491:         - choco install rtools -s rtools.3.5.0.nupkg -f -y
492:         - choco install python3 --version 3.7.3 -y --params "/InstallDir:C:\Python37-x64"
493:         - choco install curl -y --force
494: 
495:       script:
496:         - export "PATH=/c/Rtools/bin:$PATH"
497:         - cd tools/rpkg
498:         - C:/Program\ Files/R/R-3.6.0/bin/R.exe -f dependencies.R
499:         - sh configure
500:         - C:/Program\ Files/R/R-3.6.0/bin/R.exe CMD build .
501:         - C:/Program\ Files/R/R-3.6.0/bin/R.exe CMD INSTALL --build --no-multiarch duckdb_*.tar.gz
502:         - C:/Program\ Files/R/R-3.6.0/bin/R.exe CMD INSTALL duckdb_*.zip
503:         - (cd tests; C:/Program\ Files/R/R-3.6.0/bin/R.exe -f testthat.R)
504: 
505:       after_success:
506:         - C:/Python37-x64/python.exe ../upload-s3.py rstats duckdb_*.zip
507:         - C:/Program\ Files/R/R-3.6.0/bin/R.exe -e "tools::write_PACKAGES(dir = '.', type = 'win.binary')"
508:         - C:/Python37-x64/python.exe ../upload-s3.py rstats/bin/windows/contrib/3.6 duckdb_*.zip PACKAGES*
509: 
510: 
511:     - os: linux
512:       name: Python 3 Package
513: 
514:       dist: xenial
515:       language: python
516:       cache: pip
517:       env:
518:         - CIBW_BUILD='cp37-*'
519:       python: 3.7
520: 
521:       script:
522:         - pip install cibuildwheel==0.10.2 boto3
523:         - cd tools/pythonpkg
524:         - python setup.py sdist
525:         - mkdir duckdb_tarball && tar xvf dist/duckdb-*.tar.gz --strip-components=1 -C duckdb_tarball
526:         - cibuildwheel --output-dir wheelhouse duckdb_tarball
527:         - cd ../..
528:       after_success:
529:         python tools/upload-s3.py python tools/pythonpkg/wheelhouse/*.whl tools/pythonpkg/dist/duckdb-*.tar.gz
530: 
531:     - os: linux
532:       name: Python 2 Package
533:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
534: 
535:       dist: xenial
536:       language: python
537:       cache: pip
538:       env:
539:         - CIBW_BUILD='cp27-*'
540:       python: 3.7
541: 
542:       script:
543:         - pip install cibuildwheel==0.10.2 boto3
544:         - cd tools/pythonpkg
545:         - python setup.py sdist
546:         - mkdir duckdb_tarball && tar xvf dist/duckdb-*.tar.gz --strip-components=1 -C duckdb_tarball
547:         - cibuildwheel --output-dir wheelhouse duckdb_tarball
548:         - cd ../..
549:       after_success:
550:         python tools/upload-s3.py python tools/pythonpkg/wheelhouse/*.whl tools/pythonpkg/dist/duckdb-*.tar.gz
551: 
552: 
553:     - os: osx
554:       name: Python Package
555:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
556: 
557:       language: generic
558:       osx_image: xcode11.3
559: 
560:       before_install:
561:         - curl https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py
562:         - python3 /tmp/get-pip.py
563:         - python3 -m pip install cibuildwheel==0.10.2 boto3
564: 
565:       script:
566:         - cd tools/pythonpkg
567:         - python3 setup.py sdist
568:         - mkdir duckdb_tarball && tar xvf dist/duckdb-*.tar.gz --strip-components=1 -C duckdb_tarball
569:         - cibuildwheel --output-dir wheelhouse duckdb_tarball
570:         - cd ../..
571: 
572:       after_success:
573:         python3 tools/upload-s3.py python tools/pythonpkg/wheelhouse/*.whl
574: 
575: 
576:     - os: windows
577:       name: Python Package
578:       if: (type = push AND branch = master) OR type = pull_request OR tag =~ /^v\d+\.\d+\.\d+$/
579: 
580:       language: cpp
581:       filter_secrets: false
582:       # no python 27 because no C++11 support in its windows toolchain
583:       env:
584:         - CIBW_BUILD='cp37-*'
585: 
586:       before_install:
587:         - choco install python3 --version 3.7.3 --sidebyside -y --forcex86 --force --params "/InstallDir:C:\Python37"
588:         - choco install python3 --version 3.7.3 --sidebyside -y --force --params "/InstallDir:C:\Python37-x64"
589:         - choco install python3 --version 3.6.8 --sidebyside -y --force --params "/InstallDir:C:\Python36-x64"
590:         - choco install python3 --version 3.6.8 --sidebyside -y --forcex86 --force --params "/InstallDir:C:\Python36"
591:         - choco install python2 --version 2.7.16 --sidebyside -y --forcex86 --force --params "/InstallDir:C:\Python27"
592:         - choco install python2 --version 2.7.16 --sidebyside -y --force --params "/InstallDir:C:\Python27-x64"
593:         - choco install curl -y --force
594:         - C:/Python37-x64/python.exe -m pip install --upgrade pip
595:         - C:/Python37-x64/python.exe -m pip install "cibuildwheel==0.10.2"
596:         - C:/Python37-x64/python.exe -m pip install "numpy>=1.16" "pandas>=0.24" "pytest>=4.3" "pybind11>=2.4"
597: 
598:       script:
599:         - cd tools/pythonpkg
600:         - C:/Python37-x64/python.exe  setup.py sdist
601:         - mkdir duckdb_tarball && tar xvf dist/duckdb-*.tar.gz --strip-components=1 -C duckdb_tarball
602:         - C:/Python37-x64/python.exe -m cibuildwheel --platform windows --output-dir wheelhouse duckdb_tarball
603:         - cd ../..
604: 
605:       after_success:
606:         C:/Python37-x64/python.exe tools/upload-s3.py python tools/pythonpkg/wheelhouse/*.whl
607: 
[end of .travis.yml]
[start of src/common/types.cpp]
1: #include "duckdb/common/types.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/serializer.hpp"
5: #include "duckdb/common/string_util.hpp"
6: #include "duckdb/common/types/string_type.hpp"
7: 
8: #include <cmath>
9: 
10: using namespace std;
11: 
12: namespace duckdb {
13: 
14: const SQLType SQLType::SQLNULL = SQLType(SQLTypeId::SQLNULL);
15: const SQLType SQLType::BOOLEAN = SQLType(SQLTypeId::BOOLEAN);
16: const SQLType SQLType::TINYINT = SQLType(SQLTypeId::TINYINT);
17: const SQLType SQLType::SMALLINT = SQLType(SQLTypeId::SMALLINT);
18: const SQLType SQLType::INTEGER = SQLType(SQLTypeId::INTEGER);
19: const SQLType SQLType::BIGINT = SQLType(SQLTypeId::BIGINT);
20: const SQLType SQLType::FLOAT = SQLType(SQLTypeId::FLOAT);
21: const SQLType SQLType::DOUBLE = SQLType(SQLTypeId::DOUBLE);
22: const SQLType SQLType::DATE = SQLType(SQLTypeId::DATE);
23: const SQLType SQLType::TIMESTAMP = SQLType(SQLTypeId::TIMESTAMP);
24: const SQLType SQLType::TIME = SQLType(SQLTypeId::TIME);
25: 
26: const SQLType SQLType::VARCHAR = SQLType(SQLTypeId::VARCHAR);
27: 
28: // TODO these are incomplete and should maybe not exist as such
29: const SQLType SQLType::STRUCT = SQLType(SQLTypeId::STRUCT);
30: const SQLType SQLType::LIST = SQLType(SQLTypeId::LIST);
31: 
32: const SQLType SQLType::ANY = SQLType(SQLTypeId::ANY);
33: 
34: const vector<SQLType> SQLType::NUMERIC = {
35:     SQLType::TINYINT, SQLType::SMALLINT, SQLType::INTEGER,           SQLType::BIGINT,
36:     SQLType::FLOAT,   SQLType::DOUBLE,   SQLType(SQLTypeId::DECIMAL)};
37: 
38: const vector<SQLType> SQLType::INTEGRAL = {SQLType::TINYINT, SQLType::SMALLINT, SQLType::INTEGER, SQLType::BIGINT};
39: 
40: const vector<SQLType> SQLType::ALL_TYPES = {
41:     SQLType::BOOLEAN, SQLType::TINYINT,   SQLType::SMALLINT, SQLType::INTEGER, SQLType::BIGINT,
42:     SQLType::DATE,    SQLType::TIMESTAMP, SQLType::DOUBLE,   SQLType::FLOAT,   SQLType(SQLTypeId::DECIMAL),
43:     SQLType::VARCHAR};
44: // TODO add LIST/STRUCT here
45: 
46: const TypeId ROW_TYPE = TypeId::INT64;
47: 
48: string TypeIdToString(TypeId type) {
49: 	switch (type) {
50: 	case TypeId::BOOL:
51: 		return "BOOL";
52: 	case TypeId::INT8:
53: 		return "INT8";
54: 	case TypeId::INT16:
55: 		return "INT16";
56: 	case TypeId::INT32:
57: 		return "INT32";
58: 	case TypeId::INT64:
59: 		return "INT64";
60: 	case TypeId::HASH:
61: 		return "HASH";
62: 	case TypeId::POINTER:
63: 		return "POINTER";
64: 	case TypeId::FLOAT:
65: 		return "FLOAT";
66: 	case TypeId::DOUBLE:
67: 		return "DOUBLE";
68: 	case TypeId::VARCHAR:
69: 		return "VARCHAR";
70: 	case TypeId::VARBINARY:
71: 		return "VARBINARY";
72: 	case TypeId::STRUCT:
73: 		return "STRUCT<?>";
74: 	case TypeId::LIST:
75: 		return "LIST<?>";
76: 	default:
77: 		throw ConversionException("Invalid TypeId %d", type);
78: 	}
79: }
80: 
81: idx_t GetTypeIdSize(TypeId type) {
82: 	switch (type) {
83: 	case TypeId::BOOL:
84: 		return sizeof(bool);
85: 	case TypeId::INT8:
86: 		return sizeof(int8_t);
87: 	case TypeId::INT16:
88: 		return sizeof(int16_t);
89: 	case TypeId::INT32:
90: 		return sizeof(int32_t);
91: 	case TypeId::INT64:
92: 		return sizeof(int64_t);
93: 	case TypeId::FLOAT:
94: 		return sizeof(float);
95: 	case TypeId::DOUBLE:
96: 		return sizeof(double);
97: 	case TypeId::HASH:
98: 		return sizeof(hash_t);
99: 	case TypeId::POINTER:
100: 		return sizeof(uintptr_t);
101: 	case TypeId::VARCHAR:
102: 		return sizeof(string_t);
103: 	case TypeId::STRUCT:
104: 		return 0; // no own payload
105: 	case TypeId::LIST:
106: 		return 16; // offset + len
107: 	case TypeId::VARBINARY:
108: 		return sizeof(blob_t);
109: 	default:
110: 		throw ConversionException("Invalid TypeId %d", type);
111: 	}
112: }
113: 
114: SQLType SQLTypeFromInternalType(TypeId type) {
115: 	switch (type) {
116: 	case TypeId::BOOL:
117: 		return SQLType(SQLTypeId::BOOLEAN);
118: 	case TypeId::INT8:
119: 		return SQLType::TINYINT;
120: 	case TypeId::INT16:
121: 		return SQLType::SMALLINT;
122: 	case TypeId::INT32:
123: 		return SQLType::INTEGER;
124: 	case TypeId::INT64:
125: 		return SQLType::BIGINT;
126: 	case TypeId::FLOAT:
127: 		return SQLType::FLOAT;
128: 	case TypeId::DOUBLE:
129: 		return SQLType::DOUBLE;
130: 	case TypeId::VARCHAR:
131: 		return SQLType::VARCHAR;
132: 	case TypeId::VARBINARY:
133: 		return SQLType(SQLTypeId::VARBINARY);
134: 	case TypeId::STRUCT:
135: 		return SQLType(SQLTypeId::STRUCT); // TODO we do not know the child types here
136: 	case TypeId::LIST:
137: 		return SQLType(SQLTypeId::LIST);
138: 	default:
139: 		throw ConversionException("Invalid TypeId %d", type);
140: 	}
141: }
142: 
143: bool TypeIsConstantSize(TypeId type) {
144: 	return (type >= TypeId::BOOL && type <= TypeId::DOUBLE) ||
145: 	       (type >= TypeId::FIXED_SIZE_BINARY && type <= TypeId::DECIMAL) || type == TypeId::HASH ||
146: 	       type == TypeId::POINTER;
147: }
148: bool TypeIsIntegral(TypeId type) {
149: 	return (type >= TypeId::UINT8 && type <= TypeId::INT64) || type == TypeId::HASH || type == TypeId::POINTER;
150: }
151: bool TypeIsNumeric(TypeId type) {
152: 	return type >= TypeId::UINT8 && type <= TypeId::DOUBLE;
153: }
154: bool TypeIsInteger(TypeId type) {
155: 	return type >= TypeId::UINT8 && type <= TypeId::INT64;
156: }
157: 
158: void SQLType::Serialize(Serializer &serializer) {
159: 	serializer.Write(id);
160: 	serializer.Write(width);
161: 	serializer.Write(scale);
162: }
163: 
164: SQLType SQLType::Deserialize(Deserializer &source) {
165: 	auto id = source.Read<SQLTypeId>();
166: 	auto width = source.Read<uint16_t>();
167: 	auto scale = source.Read<uint8_t>();
168: 	return SQLType(id, width, scale);
169: }
170: 
171: string SQLTypeIdToString(SQLTypeId id) {
172: 	switch (id) {
173: 	case SQLTypeId::BOOLEAN:
174: 		return "BOOLEAN";
175: 	case SQLTypeId::TINYINT:
176: 		return "TINYINT";
177: 	case SQLTypeId::SMALLINT:
178: 		return "SMALLINT";
179: 	case SQLTypeId::INTEGER:
180: 		return "INTEGER";
181: 	case SQLTypeId::BIGINT:
182: 		return "BIGINT";
183: 	case SQLTypeId::DATE:
184: 		return "DATE";
185: 	case SQLTypeId::TIME:
186: 		return "TIME";
187: 	case SQLTypeId::TIMESTAMP:
188: 		return "TIMESTAMP";
189: 	case SQLTypeId::FLOAT:
190: 		return "FLOAT";
191: 	case SQLTypeId::DOUBLE:
192: 		return "DOUBLE";
193: 	case SQLTypeId::DECIMAL:
194: 		return "DECIMAL";
195: 	case SQLTypeId::VARCHAR:
196: 		return "VARCHAR";
197: 	case SQLTypeId::VARBINARY:
198: 		return "VARBINARY";
199: 	case SQLTypeId::CHAR:
200: 		return "CHAR";
201: 	case SQLTypeId::SQLNULL:
202: 		return "NULL";
203: 	case SQLTypeId::ANY:
204: 		return "ANY";
205: 	case SQLTypeId::STRUCT:
206: 		return "STRUCT<?>";
207: 	case SQLTypeId::LIST:
208: 		return "LIST<?>";
209: 	default:
210: 		return "INVALID";
211: 	}
212: }
213: 
214: string SQLTypeToString(SQLType type) {
215: 	// FIXME: display width/scale
216: 	switch (type.id) {
217: 	case SQLTypeId::STRUCT: {
218: 		string ret = "STRUCT<";
219: 		for (size_t i = 0; i < type.child_type.size(); i++) {
220: 			ret += type.child_type[i].first + ": " + SQLTypeToString(type.child_type[i].second);
221: 			if (i < type.child_type.size() - 1) {
222: 				ret += ", ";
223: 			}
224: 		}
225: 		ret += ">";
226: 		return ret;
227: 	}
228: 	case SQLTypeId::LIST: {
229: 		if (type.child_type.size() == 0) {
230: 			return "LIST<?>";
231: 		}
232: 		if (type.child_type.size() != 1) {
233: 			throw Exception("List needs a single child element");
234: 		}
235: 		return "LIST<" + SQLTypeToString(type.child_type[0].second) + ">";
236: 	}
237: 	default:
238: 		return SQLTypeIdToString(type.id);
239: 	}
240: }
241: 
242: SQLType TransformStringToSQLType(string str) {
243: 	auto lower_str = StringUtil::Lower(str);
244: 	// Transform column type
245: 	if (lower_str == "int" || lower_str == "int4" || lower_str == "signed" || lower_str == "integer" ||
246: 	    lower_str == "integral" || lower_str == "int32") {
247: 		return SQLType::INTEGER;
248: 	} else if (lower_str == "varchar" || lower_str == "bpchar" || lower_str == "text" || lower_str == "string" ||
249: 	           lower_str == "char") {
250: 		return SQLType::VARCHAR;
251: 	} else if (lower_str == "int8" || lower_str == "bigint" || lower_str == "int64" || lower_str == "long") {
252: 		return SQLType::BIGINT;
253: 	} else if (lower_str == "int2" || lower_str == "smallint" || lower_str == "short" || lower_str == "int16") {
254: 		return SQLType::SMALLINT;
255: 	} else if (lower_str == "timestamp" || lower_str == "datetime") {
256: 		return SQLType::TIMESTAMP;
257: 	} else if (lower_str == "bool" || lower_str == "boolean" || lower_str == "logical") {
258: 		return SQLType(SQLTypeId::BOOLEAN);
259: 	} else if (lower_str == "real" || lower_str == "float4" || lower_str == "float") {
260: 		return SQLType::FLOAT;
261: 	} else if (lower_str == "double" || lower_str == "numeric" || lower_str == "float8") {
262: 		return SQLType::DOUBLE;
263: 	} else if (lower_str == "tinyint" || lower_str == "int1") {
264: 		return SQLType::TINYINT;
265: 	} else if (lower_str == "varbinary") {
266: 		return SQLType(SQLTypeId::VARBINARY);
267: 	} else if (lower_str == "date") {
268: 		return SQLType::DATE;
269: 	} else if (lower_str == "time") {
270: 		return SQLType::TIME;
271: 	} else {
272: 		throw NotImplementedException("DataType %s not supported yet...\n", str.c_str());
273: 	}
274: }
275: 
276: bool SQLType::IsIntegral() const {
277: 	switch (id) {
278: 	case SQLTypeId::TINYINT:
279: 	case SQLTypeId::SMALLINT:
280: 	case SQLTypeId::INTEGER:
281: 	case SQLTypeId::BIGINT:
282: 		return true;
283: 	default:
284: 		return false;
285: 	}
286: }
287: 
288: bool SQLType::IsNumeric() const {
289: 	switch (id) {
290: 	case SQLTypeId::TINYINT:
291: 	case SQLTypeId::SMALLINT:
292: 	case SQLTypeId::INTEGER:
293: 	case SQLTypeId::BIGINT:
294: 	case SQLTypeId::FLOAT:
295: 	case SQLTypeId::DOUBLE:
296: 	case SQLTypeId::DECIMAL:
297: 		return true;
298: 	default:
299: 		return false;
300: 	}
301: }
302: 
303: TypeId GetInternalType(SQLType type) {
304: 	switch (type.id) {
305: 	case SQLTypeId::BOOLEAN:
306: 		return TypeId::BOOL;
307: 	case SQLTypeId::TINYINT:
308: 		return TypeId::INT8;
309: 	case SQLTypeId::SMALLINT:
310: 		return TypeId::INT16;
311: 	case SQLTypeId::SQLNULL:
312: 	case SQLTypeId::DATE:
313: 	case SQLTypeId::TIME:
314: 	case SQLTypeId::INTEGER:
315: 		return TypeId::INT32;
316: 	case SQLTypeId::BIGINT:
317: 	case SQLTypeId::TIMESTAMP:
318: 		return TypeId::INT64;
319: 	case SQLTypeId::FLOAT:
320: 		return TypeId::FLOAT;
321: 	case SQLTypeId::DOUBLE:
322: 		return TypeId::DOUBLE;
323: 	case SQLTypeId::DECIMAL:
324: 		// FIXME: for now
325: 		return TypeId::DOUBLE;
326: 	case SQLTypeId::VARCHAR:
327: 	case SQLTypeId::CHAR:
328: 		return TypeId::VARCHAR;
329: 	case SQLTypeId::VARBINARY:
330: 		return TypeId::VARBINARY;
331: 	case SQLTypeId::STRUCT:
332: 		return TypeId::STRUCT;
333: 	case SQLTypeId::LIST:
334: 		return TypeId::LIST;
335: 	case SQLTypeId::ANY:
336: 		return TypeId::INVALID;
337: 	default:
338: 		throw ConversionException("Invalid SQLType %s", SQLTypeToString(type).c_str());
339: 	}
340: }
341: 
342: SQLType MaxSQLType(SQLType left, SQLType right) {
343: 	if (left.id < right.id) {
344: 		return right;
345: 	} else if (right.id < left.id) {
346: 		return left;
347: 	} else if (left.width > right.width) {
348: 		return left;
349: 	} else {
350: 		return right;
351: 	}
352: }
353: 
354: bool ApproxEqual(float ldecimal, float rdecimal) {
355: 	float epsilon = fabs(rdecimal) * 0.01;
356: 	return fabs(ldecimal - rdecimal) <= epsilon;
357: }
358: 
359: bool ApproxEqual(double ldecimal, double rdecimal) {
360: 	double epsilon = fabs(rdecimal) * 0.01;
361: 	return fabs(ldecimal - rdecimal) <= epsilon;
362: }
363: 
364: } // namespace duckdb
[end of src/common/types.cpp]
[start of src/execution/operator/helper/physical_pragma.cpp]
1: #include "duckdb/execution/operator/helper/physical_pragma.hpp"
2: 
3: #include "duckdb/main/client_context.hpp"
4: #include "duckdb/main/database.hpp"
5: #include "duckdb/storage/storage_manager.hpp"
6: #include "duckdb/storage/buffer_manager.hpp"
7: #include "duckdb/common/operator/cast_operators.hpp"
8: 
9: #include <cctype>
10: 
11: using namespace duckdb;
12: using namespace std;
13: 
14: static idx_t ParseMemoryLimit(string arg);
15: 
16: void PhysicalPragma::GetChunkInternal(ClientContext &context, DataChunk &chunk, PhysicalOperatorState *state) {
17: 	auto &pragma = *info;
18: 	auto &keyword = pragma.name;
19: 	if (keyword == "enable_profile" || keyword == "enable_profiling") {
20: 		// enable profiling
21: 		if (pragma.pragma_type == PragmaType::ASSIGNMENT) {
22: 			// enable_profiling with assignment
23: 			// this is either enable_profiling = json, or enable_profiling = query_tree
24: 			string assignment = pragma.parameters[0].ToString();
25: 			if (assignment == "json") {
26: 				context.profiler.automatic_print_format = ProfilerPrintFormat::JSON;
27: 			} else if (assignment == "query_tree") {
28: 				context.profiler.automatic_print_format = ProfilerPrintFormat::QUERY_TREE;
29: 			} else {
30: 				throw ParserException("Unrecognized print format %s, supported formats: [json, query_tree]",
31: 				                      assignment.c_str());
32: 			}
33: 		} else if (pragma.pragma_type == PragmaType::NOTHING) {
34: 			context.profiler.automatic_print_format = ProfilerPrintFormat::QUERY_TREE;
35: 		} else {
36: 			throw ParserException("Cannot call PRAGMA enable_profiling");
37: 		}
38: 		context.profiler.Enable();
39: 	} else if (keyword == "disable_profile" || keyword == "disable_profiling") {
40: 		if (pragma.pragma_type != PragmaType::NOTHING) {
41: 			throw ParserException("disable_profiling cannot take parameters!");
42: 		}
43: 		// enable profiling
44: 		context.profiler.Disable();
45: 		context.profiler.automatic_print_format = ProfilerPrintFormat::NONE;
46: 	} else if (keyword == "profiling_output" || keyword == "profile_output") {
47: 		// set file location of where to save profiling output
48: 		if (pragma.pragma_type != PragmaType::ASSIGNMENT || pragma.parameters[0].type != TypeId::VARCHAR) {
49: 			throw ParserException(
50: 			    "Profiling output must be an assignment (e.g. PRAGMA profile_output='/tmp/test.json')");
51: 		}
52: 		context.profiler.save_location = pragma.parameters[0].str_value;
53: 	} else if (keyword == "memory_limit") {
54: 		if (pragma.pragma_type != PragmaType::ASSIGNMENT) {
55: 			throw ParserException("Memory limit must be an assignment (e.g. PRAGMA memory_limit='1GB')");
56: 		}
57: 		if (pragma.parameters[0].type == TypeId::VARCHAR) {
58: 			idx_t new_limit = ParseMemoryLimit(pragma.parameters[0].str_value);
59: 			// set the new limit in the buffer manager
60: 			context.db.storage->buffer_manager->SetLimit(new_limit);
61: 		} else {
62: 			int64_t value = pragma.parameters[0].GetValue<int64_t>();
63: 			if (value < 0) {
64: 				// limit < 0, set limit to infinite
65: 				context.db.storage->buffer_manager->SetLimit();
66: 			} else {
67: 				throw ParserException(
68: 				    "Memory limit must be an assignment with a memory unit (e.g. PRAGMA memory_limit='1GB')");
69: 			}
70: 		}
71: 	} else {
72: 		throw ParserException("Unrecognized PRAGMA keyword: %s", keyword.c_str());
73: 	}
74: }
75: 
76: idx_t ParseMemoryLimit(string arg) {
77: 	// split based on the number/non-number
78: 	idx_t idx = 0;
79: 	while (std::isspace(arg[idx])) {
80: 		idx++;
81: 	}
82: 	idx_t num_start = idx;
83: 	while ((arg[idx] >= '0' && arg[idx] <= '9') || arg[idx] == '.' || arg[idx] == 'e' || arg[idx] == 'E' ||
84: 	       arg[idx] == '-') {
85: 		idx++;
86: 	}
87: 	if (idx == num_start) {
88: 		throw ParserException("Memory limit must have a number (e.g. PRAGMA memory_limit=1GB");
89: 	}
90: 	string number = arg.substr(num_start, idx - num_start);
91: 
92: 	// try to parse the number
93: 	double limit = Cast::Operation<string_t, double>(number.c_str());
94: 
95: 	// now parse the memory limit unit (e.g. bytes, gb, etc)
96: 	while (std::isspace(arg[idx])) {
97: 		idx++;
98: 	}
99: 	idx_t start = idx;
100: 	while (idx < arg.size() && !std::isspace(arg[idx])) {
101: 		idx++;
102: 	}
103: 	if (limit < 0) {
104: 		// limit < 0, set limit to infinite
105: 		return (idx_t)-1;
106: 	}
107: 	string unit = StringUtil::Lower(arg.substr(start, idx - start));
108: 	idx_t multiplier;
109: 	if (unit == "byte" || unit == "bytes" || unit == "b") {
110: 		multiplier = 1;
111: 	} else if (unit == "kilobyte" || unit == "kilobytes" || unit == "kb" || unit == "k") {
112: 		multiplier = 1000LL;
113: 	} else if (unit == "megabyte" || unit == "megabytes" || unit == "mb" || unit == "m") {
114: 		multiplier = 1000LL * 1000LL;
115: 	} else if (unit == "gigabyte" || unit == "gigabytes" || unit == "gb" || unit == "g") {
116: 		multiplier = 1000LL * 1000LL * 1000LL;
117: 	} else if (unit == "terabyte" || unit == "terabytes" || unit == "tb" || unit == "t") {
118: 		multiplier = 1000LL * 1000LL * 1000LL * 1000LL;
119: 	} else {
120: 		throw ParserException("Unknown unit for memory_limit: %s (expected: b, mb, gb or tb)", unit.c_str());
121: 	}
122: 	return (idx_t)multiplier * limit;
123: }
[end of src/execution/operator/helper/physical_pragma.cpp]
[start of src/function/function.cpp]
1: #include "duckdb/function/function.hpp"
2: #include "duckdb/function/aggregate_function.hpp"
3: #include "duckdb/function/scalar_function.hpp"
4: #include "duckdb/function/cast_rules.hpp"
5: 
6: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
7: #include "duckdb/planner/expression/bound_cast_expression.hpp"
8: #include "duckdb/planner/expression/bound_function_expression.hpp"
9: 
10: #include "duckdb/common/string_util.hpp"
11: #include "duckdb/catalog/catalog.hpp"
12: #include "duckdb/parser/parsed_data/create_aggregate_function_info.hpp"
13: #include "duckdb/parser/parsed_data/create_scalar_function_info.hpp"
14: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
15: 
16: using namespace duckdb;
17: using namespace std;
18: 
19: // add your initializer for new functions here
20: void BuiltinFunctions::Initialize() {
21: 	RegisterSQLiteFunctions();
22: 	RegisterReadFunctions();
23: 
24: 	RegisterAlgebraicAggregates();
25: 	RegisterDistributiveAggregates();
26: 	RegisterNestedAggregates();
27: 
28: 	RegisterDateFunctions();
29: 	RegisterMathFunctions();
30: 	RegisterOperators();
31: 	RegisterSequenceFunctions();
32: 	RegisterStringFunctions();
33: 	RegisterNestedFunctions();
34: 	RegisterTrigonometricsFunctions();
35: }
36: 
37: BuiltinFunctions::BuiltinFunctions(ClientContext &context, Catalog &catalog) : context(context), catalog(catalog) {
38: }
39: 
40: void BuiltinFunctions::AddFunction(AggregateFunctionSet set) {
41: 	CreateAggregateFunctionInfo info(set);
42: 	catalog.CreateFunction(context, &info);
43: }
44: 
45: void BuiltinFunctions::AddFunction(AggregateFunction function) {
46: 	CreateAggregateFunctionInfo info(function);
47: 	catalog.CreateFunction(context, &info);
48: }
49: 
50: void BuiltinFunctions::AddFunction(ScalarFunction function) {
51: 	CreateScalarFunctionInfo info(function);
52: 	catalog.CreateFunction(context, &info);
53: }
54: 
55: void BuiltinFunctions::AddFunction(ScalarFunctionSet set) {
56: 	CreateScalarFunctionInfo info(set);
57: 	catalog.CreateFunction(context, &info);
58: }
59: 
60: void BuiltinFunctions::AddFunction(TableFunction function) {
61: 	CreateTableFunctionInfo info(function);
62: 	catalog.CreateTableFunction(context, &info);
63: }
64: 
65: string Function::CallToString(string name, vector<SQLType> arguments) {
66: 	string result = name + "(";
67: 	result += StringUtil::Join(arguments, arguments.size(), ", ",
68: 	                           [](const SQLType &argument) { return SQLTypeToString(argument); });
69: 	return result + ")";
70: }
71: 
72: string Function::CallToString(string name, vector<SQLType> arguments, SQLType return_type) {
73: 	string result = CallToString(name, arguments);
74: 	result += " -> " + SQLTypeToString(return_type);
75: 	return result;
76: }
77: 
78: static int64_t BindVarArgsFunctionCost(SimpleFunction &func, vector<SQLType> &arguments) {
79: 	if (arguments.size() < func.arguments.size()) {
80: 		// not enough arguments to fulfill the non-vararg part of the function
81: 		return -1;
82: 	}
83: 	int64_t cost = 0;
84: 	for (idx_t i = 0; i < arguments.size(); i++) {
85: 		SQLType arg_type = i < func.arguments.size() ? func.arguments[i] : func.varargs;
86: 		if (arguments[i] == arg_type) {
87: 			// arguments match: do nothing
88: 			continue;
89: 		}
90: 		int64_t cast_cost = CastRules::ImplicitCast(arguments[i], arg_type);
91: 		if (cast_cost >= 0) {
92: 			// we can implicitly cast, add the cost to the total cost
93: 			cost += cast_cost;
94: 		} else {
95: 			// we can't implicitly cast: throw an error
96: 			return -1;
97: 		}
98: 	}
99: 	return cost;
100: }
101: 
102: static int64_t BindFunctionCost(SimpleFunction &func, vector<SQLType> &arguments) {
103: 	if (func.HasVarArgs()) {
104: 		// special case varargs function
105: 		return BindVarArgsFunctionCost(func, arguments);
106: 	}
107: 	if (func.arguments.size() != arguments.size()) {
108: 		// invalid argument count: check the next function
109: 		return -1;
110: 	}
111: 	int64_t cost = 0;
112: 	for (idx_t i = 0; i < arguments.size(); i++) {
113: 		if (arguments[i] == func.arguments[i]) {
114: 			// arguments match: do nothing
115: 			continue;
116: 		}
117: 		int64_t cast_cost = CastRules::ImplicitCast(arguments[i], func.arguments[i]);
118: 		if (cast_cost >= 0) {
119: 			// we can implicitly cast, add the cost to the total cost
120: 			cost += cast_cost;
121: 		} else {
122: 			// we can't implicitly cast: throw an error
123: 			return -1;
124: 		}
125: 	}
126: 	return cost;
127: }
128: 
129: template <class T>
130: static idx_t BindFunctionFromArguments(string name, vector<T> &functions, vector<SQLType> &arguments) {
131: 	idx_t best_function = INVALID_INDEX;
132: 	int64_t lowest_cost = numeric_limits<int64_t>::max();
133: 	vector<idx_t> conflicting_functions;
134: 	for (idx_t f_idx = 0; f_idx < functions.size(); f_idx++) {
135: 		auto &func = functions[f_idx];
136: 		// check the arguments of the function
137: 		int64_t cost = BindFunctionCost(func, arguments);
138: 		if (cost < 0) {
139: 			// auto casting was not possible
140: 			continue;
141: 		}
142: 		if (cost == lowest_cost) {
143: 			conflicting_functions.push_back(f_idx);
144: 			continue;
145: 		}
146: 		if (cost > lowest_cost) {
147: 			continue;
148: 		}
149: 		conflicting_functions.clear();
150: 		lowest_cost = cost;
151: 		best_function = f_idx;
152: 	}
153: 	if (conflicting_functions.size() > 0) {
154: 		// there are multiple possible function definitions
155: 		// throw an exception explaining which overloads are there
156: 		conflicting_functions.push_back(best_function);
157: 		string call_str = Function::CallToString(name, arguments);
158: 		string candidate_str = "";
159: 		for (auto &conf : conflicting_functions) {
160: 			auto &f = functions[conf];
161: 			candidate_str += "\t" + f.ToString() + "\n";
162: 		}
163: 		throw BinderException("Could not choose a best candidate function for the function call \"%s\". In order to "
164: 		                      "select one, please add explicit type casts.\n\tCandidate functions:\n%s",
165: 		                      call_str.c_str(), candidate_str.c_str());
166: 	}
167: 	if (best_function == INVALID_INDEX) {
168: 		// no matching function was found, throw an error
169: 		string call_str = Function::CallToString(name, arguments);
170: 		string candidate_str = "";
171: 		for (auto &f : functions) {
172: 			candidate_str += "\t" + f.ToString() + "\n";
173: 		}
174: 		throw BinderException("No function matches the given name and argument types '%s'. You might need to add "
175: 		                      "explicit type casts.\n\tCandidate functions:\n%s",
176: 		                      call_str.c_str(), candidate_str.c_str());
177: 	}
178: 	return best_function;
179: }
180: 
181: idx_t Function::BindFunction(string name, vector<ScalarFunction> &functions, vector<SQLType> &arguments) {
182: 	return BindFunctionFromArguments(name, functions, arguments);
183: }
184: 
185: idx_t Function::BindFunction(string name, vector<AggregateFunction> &functions, vector<SQLType> &arguments) {
186: 	return BindFunctionFromArguments(name, functions, arguments);
187: }
188: 
189: void SimpleFunction::CastToFunctionArguments(vector<unique_ptr<Expression>> &children, vector<SQLType> &types) {
190: 	for (idx_t i = 0; i < types.size(); i++) {
191: 		auto target_type = i < this->arguments.size() ? this->arguments[i] : this->varargs;
192: 		if (target_type.id != SQLTypeId::ANY && types[i] != target_type) {
193: 			// type of child does not match type of function argument: add a cast
194: 			children[i] = BoundCastExpression::AddCastToType(move(children[i]), types[i], target_type);
195: 		}
196: 	}
197: }
198: 
199: unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientContext &context, string schema,
200:                                                                        string name, vector<SQLType> &arguments,
201:                                                                        vector<unique_ptr<Expression>> children,
202:                                                                        bool is_operator) {
203: 	// bind the function
204: 	auto function = Catalog::GetCatalog(context).GetEntry(context, CatalogType::SCALAR_FUNCTION, schema, name);
205: 	assert(function && function->type == CatalogType::SCALAR_FUNCTION);
206: 	return ScalarFunction::BindScalarFunction(context, (ScalarFunctionCatalogEntry &)*function, arguments,
207: 	                                          move(children), is_operator);
208: }
209: 
210: unique_ptr<BoundFunctionExpression>
211: ScalarFunction::BindScalarFunction(ClientContext &context, ScalarFunctionCatalogEntry &func, vector<SQLType> &arguments,
212:                                    vector<unique_ptr<Expression>> children, bool is_operator) {
213: 	// bind the function
214: 	idx_t best_function = Function::BindFunction(func.name, func.functions, arguments);
215: 	// found a matching function!
216: 	auto &bound_function = func.functions[best_function];
217: 	// check if we need to add casts to the children
218: 	bound_function.CastToFunctionArguments(children, arguments);
219: 
220: 	// now create the function
221: 	auto result =
222: 	    make_unique<BoundFunctionExpression>(GetInternalType(bound_function.return_type), bound_function, is_operator);
223: 	result->children = move(children);
224: 	result->arguments = arguments;
225: 	result->sql_return_type = bound_function.return_type;
226: 	if (bound_function.bind) {
227: 		result->bind_info = bound_function.bind(*result, context);
228: 	}
229: 	return result;
230: }
[end of src/function/function.cpp]
[start of src/function/scalar/date/current.cpp]
1: #include "duckdb/function/scalar/date_functions.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/types/date.hpp"
5: #include "duckdb/common/types/timestamp.hpp"
6: #include "duckdb/common/vector_operations/vector_operations.hpp"
7: 
8: using namespace std;
9: 
10: namespace duckdb {
11: 
12: static void current_time_function(DataChunk &input, ExpressionState &state, Vector &result) {
13: 	assert(input.column_count() == 0);
14: 
15: 	auto val = Value::INTEGER(Timestamp::GetTime(Timestamp::GetCurrentTimestamp()));
16: 	result.Reference(val);
17: }
18: 
19: static void current_date_function(DataChunk &input, ExpressionState &state, Vector &result) {
20: 	assert(input.column_count() == 0);
21: 
22: 	auto val = Value::INTEGER(Timestamp::GetDate(Timestamp::GetCurrentTimestamp()));
23: 	result.Reference(val);
24: }
25: 
26: static void current_timestamp_function(DataChunk &input, ExpressionState &state, Vector &result) {
27: 	assert(input.column_count() == 0);
28: 
29: 	auto val = Value::TIMESTAMP(Timestamp::GetCurrentTimestamp());
30: 	result.Reference(val);
31: }
32: 
33: void CurrentTimeFun::RegisterFunction(BuiltinFunctions &set) {
34: 	ScalarFunctionSet current_time("current_time");
35: 	current_time.AddFunction(ScalarFunction({}, SQLType::TIME, current_time_function));
36: 	set.AddFunction(current_time);
37: }
38: 
39: void CurrentDateFun::RegisterFunction(BuiltinFunctions &set) {
40: 	ScalarFunctionSet current_date("current_date");
41: 	current_date.AddFunction(ScalarFunction({}, SQLType::DATE, current_date_function));
42: 	set.AddFunction(current_date);
43: }
44: 
45: void CurrentTimestampFun::RegisterFunction(BuiltinFunctions &set) {
46: 	ScalarFunctionSet current_timestamp("current_timestamp");
47: 	current_timestamp.AddFunction(ScalarFunction({}, SQLType::TIMESTAMP, current_timestamp_function));
48: 	set.AddFunction(current_timestamp);
49: 
50: 	ScalarFunctionSet now("now");
51: 	now.AddFunction(ScalarFunction({}, SQLType::TIMESTAMP, current_timestamp_function));
52: 	set.AddFunction(now);
53: }
54: 
55: } // namespace duckdb
[end of src/function/scalar/date/current.cpp]
[start of src/function/scalar/math/numeric.cpp]
1: #include "duckdb/function/scalar/math_functions.hpp"
2: #include "duckdb/common/vector_operations/vector_operations.hpp"
3: #include "duckdb/function/scalar/trigonometric_functions.hpp"
4: 
5: #include <algorithm>
6: #include <cmath>
7: 
8: using namespace std;
9: 
10: namespace duckdb {
11: 
12: struct UnaryDoubleWrapper {
13: 	template <class FUNC, class OP, class INPUT_TYPE, class RESULT_TYPE>
14: 	static inline RESULT_TYPE Operation(FUNC fun, INPUT_TYPE input, nullmask_t &nullmask, idx_t idx) {
15: 		RESULT_TYPE result = OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input);
16: 		if (std::isnan(result) || std::isinf(result) || errno != 0) {
17: 			errno = 0;
18: 			nullmask[idx] = true;
19: 			return 0;
20: 		}
21: 		return result;
22: 	}
23: };
24: 
25: template <class T, class OP>
26: static void UnaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {
27: 	assert(input.column_count() >= 1);
28: 	errno = 0;
29: 	UnaryExecutor::Execute<T, T, OP, true, UnaryDoubleWrapper>(input.data[0], result, input.size());
30: }
31: 
32: struct BinaryDoubleWrapper {
33: 	template <class FUNC, class OP, class TA, class TB, class TR>
34: 	static inline TR Operation(FUNC fun, TA left, TB right, nullmask_t &nullmask, idx_t idx) {
35: 		TR result = OP::template Operation<TA, TB, TR>(left, right);
36: 		if (std::isnan(result) || std::isinf(result) || errno != 0) {
37: 			errno = 0;
38: 			nullmask[idx] = true;
39: 			return 0;
40: 		}
41: 		return result;
42: 	}
43: };
44: 
45: template <class T, class OP>
46: static void BinaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {
47: 	assert(input.column_count() >= 2);
48: 	errno = 0;
49: 	BinaryExecutor::Execute<T, T, T, OP, true, BinaryDoubleWrapper>(input.data[0], input.data[1], result, input.size());
50: }
51: 
52: //===--------------------------------------------------------------------===//
53: // abs
54: //===--------------------------------------------------------------------===//
55: struct AbsOperator {
56: 	template <class TA, class TR> static inline TR Operation(TA left) {
57: 		return left < 0 ? left * -1 : left;
58: 	}
59: };
60: 
61: void AbsFun::RegisterFunction(BuiltinFunctions &set) {
62: 	ScalarFunctionSet abs("abs");
63: 	for (auto &type : SQLType::NUMERIC) {
64: 		abs.AddFunction(ScalarFunction({type}, type, ScalarFunction::GetScalarUnaryFunction<AbsOperator>(type)));
65: 	}
66: 	set.AddFunction(abs);
67: }
68: 
69: //===--------------------------------------------------------------------===//
70: // sign
71: //===--------------------------------------------------------------------===//
72: struct SignOperator {
73: 	template <class TA, class TR> static inline TR Operation(TA left) {
74: 		if (left == TA(0))
75: 			return 0;
76: 		else if (left > TA(0))
77: 			return 1;
78: 		else
79: 			return -1;
80: 	}
81: };
82: 
83: void SignFun::RegisterFunction(BuiltinFunctions &set) {
84: 	ScalarFunctionSet sign("sign");
85: 	for (auto &type : SQLType::NUMERIC) {
86: 		sign.AddFunction(ScalarFunction({type}, SQLType::TINYINT,
87: 		                                ScalarFunction::GetScalarUnaryFunctionFixedReturn<int8_t, SignOperator>(type)));
88: 	}
89: 	set.AddFunction(sign);
90: }
91: 
92: //===--------------------------------------------------------------------===//
93: // ceil
94: //===--------------------------------------------------------------------===//
95: struct CeilOperator {
96: 	template <class TA, class TR> static inline TR Operation(TA left) {
97: 		return ceil(left);
98: 	}
99: };
100: 
101: void CeilFun::RegisterFunction(BuiltinFunctions &set) {
102: 	ScalarFunctionSet ceil("ceil");
103: 	for (auto &type : SQLType::NUMERIC) {
104: 		scalar_function_t func;
105: 		if (type.IsIntegral()) {
106: 			// ceil on integral type is a nop
107: 			func = ScalarFunction::NopFunction;
108: 		} else {
109: 			func = ScalarFunction::GetScalarUnaryFunction<CeilOperator>(type);
110: 		}
111: 		ceil.AddFunction(ScalarFunction({type}, type, func));
112: 	}
113: 	set.AddFunction(ceil);
114: 	ceil.name = "ceiling";
115: 	set.AddFunction(ceil);
116: }
117: 
118: //===--------------------------------------------------------------------===//
119: // floor
120: //===--------------------------------------------------------------------===//
121: struct FloorOperator {
122: 	template <class TA, class TR> static inline TR Operation(TA left) {
123: 		return floor(left);
124: 	}
125: };
126: 
127: void FloorFun::RegisterFunction(BuiltinFunctions &set) {
128: 	ScalarFunctionSet floor("floor");
129: 	for (auto &type : SQLType::NUMERIC) {
130: 		scalar_function_t func;
131: 		if (type.IsIntegral()) {
132: 			// floor on integral type is a nop
133: 			func = ScalarFunction::NopFunction;
134: 		} else {
135: 			func = ScalarFunction::GetScalarUnaryFunction<FloorOperator>(type);
136: 		}
137: 		floor.AddFunction(ScalarFunction({type}, type, func));
138: 	}
139: 	set.AddFunction(floor);
140: }
141: 
142: //===--------------------------------------------------------------------===//
143: // round
144: //===--------------------------------------------------------------------===//
145: struct RoundOperator {
146: 	template <class TA, class TB, class TR> static inline TR Operation(TA input, TB precision) {
147: 		if (precision < 0) {
148: 			precision = 0;
149: 		}
150: 		double modifier = pow(10, precision);
151: 		double rounded_value = (round(input * modifier)) / modifier;
152: 		if (std::isinf(rounded_value) || std::isnan(rounded_value)) {
153: 			return input;
154: 		}
155: 		return rounded_value;
156: 	}
157: };
158: 
159: void RoundFun::RegisterFunction(BuiltinFunctions &set) {
160: 	ScalarFunctionSet round("round");
161: 	for (auto &type : SQLType::NUMERIC) {
162: 		scalar_function_t func;
163: 		if (type.IsIntegral()) {
164: 			// round on integral type is a nop
165: 			func = ScalarFunction::NopFunction;
166: 		} else if (type.id == SQLTypeId::FLOAT) {
167: 			func = ScalarFunction::BinaryFunction<float, int32_t, float, RoundOperator>;
168: 		} else {
169: 			assert(type.id == SQLTypeId::DOUBLE || type.id == SQLTypeId::DECIMAL);
170: 			func = ScalarFunction::BinaryFunction<double, int32_t, double, RoundOperator>;
171: 		}
172: 		round.AddFunction(ScalarFunction({type, SQLType::INTEGER}, type, func));
173: 	}
174: 	set.AddFunction(round);
175: }
176: 
177: //===--------------------------------------------------------------------===//
178: // exp
179: //===--------------------------------------------------------------------===//
180: struct ExpOperator {
181: 	template <class TA, class TR> static inline TR Operation(TA left) {
182: 		return exp(left);
183: 	}
184: };
185: 
186: void ExpFun::RegisterFunction(BuiltinFunctions &set) {
187: 	set.AddFunction(
188: 	    ScalarFunction("exp", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, ExpOperator>));
189: }
190: 
191: //===--------------------------------------------------------------------===//
192: // pow
193: //===--------------------------------------------------------------------===//
194: struct PowOperator {
195: 	template <class TA, class TB, class TR> static inline TR Operation(TA base, TB exponent) {
196: 		return pow(base, exponent);
197: 	}
198: };
199: 
200: void PowFun::RegisterFunction(BuiltinFunctions &set) {
201: 	ScalarFunction power_function("pow", {SQLType::DOUBLE, SQLType::DOUBLE}, SQLType::DOUBLE,
202: 	                              BinaryDoubleFunctionWrapper<double, PowOperator>);
203: 	set.AddFunction(power_function);
204: 	power_function.name = "power";
205: 	set.AddFunction(power_function);
206: }
207: 
208: //===--------------------------------------------------------------------===//
209: // sqrt
210: //===--------------------------------------------------------------------===//
211: struct SqrtOperator {
212: 	template <class TA, class TR> static inline TR Operation(TA left) {
213: 		return sqrt(left);
214: 	}
215: };
216: 
217: void SqrtFun::RegisterFunction(BuiltinFunctions &set) {
218: 	set.AddFunction(
219: 	    ScalarFunction("sqrt", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, SqrtOperator>));
220: }
221: 
222: //===--------------------------------------------------------------------===//
223: // cbrt
224: //===--------------------------------------------------------------------===//
225: struct CbRtOperator {
226: 	template <class TA, class TR> static inline TR Operation(TA left) {
227: 		return cbrt(left);
228: 	}
229: };
230: 
231: void CbrtFun::RegisterFunction(BuiltinFunctions &set) {
232: 	set.AddFunction(
233: 	    ScalarFunction("cbrt", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, CbRtOperator>));
234: }
235: 
236: //===--------------------------------------------------------------------===//
237: // ln
238: //===--------------------------------------------------------------------===//
239: 
240: struct LnOperator {
241: 	template <class TA, class TR> static inline TR Operation(TA left) {
242: 		return log(left);
243: 	}
244: };
245: 
246: void LnFun::RegisterFunction(BuiltinFunctions &set) {
247: 	set.AddFunction(
248: 	    ScalarFunction("ln", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, LnOperator>));
249: }
250: 
251: //===--------------------------------------------------------------------===//
252: // log
253: //===--------------------------------------------------------------------===//
254: struct Log10Operator {
255: 	template <class TA, class TR> static inline TR Operation(TA left) {
256: 		return log10(left);
257: 	}
258: };
259: 
260: void Log10Fun::RegisterFunction(BuiltinFunctions &set) {
261: 	ScalarFunction log_function("log10", {SQLType::DOUBLE}, SQLType::DOUBLE,
262: 	                            UnaryDoubleFunctionWrapper<double, Log10Operator>);
263: 	set.AddFunction(log_function);
264: 	// "log" is an alias for "log10"
265: 	log_function.name = "log";
266: 	set.AddFunction(log_function);
267: }
268: 
269: //===--------------------------------------------------------------------===//
270: // log2
271: //===--------------------------------------------------------------------===//
272: struct Log2Operator {
273: 	template <class TA, class TR> static inline TR Operation(TA left) {
274: 		return log2(left);
275: 	}
276: };
277: 
278: void Log2Fun::RegisterFunction(BuiltinFunctions &set) {
279: 	set.AddFunction(
280: 	    ScalarFunction("log2", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, Log2Operator>));
281: }
282: 
283: //===--------------------------------------------------------------------===//
284: // pi
285: //===--------------------------------------------------------------------===//
286: Value pi_value = Value::DOUBLE(PI);
287: 
288: static void pi_function(DataChunk &args, ExpressionState &state, Vector &result) {
289: 	assert(args.column_count() == 0);
290: 	result.Reference(pi_value);
291: }
292: 
293: void PiFun::RegisterFunction(BuiltinFunctions &set) {
294: 	set.AddFunction(ScalarFunction("pi", {}, SQLType::DOUBLE, pi_function));
295: }
296: 
297: //===--------------------------------------------------------------------===//
298: // degrees
299: //===--------------------------------------------------------------------===//
300: struct DegreesOperator {
301: 	template <class TA, class TR> static inline TR Operation(TA left) {
302: 		return left * (180 / PI);
303: 	}
304: };
305: 
306: void DegreesFun::RegisterFunction(BuiltinFunctions &set) {
307: 	set.AddFunction(ScalarFunction("degrees", {SQLType::DOUBLE}, SQLType::DOUBLE,
308: 	                               UnaryDoubleFunctionWrapper<double, DegreesOperator>));
309: }
310: 
311: //===--------------------------------------------------------------------===//
312: // radians
313: //===--------------------------------------------------------------------===//
314: struct RadiansOperator {
315: 	template <class TA, class TR> static inline TR Operation(TA left) {
316: 		return left * (PI / 180);
317: 	}
318: };
319: 
320: void RadiansFun::RegisterFunction(BuiltinFunctions &set) {
321: 	set.AddFunction(ScalarFunction("radians", {SQLType::DOUBLE}, SQLType::DOUBLE,
322: 	                               UnaryDoubleFunctionWrapper<double, RadiansOperator>));
323: }
324: 
325: //===--------------------------------------------------------------------===//
326: // sin
327: //===--------------------------------------------------------------------===//
328: struct SinOperator {
329: 	template <class TA, class TR> static inline TR Operation(TA input) {
330: 		return sin(input);
331: 	}
332: };
333: 
334: void SinFun::RegisterFunction(BuiltinFunctions &set) {
335: 	set.AddFunction(
336: 	    ScalarFunction("sin", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, SinOperator>));
337: }
338: 
339: //===--------------------------------------------------------------------===//
340: // cos
341: //===--------------------------------------------------------------------===//
342: struct CosOperator {
343: 	template <class TA, class TR> static inline TR Operation(TA input) {
344: 		return (double)cos(input);
345: 	}
346: };
347: 
348: void CosFun::RegisterFunction(BuiltinFunctions &set) {
349: 	set.AddFunction(
350: 	    ScalarFunction("cos", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, CosOperator>));
351: }
352: 
353: //===--------------------------------------------------------------------===//
354: // tan
355: //===--------------------------------------------------------------------===//
356: struct TanOperator {
357: 	template <class TA, class TR> static inline TR Operation(TA input) {
358: 		return (double)tan(input);
359: 	}
360: };
361: 
362: void TanFun::RegisterFunction(BuiltinFunctions &set) {
363: 	set.AddFunction(
364: 	    ScalarFunction("tan", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, TanOperator>));
365: }
366: 
367: //===--------------------------------------------------------------------===//
368: // asin
369: //===--------------------------------------------------------------------===//
370: struct ASinOperator {
371: 	template <class TA, class TR> static inline TR Operation(TA input) {
372: 		if (input < -1 || input > 1) {
373: 			throw Exception("ASIN is undefined outside [-1,1]");
374: 		}
375: 		return (double)asin(input);
376: 	}
377: };
378: 
379: void AsinFun::RegisterFunction(BuiltinFunctions &set) {
380: 	set.AddFunction(
381: 	    ScalarFunction("asin", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, ASinOperator>));
382: }
383: 
384: //===--------------------------------------------------------------------===//
385: // atan
386: //===--------------------------------------------------------------------===//
387: struct ATanOperator {
388: 	template <class TA, class TR> static inline TR Operation(TA input) {
389: 		return (double)atan(input);
390: 	}
391: };
392: 
393: void AtanFun::RegisterFunction(BuiltinFunctions &set) {
394: 	set.AddFunction(
395: 	    ScalarFunction("atan", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, ATanOperator>));
396: }
397: 
398: //===--------------------------------------------------------------------===//
399: // atan2
400: //===--------------------------------------------------------------------===//
401: struct ATan2 {
402: 	template <class TA, class TB, class TR> static inline TR Operation(TA left, TB right) {
403: 		return (double)atan2(left, right);
404: 	}
405: };
406: 
407: void Atan2Fun::RegisterFunction(BuiltinFunctions &set) {
408: 	set.AddFunction(ScalarFunction("atan2", {SQLType::DOUBLE, SQLType::DOUBLE}, SQLType::DOUBLE,
409: 	                               BinaryDoubleFunctionWrapper<double, ATan2>));
410: }
411: 
412: //===--------------------------------------------------------------------===//
413: // acos
414: //===--------------------------------------------------------------------===//
415: struct ACos {
416: 	template <class TA, class TR> static inline TR Operation(TA input) {
417: 		return (double)acos(input);
418: 	}
419: };
420: 
421: void AcosFun::RegisterFunction(BuiltinFunctions &set) {
422: 	set.AddFunction(
423: 	    ScalarFunction("acos", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, ACos>));
424: }
425: 
426: //===--------------------------------------------------------------------===//
427: // cot
428: //===--------------------------------------------------------------------===//
429: struct CotOperator {
430: 	template <class TA, class TR> static inline TR Operation(TA input) {
431: 		return 1.0 / (double)tan(input);
432: 	}
433: };
434: 
435: void CotFun::RegisterFunction(BuiltinFunctions &set) {
436: 	set.AddFunction(
437: 	    ScalarFunction("cot", {SQLType::DOUBLE}, SQLType::DOUBLE, UnaryDoubleFunctionWrapper<double, CotOperator>));
438: }
439: 
440: } // namespace duckdb
[end of src/function/scalar/math/numeric.cpp]
[start of src/function/scalar/string/CMakeLists.txt]
1: add_library_unity(
2:   duckdb_func_string
3:   OBJECT
4:   reverse.cpp
5:   caseconvert.cpp
6:   concat.cpp
7:   length.cpp
8:   like.cpp
9:   printf.cpp
10:   regexp.cpp
11:   substring.cpp
12:   instr.cpp
13:   prefix.cpp
14:   suffix.cpp
15:   contains.cpp)
16: set(ALL_OBJECT_FILES
17:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_func_string>
18:     PARENT_SCOPE)
[end of src/function/scalar/string/CMakeLists.txt]
[start of src/function/scalar/string/caseconvert.cpp]
1: #include "duckdb/function/scalar/string_functions.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/vector_operations/vector_operations.hpp"
5: #include "duckdb/common/vector_operations/unary_executor.hpp"
6: 
7: #include <string.h>
8: 
9: using namespace std;
10: 
11: namespace duckdb {
12: 
13: // TODO: this does not handle UTF characters yet.
14: template <class OP> static void strcase(const char *input_data, idx_t input_length, char *output) {
15: 	for (idx_t i = 0; i < input_length; i++) {
16: 		output[i] = OP::Operation(input_data[i]);
17: 	}
18: 	output[input_length] = '\0';
19: }
20: 
21: template <class OP> static void caseconvert_function(Vector &input, Vector &result, idx_t count) {
22: 	assert(input.type == TypeId::VARCHAR);
23: 
24: 	UnaryExecutor::Execute<string_t, string_t, true>(input, result, count, [&](string_t input) {
25: 		auto input_data = input.GetData();
26: 		auto input_length = input.GetSize();
27: 
28: 		auto target = StringVector::EmptyString(result, input_length);
29: 		strcase<OP>(input_data, input_length, target.GetData());
30: 		target.Finalize();
31: 		return target;
32: 	});
33: }
34: 
35: struct StringToUpper {
36: 	static char Operation(char input) {
37: 		return toupper(input);
38: 	}
39: };
40: 
41: struct StringToLower {
42: 	static char Operation(char input) {
43: 		return tolower(input);
44: 	}
45: };
46: 
47: static void caseconvert_upper_function(DataChunk &args, ExpressionState &state, Vector &result) {
48: 	assert(args.column_count() == 1);
49: 	caseconvert_function<StringToUpper>(args.data[0], result, args.size());
50: }
51: 
52: static void caseconvert_lower_function(DataChunk &args, ExpressionState &state, Vector &result) {
53: 	assert(args.column_count() == 1);
54: 	caseconvert_function<StringToLower>(args.data[0], result, args.size());
55: }
56: 
57: void LowerFun::RegisterFunction(BuiltinFunctions &set) {
58: 	set.AddFunction(ScalarFunction("lower", {SQLType::VARCHAR}, SQLType::VARCHAR, caseconvert_lower_function));
59: }
60: 
61: void UpperFun::RegisterFunction(BuiltinFunctions &set) {
62: 	set.AddFunction(ScalarFunction("upper", {SQLType::VARCHAR}, SQLType::VARCHAR, caseconvert_upper_function));
63: }
64: 
65: } // namespace duckdb
[end of src/function/scalar/string/caseconvert.cpp]
[start of src/function/scalar/string/length.cpp]
1: #include "duckdb/function/scalar/string_functions.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/vector_operations/vector_operations.hpp"
5: 
6: using namespace std;
7: 
8: namespace duckdb {
9: 
10: struct StringLengthOperator {
11: 	template <class TA, class TR> static inline TR Operation(TA input) {
12: 		int64_t length = 0;
13: 		auto input_data = input.GetData();
14: 		auto input_length = input.GetSize();
15: 		for (idx_t i = 0; i < input_length; i++) {
16: 			length += (input_data[i] & 0xC0) != 0x80;
17: 		}
18: 		return length;
19: 	}
20: };
21: 
22: void LengthFun::RegisterFunction(BuiltinFunctions &set) {
23: 	set.AddFunction(ScalarFunction("length", {SQLType::VARCHAR}, SQLType::BIGINT,
24: 	                               ScalarFunction::UnaryFunction<string_t, int64_t, StringLengthOperator, true>));
25: }
26: 
27: } // namespace duckdb
[end of src/function/scalar/string/length.cpp]
[start of src/function/scalar/string/prefix.cpp]
1: #include "duckdb/function/scalar/string_functions.hpp"
2: #include "duckdb/common/types/string_type.hpp"
3: 
4: #include "duckdb/common/exception.hpp"
5: 
6: using namespace std;
7: 
8: namespace duckdb {
9: 
10: static bool prefix(const string_t &str, const string_t &pattern);
11: 
12: struct PrefixOperator {
13: 	template <class TA, class TB, class TR> static inline TR Operation(TA left, TB right) {
14: 		return prefix(left, right);
15: 	}
16: };
17: static bool prefix(const string_t &str, const string_t &pattern) {
18: 	auto str_size = str.GetSize();
19: 	auto patt_length = pattern.GetSize();
20: 	if (patt_length > str_size) {
21: 		return false;
22: 	}
23: 	if (patt_length <= string_t::PREFIX_LENGTH) {
24: 		// short prefix
25: 		if (patt_length == 0) {
26: 			// length = 0, return true
27: 			return true;
28: 		}
29: 
30: 		// prefix early out
31: 		const char *str_pref = str.GetPrefix();
32: 		const char *patt_pref = pattern.GetPrefix();
33: 		for (idx_t i = 0; i < patt_length; ++i) {
34: 			if (str_pref[i] != patt_pref[i])
35: 				return false;
36: 		}
37: 		return true;
38: 	} else {
39: 		// prefix early out
40: 		const char *str_pref = str.GetPrefix();
41: 		const char *patt_pref = pattern.GetPrefix();
42: 		for (idx_t i = 0; i < string_t::PREFIX_LENGTH; ++i) {
43: 			if (str_pref[i] != patt_pref[i]) {
44: 				// early out
45: 				return false;
46: 			}
47: 		}
48: 		// compare the rest of the prefix
49: 		bool equal;
50: 		uint32_t num_char_equals = string_t::PREFIX_LENGTH;
51: 		const char *str_data = str.GetData();
52: 		const char *patt_data = pattern.GetData();
53: 
54: 		for (idx_t i = string_t::PREFIX_LENGTH; i < patt_length; ++i) {
55: 			equal = (str_data[i] == patt_data[i]); // removed branch
56: 			num_char_equals += equal;
57: 		}
58: 
59: 		return (num_char_equals == patt_length);
60: 	}
61: }
62: 
63: ScalarFunction PrefixFun::GetFunction() {
64: 	return ScalarFunction("prefix",                             // name of the function
65: 	                      {SQLType::VARCHAR, SQLType::VARCHAR}, // argument list
66: 	                      SQLType::BOOLEAN,                     // return type
67: 	                      ScalarFunction::BinaryFunction<string_t, string_t, bool, PrefixOperator, true>);
68: }
69: 
70: void PrefixFun::RegisterFunction(BuiltinFunctions &set) {
71: 	set.AddFunction(GetFunction());
72: }
73: 
74: } // namespace duckdb
[end of src/function/scalar/string/prefix.cpp]
[start of src/function/scalar/string/reverse.cpp]
1: #include "duckdb/function/scalar/string_functions.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/vector_operations/vector_operations.hpp"
5: #include "duckdb/common/vector_operations/unary_executor.hpp"
6: 
7: #include <string.h>
8: 
9: using namespace std;
10: 
11: namespace duckdb {
12: 
13: static void strreverse(const char *input, idx_t n, char *output) {
14: 	idx_t bytes = 0;
15: 
16: 	output[n] = 0;
17: 
18: 	while (*input) {
19: 		if (!(*input & 0x80)) { // !*input & 0b10000000
20: 			bytes = 1;
21: 		} else if ((*input & 0xe0) == 0xc0) { // (*input & 0b1110_0000 == 0b1100_0000)
22: 			bytes = 2;
23: 		} else if ((*input & 0xf0) == 0xe0) { // (*input & 0b1111_0000 == 0b1110_0000)
24: 			bytes = 3;
25: 		} else if ((*input & 0xf8) == 0xf0) { // (*input & 0b1111_1000 == 0b1111_0000)
26: 			bytes = 4;
27: 		} else {
28: 			assert(false);
29: 		}
30: 
31: 		memcpy(&output[n - bytes], input, bytes);
32: 		input += bytes;
33: 		n -= bytes;
34: 	}
35: }
36: 
37: static void reverse_chunk_function(DataChunk &args, ExpressionState &state, Vector &result) {
38: 	assert(args.column_count() == 1);
39: 	assert(args.data[0].type == TypeId::VARCHAR);
40: 
41: 	UnaryExecutor::Execute<string_t, string_t, true>(args.data[0], result, args.size(), [&](string_t input) {
42: 		auto input_data = input.GetData();
43: 		auto input_length = input.GetSize();
44: 
45: 		auto target = StringVector::EmptyString(result, input_length);
46: 		strreverse(input_data, input_length, target.GetData());
47: 		target.Finalize();
48: 		return target;
49: 	});
50: }
51: 
52: void ReverseFun::RegisterFunction(BuiltinFunctions &set) {
53: 	set.AddFunction(ScalarFunction("reverse", {SQLType::VARCHAR}, SQLType::VARCHAR, reverse_chunk_function));
54: }
55: 
56: } // namespace duckdb
[end of src/function/scalar/string/reverse.cpp]
[start of src/function/scalar/string/substring.cpp]
1: #include "duckdb/function/scalar/string_functions.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/vector_operations/vector_operations.hpp"
5: #include "duckdb/common/vector_operations/ternary_executor.hpp"
6: 
7: using namespace std;
8: 
9: namespace duckdb {
10: 
11: static string_t substring_scalar_function(string_t input, int offset, int length, unique_ptr<char[]> &output,
12:                                           idx_t &current_len) {
13: 	// reduce offset by one because SQL starts counting at 1
14: 	offset--;
15: 
16: 	if (offset < 0 || length < 0) {
17: 		throw Exception("SUBSTRING cannot handle negative offsets");
18: 	}
19: 
20: 	idx_t required_len = input.GetSize() + 1;
21: 	if (required_len > current_len) {
22: 		// need a resize
23: 		current_len = required_len;
24: 		output = unique_ptr<char[]>{new char[required_len]};
25: 	}
26: 
27: 	// UTF8 chars can use more than one byte
28: 	idx_t input_char_offset = 0;
29: 	idx_t input_byte_offset = 0;
30: 	idx_t output_byte_offset = 0;
31: 
32: 	auto input_string = input.GetData();
33: 
34: 	while (input_string[input_byte_offset]) {
35: 		char b = input_string[input_byte_offset++];
36: 		input_char_offset += (b & 0xC0) != 0x80;
37: 		if (input_char_offset > (idx_t)(offset + length)) {
38: 			break;
39: 		}
40: 		if (input_char_offset > (idx_t)offset) {
41: 			output[output_byte_offset++] = b;
42: 		}
43: 	}
44: 	// terminate output
45: 	output[output_byte_offset] = '\0';
46: 	return string_t(output.get(), output_byte_offset);
47: }
48: 
49: static void substring_function(DataChunk &args, ExpressionState &state, Vector &result) {
50: 	assert(args.column_count() == 3 && args.data[0].type == TypeId::VARCHAR && args.data[1].type == TypeId::INT32 &&
51: 	       args.data[2].type == TypeId::INT32);
52: 	auto &input_vector = args.data[0];
53: 	auto &offset_vector = args.data[1];
54: 	auto &length_vector = args.data[2];
55: 
56: 	idx_t current_len = 0;
57: 	unique_ptr<char[]> output;
58: 	TernaryExecutor::Execute<string_t, int, int, string_t>(
59: 	    input_vector, offset_vector, length_vector, result, args.size(),
60: 	    [&](string_t input_string, int offset, int length) {
61: 		    return StringVector::AddString(
62: 		        result, substring_scalar_function(input_string, offset, length, output, current_len));
63: 	    });
64: }
65: 
66: void SubstringFun::RegisterFunction(BuiltinFunctions &set) {
67: 	set.AddFunction(ScalarFunction("substring",       // name of function
68: 	                               {SQLType::VARCHAR, // argument list
69: 	                                SQLType::INTEGER, SQLType::INTEGER},
70: 	                               SQLType::VARCHAR,     // return type
71: 	                               substring_function)); // pointer to function implementation
72: }
73: 
74: } // namespace duckdb
[end of src/function/scalar/string/substring.cpp]
[start of src/function/scalar/string_functions.cpp]
1: #include "duckdb/function/scalar/string_functions.hpp"
2: 
3: using namespace std;
4: 
5: namespace duckdb {
6: 
7: void BuiltinFunctions::RegisterStringFunctions() {
8: 	Register<ReverseFun>();
9: 	Register<LowerFun>();
10: 	Register<UpperFun>();
11: 	Register<ConcatFun>();
12: 	Register<LengthFun>();
13: 	Register<LikeFun>();
14: 	Register<PrintfFun>();
15: 	Register<RegexpFun>();
16: 	Register<SubstringFun>();
17: 	Register<InstrFun>();
18: 	Register<PrefixFun>();
19: 	Register<SuffixFun>();
20: 	Register<ContainsFun>();
21: }
22: 
23: } // namespace duckdb
[end of src/function/scalar/string_functions.cpp]
[start of src/include/duckdb/common/enums/expression_type.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/enums/expression_type.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/constants.hpp"
12: 
13: namespace duckdb {
14: 
15: //===--------------------------------------------------------------------===//
16: // Predicate Expression Operation Types
17: //===--------------------------------------------------------------------===//
18: enum class ExpressionType : uint8_t {
19: 	INVALID = 0,
20: 
21: 	// explicitly cast left as right (right is integer in ValueType enum)
22: 	OPERATOR_CAST = 12,
23: 	// logical not operator
24: 	OPERATOR_NOT = 13,
25: 	// is null operator
26: 	OPERATOR_IS_NULL = 14,
27: 	// is not null operator
28: 	OPERATOR_IS_NOT_NULL = 15,
29: 
30: 	// -----------------------------
31: 	// Comparison Operators
32: 	// -----------------------------
33: 	// equal operator between left and right
34: 	COMPARE_EQUAL = 25,
35: 	// compare initial boundary
36: 	COMPARE_BOUNDARY_START = COMPARE_EQUAL,
37: 	// inequal operator between left and right
38: 	COMPARE_NOTEQUAL = 26,
39: 	// less than operator between left and right
40: 	COMPARE_LESSTHAN = 27,
41: 	// greater than operator between left and right
42: 	COMPARE_GREATERTHAN = 28,
43: 	// less than equal operator between left and right
44: 	COMPARE_LESSTHANOREQUALTO = 29,
45: 	// greater than equal operator between left and right
46: 	COMPARE_GREATERTHANOREQUALTO = 30,
47: 	// IN operator [left IN (right1, right2, ...)]
48: 	COMPARE_IN = 35,
49: 	// NOT IN operator [left NOT IN (right1, right2, ...)]
50: 	COMPARE_NOT_IN = 36,
51: 	// IS DISTINCT FROM operator
52: 	COMPARE_DISTINCT_FROM = 37,
53: 	// compare final boundary
54: 
55: 	COMPARE_BETWEEN = 38,
56: 	COMPARE_NOT_BETWEEN = 39,
57: 	COMPARE_BOUNDARY_END = COMPARE_NOT_BETWEEN,
58: 
59: 	// -----------------------------
60: 	// Conjunction Operators
61: 	// -----------------------------
62: 	CONJUNCTION_AND = 50,
63: 	CONJUNCTION_OR = 51,
64: 
65: 	// -----------------------------
66: 	// Values
67: 	// -----------------------------
68: 	VALUE_CONSTANT = 75,
69: 	VALUE_PARAMETER = 76,
70: 	VALUE_TUPLE = 77,
71: 	VALUE_TUPLE_ADDRESS = 78,
72: 	VALUE_NULL = 79,
73: 	VALUE_VECTOR = 80,
74: 	VALUE_SCALAR = 81,
75: 	VALUE_DEFAULT = 82,
76: 
77: 	// -----------------------------
78: 	// Aggregates
79: 	// -----------------------------
80: 	AGGREGATE = 100,
81: 	BOUND_AGGREGATE = 101,
82: 
83: 	// -----------------------------
84: 	// Window Functions
85: 	// -----------------------------
86: 	WINDOW_AGGREGATE = 110,
87: 
88: 	WINDOW_RANK = 120,
89: 	WINDOW_RANK_DENSE = 121,
90: 	WINDOW_NTILE = 122,
91: 	WINDOW_PERCENT_RANK = 123,
92: 	WINDOW_CUME_DIST = 124,
93: 	WINDOW_ROW_NUMBER = 125,
94: 
95: 	WINDOW_FIRST_VALUE = 130,
96: 	WINDOW_LAST_VALUE = 131,
97: 	WINDOW_LEAD = 132,
98: 	WINDOW_LAG = 133,
99: 
100: 	// -----------------------------
101: 	// Functions
102: 	// -----------------------------
103: 	FUNCTION = 140,
104: 	BOUND_FUNCTION = 141,
105: 
106: 	// -----------------------------
107: 	// Operators
108: 	// -----------------------------
109: 	CASE_EXPR = 150,
110: 	OPERATOR_NULLIF = 151,
111: 	OPERATOR_COALESCE = 152,
112: 
113: 	// -----------------------------
114: 	// Subquery IN/EXISTS
115: 	// -----------------------------
116: 	SUBQUERY = 175,
117: 
118: 	// -----------------------------
119: 	// Parser
120: 	// -----------------------------
121: 	STAR = 200,
122: 	TABLE_STAR = 201,
123: 	PLACEHOLDER = 202,
124: 	COLUMN_REF = 203,
125: 	FUNCTION_REF = 204,
126: 	TABLE_REF = 205,
127: 
128: 	// -----------------------------
129: 	// Miscellaneous
130: 	// -----------------------------
131: 	CAST = 225,
132: 	COMMON_SUBEXPRESSION = 226,
133: 	BOUND_REF = 227,
134: 	BOUND_COLUMN_REF = 228,
135: 	BOUND_UNNEST = 229
136: };
137: 
138: //===--------------------------------------------------------------------===//
139: // Expression Class
140: //===--------------------------------------------------------------------===//
141: enum class ExpressionClass : uint8_t {
142: 	INVALID = 0,
143: 	//===--------------------------------------------------------------------===//
144: 	// Parsed Expressions
145: 	//===--------------------------------------------------------------------===//
146: 	AGGREGATE = 1,
147: 	CASE = 2,
148: 	CAST = 3,
149: 	COLUMN_REF = 4,
150: 	COMPARISON = 5,
151: 	CONJUNCTION = 6,
152: 	CONSTANT = 7,
153: 	DEFAULT = 8,
154: 	FUNCTION = 9,
155: 	OPERATOR = 10,
156: 	STAR = 11,
157: 	TABLE_STAR = 12,
158: 	SUBQUERY = 13,
159: 	WINDOW = 14,
160: 	PARAMETER = 15,
161: 	//===--------------------------------------------------------------------===//
162: 	// Bound Expressions
163: 	//===--------------------------------------------------------------------===//
164: 	BOUND_AGGREGATE = 25,
165: 	BOUND_CASE = 26,
166: 	BOUND_CAST = 27,
167: 	BOUND_COLUMN_REF = 28,
168: 	BOUND_COMPARISON = 29,
169: 	BOUND_CONJUNCTION = 30,
170: 	BOUND_CONSTANT = 31,
171: 	BOUND_DEFAULT = 32,
172: 	BOUND_FUNCTION = 33,
173: 	BOUND_OPERATOR = 34,
174: 	BOUND_PARAMETER = 35,
175: 	BOUND_REF = 36,
176: 	BOUND_SUBQUERY = 37,
177: 	BOUND_WINDOW = 38,
178: 	BOUND_BETWEEN = 39,
179: 	BOUND_UNNEST = 40,
180: 	//===--------------------------------------------------------------------===//
181: 	// Miscellaneous
182: 	//===--------------------------------------------------------------------===//
183: 	BOUND_EXPRESSION = 50,
184: 	COMMON_SUBEXPRESSION = 51
185: };
186: 
187: string ExpressionTypeToString(ExpressionType type);
188: string ExpressionTypeToOperator(ExpressionType type);
189: 
190: //! Negate a comparison expression, turning e.g. = into !=, or < into >=
191: ExpressionType NegateComparisionExpression(ExpressionType type);
192: //! Flip a comparison expression, turning e.g. < into >, or = into =
193: ExpressionType FlipComparisionExpression(ExpressionType type);
194: 
195: } // namespace duckdb
[end of src/include/duckdb/common/enums/expression_type.hpp]
[start of src/include/duckdb/common/types.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/assert.hpp"
12: #include "duckdb/common/constants.hpp"
13: 
14: #include <type_traits>
15: 
16: namespace duckdb {
17: 
18: class Serializer;
19: class Deserializer;
20: 
21: struct blob_t {
22: 	data_ptr_t data;
23: 	idx_t size;
24: };
25: 
26: struct string_t;
27: 
28: template <class T> using child_list_t = std::vector<std::pair<std::string, T>>;
29: template <class T> using buffer_ptr = std::shared_ptr<T>;
30: 
31: template <class T, typename... Args> buffer_ptr<T> make_buffer(Args &&... args) {
32: 	return std::make_shared<T>(std::forward<Args>(args)...);
33: }
34: 
35: struct list_entry_t {
36: 	list_entry_t() = default;
37: 	list_entry_t(uint64_t offset, uint64_t length) : offset(offset), length(length) {
38: 	}
39: 
40: 	uint64_t offset;
41: 	uint64_t length;
42: };
43: 
44: //===--------------------------------------------------------------------===//
45: // Internal Types
46: //===--------------------------------------------------------------------===//
47: 
48: // taken from arrow's type.h
49: enum class TypeId : uint8_t {
50: 	/// A NULL type having no physical storage
51: 	NA = 0,
52: 
53: 	/// Boolean as 1 bit, LSB bit-packed ordering
54: 	BOOL = 1,
55: 
56: 	/// Unsigned 8-bit little-endian integer
57: 	UINT8 = 2,
58: 
59: 	/// Signed 8-bit little-endian integer
60: 	INT8 = 3,
61: 
62: 	/// Unsigned 16-bit little-endian integer
63: 	UINT16 = 4,
64: 
65: 	/// Signed 16-bit little-endian integer
66: 	INT16 = 5,
67: 
68: 	/// Unsigned 32-bit little-endian integer
69: 	UINT32 = 6,
70: 
71: 	/// Signed 32-bit little-endian integer
72: 	INT32 = 7,
73: 
74: 	/// Unsigned 64-bit little-endian integer
75: 	UINT64 = 8,
76: 
77: 	/// Signed 64-bit little-endian integer
78: 	INT64 = 9,
79: 
80: 	/// 2-byte floating point value
81: 	HALF_FLOAT = 10,
82: 
83: 	/// 4-byte floating point value
84: 	FLOAT = 11,
85: 
86: 	/// 8-byte floating point value
87: 	DOUBLE = 12,
88: 
89: 	/// UTF8 variable-length string as List<Char>
90: 	STRING = 13,
91: 
92: 	/// Variable-length bytes (no guarantee of UTF8-ness)
93: 	BINARY = 14,
94: 
95: 	/// Fixed-size binary. Each value occupies the same number of bytes
96: 	FIXED_SIZE_BINARY = 15,
97: 
98: 	/// int32_t days since the UNIX epoch
99: 	DATE32 = 16,
100: 
101: 	/// int64_t milliseconds since the UNIX epoch
102: 	DATE64 = 17,
103: 
104: 	/// Exact timestamp encoded with int64 since UNIX epoch
105: 	/// Default unit millisecond
106: 	TIMESTAMP = 18,
107: 
108: 	/// Time as signed 32-bit integer, representing either seconds or
109: 	/// milliseconds since midnight
110: 	TIME32 = 19,
111: 
112: 	/// Time as signed 64-bit integer, representing either microseconds or
113: 	/// nanoseconds since midnight
114: 	TIME64 = 20,
115: 
116: 	/// YEAR_MONTH or DAY_TIME interval in SQL style
117: 	INTERVAL = 21,
118: 
119: 	/// Precision- and scale-based decimal type. Storage type depends on the
120: 	/// parameters.
121: 	DECIMAL = 22,
122: 
123: 	/// A list of some logical data type
124: 	LIST = 23,
125: 
126: 	/// Struct of logical types
127: 	STRUCT = 24,
128: 
129: 	/// Unions of logical types
130: 	UNION = 25,
131: 
132: 	/// Dictionary-encoded type, also called "categorical" or "factor"
133: 	/// in other programming languages. Holds the dictionary value
134: 	/// type but not the dictionary itself, which is part of the
135: 	/// ArrayData struct
136: 	DICTIONARY = 26,
137: 
138: 	/// Map, a repeated struct logical type
139: 	MAP = 27,
140: 
141: 	/// Custom data type, implemented by user
142: 	EXTENSION = 28,
143: 
144: 	/// Fixed size list of some logical type
145: 	FIXED_SIZE_LIST = 29,
146: 
147: 	/// Measure of elapsed time in either seconds, milliseconds, microseconds
148: 	/// or nanoseconds.
149: 	DURATION = 30,
150: 
151: 	/// Like STRING, but with 64-bit offsets
152: 	LARGE_STRING = 31,
153: 
154: 	/// Like BINARY, but with 64-bit offsets
155: 	LARGE_BINARY = 32,
156: 
157: 	/// Like LIST, but with 64-bit offsets
158: 	LARGE_LIST = 33,
159: 
160: 	// DuckDB Extensions
161: 	VARCHAR = 200, // our own string representation, different from STRING and LARGE_STRING above
162: 	VARBINARY = 201,
163: 	POINTER = 202,
164: 	HASH = 203,
165: 
166: 	INVALID = 255
167: };
168: 
169: //===--------------------------------------------------------------------===//
170: // SQL Types
171: //===--------------------------------------------------------------------===//
172: enum class SQLTypeId : uint8_t {
173: 	INVALID = 0,
174: 	SQLNULL = 1, /* NULL type, used for constant NULL */
175: 	UNKNOWN = 2, /* unknown type, used for parameter expressions */
176: 	ANY = 3,     /* ANY type, used for functions that accept any type as parameter */
177: 
178: 	BOOLEAN = 10,
179: 	TINYINT = 11,
180: 	SMALLINT = 12,
181: 	INTEGER = 13,
182: 	BIGINT = 14,
183: 	DATE = 15,
184: 	TIME = 16,
185: 	TIMESTAMP = 17,
186: 	FLOAT = 18,
187: 	DOUBLE = 19,
188: 	DECIMAL = 20,
189: 	CHAR = 21,
190: 	VARCHAR = 22,
191: 	VARBINARY = 23,
192: 
193: 	STRUCT = 100,
194: 	LIST = 101
195: };
196: 
197: struct SQLType {
198: 	SQLTypeId id;
199: 	uint16_t width;
200: 	uint8_t scale;
201: 
202: 	// TODO serialize this
203: 	child_list_t<SQLType> child_type;
204: 
205: 	SQLType(SQLTypeId id = SQLTypeId::INVALID, uint16_t width = 0, uint8_t scale = 0)
206: 	    : id(id), width(width), scale(scale) {
207: 	}
208: 
209: 	bool operator==(const SQLType &rhs) const {
210: 		return id == rhs.id && width == rhs.width && scale == rhs.scale;
211: 	}
212: 	bool operator!=(const SQLType &rhs) const {
213: 		return !(*this == rhs);
214: 	}
215: 
216: 	//! Serializes a SQLType to a stand-alone binary blob
217: 	void Serialize(Serializer &serializer);
218: 	//! Deserializes a blob back into an SQLType
219: 	static SQLType Deserialize(Deserializer &source);
220: 
221: 	bool IsIntegral() const;
222: 	bool IsNumeric() const;
223: 
224: public:
225: 	static const SQLType SQLNULL;
226: 	static const SQLType BOOLEAN;
227: 	static const SQLType TINYINT;
228: 	static const SQLType SMALLINT;
229: 	static const SQLType INTEGER;
230: 	static const SQLType BIGINT;
231: 	static const SQLType FLOAT;
232: 	static const SQLType DOUBLE;
233: 	static const SQLType DATE;
234: 	static const SQLType TIMESTAMP;
235: 	static const SQLType TIME;
236: 	static const SQLType VARCHAR;
237: 	static const SQLType STRUCT;
238: 	static const SQLType LIST;
239: 	static const SQLType ANY;
240: 
241: 	//! A list of all NUMERIC types (integral and floating point types)
242: 	static const vector<SQLType> NUMERIC;
243: 	//! A list of all INTEGRAL types
244: 	static const vector<SQLType> INTEGRAL;
245: 	//! A list of ALL SQL types
246: 	static const vector<SQLType> ALL_TYPES;
247: };
248: 
249: string SQLTypeIdToString(SQLTypeId type);
250: string SQLTypeToString(SQLType type);
251: 
252: SQLType MaxSQLType(SQLType left, SQLType right);
253: SQLType TransformStringToSQLType(string str);
254: 
255: //! Gets the internal type associated with the given SQL type
256: TypeId GetInternalType(SQLType type);
257: //! Returns the "simplest" SQL type corresponding to the given type id (e.g. TypeId::INT32 -> SQLTypeId::INTEGER)
258: SQLType SQLTypeFromInternalType(TypeId type);
259: 
260: //! Returns the TypeId for the given type
261: template <class T> TypeId GetTypeId() {
262: 	if (std::is_same<T, bool>()) {
263: 		return TypeId::BOOL;
264: 	} else if (std::is_same<T, int8_t>()) {
265: 		return TypeId::INT8;
266: 	} else if (std::is_same<T, int16_t>()) {
267: 		return TypeId::INT16;
268: 	} else if (std::is_same<T, int32_t>()) {
269: 		return TypeId::INT32;
270: 	} else if (std::is_same<T, int64_t>()) {
271: 		return TypeId::INT64;
272: 	} else if (std::is_same<T, uint64_t>()) {
273: 		return TypeId::HASH;
274: 	} else if (std::is_same<T, uintptr_t>()) {
275: 		return TypeId::POINTER;
276: 	} else if (std::is_same<T, float>()) {
277: 		return TypeId::FLOAT;
278: 	} else if (std::is_same<T, double>()) {
279: 		return TypeId::DOUBLE;
280: 	} else if (std::is_same<T, const char *>() || std::is_same<T, char *>()) {
281: 		return TypeId::VARCHAR;
282: 	} else {
283: 		return TypeId::INVALID;
284: 	}
285: }
286: 
287: template <class T> bool IsValidType() {
288: 	return GetTypeId<T>() != TypeId::INVALID;
289: }
290: 
291: //! The TypeId used by the row identifiers column
292: extern const TypeId ROW_TYPE;
293: 
294: string TypeIdToString(TypeId type);
295: idx_t GetTypeIdSize(TypeId type);
296: bool TypeIsConstantSize(TypeId type);
297: bool TypeIsIntegral(TypeId type);
298: bool TypeIsNumeric(TypeId type);
299: bool TypeIsInteger(TypeId type);
300: 
301: template <class T> bool IsIntegerType() {
302: 	return TypeIsIntegral(GetTypeId<T>());
303: }
304: 
305: bool ApproxEqual(float l, float r);
306: bool ApproxEqual(double l, double r);
307: 
308: }; // namespace duckdb
[end of src/include/duckdb/common/types.hpp]
[start of src/include/duckdb/function/function.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/function.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/types/data_chunk.hpp"
12: #include "duckdb/common/unordered_set.hpp"
13: #include "duckdb/parser/column_definition.hpp"
14: 
15: namespace duckdb {
16: class CatalogEntry;
17: class Catalog;
18: class ClientContext;
19: class Expression;
20: class ExpressionExecutor;
21: class Transaction;
22: 
23: class AggregateFunction;
24: class AggregateFunctionSet;
25: class ScalarFunctionSet;
26: class ScalarFunction;
27: class TableFunction;
28: 
29: struct FunctionData {
30: 	virtual ~FunctionData() {
31: 	}
32: 
33: 	virtual unique_ptr<FunctionData> Copy() = 0;
34: };
35: 
36: struct TableFunctionData : public FunctionData {
37: 	unique_ptr<FunctionData> Copy() override {
38: 		throw NotImplementedException("Copy not required for table-producing function");
39: 	}
40: };
41: 
42: //! Function is the base class used for any type of function (scalar, aggregate or simple function)
43: class Function {
44: public:
45: 	Function(string name) : name(name) {
46: 	}
47: 	virtual ~Function() {
48: 	}
49: 
50: 	//! The name of the function
51: 	string name;
52: 
53: public:
54: 	//! Returns the formatted string name(arg1, arg2, ...)
55: 	static string CallToString(string name, vector<SQLType> arguments);
56: 	//! Returns the formatted string name(arg1, arg2..) -> return_type
57: 	static string CallToString(string name, vector<SQLType> arguments, SQLType return_type);
58: 
59: 	//! Bind a scalar function from the set of functions and input arguments. Returns the index of the chosen function,
60: 	//! or throws an exception if none could be found.
61: 	static idx_t BindFunction(string name, vector<ScalarFunction> &functions, vector<SQLType> &arguments);
62: 	//! Bind an aggregate function from the set of functions and input arguments. Returns the index of the chosen
63: 	//! function, or throws an exception if none could be found.
64: 	static idx_t BindFunction(string name, vector<AggregateFunction> &functions, vector<SQLType> &arguments);
65: };
66: 
67: class SimpleFunction : public Function {
68: public:
69: 	SimpleFunction(string name, vector<SQLType> arguments, SQLType return_type, bool has_side_effects)
70: 	    : Function(name), arguments(move(arguments)), return_type(return_type), varargs(SQLTypeId::INVALID),
71: 	      has_side_effects(has_side_effects) {
72: 	}
73: 	virtual ~SimpleFunction() {
74: 	}
75: 
76: 	//! The set of arguments of the function
77: 	vector<SQLType> arguments;
78: 	//! Return type of the function
79: 	SQLType return_type;
80: 	//! The type of varargs to support, or SQLTypeId::INVALID if the function does not accept variable length arguments
81: 	SQLType varargs;
82: 	//! Whether or not the function has side effects (e.g. sequence increments, random() functions, NOW()). Functions
83: 	//! with side-effects cannot be constant-folded.
84: 	bool has_side_effects;
85: 
86: public:
87: 	//! Cast a set of expressions to the arguments of this function
88: 	void CastToFunctionArguments(vector<unique_ptr<Expression>> &children, vector<SQLType> &types);
89: 
90: 	string ToString() {
91: 		return Function::CallToString(name, arguments, return_type);
92: 	}
93: 
94: 	bool HasVarArgs() {
95: 		return varargs.id != SQLTypeId::INVALID;
96: 	}
97: };
98: 
99: class BuiltinFunctions {
100: public:
101: 	BuiltinFunctions(ClientContext &transaction, Catalog &catalog);
102: 
103: 	//! Initialize a catalog with all built-in functions
104: 	void Initialize();
105: 
106: public:
107: 	void AddFunction(AggregateFunctionSet set);
108: 	void AddFunction(AggregateFunction function);
109: 	void AddFunction(ScalarFunctionSet set);
110: 	void AddFunction(ScalarFunction function);
111: 	void AddFunction(TableFunction function);
112: 
113: private:
114: 	ClientContext &context;
115: 	Catalog &catalog;
116: 
117: private:
118: 	template <class T> void Register() {
119: 		T::RegisterFunction(*this);
120: 	}
121: 
122: 	// table-producing functions
123: 	void RegisterSQLiteFunctions();
124: 	void RegisterReadFunctions();
125: 
126: 	// aggregates
127: 	void RegisterAlgebraicAggregates();
128: 	void RegisterDistributiveAggregates();
129: 	void RegisterNestedAggregates();
130: 
131: 	// scalar functions
132: 	void RegisterDateFunctions();
133: 	void RegisterMathFunctions();
134: 	void RegisterOperators();
135: 	void RegisterStringFunctions();
136: 	void RegisterNestedFunctions();
137: 	void RegisterSequenceFunctions();
138: 	void RegisterTrigonometricsFunctions();
139: };
140: 
141: } // namespace duckdb
[end of src/include/duckdb/function/function.hpp]
[start of src/include/duckdb/function/scalar/string_functions.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/scalar/string_functions.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/scalar_function.hpp"
12: #include "duckdb/function/function_set.hpp"
13: 
14: namespace re2 {
15: class RE2;
16: }
17: 
18: namespace duckdb {
19: 
20: struct ReverseFun {
21: 	static void RegisterFunction(BuiltinFunctions &set);
22: };
23: 
24: struct LowerFun {
25: 	static void RegisterFunction(BuiltinFunctions &set);
26: };
27: 
28: struct UpperFun {
29: 	static void RegisterFunction(BuiltinFunctions &set);
30: };
31: 
32: struct ConcatFun {
33: 	static void RegisterFunction(BuiltinFunctions &set);
34: };
35: 
36: struct ConcatWSFun {
37: 	static void RegisterFunction(BuiltinFunctions &set);
38: };
39: 
40: struct LengthFun {
41: 	static void RegisterFunction(BuiltinFunctions &set);
42: };
43: 
44: struct LikeFun {
45: 	static void RegisterFunction(BuiltinFunctions &set);
46: };
47: 
48: struct RegexpFun {
49: 	static void RegisterFunction(BuiltinFunctions &set);
50: };
51: 
52: struct SubstringFun {
53: 	static void RegisterFunction(BuiltinFunctions &set);
54: };
55: 
56: struct PrintfFun {
57: 	static void RegisterFunction(BuiltinFunctions &set);
58: };
59: 
60: struct InstrFun {
61: 	static void RegisterFunction(BuiltinFunctions &set);
62: };
63: 
64: struct PrefixFun {
65: 	static ScalarFunction GetFunction();
66: 	static void RegisterFunction(BuiltinFunctions &set);
67: };
68: 
69: struct SuffixFun {
70: 	static ScalarFunction GetFunction();
71: 	static void RegisterFunction(BuiltinFunctions &set);
72: };
73: 
74: struct ContainsFun {
75: 	static ScalarFunction GetFunction();
76: 	static void RegisterFunction(BuiltinFunctions &set);
77: };
78: 
79: struct RegexpMatchesBindData : public FunctionData {
80: 	RegexpMatchesBindData(std::unique_ptr<re2::RE2> constant_pattern, string range_min, string range_max,
81: 	                      bool range_success);
82: 	~RegexpMatchesBindData();
83: 
84: 	std::unique_ptr<re2::RE2> constant_pattern;
85: 	string range_min, range_max;
86: 	bool range_success;
87: 
88: 	unique_ptr<FunctionData> Copy() override;
89: };
90: 
91: } // namespace duckdb
[end of src/include/duckdb/function/scalar/string_functions.hpp]
[start of src/include/duckdb/main/database.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/database.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/file_system.hpp"
13: 
14: namespace duckdb {
15: class StorageManager;
16: class Catalog;
17: class TransactionManager;
18: class ConnectionManager;
19: class FileSystem;
20: 
21: enum class AccessMode : uint8_t { UNDEFINED = 0, AUTOMATIC = 1, READ_ONLY = 2, READ_WRITE = 3 };
22: 
23: // this is optional and only used in tests at the moment
24: struct DBConfig {
25: 	friend class DuckDB;
26: 	friend class StorageManager;
27: 
28: public:
29: 	~DBConfig();
30: 
31: 	//! Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE)
32: 	AccessMode access_mode = AccessMode::AUTOMATIC;
33: 	// Checkpoint when WAL reaches this size
34: 	idx_t checkpoint_wal_size = 1 << 20;
35: 	//! Whether or not to use Direct IO, bypassing operating system buffers
36: 	bool use_direct_io = false;
37: 	//! The FileSystem to use, can be overwritten to allow for injecting custom file systems for testing purposes (e.g.
38: 	//! RamFS or something similar)
39: 	unique_ptr<FileSystem> file_system;
40: 	//! The maximum memory used by the database system (in bytes). Default: Infinite
41: 	idx_t maximum_memory = (idx_t)-1;
42: 	//! Whether or not to create and use a temporary directory to store intermediates that do not fit in memory
43: 	bool use_temporary_directory = true;
44: 	//! Directory to store temporary structures that do not fit in memory
45: 	string temporary_directory;
46: 
47: private:
48: 	// FIXME: don't set this as a user: used internally (only for now)
49: 	bool checkpoint_only = false;
50: };
51: 
52: //! The database object. This object holds the catalog and all the
53: //! database-specific meta information.
54: class Connection;
55: class DuckDB {
56: public:
57: 	DuckDB(const char *path = nullptr, DBConfig *config = nullptr);
58: 	DuckDB(const string &path, DBConfig *config = nullptr);
59: 
60: 	~DuckDB();
61: 
62: 	unique_ptr<FileSystem> file_system;
63: 	unique_ptr<StorageManager> storage;
64: 	unique_ptr<Catalog> catalog;
65: 	unique_ptr<TransactionManager> transaction_manager;
66: 	unique_ptr<ConnectionManager> connection_manager;
67: 
68: 	AccessMode access_mode;
69: 	bool use_direct_io;
70: 	bool checkpoint_only;
71: 	idx_t checkpoint_wal_size;
72: 	idx_t maximum_memory;
73: 	string temporary_directory;
74: 
75: private:
76: 	void Configure(DBConfig &config);
77: };
78: 
79: } // namespace duckdb
[end of src/include/duckdb/main/database.hpp]
[start of src/include/duckdb/parser/expression/list.hpp]
1: #include "duckdb/parser/expression/bound_expression.hpp"
2: #include "duckdb/parser/expression/case_expression.hpp"
3: #include "duckdb/parser/expression/cast_expression.hpp"
4: #include "duckdb/parser/expression/columnref_expression.hpp"
5: #include "duckdb/parser/expression/comparison_expression.hpp"
6: #include "duckdb/parser/expression/conjunction_expression.hpp"
7: #include "duckdb/parser/expression/constant_expression.hpp"
8: #include "duckdb/parser/expression/default_expression.hpp"
9: #include "duckdb/parser/expression/function_expression.hpp"
10: #include "duckdb/parser/expression/operator_expression.hpp"
11: #include "duckdb/parser/expression/parameter_expression.hpp"
12: #include "duckdb/parser/expression/star_expression.hpp"
13: #include "duckdb/parser/expression/subquery_expression.hpp"
14: #include "duckdb/parser/expression/table_star_expression.hpp"
15: #include "duckdb/parser/expression/window_expression.hpp"
[end of src/include/duckdb/parser/expression/list.hpp]
[start of src/include/duckdb/parser/tokens.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parser/tokens.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: namespace duckdb {
12: 
13: //===--------------------------------------------------------------------===//
14: // Statements
15: //===--------------------------------------------------------------------===//
16: class SQLStatement;
17: 
18: class AlterTableStatement;
19: class CopyStatement;
20: class CreateStatement;
21: class DeleteStatement;
22: class DropStatement;
23: class InsertStatement;
24: class SelectStatement;
25: class TransactionStatement;
26: class UpdateStatement;
27: class PrepareStatement;
28: class ExecuteStatement;
29: class PragmaStatement;
30: class ExplainStatement;
31: class VacuumStatement;
32: class RelationStatement;
33: 
34: //===--------------------------------------------------------------------===//
35: // Query Node
36: //===--------------------------------------------------------------------===//
37: class QueryNode;
38: class SelectNode;
39: class SetOperationNode;
40: class RecursiveCTENode;
41: 
42: //===--------------------------------------------------------------------===//
43: // Expressions
44: //===--------------------------------------------------------------------===//
45: class ParsedExpression;
46: 
47: class BetweenExpression;
48: class CaseExpression;
49: class CastExpression;
50: class ColumnRefExpression;
51: class ComparisonExpression;
52: class ConjunctionExpression;
53: class ConstantExpression;
54: class DefaultExpression;
55: class FunctionExpression;
56: class OperatorExpression;
57: class ParameterExpression;
58: class StarExpression;
59: class SubqueryExpression;
60: class WindowExpression;
61: 
62: //===--------------------------------------------------------------------===//
63: // Constraints
64: //===--------------------------------------------------------------------===//
65: class Constraint;
66: 
67: class NotNullConstraint;
68: class CheckConstraint;
69: class UniqueConstraint;
70: 
71: //===--------------------------------------------------------------------===//
72: // TableRefs
73: //===--------------------------------------------------------------------===//
74: class TableRef;
75: 
76: class BaseTableRef;
77: class CrossProductRef;
78: class JoinRef;
79: class SubqueryRef;
80: class TableFunctionRef;
81: class EmptyTableRef;
82: class ExpressionListRef;
83: 
84: } // namespace duckdb
[end of src/include/duckdb/parser/tokens.hpp]
[start of src/include/duckdb/parser/transformer.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parser/transformer.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/constants.hpp"
12: #include "duckdb/common/enums/expression_type.hpp"
13: #include "duckdb/common/types.hpp"
14: #include "duckdb/common/unordered_map.hpp"
15: #include "duckdb/parser/tokens.hpp"
16: 
17: #include "pg_definitions.hpp"
18: #include "nodes/parsenodes.hpp"
19: 
20: namespace duckdb {
21: 
22: class ColumnDefinition;
23: struct OrderByNode;
24: 
25: //! The transformer class is responsible for transforming the internal Postgres
26: //! parser representation into the DuckDB representation
27: class Transformer {
28: public:
29: 	Transformer(Transformer *parent = nullptr) : parent(parent) {
30: 	}
31: 
32: 	//! Transforms a Postgres parse tree into a set of SQL Statements
33: 	bool TransformParseTree(PGList *tree, vector<unique_ptr<SQLStatement>> &statements);
34: 	string NodetypeToString(PGNodeTag type);
35: 
36: 	idx_t ParamCount() {
37: 		return parent ? parent->ParamCount() : prepared_statement_parameter_index;
38: 	}
39: 
40: private:
41: 	Transformer *parent;
42: 	//! The current prepared statement parameter index
43: 	idx_t prepared_statement_parameter_index = 0;
44: 	//! Holds window expressions defined by name. We need those when transforming the expressions referring to them.
45: 	unordered_map<string, PGWindowDef *> window_clauses;
46: 
47: 	void SetParamCount(idx_t new_count) {
48: 		if (parent) {
49: 			parent->SetParamCount(new_count);
50: 		} else {
51: 			this->prepared_statement_parameter_index = new_count;
52: 		}
53: 	}
54: 
55: private:
56: 	//! Transforms a Postgres statement into a single SQL statement
57: 	unique_ptr<SQLStatement> TransformStatement(PGNode *stmt);
58: 	//===--------------------------------------------------------------------===//
59: 	// Statement transformation
60: 	//===--------------------------------------------------------------------===//
61: 	//! Transform a Postgres T_PGSelectStmt node into a SelectStatement
62: 	unique_ptr<SelectStatement> TransformSelect(PGNode *node);
63: 	//! Transform a Postgres T_AlterStmt node into a AlterTableStatement
64: 	unique_ptr<AlterTableStatement> TransformAlter(PGNode *node);
65: 	//! Transform a Postgres T_PGRenameStmt node into a RenameStatement
66: 	unique_ptr<AlterTableStatement> TransformRename(PGNode *node);
67: 	//! Transform a Postgres T_PGCreateStmt node into a CreateStatement
68: 	unique_ptr<CreateStatement> TransformCreateTable(PGNode *node);
69: 	//! Transform a Postgres T_PGCreateStmt node into a CreateStatement
70: 	unique_ptr<CreateStatement> TransformCreateTableAs(PGNode *node);
71: 	//! Transform a Postgres node into a CreateStatement
72: 	unique_ptr<CreateStatement> TransformCreateSchema(PGNode *node);
73: 	//! Transform a Postgres T_PGCreateSeqStmt node into a CreateStatement
74: 	unique_ptr<CreateStatement> TransformCreateSequence(PGNode *node);
75: 	//! Transform a Postgres T_PGViewStmt node into a CreateStatement
76: 	unique_ptr<CreateStatement> TransformCreateView(PGNode *node);
77: 	//! Transform a Postgres T_PGIndexStmt node into CreateStatement
78: 	unique_ptr<CreateStatement> TransformCreateIndex(PGNode *node);
79: 	//! Transform a Postgres T_PGDropStmt node into a Drop[Table,Schema]Statement
80: 	unique_ptr<SQLStatement> TransformDrop(PGNode *node);
81: 	//! Transform a Postgres T_PGInsertStmt node into a InsertStatement
82: 	unique_ptr<InsertStatement> TransformInsert(PGNode *node);
83: 	//! Transform a Postgres T_PGCopyStmt node into a CopyStatement
84: 	unique_ptr<CopyStatement> TransformCopy(PGNode *node);
85: 	//! Transform a Postgres T_PGTransactionStmt node into a TransactionStatement
86: 	unique_ptr<TransactionStatement> TransformTransaction(PGNode *node);
87: 	//! Transform a Postgres T_DeleteStatement node into a DeleteStatement
88: 	unique_ptr<DeleteStatement> TransformDelete(PGNode *node);
89: 	//! Transform a Postgres T_PGUpdateStmt node into a UpdateStatement
90: 	unique_ptr<UpdateStatement> TransformUpdate(PGNode *node);
91: 	//! Transform a Postgres T_PGPragmaStmt node into a PragmaStatement
92: 	unique_ptr<PragmaStatement> TransformPragma(PGNode *node);
93: 	unique_ptr<ExplainStatement> TransformExplain(PGNode *node);
94: 	unique_ptr<VacuumStatement> TransformVacuum(PGNode *node);
95: 	unique_ptr<PragmaStatement> TransformShow(PGNode *node);
96: 
97: 	unique_ptr<PrepareStatement> TransformPrepare(PGNode *node);
98: 	unique_ptr<ExecuteStatement> TransformExecute(PGNode *node);
99: 	unique_ptr<DropStatement> TransformDeallocate(PGNode *node);
100: 
101: 	//===--------------------------------------------------------------------===//
102: 	// Query Node Transform
103: 	//===--------------------------------------------------------------------===//
104: 	//! Transform a Postgres T_PGSelectStmt node into a QueryNode
105: 	unique_ptr<QueryNode> TransformSelectNode(PGSelectStmt *node);
106: 
107: 	//===--------------------------------------------------------------------===//
108: 	// Expression Transform
109: 	//===--------------------------------------------------------------------===//
110: 	//! Transform a Postgres boolean expression into an Expression
111: 	unique_ptr<ParsedExpression> TransformBoolExpr(PGBoolExpr *root);
112: 	//! Transform a Postgres case expression into an Expression
113: 	unique_ptr<ParsedExpression> TransformCase(PGCaseExpr *root);
114: 	//! Transform a Postgres type cast into an Expression
115: 	unique_ptr<ParsedExpression> TransformTypeCast(PGTypeCast *root);
116: 	//! Transform a Postgres coalesce into an Expression
117: 	unique_ptr<ParsedExpression> TransformCoalesce(PGAExpr *root);
118: 	//! Transform a Postgres column reference into an Expression
119: 	unique_ptr<ParsedExpression> TransformColumnRef(PGColumnRef *root);
120: 	//! Transform a Postgres constant value into an Expression
121: 	unique_ptr<ParsedExpression> TransformValue(PGValue val);
122: 	//! Transform a Postgres operator into an Expression
123: 	unique_ptr<ParsedExpression> TransformAExpr(PGAExpr *root);
124: 	//! Transform a Postgres abstract expression into an Expression
125: 	unique_ptr<ParsedExpression> TransformExpression(PGNode *node);
126: 	//! Transform a Postgres function call into an Expression
127: 	unique_ptr<ParsedExpression> TransformFuncCall(PGFuncCall *root);
128: 
129: 	//! Transform a Postgres constant value into an Expression
130: 	unique_ptr<ParsedExpression> TransformConstant(PGAConst *c);
131: 
132: 	unique_ptr<ParsedExpression> TransformResTarget(PGResTarget *root);
133: 	unique_ptr<ParsedExpression> TransformNullTest(PGNullTest *root);
134: 	unique_ptr<ParsedExpression> TransformParamRef(PGParamRef *node);
135: 	unique_ptr<ParsedExpression> TransformNamedArg(PGNamedArgExpr *root);
136: 
137: 	unique_ptr<ParsedExpression> TransformSQLValueFunction(PGSQLValueFunction *node);
138: 
139: 	unique_ptr<ParsedExpression> TransformSubquery(PGSubLink *root);
140: 	//===--------------------------------------------------------------------===//
141: 	// Constraints transform
142: 	//===--------------------------------------------------------------------===//
143: 	unique_ptr<Constraint> TransformConstraint(PGListCell *cell);
144: 
145: 	unique_ptr<Constraint> TransformConstraint(PGListCell *cell, ColumnDefinition &column, idx_t index);
146: 
147: 	//===--------------------------------------------------------------------===//
148: 	// Helpers
149: 	//===--------------------------------------------------------------------===//
150: 	string TransformAlias(PGAlias *root);
151: 	void TransformCTE(PGWithClause *de_with_clause, SelectStatement &select);
152: 	unique_ptr<QueryNode> TransformRecursiveCTE(PGCommonTableExpr *node);
153: 	// Operator String to ExpressionType (e.g. + => OPERATOR_ADD)
154: 	ExpressionType OperatorToExpressionType(string &op);
155: 
156: 	unique_ptr<ParsedExpression> TransformUnaryOperator(string op, unique_ptr<ParsedExpression> child);
157: 	unique_ptr<ParsedExpression> TransformBinaryOperator(string op, unique_ptr<ParsedExpression> left,
158: 	                                                     unique_ptr<ParsedExpression> right);
159: 	//===--------------------------------------------------------------------===//
160: 	// TableRef transform
161: 	//===--------------------------------------------------------------------===//
162: 	//! Transform a Postgres node into a TableRef
163: 	unique_ptr<TableRef> TransformTableRefNode(PGNode *node);
164: 	//! Transform a Postgres FROM clause into a TableRef
165: 	unique_ptr<TableRef> TransformFrom(PGList *root);
166: 	//! Transform a Postgres table reference into a TableRef
167: 	unique_ptr<TableRef> TransformRangeVar(PGRangeVar *root);
168: 	//! Transform a Postgres table-producing function into a TableRef
169: 	unique_ptr<TableRef> TransformRangeFunction(PGRangeFunction *root);
170: 	//! Transform a Postgres join node into a TableRef
171: 	unique_ptr<TableRef> TransformJoin(PGJoinExpr *root);
172: 	//! Transform a table producing subquery into a TableRef
173: 	unique_ptr<TableRef> TransformRangeSubselect(PGRangeSubselect *root);
174: 	//! Transform a VALUES list into a set of expressions
175: 	unique_ptr<TableRef> TransformValuesList(PGList *list);
176: 
177: 	//! Transform a Postgres TypeName string into a SQLType
178: 	SQLType TransformTypeName(PGTypeName *name);
179: 
180: 	//! Transform a Postgres GROUP BY expression into a list of Expression
181: 	bool TransformGroupBy(PGList *group, vector<unique_ptr<ParsedExpression>> &result);
182: 	//! Transform a Postgres ORDER BY expression into an OrderByDescription
183: 	bool TransformOrderBy(PGList *order, vector<OrderByNode> &result);
184: 
185: 	//! Transform a Postgres SELECT clause into a list of Expressions
186: 	bool TransformExpressionList(PGList *list, vector<unique_ptr<ParsedExpression>> &result);
187: 
188: 	void TransformWindowDef(PGWindowDef *window_spec, WindowExpression *expr);
189: };
190: 
191: } // namespace duckdb
[end of src/include/duckdb/parser/transformer.hpp]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/parser/column_definition.hpp"
13: #include "duckdb/parser/tokens.hpp"
14: #include "duckdb/planner/bind_context.hpp"
15: #include "duckdb/planner/bound_tokens.hpp"
16: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
17: #include "duckdb/planner/logical_operator.hpp"
18: #include "duckdb/planner/bound_statement.hpp"
19: 
20: namespace duckdb {
21: class BoundResultModifier;
22: class ClientContext;
23: class ExpressionBinder;
24: class LimitModifier;
25: class OrderBinder;
26: class TableCatalogEntry;
27: class ViewCatalogEntry;
28: 
29: struct CreateInfo;
30: struct BoundCreateTableInfo;
31: 
32: struct CorrelatedColumnInfo {
33: 	ColumnBinding binding;
34: 	TypeId type;
35: 	string name;
36: 	idx_t depth;
37: 
38: 	CorrelatedColumnInfo(BoundColumnRefExpression &expr)
39: 	    : binding(expr.binding), type(expr.return_type), name(expr.GetName()), depth(expr.depth) {
40: 	}
41: 
42: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
43: 		return binding == rhs.binding;
44: 	}
45: };
46: 
47: //! Bind the parsed query tree to the actual columns present in the catalog.
48: /*!
49:   The binder is responsible for binding tables and columns to actual physical
50:   tables and columns in the catalog. In the process, it also resolves types of
51:   all expressions.
52: */
53: class Binder {
54: 	friend class ExpressionBinder;
55: 	friend class RecursiveSubqueryPlanner;
56: 
57: public:
58: 	Binder(ClientContext &context, Binder *parent = nullptr);
59: 
60: 	//! The client context
61: 	ClientContext &context;
62: 	//! A mapping of names to common table expressions
63: 	unordered_map<string, QueryNode *> CTE_bindings;
64: 	//! The bind context
65: 	BindContext bind_context;
66: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
67: 	//! vector)
68: 	vector<CorrelatedColumnInfo> correlated_columns;
69: 	//! The set of parameter expressions bound by this binder
70: 	vector<BoundParameterExpression *> *parameters;
71: 	//! Whether or not the bound statement is read-only
72: 	bool read_only;
73: 	//! Whether or not the statement requires a valid transaction to run
74: 	bool requires_valid_transaction = true;
75: 
76: public:
77: 	BoundStatement Bind(SQLStatement &statement);
78: 	BoundStatement Bind(QueryNode &node);
79: 
80: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
81: 	SchemaCatalogEntry *BindSchema(CreateInfo &info);
82: 
83: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
84: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
85: 
86: 	//! Generates an unused index for a table
87: 	idx_t GenerateTableIndex();
88: 
89: 	//! Add a common table expression to the binder
90: 	void AddCTE(const string &name, QueryNode *cte);
91: 	//! Find a common table expression by name; returns nullptr if none exists
92: 	unique_ptr<QueryNode> FindCTE(const string &name);
93: 
94: 	void PushExpressionBinder(ExpressionBinder *binder);
95: 	void PopExpressionBinder();
96: 	void SetActiveBinder(ExpressionBinder *binder);
97: 	ExpressionBinder *GetActiveBinder();
98: 	bool HasActiveBinder();
99: 
100: 	vector<ExpressionBinder *> &GetActiveBinders();
101: 
102: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
103: 	//! Add a correlated column to this binder (if it does not exist)
104: 	void AddCorrelatedColumn(CorrelatedColumnInfo info);
105: 
106: private:
107: 	//! The parent binder (if any)
108: 	Binder *parent;
109: 	//! The vector of active binders
110: 	vector<ExpressionBinder *> active_binders;
111: 	//! The count of bound_tables
112: 	idx_t bound_tables;
113: 	//! Whether or not the binder has any unplanned subqueries that still need to be planned
114: 	bool has_unplanned_subqueries = false;
115: 	//! Whether or not subqueries should be planned already
116: 	bool plan_subquery = true;
117: 
118: private:
119: 	//! Bind the default values of the columns of a table
120: 	void BindDefaultValues(vector<ColumnDefinition> &columns, vector<unique_ptr<Expression>> &bound_defaults);
121: 
122: 	//! Move correlated expressions from the child binder to this binder
123: 	void MoveCorrelatedExpressions(Binder &other);
124: 
125: 	BoundStatement Bind(SelectStatement &stmt);
126: 	BoundStatement Bind(InsertStatement &stmt);
127: 	BoundStatement Bind(CopyStatement &stmt);
128: 	BoundStatement Bind(DeleteStatement &stmt);
129: 	BoundStatement Bind(UpdateStatement &stmt);
130: 	BoundStatement Bind(CreateStatement &stmt);
131: 	BoundStatement Bind(ExecuteStatement &stmt);
132: 	BoundStatement Bind(DropStatement &stmt);
133: 	BoundStatement Bind(AlterTableStatement &stmt);
134: 	BoundStatement Bind(TransactionStatement &stmt);
135: 	BoundStatement Bind(PragmaStatement &stmt);
136: 	BoundStatement Bind(ExplainStatement &stmt);
137: 	BoundStatement Bind(VacuumStatement &stmt);
138: 	BoundStatement Bind(RelationStatement &stmt);
139: 
140: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
141: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
142: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
143: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
144: 
145: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
146: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
147: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
148: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
149: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
150: 
151: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
152: 	unique_ptr<BoundTableRef> Bind(CrossProductRef &ref);
153: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
154: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref);
155: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
156: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
157: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
158: 
159: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
160: 	unique_ptr<LogicalOperator> CreatePlan(BoundCrossProductRef &ref);
161: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
162: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
163: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
164: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
165: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
166: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
167: 
168: 	unique_ptr<LogicalOperator> BindTable(TableCatalogEntry &table, BaseTableRef &ref);
169: 	unique_ptr<LogicalOperator> BindView(ViewCatalogEntry &view, BaseTableRef &ref);
170: 	unique_ptr<LogicalOperator> BindTableOrView(BaseTableRef &ref);
171: 
172: 	BoundStatement BindCopyTo(CopyStatement &stmt);
173: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
174: 
175: 	void BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
176: 	void BindModifierTypes(BoundQueryNode &result, const vector<TypeId> &types, idx_t projection_index);
177: 	unique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);
178: 	unique_ptr<Expression> BindFilter(unique_ptr<ParsedExpression> condition);
179: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
180: 
181: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
182: 
183: 	void PlanSubqueries(unique_ptr<Expression> *expr, unique_ptr<LogicalOperator> *root);
184: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
185: 
186: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<SQLType> &source_types, vector<SQLType> &target_types,
187: 	                                                       unique_ptr<LogicalOperator> op);
188: };
189: 
190: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/include/duckdb/planner/expression/bound_function_expression.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression/bound_function_expression.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/scalar_function.hpp"
12: #include "duckdb/planner/expression.hpp"
13: 
14: namespace duckdb {
15: class ScalarFunctionCatalogEntry;
16: 
17: //! Represents a function call that has been bound to a base function
18: class BoundFunctionExpression : public Expression {
19: public:
20: 	BoundFunctionExpression(TypeId return_type, ScalarFunction bound_function, bool is_operator);
21: 
22: 	// The bound function expression
23: 	ScalarFunction function;
24: 	//! List of arguments to the function
25: 	vector<unique_ptr<Expression>> children;
26: 	//! Argument types
27: 	vector<SQLType> arguments;
28: 	//! The return type
29: 	SQLType sql_return_type;
30: 	//! Whether or not the function is an operator, only used for rendering
31: 	bool is_operator;
32: 	//! The bound function data (if any)
33: 	unique_ptr<FunctionData> bind_info;
34: 
35: public:
36: 	bool IsFoldable() const override;
37: 	string ToString() const override;
38: 
39: 	hash_t Hash() const override;
40: 	bool Equals(const BaseExpression *other) const override;
41: 
42: 	unique_ptr<Expression> Copy() override;
43: };
44: } // namespace duckdb
[end of src/include/duckdb/planner/expression/bound_function_expression.hpp]
[start of src/include/duckdb/planner/expression_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/expression_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/exception.hpp"
12: #include "duckdb/parser/parsed_expression.hpp"
13: #include "duckdb/parser/expression/bound_expression.hpp"
14: #include "duckdb/parser/tokens.hpp"
15: #include "duckdb/planner/expression.hpp"
16: 
17: namespace duckdb {
18: 
19: class Binder;
20: class ClientContext;
21: class SelectNode;
22: 
23: class AggregateFunctionCatalogEntry;
24: class ScalarFunctionCatalogEntry;
25: class SimpleFunction;
26: 
27: struct BindResult {
28: 	BindResult(string error) : error(error) {
29: 	}
30: 	BindResult(unique_ptr<Expression> expr, SQLType sql_type) : expression(move(expr)), sql_type(sql_type) {
31: 	}
32: 
33: 	bool HasError() {
34: 		return !error.empty();
35: 	}
36: 
37: 	unique_ptr<Expression> expression;
38: 	SQLType sql_type;
39: 	string error;
40: };
41: 
42: class ExpressionBinder {
43: public:
44: 	ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder = false);
45: 	virtual ~ExpressionBinder();
46: 
47: 	unique_ptr<Expression> Bind(unique_ptr<ParsedExpression> &expr, SQLType *result_type = nullptr,
48: 	                            bool root_expression = true);
49: 
50: 	//! Returns whether or not any columns have been bound by the expression binder
51: 	bool BoundColumns() {
52: 		return bound_columns;
53: 	}
54: 
55: 	string Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression = false);
56: 
57: 	// Bind table names to ColumnRefExpressions
58: 	static void BindTableNames(Binder &binder, ParsedExpression &expr);
59: 
60: 	bool BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr);
61: 
62: 	//! The target type that should result from the binder. If the result is not of this type, a cast to this type will
63: 	//! be added. Defaults to INVALID.
64: 	SQLType target_type;
65: 
66: protected:
67: 	virtual BindResult BindExpression(ParsedExpression &expr, idx_t depth, bool root_expression = false);
68: 
69: 	BindResult BindExpression(CaseExpression &expr, idx_t depth);
70: 	BindResult BindExpression(CastExpression &expr, idx_t depth);
71: 	BindResult BindExpression(ColumnRefExpression &expr, idx_t depth);
72: 	BindResult BindExpression(ComparisonExpression &expr, idx_t depth);
73: 	BindResult BindExpression(ConjunctionExpression &expr, idx_t depth);
74: 	BindResult BindExpression(ConstantExpression &expr, idx_t depth);
75: 	BindResult BindExpression(FunctionExpression &expr, idx_t depth);
76: 	BindResult BindExpression(OperatorExpression &expr, idx_t depth);
77: 	BindResult BindExpression(ParameterExpression &expr, idx_t depth);
78: 	BindResult BindExpression(StarExpression &expr, idx_t depth);
79: 	BindResult BindExpression(SubqueryExpression &expr, idx_t depth);
80: 
81: 	void BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, string &error);
82: 
83: protected:
84: 	static void ExtractCorrelatedExpressions(Binder &binder, Expression &expr);
85: 
86: 	virtual BindResult BindFunction(FunctionExpression &expr, ScalarFunctionCatalogEntry *function, idx_t depth);
87: 	virtual BindResult BindAggregate(FunctionExpression &expr, AggregateFunctionCatalogEntry *function, idx_t depth);
88: 	virtual BindResult BindUnnest(FunctionExpression &expr, idx_t depth);
89: 
90: 	virtual string UnsupportedAggregateMessage();
91: 	virtual string UnsupportedUnnestMessage();
92: 
93: 	Binder &binder;
94: 	ClientContext &context;
95: 	ExpressionBinder *stored_binder;
96: 	bool bound_columns = false;
97: };
98: 
99: } // namespace duckdb
[end of src/include/duckdb/planner/expression_binder.hpp]
[start of src/main/database.cpp]
1: #include "duckdb/main/database.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/common/file_system.hpp"
5: #include "duckdb/main/connection_manager.hpp"
6: #include "duckdb/storage/storage_manager.hpp"
7: #include "duckdb/transaction/transaction_manager.hpp"
8: 
9: using namespace duckdb;
10: using namespace std;
11: 
12: DBConfig::~DBConfig() {
13: }
14: 
15: DuckDB::DuckDB(const char *path, DBConfig *config) {
16: 	if (config) {
17: 		// user-supplied configuration
18: 		Configure(*config);
19: 	} else {
20: 		// default configuration
21: 		DBConfig config;
22: 		Configure(config);
23: 	}
24: 	if (temporary_directory.empty() && path) {
25: 		// no directory specified: use default temp path
26: 		temporary_directory = string(path) + ".tmp";
27: 
28: 		// special treatment for in-memory mode
29: 		if (strcmp(path, ":memory:") == 0) {
30: 			temporary_directory = ".tmp";
31: 		}
32: 	}
33: 	if (config && !config->use_temporary_directory) {
34: 		// temporary directories explicitly disabled
35: 		temporary_directory = string();
36: 	}
37: 
38: 	storage = make_unique<StorageManager>(*this, path ? string(path) : string(), access_mode == AccessMode::READ_ONLY);
39: 	catalog = make_unique<Catalog>(*storage);
40: 	transaction_manager = make_unique<TransactionManager>(*storage);
41: 	connection_manager = make_unique<ConnectionManager>();
42: 	// initialize the database
43: 	storage->Initialize();
44: }
45: 
46: DuckDB::DuckDB(const string &path, DBConfig *config) : DuckDB(path.c_str(), config) {
47: }
48: 
49: DuckDB::~DuckDB() {
50: }
51: 
52: void DuckDB::Configure(DBConfig &config) {
53: 	if (config.access_mode != AccessMode::UNDEFINED) {
54: 		access_mode = config.access_mode;
55: 	} else {
56: 		access_mode = AccessMode::READ_WRITE;
57: 	}
58: 	if (config.file_system) {
59: 		file_system = move(config.file_system);
60: 	} else {
61: 		file_system = make_unique<FileSystem>();
62: 	}
63: 	checkpoint_only = config.checkpoint_only;
64: 	checkpoint_wal_size = config.checkpoint_wal_size;
65: 	use_direct_io = config.use_direct_io;
66: 	maximum_memory = config.maximum_memory;
67: 	temporary_directory = config.temporary_directory;
68: }
[end of src/main/database.cpp]
[start of src/parser/expression/CMakeLists.txt]
1: add_library_unity(duckdb_expression
2:                   OBJECT
3:                   case_expression.cpp
4:                   cast_expression.cpp
5:                   conjunction_expression.cpp
6:                   columnref_expression.cpp
7:                   comparison_expression.cpp
8:                   constant_expression.cpp
9:                   default_expression.cpp
10:                   function_expression.cpp
11:                   operator_expression.cpp
12:                   parameter_expression.cpp
13:                   star_expression.cpp
14:                   subquery_expression.cpp
15:                   table_star_expression.cpp
16:                   window_expression.cpp)
17: set(ALL_OBJECT_FILES
18:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_expression>
19:     PARENT_SCOPE)
[end of src/parser/expression/CMakeLists.txt]
[start of src/parser/parsed_expression.cpp]
1: #include "duckdb/parser/parsed_expression.hpp"
2: 
3: #include "duckdb/common/serializer.hpp"
4: #include "duckdb/common/types/hash.hpp"
5: #include "duckdb/parser/expression/list.hpp"
6: #include "duckdb/parser/parsed_expression_iterator.hpp"
7: 
8: using namespace duckdb;
9: using namespace std;
10: 
11: bool ParsedExpression::IsAggregate() const {
12: 	bool is_aggregate = false;
13: 	ParsedExpressionIterator::EnumerateChildren(
14: 	    *this, [&](const ParsedExpression &child) { is_aggregate |= child.IsAggregate(); });
15: 	return is_aggregate;
16: }
17: 
18: bool ParsedExpression::IsWindow() const {
19: 	bool is_window = false;
20: 	ParsedExpressionIterator::EnumerateChildren(*this,
21: 	                                            [&](const ParsedExpression &child) { is_window |= child.IsWindow(); });
22: 	return is_window;
23: }
24: 
25: bool ParsedExpression::IsScalar() const {
26: 	bool is_scalar = true;
27: 	ParsedExpressionIterator::EnumerateChildren(*this, [&](const ParsedExpression &child) {
28: 		if (!child.IsScalar()) {
29: 			is_scalar = false;
30: 		}
31: 	});
32: 	return is_scalar;
33: }
34: 
35: bool ParsedExpression::HasParameter() const {
36: 	bool has_parameter = false;
37: 	ParsedExpressionIterator::EnumerateChildren(
38: 	    *this, [&](const ParsedExpression &child) { has_parameter |= child.HasParameter(); });
39: 	return has_parameter;
40: }
41: 
42: bool ParsedExpression::HasSubquery() const {
43: 	bool has_subquery = false;
44: 	ParsedExpressionIterator::EnumerateChildren(
45: 	    *this, [&](const ParsedExpression &child) { has_subquery |= child.HasSubquery(); });
46: 	return has_subquery;
47: }
48: 
49: bool ParsedExpression::Equals(const BaseExpression *other) const {
50: 	if (other->expression_class == ExpressionClass::BOUND_EXPRESSION) {
51: 		auto bound_expr = (BoundExpression *)other;
52: 		other = bound_expr->parsed_expr.get();
53: 	}
54: 	if (!BaseExpression::Equals(other)) {
55: 		return false;
56: 	}
57: 	switch (expression_class) {
58: 	case ExpressionClass::CASE:
59: 		return CaseExpression::Equals((CaseExpression *)this, (CaseExpression *)other);
60: 	case ExpressionClass::CAST:
61: 		return CastExpression::Equals((CastExpression *)this, (CastExpression *)other);
62: 	case ExpressionClass::COLUMN_REF:
63: 		return ColumnRefExpression::Equals((ColumnRefExpression *)this, (ColumnRefExpression *)other);
64: 	case ExpressionClass::COMPARISON:
65: 		return ComparisonExpression::Equals((ComparisonExpression *)this, (ComparisonExpression *)other);
66: 	case ExpressionClass::CONJUNCTION:
67: 		return ConjunctionExpression::Equals((ConjunctionExpression *)this, (ConjunctionExpression *)other);
68: 	case ExpressionClass::CONSTANT:
69: 		return ConstantExpression::Equals((ConstantExpression *)this, (ConstantExpression *)other);
70: 	case ExpressionClass::DEFAULT:
71: 		return true;
72: 	case ExpressionClass::FUNCTION:
73: 		return FunctionExpression::Equals((FunctionExpression *)this, (FunctionExpression *)other);
74: 	case ExpressionClass::OPERATOR:
75: 		return OperatorExpression::Equals((OperatorExpression *)this, (OperatorExpression *)other);
76: 	case ExpressionClass::PARAMETER:
77: 		return true;
78: 	case ExpressionClass::STAR:
79: 		return true;
80: 	case ExpressionClass::TABLE_STAR:
81: 		return TableStarExpression::Equals((TableStarExpression *)this, (TableStarExpression *)other);
82: 	case ExpressionClass::SUBQUERY:
83: 		return SubqueryExpression::Equals((SubqueryExpression *)this, (SubqueryExpression *)other);
84: 	case ExpressionClass::WINDOW:
85: 		return WindowExpression::Equals((WindowExpression *)this, (WindowExpression *)other);
86: 	default:
87: 		throw SerializationException("Unsupported type for expression deserialization!");
88: 	}
89: }
90: 
91: hash_t ParsedExpression::Hash() const {
92: 	hash_t hash = duckdb::Hash<uint32_t>((uint32_t)type);
93: 	ParsedExpressionIterator::EnumerateChildren(
94: 	    *this, [&](const ParsedExpression &child) { hash = CombineHash(child.Hash(), hash); });
95: 	return hash;
96: }
97: 
98: void ParsedExpression::Serialize(Serializer &serializer) {
99: 	serializer.Write<ExpressionClass>(GetExpressionClass());
100: 	serializer.Write<ExpressionType>(type);
101: 	serializer.WriteString(alias);
102: }
103: 
104: unique_ptr<ParsedExpression> ParsedExpression::Deserialize(Deserializer &source) {
105: 	auto expression_class = source.Read<ExpressionClass>();
106: 	auto type = source.Read<ExpressionType>();
107: 	auto alias = source.Read<string>();
108: 	unique_ptr<ParsedExpression> result;
109: 	switch (expression_class) {
110: 	case ExpressionClass::CASE:
111: 		result = CaseExpression::Deserialize(type, source);
112: 		break;
113: 	case ExpressionClass::CAST:
114: 		result = CastExpression::Deserialize(type, source);
115: 		break;
116: 	case ExpressionClass::COLUMN_REF:
117: 		result = ColumnRefExpression::Deserialize(type, source);
118: 		break;
119: 	case ExpressionClass::COMPARISON:
120: 		result = ComparisonExpression::Deserialize(type, source);
121: 		break;
122: 	case ExpressionClass::CONJUNCTION:
123: 		result = ConjunctionExpression::Deserialize(type, source);
124: 		break;
125: 	case ExpressionClass::CONSTANT:
126: 		result = ConstantExpression::Deserialize(type, source);
127: 		break;
128: 	case ExpressionClass::DEFAULT:
129: 		result = DefaultExpression::Deserialize(type, source);
130: 		break;
131: 	case ExpressionClass::FUNCTION:
132: 		result = FunctionExpression::Deserialize(type, source);
133: 		break;
134: 	case ExpressionClass::OPERATOR:
135: 		result = OperatorExpression::Deserialize(type, source);
136: 		break;
137: 	case ExpressionClass::PARAMETER:
138: 		result = ParameterExpression::Deserialize(type, source);
139: 		break;
140: 	case ExpressionClass::STAR:
141: 		result = StarExpression::Deserialize(type, source);
142: 		break;
143: 	case ExpressionClass::TABLE_STAR:
144: 		result = TableStarExpression::Deserialize(type, source);
145: 		break;
146: 	case ExpressionClass::SUBQUERY:
147: 		result = SubqueryExpression::Deserialize(type, source);
148: 		break;
149: 	case ExpressionClass::WINDOW:
150: 		result = WindowExpression::Deserialize(type, source);
151: 		break;
152: 	default:
153: 		throw SerializationException("Unsupported type for expression deserialization!");
154: 	}
155: 	result->alias = alias;
156: 	return result;
157: }
[end of src/parser/parsed_expression.cpp]
[start of src/parser/parsed_expression_iterator.cpp]
1: #include "duckdb/parser/parsed_expression_iterator.hpp"
2: 
3: #include "duckdb/parser/expression/list.hpp"
4: 
5: using namespace duckdb;
6: using namespace std;
7: 
8: void ParsedExpressionIterator::EnumerateChildren(const ParsedExpression &expr,
9:                                                  function<void(const ParsedExpression &child)> callback) {
10: 	switch (expr.expression_class) {
11: 	case ExpressionClass::CASE: {
12: 		auto &case_expr = (const CaseExpression &)expr;
13: 		callback(*case_expr.check);
14: 		callback(*case_expr.result_if_true);
15: 		callback(*case_expr.result_if_false);
16: 		break;
17: 	}
18: 	case ExpressionClass::CAST: {
19: 		auto &cast_expr = (const CastExpression &)expr;
20: 		callback(*cast_expr.child);
21: 		break;
22: 	}
23: 	case ExpressionClass::COMPARISON: {
24: 		auto &comp_expr = (const ComparisonExpression &)expr;
25: 		callback(*comp_expr.left);
26: 		callback(*comp_expr.right);
27: 		break;
28: 	}
29: 	case ExpressionClass::CONJUNCTION: {
30: 		auto &conj_expr = (const ConjunctionExpression &)expr;
31: 		for (auto &child : conj_expr.children) {
32: 			callback(*child);
33: 		}
34: 		break;
35: 	}
36: 	case ExpressionClass::FUNCTION: {
37: 		auto &func_expr = (const FunctionExpression &)expr;
38: 		for (auto &child : func_expr.children) {
39: 			callback(*child);
40: 		}
41: 		break;
42: 	}
43: 	case ExpressionClass::OPERATOR: {
44: 		auto &op_expr = (const OperatorExpression &)expr;
45: 		for (auto &child : op_expr.children) {
46: 			callback(*child);
47: 		}
48: 		break;
49: 	}
50: 	case ExpressionClass::SUBQUERY: {
51: 		auto &subquery_expr = (const SubqueryExpression &)expr;
52: 		if (subquery_expr.child) {
53: 			callback(*subquery_expr.child);
54: 		}
55: 		break;
56: 	}
57: 	case ExpressionClass::WINDOW: {
58: 		auto &window_expr = (const WindowExpression &)expr;
59: 		for (auto &partition : window_expr.partitions) {
60: 			callback(*partition);
61: 		}
62: 		for (auto &order : window_expr.orders) {
63: 			callback(*order.expression);
64: 		}
65: 		for (auto &child : window_expr.children) {
66: 			callback(*child);
67: 		}
68: 		if (window_expr.offset_expr) {
69: 			callback(*window_expr.offset_expr);
70: 		}
71: 		if (window_expr.default_expr) {
72: 			callback(*window_expr.default_expr);
73: 		}
74: 		break;
75: 	}
76: 	case ExpressionClass::BOUND_EXPRESSION:
77: 	case ExpressionClass::COLUMN_REF:
78: 	case ExpressionClass::CONSTANT:
79: 	case ExpressionClass::DEFAULT:
80: 	case ExpressionClass::STAR:
81: 	case ExpressionClass::TABLE_STAR:
82: 	case ExpressionClass::PARAMETER:
83: 		// these node types have no children
84: 		break;
85: 	default:
86: 		// called on non ParsedExpression type!
87: 		throw NotImplementedException("Unimplemented expression class");
88: 	}
89: }
[end of src/parser/parsed_expression_iterator.cpp]
[start of src/parser/transform/expression/transform_expression.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/parser/expression/default_expression.hpp"
3: #include "duckdb/parser/transformer.hpp"
4: 
5: using namespace duckdb;
6: using namespace std;
7: 
8: unique_ptr<ParsedExpression> Transformer::TransformResTarget(PGResTarget *root) {
9: 	if (!root) {
10: 		return nullptr;
11: 	}
12: 	auto expr = TransformExpression(root->val);
13: 	if (!expr) {
14: 		return nullptr;
15: 	}
16: 	if (root->name) {
17: 		expr->alias = string(root->name);
18: 	}
19: 	return expr;
20: }
21: 
22: unique_ptr<ParsedExpression> Transformer::TransformNamedArg(PGNamedArgExpr *root) {
23: 	if (!root) {
24: 		return nullptr;
25: 	}
26: 	auto expr = TransformExpression((PGNode *)root->arg);
27: 	if (root->name) {
28: 		expr->alias = string(root->name);
29: 	}
30: 	return expr;
31: }
32: 
33: unique_ptr<ParsedExpression> Transformer::TransformExpression(PGNode *node) {
34: 	if (!node) {
35: 		return nullptr;
36: 	}
37: 
38: 	switch (node->type) {
39: 	case T_PGColumnRef:
40: 		return TransformColumnRef(reinterpret_cast<PGColumnRef *>(node));
41: 	case T_PGAConst:
42: 		return TransformConstant(reinterpret_cast<PGAConst *>(node));
43: 	case T_PGAExpr:
44: 		return TransformAExpr(reinterpret_cast<PGAExpr *>(node));
45: 	case T_PGFuncCall:
46: 		return TransformFuncCall(reinterpret_cast<PGFuncCall *>(node));
47: 	case T_PGBoolExpr:
48: 		return TransformBoolExpr(reinterpret_cast<PGBoolExpr *>(node));
49: 	case T_PGTypeCast:
50: 		return TransformTypeCast(reinterpret_cast<PGTypeCast *>(node));
51: 	case T_PGCaseExpr:
52: 		return TransformCase(reinterpret_cast<PGCaseExpr *>(node));
53: 	case T_PGSubLink:
54: 		return TransformSubquery(reinterpret_cast<PGSubLink *>(node));
55: 	case T_PGCoalesceExpr:
56: 		return TransformCoalesce(reinterpret_cast<PGAExpr *>(node));
57: 	case T_PGNullTest:
58: 		return TransformNullTest(reinterpret_cast<PGNullTest *>(node));
59: 	case T_PGResTarget:
60: 		return TransformResTarget(reinterpret_cast<PGResTarget *>(node));
61: 	case T_PGParamRef:
62: 		return TransformParamRef(reinterpret_cast<PGParamRef *>(node));
63: 	case T_PGNamedArgExpr:
64: 		return TransformNamedArg(reinterpret_cast<PGNamedArgExpr *>(node));
65: 	case T_PGSQLValueFunction:
66: 		return TransformSQLValueFunction(reinterpret_cast<PGSQLValueFunction *>(node));
67: 	case T_PGSetToDefault:
68: 		return make_unique<DefaultExpression>();
69: 
70: 	default:
71: 		throw NotImplementedException("Expr of type %d not implemented\n", (int)node->type);
72: 	}
73: }
74: 
75: bool Transformer::TransformExpressionList(PGList *list, vector<unique_ptr<ParsedExpression>> &result) {
76: 	if (!list) {
77: 		return false;
78: 	}
79: 	for (auto node = list->head; node != nullptr; node = node->next) {
80: 		auto target = reinterpret_cast<PGNode *>(node->data.ptr_value);
81: 		if (!target) {
82: 			return false;
83: 		}
84: 		auto expr = TransformExpression(target);
85: 		if (!expr) {
86: 			return false;
87: 		}
88: 		result.push_back(move(expr));
89: 	}
90: 	return true;
91: }
[end of src/parser/transform/expression/transform_expression.cpp]
[start of src/parser/transform/expression/transform_operator.cpp]
1: #include "duckdb/parser/expression/case_expression.hpp"
2: #include "duckdb/parser/expression/comparison_expression.hpp"
3: #include "duckdb/parser/expression/conjunction_expression.hpp"
4: #include "duckdb/parser/expression/constant_expression.hpp"
5: #include "duckdb/parser/expression/function_expression.hpp"
6: #include "duckdb/parser/expression/operator_expression.hpp"
7: #include "duckdb/parser/transformer.hpp"
8: 
9: using namespace duckdb;
10: using namespace std;
11: 
12: ExpressionType Transformer::OperatorToExpressionType(string &op) {
13: 	if (op == "=" || op == "==") {
14: 		return ExpressionType::COMPARE_EQUAL;
15: 	} else if (op == "!=" || op == "<>") {
16: 		return ExpressionType::COMPARE_NOTEQUAL;
17: 	} else if (op == "<") {
18: 		return ExpressionType::COMPARE_LESSTHAN;
19: 	} else if (op == ">") {
20: 		return ExpressionType::COMPARE_GREATERTHAN;
21: 	} else if (op == "<=") {
22: 		return ExpressionType::COMPARE_LESSTHANOREQUALTO;
23: 	} else if (op == ">=") {
24: 		return ExpressionType::COMPARE_GREATERTHANOREQUALTO;
25: 	}
26: 	return ExpressionType::INVALID;
27: }
28: 
29: unique_ptr<ParsedExpression> Transformer::TransformUnaryOperator(string op, unique_ptr<ParsedExpression> child) {
30: 	const auto schema = DEFAULT_SCHEMA;
31: 
32: 	vector<unique_ptr<ParsedExpression>> children;
33: 	children.push_back(move(child));
34: 
35: 	// built-in operator function
36: 	auto result = make_unique<FunctionExpression>(schema, op, children);
37: 	result->is_operator = true;
38: 	return move(result);
39: }
40: 
41: unique_ptr<ParsedExpression> Transformer::TransformBinaryOperator(string op, unique_ptr<ParsedExpression> left,
42:                                                                   unique_ptr<ParsedExpression> right) {
43: 	const auto schema = DEFAULT_SCHEMA;
44: 
45: 	vector<unique_ptr<ParsedExpression>> children;
46: 	children.push_back(move(left));
47: 	children.push_back(move(right));
48: 
49: 	if (op == "~" || op == "!~") {
50: 		// rewrite 'asdf' SIMILAR TO '.*sd.*' into regexp_full_match('asdf', '.*sd.*')
51: 		bool invert_similar = op == "!~";
52: 
53: 		auto result = make_unique<FunctionExpression>(schema, "regexp_full_match", children);
54: 		if (invert_similar) {
55: 			return make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(result));
56: 		} else {
57: 			return move(result);
58: 		}
59: 	} else {
60: 		auto target_type = OperatorToExpressionType(op);
61: 		if (target_type != ExpressionType::INVALID) {
62: 			// built-in comparison operator
63: 			return make_unique<ComparisonExpression>(target_type, move(children[0]), move(children[1]));
64: 		} else {
65: 			// built-in operator function
66: 			auto result = make_unique<FunctionExpression>(schema, op, children);
67: 			result->is_operator = true;
68: 			return move(result);
69: 		}
70: 	}
71: }
72: 
73: unique_ptr<ParsedExpression> Transformer::TransformAExpr(PGAExpr *root) {
74: 	if (!root) {
75: 		return nullptr;
76: 	}
77: 	auto name = string((reinterpret_cast<PGValue *>(root->name->head->data.ptr_value))->val.str);
78: 
79: 	switch (root->kind) {
80: 	case PG_AEXPR_DISTINCT:
81: 		break;
82: 	case PG_AEXPR_IN: {
83: 		auto left_expr = TransformExpression(root->lexpr);
84: 		ExpressionType operator_type;
85: 		// this looks very odd, but seems to be the way to find out its NOT IN
86: 		if (name == "<>") {
87: 			// NOT IN
88: 			operator_type = ExpressionType::COMPARE_NOT_IN;
89: 		} else {
90: 			// IN
91: 			operator_type = ExpressionType::COMPARE_IN;
92: 		}
93: 		auto result = make_unique<OperatorExpression>(operator_type, move(left_expr));
94: 		TransformExpressionList((PGList *)root->rexpr, result->children);
95: 		return move(result);
96: 	} break;
97: 	// rewrite NULLIF(a, b) into CASE WHEN a=b THEN NULL ELSE a END
98: 	case PG_AEXPR_NULLIF: {
99: 		auto case_expr = make_unique<CaseExpression>();
100: 		auto value = TransformExpression(root->lexpr);
101: 		// the check (A = B)
102: 		case_expr->check = make_unique<ComparisonExpression>(ExpressionType::COMPARE_EQUAL, value->Copy(),
103: 		                                                     TransformExpression(root->rexpr));
104: 		// if A = B, then constant NULL
105: 		case_expr->result_if_true = make_unique<ConstantExpression>(SQLType::SQLNULL, Value());
106: 		// else A
107: 		case_expr->result_if_false = move(value);
108: 		return move(case_expr);
109: 	} break;
110: 	// rewrite (NOT) X BETWEEN A AND B into (NOT) AND(GREATERTHANOREQUALTO(X,
111: 	// A), LESSTHANOREQUALTO(X, B))
112: 	case PG_AEXPR_BETWEEN:
113: 	case PG_AEXPR_NOT_BETWEEN: {
114: 		auto between_args = reinterpret_cast<PGList *>(root->rexpr);
115: 
116: 		if (between_args->length != 2 || !between_args->head->data.ptr_value || !between_args->tail->data.ptr_value) {
117: 			throw Exception("(NOT) BETWEEN needs two args");
118: 		}
119: 
120: 		auto between_left = TransformExpression(reinterpret_cast<PGNode *>(between_args->head->data.ptr_value));
121: 		auto between_right = TransformExpression(reinterpret_cast<PGNode *>(between_args->tail->data.ptr_value));
122: 
123: 		auto compare_left = make_unique<ComparisonExpression>(ExpressionType::COMPARE_GREATERTHANOREQUALTO,
124: 		                                                      TransformExpression(root->lexpr), move(between_left));
125: 		auto compare_right = make_unique<ComparisonExpression>(ExpressionType::COMPARE_LESSTHANOREQUALTO,
126: 		                                                       TransformExpression(root->lexpr), move(between_right));
127: 		auto compare_between = make_unique<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, move(compare_left),
128: 		                                                          move(compare_right));
129: 		if (root->kind == PG_AEXPR_BETWEEN) {
130: 			return move(compare_between);
131: 		} else {
132: 			return make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(compare_between));
133: 		}
134: 	} break;
135: 	// rewrite SIMILAR TO into regexp_full_match('asdf', '.*sd.*')
136: 	case PG_AEXPR_SIMILAR: {
137: 		auto left_expr = TransformExpression(root->lexpr);
138: 		auto right_expr = TransformExpression(root->rexpr);
139: 
140: 		vector<unique_ptr<ParsedExpression>> children;
141: 		children.push_back(move(left_expr));
142: 
143: 		auto &similar_func = reinterpret_cast<FunctionExpression &>(*right_expr);
144: 		assert(similar_func.function_name == "similar_escape");
145: 		assert(similar_func.children.size() == 2);
146: 		if (similar_func.children[1]->type != ExpressionType::VALUE_CONSTANT) {
147: 			throw NotImplementedException("Custom escape in SIMILAR TO");
148: 		}
149: 		auto &constant = (ConstantExpression &)*similar_func.children[1];
150: 		if (!constant.value.is_null) {
151: 			throw NotImplementedException("Custom escape in SIMILAR TO");
152: 		}
153: 		// take the child of the similar_func
154: 		children.push_back(move(similar_func.children[0]));
155: 
156: 		// this looks very odd, but seems to be the way to find out its NOT IN
157: 		bool invert_similar = false;
158: 		if (name == "!~") {
159: 			// NOT SIMILAR TO
160: 			invert_similar = true;
161: 		}
162: 		const auto schema = DEFAULT_SCHEMA;
163: 		const auto regex_function = "regexp_full_match";
164: 		auto result = make_unique<FunctionExpression>(schema, regex_function, children);
165: 
166: 		if (invert_similar) {
167: 			return make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(result));
168: 		} else {
169: 			return move(result);
170: 		}
171: 	} break;
172: 	default:
173: 		break;
174: 	}
175: 
176: 	auto left_expr = TransformExpression(root->lexpr);
177: 	auto right_expr = TransformExpression(root->rexpr);
178: 
179: 	if (!left_expr) {
180: 		// prefix operator
181: 		return TransformUnaryOperator(name, move(right_expr));
182: 	} else if (!right_expr) {
183: 		throw NotImplementedException("Postfix operators not implemented!");
184: 	} else {
185: 		return TransformBinaryOperator(name, move(left_expr), move(right_expr));
186: 	}
187: }
[end of src/parser/transform/expression/transform_operator.cpp]
[start of src/parser/transform/statement/transform_create_table.cpp]
1: #include "duckdb/parser/statement/create_statement.hpp"
2: #include "duckdb/parser/parsed_data/create_table_info.hpp"
3: #include "duckdb/parser/transformer.hpp"
4: #include "duckdb/parser/constraint.hpp"
5: 
6: using namespace duckdb;
7: using namespace std;
8: 
9: unique_ptr<CreateStatement> Transformer::TransformCreateTable(PGNode *node) {
10: 	auto stmt = reinterpret_cast<PGCreateStmt *>(node);
11: 	assert(stmt);
12: 	auto result = make_unique<CreateStatement>();
13: 	auto info = make_unique<CreateTableInfo>();
14: 
15: 	if (stmt->inhRelations) {
16: 		throw NotImplementedException("inherited relations not implemented");
17: 	}
18: 	assert(stmt->relation);
19: 
20: 	info->schema = INVALID_SCHEMA;
21: 	if (stmt->relation->schemaname) {
22: 		info->schema = stmt->relation->schemaname;
23: 	}
24: 	info->table = stmt->relation->relname;
25: 	info->on_conflict = stmt->if_not_exists ? OnCreateConflict::IGNORE : OnCreateConflict::ERROR;
26: 	info->temporary = stmt->relation->relpersistence == PGPostgresRelPersistence::PG_RELPERSISTENCE_TEMP;
27: 
28: 	if (info->temporary && stmt->oncommit != PGOnCommitAction::PG_ONCOMMIT_PRESERVE_ROWS &&
29: 	    stmt->oncommit != PGOnCommitAction::PG_ONCOMMIT_NOOP) {
30: 		throw NotImplementedException("Only ON COMMIT PRESERVE ROWS is supported");
31: 	}
32: 	if (!stmt->tableElts) {
33: 		throw ParserException("Table must have at least one column!");
34: 	}
35: 
36: 	for (auto c = stmt->tableElts->head; c != NULL; c = lnext(c)) {
37: 		auto node = reinterpret_cast<PGNode *>(c->data.ptr_value);
38: 		switch (node->type) {
39: 		case T_PGColumnDef: {
40: 			auto cdef = (PGColumnDef *)c->data.ptr_value;
41: 			SQLType target_type = TransformTypeName(cdef->typeName);
42: 			auto centry = ColumnDefinition(cdef->colname, target_type);
43: 
44: 			if (cdef->constraints) {
45: 				for (auto constr = cdef->constraints->head; constr != nullptr; constr = constr->next) {
46: 					auto constraint = TransformConstraint(constr, centry, info->columns.size());
47: 					if (constraint) {
48: 						info->constraints.push_back(move(constraint));
49: 					}
50: 				}
51: 			}
52: 			info->columns.push_back(move(centry));
53: 			break;
54: 		}
55: 		case T_PGConstraint: {
56: 			info->constraints.push_back(TransformConstraint(c));
57: 			break;
58: 		}
59: 		default:
60: 			throw NotImplementedException("ColumnDef type not handled yet");
61: 		}
62: 	}
63: 	result->info = move(info);
64: 	return result;
65: }
[end of src/parser/transform/statement/transform_create_table.cpp]
[start of src/planner/binder/expression/CMakeLists.txt]
1: add_library_unity(duckdb_bind_expression
2:                   OBJECT
3:                   bind_aggregate_expression.cpp
4:                   bind_case_expression.cpp
5:                   bind_cast_expression.cpp
6:                   bind_columnref_expression.cpp
7:                   bind_comparison_expression.cpp
8:                   bind_conjunction_expression.cpp
9:                   bind_constant_expression.cpp
10:                   bind_function_expression.cpp
11:                   bind_operator_expression.cpp
12:                   bind_parameter_expression.cpp
13:                   bind_subquery_expression.cpp
14:                   bind_unnest_expression.cpp
15:                   bind_window_expression.cpp)
16: set(ALL_OBJECT_FILES ${ALL_OBJECT_FILES}
17:                      $<TARGET_OBJECTS:duckdb_bind_expression> PARENT_SCOPE)
[end of src/planner/binder/expression/CMakeLists.txt]
[start of src/planner/binder/expression/bind_comparison_expression.cpp]
1: #include "duckdb/parser/expression/comparison_expression.hpp"
2: #include "duckdb/planner/expression/bound_cast_expression.hpp"
3: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
4: #include "duckdb/planner/expression_binder.hpp"
5: 
6: using namespace duckdb;
7: using namespace std;
8: 
9: BindResult ExpressionBinder::BindExpression(ComparisonExpression &expr, idx_t depth) {
10: 	// first try to bind the children of the case expression
11: 	string error;
12: 	BindChild(expr.left, depth, error);
13: 	BindChild(expr.right, depth, error);
14: 	if (!error.empty()) {
15: 		return BindResult(error);
16: 	}
17: 	// the children have been successfully resolved
18: 	auto &left = (BoundExpression &)*expr.left;
19: 	auto &right = (BoundExpression &)*expr.right;
20: 	// cast the input types to the same type
21: 	// now obtain the result type of the input types
22: 	auto input_type = MaxSQLType(left.sql_type, right.sql_type);
23: 	if (input_type.id == SQLTypeId::VARCHAR) {
24: 		// for comparison with strings, we prefer to bind to the numeric types
25: 		if (left.sql_type.IsNumeric()) {
26: 			input_type = left.sql_type;
27: 		}
28: 		if (right.sql_type.IsNumeric()) {
29: 			input_type = right.sql_type;
30: 		}
31: 	}
32: 	if (input_type.id == SQLTypeId::UNKNOWN) {
33: 		throw BinderException("Could not determine type of parameters: try adding explicit type casts");
34: 	}
35: 	// add casts (if necessary)
36: 	left.expr = BoundCastExpression::AddCastToType(move(left.expr), left.sql_type, input_type);
37: 	right.expr = BoundCastExpression::AddCastToType(move(right.expr), right.sql_type, input_type);
38: 	// now create the bound comparison expression
39: 	return BindResult(make_unique<BoundComparisonExpression>(expr.type, move(left.expr), move(right.expr)),
40: 	                  SQLType(SQLTypeId::BOOLEAN));
41: }
[end of src/planner/binder/expression/bind_comparison_expression.cpp]
[start of src/planner/binder/query_node/bind_select_node.cpp]
1: #include "duckdb/parser/expression/columnref_expression.hpp"
2: #include "duckdb/parser/expression/constant_expression.hpp"
3: #include "duckdb/parser/query_node/select_node.hpp"
4: #include "duckdb/parser/tableref/joinref.hpp"
5: #include "duckdb/planner/binder.hpp"
6: #include "duckdb/execution/expression_executor.hpp"
7: #include "duckdb/planner/expression_binder/constant_binder.hpp"
8: #include "duckdb/planner/expression_binder/group_binder.hpp"
9: #include "duckdb/planner/expression_binder/having_binder.hpp"
10: #include "duckdb/planner/expression_binder/order_binder.hpp"
11: #include "duckdb/planner/expression_binder/select_binder.hpp"
12: #include "duckdb/planner/expression_binder/where_binder.hpp"
13: #include "duckdb/planner/query_node/bound_select_node.hpp"
14: #include "duckdb/parser/expression/table_star_expression.hpp"
15: 
16: using namespace std;
17: 
18: namespace duckdb {
19: 
20: static int64_t BindConstant(Binder &binder, ClientContext &context, string clause, unique_ptr<ParsedExpression> &expr) {
21: 	ConstantBinder constant_binder(binder, context, clause);
22: 	auto bound_expr = constant_binder.Bind(expr);
23: 	Value value = ExpressionExecutor::EvaluateScalar(*bound_expr);
24: 	if (!TypeIsNumeric(value.type)) {
25: 		throw BinderException("LIMIT clause can only contain numeric constants!");
26: 	}
27: 	int64_t limit_value = value.GetValue<int64_t>();
28: 	if (limit_value < 0) {
29: 		throw BinderException("LIMIT must not be negative");
30: 	}
31: 	return limit_value;
32: }
33: 
34: unique_ptr<Expression> Binder::BindFilter(unique_ptr<ParsedExpression> condition) {
35: 	WhereBinder where_binder(*this, context);
36: 	return where_binder.Bind(condition);
37: }
38: 
39: unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {
40: 	// we treat the Distinct list as a order by
41: 	auto bound_expr = order_binder.Bind(move(expr));
42: 	if (!bound_expr) {
43: 		// DISTINCT ON non-integer constant
44: 		// remove the expression from the DISTINCT ON list
45: 		return nullptr;
46: 	}
47: 	assert(bound_expr->type == ExpressionType::BOUND_COLUMN_REF);
48: 	return bound_expr;
49: }
50: 
51: unique_ptr<BoundResultModifier> Binder::BindLimit(LimitModifier &limit_mod) {
52: 	auto result = make_unique<BoundLimitModifier>();
53: 	if (limit_mod.limit) {
54: 		result->limit = BindConstant(*this, context, "LIMIT clause", limit_mod.limit);
55: 		result->offset = 0;
56: 	}
57: 	if (limit_mod.offset) {
58: 		result->offset = BindConstant(*this, context, "OFFSET clause", limit_mod.offset);
59: 		if (!limit_mod.limit) {
60: 			result->limit = std::numeric_limits<int64_t>::max();
61: 		}
62: 	}
63: 	return move(result);
64: }
65: 
66: void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result) {
67: 	for (auto &mod : statement.modifiers) {
68: 		unique_ptr<BoundResultModifier> bound_modifier;
69: 		switch (mod->type) {
70: 		case ResultModifierType::DISTINCT_MODIFIER: {
71: 			auto &distinct = (DistinctModifier &)*mod;
72: 			auto bound_distinct = make_unique<BoundDistinctModifier>();
73: 			for (idx_t i = 0; i < distinct.distinct_on_targets.size(); i++) {
74: 				auto expr = BindOrderExpression(order_binder, move(distinct.distinct_on_targets[i]));
75: 				if (!expr) {
76: 					continue;
77: 				}
78: 				bound_distinct->target_distincts.push_back(move(expr));
79: 			}
80: 			bound_modifier = move(bound_distinct);
81: 			break;
82: 		}
83: 		case ResultModifierType::ORDER_MODIFIER: {
84: 			auto &order = (OrderModifier &)*mod;
85: 			auto bound_order = make_unique<BoundOrderModifier>();
86: 			for (idx_t i = 0; i < order.orders.size(); i++) {
87: 				BoundOrderByNode node;
88: 				node.type = order.orders[i].type;
89: 				node.expression = BindOrderExpression(order_binder, move(order.orders[i].expression));
90: 				if (!node.expression) {
91: 					continue;
92: 				}
93: 				bound_order->orders.push_back(move(node));
94: 			}
95: 			if (bound_order->orders.size() > 0) {
96: 				bound_modifier = move(bound_order);
97: 			}
98: 			break;
99: 		}
100: 		case ResultModifierType::LIMIT_MODIFIER:
101: 			bound_modifier = BindLimit((LimitModifier &)*mod);
102: 			break;
103: 		default:
104: 			throw Exception("Unsupported result modifier");
105: 		}
106: 		if (bound_modifier) {
107: 			result.modifiers.push_back(move(bound_modifier));
108: 		}
109: 	}
110: }
111: 
112: void Binder::BindModifierTypes(BoundQueryNode &result, const vector<TypeId> &types, idx_t projection_index) {
113: 	for (auto &bound_mod : result.modifiers) {
114: 		switch (bound_mod->type) {
115: 		case ResultModifierType::DISTINCT_MODIFIER: {
116: 			auto &distinct = (BoundDistinctModifier &)*bound_mod;
117: 			if (distinct.target_distincts.size() == 0) {
118: 				// DISTINCT without a target: push references to the standard select list
119: 				for (idx_t i = 0; i < types.size(); i++) {
120: 					distinct.target_distincts.push_back(
121: 					    make_unique<BoundColumnRefExpression>(types[i], ColumnBinding(projection_index, i)));
122: 				}
123: 			} else {
124: 				// DISTINCT with target list: set types
125: 				for (idx_t i = 0; i < distinct.target_distincts.size(); i++) {
126: 					auto &expr = distinct.target_distincts[i];
127: 					assert(expr->type == ExpressionType::BOUND_COLUMN_REF);
128: 					auto &bound_colref = (BoundColumnRefExpression &)*expr;
129: 					if (bound_colref.binding.column_index == INVALID_INDEX) {
130: 						throw BinderException("Ambiguous name in DISTINCT ON!");
131: 					}
132: 					assert(bound_colref.binding.column_index < types.size());
133: 					bound_colref.return_type = types[bound_colref.binding.column_index];
134: 				}
135: 			}
136: 			break;
137: 		}
138: 		case ResultModifierType::ORDER_MODIFIER: {
139: 			auto &order = (BoundOrderModifier &)*bound_mod;
140: 			for (idx_t i = 0; i < order.orders.size(); i++) {
141: 				auto &expr = order.orders[i].expression;
142: 				assert(expr->type == ExpressionType::BOUND_COLUMN_REF);
143: 				auto &bound_colref = (BoundColumnRefExpression &)*expr;
144: 				if (bound_colref.binding.column_index == INVALID_INDEX) {
145: 					throw BinderException("Ambiguous name in ORDER BY!");
146: 				}
147: 				assert(bound_colref.binding.column_index < types.size());
148: 				bound_colref.return_type = types[bound_colref.binding.column_index];
149: 			}
150: 			break;
151: 		}
152: 		default:
153: 			break;
154: 		}
155: 	}
156: }
157: 
158: unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
159: 	auto result = make_unique<BoundSelectNode>();
160: 	result->projection_index = GenerateTableIndex();
161: 	result->group_index = GenerateTableIndex();
162: 	result->aggregate_index = GenerateTableIndex();
163: 	result->window_index = GenerateTableIndex();
164: 	result->unnest_index = GenerateTableIndex();
165: 	result->prune_index = GenerateTableIndex();
166: 
167: 	// first bind the FROM table statement
168: 	result->from_table = Bind(*statement.from_table);
169: 
170: 	// visit the select list and expand any "*" statements
171: 	vector<unique_ptr<ParsedExpression>> new_select_list;
172: 	for (auto &select_element : statement.select_list) {
173: 		if (select_element->GetExpressionType() == ExpressionType::STAR) {
174: 			// * statement, expand to all columns from the FROM clause
175: 			bind_context.GenerateAllColumnExpressions(new_select_list);
176: 		} else if (select_element->GetExpressionType() == ExpressionType::TABLE_STAR) {
177: 			auto table_star =
178: 			    (TableStarExpression *)select_element.get(); // TODO this cast to explicit class is a bit dirty?
179: 			bind_context.GenerateAllColumnExpressions(new_select_list, table_star->relation_name);
180: 		} else {
181: 			// regular statement, add it to the list
182: 			new_select_list.push_back(move(select_element));
183: 		}
184: 	}
185: 	statement.select_list = move(new_select_list);
186: 
187: 	// create a mapping of (alias -> index) and a mapping of (Expression -> index) for the SELECT list
188: 	unordered_map<string, idx_t> alias_map;
189: 	expression_map_t<idx_t> projection_map;
190: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
191: 		auto &expr = statement.select_list[i];
192: 		result->names.push_back(expr->GetName());
193: 		if (!expr->alias.empty()) {
194: 			alias_map[expr->alias] = i;
195: 		}
196: 		ExpressionBinder::BindTableNames(*this, *expr);
197: 		projection_map[expr.get()] = i;
198: 		result->original_expressions.push_back(expr->Copy());
199: 	}
200: 	result->column_count = statement.select_list.size();
201: 
202: 	// first visit the WHERE clause
203: 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
204: 	if (statement.where_clause) {
205: 		result->where_clause = BindFilter(move(statement.where_clause));
206: 	}
207: 
208: 	// now bind all the result modifiers; including DISTINCT and ORDER BY targets
209: 	OrderBinder order_binder({this}, result->projection_index, statement, alias_map, projection_map);
210: 	BindModifiers(order_binder, statement, *result);
211: 
212: 	vector<unique_ptr<ParsedExpression>> unbound_groups;
213: 	BoundGroupInformation info;
214: 	if (statement.groups.size() > 0) {
215: 		// the statement has a GROUP BY clause, bind it
216: 		unbound_groups.resize(statement.groups.size());
217: 		GroupBinder group_binder(*this, context, statement, result->group_index, alias_map, info.alias_map);
218: 		for (idx_t i = 0; i < statement.groups.size(); i++) {
219: 
220: 			// we keep a copy of the unbound expression;
221: 			// we keep the unbound copy around to check for group references in the SELECT and HAVING clause
222: 			// the reason we want the unbound copy is because we want to figure out whether an expression
223: 			// is a group reference BEFORE binding in the SELECT/HAVING binder
224: 			group_binder.unbound_expression = statement.groups[i]->Copy();
225: 			group_binder.bind_index = i;
226: 
227: 			// bind the groups
228: 			SQLType group_type;
229: 			auto bound_expr = group_binder.Bind(statement.groups[i], &group_type);
230: 			assert(bound_expr->return_type != TypeId::INVALID);
231: 			info.group_types.push_back(group_type);
232: 			result->groups.push_back(move(bound_expr));
233: 
234: 			// in the unbound expression we DO bind the table names of any ColumnRefs
235: 			// we do this to make sure that "table.a" and "a" are treated the same
236: 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
237: 			// hence we convert "a" -> "test.a" in the unbound expression
238: 			unbound_groups[i] = move(group_binder.unbound_expression);
239: 			ExpressionBinder::BindTableNames(*this, *unbound_groups[i]);
240: 			info.map[unbound_groups[i].get()] = i;
241: 		}
242: 	}
243: 
244: 	// bind the HAVING clause, if any
245: 	if (statement.having) {
246: 		HavingBinder having_binder(*this, context, *result, info);
247: 		ExpressionBinder::BindTableNames(*this, *statement.having);
248: 		result->having = having_binder.Bind(statement.having);
249: 	}
250: 
251: 	// after that, we bind to the SELECT list
252: 	SelectBinder select_binder(*this, context, *result, info);
253: 	vector<TypeId> internal_types;
254: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
255: 		SQLType result_type;
256: 		auto expr = select_binder.Bind(statement.select_list[i], &result_type);
257: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES && select_binder.BoundColumns()) {
258: 			if (select_binder.BoundAggregates()) {
259: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
260: 			}
261: 			// we are forcing aggregates, and the node has columns bound
262: 			// this entry becomes a group
263: 			auto group_type = expr->return_type;
264: 			auto group_ref = make_unique<BoundColumnRefExpression>(
265: 			    group_type, ColumnBinding(result->group_index, result->groups.size()));
266: 			result->groups.push_back(move(expr));
267: 			expr = move(group_ref);
268: 		}
269: 		result->select_list.push_back(move(expr));
270: 		if (i < result->column_count) {
271: 			result->types.push_back(result_type);
272: 		}
273: 		internal_types.push_back(GetInternalType(result_type));
274: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
275: 			select_binder.ResetBindings();
276: 		}
277: 	}
278: 	result->need_prune = result->select_list.size() > result->column_count;
279: 
280: 	// in the normal select binder, we bind columns as if there is no aggregation
281: 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
282: 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
283: 	// we choose the former one [CONTROVERSIAL: this is the PostgreSQL behavior]
284: 	if (result->groups.size() > 0 || result->aggregates.size() > 0 || statement.having) {
285: 		if (statement.aggregate_handling == AggregateHandling::NO_AGGREGATES_ALLOWED) {
286: 			throw BinderException("Aggregates cannot be present in a Project relation!");
287: 		} else if (statement.aggregate_handling == AggregateHandling::STANDARD_HANDLING) {
288: 			if (select_binder.BoundColumns()) {
289: 				throw BinderException("column must appear in the GROUP BY clause or be used in an aggregate function");
290: 			}
291: 		}
292: 	}
293: 
294: 	// now that the SELECT list is bound, we set the types of DISTINCT/ORDER BY expressions
295: 	BindModifierTypes(*result, internal_types, result->projection_index);
296: 	return move(result);
297: }
298: 
299: } // namespace duckdb
[end of src/planner/binder/query_node/bind_select_node.cpp]
[start of src/planner/binder/query_node/bind_setop_node.cpp]
1: #include "duckdb/parser/expression/columnref_expression.hpp"
2: #include "duckdb/parser/expression/constant_expression.hpp"
3: #include "duckdb/parser/expression_map.hpp"
4: #include "duckdb/parser/query_node/select_node.hpp"
5: #include "duckdb/parser/query_node/set_operation_node.hpp"
6: #include "duckdb/planner/binder.hpp"
7: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
8: #include "duckdb/planner/query_node/bound_set_operation_node.hpp"
9: #include "duckdb/planner/query_node/bound_select_node.hpp"
10: #include "duckdb/planner/expression_binder/order_binder.hpp"
11: 
12: using namespace std;
13: 
14: namespace duckdb {
15: 
16: static void GatherAliases(BoundQueryNode &node, unordered_map<string, idx_t> &aliases,
17:                           expression_map_t<idx_t> &expressions) {
18: 	if (node.type == QueryNodeType::SET_OPERATION_NODE) {
19: 		// setop, recurse
20: 		auto &setop = (BoundSetOperationNode &)node;
21: 		GatherAliases(*setop.left, aliases, expressions);
22: 		GatherAliases(*setop.right, aliases, expressions);
23: 	} else {
24: 		// query node
25: 		assert(node.type == QueryNodeType::SELECT_NODE);
26: 		auto &select = (BoundSelectNode &)node;
27: 		// fill the alias lists
28: 		for (idx_t i = 0; i < select.names.size(); i++) {
29: 			auto &name = select.names[i];
30: 			auto &expr = select.original_expressions[i];
31: 			// first check if the alias is already in there
32: 			auto entry = aliases.find(name);
33: 			if (entry != aliases.end()) {
34: 				// the alias already exists
35: 				// check if there is a conflict
36: 				if (entry->second != i) {
37: 					// there is a conflict
38: 					// we place "-1" in the aliases map at this location
39: 					// "-1" signifies that there is an ambiguous reference
40: 					aliases[name] = INVALID_INDEX;
41: 				}
42: 			} else {
43: 				// the alias is not in there yet, just assign it
44: 				aliases[name] = i;
45: 			}
46: 			// now check if the node is already in the set of expressions
47: 			auto expr_entry = expressions.find(expr.get());
48: 			if (expr_entry != expressions.end()) {
49: 				// the node is in there
50: 				// repeat the same as with the alias: if there is an ambiguity we insert "-1"
51: 				if (expr_entry->second != i) {
52: 					expressions[expr.get()] = INVALID_INDEX;
53: 				}
54: 			} else {
55: 				// not in there yet, just place it in there
56: 				expressions[expr.get()] = i;
57: 			}
58: 		}
59: 	}
60: }
61: 
62: unique_ptr<BoundQueryNode> Binder::BindNode(SetOperationNode &statement) {
63: 	auto result = make_unique<BoundSetOperationNode>();
64: 	result->setop_type = statement.setop_type;
65: 
66: 	// first recursively visit the set operations
67: 	// both the left and right sides have an independent BindContext and Binder
68: 	assert(statement.left);
69: 	assert(statement.right);
70: 
71: 	result->setop_index = GenerateTableIndex();
72: 
73: 	result->left_binder = make_unique<Binder>(context, this);
74: 	result->left = result->left_binder->BindNode(*statement.left);
75: 
76: 	result->right_binder = make_unique<Binder>(context, this);
77: 	result->right = result->right_binder->BindNode(*statement.right);
78: 
79: 	if (statement.modifiers.size() > 0) {
80: 		// handle the ORDER BY/DISTINCT clauses
81: 
82: 		// we recursively visit the children of this node to extract aliases and expressions that can be referenced in
83: 		// the ORDER BY
84: 		unordered_map<string, idx_t> alias_map;
85: 		expression_map_t<idx_t> expression_map;
86: 		GatherAliases(*result, alias_map, expression_map);
87: 
88: 		// now we perform the actual resolution of the ORDER BY/DISTINCT expressions
89: 		OrderBinder order_binder({result->left_binder.get(), result->right_binder.get()}, result->setop_index,
90: 		                         alias_map, expression_map, statement.left->GetSelectList().size());
91: 		BindModifiers(order_binder, statement, *result);
92: 	}
93: 
94: 	result->names = result->left->names;
95: 
96: 	// move the correlated expressions from the child binders to this binder
97: 	MoveCorrelatedExpressions(*result->left_binder);
98: 	MoveCorrelatedExpressions(*result->right_binder);
99: 
100: 	// now both sides have been bound we can resolve types
101: 	if (result->left->types.size() != result->right->types.size()) {
102: 		throw Exception("Set operations can only apply to expressions with the "
103: 		                "same number of result columns");
104: 	}
105: 
106: 	// figure out the types of the setop result by picking the max of both
107: 	vector<TypeId> internal_types;
108: 	for (idx_t i = 0; i < result->left->types.size(); i++) {
109: 		auto result_type = MaxSQLType(result->left->types[i], result->right->types[i]);
110: 		result->types.push_back(result_type);
111: 		internal_types.push_back(GetInternalType(result_type));
112: 	}
113: 
114: 	// finally bind the types of the ORDER/DISTINCT clause expressions
115: 	BindModifierTypes(*result, internal_types, result->setop_index);
116: 	return move(result);
117: }
118: 
119: } // namespace duckdb
[end of src/planner/binder/query_node/bind_setop_node.cpp]
[start of src/planner/expression_binder.cpp]
1: #include "duckdb/planner/expression_binder.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/expression/subquery_expression.hpp"
5: #include "duckdb/parser/parsed_expression_iterator.hpp"
6: #include "duckdb/planner/binder.hpp"
7: #include "duckdb/planner/expression/bound_cast_expression.hpp"
8: #include "duckdb/planner/expression/bound_default_expression.hpp"
9: #include "duckdb/planner/expression/bound_parameter_expression.hpp"
10: #include "duckdb/planner/expression/bound_subquery_expression.hpp"
11: #include "duckdb/planner/expression_iterator.hpp"
12: 
13: using namespace duckdb;
14: using namespace std;
15: 
16: ExpressionBinder::ExpressionBinder(Binder &binder, ClientContext &context, bool replace_binder)
17:     : binder(binder), context(context), stored_binder(nullptr) {
18: 	if (replace_binder) {
19: 		stored_binder = binder.GetActiveBinder();
20: 		binder.SetActiveBinder(this);
21: 	} else {
22: 		binder.PushExpressionBinder(this);
23: 	}
24: }
25: 
26: ExpressionBinder::~ExpressionBinder() {
27: 	if (binder.HasActiveBinder()) {
28: 		if (stored_binder) {
29: 			binder.SetActiveBinder(stored_binder);
30: 		} else {
31: 			binder.PopExpressionBinder();
32: 		}
33: 	}
34: }
35: 
36: BindResult ExpressionBinder::BindExpression(ParsedExpression &expr, idx_t depth, bool root_expression) {
37: 	switch (expr.expression_class) {
38: 	case ExpressionClass::CASE:
39: 		return BindExpression((CaseExpression &)expr, depth);
40: 	case ExpressionClass::CAST:
41: 		return BindExpression((CastExpression &)expr, depth);
42: 	case ExpressionClass::COLUMN_REF:
43: 		return BindExpression((ColumnRefExpression &)expr, depth);
44: 	case ExpressionClass::COMPARISON:
45: 		return BindExpression((ComparisonExpression &)expr, depth);
46: 	case ExpressionClass::CONJUNCTION:
47: 		return BindExpression((ConjunctionExpression &)expr, depth);
48: 	case ExpressionClass::CONSTANT:
49: 		return BindExpression((ConstantExpression &)expr, depth);
50: 	case ExpressionClass::FUNCTION:
51: 		return BindExpression((FunctionExpression &)expr, depth);
52: 	case ExpressionClass::OPERATOR:
53: 		return BindExpression((OperatorExpression &)expr, depth);
54: 	case ExpressionClass::SUBQUERY:
55: 		return BindExpression((SubqueryExpression &)expr, depth);
56: 	case ExpressionClass::PARAMETER:
57: 		return BindExpression((ParameterExpression &)expr, depth);
58: 	default:
59: 		throw NotImplementedException("Unimplemented expression class");
60: 	}
61: }
62: 
63: bool ExpressionBinder::BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr) {
64: 	// try to bind in one of the outer queries, if the binding error occurred in a subquery
65: 	auto &active_binders = binder.GetActiveBinders();
66: 	// make a copy of the set of binders, so we can restore it later
67: 	auto binders = active_binders;
68: 	active_binders.pop_back();
69: 	idx_t depth = 1;
70: 	bool success = false;
71: 	while (active_binders.size() > 0) {
72: 		auto &next_binder = active_binders.back();
73: 		ExpressionBinder::BindTableNames(next_binder->binder, *expr);
74: 		auto bind_result = next_binder->Bind(&expr, depth);
75: 		if (bind_result.empty()) {
76: 			success = true;
77: 			break;
78: 		}
79: 		depth++;
80: 		active_binders.pop_back();
81: 	}
82: 	active_binders = binders;
83: 	return success;
84: }
85: 
86: void ExpressionBinder::BindChild(unique_ptr<ParsedExpression> &expr, idx_t depth, string &error) {
87: 	if (expr.get()) {
88: 		string bind_error = Bind(&expr, depth);
89: 		if (error.empty()) {
90: 			error = bind_error;
91: 		}
92: 	}
93: }
94: 
95: void ExpressionBinder::ExtractCorrelatedExpressions(Binder &binder, Expression &expr) {
96: 	if (expr.type == ExpressionType::BOUND_COLUMN_REF) {
97: 		auto &bound_colref = (BoundColumnRefExpression &)expr;
98: 		if (bound_colref.depth > 0) {
99: 			binder.AddCorrelatedColumn(CorrelatedColumnInfo(bound_colref));
100: 		}
101: 	}
102: 	ExpressionIterator::EnumerateChildren(expr,
103: 	                                      [&](Expression &child) { ExtractCorrelatedExpressions(binder, child); });
104: }
105: 
106: unique_ptr<Expression> ExpressionBinder::Bind(unique_ptr<ParsedExpression> &expr, SQLType *result_type,
107:                                               bool root_expression) {
108: 	// bind the main expression
109: 	auto error_msg = Bind(&expr, 0, root_expression);
110: 	if (!error_msg.empty()) {
111: 		// failed to bind: try to bind correlated columns in the expression (if any)
112: 		bool success = BindCorrelatedColumns(expr);
113: 		if (!success) {
114: 			throw BinderException(error_msg);
115: 		}
116: 		auto bound_expr = (BoundExpression *)expr.get();
117: 		ExtractCorrelatedExpressions(binder, *bound_expr->expr);
118: 	}
119: 	assert(expr->expression_class == ExpressionClass::BOUND_EXPRESSION);
120: 	auto bound_expr = (BoundExpression *)expr.get();
121: 	unique_ptr<Expression> result = move(bound_expr->expr);
122: 	if (target_type.id != SQLTypeId::INVALID) {
123: 		// the binder has a specific target type: add a cast to that type
124: 		result = BoundCastExpression::AddCastToType(move(result), bound_expr->sql_type, target_type);
125: 	} else {
126: 		if (bound_expr->sql_type.id == SQLTypeId::SQLNULL) {
127: 			// SQL NULL type is only used internally in the binder
128: 			// cast to INTEGER if we encounter it outside of the binder
129: 			bound_expr->sql_type = SQLType::INTEGER;
130: 			result = BoundCastExpression::AddCastToType(move(result), bound_expr->sql_type, bound_expr->sql_type);
131: 		}
132: 	}
133: 	if (result_type) {
134: 		*result_type = bound_expr->sql_type;
135: 	}
136: 	return result;
137: }
138: 
139: string ExpressionBinder::Bind(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression) {
140: 	// bind the node, but only if it has not been bound yet
141: 	auto &expression = **expr;
142: 	auto alias = expression.alias;
143: 	if (expression.GetExpressionClass() == ExpressionClass::BOUND_EXPRESSION) {
144: 		// already bound, don't bind it again
145: 		return string();
146: 	}
147: 	// bind the expression
148: 	BindResult result = BindExpression(**expr, depth, root_expression);
149: 	if (result.HasError()) {
150: 		return result.error;
151: 	} else {
152: 		// successfully bound: replace the node with a BoundExpression
153: 		*expr = make_unique<BoundExpression>(move(result.expression), move(*expr), result.sql_type);
154: 		auto be = (BoundExpression *)expr->get();
155: 		assert(be);
156: 		be->alias = alias;
157: 		if (!alias.empty()) {
158: 			be->expr->alias = alias;
159: 		}
160: 		return string();
161: 	}
162: }
163: 
164: void ExpressionBinder::BindTableNames(Binder &binder, ParsedExpression &expr) {
165: 	if (expr.type == ExpressionType::COLUMN_REF) {
166: 		auto &colref = (ColumnRefExpression &)expr;
167: 		if (colref.table_name.empty()) {
168: 			// no table name: find a binding that contains this
169: 			colref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);
170: 		}
171: 	}
172: 	ParsedExpressionIterator::EnumerateChildren(
173: 	    expr, [&](const ParsedExpression &child) { BindTableNames(binder, (ParsedExpression &)child); });
174: }
[end of src/planner/expression_binder.cpp]
[start of third_party/utf8proc/include/utf8proc.hpp]
1: /*
2:  * Copyright (c) 2014-2019 Steven G. Johnson, Jiahao Chen, Peter Colberg, Tony Kelman, Scott P. Jones, and other contributors.
3:  * Copyright (c) 2009 Public Software Group e. V., Berlin, Germany
4:  *
5:  * Permission is hereby granted, free of charge, to any person obtaining a
6:  * copy of this software and associated documentation files (the "Software"),
7:  * to deal in the Software without restriction, including without limitation
8:  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
9:  * and/or sell copies of the Software, and to permit persons to whom the
10:  * Software is furnished to do so, subject to the following conditions:
11:  *
12:  * The above copyright notice and this permission notice shall be included in
13:  * all copies or substantial portions of the Software.
14:  *
15:  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16:  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17:  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18:  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19:  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
20:  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
21:  * DEALINGS IN THE SOFTWARE.
22:  */
23: 
24: 
25: /**
26:  * @mainpage
27:  *
28:  * utf8proc is a free/open-source (MIT/expat licensed) C library
29:  * providing Unicode normalization, case-folding, and other operations
30:  * for strings in the UTF-8 encoding, supporting up-to-date Unicode versions.
31:  * See the utf8proc home page (http://julialang.org/utf8proc/)
32:  * for downloads and other information, or the source code on github
33:  * (https://github.com/JuliaLang/utf8proc).
34:  *
35:  * For the utf8proc API documentation, see: @ref utf8proc.h
36:  *
37:  * The features of utf8proc include:
38:  *
39:  * - Transformation of strings (@ref utf8proc_map) to:
40:  *    - decompose (@ref UTF8PROC_DECOMPOSE) or compose (@ref UTF8PROC_COMPOSE) Unicode combining characters (http://en.wikipedia.org/wiki/Combining_character)
41:  *    - canonicalize Unicode compatibility characters (@ref UTF8PROC_COMPAT)
42:  *    - strip "ignorable" (@ref UTF8PROC_IGNORE) characters, control characters (@ref UTF8PROC_STRIPCC), or combining characters such as accents (@ref UTF8PROC_STRIPMARK)
43:  *    - case-folding (@ref UTF8PROC_CASEFOLD)
44:  * - Unicode normalization: @ref utf8proc_NFD, @ref utf8proc_NFC, @ref utf8proc_NFKD, @ref utf8proc_NFKC
45:  * - Detecting grapheme boundaries (@ref utf8proc_grapheme_break and @ref UTF8PROC_CHARBOUND)
46:  * - Character-width computation: @ref utf8proc_charwidth
47:  * - Classification of characters by Unicode category: @ref utf8proc_category and @ref utf8proc_category_string
48:  * - Encode (@ref utf8proc_encode_char) and decode (@ref utf8proc_iterate) Unicode codepoints to/from UTF-8.
49:  */
50: 
51: /** @file */
52: 
53: #ifndef UTF8PROC_H
54: #define UTF8PROC_H
55: 
56: // DuckDB change:
57: #define UTF8PROC_STATIC
58: 
59: /** @name API version
60:  *
61:  * The utf8proc API version MAJOR.MINOR.PATCH, following
62:  * semantic-versioning rules (http://semver.org) based on API
63:  * compatibility.
64:  *
65:  * This is also returned at runtime by @ref utf8proc_version; however, the
66:  * runtime version may append a string like "-dev" to the version number
67:  * for prerelease versions.
68:  *
69:  * @note The shared-library version number in the Makefile
70:  *       (and CMakeLists.txt, and MANIFEST) may be different,
71:  *       being based on ABI compatibility rather than API compatibility.
72:  */
73: /** @{ */
74: /** The MAJOR version number (increased when backwards API compatibility is broken). */
75: #define UTF8PROC_VERSION_MAJOR 2
76: /** The MINOR version number (increased when new functionality is added in a backwards-compatible manner). */
77: #define UTF8PROC_VERSION_MINOR 4
78: /** The PATCH version (increased for fixes that do not change the API). */
79: #define UTF8PROC_VERSION_PATCH 0
80: /** @} */
81: 
82: #include <stdlib.h>
83: 
84: #if defined(_MSC_VER) && _MSC_VER < 1800
85: // MSVC prior to 2013 lacked stdbool.h and inttypes.h
86: typedef signed char utf8proc_int8_t;
87: typedef unsigned char utf8proc_uint8_t;
88: typedef short utf8proc_int16_t;
89: typedef unsigned short utf8proc_uint16_t;
90: typedef int utf8proc_int32_t;
91: typedef unsigned int utf8proc_uint32_t;
92: #  ifdef _WIN64
93: typedef __int64 utf8proc_ssize_t;
94: typedef unsigned __int64 utf8proc_size_t;
95: #  else
96: typedef int utf8proc_ssize_t;
97: typedef unsigned int utf8proc_size_t;
98: #  endif
99: #  ifndef __cplusplus
100: // emulate C99 bool
101: typedef unsigned char utf8proc_bool;
102: #    ifndef __bool_true_false_are_defined
103: #      define false 0
104: #      define true 1
105: #      define __bool_true_false_are_defined 1
106: #    endif
107: #  else
108: typedef bool utf8proc_bool;
109: #  endif
110: #else
111: #  include <stddef.h>
112: #  include <stdbool.h>
113: #  include <inttypes.h>
114: typedef int8_t utf8proc_int8_t;
115: typedef uint8_t utf8proc_uint8_t;
116: typedef int16_t utf8proc_int16_t;
117: typedef uint16_t utf8proc_uint16_t;
118: typedef int32_t utf8proc_int32_t;
119: typedef uint32_t utf8proc_uint32_t;
120: typedef size_t utf8proc_size_t;
121: typedef ptrdiff_t utf8proc_ssize_t;
122: typedef bool utf8proc_bool;
123: #endif
124: #include <limits.h>
125: 
126: #ifdef UTF8PROC_STATIC
127: #  define UTF8PROC_DLLEXPORT
128: #else
129: #  ifdef _WIN32
130: #    ifdef UTF8PROC_EXPORTS
131: #      define UTF8PROC_DLLEXPORT __declspec(dllexport)
132: #    else
133: #      define UTF8PROC_DLLEXPORT __declspec(dllimport)
134: #    endif
135: #  elif __GNUC__ >= 4
136: #    define UTF8PROC_DLLEXPORT __attribute__ ((visibility("default")))
137: #  else
138: #    define UTF8PROC_DLLEXPORT
139: #  endif
140: #endif
141: 
142: //#ifdef __cplusplus
143: //extern "C" {
144: //#endif
145: 
146: /**
147:  * Option flags used by several functions in the library.
148:  */
149: typedef enum {
150:   /** The given UTF-8 input is NULL terminated. */
151:   UTF8PROC_NULLTERM  = (1<<0),
152:   /** Unicode Versioning Stability has to be respected. */
153:   UTF8PROC_STABLE    = (1<<1),
154:   /** Compatibility decomposition (i.e. formatting information is lost). */
155:   UTF8PROC_COMPAT    = (1<<2),
156:   /** Return a result with decomposed characters. */
157:   UTF8PROC_COMPOSE   = (1<<3),
158:   /** Return a result with decomposed characters. */
159:   UTF8PROC_DECOMPOSE = (1<<4),
160:   /** Strip "default ignorable characters" such as SOFT-HYPHEN or ZERO-WIDTH-SPACE. */
161:   UTF8PROC_IGNORE    = (1<<5),
162:   /** Return an error, if the input contains unassigned codepoints. */
163:   UTF8PROC_REJECTNA  = (1<<6),
164:   /**
165:    * Indicating that NLF-sequences (LF, CRLF, CR, NEL) are representing a
166:    * line break, and should be converted to the codepoint for line
167:    * separation (LS).
168:    */
169:   UTF8PROC_NLF2LS    = (1<<7),
170:   /**
171:    * Indicating that NLF-sequences are representing a paragraph break, and
172:    * should be converted to the codepoint for paragraph separation
173:    * (PS).
174:    */
175:   UTF8PROC_NLF2PS    = (1<<8),
176:   /** Indicating that the meaning of NLF-sequences is unknown. */
177:   UTF8PROC_NLF2LF    = (UTF8PROC_NLF2LS | UTF8PROC_NLF2PS),
178:   /** Strips and/or convers control characters.
179:    *
180:    * NLF-sequences are transformed into space, except if one of the
181:    * NLF2LS/PS/LF options is given. HorizontalTab (HT) and FormFeed (FF)
182:    * are treated as a NLF-sequence in this case.  All other control
183:    * characters are simply removed.
184:    */
185:   UTF8PROC_STRIPCC   = (1<<9),
186:   /**
187:    * Performs unicode case folding, to be able to do a case-insensitive
188:    * string comparison.
189:    */
190:   UTF8PROC_CASEFOLD  = (1<<10),
191:   /**
192:    * Inserts 0xFF bytes at the beginning of each sequence which is
193:    * representing a single grapheme cluster (see UAX#29).
194:    */
195:   UTF8PROC_CHARBOUND = (1<<11),
196:   /** Lumps certain characters together.
197:    *
198:    * E.g. HYPHEN U+2010 and MINUS U+2212 to ASCII "-". See lump.md for details.
199:    *
200:    * If NLF2LF is set, this includes a transformation of paragraph and
201:    * line separators to ASCII line-feed (LF).
202:    */
203:   UTF8PROC_LUMP      = (1<<12),
204:   /** Strips all character markings.
205:    *
206:    * This includes non-spacing, spacing and enclosing (i.e. accents).
207:    * @note This option works only with @ref UTF8PROC_COMPOSE or
208:    *       @ref UTF8PROC_DECOMPOSE
209:    */
210:   UTF8PROC_STRIPMARK = (1<<13),
211:   /**
212:    * Strip unassigned codepoints.
213:    */
214:   UTF8PROC_STRIPNA    = (1<<14),
215: } utf8proc_option_t;
216: 
217: /** @name Error codes
218:  * Error codes being returned by almost all functions.
219:  */
220: /** @{ */
221: /** Memory could not be allocated. */
222: #define UTF8PROC_ERROR_NOMEM -1
223: /** The given string is too long to be processed. */
224: #define UTF8PROC_ERROR_OVERFLOW -2
225: /** The given string is not a legal UTF-8 string. */
226: #define UTF8PROC_ERROR_INVALIDUTF8 -3
227: /** The @ref UTF8PROC_REJECTNA flag was set and an unassigned codepoint was found. */
228: #define UTF8PROC_ERROR_NOTASSIGNED -4
229: /** Invalid options have been used. */
230: #define UTF8PROC_ERROR_INVALIDOPTS -5
231: /** @} */
232: 
233: /* @name Types */
234: 
235: /** Holds the value of a property. */
236: typedef utf8proc_int16_t utf8proc_propval_t;
237: 
238: /** Struct containing information about a codepoint. */
239: typedef struct utf8proc_property_struct {
240:   /**
241:    * Unicode category.
242:    * @see utf8proc_category_t.
243:    */
244:   utf8proc_propval_t category;
245:   utf8proc_propval_t combining_class;
246:   /**
247:    * Bidirectional class.
248:    * @see utf8proc_bidi_class_t.
249:    */
250:   utf8proc_propval_t bidi_class;
251:   /**
252:    * @anchor Decomposition type.
253:    * @see utf8proc_decomp_type_t.
254:    */
255:   utf8proc_propval_t decomp_type;
256:   utf8proc_uint16_t decomp_seqindex;
257:   utf8proc_uint16_t casefold_seqindex;
258:   utf8proc_uint16_t uppercase_seqindex;
259:   utf8proc_uint16_t lowercase_seqindex;
260:   utf8proc_uint16_t titlecase_seqindex;
261:   utf8proc_uint16_t comb_index;
262:   unsigned bidi_mirrored:1;
263:   unsigned comp_exclusion:1;
264:   /**
265:    * Can this codepoint be ignored?
266:    *
267:    * Used by @ref utf8proc_decompose_char when @ref UTF8PROC_IGNORE is
268:    * passed as an option.
269:    */
270:   unsigned ignorable:1;
271:   unsigned control_boundary:1;
272:   /** The width of the codepoint. */
273:   unsigned charwidth:2;
274:   unsigned pad:2;
275:   /**
276:    * Boundclass.
277:    * @see utf8proc_boundclass_t.
278:    */
279:   unsigned boundclass:8;
280: } utf8proc_property_t;
281: 
282: /** Unicode categories. */
283: typedef enum {
284:   UTF8PROC_CATEGORY_CN  = 0, /**< Other, not assigned */
285:   UTF8PROC_CATEGORY_LU  = 1, /**< Letter, uppercase */
286:   UTF8PROC_CATEGORY_LL  = 2, /**< Letter, lowercase */
287:   UTF8PROC_CATEGORY_LT  = 3, /**< Letter, titlecase */
288:   UTF8PROC_CATEGORY_LM  = 4, /**< Letter, modifier */
289:   UTF8PROC_CATEGORY_LO  = 5, /**< Letter, other */
290:   UTF8PROC_CATEGORY_MN  = 6, /**< Mark, nonspacing */
291:   UTF8PROC_CATEGORY_MC  = 7, /**< Mark, spacing combining */
292:   UTF8PROC_CATEGORY_ME  = 8, /**< Mark, enclosing */
293:   UTF8PROC_CATEGORY_ND  = 9, /**< Number, decimal digit */
294:   UTF8PROC_CATEGORY_NL = 10, /**< Number, letter */
295:   UTF8PROC_CATEGORY_NO = 11, /**< Number, other */
296:   UTF8PROC_CATEGORY_PC = 12, /**< Punctuation, connector */
297:   UTF8PROC_CATEGORY_PD = 13, /**< Punctuation, dash */
298:   UTF8PROC_CATEGORY_PS = 14, /**< Punctuation, open */
299:   UTF8PROC_CATEGORY_PE = 15, /**< Punctuation, close */
300:   UTF8PROC_CATEGORY_PI = 16, /**< Punctuation, initial quote */
301:   UTF8PROC_CATEGORY_PF = 17, /**< Punctuation, final quote */
302:   UTF8PROC_CATEGORY_PO = 18, /**< Punctuation, other */
303:   UTF8PROC_CATEGORY_SM = 19, /**< Symbol, math */
304:   UTF8PROC_CATEGORY_SC = 20, /**< Symbol, currency */
305:   UTF8PROC_CATEGORY_SK = 21, /**< Symbol, modifier */
306:   UTF8PROC_CATEGORY_SO = 22, /**< Symbol, other */
307:   UTF8PROC_CATEGORY_ZS = 23, /**< Separator, space */
308:   UTF8PROC_CATEGORY_ZL = 24, /**< Separator, line */
309:   UTF8PROC_CATEGORY_ZP = 25, /**< Separator, paragraph */
310:   UTF8PROC_CATEGORY_CC = 26, /**< Other, control */
311:   UTF8PROC_CATEGORY_CF = 27, /**< Other, format */
312:   UTF8PROC_CATEGORY_CS = 28, /**< Other, surrogate */
313:   UTF8PROC_CATEGORY_CO = 29, /**< Other, private use */
314: } utf8proc_category_t;
315: 
316: /** Bidirectional character classes. */
317: typedef enum {
318:   UTF8PROC_BIDI_CLASS_L     = 1, /**< Left-to-Right */
319:   UTF8PROC_BIDI_CLASS_LRE   = 2, /**< Left-to-Right Embedding */
320:   UTF8PROC_BIDI_CLASS_LRO   = 3, /**< Left-to-Right Override */
321:   UTF8PROC_BIDI_CLASS_R     = 4, /**< Right-to-Left */
322:   UTF8PROC_BIDI_CLASS_AL    = 5, /**< Right-to-Left Arabic */
323:   UTF8PROC_BIDI_CLASS_RLE   = 6, /**< Right-to-Left Embedding */
324:   UTF8PROC_BIDI_CLASS_RLO   = 7, /**< Right-to-Left Override */
325:   UTF8PROC_BIDI_CLASS_PDF   = 8, /**< Pop Directional Format */
326:   UTF8PROC_BIDI_CLASS_EN    = 9, /**< European Number */
327:   UTF8PROC_BIDI_CLASS_ES   = 10, /**< European Separator */
328:   UTF8PROC_BIDI_CLASS_ET   = 11, /**< European Number Terminator */
329:   UTF8PROC_BIDI_CLASS_AN   = 12, /**< Arabic Number */
330:   UTF8PROC_BIDI_CLASS_CS   = 13, /**< Common Number Separator */
331:   UTF8PROC_BIDI_CLASS_NSM  = 14, /**< Nonspacing Mark */
332:   UTF8PROC_BIDI_CLASS_BN   = 15, /**< Boundary Neutral */
333:   UTF8PROC_BIDI_CLASS_B    = 16, /**< Paragraph Separator */
334:   UTF8PROC_BIDI_CLASS_S    = 17, /**< Segment Separator */
335:   UTF8PROC_BIDI_CLASS_WS   = 18, /**< Whitespace */
336:   UTF8PROC_BIDI_CLASS_ON   = 19, /**< Other Neutrals */
337:   UTF8PROC_BIDI_CLASS_LRI  = 20, /**< Left-to-Right Isolate */
338:   UTF8PROC_BIDI_CLASS_RLI  = 21, /**< Right-to-Left Isolate */
339:   UTF8PROC_BIDI_CLASS_FSI  = 22, /**< First Strong Isolate */
340:   UTF8PROC_BIDI_CLASS_PDI  = 23, /**< Pop Directional Isolate */
341: } utf8proc_bidi_class_t;
342: 
343: /** Decomposition type. */
344: typedef enum {
345:   UTF8PROC_DECOMP_TYPE_FONT      = 1, /**< Font */
346:   UTF8PROC_DECOMP_TYPE_NOBREAK   = 2, /**< Nobreak */
347:   UTF8PROC_DECOMP_TYPE_INITIAL   = 3, /**< Initial */
348:   UTF8PROC_DECOMP_TYPE_MEDIAL    = 4, /**< Medial */
349:   UTF8PROC_DECOMP_TYPE_FINAL     = 5, /**< Final */
350:   UTF8PROC_DECOMP_TYPE_ISOLATED  = 6, /**< Isolated */
351:   UTF8PROC_DECOMP_TYPE_CIRCLE    = 7, /**< Circle */
352:   UTF8PROC_DECOMP_TYPE_SUPER     = 8, /**< Super */
353:   UTF8PROC_DECOMP_TYPE_SUB       = 9, /**< Sub */
354:   UTF8PROC_DECOMP_TYPE_VERTICAL = 10, /**< Vertical */
355:   UTF8PROC_DECOMP_TYPE_WIDE     = 11, /**< Wide */
356:   UTF8PROC_DECOMP_TYPE_NARROW   = 12, /**< Narrow */
357:   UTF8PROC_DECOMP_TYPE_SMALL    = 13, /**< Small */
358:   UTF8PROC_DECOMP_TYPE_SQUARE   = 14, /**< Square */
359:   UTF8PROC_DECOMP_TYPE_FRACTION = 15, /**< Fraction */
360:   UTF8PROC_DECOMP_TYPE_COMPAT   = 16, /**< Compat */
361: } utf8proc_decomp_type_t;
362: 
363: /** Boundclass property. (TR29) */
364: typedef enum {
365:   UTF8PROC_BOUNDCLASS_START              =  0, /**< Start */
366:   UTF8PROC_BOUNDCLASS_OTHER              =  1, /**< Other */
367:   UTF8PROC_BOUNDCLASS_CR                 =  2, /**< Cr */
368:   UTF8PROC_BOUNDCLASS_LF                 =  3, /**< Lf */
369:   UTF8PROC_BOUNDCLASS_CONTROL            =  4, /**< Control */
370:   UTF8PROC_BOUNDCLASS_EXTEND             =  5, /**< Extend */
371:   UTF8PROC_BOUNDCLASS_L                  =  6, /**< L */
372:   UTF8PROC_BOUNDCLASS_V                  =  7, /**< V */
373:   UTF8PROC_BOUNDCLASS_T                  =  8, /**< T */
374:   UTF8PROC_BOUNDCLASS_LV                 =  9, /**< Lv */
375:   UTF8PROC_BOUNDCLASS_LVT                = 10, /**< Lvt */
376:   UTF8PROC_BOUNDCLASS_REGIONAL_INDICATOR = 11, /**< Regional indicator */
377:   UTF8PROC_BOUNDCLASS_SPACINGMARK        = 12, /**< Spacingmark */
378:   UTF8PROC_BOUNDCLASS_PREPEND            = 13, /**< Prepend */
379:   UTF8PROC_BOUNDCLASS_ZWJ                = 14, /**< Zero Width Joiner */
380: 
381:   /* the following are no longer used in Unicode 11, but we keep
382:      the constants here for backward compatibility */
383:   UTF8PROC_BOUNDCLASS_E_BASE             = 15, /**< Emoji Base */
384:   UTF8PROC_BOUNDCLASS_E_MODIFIER         = 16, /**< Emoji Modifier */
385:   UTF8PROC_BOUNDCLASS_GLUE_AFTER_ZWJ     = 17, /**< Glue_After_ZWJ */
386:   UTF8PROC_BOUNDCLASS_E_BASE_GAZ         = 18, /**< E_BASE + GLUE_AFTER_ZJW */
387: 
388:   /* the Extended_Pictographic property is used in the Unicode 11
389:      grapheme-boundary rules, so we store it in the boundclass field */
390:   UTF8PROC_BOUNDCLASS_EXTENDED_PICTOGRAPHIC = 19,
391:   UTF8PROC_BOUNDCLASS_E_ZWG = 20, /* UTF8PROC_BOUNDCLASS_EXTENDED_PICTOGRAPHIC + ZWJ */
392: } utf8proc_boundclass_t;
393: 
394: /**
395:  * Function pointer type passed to @ref utf8proc_map_custom and
396:  * @ref utf8proc_decompose_custom, which is used to specify a user-defined
397:  * mapping of codepoints to be applied in conjunction with other mappings.
398:  */
399: typedef utf8proc_int32_t (*utf8proc_custom_func)(utf8proc_int32_t codepoint, void *data);
400: 
401: /**
402:  * Array containing the byte lengths of a UTF-8 encoded codepoint based
403:  * on the first byte.
404:  */
405: UTF8PROC_DLLEXPORT extern const utf8proc_int8_t utf8proc_utf8class[256];
406: 
407: /**
408:  * Returns the utf8proc API version as a string MAJOR.MINOR.PATCH
409:  * (http://semver.org format), possibly with a "-dev" suffix for
410:  * development versions.
411:  */
412: UTF8PROC_DLLEXPORT const char *utf8proc_version(void);
413: 
414: /**
415:  * Returns the utf8proc supported Unicode version as a string MAJOR.MINOR.PATCH.
416:  */
417: UTF8PROC_DLLEXPORT const char *utf8proc_unicode_version(void);
418: 
419: /**
420:  * Returns an informative error string for the given utf8proc error code
421:  * (e.g. the error codes returned by @ref utf8proc_map).
422:  */
423: UTF8PROC_DLLEXPORT const char *utf8proc_errmsg(utf8proc_ssize_t errcode);
424: 
425: /**
426:  * Reads a single codepoint from the UTF-8 sequence being pointed to by `str`.
427:  * The maximum number of bytes read is `strlen`, unless `strlen` is
428:  * negative (in which case up to 4 bytes are read).
429:  *
430:  * If a valid codepoint could be read, it is stored in the variable
431:  * pointed to by `codepoint_ref`, otherwise that variable will be set to -1.
432:  * In case of success, the number of bytes read is returned; otherwise, a
433:  * negative error code is returned.
434:  */
435: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_iterate(const utf8proc_uint8_t *str, utf8proc_ssize_t strlen, utf8proc_int32_t *codepoint_ref);
436: 
437: /**
438:  * Check if a codepoint is valid (regardless of whether it has been
439:  * assigned a value by the current Unicode standard).
440:  *
441:  * @return 1 if the given `codepoint` is valid and otherwise return 0.
442:  */
443: UTF8PROC_DLLEXPORT utf8proc_bool utf8proc_codepoint_valid(utf8proc_int32_t codepoint);
444: 
445: /**
446:  * Encodes the codepoint as an UTF-8 string in the byte array pointed
447:  * to by `dst`. This array must be at least 4 bytes long.
448:  *
449:  * In case of success the number of bytes written is returned, and
450:  * otherwise 0 is returned.
451:  *
452:  * This function does not check whether `codepoint` is valid Unicode.
453:  */
454: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_encode_char(utf8proc_int32_t codepoint, utf8proc_uint8_t *dst);
455: 
456: /**
457:  * Look up the properties for a given codepoint.
458:  *
459:  * @param codepoint The Unicode codepoint.
460:  *
461:  * @returns
462:  * A pointer to a (constant) struct containing information about
463:  * the codepoint.
464:  * @par
465:  * If the codepoint is unassigned or invalid, a pointer to a special struct is
466:  * returned in which `category` is 0 (@ref UTF8PROC_CATEGORY_CN).
467:  */
468: UTF8PROC_DLLEXPORT const utf8proc_property_t *utf8proc_get_property(utf8proc_int32_t codepoint);
469: 
470: /** Decompose a codepoint into an array of codepoints.
471:  *
472:  * @param codepoint the codepoint.
473:  * @param dst the destination buffer.
474:  * @param bufsize the size of the destination buffer.
475:  * @param options one or more of the following flags:
476:  * - @ref UTF8PROC_REJECTNA  - return an error `codepoint` is unassigned
477:  * - @ref UTF8PROC_IGNORE    - strip "default ignorable" codepoints
478:  * - @ref UTF8PROC_CASEFOLD  - apply Unicode casefolding
479:  * - @ref UTF8PROC_COMPAT    - replace certain codepoints with their
480:  *                             compatibility decomposition
481:  * - @ref UTF8PROC_CHARBOUND - insert 0xFF bytes before each grapheme cluster
482:  * - @ref UTF8PROC_LUMP      - lump certain different codepoints together
483:  * - @ref UTF8PROC_STRIPMARK - remove all character marks
484:  * - @ref UTF8PROC_STRIPNA   - remove unassigned codepoints
485:  * @param last_boundclass
486:  * Pointer to an integer variable containing
487:  * the previous codepoint's boundary class if the @ref UTF8PROC_CHARBOUND
488:  * option is used.  Otherwise, this parameter is ignored.
489:  *
490:  * @return
491:  * In case of success, the number of codepoints written is returned; in case
492:  * of an error, a negative error code is returned (@ref utf8proc_errmsg).
493:  * @par
494:  * If the number of written codepoints would be bigger than `bufsize`, the
495:  * required buffer size is returned, while the buffer will be overwritten with
496:  * undefined data.
497:  */
498: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_decompose_char(
499:   utf8proc_int32_t codepoint, utf8proc_int32_t *dst, utf8proc_ssize_t bufsize,
500:   utf8proc_option_t options, int *last_boundclass
501: );
502: 
503: /**
504:  * The same as @ref utf8proc_decompose_char, but acts on a whole UTF-8
505:  * string and orders the decomposed sequences correctly.
506:  *
507:  * If the @ref UTF8PROC_NULLTERM flag in `options` is set, processing
508:  * will be stopped, when a NULL byte is encounted, otherwise `strlen`
509:  * bytes are processed.  The result (in the form of 32-bit unicode
510:  * codepoints) is written into the buffer being pointed to by
511:  * `buffer` (which must contain at least `bufsize` entries).  In case of
512:  * success, the number of codepoints written is returned; in case of an
513:  * error, a negative error code is returned (@ref utf8proc_errmsg).
514:  * See @ref utf8proc_decompose_custom to supply additional transformations.
515:  *
516:  * If the number of written codepoints would be bigger than `bufsize`, the
517:  * required buffer size is returned, while the buffer will be overwritten with
518:  * undefined data.
519:  */
520: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_decompose(
521:   const utf8proc_uint8_t *str, utf8proc_ssize_t strlen,
522:   utf8proc_int32_t *buffer, utf8proc_ssize_t bufsize, utf8proc_option_t options
523: );
524: 
525: /**
526:  * The same as @ref utf8proc_decompose, but also takes a `custom_func` mapping function
527:  * that is called on each codepoint in `str` before any other transformations
528:  * (along with a `custom_data` pointer that is passed through to `custom_func`).
529:  * The `custom_func` argument is ignored if it is `NULL`.  See also @ref utf8proc_map_custom.
530:  */
531: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_decompose_custom(
532:   const utf8proc_uint8_t *str, utf8proc_ssize_t strlen,
533:   utf8proc_int32_t *buffer, utf8proc_ssize_t bufsize, utf8proc_option_t options,
534:   utf8proc_custom_func custom_func, void *custom_data
535: );
536: 
537: /**
538:  * Normalizes the sequence of `length` codepoints pointed to by `buffer`
539:  * in-place (i.e., the result is also stored in `buffer`).
540:  *
541:  * @param buffer the (native-endian UTF-32) unicode codepoints to re-encode.
542:  * @param length the length (in codepoints) of the buffer.
543:  * @param options a bitwise or (`|`) of one or more of the following flags:
544:  * - @ref UTF8PROC_NLF2LS  - convert LF, CRLF, CR and NEL into LS
545:  * - @ref UTF8PROC_NLF2PS  - convert LF, CRLF, CR and NEL into PS
546:  * - @ref UTF8PROC_NLF2LF  - convert LF, CRLF, CR and NEL into LF
547:  * - @ref UTF8PROC_STRIPCC - strip or convert all non-affected control characters
548:  * - @ref UTF8PROC_COMPOSE - try to combine decomposed codepoints into composite
549:  *                           codepoints
550:  * - @ref UTF8PROC_STABLE  - prohibit combining characters that would violate
551:  *                           the unicode versioning stability
552:  *
553:  * @return
554:  * In case of success, the length (in codepoints) of the normalized UTF-32 string is
555:  * returned; otherwise, a negative error code is returned (@ref utf8proc_errmsg).
556:  *
557:  * @warning The entries of the array pointed to by `str` have to be in the
558:  *          range `0x0000` to `0x10FFFF`. Otherwise, the program might crash!
559:  */
560: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_normalize_utf32(utf8proc_int32_t *buffer, utf8proc_ssize_t length, utf8proc_option_t options);
561: 
562: /**
563:  * Reencodes the sequence of `length` codepoints pointed to by `buffer`
564:  * UTF-8 data in-place (i.e., the result is also stored in `buffer`).
565:  * Can optionally normalize the UTF-32 sequence prior to UTF-8 conversion.
566:  *
567:  * @param buffer the (native-endian UTF-32) unicode codepoints to re-encode.
568:  * @param length the length (in codepoints) of the buffer.
569:  * @param options a bitwise or (`|`) of one or more of the following flags:
570:  * - @ref UTF8PROC_NLF2LS  - convert LF, CRLF, CR and NEL into LS
571:  * - @ref UTF8PROC_NLF2PS  - convert LF, CRLF, CR and NEL into PS
572:  * - @ref UTF8PROC_NLF2LF  - convert LF, CRLF, CR and NEL into LF
573:  * - @ref UTF8PROC_STRIPCC - strip or convert all non-affected control characters
574:  * - @ref UTF8PROC_COMPOSE - try to combine decomposed codepoints into composite
575:  *                           codepoints
576:  * - @ref UTF8PROC_STABLE  - prohibit combining characters that would violate
577:  *                           the unicode versioning stability
578:  * - @ref UTF8PROC_CHARBOUND - insert 0xFF bytes before each grapheme cluster
579:  *
580:  * @return
581:  * In case of success, the length (in bytes) of the resulting nul-terminated
582:  * UTF-8 string is returned; otherwise, a negative error code is returned
583:  * (@ref utf8proc_errmsg).
584:  *
585:  * @warning The amount of free space pointed to by `buffer` must
586:  *          exceed the amount of the input data by one byte, and the
587:  *          entries of the array pointed to by `str` have to be in the
588:  *          range `0x0000` to `0x10FFFF`. Otherwise, the program might crash!
589:  */
590: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_reencode(utf8proc_int32_t *buffer, utf8proc_ssize_t length, utf8proc_option_t options);
591: 
592: /**
593:  * Given a pair of consecutive codepoints, return whether a grapheme break is
594:  * permitted between them (as defined by the extended grapheme clusters in UAX#29).
595:  *
596:  * @param codepoint1 The first codepoint.
597:  * @param codepoint2 The second codepoint, occurring consecutively after `codepoint1`.
598:  * @param state Beginning with Version 29 (Unicode 9.0.0), this algorithm requires
599:  *              state to break graphemes. This state can be passed in as a pointer
600:  *              in the `state` argument and should initially be set to 0. If the
601:  *              state is not passed in (i.e. a null pointer is passed), UAX#29 rules
602:  *              GB10/12/13 which require this state will not be applied, essentially
603:  *              matching the rules in Unicode 8.0.0.
604:  *
605:  * @warning If the state parameter is used, `utf8proc_grapheme_break_stateful` must
606:  *          be called IN ORDER on ALL potential breaks in a string.  However, it
607:  *          is safe to reset the state to zero after a grapheme break.
608:  */
609: UTF8PROC_DLLEXPORT utf8proc_bool utf8proc_grapheme_break_stateful(
610:     utf8proc_int32_t codepoint1, utf8proc_int32_t codepoint2, utf8proc_int32_t *state);
611: 
612: /**
613:  * Same as @ref utf8proc_grapheme_break_stateful, except without support for the
614:  * Unicode 9 additions to the algorithm. Supported for legacy reasons.
615:  */
616: UTF8PROC_DLLEXPORT utf8proc_bool utf8proc_grapheme_break(
617:     utf8proc_int32_t codepoint1, utf8proc_int32_t codepoint2);
618: 
619: 
620: /**
621:  * Given a codepoint `c`, return the codepoint of the corresponding
622:  * lower-case character, if any; otherwise (if there is no lower-case
623:  * variant, or if `c` is not a valid codepoint) return `c`.
624:  */
625: UTF8PROC_DLLEXPORT utf8proc_int32_t utf8proc_tolower(utf8proc_int32_t c);
626: 
627: /**
628:  * Given a codepoint `c`, return the codepoint of the corresponding
629:  * upper-case character, if any; otherwise (if there is no upper-case
630:  * variant, or if `c` is not a valid codepoint) return `c`.
631:  */
632: UTF8PROC_DLLEXPORT utf8proc_int32_t utf8proc_toupper(utf8proc_int32_t c);
633: 
634: /**
635:  * Given a codepoint `c`, return the codepoint of the corresponding
636:  * title-case character, if any; otherwise (if there is no title-case
637:  * variant, or if `c` is not a valid codepoint) return `c`.
638:  */
639: UTF8PROC_DLLEXPORT utf8proc_int32_t utf8proc_totitle(utf8proc_int32_t c);
640: 
641: /**
642:  * Given a codepoint, return a character width analogous to `wcwidth(codepoint)`,
643:  * except that a width of 0 is returned for non-printable codepoints
644:  * instead of -1 as in `wcwidth`.
645:  *
646:  * @note
647:  * If you want to check for particular types of non-printable characters,
648:  * (analogous to `isprint` or `iscntrl`), use @ref utf8proc_category. */
649: UTF8PROC_DLLEXPORT int utf8proc_charwidth(utf8proc_int32_t codepoint);
650: 
651: /**
652:  * Return the Unicode category for the codepoint (one of the
653:  * @ref utf8proc_category_t constants.)
654:  */
655: UTF8PROC_DLLEXPORT utf8proc_category_t utf8proc_category(utf8proc_int32_t codepoint);
656: 
657: /**
658:  * Return the two-letter (nul-terminated) Unicode category string for
659:  * the codepoint (e.g. `"Lu"` or `"Co"`).
660:  */
661: UTF8PROC_DLLEXPORT const char *utf8proc_category_string(utf8proc_int32_t codepoint);
662: 
663: /**
664:  * Maps the given UTF-8 string pointed to by `str` to a new UTF-8
665:  * string, allocated dynamically by `malloc` and returned via `dstptr`.
666:  *
667:  * If the @ref UTF8PROC_NULLTERM flag in the `options` field is set,
668:  * the length is determined by a NULL terminator, otherwise the
669:  * parameter `strlen` is evaluated to determine the string length, but
670:  * in any case the result will be NULL terminated (though it might
671:  * contain NULL characters with the string if `str` contained NULL
672:  * characters). Other flags in the `options` field are passed to the
673:  * functions defined above, and regarded as described.  See also
674:  * @ref utf8proc_map_custom to supply a custom codepoint transformation.
675:  *
676:  * In case of success the length of the new string is returned,
677:  * otherwise a negative error code is returned.
678:  *
679:  * @note The memory of the new UTF-8 string will have been allocated
680:  * with `malloc`, and should therefore be deallocated with `free`.
681:  */
682: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_map(
683:   const utf8proc_uint8_t *str, utf8proc_ssize_t strlen, utf8proc_uint8_t **dstptr, utf8proc_option_t options
684: );
685: 
686: /**
687:  * Like @ref utf8proc_map, but also takes a `custom_func` mapping function
688:  * that is called on each codepoint in `str` before any other transformations
689:  * (along with a `custom_data` pointer that is passed through to `custom_func`).
690:  * The `custom_func` argument is ignored if it is `NULL`.
691:  */
692: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_map_custom(
693:   const utf8proc_uint8_t *str, utf8proc_ssize_t strlen, utf8proc_uint8_t **dstptr, utf8proc_option_t options,
694:   utf8proc_custom_func custom_func, void *custom_data
695: );
696: 
697: /** @name Unicode normalization
698:  *
699:  * Returns a pointer to newly allocated memory of a NFD, NFC, NFKD, NFKC or
700:  * NFKC_Casefold normalized version of the null-terminated string `str`.  These
701:  * are shortcuts to calling @ref utf8proc_map with @ref UTF8PROC_NULLTERM
702:  * combined with @ref UTF8PROC_STABLE and flags indicating the normalization.
703:  */
704: /** @{ */
705: /** NFD normalization (@ref UTF8PROC_DECOMPOSE). */
706: UTF8PROC_DLLEXPORT utf8proc_uint8_t *utf8proc_NFD(const utf8proc_uint8_t *str);
707: /** NFC normalization (@ref UTF8PROC_COMPOSE). */
708: UTF8PROC_DLLEXPORT utf8proc_uint8_t *utf8proc_NFC(const utf8proc_uint8_t *str);
709: /** NFKD normalization (@ref UTF8PROC_DECOMPOSE and @ref UTF8PROC_COMPAT). */
710: UTF8PROC_DLLEXPORT utf8proc_uint8_t *utf8proc_NFKD(const utf8proc_uint8_t *str);
711: /** NFKC normalization (@ref UTF8PROC_COMPOSE and @ref UTF8PROC_COMPAT). */
712: UTF8PROC_DLLEXPORT utf8proc_uint8_t *utf8proc_NFKC(const utf8proc_uint8_t *str);
713: /**
714:  * NFKC_Casefold normalization (@ref UTF8PROC_COMPOSE and @ref UTF8PROC_COMPAT
715:  * and @ref UTF8PROC_CASEFOLD and @ref UTF8PROC_IGNORE).
716:  **/
717: UTF8PROC_DLLEXPORT utf8proc_uint8_t *utf8proc_NFKC_Casefold(const utf8proc_uint8_t *str);
718: /** @} */
719: 
720: //#ifdef __cplusplus
721: //}
722: //#endif
723: 
724: #endif
[end of third_party/utf8proc/include/utf8proc.hpp]
[start of third_party/utf8proc/include/utf8proc_wrapper.hpp]
1: #pragma once
2: 
3: #include <string>
4: #include <cassert>
5: #include <cstring>
6: 
7: namespace duckdb {
8: 
9: enum class UnicodeType {INVALID, ASCII, UNICODE};
10: 
11: 
12: class Utf8Proc {
13: public:
14: 
15: 	static UnicodeType Analyze(const char* s) {
16: 		return Analyze(s, std::strlen(s));
17: 	}
18: 
19: 	static UnicodeType Analyze(std::string s) {
20: 		return Analyze(s.c_str(), s.size());
21: 	}
22: 
23: 	static UnicodeType Analyze(const char *s, size_t len);
24: 
25: 
26: 	static std::string Normalize(std::string s);
27: 
28: 	static char* Normalize(const char* s);
29: 
30: };
31: }
[end of third_party/utf8proc/include/utf8proc_wrapper.hpp]
[start of third_party/utf8proc/utf8proc.cpp]
1: /* -*- mode: c; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: nil -*- */
2: /*
3:  *  Copyright (c) 2014-2019 Steven G. Johnson, Jiahao Chen, Peter Colberg, Tony Kelman, Scott P. Jones, and other contributors.
4:  *  Copyright (c) 2009 Public Software Group e. V., Berlin, Germany
5:  *
6:  *  Permission is hereby granted, free of charge, to any person obtaining a
7:  *  copy of this software and associated documentation files (the "Software"),
8:  *  to deal in the Software without restriction, including without limitation
9:  *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
10:  *  and/or sell copies of the Software, and to permit persons to whom the
11:  *  Software is furnished to do so, subject to the following conditions:
12:  *
13:  *  The above copyright notice and this permission notice shall be included in
14:  *  all copies or substantial portions of the Software.
15:  *
16:  *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
17:  *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
18:  *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
19:  *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
20:  *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
21:  *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
22:  *  DEALINGS IN THE SOFTWARE.
23:  */
24: 
25: /*
26:  *  This library contains derived data from a modified version of the
27:  *  Unicode data files.
28:  *
29:  *  The original data files are available at
30:  *  http://www.unicode.org/Public/UNIDATA/
31:  *
32:  *  Please notice the copyright statement in the file "utf8proc_data.c".
33:  */
34: 
35: 
36: /*
37:  *  File name:    utf8proc.c
38:  *
39:  *  Description:
40:  *  Implementation of libutf8proc.
41:  */
42: 
43: 
44: #include "utf8proc.hpp"
45: 
46: #ifndef SSIZE_MAX
47: #define SSIZE_MAX ((size_t)SIZE_MAX/2)
48: #endif
49: #ifndef UINT16_MAX
50: #  define UINT16_MAX 65535U
51: #endif
52: 
53: #include "utf8proc_data.cpp"
54: 
55: 
56: UTF8PROC_DLLEXPORT const utf8proc_int8_t utf8proc_utf8class[256] = {
57:   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
58:   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
59:   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
60:   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
61:   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
62:   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
63:   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
64:   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
65:   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
66:   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
67:   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
68:   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
69:   2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
70:   2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
71:   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
72:   4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0 };
73: 
74: #define UTF8PROC_HANGUL_SBASE 0xAC00
75: #define UTF8PROC_HANGUL_LBASE 0x1100
76: #define UTF8PROC_HANGUL_VBASE 0x1161
77: #define UTF8PROC_HANGUL_TBASE 0x11A7
78: #define UTF8PROC_HANGUL_LCOUNT 19
79: #define UTF8PROC_HANGUL_VCOUNT 21
80: #define UTF8PROC_HANGUL_TCOUNT 28
81: #define UTF8PROC_HANGUL_NCOUNT 588
82: #define UTF8PROC_HANGUL_SCOUNT 11172
83: /* END is exclusive */
84: #define UTF8PROC_HANGUL_L_START  0x1100
85: #define UTF8PROC_HANGUL_L_END    0x115A
86: #define UTF8PROC_HANGUL_L_FILLER 0x115F
87: #define UTF8PROC_HANGUL_V_START  0x1160
88: #define UTF8PROC_HANGUL_V_END    0x11A3
89: #define UTF8PROC_HANGUL_T_START  0x11A8
90: #define UTF8PROC_HANGUL_T_END    0x11FA
91: #define UTF8PROC_HANGUL_S_START  0xAC00
92: #define UTF8PROC_HANGUL_S_END    0xD7A4
93: 
94: /* Should follow semantic-versioning rules (semver.org) based on API
95:    compatibility.  (Note that the shared-library version number will
96:    be different, being based on ABI compatibility.): */
97: #define STRINGIZEx(x) #x
98: #define STRINGIZE(x) STRINGIZEx(x)
99: UTF8PROC_DLLEXPORT const char *utf8proc_version(void) {
100:   return STRINGIZE(UTF8PROC_VERSION_MAJOR) "." STRINGIZE(UTF8PROC_VERSION_MINOR) "." STRINGIZE(UTF8PROC_VERSION_PATCH) "";
101: }
102: 
103: UTF8PROC_DLLEXPORT const char *utf8proc_unicode_version(void) {
104:   return "12.1.0";
105: }
106: 
107: UTF8PROC_DLLEXPORT const char *utf8proc_errmsg(utf8proc_ssize_t errcode) {
108:   switch (errcode) {
109:     case UTF8PROC_ERROR_NOMEM:
110:     return "Memory for processing UTF-8 data could not be allocated.";
111:     case UTF8PROC_ERROR_OVERFLOW:
112:     return "UTF-8 string is too long to be processed.";
113:     case UTF8PROC_ERROR_INVALIDUTF8:
114:     return "Invalid UTF-8 string";
115:     case UTF8PROC_ERROR_NOTASSIGNED:
116:     return "Unassigned Unicode code point found in UTF-8 string.";
117:     case UTF8PROC_ERROR_INVALIDOPTS:
118:     return "Invalid options for UTF-8 processing chosen.";
119:     default:
120:     return "An unknown error occurred while processing UTF-8 data.";
121:   }
122: }
123: 
124: #define utf_cont(ch)  (((ch) & 0xc0) == 0x80)
125: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_iterate(
126:   const utf8proc_uint8_t *str, utf8proc_ssize_t strlen, utf8proc_int32_t *dst
127: ) {
128:   utf8proc_uint32_t uc;
129:   const utf8proc_uint8_t *end;
130: 
131:   *dst = -1;
132:   if (!strlen) return 0;
133:   end = str + ((strlen < 0) ? 4 : strlen);
134:   uc = *str++;
135:   if (uc < 0x80) {
136:     *dst = uc;
137:     return 1;
138:   }
139:   // Must be between 0xc2 and 0xf4 inclusive to be valid
140:   if ((uc - 0xc2) > (0xf4-0xc2)) return UTF8PROC_ERROR_INVALIDUTF8;
141:   if (uc < 0xe0) {         // 2-byte sequence
142:      // Must have valid continuation character
143:      if (str >= end || !utf_cont(*str)) return UTF8PROC_ERROR_INVALIDUTF8;
144:      *dst = ((uc & 0x1f)<<6) | (*str & 0x3f);
145:      return 2;
146:   }
147:   if (uc < 0xf0) {        // 3-byte sequence
148:      if ((str + 1 >= end) || !utf_cont(*str) || !utf_cont(str[1]))
149:         return UTF8PROC_ERROR_INVALIDUTF8;
150:      // Check for surrogate chars
151:      if (uc == 0xed && *str > 0x9f)
152:          return UTF8PROC_ERROR_INVALIDUTF8;
153:      uc = ((uc & 0xf)<<12) | ((*str & 0x3f)<<6) | (str[1] & 0x3f);
154:      if (uc < 0x800)
155:          return UTF8PROC_ERROR_INVALIDUTF8;
156:      *dst = uc;
157:      return 3;
158:   }
159:   // 4-byte sequence
160:   // Must have 3 valid continuation characters
161:   if ((str + 2 >= end) || !utf_cont(*str) || !utf_cont(str[1]) || !utf_cont(str[2]))
162:      return UTF8PROC_ERROR_INVALIDUTF8;
163:   // Make sure in correct range (0x10000 - 0x10ffff)
164:   if (uc == 0xf0) {
165:     if (*str < 0x90) return UTF8PROC_ERROR_INVALIDUTF8;
166:   } else if (uc == 0xf4) {
167:     if (*str > 0x8f) return UTF8PROC_ERROR_INVALIDUTF8;
168:   }
169:   *dst = ((uc & 7)<<18) | ((*str & 0x3f)<<12) | ((str[1] & 0x3f)<<6) | (str[2] & 0x3f);
170:   return 4;
171: }
172: 
173: UTF8PROC_DLLEXPORT utf8proc_bool utf8proc_codepoint_valid(utf8proc_int32_t uc) {
174:     return (((utf8proc_uint32_t)uc)-0xd800 > 0x07ff) && ((utf8proc_uint32_t)uc < 0x110000);
175: }
176: 
177: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_encode_char(utf8proc_int32_t uc, utf8proc_uint8_t *dst) {
178:   if (uc < 0x00) {
179:     return 0;
180:   } else if (uc < 0x80) {
181:     dst[0] = (utf8proc_uint8_t) uc;
182:     return 1;
183:   } else if (uc < 0x800) {
184:     dst[0] = (utf8proc_uint8_t)(0xC0 + (uc >> 6));
185:     dst[1] = (utf8proc_uint8_t)(0x80 + (uc & 0x3F));
186:     return 2;
187:   // Note: we allow encoding 0xd800-0xdfff here, so as not to change
188:   // the API, however, these are actually invalid in UTF-8
189:   } else if (uc < 0x10000) {
190:     dst[0] = (utf8proc_uint8_t)(0xE0 + (uc >> 12));
191:     dst[1] = (utf8proc_uint8_t)(0x80 + ((uc >> 6) & 0x3F));
192:     dst[2] = (utf8proc_uint8_t)(0x80 + (uc & 0x3F));
193:     return 3;
194:   } else if (uc < 0x110000) {
195:     dst[0] = (utf8proc_uint8_t)(0xF0 + (uc >> 18));
196:     dst[1] = (utf8proc_uint8_t)(0x80 + ((uc >> 12) & 0x3F));
197:     dst[2] = (utf8proc_uint8_t)(0x80 + ((uc >> 6) & 0x3F));
198:     dst[3] = (utf8proc_uint8_t)(0x80 + (uc & 0x3F));
199:     return 4;
200:   } else return 0;
201: }
202: 
203: /* internal version used for inserting 0xff bytes between graphemes */
204: static utf8proc_ssize_t charbound_encode_char(utf8proc_int32_t uc, utf8proc_uint8_t *dst) {
205:    if (uc < 0x00) {
206:       if (uc == -1) { /* internal value used for grapheme breaks */
207:         dst[0] = (utf8proc_uint8_t)0xFF;
208:         return 1;
209:       }
210:       return 0;
211:    } else if (uc < 0x80) {
212:       dst[0] = (utf8proc_uint8_t)uc;
213:       return 1;
214:    } else if (uc < 0x800) {
215:       dst[0] = (utf8proc_uint8_t)(0xC0 + (uc >> 6));
216:       dst[1] = (utf8proc_uint8_t)(0x80 + (uc & 0x3F));
217:       return 2;
218:    } else if (uc < 0x10000) {
219:       dst[0] = (utf8proc_uint8_t)(0xE0 + (uc >> 12));
220:       dst[1] = (utf8proc_uint8_t)(0x80 + ((uc >> 6) & 0x3F));
221:       dst[2] = (utf8proc_uint8_t)(0x80 + (uc & 0x3F));
222:       return 3;
223:    } else if (uc < 0x110000) {
224:       dst[0] = (utf8proc_uint8_t)(0xF0 + (uc >> 18));
225:       dst[1] = (utf8proc_uint8_t)(0x80 + ((uc >> 12) & 0x3F));
226:       dst[2] = (utf8proc_uint8_t)(0x80 + ((uc >> 6) & 0x3F));
227:       dst[3] = (utf8proc_uint8_t)(0x80 + (uc & 0x3F));
228:       return 4;
229:    } else return 0;
230: }
231: 
232: /* internal "unsafe" version that does not check whether uc is in range */
233: static const utf8proc_property_t *unsafe_get_property(utf8proc_int32_t uc) {
234:   /* ASSERT: uc >= 0 && uc < 0x110000 */
235:   return utf8proc_properties + (
236:     utf8proc_stage2table[
237:       utf8proc_stage1table[uc >> 8] + (uc & 0xFF)
238:     ]
239:   );
240: }
241: 
242: UTF8PROC_DLLEXPORT const utf8proc_property_t *utf8proc_get_property(utf8proc_int32_t uc) {
243:   return uc < 0 || uc >= 0x110000 ? utf8proc_properties : unsafe_get_property(uc);
244: }
245: 
246: /* return whether there is a grapheme break between boundclasses lbc and tbc
247:    (according to the definition of extended grapheme clusters)
248: 
249:   Rule numbering refers to TR29 Version 29 (Unicode 9.0.0):
250:   http://www.unicode.org/reports/tr29/tr29-29.html
251: 
252:   CAVEATS:
253:    Please note that evaluation of GB10 (grapheme breaks between emoji zwj sequences)
254:    and GB 12/13 (regional indicator code points) require knowledge of previous characters
255:    and are thus not handled by this function. This may result in an incorrect break before
256:    an E_Modifier class codepoint and an incorrectly missing break between two
257:    REGIONAL_INDICATOR class code points if such support does not exist in the caller.
258: 
259:    See the special support in grapheme_break_extended, for required bookkeeping by the caller.
260: */
261: static utf8proc_bool grapheme_break_simple(int lbc, int tbc) {
262:   return
263:     (lbc == UTF8PROC_BOUNDCLASS_START) ? true :       // GB1
264:     (lbc == UTF8PROC_BOUNDCLASS_CR &&                 // GB3
265:      tbc == UTF8PROC_BOUNDCLASS_LF) ? false :         // ---
266:     (lbc >= UTF8PROC_BOUNDCLASS_CR && lbc <= UTF8PROC_BOUNDCLASS_CONTROL) ? true :  // GB4
267:     (tbc >= UTF8PROC_BOUNDCLASS_CR && tbc <= UTF8PROC_BOUNDCLASS_CONTROL) ? true :  // GB5
268:     (lbc == UTF8PROC_BOUNDCLASS_L &&                  // GB6
269:      (tbc == UTF8PROC_BOUNDCLASS_L ||                 // ---
270:       tbc == UTF8PROC_BOUNDCLASS_V ||                 // ---
271:       tbc == UTF8PROC_BOUNDCLASS_LV ||                // ---
272:       tbc == UTF8PROC_BOUNDCLASS_LVT)) ? false :      // ---
273:     ((lbc == UTF8PROC_BOUNDCLASS_LV ||                // GB7
274:       lbc == UTF8PROC_BOUNDCLASS_V) &&                // ---
275:      (tbc == UTF8PROC_BOUNDCLASS_V ||                 // ---
276:       tbc == UTF8PROC_BOUNDCLASS_T)) ? false :        // ---
277:     ((lbc == UTF8PROC_BOUNDCLASS_LVT ||               // GB8
278:       lbc == UTF8PROC_BOUNDCLASS_T) &&                // ---
279:      tbc == UTF8PROC_BOUNDCLASS_T) ? false :          // ---
280:     (tbc == UTF8PROC_BOUNDCLASS_EXTEND ||             // GB9
281:      tbc == UTF8PROC_BOUNDCLASS_ZWJ ||                // ---
282:      tbc == UTF8PROC_BOUNDCLASS_SPACINGMARK ||        // GB9a
283:      lbc == UTF8PROC_BOUNDCLASS_PREPEND) ? false :    // GB9b
284:     (lbc == UTF8PROC_BOUNDCLASS_E_ZWG &&              // GB11 (requires additional handling below)
285:      tbc == UTF8PROC_BOUNDCLASS_EXTENDED_PICTOGRAPHIC) ? false : // ----
286:     (lbc == UTF8PROC_BOUNDCLASS_REGIONAL_INDICATOR &&          // GB12/13 (requires additional handling below)
287:      tbc == UTF8PROC_BOUNDCLASS_REGIONAL_INDICATOR) ? false :  // ----
288:     true; // GB999
289: }
290: 
291: static utf8proc_bool grapheme_break_extended(int lbc, int tbc, utf8proc_int32_t *state)
292: {
293:   int lbc_override = ((state && *state != UTF8PROC_BOUNDCLASS_START)
294:                       ? *state : lbc);
295:   utf8proc_bool break_permitted = grapheme_break_simple(lbc_override, tbc);
296:   if (state) {
297:     // Special support for GB 12/13 made possible by GB999. After two RI
298:     // class codepoints we want to force a break. Do this by resetting the
299:     // second RI's bound class to UTF8PROC_BOUNDCLASS_OTHER, to force a break
300:     // after that character according to GB999 (unless of course such a break is
301:     // forbidden by a different rule such as GB9).
302:     if (*state == tbc && tbc == UTF8PROC_BOUNDCLASS_REGIONAL_INDICATOR)
303:       *state = UTF8PROC_BOUNDCLASS_OTHER;
304:     // Special support for GB11 (emoji extend* zwj / emoji)
305:     else if (*state == UTF8PROC_BOUNDCLASS_EXTENDED_PICTOGRAPHIC) {
306:       if (tbc == UTF8PROC_BOUNDCLASS_EXTEND) // fold EXTEND codepoints into emoji
307:         *state = UTF8PROC_BOUNDCLASS_EXTENDED_PICTOGRAPHIC;
308:       else if (tbc == UTF8PROC_BOUNDCLASS_ZWJ)
309:         *state = UTF8PROC_BOUNDCLASS_E_ZWG; // state to record emoji+zwg combo
310:       else
311:         *state = tbc;
312:     }
313:     else
314:       *state = tbc;
315:   }
316:   return break_permitted;
317: }
318: 
319: UTF8PROC_DLLEXPORT utf8proc_bool utf8proc_grapheme_break_stateful(
320:     utf8proc_int32_t c1, utf8proc_int32_t c2, utf8proc_int32_t *state) {
321: 
322:   return grapheme_break_extended(utf8proc_get_property(c1)->boundclass,
323:                                  utf8proc_get_property(c2)->boundclass,
324:                                  state);
325: }
326: 
327: 
328: UTF8PROC_DLLEXPORT utf8proc_bool utf8proc_grapheme_break(
329:     utf8proc_int32_t c1, utf8proc_int32_t c2) {
330:   return utf8proc_grapheme_break_stateful(c1, c2, NULL);
331: }
332: 
333: static utf8proc_int32_t seqindex_decode_entry(const utf8proc_uint16_t **entry)
334: {
335:   utf8proc_int32_t entry_cp = **entry;
336:   if ((entry_cp & 0xF800) == 0xD800) {
337:     *entry = *entry + 1;
338:     entry_cp = ((entry_cp & 0x03FF) << 10) | (**entry & 0x03FF);
339:     entry_cp += 0x10000;
340:   }
341:   return entry_cp;
342: }
343: 
344: static utf8proc_int32_t seqindex_decode_index(const utf8proc_uint32_t seqindex)
345: {
346:   const utf8proc_uint16_t *entry = &utf8proc_sequences[seqindex];
347:   return seqindex_decode_entry(&entry);
348: }
349: 
350: static utf8proc_ssize_t seqindex_write_char_decomposed(utf8proc_uint16_t seqindex, utf8proc_int32_t *dst, utf8proc_ssize_t bufsize, utf8proc_option_t options, int *last_boundclass) {
351:   utf8proc_ssize_t written = 0;
352:   const utf8proc_uint16_t *entry = &utf8proc_sequences[seqindex & 0x1FFF];
353:   int len = seqindex >> 13;
354:   if (len >= 7) {
355:     len = *entry;
356:     entry++;
357:   }
358:   for (; len >= 0; entry++, len--) {
359:     utf8proc_int32_t entry_cp = seqindex_decode_entry(&entry);
360: 
361:     written += utf8proc_decompose_char(entry_cp, dst+written,
362:       (bufsize > written) ? (bufsize - written) : 0, options,
363:     last_boundclass);
364:     if (written < 0) return UTF8PROC_ERROR_OVERFLOW;
365:   }
366:   return written;
367: }
368: 
369: UTF8PROC_DLLEXPORT utf8proc_int32_t utf8proc_tolower(utf8proc_int32_t c)
370: {
371:   utf8proc_int32_t cl = utf8proc_get_property(c)->lowercase_seqindex;
372:   return cl != UINT16_MAX ? seqindex_decode_index(cl) : c;
373: }
374: 
375: UTF8PROC_DLLEXPORT utf8proc_int32_t utf8proc_toupper(utf8proc_int32_t c)
376: {
377:   utf8proc_int32_t cu = utf8proc_get_property(c)->uppercase_seqindex;
378:   return cu != UINT16_MAX ? seqindex_decode_index(cu) : c;
379: }
380: 
381: UTF8PROC_DLLEXPORT utf8proc_int32_t utf8proc_totitle(utf8proc_int32_t c)
382: {
383:   utf8proc_int32_t cu = utf8proc_get_property(c)->titlecase_seqindex;
384:   return cu != UINT16_MAX ? seqindex_decode_index(cu) : c;
385: }
386: 
387: /* return a character width analogous to wcwidth (except portable and
388:    hopefully less buggy than most system wcwidth functions). */
389: UTF8PROC_DLLEXPORT int utf8proc_charwidth(utf8proc_int32_t c) {
390:   return utf8proc_get_property(c)->charwidth;
391: }
392: 
393: UTF8PROC_DLLEXPORT utf8proc_category_t utf8proc_category(utf8proc_int32_t c) {
394:   return (utf8proc_category_t)utf8proc_get_property(c)->category;
395: }
396: 
397: UTF8PROC_DLLEXPORT const char *utf8proc_category_string(utf8proc_int32_t c) {
398:   static const char s[][3] = {"Cn","Lu","Ll","Lt","Lm","Lo","Mn","Mc","Me","Nd","Nl","No","Pc","Pd","Ps","Pe","Pi","Pf","Po","Sm","Sc","Sk","So","Zs","Zl","Zp","Cc","Cf","Cs","Co"};
399:   return s[utf8proc_category(c)];
400: }
401: 
402: #define utf8proc_decompose_lump(replacement_uc) \
403:   return utf8proc_decompose_char((replacement_uc), dst, bufsize, \
404:   (utf8proc_option_t) (options & ~UTF8PROC_LUMP), last_boundclass)
405: 
406: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_decompose_char(utf8proc_int32_t uc, utf8proc_int32_t *dst, utf8proc_ssize_t bufsize, utf8proc_option_t options, int *last_boundclass) {
407:   const utf8proc_property_t *property;
408:   utf8proc_propval_t category;
409:   utf8proc_int32_t hangul_sindex;
410:   if (uc < 0 || uc >= 0x110000) return UTF8PROC_ERROR_NOTASSIGNED;
411:   property = unsafe_get_property(uc);
412:   category = property->category;
413:   hangul_sindex = uc - UTF8PROC_HANGUL_SBASE;
414:   if (options & (UTF8PROC_COMPOSE|UTF8PROC_DECOMPOSE)) {
415:     if (hangul_sindex >= 0 && hangul_sindex < UTF8PROC_HANGUL_SCOUNT) {
416:       utf8proc_int32_t hangul_tindex;
417:       if (bufsize >= 1) {
418:         dst[0] = UTF8PROC_HANGUL_LBASE +
419:           hangul_sindex / UTF8PROC_HANGUL_NCOUNT;
420:         if (bufsize >= 2) dst[1] = UTF8PROC_HANGUL_VBASE +
421:           (hangul_sindex % UTF8PROC_HANGUL_NCOUNT) / UTF8PROC_HANGUL_TCOUNT;
422:       }
423:       hangul_tindex = hangul_sindex % UTF8PROC_HANGUL_TCOUNT;
424:       if (!hangul_tindex) return 2;
425:       if (bufsize >= 3) dst[2] = UTF8PROC_HANGUL_TBASE + hangul_tindex;
426:       return 3;
427:     }
428:   }
429:   if (options & UTF8PROC_REJECTNA) {
430:     if (!category) return UTF8PROC_ERROR_NOTASSIGNED;
431:   }
432:   if (options & UTF8PROC_IGNORE) {
433:     if (property->ignorable) return 0;
434:   }
435:   if (options & UTF8PROC_STRIPNA) {
436:     if (!category) return 0;
437:   }
438:   if (options & UTF8PROC_LUMP) {
439:     if (category == UTF8PROC_CATEGORY_ZS) utf8proc_decompose_lump(0x0020);
440:     if (uc == 0x2018 || uc == 0x2019 || uc == 0x02BC || uc == 0x02C8)
441:       utf8proc_decompose_lump(0x0027);
442:     if (category == UTF8PROC_CATEGORY_PD || uc == 0x2212)
443:       utf8proc_decompose_lump(0x002D);
444:     if (uc == 0x2044 || uc == 0x2215) utf8proc_decompose_lump(0x002F);
445:     if (uc == 0x2236) utf8proc_decompose_lump(0x003A);
446:     if (uc == 0x2039 || uc == 0x2329 || uc == 0x3008)
447:       utf8proc_decompose_lump(0x003C);
448:     if (uc == 0x203A || uc == 0x232A || uc == 0x3009)
449:       utf8proc_decompose_lump(0x003E);
450:     if (uc == 0x2216) utf8proc_decompose_lump(0x005C);
451:     if (uc == 0x02C4 || uc == 0x02C6 || uc == 0x2038 || uc == 0x2303)
452:       utf8proc_decompose_lump(0x005E);
453:     if (category == UTF8PROC_CATEGORY_PC || uc == 0x02CD)
454:       utf8proc_decompose_lump(0x005F);
455:     if (uc == 0x02CB) utf8proc_decompose_lump(0x0060);
456:     if (uc == 0x2223) utf8proc_decompose_lump(0x007C);
457:     if (uc == 0x223C) utf8proc_decompose_lump(0x007E);
458:     if ((options & UTF8PROC_NLF2LS) && (options & UTF8PROC_NLF2PS)) {
459:       if (category == UTF8PROC_CATEGORY_ZL ||
460:           category == UTF8PROC_CATEGORY_ZP)
461:         utf8proc_decompose_lump(0x000A);
462:     }
463:   }
464:   if (options & UTF8PROC_STRIPMARK) {
465:     if (category == UTF8PROC_CATEGORY_MN ||
466:       category == UTF8PROC_CATEGORY_MC ||
467:       category == UTF8PROC_CATEGORY_ME) return 0;
468:   }
469:   if (options & UTF8PROC_CASEFOLD) {
470:     if (property->casefold_seqindex != UINT16_MAX) {
471:       return seqindex_write_char_decomposed(property->casefold_seqindex, dst, bufsize, options, last_boundclass);
472:     }
473:   }
474:   if (options & (UTF8PROC_COMPOSE|UTF8PROC_DECOMPOSE)) {
475:     if (property->decomp_seqindex != UINT16_MAX &&
476:         (!property->decomp_type || (options & UTF8PROC_COMPAT))) {
477:       return seqindex_write_char_decomposed(property->decomp_seqindex, dst, bufsize, options, last_boundclass);
478:     }
479:   }
480:   if (options & UTF8PROC_CHARBOUND) {
481:     utf8proc_bool boundary;
482:     int tbc = property->boundclass;
483:     boundary = grapheme_break_extended(*last_boundclass, tbc, last_boundclass);
484:     if (boundary) {
485:       if (bufsize >= 1) dst[0] = -1; /* sentinel value for grapheme break */
486:       if (bufsize >= 2) dst[1] = uc;
487:       return 2;
488:     }
489:   }
490:   if (bufsize >= 1) *dst = uc;
491:   return 1;
492: }
493: 
494: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_decompose(
495:   const utf8proc_uint8_t *str, utf8proc_ssize_t strlen,
496:   utf8proc_int32_t *buffer, utf8proc_ssize_t bufsize, utf8proc_option_t options
497: ) {
498:     return utf8proc_decompose_custom(str, strlen, buffer, bufsize, options, NULL, NULL);
499: }
500: 
501: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_decompose_custom(
502:   const utf8proc_uint8_t *str, utf8proc_ssize_t strlen,
503:   utf8proc_int32_t *buffer, utf8proc_ssize_t bufsize, utf8proc_option_t options,
504:   utf8proc_custom_func custom_func, void *custom_data
505: ) {
506:   /* strlen will be ignored, if UTF8PROC_NULLTERM is set in options */
507:   utf8proc_ssize_t wpos = 0;
508:   if ((options & UTF8PROC_COMPOSE) && (options & UTF8PROC_DECOMPOSE))
509:     return UTF8PROC_ERROR_INVALIDOPTS;
510:   if ((options & UTF8PROC_STRIPMARK) &&
511:       !(options & UTF8PROC_COMPOSE) && !(options & UTF8PROC_DECOMPOSE))
512:     return UTF8PROC_ERROR_INVALIDOPTS;
513:   {
514:     utf8proc_int32_t uc;
515:     utf8proc_ssize_t rpos = 0;
516:     utf8proc_ssize_t decomp_result;
517:     int boundclass = UTF8PROC_BOUNDCLASS_START;
518:     while (1) {
519:       if (options & UTF8PROC_NULLTERM) {
520:         rpos += utf8proc_iterate(str + rpos, -1, &uc);
521:         /* checking of return value is not necessary,
522:            as 'uc' is < 0 in case of error */
523:         if (uc < 0) return UTF8PROC_ERROR_INVALIDUTF8;
524:         if (rpos < 0) return UTF8PROC_ERROR_OVERFLOW;
525:         if (uc == 0) break;
526:       } else {
527:         if (rpos >= strlen) break;
528:         rpos += utf8proc_iterate(str + rpos, strlen - rpos, &uc);
529:         if (uc < 0) return UTF8PROC_ERROR_INVALIDUTF8;
530:       }
531:       if (custom_func != NULL) {
532:         uc = custom_func(uc, custom_data);   /* user-specified custom mapping */
533:       }
534:       decomp_result = utf8proc_decompose_char(
535:         uc, buffer + wpos, (bufsize > wpos) ? (bufsize - wpos) : 0, options,
536:         &boundclass
537:       );
538:       if (decomp_result < 0) return decomp_result;
539:       wpos += decomp_result;
540:       /* prohibiting integer overflows due to too long strings: */
541:       if (wpos < 0 ||
542:           wpos > (utf8proc_ssize_t)(SSIZE_MAX/sizeof(utf8proc_int32_t)/2))
543:         return UTF8PROC_ERROR_OVERFLOW;
544:     }
545:   }
546:   if ((options & (UTF8PROC_COMPOSE|UTF8PROC_DECOMPOSE)) && bufsize >= wpos) {
547:     utf8proc_ssize_t pos = 0;
548:     while (pos < wpos-1) {
549:       utf8proc_int32_t uc1, uc2;
550:       const utf8proc_property_t *property1, *property2;
551:       uc1 = buffer[pos];
552:       uc2 = buffer[pos+1];
553:       property1 = unsafe_get_property(uc1);
554:       property2 = unsafe_get_property(uc2);
555:       if (property1->combining_class > property2->combining_class &&
556:           property2->combining_class > 0) {
557:         buffer[pos] = uc2;
558:         buffer[pos+1] = uc1;
559:         if (pos > 0) pos--; else pos++;
560:       } else {
561:         pos++;
562:       }
563:     }
564:   }
565:   return wpos;
566: }
567: 
568: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_normalize_utf32(utf8proc_int32_t *buffer, utf8proc_ssize_t length, utf8proc_option_t options) {
569:   /* UTF8PROC_NULLTERM option will be ignored, 'length' is never ignored */
570:   if (options & (UTF8PROC_NLF2LS | UTF8PROC_NLF2PS | UTF8PROC_STRIPCC)) {
571:     utf8proc_ssize_t rpos;
572:     utf8proc_ssize_t wpos = 0;
573:     utf8proc_int32_t uc;
574:     for (rpos = 0; rpos < length; rpos++) {
575:       uc = buffer[rpos];
576:       if (uc == 0x000D && rpos < length-1 && buffer[rpos+1] == 0x000A) rpos++;
577:       if (uc == 0x000A || uc == 0x000D || uc == 0x0085 ||
578:           ((options & UTF8PROC_STRIPCC) && (uc == 0x000B || uc == 0x000C))) {
579:         if (options & UTF8PROC_NLF2LS) {
580:           if (options & UTF8PROC_NLF2PS) {
581:             buffer[wpos++] = 0x000A;
582:           } else {
583:             buffer[wpos++] = 0x2028;
584:           }
585:         } else {
586:           if (options & UTF8PROC_NLF2PS) {
587:             buffer[wpos++] = 0x2029;
588:           } else {
589:             buffer[wpos++] = 0x0020;
590:           }
591:         }
592:       } else if ((options & UTF8PROC_STRIPCC) &&
593:           (uc < 0x0020 || (uc >= 0x007F && uc < 0x00A0))) {
594:         if (uc == 0x0009) buffer[wpos++] = 0x0020;
595:       } else {
596:         buffer[wpos++] = uc;
597:       }
598:     }
599:     length = wpos;
600:   }
601:   if (options & UTF8PROC_COMPOSE) {
602:     utf8proc_int32_t *starter = NULL;
603:     utf8proc_int32_t current_char;
604:     const utf8proc_property_t *starter_property = NULL, *current_property;
605:     utf8proc_propval_t max_combining_class = -1;
606:     utf8proc_ssize_t rpos;
607:     utf8proc_ssize_t wpos = 0;
608:     utf8proc_int32_t composition;
609:     for (rpos = 0; rpos < length; rpos++) {
610:       current_char = buffer[rpos];
611:       current_property = unsafe_get_property(current_char);
612:       if (starter && current_property->combining_class > max_combining_class) {
613:         /* combination perhaps possible */
614:         utf8proc_int32_t hangul_lindex;
615:         utf8proc_int32_t hangul_sindex;
616:         hangul_lindex = *starter - UTF8PROC_HANGUL_LBASE;
617:         if (hangul_lindex >= 0 && hangul_lindex < UTF8PROC_HANGUL_LCOUNT) {
618:           utf8proc_int32_t hangul_vindex;
619:           hangul_vindex = current_char - UTF8PROC_HANGUL_VBASE;
620:           if (hangul_vindex >= 0 && hangul_vindex < UTF8PROC_HANGUL_VCOUNT) {
621:             *starter = UTF8PROC_HANGUL_SBASE +
622:               (hangul_lindex * UTF8PROC_HANGUL_VCOUNT + hangul_vindex) *
623:               UTF8PROC_HANGUL_TCOUNT;
624:             starter_property = NULL;
625:             continue;
626:           }
627:         }
628:         hangul_sindex = *starter - UTF8PROC_HANGUL_SBASE;
629:         if (hangul_sindex >= 0 && hangul_sindex < UTF8PROC_HANGUL_SCOUNT &&
630:             (hangul_sindex % UTF8PROC_HANGUL_TCOUNT) == 0) {
631:           utf8proc_int32_t hangul_tindex;
632:           hangul_tindex = current_char - UTF8PROC_HANGUL_TBASE;
633:           if (hangul_tindex >= 0 && hangul_tindex < UTF8PROC_HANGUL_TCOUNT) {
634:             *starter += hangul_tindex;
635:             starter_property = NULL;
636:             continue;
637:           }
638:         }
639:         if (!starter_property) {
640:           starter_property = unsafe_get_property(*starter);
641:         }
642:         if (starter_property->comb_index < 0x8000 &&
643:             current_property->comb_index != UINT16_MAX &&
644:             current_property->comb_index >= 0x8000) {
645:           int sidx = starter_property->comb_index;
646:           int idx = current_property->comb_index & 0x3FFF;
647:           if (idx >= utf8proc_combinations[sidx] && idx <= utf8proc_combinations[sidx + 1] ) {
648:             idx += sidx + 2 - utf8proc_combinations[sidx];
649:             if (current_property->comb_index & 0x4000) {
650:               composition = (utf8proc_combinations[idx] << 16) | utf8proc_combinations[idx+1];
651:             } else
652:               composition = utf8proc_combinations[idx];
653: 
654:             if (composition > 0 && (!(options & UTF8PROC_STABLE) ||
655:                 !(unsafe_get_property(composition)->comp_exclusion))) {
656:               *starter = composition;
657:               starter_property = NULL;
658:               continue;
659:             }
660:           }
661:         }
662:       }
663:       buffer[wpos] = current_char;
664:       if (current_property->combining_class) {
665:         if (current_property->combining_class > max_combining_class) {
666:           max_combining_class = current_property->combining_class;
667:         }
668:       } else {
669:         starter = buffer + wpos;
670:         starter_property = NULL;
671:         max_combining_class = -1;
672:       }
673:       wpos++;
674:     }
675:     length = wpos;
676:   }
677:   return length;
678: }
679: 
680: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_reencode(utf8proc_int32_t *buffer, utf8proc_ssize_t length, utf8proc_option_t options) {
681:   /* UTF8PROC_NULLTERM option will be ignored, 'length' is never ignored
682:      ASSERT: 'buffer' has one spare byte of free space at the end! */
683:   length = utf8proc_normalize_utf32(buffer, length, options);
684:   if (length < 0) return length;
685:   {
686:     utf8proc_ssize_t rpos, wpos = 0;
687:     utf8proc_int32_t uc;
688:     if (options & UTF8PROC_CHARBOUND) {
689:         for (rpos = 0; rpos < length; rpos++) {
690:             uc = buffer[rpos];
691:             wpos += charbound_encode_char(uc, ((utf8proc_uint8_t *)buffer) + wpos);
692:         }
693:     } else {
694:         for (rpos = 0; rpos < length; rpos++) {
695:             uc = buffer[rpos];
696:             wpos += utf8proc_encode_char(uc, ((utf8proc_uint8_t *)buffer) + wpos);
697:         }
698:     }
699:     ((utf8proc_uint8_t *)buffer)[wpos] = 0;
700:     return wpos;
701:   }
702: }
703: 
704: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_map(
705:   const utf8proc_uint8_t *str, utf8proc_ssize_t strlen, utf8proc_uint8_t **dstptr, utf8proc_option_t options
706: ) {
707:     return utf8proc_map_custom(str, strlen, dstptr, options, NULL, NULL);
708: }
709: 
710: UTF8PROC_DLLEXPORT utf8proc_ssize_t utf8proc_map_custom(
711:   const utf8proc_uint8_t *str, utf8proc_ssize_t strlen, utf8proc_uint8_t **dstptr, utf8proc_option_t options,
712:   utf8proc_custom_func custom_func, void *custom_data
713: ) {
714:   utf8proc_int32_t *buffer;
715:   utf8proc_ssize_t result;
716:   *dstptr = NULL;
717:   result = utf8proc_decompose_custom(str, strlen, NULL, 0, options, custom_func, custom_data);
718:   if (result < 0) return result;
719:   buffer = (utf8proc_int32_t *) malloc(result * sizeof(utf8proc_int32_t) + 1);
720:   if (!buffer) return UTF8PROC_ERROR_NOMEM;
721:   result = utf8proc_decompose_custom(str, strlen, buffer, result, options, custom_func, custom_data);
722:   if (result < 0) {
723:     free(buffer);
724:     return result;
725:   }
726:   result = utf8proc_reencode(buffer, result, options);
727:   if (result < 0) {
728:     free(buffer);
729:     return result;
730:   }
731:   {
732:     utf8proc_int32_t *newptr;
733:     newptr = (utf8proc_int32_t *) realloc(buffer, (size_t)result+1);
734:     if (newptr) buffer = newptr;
735:   }
736:   *dstptr = (utf8proc_uint8_t *)buffer;
737:   return result;
738: }
739: 
740: UTF8PROC_DLLEXPORT utf8proc_uint8_t *utf8proc_NFD(const utf8proc_uint8_t *str) {
741:   utf8proc_uint8_t *retval;
742:   utf8proc_map(str, 0, &retval, (utf8proc_option_t)(UTF8PROC_NULLTERM | UTF8PROC_STABLE |
743:     UTF8PROC_DECOMPOSE));
744:   return retval;
745: }
746: 
747: UTF8PROC_DLLEXPORT utf8proc_uint8_t *utf8proc_NFC(const utf8proc_uint8_t *str) {
748:   utf8proc_uint8_t *retval;
749:   utf8proc_map(str, 0, &retval, (utf8proc_option_t)(UTF8PROC_NULLTERM | UTF8PROC_STABLE |
750:     UTF8PROC_COMPOSE));
751:   return retval;
752: }
753: 
754: UTF8PROC_DLLEXPORT utf8proc_uint8_t *utf8proc_NFKD(const utf8proc_uint8_t *str) {
755:   utf8proc_uint8_t *retval;
756:   utf8proc_map(str, 0, &retval, (utf8proc_option_t)(UTF8PROC_NULLTERM | UTF8PROC_STABLE |
757:     UTF8PROC_DECOMPOSE | UTF8PROC_COMPAT));
758:   return retval;
759: }
760: 
761: UTF8PROC_DLLEXPORT utf8proc_uint8_t *utf8proc_NFKC(const utf8proc_uint8_t *str) {
762:   utf8proc_uint8_t *retval;
763:   utf8proc_map(str, 0, &retval, (utf8proc_option_t)(UTF8PROC_NULLTERM | UTF8PROC_STABLE |
764:     UTF8PROC_COMPOSE | UTF8PROC_COMPAT));
765:   return retval;
766: }
767: 
768: UTF8PROC_DLLEXPORT utf8proc_uint8_t *utf8proc_NFKC_Casefold(const utf8proc_uint8_t *str) {
769:   utf8proc_uint8_t *retval;
770:   utf8proc_map(str, 0, &retval, (utf8proc_option_t)(UTF8PROC_NULLTERM | UTF8PROC_STABLE |
771:     UTF8PROC_COMPOSE | UTF8PROC_COMPAT | UTF8PROC_CASEFOLD | UTF8PROC_IGNORE));
772:   return retval;
773: }
[end of third_party/utf8proc/utf8proc.cpp]
[start of third_party/utf8proc/utf8proc_wrapper.cpp]
1: #include "utf8proc_wrapper.hpp"
2: #include "utf8proc.hpp"
3: 
4: using namespace duckdb;
5: using namespace std;
6: 
7: // This function efficiently checks if a string is valid UTF8.
8: // It was originally written by Sjoerd Mullender.
9: 
10: // Here is the table that makes it work:
11: 
12: // B 		= Number of Bytes in UTF8 encoding
13: // C_MIN 	= First Unicode code point
14: // C_MAX 	= Last Unicode code point
15: // B1 		= First Byte Prefix
16: 
17: // 	B	C_MIN		C_MAX		B1
18: //	1	U+000000	U+00007F		0xxxxxxx
19: //	2	U+000080	U+0007FF		110xxxxx
20: //	3	U+000800	U+00FFFF		1110xxxx
21: //	4	U+010000	U+10FFFF		11110xxx
22: 
23: UnicodeType Utf8Proc::Analyze(const char *s, size_t len) {
24: 	UnicodeType type = UnicodeType::ASCII;
25: 	char c;
26: 	for (size_t i = 0; i < len; i++) {
27: 		c = s[i];
28: 		// 1 Byte / ASCII
29: 		if ((c & 0x80) == 0)
30: 			continue;
31: 		type = UnicodeType::UNICODE;
32: 		if ((s[++i] & 0xC0) != 0x80)
33: 			return UnicodeType::INVALID;
34: 		if ((c & 0xE0) == 0xC0)
35: 			continue;
36: 		if ((s[++i] & 0xC0) != 0x80)
37: 			return UnicodeType::INVALID;
38: 		if ((c & 0xF0) == 0xE0)
39: 			continue;
40: 		if ((s[++i] & 0xC0) != 0x80)
41: 			return UnicodeType::INVALID;
42: 		if ((c & 0xF8) == 0xF0)
43: 			continue;
44: 		return UnicodeType::INVALID;
45: 	}
46: 
47: 	return type;
48: }
49: 
50: 
51: std::string Utf8Proc::Normalize(std::string s) {
52: 	auto normalized = Normalize(s.c_str());
53: 	auto res = std::string(normalized);
54: 	free(normalized);
55: 	return res;
56: }
57: ;
58: 
59: char* Utf8Proc::Normalize(const char *s) {
60: 	assert(s);
61: 	assert(Utf8Proc::Analyze(s) != UnicodeType::INVALID);
62: 	return (char*) utf8proc_NFC((const utf8proc_uint8_t*) s);
63: }
64: ;
65: 
66: ;
[end of third_party/utf8proc/utf8proc_wrapper.cpp]
[start of tools/shell/CMakeLists.txt]
1: add_definitions(-DSQLITE_OMIT_LOAD_EXTENSION=1)
2: 
3: SET (SHELL_SOURCES shell.c)
4: if(NOT WIN32)
5: 	add_definitions(-DHAVE_LINENOISE=1)
6: 	SET (SHELL_SOURCES ${SHELL_SOURCES} linenoise.c)
7: endif()
8: 
9: include_directories(include)
10: include_directories(../sqlite3_api_wrapper/include)
11: add_executable(shell ${SHELL_SOURCES})
12: target_link_libraries(shell sqlite3_api_wrapper_static)
13: set_target_properties(shell PROPERTIES OUTPUT_NAME duckdb_cli)
14: set_target_properties(shell PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
[end of tools/shell/CMakeLists.txt]
[start of tools/shell/linenoise.c]
1: /* linenoise.c -- guerrilla line editing library against the idea that a
2:  * line editing lib needs to be 20,000 lines of C code.
3:  *
4:  * You can find the latest source code at:
5:  *
6:  *   http://github.com/antirez/linenoise
7:  *
8:  * Does a number of crazy assumptions that happen to be true in 99.9999% of
9:  * the 2010 UNIX computers around.
10:  *
11:  * ------------------------------------------------------------------------
12:  *
13:  * Copyright (c) 2010-2016, Salvatore Sanfilippo <antirez at gmail dot com>
14:  * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>
15:  *
16:  * All rights reserved.
17:  *
18:  * Redistribution and use in source and binary forms, with or without
19:  * modification, are permitted provided that the following conditions are
20:  * met:
21:  *
22:  *  *  Redistributions of source code must retain the above copyright
23:  *     notice, this list of conditions and the following disclaimer.
24:  *
25:  *  *  Redistributions in binary form must reproduce the above copyright
26:  *     notice, this list of conditions and the following disclaimer in the
27:  *     documentation and/or other materials provided with the distribution.
28:  *
29:  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
30:  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
31:  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
32:  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
33:  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
34:  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
35:  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
36:  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
37:  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
38:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
39:  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
40:  *
41:  * ------------------------------------------------------------------------
42:  *
43:  * References:
44:  * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
45:  * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html
46:  *
47:  * Todo list:
48:  * - Filter bogus Ctrl+<char> combinations.
49:  * - Win32 support
50:  *
51:  * Bloat:
52:  * - History search like Ctrl+r in readline?
53:  *
54:  * List of escape sequences used by this program, we do everything just
55:  * with three sequences. In order to be so cheap we may have some
56:  * flickering effect with some slow terminal, but the lesser sequences
57:  * the more compatible.
58:  *
59:  * EL (Erase Line)
60:  *    Sequence: ESC [ n K
61:  *    Effect: if n is 0 or missing, clear from cursor to end of line
62:  *    Effect: if n is 1, clear from beginning of line to cursor
63:  *    Effect: if n is 2, clear entire line
64:  *
65:  * CUF (CUrsor Forward)
66:  *    Sequence: ESC [ n C
67:  *    Effect: moves cursor forward n chars
68:  *
69:  * CUB (CUrsor Backward)
70:  *    Sequence: ESC [ n D
71:  *    Effect: moves cursor backward n chars
72:  *
73:  * The following is used to get the terminal width if getting
74:  * the width with the TIOCGWINSZ ioctl fails
75:  *
76:  * DSR (Device Status Report)
77:  *    Sequence: ESC [ 6 n
78:  *    Effect: reports the current cusor position as ESC [ n ; m R
79:  *            where n is the row and m is the column
80:  *
81:  * When multi line mode is enabled, we also use an additional escape
82:  * sequence. However multi line editing is disabled by default.
83:  *
84:  * CUU (Cursor Up)
85:  *    Sequence: ESC [ n A
86:  *    Effect: moves cursor up of n chars.
87:  *
88:  * CUD (Cursor Down)
89:  *    Sequence: ESC [ n B
90:  *    Effect: moves cursor down of n chars.
91:  *
92:  * When linenoiseClearScreen() is called, two additional escape sequences
93:  * are used in order to clear the screen and position the cursor at home
94:  * position.
95:  *
96:  * CUP (Cursor position)
97:  *    Sequence: ESC [ H
98:  *    Effect: moves the cursor to upper left corner
99:  *
100:  * ED (Erase display)
101:  *    Sequence: ESC [ 2 J
102:  *    Effect: clear the whole screen
103:  *
104:  */
105: 
106: #include <termios.h>
107: #include <unistd.h>
108: #include <stdlib.h>
109: #include <stdio.h>
110: #include <errno.h>
111: #include <string.h>
112: #include <stdlib.h>
113: #include <ctype.h>
114: #include <sys/stat.h>
115: #include <sys/types.h>
116: #include <sys/ioctl.h>
117: #include <unistd.h>
118: #include "linenoise.h"
119: 
120: #define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100
121: #define LINENOISE_MAX_LINE 4096
122: static char *unsupported_term[] = {"dumb", "cons25", "emacs", NULL};
123: static linenoiseCompletionCallback *completionCallback = NULL;
124: static linenoiseHintsCallback *hintsCallback = NULL;
125: static linenoiseFreeHintsCallback *freeHintsCallback = NULL;
126: 
127: static struct termios orig_termios; /* In order to restore at exit.*/
128: static int rawmode = 0;             /* For atexit() function to check if restore is needed*/
129: static int mlmode = 0;              /* Multi line mode. Default is single line. */
130: static int atexit_registered = 0;   /* Register atexit just 1 time. */
131: static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;
132: static int history_len = 0;
133: static char **history = NULL;
134: 
135: /* The linenoiseState structure represents the state during line editing.
136:  * We pass this state to functions implementing specific editing
137:  * functionalities. */
138: struct linenoiseState {
139: 	int ifd;            /* Terminal stdin file descriptor. */
140: 	int ofd;            /* Terminal stdout file descriptor. */
141: 	char *buf;          /* Edited line buffer. */
142: 	size_t buflen;      /* Edited line buffer size. */
143: 	const char *prompt; /* Prompt to display. */
144: 	size_t plen;        /* Prompt length. */
145: 	size_t pos;         /* Current cursor position. */
146: 	size_t oldpos;      /* Previous refresh cursor position. */
147: 	size_t len;         /* Current edited line length. */
148: 	size_t cols;        /* Number of columns in terminal. */
149: 	size_t maxrows;     /* Maximum num of rows used so far (multiline mode) */
150: 	int history_index;  /* The history index we are currently editing. */
151: };
152: 
153: enum KEY_ACTION {
154: 	KEY_NULL = 0,   /* NULL */
155: 	CTRL_A = 1,     /* Ctrl+a */
156: 	CTRL_B = 2,     /* Ctrl-b */
157: 	CTRL_C = 3,     /* Ctrl-c */
158: 	CTRL_D = 4,     /* Ctrl-d */
159: 	CTRL_E = 5,     /* Ctrl-e */
160: 	CTRL_F = 6,     /* Ctrl-f */
161: 	CTRL_H = 8,     /* Ctrl-h */
162: 	TAB = 9,        /* Tab */
163: 	CTRL_K = 11,    /* Ctrl+k */
164: 	CTRL_L = 12,    /* Ctrl+l */
165: 	ENTER = 13,     /* Enter */
166: 	CTRL_N = 14,    /* Ctrl-n */
167: 	CTRL_P = 16,    /* Ctrl-p */
168: 	CTRL_T = 20,    /* Ctrl-t */
169: 	CTRL_U = 21,    /* Ctrl+u */
170: 	CTRL_W = 23,    /* Ctrl+w */
171: 	ESC = 27,       /* Escape */
172: 	BACKSPACE = 127 /* Backspace */
173: };
174: 
175: static void linenoiseAtExit(void);
176: int linenoiseHistoryAdd(const char *line);
177: static void refreshLine(struct linenoiseState *l);
178: 
179: /* Debugging macro. */
180: #if 0
181: FILE *lndebug_fp = NULL;
182: #define lndebug(...)                                                                                                   \
183: 	do {                                                                                                               \
184: 		if (lndebug_fp == NULL) {                                                                                      \
185: 			lndebug_fp = fopen("/tmp/lndebug.txt", "a");                                                               \
186: 			fprintf(lndebug_fp, "[%d %d %d] p: %d, rows: %d, rpos: %d, max: %d, oldmax: %d\n", (int)l->len,            \
187: 			        (int)l->pos, (int)l->oldpos, plen, rows, rpos, (int)l->maxrows, old_rows);                         \
188: 		}                                                                                                              \
189: 		fprintf(lndebug_fp, ", " __VA_ARGS__);                                                                         \
190: 		fflush(lndebug_fp);                                                                                            \
191: 	} while (0)
192: #else
193: #define lndebug(fmt, ...)
194: #endif
195: 
196: /* ======================= Low level terminal handling ====================== */
197: 
198: /* Set if to use or not the multi line mode. */
199: void linenoiseSetMultiLine(int ml) {
200: 	mlmode = ml;
201: }
202: 
203: /* Return true if the terminal name is in the list of terminals we know are
204:  * not able to understand basic escape sequences. */
205: static int isUnsupportedTerm(void) {
206: 	char *term = getenv("TERM");
207: 	int j;
208: 
209: 	if (term == NULL)
210: 		return 0;
211: 	for (j = 0; unsupported_term[j]; j++)
212: 		if (!strcasecmp(term, unsupported_term[j]))
213: 			return 1;
214: 	return 0;
215: }
216: 
217: /* Raw mode: 1960 magic shit. */
218: static int enableRawMode(int fd) {
219: 	struct termios raw;
220: 
221: 	if (!isatty(STDIN_FILENO))
222: 		goto fatal;
223: 	if (!atexit_registered) {
224: 		atexit(linenoiseAtExit);
225: 		atexit_registered = 1;
226: 	}
227: 	if (tcgetattr(fd, &orig_termios) == -1)
228: 		goto fatal;
229: 
230: 	raw = orig_termios; /* modify the original mode */
231: 	/* input modes: no break, no CR to NL, no parity check, no strip char,
232: 	 * no start/stop output control. */
233: 	raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
234: 	/* output modes - disable post processing */
235: 	raw.c_oflag &= ~(OPOST);
236: 	/* control modes - set 8 bit chars */
237: 	raw.c_cflag |= (CS8);
238: 	/* local modes - choing off, canonical off, no extended functions,
239: 	 * no signal chars (^Z,^C) */
240: 	raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
241: 	/* control chars - set return condition: min number of bytes and timer.
242: 	 * We want read to return every single byte, without timeout. */
243: 	raw.c_cc[VMIN] = 1;
244: 	raw.c_cc[VTIME] = 0; /* 1 byte, no timer */
245: 
246: 	/* put terminal in raw mode after flushing */
247: 	if (tcsetattr(fd, TCSADRAIN, &raw) < 0)
248: 		goto fatal;
249: 	rawmode = 1;
250: 	return 0;
251: 
252: fatal:
253: 	errno = ENOTTY;
254: 	return -1;
255: }
256: 
257: static void disableRawMode(int fd) {
258: 	/* Don't even check the return value as it's too late. */
259: 	if (rawmode && tcsetattr(fd, TCSADRAIN, &orig_termios) != -1)
260: 		rawmode = 0;
261: }
262: 
263: /* Use the ESC [6n escape sequence to query the horizontal cursor position
264:  * and return it. On error -1 is returned, on success the position of the
265:  * cursor. */
266: static int getCursorPosition(int ifd, int ofd) {
267: 	char buf[32];
268: 	int cols, rows;
269: 	unsigned int i = 0;
270: 
271: 	/* Report cursor location */
272: 	if (write(ofd, "\x1b[6n", 4) != 4)
273: 		return -1;
274: 
275: 	/* Read the response: ESC [ rows ; cols R */
276: 	while (i < sizeof(buf) - 1) {
277: 		if (read(ifd, buf + i, 1) != 1)
278: 			break;
279: 		if (buf[i] == 'R')
280: 			break;
281: 		i++;
282: 	}
283: 	buf[i] = '\0';
284: 
285: 	/* Parse it. */
286: 	if (buf[0] != ESC || buf[1] != '[')
287: 		return -1;
288: 	if (sscanf(buf + 2, "%d;%d", &rows, &cols) != 2)
289: 		return -1;
290: 	return cols;
291: }
292: 
293: /* Try to get the number of columns in the current terminal, or assume 80
294:  * if it fails. */
295: static int getColumns(int ifd, int ofd) {
296: 	struct winsize ws;
297: 
298: 	if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {
299: 		/* ioctl() failed. Try to query the terminal itself. */
300: 		int start, cols;
301: 
302: 		/* Get the initial position so we can restore it later. */
303: 		start = getCursorPosition(ifd, ofd);
304: 		if (start == -1)
305: 			goto failed;
306: 
307: 		/* Go to right margin and get position. */
308: 		if (write(ofd, "\x1b[999C", 6) != 6)
309: 			goto failed;
310: 		cols = getCursorPosition(ifd, ofd);
311: 		if (cols == -1)
312: 			goto failed;
313: 
314: 		/* Restore position. */
315: 		if (cols > start) {
316: 			char seq[32];
317: 			snprintf(seq, 32, "\x1b[%dD", cols - start);
318: 			if (write(ofd, seq, strlen(seq)) == -1) {
319: 				/* Can't recover... */
320: 			}
321: 		}
322: 		return cols;
323: 	} else {
324: 		return ws.ws_col;
325: 	}
326: 
327: failed:
328: 	return 80;
329: }
330: 
331: /* Clear the screen. Used to handle ctrl+l */
332: void linenoiseClearScreen(void) {
333: 	if (write(STDOUT_FILENO, "\x1b[H\x1b[2J", 7) <= 0) {
334: 		/* nothing to do, just to avoid warning. */
335: 	}
336: }
337: 
338: /* Beep, used for completion when there is nothing to complete or when all
339:  * the choices were already shown. */
340: static void linenoiseBeep(void) {
341: 	fprintf(stderr, "\x7");
342: 	fflush(stderr);
343: }
344: 
345: /* ============================== Completion ================================ */
346: 
347: /* Free a list of completion option populated by linenoiseAddCompletion(). */
348: static void freeCompletions(linenoiseCompletions *lc) {
349: 	size_t i;
350: 	for (i = 0; i < lc->len; i++)
351: 		free(lc->cvec[i]);
352: 	if (lc->cvec != NULL)
353: 		free(lc->cvec);
354: }
355: 
356: /* This is an helper function for linenoiseEdit() and is called when the
357:  * user types the <tab> key in order to complete the string currently in the
358:  * input.
359:  *
360:  * The state of the editing is encapsulated into the pointed linenoiseState
361:  * structure as described in the structure definition. */
362: static int completeLine(struct linenoiseState *ls) {
363: 	linenoiseCompletions lc = {0, NULL};
364: 	int nread, nwritten;
365: 	char c = 0;
366: 
367: 	completionCallback(ls->buf, &lc);
368: 	if (lc.len == 0) {
369: 		linenoiseBeep();
370: 	} else {
371: 		size_t stop = 0, i = 0;
372: 
373: 		while (!stop) {
374: 			/* Show completion or original buffer */
375: 			if (i < lc.len) {
376: 				struct linenoiseState saved = *ls;
377: 
378: 				ls->len = ls->pos = strlen(lc.cvec[i]);
379: 				ls->buf = lc.cvec[i];
380: 				refreshLine(ls);
381: 				ls->len = saved.len;
382: 				ls->pos = saved.pos;
383: 				ls->buf = saved.buf;
384: 			} else {
385: 				refreshLine(ls);
386: 			}
387: 
388: 			nread = read(ls->ifd, &c, 1);
389: 			if (nread <= 0) {
390: 				freeCompletions(&lc);
391: 				return -1;
392: 			}
393: 
394: 			switch (c) {
395: 			case 9: /* tab */
396: 				i = (i + 1) % (lc.len + 1);
397: 				if (i == lc.len)
398: 					linenoiseBeep();
399: 				break;
400: 			case 27: /* escape */
401: 				/* Re-show original buffer */
402: 				if (i < lc.len)
403: 					refreshLine(ls);
404: 				stop = 1;
405: 				break;
406: 			default:
407: 				/* Update buffer and return */
408: 				if (i < lc.len) {
409: 					nwritten = snprintf(ls->buf, ls->buflen, "%s", lc.cvec[i]);
410: 					ls->len = ls->pos = nwritten;
411: 				}
412: 				stop = 1;
413: 				break;
414: 			}
415: 		}
416: 	}
417: 
418: 	freeCompletions(&lc);
419: 	return c; /* Return last read character */
420: }
421: 
422: /* Register a callback function to be called for tab-completion. */
423: void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {
424: 	completionCallback = fn;
425: }
426: 
427: /* Register a hits function to be called to show hits to the user at the
428:  * right of the prompt. */
429: void linenoiseSetHintsCallback(linenoiseHintsCallback *fn) {
430: 	hintsCallback = fn;
431: }
432: 
433: /* Register a function to free the hints returned by the hints callback
434:  * registered with linenoiseSetHintsCallback(). */
435: void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *fn) {
436: 	freeHintsCallback = fn;
437: }
438: 
439: /* This function is used by the callback function registered by the user
440:  * in order to add completion options given the input string when the
441:  * user typed <tab>. See the example.c source code for a very easy to
442:  * understand example. */
443: void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
444: 	size_t len = strlen(str);
445: 	char *copy, **cvec;
446: 
447: 	copy = malloc(len + 1);
448: 	if (copy == NULL)
449: 		return;
450: 	memcpy(copy, str, len + 1);
451: 	cvec = realloc(lc->cvec, sizeof(char *) * (lc->len + 1));
452: 	if (cvec == NULL) {
453: 		free(copy);
454: 		return;
455: 	}
456: 	lc->cvec = cvec;
457: 	lc->cvec[lc->len++] = copy;
458: }
459: 
460: /* =========================== Line editing ================================= */
461: 
462: /* We define a very simple "append buffer" structure, that is an heap
463:  * allocated string where we can append to. This is useful in order to
464:  * write all the escape sequences in a buffer and flush them to the standard
465:  * output in a single call, to avoid flickering effects. */
466: struct abuf {
467: 	char *b;
468: 	int len;
469: };
470: 
471: static void abInit(struct abuf *ab) {
472: 	ab->b = NULL;
473: 	ab->len = 0;
474: }
475: 
476: static void abAppend(struct abuf *ab, const char *s, int len) {
477: 	char *new = realloc(ab->b, ab->len + len);
478: 
479: 	if (new == NULL)
480: 		return;
481: 	memcpy(new + ab->len, s, len);
482: 	ab->b = new;
483: 	ab->len += len;
484: }
485: 
486: static void abFree(struct abuf *ab) {
487: 	free(ab->b);
488: }
489: 
490: /* Helper of refreshSingleLine() and refreshMultiLine() to show hints
491:  * to the right of the prompt. */
492: void refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {
493: 	char seq[64];
494: 	if (hintsCallback && plen + l->len < l->cols) {
495: 		int color = -1, bold = 0;
496: 		char *hint = hintsCallback(l->buf, &color, &bold);
497: 		if (hint) {
498: 			int hintlen = strlen(hint);
499: 			int hintmaxlen = l->cols - (plen + l->len);
500: 			if (hintlen > hintmaxlen)
501: 				hintlen = hintmaxlen;
502: 			if (bold == 1 && color == -1)
503: 				color = 37;
504: 			if (color != -1 || bold != 0)
505: 				snprintf(seq, 64, "\033[%d;%d;49m", bold, color);
506: 			else
507: 				seq[0] = '\0';
508: 			abAppend(ab, seq, strlen(seq));
509: 			abAppend(ab, hint, hintlen);
510: 			if (color != -1 || bold != 0)
511: 				abAppend(ab, "\033[0m", 4);
512: 			/* Call the function to free the hint returned. */
513: 			if (freeHintsCallback)
514: 				freeHintsCallback(hint);
515: 		}
516: 	}
517: }
518: 
519: /* Single line low level line refresh.
520:  *
521:  * Rewrite the currently edited line accordingly to the buffer content,
522:  * cursor position, and number of columns of the terminal. */
523: static void refreshSingleLine(struct linenoiseState *l) {
524: 	char seq[64];
525: 	size_t plen = strlen(l->prompt);
526: 	int fd = l->ofd;
527: 	char *buf = l->buf;
528: 	size_t len = l->len;
529: 	size_t pos = l->pos;
530: 	struct abuf ab;
531: 
532: 	while ((plen + pos) >= l->cols) {
533: 		buf++;
534: 		len--;
535: 		pos--;
536: 	}
537: 	while (plen + len > l->cols) {
538: 		len--;
539: 	}
540: 
541: 	abInit(&ab);
542: 	/* Cursor to left edge */
543: 	snprintf(seq, 64, "\r");
544: 	abAppend(&ab, seq, strlen(seq));
545: 	/* Write the prompt and the current buffer content */
546: 	abAppend(&ab, l->prompt, strlen(l->prompt));
547: 	abAppend(&ab, buf, len);
548: 	/* Show hits if any. */
549: 	refreshShowHints(&ab, l, plen);
550: 	/* Erase to right */
551: 	snprintf(seq, 64, "\x1b[0K");
552: 	abAppend(&ab, seq, strlen(seq));
553: 	/* Move cursor to original position. */
554: 	snprintf(seq, 64, "\r\x1b[%dC", (int)(pos + plen));
555: 	abAppend(&ab, seq, strlen(seq));
556: 	if (write(fd, ab.b, ab.len) == -1) {
557: 	} /* Can't recover from write error. */
558: 	abFree(&ab);
559: }
560: 
561: /* Multi line low level line refresh.
562:  *
563:  * Rewrite the currently edited line accordingly to the buffer content,
564:  * cursor position, and number of columns of the terminal. */
565: static void refreshMultiLine(struct linenoiseState *l) {
566: 	char seq[64];
567: 	int plen = strlen(l->prompt);
568: 	int rows = (plen + l->len + l->cols - 1) / l->cols; /* rows used by current buf. */
569: 	int rpos = (plen + l->oldpos + l->cols) / l->cols;  /* cursor relative row. */
570: 	int rpos2;                                          /* rpos after refresh. */
571: 	int col;                                            /* colum position, zero-based. */
572: 	int old_rows = l->maxrows;
573: 	int fd = l->ofd, j;
574: 	struct abuf ab;
575: 
576: 	/* Update maxrows if needed. */
577: 	if (rows > (int)l->maxrows)
578: 		l->maxrows = rows;
579: 
580: 	/* First step: clear all the lines used before. To do so start by
581: 	 * going to the last row. */
582: 	abInit(&ab);
583: 	if (old_rows - rpos > 0) {
584: 		lndebug("go down %d", old_rows - rpos);
585: 		snprintf(seq, 64, "\x1b[%dB", old_rows - rpos);
586: 		abAppend(&ab, seq, strlen(seq));
587: 	}
588: 
589: 	/* Now for every row clear it, go up. */
590: 	for (j = 0; j < old_rows - 1; j++) {
591: 		lndebug("clear+up");
592: 		snprintf(seq, 64, "\r\x1b[0K\x1b[1A");
593: 		abAppend(&ab, seq, strlen(seq));
594: 	}
595: 
596: 	/* Clean the top line. */
597: 	lndebug("clear");
598: 	snprintf(seq, 64, "\r\x1b[0K");
599: 	abAppend(&ab, seq, strlen(seq));
600: 
601: 	/* Write the prompt and the current buffer content */
602: 	abAppend(&ab, l->prompt, strlen(l->prompt));
603: 	abAppend(&ab, l->buf, l->len);
604: 
605: 	/* Show hits if any. */
606: 	refreshShowHints(&ab, l, plen);
607: 
608: 	/* If we are at the very end of the screen with our prompt, we need to
609: 	 * emit a newline and move the prompt to the first column. */
610: 	if (l->pos && l->pos == l->len && (l->pos + plen) % l->cols == 0) {
611: 		lndebug("<newline>");
612: 		abAppend(&ab, "\n", 1);
613: 		snprintf(seq, 64, "\r");
614: 		abAppend(&ab, seq, strlen(seq));
615: 		rows++;
616: 		if (rows > (int)l->maxrows)
617: 			l->maxrows = rows;
618: 	}
619: 
620: 	/* Move cursor to right position. */
621: 	rpos2 = (plen + l->pos + l->cols) / l->cols; /* current cursor relative row. */
622: 	lndebug("rpos2 %d", rpos2);
623: 
624: 	/* Go up till we reach the expected positon. */
625: 	if (rows - rpos2 > 0) {
626: 		lndebug("go-up %d", rows - rpos2);
627: 		snprintf(seq, 64, "\x1b[%dA", rows - rpos2);
628: 		abAppend(&ab, seq, strlen(seq));
629: 	}
630: 
631: 	/* Set column. */
632: 	col = (plen + (int)l->pos) % (int)l->cols;
633: 	lndebug("set col %d", 1 + col);
634: 	if (col)
635: 		snprintf(seq, 64, "\r\x1b[%dC", col);
636: 	else
637: 		snprintf(seq, 64, "\r");
638: 	abAppend(&ab, seq, strlen(seq));
639: 
640: 	lndebug("\n");
641: 	l->oldpos = l->pos;
642: 
643: 	if (write(fd, ab.b, ab.len) == -1) {
644: 	} /* Can't recover from write error. */
645: 	abFree(&ab);
646: }
647: 
648: /* Calls the two low level functions refreshSingleLine() or
649:  * refreshMultiLine() according to the selected mode. */
650: static void refreshLine(struct linenoiseState *l) {
651: 	if (mlmode)
652: 		refreshMultiLine(l);
653: 	else
654: 		refreshSingleLine(l);
655: }
656: 
657: /* Insert the character 'c' at cursor current position.
658:  *
659:  * On error writing to the terminal -1 is returned, otherwise 0. */
660: int linenoiseEditInsert(struct linenoiseState *l, char c) {
661: 	if (l->len < l->buflen) {
662: 		if (l->len == l->pos) {
663: 			l->buf[l->pos] = c;
664: 			l->pos++;
665: 			l->len++;
666: 			l->buf[l->len] = '\0';
667: 			if ((!mlmode && l->plen + l->len < l->cols && !hintsCallback)) {
668: 				/* Avoid a full update of the line in the
669: 				 * trivial case. */
670: 				if (write(l->ofd, &c, 1) == -1)
671: 					return -1;
672: 			} else {
673: 				refreshLine(l);
674: 			}
675: 		} else {
676: 			memmove(l->buf + l->pos + 1, l->buf + l->pos, l->len - l->pos);
677: 			l->buf[l->pos] = c;
678: 			l->len++;
679: 			l->pos++;
680: 			l->buf[l->len] = '\0';
681: 			refreshLine(l);
682: 		}
683: 	}
684: 	return 0;
685: }
686: 
687: /* Move cursor on the left. */
688: void linenoiseEditMoveLeft(struct linenoiseState *l) {
689: 	if (l->pos > 0) {
690: 		l->pos--;
691: 		refreshLine(l);
692: 	}
693: }
694: 
695: /* Move cursor on the right. */
696: void linenoiseEditMoveRight(struct linenoiseState *l) {
697: 	if (l->pos != l->len) {
698: 		l->pos++;
699: 		refreshLine(l);
700: 	}
701: }
702: 
703: /* Move cursor to the start of the line. */
704: void linenoiseEditMoveHome(struct linenoiseState *l) {
705: 	if (l->pos != 0) {
706: 		l->pos = 0;
707: 		refreshLine(l);
708: 	}
709: }
710: 
711: /* Move cursor to the end of the line. */
712: void linenoiseEditMoveEnd(struct linenoiseState *l) {
713: 	if (l->pos != l->len) {
714: 		l->pos = l->len;
715: 		refreshLine(l);
716: 	}
717: }
718: 
719: /* Substitute the currently edited line with the next or previous history
720:  * entry as specified by 'dir'. */
721: #define LINENOISE_HISTORY_NEXT 0
722: #define LINENOISE_HISTORY_PREV 1
723: void linenoiseEditHistoryNext(struct linenoiseState *l, int dir) {
724: 	if (history_len > 1) {
725: 		/* Update the current history entry before to
726: 		 * overwrite it with the next one. */
727: 		free(history[history_len - 1 - l->history_index]);
728: 		history[history_len - 1 - l->history_index] = strdup(l->buf);
729: 		/* Show the new entry */
730: 		l->history_index += (dir == LINENOISE_HISTORY_PREV) ? 1 : -1;
731: 		if (l->history_index < 0) {
732: 			l->history_index = 0;
733: 			return;
734: 		} else if (l->history_index >= history_len) {
735: 			l->history_index = history_len - 1;
736: 			return;
737: 		}
738: 		strncpy(l->buf, history[history_len - 1 - l->history_index], l->buflen);
739: 		l->buf[l->buflen - 1] = '\0';
740: 		l->len = l->pos = strlen(l->buf);
741: 		refreshLine(l);
742: 	}
743: }
744: 
745: /* Delete the character at the right of the cursor without altering the cursor
746:  * position. Basically this is what happens with the "Delete" keyboard key. */
747: void linenoiseEditDelete(struct linenoiseState *l) {
748: 	if (l->len > 0 && l->pos < l->len) {
749: 		memmove(l->buf + l->pos, l->buf + l->pos + 1, l->len - l->pos - 1);
750: 		l->len--;
751: 		l->buf[l->len] = '\0';
752: 		refreshLine(l);
753: 	}
754: }
755: 
756: /* Backspace implementation. */
757: void linenoiseEditBackspace(struct linenoiseState *l) {
758: 	if (l->pos > 0 && l->len > 0) {
759: 		memmove(l->buf + l->pos - 1, l->buf + l->pos, l->len - l->pos);
760: 		l->pos--;
761: 		l->len--;
762: 		l->buf[l->len] = '\0';
763: 		refreshLine(l);
764: 	}
765: }
766: 
767: /* Delete the previosu word, maintaining the cursor at the start of the
768:  * current word. */
769: void linenoiseEditDeletePrevWord(struct linenoiseState *l) {
770: 	size_t old_pos = l->pos;
771: 	size_t diff;
772: 
773: 	while (l->pos > 0 && l->buf[l->pos - 1] == ' ')
774: 		l->pos--;
775: 	while (l->pos > 0 && l->buf[l->pos - 1] != ' ')
776: 		l->pos--;
777: 	diff = old_pos - l->pos;
778: 	memmove(l->buf + l->pos, l->buf + old_pos, l->len - old_pos + 1);
779: 	l->len -= diff;
780: 	refreshLine(l);
781: }
782: 
783: /* This function is the core of the line editing capability of linenoise.
784:  * It expects 'fd' to be already in "raw mode" so that every key pressed
785:  * will be returned ASAP to read().
786:  *
787:  * The resulting string is put into 'buf' when the user type enter, or
788:  * when ctrl+d is typed.
789:  *
790:  * The function returns the length of the current buffer. */
791: static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen, const char *prompt) {
792: 	struct linenoiseState l;
793: 
794: 	/* Populate the linenoise state that we pass to functions implementing
795: 	 * specific editing functionalities. */
796: 	l.ifd = stdin_fd;
797: 	l.ofd = stdout_fd;
798: 	l.buf = buf;
799: 	l.buflen = buflen;
800: 	l.prompt = prompt;
801: 	l.plen = strlen(prompt);
802: 	l.oldpos = l.pos = 0;
803: 	l.len = 0;
804: 	l.cols = getColumns(stdin_fd, stdout_fd);
805: 	l.maxrows = 0;
806: 	l.history_index = 0;
807: 
808: 	/* Buffer starts empty. */
809: 	l.buf[0] = '\0';
810: 	l.buflen--; /* Make sure there is always space for the nulterm */
811: 
812: 	/* The latest history entry is always our current buffer, that
813: 	 * initially is just an empty string. */
814: 	linenoiseHistoryAdd("");
815: 
816: 	if (write(l.ofd, prompt, l.plen) == -1)
817: 		return -1;
818: 	while (1) {
819: 		char c;
820: 		int nread;
821: 		char seq[3];
822: 
823: 		nread = read(l.ifd, &c, 1);
824: 		if (nread <= 0)
825: 			return l.len;
826: 
827: 		/* Only autocomplete when the callback is set. It returns < 0 when
828: 		 * there was an error reading from fd. Otherwise it will return the
829: 		 * character that should be handled next. */
830: 		if (c == 9 && completionCallback != NULL) {
831: 			c = completeLine(&l);
832: 			/* Return on errors */
833: 			if (c < 0)
834: 				return l.len;
835: 			/* Read next character when 0 */
836: 			if (c == 0)
837: 				continue;
838: 		}
839: 
840: 		switch (c) {
841: 		case ENTER: /* enter */
842: 			history_len--;
843: 			free(history[history_len]);
844: 			if (mlmode)
845: 				linenoiseEditMoveEnd(&l);
846: 			if (hintsCallback) {
847: 				/* Force a refresh without hints to leave the previous
848: 				 * line as the user typed it after a newline. */
849: 				linenoiseHintsCallback *hc = hintsCallback;
850: 				hintsCallback = NULL;
851: 				refreshLine(&l);
852: 				hintsCallback = hc;
853: 			}
854: 			return (int)l.len;
855: 		case CTRL_C: /* ctrl-c */
856: 			errno = EAGAIN;
857: 			return -1;
858: 		case BACKSPACE: /* backspace */
859: 		case 8:         /* ctrl-h */
860: 			linenoiseEditBackspace(&l);
861: 			break;
862: 		case CTRL_D: /* ctrl-d, remove char at right of cursor, or if the
863: 		                line is empty, act as end-of-file. */
864: 			if (l.len > 0) {
865: 				linenoiseEditDelete(&l);
866: 			} else {
867: 				history_len--;
868: 				free(history[history_len]);
869: 				return -1;
870: 			}
871: 			break;
872: 		case CTRL_T: /* ctrl-t, swaps current character with previous. */
873: 			if (l.pos > 0 && l.pos < l.len) {
874: 				int aux = buf[l.pos - 1];
875: 				buf[l.pos - 1] = buf[l.pos];
876: 				buf[l.pos] = aux;
877: 				if (l.pos != l.len - 1)
878: 					l.pos++;
879: 				refreshLine(&l);
880: 			}
881: 			break;
882: 		case CTRL_B: /* ctrl-b */
883: 			linenoiseEditMoveLeft(&l);
884: 			break;
885: 		case CTRL_F: /* ctrl-f */
886: 			linenoiseEditMoveRight(&l);
887: 			break;
888: 		case CTRL_P: /* ctrl-p */
889: 			linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
890: 			break;
891: 		case CTRL_N: /* ctrl-n */
892: 			linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
893: 			break;
894: 		case ESC: /* escape sequence */
895: 			/* Read the next two bytes representing the escape sequence.
896: 			 * Use two calls to handle slow terminals returning the two
897: 			 * chars at different times. */
898: 			if (read(l.ifd, seq, 1) == -1)
899: 				break;
900: 			if (read(l.ifd, seq + 1, 1) == -1)
901: 				break;
902: 
903: 			/* ESC [ sequences. */
904: 			if (seq[0] == '[') {
905: 				if (seq[1] >= '0' && seq[1] <= '9') {
906: 					/* Extended escape, read additional byte. */
907: 					if (read(l.ifd, seq + 2, 1) == -1)
908: 						break;
909: 					if (seq[2] == '~') {
910: 						switch (seq[1]) {
911: 						case '3': /* Delete key. */
912: 							linenoiseEditDelete(&l);
913: 							break;
914: 						}
915: 					}
916: 				} else {
917: 					switch (seq[1]) {
918: 					case 'A': /* Up */
919: 						linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
920: 						break;
921: 					case 'B': /* Down */
922: 						linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
923: 						break;
924: 					case 'C': /* Right */
925: 						linenoiseEditMoveRight(&l);
926: 						break;
927: 					case 'D': /* Left */
928: 						linenoiseEditMoveLeft(&l);
929: 						break;
930: 					case 'H': /* Home */
931: 						linenoiseEditMoveHome(&l);
932: 						break;
933: 					case 'F': /* End*/
934: 						linenoiseEditMoveEnd(&l);
935: 						break;
936: 					}
937: 				}
938: 			}
939: 
940: 			/* ESC O sequences. */
941: 			else if (seq[0] == 'O') {
942: 				switch (seq[1]) {
943: 				case 'H': /* Home */
944: 					linenoiseEditMoveHome(&l);
945: 					break;
946: 				case 'F': /* End*/
947: 					linenoiseEditMoveEnd(&l);
948: 					break;
949: 				}
950: 			}
951: 			break;
952: 		default:
953: 			if (linenoiseEditInsert(&l, c))
954: 				return -1;
955: 			break;
956: 		case CTRL_U: /* Ctrl+u, delete the whole line. */
957: 			buf[0] = '\0';
958: 			l.pos = l.len = 0;
959: 			refreshLine(&l);
960: 			break;
961: 		case CTRL_K: /* Ctrl+k, delete from current to end of line. */
962: 			buf[l.pos] = '\0';
963: 			l.len = l.pos;
964: 			refreshLine(&l);
965: 			break;
966: 		case CTRL_A: /* Ctrl+a, go to the start of the line */
967: 			linenoiseEditMoveHome(&l);
968: 			break;
969: 		case CTRL_E: /* ctrl+e, go to the end of the line */
970: 			linenoiseEditMoveEnd(&l);
971: 			break;
972: 		case CTRL_L: /* ctrl+l, clear screen */
973: 			linenoiseClearScreen();
974: 			refreshLine(&l);
975: 			break;
976: 		case CTRL_W: /* ctrl+w, delete previous word */
977: 			linenoiseEditDeletePrevWord(&l);
978: 			break;
979: 		}
980: 	}
981: 	return l.len;
982: }
983: 
984: /* This special mode is used by linenoise in order to print scan codes
985:  * on screen for debugging / development purposes. It is implemented
986:  * by the linenoise_example program using the --keycodes option. */
987: void linenoisePrintKeyCodes(void) {
988: 	char quit[4];
989: 
990: 	printf("Linenoise key codes debugging mode.\n"
991: 	       "Press keys to see scan codes. Type 'quit' at any time to exit.\n");
992: 	if (enableRawMode(STDIN_FILENO) == -1)
993: 		return;
994: 	memset(quit, ' ', 4);
995: 	while (1) {
996: 		char c;
997: 		int nread;
998: 
999: 		nread = read(STDIN_FILENO, &c, 1);
1000: 		if (nread <= 0)
1001: 			continue;
1002: 		memmove(quit, quit + 1, sizeof(quit) - 1); /* shift string to left. */
1003: 		quit[sizeof(quit) - 1] = c;                /* Insert current char on the right. */
1004: 		if (memcmp(quit, "quit", sizeof(quit)) == 0)
1005: 			break;
1006: 
1007: 		printf("'%c' %02x (%d) (type quit to exit)\n", isprint(c) ? c : '?', (int)c, (int)c);
1008: 		printf("\r"); /* Go left edge manually, we are in raw mode. */
1009: 		fflush(stdout);
1010: 	}
1011: 	disableRawMode(STDIN_FILENO);
1012: }
1013: 
1014: /* This function calls the line editing function linenoiseEdit() using
1015:  * the STDIN file descriptor set in raw mode. */
1016: static int linenoiseRaw(char *buf, size_t buflen, const char *prompt) {
1017: 	int count;
1018: 
1019: 	if (buflen == 0) {
1020: 		errno = EINVAL;
1021: 		return -1;
1022: 	}
1023: 
1024: 	if (enableRawMode(STDIN_FILENO) == -1)
1025: 		return -1;
1026: 	count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, buflen, prompt);
1027: 	disableRawMode(STDIN_FILENO);
1028: 	printf("\n");
1029: 	return count;
1030: }
1031: 
1032: /* This function is called when linenoise() is called with the standard
1033:  * input file descriptor not attached to a TTY. So for example when the
1034:  * program using linenoise is called in pipe or with a file redirected
1035:  * to its standard input. In this case, we want to be able to return the
1036:  * line regardless of its length (by default we are limited to 4k). */
1037: static char *linenoiseNoTTY(void) {
1038: 	char *line = NULL;
1039: 	size_t len = 0, maxlen = 0;
1040: 
1041: 	while (1) {
1042: 		if (len == maxlen) {
1043: 			if (maxlen == 0)
1044: 				maxlen = 16;
1045: 			maxlen *= 2;
1046: 			char *oldval = line;
1047: 			line = realloc(line, maxlen);
1048: 			if (line == NULL) {
1049: 				if (oldval)
1050: 					free(oldval);
1051: 				return NULL;
1052: 			}
1053: 		}
1054: 		int c = fgetc(stdin);
1055: 		if (c == EOF || c == '\n') {
1056: 			if (c == EOF && len == 0) {
1057: 				free(line);
1058: 				return NULL;
1059: 			} else {
1060: 				line[len] = '\0';
1061: 				return line;
1062: 			}
1063: 		} else {
1064: 			line[len] = c;
1065: 			len++;
1066: 		}
1067: 	}
1068: }
1069: 
1070: /* The high level function that is the main API of the linenoise library.
1071:  * This function checks if the terminal has basic capabilities, just checking
1072:  * for a blacklist of stupid terminals, and later either calls the line
1073:  * editing function or uses dummy fgets() so that you will be able to type
1074:  * something even in the most desperate of the conditions. */
1075: char *linenoise(const char *prompt) {
1076: 	char buf[LINENOISE_MAX_LINE];
1077: 	int count;
1078: 
1079: 	if (!isatty(STDIN_FILENO)) {
1080: 		/* Not a tty: read from file / pipe. In this mode we don't want any
1081: 		 * limit to the line size, so we call a function to handle that. */
1082: 		return linenoiseNoTTY();
1083: 	} else if (isUnsupportedTerm()) {
1084: 		size_t len;
1085: 
1086: 		printf("%s", prompt);
1087: 		fflush(stdout);
1088: 		if (fgets(buf, LINENOISE_MAX_LINE, stdin) == NULL)
1089: 			return NULL;
1090: 		len = strlen(buf);
1091: 		while (len && (buf[len - 1] == '\n' || buf[len - 1] == '\r')) {
1092: 			len--;
1093: 			buf[len] = '\0';
1094: 		}
1095: 		return strdup(buf);
1096: 	} else {
1097: 		count = linenoiseRaw(buf, LINENOISE_MAX_LINE, prompt);
1098: 		if (count == -1)
1099: 			return NULL;
1100: 		return strdup(buf);
1101: 	}
1102: }
1103: 
1104: /* This is just a wrapper the user may want to call in order to make sure
1105:  * the linenoise returned buffer is freed with the same allocator it was
1106:  * created with. Useful when the main program is using an alternative
1107:  * allocator. */
1108: void linenoiseFree(void *ptr) {
1109: 	free(ptr);
1110: }
1111: 
1112: /* ================================ History ================================= */
1113: 
1114: /* Free the history, but does not reset it. Only used when we have to
1115:  * exit() to avoid memory leaks are reported by valgrind & co. */
1116: static void freeHistory(void) {
1117: 	if (history) {
1118: 		int j;
1119: 
1120: 		for (j = 0; j < history_len; j++)
1121: 			free(history[j]);
1122: 		free(history);
1123: 	}
1124: }
1125: 
1126: /* At exit we'll try to fix the terminal to the initial conditions. */
1127: static void linenoiseAtExit(void) {
1128: 	disableRawMode(STDIN_FILENO);
1129: 	freeHistory();
1130: }
1131: 
1132: /* This is the API call to add a new entry in the linenoise history.
1133:  * It uses a fixed array of char pointers that are shifted (memmoved)
1134:  * when the history max length is reached in order to remove the older
1135:  * entry and make room for the new one, so it is not exactly suitable for huge
1136:  * histories, but will work well for a few hundred of entries.
1137:  *
1138:  * Using a circular buffer is smarter, but a bit more complex to handle. */
1139: int linenoiseHistoryAdd(const char *line) {
1140: 	char *linecopy;
1141: 
1142: 	if (history_max_len == 0)
1143: 		return 0;
1144: 
1145: 	/* Initialization on first call. */
1146: 	if (history == NULL) {
1147: 		history = malloc(sizeof(char *) * history_max_len);
1148: 		if (history == NULL)
1149: 			return 0;
1150: 		memset(history, 0, (sizeof(char *) * history_max_len));
1151: 	}
1152: 
1153: 	/* Don't add duplicated lines. */
1154: 	if (history_len && !strcmp(history[history_len - 1], line))
1155: 		return 0;
1156: 
1157: 	/* Add an heap allocated copy of the line in the history.
1158: 	 * If we reached the max length, remove the older line. */
1159: 	linecopy = strdup(line);
1160: 	if (!linecopy)
1161: 		return 0;
1162: 	if (history_len == history_max_len) {
1163: 		free(history[0]);
1164: 		memmove(history, history + 1, sizeof(char *) * (history_max_len - 1));
1165: 		history_len--;
1166: 	}
1167: 	history[history_len] = linecopy;
1168: 	history_len++;
1169: 	return 1;
1170: }
1171: 
1172: /* Set the maximum length for the history. This function can be called even
1173:  * if there is already some history, the function will make sure to retain
1174:  * just the latest 'len' elements if the new history length value is smaller
1175:  * than the amount of items already inside the history. */
1176: int linenoiseHistorySetMaxLen(int len) {
1177: 	char **new;
1178: 
1179: 	if (len < 1)
1180: 		return 0;
1181: 	if (history) {
1182: 		int tocopy = history_len;
1183: 
1184: 		new = malloc(sizeof(char *) * len);
1185: 		if (new == NULL)
1186: 			return 0;
1187: 
1188: 		/* If we can't copy everything, free the elements we'll not use. */
1189: 		if (len < tocopy) {
1190: 			int j;
1191: 
1192: 			for (j = 0; j < tocopy - len; j++)
1193: 				free(history[j]);
1194: 			tocopy = len;
1195: 		}
1196: 		memset(new, 0, sizeof(char *) * len);
1197: 		memcpy(new, history + (history_len - tocopy), sizeof(char *) * tocopy);
1198: 		free(history);
1199: 		history = new;
1200: 	}
1201: 	history_max_len = len;
1202: 	if (history_len > history_max_len)
1203: 		history_len = history_max_len;
1204: 	return 1;
1205: }
1206: 
1207: /* Save the history in the specified file. On success 0 is returned
1208:  * otherwise -1 is returned. */
1209: int linenoiseHistorySave(const char *filename) {
1210: 	mode_t old_umask = umask(S_IXUSR | S_IRWXG | S_IRWXO);
1211: 	FILE *fp;
1212: 	int j;
1213: 
1214: 	fp = fopen(filename, "w");
1215: 	umask(old_umask);
1216: 	if (fp == NULL)
1217: 		return -1;
1218: 	chmod(filename, S_IRUSR | S_IWUSR);
1219: 	for (j = 0; j < history_len; j++)
1220: 		fprintf(fp, "%s\n", history[j]);
1221: 	fclose(fp);
1222: 	return 0;
1223: }
1224: 
1225: /* Load the history from the specified file. If the file does not exist
1226:  * zero is returned and no operation is performed.
1227:  *
1228:  * If the file exists and the operation succeeded 0 is returned, otherwise
1229:  * on error -1 is returned. */
1230: int linenoiseHistoryLoad(const char *filename) {
1231: 	FILE *fp = fopen(filename, "r");
1232: 	char buf[LINENOISE_MAX_LINE];
1233: 
1234: 	if (fp == NULL)
1235: 		return -1;
1236: 
1237: 	while (fgets(buf, LINENOISE_MAX_LINE, fp) != NULL) {
1238: 		char *p;
1239: 
1240: 		p = strchr(buf, '\r');
1241: 		if (!p)
1242: 			p = strchr(buf, '\n');
1243: 		if (p)
1244: 			*p = '\0';
1245: 		linenoiseHistoryAdd(buf);
1246: 	}
1247: 	fclose(fp);
1248: 	return 0;
1249: }
[end of tools/shell/linenoise.c]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: