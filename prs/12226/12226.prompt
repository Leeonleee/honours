You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
:bug: `v0.10.3` Regression while adding a new column to a table "because there are entries that depend on it."
### What happens?

Since latest [`v0.10.3`](https://github.com/duckdb/duckdb/releases/tag/v0.10.3), my scheduled notebook is broken, a regression has been introduced.

As a proof, see : 

- [:+1:  Before](https://www.kaggle.com/code/adriensales/fiches-emploi-nouvelle-cal-donie)
- [:-1: Now](https://www.kaggle.com/code/adriensales/fiches-emploi-nouvelle-cal-donie?scriptVersionId=179423277)

### To Reproduce

See notebook [here](https://www.kaggle.com/code/adriensales/fiches-emploi-nouvelle-cal-donie/log?scriptVersionId=179423277), still here are the steps to reproduce : 

# :one:  Create a main table : 

```python
con.execute("""create or replace table familles(id varchar primary key)""")
con.execute("""insert into familles
                    select distinct famille
                        from load_fiches
                    order by famille;""")
df = con.query("from familles").to_df()
df
```

# :two: Create a table that references it

```python
con.execute("""create or replace SEQUENCE id_fiche START 1; """)
con.execute("""create or replace table fiches(
                id integer DEFAULT nextval('id_fiche') primary key,
                famille varchar not null references familles(id),
                titre varchar not null,
                url_pdf_fiche_emploi varchar not null
                )""")

con.execute("""insert into fiches (famille, titre, url_pdf_fiche_emploi)
                    select famille, titre, url_pdf_fiche_emploi
                        from load_fiches
                    order by famille, titre;""")
df = con.query("from fiches").to_df()
df
```

# :three: Add a column to the main table

```python
con.execute("""alter table familles add column code_rome varchar""")
```


### OS:

Kaggle

### DuckDB Version:

`v0.10.3` 

### DuckDB Client:

Python

### Full Name:

Adrien Sales

### Affiliation:

https://dev.to/adriens

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
18: 
19: ## Installation
20: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
21: 
22: ## Data Import
23: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
24: 
25: ```sql
26: SELECT * FROM 'myfile.csv';
27: SELECT * FROM 'myfile.parquet';
28: ```
29: 
30: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
31: 
32: ## SQL Reference
33: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
34: 
35: ## Development
36: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
37: 
38: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
39: 
40: ## Support
41: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/catalog/dependency_manager.cpp]
1: #include "duckdb/catalog/dependency_manager.hpp"
2: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
3: #include "duckdb/catalog/duck_catalog.hpp"
4: #include "duckdb/catalog/catalog_entry.hpp"
5: #include "duckdb/main/client_context.hpp"
6: #include "duckdb/main/database.hpp"
7: #include "duckdb/parser/expression/constant_expression.hpp"
8: #include "duckdb/catalog/dependency_list.hpp"
9: #include "duckdb/common/enums/catalog_type.hpp"
10: #include "duckdb/catalog/catalog_entry/dependency/dependency_entry.hpp"
11: #include "duckdb/catalog/catalog_entry/dependency/dependency_subject_entry.hpp"
12: #include "duckdb/catalog/catalog_entry/dependency/dependency_dependent_entry.hpp"
13: #include "duckdb/catalog/catalog_entry/duck_schema_entry.hpp"
14: #include "duckdb/common/queue.hpp"
15: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
16: #include "duckdb/parser/constraints/foreign_key_constraint.hpp"
17: #include "duckdb/catalog/dependency_catalog_set.hpp"
18: 
19: namespace duckdb {
20: 
21: static void AssertMangledName(const string &mangled_name, idx_t expected_null_bytes) {
22: #ifdef DEBUG
23: 	idx_t nullbyte_count = 0;
24: 	for (auto &ch : mangled_name) {
25: 		nullbyte_count += ch == '\0';
26: 	}
27: 	D_ASSERT(nullbyte_count == expected_null_bytes);
28: #endif
29: }
30: 
31: MangledEntryName::MangledEntryName(const CatalogEntryInfo &info) {
32: 	auto &type = info.type;
33: 	auto &schema = info.schema;
34: 	auto &name = info.name;
35: 
36: 	this->name = CatalogTypeToString(type) + '\0' + schema + '\0' + name;
37: 	AssertMangledName(this->name, 2);
38: }
39: 
40: MangledDependencyName::MangledDependencyName(const MangledEntryName &from, const MangledEntryName &to) {
41: 	this->name = from.name + '\0' + to.name;
42: 	AssertMangledName(this->name, 5);
43: }
44: 
45: DependencyManager::DependencyManager(DuckCatalog &catalog) : catalog(catalog), subjects(catalog), dependents(catalog) {
46: }
47: 
48: string DependencyManager::GetSchema(const CatalogEntry &entry) {
49: 	if (entry.type == CatalogType::SCHEMA_ENTRY) {
50: 		return entry.name;
51: 	}
52: 	return entry.ParentSchema().name;
53: }
54: 
55: MangledEntryName DependencyManager::MangleName(const CatalogEntryInfo &info) {
56: 	return MangledEntryName(info);
57: }
58: 
59: MangledEntryName DependencyManager::MangleName(const CatalogEntry &entry) {
60: 	if (entry.type == CatalogType::DEPENDENCY_ENTRY) {
61: 		auto &dependency_entry = entry.Cast<DependencyEntry>();
62: 		return dependency_entry.EntryMangledName();
63: 	}
64: 	auto type = entry.type;
65: 	auto schema = GetSchema(entry);
66: 	auto name = entry.name;
67: 	CatalogEntryInfo info {type, schema, name};
68: 
69: 	return MangleName(info);
70: }
71: 
72: DependencyInfo DependencyInfo::FromSubject(DependencyEntry &dep) {
73: 	return DependencyInfo {/*dependent = */ dep.Dependent(),
74: 	                       /*subject = */ dep.Subject()};
75: }
76: 
77: DependencyInfo DependencyInfo::FromDependent(DependencyEntry &dep) {
78: 	return DependencyInfo {/*dependent = */ dep.Dependent(),
79: 	                       /*subject = */ dep.Subject()};
80: }
81: 
82: // ----------- DEPENDENCY_MANAGER -----------
83: 
84: bool DependencyManager::IsSystemEntry(CatalogEntry &entry) const {
85: 	if (entry.internal) {
86: 		return true;
87: 	}
88: 
89: 	switch (entry.type) {
90: 	case CatalogType::DEPENDENCY_ENTRY:
91: 	case CatalogType::DATABASE_ENTRY:
92: 	case CatalogType::RENAMED_ENTRY:
93: 		return true;
94: 	default:
95: 		return false;
96: 	}
97: }
98: 
99: CatalogSet &DependencyManager::Dependents() {
100: 	return dependents;
101: }
102: 
103: CatalogSet &DependencyManager::Subjects() {
104: 	return subjects;
105: }
106: 
107: void DependencyManager::ScanSetInternal(CatalogTransaction transaction, const CatalogEntryInfo &info,
108:                                         bool scan_subjects, dependency_callback_t &callback) {
109: 	catalog_entry_set_t other_entries;
110: 
111: 	auto cb = [&](CatalogEntry &other) {
112: 		D_ASSERT(other.type == CatalogType::DEPENDENCY_ENTRY);
113: 		auto &other_entry = other.Cast<DependencyEntry>();
114: #ifdef DEBUG
115: 		auto side = other_entry.Side();
116: 		if (scan_subjects) {
117: 			D_ASSERT(side == DependencyEntryType::SUBJECT);
118: 		} else {
119: 			D_ASSERT(side == DependencyEntryType::DEPENDENT);
120: 		}
121: 
122: #endif
123: 
124: 		other_entries.insert(other_entry);
125: 		callback(other_entry);
126: 	};
127: 
128: 	if (scan_subjects) {
129: 		DependencyCatalogSet subjects(Subjects(), info);
130: 		subjects.Scan(transaction, cb);
131: 	} else {
132: 		DependencyCatalogSet dependents(Dependents(), info);
133: 		dependents.Scan(transaction, cb);
134: 	}
135: 
136: #ifdef DEBUG
137: 	// Verify some invariants
138: 	// Every dependency should have a matching dependent in the other set
139: 	// And vice versa
140: 	auto mangled_name = MangleName(info);
141: 
142: 	if (scan_subjects) {
143: 		for (auto &entry : other_entries) {
144: 			auto other_info = GetLookupProperties(entry);
145: 			DependencyCatalogSet other_dependents(Dependents(), other_info);
146: 
147: 			// Verify that the other half of the dependency also exists
148: 			auto dependent = other_dependents.GetEntryDetailed(transaction, mangled_name);
149: 			D_ASSERT(dependent.reason != CatalogSet::EntryLookup::FailureReason::NOT_PRESENT);
150: 		}
151: 	} else {
152: 		for (auto &entry : other_entries) {
153: 			auto other_info = GetLookupProperties(entry);
154: 			DependencyCatalogSet other_subjects(Subjects(), other_info);
155: 
156: 			// Verify that the other half of the dependent also exists
157: 			auto subject = other_subjects.GetEntryDetailed(transaction, mangled_name);
158: 			D_ASSERT(subject.reason != CatalogSet::EntryLookup::FailureReason::NOT_PRESENT);
159: 		}
160: 	}
161: #endif
162: }
163: 
164: void DependencyManager::ScanDependents(CatalogTransaction transaction, const CatalogEntryInfo &info,
165:                                        dependency_callback_t &callback) {
166: 	ScanSetInternal(transaction, info, false, callback);
167: }
168: 
169: void DependencyManager::ScanSubjects(CatalogTransaction transaction, const CatalogEntryInfo &info,
170:                                      dependency_callback_t &callback) {
171: 	ScanSetInternal(transaction, info, true, callback);
172: }
173: 
174: void DependencyManager::RemoveDependency(CatalogTransaction transaction, const DependencyInfo &info) {
175: 	auto &dependent = info.dependent;
176: 	auto &subject = info.subject;
177: 
178: 	// The dependents of the dependency (target)
179: 	DependencyCatalogSet dependents(Dependents(), subject.entry);
180: 	// The subjects of the dependencies of the dependent
181: 	DependencyCatalogSet subjects(Subjects(), dependent.entry);
182: 
183: 	auto dependent_mangled = MangledEntryName(dependent.entry);
184: 	auto subject_mangled = MangledEntryName(subject.entry);
185: 
186: 	auto dependent_p = dependents.GetEntry(transaction, dependent_mangled);
187: 	if (dependent_p) {
188: 		// 'dependent' is no longer inhibiting the deletion of 'dependency'
189: 		dependents.DropEntry(transaction, dependent_mangled, false);
190: 	}
191: 	auto subject_p = subjects.GetEntry(transaction, subject_mangled);
192: 	if (subject_p) {
193: 		// 'dependency' is no longer required by 'dependent'
194: 		subjects.DropEntry(transaction, subject_mangled, false);
195: 	}
196: }
197: 
198: void DependencyManager::CreateSubject(CatalogTransaction transaction, const DependencyInfo &info) {
199: 	auto &from = info.dependent.entry;
200: 
201: 	DependencyCatalogSet set(Subjects(), from);
202: 	auto dep = make_uniq_base<DependencyEntry, DependencySubjectEntry>(catalog, info);
203: 	auto entry_name = dep->EntryMangledName();
204: 
205: 	//! Add to the list of objects that 'dependent' has a dependency on
206: 	set.CreateEntry(transaction, entry_name, std::move(dep));
207: }
208: 
209: void DependencyManager::CreateDependent(CatalogTransaction transaction, const DependencyInfo &info) {
210: 	auto &from = info.subject.entry;
211: 
212: 	DependencyCatalogSet set(Dependents(), from);
213: 	auto dep = make_uniq_base<DependencyEntry, DependencyDependentEntry>(catalog, info);
214: 	auto entry_name = dep->EntryMangledName();
215: 
216: 	//! Add to the list of object that depend on 'subject'
217: 	set.CreateEntry(transaction, entry_name, std::move(dep));
218: }
219: 
220: void DependencyManager::CreateDependency(CatalogTransaction transaction, DependencyInfo &info) {
221: 	DependencyCatalogSet subjects(Subjects(), info.dependent.entry);
222: 	DependencyCatalogSet dependents(Dependents(), info.subject.entry);
223: 
224: 	auto subject_mangled = MangleName(info.subject.entry);
225: 	auto dependent_mangled = MangleName(info.dependent.entry);
226: 
227: 	auto &dependent_flags = info.dependent.flags;
228: 	auto &subject_flags = info.subject.flags;
229: 
230: 	auto existing_subject = subjects.GetEntry(transaction, subject_mangled);
231: 	auto existing_dependent = dependents.GetEntry(transaction, dependent_mangled);
232: 
233: 	// Inherit the existing flags and drop the existing entry if present
234: 	if (existing_subject) {
235: 		auto &existing = existing_subject->Cast<DependencyEntry>();
236: 		auto existing_flags = existing.Subject().flags;
237: 		if (existing_flags != subject_flags) {
238: 			subject_flags.Apply(existing_flags);
239: 		}
240: 		subjects.DropEntry(transaction, subject_mangled, false, false);
241: 	}
242: 	if (existing_dependent) {
243: 		auto &existing = existing_dependent->Cast<DependencyEntry>();
244: 		auto existing_flags = existing.Dependent().flags;
245: 		if (existing_flags != dependent_flags) {
246: 			dependent_flags.Apply(existing_flags);
247: 		}
248: 		dependents.DropEntry(transaction, dependent_mangled, false, false);
249: 	}
250: 
251: 	// Create an entry in the dependents map of the object that is the target of the dependency
252: 	CreateDependent(transaction, info);
253: 	// Create an entry in the subjects map of the object that is targeting another entry
254: 	CreateSubject(transaction, info);
255: }
256: 
257: void DependencyManager::CreateDependencies(CatalogTransaction transaction, const CatalogEntry &object,
258:                                            const LogicalDependencyList &dependencies) {
259: 	DependencyDependentFlags dependency_flags;
260: 	if (object.type != CatalogType::INDEX_ENTRY) {
261: 		// indexes do not require CASCADE to be dropped, they are simply always dropped along with the table
262: 		dependency_flags.SetBlocking();
263: 	}
264: 
265: 	const auto object_info = GetLookupProperties(object);
266: 	// check for each object in the sources if they were not deleted yet
267: 	for (auto &dependency : dependencies.Set()) {
268: 		if (dependency.catalog != object.ParentCatalog().GetName()) {
269: 			throw DependencyException(
270: 			    "Error adding dependency for object \"%s\" - dependency \"%s\" is in catalog "
271: 			    "\"%s\", which does not match the catalog \"%s\".\nCross catalog dependencies are not supported.",
272: 			    object.name, dependency.entry.name, dependency.catalog, object.ParentCatalog().GetName());
273: 		}
274: 	}
275: 
276: 	// add the object to the dependents_map of each object that it depends on
277: 	for (auto &dependency : dependencies.Set()) {
278: 		DependencyInfo info {/*dependent = */ DependencyDependent {GetLookupProperties(object), dependency_flags},
279: 		                     /*subject = */ DependencySubject {dependency.entry, DependencySubjectFlags()}};
280: 		CreateDependency(transaction, info);
281: 	}
282: }
283: 
284: void DependencyManager::AddObject(CatalogTransaction transaction, CatalogEntry &object,
285:                                   const LogicalDependencyList &dependencies) {
286: 	if (IsSystemEntry(object)) {
287: 		// Don't do anything for this
288: 		return;
289: 	}
290: 	CreateDependencies(transaction, object, dependencies);
291: }
292: 
293: static bool CascadeDrop(bool cascade, const DependencyDependentFlags &flags) {
294: 	if (cascade) {
295: 		return true;
296: 	}
297: 	if (flags.IsOwnedBy()) {
298: 		// We are owned by this object, while it exists we can not be dropped without cascade.
299: 		return false;
300: 	}
301: 	return !flags.IsBlocking();
302: }
303: 
304: CatalogEntryInfo DependencyManager::GetLookupProperties(const CatalogEntry &entry) {
305: 	if (entry.type == CatalogType::DEPENDENCY_ENTRY) {
306: 		auto &dependency_entry = entry.Cast<DependencyEntry>();
307: 		return dependency_entry.EntryInfo();
308: 	} else {
309: 		auto schema = DependencyManager::GetSchema(entry);
310: 		auto &name = entry.name;
311: 		auto &type = entry.type;
312: 		return CatalogEntryInfo {type, schema, name};
313: 	}
314: }
315: 
316: optional_ptr<CatalogEntry> DependencyManager::LookupEntry(CatalogTransaction transaction, CatalogEntry &dependency) {
317: 	if (dependency.type != CatalogType::DEPENDENCY_ENTRY) {
318: 		return &dependency;
319: 	}
320: 	auto info = GetLookupProperties(dependency);
321: 
322: 	auto &type = info.type;
323: 	auto &schema = info.schema;
324: 	auto &name = info.name;
325: 
326: 	// Lookup the schema
327: 	auto schema_entry = catalog.GetSchema(transaction, schema, OnEntryNotFound::RETURN_NULL);
328: 	if (type == CatalogType::SCHEMA_ENTRY || !schema_entry) {
329: 		// This is a schema entry, perform the callback only providing the schema
330: 		return reinterpret_cast<CatalogEntry *>(schema_entry.get());
331: 	}
332: 	auto entry = schema_entry->GetEntry(transaction, type, name);
333: 	return entry;
334: }
335: 
336: void DependencyManager::CleanupDependencies(CatalogTransaction transaction, CatalogEntry &object) {
337: 	// Collect the dependencies
338: 	vector<DependencyInfo> to_remove;
339: 
340: 	auto info = GetLookupProperties(object);
341: 	ScanSubjects(transaction, info,
342: 	             [&](DependencyEntry &dep) { to_remove.push_back(DependencyInfo::FromSubject(dep)); });
343: 	ScanDependents(transaction, info,
344: 	               [&](DependencyEntry &dep) { to_remove.push_back(DependencyInfo::FromDependent(dep)); });
345: 
346: 	// Remove the dependency entries
347: 	for (auto &dep : to_remove) {
348: 		RemoveDependency(transaction, dep);
349: 	}
350: }
351: 
352: static string EntryToString(CatalogEntryInfo &info) {
353: 	auto type = info.type;
354: 	switch (type) {
355: 	case CatalogType::TABLE_ENTRY: {
356: 		return StringUtil::Format("table \"%s\"", info.name);
357: 	}
358: 	case CatalogType::SCHEMA_ENTRY: {
359: 		return StringUtil::Format("schema \"%s\"", info.name);
360: 	}
361: 	case CatalogType::VIEW_ENTRY: {
362: 		return StringUtil::Format("view \"%s\"", info.name);
363: 	}
364: 	case CatalogType::INDEX_ENTRY: {
365: 		return StringUtil::Format("index \"%s\"", info.name);
366: 	}
367: 	case CatalogType::SEQUENCE_ENTRY: {
368: 		return StringUtil::Format("index \"%s\"", info.name);
369: 	}
370: 	case CatalogType::COLLATION_ENTRY: {
371: 		return StringUtil::Format("collation \"%s\"", info.name);
372: 	}
373: 	case CatalogType::TYPE_ENTRY: {
374: 		return StringUtil::Format("type \"%s\"", info.name);
375: 	}
376: 	case CatalogType::TABLE_FUNCTION_ENTRY: {
377: 		return StringUtil::Format("table function \"%s\"", info.name);
378: 	}
379: 	case CatalogType::SCALAR_FUNCTION_ENTRY: {
380: 		return StringUtil::Format("scalar function \"%s\"", info.name);
381: 	}
382: 	case CatalogType::AGGREGATE_FUNCTION_ENTRY: {
383: 		return StringUtil::Format("aggregate function \"%s\"", info.name);
384: 	}
385: 	case CatalogType::PRAGMA_FUNCTION_ENTRY: {
386: 		return StringUtil::Format("pragma function \"%s\"", info.name);
387: 	}
388: 	case CatalogType::COPY_FUNCTION_ENTRY: {
389: 		return StringUtil::Format("copy function \"%s\"", info.name);
390: 	}
391: 	case CatalogType::MACRO_ENTRY: {
392: 		return StringUtil::Format("macro function \"%s\"", info.name);
393: 	}
394: 	case CatalogType::TABLE_MACRO_ENTRY: {
395: 		return StringUtil::Format("table macro function \"%s\"", info.name);
396: 	}
397: 	case CatalogType::SECRET_ENTRY: {
398: 		return StringUtil::Format("secret \"%s\"", info.name);
399: 	}
400: 	case CatalogType::SECRET_TYPE_ENTRY: {
401: 		return StringUtil::Format("secret type \"%s\"", info.name);
402: 	}
403: 	case CatalogType::SECRET_FUNCTION_ENTRY: {
404: 		return StringUtil::Format("secret function \"%s\"", info.name);
405: 	}
406: 	default:
407: 		throw InternalException("CatalogType not handled in EntryToString (DependencyManager) for %s",
408: 		                        CatalogTypeToString(type));
409: 	};
410: }
411: 
412: string DependencyManager::CollectDependents(CatalogTransaction transaction, catalog_entry_set_t &entries,
413:                                             CatalogEntryInfo &info) {
414: 	string result;
415: 	for (auto &entry : entries) {
416: 		D_ASSERT(!IsSystemEntry(entry.get()));
417: 		auto other_info = GetLookupProperties(entry);
418: 		result += StringUtil::Format("%s depends on %s.\n", EntryToString(other_info), EntryToString(info));
419: 		catalog_entry_set_t entry_dependents;
420: 		ScanDependents(transaction, other_info, [&](DependencyEntry &dep) {
421: 			auto child = LookupEntry(transaction, dep);
422: 			if (!child) {
423: 				return;
424: 			}
425: 			if (!CascadeDrop(false, dep.Dependent().flags)) {
426: 				entry_dependents.insert(*child);
427: 			}
428: 		});
429: 		if (!entry_dependents.empty()) {
430: 			result += CollectDependents(transaction, entry_dependents, other_info);
431: 		}
432: 	}
433: 	return result;
434: }
435: 
436: void DependencyManager::DropObject(CatalogTransaction transaction, CatalogEntry &object, bool cascade) {
437: 	if (IsSystemEntry(object)) {
438: 		// Don't do anything for this
439: 		return;
440: 	}
441: 
442: 	auto info = GetLookupProperties(object);
443: 	// Check if there are any entries that block the DROP because they still depend on the object
444: 	catalog_entry_set_t to_drop;
445: 
446: 	catalog_entry_set_t blocking_dependents;
447: 	ScanDependents(transaction, info, [&](DependencyEntry &dep) {
448: 		// It makes no sense to have a schema depend on anything
449: 		D_ASSERT(dep.EntryInfo().type != CatalogType::SCHEMA_ENTRY);
450: 		auto entry = LookupEntry(transaction, dep);
451: 		if (!entry) {
452: 			return;
453: 		}
454: 
455: 		if (!CascadeDrop(cascade, dep.Dependent().flags)) {
456: 			// no cascade and there are objects that depend on this object: throw error
457: 			blocking_dependents.insert(*entry);
458: 		} else {
459: 			to_drop.insert(*entry);
460: 		}
461: 	});
462: 	if (!blocking_dependents.empty()) {
463: 		string error_string =
464: 		    StringUtil::Format("Cannot drop entry \"%s\" because there are entries that depend on it.\n", object.name);
465: 		error_string += CollectDependents(transaction, blocking_dependents, info);
466: 		error_string += "Use DROP...CASCADE to drop all dependents.";
467: 		throw DependencyException(error_string);
468: 	}
469: 
470: 	ScanSubjects(transaction, info, [&](DependencyEntry &dep) {
471: 		auto flags = dep.Subject().flags;
472: 		if (flags.IsOwnership()) {
473: 			// We own this object, it should be dropped along with the table
474: 			auto entry = LookupEntry(transaction, dep);
475: 			to_drop.insert(*entry);
476: 		}
477: 	});
478: 
479: 	CleanupDependencies(transaction, object);
480: 
481: 	for (auto &entry : to_drop) {
482: 		auto set = entry.get().set;
483: 		D_ASSERT(set);
484: 		set->DropEntry(transaction, entry.get().name, cascade);
485: 	}
486: }
487: 
488: void DependencyManager::AlterObject(CatalogTransaction transaction, CatalogEntry &old_obj, CatalogEntry &new_obj,
489:                                     AlterInfo &alter_info) {
490: 	if (IsSystemEntry(new_obj)) {
491: 		D_ASSERT(IsSystemEntry(old_obj));
492: 		// Don't do anything for this
493: 		return;
494: 	}
495: 
496: 	const auto old_info = GetLookupProperties(old_obj);
497: 	const auto new_info = GetLookupProperties(new_obj);
498: 
499: 	vector<DependencyInfo> dependencies;
500: 	// Other entries that depend on us
501: 	ScanDependents(transaction, old_info, [&](DependencyEntry &dep) {
502: 		// It makes no sense to have a schema depend on anything
503: 		D_ASSERT(dep.EntryInfo().type != CatalogType::SCHEMA_ENTRY);
504: 
505: 		bool disallow_alter = true;
506: 		switch (alter_info.type) {
507: 		case AlterType::ALTER_TABLE: {
508: 			auto &alter_table = alter_info.Cast<AlterTableInfo>();
509: 			switch (alter_table.alter_table_type) {
510: 			case AlterTableType::FOREIGN_KEY_CONSTRAINT: {
511: 				// These alters are made as part of a CREATE or DROP table statement when a foreign key column is
512: 				// present either adding or removing a reference to the referenced primary key table
513: 				disallow_alter = false;
514: 				break;
515: 			}
516: 			default:
517: 				break;
518: 			}
519: 			break;
520: 		}
521: 		case AlterType::SET_COLUMN_COMMENT:
522: 		case AlterType::SET_COMMENT: {
523: 			disallow_alter = false;
524: 			break;
525: 		}
526: 		default:
527: 			break;
528: 		}
529: 		if (disallow_alter) {
530: 			throw DependencyException("Cannot alter entry \"%s\" because there are entries that "
531: 			                          "depend on it.",
532: 			                          old_obj.name);
533: 		}
534: 
535: 		auto dep_info = DependencyInfo::FromDependent(dep);
536: 		dep_info.subject.entry = new_info;
537: 		dependencies.emplace_back(dep_info);
538: 	});
539: 
540: 	// Keep old dependencies
541: 	dependency_set_t dependents;
542: 	ScanSubjects(transaction, old_info, [&](DependencyEntry &dep) {
543: 		auto entry = LookupEntry(transaction, dep);
544: 		if (!entry) {
545: 			return;
546: 		}
547: 
548: 		auto dep_info = DependencyInfo::FromSubject(dep);
549: 		dep_info.dependent.entry = new_info;
550: 		dependencies.emplace_back(dep_info);
551: 	});
552: 
553: 	// FIXME: we should update dependencies in the future
554: 	// some alters could cause dependencies to change (imagine types of table columns)
555: 	// or DEFAULT depending on a sequence
556: 	if (!StringUtil::CIEquals(old_obj.name, new_obj.name)) {
557: 		// The name has been changed, we need to recreate the dependency links
558: 		CleanupDependencies(transaction, old_obj);
559: 	}
560: 
561: 	// Reinstate the old dependencies
562: 	for (auto &dep : dependencies) {
563: 		CreateDependency(transaction, dep);
564: 	}
565: }
566: 
567: void DependencyManager::Scan(
568:     ClientContext &context,
569:     const std::function<void(CatalogEntry &, CatalogEntry &, const DependencyDependentFlags &)> &callback) {
570: 	auto transaction = catalog.GetCatalogTransaction(context);
571: 	lock_guard<mutex> write_lock(catalog.GetWriteLock());
572: 
573: 	// All the objects registered in the dependency manager
574: 	catalog_entry_set_t entries;
575: 	dependents.Scan(transaction, [&](CatalogEntry &set) {
576: 		auto entry = LookupEntry(transaction, set);
577: 		entries.insert(*entry);
578: 	});
579: 
580: 	// For every registered entry, get the dependents
581: 	for (auto &entry : entries) {
582: 		auto entry_info = GetLookupProperties(entry);
583: 		// Scan all the dependents of the entry
584: 		ScanDependents(transaction, entry_info, [&](DependencyEntry &dependent) {
585: 			auto dep = LookupEntry(transaction, dependent);
586: 			if (!dep) {
587: 				return;
588: 			}
589: 			auto &dependent_entry = *dep;
590: 			callback(entry, dependent_entry, dependent.Dependent().flags);
591: 		});
592: 	}
593: }
594: 
595: void DependencyManager::AddOwnership(CatalogTransaction transaction, CatalogEntry &owner, CatalogEntry &entry) {
596: 	if (IsSystemEntry(entry) || IsSystemEntry(owner)) {
597: 		return;
598: 	}
599: 
600: 	// If the owner is already owned by something else, throw an error
601: 	const auto owner_info = GetLookupProperties(owner);
602: 	ScanDependents(transaction, owner_info, [&](DependencyEntry &dep) {
603: 		if (dep.Dependent().flags.IsOwnedBy()) {
604: 			throw DependencyException("%s can not become the owner, it is already owned by %s", owner.name,
605: 			                          dep.EntryInfo().name);
606: 		}
607: 	});
608: 
609: 	// If the entry is the owner of another entry, throw an error
610: 	auto entry_info = GetLookupProperties(entry);
611: 	ScanSubjects(transaction, entry_info, [&](DependencyEntry &other) {
612: 		auto dependent_entry = LookupEntry(transaction, other);
613: 		if (!dependent_entry) {
614: 			return;
615: 		}
616: 		auto &dep = *dependent_entry;
617: 
618: 		auto flags = other.Dependent().flags;
619: 		if (!flags.IsOwnedBy()) {
620: 			return;
621: 		}
622: 		throw DependencyException("%s already owns %s. Cannot have circular dependencies", entry.name, dep.name);
623: 	});
624: 
625: 	// If the entry is already owned, throw an error
626: 	ScanDependents(transaction, entry_info, [&](DependencyEntry &other) {
627: 		auto dependent_entry = LookupEntry(transaction, other);
628: 		if (!dependent_entry) {
629: 			return;
630: 		}
631: 
632: 		auto &dep = *dependent_entry;
633: 		auto flags = other.Subject().flags;
634: 		if (!flags.IsOwnership()) {
635: 			return;
636: 		}
637: 		if (&dep != &owner) {
638: 			throw DependencyException("%s is already owned by %s", entry.name, dep.name);
639: 		}
640: 	});
641: 
642: 	DependencyInfo info {
643: 	    /*dependent = */ DependencyDependent {GetLookupProperties(owner), DependencyDependentFlags().SetOwnedBy()},
644: 	    /*subject = */ DependencySubject {GetLookupProperties(entry), DependencySubjectFlags().SetOwnership()}};
645: 	CreateDependency(transaction, info);
646: }
647: 
648: static string FormatString(const MangledEntryName &mangled) {
649: 	auto input = mangled.name;
650: 	for (size_t i = 0; i < input.size(); i++) {
651: 		if (input[i] == '\0') {
652: 			input[i] = '_';
653: 		}
654: 	}
655: 	return input;
656: }
657: 
658: void DependencyManager::PrintSubjects(CatalogTransaction transaction, const CatalogEntryInfo &info) {
659: 	auto name = MangleName(info);
660: 	Printer::Print(StringUtil::Format("Subjects of %s", FormatString(name)));
661: 	auto subjects = DependencyCatalogSet(Subjects(), info);
662: 	subjects.Scan(transaction, [&](CatalogEntry &dependency) {
663: 		auto &dep = dependency.Cast<DependencyEntry>();
664: 		auto &entry_info = dep.EntryInfo();
665: 		auto type = entry_info.type;
666: 		auto schema = entry_info.schema;
667: 		auto name = entry_info.name;
668: 		Printer::Print(StringUtil::Format("Schema: %s | Name: %s | Type: %s | Dependent type: %s | Subject type: %s",
669: 		                                  schema, name, CatalogTypeToString(type), dep.Dependent().flags.ToString(),
670: 		                                  dep.Subject().flags.ToString()));
671: 	});
672: }
673: 
674: void DependencyManager::PrintDependents(CatalogTransaction transaction, const CatalogEntryInfo &info) {
675: 	auto name = MangleName(info);
676: 	Printer::Print(StringUtil::Format("Dependents of %s", FormatString(name)));
677: 	auto dependents = DependencyCatalogSet(Dependents(), info);
678: 	dependents.Scan(transaction, [&](CatalogEntry &dependent) {
679: 		auto &dep = dependent.Cast<DependencyEntry>();
680: 		auto &entry_info = dep.EntryInfo();
681: 		auto type = entry_info.type;
682: 		auto schema = entry_info.schema;
683: 		auto name = entry_info.name;
684: 		Printer::Print(StringUtil::Format("Schema: %s | Name: %s | Type: %s | Dependent type: %s | Subject type: %s",
685: 		                                  schema, name, CatalogTypeToString(type), dep.Dependent().flags.ToString(),
686: 		                                  dep.Subject().flags.ToString()));
687: 	});
688: }
689: 
690: } // namespace duckdb
[end of src/catalog/dependency_manager.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: