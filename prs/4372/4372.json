{
  "repo": "duckdb/duckdb",
  "pull_number": 4372,
  "instance_id": "duckdb__duckdb-4372",
  "issue_numbers": [
    "4370",
    "4370"
  ],
  "base_commit": "ebe45abbb552d184dff9173c3412f63c173a0918",
  "patch": "diff --git a/src/function/scalar/list/list_sort.cpp b/src/function/scalar/list/list_sort.cpp\nindex 3a935d41421a..7c127b28213c 100644\n--- a/src/function/scalar/list/list_sort.cpp\n+++ b/src/function/scalar/list/list_sort.cpp\n@@ -90,6 +90,9 @@ void SinkDataChunk(Vector *child_vector, SelectionVector &sel, idx_t offset_list\n \tpayload_chunk.data[0].Reference(payload_vector);\n \tpayload_chunk.SetCardinality(offset_lists_indices);\n \n+\tkey_chunk.Verify();\n+\tpayload_chunk.Verify();\n+\n \t// sink\n \tlocal_sort_state.SinkChunk(key_chunk, payload_chunk);\n \tdata_to_sort = true;\n@@ -103,6 +106,7 @@ static void ListSortFunction(DataChunk &args, ExpressionState &state, Vector &re\n \tresult.SetVectorType(VectorType::FLAT_VECTOR);\n \tauto &result_validity = FlatVector::Validity(result);\n \n+\targs.Flatten();\n \tif (lists.GetType().id() == LogicalTypeId::SQLNULL) {\n \t\tresult_validity.SetInvalid(0);\n \t\treturn;\n@@ -150,7 +154,6 @@ static void ListSortFunction(DataChunk &args, ExpressionState &state, Vector &re\n \tbool data_to_sort = false;\n \n \tfor (idx_t i = 0; i < count; i++) {\n-\n \t\tauto lists_index = lists_data.sel->get_index(i);\n \t\tconst auto &list_entry = list_entries[lists_index];\n \n@@ -166,7 +169,6 @@ static void ListSortFunction(DataChunk &args, ExpressionState &state, Vector &re\n \t\t}\n \n \t\tfor (idx_t child_idx = 0; child_idx < list_entry.length; child_idx++) {\n-\n \t\t\t// lists_indices vector is full, sink\n \t\t\tif (offset_lists_indices == STANDARD_VECTOR_SIZE) {\n \t\t\t\tSinkDataChunk(&child_vector, sel, offset_lists_indices, info.types, info.payload_types, payload_vector,\n@@ -174,10 +176,10 @@ static void ListSortFunction(DataChunk &args, ExpressionState &state, Vector &re\n \t\t\t\toffset_lists_indices = 0;\n \t\t\t}\n \n-\t\t\tauto source_idx = child_data.sel->get_index(list_entry.offset + child_idx);\n+\t\t\tauto source_idx = list_entry.offset + child_idx;\n \t\t\tsel.set_index(offset_lists_indices, source_idx);\n \t\t\tlists_indices_data[offset_lists_indices] = (uint32_t)i;\n-\t\t\tpayload_vector_data[offset_lists_indices] = incr_payload_count;\n+\t\t\tpayload_vector_data[offset_lists_indices] = source_idx;\n \t\t\toffset_lists_indices++;\n \t\t\tincr_payload_count++;\n \t\t}\n@@ -189,7 +191,6 @@ static void ListSortFunction(DataChunk &args, ExpressionState &state, Vector &re\n \t}\n \n \tif (data_to_sort) {\n-\n \t\t// add local state to global state, which sorts the data\n \t\tglobal_sort_state.AddLocalState(local_sort_state);\n \t\tglobal_sort_state.PrepareMergePhase();\n@@ -216,6 +217,7 @@ static void ListSortFunction(DataChunk &args, ExpressionState &state, Vector &re\n \n \t\t\tfor (idx_t i = 0; i < row_count; i++) {\n \t\t\t\tsel_sorted.set_index(sel_sorted_idx, result_data[i]);\n+\t\t\t\tD_ASSERT(result_data[i] < lists_size);\n \t\t\t\tsel_sorted_idx++;\n \t\t\t}\n \t\t}\n",
  "test_patch": "diff --git a/test/sql/function/list/list_sort_having.test b/test/sql/function/list/list_sort_having.test\nnew file mode 100644\nindex 000000000000..901d34f5df23\n--- /dev/null\n+++ b/test/sql/function/list/list_sort_having.test\n@@ -0,0 +1,56 @@\n+# name: test/sql/function/list/list_sort_having.test\n+# description: Issue #4370: Random segmentation fault when using list_sort and having\n+# group: [list]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create or replace table test1 as (\n+    select 'new_customers' as child, 'dim_model_7' as parent\n+    union all select 'exposure_1' as child, 'dim_model_7' as parent\n+    union all select 'exposure_1' as child, 'exposure_1' as parent\n+    union all select 'fct_model_6' as child, 'fct_model_6' as parent\n+    union all select 'exposure_1' as child, 'fct_model_6' as parent\n+    union all select 'report_1' as child, 'fct_model_6' as parent\n+    union all select 'report_2' as child, 'fct_model_6' as parent\n+    union all select 'report_3' as child, 'fct_model_6' as parent\n+    union all select 'fct_model_9' as child, 'fct_model_9' as parent\n+    union all select 'stg_model_5' as child, 'fct_model_9' as parent\n+    union all select 'int_model_4' as child, 'int_model_4' as parent\n+    union all select 'int_model_5' as child, 'int_model_4' as parent\n+    union all select 'dim_model_7' as child, 'int_model_4' as parent\n+    union all select 'new_customers' as child, 'int_model_4' as parent\n+    union all select 'exposure_1' as child, 'int_model_4' as parent\n+    union all select 'int_model_5' as child, 'int_model_5' as parent\n+    union all select 'dim_model_7' as child, 'int_model_5' as parent\n+    union all select 'new_customers' as child, 'int_model_5' as parent\n+    union all select 'exposure_1' as child, 'int_model_5' as parent\n+    union all select 'model_8' as child, 'model_8' as parent\n+    union all select 'new_customers' as child, 'new_customers' as parent\n+    union all select 'report_1' as child, 'report_1' as parent\n+    union all select 'report_2' as child, 'report_2' as parent\n+    union all select 'report_3' as child, 'report_3' as parent\n+);\n+\n+query III rowsort\n+select\n+    child,\n+    count(*) as cnt,\n+    list_sort(\n+        list(\n+            parent\n+        )\n+    )\n+    as source_parents\n+from test1\n+group by 1\n+having cnt > 1;\n+----\n+dim_model_7\t2\t[int_model_4, int_model_5]\n+exposure_1\t5\t[dim_model_7, exposure_1, fct_model_6, int_model_4, int_model_5]\n+int_model_5\t2\t[int_model_4, int_model_5]\n+new_customers\t4\t[dim_model_7, int_model_4, int_model_5, new_customers]\n+report_1\t2\t[fct_model_6, report_1]\n+report_2\t2\t[fct_model_6, report_2]\n+report_3\t2\t[fct_model_6, report_3]\ndiff --git a/test/sql/function/list/list_sort_vector_types.test b/test/sql/function/list/list_sort_vector_types.test\nnew file mode 100644\nindex 000000000000..f4806109d276\n--- /dev/null\n+++ b/test/sql/function/list/list_sort_vector_types.test\n@@ -0,0 +1,26 @@\n+# name: test/sql/function/list/list_sort_vector_types.test\n+# description: Test list sort with different vector types\n+# group: [list]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+foreach flatten true false\n+\n+query I rowsort sortintarray\n+SELECT list_sort(l) FROM test_vector_types(NULL::INT[], ${flatten}) tbl(l)\n+----\n+\n+query I rowsort sortnestedintarray\n+SELECT list_sort(l) FROM test_vector_types(NULL::INT[][], ${flatten}) tbl(l)\n+----\n+\n+query I rowsort sortvarchararray\n+SELECT list_sort(l) FROM test_vector_types(NULL::VARCHAR[], ${flatten}) tbl(l)\n+----\n+\n+query I rowsort sortnestedvarchararray\n+SELECT list_sort(l) FROM test_vector_types(NULL::VARCHAR[][], ${flatten}) tbl(l)\n+----\n+\n+endloop\ndiff --git a/tools/rpkg/tests/testthat/test_arrow.R b/tools/rpkg/tests/testthat/test_arrow.R\nindex 2a2e372c229e..67fd5c0a7043 100644\n--- a/tools/rpkg/tests/testthat/test_arrow.R\n+++ b/tools/rpkg/tests/testthat/test_arrow.R\n@@ -60,14 +60,14 @@ test_that(\"to_duckdb\", {\n       select(int, lgl, dbl) %>%\n       to_duckdb(con = con) %>%\n       group_by(lgl) %>%\n-      summarise(mean_int = mean(int, na.rm = TRUE), mean_dbl = mean(dbl, na.rm = TRUE)) %>%\n+      summarise(sum_int = sum(int, na.rm = TRUE)) %>%\n       collect() %>%\n-      arrange(mean_int),\n+      arrange(sum_int),\n     example_data %>%\n       select(int, lgl, dbl) %>%\n       group_by(lgl) %>%\n-      summarise(mean_int = mean(int, na.rm = TRUE), mean_dbl = mean(dbl, na.rm = TRUE)) %>%\n-      arrange(mean_int)\n+      summarise(sum_int = sum(int, na.rm = TRUE)) %>%\n+      arrange(sum_int)\n   )\n \n   # can group_by before the to_duckdb\n@@ -76,14 +76,14 @@ test_that(\"to_duckdb\", {\n       select(int, lgl, dbl) %>%\n       group_by(lgl) %>%\n       to_duckdb(con = con) %>%\n-      summarise(mean_int = mean(int, na.rm = TRUE), mean_dbl = mean(dbl, na.rm = TRUE)) %>%\n+      summarise(sum_int = sum(int, na.rm = TRUE)) %>%\n       collect() %>%\n-      arrange(mean_int),\n+      arrange(sum_int),\n     example_data %>%\n       select(int, lgl, dbl) %>%\n       group_by(lgl) %>%\n-      summarise(mean_int = mean(int, na.rm = TRUE), mean_dbl = mean(dbl, na.rm = TRUE)) %>%\n-      arrange(mean_int)\n+      summarise(sum_int = sum(int, na.rm = TRUE)) %>%\n+      arrange(sum_int)\n   )\n })\n \n",
  "problem_statement": "Random `segmentation fault` when using `list_sort` and `having`\n### What happens?\n\nWhen running the queries from below the results are inconsistent and randomly (about 50% of the time return some `segmentation fault`).\r\n\r\nIf I remove the `having` clause the query works as expected.\n\n### To Reproduce\n\n```sql\r\ncreate or replace table test1 as (\r\n    select 'new_customers' as child, 'dim_model_7' as parent\r\n    union all select 'exposure_1' as child, 'dim_model_7' as parent\r\n    union all select 'exposure_1' as child, 'exposure_1' as parent\r\n    union all select 'fct_model_6' as child, 'fct_model_6' as parent\r\n    union all select 'exposure_1' as child, 'fct_model_6' as parent\r\n    union all select 'report_1' as child, 'fct_model_6' as parent\r\n    union all select 'report_2' as child, 'fct_model_6' as parent\r\n    union all select 'report_3' as child, 'fct_model_6' as parent\r\n    union all select 'fct_model_9' as child, 'fct_model_9' as parent\r\n    union all select 'stg_model_5' as child, 'fct_model_9' as parent\r\n    union all select 'int_model_4' as child, 'int_model_4' as parent\r\n    union all select 'int_model_5' as child, 'int_model_4' as parent\r\n    union all select 'dim_model_7' as child, 'int_model_4' as parent\r\n    union all select 'new_customers' as child, 'int_model_4' as parent\r\n    union all select 'exposure_1' as child, 'int_model_4' as parent\r\n    union all select 'int_model_5' as child, 'int_model_5' as parent\r\n    union all select 'dim_model_7' as child, 'int_model_5' as parent\r\n    union all select 'new_customers' as child, 'int_model_5' as parent\r\n    union all select 'exposure_1' as child, 'int_model_5' as parent\r\n    union all select 'model_8' as child, 'model_8' as parent\r\n    union all select 'new_customers' as child, 'new_customers' as parent\r\n    union all select 'report_1' as child, 'report_1' as parent\r\n    union all select 'report_2' as child, 'report_2' as parent\r\n    union all select 'report_3' as child, 'report_3' as parent\r\n);\r\n\r\n\r\nselect\r\n    child,\r\n    count(*) as cnt,\r\n    \r\n    list_sort(\r\n        list(\r\n            parent\r\n        )\r\n    )\r\n\r\n    as source_parents\r\nfrom test1\r\ngroup by 1\r\nhaving cnt > 1;\r\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\nv0.4.0 da9ee490d\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nBenoit Perigaud\n\n### Affiliation:\n\ndbt Labs\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nRandom `segmentation fault` when using `list_sort` and `having`\n### What happens?\n\nWhen running the queries from below the results are inconsistent and randomly (about 50% of the time return some `segmentation fault`).\r\n\r\nIf I remove the `having` clause the query works as expected.\n\n### To Reproduce\n\n```sql\r\ncreate or replace table test1 as (\r\n    select 'new_customers' as child, 'dim_model_7' as parent\r\n    union all select 'exposure_1' as child, 'dim_model_7' as parent\r\n    union all select 'exposure_1' as child, 'exposure_1' as parent\r\n    union all select 'fct_model_6' as child, 'fct_model_6' as parent\r\n    union all select 'exposure_1' as child, 'fct_model_6' as parent\r\n    union all select 'report_1' as child, 'fct_model_6' as parent\r\n    union all select 'report_2' as child, 'fct_model_6' as parent\r\n    union all select 'report_3' as child, 'fct_model_6' as parent\r\n    union all select 'fct_model_9' as child, 'fct_model_9' as parent\r\n    union all select 'stg_model_5' as child, 'fct_model_9' as parent\r\n    union all select 'int_model_4' as child, 'int_model_4' as parent\r\n    union all select 'int_model_5' as child, 'int_model_4' as parent\r\n    union all select 'dim_model_7' as child, 'int_model_4' as parent\r\n    union all select 'new_customers' as child, 'int_model_4' as parent\r\n    union all select 'exposure_1' as child, 'int_model_4' as parent\r\n    union all select 'int_model_5' as child, 'int_model_5' as parent\r\n    union all select 'dim_model_7' as child, 'int_model_5' as parent\r\n    union all select 'new_customers' as child, 'int_model_5' as parent\r\n    union all select 'exposure_1' as child, 'int_model_5' as parent\r\n    union all select 'model_8' as child, 'model_8' as parent\r\n    union all select 'new_customers' as child, 'new_customers' as parent\r\n    union all select 'report_1' as child, 'report_1' as parent\r\n    union all select 'report_2' as child, 'report_2' as parent\r\n    union all select 'report_3' as child, 'report_3' as parent\r\n);\r\n\r\n\r\nselect\r\n    child,\r\n    count(*) as cnt,\r\n    \r\n    list_sort(\r\n        list(\r\n            parent\r\n        )\r\n    )\r\n\r\n    as source_parents\r\nfrom test1\r\ngroup by 1\r\nhaving cnt > 1;\r\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\nv0.4.0 da9ee490d\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nBenoit Perigaud\n\n### Affiliation:\n\ndbt Labs\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "\n",
  "created_at": "2022-08-13T08:08:34Z"
}