{
  "repo": "duckdb/duckdb",
  "pull_number": 14623,
  "instance_id": "duckdb__duckdb-14623",
  "issue_numbers": [
    "14601"
  ],
  "base_commit": "79bf967e1b6ab438e0a83a014e937af571ed7acb",
  "patch": "diff --git a/src/execution/operator/persistent/physical_export.cpp b/src/execution/operator/persistent/physical_export.cpp\nindex 2e0f4bbf4fb4..733b01f76551 100644\n--- a/src/execution/operator/persistent/physical_export.cpp\n+++ b/src/execution/operator/persistent/physical_export.cpp\n@@ -127,6 +127,10 @@ void PhysicalExport::ExtractEntries(ClientContext &context, vector<reference<Sch\n                                     ExportEntries &result) {\n \tfor (auto &schema_p : schema_list) {\n \t\tauto &schema = schema_p.get();\n+\t\tauto &catalog = schema.ParentCatalog();\n+\t\tif (catalog.IsSystemCatalog() || catalog.IsTemporaryCatalog()) {\n+\t\t\tcontinue;\n+\t\t}\n \t\tif (!schema.internal) {\n \t\t\tresult.schemas.push_back(schema);\n \t\t}\ndiff --git a/src/parser/transform/statement/transform_pivot_stmt.cpp b/src/parser/transform/statement/transform_pivot_stmt.cpp\nindex fee41aada399..8b798a83c9fb 100644\n--- a/src/parser/transform/statement/transform_pivot_stmt.cpp\n+++ b/src/parser/transform/statement/transform_pivot_stmt.cpp\n@@ -15,6 +15,7 @@\n #include \"duckdb/parser/expression/function_expression.hpp\"\n #include \"duckdb/parser/result_modifier.hpp\"\n #include \"duckdb/parser/tableref/subqueryref.hpp\"\n+#include \"duckdb/common/types/uuid.hpp\"\n \n namespace duckdb {\n \n@@ -168,7 +169,6 @@ unique_ptr<QueryNode> Transformer::TransformPivotStatement(duckdb_libpgquery::PG\n \t// generate CREATE TYPE statements for each of the columns that do not have an IN list\n \tbool is_pivot = !pivot->unpivots;\n \tauto columns = TransformPivotList(*pivot->columns, is_pivot);\n-\tauto pivot_idx = PivotEntryCount();\n \tfor (idx_t c = 0; c < columns.size(); c++) {\n \t\tauto &col = columns[c];\n \t\tif (!col.pivot_enum.empty() || !col.entries.empty()) {\n@@ -177,7 +177,7 @@ unique_ptr<QueryNode> Transformer::TransformPivotStatement(duckdb_libpgquery::PG\n \t\tif (col.pivot_expressions.size() != 1) {\n \t\t\tthrow InternalException(\"PIVOT statement with multiple names in pivot entry!?\");\n \t\t}\n-\t\tauto enum_name = \"__pivot_enum_\" + std::to_string(pivot_idx) + \"_\" + std::to_string(c);\n+\t\tauto enum_name = \"__pivot_enum_\" + UUID::ToString(UUID::GenerateRandomUUID());\n \n \t\tauto new_select = make_uniq<SelectNode>();\n \t\tExtractCTEsRecursive(new_select->cte_map);\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/relational_api/test_pivot.py b/tools/pythonpkg/tests/fast/relational_api/test_pivot.py\nnew file mode 100644\nindex 000000000000..d78df656d6dd\n--- /dev/null\n+++ b/tools/pythonpkg/tests/fast/relational_api/test_pivot.py\n@@ -0,0 +1,30 @@\n+import duckdb\n+import pytest\n+import os\n+import tempfile\n+\n+\n+class TestPivot(object):\n+    def test_pivot_issue_14600(self, duckdb_cursor):\n+        duckdb_cursor.sql(\n+            \"create table input_data as select unnest(['u','v','w']) as a, unnest(['x','y','z']) as b, unnest([1,2,3]) as c;\"\n+        )\n+        pivot_1 = duckdb_cursor.query(\"pivot input_data on a using max(c) group by b;\")\n+        pivot_2 = duckdb_cursor.query(\"pivot input_data on b using max(c) group by a;\")\n+        pivot_1.create(\"pivot_1\")\n+        pivot_2.create(\"pivot_2\")\n+        pivot_1_tbl = duckdb_cursor.table(\"pivot_1\")\n+        pivot_2_tbl = duckdb_cursor.table(\"pivot_2\")\n+        assert set(pivot_1.columns) == set(pivot_1_tbl.columns)\n+        assert set(pivot_2.columns) == set(pivot_2_tbl.columns)\n+\n+    def test_pivot_issue_14601(self, duckdb_cursor):\n+        duckdb_cursor.sql(\n+            \"create table input_data as select unnest(['u','v','w']) as a, unnest(['x','y','z']) as b, unnest([1,2,3]) as c;\"\n+        )\n+        pivot_1 = duckdb_cursor.query(\"pivot input_data on a using max(c) group by b;\")\n+        pivot_1.create(\"pivot_1\")\n+        export_dir = tempfile.mkdtemp()\n+        duckdb_cursor.query(f\"EXPORT DATABASE '{export_dir}'\")\n+        with open(os.path.join(export_dir, \"schema.sql\"), \"r\") as f:\n+            assert 'CREATE TYPE' not in f.read()\n",
  "problem_statement": "import + pivot + export creates un-importable dump \n### What happens?\r\n\r\nIf you create a table from a pivot command, export the db, import it again elsewhere, do another pivot, then export again, the exported database will not be importable because of a bug in the schema.sql wherein there are multiple lines that start with `CREATE TYPE __pivot_enum_0_0 AS ENUM`\r\n\r\n### To Reproduce\r\n\r\n```py\r\n# demonstrate bug\r\nimport numpy as np\r\nimport pandas as pd\r\nimport duckdb\r\nfrom pathlib import Path\r\n\r\nTEMP_PATH0 = \"/tmp/duckdemo0\"\r\nTEMP_PATH1 = \"/tmp/duckdemo1\"\r\nN = 1000\r\ndf = pd.DataFrame({\"a\":np.random.choice([\"u\", \"v\", \"w\"], N, True),\r\n                   \"b\":np.random.choice([\"x\", \"y\", \"z\"], N, True),\r\n                   \"c\":np.random.randn(N),})\r\nconn0 = duckdb.connect(\":memory:0\")\r\n\r\nddf = conn0.from_df(df)\r\nddf.create(\"input_data\")\r\n\r\nxx = conn0.query(\"pivot input_data on a using max(c) group by b;\")\r\nxx.create(\"xx\")\r\nconn0.execute(f\"EXPORT DATABASE '{TEMP_PATH0}'  (FORMAT PARQUET);\")\r\nconn1 = duckdb.connect(\":memory:1\")\r\nconn1.execute(f\"IMPORT DATABASE '{TEMP_PATH0}';\")\r\nyy = conn1.query(\"pivot input_data on b using max(c) group by a;\")\r\nyy.create(\"yy\")\r\nconn1.execute(f\"EXPORT DATABASE '{TEMP_PATH1}'  (FORMAT PARQUET);\")\r\nwith (Path(TEMP_PATH1) / \"schema.sql\").open(\"r\") as f:\r\n    print(f.read())\r\n\r\n# CREATE TYPE __pivot_enum_0_0 AS ENUM ( 'x', 'y', 'z' );\r\n# CREATE TYPE __pivot_enum_0_0 AS ENUM ( 'u', 'v', 'w' );\r\n\r\n# CREATE TABLE input_data(a VARCHAR, b VARCHAR, c DOUBLE);\r\n# CREATE TABLE xx(b VARCHAR, u DOUBLE, v DOUBLE, w DOUBLE);\r\n# CREATE TABLE yy(a VARCHAR, x DOUBLE, y DOUBLE, z DOUBLE);\r\n\r\n# Renames the pivot type. Breaks importing even though it's never used.\r\n\r\nconn2 = duckdb.connect(\":memory:2\")\r\nconn2.execute(f\"IMPORT DATABASE '{TEMP_PATH1}';\")\r\n# Fails with message:\r\n# CatalogException: Catalog Error: Type with name \"__pivot_enum_0_0\" already exists!\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu 22.04.5 LTS x86_64\r\n\r\n### DuckDB Version:\r\n\r\n1.1.1\r\n\r\n### DuckDB Client:\r\n\r\npython\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nMichael Hankin\r\n\r\n### Affiliation:\r\n\r\nMothball Labs\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have not tested with any build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-10-29T21:17:41Z"
}