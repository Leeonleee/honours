You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Long string with double apostrophe becomes empty string
#### What happens?
A long string with an apostrophe becomes an empty string.

#### To Reproduce
```sql
CREATE TABLE j2 (id INT, json VARCHAR, src VARCHAR);
INSERT INTO j2(id,json,src)
    VALUES(3,'[
    {
        "id": "0001",
        "type": "donut",
        "name": "Cake",
        "ppu": 0.55,
        "batters":
            {
                "batter":
                    [
                        { "id": "1001", "type": "Regular" },
                        { "id": "1002", "type": "Chocolate" },
                        { "id": "1003", "type": "Blueberry" },
                        { "id": "1004", "type": "Devil''s Food" }
                    ]
            },
        "topping":
            [
                { "id": "5001", "type": "None" },
                { "id": "5002", "type": "Glazed" },
                { "id": "5005", "type": "Sugar" },
                { "id": "5007", "type": "Powdered Sugar" },
                { "id": "5006", "type": "Chocolate with Sprinkles" },
                { "id": "5003", "type": "Chocolate" },
                { "id": "5004", "type": "Maple" }
            ]
    },
    {
        "id": "0002",
        "type": "donut",
        "name": "Raised",
        "ppu": 0.55,
        "batters":
            {
                "batter":
                    [
                        { "id": "1001", "type": "Regular" }
                    ]
            },
        "topping":
            [
                { "id": "5001", "type": "None" },
                { "id": "5002", "type": "Glazed" },
                { "id": "5005", "type": "Sugar" },
                { "id": "5003", "type": "Chocolate" },
                { "id": "5004", "type": "Maple" }
            ]
    },
    {
        "id": "0003",
        "type": "donut",
        "name": "Old Fashioned",
        "ppu": 0.55,
        "batters":
            {
                "batter":
                    [
                        { "id": "1001", "type": "Regular" },
                        { "id": "1002", "type": "Chocolate" }
                    ]
            },
        "topping":
            [
                { "id": "5001", "type": "None" },
                { "id": "5002", "type": "Glazed" },
                { "id": "5003", "type": "Chocolate" },
                { "id": "5004", "type": "Maple" }
            ]
    }
    ]','https://adobe.github.io/Spry/samples/data_region/JSONDataSetSample.html');
SELECT json = '' FROM j2;
-- true
```
We would expect the query to return `false`.

The bug does not occur when I remove the `''` from `"Devil''s Food"`.
The bug also does not appear when the string is much shorter, e.g.:
```sql
CREATE TABLE j2 (id INT, json VARCHAR, src VARCHAR);
INSERT INTO j2(id,json,src)
    VALUES(3,'[
    {
        "id": "0001",
        "type": "donut",
        "name": "Cake",
        "ppu": 0.55,
        "batters":
            {
                "batter":
                    [
                        { "id": "1001", "type": "Regular" },
                        { "id": "1002", "type": "Chocolate" },
                        { "id": "1003", "type": "Blueberry" },
                        { "id": "1004", "type": "Devil''s Food" }
                    ]
            },
        "topping":
            [
                { "id": "5001", "type": "None" },
                { "id": "5002", "type": "Glazed" },
                { "id": "5005", "type": "Sugar" },
                { "id": "5007", "type": "Powdered Sugar" },
                { "id": "5006", "type": "Chocolate with Sprinkles" },
                { "id": "5003", "type": "Chocolate" },
                { "id": "5004", "type": "Maple" }
            ]
    }
    ]','https://adobe.github.io/Spry/samples/data_region/JSONDataSetSample.html');
SELECT json = '' FROM j2;
-- false
```

The string is stored correctly. I ran the same query in Postgres to see if it has something to do with the parser, but there it worked fine.

#### Environment (please complete the following information):
 - OS: macOS
 - DuckDB Version: master
 - DuckDB Client: CLI

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

Long string with double apostrophe becomes empty string
#### What happens?
A long string with an apostrophe becomes an empty string.

#### To Reproduce
```sql
CREATE TABLE j2 (id INT, json VARCHAR, src VARCHAR);
INSERT INTO j2(id,json,src)
    VALUES(3,'[
    {
        "id": "0001",
        "type": "donut",
        "name": "Cake",
        "ppu": 0.55,
        "batters":
            {
                "batter":
                    [
                        { "id": "1001", "type": "Regular" },
                        { "id": "1002", "type": "Chocolate" },
                        { "id": "1003", "type": "Blueberry" },
                        { "id": "1004", "type": "Devil''s Food" }
                    ]
            },
        "topping":
            [
                { "id": "5001", "type": "None" },
                { "id": "5002", "type": "Glazed" },
                { "id": "5005", "type": "Sugar" },
                { "id": "5007", "type": "Powdered Sugar" },
                { "id": "5006", "type": "Chocolate with Sprinkles" },
                { "id": "5003", "type": "Chocolate" },
                { "id": "5004", "type": "Maple" }
            ]
    },
    {
        "id": "0002",
        "type": "donut",
        "name": "Raised",
        "ppu": 0.55,
        "batters":
            {
                "batter":
                    [
                        { "id": "1001", "type": "Regular" }
                    ]
            },
        "topping":
            [
                { "id": "5001", "type": "None" },
                { "id": "5002", "type": "Glazed" },
                { "id": "5005", "type": "Sugar" },
                { "id": "5003", "type": "Chocolate" },
                { "id": "5004", "type": "Maple" }
            ]
    },
    {
        "id": "0003",
        "type": "donut",
        "name": "Old Fashioned",
        "ppu": 0.55,
        "batters":
            {
                "batter":
                    [
                        { "id": "1001", "type": "Regular" },
                        { "id": "1002", "type": "Chocolate" }
                    ]
            },
        "topping":
            [
                { "id": "5001", "type": "None" },
                { "id": "5002", "type": "Glazed" },
                { "id": "5003", "type": "Chocolate" },
                { "id": "5004", "type": "Maple" }
            ]
    }
    ]','https://adobe.github.io/Spry/samples/data_region/JSONDataSetSample.html');
SELECT json = '' FROM j2;
-- true
```
We would expect the query to return `false`.

The bug does not occur when I remove the `''` from `"Devil''s Food"`.
The bug also does not appear when the string is much shorter, e.g.:
```sql
CREATE TABLE j2 (id INT, json VARCHAR, src VARCHAR);
INSERT INTO j2(id,json,src)
    VALUES(3,'[
    {
        "id": "0001",
        "type": "donut",
        "name": "Cake",
        "ppu": 0.55,
        "batters":
            {
                "batter":
                    [
                        { "id": "1001", "type": "Regular" },
                        { "id": "1002", "type": "Chocolate" },
                        { "id": "1003", "type": "Blueberry" },
                        { "id": "1004", "type": "Devil''s Food" }
                    ]
            },
        "topping":
            [
                { "id": "5001", "type": "None" },
                { "id": "5002", "type": "Glazed" },
                { "id": "5005", "type": "Sugar" },
                { "id": "5007", "type": "Powdered Sugar" },
                { "id": "5006", "type": "Chocolate with Sprinkles" },
                { "id": "5003", "type": "Chocolate" },
                { "id": "5004", "type": "Maple" }
            ]
    }
    ]','https://adobe.github.io/Spry/samples/data_region/JSONDataSetSample.html');
SELECT json = '' FROM j2;
-- false
```

The string is stored correctly. I ran the same query in Postgres to see if it has something to do with the parser, but there it worked fine.

#### Environment (please complete the following information):
 - OS: macOS
 - DuckDB Version: master
 - DuckDB Client: CLI

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of third_party/libpg_query/pg_functions.cpp]
1: #include <stdexcept>
2: #include <string>
3: #include <thread>
4: #include <mutex>
5: #include "pg_functions.hpp"
6: #include "parser/parser.hpp"
7: #include <stdarg.h>
8: #include <mutex>
9: #include <cstring>
10: 
11: 
12: // max parse tree size approx 100 MB, should be enough
13: #define PG_MALLOC_SIZE 10240
14: 
15: namespace duckdb_libpgquery {
16: 
17: typedef struct pg_parser_state_str parser_state;
18: struct pg_parser_state_str {
19: 	int pg_err_code;
20: 	int pg_err_pos;
21: 	char pg_err_msg[BUFSIZ];
22: 
23: 	size_t malloc_pos;
24: 	size_t malloc_ptr_idx;
25: 	char **malloc_ptrs;
26: 	size_t malloc_ptr_size;
27: };
28: 
29: static __thread parser_state pg_parser_state;
30: 
31: #ifndef __GNUC__
32: __thread PGNode *duckdb_newNodeMacroHolder;
33: #endif
34: 
35: static void allocate_new(parser_state *state, size_t n) {
36: 	if (state->malloc_ptr_idx >= state->malloc_ptr_size) {
37: 		size_t new_size = state->malloc_ptr_size * 2;
38: 		auto new_malloc_ptrs = (char **) malloc(sizeof(char *) * new_size);
39: 		memcpy(new_malloc_ptrs, state->malloc_ptrs, state->malloc_ptr_size * sizeof(char*));
40: 		free(state->malloc_ptrs);
41: 		state->malloc_ptr_size = new_size;
42: 		state->malloc_ptrs = new_malloc_ptrs;
43: 	}
44: 	if (n < PG_MALLOC_SIZE) {
45: 		n = PG_MALLOC_SIZE;
46: 	}
47: 	char *base_ptr = (char *)malloc(n);
48: 	if (!base_ptr) {
49: 		throw std::runtime_error("Memory allocation failure");
50: 	}
51: 	state->malloc_ptrs[state->malloc_ptr_idx] = base_ptr;
52: 	state->malloc_ptr_idx++;
53: 	state->malloc_pos = 0;
54: }
55: 
56: void *palloc(size_t n) {
57: 	// we need to align our pointers for the sanitizer
58: 	auto aligned_n = ((n + 7) / 8) * 8;
59: 	if (pg_parser_state.malloc_pos + aligned_n > PG_MALLOC_SIZE) {
60: 		allocate_new(&pg_parser_state, aligned_n);
61: 	}
62: 
63: 	void *ptr = pg_parser_state.malloc_ptrs[pg_parser_state.malloc_ptr_idx - 1] + pg_parser_state.malloc_pos;
64: 	memset(ptr, 0, n);
65: 	pg_parser_state.malloc_pos += aligned_n;
66: 	return ptr;
67: }
68: 
69: void pg_parser_init() {
70: 	pg_parser_state.pg_err_code = PGUNDEFINED;
71: 	pg_parser_state.pg_err_msg[0] = '\0';
72: 
73: 	pg_parser_state.malloc_ptr_size = 4;
74: 	pg_parser_state.malloc_ptrs = (char **) malloc(sizeof(char *) * pg_parser_state.malloc_ptr_size);
75: 	pg_parser_state.malloc_ptr_idx = 0;
76: 	allocate_new(&pg_parser_state, 1);
77: }
78: 
79: void pg_parser_parse(const char *query, parse_result *res) {
80: 	res->parse_tree = nullptr;
81: 	try {
82: 		res->parse_tree = duckdb_libpgquery::raw_parser(query);
83: 		res->success = pg_parser_state.pg_err_code == PGUNDEFINED;
84: 	} catch (std::exception &ex) {
85: 		res->success = false;
86: 		// copy the error message of the exception
87: 		auto error_message = ex.what();
88: 		uint32_t pos = 0;
89: 		while(pos < 1023 && error_message[pos]) {
90: 			pg_parser_state.pg_err_msg[pos] = error_message[pos];
91: 			pos++;
92: 		}
93: 		pg_parser_state.pg_err_msg[pos] = '\0';
94: 	}
95: 	res->error_message = pg_parser_state.pg_err_msg;
96: 	res->error_location = pg_parser_state.pg_err_pos;
97: }
98: 
99: void pg_parser_cleanup() {
100: 	for (size_t ptr_idx = 0; ptr_idx < pg_parser_state.malloc_ptr_idx; ptr_idx++) {
101: 		char *ptr = pg_parser_state.malloc_ptrs[ptr_idx];
102: 		if (ptr) {
103: 			free(ptr);
104: 			pg_parser_state.malloc_ptrs[ptr_idx] = nullptr;
105: 		}
106: 	}
107: 	free(pg_parser_state.malloc_ptrs);
108: }
109: 
110: int ereport(int code, ...) {
111: 	std::string err = "parser error : " + std::string(pg_parser_state.pg_err_msg);
112: 	throw std::runtime_error(err);
113: }
114: void elog(int code, const char *fmt, ...) {
115: 	throw std::runtime_error("elog NOT IMPLEMENTED");
116: }
117: int errcode(int sqlerrcode) {
118: 	pg_parser_state.pg_err_code = sqlerrcode;
119: 	return 1;
120: }
121: int errmsg(const char *fmt, ...) {
122: 	va_list argptr;
123: 	va_start(argptr, fmt);
124: 	vsnprintf(pg_parser_state.pg_err_msg, BUFSIZ, fmt, argptr);
125: 	va_end(argptr);
126: 	return 1;
127: }
128: int errhint(const char *msg) {
129: 	throw std::runtime_error("errhint NOT IMPLEMENTED");
130: }
131: int errmsg_internal(const char *fmt, ...) {
132: 	throw std::runtime_error("errmsg_internal NOT IMPLEMENTED");
133: }
134: int errdetail(const char *fmt, ...) {
135: 	throw std::runtime_error("errdetail NOT IMPLEMENTED");
136: }
137: int errposition(int cursorpos) {
138: 	pg_parser_state.pg_err_pos = cursorpos;
139: 	return 1;
140: }
141: 
142: char *psprintf(const char *fmt, ...) {
143: 	char buf[BUFSIZ];
144: 	va_list args;
145: 	size_t newlen;
146: 
147: 	// attempt one: use stack buffer and determine length
148: 	va_start(args, fmt);
149: 	newlen = vsnprintf(buf, BUFSIZ, fmt, args);
150: 	va_end(args);
151: 	if (newlen < BUFSIZ) {
152: 		return pstrdup(buf);
153: 	}
154: 
155: 	// attempt two, malloc
156: 	char *mbuf = (char *)palloc(newlen);
157: 	va_start(args, fmt);
158: 	vsnprintf(mbuf, newlen, fmt, args);
159: 	va_end(args);
160: 	return mbuf;
161: }
162: 
163: char *pstrdup(const char *in) {
164: 	char *new_str = (char *)palloc(strlen(in) + 1);
165: 	memcpy(new_str, in, strlen(in));
166: 	return new_str;
167: }
168: 
169: void pfree(void *ptr) {
170: 	// nop, we free up entire context on parser cleanup
171: }
172: void *palloc0fast(size_t n) { // very fast
173: 	return palloc(n);
174: }
175: void *repalloc(void *ptr, size_t n) {
176: 	return palloc(n);
177: }
178: char *NameListToString(PGList *names) {
179: 	throw std::runtime_error("NameListToString NOT IMPLEMENTED");
180: }
181: void *copyObject(const void *from) {
182: 	throw std::runtime_error("copyObject NOT IMPLEMENTED");
183: }
184: bool equal(const void *a, const void *b) {
185: 	throw std::runtime_error("equal NOT IMPLEMENTED");
186: }
187: int exprLocation(const PGNode *expr) {
188: 	throw std::runtime_error("exprLocation NOT IMPLEMENTED");
189: }
190: bool pg_verifymbstr(const char *mbstr, int len, bool noError) {
191: 	throw std::runtime_error("pg_verifymbstr NOT IMPLEMENTED");
192: }
193: 
194: int pg_database_encoding_max_length(void) {
195: 	return 4; // UTF8
196: }
197: 
198: static int pg_utf_mblen(const unsigned char *s) {
199: 	int len;
200: 
201: 	if ((*s & 0x80) == 0)
202: 		len = 1;
203: 	else if ((*s & 0xe0) == 0xc0)
204: 		len = 2;
205: 	else if ((*s & 0xf0) == 0xe0)
206: 		len = 3;
207: 	else if ((*s & 0xf8) == 0xf0)
208: 		len = 4;
209: #ifdef NOT_USED
210: 	else if ((*s & 0xfc) == 0xf8)
211: 		len = 5;
212: 	else if ((*s & 0xfe) == 0xfc)
213: 		len = 6;
214: #endif
215: 	else
216: 		len = 1;
217: 	return len;
218: }
219: 
220: int pg_mbstrlen_with_len(const char *mbstr, int limit) {
221: 	int len = 0;
222: 	while (limit > 0 && *mbstr) {
223: 		int l = pg_utf_mblen((const unsigned char *)mbstr);
224: 		limit -= l;
225: 		mbstr += l;
226: 		len++;
227: 	}
228: 	return len;
229: }
230: 
231: int pg_mbcliplen(const char *mbstr, int len, int limit) {
232: 	throw std::runtime_error("pg_mbcliplen NOT IMPLEMENTED");
233: }
234: int pg_mblen(const char *mbstr) {
235: 	throw std::runtime_error("pg_mblen NOT IMPLEMENTED");
236: }
237: PGDefElem *defWithOids(bool value) {
238: 	throw std::runtime_error("defWithOids NOT IMPLEMENTED");
239: }
240: unsigned char *unicode_to_utf8(pg_wchar c, unsigned char *utf8string) {
241: 	throw std::runtime_error("unicode_to_utf8 NOT IMPLEMENTED");
242: }
243: 
244: // this replaces a brain damaged macro in nodes.hpp
245: PGNode *newNode(size_t size, PGNodeTag type) {
246: 	auto result = (PGNode *)palloc0fast(size);
247: 	result->type = type;
248: 	return result;
249: }
250: }
[end of third_party/libpg_query/pg_functions.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: