{
  "repo": "duckdb/duckdb",
  "pull_number": 1044,
  "instance_id": "duckdb__duckdb-1044",
  "issue_numbers": [
    "1043"
  ],
  "base_commit": "a3dce6e82915ff3ede4f61faaae2b903b119c35d",
  "patch": "diff --git a/tools/pythonpkg/duckdb_python.cpp b/tools/pythonpkg/duckdb_python.cpp\nindex b75a39d3d11c..e200cbc8c61e 100644\n--- a/tools/pythonpkg/duckdb_python.cpp\n+++ b/tools/pythonpkg/duckdb_python.cpp\n@@ -171,7 +171,8 @@ enum class PandasType : uint8_t {\n };\n \n struct PandasScanFunctionData : public TableFunctionData {\n-\tPandasScanFunctionData(py::handle df, idx_t row_count, vector<PandasType> pandas_types_, vector<LogicalType> sql_types_)\n+\tPandasScanFunctionData(py::handle df, idx_t row_count, vector<PandasType> pandas_types_,\n+\t                       vector<LogicalType> sql_types_)\n \t    : df(df), row_count(row_count), pandas_types(move(pandas_types_)), sql_types(move(sql_types_)) {\n \t}\n \tpy::handle df;\n@@ -283,7 +284,8 @@ struct PandasScanFunction : public TableFunction {\n \t\tFlatVector::SetData(out, (data_ptr_t)(src_ptr + offset));\n \t}\n \n-\ttemplate <class T> static void scan_pandas_numeric_object(py::array numpy_col, idx_t count, idx_t offset, Vector &out) {\n+\ttemplate <class T>\n+\tstatic void scan_pandas_numeric_object(py::array numpy_col, idx_t count, idx_t offset, Vector &out) {\n \t\tauto src_ptr = (PyObject **)numpy_col.data();\n \t\tauto tgt_ptr = FlatVector::GetData<T>(out);\n \t\tauto &nullmask = FlatVector::Nullmask(out);\n@@ -967,13 +969,18 @@ struct DuckDBPyConnection {\n \tvoid close() {\n \t\tconnection = nullptr;\n \t\tdatabase = nullptr;\n+\t\tfor (auto &cur : cursors) {\n+\t\t\tcur->close();\n+\t\t}\n+\t\tcursors.clear();\n \t}\n \n \t// cursor() is stupid\n-\tunique_ptr<DuckDBPyConnection> cursor() {\n-\t\tauto res = make_unique<DuckDBPyConnection>();\n+\tshared_ptr<DuckDBPyConnection> cursor() {\n+\t\tauto res = make_shared<DuckDBPyConnection>();\n \t\tres->database = database;\n \t\tres->connection = make_unique<Connection>(*res->database);\n+\t\tcursors.push_back(res);\n \t\treturn res;\n \t}\n \n@@ -1011,8 +1018,8 @@ struct DuckDBPyConnection {\n \t\treturn result->fetch_arrow_table();\n \t}\n \n-\tstatic unique_ptr<DuckDBPyConnection> connect(string database, bool read_only) {\n-\t\tauto res = make_unique<DuckDBPyConnection>();\n+\tstatic shared_ptr<DuckDBPyConnection> connect(string database, bool read_only) {\n+\t\tauto res = make_shared<DuckDBPyConnection>();\n \t\tDBConfig config;\n \t\tif (read_only)\n \t\t\tconfig.access_mode = AccessMode::READ_ONLY;\n@@ -1035,6 +1042,7 @@ struct DuckDBPyConnection {\n \tunique_ptr<Connection> connection;\n \tunordered_map<string, py::object> registered_dfs;\n \tunique_ptr<DuckDBPyResult> result;\n+\tvector<shared_ptr<DuckDBPyConnection>> cursors;\n \n \tstatic vector<Value> transform_python_param_list(py::handle params) {\n \t\tvector<Value> args;\n@@ -1087,7 +1095,7 @@ struct DuckDBPyConnection {\n \t}\n };\n \n-static unique_ptr<DuckDBPyConnection> default_connection_ = nullptr;\n+static shared_ptr<DuckDBPyConnection> default_connection_ = nullptr;\n \n static DuckDBPyConnection *default_connection() {\n \tif (!default_connection_) {\n@@ -1304,7 +1312,7 @@ PYBIND11_MODULE(duckdb, m) {\n \t      py::arg(\"database\") = \":memory:\", py::arg(\"read_only\") = false);\n \n \tauto conn_class =\n-\t    py::class_<DuckDBPyConnection>(m, \"DuckDBPyConnection\")\n+\t    py::class_<DuckDBPyConnection, shared_ptr<DuckDBPyConnection>>(m, \"DuckDBPyConnection\")\n \t        .def(\"cursor\", &DuckDBPyConnection::cursor, \"Create a duplicate of the current connection\")\n \t        .def(\"duplicate\", &DuckDBPyConnection::cursor, \"Create a duplicate of the current connection\")\n \t        .def(\"execute\", &DuckDBPyConnection::execute,\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/test_connection_close.py b/tools/pythonpkg/tests/test_connection_close.py\nnew file mode 100644\nindex 000000000000..48f851aef2ae\n--- /dev/null\n+++ b/tools/pythonpkg/tests/test_connection_close.py\n@@ -0,0 +1,25 @@\n+# cursor description\n+\n+import duckdb\n+import tempfile\n+import os\n+\n+def check_exception(f):\n+    had_exception = False\n+    try:\n+        f()\n+    except BaseException:\n+        had_exception = True\n+    assert(had_exception)\n+\n+class TestConnectionClose(object):\n+    def test_connection_close(self, duckdb_cursor):\n+        fd, db = tempfile.mkstemp()\n+        os.close(fd)\n+        os.remove(db)\n+        con = duckdb.connect(db)\n+        cursor = con.cursor()\n+        cursor.execute(\"create table a (i integer)\")\n+        cursor.execute(\"insert into a values (42)\")\n+        con.close()\n+        check_exception(lambda :cursor.execute(\"select * from a\"))\n",
  "problem_statement": "Python: Calling `close()` on a Connection should invalidate any cursors using that connection\nPer PEP-249, [calling close on a Connection object should invalidate any further queries on any cursor objects that use that connection.](https://www.python.org/dev/peps/pep-0249/#Connection.close) This isn't currently true in DuckDB b/c the `cursor` method returns a brand new and independent instance of the `DuckDBPyConnection` class.\r\n\r\nThis ends up being a problem in the [test harness](https://github.com/fishtown-analytics/dbt-adapter-tests/) I'm using to iterate on dbt-duckdb, because of the following sequence:\r\n\r\n1) The test harness opens a connection to the database (and a number of cursors) via the Python API to setup the test,\r\n2) The test harness then forks a separate instance of `dbt` that runs the desired command, but when `dbt` attempts to connect to the database, it can't because the other process has the write lock on the file for the WAL.\r\n\r\nI've been hacking around this by being careful about making sure that cursors are closed when they're no longer in use, but it's limiting my ability to use some useful tools that aren't quite as careful as I am, so I wrote a PR to fix this in a minimalist way that I will post shortly.\n",
  "hints_text": "",
  "created_at": "2020-10-23T04:53:00Z"
}