You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Unexpected result when using `LEFT JOIN`
### What happens?

Consider the below test case. The third query returns an unexpected result since the expression `t0.c1 < t2.c1` cannot be evaluated as `true` or `NULL` at the same time. 

### To Reproduce

```sql
CREATE  TABLE  t2(c1 INTEGER);
CREATE  TABLE  t0(c1 DOUBLE);
INSERT INTO t0(c1) VALUES ( 0.1);
INSERT INTO t2(c1) VALUES (2);

SELECT * FROM t2 LEFT  JOIN t0 ON true; -- 2 0.1
SELECT * FROM t2 LEFT  JOIN t0 ON true WHERE (t0.c1<t2.c1); -- 2 0.1
SELECT * FROM t2 LEFT  JOIN t0 ON true WHERE ((t0.c1<t2.c1) IS NULL);
-- Expected: empty result set
-- Actual: 2 0.1

```

### OS:

Ubuntu 22.04

### DuckDB Version:

v1.3.0-dev2262 589e10ae54

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

Suyang Zhong

### Affiliation:

NUS

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a source build

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [x] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/stable/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/stable/clients/cli/overview) and has clients for [Python](https://duckdb.org/docs/stable/clients/python/overview), [R](https://duckdb.org/docs/stable/clients/r), [Java](https://duckdb.org/docs/stable/clients/java), [Wasm](https://duckdb.org/docs/stable/clients/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdb.org/docs/stable/clients/r#duckplyr-dplyr-api).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/stable/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/stable/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/stable/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/docs/stable/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/optimizer/pushdown/pushdown_left_join.cpp]
1: #include "duckdb/common/assert.hpp"
2: #include "duckdb/common/enums/join_type.hpp"
3: #include "duckdb/common/helper.hpp"
4: #include "duckdb/common/typedefs.hpp"
5: #include "duckdb/common/types.hpp"
6: #include "duckdb/common/types/value.hpp"
7: #include "duckdb/common/unique_ptr.hpp"
8: #include "duckdb/common/unordered_map.hpp"
9: #include "duckdb/common/vector.hpp"
10: #include "duckdb/execution/expression_executor.hpp"
11: #include "duckdb/optimizer/filter_pushdown.hpp"
12: #include "duckdb/optimizer/optimizer.hpp"
13: #include "duckdb/planner/binder.hpp"
14: #include "duckdb/planner/column_binding.hpp"
15: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
16: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
17: #include "duckdb/planner/expression/bound_constant_expression.hpp"
18: #include "duckdb/planner/expression_iterator.hpp"
19: #include "duckdb/planner/joinside.hpp"
20: #include "duckdb/planner/logical_operator.hpp"
21: #include "duckdb/planner/operator/logical_any_join.hpp"
22: #include "duckdb/planner/operator/logical_comparison_join.hpp"
23: #include "duckdb/planner/operator/logical_cross_product.hpp"
24: #include "duckdb/planner/operator/logical_dummy_scan.hpp"
25: #include "duckdb/planner/operator/logical_filter.hpp"
26: #include "duckdb/planner/operator/logical_projection.hpp"
27: #include <utility>
28: 
29: namespace duckdb {
30: 
31: using Filter = FilterPushdown::Filter;
32: 
33: static unique_ptr<Expression> ReplaceColRefWithNull(unique_ptr<Expression> expr, unordered_set<idx_t> &right_bindings) {
34: 	if (expr->GetExpressionType() == ExpressionType::BOUND_COLUMN_REF) {
35: 		auto &bound_colref = expr->Cast<BoundColumnRefExpression>();
36: 		if (right_bindings.find(bound_colref.binding.table_index) != right_bindings.end()) {
37: 			// bound colref belongs to RHS
38: 			// replace it with a constant NULL
39: 			return make_uniq<BoundConstantExpression>(Value(expr->return_type));
40: 		}
41: 		return expr;
42: 	}
43: 	ExpressionIterator::EnumerateChildren(
44: 	    *expr, [&](unique_ptr<Expression> &child) { child = ReplaceColRefWithNull(std::move(child), right_bindings); });
45: 	return expr;
46: }
47: 
48: static bool FilterRemovesNull(ClientContext &context, ExpressionRewriter &rewriter, Expression *expr,
49:                               unordered_set<idx_t> &right_bindings) {
50: 	// make a copy of the expression
51: 	auto copy = expr->Copy();
52: 	// replace all BoundColumnRef expressions from the RHS with NULL constants in the copied expression
53: 	copy = ReplaceColRefWithNull(std::move(copy), right_bindings);
54: 
55: 	// attempt to flatten the expression by running the expression rewriter on it
56: 	auto filter = make_uniq<LogicalFilter>();
57: 	filter->expressions.push_back(std::move(copy));
58: 	rewriter.VisitOperator(*filter);
59: 
60: 	// check if all expressions are foldable
61: 	for (idx_t i = 0; i < filter->expressions.size(); i++) {
62: 		if (!filter->expressions[i]->IsFoldable()) {
63: 			return false;
64: 		}
65: 		// we flattened the result into a scalar, check if it is FALSE or NULL
66: 		auto val =
67: 		    ExpressionExecutor::EvaluateScalar(context, *filter->expressions[i]).DefaultCastAs(LogicalType::BOOLEAN);
68: 		// if the result of the expression with all expressions replaced with NULL is "NULL" or "false"
69: 		// then any extra entries generated by the LEFT OUTER JOIN will be filtered out!
70: 		// hence the LEFT OUTER JOIN is equivalent to an inner join
71: 		if (val.IsNull() || !BooleanValue::Get(val)) {
72: 			return true;
73: 		}
74: 	}
75: 	return false;
76: }
77: 
78: unique_ptr<LogicalOperator> FilterPushdown::PushdownLeftJoin(unique_ptr<LogicalOperator> op,
79:                                                              unordered_set<idx_t> &left_bindings,
80:                                                              unordered_set<idx_t> &right_bindings) {
81: 	auto &join = op->Cast<LogicalJoin>();
82: 	if (op->type == LogicalOperatorType::LOGICAL_DELIM_JOIN) {
83: 		return FinishPushdown(std::move(op));
84: 	}
85: 	FilterPushdown left_pushdown(optimizer, convert_mark_joins), right_pushdown(optimizer, convert_mark_joins);
86: 	// for a comparison join we create a FilterCombiner that checks if we can push conditions on LHS join conditions
87: 	// into the RHS of the join
88: 	FilterCombiner filter_combiner(optimizer);
89: 	const auto isComparison = (op->type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN ||
90: 	                           op->type == LogicalOperatorType::LOGICAL_ASOF_JOIN);
91: 	if (isComparison) {
92: 		// add all comparison conditions
93: 		auto &comparison_join = op->Cast<LogicalComparisonJoin>();
94: 		for (auto &cond : comparison_join.conditions) {
95: 			filter_combiner.AddFilter(
96: 			    make_uniq<BoundComparisonExpression>(cond.comparison, cond.left->Copy(), cond.right->Copy()));
97: 		}
98: 	}
99: 	// now check the set of filters
100: 	vector<unique_ptr<Filter>> remaining_filters;
101: 	for (idx_t i = 0; i < filters.size(); i++) {
102: 		auto side = JoinSide::GetJoinSide(filters[i]->bindings, left_bindings, right_bindings);
103: 		if (side == JoinSide::LEFT) {
104: 			// bindings match left side
105: 			// we can push the filter into the left side
106: 			if (isComparison) {
107: 				// we MIGHT be able to push it down the RHS as well, but only if it is a comparison that matches the
108: 				// join predicates we use the FilterCombiner to figure this out add the expression to the FilterCombiner
109: 				filter_combiner.AddFilter(filters[i]->filter->Copy());
110: 			}
111: 			left_pushdown.filters.push_back(std::move(filters[i]));
112: 			// erase the filter from the list of filters
113: 			filters.erase_at(i);
114: 			i--;
115: 		} else if (op->type != LogicalOperatorType::LOGICAL_ASOF_JOIN) {
116: 			// bindings match right side or both sides: we cannot directly push it into the right
117: 			// however, if the filter removes rows with null values from the RHS we can turn the left outer join
118: 			// in an inner join, and then push down as we would push down an inner join
119: 			// Edit: This is only possible if the bindings match BOTH sides, so the filter can be pushed down to both
120: 			// children. If the filter can only be applied to the right side, and the filter filters
121: 			// all tuples, then the inner join cannot be converted.
122: 			if (FilterRemovesNull(optimizer.context, optimizer.rewriter, filters[i]->filter.get(), right_bindings)) {
123: 				// the filter removes NULL values, turn it into an inner join
124: 				join.join_type = JoinType::INNER;
125: 				// now we can do more pushdown
126: 				// move all filters we added to the left_pushdown back into the filter list
127: 				for (auto &left_filter : left_pushdown.filters) {
128: 					filters.push_back(std::move(left_filter));
129: 				}
130: 				// now push down the inner join
131: 				return PushdownInnerJoin(std::move(op), left_bindings, right_bindings);
132: 			}
133: 			// we should keep the filters which only matched the right side
134: 			if (side == JoinSide::RIGHT) {
135: 				remaining_filters.push_back(std::move(filters[i]));
136: 				filters.erase_at(i);
137: 				i--;
138: 			}
139: 		}
140: 	}
141: 	// finally we check the FilterCombiner to see if there are any predicates we can push into the RHS
142: 	// we only added (1) predicates that have JoinSide::BOTH from the conditions, and
143: 	// (2) predicates that have JoinSide::LEFT from the filters
144: 	// we check now if this combination generated any new filters that are only on JoinSide::RIGHT
145: 	// this happens if, e.g. a join condition is (i=a) and there is a filter (i=500), we can then push the filter
146: 	// (a=500) into the RHS
147: 	filter_combiner.GenerateFilters([&](unique_ptr<Expression> filter) {
148: 		if (JoinSide::GetJoinSide(*filter, left_bindings, right_bindings) == JoinSide::RIGHT) {
149: 			right_pushdown.AddFilter(std::move(filter));
150: 		}
151: 	});
152: 	right_pushdown.GenerateFilters();
153: 	op->children[0] = left_pushdown.Rewrite(std::move(op->children[0]));
154: 
155: 	bool rewrite_right = true;
156: 	if (op->type == LogicalOperatorType::LOGICAL_ANY_JOIN) {
157: 		auto &any_join = join.Cast<LogicalAnyJoin>();
158: 		if (AddFilter(any_join.condition->Copy()) == FilterResult::UNSATISFIABLE) {
159: 			// filter statically evaluates to false, turns it to the cross product join with 1 row NULLs
160: 			if (any_join.join_type == JoinType::LEFT) {
161: 				unordered_map<idx_t, vector<unique_ptr<Expression>>> projections_groups;
162: 				auto column_bindings = op->children[1]->GetColumnBindings();
163: 				op->children[1]->ResolveOperatorTypes();
164: 				auto &types = op->children[1]->types;
165: 				for (idx_t i = 0; i < column_bindings.size(); i++) {
166: 					projections_groups[column_bindings[i].table_index].emplace_back(
167: 					    make_uniq<BoundConstantExpression>(Value(types[i])));
168: 				}
169: 
170: 				auto create_proj_dummy_scan = [&](idx_t table_index) {
171: 					auto dummy_scan = make_uniq<LogicalDummyScan>(optimizer.binder.GenerateTableIndex());
172: 					auto proj = make_uniq<LogicalProjection>(table_index, std::move(projections_groups[table_index]));
173: 					proj->AddChild(std::move(dummy_scan));
174: 					return proj;
175: 				};
176: 				// make cross products on the RHS first
177: 				auto begin = projections_groups.begin();
178: 				D_ASSERT(begin != projections_groups.end());
179: 				unique_ptr<LogicalOperator> left = create_proj_dummy_scan(begin->first);
180: 				projections_groups.erase(begin);
181: 				for (auto &group : projections_groups) {
182: 					auto proj = create_proj_dummy_scan(group.first);
183: 					auto op = LogicalCrossProduct::Create(std::move(left), std::move(proj));
184: 					left = std::move(op);
185: 				}
186: 				// then make cross product with the LHS
187: 				op = LogicalCrossProduct::Create(std::move(op->children[0]), std::move(left));
188: 				rewrite_right = false;
189: 			}
190: 		}
191: 	}
192: 
193: 	if (rewrite_right) {
194: 		op->children[1] = right_pushdown.Rewrite(std::move(op->children[1]));
195: 	}
196: 
197: 	for (auto &filter : remaining_filters) {
198: 		filters.push_back(std::move(filter));
199: 	}
200: 
201: 	return PushFinalFilters(std::move(op));
202: }
203: 
204: } // namespace duckdb
[end of src/optimizer/pushdown/pushdown_left_join.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: