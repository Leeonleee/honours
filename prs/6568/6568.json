{
  "repo": "duckdb/duckdb",
  "pull_number": 6568,
  "instance_id": "duckdb__duckdb-6568",
  "issue_numbers": [
    "6442"
  ],
  "base_commit": "65a9ad239bd1f66029b401d2d505997464d04ff0",
  "patch": "diff --git a/.github/workflows/Python.yml b/.github/workflows/Python.yml\nindex 0d0c4b604d42..05397285bd32 100644\n--- a/.github/workflows/Python.yml\n+++ b/.github/workflows/Python.yml\n@@ -403,7 +403,8 @@ jobs:\n       - name: Install Python Test Dependencies\n         shell: bash\n         run: |\n-          ${GITHUB_WORKSPACE}/debug-build/bin/python3 -m pip install numpy pandas pyarrow pytest psutil\n+          cd tools/pythonpkg\n+          ${GITHUB_WORKSPACE}/debug-build/bin/python3 -m pip install -r requirements-dev.txt\n \n       - name: Install DuckDB Python\n         shell: bash\ndiff --git a/tools/pythonpkg/duckdb-stubs/__init__.pyi b/tools/pythonpkg/duckdb-stubs/__init__.pyi\nindex a1ce64f2cbee..5a6f2e832829 100644\n--- a/tools/pythonpkg/duckdb-stubs/__init__.pyi\n+++ b/tools/pythonpkg/duckdb-stubs/__init__.pyi\n@@ -6,8 +6,9 @@\n import typing\n # stubgen override - missing import of Set\n from typing import Any, ClassVar, Set, Optional\n+from io import StringIO, TextIOBase\n \n-from typing import overload, Dict, List\n+from typing import overload, Dict, List, Union\n import pandas\n # stubgen override - unfortunately we need this for version checks\n import sys\n@@ -76,7 +77,7 @@ class DuckDBPyConnection:\n     ) -> DuckDBPyRelation: ...\n     def read_csv(\n         self,\n-        name: str,\n+        path_or_buffer: Union[str, StringIO, TextIOBase],\n         header: Optional[bool | int] = None,\n         compression: Optional[str] = None,\n         sep: Optional[str] = None,\n@@ -133,6 +134,7 @@ class DuckDBPyConnection:\n     def get_table_names(self, query: str) -> Set[str]: ...\n     def install_extension(self, *args, **kwargs) -> None: ...\n     def list_filesystems(self) -> list: ...\n+    def filesystem_is_registered(self, name: str) -> bool: ...\n     def load_extension(self, extension: str) -> None: ...\n     def pl(self, chunk_size: int = ..., connection: DuckDBPyConnection = ...) -> polars.DataFrame: ...\n     def torch(self, connection: DuckDBPyConnection = ...) -> dict: ...\n@@ -369,7 +371,7 @@ def read_json(\n     connection: DuckDBPyConnection = ...\n ) -> DuckDBPyRelation: ...\n def read_csv(\n-    name: str,\n+    path_or_buffer: Union[str, StringIO, TextIOBase],\n     header: Optional[bool | int] = None,\n     compression: Optional[str] = None,\n     sep: Optional[str] = None,\n@@ -448,6 +450,7 @@ def get_substrait_json(query: str, connection: DuckDBPyConnection = ...) -> Duck\n def get_table_names(query: str, connection: DuckDBPyConnection = ...) -> Set[str]: ...\n def install_extension(*args, connection: DuckDBPyConnection = ..., **kwargs) -> None: ...\n def list_filesystems(connection: DuckDBPyConnection = ...) -> list: ...\n+def filesystem_is_registered(name: str, connection: DuckDBPyConnection = ...) -> bool: ...\n def load_extension(extension: str, connection: DuckDBPyConnection = ...) -> None: ...\n def pl(chunk_size: int = ..., connection: DuckDBPyConnection = ...) -> polars.DataFrame: ...\n def torch(connection: DuckDBPyConnection = ...) -> dict: ...\ndiff --git a/tools/pythonpkg/duckdb_python.cpp b/tools/pythonpkg/duckdb_python.cpp\nindex dfdd6fd3ae63..f831241c1a87 100644\n--- a/tools/pythonpkg/duckdb_python.cpp\n+++ b/tools/pythonpkg/duckdb_python.cpp\n@@ -183,7 +183,10 @@ static void InitializeConnectionMethods(py::module_ &m) {\n \t    .def(\"unregister_filesystem\", &PyConnectionWrapper::UnregisterFilesystem, \"Unregister a filesystem\",\n \t         py::arg(\"name\"), py::arg(\"connection\") = py::none())\n \t    .def(\"list_filesystems\", &PyConnectionWrapper::ListFilesystems,\n-\t         \"List registered filesystems, including builtin ones\", py::arg(\"connection\") = py::none());\n+\t         \"List registered filesystems, including builtin ones\", py::arg(\"connection\") = py::none())\n+\t    .def(\"filesystem_is_registered\", &PyConnectionWrapper::FileSystemIsRegistered,\n+\t         \"Check if a filesystem with the provided name is currently registered\", py::arg(\"name\"),\n+\t         py::arg(\"connection\") = py::none());\n }\n \n PYBIND11_MODULE(DUCKDB_PYTHON_LIB_NAME, m) {\ndiff --git a/tools/pythonpkg/pyduckdb/bytes_io_wrapper.py b/tools/pythonpkg/pyduckdb/bytes_io_wrapper.py\nnew file mode 100644\nindex 000000000000..000314c8abf8\n--- /dev/null\n+++ b/tools/pythonpkg/pyduckdb/bytes_io_wrapper.py\n@@ -0,0 +1,64 @@\n+from io import StringIO, TextIOBase\n+from typing import Union\n+\n+\"\"\"\n+BSD 3-Clause License\n+\n+Copyright (c) 2008-2011, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team\n+All rights reserved.\n+\n+Copyright (c) 2011-2022, Open source contributors.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are met:\n+\n+* Redistributions of source code must retain the above copyright notice, this\n+  list of conditions and the following disclaimer.\n+\n+* Redistributions in binary form must reproduce the above copyright notice,\n+  this list of conditions and the following disclaimer in the documentation\n+  and/or other materials provided with the distribution.\n+\n+* Neither the name of the copyright holder nor the names of its\n+  contributors may be used to endorse or promote products derived from\n+  this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\"\"\"\n+\n+class BytesIOWrapper:\n+\t# Wrapper that wraps a StringIO buffer and reads bytes from it\n+\t# Created for compat with pyarrow read_csv\n+\tdef __init__(self, buffer: Union[StringIO, TextIOBase], encoding: str = \"utf-8\") -> None:\n+\t\tself.buffer = buffer\n+\t\tself.encoding = encoding\n+\t\t# Because a character can be represented by more than 1 byte,\n+\t\t# it is possible that reading will produce more bytes than n\n+\t\t# We store the extra bytes in this overflow variable, and append the\n+\t\t# overflow to the front of the bytestring the next time reading is performed\n+\t\tself.overflow = b\"\"\n+\n+\tdef __getattr__(self, attr: str):\n+\t\treturn getattr(self.buffer, attr)\n+\n+\tdef read(self, n: Union[int, None] = -1) -> bytes:\n+\t\tassert self.buffer is not None\n+\t\tbytestring = self.buffer.read(n).encode(self.encoding)\n+\t\t#When n=-1/n greater than remaining bytes: Read entire file/rest of file\n+\t\tcombined_bytestring = self.overflow + bytestring\n+\t\tif n is None or n < 0 or n >= len(combined_bytestring):\n+\t\t\tself.overflow = b\"\"\n+\t\t\treturn combined_bytestring\n+\t\telse:\n+\t\t\tto_return = combined_bytestring[:n]\n+\t\t\tself.overflow = combined_bytestring[n:]\n+\t\t\treturn to_return\ndiff --git a/tools/pythonpkg/pyduckdb/filesystem.py b/tools/pythonpkg/pyduckdb/filesystem.py\nnew file mode 100644\nindex 000000000000..57216a97a59c\n--- /dev/null\n+++ b/tools/pythonpkg/pyduckdb/filesystem.py\n@@ -0,0 +1,62 @@\n+from fsspec import filesystem, AbstractFileSystem\n+from fsspec.implementations.memory import MemoryFileSystem\n+from shutil import copyfileobj\n+from .bytes_io_wrapper import BytesIOWrapper\n+from io import TextIOBase\n+\n+def is_file_like(obj):\n+\t# We only care that we can read from the file\n+\treturn hasattr(obj, \"read\") and hasattr(obj, \"seek\")\n+\n+class ModifiedMemoryFileSystem(MemoryFileSystem):\n+\tprotocol = ('DUCKDB_INTERNAL_OBJECTSTORE',)\n+\t# defer to the original implementation that doesn't hardcode the protocol\n+\t_strip_protocol = classmethod(AbstractFileSystem._strip_protocol.__func__)\n+\n+\t# Add this manually because it's apparently missing on windows???\n+\tdef unstrip_protocol(self, name):\n+\t\t\"\"\"Format FS-specific path to generic, including protocol\"\"\"\n+\t\tprotos = (self.protocol,) if isinstance(self.protocol, str) else self.protocol\n+\t\tfor protocol in protos:\n+\t\t\tif name.startswith(f\"{protocol}://\"):\n+\t\t\t\treturn name\n+\t\treturn f\"{protos[0]}://{name}\"\n+\n+\tdef info(self, path, **kwargs):\n+\t\tpath = self._strip_protocol(path)\n+\t\tif path in self.store:\n+\t\t\tfilelike = self.store[path]\n+\t\t\treturn {\n+\t\t\t\t\"name\": path,\n+\t\t\t\t\"size\": getattr(filelike, \"size\", 0),\n+\t\t\t\t\"type\": \"file\",\n+\t\t\t\t\"created\": getattr(filelike, \"created\", None),\n+\t\t\t}\n+\t\telse:\n+\t\t\traise FileNotFoundError(path)\n+\n+\tdef _open(\n+\t\tself,\n+\t\tpath,\n+\t\tmode=\"rb\",\n+\t\tblock_size=None,\n+\t\tautocommit=True,\n+\t\tcache_options=None,\n+\t\t**kwargs,\n+\t):\n+\t\tpath = self._strip_protocol(path)\n+\t\tif path in self.store:\n+\t\t\tf = self.store[path]\n+\t\t\treturn f\n+\t\telse:\n+\t\t\traise FileNotFoundError(path)\n+\n+\tdef add_file(self, object, path):\n+\t\tif not is_file_like(object):\n+\t\t\traise ValueError(\"Can not read from a non file-like object\")\n+\t\tpath = self._strip_protocol(path)\n+\t\tif isinstance(object, TextIOBase):\n+\t\t\t# Wrap this so that we can return a bytes object from 'read'\n+\t\t\tself.store[path] = BytesIOWrapper(object)\n+\t\telse:\n+\t\t\tself.store[path] = object\ndiff --git a/tools/pythonpkg/setup.py b/tools/pythonpkg/setup.py\nindex b631d2502e1f..27d548db540d 100755\n--- a/tools/pythonpkg/setup.py\n+++ b/tools/pythonpkg/setup.py\n@@ -286,6 +286,7 @@ def setup_data_files(data_files):\n     license='MIT',\n     data_files = data_files,\n     packages=[\n+\t\t'pyduckdb',\n         'duckdb_query_graph',\n         'duckdb-stubs'\n     ],\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp b/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\nindex efa646a976e6..a102a4bef922 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\n@@ -93,7 +93,7 @@ class PyConnectionWrapper {\n \t                                             const py::object &sample_size = py::none(),\n \t                                             const py::object &maximum_depth = py::none());\n \tstatic unique_ptr<DuckDBPyRelation>\n-\tReadCSV(const string &name, shared_ptr<DuckDBPyConnection> conn, const py::object &header = py::none(),\n+\tReadCSV(const py::object &name, shared_ptr<DuckDBPyConnection> conn, const py::object &header = py::none(),\n \t        const py::object &compression = py::none(), const py::object &sep = py::none(),\n \t        const py::object &delimiter = py::none(), const py::object &dtype = py::none(),\n \t        const py::object &na_values = py::none(), const py::object &skiprows = py::none(),\n@@ -126,5 +126,6 @@ class PyConnectionWrapper {\n \tstatic void RegisterFilesystem(AbstractFileSystem file_system, shared_ptr<DuckDBPyConnection> conn);\n \tstatic void UnregisterFilesystem(const py::str &name, shared_ptr<DuckDBPyConnection> conn);\n \tstatic py::list ListFilesystems(shared_ptr<DuckDBPyConnection> conn);\n+\tstatic bool FileSystemIsRegistered(const string &name, shared_ptr<DuckDBPyConnection> conn);\n };\n } // namespace duckdb\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/filesystem_object.hpp b/tools/pythonpkg/src/include/duckdb_python/filesystem_object.hpp\nnew file mode 100644\nindex 000000000000..211a3a7b26a4\n--- /dev/null\n+++ b/tools/pythonpkg/src/include/duckdb_python/filesystem_object.hpp\n@@ -0,0 +1,31 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb_python/filesystem_object.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+#include \"duckdb_python/registered_py_object.hpp\"\n+#include \"duckdb_python/pyfilesystem.hpp\"\n+\n+namespace duckdb {\n+\n+class FileSystemObject : public RegisteredObject {\n+public:\n+\texplicit FileSystemObject(py::object fs, const string &filename)\n+\t    : RegisteredObject(std::move(fs)), filename(filename) {\n+\t}\n+\tvirtual ~FileSystemObject() {\n+\t\tpy::gil_scoped_acquire acquire;\n+\t\t// Assert that the 'obj' is a filesystem\n+\t\tauto &import_cache = *DuckDBPyConnection::ImportCache();\n+\t\tD_ASSERT(import_cache.pyduckdb().filesystem.modified_memory_filesystem.IsInstance(obj));\n+\t\tobj.attr(\"delete\")(filename);\n+\t}\n+\n+\tstring filename;\n+};\n+\n+} // namespace duckdb\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pyduckdb_module.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pyduckdb_module.hpp\nnew file mode 100644\nindex 000000000000..254fbb2a639c\n--- /dev/null\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/modules/pyduckdb_module.hpp\n@@ -0,0 +1,44 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb_python/import_cache/modules/numpy_module.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb_python/import_cache/python_import_cache_item.hpp\"\n+\n+namespace duckdb {\n+\n+struct PyDuckDBFileSystemCacheItem : public PythonImportCacheItem {\n+\tstatic constexpr const char *Name = \"pyduckdb.filesystem\";\n+\n+public:\n+\t~PyDuckDBFileSystemCacheItem() override {\n+\t}\n+\tvirtual void LoadSubtypes(PythonImportCache &cache) override {\n+\t\tmodified_memory_filesystem.LoadAttribute(\"ModifiedMemoryFileSystem\", cache, *this);\n+\t}\n+\n+public:\n+\tPythonImportCacheItem modified_memory_filesystem;\n+};\n+\n+struct PyDuckDBCacheItem : public PythonImportCacheItem {\n+public:\n+\tstatic constexpr const char *Name = \"pyduckdb\";\n+\n+public:\n+\t~PyDuckDBCacheItem() override {\n+\t}\n+\tvirtual void LoadSubtypes(PythonImportCache &cache) override {\n+\t\tfilesystem.LoadModule(\"pyduckdb.filesystem\", cache);\n+\t}\n+\n+public:\n+\tPyDuckDBFileSystemCacheItem filesystem;\n+};\n+\n+} // namespace duckdb\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp\nindex 355bf3ffad8a..7dc53396ebe7 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp\n@@ -34,6 +34,9 @@ struct PythonImportCache {\n \tNumpyCacheItem &numpy() {\n \t\treturn LazyLoadModule(numpy_module);\n \t}\n+\tPyDuckDBCacheItem &pyduckdb() {\n+\t\treturn LazyLoadModule(pyduckdb_module);\n+\t}\n \tDatetimeCacheItem &datetime() {\n \t\treturn LazyLoadModule(datetime_module);\n \t}\n@@ -61,6 +64,7 @@ struct PythonImportCache {\n \n private:\n \tNumpyCacheItem numpy_module;\n+\tPyDuckDBCacheItem pyduckdb_module;\n \tDatetimeCacheItem datetime_module;\n \tDecimalCacheItem decimal_module;\n \tUUIDCacheItem uuid_module;\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache_modules.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache_modules.hpp\nindex aeaeed14d3aa..329034d94ee0 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache_modules.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache_modules.hpp\n@@ -4,6 +4,7 @@\n #include \"duckdb_python/import_cache/modules/ipython_module.hpp\"\n #include \"duckdb_python/import_cache/modules/ipywidgets_module.hpp\"\n #include \"duckdb_python/import_cache/modules/numpy_module.hpp\"\n+#include \"duckdb_python/import_cache/modules/pyduckdb_module.hpp\"\n #include \"duckdb_python/import_cache/modules/pandas_module.hpp\"\n #include \"duckdb_python/import_cache/modules/polars_module.hpp\"\n #include \"duckdb_python/import_cache/modules/uuid_module.hpp\"\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp b/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp\nindex f8306d06f0d2..0480aa79d216 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp\n@@ -40,6 +40,8 @@ struct DuckDBPyConnection : public std::enable_shared_from_this<DuckDBPyConnecti\n \tvector<shared_ptr<DuckDBPyConnection>> cursors;\n \tunordered_map<string, shared_ptr<Relation>> temporary_views;\n \tstd::mutex py_connection_lock;\n+\t//! MemoryFileSystem used to temporarily store file-like objects for reading\n+\tshared_ptr<ModifiedMemoryFileSystem> internal_object_filesystem;\n \n public:\n \texplicit DuckDBPyConnection() {\n@@ -61,7 +63,7 @@ struct DuckDBPyConnection : public std::enable_shared_from_this<DuckDBPyConnecti\n \tstatic bool IsInteractive();\n \n \tunique_ptr<DuckDBPyRelation>\n-\tReadCSV(const string &name, const py::object &header = py::none(), const py::object &compression = py::none(),\n+\tReadCSV(const py::object &name, const py::object &header = py::none(), const py::object &compression = py::none(),\n \t        const py::object &sep = py::none(), const py::object &delimiter = py::none(),\n \t        const py::object &dtype = py::none(), const py::object &na_values = py::none(),\n \t        const py::object &skiprows = py::none(), const py::object &quotechar = py::none(),\n@@ -132,6 +134,8 @@ struct DuckDBPyConnection : public std::enable_shared_from_this<DuckDBPyConnecti\n \n \tvoid Close();\n \n+\tModifiedMemoryFileSystem &GetObjectFileSystem();\n+\n \t// cursor() is stupid\n \tshared_ptr<DuckDBPyConnection> Cursor();\n \n@@ -164,6 +168,7 @@ struct DuckDBPyConnection : public std::enable_shared_from_this<DuckDBPyConnecti\n \tvoid RegisterFilesystem(AbstractFileSystem filesystem);\n \tvoid UnregisterFilesystem(const py::str &name);\n \tpy::list ListFilesystems();\n+\tbool FileSystemIsRegistered(const string &name);\n \n \t//! Default connection to an in-memory database\n \tstatic shared_ptr<DuckDBPyConnection> default_connection;\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pyfilesystem.hpp b/tools/pythonpkg/src/include/duckdb_python/pyfilesystem.hpp\nindex cdaf082e5433..be47afdb0158 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyfilesystem.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyfilesystem.hpp\n@@ -9,6 +9,18 @@\n \n namespace duckdb {\n \n+class ModifiedMemoryFileSystem : public py::object {\n+public:\n+\tusing py::object::object;\n+\tModifiedMemoryFileSystem(py::object object) : py::object(object) {\n+\t}\n+\n+public:\n+\tstatic bool check_(const py::handle &object) {\n+\t\treturn py::isinstance(object, py::module::import(\"pyduckdb.filesystem\").attr(\"ModifiedMemoryFileSystem\"));\n+\t}\n+};\n+\n class AbstractFileSystem : public py::object {\n public:\n \tusing py::object::object;\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp b/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\nindex 3ccc82067721..3b83a41ca404 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\n@@ -188,6 +188,18 @@ class Optional : public py::object {\n \t}\n };\n \n+class FileLikeObject : public py::object {\n+public:\n+\tFileLikeObject(const py::object &o) : py::object(o, borrowed_t {}) {\n+\t}\n+\tusing py::object::object;\n+\n+public:\n+\tstatic bool check_(const py::handle &object) {\n+\t\treturn py::isinstance(object, py::module::import(\"io\").attr(\"IOBase\"));\n+\t}\n+};\n+\n } // namespace duckdb\n \n namespace pybind11 {\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex a0a294fc5c75..e1e6341041f4 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -37,9 +37,12 @@\n #include \"duckdb/common/enums/file_compression_type.hpp\"\n #include \"duckdb/catalog/default/default_types.hpp\"\n #include \"duckdb/main/relation/value_relation.hpp\"\n+#include \"duckdb_python/filesystem_object.hpp\"\n \n #include <random>\n \n+#include \"duckdb/common/printer.hpp\"\n+\n namespace duckdb {\n \n shared_ptr<DuckDBPyConnection> DuckDBPyConnection::default_connection = nullptr;\n@@ -47,6 +50,20 @@ DBInstanceCache instance_cache;\n shared_ptr<PythonImportCache> DuckDBPyConnection::import_cache = nullptr;\n PythonEnvironmentType DuckDBPyConnection::environment = PythonEnvironmentType::NORMAL;\n \n+static std::string GenerateRandomName() {\n+\tstd::random_device rd;\n+\tstd::mt19937 gen(rd());\n+\tstd::uniform_int_distribution<> dis(0, 15);\n+\n+\tstd::stringstream ss;\n+\tint i;\n+\tss << std::hex;\n+\tfor (i = 0; i < 16; i++) {\n+\t\tss << dis(gen);\n+\t}\n+\treturn ss.str();\n+}\n+\n void DuckDBPyConnection::DetectEnvironment() {\n \t// If __main__ does not have a __file__ attribute, we are in interactive mode\n \tauto main_module = py::module_::import(\"__main__\");\n@@ -93,6 +110,8 @@ static void InitializeConnectionMethods(py::class_<DuckDBPyConnection, shared_pt\n \t         py::arg(\"name\"))\n \t    .def(\"list_filesystems\", &DuckDBPyConnection::ListFilesystems,\n \t         \"List registered filesystems, including builtin ones\")\n+\t    .def(\"filesystem_is_registered\", &DuckDBPyConnection::FileSystemIsRegistered,\n+\t         \"Check if a filesystem with the provided name is currently registered\", py::arg(\"name\"))\n \t    .def(\"duplicate\", &DuckDBPyConnection::Cursor, \"Create a duplicate of the current connection\")\n \t    .def(\"execute\", &DuckDBPyConnection::Execute,\n \t         \"Execute the given SQL query, optionally using prepared statements with parameters set\", py::arg(\"query\"),\n@@ -246,6 +265,11 @@ py::list DuckDBPyConnection::ListFilesystems() {\n \treturn names;\n }\n \n+bool DuckDBPyConnection::FileSystemIsRegistered(const string &name) {\n+\tauto subsystems = database->GetFileSystem().ListSubSystems();\n+\treturn std::find(subsystems.begin(), subsystems.end(), name) != subsystems.end();\n+}\n+\n void DuckDBPyConnection::Initialize(py::handle &m) {\n \tauto connection_module =\n \t    py::class_<DuckDBPyConnection, shared_ptr<DuckDBPyConnection>>(m, \"DuckDBPyConnection\", py::module_local());\n@@ -522,7 +546,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadJSON(const string &name, co\n }\n \n unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n-    const string &name, const py::object &header, const py::object &compression, const py::object &sep,\n+    const py::object &name_p, const py::object &header, const py::object &compression, const py::object &sep,\n     const py::object &delimiter, const py::object &dtype, const py::object &na_values, const py::object &skiprows,\n     const py::object &quotechar, const py::object &escapechar, const py::object &encoding, const py::object &parallel,\n     const py::object &date_format, const py::object &timestamp_format, const py::object &sample_size,\n@@ -532,6 +556,18 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \t}\n \tBufferedCSVReaderOptions options;\n \n+\tshared_ptr<ExternalDependency> file_like_object_wrapper;\n+\tstring name;\n+\tif (!py::isinstance<py::str>(name_p)) {\n+\t\t// Make sure that the object filesystem is initialized and registered\n+\t\tauto &fs = GetObjectFileSystem();\n+\t\tname = StringUtil::Format(\"%s://%s\", \"DUCKDB_INTERNAL_OBJECTSTORE\", GenerateRandomName());\n+\t\tfs.attr(\"add_file\")(name_p, name);\n+\t\tfile_like_object_wrapper = make_unique<PythonDependencies>(make_unique<FileSystemObject>(fs, name));\n+\t} else {\n+\t\tname = py::str(name_p);\n+\t}\n+\n \t// First check if the header is explicitly set\n \t// when false this affects the returned types, so it needs to be known at initialization of the relation\n \tif (!py::none().is(header)) {\n@@ -562,6 +598,10 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \n \tauto read_csv_p = connection->ReadCSV(name, options);\n \tauto &read_csv = (ReadCSVRelation &)*read_csv_p;\n+\tif (file_like_object_wrapper) {\n+\t\tD_ASSERT(!read_csv.extra_dependencies);\n+\t\tread_csv.extra_dependencies = std::move(file_like_object_wrapper);\n+\t}\n \n \tif (options.has_header) {\n \t\t// 'options' is only used to initialize the ReadCSV relation\n@@ -813,20 +853,6 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::TableFunction(const string &fna\n \t    connection->TableFunction(fname, DuckDBPyConnection::TransformPythonParamList(params)));\n }\n \n-static std::string GenerateRandomName() {\n-\tstd::random_device rd;\n-\tstd::mt19937 gen(rd());\n-\tstd::uniform_int_distribution<> dis(0, 15);\n-\n-\tstd::stringstream ss;\n-\tint i;\n-\tss << std::hex;\n-\tfor (i = 0; i < 16; i++) {\n-\t\tss << dis(gen);\n-\t}\n-\treturn ss.str();\n-}\n-\n unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromDF(const DataFrame &value) {\n \tif (!connection) {\n \t\tthrow ConnectionException(\"Connection has already been closed\");\n@@ -1305,6 +1331,18 @@ PythonImportCache *DuckDBPyConnection::ImportCache() {\n \treturn import_cache.get();\n }\n \n+ModifiedMemoryFileSystem &DuckDBPyConnection::GetObjectFileSystem() {\n+\tif (!internal_object_filesystem) {\n+\t\tD_ASSERT(!FileSystemIsRegistered(\"DUCKDB_INTERNAL_OBJECTSTORE\"));\n+\t\tauto &import_cache = *ImportCache();\n+\t\tinternal_object_filesystem =\n+\t\t    make_shared<ModifiedMemoryFileSystem>(import_cache.pyduckdb().filesystem.modified_memory_filesystem()());\n+\t\tauto &abstract_fs = (AbstractFileSystem &)*internal_object_filesystem;\n+\t\tRegisterFilesystem(abstract_fs);\n+\t}\n+\treturn *internal_object_filesystem;\n+}\n+\n bool DuckDBPyConnection::IsInteractive() {\n \treturn DuckDBPyConnection::environment != PythonEnvironmentType::NORMAL;\n }\ndiff --git a/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp b/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\nindex c575b6ab2c0a..f683f7cabbe7 100644\n--- a/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\n+++ b/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\n@@ -232,12 +232,12 @@ unique_ptr<DuckDBPyRelation> PyConnectionWrapper::ReadJSON(const string &filenam\n }\n \n unique_ptr<DuckDBPyRelation> PyConnectionWrapper::ReadCSV(\n-    const string &name, shared_ptr<DuckDBPyConnection> conn, const py::object &header, const py::object &compression,\n-    const py::object &sep, const py::object &delimiter, const py::object &dtype, const py::object &na_values,\n-    const py::object &skiprows, const py::object &quotechar, const py::object &escapechar, const py::object &encoding,\n-    const py::object &parallel, const py::object &date_format, const py::object &timestamp_format,\n-    const py::object &sample_size, const py::object &all_varchar, const py::object &normalize_names,\n-    const py::object &filename) {\n+    const py::object &name, shared_ptr<DuckDBPyConnection> conn, const py::object &header,\n+    const py::object &compression, const py::object &sep, const py::object &delimiter, const py::object &dtype,\n+    const py::object &na_values, const py::object &skiprows, const py::object &quotechar, const py::object &escapechar,\n+    const py::object &encoding, const py::object &parallel, const py::object &date_format,\n+    const py::object &timestamp_format, const py::object &sample_size, const py::object &all_varchar,\n+    const py::object &normalize_names, const py::object &filename) {\n \tif (!conn) {\n \t\tconn = DuckDBPyConnection::DefaultConnection();\n \t}\n@@ -336,5 +336,11 @@ py::list PyConnectionWrapper::ListFilesystems(shared_ptr<DuckDBPyConnection> con\n \t}\n \treturn conn->ListFilesystems();\n }\n+bool PyConnectionWrapper::FileSystemIsRegistered(const string &name, shared_ptr<DuckDBPyConnection> conn) {\n+\tif (!conn) {\n+\t\tconn = DuckDBPyConnection::DefaultConnection();\n+\t}\n+\treturn conn->FileSystemIsRegistered(name);\n+}\n \n } // namespace duckdb\ndiff --git a/tools/pythonpkg/src/pyfilesystem.cpp b/tools/pythonpkg/src/pyfilesystem.cpp\nindex 6a69030f45bf..5148d2d10b04 100644\n--- a/tools/pythonpkg/src/pyfilesystem.cpp\n+++ b/tools/pythonpkg/src/pyfilesystem.cpp\n@@ -127,6 +127,10 @@ void PythonFilesystem::Seek(duckdb::FileHandle &handle, uint64_t location) {\n \n \tauto seek = PythonFileHandle::GetHandle(handle).attr(\"seek\");\n \tseek(location);\n+\tif (PyErr_Occurred()) {\n+\t\tPyErr_PrintEx(1);\n+\t\tthrow InvalidInputException(\"Python exception occurred!\");\n+\t}\n }\n bool PythonFilesystem::CanHandleFile(const string &fpath) {\n \tfor (const auto &protocol : protocols) {\ndiff --git a/tools/pythonpkg/src/python_import_cache.cpp b/tools/pythonpkg/src/python_import_cache.cpp\nindex 0a3cbc0b20ea..4f639553c50d 100644\n--- a/tools/pythonpkg/src/python_import_cache.cpp\n+++ b/tools/pythonpkg/src/python_import_cache.cpp\n@@ -40,7 +40,9 @@ void PythonImportCacheItem::LoadModule(const string &name, PythonImportCache &ca\n \t\tobject = AddCache(cache, std::move(py::module::import(name.c_str())));\n \t} catch (py::error_already_set &e) {\n \t\tif (IsRequired()) {\n-\t\t\tthrow InvalidInputException(\"Required module '%s' failed to import\", name);\n+\t\t\tPyErr_PrintEx(1);\n+\t\t\tthrow InvalidInputException(\n+\t\t\t    \"Required module '%s' failed to import, due to the following Python exception:\\n%s\", name, e.what());\n \t\t}\n \t\treturn;\n \t}\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_read_csv.py b/tools/pythonpkg/tests/fast/api/test_read_csv.py\nindex 9896cf284ea5..4bed8927427c 100644\n--- a/tools/pythonpkg/tests/fast/api/test_read_csv.py\n+++ b/tools/pythonpkg/tests/fast/api/test_read_csv.py\n@@ -1,8 +1,10 @@\n+from multiprocessing.sharedctypes import Value\n import numpy\n import datetime\n import pandas\n import pytest\n import duckdb\n+from io import StringIO, BytesIO\n \n def TestFile(name):\n \timport os\n@@ -185,4 +187,117 @@ def test_filename(self, duckdb_cursor):\n \t\tdf = rel.df()\n \t\tcolumn_names = list(df.columns.values)\n \t\t# The filename is included in the returned columns\n-\t\tassert 'filename' in column_names\n\\ No newline at end of file\n+\t\tassert 'filename' in column_names\n+\n+\tdef test_read_filelike(self, duckdb_cursor):\n+\t\tstring = StringIO(\"c1,c2,c3\\na,b,c\")\n+\t\tres = duckdb_cursor.read_csv(string, header=True).fetchall()\n+\t\tassert res == [('a', 'b', 'c')]\n+\n+\tdef test_read_filelike_rel_out_of_scope(self, duckdb_cursor):\n+\t\tdef keep_in_scope():\n+\t\t\tstring = StringIO(\"c1,c2,c3\\na,b,c\")\n+\t\t\t# Create a ReadCSVRelation on a file-like object\n+\t\t\t# this will add the object to our internal object filesystem\n+\t\t\trel = duckdb_cursor.read_csv(string, header=True)\n+\t\t\t# The file-like object will still exist, so we can execute this later\n+\t\t\treturn rel\n+\t\t\n+\t\tdef close_scope():\n+\t\t\tstring = StringIO(\"c1,c2,c3\\na,b,c\")\n+\t\t\t# Create a ReadCSVRelation on a file-like object\n+\t\t\t# this will add the object to our internal object filesystem\n+\t\t\tres = duckdb_cursor.read_csv(string, header=True).fetchall()\n+\t\t\t# When the relation goes out of scope - we delete the file-like object from our filesystem\n+\t\t\treturn res\n+\n+\t\trelation = keep_in_scope()\n+\t\tres = relation.fetchall()\n+\n+\t\tres2 = close_scope()\n+\t\tassert res == res2\n+\n+\tdef test_filelike_bytesio(self, duckdb_cursor):\n+\t\tstring = BytesIO(b\"c1,c2,c3\\na,b,c\")\n+\t\tres = duckdb_cursor.read_csv(string, header=True).fetchall()\n+\t\tassert res == [('a', 'b', 'c')]\n+\t\n+\tdef test_filelike_exception(self, duckdb_cursor):\n+\t\tclass ReadError:\n+\t\t\tdef __init__(self):\n+\t\t\t\tpass\n+\t\t\tdef read(self, amount):\n+\t\t\t\traise ValueError(amount)\n+\t\t\tdef seek(self, loc):\n+\t\t\t\treturn 0\n+\n+\t\tclass SeekError:\n+\t\t\tdef __init__(self):\n+\t\t\t\tpass\n+\t\t\tdef read(self, amount):\n+\t\t\t\treturn b'test'\n+\t\t\tdef seek(self, loc):\n+\t\t\t\traise ValueError(loc)\n+\n+\t\tobj = ReadError()\n+\t\twith pytest.raises(ValueError):\n+\t\t\tres = duckdb_cursor.read_csv(obj, header=True).fetchall()\n+\n+\t\tobj = SeekError()\n+\t\twith pytest.raises(ValueError):\n+\t\t\tres = duckdb_cursor.read_csv(obj, header=True).fetchall()\n+\t\n+\tdef test_filelike_custom(self, duckdb_cursor):\n+\t\tclass CustomIO:\n+\t\t\tdef __init__(self):\n+\t\t\t\tself.loc = 0\n+\t\t\t\tpass\n+\t\t\tdef seek(self, loc):\n+\t\t\t\tself.loc = loc\n+\t\t\t\treturn loc\n+\t\t\tdef read(self, amount):\n+\t\t\t\tout = b\"c1,c2,c3\\na,b,c\"[self.loc : self.loc + amount : 1]\n+\t\t\t\tself.loc += amount\n+\t\t\t\treturn out\n+\n+\t\tobj = CustomIO()\n+\t\tres = duckdb_cursor.read_csv(obj, header=True).fetchall()\n+\t\tassert res == [('a', 'b', 'c')]\n+\n+\tdef test_filelike_non_readable(self, duckdb_cursor):\n+\t\tobj = 5;\n+\t\twith pytest.raises(ValueError, match=\"Can not read from a non file-like object\"):\n+\t\t\tres = duckdb_cursor.read_csv(obj, header=True).fetchall()\n+\t\n+\tdef test_filelike_none(self, duckdb_cursor):\n+\t\tobj = None;\n+\t\twith pytest.raises(ValueError, match=\"Can not read from a non file-like object\"):\n+\t\t\tres = duckdb_cursor.read_csv(obj, header=True).fetchall()\n+\n+\tdef test_internal_object_filesystem_cleanup(self, duckdb_cursor):\n+\t\tclass CountedObject(StringIO):\n+\t\t\tinstance_count = 0\n+\t\t\tdef __init__(self, str):\n+\t\t\t\tCountedObject.instance_count += 1\n+\t\t\t\tsuper().__init__(str)\n+\t\t\tdef __del__(self):\n+\t\t\t\tCountedObject.instance_count -= 1\n+\n+\t\tdef scoped_objects(duckdb_cursor):\n+\t\t\tobj = CountedObject(\"a,b,c\")\n+\t\t\trel1 = duckdb_cursor.read_csv(obj)\n+\t\t\tassert rel1.fetchall() == [('a','b','c',)]\n+\t\t\tassert CountedObject.instance_count == 1\n+\n+\t\t\tobj = CountedObject(\"a,b,c\")\n+\t\t\trel2 = duckdb_cursor.read_csv(obj)\n+\t\t\tassert rel2.fetchall() == [('a','b','c',)]\n+\t\t\tassert CountedObject.instance_count == 2\n+\n+\t\t\tobj = CountedObject(\"a,b,c\")\n+\t\t\trel3 = duckdb_cursor.read_csv(obj)\n+\t\t\tassert rel3.fetchall() == [('a','b','c',)]\n+\t\t\tassert CountedObject.instance_count == 3\n+\t\tassert CountedObject.instance_count == 0\n+\t\tscoped_objects(duckdb_cursor)\n+\t\tassert CountedObject.instance_count == 0\n\\ No newline at end of file\ndiff --git a/tools/pythonpkg/tests/fast/test_filesystem.py b/tools/pythonpkg/tests/fast/test_filesystem.py\nindex 306b9fd8429a..52bb02f9cf0a 100644\n--- a/tools/pythonpkg/tests/fast/test_filesystem.py\n+++ b/tools/pythonpkg/tests/fast/test_filesystem.py\n@@ -81,8 +81,9 @@ def test_reject_abstract_filesystem(self, duckdb_cursor: DuckDBPyConnection):\n \n     def test_unregister_builtin(self, require: Callable[[str], DuckDBPyConnection]):\n         duckdb_cursor = require('httpfs')\n-        assert 'S3FileSystem' in duckdb_cursor.list_filesystems()\n+        assert duckdb_cursor.filesystem_is_registered('S3FileSystem') == True\n         duckdb_cursor.unregister_filesystem('S3FileSystem')\n+        assert duckdb_cursor.filesystem_is_registered('S3FileSystem') == False\n \n     def test_multiple_protocol_filesystems(self, duckdb_cursor: DuckDBPyConnection):\n         class ExtendedMemoryFileSystem(MemoryFileSystem):\n@@ -145,7 +146,6 @@ def test_arrow_fs_wrapper(self, tmp_path: Path, duckdb_cursor: DuckDBPyConnectio\n \n         local = fs.LocalFileSystem()\n         local_fsspec = ArrowFSWrapper(local, skip_instance_cache=True)\n-        local_fsspec.protocol = \"local\"\n         # posix calls here required as ArrowFSWrapper only supports url-like paths (not Windows paths)\n         filename = str(PurePosixPath(tmp_path.as_posix()) / \"test.csv\")\n         with local_fsspec.open(filename, mode='w') as f:\n",
  "problem_statement": "[Python] `read_csv` only accepts a filepath\n### What happens?\r\n\r\nThe `read_csv` method in DuckDB is meant to be a replica of `pandas.read_csv`, so it should also accept different types of `filepath_or_buffer`, like it's counter part does\r\n\r\n### To Reproduce\r\n\r\n```py\r\nimport duckdb\r\nfrom io import StringIO\r\n\r\nstring = StringIO(\"c1,c2,c3\\na,b,c\")\r\nduckdb.read_csv(string, header=True)\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   c0    \u2502   c1    \u2502   c2    \u2502\r\n\u2502 varchar \u2502 varchar \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 a       \u2502 b       \u2502 c       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### OS:\r\n\r\nMacOS\r\n\r\n### DuckDB Version:\r\n\r\nmaster\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nThijs Bruineman\r\n\r\n### Affiliation:\r\n\r\nDuckDB Labs\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "Might be able to reuse some of the fsspec code for this? As it already does some work to wrap python file objects\nI have a message from Mark suggesting something just like this ;)\nLikely we will need to register a subsystem with an internal protocol (\"duckdb_string_io_\" or something similar)\r\nThen add the file with a generated name, forward this file with the attached protocol: \"duckdb_string_io_://{random_name}\"\r\n\r\nThen through the VirtualFileSystem it will be matched by its protocol, and from there the PythonFileSystem will do its job",
  "created_at": "2023-03-04T08:22:03Z"
}