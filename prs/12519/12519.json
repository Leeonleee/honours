{
  "repo": "duckdb/duckdb",
  "pull_number": 12519,
  "instance_id": "duckdb__duckdb-12519",
  "issue_numbers": [
    "12513"
  ],
  "base_commit": "4659f50547192aa015aaaa27508b20fb1e696bc2",
  "patch": "diff --git a/tools/pythonpkg/src/numpy/numpy_scan.cpp b/tools/pythonpkg/src/numpy/numpy_scan.cpp\nindex b4b1d3dbe276..43267cb5adba 100644\n--- a/tools/pythonpkg/src/numpy/numpy_scan.cpp\n+++ b/tools/pythonpkg/src/numpy/numpy_scan.cpp\n@@ -197,6 +197,7 @@ void NumpyScan::Scan(PandasColumnBindData &bind_data, idx_t count, idx_t offset,\n \tD_ASSERT(bind_data.pandas_col->Backend() == PandasColumnBackend::NUMPY);\n \tauto &numpy_col = reinterpret_cast<PandasNumpyColumn &>(*bind_data.pandas_col);\n \tauto &array = numpy_col.array;\n+\tauto stride = numpy_col.stride;\n \n \tswitch (bind_data.numpy_type.type) {\n \tcase NumpyNullableType::BOOL:\n@@ -276,12 +277,13 @@ void NumpyScan::Scan(PandasColumnBindData &bind_data, idx_t count, idx_t offset,\n \t\t};\n \n \t\tfor (idx_t row = 0; row < count; row++) {\n-\t\t\tauto source_idx = offset + row;\n+\t\t\tauto source_idx = stride / sizeof(int64_t) * (row + offset);\n \t\t\tif (src_ptr[source_idx] <= NumericLimits<int64_t>::Minimum()) {\n \t\t\t\t// pandas Not a Time (NaT)\n \t\t\t\tmask.SetInvalid(row);\n \t\t\t\tcontinue;\n \t\t\t}\n+\n \t\t\t// Direct conversion, we've already matched the numpy type with the equivalent duckdb type\n \t\t\tauto input = timestamp_t(src_ptr[source_idx]);\n \t\t\tif (Timestamp::IsFinite(input)) {\n@@ -298,7 +300,7 @@ void NumpyScan::Scan(PandasColumnBindData &bind_data, idx_t count, idx_t offset,\n \t\tauto &mask = FlatVector::Validity(out);\n \n \t\tfor (idx_t row = 0; row < count; row++) {\n-\t\t\tauto source_idx = offset + row;\n+\t\t\tauto source_idx = stride / sizeof(int64_t) * (row + offset);\n \t\t\tif (src_ptr[source_idx] <= NumericLimits<int64_t>::Minimum()) {\n \t\t\t\t// pandas Not a Time (NaT)\n \t\t\t\tmask.SetInvalid(row);\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/pandas/test_stride.py b/tools/pythonpkg/tests/fast/pandas/test_stride.py\nindex e8968ee793e1..5efe8d56a560 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_stride.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_stride.py\n@@ -1,6 +1,7 @@\n import pandas as pd\n import duckdb\n import numpy as np\n+import datetime\n \n \n class TestPandasStride(object):\n@@ -20,6 +21,42 @@ def test_stride_fp32(self, duckdb_cursor):\n             assert str(output_df[col].dtype) == 'float32'\n         pd.testing.assert_frame_equal(expected_df, output_df)\n \n+    def test_stride_datetime(self, duckdb_cursor):\n+        df = pd.DataFrame({'date': pd.Series(pd.date_range(\"2024-01-01\", freq=\"D\", periods=100))})\n+        df = df.loc[::23,]\n+\n+        roundtrip = duckdb_cursor.sql(\"select * from df\").df()\n+        expected = pd.DataFrame(\n+            {\n+                'date': [\n+                    datetime.datetime(2024, 1, 1),\n+                    datetime.datetime(2024, 1, 24),\n+                    datetime.datetime(2024, 2, 16),\n+                    datetime.datetime(2024, 3, 10),\n+                    datetime.datetime(2024, 4, 2),\n+                ]\n+            }\n+        )\n+        pd.testing.assert_frame_equal(roundtrip, expected)\n+\n+    def test_stride_timedelta(self, duckdb_cursor):\n+        df = pd.DataFrame({'date': [datetime.timedelta(days=i) for i in range(100)]})\n+        df = df.loc[::23,]\n+\n+        roundtrip = duckdb_cursor.sql(\"select * from df\").df()\n+        expected = pd.DataFrame(\n+            {\n+                'date': [\n+                    datetime.timedelta(days=0),\n+                    datetime.timedelta(days=23),\n+                    datetime.timedelta(days=46),\n+                    datetime.timedelta(days=69),\n+                    datetime.timedelta(days=92),\n+                ]\n+            }\n+        )\n+        pd.testing.assert_frame_equal(roundtrip, expected)\n+\n     def test_stride_fp64(self, duckdb_cursor):\n         expected_df = pd.DataFrame(np.arange(20, dtype='float64').reshape(5, 4), columns=[\"a\", \"b\", \"c\", \"d\"])\n         con = duckdb.connect()\n",
  "problem_statement": "datetime values read from pandas dataframe are broken if the the df has a gapped index\n### What happens?\n\n```python\r\nimport duckdb\r\nimport pandas as pd\r\n\r\nn = 100\r\ndf = pd.DataFrame({'date': pd.Series(pd.date_range(\"2024-01-01\", freq=\"D\", periods=n)),\r\n                   'x': pd.Series(range(n))})\r\n\r\ndf = df.loc[::23,]  # this causes the issue\r\nprint(\"pandas df:\")\r\nprint(df)\r\n\r\nxf = duckdb.query(\"select * from df \").df()\r\nprint(\"duckdb got:\")\r\nprint(xf)\r\n```\r\n\r\nThe code above prints:\r\n```\r\npandas df:\r\n         date   x\r\n0  2024-01-01   0\r\n23 2024-01-24  23\r\n46 2024-02-16  46\r\n69 2024-03-10  69\r\n92 2024-04-02  92\r\nduckdb got:\r\n        date   x\r\n0 2024-01-01   0\r\n1 2024-01-02  23\r\n2 2024-01-03  46\r\n3 2024-01-04  69\r\n4 2024-01-05  92\r\n```\r\nThe values of the `x` column are correct, but the `date` values aren't. It seems like the `date` column doesn't choose the appropriate indexes as `x` does. Rather, first 5 rows are chosen by `date`. \r\n\n\n### To Reproduce\n\nSee the description above.\n\n### OS:\n\nUbuntu 22.04.2 LTS, aarch64\n\n### DuckDB Version:\n\n1.0.0\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nMark\n\n### Affiliation:\n\nbq\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have not tested with any build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-06-13T14:47:41Z"
}