{
  "repo": "duckdb/duckdb",
  "pull_number": 2644,
  "instance_id": "duckdb__duckdb-2644",
  "issue_numbers": [
    "2641",
    "2641"
  ],
  "base_commit": "7c70a1d4daa3829252fdc5d266a9e75a75f023f2",
  "patch": "diff --git a/src/execution/operator/persistent/buffered_csv_reader.cpp b/src/execution/operator/persistent/buffered_csv_reader.cpp\nindex 7a95b06498e2..1256e0ef1c91 100644\n--- a/src/execution/operator/persistent/buffered_csv_reader.cpp\n+++ b/src/execution/operator/persistent/buffered_csv_reader.cpp\n@@ -22,6 +22,24 @@\n \n namespace duckdb {\n \n+void BufferedCSVReaderOptions::SetDelimiter(const string &input) {\n+\tthis->delimiter = StringUtil::Replace(input, \"\\\\t\", \"\\t\");\n+\tthis->has_delimiter = true;\n+\tif (input.empty()) {\n+\t\tthrow BinderException(\"DELIM or SEP must not be empty\");\n+\t}\n+}\n+\n+std::string BufferedCSVReaderOptions::ToString() const {\n+\treturn \"DELIMITER='\" + delimiter + (has_delimiter ? \"'\" : (auto_detect ? \"' (auto detected)\" : \"' (default)\")) +\n+\t       \", QUOTE='\" + quote + (has_quote ? \"'\" : (auto_detect ? \"' (auto detected)\" : \"' (default)\")) +\n+\t       \", ESCAPE='\" + escape + (has_escape ? \"'\" : (auto_detect ? \"' (auto detected)\" : \"' (default)\")) +\n+\t       \", HEADER=\" + std::to_string(header) +\n+\t       (has_header ? \"\" : (auto_detect ? \" (auto detected)\" : \"' (default)\")) +\n+\t       \", SAMPLE_SIZE=\" + std::to_string(sample_chunk_size * sample_chunks) +\n+\t       \", ALL_VARCHAR=\" + std::to_string(all_varchar);\n+}\n+\n static string GetLineNumberStr(idx_t linenr, bool linenr_estimated) {\n \tstring estimated = (linenr_estimated ? string(\" (estimated)\") : string(\"\"));\n \treturn to_string(linenr + 1) + estimated;\n@@ -835,7 +853,7 @@ vector<LogicalType> BufferedCSVReader::RefineTypeDetection(const vector<LogicalT\n \t\tif (requested_types.size() != options.num_cols) {\n \t\t\tthrow InvalidInputException(\n \t\t\t    \"Error while determining column types: found %lld columns but expected %d. (%s)\", options.num_cols,\n-\t\t\t    requested_types.size(), options.toString());\n+\t\t\t    requested_types.size(), options.ToString());\n \t\t} else {\n \t\t\tdetected_types = requested_types;\n \t\t}\n@@ -1093,7 +1111,7 @@ add_row : {\n \t} while (ReadBuffer(start));\n \t// still in quoted state at the end of the file, error:\n \terror_message = StringUtil::Format(\"Error in file \\\"%s\\\" on line %s: unterminated quotes. (%s)\", options.file_path,\n-\t                                   GetLineNumberStr(linenr, linenr_estimated).c_str(), options.toString());\n+\t                                   GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());\n \treturn false;\n unquote:\n \t/* state: unquote */\n@@ -1123,7 +1141,7 @@ add_row : {\n \t\t\t\terror_message = StringUtil::Format(\n \t\t\t\t    \"Error in file \\\"%s\\\" on line %s: quote should be followed by end of value, end \"\n \t\t\t\t    \"of row or another quote. (%s)\",\n-\t\t\t\t    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.toString());\n+\t\t\t\t    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tif (delimiter_pos == options.delimiter.size()) {\n@@ -1140,7 +1158,7 @@ add_row : {\n \t} while (ReadBuffer(start));\n \terror_message = StringUtil::Format(\n \t    \"Error in file \\\"%s\\\" on line %s: quote should be followed by end of value, end of row or another quote. (%s)\",\n-\t    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.toString());\n+\t    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());\n \treturn false;\n handle_escape:\n \tescape_pos = 0;\n@@ -1155,7 +1173,7 @@ add_row : {\n \t\t\tif (count > escape_pos && count > quote_pos) {\n \t\t\t\terror_message = StringUtil::Format(\n \t\t\t\t    \"Error in file \\\"%s\\\" on line %s: neither QUOTE nor ESCAPE is proceeded by ESCAPE. (%s)\",\n-\t\t\t\t    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.toString());\n+\t\t\t\t    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tif (quote_pos == options.quote.size() || escape_pos == options.escape.size()) {\n@@ -1166,7 +1184,7 @@ add_row : {\n \t} while (ReadBuffer(start));\n \terror_message =\n \t    StringUtil::Format(\"Error in file \\\"%s\\\" on line %s: neither QUOTE nor ESCAPE is proceeded by ESCAPE. (%s)\",\n-\t                       options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.toString());\n+\t                       options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());\n \treturn false;\n carriage_return:\n \t/* state: carriage_return */\n@@ -1298,7 +1316,7 @@ add_row : {\n \t} while (ReadBuffer(start));\n \t// still in quoted state at the end of the file, error:\n \tthrow InvalidInputException(\"Error in file \\\"%s\\\" on line %s: unterminated quotes. (%s)\", options.file_path,\n-\t                            GetLineNumberStr(linenr, linenr_estimated).c_str(), options.toString());\n+\t                            GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());\n unquote:\n \t/* state: unquote */\n \t// this state handles the state directly after we unquote\n@@ -1325,7 +1343,7 @@ add_row : {\n \t\terror_message = StringUtil::Format(\n \t\t    \"Error in file \\\"%s\\\" on line %s: quote should be followed by end of value, end of \"\n \t\t    \"row or another quote. (%s)\",\n-\t\t    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.toString());\n+\t\t    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());\n \t\treturn false;\n \t}\n handle_escape:\n@@ -1335,13 +1353,13 @@ add_row : {\n \tif (position >= buffer_size && !ReadBuffer(start)) {\n \t\terror_message = StringUtil::Format(\n \t\t    \"Error in file \\\"%s\\\" on line %s: neither QUOTE nor ESCAPE is proceeded by ESCAPE. (%s)\", options.file_path,\n-\t\t    GetLineNumberStr(linenr, linenr_estimated).c_str(), options.toString());\n+\t\t    GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());\n \t\treturn false;\n \t}\n \tif (buffer[position] != options.quote[0] && buffer[position] != options.escape[0]) {\n \t\terror_message = StringUtil::Format(\n \t\t    \"Error in file \\\"%s\\\" on line %s: neither QUOTE nor ESCAPE is proceeded by ESCAPE. (%s)\", options.file_path,\n-\t\t    GetLineNumberStr(linenr, linenr_estimated).c_str(), options.toString());\n+\t\t    GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());\n \t\treturn false;\n \t}\n \t// escape was followed by quote or escape, go back to quoted state\n@@ -1481,7 +1499,7 @@ void BufferedCSVReader::AddValue(char *str_val, idx_t length, idx_t &column, vec\n \tif (column >= sql_types.size()) {\n \t\tthrow InvalidInputException(\"Error on line %s: expected %lld values per row, but got more. (%s)\",\n \t\t                            GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(),\n-\t\t                            options.toString());\n+\t\t                            options.ToString());\n \t}\n \n \t// insert the line number into the chunk\n@@ -1536,7 +1554,7 @@ bool BufferedCSVReader::AddRow(DataChunk &insert_chunk, idx_t &column) {\n \tif (column < sql_types.size() && mode != ParserMode::SNIFFING_DIALECT) {\n \t\tthrow InvalidInputException(\"Error on line %s: expected %lld values per row, but got %d. (%s)\",\n \t\t                            GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(), column,\n-\t\t                            options.toString());\n+\t\t                            options.ToString());\n \t}\n \n \tif (mode == ParserMode::SNIFFING_DIALECT) {\n@@ -1589,7 +1607,7 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {\n \t\t\t\t\t\tthrow InvalidInputException(\"Error in file \\\"%s\\\" between line %llu and %llu in column \\\"%s\\\": \"\n \t\t\t\t\t\t                            \"file is not valid UTF8. Parser options: %s\",\n \t\t\t\t\t\t                            options.file_path, linenr - parse_chunk.size(), linenr, col_name,\n-\t\t\t\t\t\t                            options.toString());\n+\t\t\t\t\t\t                            options.ToString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n@@ -1623,11 +1641,11 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {\n \t\t\t\t\t                            \"(SAMPLE_SIZE=X [X rows] or SAMPLE_SIZE=-1 [all rows]), \"\n \t\t\t\t\t                            \"or skipping column conversion (ALL_VARCHAR=1)\",\n \t\t\t\t\t                            error_message, col_name, linenr - parse_chunk.size() + 1, linenr,\n-\t\t\t\t\t                            options.toString());\n+\t\t\t\t\t                            options.ToString());\n \t\t\t\t} else {\n \t\t\t\t\tthrow InvalidInputException(\"%s between line %llu and %llu in column %s. Parser options: %s \",\n \t\t\t\t\t                            error_message, linenr - parse_chunk.size(), linenr, col_name,\n-\t\t\t\t\t                            options.toString());\n+\t\t\t\t\t                            options.ToString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\ndiff --git a/src/function/table/copy_csv.cpp b/src/function/table/copy_csv.cpp\nindex 6d0d2a389105..4baa115cd3ae 100644\n--- a/src/function/table/copy_csv.cpp\n+++ b/src/function/table/copy_csv.cpp\n@@ -61,11 +61,7 @@ static int64_t ParseInteger(vector<Value> &set) {\n //===--------------------------------------------------------------------===//\n static bool ParseBaseOption(BufferedCSVReaderOptions &options, string &loption, vector<Value> &set) {\n \tif (StringUtil::StartsWith(loption, \"delim\") || StringUtil::StartsWith(loption, \"sep\")) {\n-\t\toptions.delimiter = ParseString(set);\n-\t\toptions.has_delimiter = true;\n-\t\tif (options.delimiter.length() == 0) {\n-\t\t\tthrow BinderException(\"DELIM or SEP must not be empty\");\n-\t\t}\n+\t\toptions.SetDelimiter(ParseString(set));\n \t} else if (loption == \"quote\") {\n \t\toptions.quote = ParseString(set);\n \t\toptions.has_quote = true;\ndiff --git a/src/function/table/read_csv.cpp b/src/function/table/read_csv.cpp\nindex 54b1e7b10ca0..ac4e73e061a3 100644\n--- a/src/function/table/read_csv.cpp\n+++ b/src/function/table/read_csv.cpp\n@@ -33,8 +33,7 @@ static unique_ptr<FunctionData> ReadCSVBind(ClientContext &context, vector<Value\n \t\tif (kv.first == \"auto_detect\") {\n \t\t\toptions.auto_detect = kv.second.value_.boolean;\n \t\t} else if (kv.first == \"sep\" || kv.first == \"delim\") {\n-\t\t\toptions.delimiter = kv.second.str_value;\n-\t\t\toptions.has_delimiter = true;\n+\t\t\toptions.SetDelimiter(kv.second.str_value);\n \t\t} else if (kv.first == \"header\") {\n \t\t\toptions.header = kv.second.value_.boolean;\n \t\t\toptions.has_header = true;\ndiff --git a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\nindex 1b34e67425f8..a2b554afeced 100644\n--- a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\n+++ b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\n@@ -99,15 +99,9 @@ struct BufferedCSVReaderOptions {\n \t//! Whether or not a type format is specified\n \tstd::map<LogicalTypeId, bool> has_format = {{LogicalTypeId::DATE, false}, {LogicalTypeId::TIMESTAMP, false}};\n \n-\tstd::string toString() const {\n-\t\treturn \"DELIMITER='\" + delimiter + (has_delimiter ? \"'\" : (auto_detect ? \"' (auto detected)\" : \"' (default)\")) +\n-\t\t       \", QUOTE='\" + quote + (has_quote ? \"'\" : (auto_detect ? \"' (auto detected)\" : \"' (default)\")) +\n-\t\t       \", ESCAPE='\" + escape + (has_escape ? \"'\" : (auto_detect ? \"' (auto detected)\" : \"' (default)\")) +\n-\t\t       \", HEADER=\" + std::to_string(header) +\n-\t\t       (has_header ? \"\" : (auto_detect ? \" (auto detected)\" : \"' (default)\")) +\n-\t\t       \", SAMPLE_SIZE=\" + std::to_string(sample_chunk_size * sample_chunks) +\n-\t\t       \", ALL_VARCHAR=\" + std::to_string(all_varchar);\n-\t}\n+\tvoid SetDelimiter(const string &delimiter);\n+\n+\tstd::string ToString() const;\n };\n \n enum class ParserMode : uint8_t { PARSING = 0, SNIFFING_DIALECT = 1, SNIFFING_DATATYPES = 2, PARSING_HEADER = 3 };\n",
  "test_patch": "diff --git a/test/sql/copy/csv/tsv_copy.test b/test/sql/copy/csv/tsv_copy.test\nnew file mode 100644\nindex 000000000000..cea28567ebd1\n--- /dev/null\n+++ b/test/sql/copy/csv/tsv_copy.test\n@@ -0,0 +1,25 @@\n+# name: test/sql/copy/csv/tsv_copy.test\n+# description: Test TSV Copy round-trip\n+# group: [csv]\n+\n+\n+statement ok\n+CREATE TABLE people(id INTEGER, name VARCHAR);\n+\n+statement ok\n+INSERT INTO people VALUES (1, 'Mark'), (2, 'Hannes');\n+\n+statement ok\n+COPY people TO '__TEST_DIR__/test.tsv' WITH (HEADER 1, DELIMITER '\\t');\n+\n+query II\n+SELECT * FROM '__TEST_DIR__/test.tsv'\n+----\n+1\tMark\n+2\tHannes\n+\n+query II\n+SELECT * FROM read_csv('__TEST_DIR__/test.tsv', sep='\\t', columns={'id': 'INTEGER', 'name': 'VARCHAR'}, header=1)\n+----\n+1\tMark\n+2\tHannes\n",
  "problem_statement": "write CSV with tab delimiter outputs 'value1\\tvalue2'\n#### What happens?\r\n\r\n```\r\nCREATE TABLE people(id INTEGER, name VARCHAR);\r\nINSERT INTO people VALUES (1, 'Mark'), (2, 'Hannes');\r\nCOPY (SELECT * FROM people) TO 'test.csv' WITH (HEADER 1, DELIMITER '\\t');\r\n```\r\n\r\n#### To Reproduce\r\nsee above\r\n#### Environment (please complete the following information):\r\n - OS: Singularity container \r\n```\r\n sudo singularity build --sandbox duckdb_0.3.1_python/ docker://python:3.9\r\n```\r\n - DuckDB Version: 0.3.1 (also 0.2.9)\r\n - DuckDB Client: CLI\r\n\r\n#### Before Submitting\r\n\r\n- [ ] **Have you tried this on the latest `master` branch?** NO\r\n\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\r\nDetected on  a real data, confirmed with using the code provided above. \r\n\r\n\r\n\nwrite CSV with tab delimiter outputs 'value1\\tvalue2'\n#### What happens?\r\n\r\n```\r\nCREATE TABLE people(id INTEGER, name VARCHAR);\r\nINSERT INTO people VALUES (1, 'Mark'), (2, 'Hannes');\r\nCOPY (SELECT * FROM people) TO 'test.csv' WITH (HEADER 1, DELIMITER '\\t');\r\n```\r\n\r\n#### To Reproduce\r\nsee above\r\n#### Environment (please complete the following information):\r\n - OS: Singularity container \r\n```\r\n sudo singularity build --sandbox duckdb_0.3.1_python/ docker://python:3.9\r\n```\r\n - DuckDB Version: 0.3.1 (also 0.2.9)\r\n - DuckDB Client: CLI\r\n\r\n#### Before Submitting\r\n\r\n- [ ] **Have you tried this on the latest `master` branch?** NO\r\n\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\r\nDetected on  a real data, confirmed with using the code provided above. \r\n\r\n\r\n\n",
  "hints_text": "\n",
  "created_at": "2021-11-20T12:25:50Z"
}