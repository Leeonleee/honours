{
  "repo": "duckdb/duckdb",
  "pull_number": 8503,
  "instance_id": "duckdb__duckdb-8503",
  "issue_numbers": [
    "2841"
  ],
  "base_commit": "dd7f0c0870d89ae152a53191f87490052579d40e",
  "patch": "diff --git a/tools/rpkg/src/include/typesr.hpp b/tools/rpkg/src/include/typesr.hpp\nindex 8adaafcb160b..d04cc3f4eaf9 100644\n--- a/tools/rpkg/src/include/typesr.hpp\n+++ b/tools/rpkg/src/include/typesr.hpp\n@@ -16,7 +16,7 @@ struct DuckDBAltrepListEntryWrapper {\n \tduckdb::unsafe_unique_array<data_t> data;\n };\n \n-enum class RType {\n+enum class RTypeId {\n \tUNKNOWN,\n \tLOGICAL,\n \tINTEGER,\n@@ -39,11 +39,82 @@ enum class RType {\n \tINTEGER64,\n \tLIST_OF_NULLS,\n \tBLOB,\n+\n+\t// No RType equivalent\n+\tBYTE,\n+\tLIST,\n+\tSTRUCT,\n+};\n+\n+struct RType {\n+\tRType();\n+\tRType(RTypeId id); // NOLINT: Allow implicit conversion from `RTypeId`\n+\tRType(const RType &other);\n+\tRType(RType &&other) noexcept;\n+\n+\tRTypeId id() const;\n+\n+\t// copy assignment\n+\tinline RType &operator=(const RType &other) {\n+\t\tid_ = other.id_;\n+\t\taux_ = other.aux_;\n+\t\treturn *this;\n+\t}\n+\t// move assignment\n+\tinline RType &operator=(RType &&other) noexcept {\n+\t\tid_ = other.id_;\n+\t\tstd::swap(aux_, other.aux_);\n+\t\treturn *this;\n+\t}\n+\n+\tbool operator==(const RType &rhs) const;\n+\tinline bool operator!=(const RType &rhs) const {\n+\t\treturn !(*this == rhs);\n+\t}\n+\n+\tstatic constexpr const RTypeId UNKNOWN = RTypeId::UNKNOWN;\n+\tstatic constexpr const RTypeId LOGICAL = RTypeId::LOGICAL;\n+\tstatic constexpr const RTypeId INTEGER = RTypeId::INTEGER;\n+\tstatic constexpr const RTypeId NUMERIC = RTypeId::NUMERIC;\n+\tstatic constexpr const RTypeId STRING = RTypeId::STRING;\n+\tstatic constexpr const RTypeId DATE = RTypeId::DATE;\n+\tstatic constexpr const RTypeId DATE_INTEGER = RTypeId::DATE_INTEGER;\n+\tstatic constexpr const RTypeId TIMESTAMP = RTypeId::TIMESTAMP;\n+\tstatic constexpr const RTypeId TIME_SECONDS = RTypeId::TIME_SECONDS;\n+\tstatic constexpr const RTypeId TIME_MINUTES = RTypeId::TIME_MINUTES;\n+\tstatic constexpr const RTypeId TIME_HOURS = RTypeId::TIME_HOURS;\n+\tstatic constexpr const RTypeId TIME_DAYS = RTypeId::TIME_DAYS;\n+\tstatic constexpr const RTypeId TIME_WEEKS = RTypeId::TIME_WEEKS;\n+\tstatic constexpr const RTypeId TIME_SECONDS_INTEGER = RTypeId::TIME_SECONDS_INTEGER;\n+\tstatic constexpr const RTypeId TIME_MINUTES_INTEGER = RTypeId::TIME_MINUTES_INTEGER;\n+\tstatic constexpr const RTypeId TIME_HOURS_INTEGER = RTypeId::TIME_HOURS_INTEGER;\n+\tstatic constexpr const RTypeId TIME_DAYS_INTEGER = RTypeId::TIME_DAYS_INTEGER;\n+\tstatic constexpr const RTypeId TIME_WEEKS_INTEGER = RTypeId::TIME_WEEKS_INTEGER;\n+\tstatic constexpr const RTypeId INTEGER64 = RTypeId::INTEGER64;\n+\tstatic constexpr const RTypeId LIST_OF_NULLS = RTypeId::LIST_OF_NULLS;\n+\tstatic constexpr const RTypeId BLOB = RTypeId::BLOB;\n+\n+\tstatic RType FACTOR(cpp11::strings levels);\n+\tVector GetFactorLevels() const;\n+\tsize_t GetFactorLevelsCount() const;\n+\tValue GetFactorValue(int r_value) const;\n+\n+\tstatic RType LIST(const RType &child);\n+\tRType GetListChildType() const;\n+\n+\tstatic RType STRUCT(child_list_t<RType> &&children);\n+\tchild_list_t<RType> GetStructChildTypes() const;\n+\n+private:\n+\tRTypeId id_;\n+\tchild_list_t<RType> aux_;\n };\n \n struct RApiTypes {\n \tstatic RType DetectRType(SEXP v, bool integer64);\n+\tstatic LogicalType LogicalTypeFromRType(const RType &rtype, bool experimental);\n \tstatic string DetectLogicalType(const LogicalType &stype, const char *caller);\n+\tstatic R_len_t GetVecSize(RType rtype, SEXP coldata);\n \tstatic Value SexpToValue(SEXP valsexp, R_len_t idx);\n \tstatic SEXP ValueToSexp(Value &val, string &timezone_config);\n };\n@@ -125,9 +196,12 @@ struct RStringSexpType {\n \tstatic bool IsNull(SEXP val);\n };\n \n-struct RRawSexpType {\n-\tstatic string_t Convert(SEXP val);\n+struct RSexpType {\n \tstatic bool IsNull(SEXP val);\n };\n \n+struct RRawSexpType : public RSexpType {\n+\tstatic string_t Convert(SEXP val);\n+};\n+\n } // namespace duckdb\ndiff --git a/tools/rpkg/src/scan.cpp b/tools/rpkg/src/scan.cpp\nindex a6de173d7323..14bc7581cd34 100644\n--- a/tools/rpkg/src/scan.cpp\n+++ b/tools/rpkg/src/scan.cpp\n@@ -6,20 +6,262 @@\n using namespace duckdb;\n using namespace cpp11;\n \n+data_ptr_t GetColDataPtr(const RType &rtype, SEXP coldata) {\n+\tswitch (rtype.id()) {\n+\tcase RType::LOGICAL:\n+\t\treturn (data_ptr_t)LOGICAL_POINTER(coldata);\n+\tcase RType::INTEGER:\n+\t\treturn (data_ptr_t)INTEGER_POINTER(coldata);\n+\tcase RType::NUMERIC:\n+\t\treturn (data_ptr_t)NUMERIC_POINTER(coldata);\n+\tcase RType::INTEGER64:\n+\t\treturn (data_ptr_t)NUMERIC_POINTER(coldata);\n+\tcase RTypeId::FACTOR:\n+\t\t// TODO What about factors that use numeric?\n+\t\treturn (data_ptr_t)INTEGER_POINTER(coldata);\n+\tcase RType::STRING:\n+\t\treturn (data_ptr_t)DATAPTR_RO(coldata);\n+\tcase RType::TIMESTAMP:\n+\t\treturn (data_ptr_t)NUMERIC_POINTER(coldata);\n+\tcase RType::TIME_SECONDS:\n+\tcase RType::TIME_MINUTES:\n+\tcase RType::TIME_HOURS:\n+\tcase RType::TIME_DAYS:\n+\tcase RType::TIME_WEEKS:\n+\t\treturn (data_ptr_t)NUMERIC_POINTER(coldata);\n+\tcase RType::TIME_SECONDS_INTEGER:\n+\tcase RType::TIME_MINUTES_INTEGER:\n+\tcase RType::TIME_HOURS_INTEGER:\n+\tcase RType::TIME_DAYS_INTEGER:\n+\tcase RType::TIME_WEEKS_INTEGER:\n+\t\treturn (data_ptr_t)INTEGER_POINTER(coldata);\n+\tcase RType::DATE:\n+\t\tif (!IS_NUMERIC(coldata)) {\n+\t\t\tcpp11::stop(\"DATE should really be integer\");\n+\t\t}\n+\t\treturn (data_ptr_t)NUMERIC_POINTER(coldata);\n+\tcase RType::DATE_INTEGER:\n+\t\tif (!IS_INTEGER(coldata)) {\n+\t\t\tcpp11::stop(\"DATE_INTEGER should really be integer\");\n+\t\t}\n+\t\treturn (data_ptr_t)INTEGER_POINTER(coldata);\n+\tcase RType::LIST_OF_NULLS:\n+\tcase RType::BLOB:\n+\t\treturn (data_ptr_t)DATAPTR_RO(coldata);\n+\tcase RTypeId::LIST:\n+\t\treturn (data_ptr_t)DATAPTR_RO(coldata);\n+\tcase RTypeId::STRUCT:\n+\t\t// Will bind child columns dynamically. Could also optimize by descending early and recording.\n+\t\treturn (data_ptr_t)coldata;\n+\tdefault:\n+\t\tcpp11::stop(\"rapi_execute: Unsupported column type for bind\");\n+\t}\n+}\n+\n+struct DedupPointerEnumType {\n+\tstatic bool IsNull(SEXP val) {\n+\t\treturn val == NA_STRING;\n+\t}\n+\tstatic uintptr_t Convert(SEXP val) {\n+\t\treturn (uintptr_t)DATAPTR(val);\n+\t}\n+};\n+\n template <class SRC, class DST, class RTYPE>\n-static void AppendColumnSegment(SRC *source_data, Vector &result, idx_t count) {\n-\tauto result_data = FlatVector::GetData<DST>(result);\n+static void AppendColumnSegment(SRC *source_data, idx_t sexp_offset, Vector &result, idx_t count) {\n+\tsource_data += sexp_offset;\n \tauto &result_mask = FlatVector::Validity(result);\n \tfor (idx_t i = 0; i < count; i++) {\n \t\tauto val = source_data[i];\n \t\tif (RTYPE::IsNull(val)) {\n \t\t\tresult_mask.SetInvalid(i);\n \t\t} else {\n+\t\t\tauto result_data = FlatVector::GetData<DST>(result);\n \t\t\tresult_data[i] = RTYPE::Convert(val);\n \t\t}\n \t}\n }\n \n+void AppendListColumnSegment(const RType &rtype, SEXP *source_data, idx_t sexp_offset, Vector &result, idx_t count) {\n+\tsource_data += sexp_offset;\n+\tauto &result_mask = FlatVector::Validity(result);\n+\tauto child_rtype = rtype.GetListChildType();\n+\tauto result_data = FlatVector::GetData<list_entry_t>(result);\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tauto val = source_data[i];\n+\t\tif (RSexpType::IsNull(val)) {\n+\t\t\tresult_mask.SetInvalid(i);\n+\t\t} else {\n+\t\t\tauto len = RApiTypes::GetVecSize(child_rtype, val);\n+\t\t\tresult_data[i].offset = ListVector::GetListSize(result);\n+\t\t\tfor (R_len_t child_idx = 0; child_idx < len; ++child_idx) {\n+\t\t\t\tauto child_item = RApiTypes::SexpToValue(val, child_idx);\n+\t\t\t\tListVector::PushBack(result, child_item);\n+\t\t\t}\n+\t\t\tresult_data[i].length = len;\n+\t\t}\n+\t}\n+}\n+\n+void AppendAnyColumnSegment(const RType &rtype, bool experimental, data_ptr_t coldata_ptr, idx_t sexp_offset, Vector &v,\n+                            idx_t this_count);\n+\n+void AppendStructColumnSegment(const RType &rtype, bool experimental, SEXP source_data, idx_t sexp_offset,\n+                               Vector &result, idx_t count) {\n+\t// No NULL values for STRUCTs.\n+\tauto &child_entries = StructVector::GetEntries(result);\n+\tauto child_rtypes = rtype.GetStructChildTypes();\n+\tfor (size_t i = 0; i < child_entries.size(); ++i) {\n+\t\tauto coldata = VECTOR_ELT(source_data, i);\n+\t\tauto const &child_rtype = child_rtypes[i].second;\n+\t\tauto coldata_ptr = GetColDataPtr(child_rtype, coldata);\n+\t\tAppendAnyColumnSegment(child_rtype, experimental, coldata_ptr, sexp_offset, *child_entries[i], count);\n+\t}\n+}\n+\n+void AppendAnyColumnSegment(const RType &rtype, bool experimental, data_ptr_t coldata_ptr, idx_t sexp_offset, Vector &v,\n+                            idx_t this_count) {\n+\tswitch (rtype.id()) {\n+\tcase RType::LOGICAL: {\n+\t\tauto data_ptr = (int *)coldata_ptr;\n+\t\tAppendColumnSegment<int, bool, RBooleanType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::INTEGER: {\n+\t\tauto data_ptr = (int *)coldata_ptr;\n+\t\tAppendColumnSegment<int, int, RIntegerType>(data_ptr, sexp_offset, v, this_count);\n+\n+\t\tbreak;\n+\t}\n+\tcase RType::NUMERIC: {\n+\t\tauto data_ptr = (double *)coldata_ptr;\n+\t\tAppendColumnSegment<double, double, RDoubleType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::INTEGER64: {\n+\t\tauto data_ptr = (int64_t *)coldata_ptr;\n+\t\tAppendColumnSegment<int64_t, int64_t, RInteger64Type>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::STRING: {\n+\t\tauto data_ptr = (SEXP *)coldata_ptr;\n+\n+\t\tif (experimental) {\n+\t\t\tD_ASSERT(v.GetType().id() == LogicalTypeId::POINTER);\n+\t\t\tAppendColumnSegment<SEXP, uintptr_t, DedupPointerEnumType>(data_ptr, sexp_offset, v, this_count);\n+\t\t} else {\n+\t\t\tAppendColumnSegment<SEXP, string_t, RStringSexpType>(data_ptr, sexp_offset, v, this_count);\n+\t\t}\n+\n+\t\tbreak;\n+\t}\n+\tcase RTypeId::FACTOR: {\n+\t\tauto data_ptr = (int *)coldata_ptr;\n+\t\tswitch (v.GetType().InternalType()) {\n+\t\tcase PhysicalType::UINT8:\n+\t\t\tAppendColumnSegment<int, uint8_t, RFactorType>(data_ptr, sexp_offset, v, this_count);\n+\t\t\tbreak;\n+\n+\t\tcase PhysicalType::UINT16:\n+\t\t\tAppendColumnSegment<int, uint16_t, RFactorType>(data_ptr, sexp_offset, v, this_count);\n+\t\t\tbreak;\n+\n+\t\tcase PhysicalType::UINT32:\n+\t\t\tAppendColumnSegment<int, uint32_t, RFactorType>(data_ptr, sexp_offset, v, this_count);\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tcpp11::stop(\"rapi_execute: Unknown enum type for scan: %s\",\n+\t\t\t            TypeIdToString(v.GetType().InternalType()).c_str());\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase RType::TIMESTAMP: {\n+\t\tauto data_ptr = (double *)coldata_ptr;\n+\t\tAppendColumnSegment<double, timestamp_t, RTimestampType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_SECONDS: {\n+\t\tauto data_ptr = (double *)coldata_ptr;\n+\t\tAppendColumnSegment<double, dtime_t, RTimeSecondsType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_MINUTES: {\n+\t\tauto data_ptr = (double *)coldata_ptr;\n+\t\tAppendColumnSegment<double, dtime_t, RTimeMinutesType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_HOURS: {\n+\t\tauto data_ptr = (double *)coldata_ptr;\n+\t\tAppendColumnSegment<double, dtime_t, RTimeHoursType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_DAYS: {\n+\t\tauto data_ptr = (double *)coldata_ptr;\n+\t\tAppendColumnSegment<double, dtime_t, RTimeDaysType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_WEEKS: {\n+\t\tauto data_ptr = (double *)coldata_ptr;\n+\t\tAppendColumnSegment<double, dtime_t, RTimeWeeksType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_SECONDS_INTEGER: {\n+\t\tauto data_ptr = (int *)coldata_ptr;\n+\t\tAppendColumnSegment<int, dtime_t, RTimeSecondsType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_MINUTES_INTEGER: {\n+\t\tauto data_ptr = (int *)coldata_ptr;\n+\t\tAppendColumnSegment<int, dtime_t, RTimeMinutesType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_HOURS_INTEGER: {\n+\t\tauto data_ptr = (int *)coldata_ptr;\n+\t\tAppendColumnSegment<int, dtime_t, RTimeHoursType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_DAYS_INTEGER: {\n+\t\tauto data_ptr = (int *)coldata_ptr;\n+\t\tAppendColumnSegment<int, dtime_t, RTimeDaysType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::TIME_WEEKS_INTEGER: {\n+\t\tauto data_ptr = (int *)coldata_ptr;\n+\t\tAppendColumnSegment<int, dtime_t, RTimeWeeksType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::DATE: {\n+\t\tauto data_ptr = (double *)coldata_ptr;\n+\t\tAppendColumnSegment<double, date_t, RDateType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::DATE_INTEGER: {\n+\t\tauto data_ptr = (int *)coldata_ptr;\n+\t\tAppendColumnSegment<int, date_t, RDateType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RType::LIST_OF_NULLS:\n+\tcase RType::BLOB: {\n+\t\tauto data_ptr = (SEXP *)coldata_ptr;\n+\t\tAppendColumnSegment<SEXP, string_t, RRawSexpType>(data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RTypeId::LIST: {\n+\t\tauto data_ptr = (SEXP *)coldata_ptr;\n+\t\tAppendListColumnSegment(rtype, data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tcase RTypeId::STRUCT: {\n+\t\tauto data_ptr = (SEXP)coldata_ptr;\n+\t\tAppendStructColumnSegment(rtype, experimental, data_ptr, sexp_offset, v, this_count);\n+\t\tbreak;\n+\t}\n+\tdefault:\n+\t\tcpp11::stop(\"rapi_execute: Unsupported column type for scan\");\n+\t}\n+}\n+\n static bool get_bool_param(named_parameter_map_t &named_parameters, string name, bool dflt = false) {\n \tbool res = dflt;\n \tauto entry = named_parameters.find(name);\n@@ -75,96 +317,16 @@ static duckdb::unique_ptr<FunctionData> DataFrameScanBind(ClientContext &context\n \tvector<data_ptr_t> data_ptrs;\n \n \tfor (R_xlen_t col_idx = 0; col_idx < df.size(); col_idx++) {\n-\t\tauto coldata = df[col_idx];\n-\t\tLogicalType duckdb_col_type;\n-\t\tdata_ptr_t coldata_ptr = nullptr;\n-\n \t\tnames.push_back(df_names[col_idx]);\n-\t\trtypes.push_back(RApiTypes::DetectRType(coldata, integer64));\n \n-\t\tswitch (rtypes[col_idx]) {\n-\t\tcase RType::LOGICAL:\n-\t\t\tduckdb_col_type = LogicalType::BOOLEAN;\n-\t\t\tcoldata_ptr = (data_ptr_t)LOGICAL_POINTER(coldata);\n-\t\t\tbreak;\n-\t\tcase RType::INTEGER:\n-\t\t\tduckdb_col_type = LogicalType::INTEGER;\n-\t\t\tcoldata_ptr = (data_ptr_t)INTEGER_POINTER(coldata);\n-\t\t\tbreak;\n-\t\tcase RType::NUMERIC:\n-\t\t\tduckdb_col_type = LogicalType::DOUBLE;\n-\t\t\tcoldata_ptr = (data_ptr_t)NUMERIC_POINTER(coldata);\n-\t\t\tbreak;\n-\t\tcase RType::INTEGER64:\n-\t\t\tduckdb_col_type = LogicalType::BIGINT;\n-\t\t\tcoldata_ptr = (data_ptr_t)NUMERIC_POINTER(coldata);\n-\t\t\tbreak;\n-\t\tcase RType::FACTOR: {\n-\t\t\t// TODO What about factors that use numeric?\n-\t\t\tcoldata_ptr = (data_ptr_t)INTEGER_POINTER(coldata);\n-\t\t\tstrings levels = GET_LEVELS(coldata);\n-\t\t\tVector duckdb_levels(LogicalType::VARCHAR, levels.size());\n-\t\t\tauto levels_ptr = FlatVector::GetData<string_t>(duckdb_levels);\n-\t\t\tfor (R_xlen_t level_idx = 0; level_idx < levels.size(); level_idx++) {\n-\t\t\t\tlevels_ptr[level_idx] = StringVector::AddString(duckdb_levels, (string)levels[level_idx]);\n-\t\t\t}\n-\t\t\tduckdb_col_type = LogicalType::ENUM(duckdb_levels, levels.size());\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::STRING:\n-\t\t\tcoldata_ptr = (data_ptr_t)DATAPTR_RO(coldata);\n-\t\t\tif (experimental) {\n-\t\t\t\tduckdb_col_type = RStringsType::Get();\n-\t\t\t} else {\n-\t\t\t\tduckdb_col_type = LogicalType::VARCHAR;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase RType::TIMESTAMP:\n-\t\t\tduckdb_col_type = LogicalType::TIMESTAMP;\n-\t\t\tcoldata_ptr = (data_ptr_t)NUMERIC_POINTER(coldata);\n-\t\t\tbreak;\n-\t\tcase RType::TIME_SECONDS:\n-\t\tcase RType::TIME_MINUTES:\n-\t\tcase RType::TIME_HOURS:\n-\t\tcase RType::TIME_DAYS:\n-\t\tcase RType::TIME_WEEKS:\n-\t\t\tduckdb_col_type = LogicalType::TIME;\n-\t\t\tcoldata_ptr = (data_ptr_t)NUMERIC_POINTER(coldata);\n-\t\t\tbreak;\n-\t\tcase RType::TIME_SECONDS_INTEGER:\n-\t\tcase RType::TIME_MINUTES_INTEGER:\n-\t\tcase RType::TIME_HOURS_INTEGER:\n-\t\tcase RType::TIME_DAYS_INTEGER:\n-\t\tcase RType::TIME_WEEKS_INTEGER:\n-\t\t\tduckdb_col_type = LogicalType::TIME;\n-\t\t\tcoldata_ptr = (data_ptr_t)INTEGER_POINTER(coldata);\n-\t\t\tbreak;\n-\t\tcase RType::DATE:\n-\t\t\tif (!IS_NUMERIC(coldata)) {\n-\t\t\t\tcpp11::stop(\"DATE should really be integer\");\n-\t\t\t}\n-\t\t\tcoldata_ptr = (data_ptr_t)NUMERIC_POINTER(coldata);\n-\t\t\tduckdb_col_type = LogicalType::DATE;\n-\t\t\tbreak;\n-\t\tcase RType::DATE_INTEGER:\n-\t\t\tif (!IS_INTEGER(coldata)) {\n-\t\t\t\tcpp11::stop(\"DATE_INTEGER should really be integer\");\n-\t\t\t}\n-\t\t\tcoldata_ptr = (data_ptr_t)INTEGER_POINTER(coldata);\n-\t\t\tduckdb_col_type = LogicalType::DATE;\n-\t\t\tbreak;\n-\t\tcase RType::BLOB:\n-\t\t\tcoldata_ptr = (data_ptr_t)DATAPTR_RO(coldata);\n-\t\t\tduckdb_col_type = LogicalType::BLOB;\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\tcpp11::stop(\"rapi_execute: Unsupported column type for bind\");\n-\t\t}\n+\t\tauto coldata = df[col_idx];\n+\t\tauto rtype = RApiTypes::DetectRType(coldata, integer64);\n+\t\trtypes.push_back(rtype);\n+\t\treturn_types.push_back(RApiTypes::LogicalTypeFromRType(rtype, experimental));\n \n-\t\treturn_types.push_back(duckdb_col_type);\n-\t\tdata_ptrs.push_back(coldata_ptr);\n+\t\tdata_ptrs.push_back(GetColDataPtr(rtype, coldata));\n \t}\n-\tauto row_count = Rf_length(VECTOR_ELT(df, 0));\n+\tauto row_count = RApiTypes::GetVecSize(rtypes[0], VECTOR_ELT(df, 0));\n \treturn make_uniq<DataFrameScanBindData>(df, row_count, rtypes, data_ptrs, input.named_parameters);\n }\n \n@@ -213,15 +375,6 @@ static unique_ptr<LocalTableFunctionState> DataFrameScanInitLocal(ExecutionConte\n \treturn std::move(result);\n }\n \n-struct DedupPointerEnumType {\n-\tstatic bool IsNull(SEXP val) {\n-\t\treturn val == NA_STRING;\n-\t}\n-\tstatic uintptr_t Convert(SEXP val) {\n-\t\treturn (uintptr_t)DATAPTR(val);\n-\t}\n-};\n-\n static void DataFrameScanFunc(ClientContext &context, TableFunctionInput &data, DataChunk &output) {\n \tauto &bind_data = data.bind_data->Cast<DataFrameScanBindData>();\n \tauto &operator_data = data.local_state->Cast<DataFrameLocalState>();\n@@ -241,6 +394,7 @@ static void DataFrameScanFunc(ClientContext &context, TableFunctionInput &data,\n \t\tauto &v = output.data[out_col_idx];\n \t\tauto src_df_col_idx = operator_data.column_ids[out_col_idx];\n \n+\t\t// Hannes: I love the reference, but would you mind adding a bit of context why this is necessary?\n \t\tif (src_df_col_idx == COLUMN_IDENTIFIER_ROW_ID) {\n \t\t\tValue constant_42 = Value::BIGINT(42);\n \t\t\toutput.data[out_col_idx].Reference(constant_42);\n@@ -248,136 +402,8 @@ static void DataFrameScanFunc(ClientContext &context, TableFunctionInput &data,\n \t\t}\n \n \t\tauto coldata_ptr = bind_data.data_ptrs[src_df_col_idx];\n-\t\tswitch (bind_data.rtypes[src_df_col_idx]) {\n-\t\tcase RType::LOGICAL: {\n-\t\t\tauto data_ptr = (int *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<int, bool, RBooleanType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::INTEGER: {\n-\t\t\tauto data_ptr = (int *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<int, int, RIntegerType>(data_ptr, v, this_count);\n-\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::NUMERIC: {\n-\t\t\tauto data_ptr = (double *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<double, double, RDoubleType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::INTEGER64: {\n-\t\t\tauto data_ptr = (int64_t *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<int64_t, int64_t, RInteger64Type>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::STRING: {\n-\t\t\tauto data_ptr = (SEXP *)coldata_ptr + sexp_offset;\n-\n-\t\t\tif (bind_data.experimental) {\n-\t\t\t\tD_ASSERT(v.GetType().id() == LogicalTypeId::POINTER);\n-\t\t\t\tAppendColumnSegment<SEXP, uintptr_t, DedupPointerEnumType>(data_ptr, v, this_count);\n-\t\t\t} else {\n-\t\t\t\tAppendColumnSegment<SEXP, string_t, RStringSexpType>(data_ptr, v, this_count);\n-\t\t\t}\n-\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::FACTOR: {\n-\t\t\tauto data_ptr = (int *)coldata_ptr + sexp_offset;\n-\t\t\tswitch (v.GetType().InternalType()) {\n-\t\t\tcase PhysicalType::UINT8:\n-\t\t\t\tAppendColumnSegment<int, uint8_t, RFactorType>(data_ptr, v, this_count);\n-\t\t\t\tbreak;\n-\n-\t\t\tcase PhysicalType::UINT16:\n-\t\t\t\tAppendColumnSegment<int, uint16_t, RFactorType>(data_ptr, v, this_count);\n-\t\t\t\tbreak;\n-\n-\t\t\tcase PhysicalType::UINT32:\n-\t\t\t\tAppendColumnSegment<int, uint32_t, RFactorType>(data_ptr, v, this_count);\n-\t\t\t\tbreak;\n-\n-\t\t\tdefault:\n-\t\t\t\tcpp11::stop(\"rapi_execute: Unknown enum type for scan: %s\",\n-\t\t\t\t            TypeIdToString(v.GetType().InternalType()).c_str());\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::TIMESTAMP: {\n-\t\t\tauto data_ptr = (double *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<double, timestamp_t, RTimestampType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::TIME_SECONDS: {\n-\t\t\tauto data_ptr = (double *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<double, dtime_t, RTimeSecondsType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::TIME_MINUTES: {\n-\t\t\tauto data_ptr = (double *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<double, dtime_t, RTimeMinutesType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::TIME_HOURS: {\n-\t\t\tauto data_ptr = (double *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<double, dtime_t, RTimeHoursType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::TIME_DAYS: {\n-\t\t\tauto data_ptr = (double *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<double, dtime_t, RTimeDaysType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::TIME_WEEKS: {\n-\t\t\tauto data_ptr = (double *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<double, dtime_t, RTimeWeeksType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::TIME_SECONDS_INTEGER: {\n-\t\t\tauto data_ptr = (int *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<int, dtime_t, RTimeSecondsType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::TIME_MINUTES_INTEGER: {\n-\t\t\tauto data_ptr = (int *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<int, dtime_t, RTimeMinutesType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::TIME_HOURS_INTEGER: {\n-\t\t\tauto data_ptr = (int *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<int, dtime_t, RTimeHoursType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::TIME_DAYS_INTEGER: {\n-\t\t\tauto data_ptr = (int *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<int, dtime_t, RTimeDaysType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::TIME_WEEKS_INTEGER: {\n-\t\t\tauto data_ptr = (int *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<int, dtime_t, RTimeWeeksType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::DATE: {\n-\t\t\tauto data_ptr = (double *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<double, date_t, RDateType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::DATE_INTEGER: {\n-\t\t\tauto data_ptr = (int *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<int, date_t, RDateType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::BLOB: {\n-\t\t\tauto data_ptr = (SEXP *)coldata_ptr + sexp_offset;\n-\t\t\tAppendColumnSegment<SEXP, string_t, RRawSexpType>(data_ptr, v, this_count);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase RType::LIST_OF_NULLS:\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\tcpp11::stop(\"rapi_execute: Unsupported column type for scan\");\n-\t\t}\n+\t\tauto rtype = bind_data.rtypes[src_df_col_idx];\n+\t\tAppendAnyColumnSegment(rtype, bind_data.experimental, coldata_ptr, sexp_offset, v, this_count);\n \t}\n \n \toperator_data.position += this_count;\ndiff --git a/tools/rpkg/src/types.cpp b/tools/rpkg/src/types.cpp\nindex 2f24dc4bbd5f..65f2c1c37060 100644\n--- a/tools/rpkg/src/types.cpp\n+++ b/tools/rpkg/src/types.cpp\n@@ -8,6 +8,82 @@\n \n using namespace duckdb;\n \n+RType::RType() : id_(RTypeId::UNKNOWN) {\n+}\n+\n+RType::RType(RTypeId id) : id_(id) {\n+}\n+\n+RType::RType(const RType &other) : id_(other.id_), aux_(other.aux_) {\n+}\n+\n+RType::RType(RType &&other) noexcept : id_(other.id_), aux_(std::move(other.aux_)) {\n+}\n+\n+RTypeId RType::id() const {\n+\treturn id_;\n+}\n+\n+bool RType::operator==(const RType &rhs) const {\n+\treturn id_ == rhs.id_ && aux_ == rhs.aux_;\n+}\n+\n+RType RType::FACTOR(cpp11::strings levels) {\n+\tRType out = RType(RTypeId::FACTOR);\n+\tfor (R_xlen_t level_idx = 0; level_idx < levels.size(); level_idx++) {\n+\t\tout.aux_.push_back(std::make_pair(levels[level_idx], RType()));\n+\t}\n+\treturn out;\n+}\n+\n+Vector RType::GetFactorLevels() const {\n+\tD_ASSERT(id_ == RTypeId::FACTOR);\n+\tVector duckdb_levels(LogicalType::VARCHAR, aux_.size());\n+\tauto levels_ptr = FlatVector::GetData<string_t>(duckdb_levels);\n+\tfor (R_xlen_t level_idx = 0; level_idx < aux_.size(); level_idx++) {\n+\t\tlevels_ptr[level_idx] = StringVector::AddString(duckdb_levels, aux_[level_idx].first);\n+\t}\n+\treturn duckdb_levels;\n+}\n+\n+size_t RType::GetFactorLevelsCount() const {\n+\tD_ASSERT(id_ == RTypeId::FACTOR);\n+\treturn aux_.size();\n+}\n+\n+Value RType::GetFactorValue(int r_value) const {\n+\tD_ASSERT(id_ == RTypeId::FACTOR);\n+\tbool is_null = RIntegerType::IsNull(r_value);\n+\tif (!is_null) {\n+\t\tauto str_val = aux_[r_value - 1].first;\n+\t\treturn Value(str_val);\n+\t} else {\n+\t\treturn Value(LogicalType::VARCHAR);\n+\t}\n+}\n+\n+RType RType::LIST(const RType &child) {\n+\tRType out = RType(RTypeId::LIST);\n+\tout.aux_.push_back(std::make_pair(\"\", child));\n+\treturn out;\n+}\n+\n+RType RType::GetListChildType() const {\n+\tD_ASSERT(id_ == RTypeId::LIST);\n+\treturn aux_.front().second;\n+}\n+\n+RType RType::STRUCT(child_list_t<RType> &&children) {\n+\tRType out = RType(RTypeId::STRUCT);\n+\tstd::swap(out.aux_, children);\n+\treturn out;\n+}\n+\n+child_list_t<RType> RType::GetStructChildTypes() const {\n+\tD_ASSERT(id_ == RTypeId::STRUCT);\n+\treturn aux_;\n+}\n+\n RType RApiTypes::DetectRType(SEXP v, bool integer64) {\n \tif (TYPEOF(v) == REALSXP && Rf_inherits(v, \"POSIXct\")) {\n \t\treturn RType::TIMESTAMP;\n@@ -54,11 +130,13 @@ RType RApiTypes::DetectRType(SEXP v, bool integer64) {\n \t\t\treturn RType::UNKNOWN;\n \t\t}\n \t} else if (Rf_isFactor(v) && TYPEOF(v) == INTSXP) {\n-\t\treturn RType::FACTOR;\n+\t\treturn RType::FACTOR(GET_LEVELS(v));\n \t} else if (TYPEOF(v) == LGLSXP) {\n \t\treturn RType::LOGICAL;\n \t} else if (TYPEOF(v) == INTSXP) {\n \t\treturn RType::INTEGER;\n+\t} else if (TYPEOF(v) == RAWSXP) {\n+\t\treturn RTypeId::BYTE;\n \t} else if (TYPEOF(v) == REALSXP) {\n \t\tif (integer64 && Rf_inherits(v, \"integer64\")) {\n \t\t\treturn RType::INTEGER64;\n@@ -71,34 +149,117 @@ RType RApiTypes::DetectRType(SEXP v, bool integer64) {\n \t\t\treturn RType::BLOB;\n \t\t}\n \n-\t\tR_xlen_t len = Rf_length(v);\n-\t\tR_xlen_t i = 0;\n-\t\tfor (; i < len; ++i) {\n-\t\t\tauto elt = VECTOR_ELT(v, i);\n-\t\t\tif (TYPEOF(elt) == RAWSXP) {\n-\t\t\t\tbreak;\n+\t\tif (Rf_inherits(v, \"data.frame\")) {\n+\t\t\tchild_list_t<RType> child_types;\n+\t\t\tR_xlen_t ncol = Rf_length(v);\n+\t\t\tSEXP names = GET_NAMES(v);\n+\n+\t\t\tfor (R_xlen_t i = 0; i < ncol; ++i) {\n+\t\t\t\tRType child = DetectRType(VECTOR_ELT(v, i), integer64);\n+\t\t\t\tif (child == RType::UNKNOWN) {\n+\t\t\t\t\treturn (RType::UNKNOWN);\n+\t\t\t\t}\n+\t\t\t\tchild_types.push_back(std::make_pair(CHAR(STRING_ELT(names, i)), child));\n \t\t\t}\n-\t\t\tif (elt != R_NilValue) {\n-\t\t\t\treturn RType::UNKNOWN;\n+\n+\t\t\treturn RType::STRUCT(std::move(child_types));\n+\t\t} else {\n+\t\t\tR_xlen_t len = Rf_xlength(v);\n+\t\t\tR_xlen_t i = 0;\n+\t\t\tauto type = RType();\n+\t\t\tfor (; i < len; ++i) {\n+\t\t\t\tauto elt = VECTOR_ELT(v, i);\n+\t\t\t\tif (elt != R_NilValue) {\n+\t\t\t\t\ttype = DetectRType(elt, integer64);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n \n-\t\tif (i == len) {\n-\t\t\treturn RType::LIST_OF_NULLS;\n-\t\t}\n+\t\t\tif (i == len) {\n+\t\t\t\treturn RType::LIST_OF_NULLS;\n+\t\t\t}\n \n-\t\tfor (; i < len; ++i) {\n-\t\t\tauto elt = VECTOR_ELT(v, i);\n-\t\t\tif (TYPEOF(elt) != RAWSXP && elt != R_NilValue) {\n-\t\t\t\treturn RType::UNKNOWN;\n+\t\t\tfor (; i < len; ++i) {\n+\t\t\t\tauto elt = VECTOR_ELT(v, i);\n+\t\t\t\tif (elt != R_NilValue) {\n+\t\t\t\t\tauto new_type = DetectRType(elt, integer64);\n+\t\t\t\t\tif (new_type != type) {\n+\t\t\t\t\t\treturn RType::UNKNOWN;\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n \n-\t\treturn RType::BLOB;\n+\t\t\tif (type == RTypeId::BYTE) {\n+\t\t\t\treturn RType::BLOB;\n+\t\t\t}\n+\n+\t\t\treturn RType::LIST(type);\n+\t\t}\n \t}\n \treturn RType::UNKNOWN;\n }\n \n+LogicalType RApiTypes::LogicalTypeFromRType(const RType &rtype, bool experimental) {\n+\tswitch (rtype.id()) {\n+\tcase RType::LOGICAL:\n+\t\treturn LogicalType::BOOLEAN;\n+\tcase RType::INTEGER:\n+\t\treturn LogicalType::INTEGER;\n+\tcase RType::NUMERIC:\n+\t\treturn LogicalType::DOUBLE;\n+\tcase RType::INTEGER64:\n+\t\treturn LogicalType::BIGINT;\n+\tcase RTypeId::FACTOR: {\n+\t\tauto duckdb_levels = rtype.GetFactorLevels();\n+\t\treturn LogicalType::ENUM(duckdb_levels, rtype.GetFactorLevelsCount());\n+\t}\n+\tcase RType::STRING:\n+\t\tif (experimental) {\n+\t\t\treturn RStringsType::Get();\n+\t\t} else {\n+\t\t\treturn LogicalType::VARCHAR;\n+\t\t}\n+\t\tbreak;\n+\tcase RType::TIMESTAMP:\n+\t\treturn LogicalType::TIMESTAMP;\n+\tcase RType::TIME_SECONDS:\n+\tcase RType::TIME_MINUTES:\n+\tcase RType::TIME_HOURS:\n+\tcase RType::TIME_DAYS:\n+\tcase RType::TIME_WEEKS:\n+\t\treturn LogicalType::TIME;\n+\tcase RType::TIME_SECONDS_INTEGER:\n+\tcase RType::TIME_MINUTES_INTEGER:\n+\tcase RType::TIME_HOURS_INTEGER:\n+\tcase RType::TIME_DAYS_INTEGER:\n+\tcase RType::TIME_WEEKS_INTEGER:\n+\t\treturn LogicalType::TIME;\n+\tcase RType::DATE:\n+\t\treturn LogicalType::DATE;\n+\tcase RType::DATE_INTEGER:\n+\t\treturn LogicalType::DATE;\n+\tcase RType::LIST_OF_NULLS:\n+\tcase RType::BLOB:\n+\t\treturn LogicalType::BLOB;\n+\tcase RTypeId::LIST:\n+\t\treturn LogicalType::LIST(RApiTypes::LogicalTypeFromRType(rtype.GetListChildType(), experimental));\n+\tcase RTypeId::STRUCT: {\n+\t\tchild_list_t<LogicalType> children;\n+\t\tfor (const auto &child : rtype.GetStructChildTypes()) {\n+\t\t\tchildren.push_back(\n+\t\t\t    std::make_pair(child.first, RApiTypes::LogicalTypeFromRType(child.second, experimental)));\n+\t\t}\n+\t\tif (children.size() == 0) {\n+\t\t\tcpp11::stop(\"rapi_execute: Packed column must have at least one column\");\n+\t\t}\n+\t\treturn LogicalType::STRUCT(std::move(children));\n+\t}\n+\n+\tdefault:\n+\t\tcpp11::stop(\"rapi_execute: Can't convert R type to logical type\");\n+\t}\n+}\n+\n string RApiTypes::DetectLogicalType(const LogicalType &stype, const char *caller) {\n \n \tif (stype.GetAlias() == R_STRING_TYPE_NAME) {\n@@ -226,10 +387,10 @@ bool RStringSexpType::IsNull(SEXP val) {\n \treturn val == NA_STRING;\n }\n \n-string_t RRawSexpType::Convert(SEXP val) {\n-\treturn string_t((char *)RAW(val), Rf_xlength(val));\n+bool RSexpType::IsNull(SEXP val) {\n+\treturn val == R_NilValue;\n }\n \n-bool RRawSexpType::IsNull(SEXP val) {\n-\treturn val == R_NilValue;\n+string_t RRawSexpType::Convert(SEXP val) {\n+\treturn string_t((char *)RAW(val), Rf_xlength(val));\n }\ndiff --git a/tools/rpkg/src/utils.cpp b/tools/rpkg/src/utils.cpp\nindex 5dd70b91a0a1..f47899ee3721 100644\n--- a/tools/rpkg/src/utils.cpp\n+++ b/tools/rpkg/src/utils.cpp\n@@ -97,9 +97,19 @@ static void AppendColumnSegment(SRC *source_data, Vector &result, idx_t count) {\n \t}\n }\n \n+R_len_t RApiTypes::GetVecSize(RType rtype, SEXP coldata) {\n+\twhile (rtype.id() == RTypeId::STRUCT) {\n+\t\trtype = rtype.GetStructChildTypes()[0].second;\n+\t\tD_ASSERT(TYPEOF(coldata) == VECSXP);\n+\t\tcoldata = VECTOR_ELT(coldata, 0);\n+\t}\n+\t// This still isn't quite accurate, but good enough for the types we support.\n+\treturn Rf_length(coldata);\n+}\n+\n Value RApiTypes::SexpToValue(SEXP valsexp, R_len_t idx) {\n \tauto rtype = RApiTypes::DetectRType(valsexp, false); // TODO\n-\tswitch (rtype) {\n+\tswitch (rtype.id()) {\n \tcase RType::LOGICAL: {\n \t\tauto lgl_val = INTEGER_POINTER(valsexp)[idx];\n \t\treturn RBooleanType::IsNull(lgl_val) ? Value(LogicalType::BOOLEAN) : Value::BOOLEAN(lgl_val);\n@@ -121,16 +131,9 @@ Value RApiTypes::SexpToValue(SEXP valsexp, R_len_t idx) {\n \t\tauto str_val = STRING_ELT(ToUtf8(valsexp), idx);\n \t\treturn str_val == NA_STRING ? Value(LogicalType::VARCHAR) : Value(CHAR(str_val));\n \t}\n-\tcase RType::FACTOR: {\n+\tcase RTypeId::FACTOR: {\n \t\tauto int_val = INTEGER_POINTER(valsexp)[idx];\n-\t\tauto levels = GET_LEVELS(valsexp);\n-\t\tbool is_null = RIntegerType::IsNull(int_val);\n-\t\tif (!is_null) {\n-\t\t\tauto str_val = STRING_ELT(levels, int_val - 1);\n-\t\t\treturn Value(CHAR(str_val));\n-\t\t} else {\n-\t\t\treturn Value(LogicalType::VARCHAR);\n-\t\t}\n+\t\treturn rtype.GetFactorValue(int_val);\n \t}\n \tcase RType::TIMESTAMP: {\n \t\tauto ts_val = NUMERIC_POINTER(valsexp)[idx];\n@@ -192,11 +195,34 @@ Value RApiTypes::SexpToValue(SEXP valsexp, R_len_t idx) {\n \t\treturn RIntegerType::IsNull(ts_val) ? Value(LogicalType::TIME) : Value::TIME(RTimeWeeksType::Convert(ts_val));\n \t}\n \tcase RType::LIST_OF_NULLS:\n-\t\treturn Value();\n+\t\t// Performance shortcut: this corresponds to the RType::BLOB case,\n+\t\t// but we already know that all values are NULL\n+\t\treturn Value(LogicalType::BLOB);\n \tcase RType::BLOB: {\n \t\tauto ts_val = VECTOR_ELT(valsexp, idx);\n \t\treturn Rf_isNull(ts_val) ? Value(LogicalType::BLOB) : Value::BLOB(RAW(ts_val), Rf_xlength(ts_val));\n \t}\n+\tcase RTypeId::LIST: {\n+\t\tauto ts_val = VECTOR_ELT(valsexp, idx);\n+\t\tauto child_rtype = rtype.GetListChildType();\n+\t\tvector<Value> child_values;\n+\t\tR_len_t child_len = GetVecSize(child_rtype, ts_val);\n+\t\tfor (R_len_t child_idx = 0; child_idx < child_len; ++child_idx) {\n+\t\t\tauto value = SexpToValue(ts_val, child_idx);\n+\t\t\tchild_values.push_back(value);\n+\t\t}\n+\t\treturn Value::LIST(std::move(child_values));\n+\t}\n+\tcase RTypeId::STRUCT: {\n+\t\tchild_list_t<Value> child_values;\n+\t\tauto ncol = Rf_length(valsexp);\n+\t\tauto child_rtypes = rtype.GetStructChildTypes();\n+\t\tfor (R_len_t col = 0; col < ncol; ++col) {\n+\t\t\tauto value = SexpToValue(VECTOR_ELT(valsexp, col), idx);\n+\t\t\tchild_values.push_back(std::make_pair(child_rtypes[col].first, value));\n+\t\t}\n+\t\treturn Value::STRUCT(std::move(child_values));\n+\t}\n \tdefault:\n \t\tcpp11::stop(\"duckdb_sexp_to_value: Unsupported type\");\n \t\treturn Value();\n",
  "test_patch": "diff --git a/tools/rpkg/tests/testthat/test_register.R b/tools/rpkg/tests/testthat/test_register.R\nindex 083a545eb205..8359580f2833 100644\n--- a/tools/rpkg/tests/testthat/test_register.R\n+++ b/tools/rpkg/tests/testthat/test_register.R\n@@ -72,8 +72,19 @@ test_that(\"experimental string handling works\", {\n   on.exit(dbDisconnect(con, shutdown = TRUE))\n   df <- data.frame(a=c(NA, as.character(1:10000)))\n \n- duckdb_register(con, \"df\", df, experimental=TRUE)\n+  duckdb_register(con, \"df\", df, experimental=TRUE)\n \n   expect_equal(df, dbGetQuery(con, \"SELECT a::STRING a FROM df\"))\n   expect_equal(df, dbGetQuery(con, \"SELECT a FROM df\"))\n })\n+\n+test_that(\"can register list of NULL values\", {\n+  con <- dbConnect(duckdb())\n+  on.exit(dbDisconnect(con, shutdown = TRUE))\n+  df <- tibble::tibble(a = 1:2, b = list(NULL))\n+\n+  expect_silent(duckdb_register(con, \"df1\", df))\n+  expect_silent(duckdb_register(con, \"df2\", df[0, ]))\n+\n+  expect_equal(dbGetQuery(con, \"SELECT * FROM df1\"), as.data.frame(df))\n+})\ndiff --git a/tools/rpkg/tests/testthat/test_struct.R b/tools/rpkg/tests/testthat/test_struct.R\nindex 3c5874c205d9..848941c30031 100644\n--- a/tools/rpkg/tests/testthat/test_struct.R\n+++ b/tools/rpkg/tests/testthat/test_struct.R\n@@ -108,3 +108,69 @@ test_that(\"structs give the same results via Arrow\", {\n     )\n   ))\n })\n+\n+test_that(\"nested lists of atomic values can be written\", {\n+  skip_if_not_installed(\"vctrs\")\n+\n+  con <- dbConnect(duckdb())\n+  on.exit(dbDisconnect(con, shutdown = TRUE))\n+\n+  df <- vctrs::data_frame(a = 1:3, b = list(4:6, 2:3, 1L))\n+  dbWriteTable(con, \"df\", df)\n+  expect_equal(dbReadTable(con, \"df\"), df)\n+\n+  duckdb_register(con, \"df_reg\", df)\n+  expect_equal(dbReadTable(con, \"df_reg\"), df)\n+\n+  df2 <- vctrs::data_frame(a = 1:2, b = list(4:6, letters[2:3]))\n+  expect_error(dbWriteTable(con, \"df2\", df2), \"register\")\n+  expect_error(duckdb_register(con, \"df2_reg\", df2), \"register\")\n+})\n+\n+test_that(\"nested and packed columns work in full\", {\n+  skip_if_not_installed(\"vctrs\")\n+\n+  con <- dbConnect(duckdb())\n+  on.exit(dbDisconnect(con, shutdown = TRUE))\n+\n+  df <- vctrs::data_frame(\n+    a = vctrs::data_frame(\n+      x = 1:5,\n+      y = as.numeric(6:10),\n+      z = vctrs::data_frame(\n+        k = c(TRUE, FALSE, NA, TRUE, FALSE),\n+        l = letters[1:5]\n+      )\n+    ),\n+    b = list(\n+      vctrs::data_frame(\n+        u = structure(as.numeric(19577:19578), class = \"Date\"),\n+        v = structure(19577:19578, class = \"Date\"),\n+        w = structure(1691507820, class = c(\"POSIXct\", \"POSIXt\"), tzone = \"UTC\") + 0:1\n+      )\n+    ),\n+    c = list(\n+      vctrs::data_frame(\n+        # TIME_MINUTES, TIME_MINUTES_INTEGER, TIME_HOURS, ... etc.: Loss ok\n+        d = structure(as.numeric(13:16), class = \"difftime\", units = \"secs\"),\n+        e = vctrs::data_frame(\n+          u = structure(17:20, class = \"difftime\", units = \"secs\"),\n+          v = 5:8,\n+          w = as.list(9:12)\n+        )\n+      )\n+    ),\n+    f = list(\n+      vctrs::data_frame(\n+        g = list(as.raw(13), as.raw(14:15), as.raw(16:18), as.raw(19:22)),\n+        h = vctrs::data_frame(u = 1:4, v = 5:8, w = list(vctrs::data_frame(s = 9:10)))\n+      )\n+    ),\n+    i = \"plain old\"\n+  )\n+  dbWriteTable(con, \"df\", df)\n+  expect_equal(dbReadTable(con, \"df\"), df)\n+\n+  duckdb_register(con, \"df_reg\", df)\n+  expect_equal(dbReadTable(con, \"df_reg\"), df)\n+})\n",
  "problem_statement": "R list column support (R is freezing)\nHi folks,\r\n\r\nEvery time I try to write an R dataframe with a column of 'list' type to a DuckDB database, R completely freezes with this message: `Error in duckdb_register(conn, view_name, value): Unsupported column type scan`.\r\n\r\nHere is a MWE:\r\n```\r\n.path = tempfile()\r\ncon = DBI::dbConnect(duckdb::duckdb(), dbdir = .path, read_only = FALSE)\r\n\r\nDBI::dbExecute(con, \"CREATE TABLE df(id1 INTEGER not null,\r\n                                 id2 VARCHAR not NULL, \r\n                                 int_list INT[], \r\n                                 varchar_list VARCHAR[],\r\n                                 primary key (id1, id2))\")\r\n\r\ndf <- tibble::tibble(id1 = as.integer(2), id2 = c(\"a\"),\r\n                     int_list = list(as.integer(1:3)),\r\n                     varchar_list = list(c(\"a\",\"b\")))\r\n\r\nDBI::dbWriteTable(con, 'df', df, append=TRUE)\r\n```\r\n\r\n(1) Can't DuckDB nested types `integer list column` and `varchar list column` handle R lists?\r\nIf not, is there a plan to support it or at least avoid crashing/freezing R?\r\n\r\n(2) As a side-question, is there a way to alter DuckDB database to add Primary Keys? This would be important because the current method (declaring primary keys while creating a new table) requires a lot of manual work, like typing all columns of my R dataframe I want to copy to DuckDB (in some cases I have thousands of columns, which would make that impracticable).\r\n\r\nThanks a lot.\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Windows 10 Pro\r\n - DuckDB Version: 0.3.1-1\r\n - DuckDB Client: R\r\n\r\n\r\n\n",
  "hints_text": "It certainly should not crash or freeze in any case.\n> It certainly should not crash or freeze in any case.\r\n\r\n@hannesmuehleisen , I agree but for some reason it is happening with me every time on R 4.1.1, Windows 10, DuckDB 0.3.1-1.\r\n\r\nHave you been able to reproduce the issue?\r\n\nYes I can confirm this hangs after the error message. What I meant was that we need to look into it.\nCC @krlmlr \nThis issue is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.\nI checked now, the issue still remains.\nReprex with a99f5ce0be64bc4ff11fe5257896f88724658b45:\r\n\r\n``` r\r\ncon <- DBI::dbConnect(duckdb::duckdb())\r\n\r\nDBI::dbExecute(con, \"CREATE TABLE df(id1 INTEGER not null,\r\n                                 id2 VARCHAR not NULL,\r\n                                 int_list INT[],\r\n                                 varchar_list VARCHAR[],\r\n                                 primary key (id1, id2))\")\r\n#> [1] 0\r\n\r\ndf <- tibble::tibble(\r\n  id1 = as.integer(2), id2 = c(\"a\"),\r\n  int_list = list(as.integer(1:3)),\r\n  varchar_list = list(c(\"a\", \"b\"))\r\n)\r\n\r\nDBI::dbWriteTable(con, \"df\", df, append = TRUE)\r\n#> Error: rapi_execute: Unsupported column type for bind\r\n#> Error: rapi_register_df: Failed to register data frame: std::exception\r\n```\r\n\r\n<sup>Created on 2023-08-04 with [reprex v2.0.2](https://reprex.tidyverse.org)</sup>\nIt's not as bad as it seems though -- getting nested data from duckdb to R works:\r\n\r\n``` r\r\ncon <- DBI::dbConnect(duckdb::duckdb())\r\n\r\nout <- DBI::dbGetQuery(con, \"SELECT 1 AS a, {'x': 1, 'y': 2, 'z': 3} AS b\")\r\nout\r\n#>   a b.x b.y b.z\r\n#> 1 1   1   2   3\r\ntibble::as_tibble(out)\r\n#> # A tibble: 1 \u00d7 2\r\n#>       a   b$x    $y    $z\r\n#>   <int> <int> <int> <int>\r\n#> 1     1     1     2     3\r\n\r\n\r\nout <- DBI::dbGetQuery(con, \"SELECT 1 AS a, [{'x': 1, 'y': 2, 'z': 3}, {'x': 4, 'y': 5, 'z': 6}] AS b\")\r\nout\r\n#>   a                b\r\n#> 1 1 1, 4, 2, 5, 3, 6\r\ntibble::as_tibble(out)\r\n#> # A tibble: 1 \u00d7 2\r\n#>       a b           \r\n#>   <int> <list>      \r\n#> 1     1 <df [2 \u00d7 3]>\r\n```\r\n\r\n<sup>Created on 2023-08-04 with [reprex v2.0.2](https://reprex.tidyverse.org)</sup>\nIf we get to implement this, I think the following tests need to succeed:\r\n\r\n```r\r\ntest_that(\"bind plain lists of values\", {\r\n  con <- dbConnect(duckdb())\r\n  on.exit(dbDisconnect(con, shutdown = TRUE))\r\n\r\n  df <- tibble::tibble(a = 1, b = list(2:3))\r\n  expect_equal(rel_to_altrep(rel_from_df(con, df)), df)\r\n})\r\n\r\ntest_that(\"bind packed tibble\", {\r\n  con <- dbConnect(duckdb())\r\n  on.exit(dbDisconnect(con, shutdown = TRUE))\r\n\r\n  df <- tibble::tibble(a = 1, b = tibble::tibble(c = 2, d = 3))\r\n  expect_equal(rel_to_altrep(rel_from_df(con, df)), df)\r\n})\r\n\r\ntest_that(\"bind nested tibble\", {\r\n  con <- dbConnect(duckdb())\r\n  on.exit(dbDisconnect(con, shutdown = TRUE))\r\n\r\n  df <- tibble::tibble(a = 1, b = list(tibble::tibble(c = 2:3, d = 4:5)))\r\n  expect_equal(rel_to_altrep(rel_from_df(con, df)), df)\r\n})\r\n```",
  "created_at": "2023-08-07T14:51:11Z"
}