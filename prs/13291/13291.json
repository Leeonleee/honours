{
  "repo": "duckdb/duckdb",
  "pull_number": 13291,
  "instance_id": "duckdb__duckdb-13291",
  "issue_numbers": [
    "12582",
    "12582"
  ],
  "base_commit": "566eb853c82d4e7403603efe0beada4429434128",
  "patch": "diff --git a/src/include/duckdb/planner/subquery/flatten_dependent_join.hpp b/src/include/duckdb/planner/subquery/flatten_dependent_join.hpp\nindex 991e084c42ab..9b7ad035389e 100644\n--- a/src/include/duckdb/planner/subquery/flatten_dependent_join.hpp\n+++ b/src/include/duckdb/planner/subquery/flatten_dependent_join.hpp\n@@ -29,7 +29,8 @@ struct FlattenDependentJoins {\n \tbool MarkSubtreeCorrelated(LogicalOperator &op);\n \n \t//! Push the dependent join down a LogicalOperator\n-\tunique_ptr<LogicalOperator> PushDownDependentJoin(unique_ptr<LogicalOperator> plan);\n+\tunique_ptr<LogicalOperator> PushDownDependentJoin(unique_ptr<LogicalOperator> plan,\n+\t                                                  bool propagates_null_values = true);\n \n \tBinder &binder;\n \tColumnBinding base_binding;\ndiff --git a/src/planner/binder/query_node/plan_subquery.cpp b/src/planner/binder/query_node/plan_subquery.cpp\nindex af70d7e033e0..860b17914aca 100644\n--- a/src/planner/binder/query_node/plan_subquery.cpp\n+++ b/src/planner/binder/query_node/plan_subquery.cpp\n@@ -429,7 +429,7 @@ unique_ptr<LogicalOperator> Binder::PlanLateralJoin(unique_ptr<LogicalOperator>\n \t// first we check which logical operators have correlated expressions in the first place\n \tflatten.DetectCorrelatedExpressions(*right, true);\n \t// now we push the dependent join down\n-\tauto dependent_join = flatten.PushDownDependentJoin(std::move(right));\n+\tauto dependent_join = flatten.PushDownDependentJoin(std::move(right), join_type != JoinType::INNER);\n \n \t// now the dependent join is fully eliminated\n \t// we only need to create the join conditions between the LHS and the RHS\ndiff --git a/src/planner/subquery/flatten_dependent_join.cpp b/src/planner/subquery/flatten_dependent_join.cpp\nindex 4c60d299d779..ac36e9eaef4c 100644\n--- a/src/planner/subquery/flatten_dependent_join.cpp\n+++ b/src/planner/subquery/flatten_dependent_join.cpp\n@@ -87,8 +87,8 @@ bool FlattenDependentJoins::MarkSubtreeCorrelated(LogicalOperator &op) {\n \treturn has_correlation;\n }\n \n-unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoin(unique_ptr<LogicalOperator> plan) {\n-\tbool propagate_null_values = true;\n+unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoin(unique_ptr<LogicalOperator> plan,\n+                                                                         bool propagate_null_values) {\n \tauto result = PushDownDependentJoinInternal(std::move(plan), propagate_null_values, 0);\n \tif (!replacement_map.empty()) {\n \t\t// check if we have to replace any COUNT aggregates into \"CASE WHEN X IS NULL THEN 0 ELSE COUNT END\"\n@@ -255,18 +255,32 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t\t\tdelim_column_offset = aggr.groups.size() - correlated_columns.size();\n \t\t\tdelim_data_offset = aggr.groups.size();\n \t\t}\n-\t\tif (aggr.groups.size() == new_group_count) {\n-\t\t\t// we have to perform a LEFT OUTER JOIN between the result of this aggregate and the delim scan\n-\t\t\t// FIXME: this does not always have to be a LEFT OUTER JOIN, depending on whether aggr.expressions return\n+\t\tbool ungrouped_join = false;\n+\t\tif (aggr.grouping_sets.empty()) {\n+\t\t\tungrouped_join = aggr.groups.size() == new_group_count;\n+\t\t} else {\n+\t\t\tfor (auto &grouping_set : aggr.grouping_sets) {\n+\t\t\t\tif (grouping_set.size() == new_group_count) {\n+\t\t\t\t\tungrouped_join = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (ungrouped_join) {\n+\t\t\t// we have to perform an INNER or LEFT OUTER JOIN between the result of this aggregate and the delim scan\n+\t\t\t// this does not always have to be a LEFT OUTER JOIN, depending on whether aggr.expressions return\n \t\t\t// NULL or a value\n-\t\t\tunique_ptr<LogicalComparisonJoin> join = make_uniq<LogicalComparisonJoin>(JoinType::INNER);\n+\t\t\tJoinType join_type = JoinType::INNER;\n+\t\t\tif (any_join || !parent_propagate_null_values) {\n+\t\t\t\tjoin_type = JoinType::LEFT;\n+\t\t\t}\n \t\t\tfor (auto &aggr_exp : aggr.expressions) {\n \t\t\t\tauto &b_aggr_exp = aggr_exp->Cast<BoundAggregateExpression>();\n-\t\t\t\tif (!b_aggr_exp.PropagatesNullValues() || any_join || !parent_propagate_null_values) {\n-\t\t\t\t\tjoin = make_uniq<LogicalComparisonJoin>(JoinType::LEFT);\n+\t\t\t\tif (!b_aggr_exp.PropagatesNullValues()) {\n+\t\t\t\t\tjoin_type = JoinType::LEFT;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tunique_ptr<LogicalComparisonJoin> join = make_uniq<LogicalComparisonJoin>(join_type);\n \t\t\tauto left_index = binder.GenerateTableIndex();\n \t\t\tdelim_scan = make_uniq<LogicalDelimGet>(left_index, delim_types);\n \t\t\tjoin->children.push_back(std::move(delim_scan));\n",
  "test_patch": "diff --git a/test/sql/subquery/lateral/lateral_grouping_sets.test b/test/sql/subquery/lateral/lateral_grouping_sets.test\nnew file mode 100644\nindex 000000000000..4c730aa61fe8\n--- /dev/null\n+++ b/test/sql/subquery/lateral/lateral_grouping_sets.test\n@@ -0,0 +1,48 @@\n+# name: test/sql/subquery/lateral/lateral_grouping_sets.test\n+# description: Test LATERAL join with empty grouping sets\n+# group: [lateral]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query III\n+select x, a, b\n+from\n+(values (1), (2)) t2(x),\n+lateral (select count(*), count(a) from (select 1, 2 where 1 = x) t(a, b) group by grouping sets ((), (b), (a, b))) t3(a, b)\n+order by all;\n+----\n+1\t1\t1\n+1\t1\t1\n+1\t1\t1\n+2\t0\t0\n+\n+query II\n+select x, a\n+from\n+(values (1), (2)) t2(x),\n+lateral (select sum(a) from (select 1, 2 where 1 = x) t(a, b) group by grouping sets ((), (b), (a, b))) t3(a)\n+order by all;\n+----\n+1\t1\n+1\t1\n+1\t1\n+2\tNULL\n+\n+query II\n+select *\n+  from\n+  (values (1), (2)) t2(x), lateral (select sum(a) from (select 42 a) where x=1)\n+order by all\n+----\n+1\t42\n+2\tNULL\n+\n+query II\n+select *\n+  from\n+  (values (1), (2)) t2(x) left join (select sum(a) from (select 42 a) where x=1) on (1=1)\n+order by all\n+----\n+1\t42\n+2\tNULL\n",
  "problem_statement": "Query unnesting with grouping sets results in wrong output\n### What happens?\n\nThe following two queries should return the same result:\r\n```sql\r\nselect x, a, b\r\nfrom\r\n(values (1), (2)) t2(x),\r\nlateral (select count(*), count(a) from (select 1, 2 where 1 = x) t(a, b) group by grouping sets ((), (b), (a, b))) t3(a, b);\r\n\r\nselect x, a, b\r\nfrom\r\n(\r\nselect 1, count(*), count(a) from (select 1, 2 where 1 = 1) t(a, b) group by grouping sets ((), (b), (a, b))\r\nunion all\r\nselect 2, count(*), count(a) from (select 1, 2 where 1 = 2) t(a, b) group by grouping sets ((), (b), (a, b))\r\n) t3(x, a, b);\r\n```\r\n\r\nThe correct result for both queries (also returned by Postgres) is:\r\n```\r\nx,a,b\r\n1,1,1\r\n1,1,1\r\n1,1,1\r\n2,0,0\r\n```\r\n\r\nHowever, for the first query, duckdb returns:\r\n```\r\nx,a,b\r\n1,1,1\r\n1,1,1\r\n1,1,1\r\n```\n\n### To Reproduce\n\nThe queries require no database, thus DuckDB CLI can be used to reproduce.\r\nI can also reproduce on DuckDB WASM.\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n1.0\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nAltan Birler\n\n### Affiliation:\n\nTUM\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\nQuery unnesting with grouping sets results in wrong output\n### What happens?\n\nThe following two queries should return the same result:\r\n```sql\r\nselect x, a, b\r\nfrom\r\n(values (1), (2)) t2(x),\r\nlateral (select count(*), count(a) from (select 1, 2 where 1 = x) t(a, b) group by grouping sets ((), (b), (a, b))) t3(a, b);\r\n\r\nselect x, a, b\r\nfrom\r\n(\r\nselect 1, count(*), count(a) from (select 1, 2 where 1 = 1) t(a, b) group by grouping sets ((), (b), (a, b))\r\nunion all\r\nselect 2, count(*), count(a) from (select 1, 2 where 1 = 2) t(a, b) group by grouping sets ((), (b), (a, b))\r\n) t3(x, a, b);\r\n```\r\n\r\nThe correct result for both queries (also returned by Postgres) is:\r\n```\r\nx,a,b\r\n1,1,1\r\n1,1,1\r\n1,1,1\r\n2,0,0\r\n```\r\n\r\nHowever, for the first query, duckdb returns:\r\n```\r\nx,a,b\r\n1,1,1\r\n1,1,1\r\n1,1,1\r\n```\n\n### To Reproduce\n\nThe queries require no database, thus DuckDB CLI can be used to reproduce.\r\nI can also reproduce on DuckDB WASM.\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n1.0\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nAltan Birler\n\n### Affiliation:\n\nTUM\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "@hbirler thanks, I could reproduce the issue. We'll take a look.\n@hbirler thanks, I could reproduce the issue. We'll take a look.",
  "created_at": "2024-08-03T09:30:11Z"
}