You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Query unnesting with grouping sets results in wrong output
### What happens?

The following two queries should return the same result:
```sql
select x, a, b
from
(values (1), (2)) t2(x),
lateral (select count(*), count(a) from (select 1, 2 where 1 = x) t(a, b) group by grouping sets ((), (b), (a, b))) t3(a, b);

select x, a, b
from
(
select 1, count(*), count(a) from (select 1, 2 where 1 = 1) t(a, b) group by grouping sets ((), (b), (a, b))
union all
select 2, count(*), count(a) from (select 1, 2 where 1 = 2) t(a, b) group by grouping sets ((), (b), (a, b))
) t3(x, a, b);
```

The correct result for both queries (also returned by Postgres) is:
```
x,a,b
1,1,1
1,1,1
1,1,1
2,0,0
```

However, for the first query, duckdb returns:
```
x,a,b
1,1,1
1,1,1
1,1,1
```

### To Reproduce

The queries require no database, thus DuckDB CLI can be used to reproduce.
I can also reproduce on DuckDB WASM.

### OS:

Linux

### DuckDB Version:

1.0

### DuckDB Client:

CLI

### Full Name:

Altan Birler

### Affiliation:

TUM

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
Query unnesting with grouping sets results in wrong output
### What happens?

The following two queries should return the same result:
```sql
select x, a, b
from
(values (1), (2)) t2(x),
lateral (select count(*), count(a) from (select 1, 2 where 1 = x) t(a, b) group by grouping sets ((), (b), (a, b))) t3(a, b);

select x, a, b
from
(
select 1, count(*), count(a) from (select 1, 2 where 1 = 1) t(a, b) group by grouping sets ((), (b), (a, b))
union all
select 2, count(*), count(a) from (select 1, 2 where 1 = 2) t(a, b) group by grouping sets ((), (b), (a, b))
) t3(x, a, b);
```

The correct result for both queries (also returned by Postgres) is:
```
x,a,b
1,1,1
1,1,1
1,1,1
2,0,0
```

However, for the first query, duckdb returns:
```
x,a,b
1,1,1
1,1,1
1,1,1
```

### To Reproduce

The queries require no database, thus DuckDB CLI can be used to reproduce.
I can also reproduce on DuckDB WASM.

### OS:

Linux

### DuckDB Version:

1.0

### DuckDB Client:

CLI

### Full Name:

Altan Birler

### Affiliation:

TUM

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/include/duckdb/planner/subquery/flatten_dependent_join.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/subquery/flatten_dependent_join.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/planner/binder.hpp"
13: #include "duckdb/planner/column_binding_map.hpp"
14: #include "duckdb/planner/logical_operator.hpp"
15: 
16: namespace duckdb {
17: 
18: //! The FlattenDependentJoins class is responsible for pushing the dependent join down into the plan to create a
19: //! flattened subquery
20: struct FlattenDependentJoins {
21: 	FlattenDependentJoins(Binder &binder, const vector<CorrelatedColumnInfo> &correlated, bool perform_delim = true,
22: 	                      bool any_join = false);
23: 
24: 	//! Detects which Logical Operators have correlated expressions that they are dependent upon, filling the
25: 	//! has_correlated_expressions map.
26: 	bool DetectCorrelatedExpressions(LogicalOperator &op, bool lateral = false, idx_t lateral_depth = 0);
27: 
28: 	//! Mark entire subtree of Logical Operators as correlated by adding them to the has_correlated_expressions map.
29: 	bool MarkSubtreeCorrelated(LogicalOperator &op);
30: 
31: 	//! Push the dependent join down a LogicalOperator
32: 	unique_ptr<LogicalOperator> PushDownDependentJoin(unique_ptr<LogicalOperator> plan);
33: 
34: 	Binder &binder;
35: 	ColumnBinding base_binding;
36: 	idx_t delim_offset;
37: 	idx_t data_offset;
38: 	reference_map_t<LogicalOperator, bool> has_correlated_expressions;
39: 	column_binding_map_t<idx_t> correlated_map;
40: 	column_binding_map_t<idx_t> replacement_map;
41: 	const vector<CorrelatedColumnInfo> &correlated_columns;
42: 	vector<LogicalType> delim_types;
43: 
44: 	bool perform_delim;
45: 	bool any_join;
46: 
47: private:
48: 	unique_ptr<LogicalOperator> PushDownDependentJoinInternal(unique_ptr<LogicalOperator> plan,
49: 	                                                          bool &parent_propagate_null_values, idx_t lateral_depth);
50: };
51: 
52: } // namespace duckdb
[end of src/include/duckdb/planner/subquery/flatten_dependent_join.hpp]
[start of src/planner/binder/query_node/plan_subquery.cpp]
1: #include "duckdb/function/aggregate/distributive_functions.hpp"
2: #include "duckdb/main/client_config.hpp"
3: #include "duckdb/planner/binder.hpp"
4: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
5: #include "duckdb/planner/expression/bound_cast_expression.hpp"
6: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
7: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
8: #include "duckdb/planner/expression/bound_constant_expression.hpp"
9: #include "duckdb/planner/expression/bound_subquery_expression.hpp"
10: #include "duckdb/planner/expression/bound_window_expression.hpp"
11: #include "duckdb/planner/expression_iterator.hpp"
12: #include "duckdb/planner/operator/list.hpp"
13: #include "duckdb/planner/operator/logical_window.hpp"
14: #include "duckdb/function/function_binder.hpp"
15: #include "duckdb/planner/subquery/flatten_dependent_join.hpp"
16: #include "duckdb/common/enums/logical_operator_type.hpp"
17: #include "duckdb/planner/operator/logical_dependent_join.hpp"
18: #include "duckdb/planner/subquery/recursive_dependent_join_planner.hpp"
19: 
20: namespace duckdb {
21: 
22: static unique_ptr<Expression> PlanUncorrelatedSubquery(Binder &binder, BoundSubqueryExpression &expr,
23:                                                        unique_ptr<LogicalOperator> &root,
24:                                                        unique_ptr<LogicalOperator> plan) {
25: 	D_ASSERT(!expr.IsCorrelated());
26: 	switch (expr.subquery_type) {
27: 	case SubqueryType::EXISTS: {
28: 		// uncorrelated EXISTS
29: 		// we only care about existence, hence we push a LIMIT 1 operator
30: 		auto limit = make_uniq<LogicalLimit>(BoundLimitNode::ConstantValue(1), BoundLimitNode());
31: 		limit->AddChild(std::move(plan));
32: 		plan = std::move(limit);
33: 
34: 		// now we push a COUNT(*) aggregate onto the limit, this will be either 0 or 1 (EXISTS or NOT EXISTS)
35: 		auto count_star_fun = CountStarFun::GetFunction();
36: 
37: 		FunctionBinder function_binder(binder.context);
38: 		auto count_star =
39: 		    function_binder.BindAggregateFunction(count_star_fun, {}, nullptr, AggregateType::NON_DISTINCT);
40: 		auto idx_type = count_star->return_type;
41: 		vector<unique_ptr<Expression>> aggregate_list;
42: 		aggregate_list.push_back(std::move(count_star));
43: 		auto aggregate_index = binder.GenerateTableIndex();
44: 		auto aggregate =
45: 		    make_uniq<LogicalAggregate>(binder.GenerateTableIndex(), aggregate_index, std::move(aggregate_list));
46: 		aggregate->AddChild(std::move(plan));
47: 		plan = std::move(aggregate);
48: 
49: 		// now we push a projection with a comparison to 1
50: 		auto left_child = make_uniq<BoundColumnRefExpression>(idx_type, ColumnBinding(aggregate_index, 0));
51: 		auto right_child = make_uniq<BoundConstantExpression>(Value::Numeric(idx_type, 1));
52: 		auto comparison = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_EQUAL, std::move(left_child),
53: 		                                                       std::move(right_child));
54: 
55: 		vector<unique_ptr<Expression>> projection_list;
56: 		projection_list.push_back(std::move(comparison));
57: 		auto projection_index = binder.GenerateTableIndex();
58: 		auto projection = make_uniq<LogicalProjection>(projection_index, std::move(projection_list));
59: 		projection->AddChild(std::move(plan));
60: 		plan = std::move(projection);
61: 
62: 		// we add it to the main query by adding a cross product
63: 		// FIXME: should use something else besides cross product as we always add only one scalar constant
64: 		root = LogicalCrossProduct::Create(std::move(root), std::move(plan));
65: 
66: 		// we replace the original subquery with a ColumnRefExpression referring to the result of the projection (either
67: 		// TRUE or FALSE)
68: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), LogicalType::BOOLEAN,
69: 		                                           ColumnBinding(projection_index, 0));
70: 	}
71: 	case SubqueryType::SCALAR: {
72: 		// uncorrelated scalar, we want to return the first entry
73: 		// figure out the table index of the bound table of the entry which we want to return
74: 		auto bindings = plan->GetColumnBindings();
75: 		D_ASSERT(bindings.size() == 1);
76: 		idx_t table_idx = bindings[0].table_index;
77: 
78: 		// in the uncorrelated case we are only interested in the first result of the query
79: 		// hence we simply push a LIMIT 1 to get the first row of the subquery
80: 		auto limit = make_uniq<LogicalLimit>(BoundLimitNode::ConstantValue(1), BoundLimitNode());
81: 		limit->AddChild(std::move(plan));
82: 		plan = std::move(limit);
83: 
84: 		// we push an aggregate that returns the FIRST element
85: 		vector<unique_ptr<Expression>> expressions;
86: 		auto bound = make_uniq<BoundColumnRefExpression>(expr.return_type, ColumnBinding(table_idx, 0));
87: 		vector<unique_ptr<Expression>> first_children;
88: 		first_children.push_back(std::move(bound));
89: 
90: 		FunctionBinder function_binder(binder.context);
91: 		auto first_agg = function_binder.BindAggregateFunction(
92: 		    FirstFun::GetFunction(expr.return_type), std::move(first_children), nullptr, AggregateType::NON_DISTINCT);
93: 
94: 		expressions.push_back(std::move(first_agg));
95: 		auto aggr_index = binder.GenerateTableIndex();
96: 		auto aggr = make_uniq<LogicalAggregate>(binder.GenerateTableIndex(), aggr_index, std::move(expressions));
97: 		aggr->AddChild(std::move(plan));
98: 		plan = std::move(aggr);
99: 
100: 		// in the uncorrelated case, we add the value to the main query through a cross product
101: 		// FIXME: should use something else besides cross product as we always add only one scalar constant and cross
102: 		// product is not optimized for this.
103: 		D_ASSERT(root);
104: 		root = LogicalCrossProduct::Create(std::move(root), std::move(plan));
105: 
106: 		// we replace the original subquery with a BoundColumnRefExpression referring to the first result of the
107: 		// aggregation
108: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), expr.return_type, ColumnBinding(aggr_index, 0));
109: 	}
110: 	default: {
111: 		D_ASSERT(expr.subquery_type == SubqueryType::ANY);
112: 		// we generate a MARK join that results in either (TRUE, FALSE or NULL)
113: 		// subquery has NULL values -> result is (TRUE or NULL)
114: 		// subquery has no NULL values -> result is (TRUE, FALSE or NULL [if input is NULL])
115: 		// fetch the column bindings
116: 		auto plan_columns = plan->GetColumnBindings();
117: 
118: 		// then we generate the MARK join with the subquery
119: 		idx_t mark_index = binder.GenerateTableIndex();
120: 		auto join = make_uniq<LogicalComparisonJoin>(JoinType::MARK);
121: 		join->mark_index = mark_index;
122: 		join->AddChild(std::move(root));
123: 		join->AddChild(std::move(plan));
124: 		// create the JOIN condition
125: 		JoinCondition cond;
126: 		cond.left = std::move(expr.child);
127: 		cond.right = BoundCastExpression::AddDefaultCastToType(
128: 		    make_uniq<BoundColumnRefExpression>(expr.child_type, plan_columns[0]), expr.child_target);
129: 		cond.comparison = expr.comparison_type;
130: 		join->conditions.push_back(std::move(cond));
131: 		root = std::move(join);
132: 
133: 		// we replace the original subquery with a BoundColumnRefExpression referring to the mark column
134: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), expr.return_type, ColumnBinding(mark_index, 0));
135: 	}
136: 	}
137: }
138: 
139: static unique_ptr<LogicalComparisonJoin>
140: CreateDuplicateEliminatedJoin(const vector<CorrelatedColumnInfo> &correlated_columns, JoinType join_type,
141:                               unique_ptr<LogicalOperator> original_plan, bool perform_delim) {
142: 	auto delim_join = make_uniq<LogicalComparisonJoin>(join_type, LogicalOperatorType::LOGICAL_DELIM_JOIN);
143: 	if (!perform_delim) {
144: 		// if we are not performing a delim join, we push a row_number() OVER() window operator on the LHS
145: 		// and perform all duplicate elimination on that row number instead
146: 		D_ASSERT(correlated_columns[0].type.id() == LogicalTypeId::BIGINT);
147: 		auto window = make_uniq<LogicalWindow>(correlated_columns[0].binding.table_index);
148: 		auto row_number =
149: 		    make_uniq<BoundWindowExpression>(ExpressionType::WINDOW_ROW_NUMBER, LogicalType::BIGINT, nullptr, nullptr);
150: 		row_number->start = WindowBoundary::UNBOUNDED_PRECEDING;
151: 		row_number->end = WindowBoundary::CURRENT_ROW_ROWS;
152: 		row_number->alias = "delim_index";
153: 		window->expressions.push_back(std::move(row_number));
154: 		window->AddChild(std::move(original_plan));
155: 		original_plan = std::move(window);
156: 	}
157: 	delim_join->AddChild(std::move(original_plan));
158: 	for (idx_t i = 0; i < correlated_columns.size(); i++) {
159: 		auto &col = correlated_columns[i];
160: 		delim_join->duplicate_eliminated_columns.push_back(make_uniq<BoundColumnRefExpression>(col.type, col.binding));
161: 		delim_join->mark_types.push_back(col.type);
162: 	}
163: 	return delim_join;
164: }
165: 
166: static void CreateDelimJoinConditions(LogicalComparisonJoin &delim_join,
167:                                       const vector<CorrelatedColumnInfo> &correlated_columns,
168:                                       vector<ColumnBinding> bindings, idx_t base_offset, bool perform_delim) {
169: 	auto col_count = perform_delim ? correlated_columns.size() : 1;
170: 	for (idx_t i = 0; i < col_count; i++) {
171: 		auto &col = correlated_columns[i];
172: 		auto binding_idx = base_offset + i;
173: 		if (binding_idx >= bindings.size()) {
174: 			throw InternalException("Delim join - binding index out of range");
175: 		}
176: 		JoinCondition cond;
177: 		cond.left = make_uniq<BoundColumnRefExpression>(col.name, col.type, col.binding);
178: 		cond.right = make_uniq<BoundColumnRefExpression>(col.name, col.type, bindings[binding_idx]);
179: 		cond.comparison = ExpressionType::COMPARE_NOT_DISTINCT_FROM;
180: 		delim_join.conditions.push_back(std::move(cond));
181: 	}
182: }
183: 
184: static bool PerformDelimOnType(const LogicalType &type) {
185: 	if (type.InternalType() == PhysicalType::LIST) {
186: 		return false;
187: 	}
188: 	if (type.InternalType() == PhysicalType::STRUCT) {
189: 		for (auto &entry : StructType::GetChildTypes(type)) {
190: 			if (!PerformDelimOnType(entry.second)) {
191: 				return false;
192: 			}
193: 		}
194: 	}
195: 	return true;
196: }
197: 
198: static bool PerformDuplicateElimination(Binder &binder, vector<CorrelatedColumnInfo> &correlated_columns) {
199: 	if (!ClientConfig::GetConfig(binder.context).enable_optimizer) {
200: 		// if optimizations are disabled we always do a delim join
201: 		return true;
202: 	}
203: 	bool perform_delim = true;
204: 	for (auto &col : correlated_columns) {
205: 		if (!PerformDelimOnType(col.type)) {
206: 			perform_delim = false;
207: 			break;
208: 		}
209: 	}
210: 	if (perform_delim) {
211: 		return true;
212: 	}
213: 	auto binding = ColumnBinding(binder.GenerateTableIndex(), 0);
214: 	auto type = LogicalType::BIGINT;
215: 	auto name = "delim_index";
216: 	CorrelatedColumnInfo info(binding, type, name, 0);
217: 	correlated_columns.insert(correlated_columns.begin(), std::move(info));
218: 	return false;
219: }
220: 
221: static unique_ptr<Expression> PlanCorrelatedSubquery(Binder &binder, BoundSubqueryExpression &expr,
222:                                                      unique_ptr<LogicalOperator> &root,
223:                                                      unique_ptr<LogicalOperator> plan) {
224: 	auto &correlated_columns = expr.binder->correlated_columns;
225: 	// FIXME: there should be a way of disabling decorrelation for ANY queries as well, but not for now...
226: 	bool perform_delim =
227: 	    expr.subquery_type == SubqueryType::ANY ? true : PerformDuplicateElimination(binder, correlated_columns);
228: 	D_ASSERT(expr.IsCorrelated());
229: 	// correlated subquery
230: 	// for a more in-depth explanation of this code, read the paper "Unnesting Arbitrary Subqueries"
231: 	// we handle three types of correlated subqueries: Scalar, EXISTS and ANY
232: 	// all three cases are very similar with some minor changes (mainly the type of join performed at the end)
233: 	switch (expr.subquery_type) {
234: 	case SubqueryType::SCALAR: {
235: 		// correlated SCALAR query
236: 		// first push a DUPLICATE ELIMINATED join
237: 		// a duplicate eliminated join creates a duplicate eliminated copy of the LHS
238: 		// and pushes it into any DUPLICATE_ELIMINATED SCAN operators on the RHS
239: 
240: 		// in the SCALAR case, we create a SINGLE join (because we are only interested in obtaining the value)
241: 		// NULL values are equal in this join because we join on the correlated columns ONLY
242: 		// and e.g. in the query: SELECT (SELECT 42 FROM integers WHERE i1.i IS NULL LIMIT 1) FROM integers i1;
243: 		// the input value NULL will generate the value 42, and we need to join NULL on the LHS with NULL on the RHS
244: 		// the left side is the original plan
245: 		// this is the side that will be duplicate eliminated and pushed into the RHS
246: 		auto delim_join =
247: 		    CreateDuplicateEliminatedJoin(correlated_columns, JoinType::SINGLE, std::move(root), perform_delim);
248: 
249: 		// the right side initially is a DEPENDENT join between the duplicate eliminated scan and the subquery
250: 		// HOWEVER: we do not explicitly create the dependent join
251: 		// instead, we eliminate the dependent join by pushing it down into the right side of the plan
252: 		FlattenDependentJoins flatten(binder, correlated_columns, perform_delim);
253: 
254: 		// first we check which logical operators have correlated expressions in the first place
255: 		flatten.DetectCorrelatedExpressions(*plan);
256: 		// now we push the dependent join down
257: 		auto dependent_join = flatten.PushDownDependentJoin(std::move(plan));
258: 
259: 		// now the dependent join is fully eliminated
260: 		// we only need to create the join conditions between the LHS and the RHS
261: 		// fetch the set of columns
262: 		auto plan_columns = dependent_join->GetColumnBindings();
263: 
264: 		// now create the join conditions
265: 		CreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset, perform_delim);
266: 		delim_join->AddChild(std::move(dependent_join));
267: 		root = std::move(delim_join);
268: 		// finally push the BoundColumnRefExpression referring to the data element returned by the join
269: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), expr.return_type, plan_columns[flatten.data_offset]);
270: 	}
271: 	case SubqueryType::EXISTS: {
272: 		// correlated EXISTS query
273: 		// this query is similar to the correlated SCALAR query, except we use a MARK join here
274: 		idx_t mark_index = binder.GenerateTableIndex();
275: 		auto delim_join =
276: 		    CreateDuplicateEliminatedJoin(correlated_columns, JoinType::MARK, std::move(root), perform_delim);
277: 		delim_join->mark_index = mark_index;
278: 		// RHS
279: 		FlattenDependentJoins flatten(binder, correlated_columns, perform_delim, true);
280: 		flatten.DetectCorrelatedExpressions(*plan);
281: 		auto dependent_join = flatten.PushDownDependentJoin(std::move(plan));
282: 
283: 		// fetch the set of columns
284: 		auto plan_columns = dependent_join->GetColumnBindings();
285: 
286: 		// now we create the join conditions between the dependent join and the original table
287: 		CreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset, perform_delim);
288: 		delim_join->AddChild(std::move(dependent_join));
289: 		root = std::move(delim_join);
290: 		// finally push the BoundColumnRefExpression referring to the marker
291: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), expr.return_type, ColumnBinding(mark_index, 0));
292: 	}
293: 	default: {
294: 		D_ASSERT(expr.subquery_type == SubqueryType::ANY);
295: 		// correlated ANY query
296: 		// this query is similar to the correlated SCALAR query
297: 		// however, in this case we push a correlated MARK join
298: 		// note that in this join null values are NOT equal for ALL columns, but ONLY for the correlated columns
299: 		// the correlated mark join handles this case by itself
300: 		// as the MARK join has one extra join condition (the original condition, of the ANY expression, e.g.
301: 		// [i=ANY(...)])
302: 		idx_t mark_index = binder.GenerateTableIndex();
303: 		auto delim_join =
304: 		    CreateDuplicateEliminatedJoin(correlated_columns, JoinType::MARK, std::move(root), perform_delim);
305: 		delim_join->mark_index = mark_index;
306: 		// RHS
307: 		FlattenDependentJoins flatten(binder, correlated_columns, true, true);
308: 		flatten.DetectCorrelatedExpressions(*plan);
309: 		auto dependent_join = flatten.PushDownDependentJoin(std::move(plan));
310: 
311: 		// fetch the columns
312: 		auto plan_columns = dependent_join->GetColumnBindings();
313: 
314: 		// now we create the join conditions between the dependent join and the original table
315: 		CreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset, perform_delim);
316: 		// add the actual condition based on the ANY/ALL predicate
317: 		JoinCondition compare_cond;
318: 		compare_cond.left = std::move(expr.child);
319: 		compare_cond.right = BoundCastExpression::AddDefaultCastToType(
320: 		    make_uniq<BoundColumnRefExpression>(expr.child_type, plan_columns[0]), expr.child_target);
321: 		compare_cond.comparison = expr.comparison_type;
322: 		delim_join->conditions.push_back(std::move(compare_cond));
323: 
324: 		delim_join->AddChild(std::move(dependent_join));
325: 		root = std::move(delim_join);
326: 		// finally push the BoundColumnRefExpression referring to the marker
327: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), expr.return_type, ColumnBinding(mark_index, 0));
328: 	}
329: 	}
330: }
331: 
332: void RecursiveDependentJoinPlanner::VisitOperator(LogicalOperator &op) {
333: 	if (!op.children.empty()) {
334: 		// Collect all recursive CTEs during recursive descend
335: 		if (op.type == LogicalOperatorType::LOGICAL_RECURSIVE_CTE) {
336: 			auto &rec_cte = op.Cast<LogicalRecursiveCTE>();
337: 			binder.recursive_ctes[rec_cte.table_index] = &op;
338: 		}
339: 		root = std::move(op.children[0]);
340: 		D_ASSERT(root);
341: 		if (root->type == LogicalOperatorType::LOGICAL_DEPENDENT_JOIN) {
342: 			// Found a dependent join, flatten it
343: 			auto &new_root = root->Cast<LogicalDependentJoin>();
344: 			root = binder.PlanLateralJoin(std::move(new_root.children[0]), std::move(new_root.children[1]),
345: 			                              new_root.correlated_columns, new_root.join_type,
346: 			                              std::move(new_root.join_condition));
347: 		}
348: 		VisitOperatorExpressions(op);
349: 		op.children[0] = std::move(root);
350: 		for (idx_t i = 0; i < op.children.size(); i++) {
351: 			D_ASSERT(op.children[i]);
352: 			VisitOperator(*op.children[i]);
353: 		}
354: 	}
355: }
356: 
357: unique_ptr<Expression> RecursiveDependentJoinPlanner::VisitReplace(BoundSubqueryExpression &expr,
358:                                                                    unique_ptr<Expression> *expr_ptr) {
359: 	return binder.PlanSubquery(expr, root);
360: }
361: 
362: unique_ptr<Expression> Binder::PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root) {
363: 	D_ASSERT(root);
364: 	// first we translate the QueryNode of the subquery into a logical plan
365: 	// note that we do not plan nested subqueries yet
366: 	auto sub_binder = Binder::CreateBinder(context, this);
367: 	sub_binder->is_outside_flattened = false;
368: 	auto subquery_root = sub_binder->CreatePlan(*expr.subquery);
369: 	D_ASSERT(subquery_root);
370: 
371: 	// now we actually flatten the subquery
372: 	auto plan = std::move(subquery_root);
373: 
374: 	unique_ptr<Expression> result_expression;
375: 	if (!expr.IsCorrelated()) {
376: 		result_expression = PlanUncorrelatedSubquery(*this, expr, root, std::move(plan));
377: 	} else {
378: 		result_expression = PlanCorrelatedSubquery(*this, expr, root, std::move(plan));
379: 	}
380: 	// finally, we recursively plan the nested subqueries (if there are any)
381: 	if (sub_binder->has_unplanned_dependent_joins) {
382: 		RecursiveDependentJoinPlanner plan(*this);
383: 		plan.VisitOperator(*root);
384: 	}
385: 	return result_expression;
386: }
387: 
388: void Binder::PlanSubqueries(unique_ptr<Expression> &expr_ptr, unique_ptr<LogicalOperator> &root) {
389: 	if (!expr_ptr) {
390: 		return;
391: 	}
392: 	auto &expr = *expr_ptr;
393: 	// first visit the children of the node, if any
394: 	ExpressionIterator::EnumerateChildren(expr, [&](unique_ptr<Expression> &expr) { PlanSubqueries(expr, root); });
395: 
396: 	// check if this is a subquery node
397: 	if (expr.expression_class == ExpressionClass::BOUND_SUBQUERY) {
398: 		auto &subquery = expr.Cast<BoundSubqueryExpression>();
399: 		// subquery node! plan it
400: 		if (subquery.IsCorrelated() && !is_outside_flattened) {
401: 			// detected a nested correlated subquery
402: 			// we don't plan it yet here, we are currently planning a subquery
403: 			// nested subqueries will only be planned AFTER the current subquery has been flattened entirely
404: 			has_unplanned_dependent_joins = true;
405: 			return;
406: 		}
407: 		expr_ptr = PlanSubquery(subquery, root);
408: 	}
409: }
410: 
411: unique_ptr<LogicalOperator> Binder::PlanLateralJoin(unique_ptr<LogicalOperator> left, unique_ptr<LogicalOperator> right,
412:                                                     vector<CorrelatedColumnInfo> &correlated, JoinType join_type,
413:                                                     unique_ptr<Expression> condition) {
414: 	// scan the right operator for correlated columns
415: 	// correlated LATERAL JOIN
416: 	vector<JoinCondition> conditions;
417: 	vector<unique_ptr<Expression>> arbitrary_expressions;
418: 	if (condition) {
419: 		// extract join conditions, if there are any
420: 		LogicalComparisonJoin::ExtractJoinConditions(context, join_type, JoinRefType::REGULAR, left, right,
421: 		                                             std::move(condition), conditions, arbitrary_expressions);
422: 	}
423: 
424: 	auto perform_delim = PerformDuplicateElimination(*this, correlated);
425: 	auto delim_join = CreateDuplicateEliminatedJoin(correlated, join_type, std::move(left), perform_delim);
426: 
427: 	FlattenDependentJoins flatten(*this, correlated, perform_delim);
428: 
429: 	// first we check which logical operators have correlated expressions in the first place
430: 	flatten.DetectCorrelatedExpressions(*right, true);
431: 	// now we push the dependent join down
432: 	auto dependent_join = flatten.PushDownDependentJoin(std::move(right));
433: 
434: 	// now the dependent join is fully eliminated
435: 	// we only need to create the join conditions between the LHS and the RHS
436: 	// fetch the set of columns
437: 	auto plan_columns = dependent_join->GetColumnBindings();
438: 
439: 	// in case of a materialized CTE, the output is defined by the second children operator
440: 	if (dependent_join->type == LogicalOperatorType::LOGICAL_MATERIALIZED_CTE) {
441: 		plan_columns = dependent_join->children[1]->GetColumnBindings();
442: 	}
443: 
444: 	// now create the join conditions
445: 	// start off with the conditions that were passed in (if any)
446: 	D_ASSERT(delim_join->conditions.empty());
447: 	delim_join->conditions = std::move(conditions);
448: 	// then add the delim join conditions
449: 	CreateDelimJoinConditions(*delim_join, correlated, plan_columns, flatten.delim_offset, perform_delim);
450: 	delim_join->AddChild(std::move(dependent_join));
451: 
452: 	// check if there are any arbitrary expressions left
453: 	if (!arbitrary_expressions.empty()) {
454: 		// we can only evaluate scalar arbitrary expressions for inner joins
455: 		if (join_type != JoinType::INNER) {
456: 			throw BinderException(
457: 			    "Join condition for non-inner LATERAL JOIN must be a comparison between the left and right side");
458: 		}
459: 		auto filter = make_uniq<LogicalFilter>();
460: 		filter->expressions = std::move(arbitrary_expressions);
461: 		filter->AddChild(std::move(delim_join));
462: 		return std::move(filter);
463: 	}
464: 	return std::move(delim_join);
465: }
466: 
467: } // namespace duckdb
[end of src/planner/binder/query_node/plan_subquery.cpp]
[start of src/planner/subquery/flatten_dependent_join.cpp]
1: #include "duckdb/planner/subquery/flatten_dependent_join.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp"
4: #include "duckdb/common/operator/add.hpp"
5: #include "duckdb/function/aggregate/distributive_functions.hpp"
6: #include "duckdb/planner/binder.hpp"
7: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
8: #include "duckdb/planner/expression/list.hpp"
9: #include "duckdb/planner/logical_operator_visitor.hpp"
10: #include "duckdb/planner/operator/list.hpp"
11: #include "duckdb/planner/subquery/has_correlated_expressions.hpp"
12: #include "duckdb/planner/subquery/rewrite_correlated_expressions.hpp"
13: #include "duckdb/planner/subquery/rewrite_cte_scan.hpp"
14: #include "duckdb/planner/operator/logical_dependent_join.hpp"
15: #include "duckdb/execution/column_binding_resolver.hpp"
16: 
17: namespace duckdb {
18: 
19: FlattenDependentJoins::FlattenDependentJoins(Binder &binder, const vector<CorrelatedColumnInfo> &correlated,
20:                                              bool perform_delim, bool any_join)
21:     : binder(binder), delim_offset(DConstants::INVALID_INDEX), correlated_columns(correlated),
22:       perform_delim(perform_delim), any_join(any_join) {
23: 	for (idx_t i = 0; i < correlated_columns.size(); i++) {
24: 		auto &col = correlated_columns[i];
25: 		correlated_map[col.binding] = i;
26: 		delim_types.push_back(col.type);
27: 	}
28: }
29: 
30: bool FlattenDependentJoins::DetectCorrelatedExpressions(LogicalOperator &op, bool lateral, idx_t lateral_depth) {
31: 
32: 	bool is_lateral_join = false;
33: 
34: 	// check if this entry has correlated expressions
35: 	if (op.type == LogicalOperatorType::LOGICAL_DEPENDENT_JOIN) {
36: 		is_lateral_join = true;
37: 	}
38: 	HasCorrelatedExpressions visitor(correlated_columns, lateral, lateral_depth);
39: 	visitor.VisitOperator(op);
40: 	bool has_correlation = visitor.has_correlated_expressions;
41: 	int child_idx = 0;
42: 	// now visit the children of this entry and check if they have correlated expressions
43: 	for (auto &child : op.children) {
44: 		auto new_lateral_depth = lateral_depth;
45: 		if (is_lateral_join && child_idx == 1) {
46: 			new_lateral_depth = lateral_depth + 1;
47: 		}
48: 		// we OR the property with its children such that has_correlation is true if either
49: 		// (1) this node has a correlated expression or
50: 		// (2) one of its children has a correlated expression
51: 		if (DetectCorrelatedExpressions(*child, lateral, new_lateral_depth)) {
52: 			has_correlation = true;
53: 		}
54: 		child_idx++;
55: 	}
56: 	// set the entry in the map
57: 	has_correlated_expressions[op] = has_correlation;
58: 
59: 	// If we detect correlation in a materialized or recursive CTE, the entire right side of the operator
60: 	// needs to be marked as correlated. Otherwise, function PushDownDependentJoinInternal does not do the
61: 	// right thing.
62: 	if (op.type == LogicalOperatorType::LOGICAL_MATERIALIZED_CTE ||
63: 	    op.type == LogicalOperatorType::LOGICAL_RECURSIVE_CTE) {
64: 		if (has_correlation) {
65: 			MarkSubtreeCorrelated(*op.children[1].get());
66: 		}
67: 	}
68: 	return has_correlation;
69: }
70: 
71: bool FlattenDependentJoins::MarkSubtreeCorrelated(LogicalOperator &op) {
72: 	// Do not mark base table scans as correlated
73: 	auto entry = has_correlated_expressions.find(op);
74: 	D_ASSERT(entry != has_correlated_expressions.end());
75: 	bool has_correlation = entry->second;
76: 	for (auto &child : op.children) {
77: 		has_correlation |= MarkSubtreeCorrelated(*child.get());
78: 	}
79: 	if (op.type != LogicalOperatorType::LOGICAL_GET || op.children.size() == 1) {
80: 		if (op.type == LogicalOperatorType::LOGICAL_CTE_REF) {
81: 			has_correlated_expressions[op] = true;
82: 			return true;
83: 		} else {
84: 			has_correlated_expressions[op] = has_correlation;
85: 		}
86: 	}
87: 	return has_correlation;
88: }
89: 
90: unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoin(unique_ptr<LogicalOperator> plan) {
91: 	bool propagate_null_values = true;
92: 	auto result = PushDownDependentJoinInternal(std::move(plan), propagate_null_values, 0);
93: 	if (!replacement_map.empty()) {
94: 		// check if we have to replace any COUNT aggregates into "CASE WHEN X IS NULL THEN 0 ELSE COUNT END"
95: 		RewriteCountAggregates aggr(replacement_map);
96: 		aggr.VisitOperator(*result);
97: 	}
98: 	return result;
99: }
100: 
101: bool SubqueryDependentFilter(Expression &expr) {
102: 	if (expr.expression_class == ExpressionClass::BOUND_CONJUNCTION &&
103: 	    expr.GetExpressionType() == ExpressionType::CONJUNCTION_AND) {
104: 		auto &bound_conjunction = expr.Cast<BoundConjunctionExpression>();
105: 		for (auto &child : bound_conjunction.children) {
106: 			if (SubqueryDependentFilter(*child)) {
107: 				return true;
108: 			}
109: 		}
110: 	}
111: 	if (expr.expression_class == ExpressionClass::BOUND_SUBQUERY) {
112: 		return true;
113: 	}
114: 	return false;
115: }
116: 
117: unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal(unique_ptr<LogicalOperator> plan,
118:                                                                                  bool &parent_propagate_null_values,
119:                                                                                  idx_t lateral_depth) {
120: 	// first check if the logical operator has correlated expressions
121: 	auto entry = has_correlated_expressions.find(*plan);
122: 	bool exit_projection = false;
123: 	unique_ptr<LogicalDelimGet> delim_scan;
124: 	D_ASSERT(entry != has_correlated_expressions.end());
125: 	if (!entry->second) {
126: 		// we reached a node without correlated expressions
127: 		// we can eliminate the dependent join now and create a simple cross product
128: 		// now create the duplicate eliminated scan for this node
129: 		if (plan->type == LogicalOperatorType::LOGICAL_CTE_REF) {
130: 			auto &op = plan->Cast<LogicalCTERef>();
131: 
132: 			auto rec_cte = binder.recursive_ctes.find(op.cte_index);
133: 			if (rec_cte != binder.recursive_ctes.end()) {
134: 				D_ASSERT(rec_cte->second->type == LogicalOperatorType::LOGICAL_RECURSIVE_CTE);
135: 				auto &rec_cte_op = rec_cte->second->Cast<LogicalRecursiveCTE>();
136: 				RewriteCTEScan cte_rewriter(op.cte_index, rec_cte_op.correlated_columns);
137: 				cte_rewriter.VisitOperator(*plan);
138: 			}
139: 		}
140: 
141: 		// create cross product with Delim Join
142: 		auto delim_index = binder.GenerateTableIndex();
143: 		base_binding = ColumnBinding(delim_index, 0);
144: 
145: 		auto left_columns = plan->GetColumnBindings().size();
146: 		delim_offset = left_columns;
147: 		data_offset = 0;
148: 		delim_scan = make_uniq<LogicalDelimGet>(delim_index, delim_types);
149: 		if (plan->type == LogicalOperatorType::LOGICAL_PROJECTION) {
150: 			// we want to keep the logical projection for positionality.
151: 			exit_projection = true;
152: 		} else {
153: 			auto cross_product = LogicalCrossProduct::Create(std::move(plan), std::move(delim_scan));
154: 			return cross_product;
155: 		}
156: 	}
157: 	switch (plan->type) {
158: 	case LogicalOperatorType::LOGICAL_UNNEST:
159: 	case LogicalOperatorType::LOGICAL_FILTER: {
160: 		// filter
161: 		// first we flatten the dependent join in the child of the filter
162: 		for (auto &expr : plan->expressions) {
163: 			any_join |= SubqueryDependentFilter(*expr);
164: 		}
165: 		plan->children[0] =
166: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
167: 
168: 		// then we replace any correlated expressions with the corresponding entry in the correlated_map
169: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
170: 		rewriter.VisitOperator(*plan);
171: 		return plan;
172: 	}
173: 	case LogicalOperatorType::LOGICAL_PROJECTION: {
174: 		// projection
175: 		// first we flatten the dependent join in the child of the projection
176: 		for (auto &expr : plan->expressions) {
177: 			parent_propagate_null_values &= expr->PropagatesNullValues();
178: 		}
179: 
180: 		// if the node has no correlated expressions,
181: 		// push the cross product with the delim get only below the projection.
182: 		// This will preserve positionality of the columns and prevent errors when reordering of
183: 		// delim gets is enabled.
184: 		if (exit_projection) {
185: 			auto cross_product = LogicalCrossProduct::Create(std::move(plan->children[0]), std::move(delim_scan));
186: 			plan->children[0] = std::move(cross_product);
187: 		} else {
188: 			plan->children[0] = PushDownDependentJoinInternal(std::move(plan->children[0]),
189: 			                                                  parent_propagate_null_values, lateral_depth);
190: 		}
191: 
192: 		// then we replace any correlated expressions with the corresponding entry in the correlated_map
193: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
194: 		rewriter.VisitOperator(*plan);
195: 		// now we add all the columns of the delim_scan to the projection list
196: 		auto &proj = plan->Cast<LogicalProjection>();
197: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
198: 			auto &col = correlated_columns[i];
199: 			auto colref = make_uniq<BoundColumnRefExpression>(
200: 			    col.name, col.type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
201: 			plan->expressions.push_back(std::move(colref));
202: 		}
203: 
204: 		base_binding.table_index = proj.table_index;
205: 		this->delim_offset = base_binding.column_index = plan->expressions.size() - correlated_columns.size();
206: 		this->data_offset = 0;
207: 		return plan;
208: 	}
209: 	case LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY: {
210: 		auto &aggr = plan->Cast<LogicalAggregate>();
211: 		// aggregate and group by
212: 		// first we flatten the dependent join in the child of the projection
213: 		for (auto &expr : plan->expressions) {
214: 			parent_propagate_null_values &= expr->PropagatesNullValues();
215: 		}
216: 		plan->children[0] =
217: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
218: 		// then we replace any correlated expressions with the corresponding entry in the correlated_map
219: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
220: 		rewriter.VisitOperator(*plan);
221: 		// now we add all the columns of the delim_scan to the grouping operators AND the projection list
222: 		idx_t delim_table_index;
223: 		idx_t delim_column_offset;
224: 		idx_t delim_data_offset;
225: 		auto new_group_count = perform_delim ? correlated_columns.size() : 1;
226: 		for (idx_t i = 0; i < new_group_count; i++) {
227: 			auto &col = correlated_columns[i];
228: 			auto colref = make_uniq<BoundColumnRefExpression>(
229: 			    col.name, col.type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
230: 			for (auto &set : aggr.grouping_sets) {
231: 				set.insert(aggr.groups.size());
232: 			}
233: 			aggr.groups.push_back(std::move(colref));
234: 		}
235: 		if (!perform_delim) {
236: 			// if we are not performing the duplicate elimination, we have only added the row_id column to the grouping
237: 			// operators in this case, we push a FIRST aggregate for each of the remaining expressions
238: 			delim_table_index = aggr.aggregate_index;
239: 			delim_column_offset = aggr.expressions.size();
240: 			delim_data_offset = aggr.groups.size();
241: 			for (idx_t i = 0; i < correlated_columns.size(); i++) {
242: 				auto &col = correlated_columns[i];
243: 				auto first_aggregate = FirstFun::GetFunction(col.type);
244: 				auto colref = make_uniq<BoundColumnRefExpression>(
245: 				    col.name, col.type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
246: 				vector<unique_ptr<Expression>> aggr_children;
247: 				aggr_children.push_back(std::move(colref));
248: 				auto first_fun =
249: 				    make_uniq<BoundAggregateExpression>(std::move(first_aggregate), std::move(aggr_children), nullptr,
250: 				                                        nullptr, AggregateType::NON_DISTINCT);
251: 				aggr.expressions.push_back(std::move(first_fun));
252: 			}
253: 		} else {
254: 			delim_table_index = aggr.group_index;
255: 			delim_column_offset = aggr.groups.size() - correlated_columns.size();
256: 			delim_data_offset = aggr.groups.size();
257: 		}
258: 		if (aggr.groups.size() == new_group_count) {
259: 			// we have to perform a LEFT OUTER JOIN between the result of this aggregate and the delim scan
260: 			// FIXME: this does not always have to be a LEFT OUTER JOIN, depending on whether aggr.expressions return
261: 			// NULL or a value
262: 			unique_ptr<LogicalComparisonJoin> join = make_uniq<LogicalComparisonJoin>(JoinType::INNER);
263: 			for (auto &aggr_exp : aggr.expressions) {
264: 				auto &b_aggr_exp = aggr_exp->Cast<BoundAggregateExpression>();
265: 				if (!b_aggr_exp.PropagatesNullValues() || any_join || !parent_propagate_null_values) {
266: 					join = make_uniq<LogicalComparisonJoin>(JoinType::LEFT);
267: 					break;
268: 				}
269: 			}
270: 			auto left_index = binder.GenerateTableIndex();
271: 			delim_scan = make_uniq<LogicalDelimGet>(left_index, delim_types);
272: 			join->children.push_back(std::move(delim_scan));
273: 			join->children.push_back(std::move(plan));
274: 			for (idx_t i = 0; i < new_group_count; i++) {
275: 				auto &col = correlated_columns[i];
276: 				JoinCondition cond;
277: 				cond.left = make_uniq<BoundColumnRefExpression>(col.name, col.type, ColumnBinding(left_index, i));
278: 				cond.right = make_uniq<BoundColumnRefExpression>(
279: 				    correlated_columns[i].type, ColumnBinding(delim_table_index, delim_column_offset + i));
280: 				cond.comparison = ExpressionType::COMPARE_NOT_DISTINCT_FROM;
281: 				join->conditions.push_back(std::move(cond));
282: 			}
283: 			// for any COUNT aggregate we replace references to the column with: CASE WHEN COUNT(*) IS NULL THEN 0
284: 			// ELSE COUNT(*) END
285: 			for (idx_t i = 0; i < aggr.expressions.size(); i++) {
286: 				D_ASSERT(aggr.expressions[i]->GetExpressionClass() == ExpressionClass::BOUND_AGGREGATE);
287: 				auto &bound = aggr.expressions[i]->Cast<BoundAggregateExpression>();
288: 				vector<LogicalType> arguments;
289: 				if (bound.function == CountFun::GetFunction() || bound.function == CountStarFun::GetFunction()) {
290: 					// have to replace this ColumnBinding with the CASE expression
291: 					replacement_map[ColumnBinding(aggr.aggregate_index, i)] = i;
292: 				}
293: 			}
294: 			// now we update the delim_index
295: 			base_binding.table_index = left_index;
296: 			this->delim_offset = base_binding.column_index = 0;
297: 			this->data_offset = 0;
298: 			return std::move(join);
299: 		} else {
300: 			// update the delim_index
301: 			base_binding.table_index = delim_table_index;
302: 			this->delim_offset = base_binding.column_index = delim_column_offset;
303: 			this->data_offset = delim_data_offset;
304: 			return plan;
305: 		}
306: 	}
307: 	case LogicalOperatorType::LOGICAL_CROSS_PRODUCT: {
308: 		// cross product
309: 		// push into both sides of the plan
310: 		bool left_has_correlation = has_correlated_expressions.find(*plan->children[0])->second;
311: 		bool right_has_correlation = has_correlated_expressions.find(*plan->children[1])->second;
312: 		if (!right_has_correlation) {
313: 			// only left has correlation: push into left
314: 			plan->children[0] = PushDownDependentJoinInternal(std::move(plan->children[0]),
315: 			                                                  parent_propagate_null_values, lateral_depth);
316: 			return plan;
317: 		}
318: 		if (!left_has_correlation) {
319: 			// only right has correlation: push into right
320: 			plan->children[1] = PushDownDependentJoinInternal(std::move(plan->children[1]),
321: 			                                                  parent_propagate_null_values, lateral_depth);
322: 			return plan;
323: 		}
324: 		// both sides have correlation
325: 		// turn into an inner join
326: 		auto join = make_uniq<LogicalComparisonJoin>(JoinType::INNER);
327: 		plan->children[0] =
328: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
329: 		auto left_binding = this->base_binding;
330: 		plan->children[1] =
331: 		    PushDownDependentJoinInternal(std::move(plan->children[1]), parent_propagate_null_values, lateral_depth);
332: 		// add the correlated columns to the join conditions
333: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
334: 			JoinCondition cond;
335: 			cond.left = make_uniq<BoundColumnRefExpression>(
336: 			    correlated_columns[i].type, ColumnBinding(left_binding.table_index, left_binding.column_index + i));
337: 			cond.right = make_uniq<BoundColumnRefExpression>(
338: 			    correlated_columns[i].type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
339: 			cond.comparison = ExpressionType::COMPARE_NOT_DISTINCT_FROM;
340: 			join->conditions.push_back(std::move(cond));
341: 		}
342: 		join->children.push_back(std::move(plan->children[0]));
343: 		join->children.push_back(std::move(plan->children[1]));
344: 		return std::move(join);
345: 	}
346: 	case LogicalOperatorType::LOGICAL_DEPENDENT_JOIN: {
347: 		auto &dependent_join = plan->Cast<LogicalJoin>();
348: 		if (!((dependent_join.join_type == JoinType::INNER) || (dependent_join.join_type == JoinType::LEFT))) {
349: 			throw NotImplementedException("Dependent join can only be INNER or LEFT type");
350: 		}
351: 		D_ASSERT(plan->children.size() == 2);
352: 		// Push all the bindings down to the left side so the right side knows where to refer DELIM_GET from
353: 		plan->children[0] =
354: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
355: 
356: 		// Normal rewriter like in other joins
357: 		RewriteCorrelatedExpressions rewriter(this->base_binding, correlated_map, lateral_depth);
358: 		rewriter.VisitOperator(*plan);
359: 
360: 		// Recursive rewriter to visit right side of lateral join and update bindings from left
361: 		RewriteCorrelatedExpressions recursive_rewriter(this->base_binding, correlated_map, lateral_depth + 1, true);
362: 		recursive_rewriter.VisitOperator(*plan->children[1]);
363: 
364: 		return plan;
365: 	}
366: 	case LogicalOperatorType::LOGICAL_ANY_JOIN:
367: 	case LogicalOperatorType::LOGICAL_ASOF_JOIN:
368: 	case LogicalOperatorType::LOGICAL_COMPARISON_JOIN: {
369: 		auto &join = plan->Cast<LogicalJoin>();
370: 		D_ASSERT(plan->children.size() == 2);
371: 		// check the correlated expressions in the children of the join
372: 		bool left_has_correlation = has_correlated_expressions.find(*plan->children[0])->second;
373: 		bool right_has_correlation = has_correlated_expressions.find(*plan->children[1])->second;
374: 
375: 		if (join.join_type == JoinType::INNER) {
376: 			// inner join
377: 			if (!right_has_correlation) {
378: 				// only left has correlation: push into left
379: 				plan->children[0] = PushDownDependentJoinInternal(std::move(plan->children[0]),
380: 				                                                  parent_propagate_null_values, lateral_depth);
381: 				// Remove the correlated columns coming from outside for current join node
382: 				return plan;
383: 			}
384: 			if (!left_has_correlation) {
385: 				// only right has correlation: push into right
386: 				plan->children[1] = PushDownDependentJoinInternal(std::move(plan->children[1]),
387: 				                                                  parent_propagate_null_values, lateral_depth);
388: 				// Remove the correlated columns coming from outside for current join node
389: 				return plan;
390: 			}
391: 		} else if (join.join_type == JoinType::LEFT) {
392: 			// left outer join
393: 			if (!right_has_correlation) {
394: 				// only left has correlation: push into left
395: 				plan->children[0] = PushDownDependentJoinInternal(std::move(plan->children[0]),
396: 				                                                  parent_propagate_null_values, lateral_depth);
397: 				// Remove the correlated columns coming from outside for current join node
398: 				return plan;
399: 			}
400: 		} else if (join.join_type == JoinType::RIGHT) {
401: 			// left outer join
402: 			if (!left_has_correlation) {
403: 				// only right has correlation: push into right
404: 				plan->children[1] = PushDownDependentJoinInternal(std::move(plan->children[1]),
405: 				                                                  parent_propagate_null_values, lateral_depth);
406: 				return plan;
407: 			}
408: 		} else if (join.join_type == JoinType::MARK) {
409: 			if (right_has_correlation) {
410: 				throw NotImplementedException("MARK join with correlation in RHS not supported");
411: 			}
412: 			// push the child into the LHS
413: 			plan->children[0] = PushDownDependentJoinInternal(std::move(plan->children[0]),
414: 			                                                  parent_propagate_null_values, lateral_depth);
415: 			// rewrite expressions in the join conditions
416: 			RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
417: 			rewriter.VisitOperator(*plan);
418: 			return plan;
419: 		} else {
420: 			throw NotImplementedException("Unsupported join type for flattening correlated subquery");
421: 		}
422: 		// both sides have correlation
423: 		// push into both sides
424: 		plan->children[0] =
425: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
426: 		auto left_binding = this->base_binding;
427: 		plan->children[1] =
428: 		    PushDownDependentJoinInternal(std::move(plan->children[1]), parent_propagate_null_values, lateral_depth);
429: 		auto right_binding = this->base_binding;
430: 		// NOTE: for OUTER JOINS it matters what the BASE BINDING is after the join
431: 		// for the LEFT OUTER JOIN, we want the LEFT side to be the base binding after we push
432: 		// because the RIGHT binding might contain NULL values
433: 		if (join.join_type == JoinType::LEFT) {
434: 			this->base_binding = left_binding;
435: 		} else if (join.join_type == JoinType::RIGHT) {
436: 			this->base_binding = right_binding;
437: 		}
438: 		// add the correlated columns to the join conditions
439: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
440: 			auto left = make_uniq<BoundColumnRefExpression>(
441: 			    correlated_columns[i].type, ColumnBinding(left_binding.table_index, left_binding.column_index + i));
442: 			auto right = make_uniq<BoundColumnRefExpression>(
443: 			    correlated_columns[i].type, ColumnBinding(right_binding.table_index, right_binding.column_index + i));
444: 
445: 			if (join.type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN ||
446: 			    join.type == LogicalOperatorType::LOGICAL_ASOF_JOIN) {
447: 				JoinCondition cond;
448: 				cond.left = std::move(left);
449: 				cond.right = std::move(right);
450: 				cond.comparison = ExpressionType::COMPARE_NOT_DISTINCT_FROM;
451: 
452: 				auto &comparison_join = join.Cast<LogicalComparisonJoin>();
453: 				comparison_join.conditions.push_back(std::move(cond));
454: 			} else {
455: 				auto &logical_any_join = join.Cast<LogicalAnyJoin>();
456: 				auto comparison = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_NOT_DISTINCT_FROM,
457: 				                                                       std::move(left), std::move(right));
458: 				auto conjunction = make_uniq<BoundConjunctionExpression>(
459: 				    ExpressionType::CONJUNCTION_AND, std::move(comparison), std::move(logical_any_join.condition));
460: 				logical_any_join.condition = std::move(conjunction);
461: 			}
462: 		}
463: 		// then we replace any correlated expressions with the corresponding entry in the correlated_map
464: 		RewriteCorrelatedExpressions rewriter(right_binding, correlated_map, lateral_depth);
465: 		rewriter.VisitOperator(*plan);
466: 		return plan;
467: 	}
468: 	case LogicalOperatorType::LOGICAL_LIMIT: {
469: 		auto &limit = plan->Cast<LogicalLimit>();
470: 		switch (limit.limit_val.Type()) {
471: 		case LimitNodeType::CONSTANT_PERCENTAGE:
472: 		case LimitNodeType::EXPRESSION_PERCENTAGE:
473: 			// NOTE: limit percent could be supported in a manner similar to the LIMIT above
474: 			// but instead of filtering by an exact number of rows, the limit should be expressed as
475: 			// COUNT computed over the partition multiplied by the percentage
476: 			throw ParserException("Limit percent operator not supported in correlated subquery");
477: 		case LimitNodeType::EXPRESSION_VALUE:
478: 			throw ParserException("Non-constant limit not supported in correlated subquery");
479: 		default:
480: 			break;
481: 		}
482: 		switch (limit.offset_val.Type()) {
483: 		case LimitNodeType::EXPRESSION_VALUE:
484: 			throw ParserException("Non-constant offset not supported in correlated subquery");
485: 		case LimitNodeType::CONSTANT_PERCENTAGE:
486: 		case LimitNodeType::EXPRESSION_PERCENTAGE:
487: 			throw InternalException("Percentage offset in FlattenDependentJoin");
488: 		default:
489: 			break;
490: 		}
491: 		auto rownum_alias = "limit_rownum";
492: 		unique_ptr<LogicalOperator> child;
493: 		unique_ptr<LogicalOrder> order_by;
494: 
495: 		// check if the direct child of this LIMIT node is an ORDER BY node, if so, keep it separate
496: 		// this is done for an optimization to avoid having to compute the total order
497: 		if (plan->children[0]->type == LogicalOperatorType::LOGICAL_ORDER_BY) {
498: 			order_by = unique_ptr_cast<LogicalOperator, LogicalOrder>(std::move(plan->children[0]));
499: 			child = PushDownDependentJoinInternal(std::move(order_by->children[0]), parent_propagate_null_values,
500: 			                                      lateral_depth);
501: 		} else {
502: 			child = PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values,
503: 			                                      lateral_depth);
504: 		}
505: 		auto child_column_count = child->GetColumnBindings().size();
506: 		// we push a row_number() OVER (PARTITION BY [correlated columns])
507: 		auto window_index = binder.GenerateTableIndex();
508: 		auto window = make_uniq<LogicalWindow>(window_index);
509: 		auto row_number =
510: 		    make_uniq<BoundWindowExpression>(ExpressionType::WINDOW_ROW_NUMBER, LogicalType::BIGINT, nullptr, nullptr);
511: 		auto partition_count = perform_delim ? correlated_columns.size() : 1;
512: 		for (idx_t i = 0; i < partition_count; i++) {
513: 			auto &col = correlated_columns[i];
514: 			auto colref = make_uniq<BoundColumnRefExpression>(
515: 			    col.name, col.type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
516: 			row_number->partitions.push_back(std::move(colref));
517: 		}
518: 		if (order_by) {
519: 			// optimization: if there is an ORDER BY node followed by a LIMIT
520: 			// rather than computing the entire order, we push the ORDER BY expressions into the row_num computation
521: 			// this way, the order only needs to be computed per partition
522: 			row_number->orders = std::move(order_by->orders);
523: 		}
524: 		row_number->start = WindowBoundary::UNBOUNDED_PRECEDING;
525: 		row_number->end = WindowBoundary::CURRENT_ROW_ROWS;
526: 		window->expressions.push_back(std::move(row_number));
527: 		window->children.push_back(std::move(child));
528: 
529: 		// add a filter based on the row_number
530: 		// the filter we add is "row_number > offset AND row_number <= offset + limit"
531: 		auto filter = make_uniq<LogicalFilter>();
532: 		unique_ptr<Expression> condition;
533: 		auto row_num_ref =
534: 		    make_uniq<BoundColumnRefExpression>(rownum_alias, LogicalType::BIGINT, ColumnBinding(window_index, 0));
535: 
536: 		if (limit.limit_val.Type() == LimitNodeType::CONSTANT_VALUE) {
537: 			auto upper_bound_limit = NumericLimits<int64_t>::Maximum();
538: 			auto limit_val = int64_t(limit.limit_val.GetConstantValue());
539: 			if (limit.offset_val.Type() == LimitNodeType::CONSTANT_VALUE) {
540: 				// both offset and limit specified - upper bound is offset + limit
541: 				auto offset_val = int64_t(limit.offset_val.GetConstantValue());
542: 				TryAddOperator::Operation(limit_val, offset_val, upper_bound_limit);
543: 			} else {
544: 				// no offset - upper bound is only the limit
545: 				upper_bound_limit = limit_val;
546: 			}
547: 			auto upper_bound = make_uniq<BoundConstantExpression>(Value::BIGINT(upper_bound_limit));
548: 			condition = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_LESSTHANOREQUALTO,
549: 			                                                 row_num_ref->Copy(), std::move(upper_bound));
550: 		}
551: 		// we only need to add "row_number >= offset + 1" if offset is bigger than 0
552: 		if (limit.offset_val.Type() == LimitNodeType::CONSTANT_VALUE) {
553: 			auto offset_val = int64_t(limit.offset_val.GetConstantValue());
554: 			auto lower_bound = make_uniq<BoundConstantExpression>(Value::BIGINT(offset_val));
555: 			auto lower_comp = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_GREATERTHAN,
556: 			                                                       row_num_ref->Copy(), std::move(lower_bound));
557: 			if (condition) {
558: 				auto conj = make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND,
559: 				                                                  std::move(lower_comp), std::move(condition));
560: 				condition = std::move(conj);
561: 			} else {
562: 				condition = std::move(lower_comp);
563: 			}
564: 		}
565: 		filter->expressions.push_back(std::move(condition));
566: 		filter->children.push_back(std::move(window));
567: 		// we prune away the row_number after the filter clause using the projection map
568: 		for (idx_t i = 0; i < child_column_count; i++) {
569: 			filter->projection_map.push_back(i);
570: 		}
571: 		return std::move(filter);
572: 	}
573: 	case LogicalOperatorType::LOGICAL_WINDOW: {
574: 		auto &window = plan->Cast<LogicalWindow>();
575: 		// push into children
576: 		plan->children[0] =
577: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
578: 
579: 		// we replace any correlated expressions with the corresponding entry in the correlated_map
580: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
581: 		rewriter.VisitOperator(*plan);
582: 
583: 		// add the correlated columns to the PARTITION BY clauses in the Window
584: 		for (auto &expr : window.expressions) {
585: 			D_ASSERT(expr->GetExpressionClass() == ExpressionClass::BOUND_WINDOW);
586: 			auto &w = expr->Cast<BoundWindowExpression>();
587: 			for (idx_t i = 0; i < correlated_columns.size(); i++) {
588: 				w.partitions.push_back(make_uniq<BoundColumnRefExpression>(
589: 				    correlated_columns[i].type,
590: 				    ColumnBinding(base_binding.table_index, base_binding.column_index + i)));
591: 			}
592: 		}
593: 		return plan;
594: 	}
595: 	case LogicalOperatorType::LOGICAL_EXCEPT:
596: 	case LogicalOperatorType::LOGICAL_INTERSECT:
597: 	case LogicalOperatorType::LOGICAL_UNION: {
598: 		auto &setop = plan->Cast<LogicalSetOperation>();
599: 		// set operator, push into both children
600: #ifdef DEBUG
601: 		plan->children[0]->ResolveOperatorTypes();
602: 		plan->children[1]->ResolveOperatorTypes();
603: 		D_ASSERT(plan->children[0]->types == plan->children[1]->types);
604: #endif
605: 		plan->children[0] = PushDownDependentJoin(std::move(plan->children[0]));
606: 		plan->children[1] = PushDownDependentJoin(std::move(plan->children[1]));
607: #ifdef DEBUG
608: 		D_ASSERT(plan->children[0]->GetColumnBindings().size() == plan->children[1]->GetColumnBindings().size());
609: 		plan->children[0]->ResolveOperatorTypes();
610: 		plan->children[1]->ResolveOperatorTypes();
611: 		D_ASSERT(plan->children[0]->types == plan->children[1]->types);
612: #endif
613: 		// we have to refer to the setop index now
614: 		base_binding.table_index = setop.table_index;
615: 		base_binding.column_index = setop.column_count;
616: 		setop.column_count += correlated_columns.size();
617: 		return plan;
618: 	}
619: 	case LogicalOperatorType::LOGICAL_DISTINCT: {
620: 		auto &distinct = plan->Cast<LogicalDistinct>();
621: 		// push down into child
622: 		distinct.children[0] = PushDownDependentJoin(std::move(distinct.children[0]));
623: 		// add all correlated columns to the distinct targets
624: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
625: 			distinct.distinct_targets.push_back(make_uniq<BoundColumnRefExpression>(
626: 			    correlated_columns[i].type, ColumnBinding(base_binding.table_index, base_binding.column_index + i)));
627: 		}
628: 		return plan;
629: 	}
630: 	case LogicalOperatorType::LOGICAL_EXPRESSION_GET: {
631: 		// expression get
632: 		// first we flatten the dependent join in the child
633: 		plan->children[0] =
634: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
635: 		// then we replace any correlated expressions with the corresponding entry in the correlated_map
636: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
637: 		rewriter.VisitOperator(*plan);
638: 		// now we add all the correlated columns to each of the expressions of the expression scan
639: 		auto &expr_get = plan->Cast<LogicalExpressionGet>();
640: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
641: 			for (auto &expr_list : expr_get.expressions) {
642: 				auto colref = make_uniq<BoundColumnRefExpression>(
643: 				    correlated_columns[i].type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));
644: 				expr_list.push_back(std::move(colref));
645: 			}
646: 			expr_get.expr_types.push_back(correlated_columns[i].type);
647: 		}
648: 
649: 		base_binding.table_index = expr_get.table_index;
650: 		this->delim_offset = base_binding.column_index = expr_get.expr_types.size() - correlated_columns.size();
651: 		this->data_offset = 0;
652: 		return plan;
653: 	}
654: 	case LogicalOperatorType::LOGICAL_PIVOT:
655: 		throw BinderException("PIVOT is not supported in correlated subqueries yet");
656: 	case LogicalOperatorType::LOGICAL_ORDER_BY:
657: 		plan->children[0] = PushDownDependentJoin(std::move(plan->children[0]));
658: 		return plan;
659: 	case LogicalOperatorType::LOGICAL_GET: {
660: 		auto &get = plan->Cast<LogicalGet>();
661: 		if (get.children.size() != 1) {
662: 			throw InternalException("Flatten dependent joins - logical get encountered without children");
663: 		}
664: 		plan->children[0] = PushDownDependentJoin(std::move(plan->children[0]));
665: 		for (idx_t i = 0; i < correlated_columns.size(); i++) {
666: 			get.projected_input.push_back(this->delim_offset + i);
667: 		}
668: 		this->delim_offset = get.returned_types.size();
669: 		this->data_offset = 0;
670: 
671: 		RewriteCorrelatedExpressions rewriter(base_binding, correlated_map, lateral_depth);
672: 		rewriter.VisitOperator(*plan);
673: 		return plan;
674: 	}
675: 	case LogicalOperatorType::LOGICAL_MATERIALIZED_CTE:
676: 	case LogicalOperatorType::LOGICAL_RECURSIVE_CTE: {
677: 
678: #ifdef DEBUG
679: 		plan->children[0]->ResolveOperatorTypes();
680: 		plan->children[1]->ResolveOperatorTypes();
681: #endif
682: 		idx_t table_index = 0;
683: 		plan->children[0] =
684: 		    PushDownDependentJoinInternal(std::move(plan->children[0]), parent_propagate_null_values, lateral_depth);
685: 		if (plan->type == LogicalOperatorType::LOGICAL_RECURSIVE_CTE) {
686: 			auto &setop = plan->Cast<LogicalRecursiveCTE>();
687: 			base_binding.table_index = setop.table_index;
688: 			base_binding.column_index = setop.column_count;
689: 			table_index = setop.table_index;
690: 			setop.correlated_columns = correlated_columns;
691: 		} else if (plan->type == LogicalOperatorType::LOGICAL_MATERIALIZED_CTE) {
692: 			auto &setop = plan->Cast<LogicalMaterializedCTE>();
693: 			base_binding.table_index = setop.table_index;
694: 			base_binding.column_index = setop.column_count;
695: 			table_index = setop.table_index;
696: 		}
697: 
698: 		RewriteCTEScan cte_rewriter(table_index, correlated_columns);
699: 		cte_rewriter.VisitOperator(*plan->children[1]);
700: 
701: 		parent_propagate_null_values = false;
702: 		plan->children[1] =
703: 		    PushDownDependentJoinInternal(std::move(plan->children[1]), parent_propagate_null_values, lateral_depth);
704: 		RewriteCorrelatedExpressions rewriter(this->base_binding, correlated_map, lateral_depth);
705: 		rewriter.VisitOperator(*plan);
706: 
707: 		RewriteCorrelatedExpressions recursive_rewriter(this->base_binding, correlated_map, lateral_depth, true);
708: 		recursive_rewriter.VisitOperator(*plan->children[0]);
709: 		recursive_rewriter.VisitOperator(*plan->children[1]);
710: 
711: #ifdef DEBUG
712: 		plan->children[0]->ResolveOperatorTypes();
713: 		plan->children[1]->ResolveOperatorTypes();
714: #endif
715: 		if (plan->type == LogicalOperatorType::LOGICAL_RECURSIVE_CTE) {
716: 			// we have to refer to the recursive CTE index now
717: 			auto &setop = plan->Cast<LogicalRecursiveCTE>();
718: 			base_binding.table_index = setop.table_index;
719: 			base_binding.column_index = setop.column_count;
720: 			setop.column_count += correlated_columns.size();
721: 		}
722: 
723: 		return plan;
724: 	}
725: 	case LogicalOperatorType::LOGICAL_CTE_REF: {
726: 		auto &cteref = plan->Cast<LogicalCTERef>();
727: 		// Read correlated columns from CTE_SCAN instead of from DELIM_SCAN
728: 		base_binding.table_index = cteref.table_index;
729: 		base_binding.column_index = cteref.chunk_types.size() - cteref.correlated_columns;
730: 		return plan;
731: 	}
732: 	case LogicalOperatorType::LOGICAL_DELIM_JOIN: {
733: 		throw BinderException("Nested lateral joins or lateral joins in correlated subqueries are not (yet) supported");
734: 	}
735: 	case LogicalOperatorType::LOGICAL_SAMPLE:
736: 		throw BinderException("Sampling in correlated subqueries is not (yet) supported");
737: 	default:
738: 		throw InternalException("Logical operator type \"%s\" for dependent join", LogicalOperatorToString(plan->type));
739: 	}
740: }
741: 
742: } // namespace duckdb
[end of src/planner/subquery/flatten_dependent_join.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: