{
  "repo": "duckdb/duckdb",
  "pull_number": 7844,
  "instance_id": "duckdb__duckdb-7844",
  "issue_numbers": [
    "7566"
  ],
  "base_commit": "ae0f13744b519f18f2d34a5b73f7439c21e7e6d9",
  "patch": "diff --git a/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp b/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\nindex 5a70b4c9aba5..247dcfe50472 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\n@@ -213,6 +213,8 @@ struct DuckDBPyRelation {\n \tunique_ptr<QueryResult> ExecuteInternal(bool stream_result = false);\n \n private:\n+\t//! Whether the relation has been executed at least once\n+\tbool executed;\n \tshared_ptr<Relation> rel;\n \tvector<LogicalType> types;\n \tvector<string> names;\ndiff --git a/tools/pythonpkg/src/pyrelation.cpp b/tools/pythonpkg/src/pyrelation.cpp\nindex 45fd21ccac6d..1b094ba9bb11 100644\n--- a/tools/pythonpkg/src/pyrelation.cpp\n+++ b/tools/pythonpkg/src/pyrelation.cpp\n@@ -22,6 +22,7 @@ DuckDBPyRelation::DuckDBPyRelation(shared_ptr<Relation> rel_p) : rel(std::move(r\n \tif (!rel) {\n \t\tthrow InternalException(\"DuckDBPyRelation created without a relation\");\n \t}\n+\tthis->executed = false;\n \tauto &columns = rel->Columns();\n \tfor (auto &col : columns) {\n \t\tnames.push_back(col.GetName());\n@@ -33,6 +34,7 @@ DuckDBPyRelation::DuckDBPyRelation(unique_ptr<DuckDBPyResult> result_p) : rel(nu\n \tif (!result) {\n \t\tthrow InternalException(\"DuckDBPyRelation created without a result\");\n \t}\n+\tthis->executed = true;\n \tthis->types = result->GetTypes();\n \tthis->names = result->GetNames();\n }\n@@ -401,6 +403,7 @@ static unique_ptr<QueryResult> PyExecuteRelation(const shared_ptr<Relation> &rel\n }\n \n unique_ptr<QueryResult> DuckDBPyRelation::ExecuteInternal(bool stream_result) {\n+\tthis->executed = true;\n \treturn PyExecuteRelation(rel, stream_result);\n }\n \n@@ -572,14 +575,17 @@ duckdb::pyarrow::RecordBatchReader DuckDBPyRelation::ToRecordBatch(idx_t batch_s\n }\n \n void DuckDBPyRelation::Close() {\n-\tif (!result) {\n+\t// We always want to execute the query at least once, for side-effect purposes.\n+\t// if it has already been executed, we don't need to do it again.\n+\tif (!executed && !result) {\n \t\tif (!rel) {\n \t\t\treturn;\n \t\t}\n \t\tExecuteOrThrow();\n \t}\n-\tAssertResultOpen();\n-\tresult->Close();\n+\tif (result) {\n+\t\tresult->Close();\n+\t}\n }\n \n bool DuckDBPyRelation::ContainsColumnByName(const string &name) const {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_relation.py b/tools/pythonpkg/tests/fast/test_relation.py\nindex 1f65b398c65f..c26116c315d1 100644\n--- a/tools/pythonpkg/tests/fast/test_relation.py\n+++ b/tools/pythonpkg/tests/fast/test_relation.py\n@@ -252,6 +252,31 @@ def test_fetchnumpy(self, duckdb_cursor):\n             # invalid conversion of negative integer to UINTEGER\n             rel.project(\"CAST(a as UINTEGER)\").fetchnumpy()\n \n+    def test_close(self):\n+        def counter():\n+            counter.count += 1\n+            return 42\n+\n+        counter.count = 0\n+        conn = duckdb.connect()\n+        conn.create_function('my_counter', counter, [], BIGINT)\n+\n+        # Create a relation\n+        rel = conn.sql('select my_counter()')\n+        # Execute the relation once\n+        rel.fetchall()\n+        assert counter.count == 1\n+        # Close the result\n+        rel.close()\n+        # Verify that the query was not run again\n+        assert counter.count == 1\n+        rel.fetchall()\n+        assert counter.count == 2\n+\n+        # Verify that the query is run at least once if it's closed before it was executed.\n+        rel = conn.sql('select my_counter()')\n+        rel.close()\n+        assert counter.count == 3\n \n     def test_relation_print(self, duckdb_cursor):\n         con = duckdb.connect()\n",
  "problem_statement": "`DuckDBPyRelation.close()` takes as long as the query itself\n### What happens?\n\nClosing a relational query (`query.close()`) takes as long as the execution of the query itself (`query.df()`).\n\n### To Reproduce\n\n```py\r\ncon = duckdb.connect(database=':memory:').cursor()\r\nquery = con.from_df(df)\r\nquery.filter(...)\r\nquery.limit(...)\r\nquery.df() # Takes 800ms.\r\nquery.close() # PROBLEM: Takes another 800ms.\r\ncon.close() # NO PROBLEM: Takes <1ms.\r\n```\n\n### OS:\n\nMac OS Ventura\n\n### DuckDB Version:\n\n0.7.1\n\n### DuckDB Client:\n\n0.7.1\n\n### Full Name:\n\nDaniel Smilkov\n\n### Affiliation:\n\nLilac AI Inc.\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "What happens here is that `df` creates and consumes the result.\r\nIn `close` we check if there is a result, if there isn't we execute the relation.\r\n\r\nI believe this is done because relations can also be made on plans that have side-effects, so we execute the relation for those side effects in case the relation was created but not explicitly consumed.\r\n\r\nThat's my suspicion, I'll verify it soon",
  "created_at": "2023-06-06T12:30:47Z"
}