You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
DuckDB throws InternalError when creating a table from an empty DataFrame with a categoric column
### What happens?

I received an inscrutable internal error from DuckDb under certain conditions in my app;
```
con.execute("CREATE TABLE test AS SELECT * FROM empty_categoric_df")
duckdb.duckdb.InternalException: INTERNAL Error: Information loss on integer cast: value -1 outside of target range [0, 255]
```

Upon digging, and paring back details of my use case I found that the cause was when creating a table from an empty pandas DataFrame which included a categoric column.

I understand this may be a bit of an invalid edge case, but a more intelligible error message would have made it easier to debug.

### To Reproduce

Reproduction script:

```
import pandas as pd
import duckdb

con = duckdb.connect()

data = {'category': pd.Categorical(['A', 'B', 'C'])}
populated_categoric_df = pd.DataFrame(data)

con.execute("CREATE TABLE test AS SELECT * FROM populated_categoric_df")

empty_categoric_df = pd.DataFrame({'category': pd.Series(dtype='category')})

print(empty_categoric_df)
print(empty_categoric_df.dtypes)
print(empty_categoric_df['category'].cat.categories)
print(empty_categoric_df['category'].cat.codes)

con.execute("CREATE TABLE test AS SELECT * FROM empty_categoric_df")
```

The former case works, of course, the latter throws the error.

Output from the above reproduction script:
```
Empty DataFrame
Columns: [category]
Index: []
category    category
dtype: object
Index([], dtype='object')
Series([], dtype: int8)
Traceback (most recent call last):
  File <redacted>, line 18, in <module>
    con.execute("CREATE TABLE test AS SELECT * FROM empty_categoric_df")
duckdb.duckdb.InternalException: INTERNAL Error: Information loss on integer cast: value -1 outside of target range [0, 255]
This error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.
For more information, see https://duckdb.org/docs/dev/internal_errors
```

### OS:

linux/amd64

### DuckDB Version:

1.0.0

### DuckDB Client:

Python

### Full Name:

Simon Grant

### Affiliation:

n/a

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/common/types/value.cpp]
1: #include "duckdb/common/types/value.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/to_string.hpp"
5: #include "duckdb/common/limits.hpp"
6: #include "duckdb/common/operator/aggregate_operators.hpp"
7: #include "duckdb/common/operator/cast_operators.hpp"
8: #include "duckdb/common/operator/comparison_operators.hpp"
9: 
10: #include "duckdb/common/uhugeint.hpp"
11: #include "utf8proc_wrapper.hpp"
12: #include "duckdb/common/operator/numeric_binary_operators.hpp"
13: #include "duckdb/common/printer.hpp"
14: #include "duckdb/common/types/blob.hpp"
15: #include "duckdb/common/types/date.hpp"
16: #include "duckdb/common/types/decimal.hpp"
17: #include "duckdb/common/types/hugeint.hpp"
18: #include "duckdb/common/types/uuid.hpp"
19: #include "duckdb/common/types/interval.hpp"
20: #include "duckdb/common/types/null_value.hpp"
21: #include "duckdb/common/types/time.hpp"
22: #include "duckdb/common/types/timestamp.hpp"
23: #include "duckdb/common/types/bit.hpp"
24: #include "duckdb/common/types/vector.hpp"
25: #include "duckdb/common/value_operations/value_operations.hpp"
26: #include "duckdb/common/vector_operations/vector_operations.hpp"
27: #include "duckdb/common/string_util.hpp"
28: #include "duckdb/common/types/cast_helpers.hpp"
29: #include "duckdb/common/types/hash.hpp"
30: #include "duckdb/function/cast/cast_function_set.hpp"
31: #include "duckdb/main/error_manager.hpp"
32: 
33: #include "duckdb/common/serializer/serializer.hpp"
34: #include "duckdb/common/serializer/deserializer.hpp"
35: 
36: #include <utility>
37: #include <cmath>
38: 
39: namespace duckdb {
40: 
41: //===--------------------------------------------------------------------===//
42: // Extra Value Info
43: //===--------------------------------------------------------------------===//
44: enum class ExtraValueInfoType : uint8_t { INVALID_TYPE_INFO = 0, STRING_VALUE_INFO = 1, NESTED_VALUE_INFO = 2 };
45: 
46: struct ExtraValueInfo {
47: 	explicit ExtraValueInfo(ExtraValueInfoType type) : type(type) {
48: 	}
49: 	virtual ~ExtraValueInfo() {
50: 	}
51: 
52: 	ExtraValueInfoType type;
53: 
54: public:
55: 	bool Equals(ExtraValueInfo *other_p) const {
56: 		if (!other_p) {
57: 			return false;
58: 		}
59: 		if (type != other_p->type) {
60: 			return false;
61: 		}
62: 		return EqualsInternal(other_p);
63: 	}
64: 
65: 	template <class T>
66: 	T &Get() {
67: 		if (type != T::TYPE) {
68: 			throw InternalException("ExtraValueInfo type mismatch");
69: 		}
70: 		return (T &)*this;
71: 	}
72: 
73: protected:
74: 	virtual bool EqualsInternal(ExtraValueInfo *other_p) const {
75: 		return true;
76: 	}
77: };
78: 
79: //===--------------------------------------------------------------------===//
80: // String Value Info
81: //===--------------------------------------------------------------------===//
82: struct StringValueInfo : public ExtraValueInfo {
83: 	static constexpr const ExtraValueInfoType TYPE = ExtraValueInfoType::STRING_VALUE_INFO;
84: 
85: public:
86: 	explicit StringValueInfo(string str_p)
87: 	    : ExtraValueInfo(ExtraValueInfoType::STRING_VALUE_INFO), str(std::move(str_p)) {
88: 	}
89: 
90: 	const string &GetString() {
91: 		return str;
92: 	}
93: 
94: protected:
95: 	bool EqualsInternal(ExtraValueInfo *other_p) const override {
96: 		return other_p->Get<StringValueInfo>().str == str;
97: 	}
98: 
99: 	string str;
100: };
101: 
102: //===--------------------------------------------------------------------===//
103: // Nested Value Info
104: //===--------------------------------------------------------------------===//
105: struct NestedValueInfo : public ExtraValueInfo {
106: 	static constexpr const ExtraValueInfoType TYPE = ExtraValueInfoType::NESTED_VALUE_INFO;
107: 
108: public:
109: 	NestedValueInfo() : ExtraValueInfo(ExtraValueInfoType::NESTED_VALUE_INFO) {
110: 	}
111: 	explicit NestedValueInfo(vector<Value> values_p)
112: 	    : ExtraValueInfo(ExtraValueInfoType::NESTED_VALUE_INFO), values(std::move(values_p)) {
113: 	}
114: 
115: 	const vector<Value> &GetValues() {
116: 		return values;
117: 	}
118: 
119: protected:
120: 	bool EqualsInternal(ExtraValueInfo *other_p) const override {
121: 		return other_p->Get<NestedValueInfo>().values == values;
122: 	}
123: 
124: 	vector<Value> values;
125: };
126: //===--------------------------------------------------------------------===//
127: // Value
128: //===--------------------------------------------------------------------===//
129: Value::Value(LogicalType type) : type_(std::move(type)), is_null(true) {
130: }
131: 
132: Value::Value(int32_t val) : type_(LogicalType::INTEGER), is_null(false) {
133: 	value_.integer = val;
134: }
135: 
136: Value::Value(bool val) : type_(LogicalType::BOOLEAN), is_null(false) {
137: 	value_.boolean = val;
138: }
139: 
140: Value::Value(int64_t val) : type_(LogicalType::BIGINT), is_null(false) {
141: 	value_.bigint = val;
142: }
143: 
144: Value::Value(float val) : type_(LogicalType::FLOAT), is_null(false) {
145: 	value_.float_ = val;
146: }
147: 
148: Value::Value(double val) : type_(LogicalType::DOUBLE), is_null(false) {
149: 	value_.double_ = val;
150: }
151: 
152: Value::Value(const char *val) : Value(val ? string(val) : string()) {
153: }
154: 
155: Value::Value(std::nullptr_t val) : Value(LogicalType::VARCHAR) {
156: }
157: 
158: Value::Value(string_t val) : Value(val.GetString()) {
159: }
160: 
161: Value::Value(string val) : type_(LogicalType::VARCHAR), is_null(false) {
162: 	if (!Value::StringIsValid(val.c_str(), val.size())) {
163: 		throw ErrorManager::InvalidUnicodeError(val, "value construction");
164: 	}
165: 	value_info_ = make_shared_ptr<StringValueInfo>(std::move(val));
166: }
167: 
168: Value::~Value() {
169: }
170: 
171: Value::Value(const Value &other)
172:     : type_(other.type_), is_null(other.is_null), value_(other.value_), value_info_(other.value_info_) {
173: }
174: 
175: Value::Value(Value &&other) noexcept
176:     : type_(std::move(other.type_)), is_null(other.is_null), value_(other.value_),
177:       value_info_(std::move(other.value_info_)) {
178: }
179: 
180: Value &Value::operator=(const Value &other) {
181: 	if (this == &other) {
182: 		return *this;
183: 	}
184: 	type_ = other.type_;
185: 	is_null = other.is_null;
186: 	value_ = other.value_;
187: 	value_info_ = other.value_info_;
188: 	return *this;
189: }
190: 
191: Value &Value::operator=(Value &&other) noexcept {
192: 	type_ = std::move(other.type_);
193: 	is_null = other.is_null;
194: 	value_ = other.value_;
195: 	value_info_ = std::move(other.value_info_);
196: 	return *this;
197: }
198: 
199: Value Value::MinimumValue(const LogicalType &type) {
200: 	switch (type.id()) {
201: 	case LogicalTypeId::BOOLEAN:
202: 		return Value::BOOLEAN(false);
203: 	case LogicalTypeId::TINYINT:
204: 		return Value::TINYINT(NumericLimits<int8_t>::Minimum());
205: 	case LogicalTypeId::SMALLINT:
206: 		return Value::SMALLINT(NumericLimits<int16_t>::Minimum());
207: 	case LogicalTypeId::INTEGER:
208: 	case LogicalTypeId::SQLNULL:
209: 		return Value::INTEGER(NumericLimits<int32_t>::Minimum());
210: 	case LogicalTypeId::BIGINT:
211: 		return Value::BIGINT(NumericLimits<int64_t>::Minimum());
212: 	case LogicalTypeId::HUGEINT:
213: 		return Value::HUGEINT(NumericLimits<hugeint_t>::Minimum());
214: 	case LogicalTypeId::UHUGEINT:
215: 		return Value::UHUGEINT(NumericLimits<uhugeint_t>::Minimum());
216: 	case LogicalTypeId::UUID:
217: 		return Value::UUID(NumericLimits<hugeint_t>::Minimum());
218: 	case LogicalTypeId::UTINYINT:
219: 		return Value::UTINYINT(NumericLimits<uint8_t>::Minimum());
220: 	case LogicalTypeId::USMALLINT:
221: 		return Value::USMALLINT(NumericLimits<uint16_t>::Minimum());
222: 	case LogicalTypeId::UINTEGER:
223: 		return Value::UINTEGER(NumericLimits<uint32_t>::Minimum());
224: 	case LogicalTypeId::UBIGINT:
225: 		return Value::UBIGINT(NumericLimits<uint64_t>::Minimum());
226: 	case LogicalTypeId::DATE:
227: 		return Value::DATE(Date::FromDate(Date::DATE_MIN_YEAR, Date::DATE_MIN_MONTH, Date::DATE_MIN_DAY));
228: 	case LogicalTypeId::TIME:
229: 		return Value::TIME(dtime_t(0));
230: 	case LogicalTypeId::TIMESTAMP:
231: 		return Value::TIMESTAMP(Date::FromDate(Timestamp::MIN_YEAR, Timestamp::MIN_MONTH, Timestamp::MIN_DAY),
232: 		                        dtime_t(0));
233: 	case LogicalTypeId::TIMESTAMP_SEC: {
234: 		//	Casting rounds up, which will overflow
235: 		const auto min_us = MinimumValue(LogicalType::TIMESTAMP).GetValue<timestamp_t>();
236: 		return Value::TIMESTAMPSEC(timestamp_t(Timestamp::GetEpochSeconds(min_us)));
237: 	}
238: 	case LogicalTypeId::TIMESTAMP_MS: {
239: 		//	Casting rounds up, which will overflow
240: 		const auto min_us = MinimumValue(LogicalType::TIMESTAMP).GetValue<timestamp_t>();
241: 		return Value::TIMESTAMPMS(timestamp_t(Timestamp::GetEpochMs(min_us)));
242: 	}
243: 	case LogicalTypeId::TIMESTAMP_NS:
244: 		return Value::TIMESTAMPNS(timestamp_t(NumericLimits<int64_t>::Minimum()));
245: 	case LogicalTypeId::TIME_TZ:
246: 		//	"00:00:00+1559" from the PG docs, but actually 00:00:00+15:59:59
247: 		return Value::TIMETZ(dtime_tz_t(dtime_t(0), dtime_tz_t::MAX_OFFSET));
248: 	case LogicalTypeId::TIMESTAMP_TZ:
249: 		return Value::TIMESTAMPTZ(Timestamp::FromDatetime(
250: 		    Date::FromDate(Timestamp::MIN_YEAR, Timestamp::MIN_MONTH, Timestamp::MIN_DAY), dtime_t(0)));
251: 	case LogicalTypeId::FLOAT:
252: 		return Value::FLOAT(NumericLimits<float>::Minimum());
253: 	case LogicalTypeId::DOUBLE:
254: 		return Value::DOUBLE(NumericLimits<double>::Minimum());
255: 	case LogicalTypeId::DECIMAL: {
256: 		auto width = DecimalType::GetWidth(type);
257: 		auto scale = DecimalType::GetScale(type);
258: 		switch (type.InternalType()) {
259: 		case PhysicalType::INT16:
260: 			return Value::DECIMAL(int16_t(-NumericHelper::POWERS_OF_TEN[width] + 1), width, scale);
261: 		case PhysicalType::INT32:
262: 			return Value::DECIMAL(int32_t(-NumericHelper::POWERS_OF_TEN[width] + 1), width, scale);
263: 		case PhysicalType::INT64:
264: 			return Value::DECIMAL(int64_t(-NumericHelper::POWERS_OF_TEN[width] + 1), width, scale);
265: 		case PhysicalType::INT128:
266: 			return Value::DECIMAL(-Hugeint::POWERS_OF_TEN[width] + 1, width, scale);
267: 		default:
268: 			throw InternalException("Unknown decimal type");
269: 		}
270: 	}
271: 	case LogicalTypeId::ENUM:
272: 		return Value::ENUM(0, type);
273: 	default:
274: 		throw InvalidTypeException(type, "MinimumValue requires numeric type");
275: 	}
276: }
277: 
278: Value Value::MaximumValue(const LogicalType &type) {
279: 	switch (type.id()) {
280: 	case LogicalTypeId::BOOLEAN:
281: 		return Value::BOOLEAN(true);
282: 	case LogicalTypeId::TINYINT:
283: 		return Value::TINYINT(NumericLimits<int8_t>::Maximum());
284: 	case LogicalTypeId::SMALLINT:
285: 		return Value::SMALLINT(NumericLimits<int16_t>::Maximum());
286: 	case LogicalTypeId::INTEGER:
287: 	case LogicalTypeId::SQLNULL:
288: 		return Value::INTEGER(NumericLimits<int32_t>::Maximum());
289: 	case LogicalTypeId::BIGINT:
290: 		return Value::BIGINT(NumericLimits<int64_t>::Maximum());
291: 	case LogicalTypeId::HUGEINT:
292: 		return Value::HUGEINT(NumericLimits<hugeint_t>::Maximum());
293: 	case LogicalTypeId::UHUGEINT:
294: 		return Value::UHUGEINT(NumericLimits<uhugeint_t>::Maximum());
295: 	case LogicalTypeId::UUID:
296: 		return Value::UUID(NumericLimits<hugeint_t>::Maximum());
297: 	case LogicalTypeId::UTINYINT:
298: 		return Value::UTINYINT(NumericLimits<uint8_t>::Maximum());
299: 	case LogicalTypeId::USMALLINT:
300: 		return Value::USMALLINT(NumericLimits<uint16_t>::Maximum());
301: 	case LogicalTypeId::UINTEGER:
302: 		return Value::UINTEGER(NumericLimits<uint32_t>::Maximum());
303: 	case LogicalTypeId::UBIGINT:
304: 		return Value::UBIGINT(NumericLimits<uint64_t>::Maximum());
305: 	case LogicalTypeId::DATE:
306: 		return Value::DATE(Date::FromDate(Date::DATE_MAX_YEAR, Date::DATE_MAX_MONTH, Date::DATE_MAX_DAY));
307: 	case LogicalTypeId::TIME:
308: 		//	24:00:00 according to PG
309: 		return Value::TIME(dtime_t(Interval::MICROS_PER_DAY));
310: 	case LogicalTypeId::TIMESTAMP:
311: 		return Value::TIMESTAMP(timestamp_t(NumericLimits<int64_t>::Maximum() - 1));
312: 	case LogicalTypeId::TIMESTAMP_MS: {
313: 		//	Casting rounds up, which will overflow
314: 		const auto max_us = MaximumValue(LogicalType::TIMESTAMP).GetValue<timestamp_t>();
315: 		return Value::TIMESTAMPMS(timestamp_t(Timestamp::GetEpochMs(max_us)));
316: 	}
317: 	case LogicalTypeId::TIMESTAMP_NS:
318: 		return Value::TIMESTAMPNS(timestamp_t(NumericLimits<int64_t>::Maximum() - 1));
319: 	case LogicalTypeId::TIMESTAMP_SEC: {
320: 		//	Casting rounds up, which will overflow
321: 		const auto max_us = MaximumValue(LogicalType::TIMESTAMP).GetValue<timestamp_t>();
322: 		return Value::TIMESTAMPSEC(timestamp_t(Timestamp::GetEpochSeconds(max_us)));
323: 	}
324: 	case LogicalTypeId::TIME_TZ:
325: 		//	"24:00:00-1559" from the PG docs but actually "24:00:00-15:59:59"
326: 		return Value::TIMETZ(dtime_tz_t(dtime_t(Interval::MICROS_PER_DAY), dtime_tz_t::MIN_OFFSET));
327: 	case LogicalTypeId::TIMESTAMP_TZ:
328: 		return MaximumValue(LogicalType::TIMESTAMP);
329: 	case LogicalTypeId::FLOAT:
330: 		return Value::FLOAT(NumericLimits<float>::Maximum());
331: 	case LogicalTypeId::DOUBLE:
332: 		return Value::DOUBLE(NumericLimits<double>::Maximum());
333: 	case LogicalTypeId::DECIMAL: {
334: 		auto width = DecimalType::GetWidth(type);
335: 		auto scale = DecimalType::GetScale(type);
336: 		switch (type.InternalType()) {
337: 		case PhysicalType::INT16:
338: 			return Value::DECIMAL(int16_t(NumericHelper::POWERS_OF_TEN[width] - 1), width, scale);
339: 		case PhysicalType::INT32:
340: 			return Value::DECIMAL(int32_t(NumericHelper::POWERS_OF_TEN[width] - 1), width, scale);
341: 		case PhysicalType::INT64:
342: 			return Value::DECIMAL(int64_t(NumericHelper::POWERS_OF_TEN[width] - 1), width, scale);
343: 		case PhysicalType::INT128:
344: 			return Value::DECIMAL(Hugeint::POWERS_OF_TEN[width] - 1, width, scale);
345: 		default:
346: 			throw InternalException("Unknown decimal type");
347: 		}
348: 	}
349: 	case LogicalTypeId::ENUM:
350: 		return Value::ENUM(EnumType::GetSize(type) - 1, type);
351: 	default:
352: 		throw InvalidTypeException(type, "MaximumValue requires numeric type");
353: 	}
354: }
355: 
356: Value Value::Infinity(const LogicalType &type) {
357: 	switch (type.id()) {
358: 	case LogicalTypeId::DATE:
359: 		return Value::DATE(date_t::infinity());
360: 	case LogicalTypeId::TIMESTAMP:
361: 		return Value::TIMESTAMP(timestamp_t::infinity());
362: 	case LogicalTypeId::TIMESTAMP_MS:
363: 		return Value::TIMESTAMPMS(timestamp_t::infinity());
364: 	case LogicalTypeId::TIMESTAMP_NS:
365: 		return Value::TIMESTAMPNS(timestamp_t::infinity());
366: 	case LogicalTypeId::TIMESTAMP_SEC:
367: 		return Value::TIMESTAMPSEC(timestamp_t::infinity());
368: 	case LogicalTypeId::TIMESTAMP_TZ:
369: 		return Value::TIMESTAMPTZ(timestamp_t::infinity());
370: 	case LogicalTypeId::FLOAT:
371: 		return Value::FLOAT(std::numeric_limits<float>::infinity());
372: 	case LogicalTypeId::DOUBLE:
373: 		return Value::DOUBLE(std::numeric_limits<double>::infinity());
374: 	default:
375: 		throw InvalidTypeException(type, "Infinity requires numeric type");
376: 	}
377: }
378: 
379: Value Value::NegativeInfinity(const LogicalType &type) {
380: 	switch (type.id()) {
381: 	case LogicalTypeId::DATE:
382: 		return Value::DATE(date_t::ninfinity());
383: 	case LogicalTypeId::TIMESTAMP:
384: 		return Value::TIMESTAMP(timestamp_t::ninfinity());
385: 	case LogicalTypeId::TIMESTAMP_MS:
386: 		return Value::TIMESTAMPMS(timestamp_t::ninfinity());
387: 	case LogicalTypeId::TIMESTAMP_NS:
388: 		return Value::TIMESTAMPNS(timestamp_t::ninfinity());
389: 	case LogicalTypeId::TIMESTAMP_SEC:
390: 		return Value::TIMESTAMPSEC(timestamp_t::ninfinity());
391: 	case LogicalTypeId::TIMESTAMP_TZ:
392: 		return Value::TIMESTAMPTZ(timestamp_t::ninfinity());
393: 	case LogicalTypeId::FLOAT:
394: 		return Value::FLOAT(-std::numeric_limits<float>::infinity());
395: 	case LogicalTypeId::DOUBLE:
396: 		return Value::DOUBLE(-std::numeric_limits<double>::infinity());
397: 	default:
398: 		throw InvalidTypeException(type, "NegativeInfinity requires numeric type");
399: 	}
400: }
401: 
402: Value Value::BOOLEAN(int8_t value) {
403: 	Value result(LogicalType::BOOLEAN);
404: 	result.value_.boolean = bool(value);
405: 	result.is_null = false;
406: 	return result;
407: }
408: 
409: Value Value::TINYINT(int8_t value) {
410: 	Value result(LogicalType::TINYINT);
411: 	result.value_.tinyint = value;
412: 	result.is_null = false;
413: 	return result;
414: }
415: 
416: Value Value::SMALLINT(int16_t value) {
417: 	Value result(LogicalType::SMALLINT);
418: 	result.value_.smallint = value;
419: 	result.is_null = false;
420: 	return result;
421: }
422: 
423: Value Value::INTEGER(int32_t value) {
424: 	Value result(LogicalType::INTEGER);
425: 	result.value_.integer = value;
426: 	result.is_null = false;
427: 	return result;
428: }
429: 
430: Value Value::BIGINT(int64_t value) {
431: 	Value result(LogicalType::BIGINT);
432: 	result.value_.bigint = value;
433: 	result.is_null = false;
434: 	return result;
435: }
436: 
437: Value Value::HUGEINT(hugeint_t value) {
438: 	Value result(LogicalType::HUGEINT);
439: 	result.value_.hugeint = value;
440: 	result.is_null = false;
441: 	return result;
442: }
443: 
444: Value Value::UHUGEINT(uhugeint_t value) {
445: 	Value result(LogicalType::UHUGEINT);
446: 	result.value_.uhugeint = value;
447: 	result.is_null = false;
448: 	return result;
449: }
450: 
451: Value Value::UUID(hugeint_t value) {
452: 	Value result(LogicalType::UUID);
453: 	result.value_.hugeint = value;
454: 	result.is_null = false;
455: 	return result;
456: }
457: 
458: Value Value::UUID(const string &value) {
459: 	Value result(LogicalType::UUID);
460: 	result.value_.hugeint = UUID::FromString(value);
461: 	result.is_null = false;
462: 	return result;
463: }
464: 
465: Value Value::UTINYINT(uint8_t value) {
466: 	Value result(LogicalType::UTINYINT);
467: 	result.value_.utinyint = value;
468: 	result.is_null = false;
469: 	return result;
470: }
471: 
472: Value Value::USMALLINT(uint16_t value) {
473: 	Value result(LogicalType::USMALLINT);
474: 	result.value_.usmallint = value;
475: 	result.is_null = false;
476: 	return result;
477: }
478: 
479: Value Value::UINTEGER(uint32_t value) {
480: 	Value result(LogicalType::UINTEGER);
481: 	result.value_.uinteger = value;
482: 	result.is_null = false;
483: 	return result;
484: }
485: 
486: Value Value::UBIGINT(uint64_t value) {
487: 	Value result(LogicalType::UBIGINT);
488: 	result.value_.ubigint = value;
489: 	result.is_null = false;
490: 	return result;
491: }
492: 
493: bool Value::FloatIsFinite(float value) {
494: 	return !(std::isnan(value) || std::isinf(value));
495: }
496: 
497: bool Value::DoubleIsFinite(double value) {
498: 	return !(std::isnan(value) || std::isinf(value));
499: }
500: 
501: template <>
502: bool Value::IsNan(float input) {
503: 	return std::isnan(input);
504: }
505: 
506: template <>
507: bool Value::IsNan(double input) {
508: 	return std::isnan(input);
509: }
510: 
511: template <>
512: bool Value::IsFinite(float input) {
513: 	return Value::FloatIsFinite(input);
514: }
515: 
516: template <>
517: bool Value::IsFinite(double input) {
518: 	return Value::DoubleIsFinite(input);
519: }
520: 
521: template <>
522: bool Value::IsFinite(date_t input) {
523: 	return Date::IsFinite(input);
524: }
525: 
526: template <>
527: bool Value::IsFinite(timestamp_t input) {
528: 	return Timestamp::IsFinite(input);
529: }
530: 
531: bool Value::StringIsValid(const char *str, idx_t length) {
532: 	auto utf_type = Utf8Proc::Analyze(str, length);
533: 	return utf_type != UnicodeType::INVALID;
534: }
535: 
536: Value Value::DECIMAL(int16_t value, uint8_t width, uint8_t scale) {
537: 	return Value::DECIMAL(int64_t(value), width, scale);
538: }
539: 
540: Value Value::DECIMAL(int32_t value, uint8_t width, uint8_t scale) {
541: 	return Value::DECIMAL(int64_t(value), width, scale);
542: }
543: 
544: Value Value::DECIMAL(int64_t value, uint8_t width, uint8_t scale) {
545: 	auto decimal_type = LogicalType::DECIMAL(width, scale);
546: 	Value result(decimal_type);
547: 	switch (decimal_type.InternalType()) {
548: 	case PhysicalType::INT16:
549: 		result.value_.smallint = NumericCast<int16_t>(value);
550: 		break;
551: 	case PhysicalType::INT32:
552: 		result.value_.integer = NumericCast<int32_t>(value);
553: 		break;
554: 	case PhysicalType::INT64:
555: 		result.value_.bigint = value;
556: 		break;
557: 	default:
558: 		result.value_.hugeint = value;
559: 		break;
560: 	}
561: 	result.type_.Verify();
562: 	result.is_null = false;
563: 	return result;
564: }
565: 
566: Value Value::DECIMAL(hugeint_t value, uint8_t width, uint8_t scale) {
567: 	D_ASSERT(width >= Decimal::MAX_WIDTH_INT64 && width <= Decimal::MAX_WIDTH_INT128);
568: 	Value result(LogicalType::DECIMAL(width, scale));
569: 	result.value_.hugeint = value;
570: 	result.is_null = false;
571: 	return result;
572: }
573: 
574: Value Value::FLOAT(float value) {
575: 	Value result(LogicalType::FLOAT);
576: 	result.value_.float_ = value;
577: 	result.is_null = false;
578: 	return result;
579: }
580: 
581: Value Value::DOUBLE(double value) {
582: 	Value result(LogicalType::DOUBLE);
583: 	result.value_.double_ = value;
584: 	result.is_null = false;
585: 	return result;
586: }
587: 
588: Value Value::HASH(hash_t value) {
589: 	Value result(LogicalType::HASH);
590: 	result.value_.hash = value;
591: 	result.is_null = false;
592: 	return result;
593: }
594: 
595: Value Value::POINTER(uintptr_t value) {
596: 	Value result(LogicalType::POINTER);
597: 	result.value_.pointer = value;
598: 	result.is_null = false;
599: 	return result;
600: }
601: 
602: Value Value::DATE(date_t value) {
603: 	Value result(LogicalType::DATE);
604: 	result.value_.date = value;
605: 	result.is_null = false;
606: 	return result;
607: }
608: 
609: Value Value::DATE(int32_t year, int32_t month, int32_t day) {
610: 	return Value::DATE(Date::FromDate(year, month, day));
611: }
612: 
613: Value Value::TIME(dtime_t value) {
614: 	Value result(LogicalType::TIME);
615: 	result.value_.time = value;
616: 	result.is_null = false;
617: 	return result;
618: }
619: 
620: Value Value::TIMETZ(dtime_tz_t value) {
621: 	Value result(LogicalType::TIME_TZ);
622: 	result.value_.timetz = value;
623: 	result.is_null = false;
624: 	return result;
625: }
626: 
627: Value Value::TIME(int32_t hour, int32_t min, int32_t sec, int32_t micros) {
628: 	return Value::TIME(Time::FromTime(hour, min, sec, micros));
629: }
630: 
631: Value Value::TIMESTAMP(timestamp_t value) {
632: 	Value result(LogicalType::TIMESTAMP);
633: 	result.value_.timestamp = value;
634: 	result.is_null = false;
635: 	return result;
636: }
637: 
638: Value Value::TIMESTAMPTZ(timestamp_t value) {
639: 	Value result(LogicalType::TIMESTAMP_TZ);
640: 	result.value_.timestamp = value;
641: 	result.is_null = false;
642: 	return result;
643: }
644: 
645: Value Value::TIMESTAMPNS(timestamp_t timestamp) {
646: 	Value result(LogicalType::TIMESTAMP_NS);
647: 	result.value_.timestamp = timestamp;
648: 	result.is_null = false;
649: 	return result;
650: }
651: 
652: Value Value::TIMESTAMPMS(timestamp_t timestamp) {
653: 	Value result(LogicalType::TIMESTAMP_MS);
654: 	result.value_.timestamp = timestamp;
655: 	result.is_null = false;
656: 	return result;
657: }
658: 
659: Value Value::TIMESTAMPSEC(timestamp_t timestamp) {
660: 	Value result(LogicalType::TIMESTAMP_S);
661: 	result.value_.timestamp = timestamp;
662: 	result.is_null = false;
663: 	return result;
664: }
665: 
666: Value Value::TIMESTAMP(date_t date, dtime_t time) {
667: 	return Value::TIMESTAMP(Timestamp::FromDatetime(date, time));
668: }
669: 
670: Value Value::TIMESTAMP(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t min, int32_t sec,
671:                        int32_t micros) {
672: 	auto val = Value::TIMESTAMP(Date::FromDate(year, month, day), Time::FromTime(hour, min, sec, micros));
673: 	val.type_ = LogicalType::TIMESTAMP;
674: 	return val;
675: }
676: 
677: Value Value::STRUCT(const LogicalType &type, vector<Value> struct_values) {
678: 	Value result;
679: 	auto child_types = StructType::GetChildTypes(type);
680: 	for (size_t i = 0; i < struct_values.size(); i++) {
681: 		struct_values[i] = struct_values[i].DefaultCastAs(child_types[i].second);
682: 	}
683: 	result.value_info_ = make_shared_ptr<NestedValueInfo>(std::move(struct_values));
684: 	result.type_ = type;
685: 	result.is_null = false;
686: 	return result;
687: }
688: Value Value::STRUCT(child_list_t<Value> values) {
689: 	child_list_t<LogicalType> child_types;
690: 	vector<Value> struct_values;
691: 	for (auto &child : values) {
692: 		child_types.push_back(make_pair(std::move(child.first), child.second.type()));
693: 		struct_values.push_back(std::move(child.second));
694: 	}
695: 	return Value::STRUCT(LogicalType::STRUCT(child_types), std::move(struct_values));
696: }
697: 
698: Value Value::MAP(const LogicalType &child_type, vector<Value> values) { // NOLINT
699: 	vector<Value> map_keys;
700: 	vector<Value> map_values;
701: 	for (auto &val : values) {
702: 		D_ASSERT(val.type().InternalType() == PhysicalType::STRUCT);
703: 		auto &children = StructValue::GetChildren(val);
704: 		D_ASSERT(children.size() == 2);
705: 		map_keys.push_back(children[0]);
706: 		map_values.push_back(children[1]);
707: 	}
708: 	auto &key_type = StructType::GetChildType(child_type, 0);
709: 	auto &value_type = StructType::GetChildType(child_type, 1);
710: 	return Value::MAP(key_type, value_type, std::move(map_keys), std::move(map_values));
711: }
712: 
713: Value Value::MAP(const LogicalType &key_type, const LogicalType &value_type, vector<Value> keys, vector<Value> values) {
714: 	D_ASSERT(keys.size() == values.size());
715: 	Value result;
716: 
717: 	result.type_ = LogicalType::MAP(key_type, value_type);
718: 	result.is_null = false;
719: 	for (idx_t i = 0; i < keys.size(); i++) {
720: 		child_list_t<Value> new_children;
721: 		new_children.reserve(2);
722: 		new_children.push_back(std::make_pair("key", std::move(keys[i])));
723: 		new_children.push_back(std::make_pair("value", std::move(values[i])));
724: 		values[i] = Value::STRUCT(std::move(new_children));
725: 	}
726: 	result.value_info_ = make_shared_ptr<NestedValueInfo>(std::move(values));
727: 	return result;
728: }
729: 
730: Value Value::MAP(const unordered_map<string, string> &kv_pairs) {
731: 	Value result;
732: 	result.type_ = LogicalType::MAP(LogicalType::VARCHAR, LogicalType::VARCHAR);
733: 	result.is_null = false;
734: 	vector<Value> pairs;
735: 	for (auto &kv : kv_pairs) {
736: 		pairs.push_back(Value::STRUCT({{"key", Value(kv.first)}, {"value", Value(kv.second)}}));
737: 	}
738: 	result.value_info_ = make_shared_ptr<NestedValueInfo>(std::move(pairs));
739: 	return result;
740: }
741: 
742: Value Value::UNION(child_list_t<LogicalType> members, uint8_t tag, Value value) {
743: 	D_ASSERT(!members.empty());
744: 	D_ASSERT(members.size() <= UnionType::MAX_UNION_MEMBERS);
745: 	D_ASSERT(members.size() > tag);
746: 
747: 	D_ASSERT(value.type() == members[tag].second);
748: 
749: 	Value result;
750: 	result.is_null = false;
751: 	// add the tag to the front of the struct
752: 	vector<Value> union_values;
753: 	union_values.emplace_back(Value::UTINYINT(tag));
754: 	for (idx_t i = 0; i < members.size(); i++) {
755: 		if (i != tag) {
756: 			union_values.emplace_back(members[i].second);
757: 		} else {
758: 			union_values.emplace_back(nullptr);
759: 		}
760: 	}
761: 	union_values[tag + 1] = std::move(value);
762: 	result.value_info_ = make_shared_ptr<NestedValueInfo>(std::move(union_values));
763: 	result.type_ = LogicalType::UNION(std::move(members));
764: 	return result;
765: }
766: 
767: Value Value::LIST(vector<Value> values) {
768: 	if (values.empty()) {
769: 		throw InternalException("Value::LIST without providing a child-type requires a non-empty list of values. Use "
770: 		                        "Value::LIST(child_type, list) instead.");
771: 	}
772: #ifdef DEBUG
773: 	for (idx_t i = 1; i < values.size(); i++) {
774: 		D_ASSERT(values[i].type() == values[0].type());
775: 	}
776: #endif
777: 	Value result;
778: 	result.type_ = LogicalType::LIST(values[0].type());
779: 	result.value_info_ = make_shared_ptr<NestedValueInfo>(std::move(values));
780: 	result.is_null = false;
781: 	return result;
782: }
783: 
784: Value Value::LIST(const LogicalType &child_type, vector<Value> values) {
785: 	if (values.empty()) {
786: 		return Value::EMPTYLIST(child_type);
787: 	}
788: 	for (auto &val : values) {
789: 		val = val.DefaultCastAs(child_type);
790: 	}
791: 	return Value::LIST(std::move(values));
792: }
793: 
794: Value Value::EMPTYLIST(const LogicalType &child_type) {
795: 	Value result;
796: 	result.type_ = LogicalType::LIST(child_type);
797: 	result.value_info_ = make_shared_ptr<NestedValueInfo>();
798: 	result.is_null = false;
799: 	return result;
800: }
801: 
802: Value Value::ARRAY(vector<Value> values) {
803: 	if (values.empty()) {
804: 		throw InternalException("Value::ARRAY without providing a child-type requires a non-empty list of values. Use "
805: 		                        "Value::ARRAY(child_type, list) instead.");
806: 	}
807: #ifdef DEBUG
808: 	for (idx_t i = 1; i < values.size(); i++) {
809: 		D_ASSERT(values[i].type() == values[0].type());
810: 	}
811: #endif
812: 	Value result;
813: 	result.type_ = LogicalType::ARRAY(values[0].type(), values.size());
814: 	result.value_info_ = make_shared_ptr<NestedValueInfo>(std::move(values));
815: 	result.is_null = false;
816: 	return result;
817: }
818: 
819: Value Value::ARRAY(const LogicalType &child_type, vector<Value> values) {
820: 	if (values.empty()) {
821: 		return Value::EMPTYARRAY(child_type, 0);
822: 	}
823: 	for (auto &val : values) {
824: 		val = val.DefaultCastAs(child_type);
825: 	}
826: 	return Value::ARRAY(std::move(values));
827: }
828: 
829: Value Value::EMPTYARRAY(const LogicalType &child_type, uint32_t size) {
830: 	Value result;
831: 	result.type_ = LogicalType::ARRAY(child_type, size);
832: 	result.value_info_ = make_shared_ptr<NestedValueInfo>();
833: 	result.is_null = false;
834: 	return result;
835: }
836: 
837: Value Value::BLOB(const_data_ptr_t data, idx_t len) {
838: 	Value result(LogicalType::BLOB);
839: 	result.is_null = false;
840: 	result.value_info_ = make_shared_ptr<StringValueInfo>(string(const_char_ptr_cast(data), len));
841: 	return result;
842: }
843: 
844: Value Value::BLOB(const string &data) {
845: 	Value result(LogicalType::BLOB);
846: 	result.is_null = false;
847: 	result.value_info_ = make_shared_ptr<StringValueInfo>(Blob::ToBlob(string_t(data)));
848: 	return result;
849: }
850: 
851: Value Value::AGGREGATE_STATE(const LogicalType &type, const_data_ptr_t data, idx_t len) { // NOLINT
852: 	Value result(type);
853: 	result.is_null = false;
854: 	result.value_info_ = make_shared_ptr<StringValueInfo>(string(const_char_ptr_cast(data), len));
855: 	return result;
856: }
857: 
858: Value Value::BIT(const_data_ptr_t data, idx_t len) {
859: 	Value result(LogicalType::BIT);
860: 	result.is_null = false;
861: 	result.value_info_ = make_shared_ptr<StringValueInfo>(string(const_char_ptr_cast(data), len));
862: 	return result;
863: }
864: 
865: Value Value::BIT(const string &data) {
866: 	Value result(LogicalType::BIT);
867: 	result.is_null = false;
868: 	result.value_info_ = make_shared_ptr<StringValueInfo>(Bit::ToBit(string_t(data)));
869: 	return result;
870: }
871: 
872: Value Value::ENUM(uint64_t value, const LogicalType &original_type) {
873: 	D_ASSERT(original_type.id() == LogicalTypeId::ENUM);
874: 	Value result(original_type);
875: 	switch (original_type.InternalType()) {
876: 	case PhysicalType::UINT8:
877: 		result.value_.utinyint = NumericCast<uint8_t>(value);
878: 		break;
879: 	case PhysicalType::UINT16:
880: 		result.value_.usmallint = NumericCast<uint16_t>(value);
881: 		break;
882: 	case PhysicalType::UINT32:
883: 		result.value_.uinteger = NumericCast<uint32_t>(value);
884: 		break;
885: 	default:
886: 		throw InternalException("Incorrect Physical Type for ENUM");
887: 	}
888: 	result.is_null = false;
889: 	return result;
890: }
891: 
892: Value Value::INTERVAL(int32_t months, int32_t days, int64_t micros) {
893: 	Value result(LogicalType::INTERVAL);
894: 	result.is_null = false;
895: 	result.value_.interval.months = months;
896: 	result.value_.interval.days = days;
897: 	result.value_.interval.micros = micros;
898: 	return result;
899: }
900: 
901: Value Value::INTERVAL(interval_t interval) {
902: 	return Value::INTERVAL(interval.months, interval.days, interval.micros);
903: }
904: 
905: //===--------------------------------------------------------------------===//
906: // CreateValue
907: //===--------------------------------------------------------------------===//
908: template <>
909: Value Value::CreateValue(bool value) {
910: 	return Value::BOOLEAN(value);
911: }
912: 
913: template <>
914: Value Value::CreateValue(int8_t value) {
915: 	return Value::TINYINT(value);
916: }
917: 
918: template <>
919: Value Value::CreateValue(int16_t value) {
920: 	return Value::SMALLINT(value);
921: }
922: 
923: template <>
924: Value Value::CreateValue(int32_t value) {
925: 	return Value::INTEGER(value);
926: }
927: 
928: template <>
929: Value Value::CreateValue(int64_t value) {
930: 	return Value::BIGINT(value);
931: }
932: 
933: template <>
934: Value Value::CreateValue(uint8_t value) {
935: 	return Value::UTINYINT(value);
936: }
937: 
938: template <>
939: Value Value::CreateValue(uint16_t value) {
940: 	return Value::USMALLINT(value);
941: }
942: 
943: template <>
944: Value Value::CreateValue(uint32_t value) {
945: 	return Value::UINTEGER(value);
946: }
947: 
948: template <>
949: Value Value::CreateValue(uint64_t value) {
950: 	return Value::UBIGINT(value);
951: }
952: 
953: template <>
954: Value Value::CreateValue(hugeint_t value) {
955: 	return Value::HUGEINT(value);
956: }
957: 
958: template <>
959: Value Value::CreateValue(uhugeint_t value) {
960: 	return Value::UHUGEINT(value);
961: }
962: 
963: template <>
964: Value Value::CreateValue(date_t value) {
965: 	return Value::DATE(value);
966: }
967: 
968: template <>
969: Value Value::CreateValue(dtime_t value) {
970: 	return Value::TIME(value);
971: }
972: 
973: template <>
974: Value Value::CreateValue(dtime_tz_t value) {
975: 	return Value::TIMETZ(value);
976: }
977: 
978: template <>
979: Value Value::CreateValue(timestamp_t value) {
980: 	return Value::TIMESTAMP(value);
981: }
982: 
983: template <>
984: Value Value::CreateValue(timestamp_sec_t value) {
985: 	return Value::TIMESTAMPSEC(value);
986: }
987: 
988: template <>
989: Value Value::CreateValue(timestamp_ms_t value) {
990: 	return Value::TIMESTAMPMS(value);
991: }
992: 
993: template <>
994: Value Value::CreateValue(timestamp_ns_t value) {
995: 	return Value::TIMESTAMPNS(value);
996: }
997: 
998: template <>
999: Value Value::CreateValue(timestamp_tz_t value) {
1000: 	return Value::TIMESTAMPTZ(value);
1001: }
1002: 
1003: template <>
1004: Value Value::CreateValue(const char *value) {
1005: 	return Value(string(value));
1006: }
1007: 
1008: template <>
1009: Value Value::CreateValue(string value) { // NOLINT: required for templating
1010: 	return Value::BLOB(value);
1011: }
1012: 
1013: template <>
1014: Value Value::CreateValue(string_t value) {
1015: 	return Value(value);
1016: }
1017: 
1018: template <>
1019: Value Value::CreateValue(float value) {
1020: 	return Value::FLOAT(value);
1021: }
1022: 
1023: template <>
1024: Value Value::CreateValue(double value) {
1025: 	return Value::DOUBLE(value);
1026: }
1027: 
1028: template <>
1029: Value Value::CreateValue(interval_t value) {
1030: 	return Value::INTERVAL(value);
1031: }
1032: 
1033: template <>
1034: Value Value::CreateValue(Value value) {
1035: 	return value;
1036: }
1037: 
1038: //===--------------------------------------------------------------------===//
1039: // GetValue
1040: //===--------------------------------------------------------------------===//
1041: template <class T>
1042: T Value::GetValueInternal() const {
1043: 	if (IsNull()) {
1044: 		throw InternalException("Calling GetValueInternal on a value that is NULL");
1045: 	}
1046: 	switch (type_.id()) {
1047: 	case LogicalTypeId::BOOLEAN:
1048: 		return Cast::Operation<bool, T>(value_.boolean);
1049: 	case LogicalTypeId::TINYINT:
1050: 		return Cast::Operation<int8_t, T>(value_.tinyint);
1051: 	case LogicalTypeId::SMALLINT:
1052: 		return Cast::Operation<int16_t, T>(value_.smallint);
1053: 	case LogicalTypeId::INTEGER:
1054: 		return Cast::Operation<int32_t, T>(value_.integer);
1055: 	case LogicalTypeId::BIGINT:
1056: 		return Cast::Operation<int64_t, T>(value_.bigint);
1057: 	case LogicalTypeId::HUGEINT:
1058: 	case LogicalTypeId::UUID:
1059: 		return Cast::Operation<hugeint_t, T>(value_.hugeint);
1060: 	case LogicalTypeId::UHUGEINT:
1061: 		return Cast::Operation<uhugeint_t, T>(value_.uhugeint);
1062: 	case LogicalTypeId::DATE:
1063: 		return Cast::Operation<date_t, T>(value_.date);
1064: 	case LogicalTypeId::TIME:
1065: 		return Cast::Operation<dtime_t, T>(value_.time);
1066: 	case LogicalTypeId::TIME_TZ:
1067: 		return Cast::Operation<dtime_tz_t, T>(value_.timetz);
1068: 	case LogicalTypeId::TIMESTAMP:
1069: 	case LogicalTypeId::TIMESTAMP_TZ:
1070: 		return Cast::Operation<timestamp_t, T>(value_.timestamp);
1071: 	case LogicalTypeId::UTINYINT:
1072: 		return Cast::Operation<uint8_t, T>(value_.utinyint);
1073: 	case LogicalTypeId::USMALLINT:
1074: 		return Cast::Operation<uint16_t, T>(value_.usmallint);
1075: 	case LogicalTypeId::UINTEGER:
1076: 		return Cast::Operation<uint32_t, T>(value_.uinteger);
1077: 	case LogicalTypeId::TIMESTAMP_MS:
1078: 	case LogicalTypeId::TIMESTAMP_NS:
1079: 	case LogicalTypeId::TIMESTAMP_SEC:
1080: 	case LogicalTypeId::UBIGINT:
1081: 		return Cast::Operation<uint64_t, T>(value_.ubigint);
1082: 	case LogicalTypeId::FLOAT:
1083: 		return Cast::Operation<float, T>(value_.float_);
1084: 	case LogicalTypeId::DOUBLE:
1085: 		return Cast::Operation<double, T>(value_.double_);
1086: 	case LogicalTypeId::VARCHAR:
1087: 		return Cast::Operation<string_t, T>(StringValue::Get(*this).c_str());
1088: 	case LogicalTypeId::INTERVAL:
1089: 		return Cast::Operation<interval_t, T>(value_.interval);
1090: 	case LogicalTypeId::DECIMAL:
1091: 		return DefaultCastAs(LogicalType::DOUBLE).GetValueInternal<T>();
1092: 	case LogicalTypeId::ENUM: {
1093: 		switch (type_.InternalType()) {
1094: 		case PhysicalType::UINT8:
1095: 			return Cast::Operation<uint8_t, T>(value_.utinyint);
1096: 		case PhysicalType::UINT16:
1097: 			return Cast::Operation<uint16_t, T>(value_.usmallint);
1098: 		case PhysicalType::UINT32:
1099: 			return Cast::Operation<uint32_t, T>(value_.uinteger);
1100: 		default:
1101: 			throw InternalException("Invalid Internal Type for ENUMs");
1102: 		}
1103: 	}
1104: 	default:
1105: 		throw NotImplementedException("Unimplemented type \"%s\" for GetValue()", type_.ToString());
1106: 	}
1107: }
1108: 
1109: template <>
1110: bool Value::GetValue() const {
1111: 	return GetValueInternal<int8_t>();
1112: }
1113: template <>
1114: int8_t Value::GetValue() const {
1115: 	return GetValueInternal<int8_t>();
1116: }
1117: template <>
1118: int16_t Value::GetValue() const {
1119: 	return GetValueInternal<int16_t>();
1120: }
1121: template <>
1122: int32_t Value::GetValue() const {
1123: 	if (type_.id() == LogicalTypeId::DATE) {
1124: 		return value_.integer;
1125: 	}
1126: 	return GetValueInternal<int32_t>();
1127: }
1128: template <>
1129: int64_t Value::GetValue() const {
1130: 	if (IsNull()) {
1131: 		throw InternalException("Calling GetValue on a value that is NULL");
1132: 	}
1133: 	switch (type_.id()) {
1134: 	case LogicalTypeId::TIMESTAMP:
1135: 	case LogicalTypeId::TIMESTAMP_SEC:
1136: 	case LogicalTypeId::TIMESTAMP_NS:
1137: 	case LogicalTypeId::TIMESTAMP_MS:
1138: 	case LogicalTypeId::TIME:
1139: 	case LogicalTypeId::TIMESTAMP_TZ:
1140: 		return value_.bigint;
1141: 	default:
1142: 		return GetValueInternal<int64_t>();
1143: 	}
1144: }
1145: template <>
1146: hugeint_t Value::GetValue() const {
1147: 	return GetValueInternal<hugeint_t>();
1148: }
1149: template <>
1150: uint8_t Value::GetValue() const {
1151: 	return GetValueInternal<uint8_t>();
1152: }
1153: template <>
1154: uint16_t Value::GetValue() const {
1155: 	return GetValueInternal<uint16_t>();
1156: }
1157: template <>
1158: uint32_t Value::GetValue() const {
1159: 	return GetValueInternal<uint32_t>();
1160: }
1161: template <>
1162: uint64_t Value::GetValue() const {
1163: 	return GetValueInternal<uint64_t>();
1164: }
1165: template <>
1166: uhugeint_t Value::GetValue() const {
1167: 	return GetValueInternal<uhugeint_t>();
1168: }
1169: template <>
1170: string Value::GetValue() const {
1171: 	return ToString();
1172: }
1173: template <>
1174: float Value::GetValue() const {
1175: 	return GetValueInternal<float>();
1176: }
1177: template <>
1178: double Value::GetValue() const {
1179: 	return GetValueInternal<double>();
1180: }
1181: template <>
1182: date_t Value::GetValue() const {
1183: 	return GetValueInternal<date_t>();
1184: }
1185: template <>
1186: dtime_t Value::GetValue() const {
1187: 	return GetValueInternal<dtime_t>();
1188: }
1189: template <>
1190: timestamp_t Value::GetValue() const {
1191: 	return GetValueInternal<timestamp_t>();
1192: }
1193: 
1194: template <>
1195: DUCKDB_API interval_t Value::GetValue() const {
1196: 	return GetValueInternal<interval_t>();
1197: }
1198: 
1199: template <>
1200: DUCKDB_API Value Value::GetValue() const {
1201: 	return Value(*this);
1202: }
1203: 
1204: uintptr_t Value::GetPointer() const {
1205: 	D_ASSERT(type() == LogicalType::POINTER);
1206: 	return value_.pointer;
1207: }
1208: 
1209: Value Value::Numeric(const LogicalType &type, int64_t value) {
1210: 	switch (type.id()) {
1211: 	case LogicalTypeId::BOOLEAN:
1212: 		D_ASSERT(value == 0 || value == 1);
1213: 		return Value::BOOLEAN(value ? 1 : 0);
1214: 	case LogicalTypeId::TINYINT:
1215: 		D_ASSERT(value >= NumericLimits<int8_t>::Minimum() && value <= NumericLimits<int8_t>::Maximum());
1216: 		return Value::TINYINT((int8_t)value);
1217: 	case LogicalTypeId::SMALLINT:
1218: 		D_ASSERT(value >= NumericLimits<int16_t>::Minimum() && value <= NumericLimits<int16_t>::Maximum());
1219: 		return Value::SMALLINT((int16_t)value);
1220: 	case LogicalTypeId::INTEGER:
1221: 		D_ASSERT(value >= NumericLimits<int32_t>::Minimum() && value <= NumericLimits<int32_t>::Maximum());
1222: 		return Value::INTEGER((int32_t)value);
1223: 	case LogicalTypeId::BIGINT:
1224: 		return Value::BIGINT(value);
1225: 	case LogicalTypeId::UTINYINT:
1226: 		D_ASSERT(value >= NumericLimits<uint8_t>::Minimum() && value <= NumericLimits<uint8_t>::Maximum());
1227: 		return Value::UTINYINT((uint8_t)value);
1228: 	case LogicalTypeId::USMALLINT:
1229: 		D_ASSERT(value >= NumericLimits<uint16_t>::Minimum() && value <= NumericLimits<uint16_t>::Maximum());
1230: 		return Value::USMALLINT((uint16_t)value);
1231: 	case LogicalTypeId::UINTEGER:
1232: 		D_ASSERT(value >= NumericLimits<uint32_t>::Minimum() && value <= NumericLimits<uint32_t>::Maximum());
1233: 		return Value::UINTEGER((uint32_t)value);
1234: 	case LogicalTypeId::UBIGINT:
1235: 		D_ASSERT(value >= 0);
1236: 		return Value::UBIGINT(NumericCast<uint64_t>(value));
1237: 	case LogicalTypeId::HUGEINT:
1238: 		return Value::HUGEINT(value);
1239: 	case LogicalTypeId::UHUGEINT:
1240: 		return Value::UHUGEINT(NumericCast<uint64_t>(value));
1241: 	case LogicalTypeId::DECIMAL:
1242: 		return Value::DECIMAL(value, DecimalType::GetWidth(type), DecimalType::GetScale(type));
1243: 	case LogicalTypeId::FLOAT:
1244: 		return Value((float)value);
1245: 	case LogicalTypeId::DOUBLE:
1246: 		return Value((double)value);
1247: 	case LogicalTypeId::POINTER:
1248: 		return Value::POINTER(NumericCast<uintptr_t>(value));
1249: 	case LogicalTypeId::DATE:
1250: 		D_ASSERT(value >= NumericLimits<int32_t>::Minimum() && value <= NumericLimits<int32_t>::Maximum());
1251: 		return Value::DATE(date_t(NumericCast<int32_t>(value)));
1252: 	case LogicalTypeId::TIME:
1253: 		return Value::TIME(dtime_t(value));
1254: 	case LogicalTypeId::TIMESTAMP:
1255: 		return Value::TIMESTAMP(timestamp_t(value));
1256: 	case LogicalTypeId::TIMESTAMP_NS:
1257: 		return Value::TIMESTAMPNS(timestamp_t(value));
1258: 	case LogicalTypeId::TIMESTAMP_MS:
1259: 		return Value::TIMESTAMPMS(timestamp_t(value));
1260: 	case LogicalTypeId::TIMESTAMP_SEC:
1261: 		return Value::TIMESTAMPSEC(timestamp_t(value));
1262: 	case LogicalTypeId::TIMESTAMP_TZ:
1263: 		return Value::TIMESTAMPTZ(timestamp_t(value));
1264: 	case LogicalTypeId::ENUM:
1265: 		switch (type.InternalType()) {
1266: 		case PhysicalType::UINT8:
1267: 			D_ASSERT(value >= NumericLimits<uint8_t>::Minimum() && value <= NumericLimits<uint8_t>::Maximum());
1268: 			return Value::UTINYINT((uint8_t)value);
1269: 		case PhysicalType::UINT16:
1270: 			D_ASSERT(value >= NumericLimits<uint16_t>::Minimum() && value <= NumericLimits<uint16_t>::Maximum());
1271: 			return Value::USMALLINT((uint16_t)value);
1272: 		case PhysicalType::UINT32:
1273: 			D_ASSERT(value >= NumericLimits<uint32_t>::Minimum() && value <= NumericLimits<uint32_t>::Maximum());
1274: 			return Value::UINTEGER((uint32_t)value);
1275: 		default:
1276: 			throw InternalException("Enum doesn't accept this physical type");
1277: 		}
1278: 	default:
1279: 		throw InvalidTypeException(type, "Numeric requires numeric type");
1280: 	}
1281: }
1282: 
1283: Value Value::Numeric(const LogicalType &type, hugeint_t value) {
1284: #ifdef DEBUG
1285: 	// perform a throwing cast to verify that the type fits
1286: 	Value::HUGEINT(value).DefaultCastAs(type);
1287: #endif
1288: 	switch (type.id()) {
1289: 	case LogicalTypeId::HUGEINT:
1290: 		return Value::HUGEINT(value);
1291: 	case LogicalTypeId::UBIGINT:
1292: 		return Value::UBIGINT(Hugeint::Cast<uint64_t>(value));
1293: 	default:
1294: 		return Value::Numeric(type, Hugeint::Cast<int64_t>(value));
1295: 	}
1296: }
1297: 
1298: Value Value::Numeric(const LogicalType &type, uhugeint_t value) {
1299: #ifdef DEBUG
1300: 	// perform a throwing cast to verify that the type fits
1301: 	Value::UHUGEINT(value).DefaultCastAs(type);
1302: #endif
1303: 	switch (type.id()) {
1304: 	case LogicalTypeId::UHUGEINT:
1305: 		return Value::UHUGEINT(value);
1306: 	case LogicalTypeId::UBIGINT:
1307: 		return Value::UBIGINT(Uhugeint::Cast<uint64_t>(value));
1308: 	default:
1309: 		return Value::Numeric(type, Uhugeint::Cast<int64_t>(value));
1310: 	}
1311: }
1312: 
1313: //===--------------------------------------------------------------------===//
1314: // GetValueUnsafe
1315: //===--------------------------------------------------------------------===//
1316: template <>
1317: DUCKDB_API bool Value::GetValueUnsafe() const {
1318: 	D_ASSERT(type_.InternalType() == PhysicalType::BOOL);
1319: 	return value_.boolean;
1320: }
1321: 
1322: template <>
1323: int8_t Value::GetValueUnsafe() const {
1324: 	D_ASSERT(type_.InternalType() == PhysicalType::INT8 || type_.InternalType() == PhysicalType::BOOL);
1325: 	return value_.tinyint;
1326: }
1327: 
1328: template <>
1329: int16_t Value::GetValueUnsafe() const {
1330: 	D_ASSERT(type_.InternalType() == PhysicalType::INT16);
1331: 	return value_.smallint;
1332: }
1333: 
1334: template <>
1335: int32_t Value::GetValueUnsafe() const {
1336: 	D_ASSERT(type_.InternalType() == PhysicalType::INT32);
1337: 	return value_.integer;
1338: }
1339: 
1340: template <>
1341: int64_t Value::GetValueUnsafe() const {
1342: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1343: 	return value_.bigint;
1344: }
1345: 
1346: template <>
1347: hugeint_t Value::GetValueUnsafe() const {
1348: 	D_ASSERT(type_.InternalType() == PhysicalType::INT128);
1349: 	return value_.hugeint;
1350: }
1351: 
1352: template <>
1353: uint8_t Value::GetValueUnsafe() const {
1354: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT8);
1355: 	return value_.utinyint;
1356: }
1357: 
1358: template <>
1359: uint16_t Value::GetValueUnsafe() const {
1360: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT16);
1361: 	return value_.usmallint;
1362: }
1363: 
1364: template <>
1365: uint32_t Value::GetValueUnsafe() const {
1366: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT32);
1367: 	return value_.uinteger;
1368: }
1369: 
1370: template <>
1371: uint64_t Value::GetValueUnsafe() const {
1372: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT64);
1373: 	return value_.ubigint;
1374: }
1375: 
1376: template <>
1377: uhugeint_t Value::GetValueUnsafe() const {
1378: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT128);
1379: 	return value_.uhugeint;
1380: }
1381: 
1382: template <>
1383: string Value::GetValueUnsafe() const {
1384: 	return StringValue::Get(*this);
1385: }
1386: 
1387: template <>
1388: DUCKDB_API string_t Value::GetValueUnsafe() const {
1389: 	return string_t(StringValue::Get(*this));
1390: }
1391: 
1392: template <>
1393: float Value::GetValueUnsafe() const {
1394: 	D_ASSERT(type_.InternalType() == PhysicalType::FLOAT);
1395: 	return value_.float_;
1396: }
1397: 
1398: template <>
1399: double Value::GetValueUnsafe() const {
1400: 	D_ASSERT(type_.InternalType() == PhysicalType::DOUBLE);
1401: 	return value_.double_;
1402: }
1403: 
1404: template <>
1405: date_t Value::GetValueUnsafe() const {
1406: 	D_ASSERT(type_.InternalType() == PhysicalType::INT32);
1407: 	return value_.date;
1408: }
1409: 
1410: template <>
1411: dtime_t Value::GetValueUnsafe() const {
1412: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1413: 	return value_.time;
1414: }
1415: 
1416: template <>
1417: dtime_tz_t Value::GetValueUnsafe() const {
1418: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1419: 	return value_.timetz;
1420: }
1421: 
1422: template <>
1423: timestamp_t Value::GetValueUnsafe() const {
1424: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1425: 	return value_.timestamp;
1426: }
1427: 
1428: template <>
1429: interval_t Value::GetValueUnsafe() const {
1430: 	D_ASSERT(type_.InternalType() == PhysicalType::INTERVAL);
1431: 	return value_.interval;
1432: }
1433: 
1434: //===--------------------------------------------------------------------===//
1435: // Hash
1436: //===--------------------------------------------------------------------===//
1437: hash_t Value::Hash() const {
1438: 	if (IsNull()) {
1439: 		return 0;
1440: 	}
1441: 	Vector input(*this);
1442: 	Vector result(LogicalType::HASH);
1443: 	VectorOperations::Hash(input, result, 1);
1444: 
1445: 	auto data = FlatVector::GetData<hash_t>(result);
1446: 	return data[0];
1447: }
1448: 
1449: string Value::ToString() const {
1450: 	if (IsNull()) {
1451: 		return "NULL";
1452: 	}
1453: 	return StringValue::Get(DefaultCastAs(LogicalType::VARCHAR));
1454: }
1455: 
1456: string Value::ToSQLString() const {
1457: 	if (IsNull()) {
1458: 		return ToString();
1459: 	}
1460: 	switch (type_.id()) {
1461: 	case LogicalTypeId::UUID:
1462: 	case LogicalTypeId::DATE:
1463: 	case LogicalTypeId::TIME:
1464: 	case LogicalTypeId::TIMESTAMP:
1465: 	case LogicalTypeId::TIME_TZ:
1466: 	case LogicalTypeId::TIMESTAMP_TZ:
1467: 	case LogicalTypeId::TIMESTAMP_SEC:
1468: 	case LogicalTypeId::TIMESTAMP_MS:
1469: 	case LogicalTypeId::TIMESTAMP_NS:
1470: 	case LogicalTypeId::INTERVAL:
1471: 	case LogicalTypeId::BLOB:
1472: 		return "'" + ToString() + "'::" + type_.ToString();
1473: 	case LogicalTypeId::VARCHAR:
1474: 	case LogicalTypeId::ENUM:
1475: 		return "'" + StringUtil::Replace(ToString(), "'", "''") + "'";
1476: 	case LogicalTypeId::STRUCT: {
1477: 		bool is_unnamed = StructType::IsUnnamed(type_);
1478: 		string ret = is_unnamed ? "(" : "{";
1479: 		auto &child_types = StructType::GetChildTypes(type_);
1480: 		auto &struct_values = StructValue::GetChildren(*this);
1481: 		for (idx_t i = 0; i < struct_values.size(); i++) {
1482: 			auto &name = child_types[i].first;
1483: 			auto &child = struct_values[i];
1484: 			if (is_unnamed) {
1485: 				ret += child.ToSQLString();
1486: 			} else {
1487: 				ret += "'" + name + "': " + child.ToSQLString();
1488: 			}
1489: 			if (i < struct_values.size() - 1) {
1490: 				ret += ", ";
1491: 			}
1492: 		}
1493: 		ret += is_unnamed ? ")" : "}";
1494: 		return ret;
1495: 	}
1496: 	case LogicalTypeId::FLOAT:
1497: 		if (!FloatIsFinite(FloatValue::Get(*this))) {
1498: 			return "'" + ToString() + "'::" + type_.ToString();
1499: 		}
1500: 		return ToString();
1501: 	case LogicalTypeId::DOUBLE: {
1502: 		double val = DoubleValue::Get(*this);
1503: 		if (!DoubleIsFinite(val)) {
1504: 			if (!Value::IsNan(val)) {
1505: 				// to infinity and beyond
1506: 				return val < 0 ? "-1e1000" : "1e1000";
1507: 			}
1508: 			return "'" + ToString() + "'::" + type_.ToString();
1509: 		}
1510: 		return ToString();
1511: 	}
1512: 	case LogicalTypeId::LIST: {
1513: 		string ret = "[";
1514: 		auto &list_values = ListValue::GetChildren(*this);
1515: 		for (idx_t i = 0; i < list_values.size(); i++) {
1516: 			auto &child = list_values[i];
1517: 			ret += child.ToSQLString();
1518: 			if (i < list_values.size() - 1) {
1519: 				ret += ", ";
1520: 			}
1521: 		}
1522: 		ret += "]";
1523: 		return ret;
1524: 	}
1525: 	case LogicalTypeId::ARRAY: {
1526: 		string ret = "[";
1527: 		auto &array_values = ArrayValue::GetChildren(*this);
1528: 		for (idx_t i = 0; i < array_values.size(); i++) {
1529: 			auto &child = array_values[i];
1530: 			ret += child.ToSQLString();
1531: 			if (i < array_values.size() - 1) {
1532: 				ret += ", ";
1533: 			}
1534: 		}
1535: 		ret += "]";
1536: 		return ret;
1537: 	}
1538: 	default:
1539: 		return ToString();
1540: 	}
1541: }
1542: 
1543: //===--------------------------------------------------------------------===//
1544: // Type-specific getters
1545: //===--------------------------------------------------------------------===//
1546: bool BooleanValue::Get(const Value &value) {
1547: 	return value.GetValueUnsafe<bool>();
1548: }
1549: 
1550: int8_t TinyIntValue::Get(const Value &value) {
1551: 	return value.GetValueUnsafe<int8_t>();
1552: }
1553: 
1554: int16_t SmallIntValue::Get(const Value &value) {
1555: 	return value.GetValueUnsafe<int16_t>();
1556: }
1557: 
1558: int32_t IntegerValue::Get(const Value &value) {
1559: 	return value.GetValueUnsafe<int32_t>();
1560: }
1561: 
1562: int64_t BigIntValue::Get(const Value &value) {
1563: 	return value.GetValueUnsafe<int64_t>();
1564: }
1565: 
1566: hugeint_t HugeIntValue::Get(const Value &value) {
1567: 	return value.GetValueUnsafe<hugeint_t>();
1568: }
1569: 
1570: uint8_t UTinyIntValue::Get(const Value &value) {
1571: 	return value.GetValueUnsafe<uint8_t>();
1572: }
1573: 
1574: uint16_t USmallIntValue::Get(const Value &value) {
1575: 	return value.GetValueUnsafe<uint16_t>();
1576: }
1577: 
1578: uint32_t UIntegerValue::Get(const Value &value) {
1579: 	return value.GetValueUnsafe<uint32_t>();
1580: }
1581: 
1582: uint64_t UBigIntValue::Get(const Value &value) {
1583: 	return value.GetValueUnsafe<uint64_t>();
1584: }
1585: 
1586: uhugeint_t UhugeIntValue::Get(const Value &value) {
1587: 	return value.GetValueUnsafe<uhugeint_t>();
1588: }
1589: 
1590: float FloatValue::Get(const Value &value) {
1591: 	return value.GetValueUnsafe<float>();
1592: }
1593: 
1594: double DoubleValue::Get(const Value &value) {
1595: 	return value.GetValueUnsafe<double>();
1596: }
1597: 
1598: const string &StringValue::Get(const Value &value) {
1599: 	if (value.is_null) {
1600: 		throw InternalException("Calling StringValue::Get on a NULL value");
1601: 	}
1602: 	D_ASSERT(value.type().InternalType() == PhysicalType::VARCHAR);
1603: 	D_ASSERT(value.value_info_);
1604: 	return value.value_info_->Get<StringValueInfo>().GetString();
1605: }
1606: 
1607: date_t DateValue::Get(const Value &value) {
1608: 	return value.GetValueUnsafe<date_t>();
1609: }
1610: 
1611: dtime_t TimeValue::Get(const Value &value) {
1612: 	return value.GetValueUnsafe<dtime_t>();
1613: }
1614: 
1615: timestamp_t TimestampValue::Get(const Value &value) {
1616: 	return value.GetValueUnsafe<timestamp_t>();
1617: }
1618: 
1619: interval_t IntervalValue::Get(const Value &value) {
1620: 	return value.GetValueUnsafe<interval_t>();
1621: }
1622: 
1623: const vector<Value> &StructValue::GetChildren(const Value &value) {
1624: 	if (value.is_null) {
1625: 		throw InternalException("Calling StructValue::GetChildren on a NULL value");
1626: 	}
1627: 	D_ASSERT(value.type().InternalType() == PhysicalType::STRUCT);
1628: 	D_ASSERT(value.value_info_);
1629: 	return value.value_info_->Get<NestedValueInfo>().GetValues();
1630: }
1631: 
1632: const vector<Value> &ListValue::GetChildren(const Value &value) {
1633: 	if (value.is_null) {
1634: 		throw InternalException("Calling ListValue::GetChildren on a NULL value");
1635: 	}
1636: 	D_ASSERT(value.type().InternalType() == PhysicalType::LIST);
1637: 	D_ASSERT(value.value_info_);
1638: 	return value.value_info_->Get<NestedValueInfo>().GetValues();
1639: }
1640: 
1641: const vector<Value> &ArrayValue::GetChildren(const Value &value) {
1642: 	if (value.is_null) {
1643: 		throw InternalException("Calling ArrayValue::GetChildren on a NULL value");
1644: 	}
1645: 	D_ASSERT(value.type().InternalType() == PhysicalType::ARRAY);
1646: 	D_ASSERT(value.value_info_);
1647: 	return value.value_info_->Get<NestedValueInfo>().GetValues();
1648: }
1649: 
1650: const Value &UnionValue::GetValue(const Value &value) {
1651: 	D_ASSERT(value.type().id() == LogicalTypeId::UNION);
1652: 	auto &children = StructValue::GetChildren(value);
1653: 	auto tag = children[0].GetValueUnsafe<union_tag_t>();
1654: 	D_ASSERT(tag < children.size() - 1);
1655: 	return children[tag + 1];
1656: }
1657: 
1658: union_tag_t UnionValue::GetTag(const Value &value) {
1659: 	D_ASSERT(value.type().id() == LogicalTypeId::UNION);
1660: 	auto children = StructValue::GetChildren(value);
1661: 	auto tag = children[0].GetValueUnsafe<union_tag_t>();
1662: 	D_ASSERT(tag < children.size() - 1);
1663: 	return tag;
1664: }
1665: 
1666: const LogicalType &UnionValue::GetType(const Value &value) {
1667: 	return UnionType::GetMemberType(value.type(), UnionValue::GetTag(value));
1668: }
1669: 
1670: hugeint_t IntegralValue::Get(const Value &value) {
1671: 	switch (value.type().InternalType()) {
1672: 	case PhysicalType::INT8:
1673: 		return TinyIntValue::Get(value);
1674: 	case PhysicalType::INT16:
1675: 		return SmallIntValue::Get(value);
1676: 	case PhysicalType::INT32:
1677: 		return IntegerValue::Get(value);
1678: 	case PhysicalType::INT64:
1679: 		return BigIntValue::Get(value);
1680: 	case PhysicalType::INT128:
1681: 		return HugeIntValue::Get(value);
1682: 	case PhysicalType::UINT8:
1683: 		return UTinyIntValue::Get(value);
1684: 	case PhysicalType::UINT16:
1685: 		return USmallIntValue::Get(value);
1686: 	case PhysicalType::UINT32:
1687: 		return UIntegerValue::Get(value);
1688: 	case PhysicalType::UINT64:
1689: 		return NumericCast<int64_t>(UBigIntValue::Get(value));
1690: 	case PhysicalType::UINT128:
1691: 		return static_cast<hugeint_t>(UhugeIntValue::Get(value));
1692: 	default:
1693: 		throw InternalException("Invalid internal type \"%s\" for IntegralValue::Get", value.type().ToString());
1694: 	}
1695: }
1696: 
1697: //===--------------------------------------------------------------------===//
1698: // Comparison Operators
1699: //===--------------------------------------------------------------------===//
1700: bool Value::operator==(const Value &rhs) const {
1701: 	return ValueOperations::Equals(*this, rhs);
1702: }
1703: 
1704: bool Value::operator!=(const Value &rhs) const {
1705: 	return ValueOperations::NotEquals(*this, rhs);
1706: }
1707: 
1708: bool Value::operator<(const Value &rhs) const {
1709: 	return ValueOperations::LessThan(*this, rhs);
1710: }
1711: 
1712: bool Value::operator>(const Value &rhs) const {
1713: 	return ValueOperations::GreaterThan(*this, rhs);
1714: }
1715: 
1716: bool Value::operator<=(const Value &rhs) const {
1717: 	return ValueOperations::LessThanEquals(*this, rhs);
1718: }
1719: 
1720: bool Value::operator>=(const Value &rhs) const {
1721: 	return ValueOperations::GreaterThanEquals(*this, rhs);
1722: }
1723: 
1724: bool Value::operator==(const int64_t &rhs) const {
1725: 	return *this == Value::Numeric(type_, rhs);
1726: }
1727: 
1728: bool Value::operator!=(const int64_t &rhs) const {
1729: 	return *this != Value::Numeric(type_, rhs);
1730: }
1731: 
1732: bool Value::operator<(const int64_t &rhs) const {
1733: 	return *this < Value::Numeric(type_, rhs);
1734: }
1735: 
1736: bool Value::operator>(const int64_t &rhs) const {
1737: 	return *this > Value::Numeric(type_, rhs);
1738: }
1739: 
1740: bool Value::operator<=(const int64_t &rhs) const {
1741: 	return *this <= Value::Numeric(type_, rhs);
1742: }
1743: 
1744: bool Value::operator>=(const int64_t &rhs) const {
1745: 	return *this >= Value::Numeric(type_, rhs);
1746: }
1747: 
1748: bool Value::TryCastAs(CastFunctionSet &set, GetCastFunctionInput &get_input, const LogicalType &target_type,
1749:                       Value &new_value, string *error_message, bool strict) const {
1750: 	if (type_ == target_type) {
1751: 		new_value = Copy();
1752: 		return true;
1753: 	}
1754: 	Vector input(*this);
1755: 	Vector result(target_type);
1756: 	if (!VectorOperations::TryCast(set, get_input, input, result, 1, error_message, strict)) {
1757: 		return false;
1758: 	}
1759: 	new_value = result.GetValue(0);
1760: 	return true;
1761: }
1762: 
1763: bool Value::TryCastAs(ClientContext &context, const LogicalType &target_type, Value &new_value, string *error_message,
1764:                       bool strict) const {
1765: 	GetCastFunctionInput get_input(context);
1766: 	return TryCastAs(CastFunctionSet::Get(context), get_input, target_type, new_value, error_message, strict);
1767: }
1768: 
1769: bool Value::DefaultTryCastAs(const LogicalType &target_type, Value &new_value, string *error_message,
1770:                              bool strict) const {
1771: 	CastFunctionSet set;
1772: 	GetCastFunctionInput get_input;
1773: 	return TryCastAs(set, get_input, target_type, new_value, error_message, strict);
1774: }
1775: 
1776: Value Value::CastAs(CastFunctionSet &set, GetCastFunctionInput &get_input, const LogicalType &target_type,
1777:                     bool strict) const {
1778: 	Value new_value;
1779: 	string error_message;
1780: 	if (!TryCastAs(set, get_input, target_type, new_value, &error_message, strict)) {
1781: 		throw InvalidInputException("Failed to cast value: %s", error_message);
1782: 	}
1783: 	return new_value;
1784: }
1785: 
1786: Value Value::CastAs(ClientContext &context, const LogicalType &target_type, bool strict) const {
1787: 	GetCastFunctionInput get_input(context);
1788: 	return CastAs(CastFunctionSet::Get(context), get_input, target_type, strict);
1789: }
1790: 
1791: Value Value::DefaultCastAs(const LogicalType &target_type, bool strict) const {
1792: 	CastFunctionSet set;
1793: 	GetCastFunctionInput get_input;
1794: 	return CastAs(set, get_input, target_type, strict);
1795: }
1796: 
1797: bool Value::TryCastAs(CastFunctionSet &set, GetCastFunctionInput &get_input, const LogicalType &target_type,
1798:                       bool strict) {
1799: 	Value new_value;
1800: 	string error_message;
1801: 	if (!TryCastAs(set, get_input, target_type, new_value, &error_message, strict)) {
1802: 		return false;
1803: 	}
1804: 	type_ = target_type;
1805: 	is_null = new_value.is_null;
1806: 	value_ = new_value.value_;
1807: 	value_info_ = std::move(new_value.value_info_);
1808: 	return true;
1809: }
1810: 
1811: bool Value::TryCastAs(ClientContext &context, const LogicalType &target_type, bool strict) {
1812: 	GetCastFunctionInput get_input(context);
1813: 	return TryCastAs(CastFunctionSet::Get(context), get_input, target_type, strict);
1814: }
1815: 
1816: bool Value::DefaultTryCastAs(const LogicalType &target_type, bool strict) {
1817: 	CastFunctionSet set;
1818: 	GetCastFunctionInput get_input;
1819: 	return TryCastAs(set, get_input, target_type, strict);
1820: }
1821: 
1822: void Value::Reinterpret(LogicalType new_type) {
1823: 	this->type_ = std::move(new_type);
1824: }
1825: 
1826: void Value::Serialize(Serializer &serializer) const {
1827: 	serializer.WriteProperty(100, "type", type_);
1828: 	serializer.WriteProperty(101, "is_null", is_null);
1829: 	if (!IsNull()) {
1830: 		switch (type_.InternalType()) {
1831: 		case PhysicalType::BIT:
1832: 			throw InternalException("BIT type should not be serialized");
1833: 		case PhysicalType::BOOL:
1834: 			serializer.WriteProperty(102, "value", value_.boolean);
1835: 			break;
1836: 		case PhysicalType::INT8:
1837: 			serializer.WriteProperty(102, "value", value_.tinyint);
1838: 			break;
1839: 		case PhysicalType::INT16:
1840: 			serializer.WriteProperty(102, "value", value_.smallint);
1841: 			break;
1842: 		case PhysicalType::INT32:
1843: 			serializer.WriteProperty(102, "value", value_.integer);
1844: 			break;
1845: 		case PhysicalType::INT64:
1846: 			serializer.WriteProperty(102, "value", value_.bigint);
1847: 			break;
1848: 		case PhysicalType::UINT8:
1849: 			serializer.WriteProperty(102, "value", value_.utinyint);
1850: 			break;
1851: 		case PhysicalType::UINT16:
1852: 			serializer.WriteProperty(102, "value", value_.usmallint);
1853: 			break;
1854: 		case PhysicalType::UINT32:
1855: 			serializer.WriteProperty(102, "value", value_.uinteger);
1856: 			break;
1857: 		case PhysicalType::UINT64:
1858: 			serializer.WriteProperty(102, "value", value_.ubigint);
1859: 			break;
1860: 		case PhysicalType::INT128:
1861: 			serializer.WriteProperty(102, "value", value_.hugeint);
1862: 			break;
1863: 		case PhysicalType::UINT128:
1864: 			serializer.WriteProperty(102, "value", value_.uhugeint);
1865: 			break;
1866: 		case PhysicalType::FLOAT:
1867: 			serializer.WriteProperty(102, "value", value_.float_);
1868: 			break;
1869: 		case PhysicalType::DOUBLE:
1870: 			serializer.WriteProperty(102, "value", value_.double_);
1871: 			break;
1872: 		case PhysicalType::INTERVAL:
1873: 			serializer.WriteProperty(102, "value", value_.interval);
1874: 			break;
1875: 		case PhysicalType::VARCHAR: {
1876: 			if (type_.id() == LogicalTypeId::BLOB) {
1877: 				auto blob_str = Blob::ToString(StringValue::Get(*this));
1878: 				serializer.WriteProperty(102, "value", blob_str);
1879: 			} else {
1880: 				serializer.WriteProperty(102, "value", StringValue::Get(*this));
1881: 			}
1882: 		} break;
1883: 		case PhysicalType::LIST: {
1884: 			serializer.WriteObject(102, "value", [&](Serializer &serializer) {
1885: 				auto &children = ListValue::GetChildren(*this);
1886: 				serializer.WriteProperty(100, "children", children);
1887: 			});
1888: 		} break;
1889: 		case PhysicalType::STRUCT: {
1890: 			serializer.WriteObject(102, "value", [&](Serializer &serializer) {
1891: 				auto &children = StructValue::GetChildren(*this);
1892: 				serializer.WriteProperty(100, "children", children);
1893: 			});
1894: 		} break;
1895: 		case PhysicalType::ARRAY: {
1896: 			serializer.WriteObject(102, "value", [&](Serializer &serializer) {
1897: 				auto &children = ArrayValue::GetChildren(*this);
1898: 				serializer.WriteProperty(100, "children", children);
1899: 			});
1900: 		} break;
1901: 		default:
1902: 			throw NotImplementedException("Unimplemented type for Serialize");
1903: 		}
1904: 	}
1905: }
1906: 
1907: Value Value::Deserialize(Deserializer &deserializer) {
1908: 	auto type = deserializer.ReadProperty<LogicalType>(100, "type");
1909: 	auto is_null = deserializer.ReadProperty<bool>(101, "is_null");
1910: 	Value new_value = Value(type);
1911: 	if (is_null) {
1912: 		return new_value;
1913: 	}
1914: 	new_value.is_null = false;
1915: 	switch (type.InternalType()) {
1916: 	case PhysicalType::BIT:
1917: 		throw InternalException("BIT type should not be deserialized");
1918: 	case PhysicalType::BOOL:
1919: 		new_value.value_.boolean = deserializer.ReadProperty<bool>(102, "value");
1920: 		break;
1921: 	case PhysicalType::UINT8:
1922: 		new_value.value_.utinyint = deserializer.ReadProperty<uint8_t>(102, "value");
1923: 		break;
1924: 	case PhysicalType::INT8:
1925: 		new_value.value_.tinyint = deserializer.ReadProperty<int8_t>(102, "value");
1926: 		break;
1927: 	case PhysicalType::UINT16:
1928: 		new_value.value_.usmallint = deserializer.ReadProperty<uint16_t>(102, "value");
1929: 		break;
1930: 	case PhysicalType::INT16:
1931: 		new_value.value_.smallint = deserializer.ReadProperty<int16_t>(102, "value");
1932: 		break;
1933: 	case PhysicalType::UINT32:
1934: 		new_value.value_.uinteger = deserializer.ReadProperty<uint32_t>(102, "value");
1935: 		break;
1936: 	case PhysicalType::INT32:
1937: 		new_value.value_.integer = deserializer.ReadProperty<int32_t>(102, "value");
1938: 		break;
1939: 	case PhysicalType::UINT64:
1940: 		new_value.value_.ubigint = deserializer.ReadProperty<uint64_t>(102, "value");
1941: 		break;
1942: 	case PhysicalType::INT64:
1943: 		new_value.value_.bigint = deserializer.ReadProperty<int64_t>(102, "value");
1944: 		break;
1945: 	case PhysicalType::UINT128:
1946: 		new_value.value_.uhugeint = deserializer.ReadProperty<uhugeint_t>(102, "value");
1947: 		break;
1948: 	case PhysicalType::INT128:
1949: 		new_value.value_.hugeint = deserializer.ReadProperty<hugeint_t>(102, "value");
1950: 		break;
1951: 	case PhysicalType::FLOAT:
1952: 		new_value.value_.float_ = deserializer.ReadProperty<float>(102, "value");
1953: 		break;
1954: 	case PhysicalType::DOUBLE:
1955: 		new_value.value_.double_ = deserializer.ReadProperty<double>(102, "value");
1956: 		break;
1957: 	case PhysicalType::INTERVAL:
1958: 		new_value.value_.interval = deserializer.ReadProperty<interval_t>(102, "value");
1959: 		break;
1960: 	case PhysicalType::VARCHAR: {
1961: 		auto str = deserializer.ReadProperty<string>(102, "value");
1962: 		if (type.id() == LogicalTypeId::BLOB) {
1963: 			new_value.value_info_ = make_shared_ptr<StringValueInfo>(Blob::ToBlob(str));
1964: 		} else {
1965: 			new_value.value_info_ = make_shared_ptr<StringValueInfo>(str);
1966: 		}
1967: 	} break;
1968: 	case PhysicalType::LIST: {
1969: 		deserializer.ReadObject(102, "value", [&](Deserializer &obj) {
1970: 			auto children = obj.ReadProperty<vector<Value>>(100, "children");
1971: 			new_value.value_info_ = make_shared_ptr<NestedValueInfo>(children);
1972: 		});
1973: 	} break;
1974: 	case PhysicalType::STRUCT: {
1975: 		deserializer.ReadObject(102, "value", [&](Deserializer &obj) {
1976: 			auto children = obj.ReadProperty<vector<Value>>(100, "children");
1977: 			new_value.value_info_ = make_shared_ptr<NestedValueInfo>(children);
1978: 		});
1979: 	} break;
1980: 	case PhysicalType::ARRAY: {
1981: 		deserializer.ReadObject(102, "value", [&](Deserializer &obj) {
1982: 			auto children = obj.ReadProperty<vector<Value>>(100, "children");
1983: 			new_value.value_info_ = make_shared_ptr<NestedValueInfo>(children);
1984: 		});
1985: 	} break;
1986: 	default:
1987: 		throw NotImplementedException("Unimplemented type for Deserialize");
1988: 	}
1989: 	return new_value;
1990: }
1991: 
1992: void Value::Print() const {
1993: 	Printer::Print(ToString());
1994: }
1995: 
1996: bool Value::NotDistinctFrom(const Value &lvalue, const Value &rvalue) {
1997: 	return ValueOperations::NotDistinctFrom(lvalue, rvalue);
1998: }
1999: 
2000: static string SanitizeValue(string input) {
2001: 	// some results might contain padding spaces, e.g. when rendering
2002: 	// VARCHAR(10) and the string only has 6 characters, they will be padded
2003: 	// with spaces to 10 in the rendering. We don't do that here yet as we
2004: 	// are looking at internal structures. So just ignore any extra spaces
2005: 	// on the right
2006: 	StringUtil::RTrim(input);
2007: 	// for result checking code, replace null bytes with their escaped value (\0)
2008: 	return StringUtil::Replace(input, string("\0", 1), "\\0");
2009: }
2010: 
2011: bool Value::ValuesAreEqual(CastFunctionSet &set, GetCastFunctionInput &get_input, const Value &result_value,
2012:                            const Value &value) {
2013: 	if (result_value.IsNull() != value.IsNull()) {
2014: 		return false;
2015: 	}
2016: 	if (result_value.IsNull() && value.IsNull()) {
2017: 		// NULL = NULL in checking code
2018: 		return true;
2019: 	}
2020: 	switch (value.type_.id()) {
2021: 	case LogicalTypeId::FLOAT: {
2022: 		auto other = result_value.CastAs(set, get_input, LogicalType::FLOAT);
2023: 		float ldecimal = value.value_.float_;
2024: 		float rdecimal = other.value_.float_;
2025: 		return ApproxEqual(ldecimal, rdecimal);
2026: 	}
2027: 	case LogicalTypeId::DOUBLE: {
2028: 		auto other = result_value.CastAs(set, get_input, LogicalType::DOUBLE);
2029: 		double ldecimal = value.value_.double_;
2030: 		double rdecimal = other.value_.double_;
2031: 		return ApproxEqual(ldecimal, rdecimal);
2032: 	}
2033: 	case LogicalTypeId::VARCHAR: {
2034: 		auto other = result_value.CastAs(set, get_input, LogicalType::VARCHAR);
2035: 		string left = SanitizeValue(StringValue::Get(other));
2036: 		string right = SanitizeValue(StringValue::Get(value));
2037: 		return left == right;
2038: 	}
2039: 	default:
2040: 		if (result_value.type_.id() == LogicalTypeId::FLOAT || result_value.type_.id() == LogicalTypeId::DOUBLE) {
2041: 			return Value::ValuesAreEqual(set, get_input, value, result_value);
2042: 		}
2043: 		return value == result_value;
2044: 	}
2045: }
2046: 
2047: bool Value::ValuesAreEqual(ClientContext &context, const Value &result_value, const Value &value) {
2048: 	GetCastFunctionInput get_input(context);
2049: 	return Value::ValuesAreEqual(CastFunctionSet::Get(context), get_input, result_value, value);
2050: }
2051: bool Value::DefaultValuesAreEqual(const Value &result_value, const Value &value) {
2052: 	CastFunctionSet set;
2053: 	GetCastFunctionInput get_input;
2054: 	return Value::ValuesAreEqual(set, get_input, result_value, value);
2055: }
2056: 
2057: } // namespace duckdb
[end of src/common/types/value.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: