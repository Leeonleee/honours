{
  "repo": "duckdb/duckdb",
  "pull_number": 12370,
  "instance_id": "duckdb__duckdb-12370",
  "issue_numbers": [
    "12364"
  ],
  "base_commit": "e1d4ea395627d087c5f025df86dc1dae00e94e9e",
  "patch": "diff --git a/src/common/types/value.cpp b/src/common/types/value.cpp\nindex 9fae9858d285..999a17b35f13 100644\n--- a/src/common/types/value.cpp\n+++ b/src/common/types/value.cpp\n@@ -346,8 +346,10 @@ Value Value::MaximumValue(const LogicalType &type) {\n \t\t\tthrow InternalException(\"Unknown decimal type\");\n \t\t}\n \t}\n-\tcase LogicalTypeId::ENUM:\n-\t\treturn Value::ENUM(EnumType::GetSize(type) - 1, type);\n+\tcase LogicalTypeId::ENUM: {\n+\t\tauto enum_size = EnumType::GetSize(type);\n+\t\treturn Value::ENUM(enum_size - (enum_size ? 1 : 0), type);\n+\t}\n \tdefault:\n \t\tthrow InvalidTypeException(type, \"MaximumValue requires numeric type\");\n \t}\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py b/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py\nindex 848412a99108..59e28c907bd9 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_pandas_category.py\n@@ -104,6 +104,18 @@ def test_category_string_uint8(self, duckdb_cursor):\n             category.append(str(i))\n         check_create_table(category)\n \n+    def test_empty_categorical(self, duckdb_cursor):\n+        empty_categoric_df = pd.DataFrame({'category': pd.Series(dtype='category')})\n+        duckdb_cursor.execute(\"CREATE TABLE test AS SELECT * FROM empty_categoric_df\")\n+        res = duckdb_cursor.table('test').fetchall()\n+        assert res == []\n+\n+        with pytest.raises(duckdb.ConversionException, match=\"Could not convert string 'test' to UINT8\"):\n+            duckdb_cursor.execute(\"insert into test VALUES('test')\")\n+        duckdb_cursor.execute(\"insert into test VALUES(NULL)\")\n+        res = duckdb_cursor.table('test').fetchall()\n+        assert res == [(None,)]\n+\n     def test_category_fetch_df_chunk(self, duckdb_cursor):\n         con = duckdb.connect()\n         categories = ['foo', 'bla', None, 'zoo', 'foo', 'foo', None, 'bla']\n",
  "problem_statement": "DuckDB throws InternalError when creating a table from an empty DataFrame with a categoric column\n### What happens?\n\nI received an inscrutable internal error from DuckDb under certain conditions in my app;\r\n```\r\ncon.execute(\"CREATE TABLE test AS SELECT * FROM empty_categoric_df\")\r\nduckdb.duckdb.InternalException: INTERNAL Error: Information loss on integer cast: value -1 outside of target range [0, 255]\r\n```\r\n\r\nUpon digging, and paring back details of my use case I found that the cause was when creating a table from an empty pandas DataFrame which included a categoric column.\r\n\r\nI understand this may be a bit of an invalid edge case, but a more intelligible error message would have made it easier to debug.\n\n### To Reproduce\n\nReproduction script:\r\n\r\n```\r\nimport pandas as pd\r\nimport duckdb\r\n\r\ncon = duckdb.connect()\r\n\r\ndata = {'category': pd.Categorical(['A', 'B', 'C'])}\r\npopulated_categoric_df = pd.DataFrame(data)\r\n\r\ncon.execute(\"CREATE TABLE test AS SELECT * FROM populated_categoric_df\")\r\n\r\nempty_categoric_df = pd.DataFrame({'category': pd.Series(dtype='category')})\r\n\r\nprint(empty_categoric_df)\r\nprint(empty_categoric_df.dtypes)\r\nprint(empty_categoric_df['category'].cat.categories)\r\nprint(empty_categoric_df['category'].cat.codes)\r\n\r\ncon.execute(\"CREATE TABLE test AS SELECT * FROM empty_categoric_df\")\r\n```\r\n\r\nThe former case works, of course, the latter throws the error.\r\n\r\nOutput from the above reproduction script:\r\n```\r\nEmpty DataFrame\r\nColumns: [category]\r\nIndex: []\r\ncategory    category\r\ndtype: object\r\nIndex([], dtype='object')\r\nSeries([], dtype: int8)\r\nTraceback (most recent call last):\r\n  File <redacted>, line 18, in <module>\r\n    con.execute(\"CREATE TABLE test AS SELECT * FROM empty_categoric_df\")\r\nduckdb.duckdb.InternalException: INTERNAL Error: Information loss on integer cast: value -1 outside of target range [0, 255]\r\nThis error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.\r\nFor more information, see https://duckdb.org/docs/dev/internal_errors\r\n```\n\n### OS:\n\nlinux/amd64\n\n### DuckDB Version:\n\n1.0.0\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nSimon Grant\n\n### Affiliation:\n\nn/a\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "My workaround for the issue:\r\n\r\n```\r\n            for col in df.select_dtypes(include='category').columns:\r\n                if df[col].isna().all():\r\n                    df[col] = df[col].astype(str)\r\n            connection.sql(f\"CREATE TABLE {name} AS SELECT * FROM df\")\r\n```\nThanks for the report\r\n\r\nJust out of curiosity, what is the use case of this? This would create an ENUM with no entries, which isn't particularly useful.\r\nThe fix will likely be to disallow this and throw a non-fatal exception instead",
  "created_at": "2024-06-04T08:42:23Z"
}