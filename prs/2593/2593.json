{
  "repo": "duckdb/duckdb",
  "pull_number": 2593,
  "instance_id": "duckdb__duckdb-2593",
  "issue_numbers": [
    "2591",
    "2591"
  ],
  "base_commit": "ee7c56dc3b9833a3c8b7ab9cad7c724f31596280",
  "patch": "diff --git a/src/execution/operator/aggregate/physical_simple_aggregate.cpp b/src/execution/operator/aggregate/physical_simple_aggregate.cpp\nindex 8d08b4698891..18ab53b23424 100644\n--- a/src/execution/operator/aggregate/physical_simple_aggregate.cpp\n+++ b/src/execution/operator/aggregate/physical_simple_aggregate.cpp\n@@ -9,9 +9,9 @@\n namespace duckdb {\n \n PhysicalSimpleAggregate::PhysicalSimpleAggregate(vector<LogicalType> types, vector<unique_ptr<Expression>> expressions,\n-                                                 bool all_combinable, idx_t estimated_cardinality)\n+                                                 idx_t estimated_cardinality)\n     : PhysicalOperator(PhysicalOperatorType::SIMPLE_AGGREGATE, move(types), estimated_cardinality),\n-      aggregates(move(expressions)), all_combinable(all_combinable) {\n+      aggregates(move(expressions)) {\n }\n \n //===--------------------------------------------------------------------===//\n@@ -156,21 +156,15 @@ void PhysicalSimpleAggregate::Combine(ExecutionContext &context, GlobalSinkState\n \tD_ASSERT(!gstate.finished);\n \n \t// finalize: combine the local state into the global state\n-\tif (all_combinable) {\n-\t\t// all aggregates are combinable: we might be doing a parallel aggregate\n-\t\t// use the combine method to combine the partial aggregates\n-\t\tlock_guard<mutex> glock(gstate.lock);\n-\t\tfor (idx_t aggr_idx = 0; aggr_idx < aggregates.size(); aggr_idx++) {\n-\t\t\tauto &aggregate = (BoundAggregateExpression &)*aggregates[aggr_idx];\n-\t\t\tVector source_state(Value::POINTER((uintptr_t)source.state.aggregates[aggr_idx].get()));\n-\t\t\tVector dest_state(Value::POINTER((uintptr_t)gstate.state.aggregates[aggr_idx].get()));\n-\n-\t\t\taggregate.function.combine(source_state, dest_state, 1);\n-\t\t}\n-\t} else {\n-\t\t// complex aggregates: this is necessarily a non-parallel aggregate\n-\t\t// simply move over the source state into the global state\n-\t\tsource.state.Move(gstate.state);\n+\t// all aggregates are combinable: we might be doing a parallel aggregate\n+\t// use the combine method to combine the partial aggregates\n+\tlock_guard<mutex> glock(gstate.lock);\n+\tfor (idx_t aggr_idx = 0; aggr_idx < aggregates.size(); aggr_idx++) {\n+\t\tauto &aggregate = (BoundAggregateExpression &)*aggregates[aggr_idx];\n+\t\tVector source_state(Value::POINTER((uintptr_t)source.state.aggregates[aggr_idx].get()));\n+\t\tVector dest_state(Value::POINTER((uintptr_t)gstate.state.aggregates[aggr_idx].get()));\n+\n+\t\taggregate.function.combine(source_state, dest_state, 1);\n \t}\n \n \tcontext.thread.profiler.Flush(this, &source.child_executor, \"child_executor\", 0);\ndiff --git a/src/execution/physical_plan/plan_aggregate.cpp b/src/execution/physical_plan/plan_aggregate.cpp\nindex 99bc3b6d5989..863b0e08e80b 100644\n--- a/src/execution/physical_plan/plan_aggregate.cpp\n+++ b/src/execution/physical_plan/plan_aggregate.cpp\n@@ -147,9 +147,9 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalAggregate\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (use_simple_aggregation) {\n-\t\t\tgroupby = make_unique_base<PhysicalOperator, PhysicalSimpleAggregate>(\n-\t\t\t    op.types, move(op.expressions), all_combinable, op.estimated_cardinality);\n+\t\tif (use_simple_aggregation && all_combinable) {\n+\t\t\tgroupby = make_unique_base<PhysicalOperator, PhysicalSimpleAggregate>(op.types, move(op.expressions),\n+\t\t\t                                                                      op.estimated_cardinality);\n \t\t} else {\n \t\t\tgroupby = make_unique_base<PhysicalOperator, PhysicalHashAggregate>(context, op.types, move(op.expressions),\n \t\t\t                                                                    op.estimated_cardinality);\ndiff --git a/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp b/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp\nindex 239cb442f8f6..26ef0345cb47 100644\n--- a/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp\n+++ b/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp\n@@ -13,18 +13,15 @@\n \n namespace duckdb {\n \n-//! PhysicalSimpleAggregate is an aggregate operator that can only perform aggregates (1) without any groups, and (2)\n-//! without any DISTINCT aggregates\n+//! PhysicalSimpleAggregate is an aggregate operator that can only perform aggregates (1) without any groups, (2)\n+//! without any DISTINCT aggregates, and (3) when all aggregates are combineable\n class PhysicalSimpleAggregate : public PhysicalOperator {\n public:\n-\tPhysicalSimpleAggregate(vector<LogicalType> types, vector<unique_ptr<Expression>> expressions, bool all_combinable,\n+\tPhysicalSimpleAggregate(vector<LogicalType> types, vector<unique_ptr<Expression>> expressions,\n \t                        idx_t estimated_cardinality);\n \n \t//! The aggregates that have to be computed\n \tvector<unique_ptr<Expression>> aggregates;\n-\t//! Whether or not all aggregates are trivially combinable. Aggregates that are trivially combinable can be\n-\t//! parallelized.\n-\tbool all_combinable;\n \n public:\n \t// Source interface\n@@ -51,7 +48,7 @@ class PhysicalSimpleAggregate : public PhysicalOperator {\n \n \tbool ParallelSink() const override {\n \t\t// we can only parallelize if all aggregates are combinable\n-\t\treturn all_combinable;\n+\t\treturn true;\n \t}\n };\n \n",
  "test_patch": "diff --git a/test/sql/aggregate/aggregates/string_agg_union.test b/test/sql/aggregate/aggregates/string_agg_union.test\nnew file mode 100644\nindex 000000000000..ba177c7336dc\n--- /dev/null\n+++ b/test/sql/aggregate/aggregates/string_agg_union.test\n@@ -0,0 +1,30 @@\n+# name: test/sql/aggregate/aggregates/string_agg_union.test\n+# description: Issue #2591: string_agg only returns final row if there is no Group By clause\n+# group: [aggregates]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+WITH my_data as (\n+        SELECT 'text1'::varchar(1000) as my_column union all\n+        SELECT 'text1'::varchar(1000) as my_column union all\n+        SELECT 'text1'::varchar(1000) as my_column\n+    )\n+        SELECT string_agg(my_column,', ') as my_string_agg\n+        FROM my_data\n+----\n+text1, text1, text1\n+\n+query I\n+WITH my_data as (\n+        SELECT 1 as dummy,  'text1'::varchar(1000) as my_column union all\n+        SELECT 1 as dummy,  'text1'::varchar(1000) as my_column union all\n+        SELECT 1 as dummy,  'text1'::varchar(1000) as my_column\n+    )\n+        SELECT string_agg(my_column,', ') as my_string_agg\n+        FROM my_data\n+        GROUP BY\n+            dummy\n+----\n+text1, text1, text1\n",
  "problem_statement": "string_agg only returns final row if there is no Group By clause\n#### What happens?\r\nHi folks! Found an odd one...\r\nIf a group by clause is not provided, the string_agg function returns only the last row of data rather than all rows concatenated together. \r\nThis issue is not present in 0.3.0, only in 0.3.1-dev678. I have a workaround (just include a dummy column), but wanted to let you know about this one!\r\n\r\n#### To Reproduce\r\nThis query does not return correctly (returns 'text3'):\r\n```sql\r\nWITH my_data as (\r\n        SELECT 'text1'::varchar(1000) as my_column union all\r\n        SELECT 'text2'::varchar(1000) as my_column union all\r\n        SELECT 'text3'::varchar(1000) as my_column \r\n    )\r\n        SELECT string_agg(my_column,', ') as my_string_agg \r\n        FROM my_data\r\n```\r\nThis query returns correctly (returns 'text1, text2, text3'):\r\n```sql\r\nWITH my_data as (\r\n        SELECT 1 as dummy,  'text1'::varchar(1000) as my_column union all\r\n        SELECT 1 as dummy,  'text2'::varchar(1000) as my_column union all\r\n        SELECT 1 as dummy,  'text3'::varchar(1000) as my_column \r\n    )\r\n        SELECT string_agg(my_column,', ') as my_string_agg \r\n        FROM my_data\r\n        GROUP BY\r\n            dummy\r\n```\r\n#### Environment (please complete the following information):\r\n - OS: Windows 10\r\n - DuckDB Version: 0.3.1-dev678 (issue not present in 0.3.0)\r\n - DuckDB Client: Node.js\r\n\r\n#### Before Submitting\r\n\r\n- [X] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [X] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nstring_agg only returns final row if there is no Group By clause\n#### What happens?\r\nHi folks! Found an odd one...\r\nIf a group by clause is not provided, the string_agg function returns only the last row of data rather than all rows concatenated together. \r\nThis issue is not present in 0.3.0, only in 0.3.1-dev678. I have a workaround (just include a dummy column), but wanted to let you know about this one!\r\n\r\n#### To Reproduce\r\nThis query does not return correctly (returns 'text3'):\r\n```sql\r\nWITH my_data as (\r\n        SELECT 'text1'::varchar(1000) as my_column union all\r\n        SELECT 'text2'::varchar(1000) as my_column union all\r\n        SELECT 'text3'::varchar(1000) as my_column \r\n    )\r\n        SELECT string_agg(my_column,', ') as my_string_agg \r\n        FROM my_data\r\n```\r\nThis query returns correctly (returns 'text1, text2, text3'):\r\n```sql\r\nWITH my_data as (\r\n        SELECT 1 as dummy,  'text1'::varchar(1000) as my_column union all\r\n        SELECT 1 as dummy,  'text2'::varchar(1000) as my_column union all\r\n        SELECT 1 as dummy,  'text3'::varchar(1000) as my_column \r\n    )\r\n        SELECT string_agg(my_column,', ') as my_string_agg \r\n        FROM my_data\r\n        GROUP BY\r\n            dummy\r\n```\r\n#### Environment (please complete the following information):\r\n - OS: Windows 10\r\n - DuckDB Version: 0.3.1-dev678 (issue not present in 0.3.0)\r\n - DuckDB Client: Node.js\r\n\r\n#### Before Submitting\r\n\r\n- [X] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [X] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "\n",
  "created_at": "2021-11-13T18:54:05Z"
}