diff --git a/src/execution/operator/aggregate/physical_simple_aggregate.cpp b/src/execution/operator/aggregate/physical_simple_aggregate.cpp
index 8d08b4698891..18ab53b23424 100644
--- a/src/execution/operator/aggregate/physical_simple_aggregate.cpp
+++ b/src/execution/operator/aggregate/physical_simple_aggregate.cpp
@@ -9,9 +9,9 @@
 namespace duckdb {
 
 PhysicalSimpleAggregate::PhysicalSimpleAggregate(vector<LogicalType> types, vector<unique_ptr<Expression>> expressions,
-                                                 bool all_combinable, idx_t estimated_cardinality)
+                                                 idx_t estimated_cardinality)
     : PhysicalOperator(PhysicalOperatorType::SIMPLE_AGGREGATE, move(types), estimated_cardinality),
-      aggregates(move(expressions)), all_combinable(all_combinable) {
+      aggregates(move(expressions)) {
 }
 
 //===--------------------------------------------------------------------===//
@@ -156,21 +156,15 @@ void PhysicalSimpleAggregate::Combine(ExecutionContext &context, GlobalSinkState
 	D_ASSERT(!gstate.finished);
 
 	// finalize: combine the local state into the global state
-	if (all_combinable) {
-		// all aggregates are combinable: we might be doing a parallel aggregate
-		// use the combine method to combine the partial aggregates
-		lock_guard<mutex> glock(gstate.lock);
-		for (idx_t aggr_idx = 0; aggr_idx < aggregates.size(); aggr_idx++) {
-			auto &aggregate = (BoundAggregateExpression &)*aggregates[aggr_idx];
-			Vector source_state(Value::POINTER((uintptr_t)source.state.aggregates[aggr_idx].get()));
-			Vector dest_state(Value::POINTER((uintptr_t)gstate.state.aggregates[aggr_idx].get()));
-
-			aggregate.function.combine(source_state, dest_state, 1);
-		}
-	} else {
-		// complex aggregates: this is necessarily a non-parallel aggregate
-		// simply move over the source state into the global state
-		source.state.Move(gstate.state);
+	// all aggregates are combinable: we might be doing a parallel aggregate
+	// use the combine method to combine the partial aggregates
+	lock_guard<mutex> glock(gstate.lock);
+	for (idx_t aggr_idx = 0; aggr_idx < aggregates.size(); aggr_idx++) {
+		auto &aggregate = (BoundAggregateExpression &)*aggregates[aggr_idx];
+		Vector source_state(Value::POINTER((uintptr_t)source.state.aggregates[aggr_idx].get()));
+		Vector dest_state(Value::POINTER((uintptr_t)gstate.state.aggregates[aggr_idx].get()));
+
+		aggregate.function.combine(source_state, dest_state, 1);
 	}
 
 	context.thread.profiler.Flush(this, &source.child_executor, "child_executor", 0);
diff --git a/src/execution/physical_plan/plan_aggregate.cpp b/src/execution/physical_plan/plan_aggregate.cpp
index 99bc3b6d5989..863b0e08e80b 100644
--- a/src/execution/physical_plan/plan_aggregate.cpp
+++ b/src/execution/physical_plan/plan_aggregate.cpp
@@ -147,9 +147,9 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalAggregate
 				break;
 			}
 		}
-		if (use_simple_aggregation) {
-			groupby = make_unique_base<PhysicalOperator, PhysicalSimpleAggregate>(
-			    op.types, move(op.expressions), all_combinable, op.estimated_cardinality);
+		if (use_simple_aggregation && all_combinable) {
+			groupby = make_unique_base<PhysicalOperator, PhysicalSimpleAggregate>(op.types, move(op.expressions),
+			                                                                      op.estimated_cardinality);
 		} else {
 			groupby = make_unique_base<PhysicalOperator, PhysicalHashAggregate>(context, op.types, move(op.expressions),
 			                                                                    op.estimated_cardinality);
diff --git a/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp b/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp
index 239cb442f8f6..26ef0345cb47 100644
--- a/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp
+++ b/src/include/duckdb/execution/operator/aggregate/physical_simple_aggregate.hpp
@@ -13,18 +13,15 @@
 
 namespace duckdb {
 
-//! PhysicalSimpleAggregate is an aggregate operator that can only perform aggregates (1) without any groups, and (2)
-//! without any DISTINCT aggregates
+//! PhysicalSimpleAggregate is an aggregate operator that can only perform aggregates (1) without any groups, (2)
+//! without any DISTINCT aggregates, and (3) when all aggregates are combineable
 class PhysicalSimpleAggregate : public PhysicalOperator {
 public:
-	PhysicalSimpleAggregate(vector<LogicalType> types, vector<unique_ptr<Expression>> expressions, bool all_combinable,
+	PhysicalSimpleAggregate(vector<LogicalType> types, vector<unique_ptr<Expression>> expressions,
 	                        idx_t estimated_cardinality);
 
 	//! The aggregates that have to be computed
 	vector<unique_ptr<Expression>> aggregates;
-	//! Whether or not all aggregates are trivially combinable. Aggregates that are trivially combinable can be
-	//! parallelized.
-	bool all_combinable;
 
 public:
 	// Source interface
@@ -51,7 +48,7 @@ class PhysicalSimpleAggregate : public PhysicalOperator {
 
 	bool ParallelSink() const override {
 		// we can only parallelize if all aggregates are combinable
-		return all_combinable;
+		return true;
 	}
 };
 
