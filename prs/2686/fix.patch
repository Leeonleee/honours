diff --git a/src/common/enums/optimizer_type.cpp b/src/common/enums/optimizer_type.cpp
index 09541b417907..08dd7e348115 100644
--- a/src/common/enums/optimizer_type.cpp
+++ b/src/common/enums/optimizer_type.cpp
@@ -1,43 +1,54 @@
 #include "duckdb/common/enums/optimizer_type.hpp"
+#include "duckdb/common/string_util.hpp"
 
 #include "duckdb/common/exception.hpp"
 
 namespace duckdb {
 
+struct DefaultOptimizerType {
+	const char *name;
+	OptimizerType type;
+};
+
+static DefaultOptimizerType internal_optimizer_types[] = {
+    {"expression_rewriter", OptimizerType::EXPRESSION_REWRITER},
+    {"filter_pullup", OptimizerType::FILTER_PULLUP},
+    {"filter_pushdown", OptimizerType::FILTER_PUSHDOWN},
+    {"regex_range", OptimizerType::REGEX_RANGE},
+    {"in_clause", OptimizerType::IN_CLAUSE},
+    {"join_order", OptimizerType::JOIN_ORDER},
+    {"deliminator", OptimizerType::DELIMINATOR},
+    {"unused_columns", OptimizerType::UNUSED_COLUMNS},
+    {"statistics_propagation", OptimizerType::STATISTICS_PROPAGATION},
+    {"common_subexpressions", OptimizerType::COMMON_SUBEXPRESSIONS},
+    {"common_aggregate", OptimizerType::COMMON_AGGREGATE},
+    {"column_lifetime", OptimizerType::COLUMN_LIFETIME},
+    {"top_n", OptimizerType::TOP_N},
+    {"reorder_filter", OptimizerType::REORDER_FILTER},
+    {nullptr, OptimizerType::INVALID}};
+
 string OptimizerTypeToString(OptimizerType type) {
-	switch (type) {
-	case OptimizerType::EXPRESSION_REWRITER:
-		return "expression_rewriter";
-	case OptimizerType::FILTER_PULLUP:
-		return "filter_pullup";
-	case OptimizerType::FILTER_PUSHDOWN:
-		return "filter_pushdown";
-	case OptimizerType::REGEX_RANGE:
-		return "regex_range";
-	case OptimizerType::IN_CLAUSE:
-		return "in_clause";
-	case OptimizerType::JOIN_ORDER:
-		return "join_order";
-	case OptimizerType::DELIMINATOR:
-		return "deliminator";
-	case OptimizerType::UNUSED_COLUMNS:
-		return "unused_columns";
-	case OptimizerType::STATISTICS_PROPAGATION:
-		return "statistics_propagation";
-	case OptimizerType::COMMON_SUBEXPRESSIONS:
-		return "common_subexpressions";
-	case OptimizerType::COMMON_AGGREGATE:
-		return "common_aggregate";
-	case OptimizerType::COLUMN_LIFETIME:
-		return "column_lifetime";
-	case OptimizerType::TOP_N:
-		return "top_n";
-	case OptimizerType::REORDER_FILTER:
-		return "reorder_filter";
-	case OptimizerType::INVALID: // LCOV_EXCL_START
-		break;
+	for (idx_t i = 0; internal_optimizer_types[i].name; i++) {
+		if (internal_optimizer_types[i].type == type) {
+			return internal_optimizer_types[i].name;
+		}
+	}
+	throw InternalException("Invalid optimizer type");
+}
+
+OptimizerType OptimizerTypeFromString(const string &str) {
+	for (idx_t i = 0; internal_optimizer_types[i].name; i++) {
+		if (internal_optimizer_types[i].name == str) {
+			return internal_optimizer_types[i].type;
+		}
+	}
+	// optimizer not found, construct candidate list
+	vector<string> optimizer_names;
+	for (idx_t i = 0; internal_optimizer_types[i].name; i++) {
+		optimizer_names.emplace_back(internal_optimizer_types[i].name);
 	}
-	return "INVALID"; // LCOV_EXCL_STOP
+	throw ParserException("Optimizer type \"%s\" not recognized
%s", str,
+	                      StringUtil::CandidatesErrorMessage(optimizer_names, str, "Candidate optimizers"));
 }
 
 } // namespace duckdb
diff --git a/src/common/string_util.cpp b/src/common/string_util.cpp
index 9f83dddda044..ffad3ec6600f 100644
--- a/src/common/string_util.cpp
+++ b/src/common/string_util.cpp
@@ -292,4 +292,10 @@ string StringUtil::CandidatesMessage(const vector<string> &candidates, const str
 	return result_str;
 }
 
+string StringUtil::CandidatesErrorMessage(const vector<string> &strings, const string &target,
+                                          const string &message_prefix, idx_t n) {
+	auto closest_strings = StringUtil::TopNLevenshtein(strings, target, n);
+	return StringUtil::CandidatesMessage(closest_strings, message_prefix);
+}
+
 } // namespace duckdb
diff --git a/src/execution/operator/helper/physical_set.cpp b/src/execution/operator/helper/physical_set.cpp
index f4b78df8b3db..5994bab6b793 100644
--- a/src/execution/operator/helper/physical_set.cpp
+++ b/src/execution/operator/helper/physical_set.cpp
@@ -23,9 +23,9 @@ void PhysicalSet::GetData(ExecutionContext &context, DataChunk &chunk, GlobalSou
 			for (auto &entry : config.extension_parameters) {
 				potential_names.push_back(entry.first);
 			}
-			auto closest_settings = StringUtil::TopNLevenshtein(potential_names, name);
+
 			throw CatalogException("unrecognized configuration parameter \"%s\"
%s", name,
-			                       StringUtil::CandidatesMessage(closest_settings, "Did you mean"));
+			                       StringUtil::CandidatesErrorMessage(potential_names, name, "Did you mean"));
 		}
 		//! it is!
 		auto &extension_option = entry->second;
diff --git a/src/include/duckdb/common/enums/optimizer_type.hpp b/src/include/duckdb/common/enums/optimizer_type.hpp
index be5a9661b50f..8d1e77e6f3fe 100644
--- a/src/include/duckdb/common/enums/optimizer_type.hpp
+++ b/src/include/duckdb/common/enums/optimizer_type.hpp
@@ -31,5 +31,6 @@ enum class OptimizerType : uint32_t {
 };
 
 string OptimizerTypeToString(OptimizerType type);
+OptimizerType OptimizerTypeFromString(const string &str);
 
 } // namespace duckdb
diff --git a/src/include/duckdb/common/string_util.hpp b/src/include/duckdb/common/string_util.hpp
index 13a82bbb0f6f..69b3935f6515 100644
--- a/src/include/duckdb/common/string_util.hpp
+++ b/src/include/duckdb/common/string_util.hpp
@@ -120,5 +120,11 @@ class StringUtil {
 	                                                 idx_t threshold = 5);
 	DUCKDB_API static string CandidatesMessage(const vector<string> &candidates,
 	                                           const string &candidate = "Candidate bindings");
+
+	//! Generate an error message in the form of "{message_prefix}: nearest_string, nearest_string2, ...
+	//! Equivalent to calling TopNLevenshtein followed by CandidatesMessage
+	DUCKDB_API static string CandidatesErrorMessage(const vector<string> &strings, const string &target,
+	                                                const string &message_prefix, idx_t n = 5);
 };
+
 } // namespace duckdb
diff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp
index d3edc18277e0..92f9c16af500 100644
--- a/src/include/duckdb/main/settings.hpp
+++ b/src/include/duckdb/main/settings.hpp
@@ -92,6 +92,14 @@ struct DefaultNullOrderSetting {
 	static Value GetSetting(ClientContext &context);
 };
 
+struct DisabledOptimizersSetting {
+	static constexpr const char *Name = "disabled_optimizers";
+	static constexpr const char *Description = "DEBUG SETTING: disable a specific set of optimizers (comma separated)";
+	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
+	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
+	static Value GetSetting(ClientContext &context);
+};
+
 struct EnableExternalAccessSetting {
 	static constexpr const char *Name = "enable_external_access";
 	static constexpr const char *Description =
diff --git a/src/main/config.cpp b/src/main/config.cpp
index 2eec1927c288..2ea78415f8ea 100644
--- a/src/main/config.cpp
+++ b/src/main/config.cpp
@@ -31,6 +31,7 @@ static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting
                                                  DUCKDB_GLOBAL_LOCAL(DefaultCollationSetting),
                                                  DUCKDB_GLOBAL(DefaultOrderSetting),
                                                  DUCKDB_GLOBAL(DefaultNullOrderSetting),
+                                                 DUCKDB_GLOBAL(DisabledOptimizersSetting),
                                                  DUCKDB_GLOBAL(EnableExternalAccessSetting),
                                                  DUCKDB_GLOBAL(EnableObjectCacheSetting),
                                                  DUCKDB_LOCAL(EnableProfilingSetting),
diff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp
index 6a2fdbeb915c..27c99b778216 100644
--- a/src/main/settings/settings.cpp
+++ b/src/main/settings/settings.cpp
@@ -199,6 +199,35 @@ Value DefaultNullOrderSetting::GetSetting(ClientContext &context) {
 	}
 }
 
+//===--------------------------------------------------------------------===//
+// Disabled Optimizer
+//===--------------------------------------------------------------------===//
+void DisabledOptimizersSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
+	auto list = StringUtil::Split(input.ToString(), ",");
+	set<OptimizerType> disabled_optimizers;
+	for (auto &entry : list) {
+		auto param = StringUtil::Lower(entry);
+		StringUtil::Trim(param);
+		if (param.empty()) {
+			continue;
+		}
+		disabled_optimizers.insert(OptimizerTypeFromString(param));
+	}
+	config.disabled_optimizers = move(disabled_optimizers);
+}
+
+Value DisabledOptimizersSetting::GetSetting(ClientContext &context) {
+	auto &config = DBConfig::GetConfig(context);
+	string result;
+	for (auto &optimizer : config.disabled_optimizers) {
+		if (!result.empty()) {
+			result += ",";
+		}
+		result += OptimizerTypeToString(optimizer);
+	}
+	return Value(result);
+}
+
 //===--------------------------------------------------------------------===//
 // Enable External Access
 //===--------------------------------------------------------------------===//
diff --git a/src/optimizer/cse_optimizer.cpp b/src/optimizer/cse_optimizer.cpp
index 930ba5a0b5ef..97c62fbc7365 100644
--- a/src/optimizer/cse_optimizer.cpp
+++ b/src/optimizer/cse_optimizer.cpp
@@ -49,6 +49,9 @@ void CommonSubExpressionOptimizer::CountExpressions(Expression &expr, CSEReplace
 	case ExpressionClass::BOUND_COLUMN_REF:
 	case ExpressionClass::BOUND_CONSTANT:
 	case ExpressionClass::BOUND_PARAMETER:
+	// skip conjunctions and case, since short-circuiting might be incorrectly disabled otherwise
+	case ExpressionClass::BOUND_CONJUNCTION:
+	case ExpressionClass::BOUND_CASE:
 		return;
 	default:
 		break;
@@ -88,7 +91,9 @@ void CommonSubExpressionOptimizer::PerformCSEReplacement(unique_ptr<Expression>
 		return;
 	}
 	// check if this child is eligible for CSE elimination
-	if (state.expression_count.find(&expr) != state.expression_count.end()) {
+	bool can_cse = expr.expression_class != ExpressionClass::BOUND_CONJUNCTION &&
+	               expr.expression_class != ExpressionClass::BOUND_CASE;
+	if (can_cse && state.expression_count.find(&expr) != state.expression_count.end()) {
 		auto &node = state.expression_count[&expr];
 		if (node.count > 1) {
 			// this expression occurs more than once! push it into the projection
diff --git a/src/optimizer/rule/in_clause_simplification_rule.cpp b/src/optimizer/rule/in_clause_simplification_rule.cpp
index fcbd8939cd50..5c3d6c618b17 100644
--- a/src/optimizer/rule/in_clause_simplification_rule.cpp
+++ b/src/optimizer/rule/in_clause_simplification_rule.cpp
@@ -25,7 +25,7 @@ unique_ptr<Expression> InClauseSimplificationRule::Apply(LogicalOperator &op, ve
 	}
 	//! Here we check if we can apply the expression on the constant side
 	auto target_type = cast_expression->source_type();
-	if (!BoundCastExpression::CastIsInvertible(target_type, cast_expression->return_type)) {
+	if (!BoundCastExpression::CastIsInvertible(cast_expression->return_type, target_type)) {
 		return nullptr;
 	}
 	vector<unique_ptr<BoundConstantExpression>> cast_list;
