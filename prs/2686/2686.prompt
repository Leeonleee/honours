You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
CASE WHEN logical expression not short circuiting properly 
#### What happens?
Logical expression in `CASE WHEN` is not short circuiting properly. For example `CASE WHEN a AND b`, `b` is also evaluated when `a` is FALSE.

#### To Reproduce

```SQL
drop table t;
create table t (n text);
insert into t values ('1'),('0'),('');
select n, case 
when n <> '' and cast(substr(n, 1, 1) as int) <= 0 then '0' 
when n <> '' and cast(substr(n, 1, 1) as int) > 0 then '1' 
else '2'end as x from t;
```
The above code gets an error:
```
Error: Conversion Error: Could not convert string '' to INT32
```

But if delete one `WHEN` statement, a correct result could be yield:
```SQL
drop table t;
create table t (n text);
insert into t values ('1'),('0'),('');
select n, case 
when n <> '' and cast(substr(n, 1, 1) as int) <= 0 then '0' 
else '2'end as x from t;
```
Result:
```
┌───┬───┐
│ n │ x │
├───┼───┤
│ 1 │ 2 │
│ 0 │ 0 │
│   │ 2 │
└───┴───┘
```

#### Environment (please complete the following information):
 - OS: Linux
 - DuckDB Version: v0.3.2-dev175 847e60d0f 
 - DuckDB Client: cli

#### Before Submitting

- [YES ] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [ YES] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

CASE WHEN logical expression not short circuiting properly 
#### What happens?
Logical expression in `CASE WHEN` is not short circuiting properly. For example `CASE WHEN a AND b`, `b` is also evaluated when `a` is FALSE.

#### To Reproduce

```SQL
drop table t;
create table t (n text);
insert into t values ('1'),('0'),('');
select n, case 
when n <> '' and cast(substr(n, 1, 1) as int) <= 0 then '0' 
when n <> '' and cast(substr(n, 1, 1) as int) > 0 then '1' 
else '2'end as x from t;
```
The above code gets an error:
```
Error: Conversion Error: Could not convert string '' to INT32
```

But if delete one `WHEN` statement, a correct result could be yield:
```SQL
drop table t;
create table t (n text);
insert into t values ('1'),('0'),('');
select n, case 
when n <> '' and cast(substr(n, 1, 1) as int) <= 0 then '0' 
else '2'end as x from t;
```
Result:
```
┌───┬───┐
│ n │ x │
├───┼───┤
│ 1 │ 2 │
│ 0 │ 0 │
│   │ 2 │
└───┴───┘
```

#### Environment (please complete the following information):
 - OS: Linux
 - DuckDB Version: v0.3.2-dev175 847e60d0f 
 - DuckDB Client: cli

#### Before Submitting

- [YES ] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [ YES] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/common/enums/optimizer_type.cpp]
1: #include "duckdb/common/enums/optimizer_type.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: 
5: namespace duckdb {
6: 
7: string OptimizerTypeToString(OptimizerType type) {
8: 	switch (type) {
9: 	case OptimizerType::EXPRESSION_REWRITER:
10: 		return "expression_rewriter";
11: 	case OptimizerType::FILTER_PULLUP:
12: 		return "filter_pullup";
13: 	case OptimizerType::FILTER_PUSHDOWN:
14: 		return "filter_pushdown";
15: 	case OptimizerType::REGEX_RANGE:
16: 		return "regex_range";
17: 	case OptimizerType::IN_CLAUSE:
18: 		return "in_clause";
19: 	case OptimizerType::JOIN_ORDER:
20: 		return "join_order";
21: 	case OptimizerType::DELIMINATOR:
22: 		return "deliminator";
23: 	case OptimizerType::UNUSED_COLUMNS:
24: 		return "unused_columns";
25: 	case OptimizerType::STATISTICS_PROPAGATION:
26: 		return "statistics_propagation";
27: 	case OptimizerType::COMMON_SUBEXPRESSIONS:
28: 		return "common_subexpressions";
29: 	case OptimizerType::COMMON_AGGREGATE:
30: 		return "common_aggregate";
31: 	case OptimizerType::COLUMN_LIFETIME:
32: 		return "column_lifetime";
33: 	case OptimizerType::TOP_N:
34: 		return "top_n";
35: 	case OptimizerType::REORDER_FILTER:
36: 		return "reorder_filter";
37: 	case OptimizerType::INVALID: // LCOV_EXCL_START
38: 		break;
39: 	}
40: 	return "INVALID"; // LCOV_EXCL_STOP
41: }
42: 
43: } // namespace duckdb
[end of src/common/enums/optimizer_type.cpp]
[start of src/common/string_util.cpp]
1: #include "duckdb/common/string_util.hpp"
2: #include "duckdb/common/pair.hpp"
3: #include "duckdb/common/to_string.hpp"
4: #include "duckdb/common/string_util.hpp"
5: #include "duckdb/common/exception.hpp"
6: 
7: #include <algorithm>
8: #include <cctype>
9: #include <iomanip>
10: #include <memory>
11: #include <sstream>
12: #include <stdarg.h>
13: #include <string.h>
14: 
15: namespace duckdb {
16: 
17: bool StringUtil::Contains(const string &haystack, const string &needle) {
18: 	return (haystack.find(needle) != string::npos);
19: }
20: 
21: void StringUtil::LTrim(string &str) {
22: 	auto it = str.begin();
23: 	while (CharacterIsSpace(*it)) {
24: 		it++;
25: 	}
26: 	str.erase(str.begin(), it);
27: }
28: 
29: // Remove trailing ' ', '\f', '\n', '\r', '\t', '\v'
30: void StringUtil::RTrim(string &str) {
31: 	str.erase(find_if(str.rbegin(), str.rend(), [](int ch) { return ch > 0 && !CharacterIsSpace(ch); }).base(),
32: 	          str.end());
33: }
34: 
35: void StringUtil::Trim(string &str) {
36: 	StringUtil::LTrim(str);
37: 	StringUtil::RTrim(str);
38: }
39: 
40: bool StringUtil::StartsWith(string str, string prefix) {
41: 	if (prefix.size() > str.size()) {
42: 		return false;
43: 	}
44: 	return equal(prefix.begin(), prefix.end(), str.begin());
45: }
46: 
47: bool StringUtil::EndsWith(const string &str, const string &suffix) {
48: 	if (suffix.size() > str.size()) {
49: 		return false;
50: 	}
51: 	return equal(suffix.rbegin(), suffix.rend(), str.rbegin());
52: }
53: 
54: string StringUtil::Repeat(const string &str, idx_t n) {
55: 	std::ostringstream os;
56: 	for (idx_t i = 0; i < n; i++) {
57: 		os << str;
58: 	}
59: 	return (os.str());
60: }
61: 
62: vector<string> StringUtil::Split(const string &str, char delimiter) {
63: 	std::stringstream ss(str);
64: 	vector<string> lines;
65: 	string temp;
66: 	while (getline(ss, temp, delimiter)) {
67: 		lines.push_back(temp);
68: 	}
69: 	return (lines);
70: }
71: 
72: namespace string_util_internal {
73: 
74: inline void SkipSpaces(const string &str, idx_t &index) {
75: 	while (index < str.size() && std::isspace(str[index])) {
76: 		index++;
77: 	}
78: }
79: 
80: inline void ConsumeLetter(const string &str, idx_t &index, char expected) {
81: 	if (index >= str.size() || str[index] != expected) {
82: 		throw ParserException("Invalid quoted list: %s", str);
83: 	}
84: 
85: 	index++;
86: }
87: 
88: template <typename F>
89: inline void TakeWhile(const string &str, idx_t &index, const F &cond, string &taker) {
90: 	while (index < str.size() && cond(str[index])) {
91: 		taker.push_back(str[index]);
92: 		index++;
93: 	}
94: }
95: 
96: inline string TakePossiblyQuotedItem(const string &str, idx_t &index, char delimiter, char quote) {
97: 	string entry;
98: 
99: 	if (str[index] == quote) {
100: 		index++;
101: 		TakeWhile(
102: 		    str, index, [quote](char c) { return c != quote; }, entry);
103: 		ConsumeLetter(str, index, quote);
104: 	} else {
105: 		TakeWhile(
106: 		    str, index, [delimiter, quote](char c) { return c != delimiter && c != quote && !std::isspace(c); }, entry);
107: 	}
108: 
109: 	return entry;
110: }
111: 
112: } // namespace string_util_internal
113: 
114: vector<string> StringUtil::SplitWithQuote(const string &str, char delimiter, char quote) {
115: 	vector<string> entries;
116: 	idx_t i = 0;
117: 
118: 	string_util_internal::SkipSpaces(str, i);
119: 	while (i < str.size()) {
120: 		if (!entries.empty()) {
121: 			string_util_internal::ConsumeLetter(str, i, delimiter);
122: 		}
123: 
124: 		entries.emplace_back(string_util_internal::TakePossiblyQuotedItem(str, i, delimiter, quote));
125: 		string_util_internal::SkipSpaces(str, i);
126: 	}
127: 
128: 	return entries;
129: }
130: 
131: string StringUtil::Join(const vector<string> &input, const string &separator) {
132: 	return StringUtil::Join(input, input.size(), separator, [](const string &s) { return s; });
133: }
134: 
135: string StringUtil::BytesToHumanReadableString(idx_t bytes) {
136: 	string db_size;
137: 	auto kilobytes = bytes / 1000;
138: 	auto megabytes = kilobytes / 1000;
139: 	kilobytes -= megabytes * 1000;
140: 	auto gigabytes = megabytes / 1000;
141: 	megabytes -= gigabytes * 1000;
142: 	auto terabytes = gigabytes / 1000;
143: 	gigabytes -= terabytes * 1000;
144: 	if (terabytes > 0) {
145: 		return to_string(terabytes) + "." + to_string(gigabytes / 100) + "TB";
146: 	} else if (gigabytes > 0) {
147: 		return to_string(gigabytes) + "." + to_string(megabytes / 100) + "GB";
148: 	} else if (megabytes > 0) {
149: 		return to_string(megabytes) + "." + to_string(kilobytes / 100) + "MB";
150: 	} else if (kilobytes > 0) {
151: 		return to_string(kilobytes) + "KB";
152: 	} else {
153: 		return to_string(bytes) + " bytes";
154: 	}
155: }
156: 
157: string StringUtil::Upper(const string &str) {
158: 	string copy(str);
159: 	transform(copy.begin(), copy.end(), copy.begin(), [](unsigned char c) { return std::toupper(c); });
160: 	return (copy);
161: }
162: 
163: string StringUtil::Lower(const string &str) {
164: 	string copy(str);
165: 	transform(copy.begin(), copy.end(), copy.begin(), [](unsigned char c) { return std::tolower(c); });
166: 	return (copy);
167: }
168: 
169: vector<string> StringUtil::Split(const string &input, const string &split) {
170: 	vector<string> splits;
171: 
172: 	idx_t last = 0;
173: 	idx_t input_len = input.size();
174: 	idx_t split_len = split.size();
175: 	while (last <= input_len) {
176: 		idx_t next = input.find(split, last);
177: 		if (next == string::npos) {
178: 			next = input_len;
179: 		}
180: 
181: 		// Push the substring [last, next) on to splits
182: 		string substr = input.substr(last, next - last);
183: 		if (substr.empty() == false) {
184: 			splits.push_back(substr);
185: 		}
186: 		last = next + split_len;
187: 	}
188: 	return splits;
189: }
190: 
191: string StringUtil::Replace(string source, const string &from, const string &to) {
192: 	idx_t start_pos = 0;
193: 	while ((start_pos = source.find(from, start_pos)) != string::npos) {
194: 		source.replace(start_pos, from.length(), to);
195: 		start_pos += to.length(); // In case 'to' contains 'from', like
196: 		                          // replacing 'x' with 'yx'
197: 	}
198: 	return source;
199: }
200: 
201: vector<string> StringUtil::TopNStrings(vector<pair<string, idx_t>> scores, idx_t n, idx_t threshold) {
202: 	if (scores.empty()) {
203: 		return vector<string>();
204: 	}
205: 	sort(scores.begin(), scores.end(),
206: 	     [](const pair<string, idx_t> &a, const pair<string, idx_t> &b) -> bool { return a.second < b.second; });
207: 	vector<string> result;
208: 	result.push_back(scores[0].first);
209: 	for (idx_t i = 1; i < MinValue<idx_t>(scores.size(), n); i++) {
210: 		if (scores[i].second > threshold) {
211: 			break;
212: 		}
213: 		result.push_back(scores[i].first);
214: 	}
215: 	return result;
216: }
217: 
218: struct LevenshteinArray {
219: 	LevenshteinArray(idx_t len1, idx_t len2) : len1(len1) {
220: 		dist = unique_ptr<idx_t[]>(new idx_t[len1 * len2]);
221: 	}
222: 
223: 	idx_t &Score(idx_t i, idx_t j) {
224: 		return dist[GetIndex(i, j)];
225: 	}
226: 
227: private:
228: 	idx_t len1;
229: 	unique_ptr<idx_t[]> dist;
230: 
231: 	idx_t GetIndex(idx_t i, idx_t j) {
232: 		return j * len1 + i;
233: 	}
234: };
235: 
236: // adapted from https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#C++
237: idx_t StringUtil::LevenshteinDistance(const string &s1, const string &s2) {
238: 	idx_t len1 = s1.size();
239: 	idx_t len2 = s2.size();
240: 	if (len1 == 0) {
241: 		return len2;
242: 	}
243: 	if (len2 == 0) {
244: 		return len1;
245: 	}
246: 	LevenshteinArray array(len1 + 1, len2 + 1);
247: 	array.Score(0, 0) = 0;
248: 	for (idx_t i = 0; i <= len1; i++) {
249: 		array.Score(i, 0) = i;
250: 	}
251: 	for (idx_t j = 0; j <= len2; j++) {
252: 		array.Score(0, j) = j;
253: 	}
254: 	for (idx_t i = 1; i <= len1; i++) {
255: 		for (idx_t j = 1; j <= len2; j++) {
256: 			// d[i][j] = std::min({ d[i - 1][j] + 1,
257: 			//                      d[i][j - 1] + 1,
258: 			//                      d[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1) });
259: 			int equal = s1[i - 1] == s2[j - 1] ? 0 : 1;
260: 			idx_t adjacent_score1 = array.Score(i - 1, j) + 1;
261: 			idx_t adjacent_score2 = array.Score(i, j - 1) + 1;
262: 			idx_t adjacent_score3 = array.Score(i - 1, j - 1) + equal;
263: 
264: 			idx_t t = MinValue<idx_t>(adjacent_score1, adjacent_score2);
265: 			array.Score(i, j) = MinValue<idx_t>(t, adjacent_score3);
266: 		}
267: 	}
268: 	return array.Score(len1, len2);
269: }
270: 
271: vector<string> StringUtil::TopNLevenshtein(const vector<string> &strings, const string &target, idx_t n,
272:                                            idx_t threshold) {
273: 	vector<pair<string, idx_t>> scores;
274: 	scores.reserve(strings.size());
275: 	for (auto &str : strings) {
276: 		scores.emplace_back(str, LevenshteinDistance(str, target));
277: 	}
278: 	return TopNStrings(scores, n, threshold);
279: }
280: 
281: string StringUtil::CandidatesMessage(const vector<string> &candidates, const string &candidate) {
282: 	string result_str;
283: 	if (!candidates.empty()) {
284: 		result_str = "\n" + candidate + ": ";
285: 		for (idx_t i = 0; i < candidates.size(); i++) {
286: 			if (i > 0) {
287: 				result_str += ", ";
288: 			}
289: 			result_str += "\"" + candidates[i] + "\"";
290: 		}
291: 	}
292: 	return result_str;
293: }
294: 
295: } // namespace duckdb
[end of src/common/string_util.cpp]
[start of src/execution/operator/helper/physical_set.cpp]
1: #include "duckdb/execution/operator/helper/physical_set.hpp"
2: 
3: #include "duckdb/common/string_util.hpp"
4: #include "duckdb/main/database.hpp"
5: #include "duckdb/main/client_context.hpp"
6: 
7: namespace duckdb {
8: 
9: void PhysicalSet::GetData(ExecutionContext &context, DataChunk &chunk, GlobalSourceState &gstate,
10:                           LocalSourceState &lstate) const {
11: 	auto option = DBConfig::GetOptionByName(name);
12: 	if (!option) {
13: 		// check if this is an extra extension variable
14: 		auto &config = DBConfig::GetConfig(context.client);
15: 		auto entry = config.extension_parameters.find(name);
16: 		if (entry == config.extension_parameters.end()) {
17: 			// it is not!
18: 			// get a list of all options
19: 			vector<string> potential_names;
20: 			for (idx_t i = 0, option_count = DBConfig::GetOptionCount(); i < option_count; i++) {
21: 				potential_names.emplace_back(DBConfig::GetOptionByIndex(i)->name);
22: 			}
23: 			for (auto &entry : config.extension_parameters) {
24: 				potential_names.push_back(entry.first);
25: 			}
26: 			auto closest_settings = StringUtil::TopNLevenshtein(potential_names, name);
27: 			throw CatalogException("unrecognized configuration parameter \"%s\"\n%s", name,
28: 			                       StringUtil::CandidatesMessage(closest_settings, "Did you mean"));
29: 		}
30: 		//! it is!
31: 		auto &extension_option = entry->second;
32: 		auto &target_type = extension_option.type;
33: 		Value target_value = value.CastAs(target_type);
34: 		if (extension_option.set_function) {
35: 			extension_option.set_function(context.client, scope, target_value);
36: 		}
37: 		if (scope == SetScope::GLOBAL) {
38: 			config.set_variables[name] = move(target_value);
39: 		} else {
40: 			auto &client_config = ClientConfig::GetConfig(context.client);
41: 			client_config.set_variables[name] = move(target_value);
42: 		}
43: 		return;
44: 	}
45: 	SetScope variable_scope = scope;
46: 	if (variable_scope == SetScope::AUTOMATIC) {
47: 		if (option->set_local) {
48: 			variable_scope = SetScope::SESSION;
49: 		} else {
50: 			D_ASSERT(option->set_global);
51: 			variable_scope = SetScope::GLOBAL;
52: 		}
53: 	}
54: 
55: 	Value input = value.CastAs(option->parameter_type);
56: 	switch (variable_scope) {
57: 	case SetScope::GLOBAL: {
58: 		if (!option->set_global) {
59: 			throw CatalogException("option \"%s\" cannot be set globally", name);
60: 		}
61: 		auto &db = DatabaseInstance::GetDatabase(context.client);
62: 		auto &config = DBConfig::GetConfig(context.client);
63: 		option->set_global(&db, config, input);
64: 		break;
65: 	}
66: 	case SetScope::SESSION:
67: 		if (!option->set_local) {
68: 			throw CatalogException("option \"%s\" cannot be set locally", name);
69: 		}
70: 		option->set_local(context.client, input);
71: 		break;
72: 	default:
73: 		throw InternalException("Unsupported SetScope for variable");
74: 	}
75: }
76: 
77: } // namespace duckdb
[end of src/execution/operator/helper/physical_set.cpp]
[start of src/include/duckdb/common/enums/optimizer_type.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/enums/optimizer_type.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/constants.hpp"
12: 
13: namespace duckdb {
14: 
15: enum class OptimizerType : uint32_t {
16: 	INVALID = 0,
17: 	EXPRESSION_REWRITER,
18: 	FILTER_PULLUP,
19: 	FILTER_PUSHDOWN,
20: 	REGEX_RANGE,
21: 	IN_CLAUSE,
22: 	JOIN_ORDER,
23: 	DELIMINATOR,
24: 	UNUSED_COLUMNS,
25: 	STATISTICS_PROPAGATION,
26: 	COMMON_SUBEXPRESSIONS,
27: 	COMMON_AGGREGATE,
28: 	COLUMN_LIFETIME,
29: 	TOP_N,
30: 	REORDER_FILTER
31: };
32: 
33: string OptimizerTypeToString(OptimizerType type);
34: 
35: } // namespace duckdb
[end of src/include/duckdb/common/enums/optimizer_type.hpp]
[start of src/include/duckdb/common/string_util.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/string_util.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/constants.hpp"
12: #include "duckdb/common/exception.hpp"
13: #include "duckdb/common/vector.hpp"
14: 
15: namespace duckdb {
16: /**
17:  * String Utility Functions
18:  * Note that these are not the most efficient implementations (i.e., they copy
19:  * memory) and therefore they should only be used for debug messages and other
20:  * such things.
21:  */
22: class StringUtil {
23: public:
24: 	DUCKDB_API static bool CharacterIsSpace(char c) {
25: 		return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
26: 	}
27: 	DUCKDB_API static bool CharacterIsNewline(char c) {
28: 		return c == '\n' || c == '\r';
29: 	}
30: 	DUCKDB_API static bool CharacterIsDigit(char c) {
31: 		return c >= '0' && c <= '9';
32: 	}
33: 	DUCKDB_API static char CharacterToLower(char c) {
34: 		if (c >= 'A' && c <= 'Z') {
35: 			return c - ('A' - 'a');
36: 		}
37: 		return c;
38: 	}
39: 
40: 	//! Returns true if the needle string exists in the haystack
41: 	DUCKDB_API static bool Contains(const string &haystack, const string &needle);
42: 
43: 	//! Returns true if the target string starts with the given prefix
44: 	DUCKDB_API static bool StartsWith(string str, string prefix);
45: 
46: 	//! Returns true if the target string <b>ends</b> with the given suffix.
47: 	DUCKDB_API static bool EndsWith(const string &str, const string &suffix);
48: 
49: 	//! Repeat a string multiple times
50: 	DUCKDB_API static string Repeat(const string &str, const idx_t n);
51: 
52: 	//! Split the input string based on newline char
53: 	DUCKDB_API static vector<string> Split(const string &str, char delimiter);
54: 
55: 	//! Split the input string allong a quote. Note that any escaping is NOT supported.
56: 	DUCKDB_API static vector<string> SplitWithQuote(const string &str, char delimiter = ',', char quote = '"');
57: 
58: 	//! Join multiple strings into one string. Components are concatenated by the given separator
59: 	DUCKDB_API static string Join(const vector<string> &input, const string &separator);
60: 
61: 	//! Join multiple items of container with given size, transformed to string
62: 	//! using function, into one string using the given separator
63: 	template <typename C, typename S, typename Func>
64: 	static string Join(const C &input, S count, const string &separator, Func f) {
65: 		// The result
66: 		std::string result;
67: 
68: 		// If the input isn't empty, append the first element. We do this so we
69: 		// don't need to introduce an if into the loop.
70: 		if (count > 0) {
71: 			result += f(input[0]);
72: 		}
73: 
74: 		// Append the remaining input components, after the first
75: 		for (size_t i = 1; i < count; i++) {
76: 			result += separator + f(input[i]);
77: 		}
78: 
79: 		return result;
80: 	}
81: 
82: 	//! Return a string that formats the give number of bytes
83: 	DUCKDB_API static string BytesToHumanReadableString(idx_t bytes);
84: 
85: 	//! Convert a string to uppercase
86: 	DUCKDB_API static string Upper(const string &str);
87: 
88: 	//! Convert a string to lowercase
89: 	DUCKDB_API static string Lower(const string &str);
90: 
91: 	//! Format a string using printf semantics
92: 	template <typename... Args>
93: 	static string Format(const string fmt_str, Args... params) {
94: 		return Exception::ConstructMessage(fmt_str, params...);
95: 	}
96: 
97: 	//! Split the input string into a vector of strings based on the split string
98: 	DUCKDB_API static vector<string> Split(const string &input, const string &split);
99: 
100: 	//! Remove the whitespace char in the left end of the string
101: 	DUCKDB_API static void LTrim(string &str);
102: 	//! Remove the whitespace char in the right end of the string
103: 	DUCKDB_API static void RTrim(string &str);
104: 	//! Remove the whitespace char in the left and right end of the string
105: 	DUCKDB_API static void Trim(string &str);
106: 
107: 	DUCKDB_API static string Replace(string source, const string &from, const string &to);
108: 
109: 	//! Get the levenshtein distance from two strings
110: 	DUCKDB_API static idx_t LevenshteinDistance(const string &s1, const string &s2);
111: 
112: 	//! Get the top-n strings (sorted by the given score distance) from a set of scores.
113: 	//! At least one entry is returned (if there is one).
114: 	//! Strings are only returned if they have a score less than the threshold.
115: 	DUCKDB_API static vector<string> TopNStrings(vector<std::pair<string, idx_t>> scores, idx_t n = 5,
116: 	                                             idx_t threshold = 5);
117: 	//! Computes the levenshtein distance of each string in strings, and compares it to target, then returns TopNStrings
118: 	//! with the given params.
119: 	DUCKDB_API static vector<string> TopNLevenshtein(const vector<string> &strings, const string &target, idx_t n = 5,
120: 	                                                 idx_t threshold = 5);
121: 	DUCKDB_API static string CandidatesMessage(const vector<string> &candidates,
122: 	                                           const string &candidate = "Candidate bindings");
123: };
124: } // namespace duckdb
[end of src/include/duckdb/common/string_util.hpp]
[start of src/include/duckdb/main/settings.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/settings.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types/value.hpp"
13: 
14: namespace duckdb {
15: class ClientContext;
16: class DatabaseInstance;
17: struct DBConfig;
18: 
19: struct AccessModeSetting {
20: 	static constexpr const char *Name = "access_mode";
21: 	static constexpr const char *Description = "Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE)";
22: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
23: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
24: 	static Value GetSetting(ClientContext &context);
25: };
26: 
27: struct CheckpointThresholdSetting {
28: 	static constexpr const char *Name = "checkpoint_threshold";
29: 	static constexpr const char *Description =
30: 	    "The WAL size threshold at which to automatically trigger a checkpoint (e.g. 1GB)";
31: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
32: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
33: 	static Value GetSetting(ClientContext &context);
34: };
35: 
36: struct DebugCheckpointAbort {
37: 	static constexpr const char *Name = "debug_checkpoint_abort";
38: 	static constexpr const char *Description =
39: 	    "DEBUG SETTING: trigger an abort while checkpointing for testing purposes";
40: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
41: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
42: 	static Value GetSetting(ClientContext &context);
43: };
44: 
45: struct DebugForceExternal {
46: 	static constexpr const char *Name = "debug_force_external";
47: 	static constexpr const char *Description =
48: 	    "DEBUG SETTING: force out-of-core computation for operators that support it, used for testing";
49: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
50: 	static void SetLocal(ClientContext &context, const Value &parameter);
51: 	static Value GetSetting(ClientContext &context);
52: };
53: 
54: struct DebugManyFreeListBlocks {
55: 	static constexpr const char *Name = "debug_many_free_list_blocks";
56: 	static constexpr const char *Description = "DEBUG SETTING: add additional blocks to the free list";
57: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
58: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
59: 	static Value GetSetting(ClientContext &context);
60: };
61: 
62: struct DebugWindowMode {
63: 	static constexpr const char *Name = "debug_window_mode";
64: 	static constexpr const char *Description = "DEBUG SETTING: switch window mode to use";
65: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
66: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
67: 	static Value GetSetting(ClientContext &context);
68: };
69: 
70: struct DefaultCollationSetting {
71: 	static constexpr const char *Name = "default_collation";
72: 	static constexpr const char *Description = "The collation setting used when none is specified";
73: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
74: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
75: 	static void SetLocal(ClientContext &context, const Value &parameter);
76: 	static Value GetSetting(ClientContext &context);
77: };
78: 
79: struct DefaultOrderSetting {
80: 	static constexpr const char *Name = "default_order";
81: 	static constexpr const char *Description = "The order type used when none is specified (ASC or DESC)";
82: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
83: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
84: 	static Value GetSetting(ClientContext &context);
85: };
86: 
87: struct DefaultNullOrderSetting {
88: 	static constexpr const char *Name = "default_null_order";
89: 	static constexpr const char *Description = "Null ordering used when none is specified (NULLS_FIRST or NULLS_LAST)";
90: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
91: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
92: 	static Value GetSetting(ClientContext &context);
93: };
94: 
95: struct EnableExternalAccessSetting {
96: 	static constexpr const char *Name = "enable_external_access";
97: 	static constexpr const char *Description =
98: 	    "Allow the database to access external state (through e.g. loading/installing modules, COPY TO/FROM, CSV "
99: 	    "readers, pandas replacement scans, etc)";
100: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
101: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
102: 	static Value GetSetting(ClientContext &context);
103: };
104: 
105: struct EnableObjectCacheSetting {
106: 	static constexpr const char *Name = "enable_object_cache";
107: 	static constexpr const char *Description = "Whether or not object cache is used to cache e.g. Parquet metadata";
108: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
109: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
110: 	static Value GetSetting(ClientContext &context);
111: };
112: 
113: struct EnableProfilingSetting {
114: 	static constexpr const char *Name = "enable_profiling";
115: 	static constexpr const char *Description =
116: 	    "Enables profiling, and sets the output format (JSON, QUERY_TREE, QUERY_TREE_OPTIMIZER)";
117: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
118: 	static void SetLocal(ClientContext &context, const Value &parameter);
119: 	static Value GetSetting(ClientContext &context);
120: };
121: 
122: struct EnableProgressBarSetting {
123: 	static constexpr const char *Name = "enable_progress_bar";
124: 	static constexpr const char *Description =
125: 	    "Enables the progress bar, printing progress to the terminal for long queries";
126: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
127: 	static void SetLocal(ClientContext &context, const Value &parameter);
128: 	static Value GetSetting(ClientContext &context);
129: };
130: 
131: struct ExplainOutputSetting {
132: 	static constexpr const char *Name = "explain_output";
133: 	static constexpr const char *Description = "Output of EXPLAIN statements (ALL, OPTIMIZED_ONLY, PHYSICAL_ONLY)";
134: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
135: 	static void SetLocal(ClientContext &context, const Value &parameter);
136: 	static Value GetSetting(ClientContext &context);
137: };
138: 
139: struct ForceCompressionSetting {
140: 	static constexpr const char *Name = "force_compression";
141: 	static constexpr const char *Description = "DEBUG SETTING: forces a specific compression method to be used";
142: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
143: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
144: 	static Value GetSetting(ClientContext &context);
145: };
146: 
147: struct LogQueryPathSetting {
148: 	static constexpr const char *Name = "log_query_path";
149: 	static constexpr const char *Description =
150: 	    "Specifies the path to which queries should be logged (default: empty string, queries are not logged)";
151: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
152: 	static void SetLocal(ClientContext &context, const Value &parameter);
153: 	static Value GetSetting(ClientContext &context);
154: };
155: 
156: struct MaximumMemorySetting {
157: 	static constexpr const char *Name = "max_memory";
158: 	static constexpr const char *Description = "The maximum memory of the system (e.g. 1GB)";
159: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
160: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
161: 	static Value GetSetting(ClientContext &context);
162: };
163: 
164: struct PerfectHashThresholdSetting {
165: 	static constexpr const char *Name = "perfect_ht_threshold";
166: 	static constexpr const char *Description = "Threshold in bytes for when to use a perfect hash table (default: 12)";
167: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
168: 	static void SetLocal(ClientContext &context, const Value &parameter);
169: 	static Value GetSetting(ClientContext &context);
170: };
171: 
172: struct ProfilerHistorySize {
173: 	static constexpr const char *Name = "profiler_history_size";
174: 	static constexpr const char *Description = "Sets the profiler history size";
175: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
176: 	static void SetLocal(ClientContext &context, const Value &parameter);
177: 	static Value GetSetting(ClientContext &context);
178: };
179: 
180: struct ProfileOutputSetting {
181: 	static constexpr const char *Name = "profile_output";
182: 	static constexpr const char *Description =
183: 	    "The file to which profile output should be saved, or empty to print to the terminal";
184: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
185: 	static void SetLocal(ClientContext &context, const Value &parameter);
186: 	static Value GetSetting(ClientContext &context);
187: };
188: 
189: struct ProfilingModeSetting {
190: 	static constexpr const char *Name = "profiling_mode";
191: 	static constexpr const char *Description = "The profiling mode (STANDARD or DETAILED)";
192: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
193: 	static void SetLocal(ClientContext &context, const Value &parameter);
194: 	static Value GetSetting(ClientContext &context);
195: };
196: 
197: struct ProgressBarTimeSetting {
198: 	static constexpr const char *Name = "progress_bar_time";
199: 	static constexpr const char *Description =
200: 	    "Sets the time (in milliseconds) how long a query needs to take before we start printing a progress bar";
201: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
202: 	static void SetLocal(ClientContext &context, const Value &parameter);
203: 	static Value GetSetting(ClientContext &context);
204: };
205: 
206: struct SchemaSetting {
207: 	static constexpr const char *Name = "schema";
208: 	static constexpr const char *Description =
209: 	    "Sets the default search schema. Equivalent to setting search_path to a single value.";
210: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
211: 	static void SetLocal(ClientContext &context, const Value &parameter);
212: 	static Value GetSetting(ClientContext &context);
213: };
214: 
215: struct SearchPathSetting {
216: 	static constexpr const char *Name = "search_path";
217: 	static constexpr const char *Description =
218: 	    "Sets the default search search path as a comma-separated list of values";
219: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
220: 	static void SetLocal(ClientContext &context, const Value &parameter);
221: 	static Value GetSetting(ClientContext &context);
222: };
223: 
224: struct TempDirectorySetting {
225: 	static constexpr const char *Name = "temp_directory";
226: 	static constexpr const char *Description = "Set the directory to which to write temp files";
227: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
228: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
229: 	static Value GetSetting(ClientContext &context);
230: };
231: 
232: struct ThreadsSetting {
233: 	static constexpr const char *Name = "threads";
234: 	static constexpr const char *Description = "The number of total threads used by the system.";
235: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
236: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
237: 	static Value GetSetting(ClientContext &context);
238: };
239: 
240: } // namespace duckdb
[end of src/include/duckdb/main/settings.hpp]
[start of src/main/config.cpp]
1: #include "duckdb/main/config.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/common/operator/cast_operators.hpp"
4: #include "duckdb/main/settings.hpp"
5: 
6: namespace duckdb {
7: 
8: #define DUCKDB_GLOBAL(_PARAM)                                                                                          \
9: 	{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::GetSetting }
10: #define DUCKDB_GLOBAL_ALIAS(_ALIAS, _PARAM)                                                                            \
11: 	{ _ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::GetSetting }
12: 
13: #define DUCKDB_LOCAL(_PARAM)                                                                                           \
14: 	{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, _PARAM::GetSetting }
15: #define DUCKDB_LOCAL_ALIAS(_ALIAS, _PARAM)                                                                             \
16: 	{ _ALIAS, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, _PARAM::GetSetting }
17: 
18: #define DUCKDB_GLOBAL_LOCAL(_PARAM)                                                                                    \
19: 	{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal, _PARAM::GetSetting }
20: #define DUCKDB_GLOBAL_LOCAL_ALIAS(_ALIAS, _PARAM)                                                                      \
21: 	{ _ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal, _PARAM::GetSetting }
22: #define FINAL_SETTING                                                                                                  \
23: 	{ nullptr, nullptr, LogicalTypeId::INVALID, nullptr, nullptr, nullptr }
24: 
25: static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting),
26:                                                  DUCKDB_GLOBAL(CheckpointThresholdSetting),
27:                                                  DUCKDB_GLOBAL(DebugCheckpointAbort),
28:                                                  DUCKDB_LOCAL(DebugForceExternal),
29:                                                  DUCKDB_GLOBAL(DebugManyFreeListBlocks),
30:                                                  DUCKDB_GLOBAL(DebugWindowMode),
31:                                                  DUCKDB_GLOBAL_LOCAL(DefaultCollationSetting),
32:                                                  DUCKDB_GLOBAL(DefaultOrderSetting),
33:                                                  DUCKDB_GLOBAL(DefaultNullOrderSetting),
34:                                                  DUCKDB_GLOBAL(EnableExternalAccessSetting),
35:                                                  DUCKDB_GLOBAL(EnableObjectCacheSetting),
36:                                                  DUCKDB_LOCAL(EnableProfilingSetting),
37:                                                  DUCKDB_LOCAL(EnableProgressBarSetting),
38:                                                  DUCKDB_LOCAL(ExplainOutputSetting),
39:                                                  DUCKDB_GLOBAL(ForceCompressionSetting),
40:                                                  DUCKDB_LOCAL(LogQueryPathSetting),
41:                                                  DUCKDB_GLOBAL(MaximumMemorySetting),
42:                                                  DUCKDB_GLOBAL_ALIAS("memory_limit", MaximumMemorySetting),
43:                                                  DUCKDB_GLOBAL_ALIAS("null_order", DefaultNullOrderSetting),
44:                                                  DUCKDB_LOCAL(PerfectHashThresholdSetting),
45:                                                  DUCKDB_LOCAL(ProfilerHistorySize),
46:                                                  DUCKDB_LOCAL(ProfileOutputSetting),
47:                                                  DUCKDB_LOCAL(ProfilingModeSetting),
48:                                                  DUCKDB_LOCAL_ALIAS("profiling_output", ProfileOutputSetting),
49:                                                  DUCKDB_LOCAL(ProgressBarTimeSetting),
50:                                                  DUCKDB_LOCAL(SchemaSetting),
51:                                                  DUCKDB_LOCAL(SearchPathSetting),
52:                                                  DUCKDB_GLOBAL(TempDirectorySetting),
53:                                                  DUCKDB_GLOBAL(ThreadsSetting),
54:                                                  DUCKDB_GLOBAL_ALIAS("wal_autocheckpoint", CheckpointThresholdSetting),
55:                                                  DUCKDB_GLOBAL_ALIAS("worker_threads", ThreadsSetting),
56:                                                  FINAL_SETTING};
57: 
58: vector<ConfigurationOption> DBConfig::GetOptions() {
59: 	vector<ConfigurationOption> options;
60: 	for (idx_t index = 0; internal_options[index].name; index++) {
61: 		options.push_back(internal_options[index]);
62: 	}
63: 	return options;
64: }
65: 
66: idx_t DBConfig::GetOptionCount() {
67: 	idx_t count = 0;
68: 	for (idx_t index = 0; internal_options[index].name; index++) {
69: 		count++;
70: 	}
71: 	return count;
72: }
73: 
74: ConfigurationOption *DBConfig::GetOptionByIndex(idx_t target_index) {
75: 	for (idx_t index = 0; internal_options[index].name; index++) {
76: 		if (index == target_index) {
77: 			return internal_options + index;
78: 		}
79: 	}
80: 	return nullptr;
81: }
82: 
83: ConfigurationOption *DBConfig::GetOptionByName(const string &name) {
84: 	for (idx_t index = 0; internal_options[index].name; index++) {
85: 		if (internal_options[index].name == name) {
86: 			return internal_options + index;
87: 		}
88: 	}
89: 	return nullptr;
90: }
91: 
92: void DBConfig::SetOption(const ConfigurationOption &option, const Value &value) {
93: 	if (!option.set_global) {
94: 		throw InternalException("Could not set option \"%s\" as a global option", option.name);
95: 	}
96: 	Value input = value.CastAs(option.parameter_type);
97: 	option.set_global(nullptr, *this, input);
98: }
99: 
100: void DBConfig::AddExtensionOption(string name, string description, LogicalType parameter,
101:                                   set_option_callback_t function) {
102: 	extension_parameters.insert(make_pair(move(name), ExtensionOption(move(description), move(parameter), function)));
103: }
104: 
105: idx_t DBConfig::ParseMemoryLimit(const string &arg) {
106: 	if (arg[0] == '-' || arg == "null" || arg == "none") {
107: 		return DConstants::INVALID_INDEX;
108: 	}
109: 	// split based on the number/non-number
110: 	idx_t idx = 0;
111: 	while (StringUtil::CharacterIsSpace(arg[idx])) {
112: 		idx++;
113: 	}
114: 	idx_t num_start = idx;
115: 	while ((arg[idx] >= '0' && arg[idx] <= '9') || arg[idx] == '.' || arg[idx] == 'e' || arg[idx] == 'E' ||
116: 	       arg[idx] == '-') {
117: 		idx++;
118: 	}
119: 	if (idx == num_start) {
120: 		throw ParserException("Memory limit must have a number (e.g. SET memory_limit=1GB");
121: 	}
122: 	string number = arg.substr(num_start, idx - num_start);
123: 
124: 	// try to parse the number
125: 	double limit = Cast::Operation<string_t, double>(string_t(number));
126: 
127: 	// now parse the memory limit unit (e.g. bytes, gb, etc)
128: 	while (StringUtil::CharacterIsSpace(arg[idx])) {
129: 		idx++;
130: 	}
131: 	idx_t start = idx;
132: 	while (idx < arg.size() && !StringUtil::CharacterIsSpace(arg[idx])) {
133: 		idx++;
134: 	}
135: 	if (limit < 0) {
136: 		// limit < 0, set limit to infinite
137: 		return (idx_t)-1;
138: 	}
139: 	string unit = StringUtil::Lower(arg.substr(start, idx - start));
140: 	idx_t multiplier;
141: 	if (unit == "byte" || unit == "bytes" || unit == "b") {
142: 		multiplier = 1;
143: 	} else if (unit == "kilobyte" || unit == "kilobytes" || unit == "kb" || unit == "k") {
144: 		multiplier = 1000LL;
145: 	} else if (unit == "megabyte" || unit == "megabytes" || unit == "mb" || unit == "m") {
146: 		multiplier = 1000LL * 1000LL;
147: 	} else if (unit == "gigabyte" || unit == "gigabytes" || unit == "gb" || unit == "g") {
148: 		multiplier = 1000LL * 1000LL * 1000LL;
149: 	} else if (unit == "terabyte" || unit == "terabytes" || unit == "tb" || unit == "t") {
150: 		multiplier = 1000LL * 1000LL * 1000LL * 1000LL;
151: 	} else {
152: 		throw ParserException("Unknown unit for memory_limit: %s (expected: b, mb, gb or tb)", unit);
153: 	}
154: 	return (idx_t)multiplier * limit;
155: }
156: 
157: } // namespace duckdb
[end of src/main/config.cpp]
[start of src/main/settings/settings.cpp]
1: #include "duckdb/main/settings.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/main/config.hpp"
4: #include "duckdb/main/client_context.hpp"
5: #include "duckdb/catalog/catalog_search_path.hpp"
6: #include "duckdb/storage/buffer_manager.hpp"
7: #include "duckdb/parallel/task_scheduler.hpp"
8: #include "duckdb/planner/expression_binder.hpp"
9: #include "duckdb/main/query_profiler.hpp"
10: #include "duckdb/storage/storage_manager.hpp"
11: 
12: namespace duckdb {
13: 
14: //===--------------------------------------------------------------------===//
15: // Access Mode
16: //===--------------------------------------------------------------------===//
17: void AccessModeSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
18: 	auto parameter = StringUtil::Lower(input.ToString());
19: 	if (parameter == "automatic") {
20: 		config.access_mode = AccessMode::AUTOMATIC;
21: 	} else if (parameter == "read_only") {
22: 		config.access_mode = AccessMode::READ_ONLY;
23: 	} else if (parameter == "read_write") {
24: 		config.access_mode = AccessMode::READ_WRITE;
25: 	} else {
26: 		throw InvalidInputException(
27: 		    "Unrecognized parameter for option ACCESS_MODE \"%s\". Expected READ_ONLY or READ_WRITE.", parameter);
28: 	}
29: }
30: 
31: Value AccessModeSetting::GetSetting(ClientContext &context) {
32: 	auto &config = DBConfig::GetConfig(context);
33: 	switch (config.access_mode) {
34: 	case AccessMode::AUTOMATIC:
35: 		return "automatic";
36: 	case AccessMode::READ_ONLY:
37: 		return "read_only";
38: 	case AccessMode::READ_WRITE:
39: 		return "read_write";
40: 	default:
41: 		throw InternalException("Unknown access mode setting");
42: 	}
43: }
44: 
45: //===--------------------------------------------------------------------===//
46: // Checkpoint Threshold
47: //===--------------------------------------------------------------------===//
48: void CheckpointThresholdSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
49: 	idx_t new_limit = DBConfig::ParseMemoryLimit(input.ToString());
50: 	config.checkpoint_wal_size = new_limit;
51: }
52: 
53: Value CheckpointThresholdSetting::GetSetting(ClientContext &context) {
54: 	auto &config = DBConfig::GetConfig(context);
55: 	return Value(StringUtil::BytesToHumanReadableString(config.checkpoint_wal_size));
56: }
57: 
58: //===--------------------------------------------------------------------===//
59: // Debug Checkpoint Abort
60: //===--------------------------------------------------------------------===//
61: void DebugCheckpointAbort::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
62: 	auto checkpoint_abort = StringUtil::Lower(input.ToString());
63: 	if (checkpoint_abort == "none") {
64: 		config.checkpoint_abort = CheckpointAbort::NO_ABORT;
65: 	} else if (checkpoint_abort == "before_truncate") {
66: 		config.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE;
67: 	} else if (checkpoint_abort == "before_header") {
68: 		config.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER;
69: 	} else if (checkpoint_abort == "after_free_list_write") {
70: 		config.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE;
71: 	} else {
72: 		throw ParserException(
73: 		    "Unrecognized option for PRAGMA debug_checkpoint_abort, expected none, before_truncate or before_header");
74: 	}
75: }
76: 
77: Value DebugCheckpointAbort::GetSetting(ClientContext &context) {
78: 	return Value();
79: }
80: 
81: //===--------------------------------------------------------------------===//
82: // Debug Force External
83: //===--------------------------------------------------------------------===//
84: void DebugForceExternal::SetLocal(ClientContext &context, const Value &input) {
85: 	ClientConfig::GetConfig(context).force_external = input.GetValue<bool>();
86: }
87: 
88: Value DebugForceExternal::GetSetting(ClientContext &context) {
89: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).force_external);
90: }
91: 
92: //===--------------------------------------------------------------------===//
93: // Debug Many Free List blocks
94: //===--------------------------------------------------------------------===//
95: void DebugManyFreeListBlocks::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
96: 	config.debug_many_free_list_blocks = input.GetValue<bool>();
97: }
98: 
99: Value DebugManyFreeListBlocks::GetSetting(ClientContext &context) {
100: 	auto &config = DBConfig::GetConfig(context);
101: 	return Value::BOOLEAN(config.debug_many_free_list_blocks);
102: }
103: 
104: //===--------------------------------------------------------------------===//
105: // Debug Window Mode
106: //===--------------------------------------------------------------------===//
107: void DebugWindowMode::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
108: 	auto param = StringUtil::Lower(input.ToString());
109: 	if (param == "window") {
110: 		config.window_mode = WindowAggregationMode::WINDOW;
111: 	} else if (param == "combine") {
112: 		config.window_mode = WindowAggregationMode::COMBINE;
113: 	} else if (param == "separate") {
114: 		config.window_mode = WindowAggregationMode::SEPARATE;
115: 	} else {
116: 		throw ParserException("Unrecognized option for PRAGMA debug_window_mode, expected window, combine or separate");
117: 	}
118: }
119: 
120: Value DebugWindowMode::GetSetting(ClientContext &context) {
121: 	return Value();
122: }
123: 
124: //===--------------------------------------------------------------------===//
125: // Default Collation
126: //===--------------------------------------------------------------------===//
127: void DefaultCollationSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
128: 	auto parameter = StringUtil::Lower(input.ToString());
129: 	config.collation = parameter;
130: }
131: 
132: void DefaultCollationSetting::SetLocal(ClientContext &context, const Value &input) {
133: 	auto parameter = input.ToString();
134: 	// bind the collation to verify that it exists
135: 	ExpressionBinder::TestCollation(context, parameter);
136: 	auto &config = DBConfig::GetConfig(context);
137: 	config.collation = parameter;
138: }
139: 
140: Value DefaultCollationSetting::GetSetting(ClientContext &context) {
141: 	auto &config = DBConfig::GetConfig(context);
142: 	return Value(config.collation);
143: }
144: 
145: //===--------------------------------------------------------------------===//
146: // Default Order
147: //===--------------------------------------------------------------------===//
148: void DefaultOrderSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
149: 	auto parameter = StringUtil::Lower(input.ToString());
150: 	if (parameter == "ascending" || parameter == "asc") {
151: 		config.default_order_type = OrderType::ASCENDING;
152: 	} else if (parameter == "descending" || parameter == "desc") {
153: 		config.default_order_type = OrderType::DESCENDING;
154: 	} else {
155: 		throw InvalidInputException("Unrecognized parameter for option DEFAULT_ORDER \"%s\". Expected ASC or DESC.",
156: 		                            parameter);
157: 	}
158: }
159: 
160: Value DefaultOrderSetting::GetSetting(ClientContext &context) {
161: 	auto &config = DBConfig::GetConfig(context);
162: 	switch (config.default_order_type) {
163: 	case OrderType::ASCENDING:
164: 		return "asc";
165: 	case OrderType::DESCENDING:
166: 		return "desc";
167: 	default:
168: 		throw InternalException("Unknown order type setting");
169: 	}
170: }
171: 
172: //===--------------------------------------------------------------------===//
173: // Default Null Order
174: //===--------------------------------------------------------------------===//
175: void DefaultNullOrderSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
176: 	auto parameter = StringUtil::Lower(input.ToString());
177: 
178: 	if (parameter == "nulls_first" || parameter == "nulls first" || parameter == "null first" || parameter == "first") {
179: 		config.default_null_order = OrderByNullType::NULLS_FIRST;
180: 	} else if (parameter == "nulls_last" || parameter == "nulls last" || parameter == "null last" ||
181: 	           parameter == "last") {
182: 		config.default_null_order = OrderByNullType::NULLS_LAST;
183: 	} else {
184: 		throw ParserException(
185: 		    "Unrecognized parameter for option NULL_ORDER \"%s\", expected either NULLS FIRST or NULLS LAST",
186: 		    parameter);
187: 	}
188: }
189: 
190: Value DefaultNullOrderSetting::GetSetting(ClientContext &context) {
191: 	auto &config = DBConfig::GetConfig(context);
192: 	switch (config.default_null_order) {
193: 	case OrderByNullType::NULLS_FIRST:
194: 		return "nulls_first";
195: 	case OrderByNullType::NULLS_LAST:
196: 		return "nulls_last";
197: 	default:
198: 		throw InternalException("Unknown null order setting");
199: 	}
200: }
201: 
202: //===--------------------------------------------------------------------===//
203: // Enable External Access
204: //===--------------------------------------------------------------------===//
205: void EnableExternalAccessSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
206: 	if (db) {
207: 		throw InvalidInputException("Cannot change enable_external_access setting while database is running");
208: 	}
209: 	config.enable_external_access = input.GetValue<bool>();
210: }
211: 
212: Value EnableExternalAccessSetting::GetSetting(ClientContext &context) {
213: 	auto &config = DBConfig::GetConfig(context);
214: 	return Value::BOOLEAN(config.enable_external_access);
215: }
216: 
217: //===--------------------------------------------------------------------===//
218: // Enable Object Cache
219: //===--------------------------------------------------------------------===//
220: void EnableObjectCacheSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
221: 	config.object_cache_enable = input.GetValue<bool>();
222: }
223: 
224: Value EnableObjectCacheSetting::GetSetting(ClientContext &context) {
225: 	auto &config = DBConfig::GetConfig(context);
226: 	return Value::BOOLEAN(config.object_cache_enable);
227: }
228: 
229: //===--------------------------------------------------------------------===//
230: // Enable Profiling
231: //===--------------------------------------------------------------------===//
232: void EnableProfilingSetting::SetLocal(ClientContext &context, const Value &input) {
233: 	auto parameter = StringUtil::Lower(input.ToString());
234: 	if (parameter == "json") {
235: 		context.profiler->automatic_print_format = ProfilerPrintFormat::JSON;
236: 	} else if (parameter == "query_tree") {
237: 		context.profiler->automatic_print_format = ProfilerPrintFormat::QUERY_TREE;
238: 	} else if (parameter == "query_tree_optimizer") {
239: 		context.profiler->automatic_print_format = ProfilerPrintFormat::QUERY_TREE_OPTIMIZER;
240: 	} else {
241: 		throw ParserException(
242: 		    "Unrecognized print format %s, supported formats: [json, query_tree, query_tree_optimizer]", parameter);
243: 	}
244: 	context.profiler->Enable();
245: }
246: 
247: Value EnableProfilingSetting::GetSetting(ClientContext &context) {
248: 	if (!context.profiler->IsEnabled()) {
249: 		return Value();
250: 	}
251: 	switch (context.profiler->automatic_print_format) {
252: 	case ProfilerPrintFormat::NONE:
253: 		return Value("none");
254: 	case ProfilerPrintFormat::JSON:
255: 		return Value("json");
256: 	case ProfilerPrintFormat::QUERY_TREE:
257: 		return Value("query_tree");
258: 	case ProfilerPrintFormat::QUERY_TREE_OPTIMIZER:
259: 		return Value("query_tree_optimizer");
260: 	default:
261: 		throw InternalException("Unsupported profiler print format");
262: 	}
263: }
264: 
265: //===--------------------------------------------------------------------===//
266: // Enable Progress Bar
267: //===--------------------------------------------------------------------===//
268: void EnableProgressBarSetting::SetLocal(ClientContext &context, const Value &input) {
269: 	ClientConfig::GetConfig(context).enable_progress_bar = input.GetValue<bool>();
270: }
271: 
272: Value EnableProgressBarSetting::GetSetting(ClientContext &context) {
273: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).enable_progress_bar);
274: }
275: 
276: //===--------------------------------------------------------------------===//
277: // Explain Output
278: //===--------------------------------------------------------------------===//
279: void ExplainOutputSetting::SetLocal(ClientContext &context, const Value &input) {
280: 	auto parameter = StringUtil::Lower(input.ToString());
281: 	if (parameter == "all") {
282: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::ALL;
283: 	} else if (parameter == "optimized_only") {
284: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::OPTIMIZED_ONLY;
285: 	} else if (parameter == "physical_only") {
286: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::PHYSICAL_ONLY;
287: 	} else {
288: 		throw ParserException("Unrecognized output type \"%s\", expected either ALL, OPTIMIZED_ONLY or PHYSICAL_ONLY",
289: 		                      parameter);
290: 	}
291: }
292: 
293: Value ExplainOutputSetting::GetSetting(ClientContext &context) {
294: 	switch (ClientConfig::GetConfig(context).explain_output_type) {
295: 	case ExplainOutputType::ALL:
296: 		return "all";
297: 	case ExplainOutputType::OPTIMIZED_ONLY:
298: 		return "optimized_only";
299: 	case ExplainOutputType::PHYSICAL_ONLY:
300: 		return "physical_only";
301: 	default:
302: 		throw InternalException("Unrecognized explain output type");
303: 	}
304: }
305: 
306: //===--------------------------------------------------------------------===//
307: // Force Compression
308: //===--------------------------------------------------------------------===//
309: void ForceCompressionSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
310: 	auto compression = StringUtil::Lower(input.ToString());
311: 	if (compression == "none") {
312: 		config.force_compression = CompressionType::COMPRESSION_AUTO;
313: 	} else {
314: 		auto compression_type = CompressionTypeFromString(compression);
315: 		if (compression_type == CompressionType::COMPRESSION_AUTO) {
316: 			throw ParserException("Unrecognized option for PRAGMA force_compression, expected none, uncompressed, rle, "
317: 			                      "dictionary, pfor, bitpacking or fsst");
318: 		}
319: 		config.force_compression = compression_type;
320: 	}
321: }
322: 
323: Value ForceCompressionSetting::GetSetting(ClientContext &context) {
324: 	return Value();
325: }
326: 
327: //===--------------------------------------------------------------------===//
328: // Log Query Path
329: //===--------------------------------------------------------------------===//
330: void LogQueryPathSetting::SetLocal(ClientContext &context, const Value &input) {
331: 	auto path = input.ToString();
332: 	if (path.empty()) {
333: 		// empty path: clean up query writer
334: 		context.log_query_writer = nullptr;
335: 	} else {
336: 		context.log_query_writer =
337: 		    make_unique<BufferedFileWriter>(FileSystem::GetFileSystem(context), path,
338: 		                                    BufferedFileWriter::DEFAULT_OPEN_FLAGS, context.file_opener.get());
339: 	}
340: }
341: 
342: Value LogQueryPathSetting::GetSetting(ClientContext &context) {
343: 	return context.log_query_writer ? Value(context.log_query_writer->path) : Value();
344: }
345: 
346: //===--------------------------------------------------------------------===//
347: // Maximum Memory
348: //===--------------------------------------------------------------------===//
349: void MaximumMemorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
350: 	config.maximum_memory = DBConfig::ParseMemoryLimit(input.ToString());
351: 	if (db) {
352: 		BufferManager::GetBufferManager(*db).SetLimit(config.maximum_memory);
353: 	}
354: }
355: 
356: Value MaximumMemorySetting::GetSetting(ClientContext &context) {
357: 	auto &config = DBConfig::GetConfig(context);
358: 	return Value(StringUtil::BytesToHumanReadableString(config.maximum_memory));
359: }
360: 
361: //===--------------------------------------------------------------------===//
362: // Perfect Hash Threshold
363: //===--------------------------------------------------------------------===//
364: void PerfectHashThresholdSetting::SetLocal(ClientContext &context, const Value &input) {
365: 	auto bits = input.GetValue<int32_t>();
366: 	if (bits < 0 || bits > 32) {
367: 		throw ParserException("Perfect HT threshold out of range: should be within range 0 - 32");
368: 	}
369: 	ClientConfig::GetConfig(context).perfect_ht_threshold = bits;
370: }
371: 
372: Value PerfectHashThresholdSetting::GetSetting(ClientContext &context) {
373: 	return Value::BIGINT(ClientConfig::GetConfig(context).perfect_ht_threshold);
374: }
375: 
376: //===--------------------------------------------------------------------===//
377: // Profiler History Size
378: //===--------------------------------------------------------------------===//
379: void ProfilerHistorySize::SetLocal(ClientContext &context, const Value &input) {
380: 	auto size = input.GetValue<int64_t>();
381: 	if (size <= 0) {
382: 		throw ParserException("Size should be >= 0");
383: 	}
384: 	context.query_profiler_history->SetProfilerHistorySize(size);
385: }
386: 
387: Value ProfilerHistorySize::GetSetting(ClientContext &context) {
388: 	return Value();
389: }
390: 
391: //===--------------------------------------------------------------------===//
392: // Profile Output
393: //===--------------------------------------------------------------------===//
394: void ProfileOutputSetting::SetLocal(ClientContext &context, const Value &input) {
395: 	auto parameter = input.ToString();
396: 	context.profiler->save_location = parameter;
397: }
398: 
399: Value ProfileOutputSetting::GetSetting(ClientContext &context) {
400: 	return Value(context.profiler->save_location);
401: }
402: 
403: //===--------------------------------------------------------------------===//
404: // Profiling Mode
405: //===--------------------------------------------------------------------===//
406: void ProfilingModeSetting::SetLocal(ClientContext &context, const Value &input) {
407: 	auto parameter = StringUtil::Lower(input.ToString());
408: 	if (parameter == "standard") {
409: 		context.profiler->Enable();
410: 	} else if (parameter == "detailed") {
411: 		context.profiler->DetailedEnable();
412: 	} else {
413: 		throw ParserException("Unrecognized profiling mode \"%s\", supported formats: [standard, detailed]", parameter);
414: 	}
415: }
416: 
417: Value ProfilingModeSetting::GetSetting(ClientContext &context) {
418: 	return Value(context.profiler->IsDetailedEnabled() ? "detailed" : "standard");
419: }
420: 
421: //===--------------------------------------------------------------------===//
422: // Progress Bar Time
423: //===--------------------------------------------------------------------===//
424: void ProgressBarTimeSetting::SetLocal(ClientContext &context, const Value &input) {
425: 	ClientConfig::GetConfig(context).wait_time = input.GetValue<int32_t>();
426: 	ClientConfig::GetConfig(context).enable_progress_bar = true;
427: }
428: 
429: Value ProgressBarTimeSetting::GetSetting(ClientContext &context) {
430: 	return Value::BIGINT(ClientConfig::GetConfig(context).wait_time);
431: }
432: 
433: //===--------------------------------------------------------------------===//
434: // Schema
435: //===--------------------------------------------------------------------===//
436: void SchemaSetting::SetLocal(ClientContext &context, const Value &input) {
437: 	auto parameter = input.ToString();
438: 	context.catalog_search_path->Set(parameter, true);
439: }
440: 
441: Value SchemaSetting::GetSetting(ClientContext &context) {
442: 	return SearchPathSetting::GetSetting(context);
443: }
444: 
445: //===--------------------------------------------------------------------===//
446: // Search Path
447: //===--------------------------------------------------------------------===//
448: void SearchPathSetting::SetLocal(ClientContext &context, const Value &input) {
449: 	auto parameter = input.ToString();
450: 	context.catalog_search_path->Set(parameter, false);
451: }
452: 
453: Value SearchPathSetting::GetSetting(ClientContext &context) {
454: 	return Value(StringUtil::Join(context.catalog_search_path->GetSetPaths(), ","));
455: }
456: 
457: //===--------------------------------------------------------------------===//
458: // Temp Directory
459: //===--------------------------------------------------------------------===//
460: void TempDirectorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
461: 	config.temporary_directory = input.ToString();
462: 	config.use_temporary_directory = !config.temporary_directory.empty();
463: 	if (db) {
464: 		auto &buffer_manager = BufferManager::GetBufferManager(*db);
465: 		buffer_manager.SetTemporaryDirectory(config.temporary_directory);
466: 	}
467: }
468: 
469: Value TempDirectorySetting::GetSetting(ClientContext &context) {
470: 	auto &buffer_manager = BufferManager::GetBufferManager(context);
471: 	return Value(buffer_manager.GetTemporaryDirectory());
472: }
473: 
474: //===--------------------------------------------------------------------===//
475: // Threads Setting
476: //===--------------------------------------------------------------------===//
477: void ThreadsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
478: 	config.maximum_threads = input.GetValue<int64_t>();
479: 	if (db) {
480: 		TaskScheduler::GetScheduler(*db).SetThreads(config.maximum_threads);
481: 	}
482: }
483: 
484: Value ThreadsSetting::GetSetting(ClientContext &context) {
485: 	auto &config = DBConfig::GetConfig(context);
486: 	return Value::BIGINT(config.maximum_threads);
487: }
488: 
489: } // namespace duckdb
[end of src/main/settings/settings.cpp]
[start of src/optimizer/cse_optimizer.cpp]
1: #include "duckdb/optimizer/cse_optimizer.hpp"
2: 
3: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
4: #include "duckdb/planner/expression_iterator.hpp"
5: #include "duckdb/planner/operator/logical_filter.hpp"
6: #include "duckdb/planner/operator/logical_projection.hpp"
7: #include "duckdb/planner/column_binding_map.hpp"
8: #include "duckdb/planner/binder.hpp"
9: 
10: namespace duckdb {
11: 
12: //! The CSENode contains information about a common subexpression; how many times it occurs, and the column index in the
13: //! underlying projection
14: struct CSENode {
15: 	idx_t count;
16: 	idx_t column_index;
17: 
18: 	CSENode() : count(1), column_index(DConstants::INVALID_INDEX) {
19: 	}
20: };
21: 
22: //! The CSEReplacementState
23: struct CSEReplacementState {
24: 	//! The projection index of the new projection
25: 	idx_t projection_index;
26: 	//! Map of expression -> CSENode
27: 	expression_map_t<CSENode> expression_count;
28: 	//! Map of column bindings to column indexes in the projection expression list
29: 	column_binding_map_t<idx_t> column_map;
30: 	//! The set of expressions of the resulting projection
31: 	vector<unique_ptr<Expression>> expressions;
32: };
33: 
34: void CommonSubExpressionOptimizer::VisitOperator(LogicalOperator &op) {
35: 	switch (op.type) {
36: 	case LogicalOperatorType::LOGICAL_PROJECTION:
37: 	case LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY:
38: 		ExtractCommonSubExpresions(op);
39: 		break;
40: 	default:
41: 		break;
42: 	}
43: 	LogicalOperatorVisitor::VisitOperator(op);
44: }
45: 
46: void CommonSubExpressionOptimizer::CountExpressions(Expression &expr, CSEReplacementState &state) {
47: 	// we only consider expressions with children for CSE elimination
48: 	switch (expr.expression_class) {
49: 	case ExpressionClass::BOUND_COLUMN_REF:
50: 	case ExpressionClass::BOUND_CONSTANT:
51: 	case ExpressionClass::BOUND_PARAMETER:
52: 		return;
53: 	default:
54: 		break;
55: 	}
56: 	if (expr.expression_class != ExpressionClass::BOUND_AGGREGATE && !expr.HasSideEffects()) {
57: 		// we can't move aggregates to a projection, so we only consider the children of the aggregate
58: 		auto node = state.expression_count.find(&expr);
59: 		if (node == state.expression_count.end()) {
60: 			// first time we encounter this expression, insert this node with [count = 1]
61: 			state.expression_count[&expr] = CSENode();
62: 		} else {
63: 			// we encountered this expression before, increment the occurrence count
64: 			node->second.count++;
65: 		}
66: 	}
67: 	// recursively count the children
68: 	ExpressionIterator::EnumerateChildren(expr, [&](Expression &child) { CountExpressions(child, state); });
69: }
70: 
71: void CommonSubExpressionOptimizer::PerformCSEReplacement(unique_ptr<Expression> *expr_ptr, CSEReplacementState &state) {
72: 	Expression &expr = **expr_ptr;
73: 	if (expr.expression_class == ExpressionClass::BOUND_COLUMN_REF) {
74: 		auto &bound_column_ref = (BoundColumnRefExpression &)expr;
75: 		// bound column ref, check if this one has already been recorded in the expression list
76: 		auto column_entry = state.column_map.find(bound_column_ref.binding);
77: 		if (column_entry == state.column_map.end()) {
78: 			// not there yet: push the expression
79: 			idx_t new_column_index = state.expressions.size();
80: 			state.column_map[bound_column_ref.binding] = new_column_index;
81: 			state.expressions.push_back(make_unique<BoundColumnRefExpression>(
82: 			    bound_column_ref.alias, bound_column_ref.return_type, bound_column_ref.binding));
83: 			bound_column_ref.binding = ColumnBinding(state.projection_index, new_column_index);
84: 		} else {
85: 			// else: just update the column binding!
86: 			bound_column_ref.binding = ColumnBinding(state.projection_index, column_entry->second);
87: 		}
88: 		return;
89: 	}
90: 	// check if this child is eligible for CSE elimination
91: 	if (state.expression_count.find(&expr) != state.expression_count.end()) {
92: 		auto &node = state.expression_count[&expr];
93: 		if (node.count > 1) {
94: 			// this expression occurs more than once! push it into the projection
95: 			// check if it has already been pushed into the projection
96: 			auto alias = expr.alias;
97: 			auto type = expr.return_type;
98: 			if (node.column_index == DConstants::INVALID_INDEX) {
99: 				// has not been pushed yet: push it
100: 				node.column_index = state.expressions.size();
101: 				state.expressions.push_back(move(*expr_ptr));
102: 			}
103: 			// replace the original expression with a bound column ref
104: 			*expr_ptr = make_unique<BoundColumnRefExpression>(alias, type,
105: 			                                                  ColumnBinding(state.projection_index, node.column_index));
106: 			return;
107: 		}
108: 	}
109: 	// this expression only occurs once, we can't perform CSE elimination
110: 	// look into the children to see if we can replace them
111: 	ExpressionIterator::EnumerateChildren(expr,
112: 	                                      [&](unique_ptr<Expression> &child) { PerformCSEReplacement(&child, state); });
113: }
114: 
115: void CommonSubExpressionOptimizer::ExtractCommonSubExpresions(LogicalOperator &op) {
116: 	D_ASSERT(op.children.size() == 1);
117: 
118: 	// first we count for each expression with children how many types it occurs
119: 	CSEReplacementState state;
120: 	LogicalOperatorVisitor::EnumerateExpressions(
121: 	    op, [&](unique_ptr<Expression> *child) { CountExpressions(**child, state); });
122: 	// check if there are any expressions to extract
123: 	bool perform_replacement = false;
124: 	for (auto &expr : state.expression_count) {
125: 		if (expr.second.count > 1) {
126: 			perform_replacement = true;
127: 			break;
128: 		}
129: 	}
130: 	if (!perform_replacement) {
131: 		// no CSEs to extract
132: 		return;
133: 	}
134: 	state.projection_index = binder.GenerateTableIndex();
135: 	// we found common subexpressions to extract
136: 	// now we iterate over all the expressions and perform the actual CSE elimination
137: 	LogicalOperatorVisitor::EnumerateExpressions(
138: 	    op, [&](unique_ptr<Expression> *child) { PerformCSEReplacement(child, state); });
139: 	D_ASSERT(state.expressions.size() > 0);
140: 	// create a projection node as the child of this node
141: 	auto projection = make_unique<LogicalProjection>(state.projection_index, move(state.expressions));
142: 	projection->children.push_back(move(op.children[0]));
143: 	op.children[0] = move(projection);
144: }
145: 
146: } // namespace duckdb
[end of src/optimizer/cse_optimizer.cpp]
[start of src/optimizer/rule/in_clause_simplification_rule.cpp]
1: #include "duckdb/execution/expression_executor.hpp"
2: #include "duckdb/optimizer/rule/in_clause_simplification.hpp"
3: #include "duckdb/planner/expression/list.hpp"
4: #include "duckdb/planner/expression/bound_operator_expression.hpp"
5: 
6: namespace duckdb {
7: 
8: InClauseSimplificationRule::InClauseSimplificationRule(ExpressionRewriter &rewriter) : Rule(rewriter) {
9: 	// match on InClauseExpression that has a ConstantExpression as a check
10: 	auto op = make_unique<InClauseExpressionMatcher>();
11: 	op->policy = SetMatcher::Policy::SOME;
12: 	root = move(op);
13: }
14: 
15: unique_ptr<Expression> InClauseSimplificationRule::Apply(LogicalOperator &op, vector<Expression *> &bindings,
16:                                                          bool &changes_made, bool is_root) {
17: 	D_ASSERT(bindings[0]->expression_class == ExpressionClass::BOUND_OPERATOR);
18: 	auto expr = (BoundOperatorExpression *)bindings[0];
19: 	if (expr->children[0]->expression_class != ExpressionClass::BOUND_CAST) {
20: 		return nullptr;
21: 	}
22: 	auto cast_expression = (BoundCastExpression *)expr->children[0].get();
23: 	if (cast_expression->child->expression_class != ExpressionClass::BOUND_COLUMN_REF) {
24: 		return nullptr;
25: 	}
26: 	//! Here we check if we can apply the expression on the constant side
27: 	auto target_type = cast_expression->source_type();
28: 	if (!BoundCastExpression::CastIsInvertible(target_type, cast_expression->return_type)) {
29: 		return nullptr;
30: 	}
31: 	vector<unique_ptr<BoundConstantExpression>> cast_list;
32: 	//! First check if we can cast all children
33: 	for (size_t i = 1; i < expr->children.size(); i++) {
34: 		if (expr->children[i]->expression_class != ExpressionClass::BOUND_CONSTANT) {
35: 			return nullptr;
36: 		}
37: 		D_ASSERT(expr->children[i]->IsFoldable());
38: 		auto constant_value = ExpressionExecutor::EvaluateScalar(*expr->children[i]);
39: 		auto new_constant = constant_value.TryCastAs(target_type);
40: 		if (!new_constant) {
41: 			return nullptr;
42: 		} else {
43: 			auto new_constant_expr = make_unique<BoundConstantExpression>(constant_value);
44: 			cast_list.push_back(move(new_constant_expr));
45: 		}
46: 	}
47: 	//! We can cast, so we move the new constant
48: 	for (size_t i = 1; i < expr->children.size(); i++) {
49: 		expr->children[i] = move(cast_list[i - 1]);
50: 
51: 		//		expr->children[i] = move(new_constant_expr);
52: 	}
53: 	//! We can cast the full list, so we move the column
54: 	expr->children[0] = move(cast_expression->child);
55: 	return nullptr;
56: }
57: 
58: } // namespace duckdb
[end of src/optimizer/rule/in_clause_simplification_rule.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: