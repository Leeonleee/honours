{
  "repo": "duckdb/duckdb",
  "pull_number": 2686,
  "instance_id": "duckdb__duckdb-2686",
  "issue_numbers": [
    "2685",
    "2685"
  ],
  "base_commit": "01bdd7ce8930a960ad4e9ded58f29efa8fb65cda",
  "patch": "diff --git a/src/common/enums/optimizer_type.cpp b/src/common/enums/optimizer_type.cpp\nindex 09541b417907..08dd7e348115 100644\n--- a/src/common/enums/optimizer_type.cpp\n+++ b/src/common/enums/optimizer_type.cpp\n@@ -1,43 +1,54 @@\n #include \"duckdb/common/enums/optimizer_type.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n \n #include \"duckdb/common/exception.hpp\"\n \n namespace duckdb {\n \n+struct DefaultOptimizerType {\n+\tconst char *name;\n+\tOptimizerType type;\n+};\n+\n+static DefaultOptimizerType internal_optimizer_types[] = {\n+    {\"expression_rewriter\", OptimizerType::EXPRESSION_REWRITER},\n+    {\"filter_pullup\", OptimizerType::FILTER_PULLUP},\n+    {\"filter_pushdown\", OptimizerType::FILTER_PUSHDOWN},\n+    {\"regex_range\", OptimizerType::REGEX_RANGE},\n+    {\"in_clause\", OptimizerType::IN_CLAUSE},\n+    {\"join_order\", OptimizerType::JOIN_ORDER},\n+    {\"deliminator\", OptimizerType::DELIMINATOR},\n+    {\"unused_columns\", OptimizerType::UNUSED_COLUMNS},\n+    {\"statistics_propagation\", OptimizerType::STATISTICS_PROPAGATION},\n+    {\"common_subexpressions\", OptimizerType::COMMON_SUBEXPRESSIONS},\n+    {\"common_aggregate\", OptimizerType::COMMON_AGGREGATE},\n+    {\"column_lifetime\", OptimizerType::COLUMN_LIFETIME},\n+    {\"top_n\", OptimizerType::TOP_N},\n+    {\"reorder_filter\", OptimizerType::REORDER_FILTER},\n+    {nullptr, OptimizerType::INVALID}};\n+\n string OptimizerTypeToString(OptimizerType type) {\n-\tswitch (type) {\n-\tcase OptimizerType::EXPRESSION_REWRITER:\n-\t\treturn \"expression_rewriter\";\n-\tcase OptimizerType::FILTER_PULLUP:\n-\t\treturn \"filter_pullup\";\n-\tcase OptimizerType::FILTER_PUSHDOWN:\n-\t\treturn \"filter_pushdown\";\n-\tcase OptimizerType::REGEX_RANGE:\n-\t\treturn \"regex_range\";\n-\tcase OptimizerType::IN_CLAUSE:\n-\t\treturn \"in_clause\";\n-\tcase OptimizerType::JOIN_ORDER:\n-\t\treturn \"join_order\";\n-\tcase OptimizerType::DELIMINATOR:\n-\t\treturn \"deliminator\";\n-\tcase OptimizerType::UNUSED_COLUMNS:\n-\t\treturn \"unused_columns\";\n-\tcase OptimizerType::STATISTICS_PROPAGATION:\n-\t\treturn \"statistics_propagation\";\n-\tcase OptimizerType::COMMON_SUBEXPRESSIONS:\n-\t\treturn \"common_subexpressions\";\n-\tcase OptimizerType::COMMON_AGGREGATE:\n-\t\treturn \"common_aggregate\";\n-\tcase OptimizerType::COLUMN_LIFETIME:\n-\t\treturn \"column_lifetime\";\n-\tcase OptimizerType::TOP_N:\n-\t\treturn \"top_n\";\n-\tcase OptimizerType::REORDER_FILTER:\n-\t\treturn \"reorder_filter\";\n-\tcase OptimizerType::INVALID: // LCOV_EXCL_START\n-\t\tbreak;\n+\tfor (idx_t i = 0; internal_optimizer_types[i].name; i++) {\n+\t\tif (internal_optimizer_types[i].type == type) {\n+\t\t\treturn internal_optimizer_types[i].name;\n+\t\t}\n+\t}\n+\tthrow InternalException(\"Invalid optimizer type\");\n+}\n+\n+OptimizerType OptimizerTypeFromString(const string &str) {\n+\tfor (idx_t i = 0; internal_optimizer_types[i].name; i++) {\n+\t\tif (internal_optimizer_types[i].name == str) {\n+\t\t\treturn internal_optimizer_types[i].type;\n+\t\t}\n+\t}\n+\t// optimizer not found, construct candidate list\n+\tvector<string> optimizer_names;\n+\tfor (idx_t i = 0; internal_optimizer_types[i].name; i++) {\n+\t\toptimizer_names.emplace_back(internal_optimizer_types[i].name);\n \t}\n-\treturn \"INVALID\"; // LCOV_EXCL_STOP\n+\tthrow ParserException(\"Optimizer type \\\"%s\\\" not recognized\\n%s\", str,\n+\t                      StringUtil::CandidatesErrorMessage(optimizer_names, str, \"Candidate optimizers\"));\n }\n \n } // namespace duckdb\ndiff --git a/src/common/string_util.cpp b/src/common/string_util.cpp\nindex 9f83dddda044..ffad3ec6600f 100644\n--- a/src/common/string_util.cpp\n+++ b/src/common/string_util.cpp\n@@ -292,4 +292,10 @@ string StringUtil::CandidatesMessage(const vector<string> &candidates, const str\n \treturn result_str;\n }\n \n+string StringUtil::CandidatesErrorMessage(const vector<string> &strings, const string &target,\n+                                          const string &message_prefix, idx_t n) {\n+\tauto closest_strings = StringUtil::TopNLevenshtein(strings, target, n);\n+\treturn StringUtil::CandidatesMessage(closest_strings, message_prefix);\n+}\n+\n } // namespace duckdb\ndiff --git a/src/execution/operator/helper/physical_set.cpp b/src/execution/operator/helper/physical_set.cpp\nindex f4b78df8b3db..5994bab6b793 100644\n--- a/src/execution/operator/helper/physical_set.cpp\n+++ b/src/execution/operator/helper/physical_set.cpp\n@@ -23,9 +23,9 @@ void PhysicalSet::GetData(ExecutionContext &context, DataChunk &chunk, GlobalSou\n \t\t\tfor (auto &entry : config.extension_parameters) {\n \t\t\t\tpotential_names.push_back(entry.first);\n \t\t\t}\n-\t\t\tauto closest_settings = StringUtil::TopNLevenshtein(potential_names, name);\n+\n \t\t\tthrow CatalogException(\"unrecognized configuration parameter \\\"%s\\\"\\n%s\", name,\n-\t\t\t                       StringUtil::CandidatesMessage(closest_settings, \"Did you mean\"));\n+\t\t\t                       StringUtil::CandidatesErrorMessage(potential_names, name, \"Did you mean\"));\n \t\t}\n \t\t//! it is!\n \t\tauto &extension_option = entry->second;\ndiff --git a/src/include/duckdb/common/enums/optimizer_type.hpp b/src/include/duckdb/common/enums/optimizer_type.hpp\nindex be5a9661b50f..8d1e77e6f3fe 100644\n--- a/src/include/duckdb/common/enums/optimizer_type.hpp\n+++ b/src/include/duckdb/common/enums/optimizer_type.hpp\n@@ -31,5 +31,6 @@ enum class OptimizerType : uint32_t {\n };\n \n string OptimizerTypeToString(OptimizerType type);\n+OptimizerType OptimizerTypeFromString(const string &str);\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/common/string_util.hpp b/src/include/duckdb/common/string_util.hpp\nindex 13a82bbb0f6f..69b3935f6515 100644\n--- a/src/include/duckdb/common/string_util.hpp\n+++ b/src/include/duckdb/common/string_util.hpp\n@@ -120,5 +120,11 @@ class StringUtil {\n \t                                                 idx_t threshold = 5);\n \tDUCKDB_API static string CandidatesMessage(const vector<string> &candidates,\n \t                                           const string &candidate = \"Candidate bindings\");\n+\n+\t//! Generate an error message in the form of \"{message_prefix}: nearest_string, nearest_string2, ...\n+\t//! Equivalent to calling TopNLevenshtein followed by CandidatesMessage\n+\tDUCKDB_API static string CandidatesErrorMessage(const vector<string> &strings, const string &target,\n+\t                                                const string &message_prefix, idx_t n = 5);\n };\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp\nindex d3edc18277e0..92f9c16af500 100644\n--- a/src/include/duckdb/main/settings.hpp\n+++ b/src/include/duckdb/main/settings.hpp\n@@ -92,6 +92,14 @@ struct DefaultNullOrderSetting {\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n+struct DisabledOptimizersSetting {\n+\tstatic constexpr const char *Name = \"disabled_optimizers\";\n+\tstatic constexpr const char *Description = \"DEBUG SETTING: disable a specific set of optimizers (comma separated)\";\n+\tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n+\tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic Value GetSetting(ClientContext &context);\n+};\n+\n struct EnableExternalAccessSetting {\n \tstatic constexpr const char *Name = \"enable_external_access\";\n \tstatic constexpr const char *Description =\ndiff --git a/src/main/config.cpp b/src/main/config.cpp\nindex 2eec1927c288..2ea78415f8ea 100644\n--- a/src/main/config.cpp\n+++ b/src/main/config.cpp\n@@ -31,6 +31,7 @@ static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting\n                                                  DUCKDB_GLOBAL_LOCAL(DefaultCollationSetting),\n                                                  DUCKDB_GLOBAL(DefaultOrderSetting),\n                                                  DUCKDB_GLOBAL(DefaultNullOrderSetting),\n+                                                 DUCKDB_GLOBAL(DisabledOptimizersSetting),\n                                                  DUCKDB_GLOBAL(EnableExternalAccessSetting),\n                                                  DUCKDB_GLOBAL(EnableObjectCacheSetting),\n                                                  DUCKDB_LOCAL(EnableProfilingSetting),\ndiff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp\nindex 6a2fdbeb915c..27c99b778216 100644\n--- a/src/main/settings/settings.cpp\n+++ b/src/main/settings/settings.cpp\n@@ -199,6 +199,35 @@ Value DefaultNullOrderSetting::GetSetting(ClientContext &context) {\n \t}\n }\n \n+//===--------------------------------------------------------------------===//\n+// Disabled Optimizer\n+//===--------------------------------------------------------------------===//\n+void DisabledOptimizersSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {\n+\tauto list = StringUtil::Split(input.ToString(), \",\");\n+\tset<OptimizerType> disabled_optimizers;\n+\tfor (auto &entry : list) {\n+\t\tauto param = StringUtil::Lower(entry);\n+\t\tStringUtil::Trim(param);\n+\t\tif (param.empty()) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tdisabled_optimizers.insert(OptimizerTypeFromString(param));\n+\t}\n+\tconfig.disabled_optimizers = move(disabled_optimizers);\n+}\n+\n+Value DisabledOptimizersSetting::GetSetting(ClientContext &context) {\n+\tauto &config = DBConfig::GetConfig(context);\n+\tstring result;\n+\tfor (auto &optimizer : config.disabled_optimizers) {\n+\t\tif (!result.empty()) {\n+\t\t\tresult += \",\";\n+\t\t}\n+\t\tresult += OptimizerTypeToString(optimizer);\n+\t}\n+\treturn Value(result);\n+}\n+\n //===--------------------------------------------------------------------===//\n // Enable External Access\n //===--------------------------------------------------------------------===//\ndiff --git a/src/optimizer/cse_optimizer.cpp b/src/optimizer/cse_optimizer.cpp\nindex 930ba5a0b5ef..97c62fbc7365 100644\n--- a/src/optimizer/cse_optimizer.cpp\n+++ b/src/optimizer/cse_optimizer.cpp\n@@ -49,6 +49,9 @@ void CommonSubExpressionOptimizer::CountExpressions(Expression &expr, CSEReplace\n \tcase ExpressionClass::BOUND_COLUMN_REF:\n \tcase ExpressionClass::BOUND_CONSTANT:\n \tcase ExpressionClass::BOUND_PARAMETER:\n+\t// skip conjunctions and case, since short-circuiting might be incorrectly disabled otherwise\n+\tcase ExpressionClass::BOUND_CONJUNCTION:\n+\tcase ExpressionClass::BOUND_CASE:\n \t\treturn;\n \tdefault:\n \t\tbreak;\n@@ -88,7 +91,9 @@ void CommonSubExpressionOptimizer::PerformCSEReplacement(unique_ptr<Expression>\n \t\treturn;\n \t}\n \t// check if this child is eligible for CSE elimination\n-\tif (state.expression_count.find(&expr) != state.expression_count.end()) {\n+\tbool can_cse = expr.expression_class != ExpressionClass::BOUND_CONJUNCTION &&\n+\t               expr.expression_class != ExpressionClass::BOUND_CASE;\n+\tif (can_cse && state.expression_count.find(&expr) != state.expression_count.end()) {\n \t\tauto &node = state.expression_count[&expr];\n \t\tif (node.count > 1) {\n \t\t\t// this expression occurs more than once! push it into the projection\ndiff --git a/src/optimizer/rule/in_clause_simplification_rule.cpp b/src/optimizer/rule/in_clause_simplification_rule.cpp\nindex fcbd8939cd50..5c3d6c618b17 100644\n--- a/src/optimizer/rule/in_clause_simplification_rule.cpp\n+++ b/src/optimizer/rule/in_clause_simplification_rule.cpp\n@@ -25,7 +25,7 @@ unique_ptr<Expression> InClauseSimplificationRule::Apply(LogicalOperator &op, ve\n \t}\n \t//! Here we check if we can apply the expression on the constant side\n \tauto target_type = cast_expression->source_type();\n-\tif (!BoundCastExpression::CastIsInvertible(target_type, cast_expression->return_type)) {\n+\tif (!BoundCastExpression::CastIsInvertible(cast_expression->return_type, target_type)) {\n \t\treturn nullptr;\n \t}\n \tvector<unique_ptr<BoundConstantExpression>> cast_list;\n",
  "test_patch": "diff --git a/test/issues/rigger/rowid_in_clause.test b/test/issues/rigger/rowid_in_clause.test\nnew file mode 100644\nindex 000000000000..b8e111d22654\n--- /dev/null\n+++ b/test/issues/rigger/rowid_in_clause.test\n@@ -0,0 +1,63 @@\n+# name: test/issues/rigger/rowid_in_clause.test\n+# description: SQLancer bug that detected an error in the IN-clause simplification when different types were used\n+# group: [rigger]\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+statement ok\n+CREATE TABLE t0(c0 VARCHAR);\n+\n+statement ok\n+CREATE TABLE t1(c0 VARCHAR);\n+\n+statement ok\n+INSERT INTO t0(c0) VALUES (1);\n+\n+statement ok\n+INSERT INTO t1(c0) VALUES (-1);\n+\n+query II\n+SELECT * FROM t0, t1;\n+----\n+1\t-1\n+\n+query II\n+SELECT * FROM t0, t1 WHERE (t0.rowid IN (0.1))\n+----\n+\n+query II\n+SELECT * FROM t0, t1 WHERE (NOT (t0.rowid IN (0.1)))\n+----\n+1\t-1\n+\n+query II\n+SELECT * FROM t0, t1 WHERE (((t0.rowid IN (0.1))) IS NULL);\n+----\n+\n+query II\n+SELECT * FROM t0, t1 WHERE (t0.rowid IN (0.1))\n+UNION ALL\n+SELECT * FROM t0, t1 WHERE (NOT (t0.rowid IN (0.1)))\n+UNION ALL\n+SELECT * FROM t0, t1 WHERE (((t0.rowid IN (0.1))) IS NULL);\n+----\n+1\t-1\n+\n+query II\n+SELECT * FROM t0, t1 WHERE (t0.rowid IN (0.1::REAL))\n+UNION ALL\n+SELECT * FROM t0, t1 WHERE (NOT (t0.rowid IN (0.1::REAL)))\n+UNION ALL\n+SELECT * FROM t0, t1 WHERE (((t0.rowid IN (0.1::REAL))) IS NULL);\n+----\n+1\t-1\n+\n+query II\n+SELECT * FROM t0, t1 WHERE (t0.rowid IN (0.1::DOUBLE))\n+UNION ALL\n+SELECT * FROM t0, t1 WHERE (NOT (t0.rowid IN (0.1::DOUBLE)))\n+UNION ALL\n+SELECT * FROM t0, t1 WHERE (((t0.rowid IN (0.1::DOUBLE))) IS NULL);\n+----\n+1\t-1\n\\ No newline at end of file\ndiff --git a/test/sql/function/generic/case_short_circuit.test b/test/sql/function/generic/case_short_circuit.test\nnew file mode 100644\nindex 000000000000..ee824df8625b\n--- /dev/null\n+++ b/test/sql/function/generic/case_short_circuit.test\n@@ -0,0 +1,23 @@\n+# name: test/sql/function/generic/case_short_circuit.test\n+# description: Test correct CASE statement short circuiting\n+# group: [generic]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create table t (n text);\n+\n+statement ok\n+insert into t values ('1'),('0'),('');\n+\n+query II\n+select n, case \n+when n <> '' and cast(substr(n, 1, 1) as int) <= 0 then '0' \n+when n <> '' and cast(substr(n, 1, 1) as int) > 0 then '1' \n+else '2'end as x from t\n+ORDER BY n;\n+----\n+(empty)\t2\n+0\t0\n+1\t1\ndiff --git a/test/sql/settings/setting_disabled_optimizer.test b/test/sql/settings/setting_disabled_optimizer.test\nnew file mode 100644\nindex 000000000000..6f2b7fd2b5fb\n--- /dev/null\n+++ b/test/sql/settings/setting_disabled_optimizer.test\n@@ -0,0 +1,21 @@\n+# name: test/sql/settings/setting_disabled_optimizer.test\n+# description: Test disabled optimizers setting\n+# group: [settings]\n+\n+statement ok\n+SET disabled_optimizers=''\n+\n+statement ok\n+SET disabled_optimizers TO 'expression_rewriter'\n+\n+statement ok\n+SET disabled_optimizers TO 'expression_rewriter,filter_pushdown,join_order'\n+\n+statement ok\n+SELECT current_setting('disabled_optimizers');\n+\n+statement error\n+SET disabled_optimizers TO 'expression_rewriteX'\n+\n+statement error\n+SET disabled_optimizers TO 'unknown_optimizer'\n",
  "problem_statement": "CASE WHEN logical expression not short circuiting properly \n#### What happens?\r\nLogical expression in `CASE WHEN` is not short circuiting properly. For example `CASE WHEN a AND b`, `b` is also evaluated when `a` is FALSE.\r\n\r\n#### To Reproduce\r\n\r\n```SQL\r\ndrop table t;\r\ncreate table t (n text);\r\ninsert into t values ('1'),('0'),('');\r\nselect n, case \r\nwhen n <> '' and cast(substr(n, 1, 1) as int) <= 0 then '0' \r\nwhen n <> '' and cast(substr(n, 1, 1) as int) > 0 then '1' \r\nelse '2'end as x from t;\r\n```\r\nThe above code gets an error:\r\n```\r\nError: Conversion Error: Could not convert string '' to INT32\r\n```\r\n\r\nBut if delete one `WHEN` statement, a correct result could be yield:\r\n```SQL\r\ndrop table t;\r\ncreate table t (n text);\r\ninsert into t values ('1'),('0'),('');\r\nselect n, case \r\nwhen n <> '' and cast(substr(n, 1, 1) as int) <= 0 then '0' \r\nelse '2'end as x from t;\r\n```\r\nResult:\r\n```\r\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\r\n\u2502 n \u2502 x \u2502\r\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\r\n\u2502 1 \u2502 2 \u2502\r\n\u2502 0 \u2502 0 \u2502\r\n\u2502   \u2502 2 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: v0.3.2-dev175 847e60d0f \r\n - DuckDB Client: cli\r\n\r\n#### Before Submitting\r\n\r\n- [YES ] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [ YES] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nCASE WHEN logical expression not short circuiting properly \n#### What happens?\r\nLogical expression in `CASE WHEN` is not short circuiting properly. For example `CASE WHEN a AND b`, `b` is also evaluated when `a` is FALSE.\r\n\r\n#### To Reproduce\r\n\r\n```SQL\r\ndrop table t;\r\ncreate table t (n text);\r\ninsert into t values ('1'),('0'),('');\r\nselect n, case \r\nwhen n <> '' and cast(substr(n, 1, 1) as int) <= 0 then '0' \r\nwhen n <> '' and cast(substr(n, 1, 1) as int) > 0 then '1' \r\nelse '2'end as x from t;\r\n```\r\nThe above code gets an error:\r\n```\r\nError: Conversion Error: Could not convert string '' to INT32\r\n```\r\n\r\nBut if delete one `WHEN` statement, a correct result could be yield:\r\n```SQL\r\ndrop table t;\r\ncreate table t (n text);\r\ninsert into t values ('1'),('0'),('');\r\nselect n, case \r\nwhen n <> '' and cast(substr(n, 1, 1) as int) <= 0 then '0' \r\nelse '2'end as x from t;\r\n```\r\nResult:\r\n```\r\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\r\n\u2502 n \u2502 x \u2502\r\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\r\n\u2502 1 \u2502 2 \u2502\r\n\u2502 0 \u2502 0 \u2502\r\n\u2502   \u2502 2 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: v0.3.2-dev175 847e60d0f \r\n - DuckDB Client: cli\r\n\r\n#### Before Submitting\r\n\r\n- [YES ] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [ YES] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "I'm not sure short-circuiting is a standard behavior in ANSI SQL, but I've tried PostgreSQL/SQLite of which both produce proper and consistent short-circuiting result.\r\n\nThanks for the report!\r\n\r\nNot sure about the SQL standard either, but short circuiting should happen. Will have a look.\nI'm not sure short-circuiting is a standard behavior in ANSI SQL, but I've tried PostgreSQL/SQLite of which both produce proper and consistent short-circuiting result.\r\n\nThanks for the report!\r\n\r\nNot sure about the SQL standard either, but short circuiting should happen. Will have a look.",
  "created_at": "2021-11-29T10:32:39Z"
}