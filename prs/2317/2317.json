{
  "repo": "duckdb/duckdb",
  "pull_number": 2317,
  "instance_id": "duckdb__duckdb-2317",
  "issue_numbers": [
    "155"
  ],
  "base_commit": "c1d8a4cd21a0e43e7c4b016ce03f30813ccf3411",
  "patch": "diff --git a/src/catalog/CMakeLists.txt b/src/catalog/CMakeLists.txt\nindex 093b94015f24..0d993535535e 100644\n--- a/src/catalog/CMakeLists.txt\n+++ b/src/catalog/CMakeLists.txt\n@@ -1,8 +1,14 @@\n add_subdirectory(catalog_entry)\n add_subdirectory(default)\n \n-add_library_unity(duckdb_catalog OBJECT catalog_entry.cpp catalog.cpp\n-                  catalog_set.cpp dependency_manager.cpp)\n+add_library_unity(\n+  duckdb_catalog\n+  OBJECT\n+  catalog_entry.cpp\n+  catalog.cpp\n+  catalog_search_path.cpp\n+  catalog_set.cpp\n+  dependency_manager.cpp)\n set(ALL_OBJECT_FILES\n     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_catalog>\n     PARENT_SCOPE)\ndiff --git a/src/catalog/catalog.cpp b/src/catalog/catalog.cpp\nindex 9fd86d3d3cef..f7ea736beef8 100644\n--- a/src/catalog/catalog.cpp\n+++ b/src/catalog/catalog.cpp\n@@ -2,6 +2,7 @@\n #include \"duckdb/catalog/catalog_set.hpp\"\n \n #include \"duckdb/catalog/catalog_entry/list.hpp\"\n+#include \"duckdb/catalog/catalog_search_path.hpp\"\n #include \"duckdb/common/exception.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n #include \"duckdb/parser/expression/function_expression.hpp\"\n@@ -25,6 +26,12 @@\n \n namespace duckdb {\n \n+string SimilarCatalogEntry::GetQualifiedName() const {\n+\tD_ASSERT(Found());\n+\n+\treturn name + \".\" + schema->name;\n+}\n+\n Catalog::Catalog(DatabaseInstance &db)\n     : db(db), schemas(make_unique<CatalogSet>(*this, make_unique<DefaultSchemaGenerator>(*this))),\n       dependency_manager(make_unique<DependencyManager>(*this)) {\n@@ -147,23 +154,25 @@ void Catalog::DropEntry(ClientContext &context, DropInfo *info) {\n \tif (info->type == CatalogType::SCHEMA_ENTRY) {\n \t\t// DROP SCHEMA\n \t\tDropSchema(context, info);\n-\t} else {\n-\t\tif (info->schema.empty()) {\n-\t\t\tinfo->schema = DEFAULT_SCHEMA;\n-\t\t}\n-\t\tauto schema = GetSchema(context, info->schema);\n-\t\tschema->DropEntry(context, info);\n+\t\treturn;\n+\t}\n+\n+\tauto lookup = LookupEntry(context, info->type, info->schema, info->name, info->if_exists);\n+\tif (!lookup.Found()) {\n+\t\treturn;\n \t}\n+\n+\tlookup.schema->DropEntry(context, info);\n }\n \n-SchemaCatalogEntry *Catalog::GetSchema(ClientContext &context, const string &schema_name,\n+SchemaCatalogEntry *Catalog::GetSchema(ClientContext &context, const string &schema_name, bool if_exists,\n                                        QueryErrorContext error_context) {\n \tD_ASSERT(!schema_name.empty());\n \tif (schema_name == TEMP_SCHEMA) {\n \t\treturn context.temporary_objects.get();\n \t}\n \tauto entry = schemas->GetEntry(context, schema_name);\n-\tif (!entry) {\n+\tif (!entry && !if_exists) {\n \t\tthrow CatalogException(error_context.FormatError(\"Schema with name %s does not exist!\", schema_name));\n \t}\n \treturn (SchemaCatalogEntry *)entry;\n@@ -174,29 +183,99 @@ void Catalog::ScanSchemas(ClientContext &context, std::function<void(CatalogEntr\n \tschemas->Scan(context, [&](CatalogEntry *entry) { callback(entry); });\n }\n \n-CatalogEntry *Catalog::GetEntry(ClientContext &context, CatalogType type, string schema_name, const string &name,\n-                                bool if_exists, QueryErrorContext error_context) {\n-\tif (schema_name.empty()) {\n-\t\t// no schema provided: check the catalog search path in order\n-\t\tif (context.catalog_search_path.empty()) {\n-\t\t\tthrow InternalException(\"Empty catalog search path\");\n+SimilarCatalogEntry Catalog::SimilarEntryInSchemas(ClientContext &context, const string &entry_name, CatalogType type,\n+                                                   const vector<SchemaCatalogEntry *> &schemas) {\n+\n+\tvector<CatalogSet *> sets;\n+\tstd::transform(schemas.begin(), schemas.end(), std::back_inserter(sets),\n+\t               [type](SchemaCatalogEntry *s) -> CatalogSet * { return &s->GetCatalogSet(type); });\n+\tpair<string, idx_t> most_similar {\"\", (idx_t)-1};\n+\tSchemaCatalogEntry *schema_of_most_similar = nullptr;\n+\tfor (auto schema : schemas) {\n+\t\tauto entry = schema->GetCatalogSet(type).SimilarEntry(context, entry_name);\n+\t\tif (!entry.first.empty() && (most_similar.first.empty() || most_similar.second > entry.second)) {\n+\t\t\tmost_similar = entry;\n+\t\t\tschema_of_most_similar = schema;\n \t\t}\n-\t\tschema_name = DEFAULT_SCHEMA;\n-\t\tfor (idx_t i = 0; i < context.catalog_search_path.size(); i++) {\n-\t\t\tauto entry = GetEntry(context, type, context.catalog_search_path[i], name, true);\n-\t\t\tif (entry) {\n-\t\t\t\treturn entry;\n+\t}\n+\n+\treturn {most_similar.first, most_similar.second, schema_of_most_similar};\n+}\n+\n+CatalogException Catalog::CreateMissingEntryException(ClientContext &context, const string &entry_name,\n+                                                      CatalogType type, const vector<SchemaCatalogEntry *> &schemas,\n+                                                      QueryErrorContext error_context) {\n+\tauto entry = SimilarEntryInSchemas(context, entry_name, type, schemas);\n+\n+\tvector<SchemaCatalogEntry *> unseen_schemas;\n+\tthis->schemas->Scan([&schemas, &unseen_schemas](CatalogEntry *entry) {\n+\t\tauto schema_entry = (SchemaCatalogEntry *)entry;\n+\t\tif (std::find(schemas.begin(), schemas.end(), schema_entry) == schemas.end()) {\n+\t\t\tunseen_schemas.emplace_back(schema_entry);\n+\t\t}\n+\t});\n+\tauto unseen_entry = SimilarEntryInSchemas(context, entry_name, type, unseen_schemas);\n+\n+\tstring did_you_mean;\n+\tif (unseen_entry.Found() && unseen_entry.distance < entry.distance) {\n+\t\tdid_you_mean = \"\\nDid you mean \\\"\" + unseen_entry.GetQualifiedName() + \"\\\"?\";\n+\t} else if (entry.Found()) {\n+\t\tdid_you_mean = \"\\nDid you mean \\\"\" + entry.name + \"\\\"?\";\n+\t}\n+\n+\treturn CatalogException(error_context.FormatError(\"%s with name %s does not exist!%s\", CatalogTypeToString(type),\n+\t                                                  entry_name, did_you_mean));\n+}\n+\n+CatalogEntryLookup Catalog::LookupEntry(ClientContext &context, CatalogType type, const string &schema_name,\n+                                        const string &name, bool if_exists, QueryErrorContext error_context) {\n+\tif (!schema_name.empty()) {\n+\t\tauto schema = GetSchema(context, schema_name, if_exists, error_context);\n+\t\tif (!schema) {\n+\t\t\tD_ASSERT(if_exists);\n+\t\t\treturn {nullptr, nullptr};\n+\t\t}\n+\n+\t\tauto entry = schema->GetCatalogSet(type).GetEntry(context, name);\n+\t\tif (!entry && !if_exists) {\n+\t\t\tthrow CreateMissingEntryException(context, name, type, {schema}, error_context);\n+\t\t}\n+\n+\t\treturn {schema, entry};\n+\t}\n+\n+\tconst auto &paths = context.catalog_search_path->Get();\n+\tfor (const auto &path : paths) {\n+\t\tauto lookup = LookupEntry(context, type, path, name, true, error_context);\n+\t\tif (lookup.Found()) {\n+\t\t\treturn lookup;\n+\t\t}\n+\t}\n+\n+\tif (!if_exists) {\n+\t\tvector<SchemaCatalogEntry *> schemas;\n+\t\tfor (const auto &path : paths) {\n+\t\t\tauto schema = GetSchema(context, path, true);\n+\t\t\tif (schema) {\n+\t\t\t\tschemas.emplace_back(schema);\n \t\t\t}\n \t\t}\n+\n+\t\tthrow CreateMissingEntryException(context, name, type, schemas, error_context);\n \t}\n-\tauto schema = GetSchema(context, schema_name, error_context);\n-\treturn schema->GetEntry(context, type, name, if_exists, error_context);\n+\n+\treturn {nullptr, nullptr};\n+}\n+\n+CatalogEntry *Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema_name, const string &name,\n+                                bool if_exists, QueryErrorContext error_context) {\n+\treturn LookupEntry(context, type, schema_name, name, if_exists, error_context).entry;\n }\n \n template <>\n-TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,\n-                                     QueryErrorContext error_context) {\n-\tauto entry = GetEntry(context, CatalogType::TABLE_ENTRY, move(schema_name), name, if_exists);\n+TableCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n+                                     bool if_exists, QueryErrorContext error_context) {\n+\tauto entry = GetEntry(context, CatalogType::TABLE_ENTRY, schema_name, name, if_exists);\n \tif (!entry) {\n \t\treturn nullptr;\n \t}\n@@ -207,38 +286,37 @@ TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name,\n }\n \n template <>\n-SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,\n-                                        QueryErrorContext error_context) {\n-\treturn (SequenceCatalogEntry *)GetEntry(context, CatalogType::SEQUENCE_ENTRY, move(schema_name), name, if_exists,\n+SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n+                                        bool if_exists, QueryErrorContext error_context) {\n+\treturn (SequenceCatalogEntry *)GetEntry(context, CatalogType::SEQUENCE_ENTRY, schema_name, name, if_exists,\n \t                                        error_context);\n }\n \n template <>\n-TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,\n+TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n                                              bool if_exists, QueryErrorContext error_context) {\n-\treturn (TableFunctionCatalogEntry *)GetEntry(context, CatalogType::TABLE_FUNCTION_ENTRY, move(schema_name), name,\n+\treturn (TableFunctionCatalogEntry *)GetEntry(context, CatalogType::TABLE_FUNCTION_ENTRY, schema_name, name,\n \t                                             if_exists, error_context);\n }\n \n template <>\n-CopyFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,\n+CopyFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n                                             bool if_exists, QueryErrorContext error_context) {\n-\treturn (CopyFunctionCatalogEntry *)GetEntry(context, CatalogType::COPY_FUNCTION_ENTRY, move(schema_name), name,\n-\t                                            if_exists, error_context);\n+\treturn (CopyFunctionCatalogEntry *)GetEntry(context, CatalogType::COPY_FUNCTION_ENTRY, schema_name, name, if_exists,\n+\t                                            error_context);\n }\n \n template <>\n-PragmaFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,\n+PragmaFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n                                               bool if_exists, QueryErrorContext error_context) {\n-\treturn (PragmaFunctionCatalogEntry *)GetEntry(context, CatalogType::PRAGMA_FUNCTION_ENTRY, move(schema_name), name,\n+\treturn (PragmaFunctionCatalogEntry *)GetEntry(context, CatalogType::PRAGMA_FUNCTION_ENTRY, schema_name, name,\n \t                                              if_exists, error_context);\n }\n \n template <>\n-AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,\n+AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n                                                  bool if_exists, QueryErrorContext error_context) {\n-\tauto entry =\n-\t    GetEntry(context, CatalogType::AGGREGATE_FUNCTION_ENTRY, move(schema_name), name, if_exists, error_context);\n+\tauto entry = GetEntry(context, CatalogType::AGGREGATE_FUNCTION_ENTRY, schema_name, name, if_exists, error_context);\n \tif (entry->type != CatalogType::AGGREGATE_FUNCTION_ENTRY) {\n \t\tthrow CatalogException(error_context.FormatError(\"%s is not an aggregate function\", name));\n \t}\n@@ -246,29 +324,17 @@ AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string\n }\n \n template <>\n-CollateCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,\n-                                       QueryErrorContext error_context) {\n-\treturn (CollateCatalogEntry *)GetEntry(context, CatalogType::COLLATION_ENTRY, move(schema_name), name, if_exists,\n+CollateCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n+                                       bool if_exists, QueryErrorContext error_context) {\n+\treturn (CollateCatalogEntry *)GetEntry(context, CatalogType::COLLATION_ENTRY, schema_name, name, if_exists,\n \t                                       error_context);\n }\n \n void Catalog::Alter(ClientContext &context, AlterInfo *info) {\n \tModifyCatalog();\n-\tif (info->schema.empty()) {\n-\t\tauto catalog_type = info->GetCatalogType();\n-\t\t// invalid schema: search the catalog search path\n-\t\tinfo->schema = DEFAULT_SCHEMA;\n-\t\tfor (idx_t i = 0; i < context.catalog_search_path.size(); i++) {\n-\t\t\tauto entry = GetEntry(context, catalog_type, context.catalog_search_path[i], info->name, true);\n-\t\t\tif (entry) {\n-\t\t\t\t// entry exists in this schema: alter there\n-\t\t\t\tinfo->schema = context.catalog_search_path[i];\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t}\n-\tauto schema = GetSchema(context, info->schema);\n-\treturn schema->Alter(context, info);\n+\tauto lookup = LookupEntry(context, info->GetCatalogType(), info->schema, info->name);\n+\tD_ASSERT(lookup.Found()); // It must have thrown otherwise.\n+\treturn lookup.schema->Alter(context, info);\n }\n \n idx_t Catalog::GetCatalogVersion() {\ndiff --git a/src/catalog/catalog_entry/schema_catalog_entry.cpp b/src/catalog/catalog_entry/schema_catalog_entry.cpp\nindex 02e2ca898ddb..b7d673cf53e6 100644\n--- a/src/catalog/catalog_entry/schema_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/schema_catalog_entry.cpp\n@@ -181,26 +181,6 @@ void SchemaCatalogEntry::Alter(ClientContext &context, AlterInfo *info) {\n \t}\n }\n \n-CatalogEntry *SchemaCatalogEntry::GetEntry(ClientContext &context, CatalogType type, const string &entry_name,\n-                                           bool if_exists, QueryErrorContext error_context) {\n-\tauto &set = GetCatalogSet(type);\n-\n-\tauto entry = set.GetEntry(context, entry_name);\n-\tif (!entry) {\n-\t\tif (!if_exists) {\n-\t\t\tauto entry = set.SimilarEntry(context, entry_name);\n-\t\t\tstring did_you_mean;\n-\t\t\tif (!entry.empty()) {\n-\t\t\t\tdid_you_mean = \"\\nDid you mean \\\"\" + entry + \"\\\"?\";\n-\t\t\t}\n-\t\t\tthrow CatalogException(error_context.FormatError(\"%s with name %s does not exist!%s\",\n-\t\t\t                                                 CatalogTypeToString(type), entry_name, did_you_mean));\n-\t\t}\n-\t\treturn nullptr;\n-\t}\n-\treturn entry;\n-}\n-\n void SchemaCatalogEntry::Scan(ClientContext &context, CatalogType type,\n                               const std::function<void(CatalogEntry *)> &callback) {\n \tauto &set = GetCatalogSet(type);\ndiff --git a/src/catalog/catalog_search_path.cpp b/src/catalog/catalog_search_path.cpp\nnew file mode 100644\nindex 000000000000..3346b265ea94\n--- /dev/null\n+++ b/src/catalog/catalog_search_path.cpp\n@@ -0,0 +1,45 @@\n+#include \"duckdb/catalog/catalog_search_path.hpp\"\n+\n+#include \"duckdb/common/constants.hpp\"\n+#include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/main/client_context.hpp\"\n+\n+namespace duckdb {\n+\n+CatalogSearchPath::CatalogSearchPath(ClientContext &context_p) : context(context_p), paths(ParsePaths(\"\")) {\n+}\n+\n+const vector<string> &CatalogSearchPath::Get() {\n+\tValue value;\n+\tcontext.TryGetCurrentSetting(\"search_path\", value);\n+\tif (value.str_value != last_value) {\n+\t\tpaths = ParsePaths(value.str_value);\n+\t\tlast_value = value.str_value;\n+\t}\n+\n+\treturn paths;\n+}\n+\n+const string &CatalogSearchPath::GetDefault() {\n+\tconst auto &paths = Get();\n+\tD_ASSERT(paths.size() >= 2);\n+\tD_ASSERT(paths[0] == TEMP_SCHEMA);\n+\treturn paths[1];\n+}\n+\n+vector<string> CatalogSearchPath::ParsePaths(const string &value) {\n+\tvector<string> paths;\n+\tpaths.emplace_back(TEMP_SCHEMA);\n+\n+\tauto given_paths = StringUtil::SplitWithQuote(value);\n+\tfor (const auto &p : given_paths) {\n+\t\tpaths.emplace_back(StringUtil::Lower(p));\n+\t}\n+\n+\tpaths.emplace_back(DEFAULT_SCHEMA);\n+\tpaths.emplace_back(\"pg_catalog\");\n+\treturn paths;\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/catalog/catalog_set.cpp b/src/catalog/catalog_set.cpp\nindex 38aaf7a5c668..f27a86da63cf 100644\n--- a/src/catalog/catalog_set.cpp\n+++ b/src/catalog/catalog_set.cpp\n@@ -307,7 +307,7 @@ CatalogEntry *CatalogSet::GetCommittedEntry(CatalogEntry *current) {\n \treturn current;\n }\n \n-string CatalogSet::SimilarEntry(ClientContext &context, const string &name) {\n+pair<string, idx_t> CatalogSet::SimilarEntry(ClientContext &context, const string &name) {\n \tlock_guard<mutex> lock(catalog_lock);\n \n \tstring result;\n@@ -322,7 +322,7 @@ string CatalogSet::SimilarEntry(ClientContext &context, const string &name) {\n \t\t\t}\n \t\t}\n \t}\n-\treturn result;\n+\treturn {result, current_score};\n }\n \n CatalogEntry *CatalogSet::CreateEntryInternal(ClientContext &context, unique_ptr<CatalogEntry> entry) {\ndiff --git a/src/common/string_util.cpp b/src/common/string_util.cpp\nindex 4f7d2e0409bb..9f83dddda044 100644\n--- a/src/common/string_util.cpp\n+++ b/src/common/string_util.cpp\n@@ -2,6 +2,7 @@\n #include \"duckdb/common/pair.hpp\"\n #include \"duckdb/common/to_string.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/common/exception.hpp\"\n \n #include <algorithm>\n #include <cctype>\n@@ -68,6 +69,65 @@ vector<string> StringUtil::Split(const string &str, char delimiter) {\n \treturn (lines);\n }\n \n+namespace string_util_internal {\n+\n+inline void SkipSpaces(const string &str, idx_t &index) {\n+\twhile (index < str.size() && std::isspace(str[index])) {\n+\t\tindex++;\n+\t}\n+}\n+\n+inline void ConsumeLetter(const string &str, idx_t &index, char expected) {\n+\tif (index >= str.size() || str[index] != expected) {\n+\t\tthrow ParserException(\"Invalid quoted list: %s\", str);\n+\t}\n+\n+\tindex++;\n+}\n+\n+template <typename F>\n+inline void TakeWhile(const string &str, idx_t &index, const F &cond, string &taker) {\n+\twhile (index < str.size() && cond(str[index])) {\n+\t\ttaker.push_back(str[index]);\n+\t\tindex++;\n+\t}\n+}\n+\n+inline string TakePossiblyQuotedItem(const string &str, idx_t &index, char delimiter, char quote) {\n+\tstring entry;\n+\n+\tif (str[index] == quote) {\n+\t\tindex++;\n+\t\tTakeWhile(\n+\t\t    str, index, [quote](char c) { return c != quote; }, entry);\n+\t\tConsumeLetter(str, index, quote);\n+\t} else {\n+\t\tTakeWhile(\n+\t\t    str, index, [delimiter, quote](char c) { return c != delimiter && c != quote && !std::isspace(c); }, entry);\n+\t}\n+\n+\treturn entry;\n+}\n+\n+} // namespace string_util_internal\n+\n+vector<string> StringUtil::SplitWithQuote(const string &str, char delimiter, char quote) {\n+\tvector<string> entries;\n+\tidx_t i = 0;\n+\n+\tstring_util_internal::SkipSpaces(str, i);\n+\twhile (i < str.size()) {\n+\t\tif (!entries.empty()) {\n+\t\t\tstring_util_internal::ConsumeLetter(str, i, delimiter);\n+\t\t}\n+\n+\t\tentries.emplace_back(string_util_internal::TakePossiblyQuotedItem(str, i, delimiter, quote));\n+\t\tstring_util_internal::SkipSpaces(str, i);\n+\t}\n+\n+\treturn entries;\n+}\n+\n string StringUtil::Join(const vector<string> &input, const string &separator) {\n \treturn StringUtil::Join(input, input.size(), separator, [](const string &s) { return s; });\n }\ndiff --git a/src/execution/operator/helper/physical_set.cpp b/src/execution/operator/helper/physical_set.cpp\nindex 3674b4ad4a02..2ed2c9fbd572 100644\n--- a/src/execution/operator/helper/physical_set.cpp\n+++ b/src/execution/operator/helper/physical_set.cpp\n@@ -1,4 +1,6 @@\n #include \"duckdb/execution/operator/helper/physical_set.hpp\"\n+\n+#include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/main/database.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n \n@@ -7,13 +9,38 @@ namespace duckdb {\n void PhysicalSet::GetChunkInternal(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state) const {\n \tD_ASSERT(scope == SetScope::GLOBAL || scope == SetScope::SESSION);\n \n+\tauto normalized_name = ValidateInput(context);\n \tif (scope == SetScope::GLOBAL) {\n-\t\tcontext.client.db->config.set_variables[name] = value;\n+\t\tcontext.client.db->config.set_variables[normalized_name] = value;\n \t} else {\n-\t\tcontext.client.set_variables[name] = value;\n+\t\tcontext.client.set_variables[normalized_name] = value;\n \t}\n \n \tstate->finished = true;\n }\n \n+string PhysicalSet::ValidateInput(ExecutionContext &context) const {\n+\tCaseInsensitiveStringEquality case_insensitive_streq;\n+\tif (case_insensitive_streq(name, \"search_path\") || case_insensitive_streq(name, \"schema\")) {\n+\t\tauto paths = StringUtil::SplitWithQuote(value.str_value, ',');\n+\n+\t\t// The PG doc says:\n+\t\t// >  SET SCHEMA 'value' is an alias for SET search_path TO value.\n+\t\t// >  Only one schema can be specified using this syntax.\n+\t\tif (case_insensitive_streq(name, \"schema\") && paths.size() > 1) {\n+\t\t\tthrow CatalogException(\"SET schema can set only 1 schema. This has %d\", paths.size());\n+\t\t}\n+\n+\t\tfor (const auto &path : paths) {\n+\t\t\tif (!context.client.db->GetCatalog().GetSchema(context.client, StringUtil::Lower(path), true)) {\n+\t\t\t\tthrow CatalogException(\"SET %s: No schema named %s found.\", name, path);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn \"search_path\";\n+\t}\n+\n+\treturn name;\n+}\n+\n } // namespace duckdb\ndiff --git a/src/function/scalar/generic/current_setting.cpp b/src/function/scalar/generic/current_setting.cpp\nindex c43288546f20..b08e0059e484 100644\n--- a/src/function/scalar/generic/current_setting.cpp\n+++ b/src/function/scalar/generic/current_setting.cpp\n@@ -1,4 +1,5 @@\n #include \"duckdb/function/scalar/generic_functions.hpp\"\n+\n #include \"duckdb/main/database.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n #include \"duckdb/planner/expression/bound_function_expression.hpp\"\n@@ -24,6 +25,16 @@ static void CurrentSettingFunction(DataChunk &args, ExpressionState &state, Vect\n \tresult.Reference(info.value);\n }\n \n+static string NormalizeSettingName(const string &name) {\n+\tif (CaseInsensitiveStringEquality()(name, \"schema\")) {\n+\t\t// The PG doc says:\n+\t\t// >  SET SCHEMA 'value' is an alias for SET search_path TO value.\n+\t\treturn \"search_path\";\n+\t}\n+\n+\treturn name;\n+}\n+\n unique_ptr<FunctionData> CurrentSettingBind(ClientContext &context, ScalarFunction &bound_function,\n                                             vector<unique_ptr<Expression>> &arguments) {\n \n@@ -39,7 +50,7 @@ unique_ptr<FunctionData> CurrentSettingBind(ClientContext &context, ScalarFuncti\n \t\tthrow ParserException(\"Key name for struct_extract needs to be neither NULL nor empty\");\n \t}\n \n-\tconst auto &key = key_val.str_value;\n+\tconst auto &key = NormalizeSettingName(key_val.str_value);\n \tValue val;\n \tif (!context.TryGetCurrentSetting(key, val)) {\n \t\tthrow InvalidInputException(\"Variable '%s' was not SET in this context\", key);\ndiff --git a/src/include/duckdb/catalog/catalog.hpp b/src/include/duckdb/catalog/catalog.hpp\nindex 564752e134f4..702e0f5653e1 100644\n--- a/src/include/duckdb/catalog/catalog.hpp\n+++ b/src/include/duckdb/catalog/catalog.hpp\n@@ -44,6 +44,32 @@ class CatalogSet;\n class DatabaseInstance;\n class DependencyManager;\n \n+//! Return value of Catalog::LookupEntry\n+struct CatalogEntryLookup {\n+\tSchemaCatalogEntry *schema;\n+\tCatalogEntry *entry;\n+\n+\tbool Found() const {\n+\t\treturn entry;\n+\t}\n+};\n+\n+//! Return value of SimilarEntryInSchemas\n+struct SimilarCatalogEntry {\n+\t//! The entry name. Empty if absent\n+\tstring name;\n+\t//! The distance to the given name.\n+\tidx_t distance;\n+\t//! The schema of the entry.\n+\tSchemaCatalogEntry *schema;\n+\n+\tbool Found() const {\n+\t\treturn !name.empty();\n+\t}\n+\n+\tstring GetQualifiedName() const;\n+};\n+\n //! The Catalog object represents the catalog of the database.\n class Catalog {\n public:\n@@ -115,17 +141,17 @@ class Catalog {\n \tvoid DropEntry(ClientContext &context, DropInfo *info);\n \n \t//! Returns the schema object with the specified name, or throws an exception if it does not exist\n-\tSchemaCatalogEntry *GetSchema(ClientContext &context, const string &name = DEFAULT_SCHEMA,\n+\tSchemaCatalogEntry *GetSchema(ClientContext &context, const string &name = DEFAULT_SCHEMA, bool if_exists = false,\n \t                              QueryErrorContext error_context = QueryErrorContext());\n \t//! Scans all the schemas in the system one-by-one, invoking the callback for each entry\n \tvoid ScanSchemas(ClientContext &context, std::function<void(CatalogEntry *)> callback);\n \t//! Gets the \"schema.name\" entry of the specified type, if if_exists=true returns nullptr if entry does not exist,\n \t//! otherwise an exception is thrown\n-\tCatalogEntry *GetEntry(ClientContext &context, CatalogType type, string schema, const string &name,\n+\tCatalogEntry *GetEntry(ClientContext &context, CatalogType type, const string &schema, const string &name,\n \t                       bool if_exists = false, QueryErrorContext error_context = QueryErrorContext());\n \n \ttemplate <class T>\n-\tT *GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists = false,\n+\tT *GetEntry(ClientContext &context, const string &schema_name, const string &name, bool if_exists = false,\n \t            QueryErrorContext error_context = QueryErrorContext());\n \n \t//! Alter an existing entry in the catalog.\n@@ -136,29 +162,42 @@ class Catalog {\n \tatomic<idx_t> catalog_version;\n \n private:\n+\t//! A variation of GetEntry that returns an associated schema as well.\n+\tCatalogEntryLookup LookupEntry(ClientContext &context, CatalogType type, const string &schema, const string &name,\n+\t                               bool if_exists = false, QueryErrorContext error_context = QueryErrorContext());\n+\n+\t//! Return an exception with did-you-mean suggestion.\n+\tCatalogException CreateMissingEntryException(ClientContext &context, const string &entry_name, CatalogType type,\n+\t                                             const vector<SchemaCatalogEntry *> &schemas,\n+\t                                             QueryErrorContext error_context);\n+\n+\t//! Return the close entry name, the distance and the belonging schema.\n+\tSimilarCatalogEntry SimilarEntryInSchemas(ClientContext &context, const string &entry_name, CatalogType type,\n+\t                                          const vector<SchemaCatalogEntry *> &schemas);\n+\n \tvoid DropSchema(ClientContext &context, DropInfo *info);\n };\n \n template <>\n-TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,\n-                                     QueryErrorContext error_context);\n+TableCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n+                                     bool if_exists, QueryErrorContext error_context);\n template <>\n-SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,\n-                                        QueryErrorContext error_context);\n+SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n+                                        bool if_exists, QueryErrorContext error_context);\n template <>\n-TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,\n+TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n                                              bool if_exists, QueryErrorContext error_context);\n template <>\n-CopyFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,\n+CopyFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n                                             bool if_exists, QueryErrorContext error_context);\n template <>\n-PragmaFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,\n+PragmaFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n                                               bool if_exists, QueryErrorContext error_context);\n template <>\n-AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,\n+AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n                                                  bool if_exists, QueryErrorContext error_context);\n template <>\n-CollateCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,\n-                                       QueryErrorContext error_context);\n+CollateCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,\n+                                       bool if_exists, QueryErrorContext error_context);\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/catalog/catalog_entry/schema_catalog_entry.hpp b/src/include/duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\nindex 05167a19570b..ba8a9ec0c3c1 100644\n--- a/src/include/duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\n+++ b/src/include/duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\n@@ -64,10 +64,6 @@ class SchemaCatalogEntry : public CatalogEntry {\n \tCatalogSet collations;\n \n public:\n-\t//! Gets a catalog entry from the given catalog set matching the given name\n-\tCatalogEntry *GetEntry(ClientContext &context, CatalogType type, const string &name, bool if_exists,\n-\t                       QueryErrorContext error_context = QueryErrorContext());\n-\n \t//! Scan the specified catalog set, invoking the callback method for every entry\n \tvoid Scan(ClientContext &context, CatalogType type, const std::function<void(CatalogEntry *)> &callback);\n \t//! Scan the specified catalog set, invoking the callback method for every committed entry\ndiff --git a/src/include/duckdb/catalog/catalog_search_path.hpp b/src/include/duckdb/catalog/catalog_search_path.hpp\nnew file mode 100644\nindex 000000000000..f099f20510b3\n--- /dev/null\n+++ b/src/include/duckdb/catalog/catalog_search_path.hpp\n@@ -0,0 +1,37 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/catalog/catalog_search_path.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include <functional>\n+#include \"duckdb/common/enums/catalog_type.hpp\"\n+#include \"duckdb/common/string.hpp\"\n+#include \"duckdb/common/vector.hpp\"\n+#include \"duckdb/common/types/value.hpp\"\n+\n+namespace duckdb {\n+\n+class ClientContext;\n+\n+//! The schema search path, in order by which entries are searched if no schema entry is provided\n+class CatalogSearchPath {\n+public:\n+\texplicit CatalogSearchPath(ClientContext &client_p);\n+\tCatalogSearchPath(const CatalogSearchPath &other) = delete;\n+\n+\tconst vector<string> &Get();\n+\tconst string &GetDefault();\n+\n+private:\n+\tstatic vector<string> ParsePaths(const string &value);\n+\tClientContext &context;\n+\tstring last_value;\n+\tvector<string> paths;\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/catalog/catalog_set.hpp b/src/include/duckdb/catalog/catalog_set.hpp\nindex b807ffc9fef5..dd7efdfdf905 100644\n--- a/src/include/duckdb/catalog/catalog_set.hpp\n+++ b/src/include/duckdb/catalog/catalog_set.hpp\n@@ -12,6 +12,7 @@\n #include \"duckdb/catalog/default/default_generator.hpp\"\n #include \"duckdb/common/common.hpp\"\n #include \"duckdb/common/case_insensitive_map.hpp\"\n+#include \"duckdb/common/pair.hpp\"\n #include \"duckdb/common/unordered_set.hpp\"\n #include \"duckdb/common/mutex.hpp\"\n \n@@ -58,8 +59,8 @@ class CatalogSet {\n \tCatalogEntry *GetEntry(ClientContext &context, const string &name);\n \n \t//! Gets the entry that is most similar to the given name (i.e. smallest levenshtein distance), or empty string if\n-\t//! none is found\n-\tstring SimilarEntry(ClientContext &context, const string &name);\n+\t//! none is found. The returned pair consists of the entry name and the distance (smaller means closer).\n+\tpair<string, idx_t> SimilarEntry(ClientContext &context, const string &name);\n \n \t//! Rollback <entry> to be the currently valid entry for a certain catalog\n \t//! entry\ndiff --git a/src/include/duckdb/common/string_util.hpp b/src/include/duckdb/common/string_util.hpp\nindex d179954b402a..55b895e51c1d 100644\n--- a/src/include/duckdb/common/string_util.hpp\n+++ b/src/include/duckdb/common/string_util.hpp\n@@ -52,6 +52,9 @@ class StringUtil {\n \t//! Split the input string based on newline char\n \tstatic vector<string> Split(const string &str, char delimiter);\n \n+\t//! Split the input string allong a quote. Note that any escaping is NOT supported.\n+\tstatic vector<string> SplitWithQuote(const string &str, char delimiter = ',', char quote = '\"');\n+\n \t//! Join multiple strings into one string. Components are concatenated by the given separator\n \tstatic string Join(const vector<string> &input, const string &separator);\n \ndiff --git a/src/include/duckdb/execution/operator/helper/physical_set.hpp b/src/include/duckdb/execution/operator/helper/physical_set.hpp\nindex 15915685920f..24874e2dd6f1 100644\n--- a/src/include/duckdb/execution/operator/helper/physical_set.hpp\n+++ b/src/include/duckdb/execution/operator/helper/physical_set.hpp\n@@ -17,7 +17,7 @@ namespace duckdb {\n //! PhysicalSet represents a SET operation (e.g. SET a = 42)\n class PhysicalSet : public PhysicalOperator {\n public:\n-\tPhysicalSet(std::string name_p, Value value_p, SetScope scope_p, idx_t estimated_cardinality)\n+\tPhysicalSet(const std::string &name_p, Value value_p, SetScope scope_p, idx_t estimated_cardinality)\n \t    : PhysicalOperator(PhysicalOperatorType::SET, {LogicalType::BOOLEAN}, estimated_cardinality), name(name_p),\n \t      value(value_p), scope(scope_p) {\n \t}\n@@ -26,9 +26,13 @@ class PhysicalSet : public PhysicalOperator {\n \tvoid GetChunkInternal(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state) const override;\n \n public:\n-\tstd::string name;\n-\tValue value;\n-\tSetScope scope;\n+\tconst std::string name;\n+\tconst Value value;\n+\tconst SetScope scope;\n+\n+private:\n+\t//! Returns the normalized key name.\n+\tstring ValidateInput(ExecutionContext &context) const;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/main/client_context.hpp b/src/include/duckdb/main/client_context.hpp\nindex 29acb35c1266..e14a0c5f8682 100644\n--- a/src/include/duckdb/main/client_context.hpp\n+++ b/src/include/duckdb/main/client_context.hpp\n@@ -10,6 +10,7 @@\n \n #include \"duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\"\n #include \"duckdb/catalog/catalog_set.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n #include \"duckdb/common/deque.hpp\"\n #include \"duckdb/common/enums/output_type.hpp\"\n #include \"duckdb/common/pair.hpp\"\n@@ -27,6 +28,7 @@\n namespace duckdb {\n class Appender;\n class Catalog;\n+class CatalogSearchPath;\n class ChunkCollection;\n class DatabaseInstance;\n class FileOpener;\n@@ -76,7 +78,7 @@ class ClientContext : public std::enable_shared_from_this<ClientContext> {\n \tunique_ptr<SchemaCatalogEntry> temporary_objects;\n \tunordered_map<string, shared_ptr<PreparedStatementData>> prepared_statements;\n \n-\tunordered_map<string, Value> set_variables;\n+\tcase_insensitive_map_t<Value> set_variables;\n \n \t// Whether or not aggressive query verification is enabled\n \tbool query_verification_enabled = false;\n@@ -98,8 +100,7 @@ class ClientContext : public std::enable_shared_from_this<ClientContext> {\n \t//! The random generator used by random(). Its seed value can be set by setseed().\n \tstd::mt19937 random_engine;\n \n-\t//! The schema search path, in order by which entries are searched if no schema entry is provided\n-\tvector<string> catalog_search_path = {TEMP_SCHEMA, DEFAULT_SCHEMA, \"pg_catalog\"};\n+\tconst unique_ptr<CatalogSearchPath> catalog_search_path;\n \n \tunique_ptr<FileOpener> file_opener;\n \ndiff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp\nindex e44eb763ad1e..53d601b47503 100644\n--- a/src/include/duckdb/main/config.hpp\n+++ b/src/include/duckdb/main/config.hpp\n@@ -9,6 +9,7 @@\n #pragma once\n \n #include \"duckdb/common/allocator.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n #include \"duckdb/common/common.hpp\"\n #include \"duckdb/common/enums/order_type.hpp\"\n #include \"duckdb/common/file_system.hpp\"\n@@ -93,7 +94,7 @@ struct DBConfig {\n \t//! Whether or not object cache is used\n \tbool object_cache_enable = false;\n \t//! Database configuration variables as controlled by SET\n-\tunordered_map<std::string, Value> set_variables;\n+\tcase_insensitive_map_t<Value> set_variables;\n \t//! Force checkpoint when CHECKPOINT is called or on shutdown, even if no changes have been made\n \tbool force_checkpoint = false;\n \t//! Run a checkpoint on successful shutdown and delete the WAL, to leave only a single database file behind\ndiff --git a/src/include/duckdb/parser/parsed_data/create_function_info.hpp b/src/include/duckdb/parser/parsed_data/create_function_info.hpp\nindex 2f029fa8ee76..213bf875fcbb 100644\n--- a/src/include/duckdb/parser/parsed_data/create_function_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/create_function_info.hpp\n@@ -14,7 +14,7 @@\n namespace duckdb {\n \n struct CreateFunctionInfo : public CreateInfo {\n-\texplicit CreateFunctionInfo(CatalogType type) : CreateInfo(type) {\n+\texplicit CreateFunctionInfo(CatalogType type, string schema = DEFAULT_SCHEMA) : CreateInfo(type, schema) {\n \t\tD_ASSERT(type == CatalogType::SCALAR_FUNCTION_ENTRY || type == CatalogType::AGGREGATE_FUNCTION_ENTRY ||\n \t\t         type == CatalogType::TABLE_FUNCTION_ENTRY || type == CatalogType::PRAGMA_FUNCTION_ENTRY ||\n \t\t         type == CatalogType::MACRO_ENTRY);\ndiff --git a/src/include/duckdb/parser/parsed_data/create_macro_info.hpp b/src/include/duckdb/parser/parsed_data/create_macro_info.hpp\nindex f80142e795e7..31121738df8b 100644\n--- a/src/include/duckdb/parser/parsed_data/create_macro_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/create_macro_info.hpp\n@@ -14,7 +14,7 @@\n namespace duckdb {\n \n struct CreateMacroInfo : public CreateFunctionInfo {\n-\tCreateMacroInfo() : CreateFunctionInfo(CatalogType::MACRO_ENTRY) {\n+\tCreateMacroInfo() : CreateFunctionInfo(CatalogType::MACRO_ENTRY, INVALID_SCHEMA) {\n \t}\n \n \tunique_ptr<MacroFunction> function;\ndiff --git a/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp b/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp\nindex 690a66519147..1e8345667f40 100644\n--- a/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp\n@@ -15,8 +15,8 @@ namespace duckdb {\n \n struct CreateSequenceInfo : public CreateInfo {\n \tCreateSequenceInfo()\n-\t    : CreateInfo(CatalogType::SEQUENCE_ENTRY), name(string()), usage_count(0), increment(1), min_value(1),\n-\t      max_value(NumericLimits<int64_t>::Maximum()), start_value(1), cycle(false) {\n+\t    : CreateInfo(CatalogType::SEQUENCE_ENTRY, INVALID_SCHEMA), name(string()), usage_count(0), increment(1),\n+\t      min_value(1), max_value(NumericLimits<int64_t>::Maximum()), start_value(1), cycle(false) {\n \t}\n \n \t//! Sequence name to create\n@@ -39,6 +39,7 @@ struct CreateSequenceInfo : public CreateInfo {\n \t\tauto result = make_unique<CreateSequenceInfo>();\n \t\tCopyProperties(*result);\n \t\tresult->name = name;\n+\t\tresult->schema = schema;\n \t\tresult->usage_count = usage_count;\n \t\tresult->increment = increment;\n \t\tresult->min_value = min_value;\ndiff --git a/src/include/duckdb/parser/parsed_data/create_view_info.hpp b/src/include/duckdb/parser/parsed_data/create_view_info.hpp\nindex 4924bf658cf4..19c96e1c613c 100644\n--- a/src/include/duckdb/parser/parsed_data/create_view_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/create_view_info.hpp\n@@ -14,7 +14,7 @@\n namespace duckdb {\n \n struct CreateViewInfo : public CreateInfo {\n-\tCreateViewInfo() : CreateInfo(CatalogType::VIEW_ENTRY) {\n+\tCreateViewInfo() : CreateInfo(CatalogType::VIEW_ENTRY, INVALID_SCHEMA) {\n \t}\n \tCreateViewInfo(string schema, string view_name)\n \t    : CreateInfo(CatalogType::VIEW_ENTRY, schema), view_name(view_name) {\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex 683819e8764e..0a02933fc723 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -4,6 +4,7 @@\n #include \"duckdb/main/query_profiler.hpp\"\n #include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n #include \"duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp\"\n+#include \"duckdb/catalog/catalog_search_path.hpp\"\n #include \"duckdb/common/serializer/buffered_deserializer.hpp\"\n #include \"duckdb/common/serializer/buffered_serializer.hpp\"\n #include \"duckdb/execution/physical_plan_generator.hpp\"\n@@ -53,6 +54,7 @@ ClientContext::ClientContext(shared_ptr<DatabaseInstance> database)\n     : profiler(make_unique<QueryProfiler>()), query_profiler_history(make_unique<QueryProfilerHistory>()),\n       db(move(database)), transaction(db->GetTransactionManager(), *this), interrupted(false), executor(*this),\n       temporary_objects(make_unique<SchemaCatalogEntry>(&db->GetCatalog(), TEMP_SCHEMA, true)),\n+      catalog_search_path(make_unique<CatalogSearchPath>(*this)),\n       file_opener(make_unique<ClientContextFileOpener>(*this)), open_result(nullptr) {\n \tstd::random_device rd;\n \trandom_engine.seed(rd());\ndiff --git a/src/parser/transform/statement/transform_set.cpp b/src/parser/transform/statement/transform_set.cpp\nindex 79f01218f510..a3329b177ba8 100644\n--- a/src/parser/transform/statement/transform_set.cpp\n+++ b/src/parser/transform/statement/transform_set.cpp\n@@ -1,4 +1,5 @@\n #include \"duckdb/parser/statement/set_statement.hpp\"\n+\n #include \"duckdb/parser/transformer.hpp\"\n #include \"duckdb/parser/expression/constant_expression.hpp\"\n \ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex 7599f7d01314..ee254095f86c 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -1,4 +1,5 @@\n #include \"duckdb/catalog/catalog.hpp\"\n+#include \"duckdb/catalog/catalog_search_path.hpp\"\n #include \"duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n #include \"duckdb/parser/expression/subquery_expression.hpp\"\n@@ -26,7 +27,7 @@ namespace duckdb {\n \n SchemaCatalogEntry *Binder::BindSchema(CreateInfo &info) {\n \tif (info.schema.empty()) {\n-\t\tinfo.schema = info.temporary ? TEMP_SCHEMA : DEFAULT_SCHEMA;\n+\t\tinfo.schema = info.temporary ? TEMP_SCHEMA : context.catalog_search_path->GetDefault();\n \t}\n \n \tif (!info.temporary) {\n",
  "test_patch": "diff --git a/test/common/test_string_util.cpp b/test/common/test_string_util.cpp\nindex 6c6a6ce30aa1..76b2b6c0a753 100644\n--- a/test/common/test_string_util.cpp\n+++ b/test/common/test_string_util.cpp\n@@ -144,3 +144,87 @@ TEST_CASE(\"Test join vector items\", \"[string_util]\") {\n \t\tREQUIRE(result == \"\");\n \t}\n }\n+\n+TEST_CASE(\"Test split quoted strings\", \"[string_util]\") {\n+\tSECTION(\"Empty string\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"\") == vector<string> {});\n+\t}\n+\n+\tSECTION(\"Empty string with space\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\" \") == vector<string> {});\n+\t}\n+\n+\tSECTION(\"One item\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"x\") == vector<string> {\"x\"});\n+\t}\n+\n+\tSECTION(\"One item with space\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\" x \") == vector<string> {\"x\"});\n+\t}\n+\n+\tSECTION(\"One item with quote\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"\\\"x\\\"\") == vector<string> {\"x\"});\n+\t}\n+\n+\tSECTION(\"One empty item with quote\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"\\\"\\\"\") == vector<string> {\"\"});\n+\t}\n+\n+\tSECTION(\"One empty item, followed by non-empty one - Or vise versa\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"\\\"\\\",hello\") == vector<string> {\"\", \"hello\"});\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\",\\\"hello\\\"\") == vector<string> {\"\", \"hello\"});\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\",hello\") == vector<string> {\"\", \"hello\"});\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"\\\"\\\",\\\"hello\\\"\") == vector<string> {\"\", \"hello\"});\n+\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"\\\"hello\\\",\") == vector<string> {\"hello\", \"\"});\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"hello,\\\"\\\"\") == vector<string> {\"hello\", \"\"});\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"hello,\") == vector<string> {\"hello\", \"\"});\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"\\\"hello\\\",\\\"\\\"\") == vector<string> {\"hello\", \"\"});\n+\t}\n+\n+\tSECTION(\"One quoted item with spaces\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\" \\\" x y \\\" \") == vector<string> {\" x y \"});\n+\t}\n+\n+\tSECTION(\"One quoted item with a delimiter\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"\\\"x,y\\\"\") == vector<string> {\"x,y\"});\n+\t}\n+\n+\tSECTION(\"Three items\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"x,y,z\") == vector<string> {\"x\", \"y\", \"z\"});\n+\t}\n+\n+\tSECTION(\"Three items, with and without quote\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"x,\\\"y\\\",z\") == vector<string> {\"x\", \"y\", \"z\"});\n+\t}\n+\n+\tSECTION(\"Even more items, with and without quote\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"a,b,c,d,e,f,g\") == vector<string> {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"});\n+\t}\n+\n+\tSECTION(\"Three empty items\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\",,\") == vector<string> {\"\", \"\", \"\"});\n+\t}\n+\n+\tSECTION(\"Three empty quoted items\") {\n+\t\tREQUIRE(StringUtil::SplitWithQuote(\"\\\"\\\",\\\"\\\",\\\"\\\"\") == vector<string> {\"\", \"\", \"\"});\n+\t}\n+\n+\tSECTION(\"Unclosed quote\") {\n+\t\tREQUIRE_THROWS_AS(StringUtil::SplitWithQuote(\"\\\"\"), ParserException);\n+\t\tREQUIRE_THROWS_AS(StringUtil::SplitWithQuote(\"\\\"x\"), ParserException);\n+\t\tREQUIRE_THROWS_AS(StringUtil::SplitWithQuote(\"\\\"x \"), ParserException);\n+\t\tREQUIRE_THROWS_AS(StringUtil::SplitWithQuote(\"\\\",\"), ParserException);\n+\t\tREQUIRE_THROWS_AS(StringUtil::SplitWithQuote(\"\\\"x,\"), ParserException);\n+\t}\n+\n+\tSECTION(\"Unexpected quote\") {\n+\t\tREQUIRE_THROWS_AS(StringUtil::SplitWithQuote(\"abc\\\"def\"), ParserException);\n+\t}\n+\n+\tSECTION(\"Missing delimiter\") {\n+\t\tREQUIRE_THROWS_AS(StringUtil::SplitWithQuote(\"\\\"x\\\"\\\"y\\\"\"), ParserException);\n+\t\tREQUIRE_THROWS_AS(StringUtil::SplitWithQuote(\"\\\"x\\\" \\\"y\\\"\"), ParserException);\n+\t\tREQUIRE_THROWS_AS(StringUtil::SplitWithQuote(\"x y\"), ParserException);\n+\t}\n+}\n\\ No newline at end of file\ndiff --git a/test/sql/catalog/did_you_mean.test b/test/sql/catalog/did_you_mean.test\nnew file mode 100644\nindex 000000000000..2a8728ce52dc\n--- /dev/null\n+++ b/test/sql/catalog/did_you_mean.test\n@@ -0,0 +1,26 @@\n+# name: test/sql/catalog/did_you_mean.test\n+# Description: The error messages suggest possible alternative\n+# group: [catalog]\n+ \n+statement ok\n+CREATE TABLE hello(i INTEGER);\n+\n+statement ok\n+CREATE SCHEMA test;\n+\n+statement ok\n+CREATE TABLE test.bye(i INTEGER);\n+\n+statement error\n+SELECT * FROM helloo;\n+\n+# TODO(omo): Test the error message being like this:\n+# > Catalog Error: Table with name helloo does not exist!\n+# > Did you mean \"hello\"?\n+\n+statement error\n+SELECT * FROM bye;\n+\n+# TODO(omo): Test the error message being like this:\n+# > Catalog Error: Table with name bye does not exist!\n+# > Did you mean \"test.bye\"?\ndiff --git a/test/sql/catalog/test_if_not_exists.test b/test/sql/catalog/test_if_not_exists.test\nindex bc5f9814bdd2..b546d63454fc 100644\n--- a/test/sql/catalog/test_if_not_exists.test\n+++ b/test/sql/catalog/test_if_not_exists.test\n@@ -20,3 +20,6 @@ DROP TABLE IF EXISTS integers\n statement ok\n DROP TABLE IF EXISTS integers\n \n+statement ok\n+DROP TABLE IF EXISTS no_such_scheme.integers\n+\ndiff --git a/test/sql/catalog/test_set_schema.test b/test/sql/catalog/test_set_schema.test\nnew file mode 100644\nindex 000000000000..90433aa003dc\n--- /dev/null\n+++ b/test/sql/catalog/test_set_schema.test\n@@ -0,0 +1,403 @@\n+# name: test/sql/catalog/test_set_schema.test\n+# description: Default schema name changes\n+# group: [catalog]\n+\n+# This test focuses on actual name lookup.\n+# See also test_set_search_path.test\n+\n+statement ok\n+CREATE SCHEMA test;\n+\n+statement ok\n+CREATE SCHEMA out_of_path;\n+\n+statement ok\n+SET SESSION schema = 'test';\n+\n+# Testing CREATE TABLE\n+\n+statement ok\n+CREATE TABLE main.main_table(j INTEGER);\n+\n+statement ok\n+CREATE TABLE test_table(i INTEGER);\n+\n+statement ok\n+CREATE TABLE out_of_path.oop_table(k INTEGER);\n+\n+statement ok\n+SELECT * FROM test.test_table;\n+\n+statement ok\n+SELECT * FROM test_table;\n+\n+statement ok\n+SELECT * FROM main_table;\n+\n+statement ok\n+SELECT * FROM out_of_path.oop_table;\n+\n+statement error\n+SELECT * FROM out_of_path.test_table;\n+\n+statement error\n+SELECT * FROM main.test_table;\n+\n+# Testing INSERT, UPDATE and DELETE\n+\n+statement error\n+INSERT INTO main.test_table (i) VALUES (1);\n+\n+statement ok\n+INSERT INTO test_table (i) VALUES (1);\n+\n+statement ok\n+INSERT INTO test.test_table (i) VALUES (2), (3);\n+\n+statement ok\n+INSERT INTO main_table (j) VALUES (4);\n+\n+statement ok\n+INSERT INTO main.main_table (j) VALUES (5), (6);\n+\n+statement error\n+INSERT INTO oop_table (k) VALUES (7);\n+\n+statement ok\n+INSERT INTO out_of_path.oop_table (k) VALUES (8), (9);\n+\n+statement error\n+DELETE FROM main.test_table WHERE i=3;\n+\n+statement error\n+DELETE FROM test.main_table WHERE i=5;\n+\n+statement error\n+DELETE FROM oop_table WHERE k=8;\n+\n+statement ok\n+DELETE FROM test.test_table WHERE i=1;\n+\n+statement ok\n+DELETE FROM test_table WHERE i=2;\n+\n+statement ok\n+DELETE FROM main.main_table WHERE j=4;\n+\n+statement ok\n+DELETE FROM main_table WHERE j=5;\n+\n+statement ok\n+DELETE FROM out_of_path.oop_table WHERE k=8;\n+\n+query I\n+SELECT i FROM test_table;\n+----\n+3\n+\n+query I\n+SELECT j FROM main.main_table;\n+----\n+6\n+\n+query I\n+SELECT k FROM out_of_path.oop_table;\n+----\n+9\n+\n+statement error\n+UPDATE main.test_table SET i=10 WHERE i=1;\n+\n+statement ok\n+UPDATE test_table SET i=30 WHERE i=3;\n+\n+statement ok\n+UPDATE test.test_table SET i=300 WHERE i=30;\n+\n+statement ok\n+UPDATE main_table SET j=60 WHERE j=6;\n+\n+statement ok\n+UPDATE main.main_table SET j=600 WHERE j=60;\n+\n+query I\n+SELECT i FROM test_table;\n+----\n+300\n+\n+query I\n+SELECT j FROM main_table;\n+----\n+600\n+\n+# Testing temp table.\n+# test_temp_table should *not* be created in the test schema, but in the temp schema\n+\n+statement ok\n+CREATE TEMP TABLE test_temp_table(i INTEGER);\n+\n+statement error\n+SELECT * FROM main.test_temp_table;\n+\n+statement error\n+SELECT * FROM test.test_temp_table;\n+\n+statement ok\n+SELECT * FROM test_temp_table;\n+\n+# Testing functions and aggregates\n+query I\n+SELECT abs(i) FROM test_table;\n+----\n+300\n+\n+# aggregates should work as expected\n+query I\n+SELECT sum(i) FROM test_table;\n+----\n+300\n+\n+# Testing Views\n+statement ok\n+CREATE VIEW test_view AS SELECT * FROM test_table;\n+\n+statement ok\n+CREATE VIEW main.main_view AS SELECT * FROM main.main_table;\n+\n+statement ok\n+CREATE VIEW out_of_path.oop_view AS SELECT * FROM out_of_path.oop_table;\n+\n+statement error\n+SELECT * FROM main.test_view;\n+\n+statement ok\n+SELECT * FROM test.test_view;\n+\n+statement ok\n+SELECT * FROM test_view;\n+\n+statement ok\n+SELECT * FROM main.main_view;\n+\n+statement ok\n+SELECT * FROM main_view;\n+\n+statement error\n+SELECT * FROM oop_view;\n+\n+statement ok\n+SELECT * FROM out_of_path.oop_view;\n+\n+statement ok\n+SET SESSION schema = 'main';\n+\n+# Test view's schema being bound on definition.\n+statement error\n+CREATE VIEW bad_test_view AS SELECT * FROM test_table;\n+\n+# TODO(omo):\n+#   Currenly this fails because we bind the table name\n+#   when the view is actually used vs. defined.\n+#   This behavior is incompatible with PG.\n+# statement ok\n+# SELECT * FROM test.test_view;\n+\n+statement ok\n+SET SESSION schema = 'test';\n+\n+statement error\n+DROP VIEW main.test_view\n+\n+statement ok\n+DROP VIEW test_view\n+\n+statement ok\n+DROP VIEW main_view\n+\n+statement error\n+DROP VIEW oop_view\n+\n+statement ok\n+DROP VIEW out_of_path.oop_view\n+\n+# Testing Macros\n+\n+statement ok\n+CREATE MACRO test_macro(a, b) AS a + b;\n+\n+statement ok\n+CREATE MACRO test_macro2(c, d) AS c * d;\n+\n+statement ok\n+CREATE MACRO main.main_macro(a, b) AS a - b;\n+\n+statement ok\n+CREATE MACRO out_of_path.oop_macro(a, b) AS a * b;\n+\n+statement error\n+SELECT main.test_macro(1, 2);\n+\n+statement error\n+SELECT oop_macro(1, 2);\n+\n+statement ok\n+SELECT main_macro(1, 2);\n+\n+statement ok\n+SELECT main.main_macro(1, 2);\n+\n+statement ok\n+SELECT test.test_macro(1, 2);\n+\n+statement ok\n+SELECT test_macro(1, 2);\n+\n+statement ok\n+SELECT out_of_path.oop_macro(1, 2);\n+\n+statement error\n+DROP MACRO main.test_macro;\n+\n+statement ok\n+DROP MACRO test_macro;\n+\n+statement ok\n+DROP MACRO test.test_macro2;\n+\n+statement ok\n+DROP MACRO main_macro;\n+\n+statement error\n+DROP MACRO oop_macro;\n+\n+statement ok\n+DROP MACRO out_of_path.oop_macro;\n+\n+# Testing sequences.\n+\n+statement ok\n+CREATE SEQUENCE test_sequence;\n+\n+statement ok\n+CREATE SEQUENCE test_sequence2;\n+\n+statement ok\n+CREATE SEQUENCE main.main_sequence;\n+\n+statement ok\n+CREATE SEQUENCE out_of_path.oop_sequence;\n+\n+statement error\n+SELECT main.nextval('main.test_sequence');\n+\n+statement ok\n+SELECT main.nextval('test.test_sequence');\n+\n+statement ok\n+SELECT main.nextval('test_sequence');\n+\n+statement ok\n+SELECT main.nextval('main.main_sequence');\n+\n+statement ok\n+SELECT main.nextval('main_sequence');\n+\n+statement error\n+SELECT main.nextval('oop_sequence');\n+\n+statement ok\n+SELECT main.nextval('out_of_path.oop_sequence');\n+\n+statement error\n+DROP SEQUENCE main.test_sequence;\n+\n+statement ok\n+DROP SEQUENCE test_sequence;\n+\n+statement ok\n+DROP SEQUENCE test.test_sequence2;\n+\n+statement ok\n+DROP SEQUENCE main_sequence;\n+\n+statement error\n+DROP SEQUENCE oop_sequence;\n+\n+statement ok\n+DROP SEQUENCE out_of_path.oop_sequence;\n+\n+# Testing ALTER TABLE\n+\n+statement error\n+ALTER TABLE main.test_table ADD COLUMN k INTEGER;\n+\n+statement ok\n+ALTER TABLE main.main_table ADD COLUMN k INTEGER;\n+\n+statement ok\n+ALTER TABLE main_table ADD COLUMN l INTEGER;\n+\n+statement ok\n+ALTER TABLE test_table ADD COLUMN m INTEGER;\n+\n+statement ok\n+ALTER TABLE test.test_table ADD COLUMN n INTEGER;\n+\n+statement error\n+ALTER TABLE oop_table ADD COLUMN o INTEGER;\n+\n+statement ok\n+ALTER TABLE out_of_path.oop_table ADD COLUMN p INTEGER;\n+\n+# Testing DROP TABLE\n+\n+statement error\n+DROP TABLE main.test_table;\n+\n+statement error\n+DROP TABLE test.main_table;\n+\n+statement ok\n+DROP TABLE test_table;\n+\n+statement ok\n+DROP TABLE main_table;\n+\n+statement error\n+DROP TABLE oop_table;\n+\n+statement ok\n+DROP TABLE out_of_path.oop_table;\n+\n+statement ok\n+CREATE TABLE test_table2(i INTEGER);\n+\n+statement ok\n+DROP TABLE test.test_table2;\n+\n+statement ok\n+CREATE TABLE test_table3(i INTEGER);\n+\n+statement ok\n+DROP TABLE IF EXISTS test_table3;\n+\n+statement ok\n+DROP TABLE IF EXISTS test_table3;\n+\n+statement ok\n+CREATE TABLE test_table4(i INTEGER);\n+\n+statement ok\n+DROP TABLE IF EXISTS test.test_table4;\n+\n+statement ok\n+DROP TABLE IF EXISTS test.test_table4;\n+\n+statement ok\n+CREATE TABLE main.main_table2(i INTEGER);\n+\n+statement ok\n+DROP TABLE IF EXISTS main.main_table2;\n+\n+statement ok\n+DROP TABLE IF EXISTS main.main_table2;\ndiff --git a/test/sql/catalog/test_set_search_path.test b/test/sql/catalog/test_set_search_path.test\nnew file mode 100644\nindex 000000000000..c4ed76f82d64\n--- /dev/null\n+++ b/test/sql/catalog/test_set_search_path.test\n@@ -0,0 +1,204 @@\n+# name: test/sql/catalog/test_set_search_path.test\n+# description: SET schema and SET search_path\n+# group: [catalog]\n+\n+# create a couple of schemas with a table each\n+statement ok\n+CREATE TABLE main_table(i INTEGER);\n+\n+statement ok\n+CREATE SCHEMA test;\n+\n+statement ok\n+CREATE TABLE test.test_table(i INTEGER);\n+\n+statement ok\n+CREATE SCHEMA test2;\n+\n+statement ok\n+CREATE TABLE test2.bye(i INTEGER);\n+CREATE TABLE test2.test2_table(i INTEGER);\n+\n+statement ok\n+CREATE SCHEMA test3;\n+\n+statement ok\n+CREATE SCHEMA test4;\n+\n+statement ok\n+CREATE SCHEMA test5;\n+\n+statement ok\n+CREATE TABLE test5.test5_table(i INTEGER);\n+\n+# Reading the config - It should be empty for now.\n+statement error\n+SELECT CURRENT_SETTING('search_path');\n+\n+statement error\n+SELECT CURRENT_SETTING('schema');\n+\n+# Setting the default value.\n+statement ok\n+SET SEARCH_PATH = 'test';\n+\n+statement ok\n+SET SEARCH_PATH = 'test,test2';\n+\n+statement ok\n+SET SEARCH_PATH = '\"test\",\"test2\"';\n+\n+statement ok\n+SET SEARCH_PATH = '\"test\",\"test2\"';\n+\n+statement error\n+SET SEARCH_PATH = 'does_not_exist';\n+\n+# Setting the default value through 'schema'\n+\n+statement ok\n+SET SCHEMA = 'test';\n+\n+statement error\n+SET SCHEMA = 'test,test2';\n+\n+statement error\n+SET SCHEMA = 'does_not_exist';\n+\n+# Reading out to see how aliasing works.\n+\n+statement ok\n+SET SEARCH_PATH = 'test,test2';\n+\n+statement error\n+SET SEARCH_PATH = '\"invalid quoted string list';\n+\n+query I\n+SELECT MAIN.CURRENT_SETTING('search_path');\n+----\n+test,test2\n+\n+query I\n+SELECT MAIN.CURRENT_SETTING('schema');\n+----\n+test,test2\n+\n+statement ok\n+SET SCHEMA = 'test';\n+\n+query I\n+SELECT MAIN.CURRENT_SETTING('search_path');\n+----\n+test\n+\n+query I\n+SELECT MAIN.CURRENT_SETTING('schema');\n+----\n+test\n+\n+# Case insensitivity\n+\n+statement ok\n+SET schema = 'test2';\n+\n+query I\n+SELECT CURRENT_SETTING('search_path');\n+----\n+test2\n+\n+statement ok\n+SET search_path = 'test3';\n+\n+query I\n+SELECT CURRENT_SETTING('search_path');\n+----\n+test3\n+\n+# Looking up from multiple schemas\n+\n+statement ok\n+SET SEARCH_PATH = 'test,test2';\n+\n+statement ok\n+SELECT i FROM test_table;\n+\n+statement ok\n+SELECT i FROM test2_table;\n+\n+statement ok\n+SELECT i FROM main_table;\n+\n+statement ok\n+CREATE TABLE main.table_with_same_name(in_main INTEGER);\n+\n+statement ok\n+CREATE TABLE test.table_with_same_name(in_test INTEGER);\n+\n+statement ok\n+CREATE TABLE test2.table_with_same_name(in_test2 INTEGER);\n+\n+statement error\n+---\n+SELECT in_main FROM table_with_same_name;\n+\n+statement error\n+---\n+SELECT in_test2 FROM table_with_same_name;\n+\n+statement ok\n+---\n+SELECT in_test FROM table_with_same_name;\n+\n+\n+# Or even more schemas\n+\n+statement ok\n+SET SEARCH_PATH = 'test,test2,test3,test4,test5';\n+\n+statement ok\n+---\n+SELECT i FROM test5_table;\n+\n+statement ok\n+SELECT i FROM test_table;\n+\n+statement ok\n+SELECT i FROM test2_table;\n+\n+statement ok\n+SELECT i FROM main_table;\n+\n+# Duplicate entry in the path (is allowed)\n+\n+statement ok\n+SET SEARCH_PATH = 'test,test,test2';\n+\n+statement ok\n+SELECT i FROM test_table;\n+\n+statement ok\n+SELECT i FROM test2_table;\n+\n+statement ok\n+SELECT i FROM main_table;\n+\n+# Multiple connections\n+\n+statement ok con1\n+SET schema = 'test';\n+\n+statement ok con2\n+SET schema = 'test2';\n+\n+statement ok con1\n+SELECT i FROM test_table;\n+\n+statement error con2\n+SELECT i FROM test_table;\n+\n+statement error con1\n+SELECT i FROM test2_table;\n+\n+statement ok con2\n+SELECT i FROM test2_table;\n+\ndiff --git a/test/sql/function/generic/test_set.test b/test/sql/function/generic/test_set.test\nindex ca8ac20364f8..610ae697a8c2 100644\n--- a/test/sql/function/generic/test_set.test\n+++ b/test/sql/function/generic/test_set.test\n@@ -76,3 +76,29 @@ query I\n SELECT CURRENT_SETTING('shadowed');\n ----\n 42\n+\n+statement ok\n+SET SESSION CASE_IS_LOWERED = 42;\n+\n+query I\n+SELECT CURRENT_SETTING('case_is_lowered');\n+----\n+42\n+\n+query I\n+SELECT CURRENT_SETTING('CASE_IS_LOWERED');\n+----\n+42\n+\n+statement ok\n+SET SESSION case_is_lowered = 43;\n+\n+query I\n+SELECT CURRENT_SETTING('case_is_lowered');\n+----\n+43\n+\n+query I\n+SELECT CURRENT_SETTING('CASE_IS_LOWERED');\n+----\n+43\n",
  "problem_statement": "Set default schema that is used at runtime\ne.g.\r\n```sql\r\nCREATE SCHEMA s1;\r\nSET default_schema TO s1;\r\n```\n",
  "hints_text": "Hi @Mytherin,\r\n\r\ncan you please guide about the changes. Will be happy to pick this up.\nThanks for the offer :)\r\n\r\nApologies for the late reply, I have been a bit busy. Here are the changes required as I see them:\r\n\r\nWhat needs to happen for this change is that anytime the DEFAULT_SCHEMA is bound, we instead use the default schema that is specified by the user. The default schema is client-dependent, and should reset every session, so we can store this in the `ClientContext` as a simple string. It should have the default `DEFAULT_SCHEMA` as default value (which is \"main\" currently).\r\n\r\nWe then need to support actually changing this variable. An easy way of doing that for now would be through the `PRAGMA` statement, e.g. `PRAGMA default_schema='s1'`. This case should be handled in `physical_pragma.cpp`.\r\n\r\nThe variable then needs to be used in the actual binding. This all happens in `catalog.cpp`. Anytime we encounter `DEFAULT_SCHEMA` there, we need to switch this to use the variable located in the client context. Note that we should also do this for create statements. For example, if you do `CREATE TABLE integers(i INTEGER);`, the actual table created should be in the default schema.\r\n\r\nI believe those are all the changes required, at least as I see it right now.\nThis is a highly useful feature.  Syntax variants include:\r\n\r\npostgres flavors-\r\nset schema 'schema_name';\r\nset search_path to 'schema_name';\r\n\r\nmysql flavor-\r\nuse 'schema_name';\r\n",
  "created_at": "2021-09-22T13:15:28Z"
}