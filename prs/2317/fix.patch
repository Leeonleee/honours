diff --git a/src/catalog/CMakeLists.txt b/src/catalog/CMakeLists.txt
index 093b94015f24..0d993535535e 100644
--- a/src/catalog/CMakeLists.txt
+++ b/src/catalog/CMakeLists.txt
@@ -1,8 +1,14 @@
 add_subdirectory(catalog_entry)
 add_subdirectory(default)
 
-add_library_unity(duckdb_catalog OBJECT catalog_entry.cpp catalog.cpp
-                  catalog_set.cpp dependency_manager.cpp)
+add_library_unity(
+  duckdb_catalog
+  OBJECT
+  catalog_entry.cpp
+  catalog.cpp
+  catalog_search_path.cpp
+  catalog_set.cpp
+  dependency_manager.cpp)
 set(ALL_OBJECT_FILES
     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_catalog>
     PARENT_SCOPE)
diff --git a/src/catalog/catalog.cpp b/src/catalog/catalog.cpp
index 9fd86d3d3cef..f7ea736beef8 100644
--- a/src/catalog/catalog.cpp
+++ b/src/catalog/catalog.cpp
@@ -2,6 +2,7 @@
 #include "duckdb/catalog/catalog_set.hpp"
 
 #include "duckdb/catalog/catalog_entry/list.hpp"
+#include "duckdb/catalog/catalog_search_path.hpp"
 #include "duckdb/common/exception.hpp"
 #include "duckdb/main/client_context.hpp"
 #include "duckdb/parser/expression/function_expression.hpp"
@@ -25,6 +26,12 @@
 
 namespace duckdb {
 
+string SimilarCatalogEntry::GetQualifiedName() const {
+	D_ASSERT(Found());
+
+	return name + "." + schema->name;
+}
+
 Catalog::Catalog(DatabaseInstance &db)
     : db(db), schemas(make_unique<CatalogSet>(*this, make_unique<DefaultSchemaGenerator>(*this))),
       dependency_manager(make_unique<DependencyManager>(*this)) {
@@ -147,23 +154,25 @@ void Catalog::DropEntry(ClientContext &context, DropInfo *info) {
 	if (info->type == CatalogType::SCHEMA_ENTRY) {
 		// DROP SCHEMA
 		DropSchema(context, info);
-	} else {
-		if (info->schema.empty()) {
-			info->schema = DEFAULT_SCHEMA;
-		}
-		auto schema = GetSchema(context, info->schema);
-		schema->DropEntry(context, info);
+		return;
+	}
+
+	auto lookup = LookupEntry(context, info->type, info->schema, info->name, info->if_exists);
+	if (!lookup.Found()) {
+		return;
 	}
+
+	lookup.schema->DropEntry(context, info);
 }
 
-SchemaCatalogEntry *Catalog::GetSchema(ClientContext &context, const string &schema_name,
+SchemaCatalogEntry *Catalog::GetSchema(ClientContext &context, const string &schema_name, bool if_exists,
                                        QueryErrorContext error_context) {
 	D_ASSERT(!schema_name.empty());
 	if (schema_name == TEMP_SCHEMA) {
 		return context.temporary_objects.get();
 	}
 	auto entry = schemas->GetEntry(context, schema_name);
-	if (!entry) {
+	if (!entry && !if_exists) {
 		throw CatalogException(error_context.FormatError("Schema with name %s does not exist!", schema_name));
 	}
 	return (SchemaCatalogEntry *)entry;
@@ -174,29 +183,99 @@ void Catalog::ScanSchemas(ClientContext &context, std::function<void(CatalogEntr
 	schemas->Scan(context, [&](CatalogEntry *entry) { callback(entry); });
 }
 
-CatalogEntry *Catalog::GetEntry(ClientContext &context, CatalogType type, string schema_name, const string &name,
-                                bool if_exists, QueryErrorContext error_context) {
-	if (schema_name.empty()) {
-		// no schema provided: check the catalog search path in order
-		if (context.catalog_search_path.empty()) {
-			throw InternalException("Empty catalog search path");
+SimilarCatalogEntry Catalog::SimilarEntryInSchemas(ClientContext &context, const string &entry_name, CatalogType type,
+                                                   const vector<SchemaCatalogEntry *> &schemas) {
+
+	vector<CatalogSet *> sets;
+	std::transform(schemas.begin(), schemas.end(), std::back_inserter(sets),
+	               [type](SchemaCatalogEntry *s) -> CatalogSet * { return &s->GetCatalogSet(type); });
+	pair<string, idx_t> most_similar {"", (idx_t)-1};
+	SchemaCatalogEntry *schema_of_most_similar = nullptr;
+	for (auto schema : schemas) {
+		auto entry = schema->GetCatalogSet(type).SimilarEntry(context, entry_name);
+		if (!entry.first.empty() && (most_similar.first.empty() || most_similar.second > entry.second)) {
+			most_similar = entry;
+			schema_of_most_similar = schema;
 		}
-		schema_name = DEFAULT_SCHEMA;
-		for (idx_t i = 0; i < context.catalog_search_path.size(); i++) {
-			auto entry = GetEntry(context, type, context.catalog_search_path[i], name, true);
-			if (entry) {
-				return entry;
+	}
+
+	return {most_similar.first, most_similar.second, schema_of_most_similar};
+}
+
+CatalogException Catalog::CreateMissingEntryException(ClientContext &context, const string &entry_name,
+                                                      CatalogType type, const vector<SchemaCatalogEntry *> &schemas,
+                                                      QueryErrorContext error_context) {
+	auto entry = SimilarEntryInSchemas(context, entry_name, type, schemas);
+
+	vector<SchemaCatalogEntry *> unseen_schemas;
+	this->schemas->Scan([&schemas, &unseen_schemas](CatalogEntry *entry) {
+		auto schema_entry = (SchemaCatalogEntry *)entry;
+		if (std::find(schemas.begin(), schemas.end(), schema_entry) == schemas.end()) {
+			unseen_schemas.emplace_back(schema_entry);
+		}
+	});
+	auto unseen_entry = SimilarEntryInSchemas(context, entry_name, type, unseen_schemas);
+
+	string did_you_mean;
+	if (unseen_entry.Found() && unseen_entry.distance < entry.distance) {
+		did_you_mean = "
Did you mean \"" + unseen_entry.GetQualifiedName() + "\"?";
+	} else if (entry.Found()) {
+		did_you_mean = "
Did you mean \"" + entry.name + "\"?";
+	}
+
+	return CatalogException(error_context.FormatError("%s with name %s does not exist!%s", CatalogTypeToString(type),
+	                                                  entry_name, did_you_mean));
+}
+
+CatalogEntryLookup Catalog::LookupEntry(ClientContext &context, CatalogType type, const string &schema_name,
+                                        const string &name, bool if_exists, QueryErrorContext error_context) {
+	if (!schema_name.empty()) {
+		auto schema = GetSchema(context, schema_name, if_exists, error_context);
+		if (!schema) {
+			D_ASSERT(if_exists);
+			return {nullptr, nullptr};
+		}
+
+		auto entry = schema->GetCatalogSet(type).GetEntry(context, name);
+		if (!entry && !if_exists) {
+			throw CreateMissingEntryException(context, name, type, {schema}, error_context);
+		}
+
+		return {schema, entry};
+	}
+
+	const auto &paths = context.catalog_search_path->Get();
+	for (const auto &path : paths) {
+		auto lookup = LookupEntry(context, type, path, name, true, error_context);
+		if (lookup.Found()) {
+			return lookup;
+		}
+	}
+
+	if (!if_exists) {
+		vector<SchemaCatalogEntry *> schemas;
+		for (const auto &path : paths) {
+			auto schema = GetSchema(context, path, true);
+			if (schema) {
+				schemas.emplace_back(schema);
 			}
 		}
+
+		throw CreateMissingEntryException(context, name, type, schemas, error_context);
 	}
-	auto schema = GetSchema(context, schema_name, error_context);
-	return schema->GetEntry(context, type, name, if_exists, error_context);
+
+	return {nullptr, nullptr};
+}
+
+CatalogEntry *Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema_name, const string &name,
+                                bool if_exists, QueryErrorContext error_context) {
+	return LookupEntry(context, type, schema_name, name, if_exists, error_context).entry;
 }
 
 template <>
-TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,
-                                     QueryErrorContext error_context) {
-	auto entry = GetEntry(context, CatalogType::TABLE_ENTRY, move(schema_name), name, if_exists);
+TableCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
+                                     bool if_exists, QueryErrorContext error_context) {
+	auto entry = GetEntry(context, CatalogType::TABLE_ENTRY, schema_name, name, if_exists);
 	if (!entry) {
 		return nullptr;
 	}
@@ -207,38 +286,37 @@ TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name,
 }
 
 template <>
-SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,
-                                        QueryErrorContext error_context) {
-	return (SequenceCatalogEntry *)GetEntry(context, CatalogType::SEQUENCE_ENTRY, move(schema_name), name, if_exists,
+SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
+                                        bool if_exists, QueryErrorContext error_context) {
+	return (SequenceCatalogEntry *)GetEntry(context, CatalogType::SEQUENCE_ENTRY, schema_name, name, if_exists,
 	                                        error_context);
 }
 
 template <>
-TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
+TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
                                              bool if_exists, QueryErrorContext error_context) {
-	return (TableFunctionCatalogEntry *)GetEntry(context, CatalogType::TABLE_FUNCTION_ENTRY, move(schema_name), name,
+	return (TableFunctionCatalogEntry *)GetEntry(context, CatalogType::TABLE_FUNCTION_ENTRY, schema_name, name,
 	                                             if_exists, error_context);
 }
 
 template <>
-CopyFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
+CopyFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
                                             bool if_exists, QueryErrorContext error_context) {
-	return (CopyFunctionCatalogEntry *)GetEntry(context, CatalogType::COPY_FUNCTION_ENTRY, move(schema_name), name,
-	                                            if_exists, error_context);
+	return (CopyFunctionCatalogEntry *)GetEntry(context, CatalogType::COPY_FUNCTION_ENTRY, schema_name, name, if_exists,
+	                                            error_context);
 }
 
 template <>
-PragmaFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
+PragmaFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
                                               bool if_exists, QueryErrorContext error_context) {
-	return (PragmaFunctionCatalogEntry *)GetEntry(context, CatalogType::PRAGMA_FUNCTION_ENTRY, move(schema_name), name,
+	return (PragmaFunctionCatalogEntry *)GetEntry(context, CatalogType::PRAGMA_FUNCTION_ENTRY, schema_name, name,
 	                                              if_exists, error_context);
 }
 
 template <>
-AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
+AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
                                                  bool if_exists, QueryErrorContext error_context) {
-	auto entry =
-	    GetEntry(context, CatalogType::AGGREGATE_FUNCTION_ENTRY, move(schema_name), name, if_exists, error_context);
+	auto entry = GetEntry(context, CatalogType::AGGREGATE_FUNCTION_ENTRY, schema_name, name, if_exists, error_context);
 	if (entry->type != CatalogType::AGGREGATE_FUNCTION_ENTRY) {
 		throw CatalogException(error_context.FormatError("%s is not an aggregate function", name));
 	}
@@ -246,29 +324,17 @@ AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string
 }
 
 template <>
-CollateCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,
-                                       QueryErrorContext error_context) {
-	return (CollateCatalogEntry *)GetEntry(context, CatalogType::COLLATION_ENTRY, move(schema_name), name, if_exists,
+CollateCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
+                                       bool if_exists, QueryErrorContext error_context) {
+	return (CollateCatalogEntry *)GetEntry(context, CatalogType::COLLATION_ENTRY, schema_name, name, if_exists,
 	                                       error_context);
 }
 
 void Catalog::Alter(ClientContext &context, AlterInfo *info) {
 	ModifyCatalog();
-	if (info->schema.empty()) {
-		auto catalog_type = info->GetCatalogType();
-		// invalid schema: search the catalog search path
-		info->schema = DEFAULT_SCHEMA;
-		for (idx_t i = 0; i < context.catalog_search_path.size(); i++) {
-			auto entry = GetEntry(context, catalog_type, context.catalog_search_path[i], info->name, true);
-			if (entry) {
-				// entry exists in this schema: alter there
-				info->schema = context.catalog_search_path[i];
-				break;
-			}
-		}
-	}
-	auto schema = GetSchema(context, info->schema);
-	return schema->Alter(context, info);
+	auto lookup = LookupEntry(context, info->GetCatalogType(), info->schema, info->name);
+	D_ASSERT(lookup.Found()); // It must have thrown otherwise.
+	return lookup.schema->Alter(context, info);
 }
 
 idx_t Catalog::GetCatalogVersion() {
diff --git a/src/catalog/catalog_entry/schema_catalog_entry.cpp b/src/catalog/catalog_entry/schema_catalog_entry.cpp
index 02e2ca898ddb..b7d673cf53e6 100644
--- a/src/catalog/catalog_entry/schema_catalog_entry.cpp
+++ b/src/catalog/catalog_entry/schema_catalog_entry.cpp
@@ -181,26 +181,6 @@ void SchemaCatalogEntry::Alter(ClientContext &context, AlterInfo *info) {
 	}
 }
 
-CatalogEntry *SchemaCatalogEntry::GetEntry(ClientContext &context, CatalogType type, const string &entry_name,
-                                           bool if_exists, QueryErrorContext error_context) {
-	auto &set = GetCatalogSet(type);
-
-	auto entry = set.GetEntry(context, entry_name);
-	if (!entry) {
-		if (!if_exists) {
-			auto entry = set.SimilarEntry(context, entry_name);
-			string did_you_mean;
-			if (!entry.empty()) {
-				did_you_mean = "
Did you mean \"" + entry + "\"?";
-			}
-			throw CatalogException(error_context.FormatError("%s with name %s does not exist!%s",
-			                                                 CatalogTypeToString(type), entry_name, did_you_mean));
-		}
-		return nullptr;
-	}
-	return entry;
-}
-
 void SchemaCatalogEntry::Scan(ClientContext &context, CatalogType type,
                               const std::function<void(CatalogEntry *)> &callback) {
 	auto &set = GetCatalogSet(type);
diff --git a/src/catalog/catalog_search_path.cpp b/src/catalog/catalog_search_path.cpp
new file mode 100644
index 000000000000..3346b265ea94
--- /dev/null
+++ b/src/catalog/catalog_search_path.cpp
@@ -0,0 +1,45 @@
+#include "duckdb/catalog/catalog_search_path.hpp"
+
+#include "duckdb/common/constants.hpp"
+#include "duckdb/common/exception.hpp"
+#include "duckdb/common/string_util.hpp"
+#include "duckdb/main/client_context.hpp"
+
+namespace duckdb {
+
+CatalogSearchPath::CatalogSearchPath(ClientContext &context_p) : context(context_p), paths(ParsePaths("")) {
+}
+
+const vector<string> &CatalogSearchPath::Get() {
+	Value value;
+	context.TryGetCurrentSetting("search_path", value);
+	if (value.str_value != last_value) {
+		paths = ParsePaths(value.str_value);
+		last_value = value.str_value;
+	}
+
+	return paths;
+}
+
+const string &CatalogSearchPath::GetDefault() {
+	const auto &paths = Get();
+	D_ASSERT(paths.size() >= 2);
+	D_ASSERT(paths[0] == TEMP_SCHEMA);
+	return paths[1];
+}
+
+vector<string> CatalogSearchPath::ParsePaths(const string &value) {
+	vector<string> paths;
+	paths.emplace_back(TEMP_SCHEMA);
+
+	auto given_paths = StringUtil::SplitWithQuote(value);
+	for (const auto &p : given_paths) {
+		paths.emplace_back(StringUtil::Lower(p));
+	}
+
+	paths.emplace_back(DEFAULT_SCHEMA);
+	paths.emplace_back("pg_catalog");
+	return paths;
+}
+
+} // namespace duckdb
diff --git a/src/catalog/catalog_set.cpp b/src/catalog/catalog_set.cpp
index 38aaf7a5c668..f27a86da63cf 100644
--- a/src/catalog/catalog_set.cpp
+++ b/src/catalog/catalog_set.cpp
@@ -307,7 +307,7 @@ CatalogEntry *CatalogSet::GetCommittedEntry(CatalogEntry *current) {
 	return current;
 }
 
-string CatalogSet::SimilarEntry(ClientContext &context, const string &name) {
+pair<string, idx_t> CatalogSet::SimilarEntry(ClientContext &context, const string &name) {
 	lock_guard<mutex> lock(catalog_lock);
 
 	string result;
@@ -322,7 +322,7 @@ string CatalogSet::SimilarEntry(ClientContext &context, const string &name) {
 			}
 		}
 	}
-	return result;
+	return {result, current_score};
 }
 
 CatalogEntry *CatalogSet::CreateEntryInternal(ClientContext &context, unique_ptr<CatalogEntry> entry) {
diff --git a/src/common/string_util.cpp b/src/common/string_util.cpp
index 4f7d2e0409bb..9f83dddda044 100644
--- a/src/common/string_util.cpp
+++ b/src/common/string_util.cpp
@@ -2,6 +2,7 @@
 #include "duckdb/common/pair.hpp"
 #include "duckdb/common/to_string.hpp"
 #include "duckdb/common/string_util.hpp"
+#include "duckdb/common/exception.hpp"
 
 #include <algorithm>
 #include <cctype>
@@ -68,6 +69,65 @@ vector<string> StringUtil::Split(const string &str, char delimiter) {
 	return (lines);
 }
 
+namespace string_util_internal {
+
+inline void SkipSpaces(const string &str, idx_t &index) {
+	while (index < str.size() && std::isspace(str[index])) {
+		index++;
+	}
+}
+
+inline void ConsumeLetter(const string &str, idx_t &index, char expected) {
+	if (index >= str.size() || str[index] != expected) {
+		throw ParserException("Invalid quoted list: %s", str);
+	}
+
+	index++;
+}
+
+template <typename F>
+inline void TakeWhile(const string &str, idx_t &index, const F &cond, string &taker) {
+	while (index < str.size() && cond(str[index])) {
+		taker.push_back(str[index]);
+		index++;
+	}
+}
+
+inline string TakePossiblyQuotedItem(const string &str, idx_t &index, char delimiter, char quote) {
+	string entry;
+
+	if (str[index] == quote) {
+		index++;
+		TakeWhile(
+		    str, index, [quote](char c) { return c != quote; }, entry);
+		ConsumeLetter(str, index, quote);
+	} else {
+		TakeWhile(
+		    str, index, [delimiter, quote](char c) { return c != delimiter && c != quote && !std::isspace(c); }, entry);
+	}
+
+	return entry;
+}
+
+} // namespace string_util_internal
+
+vector<string> StringUtil::SplitWithQuote(const string &str, char delimiter, char quote) {
+	vector<string> entries;
+	idx_t i = 0;
+
+	string_util_internal::SkipSpaces(str, i);
+	while (i < str.size()) {
+		if (!entries.empty()) {
+			string_util_internal::ConsumeLetter(str, i, delimiter);
+		}
+
+		entries.emplace_back(string_util_internal::TakePossiblyQuotedItem(str, i, delimiter, quote));
+		string_util_internal::SkipSpaces(str, i);
+	}
+
+	return entries;
+}
+
 string StringUtil::Join(const vector<string> &input, const string &separator) {
 	return StringUtil::Join(input, input.size(), separator, [](const string &s) { return s; });
 }
diff --git a/src/execution/operator/helper/physical_set.cpp b/src/execution/operator/helper/physical_set.cpp
index 3674b4ad4a02..2ed2c9fbd572 100644
--- a/src/execution/operator/helper/physical_set.cpp
+++ b/src/execution/operator/helper/physical_set.cpp
@@ -1,4 +1,6 @@
 #include "duckdb/execution/operator/helper/physical_set.hpp"
+
+#include "duckdb/common/string_util.hpp"
 #include "duckdb/main/database.hpp"
 #include "duckdb/main/client_context.hpp"
 
@@ -7,13 +9,38 @@ namespace duckdb {
 void PhysicalSet::GetChunkInternal(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state) const {
 	D_ASSERT(scope == SetScope::GLOBAL || scope == SetScope::SESSION);
 
+	auto normalized_name = ValidateInput(context);
 	if (scope == SetScope::GLOBAL) {
-		context.client.db->config.set_variables[name] = value;
+		context.client.db->config.set_variables[normalized_name] = value;
 	} else {
-		context.client.set_variables[name] = value;
+		context.client.set_variables[normalized_name] = value;
 	}
 
 	state->finished = true;
 }
 
+string PhysicalSet::ValidateInput(ExecutionContext &context) const {
+	CaseInsensitiveStringEquality case_insensitive_streq;
+	if (case_insensitive_streq(name, "search_path") || case_insensitive_streq(name, "schema")) {
+		auto paths = StringUtil::SplitWithQuote(value.str_value, ',');
+
+		// The PG doc says:
+		// >  SET SCHEMA 'value' is an alias for SET search_path TO value.
+		// >  Only one schema can be specified using this syntax.
+		if (case_insensitive_streq(name, "schema") && paths.size() > 1) {
+			throw CatalogException("SET schema can set only 1 schema. This has %d", paths.size());
+		}
+
+		for (const auto &path : paths) {
+			if (!context.client.db->GetCatalog().GetSchema(context.client, StringUtil::Lower(path), true)) {
+				throw CatalogException("SET %s: No schema named %s found.", name, path);
+			}
+		}
+
+		return "search_path";
+	}
+
+	return name;
+}
+
 } // namespace duckdb
diff --git a/src/function/scalar/generic/current_setting.cpp b/src/function/scalar/generic/current_setting.cpp
index c43288546f20..b08e0059e484 100644
--- a/src/function/scalar/generic/current_setting.cpp
+++ b/src/function/scalar/generic/current_setting.cpp
@@ -1,4 +1,5 @@
 #include "duckdb/function/scalar/generic_functions.hpp"
+
 #include "duckdb/main/database.hpp"
 #include "duckdb/main/client_context.hpp"
 #include "duckdb/planner/expression/bound_function_expression.hpp"
@@ -24,6 +25,16 @@ static void CurrentSettingFunction(DataChunk &args, ExpressionState &state, Vect
 	result.Reference(info.value);
 }
 
+static string NormalizeSettingName(const string &name) {
+	if (CaseInsensitiveStringEquality()(name, "schema")) {
+		// The PG doc says:
+		// >  SET SCHEMA 'value' is an alias for SET search_path TO value.
+		return "search_path";
+	}
+
+	return name;
+}
+
 unique_ptr<FunctionData> CurrentSettingBind(ClientContext &context, ScalarFunction &bound_function,
                                             vector<unique_ptr<Expression>> &arguments) {
 
@@ -39,7 +50,7 @@ unique_ptr<FunctionData> CurrentSettingBind(ClientContext &context, ScalarFuncti
 		throw ParserException("Key name for struct_extract needs to be neither NULL nor empty");
 	}
 
-	const auto &key = key_val.str_value;
+	const auto &key = NormalizeSettingName(key_val.str_value);
 	Value val;
 	if (!context.TryGetCurrentSetting(key, val)) {
 		throw InvalidInputException("Variable '%s' was not SET in this context", key);
diff --git a/src/include/duckdb/catalog/catalog.hpp b/src/include/duckdb/catalog/catalog.hpp
index 564752e134f4..702e0f5653e1 100644
--- a/src/include/duckdb/catalog/catalog.hpp
+++ b/src/include/duckdb/catalog/catalog.hpp
@@ -44,6 +44,32 @@ class CatalogSet;
 class DatabaseInstance;
 class DependencyManager;
 
+//! Return value of Catalog::LookupEntry
+struct CatalogEntryLookup {
+	SchemaCatalogEntry *schema;
+	CatalogEntry *entry;
+
+	bool Found() const {
+		return entry;
+	}
+};
+
+//! Return value of SimilarEntryInSchemas
+struct SimilarCatalogEntry {
+	//! The entry name. Empty if absent
+	string name;
+	//! The distance to the given name.
+	idx_t distance;
+	//! The schema of the entry.
+	SchemaCatalogEntry *schema;
+
+	bool Found() const {
+		return !name.empty();
+	}
+
+	string GetQualifiedName() const;
+};
+
 //! The Catalog object represents the catalog of the database.
 class Catalog {
 public:
@@ -115,17 +141,17 @@ class Catalog {
 	void DropEntry(ClientContext &context, DropInfo *info);
 
 	//! Returns the schema object with the specified name, or throws an exception if it does not exist
-	SchemaCatalogEntry *GetSchema(ClientContext &context, const string &name = DEFAULT_SCHEMA,
+	SchemaCatalogEntry *GetSchema(ClientContext &context, const string &name = DEFAULT_SCHEMA, bool if_exists = false,
 	                              QueryErrorContext error_context = QueryErrorContext());
 	//! Scans all the schemas in the system one-by-one, invoking the callback for each entry
 	void ScanSchemas(ClientContext &context, std::function<void(CatalogEntry *)> callback);
 	//! Gets the "schema.name" entry of the specified type, if if_exists=true returns nullptr if entry does not exist,
 	//! otherwise an exception is thrown
-	CatalogEntry *GetEntry(ClientContext &context, CatalogType type, string schema, const string &name,
+	CatalogEntry *GetEntry(ClientContext &context, CatalogType type, const string &schema, const string &name,
 	                       bool if_exists = false, QueryErrorContext error_context = QueryErrorContext());
 
 	template <class T>
-	T *GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists = false,
+	T *GetEntry(ClientContext &context, const string &schema_name, const string &name, bool if_exists = false,
 	            QueryErrorContext error_context = QueryErrorContext());
 
 	//! Alter an existing entry in the catalog.
@@ -136,29 +162,42 @@ class Catalog {
 	atomic<idx_t> catalog_version;
 
 private:
+	//! A variation of GetEntry that returns an associated schema as well.
+	CatalogEntryLookup LookupEntry(ClientContext &context, CatalogType type, const string &schema, const string &name,
+	                               bool if_exists = false, QueryErrorContext error_context = QueryErrorContext());
+
+	//! Return an exception with did-you-mean suggestion.
+	CatalogException CreateMissingEntryException(ClientContext &context, const string &entry_name, CatalogType type,
+	                                             const vector<SchemaCatalogEntry *> &schemas,
+	                                             QueryErrorContext error_context);
+
+	//! Return the close entry name, the distance and the belonging schema.
+	SimilarCatalogEntry SimilarEntryInSchemas(ClientContext &context, const string &entry_name, CatalogType type,
+	                                          const vector<SchemaCatalogEntry *> &schemas);
+
 	void DropSchema(ClientContext &context, DropInfo *info);
 };
 
 template <>
-TableCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,
-                                     QueryErrorContext error_context);
+TableCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
+                                     bool if_exists, QueryErrorContext error_context);
 template <>
-SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,
-                                        QueryErrorContext error_context);
+SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
+                                        bool if_exists, QueryErrorContext error_context);
 template <>
-TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
+TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
                                              bool if_exists, QueryErrorContext error_context);
 template <>
-CopyFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
+CopyFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
                                             bool if_exists, QueryErrorContext error_context);
 template <>
-PragmaFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
+PragmaFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
                                               bool if_exists, QueryErrorContext error_context);
 template <>
-AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name,
+AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
                                                  bool if_exists, QueryErrorContext error_context);
 template <>
-CollateCatalogEntry *Catalog::GetEntry(ClientContext &context, string schema_name, const string &name, bool if_exists,
-                                       QueryErrorContext error_context);
+CollateCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
+                                       bool if_exists, QueryErrorContext error_context);
 
 } // namespace duckdb
diff --git a/src/include/duckdb/catalog/catalog_entry/schema_catalog_entry.hpp b/src/include/duckdb/catalog/catalog_entry/schema_catalog_entry.hpp
index 05167a19570b..ba8a9ec0c3c1 100644
--- a/src/include/duckdb/catalog/catalog_entry/schema_catalog_entry.hpp
+++ b/src/include/duckdb/catalog/catalog_entry/schema_catalog_entry.hpp
@@ -64,10 +64,6 @@ class SchemaCatalogEntry : public CatalogEntry {
 	CatalogSet collations;
 
 public:
-	//! Gets a catalog entry from the given catalog set matching the given name
-	CatalogEntry *GetEntry(ClientContext &context, CatalogType type, const string &name, bool if_exists,
-	                       QueryErrorContext error_context = QueryErrorContext());
-
 	//! Scan the specified catalog set, invoking the callback method for every entry
 	void Scan(ClientContext &context, CatalogType type, const std::function<void(CatalogEntry *)> &callback);
 	//! Scan the specified catalog set, invoking the callback method for every committed entry
diff --git a/src/include/duckdb/catalog/catalog_search_path.hpp b/src/include/duckdb/catalog/catalog_search_path.hpp
new file mode 100644
index 000000000000..f099f20510b3
--- /dev/null
+++ b/src/include/duckdb/catalog/catalog_search_path.hpp
@@ -0,0 +1,37 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// duckdb/catalog/catalog_search_path.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include <functional>
+#include "duckdb/common/enums/catalog_type.hpp"
+#include "duckdb/common/string.hpp"
+#include "duckdb/common/vector.hpp"
+#include "duckdb/common/types/value.hpp"
+
+namespace duckdb {
+
+class ClientContext;
+
+//! The schema search path, in order by which entries are searched if no schema entry is provided
+class CatalogSearchPath {
+public:
+	explicit CatalogSearchPath(ClientContext &client_p);
+	CatalogSearchPath(const CatalogSearchPath &other) = delete;
+
+	const vector<string> &Get();
+	const string &GetDefault();
+
+private:
+	static vector<string> ParsePaths(const string &value);
+	ClientContext &context;
+	string last_value;
+	vector<string> paths;
+};
+
+} // namespace duckdb
diff --git a/src/include/duckdb/catalog/catalog_set.hpp b/src/include/duckdb/catalog/catalog_set.hpp
index b807ffc9fef5..dd7efdfdf905 100644
--- a/src/include/duckdb/catalog/catalog_set.hpp
+++ b/src/include/duckdb/catalog/catalog_set.hpp
@@ -12,6 +12,7 @@
 #include "duckdb/catalog/default/default_generator.hpp"
 #include "duckdb/common/common.hpp"
 #include "duckdb/common/case_insensitive_map.hpp"
+#include "duckdb/common/pair.hpp"
 #include "duckdb/common/unordered_set.hpp"
 #include "duckdb/common/mutex.hpp"
 
@@ -58,8 +59,8 @@ class CatalogSet {
 	CatalogEntry *GetEntry(ClientContext &context, const string &name);
 
 	//! Gets the entry that is most similar to the given name (i.e. smallest levenshtein distance), or empty string if
-	//! none is found
-	string SimilarEntry(ClientContext &context, const string &name);
+	//! none is found. The returned pair consists of the entry name and the distance (smaller means closer).
+	pair<string, idx_t> SimilarEntry(ClientContext &context, const string &name);
 
 	//! Rollback <entry> to be the currently valid entry for a certain catalog
 	//! entry
diff --git a/src/include/duckdb/common/string_util.hpp b/src/include/duckdb/common/string_util.hpp
index d179954b402a..55b895e51c1d 100644
--- a/src/include/duckdb/common/string_util.hpp
+++ b/src/include/duckdb/common/string_util.hpp
@@ -52,6 +52,9 @@ class StringUtil {
 	//! Split the input string based on newline char
 	static vector<string> Split(const string &str, char delimiter);
 
+	//! Split the input string allong a quote. Note that any escaping is NOT supported.
+	static vector<string> SplitWithQuote(const string &str, char delimiter = ',', char quote = '"');
+
 	//! Join multiple strings into one string. Components are concatenated by the given separator
 	static string Join(const vector<string> &input, const string &separator);
 
diff --git a/src/include/duckdb/execution/operator/helper/physical_set.hpp b/src/include/duckdb/execution/operator/helper/physical_set.hpp
index 15915685920f..24874e2dd6f1 100644
--- a/src/include/duckdb/execution/operator/helper/physical_set.hpp
+++ b/src/include/duckdb/execution/operator/helper/physical_set.hpp
@@ -17,7 +17,7 @@ namespace duckdb {
 //! PhysicalSet represents a SET operation (e.g. SET a = 42)
 class PhysicalSet : public PhysicalOperator {
 public:
-	PhysicalSet(std::string name_p, Value value_p, SetScope scope_p, idx_t estimated_cardinality)
+	PhysicalSet(const std::string &name_p, Value value_p, SetScope scope_p, idx_t estimated_cardinality)
 	    : PhysicalOperator(PhysicalOperatorType::SET, {LogicalType::BOOLEAN}, estimated_cardinality), name(name_p),
 	      value(value_p), scope(scope_p) {
 	}
@@ -26,9 +26,13 @@ class PhysicalSet : public PhysicalOperator {
 	void GetChunkInternal(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state) const override;
 
 public:
-	std::string name;
-	Value value;
-	SetScope scope;
+	const std::string name;
+	const Value value;
+	const SetScope scope;
+
+private:
+	//! Returns the normalized key name.
+	string ValidateInput(ExecutionContext &context) const;
 };
 
 } // namespace duckdb
diff --git a/src/include/duckdb/main/client_context.hpp b/src/include/duckdb/main/client_context.hpp
index 29acb35c1266..e14a0c5f8682 100644
--- a/src/include/duckdb/main/client_context.hpp
+++ b/src/include/duckdb/main/client_context.hpp
@@ -10,6 +10,7 @@
 
 #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
 #include "duckdb/catalog/catalog_set.hpp"
+#include "duckdb/common/case_insensitive_map.hpp"
 #include "duckdb/common/deque.hpp"
 #include "duckdb/common/enums/output_type.hpp"
 #include "duckdb/common/pair.hpp"
@@ -27,6 +28,7 @@
 namespace duckdb {
 class Appender;
 class Catalog;
+class CatalogSearchPath;
 class ChunkCollection;
 class DatabaseInstance;
 class FileOpener;
@@ -76,7 +78,7 @@ class ClientContext : public std::enable_shared_from_this<ClientContext> {
 	unique_ptr<SchemaCatalogEntry> temporary_objects;
 	unordered_map<string, shared_ptr<PreparedStatementData>> prepared_statements;
 
-	unordered_map<string, Value> set_variables;
+	case_insensitive_map_t<Value> set_variables;
 
 	// Whether or not aggressive query verification is enabled
 	bool query_verification_enabled = false;
@@ -98,8 +100,7 @@ class ClientContext : public std::enable_shared_from_this<ClientContext> {
 	//! The random generator used by random(). Its seed value can be set by setseed().
 	std::mt19937 random_engine;
 
-	//! The schema search path, in order by which entries are searched if no schema entry is provided
-	vector<string> catalog_search_path = {TEMP_SCHEMA, DEFAULT_SCHEMA, "pg_catalog"};
+	const unique_ptr<CatalogSearchPath> catalog_search_path;
 
 	unique_ptr<FileOpener> file_opener;
 
diff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp
index e44eb763ad1e..53d601b47503 100644
--- a/src/include/duckdb/main/config.hpp
+++ b/src/include/duckdb/main/config.hpp
@@ -9,6 +9,7 @@
 #pragma once
 
 #include "duckdb/common/allocator.hpp"
+#include "duckdb/common/case_insensitive_map.hpp"
 #include "duckdb/common/common.hpp"
 #include "duckdb/common/enums/order_type.hpp"
 #include "duckdb/common/file_system.hpp"
@@ -93,7 +94,7 @@ struct DBConfig {
 	//! Whether or not object cache is used
 	bool object_cache_enable = false;
 	//! Database configuration variables as controlled by SET
-	unordered_map<std::string, Value> set_variables;
+	case_insensitive_map_t<Value> set_variables;
 	//! Force checkpoint when CHECKPOINT is called or on shutdown, even if no changes have been made
 	bool force_checkpoint = false;
 	//! Run a checkpoint on successful shutdown and delete the WAL, to leave only a single database file behind
diff --git a/src/include/duckdb/parser/parsed_data/create_function_info.hpp b/src/include/duckdb/parser/parsed_data/create_function_info.hpp
index 2f029fa8ee76..213bf875fcbb 100644
--- a/src/include/duckdb/parser/parsed_data/create_function_info.hpp
+++ b/src/include/duckdb/parser/parsed_data/create_function_info.hpp
@@ -14,7 +14,7 @@
 namespace duckdb {
 
 struct CreateFunctionInfo : public CreateInfo {
-	explicit CreateFunctionInfo(CatalogType type) : CreateInfo(type) {
+	explicit CreateFunctionInfo(CatalogType type, string schema = DEFAULT_SCHEMA) : CreateInfo(type, schema) {
 		D_ASSERT(type == CatalogType::SCALAR_FUNCTION_ENTRY || type == CatalogType::AGGREGATE_FUNCTION_ENTRY ||
 		         type == CatalogType::TABLE_FUNCTION_ENTRY || type == CatalogType::PRAGMA_FUNCTION_ENTRY ||
 		         type == CatalogType::MACRO_ENTRY);
diff --git a/src/include/duckdb/parser/parsed_data/create_macro_info.hpp b/src/include/duckdb/parser/parsed_data/create_macro_info.hpp
index f80142e795e7..31121738df8b 100644
--- a/src/include/duckdb/parser/parsed_data/create_macro_info.hpp
+++ b/src/include/duckdb/parser/parsed_data/create_macro_info.hpp
@@ -14,7 +14,7 @@
 namespace duckdb {
 
 struct CreateMacroInfo : public CreateFunctionInfo {
-	CreateMacroInfo() : CreateFunctionInfo(CatalogType::MACRO_ENTRY) {
+	CreateMacroInfo() : CreateFunctionInfo(CatalogType::MACRO_ENTRY, INVALID_SCHEMA) {
 	}
 
 	unique_ptr<MacroFunction> function;
diff --git a/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp b/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp
index 690a66519147..1e8345667f40 100644
--- a/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp
+++ b/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp
@@ -15,8 +15,8 @@ namespace duckdb {
 
 struct CreateSequenceInfo : public CreateInfo {
 	CreateSequenceInfo()
-	    : CreateInfo(CatalogType::SEQUENCE_ENTRY), name(string()), usage_count(0), increment(1), min_value(1),
-	      max_value(NumericLimits<int64_t>::Maximum()), start_value(1), cycle(false) {
+	    : CreateInfo(CatalogType::SEQUENCE_ENTRY, INVALID_SCHEMA), name(string()), usage_count(0), increment(1),
+	      min_value(1), max_value(NumericLimits<int64_t>::Maximum()), start_value(1), cycle(false) {
 	}
 
 	//! Sequence name to create
@@ -39,6 +39,7 @@ struct CreateSequenceInfo : public CreateInfo {
 		auto result = make_unique<CreateSequenceInfo>();
 		CopyProperties(*result);
 		result->name = name;
+		result->schema = schema;
 		result->usage_count = usage_count;
 		result->increment = increment;
 		result->min_value = min_value;
diff --git a/src/include/duckdb/parser/parsed_data/create_view_info.hpp b/src/include/duckdb/parser/parsed_data/create_view_info.hpp
index 4924bf658cf4..19c96e1c613c 100644
--- a/src/include/duckdb/parser/parsed_data/create_view_info.hpp
+++ b/src/include/duckdb/parser/parsed_data/create_view_info.hpp
@@ -14,7 +14,7 @@
 namespace duckdb {
 
 struct CreateViewInfo : public CreateInfo {
-	CreateViewInfo() : CreateInfo(CatalogType::VIEW_ENTRY) {
+	CreateViewInfo() : CreateInfo(CatalogType::VIEW_ENTRY, INVALID_SCHEMA) {
 	}
 	CreateViewInfo(string schema, string view_name)
 	    : CreateInfo(CatalogType::VIEW_ENTRY, schema), view_name(view_name) {
diff --git a/src/main/client_context.cpp b/src/main/client_context.cpp
index 683819e8764e..0a02933fc723 100644
--- a/src/main/client_context.cpp
+++ b/src/main/client_context.cpp
@@ -4,6 +4,7 @@
 #include "duckdb/main/query_profiler.hpp"
 #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
 #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
+#include "duckdb/catalog/catalog_search_path.hpp"
 #include "duckdb/common/serializer/buffered_deserializer.hpp"
 #include "duckdb/common/serializer/buffered_serializer.hpp"
 #include "duckdb/execution/physical_plan_generator.hpp"
@@ -53,6 +54,7 @@ ClientContext::ClientContext(shared_ptr<DatabaseInstance> database)
     : profiler(make_unique<QueryProfiler>()), query_profiler_history(make_unique<QueryProfilerHistory>()),
       db(move(database)), transaction(db->GetTransactionManager(), *this), interrupted(false), executor(*this),
       temporary_objects(make_unique<SchemaCatalogEntry>(&db->GetCatalog(), TEMP_SCHEMA, true)),
+      catalog_search_path(make_unique<CatalogSearchPath>(*this)),
       file_opener(make_unique<ClientContextFileOpener>(*this)), open_result(nullptr) {
 	std::random_device rd;
 	random_engine.seed(rd());
diff --git a/src/parser/transform/statement/transform_set.cpp b/src/parser/transform/statement/transform_set.cpp
index 79f01218f510..a3329b177ba8 100644
--- a/src/parser/transform/statement/transform_set.cpp
+++ b/src/parser/transform/statement/transform_set.cpp
@@ -1,4 +1,5 @@
 #include "duckdb/parser/statement/set_statement.hpp"
+
 #include "duckdb/parser/transformer.hpp"
 #include "duckdb/parser/expression/constant_expression.hpp"
 
diff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp
index 7599f7d01314..ee254095f86c 100644
--- a/src/planner/binder/statement/bind_create.cpp
+++ b/src/planner/binder/statement/bind_create.cpp
@@ -1,4 +1,5 @@
 #include "duckdb/catalog/catalog.hpp"
+#include "duckdb/catalog/catalog_search_path.hpp"
 #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
 #include "duckdb/main/client_context.hpp"
 #include "duckdb/parser/expression/subquery_expression.hpp"
@@ -26,7 +27,7 @@ namespace duckdb {
 
 SchemaCatalogEntry *Binder::BindSchema(CreateInfo &info) {
 	if (info.schema.empty()) {
-		info.schema = info.temporary ? TEMP_SCHEMA : DEFAULT_SCHEMA;
+		info.schema = info.temporary ? TEMP_SCHEMA : context.catalog_search_path->GetDefault();
 	}
 
 	if (!info.temporary) {
