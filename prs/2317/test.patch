diff --git a/test/common/test_string_util.cpp b/test/common/test_string_util.cpp
index 6c6a6ce30aa1..76b2b6c0a753 100644
--- a/test/common/test_string_util.cpp
+++ b/test/common/test_string_util.cpp
@@ -144,3 +144,87 @@ TEST_CASE("Test join vector items", "[string_util]") {
 		REQUIRE(result == "");
 	}
 }
+
+TEST_CASE("Test split quoted strings", "[string_util]") {
+	SECTION("Empty string") {
+		REQUIRE(StringUtil::SplitWithQuote("") == vector<string> {});
+	}
+
+	SECTION("Empty string with space") {
+		REQUIRE(StringUtil::SplitWithQuote(" ") == vector<string> {});
+	}
+
+	SECTION("One item") {
+		REQUIRE(StringUtil::SplitWithQuote("x") == vector<string> {"x"});
+	}
+
+	SECTION("One item with space") {
+		REQUIRE(StringUtil::SplitWithQuote(" x ") == vector<string> {"x"});
+	}
+
+	SECTION("One item with quote") {
+		REQUIRE(StringUtil::SplitWithQuote("\"x\"") == vector<string> {"x"});
+	}
+
+	SECTION("One empty item with quote") {
+		REQUIRE(StringUtil::SplitWithQuote("\"\"") == vector<string> {""});
+	}
+
+	SECTION("One empty item, followed by non-empty one - Or vise versa") {
+		REQUIRE(StringUtil::SplitWithQuote("\"\",hello") == vector<string> {"", "hello"});
+		REQUIRE(StringUtil::SplitWithQuote(",\"hello\"") == vector<string> {"", "hello"});
+		REQUIRE(StringUtil::SplitWithQuote(",hello") == vector<string> {"", "hello"});
+		REQUIRE(StringUtil::SplitWithQuote("\"\",\"hello\"") == vector<string> {"", "hello"});
+
+		REQUIRE(StringUtil::SplitWithQuote("\"hello\",") == vector<string> {"hello", ""});
+		REQUIRE(StringUtil::SplitWithQuote("hello,\"\"") == vector<string> {"hello", ""});
+		REQUIRE(StringUtil::SplitWithQuote("hello,") == vector<string> {"hello", ""});
+		REQUIRE(StringUtil::SplitWithQuote("\"hello\",\"\"") == vector<string> {"hello", ""});
+	}
+
+	SECTION("One quoted item with spaces") {
+		REQUIRE(StringUtil::SplitWithQuote(" \" x y \" ") == vector<string> {" x y "});
+	}
+
+	SECTION("One quoted item with a delimiter") {
+		REQUIRE(StringUtil::SplitWithQuote("\"x,y\"") == vector<string> {"x,y"});
+	}
+
+	SECTION("Three items") {
+		REQUIRE(StringUtil::SplitWithQuote("x,y,z") == vector<string> {"x", "y", "z"});
+	}
+
+	SECTION("Three items, with and without quote") {
+		REQUIRE(StringUtil::SplitWithQuote("x,\"y\",z") == vector<string> {"x", "y", "z"});
+	}
+
+	SECTION("Even more items, with and without quote") {
+		REQUIRE(StringUtil::SplitWithQuote("a,b,c,d,e,f,g") == vector<string> {"a", "b", "c", "d", "e", "f", "g"});
+	}
+
+	SECTION("Three empty items") {
+		REQUIRE(StringUtil::SplitWithQuote(",,") == vector<string> {"", "", ""});
+	}
+
+	SECTION("Three empty quoted items") {
+		REQUIRE(StringUtil::SplitWithQuote("\"\",\"\",\"\"") == vector<string> {"", "", ""});
+	}
+
+	SECTION("Unclosed quote") {
+		REQUIRE_THROWS_AS(StringUtil::SplitWithQuote("\""), ParserException);
+		REQUIRE_THROWS_AS(StringUtil::SplitWithQuote("\"x"), ParserException);
+		REQUIRE_THROWS_AS(StringUtil::SplitWithQuote("\"x "), ParserException);
+		REQUIRE_THROWS_AS(StringUtil::SplitWithQuote("\","), ParserException);
+		REQUIRE_THROWS_AS(StringUtil::SplitWithQuote("\"x,"), ParserException);
+	}
+
+	SECTION("Unexpected quote") {
+		REQUIRE_THROWS_AS(StringUtil::SplitWithQuote("abc\"def"), ParserException);
+	}
+
+	SECTION("Missing delimiter") {
+		REQUIRE_THROWS_AS(StringUtil::SplitWithQuote("\"x\"\"y\""), ParserException);
+		REQUIRE_THROWS_AS(StringUtil::SplitWithQuote("\"x\" \"y\""), ParserException);
+		REQUIRE_THROWS_AS(StringUtil::SplitWithQuote("x y"), ParserException);
+	}
+}
\ No newline at end of file
diff --git a/test/sql/catalog/did_you_mean.test b/test/sql/catalog/did_you_mean.test
new file mode 100644
index 000000000000..2a8728ce52dc
--- /dev/null
+++ b/test/sql/catalog/did_you_mean.test
@@ -0,0 +1,26 @@
+# name: test/sql/catalog/did_you_mean.test
+# Description: The error messages suggest possible alternative
+# group: [catalog]
+ 
+statement ok
+CREATE TABLE hello(i INTEGER);
+
+statement ok
+CREATE SCHEMA test;
+
+statement ok
+CREATE TABLE test.bye(i INTEGER);
+
+statement error
+SELECT * FROM helloo;
+
+# TODO(omo): Test the error message being like this:
+# > Catalog Error: Table with name helloo does not exist!
+# > Did you mean "hello"?
+
+statement error
+SELECT * FROM bye;
+
+# TODO(omo): Test the error message being like this:
+# > Catalog Error: Table with name bye does not exist!
+# > Did you mean "test.bye"?
diff --git a/test/sql/catalog/test_if_not_exists.test b/test/sql/catalog/test_if_not_exists.test
index bc5f9814bdd2..b546d63454fc 100644
--- a/test/sql/catalog/test_if_not_exists.test
+++ b/test/sql/catalog/test_if_not_exists.test
@@ -20,3 +20,6 @@ DROP TABLE IF EXISTS integers
 statement ok
 DROP TABLE IF EXISTS integers
 
+statement ok
+DROP TABLE IF EXISTS no_such_scheme.integers
+
diff --git a/test/sql/catalog/test_set_schema.test b/test/sql/catalog/test_set_schema.test
new file mode 100644
index 000000000000..90433aa003dc
--- /dev/null
+++ b/test/sql/catalog/test_set_schema.test
@@ -0,0 +1,403 @@
+# name: test/sql/catalog/test_set_schema.test
+# description: Default schema name changes
+# group: [catalog]
+
+# This test focuses on actual name lookup.
+# See also test_set_search_path.test
+
+statement ok
+CREATE SCHEMA test;
+
+statement ok
+CREATE SCHEMA out_of_path;
+
+statement ok
+SET SESSION schema = 'test';
+
+# Testing CREATE TABLE
+
+statement ok
+CREATE TABLE main.main_table(j INTEGER);
+
+statement ok
+CREATE TABLE test_table(i INTEGER);
+
+statement ok
+CREATE TABLE out_of_path.oop_table(k INTEGER);
+
+statement ok
+SELECT * FROM test.test_table;
+
+statement ok
+SELECT * FROM test_table;
+
+statement ok
+SELECT * FROM main_table;
+
+statement ok
+SELECT * FROM out_of_path.oop_table;
+
+statement error
+SELECT * FROM out_of_path.test_table;
+
+statement error
+SELECT * FROM main.test_table;
+
+# Testing INSERT, UPDATE and DELETE
+
+statement error
+INSERT INTO main.test_table (i) VALUES (1);
+
+statement ok
+INSERT INTO test_table (i) VALUES (1);
+
+statement ok
+INSERT INTO test.test_table (i) VALUES (2), (3);
+
+statement ok
+INSERT INTO main_table (j) VALUES (4);
+
+statement ok
+INSERT INTO main.main_table (j) VALUES (5), (6);
+
+statement error
+INSERT INTO oop_table (k) VALUES (7);
+
+statement ok
+INSERT INTO out_of_path.oop_table (k) VALUES (8), (9);
+
+statement error
+DELETE FROM main.test_table WHERE i=3;
+
+statement error
+DELETE FROM test.main_table WHERE i=5;
+
+statement error
+DELETE FROM oop_table WHERE k=8;
+
+statement ok
+DELETE FROM test.test_table WHERE i=1;
+
+statement ok
+DELETE FROM test_table WHERE i=2;
+
+statement ok
+DELETE FROM main.main_table WHERE j=4;
+
+statement ok
+DELETE FROM main_table WHERE j=5;
+
+statement ok
+DELETE FROM out_of_path.oop_table WHERE k=8;
+
+query I
+SELECT i FROM test_table;
+----
+3
+
+query I
+SELECT j FROM main.main_table;
+----
+6
+
+query I
+SELECT k FROM out_of_path.oop_table;
+----
+9
+
+statement error
+UPDATE main.test_table SET i=10 WHERE i=1;
+
+statement ok
+UPDATE test_table SET i=30 WHERE i=3;
+
+statement ok
+UPDATE test.test_table SET i=300 WHERE i=30;
+
+statement ok
+UPDATE main_table SET j=60 WHERE j=6;
+
+statement ok
+UPDATE main.main_table SET j=600 WHERE j=60;
+
+query I
+SELECT i FROM test_table;
+----
+300
+
+query I
+SELECT j FROM main_table;
+----
+600
+
+# Testing temp table.
+# test_temp_table should *not* be created in the test schema, but in the temp schema
+
+statement ok
+CREATE TEMP TABLE test_temp_table(i INTEGER);
+
+statement error
+SELECT * FROM main.test_temp_table;
+
+statement error
+SELECT * FROM test.test_temp_table;
+
+statement ok
+SELECT * FROM test_temp_table;
+
+# Testing functions and aggregates
+query I
+SELECT abs(i) FROM test_table;
+----
+300
+
+# aggregates should work as expected
+query I
+SELECT sum(i) FROM test_table;
+----
+300
+
+# Testing Views
+statement ok
+CREATE VIEW test_view AS SELECT * FROM test_table;
+
+statement ok
+CREATE VIEW main.main_view AS SELECT * FROM main.main_table;
+
+statement ok
+CREATE VIEW out_of_path.oop_view AS SELECT * FROM out_of_path.oop_table;
+
+statement error
+SELECT * FROM main.test_view;
+
+statement ok
+SELECT * FROM test.test_view;
+
+statement ok
+SELECT * FROM test_view;
+
+statement ok
+SELECT * FROM main.main_view;
+
+statement ok
+SELECT * FROM main_view;
+
+statement error
+SELECT * FROM oop_view;
+
+statement ok
+SELECT * FROM out_of_path.oop_view;
+
+statement ok
+SET SESSION schema = 'main';
+
+# Test view's schema being bound on definition.
+statement error
+CREATE VIEW bad_test_view AS SELECT * FROM test_table;
+
+# TODO(omo):
+#   Currenly this fails because we bind the table name
+#   when the view is actually used vs. defined.
+#   This behavior is incompatible with PG.
+# statement ok
+# SELECT * FROM test.test_view;
+
+statement ok
+SET SESSION schema = 'test';
+
+statement error
+DROP VIEW main.test_view
+
+statement ok
+DROP VIEW test_view
+
+statement ok
+DROP VIEW main_view
+
+statement error
+DROP VIEW oop_view
+
+statement ok
+DROP VIEW out_of_path.oop_view
+
+# Testing Macros
+
+statement ok
+CREATE MACRO test_macro(a, b) AS a + b;
+
+statement ok
+CREATE MACRO test_macro2(c, d) AS c * d;
+
+statement ok
+CREATE MACRO main.main_macro(a, b) AS a - b;
+
+statement ok
+CREATE MACRO out_of_path.oop_macro(a, b) AS a * b;
+
+statement error
+SELECT main.test_macro(1, 2);
+
+statement error
+SELECT oop_macro(1, 2);
+
+statement ok
+SELECT main_macro(1, 2);
+
+statement ok
+SELECT main.main_macro(1, 2);
+
+statement ok
+SELECT test.test_macro(1, 2);
+
+statement ok
+SELECT test_macro(1, 2);
+
+statement ok
+SELECT out_of_path.oop_macro(1, 2);
+
+statement error
+DROP MACRO main.test_macro;
+
+statement ok
+DROP MACRO test_macro;
+
+statement ok
+DROP MACRO test.test_macro2;
+
+statement ok
+DROP MACRO main_macro;
+
+statement error
+DROP MACRO oop_macro;
+
+statement ok
+DROP MACRO out_of_path.oop_macro;
+
+# Testing sequences.
+
+statement ok
+CREATE SEQUENCE test_sequence;
+
+statement ok
+CREATE SEQUENCE test_sequence2;
+
+statement ok
+CREATE SEQUENCE main.main_sequence;
+
+statement ok
+CREATE SEQUENCE out_of_path.oop_sequence;
+
+statement error
+SELECT main.nextval('main.test_sequence');
+
+statement ok
+SELECT main.nextval('test.test_sequence');
+
+statement ok
+SELECT main.nextval('test_sequence');
+
+statement ok
+SELECT main.nextval('main.main_sequence');
+
+statement ok
+SELECT main.nextval('main_sequence');
+
+statement error
+SELECT main.nextval('oop_sequence');
+
+statement ok
+SELECT main.nextval('out_of_path.oop_sequence');
+
+statement error
+DROP SEQUENCE main.test_sequence;
+
+statement ok
+DROP SEQUENCE test_sequence;
+
+statement ok
+DROP SEQUENCE test.test_sequence2;
+
+statement ok
+DROP SEQUENCE main_sequence;
+
+statement error
+DROP SEQUENCE oop_sequence;
+
+statement ok
+DROP SEQUENCE out_of_path.oop_sequence;
+
+# Testing ALTER TABLE
+
+statement error
+ALTER TABLE main.test_table ADD COLUMN k INTEGER;
+
+statement ok
+ALTER TABLE main.main_table ADD COLUMN k INTEGER;
+
+statement ok
+ALTER TABLE main_table ADD COLUMN l INTEGER;
+
+statement ok
+ALTER TABLE test_table ADD COLUMN m INTEGER;
+
+statement ok
+ALTER TABLE test.test_table ADD COLUMN n INTEGER;
+
+statement error
+ALTER TABLE oop_table ADD COLUMN o INTEGER;
+
+statement ok
+ALTER TABLE out_of_path.oop_table ADD COLUMN p INTEGER;
+
+# Testing DROP TABLE
+
+statement error
+DROP TABLE main.test_table;
+
+statement error
+DROP TABLE test.main_table;
+
+statement ok
+DROP TABLE test_table;
+
+statement ok
+DROP TABLE main_table;
+
+statement error
+DROP TABLE oop_table;
+
+statement ok
+DROP TABLE out_of_path.oop_table;
+
+statement ok
+CREATE TABLE test_table2(i INTEGER);
+
+statement ok
+DROP TABLE test.test_table2;
+
+statement ok
+CREATE TABLE test_table3(i INTEGER);
+
+statement ok
+DROP TABLE IF EXISTS test_table3;
+
+statement ok
+DROP TABLE IF EXISTS test_table3;
+
+statement ok
+CREATE TABLE test_table4(i INTEGER);
+
+statement ok
+DROP TABLE IF EXISTS test.test_table4;
+
+statement ok
+DROP TABLE IF EXISTS test.test_table4;
+
+statement ok
+CREATE TABLE main.main_table2(i INTEGER);
+
+statement ok
+DROP TABLE IF EXISTS main.main_table2;
+
+statement ok
+DROP TABLE IF EXISTS main.main_table2;
diff --git a/test/sql/catalog/test_set_search_path.test b/test/sql/catalog/test_set_search_path.test
new file mode 100644
index 000000000000..c4ed76f82d64
--- /dev/null
+++ b/test/sql/catalog/test_set_search_path.test
@@ -0,0 +1,204 @@
+# name: test/sql/catalog/test_set_search_path.test
+# description: SET schema and SET search_path
+# group: [catalog]
+
+# create a couple of schemas with a table each
+statement ok
+CREATE TABLE main_table(i INTEGER);
+
+statement ok
+CREATE SCHEMA test;
+
+statement ok
+CREATE TABLE test.test_table(i INTEGER);
+
+statement ok
+CREATE SCHEMA test2;
+
+statement ok
+CREATE TABLE test2.bye(i INTEGER);
+CREATE TABLE test2.test2_table(i INTEGER);
+
+statement ok
+CREATE SCHEMA test3;
+
+statement ok
+CREATE SCHEMA test4;
+
+statement ok
+CREATE SCHEMA test5;
+
+statement ok
+CREATE TABLE test5.test5_table(i INTEGER);
+
+# Reading the config - It should be empty for now.
+statement error
+SELECT CURRENT_SETTING('search_path');
+
+statement error
+SELECT CURRENT_SETTING('schema');
+
+# Setting the default value.
+statement ok
+SET SEARCH_PATH = 'test';
+
+statement ok
+SET SEARCH_PATH = 'test,test2';
+
+statement ok
+SET SEARCH_PATH = '"test","test2"';
+
+statement ok
+SET SEARCH_PATH = '"test","test2"';
+
+statement error
+SET SEARCH_PATH = 'does_not_exist';
+
+# Setting the default value through 'schema'
+
+statement ok
+SET SCHEMA = 'test';
+
+statement error
+SET SCHEMA = 'test,test2';
+
+statement error
+SET SCHEMA = 'does_not_exist';
+
+# Reading out to see how aliasing works.
+
+statement ok
+SET SEARCH_PATH = 'test,test2';
+
+statement error
+SET SEARCH_PATH = '"invalid quoted string list';
+
+query I
+SELECT MAIN.CURRENT_SETTING('search_path');
+----
+test,test2
+
+query I
+SELECT MAIN.CURRENT_SETTING('schema');
+----
+test,test2
+
+statement ok
+SET SCHEMA = 'test';
+
+query I
+SELECT MAIN.CURRENT_SETTING('search_path');
+----
+test
+
+query I
+SELECT MAIN.CURRENT_SETTING('schema');
+----
+test
+
+# Case insensitivity
+
+statement ok
+SET schema = 'test2';
+
+query I
+SELECT CURRENT_SETTING('search_path');
+----
+test2
+
+statement ok
+SET search_path = 'test3';
+
+query I
+SELECT CURRENT_SETTING('search_path');
+----
+test3
+
+# Looking up from multiple schemas
+
+statement ok
+SET SEARCH_PATH = 'test,test2';
+
+statement ok
+SELECT i FROM test_table;
+
+statement ok
+SELECT i FROM test2_table;
+
+statement ok
+SELECT i FROM main_table;
+
+statement ok
+CREATE TABLE main.table_with_same_name(in_main INTEGER);
+
+statement ok
+CREATE TABLE test.table_with_same_name(in_test INTEGER);
+
+statement ok
+CREATE TABLE test2.table_with_same_name(in_test2 INTEGER);
+
+statement error
+---
+SELECT in_main FROM table_with_same_name;
+
+statement error
+---
+SELECT in_test2 FROM table_with_same_name;
+
+statement ok
+---
+SELECT in_test FROM table_with_same_name;
+
+
+# Or even more schemas
+
+statement ok
+SET SEARCH_PATH = 'test,test2,test3,test4,test5';
+
+statement ok
+---
+SELECT i FROM test5_table;
+
+statement ok
+SELECT i FROM test_table;
+
+statement ok
+SELECT i FROM test2_table;
+
+statement ok
+SELECT i FROM main_table;
+
+# Duplicate entry in the path (is allowed)
+
+statement ok
+SET SEARCH_PATH = 'test,test,test2';
+
+statement ok
+SELECT i FROM test_table;
+
+statement ok
+SELECT i FROM test2_table;
+
+statement ok
+SELECT i FROM main_table;
+
+# Multiple connections
+
+statement ok con1
+SET schema = 'test';
+
+statement ok con2
+SET schema = 'test2';
+
+statement ok con1
+SELECT i FROM test_table;
+
+statement error con2
+SELECT i FROM test_table;
+
+statement error con1
+SELECT i FROM test2_table;
+
+statement ok con2
+SELECT i FROM test2_table;
+
diff --git a/test/sql/function/generic/test_set.test b/test/sql/function/generic/test_set.test
index ca8ac20364f8..610ae697a8c2 100644
--- a/test/sql/function/generic/test_set.test
+++ b/test/sql/function/generic/test_set.test
@@ -76,3 +76,29 @@ query I
 SELECT CURRENT_SETTING('shadowed');
 ----
 42
+
+statement ok
+SET SESSION CASE_IS_LOWERED = 42;
+
+query I
+SELECT CURRENT_SETTING('case_is_lowered');
+----
+42
+
+query I
+SELECT CURRENT_SETTING('CASE_IS_LOWERED');
+----
+42
+
+statement ok
+SET SESSION case_is_lowered = 43;
+
+query I
+SELECT CURRENT_SETTING('case_is_lowered');
+----
+43
+
+query I
+SELECT CURRENT_SETTING('CASE_IS_LOWERED');
+----
+43
