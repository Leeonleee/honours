{
  "repo": "duckdb/duckdb",
  "pull_number": 14183,
  "instance_id": "duckdb__duckdb-14183",
  "issue_numbers": [
    "14179"
  ],
  "base_commit": "d58cc56f8554057f9646ea343d845e1b1ba6466e",
  "patch": "diff --git a/tools/pythonpkg/src/python_replacement_scan.cpp b/tools/pythonpkg/src/python_replacement_scan.cpp\nindex 8d1610534789..65eb8c009329 100644\n--- a/tools/pythonpkg/src/python_replacement_scan.cpp\n+++ b/tools/pythonpkg/src/python_replacement_scan.cpp\n@@ -225,6 +225,9 @@ static unique_ptr<TableRef> ReplaceInternal(ClientContext &context, const string\n \t\t\t}\n \t\t}\n \t\tcurrent_frame = current_frame.attr(\"f_back\");\n+\t\tif (py::none().is(current_frame)) {\n+\t\t\tbreak;\n+\t\t}\n \t} while (scan_all_frames && (has_locals || has_globals));\n \treturn nullptr;\n }\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_replacement_scan.py b/tools/pythonpkg/tests/fast/test_replacement_scan.py\nindex 5255c8cac902..c7287bba3ffe 100644\n--- a/tools/pythonpkg/tests/fast/test_replacement_scan.py\n+++ b/tools/pythonpkg/tests/fast/test_replacement_scan.py\n@@ -165,6 +165,12 @@ def test_replacement_scan_relapi(self):\n         assert type(pyrel3) == duckdb.DuckDBPyRelation\n         assert pyrel3.fetchall() == [(142,), (184,)]\n \n+    def test_replacement_scan_not_found(self):\n+        con = duckdb.connect()\n+        con.execute(\"set python_scan_all_frames=true\")\n+        with pytest.raises(duckdb.CatalogException, match='Table with name non_existant does not exist'):\n+            res = con.sql(\"select * from non_existant\").fetchall()\n+\n     def test_replacement_scan_alias(self):\n         con = duckdb.connect()\n         pyrel1 = con.query('from (values (1, 2)) t(i, j)')\n",
  "problem_statement": "Regression: Replacement Scans Misbehave in v1.1\n### What happens?\r\n\r\nWhen importing functions that use `duckdb.sql(\"...\")` from modules, they don't \"see\" the namespace of in-memory dataframes anymore.\r\n\r\nThis was working fine in v1.0.\r\n\r\n### To Reproduce\r\n\r\n## 1) create file `ddb.py` defining a query string with a method to run a DuckDB query:\r\n\r\n```python\r\n%%writefile ddb.py\r\nimport duckdb\r\nprint(f\"DuckDB v{duckdb.__version__}\")\r\nclass Q_IMPORTED(str):\r\n    def run(self):\r\n        return duckdb.sql(self)\r\n```\r\n\r\n## 2) create another version of a query string locally, a sample dataframe, use imported and local query on a dataframe:\r\n```\r\nimport duckdb\r\nimport pandas as pd\r\ndf = pd.DataFrame({\"a\": [42]})\r\n\r\nfrom ddb import Q_IMPORTED\r\n\r\nclass Q_LOCAL(str):\r\n    def run(self):\r\n        return duckdb.sql(self)\r\n\r\ntry:\r\n    Q(\"FROM df\").run()\r\nexcept Exception as e:\r\n    print(\"Q from module\", e)\r\n\r\nQ_LOCAL(\"FROM df\").run()\r\n```\r\n\r\n```\r\nimport duckdb\r\nimport pandas as pd\r\ndf = pd.DataFrame({\"a\": [42]})\r\n\r\nfrom ddb import Q_IMPORTED\r\n\r\nclass Q_LOCAL(str):\r\n    def run(self):\r\n        return duckdb.sql(self)\r\n\r\ntry:\r\n    df_from_imported = Q_IMPORTED(\"FROM df\").run().df()\r\nexcept Exception as e:\r\n    print(\"Q from module\", e)\r\n    df_from_imported = None\r\n\r\ndf_from_local = Q_LOCAL(\"FROM df\").run().df()\r\npd.testing.assert_frame_equal(df_from_imported, df_from_local)\r\n```\r\n\r\n### output in v1.0.0\r\n```\r\nDuckDB v1.0.0\r\n```\r\n\r\n\r\n### Output in v1.1.1\r\n```\r\nDuckDB v1.1.1\r\nQ from module Catalog Error: Table with name df does not exist!\r\nDid you mean \"pg_depend\"?\r\n---------------------------------------------------------------------------\r\nAssertionError \r\n```\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n1.1\r\n\r\n### DuckDB Client:\r\n\r\npython\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nAlex\r\n\r\n### Affiliation:\r\n\r\nself\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Likely duplicate of #13836 \nLooks like it.  Similar behavior: works in the same environment but not from outside.\r\n\r\n> Previously we would scan all stack frames in an effort to find a suitable replacement, now we limit it to only the current frame (which is also what Python itself does)\r\n - #12425 \r\n\r\nSo how do you work around it?\n `set python_scan_all_frames=true` to get the old, and frankly, worse behavior\nThanks, that's useful.  I have a substantial number of reports where I'm building data stepwise starting with a non-DuckDB query to MSSQL followed by DuckDB queries to other resources; I'd either have to pin to 1.0 or revise. \r\n\r\nFWIW, I've never had issues with the old behavior.\n> `set python_scan_all_frames=true` to get the old, and frankly, worse behavior\r\n\r\nActually, further down the line stuff is breaking with \r\n`AttributeError: 'NoneType' object has no attribute 'f_locals'`; this piece was introduced in this PR\r\nhttps://github.com/duckdb/duckdb/pull/13896",
  "created_at": "2024-10-01T08:36:44Z"
}