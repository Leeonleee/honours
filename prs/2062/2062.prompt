You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
WHERE clauses not working with parquet files
**What does happen?**
I am querying a parquet file.
SELECT *, SELECT COUNT(*), GROUP BY work fine.
But when I use a WHERE clause the query always returns empty.

**What should happen?**
The WHERE filter should be applied.

**To Reproduce**
Steps to reproduce the behavior. Bonus points if those are only SQL queries.

It is hard to share the dataset.

```
select item_id, region_id, metric_id from 'data.parquet' LIMIT 10
┌─────────┬───────────┬───────────┐
│ item_id │ region_id │ metric_id │
├─────────┼───────────┼───────────┤
│ 1       │ 0         │ 11078     │
│ 1       │ 1001      │ 11078     │
│ 1       │ 1001      │ 20032     │
│ 1       │ 0         │ 20032     │
│ 1       │ 0         │ 20032     │
│ 1       │ 0         │ 20032     │
│ 1       │ 1001      │ 20032     │
│ 1       │ 1001      │ 20032     │
│ 1       │ 1001      │ 20032     │
│ 1       │ 1001      │ 20032     │
└─────────┴───────────┴───────────┘

```

```
select item_id, region_id, metric_id from 'data.parquet' LIMIT 10
```
returns nothing.

**Environment (please complete the following information):**
 - OS: Darwin Kernel Version 20.5.0: Sat May  8 05:10:33 PDT 2021; root:xnu-7195.121.3~9/RELEASE_X86_64 x86_64
 - v0.2.7 8bc050d05

**Before submitting**
- [X] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?
- [X] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds


</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![codecov](https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN)](https://codecov.io/gh/duckdb/duckdb)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/common/value_operations/comparison_operations.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/common/operator/comparison_operators.hpp"
3: #include "duckdb/common/value_operations/value_operations.hpp"
4: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
5: 
6: namespace duckdb {
7: 
8: //===--------------------------------------------------------------------===//
9: // Comparison Operations
10: //===--------------------------------------------------------------------===//
11: 
12: struct ValuePositionComparator {
13: 	// Return true if the positional Values definitely match.
14: 	// Default to the same as the final value
15: 	template <typename OP>
16: 	static inline bool Definite(const Value &lhs, const Value &rhs) {
17: 		return Final<OP>(lhs, rhs);
18: 	}
19: 
20: 	// Select the positional Values that need further testing.
21: 	// Usually this means Is Not Distinct, as those are the semantics used by Postges
22: 	template <typename OP>
23: 	static inline bool Possible(const Value &lhs, const Value &rhs) {
24: 		return ValueOperations::NotDistinctFrom(lhs, rhs);
25: 	}
26: 
27: 	// Return true if the positional Values definitely match in the final position
28: 	// This needs to be specialised.
29: 	template <typename OP>
30: 	static inline bool Final(const Value &lhs, const Value &rhs) {
31: 		return false;
32: 	}
33: 
34: 	// Tie-break based on length when one of the sides has been exhausted, returning true if the LHS matches.
35: 	// This essentially means that the existing positions compare equal.
36: 	// Default to the same semantics as the OP for idx_t. This works in most cases.
37: 	template <typename OP>
38: 	static inline bool TieBreak(const idx_t lpos, const idx_t rpos) {
39: 		return OP::Operation(lpos, rpos);
40: 	}
41: };
42: 
43: // Equals must always check every column
44: template <>
45: inline bool ValuePositionComparator::Definite<duckdb::Equals>(const Value &lhs, const Value &rhs) {
46: 	return false;
47: }
48: 
49: template <>
50: inline bool ValuePositionComparator::Final<duckdb::Equals>(const Value &lhs, const Value &rhs) {
51: 	return ValueOperations::NotDistinctFrom(lhs, rhs);
52: }
53: 
54: // NotEquals must check everything that matched
55: template <>
56: inline bool ValuePositionComparator::Possible<duckdb::NotEquals>(const Value &lhs, const Value &rhs) {
57: 	return true;
58: }
59: 
60: template <>
61: inline bool ValuePositionComparator::Final<duckdb::NotEquals>(const Value &lhs, const Value &rhs) {
62: 	return ValueOperations::NotDistinctFrom(lhs, rhs);
63: }
64: 
65: // Non-strict inequalities must use strict comparisons for Definite
66: template <>
67: bool ValuePositionComparator::Definite<duckdb::LessThanEquals>(const Value &lhs, const Value &rhs) {
68: 	return ValueOperations::DistinctLessThan(lhs, rhs);
69: }
70: 
71: template <>
72: bool ValuePositionComparator::Final<duckdb::LessThanEquals>(const Value &lhs, const Value &rhs) {
73: 	return ValueOperations::DistinctLessThanEquals(lhs, rhs);
74: }
75: 
76: template <>
77: bool ValuePositionComparator::Definite<duckdb::GreaterThanEquals>(const Value &lhs, const Value &rhs) {
78: 	return ValueOperations::DistinctGreaterThan(lhs, rhs);
79: }
80: 
81: template <>
82: bool ValuePositionComparator::Final<duckdb::GreaterThanEquals>(const Value &lhs, const Value &rhs) {
83: 	return ValueOperations::DistinctGreaterThanEquals(lhs, rhs);
84: }
85: 
86: // Strict inequalities just use strict for both Definite and Final
87: template <>
88: bool ValuePositionComparator::Final<duckdb::LessThan>(const Value &lhs, const Value &rhs) {
89: 	return ValueOperations::DistinctLessThan(lhs, rhs);
90: }
91: 
92: template <>
93: bool ValuePositionComparator::Final<duckdb::GreaterThan>(const Value &lhs, const Value &rhs) {
94: 	return ValueOperations::DistinctGreaterThan(lhs, rhs);
95: }
96: 
97: template <class OP>
98: static bool TemplatedBooleanOperation(const Value &left, const Value &right) {
99: 	const auto &left_type = left.type();
100: 	const auto &right_type = right.type();
101: 	if (left_type != right_type) {
102: 		try {
103: 			LogicalType comparison_type = BoundComparisonExpression::BindComparison(left_type, right_type);
104: 			return TemplatedBooleanOperation<OP>(left.CastAs(comparison_type), right.CastAs(comparison_type));
105: 		} catch (...) {
106: 			return false;
107: 		}
108: 	}
109: 	switch (left_type.InternalType()) {
110: 	case PhysicalType::BOOL:
111: 		return OP::Operation(left.value_.boolean, right.value_.boolean);
112: 	case PhysicalType::INT8:
113: 		return OP::Operation(left.value_.tinyint, right.value_.tinyint);
114: 	case PhysicalType::INT16:
115: 		return OP::Operation(left.value_.smallint, right.value_.smallint);
116: 	case PhysicalType::INT32:
117: 		return OP::Operation(left.value_.integer, right.value_.integer);
118: 	case PhysicalType::INT64:
119: 		return OP::Operation(left.value_.bigint, right.value_.bigint);
120: 	case PhysicalType::UINT8:
121: 		return OP::Operation(left.value_.utinyint, right.value_.utinyint);
122: 	case PhysicalType::UINT16:
123: 		return OP::Operation(left.value_.usmallint, right.value_.usmallint);
124: 	case PhysicalType::UINT32:
125: 		return OP::Operation(left.value_.uinteger, right.value_.uinteger);
126: 	case PhysicalType::UINT64:
127: 		return OP::Operation(left.value_.ubigint, right.value_.ubigint);
128: 	case PhysicalType::INT128:
129: 		return OP::Operation(left.value_.hugeint, right.value_.hugeint);
130: 	case PhysicalType::FLOAT:
131: 		return OP::Operation(left.value_.float_, right.value_.float_);
132: 	case PhysicalType::DOUBLE:
133: 		return OP::Operation(left.value_.double_, right.value_.double_);
134: 	case PhysicalType::INTERVAL:
135: 		return OP::Operation(left.value_.interval, right.value_.interval);
136: 	case PhysicalType::VARCHAR:
137: 		return OP::Operation(left.str_value, right.str_value);
138: 	case PhysicalType::STRUCT: {
139: 		// this should be enforced by the type
140: 		D_ASSERT(left.struct_value.size() == right.struct_value.size());
141: 		idx_t i = 0;
142: 		for (; i < left.struct_value.size() - 1; ++i) {
143: 			if (ValuePositionComparator::Definite<OP>(left.struct_value[i], right.struct_value[i])) {
144: 				return true;
145: 			}
146: 			if (!ValuePositionComparator::Possible<OP>(left.struct_value[i], right.struct_value[i])) {
147: 				return false;
148: 			}
149: 		}
150: 		return ValuePositionComparator::Final<OP>(left.struct_value[i], right.struct_value[i]);
151: 	}
152: 	case PhysicalType::LIST: {
153: 		for (idx_t pos = 0;; ++pos) {
154: 			if (pos == left.list_value.size() || pos == right.list_value.size()) {
155: 				return ValuePositionComparator::TieBreak<OP>(left.list_value.size(), right.list_value.size());
156: 			}
157: 			if (ValuePositionComparator::Definite<OP>(left.list_value[pos], right.list_value[pos])) {
158: 				return true;
159: 			}
160: 			if (!ValuePositionComparator::Possible<OP>(left.list_value[pos], right.list_value[pos])) {
161: 				return false;
162: 			}
163: 		}
164: 		return false;
165: 	}
166: 	default:
167: 		throw InternalException("Unimplemented type for value comparison");
168: 	}
169: }
170: 
171: bool ValueOperations::Equals(const Value &left, const Value &right) {
172: 	if (left.is_null && right.is_null) {
173: 		return true;
174: 	}
175: 	if (left.is_null != right.is_null) {
176: 		return false;
177: 	}
178: 	return TemplatedBooleanOperation<duckdb::Equals>(left, right);
179: }
180: 
181: bool ValueOperations::NotEquals(const Value &left, const Value &right) {
182: 	return !ValueOperations::Equals(left, right);
183: }
184: 
185: bool ValueOperations::GreaterThan(const Value &left, const Value &right) {
186: 	if (left.is_null && right.is_null) {
187: 		return false;
188: 	} else if (right.is_null) {
189: 		return true;
190: 	} else if (left.is_null) {
191: 		return false;
192: 	}
193: 	return TemplatedBooleanOperation<duckdb::GreaterThan>(left, right);
194: }
195: 
196: bool ValueOperations::GreaterThanEquals(const Value &left, const Value &right) {
197: 	if (left.is_null && right.is_null) {
198: 		return true;
199: 	} else if (right.is_null) {
200: 		return true;
201: 	} else if (left.is_null) {
202: 		return false;
203: 	}
204: 	return TemplatedBooleanOperation<duckdb::GreaterThanEquals>(left, right);
205: }
206: 
207: bool ValueOperations::LessThan(const Value &left, const Value &right) {
208: 	return ValueOperations::GreaterThan(right, left);
209: }
210: 
211: bool ValueOperations::LessThanEquals(const Value &left, const Value &right) {
212: 	return ValueOperations::GreaterThanEquals(right, left);
213: }
214: 
215: bool ValueOperations::NotDistinctFrom(const Value &left, const Value &right) {
216: 	if (left.is_null && right.is_null) {
217: 		return true;
218: 	}
219: 	if (left.is_null != right.is_null) {
220: 		return false;
221: 	}
222: 	return TemplatedBooleanOperation<duckdb::Equals>(left, right);
223: }
224: 
225: bool ValueOperations::DistinctFrom(const Value &left, const Value &right) {
226: 	return !ValueOperations::NotDistinctFrom(left, right);
227: }
228: 
229: bool ValueOperations::DistinctGreaterThan(const Value &left, const Value &right) {
230: 	if (left.is_null && right.is_null) {
231: 		return false;
232: 	} else if (right.is_null) {
233: 		return false;
234: 	} else if (left.is_null) {
235: 		return true;
236: 	}
237: 	return TemplatedBooleanOperation<duckdb::GreaterThan>(left, right);
238: }
239: 
240: bool ValueOperations::DistinctGreaterThanEquals(const Value &left, const Value &right) {
241: 	if (left.is_null) {
242: 		return true;
243: 	} else if (right.is_null) {
244: 		return false;
245: 	}
246: 	return TemplatedBooleanOperation<duckdb::GreaterThanEquals>(left, right);
247: }
248: 
249: bool ValueOperations::DistinctLessThan(const Value &left, const Value &right) {
250: 	return ValueOperations::DistinctGreaterThan(right, left);
251: }
252: 
253: bool ValueOperations::DistinctLessThanEquals(const Value &left, const Value &right) {
254: 	return ValueOperations::DistinctGreaterThanEquals(right, left);
255: }
256: 
257: } // namespace duckdb
[end of src/common/value_operations/comparison_operations.cpp]
[start of src/optimizer/filter_combiner.cpp]
1: #include "duckdb/optimizer/filter_combiner.hpp"
2: 
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/planner/expression.hpp"
5: #include "duckdb/planner/expression/bound_between_expression.hpp"
6: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
7: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
8: #include "duckdb/planner/expression/bound_conjunction_expression.hpp"
9: #include "duckdb/planner/expression/bound_constant_expression.hpp"
10: #include "duckdb/planner/expression/bound_function_expression.hpp"
11: #include "duckdb/planner/operator/logical_empty_result.hpp"
12: #include "duckdb/planner/operator/logical_filter.hpp"
13: #include "duckdb/planner/table_filter.hpp"
14: #include "duckdb/planner/filter/constant_filter.hpp"
15: #include "duckdb/planner/filter/null_filter.hpp"
16: 
17: #include "duckdb/common/operator/cast_operators.hpp"
18: 
19: namespace duckdb {
20: 
21: using ExpressionValueInformation = FilterCombiner::ExpressionValueInformation;
22: 
23: ValueComparisonResult CompareValueInformation(ExpressionValueInformation &left, ExpressionValueInformation &right);
24: 
25: Expression *FilterCombiner::GetNode(Expression *expr) {
26: 	auto entry = stored_expressions.find(expr);
27: 	if (entry != stored_expressions.end()) {
28: 		// expression already exists: return a reference to the stored expression
29: 		return entry->second.get();
30: 	}
31: 	// expression does not exist yet: create a copy and store it
32: 	auto copy = expr->Copy();
33: 	auto pointer_copy = copy.get();
34: 	D_ASSERT(stored_expressions.find(pointer_copy) == stored_expressions.end());
35: 	stored_expressions.insert(make_pair(pointer_copy, move(copy)));
36: 	return pointer_copy;
37: }
38: 
39: idx_t FilterCombiner::GetEquivalenceSet(Expression *expr) {
40: 	D_ASSERT(stored_expressions.find(expr) != stored_expressions.end());
41: 	D_ASSERT(stored_expressions.find(expr)->second.get() == expr);
42: 	auto entry = equivalence_set_map.find(expr);
43: 	if (entry == equivalence_set_map.end()) {
44: 		idx_t index = set_index++;
45: 		equivalence_set_map[expr] = index;
46: 		equivalence_map[index].push_back(expr);
47: 		constant_values.insert(make_pair(index, vector<ExpressionValueInformation>()));
48: 		return index;
49: 	} else {
50: 		return entry->second;
51: 	}
52: }
53: 
54: FilterResult FilterCombiner::AddConstantComparison(vector<ExpressionValueInformation> &info_list,
55:                                                    ExpressionValueInformation info) {
56: 	for (idx_t i = 0; i < info_list.size(); i++) {
57: 		auto comparison = CompareValueInformation(info_list[i], info);
58: 		switch (comparison) {
59: 		case ValueComparisonResult::PRUNE_LEFT:
60: 			// prune the entry from the info list
61: 			info_list.erase(info_list.begin() + i);
62: 			i--;
63: 			break;
64: 		case ValueComparisonResult::PRUNE_RIGHT:
65: 			// prune the current info
66: 			return FilterResult::SUCCESS;
67: 		case ValueComparisonResult::UNSATISFIABLE_CONDITION:
68: 			// combination of filters is unsatisfiable: prune the entire branch
69: 			return FilterResult::UNSATISFIABLE;
70: 		default:
71: 			// prune nothing, move to the next condition
72: 			break;
73: 		}
74: 	}
75: 	// finally add the entry to the list
76: 	info_list.push_back(info);
77: 	return FilterResult::SUCCESS;
78: }
79: 
80: FilterResult FilterCombiner::AddFilter(unique_ptr<Expression> expr) {
81: 	// try to push the filter into the combiner
82: 	auto result = AddFilter(expr.get());
83: 	if (result == FilterResult::UNSUPPORTED) {
84: 		// unsupported filter, push into remaining filters
85: 		remaining_filters.push_back(move(expr));
86: 		return FilterResult::SUCCESS;
87: 	}
88: 	return result;
89: }
90: 
91: void FilterCombiner::GenerateFilters(const std::function<void(unique_ptr<Expression> filter)> &callback) {
92: 	// first loop over the remaining filters
93: 	for (auto &filter : remaining_filters) {
94: 		callback(move(filter));
95: 	}
96: 	remaining_filters.clear();
97: 	// now loop over the equivalence sets
98: 	for (auto &entry : equivalence_map) {
99: 		auto equivalence_set = entry.first;
100: 		auto &entries = entry.second;
101: 		auto &constant_list = constant_values.find(equivalence_set)->second;
102: 		// for each entry generate an equality expression comparing to each other
103: 		for (idx_t i = 0; i < entries.size(); i++) {
104: 			for (idx_t k = i + 1; k < entries.size(); k++) {
105: 				auto comparison = make_unique<BoundComparisonExpression>(ExpressionType::COMPARE_EQUAL,
106: 				                                                         entries[i]->Copy(), entries[k]->Copy());
107: 				callback(move(comparison));
108: 			}
109: 			// for each entry also create a comparison with each constant
110: 			int lower_index = -1, upper_index = -1;
111: 			bool lower_inclusive, upper_inclusive;
112: 			for (idx_t k = 0; k < constant_list.size(); k++) {
113: 				auto &info = constant_list[k];
114: 				if (info.comparison_type == ExpressionType::COMPARE_GREATERTHAN ||
115: 				    info.comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO) {
116: 					lower_index = k;
117: 					lower_inclusive = info.comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO;
118: 				} else if (info.comparison_type == ExpressionType::COMPARE_LESSTHAN ||
119: 				           info.comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO) {
120: 					upper_index = k;
121: 					upper_inclusive = info.comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO;
122: 				} else {
123: 					auto constant = make_unique<BoundConstantExpression>(info.constant);
124: 					auto comparison = make_unique<BoundComparisonExpression>(info.comparison_type, entries[i]->Copy(),
125: 					                                                         move(constant));
126: 					callback(move(comparison));
127: 				}
128: 			}
129: 			if (lower_index >= 0 && upper_index >= 0) {
130: 				// found both lower and upper index, create a BETWEEN expression
131: 				auto lower_constant = make_unique<BoundConstantExpression>(constant_list[lower_index].constant);
132: 				auto upper_constant = make_unique<BoundConstantExpression>(constant_list[upper_index].constant);
133: 				auto between = make_unique<BoundBetweenExpression>(
134: 				    entries[i]->Copy(), move(lower_constant), move(upper_constant), lower_inclusive, upper_inclusive);
135: 				callback(move(between));
136: 			} else if (lower_index >= 0) {
137: 				// only lower index found, create simple comparison expression
138: 				auto constant = make_unique<BoundConstantExpression>(constant_list[lower_index].constant);
139: 				auto comparison = make_unique<BoundComparisonExpression>(constant_list[lower_index].comparison_type,
140: 				                                                         entries[i]->Copy(), move(constant));
141: 				callback(move(comparison));
142: 			} else if (upper_index >= 0) {
143: 				// only upper index found, create simple comparison expression
144: 				auto constant = make_unique<BoundConstantExpression>(constant_list[upper_index].constant);
145: 				auto comparison = make_unique<BoundComparisonExpression>(constant_list[upper_index].comparison_type,
146: 				                                                         entries[i]->Copy(), move(constant));
147: 				callback(move(comparison));
148: 			}
149: 		}
150: 	}
151: 	stored_expressions.clear();
152: 	equivalence_set_map.clear();
153: 	constant_values.clear();
154: 	equivalence_map.clear();
155: }
156: 
157: bool FilterCombiner::HasFilters() {
158: 	bool has_filters = false;
159: 	GenerateFilters([&](unique_ptr<Expression> child) { has_filters = true; });
160: 	return has_filters;
161: }
162: 
163: // unordered_map<idx_t, std::pair<Value *, Value *>> MergeAnd(unordered_map<idx_t, std::pair<Value *, Value *>> &f_1,
164: //                                                            unordered_map<idx_t, std::pair<Value *, Value *>> &f_2) {
165: // 	unordered_map<idx_t, std::pair<Value *, Value *>> result;
166: // 	for (auto &f : f_1) {
167: // 		auto it = f_2.find(f.first);
168: // 		if (it == f_2.end()) {
169: // 			result[f.first] = f.second;
170: // 		} else {
171: // 			Value *min = nullptr, *max = nullptr;
172: // 			if (it->second.first && f.second.first) {
173: // 				if (*f.second.first > *it->second.first) {
174: // 					min = f.second.first;
175: // 				} else {
176: // 					min = it->second.first;
177: // 				}
178: 
179: // 			} else if (it->second.first) {
180: // 				min = it->second.first;
181: // 			} else if (f.second.first) {
182: // 				min = f.second.first;
183: // 			} else {
184: // 				min = nullptr;
185: // 			}
186: // 			if (it->second.second && f.second.second) {
187: // 				if (*f.second.second < *it->second.second) {
188: // 					max = f.second.second;
189: // 				} else {
190: // 					max = it->second.second;
191: // 				}
192: // 			} else if (it->second.second) {
193: // 				max = it->second.second;
194: // 			} else if (f.second.second) {
195: // 				max = f.second.second;
196: // 			} else {
197: // 				max = nullptr;
198: // 			}
199: // 			result[f.first] = {min, max};
200: // 			f_2.erase(f.first);
201: // 		}
202: // 	}
203: // 	for (auto &f : f_2) {
204: // 		result[f.first] = f.second;
205: // 	}
206: // 	return result;
207: // }
208: 
209: // unordered_map<idx_t, std::pair<Value *, Value *>> MergeOr(unordered_map<idx_t, std::pair<Value *, Value *>> &f_1,
210: //                                                           unordered_map<idx_t, std::pair<Value *, Value *>> &f_2) {
211: // 	unordered_map<idx_t, std::pair<Value *, Value *>> result;
212: // 	for (auto &f : f_1) {
213: // 		auto it = f_2.find(f.first);
214: // 		if (it != f_2.end()) {
215: // 			Value *min = nullptr, *max = nullptr;
216: // 			if (it->second.first && f.second.first) {
217: // 				if (*f.second.first < *it->second.first) {
218: // 					min = f.second.first;
219: // 				} else {
220: // 					min = it->second.first;
221: // 				}
222: // 			}
223: // 			if (it->second.second && f.second.second) {
224: // 				if (*f.second.second > *it->second.second) {
225: // 					max = f.second.second;
226: // 				} else {
227: // 					max = it->second.second;
228: // 				}
229: // 			}
230: // 			result[f.first] = {min, max};
231: // 			f_2.erase(f.first);
232: // 		}
233: // 	}
234: // 	return result;
235: // }
236: 
237: // unordered_map<idx_t, std::pair<Value *, Value *>>
238: // FilterCombiner::FindZonemapChecks(vector<idx_t> &column_ids, unordered_set<idx_t> &not_constants, Expression *filter)
239: // { 	unordered_map<idx_t, std::pair<Value *, Value *>> checks; 	switch (filter->type) { 	case
240: // ExpressionType::CONJUNCTION_OR: {
241: // 		//! For a filter to
242: // 		auto &or_exp = (BoundConjunctionExpression &)*filter;
243: // 		checks = FindZonemapChecks(column_ids, not_constants, or_exp.children[0].get());
244: // 		for (size_t i = 1; i < or_exp.children.size(); ++i) {
245: // 			auto child_check = FindZonemapChecks(column_ids, not_constants, or_exp.children[i].get());
246: // 			checks = MergeOr(checks, child_check);
247: // 		}
248: // 		return checks;
249: // 	}
250: // 	case ExpressionType::CONJUNCTION_AND: {
251: // 		auto &and_exp = (BoundConjunctionExpression &)*filter;
252: // 		checks = FindZonemapChecks(column_ids, not_constants, and_exp.children[0].get());
253: // 		for (size_t i = 1; i < and_exp.children.size(); ++i) {
254: // 			auto child_check = FindZonemapChecks(column_ids, not_constants, and_exp.children[i].get());
255: // 			checks = MergeAnd(checks, child_check);
256: // 		}
257: // 		return checks;
258: // 	}
259: // 	case ExpressionType::COMPARE_IN: {
260: // 		auto &comp_in_exp = (BoundOperatorExpression &)*filter;
261: // 		if (comp_in_exp.children[0]->type == ExpressionType::BOUND_COLUMN_REF) {
262: // 			Value *min = nullptr, *max = nullptr;
263: // 			auto &column_ref = (BoundColumnRefExpression &)*comp_in_exp.children[0].get();
264: // 			for (size_t i {1}; i < comp_in_exp.children.size(); i++) {
265: // 				if (comp_in_exp.children[i]->type != ExpressionType::VALUE_CONSTANT) {
266: // 					//! This indicates the column has a comparison that is not with a constant
267: // 					not_constants.insert(column_ids[column_ref.binding.column_index]);
268: // 					break;
269: // 				} else {
270: // 					auto &const_value_expr = (BoundConstantExpression &)*comp_in_exp.children[i].get();
271: // 					if (const_value_expr.value.is_null) {
272: // 						return checks;
273: // 					}
274: // 					if (!min && !max) {
275: // 						min = &const_value_expr.value;
276: // 						max = min;
277: // 					} else {
278: // 						if (*min > const_value_expr.value) {
279: // 							min = &const_value_expr.value;
280: // 						}
281: // 						if (*max < const_value_expr.value) {
282: // 							max = &const_value_expr.value;
283: // 						}
284: // 					}
285: // 				}
286: // 			}
287: // 			checks[column_ids[column_ref.binding.column_index]] = {min, max};
288: // 		}
289: // 		return checks;
290: // 	}
291: // 	case ExpressionType::COMPARE_EQUAL: {
292: // 		auto &comp_exp = (BoundComparisonExpression &)*filter;
293: // 		if ((comp_exp.left->expression_class == ExpressionClass::BOUND_COLUMN_REF &&
294: // 		     comp_exp.right->expression_class == ExpressionClass::BOUND_CONSTANT)) {
295: // 			auto &column_ref = (BoundColumnRefExpression &)*comp_exp.left;
296: // 			auto &constant_value_expr = (BoundConstantExpression &)*comp_exp.right;
297: // 			checks[column_ids[column_ref.binding.column_index]] = {&constant_value_expr.value,
298: // 			                                                       &constant_value_expr.value};
299: // 		}
300: // 		if ((comp_exp.left->expression_class == ExpressionClass::BOUND_CONSTANT &&
301: // 		     comp_exp.right->expression_class == ExpressionClass::BOUND_COLUMN_REF)) {
302: // 			auto &column_ref = (BoundColumnRefExpression &)*comp_exp.right;
303: // 			auto &constant_value_expr = (BoundConstantExpression &)*comp_exp.left;
304: // 			checks[column_ids[column_ref.binding.column_index]] = {&constant_value_expr.value,
305: // 			                                                       &constant_value_expr.value};
306: // 		}
307: // 		return checks;
308: // 	}
309: // 	case ExpressionType::COMPARE_LESSTHAN:
310: // 	case ExpressionType::COMPARE_LESSTHANOREQUALTO: {
311: // 		auto &comp_exp = (BoundComparisonExpression &)*filter;
312: // 		if ((comp_exp.left->expression_class == ExpressionClass::BOUND_COLUMN_REF &&
313: // 		     comp_exp.right->expression_class == ExpressionClass::BOUND_CONSTANT)) {
314: // 			auto &column_ref = (BoundColumnRefExpression &)*comp_exp.left;
315: // 			auto &constant_value_expr = (BoundConstantExpression &)*comp_exp.right;
316: // 			checks[column_ids[column_ref.binding.column_index]] = {nullptr, &constant_value_expr.value};
317: // 		}
318: // 		if ((comp_exp.left->expression_class == ExpressionClass::BOUND_CONSTANT &&
319: // 		     comp_exp.right->expression_class == ExpressionClass::BOUND_COLUMN_REF)) {
320: // 			auto &column_ref = (BoundColumnRefExpression &)*comp_exp.right;
321: // 			auto &constant_value_expr = (BoundConstantExpression &)*comp_exp.left;
322: // 			checks[column_ids[column_ref.binding.column_index]] = {&constant_value_expr.value, nullptr};
323: // 		}
324: // 		return checks;
325: // 	}
326: // 	case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
327: // 	case ExpressionType::COMPARE_GREATERTHAN: {
328: // 		auto &comp_exp = (BoundComparisonExpression &)*filter;
329: // 		if ((comp_exp.left->expression_class == ExpressionClass::BOUND_COLUMN_REF &&
330: // 		     comp_exp.right->expression_class == ExpressionClass::BOUND_CONSTANT)) {
331: // 			auto &column_ref = (BoundColumnRefExpression &)*comp_exp.left;
332: // 			auto &constant_value_expr = (BoundConstantExpression &)*comp_exp.right;
333: // 			checks[column_ids[column_ref.binding.column_index]] = {&constant_value_expr.value, nullptr};
334: // 		}
335: // 		if ((comp_exp.left->expression_class == ExpressionClass::BOUND_CONSTANT &&
336: // 		     comp_exp.right->expression_class == ExpressionClass::BOUND_COLUMN_REF)) {
337: // 			auto &column_ref = (BoundColumnRefExpression &)*comp_exp.right;
338: // 			auto &constant_value_expr = (BoundConstantExpression &)*comp_exp.left;
339: // 			checks[column_ids[column_ref.binding.column_index]] = {nullptr, &constant_value_expr.value};
340: // 		}
341: // 		return checks;
342: // 	}
343: // 	default:
344: // 		return checks;
345: // 	}
346: // }
347: 
348: // vector<TableFilter> FilterCombiner::GenerateZonemapChecks(vector<idx_t> &column_ids,
349: //                                                           vector<TableFilter> &pushed_filters) {
350: // 	vector<TableFilter> zonemap_checks;
351: // 	unordered_set<idx_t> not_constants;
352: // 	//! We go through the remaining filters and capture their min max
353: // 	if (remaining_filters.empty()) {
354: // 		return zonemap_checks;
355: // 	}
356: 
357: // 	auto checks = FindZonemapChecks(column_ids, not_constants, remaining_filters[0].get());
358: // 	for (size_t i = 1; i < remaining_filters.size(); ++i) {
359: // 		auto child_check = FindZonemapChecks(column_ids, not_constants, remaining_filters[i].get());
360: // 		checks = MergeAnd(checks, child_check);
361: // 	}
362: // 	//! We construct the equivalent filters
363: // 	for (auto not_constant : not_constants) {
364: // 		checks.erase(not_constant);
365: // 	}
366: // 	for (const auto &pushed_filter : pushed_filters) {
367: // 		checks.erase(column_ids[pushed_filter.column_index]);
368: // 	}
369: // 	for (const auto &check : checks) {
370: // 		if (check.second.first) {
371: // 			zonemap_checks.emplace_back(check.second.first->Copy(), ExpressionType::COMPARE_GREATERTHANOREQUALTO,
372: // 			                            check.first);
373: // 		}
374: // 		if (check.second.second) {
375: // 			zonemap_checks.emplace_back(check.second.second->Copy(), ExpressionType::COMPARE_LESSTHANOREQUALTO,
376: // 			                            check.first);
377: // 		}
378: // 	}
379: // 	return zonemap_checks;
380: // }
381: 
382: TableFilterSet FilterCombiner::GenerateTableScanFilters(vector<idx_t> &column_ids) {
383: 	TableFilterSet table_filters;
384: 	//! First, we figure the filters that have constant expressions that we can push down to the table scan
385: 	for (auto &constant_value : constant_values) {
386: 		if (!constant_value.second.empty()) {
387: 			auto filter_exp = equivalence_map.end();
388: 			if ((constant_value.second[0].comparison_type == ExpressionType::COMPARE_EQUAL ||
389: 			     constant_value.second[0].comparison_type == ExpressionType::COMPARE_GREATERTHAN ||
390: 			     constant_value.second[0].comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO ||
391: 			     constant_value.second[0].comparison_type == ExpressionType::COMPARE_LESSTHAN ||
392: 			     constant_value.second[0].comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO) &&
393: 			    (TypeIsNumeric(constant_value.second[0].constant.type().InternalType()) ||
394: 			     constant_value.second[0].constant.type().InternalType() == PhysicalType::VARCHAR)) {
395: 				//! Here we check if these filters are column references
396: 				filter_exp = equivalence_map.find(constant_value.first);
397: 				if (filter_exp->second.size() == 1 && filter_exp->second[0]->type == ExpressionType::BOUND_COLUMN_REF) {
398: 					auto filter_col_exp = static_cast<BoundColumnRefExpression *>(filter_exp->second[0]);
399: 					auto column_index = column_ids[filter_col_exp->binding.column_index];
400: 					if (column_index == COLUMN_IDENTIFIER_ROW_ID) {
401: 						break;
402: 					}
403: 					auto equivalence_set = filter_exp->first;
404: 					auto &entries = filter_exp->second;
405: 					auto &constant_list = constant_values.find(equivalence_set)->second;
406: 					// for each entry generate an equality expression comparing to each other
407: 					for (idx_t i = 0; i < entries.size(); i++) {
408: 						// for each entry also create a comparison with each constant
409: 						for (idx_t k = 0; k < constant_list.size(); k++) {
410: 							auto constant_filter = make_unique<ConstantFilter>(constant_value.second[k].comparison_type,
411: 							                                                   constant_value.second[k].constant);
412: 							table_filters.PushFilter(column_index, move(constant_filter));
413: 						}
414: 						table_filters.PushFilter(column_index, make_unique<IsNotNullFilter>());
415: 					}
416: 					equivalence_map.erase(filter_exp);
417: 				}
418: 			}
419: 		}
420: 	}
421: 	//! Here we look for LIKE or IN filters
422: 	for (idx_t rem_fil_idx = 0; rem_fil_idx < remaining_filters.size(); rem_fil_idx++) {
423: 		auto &remaining_filter = remaining_filters[rem_fil_idx];
424: 		if (remaining_filter->expression_class == ExpressionClass::BOUND_FUNCTION) {
425: 			auto &func = (BoundFunctionExpression &)*remaining_filter;
426: 			if (func.function.name == "prefix" &&
427: 			    func.children[0]->expression_class == ExpressionClass::BOUND_COLUMN_REF &&
428: 			    func.children[1]->type == ExpressionType::VALUE_CONSTANT) {
429: 				//! This is a like function.
430: 				auto &column_ref = (BoundColumnRefExpression &)*func.children[0].get();
431: 				auto &constant_value_expr = (BoundConstantExpression &)*func.children[1].get();
432: 				string like_string = constant_value_expr.value.str_value;
433: 				if (like_string.empty()) {
434: 					continue;
435: 				}
436: 				auto column_index = column_ids[column_ref.binding.column_index];
437: 				auto const_value = constant_value_expr.value.Copy();
438: 				const_value.str_value = like_string;
439: 				//! Here the like must be transformed to a BOUND COMPARISON geq le
440: 				auto lower_bound =
441: 				    make_unique<ConstantFilter>(ExpressionType::COMPARE_GREATERTHANOREQUALTO, const_value);
442: 				const_value.str_value[const_value.str_value.size() - 1]++;
443: 				auto upper_bound = make_unique<ConstantFilter>(ExpressionType::COMPARE_LESSTHAN, const_value);
444: 				table_filters.PushFilter(column_index, move(lower_bound));
445: 				table_filters.PushFilter(column_index, move(upper_bound));
446: 				table_filters.PushFilter(column_index, make_unique<IsNotNullFilter>());
447: 			}
448: 			if (func.function.name == "~~" && func.children[0]->expression_class == ExpressionClass::BOUND_COLUMN_REF &&
449: 			    func.children[1]->type == ExpressionType::VALUE_CONSTANT) {
450: 				//! This is a like function.
451: 				auto &column_ref = (BoundColumnRefExpression &)*func.children[0].get();
452: 				auto &constant_value_expr = (BoundConstantExpression &)*func.children[1].get();
453: 				string like_string = constant_value_expr.value.str_value;
454: 				auto const_value = constant_value_expr.value.Copy();
455: 				if (like_string[0] == '%' || like_string[0] == '_') {
456: 					//! We have no prefix so nothing to pushdown
457: 					break;
458: 				}
459: 				string prefix;
460: 				bool equality = true;
461: 				for (char const &c : like_string) {
462: 					if (c == '%' || c == '_') {
463: 						equality = false;
464: 						break;
465: 					}
466: 					prefix += c;
467: 				}
468: 				const_value.str_value = prefix;
469: 				auto column_index = column_ids[column_ref.binding.column_index];
470: 				if (equality) {
471: 					//! Here the like can be transformed to an equality query
472: 					auto equal_filter = make_unique<ConstantFilter>(ExpressionType::COMPARE_EQUAL, const_value);
473: 					table_filters.PushFilter(column_index, move(equal_filter));
474: 					table_filters.PushFilter(column_index, make_unique<IsNotNullFilter>());
475: 				} else {
476: 					//! Here the like must be transformed to a BOUND COMPARISON geq le
477: 					auto lower_bound =
478: 					    make_unique<ConstantFilter>(ExpressionType::COMPARE_GREATERTHANOREQUALTO, const_value);
479: 					const_value.str_value[const_value.str_value.size() - 1]++;
480: 					auto upper_bound = make_unique<ConstantFilter>(ExpressionType::COMPARE_LESSTHAN, const_value);
481: 					table_filters.PushFilter(column_index, move(lower_bound));
482: 					table_filters.PushFilter(column_index, move(upper_bound));
483: 					table_filters.PushFilter(column_index, make_unique<IsNotNullFilter>());
484: 				}
485: 			}
486: 		} else if (remaining_filter->type == ExpressionType::COMPARE_IN) {
487: 			auto &func = (BoundOperatorExpression &)*remaining_filter;
488: 			vector<Value> in_values;
489: 			D_ASSERT(func.children.size() > 1);
490: 			if (func.children[0]->expression_class != ExpressionClass::BOUND_COLUMN_REF) {
491: 				continue;
492: 			}
493: 			auto &column_ref = (BoundColumnRefExpression &)*func.children[0].get();
494: 			auto column_index = column_ids[column_ref.binding.column_index];
495: 			if (column_index == COLUMN_IDENTIFIER_ROW_ID) {
496: 				break;
497: 			}
498: 			//! check if all children are const expr
499: 			bool children_constant = true;
500: 			for (size_t i {1}; i < func.children.size(); i++) {
501: 				if (func.children[i]->type != ExpressionType::VALUE_CONSTANT) {
502: 					children_constant = false;
503: 				}
504: 			}
505: 			if (!children_constant) {
506: 				continue;
507: 			}
508: 			auto &fst_const_value_expr = (BoundConstantExpression &)*func.children[1].get();
509: 			//! Check if values are consecutive, if yes transform them to >= <= (only for integers)
510: 			if (!fst_const_value_expr.value.type().IsIntegral()) {
511: 				continue;
512: 			}
513: 
514: 			for (idx_t i = 1; i < func.children.size(); i++) {
515: 				auto &const_value_expr = (BoundConstantExpression &)*func.children[i].get();
516: 				in_values.push_back(const_value_expr.value);
517: 			}
518: 			Value one(1);
519: 
520: 			sort(in_values.begin(), in_values.end());
521: 
522: 			bool is_consecutive = true;
523: 			for (idx_t in_val_idx = 1; in_val_idx < in_values.size(); in_val_idx++) {
524: 				if (in_values[in_val_idx] - in_values[in_val_idx - 1] > one || in_values[in_val_idx - 1].is_null) {
525: 					is_consecutive = false;
526: 					break;
527: 				}
528: 			}
529: 			if (!is_consecutive || in_values.empty()) {
530: 				continue;
531: 			}
532: 			auto lower_bound =
533: 			    make_unique<ConstantFilter>(ExpressionType::COMPARE_GREATERTHANOREQUALTO, in_values.front());
534: 			auto upper_bound = make_unique<ConstantFilter>(ExpressionType::COMPARE_LESSTHANOREQUALTO, in_values.back());
535: 			table_filters.PushFilter(column_index, move(lower_bound));
536: 			table_filters.PushFilter(column_index, move(upper_bound));
537: 			table_filters.PushFilter(column_index, make_unique<IsNotNullFilter>());
538: 
539: 			remaining_filters.erase(remaining_filters.begin() + rem_fil_idx);
540: 		}
541: 	}
542: 
543: 	return table_filters;
544: }
545: 
546: static bool IsGreaterThan(ExpressionType type) {
547: 	return type == ExpressionType::COMPARE_GREATERTHAN || type == ExpressionType::COMPARE_GREATERTHANOREQUALTO;
548: }
549: 
550: static bool IsLessThan(ExpressionType type) {
551: 	return type == ExpressionType::COMPARE_LESSTHAN || type == ExpressionType::COMPARE_LESSTHANOREQUALTO;
552: }
553: 
554: FilterResult FilterCombiner::AddBoundComparisonFilter(Expression *expr) {
555: 	auto &comparison = (BoundComparisonExpression &)*expr;
556: 	if (comparison.type != ExpressionType::COMPARE_LESSTHAN &&
557: 	    comparison.type != ExpressionType::COMPARE_LESSTHANOREQUALTO &&
558: 	    comparison.type != ExpressionType::COMPARE_GREATERTHAN &&
559: 	    comparison.type != ExpressionType::COMPARE_GREATERTHANOREQUALTO &&
560: 	    comparison.type != ExpressionType::COMPARE_EQUAL && comparison.type != ExpressionType::COMPARE_NOTEQUAL) {
561: 		// only support [>, >=, <, <=, ==] expressions
562: 		return FilterResult::UNSUPPORTED;
563: 	}
564: 	// check if one of the sides is a scalar value
565: 	bool left_is_scalar = comparison.left->IsFoldable();
566: 	bool right_is_scalar = comparison.right->IsFoldable();
567: 	if (left_is_scalar || right_is_scalar) {
568: 		// comparison with scalar
569: 		auto node = GetNode(left_is_scalar ? comparison.right.get() : comparison.left.get());
570: 		idx_t equivalence_set = GetEquivalenceSet(node);
571: 		auto scalar = left_is_scalar ? comparison.left.get() : comparison.right.get();
572: 		auto constant_value = ExpressionExecutor::EvaluateScalar(*scalar);
573: 
574: 		// create the ExpressionValueInformation
575: 		ExpressionValueInformation info;
576: 		info.comparison_type = left_is_scalar ? FlipComparisionExpression(comparison.type) : comparison.type;
577: 		info.constant = constant_value;
578: 
579: 		// get the current bucket of constant values
580: 		D_ASSERT(constant_values.find(equivalence_set) != constant_values.end());
581: 		auto &info_list = constant_values.find(equivalence_set)->second;
582: 		// check the existing constant comparisons to see if we can do any pruning
583: 		auto ret = AddConstantComparison(info_list, info);
584: 
585: 		auto non_scalar = left_is_scalar ? comparison.right.get() : comparison.left.get();
586: 		auto transitive_filter = FindTransitiveFilter(non_scalar);
587: 		if (transitive_filter != nullptr) {
588: 			// try to add transitive filters
589: 			if (AddTransitiveFilters((BoundComparisonExpression &)*transitive_filter) == FilterResult::UNSUPPORTED) {
590: 				// in case of unsuccessful re-add filter into remaining ones
591: 				remaining_filters.push_back(move(transitive_filter));
592: 			}
593: 		}
594: 		return ret;
595: 
596: 	} else {
597: 		// comparison between two non-scalars
598: 		// only handle comparisons for now
599: 		if (expr->type != ExpressionType::COMPARE_EQUAL) {
600: 			if (IsGreaterThan(expr->type) || IsLessThan(expr->type)) {
601: 				return AddTransitiveFilters(comparison);
602: 			}
603: 			return FilterResult::UNSUPPORTED;
604: 		}
605: 		// get the LHS and RHS nodes
606: 		auto left_node = GetNode(comparison.left.get());
607: 		auto right_node = GetNode(comparison.right.get());
608: 		if (BaseExpression::Equals(left_node, right_node)) {
609: 			return FilterResult::UNSUPPORTED;
610: 		}
611: 		// get the equivalence sets of the LHS and RHS
612: 		auto left_equivalence_set = GetEquivalenceSet(left_node);
613: 		auto right_equivalence_set = GetEquivalenceSet(right_node);
614: 		if (left_equivalence_set == right_equivalence_set) {
615: 			// this equality filter already exists, prune it
616: 			return FilterResult::SUCCESS;
617: 		}
618: 		// add the right bucket into the left bucket
619: 		D_ASSERT(equivalence_map.find(left_equivalence_set) != equivalence_map.end());
620: 		D_ASSERT(equivalence_map.find(right_equivalence_set) != equivalence_map.end());
621: 
622: 		auto &left_bucket = equivalence_map.find(left_equivalence_set)->second;
623: 		auto &right_bucket = equivalence_map.find(right_equivalence_set)->second;
624: 		for (auto &i : right_bucket) {
625: 			// rewrite the equivalence set mapping for this node
626: 			equivalence_set_map[i] = left_equivalence_set;
627: 			// add the node to the left bucket
628: 			left_bucket.push_back(i);
629: 		}
630: 		// now add all constant values from the right bucket to the left bucket
631: 		D_ASSERT(constant_values.find(left_equivalence_set) != constant_values.end());
632: 		D_ASSERT(constant_values.find(right_equivalence_set) != constant_values.end());
633: 		auto &left_constant_bucket = constant_values.find(left_equivalence_set)->second;
634: 		auto &right_constant_bucket = constant_values.find(right_equivalence_set)->second;
635: 		for (auto &i : right_constant_bucket) {
636: 			if (AddConstantComparison(left_constant_bucket, i) == FilterResult::UNSATISFIABLE) {
637: 				return FilterResult::UNSATISFIABLE;
638: 			}
639: 		}
640: 	}
641: 	return FilterResult::SUCCESS;
642: }
643: 
644: FilterResult FilterCombiner::AddFilter(Expression *expr) {
645: 	if (expr->HasParameter()) {
646: 		return FilterResult::UNSUPPORTED;
647: 	}
648: 	if (expr->IsFoldable()) {
649: 		// scalar condition, evaluate it
650: 		auto result = ExpressionExecutor::EvaluateScalar(*expr).CastAs(LogicalType::BOOLEAN);
651: 		// check if the filter passes
652: 		if (result.is_null || !result.value_.boolean) {
653: 			// the filter does not pass the scalar test, create an empty result
654: 			return FilterResult::UNSATISFIABLE;
655: 		} else {
656: 			// the filter passes the scalar test, just remove the condition
657: 			return FilterResult::SUCCESS;
658: 		}
659: 	}
660: 	D_ASSERT(!expr->IsFoldable());
661: 	if (expr->GetExpressionClass() == ExpressionClass::BOUND_BETWEEN) {
662: 		auto &comparison = (BoundBetweenExpression &)*expr;
663: 		//! check if one of the sides is a scalar value
664: 		bool left_is_scalar = comparison.lower->IsFoldable();
665: 		bool right_is_scalar = comparison.upper->IsFoldable();
666: 		if (left_is_scalar || right_is_scalar) {
667: 			//! comparison with scalar
668: 			auto node = GetNode(comparison.input.get());
669: 			idx_t equivalence_set = GetEquivalenceSet(node);
670: 			auto scalar = comparison.lower.get();
671: 			auto constant_value = ExpressionExecutor::EvaluateScalar(*scalar);
672: 
673: 			// create the ExpressionValueInformation
674: 			ExpressionValueInformation info;
675: 			if (comparison.lower_inclusive) {
676: 				info.comparison_type = ExpressionType::COMPARE_GREATERTHANOREQUALTO;
677: 			} else {
678: 				info.comparison_type = ExpressionType::COMPARE_GREATERTHAN;
679: 			}
680: 			info.constant = constant_value;
681: 
682: 			// get the current bucket of constant values
683: 			D_ASSERT(constant_values.find(equivalence_set) != constant_values.end());
684: 			auto &info_list = constant_values.find(equivalence_set)->second;
685: 			// check the existing constant comparisons to see if we can do any pruning
686: 			AddConstantComparison(info_list, info);
687: 			scalar = comparison.upper.get();
688: 			constant_value = ExpressionExecutor::EvaluateScalar(*scalar);
689: 
690: 			// create the ExpressionValueInformation
691: 			if (comparison.upper_inclusive) {
692: 				info.comparison_type = ExpressionType::COMPARE_LESSTHANOREQUALTO;
693: 			} else {
694: 				info.comparison_type = ExpressionType::COMPARE_LESSTHAN;
695: 			}
696: 			info.constant = constant_value;
697: 
698: 			// get the current bucket of constant values
699: 			D_ASSERT(constant_values.find(equivalence_set) != constant_values.end());
700: 			// check the existing constant comparisons to see if we can do any pruning
701: 			return AddConstantComparison(constant_values.find(equivalence_set)->second, info);
702: 		}
703: 	} else if (expr->GetExpressionClass() == ExpressionClass::BOUND_COMPARISON) {
704: 		return AddBoundComparisonFilter(expr);
705: 	}
706: 	// only comparisons supported for now
707: 	return FilterResult::UNSUPPORTED;
708: }
709: 
710: /*
711:  * Create and add new transitive filters from a two non-scalar filter such as j > i, j >= i, j < i, and j <= i
712:  * It's missing to create another method to add transitive filters from scalar filters, e.g, i > 10
713:  */
714: FilterResult FilterCombiner::AddTransitiveFilters(BoundComparisonExpression &comparison) {
715: 	D_ASSERT(IsGreaterThan(comparison.type) || IsLessThan(comparison.type));
716: 	// get the LHS and RHS nodes
717: 	Expression *left_node = GetNode(comparison.left.get());
718: 	Expression *right_node = GetNode(comparison.right.get());
719: 	// In case with filters like CAST(i) = j and i = 5 we replace the COLUMN_REF i with the constant 5
720: 	if (right_node->type == ExpressionType::OPERATOR_CAST) {
721: 		auto &bound_cast_expr = (BoundCastExpression &)*right_node;
722: 		if (bound_cast_expr.child->type == ExpressionType::BOUND_COLUMN_REF) {
723: 			auto &col_ref = (BoundColumnRefExpression &)*bound_cast_expr.child;
724: 			for (auto &stored_exp : stored_expressions) {
725: 				if (stored_exp.first->type == ExpressionType::BOUND_COLUMN_REF) {
726: 					auto &st_col_ref = (BoundColumnRefExpression &)*stored_exp.second;
727: 					if (st_col_ref.binding == col_ref.binding) {
728: 						bound_cast_expr.child = stored_exp.second->Copy();
729: 						right_node = GetNode(bound_cast_expr.child.get());
730: 						break;
731: 					}
732: 				}
733: 			}
734: 		}
735: 	}
736: 
737: 	if (BaseExpression::Equals(left_node, right_node)) {
738: 		return FilterResult::UNSUPPORTED;
739: 	}
740: 	// get the equivalence sets of the LHS and RHS
741: 	idx_t left_equivalence_set = GetEquivalenceSet(left_node);
742: 	idx_t right_equivalence_set = GetEquivalenceSet(right_node);
743: 	if (left_equivalence_set == right_equivalence_set) {
744: 		// this equality filter already exists, prune it
745: 		return FilterResult::SUCCESS;
746: 	}
747: 
748: 	vector<ExpressionValueInformation> &left_constants = constant_values.find(left_equivalence_set)->second;
749: 	vector<ExpressionValueInformation> &right_constants = constant_values.find(right_equivalence_set)->second;
750: 	bool is_successful = false;
751: 	bool is_inserted = false;
752: 	// read every constant filters already inserted for the right scalar variable
753: 	// and see if we can create new transitive filters, e.g., there is already a filter i > 10,
754: 	// suppose that we have now the j >= i, then we can infer a new filter j > 10
755: 	for (const auto &right_constant : right_constants) {
756: 		ExpressionValueInformation info;
757: 		info.constant = right_constant.constant;
758: 		// there is already an equality filter, e.g., i = 10
759: 		if (right_constant.comparison_type == ExpressionType::COMPARE_EQUAL) {
760: 			// create filter j [>, >=, <, <=] 10
761: 			// suppose the new comparison is j >= i and we have already a filter i = 10,
762: 			// then we create a new filter j >= 10
763: 			// and the filter j >= i can be pruned by not adding it into the remaining filters
764: 			info.comparison_type = comparison.type;
765: 		} else if ((comparison.type == ExpressionType::COMPARE_GREATERTHANOREQUALTO &&
766: 		            IsGreaterThan(right_constant.comparison_type)) ||
767: 		           (comparison.type == ExpressionType::COMPARE_LESSTHANOREQUALTO &&
768: 		            IsLessThan(right_constant.comparison_type))) {
769: 			// filters (j >= i AND i [>, >=] 10) OR (j <= i AND i [<, <=] 10)
770: 			// create filter j [>, >=] 10 and add the filter j [>=, <=] i into the remaining filters
771: 			info.comparison_type = right_constant.comparison_type; // create filter j [>, >=, <, <=] 10
772: 			if (!is_inserted) {
773: 				// Add the filter j >= i in the remaing filters
774: 				auto filter = make_unique<BoundComparisonExpression>(comparison.type, comparison.left->Copy(),
775: 				                                                     comparison.right->Copy());
776: 				remaining_filters.push_back(move(filter));
777: 				is_inserted = true;
778: 			}
779: 		} else if ((comparison.type == ExpressionType::COMPARE_GREATERTHAN &&
780: 		            IsGreaterThan(right_constant.comparison_type)) ||
781: 		           (comparison.type == ExpressionType::COMPARE_LESSTHAN &&
782: 		            IsLessThan(right_constant.comparison_type))) {
783: 			// filters (j > i AND i [>, >=] 10) OR j < i AND i [<, <=] 10
784: 			// create filter j [>, <] 10 and add the filter j [>, <] i into the remaining filters
785: 			// the comparisons j > i and j < i are more restrictive
786: 			info.comparison_type = comparison.type;
787: 			if (!is_inserted) {
788: 				// Add the filter j [>, <] i
789: 				auto filter = make_unique<BoundComparisonExpression>(comparison.type, comparison.left->Copy(),
790: 				                                                     comparison.right->Copy());
791: 				remaining_filters.push_back(move(filter));
792: 				is_inserted = true;
793: 			}
794: 		} else {
795: 			// we cannot add a new filter
796: 			continue;
797: 		}
798: 		// Add the new filer into the left set
799: 		if (AddConstantComparison(left_constants, info) == FilterResult::UNSATISFIABLE) {
800: 			return FilterResult::UNSATISFIABLE;
801: 		}
802: 		is_successful = true;
803: 	}
804: 	if (is_successful) {
805: 		// now check for remaining trasitive filters from the left column
806: 		auto transitive_filter = FindTransitiveFilter(comparison.left.get());
807: 		if (transitive_filter != nullptr) {
808: 			// try to add transitive filters
809: 			if (AddTransitiveFilters((BoundComparisonExpression &)*transitive_filter) == FilterResult::UNSUPPORTED) {
810: 				// in case of unsuccessful re-add filter into remaining ones
811: 				remaining_filters.push_back(move(transitive_filter));
812: 			}
813: 		}
814: 		return FilterResult::SUCCESS;
815: 	}
816: 
817: 	return FilterResult::UNSUPPORTED;
818: }
819: 
820: /*
821:  * Find a transitive filter already inserted into the remaining filters
822:  * Check for a match between the right column of bound comparisons and the expression,
823:  * then removes the bound comparison from the remaining filters and returns it
824:  */
825: unique_ptr<Expression> FilterCombiner::FindTransitiveFilter(Expression *expr) {
826: 	// We only check for bound column ref
827: 	if (expr->type == ExpressionType::BOUND_COLUMN_REF) {
828: 		for (idx_t i = 0; i < remaining_filters.size(); i++) {
829: 			if (remaining_filters[i]->GetExpressionClass() == ExpressionClass::BOUND_COMPARISON) {
830: 				auto comparison = (BoundComparisonExpression *)remaining_filters[i].get();
831: 				if (expr->Equals(comparison->right.get()) && comparison->type != ExpressionType::COMPARE_NOTEQUAL) {
832: 					auto filter = move(remaining_filters[i]);
833: 					remaining_filters.erase(remaining_filters.begin() + i);
834: 					return filter;
835: 				}
836: 			}
837: 		}
838: 	}
839: 	return nullptr;
840: }
841: 
842: ValueComparisonResult InvertValueComparisonResult(ValueComparisonResult result) {
843: 	if (result == ValueComparisonResult::PRUNE_RIGHT) {
844: 		return ValueComparisonResult::PRUNE_LEFT;
845: 	}
846: 	if (result == ValueComparisonResult::PRUNE_LEFT) {
847: 		return ValueComparisonResult::PRUNE_RIGHT;
848: 	}
849: 	return result;
850: }
851: 
852: ValueComparisonResult CompareValueInformation(ExpressionValueInformation &left, ExpressionValueInformation &right) {
853: 	if (left.comparison_type == ExpressionType::COMPARE_EQUAL) {
854: 		// left is COMPARE_EQUAL, we can either
855: 		// (1) prune the right side or
856: 		// (2) return UNSATISFIABLE
857: 		bool prune_right_side = false;
858: 		switch (right.comparison_type) {
859: 		case ExpressionType::COMPARE_LESSTHAN:
860: 			prune_right_side = left.constant < right.constant;
861: 			break;
862: 		case ExpressionType::COMPARE_LESSTHANOREQUALTO:
863: 			prune_right_side = left.constant <= right.constant;
864: 			break;
865: 		case ExpressionType::COMPARE_GREATERTHAN:
866: 			prune_right_side = left.constant > right.constant;
867: 			break;
868: 		case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
869: 			prune_right_side = left.constant >= right.constant;
870: 			break;
871: 		case ExpressionType::COMPARE_NOTEQUAL:
872: 			prune_right_side = left.constant != right.constant;
873: 			break;
874: 		default:
875: 			D_ASSERT(right.comparison_type == ExpressionType::COMPARE_EQUAL);
876: 			prune_right_side = left.constant == right.constant;
877: 			break;
878: 		}
879: 		if (prune_right_side) {
880: 			return ValueComparisonResult::PRUNE_RIGHT;
881: 		} else {
882: 			return ValueComparisonResult::UNSATISFIABLE_CONDITION;
883: 		}
884: 	} else if (right.comparison_type == ExpressionType::COMPARE_EQUAL) {
885: 		// right is COMPARE_EQUAL
886: 		return InvertValueComparisonResult(CompareValueInformation(right, left));
887: 	} else if (left.comparison_type == ExpressionType::COMPARE_NOTEQUAL) {
888: 		// left is COMPARE_NOTEQUAL, we can either
889: 		// (1) prune the left side or
890: 		// (2) not prune anything
891: 		bool prune_left_side = false;
892: 		switch (right.comparison_type) {
893: 		case ExpressionType::COMPARE_LESSTHAN:
894: 			prune_left_side = left.constant >= right.constant;
895: 			break;
896: 		case ExpressionType::COMPARE_LESSTHANOREQUALTO:
897: 			prune_left_side = left.constant > right.constant;
898: 			break;
899: 		case ExpressionType::COMPARE_GREATERTHAN:
900: 			prune_left_side = left.constant <= right.constant;
901: 			break;
902: 		case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
903: 			prune_left_side = left.constant < right.constant;
904: 			break;
905: 		default:
906: 			D_ASSERT(right.comparison_type == ExpressionType::COMPARE_NOTEQUAL);
907: 			prune_left_side = left.constant == right.constant;
908: 			break;
909: 		}
910: 		if (prune_left_side) {
911: 			return ValueComparisonResult::PRUNE_LEFT;
912: 		} else {
913: 			return ValueComparisonResult::PRUNE_NOTHING;
914: 		}
915: 	} else if (right.comparison_type == ExpressionType::COMPARE_NOTEQUAL) {
916: 		return InvertValueComparisonResult(CompareValueInformation(right, left));
917: 	} else if (IsGreaterThan(left.comparison_type) && IsGreaterThan(right.comparison_type)) {
918: 		// both comparisons are [>], we can either
919: 		// (1) prune the left side or
920: 		// (2) prune the right side
921: 		if (left.constant > right.constant) {
922: 			// left constant is more selective, prune right
923: 			return ValueComparisonResult::PRUNE_RIGHT;
924: 		} else if (left.constant < right.constant) {
925: 			// right constant is more selective, prune left
926: 			return ValueComparisonResult::PRUNE_LEFT;
927: 		} else {
928: 			// constants are equivalent
929: 			// however we can still have the scenario where one is [>=] and the other is [>]
930: 			// we want to prune the [>=] because [>] is more selective
931: 			// if left is [>=] we prune the left, else we prune the right
932: 			if (left.comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO) {
933: 				return ValueComparisonResult::PRUNE_LEFT;
934: 			} else {
935: 				return ValueComparisonResult::PRUNE_RIGHT;
936: 			}
937: 		}
938: 	} else if (IsLessThan(left.comparison_type) && IsLessThan(right.comparison_type)) {
939: 		// both comparisons are [<], we can either
940: 		// (1) prune the left side or
941: 		// (2) prune the right side
942: 		if (left.constant < right.constant) {
943: 			// left constant is more selective, prune right
944: 			return ValueComparisonResult::PRUNE_RIGHT;
945: 		} else if (left.constant > right.constant) {
946: 			// right constant is more selective, prune left
947: 			return ValueComparisonResult::PRUNE_LEFT;
948: 		} else {
949: 			// constants are equivalent
950: 			// however we can still have the scenario where one is [<=] and the other is [<]
951: 			// we want to prune the [<=] because [<] is more selective
952: 			// if left is [<=] we prune the left, else we prune the right
953: 			if (left.comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO) {
954: 				return ValueComparisonResult::PRUNE_LEFT;
955: 			} else {
956: 				return ValueComparisonResult::PRUNE_RIGHT;
957: 			}
958: 		}
959: 	} else if (IsLessThan(left.comparison_type)) {
960: 		D_ASSERT(IsGreaterThan(right.comparison_type));
961: 		// left is [<] and right is [>], in this case we can either
962: 		// (1) prune nothing or
963: 		// (2) return UNSATISFIABLE
964: 		// the SMALLER THAN constant has to be greater than the BIGGER THAN constant
965: 		if (left.constant >= right.constant) {
966: 			return ValueComparisonResult::PRUNE_NOTHING;
967: 		} else {
968: 			return ValueComparisonResult::UNSATISFIABLE_CONDITION;
969: 		}
970: 	} else {
971: 		// left is [>] and right is [<] or [!=]
972: 		D_ASSERT(IsLessThan(right.comparison_type) && IsGreaterThan(left.comparison_type));
973: 		return InvertValueComparisonResult(CompareValueInformation(right, left));
974: 	}
975: }
976: 
977: } // namespace duckdb
[end of src/optimizer/filter_combiner.cpp]
[start of src/optimizer/rule/move_constants.cpp]
1: #include "duckdb/optimizer/rule/move_constants.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/value_operations/value_operations.hpp"
5: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
6: #include "duckdb/planner/expression/bound_constant_expression.hpp"
7: #include "duckdb/planner/expression/bound_function_expression.hpp"
8: 
9: namespace duckdb {
10: 
11: MoveConstantsRule::MoveConstantsRule(ExpressionRewriter &rewriter) : Rule(rewriter) {
12: 	auto op = make_unique<ComparisonExpressionMatcher>();
13: 	op->matchers.push_back(make_unique<ConstantExpressionMatcher>());
14: 	op->policy = SetMatcher::Policy::UNORDERED;
15: 
16: 	auto arithmetic = make_unique<FunctionExpressionMatcher>();
17: 	// we handle multiplication, addition and subtraction because those are "easy"
18: 	// integer division makes the division case difficult
19: 	// e.g. [x / 2 = 3] means [x = 6 OR x = 7] because of truncation -> no clean rewrite rules
20: 	arithmetic->function = make_unique<ManyFunctionMatcher>(unordered_set<string> {"+", "-", "*"});
21: 	// we match only on integral numeric types
22: 	arithmetic->type = make_unique<IntegerTypeMatcher>();
23: 	arithmetic->matchers.push_back(make_unique<ConstantExpressionMatcher>());
24: 	arithmetic->matchers.push_back(make_unique<ExpressionMatcher>());
25: 	arithmetic->policy = SetMatcher::Policy::SOME;
26: 	op->matchers.push_back(move(arithmetic));
27: 	root = move(op);
28: }
29: 
30: unique_ptr<Expression> MoveConstantsRule::Apply(LogicalOperator &op, vector<Expression *> &bindings,
31:                                                 bool &changes_made) {
32: 	auto comparison = (BoundComparisonExpression *)bindings[0];
33: 	auto outer_constant = (BoundConstantExpression *)bindings[1];
34: 	auto arithmetic = (BoundFunctionExpression *)bindings[2];
35: 	auto inner_constant = (BoundConstantExpression *)bindings[3];
36: 	if (!arithmetic->return_type.IsNumeric()) {
37: 		return nullptr;
38: 	}
39: 
40: 	int arithmetic_child_index = arithmetic->children[0].get() == inner_constant ? 1 : 0;
41: 	auto &op_type = arithmetic->function.name;
42: 	if (op_type == "+") {
43: 		// [x + 1 COMP 10] OR [1 + x COMP 10]
44: 		// order does not matter in addition:
45: 		// simply change right side to 10-1 (outer_constant - inner_constant)
46: 		outer_constant->value = outer_constant->value - inner_constant->value;
47: 	} else if (op_type == "-") {
48: 		// [x - 1 COMP 10] O R [1 - x COMP 10]
49: 		// order matters in subtraction:
50: 		if (arithmetic_child_index == 0) {
51: 			// [x - 1 COMP 10]
52: 			// change right side to 10+1 (outer_constant + inner_constant)
53: 			outer_constant->value = outer_constant->value + inner_constant->value;
54: 		} else {
55: 			// [1 - x COMP 10]
56: 			// change right side to 1-10=-9
57: 			outer_constant->value = inner_constant->value - outer_constant->value;
58: 			// in this case, we should also flip the comparison
59: 			// e.g. if we have [4 - x < 2] then we should have [x > 2]
60: 			comparison->type = FlipComparisionExpression(comparison->type);
61: 		}
62: 	} else {
63: 		D_ASSERT(op_type == "*");
64: 		// [x * 2 COMP 10] OR [2 * x COMP 10]
65: 		// order does not matter in multiplication:
66: 		// change right side to 10/2 (outer_constant / inner_constant)
67: 		// but ONLY if outer_constant is cleanly divisible by the inner_constant
68: 		if (inner_constant->value == 0) {
69: 			// x * 0, the result is either 0 or NULL
70: 			// thus the final result will be either [TRUE, FALSE] or [NULL], depending
71: 			// on if 0 matches the comparison criteria with the RHS
72: 			// for now we don't fold, but we can fold to "ConstantOrNull"
73: 			return nullptr;
74: 		}
75: 		if (ValueOperations::Modulo(outer_constant->value, inner_constant->value) != 0) {
76: 			// not cleanly divisible, the result will be either FALSE or NULL
77: 			// for now, we don't do anything
78: 			return nullptr;
79: 		}
80: 		if (inner_constant->value < 0) {
81: 			// multiply by negative value, need to flip expression
82: 			comparison->type = FlipComparisionExpression(comparison->type);
83: 		}
84: 		// else divide the RHS by the LHS
85: 		outer_constant->value = outer_constant->value / inner_constant->value;
86: 	}
87: 	// replace left side with x
88: 	// first extract x from the arithmetic expression
89: 	auto arithmetic_child = move(arithmetic->children[arithmetic_child_index]);
90: 	// then place in the comparison
91: 	if (comparison->left.get() == outer_constant) {
92: 		comparison->right = move(arithmetic_child);
93: 	} else {
94: 		comparison->left = move(arithmetic_child);
95: 	}
96: 	changes_made = true;
97: 	return nullptr;
98: }
99: 
100: } // namespace duckdb
[end of src/optimizer/rule/move_constants.cpp]
[start of src/optimizer/statistics/expression/propagate_constant.cpp]
1: #include "duckdb/optimizer/statistics_propagator.hpp"
2: #include "duckdb/planner/expression/bound_constant_expression.hpp"
3: #include "duckdb/storage/statistics/numeric_statistics.hpp"
4: #include "duckdb/storage/statistics/string_statistics.hpp"
5: #include "duckdb/storage/statistics/struct_statistics.hpp"
6: #include "duckdb/storage/statistics/list_statistics.hpp"
7: 
8: namespace duckdb {
9: 
10: unique_ptr<BaseStatistics> StatisticsPropagator::StatisticsFromValue(const Value &input) {
11: 	switch (input.type().InternalType()) {
12: 	case PhysicalType::BOOL:
13: 	case PhysicalType::INT8:
14: 	case PhysicalType::INT16:
15: 	case PhysicalType::INT32:
16: 	case PhysicalType::INT64:
17: 	case PhysicalType::INT128:
18: 	case PhysicalType::FLOAT:
19: 	case PhysicalType::DOUBLE: {
20: 		auto result = make_unique<NumericStatistics>(input.type(), input, input);
21: 		result->validity_stats = make_unique<ValidityStatistics>(input.is_null, !input.is_null);
22: 		return move(result);
23: 	}
24: 	case PhysicalType::VARCHAR: {
25: 		auto result = make_unique<StringStatistics>(input.type());
26: 		result->validity_stats = make_unique<ValidityStatistics>(input.is_null, !input.is_null);
27: 		string_t str(input.str_value.c_str(), input.str_value.size());
28: 		result->Update(str);
29: 		return move(result);
30: 	}
31: 	case PhysicalType::STRUCT: {
32: 		auto result = make_unique<StructStatistics>(input.type());
33: 		result->validity_stats = make_unique<ValidityStatistics>(input.is_null, !input.is_null);
34: 		if (input.is_null) {
35: 			for (auto &child_stat : result->child_stats) {
36: 				child_stat.reset();
37: 			}
38: 		} else {
39: 			D_ASSERT(result->child_stats.size() == input.struct_value.size());
40: 			for (idx_t i = 0; i < result->child_stats.size(); i++) {
41: 				result->child_stats[i] = StatisticsFromValue(input.struct_value[i]);
42: 			}
43: 		}
44: 		return move(result);
45: 	}
46: 	case PhysicalType::LIST: {
47: 		auto result = make_unique<ListStatistics>(input.type());
48: 		result->validity_stats = make_unique<ValidityStatistics>(input.is_null, !input.is_null);
49: 		if (input.is_null) {
50: 			result->child_stats.reset();
51: 		} else {
52: 			for (auto &child_element : input.list_value) {
53: 				auto child_element_stats = StatisticsFromValue(child_element);
54: 				if (child_element_stats) {
55: 					result->child_stats->Merge(*child_element_stats);
56: 				} else {
57: 					result->child_stats.reset();
58: 				}
59: 			}
60: 		}
61: 		return move(result);
62: 	}
63: 	default:
64: 		return nullptr;
65: 	}
66: }
67: 
68: unique_ptr<BaseStatistics> StatisticsPropagator::PropagateExpression(BoundConstantExpression &constant,
69:                                                                      unique_ptr<Expression> *expr_ptr) {
70: 	return StatisticsFromValue(constant.value);
71: }
72: 
73: } // namespace duckdb
[end of src/optimizer/statistics/expression/propagate_constant.cpp]
[start of src/parser/expression/constant_expression.cpp]
1: #include "duckdb/parser/expression/constant_expression.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/types/hash.hpp"
5: #include "duckdb/common/value_operations/value_operations.hpp"
6: 
7: namespace duckdb {
8: 
9: ConstantExpression::ConstantExpression(Value val)
10:     : ParsedExpression(ExpressionType::VALUE_CONSTANT, ExpressionClass::CONSTANT), value(move(val)) {
11: }
12: 
13: string ConstantExpression::ToString() const {
14: 	return value.ToString();
15: }
16: 
17: bool ConstantExpression::Equals(const ConstantExpression *a, const ConstantExpression *b) {
18: 	return a->value == b->value;
19: }
20: 
21: hash_t ConstantExpression::Hash() const {
22: 	return ParsedExpression::Hash();
23: }
24: 
25: unique_ptr<ParsedExpression> ConstantExpression::Copy() const {
26: 	auto copy = make_unique<ConstantExpression>(value);
27: 	copy->CopyProperties(*this);
28: 	return move(copy);
29: }
30: 
31: void ConstantExpression::Serialize(Serializer &serializer) {
32: 	ParsedExpression::Serialize(serializer);
33: 	value.Serialize(serializer);
34: }
35: 
36: unique_ptr<ParsedExpression> ConstantExpression::Deserialize(ExpressionType type, Deserializer &source) {
37: 	Value value = Value::Deserialize(source);
38: 	return make_unique<ConstantExpression>(move(value));
39: }
40: 
41: } // namespace duckdb
[end of src/parser/expression/constant_expression.cpp]
[start of src/planner/expression/bound_constant_expression.cpp]
1: #include "duckdb/planner/expression/bound_constant_expression.hpp"
2: 
3: #include "duckdb/common/types/hash.hpp"
4: #include "duckdb/common/value_operations/value_operations.hpp"
5: 
6: namespace duckdb {
7: 
8: BoundConstantExpression::BoundConstantExpression(Value value_p)
9:     : Expression(ExpressionType::VALUE_CONSTANT, ExpressionClass::BOUND_CONSTANT, value_p.type()),
10:       value(move(value_p)) {
11: }
12: 
13: string BoundConstantExpression::ToString() const {
14: 	return value.ToString();
15: }
16: 
17: bool BoundConstantExpression::Equals(const BaseExpression *other_p) const {
18: 	if (!Expression::Equals(other_p)) {
19: 		return false;
20: 	}
21: 	auto other = (BoundConstantExpression *)other_p;
22: 	return value == other->value;
23: }
24: 
25: hash_t BoundConstantExpression::Hash() const {
26: 	hash_t result = Expression::Hash();
27: 	return CombineHash(ValueOperations::Hash(value), result);
28: }
29: 
30: unique_ptr<Expression> BoundConstantExpression::Copy() {
31: 	auto copy = make_unique<BoundConstantExpression>(value);
32: 	copy->CopyProperties(*this);
33: 	return move(copy);
34: }
35: 
36: } // namespace duckdb
[end of src/planner/expression/bound_constant_expression.cpp]
[start of src/storage/statistics/numeric_statistics.cpp]
1: #include "duckdb/storage/statistics/numeric_statistics.hpp"
2: #include "duckdb/common/types/vector.hpp"
3: #include "duckdb/common/operator/comparison_operators.hpp"
4: 
5: namespace duckdb {
6: 
7: template <>
8: void NumericStatistics::Update<int8_t>(SegmentStatistics &stats, int8_t new_value) {
9: 	auto &nstats = (NumericStatistics &)*stats.statistics;
10: 	UpdateValue<int8_t>(new_value, nstats.min.value_.tinyint, nstats.max.value_.tinyint);
11: }
12: 
13: template <>
14: void NumericStatistics::Update<int16_t>(SegmentStatistics &stats, int16_t new_value) {
15: 	auto &nstats = (NumericStatistics &)*stats.statistics;
16: 	UpdateValue<int16_t>(new_value, nstats.min.value_.smallint, nstats.max.value_.smallint);
17: }
18: 
19: template <>
20: void NumericStatistics::Update<int32_t>(SegmentStatistics &stats, int32_t new_value) {
21: 	auto &nstats = (NumericStatistics &)*stats.statistics;
22: 	UpdateValue<int32_t>(new_value, nstats.min.value_.integer, nstats.max.value_.integer);
23: }
24: 
25: template <>
26: void NumericStatistics::Update<int64_t>(SegmentStatistics &stats, int64_t new_value) {
27: 	auto &nstats = (NumericStatistics &)*stats.statistics;
28: 	UpdateValue<int64_t>(new_value, nstats.min.value_.bigint, nstats.max.value_.bigint);
29: }
30: 
31: template <>
32: void NumericStatistics::Update<uint8_t>(SegmentStatistics &stats, uint8_t new_value) {
33: 	auto &nstats = (NumericStatistics &)*stats.statistics;
34: 	UpdateValue<uint8_t>(new_value, nstats.min.value_.utinyint, nstats.max.value_.utinyint);
35: }
36: 
37: template <>
38: void NumericStatistics::Update<uint16_t>(SegmentStatistics &stats, uint16_t new_value) {
39: 	auto &nstats = (NumericStatistics &)*stats.statistics;
40: 	UpdateValue<uint16_t>(new_value, nstats.min.value_.usmallint, nstats.max.value_.usmallint);
41: }
42: 
43: template <>
44: void NumericStatistics::Update<uint32_t>(SegmentStatistics &stats, uint32_t new_value) {
45: 	auto &nstats = (NumericStatistics &)*stats.statistics;
46: 	UpdateValue<uint32_t>(new_value, nstats.min.value_.uinteger, nstats.max.value_.uinteger);
47: }
48: 
49: template <>
50: void NumericStatistics::Update<uint64_t>(SegmentStatistics &stats, uint64_t new_value) {
51: 	auto &nstats = (NumericStatistics &)*stats.statistics;
52: 	UpdateValue<uint64_t>(new_value, nstats.min.value_.ubigint, nstats.max.value_.ubigint);
53: }
54: 
55: template <>
56: void NumericStatistics::Update<hugeint_t>(SegmentStatistics &stats, hugeint_t new_value) {
57: 	auto &nstats = (NumericStatistics &)*stats.statistics;
58: 	UpdateValue<hugeint_t>(new_value, nstats.min.value_.hugeint, nstats.max.value_.hugeint);
59: }
60: 
61: template <>
62: void NumericStatistics::Update<float>(SegmentStatistics &stats, float new_value) {
63: 	auto &nstats = (NumericStatistics &)*stats.statistics;
64: 	UpdateValue<float>(new_value, nstats.min.value_.float_, nstats.max.value_.float_);
65: }
66: 
67: template <>
68: void NumericStatistics::Update<double>(SegmentStatistics &stats, double new_value) {
69: 	auto &nstats = (NumericStatistics &)*stats.statistics;
70: 	UpdateValue<double>(new_value, nstats.min.value_.double_, nstats.max.value_.double_);
71: }
72: 
73: template <>
74: void NumericStatistics::Update<interval_t>(SegmentStatistics &stats, interval_t new_value) {
75: }
76: 
77: template <>
78: void NumericStatistics::Update<list_entry_t>(SegmentStatistics &stats, list_entry_t new_value) {
79: }
80: 
81: NumericStatistics::NumericStatistics(LogicalType type_p) : BaseStatistics(move(type_p)) {
82: 	min = Value::MaximumValue(type);
83: 	max = Value::MinimumValue(type);
84: 	validity_stats = make_unique<ValidityStatistics>(false);
85: }
86: 
87: NumericStatistics::NumericStatistics(LogicalType type_p, Value min_p, Value max_p)
88:     : BaseStatistics(move(type_p)), min(move(min_p)), max(move(max_p)) {
89: }
90: 
91: void NumericStatistics::Merge(const BaseStatistics &other_p) {
92: 	BaseStatistics::Merge(other_p);
93: 	auto &other = (const NumericStatistics &)other_p;
94: 	if (other.min < min) {
95: 		min = other.min;
96: 	}
97: 	if (other.max > max) {
98: 		max = other.max;
99: 	}
100: }
101: 
102: FilterPropagateResult NumericStatistics::CheckZonemap(ExpressionType comparison_type, const Value &constant) {
103: 	switch (comparison_type) {
104: 	case ExpressionType::COMPARE_EQUAL:
105: 		if (constant == min && constant == max) {
106: 			return FilterPropagateResult::FILTER_ALWAYS_TRUE;
107: 		} else if (constant >= min && constant <= max) {
108: 			return FilterPropagateResult::NO_PRUNING_POSSIBLE;
109: 		} else {
110: 			return FilterPropagateResult::FILTER_ALWAYS_FALSE;
111: 		}
112: 	case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
113: 		// X >= C
114: 		// this can be true only if max(X) >= C
115: 		// if min(X) >= C, then this is always true
116: 		if (min >= constant) {
117: 			return FilterPropagateResult::FILTER_ALWAYS_TRUE;
118: 		} else if (max >= constant) {
119: 			return FilterPropagateResult::NO_PRUNING_POSSIBLE;
120: 		} else {
121: 			return FilterPropagateResult::FILTER_ALWAYS_FALSE;
122: 		}
123: 	case ExpressionType::COMPARE_GREATERTHAN:
124: 		// X > C
125: 		// this can be true only if max(X) > C
126: 		// if min(X) > C, then this is always true
127: 		if (min > constant) {
128: 			return FilterPropagateResult::FILTER_ALWAYS_TRUE;
129: 		} else if (max > constant) {
130: 			return FilterPropagateResult::NO_PRUNING_POSSIBLE;
131: 		} else {
132: 			return FilterPropagateResult::FILTER_ALWAYS_FALSE;
133: 		}
134: 	case ExpressionType::COMPARE_LESSTHANOREQUALTO:
135: 		// X <= C
136: 		// this can be true only if min(X) <= C
137: 		// if max(X) <= C, then this is always true
138: 		if (max <= constant) {
139: 			return FilterPropagateResult::FILTER_ALWAYS_TRUE;
140: 		} else if (min <= constant) {
141: 			return FilterPropagateResult::NO_PRUNING_POSSIBLE;
142: 		} else {
143: 			return FilterPropagateResult::FILTER_ALWAYS_FALSE;
144: 		}
145: 	case ExpressionType::COMPARE_LESSTHAN:
146: 		// X < C
147: 		// this can be true only if min(X) < C
148: 		// if max(X) < C, then this is always true
149: 		if (max < constant) {
150: 			return FilterPropagateResult::FILTER_ALWAYS_TRUE;
151: 		} else if (min < constant) {
152: 			return FilterPropagateResult::NO_PRUNING_POSSIBLE;
153: 		} else {
154: 			return FilterPropagateResult::FILTER_ALWAYS_FALSE;
155: 		}
156: 	default:
157: 		throw InternalException("Expression type in zonemap check not implemented");
158: 	}
159: }
160: 
161: unique_ptr<BaseStatistics> NumericStatistics::Copy() {
162: 	auto stats = make_unique<NumericStatistics>(type, min, max);
163: 	if (validity_stats) {
164: 		stats->validity_stats = validity_stats->Copy();
165: 	}
166: 	return move(stats);
167: }
168: 
169: bool NumericStatistics::IsConstant() {
170: 	return max <= min;
171: }
172: 
173: void NumericStatistics::Serialize(Serializer &serializer) {
174: 	BaseStatistics::Serialize(serializer);
175: 	min.Serialize(serializer);
176: 	max.Serialize(serializer);
177: }
178: 
179: unique_ptr<BaseStatistics> NumericStatistics::Deserialize(Deserializer &source, LogicalType type) {
180: 	auto min = Value::Deserialize(source);
181: 	auto max = Value::Deserialize(source);
182: 	return make_unique_base<BaseStatistics, NumericStatistics>(move(type), min, max);
183: }
184: 
185: string NumericStatistics::ToString() {
186: 	return StringUtil::Format("[Min: %s, Max: %s]%s", min.ToString(), max.ToString(),
187: 	                          validity_stats ? validity_stats->ToString() : "");
188: }
189: 
190: template <class T>
191: void NumericStatistics::TemplatedVerify(Vector &vector, const SelectionVector &sel, idx_t count) {
192: 	VectorData vdata;
193: 	vector.Orrify(count, vdata);
194: 
195: 	auto data = (T *)vdata.data;
196: 	for (idx_t i = 0; i < count; i++) {
197: 		auto idx = sel.get_index(i);
198: 		auto index = vdata.sel->get_index(idx);
199: 		if (!vdata.validity.RowIsValid(index)) {
200: 			continue;
201: 		}
202: 		if (!min.is_null && LessThan::Operation(data[index], min.GetValueUnsafe<T>())) { // LCOV_EXCL_START
203: 			throw InternalException("Statistics mismatch: value is smaller than min.\nStatistics: %s\nVector: %s",
204: 			                        ToString(), vector.ToString(count));
205: 		} // LCOV_EXCL_STOP
206: 		if (!max.is_null && GreaterThan::Operation(data[index], max.GetValueUnsafe<T>())) {
207: 			throw InternalException("Statistics mismatch: value is bigger than max.\nStatistics: %s\nVector: %s",
208: 			                        ToString(), vector.ToString(count));
209: 		}
210: 	}
211: }
212: 
213: void NumericStatistics::Verify(Vector &vector, const SelectionVector &sel, idx_t count) {
214: 	BaseStatistics::Verify(vector, sel, count);
215: 
216: 	switch (type.InternalType()) {
217: 	case PhysicalType::BOOL:
218: 		break;
219: 	case PhysicalType::INT8:
220: 		TemplatedVerify<int8_t>(vector, sel, count);
221: 		break;
222: 	case PhysicalType::INT16:
223: 		TemplatedVerify<int16_t>(vector, sel, count);
224: 		break;
225: 	case PhysicalType::INT32:
226: 		TemplatedVerify<int32_t>(vector, sel, count);
227: 		break;
228: 	case PhysicalType::INT64:
229: 		TemplatedVerify<int64_t>(vector, sel, count);
230: 		break;
231: 	case PhysicalType::INT128:
232: 		TemplatedVerify<hugeint_t>(vector, sel, count);
233: 		break;
234: 	case PhysicalType::FLOAT:
235: 		TemplatedVerify<float>(vector, sel, count);
236: 		break;
237: 	case PhysicalType::DOUBLE:
238: 		TemplatedVerify<double>(vector, sel, count);
239: 		break;
240: 	default:
241: 		throw InternalException("Unsupported type %s for numeric statistics verify", type.ToString());
242: 	}
243: }
244: 
245: } // namespace duckdb
[end of src/storage/statistics/numeric_statistics.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: