diff --git a/src/common/value_operations/comparison_operations.cpp b/src/common/value_operations/comparison_operations.cpp
index 0afc8708b85b..8e65df6367b1 100644
--- a/src/common/value_operations/comparison_operations.cpp
+++ b/src/common/value_operations/comparison_operations.cpp
@@ -169,11 +169,8 @@ static bool TemplatedBooleanOperation(const Value &left, const Value &right) {
 }
 
 bool ValueOperations::Equals(const Value &left, const Value &right) {
-	if (left.is_null && right.is_null) {
-		return true;
-	}
-	if (left.is_null != right.is_null) {
-		return false;
+	if (left.is_null || right.is_null) {
+		throw InternalException("Comparison on NULL values");
 	}
 	return TemplatedBooleanOperation<duckdb::Equals>(left, right);
 }
@@ -183,23 +180,15 @@ bool ValueOperations::NotEquals(const Value &left, const Value &right) {
 }
 
 bool ValueOperations::GreaterThan(const Value &left, const Value &right) {
-	if (left.is_null && right.is_null) {
-		return false;
-	} else if (right.is_null) {
-		return true;
-	} else if (left.is_null) {
-		return false;
+	if (left.is_null || right.is_null) {
+		throw InternalException("Comparison on NULL values");
 	}
 	return TemplatedBooleanOperation<duckdb::GreaterThan>(left, right);
 }
 
 bool ValueOperations::GreaterThanEquals(const Value &left, const Value &right) {
-	if (left.is_null && right.is_null) {
-		return true;
-	} else if (right.is_null) {
-		return true;
-	} else if (left.is_null) {
-		return false;
+	if (left.is_null || right.is_null) {
+		throw InternalException("Comparison on NULL values");
 	}
 	return TemplatedBooleanOperation<duckdb::GreaterThanEquals>(left, right);
 }
diff --git a/src/optimizer/filter_combiner.cpp b/src/optimizer/filter_combiner.cpp
index 82980b520e20..6d5eeca53b14 100644
--- a/src/optimizer/filter_combiner.cpp
+++ b/src/optimizer/filter_combiner.cpp
@@ -506,27 +506,36 @@ TableFilterSet FilterCombiner::GenerateTableScanFilters(vector<idx_t> &column_id
 				continue;
 			}
 			auto &fst_const_value_expr = (BoundConstantExpression &)*func.children[1].get();
+
 			//! Check if values are consecutive, if yes transform them to >= <= (only for integers)
+			// e.g. if we have x IN (1, 2, 3, 4, 5) we transform this into x >= 1 AND x <= 5
 			if (!fst_const_value_expr.value.type().IsIntegral()) {
 				continue;
 			}
 
+			bool can_simplify_in_clause = true;
 			for (idx_t i = 1; i < func.children.size(); i++) {
 				auto &const_value_expr = (BoundConstantExpression &)*func.children[i].get();
+				if (const_value_expr.value.is_null) {
+					can_simplify_in_clause = false;
+					break;
+				}
 				in_values.push_back(const_value_expr.value);
 			}
+			if (!can_simplify_in_clause || in_values.empty()) {
+				continue;
+			}
 			Value one(1);
 
 			sort(in_values.begin(), in_values.end());
 
-			bool is_consecutive = true;
 			for (idx_t in_val_idx = 1; in_val_idx < in_values.size(); in_val_idx++) {
 				if (in_values[in_val_idx] - in_values[in_val_idx - 1] > one || in_values[in_val_idx - 1].is_null) {
-					is_consecutive = false;
+					can_simplify_in_clause = false;
 					break;
 				}
 			}
-			if (!is_consecutive || in_values.empty()) {
+			if (!can_simplify_in_clause) {
 				continue;
 			}
 			auto lower_bound =
diff --git a/src/optimizer/rule/move_constants.cpp b/src/optimizer/rule/move_constants.cpp
index fd7d8026692c..d97ab1ae4fc7 100644
--- a/src/optimizer/rule/move_constants.cpp
+++ b/src/optimizer/rule/move_constants.cpp
@@ -36,6 +36,9 @@ unique_ptr<Expression> MoveConstantsRule::Apply(LogicalOperator &op, vector<Expr
 	if (!arithmetic->return_type.IsNumeric()) {
 		return nullptr;
 	}
+	if (inner_constant->value.is_null || outer_constant->value.is_null) {
+		return make_unique<BoundConstantExpression>(Value(comparison->return_type));
+	}
 
 	int arithmetic_child_index = arithmetic->children[0].get() == inner_constant ? 1 : 0;
 	auto &op_type = arithmetic->function.name;
diff --git a/src/optimizer/statistics/expression/propagate_constant.cpp b/src/optimizer/statistics/expression/propagate_constant.cpp
index c2e9a0f53fdd..d5f544efca62 100644
--- a/src/optimizer/statistics/expression/propagate_constant.cpp
+++ b/src/optimizer/statistics/expression/propagate_constant.cpp
@@ -24,8 +24,10 @@ unique_ptr<BaseStatistics> StatisticsPropagator::StatisticsFromValue(const Value
 	case PhysicalType::VARCHAR: {
 		auto result = make_unique<StringStatistics>(input.type());
 		result->validity_stats = make_unique<ValidityStatistics>(input.is_null, !input.is_null);
-		string_t str(input.str_value.c_str(), input.str_value.size());
-		result->Update(str);
+		if (!input.is_null) {
+			string_t str(input.str_value.c_str(), input.str_value.size());
+			result->Update(str);
+		}
 		return move(result);
 	}
 	case PhysicalType::STRUCT: {
diff --git a/src/parser/expression/constant_expression.cpp b/src/parser/expression/constant_expression.cpp
index 187830730881..6c553e5d18b3 100644
--- a/src/parser/expression/constant_expression.cpp
+++ b/src/parser/expression/constant_expression.cpp
@@ -15,7 +15,7 @@ string ConstantExpression::ToString() const {
 }
 
 bool ConstantExpression::Equals(const ConstantExpression *a, const ConstantExpression *b) {
-	return a->value == b->value;
+	return !ValueOperations::DistinctFrom(a->value, b->value);
 }
 
 hash_t ConstantExpression::Hash() const {
diff --git a/src/planner/expression/bound_constant_expression.cpp b/src/planner/expression/bound_constant_expression.cpp
index c0f295dba3d8..e7c13618181f 100644
--- a/src/planner/expression/bound_constant_expression.cpp
+++ b/src/planner/expression/bound_constant_expression.cpp
@@ -19,7 +19,7 @@ bool BoundConstantExpression::Equals(const BaseExpression *other_p) const {
 		return false;
 	}
 	auto other = (BoundConstantExpression *)other_p;
-	return value == other->value;
+	return !ValueOperations::DistinctFrom(value, other->value);
 }
 
 hash_t BoundConstantExpression::Hash() const {
diff --git a/src/storage/statistics/numeric_statistics.cpp b/src/storage/statistics/numeric_statistics.cpp
index b8a17bf4ec05..f9697a3b0543 100644
--- a/src/storage/statistics/numeric_statistics.cpp
+++ b/src/storage/statistics/numeric_statistics.cpp
@@ -91,15 +91,22 @@ NumericStatistics::NumericStatistics(LogicalType type_p, Value min_p, Value max_
 void NumericStatistics::Merge(const BaseStatistics &other_p) {
 	BaseStatistics::Merge(other_p);
 	auto &other = (const NumericStatistics &)other_p;
-	if (other.min < min) {
+	if (other.min.is_null || min.is_null) {
+		min.is_null = true;
+	} else if (other.min < min) {
 		min = other.min;
 	}
-	if (other.max > max) {
+	if (other.max.is_null || max.is_null) {
+		max.is_null = true;
+	} else if (other.max > max) {
 		max = other.max;
 	}
 }
 
 FilterPropagateResult NumericStatistics::CheckZonemap(ExpressionType comparison_type, const Value &constant) {
+	if (min.is_null || max.is_null) {
+		return FilterPropagateResult::NO_PRUNING_POSSIBLE;
+	}
 	switch (comparison_type) {
 	case ExpressionType::COMPARE_EQUAL:
 		if (constant == min && constant == max) {
