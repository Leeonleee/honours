{
  "repo": "duckdb/duckdb",
  "pull_number": 6878,
  "instance_id": "duckdb__duckdb-6878",
  "issue_numbers": [
    "6845"
  ],
  "base_commit": "d1518bdfe8c28127a6bb56798c0576e2e76cc55a",
  "patch": "diff --git a/tools/pythonpkg/src/vector_conversion.cpp b/tools/pythonpkg/src/vector_conversion.cpp\nindex 4dbbf90fe6a6..4407b49f886e 100644\n--- a/tools/pythonpkg/src/vector_conversion.cpp\n+++ b/tools/pythonpkg/src/vector_conversion.cpp\n@@ -305,8 +305,9 @@ void VectorConversion::NumpyToDuckDB(PandasColumnBindData &bind_data, py::array\n \t\tauto &import_cache = *DuckDBPyConnection::ImportCache();\n \n \t\t// Loop over every row of the arrays contents\n+\t\tauto stride = bind_data.numpy_stride;\n \t\tfor (idx_t row = 0; row < count; row++) {\n-\t\t\tauto source_idx = offset + row;\n+\t\t\tauto source_idx = stride / sizeof(PyObject *) * (row + offset);\n \n \t\t\t// Get the pointer to the object\n \t\t\tPyObject *val = src_ptr[source_idx];\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/pandas/test_pandas_object.py b/tools/pythonpkg/tests/fast/pandas/test_pandas_object.py\nindex 694cb61c1bad..8f1aa2e88ad6 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_pandas_object.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_pandas_object.py\n@@ -1,7 +1,7 @@\n import pandas as pd\n import duckdb\n import datetime\n-from numpy import array\n+import numpy as np\n import random\n \n class TestPandasObject(object):\n@@ -32,11 +32,18 @@ def test_2273(self, duckdb_cursor):\n         df_in = pd.DataFrame([[datetime.date(1992, 7, 30)]])\n         assert duckdb.query(\"Select * from df_in\").fetchall() == [(datetime.date(1992, 7, 30),)]\n \n+    def test_object_to_string_with_stride(self, duckdb_cursor):\n+        data = np.array([[\"a\", \"b\", \"c\"], [1,2,3], [1, 2, 3], [11, 22, 33]])\n+        df = pd.DataFrame(data=data[1:,], columns=data[0])\n+        duckdb_cursor.register(\"object_with_strides\", df)\n+        res = duckdb_cursor.sql('select * from object_with_strides').fetchall()\n+        assert res == [('1', '2', '3'), ('1', '2', '3'), ('11', '22', '33')]\n+\n     def test_2499(self, duckdb_cursor):  \n         df = pd.DataFrame(\n             [\n                 [\n-                    array([\n+                    np.array([\n                             {'a': 0.881040697801939},\n                             {'a': 0.9922600577751953},\n                             {'a': 0.1589674833259317},\n@@ -45,7 +52,7 @@ def test_2499(self, duckdb_cursor):\n                     ], dtype=object)\n                 ],\n                 [\n-                    array([\n+                    np.array([\n                             {'a': 0.8759413504156746},\n                             {'a': 0.055784331256246156},\n                             {'a': 0.8605151517439655},\n@@ -54,7 +61,7 @@ def test_2499(self, duckdb_cursor):\n                     ], dtype=object)\n                 ],\n                 [\n-                    array([\n+                    np.array([\n                             {'a': 0.9697093934032401},\n                             {'a': 0.9529257667149468},\n                             {'a': 0.21398182248591713},\n",
  "problem_statement": "Pandas DataFrames created with `data` arg are queried incorrectly. \n### What happens?\r\n\r\nPandas allows you to construct DataFrames in somewhat strange ways. For example,\r\n```python\r\nimport pandas\r\nimport numpy\r\ndata = numpy.array([[\"a\", \"b\", \"c\"], [1,2,3], [1, 2, 3], [11, 22, 33]])\r\nprint(data)\r\n[['a' 'b' 'c']\r\n ['1' '2' '3']\r\n ['1' '2' '3']\r\n ['11' '22' '33']]\r\n```\r\n```python\r\ndf = pandas.DataFrame(data=data[1:,], columns=data[0])\r\ndf\r\n    a   b   c\r\n0   1   2   3\r\n1   1   2   3\r\n2  11  22  33\r\n```\r\nWe can see here that `data` is contiguous:\r\n```python\r\ndata.flags\r\nOut[3]:\r\n  C_CONTIGUOUS : True\r\n  F_CONTIGUOUS : False\r\n  OWNDATA : True\r\n  WRITEABLE : True\r\n  ALIGNED : True\r\n  WRITEBACKIFCOPY : False\r\n```\r\nHowever, individual columns of `df` are not.\r\n```python\r\ndf[\"a\"].values.flags\r\nOut[11]:\r\n  C_CONTIGUOUS : False\r\n  F_CONTIGUOUS : False\r\n  OWNDATA : False\r\n  WRITEABLE : True\r\n  ALIGNED : True\r\n  WRITEBACKIFCOPY : False\r\n```\r\n\r\nThis causes DuckDB to query the data incorrectly:\r\n```python\r\nduckdb.query(\"select * from df\").to_df()\r\nOut[8]:\r\n   a  b  c\r\n0  1  2  3\r\n1  2  3  1\r\n2  3  1  2\r\n```\r\n\r\n### To Reproduce\r\n\r\n```python\r\nimport pandas\r\nimport numpy\r\nimport duckdb\r\n\r\ndata = numpy.array([[\"a\", \"b\", \"c\"], [1,2,3], [1, 2, 3], [11, 22, 33]])\r\ndf = pandas.DataFrame(data=data[1:,], columns=data[0])\r\ndf_shuffled = duckdb.query(\"select * from df\").to_df()\r\n```\r\n\r\n### OS:\r\n\r\niOS 13.2.1 (22D68)\r\n\r\n### DuckDB Version(s):\r\n\r\n0.7.1\r\n0.7.2-dev982\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nTim N\r\n\r\n### Affiliation:\r\n\r\nHex\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "This may be classified as undefined behavior as the DuckDB Python client may \"require\" contiguous arrays to function correctly. \r\n\r\nHowever, this is still strange/undesirable behavior as the default for DuckDB to scan python `locals()` to \"automatically\" enable querying of pandas DataFrames makes this seem more like a bug than user error. \nI see same issue with any numpy array of strings, such as: \r\n\r\n```\r\nimport pandas\r\nimport numpy\r\nimport duckdb\r\n\r\n\r\ndata1 = numpy.array([[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"]])\r\ndf1 = pandas.DataFrame(data=data1)\r\ndf1_ddb = duckdb.query(\"select * from df1\").to_df()\r\n\r\ndisplay(df1)\r\ndisplay(df1_ddb)\r\n```\r\ndf1 = \r\n0\t1\t2\r\na\tb\tc\r\nd\te\tf\r\n\r\ndf1_ddb = \r\n0\t1\t2\r\na\tb\tc\r\nb\tc\td\r\n\r\n\r\n\n@paultiq Interesting. It seems this is just for string (maybe other dtypes too?) DataFrames constructed with the `data` arg, and the non-contiguous numpy array was a red herring.\r\n\r\nIf you `copy(deep=True)` either example, the issue disappears.\r\n```\r\ndata1 = numpy.array([[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"]])\r\ndf1 = pandas.DataFrame(data=data1).copy(deep=True)\r\ndf1_ddb = duckdb.query(\"select * from df1\").to_df()\r\nassert str(df1) == str(df1_ddb)\r\n\r\ndata = numpy.array([[\"a\", \"b\", \"c\"], [1,2,3], [1, 2, 3], [11, 22, 33]])\r\ndf = pandas.DataFrame(data=data[1:,], columns=data[0]).copy(deep=True)\r\ndf_shuffled = duckdb.query(\"select * from df\").to_df()\r\nassert str(df) == str(df_shuffled)\r\n```\nGoing a little further: reproduces on anything with dtype='<U11'.\r\n\r\n```\r\nimport pandas\r\nimport numpy\r\nimport duckdb\r\ndata1 = numpy.array([[1,2,3], [5,6, 7]], dtype=\"<U11\")\r\nprint(data1.dtype)\r\ndf1 = pandas.DataFrame(data=data1)\r\ndf1_ddb = duckdb.query(\"select * from df1\").to_df()\r\nprint(df1)\r\nprint(df1_ddb)\r\n```\nThis issue is related to scanning pandas object columns, I'll have a look \ud83d\udc4d \nSo there's two issues here, one is that the type of this becomes `VARCHAR`. This happens because we don't have any logic built in to specifically deal with RangeIndex, and instead resort to `column.__array__()` which creates a list of string values out of the RangeIndex, ~~because that makes perfect sense~~\r\nAh that happens because of the `[\"a\", \"b\", \"c\"]` list in the array.\r\nIt's not aware that that has been stripped out, so it converts to string since the type is still object\r\n\r\nThe other issue is that for strings, we don't take strides into account, and assume everything is aligned",
  "created_at": "2023-03-27T12:03:33Z"
}