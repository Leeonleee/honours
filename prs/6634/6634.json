{
  "repo": "duckdb/duckdb",
  "pull_number": 6634,
  "instance_id": "duckdb__duckdb-6634",
  "issue_numbers": [
    "6581",
    "6581"
  ],
  "base_commit": "403d0ca315bbd410f2fd8eeaad368204e9bfbf2a",
  "patch": "diff --git a/src/optimizer/rule/regex_optimizations.cpp b/src/optimizer/rule/regex_optimizations.cpp\nindex 0a05fea0ff38..54a410553b3c 100644\n--- a/src/optimizer/rule/regex_optimizations.cpp\n+++ b/src/optimizer/rule/regex_optimizations.cpp\n@@ -35,7 +35,7 @@ unique_ptr<Expression> RegexOptimizationRule::Apply(LogicalOperator &op, vector<\n \n \tauto constant_value = ExpressionExecutor::EvaluateScalar(GetContext(), *constant_expr);\n \tD_ASSERT(constant_value.type() == constant_expr->return_type);\n-\tauto &patt_str = StringValue::Get(constant_value);\n+\tauto patt_str = StringValue::Get(constant_value);\n \n \tduckdb_re2::RE2 pattern(patt_str);\n \tif (!pattern.ok()) {\n@@ -47,7 +47,14 @@ unique_ptr<Expression> RegexOptimizationRule::Apply(LogicalOperator &op, vector<\n \t\tauto contains = make_unique<BoundFunctionExpression>(root->return_type, ContainsFun::GetFunction(),\n \t\t                                                     std::move(root->children), nullptr);\n \n-\t\tcontains->children[1] = make_unique<BoundConstantExpression>(Value(patt_str));\n+\t\tstring min;\n+\t\tstring max;\n+\t\tpattern.PossibleMatchRange(&min, &max, patt_str.size());\n+\t\tif (min == max) {\n+\t\t\tcontains->children[1] = make_unique<BoundConstantExpression>(Value(std::move(min)));\n+\t\t} else {\n+\t\t\tcontains->children[1] = make_unique<BoundConstantExpression>(Value(std::move(patt_str)));\n+\t\t}\n \t\treturn std::move(contains);\n \t}\n \treturn nullptr;\n",
  "test_patch": "diff --git a/test/optimizer/regex_optimizer.test b/test/optimizer/regex_optimizer.test\nindex 1d7665889eea..071e4f6bc06c 100644\n--- a/test/optimizer/regex_optimizer.test\n+++ b/test/optimizer/regex_optimizer.test\n@@ -30,3 +30,15 @@ EXPLAIN SELECT regexp_matches(s, 'a') FROM test\n query I nosort regexconstantsinglechar\n EXPLAIN SELECT contains(s, 'a') FROM test\n ----\n+\n+query I nosort correct_result\n+SELECT regexp_matches(s, '[a]') FROM test\n+----\n+\n+query I nosort correct_result\n+SELECT regexp_matches(s, 'a') FROM test\n+----\n+\n+query I nosort correct_result\n+SELECT contains(s, 'aaa') FROM test\n+----\ndiff --git a/test/optimizer/regex_optimizer_coverage.test b/test/optimizer/regex_optimizer_coverage.test\nnew file mode 100644\nindex 000000000000..7aae7a7fd80e\n--- /dev/null\n+++ b/test/optimizer/regex_optimizer_coverage.test\n@@ -0,0 +1,48 @@\n+# name: test/optimizer/regex_optimizer_coverage.test\n+# description: Test Like Optimization Rules\n+# group: [optimizer]\n+\n+statement ok\n+CREATE TABLE test(word VARCHAR);\n+\n+statement ok\n+INSERT INTO test VALUES ('FLASH'), ('TOAST'), ('BELL');\n+\n+statement ok\n+PRAGMA explain_output = OPTIMIZED_ONLY;\n+\n+query I nosort correct_result\n+select contains(word, 'AS') from test;\n+----\n+\n+query I nosort correct_result\n+select regexp_matches(word, '[A]') from test;\n+----\n+\n+query I nosort correct_result\n+select regexp_matches(word, 'A') from test;\n+----\n+\n+query I nosort correct_result\n+select regexp_matches(word, 'AS') from test;\n+----\n+\n+query I nosort correct_result\n+select regexp_matches(word, '[AS]') from test;\n+----\n+\n+query I nosort correct_result\n+select regexp_matches(word, '[S]') from test;\n+----\n+\n+query I nosort correct_result\n+select regexp_matches(word, '[A][S]') from test;\n+----\n+\n+query I nosort correct_result\n+select regexp_matches(word, '[AAAA]') from test;\n+----\n+\n+query I nosort correct_result\n+select regexp_matches(word, '[A-A]') from test;\n+----\n",
  "problem_statement": "REGEXP_MATCHES returns wrong results.\n### What happens?\n\nWeirdly, REGEXP_MATCH for '[A]' fails to match for a single character.\r\n\r\nThe first where clause emits no results, the second emits (correctly) two results.\n\n### To Reproduce\n\n```\r\nSELECT word\r\nFROM (SELECT UNNEST(['FLASH','TOAST','BELL' ]) as word)\r\nWHERE REGEXP_MATCHES(word, '[A]')\r\n-- WHERE REGEXP_MATCHES(word, '[AS]')\r\n```\n\n### OS:\n\nlinux\n\n### DuckDB Version:\n\n0.7.1\n\n### DuckDB Client:\n\ncli\n\n### Full Name:\n\nlloyd tabb\n\n### Affiliation:\n\ngoogle\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nREGEXP_MATCHES returns wrong results.\n### What happens?\n\nWeirdly, REGEXP_MATCH for '[A]' fails to match for a single character.\r\n\r\nThe first where clause emits no results, the second emits (correctly) two results.\n\n### To Reproduce\n\n```\r\nSELECT word\r\nFROM (SELECT UNNEST(['FLASH','TOAST','BELL' ]) as word)\r\nWHERE REGEXP_MATCHES(word, '[A]')\r\n-- WHERE REGEXP_MATCHES(word, '[AS]')\r\n```\n\n### OS:\n\nlinux\n\n### DuckDB Version:\n\n0.7.1\n\n### DuckDB Client:\n\ncli\n\n### Full Name:\n\nlloyd tabb\n\n### Affiliation:\n\ngoogle\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Ah it gets wrongly optimized to use `contains`:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\r\n\u2502\u2502       Physical Plan       \u2502\u2502\r\n\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         PROJECTION        \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502             #1            \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502           FILTER          \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502   contains(word, '[A]')   \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502           EC: 1           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502           UNNEST          \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         DUMMY_SCAN        \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \r\n```\r\nbecause of `regex_optimizations.cpp`\nI've looked into the RE2 library but couldn't find any difference in the produced pattern from `[A]` and `A` - so we can't use that to differentiate between the two cases.\r\nWe can just check if it's 3 characters and start with `[` and ends with `]`, but that feels a little too hardcoded?\r\nThough I'm pretty sure that will work\nAh it gets wrongly optimized to use `contains`:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\r\n\u2502\u2502       Physical Plan       \u2502\u2502\r\n\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         PROJECTION        \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502             #1            \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502           FILTER          \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502   contains(word, '[A]')   \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502           EC: 1           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502           UNNEST          \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         DUMMY_SCAN        \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \r\n```\r\nbecause of `regex_optimizations.cpp`\nI've looked into the RE2 library but couldn't find any difference in the produced pattern from `[A]` and `A` - so we can't use that to differentiate between the two cases.\r\nWe can just check if it's 3 characters and start with `[` and ends with `]`, but that feels a little too hardcoded?\r\nThough I'm pretty sure that will work",
  "created_at": "2023-03-09T08:06:38Z"
}