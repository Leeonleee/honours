{
  "repo": "duckdb/duckdb",
  "pull_number": 11668,
  "instance_id": "duckdb__duckdb-11668",
  "issue_numbers": [
    "11467",
    "11467"
  ],
  "base_commit": "5bcfd7434790fabb0ea99998abb78e3a31bad47a",
  "patch": "diff --git a/src/common/types.cpp b/src/common/types.cpp\nindex e4318c26ed22..862f86e5f900 100644\n--- a/src/common/types.cpp\n+++ b/src/common/types.cpp\n@@ -868,6 +868,8 @@ static bool CombineEqualTypes(const LogicalType &left, const LogicalType &right,\n \t\t// struct: perform recursively on each child\n \t\tauto &left_child_types = StructType::GetChildTypes(left);\n \t\tauto &right_child_types = StructType::GetChildTypes(right);\n+\t\tbool left_unnamed = StructType::IsUnnamed(left);\n+\t\tauto any_unnamed = left_unnamed || StructType::IsUnnamed(right);\n \t\tif (left_child_types.size() != right_child_types.size()) {\n \t\t\t// child types are not of equal size, we can't cast\n \t\t\t// return false\n@@ -876,14 +878,15 @@ static bool CombineEqualTypes(const LogicalType &left, const LogicalType &right,\n \t\tchild_list_t<LogicalType> child_types;\n \t\tfor (idx_t i = 0; i < left_child_types.size(); i++) {\n \t\t\tLogicalType child_type;\n-\t\t\t// Child names must be in the same order\n-\t\t\tif (!StringUtil::CIEquals(left_child_types[i].first, right_child_types[i].first)) {\n+\t\t\t// Child names must be in the same order OR either one of the structs must be unnamed\n+\t\t\tif (!any_unnamed && !StringUtil::CIEquals(left_child_types[i].first, right_child_types[i].first)) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tif (!OP::Operation(left_child_types[i].second, right_child_types[i].second, child_type)) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tchild_types.emplace_back(left_child_types[i].first, std::move(child_type));\n+\t\t\tauto &child_name = left_unnamed ? right_child_types[i].first : left_child_types[i].first;\n+\t\t\tchild_types.emplace_back(child_name, std::move(child_type));\n \t\t}\n \t\tresult = LogicalType::STRUCT(child_types);\n \t\treturn true;\n",
  "test_patch": "diff --git a/test/sql/types/struct/unnamed_struct_mix.test b/test/sql/types/struct/unnamed_struct_mix.test\nnew file mode 100644\nindex 000000000000..dcc6086e7ed1\n--- /dev/null\n+++ b/test/sql/types/struct/unnamed_struct_mix.test\n@@ -0,0 +1,16 @@\n+# name: test/sql/types/struct/unnamed_struct_mix.test\n+# description: Test mix of named and unnamed structs\n+# group: [struct]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+select [{ t:'abc', len:5 }, ('abc', 2)]\n+----\n+[{'t': abc, 'len': 5}, {'t': abc, 'len': 2}]\n+\n+query I\n+select [('abc', 2), { t:'abc', len:5 }]\n+----\n+[{'t': abc, 'len': 2}, {'t': abc, 'len': 5}]\n",
  "problem_statement": "0.11 Snapshot: Cannot create a list of types STRUCT(t VARCHAR, len INTEGER) and STRUCT(VARCHAR, INTEGER)\n### What happens?\r\n\r\nGenerating Lists from STRUCT suddenly fails with version 0.11-Snapshot\r\n\r\n### To Reproduce\r\n\r\n```sql\r\n-- works with 0.10.0\r\nselect Unnest([\r\n  { t:'abc', len:5 }::STRUCT(t VARCHAR, len integer),\r\n   ('abc', 2),\r\n], recursive => true);\r\n```\r\n\r\nFails with 0.11-Snapshot\r\n```sql\r\nselect Unnest([\r\n  { t:'abc', len:5 }::STRUCT(t VARCHAR, len integer),\r\n   ('abc', 2),\r\n], recursive => true);\r\n```\r\n```\r\nBinder Error: Cannot create a list of types STRUCT(t VARCHAR, len INTEGER) and STRUCT(VARCHAR, INTEGER) - an explicit cast is required LINE 3:    ('abc', 2),\r\n```\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n0.11-Snapshot\r\n\r\n### DuckDB Client:\r\n\r\nJava\r\n\r\n### Full Name:\r\n\r\nAndreas Reichel\r\n\r\n### Affiliation:\r\n\r\nmanticore-projects.com\r\n\r\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\r\n\r\nI have tested with a nightly build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n0.11 Snapshot: Cannot create a list of types STRUCT(t VARCHAR, len INTEGER) and STRUCT(VARCHAR, INTEGER)\n### What happens?\r\n\r\nGenerating Lists from STRUCT suddenly fails with version 0.11-Snapshot\r\n\r\n### To Reproduce\r\n\r\n```sql\r\n-- works with 0.10.0\r\nselect Unnest([\r\n  { t:'abc', len:5 }::STRUCT(t VARCHAR, len integer),\r\n   ('abc', 2),\r\n], recursive => true);\r\n```\r\n\r\nFails with 0.11-Snapshot\r\n```sql\r\nselect Unnest([\r\n  { t:'abc', len:5 }::STRUCT(t VARCHAR, len integer),\r\n   ('abc', 2),\r\n], recursive => true);\r\n```\r\n```\r\nBinder Error: Cannot create a list of types STRUCT(t VARCHAR, len INTEGER) and STRUCT(VARCHAR, INTEGER) - an explicit cast is required LINE 3:    ('abc', 2),\r\n```\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n0.11-Snapshot\r\n\r\n### DuckDB Client:\r\n\r\nJava\r\n\r\n### Full Name:\r\n\r\nAndreas Reichel\r\n\r\n### Affiliation:\r\n\r\nmanticore-projects.com\r\n\r\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\r\n\r\nI have tested with a nightly build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "I imagine this is a result of <https://github.com/duckdb/duckdb/pull/11396>\r\nThough I can't immediately tell if this is intended or an unwanted side effect / bug?\r\n\r\nI would guess it's the latter, because unnamed structs should be able to be cast implicitly to a named struct of the same types\n> I would guess it's the latter, because unnamed structs should be able to be cast implicitly to a named struct of the same types\r\n\r\nI concur or else you would have to explicitly cast every single row of your array?\r\n\r\nAt the same time I wonder: are there no standard unit tests to catch such things before merging?\nI imagine this is a result of <https://github.com/duckdb/duckdb/pull/11396>\r\nThough I can't immediately tell if this is intended or an unwanted side effect / bug?\r\n\r\nI would guess it's the latter, because unnamed structs should be able to be cast implicitly to a named struct of the same types\n> I would guess it's the latter, because unnamed structs should be able to be cast implicitly to a named struct of the same types\r\n\r\nI concur or else you would have to explicitly cast every single row of your array?\r\n\r\nAt the same time I wonder: are there no standard unit tests to catch such things before merging?",
  "created_at": "2024-04-16T08:47:36Z"
}