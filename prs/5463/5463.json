{
  "repo": "duckdb/duckdb",
  "pull_number": 5463,
  "instance_id": "duckdb__duckdb-5463",
  "issue_numbers": [
    "5450",
    "5450"
  ],
  "base_commit": "b08ba5b032506713d00d6cb7f11bb0e6085b5171",
  "patch": "diff --git a/src/function/aggregate/holistic/quantile.cpp b/src/function/aggregate/holistic/quantile.cpp\nindex a55560987620..3441e51e946b 100644\n--- a/src/function/aggregate/holistic/quantile.cpp\n+++ b/src/function/aggregate/holistic/quantile.cpp\n@@ -21,7 +21,7 @@ static hugeint_t operator*(const hugeint_t &h, const double &d) {\n }\n \n // Interval arithmetic\n-static interval_t operator*(const interval_t &i, const double &d) {\n+static interval_t operator*(const interval_t &i, const double &d) { // NOLINT\n \tD_ASSERT(d >= 0 && d <= 1);\n \treturn Interval::FromMicro(std::llround(Interval::GetMicro(i) * d));\n }\n@@ -261,28 +261,32 @@ struct QuantileComposed {\n \n // Accessed comparison\n template <typename ACCESSOR>\n-struct QuantileLess {\n+struct QuantileCompare {\n \tusing INPUT_TYPE = typename ACCESSOR::INPUT_TYPE;\n \tconst ACCESSOR &accessor;\n-\texplicit QuantileLess(const ACCESSOR &accessor_p) : accessor(accessor_p) {\n+\tconst bool desc;\n+\texplicit QuantileCompare(const ACCESSOR &accessor_p, bool desc_p) : accessor(accessor_p), desc(desc_p) {\n \t}\n \n \tinline bool operator()(const INPUT_TYPE &lhs, const INPUT_TYPE &rhs) const {\n-\t\treturn accessor(lhs) < accessor(rhs);\n+\t\tconst auto lval = accessor(lhs);\n+\t\tconst auto rval = accessor(rhs);\n+\n+\t\treturn desc ? (rval < lval) : (lval < rval);\n \t}\n };\n \n // Continuous interpolation\n template <bool DISCRETE>\n struct Interpolator {\n-\tInterpolator(const double q, const idx_t n_p)\n-\t    : n(n_p), RN((double)(n_p - 1) * q), FRN(floor(RN)), CRN(ceil(RN)), begin(0), end(n_p) {\n+\tInterpolator(const double q, const idx_t n_p, const bool desc_p)\n+\t    : desc(desc_p), RN((double)(n_p - 1) * q), FRN(floor(RN)), CRN(ceil(RN)), begin(0), end(n_p) {\n \t}\n \n \ttemplate <class INPUT_TYPE, class TARGET_TYPE, typename ACCESSOR = QuantileDirect<INPUT_TYPE>>\n \tTARGET_TYPE Operation(INPUT_TYPE *v_t, Vector &result, const ACCESSOR &accessor = ACCESSOR()) const {\n \t\tusing ACCESS_TYPE = typename ACCESSOR::RESULT_TYPE;\n-\t\tQuantileLess<ACCESSOR> comp(accessor);\n+\t\tQuantileCompare<ACCESSOR> comp(accessor, desc);\n \t\tif (CRN == FRN) {\n \t\t\tstd::nth_element(v_t + begin, v_t + FRN, v_t + end, comp);\n \t\t\treturn CastInterpolation::Cast<ACCESS_TYPE, TARGET_TYPE>(accessor(v_t[FRN]), result);\n@@ -307,7 +311,7 @@ struct Interpolator {\n \t\t}\n \t}\n \n-\tconst idx_t n;\n+\tconst bool desc;\n \tconst double RN;\n \tconst idx_t FRN;\n \tconst idx_t CRN;\n@@ -319,14 +323,15 @@ struct Interpolator {\n // Discrete \"interpolation\"\n template <>\n struct Interpolator<true> {\n-\tInterpolator(const double q, const idx_t n_p)\n-\t    : n(n_p), RN((double)(n_p - 1) * q), FRN(floor(RN)), CRN(FRN), begin(0), end(n_p) {\n+\tInterpolator(const double q, const idx_t n_p, bool desc_p)\n+\t    : desc(desc_p), RN((double)(n_p * q)), FRN(MaxValue<idx_t>(1, n_p - floor(n_p - RN)) - 1), CRN(FRN), begin(0),\n+\t      end(n_p) {\n \t}\n \n \ttemplate <class INPUT_TYPE, class TARGET_TYPE, typename ACCESSOR = QuantileDirect<INPUT_TYPE>>\n \tTARGET_TYPE Operation(INPUT_TYPE *v_t, Vector &result, const ACCESSOR &accessor = ACCESSOR()) const {\n \t\tusing ACCESS_TYPE = typename ACCESSOR::RESULT_TYPE;\n-\t\tQuantileLess<ACCESSOR> comp(accessor);\n+\t\tQuantileCompare<ACCESSOR> comp(accessor, desc);\n \t\tstd::nth_element(v_t + begin, v_t + FRN, v_t + end, comp);\n \t\treturn CastInterpolation::Cast<ACCESS_TYPE, TARGET_TYPE>(accessor(v_t[FRN]), result);\n \t}\n@@ -337,7 +342,7 @@ struct Interpolator<true> {\n \t\treturn CastInterpolation::Cast<ACCESS_TYPE, TARGET_TYPE>(accessor(v_t[FRN]), result);\n \t}\n \n-\tconst idx_t n;\n+\tconst bool desc;\n \tconst double RN;\n \tconst idx_t FRN;\n \tconst idx_t CRN;\n@@ -347,29 +352,49 @@ struct Interpolator<true> {\n };\n \n struct QuantileBindData : public FunctionData {\n-\texplicit QuantileBindData(double quantile_p) : quantiles(1, quantile_p), order(1, 0) {\n+\ttemplate <typename T>\n+\tstatic inline T Abs(const T &t) {\n+\t\treturn AbsOperator::Operation<T, T>(t);\n+\t}\n+\n+\texplicit QuantileBindData(double quantile_p) : quantiles(1, Abs(quantile_p)), order(1, 0), desc(quantile_p < 0) {\n \t}\n \n-\texplicit QuantileBindData(const vector<double> &quantiles_p) : quantiles(quantiles_p) {\n-\t\tfor (idx_t i = 0; i < quantiles.size(); ++i) {\n+\texplicit QuantileBindData(const vector<double> &quantiles_p) {\n+\t\tsize_t pos = 0;\n+\t\tsize_t neg = 0;\n+\t\tfor (idx_t i = 0; i < quantiles_p.size(); ++i) {\n+\t\t\tconst auto q = quantiles_p[i];\n+\t\t\tpos += (q > 0);\n+\t\t\tneg += (q < 0);\n+\t\t\tquantiles.push_back(Abs(q));\n \t\t\torder.push_back(i);\n \t\t}\n+\t\tif (pos && neg) {\n+\t\t\tthrow BinderException(\"QUANTILE parameters must have consistent signs\");\n+\t\t}\n+\t\tdesc = (neg > 0);\n \n \t\tIndirectLess<double> lt(quantiles.data());\n \t\tstd::sort(order.begin(), order.end(), lt);\n \t}\n \n \tunique_ptr<FunctionData> Copy() const override {\n-\t\treturn make_unique<QuantileBindData>(quantiles);\n+\t\tvector<double> copies;\n+\t\tfor (const auto &q : quantiles) {\n+\t\t\tcopies.emplace_back(desc ? -q : q);\n+\t\t}\n+\t\treturn make_unique<QuantileBindData>(copies);\n \t}\n \n \tbool Equals(const FunctionData &other_p) const override {\n \t\tauto &other = (QuantileBindData &)other_p;\n-\t\treturn quantiles == other.quantiles && order == other.order;\n+\t\treturn desc == other.desc && quantiles == other.quantiles && order == other.order;\n \t}\n \n \tvector<double> quantiles;\n \tvector<idx_t> order;\n+\tbool desc;\n };\n \n struct QuantileOperation {\n@@ -465,7 +490,7 @@ struct QuantileScalarOperation : public QuantileOperation {\n \t\tD_ASSERT(aggr_input_data.bind_data);\n \t\tauto bind_data = (QuantileBindData *)aggr_input_data.bind_data;\n \t\tD_ASSERT(bind_data->quantiles.size() == 1);\n-\t\tInterpolator<DISCRETE> interp(bind_data->quantiles[0], state->v.size());\n+\t\tInterpolator<DISCRETE> interp(bind_data->quantiles[0], state->v.size(), bind_data->desc);\n \t\ttarget[idx] = interp.template Operation<typename STATE::SaveType, RESULT_TYPE>(state->v.data(), result);\n \t}\n \n@@ -497,7 +522,7 @@ struct QuantileScalarOperation : public QuantileOperation {\n \t\t\tconst auto j = ReplaceIndex(index, frame, prev);\n \t\t\t//\tWe can only replace if the number of NULLs has not changed\n \t\t\tif (included.AllValid() || included(prev.first) == included(prev.second)) {\n-\t\t\t\tInterpolator<DISCRETE> interp(q, prev_pos);\n+\t\t\t\tInterpolator<DISCRETE> interp(q, prev_pos, false);\n \t\t\t\treplace = CanReplace(index, data, j, interp.FRN, interp.CRN, included);\n \t\t\t\tif (replace) {\n \t\t\t\t\tstate->pos = prev_pos;\n@@ -512,7 +537,7 @@ struct QuantileScalarOperation : public QuantileOperation {\n \t\t\tstate->pos = std::partition(index, index + state->pos, included) - index;\n \t\t}\n \t\tif (state->pos) {\n-\t\t\tInterpolator<DISCRETE> interp(q, state->pos);\n+\t\t\tInterpolator<DISCRETE> interp(q, state->pos, false);\n \n \t\t\tusing ID = QuantileIndirect<INPUT_TYPE>;\n \t\t\tID indirect(data);\n@@ -608,7 +633,7 @@ struct QuantileListOperation : public QuantileOperation {\n \t\tidx_t lower = 0;\n \t\tfor (const auto &q : bind_data->order) {\n \t\t\tconst auto &quantile = bind_data->quantiles[q];\n-\t\t\tInterpolator<DISCRETE> interp(quantile, state->v.size());\n+\t\t\tInterpolator<DISCRETE> interp(quantile, state->v.size(), bind_data->desc);\n \t\t\tinterp.begin = lower;\n \t\t\trdata[ridx + q] = interp.template Operation<typename STATE::SaveType, CHILD_TYPE>(v_t, result);\n \t\t\tlower = interp.FRN;\n@@ -659,7 +684,7 @@ struct QuantileListOperation : public QuantileOperation {\n \t\t\tif (included.AllValid() || included(prev.first) == included(prev.second)) {\n \t\t\t\tfor (const auto &q : bind_data->order) {\n \t\t\t\t\tconst auto &quantile = bind_data->quantiles[q];\n-\t\t\t\t\tInterpolator<DISCRETE> interp(quantile, prev_pos);\n+\t\t\t\t\tInterpolator<DISCRETE> interp(quantile, prev_pos, false);\n \t\t\t\t\tconst auto replace = CanReplace(index, data, j, interp.FRN, interp.CRN, included);\n \t\t\t\t\tif (replace < 0) {\n \t\t\t\t\t\t//\tReplacement is before this quantile, so the rest will be replaceable too.\n@@ -690,7 +715,7 @@ struct QuantileListOperation : public QuantileOperation {\n \t\t\tID indirect(data);\n \t\t\tfor (const auto &q : bind_data->order) {\n \t\t\t\tconst auto &quantile = bind_data->quantiles[q];\n-\t\t\t\tInterpolator<DISCRETE> interp(quantile, state->pos);\n+\t\t\t\tInterpolator<DISCRETE> interp(quantile, state->pos, false);\n \t\t\t\tif (replaceable.first <= interp.FRN && interp.CRN <= replaceable.second) {\n \t\t\t\t\trdata[lentry.offset + q] = interp.template Replace<idx_t, CHILD_TYPE, ID>(index, result, indirect);\n \t\t\t\t} else {\n@@ -963,7 +988,7 @@ struct MedianAbsoluteDeviationOperation : public QuantileOperation {\n \t\t\treturn;\n \t\t}\n \t\tusing SAVE_TYPE = typename STATE::SaveType;\n-\t\tInterpolator<false> interp(0.5, state->v.size());\n+\t\tInterpolator<false> interp(0.5, state->v.size(), false);\n \t\tconst auto med = interp.template Operation<SAVE_TYPE, MEDIAN_TYPE>(state->v.data(), result);\n \n \t\tMadAccessor<SAVE_TYPE, RESULT_TYPE, MEDIAN_TYPE> accessor(med);\n@@ -1009,7 +1034,7 @@ struct MedianAbsoluteDeviationOperation : public QuantileOperation {\n \t\t\tconst auto j = ReplaceIndex(index, frame, prev);\n \t\t\t//\tWe can only replace if the number of NULLs has not changed\n \t\t\tif (included.AllValid() || included(prev.first) == included(prev.second)) {\n-\t\t\t\tInterpolator<false> interp(q, prev_pos);\n+\t\t\t\tInterpolator<false> interp(q, prev_pos, false);\n \t\t\t\treplace = CanReplace(index, data, j, interp.FRN, interp.CRN, included);\n \t\t\t\tif (replace) {\n \t\t\t\t\tstate->pos = prev_pos;\n@@ -1025,7 +1050,7 @@ struct MedianAbsoluteDeviationOperation : public QuantileOperation {\n \t\t}\n \n \t\tif (state->pos) {\n-\t\t\tInterpolator<false> interp(q, state->pos);\n+\t\t\tInterpolator<false> interp(q, state->pos, false);\n \n \t\t\t// Compute or replace median from the first index\n \t\t\tusing ID = QuantileIndirect<INPUT_TYPE>;\n@@ -1136,8 +1161,8 @@ static double CheckQuantile(const Value &quantile_val) {\n \t\tthrow BinderException(\"QUANTILE parameter cannot be NULL\");\n \t}\n \tauto quantile = quantile_val.GetValue<double>();\n-\tif (quantile < 0 || quantile > 1) {\n-\t\tthrow BinderException(\"QUANTILE can only take parameters in the range [0, 1]\");\n+\tif (quantile < -1 || quantile > 1) {\n+\t\tthrow BinderException(\"QUANTILE can only take parameters in the range [-1, 1]\");\n \t}\n \n \treturn quantile;\ndiff --git a/src/planner/binder/expression/bind_aggregate_expression.cpp b/src/planner/binder/expression/bind_aggregate_expression.cpp\nindex 044c41c5b98a..6dfcc0167dec 100644\n--- a/src/planner/binder/expression/bind_aggregate_expression.cpp\n+++ b/src/planner/binder/expression/bind_aggregate_expression.cpp\n@@ -16,7 +16,20 @@\n \n namespace duckdb {\n \n-static void InvertPercentileFractions(ClientContext &context, unique_ptr<ParsedExpression> &fractions) {\n+static Value ValidatePercentileFraction(const Value &element_val, const bool desc) {\n+\tif (element_val.IsNull()) {\n+\t\treturn element_val;\n+\t}\n+\n+\tconst auto frac = element_val.GetValue<double>();\n+\tif (frac < 0 || frac > 1) {\n+\t\tthrow BinderException(\"PERCENTILEs can only take parameters in the range [0, 1]\");\n+\t}\n+\n+\treturn desc ? Value::DOUBLE(-frac) : element_val;\n+}\n+\n+static void NegatePercentileFractions(ClientContext &context, unique_ptr<ParsedExpression> &fractions, bool desc) {\n \tD_ASSERT(fractions.get());\n \tD_ASSERT(fractions->expression_class == ExpressionClass::BOUND_EXPRESSION);\n \tauto &bound = (BoundExpression &)*fractions;\n@@ -29,17 +42,11 @@ static void InvertPercentileFractions(ClientContext &context, unique_ptr<ParsedE\n \tif (value.type().id() == LogicalTypeId::LIST) {\n \t\tvector<Value> values;\n \t\tfor (const auto &element_val : ListValue::GetChildren(value)) {\n-\t\t\tif (element_val.IsNull()) {\n-\t\t\t\tvalues.push_back(element_val);\n-\t\t\t} else {\n-\t\t\t\tvalues.push_back(Value::DOUBLE(1 - element_val.GetValue<double>()));\n-\t\t\t}\n+\t\t\tvalues.push_back(ValidatePercentileFraction(element_val, desc));\n \t\t}\n \t\tbound.expr = make_unique<BoundConstantExpression>(Value::LIST(values));\n-\t} else if (value.IsNull()) {\n-\t\tbound.expr = make_unique<BoundConstantExpression>(value);\n \t} else {\n-\t\tbound.expr = make_unique<BoundConstantExpression>(Value::DOUBLE(1 - value.GetValue<double>()));\n+\t\tbound.expr = make_unique<BoundConstantExpression>(ValidatePercentileFraction(value, desc));\n \t}\n }\n \n@@ -58,7 +65,7 @@ BindResult SelectBinder::BindAggregate(FunctionExpression &aggr, AggregateFuncti\n \t// Handle ordered-set aggregates by moving the single ORDER BY expression to the front of the children.\n \t//\thttps://www.postgresql.org/docs/current/functions-aggregate.html#FUNCTIONS-ORDEREDSET-TABLE\n \tbool ordered_set_agg = false;\n-\tbool invert_fractions = false;\n+\tbool negate_fractions = false;\n \tif (aggr.order_bys && aggr.order_bys->orders.size() == 1) {\n \t\tconst auto &func_name = aggr.function_name;\n \t\tordered_set_agg = (func_name == \"quantile_cont\" || func_name == \"quantile_disc\" || func_name == \"mode\");\n@@ -68,15 +75,15 @@ BindResult SelectBinder::BindAggregate(FunctionExpression &aggr, AggregateFuncti\n \t\t\tconst auto &order = aggr.order_bys->orders[0];\n \t\t\tconst auto sense =\n \t\t\t    (order.type == OrderType::ORDER_DEFAULT) ? config.options.default_order_type : order.type;\n-\t\t\tinvert_fractions = (sense == OrderType::DESCENDING);\n+\t\t\tnegate_fractions = (sense == OrderType::DESCENDING);\n \t\t}\n \t}\n \n \tfor (auto &child : aggr.children) {\n \t\taggregate_binder.BindChild(child, 0, error);\n-\t\t// We have to invert the fractions for PERCENTILE_XXXX DESC\n-\t\tif (error.empty() && invert_fractions) {\n-\t\t\tInvertPercentileFractions(context, child);\n+\t\t// We have to negate the fractions for PERCENTILE_XXXX DESC\n+\t\tif (error.empty() && ordered_set_agg) {\n+\t\t\tNegatePercentileFractions(context, child, negate_fractions);\n \t\t}\n \t}\n \ndiff --git a/tools/rpkg/CMakeLists.txt b/tools/rpkg/CMakeLists.txt\nindex c4ad9e79788c..9012eff786a7 100644\n--- a/tools/rpkg/CMakeLists.txt\n+++ b/tools/rpkg/CMakeLists.txt\n@@ -31,8 +31,10 @@ add_library(\n   src/statement.cpp\n   src/register.cpp\n   src/scan.cpp\n+  src/transform.cpp\n   src/utils.cpp\n   src/altrep.cpp\n+  src/reltoaltrep.cpp\n   src/relational.cpp\n   src/types.cpp)\n target_link_libraries(duckdb_r_shlib duckdb ${DUCKDB_EXTRA_LINK_FLAGS}\ndiff --git a/tools/rpkg/NAMESPACE b/tools/rpkg/NAMESPACE\nindex c2da22dc1c2e..04c83a5ad411 100644\n--- a/tools/rpkg/NAMESPACE\n+++ b/tools/rpkg/NAMESPACE\n@@ -19,23 +19,7 @@ export(duckdb_register_arrow)\n export(duckdb_shutdown)\n export(duckdb_unregister)\n export(duckdb_unregister_arrow)\n-export(expr_constant)\n-export(expr_function)\n-export(expr_reference)\n-export(expr_set_alias)\n-export(expr_tostring)\n export(read_csv_duckdb)\n-export(rel_aggregate)\n-export(rel_alias)\n-export(rel_distinct)\n-export(rel_explain)\n-export(rel_filter)\n-export(rel_from_df)\n-export(rel_inner_join)\n-export(rel_order)\n-export(rel_project)\n-export(rel_set_alias)\n-export(rel_sql)\n export(simulate_duckdb)\n export(translate_duckdb)\n exportClasses(duckdb_connection)\ndiff --git a/tools/rpkg/R/cpp11.R b/tools/rpkg/R/cpp11.R\nindex 23a4a8337e0d..3ab0aa6e01a7 100644\n--- a/tools/rpkg/R/cpp11.R\n+++ b/tools/rpkg/R/cpp11.R\n@@ -52,8 +52,8 @@ rapi_expr_tostring <- function(expr) {\n   .Call(`_duckdb_rapi_expr_tostring`, expr)\n }\n \n-rapi_rel_from_df <- function(con, df) {\n-  .Call(`_duckdb_rapi_rel_from_df`, con, df)\n+rapi_rel_from_df <- function(con, df, experimental) {\n+  .Call(`_duckdb_rapi_rel_from_df`, con, df, experimental)\n }\n \n rapi_rel_filter <- function(rel, exprs) {\n@@ -112,6 +112,18 @@ rapi_rel_names <- function(rel) {\n   .Call(`_duckdb_rapi_rel_names`, rel)\n }\n \n+rapi_rel_to_altrep <- function(rel) {\n+  .Call(`_duckdb_rapi_rel_to_altrep`, rel)\n+}\n+\n+rapi_rel_from_altrep_df <- function(df) {\n+  .Call(`_duckdb_rapi_rel_from_altrep_df`, df)\n+}\n+\n+rapi_df_is_materialized <- function(df) {\n+  .Call(`_duckdb_rapi_df_is_materialized`, df)\n+}\n+\n rapi_release <- function(stmt) {\n   invisible(.Call(`_duckdb_rapi_release`, stmt))\n }\ndiff --git a/tools/rpkg/R/relational.R b/tools/rpkg/R/relational.R\nindex dd56b844390a..2ab18f45ea1c 100644\n--- a/tools/rpkg/R/relational.R\n+++ b/tools/rpkg/R/relational.R\n@@ -1,12 +1,10 @@\n-# these wrappers are a bit annoying, maybe there's a way around. Kirill?\n-\n # expressions\n \n #' Create a column reference expression\n #' @param name the column name to be referenced\n #' @param table the optional table name or a relation object to be referenced\n #' @return a column reference expression\n-#' @export\n+#' @noRd\n #' @examples\n #' col_ref_expr <- expr_reference(\"some_column_name\")\n #' col_ref_expr2 <- expr_reference(\"some_column_name\", \"some_table_name\")\n@@ -20,7 +18,7 @@ expr_reference <- function(name, table = \"\") {\n #' Create a constant expression\n #' @param val the constant value\n #' @return a constant expression\n-#' @export\n+#' @noRd\n #' @examples\n #' const_int_expr <- expr_constant(42)\n #' const_str_expr <- expr_constant(\"Hello, World\")\n@@ -30,7 +28,7 @@ expr_constant <- rapi_expr_constant\n #' @param name the function name\n #' @param args the a list of expressions for the function arguments\n #' @return a function call expression\n-#' @export\n+#' @noRd\n #' @examples\n #' call_expr <- expr_function(\"ABS\", list(expr_constant(-42)))\n expr_function <- rapi_expr_function\n@@ -38,7 +36,7 @@ expr_function <- rapi_expr_function\n #' Convert an expression to a string for debugging purposes\n #' @param expr the expression\n #' @return a string representation of the expression\n-#' @export\n+#' @noRd\n #' @examples\n #' expr_str <- expr_tostring(expr_constant(42))\n expr_tostring <- rapi_expr_tostring\n@@ -46,12 +44,11 @@ expr_tostring <- rapi_expr_tostring\n #' Set the alias for an expression\n #' @param expr the expression\n #' @param alias the alias\n-#' @export\n+#' @noRd\n #' @examples\n #' expr_set_alias(expr_constant(42), \"my_alias\")\n expr_set_alias <- rapi_expr_set_alias\n \n-\n #' @export\n print.duckdb_expr <- function(x, ...) {\n     message(\"DuckDB Expression: \", expr_tostring(x))\n@@ -63,13 +60,14 @@ print.duckdb_expr <- function(x, ...) {\n #' Convert a R data.frame to a DuckDB relation object\n #' @param con a DuckDB DBI connection object\n #' @param df the data.frame\n+#' @param experimental enable experimental string handling\n #' @return the `duckdb_relation` object wrapping the data.frame\n-#' @export\n+#' @noRd\n #' @examples\n #' con <- DBI::dbConnect(duckdb())\n #' rel <- rel_from_df(con, mtcars)\n-rel_from_df <- function(con, df) {\n-    rapi_rel_from_df(con@conn_ref, as.data.frame(df))\n+rel_from_df <- function(con, df, experimental=FALSE) {\n+    rapi_rel_from_df(con@conn_ref, as.data.frame(df), experimental)\n }\n \n #' @export\n@@ -95,11 +93,22 @@ head.duckdb_relation <- function(x, n=6L, ...) {\n     rapi_rel_limit(x, n)\n }\n \n+#' Lazily retrieve the top-n rows of a DuckDB relation object\n+#' @param rel the DuckDB relation object\n+#' @param n the amount of rows to retrieve\n+#' @return the now limited `duckdb_relation` object\n+#' @noRd\n+#' @examples\n+#' con <- DBI::dbConnect(duckdb())\n+#' rel <- rel_from_df(con, mtcars)\n+#' rel2 <- rel_limit(rel, 10)\n+rel_limit <- rapi_rel_limit\n+\n #' Lazily project a DuckDB relation object\n #' @param rel the DuckDB relation object\n #' @param exprs a list of DuckDB expressions to project\n #' @return the now projected `duckdb_relation` object\n-#' @export\n+#' @noRd\n #' @examples\n #' con <- DBI::dbConnect(duckdb())\n #' rel <- rel_from_df(con, mtcars)\n@@ -110,7 +119,7 @@ rel_project <- rapi_rel_project\n #' @param rel the DuckDB relation object\n #' @param exprs a list of DuckDB expressions to filter by\n #' @return the now filtered `duckdb_relation` object\n-#' @export\n+#' @noRd\n #' @examples\n #' con <- DBI::dbConnect(duckdb())\n #' DBI::dbExecute(con, 'CREATE MACRO gt(a, b) AS a > b')\n@@ -123,7 +132,7 @@ rel_filter <- rapi_rel_filter\n #' @param groups a list of DuckDB expressions to group by\n #' @param aggregates a (optionally named) list of DuckDB expressions with aggregates to compute\n #' @return the now aggregated `duckdb_relation` object\n-#' @export\n+#' @noRd\n #' @examples\n #' con <- DBI::dbConnect(duckdb())\n #' rel <- rel_from_df(con, mtcars)\n@@ -135,7 +144,7 @@ rel_aggregate <- rapi_rel_aggregate\n #' @param rel the DuckDB relation object\n #' @param orders a list of DuckDB expressions to order by\n #' @return the now aggregated `duckdb_relation` object\n-#' @export\n+#' @noRd\n #' @examples\n #' con <- DBI::dbConnect(duckdb())\n #' rel <- rel_from_df(con, mtcars)\n@@ -147,7 +156,7 @@ rel_order <- rapi_rel_order\n #' @param right the right-hand-side DuckDB relation object\n #' @param conds a list of DuckDB expressions to use for the join\n #' @return a new `duckdb_relation` object resulting from the join\n-#' @export\n+#' @noRd\n #' @examples\n #' con <- DBI::dbConnect(duckdb())\n #' DBI::dbExecute(con, 'CREATE MACRO eq(a, b) AS a = b')\n@@ -160,7 +169,7 @@ rel_inner_join <- rapi_rel_inner_join\n #' Lazily compute a distinct result on a DuckDB relation object\n #' @param rel the input DuckDB relation object\n #' @return a new `duckdb_relation` object with distinct rows\n-#' @export\n+#' @noRd\n #' @examples\n #' con <- DBI::dbConnect(duckdb())\n #' rel <- rel_from_df(con, mtcars)\n@@ -171,7 +180,7 @@ rel_distinct <- rapi_rel_distinct\n #' @param rel the DuckDB relation object\n #' @param sql a SQL query to run, use `_` to refer back to the relation\n #' @return the now aggregated `duckdb_relation` object\n-#' @export\n+#' @noRd\n #' @examples\n #' con <- DBI::dbConnect(duckdb())\n #' rel <- rel_from_df(con, mtcars)\n@@ -180,7 +189,7 @@ rel_sql <- rapi_rel_sql\n \n #' Print the EXPLAIN output for a DuckDB relation object\n #' @param rel the DuckDB relation object\n-#' @export\n+#' @noRd\n #' @examples\n #' con <- DBI::dbConnect(duckdb())\n #' rel <- rel_from_df(con, mtcars)\n@@ -192,7 +201,7 @@ rel_explain <- function(rel) {\n \n #' Get the internal alias for a DuckDB relation object\n #' @param rel the DuckDB relation object\n-#' @export\n+#' @noRd\n #' @examples\n #' con <- DBI::dbConnect(duckdb())\n #' rel <- rel_from_df(con, mtcars)\n@@ -202,9 +211,44 @@ rel_alias <- rapi_rel_alias\n #' Set the internal alias for a DuckDB relation object\n #' @param rel the DuckDB relation object\n #' @param alias the new alias\n-#' @export\n+#' @noRd\n #' @examples\n #' con <- DBI::dbConnect(duckdb())\n #' rel <- rel_from_df(con, mtcars)\n #' rel_set_alias(rel, \"my_new_alias\")\n rel_set_alias <- rapi_rel_set_alias\n+\n+#' Transforms a relation object to a lazy data frame using altrep\n+#' @param rel the DuckDB relation object\n+#' @return a data frame\n+#' @noRd\n+#' @examples\n+#' con <- DBI::dbConnect(duckdb())\n+#' rel <- rel_from_df(con, mtcars)\n+#' print(rel_to_altrep(rel))\n+rel_to_altrep <- rapi_rel_to_altrep\n+\n+\n+#' Retrieves the data frame back from a altrep df\n+#' @param df the data frame created by rel_to_altrep\n+#' @return the relation object\n+#' @noRd\n+#' @examples\n+#' con <- DBI::dbConnect(duckdb())\n+#' rel <- rel_from_df(con, mtcars)\n+#' df = rel_to_altrep(rel)\n+#' print(rel_from_altrep_df(df))\n+rel_from_altrep_df <- rapi_rel_from_altrep_df\n+\n+#' Checks if a lazy data frame created using rel_to_altrep has been materialized yet\n+#' @param df an altrep-backed lazy data frame\n+#' @return true if materialization has happened\n+#' @noRd\n+#' @examples\n+#' con <- DBI::dbConnect(duckdb())\n+#' rel <- rel_from_df(con, mtcars)\n+#' df <- rel_to_altrep(rel)\n+#' stopifnot(!df_is_materialized(df))\n+#' str(df)\n+#' stopifnot(df_is_materialized(df))\n+df_is_materialized <- rapi_df_is_materialized\ndiff --git a/tools/rpkg/man/expr_constant.Rd b/tools/rpkg/man/expr_constant.Rd\ndeleted file mode 100644\nindex 19f2e5101cb5..000000000000\n--- a/tools/rpkg/man/expr_constant.Rd\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{expr_constant}\n-\\alias{expr_constant}\n-\\title{Create a constant expression}\n-\\usage{\n-expr_constant(val)\n-}\n-\\arguments{\n-\\item{val}{the constant value}\n-}\n-\\value{\n-a constant expression\n-}\n-\\description{\n-Create a constant expression\n-}\n-\\examples{\n-const_int_expr <- expr_constant(42)\n-const_str_expr <- expr_constant(\"Hello, World\")\n-}\ndiff --git a/tools/rpkg/man/expr_function.Rd b/tools/rpkg/man/expr_function.Rd\ndeleted file mode 100644\nindex e92805eab6cb..000000000000\n--- a/tools/rpkg/man/expr_function.Rd\n+++ /dev/null\n@@ -1,22 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{expr_function}\n-\\alias{expr_function}\n-\\title{Create a function call expression}\n-\\usage{\n-expr_function(name, args)\n-}\n-\\arguments{\n-\\item{name}{the function name}\n-\n-\\item{args}{the a list of expressions for the function arguments}\n-}\n-\\value{\n-a function call expression\n-}\n-\\description{\n-Create a function call expression\n-}\n-\\examples{\n-call_expr <- expr_function(\"ABS\", list(expr_constant(-42)))\n-}\ndiff --git a/tools/rpkg/man/expr_reference.Rd b/tools/rpkg/man/expr_reference.Rd\ndeleted file mode 100644\nindex c2fb55b23c77..000000000000\n--- a/tools/rpkg/man/expr_reference.Rd\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{expr_reference}\n-\\alias{expr_reference}\n-\\title{Create a column reference expression}\n-\\usage{\n-expr_reference(name, table = \"\")\n-}\n-\\arguments{\n-\\item{name}{the column name to be referenced}\n-\n-\\item{table}{the optional table name or a relation object to be referenced}\n-}\n-\\value{\n-a column reference expression\n-}\n-\\description{\n-Create a column reference expression\n-}\n-\\examples{\n-col_ref_expr <- expr_reference(\"some_column_name\")\n-col_ref_expr2 <- expr_reference(\"some_column_name\", \"some_table_name\")\n-}\ndiff --git a/tools/rpkg/man/expr_set_alias.Rd b/tools/rpkg/man/expr_set_alias.Rd\ndeleted file mode 100644\nindex c955551972df..000000000000\n--- a/tools/rpkg/man/expr_set_alias.Rd\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{expr_set_alias}\n-\\alias{expr_set_alias}\n-\\title{Set the alias for an expression}\n-\\usage{\n-expr_set_alias(expr, alias)\n-}\n-\\arguments{\n-\\item{expr}{the expression}\n-\n-\\item{alias}{the alias}\n-}\n-\\description{\n-Set the alias for an expression\n-}\n-\\examples{\n-expr_set_alias(expr_constant(42), \"my_alias\")\n-}\ndiff --git a/tools/rpkg/man/expr_tostring.Rd b/tools/rpkg/man/expr_tostring.Rd\ndeleted file mode 100644\nindex 511d6e194015..000000000000\n--- a/tools/rpkg/man/expr_tostring.Rd\n+++ /dev/null\n@@ -1,20 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{expr_tostring}\n-\\alias{expr_tostring}\n-\\title{Convert an expression to a string for debugging purposes}\n-\\usage{\n-expr_tostring(expr)\n-}\n-\\arguments{\n-\\item{expr}{the expression}\n-}\n-\\value{\n-a string representation of the expression\n-}\n-\\description{\n-Convert an expression to a string for debugging purposes\n-}\n-\\examples{\n-expr_str <- expr_tostring(expr_constant(42))\n-}\ndiff --git a/tools/rpkg/man/rel_aggregate.Rd b/tools/rpkg/man/rel_aggregate.Rd\ndeleted file mode 100644\nindex dc0ee4708250..000000000000\n--- a/tools/rpkg/man/rel_aggregate.Rd\n+++ /dev/null\n@@ -1,27 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{rel_aggregate}\n-\\alias{rel_aggregate}\n-\\title{Lazily aggregate a DuckDB relation object}\n-\\usage{\n-rel_aggregate(rel, groups, aggregates)\n-}\n-\\arguments{\n-\\item{rel}{the DuckDB relation object}\n-\n-\\item{groups}{a list of DuckDB expressions to group by}\n-\n-\\item{aggregates}{a (optionally named) list of DuckDB expressions with aggregates to compute}\n-}\n-\\value{\n-the now aggregated \\code{duckdb_relation} object\n-}\n-\\description{\n-Lazily aggregate a DuckDB relation object\n-}\n-\\examples{\n-con <- DBI::dbConnect(duckdb())\n-rel <- rel_from_df(con, mtcars)\n-aggrs <- list(avg_hp = expr_function(\"avg\", list(expr_reference(\"hp\"))))\n-rel2 <- rel_aggregate(rel, list(expr_reference(\"cyl\")), aggrs)\n-}\ndiff --git a/tools/rpkg/man/rel_alias.Rd b/tools/rpkg/man/rel_alias.Rd\ndeleted file mode 100644\nindex 927851b4c705..000000000000\n--- a/tools/rpkg/man/rel_alias.Rd\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{rel_alias}\n-\\alias{rel_alias}\n-\\title{Get the internal alias for a DuckDB relation object}\n-\\usage{\n-rel_alias(rel)\n-}\n-\\arguments{\n-\\item{rel}{the DuckDB relation object}\n-}\n-\\description{\n-Get the internal alias for a DuckDB relation object\n-}\n-\\examples{\n-con <- DBI::dbConnect(duckdb())\n-rel <- rel_from_df(con, mtcars)\n-rel_alias(rel)\n-}\ndiff --git a/tools/rpkg/man/rel_distinct.Rd b/tools/rpkg/man/rel_distinct.Rd\ndeleted file mode 100644\nindex 2547f5b7a2f9..000000000000\n--- a/tools/rpkg/man/rel_distinct.Rd\n+++ /dev/null\n@@ -1,22 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{rel_distinct}\n-\\alias{rel_distinct}\n-\\title{Lazily compute a distinct result on a DuckDB relation object}\n-\\usage{\n-rel_distinct(rel)\n-}\n-\\arguments{\n-\\item{rel}{the input DuckDB relation object}\n-}\n-\\value{\n-a new \\code{duckdb_relation} object with distinct rows\n-}\n-\\description{\n-Lazily compute a distinct result on a DuckDB relation object\n-}\n-\\examples{\n-con <- DBI::dbConnect(duckdb())\n-rel <- rel_from_df(con, mtcars)\n-rel2 <- rel_distinct(rel)\n-}\ndiff --git a/tools/rpkg/man/rel_explain.Rd b/tools/rpkg/man/rel_explain.Rd\ndeleted file mode 100644\nindex 1d0a7c8bbc4d..000000000000\n--- a/tools/rpkg/man/rel_explain.Rd\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{rel_explain}\n-\\alias{rel_explain}\n-\\title{Print the EXPLAIN output for a DuckDB relation object}\n-\\usage{\n-rel_explain(rel)\n-}\n-\\arguments{\n-\\item{rel}{the DuckDB relation object}\n-}\n-\\description{\n-Print the EXPLAIN output for a DuckDB relation object\n-}\n-\\examples{\n-con <- DBI::dbConnect(duckdb())\n-rel <- rel_from_df(con, mtcars)\n-rel_explain(rel)\n-}\ndiff --git a/tools/rpkg/man/rel_filter.Rd b/tools/rpkg/man/rel_filter.Rd\ndeleted file mode 100644\nindex b0b2cf35713f..000000000000\n--- a/tools/rpkg/man/rel_filter.Rd\n+++ /dev/null\n@@ -1,25 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{rel_filter}\n-\\alias{rel_filter}\n-\\title{Lazily filter a DuckDB relation object}\n-\\usage{\n-rel_filter(rel, exprs)\n-}\n-\\arguments{\n-\\item{rel}{the DuckDB relation object}\n-\n-\\item{exprs}{a list of DuckDB expressions to filter by}\n-}\n-\\value{\n-the now filtered \\code{duckdb_relation} object\n-}\n-\\description{\n-Lazily filter a DuckDB relation object\n-}\n-\\examples{\n-con <- DBI::dbConnect(duckdb())\n-DBI::dbExecute(con, 'CREATE MACRO gt(a, b) AS a > b')\n-rel <- rel_from_df(con, mtcars)\n-rel2 <- rel_filter(rel, list(expr_function(\"gt\", list(expr_reference(\"cyl\"), expr_constant(\"6\")))))\n-}\ndiff --git a/tools/rpkg/man/rel_from_df.Rd b/tools/rpkg/man/rel_from_df.Rd\ndeleted file mode 100644\nindex 994a108a0971..000000000000\n--- a/tools/rpkg/man/rel_from_df.Rd\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{rel_from_df}\n-\\alias{rel_from_df}\n-\\title{Convert a R data.frame to a DuckDB relation object}\n-\\usage{\n-rel_from_df(con, df)\n-}\n-\\arguments{\n-\\item{con}{a DuckDB DBI connection object}\n-\n-\\item{df}{the data.frame}\n-}\n-\\value{\n-the \\code{duckdb_relation} object wrapping the data.frame\n-}\n-\\description{\n-Convert a R data.frame to a DuckDB relation object\n-}\n-\\examples{\n-con <- DBI::dbConnect(duckdb())\n-rel <- rel_from_df(con, mtcars)\n-}\ndiff --git a/tools/rpkg/man/rel_inner_join.Rd b/tools/rpkg/man/rel_inner_join.Rd\ndeleted file mode 100644\nindex 48d7b8fd3a94..000000000000\n--- a/tools/rpkg/man/rel_inner_join.Rd\n+++ /dev/null\n@@ -1,29 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{rel_inner_join}\n-\\alias{rel_inner_join}\n-\\title{Lazily INNER join two DuckDB relation objects}\n-\\usage{\n-rel_inner_join(left, right, conds)\n-}\n-\\arguments{\n-\\item{left}{the left-hand-side DuckDB relation object}\n-\n-\\item{right}{the right-hand-side DuckDB relation object}\n-\n-\\item{conds}{a list of DuckDB expressions to use for the join}\n-}\n-\\value{\n-a new \\code{duckdb_relation} object resulting from the join\n-}\n-\\description{\n-Lazily INNER join two DuckDB relation objects\n-}\n-\\examples{\n-con <- DBI::dbConnect(duckdb())\n-DBI::dbExecute(con, 'CREATE MACRO eq(a, b) AS a = b')\n-left <- rel_from_df(con, mtcars)\n-right <- rel_from_df(con, mtcars)\n-cond <- list(expr_function(\"eq\", list(expr_reference(\"cyl\", left), expr_reference(\"cyl\", right))))\n-rel2 <- rel_inner_join(left, right, cond)\n-}\ndiff --git a/tools/rpkg/man/rel_order.Rd b/tools/rpkg/man/rel_order.Rd\ndeleted file mode 100644\nindex 51780dd71ea7..000000000000\n--- a/tools/rpkg/man/rel_order.Rd\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{rel_order}\n-\\alias{rel_order}\n-\\title{Lazily reorder a DuckDB relation object}\n-\\usage{\n-rel_order(rel, orders)\n-}\n-\\arguments{\n-\\item{rel}{the DuckDB relation object}\n-\n-\\item{orders}{a list of DuckDB expressions to order by}\n-}\n-\\value{\n-the now aggregated \\code{duckdb_relation} object\n-}\n-\\description{\n-Lazily reorder a DuckDB relation object\n-}\n-\\examples{\n-con <- DBI::dbConnect(duckdb())\n-rel <- rel_from_df(con, mtcars)\n-rel2 <- rel_order(rel, list(expr_reference(\"hp\")))\n-}\ndiff --git a/tools/rpkg/man/rel_project.Rd b/tools/rpkg/man/rel_project.Rd\ndeleted file mode 100644\nindex 16087ecbdc39..000000000000\n--- a/tools/rpkg/man/rel_project.Rd\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{rel_project}\n-\\alias{rel_project}\n-\\title{Lazily project a DuckDB relation object}\n-\\usage{\n-rel_project(rel, exprs)\n-}\n-\\arguments{\n-\\item{rel}{the DuckDB relation object}\n-\n-\\item{exprs}{a list of DuckDB expressions to project}\n-}\n-\\value{\n-the now projected \\code{duckdb_relation} object\n-}\n-\\description{\n-Lazily project a DuckDB relation object\n-}\n-\\examples{\n-con <- DBI::dbConnect(duckdb())\n-rel <- rel_from_df(con, mtcars)\n-rel2 <- rel_project(rel, list(expr_reference(\"cyl\"), expr_reference(\"disp\")))\n-}\ndiff --git a/tools/rpkg/man/rel_set_alias.Rd b/tools/rpkg/man/rel_set_alias.Rd\ndeleted file mode 100644\nindex 7de4504d7e57..000000000000\n--- a/tools/rpkg/man/rel_set_alias.Rd\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{rel_set_alias}\n-\\alias{rel_set_alias}\n-\\title{Set the internal alias for a DuckDB relation object}\n-\\usage{\n-rel_set_alias(rel, alias)\n-}\n-\\arguments{\n-\\item{rel}{the DuckDB relation object}\n-\n-\\item{alias}{the new alias}\n-}\n-\\description{\n-Set the internal alias for a DuckDB relation object\n-}\n-\\examples{\n-con <- DBI::dbConnect(duckdb())\n-rel <- rel_from_df(con, mtcars)\n-rel_set_alias(rel, \"my_new_alias\")\n-}\ndiff --git a/tools/rpkg/man/rel_sql.Rd b/tools/rpkg/man/rel_sql.Rd\ndeleted file mode 100644\nindex 7f9f52a23a78..000000000000\n--- a/tools/rpkg/man/rel_sql.Rd\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-% Generated by roxygen2: do not edit by hand\n-% Please edit documentation in R/relational.R\n-\\name{rel_sql}\n-\\alias{rel_sql}\n-\\title{Run a SQL query on a DuckDB relation object}\n-\\usage{\n-rel_sql(rel, sql)\n-}\n-\\arguments{\n-\\item{rel}{the DuckDB relation object}\n-\n-\\item{sql}{a SQL query to run, use \\verb{_} to refer back to the relation}\n-}\n-\\value{\n-the now aggregated \\code{duckdb_relation} object\n-}\n-\\description{\n-Run a SQL query on a DuckDB relation object\n-}\n-\\examples{\n-con <- DBI::dbConnect(duckdb())\n-rel <- rel_from_df(con, mtcars)\n-rel2 <- rel_sql(rel, \"SELECT hp, cyl FROM _ WHERE hp > 100\")\n-}\ndiff --git a/tools/rpkg/src/Makevars.in b/tools/rpkg/src/Makevars.in\nindex 1ff05a615415..1db5587f0756 100644\n--- a/tools/rpkg/src/Makevars.in\n+++ b/tools/rpkg/src/Makevars.in\n@@ -1,4 +1,4 @@\n CXX_STD = CXX11\n PKG_CPPFLAGS = -Iinclude -I../inst/include -DDUCKDB_DISABLE_PRINT {{ INCLUDES }}\n-OBJECTS=database.o connection.o statement.o register.o relational.o scan.o utils.o altrep.o types.o cpp11.o {{ SOURCES }}\n+OBJECTS=database.o connection.o statement.o register.o relational.o scan.o transform.o utils.o altrep.o reltoaltrep.o types.o cpp11.o {{ SOURCES }}\n PKG_LIBS={{ LINK_FLAGS }}\ndiff --git a/tools/rpkg/src/cpp11.cpp b/tools/rpkg/src/cpp11.cpp\nindex 3890e9f1bf5b..4a50c8ec8724 100644\n--- a/tools/rpkg/src/cpp11.cpp\n+++ b/tools/rpkg/src/cpp11.cpp\n@@ -104,10 +104,10 @@ extern \"C\" SEXP _duckdb_rapi_expr_tostring(SEXP expr) {\n   END_CPP11\n }\n // relational.cpp\n-SEXP rapi_rel_from_df(duckdb::conn_eptr_t con, data_frame df);\n-extern \"C\" SEXP _duckdb_rapi_rel_from_df(SEXP con, SEXP df) {\n+SEXP rapi_rel_from_df(duckdb::conn_eptr_t con, data_frame df, bool experimental);\n+extern \"C\" SEXP _duckdb_rapi_rel_from_df(SEXP con, SEXP df, SEXP experimental) {\n   BEGIN_CPP11\n-    return cpp11::as_sexp(rapi_rel_from_df(cpp11::as_cpp<cpp11::decay_t<duckdb::conn_eptr_t>>(con), cpp11::as_cpp<cpp11::decay_t<data_frame>>(df)));\n+    return cpp11::as_sexp(rapi_rel_from_df(cpp11::as_cpp<cpp11::decay_t<duckdb::conn_eptr_t>>(con), cpp11::as_cpp<cpp11::decay_t<data_frame>>(df), cpp11::as_cpp<cpp11::decay_t<bool>>(experimental)));\n   END_CPP11\n }\n // relational.cpp\n@@ -208,6 +208,27 @@ extern \"C\" SEXP _duckdb_rapi_rel_names(SEXP rel) {\n     return cpp11::as_sexp(rapi_rel_names(cpp11::as_cpp<cpp11::decay_t<duckdb::rel_extptr_t>>(rel)));\n   END_CPP11\n }\n+// reltoaltrep.cpp\n+SEXP rapi_rel_to_altrep(duckdb::rel_extptr_t rel);\n+extern \"C\" SEXP _duckdb_rapi_rel_to_altrep(SEXP rel) {\n+  BEGIN_CPP11\n+    return cpp11::as_sexp(rapi_rel_to_altrep(cpp11::as_cpp<cpp11::decay_t<duckdb::rel_extptr_t>>(rel)));\n+  END_CPP11\n+}\n+// reltoaltrep.cpp\n+SEXP rapi_rel_from_altrep_df(SEXP df);\n+extern \"C\" SEXP _duckdb_rapi_rel_from_altrep_df(SEXP df) {\n+  BEGIN_CPP11\n+    return cpp11::as_sexp(rapi_rel_from_altrep_df(cpp11::as_cpp<cpp11::decay_t<SEXP>>(df)));\n+  END_CPP11\n+}\n+// reltoaltrep.cpp\n+bool rapi_df_is_materialized(SEXP df);\n+extern \"C\" SEXP _duckdb_rapi_df_is_materialized(SEXP df) {\n+  BEGIN_CPP11\n+    return cpp11::as_sexp(rapi_df_is_materialized(cpp11::as_cpp<cpp11::decay_t<SEXP>>(df)));\n+  END_CPP11\n+}\n // statement.cpp\n void rapi_release(duckdb::stmt_eptr_t stmt);\n extern \"C\" SEXP _duckdb_rapi_release(SEXP stmt) {\n@@ -284,6 +305,7 @@ extern \"C\" {\n static const R_CallMethodDef CallEntries[] = {\n     {\"_duckdb_rapi_bind\",               (DL_FUNC) &_duckdb_rapi_bind,               4},\n     {\"_duckdb_rapi_connect\",            (DL_FUNC) &_duckdb_rapi_connect,            1},\n+    {\"_duckdb_rapi_df_is_materialized\", (DL_FUNC) &_duckdb_rapi_df_is_materialized, 1},\n     {\"_duckdb_rapi_disconnect\",         (DL_FUNC) &_duckdb_rapi_disconnect,         1},\n     {\"_duckdb_rapi_execute\",            (DL_FUNC) &_duckdb_rapi_execute,            3},\n     {\"_duckdb_rapi_execute_arrow\",      (DL_FUNC) &_duckdb_rapi_execute_arrow,      2},\n@@ -305,7 +327,8 @@ static const R_CallMethodDef CallEntries[] = {\n     {\"_duckdb_rapi_rel_distinct\",       (DL_FUNC) &_duckdb_rapi_rel_distinct,       1},\n     {\"_duckdb_rapi_rel_explain\",        (DL_FUNC) &_duckdb_rapi_rel_explain,        1},\n     {\"_duckdb_rapi_rel_filter\",         (DL_FUNC) &_duckdb_rapi_rel_filter,         2},\n-    {\"_duckdb_rapi_rel_from_df\",        (DL_FUNC) &_duckdb_rapi_rel_from_df,        2},\n+    {\"_duckdb_rapi_rel_from_altrep_df\", (DL_FUNC) &_duckdb_rapi_rel_from_altrep_df, 1},\n+    {\"_duckdb_rapi_rel_from_df\",        (DL_FUNC) &_duckdb_rapi_rel_from_df,        3},\n     {\"_duckdb_rapi_rel_inner_join\",     (DL_FUNC) &_duckdb_rapi_rel_inner_join,     3},\n     {\"_duckdb_rapi_rel_limit\",          (DL_FUNC) &_duckdb_rapi_rel_limit,          2},\n     {\"_duckdb_rapi_rel_names\",          (DL_FUNC) &_duckdb_rapi_rel_names,          1},\n@@ -313,6 +336,7 @@ static const R_CallMethodDef CallEntries[] = {\n     {\"_duckdb_rapi_rel_project\",        (DL_FUNC) &_duckdb_rapi_rel_project,        2},\n     {\"_duckdb_rapi_rel_set_alias\",      (DL_FUNC) &_duckdb_rapi_rel_set_alias,      2},\n     {\"_duckdb_rapi_rel_sql\",            (DL_FUNC) &_duckdb_rapi_rel_sql,            2},\n+    {\"_duckdb_rapi_rel_to_altrep\",      (DL_FUNC) &_duckdb_rapi_rel_to_altrep,      1},\n     {\"_duckdb_rapi_rel_to_df\",          (DL_FUNC) &_duckdb_rapi_rel_to_df,          1},\n     {\"_duckdb_rapi_rel_tostring\",       (DL_FUNC) &_duckdb_rapi_rel_tostring,       1},\n     {\"_duckdb_rapi_release\",            (DL_FUNC) &_duckdb_rapi_release,            1},\n@@ -325,10 +349,12 @@ static const R_CallMethodDef CallEntries[] = {\n }\n \n void AltrepString_Initialize(DllInfo* dll);\n+void RelToAltrep_Initialize(DllInfo* dll);\n \n extern \"C\" attribute_visible void R_init_duckdb(DllInfo* dll){\n   R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);\n   R_useDynamicSymbols(dll, FALSE);\n   AltrepString_Initialize(dll);\n+  RelToAltrep_Initialize(dll);\n   R_forceSymbols(dll, TRUE);\n }\ndiff --git a/tools/rpkg/src/include/rapi.hpp b/tools/rpkg/src/include/rapi.hpp\nindex 84d8d02d4fac..5628e47952f8 100644\n--- a/tools/rpkg/src/include/rapi.hpp\n+++ b/tools/rpkg/src/include/rapi.hpp\n@@ -113,6 +113,7 @@ struct RStrings {\n \tSEXP ImportSchema_sym;\n \tSEXP ImportRecordBatch_sym;\n \tSEXP ImportRecordBatchReader_sym;\n+\tSEXP materialize_sym;\n \n \tstatic const RStrings &get() {\n \t\t// On demand\n@@ -159,3 +160,8 @@ SEXP rapi_execute_arrow(duckdb::rqry_eptr_t, int);\n SEXP rapi_record_batch(duckdb::rqry_eptr_t, int);\n \n cpp11::r_string rapi_ptr_to_str(SEXP extptr);\n+\n+void duckdb_r_transform(duckdb::Vector &src_vec, SEXP &dest, duckdb::idx_t dest_offset, duckdb::idx_t n,\n+                        bool integer64);\n+SEXP duckdb_r_allocate(const duckdb::LogicalType &type, duckdb::RProtector &r_varvalue, duckdb::idx_t nrows);\n+void duckdb_r_decorate(const duckdb::LogicalType &type, SEXP &dest, bool integer64);\ndiff --git a/tools/rpkg/src/include/reltoaltrep.hpp b/tools/rpkg/src/include/reltoaltrep.hpp\nnew file mode 100644\nindex 000000000000..fed7006adf33\n--- /dev/null\n+++ b/tools/rpkg/src/include/reltoaltrep.hpp\n@@ -0,0 +1,22 @@\n+#pragma once\n+\n+#include \"rapi.hpp\"\n+\n+struct RelToAltrep {\n+\tstatic void Initialize(DllInfo *dll);\n+\tstatic R_xlen_t RownamesLength(SEXP x);\n+\tstatic void *RownamesDataptr(SEXP x, Rboolean writeable);\n+\tstatic Rboolean RownamesInspect(SEXP x, int pre, int deep, int pvec, void (*inspect_subtree)(SEXP, int, int, int));\n+\n+\tstatic R_xlen_t VectorLength(SEXP x);\n+\tstatic void *VectorDataptr(SEXP x, Rboolean writeable);\n+\tstatic Rboolean RelInspect(SEXP x, int pre, int deep, int pvec, void (*inspect_subtree)(SEXP, int, int, int));\n+\n+\tstatic SEXP VectorStringElt(SEXP x, R_xlen_t i);\n+\n+\tstatic R_altrep_class_t rownames_class;\n+\tstatic R_altrep_class_t logical_class;\n+\tstatic R_altrep_class_t int_class;\n+\tstatic R_altrep_class_t real_class;\n+\tstatic R_altrep_class_t string_class;\n+};\ndiff --git a/tools/rpkg/src/relational.cpp b/tools/rpkg/src/relational.cpp\nindex 51c926d44d9e..00b7af598c71 100644\n--- a/tools/rpkg/src/relational.cpp\n+++ b/tools/rpkg/src/relational.cpp\n@@ -75,7 +75,7 @@ external_pointer<T> make_external(const string &rclass, Args &&...args) {\n \n // DuckDB Relations\n \n-[[cpp11::register]] SEXP rapi_rel_from_df(duckdb::conn_eptr_t con, data_frame df) {\n+[[cpp11::register]] SEXP rapi_rel_from_df(duckdb::conn_eptr_t con, data_frame df, bool experimental) {\n \tif (!con || !con.get() || !con->conn) {\n \t\tstop(\"rel_from_df: Invalid connection\");\n \t}\n@@ -84,7 +84,7 @@ external_pointer<T> make_external(const string &rclass, Args &&...args) {\n \t}\n \n \tnamed_parameter_map_t other_params;\n-\t// other_params[\"experimental\"] = Value::BOOLEAN(true);\n+\tother_params[\"experimental\"] = Value::BOOLEAN(experimental);\n \tauto alias = StringUtil::Format(\"dataframe_%d_%d\", (uintptr_t)(SEXP)df,\n \t                                (int32_t)(NumericLimits<int32_t>::Maximum() * unif_rand()));\n \tauto rel =\ndiff --git a/tools/rpkg/src/reltoaltrep.cpp b/tools/rpkg/src/reltoaltrep.cpp\nnew file mode 100644\nindex 000000000000..f9b8dc05d6b5\n--- /dev/null\n+++ b/tools/rpkg/src/reltoaltrep.cpp\n@@ -0,0 +1,289 @@\n+#include \"rapi.hpp\"\n+#include \"typesr.hpp\"\n+#include \"reltoaltrep.hpp\"\n+\n+using namespace duckdb;\n+\n+R_altrep_class_t RelToAltrep::rownames_class;\n+R_altrep_class_t RelToAltrep::logical_class;\n+R_altrep_class_t RelToAltrep::int_class;\n+R_altrep_class_t RelToAltrep::real_class;\n+R_altrep_class_t RelToAltrep::string_class;\n+\n+void RelToAltrep::Initialize(DllInfo *dll) {\n+\t// this is a string so setting row names will not lead to materialization\n+\trownames_class = R_make_altinteger_class(\"reltoaltrep_rownames_class\", \"duckdb\", dll);\n+\tlogical_class = R_make_altlogical_class(\"reltoaltrep_logical_class\", \"duckdb\", dll);\n+\tint_class = R_make_altinteger_class(\"reltoaltrep_int_class\", \"duckdb\", dll);\n+\treal_class = R_make_altreal_class(\"reltoaltrep_real_class\", \"duckdb\", dll);\n+\tstring_class = R_make_altstring_class(\"reltoaltrep_string_class\", \"duckdb\", dll);\n+\n+\tR_set_altrep_Inspect_method(rownames_class, RownamesInspect);\n+\tR_set_altrep_Inspect_method(logical_class, RelInspect);\n+\tR_set_altrep_Inspect_method(int_class, RelInspect);\n+\tR_set_altrep_Inspect_method(real_class, RelInspect);\n+\tR_set_altrep_Inspect_method(string_class, RelInspect);\n+\n+\tR_set_altrep_Length_method(rownames_class, RownamesLength);\n+\tR_set_altrep_Length_method(logical_class, VectorLength);\n+\tR_set_altrep_Length_method(int_class, VectorLength);\n+\tR_set_altrep_Length_method(real_class, VectorLength);\n+\tR_set_altrep_Length_method(string_class, VectorLength);\n+\n+\tR_set_altvec_Dataptr_method(rownames_class, RownamesDataptr);\n+\tR_set_altvec_Dataptr_method(logical_class, VectorDataptr);\n+\tR_set_altvec_Dataptr_method(int_class, VectorDataptr);\n+\tR_set_altvec_Dataptr_method(real_class, VectorDataptr);\n+\tR_set_altvec_Dataptr_method(string_class, VectorDataptr);\n+\n+\tR_set_altstring_Elt_method(string_class, VectorStringElt);\n+}\n+\n+template <class T>\n+static T *GetFromExternalPtr(SEXP x) {\n+\tif (!x) {\n+\t\tRf_error(\"need a SEXP pointer\");\n+\t}\n+\tauto wrapper = (T *)R_ExternalPtrAddr(R_altrep_data1(x));\n+\tif (!wrapper) {\n+\t\tRf_error(\"This looks like it has been freed\");\n+\t}\n+\treturn wrapper;\n+}\n+\n+struct AltrepRelationWrapper {\n+\n+\tstatic AltrepRelationWrapper *Get(SEXP x) {\n+\t\treturn GetFromExternalPtr<AltrepRelationWrapper>(x);\n+\t}\n+\n+\tAltrepRelationWrapper(shared_ptr<Relation> rel_p) : rel(rel_p) {\n+\t}\n+\n+\tMaterializedQueryResult *GetQueryResult() {\n+\t\tif (!res) {\n+\t\t\tauto option = Rf_GetOption(RStrings::get().materialize_sym, R_BaseEnv);\n+\t\t\tif (option != R_NilValue && !Rf_isNull(option) && LOGICAL_ELT(option, 0) == true) {\n+\t\t\t\tRprintf(\"materializing:\\n%s\\n\", rel->ToString().c_str());\n+\t\t\t}\n+\t\t\tres = rel->Execute();\n+\t\t\tif (res->HasError()) {\n+\t\t\t\tRf_error(res->GetError().c_str());\n+\t\t\t}\n+\t\t\tD_ASSERT(res->type == QueryResultType::MATERIALIZED_RESULT);\n+\t\t}\n+\t\tD_ASSERT(res);\n+\t\treturn (MaterializedQueryResult *)res.get();\n+\t}\n+\n+\tshared_ptr<Relation> rel;\n+\tunique_ptr<QueryResult> res;\n+};\n+\n+struct AltrepRownamesWrapper {\n+\n+\tAltrepRownamesWrapper(shared_ptr<AltrepRelationWrapper> rel_p) : rel(rel_p) {\n+\t\trowlen_data[0] = NA_INTEGER;\n+\t}\n+\n+\tstatic AltrepRownamesWrapper *Get(SEXP x) {\n+\t\treturn GetFromExternalPtr<AltrepRownamesWrapper>(x);\n+\t}\n+\n+\tint32_t rowlen_data[2];\n+\tshared_ptr<AltrepRelationWrapper> rel;\n+};\n+\n+struct AltrepVectorWrapper {\n+\tAltrepVectorWrapper(shared_ptr<AltrepRelationWrapper> rel_p, idx_t column_index_p)\n+\t    : rel(rel_p), column_index(column_index_p) {\n+\t}\n+\n+\tstatic AltrepVectorWrapper *Get(SEXP x) {\n+\t\treturn GetFromExternalPtr<AltrepVectorWrapper>(x);\n+\t}\n+\n+\tvoid *Dataptr() {\n+\t\tif (transformed_vector.data() == R_NilValue) {\n+\t\t\tauto res = rel->GetQueryResult();\n+\t\t\tRProtector r_varvalue;\n+\t\t\ttransformed_vector = duckdb_r_allocate(res->types[column_index], r_varvalue, res->RowCount());\n+\t\t\tidx_t dest_offset = 0;\n+\t\t\tfor (auto &chunk : res->Collection().Chunks()) {\n+\t\t\t\tSEXP dest = transformed_vector.data();\n+\t\t\t\tduckdb_r_transform(chunk.data[column_index], dest, dest_offset, chunk.size(), false);\n+\t\t\t\tdest_offset += chunk.size();\n+\t\t\t}\n+\t\t}\n+\t\treturn DATAPTR(transformed_vector);\n+\t}\n+\n+\tSEXP Vector() {\n+\t\tDataptr();\n+\t\treturn transformed_vector;\n+\t}\n+\n+\tshared_ptr<AltrepRelationWrapper> rel;\n+\tidx_t column_index;\n+\tcpp11::sexp transformed_vector;\n+};\n+\n+Rboolean RelToAltrep::RownamesInspect(SEXP x, int pre, int deep, int pvec,\n+                                      void (*inspect_subtree)(SEXP, int, int, int)) {\n+\tAltrepRownamesWrapper::Get(x); // make sure this is alive\n+\tRprintf(\"DUCKDB_ALTREP_REL_ROWNAMES\\n\");\n+\treturn TRUE;\n+}\n+\n+Rboolean RelToAltrep::RelInspect(SEXP x, int pre, int deep, int pvec, void (*inspect_subtree)(SEXP, int, int, int)) {\n+\tauto wrapper = AltrepVectorWrapper::Get(x); // make sure this is alive\n+\tauto &col = wrapper->rel->rel->Columns()[wrapper->column_index];\n+\tRprintf(\"DUCKDB_ALTREP_REL_VECTOR %s (%s)\\n\", col.Name().c_str(), col.Type().ToString().c_str());\n+\treturn TRUE;\n+}\n+\n+// this allows us to set row names on a data frame with an int argument without calling INTPTR on it\n+static void install_new_attrib(SEXP vec, SEXP name, SEXP val) {\n+\tSEXP attrib_vec = ATTRIB(vec);\n+\tSEXP attrib_cell = Rf_cons(val, R_NilValue);\n+\tSET_TAG(attrib_cell, name);\n+\tSETCDR(attrib_vec, attrib_cell);\n+}\n+\n+R_xlen_t RelToAltrep::RownamesLength(SEXP x) {\n+\t// row.names vector has length 2 in the \"compact\" case which we're using\n+\t// see https://stat.ethz.ch/R-manual/R-devel/library/base/html/row.names.html\n+\treturn 2;\n+}\n+\n+void *RelToAltrep::RownamesDataptr(SEXP x, Rboolean writeable) {\n+\tauto rownames_wrapper = AltrepRownamesWrapper::Get(x);\n+\tauto row_count = rownames_wrapper->rel->GetQueryResult()->RowCount();\n+\tif (row_count > (idx_t)NumericLimits<int32_t>::Maximum()) {\n+\t\tRf_error(\"Integer overflow for row.names attribute\");\n+\t}\n+\trownames_wrapper->rowlen_data[1] = -row_count;\n+\treturn rownames_wrapper->rowlen_data;\n+}\n+\n+R_xlen_t RelToAltrep::VectorLength(SEXP x) {\n+\treturn AltrepVectorWrapper::Get(x)->rel->GetQueryResult()->RowCount();\n+}\n+\n+void *RelToAltrep::VectorDataptr(SEXP x, Rboolean writeable) {\n+\treturn AltrepVectorWrapper::Get(x)->Dataptr();\n+}\n+\n+SEXP RelToAltrep::VectorStringElt(SEXP x, R_xlen_t i) {\n+\treturn STRING_ELT(AltrepVectorWrapper::Get(x)->Vector(), i);\n+}\n+\n+static R_altrep_class_t LogicalTypeToAltrepType(const LogicalType &type) {\n+\tswitch (type.id()) {\n+\tcase LogicalTypeId::BOOLEAN:\n+\t\treturn RelToAltrep::logical_class;\n+\tcase LogicalTypeId::UTINYINT:\n+\tcase LogicalTypeId::TINYINT:\n+\tcase LogicalTypeId::SMALLINT:\n+\tcase LogicalTypeId::USMALLINT:\n+\tcase LogicalTypeId::INTEGER:\n+\tcase LogicalTypeId::ENUM:\n+\t\treturn RelToAltrep::int_class;\n+\tcase LogicalTypeId::UINTEGER:\n+\tcase LogicalTypeId::UBIGINT:\n+\tcase LogicalTypeId::BIGINT:\n+\tcase LogicalTypeId::HUGEINT:\n+\tcase LogicalTypeId::FLOAT:\n+\tcase LogicalTypeId::DOUBLE:\n+\tcase LogicalTypeId::DECIMAL:\n+\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\tcase LogicalTypeId::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\tcase LogicalTypeId::DATE:\n+\tcase LogicalTypeId::TIME:\n+\tcase LogicalTypeId::INTERVAL:\n+\t\treturn RelToAltrep::real_class;\n+\tcase LogicalTypeId::VARCHAR:\n+\tcase LogicalTypeId::UUID:\n+\t\treturn RelToAltrep::string_class;\n+\tdefault:\n+\t\tcpp11::stop(\"rel_to_altrep: Unknown column type for altrep: %s\", type.ToString().c_str());\n+\t}\n+}\n+\n+[[cpp11::register]] SEXP rapi_rel_to_altrep(duckdb::rel_extptr_t rel) {\n+\tD_ASSERT(rel && rel->rel);\n+\tauto drel = rel->rel;\n+\tauto ncols = drel->Columns().size();\n+\n+\tcpp11::writable::list data_frame(NEW_LIST(ncols));\n+\tdata_frame.attr(R_ClassSymbol) = RStrings::get().dataframe_str;\n+\tauto relation_wrapper = make_shared<AltrepRelationWrapper>(drel);\n+\tRProtector r_protector;\n+\n+\tcpp11::external_pointer<AltrepRownamesWrapper> ptr(new AltrepRownamesWrapper(relation_wrapper));\n+\tauto row_names_sexp = R_new_altrep(RelToAltrep::rownames_class, ptr, rel);\n+\tinstall_new_attrib(data_frame, R_RowNamesSymbol, row_names_sexp);\n+\tvector<string> names;\n+\tfor (auto &col : drel->Columns()) {\n+\t\tnames.push_back(col.Name());\n+\t}\n+\n+\tSET_NAMES(data_frame, StringsToSexp(names));\n+\tfor (size_t col_idx = 0; col_idx < ncols; col_idx++) {\n+\t\tauto &column_type = drel->Columns()[col_idx].Type();\n+\t\tcpp11::external_pointer<AltrepVectorWrapper> ptr(new AltrepVectorWrapper(relation_wrapper, col_idx));\n+\t\tauto vector_sexp = r_protector.Protect(R_new_altrep(LogicalTypeToAltrepType(column_type), ptr, R_NilValue));\n+\t\tduckdb_r_decorate(column_type, vector_sexp, false);\n+\t\tSET_VECTOR_ELT(data_frame, col_idx, vector_sexp);\n+\t}\n+\treturn data_frame;\n+}\n+\n+[[cpp11::register]] SEXP rapi_rel_from_altrep_df(SEXP df) {\n+\tif (!Rf_inherits(df, \"data.frame\")) {\n+\t\tRf_error(\"Not a data.frame\");\n+\t}\n+\n+\tSEXP row_names = R_NilValue;\n+\tfor (SEXP attrib = ATTRIB(df); attrib != R_NilValue; attrib = CDR(attrib)) {\n+\t\tif (TAG(attrib) == R_RowNamesSymbol) {\n+\t\t\trow_names = CAR(attrib);\n+\t\t}\n+\t}\n+\n+\tif (row_names == R_NilValue || !ALTREP(row_names)) {\n+\t\tRf_error(\"Not a 'special' data.frame\");\n+\t}\n+\tauto res = R_altrep_data2(row_names);\n+\tif (res == R_NilValue) {\n+\t\tRf_error(\"NULL in data2?\");\n+\t}\n+\treturn res;\n+}\n+\n+[[cpp11::register]] bool rapi_df_is_materialized(SEXP df) {\n+\tD_ASSERT(df);\n+\tauto first_col = VECTOR_ELT(df, 0);\n+\tif (!ALTREP(first_col)) {\n+\t\tRf_error(\"Not a lazy data frame\");\n+\t}\n+\tauto altrep_data = R_altrep_data1(first_col);\n+\tif (!altrep_data) {\n+\t\tRf_error(\"Not a lazy data frame\");\n+\t}\n+\tauto wrapper = (AltrepVectorWrapper *)R_ExternalPtrAddr(altrep_data);\n+\tif (!wrapper) {\n+\t\tRf_error(\"Invalid lazy data frame\");\n+\t}\n+\treturn wrapper->rel->res.get() != nullptr;\n+}\n+\n+// exception required as long as r-lib/decor#6 remains\n+// clang-format off\n+[[cpp11::init]] void RelToAltrep_Initialize(DllInfo* dll) {\n+\t// clang-format on\n+\tRelToAltrep::Initialize(dll);\n+}\ndiff --git a/tools/rpkg/src/scan.cpp b/tools/rpkg/src/scan.cpp\nindex 458c11006846..d7f1bfc9099a 100644\n--- a/tools/rpkg/src/scan.cpp\n+++ b/tools/rpkg/src/scan.cpp\n@@ -166,10 +166,19 @@ static unique_ptr<FunctionData> DataFrameScanBind(ClientContext &context, TableF\n \t\t\tcoldata_ptr = (data_ptr_t)INTEGER_POINTER(coldata);\n \t\t\tbreak;\n \t\tcase RType::DATE:\n-\t\tcase RType::DATE_INTEGER:\n+\t\t\tif (!IS_NUMERIC(coldata)) {\n+\t\t\t\tcpp11::stop(\"DATE should really be integer\");\n+\t\t\t}\n \t\t\tcoldata_ptr = (data_ptr_t)NUMERIC_POINTER(coldata);\n \t\t\tduckdb_col_type = LogicalType::DATE;\n \t\t\tbreak;\n+\t\tcase RType::DATE_INTEGER:\n+\t\t\tif (!IS_INTEGER(coldata)) {\n+\t\t\t\tcpp11::stop(\"DATE_INTEGER should really be integer\");\n+\t\t\t}\n+\t\t\tcoldata_ptr = (data_ptr_t)INTEGER_POINTER(coldata);\n+\t\t\tduckdb_col_type = LogicalType::DATE;\n+\t\t\tbreak;\n \t\tcase RType::BLOB:\n \t\t\tduckdb_col_type = LogicalType::BLOB;\n \t\t\tbreak;\ndiff --git a/tools/rpkg/src/statement.cpp b/tools/rpkg/src/statement.cpp\nindex 54f06e02447c..a4f03244ccde 100644\n--- a/tools/rpkg/src/statement.cpp\n+++ b/tools/rpkg/src/statement.cpp\n@@ -9,25 +9,12 @@\n #include \"duckdb/common/types/timestamp.hpp\"\n #include \"duckdb/common/arrow/arrow_wrapper.hpp\"\n #include \"duckdb/common/arrow/result_arrow_wrapper.hpp\"\n-#include \"duckdb/main/stream_query_result.hpp\"\n-#include \"duckdb/common/types/uuid.hpp\"\n \n #include \"duckdb/parser/statement/relation_statement.hpp\"\n \n using namespace duckdb;\n using namespace cpp11::literals;\n \n-// converter for primitive types\n-template <class SRC, class DEST>\n-static void VectorToR(Vector &src_vec, size_t count, void *dest, uint64_t dest_offset, DEST na_val) {\n-\tauto src_ptr = FlatVector::GetData<SRC>(src_vec);\n-\tauto &mask = FlatVector::Validity(src_vec);\n-\tauto dest_ptr = ((DEST *)dest) + dest_offset;\n-\tfor (size_t row_idx = 0; row_idx < count; row_idx++) {\n-\t\tdest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? na_val : src_ptr[row_idx];\n-\t}\n-}\n-\n [[cpp11::register]] void rapi_release(duckdb::stmt_eptr_t stmt) {\n \tauto stmt_ptr = stmt.release();\n \tif (stmt_ptr) {\n@@ -45,7 +32,7 @@ static void VectorToR(Vector &src_vec, size_t count, void *dest, uint64_t dest_o\n \tauto chunk = res->Fetch();\n \tauto blob_string = StringValue::Get(chunk->GetValue(0, 0));\n \n-\tSEXP rawval = NEW_RAW(blob_string.size());\n+\tauto rawval = NEW_RAW(blob_string.size());\n \tif (!rawval) {\n \t\tthrow std::bad_alloc();\n \t}\n@@ -189,436 +176,14 @@ static cpp11::list construct_retlist(unique_ptr<PreparedStatement> stmt, const s\n \treturn out;\n }\n \n-static SEXP allocate(const LogicalType &type, RProtector &r_varvalue, idx_t nrows) {\n-\tSEXP varvalue = NULL;\n-\tswitch (type.id()) {\n-\tcase LogicalTypeId::BOOLEAN:\n-\t\tvarvalue = r_varvalue.Protect(NEW_LOGICAL(nrows));\n-\t\tbreak;\n-\tcase LogicalTypeId::UTINYINT:\n-\tcase LogicalTypeId::TINYINT:\n-\tcase LogicalTypeId::SMALLINT:\n-\tcase LogicalTypeId::USMALLINT:\n-\tcase LogicalTypeId::INTEGER:\n-\t\tvarvalue = r_varvalue.Protect(NEW_INTEGER(nrows));\n-\t\tbreak;\n-\tcase LogicalTypeId::UINTEGER:\n-\tcase LogicalTypeId::UBIGINT:\n-\tcase LogicalTypeId::BIGINT:\n-\tcase LogicalTypeId::HUGEINT:\n-\tcase LogicalTypeId::FLOAT:\n-\tcase LogicalTypeId::DOUBLE:\n-\tcase LogicalTypeId::DECIMAL:\n-\tcase LogicalTypeId::TIMESTAMP_SEC:\n-\tcase LogicalTypeId::TIMESTAMP_MS:\n-\tcase LogicalTypeId::TIMESTAMP:\n-\tcase LogicalTypeId::TIMESTAMP_TZ:\n-\tcase LogicalTypeId::TIMESTAMP_NS:\n-\tcase LogicalTypeId::DATE:\n-\tcase LogicalTypeId::TIME:\n-\tcase LogicalTypeId::INTERVAL:\n-\t\tvarvalue = r_varvalue.Protect(NEW_NUMERIC(nrows));\n-\t\tbreak;\n-\tcase LogicalTypeId::LIST:\n-\t\tvarvalue = r_varvalue.Protect(NEW_LIST(nrows));\n-\t\tbreak;\n-\tcase LogicalTypeId::STRUCT: {\n-\t\tcpp11::writable::list dest_list;\n-\n-\t\tfor (const auto &child : StructType::GetChildTypes(type)) {\n-\t\t\tconst auto &name = child.first;\n-\t\t\tconst auto &child_type = child.second;\n-\n-\t\t\tRProtector child_protector;\n-\t\t\tauto dest_child = allocate(child_type, child_protector, nrows);\n-\t\t\tdest_list.push_back(cpp11::named_arg(name.c_str()) = std::move(dest_child));\n-\t\t}\n-\n-\t\t// Note we cannot use cpp11's data frame here as it tries to calculate the number of rows itself,\n-\t\t// but gives the wrong answer if the first column is another data frame or the struct is empty.\n-\t\tdest_list.attr(R_ClassSymbol) = RStrings::get().dataframe_str;\n-\t\tdest_list.attr(R_RowNamesSymbol) = {NA_INTEGER, -static_cast<int>(nrows)};\n-\n-\t\tvarvalue = r_varvalue.Protect(cpp11::as_sexp(dest_list));\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::JSON:\n-\tcase LogicalTypeId::VARCHAR: {\n-\t\tauto wrapper = new DuckDBAltrepStringWrapper();\n-\t\twrapper->length = nrows;\n-\t\twrapper->string_data = std::unique_ptr<string_t[]>(new string_t[nrows]);\n-\t\twrapper->mask_data = std::unique_ptr<bool[]>(new bool[nrows]);\n-\n-\t\tcpp11::external_pointer<DuckDBAltrepStringWrapper> ptr(wrapper);\n-\t\tvarvalue = r_varvalue.Protect(R_new_altrep(AltrepString::rclass, ptr, R_NilValue));\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::UUID:\n-\t\tvarvalue = r_varvalue.Protect(NEW_STRING(nrows));\n-\t\tbreak;\n-\tcase LogicalTypeId::BLOB:\n-\t\tvarvalue = r_varvalue.Protect(NEW_LIST(nrows));\n-\t\tbreak;\n-\tcase LogicalTypeId::ENUM: {\n-\t\tauto physical_type = type.InternalType();\n-\t\tif (physical_type == PhysicalType::UINT64) { // DEDUP_POINTER_ENUM\n-\t\t\tvarvalue = r_varvalue.Protect(NEW_STRING(nrows));\n-\t\t} else {\n-\t\t\tvarvalue = r_varvalue.Protect(NEW_INTEGER(nrows));\n-\t\t}\n-\t\tbreak;\n-\t}\n-\tdefault:\n-\t\tcpp11::stop(\"rapi_execute: Unknown column type for execute: %s\", type.ToString().c_str());\n-\t}\n-\tif (!varvalue) {\n-\t\tthrow std::bad_alloc();\n-\t}\n-\treturn varvalue;\n-}\n-\n-// Convert DuckDB's timestamp to R's timestamp (POSIXct). This is a represented as the number of seconds since the\n-// epoch, stored as a double.\n-template <LogicalTypeId>\n-double ConvertTimestampValue(int64_t timestamp);\n-\n-template <>\n-double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_SEC>(int64_t timestamp) {\n-\treturn static_cast<double>(timestamp);\n-}\n-\n-template <>\n-double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_MS>(int64_t timestamp) {\n-\treturn static_cast<double>(timestamp) / Interval::MSECS_PER_SEC;\n-}\n-\n-template <>\n-double ConvertTimestampValue<LogicalTypeId::TIMESTAMP>(int64_t timestamp) {\n-\treturn static_cast<double>(timestamp) / Interval::MICROS_PER_SEC;\n-}\n-\n-template <>\n-double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_TZ>(int64_t timestamp) {\n-\treturn ConvertTimestampValue<LogicalTypeId::TIMESTAMP>(timestamp);\n-}\n-\n-template <>\n-double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_NS>(int64_t timestamp) {\n-\treturn static_cast<double>(timestamp) / Interval::NANOS_PER_SEC;\n-}\n-\n-template <LogicalTypeId LT>\n-void ConvertTimestampVector(Vector &src_vec, size_t count, SEXP &dest, uint64_t dest_offset) {\n-\tauto src_data = FlatVector::GetData<int64_t>(src_vec);\n-\tauto &mask = FlatVector::Validity(src_vec);\n-\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n-\tfor (size_t row_idx = 0; row_idx < count; row_idx++) {\n-\t\tdest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? NA_REAL : ConvertTimestampValue<LT>(src_data[row_idx]);\n-\t}\n-\n-\t// some dresssup for R\n-\tSET_CLASS(dest, RStrings::get().POSIXct_POSIXt_str);\n-\tRf_setAttrib(dest, RStrings::get().tzone_sym, RStrings::get().UTC_str);\n-}\n-\n-std::once_flag nanosecond_coercion_warning;\n-\n-static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n, bool integer64) {\n-\tswitch (src_vec.GetType().id()) {\n-\tcase LogicalTypeId::BOOLEAN:\n-\t\tVectorToR<int8_t, uint32_t>(src_vec, n, LOGICAL_POINTER(dest), dest_offset, NA_LOGICAL);\n-\t\tbreak;\n-\tcase LogicalTypeId::UTINYINT:\n-\t\tVectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n-\t\tbreak;\n-\tcase LogicalTypeId::TINYINT:\n-\t\tVectorToR<int8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n-\t\tbreak;\n-\tcase LogicalTypeId::USMALLINT:\n-\t\tVectorToR<uint16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n-\t\tbreak;\n-\tcase LogicalTypeId::SMALLINT:\n-\t\tVectorToR<int16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n-\t\tbreak;\n-\tcase LogicalTypeId::INTEGER:\n-\t\tVectorToR<int32_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n-\t\tbreak;\n-\tcase LogicalTypeId::TIMESTAMP_SEC:\n-\t\tConvertTimestampVector<LogicalTypeId::TIMESTAMP_SEC>(src_vec, n, dest, dest_offset);\n-\t\tbreak;\n-\tcase LogicalTypeId::TIMESTAMP_MS:\n-\t\tConvertTimestampVector<LogicalTypeId::TIMESTAMP_MS>(src_vec, n, dest, dest_offset);\n-\t\tbreak;\n-\tcase LogicalTypeId::TIMESTAMP:\n-\t\tConvertTimestampVector<LogicalTypeId::TIMESTAMP>(src_vec, n, dest, dest_offset);\n-\t\tbreak;\n-\tcase LogicalTypeId::TIMESTAMP_TZ:\n-\t\tConvertTimestampVector<LogicalTypeId::TIMESTAMP_TZ>(src_vec, n, dest, dest_offset);\n-\t\tbreak;\n-\tcase LogicalTypeId::TIMESTAMP_NS:\n-\t\tConvertTimestampVector<LogicalTypeId::TIMESTAMP_NS>(src_vec, n, dest, dest_offset);\n-\t\tstd::call_once(nanosecond_coercion_warning, Rf_warning,\n-\t\t               \"Coercing nanoseconds to a lower resolution may result in a loss of data.\");\n-\t\tbreak;\n-\tcase LogicalTypeId::DATE: {\n-\t\tauto src_data = FlatVector::GetData<date_t>(src_vec);\n-\t\tauto &mask = FlatVector::Validity(src_vec);\n-\t\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n-\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n-\t\t\tdest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? NA_REAL : (double)int32_t(src_data[row_idx]);\n-\t\t}\n-\n-\t\t// some dresssup for R\n-\t\tSET_CLASS(dest, RStrings::get().Date_str);\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::TIME: {\n-\t\tauto src_data = FlatVector::GetData<dtime_t>(src_vec);\n-\t\tauto &mask = FlatVector::Validity(src_vec);\n-\t\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n-\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n-\t\t\tif (!mask.RowIsValid(row_idx)) {\n-\t\t\t\tdest_ptr[row_idx] = NA_REAL;\n-\t\t\t} else {\n-\t\t\t\tdest_ptr[row_idx] = src_data[row_idx].micros / Interval::MICROS_PER_SEC;\n-\t\t\t}\n-\t\t}\n-\t\tSET_CLASS(dest, RStrings::get().difftime_str);\n-\t\tRf_setAttrib(dest, RStrings::get().units_sym, RStrings::get().secs_str);\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::INTERVAL: {\n-\t\tauto src_data = FlatVector::GetData<interval_t>(src_vec);\n-\t\tauto &mask = FlatVector::Validity(src_vec);\n-\t\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n-\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n-\t\t\tif (!mask.RowIsValid(row_idx)) {\n-\t\t\t\tdest_ptr[row_idx] = NA_REAL;\n-\t\t\t} else {\n-\t\t\t\tdest_ptr[row_idx] = Interval::GetMicro(src_data[row_idx]) / Interval::MICROS_PER_SEC;\n-\t\t\t}\n-\t\t}\n-\t\tSET_CLASS(dest, RStrings::get().difftime_str);\n-\t\tRf_setAttrib(dest, RStrings::get().units_sym, RStrings::get().secs_str);\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::UINTEGER:\n-\t\tVectorToR<uint32_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n-\t\tbreak;\n-\tcase LogicalTypeId::UBIGINT:\n-\t\tif (integer64) {\n-\t\t\t// this silently loses the high bit\n-\t\t\tVectorToR<uint64_t, int64_t>(src_vec, n, NUMERIC_POINTER(dest), dest_offset,\n-\t\t\t                             NumericLimits<int64_t>::Minimum());\n-\t\t\tRf_setAttrib(dest, R_ClassSymbol, RStrings::get().integer64_str);\n-\t\t} else {\n-\t\t\tVectorToR<uint64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n-\t\t}\n-\t\tbreak;\n-\tcase LogicalTypeId::BIGINT:\n-\t\tif (integer64) {\n-\t\t\tVectorToR<int64_t, int64_t>(src_vec, n, NUMERIC_POINTER(dest), dest_offset,\n-\t\t\t                            NumericLimits<int64_t>::Minimum());\n-\t\t\tRf_setAttrib(dest, R_ClassSymbol, RStrings::get().integer64_str);\n-\t\t} else {\n-\t\t\tVectorToR<int64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n-\t\t}\n-\t\tbreak;\n-\tcase LogicalTypeId::HUGEINT: {\n-\t\tauto src_data = FlatVector::GetData<hugeint_t>(src_vec);\n-\t\tauto &mask = FlatVector::Validity(src_vec);\n-\t\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n-\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n-\t\t\tif (!mask.RowIsValid(row_idx)) {\n-\t\t\t\tdest_ptr[row_idx] = NA_REAL;\n-\t\t\t} else {\n-\t\t\t\tHugeint::TryCast(src_data[row_idx], dest_ptr[row_idx]);\n-\t\t\t}\n-\t\t}\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::DECIMAL: {\n-\t\tauto &decimal_type = src_vec.GetType();\n-\t\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n-\t\tauto dec_scale = DecimalType::GetScale(decimal_type);\n-\t\tswitch (decimal_type.InternalType()) {\n-\t\tcase PhysicalType::INT16:\n-\t\t\tRDecimalCastLoop<int16_t>(src_vec, n, dest_ptr, dec_scale);\n-\t\t\tbreak;\n-\t\tcase PhysicalType::INT32:\n-\t\t\tRDecimalCastLoop<int32_t>(src_vec, n, dest_ptr, dec_scale);\n-\t\t\tbreak;\n-\t\tcase PhysicalType::INT64:\n-\t\t\tRDecimalCastLoop<int64_t>(src_vec, n, dest_ptr, dec_scale);\n-\t\t\tbreak;\n-\t\tcase PhysicalType::INT128:\n-\t\t\tRDecimalCastLoop<hugeint_t>(src_vec, n, dest_ptr, dec_scale);\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\tthrow NotImplementedException(\"Unimplemented internal type for DECIMAL\");\n-\t\t}\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::FLOAT:\n-\t\tVectorToR<float, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n-\t\tbreak;\n-\n-\tcase LogicalTypeId::DOUBLE:\n-\t\tVectorToR<double, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n-\t\tbreak;\n-\tcase LogicalTypeId::JSON:\n-\tcase LogicalTypeId::VARCHAR: {\n-\t\tauto wrapper = (DuckDBAltrepStringWrapper *)R_ExternalPtrAddr(R_altrep_data1(dest));\n-\t\tauto src_data = FlatVector::GetData<string_t>(src_vec);\n-\t\tauto &mask = FlatVector::Validity(src_vec);\n-\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n-\t\t\tauto valid = mask.RowIsValid(row_idx);\n-\t\t\tauto dest_idx = dest_offset + row_idx;\n-\t\t\twrapper->mask_data[dest_idx] = valid;\n-\t\t\tif (valid) {\n-\t\t\t\twrapper->string_data[dest_idx] =\n-\t\t\t\t    src_data[row_idx].IsInlined() ? src_data[row_idx] : wrapper->heap.AddString(src_data[row_idx]);\n-\t\t\t}\n-\t\t}\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::LIST: {\n-\t\t// figure out the total and max element length of the list vector child\n-\t\tauto src_data = ListVector::GetData(src_vec);\n-\t\tauto &child_type = ListType::GetChildType(src_vec.GetType());\n-\t\tVector child_vector(child_type, nullptr);\n-\n-\t\t// actual loop over rows\n-\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n-\t\t\tif (!FlatVector::Validity(src_vec).RowIsValid(row_idx)) {\n-\t\t\t\tSET_ELEMENT(dest, dest_offset + row_idx, R_NilValue);\n-\t\t\t} else {\n-\t\t\t\tconst auto end = src_data[row_idx].offset + src_data[row_idx].length;\n-\t\t\t\tchild_vector.Slice(ListVector::GetEntry(src_vec), src_data[row_idx].offset, end);\n-\n-\t\t\t\tRProtector ele_prot;\n-\t\t\t\t// transform the list child vector to a single R SEXP\n-\t\t\t\tauto list_element =\n-\t\t\t\t    allocate(ListType::GetChildType(src_vec.GetType()), ele_prot, src_data[row_idx].length);\n-\t\t\t\ttransform(child_vector, list_element, 0, src_data[row_idx].length, integer64);\n-\n-\t\t\t\t// call R's own extract subset method\n-\t\t\t\tSET_ELEMENT(dest, dest_offset + row_idx, list_element);\n-\t\t\t}\n-\t\t}\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::STRUCT: {\n-\t\tconst auto &children = StructVector::GetEntries(src_vec);\n-\n-\t\tfor (size_t i = 0; i < children.size(); i++) {\n-\t\t\tconst auto &struct_child = children[i];\n-\t\t\tSEXP child_dest = VECTOR_ELT(dest, i);\n-\t\t\ttransform(*struct_child, child_dest, dest_offset, n, integer64);\n-\t\t}\n-\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::BLOB: {\n-\t\tauto src_ptr = FlatVector::GetData<string_t>(src_vec);\n-\t\tauto &mask = FlatVector::Validity(src_vec);\n-\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n-\t\t\tif (!mask.RowIsValid(row_idx)) {\n-\t\t\t\tSET_VECTOR_ELT(dest, dest_offset + row_idx, R_NilValue);\n-\t\t\t} else {\n-\t\t\t\tSEXP rawval = NEW_RAW(src_ptr[row_idx].GetSize());\n-\t\t\t\tif (!rawval) {\n-\t\t\t\t\tthrow std::bad_alloc();\n-\t\t\t\t}\n-\t\t\t\tmemcpy(RAW_POINTER(rawval), src_ptr[row_idx].GetDataUnsafe(), src_ptr[row_idx].GetSize());\n-\t\t\t\tSET_VECTOR_ELT(dest, dest_offset + row_idx, rawval);\n-\t\t\t}\n-\t\t}\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::ENUM: {\n-\t\tauto physical_type = src_vec.GetType().InternalType();\n-\t\tauto dummy = NEW_STRING(1);\n-\t\tptrdiff_t sexp_header_size = (data_ptr_t)DATAPTR(dummy) - (data_ptr_t)dummy; // don't tell anyone\n-\t\tif (physical_type == PhysicalType::UINT64) {                                 // DEDUP_POINTER_ENUM\n-\t\t\tauto src_ptr = FlatVector::GetData<uint64_t>(src_vec);\n-\t\t\tauto &mask = FlatVector::Validity(src_vec);\n-\t\t\t/* we have to use SET_STRING_ELT here because otherwise those SEXPs dont get referenced */\n-\t\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n-\t\t\t\tif (!mask.RowIsValid(row_idx)) {\n-\t\t\t\t\tSET_STRING_ELT(dest, dest_offset + row_idx, NA_STRING);\n-\t\t\t\t} else {\n-\t\t\t\t\tSET_STRING_ELT(dest, dest_offset + row_idx,\n-\t\t\t\t\t               (SEXP)((data_ptr_t)src_ptr[row_idx] - sexp_header_size));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\n-\t\tswitch (physical_type) {\n-\t\tcase PhysicalType::UINT8:\n-\t\t\tVectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n-\t\t\tbreak;\n-\n-\t\tcase PhysicalType::UINT16:\n-\t\t\tVectorToR<uint16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n-\t\t\tbreak;\n-\n-\t\tcase PhysicalType::UINT32:\n-\t\t\tVectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n-\t\t\tbreak;\n-\n-\t\tdefault:\n-\t\t\tcpp11::stop(\"rapi_execute: Unknown enum type for convert: %s\", TypeIdToString(physical_type).c_str());\n-\t\t}\n-\t\t// increment by one cause R factor offsets start at 1\n-\t\tauto dest_ptr = ((int32_t *)INTEGER_POINTER(dest)) + dest_offset;\n-\t\tfor (idx_t i = 0; i < n; i++) {\n-\t\t\tif (dest_ptr[i] == NA_INTEGER) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tdest_ptr[i]++;\n-\t\t}\n-\n-\t\tauto &str_vec = EnumType::GetValuesInsertOrder(src_vec.GetType());\n-\t\tauto size = EnumType::GetSize(src_vec.GetType());\n-\t\tvector<string> str_c_vec(size);\n-\t\tfor (idx_t i = 0; i < size; i++) {\n-\t\t\tstr_c_vec[i] = str_vec.GetValue(i).ToString();\n-\t\t}\n-\n-\t\tSET_LEVELS(dest, StringsToSexp(str_c_vec));\n-\t\tSET_CLASS(dest, RStrings::get().factor_str);\n-\t\tbreak;\n-\t}\n-\tcase LogicalTypeId::UUID: {\n-\t\tauto src_ptr = FlatVector::GetData<hugeint_t>(src_vec);\n-\t\tauto &mask = FlatVector::Validity(src_vec);\n-\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n-\t\t\tif (!mask.RowIsValid(row_idx)) {\n-\t\t\t\tSET_STRING_ELT(dest, dest_offset + row_idx, NA_STRING);\n-\t\t\t} else {\n-\t\t\t\tchar uuid_buf[UUID::STRING_SIZE];\n-\t\t\t\tUUID::ToString(src_ptr[row_idx], uuid_buf);\n-\t\t\t\tSET_STRING_ELT(dest, dest_offset + row_idx, Rf_mkCharLen(uuid_buf, UUID::STRING_SIZE));\n-\t\t\t}\n-\t\t}\n-\t\tbreak;\n-\t}\n-\tdefault:\n-\t\tcpp11::stop(\"rapi_execute: Unknown column type for convert: %s\", src_vec.GetType().ToString().c_str());\n-\t\tbreak;\n-\t}\n-}\n-\n SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result, bool integer64) {\n \t// step 2: create result data frame and allocate columns\n-\tuint32_t ncols = result->types.size();\n+\tauto ncols = result->types.size();\n \tif (ncols == 0) {\n \t\treturn Rf_ScalarReal(0); // no need for protection because no allocation can happen afterwards\n \t}\n \n-\tuint64_t nrows = result->RowCount();\n+\tauto nrows = result->RowCount();\n \n \t// Note we cannot use cpp11's data frame here as it tries to calculate the number of rows itself,\n \t// but gives the wrong answer if the first column is another data frame. So we set the necessary\n@@ -629,22 +194,22 @@ SEXP duckdb::duckdb_execute_R_impl(MaterializedQueryResult *result, bool integer\n \tSET_NAMES(data_frame, StringsToSexp(result->names));\n \n \tfor (size_t col_idx = 0; col_idx < ncols; col_idx++) {\n-\t\t// TODO move the protector to allocate?\n \t\tRProtector r_varvalue;\n-\t\tauto varvalue = allocate(result->types[col_idx], r_varvalue, nrows);\n+\t\tauto varvalue = r_varvalue.Protect(duckdb_r_allocate(result->types[col_idx], r_varvalue, nrows));\n+\t\tduckdb_r_decorate(result->types[col_idx], varvalue, integer64);\n \t\tSET_VECTOR_ELT(data_frame, col_idx, varvalue);\n \t}\n \n \t// at this point data_frame is fully allocated and the only protected SEXP\n \n \t// step 3: set values from chunks\n-\tuint64_t dest_offset = 0;\n+\tidx_t dest_offset = 0;\n \tfor (auto &chunk : result->Collection().Chunks()) {\n \t\tD_ASSERT(chunk.ColumnCount() == ncols);\n \t\tD_ASSERT(chunk.ColumnCount() == (idx_t)Rf_length(data_frame));\n \t\tfor (size_t col_idx = 0; col_idx < chunk.ColumnCount(); col_idx++) {\n \t\t\tSEXP dest = VECTOR_ELT(data_frame, col_idx);\n-\t\t\ttransform(chunk.data[col_idx], dest, dest_offset, chunk.size(), integer64);\n+\t\t\tduckdb_r_transform(chunk.data[col_idx], dest, dest_offset, chunk.size(), integer64);\n \t\t}\n \t\tdest_offset += chunk.size();\n \t}\n@@ -686,7 +251,7 @@ bool FetchArrowChunk(QueryResult *result, AppendableRList &batches_list, ArrowAr\n \tif (count == 0) {\n \t\treturn false;\n \t}\n-\tstring timezone_config = QueryResult::GetConfigTimezone(*result);\n+\tauto timezone_config = QueryResult::GetConfigTimezone(*result);\n \tArrowConverter::ToArrowSchema(&arrow_schema, result->types, result->names, timezone_config);\n \tbatches_list.PrepAppend();\n \tbatches_list.Append(cpp11::safe[Rf_eval](batch_import_from_c, arrow_namespace));\n@@ -717,7 +282,7 @@ bool FetchArrowChunk(QueryResult *result, AppendableRList &batches_list, ArrowAr\n \t}\n \n \tSET_LENGTH(batches_list.the_list, batches_list.size);\n-\tstring timezone_config = QueryResult::GetConfigTimezone(*result);\n+\tauto timezone_config = QueryResult::GetConfigTimezone(*result);\n \tArrowConverter::ToArrowSchema(&arrow_schema, result->types, result->names, timezone_config);\n \tcpp11::sexp schema_arrow_obj(cpp11::safe[Rf_eval](schema_import_from_c, arrow_namespace));\n \n@@ -733,7 +298,7 @@ bool FetchArrowChunk(QueryResult *result, AppendableRList &batches_list, ArrowAr\n \tcpp11::function getNamespace = RStrings::get().getNamespace_sym;\n \tcpp11::sexp arrow_namespace(getNamespace(RStrings::get().arrow_str));\n \n-\tResultArrowArrayStreamWrapper *result_stream = new ResultArrowArrayStreamWrapper(move(qry_res->result), chunk_size);\n+\tauto result_stream = new ResultArrowArrayStreamWrapper(move(qry_res->result), chunk_size);\n \tcpp11::sexp stream_ptr_sexp(\n \t    Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&result_stream->stream))));\n \tcpp11::sexp record_batch_reader(Rf_lang2(RStrings::get().ImportRecordBatchReader_sym, stream_ptr_sexp));\n@@ -766,7 +331,7 @@ bool FetchArrowChunk(QueryResult *result, AppendableRList &batches_list, ArrowAr\n \t\treturn query_resultsexp;\n \t} else {\n \t\tD_ASSERT(generic_result->type == QueryResultType::MATERIALIZED_RESULT);\n-\t\tMaterializedQueryResult *result = (MaterializedQueryResult *)generic_result.get();\n+\t\tauto result = (MaterializedQueryResult *)generic_result.get();\n \t\treturn duckdb_execute_R_impl(result, integer64);\n \t}\n }\ndiff --git a/tools/rpkg/src/transform.cpp b/tools/rpkg/src/transform.cpp\nnew file mode 100644\nindex 000000000000..3dcf9101bd34\n--- /dev/null\n+++ b/tools/rpkg/src/transform.cpp\n@@ -0,0 +1,505 @@\n+#include \"rapi.hpp\"\n+#include \"typesr.hpp\"\n+#include \"altrepstring.hpp\"\n+#include \"duckdb/common/types/uuid.hpp\"\n+\n+using namespace duckdb;\n+\n+// converter for primitive types\n+template <class SRC, class DEST>\n+static void VectorToR(Vector &src_vec, size_t count, void *dest, uint64_t dest_offset, DEST na_val) {\n+\tauto src_ptr = FlatVector::GetData<SRC>(src_vec);\n+\tauto &mask = FlatVector::Validity(src_vec);\n+\tauto dest_ptr = ((DEST *)dest) + dest_offset;\n+\tfor (size_t row_idx = 0; row_idx < count; row_idx++) {\n+\t\tdest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? na_val : src_ptr[row_idx];\n+\t}\n+}\n+\n+SEXP duckdb_r_allocate(const LogicalType &type, RProtector &r_varvalue, idx_t nrows) {\n+\tSEXP varvalue = NULL;\n+\tswitch (type.id()) {\n+\tcase LogicalTypeId::BOOLEAN:\n+\t\tvarvalue = r_varvalue.Protect(NEW_LOGICAL(nrows));\n+\t\tbreak;\n+\tcase LogicalTypeId::UTINYINT:\n+\tcase LogicalTypeId::TINYINT:\n+\tcase LogicalTypeId::SMALLINT:\n+\tcase LogicalTypeId::USMALLINT:\n+\tcase LogicalTypeId::INTEGER:\n+\t\tvarvalue = r_varvalue.Protect(NEW_INTEGER(nrows));\n+\t\tbreak;\n+\tcase LogicalTypeId::UINTEGER:\n+\tcase LogicalTypeId::UBIGINT:\n+\tcase LogicalTypeId::BIGINT:\n+\tcase LogicalTypeId::HUGEINT:\n+\tcase LogicalTypeId::FLOAT:\n+\tcase LogicalTypeId::DOUBLE:\n+\tcase LogicalTypeId::DECIMAL:\n+\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\tcase LogicalTypeId::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\tcase LogicalTypeId::DATE:\n+\tcase LogicalTypeId::TIME:\n+\tcase LogicalTypeId::INTERVAL:\n+\t\tvarvalue = r_varvalue.Protect(NEW_NUMERIC(nrows));\n+\t\tbreak;\n+\tcase LogicalTypeId::LIST:\n+\t\tvarvalue = r_varvalue.Protect(NEW_LIST(nrows));\n+\t\tbreak;\n+\tcase LogicalTypeId::STRUCT: {\n+\t\tcpp11::writable::list dest_list;\n+\n+\t\tfor (const auto &child : StructType::GetChildTypes(type)) {\n+\t\t\tconst auto &name = child.first;\n+\t\t\tconst auto &child_type = child.second;\n+\n+\t\t\tRProtector child_protector;\n+\t\t\tauto dest_child = duckdb_r_allocate(child_type, child_protector, nrows);\n+\t\t\tdest_list.push_back(cpp11::named_arg(name.c_str()) = std::move(dest_child));\n+\t\t}\n+\n+\t\t// Note we cannot use cpp11's data frame here as it tries to calculate the number of rows itself,\n+\t\t// but gives the wrong answer if the first column is another data frame or the struct is empty.\n+\t\tdest_list.attr(R_ClassSymbol) = RStrings::get().dataframe_str;\n+\t\tdest_list.attr(R_RowNamesSymbol) = {NA_INTEGER, -static_cast<int>(nrows)};\n+\n+\t\tvarvalue = r_varvalue.Protect(cpp11::as_sexp(dest_list));\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::JSON:\n+\tcase LogicalTypeId::VARCHAR: {\n+\t\tauto wrapper = new DuckDBAltrepStringWrapper();\n+\t\twrapper->length = nrows;\n+\t\twrapper->string_data = std::unique_ptr<string_t[]>(new string_t[nrows]);\n+\t\twrapper->mask_data = std::unique_ptr<bool[]>(new bool[nrows]);\n+\n+\t\tcpp11::external_pointer<DuckDBAltrepStringWrapper> ptr(wrapper);\n+\t\tvarvalue = r_varvalue.Protect(R_new_altrep(AltrepString::rclass, ptr, R_NilValue));\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::UUID:\n+\t\tvarvalue = r_varvalue.Protect(NEW_STRING(nrows));\n+\t\tbreak;\n+\tcase LogicalTypeId::BLOB:\n+\t\tvarvalue = r_varvalue.Protect(NEW_LIST(nrows));\n+\t\tbreak;\n+\tcase LogicalTypeId::ENUM: {\n+\t\tauto physical_type = type.InternalType();\n+\t\tif (physical_type == PhysicalType::UINT64) { // DEDUP_POINTER_ENUM\n+\t\t\tvarvalue = r_varvalue.Protect(NEW_STRING(nrows));\n+\t\t} else {\n+\t\t\tvarvalue = r_varvalue.Protect(NEW_INTEGER(nrows));\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tdefault:\n+\t\tcpp11::stop(\"rapi_execute: Unknown column type for execute: %s\", type.ToString().c_str());\n+\t}\n+\tif (!varvalue) {\n+\t\tthrow std::bad_alloc();\n+\t}\n+\treturn varvalue;\n+}\n+\n+// Convert DuckDB's timestamp to R's timestamp (POSIXct). This is a represented as the number of seconds since the\n+// epoch, stored as a double.\n+template <LogicalTypeId>\n+double ConvertTimestampValue(int64_t timestamp);\n+\n+template <>\n+double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_SEC>(int64_t timestamp) {\n+\treturn static_cast<double>(timestamp);\n+}\n+\n+template <>\n+double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_MS>(int64_t timestamp) {\n+\treturn static_cast<double>(timestamp) / Interval::MSECS_PER_SEC;\n+}\n+\n+template <>\n+double ConvertTimestampValue<LogicalTypeId::TIMESTAMP>(int64_t timestamp) {\n+\treturn static_cast<double>(timestamp) / Interval::MICROS_PER_SEC;\n+}\n+\n+template <>\n+double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_TZ>(int64_t timestamp) {\n+\treturn ConvertTimestampValue<LogicalTypeId::TIMESTAMP>(timestamp);\n+}\n+\n+template <>\n+double ConvertTimestampValue<LogicalTypeId::TIMESTAMP_NS>(int64_t timestamp) {\n+\treturn static_cast<double>(timestamp) / Interval::NANOS_PER_SEC;\n+}\n+\n+template <LogicalTypeId LT>\n+void ConvertTimestampVector(Vector &src_vec, size_t count, SEXP &dest, uint64_t dest_offset) {\n+\tauto src_data = FlatVector::GetData<int64_t>(src_vec);\n+\tauto &mask = FlatVector::Validity(src_vec);\n+\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n+\tfor (size_t row_idx = 0; row_idx < count; row_idx++) {\n+\t\tdest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? NA_REAL : ConvertTimestampValue<LT>(src_data[row_idx]);\n+\t}\n+}\n+\n+std::once_flag nanosecond_coercion_warning;\n+\n+void duckdb_r_decorate(const LogicalType &type, SEXP &dest, bool integer64) {\n+\tswitch (type.id()) {\n+\tcase LogicalTypeId::BOOLEAN:\n+\n+\tcase LogicalTypeId::UTINYINT:\n+\tcase LogicalTypeId::TINYINT:\n+\tcase LogicalTypeId::USMALLINT:\n+\tcase LogicalTypeId::SMALLINT:\n+\tcase LogicalTypeId::INTEGER:\n+\tcase LogicalTypeId::UINTEGER:\n+\tcase LogicalTypeId::HUGEINT:\n+\tcase LogicalTypeId::DECIMAL:\n+\tcase LogicalTypeId::FLOAT:\n+\tcase LogicalTypeId::DOUBLE:\n+\tcase LogicalTypeId::VARCHAR:\n+\tcase LogicalTypeId::BLOB:\n+\tcase LogicalTypeId::JSON:\n+\tcase LogicalTypeId::UUID:\n+\tcase LogicalTypeId::LIST:\n+\t\tbreak; // no extra decoration required, do nothing\n+\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\tcase LogicalTypeId::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\tSET_CLASS(dest, RStrings::get().POSIXct_POSIXt_str);\n+\t\tRf_setAttrib(dest, RStrings::get().tzone_sym, RStrings::get().UTC_str);\n+\t\tbreak;\n+\tcase LogicalTypeId::DATE:\n+\t\tSET_CLASS(dest, RStrings::get().Date_str);\n+\t\tbreak;\n+\tcase LogicalTypeId::TIME:\n+\tcase LogicalTypeId::INTERVAL:\n+\t\tSET_CLASS(dest, RStrings::get().difftime_str);\n+\t\tRf_setAttrib(dest, RStrings::get().units_sym, RStrings::get().secs_str);\n+\t\tbreak;\n+\tcase LogicalTypeId::BIGINT:\n+\tcase LogicalTypeId::UBIGINT:\n+\t\tif (integer64) {\n+\t\t\tRf_setAttrib(dest, R_ClassSymbol, RStrings::get().integer64_str);\n+\t\t}\n+\t\tbreak;\n+\tcase LogicalTypeId::STRUCT: {\n+\t\tconst auto &child_types = StructType::GetChildTypes(type);\n+\t\tfor (size_t i = 0; i < child_types.size(); i++) {\n+\t\t\tconst auto &child_type = child_types[i].second;\n+\t\t\tSEXP child_dest = VECTOR_ELT(dest, i);\n+\t\t\tduckdb_r_decorate(child_type, child_dest, integer64);\n+\t\t}\n+\n+\t\tbreak;\n+\t}\n+\n+\tcase LogicalTypeId::ENUM: {\n+\t\tauto &str_vec = EnumType::GetValuesInsertOrder(type);\n+\t\tauto size = EnumType::GetSize(type);\n+\t\tvector<string> str_c_vec(size);\n+\t\tfor (idx_t i = 0; i < size; i++) {\n+\t\t\tstr_c_vec[i] = str_vec.GetValue(i).ToString();\n+\t\t}\n+\t\tSET_LEVELS(dest, StringsToSexp(str_c_vec));\n+\t\tSET_CLASS(dest, RStrings::get().factor_str);\n+\t\tbreak;\n+\t}\n+\n+\tdefault:\n+\t\tcpp11::stop(\"rapi_execute: Unknown column type for convert: %s\", type.ToString().c_str());\n+\t\tbreak;\n+\t}\n+}\n+\n+void duckdb_r_transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n, bool integer64) {\n+\tswitch (src_vec.GetType().id()) {\n+\tcase LogicalTypeId::BOOLEAN:\n+\t\tVectorToR<int8_t, uint32_t>(src_vec, n, LOGICAL_POINTER(dest), dest_offset, NA_LOGICAL);\n+\t\tbreak;\n+\tcase LogicalTypeId::UTINYINT:\n+\t\tVectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n+\t\tbreak;\n+\tcase LogicalTypeId::TINYINT:\n+\t\tVectorToR<int8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n+\t\tbreak;\n+\tcase LogicalTypeId::USMALLINT:\n+\t\tVectorToR<uint16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n+\t\tbreak;\n+\tcase LogicalTypeId::SMALLINT:\n+\t\tVectorToR<int16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n+\t\tbreak;\n+\tcase LogicalTypeId::INTEGER:\n+\t\tVectorToR<int32_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n+\t\tbreak;\n+\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\tConvertTimestampVector<LogicalTypeId::TIMESTAMP_SEC>(src_vec, n, dest, dest_offset);\n+\t\tbreak;\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\t\tConvertTimestampVector<LogicalTypeId::TIMESTAMP_MS>(src_vec, n, dest, dest_offset);\n+\t\tbreak;\n+\tcase LogicalTypeId::TIMESTAMP:\n+\t\tConvertTimestampVector<LogicalTypeId::TIMESTAMP>(src_vec, n, dest, dest_offset);\n+\t\tbreak;\n+\tcase LogicalTypeId::TIMESTAMP_TZ:\n+\t\tConvertTimestampVector<LogicalTypeId::TIMESTAMP_TZ>(src_vec, n, dest, dest_offset);\n+\t\tbreak;\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\t\tConvertTimestampVector<LogicalTypeId::TIMESTAMP_NS>(src_vec, n, dest, dest_offset);\n+\t\tstd::call_once(nanosecond_coercion_warning, Rf_warning,\n+\t\t               \"Coercing nanoseconds to a lower resolution may result in a loss of data.\");\n+\t\tbreak;\n+\tcase LogicalTypeId::DATE: {\n+\t\tauto src_data = FlatVector::GetData<date_t>(src_vec);\n+\t\tauto &mask = FlatVector::Validity(src_vec);\n+\t\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n+\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n+\t\t\tdest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? NA_REAL : (double)int32_t(src_data[row_idx]);\n+\t\t}\n+\n+\t\t// some dresssup for R\n+\t\tSET_CLASS(dest, RStrings::get().Date_str);\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::TIME: {\n+\t\tauto src_data = FlatVector::GetData<dtime_t>(src_vec);\n+\t\tauto &mask = FlatVector::Validity(src_vec);\n+\t\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n+\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n+\t\t\tif (!mask.RowIsValid(row_idx)) {\n+\t\t\t\tdest_ptr[row_idx] = NA_REAL;\n+\t\t\t} else {\n+\t\t\t\tdest_ptr[row_idx] = src_data[row_idx].micros / Interval::MICROS_PER_SEC;\n+\t\t\t}\n+\t\t}\n+\t\tSET_CLASS(dest, RStrings::get().difftime_str);\n+\t\tRf_setAttrib(dest, RStrings::get().units_sym, RStrings::get().secs_str);\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::INTERVAL: {\n+\t\tauto src_data = FlatVector::GetData<interval_t>(src_vec);\n+\t\tauto &mask = FlatVector::Validity(src_vec);\n+\t\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n+\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n+\t\t\tif (!mask.RowIsValid(row_idx)) {\n+\t\t\t\tdest_ptr[row_idx] = NA_REAL;\n+\t\t\t} else {\n+\t\t\t\tdest_ptr[row_idx] = Interval::GetMicro(src_data[row_idx]) / Interval::MICROS_PER_SEC;\n+\t\t\t}\n+\t\t}\n+\t\tSET_CLASS(dest, RStrings::get().difftime_str);\n+\t\tRf_setAttrib(dest, RStrings::get().units_sym, RStrings::get().secs_str);\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::UINTEGER:\n+\t\tVectorToR<uint32_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n+\t\tbreak;\n+\tcase LogicalTypeId::UBIGINT:\n+\t\tif (integer64) {\n+\t\t\t// this silently loses the high bit\n+\t\t\tVectorToR<uint64_t, int64_t>(src_vec, n, NUMERIC_POINTER(dest), dest_offset,\n+\t\t\t                             NumericLimits<int64_t>::Minimum());\n+\t\t\tRf_setAttrib(dest, R_ClassSymbol, RStrings::get().integer64_str);\n+\t\t} else {\n+\t\t\tVectorToR<uint64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n+\t\t}\n+\t\tbreak;\n+\tcase LogicalTypeId::BIGINT:\n+\t\tif (integer64) {\n+\t\t\tVectorToR<int64_t, int64_t>(src_vec, n, NUMERIC_POINTER(dest), dest_offset,\n+\t\t\t                            NumericLimits<int64_t>::Minimum());\n+\t\t\tRf_setAttrib(dest, R_ClassSymbol, RStrings::get().integer64_str);\n+\t\t} else {\n+\t\t\tVectorToR<int64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n+\t\t}\n+\t\tbreak;\n+\tcase LogicalTypeId::HUGEINT: {\n+\t\tauto src_data = FlatVector::GetData<hugeint_t>(src_vec);\n+\t\tauto &mask = FlatVector::Validity(src_vec);\n+\t\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n+\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n+\t\t\tif (!mask.RowIsValid(row_idx)) {\n+\t\t\t\tdest_ptr[row_idx] = NA_REAL;\n+\t\t\t} else {\n+\t\t\t\tHugeint::TryCast(src_data[row_idx], dest_ptr[row_idx]);\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::DECIMAL: {\n+\t\tauto &decimal_type = src_vec.GetType();\n+\t\tdouble *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;\n+\t\tauto dec_scale = DecimalType::GetScale(decimal_type);\n+\t\tswitch (decimal_type.InternalType()) {\n+\t\tcase PhysicalType::INT16:\n+\t\t\tRDecimalCastLoop<int16_t>(src_vec, n, dest_ptr, dec_scale);\n+\t\t\tbreak;\n+\t\tcase PhysicalType::INT32:\n+\t\t\tRDecimalCastLoop<int32_t>(src_vec, n, dest_ptr, dec_scale);\n+\t\t\tbreak;\n+\t\tcase PhysicalType::INT64:\n+\t\t\tRDecimalCastLoop<int64_t>(src_vec, n, dest_ptr, dec_scale);\n+\t\t\tbreak;\n+\t\tcase PhysicalType::INT128:\n+\t\t\tRDecimalCastLoop<hugeint_t>(src_vec, n, dest_ptr, dec_scale);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow NotImplementedException(\"Unimplemented internal type for DECIMAL\");\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::FLOAT:\n+\t\tVectorToR<float, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n+\t\tbreak;\n+\n+\tcase LogicalTypeId::DOUBLE:\n+\t\tVectorToR<double, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);\n+\t\tbreak;\n+\tcase LogicalTypeId::JSON:\n+\tcase LogicalTypeId::VARCHAR: {\n+\t\tauto wrapper = (DuckDBAltrepStringWrapper *)R_ExternalPtrAddr(R_altrep_data1(dest));\n+\t\tauto src_data = FlatVector::GetData<string_t>(src_vec);\n+\t\tauto &mask = FlatVector::Validity(src_vec);\n+\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n+\t\t\tauto valid = mask.RowIsValid(row_idx);\n+\t\t\tauto dest_idx = dest_offset + row_idx;\n+\t\t\twrapper->mask_data[dest_idx] = valid;\n+\t\t\tif (valid) {\n+\t\t\t\twrapper->string_data[dest_idx] =\n+\t\t\t\t    src_data[row_idx].IsInlined() ? src_data[row_idx] : wrapper->heap.AddString(src_data[row_idx]);\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::LIST: {\n+\t\t// figure out the total and max element length of the list vector child\n+\t\tauto src_data = ListVector::GetData(src_vec);\n+\t\tauto &child_type = ListType::GetChildType(src_vec.GetType());\n+\t\tVector child_vector(child_type, nullptr);\n+\n+\t\t// actual loop over rows\n+\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n+\t\t\tif (!FlatVector::Validity(src_vec).RowIsValid(row_idx)) {\n+\t\t\t\tSET_ELEMENT(dest, dest_offset + row_idx, R_NilValue);\n+\t\t\t} else {\n+\t\t\t\tconst auto end = src_data[row_idx].offset + src_data[row_idx].length;\n+\t\t\t\tchild_vector.Slice(ListVector::GetEntry(src_vec), src_data[row_idx].offset, end);\n+\n+\t\t\t\tRProtector ele_prot;\n+\t\t\t\t// transform the list child vector to a single R SEXP\n+\t\t\t\tauto list_element = ele_prot.Protect(duckdb_r_allocate(child_type, ele_prot, src_data[row_idx].length));\n+\t\t\t\tduckdb_r_decorate(child_type, list_element, integer64);\n+\t\t\t\tduckdb_r_transform(child_vector, list_element, 0, src_data[row_idx].length, integer64);\n+\n+\t\t\t\t// call R's own extract subset method\n+\t\t\t\tSET_ELEMENT(dest, dest_offset + row_idx, list_element);\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::STRUCT: {\n+\t\tconst auto &children = StructVector::GetEntries(src_vec);\n+\n+\t\tfor (size_t i = 0; i < children.size(); i++) {\n+\t\t\tconst auto &struct_child = children[i];\n+\t\t\tSEXP child_dest = VECTOR_ELT(dest, i);\n+\t\t\tduckdb_r_transform(*struct_child, child_dest, dest_offset, n, integer64);\n+\t\t}\n+\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::BLOB: {\n+\t\tauto src_ptr = FlatVector::GetData<string_t>(src_vec);\n+\t\tauto &mask = FlatVector::Validity(src_vec);\n+\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n+\t\t\tif (!mask.RowIsValid(row_idx)) {\n+\t\t\t\tSET_VECTOR_ELT(dest, dest_offset + row_idx, R_NilValue);\n+\t\t\t} else {\n+\t\t\t\tSEXP rawval = NEW_RAW(src_ptr[row_idx].GetSize());\n+\t\t\t\tif (!rawval) {\n+\t\t\t\t\tthrow std::bad_alloc();\n+\t\t\t\t}\n+\t\t\t\tmemcpy(RAW_POINTER(rawval), src_ptr[row_idx].GetDataUnsafe(), src_ptr[row_idx].GetSize());\n+\t\t\t\tSET_VECTOR_ELT(dest, dest_offset + row_idx, rawval);\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::ENUM: {\n+\t\tauto physical_type = src_vec.GetType().InternalType();\n+\t\tauto dummy = NEW_STRING(1);\n+\t\tptrdiff_t sexp_header_size = (data_ptr_t)DATAPTR(dummy) - (data_ptr_t)dummy; // don't tell anyone\n+\t\tif (physical_type == PhysicalType::UINT64) {                                 // DEDUP_POINTER_ENUM\n+\t\t\tauto src_ptr = FlatVector::GetData<uint64_t>(src_vec);\n+\t\t\tauto &mask = FlatVector::Validity(src_vec);\n+\t\t\t/* we have to use SET_STRING_ELT here because otherwise those SEXPs dont get referenced */\n+\t\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n+\t\t\t\tif (!mask.RowIsValid(row_idx)) {\n+\t\t\t\t\tSET_STRING_ELT(dest, dest_offset + row_idx, NA_STRING);\n+\t\t\t\t} else {\n+\t\t\t\t\tSET_STRING_ELT(dest, dest_offset + row_idx,\n+\t\t\t\t\t               (SEXP)((data_ptr_t)src_ptr[row_idx] - sexp_header_size));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tswitch (physical_type) {\n+\t\tcase PhysicalType::UINT8:\n+\t\t\tVectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n+\t\t\tbreak;\n+\n+\t\tcase PhysicalType::UINT16:\n+\t\t\tVectorToR<uint16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n+\t\t\tbreak;\n+\n+\t\tcase PhysicalType::UINT32:\n+\t\t\tVectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tcpp11::stop(\"rapi_execute: Unknown enum type for convert: %s\", TypeIdToString(physical_type).c_str());\n+\t\t}\n+\t\t// increment by one cause R factor offsets start at 1\n+\t\tauto dest_ptr = ((int32_t *)INTEGER_POINTER(dest)) + dest_offset;\n+\t\tfor (idx_t i = 0; i < n; i++) {\n+\t\t\tif (dest_ptr[i] == NA_INTEGER) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tdest_ptr[i]++;\n+\t\t}\n+\n+\t\tauto &str_vec = EnumType::GetValuesInsertOrder(src_vec.GetType());\n+\t\tauto size = EnumType::GetSize(src_vec.GetType());\n+\t\tvector<string> str_c_vec(size);\n+\t\tfor (idx_t i = 0; i < size; i++) {\n+\t\t\tstr_c_vec[i] = str_vec.GetValue(i).ToString();\n+\t\t}\n+\n+\t\tSET_LEVELS(dest, StringsToSexp(str_c_vec));\n+\t\tSET_CLASS(dest, RStrings::get().factor_str);\n+\t\tbreak;\n+\t}\n+\tcase LogicalTypeId::UUID: {\n+\t\tauto src_ptr = FlatVector::GetData<hugeint_t>(src_vec);\n+\t\tauto &mask = FlatVector::Validity(src_vec);\n+\t\tfor (size_t row_idx = 0; row_idx < n; row_idx++) {\n+\t\t\tif (!mask.RowIsValid(row_idx)) {\n+\t\t\t\tSET_STRING_ELT(dest, dest_offset + row_idx, NA_STRING);\n+\t\t\t} else {\n+\t\t\t\tchar uuid_buf[UUID::STRING_SIZE];\n+\t\t\t\tUUID::ToString(src_ptr[row_idx], uuid_buf);\n+\t\t\t\tSET_STRING_ELT(dest, dest_offset + row_idx, Rf_mkCharLen(uuid_buf, UUID::STRING_SIZE));\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tdefault:\n+\t\tcpp11::stop(\"rapi_execute: Unknown column type for convert: %s\", src_vec.GetType().ToString().c_str());\n+\t}\n+}\ndiff --git a/tools/rpkg/src/utils.cpp b/tools/rpkg/src/utils.cpp\nindex b0c76d0a9e1b..2026caf3d7cc 100644\n--- a/tools/rpkg/src/utils.cpp\n+++ b/tools/rpkg/src/utils.cpp\n@@ -77,6 +77,7 @@ RStrings::RStrings() {\n \tImportRecordBatch_sym = Rf_install(\"ImportRecordBatch\");\n \tImportRecordBatchReader_sym = Rf_install(\"ImportRecordBatchReader\");\n \tTable__from_record_batches_sym = Rf_install(\"Table__from_record_batches\");\n+\tmaterialize_sym = Rf_install(\"duckdb.materialize_message\");\n }\n \n template <class SRC, class DST, class RTYPE>\n",
  "test_patch": "diff --git a/scripts/run_test_list.py b/scripts/run_test_list.py\nnew file mode 100644\nindex 000000000000..fc793a681858\n--- /dev/null\n+++ b/scripts/run_test_list.py\n@@ -0,0 +1,63 @@\n+import sys\n+import subprocess\n+import re\n+import os\n+\n+# wheth\n+no_exit = False\n+for i in range(len(sys.argv)):\n+\tif sys.argv[i] == '--no-exit':\n+\t\tno_exit = True\n+\t\tdel sys.argv[i]\n+\t\ti-=1\n+\n+if len(sys.argv) < 2:\n+\tprint(\"Expected usage: python3 scripts/run_test_list.py build/debug/test/unittest [--no-exit]\")\n+\texit(1)\n+unittest_program = sys.argv[1]\n+extra_args = []\n+if len(sys.argv) > 2:\n+\textra_args = [sys.argv[2]]\n+\n+\n+test_cases = []\n+first_line = True\n+for line in sys.stdin:\n+\tif first_line:\n+\t\tfirst_line = False\n+\t\tcontinue\n+\tif len(line.strip()) == 0:\n+\t\tcontinue\n+\tsplits = line.rsplit('\\t', 1)\n+\ttest_cases.append(splits[0])\n+\n+test_count = len(test_cases)\n+return_code = 0\n+for test_number in range(test_count):\n+\tprint(\"[\" + str(test_number) + \"/\" + str(test_count) + \"]: \" + test_cases[test_number])\n+\tres = subprocess.run([unittest_program, test_cases[test_number]], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+\tstdout = res.stdout.decode('utf8')\n+\tstderr = res.stderr.decode('utf8')\n+\tif res.returncode is not None and res.returncode != 0:\n+\t\tprint(\"FAILURE IN RUNNING TEST\")\n+\t\tprint(\"\"\"--------------------\n+RETURNCODE\n+--------------------\n+\"\"\")\n+\t\tprint(res.returncode)\n+\t\tprint(\"\"\"--------------------\n+STDOUT\n+--------------------\n+\"\"\")\n+\t\tprint(stdout)\n+\t\tprint(\"\"\"--------------------\n+STDERR\n+--------------------\n+\"\"\")\n+\t\tprint(stderr)\n+\t\treturn_code = 1\n+\t\tif not no_exit:\n+\t\t\tbreak\n+\n+exit(return_code)\n+\ndiff --git a/test/sql/aggregate/aggregates/test_ordered_aggregates.test b/test/sql/aggregate/aggregates/test_ordered_aggregates.test\nindex 08afe089cbfd..0ee291967e9c 100644\n--- a/test/sql/aggregate/aggregates/test_ordered_aggregates.test\n+++ b/test/sql/aggregate/aggregates/test_ordered_aggregates.test\n@@ -74,6 +74,19 @@ select percentile_cont([0.25, 0.5, 0.75]) within group(order by i desc) from gen\n ----\n [75.0, 50.0, 25.0]\n \n+# DESC boundary condition\n+query I\n+SELECT percentile_disc(.5) WITHIN GROUP (order by col desc) \n+FROM VALUES (11000), (3100), (2900), (2800), (2600), (2500) AS tab(col);\n+----\n+2900\n+\n+query I\n+SELECT percentile_disc([.25, .5, .75]) WITHIN GROUP (order by col desc) \n+FROM VALUES (11000), (3100), (2900), (2800), (2600), (2500) AS tab(col);\n+----\n+[3100, 2900, 2600]\n+\n #\n # Error checking\n #\n@@ -126,3 +139,17 @@ SELECT percentile_disc(strftime(DATE '1-11-25',NULL)) WITHIN GROUP (ORDER BY 1 D\n \n statement error\n SELECT percentile_cont(CASE 1 WHEN 2 THEN 3 END) WITHIN GROUP (ORDER BY 1 DESC);\n+\n+# Negative fractions are not allowed\n+\n+foreach sense ASC DESC\n+\n+statement error\n+SELECT percentile_disc(-.5) WITHIN GROUP (order by col ${sense}) \n+FROM VALUES (11000), (3100), (2900), (2800), (2600), (2500) AS tab(col);\n+\n+statement error\n+SELECT percentile_disc([-.25, .5, .75]) WITHIN GROUP (order by col ${sense}) \n+FROM VALUES (11000), (3100), (2900), (2800), (2600), (2500) AS tab(col);\n+\n+endloop\ndiff --git a/test/sql/aggregate/aggregates/test_quantile_cont.test b/test/sql/aggregate/aggregates/test_quantile_cont.test\nindex a289059f3944..96b8ca0de5e8 100644\n--- a/test/sql/aggregate/aggregates/test_quantile_cont.test\n+++ b/test/sql/aggregate/aggregates/test_quantile_cont.test\n@@ -117,6 +117,12 @@ SELECT quantile_cont(1, 0.1) FROM quantile\n ----\n 1\n \n+# Negative/Descending fractions\n+query I\n+SELECT quantile_cont(r, -0.1) FROM quantile\n+----\n+899910.0\n+\n # empty input\n query R\n SELECT quantile_cont(r, 0.1) FROM quantile WHERE 1=0\n@@ -124,7 +130,7 @@ SELECT quantile_cont(r, 0.1) FROM quantile WHERE 1=0\n NULL\n \n statement error\n-SELECT quantile_cont(r, -0.1) FROM quantile\n+SELECT quantile_cont(r, -1.1) FROM quantile\n \n statement error\n SELECT quantile_cont(r, 1.1) FROM quantile\ndiff --git a/test/sql/aggregate/aggregates/test_quantile_disc.test b/test/sql/aggregate/aggregates/test_quantile_disc.test\nindex da31bb327b51..9ca10d7ce0f2 100644\n--- a/test/sql/aggregate/aggregates/test_quantile_disc.test\n+++ b/test/sql/aggregate/aggregates/test_quantile_disc.test\n@@ -2,6 +2,8 @@\n # description: Test QUANTILE_DISC aggregate\n # group: [aggregates]\n \n+require 64bit\n+\n statement ok\n PRAGMA enable_verification\n \n@@ -70,6 +72,13 @@ FROM range(0,100) tbl(d)\n \n endloop\n \n+# Negative quantiles (use descending intervals)\n+query I\n+SELECT quantile_disc(col, -0.5)\n+FROM VALUES (11000), (3100), (2900), (2800), (2600), (2500) AS tab(col);\n+----\n+2900\n+\n #\n # VARCHAR. Remember, this is dictionary ordering, not numeric ordering!\n #\n@@ -167,7 +176,7 @@ NULL\n \n # Invalid usage\n statement error\n-SELECT quantile_disc(r, -0.1) FROM quantile\n+SELECT quantile_disc(r, -1.1) FROM quantile\n \n statement error\n SELECT quantile_disc(r, 1.1) FROM quantile\ndiff --git a/test/sql/aggregate/aggregates/test_quantile_disc_list.test b/test/sql/aggregate/aggregates/test_quantile_disc_list.test\nindex 49ad058fabd5..5b67bf72a809 100644\n--- a/test/sql/aggregate/aggregates/test_quantile_disc_list.test\n+++ b/test/sql/aggregate/aggregates/test_quantile_disc_list.test\n@@ -2,6 +2,8 @@\n # description: Test QUANTILE_DISC operator with LIST quantiles\n # group: [aggregates]\n \n+require 64bit\n+\n statement ok\n PRAGMA enable_verification\n \n@@ -25,6 +27,14 @@ FROM range(0,100) tbl(d)\n \n endloop\n \n+# Negative quantiles (use descending intervals)\n+query I\n+SELECT quantile_disc(col, [-.25, -.5, -.75])\n+FROM VALUES (11000), (3100), (2900), (2800), (2600), (2500) AS tab(col);\n+----\n+[3100, 2900, 2600]\n+\n+\n # VARCHAR. Remember, this is dictionary ordering, not numeric ordering!\n query I\n SELECT quantile_disc(d::VARCHAR, [0.1, 0.5, 0.9])\n@@ -139,6 +149,15 @@ SELECT quantile_disc(r, []) FROM quantiles\n ----\n []\n \n+# Oracle boundaries\n+query I\n+SELECT quantile_disc(col, [0.1, 0.32, 0.33, 0.34, 0.49, .5, .51, 0.75, 0.9, 0.999, 1])\n+FROM VALUES (0), (1), (2), (10) AS tab(col);\n+----\n+[0, 1, 1, 1, 1, 1, 2, 2, 10, 10, 10]\n+\n+\n+# Invalid use\n statement error\n SELECT quantile_disc(r, [-0.1, 0.5, 0.9]) FROM quantiles\n \ndiff --git a/test/sql/function/timestamp/test_icu_strptime.test b/test/sql/function/timestamp/test_icu_strptime.test\nindex 1a1bc71451a0..fc2c3f947408 100644\n--- a/test/sql/function/timestamp/test_icu_strptime.test\n+++ b/test/sql/function/timestamp/test_icu_strptime.test\n@@ -55,14 +55,14 @@ CREATE TABLE abbrevs AS (\n query II\n SELECT strptime('2022-03-05 17:59:17.877 ' || tz_name, '%Y-%m-%d %H:%M:%S.%g %Z') tstz, tz_name\n FROM zones\n-ORDER BY tstz\n+ORDER BY ALL\n ----\n 2022-03-04 19:59:17.877-08\tEtc/GMT-14\n 2022-03-04 20:14:17.877-08\tNZ-CHAT\n 2022-03-04 20:59:17.877-08\tPacific/Auckland\n 2022-03-04 20:59:17.877-08\tPacific/Enderbury\n-2022-03-04 22:59:17.877-08\tAustralia/Melbourne\n 2022-03-04 22:59:17.877-08\tAustralia/LHI\n+2022-03-04 22:59:17.877-08\tAustralia/Melbourne\n 2022-03-04 22:59:17.877-08\tPacific/Efate\n 2022-03-05 00:29:17.877-08\tAustralia/Darwin\n 2022-03-05 00:59:17.877-08\tAsia/Tokyo\n@@ -100,7 +100,7 @@ ORDER BY tstz\n query II\n SELECT strptime('2022-03-05 17:59:17.877 ' || tz_name, '%Y-%m-%d %H:%M:%S.%g %Z') tstz, tz_name\n FROM abbrevs\n-ORDER BY tstz\n+ORDER BY ALL\n ----\n 2022-03-04 19:59:17.877-08\tEtc/GMT-14\n 2022-03-04 20:14:17.877-08\tNZ-CHAT\ndiff --git a/test/sql/types/nested/list/list_aggr_parameter.test b/test/sql/types/nested/list/list_aggr_parameter.test\nindex f581a7178a78..342de1709a54 100644\n--- a/test/sql/types/nested/list/list_aggr_parameter.test\n+++ b/test/sql/types/nested/list/list_aggr_parameter.test\n@@ -11,9 +11,9 @@ SELECT list_aggr(list(i), 'quantile', 0.5) FROM range(1, 11) tbl(i);\n 5\n \n query I\n-SELECT list_aggr(list(i), 'quantile', [0.2, 0.5, 0.8]) FROM range(1, 11) tbl(i);\n+SELECT list_aggr(list(i), 'quantile', [0.25, 0.5, 0.75]) FROM range(1, 11) tbl(i);\n ----\n-[2, 5, 8]\n+[3, 5, 8]\n \n query I\n SELECT list_aggr(list(i), 'string_agg', '|') FROM range(1, 4) tbl(i);\ndiff --git a/test/sql/types/timestamp/test_infinite_time.test b/test/sql/types/timestamp/test_infinite_time.test\nindex 5acde46c59c1..7a97f977f1b4 100644\n--- a/test/sql/types/timestamp/test_infinite_time.test\n+++ b/test/sql/types/timestamp/test_infinite_time.test\n@@ -187,7 +187,7 @@ FROM specials;\n {-infinity=1, 1970-01-01 00:00:00=1, infinity=1}\t{-infinity=1, 1970-01-01 00:00:00+00=1, infinity=1}\t{-infinity=1, 1970-01-01=1, infinity=1}\n \n query III\n-SELECT QUANTILE_DISC(ts, 0.34), QUANTILE_DISC(tstz, 0.34), QUANTILE_DISC(dt, 0.34)\n+SELECT QUANTILE_DISC(ts, 0.32), QUANTILE_DISC(tstz, 0.32), QUANTILE_DISC(dt, 0.32)\n FROM specials;\n ----\n -infinity\t-infinity\t-infinity\ndiff --git a/test/sql/window/test_quantile_window.test b/test/sql/window/test_quantile_window.test\nindex 7554ecd385c1..c98f664119a1 100644\n--- a/test/sql/window/test_quantile_window.test\n+++ b/test/sql/window/test_quantile_window.test\n@@ -286,12 +286,12 @@ SELECT r, QUANTILE_DISC(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PR\n FROM t\n ORDER BY 1\n ----\n-0\t[0, 1, 1]\n+0\t[0, 1, 2]\n 1\t[0, 1, 2]\n 2\t[1, 2, 3]\n 3\t[2, 3, 4]\n-4\t[3, 4, 4]\n-5\t[4, 4, 4]\n+4\t[3, 4, 5]\n+5\t[4, 4, 5]\n \n # Moving discrete list with NULLs\n query II\n@@ -307,12 +307,12 @@ SELECT r, QUANTILE_DISC(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PR\n FROM t\n ORDER BY 1\n ----\n-0\t[1, 1, 1]\n-1\t[1, 2, 2]\n+0\t[1, 1, 2]\n+1\t[1, 2, 3]\n 2\t[1, 2, 3]\n 3\t[2, 3, 4]\n-4\t[3, 4, 4]\n-5\t[4, 4, 4]\n+4\t[3, 4, 5]\n+5\t[4, 4, 5]\n \n # Moving discrete list with all NULLs\n query II\n@@ -501,12 +501,12 @@ SELECT r, QUANTILE_DISC(i, [0.25, 0.5, 0.75]) OVER (ORDER BY r ROWS BETWEEN p PR\n FROM t\n ORDER BY 1\n ----\n-0\t[1, 1, 1]\n-1\t[1, 2, 2]\n+0\t[1, 1, 2]\n+1\t[1, 2, 3]\n 2\t[1, 2, 3]\n 3\t[2, 3, 4]\n-4\t[3, 4, 4]\n-5\t[4, 4, 4]\n+4\t[3, 4, 5]\n+5\t[4, 4, 5]\n \n query II\n WITH t(r, i, p, f) AS (VALUES\ndiff --git a/tools/rpkg/tests/testthat/test_relational.R b/tools/rpkg/tests/testthat/test_relational.R\nindex 509722e812ef..96ed381286bf 100644\n--- a/tools/rpkg/tests/testthat/test_relational.R\n+++ b/tools/rpkg/tests/testthat/test_relational.R\n@@ -91,3 +91,35 @@ test_that(\"we can cast R strings to DuckDB strings\", {\n     }\n })\n \n+\n+test_that(\"the altrep-conversion for relations works\", {\n+  iris$Species <- as.character(iris$Species)\n+  rel <- rel_from_df(con, iris)\n+  df <- rel_to_altrep(rel)\n+  expect_false(df_is_materialized(df))\n+  inspect_output <- capture.output(.Internal(inspect(df)))\n+  expect_true(any(grepl(\"DUCKDB_ALTREP_REL_VECTOR\", inspect_output, fixed=TRUE)))\n+  expect_true(any(grepl(\"DUCKDB_ALTREP_REL_ROWNAMES\", inspect_output, fixed=TRUE)))\n+  expect_false(df_is_materialized(df))\n+  dim(df)\n+  expect_true(df_is_materialized(df))\n+  expect_equal(iris, df)\n+})\n+\n+\n+test_that(\"the altrep-conversion for relations work for weirdo types\", {\n+  test_df <- data.frame(col_date=as.Date(\"2019-11-26\"), col_ts=as.POSIXct(\"2019-11-26 21:11Z\", \"UTC\"), col_factor=factor(c(\"a\")))\n+  rel <- rel_from_df(con, test_df)\n+  df <- rel_to_altrep(rel)\n+  expect_false(df_is_materialized(df))\n+  expect_equal(test_df, df)\n+})\n+\n+\n+test_that(\"we can get the relation object back from an altrep df\", {\n+  iris$Species <- as.character(iris$Species)\n+  rel <- rel_from_df(con, iris)\n+  df <- rel_to_altrep(rel)\n+  rel2 <- rel_from_altrep_df(df)\n+  expect_true(TRUE)\n+})\n",
  "problem_statement": "`IDate` class (an experimental class within R's data.table package) crashes duckdb's dbWriteTable method\n### What happens?\n\nhttps://youtu.be/tfQs7WbVse8?t=84\n\n### To Reproduce\n\n\r\n\tlibrary(DBI)\r\n\tx <- data.frame(data.table::as.IDate(\"2001-01-01\"))\r\n\tcon <- dbConnect( duckdb::duckdb() , dbdir = tempfile() )\r\n\tdbWriteTable( con , \"x\" , x )\r\n\r\n\n\n### OS:\n\nwindows 10 x64\n\n### DuckDB Version:\n\n0.5.1\n\n### DuckDB Client:\n\nR\n\n### Full Name:\n\nAnthony Damico\n\n### Affiliation:\n\nindependent consultant\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n`IDate` class (an experimental class within R's data.table package) crashes duckdb's dbWriteTable method\n### What happens?\n\nhttps://youtu.be/tfQs7WbVse8?t=84\n\n### To Reproduce\n\n\r\n\tlibrary(DBI)\r\n\tx <- data.frame(data.table::as.IDate(\"2001-01-01\"))\r\n\tcon <- dbConnect( duckdb::duckdb() , dbdir = tempfile() )\r\n\tdbWriteTable( con , \"x\" , x )\r\n\r\n\n\n### OS:\n\nwindows 10 x64\n\n### DuckDB Version:\n\n0.5.1\n\n### DuckDB Client:\n\nR\n\n### Full Name:\n\nAnthony Damico\n\n### Affiliation:\n\nindependent consultant\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "\n",
  "created_at": "2022-11-23T15:34:30Z"
}