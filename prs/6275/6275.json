{
  "repo": "duckdb/duckdb",
  "pull_number": 6275,
  "instance_id": "duckdb__duckdb-6275",
  "issue_numbers": [
    "6271"
  ],
  "base_commit": "14a51626cd67b934a52659467e23dbb658a2c9f7",
  "patch": "diff --git a/src/execution/column_binding_resolver.cpp b/src/execution/column_binding_resolver.cpp\nindex 212e3bd43fce..ea7fb2d40417 100644\n--- a/src/execution/column_binding_resolver.cpp\n+++ b/src/execution/column_binding_resolver.cpp\n@@ -65,9 +65,12 @@ void ColumnBindingResolver::VisitOperator(LogicalOperator &op) {\n \t\t// ON CONFLICT DO UPDATE clause\n \t\tauto &insert_op = (LogicalInsert &)op;\n \t\tif (insert_op.action_type != OnConflictAction::THROW) {\n+\t\t\t// Get the bindings from the children\n \t\t\tVisitOperatorChildren(op);\n-\t\t\tauto dummy_bindings = LogicalOperator::GenerateColumnBindings(\n-\t\t\t    insert_op.excluded_table_index, insert_op.table->GetColumns().PhysicalColumnCount());\n+\t\t\tauto column_count = insert_op.table->GetColumns().PhysicalColumnCount();\n+\t\t\tauto dummy_bindings = LogicalOperator::GenerateColumnBindings(insert_op.excluded_table_index, column_count);\n+\t\t\t// Now insert our dummy bindings at the start of the bindings,\n+\t\t\t// so the first 'column_count' indices of the chunk are reserved for our 'excluded' columns\n \t\t\tbindings.insert(bindings.begin(), dummy_bindings.begin(), dummy_bindings.end());\n \t\t\tif (insert_op.on_conflict_condition) {\n \t\t\t\tVisitExpression(&insert_op.on_conflict_condition);\ndiff --git a/src/include/duckdb/planner/operator/logical_execute.hpp b/src/include/duckdb/planner/operator/logical_execute.hpp\nindex 7a6b912469e8..2466ef1bca6f 100644\n--- a/src/include/duckdb/planner/operator/logical_execute.hpp\n+++ b/src/include/duckdb/planner/operator/logical_execute.hpp\n@@ -32,11 +32,7 @@ class LogicalExecute : public LogicalOperator {\n \t\t// already resolved\n \t}\n \tvector<ColumnBinding> GetColumnBindings() override {\n-\t\tvector<ColumnBinding> bindings;\n-\t\tfor (idx_t i = 0; i < types.size(); i++) {\n-\t\t\tbindings.push_back(ColumnBinding(0, i));\n-\t\t}\n-\t\treturn bindings;\n+\t\treturn GenerateColumnBindings(0, types.size());\n \t}\n };\n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/operator/logical_show.hpp b/src/include/duckdb/planner/operator/logical_show.hpp\nindex 87563eff3062..6e3bdfe52a47 100644\n--- a/src/include/duckdb/planner/operator/logical_show.hpp\n+++ b/src/include/duckdb/planner/operator/logical_show.hpp\n@@ -33,8 +33,7 @@ class LogicalShow : public LogicalOperator {\n \t\t         LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR};\n \t}\n \tvector<ColumnBinding> GetColumnBindings() override {\n-\t\treturn {ColumnBinding(0, 0), ColumnBinding(0, 1), ColumnBinding(0, 2),\n-\t\t        ColumnBinding(0, 3), ColumnBinding(0, 4), ColumnBinding(0, 5)};\n+\t\treturn GenerateColumnBindings(0, types.size());\n \t}\n };\n } // namespace duckdb\ndiff --git a/src/parser/statement/insert_statement.cpp b/src/parser/statement/insert_statement.cpp\nindex f4d0efae9067..6af00d4bf88e 100644\n--- a/src/parser/statement/insert_statement.cpp\n+++ b/src/parser/statement/insert_statement.cpp\n@@ -28,6 +28,9 @@ InsertStatement::InsertStatement(const InsertStatement &other)\n       select_statement(unique_ptr_cast<SQLStatement, SelectStatement>(other.select_statement->Copy())),\n       columns(other.columns), table(other.table), schema(other.schema), catalog(other.catalog) {\n \tcte_map = other.cte_map.Copy();\n+\tif (other.table_ref) {\n+\t\ttable_ref = other.table_ref->Copy();\n+\t}\n \tif (other.on_conflict_info) {\n \t\ton_conflict_info = other.on_conflict_info->Copy();\n \t}\ndiff --git a/src/planner/binder/statement/bind_insert.cpp b/src/planner/binder/statement/bind_insert.cpp\nindex b5bd69e8b4c5..b7715884e29b 100644\n--- a/src/planner/binder/statement/bind_insert.cpp\n+++ b/src/planner/binder/statement/bind_insert.cpp\n@@ -301,7 +301,28 @@ void Binder::BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &tabl\n \t\tinsert.on_conflict_condition = std::move(condition);\n \t}\n \n-\tauto projection_index = insert.children[0]->GetTableIndex()[0];\n+\tauto bindings = insert.children[0]->GetColumnBindings();\n+\tidx_t projection_index = DConstants::INVALID_INDEX;\n+\tstd::vector<unique_ptr<LogicalOperator>> *insert_child_operators;\n+\tinsert_child_operators = &insert.children;\n+\twhile (projection_index == DConstants::INVALID_INDEX) {\n+\t\tif (insert_child_operators->empty()) {\n+\t\t\t// No further children to visit\n+\t\t\tbreak;\n+\t\t}\n+\t\tD_ASSERT(insert_child_operators->size() >= 1);\n+\t\tauto &current_child = (*insert_child_operators)[0];\n+\t\tauto table_indices = current_child->GetTableIndex();\n+\t\tif (table_indices.empty()) {\n+\t\t\t// This operator does not have a table index to refer to, we have to visit its children\n+\t\t\tinsert_child_operators = &current_child->children;\n+\t\t\tcontinue;\n+\t\t}\n+\t\tprojection_index = table_indices[0];\n+\t}\n+\tif (projection_index == DConstants::INVALID_INDEX) {\n+\t\tthrow InternalException(\"Could not locate a table_index from the children of the insert\");\n+\t}\n \n \tstring unused;\n \tauto original_binding = bind_context.GetBinding(table_alias, unused);\ndiff --git a/src/planner/logical_operator.cpp b/src/planner/logical_operator.cpp\nindex 45c50e594bc0..5bf0a9d6bfbd 100644\n--- a/src/planner/logical_operator.cpp\n+++ b/src/planner/logical_operator.cpp\n@@ -57,6 +57,7 @@ void LogicalOperator::ResolveOperatorTypes() {\n \n vector<ColumnBinding> LogicalOperator::GenerateColumnBindings(idx_t table_idx, idx_t column_count) {\n \tvector<ColumnBinding> result;\n+\tresult.reserve(column_count);\n \tfor (idx_t i = 0; i < column_count; i++) {\n \t\tresult.emplace_back(table_idx, i);\n \t}\n@@ -84,6 +85,7 @@ vector<ColumnBinding> LogicalOperator::MapBindings(const vector<ColumnBinding> &\n \t\tvector<ColumnBinding> result_bindings;\n \t\tresult_bindings.reserve(projection_map.size());\n \t\tfor (auto index : projection_map) {\n+\t\t\tD_ASSERT(index < bindings.size());\n \t\t\tresult_bindings.push_back(bindings[index]);\n \t\t}\n \t\treturn result_bindings;\n",
  "test_patch": "diff --git a/test/sql/upsert/upsert_distinct_bug.test b/test/sql/upsert/upsert_distinct_bug.test\nnew file mode 100644\nindex 000000000000..d9abfa9df5f2\n--- /dev/null\n+++ b/test/sql/upsert/upsert_distinct_bug.test\n@@ -0,0 +1,47 @@\n+# name: test/sql/upsert/upsert_distinct_bug.test\n+# group: [upsert]\n+\n+# Create raw data table\n+statement ok\n+CREATE TABLE test_table_raw(id VARCHAR, name VARCHAR);\n+\n+# Insert raw data\n+statement ok\n+INSERT INTO test_table_raw VALUES\n+\t('abc001','foo'),\n+\t('abc002','bar'),\n+\t('abc001','foo2'),\n+\t('abc002','bar2');\n+\n+# Create aggregated data table\n+statement ok\n+CREATE TABLE test_table(id VARCHAR PRIMARY KEY, name VARCHAR);\n+\n+\n+# Insert aggregated data\n+statement error\n+INSERT INTO test_table\n+SELECT\n+  DISTINCT(id) as id,\n+  name\n+FROM test_table_raw;\n+\n+# Insert aggregated data\n+statement error\n+INSERT INTO test_table\n+SELECT\n+  DISTINCT(id) as id,\n+  name\n+FROM test_table_raw;\n+\n+# Insert aggregated data second time with \"INSERT OR IGNORE\" => Segmentation fault\n+# This contains conflicts between the to-be-inserted rows, still won't succeed\n+statement error\n+INSERT OR IGNORE INTO test_table\n+SELECT\n+  DISTINCT(id) as id,\n+  name\n+FROM test_table_raw;\n+\n+statement ok\n+SELECT * FROM test_table_raw;\n",
  "problem_statement": "DuckDB CLI v0.7.0: Segmentation fault on \"INSERT OR IGNORE\" \n### What happens?\n\nFollowing SQL statement kills DuckDB CLI with a \"Segmentation fault\"\r\n```sql\r\nINSERT OR IGNORE INTO test_table\r\nSELECT\r\n  DISTINCT(id) as id,\r\n  name\r\nFROM test_table_raw;\r\n```\n\n### To Reproduce\n\nJust run this script\r\n\r\n```shell\r\n#!/bin/bash\r\n\r\ncat << EOF | duckdb ./test.db\r\n--Create raw data table\r\nCREATE TABLE test_table_raw(id VARCHAR, name VARCHAR);\r\n\r\n--Insert raw data\r\nINSERT INTO test_table_raw VALUES('abc001','foo'),('abc002','bar'),('abc001','foo2'),('abc002','bar2');\r\n\r\n--Create aggregated data table\r\nCREATE TABLE test_table(id VARCHAR PRIMARY KEY, name VARCHAR);\r\n\r\n\r\n--Insert aggregated data\r\nINSERT INTO test_table\r\nSELECT\r\n  DISTINCT(id) as id,\r\n  name\r\nFROM test_table_raw;\r\n\r\n--Insert aggregated data second time with \"INSERT OR IGNORE\" => Segmentation fault\r\nINSERT OR IGNORE INTO test_table\r\nSELECT\r\n  DISTINCT(id) as id,\r\n  name\r\nFROM test_table_raw;\r\n\r\n\r\nSELECT * FROM test_table_raw;\r\n\r\nEOF\r\n```\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\nv0.7.0\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nKorbinian Pauli\n\n### Affiliation:\n\nprivate\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Hey! Thanks for the bug report\r\n\r\nI'll look into it :)\nI can make this not segfault, but I can't make this work the way you want this to work.\r\nWe can detect conflicts between inserted rows and existing rows.\r\n\r\nIn this case the conflicts are within the inserted rows\r\n```sql\r\nSELECT\r\n  DISTINCT(id) as id,\r\n  name\r\nFROM test_table_raw;\r\n```\r\n```\r\nabc001  foo\r\nabc002  bar\r\nabc001  foo2\r\nabc002  bar2\r\n```\r\n\r\nTo get this to insert, you have to make sure that the rows you're inserting don't have conflicts between eachother\r\nLikely you want this:\r\n```sql\r\nSELECT DISTINCT ON (id)\r\n  id,\r\n  name\r\nFROM test_table_raw;\r\n```\r\n```\r\nabc001  foo\r\nabc002  bar\r\n```",
  "created_at": "2023-02-14T12:01:43Z"
}