{
  "repo": "duckdb/duckdb",
  "pull_number": 4166,
  "instance_id": "duckdb__duckdb-4166",
  "issue_numbers": [
    "4165",
    "4165"
  ],
  "base_commit": "195b7b47b43f875b0ade249eaf456f7909a447bc",
  "patch": "diff --git a/src/include/duckdb/common/vector_operations/binary_executor.hpp b/src/include/duckdb/common/vector_operations/binary_executor.hpp\nindex 3bba926d3804..8107730a04df 100644\n--- a/src/include/duckdb/common/vector_operations/binary_executor.hpp\n+++ b/src/include/duckdb/common/vector_operations/binary_executor.hpp\n@@ -387,9 +387,19 @@ struct BinaryExecutor {\n \t\tauto rdata = FlatVector::GetData<RIGHT_TYPE>(right);\n \n \t\tif (LEFT_CONSTANT && ConstantVector::IsNull(left)) {\n+\t\t\tif (false_sel) {\n+\t\t\t\tfor (idx_t i = 0; i < count; i++) {\n+\t\t\t\t\tfalse_sel->set_index(i, sel->get_index(i));\n+\t\t\t\t}\n+\t\t\t}\n \t\t\treturn 0;\n \t\t}\n \t\tif (RIGHT_CONSTANT && ConstantVector::IsNull(right)) {\n+\t\t\tif (false_sel) {\n+\t\t\t\tfor (idx_t i = 0; i < count; i++) {\n+\t\t\t\t\tfalse_sel->set_index(i, sel->get_index(i));\n+\t\t\t\t}\n+\t\t\t}\n \t\t\treturn 0;\n \t\t}\n \n",
  "test_patch": "diff --git a/test/issues/general/test_4165.test b/test/issues/general/test_4165.test\nnew file mode 100644\nindex 000000000000..e6c752baf8f3\n--- /dev/null\n+++ b/test/issues/general/test_4165.test\n@@ -0,0 +1,34 @@\n+# name: test/issues/general/test_4165.test\n+# description: Issue 4165: SIGSEGV on Debian Buster amd64\n+# group: [general]\n+\n+statement ok\n+SELECT setseed(0.42);\n+\n+statement ok\n+CREATE TABLE df_a AS\n+SELECT\n+    (100000 + (899999 * RANDOM()))::BIGINT AS ID,\n+    (4000 * RANDOM())::BIGINT AS C,\n+    (4000 * RANDOM())::BIGINT AS P,\n+    substring('abc', 1+(RANDOM() * 2)::BIGINT, 1) AS S\n+FROM range(20000)\n+\n+statement ok\n+CREATE TABLE df_b AS\n+SELECT * FROM df_a WHERE S='a'\n+\n+statement ok\n+select\n+       Case\n+           when try_cast(b.c as real) is null\n+                and a.s = 'b' then a.p\n+           when try_cast(b.c as real) is not null\n+                and a.s = 'b'\n+                and try_cast(b.c as real) < try_cast(a.p as real)\n+                then try_cast(a.p as real)\n+           else 0\n+       END\n+from df_a a\n+left join df_b b on Cast(a.ID as real) = cast(b.ID as real)\n+left join df_b c on a.ID = c.ID;\n",
  "problem_statement": "SIGSEGV on Debian Buster amd64 \n#### What happens?\r\nIn certain environments (Debian Buster running on an amd64 architecture), running a certain query in DuckDB can lead to the Python process being terminated with a segfault.\r\n\r\n#### To Reproduce\r\nThe segfault can be reproduced through the following Python code\r\n```python\r\nimport pandas as pd\r\nimport numpy as np\r\nimport duckdb\r\n\r\nROWS = 8000\r\n\r\ndf_a = pd.DataFrame(np.random.randint(100000,999999,size=(ROWS,1)), columns=['ID'])\r\ndf_a['C'] = np.random.randint(0,4000,size=(ROWS,1))\r\ndf_a['P'] = np.random.randint(0,4000,size=(ROWS,1))\r\ndf_a['S'] = np.random.choice(['a', 'b', 'c'],size=(ROWS,1))\r\n\r\ndf_b = df_a[df_a.S == 'a']\r\n\r\ndb = duckdb.connect(database=\":memory:\", read_only=False)\r\ndb.register('df_a', df_a)\r\ndb.register('df_b', df_b)\r\ndb.execute('''\r\nselect \r\n       Case\r\n           when try_cast(b.c as real) is null\r\n                and a.s = 'b' then a.p\r\n           when try_cast(b.c as real) is not null\r\n                and a.s = 'b'\r\n                and try_cast(b.c as real) < try_cast(a.p as real)\r\n                then try_cast(a.p as real)\r\n           else 0\r\n       END\r\nfrom df_a a\r\nleft join df_b b on Cast(a.ID as real) = cast(b.ID as real)\r\nleft join df_b c on a.ID = c.ID\r\n''')\r\n\r\ndf_c = db.fetch_df()\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Debian Buster amd64 (running inside a Docker container)\r\n - DuckDB Version: 0.4.0\r\n - DuckDB Client: Python\r\n \r\n#### Identity Disclosure:\r\n - Full Name: Alex Bergeron\r\n - Affiliation: Hex Technologies\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\nDepending on the configuration, adjusting the `ROWS` variable might be required to guarantee hitting that segfault.\nSIGSEGV on Debian Buster amd64 \n#### What happens?\r\nIn certain environments (Debian Buster running on an amd64 architecture), running a certain query in DuckDB can lead to the Python process being terminated with a segfault.\r\n\r\n#### To Reproduce\r\nThe segfault can be reproduced through the following Python code\r\n```python\r\nimport pandas as pd\r\nimport numpy as np\r\nimport duckdb\r\n\r\nROWS = 8000\r\n\r\ndf_a = pd.DataFrame(np.random.randint(100000,999999,size=(ROWS,1)), columns=['ID'])\r\ndf_a['C'] = np.random.randint(0,4000,size=(ROWS,1))\r\ndf_a['P'] = np.random.randint(0,4000,size=(ROWS,1))\r\ndf_a['S'] = np.random.choice(['a', 'b', 'c'],size=(ROWS,1))\r\n\r\ndf_b = df_a[df_a.S == 'a']\r\n\r\ndb = duckdb.connect(database=\":memory:\", read_only=False)\r\ndb.register('df_a', df_a)\r\ndb.register('df_b', df_b)\r\ndb.execute('''\r\nselect \r\n       Case\r\n           when try_cast(b.c as real) is null\r\n                and a.s = 'b' then a.p\r\n           when try_cast(b.c as real) is not null\r\n                and a.s = 'b'\r\n                and try_cast(b.c as real) < try_cast(a.p as real)\r\n                then try_cast(a.p as real)\r\n           else 0\r\n       END\r\nfrom df_a a\r\nleft join df_b b on Cast(a.ID as real) = cast(b.ID as real)\r\nleft join df_b c on a.ID = c.ID\r\n''')\r\n\r\ndf_c = db.fetch_df()\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Debian Buster amd64 (running inside a Docker container)\r\n - DuckDB Version: 0.4.0\r\n - DuckDB Client: Python\r\n \r\n#### Identity Disclosure:\r\n - Full Name: Alex Bergeron\r\n - Affiliation: Hex Technologies\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\nDepending on the configuration, adjusting the `ROWS` variable might be required to guarantee hitting that segfault.\n",
  "hints_text": "Thanks for the report! I have managed to reproduce the issue. I will have a look.\nThanks for the report! I have managed to reproduce the issue. I will have a look.",
  "created_at": "2022-07-19T21:10:50Z"
}