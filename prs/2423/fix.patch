diff --git a/src/function/function.cpp b/src/function/function.cpp
index ee018a23a49a..e38f5a1c92bc 100644
--- a/src/function/function.cpp
+++ b/src/function/function.cpp
@@ -19,6 +19,7 @@
 #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
 #include "duckdb/planner/expression/bound_cast_expression.hpp"
 #include "duckdb/planner/expression/bound_function_expression.hpp"
+#include "duckdb/planner/expression_binder.hpp"
 
 namespace duckdb {
 
@@ -316,25 +317,38 @@ idx_t Function::BindFunction(const string &name, vector<TableFunction> &function
 	return Function::BindFunction(name, functions, types, error);
 }
 
+enum class LogicalTypeComparisonResult { IDENTICAL_TYPE, TARGET_IS_ANY, DIFFERENT_TYPES };
+
+LogicalTypeComparisonResult RequiresCast(const LogicalType &source_type, const LogicalType &target_type) {
+	if (target_type.id() == LogicalTypeId::ANY) {
+		return LogicalTypeComparisonResult::TARGET_IS_ANY;
+	}
+	if (source_type == target_type) {
+		return LogicalTypeComparisonResult::IDENTICAL_TYPE;
+	}
+	if (source_type.id() == LogicalTypeId::LIST && target_type.id() == LogicalTypeId::LIST) {
+		return RequiresCast(ListType::GetChildType(source_type), ListType::GetChildType(target_type));
+	}
+	return LogicalTypeComparisonResult::DIFFERENT_TYPES;
+}
+
 void BaseScalarFunction::CastToFunctionArguments(vector<unique_ptr<Expression>> &children) {
 	for (idx_t i = 0; i < children.size(); i++) {
 		auto target_type = i < this->arguments.size() ? this->arguments[i] : this->varargs;
 		target_type.Verify();
 		// check if the type of child matches the type of function argument
 		// if not we need to add a cast
-		bool require_cast = children[i]->return_type != target_type;
+		auto cast_result = RequiresCast(children[i]->return_type, target_type);
 		// except for one special case: if the function accepts ANY argument
 		// in that case we don't add a cast
-		if (target_type.id() == LogicalTypeId::ANY) {
+		if (cast_result == LogicalTypeComparisonResult::TARGET_IS_ANY) {
 			if (children[i]->return_type.id() == LogicalTypeId::UNKNOWN) {
 				// UNLESS the child is a prepared statement parameter
 				// in that case we default the prepared statement parameter to VARCHAR
-				target_type = LogicalType::VARCHAR;
-			} else {
-				require_cast = false;
+				children[i]->return_type =
+				    ExpressionBinder::ExchangeType(target_type, LogicalTypeId::ANY, LogicalType::VARCHAR);
 			}
-		}
-		if (require_cast) {
+		} else if (cast_result == LogicalTypeComparisonResult::DIFFERENT_TYPES) {
 			children[i] = BoundCastExpression::AddCastToType(move(children[i]), target_type);
 		}
 	}
diff --git a/src/function/scalar/list/list_extract.cpp b/src/function/scalar/list/list_extract.cpp
index f6cd728d9188..c7efcb86a5c4 100644
--- a/src/function/scalar/list/list_extract.cpp
+++ b/src/function/scalar/list/list_extract.cpp
@@ -187,6 +187,10 @@ static void ListExtractFunction(DataChunk &args, ExpressionState &state, Vector
 	case LogicalTypeId::VARCHAR:
 		ExecuteStringExtract(result, base, subscript, count);
 		break;
+	case LogicalTypeId::SQLNULL:
+		result.SetVectorType(VectorType::CONSTANT_VECTOR);
+		ConstantVector::SetNull(result, true);
+		break;
 	default:
 		throw NotImplementedException("Specifier type not implemented");
 	}
@@ -195,10 +199,14 @@ static void ListExtractFunction(DataChunk &args, ExpressionState &state, Vector
 static unique_ptr<FunctionData> ListExtractBind(ClientContext &context, ScalarFunction &bound_function,
                                                 vector<unique_ptr<Expression>> &arguments) {
 	D_ASSERT(bound_function.arguments.size() == 2);
-	D_ASSERT(LogicalTypeId::LIST == arguments[0]->return_type.id());
-	// list extract returns the child type of the list as return type
-	bound_function.return_type = ListType::GetChildType(arguments[0]->return_type);
-
+	if (arguments[0]->return_type.id() == LogicalTypeId::SQLNULL) {
+		bound_function.arguments[0] = LogicalType::SQLNULL;
+		bound_function.return_type = LogicalType::SQLNULL;
+	} else {
+		D_ASSERT(LogicalTypeId::LIST == arguments[0]->return_type.id());
+		// list extract returns the child type of the list as return type
+		bound_function.return_type = ListType::GetChildType(arguments[0]->return_type);
+	}
 	return make_unique<VariableReturnBindData>(bound_function.return_type);
 }
 
diff --git a/src/function/scalar/string/length.cpp b/src/function/scalar/string/length.cpp
index 13d9a7e4a570..6eac0dd5d0ca 100644
--- a/src/function/scalar/string/length.cpp
+++ b/src/function/scalar/string/length.cpp
@@ -72,7 +72,7 @@ static unique_ptr<FunctionData> ListLengthBind(ClientContext &context, ScalarFun
 
 void LengthFun::RegisterFunction(BuiltinFunctions &set) {
 	ScalarFunction array_length_unary = ScalarFunction(
-	    {LogicalTypeId::LIST}, LogicalType::BIGINT,
+	    {LogicalType::LIST(LogicalType::ANY)}, LogicalType::BIGINT,
 	    ScalarFunction::UnaryFunction<list_entry_t, int64_t, ArrayLengthOperator>, false, ListLengthBind);
 	ScalarFunctionSet length("length");
 	length.AddFunction(ScalarFunction({LogicalType::VARCHAR}, LogicalType::BIGINT,
@@ -86,7 +86,7 @@ void LengthFun::RegisterFunction(BuiltinFunctions &set) {
 	ScalarFunctionSet array_length("array_length");
 	array_length.AddFunction(array_length_unary);
 	array_length.AddFunction(
-	    ScalarFunction({LogicalTypeId::LIST, LogicalType::BIGINT}, LogicalType::BIGINT,
+	    ScalarFunction({LogicalType::LIST(LogicalType::ANY), LogicalType::BIGINT}, LogicalType::BIGINT,
 	                   ScalarFunction::BinaryFunction<list_entry_t, int64_t, int64_t, ArrayLengthBinaryOperator>, false,
 	                   ListLengthBind));
 	set.AddFunction(array_length);
diff --git a/src/planner/planner.cpp b/src/planner/planner.cpp
index 4ff091e9e906..f73690a57479 100644
--- a/src/planner/planner.cpp
+++ b/src/planner/planner.cpp
@@ -40,7 +40,7 @@ void Planner::CreatePlan(SQLStatement &statement) {
 	for (auto &expr : bound_parameters) {
 		// check if the type of the parameter could be resolved
 		if (expr->return_type.id() == LogicalTypeId::INVALID || expr->return_type.id() == LogicalTypeId::UNKNOWN) {
-			throw InternalException("Could not determine type of parameters");
+			throw BinderException("Could not determine type of parameters");
 		}
 		auto value = make_unique<Value>(expr->return_type);
 		expr->value = value.get();
