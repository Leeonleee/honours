{
  "repo": "duckdb/duckdb",
  "pull_number": 2423,
  "instance_id": "duckdb__duckdb-2423",
  "issue_numbers": [
    "2416",
    "2416"
  ],
  "base_commit": "41b1cff3cb4bb65dd8a58f9929f696c3311e9731",
  "patch": "diff --git a/src/function/function.cpp b/src/function/function.cpp\nindex ee018a23a49a..e38f5a1c92bc 100644\n--- a/src/function/function.cpp\n+++ b/src/function/function.cpp\n@@ -19,6 +19,7 @@\n #include \"duckdb/planner/expression/bound_aggregate_expression.hpp\"\n #include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n #include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/planner/expression_binder.hpp\"\n \n namespace duckdb {\n \n@@ -316,25 +317,38 @@ idx_t Function::BindFunction(const string &name, vector<TableFunction> &function\n \treturn Function::BindFunction(name, functions, types, error);\n }\n \n+enum class LogicalTypeComparisonResult { IDENTICAL_TYPE, TARGET_IS_ANY, DIFFERENT_TYPES };\n+\n+LogicalTypeComparisonResult RequiresCast(const LogicalType &source_type, const LogicalType &target_type) {\n+\tif (target_type.id() == LogicalTypeId::ANY) {\n+\t\treturn LogicalTypeComparisonResult::TARGET_IS_ANY;\n+\t}\n+\tif (source_type == target_type) {\n+\t\treturn LogicalTypeComparisonResult::IDENTICAL_TYPE;\n+\t}\n+\tif (source_type.id() == LogicalTypeId::LIST && target_type.id() == LogicalTypeId::LIST) {\n+\t\treturn RequiresCast(ListType::GetChildType(source_type), ListType::GetChildType(target_type));\n+\t}\n+\treturn LogicalTypeComparisonResult::DIFFERENT_TYPES;\n+}\n+\n void BaseScalarFunction::CastToFunctionArguments(vector<unique_ptr<Expression>> &children) {\n \tfor (idx_t i = 0; i < children.size(); i++) {\n \t\tauto target_type = i < this->arguments.size() ? this->arguments[i] : this->varargs;\n \t\ttarget_type.Verify();\n \t\t// check if the type of child matches the type of function argument\n \t\t// if not we need to add a cast\n-\t\tbool require_cast = children[i]->return_type != target_type;\n+\t\tauto cast_result = RequiresCast(children[i]->return_type, target_type);\n \t\t// except for one special case: if the function accepts ANY argument\n \t\t// in that case we don't add a cast\n-\t\tif (target_type.id() == LogicalTypeId::ANY) {\n+\t\tif (cast_result == LogicalTypeComparisonResult::TARGET_IS_ANY) {\n \t\t\tif (children[i]->return_type.id() == LogicalTypeId::UNKNOWN) {\n \t\t\t\t// UNLESS the child is a prepared statement parameter\n \t\t\t\t// in that case we default the prepared statement parameter to VARCHAR\n-\t\t\t\ttarget_type = LogicalType::VARCHAR;\n-\t\t\t} else {\n-\t\t\t\trequire_cast = false;\n+\t\t\t\tchildren[i]->return_type =\n+\t\t\t\t    ExpressionBinder::ExchangeType(target_type, LogicalTypeId::ANY, LogicalType::VARCHAR);\n \t\t\t}\n-\t\t}\n-\t\tif (require_cast) {\n+\t\t} else if (cast_result == LogicalTypeComparisonResult::DIFFERENT_TYPES) {\n \t\t\tchildren[i] = BoundCastExpression::AddCastToType(move(children[i]), target_type);\n \t\t}\n \t}\ndiff --git a/src/function/scalar/list/list_extract.cpp b/src/function/scalar/list/list_extract.cpp\nindex f6cd728d9188..c7efcb86a5c4 100644\n--- a/src/function/scalar/list/list_extract.cpp\n+++ b/src/function/scalar/list/list_extract.cpp\n@@ -187,6 +187,10 @@ static void ListExtractFunction(DataChunk &args, ExpressionState &state, Vector\n \tcase LogicalTypeId::VARCHAR:\n \t\tExecuteStringExtract(result, base, subscript, count);\n \t\tbreak;\n+\tcase LogicalTypeId::SQLNULL:\n+\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\t\tConstantVector::SetNull(result, true);\n+\t\tbreak;\n \tdefault:\n \t\tthrow NotImplementedException(\"Specifier type not implemented\");\n \t}\n@@ -195,10 +199,14 @@ static void ListExtractFunction(DataChunk &args, ExpressionState &state, Vector\n static unique_ptr<FunctionData> ListExtractBind(ClientContext &context, ScalarFunction &bound_function,\n                                                 vector<unique_ptr<Expression>> &arguments) {\n \tD_ASSERT(bound_function.arguments.size() == 2);\n-\tD_ASSERT(LogicalTypeId::LIST == arguments[0]->return_type.id());\n-\t// list extract returns the child type of the list as return type\n-\tbound_function.return_type = ListType::GetChildType(arguments[0]->return_type);\n-\n+\tif (arguments[0]->return_type.id() == LogicalTypeId::SQLNULL) {\n+\t\tbound_function.arguments[0] = LogicalType::SQLNULL;\n+\t\tbound_function.return_type = LogicalType::SQLNULL;\n+\t} else {\n+\t\tD_ASSERT(LogicalTypeId::LIST == arguments[0]->return_type.id());\n+\t\t// list extract returns the child type of the list as return type\n+\t\tbound_function.return_type = ListType::GetChildType(arguments[0]->return_type);\n+\t}\n \treturn make_unique<VariableReturnBindData>(bound_function.return_type);\n }\n \ndiff --git a/src/function/scalar/string/length.cpp b/src/function/scalar/string/length.cpp\nindex 13d9a7e4a570..6eac0dd5d0ca 100644\n--- a/src/function/scalar/string/length.cpp\n+++ b/src/function/scalar/string/length.cpp\n@@ -72,7 +72,7 @@ static unique_ptr<FunctionData> ListLengthBind(ClientContext &context, ScalarFun\n \n void LengthFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunction array_length_unary = ScalarFunction(\n-\t    {LogicalTypeId::LIST}, LogicalType::BIGINT,\n+\t    {LogicalType::LIST(LogicalType::ANY)}, LogicalType::BIGINT,\n \t    ScalarFunction::UnaryFunction<list_entry_t, int64_t, ArrayLengthOperator>, false, ListLengthBind);\n \tScalarFunctionSet length(\"length\");\n \tlength.AddFunction(ScalarFunction({LogicalType::VARCHAR}, LogicalType::BIGINT,\n@@ -86,7 +86,7 @@ void LengthFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunctionSet array_length(\"array_length\");\n \tarray_length.AddFunction(array_length_unary);\n \tarray_length.AddFunction(\n-\t    ScalarFunction({LogicalTypeId::LIST, LogicalType::BIGINT}, LogicalType::BIGINT,\n+\t    ScalarFunction({LogicalType::LIST(LogicalType::ANY), LogicalType::BIGINT}, LogicalType::BIGINT,\n \t                   ScalarFunction::BinaryFunction<list_entry_t, int64_t, int64_t, ArrayLengthBinaryOperator>, false,\n \t                   ListLengthBind));\n \tset.AddFunction(array_length);\ndiff --git a/src/planner/planner.cpp b/src/planner/planner.cpp\nindex 4ff091e9e906..f73690a57479 100644\n--- a/src/planner/planner.cpp\n+++ b/src/planner/planner.cpp\n@@ -40,7 +40,7 @@ void Planner::CreatePlan(SQLStatement &statement) {\n \tfor (auto &expr : bound_parameters) {\n \t\t// check if the type of the parameter could be resolved\n \t\tif (expr->return_type.id() == LogicalTypeId::INVALID || expr->return_type.id() == LogicalTypeId::UNKNOWN) {\n-\t\t\tthrow InternalException(\"Could not determine type of parameters\");\n+\t\t\tthrow BinderException(\"Could not determine type of parameters\");\n \t\t}\n \t\tauto value = make_unique<Value>(expr->return_type);\n \t\texpr->value = value.get();\n",
  "test_patch": "diff --git a/test/issues/general/test_2416.test b/test/issues/general/test_2416.test\nnew file mode 100644\nindex 000000000000..46a8dcd3c13a\n--- /dev/null\n+++ b/test/issues/general/test_2416.test\n@@ -0,0 +1,90 @@\n+# name: test/issues/general/test_2416.test\n+# description: Issue 2416: Segmentation fault on macro creation\n+# group: [general]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+select list_extract(null, null);\n+----\n+NULL\n+\n+query I\n+select list_extract(null, 1);\n+----\n+NULL\n+\n+query I\n+select list_extract([1, 2, 3], NULL);\n+----\n+NULL\n+\n+query I\n+SELECT list_extract([1, 2, 3], 1)\n+----\n+2\n+\n+statement ok\n+PREPARE v1 AS SELECT list_extract($1::int[], 1)\n+\n+query I\n+EXECUTE v1([1, 2, 3])\n+----\n+2\n+\n+query I\n+EXECUTE v1(NULL)\n+----\n+NULL\n+\n+statement ok\n+PREPARE v2 AS SELECT list_extract([1, 2, 3], $1)\n+\n+query I\n+EXECUTE v2(1)\n+----\n+2\n+\n+query I\n+EXECUTE v2(NULL)\n+----\n+NULL\n+\n+statement ok\n+create macro extract_field(my_struct, my_field) as my_struct[my_field];\n+\n+query I\n+SELECT extract_field([1, 2, 3], 1)\n+----\n+2\n+\n+# the same but with array_length\n+query I\n+select array_length(null);\n+----\n+NULL\n+\n+statement ok\n+PREPARE v3 AS SELECT array_length($1::int[])\n+\n+query I\n+EXECUTE v3([1, 2, 3])\n+----\n+3\n+\n+query I\n+EXECUTE v3(NULL)\n+----\n+NULL\n+\n+statement error\n+PREPARE v4 AS SELECT array_length($1)\n+\n+statement ok\n+create macro array_l(my_arr) as array_length(my_arr);\n+\n+query I\n+SELECT array_l([1, 2, 3])\n+----\n+3\n",
  "problem_statement": "Segmentation fault on macro creation\n**What does happen?**\r\nCreating the following macro causes a segmentation fault:\r\n```sql\r\ncreate macro extract_field(my_struct, my_field) as my_struct[my_field];\r\n```\r\n\r\nThis is equivalent, and also results in a segmentation fault:\r\n```sql\r\ncreate macro extract_field(my_struct, my_field) as array_extract(my_struct, my_field);\r\n```\r\n\r\n**What should happen?**\r\nThe macro should be created succesfully.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n1. Run one of the queries as shown above\r\n\r\n**Environment (please complete the following information):**\r\n - OS: macOS Big Sur\r\n - DuckDB Version 3.0 (latest master branch)\r\n\r\n**Before submitting**\r\n- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\nSegmentation fault on macro creation\n**What does happen?**\r\nCreating the following macro causes a segmentation fault:\r\n```sql\r\ncreate macro extract_field(my_struct, my_field) as my_struct[my_field];\r\n```\r\n\r\nThis is equivalent, and also results in a segmentation fault:\r\n```sql\r\ncreate macro extract_field(my_struct, my_field) as array_extract(my_struct, my_field);\r\n```\r\n\r\n**What should happen?**\r\nThe macro should be created succesfully.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n1. Run one of the queries as shown above\r\n\r\n**Environment (please complete the following information):**\r\n - OS: macOS Big Sur\r\n - DuckDB Version 3.0 (latest master branch)\r\n\r\n**Before submitting**\r\n- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\n",
  "hints_text": "\n",
  "created_at": "2021-10-13T20:35:35Z"
}