{
  "repo": "duckdb/duckdb",
  "pull_number": 9993,
  "instance_id": "duckdb__duckdb-9993",
  "issue_numbers": [
    "9456"
  ],
  "base_commit": "bce1e358e09f2525ed0ab5d73195ff8c9675d85a",
  "patch": "diff --git a/.github/patches/extensions/substrait/disable_tpch.patch b/.github/patches/extensions/substrait/disable_tpch.patch\nnew file mode 100644\nindex 000000000000..55d4c660675d\n--- /dev/null\n+++ b/.github/patches/extensions/substrait/disable_tpch.patch\n@@ -0,0 +1,19 @@\n+diff --git a/test/sql/test_substrait_tpch.test b/test/sql/test_substrait_tpch.test\n+index ffa2666..10f815b 100644\n+--- a/test/sql/test_substrait_tpch.test\n++++ b/test/sql/test_substrait_tpch.test\n+@@ -2,6 +2,14 @@\n+ # description: Test get_substrait with TPC-H queries\n+ # group: [sql]\n+ \n++# test skipped since PR https://github.com/duckdb/duckdb/pull/9993\n++# the PR re-introduces DelimJoins in TPC-H again for performance reasons\n++# if there is a selection in the duplicate-eliminated side, we keep the DelimJoin\n++# this is checked in Deliminator::HasSelection\n++# if this function returns false, all DelimJoins are removed from TPC-H\n++\n++mode skip\n++\n+ require substrait\n+ \n+ require tpch\ndiff --git a/src/common/enum_util.cpp b/src/common/enum_util.cpp\nindex 650e2ec94e85..fd275b2d7284 100644\n--- a/src/common/enum_util.cpp\n+++ b/src/common/enum_util.cpp\n@@ -4173,8 +4173,10 @@ const char* EnumUtil::ToChars<PhysicalOperatorType>(PhysicalOperatorType value)\n \t\treturn \"PIECEWISE_MERGE_JOIN\";\n \tcase PhysicalOperatorType::IE_JOIN:\n \t\treturn \"IE_JOIN\";\n-\tcase PhysicalOperatorType::DELIM_JOIN:\n-\t\treturn \"DELIM_JOIN\";\n+\tcase PhysicalOperatorType::LEFT_DELIM_JOIN:\n+\t\treturn \"LEFT_DELIM_JOIN\";\n+\tcase PhysicalOperatorType::RIGHT_DELIM_JOIN:\n+\t\treturn \"RIGHT_DELIM_JOIN\";\n \tcase PhysicalOperatorType::POSITIONAL_JOIN:\n \t\treturn \"POSITIONAL_JOIN\";\n \tcase PhysicalOperatorType::ASOF_JOIN:\n@@ -4366,8 +4368,11 @@ PhysicalOperatorType EnumUtil::FromString<PhysicalOperatorType>(const char *valu\n \tif (StringUtil::Equals(value, \"IE_JOIN\")) {\n \t\treturn PhysicalOperatorType::IE_JOIN;\n \t}\n-\tif (StringUtil::Equals(value, \"DELIM_JOIN\")) {\n-\t\treturn PhysicalOperatorType::DELIM_JOIN;\n+\tif (StringUtil::Equals(value, \"LEFT_DELIM_JOIN\")) {\n+\t\treturn PhysicalOperatorType::LEFT_DELIM_JOIN;\n+\t}\n+\tif (StringUtil::Equals(value, \"RIGHT_DELIM_JOIN\")) {\n+\t\treturn PhysicalOperatorType::RIGHT_DELIM_JOIN;\n \t}\n \tif (StringUtil::Equals(value, \"POSITIONAL_JOIN\")) {\n \t\treturn PhysicalOperatorType::POSITIONAL_JOIN;\ndiff --git a/src/common/enums/join_type.cpp b/src/common/enums/join_type.cpp\nindex 7d7e96c5261d..543163fce6fe 100644\n--- a/src/common/enums/join_type.cpp\n+++ b/src/common/enums/join_type.cpp\n@@ -1,4 +1,5 @@\n #include \"duckdb/common/enums/join_type.hpp\"\n+\n #include \"duckdb/common/enum_util.hpp\"\n \n namespace duckdb {\n@@ -16,6 +17,34 @@ bool PropagatesBuildSide(JoinType type) {\n \t       type == JoinType::RIGHT_SEMI;\n }\n \n+bool HasInverseJoinType(JoinType type) {\n+\treturn type != JoinType::SINGLE && type != JoinType::MARK;\n+}\n+\n+JoinType InverseJoinType(JoinType type) {\n+\tD_ASSERT(HasInverseJoinType(type));\n+\tswitch (type) {\n+\tcase JoinType::LEFT:\n+\t\treturn JoinType::RIGHT;\n+\tcase JoinType::RIGHT:\n+\t\treturn JoinType::LEFT;\n+\tcase JoinType::INNER:\n+\t\treturn JoinType::INNER;\n+\tcase JoinType::OUTER:\n+\t\treturn JoinType::OUTER;\n+\tcase JoinType::SEMI:\n+\t\treturn JoinType::RIGHT_SEMI;\n+\tcase JoinType::ANTI:\n+\t\treturn JoinType::RIGHT_ANTI;\n+\tcase JoinType::RIGHT_SEMI:\n+\t\treturn JoinType::SEMI;\n+\tcase JoinType::RIGHT_ANTI:\n+\t\treturn JoinType::ANTI;\n+\tdefault:\n+\t\tthrow NotImplementedException(\"InverseJoinType for JoinType::%s\", EnumUtil::ToString(type));\n+\t}\n+}\n+\n // **DEPRECATED**: Use EnumUtil directly instead.\n string JoinTypeToString(JoinType type) {\n \treturn EnumUtil::ToString(type);\ndiff --git a/src/common/enums/physical_operator_type.cpp b/src/common/enums/physical_operator_type.cpp\nindex 620ed69d812b..54b6fc7acb5b 100644\n--- a/src/common/enums/physical_operator_type.cpp\n+++ b/src/common/enums/physical_operator_type.cpp\n@@ -51,8 +51,10 @@ string PhysicalOperatorToString(PhysicalOperatorType type) {\n \t\treturn \"BATCH_COPY_TO_FILE\";\n \tcase PhysicalOperatorType::FIXED_BATCH_COPY_TO_FILE:\n \t\treturn \"FIXED_BATCH_COPY_TO_FILE\";\n-\tcase PhysicalOperatorType::DELIM_JOIN:\n-\t\treturn \"DELIM_JOIN\";\n+\tcase PhysicalOperatorType::LEFT_DELIM_JOIN:\n+\t\treturn \"LEFT_DELIM_JOIN\";\n+\tcase PhysicalOperatorType::RIGHT_DELIM_JOIN:\n+\t\treturn \"RIGHT_DELIM_JOIN\";\n \tcase PhysicalOperatorType::BLOCKWISE_NL_JOIN:\n \t\treturn \"BLOCKWISE_NL_JOIN\";\n \tcase PhysicalOperatorType::NESTED_LOOP_JOIN:\ndiff --git a/src/common/tree_renderer.cpp b/src/common/tree_renderer.cpp\nindex 1ce04df6dd04..c3cd19803866 100644\n--- a/src/common/tree_renderer.cpp\n+++ b/src/common/tree_renderer.cpp\n@@ -1,12 +1,13 @@\n #include \"duckdb/common/tree_renderer.hpp\"\n-#include \"duckdb/planner/logical_operator.hpp\"\n-#include \"duckdb/execution/physical_operator.hpp\"\n-#include \"duckdb/common/string_util.hpp\"\n+\n #include \"duckdb/common/pair.hpp\"\n-#include \"duckdb/execution/operator/join/physical_delim_join.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/execution/operator/aggregate/physical_hash_aggregate.hpp\"\n+#include \"duckdb/execution/operator/join/physical_delim_join.hpp\"\n #include \"duckdb/execution/operator/scan/physical_positional_scan.hpp\"\n+#include \"duckdb/execution/physical_operator.hpp\"\n #include \"duckdb/parallel/pipeline.hpp\"\n+#include \"duckdb/planner/logical_operator.hpp\"\n #include \"utf8proc_wrapper.hpp\"\n \n #include <sstream>\n@@ -378,7 +379,8 @@ class TreeChildrenIterator {\n template <>\n bool TreeChildrenIterator::HasChildren(const PhysicalOperator &op) {\n \tswitch (op.type) {\n-\tcase PhysicalOperatorType::DELIM_JOIN:\n+\tcase PhysicalOperatorType::LEFT_DELIM_JOIN:\n+\tcase PhysicalOperatorType::RIGHT_DELIM_JOIN:\n \tcase PhysicalOperatorType::POSITIONAL_SCAN:\n \t\treturn true;\n \tdefault:\n@@ -391,7 +393,7 @@ void TreeChildrenIterator::Iterate(const PhysicalOperator &op,\n \tfor (auto &child : op.children) {\n \t\tcallback(*child);\n \t}\n-\tif (op.type == PhysicalOperatorType::DELIM_JOIN) {\n+\tif (op.type == PhysicalOperatorType::LEFT_DELIM_JOIN || op.type == PhysicalOperatorType::RIGHT_DELIM_JOIN) {\n \t\tauto &delim = op.Cast<PhysicalDelimJoin>();\n \t\tcallback(*delim.join);\n \t} else if ((op.type == PhysicalOperatorType::POSITIONAL_SCAN)) {\ndiff --git a/src/execution/column_binding_resolver.cpp b/src/execution/column_binding_resolver.cpp\nindex 1bb2a74e0bd2..ea4b2dc7c80d 100644\n--- a/src/execution/column_binding_resolver.cpp\n+++ b/src/execution/column_binding_resolver.cpp\n@@ -1,16 +1,14 @@\n #include \"duckdb/execution/column_binding_resolver.hpp\"\n \n-#include \"duckdb/planner/operator/logical_comparison_join.hpp\"\n+#include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n+#include \"duckdb/common/to_string.hpp\"\n+#include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_reference_expression.hpp\"\n #include \"duckdb/planner/operator/logical_any_join.hpp\"\n+#include \"duckdb/planner/operator/logical_comparison_join.hpp\"\n #include \"duckdb/planner/operator/logical_create_index.hpp\"\n-#include \"duckdb/planner/operator/logical_insert.hpp\"\n #include \"duckdb/planner/operator/logical_extension_operator.hpp\"\n-\n-#include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n-#include \"duckdb/planner/expression/bound_reference_expression.hpp\"\n-\n-#include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n-#include \"duckdb/common/to_string.hpp\"\n+#include \"duckdb/planner/operator/logical_insert.hpp\"\n \n namespace duckdb {\n \n@@ -20,8 +18,7 @@ ColumnBindingResolver::ColumnBindingResolver() {\n void ColumnBindingResolver::VisitOperator(LogicalOperator &op) {\n \tswitch (op.type) {\n \tcase LogicalOperatorType::LOGICAL_ASOF_JOIN:\n-\tcase LogicalOperatorType::LOGICAL_COMPARISON_JOIN:\n-\tcase LogicalOperatorType::LOGICAL_DELIM_JOIN: {\n+\tcase LogicalOperatorType::LOGICAL_COMPARISON_JOIN: {\n \t\t// special case: comparison join\n \t\tauto &comp_join = op.Cast<LogicalComparisonJoin>();\n \t\t// first get the bindings of the LHS and resolve the LHS expressions\n@@ -42,6 +39,40 @@ void ColumnBindingResolver::VisitOperator(LogicalOperator &op) {\n \t\tbindings = op.GetColumnBindings();\n \t\treturn;\n \t}\n+\tcase LogicalOperatorType::LOGICAL_DELIM_JOIN: {\n+\t\tauto &comp_join = op.Cast<LogicalComparisonJoin>();\n+\t\t// depending on whether the delim join has been flipped, get the appropriate bindings\n+\t\tif (comp_join.delim_flipped) {\n+\t\t\tVisitOperator(*comp_join.children[1]);\n+\t\t\tfor (auto &cond : comp_join.conditions) {\n+\t\t\t\tVisitExpression(&cond.right);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tVisitOperator(*comp_join.children[0]);\n+\t\t\tfor (auto &cond : comp_join.conditions) {\n+\t\t\t\tVisitExpression(&cond.left);\n+\t\t\t}\n+\t\t}\n+\t\t// visit the duplicate eliminated columns\n+\t\tfor (auto &expr : comp_join.duplicate_eliminated_columns) {\n+\t\t\tVisitExpression(&expr);\n+\t\t}\n+\t\t// now get the other side\n+\t\tif (comp_join.delim_flipped) {\n+\t\t\tVisitOperator(*comp_join.children[0]);\n+\t\t\tfor (auto &cond : comp_join.conditions) {\n+\t\t\t\tVisitExpression(&cond.left);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tVisitOperator(*comp_join.children[1]);\n+\t\t\tfor (auto &cond : comp_join.conditions) {\n+\t\t\t\tVisitExpression(&cond.right);\n+\t\t\t}\n+\t\t}\n+\t\t// finally update the bindings with the result bindings of the join\n+\t\tbindings = op.GetColumnBindings();\n+\t\treturn;\n+\t}\n \tcase LogicalOperatorType::LOGICAL_ANY_JOIN: {\n \t\t// ANY join, this join is different because we evaluate the expression on the bindings of BOTH join sides at\n \t\t// once i.e. we set the bindings first to the bindings of the entire join, and then resolve the expressions of\ndiff --git a/src/execution/operator/join/CMakeLists.txt b/src/execution/operator/join/CMakeLists.txt\nindex 50e9f0fdc964..9adfabb8fff8 100644\n--- a/src/execution/operator/join/CMakeLists.txt\n+++ b/src/execution/operator/join/CMakeLists.txt\n@@ -7,6 +7,7 @@ add_library_unity(\n   physical_comparison_join.cpp\n   physical_cross_product.cpp\n   physical_delim_join.cpp\n+  physical_left_delim_join.cpp\n   physical_hash_join.cpp\n   physical_iejoin.cpp\n   physical_join.cpp\n@@ -14,7 +15,8 @@ add_library_unity(\n   perfect_hash_join_executor.cpp\n   physical_piecewise_merge_join.cpp\n   physical_positional_join.cpp\n-  physical_range_join.cpp)\n+  physical_range_join.cpp\n+  physical_right_delim_join.cpp)\n set(ALL_OBJECT_FILES\n     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_operator_join>\n     PARENT_SCOPE)\ndiff --git a/src/execution/operator/join/physical_delim_join.cpp b/src/execution/operator/join/physical_delim_join.cpp\nindex 487fc35dfd46..5d9f2806f9c3 100644\n--- a/src/execution/operator/join/physical_delim_join.cpp\n+++ b/src/execution/operator/join/physical_delim_join.cpp\n@@ -1,30 +1,15 @@\n #include \"duckdb/execution/operator/join/physical_delim_join.hpp\"\n \n-#include \"duckdb/common/types/column/column_data_collection.hpp\"\n-#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n #include \"duckdb/execution/operator/aggregate/physical_hash_aggregate.hpp\"\n-#include \"duckdb/execution/operator/scan/physical_column_data_scan.hpp\"\n-#include \"duckdb/execution/operator/set/physical_recursive_cte.hpp\"\n-#include \"duckdb/parallel/meta_pipeline.hpp\"\n-#include \"duckdb/parallel/pipeline.hpp\"\n-#include \"duckdb/parallel/thread_context.hpp\"\n \n namespace duckdb {\n \n-PhysicalDelimJoin::PhysicalDelimJoin(vector<LogicalType> types, unique_ptr<PhysicalOperator> original_join,\n+PhysicalDelimJoin::PhysicalDelimJoin(PhysicalOperatorType type, vector<LogicalType> types,\n+                                     unique_ptr<PhysicalOperator> original_join,\n                                      vector<const_reference<PhysicalOperator>> delim_scans, idx_t estimated_cardinality)\n-    : PhysicalOperator(PhysicalOperatorType::DELIM_JOIN, std::move(types), estimated_cardinality),\n-      join(std::move(original_join)), delim_scans(std::move(delim_scans)) {\n-\tD_ASSERT(join->children.size() == 2);\n-\t// now for the original join\n-\t// we take its left child, this is the side that we will duplicate eliminate\n-\tchildren.push_back(std::move(join->children[0]));\n-\n-\t// we replace it with a PhysicalColumnDataScan, that scans the ColumnDataCollection that we keep cached\n-\t// the actual chunk collection to scan will be created in the DelimJoinGlobalState\n-\tauto cached_chunk_scan = make_uniq<PhysicalColumnDataScan>(\n-\t    children[0]->GetTypes(), PhysicalOperatorType::COLUMN_DATA_SCAN, estimated_cardinality);\n-\tjoin->children[0] = std::move(cached_chunk_scan);\n+    : PhysicalOperator(type, std::move(types), estimated_cardinality), join(std::move(original_join)),\n+      delim_scans(std::move(delim_scans)) {\n+\tD_ASSERT(type == PhysicalOperatorType::LEFT_DELIM_JOIN || type == PhysicalOperatorType::RIGHT_DELIM_JOIN);\n }\n \n vector<const_reference<PhysicalOperator>> PhysicalDelimJoin::GetChildren() const {\n@@ -37,115 +22,8 @@ vector<const_reference<PhysicalOperator>> PhysicalDelimJoin::GetChildren() const\n \treturn result;\n }\n \n-//===--------------------------------------------------------------------===//\n-// Sink\n-//===--------------------------------------------------------------------===//\n-class DelimJoinGlobalState : public GlobalSinkState {\n-public:\n-\texplicit DelimJoinGlobalState(ClientContext &context, const PhysicalDelimJoin &delim_join)\n-\t    : lhs_data(context, delim_join.children[0]->GetTypes()) {\n-\t\tD_ASSERT(delim_join.delim_scans.size() > 0);\n-\t\t// set up the delim join chunk to scan in the original join\n-\t\tauto &cached_chunk_scan = delim_join.join->children[0]->Cast<PhysicalColumnDataScan>();\n-\t\tcached_chunk_scan.collection = &lhs_data;\n-\t}\n-\n-\tColumnDataCollection lhs_data;\n-\tmutex lhs_lock;\n-\n-\tvoid Merge(ColumnDataCollection &input) {\n-\t\tlock_guard<mutex> guard(lhs_lock);\n-\t\tlhs_data.Combine(input);\n-\t}\n-};\n-\n-class DelimJoinLocalState : public LocalSinkState {\n-public:\n-\texplicit DelimJoinLocalState(ClientContext &context, const PhysicalDelimJoin &delim_join)\n-\t    : lhs_data(context, delim_join.children[0]->GetTypes()) {\n-\t\tlhs_data.InitializeAppend(append_state);\n-\t}\n-\n-\tunique_ptr<LocalSinkState> distinct_state;\n-\tColumnDataCollection lhs_data;\n-\tColumnDataAppendState append_state;\n-\n-\tvoid Append(DataChunk &input) {\n-\t\tlhs_data.Append(input);\n-\t}\n-};\n-\n-unique_ptr<GlobalSinkState> PhysicalDelimJoin::GetGlobalSinkState(ClientContext &context) const {\n-\tauto state = make_uniq<DelimJoinGlobalState>(context, *this);\n-\tdistinct->sink_state = distinct->GetGlobalSinkState(context);\n-\tif (delim_scans.size() > 1) {\n-\t\tPhysicalHashAggregate::SetMultiScan(*distinct->sink_state);\n-\t}\n-\treturn std::move(state);\n-}\n-\n-unique_ptr<LocalSinkState> PhysicalDelimJoin::GetLocalSinkState(ExecutionContext &context) const {\n-\tauto state = make_uniq<DelimJoinLocalState>(context.client, *this);\n-\tstate->distinct_state = distinct->GetLocalSinkState(context);\n-\treturn std::move(state);\n-}\n-\n-SinkResultType PhysicalDelimJoin::Sink(ExecutionContext &context, DataChunk &chunk, OperatorSinkInput &input) const {\n-\tauto &lstate = input.local_state.Cast<DelimJoinLocalState>();\n-\tlstate.lhs_data.Append(lstate.append_state, chunk);\n-\tOperatorSinkInput distinct_sink_input {*distinct->sink_state, *lstate.distinct_state, input.interrupt_state};\n-\tdistinct->Sink(context, chunk, distinct_sink_input);\n-\treturn SinkResultType::NEED_MORE_INPUT;\n-}\n-\n-SinkCombineResultType PhysicalDelimJoin::Combine(ExecutionContext &context, OperatorSinkCombineInput &input) const {\n-\tauto &lstate = input.local_state.Cast<DelimJoinLocalState>();\n-\tauto &gstate = input.global_state.Cast<DelimJoinGlobalState>();\n-\tgstate.Merge(lstate.lhs_data);\n-\n-\tOperatorSinkCombineInput distinct_combine_input {*distinct->sink_state, *lstate.distinct_state,\n-\t                                                 input.interrupt_state};\n-\tdistinct->Combine(context, distinct_combine_input);\n-\n-\treturn SinkCombineResultType::FINISHED;\n-}\n-\n-SinkFinalizeType PhysicalDelimJoin::Finalize(Pipeline &pipeline, Event &event, ClientContext &client,\n-                                             OperatorSinkFinalizeInput &input) const {\n-\t// finalize the distinct HT\n-\tD_ASSERT(distinct);\n-\n-\tOperatorSinkFinalizeInput finalize_input {*distinct->sink_state, input.interrupt_state};\n-\tdistinct->Finalize(pipeline, event, client, finalize_input);\n-\treturn SinkFinalizeType::READY;\n-}\n-\n string PhysicalDelimJoin::ParamsToString() const {\n \treturn join->ParamsToString();\n }\n \n-//===--------------------------------------------------------------------===//\n-// Pipeline Construction\n-//===--------------------------------------------------------------------===//\n-void PhysicalDelimJoin::BuildPipelines(Pipeline &current, MetaPipeline &meta_pipeline) {\n-\top_state.reset();\n-\tsink_state.reset();\n-\n-\tauto &child_meta_pipeline = meta_pipeline.CreateChildMetaPipeline(current, *this);\n-\tchild_meta_pipeline.Build(*children[0]);\n-\n-\tif (type == PhysicalOperatorType::DELIM_JOIN) {\n-\t\t// recurse into the actual join\n-\t\t// any pipelines in there depend on the main pipeline\n-\t\t// any scan of the duplicate eliminated data on the RHS depends on this pipeline\n-\t\t// we add an entry to the mapping of (PhysicalOperator*) -> (Pipeline*)\n-\t\tauto &state = meta_pipeline.GetState();\n-\t\tfor (auto &delim_scan : delim_scans) {\n-\t\t\tstate.delim_join_dependencies.insert(\n-\t\t\t    make_pair(delim_scan, reference<Pipeline>(*child_meta_pipeline.GetBasePipeline())));\n-\t\t}\n-\t\tjoin->BuildPipelines(current, meta_pipeline);\n-\t}\n-}\n-\n } // namespace duckdb\ndiff --git a/src/execution/operator/join/physical_join.cpp b/src/execution/operator/join/physical_join.cpp\nindex 46d4535ee509..d4fb21e9adab 100644\n--- a/src/execution/operator/join/physical_join.cpp\n+++ b/src/execution/operator/join/physical_join.cpp\n@@ -28,7 +28,8 @@ bool PhysicalJoin::EmptyResultIfRHSIsEmpty() const {\n //===--------------------------------------------------------------------===//\n // Pipeline Construction\n //===--------------------------------------------------------------------===//\n-void PhysicalJoin::BuildJoinPipelines(Pipeline &current, MetaPipeline &meta_pipeline, PhysicalOperator &op) {\n+void PhysicalJoin::BuildJoinPipelines(Pipeline &current, MetaPipeline &meta_pipeline, PhysicalOperator &op,\n+                                      bool build_rhs) {\n \top.op_state.reset();\n \top.sink_state.reset();\n \n@@ -41,9 +42,11 @@ void PhysicalJoin::BuildJoinPipelines(Pipeline &current, MetaPipeline &meta_pipe\n \tmeta_pipeline.GetPipelines(pipelines_so_far, false);\n \tauto last_pipeline = pipelines_so_far.back().get();\n \n-\t// on the RHS (build side), we construct a child MetaPipeline with this operator as its sink\n-\tauto &child_meta_pipeline = meta_pipeline.CreateChildMetaPipeline(current, op);\n-\tchild_meta_pipeline.Build(*op.children[1]);\n+\tif (build_rhs) {\n+\t\t// on the RHS (build side), we construct a child MetaPipeline with this operator as its sink\n+\t\tauto &child_meta_pipeline = meta_pipeline.CreateChildMetaPipeline(current, op);\n+\t\tchild_meta_pipeline.Build(*op.children[1]);\n+\t}\n \n \t// continue building the current pipeline on the LHS (probe side)\n \top.children[0]->BuildPipelines(current, meta_pipeline);\ndiff --git a/src/execution/operator/join/physical_left_delim_join.cpp b/src/execution/operator/join/physical_left_delim_join.cpp\nnew file mode 100644\nindex 000000000000..04a6ce80d1a7\n--- /dev/null\n+++ b/src/execution/operator/join/physical_left_delim_join.cpp\n@@ -0,0 +1,137 @@\n+#include \"duckdb/execution/operator/join/physical_left_delim_join.hpp\"\n+\n+#include \"duckdb/common/types/column/column_data_collection.hpp\"\n+#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n+#include \"duckdb/execution/operator/aggregate/physical_hash_aggregate.hpp\"\n+#include \"duckdb/execution/operator/scan/physical_column_data_scan.hpp\"\n+#include \"duckdb/parallel/meta_pipeline.hpp\"\n+#include \"duckdb/parallel/pipeline.hpp\"\n+#include \"duckdb/parallel/thread_context.hpp\"\n+\n+namespace duckdb {\n+\n+PhysicalLeftDelimJoin::PhysicalLeftDelimJoin(vector<LogicalType> types, unique_ptr<PhysicalOperator> original_join,\n+                                             vector<const_reference<PhysicalOperator>> delim_scans,\n+                                             idx_t estimated_cardinality)\n+    : PhysicalDelimJoin(PhysicalOperatorType::LEFT_DELIM_JOIN, std::move(types), std::move(original_join),\n+                        std::move(delim_scans), estimated_cardinality) {\n+\tD_ASSERT(join->children.size() == 2);\n+\t// now for the original join\n+\t// we take its left child, this is the side that we will duplicate eliminate\n+\tchildren.push_back(std::move(join->children[0]));\n+\n+\t// we replace it with a PhysicalColumnDataScan, that scans the ColumnDataCollection that we keep cached\n+\t// the actual chunk collection to scan will be created in the LeftDelimJoinGlobalState\n+\tauto cached_chunk_scan = make_uniq<PhysicalColumnDataScan>(\n+\t    children[0]->GetTypes(), PhysicalOperatorType::COLUMN_DATA_SCAN, estimated_cardinality);\n+\tjoin->children[0] = std::move(cached_chunk_scan);\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// Sink\n+//===--------------------------------------------------------------------===//\n+class LeftDelimJoinGlobalState : public GlobalSinkState {\n+public:\n+\texplicit LeftDelimJoinGlobalState(ClientContext &context, const PhysicalLeftDelimJoin &delim_join)\n+\t    : lhs_data(context, delim_join.children[0]->GetTypes()) {\n+\t\tD_ASSERT(!delim_join.delim_scans.empty());\n+\t\t// set up the delim join chunk to scan in the original join\n+\t\tauto &cached_chunk_scan = delim_join.join->children[0]->Cast<PhysicalColumnDataScan>();\n+\t\tcached_chunk_scan.collection = &lhs_data;\n+\t}\n+\n+\tColumnDataCollection lhs_data;\n+\tmutex lhs_lock;\n+\n+\tvoid Merge(ColumnDataCollection &input) {\n+\t\tlock_guard<mutex> guard(lhs_lock);\n+\t\tlhs_data.Combine(input);\n+\t}\n+};\n+\n+class LeftDelimJoinLocalState : public LocalSinkState {\n+public:\n+\texplicit LeftDelimJoinLocalState(ClientContext &context, const PhysicalLeftDelimJoin &delim_join)\n+\t    : lhs_data(context, delim_join.children[0]->GetTypes()) {\n+\t\tlhs_data.InitializeAppend(append_state);\n+\t}\n+\n+\tunique_ptr<LocalSinkState> distinct_state;\n+\tColumnDataCollection lhs_data;\n+\tColumnDataAppendState append_state;\n+\n+\tvoid Append(DataChunk &input) {\n+\t\tlhs_data.Append(input);\n+\t}\n+};\n+\n+unique_ptr<GlobalSinkState> PhysicalLeftDelimJoin::GetGlobalSinkState(ClientContext &context) const {\n+\tauto state = make_uniq<LeftDelimJoinGlobalState>(context, *this);\n+\tdistinct->sink_state = distinct->GetGlobalSinkState(context);\n+\tif (delim_scans.size() > 1) {\n+\t\tPhysicalHashAggregate::SetMultiScan(*distinct->sink_state);\n+\t}\n+\treturn std::move(state);\n+}\n+\n+unique_ptr<LocalSinkState> PhysicalLeftDelimJoin::GetLocalSinkState(ExecutionContext &context) const {\n+\tauto state = make_uniq<LeftDelimJoinLocalState>(context.client, *this);\n+\tstate->distinct_state = distinct->GetLocalSinkState(context);\n+\treturn std::move(state);\n+}\n+\n+SinkResultType PhysicalLeftDelimJoin::Sink(ExecutionContext &context, DataChunk &chunk,\n+                                           OperatorSinkInput &input) const {\n+\tauto &lstate = input.local_state.Cast<LeftDelimJoinLocalState>();\n+\tlstate.lhs_data.Append(lstate.append_state, chunk);\n+\tOperatorSinkInput distinct_sink_input {*distinct->sink_state, *lstate.distinct_state, input.interrupt_state};\n+\tdistinct->Sink(context, chunk, distinct_sink_input);\n+\treturn SinkResultType::NEED_MORE_INPUT;\n+}\n+\n+SinkCombineResultType PhysicalLeftDelimJoin::Combine(ExecutionContext &context, OperatorSinkCombineInput &input) const {\n+\tauto &lstate = input.local_state.Cast<LeftDelimJoinLocalState>();\n+\tauto &gstate = input.global_state.Cast<LeftDelimJoinGlobalState>();\n+\tgstate.Merge(lstate.lhs_data);\n+\n+\tOperatorSinkCombineInput distinct_combine_input {*distinct->sink_state, *lstate.distinct_state,\n+\t                                                 input.interrupt_state};\n+\tdistinct->Combine(context, distinct_combine_input);\n+\n+\treturn SinkCombineResultType::FINISHED;\n+}\n+\n+SinkFinalizeType PhysicalLeftDelimJoin::Finalize(Pipeline &pipeline, Event &event, ClientContext &client,\n+                                                 OperatorSinkFinalizeInput &input) const {\n+\t// finalize the distinct HT\n+\tD_ASSERT(distinct);\n+\n+\tOperatorSinkFinalizeInput finalize_input {*distinct->sink_state, input.interrupt_state};\n+\tdistinct->Finalize(pipeline, event, client, finalize_input);\n+\treturn SinkFinalizeType::READY;\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// Pipeline Construction\n+//===--------------------------------------------------------------------===//\n+void PhysicalLeftDelimJoin::BuildPipelines(Pipeline &current, MetaPipeline &meta_pipeline) {\n+\top_state.reset();\n+\tsink_state.reset();\n+\n+\tauto &child_meta_pipeline = meta_pipeline.CreateChildMetaPipeline(current, *this);\n+\tchild_meta_pipeline.Build(*children[0]);\n+\n+\tD_ASSERT(type == PhysicalOperatorType::LEFT_DELIM_JOIN);\n+\t// recurse into the actual join\n+\t// any pipelines in there depend on the main pipeline\n+\t// any scan of the duplicate eliminated data on the RHS depends on this pipeline\n+\t// we add an entry to the mapping of (PhysicalOperator*) -> (Pipeline*)\n+\tauto &state = meta_pipeline.GetState();\n+\tfor (auto &delim_scan : delim_scans) {\n+\t\tstate.delim_join_dependencies.insert(\n+\t\t    make_pair(delim_scan, reference<Pipeline>(*child_meta_pipeline.GetBasePipeline())));\n+\t}\n+\tjoin->BuildPipelines(current, meta_pipeline);\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/execution/operator/join/physical_right_delim_join.cpp b/src/execution/operator/join/physical_right_delim_join.cpp\nnew file mode 100644\nindex 000000000000..aad86786812f\n--- /dev/null\n+++ b/src/execution/operator/join/physical_right_delim_join.cpp\n@@ -0,0 +1,121 @@\n+#include \"duckdb/execution/operator/join/physical_right_delim_join.hpp\"\n+\n+#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n+#include \"duckdb/execution/operator/aggregate/physical_hash_aggregate.hpp\"\n+#include \"duckdb/execution/operator/join/physical_join.hpp\"\n+#include \"duckdb/execution/operator/scan/physical_dummy_scan.hpp\"\n+#include \"duckdb/parallel/meta_pipeline.hpp\"\n+#include \"duckdb/parallel/pipeline.hpp\"\n+#include \"duckdb/parallel/thread_context.hpp\"\n+\n+namespace duckdb {\n+\n+PhysicalRightDelimJoin::PhysicalRightDelimJoin(vector<LogicalType> types, unique_ptr<PhysicalOperator> original_join,\n+                                               vector<const_reference<PhysicalOperator>> delim_scans,\n+                                               idx_t estimated_cardinality)\n+    : PhysicalDelimJoin(PhysicalOperatorType::RIGHT_DELIM_JOIN, std::move(types), std::move(original_join),\n+                        std::move(delim_scans), estimated_cardinality) {\n+\tD_ASSERT(join->children.size() == 2);\n+\t// now for the original join\n+\t// we take its right child, this is the side that we will duplicate eliminate\n+\tchildren.push_back(std::move(join->children[1]));\n+\n+\t// we replace it with a PhysicalDummyScan, which contains no data, just the types, it won't be scanned anyway\n+\tjoin->children[1] = make_uniq<PhysicalDummyScan>(children[0]->GetTypes(), estimated_cardinality);\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// Sink\n+//===--------------------------------------------------------------------===//\n+class RightDelimJoinGlobalState : public GlobalSinkState {};\n+\n+class RightDelimJoinLocalState : public LocalSinkState {\n+public:\n+\tunique_ptr<LocalSinkState> join_state;\n+\tunique_ptr<LocalSinkState> distinct_state;\n+};\n+\n+unique_ptr<GlobalSinkState> PhysicalRightDelimJoin::GetGlobalSinkState(ClientContext &context) const {\n+\tauto state = make_uniq<RightDelimJoinGlobalState>();\n+\tjoin->sink_state = join->GetGlobalSinkState(context);\n+\tdistinct->sink_state = distinct->GetGlobalSinkState(context);\n+\tif (delim_scans.size() > 1) {\n+\t\tPhysicalHashAggregate::SetMultiScan(*distinct->sink_state);\n+\t}\n+\treturn std::move(state);\n+}\n+\n+unique_ptr<LocalSinkState> PhysicalRightDelimJoin::GetLocalSinkState(ExecutionContext &context) const {\n+\tauto state = make_uniq<RightDelimJoinLocalState>();\n+\tstate->join_state = join->GetLocalSinkState(context);\n+\tstate->distinct_state = distinct->GetLocalSinkState(context);\n+\treturn std::move(state);\n+}\n+\n+SinkResultType PhysicalRightDelimJoin::Sink(ExecutionContext &context, DataChunk &chunk,\n+                                            OperatorSinkInput &input) const {\n+\tauto &lstate = input.local_state.Cast<RightDelimJoinLocalState>();\n+\n+\tOperatorSinkInput join_sink_input {*join->sink_state, *lstate.join_state, input.interrupt_state};\n+\tjoin->Sink(context, chunk, join_sink_input);\n+\n+\tOperatorSinkInput distinct_sink_input {*distinct->sink_state, *lstate.distinct_state, input.interrupt_state};\n+\tdistinct->Sink(context, chunk, distinct_sink_input);\n+\n+\treturn SinkResultType::NEED_MORE_INPUT;\n+}\n+\n+SinkCombineResultType PhysicalRightDelimJoin::Combine(ExecutionContext &context,\n+                                                      OperatorSinkCombineInput &input) const {\n+\tauto &lstate = input.local_state.Cast<RightDelimJoinLocalState>();\n+\n+\tOperatorSinkCombineInput join_combine_input {*join->sink_state, *lstate.join_state, input.interrupt_state};\n+\tjoin->Combine(context, join_combine_input);\n+\n+\tOperatorSinkCombineInput distinct_combine_input {*distinct->sink_state, *lstate.distinct_state,\n+\t                                                 input.interrupt_state};\n+\tdistinct->Combine(context, distinct_combine_input);\n+\n+\treturn SinkCombineResultType::FINISHED;\n+}\n+\n+SinkFinalizeType PhysicalRightDelimJoin::Finalize(Pipeline &pipeline, Event &event, ClientContext &client,\n+                                                  OperatorSinkFinalizeInput &input) const {\n+\tD_ASSERT(join);\n+\tD_ASSERT(distinct);\n+\n+\tOperatorSinkFinalizeInput join_finalize_input {*join->sink_state, input.interrupt_state};\n+\tjoin->Finalize(pipeline, event, client, join_finalize_input);\n+\n+\tOperatorSinkFinalizeInput distinct_finalize_input {*distinct->sink_state, input.interrupt_state};\n+\tdistinct->Finalize(pipeline, event, client, distinct_finalize_input);\n+\n+\treturn SinkFinalizeType::READY;\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// Pipeline Construction\n+//===--------------------------------------------------------------------===//\n+void PhysicalRightDelimJoin::BuildPipelines(Pipeline &current, MetaPipeline &meta_pipeline) {\n+\top_state.reset();\n+\tsink_state.reset();\n+\n+\tauto &child_meta_pipeline = meta_pipeline.CreateChildMetaPipeline(current, *this);\n+\tchild_meta_pipeline.Build(*children[0]);\n+\n+\tD_ASSERT(type == PhysicalOperatorType::RIGHT_DELIM_JOIN);\n+\t// recurse into the actual join\n+\t// any pipelines in there depend on the main pipeline\n+\t// any scan of the duplicate eliminated data on the LHS depends on this pipeline\n+\t// we add an entry to the mapping of (PhysicalOperator*) -> (Pipeline*)\n+\tauto &state = meta_pipeline.GetState();\n+\tfor (auto &delim_scan : delim_scans) {\n+\t\tstate.delim_join_dependencies.insert(\n+\t\t    make_pair(delim_scan, reference<Pipeline>(*child_meta_pipeline.GetBasePipeline())));\n+\t}\n+\n+\t// Build join pipelines without building the RHS (already built in the Sink of this op)\n+\tPhysicalJoin::BuildJoinPipelines(current, meta_pipeline, *join, false);\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/execution/operator/scan/physical_column_data_scan.cpp b/src/execution/operator/scan/physical_column_data_scan.cpp\nindex 55c00b7a64f0..d91e7a5c364e 100644\n--- a/src/execution/operator/scan/physical_column_data_scan.cpp\n+++ b/src/execution/operator/scan/physical_column_data_scan.cpp\n@@ -1,7 +1,8 @@\n #include \"duckdb/execution/operator/scan/physical_column_data_scan.hpp\"\n \n-#include \"duckdb/execution/operator/join/physical_delim_join.hpp\"\n+#include \"duckdb/common/types/column/column_data_collection.hpp\"\n #include \"duckdb/execution/operator/aggregate/physical_hash_aggregate.hpp\"\n+#include \"duckdb/execution/operator/join/physical_delim_join.hpp\"\n #include \"duckdb/parallel/meta_pipeline.hpp\"\n #include \"duckdb/parallel/pipeline.hpp\"\n \n@@ -14,6 +15,11 @@ PhysicalColumnDataScan::PhysicalColumnDataScan(vector<LogicalType> types, Physic\n       owned_collection(std::move(owned_collection_p)) {\n }\n \n+PhysicalColumnDataScan::PhysicalColumnDataScan(vector<LogicalType> types, PhysicalOperatorType op_type,\n+                                               idx_t estimated_cardinality, idx_t cte_index)\n+    : PhysicalOperator(op_type, std::move(types), estimated_cardinality), collection(nullptr), cte_index(cte_index) {\n+}\n+\n class PhysicalColumnDataScanState : public GlobalSourceState {\n public:\n \texplicit PhysicalColumnDataScanState() : initialized(false) {\n@@ -58,7 +64,8 @@ void PhysicalColumnDataScan::BuildPipelines(Pipeline &current, MetaPipeline &met\n \t\tauto delim_dependency = entry->second.get().shared_from_this();\n \t\tauto delim_sink = state.GetPipelineSink(*delim_dependency);\n \t\tD_ASSERT(delim_sink);\n-\t\tD_ASSERT(delim_sink->type == PhysicalOperatorType::DELIM_JOIN);\n+\t\tD_ASSERT(delim_sink->type == PhysicalOperatorType::LEFT_DELIM_JOIN ||\n+\t\t         delim_sink->type == PhysicalOperatorType::RIGHT_DELIM_JOIN);\n \t\tauto &delim_join = delim_sink->Cast<PhysicalDelimJoin>();\n \t\tcurrent.AddDependency(delim_dependency);\n \t\tstate.SetPipelineSource(current, delim_join.distinct->Cast<PhysicalOperator>());\ndiff --git a/src/execution/physical_plan/plan_delim_join.cpp b/src/execution/physical_plan/plan_delim_join.cpp\nindex f30cb2591f59..ba4246b522d0 100644\n--- a/src/execution/physical_plan/plan_delim_join.cpp\n+++ b/src/execution/physical_plan/plan_delim_join.cpp\n@@ -1,9 +1,11 @@\n-#include \"duckdb/execution/operator/join/physical_delim_join.hpp\"\n+#include \"duckdb/common/enum_util.hpp\"\n+#include \"duckdb/execution/operator/aggregate/physical_hash_aggregate.hpp\"\n #include \"duckdb/execution/operator/join/physical_hash_join.hpp\"\n+#include \"duckdb/execution/operator/join/physical_left_delim_join.hpp\"\n+#include \"duckdb/execution/operator/join/physical_right_delim_join.hpp\"\n #include \"duckdb/execution/operator/projection/physical_projection.hpp\"\n #include \"duckdb/execution/physical_plan_generator.hpp\"\n #include \"duckdb/planner/expression/bound_reference_expression.hpp\"\n-#include \"duckdb/execution/operator/aggregate/physical_hash_aggregate.hpp\"\n \n namespace duckdb {\n \n@@ -22,11 +24,12 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::PlanDelimJoin(LogicalCompari\n \t// this should create a join, not a cross product\n \tD_ASSERT(plan && plan->type != PhysicalOperatorType::CROSS_PRODUCT);\n \t// duplicate eliminated join\n-\t// first gather the scans on the duplicate eliminated data set from the RHS\n+\t// first gather the scans on the duplicate eliminated data set from the delim side\n+\tconst idx_t delim_idx = op.delim_flipped ? 0 : 1;\n \tvector<const_reference<PhysicalOperator>> delim_scans;\n-\tGatherDelimScans(*plan->children[1], delim_scans);\n+\tGatherDelimScans(*plan->children[delim_idx], delim_scans);\n \tif (delim_scans.empty()) {\n-\t\t// no duplicate eliminated scans in the RHS!\n+\t\t// no duplicate eliminated scans in the delim side!\n \t\t// in this case we don't need to create a delim join\n \t\t// just push the normal join\n \t\treturn plan;\n@@ -40,7 +43,13 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::PlanDelimJoin(LogicalCompari\n \t\tdistinct_groups.push_back(make_uniq<BoundReferenceExpression>(bound_ref.return_type, bound_ref.index));\n \t}\n \t// now create the duplicate eliminated join\n-\tauto delim_join = make_uniq<PhysicalDelimJoin>(op.types, std::move(plan), delim_scans, op.estimated_cardinality);\n+\tunique_ptr<PhysicalDelimJoin> delim_join;\n+\tif (op.delim_flipped) {\n+\t\tdelim_join =\n+\t\t    make_uniq<PhysicalRightDelimJoin>(op.types, std::move(plan), delim_scans, op.estimated_cardinality);\n+\t} else {\n+\t\tdelim_join = make_uniq<PhysicalLeftDelimJoin>(op.types, std::move(plan), delim_scans, op.estimated_cardinality);\n+\t}\n \t// we still have to create the DISTINCT clause that is used to generate the duplicate eliminated chunk\n \tdelim_join->distinct = make_uniq<PhysicalHashAggregate>(context, delim_types, std::move(distinct_expressions),\n \t                                                        std::move(distinct_groups), op.estimated_cardinality);\ndiff --git a/src/include/duckdb/common/enums/join_type.hpp b/src/include/duckdb/common/enums/join_type.hpp\nindex 4c9529768f21..4b3446963eaf 100644\n--- a/src/include/duckdb/common/enums/join_type.hpp\n+++ b/src/include/duckdb/common/enums/join_type.hpp\n@@ -39,9 +39,15 @@ bool IsLeftOuterJoin(JoinType type);\n //! True if join is rght or full outer join\n bool IsRightOuterJoin(JoinType type);\n \n-//!\n+//! Whether the build side is propagated out of the join\n bool PropagatesBuildSide(JoinType type);\n \n+//! Whether the JoinType has an inverse\n+bool HasInverseJoinType(JoinType type);\n+\n+//! Gets the inverse JoinType, e.g., LEFT -> RIGHT\n+JoinType InverseJoinType(JoinType type);\n+\n // **DEPRECATED**: Use EnumUtil directly instead.\n string JoinTypeToString(JoinType type);\n \ndiff --git a/src/include/duckdb/common/enums/physical_operator_type.hpp b/src/include/duckdb/common/enums/physical_operator_type.hpp\nindex 9ff5395f495a..3505953a46c2 100644\n--- a/src/include/duckdb/common/enums/physical_operator_type.hpp\n+++ b/src/include/duckdb/common/enums/physical_operator_type.hpp\n@@ -59,7 +59,8 @@ enum class PhysicalOperatorType : uint8_t {\n \tCROSS_PRODUCT,\n \tPIECEWISE_MERGE_JOIN,\n \tIE_JOIN,\n-\tDELIM_JOIN,\n+\tLEFT_DELIM_JOIN,\n+\tRIGHT_DELIM_JOIN,\n \tPOSITIONAL_JOIN,\n \tASOF_JOIN,\n \t// -----------------------------\ndiff --git a/src/include/duckdb/execution/operator/join/physical_delim_join.hpp b/src/include/duckdb/execution/operator/join/physical_delim_join.hpp\nindex 0e3a77540cbc..f58ab101b0a4 100644\n--- a/src/include/duckdb/execution/operator/join/physical_delim_join.hpp\n+++ b/src/include/duckdb/execution/operator/join/physical_delim_join.hpp\n@@ -12,16 +12,14 @@\n #include \"duckdb/execution/physical_operator.hpp\"\n \n namespace duckdb {\n+\n class PhysicalHashAggregate;\n \n-//! PhysicalDelimJoin represents a join where the LHS will be duplicate eliminated and pushed into a\n-//! PhysicalColumnDataScan in the RHS.\n+//! PhysicalDelimJoin represents a join where either the LHS or RHS will be duplicate eliminated and pushed into a\n+//! PhysicalColumnDataScan in the other side. Implementations are PhysicalLeftDelimJoin and PhysicalRightDelimJoin\n class PhysicalDelimJoin : public PhysicalOperator {\n public:\n-\tstatic constexpr const PhysicalOperatorType TYPE = PhysicalOperatorType::DELIM_JOIN;\n-\n-public:\n-\tPhysicalDelimJoin(vector<LogicalType> types, unique_ptr<PhysicalOperator> original_join,\n+\tPhysicalDelimJoin(PhysicalOperatorType type, vector<LogicalType> types, unique_ptr<PhysicalOperator> original_join,\n \t                  vector<const_reference<PhysicalOperator>> delim_scans, idx_t estimated_cardinality);\n \n \tunique_ptr<PhysicalOperator> join;\n@@ -31,14 +29,6 @@ class PhysicalDelimJoin : public PhysicalOperator {\n public:\n \tvector<const_reference<PhysicalOperator>> GetChildren() const override;\n \n-public:\n-\tunique_ptr<GlobalSinkState> GetGlobalSinkState(ClientContext &context) const override;\n-\tunique_ptr<LocalSinkState> GetLocalSinkState(ExecutionContext &context) const override;\n-\tSinkResultType Sink(ExecutionContext &context, DataChunk &chunk, OperatorSinkInput &input) const override;\n-\tSinkCombineResultType Combine(ExecutionContext &context, OperatorSinkCombineInput &input) const override;\n-\tSinkFinalizeType Finalize(Pipeline &pipeline, Event &event, ClientContext &context,\n-\t                          OperatorSinkFinalizeInput &input) const override;\n-\n \tbool IsSink() const override {\n \t\treturn true;\n \t}\n@@ -51,10 +41,8 @@ class PhysicalDelimJoin : public PhysicalOperator {\n \tbool SinkOrderDependent() const override {\n \t\treturn false;\n \t}\n-\tstring ParamsToString() const override;\n \n-public:\n-\tvoid BuildPipelines(Pipeline &current, MetaPipeline &meta_pipeline) override;\n+\tstring ParamsToString() const override;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/execution/operator/join/physical_join.hpp b/src/include/duckdb/execution/operator/join/physical_join.hpp\nindex bcc25ebaaef1..2d92c37b082c 100644\n--- a/src/include/duckdb/execution/operator/join/physical_join.hpp\n+++ b/src/include/duckdb/execution/operator/join/physical_join.hpp\n@@ -33,7 +33,8 @@ class PhysicalJoin : public CachingPhysicalOperator {\n \t                                    bool has_null);\n \n public:\n-\tstatic void BuildJoinPipelines(Pipeline &current, MetaPipeline &confluent_pipelines, PhysicalOperator &op);\n+\tstatic void BuildJoinPipelines(Pipeline &current, MetaPipeline &confluent_pipelines, PhysicalOperator &op,\n+\t                               bool build_rhs = true);\n \tvoid BuildPipelines(Pipeline &current, MetaPipeline &meta_pipeline) override;\n \tvector<const_reference<PhysicalOperator>> GetSources() const override;\n \ndiff --git a/src/include/duckdb/execution/operator/join/physical_left_delim_join.hpp b/src/include/duckdb/execution/operator/join/physical_left_delim_join.hpp\nnew file mode 100644\nindex 000000000000..9c44a9a93f4e\n--- /dev/null\n+++ b/src/include/duckdb/execution/operator/join/physical_left_delim_join.hpp\n@@ -0,0 +1,37 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/execution/operator/join/physical_left_delim_join.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/execution/operator/join/physical_delim_join.hpp\"\n+\n+namespace duckdb {\n+\n+//! PhysicalLeftDelimJoin represents a join where the LHS will be duplicate eliminated and pushed into a\n+//! PhysicalColumnDataScan in the RHS.\n+class PhysicalLeftDelimJoin : public PhysicalDelimJoin {\n+public:\n+\tstatic constexpr const PhysicalOperatorType TYPE = PhysicalOperatorType::LEFT_DELIM_JOIN;\n+\n+public:\n+\tPhysicalLeftDelimJoin(vector<LogicalType> types, unique_ptr<PhysicalOperator> original_join,\n+\t                      vector<const_reference<PhysicalOperator>> delim_scans, idx_t estimated_cardinality);\n+\n+public:\n+\tunique_ptr<GlobalSinkState> GetGlobalSinkState(ClientContext &context) const override;\n+\tunique_ptr<LocalSinkState> GetLocalSinkState(ExecutionContext &context) const override;\n+\tSinkResultType Sink(ExecutionContext &context, DataChunk &chunk, OperatorSinkInput &input) const override;\n+\tSinkCombineResultType Combine(ExecutionContext &context, OperatorSinkCombineInput &input) const override;\n+\tSinkFinalizeType Finalize(Pipeline &pipeline, Event &event, ClientContext &context,\n+\t                          OperatorSinkFinalizeInput &input) const override;\n+\n+public:\n+\tvoid BuildPipelines(Pipeline &current, MetaPipeline &meta_pipeline) override;\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/execution/operator/join/physical_right_delim_join.hpp b/src/include/duckdb/execution/operator/join/physical_right_delim_join.hpp\nnew file mode 100644\nindex 000000000000..394cc58bfac7\n--- /dev/null\n+++ b/src/include/duckdb/execution/operator/join/physical_right_delim_join.hpp\n@@ -0,0 +1,37 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/execution/operator/join/physical_right_delim_join.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/execution/operator/join/physical_delim_join.hpp\"\n+\n+namespace duckdb {\n+\n+//! PhysicalRightDelimJoin represents a join where the RHS will be duplicate eliminated and pushed into a\n+//! PhysicalColumnDataScan in the LHS.\n+class PhysicalRightDelimJoin : public PhysicalDelimJoin {\n+public:\n+\tstatic constexpr const PhysicalOperatorType TYPE = PhysicalOperatorType::RIGHT_DELIM_JOIN;\n+\n+public:\n+\tPhysicalRightDelimJoin(vector<LogicalType> types, unique_ptr<PhysicalOperator> original_join,\n+\t                       vector<const_reference<PhysicalOperator>> delim_scans, idx_t estimated_cardinality);\n+\n+public:\n+\tunique_ptr<GlobalSinkState> GetGlobalSinkState(ClientContext &context) const override;\n+\tunique_ptr<LocalSinkState> GetLocalSinkState(ExecutionContext &context) const override;\n+\tSinkResultType Sink(ExecutionContext &context, DataChunk &chunk, OperatorSinkInput &input) const override;\n+\tSinkCombineResultType Combine(ExecutionContext &context, OperatorSinkCombineInput &input) const override;\n+\tSinkFinalizeType Finalize(Pipeline &pipeline, Event &event, ClientContext &context,\n+\t                          OperatorSinkFinalizeInput &input) const override;\n+\n+public:\n+\tvoid BuildPipelines(Pipeline &current, MetaPipeline &meta_pipeline) override;\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/execution/operator/scan/physical_column_data_scan.hpp b/src/include/duckdb/execution/operator/scan/physical_column_data_scan.hpp\nindex 17dc8edb4627..57e452fb57d3 100644\n--- a/src/include/duckdb/execution/operator/scan/physical_column_data_scan.hpp\n+++ b/src/include/duckdb/execution/operator/scan/physical_column_data_scan.hpp\n@@ -23,10 +23,7 @@ class PhysicalColumnDataScan : public PhysicalOperator {\n \t                       unique_ptr<ColumnDataCollection> owned_collection = nullptr);\n \n \tPhysicalColumnDataScan(vector<LogicalType> types, PhysicalOperatorType op_type, idx_t estimated_cardinality,\n-\t                       idx_t cte_index)\n-\t    : PhysicalOperator(op_type, std::move(types), estimated_cardinality), collection(nullptr),\n-\t      cte_index(cte_index) {\n-\t}\n+\t                       idx_t cte_index);\n \n \t// the column data collection to scan\n \toptional_ptr<ColumnDataCollection> collection;\ndiff --git a/src/include/duckdb/optimizer/deliminator.hpp b/src/include/duckdb/optimizer/deliminator.hpp\nindex 482c4064adce..fb6d1d913a5a 100644\n--- a/src/include/duckdb/optimizer/deliminator.hpp\n+++ b/src/include/duckdb/optimizer/deliminator.hpp\n@@ -25,13 +25,16 @@ class Deliminator {\n private:\n \t//! Finds DelimJoins and their corresponding DelimGets\n \tvoid FindCandidates(unique_ptr<LogicalOperator> &op, vector<DelimCandidate> &candidates);\n-\tvoid FindJoinWithDelimGet(unique_ptr<LogicalOperator> &op, DelimCandidate &candidate);\n+\tvoid FindJoinWithDelimGet(unique_ptr<LogicalOperator> &op, DelimCandidate &candidate, idx_t depth = 0);\n+\t//! Whether the DelimJoin is selective\n+\tbool HasSelection(const LogicalOperator &delim_join);\n \t//! Remove joins with a DelimGet\n \tbool RemoveJoinWithDelimGet(LogicalComparisonJoin &delim_join, const idx_t delim_get_count,\n \t                            unique_ptr<LogicalOperator> &join, bool &all_equality_conditions);\n \tbool RemoveInequalityJoinWithDelimGet(LogicalComparisonJoin &delim_join, const idx_t delim_get_count,\n \t                                      unique_ptr<LogicalOperator> &join,\n \t                                      const vector<ReplacementBinding> &replacement_bindings);\n+\tvoid TrySwitchSingleToLeft(LogicalComparisonJoin &delim_join);\n \n private:\n \toptional_ptr<LogicalOperator> root;\ndiff --git a/src/include/duckdb/optimizer/join_order/query_graph_manager.hpp b/src/include/duckdb/optimizer/join_order/query_graph_manager.hpp\nindex 4e5e08addb5f..79aa37fb9ea4 100644\n--- a/src/include/duckdb/optimizer/join_order/query_graph_manager.hpp\n+++ b/src/include/duckdb/optimizer/join_order/query_graph_manager.hpp\n@@ -90,7 +90,7 @@ class QueryGraphManager {\n \t//! (Basically we put lower expected cardinality columns on the build side, and larger\n \t//! tables on the probe side)\n \tunique_ptr<LogicalOperator> LeftRightOptimizations(unique_ptr<LogicalOperator> op);\n-\tvoid TryFlipChildren(LogicalOperator &op, JoinType inverse, idx_t cardinality_ratio = 1);\n+\tvoid TryFlipChildren(LogicalOperator &op, idx_t cardinality_ratio = 1);\n \n private:\n \tvector<reference<LogicalOperator>> filter_operators;\ndiff --git a/src/include/duckdb/planner/operator/logical_comparison_join.hpp b/src/include/duckdb/planner/operator/logical_comparison_join.hpp\nindex abcfafb0b38b..4cb62ca332f3 100644\n--- a/src/include/duckdb/planner/operator/logical_comparison_join.hpp\n+++ b/src/include/duckdb/planner/operator/logical_comparison_join.hpp\n@@ -31,6 +31,8 @@ class LogicalComparisonJoin : public LogicalJoin {\n \tvector<LogicalType> mark_types;\n \t//! The set of columns that will be duplicate eliminated from the LHS and pushed into the RHS\n \tvector<unique_ptr<Expression>> duplicate_eliminated_columns;\n+\t//! If this is a DelimJoin, whether it has been flipped to de-duplicating the RHS instead\n+\tbool delim_flipped = false;\n \n public:\n \tstring ParamsToString() const override;\ndiff --git a/src/include/duckdb/storage/serialization/logical_operator.json b/src/include/duckdb/storage/serialization/logical_operator.json\nindex bbdf3b5031e5..e40e7462f62b 100644\n--- a/src/include/duckdb/storage/serialization/logical_operator.json\n+++ b/src/include/duckdb/storage/serialization/logical_operator.json\n@@ -433,6 +433,12 @@\n         \"id\": 206,\n         \"name\": \"duplicate_eliminated_columns\",\n         \"type\": \"vector<Expression*>\"\n+      },\n+      {\n+        \"id\": 207,\n+        \"name\": \"delim_flipped\",\n+        \"type\": \"bool\",\n+        \"default\": \"false\"\n       }\n     ],\n     \"constructor\": [\"join_type\", \"type\"]\ndiff --git a/src/main/query_profiler.cpp b/src/main/query_profiler.cpp\nindex 26b17f046257..d8b80b1e4234 100644\n--- a/src/main/query_profiler.cpp\n+++ b/src/main/query_profiler.cpp\n@@ -9,7 +9,7 @@\n #include \"duckdb/common/tree_renderer.hpp\"\n #include \"duckdb/execution/expression_executor.hpp\"\n #include \"duckdb/execution/operator/helper/physical_execute.hpp\"\n-#include \"duckdb/execution/operator/join/physical_delim_join.hpp\"\n+#include \"duckdb/execution/operator/join/physical_left_delim_join.hpp\"\n #include \"duckdb/execution/physical_operator.hpp\"\n #include \"duckdb/main/client_config.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n@@ -101,7 +101,8 @@ bool QueryProfiler::OperatorRequiresProfiling(PhysicalOperatorType op_type) {\n \tcase PhysicalOperatorType::CROSS_PRODUCT:\n \tcase PhysicalOperatorType::PIECEWISE_MERGE_JOIN:\n \tcase PhysicalOperatorType::IE_JOIN:\n-\tcase PhysicalOperatorType::DELIM_JOIN:\n+\tcase PhysicalOperatorType::LEFT_DELIM_JOIN:\n+\tcase PhysicalOperatorType::RIGHT_DELIM_JOIN:\n \tcase PhysicalOperatorType::UNION:\n \tcase PhysicalOperatorType::RECURSIVE_CTE:\n \tcase PhysicalOperatorType::EMPTY_RESULT:\ndiff --git a/src/optimizer/deliminator.cpp b/src/optimizer/deliminator.cpp\nindex 0e45c4d86ee6..2771222e7af5 100644\n--- a/src/optimizer/deliminator.cpp\n+++ b/src/optimizer/deliminator.cpp\n@@ -1,7 +1,5 @@\n #include \"duckdb/optimizer/deliminator.hpp\"\n \n-#include \"duckdb/optimizer/join_order/join_order_optimizer.hpp\"\n-#include \"duckdb/optimizer/remove_duplicate_groups.hpp\"\n #include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n #include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n #include \"duckdb/planner/expression/bound_conjunction_expression.hpp\"\n@@ -10,9 +8,20 @@\n #include \"duckdb/planner/operator/logical_comparison_join.hpp\"\n #include \"duckdb/planner/operator/logical_delim_get.hpp\"\n #include \"duckdb/planner/operator/logical_filter.hpp\"\n+#include \"duckdb/planner/operator/logical_get.hpp\"\n+#include \"duckdb/planner/table_filter.hpp\"\n+\n+#include <algorithm>\n \n namespace duckdb {\n \n+struct JoinWithDelimGet {\n+\tJoinWithDelimGet(unique_ptr<LogicalOperator> &join_p, idx_t depth_p) : join(join_p), depth(depth_p) {\n+\t}\n+\treference<unique_ptr<LogicalOperator>> join;\n+\tidx_t depth;\n+};\n+\n struct DelimCandidate {\n public:\n \texplicit DelimCandidate(unique_ptr<LogicalOperator> &op, LogicalComparisonJoin &delim_join)\n@@ -22,7 +31,7 @@ struct DelimCandidate {\n public:\n \tunique_ptr<LogicalOperator> &op;\n \tLogicalComparisonJoin &delim_join;\n-\tvector<reference<unique_ptr<LogicalOperator>>> joins;\n+\tvector<JoinWithDelimGet> joins;\n \tidx_t delim_get_count;\n };\n \n@@ -42,15 +51,30 @@ unique_ptr<LogicalOperator> Deliminator::Optimize(unique_ptr<LogicalOperator> op\n \tvector<DelimCandidate> candidates;\n \tFindCandidates(op, candidates);\n \n+\tif (candidates.empty()) {\n+\t\treturn op;\n+\t}\n+\n \tfor (auto &candidate : candidates) {\n \t\tauto &delim_join = candidate.delim_join;\n \n+\t\t// Sort these so the deepest are first\n+\t\tstd::sort(candidate.joins.begin(), candidate.joins.end(),\n+\t\t          [](const JoinWithDelimGet &lhs, const JoinWithDelimGet &rhs) { return lhs.depth > rhs.depth; });\n+\n \t\tbool all_removed = true;\n+\t\tif (!candidate.joins.empty() && HasSelection(delim_join)) {\n+\t\t\t// Keep the deepest join with DelimGet in these cases,\n+\t\t\t// as the selection can greatly reduce the cost of the RHS child of the DelimJoin\n+\t\t\tcandidate.joins.erase(candidate.joins.begin());\n+\t\t\tall_removed = false;\n+\t\t}\n+\n \t\tbool all_equality_conditions = true;\n \t\tfor (auto &join : candidate.joins) {\n-\t\t\tall_removed =\n-\t\t\t    RemoveJoinWithDelimGet(delim_join, candidate.delim_get_count, join, all_equality_conditions) &&\n-\t\t\t    all_removed;\n+\t\t\tall_removed = RemoveJoinWithDelimGet(delim_join, candidate.delim_get_count, join.join.get(),\n+\t\t\t                                     all_equality_conditions) &&\n+\t\t\t              all_removed;\n \t\t}\n \n \t\t// Change type if there are no more duplicate-eliminated columns\n@@ -65,13 +89,18 @@ unique_ptr<LogicalOperator> Deliminator::Optimize(unique_ptr<LogicalOperator> op\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\n+\t\t// Only DelimJoins are ever created as SINGLE joins,\n+\t\t// and we can switch from SINGLE to LEFT if the RHS is de-duplicated by an aggr\n+\t\tif (delim_join.join_type == JoinType::SINGLE) {\n+\t\t\tTrySwitchSingleToLeft(delim_join);\n+\t\t}\n \t}\n \n \treturn op;\n }\n \n void Deliminator::FindCandidates(unique_ptr<LogicalOperator> &op, vector<DelimCandidate> &candidates) {\n-\t// Search children before adding, so the deepest candidates get added first\n \tfor (auto &child : op->children) {\n \t\tFindCandidates(child, candidates);\n \t}\n@@ -87,6 +116,33 @@ void Deliminator::FindCandidates(unique_ptr<LogicalOperator> &op, vector<DelimCa\n \tFindJoinWithDelimGet(op->children[1], candidate);\n }\n \n+bool Deliminator::HasSelection(const LogicalOperator &op) {\n+\t// TODO once we implement selectivity estimation using samples we need to use that here\n+\tswitch (op.type) {\n+\tcase LogicalOperatorType::LOGICAL_GET: {\n+\t\tauto &get = op.Cast<LogicalGet>();\n+\t\tfor (const auto &filter : get.table_filters.filters) {\n+\t\t\tif (filter.second->filter_type != TableFilterType::IS_NOT_NULL) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase LogicalOperatorType::LOGICAL_FILTER:\n+\t\treturn true;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\n+\tfor (auto &child : op.children) {\n+\t\tif (HasSelection(*child)) {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\treturn false;\n+}\n+\n static bool OperatorIsDelimGet(LogicalOperator &op) {\n \tif (op.type == LogicalOperatorType::LOGICAL_DELIM_GET) {\n \t\treturn true;\n@@ -98,20 +154,20 @@ static bool OperatorIsDelimGet(LogicalOperator &op) {\n \treturn false;\n }\n \n-void Deliminator::FindJoinWithDelimGet(unique_ptr<LogicalOperator> &op, DelimCandidate &candidate) {\n+void Deliminator::FindJoinWithDelimGet(unique_ptr<LogicalOperator> &op, DelimCandidate &candidate, idx_t depth) {\n \tif (op->type == LogicalOperatorType::LOGICAL_DELIM_JOIN) {\n-\t\tFindJoinWithDelimGet(op->children[0], candidate);\n+\t\tFindJoinWithDelimGet(op->children[0], candidate, depth + 1);\n \t} else if (op->type == LogicalOperatorType::LOGICAL_DELIM_GET) {\n \t\tcandidate.delim_get_count++;\n \t} else {\n \t\tfor (auto &child : op->children) {\n-\t\t\tFindJoinWithDelimGet(child, candidate);\n+\t\t\tFindJoinWithDelimGet(child, candidate, depth + 1);\n \t\t}\n \t}\n \n \tif (op->type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN &&\n \t    (OperatorIsDelimGet(*op->children[0]) || OperatorIsDelimGet(*op->children[1]))) {\n-\t\tcandidate.joins.emplace_back(op);\n+\t\tcandidate.joins.emplace_back(op, depth);\n \t}\n }\n \n@@ -230,8 +286,8 @@ bool Deliminator::RemoveInequalityJoinWithDelimGet(LogicalComparisonJoin &delim_\n \t}\n \n \t// TODO: we cannot perform the optimization here because our pure inequality joins don't implement\n-\t//  JoinType::SINGLE yet\n-\tif (delim_join.join_type == JoinType::SINGLE) {\n+\t//  JoinType::SINGLE yet, and JoinType::MARK is a special case\n+\tif (delim_join.join_type == JoinType::SINGLE || delim_join.join_type == JoinType::MARK) {\n \t\tbool has_one_equality = false;\n \t\tfor (auto &cond : join_conditions) {\n \t\t\thas_one_equality = has_one_equality || IsEqualityJoinCondition(cond);\n@@ -283,7 +339,22 @@ bool Deliminator::RemoveInequalityJoinWithDelimGet(LogicalComparisonJoin &delim_\n \t\t\tauto &delim_side = delim_idx == 0 ? *join_condition.left : *join_condition.right;\n \t\t\tauto &colref = delim_side.Cast<BoundColumnRefExpression>();\n \t\t\tif (colref.binding == traced_binding) {\n-\t\t\t\tdelim_condition.comparison = FlipComparisonExpression(join_condition.comparison);\n+\t\t\t\tauto join_comparison = join_condition.comparison;\n+\t\t\t\tif (delim_condition.comparison == ExpressionType::COMPARE_DISTINCT_FROM ||\n+\t\t\t\t    delim_condition.comparison == ExpressionType::COMPARE_NOT_DISTINCT_FROM) {\n+\t\t\t\t\t// We need to compare NULL values\n+\t\t\t\t\tif (join_comparison == ExpressionType::COMPARE_EQUAL) {\n+\t\t\t\t\t\tjoin_comparison = ExpressionType::COMPARE_NOT_DISTINCT_FROM;\n+\t\t\t\t\t} else if (join_comparison == ExpressionType::COMPARE_NOTEQUAL) {\n+\t\t\t\t\t\tjoin_comparison = ExpressionType::COMPARE_DISTINCT_FROM;\n+\t\t\t\t\t} else if (join_comparison != ExpressionType::COMPARE_DISTINCT_FROM &&\n+\t\t\t\t\t           join_comparison != ExpressionType::COMPARE_NOT_DISTINCT_FROM) {\n+\t\t\t\t\t\t// The optimization does not work here\n+\t\t\t\t\t\tfound = false;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tdelim_condition.comparison = FlipComparisonExpression(join_comparison);\n \t\t\t\tfound = true;\n \t\t\t\tbreak;\n \t\t\t}\n@@ -294,4 +365,55 @@ bool Deliminator::RemoveInequalityJoinWithDelimGet(LogicalComparisonJoin &delim_\n \treturn found_all;\n }\n \n+void Deliminator::TrySwitchSingleToLeft(LogicalComparisonJoin &delim_join) {\n+\tD_ASSERT(delim_join.join_type == JoinType::SINGLE);\n+\n+\t// Collect RHS bindings\n+\tvector<ColumnBinding> join_bindings;\n+\tfor (const auto &cond : delim_join.conditions) {\n+\t\tif (!IsEqualityJoinCondition(cond)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tif (cond.right->type != ExpressionType::BOUND_COLUMN_REF) {\n+\t\t\treturn;\n+\t\t}\n+\t\tauto &colref = cond.right->Cast<BoundColumnRefExpression>();\n+\t\tjoin_bindings.emplace_back(colref.binding);\n+\t}\n+\n+\t// Now try to find an aggr in the RHS such that the join_column_bindings is a superset of the groups\n+\treference<LogicalOperator> current_op = *delim_join.children[1];\n+\twhile (current_op.get().type != LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY) {\n+\t\tif (current_op.get().children.size() != 1) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tswitch (current_op.get().type) {\n+\t\tcase LogicalOperatorType::LOGICAL_PROJECTION:\n+\t\t\tFindAndReplaceBindings(join_bindings, current_op.get().expressions, current_op.get().GetColumnBindings());\n+\t\t\tbreak;\n+\t\tcase LogicalOperatorType::LOGICAL_FILTER:\n+\t\t\tbreak; // Doesn't change bindings\n+\t\tdefault:\n+\t\t\treturn;\n+\t\t}\n+\t\tcurrent_op = *current_op.get().children[0];\n+\t}\n+\n+\tD_ASSERT(current_op.get().type == LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY);\n+\tconst auto &aggr = current_op.get().Cast<LogicalAggregate>();\n+\tif (!aggr.grouping_functions.empty()) {\n+\t\treturn;\n+\t}\n+\n+\tfor (idx_t group_idx = 0; group_idx < aggr.groups.size(); group_idx++) {\n+\t\tif (std::find(join_bindings.begin(), join_bindings.end(), ColumnBinding(aggr.group_index, group_idx)) ==\n+\t\t    join_bindings.end()) {\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+\tdelim_join.join_type = JoinType::LEFT;\n+}\n+\n } // namespace duckdb\ndiff --git a/src/optimizer/join_order/query_graph_manager.cpp b/src/optimizer/join_order/query_graph_manager.cpp\nindex dddc388f2fc2..e30727dc6e28 100644\n--- a/src/optimizer/join_order/query_graph_manager.cpp\n+++ b/src/optimizer/join_order/query_graph_manager.cpp\n@@ -1,14 +1,15 @@\n #include \"duckdb/optimizer/join_order/query_graph_manager.hpp\"\n-#include \"duckdb/planner/logical_operator.hpp\"\n-#include \"duckdb/optimizer/join_order/join_relation.hpp\"\n+\n+#include \"duckdb/common/assert.hpp\"\n #include \"duckdb/common/enums/join_type.hpp\"\n-#include \"duckdb/planner/operator/list.hpp\"\n-#include \"duckdb/planner/expression_iterator.hpp\"\n-#include \"duckdb/planner/expression/bound_comparison_expression.hpp\"\n-#include \"duckdb/execution/physical_plan_generator.hpp\"\n #include \"duckdb/common/printer.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n-#include \"duckdb/common/assert.hpp\"\n+#include \"duckdb/execution/physical_plan_generator.hpp\"\n+#include \"duckdb/optimizer/join_order/join_relation.hpp\"\n+#include \"duckdb/planner/expression/bound_comparison_expression.hpp\"\n+#include \"duckdb/planner/expression_iterator.hpp\"\n+#include \"duckdb/planner/logical_operator.hpp\"\n+#include \"duckdb/planner/operator/list.hpp\"\n \n namespace duckdb {\n \n@@ -334,20 +335,11 @@ unique_ptr<LogicalOperator> QueryGraphManager::RewritePlan(unique_ptr<LogicalOpe\n \treturn plan;\n }\n \n-void QueryGraphManager::TryFlipChildren(LogicalOperator &op, JoinType inverse, idx_t cardinality_ratio) {\n-\tauto &left_child = op.children[0];\n-\tauto &right_child = op.children[1];\n-\tauto lhs_cardinality = left_child->has_estimated_cardinality ? left_child->estimated_cardinality\n-\t                                                             : left_child->EstimateCardinality(context);\n-\tauto rhs_cardinality = right_child->has_estimated_cardinality ? right_child->estimated_cardinality\n-\t                                                              : right_child->EstimateCardinality(context);\n-\tif (rhs_cardinality < lhs_cardinality * cardinality_ratio) {\n-\t\treturn;\n-\t}\n-\tstd::swap(left_child, right_child);\n-\tif (op.type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN) {\n+static void FlipChildren(LogicalOperator &op) {\n+\tstd::swap(op.children[0], op.children[1]);\n+\tif (op.type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN || op.type == LogicalOperatorType::LOGICAL_DELIM_JOIN) {\n \t\tauto &join = op.Cast<LogicalComparisonJoin>();\n-\t\tjoin.join_type = inverse;\n+\t\tjoin.join_type = InverseJoinType(join.join_type);\n \t\tfor (auto &cond : join.conditions) {\n \t\t\tstd::swap(cond.left, cond.right);\n \t\t\tcond.comparison = FlipComparisonExpression(cond.comparison);\n@@ -355,8 +347,21 @@ void QueryGraphManager::TryFlipChildren(LogicalOperator &op, JoinType inverse, i\n \t}\n \tif (op.type == LogicalOperatorType::LOGICAL_ANY_JOIN) {\n \t\tauto &join = op.Cast<LogicalAnyJoin>();\n-\t\tjoin.join_type = inverse;\n+\t\tjoin.join_type = InverseJoinType(join.join_type);\n+\t}\n+}\n+\n+void QueryGraphManager::TryFlipChildren(LogicalOperator &op, idx_t cardinality_ratio) {\n+\tauto &left_child = op.children[0];\n+\tauto &right_child = op.children[1];\n+\tauto lhs_cardinality = left_child->has_estimated_cardinality ? left_child->estimated_cardinality\n+\t                                                             : left_child->EstimateCardinality(context);\n+\tauto rhs_cardinality = right_child->has_estimated_cardinality ? right_child->estimated_cardinality\n+\t                                                              : right_child->EstimateCardinality(context);\n+\tif (rhs_cardinality < lhs_cardinality * cardinality_ratio) {\n+\t\treturn;\n \t}\n+\tFlipChildren(op);\n }\n \n unique_ptr<LogicalOperator> QueryGraphManager::LeftRightOptimizations(unique_ptr<LogicalOperator> input_op) {\n@@ -368,40 +373,52 @@ unique_ptr<LogicalOperator> QueryGraphManager::LeftRightOptimizations(unique_ptr\n \t\t\tcase LogicalOperatorType::LOGICAL_COMPARISON_JOIN: {\n \t\t\t\tauto &join = op->Cast<LogicalComparisonJoin>();\n \n-\t\t\t\tif (join.join_type == JoinType::INNER) {\n-\t\t\t\t\tTryFlipChildren(join, JoinType::INNER);\n-\t\t\t\t} else if (join.join_type == JoinType::LEFT && join.right_projection_map.empty()) {\n-\t\t\t\t\tTryFlipChildren(join, JoinType::RIGHT, 2);\n-\t\t\t\t} else if (join.join_type == JoinType::SEMI) {\n-\t\t\t\t\tidx_t has_range = 0;\n-\t\t\t\t\tif (!PhysicalPlanGenerator::HasEquality(join.conditions, has_range)) {\n-\t\t\t\t\t\t// if the conditions have no equality, do not flip the children.\n-\t\t\t\t\t\t// There is no physical join operator (yet) that can do a right_semi/anti join.\n-\t\t\t\t\t\tbreak;\n+\t\t\t\tswitch (join.join_type) {\n+\t\t\t\tcase JoinType::INNER:\n+\t\t\t\tcase JoinType::OUTER:\n+\t\t\t\t\tTryFlipChildren(join);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase JoinType::LEFT:\n+\t\t\t\tcase JoinType::RIGHT:\n+\t\t\t\t\tif (join.right_projection_map.empty()) {\n+\t\t\t\t\t\tTryFlipChildren(join, 2);\n \t\t\t\t\t}\n-\t\t\t\t\tTryFlipChildren(join, JoinType::RIGHT_SEMI, 2);\n-\t\t\t\t} else if (join.join_type == JoinType::ANTI) {\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase JoinType::SEMI:\n+\t\t\t\tcase JoinType::ANTI: {\n \t\t\t\t\tidx_t has_range = 0;\n \t\t\t\t\tif (!PhysicalPlanGenerator::HasEquality(join.conditions, has_range)) {\n \t\t\t\t\t\t// if the conditions have no equality, do not flip the children.\n \t\t\t\t\t\t// There is no physical join operator (yet) that can do a right_semi/anti join.\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n-\t\t\t\t\tTryFlipChildren(join, JoinType::RIGHT_ANTI, 2);\n+\t\t\t\t\tTryFlipChildren(join, 2);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tdefault:\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase LogicalOperatorType::LOGICAL_CROSS_PRODUCT: {\n \t\t\t\t// cross product not a comparison join so JoinType::INNER will get ignored\n-\t\t\t\tTryFlipChildren(*op, JoinType::INNER, 1);\n+\t\t\t\tTryFlipChildren(*op, 1);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase LogicalOperatorType::LOGICAL_ANY_JOIN: {\n \t\t\t\tauto &join = op->Cast<LogicalAnyJoin>();\n \t\t\t\tif (join.join_type == JoinType::LEFT && join.right_projection_map.empty()) {\n-\t\t\t\t\tTryFlipChildren(join, JoinType::RIGHT, 2);\n+\t\t\t\t\tTryFlipChildren(join, 2);\n \t\t\t\t} else if (join.join_type == JoinType::INNER) {\n-\t\t\t\t\tTryFlipChildren(join, JoinType::INNER, 1);\n+\t\t\t\t\tTryFlipChildren(join, 1);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tcase LogicalOperatorType::LOGICAL_DELIM_JOIN: {\n+\t\t\t\tauto &join = op->Cast<LogicalComparisonJoin>();\n+\t\t\t\tif (HasInverseJoinType(join.join_type) && join.right_projection_map.empty()) {\n+\t\t\t\t\tFlipChildren(join);\n+\t\t\t\t\tjoin.delim_flipped = true;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\ndiff --git a/src/optimizer/unnest_rewriter.cpp b/src/optimizer/unnest_rewriter.cpp\nindex 4c93505891e6..f5d91061f3d2 100644\n--- a/src/optimizer/unnest_rewriter.cpp\n+++ b/src/optimizer/unnest_rewriter.cpp\n@@ -85,12 +85,14 @@ void UnnestRewriter::FindCandidates(unique_ptr<LogicalOperator> *op_ptr,\n \t}\n \n \t// LHS child is a window\n-\tif (delim_join.children[0]->type != LogicalOperatorType::LOGICAL_WINDOW) {\n+\tidx_t delim_idx = delim_join.delim_flipped ? 1 : 0;\n+\tidx_t other_idx = 1 - delim_idx;\n+\tif (delim_join.children[delim_idx]->type != LogicalOperatorType::LOGICAL_WINDOW) {\n \t\treturn;\n \t}\n \n \t// RHS child must be projection(s) followed by an UNNEST\n-\tauto curr_op = &delim_join.children[1];\n+\tauto curr_op = &delim_join.children[other_idx];\n \twhile (curr_op->get()->type == LogicalOperatorType::LOGICAL_PROJECTION) {\n \t\tif (curr_op->get()->children.size() != 1) {\n \t\t\tbreak;\n@@ -116,20 +118,23 @@ bool UnnestRewriter::RewriteCandidate(unique_ptr<LogicalOperator> *candidate) {\n \n \t// get the LOGICAL_DELIM_JOIN, which is a child of the candidate\n \tD_ASSERT(topmost_op.children.size() == 1);\n-\tauto &delim_join = *(topmost_op.children[0]);\n+\tauto &delim_join = topmost_op.children[0]->Cast<LogicalComparisonJoin>();\n \tD_ASSERT(delim_join.type == LogicalOperatorType::LOGICAL_DELIM_JOIN);\n \tGetDelimColumns(delim_join);\n \n \t// LHS of the LOGICAL_DELIM_JOIN is a LOGICAL_WINDOW that contains a LOGICAL_PROJECTION\n \t// this lhs_proj later becomes the child of the UNNEST\n-\tauto &window = *delim_join.children[0];\n+\n+\tidx_t delim_idx = delim_join.delim_flipped ? 1 : 0;\n+\tidx_t other_idx = 1 - delim_idx;\n+\tauto &window = *delim_join.children[delim_idx];\n \tauto &lhs_op = window.children[0];\n \tGetLHSExpressions(*lhs_op);\n \n \t// find the LOGICAL_UNNEST\n \t// and get the path down to the LOGICAL_UNNEST\n \tvector<unique_ptr<LogicalOperator> *> path_to_unnest;\n-\tauto curr_op = &(delim_join.children[1]);\n+\tauto curr_op = &delim_join.children[other_idx];\n \twhile (curr_op->get()->type == LogicalOperatorType::LOGICAL_PROJECTION) {\n \t\tpath_to_unnest.push_back(curr_op);\n \t\tcurr_op = &curr_op->get()->children[0];\n@@ -160,7 +165,7 @@ void UnnestRewriter::UpdateRHSBindings(unique_ptr<LogicalOperator> *plan_ptr, un\n \tidx_t shift = lhs_bindings.size();\n \n \tvector<unique_ptr<LogicalOperator> *> path_to_unnest;\n-\tauto curr_op = &(topmost_op.children[0]);\n+\tauto curr_op = &topmost_op.children[0];\n \twhile (curr_op->get()->type == LogicalOperatorType::LOGICAL_PROJECTION) {\n \n \t\tpath_to_unnest.push_back(curr_op);\n@@ -253,7 +258,7 @@ void UnnestRewriter::UpdateBoundUnnestBindings(UnnestRewriterPlanUpdater &update\n \tauto &topmost_op = (LogicalOperator &)**candidate;\n \n \t// traverse LOGICAL_PROJECTION(s)\n-\tauto curr_op = &(topmost_op.children[0]);\n+\tauto curr_op = &topmost_op.children[0];\n \twhile (curr_op->get()->type == LogicalOperatorType::LOGICAL_PROJECTION) {\n \t\tcurr_op = &curr_op->get()->children[0];\n \t}\ndiff --git a/src/storage/serialization/serialize_logical_operator.cpp b/src/storage/serialization/serialize_logical_operator.cpp\nindex 71c5ac2efe44..eac58aad98ed 100644\n--- a/src/storage/serialization/serialize_logical_operator.cpp\n+++ b/src/storage/serialization/serialize_logical_operator.cpp\n@@ -288,6 +288,7 @@ void LogicalComparisonJoin::Serialize(Serializer &serializer) const {\n \tserializer.WritePropertyWithDefault<vector<JoinCondition>>(204, \"conditions\", conditions);\n \tserializer.WritePropertyWithDefault<vector<LogicalType>>(205, \"mark_types\", mark_types);\n \tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(206, \"duplicate_eliminated_columns\", duplicate_eliminated_columns);\n+\tserializer.WritePropertyWithDefault<bool>(207, \"delim_flipped\", delim_flipped, false);\n }\n \n unique_ptr<LogicalOperator> LogicalComparisonJoin::Deserialize(Deserializer &deserializer) {\n@@ -299,6 +300,7 @@ unique_ptr<LogicalOperator> LogicalComparisonJoin::Deserialize(Deserializer &des\n \tdeserializer.ReadPropertyWithDefault<vector<JoinCondition>>(204, \"conditions\", result->conditions);\n \tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(205, \"mark_types\", result->mark_types);\n \tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(206, \"duplicate_eliminated_columns\", result->duplicate_eliminated_columns);\n+\tdeserializer.ReadPropertyWithDefault<bool>(207, \"delim_flipped\", result->delim_flipped, false);\n \treturn std::move(result);\n }\n \n",
  "test_patch": "diff --git a/test/issues/general/test_4950.test b/test/issues/general/test_4950.test\nindex 8e9147b0a895..302943df36d3 100644\n--- a/test/issues/general/test_4950.test\n+++ b/test/issues/general/test_4950.test\n@@ -36,17 +36,6 @@ explain select * from lineitem l1 where exists (\n ----\n logical_opt\t<!REGEX>:.*INNER.*\n \n-# deliminator should remove DELIM_JOIN as well\n-query II\n-explain select * from lineitem l1 where exists (\n-    select * from lineitem l2\n-    where\n-        l2.l_orderkey = l1.l_orderkey\n-        and l2.l_suppkey <> l1.l_suppkey\n-);\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n-\n # SINGLE join - same story\n query III\n select * from lineitem l1 where (\n@@ -135,16 +124,6 @@ explain select count(*) from lineitem l1 where exists (\n ----\n logical_opt\t<!REGEX>:.*INNER.*\n \n-query II\n-explain select count(*) from lineitem l1 where exists (\n-     select l_partkey from lineitem l2\n-     where\n-         l2.l_orderkey = l1.l_orderkey\n-         and l2.l_suppkey <> l1.l_suppkey\n-);\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n-\n # aggregate within the subquery\n query I\n select count(*) from lineitem l1 where exists (\n@@ -155,54 +134,3 @@ select count(*) from lineitem l1 where exists (\n );\n ----\n 6\n-\n-statement ok\n-drop table lineitem\n-\n-require tpch\n-\n-statement ok\n-call dbgen(sf=0.01)\n-\n-# now the real kicker, tpch q21, should not have any DELIM_JOIN\n-query II\n-EXPLAIN SELECT\n-    s_name,\n-    count(*) AS numwait\n-FROM\n-    supplier,\n-    lineitem l1,\n-    orders,\n-    nation\n-WHERE\n-    s_suppkey = l1.l_suppkey\n-    AND o_orderkey = l1.l_orderkey\n-    AND o_orderstatus = 'F'\n-    AND l1.l_receiptdate > l1.l_commitdate\n-    AND EXISTS (\n-        SELECT\n-            *\n-        FROM\n-            lineitem l2\n-        WHERE\n-            l2.l_orderkey = l1.l_orderkey\n-            AND l2.l_suppkey <> l1.l_suppkey)\n-    AND NOT EXISTS (\n-        SELECT\n-            *\n-        FROM\n-            lineitem l3\n-        WHERE\n-            l3.l_orderkey = l1.l_orderkey\n-            AND l3.l_suppkey <> l1.l_suppkey\n-            AND l3.l_receiptdate > l3.l_commitdate)\n-    AND s_nationkey = n_nationkey\n-    AND n_name = 'SAUDI ARABIA'\n-GROUP BY\n-    s_name\n-ORDER BY\n-    numwait DESC,\n-    s_name\n-LIMIT 100;\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\ndiff --git a/test/issues/general/test_9456.test b/test/issues/general/test_9456.test\nnew file mode 100644\nindex 000000000000..432a9c7f7fdf\n--- /dev/null\n+++ b/test/issues/general/test_9456.test\n@@ -0,0 +1,54 @@\n+# name: test/issues/general/test_9456.test\n+# description: Issue 9456: EXISTS operator returns NULL when multiple predicates are present\n+# group: [general]\n+\n+statement ok\n+create table u(u0 int, u1 int);\n+\n+statement ok\n+create table t(t0 int, t1 int);\n+\n+statement ok\n+insert into u values(1, 10);\n+\n+statement ok\n+insert into t values(1, 11);\n+\n+statement ok\n+insert into u values(null, 20);\n+\n+statement ok\n+insert into t values(null, 21);\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query III\n+SELECT t0, t1, EXISTS (SELECT * FROM u WHERE u0 = t0 AND u1 < t1) FROM t ORDER BY t0, t1;\n+----\n+1\t11\ttrue\n+NULL\t21\tfalse\n+\n+query III\n+SELECT t0, t1, EXISTS (SELECT * FROM u WHERE u0 != t0 AND u1 < t1) FROM t ORDER BY t0, t1;\n+----\n+1\t11\tfalse\n+NULL\t21\tfalse\n+\n+query III\n+SELECT t0, t1, EXISTS (SELECT * FROM u WHERE u0 != t0 AND u1 = t1) FROM t ORDER BY t0, t1;\n+----\n+1\t11\tfalse\n+NULL\t21\tfalse\n+\n+query III\n+SELECT t0, t1, EXISTS (SELECT * FROM u WHERE u0 != t0 AND u1 != t1) FROM t ORDER BY t0, t1;\n+----\n+1\t11\tfalse\n+NULL\t21\tfalse\n+\n+query III\n+SELECT t0, t1, EXISTS (SELECT * FROM u WHERE u0 < t0 AND u1 < t1) FROM t ORDER BY t0, t1;\n+----\n+1\t11\tfalse\n+NULL\t21\tfalse\ndiff --git a/test/optimizer/deliminator.test b/test/optimizer/deliminator.test\nindex 5f07028ae4b4..cf450051949b 100644\n--- a/test/optimizer/deliminator.test\n+++ b/test/optimizer/deliminator.test\n@@ -13,28 +13,29 @@ CALL dbgen(sf=0.0001);\n statement ok\n PRAGMA explain_output = OPTIMIZED_ONLY\n \n-# Q 02\n+# Q 02: join with JoinType::SINGLE (created when pushing down dependent joins) is converted to LEFT\n query II\n explain SELECT s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment FROM part, supplier, partsupp, nation, region WHERE p_partkey = ps_partkey AND s_suppkey = ps_suppkey AND p_size = 15 AND p_type LIKE '%BRASS' AND s_nationkey = n_nationkey AND n_regionkey = r_regionkey AND r_name = 'EUROPE' AND ps_supplycost = ( SELECT min(ps_supplycost) FROM partsupp, supplier, nation, region WHERE p_partkey = ps_partkey AND s_suppkey = ps_suppkey AND s_nationkey = n_nationkey AND n_regionkey = r_regionkey AND r_name = 'EUROPE') ORDER BY s_acctbal DESC, n_name, s_name, p_partkey LIMIT 100;\n ----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n+logical_opt\t<!REGEX>:.*SINGLE.*\n \n-# Q 17\n+# Q 17: join with JoinType::SINGLE (created when pushing down dependent joins) is converted to LEFT\n query II\n explain SELECT sum(l_extendedprice) / 7.0 AS avg_yearly FROM lineitem, part WHERE p_partkey = l_partkey AND p_brand = 'Brand#23' AND p_container = 'MED BOX' AND l_quantity < ( SELECT 0.2 * avg(l_quantity) FROM lineitem WHERE l_partkey = p_partkey);\n ----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n+logical_opt\t<!REGEX>:.*SINGLE.*\n \n-# Q 20\n+# Q 17: if we remove the filters \"\"\" p_brand = 'Brand#23' AND p_container = 'MED BOX' \"\"\" we can remove the whole DELIM join\n query II\n-explain SELECT s_name, s_address FROM supplier, nation WHERE s_suppkey IN ( SELECT ps_suppkey FROM partsupp WHERE ps_partkey IN ( SELECT p_partkey FROM part WHERE p_name LIKE 'forest%') AND ps_availqty > ( SELECT 0.5 * sum(l_quantity) FROM lineitem WHERE l_partkey = ps_partkey AND l_suppkey = ps_suppkey AND l_shipdate >= CAST('1994-01-01' AS date) AND l_shipdate < CAST('1995-01-01' AS date))) AND s_nationkey = n_nationkey AND n_name = 'CANADA' ORDER BY s_name;\n+explain SELECT sum(l_extendedprice) / 7.0 AS avg_yearly FROM lineitem, part WHERE p_partkey = l_partkey AND l_quantity < (SELECT 0.2 * avg(l_quantity) FROM lineitem WHERE l_partkey = p_partkey);\n ----\n logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n \n+# Q 20: join with JoinType::SINGLE (created when pushing down dependent joins) is converted to LEFT\n query II\n-explain SELECT s_name, count(*) AS numwait FROM supplier, lineitem l1, orders, nation WHERE s_suppkey = l1.l_suppkey AND o_orderkey = l1.l_orderkey AND o_orderstatus = 'F' AND l1.l_receiptdate > l1.l_commitdate AND EXISTS ( SELECT * FROM lineitem l2 WHERE l2.l_orderkey = l1.l_orderkey AND l2.l_suppkey <> l1.l_suppkey) AND NOT EXISTS ( SELECT * FROM lineitem l3 WHERE l3.l_orderkey = l1.l_orderkey AND l3.l_suppkey <> l1.l_suppkey AND l3.l_receiptdate > l3.l_commitdate) AND s_nationkey = n_nationkey AND n_name = 'SAUDI ARABIA' GROUP BY s_name ORDER BY numwait DESC, s_name LIMIT 100;\n+explain SELECT s_name, s_address FROM supplier, nation WHERE s_suppkey IN ( SELECT ps_suppkey FROM partsupp WHERE ps_partkey IN ( SELECT p_partkey FROM part WHERE p_name LIKE 'forest%') AND ps_availqty > ( SELECT 0.5 * sum(l_quantity) FROM lineitem WHERE l_partkey = ps_partkey AND l_suppkey = ps_suppkey AND l_shipdate >= CAST('1994-01-01' AS date) AND l_shipdate < CAST('1995-01-01' AS date))) AND s_nationkey = n_nationkey AND n_name = 'CANADA' ORDER BY s_name;\n ----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n+logical_opt\t<!REGEX>:.*SINGLE.*\n \n statement ok\n CREATE TABLE integers(i INTEGER, j integer)\n@@ -179,3 +180,22 @@ NULL\t0\n 1\t1\n 2\t1\n 3\t0\n+\n+# FTS\n+require fts\n+\n+require noalternativeverify\n+\n+statement ok\n+CREATE TABLE documents(id VARCHAR, body VARCHAR)\n+\n+statement ok\n+INSERT INTO documents VALUES ('doc1', ' QU\u00c1CKING+QU\u00c1CKING+QU\u00c1CKING'), ('doc2', ' B\u00c1RKING+B\u00c1RKING+B\u00c1RKING+B\u00c1RKING'), ('doc3', ' M\u00c9OWING+M\u00c9OWING+M\u00c9OWING+M\u00c9OWING+M\u00c9OWING+999')\n+\n+statement ok\n+PRAGMA create_fts_index('documents', 'id', 'body', overwrite=1)\n+\n+query II\n+EXPLAIN SELECT score, id, body FROM (SELECT *, fts_main_documents.match_bm25(id, 'quacked barked') AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n+----\n+logical_opt\t<!REGEX>:.*DELIM_JOIN.*\ndiff --git a/test/optimizer/deliminator_optimizer.test b/test/optimizer/deliminator_optimizer.test\ndeleted file mode 100644\nindex d8665d130e9f..000000000000\n--- a/test/optimizer/deliminator_optimizer.test\n+++ /dev/null\n@@ -1,235 +0,0 @@\n-# name: test/optimizer/deliminator_optimizer.test\n-# description: Test the Deliminator optimizer\n-# group: [optimizer]\n-\n-statement ok\n-CREATE TABLE integers(i INTEGER)\n-\n-# specific edge case with two DelimGets under the DelimJoin\n-statement ok\n-SELECT i, (SELECT MIN(i+2*i1.i) FROM integers) FROM integers i1 ORDER BY i\n-\n-statement ok\n-INSERT INTO integers VALUES (1), (2), (3)\n-\n-statement ok\n-PRAGMA explain_output = OPTIMIZED_ONLY\n-\n-# correlated any/all\n-query II\n-EXPLAIN SELECT i=ANY(SELECT i FROM integers WHERE i=i1.i) FROM integers i1 ORDER BY i\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n-\n-query II\n-EXPLAIN SELECT i=ALL(SELECT i FROM integers WHERE i=i1.i) FROM integers i1 ORDER BY i\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n-\n-# correlated where\n-statement ok\n-CREATE TABLE test (id INTEGER, b INTEGER)\n-\n-query II\n-EXPLAIN SELECT * FROM test WHERE b=(SELECT MIN(b) FROM test AS a WHERE a.id=test.id)\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n-\n-# TPC-H\n-require tpch\n-\n-statement ok\n-CALL dbgen(sf=0.0001)\n-\n-# q02\n-query II\n-EXPLAIN\n-SELECT\n-    s_acctbal,\n-    s_name,\n-    n_name,\n-    p_partkey,\n-    p_mfgr,\n-    s_address,\n-    s_phone,\n-    s_comment\n-FROM\n-    part,\n-    supplier,\n-    partsupp,\n-    nation,\n-    region\n-WHERE\n-    p_partkey = ps_partkey\n-    AND s_suppkey = ps_suppkey\n-    AND p_size = 15\n-    AND p_type LIKE '%BRASS'\n-    AND s_nationkey = n_nationkey\n-    AND n_regionkey = r_regionkey\n-    AND r_name = 'EUROPE'\n-    AND ps_supplycost = (\n-        SELECT\n-            min(ps_supplycost)\n-        FROM\n-            partsupp,\n-            supplier,\n-            nation,\n-            region\n-        WHERE\n-            p_partkey = ps_partkey\n-            AND s_suppkey = ps_suppkey\n-            AND s_nationkey = n_nationkey\n-            AND n_regionkey = r_regionkey\n-            AND r_name = 'EUROPE')\n-ORDER BY\n-    s_acctbal DESC,\n-    n_name,\n-    s_name,\n-    p_partkey\n-LIMIT 100\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n-\n-# q04\n-query II\n-EXPLAIN\n-SELECT\n-    o_orderpriority,\n-    count(*) AS order_count\n-FROM\n-    orders\n-WHERE\n-    o_orderdate >= CAST('1993-07-01' AS date)\n-    AND o_orderdate < CAST('1993-10-01' AS date)\n-    AND EXISTS (\n-        SELECT\n-            *\n-        FROM\n-            lineitem\n-        WHERE\n-            l_orderkey = o_orderkey\n-            AND l_commitdate < l_receiptdate)\n-GROUP BY\n-    o_orderpriority\n-ORDER BY\n-    o_orderpriority\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n-\n-# q17\n-query II\n-EXPLAIN\n-SELECT\n-    sum(l_extendedprice) / 7.0 AS avg_yearly\n-FROM\n-    lineitem,\n-    part\n-WHERE\n-    p_partkey = l_partkey\n-    AND p_brand = 'Brand#23'\n-    AND p_container = 'MED BOX'\n-    AND l_quantity < (\n-        SELECT\n-            0.2 * avg(l_quantity)\n-        FROM\n-            lineitem\n-        WHERE\n-            l_partkey = p_partkey)\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n-\n-# q20\n-query II\n-EXPLAIN\n-SELECT\n-    s_name,\n-    s_address\n-FROM\n-    supplier,\n-    nation\n-WHERE\n-    s_suppkey IN (\n-        SELECT\n-            ps_suppkey\n-        FROM\n-            partsupp\n-        WHERE\n-            ps_partkey IN (\n-                SELECT\n-                    p_partkey\n-                FROM\n-                    part\n-                WHERE\n-                    p_name LIKE 'forest%')\n-                AND ps_availqty > (\n-                    SELECT\n-                        0.5 * sum(l_quantity)\n-                    FROM\n-                        lineitem\n-                    WHERE\n-                        l_partkey = ps_partkey\n-                        AND l_suppkey = ps_suppkey\n-                        AND l_shipdate >= CAST('1994-01-01' AS date)\n-                        AND l_shipdate < CAST('1995-01-01' AS date)))\n-            AND s_nationkey = n_nationkey\n-            AND n_name = 'CANADA'\n-        ORDER BY\n-            s_name\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n-\n-# q21\n-query II\n-EXPLAIN\n-SELECT\n-    cntrycode,\n-    count(*) AS numcust,\n-    sum(c_acctbal) AS totacctbal\n-FROM (\n-    SELECT\n-        substring(c_phone FROM 1 FOR 2) AS cntrycode,\n-        c_acctbal\n-    FROM\n-        customer\n-    WHERE\n-        substring(c_phone FROM 1 FOR 2) IN ('13', '31', '23', '29', '30', '18', '17')\n-        AND c_acctbal > (\n-            SELECT\n-                avg(c_acctbal)\n-            FROM\n-                customer\n-            WHERE\n-                c_acctbal > 0.00\n-                AND substring(c_phone FROM 1 FOR 2) IN ('13', '31', '23', '29', '30', '18', '17'))\n-            AND NOT EXISTS (\n-                SELECT\n-                    *\n-                FROM\n-                    orders\n-                WHERE\n-                    o_custkey = c_custkey)) AS custsale\n-GROUP BY\n-    cntrycode\n-ORDER BY\n-    cntrycode\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n-\n-# FTS\n-require fts\n-\n-require noalternativeverify\n-\n-statement ok\n-CREATE TABLE documents(id VARCHAR, body VARCHAR)\n-\n-statement ok\n-INSERT INTO documents VALUES ('doc1', ' QU\u00c1CKING+QU\u00c1CKING+QU\u00c1CKING'), ('doc2', ' B\u00c1RKING+B\u00c1RKING+B\u00c1RKING+B\u00c1RKING'), ('doc3', ' M\u00c9OWING+M\u00c9OWING+M\u00c9OWING+M\u00c9OWING+M\u00c9OWING+999')\n-\n-statement ok\n-PRAGMA create_fts_index('documents', 'id', 'body', overwrite=1)\n-\n-query II\n-EXPLAIN SELECT score, id, body FROM (SELECT *, fts_main_documents.match_bm25(id, 'quacked barked') AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n-----\n-logical_opt\t<!REGEX>:.*DELIM_JOIN.*\ndiff --git a/test/optimizer/using_optimizer.test b/test/optimizer/using_optimizer.test\nindex 0e592c89fdbc..06fbe5c72430 100644\n--- a/test/optimizer/using_optimizer.test\n+++ b/test/optimizer/using_optimizer.test\n@@ -111,13 +111,13 @@ explain select c.i from a left outer join b on (a.i=b.i) right join c on (a.i=c.\n # full outer join\n # need to use a case expression here\n query I\n-select i from a full outer join b using (i);\n+select i from a full outer join b using (i) order by all;\n ----\n 42\n 43\n \n query I\n-select coalesce(a.i, b.i) from a full outer join b on (a.i=b.i);\n+select coalesce(a.i, b.i) from a full outer join b on (a.i=b.i) order by all;\n ----\n 42\n 43\ndiff --git a/test/sql/join/test_nested_keys.test b/test/sql/join/test_nested_keys.test\nindex 5ad3d59acdb0..0ec77e2ecebd 100644\n--- a/test/sql/join/test_nested_keys.test\n+++ b/test/sql/join/test_nested_keys.test\n@@ -55,7 +55,7 @@ NULL\tNULL\tNULL\n 5\t[9, 10, 11]\t[9, 10, 11]\n \n query III\n-SELECT i, pk, fk FROM intlistdim FULL OUTER JOIN intlists ON intlistdim.pk=intlists.fk ORDER BY i\n+SELECT i, pk, fk FROM intlistdim FULL OUTER JOIN intlists ON intlistdim.pk=intlists.fk ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n NULL\tNULL\t[13]\n@@ -112,7 +112,7 @@ NULL\tNULL\tNULL\n 5\t[i, j, k]\t[i, j, k]\n \n query III\n-SELECT i, pk, fk FROM strlistdim FULL OUTER JOIN strlists ON strlistdim.pk=strlists.fk ORDER BY i\n+SELECT i, pk, fk FROM strlistdim FULL OUTER JOIN strlists ON strlistdim.pk=strlists.fk ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n NULL\tNULL\t[Somateria mollissima]\n@@ -169,7 +169,7 @@ NULL\tNULL\tNULL\n 5\t{'x': 9, 'y': i}\t{'x': 9, 'y': i}\n \n query III\n-SELECT i, pk, fk FROM structdim FULL OUTER JOIN structs ON structdim.pk=structs.fk ORDER BY i\n+SELECT i, pk, fk FROM structdim FULL OUTER JOIN structs ON structdim.pk=structs.fk ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n NULL\tNULL\t{'x': 13, 'y': Somateria mollissima}\n@@ -241,7 +241,7 @@ SELECT i, pk, fk\n FROM struct_lint_lstr_dim\n FULL OUTER JOIN struct_lint_lstr\n ON struct_lint_lstr_dim.pk=struct_lint_lstr.fk\n-ORDER BY i\n+ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n NULL\tNULL\t{'x': [13], 'y': [Somateria mollissima]}\n@@ -314,7 +314,7 @@ SELECT i, pk, fk\n FROM r2l3r4l5i4i2l3v_dim\n FULL OUTER JOIN r2l3r4l5i4i2l3v\n ON r2l3r4l5i4i2l3v_dim.pk = r2l3r4l5i4i2l3v.fk\n-ORDER BY i\n+ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n NULL\tNULL\t{'x': [{'l4': [62], 'i4': 47}], 'y': [Somateria mollissima]}\ndiff --git a/test/sql/join/test_nested_payloads.test b/test/sql/join/test_nested_payloads.test\nindex 111806bcc164..0be3eeb02132 100644\n--- a/test/sql/join/test_nested_payloads.test\n+++ b/test/sql/join/test_nested_payloads.test\n@@ -49,7 +49,7 @@ NULL\t[13]\n 5\t[9, 10, 11]\n \n query III\n-SELECT fk, pk, p FROM integers, intlists WHERE fk = pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers, intlists WHERE fk = pk ORDER BY ALL\n ----\n 1\t1\t[1]\n 2\t2\t[NULL]\n@@ -57,7 +57,7 @@ SELECT fk, pk, p FROM integers, intlists WHERE fk = pk ORDER BY fk, pk\n 5\t5\t[9, 10, 11]\n \n query III\n-SELECT fk, pk, p FROM integers LEFT OUTER JOIN intlists ON integers.fk=intlists.pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers LEFT OUTER JOIN intlists ON integers.fk=intlists.pk ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n 1\t1\t[1]\n@@ -69,13 +69,13 @@ query III\n SELECT fk, pk, p\n FROM integers LEFT OUTER JOIN intlists ON integers.fk=intlists.pk\n WHERE pk < 5 AND fk > 1\n-ORDER BY fk, pk\n+ORDER BY ALL\n ----\n 2\t2\t[NULL]\n 3\t3\t[]\n \n query III\n-SELECT fk, pk, p FROM intlists RIGHT OUTER JOIN integers ON integers.fk=intlists.pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM intlists RIGHT OUTER JOIN integers ON integers.fk=intlists.pk ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n 1\t1\t[1]\n@@ -84,7 +84,7 @@ NULL\tNULL\tNULL\n 5\t5\t[9, 10, 11]\n \n query III\n-SELECT fk, pk, p FROM integers FULL OUTER JOIN intlists ON integers.fk=intlists.pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers FULL OUTER JOIN intlists ON integers.fk=intlists.pk ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n NULL\tNULL\t[13]\n@@ -151,7 +151,7 @@ NULL\tNULL\tNULL\n 5\t5\t[i, j, k]\n \n query III\n-SELECT fk, pk, p FROM integers FULL OUTER JOIN strlists ON integers.fk=strlists.pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers FULL OUTER JOIN strlists ON integers.fk=strlists.pk ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n NULL\tNULL\t[Somateria mollissima]\n@@ -193,7 +193,7 @@ NULL\t{'x': 13, 'y': Somateria mollissima}\n 5\t{'x': 9, 'y': i}\n \n query III\n-SELECT fk, pk, p FROM integers, structs WHERE fk = pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers, structs WHERE fk = pk ORDER BY ALL\n ----\n 1\t1\t{'x': 1, 'y': a}\n 2\t2\t{'x': NULL, 'y': NULL}\n@@ -201,7 +201,7 @@ SELECT fk, pk, p FROM integers, structs WHERE fk = pk ORDER BY fk, pk\n 5\t5\t{'x': 9, 'y': i}\n \n query III\n-SELECT fk, pk, p FROM integers LEFT OUTER JOIN structs ON integers.fk=structs.pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers LEFT OUTER JOIN structs ON integers.fk=structs.pk ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n 1\t1\t{'x': 1, 'y': a}\n@@ -213,13 +213,13 @@ query III\n SELECT fk, pk, p\n FROM integers LEFT OUTER JOIN structs ON integers.fk=structs.pk\n WHERE pk < 5 AND fk > 1\n-ORDER BY fk, pk\n+ORDER BY ALL\n ----\n 2\t2\t{'x': NULL, 'y': NULL}\n 3\t3\t{'x': 0, 'y': }\n \n query III\n-SELECT fk, pk, p FROM structs RIGHT OUTER JOIN integers ON integers.fk=structs.pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM structs RIGHT OUTER JOIN integers ON integers.fk=structs.pk ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n 1\t1\t{'x': 1, 'y': a}\n@@ -229,7 +229,7 @@ NULL\tNULL\tNULL\n \n \n query III\n-SELECT fk, pk, p FROM integers FULL OUTER JOIN structs ON integers.fk=structs.pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers FULL OUTER JOIN structs ON integers.fk=structs.pk ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n NULL\tNULL\t{'x': 13, 'y': Somateria mollissima}\n@@ -261,7 +261,7 @@ NULL\t{'x': [13], 'y': [Somateria mollissima]}\n 5\t{'x': [9, 10, 11], 'y': [i, j, k]}\n \n query III\n-SELECT fk, pk, p FROM integers, struct_lint_lstr WHERE fk = pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers, struct_lint_lstr WHERE fk = pk ORDER BY ALL\n ----\n 1\t1\t{'x': [1], 'y': [a]}\n 2\t2\t{'x': [NULL], 'y': [NULL]}\n@@ -271,7 +271,7 @@ SELECT fk, pk, p FROM integers, struct_lint_lstr WHERE fk = pk ORDER BY fk, pk\n query III\n SELECT fk, pk, p\n FROM integers LEFT OUTER JOIN struct_lint_lstr ON integers.fk=struct_lint_lstr.pk\n-ORDER BY fk, pk\n+ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n 1\t1\t{'x': [1], 'y': [a]}\n@@ -283,7 +283,7 @@ query III\n SELECT fk, pk, p\n FROM integers LEFT OUTER JOIN struct_lint_lstr ON integers.fk=struct_lint_lstr.pk\n WHERE pk < 5 AND fk > 1\n-ORDER BY fk, pk\n+ORDER BY ALL\n ----\n 2\t2\t{'x': [NULL], 'y': [NULL]}\n 3\t3\t{'x': [], 'y': []}\n@@ -291,7 +291,7 @@ ORDER BY fk, pk\n query III\n SELECT fk, pk, p\n FROM struct_lint_lstr RIGHT OUTER JOIN integers ON integers.fk=struct_lint_lstr.pk\n-ORDER BY fk, pk\n+ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n 1\t1\t{'x': [1], 'y': [a]}\n@@ -302,7 +302,7 @@ NULL\tNULL\tNULL\n query III\n SELECT fk, pk, p\n FROM integers FULL OUTER JOIN struct_lint_lstr ON integers.fk=struct_lint_lstr.pk\n-ORDER BY fk, pk\n+ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n NULL\tNULL\t{'x': [13], 'y': [Somateria mollissima]}\n@@ -334,7 +334,7 @@ NULL\t{'x': [{'l4': [62], 'i4': 47}], 'y': [Somateria mollissima]}\n 5\t{'x': [{'l4': [56], 'i4': 44}, {'l4': [57, 58], 'i4': 45}, {'l4': [59, 60, 61], 'i4': 46}], 'y': [i, j, k]}\n \n query III\n-SELECT fk, pk, p FROM integers, r2l3r4l5i4i2l3v WHERE fk = pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers, r2l3r4l5i4i2l3v WHERE fk = pk ORDER BY ALL\n ----\n 1\t1\t{'x': [{'l4': [51], 'i4': 41}], 'y': [a]}\n 2\t2\t{'x': [NULL], 'y': [NULL]}\n@@ -344,7 +344,7 @@ SELECT fk, pk, p FROM integers, r2l3r4l5i4i2l3v WHERE fk = pk ORDER BY fk, pk\n query III\n SELECT fk, pk, p\n FROM integers LEFT OUTER JOIN r2l3r4l5i4i2l3v ON integers.fk=r2l3r4l5i4i2l3v.pk\n-ORDER BY fk, pk\n+ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n 1\t1\t{'x': [{'l4': [51], 'i4': 41}], 'y': [a]}\n@@ -356,7 +356,7 @@ query III\n SELECT fk, pk, p\n FROM integers LEFT OUTER JOIN r2l3r4l5i4i2l3v ON integers.fk=r2l3r4l5i4i2l3v.pk\n WHERE pk < 5 AND fk > 1\n-ORDER BY fk, pk\n+ORDER BY ALL\n ----\n 2\t2\t{'x': [NULL], 'y': [NULL]}\n 3\t3\t{'x': [], 'y': []}\n@@ -364,7 +364,7 @@ ORDER BY fk, pk\n query III\n SELECT fk, pk, p\n FROM r2l3r4l5i4i2l3v RIGHT OUTER JOIN integers ON integers.fk=r2l3r4l5i4i2l3v.pk\n-ORDER BY fk, pk\n+ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n 1\t1\t{'x': [{'l4': [51], 'i4': 41}], 'y': [a]}\n@@ -375,7 +375,7 @@ NULL\tNULL\tNULL\n query III\n SELECT fk, pk, p\n FROM integers FULL OUTER JOIN r2l3r4l5i4i2l3v ON integers.fk=r2l3r4l5i4i2l3v.pk\n-ORDER BY fk, pk\n+ORDER BY ALL\n ----\n NULL\tNULL\tNULL\n NULL\tNULL\t{'x': [{'l4': [62], 'i4': 47}], 'y': [Somateria mollissima]}\n@@ -413,12 +413,12 @@ SELECT pk, p FROM longlists ORDER BY pk;\n 12 values hashing to 6ed3f1a5b7eb595d57083d74ce4a51df\n \n query III\n-SELECT fk, pk, p FROM integers, longlists WHERE fk = pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers, longlists WHERE fk = pk ORDER BY ALL\n ----\n 12 values hashing to 74f807166632863aa7b71486777820b5\n \n query III\n-SELECT fk, pk, p FROM integers LEFT OUTER JOIN longlists ON integers.fk=longlists.pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers LEFT OUTER JOIN longlists ON integers.fk=longlists.pk ORDER BY ALL\n ----\n 15 values hashing to e7e8557f5d71ca6b20614e6cd6c35bbf\n \n@@ -426,18 +426,18 @@ query III\n SELECT fk, pk, p\n FROM integers LEFT OUTER JOIN longlists ON integers.fk=longlists.pk\n WHERE pk < 5 AND fk > 1\n-ORDER BY fk, pk\n+ORDER BY ALL\n ----\n 2\t2\t[NULL]\n 3\t3\t[]\n \n query III\n-SELECT fk, pk, p FROM longlists RIGHT OUTER JOIN integers ON integers.fk=longlists.pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM longlists RIGHT OUTER JOIN integers ON integers.fk=longlists.pk ORDER BY ALL\n ----\n 15 values hashing to e7e8557f5d71ca6b20614e6cd6c35bbf\n \n query III\n-SELECT fk, pk, p FROM integers FULL OUTER JOIN longlists ON integers.fk=longlists.pk ORDER BY fk, pk\n+SELECT fk, pk, p FROM integers FULL OUTER JOIN longlists ON integers.fk=longlists.pk ORDER BY ALL\n ----\n 21 values hashing to 397312e04f9a44a70a2672865240afb0\n \ndiff --git a/test/sql/order/limit_full_outer_join.test b/test/sql/order/limit_full_outer_join.test\nindex cf3bc4abcd4c..91056d431e43 100644\n--- a/test/sql/order/limit_full_outer_join.test\n+++ b/test/sql/order/limit_full_outer_join.test\n@@ -18,7 +18,7 @@ statement ok\n INSERT INTO integers2 VALUES (1, 10), (2, 20)\n \n query IIII\n-SELECT i, j, k, l FROM integers FULL OUTER JOIN integers2 ON integers.i=integers2.k LIMIT 2\n+SELECT i, j, k, l FROM integers FULL OUTER JOIN integers2 ON integers.i=integers2.k ORDER BY ALL LIMIT 2\n ----\n 1\t1\t1\t10\n 3\t3\tNULL\tNULL\ndiff --git a/test/sql/subquery/scalar/expression_get.test_slow b/test/sql/subquery/scalar/expression_get.test_slow\nindex 3017ace04136..349d9400fa95 100644\n--- a/test/sql/subquery/scalar/expression_get.test_slow\n+++ b/test/sql/subquery/scalar/expression_get.test_slow\n@@ -13,7 +13,7 @@ statement ok\n CREATE TABLE test AS SELECT CAST((i % 10) AS INTEGER) AS i, CAST(((i * 2) % 10) AS INTEGER) AS j FROM generate_series(0, 9, 1) tbl(i);\n \n query III\n-SELECT i, j, (SELECT max(x) FROM (VALUES (i), (j)) AS X(x)) as maxn FROM test;\n+SELECT i, j, (SELECT max(x) FROM (VALUES (i), (j)) AS X(x)) as maxn FROM test ORDER BY ALL;\n ----\n 0\t0\t0\n 1\t2\t2\n@@ -28,7 +28,7 @@ SELECT i, j, (SELECT max(x) FROM (VALUES (i), (j)) AS X(x)) as maxn FROM test;\n \n # mix of correlated and non-correlated values\n query III\n-SELECT i, j, (SELECT max(x) FROM (VALUES (i), (j), (3), (NULL), (5)) AS X(x)) as maxn FROM test;\n+SELECT i, j, (SELECT max(x) FROM (VALUES (i), (j), (3), (NULL), (5)) AS X(x)) as maxn FROM test ORDER BY ALL;\n ----\n 0\t0\t5\n 1\t2\t5\ndiff --git a/test/sql/subquery/scalar/test_nested_correlated_subquery.test_slow b/test/sql/subquery/scalar/test_nested_correlated_subquery.test_slow\nindex fe350fb1d820..6496c99c2e93 100644\n--- a/test/sql/subquery/scalar/test_nested_correlated_subquery.test_slow\n+++ b/test/sql/subquery/scalar/test_nested_correlated_subquery.test_slow\n@@ -324,7 +324,7 @@ NULL\n 0.000000\n \n query R\n-SELECT (SELECT (SELECT COVAR_POP(i2.i, i3.i) FROM integers i3) FROM integers i2 LIMIT 1) FROM integers i1 ORDER BY 1\n+SELECT (SELECT (SELECT COVAR_POP(i2.i, i3.i) FROM integers i3) FROM integers i2 ORDER BY i NULLS LAST LIMIT 1) FROM integers i1 ORDER BY 1\n ----\n 0.000000\n 0.000000\n",
  "problem_statement": "EXISTS operator returns NULL when multiple predicates are present\n### What happens?\r\n\r\nEXISTS operator returns NULL. The documentation says it should only return `true` or `false`.\r\n\r\n### To Reproduce\r\n\r\ncreate table u(u0 int, u1 int);\r\ncreate table t(t0 int, t1 int);\r\ninsert into u values(1, 10);\r\ninsert into t values(1, 11);\r\ninsert into u values(null, 20);\r\ninsert into t values(null, 21);\r\nSELECT t0, t1, EXISTS (SELECT * FROM u WHERE u0 = t0 AND u1 < t1) FROM t;\r\n\r\n\r\n### OS:\r\n\r\narm64\r\n\r\n### DuckDB Version:\r\n\r\n0.9.1\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nDeepak Majeti\r\n\r\n### Affiliation:\r\n\r\nIBM\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2023-12-14T15:35:50Z"
}