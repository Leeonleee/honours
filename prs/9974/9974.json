{
  "repo": "duckdb/duckdb",
  "pull_number": 9974,
  "instance_id": "duckdb__duckdb-9974",
  "issue_numbers": [
    "9970"
  ],
  "base_commit": "e1f9fcedcfd42a815fdea9496902d7253601184f",
  "patch": "diff --git a/src/catalog/default/default_functions.cpp b/src/catalog/default/default_functions.cpp\nindex dfd66cece422..e1c3d75e799d 100644\n--- a/src/catalog/default/default_functions.cpp\n+++ b/src/catalog/default/default_functions.cpp\n@@ -105,14 +105,14 @@ static DefaultMacro internal_macros[] = {\n     {DEFAULT_SCHEMA, \"array_reverse\", {\"l\", nullptr}, \"list_reverse(l)\"},\n \n     // FIXME implement as actual function if we encounter a lot of performance issues. Complexity now: n * m, with hashing possibly n + m\n-    {DEFAULT_SCHEMA, \"list_intersect\", {\"l1\", \"l2\", nullptr}, \"list_filter(list_distinct(l1), (x) -> list_contains(l2, x))\"},\n+    {DEFAULT_SCHEMA, \"list_intersect\", {\"l1\", \"l2\", nullptr}, \"list_filter(list_distinct(l1), (variable_intersect) -> list_contains(l2, variable_intersect))\"},\n     {DEFAULT_SCHEMA, \"array_intersect\", {\"l1\", \"l2\", nullptr}, \"list_intersect(l1, l2)\"},\n \n-    {DEFAULT_SCHEMA, \"list_has_any\", {\"l1\", \"l2\", nullptr}, \"CASE WHEN l1 IS NULL THEN NULL WHEN l2 IS NULL THEN NULL WHEN len(list_filter(l1, (x) -> list_contains(l2, x))) > 0 THEN true ELSE false END\"},\n+    {DEFAULT_SCHEMA, \"list_has_any\", {\"l1\", \"l2\", nullptr}, \"CASE WHEN l1 IS NULL THEN NULL WHEN l2 IS NULL THEN NULL WHEN len(list_filter(l1, (variable_has_any) -> list_contains(l2, variable_has_any))) > 0 THEN true ELSE false END\"},\n     {DEFAULT_SCHEMA, \"array_has_any\", {\"l1\", \"l2\", nullptr}, \"list_has_any(l1, l2)\" },\n     {DEFAULT_SCHEMA, \"&&\", {\"l1\", \"l2\", nullptr}, \"list_has_any(l1, l2)\" }, // \"&&\" is the operator for \"list_has_any\n \n-    {DEFAULT_SCHEMA, \"list_has_all\", {\"l1\", \"l2\", nullptr}, \"CASE WHEN l1 IS NULL THEN NULL WHEN l2 IS NULL THEN NULL WHEN len(list_filter(l2, (x) -> list_contains(l1, x))) = len(list_filter(l2, x -> x IS NOT NULL)) THEN true ELSE false END\"},\n+    {DEFAULT_SCHEMA, \"list_has_all\", {\"l1\", \"l2\", nullptr}, \"CASE WHEN l1 IS NULL THEN NULL WHEN l2 IS NULL THEN NULL WHEN len(list_filter(l2, (variable_has_all) -> list_contains(l1, variable_has_all))) = len(list_filter(l2, variable_has_all -> variable_has_all IS NOT NULL)) THEN true ELSE false END\"},\n     {DEFAULT_SCHEMA, \"array_has_all\", {\"l1\", \"l2\", nullptr}, \"list_has_all(l1, l2)\" },\n     {DEFAULT_SCHEMA, \"@>\", {\"l1\", \"l2\", nullptr}, \"list_has_all(l1, l2)\" }, // \"@>\" is the operator for \"list_has_all\n     {DEFAULT_SCHEMA, \"<@\", {\"l1\", \"l2\", nullptr}, \"list_has_all(l2, l1)\" }, // \"<@\" is the operator for \"list_has_all\ndiff --git a/src/planner/binder/expression/bind_lambda.cpp b/src/planner/binder/expression/bind_lambda.cpp\nindex 3d279dd99f83..1d7a33b54c8f 100644\n--- a/src/planner/binder/expression/bind_lambda.cpp\n+++ b/src/planner/binder/expression/bind_lambda.cpp\n@@ -85,6 +85,26 @@ BindResult ExpressionBinder::BindExpression(LambdaExpression &expr, idx_t depth,\n \t\tparams_strings.push_back(expr.params[i]->ToString());\n \t}\n \n+\t// ensure that we do not have ambiguous lambda parameters\n+\tif (lambda_bindings) {\n+\t\tfor (const auto &binding : *lambda_bindings) {\n+\t\t\tfor (const auto &outer_lambda_parameter : binding.names) {\n+\t\t\t\tfor (const auto &this_lambda_parameter : column_names) {\n+\t\t\t\t\tif (outer_lambda_parameter == this_lambda_parameter) {\n+\t\t\t\t\t\tthrow BinderException(\"Ambiguous lambda parameter name: '%s'. Try changing your lambda \"\n+\t\t\t\t\t\t                      \"parameter name. \\n Some list functions use lambda functions \"\n+\t\t\t\t\t\t                      \"under the hood, so *the same* function cannot be nested, like \"\n+\t\t\t\t\t\t                      \"list_intersect(list_intersect(...),...), list_has_any, list_has_all, \"\n+\t\t\t\t\t\t                      \"and their aliases. \\n \"\n+\t\t\t\t\t\t                      \"Try writing them out manually with lambda functions to define explicit \"\n+\t\t\t\t\t\t                      \"lambda parameter names.\",\n+\t\t\t\t\t\t                      outer_lambda_parameter);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t// base table alias\n \tauto params_alias = StringUtil::Join(params_strings, \", \");\n \tif (params_strings.size() > 1) {\n",
  "test_patch": "diff --git a/test/sql/function/list/lambdas/incorrect.test b/test/sql/function/list/lambdas/incorrect.test\nindex 848ab1c711b4..a0087f9eab4f 100644\n--- a/test/sql/function/list/lambdas/incorrect.test\n+++ b/test/sql/function/list/lambdas/incorrect.test\n@@ -209,3 +209,84 @@ statement error\n SELECT list_transform(UNNEST(s), x -> UNNEST(x)) FROM tbl;\n ----\n failed to bind function\n+\n+# issue #9970\n+\n+# ambiguous parameter names\n+\n+statement error\n+SELECT list_transform([1,2], x -> list_transform([3,4], x -> x));\n+----\n+Ambiguous lambda parameter name\n+\n+statement error\n+SELECT list_has_all([variable_has_all FOR variable_has_all IN ['a']], ['b']) AS list_comp_result;\n+----\n+Ambiguous lambda parameter name\n+\n+statement error\n+SELECT list_has_all(list_transform(['a'], variable_has_all -> variable_has_all), ['b']) AS list_transform_result;\n+----\n+Ambiguous lambda parameter name\n+\n+statement error\n+SELECT list_has_any(['b'], list_transform(['a'], variable_has_any -> variable_has_any)) AS list_transform_result;\n+----\n+Ambiguous lambda parameter name\n+\n+# implicit nesting creates ambiguous parameter names\n+\n+# first input parameter can be nested\n+query I\n+SELECT list_intersect(list_intersect([1], [1]), [1])\n+----\n+[1]\n+\n+# second input parameter CANNOT be nested\n+statement error\n+SELECT list_intersect([1], list_intersect([1], [1]))\n+----\n+function cannot be nested\n+\n+# first input parameter can be nested\n+query I\n+SELECT list_has_any(LIST_VALUE(list_has_any([1], [1])), [1])\n+----\n+true\n+\n+# second input parameter CANNOT be nested\n+statement error\n+SELECT list_has_any([1], LIST_VALUE(list_has_any([1], [1])))\n+----\n+function cannot be nested\n+\n+# first input parameter CANNOT be nested\n+\n+statement error\n+SELECT list_has_all(LIST_VALUE(list_has_all([1], [1])), [1])\n+----\n+function cannot be nested\n+\n+# second input parameter can be nested\n+\n+query I\n+SELECT list_has_all([1], LIST_VALUE(list_has_all([1], [1])))\n+----\n+true\n+\n+# nest different helper functions/rewrites\n+\n+query I\n+SELECT list_has_any(LIST_VALUE(list_has_all(list_intersect([1], [1]), [1])), [1]);\n+----\n+true\n+\n+query I\n+SELECT list_has_all(LIST_VALUE(list_has_any(list_intersect([1], [1]), [1])), [1]);\n+----\n+true\n+\n+query I\n+SELECT list_intersect(LIST_VALUE(list_has_all(LIST_VALUE(list_has_any([1], [1])), [1])), [1])\n+----\n+[true]\ndiff --git a/test/sql/function/list/list_intersect.test b/test/sql/function/list/list_intersect.test\nindex f086849d6cd0..2d14fd46507a 100644\n--- a/test/sql/function/list/list_intersect.test\n+++ b/test/sql/function/list/list_intersect.test\n@@ -108,10 +108,10 @@ insert into large_lists values (range(3000), range(3000));\n statement ok\n select list_intersect(l1, l2) from large_lists;\n \n-query I\n+statement error\n select list_intersect(list_intersect([1,2,3,4], [4,5,6,7]), list_intersect([4,5,6,7],[1,2,3,4]));\n ----\n-[4]\n+function cannot be nested\n \n query I\n select list_intersect(list_filter([1,2,3,4], x -> x > 2), list_filter([4,5,6,7], x -> x > 2));\n",
  "problem_statement": "list_has_all function returns wrong result when first argument uses a list comprehension or list transformation.\n### What happens?\n\n\r\nWhen doing a list comprehension in the first argument of the list_has_all function the result is true even though the correct result is false. \r\n\r\nThe example below uses the identity transformation which should not affect the output result.\r\n```\r\nD select list_has_all(['a'], ['b']) as normal_result;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 normal_result \u2502\r\n\u2502    boolean    \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 false         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD select list_has_all([x for x in ['a']], ['b']) as list_comp_result;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 list_comp_result \u2502\r\n\u2502     boolean      \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 true             \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD select list_has_all(list_transform(['a'], x -> x), ['b']) as list_transform_result;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 list_transform_result \u2502\r\n\u2502        boolean        \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 true                  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n\n### To Reproduce\n\nRun the queries above.\n\n### OS:\n\nMacOS Sonoma 14.1\n\n### DuckDB Version:\n\nv0.9.2\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nSteven Litvack-Winkler\n\n### Affiliation:\n\nObsidian Security\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "Just noticed something interesting.\r\n\r\n```\r\nD select list_has_all([x for x in ['a']], ['b']) as list_comp_result;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 list_comp_result \u2502\r\n\u2502     boolean      \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 true             \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD select list_has_all([y for y in ['a']], ['b']) as list_comp_result;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 list_comp_result \u2502\r\n\u2502     boolean      \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 false            \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nIt seems like things work weirdly if the variable 'x' in the source code macro is reused. https://github.com/duckdb/duckdb/blob/323724447b32499538630dfb052f231ff05c7a10/src/catalog/default/default_functions.cpp#L115\nThat's wild, thanks for reporting!\n```sql\r\nD select list_transform([1,2], x -> list_transform([3,4], x -> x));\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 list_transform(main.list_value(1, 2), (x -> list_transform(main.list_value(3, 4), (x -> x)))) \u2502\r\n\u2502                                           int32[][]                                           \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [[1, 1], [2, 2]]                                                                              \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nNice catch. This is reproducible without the `list_has_all`. It's a binder bug - we do not check if a lambda parameter name is already in use by an 'outer' lambda function. `list_has_all` 'hides' this from the user, and I assume it hasn't been caught before because users don't repeat variable names for nesting when typing the queries manually. I will open a PR to fix this.",
  "created_at": "2023-12-13T13:50:04Z"
}