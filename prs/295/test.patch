diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index fec483747d66..33d4b2a39f23 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -10,6 +10,7 @@ add_subdirectory(common)
 add_subdirectory(helpers)
 add_subdirectory(monetdb)
 add_subdirectory(sql)
+add_subdirectory(planner)
 add_subdirectory(optimizer)
 
 if(NOT WIN32)
diff --git a/test/planner/CMakeLists.txt b/test/planner/CMakeLists.txt
new file mode 100644
index 000000000000..a462ee7badf7
--- /dev/null
+++ b/test/planner/CMakeLists.txt
@@ -0,0 +1,5 @@
+add_library(test_planner OBJECT
+            test_projection_binding.cpp)
+set(ALL_OBJECT_FILES
+    ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:test_planner>
+    PARENT_SCOPE)
diff --git a/test/planner/test_projection_binding.cpp b/test/planner/test_projection_binding.cpp
new file mode 100644
index 000000000000..2c330d442cb2
--- /dev/null
+++ b/test/planner/test_projection_binding.cpp
@@ -0,0 +1,34 @@
+#include "catch.hpp"
+#include "expression_helper.hpp"
+#include "test_helpers.hpp"
+
+using namespace duckdb;
+using namespace std;
+
+TEST_CASE("Test projection bindings for ORDER BY", "[projection-binding-order-by]") {
+	ExpressionHelper helper;
+  using Op = LogicalOperatorType;
+
+	auto projection_matches = [&](string query, vector<LogicalOperatorType> path, size_t count) -> bool {
+		auto plan = helper.ParseLogicalTree(query);
+		for (auto type : path) {
+			if (plan->type != type)
+				return false;
+			if (plan->children.size() == 0)
+				return false;
+			plan = move(plan->children[0]);
+		}
+		return (plan->type == Op::PROJECTION && plan->expressions.size() == count);
+	};
+
+	auto &con = helper.con;
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE a (i INTEGER, j INTEGER)"));
+
+	REQUIRE(projection_matches("SELECT i FROM a ORDER BY j", {Op::PRUNE_COLUMNS, Op::ORDER_BY}, 2));
+	REQUIRE(projection_matches("SELECT i FROM a ORDER BY i", {Op::ORDER_BY}, 1));
+	REQUIRE(projection_matches("SELECT a.i FROM a ORDER BY i", {Op::ORDER_BY}, 1));
+	REQUIRE(projection_matches("SELECT i FROM a ORDER BY a.i", {Op::ORDER_BY}, 1));
+	REQUIRE(projection_matches("SELECT i AS k FROM a ORDER BY i", {Op::ORDER_BY}, 1));
+
+	con.Query("DROP TABLE a");
+}
