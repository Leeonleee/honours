{
  "repo": "duckdb/duckdb",
  "pull_number": 295,
  "instance_id": "duckdb__duckdb-295",
  "issue_numbers": [
    "293"
  ],
  "base_commit": "b551a19663e8e09446fc765478b9ed8c96c08f69",
  "patch": "diff --git a/src/include/planner/expression_binder/order_binder.hpp b/src/include/planner/expression_binder/order_binder.hpp\nindex 7d862a7a7f93..078160a74b27 100644\n--- a/src/include/planner/expression_binder/order_binder.hpp\n+++ b/src/include/planner/expression_binder/order_binder.hpp\n@@ -11,6 +11,7 @@\n #include \"common/unordered_map.hpp\"\n #include \"parser/expression_map.hpp\"\n #include \"parser/parsed_expression.hpp\"\n+#include \"planner/expression/bound_columnref_expression.hpp\"\n \n namespace duckdb {\n class Expression;\n@@ -20,9 +21,10 @@ class SelectNode;\n class OrderBinder {\n public:\n \tOrderBinder(index_t projection_index, SelectNode &node, unordered_map<string, index_t> &alias_map,\n-\t            expression_map_t<index_t> &projection_map);\n+\t            expression_map_t<index_t> &projection_map, vector<unique_ptr<ParsedExpression>> &extra_select_list);\n \n \tunique_ptr<Expression> Bind(unique_ptr<ParsedExpression> expr);\n+\tvoid RemapIndex(BoundColumnRefExpression &expr, index_t index);\n \n private:\n \tunique_ptr<Expression> CreateProjectionReference(ParsedExpression &expr, index_t index);\n@@ -31,6 +33,7 @@ class OrderBinder {\n \tSelectNode &node;\n \tunordered_map<string, index_t> &alias_map;\n \texpression_map_t<index_t> &projection_map;\n+\tvector<unique_ptr<ParsedExpression>> &extra_select_list;\n };\n \n } // namespace duckdb\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex c75fa94fdd64..a0ae1bba8563 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -89,10 +89,11 @@ unique_ptr<BoundQueryNode> Binder::Bind(SelectNode &statement) {\n \t}\n \n \t// we bind the DISTINCT ON before we bind any order, aggregations or window functions\n+\tvector<unique_ptr<ParsedExpression>> extra_select_list;\n+\tOrderBinder order_binder(result->projection_index, statement, alias_map, projection_map, extra_select_list);\n \tfor (index_t i = 0; i < statement.distinct_on_targets.size(); i++) {\n \t\t// we treat the Distinct list as a order by\n-\t\tOrderBinder distinct_binder(result->projection_index, statement, alias_map, projection_map);\n-\t\tauto bound_expr = distinct_binder.Bind(move(statement.distinct_on_targets[i]));\n+\t\tauto bound_expr = order_binder.Bind(move(statement.distinct_on_targets[i]));\n \t\tif (!bound_expr) {\n \t\t\t// DISTINCT ON non-integer constant\n \t\t\t// remove the expression from the  DISTINCT ON list\n@@ -104,7 +105,6 @@ unique_ptr<BoundQueryNode> Binder::Bind(SelectNode &statement) {\n \n \t// we bind the ORDER BY before we bind any aggregations or window functions\n \tfor (index_t i = 0; i < statement.orders.size(); i++) {\n-\t\tOrderBinder order_binder(result->projection_index, statement, alias_map, projection_map);\n \t\tauto bound_expr = order_binder.Bind(move(statement.orders[i].expression));\n \t\tif (!bound_expr) {\n \t\t\t// ORDER BY non-integer constant\n@@ -160,8 +160,26 @@ unique_ptr<BoundQueryNode> Binder::Bind(SelectNode &statement) {\n \t// after that, we bind to the SELECT list\n \tSelectBinder select_binder(*this, context, *result, info);\n \tfor (index_t i = 0; i < statement.select_list.size(); i++) {\n-\t\tSQLType result_type;\n \t\tselect_binder.BindTableNames(*statement.select_list[i]);\n+\t}\n+\t// including the extra SELECT list from DISTINCT ON & ORDER BY\n+\tunordered_map<index_t, index_t> projection_remap;\n+\tfor (index_t i = 0; i < extra_select_list.size(); i++) {\n+\t\tauto &expr = extra_select_list[i];\n+\t\tselect_binder.BindTableNames(*expr);\n+\t\t// See if it matches an entry already in the SELECT list\n+\t\tauto post_bind_index = projection_map.find(expr.get());\n+\t\tindex_t newindex;\n+\t\tif (post_bind_index != projection_map.end()) {\n+\t\t\tnewindex = post_bind_index->second;\n+\t\t} else {\n+\t\t\tnewindex = statement.select_list.size();\n+\t\t\tstatement.select_list.push_back(move(expr));\n+\t\t}\n+\t\tprojection_remap[result->column_count + i] = newindex;\n+\t}\n+\tfor (index_t i = 0; i < statement.select_list.size(); i++) {\n+\t\tSQLType result_type;\n \t\tauto expr = select_binder.Bind(statement.select_list[i], &result_type);\n \t\tresult->select_list.push_back(move(expr));\n \t\tif (i < result->column_count) {\n@@ -182,6 +200,10 @@ unique_ptr<BoundQueryNode> Binder::Bind(SelectNode &statement) {\n \tfor (index_t i = 0; i < result->orders.size(); i++) {\n \t\tassert(result->orders[i].expression->type == ExpressionType::BOUND_COLUMN_REF);\n \t\tauto &order = (BoundColumnRefExpression &)*result->orders[i].expression;\n+\t\t// See if the column index has been remapped in the projection\n+\t\tauto entry = projection_remap.find(order.binding.column_index);\n+\t\tif (entry != projection_remap.end())\n+\t\t\torder_binder.RemapIndex(order, entry->second);\n \t\tassert(order.binding.column_index < statement.select_list.size());\n \t\torder.return_type = result->select_list[order.binding.column_index]->return_type;\n \t\tassert(order.return_type != TypeId::INVALID);\n@@ -191,6 +213,10 @@ unique_ptr<BoundQueryNode> Binder::Bind(SelectNode &statement) {\n \tfor (index_t i = 0; i < result->target_distincts.size(); i++) {\n \t\tassert(result->target_distincts[i]->type == ExpressionType::BOUND_COLUMN_REF);\n \t\tauto &distinct = (BoundColumnRefExpression &)*result->target_distincts[i];\n+\t\t// See if the column index has been remapped in the projection\n+\t\tauto entry = projection_remap.find(distinct.binding.column_index);\n+\t\tif (entry != projection_remap.end())\n+\t\t\torder_binder.RemapIndex(distinct, entry->second);\n \t\tassert(distinct.binding.column_index < statement.select_list.size());\n \t\tdistinct.return_type = result->select_list[distinct.binding.column_index]->return_type;\n \t\tassert(distinct.return_type != TypeId::INVALID);\ndiff --git a/src/planner/expression_binder/order_binder.cpp b/src/planner/expression_binder/order_binder.cpp\nindex 9cd988ffe86e..ca82d02a5017 100644\n--- a/src/planner/expression_binder/order_binder.cpp\n+++ b/src/planner/expression_binder/order_binder.cpp\n@@ -3,14 +3,15 @@\n #include \"parser/expression/columnref_expression.hpp\"\n #include \"parser/expression/constant_expression.hpp\"\n #include \"parser/query_node/select_node.hpp\"\n-#include \"planner/expression/bound_columnref_expression.hpp\"\n \n using namespace duckdb;\n using namespace std;\n \n OrderBinder::OrderBinder(index_t projection_index, SelectNode &node, unordered_map<string, index_t> &alias_map,\n-                         expression_map_t<index_t> &projection_map)\n-    : projection_index(projection_index), node(node), alias_map(alias_map), projection_map(projection_map) {\n+                         expression_map_t<index_t> &projection_map,\n+                         vector<unique_ptr<ParsedExpression>> &extra_select_list)\n+    : projection_index(projection_index), node(node), alias_map(alias_map), projection_map(projection_map),\n+      extra_select_list(extra_select_list) {\n }\n \n unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &expr, index_t index) {\n@@ -18,6 +19,10 @@ unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &\n \t                                             ColumnBinding(projection_index, index));\n }\n \n+void OrderBinder::RemapIndex(BoundColumnRefExpression &expr, index_t index) {\n+\texpr.binding.column_index = index;\n+}\n+\n unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {\n \t// in the ORDER BY clause we do not bind children\n \t// we bind ONLY to the select list\n@@ -75,7 +80,7 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {\n \t\tthrow BinderException(\"for SELECT DISTINCT, ORDER BY expressions must appear in select list!\");\n \t}\n \t// otherwise we need to push the ORDER BY entry into the select list\n-\tauto result = CreateProjectionReference(*expr, node.select_list.size());\n-\tnode.select_list.push_back(move(expr));\n+\tauto result = CreateProjectionReference(*expr, node.select_list.size() + extra_select_list.size());\n+\textra_select_list.push_back(move(expr));\n \treturn result;\n }\n",
  "test_patch": "diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt\nindex fec483747d66..33d4b2a39f23 100644\n--- a/test/CMakeLists.txt\n+++ b/test/CMakeLists.txt\n@@ -10,6 +10,7 @@ add_subdirectory(common)\n add_subdirectory(helpers)\n add_subdirectory(monetdb)\n add_subdirectory(sql)\n+add_subdirectory(planner)\n add_subdirectory(optimizer)\n \n if(NOT WIN32)\ndiff --git a/test/planner/CMakeLists.txt b/test/planner/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..a462ee7badf7\n--- /dev/null\n+++ b/test/planner/CMakeLists.txt\n@@ -0,0 +1,5 @@\n+add_library(test_planner OBJECT\n+            test_projection_binding.cpp)\n+set(ALL_OBJECT_FILES\n+    ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:test_planner>\n+    PARENT_SCOPE)\ndiff --git a/test/planner/test_projection_binding.cpp b/test/planner/test_projection_binding.cpp\nnew file mode 100644\nindex 000000000000..2c330d442cb2\n--- /dev/null\n+++ b/test/planner/test_projection_binding.cpp\n@@ -0,0 +1,34 @@\n+#include \"catch.hpp\"\n+#include \"expression_helper.hpp\"\n+#include \"test_helpers.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+TEST_CASE(\"Test projection bindings for ORDER BY\", \"[projection-binding-order-by]\") {\n+\tExpressionHelper helper;\n+  using Op = LogicalOperatorType;\n+\n+\tauto projection_matches = [&](string query, vector<LogicalOperatorType> path, size_t count) -> bool {\n+\t\tauto plan = helper.ParseLogicalTree(query);\n+\t\tfor (auto type : path) {\n+\t\t\tif (plan->type != type)\n+\t\t\t\treturn false;\n+\t\t\tif (plan->children.size() == 0)\n+\t\t\t\treturn false;\n+\t\t\tplan = move(plan->children[0]);\n+\t\t}\n+\t\treturn (plan->type == Op::PROJECTION && plan->expressions.size() == count);\n+\t};\n+\n+\tauto &con = helper.con;\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE a (i INTEGER, j INTEGER)\"));\n+\n+\tREQUIRE(projection_matches(\"SELECT i FROM a ORDER BY j\", {Op::PRUNE_COLUMNS, Op::ORDER_BY}, 2));\n+\tREQUIRE(projection_matches(\"SELECT i FROM a ORDER BY i\", {Op::ORDER_BY}, 1));\n+\tREQUIRE(projection_matches(\"SELECT a.i FROM a ORDER BY i\", {Op::ORDER_BY}, 1));\n+\tREQUIRE(projection_matches(\"SELECT i FROM a ORDER BY a.i\", {Op::ORDER_BY}, 1));\n+\tREQUIRE(projection_matches(\"SELECT i AS k FROM a ORDER BY i\", {Op::ORDER_BY}, 1));\n+\n+\tcon.Query(\"DROP TABLE a\");\n+}\n",
  "problem_statement": "ORDER BY pushes unnecessary projections\n````\r\ncreate table a (i integer);\r\nexplain select a.i from a order by i;\r\n````\r\nresults in the plan\r\n````\r\nPRUNE\r\nORDER_BY\r\n    PROJECTION[i, i]\r\n        GET(a)\r\n````\r\n\r\n`i` is projected twice because the resolution of i from the order by does not recognise that i is already in the projection\n",
  "hints_text": "",
  "created_at": "2019-09-26T17:01:54Z"
}