diff --git a/src/include/planner/expression_binder/order_binder.hpp b/src/include/planner/expression_binder/order_binder.hpp
index 7d862a7a7f93..078160a74b27 100644
--- a/src/include/planner/expression_binder/order_binder.hpp
+++ b/src/include/planner/expression_binder/order_binder.hpp
@@ -11,6 +11,7 @@
 #include "common/unordered_map.hpp"
 #include "parser/expression_map.hpp"
 #include "parser/parsed_expression.hpp"
+#include "planner/expression/bound_columnref_expression.hpp"
 
 namespace duckdb {
 class Expression;
@@ -20,9 +21,10 @@ class SelectNode;
 class OrderBinder {
 public:
 	OrderBinder(index_t projection_index, SelectNode &node, unordered_map<string, index_t> &alias_map,
-	            expression_map_t<index_t> &projection_map);
+	            expression_map_t<index_t> &projection_map, vector<unique_ptr<ParsedExpression>> &extra_select_list);
 
 	unique_ptr<Expression> Bind(unique_ptr<ParsedExpression> expr);
+	void RemapIndex(BoundColumnRefExpression &expr, index_t index);
 
 private:
 	unique_ptr<Expression> CreateProjectionReference(ParsedExpression &expr, index_t index);
@@ -31,6 +33,7 @@ class OrderBinder {
 	SelectNode &node;
 	unordered_map<string, index_t> &alias_map;
 	expression_map_t<index_t> &projection_map;
+	vector<unique_ptr<ParsedExpression>> &extra_select_list;
 };
 
 } // namespace duckdb
diff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp
index c75fa94fdd64..a0ae1bba8563 100644
--- a/src/planner/binder/query_node/bind_select_node.cpp
+++ b/src/planner/binder/query_node/bind_select_node.cpp
@@ -89,10 +89,11 @@ unique_ptr<BoundQueryNode> Binder::Bind(SelectNode &statement) {
 	}
 
 	// we bind the DISTINCT ON before we bind any order, aggregations or window functions
+	vector<unique_ptr<ParsedExpression>> extra_select_list;
+	OrderBinder order_binder(result->projection_index, statement, alias_map, projection_map, extra_select_list);
 	for (index_t i = 0; i < statement.distinct_on_targets.size(); i++) {
 		// we treat the Distinct list as a order by
-		OrderBinder distinct_binder(result->projection_index, statement, alias_map, projection_map);
-		auto bound_expr = distinct_binder.Bind(move(statement.distinct_on_targets[i]));
+		auto bound_expr = order_binder.Bind(move(statement.distinct_on_targets[i]));
 		if (!bound_expr) {
 			// DISTINCT ON non-integer constant
 			// remove the expression from the  DISTINCT ON list
@@ -104,7 +105,6 @@ unique_ptr<BoundQueryNode> Binder::Bind(SelectNode &statement) {
 
 	// we bind the ORDER BY before we bind any aggregations or window functions
 	for (index_t i = 0; i < statement.orders.size(); i++) {
-		OrderBinder order_binder(result->projection_index, statement, alias_map, projection_map);
 		auto bound_expr = order_binder.Bind(move(statement.orders[i].expression));
 		if (!bound_expr) {
 			// ORDER BY non-integer constant
@@ -160,8 +160,26 @@ unique_ptr<BoundQueryNode> Binder::Bind(SelectNode &statement) {
 	// after that, we bind to the SELECT list
 	SelectBinder select_binder(*this, context, *result, info);
 	for (index_t i = 0; i < statement.select_list.size(); i++) {
-		SQLType result_type;
 		select_binder.BindTableNames(*statement.select_list[i]);
+	}
+	// including the extra SELECT list from DISTINCT ON & ORDER BY
+	unordered_map<index_t, index_t> projection_remap;
+	for (index_t i = 0; i < extra_select_list.size(); i++) {
+		auto &expr = extra_select_list[i];
+		select_binder.BindTableNames(*expr);
+		// See if it matches an entry already in the SELECT list
+		auto post_bind_index = projection_map.find(expr.get());
+		index_t newindex;
+		if (post_bind_index != projection_map.end()) {
+			newindex = post_bind_index->second;
+		} else {
+			newindex = statement.select_list.size();
+			statement.select_list.push_back(move(expr));
+		}
+		projection_remap[result->column_count + i] = newindex;
+	}
+	for (index_t i = 0; i < statement.select_list.size(); i++) {
+		SQLType result_type;
 		auto expr = select_binder.Bind(statement.select_list[i], &result_type);
 		result->select_list.push_back(move(expr));
 		if (i < result->column_count) {
@@ -182,6 +200,10 @@ unique_ptr<BoundQueryNode> Binder::Bind(SelectNode &statement) {
 	for (index_t i = 0; i < result->orders.size(); i++) {
 		assert(result->orders[i].expression->type == ExpressionType::BOUND_COLUMN_REF);
 		auto &order = (BoundColumnRefExpression &)*result->orders[i].expression;
+		// See if the column index has been remapped in the projection
+		auto entry = projection_remap.find(order.binding.column_index);
+		if (entry != projection_remap.end())
+			order_binder.RemapIndex(order, entry->second);
 		assert(order.binding.column_index < statement.select_list.size());
 		order.return_type = result->select_list[order.binding.column_index]->return_type;
 		assert(order.return_type != TypeId::INVALID);
@@ -191,6 +213,10 @@ unique_ptr<BoundQueryNode> Binder::Bind(SelectNode &statement) {
 	for (index_t i = 0; i < result->target_distincts.size(); i++) {
 		assert(result->target_distincts[i]->type == ExpressionType::BOUND_COLUMN_REF);
 		auto &distinct = (BoundColumnRefExpression &)*result->target_distincts[i];
+		// See if the column index has been remapped in the projection
+		auto entry = projection_remap.find(distinct.binding.column_index);
+		if (entry != projection_remap.end())
+			order_binder.RemapIndex(distinct, entry->second);
 		assert(distinct.binding.column_index < statement.select_list.size());
 		distinct.return_type = result->select_list[distinct.binding.column_index]->return_type;
 		assert(distinct.return_type != TypeId::INVALID);
diff --git a/src/planner/expression_binder/order_binder.cpp b/src/planner/expression_binder/order_binder.cpp
index 9cd988ffe86e..ca82d02a5017 100644
--- a/src/planner/expression_binder/order_binder.cpp
+++ b/src/planner/expression_binder/order_binder.cpp
@@ -3,14 +3,15 @@
 #include "parser/expression/columnref_expression.hpp"
 #include "parser/expression/constant_expression.hpp"
 #include "parser/query_node/select_node.hpp"
-#include "planner/expression/bound_columnref_expression.hpp"
 
 using namespace duckdb;
 using namespace std;
 
 OrderBinder::OrderBinder(index_t projection_index, SelectNode &node, unordered_map<string, index_t> &alias_map,
-                         expression_map_t<index_t> &projection_map)
-    : projection_index(projection_index), node(node), alias_map(alias_map), projection_map(projection_map) {
+                         expression_map_t<index_t> &projection_map,
+                         vector<unique_ptr<ParsedExpression>> &extra_select_list)
+    : projection_index(projection_index), node(node), alias_map(alias_map), projection_map(projection_map),
+      extra_select_list(extra_select_list) {
 }
 
 unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &expr, index_t index) {
@@ -18,6 +19,10 @@ unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &
 	                                             ColumnBinding(projection_index, index));
 }
 
+void OrderBinder::RemapIndex(BoundColumnRefExpression &expr, index_t index) {
+	expr.binding.column_index = index;
+}
+
 unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {
 	// in the ORDER BY clause we do not bind children
 	// we bind ONLY to the select list
@@ -75,7 +80,7 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {
 		throw BinderException("for SELECT DISTINCT, ORDER BY expressions must appear in select list!");
 	}
 	// otherwise we need to push the ORDER BY entry into the select list
-	auto result = CreateProjectionReference(*expr, node.select_list.size());
-	node.select_list.push_back(move(expr));
+	auto result = CreateProjectionReference(*expr, node.select_list.size() + extra_select_list.size());
+	extra_select_list.push_back(move(expr));
 	return result;
 }
