You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
ORDER BY pushes unnecessary projections
````
create table a (i integer);
explain select a.i from a order by i;
````
results in the plan
````
PRUNE
ORDER_BY
    PROJECTION[i, i]
        GET(a)
````

`i` is projected twice because the resolution of i from the order by does not recognise that i is already in the projection

</issue>
<code>
[start of README.md]
1: <img align="left" src="logo/duckdb-logo.png" height="120">
2: 
3: # DuckDB, the SQLite for Analytics
4: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
5: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
6: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
7: 
8: <br>
9: 
10: 
11: # Requirements
12: DuckDB requires [CMake](https://cmake.org) to be installed and a `C++11` compliant compiler. GCC 4.9 and newer, Clang 3.9 and newer and VisualStudio 2017 are tested on each revision.
13: 
14: ## Compiling
15: Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug versoin. You may run `make unit` and `make allunit` to verify that your version works properly after making changes.
16: 
17: # Usage
18: A command line utility based on `sqlite3` can be found in either `build/release/tools/shell/shell` (release, the default) or `build/debug/tools/shell/shell` (debug).
19: 
20: # Embedding
21: As DuckDB is an embedded database, there is no database server to launch or client to connect to a running server. However, the database server can be embedded directly into an application using the C or C++ bindings. The main build process creates the shared library `build/release/src/libduckdb.[so|dylib|dll]` that can be linked against. A static library is built as well.
22: 
23: For examples on how to embed DuckDB into your application, see the [examples](https://github.com/cwida/duckdb/tree/master/examples) folder.
24: 
25: ## Benchchmarks
26: After compiling, benchmarks can be executed from the root directory by executing `./build/release/benchmark/benchmark_runner`.
27: 
28: ## Standing on the Shoulders of Giants
29: DuckDB is implemented in C++ 11, should compile with GCC and clang, uses CMake to build and [Catch2](https://github.com/catchorg/Catch2) for testing. DuckDB uses some components from various Open-Source databases and draws inspiration from scientific publications. Here is an overview:
30: 
31: * Parser: We use the PostgreSQL parser that was [repackaged as a stand-alone library](https://github.com/lfittl/libpg_query). The translation to our own parse tree is inspired by [Peloton](https://pelotondb.io).
32: * Shell: We have adapted the [SQLite shell](https://sqlite.org/cli.html) to work with DuckDB.
33: * Tests: We use the [SQL Logic Tests from SQLite](https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki) to test DuckDB.
34: * Query fuzzing: We use [SQLsmith](https://github.com/anse1/sqlsmith) to generate random queries for additional testing.
35: * Date Math: We use the date math component from [MonetDB](https://www.monetdb.org).
36: * SQL Window Functions: DuckDB's window functions implementation uses Segment Tree Aggregation as described in the paper "Efficient Processing of Window Functions in Analytical SQL Queries" by Viktor Leis, Kan Kundhikanjana, Alfons Kemper and Thomas Neumann.
37: * Execution engine: The vectorized execution engine is inspired by the paper "MonetDB/X100: Hyper-Pipelining Query Execution" by Peter Boncz, Marcin Zukowski and Niels Nes.
38: * Optimizer: DuckDB's optimizer draws inspiration from the papers "Dynamic programming strikes back" by Guido Moerkotte and Thomas Neumman as well as "Unnesting Arbitrary Queries" by Thomas Neumann and Alfons Kemper.
39: * Concurrency control: Our MVCC implementation is inspired by the paper "Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems" by Thomas Neumann, Tobias Mühlbauer and Alfons Kemper.
40: * Regular Expression: DuckDB uses Google's [RE2](https://github.com/google/re2) regular expression engine.
41: 
42: ## Other pages
43: * [Continuous Benchmarking (CB™)](https://www.duckdb.org/benchmarks/index.html), runs TPC-H, TPC-DS and some microbenchmarks on every commit
[end of README.md]
[start of src/include/planner/expression_binder/order_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // planner/expression_binder/order_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "common/unordered_map.hpp"
12: #include "parser/expression_map.hpp"
13: #include "parser/parsed_expression.hpp"
14: 
15: namespace duckdb {
16: class Expression;
17: class SelectNode;
18: 
19: //! The ORDER binder is responsible for binding an expression within the ORDER BY clause of a SQL statement
20: class OrderBinder {
21: public:
22: 	OrderBinder(index_t projection_index, SelectNode &node, unordered_map<string, index_t> &alias_map,
23: 	            expression_map_t<index_t> &projection_map);
24: 
25: 	unique_ptr<Expression> Bind(unique_ptr<ParsedExpression> expr);
26: 
27: private:
28: 	unique_ptr<Expression> CreateProjectionReference(ParsedExpression &expr, index_t index);
29: 
30: 	index_t projection_index;
31: 	SelectNode &node;
32: 	unordered_map<string, index_t> &alias_map;
33: 	expression_map_t<index_t> &projection_map;
34: };
35: 
36: } // namespace duckdb
[end of src/include/planner/expression_binder/order_binder.hpp]
[start of src/planner/binder/query_node/bind_select_node.cpp]
1: #include "parser/expression/columnref_expression.hpp"
2: #include "parser/expression/constant_expression.hpp"
3: #include "parser/query_node/select_node.hpp"
4: #include "parser/tableref/joinref.hpp"
5: #include "planner/binder.hpp"
6: #include "planner/expression_binder/group_binder.hpp"
7: #include "planner/expression_binder/having_binder.hpp"
8: #include "planner/expression_binder/order_binder.hpp"
9: #include "planner/expression_binder/select_binder.hpp"
10: #include "planner/expression_binder/where_binder.hpp"
11: #include "planner/query_node/bound_select_node.hpp"
12: 
13: using namespace duckdb;
14: using namespace std;
15: 
16: unique_ptr<BoundQueryNode> Binder::Bind(SelectNode &statement) {
17: 	auto result = make_unique<BoundSelectNode>();
18: 	result->projection_index = GenerateTableIndex();
19: 	result->group_index = GenerateTableIndex();
20: 	result->aggregate_index = GenerateTableIndex();
21: 	result->window_index = GenerateTableIndex();
22: 
23: 	if (statement.values.size() > 0) {
24: 		// bind value list
25: 		WhereBinder binder(*this, context);
26: 		binder.target_type = SQLType(SQLTypeId::INVALID);
27: 		for (index_t list_idx = 0; list_idx < statement.values.size(); list_idx++) {
28: 			auto &expression_list = statement.values[list_idx];
29: 			vector<unique_ptr<Expression>> list;
30: 			if (list_idx == 0) {
31: 				// for the first list, we set the expected types as the types of these expressions
32: 				for (index_t val_idx = 0; val_idx < expression_list.size(); val_idx++) {
33: 					SQLType result_type;
34: 					auto expr = binder.Bind(expression_list[val_idx], &result_type);
35: 					result->types.push_back(result_type);
36: 					result->names.push_back("col" + to_string(val_idx));
37: 					list.push_back(move(expr));
38: 				}
39: 			} else {
40: 				// for subsequent lists, we apply the expected types we found in the first list
41: 				for (index_t val_idx = 0; val_idx < expression_list.size(); val_idx++) {
42: 					binder.target_type = result->types[val_idx];
43: 					list.push_back(binder.Bind(expression_list[val_idx]));
44: 				}
45: 			}
46: 			result->values.push_back(move(list));
47: 		}
48: 		return move(result);
49: 	}
50: 	// first bind the FROM table statement
51: 	if (statement.from_table) {
52: 		result->from_table = Bind(*statement.from_table);
53: 	}
54: 
55: 	// visit the select list and expand any "*" statements
56: 	vector<unique_ptr<ParsedExpression>> new_select_list;
57: 	for (auto &select_element : statement.select_list) {
58: 		if (select_element->GetExpressionType() == ExpressionType::STAR) {
59: 			// * statement, expand to all columns from the FROM clause
60: 			bind_context.GenerateAllColumnExpressions(new_select_list);
61: 		} else {
62: 			// regular statement, add it to the list
63: 			new_select_list.push_back(move(select_element));
64: 		}
65: 	}
66: 	statement.select_list = move(new_select_list);
67: 
68: 	for (auto &entry : statement.select_list) {
69: 		result->names.push_back(entry->GetName());
70: 	}
71: 	result->column_count = statement.select_list.size();
72: 
73: 	// first visit the WHERE clause
74: 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
75: 	if (statement.where_clause) {
76: 		WhereBinder where_binder(*this, context);
77: 		result->where_clause = where_binder.Bind(statement.where_clause);
78: 	}
79: 
80: 	// create a mapping of (alias -> index) and a mapping of (Expression -> index) for the SELECT list
81: 	unordered_map<string, index_t> alias_map;
82: 	expression_map_t<index_t> projection_map;
83: 	for (index_t i = 0; i < statement.select_list.size(); i++) {
84: 		auto &expr = statement.select_list[i];
85: 		if (!expr->alias.empty()) {
86: 			alias_map[expr->alias] = i;
87: 		}
88: 		projection_map[expr.get()] = i;
89: 	}
90: 
91: 	// we bind the DISTINCT ON before we bind any order, aggregations or window functions
92: 	for (index_t i = 0; i < statement.distinct_on_targets.size(); i++) {
93: 		// we treat the Distinct list as a order by
94: 		OrderBinder distinct_binder(result->projection_index, statement, alias_map, projection_map);
95: 		auto bound_expr = distinct_binder.Bind(move(statement.distinct_on_targets[i]));
96: 		if (!bound_expr) {
97: 			// DISTINCT ON non-integer constant
98: 			// remove the expression from the  DISTINCT ON list
99: 			continue;
100: 		}
101: 		assert(bound_expr->type == ExpressionType::BOUND_COLUMN_REF);
102: 		result->target_distincts.push_back(move(bound_expr));
103: 	}
104: 
105: 	// we bind the ORDER BY before we bind any aggregations or window functions
106: 	for (index_t i = 0; i < statement.orders.size(); i++) {
107: 		OrderBinder order_binder(result->projection_index, statement, alias_map, projection_map);
108: 		auto bound_expr = order_binder.Bind(move(statement.orders[i].expression));
109: 		if (!bound_expr) {
110: 			// ORDER BY non-integer constant
111: 			// remove the expression from the ORDER BY list
112: 			continue;
113: 		}
114: 		assert(bound_expr->type == ExpressionType::BOUND_COLUMN_REF);
115: 		BoundOrderByNode order_node;
116: 		order_node.expression = move(bound_expr);
117: 		order_node.type = statement.orders[i].type;
118: 		result->orders.push_back(move(order_node));
119: 	}
120: 
121: 	vector<unique_ptr<ParsedExpression>> unbound_groups;
122: 	BoundGroupInformation info;
123: 	if (statement.groups.size() > 0) {
124: 		// the statement has a GROUP BY clause, bind it
125: 		unbound_groups.resize(statement.groups.size());
126: 		GroupBinder group_binder(*this, context, statement, result->group_index, alias_map, info.alias_map);
127: 		for (index_t i = 0; i < statement.groups.size(); i++) {
128: 
129: 			// we keep a copy of the unbound expression;
130: 			// we keep the unbound copy around to check for group references in the SELECT and HAVING clause
131: 			// the reason we want the unbound copy is because we want to figure out whether an expression
132: 			// is a group reference BEFORE binding in the SELECT/HAVING binder
133: 			group_binder.unbound_expression = statement.groups[i]->Copy();
134: 			group_binder.bind_index = i;
135: 
136: 			// bind the groups
137: 			SQLType group_type;
138: 			auto bound_expr = group_binder.Bind(statement.groups[i], &group_type);
139: 			assert(bound_expr->return_type != TypeId::INVALID);
140: 			info.group_types.push_back(group_type);
141: 			result->groups.push_back(move(bound_expr));
142: 
143: 			// in the unbound expression we DO bind the table names of any ColumnRefs
144: 			// we do this to make sure that "table.a" and "a" are treated the same
145: 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
146: 			// hence we convert "a" -> "test.a" in the unbound expression
147: 			unbound_groups[i] = move(group_binder.unbound_expression);
148: 			group_binder.BindTableNames(*unbound_groups[i]);
149: 			info.map[unbound_groups[i].get()] = i;
150: 		}
151: 	}
152: 
153: 	// bind the HAVING clause, if any
154: 	if (statement.having) {
155: 		HavingBinder having_binder(*this, context, *result, info);
156: 		having_binder.BindTableNames(*statement.having);
157: 		result->having = having_binder.Bind(statement.having);
158: 	}
159: 
160: 	// after that, we bind to the SELECT list
161: 	SelectBinder select_binder(*this, context, *result, info);
162: 	for (index_t i = 0; i < statement.select_list.size(); i++) {
163: 		SQLType result_type;
164: 		select_binder.BindTableNames(*statement.select_list[i]);
165: 		auto expr = select_binder.Bind(statement.select_list[i], &result_type);
166: 		result->select_list.push_back(move(expr));
167: 		if (i < result->column_count) {
168: 			result->types.push_back(result_type);
169: 		}
170: 	}
171: 	// in the normal select binder, we bind columns as if there is no aggregation
172: 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
173: 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
174: 	// we choose the former one [CONTROVERSIAL: this is the PostgreSQL behavior]
175: 	if (result->aggregates.size() > 0) {
176: 		if (select_binder.BoundColumns()) {
177: 			throw BinderException("column must appear in the GROUP BY clause or be used in an aggregate function");
178: 		}
179: 	}
180: 
181: 	// resolve the types of the ORDER BY clause
182: 	for (index_t i = 0; i < result->orders.size(); i++) {
183: 		assert(result->orders[i].expression->type == ExpressionType::BOUND_COLUMN_REF);
184: 		auto &order = (BoundColumnRefExpression &)*result->orders[i].expression;
185: 		assert(order.binding.column_index < statement.select_list.size());
186: 		order.return_type = result->select_list[order.binding.column_index]->return_type;
187: 		assert(order.return_type != TypeId::INVALID);
188: 	}
189: 
190: 	// resolve the types of the DISTINCT ON clause
191: 	for (index_t i = 0; i < result->target_distincts.size(); i++) {
192: 		assert(result->target_distincts[i]->type == ExpressionType::BOUND_COLUMN_REF);
193: 		auto &distinct = (BoundColumnRefExpression &)*result->target_distincts[i];
194: 		assert(distinct.binding.column_index < statement.select_list.size());
195: 		distinct.return_type = result->select_list[distinct.binding.column_index]->return_type;
196: 		assert(distinct.return_type != TypeId::INVALID);
197: 	}
198: 
199: 	return move(result);
200: }
[end of src/planner/binder/query_node/bind_select_node.cpp]
[start of src/planner/expression_binder/order_binder.cpp]
1: #include "planner/expression_binder/order_binder.hpp"
2: 
3: #include "parser/expression/columnref_expression.hpp"
4: #include "parser/expression/constant_expression.hpp"
5: #include "parser/query_node/select_node.hpp"
6: #include "planner/expression/bound_columnref_expression.hpp"
7: 
8: using namespace duckdb;
9: using namespace std;
10: 
11: OrderBinder::OrderBinder(index_t projection_index, SelectNode &node, unordered_map<string, index_t> &alias_map,
12:                          expression_map_t<index_t> &projection_map)
13:     : projection_index(projection_index), node(node), alias_map(alias_map), projection_map(projection_map) {
14: }
15: 
16: unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &expr, index_t index) {
17: 	return make_unique<BoundColumnRefExpression>(expr.GetName(), TypeId::INVALID,
18: 	                                             ColumnBinding(projection_index, index));
19: }
20: 
21: unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {
22: 	// in the ORDER BY clause we do not bind children
23: 	// we bind ONLY to the select list
24: 	// if there is no matching entry in the SELECT list already, we add the expression to the SELECT list and refer the
25: 	// new expression the new entry will then be bound later during the binding of the SELECT list we also don't do type
26: 	// resolution here: this only happens after the SELECT list has been bound
27: 	switch (expr->expression_class) {
28: 	case ExpressionClass::CONSTANT: {
29: 		// ORDER BY constant
30: 		// is the ORDER BY expression a constant integer? (e.g. ORDER BY 1)
31: 		auto &constant = (ConstantExpression &)*expr;
32: 		// ORDER BY a constant
33: 		if (!TypeIsIntegral(constant.value.type)) {
34: 			// non-integral expression, we just leave the constant here.
35: 			// ORDER BY <constant> has no effect
36: 			// CONTROVERSIAL: maybe we should throw an error
37: 			return nullptr;
38: 		}
39: 		// INTEGER constant: we use the integer as an index into the select list (e.g. ORDER BY 1)
40: 		auto index = (index_t)constant.value.GetNumericValue();
41: 		if (index < 1 || index > node.select_list.size()) {
42: 			throw BinderException("ORDER term out of range - should be between 1 and %lld",
43: 			                      (index_t)node.select_list.size());
44: 		}
45: 		return CreateProjectionReference(*expr, index - 1);
46: 	}
47: 	case ExpressionClass::COLUMN_REF: {
48: 		// COLUMN REF expression
49: 		// check if we can bind it to an alias in the select list
50: 		auto &colref = (ColumnRefExpression &)*expr;
51: 		// if there is an explicit table name we can't bind to an alias
52: 		if (!colref.table_name.empty()) {
53: 			break;
54: 		}
55: 		// check the alias list
56: 		auto entry = alias_map.find(colref.column_name);
57: 		if (entry != alias_map.end()) {
58: 			// it does! point it to that entry
59: 			return CreateProjectionReference(*expr, entry->second);
60: 		}
61: 		break;
62: 	}
63: 	default:
64: 		break;
65: 	}
66: 	// general case
67: 	// first check if the ORDER BY clause already points to an entry in the projection list
68: 	auto entry = projection_map.find(expr.get());
69: 	if (entry != projection_map.end()) {
70: 		// there is a matching entry in the projection list
71: 		// just point to that entry
72: 		return CreateProjectionReference(*expr, entry->second);
73: 	}
74: 	if (node.select_distinct) {
75: 		throw BinderException("for SELECT DISTINCT, ORDER BY expressions must appear in select list!");
76: 	}
77: 	// otherwise we need to push the ORDER BY entry into the select list
78: 	auto result = CreateProjectionReference(*expr, node.select_list.size());
79: 	node.select_list.push_back(move(expr));
80: 	return result;
81: }
[end of src/planner/expression_binder/order_binder.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: