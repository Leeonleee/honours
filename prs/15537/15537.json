{
  "repo": "duckdb/duckdb",
  "pull_number": 15537,
  "instance_id": "duckdb__duckdb-15537",
  "issue_numbers": [
    "15528"
  ],
  "base_commit": "1342bdbf2d809a4194f2767c3020181ce5199df7",
  "patch": "diff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 9fb078e9f0a9..13cd5e1512ba 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -2022,8 +2022,11 @@ py::dict DuckDBPyConnection::FetchTF() {\n }\n \n PolarsDataFrame DuckDBPyConnection::FetchPolars(idx_t rows_per_batch) {\n-\tauto arrow = FetchArrow(rows_per_batch);\n-\treturn py::cast<PolarsDataFrame>(py::module::import(\"polars\").attr(\"DataFrame\")(arrow));\n+\tif (!con.HasResult()) {\n+\t\tthrow InvalidInputException(\"No open result set\");\n+\t}\n+\tauto &result = con.GetResult();\n+\treturn result.ToPolars(rows_per_batch);\n }\n \n duckdb::pyarrow::RecordBatchReader DuckDBPyConnection::FetchRecordBatchReader(const idx_t rows_per_batch) {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/arrow/test_polars.py b/tools/pythonpkg/tests/fast/arrow/test_polars.py\nindex 1238bd3ec10e..df1a683a917e 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_polars.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_polars.py\n@@ -30,6 +30,10 @@ def test_polars(self, duckdb_cursor):\n         con_result = con.execute('SELECT * FROM df').pl()\n         pl_testing.assert_frame_equal(df, con_result)\n \n+    def test_execute_polars(self, duckdb_cursor):\n+        res1 = duckdb_cursor.execute(\"SELECT 1 AS a, 2 AS a\").pl()\n+        assert res1.columns == ['a', 'a_1']\n+\n     def test_register_polars(self, duckdb_cursor):\n         con = duckdb.connect()\n         df = pl.DataFrame(\n",
  "problem_statement": "Pandas (.df()) and fetchall() but not Polars (.pl()) rename column name conflicts \n### What happens?\r\n\r\nIf two tables with identical column names are joined, and the identical column names are selected from each table and retrieved using the Python API via .pl(), this fails with the error \"polars.exceptions.ShapeError: M column names provided for a DataFrame of width N\" (where M is the number of columns participating in the conflict, and N is the number of unique names. Pandas and fetchall() assign a unique suffix (i.e. _1). I'm not sure if this is a bug or intended behavior, but my vote would be to have the behavior be consistent across all manners of fetching rows. Thank you!\r\n\r\n### To Reproduce\r\n\r\n```\r\nimport duckdb as dd\r\n\r\nconn = dd.connect()\r\nconn.execute(\"CREATE TABLE one (a INTEGER); CREATE TABLE two (a INTEGER); SELECT one.a, two.a FROM one JOIN two ON one.a = two.a\").pl()\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu Jammy Jellyfish\r\n\r\n### DuckDB Version:\r\n\r\n1.1.3\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nBen Skubi\r\n\r\n### Affiliation:\r\n\r\nOHSU\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Thanks for opening this issue! Based on our automated check, it seems that your post contains some code but it does not use [code blocks](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-and-highlighting-code-blocks) to format it.\n          \nPlease double-check your post and revise it if necessary. To employ syntax highlighting, it's recommended to use code blocks with triple backticks, e.g.:\n````\n```sql\nSELECT ...\n```\n````\nIf this is a false positive, feel free to disregard this comment.\n\nMWE:\r\n\r\n```python\r\nimport duckdb as dd\r\ndd.execute(\"SELECT 1 AS a, 2 AS a\").pl()\r\n```\r\n\r\nConfusingly, \r\n\r\n```python\r\nimport duckdb as dd\r\ndd.query(\"SELECT 1 AS a, 2 AS a\").pl()\r\ndd.query(\"SELECT 1 AS a, 2 AS a\").execute().pl()\r\n```\r\nwork as expected. See https://github.com/duckdb/duckdb/issues/11085 for similar problems with / differences between `execute` and query. ",
  "created_at": "2025-01-03T11:10:57Z"
}