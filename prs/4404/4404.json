{
  "repo": "duckdb/duckdb",
  "pull_number": 4404,
  "instance_id": "duckdb__duckdb-4404",
  "issue_numbers": [
    "4389"
  ],
  "base_commit": "a086308b550a09dd825a502d32277493e9c4002f",
  "patch": "diff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp\nindex e529acf551ad..33ab8e8439fa 100644\n--- a/tools/jdbc/src/jni/duckdb_java.cpp\n+++ b/tools/jdbc/src/jni/duckdb_java.cpp\n@@ -623,7 +623,10 @@ JNIEXPORT jobjectArray JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1fetch(\n \t\tcase LogicalTypeId::DOUBLE:\n \t\t\tconstlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(double));\n \t\t\tbreak;\n+\t\tcase LogicalTypeId::TIMESTAMP_SEC:\n+\t\tcase LogicalTypeId::TIMESTAMP_MS:\n \t\tcase LogicalTypeId::TIMESTAMP:\n+\t\tcase LogicalTypeId::TIMESTAMP_NS:\n \t\tcase LogicalTypeId::TIMESTAMP_TZ:\n \t\t\tconstlen_data = env->NewDirectByteBuffer(FlatVector::GetData(vec), row_count * sizeof(timestamp_t));\n \t\t\tbreak;\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java\nindex 2941ab76227a..cafae3953fbb 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBColumnType.java\n@@ -2,5 +2,6 @@\n \n public enum DuckDBColumnType {\n \tBOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, UTINYINT, USMALLINT, UINTEGER, UBIGINT, HUGEINT, FLOAT, DOUBLE,\n-\tDECIMAL, VARCHAR, BLOB, TIME, DATE, TIMESTAMP, TIMESTAMP_WITH_TIME_ZONE, INTERVAL, LIST, STRUCT, ENUM, UUID\n+\tDECIMAL, VARCHAR, BLOB, TIME, DATE, TIMESTAMP, TIMESTAMP_MS, TIMESTAMP_NS, TIMESTAMP_S, TIMESTAMP_WITH_TIME_ZONE,\n+\tINTERVAL, LIST, STRUCT, ENUM, UUID\n }\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java\nindex fbdeba4d1598..cf87fba1bdcd 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSet.java\n@@ -156,6 +156,9 @@ public Object getObject(int columnIndex) throws SQLException {\n \t\tcase DATE:\n \t\t\treturn getDate(columnIndex);\n \t\tcase TIMESTAMP:\n+\t\tcase TIMESTAMP_NS:\n+\t\tcase TIMESTAMP_S:\n+\t\tcase TIMESTAMP_MS:\n \t\t\treturn getTimestamp(columnIndex);\n \t\tcase TIMESTAMP_WITH_TIME_ZONE:\n \t\t\treturn getOffsetDateTime(columnIndex);\n@@ -476,7 +479,15 @@ public Timestamp getTimestamp(int columnIndex) throws SQLException {\n \t\tif (isType(columnIndex, DuckDBColumnType.TIMESTAMP)) {\n \t\t\treturn DuckDBTimestamp.toSqlTimestamp(getbuf(columnIndex, 8).getLong());\n \t\t}\n-\n+\t\tif (isType(columnIndex, DuckDBColumnType.TIMESTAMP_MS)) {\n+\t\t\treturn DuckDBTimestamp.toSqlTimestamp(getbuf(columnIndex, 8).getLong() * 1000);\n+\t\t}\n+\t\tif (isType(columnIndex, DuckDBColumnType.TIMESTAMP_NS)) {\n+\t\t\treturn DuckDBTimestamp.toSqlTimestampNanos(getbuf(columnIndex, 8).getLong());\n+\t\t}\n+\t\tif (isType(columnIndex, DuckDBColumnType.TIMESTAMP_S)) {\n+\t\t\treturn DuckDBTimestamp.toSqlTimestamp(getbuf(columnIndex, 8).getLong() * 1_000_000);\n+\t\t}\n \t\tObject o = getObject(columnIndex);\n \t\treturn Timestamp.valueOf(o.toString());\n \t}\n@@ -499,7 +510,6 @@ private OffsetDateTime getOffsetDateTime(int columnIndex) throws SQLException {\n \t\tif (isType(columnIndex, DuckDBColumnType.TIMESTAMP_WITH_TIME_ZONE)) {\n \t\t\treturn DuckDBTimestamp.toOffsetDateTime(getbuf(columnIndex, 8).getLong());\n \t\t}\n-\n \t\tObject o = getObject(columnIndex);\n \t\treturn OffsetDateTime.parse(o.toString());\n \t}\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\nindex 8407e581fbe2..6b619c760a19 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBResultSetMetaData.java\n@@ -109,7 +109,10 @@ public static int type_to_int(DuckDBColumnType type) throws SQLException {\n \t\t\treturn Types.TIME;\n \t\tcase DATE:\n \t\t\treturn Types.DATE;\n+\t\tcase TIMESTAMP_S:\n+\t\tcase TIMESTAMP_MS:\n \t\tcase TIMESTAMP:\n+\t\tcase TIMESTAMP_NS:\n \t\t\treturn Types.TIMESTAMP;\n \t\tcase TIMESTAMP_WITH_TIME_ZONE:\n \t\t\treturn Types.TIME_WITH_TIMEZONE;\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBTimestamp.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBTimestamp.java\nindex 1a031443d9dd..fb79802b8a10 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBTimestamp.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBTimestamp.java\n@@ -41,7 +41,12 @@ public static Timestamp toSqlTimestamp(long timeMicros) {\n \t\t\tLocalDateTime.ofEpochSecond(micros2seconds(timeMicros)\n \t\t\t\t, nanosPartMicros(timeMicros), ZoneOffset.UTC));\n \t}\n-\t\n+\n+\tpublic static Timestamp toSqlTimestampNanos(long timeNanos) {\n+\t\treturn Timestamp.valueOf(\n+\t\t\tLocalDateTime.ofEpochSecond(nanos2seconds(timeNanos)\n+\t\t\t\t, nanosPartNanos(timeNanos), ZoneOffset.UTC));\n+\t}\n \tpublic static LocalDateTime toLocalDateTime(long timeMicros) {\n \t\treturn LocalDateTime.ofEpochSecond(micros2seconds(timeMicros)\n \t\t\t\t, nanosPartMicros(timeMicros), ZoneOffset.UTC);\n@@ -94,4 +99,21 @@ private static int nanosPartMicros(long micros) {\n \t\t\treturn (int) ((1000_000L + (micros % 1000_000L)) * 1000);\n \t\t}\n \t}\n+\n+\tprivate static long nanos2seconds(long nanos) {\n+\t\tif ((nanos % 1_000_000_000L) >= 0) {\n+\t\t\treturn nanos / 1_000_000_000L;\n+\t\t} else {\n+\t\t\treturn (nanos / 1_000_000_000L) -1;\n+\t\t}\n+\t}\n+\n+\tprivate static int nanosPartNanos(long nanos) {\n+\t\tif ((nanos % 1_000_000_000L) >= 0) {\n+\t\t\treturn (int) ((nanos % 1_000_000_000L));\n+\t\t}\n+\t\telse {\n+\t\t\treturn (int) ((1_000_000_000L + (nanos % 1_000_000_000L)));\n+\t\t}\n+\t}\n }\n",
  "test_patch": "diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex e701a0bb1351..b104c75e1d07 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -329,6 +329,54 @@ public static void test_enum() throws Exception {\n \t\tconn.close();\n \t}\n \n+\tpublic static void test_timestamp_ms() throws Exception {\n+\t\tString expectedString = \"2022-08-17 12:11:10.999\";\n+\t\tString sql = \"SELECT '2022-08-17T12:11:10.999'::TIMESTAMP_MS as ts_ms\";\n+\t\tassert_timestamp_match(sql, expectedString, \"TIMESTAMP_MS\");\n+\t}\n+\n+\tpublic static void test_timestamp_ns() throws Exception {\n+\t\tString expectedString = \"2022-08-17 12:11:10.999999\";\n+\t\tString sql = \"SELECT '2022-08-17T12:11:10.999999999'::TIMESTAMP_NS as ts_ns\";\n+\t\tassert_timestamp_match(sql, expectedString, \"TIMESTAMP_NS\");\n+\t}\n+\n+\tpublic static void test_timestamp_s() throws Exception {\n+\t\tString expectedString = \"2022-08-17 12:11:10\";\n+\t\tString sql = \"SELECT '2022-08-17T12:11:10'::TIMESTAMP_S as ts_s\";\n+\t\tassert_timestamp_match(sql, expectedString, \"TIMESTAMP_S\");\n+\t}\n+\n+\tprivate static void assert_timestamp_match(String fetchSql, String expectedString, String expectedTypeName) throws Exception {\n+\t\tString originalTzProperty = System.getProperty(\"user.timezone\");\n+\t\tTimeZone originalTz = TimeZone.getDefault();\n+\t\ttry {\n+\t\t\tTimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\n+\t\t\tSystem.setProperty(\"user.timezone\", \"UTC\");\n+\t\t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\t\tStatement stmt = conn.createStatement();\n+\n+\t\t\tResultSet rs = stmt.executeQuery(fetchSql);\n+\t\t\tassertTrue(rs.next());\n+\t\t\tTimestamp actual = rs.getTimestamp(1);\n+\n+\t\t\tTimestamp expected = Timestamp.valueOf(expectedString);\n+\n+\t\t\tassertEquals(expected.getTime(), actual.getTime());\n+\t\t\tassertEquals(expected.getNanos(), actual.getNanos());\n+\n+\t\t\tassertEquals(Types.TIMESTAMP, rs.getMetaData().getColumnType(1));\n+\t\t\tassertEquals(expectedTypeName, rs.getMetaData().getColumnTypeName(1));\n+\n+\t\t\trs.close();\n+\t\t\tstmt.close();\n+\t\t\tconn.close();\n+\t\t} finally {\n+\t\t\tTimeZone.setDefault(originalTz);\n+\t\t\tSystem.setProperty(\"user.timezone\", originalTzProperty);\n+\t\t}\n+\t}\n+\n \tpublic static void test_timestamp_tz() throws Exception {\n \t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n \t\tStatement stmt = conn.createStatement();\n",
  "problem_statement": "[JDBC] unsupported timestamp types: timestamp_ms, timestamp_ns, timestamp_s\n### What happens?\n\nJDBC driver fails to deserialize timestamp in any non-microsecond form. \r\n\r\nthe sql query: `select CAST(now() AS TIMESTAMP_MS)`\r\n\r\nFails with the error: \r\n```\r\nNo enum constant org.duckdb.DuckDBColumnType.TIMESTAMP_MS\r\njava.lang.IllegalArgumentException: No enum constant org.duckdb.DuckDBColumnType.TIMESTAMP_MS\r\n\tat java.base/java.lang.Enum.valueOf(Enum.java:273)\r\n\tat org.duckdb.DuckDBColumnType.valueOf(DuckDBColumnType.java:3)\r\n\tat org.duckdb.DuckDBResultSetMetaData.TypeNameToType(DuckDBResultSetMetaData.java:51)\r\n\tat org.duckdb.DuckDBResultSetMetaData.<init>(DuckDBResultSetMetaData.java:29)\r\n\tat org.duckdb.DuckDBNative.duckdb_jdbc_meta(Native Method)\r\n\tat org.duckdb.DuckDBPreparedStatement.prepare(DuckDBPreparedStatement.java:97)\r\n\tat org.duckdb.DuckDBPreparedStatement.executeQuery(DuckDBPreparedStatement.java:174)\r\n```\r\n\r\nSimilarly, it fails with `TIMESTAMP_S` and `TIMESTAMP_NS` as well.\r\n\r\nRan into this while trying to reproduce #4388 using the JDBC driver as well as the work to support arrow with jdbc (https://github.com/duckdb/duckdb/pull/4071#issuecomment-1179460128)\r\n\r\nI have an implementation here that could be extracted and pulled into its own PR:\r\nhttps://github.com/jonathanswenson/duckdb/commit/77ec47eb367755e3412aa5a3f2b3fb0b354d84f9#diff-66fcba33d6157d817b0cc8127a9a67e50cee82e51797d4463a580df4be00ca6fR492\n\n### To Reproduce\n\n```\r\nConnection connection = getConnection(); // implement this somehow \r\nStatement statement = connection.createStatement();\r\nString sql = \"select CAST(now() AS TIMESTAMP_MS)\";\r\nResultSet resultSet = statement.executeQuery(sql);\r\nresultSet.next();\r\nresultSet.getString(1);\r\n```\r\n\r\n```\r\nselect CAST(now() AS TIMESTAMP_MS)\r\nselect CAST(now() AS TIMESTAMP_NS)\r\nselect CAST(now() AS TIMESTAMP_S)\r\n```\n\n### OS:\n\nOSX\n\n### DuckDB Version:\n\n0.4.0\n\n### DuckDB Client:\n\nJAVA\n\n### Full Name:\n\nJonathan Swenson\n\n### Affiliation:\n\nOmni\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "@jonathanswenson it looks like you already have a pretty well tested implementation on your branch, feel free to extract it and create a pr? If you don't have the time, I'm happy to extract it and attribute the commits to you",
  "created_at": "2022-08-15T19:08:35Z"
}