You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Appending Int32 via Julia client truncates module Int16
### What happens?

When appending an `Int32` (4 byte integer) julia value to a DuckDB, it gets truncated module `Int16` (2 byte integer). For example, appending an `Int32(2^16)` fills the entry with the value `0` instead of `65536`. Might be due to [this line](https://github.com/duckdb/duckdb/blob/0ec9ff78c80e0d11268b22fbfc7e35fd47bc558b/tools/juliapkg/src/api.jl#L2613) in the DuckDB source code.

### To Reproduce

Script:

```julia
using DuckDB
db = DuckDB.DB("test.duckdb")

DBInterface.execute(db, "CREATE TABLE mytable(id INTEGER)")

appender = DuckDB.Appender(db, "mytable")

DuckDB.append(appender, Int32(2^16))
DuckDB.end_row(appender)
DuckDB.flush(appender)
DuckDB.close(appender)

res = DBInterface.execute(db, "SELECT id FROM mytable")
```

Output:

```julia
(id = Union{Missing, Int32}[0],)
```

whereas I was expecting

```julia
(id = Union{Missing, Int32}[65536],)
```

This is my minimal julia (v1.10.4) enviroment to reproduce

```
(jl_CoroC4) pkg> status
Status `/tmp/jl_CoroC4/Project.toml`
  [d2f5444f] DuckDB v1.0.0

(jl_CoroC4) pkg> status --manifest
Status `/tmp/jl_CoroC4/Manifest.toml`
  [a10d1c49] DBInterface v2.6.1
  [9a962f9c] DataAPI v1.16.0
  [e2d170a0] DataValueInterfaces v1.0.0
  [d2f5444f] DuckDB v1.0.0
  [fb4d412d] FixedPointDecimals v0.5.2
  [842dd82b] InlineStrings v1.4.1
  [82899510] IteratorInterfaceExtensions v1.0.0
  [692b3bcd] JLLWrappers v1.5.0
  [bac558e1] OrderedCollections v1.6.3
  [69de0a69] Parsers v2.8.1
  [aea7be01] PrecompileTools v1.2.1
  [21216c6a] Preferences v1.4.3
  [3783bdb8] TableTraits v1.0.1
  [bd369af6] Tables v1.11.1
  [ea10d353] WeakRefStrings v1.4.2
  [2cbbab25] DuckDB_jll v1.0.0+0
  [56f22d72] Artifacts
  [ade2ca70] Dates
  [8f399da3] Libdl
  [37e2e46d] LinearAlgebra
  [de0858da] Printf
  [9a3f8284] Random
  [ea8e919c] SHA v0.7.0
  [fa267f1f] TOML v1.0.3
  [cf7118a7] UUIDs
  [4ec0a83e] Unicode
  [e66e0078] CompilerSupportLibraries_jll v1.1.1+0
  [4536629a] OpenBLAS_jll v0.3.23+4
  [8e850b90] libblastrampoline_jll v5.8.0+1
```

### OS:

Ubuntu 24.04 amd64

### DuckDB Version:

1.0.0 (everything installed by adding DuckDB.jl v1.0.0)

### DuckDB Client:

Julia (julia v1.10.4)

### Full Name:

Pietro Vertechi

### Affiliation:

Lambda Solutions

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with the stable release.

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of tools/juliapkg/Project.toml]
1: name = "DuckDB"
2: uuid = "d2f5444f-75bc-4fdf-ac35-56f514c445e1"
3: authors = ["Mark Raasveldt <mark@duckdblabs.com", "Hannes MÃ¼hleisen <hannes@duckdblabs.com>"]
4: version = "1.0.0"
5: 
6: [deps]
7: DBInterface = "a10d1c49-ce27-4219-8d33-6db1a4562965"
8: Dates = "ade2ca70-3891-5945-98fb-dc099432e06a"
9: DuckDB_jll = "2cbbab25-fc8b-58cf-88d4-687a02676033"
10: FixedPointDecimals = "fb4d412d-6eee-574d-9565-ede6634db7b0"
11: Tables = "bd369af6-aec1-5ad0-b16a-f7cc5008161c"
12: UUIDs = "cf7118a7-6976-5b1a-9a39-7adc72f591a4"
13: WeakRefStrings = "ea10d353-3f73-51f8-a26c-33c1cb351aa5"
14: 
15: [compat]
16: DBInterface = "2.5"
17: DuckDB_jll = "1.0.0"
18: FixedPointDecimals = "0.4, 0.5"
19: Tables = "1.7"
20: WeakRefStrings = "1.4"
21: julia = "1.6"
[end of tools/juliapkg/Project.toml]
[start of tools/juliapkg/src/api.jl]
1: using Base.Libc
2: 
3: if "JULIA_DUCKDB_LIBRARY" in keys(ENV)
4:     libduckdb = ENV["JULIA_DUCKDB_LIBRARY"]
5: else
6:     using DuckDB_jll
7: end
8: 
9: #=//===--------------------------------------------------------------------===//
10: // Open/Connect
11: //===--------------------------------------------------------------------===//
12: =#
13: """
14: 	duckdb_open(path, out_database)
15: Creates a new database or opens an existing database file stored at the given path.
16: If no path is given a new in-memory database is created instead.
17: * `path`: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
18: * `out_database`: The result database object.
19: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
20: """
21: function duckdb_open(path, out_database)
22:     return ccall((:duckdb_open, libduckdb), duckdb_state, (Ptr{UInt8}, Ref{duckdb_database}), path, out_database)
23: end
24: """
25: 	Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the given path.
26: 
27:     * path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
28:     * out_database: The result database object.
29:     * config: (Optional) configuration used to start up the database system.
30:     * out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.
31:     Note that the error must be freed using `duckdb_free`.
32:     * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
33: """
34: function duckdb_open_ext(path, out_database, config, out_error)
35:     return ccall(
36:         (:duckdb_open_ext, libduckdb),
37:         duckdb_state,
38:         (Ptr{UInt8}, Ref{duckdb_database}, duckdb_config, Ptr{Ptr{UInt8}}),
39:         path,
40:         out_database,
41:         config,
42:         out_error
43:     )
44: end
45: """
46: 	duckdb_close(database)
47: Closes the specified database and de-allocates all memory allocated for that database.
48: This should be called after you are done with any database allocated through `duckdb_open`.
49: Note that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.
50: Still it is recommended to always correctly close a database object after you are done with it.
51: * `database`: The database object to shut down.
52: """
53: function duckdb_close(database)
54:     return ccall((:duckdb_close, libduckdb), Cvoid, (Ref{duckdb_database},), database)
55: end
56: """
57: 	duckdb_connect(database, out_connection)
58: Opens a connection to a database. Connections are required to query the database, and store transactional state
59: associated with the connection.
60: * `database`: The database file to connect to.
61: * `out_connection`: The result connection object.
62: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
63: """
64: function duckdb_connect(database, out_connection)
65:     return ccall(
66:         (:duckdb_connect, libduckdb),
67:         duckdb_state,
68:         (duckdb_database, Ref{duckdb_connection}),
69:         database,
70:         out_connection
71:     )
72: end
73: 
74: """
75: 	duckdb_disconnect(connection)
76: Closes the specified connection and de-allocates all memory allocated for that connection.
77: * `connection`: The connection to close.
78: """
79: function duckdb_disconnect(connection)
80:     return ccall((:duckdb_disconnect, libduckdb), Cvoid, (Ref{duckdb_connection},), connection)
81: end
82: 
83: #=
84: //===--------------------------------------------------------------------===//
85: // Configuration
86: //===--------------------------------------------------------------------===//
87: =#
88: 
89: """
90: 	duckdb_create_config(config)
91: Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance
92: through `duckdb_open_ext`.
93: This will always succeed unless there is a malloc failure.
94: * `out_config`: The result configuration object.
95: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
96: """
97: function duckdb_create_config(config)
98:     return ccall((:duckdb_create_config, libduckdb), duckdb_state, (Ref{duckdb_config},), config)
99: end
100: 
101: """
102: 	duckdb_config_count()
103: This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.
104: This should not be called in a loop as it internally loops over all the options.
105: * returns: The amount of config options available.
106: """
107: function duckdb_config_count()
108:     return ccall((:duckdb_config_count, libduckdb), Int32, ())
109: end
110: 
111: """
112: 	duckdb_get_config_flag(index,out_name,out_description)
113: Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.
114: display configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).
115: The result name or description MUST NOT be freed.
116: * `index`: The index of the configuration option (between 0 and `duckdb_config_count`)
117: * `out_name`: A name of the configuration flag.
118: * `out_description`: A description of the configuration flag.
119: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
120: """
121: function duckdb_get_config_flag(index, out_name, out_description)
122:     return ccall(
123:         (:duckdb_get_config_flag, libduckdb),
124:         duckdb_state,
125:         (Int32, Ptr{Ptr{UInt8}}, Ptr{Ptr{UInt8}}),
126:         index,
127:         out_name,
128:         out_description
129:     )
130: end
131: 
132: """
133: 	duckdb_set_config(config,name,option)
134: Sets the specified option for the specified configuration. The configuration option is indicated by name.
135: To obtain a list of config options, see `duckdb_get_config_flag`.
136: In the source code, configuration options are defined in `config.cpp`.
137: This can fail if either the name is invalid, or if the value provided for the option is invalid.
138: * `duckdb_config`: The configuration object to set the option on.
139: * `name`: The name of the configuration flag to set.
140: * `option`: The value to set the configuration flag to.
141: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
142: """
143: function duckdb_set_config(config, name, option)
144:     return ccall(
145:         (:duckdb_set_config, libduckdb),
146:         duckdb_state,
147:         (duckdb_config, Ptr{UInt8}, Ptr{UInt8}),
148:         config,
149:         name,
150:         option
151:     )
152: end
153: 
154: """
155: 	duckdb_destroy_config(config)
156: Destroys the specified configuration option and de-allocates all memory allocated for the object.
157: * `config`: The configuration object to destroy.
158: """
159: function duckdb_destroy_config(config)
160:     return ccall((:duckdb_destroy_config, libduckdb), Cvoid, (Ref{duckdb_config},), config)
161: end
162: 
163: #=
164: //===--------------------------------------------------------------------===//
165: // Query Execution
166: //===--------------------------------------------------------------------===//
167: =#
168: 
169: """
170: 	duckdb_query(connection,query,out_result)
171: Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.
172: If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
173: `duckdb_result_error`.
174: Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the
175: query fails, otherwise the error stored within the result will not be freed correctly.
176: * `connection`: The connection to perform the query in.
177: * `query`: The SQL query to run.
178: * `out_result`: The query result.
179: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
180: """
181: function duckdb_query(connection, query, out_result)
182:     return ccall(
183:         (:duckdb_query, libduckdb),
184:         duckdb_state,
185:         (duckdb_connection, Ptr{UInt8}, Ref{duckdb_result}),
186:         connection,
187:         query,
188:         out_result
189:     )
190: end
191: 
192: """
193: 	duckdb_destroy_result(result)
194: Closes the result and de-allocates all memory allocated for that connection.
195: * `result`: The result to destroy.
196: """
197: function duckdb_destroy_result(result)
198:     return ccall((:duckdb_destroy_result, libduckdb), Cvoid, (Ref{duckdb_result},), result)
199: end
200: 
201: """
202: 	duckdb_column_name(result,col)
203: Returns the column name of the specified column. The result should not need be freed; the column names will
204: automatically be destroyed when the result is destroyed.
205: Returns `NULL` if the column is out of range.
206: * `result`: The result object to fetch the column name from.
207: * `col`: The column index.
208: * returns: The column name of the specified column.
209: """
210: function duckdb_column_name(result, col)
211:     return ccall((:duckdb_column_name, libduckdb), Ptr{UInt8}, (Ref{duckdb_result}, Int32), result, col - 1)
212: end
213: 
214: """
215: 	duckdb_column_type(result,col)
216: Returns the column type of the specified column.
217: Returns `DUCKDB_TYPE_INVALID` if the column is out of range.
218: * `result`: The result object to fetch the column type from.
219: * `col`: The column index.
220: * returns: The column type of the specified column.
221: """
222: function duckdb_column_type(result, col)
223:     return ccall((:duckdb_column_type, libduckdb), DUCKDB_TYPE, (Ref{duckdb_result}, Int32), result, col - 1)
224: end
225: 
226: """
227: Returns the logical column type of the specified column.
228: 
229: The return type of this call should be destroyed with `duckdb_destroy_logical_type`.
230: 
231: Returns `NULL` if the column is out of range.
232: 
233: * result: The result object to fetch the column type from.
234: * col: The column index.
235: * returns: The logical column type of the specified column.
236: """
237: function duckdb_column_logical_type(result, col)
238:     return ccall(
239:         (:duckdb_column_logical_type, libduckdb),
240:         duckdb_logical_type,
241:         (Ref{duckdb_result}, Int32),
242:         result,
243:         col - 1
244:     )
245: end
246: 
247: """
248: 	duckdb_column_count(result)
249: Returns the number of columns present in a the result object.
250: * `result`: The result object.
251: * returns: The number of columns present in the result object.
252: """
253: function duckdb_column_count(result)
254:     return ccall((:duckdb_column_count, libduckdb), Int32, (Ref{duckdb_result},), result)
255: end
256: 
257: """
258: 	duckdb_row_count(result)
259: Returns the number of rows present in a the result object.
260: * `result`: The result object.
261: * returns: The number of rows present in the result object.
262: """
263: function duckdb_row_count(result)
264:     return ccall((:duckdb_row_count, libduckdb), Int64, (Ref{duckdb_result},), result)
265: end
266: 
267: """
268: 	duckdb_rows_changed(result)
269: Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE
270: queries. For other queries the rows_changed will be 0.
271: * `result`: The result object.
272: * returns: The number of rows changed.
273: """
274: function duckdb_rows_changed(result)
275:     return ccall((:duckdb_rows_changed, libduckdb), Int64, (Ptr{Cvoid},), result)
276: end
277: 
278: """
279: 	duckdb_column_data(result,col)
280: Returns the data of a specific column of a result in columnar format. This is the fastest way of accessing data in a
281: query result, as no conversion or type checking must be performed (outside of the original switch). If performance
282: is a concern, it is recommended to use this API over the `duckdb_value` functions.
283: The function returns a dense array which contains the result data. The exact type stored in the array depends on the
284: corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
285: accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.
286: For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:
287: ```c
288: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
289: printf("Data for row %d: %d\\n", row, data[row]);
290: ```
291: * `result`: The result object to fetch the column data from.
292: * `col`: The column index.
293: * returns: The column data of the specified column.
294: """
295: function duckdb_column_data(result, col)
296:     return ccall((:duckdb_column_data, libduckdb), Ptr{Cvoid}, (Ref{duckdb_result}, Int32), result, col - 1)
297: end
298: 
299: """
300: 	duckdb_nullmask_data(result,col)
301: Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
302: whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
303: by `duckdb_column_data` are undefined.
304: ```c
305: int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
306: bool *nullmask = duckdb_nullmask_data(&result, 0);
307: if (nullmask[row]) {
308:     printf("Data for row %d: NULL\n", row);
309: } else {
310:     printf("Data for row %d: %d\n", row, data[row]);
311: }
312: ```
313: * `result`: The result object to fetch the nullmask from.
314: * `col`: The column index.
315: * returns: The nullmask of the specified column.
316: """
317: function duckdb_nullmask_data(result, col)
318:     return ccall((:duckdb_nullmask_data, libduckdb), Ptr{Int32}, (Ref{duckdb_result}, Int32), result, col - 1)
319: end
320: 
321: """
322: 	duckdb_result_error(result)
323: Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.
324: The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.
325: * `result`: The result object to fetch the nullmask from.
326: * returns: The error of the result.
327: """
328: function duckdb_result_error(result)
329:     return ccall((:duckdb_result_error, libduckdb), Ptr{UInt8}, (Ref{duckdb_result},), result)
330: end
331: 
332: #=
333: //===--------------------------------------------------------------------===//
334: // Result Functions
335: //===--------------------------------------------------------------------===//
336: =#
337: 
338: """
339: Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.
340: 
341: This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data` functions.
342: It results in significantly better performance, and should be preferred in newer code-bases.
343: 
344: If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be mixed with the legacy result functions).
345: 
346: Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.
347: 
348: * result: The result object to fetch the data chunk from.
349: * chunk_index: The chunk index to fetch from.
350: * returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
351: """
352: function duckdb_result_get_chunk(result, chunk_index)
353:     return ccall(
354:         (:duckdb_result_get_chunk, libduckdb),
355:         duckdb_data_chunk,
356:         (duckdb_result, UInt64),
357:         result,
358:         chunk_index - 1
359:     )
360: end
361: 
362: """
363:  Checks if the type of the internal result is StreamQueryResult.
364: 
365:  * result: The result object to check.
366:  * returns: Whether or not the result object is of the type StreamQueryResult
367: """
368: function duckdb_result_is_streaming(result)
369:     return ccall((:duckdb_result_is_streaming, libduckdb), Bool, (duckdb_result,), result)
370: end
371: 
372: """
373:  Fetches a data chunk from the (streaming) duckdb_result. This function should be called repeatedly until the result is
374:  exhausted.
375: 
376:  The result must be destroyed with `duckdb_destroy_data_chunk`.
377: 
378:  This function can only be used on duckdb_results created with 'duckdb_pending_prepared_streaming'
379: 
380:  If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be
381:  mixed with the legacy result functions or the materialized result functions).
382: 
383:  It is not known beforehand how many chunks will be returned by this result.
384: 
385:  * result: The result object to fetch the data chunk from.
386:  * returns: The resulting data chunk. Returns `NULL` if the result has an error.
387: """
388: function duckdb_stream_fetch_chunk(result)
389:     return ccall((:duckdb_stream_fetch_chunk, libduckdb), duckdb_data_chunk, (duckdb_result,), result)
390: end
391: 
392: 
393: 
394: 
395: """
396: Returns the number of data chunks present in the result.
397: 
398: * result: The result object
399: * returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
400: """
401: function duckdb_result_chunk_count(result)
402:     return ccall((:duckdb_result_chunk_count, libduckdb), UInt64, (duckdb_result,), result)
403: end
404: 
405: 
406: """
407: 	duckdb_value_boolean(result,col,row)
408: * returns: The boolean value at the specified location, or false if the value cannot be converted.
409: """
410: function duckdb_value_boolean(result, col, row)
411:     return ccall(
412:         (:duckdb_value_boolean, libduckdb),
413:         Int32,
414:         (Ref{duckdb_result}, Int32, Int32),
415:         result,
416:         col - 1,
417:         row - 1
418:     )
419: end
420: 
421: """
422: 	duckdb_value_int8(result,col,row)
423: * returns: The int8_t value at the specified location, or 0 if the value cannot be converted.
424: """
425: function duckdb_value_int8(result, col, row)
426:     return ccall((:duckdb_value_int8, libduckdb), Int8, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
427: end
428: 
429: """
430: 	duckdb_value_int16(result,col,row)
431:  * returns: The int16_t value at the specified location, or 0 if the value cannot be converted.
432: """
433: function duckdb_value_int16(result, col, row)
434:     return ccall((:duckdb_value_int16, libduckdb), Int16, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
435: end
436: 
437: """
438: 	duckdb_value_int32(result,col,row)
439:  * returns: The int32_t value at the specified location, or 0 if the value cannot be converted.
440: """
441: function duckdb_value_int32(result, col, row)
442:     return ccall((:duckdb_value_int32, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
443: end
444: 
445: """
446: 	duckdb_value_int64(result,col,row)
447:  * returns: The int64_t value at the specified location, or 0 if the value cannot be converted.
448: """
449: function duckdb_value_int64(result, col, row)
450:     return ccall((:duckdb_value_int64, libduckdb), Int64, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
451: end
452: 
453: """
454: 	duckdb_value_hugeint(result,col,row)
455:  * returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.
456: """
457: function duckdb_value_hugeint(result, col, row)
458:     return ccall(
459:         (:duckdb_value_hugeint, libduckdb),
460:         Int64,
461:         (Ref{duckdb_result}, Int32, Int32),
462:         result,
463:         col - 1,
464:         row - 1
465:     )
466: end
467: 
468: """
469: 	duckdb_value_uhugeint(result,col,row)
470:  * returns: The duckdb_uhugeint value at the specified location, or 0 if the value cannot be converted.
471: """
472: function duckdb_value_uhugeint(result, col, row)
473:     return ccall(
474:         (:duckdb_value_uhugeint, libduckdb),
475:         UInt64,
476:         (Ref{duckdb_result}, Int32, Int32),
477:         result,
478:         col - 1,
479:         row - 1
480:     )
481: end
482: 
483: """
484: 	duckdb_value_uint8(result,col,row)
485:  * returns: The uint8_t value at the specified location, or 0 if the value cannot be converted.
486: 
487: """
488: function duckdb_value_uint8(result, col, row)
489:     return ccall((:duckdb_value_uint8, libduckdb), UInt8, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
490: end
491: 
492: """
493: 	duckdb_value_uint16(result,col,row)
494:  * returns: The uint16_t value at the specified location, or 0 if the value cannot be converted.
495: """
496: function duckdb_value_uint16(result, col, row)
497:     return ccall(
498:         (:duckdb_value_uint16, libduckdb),
499:         UInt16,
500:         (Ref{duckdb_result}, Int32, Int32),
501:         result,
502:         col - 1,
503:         row - 1
504:     )
505: end
506: 
507: """
508: 	duckdb_value_uint32(result,col,row)
509:  * returns: The uint32_t value at the specified location, or 0 if the value cannot be converted.
510: """
511: function duckdb_value_uint32(result, col, row)
512:     return ccall(
513:         (:duckdb_value_uint32, libduckdb),
514:         UInt32,
515:         (Ref{duckdb_result}, Int32, Int32),
516:         result,
517:         col - 1,
518:         row - 1
519:     )
520: end
521: 
522: """
523: 	duckdb_value_uint64(result,col,row)
524: * returns: The uint64_t value at the specified location, or 0 if the value cannot be converted.
525: """
526: function duckdb_value_uint64(result, col, row)
527:     return ccall(
528:         (:duckdb_value_uint64, libduckdb),
529:         UInt64,
530:         (Ref{duckdb_result}, Int32, Int32),
531:         result,
532:         col - 1,
533:         row - 1
534:     )
535: end
536: 
537: """
538: 	duckdb_value_float(result,col,row)
539:  * returns: The float value at the specified location, or 0 if the value cannot be converted.
540: """
541: function duckdb_value_float(result, col, row)
542:     return ccall(
543:         (:duckdb_value_float, libduckdb),
544:         Float32,
545:         (Ref{duckdb_result}, Int32, Int32),
546:         result,
547:         col - 1,
548:         row - 1
549:     )
550: end
551: 
552: """
553: 	duckdb_value_double(result,col,row)
554:  * returns: The double value at the specified location, or 0 if the value cannot be converted.
555: """
556: function duckdb_value_double(result, col, row)
557:     return ccall(
558:         (:duckdb_value_double, libduckdb),
559:         Float64,
560:         (Ref{duckdb_result}, Int32, Int32),
561:         result,
562:         col - 1,
563:         row - 1
564:     )
565: end
566: 
567: """
568: duckdb_value_date(result,col,row)
569:  * returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted.
570: DUCKDB_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);
571: """
572: function duckdb_value_date(result, col, row)
573:     return ccall((:duckdb_value_date, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
574: end
575: 
576: """
577: duckdb_value_time(result,col,row)
578:  * returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted.
579: DUCKDB_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);
580: """
581: function duckdb_value_time(result, col, row)
582:     return ccall((:duckdb_value_time, libduckdb), Int32, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
583: end
584: 
585: """
586: duckdb_value_timestamp(result,col,row)
587:  * returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.
588: DUCKDB_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);
589: """
590: function duckdb_value_timestamp(result, col, row)
591:     return ccall(
592:         (:duckdb_value_timestamp, libduckdb),
593:         Int32,
594:         (Ref{duckdb_result}, Int32, Int32),
595:         result,
596:         col - 1,
597:         row - 1
598:     )
599: end
600: 
601: """
602: duckdb_value_interval(result,col,row)
603:  * returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted.
604: DUCKDB_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);
605: """
606: function duckdb_value_interval(result, col, row)
607:     return ccall(
608:         (:duckdb_value_interval, libduckdb),
609:         Int32,
610:         (Ref{duckdb_result}, Int32, Int32),
611:         result,
612:         col - 1,
613:         row - 1
614:     )
615: end
616: 
617: """
618: duckdb_value_varchar(result,col,row)
619: * returns: The char* value at the specified location, or nullptr if the value cannot be converted.
620: The result must be freed with `duckdb_free`.
621: DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);
622: """
623: function duckdb_value_varchar(result, col, row)
624:     return ccall(
625:         (:duckdb_value_varchar, libduckdb),
626:         Ptr{UInt8},
627:         (Ref{duckdb_result}, Int32, Int32),
628:         result,
629:         col - 1,
630:         row - 1
631:     )
632: end
633: 
634: """
635: duckdb_value_varchar_internal(result,col,row)
636: * returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
637: If the column is NOT a VARCHAR column this function will return NULL.
638: The result must NOT be freed.
639: DUCKDB_API char *duckdb_value_varchar_internal(duckdb_result *result, idx_t col, idx_t row);
640: """
641: function duckdb_value_varchar_internal(result, col, row)
642:     return ccall(
643:         (:duckdb_value_varchar_internal, libduckdb),
644:         Ptr{UInt8},
645:         (Ref{duckdb_result}, Int32, Int32),
646:         result,
647:         col - 1,
648:         row - 1
649:     )
650: end
651: 
652: # """
653: # duckdb_value_blob(result,col,row)
654: # * returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the
655: # value cannot be converted. The resulting "blob.data" must be freed with `duckdb_free.`
656: # DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);
657: # """
658: # function duckdb_value_blob(result, col, row)
659: #     return ccall(
660: #         (:duckdb_value_blob, libduckdb),
661: #         Ptr{Cvoid},
662: #         (Ptr{Cvoid}, Int32, Int32),
663: #         result,
664: #         col - 1,
665: #         row - 1,
666: #     )
667: # end
668: 
669: """
670: duckdb_value_is_null(result,col,row)
671:  * returns: Returns true if the value at the specified index is NULL, and false otherwise.
672: DUCKDB_API bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row);
673: """
674: function duckdb_value_is_null(result, col, row)
675:     return ccall((:duckdb_value_is_null, libduckdb), Bool, (Ref{duckdb_result}, Int32, Int32), result, col - 1, row - 1)
676: end
677: 
678: #=
679: //===--------------------------------------------------------------------===//
680: // Helpers
681: //===--------------------------------------------------------------------===//
682: =#
683: 
684: 
685: """
686: duckdb_malloc(size)
687: 
688: Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner
689: should be freed using `duckdb_free`.
690: * size: The number of bytes to allocate.
691: * returns: A pointer to the allocated memory region.
692: DUCKDB_API void *duckdb_malloc(size_t size);
693: """
694: function duckdb_malloc(size)
695:     return ccall((:duckdb_malloc, libduckdb), Cvoid, (Csize_t,), size)
696: end
697: 
698: """
699: duckdb_free(ptr)
700: Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_value_blob`.
701: * ptr: The memory region to de-allocate.
702: DUCKDB_API void duckdb_free(void *ptr);
703: """
704: function duckdb_free(ptr)
705:     return ccall((:duckdb_free, libduckdb), Cvoid, (Ptr{Cvoid},), ptr)
706: end
707: 
708: """
709: The internal vector size used by DuckDB.
710: This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.
711: 
712: * returns: The vector size.
713: """
714: function duckdb_vector_size()
715:     return ccall((:duckdb_vector_size, libduckdb), UInt64, ())
716: end
717: 
718: # #=
719: # //===--------------------------------------------------------------------===//
720: # // Date/Time/Timestamp Helpers
721: # //===--------------------------------------------------------------------===//
722: # =#
723: #
724: #
725: # """
726: # duckdb_from_date(date)
727: # Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).
728: # * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
729: # * returns: The `duckdb_date_struct` with the decomposed elements.
730: # DUCKDB_API duckdb_date_struct duckdb_from_date(duckdb_date date);
731: # """
732: # function duckdb_from_date(date)
733: #     return ccall((:duckdb_from_date, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), date)
734: # end
735: #
736: # """
737: # duckdb_to_date(date)
738: # Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).
739: # * date: The year, month and date stored in a `duckdb_date_struct`.
740: # * returns: The `duckdb_date` element.
741: # DUCKDB_API duckdb_date duckdb_to_date(duckdb_date_struct date);
742: # """
743: # function duckdb_to_date(date)
744: #     return ccall((:duckdb_to_date, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), date)
745: # end
746: #
747: # """
748: # duckdb_from_time(time)
749: # Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).
750: # * time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.
751: # * returns: The `duckdb_time_struct` with the decomposed elements.
752: # DUCKDB_API duckdb_time_struct duckdb_from_time(duckdb_time time);
753: # """
754: # function duckdb_from_time(time)
755: #     return ccall((:duckdb_from_time, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), time)
756: # end
757: #
758: # """
759: # duckdb_to_time(time)
760: # Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).
761: # * time: The hour, minute, second and microsecond in a `duckdb_time_struct`.
762: # * returns: The `duckdb_time` element.
763: # DUCKDB_API duckdb_time duckdb_to_time(duckdb_time_struct time);
764: # """
765: # function duckdb_to_time(time)
766: #     return ccall((:duckdb_to_time, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), time)
767: # end
768: #
769: # """
770: # duckdb_from_timestamp(ts)
771: # Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.
772: # * ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
773: # * returns: The `duckdb_timestamp_struct` with the decomposed elements.
774: # DUCKDB_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts);
775: # """
776: # function duckdb_from_timestamp(ts)
777: #     return ccall((:duckdb_from_timestamp, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), ts)
778: # end
779: #
780: 
781: """
782: Decompose a TIME_TZ objects into micros and a timezone offset.
783: 
784: Use `duckdb_from_time` to further decompose the micros into hour, minute, second and microsecond.
785: 
786: * micros: The time object, as obtained from a `DUCKDB_TYPE_TIME_TZ` column.
787: * out_micros: The microsecond component of the time.
788: * out_offset: The timezone offset component of the time.
789: """
790: function duckdb_from_time_tz(val)
791:     return ccall((:duckdb_from_time_tz, libduckdb), duckdb_time_tz, (UInt64,), val)
792: end
793: 
794: #
795: # """
796: # duckdb_to_timestamp(ts)
797: # Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.
798: # * ts: The de-composed elements in a `duckdb_timestamp_struct`.
799: # * returns: The `duckdb_timestamp` element.
800: # */
801: # DUCKDB_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts);
802: # """
803: # function duckdb_to_timestamp(ts)
804: #     return ccall((:duckdb_to_timestamp, libduckdb), Ptr{Cvoid}, (Ptr{Cvoid},), ts)
805: # end
806: #
807: # #=
808: # //===--------------------------------------------------------------------===//
809: # // Hugeint Helpers
810: # //===--------------------------------------------------------------------===//
811: # =#
812: #
813: #
814: # """
815: # duckdb_hugeint_to_double(val)
816: # Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.
817: # * val: The hugeint value.
818: # * returns: The converted `double` element.
819: # DUCKDB_API double duckdb_hugeint_to_double(duckdb_hugeint val);
820: # """
821: # function duckdb_hugeint_to_double(val)
822: #     return ccall((:duckdb_hugeint_to_double, libduckdb), Float64, (Int64,), val)
823: # end
824: #
825: # """
826: # duckdb_double_to_hugeint(val)
827: # Converts a double value to a duckdb_hugeint object.
828: # If the conversion fails because the double value is too big the result will be 0.
829: # * val: The double value.
830: # * returns: The converted `duckdb_hugeint` element.
831: # DUCKDB_API duckdb_hugeint duckdb_double_to_hugeint(double val);
832: # """
833: # function duckdb_double_to_hugeint(val)
834: #     return ccall((:duckdb_double_to_hugeint, libduckdb), Int64, (Float64,), val)
835: # end
836: #
837: # #=
838: # //===--------------------------------------------------------------------===//
839: # // Prepared Statements
840: # //===--------------------------------------------------------------------===//
841: # // A prepared statement is a parameterized query that allows you to bind parameters to it.
842: # // * This is useful to easily supply parameters to functions and avoid SQL injection attacks.
843: # // * This is useful to speed up queries that you will execute several times with different parameters.
844: # // Because the query will only be parsed, bound, optimized and planned once during the prepare stage,
845: # // rather than once per execution.
846: # // For example:
847: # //   SELECT * FROM tbl WHERE id=?
848: # // Or a query with multiple parameters:
849: # //   SELECT * FROM tbl WHERE id=$1 OR name=$2
850: # =#
851: 
852: 
853: """
854: Create a prepared statement object from a query.
855: Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using
856: `duckdb_destroy_prepare`, even if the prepare fails.
857: If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
858: * connection: The connection object
859: * query: The SQL query to prepare
860: * out_prepared_statement: The resulting prepared statement object
861: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
862: DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
863:                                        duckdb_prepared_statement *out_prepared_statement);
864: """
865: function duckdb_prepare(connection, query, out_prepared_statement)
866:     return ccall(
867:         (:duckdb_prepare, libduckdb),
868:         duckdb_state,
869:         (duckdb_connection, Ptr{UInt8}, Ref{duckdb_prepared_statement}),
870:         connection,
871:         query,
872:         out_prepared_statement
873:     )
874: end
875: 
876: """
877: Closes the prepared statement and de-allocates all memory allocated for that connection.
878: * prepared_statement: The prepared statement to destroy.
879: DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);
880: """
881: function duckdb_destroy_prepare(prepared_statement)
882:     return ccall((:duckdb_destroy_prepare, libduckdb), Cvoid, (Ref{duckdb_prepared_statement},), prepared_statement)
883: end
884: 
885: """
886: Returns the error message associated with the given prepared statement.
887: If the prepared statement has no error message, this returns `nullptr` instead.
888: The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.
889: * prepared_statement: The prepared statement to obtain the error from.
890: * returns: The error message, or `nullptr` if there is none.
891: DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);
892: """
893: function duckdb_prepare_error(prepared_statement)
894:     return ccall((:duckdb_prepare_error, libduckdb), Ptr{UInt8}, (duckdb_prepared_statement,), prepared_statement[])
895: end
896: 
897: """
898: Returns the number of parameters that can be provided to the given prepared statement.
899: Returns 0 if the query was not successfully prepared.
900: * prepared_statement: The prepared statement to obtain the number of parameters for.
901: DUCKDB_API idx_t duckdb_nparams(duckdb_prepared_statement prepared_statement);
902: """
903: function duckdb_nparams(prepared_statement)
904:     return ccall((:duckdb_nparams, libduckdb), Int32, (duckdb_prepared_statement,), prepared_statement)
905: end
906: 
907: """
908: Returns the parameter type for the parameter at the given index.
909: Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.
910: * prepared_statement: The prepared statement.
911: * param_idx: The parameter index.
912: * returns: The parameter type
913: DUCKDB_API duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_t param_idx);
914: """
915: function duckdb_param_type(prepared_statement, param_idx)
916:     return ccall(
917:         (:duckdb_param_type, libduckdb),
918:         Int32,
919:         (duckdb_prepared_statement, Int32),
920:         prepared_statement,
921:         param_idx
922:     )
923: end
924: 
925: """
926: Binds a bool value to the prepared statement at the specified index.
927: DUCKDB_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);
928: """
929: function duckdb_bind_boolean(prepared_statement, param_idx, val)
930:     return ccall(
931:         (:duckdb_bind_boolean, libduckdb),
932:         duckdb_state,
933:         (duckdb_prepared_statement, Int32, Int32),
934:         prepared_statement,
935:         param_idx,
936:         val
937:     )
938: end
939: 
940: """
941: Binds an int8_t value to the prepared statement at the specified index.
942: DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);
943: """
944: function duckdb_bind_int8(prepared_statement, param_idx, val)
945:     return ccall(
946:         (:duckdb_bind_int8, libduckdb),
947:         duckdb_state,
948:         (duckdb_prepared_statement, Int32, Int8),
949:         prepared_statement,
950:         param_idx,
951:         val
952:     )
953: end
954: 
955: """
956: Binds an int16_t value to the prepared statement at the specified index.
957: DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);
958: """
959: function duckdb_bind_int16(prepared_statement, param_idx, val)
960:     return ccall(
961:         (:duckdb_bind_int16, libduckdb),
962:         duckdb_state,
963:         (duckdb_prepared_statement, Int32, Int16),
964:         prepared_statement,
965:         param_idx,
966:         val
967:     )
968: end
969: 
970: """
971: Binds an int32_t value to the prepared statement at the specified index.
972: DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);
973: """
974: function duckdb_bind_int32(prepared_statement, param_idx, val)
975:     return ccall(
976:         (:duckdb_bind_int32, libduckdb),
977:         duckdb_state,
978:         (duckdb_prepared_statement, Int32, Int32),
979:         prepared_statement,
980:         param_idx,
981:         val
982:     )
983: end
984: 
985: """
986: Binds an int64_t value to the prepared statement at the specified index.
987: DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);
988: """
989: function duckdb_bind_int64(prepared_statement, param_idx, val)
990:     return ccall(
991:         (:duckdb_bind_int64, libduckdb),
992:         duckdb_state,
993:         (duckdb_prepared_statement, Int32, Int64),
994:         prepared_statement,
995:         param_idx,
996:         val
997:     )
998: end
999: 
1000: """
1001: Binds a duckdb_hugeint value to the prepared statement at the specified index.
1002: */
1003: DUCKDB_API duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1004:                                             duckdb_hugeint val);
1005: """
1006: function duckdb_bind_hugeint(prepared_statement, param_idx, val)
1007:     return ccall(
1008:         (:duckdb_bind_hugeint, libduckdb),
1009:         duckdb_state,
1010:         (duckdb_prepared_statement, Int32, duckdb_hugeint),
1011:         prepared_statement,
1012:         param_idx,
1013:         val
1014:     )
1015: end
1016: 
1017: """
1018: Binds an duckdb_uhugeint value to the prepared statement at the specified index.
1019: */
1020: DUCKDB_API duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1021:                                             duckdb_uhugeint val);
1022: """
1023: function duckdb_bind_uhugeint(prepared_statement, param_idx, val)
1024:     return ccall(
1025:         (:duckdb_bind_uhugeint, libduckdb),
1026:         duckdb_state,
1027:         (duckdb_prepared_statement, Int32, duckdb_uhugeint),
1028:         prepared_statement,
1029:         param_idx,
1030:         val
1031:     )
1032: end
1033: 
1034: """
1035: Binds an uint8_t value to the prepared statement at the specified index.
1036: DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);
1037: """
1038: function duckdb_bind_uint8(prepared_statement, param_idx, val)
1039:     return ccall(
1040:         (:duckdb_bind_uint8, libduckdb),
1041:         duckdb_state,
1042:         (duckdb_prepared_statement, Int32, UInt8),
1043:         prepared_statement,
1044:         param_idx,
1045:         val
1046:     )
1047: end
1048: 
1049: """
1050: Binds an uint16_t value to the prepared statement at the specified index.
1051: DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val);
1052: """
1053: function duckdb_bind_uint16(prepared_statement, param_idx, val)
1054:     return ccall(
1055:         (:duckdb_bind_uint16, libduckdb),
1056:         duckdb_state,
1057:         (duckdb_prepared_statement, Int32, UInt16),
1058:         prepared_statement,
1059:         param_idx,
1060:         val
1061:     )
1062: end
1063: 
1064: """
1065: Binds an uint32_t value to the prepared statement at the specified index.
1066: DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);
1067: """
1068: function duckdb_bind_uint32(prepared_statement, param_idx, val)
1069:     return ccall(
1070:         (:duckdb_bind_uint32, libduckdb),
1071:         duckdb_state,
1072:         (duckdb_prepared_statement, Int32, UInt32),
1073:         prepared_statement,
1074:         param_idx,
1075:         val
1076:     )
1077: end
1078: 
1079: """
1080: Binds an uint64_t value to the prepared statement at the specified index.
1081: DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);
1082: """
1083: function duckdb_bind_uint64(prepared_statement, param_idx, val)
1084:     return ccall(
1085:         (:duckdb_bind_uint64, libduckdb),
1086:         duckdb_state,
1087:         (duckdb_prepared_statement, Int32, UInt64),
1088:         prepared_statement,
1089:         param_idx,
1090:         val
1091:     )
1092: end
1093: 
1094: """
1095: Binds a float value to the prepared statement at the specified index.
1096: DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);
1097: """
1098: function duckdb_bind_float(prepared_statement, param_idx, val)
1099:     return ccall(
1100:         (:duckdb_bind_float, libduckdb),
1101:         duckdb_state,
1102:         (duckdb_prepared_statement, Int32, Float32),
1103:         prepared_statement,
1104:         param_idx,
1105:         val
1106:     )
1107: end
1108: 
1109: """
1110: Binds a double value to the prepared statement at the specified index.
1111: DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);
1112: """
1113: function duckdb_bind_double(prepared_statement, param_idx, val)
1114:     return ccall(
1115:         (:duckdb_bind_double, libduckdb),
1116:         duckdb_state,
1117:         (duckdb_prepared_statement, Int32, Float64),
1118:         prepared_statement,
1119:         param_idx,
1120:         val
1121:     )
1122: end
1123: 
1124: """
1125: Binds a duckdb_date value to the prepared statement at the specified index.
1126: DUCKDB_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1127:                                          duckdb_date val);
1128: """
1129: function duckdb_bind_date(prepared_statement, param_idx, val)
1130:     return ccall(
1131:         (:duckdb_bind_date, libduckdb),
1132:         duckdb_state,
1133:         (duckdb_prepared_statement, Int32, Int32),
1134:         prepared_statement,
1135:         param_idx,
1136:         val
1137:     )
1138: end
1139: 
1140: """
1141: Binds a duckdb_time value to the prepared statement at the specified index.
1142: DUCKDB_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1143:                                          duckdb_time val);
1144: """
1145: function duckdb_bind_time(prepared_statement, param_idx, val)
1146:     return ccall(
1147:         (:duckdb_bind_time, libduckdb),
1148:         duckdb_state,
1149:         (duckdb_prepared_statement, Int32, Int64),
1150:         prepared_statement,
1151:         param_idx,
1152:         val
1153:     )
1154: end
1155: 
1156: """
1157: Binds a duckdb_timestamp value to the prepared statement at the specified index.
1158: DUCKDB_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1159:                                               duckdb_timestamp val);
1160: """
1161: function duckdb_bind_timestamp(prepared_statement, param_idx, val)
1162:     return ccall(
1163:         (:duckdb_bind_timestamp, libduckdb),
1164:         duckdb_state,
1165:         (duckdb_prepared_statement, Int32, Int64),
1166:         prepared_statement,
1167:         param_idx,
1168:         val
1169:     )
1170: end
1171: 
1172: """
1173: Binds a duckdb_interval value to the prepared statement at the specified index.
1174: DUCKDB_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1175:                                              duckdb_interval val);
1176: """
1177: function duckdb_bind_interval(prepared_statement, param_idx, val)
1178:     return ccall(
1179:         (:duckdb_bind_interval, libduckdb),
1180:         duckdb_state,
1181:         (duckdb_prepared_statement, Int32, Int32),
1182:         prepared_statement,
1183:         param_idx,
1184:         val
1185:     )
1186: end
1187: 
1188: """
1189: Binds a null-terminated varchar value to the prepared statement at the specified index.
1190: DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1191:                                             const char *val);
1192: """
1193: function duckdb_bind_varchar(prepared_statement, param_idx, val)
1194:     return ccall(
1195:         (:duckdb_bind_varchar, libduckdb),
1196:         duckdb_state,
1197:         (duckdb_prepared_statement, Int32, Ptr{UInt8}),
1198:         prepared_statement,
1199:         param_idx,
1200:         val
1201:     )
1202: end
1203: 
1204: """
1205: Binds a varchar value to the prepared statement at the specified index.
1206: DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1207:                                                    const char *val, idx_t length);
1208: """
1209: function duckdb_bind_varchar_length(prepared_statement, param_idx, val, length)
1210:     return ccall(
1211:         (:duckdb_bind_varchar_length, libduckdb),
1212:         duckdb_state,
1213:         (duckdb_prepared_statement, Int32, Ptr{UInt8}, Int32),
1214:         prepared_statement,
1215:         param_idx,
1216:         val,
1217:         length
1218:     )
1219: end
1220: 
1221: """
1222: Binds a blob value to the prepared statement at the specified index.
1223: DUCKDB_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,
1224:                                          const void *data, idx_t length);
1225: """
1226: function duckdb_bind_blob(prepared_statement, param_idx, val, length)
1227:     return ccall(
1228:         (:duckdb_bind_blob, libduckdb),
1229:         duckdb_state,
1230:         (duckdb_prepared_statement, Int32, Ptr{Cvoid}, Int32),
1231:         prepared_statement,
1232:         param_idx,
1233:         val,
1234:         length
1235:     )
1236: end
1237: 
1238: """
1239: Binds a NULL value to the prepared statement at the specified index.
1240: DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);
1241: """
1242: function duckdb_bind_null(prepared_statement, param_idx)
1243:     return ccall(
1244:         (:duckdb_bind_null, libduckdb),
1245:         duckdb_state,
1246:         (duckdb_prepared_statement, Int32),
1247:         prepared_statement,
1248:         param_idx
1249:     )
1250: end
1251: 
1252: """
1253: Executes the prepared statement with the given bound parameters, and returns a materialized query result.
1254: This method can be called multiple times for each prepared statement, and the parameters can be modified
1255: between calls to this function.
1256: * prepared_statement: The prepared statement to execute.
1257: * out_result: The query result.
1258: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1259: DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,
1260:                                                 duckdb_result *out_result);
1261: """
1262: function duckdb_execute_prepared(prepared_statement, out_result)
1263:     return ccall(
1264:         (:duckdb_execute_prepared, libduckdb),
1265:         duckdb_state,
1266:         (duckdb_prepared_statement, Ref{duckdb_result}),
1267:         prepared_statement,
1268:         out_result
1269:     )
1270: end
1271: 
1272: # """
1273: # Executes the prepared statement with the given bound parameters, and returns an arrow query result.
1274: # * prepared_statement: The prepared statement to execute.
1275: # * out_result: The query result.
1276: # * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1277: # DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,
1278: #                                                       duckdb_arrow *out_result);
1279: # """
1280: # function duckdb_execute_prepared_arrow(prepared_statement, out_result)
1281: #     return ccall(
1282: #         (:duckdb_execute_prepared_arrow, libduckdb),
1283: #         duckdb_state,
1284: #         (Ptr{Cvoid}, Ptr{Cvoid}),
1285: #         prepared_statement,
1286: #         out_result,
1287: #     )
1288: # end
1289: 
1290: #=
1291: //===--------------------------------------------------------------------===//
1292: // Pending Result Interface
1293: //===--------------------------------------------------------------------===//
1294: =#
1295: """
1296: Executes the prepared statement with the given bound parameters, and returns a pending result.
1297: The pending result represents an intermediate structure for a query that is not yet fully executed.
1298: The pending result can be used to incrementally execute a query, returning control to the client between tasks.
1299: 
1300: Note that after calling `duckdb_pending_prepared`, the pending result should always be destroyed using
1301: `duckdb_destroy_pending`, even if this function returns DuckDBError.
1302: 
1303: * prepared_statement: The prepared statement to execute.
1304: * out_result: The pending query result.
1305: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1306: """
1307: function duckdb_pending_prepared(prepared_statement, out_pending)
1308:     return ccall(
1309:         (:duckdb_pending_prepared, libduckdb),
1310:         duckdb_state,
1311:         (duckdb_prepared_statement, Ref{duckdb_pending_result}),
1312:         prepared_statement,
1313:         out_pending
1314:     )
1315: end
1316: 
1317: """
1318: Executes the prepared statement with the given bound parameters, and returns a pending result.
1319: This pending result will create a streaming duckdb_result when executed.
1320: The pending result represents an intermediate structure for a query that is not yet fully executed.
1321: 
1322: Note that after calling `duckdb_pending_prepared_streaming`, the pending result should always be destroyed using
1323: `duckdb_destroy_pending`, even if this function returns DuckDBError.
1324: 
1325: * prepared_statement: The prepared statement to execute.
1326: * out_result: The pending query result.
1327: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1328: """
1329: function duckdb_pending_prepared_streaming(prepared_statement, out_pending)
1330:     return ccall(
1331:         (:duckdb_pending_prepared_streaming, libduckdb),
1332:         duckdb_state,
1333:         (duckdb_prepared_statement, Ref{duckdb_pending_result}),
1334:         prepared_statement,
1335:         out_pending
1336:     )
1337: end
1338: 
1339: """
1340: Checks the state of the execution, returning it.
1341: The pending result represents an intermediate structure for a query that is not yet fully executed.
1342: 
1343: If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.
1344: If this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_check_state function should be called again.
1345: If this returns DUCKDB_PENDING_ERROR, an error occurred during execution.
1346: 
1347: The error message can be obtained by calling duckdb_pending_error on the pending_result.
1348: 
1349: * pending_result: The pending result to check the state of.
1350: * returns: The state of the pending result.
1351: """
1352: function duckdb_pending_execute_check_state(pending_result)
1353:     return ccall(
1354:         (:duckdb_pending_execute_check_state, libduckdb),
1355:         duckdb_pending_state,
1356:         (duckdb_pending_result,),
1357:         pending_result
1358:     )
1359: end
1360: 
1361: """
1362: Closes the pending result and de-allocates all memory allocated for the result.
1363: 
1364: * pending_result: The pending result to destroy.
1365: """
1366: function duckdb_destroy_pending(pending_result)
1367:     return ccall((:duckdb_destroy_pending, libduckdb), Cvoid, (Ref{duckdb_pending_result},), pending_result)
1368: end
1369: 
1370: """
1371: Returns the error message contained within the pending result.
1372: 
1373: The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_pending` is called.
1374: 
1375: * result: The pending result to fetch the error from.
1376: * returns: The error of the pending result.
1377: """
1378: function duckdb_pending_error(pending_result)
1379:     return ccall((:duckdb_pending_error, libduckdb), Ptr{UInt8}, (duckdb_pending_result,), pending_result)
1380: end
1381: 
1382: """
1383: Executes a single task within the query, returning whether or not the query is ready.
1384: 
1385: If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.
1386: If this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_task function should be called again.
1387: If this returns DUCKDB_PENDING_ERROR, an error occurred during execution.
1388: 
1389: The error message can be obtained by calling duckdb_pending_error on the pending_result.
1390: 
1391: * pending_result: The pending result to execute a task within.
1392: * returns: The state of the pending result after the execution.
1393: """
1394: function duckdb_pending_execute_task(pending_result)
1395:     return ccall(
1396:         (:duckdb_pending_execute_task, libduckdb),
1397:         duckdb_pending_state,
1398:         (duckdb_pending_result,),
1399:         pending_result
1400:     )
1401: end
1402: 
1403: """
1404: Fully execute a pending query result, returning the final query result.
1405: 
1406: If duckdb_pending_execute_task has been called until DUCKDB_PENDING_RESULT_READY was returned, this will return fast.
1407: Otherwise, all remaining tasks must be executed first.
1408: 
1409: * pending_result: The pending result to execute.
1410: * out_result: The result object.
1411: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
1412: """
1413: function duckdb_execute_pending(pending_result, out_result)
1414:     return ccall(
1415:         (:duckdb_execute_pending, libduckdb),
1416:         duckdb_state,
1417:         (duckdb_pending_result, Ref{duckdb_result}),
1418:         pending_result,
1419:         out_result
1420:     )
1421: end
1422: 
1423: """
1424: Returns whether a duckdb_pending_state is finished executing. For example if `pending_state` is
1425: DUCKDB_PENDING_RESULT_READY, this function will return true.
1426: 
1427: * pending_state: The pending state on which to decide whether to finish execution.
1428: * returns: Boolean indicating pending execution should be considered finished.
1429: """
1430: function duckdb_pending_execution_is_finished(pending_state)
1431:     return ccall((:duckdb_pending_execution_is_finished, libduckdb), Bool, (duckdb_pending_state,), pending_state)
1432: end
1433: 
1434: #=
1435: //===--------------------------------------------------------------------===//
1436: // Value Interface
1437: //===--------------------------------------------------------------------===//
1438: =#
1439: """
1440: Destroys the value and de-allocates all memory allocated for that type.
1441: 
1442: * value: The value to destroy.
1443: """
1444: function duckdb_destroy_value(handle)
1445:     return ccall((:duckdb_destroy_value, libduckdb), Cvoid, (Ref{duckdb_value},), handle)
1446: end
1447: 
1448: """
1449: Creates a value from a null-terminated string
1450: 
1451: * value: The null-terminated string
1452: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
1453: """
1454: function duckdb_create_varchar(handle)
1455:     return ccall((:duckdb_create_varchar, libduckdb), duckdb_value, (Ptr{UInt8},), handle)
1456: end
1457: 
1458: """
1459: Creates a value from a string
1460: 
1461: * value: The text
1462: * length: The length of the text
1463: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
1464: """
1465: function duckdb_create_varchar_length(text, len)
1466:     return ccall((:duckdb_create_varchar_length, libduckdb), duckdb_value, (Ptr{UInt8}, UInt64), text, len)
1467: end
1468: 
1469: 
1470: """
1471: Creates a value from an int64
1472: 
1473: * value: The bigint value
1474: * returns: The value. This must be destroyed with `duckdb_destroy_value`.
1475: """
1476: function duckdb_create_int64(handle)
1477:     return ccall((:duckdb_create_int64, libduckdb), duckdb_value, (Int64,), handle)
1478: end
1479: 
1480: """
1481: Obtains a string representation of the given value.
1482: The result must be destroyed with `duckdb_free`.
1483: 
1484: * value: The value
1485: * returns: The string value. This must be destroyed with `duckdb_free`.
1486: """
1487: function duckdb_get_varchar(handle)
1488:     return ccall((:duckdb_get_varchar, libduckdb), Ptr{UInt8}, (duckdb_value,), handle)
1489: end
1490: 
1491: """
1492: Obtains an int64 of the given value.
1493: 
1494: * value: The value
1495: * returns: The int64 value, or 0 if no conversion is possible
1496: """
1497: function duckdb_get_int64(handle)
1498:     return ccall((:duckdb_get_int64, libduckdb), Int64, (duckdb_value,), handle)
1499: end
1500: 
1501: #=
1502: //===--------------------------------------------------------------------===//
1503: // Logical Type Interface
1504: //===--------------------------------------------------------------------===//
1505: =#
1506: """
1507: Creates a `duckdb_logical_type` from a standard primitive type.
1508: The resulting type should be destroyed with `duckdb_destroy_logical_type`.
1509: 
1510: This should not be used with `DUCKDB_TYPE_DECIMAL`.
1511: 
1512: * type: The primitive type to create.
1513: * returns: The logical type type.
1514: """
1515: function duckdb_create_logical_type(type)
1516:     return ccall((:duckdb_create_logical_type, libduckdb), duckdb_logical_type, (Int32,), type)
1517: end
1518: 
1519: """
1520: Creates a `duckdb_logical_type` of type decimal with the specified width and scale
1521: The resulting type should be destroyed with `duckdb_destroy_logical_type`.
1522: 
1523: * width: The width of the decimal type
1524: * scale: The scale of the decimal type
1525: * returns: The logical type.
1526: """
1527: function duckdb_create_decimal_type(width, scale)
1528:     return ccall((:duckdb_create_decimal_type, libduckdb), duckdb_logical_type, (UInt8, UInt8), width, scale)
1529: end
1530: 
1531: 
1532: """
1533: Retrieves the type class of a `duckdb_logical_type`.
1534: 
1535: * type: The logical type object
1536: * returns: The type id
1537: """
1538: function duckdb_get_type_id(handle)
1539:     return ccall((:duckdb_get_type_id, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)
1540: end
1541: 
1542: """
1543: Retrieves the width of a decimal type.
1544: 
1545: * type: The logical type object
1546: * returns: The width of the decimal type
1547: """
1548: function duckdb_decimal_width(handle)
1549:     return ccall((:duckdb_decimal_width, libduckdb), UInt8, (duckdb_logical_type,), handle)
1550: end
1551: 
1552: """
1553: Retrieves the scale of a decimal type.
1554: 
1555: * type: The logical type object
1556: * returns: The scale of the decimal type
1557: """
1558: function duckdb_decimal_scale(handle)
1559:     return ccall((:duckdb_decimal_scale, libduckdb), UInt8, (duckdb_logical_type,), handle)
1560: end
1561: 
1562: """
1563: Retrieves the internal storage type of a decimal type.
1564: 
1565: * type: The logical type object
1566: * returns: The internal type of the decimal type
1567: """
1568: function duckdb_decimal_internal_type(handle)
1569:     return ccall((:duckdb_decimal_internal_type, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)
1570: end
1571: 
1572: """
1573: Retrieves the internal storage type of an enum type.
1574: 
1575: * type: The logical type object
1576: * returns: The internal type of the enum type
1577: """
1578: function duckdb_enum_internal_type(handle)
1579:     return ccall((:duckdb_enum_internal_type, libduckdb), DUCKDB_TYPE, (duckdb_logical_type,), handle)
1580: end
1581: 
1582: """
1583: Retrieves the dictionary size of the enum type
1584: 
1585: * type: The logical type object
1586: * returns: The dictionary size of the enum type
1587: """
1588: function duckdb_enum_dictionary_size(handle)
1589:     return ccall((:duckdb_enum_dictionary_size, libduckdb), UInt32, (duckdb_logical_type,), handle)
1590: end
1591: 
1592: """
1593: Retrieves the dictionary value at the specified position from the enum.
1594: 
1595: The result must be freed with `duckdb_free`
1596: 
1597: * type: The logical type object
1598: * index: The index in the dictionary
1599: * returns: The string value of the enum type. Must be freed with `duckdb_free`.
1600: """
1601: function duckdb_enum_dictionary_value(handle, index)
1602:     return ccall(
1603:         (:duckdb_enum_dictionary_value, libduckdb),
1604:         Ptr{UInt8},
1605:         (duckdb_logical_type, UInt64),
1606:         handle,
1607:         index - 1
1608:     )
1609: end
1610: 
1611: """
1612: Retrieves the child type of the given list type.
1613: 
1614: The result must be freed with `duckdb_destroy_logical_type`
1615: 
1616: * type: The logical type object
1617: * returns: The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`.
1618: """
1619: function duckdb_list_type_child_type(handle)
1620:     return ccall((:duckdb_list_type_child_type, libduckdb), duckdb_logical_type, (duckdb_logical_type,), handle)
1621: end
1622: 
1623: """
1624: Returns the number of children of a struct type.
1625: 
1626: * type: The logical type object
1627: * returns: The number of children of a struct type.
1628: """
1629: function duckdb_struct_type_child_count(handle)
1630:     return ccall((:duckdb_struct_type_child_count, libduckdb), UInt64, (duckdb_logical_type,), handle)
1631: end
1632: 
1633: """
1634: Returns the number of members of a union type.
1635: 
1636: * type: The logical type object
1637: * returns: The number of members of a union type.
1638: """
1639: function duckdb_union_type_member_count(handle)
1640:     return ccall((:duckdb_union_type_member_count, libduckdb), UInt64, (duckdb_logical_type,), handle)
1641: end
1642: 
1643: """
1644: Retrieves the name of the struct child.
1645: 
1646: The result must be freed with `duckdb_free`
1647: 
1648: * type: The logical type object
1649: * index: The child index
1650: * returns: The name of the struct type. Must be freed with `duckdb_free`.
1651: """
1652: function duckdb_struct_type_child_name(handle, index)
1653:     return ccall(
1654:         (:duckdb_struct_type_child_name, libduckdb),
1655:         Ptr{UInt8},
1656:         (duckdb_logical_type, UInt64),
1657:         handle,
1658:         index - 1
1659:     )
1660: end
1661: 
1662: """
1663: Retrieves the name of the union member.
1664: 
1665: The result must be freed with `duckdb_free`
1666: 
1667: * type: The logical type object
1668: * index: The member index
1669: * returns: The name of the union member. Must be freed with `duckdb_free`.
1670: """
1671: function duckdb_union_type_member_name(handle, index)
1672:     return ccall(
1673:         (:duckdb_union_type_member_name, libduckdb),
1674:         Ptr{UInt8},
1675:         (duckdb_logical_type, UInt64),
1676:         handle,
1677:         index - 1
1678:     )
1679: end
1680: 
1681: """
1682: Retrieves the child type of the given struct type at the specified index.
1683: 
1684: The result must be freed with `duckdb_destroy_logical_type`
1685: 
1686: * type: The logical type object
1687: * index: The child index
1688: * returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.
1689: """
1690: function duckdb_struct_type_child_type(handle, index)
1691:     return ccall(
1692:         (:duckdb_struct_type_child_type, libduckdb),
1693:         duckdb_logical_type,
1694:         (duckdb_logical_type, UInt64),
1695:         handle,
1696:         index - 1
1697:     )
1698: end
1699: 
1700: """
1701: Retrieves the member type of the given union type at the specified index.
1702: 
1703: The result must be freed with `duckdb_destroy_logical_type`
1704: 
1705: * type: The logical type object
1706: * index: The member index
1707: * returns: The member type of the union type. Must be destroyed with `duckdb_destroy_logical_type`.
1708: """
1709: function duckdb_union_type_member_type(handle, index)
1710:     return ccall(
1711:         (:duckdb_union_type_member_type, libduckdb),
1712:         duckdb_logical_type,
1713:         (duckdb_logical_type, UInt64),
1714:         handle,
1715:         index - 1
1716:     )
1717: end
1718: 
1719: """
1720: Destroys the logical type and de-allocates all memory allocated for that type.
1721: 
1722: * type: The logical type to destroy.
1723: """
1724: function duckdb_destroy_logical_type(handle)
1725:     return ccall((:duckdb_destroy_logical_type, libduckdb), Cvoid, (Ref{duckdb_logical_type},), handle)
1726: end
1727: 
1728: #=
1729: //===--------------------------------------------------------------------===//
1730: // Data Chunk Interface
1731: //===--------------------------------------------------------------------===//
1732: =#
1733: """
1734: Creates an empty DataChunk with the specified set of types.
1735: 
1736: * types: An array of types of the data chunk.
1737: * column_count: The number of columns.
1738: * returns: The data chunk.
1739: """
1740: function duckdb_create_data_chunk(types, column_count)
1741:     return ccall(
1742:         (:duckdb_create_data_chunk, libduckdb),
1743:         duckdb_data_chunk,
1744:         (Ptr{duckdb_logical_type}, UInt64),
1745:         types,
1746:         column_count
1747:     )
1748: end
1749: 
1750: """
1751: Destroys the data chunk and de-allocates all memory allocated for that chunk.
1752: 
1753: * chunk: The data chunk to destroy.
1754: """
1755: function duckdb_destroy_data_chunk(chunk)
1756:     return ccall((:duckdb_destroy_data_chunk, libduckdb), Cvoid, (Ref{duckdb_data_chunk},), chunk)
1757: end
1758: 
1759: """
1760: Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.
1761: 
1762: * chunk: The data chunk to reset.
1763: """
1764: function duckdb_data_chunk_reset(chunk)
1765:     return ccall((:duckdb_data_chunk_reset, libduckdb), Cvoid, (duckdb_data_chunk,), chunk)
1766: end
1767: 
1768: """
1769: Retrieves the number of columns in a data chunk.
1770: 
1771: * chunk: The data chunk to get the data from
1772: * returns: The number of columns in the data chunk
1773: """
1774: function duckdb_data_chunk_get_column_count(chunk)
1775:     return ccall((:duckdb_data_chunk_get_column_count, libduckdb), UInt64, (duckdb_data_chunk,), chunk)
1776: end
1777: 
1778: 
1779: """
1780: Retrieves the current number of tuples in a data chunk.
1781: 
1782: * chunk: The data chunk to get the data from
1783: * returns: The number of tuples in the data chunk
1784: """
1785: function duckdb_data_chunk_get_size(chunk)
1786:     return ccall((:duckdb_data_chunk_get_size, libduckdb), UInt64, (duckdb_data_chunk,), chunk)
1787: end
1788: 
1789: """
1790: Sets the current number of tuples in a data chunk.
1791: 
1792: * chunk: The data chunk to set the size in
1793: * size: The number of tuples in the data chunk
1794: """
1795: function duckdb_data_chunk_set_size(chunk, size)
1796:     return ccall((:duckdb_data_chunk_set_size, libduckdb), Cvoid, (duckdb_data_chunk, UInt64), chunk, size)
1797: end
1798: 
1799: """
1800: Retrieves the vector at the specified column index in the data chunk.
1801: 
1802: The pointer to the vector is valid for as long as the chunk is alive.
1803: It does NOT need to be destroyed.
1804: 
1805: * chunk: The data chunk to get the data from
1806: * returns: The vector
1807: """
1808: function duckdb_data_chunk_get_vector(chunk, col_idx)
1809:     return ccall(
1810:         (:duckdb_data_chunk_get_vector, libduckdb),
1811:         duckdb_vector,
1812:         (duckdb_data_chunk, UInt64),
1813:         chunk,
1814:         col_idx - 1
1815:     )
1816: end
1817: 
1818: #=
1819: //===--------------------------------------------------------------------===//
1820: // Vector Functions
1821: //===--------------------------------------------------------------------===//
1822: =#
1823: """
1824: Retrieves the column type of the specified vector.
1825: 
1826: The result must be destroyed with `duckdb_destroy_logical_type`.
1827: 
1828: * vector: The vector get the data from
1829: * returns: The type of the vector
1830: """
1831: function duckdb_vector_get_column_type(vector)
1832:     return ccall((:duckdb_vector_get_column_type, libduckdb), duckdb_logical_type, (duckdb_vector,), vector)
1833: end
1834: 
1835: """
1836: Retrieves the data pointer of the vector.
1837: 
1838: The data pointer can be used to read or write values from the vector.
1839: How to read or write values depends on the type of the vector.
1840: 
1841: * vector: The vector to get the data from
1842: * returns: The data pointer
1843: """
1844: function duckdb_vector_get_data(vector)
1845:     return ccall((:duckdb_vector_get_data, libduckdb), Ptr{Cvoid}, (duckdb_vector,), vector)
1846: end
1847: 
1848: """
1849: Retrieves the validity mask pointer of the specified vector.
1850: 
1851: If all values are valid, this function MIGHT return NULL!
1852: 
1853: The validity mask is a bitset that signifies null-ness within the data chunk.
1854: It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.
1855: The bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).
1856: 
1857: Validity of a specific value can be obtained like this:
1858: 
1859: idx_t entry_idx = row_idx / 64;
1860: idx_t idx_in_entry = row_idx % 64;
1861: bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);
1862: 
1863: Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.
1864: 
1865: * vector: The vector to get the data from
1866: * returns: The pointer to the validity mask, or NULL if no validity mask is present
1867: """
1868: function duckdb_vector_get_validity(vector)
1869:     return ccall((:duckdb_vector_get_validity, libduckdb), Ptr{UInt64}, (duckdb_vector,), vector)
1870: end
1871: 
1872: """
1873: Ensures the validity mask is writable by allocating it.
1874: 
1875: After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.
1876: This allows null values to be written to the vector, regardless of whether a validity mask was present before.
1877: 
1878: * vector: The vector to alter
1879: """
1880: function duckdb_vector_ensure_validity_writable(vector)
1881:     return ccall((:duckdb_vector_ensure_validity_writable, libduckdb), Cvoid, (duckdb_vector,), vector)
1882: end
1883: 
1884: """
1885: Retrieves the child vector of a list vector.
1886: 
1887: The resulting vector is valid as long as the parent vector is valid.
1888: 
1889: * vector: The vector
1890: * returns: The child vector
1891: """
1892: function duckdb_list_vector_get_child(vector)
1893:     return ccall((:duckdb_list_vector_get_child, libduckdb), duckdb_vector, (duckdb_vector,), vector)
1894: end
1895: 
1896: """
1897: Returns the size of the child vector of the list
1898: 
1899: * vector: The vector
1900: * returns: The size of the child list
1901: """
1902: function duckdb_list_vector_get_size(vector)
1903:     return ccall((:duckdb_list_vector_get_size, libduckdb), UInt64, (duckdb_vector,), vector)
1904: end
1905: 
1906: """
1907: Retrieves the child vector of a struct vector.
1908: 
1909: The resulting vector is valid as long as the parent vector is valid.
1910: 
1911: * vector: The vector
1912: * index: The child index
1913: * returns: The child vector
1914: """
1915: function duckdb_struct_vector_get_child(vector, index)
1916:     return ccall(
1917:         (:duckdb_struct_vector_get_child, libduckdb),
1918:         duckdb_vector,
1919:         (duckdb_vector, UInt64),
1920:         vector,
1921:         index - 1
1922:     )
1923: end
1924: 
1925: """
1926: Retrieves the member vector of a union vector.
1927: 
1928: The resulting vector is valid as long as the parent vector is valid.
1929: 
1930: * vector: The vector
1931: * index: The member index
1932: * returns: The member vector
1933: """
1934: function duckdb_union_vector_get_member(vector, index)
1935:     return ccall(
1936:         (:duckdb_struct_vector_get_child, libduckdb),
1937:         duckdb_vector,
1938:         (duckdb_vector, UInt64),
1939:         vector,
1940:         1 + (index - 1)
1941:     )
1942: end
1943: 
1944: """
1945: Assigns a string element in the vector at the specified location.
1946: 
1947: * vector: The vector to alter
1948: * index: The row position in the vector to assign the string to
1949: * str: The null-terminated string
1950: """
1951: function duckdb_vector_assign_string_element(vector, index, str)
1952:     return ccall(
1953:         (:duckdb_vector_assign_string_element, libduckdb),
1954:         Cvoid,
1955:         (duckdb_vector, UInt64, Ptr{UInt8}),
1956:         vector,
1957:         index - 1,
1958:         str
1959:     )
1960: end
1961: """
1962: Assigns a string element in the vector at the specified location.
1963: 
1964: * vector: The vector to alter
1965: * index: The row position in the vector to assign the string to
1966: * str: The null-terminated string
1967: * str_len: The string length
1968: """
1969: function duckdb_vector_assign_string_element_len(vector, index, str, str_len)
1970:     return ccall(
1971:         (:duckdb_vector_assign_string_element_len, libduckdb),
1972:         Cvoid,
1973:         (duckdb_vector, UInt64, Ptr{UInt8}, UInt64),
1974:         vector,
1975:         index - 1,
1976:         str,
1977:         str_len
1978:     )
1979: end
1980: 
1981: #=
1982: //===--------------------------------------------------------------------===//
1983: // Table Functions
1984: //===--------------------------------------------------------------------===//
1985: =#
1986: """
1987: Creates a new empty table function.
1988: 
1989: The return value should be destroyed with `duckdb_destroy_table_function`.
1990: 
1991: * returns: The table function object.
1992: """
1993: function duckdb_create_table_function()
1994:     return ccall((:duckdb_create_table_function, libduckdb), duckdb_table_function, ())
1995: end
1996: 
1997: """
1998: Destroys the given table function object.
1999: 
2000: * table_function: The table function to destroy
2001: """
2002: function duckdb_destroy_table_function(func)
2003:     return ccall((:duckdb_destroy_table_function, libduckdb), Cvoid, (Ref{duckdb_table_function},), func)
2004: end
2005: 
2006: """
2007: Sets the name of the given table function.
2008: 
2009: * table_function: The table function
2010: * name: The name of the table function
2011: """
2012: function duckdb_table_function_set_name(func, name)
2013:     return ccall((:duckdb_table_function_set_name, libduckdb), Cvoid, (duckdb_table_function, Ptr{UInt8}), func, name)
2014: end
2015: 
2016: """
2017: Adds a parameter to the table function.
2018: 
2019: * table_function: The table function
2020: * type: The type of the parameter to add.
2021: """
2022: function duckdb_table_function_add_parameter(func, type)
2023:     return ccall(
2024:         (:duckdb_table_function_add_parameter, libduckdb),
2025:         Cvoid,
2026:         (duckdb_table_function, duckdb_logical_type),
2027:         func,
2028:         type
2029:     )
2030: end
2031: 
2032: """
2033: Assigns extra information to the table function that can be fetched during binding, etc.
2034: 
2035: * table_function: The table function
2036: * extra_info: The extra information
2037: * destroy: The callback that will be called to destroy the bind data (if any)
2038: """
2039: function duckdb_table_function_set_extra_info(table_func, extra_data)
2040:     return ccall(
2041:         (:duckdb_table_function_set_extra_info, libduckdb),
2042:         Cvoid,
2043:         (duckdb_table_function, Ptr{Cvoid}, Ptr{Cvoid}),
2044:         table_func,
2045:         extra_data,
2046:         C_NULL
2047:     )
2048: end
2049: 
2050: """
2051: Sets the bind function of the table function
2052: 
2053: * table_function: The table function
2054: * bind: The bind function
2055: """
2056: function duckdb_table_function_set_bind(table_func, bind_func)
2057:     return ccall(
2058:         (:duckdb_table_function_set_bind, libduckdb),
2059:         Cvoid,
2060:         (duckdb_table_function, Ptr{Cvoid}),
2061:         table_func,
2062:         bind_func
2063:     )
2064: end
2065: 
2066: """
2067: Sets the init function of the table function
2068: 
2069: * table_function: The table function
2070: * init: The init function
2071: """
2072: function duckdb_table_function_set_init(table_func, init_func)
2073:     return ccall(
2074:         (:duckdb_table_function_set_init, libduckdb),
2075:         Cvoid,
2076:         (duckdb_table_function, Ptr{Cvoid}),
2077:         table_func,
2078:         init_func
2079:     )
2080: end
2081: 
2082: """
2083: Sets the thread-local init function of the table function
2084: 
2085: * table_function: The table function
2086: * init: The init function
2087: """
2088: function duckdb_table_function_set_local_init(table_func, init_func)
2089:     return ccall(
2090:         (:duckdb_table_function_set_local_init, libduckdb),
2091:         Cvoid,
2092:         (duckdb_table_function, Ptr{Cvoid}),
2093:         table_func,
2094:         init_func
2095:     )
2096: end
2097: 
2098: 
2099: """
2100: Sets the main function of the table function
2101: 
2102: * table_function: The table function
2103: * function: The function
2104: """
2105: function duckdb_table_function_set_function(table_func, func)
2106:     return ccall(
2107:         (:duckdb_table_function_set_function, libduckdb),
2108:         Cvoid,
2109:         (duckdb_table_function, Ptr{Cvoid}),
2110:         table_func,
2111:         func
2112:     )
2113: end
2114: 
2115: """
2116: Sets whether or not the given table function supports projection pushdown.
2117: 
2118: If this is set to true, the system will provide a list of all required columns in the `init` stage through
2119: the `duckdb_init_get_column_count` and `duckdb_init_get_column_index` functions.
2120: If this is set to false (the default), the system will expect all columns to be projected.
2121: 
2122: * table_function: The table function
2123: * pushdown: True if the table function supports projection pushdown, false otherwise.
2124: """
2125: function duckdb_table_function_supports_projection_pushdown(table_func, pushdown)
2126:     return ccall(
2127:         (:duckdb_table_function_supports_projection_pushdown, libduckdb),
2128:         Cvoid,
2129:         (duckdb_table_function, Bool),
2130:         table_func,
2131:         pushdown
2132:     )
2133: end
2134: 
2135: """
2136: Register the table function object within the given connection.
2137: 
2138: The function requires at least a name, a bind function, an init function and a main function.
2139: 
2140: If the function is incomplete or a function with this name already exists DuckDBError is returned.
2141: 
2142: * con: The connection to register it in.
2143: * function: The function pointer
2144: * returns: Whether or not the registration was successful.
2145: """
2146: function duckdb_register_table_function(con, func)
2147:     return ccall(
2148:         (:duckdb_register_table_function, libduckdb),
2149:         Int32,
2150:         (duckdb_connection, duckdb_table_function),
2151:         con,
2152:         func
2153:     )
2154: end
2155: 
2156: #=
2157: //===--------------------------------------------------------------------===//
2158: // Table Function Bind
2159: //===--------------------------------------------------------------------===//
2160: =#
2161: 
2162: """
2163: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
2164: 
2165: * info: The info object
2166: * returns: The extra info
2167: """
2168: function duckdb_bind_get_extra_info(bind_info)
2169:     return ccall((:duckdb_bind_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_bind_info,), bind_info)
2170: end
2171: 
2172: """
2173: Adds a result column to the output of the table function.
2174: 
2175: * info: The info object
2176: * name: The name of the column
2177: * type: The logical type of the column
2178: """
2179: function duckdb_bind_add_result_column(bind_info, name, type)
2180:     return ccall(
2181:         (:duckdb_bind_add_result_column, libduckdb),
2182:         Cvoid,
2183:         (duckdb_bind_info, Ptr{UInt8}, duckdb_logical_type),
2184:         bind_info,
2185:         name,
2186:         type
2187:     )
2188: end
2189: 
2190: """
2191: Retrieves the number of regular (non-named) parameters to the function.
2192: 
2193: * info: The info object
2194: * returns: The number of parameters
2195: """
2196: function duckdb_bind_get_parameter_count(bind_info)
2197:     return ccall((:duckdb_bind_get_parameter_count, libduckdb), Int32, (duckdb_bind_info,), bind_info)
2198: end
2199: 
2200: """
2201: Retrieves the parameter at the given index.
2202: 
2203: The result must be destroyed with `duckdb_destroy_value`.
2204: 
2205: * info: The info object
2206: * index: The index of the parameter to get
2207: * returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
2208: """
2209: function duckdb_bind_get_parameter(bind_info, index)
2210:     return ccall((:duckdb_bind_get_parameter, libduckdb), duckdb_value, (duckdb_bind_info, Int32), bind_info, index)
2211: end
2212: 
2213: """
2214: Retrieves the parameter at the given index.
2215: 
2216: The result must be destroyed with `duckdb_destroy_value`.
2217: 
2218: * info: The info object
2219: * index: The index of the parameter to get
2220: * returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
2221: """
2222: function duckdb_bind_set_bind_data(bind_info, bind_data, delete_callback)
2223:     return ccall(
2224:         (:duckdb_bind_set_bind_data, libduckdb),
2225:         Cvoid,
2226:         (duckdb_bind_info, Ptr{Cvoid}, Ptr{Cvoid}),
2227:         bind_info,
2228:         bind_data,
2229:         delete_callback
2230:     )
2231: end
2232: 
2233: """
2234: Sets the cardinality estimate for the table function, used for optimization.
2235: 
2236: * info: The bind data object.
2237: * is_exact: Whether or not the cardinality estimate is exact, or an approximation
2238: """
2239: function duckdb_bind_set_cardinality(bind_info, cardinality, is_exact)
2240:     return ccall(
2241:         (:duckdb_bind_set_cardinality, libduckdb),
2242:         Cvoid,
2243:         (duckdb_bind_info, UInt64, Bool),
2244:         bind_info,
2245:         cardinality,
2246:         is_exact
2247:     )
2248: end
2249: 
2250: """
2251: Report that an error has occurred during bind.
2252: 
2253: * info: The info object
2254: * error: The error message
2255: """
2256: function duckdb_bind_set_error(info, error_message)
2257:     return ccall((:duckdb_bind_set_error, libduckdb), Cvoid, (duckdb_bind_info, Ptr{UInt8}), info, error_message)
2258: end
2259: 
2260: #=
2261: //===--------------------------------------------------------------------===//
2262: // Table Function Init
2263: //===--------------------------------------------------------------------===//
2264: =#
2265: """
2266: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
2267: 
2268: * info: The info object
2269: * returns: The extra info
2270: """
2271: function duckdb_init_get_extra_info(info)
2272:     return ccall((:duckdb_init_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_init_info,), info)
2273: end
2274: 
2275: """
2276: Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
2277: 
2278: Note that the bind data should be considered as read-only.
2279: For tracking state, use the init data instead.
2280: 
2281: * info: The info object
2282: * returns: The bind data object
2283: """
2284: function duckdb_init_get_bind_data(info)
2285:     return ccall((:duckdb_init_get_bind_data, libduckdb), Ptr{Cvoid}, (duckdb_init_info,), info)
2286: end
2287: 
2288: """
2289: Sets the user-provided init data in the init object. This object can be retrieved again during execution.
2290: 
2291: * info: The info object
2292: * extra_data: The init data object.
2293: * destroy: The callback that will be called to destroy the init data (if any)
2294: """
2295: function duckdb_init_set_init_data(init_info, init_data, delete_callback)
2296:     return ccall(
2297:         (:duckdb_init_set_init_data, libduckdb),
2298:         Cvoid,
2299:         (duckdb_init_info, Ptr{Cvoid}, Ptr{Cvoid}),
2300:         init_info,
2301:         init_data,
2302:         delete_callback
2303:     )
2304: end
2305: 
2306: 
2307: """
2308: Returns the number of projected columns.
2309: 
2310: This function must be used if projection pushdown is enabled to figure out which columns to emit.
2311: 
2312: * info: The info object
2313: * returns: The number of projected columns.
2314: """
2315: function duckdb_init_get_column_count(info)
2316:     return ccall((:duckdb_init_get_column_count, libduckdb), UInt64, (duckdb_init_info,), info)
2317: end
2318: 
2319: """
2320: Returns the column index of the projected column at the specified position.
2321: 
2322: This function must be used if projection pushdown is enabled to figure out which columns to emit.
2323: 
2324: * info: The info object
2325: * column_index: The index at which to get the projected column index, from 0..duckdb_init_get_column_count(info)
2326: * returns: The column index of the projected column.
2327: """
2328: function duckdb_init_get_column_index(info, index)
2329:     return ccall((:duckdb_init_get_column_index, libduckdb), UInt64, (duckdb_init_info, UInt64), info, index - 1) + 1
2330: end
2331: 
2332: """
2333: Sets how many threads can process this table function in parallel (default: 1)
2334: 
2335: * info: The info object
2336: * max_threads: The maximum amount of threads that can process this table function
2337: """
2338: function duckdb_init_set_max_threads(info, max_threads)
2339:     return ccall((:duckdb_init_set_max_threads, libduckdb), Cvoid, (duckdb_init_info, UInt64), info, max_threads)
2340: end
2341: 
2342: """
2343: Report that an error has occurred during init.
2344: 
2345: * info: The info object
2346: * error: The error message
2347: """
2348: function duckdb_init_set_error(info, error_message)
2349:     return ccall((:duckdb_init_set_error, libduckdb), Cvoid, (duckdb_init_info, Ptr{UInt8}), info, error_message)
2350: end
2351: 
2352: #=
2353: //===--------------------------------------------------------------------===//
2354: // Table Function
2355: //===--------------------------------------------------------------------===//
2356: =#
2357: """
2358: Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
2359: 
2360: * info: The info object
2361: * returns: The extra info
2362: """
2363: function duckdb_function_get_extra_info(info)
2364:     return ccall((:duckdb_function_get_extra_info, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)
2365: end
2366: 
2367: """
2368: Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
2369: 
2370: Note that the bind data should be considered as read-only.
2371: For tracking state, use the init data instead.
2372: 
2373: * info: The info object
2374: * returns: The bind data object
2375: """
2376: function duckdb_function_get_bind_data(info)
2377:     return ccall((:duckdb_function_get_bind_data, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)
2378: end
2379: 
2380: """
2381: Gets the init data set by `duckdb_init_set_init_data` during the init.
2382: 
2383: * info: The info object
2384: * returns: The init data object
2385: """
2386: function duckdb_function_get_init_data(info)
2387:     return ccall((:duckdb_function_get_init_data, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)
2388: end
2389: 
2390: """
2391: Gets the init data set by `duckdb_init_set_init_data` during the local_init.
2392: 
2393: * info: The info object
2394: * returns: The init data object
2395: """
2396: function duckdb_function_get_local_init_data(info)
2397:     return ccall((:duckdb_function_get_local_init_data, libduckdb), Ptr{Cvoid}, (duckdb_function_info,), info)
2398: end
2399: 
2400: """
2401: Report that an error has occurred while executing the function.
2402: 
2403: * info: The info object
2404: * error: The error message
2405: """
2406: function duckdb_function_set_error(info, error_message)
2407:     return ccall(
2408:         (:duckdb_function_set_error, libduckdb),
2409:         Cvoid,
2410:         (duckdb_function_info, Ptr{UInt8}),
2411:         info,
2412:         error_message
2413:     )
2414: end
2415: 
2416: #=
2417: //===--------------------------------------------------------------------===//
2418: // Replacement scans
2419: //===--------------------------------------------------------------------===//
2420: =#
2421: """
2422: Add a replacement scan definition to the specified database
2423: 
2424: * db: The database object to add the replacement scan to
2425: * replacement: The replacement scan callback
2426: * extra_data: Extra data that is passed back into the specified callback
2427: * delete_callback: The delete callback to call on the extra data, if any
2428: """
2429: function duckdb_add_replacement_scan(db, replacement, extra_data, delete_callback)
2430:     return ccall(
2431:         (:duckdb_add_replacement_scan, libduckdb),
2432:         Cvoid,
2433:         (duckdb_database, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}),
2434:         db,
2435:         replacement,
2436:         extra_data,
2437:         delete_callback
2438:     )
2439: end
2440: 
2441: """
2442: Sets the replacement function name to use. If this function is called in the replacement callback,
2443:  the replacement scan is performed. If it is not called, the replacement callback is not performed.
2444: 
2445: * info: The info object
2446: * function_name: The function name to substitute.
2447: """
2448: function duckdb_replacement_scan_set_function_name(info, function_name)
2449:     return ccall(
2450:         (:duckdb_replacement_scan_set_function_name, libduckdb),
2451:         Cvoid,
2452:         (duckdb_replacement_scan_info, Ptr{UInt8}),
2453:         info,
2454:         function_name
2455:     )
2456: end
2457: 
2458: 
2459: """
2460: Adds a parameter to the replacement scan function.
2461: 
2462: * info: The info object
2463: * parameter: The parameter to add. The function will call `duckdb_destroy_value` on the parameter.
2464: """
2465: function duckdb_replacement_scan_add_parameter(info, parameter)
2466:     return ccall(
2467:         (:duckdb_replacement_scan_add_parameter, libduckdb),
2468:         Cvoid,
2469:         (duckdb_replacement_scan_info, duckdb_value),
2470:         info,
2471:         parameter
2472:     )
2473: end
2474: 
2475: """
2476: Report that an error has occurred while executing the replacement scan.
2477: 
2478: * info: The info object
2479: * error: The error message
2480: """
2481: function duckdb_replacement_scan_set_error(info, error_message)
2482:     return ccall(
2483:         (:duckdb_replacement_scan_set_error, libduckdb),
2484:         Cvoid,
2485:         (duckdb_replacement_scan_info, Ptr{UInt8}),
2486:         info,
2487:         error_message
2488:     )
2489: end
2490: 
2491: #=
2492: //===--------------------------------------------------------------------===//
2493: // Appender
2494: //===--------------------------------------------------------------------===//
2495: =#
2496: 
2497: """
2498: Creates an appender object.
2499: * connection: The connection context to create the appender in.
2500: * schema: The schema of the table to append to, or `nullptr` for the default schema.
2501: * table: The table name to append to.
2502: * out_appender: The resulting appender object.
2503: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2504: DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,
2505:                                                duckdb_appender *out_appender);
2506: """
2507: function duckdb_appender_create(connection, schema, table, out_appender)
2508:     return ccall(
2509:         (:duckdb_appender_create, libduckdb),
2510:         Int32,
2511:         (duckdb_connection, Ptr{UInt8}, Ptr{UInt8}, Ref{duckdb_appender}),
2512:         connection,
2513:         schema,
2514:         table,
2515:         out_appender
2516:     )
2517: end
2518: 
2519: """
2520: Returns the error message associated with the given appender.
2521: If the appender has no error message, this returns `nullptr` instead.
2522: The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.
2523: * appender: The appender to get the error from.
2524: * returns: The error message, or `nullptr` if there is none.
2525: DUCKDB_API const char *duckdb_appender_error(duckdb_appender appender);
2526: """
2527: function duckdb_appender_error(appender)
2528:     return ccall((:duckdb_appender_error, libduckdb), Ptr{UInt8}, (duckdb_appender,), appender)
2529: end
2530: 
2531: """
2532: Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the
2533: base table.
2534: This should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you
2535: are done with the appender.
2536: * appender: The appender to flush.
2537: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2538: DUCKDB_API duckdb_state duckdb_appender_flush(duckdb_appender appender);
2539: """
2540: function duckdb_appender_flush(appender)
2541:     return ccall((:duckdb_appender_flush, libduckdb), duckdb_state, (duckdb_appender,), appender)
2542: end
2543: 
2544: """
2545: Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.
2546: This is generally not necessary. Call `duckdb_appender_destroy` instead.
2547: * appender: The appender to flush and close.
2548: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2549: DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);
2550: """
2551: function duckdb_appender_close(appender)
2552:     return ccall((:duckdb_appender_close, libduckdb), duckdb_state, (duckdb_appender,), appender)
2553: end
2554: 
2555: """
2556: Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating
2557: all memory associated with the appender.
2558: * appender: The appender to flush, close and destroy.
2559: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2560: DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);
2561: """
2562: function duckdb_appender_destroy(appender)
2563:     return ccall((:duckdb_appender_destroy, libduckdb), duckdb_state, (Ref{duckdb_appender},), appender)
2564: end
2565: 
2566: """
2567: A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.
2568: DUCKDB_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);
2569: """
2570: function duckdb_appender_begin_row(appender)
2571:     return ccall((:duckdb_appender_begin_row, libduckdb), duckdb_state, (duckdb_appender,), appender)
2572: end
2573: 
2574: """
2575: Finish the current row of appends. After end_row is called, the next row can be appended.
2576: * appender: The appender.
2577: * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2578: DUCKDB_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);
2579: """
2580: function duckdb_appender_end_row(appender)
2581:     return ccall((:duckdb_appender_end_row, libduckdb), duckdb_state, (duckdb_appender,), appender)
2582: end
2583: 
2584: """
2585: Append a bool value to the appender.
2586: DUCKDB_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);
2587: """
2588: function duckdb_append_bool(appender, value)
2589:     return ccall((:duckdb_append_bool, libduckdb), duckdb_state, (duckdb_appender, Bool), appender, value)
2590: end
2591: 
2592: """
2593: Append an int8_t value to the appender.
2594: DUCKDB_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);
2595: """
2596: function duckdb_append_int8(appender, value)
2597:     return ccall((:duckdb_append_int8, libduckdb), duckdb_state, (duckdb_appender, Int8), appender, value)
2598: end
2599: 
2600: """
2601: Append an int16_t value to the appender.
2602: DUCKDB_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);
2603: """
2604: function duckdb_append_int16(appender, value)
2605:     return ccall((:duckdb_append_int16, libduckdb), duckdb_state, (duckdb_appender, Int16), appender, value)
2606: end
2607: 
2608: """
2609: Append an int32_t value to the appender.
2610: DUCKDB_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);
2611: """
2612: function duckdb_append_int32(appender, value)
2613:     return ccall((:duckdb_append_int16, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
2614: end
2615: 
2616: """
2617: Append an int64_t value to the appender.
2618: DUCKDB_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);
2619: """
2620: function duckdb_append_int64(appender, value)
2621:     return ccall((:duckdb_append_int64, libduckdb), duckdb_state, (duckdb_appender, Int64), appender, value)
2622: end
2623: 
2624: """
2625: Append a duckdb_hugeint value to the appender.
2626: DUCKDB_API duckdb_state duckdb_append_hugeint(duckdb_appender appender, duckdb_hugeint value);
2627: """
2628: function duckdb_append_hugeint(appender, value)
2629:     return ccall((:duckdb_append_hugeint, libduckdb), duckdb_state, (duckdb_appender, Int128), appender, value)
2630: end
2631: 
2632: """
2633: Append a duckdb_uhugeint value to the appender.
2634: DUCKDB_API duckdb_state duckdb_append_uhugeint(duckdb_appender appender, duckdb_uhugeint value);
2635: """
2636: function duckdb_append_uhugeint(appender, value)
2637:     return ccall((:duckdb_append_uhugeint, libduckdb), duckdb_state, (duckdb_appender, UInt128), appender, value)
2638: end
2639: 
2640: """
2641: Append a uint8_t value to the appender.
2642: DUCKDB_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);
2643: """
2644: function duckdb_append_uint8(appender, value)
2645:     return ccall((:duckdb_append_uint8, libduckdb), duckdb_state, (duckdb_appender, UInt8), appender, value)
2646: end
2647: 
2648: """
2649: Append a uint16_t value to the appender.
2650: DUCKDB_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);
2651: """
2652: function duckdb_append_uint16(appender, value)
2653:     return ccall((:duckdb_append_uint16, libduckdb), duckdb_state, (duckdb_appender, UInt16), appender, value)
2654: end
2655: 
2656: """
2657: Append a uint32_t value to the appender.
2658: DUCKDB_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);
2659: """
2660: function duckdb_append_uint32(appender, value)
2661:     return ccall((:duckdb_append_uint32, libduckdb), duckdb_state, (duckdb_appender, UInt32), appender, value)
2662: end
2663: 
2664: """
2665: Append a uint64_t value to the appender.
2666: DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);
2667: """
2668: function duckdb_append_uint64(appender, value)
2669:     return ccall((:duckdb_append_uint64, libduckdb), duckdb_state, (duckdb_appender, UInt64), appender, value)
2670: end
2671: 
2672: """
2673: Append a float value to the appender.
2674: DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);
2675: """
2676: function duckdb_append_float(appender, value)
2677:     return ccall((:duckdb_append_float, libduckdb), duckdb_state, (duckdb_appender, Float32), appender, value)
2678: end
2679: 
2680: """
2681: Append a double value to the appender.
2682: DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);
2683: """
2684: function duckdb_append_double(appender, value)
2685:     return ccall((:duckdb_append_double, libduckdb), duckdb_state, (duckdb_appender, Float64), appender, value)
2686: end
2687: 
2688: """
2689: Append a duckdb_date value to the appender.
2690: DUCKDB_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);
2691: """
2692: function duckdb_append_date(appender, value)
2693:     return ccall((:duckdb_append_date, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
2694: end
2695: 
2696: """
2697: Append a duckdb_time value to the appender.
2698: DUCKDB_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);
2699: """
2700: function duckdb_append_time(appender, value)
2701:     return ccall((:duckdb_append_time, libduckdb), duckdb_state, (duckdb_appender, Int64), appender, value)
2702: end
2703: 
2704: """
2705: Append a duckdb_timestamp value to the appender.
2706: DUCKDB_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);
2707: """
2708: function duckdb_append_timestamp(appender, value)
2709:     return ccall((:duckdb_append_timestamp, libduckdb), duckdb_state, (duckdb_appender, Int64), appender, value)
2710: end
2711: 
2712: """
2713: Append a duckdb_interval value to the appender.
2714: DUCKDB_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);
2715: """
2716: function duckdb_append_interval(appender, value)
2717:     return ccall((:duckdb_append_interval, libduckdb), duckdb_state, (duckdb_appender, Int32), appender, value)
2718: end
2719: 
2720: """
2721: Append a varchar value to the appender.
2722: DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);
2723: """
2724: function duckdb_append_varchar(appender, value)
2725:     return ccall((:duckdb_append_varchar, libduckdb), duckdb_state, (duckdb_appender, Ptr{UInt8}), appender, value)
2726: end
2727: 
2728: """
2729: Append a varchar value to the appender.
2730: DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);
2731: """
2732: function duckdb_append_varchar_length(appender, value, length)
2733:     return ccall(
2734:         (:duckdb_append_varchar_length, libduckdb),
2735:         duckdb_state,
2736:         (duckdb_appender, Ptr{UInt8}, Int32),
2737:         appender,
2738:         value,
2739:         length
2740:     )
2741: end
2742: 
2743: """
2744: Append a blob value to the appender.
2745: DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);
2746: """
2747: function duckdb_append_blob(appender, data, length)
2748:     return ccall(
2749:         (:duckdb_append_blob, libduckdb),
2750:         duckdb_state,
2751:         (duckdb_appender, Ptr{Cvoid}, Int32),
2752:         appender,
2753:         data,
2754:         length
2755:     )
2756: end
2757: 
2758: """
2759: Append a NULL value to the appender (of any type).
2760: DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);
2761: """
2762: function duckdb_append_null(appender)
2763:     return ccall((:duckdb_append_null, libduckdb), duckdb_state, (duckdb_appender,), appender)
2764: end
2765: 
2766: # #=
2767: # //===--------------------------------------------------------------------===//
2768: # // Arrow Interface
2769: # //===--------------------------------------------------------------------===//
2770: # =#
2771: #
2772: #
2773: # """
2774: # Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.
2775: # If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
2776: # `duckdb_query_arrow_error`.
2777: # Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the
2778: # query fails, otherwise the error stored within the result will not be freed correctly.
2779: # * connection: The connection to perform the query in.
2780: # * query: The SQL query to run.
2781: # * out_result: The query result.
2782: # * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2783: # DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);
2784: # """
2785: # function duckdb_query_arrow(connection, query, out_result)
2786: #     return ccall(
2787: #         (:duckdb_query_arrow, libduckdb),
2788: #         Int32,
2789: #         (Ptr{Cvoid}, Ptr{UInt8}, Ptr{Cvoid}),
2790: #         connection[],
2791: #         query,
2792: #         out_result,
2793: #     )
2794: # end
2795: #
2796: # """
2797: # Fetch the internal arrow schema from the arrow result.
2798: # * result: The result to fetch the schema from.
2799: # * out_schema: The output schema.
2800: # * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2801: # DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);
2802: # """
2803: # function duckdb_query_arrow_schema(result, out_schema)
2804: #     return ccall(
2805: #         (:duckdb_query_arrow_schema, libduckdb),
2806: #         duckdb_state,
2807: #         (Ptr{Cvoid}, Ptr{UInt8}),
2808: #         result,
2809: #         out_schema,
2810: #     )
2811: # end
2812: #
2813: # """
2814: # Fetch an internal arrow array from the arrow result.
2815: # This function can be called multiple time to get next chunks, which will free the previous out_array.
2816: # So consume the out_array before calling this function again.
2817: # * result: The result to fetch the array from.
2818: # * out_array: The output array.
2819: # * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
2820: # DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);
2821: # """
2822: # function duckdb_query_arrow_array(result, out_array)
2823: #     return ccall(
2824: #         (:duckdb_query_arrow_array, libduckdb),
2825: #         duckdb_state,
2826: #         (Ptr{Cvoid}, Ptr{Cvoid}),
2827: #         result,
2828: #         out_array,
2829: #     )
2830: # end
2831: #
2832: # """
2833: # Returns the number of columns present in a the arrow result object.
2834: # * result: The result object.
2835: # * returns: The number of columns present in the result object.
2836: # DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);
2837: # """
2838: # function duckdb_arrow_column_count(result)
2839: #     return ccall((:duckdb_arrow_column_count, libduckdb), Int32, (Ptr{Cvoid},), result)
2840: # end
2841: #
2842: # """
2843: # Returns the number of rows present in a the arrow result object.
2844: # * result: The result object.
2845: # * returns: The number of rows present in the result object.
2846: # DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);
2847: # """
2848: # function duckdb_arrow_row_count(result)
2849: #     return ccall((:duckdb_arrow_row_count, libduckdb), Int64, (Ptr{Cvoid},), result)
2850: # end
2851: #
2852: # """
2853: # Returns the number of rows changed by the query stored in the arrow result. This is relevant only for
2854: # INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.
2855: # * result: The result object.
2856: # * returns: The number of rows changed.
2857: # DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);
2858: # """
2859: # function duckdb_arrow_rows_changed(result)
2860: #     return ccall((:duckdb_arrow_rows_changed, libduckdb), Int64, (Ptr{Cvoid},), result)
2861: # end
2862: #
2863: # """
2864: # Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns
2865: # `DuckDBError`.
2866: # The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.
2867: # * result: The result object to fetch the nullmask from.
2868: # * returns: The error of the result.
2869: # DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);
2870: # """
2871: # function duckdb_query_arrow_error(result)
2872: #     return ccall((:duckdb_query_arrow_error, libduckdb), Ptr{UInt8}, (Ptr{Cvoid},), result)
2873: # end
2874: #
2875: # """
2876: # Closes the result and de-allocates all memory allocated for the arrow result.
2877: # * result: The result to destroy.
2878: # DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);
2879: # """
2880: # function duckdb_destroy_arrow(result)
2881: #     return ccall((:duckdb_destroy_arrow, libduckdb), Cvoid, (Ptr{Ptr{Cvoid}},), result)
2882: # end
2883: 
2884: #=
2885: //===--------------------------------------------------------------------===//
2886: // Threading Interface
2887: //===--------------------------------------------------------------------===//
2888: =#
2889: """
2890: Execute DuckDB tasks on this thread.
2891: 
2892: Will return after `max_tasks` have been executed, or if there are no more tasks present.
2893: 
2894: * database: The database object to execute tasks for
2895: * max_tasks: The maximum amount of tasks to execute
2896: """
2897: function duckdb_execute_tasks(handle, max_tasks)
2898:     return ccall((:duckdb_execute_tasks, libduckdb), Cvoid, (duckdb_database, UInt64), handle, max_tasks)
2899: end
2900: 
2901: """
2902: Creates a task state that can be used with duckdb_execute_tasks_state to execute tasks until
2903:  duckdb_finish_execution is called on the state.
2904: 
2905: duckdb_destroy_state should be called on the result in order to free memory.
2906: 
2907: * returns: The task state that can be used with duckdb_execute_tasks_state.
2908: """
2909: function duckdb_create_task_state(database)
2910:     return ccall((:duckdb_create_task_state, libduckdb), duckdb_task_state, (duckdb_database,), database)
2911: end
2912: 
2913: """
2914: Execute DuckDB tasks on this thread.
2915: 
2916: The thread will keep on executing tasks forever, until duckdb_finish_execution is called on the state.
2917: Multiple threads can share the same duckdb_task_state.
2918: 
2919: * database: The database object to execute tasks for
2920: * state: The task state of the executor
2921: """
2922: function duckdb_execute_tasks_state(state)
2923:     return ccall((:duckdb_execute_tasks_state, libduckdb), Cvoid, (duckdb_task_state,), state)
2924: end
2925: 
2926: """
2927: Execute DuckDB tasks on this thread.
2928: 
2929: The thread will keep on executing tasks until either duckdb_finish_execution is called on the state,
2930: max_tasks tasks have been executed or there are no more tasks to be executed.
2931: 
2932: Multiple threads can share the same duckdb_task_state.
2933: 
2934: * state: The task state of the executor
2935: * max_tasks: The maximum amount of tasks to execute
2936: * returns: The amount of tasks that have actually been executed
2937: """
2938: function duckdb_execute_n_tasks_state(state, max_tasks)
2939:     return ccall((:duckdb_execute_n_tasks_state, libduckdb), UInt64, (duckdb_task_state, UInt64), state, max_tasks)
2940: end
2941: 
2942: """
2943: Finish execution on a specific task.
2944: 
2945: * state: The task state to finish execution
2946: """
2947: function duckdb_finish_execution(state)
2948:     return ccall((:duckdb_finish_execution, libduckdb), Cvoid, (duckdb_task_state,), state)
2949: end
2950: 
2951: """
2952: Check if the provided duckdb_task_state has finished execution
2953: 
2954: * state: The task state to inspect
2955: * returns: Whether or not duckdb_finish_execution has been called on the task state
2956: """
2957: function duckdb_task_state_is_finished(state)
2958:     return ccall((:duckdb_task_state_is_finished, libduckdb), Bool, (duckdb_task_state,), state)
2959: end
2960: 
2961: """
2962: Destroys the task state returned from duckdb_create_task_state.
2963: 
2964: Note that this should not be called while there is an active duckdb_execute_tasks_state running
2965: on the task state.
2966: 
2967: * state: The task state to clean up
2968: """
2969: function duckdb_destroy_task_state(state)
2970:     return ccall((:duckdb_destroy_task_state, libduckdb), Cvoid, (duckdb_task_state,), state)
2971: end
2972: 
2973: """
2974: Returns true if execution of the current query is finished.
2975: 
2976: * con: The connection on which to check
2977: """
2978: function duckdb_execution_is_finished(con)
2979:     return ccall((:duckdb_execution_is_finished, libduckdb), Bool, (duckdb_connection,), con)
2980: end
[end of tools/juliapkg/src/api.jl]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: