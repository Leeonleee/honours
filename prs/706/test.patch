diff --git a/tools/rpkg/tests/testthat.R b/tools/rpkg/tests/testthat.R
index 1ae94ea805f3..03b5eae9b505 100644
--- a/tools/rpkg/tests/testthat.R
+++ b/tools/rpkg/tests/testthat.R
@@ -4,25 +4,25 @@ library("testthat")
 test_check("duckdb")
 
 dbplyr_tests <- function() {
-	if (!identical(Sys.getenv("NOT_CRAN"), "true")) {
-		return()
-	}
-	# the hacky part
-	library("dbplyr")
+  if (!identical(Sys.getenv("NOT_CRAN"), "true")) {
+    return()
+  }
+  # the hacky part
+  library("dbplyr")
 
-	# pull dbplyr sources to harvest test cases
-	zipfile <- tempfile()
-	url <- "https://github.com/tidyverse/dbplyr/archive/v1.4.2.zip"
-	download.file(url, zipfile)
-	dbplyr_src <- tempdir()
-	unzip(zipfile, exdir=dbplyr_src)
-	tests <- Sys.glob(file.path(dbplyr_src, "dbplyr*", "tests"))
-	setwd(tests)
+  # pull dbplyr sources to harvest test cases
+  zipfile <- tempfile()
+  url <- "https://github.com/tidyverse/dbplyr/archive/v1.4.2.zip"
+  download.file(url, zipfile)
+  dbplyr_src <- tempdir()
+  unzip(zipfile, exdir = dbplyr_src)
+  tests <- Sys.glob(file.path(dbplyr_src, "dbplyr*", "tests"))
+  setwd(tests)
 
-	options(duckdb.debug=T)
-	test_register_src("duckdb", duckdb::src_duckdb())
+  options(duckdb.debug = T)
+  test_register_src("duckdb", duckdb::src_duckdb())
 
-	# TODO fix excluded test cases
-	test_check("dbplyr", stop_on_failure=TRUE,, invert=T, filter="(verb-joins|verb-mutate)")
+  # TODO fix excluded test cases
+  test_check("dbplyr", stop_on_failure = TRUE, , invert = T, filter = "(verb-joins|verb-mutate)")
 }
 # dbplyr_tests()
diff --git a/tools/rpkg/tests/testthat/test-DBItest.R b/tools/rpkg/tests/testthat/test-DBItest.R
index 17b26a154542..31ab761ef613 100644
--- a/tools/rpkg/tests/testthat/test-DBItest.R
+++ b/tools/rpkg/tests/testthat/test-DBItest.R
@@ -1,69 +1,69 @@
-DBItest::make_context(duckdb::duckdb(), list(debug=F), tweaks = DBItest::tweaks(omit_blob_tests=TRUE, temporary_tables=FALSE, timestamp_cast = function(x) sprintf("CAST('%s' AS TIMESTAMP)", x), date_cast = function(x) sprintf("CAST('%s' AS DATE)", x), time_cast = function(x) sprintf("CAST('%s' AS TIME)", x)), name = "duckdb")
+DBItest::make_context(duckdb::duckdb(), list(debug = F), tweaks = DBItest::tweaks(omit_blob_tests = TRUE, temporary_tables = FALSE, timestamp_cast = function(x) sprintf("CAST('%s' AS TIMESTAMP)", x), date_cast = function(x) sprintf("CAST('%s' AS DATE)", x), time_cast = function(x) sprintf("CAST('%s' AS TIME)", x)), name = "duckdb")
 
 DBItest::test_all(c(
-	"package_name", # wontfix
-	"constructor", # wontfix
-	"send_query_only_one_result_set", # wontfix
-	"send_statement_only_one_result_set", # wontfix
-	"send_query_stale_warning", # wontfix
-	"send_statement_stale_warning", # wontfix
+  "package_name", # wontfix
+  "constructor", # wontfix
+  "send_query_only_one_result_set", # wontfix
+  "send_statement_only_one_result_set", # wontfix
+  "send_query_stale_warning", # wontfix
+  "send_statement_stale_warning", # wontfix
 
-	"get_query_n_bad", # broken test
-	"get_query_good_after_bad_n", # broken test
-	"has_completed_statement", # broken test
-	"roundtrip_timestamp", # broken test
-	"data_timestamp", # broken test (fixed in dev)
+  "get_query_n_bad", # broken test
+  "get_query_good_after_bad_n", # broken test
+  "has_completed_statement", # broken test
+  "roundtrip_timestamp", # broken test
+  "data_timestamp", # broken test (fixed in dev)
 
-	"data_logical", # casting NULL issue
+  "data_logical", # casting NULL issue
 
-	"data_time_current",
-	"data_date_current",
-	"data_timestamp_current",
-	"data_date_current_typed",
-	"data_timestamp_current_typed",
-	"roundtrip_time",
-	"roundtrip_field_types", # strange
-	"data_64_bit_numeric_warning",  # not now
-	"data_64_bit_lossless",  # not now,
-	"roundtrip_64_bit_character",
-	"roundtrip_64_bit_numeric",
-	"roundtrip_numeric_special",
+  "data_time_current",
+  "data_date_current",
+  "data_timestamp_current",
+  "data_date_current_typed",
+  "data_timestamp_current_typed",
+  "roundtrip_time",
+  "roundtrip_field_types", # strange
+  "data_64_bit_numeric_warning", # not now
+  "data_64_bit_lossless", # not now,
+  "roundtrip_64_bit_character",
+  "roundtrip_64_bit_numeric",
+  "roundtrip_numeric_special",
 
-	"begin_write_commit",
-	"remove_table_other_con",
-	"table_visible_in_other_connection",
-	# new tests skipped after DBI upgrade
-	"connect_format",
-	"connect_bigint_integer",
-	"connect_bigint_character",
-	"connect_bigint_integer64",
-	"create_table_overwrite",
-	"append_table_return",
-	"append_table_append_incompatible",
-	"append_roundtrip_keywords",
-	"append_roundtrip_quotes",
-	"append_roundtrip_integer",
-	"append_roundtrip_numeric",
-	"append_roundtrip_logical",
-	"append_roundtrip_null",
-	"append_roundtrip_64_bit_numeric",
-	"append_roundtrip_64_bit_character",
-	"append_roundtrip_64_bit_roundtrip",
-	"append_roundtrip_character",
-	"append_roundtrip_character_native",
-	"append_roundtrip_character_empty",
-	"append_roundtrip_factor",
-	"append_roundtrip_date",
-	"append_roundtrip_time",
-	"append_roundtrip_timestamp",
-	"append_table_name",
-	"append_table_row_names_false",
-	"remove_table_missing_succeed",
-	"column_info_closed",
-	"column_info_consistent",
-	"column_info_consistent",
-	"reexport",
-	"roundtrip_logical",
+  "begin_write_commit",
+  "remove_table_other_con",
+  "table_visible_in_other_connection",
+  # new tests skipped after DBI upgrade
+  "connect_format",
+  "connect_bigint_integer",
+  "connect_bigint_character",
+  "connect_bigint_integer64",
+  "create_table_overwrite",
+  "append_table_return",
+  "append_table_append_incompatible",
+  "append_roundtrip_keywords",
+  "append_roundtrip_quotes",
+  "append_roundtrip_integer",
+  "append_roundtrip_numeric",
+  "append_roundtrip_logical",
+  "append_roundtrip_null",
+  "append_roundtrip_64_bit_numeric",
+  "append_roundtrip_64_bit_character",
+  "append_roundtrip_64_bit_roundtrip",
+  "append_roundtrip_character",
+  "append_roundtrip_character_native",
+  "append_roundtrip_character_empty",
+  "append_roundtrip_factor",
+  "append_roundtrip_date",
+  "append_roundtrip_time",
+  "append_roundtrip_timestamp",
+  "append_table_name",
+  "append_table_row_names_false",
+  "remove_table_missing_succeed",
+  "column_info_closed",
+  "column_info_consistent",
+  "column_info_consistent",
+  "reexport",
+  "roundtrip_logical",
 
-	"package_dependencies"
-	))
+  "package_dependencies"
+))
diff --git a/tools/rpkg/tests/testthat/test_bind.R b/tools/rpkg/tests/testthat/test_bind.R
index 788e9e667819..675716341a60 100644
--- a/tools/rpkg/tests/testthat/test_bind.R
+++ b/tools/rpkg/tests/testthat/test_bind.R
@@ -2,147 +2,145 @@ library("testthat")
 library("DBI")
 
 test_convert <- function(con, type, val) {
-	val_comp <- val
-	if (class(val) == "factor") {
-		val_comp <- as.character(val)
-	}
-	q <- dbSendQuery(con, sprintf("SELECT CAST(? AS %s) a", type))
-	dbBind(q, list(val))
-	res1 <- dbFetch(q)
-	dbBind(q, list(NA))
-	res2 <- dbFetch(q)
-	dbClearResult(q)
-	expect_equal(res1[[1]][1], val_comp)
-	expect_true(is.na(res2[[1]][1]))
-
-	dbExecute(con, "DROP TABLE IF EXISTS bind_test")
-	dbExecute(con, sprintf("CREATE TEMPORARY TABLE bind_test(i INTEGER, a %s)", type))
-	q <- dbSendStatement(con, "INSERT INTO bind_test VALUES ($1, $2)")
-	dbBind(q, list(1, val))
-	dbBind(q, list(2, NA))
-	dbClearResult(q)
-	res3 <- dbGetQuery(con, "SELECT a FROM bind_test ORDER BY i")
-	dbExecute(con, "DROP TABLE bind_test")
-
-	expect_equal(res3[[1]][1], val_comp)
-	expect_true(is.na(res3[[1]][2]))
+  val_comp <- val
+  if (class(val) == "factor") {
+    val_comp <- as.character(val)
+  }
+  q <- dbSendQuery(con, sprintf("SELECT CAST(? AS %s) a", type))
+  dbBind(q, list(val))
+  res1 <- dbFetch(q)
+  dbBind(q, list(NA))
+  res2 <- dbFetch(q)
+  dbClearResult(q)
+  expect_equal(res1[[1]][1], val_comp)
+  expect_true(is.na(res2[[1]][1]))
+
+  dbExecute(con, "DROP TABLE IF EXISTS bind_test")
+  dbExecute(con, sprintf("CREATE TEMPORARY TABLE bind_test(i INTEGER, a %s)", type))
+  q <- dbSendStatement(con, "INSERT INTO bind_test VALUES ($1, $2)")
+  dbBind(q, list(1, val))
+  dbBind(q, list(2, NA))
+  dbClearResult(q)
+  res3 <- dbGetQuery(con, "SELECT a FROM bind_test ORDER BY i")
+  dbExecute(con, "DROP TABLE bind_test")
+
+  expect_equal(res3[[1]][1], val_comp)
+  expect_true(is.na(res3[[1]][2]))
 }
 
 test_that("dbBind() works as expected for all types", {
-	con <- dbConnect(duckdb::duckdb())
-	test_convert(con, "BOOLEAN", TRUE)
-	test_convert(con, "BOOLEAN", FALSE)
+  con <- dbConnect(duckdb::duckdb())
+  test_convert(con, "BOOLEAN", TRUE)
+  test_convert(con, "BOOLEAN", FALSE)
 
-	test_convert(con, "INTEGER", 42L)
-	test_convert(con, "INTEGER", 42)
+  test_convert(con, "INTEGER", 42L)
+  test_convert(con, "INTEGER", 42)
 
-	test_convert(con, "DOUBLE", 42L)
-	test_convert(con, "DOUBLE", 42.2)
+  test_convert(con, "DOUBLE", 42L)
+  test_convert(con, "DOUBLE", 42.2)
 
-	test_convert(con, "STRING", "Hello, World")
-	
-	test_convert(con, "DATE", as.Date("2019-11-26"))
+  test_convert(con, "STRING", "Hello, World")
 
-	test_convert(con, "TIMESTAMP", as.POSIXct("2019-11-26 21:11Z", "UTC"))
+  test_convert(con, "DATE", as.Date("2019-11-26"))
 
-	test_convert(con, "STRING", as.factor("Hello, World"))
-	
-	dbDisconnect(con, shutdown=T)
+  test_convert(con, "TIMESTAMP", as.POSIXct("2019-11-26 21:11Z", "UTC"))
 
+  test_convert(con, "STRING", as.factor("Hello, World"))
+
+  dbDisconnect(con, shutdown = T)
 })
 
 test_that("dbBind() is called from dbGetQuery and dbExecute", {
-	con <- dbConnect(duckdb::duckdb())
-
-	res <- dbGetQuery(con, "SELECT CAST (? AS INTEGER), CAST(? AS STRING)", 42, "Hello")
+  con <- dbConnect(duckdb::duckdb())
 
-	expect_equal(res[[1]][1], 42L)
-	expect_equal(res[[2]][1], "Hello")
+  res <- dbGetQuery(con, "SELECT CAST (? AS INTEGER), CAST(? AS STRING)", 42, "Hello")
 
-	res <- dbGetQuery(con, "SELECT CAST (? AS INTEGER), CAST(? AS STRING)", list(42, "Hello"))
+  expect_equal(res[[1]][1], 42L)
+  expect_equal(res[[2]][1], "Hello")
 
-	expect_equal(res[[1]][1], 42L)
-	expect_equal(res[[2]][1], "Hello")
+  res <- dbGetQuery(con, "SELECT CAST (? AS INTEGER), CAST(? AS STRING)", list(42, "Hello"))
 
+  expect_equal(res[[1]][1], 42L)
+  expect_equal(res[[2]][1], "Hello")
 
-	q <- dbSendQuery(con, "SELECT CAST (? AS INTEGER), CAST(? AS STRING)", 42, "Hello")
-	# already have a result
 
-	res <- dbFetch(q)
+  q <- dbSendQuery(con, "SELECT CAST (? AS INTEGER), CAST(? AS STRING)", 42, "Hello")
+  # already have a result
 
-	expect_equal(res[[1]][1], 42L)
-	expect_equal(res[[2]][1], "Hello")
+  res <- dbFetch(q)
 
+  expect_equal(res[[1]][1], 42L)
+  expect_equal(res[[2]][1], "Hello")
 
-	# now bind again
-	dbBind(q, list(43, "Holla"))
 
-	res <- dbFetch(q)
+  # now bind again
+  dbBind(q, list(43, "Holla"))
 
-	expect_equal(res[[1]][1], 43L)
-	expect_equal(res[[2]][1], "Holla")
+  res <- dbFetch(q)
 
+  expect_equal(res[[1]][1], 43L)
+  expect_equal(res[[2]][1], "Holla")
 
-	dbClearResult(q)
 
-	dbDisconnect(con, shutdown=T)
+  dbClearResult(q)
 
+  dbDisconnect(con, shutdown = T)
 })
 
 test_that("various error cases for dbBind()", {
-	# testthat::skip("eek")
-	con <- dbConnect(duckdb::duckdb())
+  # testthat::skip("eek")
+  con <- dbConnect(duckdb::duckdb())
 
-	q <- dbSendQuery(con, "SELECT CAST (? AS INTEGER)")
+  q <- dbSendQuery(con, "SELECT CAST (? AS INTEGER)")
 
-	expect_error(dbFetch(q))
+  expect_error(dbFetch(q))
 
-	expect_error(dbBind(q, list()))
-	expect_error(dbBind(q, list(1, 2)))
-	expect_error(dbBind(q, list("asdf", "asdf")))
+  expect_error(dbBind(q, list()))
+  expect_error(dbBind(q, list(1, 2)))
+  expect_error(dbBind(q, list("asdf", "asdf")))
 
-	expect_error(dbBind(q))
+  expect_error(dbBind(q))
 
-	expect_error(dbBind(q, 1))
-	expect_error(dbBind(q, 1, 2))
-	expect_error(dbBind(q, "asdf"))
-	expect_error(dbBind(q, "asdf", "asdf"))
+  expect_error(dbBind(q, 1))
+  expect_error(dbBind(q, 1, 2))
+  expect_error(dbBind(q, "asdf"))
+  expect_error(dbBind(q, "asdf", "asdf"))
 
-	dbClearResult(q)
+  dbClearResult(q)
 
-	expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", 1, 2))
-	expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", "asdf"))
-	expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", "asdf", "asdf"))
-	expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)"))
-	expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", list()))
-	expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", list(1, 2)))
-	expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", list("asdf")))
-	expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", list("asdf", "asdf")))
+  expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", 1, 2))
+  expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", "asdf"))
+  expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", "asdf", "asdf"))
+  expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)"))
+  expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", list()))
+  expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", list(1, 2)))
+  expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", list("asdf")))
+  expect_error(dbGetQuery(con, "SELECT CAST (? AS INTEGER)", list("asdf", "asdf")))
 
-	q <- dbSendQuery(con, "SELECT CAST (42 AS INTEGER)")
+  q <- dbSendQuery(con, "SELECT CAST (42 AS INTEGER)")
 
-	res <- dbFetch(q)
-	expect_equal(res[[1]][1], 42L)
+  res <- dbFetch(q)
+  expect_equal(res[[1]][1], 42L)
 
-	expect_error(dbBind(q, list()))
-	expect_error(dbBind(q, list(1)))
-	expect_error(dbBind(q, list("asdf")))
+  expect_error(dbBind(q, list()))
+  expect_error(dbBind(q, list(1)))
+  expect_error(dbBind(q, list("asdf")))
 
-	expect_error(dbBind(q))
-	expect_error(dbBind(q, 1))
-	expect_error(dbBind(q, "asdf"))
+  expect_error(dbBind(q))
+  expect_error(dbBind(q, 1))
+  expect_error(dbBind(q, "asdf"))
 
-	dbClearResult(q)
+  dbClearResult(q)
 
-	expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", 1))
-	expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", 1, 2))
-	expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", "asdf"))
-	expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", "asdf", "asdf"))
-	expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", list(1)))
-	expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", list(1, 2)))
-	expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", list("asdf")))
-	expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", list("asdf", "asdf")))
+  expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", 1))
+  expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", 1, 2))
+  expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", "asdf"))
+  expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", "asdf", "asdf"))
+  expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", list(1)))
+  expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", list(1, 2)))
+  expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", list("asdf")))
+  expect_error(dbGetQuery(con, "SELECT CAST (42 AS INTEGER)", list("asdf", "asdf")))
 
 
-	dbDisconnect(con, shutdown=T)
+  dbDisconnect(con, shutdown = T)
 })
diff --git a/tools/rpkg/tests/testthat/test_parquet.R b/tools/rpkg/tests/testthat/test_parquet.R
index d212489bf385..275fd22d697d 100644
--- a/tools/rpkg/tests/testthat/test_parquet.R
+++ b/tools/rpkg/tests/testthat/test_parquet.R
@@ -2,7 +2,7 @@ library("testthat")
 library("DBI")
 
 test_that("parquet reader works on the notorious userdata1 file", {
-	con <- dbConnect(duckdb::duckdb())
-	res <- dbGetQuery(con, "SELECT * FROM parquet_scan('userdata1.parquet')")
-	dbDisconnect(con, shutdown=T)
-})
\ No newline at end of file
+  con <- dbConnect(duckdb::duckdb())
+  res <- dbGetQuery(con, "SELECT * FROM parquet_scan('userdata1.parquet')")
+  dbDisconnect(con, shutdown = T)
+})
diff --git a/tools/rpkg/tests/testthat/test_read.R b/tools/rpkg/tests/testthat/test_read.R
index 49b545abe1ca..8571b4c3be3f 100644
--- a/tools/rpkg/tests/testthat/test_read.R
+++ b/tools/rpkg/tests/testthat/test_read.R
@@ -2,107 +2,106 @@ library("testthat")
 library("DBI")
 
 test_that("read_csv_duckdb() works as expected", {
-	con <- dbConnect(duckdb::duckdb())
-	
-	tf <- tempfile()
-
-	# default case
-	write.csv(iris, tf, row.names = FALSE)
-	read_csv_duckdb(con, tf, "iris")
-	res <- dbReadTable(con, "iris")
-	res$Species <- as.factor(res$Species)
-	expect_true(identical(res, iris))
-
-	# table exists
-	read_csv_duckdb(con, tf, "iris")
-	count <- dbGetQuery(con, "SELECT COUNT(*) FROM iris")[1][1]
-	expect_true(identical(as.integer(count), as.integer(nrow(iris)*2)))
-	dbRemoveTable(con, "iris")
-
-
-	# different separator
-	write.table(iris, tf, row.names = FALSE, sep=" ")
-	read_csv_duckdb(con, tf, "iris", delim=" ")
-	res <- dbReadTable(con, "iris")
-	res$Species <- as.factor(res$Species)
-	expect_true(identical(res, iris))
-	dbRemoveTable(con, "iris")
-
-	write.table(iris, tf, row.names = FALSE, sep=" ")
-	read_csv_duckdb(con, tf, "iris", sep=" ")
-	res <- dbReadTable(con, "iris")
-	res$Species <- as.factor(res$Species)
-	expect_true(identical(res, iris))
-	dbRemoveTable(con, "iris")
-
-	# no header
-	write.table(iris, tf, row.names = FALSE, sep=",", col.names=FALSE)
-	read_csv_duckdb(con, tf, "iris", header=FALSE)
-	res <- dbReadTable(con, "iris")
-	names(res) <- names(iris)
-	res$Species <- as.factor(res$Species)
-	expect_true(identical(res, iris))
-	dbRemoveTable(con, "iris")
-
-	# lowercase header
-	write.csv(iris, tf, row.names = FALSE)
-	read_csv_duckdb(con, tf, "iris", lower.case.names=T)
-	res <- dbReadTable(con, "iris")
-	res$species <- as.factor(res$species)
-	iris_lc <- iris
-	names(iris_lc) <- tolower(names(iris))
-	expect_true(identical(res, iris_lc))
-	dbRemoveTable(con, "iris")
-
-	# nulls
-	iris_na <- iris
-	iris_na[[2]][42] <- NA
-
-	write.csv(iris_na, tf, row.names = FALSE, na="")
-	read_csv_duckdb(con, tf, "iris")
-	res <- dbReadTable(con, "iris")
-	res$Species <- as.factor(res$Species)
-	expect_true(identical(res, iris_na))
-	dbRemoveTable(con, "iris")
-
-
-	write.csv(iris_na, tf, row.names = FALSE, na="NULL")
-	read_csv_duckdb(con, tf, "iris", na.strings="NULL")
-	res <- dbReadTable(con, "iris")
-	res$Species <- as.factor(res$Species)
-	expect_true(identical(res, iris_na))
-	dbRemoveTable(con, "iris")
-
-
-	# strange table name
-	write.csv(iris, tf, row.names = FALSE)
-	read_csv_duckdb(con, tf, "ir Is")
-	res <- dbReadTable(con, "ir Is")
-	res$Species <- as.factor(res$Species)
-	expect_true(identical(res, iris))
-	dbRemoveTable(con, "ir Is")
-
-
-	# specified column names
-	colnames <- paste0("c", 1:5)
-	write.csv(iris, tf, row.names = FALSE)
-	read_csv_duckdb(con, tf, "iris", col.names=colnames)
-	res <- dbReadTable(con, "iris")
-	res$c5 <- as.factor(res$c5)
-	iris_c <- iris
-	names(iris_c) <- colnames
-	expect_true(identical(res, iris_c))
-	dbRemoveTable(con, "iris")
-
-
-	# multiple files
-	tf2 <- tempfile()
-	write.csv(iris, tf2, row.names = FALSE)
-	read_csv_duckdb(con, c(tf, tf2), "iris")
-	count <- dbGetQuery(con, "SELECT COUNT(*) FROM iris")[1][1]
-	expect_true(identical(as.integer(count), as.integer(nrow(iris)*2)))
-	dbRemoveTable(con, "iris")
-
-	dbDisconnect(con, shutdown=T)
-
+  con <- dbConnect(duckdb::duckdb())
+
+  tf <- tempfile()
+
+  # default case
+  write.csv(iris, tf, row.names = FALSE)
+  read_csv_duckdb(con, tf, "iris")
+  res <- dbReadTable(con, "iris")
+  res$Species <- as.factor(res$Species)
+  expect_true(identical(res, iris))
+
+  # table exists
+  read_csv_duckdb(con, tf, "iris")
+  count <- dbGetQuery(con, "SELECT COUNT(*) FROM iris")[1][1]
+  expect_true(identical(as.integer(count), as.integer(nrow(iris) * 2)))
+  dbRemoveTable(con, "iris")
+
+
+  # different separator
+  write.table(iris, tf, row.names = FALSE, sep = " ")
+  read_csv_duckdb(con, tf, "iris", delim = " ")
+  res <- dbReadTable(con, "iris")
+  res$Species <- as.factor(res$Species)
+  expect_true(identical(res, iris))
+  dbRemoveTable(con, "iris")
+
+  write.table(iris, tf, row.names = FALSE, sep = " ")
+  read_csv_duckdb(con, tf, "iris", sep = " ")
+  res <- dbReadTable(con, "iris")
+  res$Species <- as.factor(res$Species)
+  expect_true(identical(res, iris))
+  dbRemoveTable(con, "iris")
+
+  # no header
+  write.table(iris, tf, row.names = FALSE, sep = ",", col.names = FALSE)
+  read_csv_duckdb(con, tf, "iris", header = FALSE)
+  res <- dbReadTable(con, "iris")
+  names(res) <- names(iris)
+  res$Species <- as.factor(res$Species)
+  expect_true(identical(res, iris))
+  dbRemoveTable(con, "iris")
+
+  # lowercase header
+  write.csv(iris, tf, row.names = FALSE)
+  read_csv_duckdb(con, tf, "iris", lower.case.names = T)
+  res <- dbReadTable(con, "iris")
+  res$species <- as.factor(res$species)
+  iris_lc <- iris
+  names(iris_lc) <- tolower(names(iris))
+  expect_true(identical(res, iris_lc))
+  dbRemoveTable(con, "iris")
+
+  # nulls
+  iris_na <- iris
+  iris_na[[2]][42] <- NA
+
+  write.csv(iris_na, tf, row.names = FALSE, na = "")
+  read_csv_duckdb(con, tf, "iris")
+  res <- dbReadTable(con, "iris")
+  res$Species <- as.factor(res$Species)
+  expect_true(identical(res, iris_na))
+  dbRemoveTable(con, "iris")
+
+
+  write.csv(iris_na, tf, row.names = FALSE, na = "NULL")
+  read_csv_duckdb(con, tf, "iris", na.strings = "NULL")
+  res <- dbReadTable(con, "iris")
+  res$Species <- as.factor(res$Species)
+  expect_true(identical(res, iris_na))
+  dbRemoveTable(con, "iris")
+
+
+  # strange table name
+  write.csv(iris, tf, row.names = FALSE)
+  read_csv_duckdb(con, tf, "ir Is")
+  res <- dbReadTable(con, "ir Is")
+  res$Species <- as.factor(res$Species)
+  expect_true(identical(res, iris))
+  dbRemoveTable(con, "ir Is")
+
+
+  # specified column names
+  colnames <- paste0("c", 1:5)
+  write.csv(iris, tf, row.names = FALSE)
+  read_csv_duckdb(con, tf, "iris", col.names = colnames)
+  res <- dbReadTable(con, "iris")
+  res$c5 <- as.factor(res$c5)
+  iris_c <- iris
+  names(iris_c) <- colnames
+  expect_true(identical(res, iris_c))
+  dbRemoveTable(con, "iris")
+
+
+  # multiple files
+  tf2 <- tempfile()
+  write.csv(iris, tf2, row.names = FALSE)
+  read_csv_duckdb(con, c(tf, tf2), "iris")
+  count <- dbGetQuery(con, "SELECT COUNT(*) FROM iris")[1][1]
+  expect_true(identical(as.integer(count), as.integer(nrow(iris) * 2)))
+  dbRemoveTable(con, "iris")
+
+  dbDisconnect(con, shutdown = T)
 })
diff --git a/tools/rpkg/tests/testthat/test_readonly.R b/tools/rpkg/tests/testthat/test_readonly.R
index 5df07039f1b1..624e6bcf5fbc 100644
--- a/tools/rpkg/tests/testthat/test_readonly.R
+++ b/tools/rpkg/tests/testthat/test_readonly.R
@@ -1,57 +1,57 @@
 library(testthat)
 
 test_that("read_only flag and shutdown works as expected", {
-	library("DBI")
+  library("DBI")
 
-	dbdir <- tempfile()
+  dbdir <- tempfile()
 
-	# 1st: create a db and write some tables
+  # 1st: create a db and write some tables
 
-	callr::r(function(dbdir) {
-		library("DBI")
-		con <- dbConnect(duckdb::duckdb(), dbdir, read_only=FALSE) # FALSE is the default
-		print(con)
-		res <- dbWriteTable(con, "iris", iris)
-		dbDisconnect(con)
-		duckdb::duckdb_shutdown(con@driver)
-	}, args = list(dbdir))
+  callr::r(function(dbdir) {
+    library("DBI")
+    con <- dbConnect(duckdb::duckdb(), dbdir, read_only = FALSE) # FALSE is the default
+    print(con)
+    res <- dbWriteTable(con, "iris", iris)
+    dbDisconnect(con)
+    duckdb::duckdb_shutdown(con@driver)
+  }, args = list(dbdir))
 
 
-	# 2nd: start two parallel read-only references
-	drv <- duckdb::duckdb(dbdir, read_only=TRUE)
-	con <- dbConnect(drv)
+  # 2nd: start two parallel read-only references
+  drv <- duckdb::duckdb(dbdir, read_only = TRUE)
+  con <- dbConnect(drv)
 
-	res <- dbReadTable(con, "iris")
+  res <- dbReadTable(con, "iris")
 
 
-	# can have another conn on this drv
-	con2 <- dbConnect(drv)
-	res <- dbReadTable(con2, "iris")
+  # can have another conn on this drv
+  con2 <- dbConnect(drv)
+  res <- dbReadTable(con2, "iris")
 
-	# con is still alive
-	callr::r(function(dbdir) {
-		library("DBI")
-		con <- dbConnect(duckdb::duckdb(), dbdir, read_only=TRUE)
-		res <- dbReadTable(con, "iris")
-		dbDisconnect(con, shutdown=TRUE)
-	}, args = list(dbdir))
+  # con is still alive
+  callr::r(function(dbdir) {
+    library("DBI")
+    con <- dbConnect(duckdb::duckdb(), dbdir, read_only = TRUE)
+    res <- dbReadTable(con, "iris")
+    dbDisconnect(con, shutdown = TRUE)
+  }, args = list(dbdir))
 
-	# shut down one of them again
-	res <- dbReadTable(con, "iris")
+  # shut down one of them again
+  res <- dbReadTable(con, "iris")
 
-	dbDisconnect(con)
-	dbDisconnect(con2, shutdown=TRUE)
-	duckdb::duckdb_shutdown(con@driver)
+  dbDisconnect(con)
+  dbDisconnect(con2, shutdown = TRUE)
+  duckdb::duckdb_shutdown(con@driver)
 
 
-	# now we can get write access again
-	# TODO shutdown
-	callr::r(function(dbdir) {
-		library("DBI")
-		con <- dbConnect(duckdb::duckdb(), dbdir, read_only=FALSE) # FALSE is the default
-		res <- dbWriteTable(con, "iris2", iris)
-		dbDisconnect(con)
-	}, args = list(dbdir))
+  # now we can get write access again
+  # TODO shutdown
+  callr::r(function(dbdir) {
+    library("DBI")
+    con <- dbConnect(duckdb::duckdb(), dbdir, read_only = FALSE) # FALSE is the default
+    res <- dbWriteTable(con, "iris2", iris)
+    dbDisconnect(con)
+  }, args = list(dbdir))
 
-	expect_true(T)
+  expect_true(T)
 })
diff --git a/tools/rpkg/tests/testthat/test_register.R b/tools/rpkg/tests/testthat/test_register.R
index 003f412fd5f7..5de72c3d48d5 100644
--- a/tools/rpkg/tests/testthat/test_register.R
+++ b/tools/rpkg/tests/testthat/test_register.R
@@ -3,56 +3,55 @@ library("DBI")
 
 
 test_that("duckdb_register() works", {
-	con <- dbConnect(duckdb::duckdb())
-	
-	# most basic case
-	duckdb::duckdb_register(con, "my_df1", iris)
-	res <- dbReadTable(con, "my_df1")
-	res$Species <- as.factor(res$Species)
-	expect_true(identical(res, iris))
-	duckdb::duckdb_unregister(con, "my_df1")
-
-	duckdb::duckdb_register(con, "my_df2", mtcars)
-	res <- dbReadTable(con, "my_df2")
-	row.names(res) <- row.names(mtcars)
-	expect_true(identical(res, mtcars))
-	duckdb::duckdb_unregister(con, "my_df2")
-
-	duckdb::duckdb_register(con, "my_df1", mtcars)
-	res <- dbReadTable(con, "my_df1")
-	row.names(res) <- row.names(mtcars)
-	expect_true(identical(res, mtcars))
-
- 	# do not need unregister, can simply overwrite
-	duckdb::duckdb_register(con, "my_df1", iris)
-	res <- dbReadTable(con, "my_df1")
-	res$Species <- as.factor(res$Species)
-	expect_true(identical(res, iris))
-
-	duckdb::duckdb_unregister(con, "my_df1")
-	duckdb::duckdb_unregister(con, "my_df2")
-	duckdb::duckdb_unregister(con, "xxx")
-
-	# this needs to be empty now
-	expect_true(length(attributes(con@conn_ref)) == 0)
-
-	dbDisconnect(con, shutdown=T)
+  con <- dbConnect(duckdb::duckdb())
+
+  # most basic case
+  duckdb::duckdb_register(con, "my_df1", iris)
+  res <- dbReadTable(con, "my_df1")
+  res$Species <- as.factor(res$Species)
+  expect_true(identical(res, iris))
+  duckdb::duckdb_unregister(con, "my_df1")
+
+  duckdb::duckdb_register(con, "my_df2", mtcars)
+  res <- dbReadTable(con, "my_df2")
+  row.names(res) <- row.names(mtcars)
+  expect_true(identical(res, mtcars))
+  duckdb::duckdb_unregister(con, "my_df2")
+
+  duckdb::duckdb_register(con, "my_df1", mtcars)
+  res <- dbReadTable(con, "my_df1")
+  row.names(res) <- row.names(mtcars)
+  expect_true(identical(res, mtcars))
+
+  # do not need unregister, can simply overwrite
+  duckdb::duckdb_register(con, "my_df1", iris)
+  res <- dbReadTable(con, "my_df1")
+  res$Species <- as.factor(res$Species)
+  expect_true(identical(res, iris))
+
+  duckdb::duckdb_unregister(con, "my_df1")
+  duckdb::duckdb_unregister(con, "my_df2")
+  duckdb::duckdb_unregister(con, "xxx")
+
+  # this needs to be empty now
+  expect_true(length(attributes(con@conn_ref)) == 0)
+
+  dbDisconnect(con, shutdown = T)
 })
 
 
 test_that("various error cases for duckdb_register()", {
-	con <- dbConnect(duckdb::duckdb())
+  con <- dbConnect(duckdb::duckdb())
 
-	duckdb::duckdb_register(con, "my_df1", iris)
-	duckdb::duckdb_unregister(con, "my_df1")
-	expect_error(dbReadTable(con, "my_df1"))
+  duckdb::duckdb_register(con, "my_df1", iris)
+  duckdb::duckdb_unregister(con, "my_df1")
+  expect_error(dbReadTable(con, "my_df1"))
 
-	expect_error(duckdb::duckdb_register(1, "my_df1", iris))
-	expect_error(duckdb::duckdb_register(con, "", iris))
-	expect_error(duckdb::duckdb_unregister(1, "my_df1"))
-	expect_error(duckdb::duckdb_unregister(con, ""))
-	dbDisconnect(con, shutdown=T)
-
-	expect_error(duckdb::duckdb_unregister(con, "my_df1"))
+  expect_error(duckdb::duckdb_register(1, "my_df1", iris))
+  expect_error(duckdb::duckdb_register(con, "", iris))
+  expect_error(duckdb::duckdb_unregister(1, "my_df1"))
+  expect_error(duckdb::duckdb_unregister(con, ""))
+  dbDisconnect(con, shutdown = T)
 
+  expect_error(duckdb::duckdb_unregister(con, "my_df1"))
 })
