diff --git a/tools/rpkg/.gitignore b/tools/rpkg/.gitignore
index b748dbbb1297..83982f17b973 100644
--- a/tools/rpkg/.gitignore
+++ b/tools/rpkg/.gitignore
@@ -3,3 +3,102 @@ src/duckdb
 *.tgz
 src/Makevars
 /src/
+
+# Created by https://www.toptal.com/developers/gitignore/api/r
+# Edit at https://www.toptal.com/developers/gitignore?templates=r
+### R ###
+# History files
+.Rhistory
+.Rapp.history
+# Session Data files
+.RData
+# User-specific files
+.Ruserdata
+# Example code in package build process
+*-Ex.R
+# Output files from R CMD build
+/*.tar.gz
+# Output files from R CMD check
+/*.Rcheck/
+# RStudio files
+.Rproj.user/
+# produced vignettes
+vignettes/*.html
+vignettes/*.pdf
+# OAuth2 token, see https://github.com/hadley/httr/releases/tag/v0.3
+.httr-oauth
+# knitr and R markdown default cache directories
+*_cache/
+/cache/
+# Temporary files created by R markdown
+*.utf8.md
+*.knit.md
+# R Environment Variables
+.Renviron
+### R.Bookdown Stack ###
+# R package: bookdown caching files
+/*_files/
+# End of https://www.toptal.com/developers/gitignore/api/r
+docs/
+# Created by https://www.toptal.com/developers/gitignore/api/visualstudiocode
+# Edit at https://www.toptal.com/developers/gitignore?templates=visualstudiocode
+### VisualStudioCode ###
+.vscode/*
+!.vscode/settings.json
+!.vscode/tasks.json
+!.vscode/launch.json
+!.vscode/extensions.json
+*.code-workspace
+### VisualStudioCode Patch ###
+# Ignore all local history of files
+.history
+# End of https://www.toptal.com/developers/gitignore/api/visualstudiocode
+# Created by https://www.toptal.com/developers/gitignore/api/macos
+# Edit at https://www.toptal.com/developers/gitignore?templates=macos
+### macOS ###
+# General
+.DS_Store
+.AppleDouble
+.LSOverride
+# Icon must end with two \r
+Icon
+# Thumbnails
+._*
+# Files that might appear in the root of a volume
+.DocumentRevisions-V100
+.fseventsd
+.Spotlight-V100
+.TemporaryItems
+.Trashes
+.VolumeIcon.icns
+.com.apple.timemachine.donotpresent
+# Directories potentially created on remote AFP share
+.AppleDB
+.AppleDesktop
+Network Trash Folder
+Temporary Items
+.apdisk
+# End of https://www.toptal.com/developers/gitignore/api/macos
+# Created by https://www.toptal.com/developers/gitignore/api/windows
+# Edit at https://www.toptal.com/developers/gitignore?templates=windows
+### Windows ###
+# Windows thumbnail cache files
+Thumbs.db
+Thumbs.db:encryptable
+ehthumbs.db
+ehthumbs_vista.db
+# Dump file
+*.stackdump
+# Folder config file
+[Dd]esktop.ini
+# Recycle Bin used on file shares
+$RECYCLE.BIN/
+# Windows Installer files
+*.cab
+*.msi
+*.msix
+*.msm
+*.msp
+# Windows shortcuts
+*.lnk
+# End of https://www.toptal.com/developers/gitignore/api/windows
diff --git a/tools/rpkg/DESCRIPTION b/tools/rpkg/DESCRIPTION
index 70a4ebf2cf41..0a5ce45f01ac 100644
--- a/tools/rpkg/DESCRIPTION
+++ b/tools/rpkg/DESCRIPTION
@@ -1,28 +1,44 @@
 Package: duckdb
 Title: DBI Package for the DuckDB Database Management System
 Version: 0.2.0
-Authors@R: c(person("Hannes", "M\u00fchleisen", role = c("aut", "cre"), email = "hannes@cwi.nl", comment = c(ORCID = "0000-0001-8552-0029")), person("Mark", "Raasveldt", role = c("aut"), email = "mark.raasveldt@cwi.nl", comment = c(ORCID = "0000-0001-5005-6844")), person(given = "DuckDB Contributors", role = "aut"))
-Description: DuckDB is an embedded analytical data management system with SQL support. This package includes all of DuckDB as well as R DBI & dplyr connectors.
-Depends: 
-    R (>= 3.5.0),
-    DBI
+Authors@R: 
+    c(person(given = "Hannes",
+             family = "MÃ¼hleisen",
+             role = c("aut", "cre"),
+             email = "hannes@cwi.nl",
+             comment = c(ORCID = "0000-0001-8552-0029")),
+      person(given = "Mark",
+             family = "Raasveldt",
+             role = "aut",
+             email = "mark.raasveldt@cwi.nl",
+             comment = c(ORCID = "0000-0001-5005-6844")),
+      person(given = "DuckDB Contributors",
+             role = "aut"))
+Description: DuckDB is an embedded analytical data management
+    system with SQL support. This package includes all of DuckDB as well
+    as R DBI & dplyr connectors.
 License: MPL
-LazyData: true
-Encoding: UTF-8
+URL: https://www.duckdb.org, https://github.com/cwida/duckdb
+BugReports: https://github.com/cwida/duckdb/issues
+Depends: 
+    DBI,
+    R (>= 3.5.0)
 Imports:
     dbplyr,
     methods,
     testthat,
     utils
 Suggests: 
-    DBItest, 
-    callr
-URL: https://www.duckdb.org, https://github.com/cwida/duckdb
-BugReports: https://github.com/cwida/duckdb/issues
+    callr,
+    DBItest,
+    nycflights13
+Encoding: UTF-8
+LazyData: true
+RoxygenNote: 7.1.0.9000
+SystemRequirements: C++11
 Collate: 
     'duckdb.R'
     'Driver.R'
     'Connection.R'
     'Result.R'
-RoxygenNote: 6.1.1
-SystemRequirements: C++11
+    'duckdb-package.R'
diff --git a/tools/rpkg/NAMESPACE b/tools/rpkg/NAMESPACE
index d3ec3d5cc06e..0f17aa9c0461 100644
--- a/tools/rpkg/NAMESPACE
+++ b/tools/rpkg/NAMESPACE
@@ -1,13 +1,11 @@
 # Generated by roxygen2: do not edit by hand
 
 export(duckdb)
-export(duckdb_shutdown)
 export(duckdb_register)
+export(duckdb_shutdown)
 export(duckdb_unregister)
-export(src_duckdb)
 export(read_csv_duckdb)
-export(duckdb.read.csv)
-
+export(src_duckdb)
 exportClasses(duckdb_connection)
 exportClasses(duckdb_driver)
 exportClasses(duckdb_result)
@@ -40,4 +38,4 @@ importFrom(DBI,dbConnect)
 importFrom(dbplyr,src_dbi)
 importFrom(testthat,skip)
 importFrom(utils,head)
-useDynLib(duckdb , .registration = TRUE)
+useDynLib(duckdb, .registration = TRUE)
diff --git a/tools/rpkg/R/Connection.R b/tools/rpkg/R/Connection.R
index b9f5b5ac0b08..24f52d676f5b 100644
--- a/tools/rpkg/R/Connection.R
+++ b/tools/rpkg/R/Connection.R
@@ -12,12 +12,16 @@ duckdb_connection <- function(duckdb_driver, debug) {
   )
 }
 
+#' @rdname DBI
+#' @export
 duckdb_register <- function(conn, name, df) {
   stopifnot(dbIsValid(conn))
   .Call(duckdb_register_R, conn@conn_ref, as.character(name), as.data.frame(df))
   invisible(TRUE)
 }
 
+#' @rdname DBI
+#' @export
 duckdb_unregister <- function(conn, name) {
   stopifnot(dbIsValid(conn))
   .Call(duckdb_unregister_R, conn@conn_ref, as.character(name))
@@ -30,83 +34,96 @@ duckdb_unregister <- function(conn, name) {
 setClass(
   "duckdb_connection",
   contains = "DBIConnection",
-  slots = list(dbdir= "character", conn_ref = "externalptr", driver = "duckdb_driver", debug="logical")
+  slots = list(dbdir = "character", conn_ref = "externalptr", driver = "duckdb_driver", debug = "logical")
 )
 
 #' @rdname DBI
 #' @inheritParams methods::show
 #' @export
-setMethod("show", "duckdb_connection",
-          function(object) {
-            cat(sprintf("<duckdb_connection %s driver=%s>
", extptr_str(object@conn_ref), drv_to_string(object@driver)))
-          })
+setMethod(
+  "show", "duckdb_connection",
+  function(object) {
+    cat(sprintf("<duckdb_connection %s driver=%s>
", extptr_str(object@conn_ref), drv_to_string(object@driver)))
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbIsValid
 #' @export
-setMethod("dbIsValid", "duckdb_connection",
-          function(dbObj, ...) {
-            valid <- FALSE
-            tryCatch ({
-              dbGetQuery(dbObj, SQL("SELECT 1"))
-              valid <- TRUE
-            }, error = function(c) {
-            })
-            valid
-          })
+setMethod(
+  "dbIsValid", "duckdb_connection",
+  function(dbObj, ...) {
+    valid <- FALSE
+    tryCatch(
+      {
+        dbGetQuery(dbObj, SQL("SELECT 1"))
+        valid <- TRUE
+      },
+      error = function(c) {
+      }
+    )
+    valid
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbDisconnect
 #' @export
-setMethod("dbDisconnect", "duckdb_connection",
-          function(conn, ..., shutdown=FALSE) {
-            if (!dbIsValid(conn)) {
-              warning("Connection already closed.", call. = FALSE)
-            }
-            .Call(duckdb_disconnect_R, conn@conn_ref)
-            if (shutdown) {
-              duckdb_shutdown(conn@driver)
-            }
-
-            invisible(TRUE)
-          })
+setMethod(
+  "dbDisconnect", "duckdb_connection",
+  function(conn, ..., shutdown = FALSE) {
+    if (!dbIsValid(conn)) {
+      warning("Connection already closed.", call. = FALSE)
+    }
+    .Call(duckdb_disconnect_R, conn@conn_ref)
+    if (shutdown) {
+      duckdb_shutdown(conn@driver)
+    }
+
+    invisible(TRUE)
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbSendQuery
 #' @export
-setMethod("dbSendQuery", c("duckdb_connection", "character"),
-          function(conn, statement, ..., immediate=FALSE) {
-            if (conn@debug) {
-              cat("Q ", statement, "
")
-            }
-		        statement <- enc2utf8(statement)
-            stmt_lst <- .Call(duckdb_prepare_R, conn@conn_ref, statement)
-
-            res <- duckdb_result(
-              connection = conn,
-              stmt_lst = stmt_lst
-            )
-            params <- list(...)
-            if (length(params) == 1 && class(params[[1]])[[1]] == "list") {
-              params <- params[[1]]
-            }
-            if (length(params) > 0) {
-              dbBind(res, params)
-            }
-            return(res)
-          })
+setMethod(
+  "dbSendQuery", c("duckdb_connection", "character"),
+  function(conn, statement, ..., immediate = FALSE) {
+    if (conn@debug) {
+      cat("Q ", statement, "
")
+    }
+    statement <- enc2utf8(statement)
+    stmt_lst <- .Call(duckdb_prepare_R, conn@conn_ref, statement)
+
+    res <- duckdb_result(
+      connection = conn,
+      stmt_lst = stmt_lst
+    )
+    params <- list(...)
+    if (length(params) == 1 && class(params[[1]])[[1]] == "list") {
+      params <- params[[1]]
+    }
+    if (length(params) > 0) {
+      dbBind(res, params)
+    }
+    return(res)
+  }
+)
 
 
 #' @rdname DBI
 #' @inheritParams DBI::dbDataType
 #' @export
-setMethod("dbDataType", "duckdb_connection",
-          function(dbObj, obj, ...) {
-            dbDataType(dbObj@driver, obj, ...)
-          })
+setMethod(
+  "dbDataType", "duckdb_connection",
+  function(dbObj, obj, ...) {
+    dbDataType(dbObj@driver, obj, ...)
+  }
+)
 
 duckdb_random_string <- function(x) {
-	paste(sample(letters, 10, replace = TRUE), collapse="")
+  paste(sample(letters, 10, replace = TRUE), collapse = "")
 }
 
 #' @rdname DBI
@@ -116,254 +133,284 @@ duckdb_random_string <- function(x) {
 #' @param append Allow appending to the destination table. Cannot be
 #'   `TRUE` if `overwrite` is also `TRUE`.
 #' @export
-setMethod("dbWriteTable", c("duckdb_connection", "character", "data.frame"),
-          function(conn,
-                   name,
-                   value,
-                   row.names = FALSE,
-                   overwrite = FALSE,
-                   append = FALSE,
-                   field.types = NULL,
-                   temporary = FALSE,
-                   ...) {
-            check_flag(overwrite)
-            check_flag(append)
-            check_flag(temporary)
-            
-            # TODO: start a transaction if one is not already running
-            
-            
-            if (overwrite && append) {
-              stop("Setting both overwrite and append makes no sense")
-            }
-            
-            # oof
-            if (!is.null(field.types) &&
-                (
-                  !is.character(field.types) ||
-                  any(is.na(names(field.types))) ||
-                  length(unique(names(field.types))) != length(names(field.types)) ||
-                  append
-                )) {
-              stop("invalid field.types argument")
-            }
-            value <- as.data.frame(value)
-            if (!is.data.frame(value)) {
-              stop("need a data frame as parameter")
-            }
-            
-            # use Kirill's magic, convert rownames to additional column
-            value <- sqlRownamesToColumn(value, row.names)
-            
-            if (dbExistsTable(conn, name)) {
-              if (overwrite) {
-                dbRemoveTable(conn, name)
-              }
-              if (!overwrite && !append) {
-                stop(
-                  "Table ",
-                  name,
-                  " already exists. Set overwrite=TRUE if you want
+setMethod(
+  "dbWriteTable", c("duckdb_connection", "character", "data.frame"),
+  function(conn,
+           name,
+           value,
+           row.names = FALSE,
+           overwrite = FALSE,
+           append = FALSE,
+           field.types = NULL,
+           temporary = FALSE,
+           ...) {
+    check_flag(overwrite)
+    check_flag(append)
+    check_flag(temporary)
+
+    # TODO: start a transaction if one is not already running
+
+
+    if (overwrite && append) {
+      stop("Setting both overwrite and append makes no sense")
+    }
+
+    # oof
+    if (!is.null(field.types) &&
+      (
+        !is.character(field.types) ||
+          any(is.na(names(field.types))) ||
+          length(unique(names(field.types))) != length(names(field.types)) ||
+          append
+      )) {
+      stop("invalid field.types argument")
+    }
+    value <- as.data.frame(value)
+    if (!is.data.frame(value)) {
+      stop("need a data frame as parameter")
+    }
+
+    # use Kirill's magic, convert rownames to additional column
+    value <- sqlRownamesToColumn(value, row.names)
+
+    if (dbExistsTable(conn, name)) {
+      if (overwrite) {
+        dbRemoveTable(conn, name)
+      }
+      if (!overwrite && !append) {
+        stop(
+          "Table ",
+          name,
+          " already exists. Set overwrite=TRUE if you want
                   to remove the existing table. Set append=TRUE if you would like to add the new data to the
                   existing table."
-                )
-              }
-              if (append && any(names(value) != dbListFields(conn, name))) {
-                stop("Column name mismatch for append")
-              }
-              }
-            table_name <- dbQuoteIdentifier(conn, name)
-
-            if (!dbExistsTable(conn, name)) {
-              column_names <- dbQuoteIdentifier(conn, names(value))
-              column_types <-
-                vapply(value, dbDataType, dbObj = conn, FUN.VALUE = "character")
-              
-              if (!is.null(field.types)) {
-                mapped_column_types <- field.types[names(value)]
-                if (any(is.na(mapped_column_types)) ||
-                    length(mapped_column_types) != length(names(value))) {
-                  stop("Column name/type mismatch")
-                }
-                column_types <- mapped_column_types
-              }
-
-              temp_str <- ""
-              if (temporary) temp_str <- "TEMPORARY"
-              
-              schema_str <- paste(column_names, column_types, collapse = ", ")
-              dbExecute(conn, SQL(sprintf(
-                "CREATE %s TABLE %s (%s)", temp_str, table_name, schema_str
-              )))
-            }
-			
-			if (length(value[[1]])) {
-				classes <- unlist(lapply(value, function(v){
-				  class(v)[[1]]
-				}))
-				for (c in names(classes[classes=="character"])) {
-				  value[[c]] <- enc2utf8(value[[c]])
-				}
-				for (c in names(classes[classes=="factor"])) {
-				  levels(value[[c]]) <- enc2utf8(levels(value[[c]]))
-				}
-			}
-			view_name <- sprintf("_duckdb_append_view_%s", duckdb_random_string())
-            on.exit(duckdb_unregister(conn, view_name))
-            duckdb_register(conn, view_name, value)
-            dbExecute(conn, sprintf("INSERT INTO %s SELECT * FROM %s", table_name, view_name))
-
-            invisible(TRUE)
-          })
+        )
+      }
+      if (append && any(names(value) != dbListFields(conn, name))) {
+        stop("Column name mismatch for append")
+      }
+    }
+    table_name <- dbQuoteIdentifier(conn, name)
+
+    if (!dbExistsTable(conn, name)) {
+      column_names <- dbQuoteIdentifier(conn, names(value))
+      column_types <-
+        vapply(value, dbDataType, dbObj = conn, FUN.VALUE = "character")
+
+      if (!is.null(field.types)) {
+        mapped_column_types <- field.types[names(value)]
+        if (any(is.na(mapped_column_types)) ||
+          length(mapped_column_types) != length(names(value))) {
+          stop("Column name/type mismatch")
+        }
+        column_types <- mapped_column_types
+      }
+
+      temp_str <- ""
+      if (temporary) temp_str <- "TEMPORARY"
+
+      schema_str <- paste(column_names, column_types, collapse = ", ")
+      dbExecute(conn, SQL(sprintf(
+        "CREATE %s TABLE %s (%s)", temp_str, table_name, schema_str
+      )))
+    }
+
+    if (length(value[[1]])) {
+      classes <- unlist(lapply(value, function(v) {
+        class(v)[[1]]
+      }))
+      for (c in names(classes[classes == "character"])) {
+        value[[c]] <- enc2utf8(value[[c]])
+      }
+      for (c in names(classes[classes == "factor"])) {
+        levels(value[[c]]) <- enc2utf8(levels(value[[c]]))
+      }
+    }
+    view_name <- sprintf("_duckdb_append_view_%s", duckdb_random_string())
+    on.exit(duckdb_unregister(conn, view_name))
+    duckdb_register(conn, view_name, value)
+    dbExecute(conn, sprintf("INSERT INTO %s SELECT * FROM %s", table_name, view_name))
+
+    invisible(TRUE)
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbListTables
 #' @export
-setMethod("dbListTables", "duckdb_connection",
-          function(conn, ...) {
-            dbGetQuery(conn,
-                       SQL(
-                         "SELECT name FROM sqlite_master() WHERE type='table' ORDER BY name"
-                       ))[[1]]
-          })
+setMethod(
+  "dbListTables", "duckdb_connection",
+  function(conn, ...) {
+    dbGetQuery(
+      conn,
+      SQL(
+        "SELECT name FROM sqlite_master() WHERE type='table' ORDER BY name"
+      )
+    )[[1]]
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbExistsTable
 #' @export
-setMethod("dbExistsTable", c("duckdb_connection", "character"),
-          function(conn, name, ...) {
-            if (!dbIsValid(conn)) {
-              stop("Invalid connection")
-            }
-            if (length(name) != 1) {
-              stop("Can only have a single name argument")
-            }
-            exists <- FALSE
-            tryCatch ({
-              dbGetQuery(conn,
-                         sqlInterpolate(
-                           conn,
-                           "SELECT * FROM ? WHERE FALSE",
-                           dbQuoteIdentifier(conn, name)
-                         ))
-              exists <- TRUE
-            }, error = function(c) {
-            })
-            exists
-          })
+setMethod(
+  "dbExistsTable", c("duckdb_connection", "character"),
+  function(conn, name, ...) {
+    if (!dbIsValid(conn)) {
+      stop("Invalid connection")
+    }
+    if (length(name) != 1) {
+      stop("Can only have a single name argument")
+    }
+    exists <- FALSE
+    tryCatch(
+      {
+        dbGetQuery(
+          conn,
+          sqlInterpolate(
+            conn,
+            "SELECT * FROM ? WHERE FALSE",
+            dbQuoteIdentifier(conn, name)
+          )
+        )
+        exists <- TRUE
+      },
+      error = function(c) {
+      }
+    )
+    exists
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbListFields
 #' @export
-setMethod("dbListFields", c("duckdb_connection", "character"),
-          function(conn, name, ...) {
-            names(dbGetQuery(
-              conn,
-              sqlInterpolate(
-                conn,
-                "SELECT * FROM ? WHERE FALSE",
-                dbQuoteIdentifier(conn, name)
-              )
-            ))
-          })
+setMethod(
+  "dbListFields", c("duckdb_connection", "character"),
+  function(conn, name, ...) {
+    names(dbGetQuery(
+      conn,
+      sqlInterpolate(
+        conn,
+        "SELECT * FROM ? WHERE FALSE",
+        dbQuoteIdentifier(conn, name)
+      )
+    ))
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbRemoveTable
 #' @export
-setMethod("dbRemoveTable", c("duckdb_connection", "character"),
-          function(conn, name, ...) {
-            dbExecute(conn,
-                      sqlInterpolate(conn, "DROP TABLE ?", dbQuoteIdentifier(conn, name)))
-            invisible(TRUE)
-          })
+setMethod(
+  "dbRemoveTable", c("duckdb_connection", "character"),
+  function(conn, name, ...) {
+    dbExecute(
+      conn,
+      sqlInterpolate(conn, "DROP TABLE ?", dbQuoteIdentifier(conn, name))
+    )
+    invisible(TRUE)
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbGetInfo
 #' @export
-setMethod("dbGetInfo", "duckdb_connection",
-          function(dbObj, ...) {
-            list(
-              dbname = dbObj@dbdir,
-              db.version = NA,
-              username = NA,
-              host = NA,
-              port = NA
-            )
-          })
+setMethod(
+  "dbGetInfo", "duckdb_connection",
+  function(dbObj, ...) {
+    list(
+      dbname = dbObj@dbdir,
+      db.version = NA,
+      username = NA,
+      host = NA,
+      port = NA
+    )
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbBegin
 #' @export
-setMethod("dbBegin", "duckdb_connection",
-          function(conn, ...) {
-            dbExecute(conn, SQL("BEGIN TRANSACTION"))
-            invisible(TRUE)
-          })
+setMethod(
+  "dbBegin", "duckdb_connection",
+  function(conn, ...) {
+    dbExecute(conn, SQL("BEGIN TRANSACTION"))
+    invisible(TRUE)
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbCommit
 #' @export
-setMethod("dbCommit", "duckdb_connection",
-          function(conn, ...) {
-            dbExecute(conn, SQL("COMMIT"))
-            invisible(TRUE)
-          })
+setMethod(
+  "dbCommit", "duckdb_connection",
+  function(conn, ...) {
+    dbExecute(conn, SQL("COMMIT"))
+    invisible(TRUE)
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbRollback
 #' @export
-setMethod("dbRollback", "duckdb_connection",
-          function(conn, ...) {
-            dbExecute(conn, SQL("ROLLBACK"))
-            invisible(TRUE)
-          })
+setMethod(
+  "dbRollback", "duckdb_connection",
+  function(conn, ...) {
+    dbExecute(conn, SQL("ROLLBACK"))
+    invisible(TRUE)
+  }
+)
 
+#' @rdname DBI
+#' @export
+read_csv_duckdb <- duckdb.read.csv <- function(conn, files, tablename, header = TRUE, na.strings = "", nrow.check = 500,
+                                               delim = ",", quote = "\"", col.names = NULL, lower.case.names = FALSE, sep = delim, transaction = TRUE, ...) {
 
-read_csv_duckdb <- duckdb.read.csv <- function(conn, files, tablename, header=TRUE, na.strings="", nrow.check=500, 
-                                               delim=",", quote="\"", col.names=NULL, lower.case.names=FALSE, sep=delim, transaction=TRUE, ...){
-  
-  if (length(na.strings)>1) stop("na.strings must be of length 1")
+  if (length(na.strings) > 1) stop("na.strings must be of length 1")
   if (!missing(sep)) delim <- sep
 
-  headers <- lapply(files, utils::read.csv, sep=delim, na.strings=na.strings, quote=quote, nrows=nrow.check, header=header, ...)
-  if (length(files)>1){
+  headers <- lapply(files, utils::read.csv, sep = delim, na.strings = na.strings, quote = quote, nrows = nrow.check, header = header, ...)
+  if (length(files) > 1) {
     nn <- sapply(headers, ncol)
-    if (!all(nn==nn[1])) stop("Files have different numbers of columns")
+    if (!all(nn == nn[1])) stop("Files have different numbers of columns")
     nms <- sapply(headers, names)
-    if(!all(nms==nms[, 1])) stop("Files have different variable names")
-    types <- sapply(headers, function(df) sapply(df, dbDataType, dbObj=conn))
-    if(!all(types==types[, 1])) stop("Files have different variable types")
+    if (!all(nms == nms[, 1])) stop("Files have different variable names")
+    types <- sapply(headers, function(df) sapply(df, dbDataType, dbObj = conn))
+    if (!all(types == types[, 1])) stop("Files have different variable types")
   }
-  
+
   if (transaction) {
-     dbBegin(conn)
-     on.exit(tryCatch(dbRollback(conn), error=function(e){}))
+    dbBegin(conn)
+    on.exit(tryCatch(dbRollback(conn), error = function(e) {}))
   }
 
   tablename <- dbQuoteIdentifier(conn, tablename)
 
   if (!dbExistsTable(conn, tablename)) {
-    if(lower.case.names) names(headers[[1]]) <- tolower(names(headers[[1]]))
-    if(!is.null(col.names)) {
+    if (lower.case.names) names(headers[[1]]) <- tolower(names(headers[[1]]))
+    if (!is.null(col.names)) {
       if (lower.case.names) {
         warning("Ignoring lower.case.names parameter as overriding col.names are supplied.")
       }
       col.names <- as.character(col.names)
       if (length(unique(col.names)) != length(names(headers[[1]]))) {
-        stop("You supplied ", length(unique(col.names)), " unique column names, but file has ", 
-          length(names(headers[[1]])), " columns.")
+        stop(
+          "You supplied ", length(unique(col.names)), " unique column names, but file has ",
+          length(names(headers[[1]])), " columns."
+        )
       }
-      names(headers[[1]]) <-  col.names
+      names(headers[[1]]) <- col.names
     }
-    dbWriteTable(conn, tablename, headers[[1]][FALSE, ,drop=FALSE])
+    dbWriteTable(conn, tablename, headers[[1]][FALSE, , drop = FALSE])
   }
-  
-  for(i in seq_along(files)) {
+
+  for (i in seq_along(files)) {
     thefile <- dbQuoteString(conn, encodeString(normalizePath(files[i])))
-    dbExecute(conn, sprintf("COPY %s FROM %s (DELIMITER %s, QUOTE %s, HEADER %s, NULL %s)", tablename, thefile, dbQuoteString(conn, delim), dbQuoteString(conn,quote), tolower(header), dbQuoteString(conn, na.strings[1])))
+    dbExecute(conn, sprintf("COPY %s FROM %s (DELIMITER %s, QUOTE %s, HEADER %s, NULL %s)", tablename, thefile, dbQuoteString(conn, delim), dbQuoteString(conn, quote), tolower(header), dbQuoteString(conn, na.strings[1])))
   }
   dbGetQuery(conn, paste("SELECT COUNT(*) FROM", tablename))[[1]]
- 
+
   if (transaction) {
     dbCommit(conn)
     on.exit(NULL)
diff --git a/tools/rpkg/R/Driver.R b/tools/rpkg/R/Driver.R
index 90278a8f7574..4285e8119d36 100644
--- a/tools/rpkg/R/Driver.R
+++ b/tools/rpkg/R/Driver.R
@@ -20,32 +20,31 @@ DBDIR_MEMORY <- ":memory:"
 #' #' library(DBI)
 #' duckdb::duckdb()
 #' }
-
-
-duckdb <- function(dbdir=DBDIR_MEMORY, read_only=FALSE) {
+#'
+duckdb <- function(dbdir = DBDIR_MEMORY, read_only = FALSE) {
   check_flag(read_only)
   new(
     "duckdb_driver",
     database_ref = .Call(duckdb_startup_R, dbdir, read_only),
-    dbdir=dbdir,
+    dbdir = dbdir,
     read_only = read_only
   )
 }
 
 #' @rdname DBI
 #' @export
-setClass("duckdb_driver", contains = "DBIDriver", slots = list(database_ref = "externalptr", dbdir="character", read_only="logical"))
+setClass("duckdb_driver", contains = "DBIDriver", slots = list(database_ref = "externalptr", dbdir = "character", read_only = "logical"))
 
-extptr_str <- function(e, n=5) {
+extptr_str <- function(e, n = 5) {
   x <- .Call(duckdb_ptr_to_str, e)
-  substr(x, nchar(x)-n+1, nchar(x))
+  substr(x, nchar(x) - n + 1, nchar(x))
 }
 
 drv_to_string <- function(drv) {
   if (!is(drv, "duckdb_driver")) {
     stop("pass a duckdb_driver object")
   }
-  sprintf("<duckdb_driver %s dbdir='%s' read_only=%s>",  extptr_str(drv@database_ref), drv@dbdir, drv@read_only)
+  sprintf("<duckdb_driver %s dbdir='%s' read_only=%s>", extptr_str(drv@database_ref), drv@dbdir, drv@read_only)
 }
 
 #' @rdname DBI
@@ -56,14 +55,15 @@ setMethod(
   function(object) {
     cat(drv_to_string(object))
     cat("
")
-  })
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbConnect
 #' @export
 setMethod(
   "dbConnect", "duckdb_driver",
-  function(drv, dbdir=DBDIR_MEMORY, ..., debug=getOption("duckdb.debug", FALSE), read_only=FALSE) {
+  function(drv, dbdir = DBDIR_MEMORY, ..., debug = getOption("duckdb.debug", FALSE), read_only = FALSE) {
 
     check_flag(debug)
 
@@ -77,7 +77,7 @@ setMethod(
       drv <- duckdb(dbdir, read_only)
     }
 
-    duckdb_connection(drv, debug=debug)
+    duckdb_connection(drv, debug = debug)
   }
 )
 
@@ -88,21 +88,31 @@ setMethod(
   "dbDataType", "duckdb_driver",
   function(dbObj, obj, ...) {
 
-  if (is.null(obj)) stop("NULL parameter")
-  if (is.data.frame(obj)) {
-    return (vapply(obj, function(x) dbDataType(dbObj, x), FUN.VALUE = "character"))
+    if (is.null(obj)) stop("NULL parameter")
+    if (is.data.frame(obj)) {
+      return(vapply(obj, function(x) dbDataType(dbObj, x), FUN.VALUE = "character"))
+    }
+    #  else if (int64 && inherits(obj, "integer64")) "BIGINT"
+    else if (inherits(obj, "Date")) {
+      "DATE"
+    } else if (inherits(obj, "difftime")) {
+      "TIME"
+    } else if (is.logical(obj)) {
+      "BOOLEAN"
+    } else if (is.integer(obj)) {
+      "INTEGER"
+    } else if (is.numeric(obj)) {
+      "DOUBLE"
+    } else if (inherits(obj, "POSIXt")) {
+      "TIMESTAMP"
+    } else if (is.list(obj) && all(vapply(obj, typeof, FUN.VALUE = "character") == "raw" || is.na(obj))) {
+      "BLOB"
+    } else {
+      "STRING"
+    }
+
   }
-#  else if (int64 && inherits(obj, "integer64")) "BIGINT"
-  else if (inherits(obj, "Date")) "DATE"
-  else if (inherits(obj, "difftime")) "TIME"
-  else if (is.logical(obj)) "BOOLEAN"
-  else if (is.integer(obj)) "INTEGER"
-  else if (is.numeric(obj)) "DOUBLE"
-  else if (inherits(obj, "POSIXt")) "TIMESTAMP"
-  else if (is.list(obj) && all(vapply(obj, typeof, FUN.VALUE = "character") == "raw" || is.na(obj))) "BLOB"
-  else "STRING"
-
-  })
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbIsValid
@@ -111,15 +121,19 @@ setMethod(
   "dbIsValid", "duckdb_driver",
   function(dbObj, ...) {
     valid <- FALSE
-    tryCatch ({
-      con <- dbConnect(dbObj)
-      dbExecute(con, SQL("SELECT 1"))
-      dbDisconnect(con)
-      valid <- TRUE
-    }, error = function(c) {
-    })
+    tryCatch(
+      {
+        con <- dbConnect(dbObj)
+        dbExecute(con, SQL("SELECT 1"))
+        dbDisconnect(con)
+        valid <- TRUE
+      },
+      error = function(c) {
+      }
+    )
     valid
-  })
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbGetInfo
@@ -127,10 +141,12 @@ setMethod(
 setMethod(
   "dbGetInfo", "duckdb_driver",
   function(dbObj, ...) {
-    list(driver.version=NA, client.version=NA)
-  })
+    list(driver.version = NA, client.version = NA)
+  }
+)
 
 
+#' @rdname DBI
 #' @export
 duckdb_shutdown <- function(drv) {
   if (!is(drv, "duckdb_driver")) {
@@ -144,21 +160,21 @@ duckdb_shutdown <- function(drv) {
   invisible(TRUE)
 }
 
-is_installed <- function (pkg) {
-    as.logical(requireNamespace(pkg, quietly = TRUE)) == TRUE
+is_installed <- function(pkg) {
+  as.logical(requireNamespace(pkg, quietly = TRUE)) == TRUE
 }
 
 
 #' @importFrom DBI dbConnect
 #' @importFrom dbplyr src_dbi
 #' @export
-src_duckdb <- function (path=":memory:", create = FALSE, read_only=FALSE) {
-    if (!is_installed("dbplyr")) {
-      stop("Need package `dbplyr` installed.")
-    }
-    if (path != ":memory:" && !create && !file.exists(path)) {
-        stop("`path` '",path,"' must already exist, unless `create` = TRUE")
-    }
-    con <- DBI::dbConnect(duckdb::duckdb(), path, read_only=read_only)
-    dbplyr::src_dbi(con, auto_disconnect = TRUE)
+src_duckdb <- function(path = ":memory:", create = FALSE, read_only = FALSE) {
+  if (!is_installed("dbplyr")) {
+    stop("Need package `dbplyr` installed.")
+  }
+  if (path != ":memory:" && !create && !file.exists(path)) {
+    stop("`path` '", path, "' must already exist, unless `create` = TRUE")
+  }
+  con <- DBI::dbConnect(duckdb::duckdb(), path, read_only = read_only)
+  dbplyr::src_dbi(con, auto_disconnect = TRUE)
 }
diff --git a/tools/rpkg/R/Result.R b/tools/rpkg/R/Result.R
index 591225917b0b..5ab5d77e35bf 100644
--- a/tools/rpkg/R/Result.R
+++ b/tools/rpkg/R/Result.R
@@ -2,12 +2,12 @@
 NULL
 
 duckdb_result <- function(connection, stmt_lst) {
-  env <- new.env(parent=emptyenv())
+  env <- new.env(parent = emptyenv())
   env$rows_fetched <- 0
   env$open <- TRUE
   env$rows_affected <- 0
 
-  res <- new("duckdb_result", connection = connection, stmt_lst = stmt_lst, env=env)
+  res <- new("duckdb_result", connection = connection, stmt_lst = stmt_lst, env = env)
 
   if (stmt_lst$n_param == 0) {
     duckdb_execute(res)
@@ -19,9 +19,9 @@ duckdb_result <- function(connection, stmt_lst) {
 duckdb_execute <- function(res) {
   res@env$resultset <- .Call(duckdb_execute_R, res@stmt_lst$ref)
   attr(res@env$resultset, "row.names") <-
-          c(NA_integer_, as.integer(-1 * length(res@env$resultset[[1]])))
+    c(NA_integer_, as.integer(-1 * length(res@env$resultset[[1]])))
   class(res@env$resultset) <- "data.frame"
-  if (res@stmt_lst$type != 'SELECT') {
+  if (res@stmt_lst$type != "SELECT") {
     res@env$rows_affected <- as.numeric(res@env$resultset[[1]][1])
   }
 }
@@ -45,7 +45,8 @@ setMethod(
   "show", "duckdb_result",
   function(object) {
     cat(sprintf("<duckdb_result %s connection=%s statement='%s'>
", extptr_str(object@stmt_lst$ref), extptr_str(object@connection@conn_ref), object@stmt_lst$str))
-  })
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbClearResult
@@ -60,10 +61,11 @@ setMethod(
       warning("Result was cleared already")
     }
     return(invisible(TRUE))
-  })
+  }
+)
 
 # as per is.integer documentation
-is_wholenumber <- function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol
+is_wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - round(x)) < tol
 
 fix_rownames <- function(df) {
   attr(df, "row.names") <- c(NA, as.integer(-nrow(df)))
@@ -98,7 +100,7 @@ setMethod(
       return(data.frame())
     }
 
-# FIXME this is ugly
+    # FIXME this is ugly
     if (n == 0) {
       return(utils::head(res@env$resultset, 0))
     }
@@ -106,7 +108,7 @@ setMethod(
       res@env$rows_fetched <- 0
     }
     if (res@env$rows_fetched >= nrow(res@env$resultset)) {
-      return(fix_rownames(res@env$resultset[F,, drop=F]))
+      return(fix_rownames(res@env$resultset[F, , drop = F]))
     }
     # special case, return everything
     if (n == -1 && res@env$rows_fetched == 0) {
@@ -116,14 +118,15 @@ setMethod(
     if (n > -1) {
       n <- min(n, nrow(res@env$resultset) - res@env$rows_fetched)
       res@env$rows_fetched <- res@env$rows_fetched + n
-      df <- res@env$resultset[(res@env$rows_fetched - n + 1):(res@env$rows_fetched),, drop=F]
+      df <- res@env$resultset[(res@env$rows_fetched - n + 1):(res@env$rows_fetched), , drop = F]
       return(fix_rownames(df))
     }
     start <- res@env$rows_fetched + 1
     res@env$rows_fetched <- nrow(res@env$resultset)
-    df <- res@env$resultset[nrow(res@env$resultset),, drop=F]
+    df <- res@env$resultset[nrow(res@env$resultset), , drop = F]
     return(fix_rownames(df))
-  })
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbHasCompleted
@@ -132,13 +135,14 @@ setMethod(
   "dbHasCompleted", "duckdb_result",
   function(res, ...) {
     if (!res@env$open) {
-     stop("result has already been cleared")
+      stop("result has already been cleared")
     }
     if (res@stmt_lst$type != "SELECT") {
       return(TRUE)
     }
     return(res@env$rows_fetched == nrow(res@env$resultset))
-  })
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbGetInfo
@@ -148,7 +152,8 @@ setMethod(
   function(dbObj, ...) {
     # Optional
     getMethod("dbGetInfo", "DBIResult", asNamespace("DBI"))(dbObj, ...)
-  })
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbIsValid
@@ -157,7 +162,8 @@ setMethod(
   "dbIsValid", "duckdb_result",
   function(dbObj, ...) {
     return(dbObj@env$open)
-  })
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbGetStatement
@@ -169,7 +175,8 @@ setMethod(
       stop("result has already been cleared")
     }
     return(res@stmt_lst$str)
-  })
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbColumnInfo
@@ -177,9 +184,10 @@ setMethod(
 setMethod(
   "dbColumnInfo", "duckdb_result",
   function(res, ...) {
-    return(data.frame(name=res@stmt_lst$names, type=res@stmt_lst$rtypes, stringsAsFactors=FALSE))
+    return(data.frame(name = res@stmt_lst$names, type = res@stmt_lst$rtypes, stringsAsFactors = FALSE))
 
-  })
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbGetRowCount
@@ -190,8 +198,9 @@ setMethod(
     if (!res@env$open) {
       stop("result has already been cleared")
     }
-   return(res@env$rows_fetched)
-  })
+    return(res@env$rows_fetched)
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbGetRowsAffected
@@ -199,11 +208,12 @@ setMethod(
 setMethod(
   "dbGetRowsAffected", "duckdb_result",
   function(res, ...) {
-     if (!res@env$open) {
+    if (!res@env$open) {
       stop("result has already been cleared")
     }
-  return (res@env$rows_affected)
-  })
+    return(res@env$rows_affected)
+  }
+)
 
 #' @rdname DBI
 #' @inheritParams DBI::dbBind
@@ -220,4 +230,5 @@ setMethod(
 
     invisible(.Call(duckdb_bind_R, res@stmt_lst$ref, params))
     duckdb_execute(res)
-  })
+  }
+)
diff --git a/tools/rpkg/R/duckdb-package.R b/tools/rpkg/R/duckdb-package.R
new file mode 100644
index 000000000000..7c508071d805
--- /dev/null
+++ b/tools/rpkg/R/duckdb-package.R
@@ -0,0 +1,4 @@
+## usethis namespace: start
+#' @useDynLib duckdb, .registration = TRUE
+## usethis namespace: end
+NULL
diff --git a/tools/rpkg/R/duckdb.R b/tools/rpkg/R/duckdb.R
index dfe876c8e82d..9e58ebdd4b7a 100644
--- a/tools/rpkg/R/duckdb.R
+++ b/tools/rpkg/R/duckdb.R
@@ -7,4 +7,3 @@ check_flag <- function(x) {
   }
 }
 
-#' @useDynLib duckdb , .registration = TRUE
diff --git a/tools/rpkg/man/DBI.Rd b/tools/rpkg/man/DBI.Rd
index 471fd3ce8431..dce696ee3226 100644
--- a/tools/rpkg/man/DBI.Rd
+++ b/tools/rpkg/man/DBI.Rd
@@ -9,12 +9,14 @@
 \alias{dbDataType,duckdb_driver-method}
 \alias{dbIsValid,duckdb_driver-method}
 \alias{dbGetInfo,duckdb_driver-method}
+\alias{duckdb_shutdown}
+\alias{duckdb_register}
+\alias{duckdb_unregister}
 \alias{duckdb_connection-class}
 \alias{show,duckdb_connection-method}
 \alias{dbIsValid,duckdb_connection-method}
 \alias{dbDisconnect,duckdb_connection-method}
 \alias{dbSendQuery,duckdb_connection,character-method}
-\alias{dbSendStatement,duckdb_connection,character-method}
 \alias{dbDataType,duckdb_connection-method}
 \alias{dbWriteTable,duckdb_connection,character,data.frame-method}
 \alias{dbListTables,duckdb_connection-method}
@@ -25,6 +27,7 @@
 \alias{dbBegin,duckdb_connection-method}
 \alias{dbCommit,duckdb_connection-method}
 \alias{dbRollback,duckdb_connection-method}
+\alias{read_csv_duckdb}
 \alias{duckdb_result-class}
 \alias{show,duckdb_result-method}
 \alias{dbClearResult,duckdb_result-method}
@@ -43,10 +46,10 @@
 
 \S4method{dbConnect}{duckdb_driver}(
   drv,
-  dbdir = ":memory:",
+  dbdir = DBDIR_MEMORY,
   ...,
   debug = getOption("duckdb.debug", FALSE),
-  dbname = NA
+  read_only = FALSE
 )
 
 \S4method{dbDataType}{duckdb_driver}(dbObj, obj, ...)
@@ -55,15 +58,19 @@
 
 \S4method{dbGetInfo}{duckdb_driver}(dbObj, ...)
 
+duckdb_shutdown(drv)
+
+duckdb_register(conn, name, df)
+
+duckdb_unregister(conn, name)
+
 \S4method{show}{duckdb_connection}(object)
 
 \S4method{dbIsValid}{duckdb_connection}(dbObj, ...)
 
-\S4method{dbDisconnect}{duckdb_connection}(conn, ...)
+\S4method{dbDisconnect}{duckdb_connection}(conn, ..., shutdown = FALSE)
 
-\S4method{dbSendQuery}{duckdb_connection,character}(conn, statement, ...)
-
-\S4method{dbSendStatement}{duckdb_connection,character}(conn, statement, ...)
+\S4method{dbSendQuery}{duckdb_connection,character}(conn, statement, ..., immediate = FALSE)
 
 \S4method{dbDataType}{duckdb_connection}(dbObj, obj, ...)
 
@@ -95,6 +102,22 @@
 
 \S4method{dbRollback}{duckdb_connection}(conn, ...)
 
+read_csv_duckdb(
+  conn,
+  files,
+  tablename,
+  header = TRUE,
+  na.strings = "",
+  nrow.check = 500,
+  delim = ",",
+  quote = "\\"",
+  col.names = NULL,
+  lower.case.names = FALSE,
+  sep = delim,
+  transaction = TRUE,
+  ...
+)
+
 \S4method{show}{duckdb_result}(object)
 
 \S4method{dbClearResult}{duckdb_result}(res, ...)
@@ -134,14 +157,14 @@ or \linkS4class{DBIConnection}}
 \item{obj}{An R object whose SQL type we want to determine.}
 
 \item{conn}{A \linkS4class{DBIConnection} object, as returned by
-\code{\link[=dbConnect]{dbConnect()}}.}
-
-\item{statement}{a character string containing SQL.}
+\code{\link[DBI:dbConnect]{dbConnect()}}.}
 
 \item{name}{A character string specifying the unquoted DBMS table name,
-or the result of a call to \code{\link[=dbQuoteIdentifier]{dbQuoteIdentifier()}}.}
+or the result of a call to \code{\link[DBI:dbQuoteIdentifier]{dbQuoteIdentifier()}}.}
+
+\item{statement}{a character string containing SQL.}
 
-\item{value}{a \link[DBI]{data.frame} (or coercible to data.frame).}
+\item{value}{a \link{data.frame} (or coercible to data.frame).}
 
 \item{overwrite}{Allow overwriting the destination table. Cannot be
 `TRUE` if `append` is also `TRUE`.}
diff --git a/tools/rpkg/man/duckdb-package.Rd b/tools/rpkg/man/duckdb-package.Rd
index 98acac9fe5ee..7a6f450f3890 100644
--- a/tools/rpkg/man/duckdb-package.Rd
+++ b/tools/rpkg/man/duckdb-package.Rd
@@ -4,10 +4,31 @@
 
ame{duckdb-package}
 \alias{duckdb}
 \alias{duckdb-package}
-\title{duckdb: DBI Package for DuckDB}
+\title{duckdb: DBI Package for the DuckDB Database Management System}
 \description{
-TODO
+DuckDB is an embedded analytical data management
+    system with SQL support. This package includes all of DuckDB as well
+    as R DBI & dplyr connectors.
 }
 \details{
 TBD.
 }
+\seealso{
+Useful links:
+\itemize{
+  \item \url{https://www.duckdb.org}
+  \item \url{https://github.com/cwida/duckdb}
+  \item Report bugs at \url{https://github.com/cwida/duckdb/issues}
+}
+
+}
+\author{
+\strong{Maintainer}: Hannes MÃ¼hleisen \email{hannes@cwi.nl} (\href{https://orcid.org/0000-0001-8552-0029}{ORCID})
+
+Authors:
+\itemize{
+  \item Mark Raasveldt \email{mark.raasveldt@cwi.nl} (\href{https://orcid.org/0000-0001-5005-6844}{ORCID})
+  \item DuckDB Contributors
+}
+
+}
diff --git a/tools/rpkg/man/duckdb.Rd b/tools/rpkg/man/duckdb.Rd
index 4e5705da65c3..3d5c3d6b0396 100644
--- a/tools/rpkg/man/duckdb.Rd
+++ b/tools/rpkg/man/duckdb.Rd
@@ -4,7 +4,7 @@
 \alias{duckdb}
 \title{DuckDB driver}
 \usage{
-duckdb()
+duckdb(dbdir = DBDIR_MEMORY, read_only = FALSE)
 }
 \description{
 TBD.
@@ -14,4 +14,5 @@ TBD.
 #' library(DBI)
 duckdb::duckdb()
 }
+
 }
