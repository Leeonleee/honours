{
  "repo": "duckdb/duckdb",
  "pull_number": 706,
  "instance_id": "duckdb__duckdb-706",
  "issue_numbers": [
    "700"
  ],
  "base_commit": "c9e32c3066c1913a66d8494cdb7faa1cef7fac62",
  "patch": "diff --git a/tools/rpkg/.gitignore b/tools/rpkg/.gitignore\nindex b748dbbb1297..83982f17b973 100644\n--- a/tools/rpkg/.gitignore\n+++ b/tools/rpkg/.gitignore\n@@ -3,3 +3,102 @@ src/duckdb\n *.tgz\n src/Makevars\n /src/\n+\n+# Created by https://www.toptal.com/developers/gitignore/api/r\n+# Edit at https://www.toptal.com/developers/gitignore?templates=r\n+### R ###\n+# History files\n+.Rhistory\n+.Rapp.history\n+# Session Data files\n+.RData\n+# User-specific files\n+.Ruserdata\n+# Example code in package build process\n+*-Ex.R\n+# Output files from R CMD build\n+/*.tar.gz\n+# Output files from R CMD check\n+/*.Rcheck/\n+# RStudio files\n+.Rproj.user/\n+# produced vignettes\n+vignettes/*.html\n+vignettes/*.pdf\n+# OAuth2 token, see https://github.com/hadley/httr/releases/tag/v0.3\n+.httr-oauth\n+# knitr and R markdown default cache directories\n+*_cache/\n+/cache/\n+# Temporary files created by R markdown\n+*.utf8.md\n+*.knit.md\n+# R Environment Variables\n+.Renviron\n+### R.Bookdown Stack ###\n+# R package: bookdown caching files\n+/*_files/\n+# End of https://www.toptal.com/developers/gitignore/api/r\n+docs/\n+# Created by https://www.toptal.com/developers/gitignore/api/visualstudiocode\n+# Edit at https://www.toptal.com/developers/gitignore?templates=visualstudiocode\n+### VisualStudioCode ###\n+.vscode/*\n+!.vscode/settings.json\n+!.vscode/tasks.json\n+!.vscode/launch.json\n+!.vscode/extensions.json\n+*.code-workspace\n+### VisualStudioCode Patch ###\n+# Ignore all local history of files\n+.history\n+# End of https://www.toptal.com/developers/gitignore/api/visualstudiocode\n+# Created by https://www.toptal.com/developers/gitignore/api/macos\n+# Edit at https://www.toptal.com/developers/gitignore?templates=macos\n+### macOS ###\n+# General\n+.DS_Store\n+.AppleDouble\n+.LSOverride\n+# Icon must end with two \\r\n+Icon\n+# Thumbnails\n+._*\n+# Files that might appear in the root of a volume\n+.DocumentRevisions-V100\n+.fseventsd\n+.Spotlight-V100\n+.TemporaryItems\n+.Trashes\n+.VolumeIcon.icns\n+.com.apple.timemachine.donotpresent\n+# Directories potentially created on remote AFP share\n+.AppleDB\n+.AppleDesktop\n+Network Trash Folder\n+Temporary Items\n+.apdisk\n+# End of https://www.toptal.com/developers/gitignore/api/macos\n+# Created by https://www.toptal.com/developers/gitignore/api/windows\n+# Edit at https://www.toptal.com/developers/gitignore?templates=windows\n+### Windows ###\n+# Windows thumbnail cache files\n+Thumbs.db\n+Thumbs.db:encryptable\n+ehthumbs.db\n+ehthumbs_vista.db\n+# Dump file\n+*.stackdump\n+# Folder config file\n+[Dd]esktop.ini\n+# Recycle Bin used on file shares\n+$RECYCLE.BIN/\n+# Windows Installer files\n+*.cab\n+*.msi\n+*.msix\n+*.msm\n+*.msp\n+# Windows shortcuts\n+*.lnk\n+# End of https://www.toptal.com/developers/gitignore/api/windows\ndiff --git a/tools/rpkg/DESCRIPTION b/tools/rpkg/DESCRIPTION\nindex 70a4ebf2cf41..0a5ce45f01ac 100644\n--- a/tools/rpkg/DESCRIPTION\n+++ b/tools/rpkg/DESCRIPTION\n@@ -1,28 +1,44 @@\n Package: duckdb\n Title: DBI Package for the DuckDB Database Management System\n Version: 0.2.0\n-Authors@R: c(person(\"Hannes\", \"M\\u00fchleisen\", role = c(\"aut\", \"cre\"), email = \"hannes@cwi.nl\", comment = c(ORCID = \"0000-0001-8552-0029\")), person(\"Mark\", \"Raasveldt\", role = c(\"aut\"), email = \"mark.raasveldt@cwi.nl\", comment = c(ORCID = \"0000-0001-5005-6844\")), person(given = \"DuckDB Contributors\", role = \"aut\"))\n-Description: DuckDB is an embedded analytical data management system with SQL support. This package includes all of DuckDB as well as R DBI & dplyr connectors.\n-Depends: \n-    R (>= 3.5.0),\n-    DBI\n+Authors@R: \n+    c(person(given = \"Hannes\",\n+             family = \"M\u00fchleisen\",\n+             role = c(\"aut\", \"cre\"),\n+             email = \"hannes@cwi.nl\",\n+             comment = c(ORCID = \"0000-0001-8552-0029\")),\n+      person(given = \"Mark\",\n+             family = \"Raasveldt\",\n+             role = \"aut\",\n+             email = \"mark.raasveldt@cwi.nl\",\n+             comment = c(ORCID = \"0000-0001-5005-6844\")),\n+      person(given = \"DuckDB Contributors\",\n+             role = \"aut\"))\n+Description: DuckDB is an embedded analytical data management\n+    system with SQL support. This package includes all of DuckDB as well\n+    as R DBI & dplyr connectors.\n License: MPL\n-LazyData: true\n-Encoding: UTF-8\n+URL: https://www.duckdb.org, https://github.com/cwida/duckdb\n+BugReports: https://github.com/cwida/duckdb/issues\n+Depends: \n+    DBI,\n+    R (>= 3.5.0)\n Imports:\n     dbplyr,\n     methods,\n     testthat,\n     utils\n Suggests: \n-    DBItest, \n-    callr\n-URL: https://www.duckdb.org, https://github.com/cwida/duckdb\n-BugReports: https://github.com/cwida/duckdb/issues\n+    callr,\n+    DBItest,\n+    nycflights13\n+Encoding: UTF-8\n+LazyData: true\n+RoxygenNote: 7.1.0.9000\n+SystemRequirements: C++11\n Collate: \n     'duckdb.R'\n     'Driver.R'\n     'Connection.R'\n     'Result.R'\n-RoxygenNote: 6.1.1\n-SystemRequirements: C++11\n+    'duckdb-package.R'\ndiff --git a/tools/rpkg/NAMESPACE b/tools/rpkg/NAMESPACE\nindex d3ec3d5cc06e..0f17aa9c0461 100644\n--- a/tools/rpkg/NAMESPACE\n+++ b/tools/rpkg/NAMESPACE\n@@ -1,13 +1,11 @@\n # Generated by roxygen2: do not edit by hand\n \n export(duckdb)\n-export(duckdb_shutdown)\n export(duckdb_register)\n+export(duckdb_shutdown)\n export(duckdb_unregister)\n-export(src_duckdb)\n export(read_csv_duckdb)\n-export(duckdb.read.csv)\n-\n+export(src_duckdb)\n exportClasses(duckdb_connection)\n exportClasses(duckdb_driver)\n exportClasses(duckdb_result)\n@@ -40,4 +38,4 @@ importFrom(DBI,dbConnect)\n importFrom(dbplyr,src_dbi)\n importFrom(testthat,skip)\n importFrom(utils,head)\n-useDynLib(duckdb , .registration = TRUE)\n+useDynLib(duckdb, .registration = TRUE)\ndiff --git a/tools/rpkg/R/Connection.R b/tools/rpkg/R/Connection.R\nindex b9f5b5ac0b08..24f52d676f5b 100644\n--- a/tools/rpkg/R/Connection.R\n+++ b/tools/rpkg/R/Connection.R\n@@ -12,12 +12,16 @@ duckdb_connection <- function(duckdb_driver, debug) {\n   )\n }\n \n+#' @rdname DBI\n+#' @export\n duckdb_register <- function(conn, name, df) {\n   stopifnot(dbIsValid(conn))\n   .Call(duckdb_register_R, conn@conn_ref, as.character(name), as.data.frame(df))\n   invisible(TRUE)\n }\n \n+#' @rdname DBI\n+#' @export\n duckdb_unregister <- function(conn, name) {\n   stopifnot(dbIsValid(conn))\n   .Call(duckdb_unregister_R, conn@conn_ref, as.character(name))\n@@ -30,83 +34,96 @@ duckdb_unregister <- function(conn, name) {\n setClass(\n   \"duckdb_connection\",\n   contains = \"DBIConnection\",\n-  slots = list(dbdir= \"character\", conn_ref = \"externalptr\", driver = \"duckdb_driver\", debug=\"logical\")\n+  slots = list(dbdir = \"character\", conn_ref = \"externalptr\", driver = \"duckdb_driver\", debug = \"logical\")\n )\n \n #' @rdname DBI\n #' @inheritParams methods::show\n #' @export\n-setMethod(\"show\", \"duckdb_connection\",\n-          function(object) {\n-            cat(sprintf(\"<duckdb_connection %s driver=%s>\\n\", extptr_str(object@conn_ref), drv_to_string(object@driver)))\n-          })\n+setMethod(\n+  \"show\", \"duckdb_connection\",\n+  function(object) {\n+    cat(sprintf(\"<duckdb_connection %s driver=%s>\\n\", extptr_str(object@conn_ref), drv_to_string(object@driver)))\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbIsValid\n #' @export\n-setMethod(\"dbIsValid\", \"duckdb_connection\",\n-          function(dbObj, ...) {\n-            valid <- FALSE\n-            tryCatch ({\n-              dbGetQuery(dbObj, SQL(\"SELECT 1\"))\n-              valid <- TRUE\n-            }, error = function(c) {\n-            })\n-            valid\n-          })\n+setMethod(\n+  \"dbIsValid\", \"duckdb_connection\",\n+  function(dbObj, ...) {\n+    valid <- FALSE\n+    tryCatch(\n+      {\n+        dbGetQuery(dbObj, SQL(\"SELECT 1\"))\n+        valid <- TRUE\n+      },\n+      error = function(c) {\n+      }\n+    )\n+    valid\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbDisconnect\n #' @export\n-setMethod(\"dbDisconnect\", \"duckdb_connection\",\n-          function(conn, ..., shutdown=FALSE) {\n-            if (!dbIsValid(conn)) {\n-              warning(\"Connection already closed.\", call. = FALSE)\n-            }\n-            .Call(duckdb_disconnect_R, conn@conn_ref)\n-            if (shutdown) {\n-              duckdb_shutdown(conn@driver)\n-            }\n-\n-            invisible(TRUE)\n-          })\n+setMethod(\n+  \"dbDisconnect\", \"duckdb_connection\",\n+  function(conn, ..., shutdown = FALSE) {\n+    if (!dbIsValid(conn)) {\n+      warning(\"Connection already closed.\", call. = FALSE)\n+    }\n+    .Call(duckdb_disconnect_R, conn@conn_ref)\n+    if (shutdown) {\n+      duckdb_shutdown(conn@driver)\n+    }\n+\n+    invisible(TRUE)\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbSendQuery\n #' @export\n-setMethod(\"dbSendQuery\", c(\"duckdb_connection\", \"character\"),\n-          function(conn, statement, ..., immediate=FALSE) {\n-            if (conn@debug) {\n-              cat(\"Q \", statement, \"\\n\")\n-            }\n-\t\t        statement <- enc2utf8(statement)\n-            stmt_lst <- .Call(duckdb_prepare_R, conn@conn_ref, statement)\n-\n-            res <- duckdb_result(\n-              connection = conn,\n-              stmt_lst = stmt_lst\n-            )\n-            params <- list(...)\n-            if (length(params) == 1 && class(params[[1]])[[1]] == \"list\") {\n-              params <- params[[1]]\n-            }\n-            if (length(params) > 0) {\n-              dbBind(res, params)\n-            }\n-            return(res)\n-          })\n+setMethod(\n+  \"dbSendQuery\", c(\"duckdb_connection\", \"character\"),\n+  function(conn, statement, ..., immediate = FALSE) {\n+    if (conn@debug) {\n+      cat(\"Q \", statement, \"\\n\")\n+    }\n+    statement <- enc2utf8(statement)\n+    stmt_lst <- .Call(duckdb_prepare_R, conn@conn_ref, statement)\n+\n+    res <- duckdb_result(\n+      connection = conn,\n+      stmt_lst = stmt_lst\n+    )\n+    params <- list(...)\n+    if (length(params) == 1 && class(params[[1]])[[1]] == \"list\") {\n+      params <- params[[1]]\n+    }\n+    if (length(params) > 0) {\n+      dbBind(res, params)\n+    }\n+    return(res)\n+  }\n+)\n \n \n #' @rdname DBI\n #' @inheritParams DBI::dbDataType\n #' @export\n-setMethod(\"dbDataType\", \"duckdb_connection\",\n-          function(dbObj, obj, ...) {\n-            dbDataType(dbObj@driver, obj, ...)\n-          })\n+setMethod(\n+  \"dbDataType\", \"duckdb_connection\",\n+  function(dbObj, obj, ...) {\n+    dbDataType(dbObj@driver, obj, ...)\n+  }\n+)\n \n duckdb_random_string <- function(x) {\n-\tpaste(sample(letters, 10, replace = TRUE), collapse=\"\")\n+  paste(sample(letters, 10, replace = TRUE), collapse = \"\")\n }\n \n #' @rdname DBI\n@@ -116,254 +133,284 @@ duckdb_random_string <- function(x) {\n #' @param append Allow appending to the destination table. Cannot be\n #'   `TRUE` if `overwrite` is also `TRUE`.\n #' @export\n-setMethod(\"dbWriteTable\", c(\"duckdb_connection\", \"character\", \"data.frame\"),\n-          function(conn,\n-                   name,\n-                   value,\n-                   row.names = FALSE,\n-                   overwrite = FALSE,\n-                   append = FALSE,\n-                   field.types = NULL,\n-                   temporary = FALSE,\n-                   ...) {\n-            check_flag(overwrite)\n-            check_flag(append)\n-            check_flag(temporary)\n-            \n-            # TODO: start a transaction if one is not already running\n-            \n-            \n-            if (overwrite && append) {\n-              stop(\"Setting both overwrite and append makes no sense\")\n-            }\n-            \n-            # oof\n-            if (!is.null(field.types) &&\n-                (\n-                  !is.character(field.types) ||\n-                  any(is.na(names(field.types))) ||\n-                  length(unique(names(field.types))) != length(names(field.types)) ||\n-                  append\n-                )) {\n-              stop(\"invalid field.types argument\")\n-            }\n-            value <- as.data.frame(value)\n-            if (!is.data.frame(value)) {\n-              stop(\"need a data frame as parameter\")\n-            }\n-            \n-            # use Kirill's magic, convert rownames to additional column\n-            value <- sqlRownamesToColumn(value, row.names)\n-            \n-            if (dbExistsTable(conn, name)) {\n-              if (overwrite) {\n-                dbRemoveTable(conn, name)\n-              }\n-              if (!overwrite && !append) {\n-                stop(\n-                  \"Table \",\n-                  name,\n-                  \" already exists. Set overwrite=TRUE if you want\n+setMethod(\n+  \"dbWriteTable\", c(\"duckdb_connection\", \"character\", \"data.frame\"),\n+  function(conn,\n+           name,\n+           value,\n+           row.names = FALSE,\n+           overwrite = FALSE,\n+           append = FALSE,\n+           field.types = NULL,\n+           temporary = FALSE,\n+           ...) {\n+    check_flag(overwrite)\n+    check_flag(append)\n+    check_flag(temporary)\n+\n+    # TODO: start a transaction if one is not already running\n+\n+\n+    if (overwrite && append) {\n+      stop(\"Setting both overwrite and append makes no sense\")\n+    }\n+\n+    # oof\n+    if (!is.null(field.types) &&\n+      (\n+        !is.character(field.types) ||\n+          any(is.na(names(field.types))) ||\n+          length(unique(names(field.types))) != length(names(field.types)) ||\n+          append\n+      )) {\n+      stop(\"invalid field.types argument\")\n+    }\n+    value <- as.data.frame(value)\n+    if (!is.data.frame(value)) {\n+      stop(\"need a data frame as parameter\")\n+    }\n+\n+    # use Kirill's magic, convert rownames to additional column\n+    value <- sqlRownamesToColumn(value, row.names)\n+\n+    if (dbExistsTable(conn, name)) {\n+      if (overwrite) {\n+        dbRemoveTable(conn, name)\n+      }\n+      if (!overwrite && !append) {\n+        stop(\n+          \"Table \",\n+          name,\n+          \" already exists. Set overwrite=TRUE if you want\n                   to remove the existing table. Set append=TRUE if you would like to add the new data to the\n                   existing table.\"\n-                )\n-              }\n-              if (append && any(names(value) != dbListFields(conn, name))) {\n-                stop(\"Column name mismatch for append\")\n-              }\n-              }\n-            table_name <- dbQuoteIdentifier(conn, name)\n-\n-            if (!dbExistsTable(conn, name)) {\n-              column_names <- dbQuoteIdentifier(conn, names(value))\n-              column_types <-\n-                vapply(value, dbDataType, dbObj = conn, FUN.VALUE = \"character\")\n-              \n-              if (!is.null(field.types)) {\n-                mapped_column_types <- field.types[names(value)]\n-                if (any(is.na(mapped_column_types)) ||\n-                    length(mapped_column_types) != length(names(value))) {\n-                  stop(\"Column name/type mismatch\")\n-                }\n-                column_types <- mapped_column_types\n-              }\n-\n-              temp_str <- \"\"\n-              if (temporary) temp_str <- \"TEMPORARY\"\n-              \n-              schema_str <- paste(column_names, column_types, collapse = \", \")\n-              dbExecute(conn, SQL(sprintf(\n-                \"CREATE %s TABLE %s (%s)\", temp_str, table_name, schema_str\n-              )))\n-            }\n-\t\t\t\n-\t\t\tif (length(value[[1]])) {\n-\t\t\t\tclasses <- unlist(lapply(value, function(v){\n-\t\t\t\t  class(v)[[1]]\n-\t\t\t\t}))\n-\t\t\t\tfor (c in names(classes[classes==\"character\"])) {\n-\t\t\t\t  value[[c]] <- enc2utf8(value[[c]])\n-\t\t\t\t}\n-\t\t\t\tfor (c in names(classes[classes==\"factor\"])) {\n-\t\t\t\t  levels(value[[c]]) <- enc2utf8(levels(value[[c]]))\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tview_name <- sprintf(\"_duckdb_append_view_%s\", duckdb_random_string())\n-            on.exit(duckdb_unregister(conn, view_name))\n-            duckdb_register(conn, view_name, value)\n-            dbExecute(conn, sprintf(\"INSERT INTO %s SELECT * FROM %s\", table_name, view_name))\n-\n-            invisible(TRUE)\n-          })\n+        )\n+      }\n+      if (append && any(names(value) != dbListFields(conn, name))) {\n+        stop(\"Column name mismatch for append\")\n+      }\n+    }\n+    table_name <- dbQuoteIdentifier(conn, name)\n+\n+    if (!dbExistsTable(conn, name)) {\n+      column_names <- dbQuoteIdentifier(conn, names(value))\n+      column_types <-\n+        vapply(value, dbDataType, dbObj = conn, FUN.VALUE = \"character\")\n+\n+      if (!is.null(field.types)) {\n+        mapped_column_types <- field.types[names(value)]\n+        if (any(is.na(mapped_column_types)) ||\n+          length(mapped_column_types) != length(names(value))) {\n+          stop(\"Column name/type mismatch\")\n+        }\n+        column_types <- mapped_column_types\n+      }\n+\n+      temp_str <- \"\"\n+      if (temporary) temp_str <- \"TEMPORARY\"\n+\n+      schema_str <- paste(column_names, column_types, collapse = \", \")\n+      dbExecute(conn, SQL(sprintf(\n+        \"CREATE %s TABLE %s (%s)\", temp_str, table_name, schema_str\n+      )))\n+    }\n+\n+    if (length(value[[1]])) {\n+      classes <- unlist(lapply(value, function(v) {\n+        class(v)[[1]]\n+      }))\n+      for (c in names(classes[classes == \"character\"])) {\n+        value[[c]] <- enc2utf8(value[[c]])\n+      }\n+      for (c in names(classes[classes == \"factor\"])) {\n+        levels(value[[c]]) <- enc2utf8(levels(value[[c]]))\n+      }\n+    }\n+    view_name <- sprintf(\"_duckdb_append_view_%s\", duckdb_random_string())\n+    on.exit(duckdb_unregister(conn, view_name))\n+    duckdb_register(conn, view_name, value)\n+    dbExecute(conn, sprintf(\"INSERT INTO %s SELECT * FROM %s\", table_name, view_name))\n+\n+    invisible(TRUE)\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbListTables\n #' @export\n-setMethod(\"dbListTables\", \"duckdb_connection\",\n-          function(conn, ...) {\n-            dbGetQuery(conn,\n-                       SQL(\n-                         \"SELECT name FROM sqlite_master() WHERE type='table' ORDER BY name\"\n-                       ))[[1]]\n-          })\n+setMethod(\n+  \"dbListTables\", \"duckdb_connection\",\n+  function(conn, ...) {\n+    dbGetQuery(\n+      conn,\n+      SQL(\n+        \"SELECT name FROM sqlite_master() WHERE type='table' ORDER BY name\"\n+      )\n+    )[[1]]\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbExistsTable\n #' @export\n-setMethod(\"dbExistsTable\", c(\"duckdb_connection\", \"character\"),\n-          function(conn, name, ...) {\n-            if (!dbIsValid(conn)) {\n-              stop(\"Invalid connection\")\n-            }\n-            if (length(name) != 1) {\n-              stop(\"Can only have a single name argument\")\n-            }\n-            exists <- FALSE\n-            tryCatch ({\n-              dbGetQuery(conn,\n-                         sqlInterpolate(\n-                           conn,\n-                           \"SELECT * FROM ? WHERE FALSE\",\n-                           dbQuoteIdentifier(conn, name)\n-                         ))\n-              exists <- TRUE\n-            }, error = function(c) {\n-            })\n-            exists\n-          })\n+setMethod(\n+  \"dbExistsTable\", c(\"duckdb_connection\", \"character\"),\n+  function(conn, name, ...) {\n+    if (!dbIsValid(conn)) {\n+      stop(\"Invalid connection\")\n+    }\n+    if (length(name) != 1) {\n+      stop(\"Can only have a single name argument\")\n+    }\n+    exists <- FALSE\n+    tryCatch(\n+      {\n+        dbGetQuery(\n+          conn,\n+          sqlInterpolate(\n+            conn,\n+            \"SELECT * FROM ? WHERE FALSE\",\n+            dbQuoteIdentifier(conn, name)\n+          )\n+        )\n+        exists <- TRUE\n+      },\n+      error = function(c) {\n+      }\n+    )\n+    exists\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbListFields\n #' @export\n-setMethod(\"dbListFields\", c(\"duckdb_connection\", \"character\"),\n-          function(conn, name, ...) {\n-            names(dbGetQuery(\n-              conn,\n-              sqlInterpolate(\n-                conn,\n-                \"SELECT * FROM ? WHERE FALSE\",\n-                dbQuoteIdentifier(conn, name)\n-              )\n-            ))\n-          })\n+setMethod(\n+  \"dbListFields\", c(\"duckdb_connection\", \"character\"),\n+  function(conn, name, ...) {\n+    names(dbGetQuery(\n+      conn,\n+      sqlInterpolate(\n+        conn,\n+        \"SELECT * FROM ? WHERE FALSE\",\n+        dbQuoteIdentifier(conn, name)\n+      )\n+    ))\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbRemoveTable\n #' @export\n-setMethod(\"dbRemoveTable\", c(\"duckdb_connection\", \"character\"),\n-          function(conn, name, ...) {\n-            dbExecute(conn,\n-                      sqlInterpolate(conn, \"DROP TABLE ?\", dbQuoteIdentifier(conn, name)))\n-            invisible(TRUE)\n-          })\n+setMethod(\n+  \"dbRemoveTable\", c(\"duckdb_connection\", \"character\"),\n+  function(conn, name, ...) {\n+    dbExecute(\n+      conn,\n+      sqlInterpolate(conn, \"DROP TABLE ?\", dbQuoteIdentifier(conn, name))\n+    )\n+    invisible(TRUE)\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbGetInfo\n #' @export\n-setMethod(\"dbGetInfo\", \"duckdb_connection\",\n-          function(dbObj, ...) {\n-            list(\n-              dbname = dbObj@dbdir,\n-              db.version = NA,\n-              username = NA,\n-              host = NA,\n-              port = NA\n-            )\n-          })\n+setMethod(\n+  \"dbGetInfo\", \"duckdb_connection\",\n+  function(dbObj, ...) {\n+    list(\n+      dbname = dbObj@dbdir,\n+      db.version = NA,\n+      username = NA,\n+      host = NA,\n+      port = NA\n+    )\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbBegin\n #' @export\n-setMethod(\"dbBegin\", \"duckdb_connection\",\n-          function(conn, ...) {\n-            dbExecute(conn, SQL(\"BEGIN TRANSACTION\"))\n-            invisible(TRUE)\n-          })\n+setMethod(\n+  \"dbBegin\", \"duckdb_connection\",\n+  function(conn, ...) {\n+    dbExecute(conn, SQL(\"BEGIN TRANSACTION\"))\n+    invisible(TRUE)\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbCommit\n #' @export\n-setMethod(\"dbCommit\", \"duckdb_connection\",\n-          function(conn, ...) {\n-            dbExecute(conn, SQL(\"COMMIT\"))\n-            invisible(TRUE)\n-          })\n+setMethod(\n+  \"dbCommit\", \"duckdb_connection\",\n+  function(conn, ...) {\n+    dbExecute(conn, SQL(\"COMMIT\"))\n+    invisible(TRUE)\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbRollback\n #' @export\n-setMethod(\"dbRollback\", \"duckdb_connection\",\n-          function(conn, ...) {\n-            dbExecute(conn, SQL(\"ROLLBACK\"))\n-            invisible(TRUE)\n-          })\n+setMethod(\n+  \"dbRollback\", \"duckdb_connection\",\n+  function(conn, ...) {\n+    dbExecute(conn, SQL(\"ROLLBACK\"))\n+    invisible(TRUE)\n+  }\n+)\n \n+#' @rdname DBI\n+#' @export\n+read_csv_duckdb <- duckdb.read.csv <- function(conn, files, tablename, header = TRUE, na.strings = \"\", nrow.check = 500,\n+                                               delim = \",\", quote = \"\\\"\", col.names = NULL, lower.case.names = FALSE, sep = delim, transaction = TRUE, ...) {\n \n-read_csv_duckdb <- duckdb.read.csv <- function(conn, files, tablename, header=TRUE, na.strings=\"\", nrow.check=500, \n-                                               delim=\",\", quote=\"\\\"\", col.names=NULL, lower.case.names=FALSE, sep=delim, transaction=TRUE, ...){\n-  \n-  if (length(na.strings)>1) stop(\"na.strings must be of length 1\")\n+  if (length(na.strings) > 1) stop(\"na.strings must be of length 1\")\n   if (!missing(sep)) delim <- sep\n \n-  headers <- lapply(files, utils::read.csv, sep=delim, na.strings=na.strings, quote=quote, nrows=nrow.check, header=header, ...)\n-  if (length(files)>1){\n+  headers <- lapply(files, utils::read.csv, sep = delim, na.strings = na.strings, quote = quote, nrows = nrow.check, header = header, ...)\n+  if (length(files) > 1) {\n     nn <- sapply(headers, ncol)\n-    if (!all(nn==nn[1])) stop(\"Files have different numbers of columns\")\n+    if (!all(nn == nn[1])) stop(\"Files have different numbers of columns\")\n     nms <- sapply(headers, names)\n-    if(!all(nms==nms[, 1])) stop(\"Files have different variable names\")\n-    types <- sapply(headers, function(df) sapply(df, dbDataType, dbObj=conn))\n-    if(!all(types==types[, 1])) stop(\"Files have different variable types\")\n+    if (!all(nms == nms[, 1])) stop(\"Files have different variable names\")\n+    types <- sapply(headers, function(df) sapply(df, dbDataType, dbObj = conn))\n+    if (!all(types == types[, 1])) stop(\"Files have different variable types\")\n   }\n-  \n+\n   if (transaction) {\n-     dbBegin(conn)\n-     on.exit(tryCatch(dbRollback(conn), error=function(e){}))\n+    dbBegin(conn)\n+    on.exit(tryCatch(dbRollback(conn), error = function(e) {}))\n   }\n \n   tablename <- dbQuoteIdentifier(conn, tablename)\n \n   if (!dbExistsTable(conn, tablename)) {\n-    if(lower.case.names) names(headers[[1]]) <- tolower(names(headers[[1]]))\n-    if(!is.null(col.names)) {\n+    if (lower.case.names) names(headers[[1]]) <- tolower(names(headers[[1]]))\n+    if (!is.null(col.names)) {\n       if (lower.case.names) {\n         warning(\"Ignoring lower.case.names parameter as overriding col.names are supplied.\")\n       }\n       col.names <- as.character(col.names)\n       if (length(unique(col.names)) != length(names(headers[[1]]))) {\n-        stop(\"You supplied \", length(unique(col.names)), \" unique column names, but file has \", \n-          length(names(headers[[1]])), \" columns.\")\n+        stop(\n+          \"You supplied \", length(unique(col.names)), \" unique column names, but file has \",\n+          length(names(headers[[1]])), \" columns.\"\n+        )\n       }\n-      names(headers[[1]]) <-  col.names\n+      names(headers[[1]]) <- col.names\n     }\n-    dbWriteTable(conn, tablename, headers[[1]][FALSE, ,drop=FALSE])\n+    dbWriteTable(conn, tablename, headers[[1]][FALSE, , drop = FALSE])\n   }\n-  \n-  for(i in seq_along(files)) {\n+\n+  for (i in seq_along(files)) {\n     thefile <- dbQuoteString(conn, encodeString(normalizePath(files[i])))\n-    dbExecute(conn, sprintf(\"COPY %s FROM %s (DELIMITER %s, QUOTE %s, HEADER %s, NULL %s)\", tablename, thefile, dbQuoteString(conn, delim), dbQuoteString(conn,quote), tolower(header), dbQuoteString(conn, na.strings[1])))\n+    dbExecute(conn, sprintf(\"COPY %s FROM %s (DELIMITER %s, QUOTE %s, HEADER %s, NULL %s)\", tablename, thefile, dbQuoteString(conn, delim), dbQuoteString(conn, quote), tolower(header), dbQuoteString(conn, na.strings[1])))\n   }\n   dbGetQuery(conn, paste(\"SELECT COUNT(*) FROM\", tablename))[[1]]\n- \n+\n   if (transaction) {\n     dbCommit(conn)\n     on.exit(NULL)\ndiff --git a/tools/rpkg/R/Driver.R b/tools/rpkg/R/Driver.R\nindex 90278a8f7574..4285e8119d36 100644\n--- a/tools/rpkg/R/Driver.R\n+++ b/tools/rpkg/R/Driver.R\n@@ -20,32 +20,31 @@ DBDIR_MEMORY <- \":memory:\"\n #' #' library(DBI)\n #' duckdb::duckdb()\n #' }\n-\n-\n-duckdb <- function(dbdir=DBDIR_MEMORY, read_only=FALSE) {\n+#'\n+duckdb <- function(dbdir = DBDIR_MEMORY, read_only = FALSE) {\n   check_flag(read_only)\n   new(\n     \"duckdb_driver\",\n     database_ref = .Call(duckdb_startup_R, dbdir, read_only),\n-    dbdir=dbdir,\n+    dbdir = dbdir,\n     read_only = read_only\n   )\n }\n \n #' @rdname DBI\n #' @export\n-setClass(\"duckdb_driver\", contains = \"DBIDriver\", slots = list(database_ref = \"externalptr\", dbdir=\"character\", read_only=\"logical\"))\n+setClass(\"duckdb_driver\", contains = \"DBIDriver\", slots = list(database_ref = \"externalptr\", dbdir = \"character\", read_only = \"logical\"))\n \n-extptr_str <- function(e, n=5) {\n+extptr_str <- function(e, n = 5) {\n   x <- .Call(duckdb_ptr_to_str, e)\n-  substr(x, nchar(x)-n+1, nchar(x))\n+  substr(x, nchar(x) - n + 1, nchar(x))\n }\n \n drv_to_string <- function(drv) {\n   if (!is(drv, \"duckdb_driver\")) {\n     stop(\"pass a duckdb_driver object\")\n   }\n-  sprintf(\"<duckdb_driver %s dbdir='%s' read_only=%s>\",  extptr_str(drv@database_ref), drv@dbdir, drv@read_only)\n+  sprintf(\"<duckdb_driver %s dbdir='%s' read_only=%s>\", extptr_str(drv@database_ref), drv@dbdir, drv@read_only)\n }\n \n #' @rdname DBI\n@@ -56,14 +55,15 @@ setMethod(\n   function(object) {\n     cat(drv_to_string(object))\n     cat(\"\\n\")\n-  })\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbConnect\n #' @export\n setMethod(\n   \"dbConnect\", \"duckdb_driver\",\n-  function(drv, dbdir=DBDIR_MEMORY, ..., debug=getOption(\"duckdb.debug\", FALSE), read_only=FALSE) {\n+  function(drv, dbdir = DBDIR_MEMORY, ..., debug = getOption(\"duckdb.debug\", FALSE), read_only = FALSE) {\n \n     check_flag(debug)\n \n@@ -77,7 +77,7 @@ setMethod(\n       drv <- duckdb(dbdir, read_only)\n     }\n \n-    duckdb_connection(drv, debug=debug)\n+    duckdb_connection(drv, debug = debug)\n   }\n )\n \n@@ -88,21 +88,31 @@ setMethod(\n   \"dbDataType\", \"duckdb_driver\",\n   function(dbObj, obj, ...) {\n \n-  if (is.null(obj)) stop(\"NULL parameter\")\n-  if (is.data.frame(obj)) {\n-    return (vapply(obj, function(x) dbDataType(dbObj, x), FUN.VALUE = \"character\"))\n+    if (is.null(obj)) stop(\"NULL parameter\")\n+    if (is.data.frame(obj)) {\n+      return(vapply(obj, function(x) dbDataType(dbObj, x), FUN.VALUE = \"character\"))\n+    }\n+    #  else if (int64 && inherits(obj, \"integer64\")) \"BIGINT\"\n+    else if (inherits(obj, \"Date\")) {\n+      \"DATE\"\n+    } else if (inherits(obj, \"difftime\")) {\n+      \"TIME\"\n+    } else if (is.logical(obj)) {\n+      \"BOOLEAN\"\n+    } else if (is.integer(obj)) {\n+      \"INTEGER\"\n+    } else if (is.numeric(obj)) {\n+      \"DOUBLE\"\n+    } else if (inherits(obj, \"POSIXt\")) {\n+      \"TIMESTAMP\"\n+    } else if (is.list(obj) && all(vapply(obj, typeof, FUN.VALUE = \"character\") == \"raw\" || is.na(obj))) {\n+      \"BLOB\"\n+    } else {\n+      \"STRING\"\n+    }\n+\n   }\n-#  else if (int64 && inherits(obj, \"integer64\")) \"BIGINT\"\n-  else if (inherits(obj, \"Date\")) \"DATE\"\n-  else if (inherits(obj, \"difftime\")) \"TIME\"\n-  else if (is.logical(obj)) \"BOOLEAN\"\n-  else if (is.integer(obj)) \"INTEGER\"\n-  else if (is.numeric(obj)) \"DOUBLE\"\n-  else if (inherits(obj, \"POSIXt\")) \"TIMESTAMP\"\n-  else if (is.list(obj) && all(vapply(obj, typeof, FUN.VALUE = \"character\") == \"raw\" || is.na(obj))) \"BLOB\"\n-  else \"STRING\"\n-\n-  })\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbIsValid\n@@ -111,15 +121,19 @@ setMethod(\n   \"dbIsValid\", \"duckdb_driver\",\n   function(dbObj, ...) {\n     valid <- FALSE\n-    tryCatch ({\n-      con <- dbConnect(dbObj)\n-      dbExecute(con, SQL(\"SELECT 1\"))\n-      dbDisconnect(con)\n-      valid <- TRUE\n-    }, error = function(c) {\n-    })\n+    tryCatch(\n+      {\n+        con <- dbConnect(dbObj)\n+        dbExecute(con, SQL(\"SELECT 1\"))\n+        dbDisconnect(con)\n+        valid <- TRUE\n+      },\n+      error = function(c) {\n+      }\n+    )\n     valid\n-  })\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbGetInfo\n@@ -127,10 +141,12 @@ setMethod(\n setMethod(\n   \"dbGetInfo\", \"duckdb_driver\",\n   function(dbObj, ...) {\n-    list(driver.version=NA, client.version=NA)\n-  })\n+    list(driver.version = NA, client.version = NA)\n+  }\n+)\n \n \n+#' @rdname DBI\n #' @export\n duckdb_shutdown <- function(drv) {\n   if (!is(drv, \"duckdb_driver\")) {\n@@ -144,21 +160,21 @@ duckdb_shutdown <- function(drv) {\n   invisible(TRUE)\n }\n \n-is_installed <- function (pkg) {\n-    as.logical(requireNamespace(pkg, quietly = TRUE)) == TRUE\n+is_installed <- function(pkg) {\n+  as.logical(requireNamespace(pkg, quietly = TRUE)) == TRUE\n }\n \n \n #' @importFrom DBI dbConnect\n #' @importFrom dbplyr src_dbi\n #' @export\n-src_duckdb <- function (path=\":memory:\", create = FALSE, read_only=FALSE) {\n-    if (!is_installed(\"dbplyr\")) {\n-      stop(\"Need package `dbplyr` installed.\")\n-    }\n-    if (path != \":memory:\" && !create && !file.exists(path)) {\n-        stop(\"`path` '\",path,\"' must already exist, unless `create` = TRUE\")\n-    }\n-    con <- DBI::dbConnect(duckdb::duckdb(), path, read_only=read_only)\n-    dbplyr::src_dbi(con, auto_disconnect = TRUE)\n+src_duckdb <- function(path = \":memory:\", create = FALSE, read_only = FALSE) {\n+  if (!is_installed(\"dbplyr\")) {\n+    stop(\"Need package `dbplyr` installed.\")\n+  }\n+  if (path != \":memory:\" && !create && !file.exists(path)) {\n+    stop(\"`path` '\", path, \"' must already exist, unless `create` = TRUE\")\n+  }\n+  con <- DBI::dbConnect(duckdb::duckdb(), path, read_only = read_only)\n+  dbplyr::src_dbi(con, auto_disconnect = TRUE)\n }\ndiff --git a/tools/rpkg/R/Result.R b/tools/rpkg/R/Result.R\nindex 591225917b0b..5ab5d77e35bf 100644\n--- a/tools/rpkg/R/Result.R\n+++ b/tools/rpkg/R/Result.R\n@@ -2,12 +2,12 @@\n NULL\n \n duckdb_result <- function(connection, stmt_lst) {\n-  env <- new.env(parent=emptyenv())\n+  env <- new.env(parent = emptyenv())\n   env$rows_fetched <- 0\n   env$open <- TRUE\n   env$rows_affected <- 0\n \n-  res <- new(\"duckdb_result\", connection = connection, stmt_lst = stmt_lst, env=env)\n+  res <- new(\"duckdb_result\", connection = connection, stmt_lst = stmt_lst, env = env)\n \n   if (stmt_lst$n_param == 0) {\n     duckdb_execute(res)\n@@ -19,9 +19,9 @@ duckdb_result <- function(connection, stmt_lst) {\n duckdb_execute <- function(res) {\n   res@env$resultset <- .Call(duckdb_execute_R, res@stmt_lst$ref)\n   attr(res@env$resultset, \"row.names\") <-\n-          c(NA_integer_, as.integer(-1 * length(res@env$resultset[[1]])))\n+    c(NA_integer_, as.integer(-1 * length(res@env$resultset[[1]])))\n   class(res@env$resultset) <- \"data.frame\"\n-  if (res@stmt_lst$type != 'SELECT') {\n+  if (res@stmt_lst$type != \"SELECT\") {\n     res@env$rows_affected <- as.numeric(res@env$resultset[[1]][1])\n   }\n }\n@@ -45,7 +45,8 @@ setMethod(\n   \"show\", \"duckdb_result\",\n   function(object) {\n     cat(sprintf(\"<duckdb_result %s connection=%s statement='%s'>\\n\", extptr_str(object@stmt_lst$ref), extptr_str(object@connection@conn_ref), object@stmt_lst$str))\n-  })\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbClearResult\n@@ -60,10 +61,11 @@ setMethod(\n       warning(\"Result was cleared already\")\n     }\n     return(invisible(TRUE))\n-  })\n+  }\n+)\n \n # as per is.integer documentation\n-is_wholenumber <- function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol\n+is_wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - round(x)) < tol\n \n fix_rownames <- function(df) {\n   attr(df, \"row.names\") <- c(NA, as.integer(-nrow(df)))\n@@ -98,7 +100,7 @@ setMethod(\n       return(data.frame())\n     }\n \n-# FIXME this is ugly\n+    # FIXME this is ugly\n     if (n == 0) {\n       return(utils::head(res@env$resultset, 0))\n     }\n@@ -106,7 +108,7 @@ setMethod(\n       res@env$rows_fetched <- 0\n     }\n     if (res@env$rows_fetched >= nrow(res@env$resultset)) {\n-      return(fix_rownames(res@env$resultset[F,, drop=F]))\n+      return(fix_rownames(res@env$resultset[F, , drop = F]))\n     }\n     # special case, return everything\n     if (n == -1 && res@env$rows_fetched == 0) {\n@@ -116,14 +118,15 @@ setMethod(\n     if (n > -1) {\n       n <- min(n, nrow(res@env$resultset) - res@env$rows_fetched)\n       res@env$rows_fetched <- res@env$rows_fetched + n\n-      df <- res@env$resultset[(res@env$rows_fetched - n + 1):(res@env$rows_fetched),, drop=F]\n+      df <- res@env$resultset[(res@env$rows_fetched - n + 1):(res@env$rows_fetched), , drop = F]\n       return(fix_rownames(df))\n     }\n     start <- res@env$rows_fetched + 1\n     res@env$rows_fetched <- nrow(res@env$resultset)\n-    df <- res@env$resultset[nrow(res@env$resultset),, drop=F]\n+    df <- res@env$resultset[nrow(res@env$resultset), , drop = F]\n     return(fix_rownames(df))\n-  })\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbHasCompleted\n@@ -132,13 +135,14 @@ setMethod(\n   \"dbHasCompleted\", \"duckdb_result\",\n   function(res, ...) {\n     if (!res@env$open) {\n-     stop(\"result has already been cleared\")\n+      stop(\"result has already been cleared\")\n     }\n     if (res@stmt_lst$type != \"SELECT\") {\n       return(TRUE)\n     }\n     return(res@env$rows_fetched == nrow(res@env$resultset))\n-  })\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbGetInfo\n@@ -148,7 +152,8 @@ setMethod(\n   function(dbObj, ...) {\n     # Optional\n     getMethod(\"dbGetInfo\", \"DBIResult\", asNamespace(\"DBI\"))(dbObj, ...)\n-  })\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbIsValid\n@@ -157,7 +162,8 @@ setMethod(\n   \"dbIsValid\", \"duckdb_result\",\n   function(dbObj, ...) {\n     return(dbObj@env$open)\n-  })\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbGetStatement\n@@ -169,7 +175,8 @@ setMethod(\n       stop(\"result has already been cleared\")\n     }\n     return(res@stmt_lst$str)\n-  })\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbColumnInfo\n@@ -177,9 +184,10 @@ setMethod(\n setMethod(\n   \"dbColumnInfo\", \"duckdb_result\",\n   function(res, ...) {\n-    return(data.frame(name=res@stmt_lst$names, type=res@stmt_lst$rtypes, stringsAsFactors=FALSE))\n+    return(data.frame(name = res@stmt_lst$names, type = res@stmt_lst$rtypes, stringsAsFactors = FALSE))\n \n-  })\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbGetRowCount\n@@ -190,8 +198,9 @@ setMethod(\n     if (!res@env$open) {\n       stop(\"result has already been cleared\")\n     }\n-   return(res@env$rows_fetched)\n-  })\n+    return(res@env$rows_fetched)\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbGetRowsAffected\n@@ -199,11 +208,12 @@ setMethod(\n setMethod(\n   \"dbGetRowsAffected\", \"duckdb_result\",\n   function(res, ...) {\n-     if (!res@env$open) {\n+    if (!res@env$open) {\n       stop(\"result has already been cleared\")\n     }\n-  return (res@env$rows_affected)\n-  })\n+    return(res@env$rows_affected)\n+  }\n+)\n \n #' @rdname DBI\n #' @inheritParams DBI::dbBind\n@@ -220,4 +230,5 @@ setMethod(\n \n     invisible(.Call(duckdb_bind_R, res@stmt_lst$ref, params))\n     duckdb_execute(res)\n-  })\n+  }\n+)\ndiff --git a/tools/rpkg/R/duckdb-package.R b/tools/rpkg/R/duckdb-package.R\nnew file mode 100644\nindex 000000000000..7c508071d805\n--- /dev/null\n+++ b/tools/rpkg/R/duckdb-package.R\n@@ -0,0 +1,4 @@\n+## usethis namespace: start\n+#' @useDynLib duckdb, .registration = TRUE\n+## usethis namespace: end\n+NULL\ndiff --git a/tools/rpkg/R/duckdb.R b/tools/rpkg/R/duckdb.R\nindex dfe876c8e82d..9e58ebdd4b7a 100644\n--- a/tools/rpkg/R/duckdb.R\n+++ b/tools/rpkg/R/duckdb.R\n@@ -7,4 +7,3 @@ check_flag <- function(x) {\n   }\n }\n \n-#' @useDynLib duckdb , .registration = TRUE\ndiff --git a/tools/rpkg/man/DBI.Rd b/tools/rpkg/man/DBI.Rd\nindex 471fd3ce8431..dce696ee3226 100644\n--- a/tools/rpkg/man/DBI.Rd\n+++ b/tools/rpkg/man/DBI.Rd\n@@ -9,12 +9,14 @@\n \\alias{dbDataType,duckdb_driver-method}\n \\alias{dbIsValid,duckdb_driver-method}\n \\alias{dbGetInfo,duckdb_driver-method}\n+\\alias{duckdb_shutdown}\n+\\alias{duckdb_register}\n+\\alias{duckdb_unregister}\n \\alias{duckdb_connection-class}\n \\alias{show,duckdb_connection-method}\n \\alias{dbIsValid,duckdb_connection-method}\n \\alias{dbDisconnect,duckdb_connection-method}\n \\alias{dbSendQuery,duckdb_connection,character-method}\n-\\alias{dbSendStatement,duckdb_connection,character-method}\n \\alias{dbDataType,duckdb_connection-method}\n \\alias{dbWriteTable,duckdb_connection,character,data.frame-method}\n \\alias{dbListTables,duckdb_connection-method}\n@@ -25,6 +27,7 @@\n \\alias{dbBegin,duckdb_connection-method}\n \\alias{dbCommit,duckdb_connection-method}\n \\alias{dbRollback,duckdb_connection-method}\n+\\alias{read_csv_duckdb}\n \\alias{duckdb_result-class}\n \\alias{show,duckdb_result-method}\n \\alias{dbClearResult,duckdb_result-method}\n@@ -43,10 +46,10 @@\n \n \\S4method{dbConnect}{duckdb_driver}(\n   drv,\n-  dbdir = \":memory:\",\n+  dbdir = DBDIR_MEMORY,\n   ...,\n   debug = getOption(\"duckdb.debug\", FALSE),\n-  dbname = NA\n+  read_only = FALSE\n )\n \n \\S4method{dbDataType}{duckdb_driver}(dbObj, obj, ...)\n@@ -55,15 +58,19 @@\n \n \\S4method{dbGetInfo}{duckdb_driver}(dbObj, ...)\n \n+duckdb_shutdown(drv)\n+\n+duckdb_register(conn, name, df)\n+\n+duckdb_unregister(conn, name)\n+\n \\S4method{show}{duckdb_connection}(object)\n \n \\S4method{dbIsValid}{duckdb_connection}(dbObj, ...)\n \n-\\S4method{dbDisconnect}{duckdb_connection}(conn, ...)\n+\\S4method{dbDisconnect}{duckdb_connection}(conn, ..., shutdown = FALSE)\n \n-\\S4method{dbSendQuery}{duckdb_connection,character}(conn, statement, ...)\n-\n-\\S4method{dbSendStatement}{duckdb_connection,character}(conn, statement, ...)\n+\\S4method{dbSendQuery}{duckdb_connection,character}(conn, statement, ..., immediate = FALSE)\n \n \\S4method{dbDataType}{duckdb_connection}(dbObj, obj, ...)\n \n@@ -95,6 +102,22 @@\n \n \\S4method{dbRollback}{duckdb_connection}(conn, ...)\n \n+read_csv_duckdb(\n+  conn,\n+  files,\n+  tablename,\n+  header = TRUE,\n+  na.strings = \"\",\n+  nrow.check = 500,\n+  delim = \",\",\n+  quote = \"\\\\\"\",\n+  col.names = NULL,\n+  lower.case.names = FALSE,\n+  sep = delim,\n+  transaction = TRUE,\n+  ...\n+)\n+\n \\S4method{show}{duckdb_result}(object)\n \n \\S4method{dbClearResult}{duckdb_result}(res, ...)\n@@ -134,14 +157,14 @@ or \\linkS4class{DBIConnection}}\n \\item{obj}{An R object whose SQL type we want to determine.}\n \n \\item{conn}{A \\linkS4class{DBIConnection} object, as returned by\n-\\code{\\link[=dbConnect]{dbConnect()}}.}\n-\n-\\item{statement}{a character string containing SQL.}\n+\\code{\\link[DBI:dbConnect]{dbConnect()}}.}\n \n \\item{name}{A character string specifying the unquoted DBMS table name,\n-or the result of a call to \\code{\\link[=dbQuoteIdentifier]{dbQuoteIdentifier()}}.}\n+or the result of a call to \\code{\\link[DBI:dbQuoteIdentifier]{dbQuoteIdentifier()}}.}\n+\n+\\item{statement}{a character string containing SQL.}\n \n-\\item{value}{a \\link[DBI]{data.frame} (or coercible to data.frame).}\n+\\item{value}{a \\link{data.frame} (or coercible to data.frame).}\n \n \\item{overwrite}{Allow overwriting the destination table. Cannot be\n `TRUE` if `append` is also `TRUE`.}\ndiff --git a/tools/rpkg/man/duckdb-package.Rd b/tools/rpkg/man/duckdb-package.Rd\nindex 98acac9fe5ee..7a6f450f3890 100644\n--- a/tools/rpkg/man/duckdb-package.Rd\n+++ b/tools/rpkg/man/duckdb-package.Rd\n@@ -4,10 +4,31 @@\n \\name{duckdb-package}\n \\alias{duckdb}\n \\alias{duckdb-package}\n-\\title{duckdb: DBI Package for DuckDB}\n+\\title{duckdb: DBI Package for the DuckDB Database Management System}\n \\description{\n-TODO\n+DuckDB is an embedded analytical data management\n+    system with SQL support. This package includes all of DuckDB as well\n+    as R DBI & dplyr connectors.\n }\n \\details{\n TBD.\n }\n+\\seealso{\n+Useful links:\n+\\itemize{\n+  \\item \\url{https://www.duckdb.org}\n+  \\item \\url{https://github.com/cwida/duckdb}\n+  \\item Report bugs at \\url{https://github.com/cwida/duckdb/issues}\n+}\n+\n+}\n+\\author{\n+\\strong{Maintainer}: Hannes M\u00fchleisen \\email{hannes@cwi.nl} (\\href{https://orcid.org/0000-0001-8552-0029}{ORCID})\n+\n+Authors:\n+\\itemize{\n+  \\item Mark Raasveldt \\email{mark.raasveldt@cwi.nl} (\\href{https://orcid.org/0000-0001-5005-6844}{ORCID})\n+  \\item DuckDB Contributors\n+}\n+\n+}\ndiff --git a/tools/rpkg/man/duckdb.Rd b/tools/rpkg/man/duckdb.Rd\nindex 4e5705da65c3..3d5c3d6b0396 100644\n--- a/tools/rpkg/man/duckdb.Rd\n+++ b/tools/rpkg/man/duckdb.Rd\n@@ -4,7 +4,7 @@\n \\alias{duckdb}\n \\title{DuckDB driver}\n \\usage{\n-duckdb()\n+duckdb(dbdir = DBDIR_MEMORY, read_only = FALSE)\n }\n \\description{\n TBD.\n@@ -14,4 +14,5 @@ TBD.\n #' library(DBI)\n duckdb::duckdb()\n }\n+\n }\n",
  "test_patch": "diff --git a/tools/rpkg/tests/testthat.R b/tools/rpkg/tests/testthat.R\nindex 1ae94ea805f3..03b5eae9b505 100644\n--- a/tools/rpkg/tests/testthat.R\n+++ b/tools/rpkg/tests/testthat.R\n@@ -4,25 +4,25 @@ library(\"testthat\")\n test_check(\"duckdb\")\n \n dbplyr_tests <- function() {\n-\tif (!identical(Sys.getenv(\"NOT_CRAN\"), \"true\")) {\n-\t\treturn()\n-\t}\n-\t# the hacky part\n-\tlibrary(\"dbplyr\")\n+  if (!identical(Sys.getenv(\"NOT_CRAN\"), \"true\")) {\n+    return()\n+  }\n+  # the hacky part\n+  library(\"dbplyr\")\n \n-\t# pull dbplyr sources to harvest test cases\n-\tzipfile <- tempfile()\n-\turl <- \"https://github.com/tidyverse/dbplyr/archive/v1.4.2.zip\"\n-\tdownload.file(url, zipfile)\n-\tdbplyr_src <- tempdir()\n-\tunzip(zipfile, exdir=dbplyr_src)\n-\ttests <- Sys.glob(file.path(dbplyr_src, \"dbplyr*\", \"tests\"))\n-\tsetwd(tests)\n+  # pull dbplyr sources to harvest test cases\n+  zipfile <- tempfile()\n+  url <- \"https://github.com/tidyverse/dbplyr/archive/v1.4.2.zip\"\n+  download.file(url, zipfile)\n+  dbplyr_src <- tempdir()\n+  unzip(zipfile, exdir = dbplyr_src)\n+  tests <- Sys.glob(file.path(dbplyr_src, \"dbplyr*\", \"tests\"))\n+  setwd(tests)\n \n-\toptions(duckdb.debug=T)\n-\ttest_register_src(\"duckdb\", duckdb::src_duckdb())\n+  options(duckdb.debug = T)\n+  test_register_src(\"duckdb\", duckdb::src_duckdb())\n \n-\t# TODO fix excluded test cases\n-\ttest_check(\"dbplyr\", stop_on_failure=TRUE,, invert=T, filter=\"(verb-joins|verb-mutate)\")\n+  # TODO fix excluded test cases\n+  test_check(\"dbplyr\", stop_on_failure = TRUE, , invert = T, filter = \"(verb-joins|verb-mutate)\")\n }\n # dbplyr_tests()\ndiff --git a/tools/rpkg/tests/testthat/test-DBItest.R b/tools/rpkg/tests/testthat/test-DBItest.R\nindex 17b26a154542..31ab761ef613 100644\n--- a/tools/rpkg/tests/testthat/test-DBItest.R\n+++ b/tools/rpkg/tests/testthat/test-DBItest.R\n@@ -1,69 +1,69 @@\n-DBItest::make_context(duckdb::duckdb(), list(debug=F), tweaks = DBItest::tweaks(omit_blob_tests=TRUE, temporary_tables=FALSE, timestamp_cast = function(x) sprintf(\"CAST('%s' AS TIMESTAMP)\", x), date_cast = function(x) sprintf(\"CAST('%s' AS DATE)\", x), time_cast = function(x) sprintf(\"CAST('%s' AS TIME)\", x)), name = \"duckdb\")\n+DBItest::make_context(duckdb::duckdb(), list(debug = F), tweaks = DBItest::tweaks(omit_blob_tests = TRUE, temporary_tables = FALSE, timestamp_cast = function(x) sprintf(\"CAST('%s' AS TIMESTAMP)\", x), date_cast = function(x) sprintf(\"CAST('%s' AS DATE)\", x), time_cast = function(x) sprintf(\"CAST('%s' AS TIME)\", x)), name = \"duckdb\")\n \n DBItest::test_all(c(\n-\t\"package_name\", # wontfix\n-\t\"constructor\", # wontfix\n-\t\"send_query_only_one_result_set\", # wontfix\n-\t\"send_statement_only_one_result_set\", # wontfix\n-\t\"send_query_stale_warning\", # wontfix\n-\t\"send_statement_stale_warning\", # wontfix\n+  \"package_name\", # wontfix\n+  \"constructor\", # wontfix\n+  \"send_query_only_one_result_set\", # wontfix\n+  \"send_statement_only_one_result_set\", # wontfix\n+  \"send_query_stale_warning\", # wontfix\n+  \"send_statement_stale_warning\", # wontfix\n \n-\t\"get_query_n_bad\", # broken test\n-\t\"get_query_good_after_bad_n\", # broken test\n-\t\"has_completed_statement\", # broken test\n-\t\"roundtrip_timestamp\", # broken test\n-\t\"data_timestamp\", # broken test (fixed in dev)\n+  \"get_query_n_bad\", # broken test\n+  \"get_query_good_after_bad_n\", # broken test\n+  \"has_completed_statement\", # broken test\n+  \"roundtrip_timestamp\", # broken test\n+  \"data_timestamp\", # broken test (fixed in dev)\n \n-\t\"data_logical\", # casting NULL issue\n+  \"data_logical\", # casting NULL issue\n \n-\t\"data_time_current\",\n-\t\"data_date_current\",\n-\t\"data_timestamp_current\",\n-\t\"data_date_current_typed\",\n-\t\"data_timestamp_current_typed\",\n-\t\"roundtrip_time\",\n-\t\"roundtrip_field_types\", # strange\n-\t\"data_64_bit_numeric_warning\",  # not now\n-\t\"data_64_bit_lossless\",  # not now,\n-\t\"roundtrip_64_bit_character\",\n-\t\"roundtrip_64_bit_numeric\",\n-\t\"roundtrip_numeric_special\",\n+  \"data_time_current\",\n+  \"data_date_current\",\n+  \"data_timestamp_current\",\n+  \"data_date_current_typed\",\n+  \"data_timestamp_current_typed\",\n+  \"roundtrip_time\",\n+  \"roundtrip_field_types\", # strange\n+  \"data_64_bit_numeric_warning\", # not now\n+  \"data_64_bit_lossless\", # not now,\n+  \"roundtrip_64_bit_character\",\n+  \"roundtrip_64_bit_numeric\",\n+  \"roundtrip_numeric_special\",\n \n-\t\"begin_write_commit\",\n-\t\"remove_table_other_con\",\n-\t\"table_visible_in_other_connection\",\n-\t# new tests skipped after DBI upgrade\n-\t\"connect_format\",\n-\t\"connect_bigint_integer\",\n-\t\"connect_bigint_character\",\n-\t\"connect_bigint_integer64\",\n-\t\"create_table_overwrite\",\n-\t\"append_table_return\",\n-\t\"append_table_append_incompatible\",\n-\t\"append_roundtrip_keywords\",\n-\t\"append_roundtrip_quotes\",\n-\t\"append_roundtrip_integer\",\n-\t\"append_roundtrip_numeric\",\n-\t\"append_roundtrip_logical\",\n-\t\"append_roundtrip_null\",\n-\t\"append_roundtrip_64_bit_numeric\",\n-\t\"append_roundtrip_64_bit_character\",\n-\t\"append_roundtrip_64_bit_roundtrip\",\n-\t\"append_roundtrip_character\",\n-\t\"append_roundtrip_character_native\",\n-\t\"append_roundtrip_character_empty\",\n-\t\"append_roundtrip_factor\",\n-\t\"append_roundtrip_date\",\n-\t\"append_roundtrip_time\",\n-\t\"append_roundtrip_timestamp\",\n-\t\"append_table_name\",\n-\t\"append_table_row_names_false\",\n-\t\"remove_table_missing_succeed\",\n-\t\"column_info_closed\",\n-\t\"column_info_consistent\",\n-\t\"column_info_consistent\",\n-\t\"reexport\",\n-\t\"roundtrip_logical\",\n+  \"begin_write_commit\",\n+  \"remove_table_other_con\",\n+  \"table_visible_in_other_connection\",\n+  # new tests skipped after DBI upgrade\n+  \"connect_format\",\n+  \"connect_bigint_integer\",\n+  \"connect_bigint_character\",\n+  \"connect_bigint_integer64\",\n+  \"create_table_overwrite\",\n+  \"append_table_return\",\n+  \"append_table_append_incompatible\",\n+  \"append_roundtrip_keywords\",\n+  \"append_roundtrip_quotes\",\n+  \"append_roundtrip_integer\",\n+  \"append_roundtrip_numeric\",\n+  \"append_roundtrip_logical\",\n+  \"append_roundtrip_null\",\n+  \"append_roundtrip_64_bit_numeric\",\n+  \"append_roundtrip_64_bit_character\",\n+  \"append_roundtrip_64_bit_roundtrip\",\n+  \"append_roundtrip_character\",\n+  \"append_roundtrip_character_native\",\n+  \"append_roundtrip_character_empty\",\n+  \"append_roundtrip_factor\",\n+  \"append_roundtrip_date\",\n+  \"append_roundtrip_time\",\n+  \"append_roundtrip_timestamp\",\n+  \"append_table_name\",\n+  \"append_table_row_names_false\",\n+  \"remove_table_missing_succeed\",\n+  \"column_info_closed\",\n+  \"column_info_consistent\",\n+  \"column_info_consistent\",\n+  \"reexport\",\n+  \"roundtrip_logical\",\n \n-\t\"package_dependencies\"\n-\t))\n+  \"package_dependencies\"\n+))\ndiff --git a/tools/rpkg/tests/testthat/test_bind.R b/tools/rpkg/tests/testthat/test_bind.R\nindex 788e9e667819..675716341a60 100644\n--- a/tools/rpkg/tests/testthat/test_bind.R\n+++ b/tools/rpkg/tests/testthat/test_bind.R\n@@ -2,147 +2,145 @@ library(\"testthat\")\n library(\"DBI\")\n \n test_convert <- function(con, type, val) {\n-\tval_comp <- val\n-\tif (class(val) == \"factor\") {\n-\t\tval_comp <- as.character(val)\n-\t}\n-\tq <- dbSendQuery(con, sprintf(\"SELECT CAST(? AS %s) a\", type))\n-\tdbBind(q, list(val))\n-\tres1 <- dbFetch(q)\n-\tdbBind(q, list(NA))\n-\tres2 <- dbFetch(q)\n-\tdbClearResult(q)\n-\texpect_equal(res1[[1]][1], val_comp)\n-\texpect_true(is.na(res2[[1]][1]))\n-\n-\tdbExecute(con, \"DROP TABLE IF EXISTS bind_test\")\n-\tdbExecute(con, sprintf(\"CREATE TEMPORARY TABLE bind_test(i INTEGER, a %s)\", type))\n-\tq <- dbSendStatement(con, \"INSERT INTO bind_test VALUES ($1, $2)\")\n-\tdbBind(q, list(1, val))\n-\tdbBind(q, list(2, NA))\n-\tdbClearResult(q)\n-\tres3 <- dbGetQuery(con, \"SELECT a FROM bind_test ORDER BY i\")\n-\tdbExecute(con, \"DROP TABLE bind_test\")\n-\n-\texpect_equal(res3[[1]][1], val_comp)\n-\texpect_true(is.na(res3[[1]][2]))\n+  val_comp <- val\n+  if (class(val) == \"factor\") {\n+    val_comp <- as.character(val)\n+  }\n+  q <- dbSendQuery(con, sprintf(\"SELECT CAST(? AS %s) a\", type))\n+  dbBind(q, list(val))\n+  res1 <- dbFetch(q)\n+  dbBind(q, list(NA))\n+  res2 <- dbFetch(q)\n+  dbClearResult(q)\n+  expect_equal(res1[[1]][1], val_comp)\n+  expect_true(is.na(res2[[1]][1]))\n+\n+  dbExecute(con, \"DROP TABLE IF EXISTS bind_test\")\n+  dbExecute(con, sprintf(\"CREATE TEMPORARY TABLE bind_test(i INTEGER, a %s)\", type))\n+  q <- dbSendStatement(con, \"INSERT INTO bind_test VALUES ($1, $2)\")\n+  dbBind(q, list(1, val))\n+  dbBind(q, list(2, NA))\n+  dbClearResult(q)\n+  res3 <- dbGetQuery(con, \"SELECT a FROM bind_test ORDER BY i\")\n+  dbExecute(con, \"DROP TABLE bind_test\")\n+\n+  expect_equal(res3[[1]][1], val_comp)\n+  expect_true(is.na(res3[[1]][2]))\n }\n \n test_that(\"dbBind() works as expected for all types\", {\n-\tcon <- dbConnect(duckdb::duckdb())\n-\ttest_convert(con, \"BOOLEAN\", TRUE)\n-\ttest_convert(con, \"BOOLEAN\", FALSE)\n+  con <- dbConnect(duckdb::duckdb())\n+  test_convert(con, \"BOOLEAN\", TRUE)\n+  test_convert(con, \"BOOLEAN\", FALSE)\n \n-\ttest_convert(con, \"INTEGER\", 42L)\n-\ttest_convert(con, \"INTEGER\", 42)\n+  test_convert(con, \"INTEGER\", 42L)\n+  test_convert(con, \"INTEGER\", 42)\n \n-\ttest_convert(con, \"DOUBLE\", 42L)\n-\ttest_convert(con, \"DOUBLE\", 42.2)\n+  test_convert(con, \"DOUBLE\", 42L)\n+  test_convert(con, \"DOUBLE\", 42.2)\n \n-\ttest_convert(con, \"STRING\", \"Hello, World\")\n-\t\n-\ttest_convert(con, \"DATE\", as.Date(\"2019-11-26\"))\n+  test_convert(con, \"STRING\", \"Hello, World\")\n \n-\ttest_convert(con, \"TIMESTAMP\", as.POSIXct(\"2019-11-26 21:11Z\", \"UTC\"))\n+  test_convert(con, \"DATE\", as.Date(\"2019-11-26\"))\n \n-\ttest_convert(con, \"STRING\", as.factor(\"Hello, World\"))\n-\t\n-\tdbDisconnect(con, shutdown=T)\n+  test_convert(con, \"TIMESTAMP\", as.POSIXct(\"2019-11-26 21:11Z\", \"UTC\"))\n \n+  test_convert(con, \"STRING\", as.factor(\"Hello, World\"))\n+\n+  dbDisconnect(con, shutdown = T)\n })\n \n test_that(\"dbBind() is called from dbGetQuery and dbExecute\", {\n-\tcon <- dbConnect(duckdb::duckdb())\n-\n-\tres <- dbGetQuery(con, \"SELECT CAST (? AS INTEGER), CAST(? AS STRING)\", 42, \"Hello\")\n+  con <- dbConnect(duckdb::duckdb())\n \n-\texpect_equal(res[[1]][1], 42L)\n-\texpect_equal(res[[2]][1], \"Hello\")\n+  res <- dbGetQuery(con, \"SELECT CAST (? AS INTEGER), CAST(? AS STRING)\", 42, \"Hello\")\n \n-\tres <- dbGetQuery(con, \"SELECT CAST (? AS INTEGER), CAST(? AS STRING)\", list(42, \"Hello\"))\n+  expect_equal(res[[1]][1], 42L)\n+  expect_equal(res[[2]][1], \"Hello\")\n \n-\texpect_equal(res[[1]][1], 42L)\n-\texpect_equal(res[[2]][1], \"Hello\")\n+  res <- dbGetQuery(con, \"SELECT CAST (? AS INTEGER), CAST(? AS STRING)\", list(42, \"Hello\"))\n \n+  expect_equal(res[[1]][1], 42L)\n+  expect_equal(res[[2]][1], \"Hello\")\n \n-\tq <- dbSendQuery(con, \"SELECT CAST (? AS INTEGER), CAST(? AS STRING)\", 42, \"Hello\")\n-\t# already have a result\n \n-\tres <- dbFetch(q)\n+  q <- dbSendQuery(con, \"SELECT CAST (? AS INTEGER), CAST(? AS STRING)\", 42, \"Hello\")\n+  # already have a result\n \n-\texpect_equal(res[[1]][1], 42L)\n-\texpect_equal(res[[2]][1], \"Hello\")\n+  res <- dbFetch(q)\n \n+  expect_equal(res[[1]][1], 42L)\n+  expect_equal(res[[2]][1], \"Hello\")\n \n-\t# now bind again\n-\tdbBind(q, list(43, \"Holla\"))\n \n-\tres <- dbFetch(q)\n+  # now bind again\n+  dbBind(q, list(43, \"Holla\"))\n \n-\texpect_equal(res[[1]][1], 43L)\n-\texpect_equal(res[[2]][1], \"Holla\")\n+  res <- dbFetch(q)\n \n+  expect_equal(res[[1]][1], 43L)\n+  expect_equal(res[[2]][1], \"Holla\")\n \n-\tdbClearResult(q)\n \n-\tdbDisconnect(con, shutdown=T)\n+  dbClearResult(q)\n \n+  dbDisconnect(con, shutdown = T)\n })\n \n test_that(\"various error cases for dbBind()\", {\n-\t# testthat::skip(\"eek\")\n-\tcon <- dbConnect(duckdb::duckdb())\n+  # testthat::skip(\"eek\")\n+  con <- dbConnect(duckdb::duckdb())\n \n-\tq <- dbSendQuery(con, \"SELECT CAST (? AS INTEGER)\")\n+  q <- dbSendQuery(con, \"SELECT CAST (? AS INTEGER)\")\n \n-\texpect_error(dbFetch(q))\n+  expect_error(dbFetch(q))\n \n-\texpect_error(dbBind(q, list()))\n-\texpect_error(dbBind(q, list(1, 2)))\n-\texpect_error(dbBind(q, list(\"asdf\", \"asdf\")))\n+  expect_error(dbBind(q, list()))\n+  expect_error(dbBind(q, list(1, 2)))\n+  expect_error(dbBind(q, list(\"asdf\", \"asdf\")))\n \n-\texpect_error(dbBind(q))\n+  expect_error(dbBind(q))\n \n-\texpect_error(dbBind(q, 1))\n-\texpect_error(dbBind(q, 1, 2))\n-\texpect_error(dbBind(q, \"asdf\"))\n-\texpect_error(dbBind(q, \"asdf\", \"asdf\"))\n+  expect_error(dbBind(q, 1))\n+  expect_error(dbBind(q, 1, 2))\n+  expect_error(dbBind(q, \"asdf\"))\n+  expect_error(dbBind(q, \"asdf\", \"asdf\"))\n \n-\tdbClearResult(q)\n+  dbClearResult(q)\n \n-\texpect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", 1, 2))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", \"asdf\"))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", \"asdf\", \"asdf\"))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\"))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", list()))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", list(1, 2)))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", list(\"asdf\")))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", list(\"asdf\", \"asdf\")))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", 1, 2))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", \"asdf\"))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", \"asdf\", \"asdf\"))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\"))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", list()))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", list(1, 2)))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", list(\"asdf\")))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (? AS INTEGER)\", list(\"asdf\", \"asdf\")))\n \n-\tq <- dbSendQuery(con, \"SELECT CAST (42 AS INTEGER)\")\n+  q <- dbSendQuery(con, \"SELECT CAST (42 AS INTEGER)\")\n \n-\tres <- dbFetch(q)\n-\texpect_equal(res[[1]][1], 42L)\n+  res <- dbFetch(q)\n+  expect_equal(res[[1]][1], 42L)\n \n-\texpect_error(dbBind(q, list()))\n-\texpect_error(dbBind(q, list(1)))\n-\texpect_error(dbBind(q, list(\"asdf\")))\n+  expect_error(dbBind(q, list()))\n+  expect_error(dbBind(q, list(1)))\n+  expect_error(dbBind(q, list(\"asdf\")))\n \n-\texpect_error(dbBind(q))\n-\texpect_error(dbBind(q, 1))\n-\texpect_error(dbBind(q, \"asdf\"))\n+  expect_error(dbBind(q))\n+  expect_error(dbBind(q, 1))\n+  expect_error(dbBind(q, \"asdf\"))\n \n-\tdbClearResult(q)\n+  dbClearResult(q)\n \n-\texpect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", 1))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", 1, 2))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", \"asdf\"))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", \"asdf\", \"asdf\"))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", list(1)))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", list(1, 2)))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", list(\"asdf\")))\n-\texpect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", list(\"asdf\", \"asdf\")))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", 1))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", 1, 2))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", \"asdf\"))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", \"asdf\", \"asdf\"))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", list(1)))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", list(1, 2)))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", list(\"asdf\")))\n+  expect_error(dbGetQuery(con, \"SELECT CAST (42 AS INTEGER)\", list(\"asdf\", \"asdf\")))\n \n \n-\tdbDisconnect(con, shutdown=T)\n+  dbDisconnect(con, shutdown = T)\n })\ndiff --git a/tools/rpkg/tests/testthat/test_parquet.R b/tools/rpkg/tests/testthat/test_parquet.R\nindex d212489bf385..275fd22d697d 100644\n--- a/tools/rpkg/tests/testthat/test_parquet.R\n+++ b/tools/rpkg/tests/testthat/test_parquet.R\n@@ -2,7 +2,7 @@ library(\"testthat\")\n library(\"DBI\")\n \n test_that(\"parquet reader works on the notorious userdata1 file\", {\n-\tcon <- dbConnect(duckdb::duckdb())\n-\tres <- dbGetQuery(con, \"SELECT * FROM parquet_scan('userdata1.parquet')\")\n-\tdbDisconnect(con, shutdown=T)\n-})\n\\ No newline at end of file\n+  con <- dbConnect(duckdb::duckdb())\n+  res <- dbGetQuery(con, \"SELECT * FROM parquet_scan('userdata1.parquet')\")\n+  dbDisconnect(con, shutdown = T)\n+})\ndiff --git a/tools/rpkg/tests/testthat/test_read.R b/tools/rpkg/tests/testthat/test_read.R\nindex 49b545abe1ca..8571b4c3be3f 100644\n--- a/tools/rpkg/tests/testthat/test_read.R\n+++ b/tools/rpkg/tests/testthat/test_read.R\n@@ -2,107 +2,106 @@ library(\"testthat\")\n library(\"DBI\")\n \n test_that(\"read_csv_duckdb() works as expected\", {\n-\tcon <- dbConnect(duckdb::duckdb())\n-\t\n-\ttf <- tempfile()\n-\n-\t# default case\n-\twrite.csv(iris, tf, row.names = FALSE)\n-\tread_csv_duckdb(con, tf, \"iris\")\n-\tres <- dbReadTable(con, \"iris\")\n-\tres$Species <- as.factor(res$Species)\n-\texpect_true(identical(res, iris))\n-\n-\t# table exists\n-\tread_csv_duckdb(con, tf, \"iris\")\n-\tcount <- dbGetQuery(con, \"SELECT COUNT(*) FROM iris\")[1][1]\n-\texpect_true(identical(as.integer(count), as.integer(nrow(iris)*2)))\n-\tdbRemoveTable(con, \"iris\")\n-\n-\n-\t# different separator\n-\twrite.table(iris, tf, row.names = FALSE, sep=\" \")\n-\tread_csv_duckdb(con, tf, \"iris\", delim=\" \")\n-\tres <- dbReadTable(con, \"iris\")\n-\tres$Species <- as.factor(res$Species)\n-\texpect_true(identical(res, iris))\n-\tdbRemoveTable(con, \"iris\")\n-\n-\twrite.table(iris, tf, row.names = FALSE, sep=\" \")\n-\tread_csv_duckdb(con, tf, \"iris\", sep=\" \")\n-\tres <- dbReadTable(con, \"iris\")\n-\tres$Species <- as.factor(res$Species)\n-\texpect_true(identical(res, iris))\n-\tdbRemoveTable(con, \"iris\")\n-\n-\t# no header\n-\twrite.table(iris, tf, row.names = FALSE, sep=\",\", col.names=FALSE)\n-\tread_csv_duckdb(con, tf, \"iris\", header=FALSE)\n-\tres <- dbReadTable(con, \"iris\")\n-\tnames(res) <- names(iris)\n-\tres$Species <- as.factor(res$Species)\n-\texpect_true(identical(res, iris))\n-\tdbRemoveTable(con, \"iris\")\n-\n-\t# lowercase header\n-\twrite.csv(iris, tf, row.names = FALSE)\n-\tread_csv_duckdb(con, tf, \"iris\", lower.case.names=T)\n-\tres <- dbReadTable(con, \"iris\")\n-\tres$species <- as.factor(res$species)\n-\tiris_lc <- iris\n-\tnames(iris_lc) <- tolower(names(iris))\n-\texpect_true(identical(res, iris_lc))\n-\tdbRemoveTable(con, \"iris\")\n-\n-\t# nulls\n-\tiris_na <- iris\n-\tiris_na[[2]][42] <- NA\n-\n-\twrite.csv(iris_na, tf, row.names = FALSE, na=\"\")\n-\tread_csv_duckdb(con, tf, \"iris\")\n-\tres <- dbReadTable(con, \"iris\")\n-\tres$Species <- as.factor(res$Species)\n-\texpect_true(identical(res, iris_na))\n-\tdbRemoveTable(con, \"iris\")\n-\n-\n-\twrite.csv(iris_na, tf, row.names = FALSE, na=\"NULL\")\n-\tread_csv_duckdb(con, tf, \"iris\", na.strings=\"NULL\")\n-\tres <- dbReadTable(con, \"iris\")\n-\tres$Species <- as.factor(res$Species)\n-\texpect_true(identical(res, iris_na))\n-\tdbRemoveTable(con, \"iris\")\n-\n-\n-\t# strange table name\n-\twrite.csv(iris, tf, row.names = FALSE)\n-\tread_csv_duckdb(con, tf, \"ir Is\")\n-\tres <- dbReadTable(con, \"ir Is\")\n-\tres$Species <- as.factor(res$Species)\n-\texpect_true(identical(res, iris))\n-\tdbRemoveTable(con, \"ir Is\")\n-\n-\n-\t# specified column names\n-\tcolnames <- paste0(\"c\", 1:5)\n-\twrite.csv(iris, tf, row.names = FALSE)\n-\tread_csv_duckdb(con, tf, \"iris\", col.names=colnames)\n-\tres <- dbReadTable(con, \"iris\")\n-\tres$c5 <- as.factor(res$c5)\n-\tiris_c <- iris\n-\tnames(iris_c) <- colnames\n-\texpect_true(identical(res, iris_c))\n-\tdbRemoveTable(con, \"iris\")\n-\n-\n-\t# multiple files\n-\ttf2 <- tempfile()\n-\twrite.csv(iris, tf2, row.names = FALSE)\n-\tread_csv_duckdb(con, c(tf, tf2), \"iris\")\n-\tcount <- dbGetQuery(con, \"SELECT COUNT(*) FROM iris\")[1][1]\n-\texpect_true(identical(as.integer(count), as.integer(nrow(iris)*2)))\n-\tdbRemoveTable(con, \"iris\")\n-\n-\tdbDisconnect(con, shutdown=T)\n-\n+  con <- dbConnect(duckdb::duckdb())\n+\n+  tf <- tempfile()\n+\n+  # default case\n+  write.csv(iris, tf, row.names = FALSE)\n+  read_csv_duckdb(con, tf, \"iris\")\n+  res <- dbReadTable(con, \"iris\")\n+  res$Species <- as.factor(res$Species)\n+  expect_true(identical(res, iris))\n+\n+  # table exists\n+  read_csv_duckdb(con, tf, \"iris\")\n+  count <- dbGetQuery(con, \"SELECT COUNT(*) FROM iris\")[1][1]\n+  expect_true(identical(as.integer(count), as.integer(nrow(iris) * 2)))\n+  dbRemoveTable(con, \"iris\")\n+\n+\n+  # different separator\n+  write.table(iris, tf, row.names = FALSE, sep = \" \")\n+  read_csv_duckdb(con, tf, \"iris\", delim = \" \")\n+  res <- dbReadTable(con, \"iris\")\n+  res$Species <- as.factor(res$Species)\n+  expect_true(identical(res, iris))\n+  dbRemoveTable(con, \"iris\")\n+\n+  write.table(iris, tf, row.names = FALSE, sep = \" \")\n+  read_csv_duckdb(con, tf, \"iris\", sep = \" \")\n+  res <- dbReadTable(con, \"iris\")\n+  res$Species <- as.factor(res$Species)\n+  expect_true(identical(res, iris))\n+  dbRemoveTable(con, \"iris\")\n+\n+  # no header\n+  write.table(iris, tf, row.names = FALSE, sep = \",\", col.names = FALSE)\n+  read_csv_duckdb(con, tf, \"iris\", header = FALSE)\n+  res <- dbReadTable(con, \"iris\")\n+  names(res) <- names(iris)\n+  res$Species <- as.factor(res$Species)\n+  expect_true(identical(res, iris))\n+  dbRemoveTable(con, \"iris\")\n+\n+  # lowercase header\n+  write.csv(iris, tf, row.names = FALSE)\n+  read_csv_duckdb(con, tf, \"iris\", lower.case.names = T)\n+  res <- dbReadTable(con, \"iris\")\n+  res$species <- as.factor(res$species)\n+  iris_lc <- iris\n+  names(iris_lc) <- tolower(names(iris))\n+  expect_true(identical(res, iris_lc))\n+  dbRemoveTable(con, \"iris\")\n+\n+  # nulls\n+  iris_na <- iris\n+  iris_na[[2]][42] <- NA\n+\n+  write.csv(iris_na, tf, row.names = FALSE, na = \"\")\n+  read_csv_duckdb(con, tf, \"iris\")\n+  res <- dbReadTable(con, \"iris\")\n+  res$Species <- as.factor(res$Species)\n+  expect_true(identical(res, iris_na))\n+  dbRemoveTable(con, \"iris\")\n+\n+\n+  write.csv(iris_na, tf, row.names = FALSE, na = \"NULL\")\n+  read_csv_duckdb(con, tf, \"iris\", na.strings = \"NULL\")\n+  res <- dbReadTable(con, \"iris\")\n+  res$Species <- as.factor(res$Species)\n+  expect_true(identical(res, iris_na))\n+  dbRemoveTable(con, \"iris\")\n+\n+\n+  # strange table name\n+  write.csv(iris, tf, row.names = FALSE)\n+  read_csv_duckdb(con, tf, \"ir Is\")\n+  res <- dbReadTable(con, \"ir Is\")\n+  res$Species <- as.factor(res$Species)\n+  expect_true(identical(res, iris))\n+  dbRemoveTable(con, \"ir Is\")\n+\n+\n+  # specified column names\n+  colnames <- paste0(\"c\", 1:5)\n+  write.csv(iris, tf, row.names = FALSE)\n+  read_csv_duckdb(con, tf, \"iris\", col.names = colnames)\n+  res <- dbReadTable(con, \"iris\")\n+  res$c5 <- as.factor(res$c5)\n+  iris_c <- iris\n+  names(iris_c) <- colnames\n+  expect_true(identical(res, iris_c))\n+  dbRemoveTable(con, \"iris\")\n+\n+\n+  # multiple files\n+  tf2 <- tempfile()\n+  write.csv(iris, tf2, row.names = FALSE)\n+  read_csv_duckdb(con, c(tf, tf2), \"iris\")\n+  count <- dbGetQuery(con, \"SELECT COUNT(*) FROM iris\")[1][1]\n+  expect_true(identical(as.integer(count), as.integer(nrow(iris) * 2)))\n+  dbRemoveTable(con, \"iris\")\n+\n+  dbDisconnect(con, shutdown = T)\n })\ndiff --git a/tools/rpkg/tests/testthat/test_readonly.R b/tools/rpkg/tests/testthat/test_readonly.R\nindex 5df07039f1b1..624e6bcf5fbc 100644\n--- a/tools/rpkg/tests/testthat/test_readonly.R\n+++ b/tools/rpkg/tests/testthat/test_readonly.R\n@@ -1,57 +1,57 @@\n library(testthat)\n \n test_that(\"read_only flag and shutdown works as expected\", {\n-\tlibrary(\"DBI\")\n+  library(\"DBI\")\n \n-\tdbdir <- tempfile()\n+  dbdir <- tempfile()\n \n-\t# 1st: create a db and write some tables\n+  # 1st: create a db and write some tables\n \n-\tcallr::r(function(dbdir) {\n-\t\tlibrary(\"DBI\")\n-\t\tcon <- dbConnect(duckdb::duckdb(), dbdir, read_only=FALSE) # FALSE is the default\n-\t\tprint(con)\n-\t\tres <- dbWriteTable(con, \"iris\", iris)\n-\t\tdbDisconnect(con)\n-\t\tduckdb::duckdb_shutdown(con@driver)\n-\t}, args = list(dbdir))\n+  callr::r(function(dbdir) {\n+    library(\"DBI\")\n+    con <- dbConnect(duckdb::duckdb(), dbdir, read_only = FALSE) # FALSE is the default\n+    print(con)\n+    res <- dbWriteTable(con, \"iris\", iris)\n+    dbDisconnect(con)\n+    duckdb::duckdb_shutdown(con@driver)\n+  }, args = list(dbdir))\n \n \n-\t# 2nd: start two parallel read-only references\n-\tdrv <- duckdb::duckdb(dbdir, read_only=TRUE)\n-\tcon <- dbConnect(drv)\n+  # 2nd: start two parallel read-only references\n+  drv <- duckdb::duckdb(dbdir, read_only = TRUE)\n+  con <- dbConnect(drv)\n \n-\tres <- dbReadTable(con, \"iris\")\n+  res <- dbReadTable(con, \"iris\")\n \n \n-\t# can have another conn on this drv\n-\tcon2 <- dbConnect(drv)\n-\tres <- dbReadTable(con2, \"iris\")\n+  # can have another conn on this drv\n+  con2 <- dbConnect(drv)\n+  res <- dbReadTable(con2, \"iris\")\n \n-\t# con is still alive\n-\tcallr::r(function(dbdir) {\n-\t\tlibrary(\"DBI\")\n-\t\tcon <- dbConnect(duckdb::duckdb(), dbdir, read_only=TRUE)\n-\t\tres <- dbReadTable(con, \"iris\")\n-\t\tdbDisconnect(con, shutdown=TRUE)\n-\t}, args = list(dbdir))\n+  # con is still alive\n+  callr::r(function(dbdir) {\n+    library(\"DBI\")\n+    con <- dbConnect(duckdb::duckdb(), dbdir, read_only = TRUE)\n+    res <- dbReadTable(con, \"iris\")\n+    dbDisconnect(con, shutdown = TRUE)\n+  }, args = list(dbdir))\n \n-\t# shut down one of them again\n-\tres <- dbReadTable(con, \"iris\")\n+  # shut down one of them again\n+  res <- dbReadTable(con, \"iris\")\n \n-\tdbDisconnect(con)\n-\tdbDisconnect(con2, shutdown=TRUE)\n-\tduckdb::duckdb_shutdown(con@driver)\n+  dbDisconnect(con)\n+  dbDisconnect(con2, shutdown = TRUE)\n+  duckdb::duckdb_shutdown(con@driver)\n \n \n-\t# now we can get write access again\n-\t# TODO shutdown\n-\tcallr::r(function(dbdir) {\n-\t\tlibrary(\"DBI\")\n-\t\tcon <- dbConnect(duckdb::duckdb(), dbdir, read_only=FALSE) # FALSE is the default\n-\t\tres <- dbWriteTable(con, \"iris2\", iris)\n-\t\tdbDisconnect(con)\n-\t}, args = list(dbdir))\n+  # now we can get write access again\n+  # TODO shutdown\n+  callr::r(function(dbdir) {\n+    library(\"DBI\")\n+    con <- dbConnect(duckdb::duckdb(), dbdir, read_only = FALSE) # FALSE is the default\n+    res <- dbWriteTable(con, \"iris2\", iris)\n+    dbDisconnect(con)\n+  }, args = list(dbdir))\n \n-\texpect_true(T)\n+  expect_true(T)\n })\ndiff --git a/tools/rpkg/tests/testthat/test_register.R b/tools/rpkg/tests/testthat/test_register.R\nindex 003f412fd5f7..5de72c3d48d5 100644\n--- a/tools/rpkg/tests/testthat/test_register.R\n+++ b/tools/rpkg/tests/testthat/test_register.R\n@@ -3,56 +3,55 @@ library(\"DBI\")\n \n \n test_that(\"duckdb_register() works\", {\n-\tcon <- dbConnect(duckdb::duckdb())\n-\t\n-\t# most basic case\n-\tduckdb::duckdb_register(con, \"my_df1\", iris)\n-\tres <- dbReadTable(con, \"my_df1\")\n-\tres$Species <- as.factor(res$Species)\n-\texpect_true(identical(res, iris))\n-\tduckdb::duckdb_unregister(con, \"my_df1\")\n-\n-\tduckdb::duckdb_register(con, \"my_df2\", mtcars)\n-\tres <- dbReadTable(con, \"my_df2\")\n-\trow.names(res) <- row.names(mtcars)\n-\texpect_true(identical(res, mtcars))\n-\tduckdb::duckdb_unregister(con, \"my_df2\")\n-\n-\tduckdb::duckdb_register(con, \"my_df1\", mtcars)\n-\tres <- dbReadTable(con, \"my_df1\")\n-\trow.names(res) <- row.names(mtcars)\n-\texpect_true(identical(res, mtcars))\n-\n- \t# do not need unregister, can simply overwrite\n-\tduckdb::duckdb_register(con, \"my_df1\", iris)\n-\tres <- dbReadTable(con, \"my_df1\")\n-\tres$Species <- as.factor(res$Species)\n-\texpect_true(identical(res, iris))\n-\n-\tduckdb::duckdb_unregister(con, \"my_df1\")\n-\tduckdb::duckdb_unregister(con, \"my_df2\")\n-\tduckdb::duckdb_unregister(con, \"xxx\")\n-\n-\t# this needs to be empty now\n-\texpect_true(length(attributes(con@conn_ref)) == 0)\n-\n-\tdbDisconnect(con, shutdown=T)\n+  con <- dbConnect(duckdb::duckdb())\n+\n+  # most basic case\n+  duckdb::duckdb_register(con, \"my_df1\", iris)\n+  res <- dbReadTable(con, \"my_df1\")\n+  res$Species <- as.factor(res$Species)\n+  expect_true(identical(res, iris))\n+  duckdb::duckdb_unregister(con, \"my_df1\")\n+\n+  duckdb::duckdb_register(con, \"my_df2\", mtcars)\n+  res <- dbReadTable(con, \"my_df2\")\n+  row.names(res) <- row.names(mtcars)\n+  expect_true(identical(res, mtcars))\n+  duckdb::duckdb_unregister(con, \"my_df2\")\n+\n+  duckdb::duckdb_register(con, \"my_df1\", mtcars)\n+  res <- dbReadTable(con, \"my_df1\")\n+  row.names(res) <- row.names(mtcars)\n+  expect_true(identical(res, mtcars))\n+\n+  # do not need unregister, can simply overwrite\n+  duckdb::duckdb_register(con, \"my_df1\", iris)\n+  res <- dbReadTable(con, \"my_df1\")\n+  res$Species <- as.factor(res$Species)\n+  expect_true(identical(res, iris))\n+\n+  duckdb::duckdb_unregister(con, \"my_df1\")\n+  duckdb::duckdb_unregister(con, \"my_df2\")\n+  duckdb::duckdb_unregister(con, \"xxx\")\n+\n+  # this needs to be empty now\n+  expect_true(length(attributes(con@conn_ref)) == 0)\n+\n+  dbDisconnect(con, shutdown = T)\n })\n \n \n test_that(\"various error cases for duckdb_register()\", {\n-\tcon <- dbConnect(duckdb::duckdb())\n+  con <- dbConnect(duckdb::duckdb())\n \n-\tduckdb::duckdb_register(con, \"my_df1\", iris)\n-\tduckdb::duckdb_unregister(con, \"my_df1\")\n-\texpect_error(dbReadTable(con, \"my_df1\"))\n+  duckdb::duckdb_register(con, \"my_df1\", iris)\n+  duckdb::duckdb_unregister(con, \"my_df1\")\n+  expect_error(dbReadTable(con, \"my_df1\"))\n \n-\texpect_error(duckdb::duckdb_register(1, \"my_df1\", iris))\n-\texpect_error(duckdb::duckdb_register(con, \"\", iris))\n-\texpect_error(duckdb::duckdb_unregister(1, \"my_df1\"))\n-\texpect_error(duckdb::duckdb_unregister(con, \"\"))\n-\tdbDisconnect(con, shutdown=T)\n-\n-\texpect_error(duckdb::duckdb_unregister(con, \"my_df1\"))\n+  expect_error(duckdb::duckdb_register(1, \"my_df1\", iris))\n+  expect_error(duckdb::duckdb_register(con, \"\", iris))\n+  expect_error(duckdb::duckdb_unregister(1, \"my_df1\"))\n+  expect_error(duckdb::duckdb_unregister(con, \"\"))\n+  dbDisconnect(con, shutdown = T)\n \n+  expect_error(duckdb::duckdb_unregister(con, \"my_df1\"))\n })\n",
  "problem_statement": "R: Tidy package\n- [x] Apply tidyverse coding style\r\n- [x] Update roxygen version\r\n- [x] Update package description\r\n- [x] Tidy DESCRIPTION\r\n\n",
  "hints_text": "",
  "created_at": "2020-06-23T16:15:35Z"
}