You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
R: Tidy package
- [x] Apply tidyverse coding style
- [x] Update roxygen version
- [x] Update package description
- [x] Tidy DESCRIPTION


</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="30">
2: 
3: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of tools/rpkg/.gitignore]
1: src/duckdb
2: *.tar.gz
3: *.tgz
4: src/Makevars
5: /src/
[end of tools/rpkg/.gitignore]
[start of tools/rpkg/DESCRIPTION]
1: Package: duckdb
2: Title: DBI Package for the DuckDB Database Management System
3: Version: 0.2.0
4: Authors@R: c(person("Hannes", "M\u00fchleisen", role = c("aut", "cre"), email = "hannes@cwi.nl", comment = c(ORCID = "0000-0001-8552-0029")), person("Mark", "Raasveldt", role = c("aut"), email = "mark.raasveldt@cwi.nl", comment = c(ORCID = "0000-0001-5005-6844")), person(given = "DuckDB Contributors", role = "aut"))
5: Description: DuckDB is an embedded analytical data management system with SQL support. This package includes all of DuckDB as well as R DBI & dplyr connectors.
6: Depends:
7:     R (>= 3.5.0),
8:     DBI
9: License: MPL
10: LazyData: true
11: Encoding: UTF-8
12: Imports:
13:     dbplyr,
14:     methods,
15:     testthat,
16:     utils
17: Suggests:
18:     DBItest,
19:     callr
20: URL: https://www.duckdb.org, https://github.com/cwida/duckdb
21: BugReports: https://github.com/cwida/duckdb/issues
22: Collate:
23:     'duckdb.R'
24:     'Driver.R'
25:     'Connection.R'
26:     'Result.R'
27: RoxygenNote: 6.1.1
28: SystemRequirements: C++11
[end of tools/rpkg/DESCRIPTION]
[start of tools/rpkg/NAMESPACE]
1: # Generated by roxygen2: do not edit by hand
2: 
3: export(duckdb)
4: export(duckdb_shutdown)
5: export(duckdb_register)
6: export(duckdb_unregister)
7: export(src_duckdb)
8: export(read_csv_duckdb)
9: export(duckdb.read.csv)
10: 
11: exportClasses(duckdb_connection)
12: exportClasses(duckdb_driver)
13: exportClasses(duckdb_result)
14: exportMethods(dbBegin)
15: exportMethods(dbBind)
16: exportMethods(dbClearResult)
17: exportMethods(dbColumnInfo)
18: exportMethods(dbCommit)
19: exportMethods(dbConnect)
20: exportMethods(dbDataType)
21: exportMethods(dbDisconnect)
22: exportMethods(dbExistsTable)
23: exportMethods(dbFetch)
24: exportMethods(dbGetInfo)
25: exportMethods(dbGetRowCount)
26: exportMethods(dbGetRowsAffected)
27: exportMethods(dbGetStatement)
28: exportMethods(dbHasCompleted)
29: exportMethods(dbIsValid)
30: exportMethods(dbListFields)
31: exportMethods(dbListTables)
32: exportMethods(dbRemoveTable)
33: exportMethods(dbRollback)
34: exportMethods(dbSendQuery)
35: exportMethods(dbWriteTable)
36: exportMethods(show)
37: import(DBI)
38: import(methods)
39: importFrom(DBI,dbConnect)
40: importFrom(dbplyr,src_dbi)
41: importFrom(testthat,skip)
42: importFrom(utils,head)
43: useDynLib(duckdb , .registration = TRUE)
[end of tools/rpkg/NAMESPACE]
[start of tools/rpkg/R/Connection.R]
1: #' @include Driver.R
2: 
3: NULL
4: 
5: 
6: duckdb_connection <- function(duckdb_driver, debug) {
7:   new(
8:     "duckdb_connection",
9:     conn_ref = .Call(duckdb_connect_R, duckdb_driver@database_ref),
10:     driver = duckdb_driver,
11:     debug = debug
12:   )
13: }
14: 
15: duckdb_register <- function(conn, name, df) {
16:   stopifnot(dbIsValid(conn))
17:   .Call(duckdb_register_R, conn@conn_ref, as.character(name), as.data.frame(df))
18:   invisible(TRUE)
19: }
20: 
21: duckdb_unregister <- function(conn, name) {
22:   stopifnot(dbIsValid(conn))
23:   .Call(duckdb_unregister_R, conn@conn_ref, as.character(name))
24:   invisible(TRUE)
25: }
26: 
27: 
28: #' @rdname DBI
29: #' @export
30: setClass(
31:   "duckdb_connection",
32:   contains = "DBIConnection",
33:   slots = list(dbdir= "character", conn_ref = "externalptr", driver = "duckdb_driver", debug="logical")
34: )
35: 
36: #' @rdname DBI
37: #' @inheritParams methods::show
38: #' @export
39: setMethod("show", "duckdb_connection",
40:           function(object) {
41:             cat(sprintf("<duckdb_connection %s driver=%s>\n", extptr_str(object@conn_ref), drv_to_string(object@driver)))
42:           })
43: 
44: #' @rdname DBI
45: #' @inheritParams DBI::dbIsValid
46: #' @export
47: setMethod("dbIsValid", "duckdb_connection",
48:           function(dbObj, ...) {
49:             valid <- FALSE
50:             tryCatch ({
51:               dbGetQuery(dbObj, SQL("SELECT 1"))
52:               valid <- TRUE
53:             }, error = function(c) {
54:             })
55:             valid
56:           })
57: 
58: #' @rdname DBI
59: #' @inheritParams DBI::dbDisconnect
60: #' @export
61: setMethod("dbDisconnect", "duckdb_connection",
62:           function(conn, ..., shutdown=FALSE) {
63:             if (!dbIsValid(conn)) {
64:               warning("Connection already closed.", call. = FALSE)
65:             }
66:             .Call(duckdb_disconnect_R, conn@conn_ref)
67:             if (shutdown) {
68:               duckdb_shutdown(conn@driver)
69:             }
70: 
71:             invisible(TRUE)
72:           })
73: 
74: #' @rdname DBI
75: #' @inheritParams DBI::dbSendQuery
76: #' @export
77: setMethod("dbSendQuery", c("duckdb_connection", "character"),
78:           function(conn, statement, ..., immediate=FALSE) {
79:             if (conn@debug) {
80:               cat("Q ", statement, "\n")
81:             }
82: 		        statement <- enc2utf8(statement)
83:             stmt_lst <- .Call(duckdb_prepare_R, conn@conn_ref, statement)
84: 
85:             res <- duckdb_result(
86:               connection = conn,
87:               stmt_lst = stmt_lst
88:             )
89:             params <- list(...)
90:             if (length(params) == 1 && class(params[[1]])[[1]] == "list") {
91:               params <- params[[1]]
92:             }
93:             if (length(params) > 0) {
94:               dbBind(res, params)
95:             }
96:             return(res)
97:           })
98: 
99: 
100: #' @rdname DBI
101: #' @inheritParams DBI::dbDataType
102: #' @export
103: setMethod("dbDataType", "duckdb_connection",
104:           function(dbObj, obj, ...) {
105:             dbDataType(dbObj@driver, obj, ...)
106:           })
107: 
108: duckdb_random_string <- function(x) {
109: 	paste(sample(letters, 10, replace = TRUE), collapse="")
110: }
111: 
112: #' @rdname DBI
113: #' @inheritParams DBI::dbWriteTable
114: #' @param overwrite Allow overwriting the destination table. Cannot be
115: #'   `TRUE` if `append` is also `TRUE`.
116: #' @param append Allow appending to the destination table. Cannot be
117: #'   `TRUE` if `overwrite` is also `TRUE`.
118: #' @export
119: setMethod("dbWriteTable", c("duckdb_connection", "character", "data.frame"),
120:           function(conn,
121:                    name,
122:                    value,
123:                    row.names = FALSE,
124:                    overwrite = FALSE,
125:                    append = FALSE,
126:                    field.types = NULL,
127:                    temporary = FALSE,
128:                    ...) {
129:             check_flag(overwrite)
130:             check_flag(append)
131:             check_flag(temporary)
132: 
133:             # TODO: start a transaction if one is not already running
134: 
135: 
136:             if (overwrite && append) {
137:               stop("Setting both overwrite and append makes no sense")
138:             }
139: 
140:             # oof
141:             if (!is.null(field.types) &&
142:                 (
143:                   !is.character(field.types) ||
144:                   any(is.na(names(field.types))) ||
145:                   length(unique(names(field.types))) != length(names(field.types)) ||
146:                   append
147:                 )) {
148:               stop("invalid field.types argument")
149:             }
150:             value <- as.data.frame(value)
151:             if (!is.data.frame(value)) {
152:               stop("need a data frame as parameter")
153:             }
154: 
155:             # use Kirill's magic, convert rownames to additional column
156:             value <- sqlRownamesToColumn(value, row.names)
157: 
158:             if (dbExistsTable(conn, name)) {
159:               if (overwrite) {
160:                 dbRemoveTable(conn, name)
161:               }
162:               if (!overwrite && !append) {
163:                 stop(
164:                   "Table ",
165:                   name,
166:                   " already exists. Set overwrite=TRUE if you want
167:                   to remove the existing table. Set append=TRUE if you would like to add the new data to the
168:                   existing table."
169:                 )
170:               }
171:               if (append && any(names(value) != dbListFields(conn, name))) {
172:                 stop("Column name mismatch for append")
173:               }
174:               }
175:             table_name <- dbQuoteIdentifier(conn, name)
176: 
177:             if (!dbExistsTable(conn, name)) {
178:               column_names <- dbQuoteIdentifier(conn, names(value))
179:               column_types <-
180:                 vapply(value, dbDataType, dbObj = conn, FUN.VALUE = "character")
181: 
182:               if (!is.null(field.types)) {
183:                 mapped_column_types <- field.types[names(value)]
184:                 if (any(is.na(mapped_column_types)) ||
185:                     length(mapped_column_types) != length(names(value))) {
186:                   stop("Column name/type mismatch")
187:                 }
188:                 column_types <- mapped_column_types
189:               }
190: 
191:               temp_str <- ""
192:               if (temporary) temp_str <- "TEMPORARY"
193: 
194:               schema_str <- paste(column_names, column_types, collapse = ", ")
195:               dbExecute(conn, SQL(sprintf(
196:                 "CREATE %s TABLE %s (%s)", temp_str, table_name, schema_str
197:               )))
198:             }
199: 
200: 			if (length(value[[1]])) {
201: 				classes <- unlist(lapply(value, function(v){
202: 				  class(v)[[1]]
203: 				}))
204: 				for (c in names(classes[classes=="character"])) {
205: 				  value[[c]] <- enc2utf8(value[[c]])
206: 				}
207: 				for (c in names(classes[classes=="factor"])) {
208: 				  levels(value[[c]]) <- enc2utf8(levels(value[[c]]))
209: 				}
210: 			}
211: 			view_name <- sprintf("_duckdb_append_view_%s", duckdb_random_string())
212:             on.exit(duckdb_unregister(conn, view_name))
213:             duckdb_register(conn, view_name, value)
214:             dbExecute(conn, sprintf("INSERT INTO %s SELECT * FROM %s", table_name, view_name))
215: 
216:             invisible(TRUE)
217:           })
218: 
219: #' @rdname DBI
220: #' @inheritParams DBI::dbListTables
221: #' @export
222: setMethod("dbListTables", "duckdb_connection",
223:           function(conn, ...) {
224:             dbGetQuery(conn,
225:                        SQL(
226:                          "SELECT name FROM sqlite_master() WHERE type='table' ORDER BY name"
227:                        ))[[1]]
228:           })
229: 
230: #' @rdname DBI
231: #' @inheritParams DBI::dbExistsTable
232: #' @export
233: setMethod("dbExistsTable", c("duckdb_connection", "character"),
234:           function(conn, name, ...) {
235:             if (!dbIsValid(conn)) {
236:               stop("Invalid connection")
237:             }
238:             if (length(name) != 1) {
239:               stop("Can only have a single name argument")
240:             }
241:             exists <- FALSE
242:             tryCatch ({
243:               dbGetQuery(conn,
244:                          sqlInterpolate(
245:                            conn,
246:                            "SELECT * FROM ? WHERE FALSE",
247:                            dbQuoteIdentifier(conn, name)
248:                          ))
249:               exists <- TRUE
250:             }, error = function(c) {
251:             })
252:             exists
253:           })
254: 
255: #' @rdname DBI
256: #' @inheritParams DBI::dbListFields
257: #' @export
258: setMethod("dbListFields", c("duckdb_connection", "character"),
259:           function(conn, name, ...) {
260:             names(dbGetQuery(
261:               conn,
262:               sqlInterpolate(
263:                 conn,
264:                 "SELECT * FROM ? WHERE FALSE",
265:                 dbQuoteIdentifier(conn, name)
266:               )
267:             ))
268:           })
269: 
270: #' @rdname DBI
271: #' @inheritParams DBI::dbRemoveTable
272: #' @export
273: setMethod("dbRemoveTable", c("duckdb_connection", "character"),
274:           function(conn, name, ...) {
275:             dbExecute(conn,
276:                       sqlInterpolate(conn, "DROP TABLE ?", dbQuoteIdentifier(conn, name)))
277:             invisible(TRUE)
278:           })
279: 
280: #' @rdname DBI
281: #' @inheritParams DBI::dbGetInfo
282: #' @export
283: setMethod("dbGetInfo", "duckdb_connection",
284:           function(dbObj, ...) {
285:             list(
286:               dbname = dbObj@dbdir,
287:               db.version = NA,
288:               username = NA,
289:               host = NA,
290:               port = NA
291:             )
292:           })
293: 
294: #' @rdname DBI
295: #' @inheritParams DBI::dbBegin
296: #' @export
297: setMethod("dbBegin", "duckdb_connection",
298:           function(conn, ...) {
299:             dbExecute(conn, SQL("BEGIN TRANSACTION"))
300:             invisible(TRUE)
301:           })
302: 
303: #' @rdname DBI
304: #' @inheritParams DBI::dbCommit
305: #' @export
306: setMethod("dbCommit", "duckdb_connection",
307:           function(conn, ...) {
308:             dbExecute(conn, SQL("COMMIT"))
309:             invisible(TRUE)
310:           })
311: 
312: #' @rdname DBI
313: #' @inheritParams DBI::dbRollback
314: #' @export
315: setMethod("dbRollback", "duckdb_connection",
316:           function(conn, ...) {
317:             dbExecute(conn, SQL("ROLLBACK"))
318:             invisible(TRUE)
319:           })
320: 
321: 
322: read_csv_duckdb <- duckdb.read.csv <- function(conn, files, tablename, header=TRUE, na.strings="", nrow.check=500,
323:                                                delim=",", quote="\"", col.names=NULL, lower.case.names=FALSE, sep=delim, transaction=TRUE, ...){
324: 
325:   if (length(na.strings)>1) stop("na.strings must be of length 1")
326:   if (!missing(sep)) delim <- sep
327: 
328:   headers <- lapply(files, utils::read.csv, sep=delim, na.strings=na.strings, quote=quote, nrows=nrow.check, header=header, ...)
329:   if (length(files)>1){
330:     nn <- sapply(headers, ncol)
331:     if (!all(nn==nn[1])) stop("Files have different numbers of columns")
332:     nms <- sapply(headers, names)
333:     if(!all(nms==nms[, 1])) stop("Files have different variable names")
334:     types <- sapply(headers, function(df) sapply(df, dbDataType, dbObj=conn))
335:     if(!all(types==types[, 1])) stop("Files have different variable types")
336:   }
337: 
338:   if (transaction) {
339:      dbBegin(conn)
340:      on.exit(tryCatch(dbRollback(conn), error=function(e){}))
341:   }
342: 
343:   tablename <- dbQuoteIdentifier(conn, tablename)
344: 
345:   if (!dbExistsTable(conn, tablename)) {
346:     if(lower.case.names) names(headers[[1]]) <- tolower(names(headers[[1]]))
347:     if(!is.null(col.names)) {
348:       if (lower.case.names) {
349:         warning("Ignoring lower.case.names parameter as overriding col.names are supplied.")
350:       }
351:       col.names <- as.character(col.names)
352:       if (length(unique(col.names)) != length(names(headers[[1]]))) {
353:         stop("You supplied ", length(unique(col.names)), " unique column names, but file has ",
354:           length(names(headers[[1]])), " columns.")
355:       }
356:       names(headers[[1]]) <-  col.names
357:     }
358:     dbWriteTable(conn, tablename, headers[[1]][FALSE, ,drop=FALSE])
359:   }
360: 
361:   for(i in seq_along(files)) {
362:     thefile <- dbQuoteString(conn, encodeString(normalizePath(files[i])))
363:     dbExecute(conn, sprintf("COPY %s FROM %s (DELIMITER %s, QUOTE %s, HEADER %s, NULL %s)", tablename, thefile, dbQuoteString(conn, delim), dbQuoteString(conn,quote), tolower(header), dbQuoteString(conn, na.strings[1])))
364:   }
365:   dbGetQuery(conn, paste("SELECT COUNT(*) FROM", tablename))[[1]]
366: 
367:   if (transaction) {
368:     dbCommit(conn)
369:     on.exit(NULL)
370:   }
371: }
[end of tools/rpkg/R/Connection.R]
[start of tools/rpkg/R/Driver.R]
1: #' @include duckdb.R
2: NULL
3: 
4: #' DBI methods
5: #'
6: #' Implementations of pure virtual functions defined in the `DBI` package.
7: #' @name DBI
8: NULL
9: 
10: DBDIR_MEMORY <- ":memory:"
11: 
12: #' DuckDB driver
13: #'
14: #' TBD.
15: #'
16: #' @export
17: #' @import methods DBI
18: #' @examples
19: #' \dontrun{
20: #' #' library(DBI)
21: #' duckdb::duckdb()
22: #' }
23: 
24: 
25: duckdb <- function(dbdir=DBDIR_MEMORY, read_only=FALSE) {
26:   check_flag(read_only)
27:   new(
28:     "duckdb_driver",
29:     database_ref = .Call(duckdb_startup_R, dbdir, read_only),
30:     dbdir=dbdir,
31:     read_only = read_only
32:   )
33: }
34: 
35: #' @rdname DBI
36: #' @export
37: setClass("duckdb_driver", contains = "DBIDriver", slots = list(database_ref = "externalptr", dbdir="character", read_only="logical"))
38: 
39: extptr_str <- function(e, n=5) {
40:   x <- .Call(duckdb_ptr_to_str, e)
41:   substr(x, nchar(x)-n+1, nchar(x))
42: }
43: 
44: drv_to_string <- function(drv) {
45:   if (!is(drv, "duckdb_driver")) {
46:     stop("pass a duckdb_driver object")
47:   }
48:   sprintf("<duckdb_driver %s dbdir='%s' read_only=%s>",  extptr_str(drv@database_ref), drv@dbdir, drv@read_only)
49: }
50: 
51: #' @rdname DBI
52: #' @inheritParams methods::show
53: #' @export
54: setMethod(
55:   "show", "duckdb_driver",
56:   function(object) {
57:     cat(drv_to_string(object))
58:     cat("\n")
59:   })
60: 
61: #' @rdname DBI
62: #' @inheritParams DBI::dbConnect
63: #' @export
64: setMethod(
65:   "dbConnect", "duckdb_driver",
66:   function(drv, dbdir=DBDIR_MEMORY, ..., debug=getOption("duckdb.debug", FALSE), read_only=FALSE) {
67: 
68:     check_flag(debug)
69: 
70:     missing_dbdir <- missing(dbdir)
71:     dbdir <- path.expand(as.character(dbdir))
72: 
73: 
74:     # aha, a late comer. let's make a new instance.
75:     if (!missing_dbdir && dbdir != drv@dbdir) {
76:       duckdb_shutdown(drv)
77:       drv <- duckdb(dbdir, read_only)
78:     }
79: 
80:     duckdb_connection(drv, debug=debug)
81:   }
82: )
83: 
84: #' @rdname DBI
85: #' @inheritParams DBI::dbDataType
86: #' @export
87: setMethod(
88:   "dbDataType", "duckdb_driver",
89:   function(dbObj, obj, ...) {
90: 
91:   if (is.null(obj)) stop("NULL parameter")
92:   if (is.data.frame(obj)) {
93:     return (vapply(obj, function(x) dbDataType(dbObj, x), FUN.VALUE = "character"))
94:   }
95: #  else if (int64 && inherits(obj, "integer64")) "BIGINT"
96:   else if (inherits(obj, "Date")) "DATE"
97:   else if (inherits(obj, "difftime")) "TIME"
98:   else if (is.logical(obj)) "BOOLEAN"
99:   else if (is.integer(obj)) "INTEGER"
100:   else if (is.numeric(obj)) "DOUBLE"
101:   else if (inherits(obj, "POSIXt")) "TIMESTAMP"
102:   else if (is.list(obj) && all(vapply(obj, typeof, FUN.VALUE = "character") == "raw" || is.na(obj))) "BLOB"
103:   else "STRING"
104: 
105:   })
106: 
107: #' @rdname DBI
108: #' @inheritParams DBI::dbIsValid
109: #' @export
110: setMethod(
111:   "dbIsValid", "duckdb_driver",
112:   function(dbObj, ...) {
113:     valid <- FALSE
114:     tryCatch ({
115:       con <- dbConnect(dbObj)
116:       dbExecute(con, SQL("SELECT 1"))
117:       dbDisconnect(con)
118:       valid <- TRUE
119:     }, error = function(c) {
120:     })
121:     valid
122:   })
123: 
124: #' @rdname DBI
125: #' @inheritParams DBI::dbGetInfo
126: #' @export
127: setMethod(
128:   "dbGetInfo", "duckdb_driver",
129:   function(dbObj, ...) {
130:     list(driver.version=NA, client.version=NA)
131:   })
132: 
133: 
134: #' @export
135: duckdb_shutdown <- function(drv) {
136:   if (!is(drv, "duckdb_driver")) {
137:     stop("pass a duckdb_driver object")
138:   }
139:   if (!dbIsValid(drv)) {
140:     warning("invalid driver object, already closed?")
141:     invisible(FALSE)
142:   }
143:   .Call(duckdb_shutdown_R, drv@database_ref)
144:   invisible(TRUE)
145: }
146: 
147: is_installed <- function (pkg) {
148:     as.logical(requireNamespace(pkg, quietly = TRUE)) == TRUE
149: }
150: 
151: 
152: #' @importFrom DBI dbConnect
153: #' @importFrom dbplyr src_dbi
154: #' @export
155: src_duckdb <- function (path=":memory:", create = FALSE, read_only=FALSE) {
156:     if (!is_installed("dbplyr")) {
157:       stop("Need package `dbplyr` installed.")
158:     }
159:     if (path != ":memory:" && !create && !file.exists(path)) {
160:         stop("`path` '",path,"' must already exist, unless `create` = TRUE")
161:     }
162:     con <- DBI::dbConnect(duckdb::duckdb(), path, read_only=read_only)
163:     dbplyr::src_dbi(con, auto_disconnect = TRUE)
164: }
[end of tools/rpkg/R/Driver.R]
[start of tools/rpkg/R/Result.R]
1: #' @include Connection.R
2: NULL
3: 
4: duckdb_result <- function(connection, stmt_lst) {
5:   env <- new.env(parent=emptyenv())
6:   env$rows_fetched <- 0
7:   env$open <- TRUE
8:   env$rows_affected <- 0
9: 
10:   res <- new("duckdb_result", connection = connection, stmt_lst = stmt_lst, env=env)
11: 
12:   if (stmt_lst$n_param == 0) {
13:     duckdb_execute(res)
14:   }
15: 
16:   return(res)
17: }
18: 
19: duckdb_execute <- function(res) {
20:   res@env$resultset <- .Call(duckdb_execute_R, res@stmt_lst$ref)
21:   attr(res@env$resultset, "row.names") <-
22:           c(NA_integer_, as.integer(-1 * length(res@env$resultset[[1]])))
23:   class(res@env$resultset) <- "data.frame"
24:   if (res@stmt_lst$type != 'SELECT') {
25:     res@env$rows_affected <- as.numeric(res@env$resultset[[1]][1])
26:   }
27: }
28: 
29: #' @rdname DBI
30: #' @export
31: setClass(
32:   "duckdb_result",
33:   contains = "DBIResult",
34:   slots = list(
35:     connection = "duckdb_connection",
36:     stmt_lst = "list",
37:     env = "environment"
38:   )
39: )
40: 
41: #' @rdname DBI
42: #' @inheritParams methods::show
43: #' @export
44: setMethod(
45:   "show", "duckdb_result",
46:   function(object) {
47:     cat(sprintf("<duckdb_result %s connection=%s statement='%s'>\n", extptr_str(object@stmt_lst$ref), extptr_str(object@connection@conn_ref), object@stmt_lst$str))
48:   })
49: 
50: #' @rdname DBI
51: #' @inheritParams DBI::dbClearResult
52: #' @export
53: setMethod(
54:   "dbClearResult", "duckdb_result",
55:   function(res, ...) {
56:     if (res@env$open) {
57:       .Call(duckdb_release_R, res@stmt_lst$ref)
58:       res@env$open <- FALSE
59:     } else {
60:       warning("Result was cleared already")
61:     }
62:     return(invisible(TRUE))
63:   })
64: 
65: # as per is.integer documentation
66: is_wholenumber <- function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol
67: 
68: fix_rownames <- function(df) {
69:   attr(df, "row.names") <- c(NA, as.integer(-nrow(df)))
70:   return(df)
71: }
72: 
73: 
74: #' @rdname DBI
75: #' @inheritParams DBI::dbFetch
76: #' @importFrom utils head
77: #' @export
78: setMethod(
79:   "dbFetch", "duckdb_result",
80:   function(res, n = -1, ...) {
81:     if (!res@env$open) {
82:       stop("result set was closed")
83:     }
84:     if (length(n) != 1) {
85:       stop("need exactly one value in n")
86:     }
87:     if (is.infinite(n)) {
88:       n <- -1
89:     }
90:     if (n < -1) {
91:       stop("cannot fetch negative n other than -1")
92:     }
93:     if (!is_wholenumber(n)) {
94:       stop("n needs to be not a whole number")
95:     }
96:     if (res@stmt_lst$type != "SELECT") {
97:       warning("Should not call dbFetch() on results that do not come from SELECT")
98:       return(data.frame())
99:     }
100: 
101: # FIXME this is ugly
102:     if (n == 0) {
103:       return(utils::head(res@env$resultset, 0))
104:     }
105:     if (res@env$rows_fetched < 0) {
106:       res@env$rows_fetched <- 0
107:     }
108:     if (res@env$rows_fetched >= nrow(res@env$resultset)) {
109:       return(fix_rownames(res@env$resultset[F,, drop=F]))
110:     }
111:     # special case, return everything
112:     if (n == -1 && res@env$rows_fetched == 0) {
113:       res@env$rows_fetched <- nrow(res@env$resultset)
114:       return(res@env$resultset)
115:     }
116:     if (n > -1) {
117:       n <- min(n, nrow(res@env$resultset) - res@env$rows_fetched)
118:       res@env$rows_fetched <- res@env$rows_fetched + n
119:       df <- res@env$resultset[(res@env$rows_fetched - n + 1):(res@env$rows_fetched),, drop=F]
120:       return(fix_rownames(df))
121:     }
122:     start <- res@env$rows_fetched + 1
123:     res@env$rows_fetched <- nrow(res@env$resultset)
124:     df <- res@env$resultset[nrow(res@env$resultset),, drop=F]
125:     return(fix_rownames(df))
126:   })
127: 
128: #' @rdname DBI
129: #' @inheritParams DBI::dbHasCompleted
130: #' @export
131: setMethod(
132:   "dbHasCompleted", "duckdb_result",
133:   function(res, ...) {
134:     if (!res@env$open) {
135:      stop("result has already been cleared")
136:     }
137:     if (res@stmt_lst$type != "SELECT") {
138:       return(TRUE)
139:     }
140:     return(res@env$rows_fetched == nrow(res@env$resultset))
141:   })
142: 
143: #' @rdname DBI
144: #' @inheritParams DBI::dbGetInfo
145: #' @export
146: setMethod(
147:   "dbGetInfo", "duckdb_result",
148:   function(dbObj, ...) {
149:     # Optional
150:     getMethod("dbGetInfo", "DBIResult", asNamespace("DBI"))(dbObj, ...)
151:   })
152: 
153: #' @rdname DBI
154: #' @inheritParams DBI::dbIsValid
155: #' @export
156: setMethod(
157:   "dbIsValid", "duckdb_result",
158:   function(dbObj, ...) {
159:     return(dbObj@env$open)
160:   })
161: 
162: #' @rdname DBI
163: #' @inheritParams DBI::dbGetStatement
164: #' @export
165: setMethod(
166:   "dbGetStatement", "duckdb_result",
167:   function(res, ...) {
168:     if (!res@env$open) {
169:       stop("result has already been cleared")
170:     }
171:     return(res@stmt_lst$str)
172:   })
173: 
174: #' @rdname DBI
175: #' @inheritParams DBI::dbColumnInfo
176: #' @export
177: setMethod(
178:   "dbColumnInfo", "duckdb_result",
179:   function(res, ...) {
180:     return(data.frame(name=res@stmt_lst$names, type=res@stmt_lst$rtypes, stringsAsFactors=FALSE))
181: 
182:   })
183: 
184: #' @rdname DBI
185: #' @inheritParams DBI::dbGetRowCount
186: #' @export
187: setMethod(
188:   "dbGetRowCount", "duckdb_result",
189:   function(res, ...) {
190:     if (!res@env$open) {
191:       stop("result has already been cleared")
192:     }
193:    return(res@env$rows_fetched)
194:   })
195: 
196: #' @rdname DBI
197: #' @inheritParams DBI::dbGetRowsAffected
198: #' @export
199: setMethod(
200:   "dbGetRowsAffected", "duckdb_result",
201:   function(res, ...) {
202:      if (!res@env$open) {
203:       stop("result has already been cleared")
204:     }
205:   return (res@env$rows_affected)
206:   })
207: 
208: #' @rdname DBI
209: #' @inheritParams DBI::dbBind
210: #' @importFrom testthat skip
211: #' @export
212: setMethod(
213:   "dbBind", "duckdb_result",
214:   function(res, params, ...) {
215:     if (!res@env$open) {
216:       stop("result has already been cleared")
217:     }
218:     res@env$rows_fetched <- 0
219:     res@env$resultset <- data.frame()
220: 
221:     invisible(.Call(duckdb_bind_R, res@stmt_lst$ref, params))
222:     duckdb_execute(res)
223:   })
[end of tools/rpkg/R/Result.R]
[start of tools/rpkg/R/duckdb.R]
1: #' @details TBD.
2: "_PACKAGE"
3: 
4: check_flag <- function(x) {
5:   if (is.null(x) || length(x) != 1 || is.na(x) || !is.logical(x)) {
6:     stop("flags need to be scalar logicals")
7:   }
8: }
9: 
10: #' @useDynLib duckdb , .registration = TRUE
[end of tools/rpkg/R/duckdb.R]
[start of tools/rpkg/man/DBI.Rd]
1: % Generated by roxygen2: do not edit by hand
2: % Please edit documentation in R/Driver.R, R/Connection.R, R/Result.R
3: \docType{class}
4: \name{DBI}
5: \alias{DBI}
6: \alias{duckdb_driver-class}
7: \alias{show,duckdb_driver-method}
8: \alias{dbConnect,duckdb_driver-method}
9: \alias{dbDataType,duckdb_driver-method}
10: \alias{dbIsValid,duckdb_driver-method}
11: \alias{dbGetInfo,duckdb_driver-method}
12: \alias{duckdb_connection-class}
13: \alias{show,duckdb_connection-method}
14: \alias{dbIsValid,duckdb_connection-method}
15: \alias{dbDisconnect,duckdb_connection-method}
16: \alias{dbSendQuery,duckdb_connection,character-method}
17: \alias{dbSendStatement,duckdb_connection,character-method}
18: \alias{dbDataType,duckdb_connection-method}
19: \alias{dbWriteTable,duckdb_connection,character,data.frame-method}
20: \alias{dbListTables,duckdb_connection-method}
21: \alias{dbExistsTable,duckdb_connection,character-method}
22: \alias{dbListFields,duckdb_connection,character-method}
23: \alias{dbRemoveTable,duckdb_connection,character-method}
24: \alias{dbGetInfo,duckdb_connection-method}
25: \alias{dbBegin,duckdb_connection-method}
26: \alias{dbCommit,duckdb_connection-method}
27: \alias{dbRollback,duckdb_connection-method}
28: \alias{duckdb_result-class}
29: \alias{show,duckdb_result-method}
30: \alias{dbClearResult,duckdb_result-method}
31: \alias{dbFetch,duckdb_result-method}
32: \alias{dbHasCompleted,duckdb_result-method}
33: \alias{dbGetInfo,duckdb_result-method}
34: \alias{dbIsValid,duckdb_result-method}
35: \alias{dbGetStatement,duckdb_result-method}
36: \alias{dbColumnInfo,duckdb_result-method}
37: \alias{dbGetRowCount,duckdb_result-method}
38: \alias{dbGetRowsAffected,duckdb_result-method}
39: \alias{dbBind,duckdb_result-method}
40: \title{DBI methods}
41: \usage{
42: \S4method{show}{duckdb_driver}(object)
43: 
44: \S4method{dbConnect}{duckdb_driver}(
45:   drv,
46:   dbdir = ":memory:",
47:   ...,
48:   debug = getOption("duckdb.debug", FALSE),
49:   dbname = NA
50: )
51: 
52: \S4method{dbDataType}{duckdb_driver}(dbObj, obj, ...)
53: 
54: \S4method{dbIsValid}{duckdb_driver}(dbObj, ...)
55: 
56: \S4method{dbGetInfo}{duckdb_driver}(dbObj, ...)
57: 
58: \S4method{show}{duckdb_connection}(object)
59: 
60: \S4method{dbIsValid}{duckdb_connection}(dbObj, ...)
61: 
62: \S4method{dbDisconnect}{duckdb_connection}(conn, ...)
63: 
64: \S4method{dbSendQuery}{duckdb_connection,character}(conn, statement, ...)
65: 
66: \S4method{dbSendStatement}{duckdb_connection,character}(conn, statement, ...)
67: 
68: \S4method{dbDataType}{duckdb_connection}(dbObj, obj, ...)
69: 
70: \S4method{dbWriteTable}{duckdb_connection,character,data.frame}(
71:   conn,
72:   name,
73:   value,
74:   row.names = FALSE,
75:   overwrite = FALSE,
76:   append = FALSE,
77:   field.types = NULL,
78:   temporary = FALSE,
79:   ...
80: )
81: 
82: \S4method{dbListTables}{duckdb_connection}(conn, ...)
83: 
84: \S4method{dbExistsTable}{duckdb_connection,character}(conn, name, ...)
85: 
86: \S4method{dbListFields}{duckdb_connection,character}(conn, name, ...)
87: 
88: \S4method{dbRemoveTable}{duckdb_connection,character}(conn, name, ...)
89: 
90: \S4method{dbGetInfo}{duckdb_connection}(dbObj, ...)
91: 
92: \S4method{dbBegin}{duckdb_connection}(conn, ...)
93: 
94: \S4method{dbCommit}{duckdb_connection}(conn, ...)
95: 
96: \S4method{dbRollback}{duckdb_connection}(conn, ...)
97: 
98: \S4method{show}{duckdb_result}(object)
99: 
100: \S4method{dbClearResult}{duckdb_result}(res, ...)
101: 
102: \S4method{dbFetch}{duckdb_result}(res, n = -1, ...)
103: 
104: \S4method{dbHasCompleted}{duckdb_result}(res, ...)
105: 
106: \S4method{dbGetInfo}{duckdb_result}(dbObj, ...)
107: 
108: \S4method{dbIsValid}{duckdb_result}(dbObj, ...)
109: 
110: \S4method{dbGetStatement}{duckdb_result}(res, ...)
111: 
112: \S4method{dbColumnInfo}{duckdb_result}(res, ...)
113: 
114: \S4method{dbGetRowCount}{duckdb_result}(res, ...)
115: 
116: \S4method{dbGetRowsAffected}{duckdb_result}(res, ...)
117: 
118: \S4method{dbBind}{duckdb_result}(res, params, ...)
119: }
120: \arguments{
121: \item{object}{Any R object}
122: 
123: \item{drv}{an object that inherits from \linkS4class{DBIDriver},
124: or an existing \linkS4class{DBIConnection}
125: object (in order to clone an existing connection).}
126: 
127: \item{...}{authentication arguments needed by the DBMS instance; these
128: typically include \code{user}, \code{password}, \code{host}, \code{port}, \code{dbname}, etc.
129: For details see the appropriate \code{DBIDriver}.}
130: 
131: \item{dbObj}{A object inheriting from \linkS4class{DBIDriver}
132: or \linkS4class{DBIConnection}}
133: 
134: \item{obj}{An R object whose SQL type we want to determine.}
135: 
136: \item{conn}{A \linkS4class{DBIConnection} object, as returned by
137: \code{\link[=dbConnect]{dbConnect()}}.}
138: 
139: \item{statement}{a character string containing SQL.}
140: 
141: \item{name}{A character string specifying the unquoted DBMS table name,
142: or the result of a call to \code{\link[=dbQuoteIdentifier]{dbQuoteIdentifier()}}.}
143: 
144: \item{value}{a \link[DBI]{data.frame} (or coercible to data.frame).}
145: 
146: \item{overwrite}{Allow overwriting the destination table. Cannot be
147: `TRUE` if `append` is also `TRUE`.}
148: 
149: \item{append}{Allow appending to the destination table. Cannot be
150: `TRUE` if `overwrite` is also `TRUE`.}
151: 
152: \item{res}{An object inheriting from \linkS4class{DBIResult}.}
153: 
154: \item{n}{maximum number of records to retrieve per fetch. Use \code{n = -1}
155: or \code{n = Inf}
156: to retrieve all pending records.  Some implementations may recognize other
157: special values.}
158: 
159: \item{params}{A list of bindings, named or unnamed.}
160: }
161: \description{
162: Implementations of pure virtual functions defined in the `DBI` package.
163: }
[end of tools/rpkg/man/DBI.Rd]
[start of tools/rpkg/man/duckdb-package.Rd]
1: % Generated by roxygen2: do not edit by hand
2: % Please edit documentation in R/duckdb.R
3: \docType{package}
4: \name{duckdb-package}
5: \alias{duckdb}
6: \alias{duckdb-package}
7: \title{duckdb: DBI Package for DuckDB}
8: \description{
9: TODO
10: }
11: \details{
12: TBD.
13: }
[end of tools/rpkg/man/duckdb-package.Rd]
[start of tools/rpkg/man/duckdb.Rd]
1: % Generated by roxygen2: do not edit by hand
2: % Please edit documentation in R/Driver.R
3: \name{duckdb}
4: \alias{duckdb}
5: \title{DuckDB driver}
6: \usage{
7: duckdb()
8: }
9: \description{
10: TBD.
11: }
12: \examples{
13: \dontrun{
14: #' library(DBI)
15: duckdb::duckdb()
16: }
17: }
[end of tools/rpkg/man/duckdb.Rd]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: