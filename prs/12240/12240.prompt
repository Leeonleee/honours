You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Hive partitioned append/write 0.10.3 
### What happens?

Before version 0.10.3, you could enforce partitioned append to a Hive partitioned table by specifying the FILENAME_PATTERN 
property and setting OVERWRITE_OR_IGNORE to true. 
However, since the recent changes (as documented in this GitHub pull request https://github.com/duckdb/duckdb/pull/11787),
 the behavior has been modified. Now I am experiencing breaking changes in my applications.  Is there any alternative approach for partitioned append? The code below  illustrates the problem.

### To Reproduce

```sql
create or replace temp view t_val_v  as 
select *
from ( 
    values 
    ('p_1', 'key_1', 'val_1'),
    ('p_2', 'key_1', 'val_1'),
    ('p_3', 'key_1', 'val_1')
) as t_val(p_key, key, val);
copy (
    select *
    from  t_val_v
) to '/home/da/output_tmp/t_val' (
format parquet,
PARTITION_BY (p_key),
FILENAME_PATTERN "pv1_{i}",
OVERWRITE_OR_IGNORE false
);
copy (
    select *
    from  t_val_v
) to '/home/da/output_tmp/t_val' (
format parquet,
PARTITION_BY (p_key),
FILENAME_PATTERN "pv2_{i}",
OVERWRITE_OR_IGNORE false
);
```

output before. changes (version 0.10.2):

```bash
before 0.10.3 
~/output_tmp/t_val/p_key=p_1$ ls -la
total 16
drwxr-xr-x 2 da da 4096 May 24 10:46 .
drwxr-xr-x 5 da da 4096 May 24 10:44 ..
-rw-r--r-- 1 da da  367 May 24 11:49 pv1_0.parquet
-rw-r--r-- 1 da da  367 May 24 11:49 pv2_0.parquet
```
output with version 0.10.3 (removes all old files)

```bash
~/output_tmp/t_val/p_key=p_1$ ls -la
total 12
drwxr-xr-x 2 da da 4096 May 24 11:51 .
drwxr-xr-x 5 da da 4096 May 24 10:44 ..
-rw-r--r-- 1 da da  367 May 24 11:51 pv2_0.parquet
```



### OS:

windows, ubuntu

### DuckDB Version:

0.10.3

### DuckDB Client:

python

### Full Name:

Daniar Achakeev

### Affiliation:

HMS Analytical Software GmbH

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
Hive partitioned append/write 0.10.3 
### What happens?

Before version 0.10.3, you could enforce partitioned append to a Hive partitioned table by specifying the FILENAME_PATTERN 
property and setting OVERWRITE_OR_IGNORE to true. 
However, since the recent changes (as documented in this GitHub pull request https://github.com/duckdb/duckdb/pull/11787),
 the behavior has been modified. Now I am experiencing breaking changes in my applications.  Is there any alternative approach for partitioned append? The code below  illustrates the problem.

### To Reproduce

```sql
create or replace temp view t_val_v  as 
select *
from ( 
    values 
    ('p_1', 'key_1', 'val_1'),
    ('p_2', 'key_1', 'val_1'),
    ('p_3', 'key_1', 'val_1')
) as t_val(p_key, key, val);
copy (
    select *
    from  t_val_v
) to '/home/da/output_tmp/t_val' (
format parquet,
PARTITION_BY (p_key),
FILENAME_PATTERN "pv1_{i}",
OVERWRITE_OR_IGNORE false
);
copy (
    select *
    from  t_val_v
) to '/home/da/output_tmp/t_val' (
format parquet,
PARTITION_BY (p_key),
FILENAME_PATTERN "pv2_{i}",
OVERWRITE_OR_IGNORE false
);
```

output before. changes (version 0.10.2):

```bash
before 0.10.3 
~/output_tmp/t_val/p_key=p_1$ ls -la
total 16
drwxr-xr-x 2 da da 4096 May 24 10:46 .
drwxr-xr-x 5 da da 4096 May 24 10:44 ..
-rw-r--r-- 1 da da  367 May 24 11:49 pv1_0.parquet
-rw-r--r-- 1 da da  367 May 24 11:49 pv2_0.parquet
```
output with version 0.10.3 (removes all old files)

```bash
~/output_tmp/t_val/p_key=p_1$ ls -la
total 12
drwxr-xr-x 2 da da 4096 May 24 11:51 .
drwxr-xr-x 5 da da 4096 May 24 10:44 ..
-rw-r--r-- 1 da da  367 May 24 11:51 pv2_0.parquet
```



### OS:

windows, ubuntu

### DuckDB Version:

0.10.3

### DuckDB Client:

python

### Full Name:

Daniar Achakeev

### Affiliation:

HMS Analytical Software GmbH

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
18: 
19: ## Installation
20: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
21: 
22: ## Data Import
23: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
24: 
25: ```sql
26: SELECT * FROM 'myfile.csv';
27: SELECT * FROM 'myfile.parquet';
28: ```
29: 
30: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
31: 
32: ## SQL Reference
33: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
34: 
35: ## Development
36: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
37: 
38: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
39: 
40: ## Support
41: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/common/enum_util.cpp]
1: //-------------------------------------------------------------------------
2: // This file is automatically generated by scripts/generate_enum_util.py
3: // Do not edit this file manually, your changes will be overwritten
4: // If you want to exclude an enum from serialization, add it to the blacklist in the script
5: //
6: // Note: The generated code will only work properly if the enum is a top level item in the duckdb namespace
7: // If the enum is nested in a class, or in another namespace, the generated code will not compile.
8: // You should move the enum to the duckdb namespace, manually write a specialization or add it to the blacklist
9: //-------------------------------------------------------------------------
10: 
11: 
12: #include "duckdb/common/enum_util.hpp"
13: #include "duckdb/catalog/catalog_entry/dependency/dependency_entry.hpp"
14: #include "duckdb/catalog/catalog_entry/table_column_type.hpp"
15: #include "duckdb/common/box_renderer.hpp"
16: #include "duckdb/common/enums/access_mode.hpp"
17: #include "duckdb/common/enums/aggregate_handling.hpp"
18: #include "duckdb/common/enums/catalog_lookup_behavior.hpp"
19: #include "duckdb/common/enums/catalog_type.hpp"
20: #include "duckdb/common/enums/compression_type.hpp"
21: #include "duckdb/common/enums/cte_materialize.hpp"
22: #include "duckdb/common/enums/date_part_specifier.hpp"
23: #include "duckdb/common/enums/debug_initialize.hpp"
24: #include "duckdb/common/enums/expression_type.hpp"
25: #include "duckdb/common/enums/file_compression_type.hpp"
26: #include "duckdb/common/enums/file_glob_options.hpp"
27: #include "duckdb/common/enums/filter_propagate_result.hpp"
28: #include "duckdb/common/enums/index_constraint_type.hpp"
29: #include "duckdb/common/enums/join_type.hpp"
30: #include "duckdb/common/enums/joinref_type.hpp"
31: #include "duckdb/common/enums/logical_operator_type.hpp"
32: #include "duckdb/common/enums/memory_tag.hpp"
33: #include "duckdb/common/enums/on_create_conflict.hpp"
34: #include "duckdb/common/enums/on_entry_not_found.hpp"
35: #include "duckdb/common/enums/operator_result_type.hpp"
36: #include "duckdb/common/enums/optimizer_type.hpp"
37: #include "duckdb/common/enums/order_preservation_type.hpp"
38: #include "duckdb/common/enums/order_type.hpp"
39: #include "duckdb/common/enums/output_type.hpp"
40: #include "duckdb/common/enums/pending_execution_result.hpp"
41: #include "duckdb/common/enums/physical_operator_type.hpp"
42: #include "duckdb/common/enums/prepared_statement_mode.hpp"
43: #include "duckdb/common/enums/profiler_format.hpp"
44: #include "duckdb/common/enums/relation_type.hpp"
45: #include "duckdb/common/enums/scan_options.hpp"
46: #include "duckdb/common/enums/set_operation_type.hpp"
47: #include "duckdb/common/enums/set_scope.hpp"
48: #include "duckdb/common/enums/set_type.hpp"
49: #include "duckdb/common/enums/statement_type.hpp"
50: #include "duckdb/common/enums/subquery_type.hpp"
51: #include "duckdb/common/enums/tableref_type.hpp"
52: #include "duckdb/common/enums/undo_flags.hpp"
53: #include "duckdb/common/enums/vector_type.hpp"
54: #include "duckdb/common/enums/wal_type.hpp"
55: #include "duckdb/common/enums/window_aggregation_mode.hpp"
56: #include "duckdb/common/exception.hpp"
57: #include "duckdb/common/exception_format_value.hpp"
58: #include "duckdb/common/extra_type_info.hpp"
59: #include "duckdb/common/file_buffer.hpp"
60: #include "duckdb/common/file_open_flags.hpp"
61: #include "duckdb/common/multi_file_list.hpp"
62: #include "duckdb/common/operator/decimal_cast_operators.hpp"
63: #include "duckdb/common/printer.hpp"
64: #include "duckdb/common/sort/partition_state.hpp"
65: #include "duckdb/common/types.hpp"
66: #include "duckdb/common/types/column/column_data_scan_states.hpp"
67: #include "duckdb/common/types/column/partitioned_column_data.hpp"
68: #include "duckdb/common/types/conflict_manager.hpp"
69: #include "duckdb/common/types/hyperloglog.hpp"
70: #include "duckdb/common/types/row/partitioned_tuple_data.hpp"
71: #include "duckdb/common/types/row/tuple_data_states.hpp"
72: #include "duckdb/common/types/timestamp.hpp"
73: #include "duckdb/common/types/vector.hpp"
74: #include "duckdb/common/types/vector_buffer.hpp"
75: #include "duckdb/core_functions/aggregate/quantile_enum.hpp"
76: #include "duckdb/execution/index/art/art.hpp"
77: #include "duckdb/execution/index/art/node.hpp"
78: #include "duckdb/execution/operator/csv_scanner/csv_option.hpp"
79: #include "duckdb/execution/operator/csv_scanner/csv_state.hpp"
80: #include "duckdb/execution/operator/csv_scanner/quote_rules.hpp"
81: #include "duckdb/execution/reservoir_sample.hpp"
82: #include "duckdb/function/aggregate_state.hpp"
83: #include "duckdb/function/function.hpp"
84: #include "duckdb/function/macro_function.hpp"
85: #include "duckdb/function/scalar/compressed_materialization_functions.hpp"
86: #include "duckdb/function/scalar/strftime_format.hpp"
87: #include "duckdb/function/table/arrow/arrow_duck_schema.hpp"
88: #include "duckdb/function/table_function.hpp"
89: #include "duckdb/main/appender.hpp"
90: #include "duckdb/main/capi/capi_internal.hpp"
91: #include "duckdb/main/client_properties.hpp"
92: #include "duckdb/main/config.hpp"
93: #include "duckdb/main/error_manager.hpp"
94: #include "duckdb/main/extension_helper.hpp"
95: #include "duckdb/main/extension_install_info.hpp"
96: #include "duckdb/main/query_result.hpp"
97: #include "duckdb/main/secret/secret.hpp"
98: #include "duckdb/main/settings.hpp"
99: #include "duckdb/parallel/interrupt.hpp"
100: #include "duckdb/parallel/task.hpp"
101: #include "duckdb/parser/constraint.hpp"
102: #include "duckdb/parser/expression/parameter_expression.hpp"
103: #include "duckdb/parser/expression/window_expression.hpp"
104: #include "duckdb/parser/parsed_data/alter_info.hpp"
105: #include "duckdb/parser/parsed_data/alter_scalar_function_info.hpp"
106: #include "duckdb/parser/parsed_data/alter_table_function_info.hpp"
107: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
108: #include "duckdb/parser/parsed_data/create_sequence_info.hpp"
109: #include "duckdb/parser/parsed_data/extra_drop_info.hpp"
110: #include "duckdb/parser/parsed_data/load_info.hpp"
111: #include "duckdb/parser/parsed_data/parse_info.hpp"
112: #include "duckdb/parser/parsed_data/pragma_info.hpp"
113: #include "duckdb/parser/parsed_data/sample_options.hpp"
114: #include "duckdb/parser/parsed_data/transaction_info.hpp"
115: #include "duckdb/parser/parser_extension.hpp"
116: #include "duckdb/parser/query_node.hpp"
117: #include "duckdb/parser/result_modifier.hpp"
118: #include "duckdb/parser/simplified_token.hpp"
119: #include "duckdb/parser/statement/explain_statement.hpp"
120: #include "duckdb/parser/statement/insert_statement.hpp"
121: #include "duckdb/parser/tableref/showref.hpp"
122: #include "duckdb/planner/binder.hpp"
123: #include "duckdb/planner/bound_result_modifier.hpp"
124: #include "duckdb/planner/table_filter.hpp"
125: #include "duckdb/storage/buffer/block_handle.hpp"
126: #include "duckdb/storage/compression/bitpacking.hpp"
127: #include "duckdb/storage/magic_bytes.hpp"
128: #include "duckdb/storage/statistics/base_statistics.hpp"
129: #include "duckdb/storage/table/chunk_info.hpp"
130: #include "duckdb/storage/table/column_segment.hpp"
131: #include "duckdb/verification/statement_verifier.hpp"
132: 
133: namespace duckdb {
134: 
135: template<>
136: const char* EnumUtil::ToChars<AccessMode>(AccessMode value) {
137: 	switch(value) {
138: 	case AccessMode::UNDEFINED:
139: 		return "UNDEFINED";
140: 	case AccessMode::AUTOMATIC:
141: 		return "AUTOMATIC";
142: 	case AccessMode::READ_ONLY:
143: 		return "READ_ONLY";
144: 	case AccessMode::READ_WRITE:
145: 		return "READ_WRITE";
146: 	default:
147: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
148: 	}
149: }
150: 
151: template<>
152: AccessMode EnumUtil::FromString<AccessMode>(const char *value) {
153: 	if (StringUtil::Equals(value, "UNDEFINED")) {
154: 		return AccessMode::UNDEFINED;
155: 	}
156: 	if (StringUtil::Equals(value, "AUTOMATIC")) {
157: 		return AccessMode::AUTOMATIC;
158: 	}
159: 	if (StringUtil::Equals(value, "READ_ONLY")) {
160: 		return AccessMode::READ_ONLY;
161: 	}
162: 	if (StringUtil::Equals(value, "READ_WRITE")) {
163: 		return AccessMode::READ_WRITE;
164: 	}
165: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
166: }
167: 
168: template<>
169: const char* EnumUtil::ToChars<AggregateCombineType>(AggregateCombineType value) {
170: 	switch(value) {
171: 	case AggregateCombineType::PRESERVE_INPUT:
172: 		return "PRESERVE_INPUT";
173: 	case AggregateCombineType::ALLOW_DESTRUCTIVE:
174: 		return "ALLOW_DESTRUCTIVE";
175: 	default:
176: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
177: 	}
178: }
179: 
180: template<>
181: AggregateCombineType EnumUtil::FromString<AggregateCombineType>(const char *value) {
182: 	if (StringUtil::Equals(value, "PRESERVE_INPUT")) {
183: 		return AggregateCombineType::PRESERVE_INPUT;
184: 	}
185: 	if (StringUtil::Equals(value, "ALLOW_DESTRUCTIVE")) {
186: 		return AggregateCombineType::ALLOW_DESTRUCTIVE;
187: 	}
188: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
189: }
190: 
191: template<>
192: const char* EnumUtil::ToChars<AggregateHandling>(AggregateHandling value) {
193: 	switch(value) {
194: 	case AggregateHandling::STANDARD_HANDLING:
195: 		return "STANDARD_HANDLING";
196: 	case AggregateHandling::NO_AGGREGATES_ALLOWED:
197: 		return "NO_AGGREGATES_ALLOWED";
198: 	case AggregateHandling::FORCE_AGGREGATES:
199: 		return "FORCE_AGGREGATES";
200: 	default:
201: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
202: 	}
203: }
204: 
205: template<>
206: AggregateHandling EnumUtil::FromString<AggregateHandling>(const char *value) {
207: 	if (StringUtil::Equals(value, "STANDARD_HANDLING")) {
208: 		return AggregateHandling::STANDARD_HANDLING;
209: 	}
210: 	if (StringUtil::Equals(value, "NO_AGGREGATES_ALLOWED")) {
211: 		return AggregateHandling::NO_AGGREGATES_ALLOWED;
212: 	}
213: 	if (StringUtil::Equals(value, "FORCE_AGGREGATES")) {
214: 		return AggregateHandling::FORCE_AGGREGATES;
215: 	}
216: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
217: }
218: 
219: template<>
220: const char* EnumUtil::ToChars<AggregateOrderDependent>(AggregateOrderDependent value) {
221: 	switch(value) {
222: 	case AggregateOrderDependent::ORDER_DEPENDENT:
223: 		return "ORDER_DEPENDENT";
224: 	case AggregateOrderDependent::NOT_ORDER_DEPENDENT:
225: 		return "NOT_ORDER_DEPENDENT";
226: 	default:
227: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
228: 	}
229: }
230: 
231: template<>
232: AggregateOrderDependent EnumUtil::FromString<AggregateOrderDependent>(const char *value) {
233: 	if (StringUtil::Equals(value, "ORDER_DEPENDENT")) {
234: 		return AggregateOrderDependent::ORDER_DEPENDENT;
235: 	}
236: 	if (StringUtil::Equals(value, "NOT_ORDER_DEPENDENT")) {
237: 		return AggregateOrderDependent::NOT_ORDER_DEPENDENT;
238: 	}
239: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
240: }
241: 
242: template<>
243: const char* EnumUtil::ToChars<AggregateType>(AggregateType value) {
244: 	switch(value) {
245: 	case AggregateType::NON_DISTINCT:
246: 		return "NON_DISTINCT";
247: 	case AggregateType::DISTINCT:
248: 		return "DISTINCT";
249: 	default:
250: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
251: 	}
252: }
253: 
254: template<>
255: AggregateType EnumUtil::FromString<AggregateType>(const char *value) {
256: 	if (StringUtil::Equals(value, "NON_DISTINCT")) {
257: 		return AggregateType::NON_DISTINCT;
258: 	}
259: 	if (StringUtil::Equals(value, "DISTINCT")) {
260: 		return AggregateType::DISTINCT;
261: 	}
262: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
263: }
264: 
265: template<>
266: const char* EnumUtil::ToChars<AlterForeignKeyType>(AlterForeignKeyType value) {
267: 	switch(value) {
268: 	case AlterForeignKeyType::AFT_ADD:
269: 		return "AFT_ADD";
270: 	case AlterForeignKeyType::AFT_DELETE:
271: 		return "AFT_DELETE";
272: 	default:
273: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
274: 	}
275: }
276: 
277: template<>
278: AlterForeignKeyType EnumUtil::FromString<AlterForeignKeyType>(const char *value) {
279: 	if (StringUtil::Equals(value, "AFT_ADD")) {
280: 		return AlterForeignKeyType::AFT_ADD;
281: 	}
282: 	if (StringUtil::Equals(value, "AFT_DELETE")) {
283: 		return AlterForeignKeyType::AFT_DELETE;
284: 	}
285: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
286: }
287: 
288: template<>
289: const char* EnumUtil::ToChars<AlterScalarFunctionType>(AlterScalarFunctionType value) {
290: 	switch(value) {
291: 	case AlterScalarFunctionType::INVALID:
292: 		return "INVALID";
293: 	case AlterScalarFunctionType::ADD_FUNCTION_OVERLOADS:
294: 		return "ADD_FUNCTION_OVERLOADS";
295: 	default:
296: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
297: 	}
298: }
299: 
300: template<>
301: AlterScalarFunctionType EnumUtil::FromString<AlterScalarFunctionType>(const char *value) {
302: 	if (StringUtil::Equals(value, "INVALID")) {
303: 		return AlterScalarFunctionType::INVALID;
304: 	}
305: 	if (StringUtil::Equals(value, "ADD_FUNCTION_OVERLOADS")) {
306: 		return AlterScalarFunctionType::ADD_FUNCTION_OVERLOADS;
307: 	}
308: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
309: }
310: 
311: template<>
312: const char* EnumUtil::ToChars<AlterTableFunctionType>(AlterTableFunctionType value) {
313: 	switch(value) {
314: 	case AlterTableFunctionType::INVALID:
315: 		return "INVALID";
316: 	case AlterTableFunctionType::ADD_FUNCTION_OVERLOADS:
317: 		return "ADD_FUNCTION_OVERLOADS";
318: 	default:
319: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
320: 	}
321: }
322: 
323: template<>
324: AlterTableFunctionType EnumUtil::FromString<AlterTableFunctionType>(const char *value) {
325: 	if (StringUtil::Equals(value, "INVALID")) {
326: 		return AlterTableFunctionType::INVALID;
327: 	}
328: 	if (StringUtil::Equals(value, "ADD_FUNCTION_OVERLOADS")) {
329: 		return AlterTableFunctionType::ADD_FUNCTION_OVERLOADS;
330: 	}
331: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
332: }
333: 
334: template<>
335: const char* EnumUtil::ToChars<AlterTableType>(AlterTableType value) {
336: 	switch(value) {
337: 	case AlterTableType::INVALID:
338: 		return "INVALID";
339: 	case AlterTableType::RENAME_COLUMN:
340: 		return "RENAME_COLUMN";
341: 	case AlterTableType::RENAME_TABLE:
342: 		return "RENAME_TABLE";
343: 	case AlterTableType::ADD_COLUMN:
344: 		return "ADD_COLUMN";
345: 	case AlterTableType::REMOVE_COLUMN:
346: 		return "REMOVE_COLUMN";
347: 	case AlterTableType::ALTER_COLUMN_TYPE:
348: 		return "ALTER_COLUMN_TYPE";
349: 	case AlterTableType::SET_DEFAULT:
350: 		return "SET_DEFAULT";
351: 	case AlterTableType::FOREIGN_KEY_CONSTRAINT:
352: 		return "FOREIGN_KEY_CONSTRAINT";
353: 	case AlterTableType::SET_NOT_NULL:
354: 		return "SET_NOT_NULL";
355: 	case AlterTableType::DROP_NOT_NULL:
356: 		return "DROP_NOT_NULL";
357: 	case AlterTableType::SET_COLUMN_COMMENT:
358: 		return "SET_COLUMN_COMMENT";
359: 	default:
360: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
361: 	}
362: }
363: 
364: template<>
365: AlterTableType EnumUtil::FromString<AlterTableType>(const char *value) {
366: 	if (StringUtil::Equals(value, "INVALID")) {
367: 		return AlterTableType::INVALID;
368: 	}
369: 	if (StringUtil::Equals(value, "RENAME_COLUMN")) {
370: 		return AlterTableType::RENAME_COLUMN;
371: 	}
372: 	if (StringUtil::Equals(value, "RENAME_TABLE")) {
373: 		return AlterTableType::RENAME_TABLE;
374: 	}
375: 	if (StringUtil::Equals(value, "ADD_COLUMN")) {
376: 		return AlterTableType::ADD_COLUMN;
377: 	}
378: 	if (StringUtil::Equals(value, "REMOVE_COLUMN")) {
379: 		return AlterTableType::REMOVE_COLUMN;
380: 	}
381: 	if (StringUtil::Equals(value, "ALTER_COLUMN_TYPE")) {
382: 		return AlterTableType::ALTER_COLUMN_TYPE;
383: 	}
384: 	if (StringUtil::Equals(value, "SET_DEFAULT")) {
385: 		return AlterTableType::SET_DEFAULT;
386: 	}
387: 	if (StringUtil::Equals(value, "FOREIGN_KEY_CONSTRAINT")) {
388: 		return AlterTableType::FOREIGN_KEY_CONSTRAINT;
389: 	}
390: 	if (StringUtil::Equals(value, "SET_NOT_NULL")) {
391: 		return AlterTableType::SET_NOT_NULL;
392: 	}
393: 	if (StringUtil::Equals(value, "DROP_NOT_NULL")) {
394: 		return AlterTableType::DROP_NOT_NULL;
395: 	}
396: 	if (StringUtil::Equals(value, "SET_COLUMN_COMMENT")) {
397: 		return AlterTableType::SET_COLUMN_COMMENT;
398: 	}
399: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
400: }
401: 
402: template<>
403: const char* EnumUtil::ToChars<AlterType>(AlterType value) {
404: 	switch(value) {
405: 	case AlterType::INVALID:
406: 		return "INVALID";
407: 	case AlterType::ALTER_TABLE:
408: 		return "ALTER_TABLE";
409: 	case AlterType::ALTER_VIEW:
410: 		return "ALTER_VIEW";
411: 	case AlterType::ALTER_SEQUENCE:
412: 		return "ALTER_SEQUENCE";
413: 	case AlterType::CHANGE_OWNERSHIP:
414: 		return "CHANGE_OWNERSHIP";
415: 	case AlterType::ALTER_SCALAR_FUNCTION:
416: 		return "ALTER_SCALAR_FUNCTION";
417: 	case AlterType::ALTER_TABLE_FUNCTION:
418: 		return "ALTER_TABLE_FUNCTION";
419: 	case AlterType::SET_COMMENT:
420: 		return "SET_COMMENT";
421: 	case AlterType::SET_COLUMN_COMMENT:
422: 		return "SET_COLUMN_COMMENT";
423: 	default:
424: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
425: 	}
426: }
427: 
428: template<>
429: AlterType EnumUtil::FromString<AlterType>(const char *value) {
430: 	if (StringUtil::Equals(value, "INVALID")) {
431: 		return AlterType::INVALID;
432: 	}
433: 	if (StringUtil::Equals(value, "ALTER_TABLE")) {
434: 		return AlterType::ALTER_TABLE;
435: 	}
436: 	if (StringUtil::Equals(value, "ALTER_VIEW")) {
437: 		return AlterType::ALTER_VIEW;
438: 	}
439: 	if (StringUtil::Equals(value, "ALTER_SEQUENCE")) {
440: 		return AlterType::ALTER_SEQUENCE;
441: 	}
442: 	if (StringUtil::Equals(value, "CHANGE_OWNERSHIP")) {
443: 		return AlterType::CHANGE_OWNERSHIP;
444: 	}
445: 	if (StringUtil::Equals(value, "ALTER_SCALAR_FUNCTION")) {
446: 		return AlterType::ALTER_SCALAR_FUNCTION;
447: 	}
448: 	if (StringUtil::Equals(value, "ALTER_TABLE_FUNCTION")) {
449: 		return AlterType::ALTER_TABLE_FUNCTION;
450: 	}
451: 	if (StringUtil::Equals(value, "SET_COMMENT")) {
452: 		return AlterType::SET_COMMENT;
453: 	}
454: 	if (StringUtil::Equals(value, "SET_COLUMN_COMMENT")) {
455: 		return AlterType::SET_COLUMN_COMMENT;
456: 	}
457: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
458: }
459: 
460: template<>
461: const char* EnumUtil::ToChars<AlterViewType>(AlterViewType value) {
462: 	switch(value) {
463: 	case AlterViewType::INVALID:
464: 		return "INVALID";
465: 	case AlterViewType::RENAME_VIEW:
466: 		return "RENAME_VIEW";
467: 	default:
468: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
469: 	}
470: }
471: 
472: template<>
473: AlterViewType EnumUtil::FromString<AlterViewType>(const char *value) {
474: 	if (StringUtil::Equals(value, "INVALID")) {
475: 		return AlterViewType::INVALID;
476: 	}
477: 	if (StringUtil::Equals(value, "RENAME_VIEW")) {
478: 		return AlterViewType::RENAME_VIEW;
479: 	}
480: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
481: }
482: 
483: template<>
484: const char* EnumUtil::ToChars<AppenderType>(AppenderType value) {
485: 	switch(value) {
486: 	case AppenderType::LOGICAL:
487: 		return "LOGICAL";
488: 	case AppenderType::PHYSICAL:
489: 		return "PHYSICAL";
490: 	default:
491: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
492: 	}
493: }
494: 
495: template<>
496: AppenderType EnumUtil::FromString<AppenderType>(const char *value) {
497: 	if (StringUtil::Equals(value, "LOGICAL")) {
498: 		return AppenderType::LOGICAL;
499: 	}
500: 	if (StringUtil::Equals(value, "PHYSICAL")) {
501: 		return AppenderType::PHYSICAL;
502: 	}
503: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
504: }
505: 
506: template<>
507: const char* EnumUtil::ToChars<ArrowDateTimeType>(ArrowDateTimeType value) {
508: 	switch(value) {
509: 	case ArrowDateTimeType::MILLISECONDS:
510: 		return "MILLISECONDS";
511: 	case ArrowDateTimeType::MICROSECONDS:
512: 		return "MICROSECONDS";
513: 	case ArrowDateTimeType::NANOSECONDS:
514: 		return "NANOSECONDS";
515: 	case ArrowDateTimeType::SECONDS:
516: 		return "SECONDS";
517: 	case ArrowDateTimeType::DAYS:
518: 		return "DAYS";
519: 	case ArrowDateTimeType::MONTHS:
520: 		return "MONTHS";
521: 	case ArrowDateTimeType::MONTH_DAY_NANO:
522: 		return "MONTH_DAY_NANO";
523: 	default:
524: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
525: 	}
526: }
527: 
528: template<>
529: ArrowDateTimeType EnumUtil::FromString<ArrowDateTimeType>(const char *value) {
530: 	if (StringUtil::Equals(value, "MILLISECONDS")) {
531: 		return ArrowDateTimeType::MILLISECONDS;
532: 	}
533: 	if (StringUtil::Equals(value, "MICROSECONDS")) {
534: 		return ArrowDateTimeType::MICROSECONDS;
535: 	}
536: 	if (StringUtil::Equals(value, "NANOSECONDS")) {
537: 		return ArrowDateTimeType::NANOSECONDS;
538: 	}
539: 	if (StringUtil::Equals(value, "SECONDS")) {
540: 		return ArrowDateTimeType::SECONDS;
541: 	}
542: 	if (StringUtil::Equals(value, "DAYS")) {
543: 		return ArrowDateTimeType::DAYS;
544: 	}
545: 	if (StringUtil::Equals(value, "MONTHS")) {
546: 		return ArrowDateTimeType::MONTHS;
547: 	}
548: 	if (StringUtil::Equals(value, "MONTH_DAY_NANO")) {
549: 		return ArrowDateTimeType::MONTH_DAY_NANO;
550: 	}
551: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
552: }
553: 
554: template<>
555: const char* EnumUtil::ToChars<ArrowOffsetSize>(ArrowOffsetSize value) {
556: 	switch(value) {
557: 	case ArrowOffsetSize::REGULAR:
558: 		return "REGULAR";
559: 	case ArrowOffsetSize::LARGE:
560: 		return "LARGE";
561: 	default:
562: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
563: 	}
564: }
565: 
566: template<>
567: ArrowOffsetSize EnumUtil::FromString<ArrowOffsetSize>(const char *value) {
568: 	if (StringUtil::Equals(value, "REGULAR")) {
569: 		return ArrowOffsetSize::REGULAR;
570: 	}
571: 	if (StringUtil::Equals(value, "LARGE")) {
572: 		return ArrowOffsetSize::LARGE;
573: 	}
574: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
575: }
576: 
577: template<>
578: const char* EnumUtil::ToChars<ArrowVariableSizeType>(ArrowVariableSizeType value) {
579: 	switch(value) {
580: 	case ArrowVariableSizeType::FIXED_SIZE:
581: 		return "FIXED_SIZE";
582: 	case ArrowVariableSizeType::NORMAL:
583: 		return "NORMAL";
584: 	case ArrowVariableSizeType::SUPER_SIZE:
585: 		return "SUPER_SIZE";
586: 	default:
587: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
588: 	}
589: }
590: 
591: template<>
592: ArrowVariableSizeType EnumUtil::FromString<ArrowVariableSizeType>(const char *value) {
593: 	if (StringUtil::Equals(value, "FIXED_SIZE")) {
594: 		return ArrowVariableSizeType::FIXED_SIZE;
595: 	}
596: 	if (StringUtil::Equals(value, "NORMAL")) {
597: 		return ArrowVariableSizeType::NORMAL;
598: 	}
599: 	if (StringUtil::Equals(value, "SUPER_SIZE")) {
600: 		return ArrowVariableSizeType::SUPER_SIZE;
601: 	}
602: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
603: }
604: 
605: template<>
606: const char* EnumUtil::ToChars<BinderType>(BinderType value) {
607: 	switch(value) {
608: 	case BinderType::REGULAR_BINDER:
609: 		return "REGULAR_BINDER";
610: 	case BinderType::VIEW_BINDER:
611: 		return "VIEW_BINDER";
612: 	default:
613: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
614: 	}
615: }
616: 
617: template<>
618: BinderType EnumUtil::FromString<BinderType>(const char *value) {
619: 	if (StringUtil::Equals(value, "REGULAR_BINDER")) {
620: 		return BinderType::REGULAR_BINDER;
621: 	}
622: 	if (StringUtil::Equals(value, "VIEW_BINDER")) {
623: 		return BinderType::VIEW_BINDER;
624: 	}
625: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
626: }
627: 
628: template<>
629: const char* EnumUtil::ToChars<BindingMode>(BindingMode value) {
630: 	switch(value) {
631: 	case BindingMode::STANDARD_BINDING:
632: 		return "STANDARD_BINDING";
633: 	case BindingMode::EXTRACT_NAMES:
634: 		return "EXTRACT_NAMES";
635: 	default:
636: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
637: 	}
638: }
639: 
640: template<>
641: BindingMode EnumUtil::FromString<BindingMode>(const char *value) {
642: 	if (StringUtil::Equals(value, "STANDARD_BINDING")) {
643: 		return BindingMode::STANDARD_BINDING;
644: 	}
645: 	if (StringUtil::Equals(value, "EXTRACT_NAMES")) {
646: 		return BindingMode::EXTRACT_NAMES;
647: 	}
648: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
649: }
650: 
651: template<>
652: const char* EnumUtil::ToChars<BitpackingMode>(BitpackingMode value) {
653: 	switch(value) {
654: 	case BitpackingMode::INVALID:
655: 		return "INVALID";
656: 	case BitpackingMode::AUTO:
657: 		return "AUTO";
658: 	case BitpackingMode::CONSTANT:
659: 		return "CONSTANT";
660: 	case BitpackingMode::CONSTANT_DELTA:
661: 		return "CONSTANT_DELTA";
662: 	case BitpackingMode::DELTA_FOR:
663: 		return "DELTA_FOR";
664: 	case BitpackingMode::FOR:
665: 		return "FOR";
666: 	default:
667: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
668: 	}
669: }
670: 
671: template<>
672: BitpackingMode EnumUtil::FromString<BitpackingMode>(const char *value) {
673: 	if (StringUtil::Equals(value, "INVALID")) {
674: 		return BitpackingMode::INVALID;
675: 	}
676: 	if (StringUtil::Equals(value, "AUTO")) {
677: 		return BitpackingMode::AUTO;
678: 	}
679: 	if (StringUtil::Equals(value, "CONSTANT")) {
680: 		return BitpackingMode::CONSTANT;
681: 	}
682: 	if (StringUtil::Equals(value, "CONSTANT_DELTA")) {
683: 		return BitpackingMode::CONSTANT_DELTA;
684: 	}
685: 	if (StringUtil::Equals(value, "DELTA_FOR")) {
686: 		return BitpackingMode::DELTA_FOR;
687: 	}
688: 	if (StringUtil::Equals(value, "FOR")) {
689: 		return BitpackingMode::FOR;
690: 	}
691: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
692: }
693: 
694: template<>
695: const char* EnumUtil::ToChars<BlockState>(BlockState value) {
696: 	switch(value) {
697: 	case BlockState::BLOCK_UNLOADED:
698: 		return "BLOCK_UNLOADED";
699: 	case BlockState::BLOCK_LOADED:
700: 		return "BLOCK_LOADED";
701: 	default:
702: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
703: 	}
704: }
705: 
706: template<>
707: BlockState EnumUtil::FromString<BlockState>(const char *value) {
708: 	if (StringUtil::Equals(value, "BLOCK_UNLOADED")) {
709: 		return BlockState::BLOCK_UNLOADED;
710: 	}
711: 	if (StringUtil::Equals(value, "BLOCK_LOADED")) {
712: 		return BlockState::BLOCK_LOADED;
713: 	}
714: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
715: }
716: 
717: template<>
718: const char* EnumUtil::ToChars<CAPIResultSetType>(CAPIResultSetType value) {
719: 	switch(value) {
720: 	case CAPIResultSetType::CAPI_RESULT_TYPE_NONE:
721: 		return "CAPI_RESULT_TYPE_NONE";
722: 	case CAPIResultSetType::CAPI_RESULT_TYPE_MATERIALIZED:
723: 		return "CAPI_RESULT_TYPE_MATERIALIZED";
724: 	case CAPIResultSetType::CAPI_RESULT_TYPE_STREAMING:
725: 		return "CAPI_RESULT_TYPE_STREAMING";
726: 	case CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED:
727: 		return "CAPI_RESULT_TYPE_DEPRECATED";
728: 	default:
729: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
730: 	}
731: }
732: 
733: template<>
734: CAPIResultSetType EnumUtil::FromString<CAPIResultSetType>(const char *value) {
735: 	if (StringUtil::Equals(value, "CAPI_RESULT_TYPE_NONE")) {
736: 		return CAPIResultSetType::CAPI_RESULT_TYPE_NONE;
737: 	}
738: 	if (StringUtil::Equals(value, "CAPI_RESULT_TYPE_MATERIALIZED")) {
739: 		return CAPIResultSetType::CAPI_RESULT_TYPE_MATERIALIZED;
740: 	}
741: 	if (StringUtil::Equals(value, "CAPI_RESULT_TYPE_STREAMING")) {
742: 		return CAPIResultSetType::CAPI_RESULT_TYPE_STREAMING;
743: 	}
744: 	if (StringUtil::Equals(value, "CAPI_RESULT_TYPE_DEPRECATED")) {
745: 		return CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED;
746: 	}
747: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
748: }
749: 
750: template<>
751: const char* EnumUtil::ToChars<CSVState>(CSVState value) {
752: 	switch(value) {
753: 	case CSVState::STANDARD:
754: 		return "STANDARD";
755: 	case CSVState::DELIMITER:
756: 		return "DELIMITER";
757: 	case CSVState::RECORD_SEPARATOR:
758: 		return "RECORD_SEPARATOR";
759: 	case CSVState::CARRIAGE_RETURN:
760: 		return "CARRIAGE_RETURN";
761: 	case CSVState::QUOTED:
762: 		return "QUOTED";
763: 	case CSVState::UNQUOTED:
764: 		return "UNQUOTED";
765: 	case CSVState::ESCAPE:
766: 		return "ESCAPE";
767: 	case CSVState::INVALID:
768: 		return "INVALID";
769: 	case CSVState::NOT_SET:
770: 		return "NOT_SET";
771: 	case CSVState::QUOTED_NEW_LINE:
772: 		return "QUOTED_NEW_LINE";
773: 	case CSVState::EMPTY_SPACE:
774: 		return "EMPTY_SPACE";
775: 	default:
776: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
777: 	}
778: }
779: 
780: template<>
781: CSVState EnumUtil::FromString<CSVState>(const char *value) {
782: 	if (StringUtil::Equals(value, "STANDARD")) {
783: 		return CSVState::STANDARD;
784: 	}
785: 	if (StringUtil::Equals(value, "DELIMITER")) {
786: 		return CSVState::DELIMITER;
787: 	}
788: 	if (StringUtil::Equals(value, "RECORD_SEPARATOR")) {
789: 		return CSVState::RECORD_SEPARATOR;
790: 	}
791: 	if (StringUtil::Equals(value, "CARRIAGE_RETURN")) {
792: 		return CSVState::CARRIAGE_RETURN;
793: 	}
794: 	if (StringUtil::Equals(value, "QUOTED")) {
795: 		return CSVState::QUOTED;
796: 	}
797: 	if (StringUtil::Equals(value, "UNQUOTED")) {
798: 		return CSVState::UNQUOTED;
799: 	}
800: 	if (StringUtil::Equals(value, "ESCAPE")) {
801: 		return CSVState::ESCAPE;
802: 	}
803: 	if (StringUtil::Equals(value, "INVALID")) {
804: 		return CSVState::INVALID;
805: 	}
806: 	if (StringUtil::Equals(value, "NOT_SET")) {
807: 		return CSVState::NOT_SET;
808: 	}
809: 	if (StringUtil::Equals(value, "QUOTED_NEW_LINE")) {
810: 		return CSVState::QUOTED_NEW_LINE;
811: 	}
812: 	if (StringUtil::Equals(value, "EMPTY_SPACE")) {
813: 		return CSVState::EMPTY_SPACE;
814: 	}
815: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
816: }
817: 
818: template<>
819: const char* EnumUtil::ToChars<CTEMaterialize>(CTEMaterialize value) {
820: 	switch(value) {
821: 	case CTEMaterialize::CTE_MATERIALIZE_DEFAULT:
822: 		return "CTE_MATERIALIZE_DEFAULT";
823: 	case CTEMaterialize::CTE_MATERIALIZE_ALWAYS:
824: 		return "CTE_MATERIALIZE_ALWAYS";
825: 	case CTEMaterialize::CTE_MATERIALIZE_NEVER:
826: 		return "CTE_MATERIALIZE_NEVER";
827: 	default:
828: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
829: 	}
830: }
831: 
832: template<>
833: CTEMaterialize EnumUtil::FromString<CTEMaterialize>(const char *value) {
834: 	if (StringUtil::Equals(value, "CTE_MATERIALIZE_DEFAULT")) {
835: 		return CTEMaterialize::CTE_MATERIALIZE_DEFAULT;
836: 	}
837: 	if (StringUtil::Equals(value, "CTE_MATERIALIZE_ALWAYS")) {
838: 		return CTEMaterialize::CTE_MATERIALIZE_ALWAYS;
839: 	}
840: 	if (StringUtil::Equals(value, "CTE_MATERIALIZE_NEVER")) {
841: 		return CTEMaterialize::CTE_MATERIALIZE_NEVER;
842: 	}
843: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
844: }
845: 
846: template<>
847: const char* EnumUtil::ToChars<CatalogLookupBehavior>(CatalogLookupBehavior value) {
848: 	switch(value) {
849: 	case CatalogLookupBehavior::STANDARD:
850: 		return "STANDARD";
851: 	case CatalogLookupBehavior::LOWER_PRIORITY:
852: 		return "LOWER_PRIORITY";
853: 	case CatalogLookupBehavior::NEVER_LOOKUP:
854: 		return "NEVER_LOOKUP";
855: 	default:
856: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
857: 	}
858: }
859: 
860: template<>
861: CatalogLookupBehavior EnumUtil::FromString<CatalogLookupBehavior>(const char *value) {
862: 	if (StringUtil::Equals(value, "STANDARD")) {
863: 		return CatalogLookupBehavior::STANDARD;
864: 	}
865: 	if (StringUtil::Equals(value, "LOWER_PRIORITY")) {
866: 		return CatalogLookupBehavior::LOWER_PRIORITY;
867: 	}
868: 	if (StringUtil::Equals(value, "NEVER_LOOKUP")) {
869: 		return CatalogLookupBehavior::NEVER_LOOKUP;
870: 	}
871: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
872: }
873: 
874: template<>
875: const char* EnumUtil::ToChars<CatalogType>(CatalogType value) {
876: 	switch(value) {
877: 	case CatalogType::INVALID:
878: 		return "INVALID";
879: 	case CatalogType::TABLE_ENTRY:
880: 		return "TABLE_ENTRY";
881: 	case CatalogType::SCHEMA_ENTRY:
882: 		return "SCHEMA_ENTRY";
883: 	case CatalogType::VIEW_ENTRY:
884: 		return "VIEW_ENTRY";
885: 	case CatalogType::INDEX_ENTRY:
886: 		return "INDEX_ENTRY";
887: 	case CatalogType::PREPARED_STATEMENT:
888: 		return "PREPARED_STATEMENT";
889: 	case CatalogType::SEQUENCE_ENTRY:
890: 		return "SEQUENCE_ENTRY";
891: 	case CatalogType::COLLATION_ENTRY:
892: 		return "COLLATION_ENTRY";
893: 	case CatalogType::TYPE_ENTRY:
894: 		return "TYPE_ENTRY";
895: 	case CatalogType::DATABASE_ENTRY:
896: 		return "DATABASE_ENTRY";
897: 	case CatalogType::TABLE_FUNCTION_ENTRY:
898: 		return "TABLE_FUNCTION_ENTRY";
899: 	case CatalogType::SCALAR_FUNCTION_ENTRY:
900: 		return "SCALAR_FUNCTION_ENTRY";
901: 	case CatalogType::AGGREGATE_FUNCTION_ENTRY:
902: 		return "AGGREGATE_FUNCTION_ENTRY";
903: 	case CatalogType::PRAGMA_FUNCTION_ENTRY:
904: 		return "PRAGMA_FUNCTION_ENTRY";
905: 	case CatalogType::COPY_FUNCTION_ENTRY:
906: 		return "COPY_FUNCTION_ENTRY";
907: 	case CatalogType::MACRO_ENTRY:
908: 		return "MACRO_ENTRY";
909: 	case CatalogType::TABLE_MACRO_ENTRY:
910: 		return "TABLE_MACRO_ENTRY";
911: 	case CatalogType::DELETED_ENTRY:
912: 		return "DELETED_ENTRY";
913: 	case CatalogType::RENAMED_ENTRY:
914: 		return "RENAMED_ENTRY";
915: 	case CatalogType::SECRET_ENTRY:
916: 		return "SECRET_ENTRY";
917: 	case CatalogType::SECRET_TYPE_ENTRY:
918: 		return "SECRET_TYPE_ENTRY";
919: 	case CatalogType::SECRET_FUNCTION_ENTRY:
920: 		return "SECRET_FUNCTION_ENTRY";
921: 	case CatalogType::DEPENDENCY_ENTRY:
922: 		return "DEPENDENCY_ENTRY";
923: 	default:
924: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
925: 	}
926: }
927: 
928: template<>
929: CatalogType EnumUtil::FromString<CatalogType>(const char *value) {
930: 	if (StringUtil::Equals(value, "INVALID")) {
931: 		return CatalogType::INVALID;
932: 	}
933: 	if (StringUtil::Equals(value, "TABLE_ENTRY")) {
934: 		return CatalogType::TABLE_ENTRY;
935: 	}
936: 	if (StringUtil::Equals(value, "SCHEMA_ENTRY")) {
937: 		return CatalogType::SCHEMA_ENTRY;
938: 	}
939: 	if (StringUtil::Equals(value, "VIEW_ENTRY")) {
940: 		return CatalogType::VIEW_ENTRY;
941: 	}
942: 	if (StringUtil::Equals(value, "INDEX_ENTRY")) {
943: 		return CatalogType::INDEX_ENTRY;
944: 	}
945: 	if (StringUtil::Equals(value, "PREPARED_STATEMENT")) {
946: 		return CatalogType::PREPARED_STATEMENT;
947: 	}
948: 	if (StringUtil::Equals(value, "SEQUENCE_ENTRY")) {
949: 		return CatalogType::SEQUENCE_ENTRY;
950: 	}
951: 	if (StringUtil::Equals(value, "COLLATION_ENTRY")) {
952: 		return CatalogType::COLLATION_ENTRY;
953: 	}
954: 	if (StringUtil::Equals(value, "TYPE_ENTRY")) {
955: 		return CatalogType::TYPE_ENTRY;
956: 	}
957: 	if (StringUtil::Equals(value, "DATABASE_ENTRY")) {
958: 		return CatalogType::DATABASE_ENTRY;
959: 	}
960: 	if (StringUtil::Equals(value, "TABLE_FUNCTION_ENTRY")) {
961: 		return CatalogType::TABLE_FUNCTION_ENTRY;
962: 	}
963: 	if (StringUtil::Equals(value, "SCALAR_FUNCTION_ENTRY")) {
964: 		return CatalogType::SCALAR_FUNCTION_ENTRY;
965: 	}
966: 	if (StringUtil::Equals(value, "AGGREGATE_FUNCTION_ENTRY")) {
967: 		return CatalogType::AGGREGATE_FUNCTION_ENTRY;
968: 	}
969: 	if (StringUtil::Equals(value, "PRAGMA_FUNCTION_ENTRY")) {
970: 		return CatalogType::PRAGMA_FUNCTION_ENTRY;
971: 	}
972: 	if (StringUtil::Equals(value, "COPY_FUNCTION_ENTRY")) {
973: 		return CatalogType::COPY_FUNCTION_ENTRY;
974: 	}
975: 	if (StringUtil::Equals(value, "MACRO_ENTRY")) {
976: 		return CatalogType::MACRO_ENTRY;
977: 	}
978: 	if (StringUtil::Equals(value, "TABLE_MACRO_ENTRY")) {
979: 		return CatalogType::TABLE_MACRO_ENTRY;
980: 	}
981: 	if (StringUtil::Equals(value, "DELETED_ENTRY")) {
982: 		return CatalogType::DELETED_ENTRY;
983: 	}
984: 	if (StringUtil::Equals(value, "RENAMED_ENTRY")) {
985: 		return CatalogType::RENAMED_ENTRY;
986: 	}
987: 	if (StringUtil::Equals(value, "SECRET_ENTRY")) {
988: 		return CatalogType::SECRET_ENTRY;
989: 	}
990: 	if (StringUtil::Equals(value, "SECRET_TYPE_ENTRY")) {
991: 		return CatalogType::SECRET_TYPE_ENTRY;
992: 	}
993: 	if (StringUtil::Equals(value, "SECRET_FUNCTION_ENTRY")) {
994: 		return CatalogType::SECRET_FUNCTION_ENTRY;
995: 	}
996: 	if (StringUtil::Equals(value, "DEPENDENCY_ENTRY")) {
997: 		return CatalogType::DEPENDENCY_ENTRY;
998: 	}
999: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1000: }
1001: 
1002: template<>
1003: const char* EnumUtil::ToChars<CheckpointAbort>(CheckpointAbort value) {
1004: 	switch(value) {
1005: 	case CheckpointAbort::NO_ABORT:
1006: 		return "NO_ABORT";
1007: 	case CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE:
1008: 		return "DEBUG_ABORT_BEFORE_TRUNCATE";
1009: 	case CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER:
1010: 		return "DEBUG_ABORT_BEFORE_HEADER";
1011: 	case CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE:
1012: 		return "DEBUG_ABORT_AFTER_FREE_LIST_WRITE";
1013: 	default:
1014: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1015: 	}
1016: }
1017: 
1018: template<>
1019: CheckpointAbort EnumUtil::FromString<CheckpointAbort>(const char *value) {
1020: 	if (StringUtil::Equals(value, "NO_ABORT")) {
1021: 		return CheckpointAbort::NO_ABORT;
1022: 	}
1023: 	if (StringUtil::Equals(value, "DEBUG_ABORT_BEFORE_TRUNCATE")) {
1024: 		return CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE;
1025: 	}
1026: 	if (StringUtil::Equals(value, "DEBUG_ABORT_BEFORE_HEADER")) {
1027: 		return CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER;
1028: 	}
1029: 	if (StringUtil::Equals(value, "DEBUG_ABORT_AFTER_FREE_LIST_WRITE")) {
1030: 		return CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE;
1031: 	}
1032: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1033: }
1034: 
1035: template<>
1036: const char* EnumUtil::ToChars<ChunkInfoType>(ChunkInfoType value) {
1037: 	switch(value) {
1038: 	case ChunkInfoType::CONSTANT_INFO:
1039: 		return "CONSTANT_INFO";
1040: 	case ChunkInfoType::VECTOR_INFO:
1041: 		return "VECTOR_INFO";
1042: 	case ChunkInfoType::EMPTY_INFO:
1043: 		return "EMPTY_INFO";
1044: 	default:
1045: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1046: 	}
1047: }
1048: 
1049: template<>
1050: ChunkInfoType EnumUtil::FromString<ChunkInfoType>(const char *value) {
1051: 	if (StringUtil::Equals(value, "CONSTANT_INFO")) {
1052: 		return ChunkInfoType::CONSTANT_INFO;
1053: 	}
1054: 	if (StringUtil::Equals(value, "VECTOR_INFO")) {
1055: 		return ChunkInfoType::VECTOR_INFO;
1056: 	}
1057: 	if (StringUtil::Equals(value, "EMPTY_INFO")) {
1058: 		return ChunkInfoType::EMPTY_INFO;
1059: 	}
1060: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1061: }
1062: 
1063: template<>
1064: const char* EnumUtil::ToChars<ColumnDataAllocatorType>(ColumnDataAllocatorType value) {
1065: 	switch(value) {
1066: 	case ColumnDataAllocatorType::BUFFER_MANAGER_ALLOCATOR:
1067: 		return "BUFFER_MANAGER_ALLOCATOR";
1068: 	case ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR:
1069: 		return "IN_MEMORY_ALLOCATOR";
1070: 	case ColumnDataAllocatorType::HYBRID:
1071: 		return "HYBRID";
1072: 	default:
1073: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1074: 	}
1075: }
1076: 
1077: template<>
1078: ColumnDataAllocatorType EnumUtil::FromString<ColumnDataAllocatorType>(const char *value) {
1079: 	if (StringUtil::Equals(value, "BUFFER_MANAGER_ALLOCATOR")) {
1080: 		return ColumnDataAllocatorType::BUFFER_MANAGER_ALLOCATOR;
1081: 	}
1082: 	if (StringUtil::Equals(value, "IN_MEMORY_ALLOCATOR")) {
1083: 		return ColumnDataAllocatorType::IN_MEMORY_ALLOCATOR;
1084: 	}
1085: 	if (StringUtil::Equals(value, "HYBRID")) {
1086: 		return ColumnDataAllocatorType::HYBRID;
1087: 	}
1088: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1089: }
1090: 
1091: template<>
1092: const char* EnumUtil::ToChars<ColumnDataScanProperties>(ColumnDataScanProperties value) {
1093: 	switch(value) {
1094: 	case ColumnDataScanProperties::INVALID:
1095: 		return "INVALID";
1096: 	case ColumnDataScanProperties::ALLOW_ZERO_COPY:
1097: 		return "ALLOW_ZERO_COPY";
1098: 	case ColumnDataScanProperties::DISALLOW_ZERO_COPY:
1099: 		return "DISALLOW_ZERO_COPY";
1100: 	default:
1101: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1102: 	}
1103: }
1104: 
1105: template<>
1106: ColumnDataScanProperties EnumUtil::FromString<ColumnDataScanProperties>(const char *value) {
1107: 	if (StringUtil::Equals(value, "INVALID")) {
1108: 		return ColumnDataScanProperties::INVALID;
1109: 	}
1110: 	if (StringUtil::Equals(value, "ALLOW_ZERO_COPY")) {
1111: 		return ColumnDataScanProperties::ALLOW_ZERO_COPY;
1112: 	}
1113: 	if (StringUtil::Equals(value, "DISALLOW_ZERO_COPY")) {
1114: 		return ColumnDataScanProperties::DISALLOW_ZERO_COPY;
1115: 	}
1116: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1117: }
1118: 
1119: template<>
1120: const char* EnumUtil::ToChars<ColumnSegmentType>(ColumnSegmentType value) {
1121: 	switch(value) {
1122: 	case ColumnSegmentType::TRANSIENT:
1123: 		return "TRANSIENT";
1124: 	case ColumnSegmentType::PERSISTENT:
1125: 		return "PERSISTENT";
1126: 	default:
1127: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1128: 	}
1129: }
1130: 
1131: template<>
1132: ColumnSegmentType EnumUtil::FromString<ColumnSegmentType>(const char *value) {
1133: 	if (StringUtil::Equals(value, "TRANSIENT")) {
1134: 		return ColumnSegmentType::TRANSIENT;
1135: 	}
1136: 	if (StringUtil::Equals(value, "PERSISTENT")) {
1137: 		return ColumnSegmentType::PERSISTENT;
1138: 	}
1139: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1140: }
1141: 
1142: template<>
1143: const char* EnumUtil::ToChars<CompressedMaterializationDirection>(CompressedMaterializationDirection value) {
1144: 	switch(value) {
1145: 	case CompressedMaterializationDirection::INVALID:
1146: 		return "INVALID";
1147: 	case CompressedMaterializationDirection::COMPRESS:
1148: 		return "COMPRESS";
1149: 	case CompressedMaterializationDirection::DECOMPRESS:
1150: 		return "DECOMPRESS";
1151: 	default:
1152: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1153: 	}
1154: }
1155: 
1156: template<>
1157: CompressedMaterializationDirection EnumUtil::FromString<CompressedMaterializationDirection>(const char *value) {
1158: 	if (StringUtil::Equals(value, "INVALID")) {
1159: 		return CompressedMaterializationDirection::INVALID;
1160: 	}
1161: 	if (StringUtil::Equals(value, "COMPRESS")) {
1162: 		return CompressedMaterializationDirection::COMPRESS;
1163: 	}
1164: 	if (StringUtil::Equals(value, "DECOMPRESS")) {
1165: 		return CompressedMaterializationDirection::DECOMPRESS;
1166: 	}
1167: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1168: }
1169: 
1170: template<>
1171: const char* EnumUtil::ToChars<CompressionType>(CompressionType value) {
1172: 	switch(value) {
1173: 	case CompressionType::COMPRESSION_AUTO:
1174: 		return "COMPRESSION_AUTO";
1175: 	case CompressionType::COMPRESSION_UNCOMPRESSED:
1176: 		return "COMPRESSION_UNCOMPRESSED";
1177: 	case CompressionType::COMPRESSION_CONSTANT:
1178: 		return "COMPRESSION_CONSTANT";
1179: 	case CompressionType::COMPRESSION_RLE:
1180: 		return "COMPRESSION_RLE";
1181: 	case CompressionType::COMPRESSION_DICTIONARY:
1182: 		return "COMPRESSION_DICTIONARY";
1183: 	case CompressionType::COMPRESSION_PFOR_DELTA:
1184: 		return "COMPRESSION_PFOR_DELTA";
1185: 	case CompressionType::COMPRESSION_BITPACKING:
1186: 		return "COMPRESSION_BITPACKING";
1187: 	case CompressionType::COMPRESSION_FSST:
1188: 		return "COMPRESSION_FSST";
1189: 	case CompressionType::COMPRESSION_CHIMP:
1190: 		return "COMPRESSION_CHIMP";
1191: 	case CompressionType::COMPRESSION_PATAS:
1192: 		return "COMPRESSION_PATAS";
1193: 	case CompressionType::COMPRESSION_ALP:
1194: 		return "COMPRESSION_ALP";
1195: 	case CompressionType::COMPRESSION_ALPRD:
1196: 		return "COMPRESSION_ALPRD";
1197: 	case CompressionType::COMPRESSION_COUNT:
1198: 		return "COMPRESSION_COUNT";
1199: 	default:
1200: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1201: 	}
1202: }
1203: 
1204: template<>
1205: CompressionType EnumUtil::FromString<CompressionType>(const char *value) {
1206: 	if (StringUtil::Equals(value, "COMPRESSION_AUTO")) {
1207: 		return CompressionType::COMPRESSION_AUTO;
1208: 	}
1209: 	if (StringUtil::Equals(value, "COMPRESSION_UNCOMPRESSED")) {
1210: 		return CompressionType::COMPRESSION_UNCOMPRESSED;
1211: 	}
1212: 	if (StringUtil::Equals(value, "COMPRESSION_CONSTANT")) {
1213: 		return CompressionType::COMPRESSION_CONSTANT;
1214: 	}
1215: 	if (StringUtil::Equals(value, "COMPRESSION_RLE")) {
1216: 		return CompressionType::COMPRESSION_RLE;
1217: 	}
1218: 	if (StringUtil::Equals(value, "COMPRESSION_DICTIONARY")) {
1219: 		return CompressionType::COMPRESSION_DICTIONARY;
1220: 	}
1221: 	if (StringUtil::Equals(value, "COMPRESSION_PFOR_DELTA")) {
1222: 		return CompressionType::COMPRESSION_PFOR_DELTA;
1223: 	}
1224: 	if (StringUtil::Equals(value, "COMPRESSION_BITPACKING")) {
1225: 		return CompressionType::COMPRESSION_BITPACKING;
1226: 	}
1227: 	if (StringUtil::Equals(value, "COMPRESSION_FSST")) {
1228: 		return CompressionType::COMPRESSION_FSST;
1229: 	}
1230: 	if (StringUtil::Equals(value, "COMPRESSION_CHIMP")) {
1231: 		return CompressionType::COMPRESSION_CHIMP;
1232: 	}
1233: 	if (StringUtil::Equals(value, "COMPRESSION_PATAS")) {
1234: 		return CompressionType::COMPRESSION_PATAS;
1235: 	}
1236: 	if (StringUtil::Equals(value, "COMPRESSION_ALP")) {
1237: 		return CompressionType::COMPRESSION_ALP;
1238: 	}
1239: 	if (StringUtil::Equals(value, "COMPRESSION_ALPRD")) {
1240: 		return CompressionType::COMPRESSION_ALPRD;
1241: 	}
1242: 	if (StringUtil::Equals(value, "COMPRESSION_COUNT")) {
1243: 		return CompressionType::COMPRESSION_COUNT;
1244: 	}
1245: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1246: }
1247: 
1248: template<>
1249: const char* EnumUtil::ToChars<ConflictManagerMode>(ConflictManagerMode value) {
1250: 	switch(value) {
1251: 	case ConflictManagerMode::SCAN:
1252: 		return "SCAN";
1253: 	case ConflictManagerMode::THROW:
1254: 		return "THROW";
1255: 	default:
1256: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1257: 	}
1258: }
1259: 
1260: template<>
1261: ConflictManagerMode EnumUtil::FromString<ConflictManagerMode>(const char *value) {
1262: 	if (StringUtil::Equals(value, "SCAN")) {
1263: 		return ConflictManagerMode::SCAN;
1264: 	}
1265: 	if (StringUtil::Equals(value, "THROW")) {
1266: 		return ConflictManagerMode::THROW;
1267: 	}
1268: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1269: }
1270: 
1271: template<>
1272: const char* EnumUtil::ToChars<ConstraintType>(ConstraintType value) {
1273: 	switch(value) {
1274: 	case ConstraintType::INVALID:
1275: 		return "INVALID";
1276: 	case ConstraintType::NOT_NULL:
1277: 		return "NOT_NULL";
1278: 	case ConstraintType::CHECK:
1279: 		return "CHECK";
1280: 	case ConstraintType::UNIQUE:
1281: 		return "UNIQUE";
1282: 	case ConstraintType::FOREIGN_KEY:
1283: 		return "FOREIGN_KEY";
1284: 	default:
1285: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1286: 	}
1287: }
1288: 
1289: template<>
1290: ConstraintType EnumUtil::FromString<ConstraintType>(const char *value) {
1291: 	if (StringUtil::Equals(value, "INVALID")) {
1292: 		return ConstraintType::INVALID;
1293: 	}
1294: 	if (StringUtil::Equals(value, "NOT_NULL")) {
1295: 		return ConstraintType::NOT_NULL;
1296: 	}
1297: 	if (StringUtil::Equals(value, "CHECK")) {
1298: 		return ConstraintType::CHECK;
1299: 	}
1300: 	if (StringUtil::Equals(value, "UNIQUE")) {
1301: 		return ConstraintType::UNIQUE;
1302: 	}
1303: 	if (StringUtil::Equals(value, "FOREIGN_KEY")) {
1304: 		return ConstraintType::FOREIGN_KEY;
1305: 	}
1306: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1307: }
1308: 
1309: template<>
1310: const char* EnumUtil::ToChars<DataFileType>(DataFileType value) {
1311: 	switch(value) {
1312: 	case DataFileType::FILE_DOES_NOT_EXIST:
1313: 		return "FILE_DOES_NOT_EXIST";
1314: 	case DataFileType::DUCKDB_FILE:
1315: 		return "DUCKDB_FILE";
1316: 	case DataFileType::SQLITE_FILE:
1317: 		return "SQLITE_FILE";
1318: 	case DataFileType::PARQUET_FILE:
1319: 		return "PARQUET_FILE";
1320: 	default:
1321: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1322: 	}
1323: }
1324: 
1325: template<>
1326: DataFileType EnumUtil::FromString<DataFileType>(const char *value) {
1327: 	if (StringUtil::Equals(value, "FILE_DOES_NOT_EXIST")) {
1328: 		return DataFileType::FILE_DOES_NOT_EXIST;
1329: 	}
1330: 	if (StringUtil::Equals(value, "DUCKDB_FILE")) {
1331: 		return DataFileType::DUCKDB_FILE;
1332: 	}
1333: 	if (StringUtil::Equals(value, "SQLITE_FILE")) {
1334: 		return DataFileType::SQLITE_FILE;
1335: 	}
1336: 	if (StringUtil::Equals(value, "PARQUET_FILE")) {
1337: 		return DataFileType::PARQUET_FILE;
1338: 	}
1339: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1340: }
1341: 
1342: template<>
1343: const char* EnumUtil::ToChars<DatePartSpecifier>(DatePartSpecifier value) {
1344: 	switch(value) {
1345: 	case DatePartSpecifier::YEAR:
1346: 		return "YEAR";
1347: 	case DatePartSpecifier::MONTH:
1348: 		return "MONTH";
1349: 	case DatePartSpecifier::DAY:
1350: 		return "DAY";
1351: 	case DatePartSpecifier::DECADE:
1352: 		return "DECADE";
1353: 	case DatePartSpecifier::CENTURY:
1354: 		return "CENTURY";
1355: 	case DatePartSpecifier::MILLENNIUM:
1356: 		return "MILLENNIUM";
1357: 	case DatePartSpecifier::MICROSECONDS:
1358: 		return "MICROSECONDS";
1359: 	case DatePartSpecifier::MILLISECONDS:
1360: 		return "MILLISECONDS";
1361: 	case DatePartSpecifier::SECOND:
1362: 		return "SECOND";
1363: 	case DatePartSpecifier::MINUTE:
1364: 		return "MINUTE";
1365: 	case DatePartSpecifier::HOUR:
1366: 		return "HOUR";
1367: 	case DatePartSpecifier::DOW:
1368: 		return "DOW";
1369: 	case DatePartSpecifier::ISODOW:
1370: 		return "ISODOW";
1371: 	case DatePartSpecifier::WEEK:
1372: 		return "WEEK";
1373: 	case DatePartSpecifier::ISOYEAR:
1374: 		return "ISOYEAR";
1375: 	case DatePartSpecifier::QUARTER:
1376: 		return "QUARTER";
1377: 	case DatePartSpecifier::DOY:
1378: 		return "DOY";
1379: 	case DatePartSpecifier::YEARWEEK:
1380: 		return "YEARWEEK";
1381: 	case DatePartSpecifier::ERA:
1382: 		return "ERA";
1383: 	case DatePartSpecifier::TIMEZONE:
1384: 		return "TIMEZONE";
1385: 	case DatePartSpecifier::TIMEZONE_HOUR:
1386: 		return "TIMEZONE_HOUR";
1387: 	case DatePartSpecifier::TIMEZONE_MINUTE:
1388: 		return "TIMEZONE_MINUTE";
1389: 	case DatePartSpecifier::EPOCH:
1390: 		return "EPOCH";
1391: 	case DatePartSpecifier::JULIAN_DAY:
1392: 		return "JULIAN_DAY";
1393: 	case DatePartSpecifier::INVALID:
1394: 		return "INVALID";
1395: 	default:
1396: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1397: 	}
1398: }
1399: 
1400: template<>
1401: DatePartSpecifier EnumUtil::FromString<DatePartSpecifier>(const char *value) {
1402: 	if (StringUtil::Equals(value, "YEAR")) {
1403: 		return DatePartSpecifier::YEAR;
1404: 	}
1405: 	if (StringUtil::Equals(value, "MONTH")) {
1406: 		return DatePartSpecifier::MONTH;
1407: 	}
1408: 	if (StringUtil::Equals(value, "DAY")) {
1409: 		return DatePartSpecifier::DAY;
1410: 	}
1411: 	if (StringUtil::Equals(value, "DECADE")) {
1412: 		return DatePartSpecifier::DECADE;
1413: 	}
1414: 	if (StringUtil::Equals(value, "CENTURY")) {
1415: 		return DatePartSpecifier::CENTURY;
1416: 	}
1417: 	if (StringUtil::Equals(value, "MILLENNIUM")) {
1418: 		return DatePartSpecifier::MILLENNIUM;
1419: 	}
1420: 	if (StringUtil::Equals(value, "MICROSECONDS")) {
1421: 		return DatePartSpecifier::MICROSECONDS;
1422: 	}
1423: 	if (StringUtil::Equals(value, "MILLISECONDS")) {
1424: 		return DatePartSpecifier::MILLISECONDS;
1425: 	}
1426: 	if (StringUtil::Equals(value, "SECOND")) {
1427: 		return DatePartSpecifier::SECOND;
1428: 	}
1429: 	if (StringUtil::Equals(value, "MINUTE")) {
1430: 		return DatePartSpecifier::MINUTE;
1431: 	}
1432: 	if (StringUtil::Equals(value, "HOUR")) {
1433: 		return DatePartSpecifier::HOUR;
1434: 	}
1435: 	if (StringUtil::Equals(value, "DOW")) {
1436: 		return DatePartSpecifier::DOW;
1437: 	}
1438: 	if (StringUtil::Equals(value, "ISODOW")) {
1439: 		return DatePartSpecifier::ISODOW;
1440: 	}
1441: 	if (StringUtil::Equals(value, "WEEK")) {
1442: 		return DatePartSpecifier::WEEK;
1443: 	}
1444: 	if (StringUtil::Equals(value, "ISOYEAR")) {
1445: 		return DatePartSpecifier::ISOYEAR;
1446: 	}
1447: 	if (StringUtil::Equals(value, "QUARTER")) {
1448: 		return DatePartSpecifier::QUARTER;
1449: 	}
1450: 	if (StringUtil::Equals(value, "DOY")) {
1451: 		return DatePartSpecifier::DOY;
1452: 	}
1453: 	if (StringUtil::Equals(value, "YEARWEEK")) {
1454: 		return DatePartSpecifier::YEARWEEK;
1455: 	}
1456: 	if (StringUtil::Equals(value, "ERA")) {
1457: 		return DatePartSpecifier::ERA;
1458: 	}
1459: 	if (StringUtil::Equals(value, "TIMEZONE")) {
1460: 		return DatePartSpecifier::TIMEZONE;
1461: 	}
1462: 	if (StringUtil::Equals(value, "TIMEZONE_HOUR")) {
1463: 		return DatePartSpecifier::TIMEZONE_HOUR;
1464: 	}
1465: 	if (StringUtil::Equals(value, "TIMEZONE_MINUTE")) {
1466: 		return DatePartSpecifier::TIMEZONE_MINUTE;
1467: 	}
1468: 	if (StringUtil::Equals(value, "EPOCH")) {
1469: 		return DatePartSpecifier::EPOCH;
1470: 	}
1471: 	if (StringUtil::Equals(value, "JULIAN_DAY")) {
1472: 		return DatePartSpecifier::JULIAN_DAY;
1473: 	}
1474: 	if (StringUtil::Equals(value, "INVALID")) {
1475: 		return DatePartSpecifier::INVALID;
1476: 	}
1477: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1478: }
1479: 
1480: template<>
1481: const char* EnumUtil::ToChars<DebugInitialize>(DebugInitialize value) {
1482: 	switch(value) {
1483: 	case DebugInitialize::NO_INITIALIZE:
1484: 		return "NO_INITIALIZE";
1485: 	case DebugInitialize::DEBUG_ZERO_INITIALIZE:
1486: 		return "DEBUG_ZERO_INITIALIZE";
1487: 	case DebugInitialize::DEBUG_ONE_INITIALIZE:
1488: 		return "DEBUG_ONE_INITIALIZE";
1489: 	default:
1490: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1491: 	}
1492: }
1493: 
1494: template<>
1495: DebugInitialize EnumUtil::FromString<DebugInitialize>(const char *value) {
1496: 	if (StringUtil::Equals(value, "NO_INITIALIZE")) {
1497: 		return DebugInitialize::NO_INITIALIZE;
1498: 	}
1499: 	if (StringUtil::Equals(value, "DEBUG_ZERO_INITIALIZE")) {
1500: 		return DebugInitialize::DEBUG_ZERO_INITIALIZE;
1501: 	}
1502: 	if (StringUtil::Equals(value, "DEBUG_ONE_INITIALIZE")) {
1503: 		return DebugInitialize::DEBUG_ONE_INITIALIZE;
1504: 	}
1505: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1506: }
1507: 
1508: template<>
1509: const char* EnumUtil::ToChars<DefaultOrderByNullType>(DefaultOrderByNullType value) {
1510: 	switch(value) {
1511: 	case DefaultOrderByNullType::INVALID:
1512: 		return "INVALID";
1513: 	case DefaultOrderByNullType::NULLS_FIRST:
1514: 		return "NULLS_FIRST";
1515: 	case DefaultOrderByNullType::NULLS_LAST:
1516: 		return "NULLS_LAST";
1517: 	case DefaultOrderByNullType::NULLS_FIRST_ON_ASC_LAST_ON_DESC:
1518: 		return "NULLS_FIRST_ON_ASC_LAST_ON_DESC";
1519: 	case DefaultOrderByNullType::NULLS_LAST_ON_ASC_FIRST_ON_DESC:
1520: 		return "NULLS_LAST_ON_ASC_FIRST_ON_DESC";
1521: 	default:
1522: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1523: 	}
1524: }
1525: 
1526: template<>
1527: DefaultOrderByNullType EnumUtil::FromString<DefaultOrderByNullType>(const char *value) {
1528: 	if (StringUtil::Equals(value, "INVALID")) {
1529: 		return DefaultOrderByNullType::INVALID;
1530: 	}
1531: 	if (StringUtil::Equals(value, "NULLS_FIRST")) {
1532: 		return DefaultOrderByNullType::NULLS_FIRST;
1533: 	}
1534: 	if (StringUtil::Equals(value, "NULLS_LAST")) {
1535: 		return DefaultOrderByNullType::NULLS_LAST;
1536: 	}
1537: 	if (StringUtil::Equals(value, "NULLS_FIRST_ON_ASC_LAST_ON_DESC")) {
1538: 		return DefaultOrderByNullType::NULLS_FIRST_ON_ASC_LAST_ON_DESC;
1539: 	}
1540: 	if (StringUtil::Equals(value, "NULLS_LAST_ON_ASC_FIRST_ON_DESC")) {
1541: 		return DefaultOrderByNullType::NULLS_LAST_ON_ASC_FIRST_ON_DESC;
1542: 	}
1543: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1544: }
1545: 
1546: template<>
1547: const char* EnumUtil::ToChars<DependencyEntryType>(DependencyEntryType value) {
1548: 	switch(value) {
1549: 	case DependencyEntryType::SUBJECT:
1550: 		return "SUBJECT";
1551: 	case DependencyEntryType::DEPENDENT:
1552: 		return "DEPENDENT";
1553: 	default:
1554: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1555: 	}
1556: }
1557: 
1558: template<>
1559: DependencyEntryType EnumUtil::FromString<DependencyEntryType>(const char *value) {
1560: 	if (StringUtil::Equals(value, "SUBJECT")) {
1561: 		return DependencyEntryType::SUBJECT;
1562: 	}
1563: 	if (StringUtil::Equals(value, "DEPENDENT")) {
1564: 		return DependencyEntryType::DEPENDENT;
1565: 	}
1566: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1567: }
1568: 
1569: template<>
1570: const char* EnumUtil::ToChars<DeprecatedIndexType>(DeprecatedIndexType value) {
1571: 	switch(value) {
1572: 	case DeprecatedIndexType::INVALID:
1573: 		return "INVALID";
1574: 	case DeprecatedIndexType::ART:
1575: 		return "ART";
1576: 	case DeprecatedIndexType::EXTENSION:
1577: 		return "EXTENSION";
1578: 	default:
1579: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1580: 	}
1581: }
1582: 
1583: template<>
1584: DeprecatedIndexType EnumUtil::FromString<DeprecatedIndexType>(const char *value) {
1585: 	if (StringUtil::Equals(value, "INVALID")) {
1586: 		return DeprecatedIndexType::INVALID;
1587: 	}
1588: 	if (StringUtil::Equals(value, "ART")) {
1589: 		return DeprecatedIndexType::ART;
1590: 	}
1591: 	if (StringUtil::Equals(value, "EXTENSION")) {
1592: 		return DeprecatedIndexType::EXTENSION;
1593: 	}
1594: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1595: }
1596: 
1597: template<>
1598: const char* EnumUtil::ToChars<DistinctType>(DistinctType value) {
1599: 	switch(value) {
1600: 	case DistinctType::DISTINCT:
1601: 		return "DISTINCT";
1602: 	case DistinctType::DISTINCT_ON:
1603: 		return "DISTINCT_ON";
1604: 	default:
1605: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1606: 	}
1607: }
1608: 
1609: template<>
1610: DistinctType EnumUtil::FromString<DistinctType>(const char *value) {
1611: 	if (StringUtil::Equals(value, "DISTINCT")) {
1612: 		return DistinctType::DISTINCT;
1613: 	}
1614: 	if (StringUtil::Equals(value, "DISTINCT_ON")) {
1615: 		return DistinctType::DISTINCT_ON;
1616: 	}
1617: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1618: }
1619: 
1620: template<>
1621: const char* EnumUtil::ToChars<ErrorType>(ErrorType value) {
1622: 	switch(value) {
1623: 	case ErrorType::UNSIGNED_EXTENSION:
1624: 		return "UNSIGNED_EXTENSION";
1625: 	case ErrorType::INVALIDATED_TRANSACTION:
1626: 		return "INVALIDATED_TRANSACTION";
1627: 	case ErrorType::INVALIDATED_DATABASE:
1628: 		return "INVALIDATED_DATABASE";
1629: 	case ErrorType::ERROR_COUNT:
1630: 		return "ERROR_COUNT";
1631: 	case ErrorType::INVALID:
1632: 		return "INVALID";
1633: 	default:
1634: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1635: 	}
1636: }
1637: 
1638: template<>
1639: ErrorType EnumUtil::FromString<ErrorType>(const char *value) {
1640: 	if (StringUtil::Equals(value, "UNSIGNED_EXTENSION")) {
1641: 		return ErrorType::UNSIGNED_EXTENSION;
1642: 	}
1643: 	if (StringUtil::Equals(value, "INVALIDATED_TRANSACTION")) {
1644: 		return ErrorType::INVALIDATED_TRANSACTION;
1645: 	}
1646: 	if (StringUtil::Equals(value, "INVALIDATED_DATABASE")) {
1647: 		return ErrorType::INVALIDATED_DATABASE;
1648: 	}
1649: 	if (StringUtil::Equals(value, "ERROR_COUNT")) {
1650: 		return ErrorType::ERROR_COUNT;
1651: 	}
1652: 	if (StringUtil::Equals(value, "INVALID")) {
1653: 		return ErrorType::INVALID;
1654: 	}
1655: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1656: }
1657: 
1658: template<>
1659: const char* EnumUtil::ToChars<ExceptionFormatValueType>(ExceptionFormatValueType value) {
1660: 	switch(value) {
1661: 	case ExceptionFormatValueType::FORMAT_VALUE_TYPE_DOUBLE:
1662: 		return "FORMAT_VALUE_TYPE_DOUBLE";
1663: 	case ExceptionFormatValueType::FORMAT_VALUE_TYPE_INTEGER:
1664: 		return "FORMAT_VALUE_TYPE_INTEGER";
1665: 	case ExceptionFormatValueType::FORMAT_VALUE_TYPE_STRING:
1666: 		return "FORMAT_VALUE_TYPE_STRING";
1667: 	default:
1668: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1669: 	}
1670: }
1671: 
1672: template<>
1673: ExceptionFormatValueType EnumUtil::FromString<ExceptionFormatValueType>(const char *value) {
1674: 	if (StringUtil::Equals(value, "FORMAT_VALUE_TYPE_DOUBLE")) {
1675: 		return ExceptionFormatValueType::FORMAT_VALUE_TYPE_DOUBLE;
1676: 	}
1677: 	if (StringUtil::Equals(value, "FORMAT_VALUE_TYPE_INTEGER")) {
1678: 		return ExceptionFormatValueType::FORMAT_VALUE_TYPE_INTEGER;
1679: 	}
1680: 	if (StringUtil::Equals(value, "FORMAT_VALUE_TYPE_STRING")) {
1681: 		return ExceptionFormatValueType::FORMAT_VALUE_TYPE_STRING;
1682: 	}
1683: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1684: }
1685: 
1686: template<>
1687: const char* EnumUtil::ToChars<ExceptionType>(ExceptionType value) {
1688: 	switch(value) {
1689: 	case ExceptionType::INVALID:
1690: 		return "INVALID";
1691: 	case ExceptionType::OUT_OF_RANGE:
1692: 		return "OUT_OF_RANGE";
1693: 	case ExceptionType::CONVERSION:
1694: 		return "CONVERSION";
1695: 	case ExceptionType::UNKNOWN_TYPE:
1696: 		return "UNKNOWN_TYPE";
1697: 	case ExceptionType::DECIMAL:
1698: 		return "DECIMAL";
1699: 	case ExceptionType::MISMATCH_TYPE:
1700: 		return "MISMATCH_TYPE";
1701: 	case ExceptionType::DIVIDE_BY_ZERO:
1702: 		return "DIVIDE_BY_ZERO";
1703: 	case ExceptionType::OBJECT_SIZE:
1704: 		return "OBJECT_SIZE";
1705: 	case ExceptionType::INVALID_TYPE:
1706: 		return "INVALID_TYPE";
1707: 	case ExceptionType::SERIALIZATION:
1708: 		return "SERIALIZATION";
1709: 	case ExceptionType::TRANSACTION:
1710: 		return "TRANSACTION";
1711: 	case ExceptionType::NOT_IMPLEMENTED:
1712: 		return "NOT_IMPLEMENTED";
1713: 	case ExceptionType::EXPRESSION:
1714: 		return "EXPRESSION";
1715: 	case ExceptionType::CATALOG:
1716: 		return "CATALOG";
1717: 	case ExceptionType::PARSER:
1718: 		return "PARSER";
1719: 	case ExceptionType::PLANNER:
1720: 		return "PLANNER";
1721: 	case ExceptionType::SCHEDULER:
1722: 		return "SCHEDULER";
1723: 	case ExceptionType::EXECUTOR:
1724: 		return "EXECUTOR";
1725: 	case ExceptionType::CONSTRAINT:
1726: 		return "CONSTRAINT";
1727: 	case ExceptionType::INDEX:
1728: 		return "INDEX";
1729: 	case ExceptionType::STAT:
1730: 		return "STAT";
1731: 	case ExceptionType::CONNECTION:
1732: 		return "CONNECTION";
1733: 	case ExceptionType::SYNTAX:
1734: 		return "SYNTAX";
1735: 	case ExceptionType::SETTINGS:
1736: 		return "SETTINGS";
1737: 	case ExceptionType::BINDER:
1738: 		return "BINDER";
1739: 	case ExceptionType::NETWORK:
1740: 		return "NETWORK";
1741: 	case ExceptionType::OPTIMIZER:
1742: 		return "OPTIMIZER";
1743: 	case ExceptionType::NULL_POINTER:
1744: 		return "NULL_POINTER";
1745: 	case ExceptionType::IO:
1746: 		return "IO";
1747: 	case ExceptionType::INTERRUPT:
1748: 		return "INTERRUPT";
1749: 	case ExceptionType::FATAL:
1750: 		return "FATAL";
1751: 	case ExceptionType::INTERNAL:
1752: 		return "INTERNAL";
1753: 	case ExceptionType::INVALID_INPUT:
1754: 		return "INVALID_INPUT";
1755: 	case ExceptionType::OUT_OF_MEMORY:
1756: 		return "OUT_OF_MEMORY";
1757: 	case ExceptionType::PERMISSION:
1758: 		return "PERMISSION";
1759: 	case ExceptionType::PARAMETER_NOT_RESOLVED:
1760: 		return "PARAMETER_NOT_RESOLVED";
1761: 	case ExceptionType::PARAMETER_NOT_ALLOWED:
1762: 		return "PARAMETER_NOT_ALLOWED";
1763: 	case ExceptionType::DEPENDENCY:
1764: 		return "DEPENDENCY";
1765: 	case ExceptionType::HTTP:
1766: 		return "HTTP";
1767: 	case ExceptionType::MISSING_EXTENSION:
1768: 		return "MISSING_EXTENSION";
1769: 	case ExceptionType::AUTOLOAD:
1770: 		return "AUTOLOAD";
1771: 	case ExceptionType::SEQUENCE:
1772: 		return "SEQUENCE";
1773: 	default:
1774: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1775: 	}
1776: }
1777: 
1778: template<>
1779: ExceptionType EnumUtil::FromString<ExceptionType>(const char *value) {
1780: 	if (StringUtil::Equals(value, "INVALID")) {
1781: 		return ExceptionType::INVALID;
1782: 	}
1783: 	if (StringUtil::Equals(value, "OUT_OF_RANGE")) {
1784: 		return ExceptionType::OUT_OF_RANGE;
1785: 	}
1786: 	if (StringUtil::Equals(value, "CONVERSION")) {
1787: 		return ExceptionType::CONVERSION;
1788: 	}
1789: 	if (StringUtil::Equals(value, "UNKNOWN_TYPE")) {
1790: 		return ExceptionType::UNKNOWN_TYPE;
1791: 	}
1792: 	if (StringUtil::Equals(value, "DECIMAL")) {
1793: 		return ExceptionType::DECIMAL;
1794: 	}
1795: 	if (StringUtil::Equals(value, "MISMATCH_TYPE")) {
1796: 		return ExceptionType::MISMATCH_TYPE;
1797: 	}
1798: 	if (StringUtil::Equals(value, "DIVIDE_BY_ZERO")) {
1799: 		return ExceptionType::DIVIDE_BY_ZERO;
1800: 	}
1801: 	if (StringUtil::Equals(value, "OBJECT_SIZE")) {
1802: 		return ExceptionType::OBJECT_SIZE;
1803: 	}
1804: 	if (StringUtil::Equals(value, "INVALID_TYPE")) {
1805: 		return ExceptionType::INVALID_TYPE;
1806: 	}
1807: 	if (StringUtil::Equals(value, "SERIALIZATION")) {
1808: 		return ExceptionType::SERIALIZATION;
1809: 	}
1810: 	if (StringUtil::Equals(value, "TRANSACTION")) {
1811: 		return ExceptionType::TRANSACTION;
1812: 	}
1813: 	if (StringUtil::Equals(value, "NOT_IMPLEMENTED")) {
1814: 		return ExceptionType::NOT_IMPLEMENTED;
1815: 	}
1816: 	if (StringUtil::Equals(value, "EXPRESSION")) {
1817: 		return ExceptionType::EXPRESSION;
1818: 	}
1819: 	if (StringUtil::Equals(value, "CATALOG")) {
1820: 		return ExceptionType::CATALOG;
1821: 	}
1822: 	if (StringUtil::Equals(value, "PARSER")) {
1823: 		return ExceptionType::PARSER;
1824: 	}
1825: 	if (StringUtil::Equals(value, "PLANNER")) {
1826: 		return ExceptionType::PLANNER;
1827: 	}
1828: 	if (StringUtil::Equals(value, "SCHEDULER")) {
1829: 		return ExceptionType::SCHEDULER;
1830: 	}
1831: 	if (StringUtil::Equals(value, "EXECUTOR")) {
1832: 		return ExceptionType::EXECUTOR;
1833: 	}
1834: 	if (StringUtil::Equals(value, "CONSTRAINT")) {
1835: 		return ExceptionType::CONSTRAINT;
1836: 	}
1837: 	if (StringUtil::Equals(value, "INDEX")) {
1838: 		return ExceptionType::INDEX;
1839: 	}
1840: 	if (StringUtil::Equals(value, "STAT")) {
1841: 		return ExceptionType::STAT;
1842: 	}
1843: 	if (StringUtil::Equals(value, "CONNECTION")) {
1844: 		return ExceptionType::CONNECTION;
1845: 	}
1846: 	if (StringUtil::Equals(value, "SYNTAX")) {
1847: 		return ExceptionType::SYNTAX;
1848: 	}
1849: 	if (StringUtil::Equals(value, "SETTINGS")) {
1850: 		return ExceptionType::SETTINGS;
1851: 	}
1852: 	if (StringUtil::Equals(value, "BINDER")) {
1853: 		return ExceptionType::BINDER;
1854: 	}
1855: 	if (StringUtil::Equals(value, "NETWORK")) {
1856: 		return ExceptionType::NETWORK;
1857: 	}
1858: 	if (StringUtil::Equals(value, "OPTIMIZER")) {
1859: 		return ExceptionType::OPTIMIZER;
1860: 	}
1861: 	if (StringUtil::Equals(value, "NULL_POINTER")) {
1862: 		return ExceptionType::NULL_POINTER;
1863: 	}
1864: 	if (StringUtil::Equals(value, "IO")) {
1865: 		return ExceptionType::IO;
1866: 	}
1867: 	if (StringUtil::Equals(value, "INTERRUPT")) {
1868: 		return ExceptionType::INTERRUPT;
1869: 	}
1870: 	if (StringUtil::Equals(value, "FATAL")) {
1871: 		return ExceptionType::FATAL;
1872: 	}
1873: 	if (StringUtil::Equals(value, "INTERNAL")) {
1874: 		return ExceptionType::INTERNAL;
1875: 	}
1876: 	if (StringUtil::Equals(value, "INVALID_INPUT")) {
1877: 		return ExceptionType::INVALID_INPUT;
1878: 	}
1879: 	if (StringUtil::Equals(value, "OUT_OF_MEMORY")) {
1880: 		return ExceptionType::OUT_OF_MEMORY;
1881: 	}
1882: 	if (StringUtil::Equals(value, "PERMISSION")) {
1883: 		return ExceptionType::PERMISSION;
1884: 	}
1885: 	if (StringUtil::Equals(value, "PARAMETER_NOT_RESOLVED")) {
1886: 		return ExceptionType::PARAMETER_NOT_RESOLVED;
1887: 	}
1888: 	if (StringUtil::Equals(value, "PARAMETER_NOT_ALLOWED")) {
1889: 		return ExceptionType::PARAMETER_NOT_ALLOWED;
1890: 	}
1891: 	if (StringUtil::Equals(value, "DEPENDENCY")) {
1892: 		return ExceptionType::DEPENDENCY;
1893: 	}
1894: 	if (StringUtil::Equals(value, "HTTP")) {
1895: 		return ExceptionType::HTTP;
1896: 	}
1897: 	if (StringUtil::Equals(value, "MISSING_EXTENSION")) {
1898: 		return ExceptionType::MISSING_EXTENSION;
1899: 	}
1900: 	if (StringUtil::Equals(value, "AUTOLOAD")) {
1901: 		return ExceptionType::AUTOLOAD;
1902: 	}
1903: 	if (StringUtil::Equals(value, "SEQUENCE")) {
1904: 		return ExceptionType::SEQUENCE;
1905: 	}
1906: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1907: }
1908: 
1909: template<>
1910: const char* EnumUtil::ToChars<ExplainOutputType>(ExplainOutputType value) {
1911: 	switch(value) {
1912: 	case ExplainOutputType::ALL:
1913: 		return "ALL";
1914: 	case ExplainOutputType::OPTIMIZED_ONLY:
1915: 		return "OPTIMIZED_ONLY";
1916: 	case ExplainOutputType::PHYSICAL_ONLY:
1917: 		return "PHYSICAL_ONLY";
1918: 	default:
1919: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1920: 	}
1921: }
1922: 
1923: template<>
1924: ExplainOutputType EnumUtil::FromString<ExplainOutputType>(const char *value) {
1925: 	if (StringUtil::Equals(value, "ALL")) {
1926: 		return ExplainOutputType::ALL;
1927: 	}
1928: 	if (StringUtil::Equals(value, "OPTIMIZED_ONLY")) {
1929: 		return ExplainOutputType::OPTIMIZED_ONLY;
1930: 	}
1931: 	if (StringUtil::Equals(value, "PHYSICAL_ONLY")) {
1932: 		return ExplainOutputType::PHYSICAL_ONLY;
1933: 	}
1934: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1935: }
1936: 
1937: template<>
1938: const char* EnumUtil::ToChars<ExplainType>(ExplainType value) {
1939: 	switch(value) {
1940: 	case ExplainType::EXPLAIN_STANDARD:
1941: 		return "EXPLAIN_STANDARD";
1942: 	case ExplainType::EXPLAIN_ANALYZE:
1943: 		return "EXPLAIN_ANALYZE";
1944: 	default:
1945: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1946: 	}
1947: }
1948: 
1949: template<>
1950: ExplainType EnumUtil::FromString<ExplainType>(const char *value) {
1951: 	if (StringUtil::Equals(value, "EXPLAIN_STANDARD")) {
1952: 		return ExplainType::EXPLAIN_STANDARD;
1953: 	}
1954: 	if (StringUtil::Equals(value, "EXPLAIN_ANALYZE")) {
1955: 		return ExplainType::EXPLAIN_ANALYZE;
1956: 	}
1957: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1958: }
1959: 
1960: template<>
1961: const char* EnumUtil::ToChars<ExponentType>(ExponentType value) {
1962: 	switch(value) {
1963: 	case ExponentType::NONE:
1964: 		return "NONE";
1965: 	case ExponentType::POSITIVE:
1966: 		return "POSITIVE";
1967: 	case ExponentType::NEGATIVE:
1968: 		return "NEGATIVE";
1969: 	default:
1970: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
1971: 	}
1972: }
1973: 
1974: template<>
1975: ExponentType EnumUtil::FromString<ExponentType>(const char *value) {
1976: 	if (StringUtil::Equals(value, "NONE")) {
1977: 		return ExponentType::NONE;
1978: 	}
1979: 	if (StringUtil::Equals(value, "POSITIVE")) {
1980: 		return ExponentType::POSITIVE;
1981: 	}
1982: 	if (StringUtil::Equals(value, "NEGATIVE")) {
1983: 		return ExponentType::NEGATIVE;
1984: 	}
1985: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
1986: }
1987: 
1988: template<>
1989: const char* EnumUtil::ToChars<ExpressionClass>(ExpressionClass value) {
1990: 	switch(value) {
1991: 	case ExpressionClass::INVALID:
1992: 		return "INVALID";
1993: 	case ExpressionClass::AGGREGATE:
1994: 		return "AGGREGATE";
1995: 	case ExpressionClass::CASE:
1996: 		return "CASE";
1997: 	case ExpressionClass::CAST:
1998: 		return "CAST";
1999: 	case ExpressionClass::COLUMN_REF:
2000: 		return "COLUMN_REF";
2001: 	case ExpressionClass::COMPARISON:
2002: 		return "COMPARISON";
2003: 	case ExpressionClass::CONJUNCTION:
2004: 		return "CONJUNCTION";
2005: 	case ExpressionClass::CONSTANT:
2006: 		return "CONSTANT";
2007: 	case ExpressionClass::DEFAULT:
2008: 		return "DEFAULT";
2009: 	case ExpressionClass::FUNCTION:
2010: 		return "FUNCTION";
2011: 	case ExpressionClass::OPERATOR:
2012: 		return "OPERATOR";
2013: 	case ExpressionClass::STAR:
2014: 		return "STAR";
2015: 	case ExpressionClass::SUBQUERY:
2016: 		return "SUBQUERY";
2017: 	case ExpressionClass::WINDOW:
2018: 		return "WINDOW";
2019: 	case ExpressionClass::PARAMETER:
2020: 		return "PARAMETER";
2021: 	case ExpressionClass::COLLATE:
2022: 		return "COLLATE";
2023: 	case ExpressionClass::LAMBDA:
2024: 		return "LAMBDA";
2025: 	case ExpressionClass::POSITIONAL_REFERENCE:
2026: 		return "POSITIONAL_REFERENCE";
2027: 	case ExpressionClass::BETWEEN:
2028: 		return "BETWEEN";
2029: 	case ExpressionClass::LAMBDA_REF:
2030: 		return "LAMBDA_REF";
2031: 	case ExpressionClass::BOUND_AGGREGATE:
2032: 		return "BOUND_AGGREGATE";
2033: 	case ExpressionClass::BOUND_CASE:
2034: 		return "BOUND_CASE";
2035: 	case ExpressionClass::BOUND_CAST:
2036: 		return "BOUND_CAST";
2037: 	case ExpressionClass::BOUND_COLUMN_REF:
2038: 		return "BOUND_COLUMN_REF";
2039: 	case ExpressionClass::BOUND_COMPARISON:
2040: 		return "BOUND_COMPARISON";
2041: 	case ExpressionClass::BOUND_CONJUNCTION:
2042: 		return "BOUND_CONJUNCTION";
2043: 	case ExpressionClass::BOUND_CONSTANT:
2044: 		return "BOUND_CONSTANT";
2045: 	case ExpressionClass::BOUND_DEFAULT:
2046: 		return "BOUND_DEFAULT";
2047: 	case ExpressionClass::BOUND_FUNCTION:
2048: 		return "BOUND_FUNCTION";
2049: 	case ExpressionClass::BOUND_OPERATOR:
2050: 		return "BOUND_OPERATOR";
2051: 	case ExpressionClass::BOUND_PARAMETER:
2052: 		return "BOUND_PARAMETER";
2053: 	case ExpressionClass::BOUND_REF:
2054: 		return "BOUND_REF";
2055: 	case ExpressionClass::BOUND_SUBQUERY:
2056: 		return "BOUND_SUBQUERY";
2057: 	case ExpressionClass::BOUND_WINDOW:
2058: 		return "BOUND_WINDOW";
2059: 	case ExpressionClass::BOUND_BETWEEN:
2060: 		return "BOUND_BETWEEN";
2061: 	case ExpressionClass::BOUND_UNNEST:
2062: 		return "BOUND_UNNEST";
2063: 	case ExpressionClass::BOUND_LAMBDA:
2064: 		return "BOUND_LAMBDA";
2065: 	case ExpressionClass::BOUND_LAMBDA_REF:
2066: 		return "BOUND_LAMBDA_REF";
2067: 	case ExpressionClass::BOUND_EXPRESSION:
2068: 		return "BOUND_EXPRESSION";
2069: 	case ExpressionClass::BOUND_EXPANDED:
2070: 		return "BOUND_EXPANDED";
2071: 	default:
2072: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2073: 	}
2074: }
2075: 
2076: template<>
2077: ExpressionClass EnumUtil::FromString<ExpressionClass>(const char *value) {
2078: 	if (StringUtil::Equals(value, "INVALID")) {
2079: 		return ExpressionClass::INVALID;
2080: 	}
2081: 	if (StringUtil::Equals(value, "AGGREGATE")) {
2082: 		return ExpressionClass::AGGREGATE;
2083: 	}
2084: 	if (StringUtil::Equals(value, "CASE")) {
2085: 		return ExpressionClass::CASE;
2086: 	}
2087: 	if (StringUtil::Equals(value, "CAST")) {
2088: 		return ExpressionClass::CAST;
2089: 	}
2090: 	if (StringUtil::Equals(value, "COLUMN_REF")) {
2091: 		return ExpressionClass::COLUMN_REF;
2092: 	}
2093: 	if (StringUtil::Equals(value, "COMPARISON")) {
2094: 		return ExpressionClass::COMPARISON;
2095: 	}
2096: 	if (StringUtil::Equals(value, "CONJUNCTION")) {
2097: 		return ExpressionClass::CONJUNCTION;
2098: 	}
2099: 	if (StringUtil::Equals(value, "CONSTANT")) {
2100: 		return ExpressionClass::CONSTANT;
2101: 	}
2102: 	if (StringUtil::Equals(value, "DEFAULT")) {
2103: 		return ExpressionClass::DEFAULT;
2104: 	}
2105: 	if (StringUtil::Equals(value, "FUNCTION")) {
2106: 		return ExpressionClass::FUNCTION;
2107: 	}
2108: 	if (StringUtil::Equals(value, "OPERATOR")) {
2109: 		return ExpressionClass::OPERATOR;
2110: 	}
2111: 	if (StringUtil::Equals(value, "STAR")) {
2112: 		return ExpressionClass::STAR;
2113: 	}
2114: 	if (StringUtil::Equals(value, "SUBQUERY")) {
2115: 		return ExpressionClass::SUBQUERY;
2116: 	}
2117: 	if (StringUtil::Equals(value, "WINDOW")) {
2118: 		return ExpressionClass::WINDOW;
2119: 	}
2120: 	if (StringUtil::Equals(value, "PARAMETER")) {
2121: 		return ExpressionClass::PARAMETER;
2122: 	}
2123: 	if (StringUtil::Equals(value, "COLLATE")) {
2124: 		return ExpressionClass::COLLATE;
2125: 	}
2126: 	if (StringUtil::Equals(value, "LAMBDA")) {
2127: 		return ExpressionClass::LAMBDA;
2128: 	}
2129: 	if (StringUtil::Equals(value, "POSITIONAL_REFERENCE")) {
2130: 		return ExpressionClass::POSITIONAL_REFERENCE;
2131: 	}
2132: 	if (StringUtil::Equals(value, "BETWEEN")) {
2133: 		return ExpressionClass::BETWEEN;
2134: 	}
2135: 	if (StringUtil::Equals(value, "LAMBDA_REF")) {
2136: 		return ExpressionClass::LAMBDA_REF;
2137: 	}
2138: 	if (StringUtil::Equals(value, "BOUND_AGGREGATE")) {
2139: 		return ExpressionClass::BOUND_AGGREGATE;
2140: 	}
2141: 	if (StringUtil::Equals(value, "BOUND_CASE")) {
2142: 		return ExpressionClass::BOUND_CASE;
2143: 	}
2144: 	if (StringUtil::Equals(value, "BOUND_CAST")) {
2145: 		return ExpressionClass::BOUND_CAST;
2146: 	}
2147: 	if (StringUtil::Equals(value, "BOUND_COLUMN_REF")) {
2148: 		return ExpressionClass::BOUND_COLUMN_REF;
2149: 	}
2150: 	if (StringUtil::Equals(value, "BOUND_COMPARISON")) {
2151: 		return ExpressionClass::BOUND_COMPARISON;
2152: 	}
2153: 	if (StringUtil::Equals(value, "BOUND_CONJUNCTION")) {
2154: 		return ExpressionClass::BOUND_CONJUNCTION;
2155: 	}
2156: 	if (StringUtil::Equals(value, "BOUND_CONSTANT")) {
2157: 		return ExpressionClass::BOUND_CONSTANT;
2158: 	}
2159: 	if (StringUtil::Equals(value, "BOUND_DEFAULT")) {
2160: 		return ExpressionClass::BOUND_DEFAULT;
2161: 	}
2162: 	if (StringUtil::Equals(value, "BOUND_FUNCTION")) {
2163: 		return ExpressionClass::BOUND_FUNCTION;
2164: 	}
2165: 	if (StringUtil::Equals(value, "BOUND_OPERATOR")) {
2166: 		return ExpressionClass::BOUND_OPERATOR;
2167: 	}
2168: 	if (StringUtil::Equals(value, "BOUND_PARAMETER")) {
2169: 		return ExpressionClass::BOUND_PARAMETER;
2170: 	}
2171: 	if (StringUtil::Equals(value, "BOUND_REF")) {
2172: 		return ExpressionClass::BOUND_REF;
2173: 	}
2174: 	if (StringUtil::Equals(value, "BOUND_SUBQUERY")) {
2175: 		return ExpressionClass::BOUND_SUBQUERY;
2176: 	}
2177: 	if (StringUtil::Equals(value, "BOUND_WINDOW")) {
2178: 		return ExpressionClass::BOUND_WINDOW;
2179: 	}
2180: 	if (StringUtil::Equals(value, "BOUND_BETWEEN")) {
2181: 		return ExpressionClass::BOUND_BETWEEN;
2182: 	}
2183: 	if (StringUtil::Equals(value, "BOUND_UNNEST")) {
2184: 		return ExpressionClass::BOUND_UNNEST;
2185: 	}
2186: 	if (StringUtil::Equals(value, "BOUND_LAMBDA")) {
2187: 		return ExpressionClass::BOUND_LAMBDA;
2188: 	}
2189: 	if (StringUtil::Equals(value, "BOUND_LAMBDA_REF")) {
2190: 		return ExpressionClass::BOUND_LAMBDA_REF;
2191: 	}
2192: 	if (StringUtil::Equals(value, "BOUND_EXPRESSION")) {
2193: 		return ExpressionClass::BOUND_EXPRESSION;
2194: 	}
2195: 	if (StringUtil::Equals(value, "BOUND_EXPANDED")) {
2196: 		return ExpressionClass::BOUND_EXPANDED;
2197: 	}
2198: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2199: }
2200: 
2201: template<>
2202: const char* EnumUtil::ToChars<ExpressionType>(ExpressionType value) {
2203: 	switch(value) {
2204: 	case ExpressionType::INVALID:
2205: 		return "INVALID";
2206: 	case ExpressionType::OPERATOR_CAST:
2207: 		return "OPERATOR_CAST";
2208: 	case ExpressionType::OPERATOR_NOT:
2209: 		return "OPERATOR_NOT";
2210: 	case ExpressionType::OPERATOR_IS_NULL:
2211: 		return "OPERATOR_IS_NULL";
2212: 	case ExpressionType::OPERATOR_IS_NOT_NULL:
2213: 		return "OPERATOR_IS_NOT_NULL";
2214: 	case ExpressionType::COMPARE_EQUAL:
2215: 		return "COMPARE_EQUAL";
2216: 	case ExpressionType::COMPARE_NOTEQUAL:
2217: 		return "COMPARE_NOTEQUAL";
2218: 	case ExpressionType::COMPARE_LESSTHAN:
2219: 		return "COMPARE_LESSTHAN";
2220: 	case ExpressionType::COMPARE_GREATERTHAN:
2221: 		return "COMPARE_GREATERTHAN";
2222: 	case ExpressionType::COMPARE_LESSTHANOREQUALTO:
2223: 		return "COMPARE_LESSTHANOREQUALTO";
2224: 	case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
2225: 		return "COMPARE_GREATERTHANOREQUALTO";
2226: 	case ExpressionType::COMPARE_IN:
2227: 		return "COMPARE_IN";
2228: 	case ExpressionType::COMPARE_NOT_IN:
2229: 		return "COMPARE_NOT_IN";
2230: 	case ExpressionType::COMPARE_DISTINCT_FROM:
2231: 		return "COMPARE_DISTINCT_FROM";
2232: 	case ExpressionType::COMPARE_BETWEEN:
2233: 		return "COMPARE_BETWEEN";
2234: 	case ExpressionType::COMPARE_NOT_BETWEEN:
2235: 		return "COMPARE_NOT_BETWEEN";
2236: 	case ExpressionType::COMPARE_NOT_DISTINCT_FROM:
2237: 		return "COMPARE_NOT_DISTINCT_FROM";
2238: 	case ExpressionType::CONJUNCTION_AND:
2239: 		return "CONJUNCTION_AND";
2240: 	case ExpressionType::CONJUNCTION_OR:
2241: 		return "CONJUNCTION_OR";
2242: 	case ExpressionType::VALUE_CONSTANT:
2243: 		return "VALUE_CONSTANT";
2244: 	case ExpressionType::VALUE_PARAMETER:
2245: 		return "VALUE_PARAMETER";
2246: 	case ExpressionType::VALUE_TUPLE:
2247: 		return "VALUE_TUPLE";
2248: 	case ExpressionType::VALUE_TUPLE_ADDRESS:
2249: 		return "VALUE_TUPLE_ADDRESS";
2250: 	case ExpressionType::VALUE_NULL:
2251: 		return "VALUE_NULL";
2252: 	case ExpressionType::VALUE_VECTOR:
2253: 		return "VALUE_VECTOR";
2254: 	case ExpressionType::VALUE_SCALAR:
2255: 		return "VALUE_SCALAR";
2256: 	case ExpressionType::VALUE_DEFAULT:
2257: 		return "VALUE_DEFAULT";
2258: 	case ExpressionType::AGGREGATE:
2259: 		return "AGGREGATE";
2260: 	case ExpressionType::BOUND_AGGREGATE:
2261: 		return "BOUND_AGGREGATE";
2262: 	case ExpressionType::GROUPING_FUNCTION:
2263: 		return "GROUPING_FUNCTION";
2264: 	case ExpressionType::WINDOW_AGGREGATE:
2265: 		return "WINDOW_AGGREGATE";
2266: 	case ExpressionType::WINDOW_RANK:
2267: 		return "WINDOW_RANK";
2268: 	case ExpressionType::WINDOW_RANK_DENSE:
2269: 		return "WINDOW_RANK_DENSE";
2270: 	case ExpressionType::WINDOW_NTILE:
2271: 		return "WINDOW_NTILE";
2272: 	case ExpressionType::WINDOW_PERCENT_RANK:
2273: 		return "WINDOW_PERCENT_RANK";
2274: 	case ExpressionType::WINDOW_CUME_DIST:
2275: 		return "WINDOW_CUME_DIST";
2276: 	case ExpressionType::WINDOW_ROW_NUMBER:
2277: 		return "WINDOW_ROW_NUMBER";
2278: 	case ExpressionType::WINDOW_FIRST_VALUE:
2279: 		return "WINDOW_FIRST_VALUE";
2280: 	case ExpressionType::WINDOW_LAST_VALUE:
2281: 		return "WINDOW_LAST_VALUE";
2282: 	case ExpressionType::WINDOW_LEAD:
2283: 		return "WINDOW_LEAD";
2284: 	case ExpressionType::WINDOW_LAG:
2285: 		return "WINDOW_LAG";
2286: 	case ExpressionType::WINDOW_NTH_VALUE:
2287: 		return "WINDOW_NTH_VALUE";
2288: 	case ExpressionType::FUNCTION:
2289: 		return "FUNCTION";
2290: 	case ExpressionType::BOUND_FUNCTION:
2291: 		return "BOUND_FUNCTION";
2292: 	case ExpressionType::CASE_EXPR:
2293: 		return "CASE_EXPR";
2294: 	case ExpressionType::OPERATOR_NULLIF:
2295: 		return "OPERATOR_NULLIF";
2296: 	case ExpressionType::OPERATOR_COALESCE:
2297: 		return "OPERATOR_COALESCE";
2298: 	case ExpressionType::ARRAY_EXTRACT:
2299: 		return "ARRAY_EXTRACT";
2300: 	case ExpressionType::ARRAY_SLICE:
2301: 		return "ARRAY_SLICE";
2302: 	case ExpressionType::STRUCT_EXTRACT:
2303: 		return "STRUCT_EXTRACT";
2304: 	case ExpressionType::ARRAY_CONSTRUCTOR:
2305: 		return "ARRAY_CONSTRUCTOR";
2306: 	case ExpressionType::ARROW:
2307: 		return "ARROW";
2308: 	case ExpressionType::SUBQUERY:
2309: 		return "SUBQUERY";
2310: 	case ExpressionType::STAR:
2311: 		return "STAR";
2312: 	case ExpressionType::TABLE_STAR:
2313: 		return "TABLE_STAR";
2314: 	case ExpressionType::PLACEHOLDER:
2315: 		return "PLACEHOLDER";
2316: 	case ExpressionType::COLUMN_REF:
2317: 		return "COLUMN_REF";
2318: 	case ExpressionType::FUNCTION_REF:
2319: 		return "FUNCTION_REF";
2320: 	case ExpressionType::TABLE_REF:
2321: 		return "TABLE_REF";
2322: 	case ExpressionType::LAMBDA_REF:
2323: 		return "LAMBDA_REF";
2324: 	case ExpressionType::CAST:
2325: 		return "CAST";
2326: 	case ExpressionType::BOUND_REF:
2327: 		return "BOUND_REF";
2328: 	case ExpressionType::BOUND_COLUMN_REF:
2329: 		return "BOUND_COLUMN_REF";
2330: 	case ExpressionType::BOUND_UNNEST:
2331: 		return "BOUND_UNNEST";
2332: 	case ExpressionType::COLLATE:
2333: 		return "COLLATE";
2334: 	case ExpressionType::LAMBDA:
2335: 		return "LAMBDA";
2336: 	case ExpressionType::POSITIONAL_REFERENCE:
2337: 		return "POSITIONAL_REFERENCE";
2338: 	case ExpressionType::BOUND_LAMBDA_REF:
2339: 		return "BOUND_LAMBDA_REF";
2340: 	case ExpressionType::BOUND_EXPANDED:
2341: 		return "BOUND_EXPANDED";
2342: 	default:
2343: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2344: 	}
2345: }
2346: 
2347: template<>
2348: ExpressionType EnumUtil::FromString<ExpressionType>(const char *value) {
2349: 	if (StringUtil::Equals(value, "INVALID")) {
2350: 		return ExpressionType::INVALID;
2351: 	}
2352: 	if (StringUtil::Equals(value, "OPERATOR_CAST")) {
2353: 		return ExpressionType::OPERATOR_CAST;
2354: 	}
2355: 	if (StringUtil::Equals(value, "OPERATOR_NOT")) {
2356: 		return ExpressionType::OPERATOR_NOT;
2357: 	}
2358: 	if (StringUtil::Equals(value, "OPERATOR_IS_NULL")) {
2359: 		return ExpressionType::OPERATOR_IS_NULL;
2360: 	}
2361: 	if (StringUtil::Equals(value, "OPERATOR_IS_NOT_NULL")) {
2362: 		return ExpressionType::OPERATOR_IS_NOT_NULL;
2363: 	}
2364: 	if (StringUtil::Equals(value, "COMPARE_EQUAL")) {
2365: 		return ExpressionType::COMPARE_EQUAL;
2366: 	}
2367: 	if (StringUtil::Equals(value, "COMPARE_NOTEQUAL")) {
2368: 		return ExpressionType::COMPARE_NOTEQUAL;
2369: 	}
2370: 	if (StringUtil::Equals(value, "COMPARE_LESSTHAN")) {
2371: 		return ExpressionType::COMPARE_LESSTHAN;
2372: 	}
2373: 	if (StringUtil::Equals(value, "COMPARE_GREATERTHAN")) {
2374: 		return ExpressionType::COMPARE_GREATERTHAN;
2375: 	}
2376: 	if (StringUtil::Equals(value, "COMPARE_LESSTHANOREQUALTO")) {
2377: 		return ExpressionType::COMPARE_LESSTHANOREQUALTO;
2378: 	}
2379: 	if (StringUtil::Equals(value, "COMPARE_GREATERTHANOREQUALTO")) {
2380: 		return ExpressionType::COMPARE_GREATERTHANOREQUALTO;
2381: 	}
2382: 	if (StringUtil::Equals(value, "COMPARE_IN")) {
2383: 		return ExpressionType::COMPARE_IN;
2384: 	}
2385: 	if (StringUtil::Equals(value, "COMPARE_NOT_IN")) {
2386: 		return ExpressionType::COMPARE_NOT_IN;
2387: 	}
2388: 	if (StringUtil::Equals(value, "COMPARE_DISTINCT_FROM")) {
2389: 		return ExpressionType::COMPARE_DISTINCT_FROM;
2390: 	}
2391: 	if (StringUtil::Equals(value, "COMPARE_BETWEEN")) {
2392: 		return ExpressionType::COMPARE_BETWEEN;
2393: 	}
2394: 	if (StringUtil::Equals(value, "COMPARE_NOT_BETWEEN")) {
2395: 		return ExpressionType::COMPARE_NOT_BETWEEN;
2396: 	}
2397: 	if (StringUtil::Equals(value, "COMPARE_NOT_DISTINCT_FROM")) {
2398: 		return ExpressionType::COMPARE_NOT_DISTINCT_FROM;
2399: 	}
2400: 	if (StringUtil::Equals(value, "CONJUNCTION_AND")) {
2401: 		return ExpressionType::CONJUNCTION_AND;
2402: 	}
2403: 	if (StringUtil::Equals(value, "CONJUNCTION_OR")) {
2404: 		return ExpressionType::CONJUNCTION_OR;
2405: 	}
2406: 	if (StringUtil::Equals(value, "VALUE_CONSTANT")) {
2407: 		return ExpressionType::VALUE_CONSTANT;
2408: 	}
2409: 	if (StringUtil::Equals(value, "VALUE_PARAMETER")) {
2410: 		return ExpressionType::VALUE_PARAMETER;
2411: 	}
2412: 	if (StringUtil::Equals(value, "VALUE_TUPLE")) {
2413: 		return ExpressionType::VALUE_TUPLE;
2414: 	}
2415: 	if (StringUtil::Equals(value, "VALUE_TUPLE_ADDRESS")) {
2416: 		return ExpressionType::VALUE_TUPLE_ADDRESS;
2417: 	}
2418: 	if (StringUtil::Equals(value, "VALUE_NULL")) {
2419: 		return ExpressionType::VALUE_NULL;
2420: 	}
2421: 	if (StringUtil::Equals(value, "VALUE_VECTOR")) {
2422: 		return ExpressionType::VALUE_VECTOR;
2423: 	}
2424: 	if (StringUtil::Equals(value, "VALUE_SCALAR")) {
2425: 		return ExpressionType::VALUE_SCALAR;
2426: 	}
2427: 	if (StringUtil::Equals(value, "VALUE_DEFAULT")) {
2428: 		return ExpressionType::VALUE_DEFAULT;
2429: 	}
2430: 	if (StringUtil::Equals(value, "AGGREGATE")) {
2431: 		return ExpressionType::AGGREGATE;
2432: 	}
2433: 	if (StringUtil::Equals(value, "BOUND_AGGREGATE")) {
2434: 		return ExpressionType::BOUND_AGGREGATE;
2435: 	}
2436: 	if (StringUtil::Equals(value, "GROUPING_FUNCTION")) {
2437: 		return ExpressionType::GROUPING_FUNCTION;
2438: 	}
2439: 	if (StringUtil::Equals(value, "WINDOW_AGGREGATE")) {
2440: 		return ExpressionType::WINDOW_AGGREGATE;
2441: 	}
2442: 	if (StringUtil::Equals(value, "WINDOW_RANK")) {
2443: 		return ExpressionType::WINDOW_RANK;
2444: 	}
2445: 	if (StringUtil::Equals(value, "WINDOW_RANK_DENSE")) {
2446: 		return ExpressionType::WINDOW_RANK_DENSE;
2447: 	}
2448: 	if (StringUtil::Equals(value, "WINDOW_NTILE")) {
2449: 		return ExpressionType::WINDOW_NTILE;
2450: 	}
2451: 	if (StringUtil::Equals(value, "WINDOW_PERCENT_RANK")) {
2452: 		return ExpressionType::WINDOW_PERCENT_RANK;
2453: 	}
2454: 	if (StringUtil::Equals(value, "WINDOW_CUME_DIST")) {
2455: 		return ExpressionType::WINDOW_CUME_DIST;
2456: 	}
2457: 	if (StringUtil::Equals(value, "WINDOW_ROW_NUMBER")) {
2458: 		return ExpressionType::WINDOW_ROW_NUMBER;
2459: 	}
2460: 	if (StringUtil::Equals(value, "WINDOW_FIRST_VALUE")) {
2461: 		return ExpressionType::WINDOW_FIRST_VALUE;
2462: 	}
2463: 	if (StringUtil::Equals(value, "WINDOW_LAST_VALUE")) {
2464: 		return ExpressionType::WINDOW_LAST_VALUE;
2465: 	}
2466: 	if (StringUtil::Equals(value, "WINDOW_LEAD")) {
2467: 		return ExpressionType::WINDOW_LEAD;
2468: 	}
2469: 	if (StringUtil::Equals(value, "WINDOW_LAG")) {
2470: 		return ExpressionType::WINDOW_LAG;
2471: 	}
2472: 	if (StringUtil::Equals(value, "WINDOW_NTH_VALUE")) {
2473: 		return ExpressionType::WINDOW_NTH_VALUE;
2474: 	}
2475: 	if (StringUtil::Equals(value, "FUNCTION")) {
2476: 		return ExpressionType::FUNCTION;
2477: 	}
2478: 	if (StringUtil::Equals(value, "BOUND_FUNCTION")) {
2479: 		return ExpressionType::BOUND_FUNCTION;
2480: 	}
2481: 	if (StringUtil::Equals(value, "CASE_EXPR")) {
2482: 		return ExpressionType::CASE_EXPR;
2483: 	}
2484: 	if (StringUtil::Equals(value, "OPERATOR_NULLIF")) {
2485: 		return ExpressionType::OPERATOR_NULLIF;
2486: 	}
2487: 	if (StringUtil::Equals(value, "OPERATOR_COALESCE")) {
2488: 		return ExpressionType::OPERATOR_COALESCE;
2489: 	}
2490: 	if (StringUtil::Equals(value, "ARRAY_EXTRACT")) {
2491: 		return ExpressionType::ARRAY_EXTRACT;
2492: 	}
2493: 	if (StringUtil::Equals(value, "ARRAY_SLICE")) {
2494: 		return ExpressionType::ARRAY_SLICE;
2495: 	}
2496: 	if (StringUtil::Equals(value, "STRUCT_EXTRACT")) {
2497: 		return ExpressionType::STRUCT_EXTRACT;
2498: 	}
2499: 	if (StringUtil::Equals(value, "ARRAY_CONSTRUCTOR")) {
2500: 		return ExpressionType::ARRAY_CONSTRUCTOR;
2501: 	}
2502: 	if (StringUtil::Equals(value, "ARROW")) {
2503: 		return ExpressionType::ARROW;
2504: 	}
2505: 	if (StringUtil::Equals(value, "SUBQUERY")) {
2506: 		return ExpressionType::SUBQUERY;
2507: 	}
2508: 	if (StringUtil::Equals(value, "STAR")) {
2509: 		return ExpressionType::STAR;
2510: 	}
2511: 	if (StringUtil::Equals(value, "TABLE_STAR")) {
2512: 		return ExpressionType::TABLE_STAR;
2513: 	}
2514: 	if (StringUtil::Equals(value, "PLACEHOLDER")) {
2515: 		return ExpressionType::PLACEHOLDER;
2516: 	}
2517: 	if (StringUtil::Equals(value, "COLUMN_REF")) {
2518: 		return ExpressionType::COLUMN_REF;
2519: 	}
2520: 	if (StringUtil::Equals(value, "FUNCTION_REF")) {
2521: 		return ExpressionType::FUNCTION_REF;
2522: 	}
2523: 	if (StringUtil::Equals(value, "TABLE_REF")) {
2524: 		return ExpressionType::TABLE_REF;
2525: 	}
2526: 	if (StringUtil::Equals(value, "LAMBDA_REF")) {
2527: 		return ExpressionType::LAMBDA_REF;
2528: 	}
2529: 	if (StringUtil::Equals(value, "CAST")) {
2530: 		return ExpressionType::CAST;
2531: 	}
2532: 	if (StringUtil::Equals(value, "BOUND_REF")) {
2533: 		return ExpressionType::BOUND_REF;
2534: 	}
2535: 	if (StringUtil::Equals(value, "BOUND_COLUMN_REF")) {
2536: 		return ExpressionType::BOUND_COLUMN_REF;
2537: 	}
2538: 	if (StringUtil::Equals(value, "BOUND_UNNEST")) {
2539: 		return ExpressionType::BOUND_UNNEST;
2540: 	}
2541: 	if (StringUtil::Equals(value, "COLLATE")) {
2542: 		return ExpressionType::COLLATE;
2543: 	}
2544: 	if (StringUtil::Equals(value, "LAMBDA")) {
2545: 		return ExpressionType::LAMBDA;
2546: 	}
2547: 	if (StringUtil::Equals(value, "POSITIONAL_REFERENCE")) {
2548: 		return ExpressionType::POSITIONAL_REFERENCE;
2549: 	}
2550: 	if (StringUtil::Equals(value, "BOUND_LAMBDA_REF")) {
2551: 		return ExpressionType::BOUND_LAMBDA_REF;
2552: 	}
2553: 	if (StringUtil::Equals(value, "BOUND_EXPANDED")) {
2554: 		return ExpressionType::BOUND_EXPANDED;
2555: 	}
2556: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2557: }
2558: 
2559: template<>
2560: const char* EnumUtil::ToChars<ExtensionInstallMode>(ExtensionInstallMode value) {
2561: 	switch(value) {
2562: 	case ExtensionInstallMode::UNKNOWN:
2563: 		return "UNKNOWN";
2564: 	case ExtensionInstallMode::REPOSITORY:
2565: 		return "REPOSITORY";
2566: 	case ExtensionInstallMode::CUSTOM_PATH:
2567: 		return "CUSTOM_PATH";
2568: 	case ExtensionInstallMode::STATICALLY_LINKED:
2569: 		return "STATICALLY_LINKED";
2570: 	case ExtensionInstallMode::NOT_INSTALLED:
2571: 		return "NOT_INSTALLED";
2572: 	default:
2573: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2574: 	}
2575: }
2576: 
2577: template<>
2578: ExtensionInstallMode EnumUtil::FromString<ExtensionInstallMode>(const char *value) {
2579: 	if (StringUtil::Equals(value, "UNKNOWN")) {
2580: 		return ExtensionInstallMode::UNKNOWN;
2581: 	}
2582: 	if (StringUtil::Equals(value, "REPOSITORY")) {
2583: 		return ExtensionInstallMode::REPOSITORY;
2584: 	}
2585: 	if (StringUtil::Equals(value, "CUSTOM_PATH")) {
2586: 		return ExtensionInstallMode::CUSTOM_PATH;
2587: 	}
2588: 	if (StringUtil::Equals(value, "STATICALLY_LINKED")) {
2589: 		return ExtensionInstallMode::STATICALLY_LINKED;
2590: 	}
2591: 	if (StringUtil::Equals(value, "NOT_INSTALLED")) {
2592: 		return ExtensionInstallMode::NOT_INSTALLED;
2593: 	}
2594: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2595: }
2596: 
2597: template<>
2598: const char* EnumUtil::ToChars<ExtensionLoadResult>(ExtensionLoadResult value) {
2599: 	switch(value) {
2600: 	case ExtensionLoadResult::LOADED_EXTENSION:
2601: 		return "LOADED_EXTENSION";
2602: 	case ExtensionLoadResult::EXTENSION_UNKNOWN:
2603: 		return "EXTENSION_UNKNOWN";
2604: 	case ExtensionLoadResult::NOT_LOADED:
2605: 		return "NOT_LOADED";
2606: 	default:
2607: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2608: 	}
2609: }
2610: 
2611: template<>
2612: ExtensionLoadResult EnumUtil::FromString<ExtensionLoadResult>(const char *value) {
2613: 	if (StringUtil::Equals(value, "LOADED_EXTENSION")) {
2614: 		return ExtensionLoadResult::LOADED_EXTENSION;
2615: 	}
2616: 	if (StringUtil::Equals(value, "EXTENSION_UNKNOWN")) {
2617: 		return ExtensionLoadResult::EXTENSION_UNKNOWN;
2618: 	}
2619: 	if (StringUtil::Equals(value, "NOT_LOADED")) {
2620: 		return ExtensionLoadResult::NOT_LOADED;
2621: 	}
2622: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2623: }
2624: 
2625: template<>
2626: const char* EnumUtil::ToChars<ExtensionUpdateResultTag>(ExtensionUpdateResultTag value) {
2627: 	switch(value) {
2628: 	case ExtensionUpdateResultTag::UNKNOWN:
2629: 		return "UNKNOWN";
2630: 	case ExtensionUpdateResultTag::NO_UPDATE_AVAILABLE:
2631: 		return "NO_UPDATE_AVAILABLE";
2632: 	case ExtensionUpdateResultTag::NOT_A_REPOSITORY:
2633: 		return "NOT_A_REPOSITORY";
2634: 	case ExtensionUpdateResultTag::NOT_INSTALLED:
2635: 		return "NOT_INSTALLED";
2636: 	case ExtensionUpdateResultTag::STATICALLY_LOADED:
2637: 		return "STATICALLY_LOADED";
2638: 	case ExtensionUpdateResultTag::MISSING_INSTALL_INFO:
2639: 		return "MISSING_INSTALL_INFO";
2640: 	case ExtensionUpdateResultTag::REDOWNLOADED:
2641: 		return "REDOWNLOADED";
2642: 	case ExtensionUpdateResultTag::UPDATED:
2643: 		return "UPDATED";
2644: 	default:
2645: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2646: 	}
2647: }
2648: 
2649: template<>
2650: ExtensionUpdateResultTag EnumUtil::FromString<ExtensionUpdateResultTag>(const char *value) {
2651: 	if (StringUtil::Equals(value, "UNKNOWN")) {
2652: 		return ExtensionUpdateResultTag::UNKNOWN;
2653: 	}
2654: 	if (StringUtil::Equals(value, "NO_UPDATE_AVAILABLE")) {
2655: 		return ExtensionUpdateResultTag::NO_UPDATE_AVAILABLE;
2656: 	}
2657: 	if (StringUtil::Equals(value, "NOT_A_REPOSITORY")) {
2658: 		return ExtensionUpdateResultTag::NOT_A_REPOSITORY;
2659: 	}
2660: 	if (StringUtil::Equals(value, "NOT_INSTALLED")) {
2661: 		return ExtensionUpdateResultTag::NOT_INSTALLED;
2662: 	}
2663: 	if (StringUtil::Equals(value, "STATICALLY_LOADED")) {
2664: 		return ExtensionUpdateResultTag::STATICALLY_LOADED;
2665: 	}
2666: 	if (StringUtil::Equals(value, "MISSING_INSTALL_INFO")) {
2667: 		return ExtensionUpdateResultTag::MISSING_INSTALL_INFO;
2668: 	}
2669: 	if (StringUtil::Equals(value, "REDOWNLOADED")) {
2670: 		return ExtensionUpdateResultTag::REDOWNLOADED;
2671: 	}
2672: 	if (StringUtil::Equals(value, "UPDATED")) {
2673: 		return ExtensionUpdateResultTag::UPDATED;
2674: 	}
2675: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2676: }
2677: 
2678: template<>
2679: const char* EnumUtil::ToChars<ExtraDropInfoType>(ExtraDropInfoType value) {
2680: 	switch(value) {
2681: 	case ExtraDropInfoType::INVALID:
2682: 		return "INVALID";
2683: 	case ExtraDropInfoType::SECRET_INFO:
2684: 		return "SECRET_INFO";
2685: 	default:
2686: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2687: 	}
2688: }
2689: 
2690: template<>
2691: ExtraDropInfoType EnumUtil::FromString<ExtraDropInfoType>(const char *value) {
2692: 	if (StringUtil::Equals(value, "INVALID")) {
2693: 		return ExtraDropInfoType::INVALID;
2694: 	}
2695: 	if (StringUtil::Equals(value, "SECRET_INFO")) {
2696: 		return ExtraDropInfoType::SECRET_INFO;
2697: 	}
2698: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2699: }
2700: 
2701: template<>
2702: const char* EnumUtil::ToChars<ExtraTypeInfoType>(ExtraTypeInfoType value) {
2703: 	switch(value) {
2704: 	case ExtraTypeInfoType::INVALID_TYPE_INFO:
2705: 		return "INVALID_TYPE_INFO";
2706: 	case ExtraTypeInfoType::GENERIC_TYPE_INFO:
2707: 		return "GENERIC_TYPE_INFO";
2708: 	case ExtraTypeInfoType::DECIMAL_TYPE_INFO:
2709: 		return "DECIMAL_TYPE_INFO";
2710: 	case ExtraTypeInfoType::STRING_TYPE_INFO:
2711: 		return "STRING_TYPE_INFO";
2712: 	case ExtraTypeInfoType::LIST_TYPE_INFO:
2713: 		return "LIST_TYPE_INFO";
2714: 	case ExtraTypeInfoType::STRUCT_TYPE_INFO:
2715: 		return "STRUCT_TYPE_INFO";
2716: 	case ExtraTypeInfoType::ENUM_TYPE_INFO:
2717: 		return "ENUM_TYPE_INFO";
2718: 	case ExtraTypeInfoType::USER_TYPE_INFO:
2719: 		return "USER_TYPE_INFO";
2720: 	case ExtraTypeInfoType::AGGREGATE_STATE_TYPE_INFO:
2721: 		return "AGGREGATE_STATE_TYPE_INFO";
2722: 	case ExtraTypeInfoType::ARRAY_TYPE_INFO:
2723: 		return "ARRAY_TYPE_INFO";
2724: 	case ExtraTypeInfoType::ANY_TYPE_INFO:
2725: 		return "ANY_TYPE_INFO";
2726: 	case ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO:
2727: 		return "INTEGER_LITERAL_TYPE_INFO";
2728: 	default:
2729: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2730: 	}
2731: }
2732: 
2733: template<>
2734: ExtraTypeInfoType EnumUtil::FromString<ExtraTypeInfoType>(const char *value) {
2735: 	if (StringUtil::Equals(value, "INVALID_TYPE_INFO")) {
2736: 		return ExtraTypeInfoType::INVALID_TYPE_INFO;
2737: 	}
2738: 	if (StringUtil::Equals(value, "GENERIC_TYPE_INFO")) {
2739: 		return ExtraTypeInfoType::GENERIC_TYPE_INFO;
2740: 	}
2741: 	if (StringUtil::Equals(value, "DECIMAL_TYPE_INFO")) {
2742: 		return ExtraTypeInfoType::DECIMAL_TYPE_INFO;
2743: 	}
2744: 	if (StringUtil::Equals(value, "STRING_TYPE_INFO")) {
2745: 		return ExtraTypeInfoType::STRING_TYPE_INFO;
2746: 	}
2747: 	if (StringUtil::Equals(value, "LIST_TYPE_INFO")) {
2748: 		return ExtraTypeInfoType::LIST_TYPE_INFO;
2749: 	}
2750: 	if (StringUtil::Equals(value, "STRUCT_TYPE_INFO")) {
2751: 		return ExtraTypeInfoType::STRUCT_TYPE_INFO;
2752: 	}
2753: 	if (StringUtil::Equals(value, "ENUM_TYPE_INFO")) {
2754: 		return ExtraTypeInfoType::ENUM_TYPE_INFO;
2755: 	}
2756: 	if (StringUtil::Equals(value, "USER_TYPE_INFO")) {
2757: 		return ExtraTypeInfoType::USER_TYPE_INFO;
2758: 	}
2759: 	if (StringUtil::Equals(value, "AGGREGATE_STATE_TYPE_INFO")) {
2760: 		return ExtraTypeInfoType::AGGREGATE_STATE_TYPE_INFO;
2761: 	}
2762: 	if (StringUtil::Equals(value, "ARRAY_TYPE_INFO")) {
2763: 		return ExtraTypeInfoType::ARRAY_TYPE_INFO;
2764: 	}
2765: 	if (StringUtil::Equals(value, "ANY_TYPE_INFO")) {
2766: 		return ExtraTypeInfoType::ANY_TYPE_INFO;
2767: 	}
2768: 	if (StringUtil::Equals(value, "INTEGER_LITERAL_TYPE_INFO")) {
2769: 		return ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO;
2770: 	}
2771: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2772: }
2773: 
2774: template<>
2775: const char* EnumUtil::ToChars<FileBufferType>(FileBufferType value) {
2776: 	switch(value) {
2777: 	case FileBufferType::BLOCK:
2778: 		return "BLOCK";
2779: 	case FileBufferType::MANAGED_BUFFER:
2780: 		return "MANAGED_BUFFER";
2781: 	case FileBufferType::TINY_BUFFER:
2782: 		return "TINY_BUFFER";
2783: 	default:
2784: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2785: 	}
2786: }
2787: 
2788: template<>
2789: FileBufferType EnumUtil::FromString<FileBufferType>(const char *value) {
2790: 	if (StringUtil::Equals(value, "BLOCK")) {
2791: 		return FileBufferType::BLOCK;
2792: 	}
2793: 	if (StringUtil::Equals(value, "MANAGED_BUFFER")) {
2794: 		return FileBufferType::MANAGED_BUFFER;
2795: 	}
2796: 	if (StringUtil::Equals(value, "TINY_BUFFER")) {
2797: 		return FileBufferType::TINY_BUFFER;
2798: 	}
2799: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2800: }
2801: 
2802: template<>
2803: const char* EnumUtil::ToChars<FileCompressionType>(FileCompressionType value) {
2804: 	switch(value) {
2805: 	case FileCompressionType::AUTO_DETECT:
2806: 		return "AUTO_DETECT";
2807: 	case FileCompressionType::UNCOMPRESSED:
2808: 		return "UNCOMPRESSED";
2809: 	case FileCompressionType::GZIP:
2810: 		return "GZIP";
2811: 	case FileCompressionType::ZSTD:
2812: 		return "ZSTD";
2813: 	default:
2814: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2815: 	}
2816: }
2817: 
2818: template<>
2819: FileCompressionType EnumUtil::FromString<FileCompressionType>(const char *value) {
2820: 	if (StringUtil::Equals(value, "AUTO_DETECT")) {
2821: 		return FileCompressionType::AUTO_DETECT;
2822: 	}
2823: 	if (StringUtil::Equals(value, "UNCOMPRESSED")) {
2824: 		return FileCompressionType::UNCOMPRESSED;
2825: 	}
2826: 	if (StringUtil::Equals(value, "GZIP")) {
2827: 		return FileCompressionType::GZIP;
2828: 	}
2829: 	if (StringUtil::Equals(value, "ZSTD")) {
2830: 		return FileCompressionType::ZSTD;
2831: 	}
2832: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2833: }
2834: 
2835: template<>
2836: const char* EnumUtil::ToChars<FileExpandResult>(FileExpandResult value) {
2837: 	switch(value) {
2838: 	case FileExpandResult::NO_FILES:
2839: 		return "NO_FILES";
2840: 	case FileExpandResult::SINGLE_FILE:
2841: 		return "SINGLE_FILE";
2842: 	case FileExpandResult::MULTIPLE_FILES:
2843: 		return "MULTIPLE_FILES";
2844: 	default:
2845: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2846: 	}
2847: }
2848: 
2849: template<>
2850: FileExpandResult EnumUtil::FromString<FileExpandResult>(const char *value) {
2851: 	if (StringUtil::Equals(value, "NO_FILES")) {
2852: 		return FileExpandResult::NO_FILES;
2853: 	}
2854: 	if (StringUtil::Equals(value, "SINGLE_FILE")) {
2855: 		return FileExpandResult::SINGLE_FILE;
2856: 	}
2857: 	if (StringUtil::Equals(value, "MULTIPLE_FILES")) {
2858: 		return FileExpandResult::MULTIPLE_FILES;
2859: 	}
2860: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2861: }
2862: 
2863: template<>
2864: const char* EnumUtil::ToChars<FileGlobOptions>(FileGlobOptions value) {
2865: 	switch(value) {
2866: 	case FileGlobOptions::DISALLOW_EMPTY:
2867: 		return "DISALLOW_EMPTY";
2868: 	case FileGlobOptions::ALLOW_EMPTY:
2869: 		return "ALLOW_EMPTY";
2870: 	default:
2871: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2872: 	}
2873: }
2874: 
2875: template<>
2876: FileGlobOptions EnumUtil::FromString<FileGlobOptions>(const char *value) {
2877: 	if (StringUtil::Equals(value, "DISALLOW_EMPTY")) {
2878: 		return FileGlobOptions::DISALLOW_EMPTY;
2879: 	}
2880: 	if (StringUtil::Equals(value, "ALLOW_EMPTY")) {
2881: 		return FileGlobOptions::ALLOW_EMPTY;
2882: 	}
2883: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2884: }
2885: 
2886: template<>
2887: const char* EnumUtil::ToChars<FileLockType>(FileLockType value) {
2888: 	switch(value) {
2889: 	case FileLockType::NO_LOCK:
2890: 		return "NO_LOCK";
2891: 	case FileLockType::READ_LOCK:
2892: 		return "READ_LOCK";
2893: 	case FileLockType::WRITE_LOCK:
2894: 		return "WRITE_LOCK";
2895: 	default:
2896: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2897: 	}
2898: }
2899: 
2900: template<>
2901: FileLockType EnumUtil::FromString<FileLockType>(const char *value) {
2902: 	if (StringUtil::Equals(value, "NO_LOCK")) {
2903: 		return FileLockType::NO_LOCK;
2904: 	}
2905: 	if (StringUtil::Equals(value, "READ_LOCK")) {
2906: 		return FileLockType::READ_LOCK;
2907: 	}
2908: 	if (StringUtil::Equals(value, "WRITE_LOCK")) {
2909: 		return FileLockType::WRITE_LOCK;
2910: 	}
2911: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2912: }
2913: 
2914: template<>
2915: const char* EnumUtil::ToChars<FilterPropagateResult>(FilterPropagateResult value) {
2916: 	switch(value) {
2917: 	case FilterPropagateResult::NO_PRUNING_POSSIBLE:
2918: 		return "NO_PRUNING_POSSIBLE";
2919: 	case FilterPropagateResult::FILTER_ALWAYS_TRUE:
2920: 		return "FILTER_ALWAYS_TRUE";
2921: 	case FilterPropagateResult::FILTER_ALWAYS_FALSE:
2922: 		return "FILTER_ALWAYS_FALSE";
2923: 	case FilterPropagateResult::FILTER_TRUE_OR_NULL:
2924: 		return "FILTER_TRUE_OR_NULL";
2925: 	case FilterPropagateResult::FILTER_FALSE_OR_NULL:
2926: 		return "FILTER_FALSE_OR_NULL";
2927: 	default:
2928: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2929: 	}
2930: }
2931: 
2932: template<>
2933: FilterPropagateResult EnumUtil::FromString<FilterPropagateResult>(const char *value) {
2934: 	if (StringUtil::Equals(value, "NO_PRUNING_POSSIBLE")) {
2935: 		return FilterPropagateResult::NO_PRUNING_POSSIBLE;
2936: 	}
2937: 	if (StringUtil::Equals(value, "FILTER_ALWAYS_TRUE")) {
2938: 		return FilterPropagateResult::FILTER_ALWAYS_TRUE;
2939: 	}
2940: 	if (StringUtil::Equals(value, "FILTER_ALWAYS_FALSE")) {
2941: 		return FilterPropagateResult::FILTER_ALWAYS_FALSE;
2942: 	}
2943: 	if (StringUtil::Equals(value, "FILTER_TRUE_OR_NULL")) {
2944: 		return FilterPropagateResult::FILTER_TRUE_OR_NULL;
2945: 	}
2946: 	if (StringUtil::Equals(value, "FILTER_FALSE_OR_NULL")) {
2947: 		return FilterPropagateResult::FILTER_FALSE_OR_NULL;
2948: 	}
2949: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2950: }
2951: 
2952: template<>
2953: const char* EnumUtil::ToChars<ForeignKeyType>(ForeignKeyType value) {
2954: 	switch(value) {
2955: 	case ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE:
2956: 		return "FK_TYPE_PRIMARY_KEY_TABLE";
2957: 	case ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE:
2958: 		return "FK_TYPE_FOREIGN_KEY_TABLE";
2959: 	case ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE:
2960: 		return "FK_TYPE_SELF_REFERENCE_TABLE";
2961: 	default:
2962: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2963: 	}
2964: }
2965: 
2966: template<>
2967: ForeignKeyType EnumUtil::FromString<ForeignKeyType>(const char *value) {
2968: 	if (StringUtil::Equals(value, "FK_TYPE_PRIMARY_KEY_TABLE")) {
2969: 		return ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE;
2970: 	}
2971: 	if (StringUtil::Equals(value, "FK_TYPE_FOREIGN_KEY_TABLE")) {
2972: 		return ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE;
2973: 	}
2974: 	if (StringUtil::Equals(value, "FK_TYPE_SELF_REFERENCE_TABLE")) {
2975: 		return ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE;
2976: 	}
2977: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
2978: }
2979: 
2980: template<>
2981: const char* EnumUtil::ToChars<FunctionNullHandling>(FunctionNullHandling value) {
2982: 	switch(value) {
2983: 	case FunctionNullHandling::DEFAULT_NULL_HANDLING:
2984: 		return "DEFAULT_NULL_HANDLING";
2985: 	case FunctionNullHandling::SPECIAL_HANDLING:
2986: 		return "SPECIAL_HANDLING";
2987: 	default:
2988: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
2989: 	}
2990: }
2991: 
2992: template<>
2993: FunctionNullHandling EnumUtil::FromString<FunctionNullHandling>(const char *value) {
2994: 	if (StringUtil::Equals(value, "DEFAULT_NULL_HANDLING")) {
2995: 		return FunctionNullHandling::DEFAULT_NULL_HANDLING;
2996: 	}
2997: 	if (StringUtil::Equals(value, "SPECIAL_HANDLING")) {
2998: 		return FunctionNullHandling::SPECIAL_HANDLING;
2999: 	}
3000: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3001: }
3002: 
3003: template<>
3004: const char* EnumUtil::ToChars<FunctionStability>(FunctionStability value) {
3005: 	switch(value) {
3006: 	case FunctionStability::CONSISTENT:
3007: 		return "CONSISTENT";
3008: 	case FunctionStability::VOLATILE:
3009: 		return "VOLATILE";
3010: 	case FunctionStability::CONSISTENT_WITHIN_QUERY:
3011: 		return "CONSISTENT_WITHIN_QUERY";
3012: 	default:
3013: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3014: 	}
3015: }
3016: 
3017: template<>
3018: FunctionStability EnumUtil::FromString<FunctionStability>(const char *value) {
3019: 	if (StringUtil::Equals(value, "CONSISTENT")) {
3020: 		return FunctionStability::CONSISTENT;
3021: 	}
3022: 	if (StringUtil::Equals(value, "VOLATILE")) {
3023: 		return FunctionStability::VOLATILE;
3024: 	}
3025: 	if (StringUtil::Equals(value, "CONSISTENT_WITHIN_QUERY")) {
3026: 		return FunctionStability::CONSISTENT_WITHIN_QUERY;
3027: 	}
3028: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3029: }
3030: 
3031: template<>
3032: const char* EnumUtil::ToChars<HLLStorageType>(HLLStorageType value) {
3033: 	switch(value) {
3034: 	case HLLStorageType::UNCOMPRESSED:
3035: 		return "UNCOMPRESSED";
3036: 	default:
3037: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3038: 	}
3039: }
3040: 
3041: template<>
3042: HLLStorageType EnumUtil::FromString<HLLStorageType>(const char *value) {
3043: 	if (StringUtil::Equals(value, "UNCOMPRESSED")) {
3044: 		return HLLStorageType::UNCOMPRESSED;
3045: 	}
3046: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3047: }
3048: 
3049: template<>
3050: const char* EnumUtil::ToChars<IndexConstraintType>(IndexConstraintType value) {
3051: 	switch(value) {
3052: 	case IndexConstraintType::NONE:
3053: 		return "NONE";
3054: 	case IndexConstraintType::UNIQUE:
3055: 		return "UNIQUE";
3056: 	case IndexConstraintType::PRIMARY:
3057: 		return "PRIMARY";
3058: 	case IndexConstraintType::FOREIGN:
3059: 		return "FOREIGN";
3060: 	default:
3061: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3062: 	}
3063: }
3064: 
3065: template<>
3066: IndexConstraintType EnumUtil::FromString<IndexConstraintType>(const char *value) {
3067: 	if (StringUtil::Equals(value, "NONE")) {
3068: 		return IndexConstraintType::NONE;
3069: 	}
3070: 	if (StringUtil::Equals(value, "UNIQUE")) {
3071: 		return IndexConstraintType::UNIQUE;
3072: 	}
3073: 	if (StringUtil::Equals(value, "PRIMARY")) {
3074: 		return IndexConstraintType::PRIMARY;
3075: 	}
3076: 	if (StringUtil::Equals(value, "FOREIGN")) {
3077: 		return IndexConstraintType::FOREIGN;
3078: 	}
3079: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3080: }
3081: 
3082: template<>
3083: const char* EnumUtil::ToChars<InsertColumnOrder>(InsertColumnOrder value) {
3084: 	switch(value) {
3085: 	case InsertColumnOrder::INSERT_BY_POSITION:
3086: 		return "INSERT_BY_POSITION";
3087: 	case InsertColumnOrder::INSERT_BY_NAME:
3088: 		return "INSERT_BY_NAME";
3089: 	default:
3090: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3091: 	}
3092: }
3093: 
3094: template<>
3095: InsertColumnOrder EnumUtil::FromString<InsertColumnOrder>(const char *value) {
3096: 	if (StringUtil::Equals(value, "INSERT_BY_POSITION")) {
3097: 		return InsertColumnOrder::INSERT_BY_POSITION;
3098: 	}
3099: 	if (StringUtil::Equals(value, "INSERT_BY_NAME")) {
3100: 		return InsertColumnOrder::INSERT_BY_NAME;
3101: 	}
3102: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3103: }
3104: 
3105: template<>
3106: const char* EnumUtil::ToChars<InterruptMode>(InterruptMode value) {
3107: 	switch(value) {
3108: 	case InterruptMode::NO_INTERRUPTS:
3109: 		return "NO_INTERRUPTS";
3110: 	case InterruptMode::TASK:
3111: 		return "TASK";
3112: 	case InterruptMode::BLOCKING:
3113: 		return "BLOCKING";
3114: 	default:
3115: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3116: 	}
3117: }
3118: 
3119: template<>
3120: InterruptMode EnumUtil::FromString<InterruptMode>(const char *value) {
3121: 	if (StringUtil::Equals(value, "NO_INTERRUPTS")) {
3122: 		return InterruptMode::NO_INTERRUPTS;
3123: 	}
3124: 	if (StringUtil::Equals(value, "TASK")) {
3125: 		return InterruptMode::TASK;
3126: 	}
3127: 	if (StringUtil::Equals(value, "BLOCKING")) {
3128: 		return InterruptMode::BLOCKING;
3129: 	}
3130: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3131: }
3132: 
3133: template<>
3134: const char* EnumUtil::ToChars<JoinRefType>(JoinRefType value) {
3135: 	switch(value) {
3136: 	case JoinRefType::REGULAR:
3137: 		return "REGULAR";
3138: 	case JoinRefType::NATURAL:
3139: 		return "NATURAL";
3140: 	case JoinRefType::CROSS:
3141: 		return "CROSS";
3142: 	case JoinRefType::POSITIONAL:
3143: 		return "POSITIONAL";
3144: 	case JoinRefType::ASOF:
3145: 		return "ASOF";
3146: 	case JoinRefType::DEPENDENT:
3147: 		return "DEPENDENT";
3148: 	default:
3149: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3150: 	}
3151: }
3152: 
3153: template<>
3154: JoinRefType EnumUtil::FromString<JoinRefType>(const char *value) {
3155: 	if (StringUtil::Equals(value, "REGULAR")) {
3156: 		return JoinRefType::REGULAR;
3157: 	}
3158: 	if (StringUtil::Equals(value, "NATURAL")) {
3159: 		return JoinRefType::NATURAL;
3160: 	}
3161: 	if (StringUtil::Equals(value, "CROSS")) {
3162: 		return JoinRefType::CROSS;
3163: 	}
3164: 	if (StringUtil::Equals(value, "POSITIONAL")) {
3165: 		return JoinRefType::POSITIONAL;
3166: 	}
3167: 	if (StringUtil::Equals(value, "ASOF")) {
3168: 		return JoinRefType::ASOF;
3169: 	}
3170: 	if (StringUtil::Equals(value, "DEPENDENT")) {
3171: 		return JoinRefType::DEPENDENT;
3172: 	}
3173: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3174: }
3175: 
3176: template<>
3177: const char* EnumUtil::ToChars<JoinType>(JoinType value) {
3178: 	switch(value) {
3179: 	case JoinType::INVALID:
3180: 		return "INVALID";
3181: 	case JoinType::LEFT:
3182: 		return "LEFT";
3183: 	case JoinType::RIGHT:
3184: 		return "RIGHT";
3185: 	case JoinType::INNER:
3186: 		return "INNER";
3187: 	case JoinType::OUTER:
3188: 		return "FULL";
3189: 	case JoinType::SEMI:
3190: 		return "SEMI";
3191: 	case JoinType::ANTI:
3192: 		return "ANTI";
3193: 	case JoinType::MARK:
3194: 		return "MARK";
3195: 	case JoinType::SINGLE:
3196: 		return "SINGLE";
3197: 	case JoinType::RIGHT_SEMI:
3198: 		return "RIGHT_SEMI";
3199: 	case JoinType::RIGHT_ANTI:
3200: 		return "RIGHT_ANTI";
3201: 	default:
3202: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3203: 	}
3204: }
3205: 
3206: template<>
3207: JoinType EnumUtil::FromString<JoinType>(const char *value) {
3208: 	if (StringUtil::Equals(value, "INVALID")) {
3209: 		return JoinType::INVALID;
3210: 	}
3211: 	if (StringUtil::Equals(value, "LEFT")) {
3212: 		return JoinType::LEFT;
3213: 	}
3214: 	if (StringUtil::Equals(value, "RIGHT")) {
3215: 		return JoinType::RIGHT;
3216: 	}
3217: 	if (StringUtil::Equals(value, "INNER")) {
3218: 		return JoinType::INNER;
3219: 	}
3220: 	if (StringUtil::Equals(value, "FULL")) {
3221: 		return JoinType::OUTER;
3222: 	}
3223: 	if (StringUtil::Equals(value, "SEMI")) {
3224: 		return JoinType::SEMI;
3225: 	}
3226: 	if (StringUtil::Equals(value, "ANTI")) {
3227: 		return JoinType::ANTI;
3228: 	}
3229: 	if (StringUtil::Equals(value, "MARK")) {
3230: 		return JoinType::MARK;
3231: 	}
3232: 	if (StringUtil::Equals(value, "SINGLE")) {
3233: 		return JoinType::SINGLE;
3234: 	}
3235: 	if (StringUtil::Equals(value, "RIGHT_SEMI")) {
3236: 		return JoinType::RIGHT_SEMI;
3237: 	}
3238: 	if (StringUtil::Equals(value, "RIGHT_ANTI")) {
3239: 		return JoinType::RIGHT_ANTI;
3240: 	}
3241: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3242: }
3243: 
3244: template<>
3245: const char* EnumUtil::ToChars<KeywordCategory>(KeywordCategory value) {
3246: 	switch(value) {
3247: 	case KeywordCategory::KEYWORD_RESERVED:
3248: 		return "KEYWORD_RESERVED";
3249: 	case KeywordCategory::KEYWORD_UNRESERVED:
3250: 		return "KEYWORD_UNRESERVED";
3251: 	case KeywordCategory::KEYWORD_TYPE_FUNC:
3252: 		return "KEYWORD_TYPE_FUNC";
3253: 	case KeywordCategory::KEYWORD_COL_NAME:
3254: 		return "KEYWORD_COL_NAME";
3255: 	default:
3256: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3257: 	}
3258: }
3259: 
3260: template<>
3261: KeywordCategory EnumUtil::FromString<KeywordCategory>(const char *value) {
3262: 	if (StringUtil::Equals(value, "KEYWORD_RESERVED")) {
3263: 		return KeywordCategory::KEYWORD_RESERVED;
3264: 	}
3265: 	if (StringUtil::Equals(value, "KEYWORD_UNRESERVED")) {
3266: 		return KeywordCategory::KEYWORD_UNRESERVED;
3267: 	}
3268: 	if (StringUtil::Equals(value, "KEYWORD_TYPE_FUNC")) {
3269: 		return KeywordCategory::KEYWORD_TYPE_FUNC;
3270: 	}
3271: 	if (StringUtil::Equals(value, "KEYWORD_COL_NAME")) {
3272: 		return KeywordCategory::KEYWORD_COL_NAME;
3273: 	}
3274: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3275: }
3276: 
3277: template<>
3278: const char* EnumUtil::ToChars<LimitNodeType>(LimitNodeType value) {
3279: 	switch(value) {
3280: 	case LimitNodeType::UNSET:
3281: 		return "UNSET";
3282: 	case LimitNodeType::CONSTANT_VALUE:
3283: 		return "CONSTANT_VALUE";
3284: 	case LimitNodeType::CONSTANT_PERCENTAGE:
3285: 		return "CONSTANT_PERCENTAGE";
3286: 	case LimitNodeType::EXPRESSION_VALUE:
3287: 		return "EXPRESSION_VALUE";
3288: 	case LimitNodeType::EXPRESSION_PERCENTAGE:
3289: 		return "EXPRESSION_PERCENTAGE";
3290: 	default:
3291: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3292: 	}
3293: }
3294: 
3295: template<>
3296: LimitNodeType EnumUtil::FromString<LimitNodeType>(const char *value) {
3297: 	if (StringUtil::Equals(value, "UNSET")) {
3298: 		return LimitNodeType::UNSET;
3299: 	}
3300: 	if (StringUtil::Equals(value, "CONSTANT_VALUE")) {
3301: 		return LimitNodeType::CONSTANT_VALUE;
3302: 	}
3303: 	if (StringUtil::Equals(value, "CONSTANT_PERCENTAGE")) {
3304: 		return LimitNodeType::CONSTANT_PERCENTAGE;
3305: 	}
3306: 	if (StringUtil::Equals(value, "EXPRESSION_VALUE")) {
3307: 		return LimitNodeType::EXPRESSION_VALUE;
3308: 	}
3309: 	if (StringUtil::Equals(value, "EXPRESSION_PERCENTAGE")) {
3310: 		return LimitNodeType::EXPRESSION_PERCENTAGE;
3311: 	}
3312: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3313: }
3314: 
3315: template<>
3316: const char* EnumUtil::ToChars<LoadType>(LoadType value) {
3317: 	switch(value) {
3318: 	case LoadType::LOAD:
3319: 		return "LOAD";
3320: 	case LoadType::INSTALL:
3321: 		return "INSTALL";
3322: 	case LoadType::FORCE_INSTALL:
3323: 		return "FORCE_INSTALL";
3324: 	default:
3325: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3326: 	}
3327: }
3328: 
3329: template<>
3330: LoadType EnumUtil::FromString<LoadType>(const char *value) {
3331: 	if (StringUtil::Equals(value, "LOAD")) {
3332: 		return LoadType::LOAD;
3333: 	}
3334: 	if (StringUtil::Equals(value, "INSTALL")) {
3335: 		return LoadType::INSTALL;
3336: 	}
3337: 	if (StringUtil::Equals(value, "FORCE_INSTALL")) {
3338: 		return LoadType::FORCE_INSTALL;
3339: 	}
3340: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3341: }
3342: 
3343: template<>
3344: const char* EnumUtil::ToChars<LogicalOperatorType>(LogicalOperatorType value) {
3345: 	switch(value) {
3346: 	case LogicalOperatorType::LOGICAL_INVALID:
3347: 		return "LOGICAL_INVALID";
3348: 	case LogicalOperatorType::LOGICAL_PROJECTION:
3349: 		return "LOGICAL_PROJECTION";
3350: 	case LogicalOperatorType::LOGICAL_FILTER:
3351: 		return "LOGICAL_FILTER";
3352: 	case LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY:
3353: 		return "LOGICAL_AGGREGATE_AND_GROUP_BY";
3354: 	case LogicalOperatorType::LOGICAL_WINDOW:
3355: 		return "LOGICAL_WINDOW";
3356: 	case LogicalOperatorType::LOGICAL_UNNEST:
3357: 		return "LOGICAL_UNNEST";
3358: 	case LogicalOperatorType::LOGICAL_LIMIT:
3359: 		return "LOGICAL_LIMIT";
3360: 	case LogicalOperatorType::LOGICAL_ORDER_BY:
3361: 		return "LOGICAL_ORDER_BY";
3362: 	case LogicalOperatorType::LOGICAL_TOP_N:
3363: 		return "LOGICAL_TOP_N";
3364: 	case LogicalOperatorType::LOGICAL_COPY_TO_FILE:
3365: 		return "LOGICAL_COPY_TO_FILE";
3366: 	case LogicalOperatorType::LOGICAL_DISTINCT:
3367: 		return "LOGICAL_DISTINCT";
3368: 	case LogicalOperatorType::LOGICAL_SAMPLE:
3369: 		return "LOGICAL_SAMPLE";
3370: 	case LogicalOperatorType::LOGICAL_PIVOT:
3371: 		return "LOGICAL_PIVOT";
3372: 	case LogicalOperatorType::LOGICAL_COPY_DATABASE:
3373: 		return "LOGICAL_COPY_DATABASE";
3374: 	case LogicalOperatorType::LOGICAL_GET:
3375: 		return "LOGICAL_GET";
3376: 	case LogicalOperatorType::LOGICAL_CHUNK_GET:
3377: 		return "LOGICAL_CHUNK_GET";
3378: 	case LogicalOperatorType::LOGICAL_DELIM_GET:
3379: 		return "LOGICAL_DELIM_GET";
3380: 	case LogicalOperatorType::LOGICAL_EXPRESSION_GET:
3381: 		return "LOGICAL_EXPRESSION_GET";
3382: 	case LogicalOperatorType::LOGICAL_DUMMY_SCAN:
3383: 		return "LOGICAL_DUMMY_SCAN";
3384: 	case LogicalOperatorType::LOGICAL_EMPTY_RESULT:
3385: 		return "LOGICAL_EMPTY_RESULT";
3386: 	case LogicalOperatorType::LOGICAL_CTE_REF:
3387: 		return "LOGICAL_CTE_REF";
3388: 	case LogicalOperatorType::LOGICAL_JOIN:
3389: 		return "LOGICAL_JOIN";
3390: 	case LogicalOperatorType::LOGICAL_DELIM_JOIN:
3391: 		return "LOGICAL_DELIM_JOIN";
3392: 	case LogicalOperatorType::LOGICAL_COMPARISON_JOIN:
3393: 		return "LOGICAL_COMPARISON_JOIN";
3394: 	case LogicalOperatorType::LOGICAL_ANY_JOIN:
3395: 		return "LOGICAL_ANY_JOIN";
3396: 	case LogicalOperatorType::LOGICAL_CROSS_PRODUCT:
3397: 		return "LOGICAL_CROSS_PRODUCT";
3398: 	case LogicalOperatorType::LOGICAL_POSITIONAL_JOIN:
3399: 		return "LOGICAL_POSITIONAL_JOIN";
3400: 	case LogicalOperatorType::LOGICAL_ASOF_JOIN:
3401: 		return "LOGICAL_ASOF_JOIN";
3402: 	case LogicalOperatorType::LOGICAL_DEPENDENT_JOIN:
3403: 		return "LOGICAL_DEPENDENT_JOIN";
3404: 	case LogicalOperatorType::LOGICAL_UNION:
3405: 		return "LOGICAL_UNION";
3406: 	case LogicalOperatorType::LOGICAL_EXCEPT:
3407: 		return "LOGICAL_EXCEPT";
3408: 	case LogicalOperatorType::LOGICAL_INTERSECT:
3409: 		return "LOGICAL_INTERSECT";
3410: 	case LogicalOperatorType::LOGICAL_RECURSIVE_CTE:
3411: 		return "LOGICAL_RECURSIVE_CTE";
3412: 	case LogicalOperatorType::LOGICAL_MATERIALIZED_CTE:
3413: 		return "LOGICAL_MATERIALIZED_CTE";
3414: 	case LogicalOperatorType::LOGICAL_INSERT:
3415: 		return "LOGICAL_INSERT";
3416: 	case LogicalOperatorType::LOGICAL_DELETE:
3417: 		return "LOGICAL_DELETE";
3418: 	case LogicalOperatorType::LOGICAL_UPDATE:
3419: 		return "LOGICAL_UPDATE";
3420: 	case LogicalOperatorType::LOGICAL_ALTER:
3421: 		return "LOGICAL_ALTER";
3422: 	case LogicalOperatorType::LOGICAL_CREATE_TABLE:
3423: 		return "LOGICAL_CREATE_TABLE";
3424: 	case LogicalOperatorType::LOGICAL_CREATE_INDEX:
3425: 		return "LOGICAL_CREATE_INDEX";
3426: 	case LogicalOperatorType::LOGICAL_CREATE_SEQUENCE:
3427: 		return "LOGICAL_CREATE_SEQUENCE";
3428: 	case LogicalOperatorType::LOGICAL_CREATE_VIEW:
3429: 		return "LOGICAL_CREATE_VIEW";
3430: 	case LogicalOperatorType::LOGICAL_CREATE_SCHEMA:
3431: 		return "LOGICAL_CREATE_SCHEMA";
3432: 	case LogicalOperatorType::LOGICAL_CREATE_MACRO:
3433: 		return "LOGICAL_CREATE_MACRO";
3434: 	case LogicalOperatorType::LOGICAL_DROP:
3435: 		return "LOGICAL_DROP";
3436: 	case LogicalOperatorType::LOGICAL_PRAGMA:
3437: 		return "LOGICAL_PRAGMA";
3438: 	case LogicalOperatorType::LOGICAL_TRANSACTION:
3439: 		return "LOGICAL_TRANSACTION";
3440: 	case LogicalOperatorType::LOGICAL_CREATE_TYPE:
3441: 		return "LOGICAL_CREATE_TYPE";
3442: 	case LogicalOperatorType::LOGICAL_ATTACH:
3443: 		return "LOGICAL_ATTACH";
3444: 	case LogicalOperatorType::LOGICAL_DETACH:
3445: 		return "LOGICAL_DETACH";
3446: 	case LogicalOperatorType::LOGICAL_EXPLAIN:
3447: 		return "LOGICAL_EXPLAIN";
3448: 	case LogicalOperatorType::LOGICAL_PREPARE:
3449: 		return "LOGICAL_PREPARE";
3450: 	case LogicalOperatorType::LOGICAL_EXECUTE:
3451: 		return "LOGICAL_EXECUTE";
3452: 	case LogicalOperatorType::LOGICAL_EXPORT:
3453: 		return "LOGICAL_EXPORT";
3454: 	case LogicalOperatorType::LOGICAL_VACUUM:
3455: 		return "LOGICAL_VACUUM";
3456: 	case LogicalOperatorType::LOGICAL_SET:
3457: 		return "LOGICAL_SET";
3458: 	case LogicalOperatorType::LOGICAL_LOAD:
3459: 		return "LOGICAL_LOAD";
3460: 	case LogicalOperatorType::LOGICAL_RESET:
3461: 		return "LOGICAL_RESET";
3462: 	case LogicalOperatorType::LOGICAL_UPDATE_EXTENSIONS:
3463: 		return "LOGICAL_UPDATE_EXTENSIONS";
3464: 	case LogicalOperatorType::LOGICAL_CREATE_SECRET:
3465: 		return "LOGICAL_CREATE_SECRET";
3466: 	case LogicalOperatorType::LOGICAL_EXTENSION_OPERATOR:
3467: 		return "LOGICAL_EXTENSION_OPERATOR";
3468: 	default:
3469: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3470: 	}
3471: }
3472: 
3473: template<>
3474: LogicalOperatorType EnumUtil::FromString<LogicalOperatorType>(const char *value) {
3475: 	if (StringUtil::Equals(value, "LOGICAL_INVALID")) {
3476: 		return LogicalOperatorType::LOGICAL_INVALID;
3477: 	}
3478: 	if (StringUtil::Equals(value, "LOGICAL_PROJECTION")) {
3479: 		return LogicalOperatorType::LOGICAL_PROJECTION;
3480: 	}
3481: 	if (StringUtil::Equals(value, "LOGICAL_FILTER")) {
3482: 		return LogicalOperatorType::LOGICAL_FILTER;
3483: 	}
3484: 	if (StringUtil::Equals(value, "LOGICAL_AGGREGATE_AND_GROUP_BY")) {
3485: 		return LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY;
3486: 	}
3487: 	if (StringUtil::Equals(value, "LOGICAL_WINDOW")) {
3488: 		return LogicalOperatorType::LOGICAL_WINDOW;
3489: 	}
3490: 	if (StringUtil::Equals(value, "LOGICAL_UNNEST")) {
3491: 		return LogicalOperatorType::LOGICAL_UNNEST;
3492: 	}
3493: 	if (StringUtil::Equals(value, "LOGICAL_LIMIT")) {
3494: 		return LogicalOperatorType::LOGICAL_LIMIT;
3495: 	}
3496: 	if (StringUtil::Equals(value, "LOGICAL_ORDER_BY")) {
3497: 		return LogicalOperatorType::LOGICAL_ORDER_BY;
3498: 	}
3499: 	if (StringUtil::Equals(value, "LOGICAL_TOP_N")) {
3500: 		return LogicalOperatorType::LOGICAL_TOP_N;
3501: 	}
3502: 	if (StringUtil::Equals(value, "LOGICAL_COPY_TO_FILE")) {
3503: 		return LogicalOperatorType::LOGICAL_COPY_TO_FILE;
3504: 	}
3505: 	if (StringUtil::Equals(value, "LOGICAL_DISTINCT")) {
3506: 		return LogicalOperatorType::LOGICAL_DISTINCT;
3507: 	}
3508: 	if (StringUtil::Equals(value, "LOGICAL_SAMPLE")) {
3509: 		return LogicalOperatorType::LOGICAL_SAMPLE;
3510: 	}
3511: 	if (StringUtil::Equals(value, "LOGICAL_PIVOT")) {
3512: 		return LogicalOperatorType::LOGICAL_PIVOT;
3513: 	}
3514: 	if (StringUtil::Equals(value, "LOGICAL_COPY_DATABASE")) {
3515: 		return LogicalOperatorType::LOGICAL_COPY_DATABASE;
3516: 	}
3517: 	if (StringUtil::Equals(value, "LOGICAL_GET")) {
3518: 		return LogicalOperatorType::LOGICAL_GET;
3519: 	}
3520: 	if (StringUtil::Equals(value, "LOGICAL_CHUNK_GET")) {
3521: 		return LogicalOperatorType::LOGICAL_CHUNK_GET;
3522: 	}
3523: 	if (StringUtil::Equals(value, "LOGICAL_DELIM_GET")) {
3524: 		return LogicalOperatorType::LOGICAL_DELIM_GET;
3525: 	}
3526: 	if (StringUtil::Equals(value, "LOGICAL_EXPRESSION_GET")) {
3527: 		return LogicalOperatorType::LOGICAL_EXPRESSION_GET;
3528: 	}
3529: 	if (StringUtil::Equals(value, "LOGICAL_DUMMY_SCAN")) {
3530: 		return LogicalOperatorType::LOGICAL_DUMMY_SCAN;
3531: 	}
3532: 	if (StringUtil::Equals(value, "LOGICAL_EMPTY_RESULT")) {
3533: 		return LogicalOperatorType::LOGICAL_EMPTY_RESULT;
3534: 	}
3535: 	if (StringUtil::Equals(value, "LOGICAL_CTE_REF")) {
3536: 		return LogicalOperatorType::LOGICAL_CTE_REF;
3537: 	}
3538: 	if (StringUtil::Equals(value, "LOGICAL_JOIN")) {
3539: 		return LogicalOperatorType::LOGICAL_JOIN;
3540: 	}
3541: 	if (StringUtil::Equals(value, "LOGICAL_DELIM_JOIN")) {
3542: 		return LogicalOperatorType::LOGICAL_DELIM_JOIN;
3543: 	}
3544: 	if (StringUtil::Equals(value, "LOGICAL_COMPARISON_JOIN")) {
3545: 		return LogicalOperatorType::LOGICAL_COMPARISON_JOIN;
3546: 	}
3547: 	if (StringUtil::Equals(value, "LOGICAL_ANY_JOIN")) {
3548: 		return LogicalOperatorType::LOGICAL_ANY_JOIN;
3549: 	}
3550: 	if (StringUtil::Equals(value, "LOGICAL_CROSS_PRODUCT")) {
3551: 		return LogicalOperatorType::LOGICAL_CROSS_PRODUCT;
3552: 	}
3553: 	if (StringUtil::Equals(value, "LOGICAL_POSITIONAL_JOIN")) {
3554: 		return LogicalOperatorType::LOGICAL_POSITIONAL_JOIN;
3555: 	}
3556: 	if (StringUtil::Equals(value, "LOGICAL_ASOF_JOIN")) {
3557: 		return LogicalOperatorType::LOGICAL_ASOF_JOIN;
3558: 	}
3559: 	if (StringUtil::Equals(value, "LOGICAL_DEPENDENT_JOIN")) {
3560: 		return LogicalOperatorType::LOGICAL_DEPENDENT_JOIN;
3561: 	}
3562: 	if (StringUtil::Equals(value, "LOGICAL_UNION")) {
3563: 		return LogicalOperatorType::LOGICAL_UNION;
3564: 	}
3565: 	if (StringUtil::Equals(value, "LOGICAL_EXCEPT")) {
3566: 		return LogicalOperatorType::LOGICAL_EXCEPT;
3567: 	}
3568: 	if (StringUtil::Equals(value, "LOGICAL_INTERSECT")) {
3569: 		return LogicalOperatorType::LOGICAL_INTERSECT;
3570: 	}
3571: 	if (StringUtil::Equals(value, "LOGICAL_RECURSIVE_CTE")) {
3572: 		return LogicalOperatorType::LOGICAL_RECURSIVE_CTE;
3573: 	}
3574: 	if (StringUtil::Equals(value, "LOGICAL_MATERIALIZED_CTE")) {
3575: 		return LogicalOperatorType::LOGICAL_MATERIALIZED_CTE;
3576: 	}
3577: 	if (StringUtil::Equals(value, "LOGICAL_INSERT")) {
3578: 		return LogicalOperatorType::LOGICAL_INSERT;
3579: 	}
3580: 	if (StringUtil::Equals(value, "LOGICAL_DELETE")) {
3581: 		return LogicalOperatorType::LOGICAL_DELETE;
3582: 	}
3583: 	if (StringUtil::Equals(value, "LOGICAL_UPDATE")) {
3584: 		return LogicalOperatorType::LOGICAL_UPDATE;
3585: 	}
3586: 	if (StringUtil::Equals(value, "LOGICAL_ALTER")) {
3587: 		return LogicalOperatorType::LOGICAL_ALTER;
3588: 	}
3589: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_TABLE")) {
3590: 		return LogicalOperatorType::LOGICAL_CREATE_TABLE;
3591: 	}
3592: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_INDEX")) {
3593: 		return LogicalOperatorType::LOGICAL_CREATE_INDEX;
3594: 	}
3595: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_SEQUENCE")) {
3596: 		return LogicalOperatorType::LOGICAL_CREATE_SEQUENCE;
3597: 	}
3598: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_VIEW")) {
3599: 		return LogicalOperatorType::LOGICAL_CREATE_VIEW;
3600: 	}
3601: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_SCHEMA")) {
3602: 		return LogicalOperatorType::LOGICAL_CREATE_SCHEMA;
3603: 	}
3604: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_MACRO")) {
3605: 		return LogicalOperatorType::LOGICAL_CREATE_MACRO;
3606: 	}
3607: 	if (StringUtil::Equals(value, "LOGICAL_DROP")) {
3608: 		return LogicalOperatorType::LOGICAL_DROP;
3609: 	}
3610: 	if (StringUtil::Equals(value, "LOGICAL_PRAGMA")) {
3611: 		return LogicalOperatorType::LOGICAL_PRAGMA;
3612: 	}
3613: 	if (StringUtil::Equals(value, "LOGICAL_TRANSACTION")) {
3614: 		return LogicalOperatorType::LOGICAL_TRANSACTION;
3615: 	}
3616: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_TYPE")) {
3617: 		return LogicalOperatorType::LOGICAL_CREATE_TYPE;
3618: 	}
3619: 	if (StringUtil::Equals(value, "LOGICAL_ATTACH")) {
3620: 		return LogicalOperatorType::LOGICAL_ATTACH;
3621: 	}
3622: 	if (StringUtil::Equals(value, "LOGICAL_DETACH")) {
3623: 		return LogicalOperatorType::LOGICAL_DETACH;
3624: 	}
3625: 	if (StringUtil::Equals(value, "LOGICAL_EXPLAIN")) {
3626: 		return LogicalOperatorType::LOGICAL_EXPLAIN;
3627: 	}
3628: 	if (StringUtil::Equals(value, "LOGICAL_PREPARE")) {
3629: 		return LogicalOperatorType::LOGICAL_PREPARE;
3630: 	}
3631: 	if (StringUtil::Equals(value, "LOGICAL_EXECUTE")) {
3632: 		return LogicalOperatorType::LOGICAL_EXECUTE;
3633: 	}
3634: 	if (StringUtil::Equals(value, "LOGICAL_EXPORT")) {
3635: 		return LogicalOperatorType::LOGICAL_EXPORT;
3636: 	}
3637: 	if (StringUtil::Equals(value, "LOGICAL_VACUUM")) {
3638: 		return LogicalOperatorType::LOGICAL_VACUUM;
3639: 	}
3640: 	if (StringUtil::Equals(value, "LOGICAL_SET")) {
3641: 		return LogicalOperatorType::LOGICAL_SET;
3642: 	}
3643: 	if (StringUtil::Equals(value, "LOGICAL_LOAD")) {
3644: 		return LogicalOperatorType::LOGICAL_LOAD;
3645: 	}
3646: 	if (StringUtil::Equals(value, "LOGICAL_RESET")) {
3647: 		return LogicalOperatorType::LOGICAL_RESET;
3648: 	}
3649: 	if (StringUtil::Equals(value, "LOGICAL_UPDATE_EXTENSIONS")) {
3650: 		return LogicalOperatorType::LOGICAL_UPDATE_EXTENSIONS;
3651: 	}
3652: 	if (StringUtil::Equals(value, "LOGICAL_CREATE_SECRET")) {
3653: 		return LogicalOperatorType::LOGICAL_CREATE_SECRET;
3654: 	}
3655: 	if (StringUtil::Equals(value, "LOGICAL_EXTENSION_OPERATOR")) {
3656: 		return LogicalOperatorType::LOGICAL_EXTENSION_OPERATOR;
3657: 	}
3658: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3659: }
3660: 
3661: template<>
3662: const char* EnumUtil::ToChars<LogicalTypeId>(LogicalTypeId value) {
3663: 	switch(value) {
3664: 	case LogicalTypeId::INVALID:
3665: 		return "INVALID";
3666: 	case LogicalTypeId::SQLNULL:
3667: 		return "NULL";
3668: 	case LogicalTypeId::UNKNOWN:
3669: 		return "UNKNOWN";
3670: 	case LogicalTypeId::ANY:
3671: 		return "ANY";
3672: 	case LogicalTypeId::USER:
3673: 		return "USER";
3674: 	case LogicalTypeId::BOOLEAN:
3675: 		return "BOOLEAN";
3676: 	case LogicalTypeId::TINYINT:
3677: 		return "TINYINT";
3678: 	case LogicalTypeId::SMALLINT:
3679: 		return "SMALLINT";
3680: 	case LogicalTypeId::INTEGER:
3681: 		return "INTEGER";
3682: 	case LogicalTypeId::BIGINT:
3683: 		return "BIGINT";
3684: 	case LogicalTypeId::DATE:
3685: 		return "DATE";
3686: 	case LogicalTypeId::TIME:
3687: 		return "TIME";
3688: 	case LogicalTypeId::TIMESTAMP_SEC:
3689: 		return "TIMESTAMP_S";
3690: 	case LogicalTypeId::TIMESTAMP_MS:
3691: 		return "TIMESTAMP_MS";
3692: 	case LogicalTypeId::TIMESTAMP:
3693: 		return "TIMESTAMP";
3694: 	case LogicalTypeId::TIMESTAMP_NS:
3695: 		return "TIMESTAMP_NS";
3696: 	case LogicalTypeId::DECIMAL:
3697: 		return "DECIMAL";
3698: 	case LogicalTypeId::FLOAT:
3699: 		return "FLOAT";
3700: 	case LogicalTypeId::DOUBLE:
3701: 		return "DOUBLE";
3702: 	case LogicalTypeId::CHAR:
3703: 		return "CHAR";
3704: 	case LogicalTypeId::VARCHAR:
3705: 		return "VARCHAR";
3706: 	case LogicalTypeId::BLOB:
3707: 		return "BLOB";
3708: 	case LogicalTypeId::INTERVAL:
3709: 		return "INTERVAL";
3710: 	case LogicalTypeId::UTINYINT:
3711: 		return "UTINYINT";
3712: 	case LogicalTypeId::USMALLINT:
3713: 		return "USMALLINT";
3714: 	case LogicalTypeId::UINTEGER:
3715: 		return "UINTEGER";
3716: 	case LogicalTypeId::UBIGINT:
3717: 		return "UBIGINT";
3718: 	case LogicalTypeId::TIMESTAMP_TZ:
3719: 		return "TIMESTAMP WITH TIME ZONE";
3720: 	case LogicalTypeId::TIME_TZ:
3721: 		return "TIME WITH TIME ZONE";
3722: 	case LogicalTypeId::BIT:
3723: 		return "BIT";
3724: 	case LogicalTypeId::STRING_LITERAL:
3725: 		return "STRING_LITERAL";
3726: 	case LogicalTypeId::INTEGER_LITERAL:
3727: 		return "INTEGER_LITERAL";
3728: 	case LogicalTypeId::UHUGEINT:
3729: 		return "UHUGEINT";
3730: 	case LogicalTypeId::HUGEINT:
3731: 		return "HUGEINT";
3732: 	case LogicalTypeId::POINTER:
3733: 		return "POINTER";
3734: 	case LogicalTypeId::VALIDITY:
3735: 		return "VALIDITY";
3736: 	case LogicalTypeId::UUID:
3737: 		return "UUID";
3738: 	case LogicalTypeId::STRUCT:
3739: 		return "STRUCT";
3740: 	case LogicalTypeId::LIST:
3741: 		return "LIST";
3742: 	case LogicalTypeId::MAP:
3743: 		return "MAP";
3744: 	case LogicalTypeId::TABLE:
3745: 		return "TABLE";
3746: 	case LogicalTypeId::ENUM:
3747: 		return "ENUM";
3748: 	case LogicalTypeId::AGGREGATE_STATE:
3749: 		return "AGGREGATE_STATE";
3750: 	case LogicalTypeId::LAMBDA:
3751: 		return "LAMBDA";
3752: 	case LogicalTypeId::UNION:
3753: 		return "UNION";
3754: 	case LogicalTypeId::ARRAY:
3755: 		return "ARRAY";
3756: 	default:
3757: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3758: 	}
3759: }
3760: 
3761: template<>
3762: LogicalTypeId EnumUtil::FromString<LogicalTypeId>(const char *value) {
3763: 	if (StringUtil::Equals(value, "INVALID")) {
3764: 		return LogicalTypeId::INVALID;
3765: 	}
3766: 	if (StringUtil::Equals(value, "NULL")) {
3767: 		return LogicalTypeId::SQLNULL;
3768: 	}
3769: 	if (StringUtil::Equals(value, "UNKNOWN")) {
3770: 		return LogicalTypeId::UNKNOWN;
3771: 	}
3772: 	if (StringUtil::Equals(value, "ANY")) {
3773: 		return LogicalTypeId::ANY;
3774: 	}
3775: 	if (StringUtil::Equals(value, "USER")) {
3776: 		return LogicalTypeId::USER;
3777: 	}
3778: 	if (StringUtil::Equals(value, "BOOLEAN")) {
3779: 		return LogicalTypeId::BOOLEAN;
3780: 	}
3781: 	if (StringUtil::Equals(value, "TINYINT")) {
3782: 		return LogicalTypeId::TINYINT;
3783: 	}
3784: 	if (StringUtil::Equals(value, "SMALLINT")) {
3785: 		return LogicalTypeId::SMALLINT;
3786: 	}
3787: 	if (StringUtil::Equals(value, "INTEGER")) {
3788: 		return LogicalTypeId::INTEGER;
3789: 	}
3790: 	if (StringUtil::Equals(value, "BIGINT")) {
3791: 		return LogicalTypeId::BIGINT;
3792: 	}
3793: 	if (StringUtil::Equals(value, "DATE")) {
3794: 		return LogicalTypeId::DATE;
3795: 	}
3796: 	if (StringUtil::Equals(value, "TIME")) {
3797: 		return LogicalTypeId::TIME;
3798: 	}
3799: 	if (StringUtil::Equals(value, "TIMESTAMP_S")) {
3800: 		return LogicalTypeId::TIMESTAMP_SEC;
3801: 	}
3802: 	if (StringUtil::Equals(value, "TIMESTAMP_MS")) {
3803: 		return LogicalTypeId::TIMESTAMP_MS;
3804: 	}
3805: 	if (StringUtil::Equals(value, "TIMESTAMP")) {
3806: 		return LogicalTypeId::TIMESTAMP;
3807: 	}
3808: 	if (StringUtil::Equals(value, "TIMESTAMP_NS")) {
3809: 		return LogicalTypeId::TIMESTAMP_NS;
3810: 	}
3811: 	if (StringUtil::Equals(value, "DECIMAL")) {
3812: 		return LogicalTypeId::DECIMAL;
3813: 	}
3814: 	if (StringUtil::Equals(value, "FLOAT")) {
3815: 		return LogicalTypeId::FLOAT;
3816: 	}
3817: 	if (StringUtil::Equals(value, "DOUBLE")) {
3818: 		return LogicalTypeId::DOUBLE;
3819: 	}
3820: 	if (StringUtil::Equals(value, "CHAR")) {
3821: 		return LogicalTypeId::CHAR;
3822: 	}
3823: 	if (StringUtil::Equals(value, "VARCHAR")) {
3824: 		return LogicalTypeId::VARCHAR;
3825: 	}
3826: 	if (StringUtil::Equals(value, "BLOB")) {
3827: 		return LogicalTypeId::BLOB;
3828: 	}
3829: 	if (StringUtil::Equals(value, "INTERVAL")) {
3830: 		return LogicalTypeId::INTERVAL;
3831: 	}
3832: 	if (StringUtil::Equals(value, "UTINYINT")) {
3833: 		return LogicalTypeId::UTINYINT;
3834: 	}
3835: 	if (StringUtil::Equals(value, "USMALLINT")) {
3836: 		return LogicalTypeId::USMALLINT;
3837: 	}
3838: 	if (StringUtil::Equals(value, "UINTEGER")) {
3839: 		return LogicalTypeId::UINTEGER;
3840: 	}
3841: 	if (StringUtil::Equals(value, "UBIGINT")) {
3842: 		return LogicalTypeId::UBIGINT;
3843: 	}
3844: 	if (StringUtil::Equals(value, "TIMESTAMP WITH TIME ZONE")) {
3845: 		return LogicalTypeId::TIMESTAMP_TZ;
3846: 	}
3847: 	if (StringUtil::Equals(value, "TIME WITH TIME ZONE")) {
3848: 		return LogicalTypeId::TIME_TZ;
3849: 	}
3850: 	if (StringUtil::Equals(value, "BIT")) {
3851: 		return LogicalTypeId::BIT;
3852: 	}
3853: 	if (StringUtil::Equals(value, "STRING_LITERAL")) {
3854: 		return LogicalTypeId::STRING_LITERAL;
3855: 	}
3856: 	if (StringUtil::Equals(value, "INTEGER_LITERAL")) {
3857: 		return LogicalTypeId::INTEGER_LITERAL;
3858: 	}
3859: 	if (StringUtil::Equals(value, "UHUGEINT")) {
3860: 		return LogicalTypeId::UHUGEINT;
3861: 	}
3862: 	if (StringUtil::Equals(value, "HUGEINT")) {
3863: 		return LogicalTypeId::HUGEINT;
3864: 	}
3865: 	if (StringUtil::Equals(value, "POINTER")) {
3866: 		return LogicalTypeId::POINTER;
3867: 	}
3868: 	if (StringUtil::Equals(value, "VALIDITY")) {
3869: 		return LogicalTypeId::VALIDITY;
3870: 	}
3871: 	if (StringUtil::Equals(value, "UUID")) {
3872: 		return LogicalTypeId::UUID;
3873: 	}
3874: 	if (StringUtil::Equals(value, "STRUCT")) {
3875: 		return LogicalTypeId::STRUCT;
3876: 	}
3877: 	if (StringUtil::Equals(value, "LIST")) {
3878: 		return LogicalTypeId::LIST;
3879: 	}
3880: 	if (StringUtil::Equals(value, "MAP")) {
3881: 		return LogicalTypeId::MAP;
3882: 	}
3883: 	if (StringUtil::Equals(value, "TABLE")) {
3884: 		return LogicalTypeId::TABLE;
3885: 	}
3886: 	if (StringUtil::Equals(value, "ENUM")) {
3887: 		return LogicalTypeId::ENUM;
3888: 	}
3889: 	if (StringUtil::Equals(value, "AGGREGATE_STATE")) {
3890: 		return LogicalTypeId::AGGREGATE_STATE;
3891: 	}
3892: 	if (StringUtil::Equals(value, "LAMBDA")) {
3893: 		return LogicalTypeId::LAMBDA;
3894: 	}
3895: 	if (StringUtil::Equals(value, "UNION")) {
3896: 		return LogicalTypeId::UNION;
3897: 	}
3898: 	if (StringUtil::Equals(value, "ARRAY")) {
3899: 		return LogicalTypeId::ARRAY;
3900: 	}
3901: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3902: }
3903: 
3904: template<>
3905: const char* EnumUtil::ToChars<LookupResultType>(LookupResultType value) {
3906: 	switch(value) {
3907: 	case LookupResultType::LOOKUP_MISS:
3908: 		return "LOOKUP_MISS";
3909: 	case LookupResultType::LOOKUP_HIT:
3910: 		return "LOOKUP_HIT";
3911: 	case LookupResultType::LOOKUP_NULL:
3912: 		return "LOOKUP_NULL";
3913: 	default:
3914: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3915: 	}
3916: }
3917: 
3918: template<>
3919: LookupResultType EnumUtil::FromString<LookupResultType>(const char *value) {
3920: 	if (StringUtil::Equals(value, "LOOKUP_MISS")) {
3921: 		return LookupResultType::LOOKUP_MISS;
3922: 	}
3923: 	if (StringUtil::Equals(value, "LOOKUP_HIT")) {
3924: 		return LookupResultType::LOOKUP_HIT;
3925: 	}
3926: 	if (StringUtil::Equals(value, "LOOKUP_NULL")) {
3927: 		return LookupResultType::LOOKUP_NULL;
3928: 	}
3929: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3930: }
3931: 
3932: template<>
3933: const char* EnumUtil::ToChars<MacroType>(MacroType value) {
3934: 	switch(value) {
3935: 	case MacroType::VOID_MACRO:
3936: 		return "VOID_MACRO";
3937: 	case MacroType::TABLE_MACRO:
3938: 		return "TABLE_MACRO";
3939: 	case MacroType::SCALAR_MACRO:
3940: 		return "SCALAR_MACRO";
3941: 	default:
3942: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3943: 	}
3944: }
3945: 
3946: template<>
3947: MacroType EnumUtil::FromString<MacroType>(const char *value) {
3948: 	if (StringUtil::Equals(value, "VOID_MACRO")) {
3949: 		return MacroType::VOID_MACRO;
3950: 	}
3951: 	if (StringUtil::Equals(value, "TABLE_MACRO")) {
3952: 		return MacroType::TABLE_MACRO;
3953: 	}
3954: 	if (StringUtil::Equals(value, "SCALAR_MACRO")) {
3955: 		return MacroType::SCALAR_MACRO;
3956: 	}
3957: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3958: }
3959: 
3960: template<>
3961: const char* EnumUtil::ToChars<MapInvalidReason>(MapInvalidReason value) {
3962: 	switch(value) {
3963: 	case MapInvalidReason::VALID:
3964: 		return "VALID";
3965: 	case MapInvalidReason::NULL_KEY:
3966: 		return "NULL_KEY";
3967: 	case MapInvalidReason::DUPLICATE_KEY:
3968: 		return "DUPLICATE_KEY";
3969: 	case MapInvalidReason::NOT_ALIGNED:
3970: 		return "NOT_ALIGNED";
3971: 	case MapInvalidReason::INVALID_PARAMS:
3972: 		return "INVALID_PARAMS";
3973: 	default:
3974: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
3975: 	}
3976: }
3977: 
3978: template<>
3979: MapInvalidReason EnumUtil::FromString<MapInvalidReason>(const char *value) {
3980: 	if (StringUtil::Equals(value, "VALID")) {
3981: 		return MapInvalidReason::VALID;
3982: 	}
3983: 	if (StringUtil::Equals(value, "NULL_KEY")) {
3984: 		return MapInvalidReason::NULL_KEY;
3985: 	}
3986: 	if (StringUtil::Equals(value, "DUPLICATE_KEY")) {
3987: 		return MapInvalidReason::DUPLICATE_KEY;
3988: 	}
3989: 	if (StringUtil::Equals(value, "NOT_ALIGNED")) {
3990: 		return MapInvalidReason::NOT_ALIGNED;
3991: 	}
3992: 	if (StringUtil::Equals(value, "INVALID_PARAMS")) {
3993: 		return MapInvalidReason::INVALID_PARAMS;
3994: 	}
3995: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
3996: }
3997: 
3998: template<>
3999: const char* EnumUtil::ToChars<MemoryTag>(MemoryTag value) {
4000: 	switch(value) {
4001: 	case MemoryTag::BASE_TABLE:
4002: 		return "BASE_TABLE";
4003: 	case MemoryTag::HASH_TABLE:
4004: 		return "HASH_TABLE";
4005: 	case MemoryTag::PARQUET_READER:
4006: 		return "PARQUET_READER";
4007: 	case MemoryTag::CSV_READER:
4008: 		return "CSV_READER";
4009: 	case MemoryTag::ORDER_BY:
4010: 		return "ORDER_BY";
4011: 	case MemoryTag::ART_INDEX:
4012: 		return "ART_INDEX";
4013: 	case MemoryTag::COLUMN_DATA:
4014: 		return "COLUMN_DATA";
4015: 	case MemoryTag::METADATA:
4016: 		return "METADATA";
4017: 	case MemoryTag::OVERFLOW_STRINGS:
4018: 		return "OVERFLOW_STRINGS";
4019: 	case MemoryTag::IN_MEMORY_TABLE:
4020: 		return "IN_MEMORY_TABLE";
4021: 	case MemoryTag::ALLOCATOR:
4022: 		return "ALLOCATOR";
4023: 	case MemoryTag::EXTENSION:
4024: 		return "EXTENSION";
4025: 	default:
4026: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4027: 	}
4028: }
4029: 
4030: template<>
4031: MemoryTag EnumUtil::FromString<MemoryTag>(const char *value) {
4032: 	if (StringUtil::Equals(value, "BASE_TABLE")) {
4033: 		return MemoryTag::BASE_TABLE;
4034: 	}
4035: 	if (StringUtil::Equals(value, "HASH_TABLE")) {
4036: 		return MemoryTag::HASH_TABLE;
4037: 	}
4038: 	if (StringUtil::Equals(value, "PARQUET_READER")) {
4039: 		return MemoryTag::PARQUET_READER;
4040: 	}
4041: 	if (StringUtil::Equals(value, "CSV_READER")) {
4042: 		return MemoryTag::CSV_READER;
4043: 	}
4044: 	if (StringUtil::Equals(value, "ORDER_BY")) {
4045: 		return MemoryTag::ORDER_BY;
4046: 	}
4047: 	if (StringUtil::Equals(value, "ART_INDEX")) {
4048: 		return MemoryTag::ART_INDEX;
4049: 	}
4050: 	if (StringUtil::Equals(value, "COLUMN_DATA")) {
4051: 		return MemoryTag::COLUMN_DATA;
4052: 	}
4053: 	if (StringUtil::Equals(value, "METADATA")) {
4054: 		return MemoryTag::METADATA;
4055: 	}
4056: 	if (StringUtil::Equals(value, "OVERFLOW_STRINGS")) {
4057: 		return MemoryTag::OVERFLOW_STRINGS;
4058: 	}
4059: 	if (StringUtil::Equals(value, "IN_MEMORY_TABLE")) {
4060: 		return MemoryTag::IN_MEMORY_TABLE;
4061: 	}
4062: 	if (StringUtil::Equals(value, "ALLOCATOR")) {
4063: 		return MemoryTag::ALLOCATOR;
4064: 	}
4065: 	if (StringUtil::Equals(value, "EXTENSION")) {
4066: 		return MemoryTag::EXTENSION;
4067: 	}
4068: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4069: }
4070: 
4071: template<>
4072: const char* EnumUtil::ToChars<NType>(NType value) {
4073: 	switch(value) {
4074: 	case NType::PREFIX:
4075: 		return "PREFIX";
4076: 	case NType::LEAF:
4077: 		return "LEAF";
4078: 	case NType::NODE_4:
4079: 		return "NODE_4";
4080: 	case NType::NODE_16:
4081: 		return "NODE_16";
4082: 	case NType::NODE_48:
4083: 		return "NODE_48";
4084: 	case NType::NODE_256:
4085: 		return "NODE_256";
4086: 	case NType::LEAF_INLINED:
4087: 		return "LEAF_INLINED";
4088: 	default:
4089: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4090: 	}
4091: }
4092: 
4093: template<>
4094: NType EnumUtil::FromString<NType>(const char *value) {
4095: 	if (StringUtil::Equals(value, "PREFIX")) {
4096: 		return NType::PREFIX;
4097: 	}
4098: 	if (StringUtil::Equals(value, "LEAF")) {
4099: 		return NType::LEAF;
4100: 	}
4101: 	if (StringUtil::Equals(value, "NODE_4")) {
4102: 		return NType::NODE_4;
4103: 	}
4104: 	if (StringUtil::Equals(value, "NODE_16")) {
4105: 		return NType::NODE_16;
4106: 	}
4107: 	if (StringUtil::Equals(value, "NODE_48")) {
4108: 		return NType::NODE_48;
4109: 	}
4110: 	if (StringUtil::Equals(value, "NODE_256")) {
4111: 		return NType::NODE_256;
4112: 	}
4113: 	if (StringUtil::Equals(value, "LEAF_INLINED")) {
4114: 		return NType::LEAF_INLINED;
4115: 	}
4116: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4117: }
4118: 
4119: template<>
4120: const char* EnumUtil::ToChars<NewLineIdentifier>(NewLineIdentifier value) {
4121: 	switch(value) {
4122: 	case NewLineIdentifier::SINGLE:
4123: 		return "SINGLE";
4124: 	case NewLineIdentifier::CARRY_ON:
4125: 		return "CARRY_ON";
4126: 	case NewLineIdentifier::NOT_SET:
4127: 		return "NOT_SET";
4128: 	default:
4129: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4130: 	}
4131: }
4132: 
4133: template<>
4134: NewLineIdentifier EnumUtil::FromString<NewLineIdentifier>(const char *value) {
4135: 	if (StringUtil::Equals(value, "SINGLE")) {
4136: 		return NewLineIdentifier::SINGLE;
4137: 	}
4138: 	if (StringUtil::Equals(value, "CARRY_ON")) {
4139: 		return NewLineIdentifier::CARRY_ON;
4140: 	}
4141: 	if (StringUtil::Equals(value, "NOT_SET")) {
4142: 		return NewLineIdentifier::NOT_SET;
4143: 	}
4144: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4145: }
4146: 
4147: template<>
4148: const char* EnumUtil::ToChars<OnConflictAction>(OnConflictAction value) {
4149: 	switch(value) {
4150: 	case OnConflictAction::THROW:
4151: 		return "THROW";
4152: 	case OnConflictAction::NOTHING:
4153: 		return "NOTHING";
4154: 	case OnConflictAction::UPDATE:
4155: 		return "UPDATE";
4156: 	case OnConflictAction::REPLACE:
4157: 		return "REPLACE";
4158: 	default:
4159: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4160: 	}
4161: }
4162: 
4163: template<>
4164: OnConflictAction EnumUtil::FromString<OnConflictAction>(const char *value) {
4165: 	if (StringUtil::Equals(value, "THROW")) {
4166: 		return OnConflictAction::THROW;
4167: 	}
4168: 	if (StringUtil::Equals(value, "NOTHING")) {
4169: 		return OnConflictAction::NOTHING;
4170: 	}
4171: 	if (StringUtil::Equals(value, "UPDATE")) {
4172: 		return OnConflictAction::UPDATE;
4173: 	}
4174: 	if (StringUtil::Equals(value, "REPLACE")) {
4175: 		return OnConflictAction::REPLACE;
4176: 	}
4177: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4178: }
4179: 
4180: template<>
4181: const char* EnumUtil::ToChars<OnCreateConflict>(OnCreateConflict value) {
4182: 	switch(value) {
4183: 	case OnCreateConflict::ERROR_ON_CONFLICT:
4184: 		return "ERROR_ON_CONFLICT";
4185: 	case OnCreateConflict::IGNORE_ON_CONFLICT:
4186: 		return "IGNORE_ON_CONFLICT";
4187: 	case OnCreateConflict::REPLACE_ON_CONFLICT:
4188: 		return "REPLACE_ON_CONFLICT";
4189: 	case OnCreateConflict::ALTER_ON_CONFLICT:
4190: 		return "ALTER_ON_CONFLICT";
4191: 	default:
4192: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4193: 	}
4194: }
4195: 
4196: template<>
4197: OnCreateConflict EnumUtil::FromString<OnCreateConflict>(const char *value) {
4198: 	if (StringUtil::Equals(value, "ERROR_ON_CONFLICT")) {
4199: 		return OnCreateConflict::ERROR_ON_CONFLICT;
4200: 	}
4201: 	if (StringUtil::Equals(value, "IGNORE_ON_CONFLICT")) {
4202: 		return OnCreateConflict::IGNORE_ON_CONFLICT;
4203: 	}
4204: 	if (StringUtil::Equals(value, "REPLACE_ON_CONFLICT")) {
4205: 		return OnCreateConflict::REPLACE_ON_CONFLICT;
4206: 	}
4207: 	if (StringUtil::Equals(value, "ALTER_ON_CONFLICT")) {
4208: 		return OnCreateConflict::ALTER_ON_CONFLICT;
4209: 	}
4210: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4211: }
4212: 
4213: template<>
4214: const char* EnumUtil::ToChars<OnEntryNotFound>(OnEntryNotFound value) {
4215: 	switch(value) {
4216: 	case OnEntryNotFound::THROW_EXCEPTION:
4217: 		return "THROW_EXCEPTION";
4218: 	case OnEntryNotFound::RETURN_NULL:
4219: 		return "RETURN_NULL";
4220: 	default:
4221: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4222: 	}
4223: }
4224: 
4225: template<>
4226: OnEntryNotFound EnumUtil::FromString<OnEntryNotFound>(const char *value) {
4227: 	if (StringUtil::Equals(value, "THROW_EXCEPTION")) {
4228: 		return OnEntryNotFound::THROW_EXCEPTION;
4229: 	}
4230: 	if (StringUtil::Equals(value, "RETURN_NULL")) {
4231: 		return OnEntryNotFound::RETURN_NULL;
4232: 	}
4233: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4234: }
4235: 
4236: template<>
4237: const char* EnumUtil::ToChars<OperatorFinalizeResultType>(OperatorFinalizeResultType value) {
4238: 	switch(value) {
4239: 	case OperatorFinalizeResultType::HAVE_MORE_OUTPUT:
4240: 		return "HAVE_MORE_OUTPUT";
4241: 	case OperatorFinalizeResultType::FINISHED:
4242: 		return "FINISHED";
4243: 	default:
4244: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4245: 	}
4246: }
4247: 
4248: template<>
4249: OperatorFinalizeResultType EnumUtil::FromString<OperatorFinalizeResultType>(const char *value) {
4250: 	if (StringUtil::Equals(value, "HAVE_MORE_OUTPUT")) {
4251: 		return OperatorFinalizeResultType::HAVE_MORE_OUTPUT;
4252: 	}
4253: 	if (StringUtil::Equals(value, "FINISHED")) {
4254: 		return OperatorFinalizeResultType::FINISHED;
4255: 	}
4256: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4257: }
4258: 
4259: template<>
4260: const char* EnumUtil::ToChars<OperatorResultType>(OperatorResultType value) {
4261: 	switch(value) {
4262: 	case OperatorResultType::NEED_MORE_INPUT:
4263: 		return "NEED_MORE_INPUT";
4264: 	case OperatorResultType::HAVE_MORE_OUTPUT:
4265: 		return "HAVE_MORE_OUTPUT";
4266: 	case OperatorResultType::FINISHED:
4267: 		return "FINISHED";
4268: 	case OperatorResultType::BLOCKED:
4269: 		return "BLOCKED";
4270: 	default:
4271: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4272: 	}
4273: }
4274: 
4275: template<>
4276: OperatorResultType EnumUtil::FromString<OperatorResultType>(const char *value) {
4277: 	if (StringUtil::Equals(value, "NEED_MORE_INPUT")) {
4278: 		return OperatorResultType::NEED_MORE_INPUT;
4279: 	}
4280: 	if (StringUtil::Equals(value, "HAVE_MORE_OUTPUT")) {
4281: 		return OperatorResultType::HAVE_MORE_OUTPUT;
4282: 	}
4283: 	if (StringUtil::Equals(value, "FINISHED")) {
4284: 		return OperatorResultType::FINISHED;
4285: 	}
4286: 	if (StringUtil::Equals(value, "BLOCKED")) {
4287: 		return OperatorResultType::BLOCKED;
4288: 	}
4289: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4290: }
4291: 
4292: template<>
4293: const char* EnumUtil::ToChars<OptimizerType>(OptimizerType value) {
4294: 	switch(value) {
4295: 	case OptimizerType::INVALID:
4296: 		return "INVALID";
4297: 	case OptimizerType::EXPRESSION_REWRITER:
4298: 		return "EXPRESSION_REWRITER";
4299: 	case OptimizerType::FILTER_PULLUP:
4300: 		return "FILTER_PULLUP";
4301: 	case OptimizerType::FILTER_PUSHDOWN:
4302: 		return "FILTER_PUSHDOWN";
4303: 	case OptimizerType::REGEX_RANGE:
4304: 		return "REGEX_RANGE";
4305: 	case OptimizerType::IN_CLAUSE:
4306: 		return "IN_CLAUSE";
4307: 	case OptimizerType::JOIN_ORDER:
4308: 		return "JOIN_ORDER";
4309: 	case OptimizerType::DELIMINATOR:
4310: 		return "DELIMINATOR";
4311: 	case OptimizerType::UNNEST_REWRITER:
4312: 		return "UNNEST_REWRITER";
4313: 	case OptimizerType::UNUSED_COLUMNS:
4314: 		return "UNUSED_COLUMNS";
4315: 	case OptimizerType::STATISTICS_PROPAGATION:
4316: 		return "STATISTICS_PROPAGATION";
4317: 	case OptimizerType::COMMON_SUBEXPRESSIONS:
4318: 		return "COMMON_SUBEXPRESSIONS";
4319: 	case OptimizerType::COMMON_AGGREGATE:
4320: 		return "COMMON_AGGREGATE";
4321: 	case OptimizerType::COLUMN_LIFETIME:
4322: 		return "COLUMN_LIFETIME";
4323: 	case OptimizerType::TOP_N:
4324: 		return "TOP_N";
4325: 	case OptimizerType::COMPRESSED_MATERIALIZATION:
4326: 		return "COMPRESSED_MATERIALIZATION";
4327: 	case OptimizerType::DUPLICATE_GROUPS:
4328: 		return "DUPLICATE_GROUPS";
4329: 	case OptimizerType::REORDER_FILTER:
4330: 		return "REORDER_FILTER";
4331: 	case OptimizerType::EXTENSION:
4332: 		return "EXTENSION";
4333: 	default:
4334: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4335: 	}
4336: }
4337: 
4338: template<>
4339: OptimizerType EnumUtil::FromString<OptimizerType>(const char *value) {
4340: 	if (StringUtil::Equals(value, "INVALID")) {
4341: 		return OptimizerType::INVALID;
4342: 	}
4343: 	if (StringUtil::Equals(value, "EXPRESSION_REWRITER")) {
4344: 		return OptimizerType::EXPRESSION_REWRITER;
4345: 	}
4346: 	if (StringUtil::Equals(value, "FILTER_PULLUP")) {
4347: 		return OptimizerType::FILTER_PULLUP;
4348: 	}
4349: 	if (StringUtil::Equals(value, "FILTER_PUSHDOWN")) {
4350: 		return OptimizerType::FILTER_PUSHDOWN;
4351: 	}
4352: 	if (StringUtil::Equals(value, "REGEX_RANGE")) {
4353: 		return OptimizerType::REGEX_RANGE;
4354: 	}
4355: 	if (StringUtil::Equals(value, "IN_CLAUSE")) {
4356: 		return OptimizerType::IN_CLAUSE;
4357: 	}
4358: 	if (StringUtil::Equals(value, "JOIN_ORDER")) {
4359: 		return OptimizerType::JOIN_ORDER;
4360: 	}
4361: 	if (StringUtil::Equals(value, "DELIMINATOR")) {
4362: 		return OptimizerType::DELIMINATOR;
4363: 	}
4364: 	if (StringUtil::Equals(value, "UNNEST_REWRITER")) {
4365: 		return OptimizerType::UNNEST_REWRITER;
4366: 	}
4367: 	if (StringUtil::Equals(value, "UNUSED_COLUMNS")) {
4368: 		return OptimizerType::UNUSED_COLUMNS;
4369: 	}
4370: 	if (StringUtil::Equals(value, "STATISTICS_PROPAGATION")) {
4371: 		return OptimizerType::STATISTICS_PROPAGATION;
4372: 	}
4373: 	if (StringUtil::Equals(value, "COMMON_SUBEXPRESSIONS")) {
4374: 		return OptimizerType::COMMON_SUBEXPRESSIONS;
4375: 	}
4376: 	if (StringUtil::Equals(value, "COMMON_AGGREGATE")) {
4377: 		return OptimizerType::COMMON_AGGREGATE;
4378: 	}
4379: 	if (StringUtil::Equals(value, "COLUMN_LIFETIME")) {
4380: 		return OptimizerType::COLUMN_LIFETIME;
4381: 	}
4382: 	if (StringUtil::Equals(value, "TOP_N")) {
4383: 		return OptimizerType::TOP_N;
4384: 	}
4385: 	if (StringUtil::Equals(value, "COMPRESSED_MATERIALIZATION")) {
4386: 		return OptimizerType::COMPRESSED_MATERIALIZATION;
4387: 	}
4388: 	if (StringUtil::Equals(value, "DUPLICATE_GROUPS")) {
4389: 		return OptimizerType::DUPLICATE_GROUPS;
4390: 	}
4391: 	if (StringUtil::Equals(value, "REORDER_FILTER")) {
4392: 		return OptimizerType::REORDER_FILTER;
4393: 	}
4394: 	if (StringUtil::Equals(value, "EXTENSION")) {
4395: 		return OptimizerType::EXTENSION;
4396: 	}
4397: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4398: }
4399: 
4400: template<>
4401: const char* EnumUtil::ToChars<OrderByNullType>(OrderByNullType value) {
4402: 	switch(value) {
4403: 	case OrderByNullType::INVALID:
4404: 		return "INVALID";
4405: 	case OrderByNullType::ORDER_DEFAULT:
4406: 		return "ORDER_DEFAULT";
4407: 	case OrderByNullType::NULLS_FIRST:
4408: 		return "NULLS_FIRST";
4409: 	case OrderByNullType::NULLS_LAST:
4410: 		return "NULLS_LAST";
4411: 	default:
4412: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4413: 	}
4414: }
4415: 
4416: template<>
4417: OrderByNullType EnumUtil::FromString<OrderByNullType>(const char *value) {
4418: 	if (StringUtil::Equals(value, "INVALID")) {
4419: 		return OrderByNullType::INVALID;
4420: 	}
4421: 	if (StringUtil::Equals(value, "ORDER_DEFAULT") || StringUtil::Equals(value, "DEFAULT")) {
4422: 		return OrderByNullType::ORDER_DEFAULT;
4423: 	}
4424: 	if (StringUtil::Equals(value, "NULLS_FIRST") || StringUtil::Equals(value, "NULLS FIRST")) {
4425: 		return OrderByNullType::NULLS_FIRST;
4426: 	}
4427: 	if (StringUtil::Equals(value, "NULLS_LAST") || StringUtil::Equals(value, "NULLS LAST")) {
4428: 		return OrderByNullType::NULLS_LAST;
4429: 	}
4430: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4431: }
4432: 
4433: template<>
4434: const char* EnumUtil::ToChars<OrderPreservationType>(OrderPreservationType value) {
4435: 	switch(value) {
4436: 	case OrderPreservationType::NO_ORDER:
4437: 		return "NO_ORDER";
4438: 	case OrderPreservationType::INSERTION_ORDER:
4439: 		return "INSERTION_ORDER";
4440: 	case OrderPreservationType::FIXED_ORDER:
4441: 		return "FIXED_ORDER";
4442: 	default:
4443: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4444: 	}
4445: }
4446: 
4447: template<>
4448: OrderPreservationType EnumUtil::FromString<OrderPreservationType>(const char *value) {
4449: 	if (StringUtil::Equals(value, "NO_ORDER")) {
4450: 		return OrderPreservationType::NO_ORDER;
4451: 	}
4452: 	if (StringUtil::Equals(value, "INSERTION_ORDER")) {
4453: 		return OrderPreservationType::INSERTION_ORDER;
4454: 	}
4455: 	if (StringUtil::Equals(value, "FIXED_ORDER")) {
4456: 		return OrderPreservationType::FIXED_ORDER;
4457: 	}
4458: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4459: }
4460: 
4461: template<>
4462: const char* EnumUtil::ToChars<OrderType>(OrderType value) {
4463: 	switch(value) {
4464: 	case OrderType::INVALID:
4465: 		return "INVALID";
4466: 	case OrderType::ORDER_DEFAULT:
4467: 		return "ORDER_DEFAULT";
4468: 	case OrderType::ASCENDING:
4469: 		return "ASCENDING";
4470: 	case OrderType::DESCENDING:
4471: 		return "DESCENDING";
4472: 	default:
4473: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4474: 	}
4475: }
4476: 
4477: template<>
4478: OrderType EnumUtil::FromString<OrderType>(const char *value) {
4479: 	if (StringUtil::Equals(value, "INVALID")) {
4480: 		return OrderType::INVALID;
4481: 	}
4482: 	if (StringUtil::Equals(value, "ORDER_DEFAULT") || StringUtil::Equals(value, "DEFAULT")) {
4483: 		return OrderType::ORDER_DEFAULT;
4484: 	}
4485: 	if (StringUtil::Equals(value, "ASCENDING") || StringUtil::Equals(value, "ASC")) {
4486: 		return OrderType::ASCENDING;
4487: 	}
4488: 	if (StringUtil::Equals(value, "DESCENDING") || StringUtil::Equals(value, "DESC")) {
4489: 		return OrderType::DESCENDING;
4490: 	}
4491: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4492: }
4493: 
4494: template<>
4495: const char* EnumUtil::ToChars<OutputStream>(OutputStream value) {
4496: 	switch(value) {
4497: 	case OutputStream::STREAM_STDOUT:
4498: 		return "STREAM_STDOUT";
4499: 	case OutputStream::STREAM_STDERR:
4500: 		return "STREAM_STDERR";
4501: 	default:
4502: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4503: 	}
4504: }
4505: 
4506: template<>
4507: OutputStream EnumUtil::FromString<OutputStream>(const char *value) {
4508: 	if (StringUtil::Equals(value, "STREAM_STDOUT")) {
4509: 		return OutputStream::STREAM_STDOUT;
4510: 	}
4511: 	if (StringUtil::Equals(value, "STREAM_STDERR")) {
4512: 		return OutputStream::STREAM_STDERR;
4513: 	}
4514: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4515: }
4516: 
4517: template<>
4518: const char* EnumUtil::ToChars<ParseInfoType>(ParseInfoType value) {
4519: 	switch(value) {
4520: 	case ParseInfoType::ALTER_INFO:
4521: 		return "ALTER_INFO";
4522: 	case ParseInfoType::ATTACH_INFO:
4523: 		return "ATTACH_INFO";
4524: 	case ParseInfoType::COPY_INFO:
4525: 		return "COPY_INFO";
4526: 	case ParseInfoType::CREATE_INFO:
4527: 		return "CREATE_INFO";
4528: 	case ParseInfoType::CREATE_SECRET_INFO:
4529: 		return "CREATE_SECRET_INFO";
4530: 	case ParseInfoType::DETACH_INFO:
4531: 		return "DETACH_INFO";
4532: 	case ParseInfoType::DROP_INFO:
4533: 		return "DROP_INFO";
4534: 	case ParseInfoType::BOUND_EXPORT_DATA:
4535: 		return "BOUND_EXPORT_DATA";
4536: 	case ParseInfoType::LOAD_INFO:
4537: 		return "LOAD_INFO";
4538: 	case ParseInfoType::PRAGMA_INFO:
4539: 		return "PRAGMA_INFO";
4540: 	case ParseInfoType::SHOW_SELECT_INFO:
4541: 		return "SHOW_SELECT_INFO";
4542: 	case ParseInfoType::TRANSACTION_INFO:
4543: 		return "TRANSACTION_INFO";
4544: 	case ParseInfoType::VACUUM_INFO:
4545: 		return "VACUUM_INFO";
4546: 	case ParseInfoType::COMMENT_ON_INFO:
4547: 		return "COMMENT_ON_INFO";
4548: 	case ParseInfoType::COMMENT_ON_COLUMN_INFO:
4549: 		return "COMMENT_ON_COLUMN_INFO";
4550: 	case ParseInfoType::COPY_DATABASE_INFO:
4551: 		return "COPY_DATABASE_INFO";
4552: 	case ParseInfoType::UPDATE_EXTENSIONS_INFO:
4553: 		return "UPDATE_EXTENSIONS_INFO";
4554: 	default:
4555: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4556: 	}
4557: }
4558: 
4559: template<>
4560: ParseInfoType EnumUtil::FromString<ParseInfoType>(const char *value) {
4561: 	if (StringUtil::Equals(value, "ALTER_INFO")) {
4562: 		return ParseInfoType::ALTER_INFO;
4563: 	}
4564: 	if (StringUtil::Equals(value, "ATTACH_INFO")) {
4565: 		return ParseInfoType::ATTACH_INFO;
4566: 	}
4567: 	if (StringUtil::Equals(value, "COPY_INFO")) {
4568: 		return ParseInfoType::COPY_INFO;
4569: 	}
4570: 	if (StringUtil::Equals(value, "CREATE_INFO")) {
4571: 		return ParseInfoType::CREATE_INFO;
4572: 	}
4573: 	if (StringUtil::Equals(value, "CREATE_SECRET_INFO")) {
4574: 		return ParseInfoType::CREATE_SECRET_INFO;
4575: 	}
4576: 	if (StringUtil::Equals(value, "DETACH_INFO")) {
4577: 		return ParseInfoType::DETACH_INFO;
4578: 	}
4579: 	if (StringUtil::Equals(value, "DROP_INFO")) {
4580: 		return ParseInfoType::DROP_INFO;
4581: 	}
4582: 	if (StringUtil::Equals(value, "BOUND_EXPORT_DATA")) {
4583: 		return ParseInfoType::BOUND_EXPORT_DATA;
4584: 	}
4585: 	if (StringUtil::Equals(value, "LOAD_INFO")) {
4586: 		return ParseInfoType::LOAD_INFO;
4587: 	}
4588: 	if (StringUtil::Equals(value, "PRAGMA_INFO")) {
4589: 		return ParseInfoType::PRAGMA_INFO;
4590: 	}
4591: 	if (StringUtil::Equals(value, "SHOW_SELECT_INFO")) {
4592: 		return ParseInfoType::SHOW_SELECT_INFO;
4593: 	}
4594: 	if (StringUtil::Equals(value, "TRANSACTION_INFO")) {
4595: 		return ParseInfoType::TRANSACTION_INFO;
4596: 	}
4597: 	if (StringUtil::Equals(value, "VACUUM_INFO")) {
4598: 		return ParseInfoType::VACUUM_INFO;
4599: 	}
4600: 	if (StringUtil::Equals(value, "COMMENT_ON_INFO")) {
4601: 		return ParseInfoType::COMMENT_ON_INFO;
4602: 	}
4603: 	if (StringUtil::Equals(value, "COMMENT_ON_COLUMN_INFO")) {
4604: 		return ParseInfoType::COMMENT_ON_COLUMN_INFO;
4605: 	}
4606: 	if (StringUtil::Equals(value, "COPY_DATABASE_INFO")) {
4607: 		return ParseInfoType::COPY_DATABASE_INFO;
4608: 	}
4609: 	if (StringUtil::Equals(value, "UPDATE_EXTENSIONS_INFO")) {
4610: 		return ParseInfoType::UPDATE_EXTENSIONS_INFO;
4611: 	}
4612: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4613: }
4614: 
4615: template<>
4616: const char* EnumUtil::ToChars<ParserExtensionResultType>(ParserExtensionResultType value) {
4617: 	switch(value) {
4618: 	case ParserExtensionResultType::PARSE_SUCCESSFUL:
4619: 		return "PARSE_SUCCESSFUL";
4620: 	case ParserExtensionResultType::DISPLAY_ORIGINAL_ERROR:
4621: 		return "DISPLAY_ORIGINAL_ERROR";
4622: 	case ParserExtensionResultType::DISPLAY_EXTENSION_ERROR:
4623: 		return "DISPLAY_EXTENSION_ERROR";
4624: 	default:
4625: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4626: 	}
4627: }
4628: 
4629: template<>
4630: ParserExtensionResultType EnumUtil::FromString<ParserExtensionResultType>(const char *value) {
4631: 	if (StringUtil::Equals(value, "PARSE_SUCCESSFUL")) {
4632: 		return ParserExtensionResultType::PARSE_SUCCESSFUL;
4633: 	}
4634: 	if (StringUtil::Equals(value, "DISPLAY_ORIGINAL_ERROR")) {
4635: 		return ParserExtensionResultType::DISPLAY_ORIGINAL_ERROR;
4636: 	}
4637: 	if (StringUtil::Equals(value, "DISPLAY_EXTENSION_ERROR")) {
4638: 		return ParserExtensionResultType::DISPLAY_EXTENSION_ERROR;
4639: 	}
4640: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4641: }
4642: 
4643: template<>
4644: const char* EnumUtil::ToChars<PartitionSortStage>(PartitionSortStage value) {
4645: 	switch(value) {
4646: 	case PartitionSortStage::INIT:
4647: 		return "INIT";
4648: 	case PartitionSortStage::SCAN:
4649: 		return "SCAN";
4650: 	case PartitionSortStage::PREPARE:
4651: 		return "PREPARE";
4652: 	case PartitionSortStage::MERGE:
4653: 		return "MERGE";
4654: 	case PartitionSortStage::SORTED:
4655: 		return "SORTED";
4656: 	default:
4657: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4658: 	}
4659: }
4660: 
4661: template<>
4662: PartitionSortStage EnumUtil::FromString<PartitionSortStage>(const char *value) {
4663: 	if (StringUtil::Equals(value, "INIT")) {
4664: 		return PartitionSortStage::INIT;
4665: 	}
4666: 	if (StringUtil::Equals(value, "SCAN")) {
4667: 		return PartitionSortStage::SCAN;
4668: 	}
4669: 	if (StringUtil::Equals(value, "PREPARE")) {
4670: 		return PartitionSortStage::PREPARE;
4671: 	}
4672: 	if (StringUtil::Equals(value, "MERGE")) {
4673: 		return PartitionSortStage::MERGE;
4674: 	}
4675: 	if (StringUtil::Equals(value, "SORTED")) {
4676: 		return PartitionSortStage::SORTED;
4677: 	}
4678: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4679: }
4680: 
4681: template<>
4682: const char* EnumUtil::ToChars<PartitionedColumnDataType>(PartitionedColumnDataType value) {
4683: 	switch(value) {
4684: 	case PartitionedColumnDataType::INVALID:
4685: 		return "INVALID";
4686: 	case PartitionedColumnDataType::RADIX:
4687: 		return "RADIX";
4688: 	case PartitionedColumnDataType::HIVE:
4689: 		return "HIVE";
4690: 	default:
4691: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4692: 	}
4693: }
4694: 
4695: template<>
4696: PartitionedColumnDataType EnumUtil::FromString<PartitionedColumnDataType>(const char *value) {
4697: 	if (StringUtil::Equals(value, "INVALID")) {
4698: 		return PartitionedColumnDataType::INVALID;
4699: 	}
4700: 	if (StringUtil::Equals(value, "RADIX")) {
4701: 		return PartitionedColumnDataType::RADIX;
4702: 	}
4703: 	if (StringUtil::Equals(value, "HIVE")) {
4704: 		return PartitionedColumnDataType::HIVE;
4705: 	}
4706: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4707: }
4708: 
4709: template<>
4710: const char* EnumUtil::ToChars<PartitionedTupleDataType>(PartitionedTupleDataType value) {
4711: 	switch(value) {
4712: 	case PartitionedTupleDataType::INVALID:
4713: 		return "INVALID";
4714: 	case PartitionedTupleDataType::RADIX:
4715: 		return "RADIX";
4716: 	default:
4717: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4718: 	}
4719: }
4720: 
4721: template<>
4722: PartitionedTupleDataType EnumUtil::FromString<PartitionedTupleDataType>(const char *value) {
4723: 	if (StringUtil::Equals(value, "INVALID")) {
4724: 		return PartitionedTupleDataType::INVALID;
4725: 	}
4726: 	if (StringUtil::Equals(value, "RADIX")) {
4727: 		return PartitionedTupleDataType::RADIX;
4728: 	}
4729: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4730: }
4731: 
4732: template<>
4733: const char* EnumUtil::ToChars<PendingExecutionResult>(PendingExecutionResult value) {
4734: 	switch(value) {
4735: 	case PendingExecutionResult::RESULT_READY:
4736: 		return "RESULT_READY";
4737: 	case PendingExecutionResult::RESULT_NOT_READY:
4738: 		return "RESULT_NOT_READY";
4739: 	case PendingExecutionResult::EXECUTION_ERROR:
4740: 		return "EXECUTION_ERROR";
4741: 	case PendingExecutionResult::BLOCKED:
4742: 		return "BLOCKED";
4743: 	case PendingExecutionResult::NO_TASKS_AVAILABLE:
4744: 		return "NO_TASKS_AVAILABLE";
4745: 	default:
4746: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4747: 	}
4748: }
4749: 
4750: template<>
4751: PendingExecutionResult EnumUtil::FromString<PendingExecutionResult>(const char *value) {
4752: 	if (StringUtil::Equals(value, "RESULT_READY")) {
4753: 		return PendingExecutionResult::RESULT_READY;
4754: 	}
4755: 	if (StringUtil::Equals(value, "RESULT_NOT_READY")) {
4756: 		return PendingExecutionResult::RESULT_NOT_READY;
4757: 	}
4758: 	if (StringUtil::Equals(value, "EXECUTION_ERROR")) {
4759: 		return PendingExecutionResult::EXECUTION_ERROR;
4760: 	}
4761: 	if (StringUtil::Equals(value, "BLOCKED")) {
4762: 		return PendingExecutionResult::BLOCKED;
4763: 	}
4764: 	if (StringUtil::Equals(value, "NO_TASKS_AVAILABLE")) {
4765: 		return PendingExecutionResult::NO_TASKS_AVAILABLE;
4766: 	}
4767: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
4768: }
4769: 
4770: template<>
4771: const char* EnumUtil::ToChars<PhysicalOperatorType>(PhysicalOperatorType value) {
4772: 	switch(value) {
4773: 	case PhysicalOperatorType::INVALID:
4774: 		return "INVALID";
4775: 	case PhysicalOperatorType::ORDER_BY:
4776: 		return "ORDER_BY";
4777: 	case PhysicalOperatorType::LIMIT:
4778: 		return "LIMIT";
4779: 	case PhysicalOperatorType::STREAMING_LIMIT:
4780: 		return "STREAMING_LIMIT";
4781: 	case PhysicalOperatorType::LIMIT_PERCENT:
4782: 		return "LIMIT_PERCENT";
4783: 	case PhysicalOperatorType::TOP_N:
4784: 		return "TOP_N";
4785: 	case PhysicalOperatorType::WINDOW:
4786: 		return "WINDOW";
4787: 	case PhysicalOperatorType::UNNEST:
4788: 		return "UNNEST";
4789: 	case PhysicalOperatorType::UNGROUPED_AGGREGATE:
4790: 		return "UNGROUPED_AGGREGATE";
4791: 	case PhysicalOperatorType::HASH_GROUP_BY:
4792: 		return "HASH_GROUP_BY";
4793: 	case PhysicalOperatorType::PERFECT_HASH_GROUP_BY:
4794: 		return "PERFECT_HASH_GROUP_BY";
4795: 	case PhysicalOperatorType::FILTER:
4796: 		return "FILTER";
4797: 	case PhysicalOperatorType::PROJECTION:
4798: 		return "PROJECTION";
4799: 	case PhysicalOperatorType::COPY_TO_FILE:
4800: 		return "COPY_TO_FILE";
4801: 	case PhysicalOperatorType::BATCH_COPY_TO_FILE:
4802: 		return "BATCH_COPY_TO_FILE";
4803: 	case PhysicalOperatorType::RESERVOIR_SAMPLE:
4804: 		return "RESERVOIR_SAMPLE";
4805: 	case PhysicalOperatorType::STREAMING_SAMPLE:
4806: 		return "STREAMING_SAMPLE";
4807: 	case PhysicalOperatorType::STREAMING_WINDOW:
4808: 		return "STREAMING_WINDOW";
4809: 	case PhysicalOperatorType::PIVOT:
4810: 		return "PIVOT";
4811: 	case PhysicalOperatorType::COPY_DATABASE:
4812: 		return "COPY_DATABASE";
4813: 	case PhysicalOperatorType::TABLE_SCAN:
4814: 		return "TABLE_SCAN";
4815: 	case PhysicalOperatorType::DUMMY_SCAN:
4816: 		return "DUMMY_SCAN";
4817: 	case PhysicalOperatorType::COLUMN_DATA_SCAN:
4818: 		return "COLUMN_DATA_SCAN";
4819: 	case PhysicalOperatorType::CHUNK_SCAN:
4820: 		return "CHUNK_SCAN";
4821: 	case PhysicalOperatorType::RECURSIVE_CTE_SCAN:
4822: 		return "RECURSIVE_CTE_SCAN";
4823: 	case PhysicalOperatorType::CTE_SCAN:
4824: 		return "CTE_SCAN";
4825: 	case PhysicalOperatorType::DELIM_SCAN:
4826: 		return "DELIM_SCAN";
4827: 	case PhysicalOperatorType::EXPRESSION_SCAN:
4828: 		return "EXPRESSION_SCAN";
4829: 	case PhysicalOperatorType::POSITIONAL_SCAN:
4830: 		return "POSITIONAL_SCAN";
4831: 	case PhysicalOperatorType::BLOCKWISE_NL_JOIN:
4832: 		return "BLOCKWISE_NL_JOIN";
4833: 	case PhysicalOperatorType::NESTED_LOOP_JOIN:
4834: 		return "NESTED_LOOP_JOIN";
4835: 	case PhysicalOperatorType::HASH_JOIN:
4836: 		return "HASH_JOIN";
4837: 	case PhysicalOperatorType::CROSS_PRODUCT:
4838: 		return "CROSS_PRODUCT";
4839: 	case PhysicalOperatorType::PIECEWISE_MERGE_JOIN:
4840: 		return "PIECEWISE_MERGE_JOIN";
4841: 	case PhysicalOperatorType::IE_JOIN:
4842: 		return "IE_JOIN";
4843: 	case PhysicalOperatorType::LEFT_DELIM_JOIN:
4844: 		return "LEFT_DELIM_JOIN";
4845: 	case PhysicalOperatorType::RIGHT_DELIM_JOIN:
4846: 		return "RIGHT_DELIM_JOIN";
4847: 	case PhysicalOperatorType::POSITIONAL_JOIN:
4848: 		return "POSITIONAL_JOIN";
4849: 	case PhysicalOperatorType::ASOF_JOIN:
4850: 		return "ASOF_JOIN";
4851: 	case PhysicalOperatorType::UNION:
4852: 		return "UNION";
4853: 	case PhysicalOperatorType::RECURSIVE_CTE:
4854: 		return "RECURSIVE_CTE";
4855: 	case PhysicalOperatorType::CTE:
4856: 		return "CTE";
4857: 	case PhysicalOperatorType::INSERT:
4858: 		return "INSERT";
4859: 	case PhysicalOperatorType::BATCH_INSERT:
4860: 		return "BATCH_INSERT";
4861: 	case PhysicalOperatorType::DELETE_OPERATOR:
4862: 		return "DELETE_OPERATOR";
4863: 	case PhysicalOperatorType::UPDATE:
4864: 		return "UPDATE";
4865: 	case PhysicalOperatorType::CREATE_TABLE:
4866: 		return "CREATE_TABLE";
4867: 	case PhysicalOperatorType::CREATE_TABLE_AS:
4868: 		return "CREATE_TABLE_AS";
4869: 	case PhysicalOperatorType::BATCH_CREATE_TABLE_AS:
4870: 		return "BATCH_CREATE_TABLE_AS";
4871: 	case PhysicalOperatorType::CREATE_INDEX:
4872: 		return "CREATE_INDEX";
4873: 	case PhysicalOperatorType::ALTER:
4874: 		return "ALTER";
4875: 	case PhysicalOperatorType::CREATE_SEQUENCE:
4876: 		return "CREATE_SEQUENCE";
4877: 	case PhysicalOperatorType::CREATE_VIEW:
4878: 		return "CREATE_VIEW";
4879: 	case PhysicalOperatorType::CREATE_SCHEMA:
4880: 		return "CREATE_SCHEMA";
4881: 	case PhysicalOperatorType::CREATE_MACRO:
4882: 		return "CREATE_MACRO";
4883: 	case PhysicalOperatorType::DROP:
4884: 		return "DROP";
4885: 	case PhysicalOperatorType::PRAGMA:
4886: 		return "PRAGMA";
4887: 	case PhysicalOperatorType::TRANSACTION:
4888: 		return "TRANSACTION";
4889: 	case PhysicalOperatorType::CREATE_TYPE:
4890: 		return "CREATE_TYPE";
4891: 	case PhysicalOperatorType::ATTACH:
4892: 		return "ATTACH";
4893: 	case PhysicalOperatorType::DETACH:
4894: 		return "DETACH";
4895: 	case PhysicalOperatorType::EXPLAIN:
4896: 		return "EXPLAIN";
4897: 	case PhysicalOperatorType::EXPLAIN_ANALYZE:
4898: 		return "EXPLAIN_ANALYZE";
4899: 	case PhysicalOperatorType::EMPTY_RESULT:
4900: 		return "EMPTY_RESULT";
4901: 	case PhysicalOperatorType::EXECUTE:
4902: 		return "EXECUTE";
4903: 	case PhysicalOperatorType::PREPARE:
4904: 		return "PREPARE";
4905: 	case PhysicalOperatorType::VACUUM:
4906: 		return "VACUUM";
4907: 	case PhysicalOperatorType::EXPORT:
4908: 		return "EXPORT";
4909: 	case PhysicalOperatorType::SET:
4910: 		return "SET";
4911: 	case PhysicalOperatorType::LOAD:
4912: 		return "LOAD";
4913: 	case PhysicalOperatorType::INOUT_FUNCTION:
4914: 		return "INOUT_FUNCTION";
4915: 	case PhysicalOperatorType::RESULT_COLLECTOR:
4916: 		return "RESULT_COLLECTOR";
4917: 	case PhysicalOperatorType::RESET:
4918: 		return "RESET";
4919: 	case PhysicalOperatorType::EXTENSION:
4920: 		return "EXTENSION";
4921: 	case PhysicalOperatorType::VERIFY_VECTOR:
4922: 		return "VERIFY_VECTOR";
4923: 	case PhysicalOperatorType::UPDATE_EXTENSIONS:
4924: 		return "UPDATE_EXTENSIONS";
4925: 	case PhysicalOperatorType::CREATE_SECRET:
4926: 		return "CREATE_SECRET";
4927: 	default:
4928: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
4929: 	}
4930: }
4931: 
4932: template<>
4933: PhysicalOperatorType EnumUtil::FromString<PhysicalOperatorType>(const char *value) {
4934: 	if (StringUtil::Equals(value, "INVALID")) {
4935: 		return PhysicalOperatorType::INVALID;
4936: 	}
4937: 	if (StringUtil::Equals(value, "ORDER_BY")) {
4938: 		return PhysicalOperatorType::ORDER_BY;
4939: 	}
4940: 	if (StringUtil::Equals(value, "LIMIT")) {
4941: 		return PhysicalOperatorType::LIMIT;
4942: 	}
4943: 	if (StringUtil::Equals(value, "STREAMING_LIMIT")) {
4944: 		return PhysicalOperatorType::STREAMING_LIMIT;
4945: 	}
4946: 	if (StringUtil::Equals(value, "LIMIT_PERCENT")) {
4947: 		return PhysicalOperatorType::LIMIT_PERCENT;
4948: 	}
4949: 	if (StringUtil::Equals(value, "TOP_N")) {
4950: 		return PhysicalOperatorType::TOP_N;
4951: 	}
4952: 	if (StringUtil::Equals(value, "WINDOW")) {
4953: 		return PhysicalOperatorType::WINDOW;
4954: 	}
4955: 	if (StringUtil::Equals(value, "UNNEST")) {
4956: 		return PhysicalOperatorType::UNNEST;
4957: 	}
4958: 	if (StringUtil::Equals(value, "UNGROUPED_AGGREGATE")) {
4959: 		return PhysicalOperatorType::UNGROUPED_AGGREGATE;
4960: 	}
4961: 	if (StringUtil::Equals(value, "HASH_GROUP_BY")) {
4962: 		return PhysicalOperatorType::HASH_GROUP_BY;
4963: 	}
4964: 	if (StringUtil::Equals(value, "PERFECT_HASH_GROUP_BY")) {
4965: 		return PhysicalOperatorType::PERFECT_HASH_GROUP_BY;
4966: 	}
4967: 	if (StringUtil::Equals(value, "FILTER")) {
4968: 		return PhysicalOperatorType::FILTER;
4969: 	}
4970: 	if (StringUtil::Equals(value, "PROJECTION")) {
4971: 		return PhysicalOperatorType::PROJECTION;
4972: 	}
4973: 	if (StringUtil::Equals(value, "COPY_TO_FILE")) {
4974: 		return PhysicalOperatorType::COPY_TO_FILE;
4975: 	}
4976: 	if (StringUtil::Equals(value, "BATCH_COPY_TO_FILE")) {
4977: 		return PhysicalOperatorType::BATCH_COPY_TO_FILE;
4978: 	}
4979: 	if (StringUtil::Equals(value, "RESERVOIR_SAMPLE")) {
4980: 		return PhysicalOperatorType::RESERVOIR_SAMPLE;
4981: 	}
4982: 	if (StringUtil::Equals(value, "STREAMING_SAMPLE")) {
4983: 		return PhysicalOperatorType::STREAMING_SAMPLE;
4984: 	}
4985: 	if (StringUtil::Equals(value, "STREAMING_WINDOW")) {
4986: 		return PhysicalOperatorType::STREAMING_WINDOW;
4987: 	}
4988: 	if (StringUtil::Equals(value, "PIVOT")) {
4989: 		return PhysicalOperatorType::PIVOT;
4990: 	}
4991: 	if (StringUtil::Equals(value, "COPY_DATABASE")) {
4992: 		return PhysicalOperatorType::COPY_DATABASE;
4993: 	}
4994: 	if (StringUtil::Equals(value, "TABLE_SCAN")) {
4995: 		return PhysicalOperatorType::TABLE_SCAN;
4996: 	}
4997: 	if (StringUtil::Equals(value, "DUMMY_SCAN")) {
4998: 		return PhysicalOperatorType::DUMMY_SCAN;
4999: 	}
5000: 	if (StringUtil::Equals(value, "COLUMN_DATA_SCAN")) {
5001: 		return PhysicalOperatorType::COLUMN_DATA_SCAN;
5002: 	}
5003: 	if (StringUtil::Equals(value, "CHUNK_SCAN")) {
5004: 		return PhysicalOperatorType::CHUNK_SCAN;
5005: 	}
5006: 	if (StringUtil::Equals(value, "RECURSIVE_CTE_SCAN")) {
5007: 		return PhysicalOperatorType::RECURSIVE_CTE_SCAN;
5008: 	}
5009: 	if (StringUtil::Equals(value, "CTE_SCAN")) {
5010: 		return PhysicalOperatorType::CTE_SCAN;
5011: 	}
5012: 	if (StringUtil::Equals(value, "DELIM_SCAN")) {
5013: 		return PhysicalOperatorType::DELIM_SCAN;
5014: 	}
5015: 	if (StringUtil::Equals(value, "EXPRESSION_SCAN")) {
5016: 		return PhysicalOperatorType::EXPRESSION_SCAN;
5017: 	}
5018: 	if (StringUtil::Equals(value, "POSITIONAL_SCAN")) {
5019: 		return PhysicalOperatorType::POSITIONAL_SCAN;
5020: 	}
5021: 	if (StringUtil::Equals(value, "BLOCKWISE_NL_JOIN")) {
5022: 		return PhysicalOperatorType::BLOCKWISE_NL_JOIN;
5023: 	}
5024: 	if (StringUtil::Equals(value, "NESTED_LOOP_JOIN")) {
5025: 		return PhysicalOperatorType::NESTED_LOOP_JOIN;
5026: 	}
5027: 	if (StringUtil::Equals(value, "HASH_JOIN")) {
5028: 		return PhysicalOperatorType::HASH_JOIN;
5029: 	}
5030: 	if (StringUtil::Equals(value, "CROSS_PRODUCT")) {
5031: 		return PhysicalOperatorType::CROSS_PRODUCT;
5032: 	}
5033: 	if (StringUtil::Equals(value, "PIECEWISE_MERGE_JOIN")) {
5034: 		return PhysicalOperatorType::PIECEWISE_MERGE_JOIN;
5035: 	}
5036: 	if (StringUtil::Equals(value, "IE_JOIN")) {
5037: 		return PhysicalOperatorType::IE_JOIN;
5038: 	}
5039: 	if (StringUtil::Equals(value, "LEFT_DELIM_JOIN")) {
5040: 		return PhysicalOperatorType::LEFT_DELIM_JOIN;
5041: 	}
5042: 	if (StringUtil::Equals(value, "RIGHT_DELIM_JOIN")) {
5043: 		return PhysicalOperatorType::RIGHT_DELIM_JOIN;
5044: 	}
5045: 	if (StringUtil::Equals(value, "POSITIONAL_JOIN")) {
5046: 		return PhysicalOperatorType::POSITIONAL_JOIN;
5047: 	}
5048: 	if (StringUtil::Equals(value, "ASOF_JOIN")) {
5049: 		return PhysicalOperatorType::ASOF_JOIN;
5050: 	}
5051: 	if (StringUtil::Equals(value, "UNION")) {
5052: 		return PhysicalOperatorType::UNION;
5053: 	}
5054: 	if (StringUtil::Equals(value, "RECURSIVE_CTE")) {
5055: 		return PhysicalOperatorType::RECURSIVE_CTE;
5056: 	}
5057: 	if (StringUtil::Equals(value, "CTE")) {
5058: 		return PhysicalOperatorType::CTE;
5059: 	}
5060: 	if (StringUtil::Equals(value, "INSERT")) {
5061: 		return PhysicalOperatorType::INSERT;
5062: 	}
5063: 	if (StringUtil::Equals(value, "BATCH_INSERT")) {
5064: 		return PhysicalOperatorType::BATCH_INSERT;
5065: 	}
5066: 	if (StringUtil::Equals(value, "DELETE_OPERATOR")) {
5067: 		return PhysicalOperatorType::DELETE_OPERATOR;
5068: 	}
5069: 	if (StringUtil::Equals(value, "UPDATE")) {
5070: 		return PhysicalOperatorType::UPDATE;
5071: 	}
5072: 	if (StringUtil::Equals(value, "CREATE_TABLE")) {
5073: 		return PhysicalOperatorType::CREATE_TABLE;
5074: 	}
5075: 	if (StringUtil::Equals(value, "CREATE_TABLE_AS")) {
5076: 		return PhysicalOperatorType::CREATE_TABLE_AS;
5077: 	}
5078: 	if (StringUtil::Equals(value, "BATCH_CREATE_TABLE_AS")) {
5079: 		return PhysicalOperatorType::BATCH_CREATE_TABLE_AS;
5080: 	}
5081: 	if (StringUtil::Equals(value, "CREATE_INDEX")) {
5082: 		return PhysicalOperatorType::CREATE_INDEX;
5083: 	}
5084: 	if (StringUtil::Equals(value, "ALTER")) {
5085: 		return PhysicalOperatorType::ALTER;
5086: 	}
5087: 	if (StringUtil::Equals(value, "CREATE_SEQUENCE")) {
5088: 		return PhysicalOperatorType::CREATE_SEQUENCE;
5089: 	}
5090: 	if (StringUtil::Equals(value, "CREATE_VIEW")) {
5091: 		return PhysicalOperatorType::CREATE_VIEW;
5092: 	}
5093: 	if (StringUtil::Equals(value, "CREATE_SCHEMA")) {
5094: 		return PhysicalOperatorType::CREATE_SCHEMA;
5095: 	}
5096: 	if (StringUtil::Equals(value, "CREATE_MACRO")) {
5097: 		return PhysicalOperatorType::CREATE_MACRO;
5098: 	}
5099: 	if (StringUtil::Equals(value, "DROP")) {
5100: 		return PhysicalOperatorType::DROP;
5101: 	}
5102: 	if (StringUtil::Equals(value, "PRAGMA")) {
5103: 		return PhysicalOperatorType::PRAGMA;
5104: 	}
5105: 	if (StringUtil::Equals(value, "TRANSACTION")) {
5106: 		return PhysicalOperatorType::TRANSACTION;
5107: 	}
5108: 	if (StringUtil::Equals(value, "CREATE_TYPE")) {
5109: 		return PhysicalOperatorType::CREATE_TYPE;
5110: 	}
5111: 	if (StringUtil::Equals(value, "ATTACH")) {
5112: 		return PhysicalOperatorType::ATTACH;
5113: 	}
5114: 	if (StringUtil::Equals(value, "DETACH")) {
5115: 		return PhysicalOperatorType::DETACH;
5116: 	}
5117: 	if (StringUtil::Equals(value, "EXPLAIN")) {
5118: 		return PhysicalOperatorType::EXPLAIN;
5119: 	}
5120: 	if (StringUtil::Equals(value, "EXPLAIN_ANALYZE")) {
5121: 		return PhysicalOperatorType::EXPLAIN_ANALYZE;
5122: 	}
5123: 	if (StringUtil::Equals(value, "EMPTY_RESULT")) {
5124: 		return PhysicalOperatorType::EMPTY_RESULT;
5125: 	}
5126: 	if (StringUtil::Equals(value, "EXECUTE")) {
5127: 		return PhysicalOperatorType::EXECUTE;
5128: 	}
5129: 	if (StringUtil::Equals(value, "PREPARE")) {
5130: 		return PhysicalOperatorType::PREPARE;
5131: 	}
5132: 	if (StringUtil::Equals(value, "VACUUM")) {
5133: 		return PhysicalOperatorType::VACUUM;
5134: 	}
5135: 	if (StringUtil::Equals(value, "EXPORT")) {
5136: 		return PhysicalOperatorType::EXPORT;
5137: 	}
5138: 	if (StringUtil::Equals(value, "SET")) {
5139: 		return PhysicalOperatorType::SET;
5140: 	}
5141: 	if (StringUtil::Equals(value, "LOAD")) {
5142: 		return PhysicalOperatorType::LOAD;
5143: 	}
5144: 	if (StringUtil::Equals(value, "INOUT_FUNCTION")) {
5145: 		return PhysicalOperatorType::INOUT_FUNCTION;
5146: 	}
5147: 	if (StringUtil::Equals(value, "RESULT_COLLECTOR")) {
5148: 		return PhysicalOperatorType::RESULT_COLLECTOR;
5149: 	}
5150: 	if (StringUtil::Equals(value, "RESET")) {
5151: 		return PhysicalOperatorType::RESET;
5152: 	}
5153: 	if (StringUtil::Equals(value, "EXTENSION")) {
5154: 		return PhysicalOperatorType::EXTENSION;
5155: 	}
5156: 	if (StringUtil::Equals(value, "VERIFY_VECTOR")) {
5157: 		return PhysicalOperatorType::VERIFY_VECTOR;
5158: 	}
5159: 	if (StringUtil::Equals(value, "UPDATE_EXTENSIONS")) {
5160: 		return PhysicalOperatorType::UPDATE_EXTENSIONS;
5161: 	}
5162: 	if (StringUtil::Equals(value, "CREATE_SECRET")) {
5163: 		return PhysicalOperatorType::CREATE_SECRET;
5164: 	}
5165: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5166: }
5167: 
5168: template<>
5169: const char* EnumUtil::ToChars<PhysicalType>(PhysicalType value) {
5170: 	switch(value) {
5171: 	case PhysicalType::BOOL:
5172: 		return "BOOL";
5173: 	case PhysicalType::UINT8:
5174: 		return "UINT8";
5175: 	case PhysicalType::INT8:
5176: 		return "INT8";
5177: 	case PhysicalType::UINT16:
5178: 		return "UINT16";
5179: 	case PhysicalType::INT16:
5180: 		return "INT16";
5181: 	case PhysicalType::UINT32:
5182: 		return "UINT32";
5183: 	case PhysicalType::INT32:
5184: 		return "INT32";
5185: 	case PhysicalType::UINT64:
5186: 		return "UINT64";
5187: 	case PhysicalType::INT64:
5188: 		return "INT64";
5189: 	case PhysicalType::FLOAT:
5190: 		return "FLOAT";
5191: 	case PhysicalType::DOUBLE:
5192: 		return "DOUBLE";
5193: 	case PhysicalType::INTERVAL:
5194: 		return "INTERVAL";
5195: 	case PhysicalType::LIST:
5196: 		return "LIST";
5197: 	case PhysicalType::STRUCT:
5198: 		return "STRUCT";
5199: 	case PhysicalType::ARRAY:
5200: 		return "ARRAY";
5201: 	case PhysicalType::VARCHAR:
5202: 		return "VARCHAR";
5203: 	case PhysicalType::UINT128:
5204: 		return "UINT128";
5205: 	case PhysicalType::INT128:
5206: 		return "INT128";
5207: 	case PhysicalType::UNKNOWN:
5208: 		return "UNKNOWN";
5209: 	case PhysicalType::BIT:
5210: 		return "BIT";
5211: 	case PhysicalType::INVALID:
5212: 		return "INVALID";
5213: 	default:
5214: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5215: 	}
5216: }
5217: 
5218: template<>
5219: PhysicalType EnumUtil::FromString<PhysicalType>(const char *value) {
5220: 	if (StringUtil::Equals(value, "BOOL")) {
5221: 		return PhysicalType::BOOL;
5222: 	}
5223: 	if (StringUtil::Equals(value, "UINT8")) {
5224: 		return PhysicalType::UINT8;
5225: 	}
5226: 	if (StringUtil::Equals(value, "INT8")) {
5227: 		return PhysicalType::INT8;
5228: 	}
5229: 	if (StringUtil::Equals(value, "UINT16")) {
5230: 		return PhysicalType::UINT16;
5231: 	}
5232: 	if (StringUtil::Equals(value, "INT16")) {
5233: 		return PhysicalType::INT16;
5234: 	}
5235: 	if (StringUtil::Equals(value, "UINT32")) {
5236: 		return PhysicalType::UINT32;
5237: 	}
5238: 	if (StringUtil::Equals(value, "INT32")) {
5239: 		return PhysicalType::INT32;
5240: 	}
5241: 	if (StringUtil::Equals(value, "UINT64")) {
5242: 		return PhysicalType::UINT64;
5243: 	}
5244: 	if (StringUtil::Equals(value, "INT64")) {
5245: 		return PhysicalType::INT64;
5246: 	}
5247: 	if (StringUtil::Equals(value, "FLOAT")) {
5248: 		return PhysicalType::FLOAT;
5249: 	}
5250: 	if (StringUtil::Equals(value, "DOUBLE")) {
5251: 		return PhysicalType::DOUBLE;
5252: 	}
5253: 	if (StringUtil::Equals(value, "INTERVAL")) {
5254: 		return PhysicalType::INTERVAL;
5255: 	}
5256: 	if (StringUtil::Equals(value, "LIST")) {
5257: 		return PhysicalType::LIST;
5258: 	}
5259: 	if (StringUtil::Equals(value, "STRUCT")) {
5260: 		return PhysicalType::STRUCT;
5261: 	}
5262: 	if (StringUtil::Equals(value, "ARRAY")) {
5263: 		return PhysicalType::ARRAY;
5264: 	}
5265: 	if (StringUtil::Equals(value, "VARCHAR")) {
5266: 		return PhysicalType::VARCHAR;
5267: 	}
5268: 	if (StringUtil::Equals(value, "UINT128")) {
5269: 		return PhysicalType::UINT128;
5270: 	}
5271: 	if (StringUtil::Equals(value, "INT128")) {
5272: 		return PhysicalType::INT128;
5273: 	}
5274: 	if (StringUtil::Equals(value, "UNKNOWN")) {
5275: 		return PhysicalType::UNKNOWN;
5276: 	}
5277: 	if (StringUtil::Equals(value, "BIT")) {
5278: 		return PhysicalType::BIT;
5279: 	}
5280: 	if (StringUtil::Equals(value, "INVALID")) {
5281: 		return PhysicalType::INVALID;
5282: 	}
5283: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5284: }
5285: 
5286: template<>
5287: const char* EnumUtil::ToChars<PragmaType>(PragmaType value) {
5288: 	switch(value) {
5289: 	case PragmaType::PRAGMA_STATEMENT:
5290: 		return "PRAGMA_STATEMENT";
5291: 	case PragmaType::PRAGMA_CALL:
5292: 		return "PRAGMA_CALL";
5293: 	default:
5294: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5295: 	}
5296: }
5297: 
5298: template<>
5299: PragmaType EnumUtil::FromString<PragmaType>(const char *value) {
5300: 	if (StringUtil::Equals(value, "PRAGMA_STATEMENT")) {
5301: 		return PragmaType::PRAGMA_STATEMENT;
5302: 	}
5303: 	if (StringUtil::Equals(value, "PRAGMA_CALL")) {
5304: 		return PragmaType::PRAGMA_CALL;
5305: 	}
5306: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5307: }
5308: 
5309: template<>
5310: const char* EnumUtil::ToChars<PreparedParamType>(PreparedParamType value) {
5311: 	switch(value) {
5312: 	case PreparedParamType::AUTO_INCREMENT:
5313: 		return "AUTO_INCREMENT";
5314: 	case PreparedParamType::POSITIONAL:
5315: 		return "POSITIONAL";
5316: 	case PreparedParamType::NAMED:
5317: 		return "NAMED";
5318: 	case PreparedParamType::INVALID:
5319: 		return "INVALID";
5320: 	default:
5321: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5322: 	}
5323: }
5324: 
5325: template<>
5326: PreparedParamType EnumUtil::FromString<PreparedParamType>(const char *value) {
5327: 	if (StringUtil::Equals(value, "AUTO_INCREMENT")) {
5328: 		return PreparedParamType::AUTO_INCREMENT;
5329: 	}
5330: 	if (StringUtil::Equals(value, "POSITIONAL")) {
5331: 		return PreparedParamType::POSITIONAL;
5332: 	}
5333: 	if (StringUtil::Equals(value, "NAMED")) {
5334: 		return PreparedParamType::NAMED;
5335: 	}
5336: 	if (StringUtil::Equals(value, "INVALID")) {
5337: 		return PreparedParamType::INVALID;
5338: 	}
5339: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5340: }
5341: 
5342: template<>
5343: const char* EnumUtil::ToChars<PreparedStatementMode>(PreparedStatementMode value) {
5344: 	switch(value) {
5345: 	case PreparedStatementMode::PREPARE_ONLY:
5346: 		return "PREPARE_ONLY";
5347: 	case PreparedStatementMode::PREPARE_AND_EXECUTE:
5348: 		return "PREPARE_AND_EXECUTE";
5349: 	default:
5350: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5351: 	}
5352: }
5353: 
5354: template<>
5355: PreparedStatementMode EnumUtil::FromString<PreparedStatementMode>(const char *value) {
5356: 	if (StringUtil::Equals(value, "PREPARE_ONLY")) {
5357: 		return PreparedStatementMode::PREPARE_ONLY;
5358: 	}
5359: 	if (StringUtil::Equals(value, "PREPARE_AND_EXECUTE")) {
5360: 		return PreparedStatementMode::PREPARE_AND_EXECUTE;
5361: 	}
5362: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5363: }
5364: 
5365: template<>
5366: const char* EnumUtil::ToChars<ProfilerPrintFormat>(ProfilerPrintFormat value) {
5367: 	switch(value) {
5368: 	case ProfilerPrintFormat::QUERY_TREE:
5369: 		return "QUERY_TREE";
5370: 	case ProfilerPrintFormat::JSON:
5371: 		return "JSON";
5372: 	case ProfilerPrintFormat::QUERY_TREE_OPTIMIZER:
5373: 		return "QUERY_TREE_OPTIMIZER";
5374: 	default:
5375: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5376: 	}
5377: }
5378: 
5379: template<>
5380: ProfilerPrintFormat EnumUtil::FromString<ProfilerPrintFormat>(const char *value) {
5381: 	if (StringUtil::Equals(value, "QUERY_TREE")) {
5382: 		return ProfilerPrintFormat::QUERY_TREE;
5383: 	}
5384: 	if (StringUtil::Equals(value, "JSON")) {
5385: 		return ProfilerPrintFormat::JSON;
5386: 	}
5387: 	if (StringUtil::Equals(value, "QUERY_TREE_OPTIMIZER")) {
5388: 		return ProfilerPrintFormat::QUERY_TREE_OPTIMIZER;
5389: 	}
5390: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5391: }
5392: 
5393: template<>
5394: const char* EnumUtil::ToChars<QuantileSerializationType>(QuantileSerializationType value) {
5395: 	switch(value) {
5396: 	case QuantileSerializationType::NON_DECIMAL:
5397: 		return "NON_DECIMAL";
5398: 	case QuantileSerializationType::DECIMAL_DISCRETE:
5399: 		return "DECIMAL_DISCRETE";
5400: 	case QuantileSerializationType::DECIMAL_DISCRETE_LIST:
5401: 		return "DECIMAL_DISCRETE_LIST";
5402: 	case QuantileSerializationType::DECIMAL_CONTINUOUS:
5403: 		return "DECIMAL_CONTINUOUS";
5404: 	case QuantileSerializationType::DECIMAL_CONTINUOUS_LIST:
5405: 		return "DECIMAL_CONTINUOUS_LIST";
5406: 	default:
5407: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5408: 	}
5409: }
5410: 
5411: template<>
5412: QuantileSerializationType EnumUtil::FromString<QuantileSerializationType>(const char *value) {
5413: 	if (StringUtil::Equals(value, "NON_DECIMAL")) {
5414: 		return QuantileSerializationType::NON_DECIMAL;
5415: 	}
5416: 	if (StringUtil::Equals(value, "DECIMAL_DISCRETE")) {
5417: 		return QuantileSerializationType::DECIMAL_DISCRETE;
5418: 	}
5419: 	if (StringUtil::Equals(value, "DECIMAL_DISCRETE_LIST")) {
5420: 		return QuantileSerializationType::DECIMAL_DISCRETE_LIST;
5421: 	}
5422: 	if (StringUtil::Equals(value, "DECIMAL_CONTINUOUS")) {
5423: 		return QuantileSerializationType::DECIMAL_CONTINUOUS;
5424: 	}
5425: 	if (StringUtil::Equals(value, "DECIMAL_CONTINUOUS_LIST")) {
5426: 		return QuantileSerializationType::DECIMAL_CONTINUOUS_LIST;
5427: 	}
5428: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5429: }
5430: 
5431: template<>
5432: const char* EnumUtil::ToChars<QueryNodeType>(QueryNodeType value) {
5433: 	switch(value) {
5434: 	case QueryNodeType::SELECT_NODE:
5435: 		return "SELECT_NODE";
5436: 	case QueryNodeType::SET_OPERATION_NODE:
5437: 		return "SET_OPERATION_NODE";
5438: 	case QueryNodeType::BOUND_SUBQUERY_NODE:
5439: 		return "BOUND_SUBQUERY_NODE";
5440: 	case QueryNodeType::RECURSIVE_CTE_NODE:
5441: 		return "RECURSIVE_CTE_NODE";
5442: 	case QueryNodeType::CTE_NODE:
5443: 		return "CTE_NODE";
5444: 	default:
5445: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5446: 	}
5447: }
5448: 
5449: template<>
5450: QueryNodeType EnumUtil::FromString<QueryNodeType>(const char *value) {
5451: 	if (StringUtil::Equals(value, "SELECT_NODE")) {
5452: 		return QueryNodeType::SELECT_NODE;
5453: 	}
5454: 	if (StringUtil::Equals(value, "SET_OPERATION_NODE")) {
5455: 		return QueryNodeType::SET_OPERATION_NODE;
5456: 	}
5457: 	if (StringUtil::Equals(value, "BOUND_SUBQUERY_NODE")) {
5458: 		return QueryNodeType::BOUND_SUBQUERY_NODE;
5459: 	}
5460: 	if (StringUtil::Equals(value, "RECURSIVE_CTE_NODE")) {
5461: 		return QueryNodeType::RECURSIVE_CTE_NODE;
5462: 	}
5463: 	if (StringUtil::Equals(value, "CTE_NODE")) {
5464: 		return QueryNodeType::CTE_NODE;
5465: 	}
5466: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5467: }
5468: 
5469: template<>
5470: const char* EnumUtil::ToChars<QueryResultType>(QueryResultType value) {
5471: 	switch(value) {
5472: 	case QueryResultType::MATERIALIZED_RESULT:
5473: 		return "MATERIALIZED_RESULT";
5474: 	case QueryResultType::STREAM_RESULT:
5475: 		return "STREAM_RESULT";
5476: 	case QueryResultType::PENDING_RESULT:
5477: 		return "PENDING_RESULT";
5478: 	default:
5479: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5480: 	}
5481: }
5482: 
5483: template<>
5484: QueryResultType EnumUtil::FromString<QueryResultType>(const char *value) {
5485: 	if (StringUtil::Equals(value, "MATERIALIZED_RESULT")) {
5486: 		return QueryResultType::MATERIALIZED_RESULT;
5487: 	}
5488: 	if (StringUtil::Equals(value, "STREAM_RESULT")) {
5489: 		return QueryResultType::STREAM_RESULT;
5490: 	}
5491: 	if (StringUtil::Equals(value, "PENDING_RESULT")) {
5492: 		return QueryResultType::PENDING_RESULT;
5493: 	}
5494: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5495: }
5496: 
5497: template<>
5498: const char* EnumUtil::ToChars<QuoteRule>(QuoteRule value) {
5499: 	switch(value) {
5500: 	case QuoteRule::QUOTES_RFC:
5501: 		return "QUOTES_RFC";
5502: 	case QuoteRule::QUOTES_OTHER:
5503: 		return "QUOTES_OTHER";
5504: 	case QuoteRule::NO_QUOTES:
5505: 		return "NO_QUOTES";
5506: 	default:
5507: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5508: 	}
5509: }
5510: 
5511: template<>
5512: QuoteRule EnumUtil::FromString<QuoteRule>(const char *value) {
5513: 	if (StringUtil::Equals(value, "QUOTES_RFC")) {
5514: 		return QuoteRule::QUOTES_RFC;
5515: 	}
5516: 	if (StringUtil::Equals(value, "QUOTES_OTHER")) {
5517: 		return QuoteRule::QUOTES_OTHER;
5518: 	}
5519: 	if (StringUtil::Equals(value, "NO_QUOTES")) {
5520: 		return QuoteRule::NO_QUOTES;
5521: 	}
5522: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5523: }
5524: 
5525: template<>
5526: const char* EnumUtil::ToChars<RelationType>(RelationType value) {
5527: 	switch(value) {
5528: 	case RelationType::INVALID_RELATION:
5529: 		return "INVALID_RELATION";
5530: 	case RelationType::TABLE_RELATION:
5531: 		return "TABLE_RELATION";
5532: 	case RelationType::PROJECTION_RELATION:
5533: 		return "PROJECTION_RELATION";
5534: 	case RelationType::FILTER_RELATION:
5535: 		return "FILTER_RELATION";
5536: 	case RelationType::EXPLAIN_RELATION:
5537: 		return "EXPLAIN_RELATION";
5538: 	case RelationType::CROSS_PRODUCT_RELATION:
5539: 		return "CROSS_PRODUCT_RELATION";
5540: 	case RelationType::JOIN_RELATION:
5541: 		return "JOIN_RELATION";
5542: 	case RelationType::AGGREGATE_RELATION:
5543: 		return "AGGREGATE_RELATION";
5544: 	case RelationType::SET_OPERATION_RELATION:
5545: 		return "SET_OPERATION_RELATION";
5546: 	case RelationType::DISTINCT_RELATION:
5547: 		return "DISTINCT_RELATION";
5548: 	case RelationType::LIMIT_RELATION:
5549: 		return "LIMIT_RELATION";
5550: 	case RelationType::ORDER_RELATION:
5551: 		return "ORDER_RELATION";
5552: 	case RelationType::CREATE_VIEW_RELATION:
5553: 		return "CREATE_VIEW_RELATION";
5554: 	case RelationType::CREATE_TABLE_RELATION:
5555: 		return "CREATE_TABLE_RELATION";
5556: 	case RelationType::INSERT_RELATION:
5557: 		return "INSERT_RELATION";
5558: 	case RelationType::VALUE_LIST_RELATION:
5559: 		return "VALUE_LIST_RELATION";
5560: 	case RelationType::MATERIALIZED_RELATION:
5561: 		return "MATERIALIZED_RELATION";
5562: 	case RelationType::DELETE_RELATION:
5563: 		return "DELETE_RELATION";
5564: 	case RelationType::UPDATE_RELATION:
5565: 		return "UPDATE_RELATION";
5566: 	case RelationType::WRITE_CSV_RELATION:
5567: 		return "WRITE_CSV_RELATION";
5568: 	case RelationType::WRITE_PARQUET_RELATION:
5569: 		return "WRITE_PARQUET_RELATION";
5570: 	case RelationType::READ_CSV_RELATION:
5571: 		return "READ_CSV_RELATION";
5572: 	case RelationType::SUBQUERY_RELATION:
5573: 		return "SUBQUERY_RELATION";
5574: 	case RelationType::TABLE_FUNCTION_RELATION:
5575: 		return "TABLE_FUNCTION_RELATION";
5576: 	case RelationType::VIEW_RELATION:
5577: 		return "VIEW_RELATION";
5578: 	case RelationType::QUERY_RELATION:
5579: 		return "QUERY_RELATION";
5580: 	default:
5581: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5582: 	}
5583: }
5584: 
5585: template<>
5586: RelationType EnumUtil::FromString<RelationType>(const char *value) {
5587: 	if (StringUtil::Equals(value, "INVALID_RELATION")) {
5588: 		return RelationType::INVALID_RELATION;
5589: 	}
5590: 	if (StringUtil::Equals(value, "TABLE_RELATION")) {
5591: 		return RelationType::TABLE_RELATION;
5592: 	}
5593: 	if (StringUtil::Equals(value, "PROJECTION_RELATION")) {
5594: 		return RelationType::PROJECTION_RELATION;
5595: 	}
5596: 	if (StringUtil::Equals(value, "FILTER_RELATION")) {
5597: 		return RelationType::FILTER_RELATION;
5598: 	}
5599: 	if (StringUtil::Equals(value, "EXPLAIN_RELATION")) {
5600: 		return RelationType::EXPLAIN_RELATION;
5601: 	}
5602: 	if (StringUtil::Equals(value, "CROSS_PRODUCT_RELATION")) {
5603: 		return RelationType::CROSS_PRODUCT_RELATION;
5604: 	}
5605: 	if (StringUtil::Equals(value, "JOIN_RELATION")) {
5606: 		return RelationType::JOIN_RELATION;
5607: 	}
5608: 	if (StringUtil::Equals(value, "AGGREGATE_RELATION")) {
5609: 		return RelationType::AGGREGATE_RELATION;
5610: 	}
5611: 	if (StringUtil::Equals(value, "SET_OPERATION_RELATION")) {
5612: 		return RelationType::SET_OPERATION_RELATION;
5613: 	}
5614: 	if (StringUtil::Equals(value, "DISTINCT_RELATION")) {
5615: 		return RelationType::DISTINCT_RELATION;
5616: 	}
5617: 	if (StringUtil::Equals(value, "LIMIT_RELATION")) {
5618: 		return RelationType::LIMIT_RELATION;
5619: 	}
5620: 	if (StringUtil::Equals(value, "ORDER_RELATION")) {
5621: 		return RelationType::ORDER_RELATION;
5622: 	}
5623: 	if (StringUtil::Equals(value, "CREATE_VIEW_RELATION")) {
5624: 		return RelationType::CREATE_VIEW_RELATION;
5625: 	}
5626: 	if (StringUtil::Equals(value, "CREATE_TABLE_RELATION")) {
5627: 		return RelationType::CREATE_TABLE_RELATION;
5628: 	}
5629: 	if (StringUtil::Equals(value, "INSERT_RELATION")) {
5630: 		return RelationType::INSERT_RELATION;
5631: 	}
5632: 	if (StringUtil::Equals(value, "VALUE_LIST_RELATION")) {
5633: 		return RelationType::VALUE_LIST_RELATION;
5634: 	}
5635: 	if (StringUtil::Equals(value, "MATERIALIZED_RELATION")) {
5636: 		return RelationType::MATERIALIZED_RELATION;
5637: 	}
5638: 	if (StringUtil::Equals(value, "DELETE_RELATION")) {
5639: 		return RelationType::DELETE_RELATION;
5640: 	}
5641: 	if (StringUtil::Equals(value, "UPDATE_RELATION")) {
5642: 		return RelationType::UPDATE_RELATION;
5643: 	}
5644: 	if (StringUtil::Equals(value, "WRITE_CSV_RELATION")) {
5645: 		return RelationType::WRITE_CSV_RELATION;
5646: 	}
5647: 	if (StringUtil::Equals(value, "WRITE_PARQUET_RELATION")) {
5648: 		return RelationType::WRITE_PARQUET_RELATION;
5649: 	}
5650: 	if (StringUtil::Equals(value, "READ_CSV_RELATION")) {
5651: 		return RelationType::READ_CSV_RELATION;
5652: 	}
5653: 	if (StringUtil::Equals(value, "SUBQUERY_RELATION")) {
5654: 		return RelationType::SUBQUERY_RELATION;
5655: 	}
5656: 	if (StringUtil::Equals(value, "TABLE_FUNCTION_RELATION")) {
5657: 		return RelationType::TABLE_FUNCTION_RELATION;
5658: 	}
5659: 	if (StringUtil::Equals(value, "VIEW_RELATION")) {
5660: 		return RelationType::VIEW_RELATION;
5661: 	}
5662: 	if (StringUtil::Equals(value, "QUERY_RELATION")) {
5663: 		return RelationType::QUERY_RELATION;
5664: 	}
5665: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5666: }
5667: 
5668: template<>
5669: const char* EnumUtil::ToChars<RenderMode>(RenderMode value) {
5670: 	switch(value) {
5671: 	case RenderMode::ROWS:
5672: 		return "ROWS";
5673: 	case RenderMode::COLUMNS:
5674: 		return "COLUMNS";
5675: 	default:
5676: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5677: 	}
5678: }
5679: 
5680: template<>
5681: RenderMode EnumUtil::FromString<RenderMode>(const char *value) {
5682: 	if (StringUtil::Equals(value, "ROWS")) {
5683: 		return RenderMode::ROWS;
5684: 	}
5685: 	if (StringUtil::Equals(value, "COLUMNS")) {
5686: 		return RenderMode::COLUMNS;
5687: 	}
5688: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5689: }
5690: 
5691: template<>
5692: const char* EnumUtil::ToChars<ResultModifierType>(ResultModifierType value) {
5693: 	switch(value) {
5694: 	case ResultModifierType::LIMIT_MODIFIER:
5695: 		return "LIMIT_MODIFIER";
5696: 	case ResultModifierType::ORDER_MODIFIER:
5697: 		return "ORDER_MODIFIER";
5698: 	case ResultModifierType::DISTINCT_MODIFIER:
5699: 		return "DISTINCT_MODIFIER";
5700: 	case ResultModifierType::LIMIT_PERCENT_MODIFIER:
5701: 		return "LIMIT_PERCENT_MODIFIER";
5702: 	default:
5703: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5704: 	}
5705: }
5706: 
5707: template<>
5708: ResultModifierType EnumUtil::FromString<ResultModifierType>(const char *value) {
5709: 	if (StringUtil::Equals(value, "LIMIT_MODIFIER")) {
5710: 		return ResultModifierType::LIMIT_MODIFIER;
5711: 	}
5712: 	if (StringUtil::Equals(value, "ORDER_MODIFIER")) {
5713: 		return ResultModifierType::ORDER_MODIFIER;
5714: 	}
5715: 	if (StringUtil::Equals(value, "DISTINCT_MODIFIER")) {
5716: 		return ResultModifierType::DISTINCT_MODIFIER;
5717: 	}
5718: 	if (StringUtil::Equals(value, "LIMIT_PERCENT_MODIFIER")) {
5719: 		return ResultModifierType::LIMIT_PERCENT_MODIFIER;
5720: 	}
5721: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5722: }
5723: 
5724: template<>
5725: const char* EnumUtil::ToChars<SampleMethod>(SampleMethod value) {
5726: 	switch(value) {
5727: 	case SampleMethod::SYSTEM_SAMPLE:
5728: 		return "System";
5729: 	case SampleMethod::BERNOULLI_SAMPLE:
5730: 		return "Bernoulli";
5731: 	case SampleMethod::RESERVOIR_SAMPLE:
5732: 		return "Reservoir";
5733: 	default:
5734: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5735: 	}
5736: }
5737: 
5738: template<>
5739: SampleMethod EnumUtil::FromString<SampleMethod>(const char *value) {
5740: 	if (StringUtil::Equals(value, "System")) {
5741: 		return SampleMethod::SYSTEM_SAMPLE;
5742: 	}
5743: 	if (StringUtil::Equals(value, "Bernoulli")) {
5744: 		return SampleMethod::BERNOULLI_SAMPLE;
5745: 	}
5746: 	if (StringUtil::Equals(value, "Reservoir")) {
5747: 		return SampleMethod::RESERVOIR_SAMPLE;
5748: 	}
5749: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5750: }
5751: 
5752: template<>
5753: const char* EnumUtil::ToChars<SampleType>(SampleType value) {
5754: 	switch(value) {
5755: 	case SampleType::BLOCKING_SAMPLE:
5756: 		return "BLOCKING_SAMPLE";
5757: 	case SampleType::RESERVOIR_SAMPLE:
5758: 		return "RESERVOIR_SAMPLE";
5759: 	case SampleType::RESERVOIR_PERCENTAGE_SAMPLE:
5760: 		return "RESERVOIR_PERCENTAGE_SAMPLE";
5761: 	default:
5762: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5763: 	}
5764: }
5765: 
5766: template<>
5767: SampleType EnumUtil::FromString<SampleType>(const char *value) {
5768: 	if (StringUtil::Equals(value, "BLOCKING_SAMPLE")) {
5769: 		return SampleType::BLOCKING_SAMPLE;
5770: 	}
5771: 	if (StringUtil::Equals(value, "RESERVOIR_SAMPLE")) {
5772: 		return SampleType::RESERVOIR_SAMPLE;
5773: 	}
5774: 	if (StringUtil::Equals(value, "RESERVOIR_PERCENTAGE_SAMPLE")) {
5775: 		return SampleType::RESERVOIR_PERCENTAGE_SAMPLE;
5776: 	}
5777: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5778: }
5779: 
5780: template<>
5781: const char* EnumUtil::ToChars<ScanType>(ScanType value) {
5782: 	switch(value) {
5783: 	case ScanType::TABLE:
5784: 		return "TABLE";
5785: 	case ScanType::PARQUET:
5786: 		return "PARQUET";
5787: 	default:
5788: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5789: 	}
5790: }
5791: 
5792: template<>
5793: ScanType EnumUtil::FromString<ScanType>(const char *value) {
5794: 	if (StringUtil::Equals(value, "TABLE")) {
5795: 		return ScanType::TABLE;
5796: 	}
5797: 	if (StringUtil::Equals(value, "PARQUET")) {
5798: 		return ScanType::PARQUET;
5799: 	}
5800: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5801: }
5802: 
5803: template<>
5804: const char* EnumUtil::ToChars<SecretDisplayType>(SecretDisplayType value) {
5805: 	switch(value) {
5806: 	case SecretDisplayType::REDACTED:
5807: 		return "REDACTED";
5808: 	case SecretDisplayType::UNREDACTED:
5809: 		return "UNREDACTED";
5810: 	default:
5811: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5812: 	}
5813: }
5814: 
5815: template<>
5816: SecretDisplayType EnumUtil::FromString<SecretDisplayType>(const char *value) {
5817: 	if (StringUtil::Equals(value, "REDACTED")) {
5818: 		return SecretDisplayType::REDACTED;
5819: 	}
5820: 	if (StringUtil::Equals(value, "UNREDACTED")) {
5821: 		return SecretDisplayType::UNREDACTED;
5822: 	}
5823: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5824: }
5825: 
5826: template<>
5827: const char* EnumUtil::ToChars<SecretPersistType>(SecretPersistType value) {
5828: 	switch(value) {
5829: 	case SecretPersistType::DEFAULT:
5830: 		return "DEFAULT";
5831: 	case SecretPersistType::TEMPORARY:
5832: 		return "TEMPORARY";
5833: 	case SecretPersistType::PERSISTENT:
5834: 		return "PERSISTENT";
5835: 	default:
5836: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5837: 	}
5838: }
5839: 
5840: template<>
5841: SecretPersistType EnumUtil::FromString<SecretPersistType>(const char *value) {
5842: 	if (StringUtil::Equals(value, "DEFAULT")) {
5843: 		return SecretPersistType::DEFAULT;
5844: 	}
5845: 	if (StringUtil::Equals(value, "TEMPORARY")) {
5846: 		return SecretPersistType::TEMPORARY;
5847: 	}
5848: 	if (StringUtil::Equals(value, "PERSISTENT")) {
5849: 		return SecretPersistType::PERSISTENT;
5850: 	}
5851: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5852: }
5853: 
5854: template<>
5855: const char* EnumUtil::ToChars<SequenceInfo>(SequenceInfo value) {
5856: 	switch(value) {
5857: 	case SequenceInfo::SEQ_START:
5858: 		return "SEQ_START";
5859: 	case SequenceInfo::SEQ_INC:
5860: 		return "SEQ_INC";
5861: 	case SequenceInfo::SEQ_MIN:
5862: 		return "SEQ_MIN";
5863: 	case SequenceInfo::SEQ_MAX:
5864: 		return "SEQ_MAX";
5865: 	case SequenceInfo::SEQ_CYCLE:
5866: 		return "SEQ_CYCLE";
5867: 	case SequenceInfo::SEQ_OWN:
5868: 		return "SEQ_OWN";
5869: 	default:
5870: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5871: 	}
5872: }
5873: 
5874: template<>
5875: SequenceInfo EnumUtil::FromString<SequenceInfo>(const char *value) {
5876: 	if (StringUtil::Equals(value, "SEQ_START")) {
5877: 		return SequenceInfo::SEQ_START;
5878: 	}
5879: 	if (StringUtil::Equals(value, "SEQ_INC")) {
5880: 		return SequenceInfo::SEQ_INC;
5881: 	}
5882: 	if (StringUtil::Equals(value, "SEQ_MIN")) {
5883: 		return SequenceInfo::SEQ_MIN;
5884: 	}
5885: 	if (StringUtil::Equals(value, "SEQ_MAX")) {
5886: 		return SequenceInfo::SEQ_MAX;
5887: 	}
5888: 	if (StringUtil::Equals(value, "SEQ_CYCLE")) {
5889: 		return SequenceInfo::SEQ_CYCLE;
5890: 	}
5891: 	if (StringUtil::Equals(value, "SEQ_OWN")) {
5892: 		return SequenceInfo::SEQ_OWN;
5893: 	}
5894: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5895: }
5896: 
5897: template<>
5898: const char* EnumUtil::ToChars<SetOperationType>(SetOperationType value) {
5899: 	switch(value) {
5900: 	case SetOperationType::NONE:
5901: 		return "NONE";
5902: 	case SetOperationType::UNION:
5903: 		return "UNION";
5904: 	case SetOperationType::EXCEPT:
5905: 		return "EXCEPT";
5906: 	case SetOperationType::INTERSECT:
5907: 		return "INTERSECT";
5908: 	case SetOperationType::UNION_BY_NAME:
5909: 		return "UNION_BY_NAME";
5910: 	default:
5911: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5912: 	}
5913: }
5914: 
5915: template<>
5916: SetOperationType EnumUtil::FromString<SetOperationType>(const char *value) {
5917: 	if (StringUtil::Equals(value, "NONE")) {
5918: 		return SetOperationType::NONE;
5919: 	}
5920: 	if (StringUtil::Equals(value, "UNION")) {
5921: 		return SetOperationType::UNION;
5922: 	}
5923: 	if (StringUtil::Equals(value, "EXCEPT")) {
5924: 		return SetOperationType::EXCEPT;
5925: 	}
5926: 	if (StringUtil::Equals(value, "INTERSECT")) {
5927: 		return SetOperationType::INTERSECT;
5928: 	}
5929: 	if (StringUtil::Equals(value, "UNION_BY_NAME")) {
5930: 		return SetOperationType::UNION_BY_NAME;
5931: 	}
5932: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5933: }
5934: 
5935: template<>
5936: const char* EnumUtil::ToChars<SetScope>(SetScope value) {
5937: 	switch(value) {
5938: 	case SetScope::AUTOMATIC:
5939: 		return "AUTOMATIC";
5940: 	case SetScope::LOCAL:
5941: 		return "LOCAL";
5942: 	case SetScope::SESSION:
5943: 		return "SESSION";
5944: 	case SetScope::GLOBAL:
5945: 		return "GLOBAL";
5946: 	default:
5947: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5948: 	}
5949: }
5950: 
5951: template<>
5952: SetScope EnumUtil::FromString<SetScope>(const char *value) {
5953: 	if (StringUtil::Equals(value, "AUTOMATIC")) {
5954: 		return SetScope::AUTOMATIC;
5955: 	}
5956: 	if (StringUtil::Equals(value, "LOCAL")) {
5957: 		return SetScope::LOCAL;
5958: 	}
5959: 	if (StringUtil::Equals(value, "SESSION")) {
5960: 		return SetScope::SESSION;
5961: 	}
5962: 	if (StringUtil::Equals(value, "GLOBAL")) {
5963: 		return SetScope::GLOBAL;
5964: 	}
5965: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5966: }
5967: 
5968: template<>
5969: const char* EnumUtil::ToChars<SetType>(SetType value) {
5970: 	switch(value) {
5971: 	case SetType::SET:
5972: 		return "SET";
5973: 	case SetType::RESET:
5974: 		return "RESET";
5975: 	default:
5976: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
5977: 	}
5978: }
5979: 
5980: template<>
5981: SetType EnumUtil::FromString<SetType>(const char *value) {
5982: 	if (StringUtil::Equals(value, "SET")) {
5983: 		return SetType::SET;
5984: 	}
5985: 	if (StringUtil::Equals(value, "RESET")) {
5986: 		return SetType::RESET;
5987: 	}
5988: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
5989: }
5990: 
5991: template<>
5992: const char* EnumUtil::ToChars<SettingScope>(SettingScope value) {
5993: 	switch(value) {
5994: 	case SettingScope::GLOBAL:
5995: 		return "GLOBAL";
5996: 	case SettingScope::LOCAL:
5997: 		return "LOCAL";
5998: 	case SettingScope::INVALID:
5999: 		return "INVALID";
6000: 	default:
6001: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6002: 	}
6003: }
6004: 
6005: template<>
6006: SettingScope EnumUtil::FromString<SettingScope>(const char *value) {
6007: 	if (StringUtil::Equals(value, "GLOBAL")) {
6008: 		return SettingScope::GLOBAL;
6009: 	}
6010: 	if (StringUtil::Equals(value, "LOCAL")) {
6011: 		return SettingScope::LOCAL;
6012: 	}
6013: 	if (StringUtil::Equals(value, "INVALID")) {
6014: 		return SettingScope::INVALID;
6015: 	}
6016: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6017: }
6018: 
6019: template<>
6020: const char* EnumUtil::ToChars<ShowType>(ShowType value) {
6021: 	switch(value) {
6022: 	case ShowType::SUMMARY:
6023: 		return "SUMMARY";
6024: 	case ShowType::DESCRIBE:
6025: 		return "DESCRIBE";
6026: 	default:
6027: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6028: 	}
6029: }
6030: 
6031: template<>
6032: ShowType EnumUtil::FromString<ShowType>(const char *value) {
6033: 	if (StringUtil::Equals(value, "SUMMARY")) {
6034: 		return ShowType::SUMMARY;
6035: 	}
6036: 	if (StringUtil::Equals(value, "DESCRIBE")) {
6037: 		return ShowType::DESCRIBE;
6038: 	}
6039: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6040: }
6041: 
6042: template<>
6043: const char* EnumUtil::ToChars<SimplifiedTokenType>(SimplifiedTokenType value) {
6044: 	switch(value) {
6045: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER:
6046: 		return "SIMPLIFIED_TOKEN_IDENTIFIER";
6047: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_NUMERIC_CONSTANT:
6048: 		return "SIMPLIFIED_TOKEN_NUMERIC_CONSTANT";
6049: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_STRING_CONSTANT:
6050: 		return "SIMPLIFIED_TOKEN_STRING_CONSTANT";
6051: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_OPERATOR:
6052: 		return "SIMPLIFIED_TOKEN_OPERATOR";
6053: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_KEYWORD:
6054: 		return "SIMPLIFIED_TOKEN_KEYWORD";
6055: 	case SimplifiedTokenType::SIMPLIFIED_TOKEN_COMMENT:
6056: 		return "SIMPLIFIED_TOKEN_COMMENT";
6057: 	default:
6058: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6059: 	}
6060: }
6061: 
6062: template<>
6063: SimplifiedTokenType EnumUtil::FromString<SimplifiedTokenType>(const char *value) {
6064: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_IDENTIFIER")) {
6065: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER;
6066: 	}
6067: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_NUMERIC_CONSTANT")) {
6068: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_NUMERIC_CONSTANT;
6069: 	}
6070: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_STRING_CONSTANT")) {
6071: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_STRING_CONSTANT;
6072: 	}
6073: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_OPERATOR")) {
6074: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_OPERATOR;
6075: 	}
6076: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_KEYWORD")) {
6077: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_KEYWORD;
6078: 	}
6079: 	if (StringUtil::Equals(value, "SIMPLIFIED_TOKEN_COMMENT")) {
6080: 		return SimplifiedTokenType::SIMPLIFIED_TOKEN_COMMENT;
6081: 	}
6082: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6083: }
6084: 
6085: template<>
6086: const char* EnumUtil::ToChars<SinkCombineResultType>(SinkCombineResultType value) {
6087: 	switch(value) {
6088: 	case SinkCombineResultType::FINISHED:
6089: 		return "FINISHED";
6090: 	case SinkCombineResultType::BLOCKED:
6091: 		return "BLOCKED";
6092: 	default:
6093: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6094: 	}
6095: }
6096: 
6097: template<>
6098: SinkCombineResultType EnumUtil::FromString<SinkCombineResultType>(const char *value) {
6099: 	if (StringUtil::Equals(value, "FINISHED")) {
6100: 		return SinkCombineResultType::FINISHED;
6101: 	}
6102: 	if (StringUtil::Equals(value, "BLOCKED")) {
6103: 		return SinkCombineResultType::BLOCKED;
6104: 	}
6105: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6106: }
6107: 
6108: template<>
6109: const char* EnumUtil::ToChars<SinkFinalizeType>(SinkFinalizeType value) {
6110: 	switch(value) {
6111: 	case SinkFinalizeType::READY:
6112: 		return "READY";
6113: 	case SinkFinalizeType::NO_OUTPUT_POSSIBLE:
6114: 		return "NO_OUTPUT_POSSIBLE";
6115: 	case SinkFinalizeType::BLOCKED:
6116: 		return "BLOCKED";
6117: 	default:
6118: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6119: 	}
6120: }
6121: 
6122: template<>
6123: SinkFinalizeType EnumUtil::FromString<SinkFinalizeType>(const char *value) {
6124: 	if (StringUtil::Equals(value, "READY")) {
6125: 		return SinkFinalizeType::READY;
6126: 	}
6127: 	if (StringUtil::Equals(value, "NO_OUTPUT_POSSIBLE")) {
6128: 		return SinkFinalizeType::NO_OUTPUT_POSSIBLE;
6129: 	}
6130: 	if (StringUtil::Equals(value, "BLOCKED")) {
6131: 		return SinkFinalizeType::BLOCKED;
6132: 	}
6133: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6134: }
6135: 
6136: template<>
6137: const char* EnumUtil::ToChars<SinkNextBatchType>(SinkNextBatchType value) {
6138: 	switch(value) {
6139: 	case SinkNextBatchType::READY:
6140: 		return "READY";
6141: 	case SinkNextBatchType::BLOCKED:
6142: 		return "BLOCKED";
6143: 	default:
6144: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6145: 	}
6146: }
6147: 
6148: template<>
6149: SinkNextBatchType EnumUtil::FromString<SinkNextBatchType>(const char *value) {
6150: 	if (StringUtil::Equals(value, "READY")) {
6151: 		return SinkNextBatchType::READY;
6152: 	}
6153: 	if (StringUtil::Equals(value, "BLOCKED")) {
6154: 		return SinkNextBatchType::BLOCKED;
6155: 	}
6156: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6157: }
6158: 
6159: template<>
6160: const char* EnumUtil::ToChars<SinkResultType>(SinkResultType value) {
6161: 	switch(value) {
6162: 	case SinkResultType::NEED_MORE_INPUT:
6163: 		return "NEED_MORE_INPUT";
6164: 	case SinkResultType::FINISHED:
6165: 		return "FINISHED";
6166: 	case SinkResultType::BLOCKED:
6167: 		return "BLOCKED";
6168: 	default:
6169: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6170: 	}
6171: }
6172: 
6173: template<>
6174: SinkResultType EnumUtil::FromString<SinkResultType>(const char *value) {
6175: 	if (StringUtil::Equals(value, "NEED_MORE_INPUT")) {
6176: 		return SinkResultType::NEED_MORE_INPUT;
6177: 	}
6178: 	if (StringUtil::Equals(value, "FINISHED")) {
6179: 		return SinkResultType::FINISHED;
6180: 	}
6181: 	if (StringUtil::Equals(value, "BLOCKED")) {
6182: 		return SinkResultType::BLOCKED;
6183: 	}
6184: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6185: }
6186: 
6187: template<>
6188: const char* EnumUtil::ToChars<SourceResultType>(SourceResultType value) {
6189: 	switch(value) {
6190: 	case SourceResultType::HAVE_MORE_OUTPUT:
6191: 		return "HAVE_MORE_OUTPUT";
6192: 	case SourceResultType::FINISHED:
6193: 		return "FINISHED";
6194: 	case SourceResultType::BLOCKED:
6195: 		return "BLOCKED";
6196: 	default:
6197: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6198: 	}
6199: }
6200: 
6201: template<>
6202: SourceResultType EnumUtil::FromString<SourceResultType>(const char *value) {
6203: 	if (StringUtil::Equals(value, "HAVE_MORE_OUTPUT")) {
6204: 		return SourceResultType::HAVE_MORE_OUTPUT;
6205: 	}
6206: 	if (StringUtil::Equals(value, "FINISHED")) {
6207: 		return SourceResultType::FINISHED;
6208: 	}
6209: 	if (StringUtil::Equals(value, "BLOCKED")) {
6210: 		return SourceResultType::BLOCKED;
6211: 	}
6212: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6213: }
6214: 
6215: template<>
6216: const char* EnumUtil::ToChars<StatementReturnType>(StatementReturnType value) {
6217: 	switch(value) {
6218: 	case StatementReturnType::QUERY_RESULT:
6219: 		return "QUERY_RESULT";
6220: 	case StatementReturnType::CHANGED_ROWS:
6221: 		return "CHANGED_ROWS";
6222: 	case StatementReturnType::NOTHING:
6223: 		return "NOTHING";
6224: 	default:
6225: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6226: 	}
6227: }
6228: 
6229: template<>
6230: StatementReturnType EnumUtil::FromString<StatementReturnType>(const char *value) {
6231: 	if (StringUtil::Equals(value, "QUERY_RESULT")) {
6232: 		return StatementReturnType::QUERY_RESULT;
6233: 	}
6234: 	if (StringUtil::Equals(value, "CHANGED_ROWS")) {
6235: 		return StatementReturnType::CHANGED_ROWS;
6236: 	}
6237: 	if (StringUtil::Equals(value, "NOTHING")) {
6238: 		return StatementReturnType::NOTHING;
6239: 	}
6240: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6241: }
6242: 
6243: template<>
6244: const char* EnumUtil::ToChars<StatementType>(StatementType value) {
6245: 	switch(value) {
6246: 	case StatementType::INVALID_STATEMENT:
6247: 		return "INVALID_STATEMENT";
6248: 	case StatementType::SELECT_STATEMENT:
6249: 		return "SELECT_STATEMENT";
6250: 	case StatementType::INSERT_STATEMENT:
6251: 		return "INSERT_STATEMENT";
6252: 	case StatementType::UPDATE_STATEMENT:
6253: 		return "UPDATE_STATEMENT";
6254: 	case StatementType::CREATE_STATEMENT:
6255: 		return "CREATE_STATEMENT";
6256: 	case StatementType::DELETE_STATEMENT:
6257: 		return "DELETE_STATEMENT";
6258: 	case StatementType::PREPARE_STATEMENT:
6259: 		return "PREPARE_STATEMENT";
6260: 	case StatementType::EXECUTE_STATEMENT:
6261: 		return "EXECUTE_STATEMENT";
6262: 	case StatementType::ALTER_STATEMENT:
6263: 		return "ALTER_STATEMENT";
6264: 	case StatementType::TRANSACTION_STATEMENT:
6265: 		return "TRANSACTION_STATEMENT";
6266: 	case StatementType::COPY_STATEMENT:
6267: 		return "COPY_STATEMENT";
6268: 	case StatementType::ANALYZE_STATEMENT:
6269: 		return "ANALYZE_STATEMENT";
6270: 	case StatementType::VARIABLE_SET_STATEMENT:
6271: 		return "VARIABLE_SET_STATEMENT";
6272: 	case StatementType::CREATE_FUNC_STATEMENT:
6273: 		return "CREATE_FUNC_STATEMENT";
6274: 	case StatementType::EXPLAIN_STATEMENT:
6275: 		return "EXPLAIN_STATEMENT";
6276: 	case StatementType::DROP_STATEMENT:
6277: 		return "DROP_STATEMENT";
6278: 	case StatementType::EXPORT_STATEMENT:
6279: 		return "EXPORT_STATEMENT";
6280: 	case StatementType::PRAGMA_STATEMENT:
6281: 		return "PRAGMA_STATEMENT";
6282: 	case StatementType::VACUUM_STATEMENT:
6283: 		return "VACUUM_STATEMENT";
6284: 	case StatementType::CALL_STATEMENT:
6285: 		return "CALL_STATEMENT";
6286: 	case StatementType::SET_STATEMENT:
6287: 		return "SET_STATEMENT";
6288: 	case StatementType::LOAD_STATEMENT:
6289: 		return "LOAD_STATEMENT";
6290: 	case StatementType::RELATION_STATEMENT:
6291: 		return "RELATION_STATEMENT";
6292: 	case StatementType::EXTENSION_STATEMENT:
6293: 		return "EXTENSION_STATEMENT";
6294: 	case StatementType::LOGICAL_PLAN_STATEMENT:
6295: 		return "LOGICAL_PLAN_STATEMENT";
6296: 	case StatementType::ATTACH_STATEMENT:
6297: 		return "ATTACH_STATEMENT";
6298: 	case StatementType::DETACH_STATEMENT:
6299: 		return "DETACH_STATEMENT";
6300: 	case StatementType::MULTI_STATEMENT:
6301: 		return "MULTI_STATEMENT";
6302: 	case StatementType::COPY_DATABASE_STATEMENT:
6303: 		return "COPY_DATABASE_STATEMENT";
6304: 	case StatementType::UPDATE_EXTENSIONS_STATEMENT:
6305: 		return "UPDATE_EXTENSIONS_STATEMENT";
6306: 	default:
6307: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6308: 	}
6309: }
6310: 
6311: template<>
6312: StatementType EnumUtil::FromString<StatementType>(const char *value) {
6313: 	if (StringUtil::Equals(value, "INVALID_STATEMENT")) {
6314: 		return StatementType::INVALID_STATEMENT;
6315: 	}
6316: 	if (StringUtil::Equals(value, "SELECT_STATEMENT")) {
6317: 		return StatementType::SELECT_STATEMENT;
6318: 	}
6319: 	if (StringUtil::Equals(value, "INSERT_STATEMENT")) {
6320: 		return StatementType::INSERT_STATEMENT;
6321: 	}
6322: 	if (StringUtil::Equals(value, "UPDATE_STATEMENT")) {
6323: 		return StatementType::UPDATE_STATEMENT;
6324: 	}
6325: 	if (StringUtil::Equals(value, "CREATE_STATEMENT")) {
6326: 		return StatementType::CREATE_STATEMENT;
6327: 	}
6328: 	if (StringUtil::Equals(value, "DELETE_STATEMENT")) {
6329: 		return StatementType::DELETE_STATEMENT;
6330: 	}
6331: 	if (StringUtil::Equals(value, "PREPARE_STATEMENT")) {
6332: 		return StatementType::PREPARE_STATEMENT;
6333: 	}
6334: 	if (StringUtil::Equals(value, "EXECUTE_STATEMENT")) {
6335: 		return StatementType::EXECUTE_STATEMENT;
6336: 	}
6337: 	if (StringUtil::Equals(value, "ALTER_STATEMENT")) {
6338: 		return StatementType::ALTER_STATEMENT;
6339: 	}
6340: 	if (StringUtil::Equals(value, "TRANSACTION_STATEMENT")) {
6341: 		return StatementType::TRANSACTION_STATEMENT;
6342: 	}
6343: 	if (StringUtil::Equals(value, "COPY_STATEMENT")) {
6344: 		return StatementType::COPY_STATEMENT;
6345: 	}
6346: 	if (StringUtil::Equals(value, "ANALYZE_STATEMENT")) {
6347: 		return StatementType::ANALYZE_STATEMENT;
6348: 	}
6349: 	if (StringUtil::Equals(value, "VARIABLE_SET_STATEMENT")) {
6350: 		return StatementType::VARIABLE_SET_STATEMENT;
6351: 	}
6352: 	if (StringUtil::Equals(value, "CREATE_FUNC_STATEMENT")) {
6353: 		return StatementType::CREATE_FUNC_STATEMENT;
6354: 	}
6355: 	if (StringUtil::Equals(value, "EXPLAIN_STATEMENT")) {
6356: 		return StatementType::EXPLAIN_STATEMENT;
6357: 	}
6358: 	if (StringUtil::Equals(value, "DROP_STATEMENT")) {
6359: 		return StatementType::DROP_STATEMENT;
6360: 	}
6361: 	if (StringUtil::Equals(value, "EXPORT_STATEMENT")) {
6362: 		return StatementType::EXPORT_STATEMENT;
6363: 	}
6364: 	if (StringUtil::Equals(value, "PRAGMA_STATEMENT")) {
6365: 		return StatementType::PRAGMA_STATEMENT;
6366: 	}
6367: 	if (StringUtil::Equals(value, "VACUUM_STATEMENT")) {
6368: 		return StatementType::VACUUM_STATEMENT;
6369: 	}
6370: 	if (StringUtil::Equals(value, "CALL_STATEMENT")) {
6371: 		return StatementType::CALL_STATEMENT;
6372: 	}
6373: 	if (StringUtil::Equals(value, "SET_STATEMENT")) {
6374: 		return StatementType::SET_STATEMENT;
6375: 	}
6376: 	if (StringUtil::Equals(value, "LOAD_STATEMENT")) {
6377: 		return StatementType::LOAD_STATEMENT;
6378: 	}
6379: 	if (StringUtil::Equals(value, "RELATION_STATEMENT")) {
6380: 		return StatementType::RELATION_STATEMENT;
6381: 	}
6382: 	if (StringUtil::Equals(value, "EXTENSION_STATEMENT")) {
6383: 		return StatementType::EXTENSION_STATEMENT;
6384: 	}
6385: 	if (StringUtil::Equals(value, "LOGICAL_PLAN_STATEMENT")) {
6386: 		return StatementType::LOGICAL_PLAN_STATEMENT;
6387: 	}
6388: 	if (StringUtil::Equals(value, "ATTACH_STATEMENT")) {
6389: 		return StatementType::ATTACH_STATEMENT;
6390: 	}
6391: 	if (StringUtil::Equals(value, "DETACH_STATEMENT")) {
6392: 		return StatementType::DETACH_STATEMENT;
6393: 	}
6394: 	if (StringUtil::Equals(value, "MULTI_STATEMENT")) {
6395: 		return StatementType::MULTI_STATEMENT;
6396: 	}
6397: 	if (StringUtil::Equals(value, "COPY_DATABASE_STATEMENT")) {
6398: 		return StatementType::COPY_DATABASE_STATEMENT;
6399: 	}
6400: 	if (StringUtil::Equals(value, "UPDATE_EXTENSIONS_STATEMENT")) {
6401: 		return StatementType::UPDATE_EXTENSIONS_STATEMENT;
6402: 	}
6403: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6404: }
6405: 
6406: template<>
6407: const char* EnumUtil::ToChars<StatisticsType>(StatisticsType value) {
6408: 	switch(value) {
6409: 	case StatisticsType::NUMERIC_STATS:
6410: 		return "NUMERIC_STATS";
6411: 	case StatisticsType::STRING_STATS:
6412: 		return "STRING_STATS";
6413: 	case StatisticsType::LIST_STATS:
6414: 		return "LIST_STATS";
6415: 	case StatisticsType::STRUCT_STATS:
6416: 		return "STRUCT_STATS";
6417: 	case StatisticsType::BASE_STATS:
6418: 		return "BASE_STATS";
6419: 	case StatisticsType::ARRAY_STATS:
6420: 		return "ARRAY_STATS";
6421: 	default:
6422: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6423: 	}
6424: }
6425: 
6426: template<>
6427: StatisticsType EnumUtil::FromString<StatisticsType>(const char *value) {
6428: 	if (StringUtil::Equals(value, "NUMERIC_STATS")) {
6429: 		return StatisticsType::NUMERIC_STATS;
6430: 	}
6431: 	if (StringUtil::Equals(value, "STRING_STATS")) {
6432: 		return StatisticsType::STRING_STATS;
6433: 	}
6434: 	if (StringUtil::Equals(value, "LIST_STATS")) {
6435: 		return StatisticsType::LIST_STATS;
6436: 	}
6437: 	if (StringUtil::Equals(value, "STRUCT_STATS")) {
6438: 		return StatisticsType::STRUCT_STATS;
6439: 	}
6440: 	if (StringUtil::Equals(value, "BASE_STATS")) {
6441: 		return StatisticsType::BASE_STATS;
6442: 	}
6443: 	if (StringUtil::Equals(value, "ARRAY_STATS")) {
6444: 		return StatisticsType::ARRAY_STATS;
6445: 	}
6446: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6447: }
6448: 
6449: template<>
6450: const char* EnumUtil::ToChars<StatsInfo>(StatsInfo value) {
6451: 	switch(value) {
6452: 	case StatsInfo::CAN_HAVE_NULL_VALUES:
6453: 		return "CAN_HAVE_NULL_VALUES";
6454: 	case StatsInfo::CANNOT_HAVE_NULL_VALUES:
6455: 		return "CANNOT_HAVE_NULL_VALUES";
6456: 	case StatsInfo::CAN_HAVE_VALID_VALUES:
6457: 		return "CAN_HAVE_VALID_VALUES";
6458: 	case StatsInfo::CANNOT_HAVE_VALID_VALUES:
6459: 		return "CANNOT_HAVE_VALID_VALUES";
6460: 	case StatsInfo::CAN_HAVE_NULL_AND_VALID_VALUES:
6461: 		return "CAN_HAVE_NULL_AND_VALID_VALUES";
6462: 	default:
6463: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6464: 	}
6465: }
6466: 
6467: template<>
6468: StatsInfo EnumUtil::FromString<StatsInfo>(const char *value) {
6469: 	if (StringUtil::Equals(value, "CAN_HAVE_NULL_VALUES")) {
6470: 		return StatsInfo::CAN_HAVE_NULL_VALUES;
6471: 	}
6472: 	if (StringUtil::Equals(value, "CANNOT_HAVE_NULL_VALUES")) {
6473: 		return StatsInfo::CANNOT_HAVE_NULL_VALUES;
6474: 	}
6475: 	if (StringUtil::Equals(value, "CAN_HAVE_VALID_VALUES")) {
6476: 		return StatsInfo::CAN_HAVE_VALID_VALUES;
6477: 	}
6478: 	if (StringUtil::Equals(value, "CANNOT_HAVE_VALID_VALUES")) {
6479: 		return StatsInfo::CANNOT_HAVE_VALID_VALUES;
6480: 	}
6481: 	if (StringUtil::Equals(value, "CAN_HAVE_NULL_AND_VALID_VALUES")) {
6482: 		return StatsInfo::CAN_HAVE_NULL_AND_VALID_VALUES;
6483: 	}
6484: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6485: }
6486: 
6487: template<>
6488: const char* EnumUtil::ToChars<StrTimeSpecifier>(StrTimeSpecifier value) {
6489: 	switch(value) {
6490: 	case StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME:
6491: 		return "ABBREVIATED_WEEKDAY_NAME";
6492: 	case StrTimeSpecifier::FULL_WEEKDAY_NAME:
6493: 		return "FULL_WEEKDAY_NAME";
6494: 	case StrTimeSpecifier::WEEKDAY_DECIMAL:
6495: 		return "WEEKDAY_DECIMAL";
6496: 	case StrTimeSpecifier::DAY_OF_MONTH_PADDED:
6497: 		return "DAY_OF_MONTH_PADDED";
6498: 	case StrTimeSpecifier::DAY_OF_MONTH:
6499: 		return "DAY_OF_MONTH";
6500: 	case StrTimeSpecifier::ABBREVIATED_MONTH_NAME:
6501: 		return "ABBREVIATED_MONTH_NAME";
6502: 	case StrTimeSpecifier::FULL_MONTH_NAME:
6503: 		return "FULL_MONTH_NAME";
6504: 	case StrTimeSpecifier::MONTH_DECIMAL_PADDED:
6505: 		return "MONTH_DECIMAL_PADDED";
6506: 	case StrTimeSpecifier::MONTH_DECIMAL:
6507: 		return "MONTH_DECIMAL";
6508: 	case StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED:
6509: 		return "YEAR_WITHOUT_CENTURY_PADDED";
6510: 	case StrTimeSpecifier::YEAR_WITHOUT_CENTURY:
6511: 		return "YEAR_WITHOUT_CENTURY";
6512: 	case StrTimeSpecifier::YEAR_DECIMAL:
6513: 		return "YEAR_DECIMAL";
6514: 	case StrTimeSpecifier::HOUR_24_PADDED:
6515: 		return "HOUR_24_PADDED";
6516: 	case StrTimeSpecifier::HOUR_24_DECIMAL:
6517: 		return "HOUR_24_DECIMAL";
6518: 	case StrTimeSpecifier::HOUR_12_PADDED:
6519: 		return "HOUR_12_PADDED";
6520: 	case StrTimeSpecifier::HOUR_12_DECIMAL:
6521: 		return "HOUR_12_DECIMAL";
6522: 	case StrTimeSpecifier::AM_PM:
6523: 		return "AM_PM";
6524: 	case StrTimeSpecifier::MINUTE_PADDED:
6525: 		return "MINUTE_PADDED";
6526: 	case StrTimeSpecifier::MINUTE_DECIMAL:
6527: 		return "MINUTE_DECIMAL";
6528: 	case StrTimeSpecifier::SECOND_PADDED:
6529: 		return "SECOND_PADDED";
6530: 	case StrTimeSpecifier::SECOND_DECIMAL:
6531: 		return "SECOND_DECIMAL";
6532: 	case StrTimeSpecifier::MICROSECOND_PADDED:
6533: 		return "MICROSECOND_PADDED";
6534: 	case StrTimeSpecifier::MILLISECOND_PADDED:
6535: 		return "MILLISECOND_PADDED";
6536: 	case StrTimeSpecifier::UTC_OFFSET:
6537: 		return "UTC_OFFSET";
6538: 	case StrTimeSpecifier::TZ_NAME:
6539: 		return "TZ_NAME";
6540: 	case StrTimeSpecifier::DAY_OF_YEAR_PADDED:
6541: 		return "DAY_OF_YEAR_PADDED";
6542: 	case StrTimeSpecifier::DAY_OF_YEAR_DECIMAL:
6543: 		return "DAY_OF_YEAR_DECIMAL";
6544: 	case StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:
6545: 		return "WEEK_NUMBER_PADDED_SUN_FIRST";
6546: 	case StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:
6547: 		return "WEEK_NUMBER_PADDED_MON_FIRST";
6548: 	case StrTimeSpecifier::LOCALE_APPROPRIATE_DATE_AND_TIME:
6549: 		return "LOCALE_APPROPRIATE_DATE_AND_TIME";
6550: 	case StrTimeSpecifier::LOCALE_APPROPRIATE_DATE:
6551: 		return "LOCALE_APPROPRIATE_DATE";
6552: 	case StrTimeSpecifier::LOCALE_APPROPRIATE_TIME:
6553: 		return "LOCALE_APPROPRIATE_TIME";
6554: 	case StrTimeSpecifier::NANOSECOND_PADDED:
6555: 		return "NANOSECOND_PADDED";
6556: 	case StrTimeSpecifier::YEAR_ISO:
6557: 		return "YEAR_ISO";
6558: 	case StrTimeSpecifier::WEEKDAY_ISO:
6559: 		return "WEEKDAY_ISO";
6560: 	case StrTimeSpecifier::WEEK_NUMBER_ISO:
6561: 		return "WEEK_NUMBER_ISO";
6562: 	default:
6563: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6564: 	}
6565: }
6566: 
6567: template<>
6568: StrTimeSpecifier EnumUtil::FromString<StrTimeSpecifier>(const char *value) {
6569: 	if (StringUtil::Equals(value, "ABBREVIATED_WEEKDAY_NAME")) {
6570: 		return StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME;
6571: 	}
6572: 	if (StringUtil::Equals(value, "FULL_WEEKDAY_NAME")) {
6573: 		return StrTimeSpecifier::FULL_WEEKDAY_NAME;
6574: 	}
6575: 	if (StringUtil::Equals(value, "WEEKDAY_DECIMAL")) {
6576: 		return StrTimeSpecifier::WEEKDAY_DECIMAL;
6577: 	}
6578: 	if (StringUtil::Equals(value, "DAY_OF_MONTH_PADDED")) {
6579: 		return StrTimeSpecifier::DAY_OF_MONTH_PADDED;
6580: 	}
6581: 	if (StringUtil::Equals(value, "DAY_OF_MONTH")) {
6582: 		return StrTimeSpecifier::DAY_OF_MONTH;
6583: 	}
6584: 	if (StringUtil::Equals(value, "ABBREVIATED_MONTH_NAME")) {
6585: 		return StrTimeSpecifier::ABBREVIATED_MONTH_NAME;
6586: 	}
6587: 	if (StringUtil::Equals(value, "FULL_MONTH_NAME")) {
6588: 		return StrTimeSpecifier::FULL_MONTH_NAME;
6589: 	}
6590: 	if (StringUtil::Equals(value, "MONTH_DECIMAL_PADDED")) {
6591: 		return StrTimeSpecifier::MONTH_DECIMAL_PADDED;
6592: 	}
6593: 	if (StringUtil::Equals(value, "MONTH_DECIMAL")) {
6594: 		return StrTimeSpecifier::MONTH_DECIMAL;
6595: 	}
6596: 	if (StringUtil::Equals(value, "YEAR_WITHOUT_CENTURY_PADDED")) {
6597: 		return StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED;
6598: 	}
6599: 	if (StringUtil::Equals(value, "YEAR_WITHOUT_CENTURY")) {
6600: 		return StrTimeSpecifier::YEAR_WITHOUT_CENTURY;
6601: 	}
6602: 	if (StringUtil::Equals(value, "YEAR_DECIMAL")) {
6603: 		return StrTimeSpecifier::YEAR_DECIMAL;
6604: 	}
6605: 	if (StringUtil::Equals(value, "HOUR_24_PADDED")) {
6606: 		return StrTimeSpecifier::HOUR_24_PADDED;
6607: 	}
6608: 	if (StringUtil::Equals(value, "HOUR_24_DECIMAL")) {
6609: 		return StrTimeSpecifier::HOUR_24_DECIMAL;
6610: 	}
6611: 	if (StringUtil::Equals(value, "HOUR_12_PADDED")) {
6612: 		return StrTimeSpecifier::HOUR_12_PADDED;
6613: 	}
6614: 	if (StringUtil::Equals(value, "HOUR_12_DECIMAL")) {
6615: 		return StrTimeSpecifier::HOUR_12_DECIMAL;
6616: 	}
6617: 	if (StringUtil::Equals(value, "AM_PM")) {
6618: 		return StrTimeSpecifier::AM_PM;
6619: 	}
6620: 	if (StringUtil::Equals(value, "MINUTE_PADDED")) {
6621: 		return StrTimeSpecifier::MINUTE_PADDED;
6622: 	}
6623: 	if (StringUtil::Equals(value, "MINUTE_DECIMAL")) {
6624: 		return StrTimeSpecifier::MINUTE_DECIMAL;
6625: 	}
6626: 	if (StringUtil::Equals(value, "SECOND_PADDED")) {
6627: 		return StrTimeSpecifier::SECOND_PADDED;
6628: 	}
6629: 	if (StringUtil::Equals(value, "SECOND_DECIMAL")) {
6630: 		return StrTimeSpecifier::SECOND_DECIMAL;
6631: 	}
6632: 	if (StringUtil::Equals(value, "MICROSECOND_PADDED")) {
6633: 		return StrTimeSpecifier::MICROSECOND_PADDED;
6634: 	}
6635: 	if (StringUtil::Equals(value, "MILLISECOND_PADDED")) {
6636: 		return StrTimeSpecifier::MILLISECOND_PADDED;
6637: 	}
6638: 	if (StringUtil::Equals(value, "UTC_OFFSET")) {
6639: 		return StrTimeSpecifier::UTC_OFFSET;
6640: 	}
6641: 	if (StringUtil::Equals(value, "TZ_NAME")) {
6642: 		return StrTimeSpecifier::TZ_NAME;
6643: 	}
6644: 	if (StringUtil::Equals(value, "DAY_OF_YEAR_PADDED")) {
6645: 		return StrTimeSpecifier::DAY_OF_YEAR_PADDED;
6646: 	}
6647: 	if (StringUtil::Equals(value, "DAY_OF_YEAR_DECIMAL")) {
6648: 		return StrTimeSpecifier::DAY_OF_YEAR_DECIMAL;
6649: 	}
6650: 	if (StringUtil::Equals(value, "WEEK_NUMBER_PADDED_SUN_FIRST")) {
6651: 		return StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST;
6652: 	}
6653: 	if (StringUtil::Equals(value, "WEEK_NUMBER_PADDED_MON_FIRST")) {
6654: 		return StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST;
6655: 	}
6656: 	if (StringUtil::Equals(value, "LOCALE_APPROPRIATE_DATE_AND_TIME")) {
6657: 		return StrTimeSpecifier::LOCALE_APPROPRIATE_DATE_AND_TIME;
6658: 	}
6659: 	if (StringUtil::Equals(value, "LOCALE_APPROPRIATE_DATE")) {
6660: 		return StrTimeSpecifier::LOCALE_APPROPRIATE_DATE;
6661: 	}
6662: 	if (StringUtil::Equals(value, "LOCALE_APPROPRIATE_TIME")) {
6663: 		return StrTimeSpecifier::LOCALE_APPROPRIATE_TIME;
6664: 	}
6665: 	if (StringUtil::Equals(value, "NANOSECOND_PADDED")) {
6666: 		return StrTimeSpecifier::NANOSECOND_PADDED;
6667: 	}
6668: 	if (StringUtil::Equals(value, "YEAR_ISO")) {
6669: 		return StrTimeSpecifier::YEAR_ISO;
6670: 	}
6671: 	if (StringUtil::Equals(value, "WEEKDAY_ISO")) {
6672: 		return StrTimeSpecifier::WEEKDAY_ISO;
6673: 	}
6674: 	if (StringUtil::Equals(value, "WEEK_NUMBER_ISO")) {
6675: 		return StrTimeSpecifier::WEEK_NUMBER_ISO;
6676: 	}
6677: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6678: }
6679: 
6680: template<>
6681: const char* EnumUtil::ToChars<SubqueryType>(SubqueryType value) {
6682: 	switch(value) {
6683: 	case SubqueryType::INVALID:
6684: 		return "INVALID";
6685: 	case SubqueryType::SCALAR:
6686: 		return "SCALAR";
6687: 	case SubqueryType::EXISTS:
6688: 		return "EXISTS";
6689: 	case SubqueryType::NOT_EXISTS:
6690: 		return "NOT_EXISTS";
6691: 	case SubqueryType::ANY:
6692: 		return "ANY";
6693: 	default:
6694: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6695: 	}
6696: }
6697: 
6698: template<>
6699: SubqueryType EnumUtil::FromString<SubqueryType>(const char *value) {
6700: 	if (StringUtil::Equals(value, "INVALID")) {
6701: 		return SubqueryType::INVALID;
6702: 	}
6703: 	if (StringUtil::Equals(value, "SCALAR")) {
6704: 		return SubqueryType::SCALAR;
6705: 	}
6706: 	if (StringUtil::Equals(value, "EXISTS")) {
6707: 		return SubqueryType::EXISTS;
6708: 	}
6709: 	if (StringUtil::Equals(value, "NOT_EXISTS")) {
6710: 		return SubqueryType::NOT_EXISTS;
6711: 	}
6712: 	if (StringUtil::Equals(value, "ANY")) {
6713: 		return SubqueryType::ANY;
6714: 	}
6715: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6716: }
6717: 
6718: template<>
6719: const char* EnumUtil::ToChars<TableColumnType>(TableColumnType value) {
6720: 	switch(value) {
6721: 	case TableColumnType::STANDARD:
6722: 		return "STANDARD";
6723: 	case TableColumnType::GENERATED:
6724: 		return "GENERATED";
6725: 	default:
6726: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6727: 	}
6728: }
6729: 
6730: template<>
6731: TableColumnType EnumUtil::FromString<TableColumnType>(const char *value) {
6732: 	if (StringUtil::Equals(value, "STANDARD")) {
6733: 		return TableColumnType::STANDARD;
6734: 	}
6735: 	if (StringUtil::Equals(value, "GENERATED")) {
6736: 		return TableColumnType::GENERATED;
6737: 	}
6738: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6739: }
6740: 
6741: template<>
6742: const char* EnumUtil::ToChars<TableFilterType>(TableFilterType value) {
6743: 	switch(value) {
6744: 	case TableFilterType::CONSTANT_COMPARISON:
6745: 		return "CONSTANT_COMPARISON";
6746: 	case TableFilterType::IS_NULL:
6747: 		return "IS_NULL";
6748: 	case TableFilterType::IS_NOT_NULL:
6749: 		return "IS_NOT_NULL";
6750: 	case TableFilterType::CONJUNCTION_OR:
6751: 		return "CONJUNCTION_OR";
6752: 	case TableFilterType::CONJUNCTION_AND:
6753: 		return "CONJUNCTION_AND";
6754: 	case TableFilterType::STRUCT_EXTRACT:
6755: 		return "STRUCT_EXTRACT";
6756: 	default:
6757: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6758: 	}
6759: }
6760: 
6761: template<>
6762: TableFilterType EnumUtil::FromString<TableFilterType>(const char *value) {
6763: 	if (StringUtil::Equals(value, "CONSTANT_COMPARISON")) {
6764: 		return TableFilterType::CONSTANT_COMPARISON;
6765: 	}
6766: 	if (StringUtil::Equals(value, "IS_NULL")) {
6767: 		return TableFilterType::IS_NULL;
6768: 	}
6769: 	if (StringUtil::Equals(value, "IS_NOT_NULL")) {
6770: 		return TableFilterType::IS_NOT_NULL;
6771: 	}
6772: 	if (StringUtil::Equals(value, "CONJUNCTION_OR")) {
6773: 		return TableFilterType::CONJUNCTION_OR;
6774: 	}
6775: 	if (StringUtil::Equals(value, "CONJUNCTION_AND")) {
6776: 		return TableFilterType::CONJUNCTION_AND;
6777: 	}
6778: 	if (StringUtil::Equals(value, "STRUCT_EXTRACT")) {
6779: 		return TableFilterType::STRUCT_EXTRACT;
6780: 	}
6781: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6782: }
6783: 
6784: template<>
6785: const char* EnumUtil::ToChars<TableReferenceType>(TableReferenceType value) {
6786: 	switch(value) {
6787: 	case TableReferenceType::INVALID:
6788: 		return "INVALID";
6789: 	case TableReferenceType::BASE_TABLE:
6790: 		return "BASE_TABLE";
6791: 	case TableReferenceType::SUBQUERY:
6792: 		return "SUBQUERY";
6793: 	case TableReferenceType::JOIN:
6794: 		return "JOIN";
6795: 	case TableReferenceType::TABLE_FUNCTION:
6796: 		return "TABLE_FUNCTION";
6797: 	case TableReferenceType::EXPRESSION_LIST:
6798: 		return "EXPRESSION_LIST";
6799: 	case TableReferenceType::CTE:
6800: 		return "CTE";
6801: 	case TableReferenceType::EMPTY_FROM:
6802: 		return "EMPTY";
6803: 	case TableReferenceType::PIVOT:
6804: 		return "PIVOT";
6805: 	case TableReferenceType::SHOW_REF:
6806: 		return "SHOW_REF";
6807: 	case TableReferenceType::COLUMN_DATA:
6808: 		return "COLUMN_DATA";
6809: 	default:
6810: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6811: 	}
6812: }
6813: 
6814: template<>
6815: TableReferenceType EnumUtil::FromString<TableReferenceType>(const char *value) {
6816: 	if (StringUtil::Equals(value, "INVALID")) {
6817: 		return TableReferenceType::INVALID;
6818: 	}
6819: 	if (StringUtil::Equals(value, "BASE_TABLE")) {
6820: 		return TableReferenceType::BASE_TABLE;
6821: 	}
6822: 	if (StringUtil::Equals(value, "SUBQUERY")) {
6823: 		return TableReferenceType::SUBQUERY;
6824: 	}
6825: 	if (StringUtil::Equals(value, "JOIN")) {
6826: 		return TableReferenceType::JOIN;
6827: 	}
6828: 	if (StringUtil::Equals(value, "TABLE_FUNCTION")) {
6829: 		return TableReferenceType::TABLE_FUNCTION;
6830: 	}
6831: 	if (StringUtil::Equals(value, "EXPRESSION_LIST")) {
6832: 		return TableReferenceType::EXPRESSION_LIST;
6833: 	}
6834: 	if (StringUtil::Equals(value, "CTE")) {
6835: 		return TableReferenceType::CTE;
6836: 	}
6837: 	if (StringUtil::Equals(value, "EMPTY")) {
6838: 		return TableReferenceType::EMPTY_FROM;
6839: 	}
6840: 	if (StringUtil::Equals(value, "PIVOT")) {
6841: 		return TableReferenceType::PIVOT;
6842: 	}
6843: 	if (StringUtil::Equals(value, "SHOW_REF")) {
6844: 		return TableReferenceType::SHOW_REF;
6845: 	}
6846: 	if (StringUtil::Equals(value, "COLUMN_DATA")) {
6847: 		return TableReferenceType::COLUMN_DATA;
6848: 	}
6849: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6850: }
6851: 
6852: template<>
6853: const char* EnumUtil::ToChars<TableScanType>(TableScanType value) {
6854: 	switch(value) {
6855: 	case TableScanType::TABLE_SCAN_REGULAR:
6856: 		return "TABLE_SCAN_REGULAR";
6857: 	case TableScanType::TABLE_SCAN_COMMITTED_ROWS:
6858: 		return "TABLE_SCAN_COMMITTED_ROWS";
6859: 	case TableScanType::TABLE_SCAN_COMMITTED_ROWS_DISALLOW_UPDATES:
6860: 		return "TABLE_SCAN_COMMITTED_ROWS_DISALLOW_UPDATES";
6861: 	case TableScanType::TABLE_SCAN_COMMITTED_ROWS_OMIT_PERMANENTLY_DELETED:
6862: 		return "TABLE_SCAN_COMMITTED_ROWS_OMIT_PERMANENTLY_DELETED";
6863: 	case TableScanType::TABLE_SCAN_LATEST_COMMITTED_ROWS:
6864: 		return "TABLE_SCAN_LATEST_COMMITTED_ROWS";
6865: 	default:
6866: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6867: 	}
6868: }
6869: 
6870: template<>
6871: TableScanType EnumUtil::FromString<TableScanType>(const char *value) {
6872: 	if (StringUtil::Equals(value, "TABLE_SCAN_REGULAR")) {
6873: 		return TableScanType::TABLE_SCAN_REGULAR;
6874: 	}
6875: 	if (StringUtil::Equals(value, "TABLE_SCAN_COMMITTED_ROWS")) {
6876: 		return TableScanType::TABLE_SCAN_COMMITTED_ROWS;
6877: 	}
6878: 	if (StringUtil::Equals(value, "TABLE_SCAN_COMMITTED_ROWS_DISALLOW_UPDATES")) {
6879: 		return TableScanType::TABLE_SCAN_COMMITTED_ROWS_DISALLOW_UPDATES;
6880: 	}
6881: 	if (StringUtil::Equals(value, "TABLE_SCAN_COMMITTED_ROWS_OMIT_PERMANENTLY_DELETED")) {
6882: 		return TableScanType::TABLE_SCAN_COMMITTED_ROWS_OMIT_PERMANENTLY_DELETED;
6883: 	}
6884: 	if (StringUtil::Equals(value, "TABLE_SCAN_LATEST_COMMITTED_ROWS")) {
6885: 		return TableScanType::TABLE_SCAN_LATEST_COMMITTED_ROWS;
6886: 	}
6887: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6888: }
6889: 
6890: template<>
6891: const char* EnumUtil::ToChars<TaskExecutionMode>(TaskExecutionMode value) {
6892: 	switch(value) {
6893: 	case TaskExecutionMode::PROCESS_ALL:
6894: 		return "PROCESS_ALL";
6895: 	case TaskExecutionMode::PROCESS_PARTIAL:
6896: 		return "PROCESS_PARTIAL";
6897: 	default:
6898: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6899: 	}
6900: }
6901: 
6902: template<>
6903: TaskExecutionMode EnumUtil::FromString<TaskExecutionMode>(const char *value) {
6904: 	if (StringUtil::Equals(value, "PROCESS_ALL")) {
6905: 		return TaskExecutionMode::PROCESS_ALL;
6906: 	}
6907: 	if (StringUtil::Equals(value, "PROCESS_PARTIAL")) {
6908: 		return TaskExecutionMode::PROCESS_PARTIAL;
6909: 	}
6910: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6911: }
6912: 
6913: template<>
6914: const char* EnumUtil::ToChars<TaskExecutionResult>(TaskExecutionResult value) {
6915: 	switch(value) {
6916: 	case TaskExecutionResult::TASK_FINISHED:
6917: 		return "TASK_FINISHED";
6918: 	case TaskExecutionResult::TASK_NOT_FINISHED:
6919: 		return "TASK_NOT_FINISHED";
6920: 	case TaskExecutionResult::TASK_ERROR:
6921: 		return "TASK_ERROR";
6922: 	case TaskExecutionResult::TASK_BLOCKED:
6923: 		return "TASK_BLOCKED";
6924: 	default:
6925: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6926: 	}
6927: }
6928: 
6929: template<>
6930: TaskExecutionResult EnumUtil::FromString<TaskExecutionResult>(const char *value) {
6931: 	if (StringUtil::Equals(value, "TASK_FINISHED")) {
6932: 		return TaskExecutionResult::TASK_FINISHED;
6933: 	}
6934: 	if (StringUtil::Equals(value, "TASK_NOT_FINISHED")) {
6935: 		return TaskExecutionResult::TASK_NOT_FINISHED;
6936: 	}
6937: 	if (StringUtil::Equals(value, "TASK_ERROR")) {
6938: 		return TaskExecutionResult::TASK_ERROR;
6939: 	}
6940: 	if (StringUtil::Equals(value, "TASK_BLOCKED")) {
6941: 		return TaskExecutionResult::TASK_BLOCKED;
6942: 	}
6943: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6944: }
6945: 
6946: template<>
6947: const char* EnumUtil::ToChars<TimestampCastResult>(TimestampCastResult value) {
6948: 	switch(value) {
6949: 	case TimestampCastResult::SUCCESS:
6950: 		return "SUCCESS";
6951: 	case TimestampCastResult::ERROR_INCORRECT_FORMAT:
6952: 		return "ERROR_INCORRECT_FORMAT";
6953: 	case TimestampCastResult::ERROR_NON_UTC_TIMEZONE:
6954: 		return "ERROR_NON_UTC_TIMEZONE";
6955: 	default:
6956: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6957: 	}
6958: }
6959: 
6960: template<>
6961: TimestampCastResult EnumUtil::FromString<TimestampCastResult>(const char *value) {
6962: 	if (StringUtil::Equals(value, "SUCCESS")) {
6963: 		return TimestampCastResult::SUCCESS;
6964: 	}
6965: 	if (StringUtil::Equals(value, "ERROR_INCORRECT_FORMAT")) {
6966: 		return TimestampCastResult::ERROR_INCORRECT_FORMAT;
6967: 	}
6968: 	if (StringUtil::Equals(value, "ERROR_NON_UTC_TIMEZONE")) {
6969: 		return TimestampCastResult::ERROR_NON_UTC_TIMEZONE;
6970: 	}
6971: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
6972: }
6973: 
6974: template<>
6975: const char* EnumUtil::ToChars<TransactionType>(TransactionType value) {
6976: 	switch(value) {
6977: 	case TransactionType::INVALID:
6978: 		return "INVALID";
6979: 	case TransactionType::BEGIN_TRANSACTION:
6980: 		return "BEGIN_TRANSACTION";
6981: 	case TransactionType::COMMIT:
6982: 		return "COMMIT";
6983: 	case TransactionType::ROLLBACK:
6984: 		return "ROLLBACK";
6985: 	default:
6986: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
6987: 	}
6988: }
6989: 
6990: template<>
6991: TransactionType EnumUtil::FromString<TransactionType>(const char *value) {
6992: 	if (StringUtil::Equals(value, "INVALID")) {
6993: 		return TransactionType::INVALID;
6994: 	}
6995: 	if (StringUtil::Equals(value, "BEGIN_TRANSACTION")) {
6996: 		return TransactionType::BEGIN_TRANSACTION;
6997: 	}
6998: 	if (StringUtil::Equals(value, "COMMIT")) {
6999: 		return TransactionType::COMMIT;
7000: 	}
7001: 	if (StringUtil::Equals(value, "ROLLBACK")) {
7002: 		return TransactionType::ROLLBACK;
7003: 	}
7004: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7005: }
7006: 
7007: template<>
7008: const char* EnumUtil::ToChars<TupleDataPinProperties>(TupleDataPinProperties value) {
7009: 	switch(value) {
7010: 	case TupleDataPinProperties::INVALID:
7011: 		return "INVALID";
7012: 	case TupleDataPinProperties::KEEP_EVERYTHING_PINNED:
7013: 		return "KEEP_EVERYTHING_PINNED";
7014: 	case TupleDataPinProperties::UNPIN_AFTER_DONE:
7015: 		return "UNPIN_AFTER_DONE";
7016: 	case TupleDataPinProperties::DESTROY_AFTER_DONE:
7017: 		return "DESTROY_AFTER_DONE";
7018: 	case TupleDataPinProperties::ALREADY_PINNED:
7019: 		return "ALREADY_PINNED";
7020: 	default:
7021: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7022: 	}
7023: }
7024: 
7025: template<>
7026: TupleDataPinProperties EnumUtil::FromString<TupleDataPinProperties>(const char *value) {
7027: 	if (StringUtil::Equals(value, "INVALID")) {
7028: 		return TupleDataPinProperties::INVALID;
7029: 	}
7030: 	if (StringUtil::Equals(value, "KEEP_EVERYTHING_PINNED")) {
7031: 		return TupleDataPinProperties::KEEP_EVERYTHING_PINNED;
7032: 	}
7033: 	if (StringUtil::Equals(value, "UNPIN_AFTER_DONE")) {
7034: 		return TupleDataPinProperties::UNPIN_AFTER_DONE;
7035: 	}
7036: 	if (StringUtil::Equals(value, "DESTROY_AFTER_DONE")) {
7037: 		return TupleDataPinProperties::DESTROY_AFTER_DONE;
7038: 	}
7039: 	if (StringUtil::Equals(value, "ALREADY_PINNED")) {
7040: 		return TupleDataPinProperties::ALREADY_PINNED;
7041: 	}
7042: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7043: }
7044: 
7045: template<>
7046: const char* EnumUtil::ToChars<UndoFlags>(UndoFlags value) {
7047: 	switch(value) {
7048: 	case UndoFlags::EMPTY_ENTRY:
7049: 		return "EMPTY_ENTRY";
7050: 	case UndoFlags::CATALOG_ENTRY:
7051: 		return "CATALOG_ENTRY";
7052: 	case UndoFlags::INSERT_TUPLE:
7053: 		return "INSERT_TUPLE";
7054: 	case UndoFlags::DELETE_TUPLE:
7055: 		return "DELETE_TUPLE";
7056: 	case UndoFlags::UPDATE_TUPLE:
7057: 		return "UPDATE_TUPLE";
7058: 	case UndoFlags::SEQUENCE_VALUE:
7059: 		return "SEQUENCE_VALUE";
7060: 	default:
7061: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7062: 	}
7063: }
7064: 
7065: template<>
7066: UndoFlags EnumUtil::FromString<UndoFlags>(const char *value) {
7067: 	if (StringUtil::Equals(value, "EMPTY_ENTRY")) {
7068: 		return UndoFlags::EMPTY_ENTRY;
7069: 	}
7070: 	if (StringUtil::Equals(value, "CATALOG_ENTRY")) {
7071: 		return UndoFlags::CATALOG_ENTRY;
7072: 	}
7073: 	if (StringUtil::Equals(value, "INSERT_TUPLE")) {
7074: 		return UndoFlags::INSERT_TUPLE;
7075: 	}
7076: 	if (StringUtil::Equals(value, "DELETE_TUPLE")) {
7077: 		return UndoFlags::DELETE_TUPLE;
7078: 	}
7079: 	if (StringUtil::Equals(value, "UPDATE_TUPLE")) {
7080: 		return UndoFlags::UPDATE_TUPLE;
7081: 	}
7082: 	if (StringUtil::Equals(value, "SEQUENCE_VALUE")) {
7083: 		return UndoFlags::SEQUENCE_VALUE;
7084: 	}
7085: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7086: }
7087: 
7088: template<>
7089: const char* EnumUtil::ToChars<UnionInvalidReason>(UnionInvalidReason value) {
7090: 	switch(value) {
7091: 	case UnionInvalidReason::VALID:
7092: 		return "VALID";
7093: 	case UnionInvalidReason::TAG_OUT_OF_RANGE:
7094: 		return "TAG_OUT_OF_RANGE";
7095: 	case UnionInvalidReason::NO_MEMBERS:
7096: 		return "NO_MEMBERS";
7097: 	case UnionInvalidReason::VALIDITY_OVERLAP:
7098: 		return "VALIDITY_OVERLAP";
7099: 	case UnionInvalidReason::TAG_MISMATCH:
7100: 		return "TAG_MISMATCH";
7101: 	case UnionInvalidReason::NULL_TAG:
7102: 		return "NULL_TAG";
7103: 	default:
7104: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7105: 	}
7106: }
7107: 
7108: template<>
7109: UnionInvalidReason EnumUtil::FromString<UnionInvalidReason>(const char *value) {
7110: 	if (StringUtil::Equals(value, "VALID")) {
7111: 		return UnionInvalidReason::VALID;
7112: 	}
7113: 	if (StringUtil::Equals(value, "TAG_OUT_OF_RANGE")) {
7114: 		return UnionInvalidReason::TAG_OUT_OF_RANGE;
7115: 	}
7116: 	if (StringUtil::Equals(value, "NO_MEMBERS")) {
7117: 		return UnionInvalidReason::NO_MEMBERS;
7118: 	}
7119: 	if (StringUtil::Equals(value, "VALIDITY_OVERLAP")) {
7120: 		return UnionInvalidReason::VALIDITY_OVERLAP;
7121: 	}
7122: 	if (StringUtil::Equals(value, "TAG_MISMATCH")) {
7123: 		return UnionInvalidReason::TAG_MISMATCH;
7124: 	}
7125: 	if (StringUtil::Equals(value, "NULL_TAG")) {
7126: 		return UnionInvalidReason::NULL_TAG;
7127: 	}
7128: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7129: }
7130: 
7131: template<>
7132: const char* EnumUtil::ToChars<VectorAuxiliaryDataType>(VectorAuxiliaryDataType value) {
7133: 	switch(value) {
7134: 	case VectorAuxiliaryDataType::ARROW_AUXILIARY:
7135: 		return "ARROW_AUXILIARY";
7136: 	default:
7137: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7138: 	}
7139: }
7140: 
7141: template<>
7142: VectorAuxiliaryDataType EnumUtil::FromString<VectorAuxiliaryDataType>(const char *value) {
7143: 	if (StringUtil::Equals(value, "ARROW_AUXILIARY")) {
7144: 		return VectorAuxiliaryDataType::ARROW_AUXILIARY;
7145: 	}
7146: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7147: }
7148: 
7149: template<>
7150: const char* EnumUtil::ToChars<VectorBufferType>(VectorBufferType value) {
7151: 	switch(value) {
7152: 	case VectorBufferType::STANDARD_BUFFER:
7153: 		return "STANDARD_BUFFER";
7154: 	case VectorBufferType::DICTIONARY_BUFFER:
7155: 		return "DICTIONARY_BUFFER";
7156: 	case VectorBufferType::VECTOR_CHILD_BUFFER:
7157: 		return "VECTOR_CHILD_BUFFER";
7158: 	case VectorBufferType::STRING_BUFFER:
7159: 		return "STRING_BUFFER";
7160: 	case VectorBufferType::FSST_BUFFER:
7161: 		return "FSST_BUFFER";
7162: 	case VectorBufferType::STRUCT_BUFFER:
7163: 		return "STRUCT_BUFFER";
7164: 	case VectorBufferType::LIST_BUFFER:
7165: 		return "LIST_BUFFER";
7166: 	case VectorBufferType::MANAGED_BUFFER:
7167: 		return "MANAGED_BUFFER";
7168: 	case VectorBufferType::OPAQUE_BUFFER:
7169: 		return "OPAQUE_BUFFER";
7170: 	case VectorBufferType::ARRAY_BUFFER:
7171: 		return "ARRAY_BUFFER";
7172: 	default:
7173: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7174: 	}
7175: }
7176: 
7177: template<>
7178: VectorBufferType EnumUtil::FromString<VectorBufferType>(const char *value) {
7179: 	if (StringUtil::Equals(value, "STANDARD_BUFFER")) {
7180: 		return VectorBufferType::STANDARD_BUFFER;
7181: 	}
7182: 	if (StringUtil::Equals(value, "DICTIONARY_BUFFER")) {
7183: 		return VectorBufferType::DICTIONARY_BUFFER;
7184: 	}
7185: 	if (StringUtil::Equals(value, "VECTOR_CHILD_BUFFER")) {
7186: 		return VectorBufferType::VECTOR_CHILD_BUFFER;
7187: 	}
7188: 	if (StringUtil::Equals(value, "STRING_BUFFER")) {
7189: 		return VectorBufferType::STRING_BUFFER;
7190: 	}
7191: 	if (StringUtil::Equals(value, "FSST_BUFFER")) {
7192: 		return VectorBufferType::FSST_BUFFER;
7193: 	}
7194: 	if (StringUtil::Equals(value, "STRUCT_BUFFER")) {
7195: 		return VectorBufferType::STRUCT_BUFFER;
7196: 	}
7197: 	if (StringUtil::Equals(value, "LIST_BUFFER")) {
7198: 		return VectorBufferType::LIST_BUFFER;
7199: 	}
7200: 	if (StringUtil::Equals(value, "MANAGED_BUFFER")) {
7201: 		return VectorBufferType::MANAGED_BUFFER;
7202: 	}
7203: 	if (StringUtil::Equals(value, "OPAQUE_BUFFER")) {
7204: 		return VectorBufferType::OPAQUE_BUFFER;
7205: 	}
7206: 	if (StringUtil::Equals(value, "ARRAY_BUFFER")) {
7207: 		return VectorBufferType::ARRAY_BUFFER;
7208: 	}
7209: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7210: }
7211: 
7212: template<>
7213: const char* EnumUtil::ToChars<VectorType>(VectorType value) {
7214: 	switch(value) {
7215: 	case VectorType::FLAT_VECTOR:
7216: 		return "FLAT_VECTOR";
7217: 	case VectorType::FSST_VECTOR:
7218: 		return "FSST_VECTOR";
7219: 	case VectorType::CONSTANT_VECTOR:
7220: 		return "CONSTANT_VECTOR";
7221: 	case VectorType::DICTIONARY_VECTOR:
7222: 		return "DICTIONARY_VECTOR";
7223: 	case VectorType::SEQUENCE_VECTOR:
7224: 		return "SEQUENCE_VECTOR";
7225: 	default:
7226: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7227: 	}
7228: }
7229: 
7230: template<>
7231: VectorType EnumUtil::FromString<VectorType>(const char *value) {
7232: 	if (StringUtil::Equals(value, "FLAT_VECTOR")) {
7233: 		return VectorType::FLAT_VECTOR;
7234: 	}
7235: 	if (StringUtil::Equals(value, "FSST_VECTOR")) {
7236: 		return VectorType::FSST_VECTOR;
7237: 	}
7238: 	if (StringUtil::Equals(value, "CONSTANT_VECTOR")) {
7239: 		return VectorType::CONSTANT_VECTOR;
7240: 	}
7241: 	if (StringUtil::Equals(value, "DICTIONARY_VECTOR")) {
7242: 		return VectorType::DICTIONARY_VECTOR;
7243: 	}
7244: 	if (StringUtil::Equals(value, "SEQUENCE_VECTOR")) {
7245: 		return VectorType::SEQUENCE_VECTOR;
7246: 	}
7247: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7248: }
7249: 
7250: template<>
7251: const char* EnumUtil::ToChars<VerificationType>(VerificationType value) {
7252: 	switch(value) {
7253: 	case VerificationType::ORIGINAL:
7254: 		return "ORIGINAL";
7255: 	case VerificationType::COPIED:
7256: 		return "COPIED";
7257: 	case VerificationType::DESERIALIZED:
7258: 		return "DESERIALIZED";
7259: 	case VerificationType::PARSED:
7260: 		return "PARSED";
7261: 	case VerificationType::UNOPTIMIZED:
7262: 		return "UNOPTIMIZED";
7263: 	case VerificationType::NO_OPERATOR_CACHING:
7264: 		return "NO_OPERATOR_CACHING";
7265: 	case VerificationType::PREPARED:
7266: 		return "PREPARED";
7267: 	case VerificationType::EXTERNAL:
7268: 		return "EXTERNAL";
7269: 	case VerificationType::FETCH_ROW_AS_SCAN:
7270: 		return "FETCH_ROW_AS_SCAN";
7271: 	case VerificationType::INVALID:
7272: 		return "INVALID";
7273: 	default:
7274: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7275: 	}
7276: }
7277: 
7278: template<>
7279: VerificationType EnumUtil::FromString<VerificationType>(const char *value) {
7280: 	if (StringUtil::Equals(value, "ORIGINAL")) {
7281: 		return VerificationType::ORIGINAL;
7282: 	}
7283: 	if (StringUtil::Equals(value, "COPIED")) {
7284: 		return VerificationType::COPIED;
7285: 	}
7286: 	if (StringUtil::Equals(value, "DESERIALIZED")) {
7287: 		return VerificationType::DESERIALIZED;
7288: 	}
7289: 	if (StringUtil::Equals(value, "PARSED")) {
7290: 		return VerificationType::PARSED;
7291: 	}
7292: 	if (StringUtil::Equals(value, "UNOPTIMIZED")) {
7293: 		return VerificationType::UNOPTIMIZED;
7294: 	}
7295: 	if (StringUtil::Equals(value, "NO_OPERATOR_CACHING")) {
7296: 		return VerificationType::NO_OPERATOR_CACHING;
7297: 	}
7298: 	if (StringUtil::Equals(value, "PREPARED")) {
7299: 		return VerificationType::PREPARED;
7300: 	}
7301: 	if (StringUtil::Equals(value, "EXTERNAL")) {
7302: 		return VerificationType::EXTERNAL;
7303: 	}
7304: 	if (StringUtil::Equals(value, "FETCH_ROW_AS_SCAN")) {
7305: 		return VerificationType::FETCH_ROW_AS_SCAN;
7306: 	}
7307: 	if (StringUtil::Equals(value, "INVALID")) {
7308: 		return VerificationType::INVALID;
7309: 	}
7310: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7311: }
7312: 
7313: template<>
7314: const char* EnumUtil::ToChars<VerifyExistenceType>(VerifyExistenceType value) {
7315: 	switch(value) {
7316: 	case VerifyExistenceType::APPEND:
7317: 		return "APPEND";
7318: 	case VerifyExistenceType::APPEND_FK:
7319: 		return "APPEND_FK";
7320: 	case VerifyExistenceType::DELETE_FK:
7321: 		return "DELETE_FK";
7322: 	default:
7323: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7324: 	}
7325: }
7326: 
7327: template<>
7328: VerifyExistenceType EnumUtil::FromString<VerifyExistenceType>(const char *value) {
7329: 	if (StringUtil::Equals(value, "APPEND")) {
7330: 		return VerifyExistenceType::APPEND;
7331: 	}
7332: 	if (StringUtil::Equals(value, "APPEND_FK")) {
7333: 		return VerifyExistenceType::APPEND_FK;
7334: 	}
7335: 	if (StringUtil::Equals(value, "DELETE_FK")) {
7336: 		return VerifyExistenceType::DELETE_FK;
7337: 	}
7338: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7339: }
7340: 
7341: template<>
7342: const char* EnumUtil::ToChars<WALType>(WALType value) {
7343: 	switch(value) {
7344: 	case WALType::INVALID:
7345: 		return "INVALID";
7346: 	case WALType::CREATE_TABLE:
7347: 		return "CREATE_TABLE";
7348: 	case WALType::DROP_TABLE:
7349: 		return "DROP_TABLE";
7350: 	case WALType::CREATE_SCHEMA:
7351: 		return "CREATE_SCHEMA";
7352: 	case WALType::DROP_SCHEMA:
7353: 		return "DROP_SCHEMA";
7354: 	case WALType::CREATE_VIEW:
7355: 		return "CREATE_VIEW";
7356: 	case WALType::DROP_VIEW:
7357: 		return "DROP_VIEW";
7358: 	case WALType::CREATE_SEQUENCE:
7359: 		return "CREATE_SEQUENCE";
7360: 	case WALType::DROP_SEQUENCE:
7361: 		return "DROP_SEQUENCE";
7362: 	case WALType::SEQUENCE_VALUE:
7363: 		return "SEQUENCE_VALUE";
7364: 	case WALType::CREATE_MACRO:
7365: 		return "CREATE_MACRO";
7366: 	case WALType::DROP_MACRO:
7367: 		return "DROP_MACRO";
7368: 	case WALType::CREATE_TYPE:
7369: 		return "CREATE_TYPE";
7370: 	case WALType::DROP_TYPE:
7371: 		return "DROP_TYPE";
7372: 	case WALType::ALTER_INFO:
7373: 		return "ALTER_INFO";
7374: 	case WALType::CREATE_TABLE_MACRO:
7375: 		return "CREATE_TABLE_MACRO";
7376: 	case WALType::DROP_TABLE_MACRO:
7377: 		return "DROP_TABLE_MACRO";
7378: 	case WALType::CREATE_INDEX:
7379: 		return "CREATE_INDEX";
7380: 	case WALType::DROP_INDEX:
7381: 		return "DROP_INDEX";
7382: 	case WALType::USE_TABLE:
7383: 		return "USE_TABLE";
7384: 	case WALType::INSERT_TUPLE:
7385: 		return "INSERT_TUPLE";
7386: 	case WALType::DELETE_TUPLE:
7387: 		return "DELETE_TUPLE";
7388: 	case WALType::UPDATE_TUPLE:
7389: 		return "UPDATE_TUPLE";
7390: 	case WALType::WAL_VERSION:
7391: 		return "WAL_VERSION";
7392: 	case WALType::CHECKPOINT:
7393: 		return "CHECKPOINT";
7394: 	case WALType::WAL_FLUSH:
7395: 		return "WAL_FLUSH";
7396: 	default:
7397: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7398: 	}
7399: }
7400: 
7401: template<>
7402: WALType EnumUtil::FromString<WALType>(const char *value) {
7403: 	if (StringUtil::Equals(value, "INVALID")) {
7404: 		return WALType::INVALID;
7405: 	}
7406: 	if (StringUtil::Equals(value, "CREATE_TABLE")) {
7407: 		return WALType::CREATE_TABLE;
7408: 	}
7409: 	if (StringUtil::Equals(value, "DROP_TABLE")) {
7410: 		return WALType::DROP_TABLE;
7411: 	}
7412: 	if (StringUtil::Equals(value, "CREATE_SCHEMA")) {
7413: 		return WALType::CREATE_SCHEMA;
7414: 	}
7415: 	if (StringUtil::Equals(value, "DROP_SCHEMA")) {
7416: 		return WALType::DROP_SCHEMA;
7417: 	}
7418: 	if (StringUtil::Equals(value, "CREATE_VIEW")) {
7419: 		return WALType::CREATE_VIEW;
7420: 	}
7421: 	if (StringUtil::Equals(value, "DROP_VIEW")) {
7422: 		return WALType::DROP_VIEW;
7423: 	}
7424: 	if (StringUtil::Equals(value, "CREATE_SEQUENCE")) {
7425: 		return WALType::CREATE_SEQUENCE;
7426: 	}
7427: 	if (StringUtil::Equals(value, "DROP_SEQUENCE")) {
7428: 		return WALType::DROP_SEQUENCE;
7429: 	}
7430: 	if (StringUtil::Equals(value, "SEQUENCE_VALUE")) {
7431: 		return WALType::SEQUENCE_VALUE;
7432: 	}
7433: 	if (StringUtil::Equals(value, "CREATE_MACRO")) {
7434: 		return WALType::CREATE_MACRO;
7435: 	}
7436: 	if (StringUtil::Equals(value, "DROP_MACRO")) {
7437: 		return WALType::DROP_MACRO;
7438: 	}
7439: 	if (StringUtil::Equals(value, "CREATE_TYPE")) {
7440: 		return WALType::CREATE_TYPE;
7441: 	}
7442: 	if (StringUtil::Equals(value, "DROP_TYPE")) {
7443: 		return WALType::DROP_TYPE;
7444: 	}
7445: 	if (StringUtil::Equals(value, "ALTER_INFO")) {
7446: 		return WALType::ALTER_INFO;
7447: 	}
7448: 	if (StringUtil::Equals(value, "CREATE_TABLE_MACRO")) {
7449: 		return WALType::CREATE_TABLE_MACRO;
7450: 	}
7451: 	if (StringUtil::Equals(value, "DROP_TABLE_MACRO")) {
7452: 		return WALType::DROP_TABLE_MACRO;
7453: 	}
7454: 	if (StringUtil::Equals(value, "CREATE_INDEX")) {
7455: 		return WALType::CREATE_INDEX;
7456: 	}
7457: 	if (StringUtil::Equals(value, "DROP_INDEX")) {
7458: 		return WALType::DROP_INDEX;
7459: 	}
7460: 	if (StringUtil::Equals(value, "USE_TABLE")) {
7461: 		return WALType::USE_TABLE;
7462: 	}
7463: 	if (StringUtil::Equals(value, "INSERT_TUPLE")) {
7464: 		return WALType::INSERT_TUPLE;
7465: 	}
7466: 	if (StringUtil::Equals(value, "DELETE_TUPLE")) {
7467: 		return WALType::DELETE_TUPLE;
7468: 	}
7469: 	if (StringUtil::Equals(value, "UPDATE_TUPLE")) {
7470: 		return WALType::UPDATE_TUPLE;
7471: 	}
7472: 	if (StringUtil::Equals(value, "WAL_VERSION")) {
7473: 		return WALType::WAL_VERSION;
7474: 	}
7475: 	if (StringUtil::Equals(value, "CHECKPOINT")) {
7476: 		return WALType::CHECKPOINT;
7477: 	}
7478: 	if (StringUtil::Equals(value, "WAL_FLUSH")) {
7479: 		return WALType::WAL_FLUSH;
7480: 	}
7481: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7482: }
7483: 
7484: template<>
7485: const char* EnumUtil::ToChars<WindowAggregationMode>(WindowAggregationMode value) {
7486: 	switch(value) {
7487: 	case WindowAggregationMode::WINDOW:
7488: 		return "WINDOW";
7489: 	case WindowAggregationMode::COMBINE:
7490: 		return "COMBINE";
7491: 	case WindowAggregationMode::SEPARATE:
7492: 		return "SEPARATE";
7493: 	default:
7494: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7495: 	}
7496: }
7497: 
7498: template<>
7499: WindowAggregationMode EnumUtil::FromString<WindowAggregationMode>(const char *value) {
7500: 	if (StringUtil::Equals(value, "WINDOW")) {
7501: 		return WindowAggregationMode::WINDOW;
7502: 	}
7503: 	if (StringUtil::Equals(value, "COMBINE")) {
7504: 		return WindowAggregationMode::COMBINE;
7505: 	}
7506: 	if (StringUtil::Equals(value, "SEPARATE")) {
7507: 		return WindowAggregationMode::SEPARATE;
7508: 	}
7509: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7510: }
7511: 
7512: template<>
7513: const char* EnumUtil::ToChars<WindowBoundary>(WindowBoundary value) {
7514: 	switch(value) {
7515: 	case WindowBoundary::INVALID:
7516: 		return "INVALID";
7517: 	case WindowBoundary::UNBOUNDED_PRECEDING:
7518: 		return "UNBOUNDED_PRECEDING";
7519: 	case WindowBoundary::UNBOUNDED_FOLLOWING:
7520: 		return "UNBOUNDED_FOLLOWING";
7521: 	case WindowBoundary::CURRENT_ROW_RANGE:
7522: 		return "CURRENT_ROW_RANGE";
7523: 	case WindowBoundary::CURRENT_ROW_ROWS:
7524: 		return "CURRENT_ROW_ROWS";
7525: 	case WindowBoundary::EXPR_PRECEDING_ROWS:
7526: 		return "EXPR_PRECEDING_ROWS";
7527: 	case WindowBoundary::EXPR_FOLLOWING_ROWS:
7528: 		return "EXPR_FOLLOWING_ROWS";
7529: 	case WindowBoundary::EXPR_PRECEDING_RANGE:
7530: 		return "EXPR_PRECEDING_RANGE";
7531: 	case WindowBoundary::EXPR_FOLLOWING_RANGE:
7532: 		return "EXPR_FOLLOWING_RANGE";
7533: 	default:
7534: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7535: 	}
7536: }
7537: 
7538: template<>
7539: WindowBoundary EnumUtil::FromString<WindowBoundary>(const char *value) {
7540: 	if (StringUtil::Equals(value, "INVALID")) {
7541: 		return WindowBoundary::INVALID;
7542: 	}
7543: 	if (StringUtil::Equals(value, "UNBOUNDED_PRECEDING")) {
7544: 		return WindowBoundary::UNBOUNDED_PRECEDING;
7545: 	}
7546: 	if (StringUtil::Equals(value, "UNBOUNDED_FOLLOWING")) {
7547: 		return WindowBoundary::UNBOUNDED_FOLLOWING;
7548: 	}
7549: 	if (StringUtil::Equals(value, "CURRENT_ROW_RANGE")) {
7550: 		return WindowBoundary::CURRENT_ROW_RANGE;
7551: 	}
7552: 	if (StringUtil::Equals(value, "CURRENT_ROW_ROWS")) {
7553: 		return WindowBoundary::CURRENT_ROW_ROWS;
7554: 	}
7555: 	if (StringUtil::Equals(value, "EXPR_PRECEDING_ROWS")) {
7556: 		return WindowBoundary::EXPR_PRECEDING_ROWS;
7557: 	}
7558: 	if (StringUtil::Equals(value, "EXPR_FOLLOWING_ROWS")) {
7559: 		return WindowBoundary::EXPR_FOLLOWING_ROWS;
7560: 	}
7561: 	if (StringUtil::Equals(value, "EXPR_PRECEDING_RANGE")) {
7562: 		return WindowBoundary::EXPR_PRECEDING_RANGE;
7563: 	}
7564: 	if (StringUtil::Equals(value, "EXPR_FOLLOWING_RANGE")) {
7565: 		return WindowBoundary::EXPR_FOLLOWING_RANGE;
7566: 	}
7567: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7568: }
7569: 
7570: template<>
7571: const char* EnumUtil::ToChars<WindowExcludeMode>(WindowExcludeMode value) {
7572: 	switch(value) {
7573: 	case WindowExcludeMode::NO_OTHER:
7574: 		return "NO_OTHER";
7575: 	case WindowExcludeMode::CURRENT_ROW:
7576: 		return "CURRENT_ROW";
7577: 	case WindowExcludeMode::GROUP:
7578: 		return "GROUP";
7579: 	case WindowExcludeMode::TIES:
7580: 		return "TIES";
7581: 	default:
7582: 		throw NotImplementedException(StringUtil::Format("Enum value: '%d' not implemented", value));
7583: 	}
7584: }
7585: 
7586: template<>
7587: WindowExcludeMode EnumUtil::FromString<WindowExcludeMode>(const char *value) {
7588: 	if (StringUtil::Equals(value, "NO_OTHER")) {
7589: 		return WindowExcludeMode::NO_OTHER;
7590: 	}
7591: 	if (StringUtil::Equals(value, "CURRENT_ROW")) {
7592: 		return WindowExcludeMode::CURRENT_ROW;
7593: 	}
7594: 	if (StringUtil::Equals(value, "GROUP")) {
7595: 		return WindowExcludeMode::GROUP;
7596: 	}
7597: 	if (StringUtil::Equals(value, "TIES")) {
7598: 		return WindowExcludeMode::TIES;
7599: 	}
7600: 	throw NotImplementedException(StringUtil::Format("Enum value: '%s' not implemented", value));
7601: }
7602: 
7603: }
7604: 
[end of src/common/enum_util.cpp]
[start of src/execution/operator/persistent/physical_copy_to_file.cpp]
1: #include "duckdb/execution/operator/persistent/physical_copy_to_file.hpp"
2: 
3: #include "duckdb/common/file_opener.hpp"
4: #include "duckdb/common/file_system.hpp"
5: #include "duckdb/common/hive_partitioning.hpp"
6: #include "duckdb/common/string_util.hpp"
7: #include "duckdb/common/types/uuid.hpp"
8: #include "duckdb/common/vector_operations/vector_operations.hpp"
9: #include "duckdb/storage/storage_lock.hpp"
10: #include "duckdb/common/value_operations/value_operations.hpp"
11: #include <algorithm>
12: 
13: namespace duckdb {
14: 
15: struct PartitionWriteInfo {
16: 	unique_ptr<GlobalFunctionData> global_state;
17: };
18: 
19: struct VectorOfValuesHashFunction {
20: 	uint64_t operator()(const vector<Value> &values) const {
21: 		hash_t result = 0;
22: 		for (auto &val : values) {
23: 			result ^= val.Hash();
24: 		}
25: 		return result;
26: 	}
27: };
28: 
29: struct VectorOfValuesEquality {
30: 	bool operator()(const vector<Value> &a, const vector<Value> &b) const {
31: 		if (a.size() != b.size()) {
32: 			return false;
33: 		}
34: 		for (idx_t i = 0; i < a.size(); i++) {
35: 			if (ValueOperations::DistinctFrom(a[i], b[i])) {
36: 				return false;
37: 			}
38: 		}
39: 		return true;
40: 	}
41: };
42: 
43: template <class T>
44: using vector_of_value_map_t = unordered_map<vector<Value>, T, VectorOfValuesHashFunction, VectorOfValuesEquality>;
45: 
46: class CopyToFunctionGlobalState : public GlobalSinkState {
47: public:
48: 	explicit CopyToFunctionGlobalState(unique_ptr<GlobalFunctionData> global_state)
49: 	    : rows_copied(0), last_file_offset(0), global_state(std::move(global_state)) {
50: 	}
51: 	StorageLock lock;
52: 	atomic<idx_t> rows_copied;
53: 	atomic<idx_t> last_file_offset;
54: 	unique_ptr<GlobalFunctionData> global_state;
55: 	//! Created directories
56: 	unordered_set<string> created_directories;
57: 	//! shared state for HivePartitionedColumnData
58: 	shared_ptr<GlobalHivePartitionState> partition_state;
59: 
60: 	void CreateDir(const string &dir_path, FileSystem &fs) {
61: 		if (created_directories.find(dir_path) != created_directories.end()) {
62: 			// already attempted to create this directory
63: 			return;
64: 		}
65: 		if (!fs.DirectoryExists(dir_path)) {
66: 			fs.CreateDirectory(dir_path);
67: 		}
68: 		created_directories.insert(dir_path);
69: 	}
70: 
71: 	string GetOrCreateDirectory(const vector<idx_t> &cols, const vector<string> &names, const vector<Value> &values,
72: 	                            string path, FileSystem &fs) {
73: 		CreateDir(path, fs);
74: 		for (idx_t i = 0; i < cols.size(); i++) {
75: 			const auto &partition_col_name = names[cols[i]];
76: 			const auto &partition_value = values[i];
77: 			string p_dir = partition_col_name + "=" + partition_value.ToString();
78: 			path = fs.JoinPath(path, p_dir);
79: 			CreateDir(path, fs);
80: 		}
81: 		return path;
82: 	}
83: 
84: 	void FinalizePartition(ClientContext &context, const PhysicalCopyToFile &op, PartitionWriteInfo &info) {
85: 		if (!info.global_state) {
86: 			// already finalized
87: 			return;
88: 		}
89: 		// finalize the partition
90: 		op.function.copy_to_finalize(context, *op.bind_data, *info.global_state);
91: 		info.global_state.reset();
92: 	}
93: 
94: 	void FinalizePartitions(ClientContext &context, const PhysicalCopyToFile &op) {
95: 		// finalize any remaining partitions
96: 		for (auto &entry : active_partitioned_writes) {
97: 			FinalizePartition(context, op, *entry.second);
98: 		}
99: 	}
100: 
101: 	PartitionWriteInfo &GetPartitionWriteInfo(ExecutionContext &context, const PhysicalCopyToFile &op,
102: 	                                          const vector<Value> &values) {
103: 		auto l = lock.GetExclusiveLock();
104: 		// check if we have already started writing this partition
105: 		auto entry = active_partitioned_writes.find(values);
106: 		if (entry != active_partitioned_writes.end()) {
107: 			// we have - continue writing in this partition
108: 			return *entry->second;
109: 		}
110: 		auto &fs = FileSystem::GetFileSystem(context.client);
111: 		// Create a writer for the current file
112: 		auto trimmed_path = op.GetTrimmedPath(context.client);
113: 		string hive_path = GetOrCreateDirectory(op.partition_columns, op.names, values, trimmed_path, fs);
114: 		string full_path(op.filename_pattern.CreateFilename(fs, hive_path, op.file_extension, 0));
115: 		// initialize writes
116: 		auto info = make_uniq<PartitionWriteInfo>();
117: 		info->global_state = op.function.copy_to_initialize_global(context.client, *op.bind_data, full_path);
118: 		auto &result = *info;
119: 		// store in active write map
120: 		active_partitioned_writes.insert(make_pair(values, std::move(info)));
121: 		return result;
122: 	}
123: 
124: private:
125: 	//! The active writes per partition (for partitioned write)
126: 	vector_of_value_map_t<unique_ptr<PartitionWriteInfo>> active_partitioned_writes;
127: };
128: 
129: string PhysicalCopyToFile::GetTrimmedPath(ClientContext &context) const {
130: 	auto &fs = FileSystem::GetFileSystem(context);
131: 	string trimmed_path = file_path;
132: 	StringUtil::RTrim(trimmed_path, fs.PathSeparator(trimmed_path));
133: 	return trimmed_path;
134: }
135: 
136: class CopyToFunctionLocalState : public LocalSinkState {
137: public:
138: 	explicit CopyToFunctionLocalState(unique_ptr<LocalFunctionData> local_state) : local_state(std::move(local_state)) {
139: 	}
140: 	unique_ptr<GlobalFunctionData> global_state;
141: 	unique_ptr<LocalFunctionData> local_state;
142: 
143: 	//! Buffers the tuples in partitions before writing
144: 	unique_ptr<HivePartitionedColumnData> part_buffer;
145: 	unique_ptr<PartitionedColumnDataAppendState> part_buffer_append_state;
146: 
147: 	idx_t append_count = 0;
148: 
149: 	void InitializeAppendState(ClientContext &context, const PhysicalCopyToFile &op,
150: 	                           CopyToFunctionGlobalState &gstate) {
151: 		part_buffer = make_uniq<HivePartitionedColumnData>(context, op.expected_types, op.partition_columns,
152: 		                                                   gstate.partition_state);
153: 		part_buffer_append_state = make_uniq<PartitionedColumnDataAppendState>();
154: 		part_buffer->InitializeAppendState(*part_buffer_append_state);
155: 		append_count = 0;
156: 	}
157: 
158: 	void AppendToPartition(ExecutionContext &context, const PhysicalCopyToFile &op, CopyToFunctionGlobalState &g,
159: 	                       DataChunk &chunk) {
160: 		if (!part_buffer) {
161: 			// re-initialize the append
162: 			InitializeAppendState(context.client, op, g);
163: 		}
164: 		part_buffer->Append(*part_buffer_append_state, chunk);
165: 		append_count += chunk.size();
166: 		if (append_count >= ClientConfig::GetConfig(context.client).partitioned_write_flush_threshold) {
167: 			// flush all cached partitions
168: 			FlushPartitions(context, op, g);
169: 		}
170: 	}
171: 
172: 	void ResetAppendState() {
173: 		part_buffer_append_state.reset();
174: 		part_buffer.reset();
175: 		append_count = 0;
176: 	}
177: 
178: 	void FlushPartitions(ExecutionContext &context, const PhysicalCopyToFile &op, CopyToFunctionGlobalState &g) {
179: 		if (!part_buffer) {
180: 			return;
181: 		}
182: 		part_buffer->FlushAppendState(*part_buffer_append_state);
183: 		auto &partitions = part_buffer->GetPartitions();
184: 		auto partition_key_map = part_buffer->GetReverseMap();
185: 
186: 		for (idx_t i = 0; i < partitions.size(); i++) {
187: 			auto entry = partition_key_map.find(i);
188: 			if (entry == partition_key_map.end()) {
189: 				continue;
190: 			}
191: 			// get the partition write info for this buffer
192: 			auto &info = g.GetPartitionWriteInfo(context, op, entry->second->values);
193: 
194: 			auto local_copy_state = op.function.copy_to_initialize_local(context, *op.bind_data);
195: 			// push the chunks into the write state
196: 			for (auto &chunk : partitions[i]->Chunks()) {
197: 				op.function.copy_to_sink(context, *op.bind_data, *info.global_state, *local_copy_state, chunk);
198: 			}
199: 			op.function.copy_to_combine(context, *op.bind_data, *info.global_state, *local_copy_state);
200: 			local_copy_state.reset();
201: 			partitions[i].reset();
202: 		}
203: 		ResetAppendState();
204: 	}
205: };
206: 
207: unique_ptr<GlobalFunctionData> PhysicalCopyToFile::CreateFileState(ClientContext &context,
208:                                                                    GlobalSinkState &sink) const {
209: 	auto &g = sink.Cast<CopyToFunctionGlobalState>();
210: 	idx_t this_file_offset = g.last_file_offset++;
211: 	auto &fs = FileSystem::GetFileSystem(context);
212: 	string output_path(filename_pattern.CreateFilename(fs, file_path, file_extension, this_file_offset));
213: 	return function.copy_to_initialize_global(context, *bind_data, output_path);
214: }
215: 
216: unique_ptr<LocalSinkState> PhysicalCopyToFile::GetLocalSinkState(ExecutionContext &context) const {
217: 	if (partition_output) {
218: 		auto &g = sink_state->Cast<CopyToFunctionGlobalState>();
219: 
220: 		auto state = make_uniq<CopyToFunctionLocalState>(nullptr);
221: 		state->InitializeAppendState(context.client, *this, g);
222: 		return std::move(state);
223: 	}
224: 	auto res = make_uniq<CopyToFunctionLocalState>(function.copy_to_initialize_local(context, *bind_data));
225: 	if (per_thread_output) {
226: 		res->global_state = CreateFileState(context.client, *sink_state);
227: 	}
228: 	return std::move(res);
229: }
230: 
231: void CheckDirectory(FileSystem &fs, const string &file_path, bool overwrite) {
232: 	if (fs.IsRemoteFile(file_path) && overwrite) {
233: 		// we only remove files for local file systems
234: 		// as remote file systems (e.g. S3) do not support RemoveFile
235: 		return;
236: 	}
237: 	vector<string> file_list;
238: 	vector<string> directory_list;
239: 	directory_list.push_back(file_path);
240: 	for (idx_t dir_idx = 0; dir_idx < directory_list.size(); dir_idx++) {
241: 		auto directory = directory_list[dir_idx];
242: 		fs.ListFiles(directory, [&](const string &path, bool is_directory) {
243: 			auto full_path = fs.JoinPath(directory, path);
244: 			if (is_directory) {
245: 				directory_list.emplace_back(std::move(full_path));
246: 			} else {
247: 				file_list.emplace_back(std::move(full_path));
248: 			}
249: 		});
250: 	}
251: 	if (file_list.empty()) {
252: 		return;
253: 	}
254: 	if (overwrite) {
255: 		for (auto &file : file_list) {
256: 			fs.RemoveFile(file);
257: 		}
258: 	} else {
259: 		throw IOException("Directory \"%s\" is not empty! Enable OVERWRITE_OR_IGNORE option to force writing",
260: 		                  file_path);
261: 	}
262: }
263: 
264: unique_ptr<GlobalSinkState> PhysicalCopyToFile::GetGlobalSinkState(ClientContext &context) const {
265: 
266: 	if (partition_output || per_thread_output || file_size_bytes.IsValid()) {
267: 		auto &fs = FileSystem::GetFileSystem(context);
268: 		if (fs.FileExists(file_path)) {
269: 			// the target file exists AND is a file (not a directory)
270: 			if (fs.IsRemoteFile(file_path)) {
271: 				// for remote files we cannot do anything - as we cannot delete the file
272: 				throw IOException("Cannot write to \"%s\" - it exists and is a file, not a directory!", file_path);
273: 			} else {
274: 				// for local files we can remove the file if OVERWRITE_OR_IGNORE is enabled
275: 				if (overwrite_or_ignore) {
276: 					fs.RemoveFile(file_path);
277: 				} else {
278: 					throw IOException("Cannot write to \"%s\" - it exists and is a file, not a directory! Enable "
279: 					                  "OVERWRITE_OR_IGNORE option to force writing",
280: 					                  file_path);
281: 				}
282: 			}
283: 		}
284: 		// what if the target exists and is a directory
285: 		if (!fs.DirectoryExists(file_path)) {
286: 			fs.CreateDirectory(file_path);
287: 		} else {
288: 			CheckDirectory(fs, file_path, overwrite_or_ignore);
289: 		}
290: 
291: 		auto state = make_uniq<CopyToFunctionGlobalState>(nullptr);
292: 		if (!per_thread_output && file_size_bytes.IsValid()) {
293: 			state->global_state = CreateFileState(context, *state);
294: 		}
295: 
296: 		if (partition_output) {
297: 			state->partition_state = make_shared_ptr<GlobalHivePartitionState>();
298: 		}
299: 
300: 		return std::move(state);
301: 	}
302: 
303: 	return make_uniq<CopyToFunctionGlobalState>(function.copy_to_initialize_global(context, *bind_data, file_path));
304: }
305: 
306: //===--------------------------------------------------------------------===//
307: // Sink
308: //===--------------------------------------------------------------------===//
309: void PhysicalCopyToFile::MoveTmpFile(ClientContext &context, const string &tmp_file_path) {
310: 	auto &fs = FileSystem::GetFileSystem(context);
311: 
312: 	auto path = StringUtil::GetFilePath(tmp_file_path);
313: 	auto base = StringUtil::GetFileName(tmp_file_path);
314: 
315: 	auto prefix = base.find("tmp_");
316: 	if (prefix == 0) {
317: 		base = base.substr(4);
318: 	}
319: 
320: 	auto file_path = fs.JoinPath(path, base);
321: 	if (fs.FileExists(file_path)) {
322: 		fs.RemoveFile(file_path);
323: 	}
324: 	fs.MoveFile(tmp_file_path, file_path);
325: }
326: 
327: PhysicalCopyToFile::PhysicalCopyToFile(vector<LogicalType> types, CopyFunction function_p,
328:                                        unique_ptr<FunctionData> bind_data, idx_t estimated_cardinality)
329:     : PhysicalOperator(PhysicalOperatorType::COPY_TO_FILE, std::move(types), estimated_cardinality),
330:       function(std::move(function_p)), bind_data(std::move(bind_data)), parallel(false) {
331: }
332: 
333: SinkResultType PhysicalCopyToFile::Sink(ExecutionContext &context, DataChunk &chunk, OperatorSinkInput &input) const {
334: 	auto &g = input.global_state.Cast<CopyToFunctionGlobalState>();
335: 	auto &l = input.local_state.Cast<CopyToFunctionLocalState>();
336: 
337: 	if (partition_output) {
338: 		l.AppendToPartition(context, *this, g, chunk);
339: 		return SinkResultType::NEED_MORE_INPUT;
340: 	}
341: 
342: 	g.rows_copied += chunk.size();
343: 
344: 	if (per_thread_output) {
345: 		auto &gstate = l.global_state;
346: 		function.copy_to_sink(context, *bind_data, *gstate, *l.local_state, chunk);
347: 
348: 		if (file_size_bytes.IsValid() && function.file_size_bytes(*gstate) > file_size_bytes.GetIndex()) {
349: 			function.copy_to_finalize(context.client, *bind_data, *gstate);
350: 			gstate = CreateFileState(context.client, *sink_state);
351: 		}
352: 		return SinkResultType::NEED_MORE_INPUT;
353: 	}
354: 
355: 	if (!file_size_bytes.IsValid()) {
356: 		function.copy_to_sink(context, *bind_data, *g.global_state, *l.local_state, chunk);
357: 		return SinkResultType::NEED_MORE_INPUT;
358: 	}
359: 
360: 	// FILE_SIZE_BYTES is set, but threads write to the same file, synchronize using lock
361: 	auto &gstate = g.global_state;
362: 	auto lock = g.lock.GetExclusiveLock();
363: 	if (function.file_size_bytes(*gstate) > file_size_bytes.GetIndex()) {
364: 		auto owned_gstate = std::move(gstate);
365: 		gstate = CreateFileState(context.client, *sink_state);
366: 		lock.reset();
367: 		function.copy_to_finalize(context.client, *bind_data, *owned_gstate);
368: 	} else {
369: 		lock.reset();
370: 	}
371: 
372: 	lock = g.lock.GetSharedLock();
373: 	function.copy_to_sink(context, *bind_data, *gstate, *l.local_state, chunk);
374: 
375: 	return SinkResultType::NEED_MORE_INPUT;
376: }
377: 
378: SinkCombineResultType PhysicalCopyToFile::Combine(ExecutionContext &context, OperatorSinkCombineInput &input) const {
379: 	auto &g = input.global_state.Cast<CopyToFunctionGlobalState>();
380: 	auto &l = input.local_state.Cast<CopyToFunctionLocalState>();
381: 
382: 	if (partition_output) {
383: 		// flush all remaining partitions
384: 		l.FlushPartitions(context, *this, g);
385: 	} else if (function.copy_to_combine) {
386: 		if (per_thread_output) {
387: 			// For PER_THREAD_OUTPUT, we can combine/finalize immediately
388: 			function.copy_to_combine(context, *bind_data, *l.global_state, *l.local_state);
389: 			function.copy_to_finalize(context.client, *bind_data, *l.global_state);
390: 		} else if (file_size_bytes.IsValid()) {
391: 			// File in global state may change with FILE_SIZE_BYTES, need to grab lock
392: 			auto lock = g.lock.GetSharedLock();
393: 			function.copy_to_combine(context, *bind_data, *g.global_state, *l.local_state);
394: 		} else {
395: 			function.copy_to_combine(context, *bind_data, *g.global_state, *l.local_state);
396: 		}
397: 	}
398: 
399: 	return SinkCombineResultType::FINISHED;
400: }
401: 
402: SinkFinalizeType PhysicalCopyToFile::Finalize(Pipeline &pipeline, Event &event, ClientContext &context,
403:                                               OperatorSinkFinalizeInput &input) const {
404: 	auto &gstate = input.global_state.Cast<CopyToFunctionGlobalState>();
405: 	if (partition_output) {
406: 		// finalize any outstanding partitions
407: 		gstate.FinalizePartitions(context, *this);
408: 		return SinkFinalizeType::READY;
409: 	}
410: 	if (per_thread_output) {
411: 		// already happened in combine
412: 		return SinkFinalizeType::READY;
413: 	}
414: 	if (function.copy_to_finalize) {
415: 		function.copy_to_finalize(context, *bind_data, *gstate.global_state);
416: 
417: 		if (use_tmp_file) {
418: 			D_ASSERT(!per_thread_output);
419: 			D_ASSERT(!partition_output);
420: 			D_ASSERT(!file_size_bytes.IsValid());
421: 			MoveTmpFile(context, file_path);
422: 		}
423: 	}
424: 	return SinkFinalizeType::READY;
425: }
426: 
427: //===--------------------------------------------------------------------===//
428: // Source
429: //===--------------------------------------------------------------------===//
430: 
431: SourceResultType PhysicalCopyToFile::GetData(ExecutionContext &context, DataChunk &chunk,
432:                                              OperatorSourceInput &input) const {
433: 	auto &g = sink_state->Cast<CopyToFunctionGlobalState>();
434: 
435: 	chunk.SetCardinality(1);
436: 	chunk.SetValue(0, 0, Value::BIGINT(NumericCast<int64_t>(g.rows_copied.load())));
437: 
438: 	return SourceResultType::FINISHED;
439: }
440: 
441: } // namespace duckdb
[end of src/execution/operator/persistent/physical_copy_to_file.cpp]
[start of src/execution/physical_plan/plan_copy_to_file.cpp]
1: #include "duckdb/execution/operator/persistent/physical_copy_to_file.hpp"
2: #include "duckdb/execution/operator/persistent/physical_batch_copy_to_file.hpp"
3: #include "duckdb/execution/physical_plan_generator.hpp"
4: #include "duckdb/planner/operator/logical_copy_to_file.hpp"
5: 
6: namespace duckdb {
7: 
8: unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalCopyToFile &op) {
9: 	auto plan = CreatePlan(*op.children[0]);
10: 	bool preserve_insertion_order = PhysicalPlanGenerator::PreserveInsertionOrder(context, *plan);
11: 	bool supports_batch_index = PhysicalPlanGenerator::UseBatchIndex(context, *plan);
12: 	auto &fs = FileSystem::GetFileSystem(context);
13: 	op.file_path = fs.ExpandPath(op.file_path);
14: 	if (op.use_tmp_file) {
15: 		auto path = StringUtil::GetFilePath(op.file_path);
16: 		auto base = StringUtil::GetFileName(op.file_path);
17: 		op.file_path = fs.JoinPath(path, "tmp_" + base);
18: 	}
19: 	if (op.per_thread_output || op.file_size_bytes.IsValid() || op.partition_output || !op.partition_columns.empty() ||
20: 	    op.overwrite_or_ignore) {
21: 		// hive-partitioning/per-thread output does not care about insertion order, and does not support batch indexes
22: 		preserve_insertion_order = false;
23: 		supports_batch_index = false;
24: 	}
25: 	auto mode = CopyFunctionExecutionMode::REGULAR_COPY_TO_FILE;
26: 	if (op.function.execution_mode) {
27: 		mode = op.function.execution_mode(preserve_insertion_order, supports_batch_index);
28: 	}
29: 	if (mode == CopyFunctionExecutionMode::BATCH_COPY_TO_FILE) {
30: 		if (!supports_batch_index) {
31: 			throw InternalException("BATCH_COPY_TO_FILE can only be used if batch indexes are supported");
32: 		}
33: 		// batched copy to file
34: 		auto copy = make_uniq<PhysicalBatchCopyToFile>(op.types, op.function, std::move(op.bind_data),
35: 		                                               op.estimated_cardinality);
36: 		copy->file_path = op.file_path;
37: 		copy->use_tmp_file = op.use_tmp_file;
38: 		copy->children.push_back(std::move(plan));
39: 		return std::move(copy);
40: 	}
41: 	// COPY from select statement to file
42: 	auto copy = make_uniq<PhysicalCopyToFile>(op.types, op.function, std::move(op.bind_data), op.estimated_cardinality);
43: 	copy->file_path = op.file_path;
44: 	copy->use_tmp_file = op.use_tmp_file;
45: 	copy->overwrite_or_ignore = op.overwrite_or_ignore;
46: 	copy->filename_pattern = op.filename_pattern;
47: 	copy->file_extension = op.file_extension;
48: 	copy->per_thread_output = op.per_thread_output;
49: 	if (op.file_size_bytes.IsValid()) {
50: 		copy->file_size_bytes = op.file_size_bytes;
51: 	}
52: 	copy->partition_output = op.partition_output;
53: 	copy->partition_columns = op.partition_columns;
54: 	copy->names = op.names;
55: 	copy->expected_types = op.expected_types;
56: 	copy->parallel = mode == CopyFunctionExecutionMode::PARALLEL_COPY_TO_FILE;
57: 
58: 	copy->children.push_back(std::move(plan));
59: 	return std::move(copy);
60: }
61: 
62: } // namespace duckdb
[end of src/execution/physical_plan/plan_copy_to_file.cpp]
[start of src/include/duckdb/common/enum_util.hpp]
1: //-------------------------------------------------------------------------
2: // This file is automatically generated by scripts/generate_enum_util.py
3: // Do not edit this file manually, your changes will be overwritten
4: // If you want to exclude an enum from serialization, add it to the blacklist in the script
5: //
6: // Note: The generated code will only work properly if the enum is a top level item in the duckdb namespace
7: // If the enum is nested in a class, or in another namespace, the generated code will not compile.
8: // You should move the enum to the duckdb namespace, manually write a specialization or add it to the blacklist
9: //-------------------------------------------------------------------------
10: 
11: 
12: #pragma once
13: 
14: #include <stdint.h>
15: #include "duckdb/common/string.hpp"
16: 
17: namespace duckdb {
18: 
19: struct EnumUtil {
20:     // String -> Enum
21:     template <class T>
22:     static T FromString(const char *value) = delete;
23: 
24:     template <class T>
25:     static T FromString(const string &value) { return FromString<T>(value.c_str()); }
26: 
27:     // Enum -> String
28:     template <class T>
29:     static const char *ToChars(T value) = delete;
30: 
31:     template <class T>
32:     static string ToString(T value) { return string(ToChars<T>(value)); }
33: };
34: 
35: enum class AccessMode : uint8_t;
36: 
37: enum class AggregateCombineType : uint8_t;
38: 
39: enum class AggregateHandling : uint8_t;
40: 
41: enum class AggregateOrderDependent : uint8_t;
42: 
43: enum class AggregateType : uint8_t;
44: 
45: enum class AlterForeignKeyType : uint8_t;
46: 
47: enum class AlterScalarFunctionType : uint8_t;
48: 
49: enum class AlterTableFunctionType : uint8_t;
50: 
51: enum class AlterTableType : uint8_t;
52: 
53: enum class AlterType : uint8_t;
54: 
55: enum class AlterViewType : uint8_t;
56: 
57: enum class AppenderType : uint8_t;
58: 
59: enum class ArrowDateTimeType : uint8_t;
60: 
61: enum class ArrowOffsetSize : uint8_t;
62: 
63: enum class ArrowVariableSizeType : uint8_t;
64: 
65: enum class BinderType : uint8_t;
66: 
67: enum class BindingMode : uint8_t;
68: 
69: enum class BitpackingMode : uint8_t;
70: 
71: enum class BlockState : uint8_t;
72: 
73: enum class CAPIResultSetType : uint8_t;
74: 
75: enum class CSVState : uint8_t;
76: 
77: enum class CTEMaterialize : uint8_t;
78: 
79: enum class CatalogLookupBehavior : uint8_t;
80: 
81: enum class CatalogType : uint8_t;
82: 
83: enum class CheckpointAbort : uint8_t;
84: 
85: enum class ChunkInfoType : uint8_t;
86: 
87: enum class ColumnDataAllocatorType : uint8_t;
88: 
89: enum class ColumnDataScanProperties : uint8_t;
90: 
91: enum class ColumnSegmentType : uint8_t;
92: 
93: enum class CompressedMaterializationDirection : uint8_t;
94: 
95: enum class CompressionType : uint8_t;
96: 
97: enum class ConflictManagerMode : uint8_t;
98: 
99: enum class ConstraintType : uint8_t;
100: 
101: enum class DataFileType : uint8_t;
102: 
103: enum class DatePartSpecifier : uint8_t;
104: 
105: enum class DebugInitialize : uint8_t;
106: 
107: enum class DefaultOrderByNullType : uint8_t;
108: 
109: enum class DependencyEntryType : uint8_t;
110: 
111: enum class DeprecatedIndexType : uint8_t;
112: 
113: enum class DistinctType : uint8_t;
114: 
115: enum class ErrorType : uint16_t;
116: 
117: enum class ExceptionFormatValueType : uint8_t;
118: 
119: enum class ExceptionType : uint8_t;
120: 
121: enum class ExplainOutputType : uint8_t;
122: 
123: enum class ExplainType : uint8_t;
124: 
125: enum class ExponentType : uint8_t;
126: 
127: enum class ExpressionClass : uint8_t;
128: 
129: enum class ExpressionType : uint8_t;
130: 
131: enum class ExtensionInstallMode : uint8_t;
132: 
133: enum class ExtensionLoadResult : uint8_t;
134: 
135: enum class ExtensionUpdateResultTag : uint8_t;
136: 
137: enum class ExtraDropInfoType : uint8_t;
138: 
139: enum class ExtraTypeInfoType : uint8_t;
140: 
141: enum class FileBufferType : uint8_t;
142: 
143: enum class FileCompressionType : uint8_t;
144: 
145: enum class FileExpandResult : uint8_t;
146: 
147: enum class FileGlobOptions : uint8_t;
148: 
149: enum class FileLockType : uint8_t;
150: 
151: enum class FilterPropagateResult : uint8_t;
152: 
153: enum class ForeignKeyType : uint8_t;
154: 
155: enum class FunctionNullHandling : uint8_t;
156: 
157: enum class FunctionStability : uint8_t;
158: 
159: enum class HLLStorageType : uint8_t;
160: 
161: enum class IndexConstraintType : uint8_t;
162: 
163: enum class InsertColumnOrder : uint8_t;
164: 
165: enum class InterruptMode : uint8_t;
166: 
167: enum class JoinRefType : uint8_t;
168: 
169: enum class JoinType : uint8_t;
170: 
171: enum class KeywordCategory : uint8_t;
172: 
173: enum class LimitNodeType : uint8_t;
174: 
175: enum class LoadType : uint8_t;
176: 
177: enum class LogicalOperatorType : uint8_t;
178: 
179: enum class LogicalTypeId : uint8_t;
180: 
181: enum class LookupResultType : uint8_t;
182: 
183: enum class MacroType : uint8_t;
184: 
185: enum class MapInvalidReason : uint8_t;
186: 
187: enum class MemoryTag : uint8_t;
188: 
189: enum class NType : uint8_t;
190: 
191: enum class NewLineIdentifier : uint8_t;
192: 
193: enum class OnConflictAction : uint8_t;
194: 
195: enum class OnCreateConflict : uint8_t;
196: 
197: enum class OnEntryNotFound : uint8_t;
198: 
199: enum class OperatorFinalizeResultType : uint8_t;
200: 
201: enum class OperatorResultType : uint8_t;
202: 
203: enum class OptimizerType : uint32_t;
204: 
205: enum class OrderByNullType : uint8_t;
206: 
207: enum class OrderPreservationType : uint8_t;
208: 
209: enum class OrderType : uint8_t;
210: 
211: enum class OutputStream : uint8_t;
212: 
213: enum class ParseInfoType : uint8_t;
214: 
215: enum class ParserExtensionResultType : uint8_t;
216: 
217: enum class PartitionSortStage : uint8_t;
218: 
219: enum class PartitionedColumnDataType : uint8_t;
220: 
221: enum class PartitionedTupleDataType : uint8_t;
222: 
223: enum class PendingExecutionResult : uint8_t;
224: 
225: enum class PhysicalOperatorType : uint8_t;
226: 
227: enum class PhysicalType : uint8_t;
228: 
229: enum class PragmaType : uint8_t;
230: 
231: enum class PreparedParamType : uint8_t;
232: 
233: enum class PreparedStatementMode : uint8_t;
234: 
235: enum class ProfilerPrintFormat : uint8_t;
236: 
237: enum class QuantileSerializationType : uint8_t;
238: 
239: enum class QueryNodeType : uint8_t;
240: 
241: enum class QueryResultType : uint8_t;
242: 
243: enum class QuoteRule : uint8_t;
244: 
245: enum class RelationType : uint8_t;
246: 
247: enum class RenderMode : uint8_t;
248: 
249: enum class ResultModifierType : uint8_t;
250: 
251: enum class SampleMethod : uint8_t;
252: 
253: enum class SampleType : uint8_t;
254: 
255: enum class ScanType : uint8_t;
256: 
257: enum class SecretDisplayType : uint8_t;
258: 
259: enum class SecretPersistType : uint8_t;
260: 
261: enum class SequenceInfo : uint8_t;
262: 
263: enum class SetOperationType : uint8_t;
264: 
265: enum class SetScope : uint8_t;
266: 
267: enum class SetType : uint8_t;
268: 
269: enum class SettingScope : uint8_t;
270: 
271: enum class ShowType : uint8_t;
272: 
273: enum class SimplifiedTokenType : uint8_t;
274: 
275: enum class SinkCombineResultType : uint8_t;
276: 
277: enum class SinkFinalizeType : uint8_t;
278: 
279: enum class SinkNextBatchType : uint8_t;
280: 
281: enum class SinkResultType : uint8_t;
282: 
283: enum class SourceResultType : uint8_t;
284: 
285: enum class StatementReturnType : uint8_t;
286: 
287: enum class StatementType : uint8_t;
288: 
289: enum class StatisticsType : uint8_t;
290: 
291: enum class StatsInfo : uint8_t;
292: 
293: enum class StrTimeSpecifier : uint8_t;
294: 
295: enum class SubqueryType : uint8_t;
296: 
297: enum class TableColumnType : uint8_t;
298: 
299: enum class TableFilterType : uint8_t;
300: 
301: enum class TableReferenceType : uint8_t;
302: 
303: enum class TableScanType : uint8_t;
304: 
305: enum class TaskExecutionMode : uint8_t;
306: 
307: enum class TaskExecutionResult : uint8_t;
308: 
309: enum class TimestampCastResult : uint8_t;
310: 
311: enum class TransactionType : uint8_t;
312: 
313: enum class TupleDataPinProperties : uint8_t;
314: 
315: enum class UndoFlags : uint32_t;
316: 
317: enum class UnionInvalidReason : uint8_t;
318: 
319: enum class VectorAuxiliaryDataType : uint8_t;
320: 
321: enum class VectorBufferType : uint8_t;
322: 
323: enum class VectorType : uint8_t;
324: 
325: enum class VerificationType : uint8_t;
326: 
327: enum class VerifyExistenceType : uint8_t;
328: 
329: enum class WALType : uint8_t;
330: 
331: enum class WindowAggregationMode : uint32_t;
332: 
333: enum class WindowBoundary : uint8_t;
334: 
335: enum class WindowExcludeMode : uint8_t;
336: 
337: 
338: template<>
339: const char* EnumUtil::ToChars<AccessMode>(AccessMode value);
340: 
341: template<>
342: const char* EnumUtil::ToChars<AggregateCombineType>(AggregateCombineType value);
343: 
344: template<>
345: const char* EnumUtil::ToChars<AggregateHandling>(AggregateHandling value);
346: 
347: template<>
348: const char* EnumUtil::ToChars<AggregateOrderDependent>(AggregateOrderDependent value);
349: 
350: template<>
351: const char* EnumUtil::ToChars<AggregateType>(AggregateType value);
352: 
353: template<>
354: const char* EnumUtil::ToChars<AlterForeignKeyType>(AlterForeignKeyType value);
355: 
356: template<>
357: const char* EnumUtil::ToChars<AlterScalarFunctionType>(AlterScalarFunctionType value);
358: 
359: template<>
360: const char* EnumUtil::ToChars<AlterTableFunctionType>(AlterTableFunctionType value);
361: 
362: template<>
363: const char* EnumUtil::ToChars<AlterTableType>(AlterTableType value);
364: 
365: template<>
366: const char* EnumUtil::ToChars<AlterType>(AlterType value);
367: 
368: template<>
369: const char* EnumUtil::ToChars<AlterViewType>(AlterViewType value);
370: 
371: template<>
372: const char* EnumUtil::ToChars<AppenderType>(AppenderType value);
373: 
374: template<>
375: const char* EnumUtil::ToChars<ArrowDateTimeType>(ArrowDateTimeType value);
376: 
377: template<>
378: const char* EnumUtil::ToChars<ArrowOffsetSize>(ArrowOffsetSize value);
379: 
380: template<>
381: const char* EnumUtil::ToChars<ArrowVariableSizeType>(ArrowVariableSizeType value);
382: 
383: template<>
384: const char* EnumUtil::ToChars<BinderType>(BinderType value);
385: 
386: template<>
387: const char* EnumUtil::ToChars<BindingMode>(BindingMode value);
388: 
389: template<>
390: const char* EnumUtil::ToChars<BitpackingMode>(BitpackingMode value);
391: 
392: template<>
393: const char* EnumUtil::ToChars<BlockState>(BlockState value);
394: 
395: template<>
396: const char* EnumUtil::ToChars<CAPIResultSetType>(CAPIResultSetType value);
397: 
398: template<>
399: const char* EnumUtil::ToChars<CSVState>(CSVState value);
400: 
401: template<>
402: const char* EnumUtil::ToChars<CTEMaterialize>(CTEMaterialize value);
403: 
404: template<>
405: const char* EnumUtil::ToChars<CatalogLookupBehavior>(CatalogLookupBehavior value);
406: 
407: template<>
408: const char* EnumUtil::ToChars<CatalogType>(CatalogType value);
409: 
410: template<>
411: const char* EnumUtil::ToChars<CheckpointAbort>(CheckpointAbort value);
412: 
413: template<>
414: const char* EnumUtil::ToChars<ChunkInfoType>(ChunkInfoType value);
415: 
416: template<>
417: const char* EnumUtil::ToChars<ColumnDataAllocatorType>(ColumnDataAllocatorType value);
418: 
419: template<>
420: const char* EnumUtil::ToChars<ColumnDataScanProperties>(ColumnDataScanProperties value);
421: 
422: template<>
423: const char* EnumUtil::ToChars<ColumnSegmentType>(ColumnSegmentType value);
424: 
425: template<>
426: const char* EnumUtil::ToChars<CompressedMaterializationDirection>(CompressedMaterializationDirection value);
427: 
428: template<>
429: const char* EnumUtil::ToChars<CompressionType>(CompressionType value);
430: 
431: template<>
432: const char* EnumUtil::ToChars<ConflictManagerMode>(ConflictManagerMode value);
433: 
434: template<>
435: const char* EnumUtil::ToChars<ConstraintType>(ConstraintType value);
436: 
437: template<>
438: const char* EnumUtil::ToChars<DataFileType>(DataFileType value);
439: 
440: template<>
441: const char* EnumUtil::ToChars<DatePartSpecifier>(DatePartSpecifier value);
442: 
443: template<>
444: const char* EnumUtil::ToChars<DebugInitialize>(DebugInitialize value);
445: 
446: template<>
447: const char* EnumUtil::ToChars<DefaultOrderByNullType>(DefaultOrderByNullType value);
448: 
449: template<>
450: const char* EnumUtil::ToChars<DependencyEntryType>(DependencyEntryType value);
451: 
452: template<>
453: const char* EnumUtil::ToChars<DeprecatedIndexType>(DeprecatedIndexType value);
454: 
455: template<>
456: const char* EnumUtil::ToChars<DistinctType>(DistinctType value);
457: 
458: template<>
459: const char* EnumUtil::ToChars<ErrorType>(ErrorType value);
460: 
461: template<>
462: const char* EnumUtil::ToChars<ExceptionFormatValueType>(ExceptionFormatValueType value);
463: 
464: template<>
465: const char* EnumUtil::ToChars<ExceptionType>(ExceptionType value);
466: 
467: template<>
468: const char* EnumUtil::ToChars<ExplainOutputType>(ExplainOutputType value);
469: 
470: template<>
471: const char* EnumUtil::ToChars<ExplainType>(ExplainType value);
472: 
473: template<>
474: const char* EnumUtil::ToChars<ExponentType>(ExponentType value);
475: 
476: template<>
477: const char* EnumUtil::ToChars<ExpressionClass>(ExpressionClass value);
478: 
479: template<>
480: const char* EnumUtil::ToChars<ExpressionType>(ExpressionType value);
481: 
482: template<>
483: const char* EnumUtil::ToChars<ExtensionInstallMode>(ExtensionInstallMode value);
484: 
485: template<>
486: const char* EnumUtil::ToChars<ExtensionLoadResult>(ExtensionLoadResult value);
487: 
488: template<>
489: const char* EnumUtil::ToChars<ExtensionUpdateResultTag>(ExtensionUpdateResultTag value);
490: 
491: template<>
492: const char* EnumUtil::ToChars<ExtraDropInfoType>(ExtraDropInfoType value);
493: 
494: template<>
495: const char* EnumUtil::ToChars<ExtraTypeInfoType>(ExtraTypeInfoType value);
496: 
497: template<>
498: const char* EnumUtil::ToChars<FileBufferType>(FileBufferType value);
499: 
500: template<>
501: const char* EnumUtil::ToChars<FileCompressionType>(FileCompressionType value);
502: 
503: template<>
504: const char* EnumUtil::ToChars<FileExpandResult>(FileExpandResult value);
505: 
506: template<>
507: const char* EnumUtil::ToChars<FileGlobOptions>(FileGlobOptions value);
508: 
509: template<>
510: const char* EnumUtil::ToChars<FileLockType>(FileLockType value);
511: 
512: template<>
513: const char* EnumUtil::ToChars<FilterPropagateResult>(FilterPropagateResult value);
514: 
515: template<>
516: const char* EnumUtil::ToChars<ForeignKeyType>(ForeignKeyType value);
517: 
518: template<>
519: const char* EnumUtil::ToChars<FunctionNullHandling>(FunctionNullHandling value);
520: 
521: template<>
522: const char* EnumUtil::ToChars<FunctionStability>(FunctionStability value);
523: 
524: template<>
525: const char* EnumUtil::ToChars<HLLStorageType>(HLLStorageType value);
526: 
527: template<>
528: const char* EnumUtil::ToChars<IndexConstraintType>(IndexConstraintType value);
529: 
530: template<>
531: const char* EnumUtil::ToChars<InsertColumnOrder>(InsertColumnOrder value);
532: 
533: template<>
534: const char* EnumUtil::ToChars<InterruptMode>(InterruptMode value);
535: 
536: template<>
537: const char* EnumUtil::ToChars<JoinRefType>(JoinRefType value);
538: 
539: template<>
540: const char* EnumUtil::ToChars<JoinType>(JoinType value);
541: 
542: template<>
543: const char* EnumUtil::ToChars<KeywordCategory>(KeywordCategory value);
544: 
545: template<>
546: const char* EnumUtil::ToChars<LimitNodeType>(LimitNodeType value);
547: 
548: template<>
549: const char* EnumUtil::ToChars<LoadType>(LoadType value);
550: 
551: template<>
552: const char* EnumUtil::ToChars<LogicalOperatorType>(LogicalOperatorType value);
553: 
554: template<>
555: const char* EnumUtil::ToChars<LogicalTypeId>(LogicalTypeId value);
556: 
557: template<>
558: const char* EnumUtil::ToChars<LookupResultType>(LookupResultType value);
559: 
560: template<>
561: const char* EnumUtil::ToChars<MacroType>(MacroType value);
562: 
563: template<>
564: const char* EnumUtil::ToChars<MapInvalidReason>(MapInvalidReason value);
565: 
566: template<>
567: const char* EnumUtil::ToChars<MemoryTag>(MemoryTag value);
568: 
569: template<>
570: const char* EnumUtil::ToChars<NType>(NType value);
571: 
572: template<>
573: const char* EnumUtil::ToChars<NewLineIdentifier>(NewLineIdentifier value);
574: 
575: template<>
576: const char* EnumUtil::ToChars<OnConflictAction>(OnConflictAction value);
577: 
578: template<>
579: const char* EnumUtil::ToChars<OnCreateConflict>(OnCreateConflict value);
580: 
581: template<>
582: const char* EnumUtil::ToChars<OnEntryNotFound>(OnEntryNotFound value);
583: 
584: template<>
585: const char* EnumUtil::ToChars<OperatorFinalizeResultType>(OperatorFinalizeResultType value);
586: 
587: template<>
588: const char* EnumUtil::ToChars<OperatorResultType>(OperatorResultType value);
589: 
590: template<>
591: const char* EnumUtil::ToChars<OptimizerType>(OptimizerType value);
592: 
593: template<>
594: const char* EnumUtil::ToChars<OrderByNullType>(OrderByNullType value);
595: 
596: template<>
597: const char* EnumUtil::ToChars<OrderPreservationType>(OrderPreservationType value);
598: 
599: template<>
600: const char* EnumUtil::ToChars<OrderType>(OrderType value);
601: 
602: template<>
603: const char* EnumUtil::ToChars<OutputStream>(OutputStream value);
604: 
605: template<>
606: const char* EnumUtil::ToChars<ParseInfoType>(ParseInfoType value);
607: 
608: template<>
609: const char* EnumUtil::ToChars<ParserExtensionResultType>(ParserExtensionResultType value);
610: 
611: template<>
612: const char* EnumUtil::ToChars<PartitionSortStage>(PartitionSortStage value);
613: 
614: template<>
615: const char* EnumUtil::ToChars<PartitionedColumnDataType>(PartitionedColumnDataType value);
616: 
617: template<>
618: const char* EnumUtil::ToChars<PartitionedTupleDataType>(PartitionedTupleDataType value);
619: 
620: template<>
621: const char* EnumUtil::ToChars<PendingExecutionResult>(PendingExecutionResult value);
622: 
623: template<>
624: const char* EnumUtil::ToChars<PhysicalOperatorType>(PhysicalOperatorType value);
625: 
626: template<>
627: const char* EnumUtil::ToChars<PhysicalType>(PhysicalType value);
628: 
629: template<>
630: const char* EnumUtil::ToChars<PragmaType>(PragmaType value);
631: 
632: template<>
633: const char* EnumUtil::ToChars<PreparedParamType>(PreparedParamType value);
634: 
635: template<>
636: const char* EnumUtil::ToChars<PreparedStatementMode>(PreparedStatementMode value);
637: 
638: template<>
639: const char* EnumUtil::ToChars<ProfilerPrintFormat>(ProfilerPrintFormat value);
640: 
641: template<>
642: const char* EnumUtil::ToChars<QuantileSerializationType>(QuantileSerializationType value);
643: 
644: template<>
645: const char* EnumUtil::ToChars<QueryNodeType>(QueryNodeType value);
646: 
647: template<>
648: const char* EnumUtil::ToChars<QueryResultType>(QueryResultType value);
649: 
650: template<>
651: const char* EnumUtil::ToChars<QuoteRule>(QuoteRule value);
652: 
653: template<>
654: const char* EnumUtil::ToChars<RelationType>(RelationType value);
655: 
656: template<>
657: const char* EnumUtil::ToChars<RenderMode>(RenderMode value);
658: 
659: template<>
660: const char* EnumUtil::ToChars<ResultModifierType>(ResultModifierType value);
661: 
662: template<>
663: const char* EnumUtil::ToChars<SampleMethod>(SampleMethod value);
664: 
665: template<>
666: const char* EnumUtil::ToChars<SampleType>(SampleType value);
667: 
668: template<>
669: const char* EnumUtil::ToChars<ScanType>(ScanType value);
670: 
671: template<>
672: const char* EnumUtil::ToChars<SecretDisplayType>(SecretDisplayType value);
673: 
674: template<>
675: const char* EnumUtil::ToChars<SecretPersistType>(SecretPersistType value);
676: 
677: template<>
678: const char* EnumUtil::ToChars<SequenceInfo>(SequenceInfo value);
679: 
680: template<>
681: const char* EnumUtil::ToChars<SetOperationType>(SetOperationType value);
682: 
683: template<>
684: const char* EnumUtil::ToChars<SetScope>(SetScope value);
685: 
686: template<>
687: const char* EnumUtil::ToChars<SetType>(SetType value);
688: 
689: template<>
690: const char* EnumUtil::ToChars<SettingScope>(SettingScope value);
691: 
692: template<>
693: const char* EnumUtil::ToChars<ShowType>(ShowType value);
694: 
695: template<>
696: const char* EnumUtil::ToChars<SimplifiedTokenType>(SimplifiedTokenType value);
697: 
698: template<>
699: const char* EnumUtil::ToChars<SinkCombineResultType>(SinkCombineResultType value);
700: 
701: template<>
702: const char* EnumUtil::ToChars<SinkFinalizeType>(SinkFinalizeType value);
703: 
704: template<>
705: const char* EnumUtil::ToChars<SinkNextBatchType>(SinkNextBatchType value);
706: 
707: template<>
708: const char* EnumUtil::ToChars<SinkResultType>(SinkResultType value);
709: 
710: template<>
711: const char* EnumUtil::ToChars<SourceResultType>(SourceResultType value);
712: 
713: template<>
714: const char* EnumUtil::ToChars<StatementReturnType>(StatementReturnType value);
715: 
716: template<>
717: const char* EnumUtil::ToChars<StatementType>(StatementType value);
718: 
719: template<>
720: const char* EnumUtil::ToChars<StatisticsType>(StatisticsType value);
721: 
722: template<>
723: const char* EnumUtil::ToChars<StatsInfo>(StatsInfo value);
724: 
725: template<>
726: const char* EnumUtil::ToChars<StrTimeSpecifier>(StrTimeSpecifier value);
727: 
728: template<>
729: const char* EnumUtil::ToChars<SubqueryType>(SubqueryType value);
730: 
731: template<>
732: const char* EnumUtil::ToChars<TableColumnType>(TableColumnType value);
733: 
734: template<>
735: const char* EnumUtil::ToChars<TableFilterType>(TableFilterType value);
736: 
737: template<>
738: const char* EnumUtil::ToChars<TableReferenceType>(TableReferenceType value);
739: 
740: template<>
741: const char* EnumUtil::ToChars<TableScanType>(TableScanType value);
742: 
743: template<>
744: const char* EnumUtil::ToChars<TaskExecutionMode>(TaskExecutionMode value);
745: 
746: template<>
747: const char* EnumUtil::ToChars<TaskExecutionResult>(TaskExecutionResult value);
748: 
749: template<>
750: const char* EnumUtil::ToChars<TimestampCastResult>(TimestampCastResult value);
751: 
752: template<>
753: const char* EnumUtil::ToChars<TransactionType>(TransactionType value);
754: 
755: template<>
756: const char* EnumUtil::ToChars<TupleDataPinProperties>(TupleDataPinProperties value);
757: 
758: template<>
759: const char* EnumUtil::ToChars<UndoFlags>(UndoFlags value);
760: 
761: template<>
762: const char* EnumUtil::ToChars<UnionInvalidReason>(UnionInvalidReason value);
763: 
764: template<>
765: const char* EnumUtil::ToChars<VectorAuxiliaryDataType>(VectorAuxiliaryDataType value);
766: 
767: template<>
768: const char* EnumUtil::ToChars<VectorBufferType>(VectorBufferType value);
769: 
770: template<>
771: const char* EnumUtil::ToChars<VectorType>(VectorType value);
772: 
773: template<>
774: const char* EnumUtil::ToChars<VerificationType>(VerificationType value);
775: 
776: template<>
777: const char* EnumUtil::ToChars<VerifyExistenceType>(VerifyExistenceType value);
778: 
779: template<>
780: const char* EnumUtil::ToChars<WALType>(WALType value);
781: 
782: template<>
783: const char* EnumUtil::ToChars<WindowAggregationMode>(WindowAggregationMode value);
784: 
785: template<>
786: const char* EnumUtil::ToChars<WindowBoundary>(WindowBoundary value);
787: 
788: template<>
789: const char* EnumUtil::ToChars<WindowExcludeMode>(WindowExcludeMode value);
790: 
791: 
792: template<>
793: AccessMode EnumUtil::FromString<AccessMode>(const char *value);
794: 
795: template<>
796: AggregateCombineType EnumUtil::FromString<AggregateCombineType>(const char *value);
797: 
798: template<>
799: AggregateHandling EnumUtil::FromString<AggregateHandling>(const char *value);
800: 
801: template<>
802: AggregateOrderDependent EnumUtil::FromString<AggregateOrderDependent>(const char *value);
803: 
804: template<>
805: AggregateType EnumUtil::FromString<AggregateType>(const char *value);
806: 
807: template<>
808: AlterForeignKeyType EnumUtil::FromString<AlterForeignKeyType>(const char *value);
809: 
810: template<>
811: AlterScalarFunctionType EnumUtil::FromString<AlterScalarFunctionType>(const char *value);
812: 
813: template<>
814: AlterTableFunctionType EnumUtil::FromString<AlterTableFunctionType>(const char *value);
815: 
816: template<>
817: AlterTableType EnumUtil::FromString<AlterTableType>(const char *value);
818: 
819: template<>
820: AlterType EnumUtil::FromString<AlterType>(const char *value);
821: 
822: template<>
823: AlterViewType EnumUtil::FromString<AlterViewType>(const char *value);
824: 
825: template<>
826: AppenderType EnumUtil::FromString<AppenderType>(const char *value);
827: 
828: template<>
829: ArrowDateTimeType EnumUtil::FromString<ArrowDateTimeType>(const char *value);
830: 
831: template<>
832: ArrowOffsetSize EnumUtil::FromString<ArrowOffsetSize>(const char *value);
833: 
834: template<>
835: ArrowVariableSizeType EnumUtil::FromString<ArrowVariableSizeType>(const char *value);
836: 
837: template<>
838: BinderType EnumUtil::FromString<BinderType>(const char *value);
839: 
840: template<>
841: BindingMode EnumUtil::FromString<BindingMode>(const char *value);
842: 
843: template<>
844: BitpackingMode EnumUtil::FromString<BitpackingMode>(const char *value);
845: 
846: template<>
847: BlockState EnumUtil::FromString<BlockState>(const char *value);
848: 
849: template<>
850: CAPIResultSetType EnumUtil::FromString<CAPIResultSetType>(const char *value);
851: 
852: template<>
853: CSVState EnumUtil::FromString<CSVState>(const char *value);
854: 
855: template<>
856: CTEMaterialize EnumUtil::FromString<CTEMaterialize>(const char *value);
857: 
858: template<>
859: CatalogLookupBehavior EnumUtil::FromString<CatalogLookupBehavior>(const char *value);
860: 
861: template<>
862: CatalogType EnumUtil::FromString<CatalogType>(const char *value);
863: 
864: template<>
865: CheckpointAbort EnumUtil::FromString<CheckpointAbort>(const char *value);
866: 
867: template<>
868: ChunkInfoType EnumUtil::FromString<ChunkInfoType>(const char *value);
869: 
870: template<>
871: ColumnDataAllocatorType EnumUtil::FromString<ColumnDataAllocatorType>(const char *value);
872: 
873: template<>
874: ColumnDataScanProperties EnumUtil::FromString<ColumnDataScanProperties>(const char *value);
875: 
876: template<>
877: ColumnSegmentType EnumUtil::FromString<ColumnSegmentType>(const char *value);
878: 
879: template<>
880: CompressedMaterializationDirection EnumUtil::FromString<CompressedMaterializationDirection>(const char *value);
881: 
882: template<>
883: CompressionType EnumUtil::FromString<CompressionType>(const char *value);
884: 
885: template<>
886: ConflictManagerMode EnumUtil::FromString<ConflictManagerMode>(const char *value);
887: 
888: template<>
889: ConstraintType EnumUtil::FromString<ConstraintType>(const char *value);
890: 
891: template<>
892: DataFileType EnumUtil::FromString<DataFileType>(const char *value);
893: 
894: template<>
895: DatePartSpecifier EnumUtil::FromString<DatePartSpecifier>(const char *value);
896: 
897: template<>
898: DebugInitialize EnumUtil::FromString<DebugInitialize>(const char *value);
899: 
900: template<>
901: DefaultOrderByNullType EnumUtil::FromString<DefaultOrderByNullType>(const char *value);
902: 
903: template<>
904: DependencyEntryType EnumUtil::FromString<DependencyEntryType>(const char *value);
905: 
906: template<>
907: DeprecatedIndexType EnumUtil::FromString<DeprecatedIndexType>(const char *value);
908: 
909: template<>
910: DistinctType EnumUtil::FromString<DistinctType>(const char *value);
911: 
912: template<>
913: ErrorType EnumUtil::FromString<ErrorType>(const char *value);
914: 
915: template<>
916: ExceptionFormatValueType EnumUtil::FromString<ExceptionFormatValueType>(const char *value);
917: 
918: template<>
919: ExceptionType EnumUtil::FromString<ExceptionType>(const char *value);
920: 
921: template<>
922: ExplainOutputType EnumUtil::FromString<ExplainOutputType>(const char *value);
923: 
924: template<>
925: ExplainType EnumUtil::FromString<ExplainType>(const char *value);
926: 
927: template<>
928: ExponentType EnumUtil::FromString<ExponentType>(const char *value);
929: 
930: template<>
931: ExpressionClass EnumUtil::FromString<ExpressionClass>(const char *value);
932: 
933: template<>
934: ExpressionType EnumUtil::FromString<ExpressionType>(const char *value);
935: 
936: template<>
937: ExtensionInstallMode EnumUtil::FromString<ExtensionInstallMode>(const char *value);
938: 
939: template<>
940: ExtensionLoadResult EnumUtil::FromString<ExtensionLoadResult>(const char *value);
941: 
942: template<>
943: ExtensionUpdateResultTag EnumUtil::FromString<ExtensionUpdateResultTag>(const char *value);
944: 
945: template<>
946: ExtraDropInfoType EnumUtil::FromString<ExtraDropInfoType>(const char *value);
947: 
948: template<>
949: ExtraTypeInfoType EnumUtil::FromString<ExtraTypeInfoType>(const char *value);
950: 
951: template<>
952: FileBufferType EnumUtil::FromString<FileBufferType>(const char *value);
953: 
954: template<>
955: FileCompressionType EnumUtil::FromString<FileCompressionType>(const char *value);
956: 
957: template<>
958: FileExpandResult EnumUtil::FromString<FileExpandResult>(const char *value);
959: 
960: template<>
961: FileGlobOptions EnumUtil::FromString<FileGlobOptions>(const char *value);
962: 
963: template<>
964: FileLockType EnumUtil::FromString<FileLockType>(const char *value);
965: 
966: template<>
967: FilterPropagateResult EnumUtil::FromString<FilterPropagateResult>(const char *value);
968: 
969: template<>
970: ForeignKeyType EnumUtil::FromString<ForeignKeyType>(const char *value);
971: 
972: template<>
973: FunctionNullHandling EnumUtil::FromString<FunctionNullHandling>(const char *value);
974: 
975: template<>
976: FunctionStability EnumUtil::FromString<FunctionStability>(const char *value);
977: 
978: template<>
979: HLLStorageType EnumUtil::FromString<HLLStorageType>(const char *value);
980: 
981: template<>
982: IndexConstraintType EnumUtil::FromString<IndexConstraintType>(const char *value);
983: 
984: template<>
985: InsertColumnOrder EnumUtil::FromString<InsertColumnOrder>(const char *value);
986: 
987: template<>
988: InterruptMode EnumUtil::FromString<InterruptMode>(const char *value);
989: 
990: template<>
991: JoinRefType EnumUtil::FromString<JoinRefType>(const char *value);
992: 
993: template<>
994: JoinType EnumUtil::FromString<JoinType>(const char *value);
995: 
996: template<>
997: KeywordCategory EnumUtil::FromString<KeywordCategory>(const char *value);
998: 
999: template<>
1000: LimitNodeType EnumUtil::FromString<LimitNodeType>(const char *value);
1001: 
1002: template<>
1003: LoadType EnumUtil::FromString<LoadType>(const char *value);
1004: 
1005: template<>
1006: LogicalOperatorType EnumUtil::FromString<LogicalOperatorType>(const char *value);
1007: 
1008: template<>
1009: LogicalTypeId EnumUtil::FromString<LogicalTypeId>(const char *value);
1010: 
1011: template<>
1012: LookupResultType EnumUtil::FromString<LookupResultType>(const char *value);
1013: 
1014: template<>
1015: MacroType EnumUtil::FromString<MacroType>(const char *value);
1016: 
1017: template<>
1018: MapInvalidReason EnumUtil::FromString<MapInvalidReason>(const char *value);
1019: 
1020: template<>
1021: MemoryTag EnumUtil::FromString<MemoryTag>(const char *value);
1022: 
1023: template<>
1024: NType EnumUtil::FromString<NType>(const char *value);
1025: 
1026: template<>
1027: NewLineIdentifier EnumUtil::FromString<NewLineIdentifier>(const char *value);
1028: 
1029: template<>
1030: OnConflictAction EnumUtil::FromString<OnConflictAction>(const char *value);
1031: 
1032: template<>
1033: OnCreateConflict EnumUtil::FromString<OnCreateConflict>(const char *value);
1034: 
1035: template<>
1036: OnEntryNotFound EnumUtil::FromString<OnEntryNotFound>(const char *value);
1037: 
1038: template<>
1039: OperatorFinalizeResultType EnumUtil::FromString<OperatorFinalizeResultType>(const char *value);
1040: 
1041: template<>
1042: OperatorResultType EnumUtil::FromString<OperatorResultType>(const char *value);
1043: 
1044: template<>
1045: OptimizerType EnumUtil::FromString<OptimizerType>(const char *value);
1046: 
1047: template<>
1048: OrderByNullType EnumUtil::FromString<OrderByNullType>(const char *value);
1049: 
1050: template<>
1051: OrderPreservationType EnumUtil::FromString<OrderPreservationType>(const char *value);
1052: 
1053: template<>
1054: OrderType EnumUtil::FromString<OrderType>(const char *value);
1055: 
1056: template<>
1057: OutputStream EnumUtil::FromString<OutputStream>(const char *value);
1058: 
1059: template<>
1060: ParseInfoType EnumUtil::FromString<ParseInfoType>(const char *value);
1061: 
1062: template<>
1063: ParserExtensionResultType EnumUtil::FromString<ParserExtensionResultType>(const char *value);
1064: 
1065: template<>
1066: PartitionSortStage EnumUtil::FromString<PartitionSortStage>(const char *value);
1067: 
1068: template<>
1069: PartitionedColumnDataType EnumUtil::FromString<PartitionedColumnDataType>(const char *value);
1070: 
1071: template<>
1072: PartitionedTupleDataType EnumUtil::FromString<PartitionedTupleDataType>(const char *value);
1073: 
1074: template<>
1075: PendingExecutionResult EnumUtil::FromString<PendingExecutionResult>(const char *value);
1076: 
1077: template<>
1078: PhysicalOperatorType EnumUtil::FromString<PhysicalOperatorType>(const char *value);
1079: 
1080: template<>
1081: PhysicalType EnumUtil::FromString<PhysicalType>(const char *value);
1082: 
1083: template<>
1084: PragmaType EnumUtil::FromString<PragmaType>(const char *value);
1085: 
1086: template<>
1087: PreparedParamType EnumUtil::FromString<PreparedParamType>(const char *value);
1088: 
1089: template<>
1090: PreparedStatementMode EnumUtil::FromString<PreparedStatementMode>(const char *value);
1091: 
1092: template<>
1093: ProfilerPrintFormat EnumUtil::FromString<ProfilerPrintFormat>(const char *value);
1094: 
1095: template<>
1096: QuantileSerializationType EnumUtil::FromString<QuantileSerializationType>(const char *value);
1097: 
1098: template<>
1099: QueryNodeType EnumUtil::FromString<QueryNodeType>(const char *value);
1100: 
1101: template<>
1102: QueryResultType EnumUtil::FromString<QueryResultType>(const char *value);
1103: 
1104: template<>
1105: QuoteRule EnumUtil::FromString<QuoteRule>(const char *value);
1106: 
1107: template<>
1108: RelationType EnumUtil::FromString<RelationType>(const char *value);
1109: 
1110: template<>
1111: RenderMode EnumUtil::FromString<RenderMode>(const char *value);
1112: 
1113: template<>
1114: ResultModifierType EnumUtil::FromString<ResultModifierType>(const char *value);
1115: 
1116: template<>
1117: SampleMethod EnumUtil::FromString<SampleMethod>(const char *value);
1118: 
1119: template<>
1120: SampleType EnumUtil::FromString<SampleType>(const char *value);
1121: 
1122: template<>
1123: ScanType EnumUtil::FromString<ScanType>(const char *value);
1124: 
1125: template<>
1126: SecretDisplayType EnumUtil::FromString<SecretDisplayType>(const char *value);
1127: 
1128: template<>
1129: SecretPersistType EnumUtil::FromString<SecretPersistType>(const char *value);
1130: 
1131: template<>
1132: SequenceInfo EnumUtil::FromString<SequenceInfo>(const char *value);
1133: 
1134: template<>
1135: SetOperationType EnumUtil::FromString<SetOperationType>(const char *value);
1136: 
1137: template<>
1138: SetScope EnumUtil::FromString<SetScope>(const char *value);
1139: 
1140: template<>
1141: SetType EnumUtil::FromString<SetType>(const char *value);
1142: 
1143: template<>
1144: SettingScope EnumUtil::FromString<SettingScope>(const char *value);
1145: 
1146: template<>
1147: ShowType EnumUtil::FromString<ShowType>(const char *value);
1148: 
1149: template<>
1150: SimplifiedTokenType EnumUtil::FromString<SimplifiedTokenType>(const char *value);
1151: 
1152: template<>
1153: SinkCombineResultType EnumUtil::FromString<SinkCombineResultType>(const char *value);
1154: 
1155: template<>
1156: SinkFinalizeType EnumUtil::FromString<SinkFinalizeType>(const char *value);
1157: 
1158: template<>
1159: SinkNextBatchType EnumUtil::FromString<SinkNextBatchType>(const char *value);
1160: 
1161: template<>
1162: SinkResultType EnumUtil::FromString<SinkResultType>(const char *value);
1163: 
1164: template<>
1165: SourceResultType EnumUtil::FromString<SourceResultType>(const char *value);
1166: 
1167: template<>
1168: StatementReturnType EnumUtil::FromString<StatementReturnType>(const char *value);
1169: 
1170: template<>
1171: StatementType EnumUtil::FromString<StatementType>(const char *value);
1172: 
1173: template<>
1174: StatisticsType EnumUtil::FromString<StatisticsType>(const char *value);
1175: 
1176: template<>
1177: StatsInfo EnumUtil::FromString<StatsInfo>(const char *value);
1178: 
1179: template<>
1180: StrTimeSpecifier EnumUtil::FromString<StrTimeSpecifier>(const char *value);
1181: 
1182: template<>
1183: SubqueryType EnumUtil::FromString<SubqueryType>(const char *value);
1184: 
1185: template<>
1186: TableColumnType EnumUtil::FromString<TableColumnType>(const char *value);
1187: 
1188: template<>
1189: TableFilterType EnumUtil::FromString<TableFilterType>(const char *value);
1190: 
1191: template<>
1192: TableReferenceType EnumUtil::FromString<TableReferenceType>(const char *value);
1193: 
1194: template<>
1195: TableScanType EnumUtil::FromString<TableScanType>(const char *value);
1196: 
1197: template<>
1198: TaskExecutionMode EnumUtil::FromString<TaskExecutionMode>(const char *value);
1199: 
1200: template<>
1201: TaskExecutionResult EnumUtil::FromString<TaskExecutionResult>(const char *value);
1202: 
1203: template<>
1204: TimestampCastResult EnumUtil::FromString<TimestampCastResult>(const char *value);
1205: 
1206: template<>
1207: TransactionType EnumUtil::FromString<TransactionType>(const char *value);
1208: 
1209: template<>
1210: TupleDataPinProperties EnumUtil::FromString<TupleDataPinProperties>(const char *value);
1211: 
1212: template<>
1213: UndoFlags EnumUtil::FromString<UndoFlags>(const char *value);
1214: 
1215: template<>
1216: UnionInvalidReason EnumUtil::FromString<UnionInvalidReason>(const char *value);
1217: 
1218: template<>
1219: VectorAuxiliaryDataType EnumUtil::FromString<VectorAuxiliaryDataType>(const char *value);
1220: 
1221: template<>
1222: VectorBufferType EnumUtil::FromString<VectorBufferType>(const char *value);
1223: 
1224: template<>
1225: VectorType EnumUtil::FromString<VectorType>(const char *value);
1226: 
1227: template<>
1228: VerificationType EnumUtil::FromString<VerificationType>(const char *value);
1229: 
1230: template<>
1231: VerifyExistenceType EnumUtil::FromString<VerifyExistenceType>(const char *value);
1232: 
1233: template<>
1234: WALType EnumUtil::FromString<WALType>(const char *value);
1235: 
1236: template<>
1237: WindowAggregationMode EnumUtil::FromString<WindowAggregationMode>(const char *value);
1238: 
1239: template<>
1240: WindowBoundary EnumUtil::FromString<WindowBoundary>(const char *value);
1241: 
1242: template<>
1243: WindowExcludeMode EnumUtil::FromString<WindowExcludeMode>(const char *value);
1244: 
1245: 
1246: }
[end of src/include/duckdb/common/enum_util.hpp]
[start of src/include/duckdb/execution/operator/persistent/physical_copy_to_file.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/operator/persistent/physical_copy_to_file.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/file_system.hpp"
12: #include "duckdb/common/filename_pattern.hpp"
13: #include "duckdb/execution/physical_operator.hpp"
14: #include "duckdb/function/copy_function.hpp"
15: #include "duckdb/parser/parsed_data/copy_info.hpp"
16: 
17: namespace duckdb {
18: 
19: //! Copy the contents of a query into a table
20: class PhysicalCopyToFile : public PhysicalOperator {
21: public:
22: 	static constexpr const PhysicalOperatorType TYPE = PhysicalOperatorType::COPY_TO_FILE;
23: 
24: public:
25: 	PhysicalCopyToFile(vector<LogicalType> types, CopyFunction function, unique_ptr<FunctionData> bind_data,
26: 	                   idx_t estimated_cardinality);
27: 
28: 	CopyFunction function;
29: 	unique_ptr<FunctionData> bind_data;
30: 	string file_path;
31: 	bool use_tmp_file;
32: 	FilenamePattern filename_pattern;
33: 	string file_extension;
34: 	bool overwrite_or_ignore;
35: 	bool parallel;
36: 	bool per_thread_output;
37: 	optional_idx file_size_bytes;
38: 
39: 	bool partition_output;
40: 	vector<idx_t> partition_columns;
41: 	vector<string> names;
42: 	vector<LogicalType> expected_types;
43: 
44: public:
45: 	// Source interface
46: 	SourceResultType GetData(ExecutionContext &context, DataChunk &chunk, OperatorSourceInput &input) const override;
47: 
48: 	bool IsSource() const override {
49: 		return true;
50: 	}
51: 
52: public:
53: 	// Sink interface
54: 	SinkResultType Sink(ExecutionContext &context, DataChunk &chunk, OperatorSinkInput &input) const override;
55: 	SinkCombineResultType Combine(ExecutionContext &context, OperatorSinkCombineInput &input) const override;
56: 	SinkFinalizeType Finalize(Pipeline &pipeline, Event &event, ClientContext &context,
57: 	                          OperatorSinkFinalizeInput &input) const override;
58: 	unique_ptr<LocalSinkState> GetLocalSinkState(ExecutionContext &context) const override;
59: 	unique_ptr<GlobalSinkState> GetGlobalSinkState(ClientContext &context) const override;
60: 
61: 	bool IsSink() const override {
62: 		return true;
63: 	}
64: 
65: 	bool SinkOrderDependent() const override {
66: 		return true;
67: 	}
68: 
69: 	bool ParallelSink() const override {
70: 		return per_thread_output || partition_output || parallel;
71: 	}
72: 
73: 	static void MoveTmpFile(ClientContext &context, const string &tmp_file_path);
74: 
75: 	string GetTrimmedPath(ClientContext &context) const;
76: 
77: private:
78: 	unique_ptr<GlobalFunctionData> CreateFileState(ClientContext &context, GlobalSinkState &sink) const;
79: };
80: } // namespace duckdb
[end of src/include/duckdb/execution/operator/persistent/physical_copy_to_file.hpp]
[start of src/include/duckdb/planner/operator/logical_copy_to_file.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/operator/logical_copy_to_file.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/filename_pattern.hpp"
12: #include "duckdb/common/local_file_system.hpp"
13: #include "duckdb/common/optional_idx.hpp"
14: #include "duckdb/function/copy_function.hpp"
15: #include "duckdb/planner/logical_operator.hpp"
16: 
17: namespace duckdb {
18: 
19: class LogicalCopyToFile : public LogicalOperator {
20: public:
21: 	static constexpr const LogicalOperatorType TYPE = LogicalOperatorType::LOGICAL_COPY_TO_FILE;
22: 
23: public:
24: 	LogicalCopyToFile(CopyFunction function, unique_ptr<FunctionData> bind_data, unique_ptr<CopyInfo> copy_info)
25: 	    : LogicalOperator(LogicalOperatorType::LOGICAL_COPY_TO_FILE), function(std::move(function)),
26: 	      bind_data(std::move(bind_data)), copy_info(std::move(copy_info)) {
27: 	}
28: 	CopyFunction function;
29: 	unique_ptr<FunctionData> bind_data;
30: 	unique_ptr<CopyInfo> copy_info;
31: 
32: 	std::string file_path;
33: 	bool use_tmp_file;
34: 	FilenamePattern filename_pattern;
35: 	string file_extension;
36: 	bool overwrite_or_ignore;
37: 	bool per_thread_output;
38: 	optional_idx file_size_bytes;
39: 
40: 	bool partition_output;
41: 	vector<idx_t> partition_columns;
42: 	vector<string> names;
43: 	vector<LogicalType> expected_types;
44: 
45: public:
46: 	idx_t EstimateCardinality(ClientContext &context) override;
47: 	void Serialize(Serializer &serializer) const override;
48: 	static unique_ptr<LogicalOperator> Deserialize(Deserializer &deserializer);
49: 
50: protected:
51: 	void ResolveTypes() override {
52: 		types.emplace_back(LogicalType::BIGINT);
53: 	}
54: };
55: } // namespace duckdb
[end of src/include/duckdb/planner/operator/logical_copy_to_file.hpp]
[start of src/planner/binder/statement/bind_copy.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/catalog/catalog_entry/copy_function_catalog_entry.hpp"
3: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
5: #include "duckdb/common/bind_helpers.hpp"
6: #include "duckdb/common/filename_pattern.hpp"
7: #include "duckdb/common/local_file_system.hpp"
8: #include "duckdb/function/table/read_csv.hpp"
9: #include "duckdb/main/client_context.hpp"
10: #include "duckdb/main/database.hpp"
11: #include "duckdb/parser/expression/columnref_expression.hpp"
12: #include "duckdb/parser/expression/star_expression.hpp"
13: #include "duckdb/parser/query_node/select_node.hpp"
14: #include "duckdb/parser/statement/copy_statement.hpp"
15: #include "duckdb/parser/statement/insert_statement.hpp"
16: #include "duckdb/parser/tableref/basetableref.hpp"
17: #include "duckdb/planner/binder.hpp"
18: #include "duckdb/planner/operator/logical_copy_to_file.hpp"
19: #include "duckdb/planner/operator/logical_get.hpp"
20: #include "duckdb/planner/operator/logical_insert.hpp"
21: 
22: #include <algorithm>
23: 
24: namespace duckdb {
25: 
26: static bool GetBooleanArg(ClientContext &context, const vector<Value> &arg) {
27: 	return arg.empty() || arg[0].CastAs(context, LogicalType::BOOLEAN).GetValue<bool>();
28: }
29: 
30: BoundStatement Binder::BindCopyTo(CopyStatement &stmt) {
31: 	// COPY TO a file
32: 	auto &config = DBConfig::GetConfig(context);
33: 	if (!config.options.enable_external_access) {
34: 		throw PermissionException("COPY TO is disabled by configuration");
35: 	}
36: 	BoundStatement result;
37: 	result.types = {LogicalType::BIGINT};
38: 	result.names = {"Count"};
39: 
40: 	// lookup the format in the catalog
41: 	auto &copy_function =
42: 	    Catalog::GetEntry<CopyFunctionCatalogEntry>(context, INVALID_CATALOG, DEFAULT_SCHEMA, stmt.info->format);
43: 	if (copy_function.function.plan) {
44: 		// plan rewrite COPY TO
45: 		return copy_function.function.plan(*this, stmt);
46: 	}
47: 
48: 	auto &copy_info = *stmt.info;
49: 	// bind the select statement
50: 	auto node_copy = copy_info.select_statement->Copy();
51: 	auto select_node = Bind(*node_copy);
52: 
53: 	if (!copy_function.function.copy_to_bind) {
54: 		throw NotImplementedException("COPY TO is not supported for FORMAT \"%s\"", stmt.info->format);
55: 	}
56: 
57: 	bool use_tmp_file = true;
58: 	bool overwrite_or_ignore = false;
59: 	FilenamePattern filename_pattern;
60: 	bool user_set_use_tmp_file = false;
61: 	bool per_thread_output = false;
62: 	optional_idx file_size_bytes;
63: 	vector<idx_t> partition_cols;
64: 
65: 	CopyFunctionBindInput bind_input(*stmt.info);
66: 
67: 	bind_input.file_extension = copy_function.function.extension;
68: 
69: 	auto original_options = stmt.info->options;
70: 	stmt.info->options.clear();
71: 
72: 	for (auto &option : original_options) {
73: 		auto loption = StringUtil::Lower(option.first);
74: 		if (loption == "use_tmp_file") {
75: 			use_tmp_file = GetBooleanArg(context, option.second);
76: 			user_set_use_tmp_file = true;
77: 		} else if (loption == "overwrite_or_ignore") {
78: 			overwrite_or_ignore = GetBooleanArg(context, option.second);
79: 		} else if (loption == "filename_pattern") {
80: 			if (option.second.empty()) {
81: 				throw IOException("FILENAME_PATTERN cannot be empty");
82: 			}
83: 			filename_pattern.SetFilenamePattern(
84: 			    option.second[0].CastAs(context, LogicalType::VARCHAR).GetValue<string>());
85: 		} else if (loption == "file_extension") {
86: 			if (option.second.empty()) {
87: 				throw IOException("FILE_EXTENSION cannot be empty");
88: 			}
89: 			bind_input.file_extension = option.second[0].CastAs(context, LogicalType::VARCHAR).GetValue<string>();
90: 		} else if (loption == "per_thread_output") {
91: 			per_thread_output = GetBooleanArg(context, option.second);
92: 		} else if (loption == "file_size_bytes") {
93: 			if (option.second.empty()) {
94: 				throw BinderException("FILE_SIZE_BYTES cannot be empty");
95: 			}
96: 			if (!copy_function.function.file_size_bytes) {
97: 				throw NotImplementedException("FILE_SIZE_BYTES not implemented for FORMAT \"%s\"", stmt.info->format);
98: 			}
99: 			if (option.second[0].GetTypeMutable().id() == LogicalTypeId::VARCHAR) {
100: 				file_size_bytes = DBConfig::ParseMemoryLimit(option.second[0].ToString());
101: 			} else {
102: 				file_size_bytes = option.second[0].GetValue<uint64_t>();
103: 			}
104: 		} else if (loption == "partition_by") {
105: 			auto converted = ConvertVectorToValue(std::move(option.second));
106: 			partition_cols = ParseColumnsOrdered(converted, select_node.names, loption);
107: 		} else {
108: 			stmt.info->options[option.first] = option.second;
109: 		}
110: 	}
111: 	if (user_set_use_tmp_file && per_thread_output) {
112: 		throw NotImplementedException("Can't combine USE_TMP_FILE and PER_THREAD_OUTPUT for COPY");
113: 	}
114: 	if (user_set_use_tmp_file && file_size_bytes.IsValid()) {
115: 		throw NotImplementedException("Can't combine USE_TMP_FILE and FILE_SIZE_BYTES for COPY");
116: 	}
117: 	if (user_set_use_tmp_file && !partition_cols.empty()) {
118: 		throw NotImplementedException("Can't combine USE_TMP_FILE and PARTITION_BY for COPY");
119: 	}
120: 	if (per_thread_output && !partition_cols.empty()) {
121: 		throw NotImplementedException("Can't combine PER_THREAD_OUTPUT and PARTITION_BY for COPY");
122: 	}
123: 	if (file_size_bytes.IsValid() && !partition_cols.empty()) {
124: 		throw NotImplementedException("Can't combine FILE_SIZE_BYTES and PARTITION_BY for COPY");
125: 	}
126: 	bool is_remote_file = FileSystem::IsRemoteFile(stmt.info->file_path);
127: 	if (is_remote_file) {
128: 		use_tmp_file = false;
129: 	} else {
130: 		auto &fs = FileSystem::GetFileSystem(context);
131: 		bool is_file_and_exists = fs.FileExists(stmt.info->file_path);
132: 		bool is_stdout = stmt.info->file_path == "/dev/stdout";
133: 		if (!user_set_use_tmp_file) {
134: 			use_tmp_file = is_file_and_exists && !per_thread_output && partition_cols.empty() && !is_stdout;
135: 		}
136: 	}
137: 
138: 	auto unique_column_names = select_node.names;
139: 	QueryResult::DeduplicateColumns(unique_column_names);
140: 	auto file_path = stmt.info->file_path;
141: 
142: 	auto function_data =
143: 	    copy_function.function.copy_to_bind(context, bind_input, unique_column_names, select_node.types);
144: 
145: 	// now create the copy information
146: 	auto copy = make_uniq<LogicalCopyToFile>(copy_function.function, std::move(function_data), std::move(stmt.info));
147: 	copy->file_path = file_path;
148: 	copy->use_tmp_file = use_tmp_file;
149: 	copy->overwrite_or_ignore = overwrite_or_ignore;
150: 	copy->filename_pattern = filename_pattern;
151: 	copy->file_extension = bind_input.file_extension;
152: 	copy->per_thread_output = per_thread_output;
153: 	if (file_size_bytes.IsValid()) {
154: 		copy->file_size_bytes = file_size_bytes;
155: 	}
156: 	copy->partition_output = !partition_cols.empty();
157: 	copy->partition_columns = std::move(partition_cols);
158: 
159: 	copy->names = unique_column_names;
160: 	copy->expected_types = select_node.types;
161: 
162: 	copy->AddChild(std::move(select_node.plan));
163: 
164: 	result.plan = std::move(copy);
165: 
166: 	return result;
167: }
168: 
169: BoundStatement Binder::BindCopyFrom(CopyStatement &stmt) {
170: 	auto &config = DBConfig::GetConfig(context);
171: 	if (!config.options.enable_external_access) {
172: 		throw PermissionException("COPY FROM is disabled by configuration");
173: 	}
174: 	BoundStatement result;
175: 	result.types = {LogicalType::BIGINT};
176: 	result.names = {"Count"};
177: 
178: 	if (stmt.info->table.empty()) {
179: 		throw ParserException("COPY FROM requires a table name to be specified");
180: 	}
181: 	// COPY FROM a file
182: 	// generate an insert statement for the the to-be-inserted table
183: 	InsertStatement insert;
184: 	insert.table = stmt.info->table;
185: 	insert.schema = stmt.info->schema;
186: 	insert.catalog = stmt.info->catalog;
187: 	insert.columns = stmt.info->select_list;
188: 
189: 	// bind the insert statement to the base table
190: 	auto insert_statement = Bind(insert);
191: 	D_ASSERT(insert_statement.plan->type == LogicalOperatorType::LOGICAL_INSERT);
192: 
193: 	auto &bound_insert = insert_statement.plan->Cast<LogicalInsert>();
194: 
195: 	// lookup the format in the catalog
196: 	auto &catalog = Catalog::GetSystemCatalog(context);
197: 	auto &copy_function = catalog.GetEntry<CopyFunctionCatalogEntry>(context, DEFAULT_SCHEMA, stmt.info->format);
198: 	if (!copy_function.function.copy_from_bind) {
199: 		throw NotImplementedException("COPY FROM is not supported for FORMAT \"%s\"", stmt.info->format);
200: 	}
201: 	// lookup the table to copy into
202: 	BindSchemaOrCatalog(stmt.info->catalog, stmt.info->schema);
203: 	auto &table =
204: 	    Catalog::GetEntry<TableCatalogEntry>(context, stmt.info->catalog, stmt.info->schema, stmt.info->table);
205: 	vector<string> expected_names;
206: 	if (!bound_insert.column_index_map.empty()) {
207: 		expected_names.resize(bound_insert.expected_types.size());
208: 		for (auto &col : table.GetColumns().Physical()) {
209: 			auto i = col.Physical();
210: 			if (bound_insert.column_index_map[i] != DConstants::INVALID_INDEX) {
211: 				expected_names[bound_insert.column_index_map[i]] = col.Name();
212: 			}
213: 		}
214: 	} else {
215: 		expected_names.reserve(bound_insert.expected_types.size());
216: 		for (auto &col : table.GetColumns().Physical()) {
217: 			expected_names.push_back(col.Name());
218: 		}
219: 	}
220: 
221: 	auto function_data =
222: 	    copy_function.function.copy_from_bind(context, *stmt.info, expected_names, bound_insert.expected_types);
223: 	auto get = make_uniq<LogicalGet>(GenerateTableIndex(), copy_function.function.copy_from_function,
224: 	                                 std::move(function_data), bound_insert.expected_types, expected_names);
225: 	for (idx_t i = 0; i < bound_insert.expected_types.size(); i++) {
226: 		get->column_ids.push_back(i);
227: 	}
228: 	insert_statement.plan->children.push_back(std::move(get));
229: 	result.plan = std::move(insert_statement.plan);
230: 	return result;
231: }
232: 
233: BoundStatement Binder::Bind(CopyStatement &stmt) {
234: 	if (!stmt.info->is_from && !stmt.info->select_statement) {
235: 		// copy table into file without a query
236: 		// generate SELECT * FROM table;
237: 		auto ref = make_uniq<BaseTableRef>();
238: 		ref->catalog_name = stmt.info->catalog;
239: 		ref->schema_name = stmt.info->schema;
240: 		ref->table_name = stmt.info->table;
241: 
242: 		auto statement = make_uniq<SelectNode>();
243: 		statement->from_table = std::move(ref);
244: 		if (!stmt.info->select_list.empty()) {
245: 			for (auto &name : stmt.info->select_list) {
246: 				statement->select_list.push_back(make_uniq<ColumnRefExpression>(name));
247: 			}
248: 		} else {
249: 			statement->select_list.push_back(make_uniq<StarExpression>());
250: 		}
251: 		stmt.info->select_statement = std::move(statement);
252: 	}
253: 
254: 	auto &properties = GetStatementProperties();
255: 	properties.allow_stream_result = false;
256: 	properties.return_type = StatementReturnType::CHANGED_ROWS;
257: 	if (stmt.info->is_from) {
258: 		return BindCopyFrom(stmt);
259: 	} else {
260: 		return BindCopyTo(stmt);
261: 	}
262: }
263: 
264: } // namespace duckdb
[end of src/planner/binder/statement/bind_copy.cpp]
[start of src/planner/operator/logical_copy_to_file.cpp]
1: #include "duckdb/planner/operator/logical_copy_to_file.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/copy_function_catalog_entry.hpp"
4: #include "duckdb/common/serializer/deserializer.hpp"
5: #include "duckdb/common/serializer/serializer.hpp"
6: #include "duckdb/function/copy_function.hpp"
7: #include "duckdb/function/function_serialization.hpp"
8: 
9: namespace duckdb {
10: 
11: void LogicalCopyToFile::Serialize(Serializer &serializer) const {
12: 	LogicalOperator::Serialize(serializer);
13: 	serializer.WriteProperty(200, "file_path", file_path);
14: 	serializer.WriteProperty(201, "use_tmp_file", use_tmp_file);
15: 	serializer.WriteProperty(202, "filename_pattern", filename_pattern);
16: 	serializer.WriteProperty(203, "overwrite_or_ignore", overwrite_or_ignore);
17: 	serializer.WriteProperty(204, "per_thread_output", per_thread_output);
18: 	serializer.WriteProperty(205, "partition_output", partition_output);
19: 	serializer.WriteProperty(206, "partition_columns", partition_columns);
20: 	serializer.WriteProperty(207, "names", names);
21: 	serializer.WriteProperty(208, "expected_types", expected_types);
22: 	serializer.WriteProperty(209, "copy_info", copy_info);
23: 
24: 	// Serialize function
25: 	serializer.WriteProperty(210, "function_name", function.name);
26: 
27: 	bool has_serialize = function.serialize;
28: 	serializer.WriteProperty(211, "function_has_serialize", has_serialize);
29: 	if (has_serialize) {
30: 		D_ASSERT(function.deserialize); // if serialize is set, deserialize should be set as well
31: 		serializer.WriteObject(212, "function_data",
32: 		                       [&](Serializer &obj) { function.serialize(obj, *bind_data, function); });
33: 	}
34: 
35: 	serializer.WriteProperty(213, "file_extension", file_extension);
36: }
37: 
38: unique_ptr<LogicalOperator> LogicalCopyToFile::Deserialize(Deserializer &deserializer) {
39: 	auto file_path = deserializer.ReadProperty<string>(200, "file_path");
40: 	auto use_tmp_file = deserializer.ReadProperty<bool>(201, "use_tmp_file");
41: 	auto filename_pattern = deserializer.ReadProperty<FilenamePattern>(202, "filename_pattern");
42: 	auto overwrite_or_ignore = deserializer.ReadProperty<bool>(203, "overwrite_or_ignore");
43: 	auto per_thread_output = deserializer.ReadProperty<bool>(204, "per_thread_output");
44: 	auto partition_output = deserializer.ReadProperty<bool>(205, "partition_output");
45: 	auto partition_columns = deserializer.ReadProperty<vector<idx_t>>(206, "partition_columns");
46: 	auto names = deserializer.ReadProperty<vector<string>>(207, "names");
47: 	auto expected_types = deserializer.ReadProperty<vector<LogicalType>>(208, "expected_types");
48: 	auto copy_info =
49: 	    unique_ptr_cast<ParseInfo, CopyInfo>(deserializer.ReadProperty<unique_ptr<ParseInfo>>(209, "copy_info"));
50: 
51: 	// Deserialize function
52: 	auto &context = deserializer.Get<ClientContext &>();
53: 	auto name = deserializer.ReadProperty<string>(210, "function_name");
54: 
55: 	auto &func_catalog_entry =
56: 	    Catalog::GetEntry(context, CatalogType::COPY_FUNCTION_ENTRY, SYSTEM_CATALOG, DEFAULT_SCHEMA, name);
57: 	if (func_catalog_entry.type != CatalogType::COPY_FUNCTION_ENTRY) {
58: 		throw InternalException("DeserializeFunction - cant find catalog entry for function %s", name);
59: 	}
60: 	auto &function_entry = func_catalog_entry.Cast<CopyFunctionCatalogEntry>();
61: 	auto function = function_entry.function;
62: 	// Deserialize function data
63: 	unique_ptr<FunctionData> bind_data;
64: 	auto has_serialize = deserializer.ReadProperty<bool>(211, "function_has_serialize");
65: 	if (has_serialize) {
66: 		// Just deserialize the bind data
67: 		deserializer.ReadObject(212, "function_data",
68: 		                        [&](Deserializer &obj) { bind_data = function.deserialize(obj, function); });
69: 	} else {
70: 		// Otherwise, re-bind with the copy info
71: 		if (!function.copy_to_bind) {
72: 			throw InternalException("Copy function \"%s\" has neither bind nor (de)serialize", function.name);
73: 		}
74: 
75: 		CopyFunctionBindInput function_bind_input(*copy_info);
76: 		bind_data = function.copy_to_bind(context, function_bind_input, names, expected_types);
77: 	}
78: 
79: 	auto default_extension = function.extension;
80: 
81: 	auto file_extension =
82: 	    deserializer.ReadPropertyWithDefault<string>(213, "file_extension", std::move(default_extension));
83: 
84: 	auto result = make_uniq<LogicalCopyToFile>(function, std::move(bind_data), std::move(copy_info));
85: 	result->file_path = file_path;
86: 	result->use_tmp_file = use_tmp_file;
87: 	result->filename_pattern = filename_pattern;
88: 	result->file_extension = file_extension;
89: 	result->overwrite_or_ignore = overwrite_or_ignore;
90: 	result->per_thread_output = per_thread_output;
91: 	result->partition_output = partition_output;
92: 	result->partition_columns = partition_columns;
93: 	result->names = names;
94: 	result->expected_types = expected_types;
95: 
96: 	return std::move(result);
97: }
98: 
99: idx_t LogicalCopyToFile::EstimateCardinality(ClientContext &context) {
100: 	return 1;
101: }
102: 
103: } // namespace duckdb
[end of src/planner/operator/logical_copy_to_file.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: