{
  "repo": "duckdb/duckdb",
  "pull_number": 8205,
  "instance_id": "duckdb__duckdb-8205",
  "issue_numbers": [
    "7918"
  ],
  "base_commit": "c277db819b8bfb774007aefa139a5c0826cb654e",
  "patch": "diff --git a/tools/odbc/connection.cpp b/tools/odbc/connection.cpp\nindex 76da636b769b..f062bcd9a8c7 100644\n--- a/tools/odbc/connection.cpp\n+++ b/tools/odbc/connection.cpp\n@@ -27,7 +27,7 @@ SQLRETURN SQL_API SQLGetConnectAttr(SQLHDBC connection_handle, SQLINTEGER attrib\n \t\treturn SQL_SUCCESS;\n \t}\n \tcase SQL_ATTR_ACCESS_MODE: {\n-\t\tduckdb::Store<SQLUINTEGER>(dbc->sql_attr_access_mode, (duckdb::data_ptr_t)value_ptr);\n+\t\tduckdb::Store<SQLUINTEGER>(dbc->sql_attr_access_mode, reinterpret_cast<duckdb::data_ptr_t>(value_ptr));\n \t\treturn SQL_SUCCESS;\n \t}\n \tcase SQL_ATTR_CURRENT_CATALOG: {\n@@ -131,16 +131,28 @@ SQLRETURN SQL_API SQLSetConnectAttr(SQLHDBC connection_handle, SQLINTEGER attrib\n \t\t\tdbc->autocommit = false;\n \t\t\tdbc->conn->SetAutoCommit(false);\n \t\t\treturn SQL_SUCCESS;\n-\t\tcase SQL_ATTR_METADATA_ID:\n-\t\t\tdbc->sql_attr_metadata_id = *((SQLUINTEGER *)value_ptr);\n-\t\t\treturn SQL_SUCCESS;\n+\t\tcase SQL_ATTR_METADATA_ID: {\n+\t\t\tif (value_ptr) {\n+\t\t\t\tdbc->sql_attr_metadata_id = OdbcUtils::SQLPointerToSQLUInteger(value_ptr);\n+\t\t\t\treturn SQL_SUCCESS;\n+\t\t\t}\n+\t\t}\n \t\tdefault:\n \t\t\treturn SQL_SUCCESS;\n \t\t}\n-\t\tbreak;\n-\tcase SQL_ATTR_ACCESS_MODE:\n-\t\tdbc->sql_attr_access_mode = *((SQLUINTEGER *)value_ptr);\n-\t\treturn SQL_SUCCESS;\n+\tcase SQL_ATTR_ACCESS_MODE: {\n+\t\tauto access_mode = OdbcUtils::SQLPointerToSQLUInteger(value_ptr);\n+\t\tswitch (access_mode) {\n+\t\tcase SQL_MODE_READ_WRITE:\n+\t\t\tdbc->sql_attr_access_mode = SQL_MODE_READ_WRITE;\n+\t\t\treturn SQL_SUCCESS;\n+\t\tcase SQL_MODE_READ_ONLY:\n+\t\t\tdbc->sql_attr_access_mode = SQL_MODE_READ_ONLY;\n+\t\t\treturn SQL_SUCCESS;\n+\t\t}\n+\t\tduckdb::DiagRecord diag_rec(\"Invalid access mode.\", SQLStateType::INVALID_ATTR_VALUE, dbc->GetDataSourceName());\n+\t\treturn duckdb::SetDiagnosticRecord(dbc, SQL_ERROR, \"SQLSetConnectAttr\", diag_rec, dbc->GetDataSourceName());\n+\t}\n #ifdef SQL_ATTR_ASYNC_DBC_EVENT\n \tcase SQL_ATTR_ASYNC_DBC_EVENT:\n #endif\n@@ -166,7 +178,7 @@ SQLRETURN SQL_API SQLSetConnectAttr(SQLHDBC connection_handle, SQLINTEGER attrib\n \t\treturn SQL_SUCCESS;\n \tcase SQL_ATTR_CURRENT_CATALOG: {\n \t\tif (dbc->conn) {\n-\t\t\tduckdb::DiagRecord diag_rec(\"Connection already stablished, the database name could not be set.\",\n+\t\t\tduckdb::DiagRecord diag_rec(\"Connection already established, the database name could not be set.\",\n \t\t\t                            SQLStateType::INVALID_CONNECTION_STR_ATTR, dbc->GetDataSourceName());\n \t\t\treturn duckdb::SetDiagnosticRecord(dbc, SQL_ERROR, \"SQLSetConnectAttr\", diag_rec, dbc->GetDataSourceName());\n \t\t}\ndiff --git a/tools/odbc/include/odbc_fetch.hpp b/tools/odbc/include/odbc_fetch.hpp\nindex f9cd8982a625..22780ef023be 100644\n--- a/tools/odbc/include/odbc_fetch.hpp\n+++ b/tools/odbc/include/odbc_fetch.hpp\n@@ -30,7 +30,7 @@ class OdbcFetch {\n \t} last_fetched_variable_val;\n \n private:\n-\tOdbcHandleStmt *stmt_ref;\n+\tOdbcHandleStmt *hstmt_ref;\n \t// main structure to hold the fetched chunks\n \tvector<duckdb::unique_ptr<DataChunk>> chunks;\n \t// used by fetch prior\n@@ -44,8 +44,8 @@ class OdbcFetch {\n \tbool resultset_end;\n \n public:\n-\texplicit OdbcFetch(OdbcHandleStmt *stmt)\n-\t    : cursor_type(SQL_CURSOR_FORWARD_ONLY), cursor_scrollable(SQL_NONSCROLLABLE), row_count(0), stmt_ref(stmt),\n+\texplicit OdbcFetch(OdbcHandleStmt *hstmt)\n+\t    : cursor_type(SQL_CURSOR_FORWARD_ONLY), cursor_scrollable(SQL_NONSCROLLABLE), row_count(0), hstmt_ref(hstmt),\n \t      resultset_end(false) {\n \t\tResetLastFetchedVariableVal();\n \t}\n@@ -55,12 +55,11 @@ class OdbcFetch {\n \t\tD_ASSERT(chunk_row <= ((row_t)current_chunk->size()));\n \t}\n \n-\tSQLRETURN Fetch(SQLHSTMT statement_handle, OdbcHandleStmt *stmt, SQLULEN fetch_orientation = SQL_FETCH_NEXT,\n-\t                SQLLEN fetch_offset = 0);\n+\tSQLRETURN Fetch(OdbcHandleStmt *hstmt, SQLULEN fetch_orientation, SQLLEN fetch_offset);\n \n-\tSQLRETURN FetchFirst(SQLHSTMT statement_handle, OdbcHandleStmt *stmt);\n+\tSQLRETURN FetchFirst(OdbcHandleStmt *hstmt);\n \n-\tSQLRETURN FetchNextChunk(SQLULEN fetch_orientation, OdbcHandleStmt *stmt, SQLLEN fetch_offset);\n+\tSQLRETURN FetchNextChunk(SQLULEN fetch_orientation, OdbcHandleStmt *hstmt, SQLLEN fetch_offset);\n \n \tSQLRETURN DummyFetch();\n \n@@ -68,7 +67,7 @@ class OdbcFetch {\n \n \tvoid ClearChunks();\n \n-\tSQLRETURN Materialize(OdbcHandleStmt *stmt);\n+\tSQLRETURN Materialize(OdbcHandleStmt *hstmt);\n \n \tvoid ResetLastFetchedVariableVal();\n \tvoid SetLastFetchedVariableVal(row_t col_idx);\n@@ -80,9 +79,9 @@ class OdbcFetch {\n \tSQLLEN GetRowCount();\n \n private:\n-\tSQLRETURN ColumnWise(SQLHSTMT statement_handle, OdbcHandleStmt *stmt);\n+\tSQLRETURN ColumnWise(OdbcHandleStmt *hstmt);\n \n-\tSQLRETURN RowWise(SQLHSTMT statement_handle, OdbcHandleStmt *stmt);\n+\tSQLRETURN RowWise(OdbcHandleStmt *hstmt);\n \n \tinline bool RequireFetch() {\n \t\treturn (chunks.empty() || (chunk_row >= ((duckdb::row_t)chunks.back()->size()) - 1));\n@@ -90,17 +89,17 @@ class OdbcFetch {\n \n \tvoid IncreaseRowCount();\n \n-\tSQLRETURN FetchNext(OdbcHandleStmt *stmt);\n+\tSQLRETURN FetchNext(OdbcHandleStmt *hstmt);\n \n-\tSQLRETURN SetCurrentChunk(OdbcHandleStmt *stmt);\n+\tSQLRETURN SetCurrentChunk(OdbcHandleStmt *hstmt);\n \n-\tSQLRETURN SetPriorCurrentChunk(OdbcHandleStmt *stmt);\n+\tSQLRETURN SetPriorCurrentChunk(OdbcHandleStmt *hstmt);\n \n \tSQLRETURN BeforeStart();\n \n-\tSQLRETURN SetAbsoluteCurrentChunk(OdbcHandleStmt *stmt, SQLLEN fetch_offset);\n+\tSQLRETURN SetAbsoluteCurrentChunk(OdbcHandleStmt *hstmt, SQLLEN fetch_offset);\n \n-\tSQLRETURN SetFirstCurrentChunk(OdbcHandleStmt *stmt);\n+\tSQLRETURN SetFirstCurrentChunk(OdbcHandleStmt *hstmt);\n \n \tvoid SetRowStatus(idx_t row_idx, SQLINTEGER status);\n };\ndiff --git a/tools/odbc/include/odbc_utils.hpp b/tools/odbc/include/odbc_utils.hpp\nindex 543e97e31b53..693ac1f4c852 100644\n--- a/tools/odbc/include/odbc_utils.hpp\n+++ b/tools/odbc/include/odbc_utils.hpp\n@@ -64,6 +64,8 @@ struct OdbcUtils {\n \n \tstatic void SetValueFromConnStr(const string &conn_str, const char *key, string &value);\n \tstatic void SetValueFromConnStr(SQLCHAR *conn_c_str, const char *key, string &value);\n+\n+\tstatic SQLUINTEGER SQLPointerToSQLUInteger(SQLPOINTER value);\n };\n } // namespace duckdb\n #endif\ndiff --git a/tools/odbc/include/statement_functions.hpp b/tools/odbc/include/statement_functions.hpp\nindex 9519095a9705..9b26ff639f58 100644\n--- a/tools/odbc/include/statement_functions.hpp\n+++ b/tools/odbc/include/statement_functions.hpp\n@@ -12,10 +12,10 @@ SQLRETURN PrepareStmt(SQLHSTMT statement_handle, SQLCHAR *statement_text, SQLINT\n SQLRETURN BatchExecuteStmt(SQLHSTMT statement_handle);\n SQLRETURN SingleExecuteStmt(OdbcHandleStmt *stmt);\n \n-SQLRETURN FetchStmtResult(SQLHSTMT statement_handle, SQLSMALLINT fetch_orientation = SQL_FETCH_NEXT,\n+SQLRETURN FetchStmtResult(duckdb::OdbcHandleStmt *hstmt, SQLSMALLINT fetch_orientation = SQL_FETCH_NEXT,\n                           SQLLEN fetch_offset = 0);\n \n-SQLRETURN GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_or_param_num, SQLSMALLINT target_type,\n+SQLRETURN GetDataStmtResult(OdbcHandleStmt *hstmt, SQLUSMALLINT col_or_param_num, SQLSMALLINT target_type,\n                             SQLPOINTER target_value_ptr, SQLLEN buffer_length, SQLLEN *str_len_or_ind_ptr);\n \n SQLRETURN ExecDirectStmt(SQLHSTMT statement_handle, SQLCHAR *statement_text, SQLINTEGER text_length);\ndiff --git a/tools/odbc/odbc_fetch.cpp b/tools/odbc/odbc_fetch.cpp\nindex 3331213a88e1..33c11dc990dc 100644\n--- a/tools/odbc/odbc_fetch.cpp\n+++ b/tools/odbc/odbc_fetch.cpp\n@@ -16,14 +16,14 @@ OdbcFetch::~OdbcFetch() {\n }\n \n void OdbcFetch::IncreaseRowCount() {\n-\tif ((chunk_row + stmt_ref->row_desc->ard->header.sql_desc_array_size) < current_chunk->size()) {\n-\t\trow_count += stmt_ref->row_desc->ard->header.sql_desc_array_size;\n+\tif ((chunk_row + hstmt_ref->row_desc->ard->header.sql_desc_array_size) < current_chunk->size()) {\n+\t\trow_count += hstmt_ref->row_desc->ard->header.sql_desc_array_size;\n \t} else {\n \t\trow_count += current_chunk->size() - chunk_row;\n \t}\n }\n \n-SQLRETURN OdbcFetch::Materialize(OdbcHandleStmt *stmt) {\n+SQLRETURN OdbcFetch::Materialize(OdbcHandleStmt *hstmt) {\n \t// preserve states before materialization\n \tauto before_cur_chunk = current_chunk;\n \tauto before_cur_chunk_idx = current_chunk_idx;\n@@ -32,7 +32,7 @@ SQLRETURN OdbcFetch::Materialize(OdbcHandleStmt *stmt) {\n \n \tSQLRETURN ret;\n \tdo {\n-\t\tret = FetchNext(stmt);\n+\t\tret = FetchNext(hstmt);\n \t} while (SQL_SUCCEEDED(ret));\n \n \tD_ASSERT(resultset_end);\n@@ -58,16 +58,16 @@ SQLRETURN OdbcFetch::Materialize(OdbcHandleStmt *stmt) {\n \treturn ret;\n }\n \n-SQLRETURN OdbcFetch::FetchNext(OdbcHandleStmt *stmt) {\n+SQLRETURN OdbcFetch::FetchNext(OdbcHandleStmt *hstmt) {\n \t// case hasn't reached the end of query result, then try to fetch\n \tif (!resultset_end) {\n \t\ttry {\n \t\t\t// it's need to reset the last_fetched_len\n \t\t\tResetLastFetchedVariableVal();\n-\t\t\tauto chunk = stmt->res->Fetch();\n-\t\t\tif (stmt->res->HasError()) {\n-\t\t\t\tstmt->open = false;\n-\t\t\t\tstmt->error_messages.emplace_back(stmt->res->GetError());\n+\t\t\tauto chunk = hstmt->res->Fetch();\n+\t\t\tif (hstmt->res->HasError()) {\n+\t\t\t\thstmt->open = false;\n+\t\t\t\thstmt->error_messages.emplace_back(hstmt->res->GetError());\n \t\t\t\treturn SQL_ERROR;\n \t\t\t}\n \t\t\tif (!chunk || chunk->size() == 0) {\n@@ -85,17 +85,17 @@ SQLRETURN OdbcFetch::FetchNext(OdbcHandleStmt *stmt) {\n \t\t\t}\n \t\t} catch (duckdb::Exception &e) {\n \t\t\t// TODO this is quite dirty, we should have separate error holder\n-\t\t\tstmt->res->SetError(PreservedError(e));\n-\t\t\tstmt->open = false;\n-\t\t\tstmt->error_messages.emplace_back(std::string(e.what()));\n+\t\t\thstmt->res->SetError(PreservedError(e));\n+\t\t\thstmt->open = false;\n+\t\t\thstmt->error_messages.emplace_back(std::string(e.what()));\n \t\t\treturn SQL_ERROR;\n \t\t}\n \t}\n \n-\treturn SetCurrentChunk(stmt);\n+\treturn SetCurrentChunk(hstmt);\n }\n \n-SQLRETURN OdbcFetch::SetCurrentChunk(OdbcHandleStmt *stmt) {\n+SQLRETURN OdbcFetch::SetCurrentChunk(OdbcHandleStmt *hstmt) {\n \tif (chunks.empty()) {\n \t\treturn SQL_NO_DATA;\n \t}\n@@ -113,8 +113,8 @@ SQLRETURN OdbcFetch::SetCurrentChunk(OdbcHandleStmt *stmt) {\n \treturn SQL_SUCCESS;\n }\n \n-SQLRETURN OdbcFetch::SetPriorCurrentChunk(OdbcHandleStmt *stmt) {\n-\tprior_chunk_row -= stmt_ref->row_desc->ard->header.sql_desc_array_size;\n+SQLRETURN OdbcFetch::SetPriorCurrentChunk(OdbcHandleStmt *hstmt) {\n+\tprior_chunk_row -= hstmt_ref->row_desc->ard->header.sql_desc_array_size;\n \n \t// case the current chunk is the first one and fetch prior has reached the position \"before start\"\n \tif (current_chunk_idx == 0 && prior_chunk_row < -1) {\n@@ -125,7 +125,7 @@ SQLRETURN OdbcFetch::SetPriorCurrentChunk(OdbcHandleStmt *stmt) {\n \tif (prior_chunk_row < -1) {\n \t\t--current_chunk_idx;\n \t\tcurrent_chunk = chunks[current_chunk_idx].get();\n-\t\tprior_chunk_row = current_chunk->size() - stmt_ref->row_desc->ard->header.sql_desc_array_size - 1;\n+\t\tprior_chunk_row = current_chunk->size() - hstmt_ref->row_desc->ard->header.sql_desc_array_size - 1;\n \t\tif (prior_chunk_row < 0) {\n \t\t\tprior_chunk_row = -1;\n \t\t}\n@@ -147,10 +147,10 @@ SQLRETURN OdbcFetch::BeforeStart() {\n \treturn RETURN_FETCH_BEFORE_START;\n }\n \n-SQLRETURN OdbcFetch::SetAbsoluteCurrentChunk(OdbcHandleStmt *stmt, SQLLEN fetch_offset) {\n+SQLRETURN OdbcFetch::SetAbsoluteCurrentChunk(OdbcHandleStmt *hstmt, SQLLEN fetch_offset) {\n \t// there is no current_chunk, it requires fetch next\n \tif (!current_chunk || chunks.empty()) {\n-\t\tFetchNext(stmt);\n+\t\tFetchNext(hstmt);\n \t}\n \t// it has reachted the last row\n \tif (fetch_offset > (SQLLEN)current_chunk->size() && resultset_end) {\n@@ -170,14 +170,14 @@ SQLRETURN OdbcFetch::SetAbsoluteCurrentChunk(OdbcHandleStmt *stmt, SQLLEN fetch_\n \n \t// FetchOffset < 0    AND | FetchOffset |    > LastResultRow AND |FetchOffset | > RowsetSize\n \tif ((fetch_offset < 0) && (std::abs(fetch_offset) > chunk_row) &&\n-\t    ((SQLULEN)std::abs(fetch_offset) > stmt_ref->row_desc->ard->header.sql_desc_array_size)) {\n+\t    ((SQLULEN)std::abs(fetch_offset) > hstmt_ref->row_desc->ard->header.sql_desc_array_size)) {\n \t\t// Before start, return to BOF\n \t\treturn BeforeStart();\n \t}\n \n \t// FetchOffset < 0    AND | FetchOffset |   > LastResultRow AND | FetchOffset | <= RowsetSize\n \tif ((fetch_offset < 0) && (std::abs(fetch_offset) > chunk_row) &&\n-\t    ((SQLULEN)std::abs(fetch_offset) <= stmt_ref->row_desc->ard->header.sql_desc_array_size)) {\n+\t    ((SQLULEN)std::abs(fetch_offset) <= hstmt_ref->row_desc->ard->header.sql_desc_array_size)) {\n \t\tchunk_row = prior_chunk_row = 0;\n \t\treturn SQL_SUCCESS;\n \t}\n@@ -196,30 +196,30 @@ SQLRETURN OdbcFetch::SetAbsoluteCurrentChunk(OdbcHandleStmt *stmt, SQLLEN fetch_\n \n \t// FetchOffset > LastResultRow\n \tif (fetch_offset >= (SQLLEN)current_chunk->size()) {\n-\t\tauto ret = FetchNext(stmt);\n+\t\tauto ret = FetchNext(hstmt);\n \t\tif (ret != SQL_SUCCESS) {\n \t\t\tcurrent_chunk_idx = 0; // reset chunk idx\n \t\t\treturn ret;\n \t\t}\n \t\tfetch_offset -= current_chunk->size();\n \t\t// recall set absolute based on the new chunk and relative offset\n-\t\treturn SetAbsoluteCurrentChunk(stmt, fetch_offset);\n+\t\treturn SetAbsoluteCurrentChunk(hstmt, fetch_offset);\n \t}\n \n \treturn SQL_ERROR;\n }\n \n-SQLRETURN OdbcFetch::SetFirstCurrentChunk(OdbcHandleStmt *stmt) {\n+SQLRETURN OdbcFetch::SetFirstCurrentChunk(OdbcHandleStmt *hstmt) {\n \tBeforeStart();\n \tif (!current_chunk) {\n-\t\treturn FetchNext(stmt);\n+\t\treturn FetchNext(hstmt);\n \t}\n \treturn SQL_SUCCESS;\n }\n \n-SQLRETURN OdbcFetch::FetchNextChunk(SQLULEN fetch_orientation, OdbcHandleStmt *stmt, SQLLEN fetch_offset) {\n+SQLRETURN OdbcFetch::FetchNextChunk(SQLULEN fetch_orientation, OdbcHandleStmt *hstmt, SQLLEN fetch_offset) {\n \tif (cursor_type == SQL_CURSOR_FORWARD_ONLY && fetch_orientation != SQL_FETCH_NEXT) {\n-\t\tstmt->error_messages.emplace_back(\"Incorrect fetch orientation for cursor type: SQL_CURSOR_FORWARD_ONLY.\");\n+\t\thstmt->error_messages.emplace_back(\"Incorrect fetch orientation for cursor type: SQL_CURSOR_FORWARD_ONLY.\");\n \t\treturn SQL_ERROR;\n \t}\n \n@@ -231,37 +231,37 @@ SQLRETURN OdbcFetch::FetchNextChunk(SQLULEN fetch_orientation, OdbcHandleStmt *s\n \t\t\tif (resultset_end && (current_chunk_idx == chunks.size() - 1)) {\n \t\t\t\treturn SQL_NO_DATA;\n \t\t\t}\n-\t\t\treturn FetchNext(stmt);\n+\t\t\treturn FetchNext(hstmt);\n \t\t}\n \t\treturn SQL_SUCCESS;\n \tcase SQL_FETCH_PRIOR:\n-\t\treturn SetPriorCurrentChunk(stmt);\n+\t\treturn SetPriorCurrentChunk(hstmt);\n \tcase SQL_FETCH_ABSOLUTE:\n-\t\treturn SetAbsoluteCurrentChunk(stmt, fetch_offset);\n+\t\treturn SetAbsoluteCurrentChunk(hstmt, fetch_offset);\n \tcase SQL_FETCH_FIRST:\n-\t\treturn SetFirstCurrentChunk(stmt);\n+\t\treturn SetFirstCurrentChunk(hstmt);\n \tdefault:\n \t\treturn SQL_SUCCESS;\n \t}\n }\n \n SQLRETURN OdbcFetch::DummyFetch() {\n-\tif (stmt_ref->retrieve_data == SQL_RD_OFF) {\n-\t\tauto row_set_size = (SQLLEN)stmt_ref->row_desc->ard->header.sql_desc_array_size;\n+\tif (hstmt_ref->retrieve_data == SQL_RD_OFF) {\n+\t\tauto row_set_size = (SQLLEN)hstmt_ref->row_desc->ard->header.sql_desc_array_size;\n \n-\t\tif (stmt_ref->odbc_fetcher->chunk_row + row_set_size > stmt_ref->odbc_fetcher->row_count) {\n-\t\t\trow_set_size = stmt_ref->odbc_fetcher->row_count - stmt_ref->odbc_fetcher->chunk_row;\n+\t\tif (hstmt_ref->odbc_fetcher->chunk_row + row_set_size > hstmt_ref->odbc_fetcher->row_count) {\n+\t\t\trow_set_size = hstmt_ref->odbc_fetcher->row_count - hstmt_ref->odbc_fetcher->chunk_row;\n \t\t}\n \t\tif (row_set_size <= 0) {\n \t\t\treturn SQL_NO_DATA;\n \t\t}\n-\t\tif (stmt_ref->row_desc->ird->header.sql_desc_array_status_ptr) {\n+\t\tif (hstmt_ref->row_desc->ird->header.sql_desc_array_status_ptr) {\n \t\t\tduckdb::idx_t row_idx;\n \t\t\tfor (row_idx = 0; row_idx < (duckdb::idx_t)row_set_size; row_idx++) {\n-\t\t\t\tstmt_ref->row_desc->ird->header.sql_desc_array_status_ptr[row_idx] = SQL_ROW_SUCCESS;\n+\t\t\t\thstmt_ref->row_desc->ird->header.sql_desc_array_status_ptr[row_idx] = SQL_ROW_SUCCESS;\n \t\t\t}\n-\t\t\tfor (; row_idx < stmt_ref->row_desc->ard->header.sql_desc_array_size; row_idx++) {\n-\t\t\t\tstmt_ref->row_desc->ird->header.sql_desc_array_status_ptr[row_idx] = SQL_ROW_NOROW;\n+\t\t\tfor (; row_idx < hstmt_ref->row_desc->ard->header.sql_desc_array_size; row_idx++) {\n+\t\t\t\thstmt_ref->row_desc->ird->header.sql_desc_array_status_ptr[row_idx] = SQL_ROW_NOROW;\n \t\t\t}\n \t\t}\n \t\treturn SQL_SUCCESS;\n@@ -278,9 +278,8 @@ SQLRETURN OdbcFetch::GetValue(SQLUSMALLINT col_idx, duckdb::Value &value) {\n \treturn SQL_SUCCESS;\n }\n \n-SQLRETURN OdbcFetch::Fetch(SQLHSTMT statement_handle, OdbcHandleStmt *stmt, SQLULEN fetch_orientation,\n-                           SQLLEN fetch_offset) {\n-\tSQLRETURN ret = FetchNextChunk(fetch_orientation, stmt, fetch_offset);\n+SQLRETURN OdbcFetch::Fetch(OdbcHandleStmt *hstmt, SQLULEN fetch_orientation, SQLLEN fetch_offset) {\n+\tSQLRETURN ret = FetchNextChunk(fetch_orientation, hstmt, fetch_offset);\n \tif (ret != SQL_SUCCESS) {\n \t\tif (ret == RETURN_FETCH_BEFORE_START) {\n \t\t\treturn SQL_SUCCESS;\n@@ -289,46 +288,47 @@ SQLRETURN OdbcFetch::Fetch(SQLHSTMT statement_handle, OdbcHandleStmt *stmt, SQLU\n \t}\n \n \t// case there is no bound column\n-\tif (stmt->bound_cols.empty()) {\n+\tif (hstmt->bound_cols.empty()) {\n \t\t// increment fetched row\n-\t\tchunk_row += stmt_ref->row_desc->ard->header.sql_desc_array_size;\n-\t\tif (stmt->rows_fetched_ptr) {\n-\t\t\t(*stmt->rows_fetched_ptr) = 1;\n+\t\tchunk_row += hstmt_ref->row_desc->ard->header.sql_desc_array_size;\n+\t\tif (hstmt->rows_fetched_ptr) {\n+\t\t\t(*hstmt->rows_fetched_ptr) = 1;\n \t\t}\n \t\tIncreaseRowCount();\n \t\treturn SQL_SUCCESS;\n \t}\n \n-\tif (stmt_ref->row_desc->ard->header.sql_desc_bind_type == SQL_BIND_BY_COLUMN) {\n-\t\tif (!SQL_SUCCEEDED(OdbcFetch::ColumnWise(statement_handle, stmt))) {\n-\t\t\tstmt->error_messages.emplace_back(\"Column-wise fetching failed.\");\n+\tif (hstmt_ref->row_desc->ard->header.sql_desc_bind_type == SQL_BIND_BY_COLUMN) {\n+\t\tret = OdbcFetch::ColumnWise(hstmt);\n+\t\tif (!SQL_SUCCEEDED(ret)) {\n+\t\t\thstmt->error_messages.emplace_back(\"Column-wise fetching failed.\");\n \t\t\treturn SQL_ERROR;\n \t\t}\n \t} else {\n \t\t// sql_desc_bind_type should be greater than 0 because it contains the length of the row to be fetched\n-\t\tD_ASSERT(stmt->row_desc->ard->header.sql_desc_bind_type > 0);\n-\t\tif (!SQL_SUCCEEDED(duckdb::OdbcFetch::RowWise(statement_handle, stmt))) {\n-\t\t\tstmt->error_messages.emplace_back(\"Row-wise fetching failed.\");\n+\t\tD_ASSERT(hstmt->row_desc->ard->header.sql_desc_bind_type > 0);\n+\t\tif (!SQL_SUCCEEDED(duckdb::OdbcFetch::RowWise(nullptr))) {\n+\t\t\thstmt->error_messages.emplace_back(\"Row-wise fetching failed.\");\n \t\t\treturn SQL_ERROR;\n \t\t}\n \t}\n \tIncreaseRowCount();\n-\treturn SQL_SUCCESS;\n+\treturn ret;\n }\n \n-SQLRETURN OdbcFetch::FetchFirst(SQLHSTMT statement_handle, OdbcHandleStmt *stmt) {\n+SQLRETURN OdbcFetch::FetchFirst(OdbcHandleStmt *hstmt) {\n \tauto cursor_type_before = cursor_type;\n \tcursor_type = SQL_CURSOR_DYNAMIC;\n-\tauto ret = FetchNextChunk(SQL_FETCH_FIRST, stmt, 0);\n+\tauto ret = FetchNextChunk(SQL_FETCH_FIRST, hstmt, 0);\n \tcursor_type = cursor_type_before;\n \treturn ret;\n }\n \n-SQLRETURN OdbcFetch::ColumnWise(SQLHSTMT statement_handle, OdbcHandleStmt *stmt) {\n+SQLRETURN OdbcFetch::ColumnWise(OdbcHandleStmt *hstmt) {\n \tSQLRETURN ret = SQL_SUCCESS;\n \n \tSQLLEN first_row_to_fetch = chunk_row + 1;\n-\tSQLULEN last_row_to_fetch = first_row_to_fetch + stmt_ref->row_desc->ard->header.sql_desc_array_size;\n+\tSQLULEN last_row_to_fetch = first_row_to_fetch + hstmt_ref->row_desc->ard->header.sql_desc_array_size;\n \n \tif (last_row_to_fetch > current_chunk->size()) {\n \t\tlast_row_to_fetch = current_chunk->size();\n@@ -339,8 +339,8 @@ SQLRETURN OdbcFetch::ColumnWise(SQLHSTMT statement_handle, OdbcHandleStmt *stmt)\n \t\tSetRowStatus(row_idx, SQL_SUCCESS);\n \t\t// now fill buffers in fetch if set\n \t\t// TODO actually vectorize this\n-\t\tfor (duckdb::idx_t col_idx = 0; col_idx < stmt->stmt->ColumnCount(); col_idx++) {\n-\t\t\tauto bound_col = stmt->bound_cols[col_idx];\n+\t\tfor (duckdb::idx_t col_idx = 0; col_idx < hstmt->stmt->ColumnCount(); col_idx++) {\n+\t\t\tauto bound_col = hstmt->bound_cols[col_idx];\n \n \t\t\tif (!bound_col.IsBound() && !bound_col.IsVarcharBound()) {\n \t\t\t\tcontinue;\n@@ -348,8 +348,8 @@ SQLRETURN OdbcFetch::ColumnWise(SQLHSTMT statement_handle, OdbcHandleStmt *stmt)\n \t\t\tauto target_val_addr = bound_col.ptr;\n \t\t\tauto target_len_addr = bound_col.strlen_or_ind;\n \n-\t\t\tif (stmt_ref->row_desc->ard->header.sql_desc_array_size != SINGLE_VALUE_FETCH) {\n-\t\t\t\t// need specialized pointer arithmetic according with the value type\n+\t\t\tif (hstmt_ref->row_desc->ard->header.sql_desc_array_size != SINGLE_VALUE_FETCH) {\n+\t\t\t\t// need specialized pointer arithmetic according to the value type\n \t\t\t\tauto pointer_size = ApiInfo::PointerSizeOf(bound_col.type);\n \t\t\t\tif (pointer_size < 0) {\n \t\t\t\t\tpointer_size = bound_col.len;\n@@ -358,29 +358,29 @@ SQLRETURN OdbcFetch::ColumnWise(SQLHSTMT statement_handle, OdbcHandleStmt *stmt)\n \t\t\t\ttarget_len_addr += row_idx;\n \t\t\t}\n \n-\t\t\tif (!SQL_SUCCEEDED(duckdb::GetDataStmtResult(statement_handle, col_idx + 1, bound_col.type, target_val_addr,\n+\t\t\tif (!SQL_SUCCEEDED(duckdb::GetDataStmtResult(hstmt, col_idx + 1, bound_col.type, target_val_addr,\n \t\t\t                                             bound_col.len, target_len_addr))) {\n \t\t\t\tSetRowStatus(row_idx, SQL_ROW_ERROR);\n-\t\t\t\tstmt->error_messages.emplace_back(\"Error retriving #row: \" + std::to_string(row_idx) +\n-\t\t\t\t                                  \" and column: \" + stmt->stmt->GetNames()[col_idx]);\n+\t\t\t\thstmt->error_messages.emplace_back(\"Error retrieving #row: \" + std::to_string(row_idx) +\n+\t\t\t\t                                   \" and column: \" + hstmt->stmt->GetNames()[col_idx]);\n \t\t\t\tret = SQL_SUCCESS_WITH_INFO;\n \t\t\t}\n \t\t}\n \t}\n \n-\tif (stmt->rows_fetched_ptr) {\n-\t\t*stmt->rows_fetched_ptr = last_row_to_fetch - first_row_to_fetch;\n+\tif (hstmt->rows_fetched_ptr) {\n+\t\t*hstmt->rows_fetched_ptr = last_row_to_fetch - first_row_to_fetch;\n \t}\n \n \treturn ret;\n }\n \n-SQLRETURN OdbcFetch::RowWise(SQLHSTMT statement_handle, OdbcHandleStmt *stmt) {\n+SQLRETURN OdbcFetch::RowWise(OdbcHandleStmt *hstmt) {\n \tSQLRETURN ret = SQL_SUCCESS;\n-\tSQLULEN row_size = stmt->row_desc->ard->header.sql_desc_bind_type;\n+\tSQLULEN row_size = hstmt->row_desc->ard->header.sql_desc_bind_type;\n \n \tSQLLEN first_row_to_fetch = chunk_row + 1;\n-\tSQLULEN last_row_to_fetch = first_row_to_fetch + stmt_ref->row_desc->ard->header.sql_desc_array_size;\n+\tSQLULEN last_row_to_fetch = first_row_to_fetch + hstmt_ref->row_desc->ard->header.sql_desc_array_size;\n \n \tif (last_row_to_fetch > current_chunk->size()) {\n \t\tlast_row_to_fetch = current_chunk->size();\n@@ -391,8 +391,8 @@ SQLRETURN OdbcFetch::RowWise(SQLHSTMT statement_handle, OdbcHandleStmt *stmt) {\n \t\t++chunk_row;\n \t\tSetRowStatus(row_idx, SQL_SUCCESS);\n \t\tauto row_offeset = row_size * row_idx;\n-\t\tfor (duckdb::idx_t col_idx = 0; col_idx < stmt->stmt->ColumnCount(); col_idx++) {\n-\t\t\tauto bound_col = stmt->bound_cols[col_idx];\n+\t\tfor (duckdb::idx_t col_idx = 0; col_idx < hstmt->stmt->ColumnCount(); col_idx++) {\n+\t\t\tauto bound_col = hstmt->bound_cols[col_idx];\n \t\t\tif (!bound_col.IsBound()) {\n \t\t\t\tcontinue;\n \t\t\t}\n@@ -401,18 +401,18 @@ SQLRETURN OdbcFetch::RowWise(SQLHSTMT statement_handle, OdbcHandleStmt *stmt) {\n \t\t\tuint8_t *target_val_addr = (uint8_t *)bound_col.ptr + row_offeset;\n \t\t\tuint8_t *target_len_addr = (uint8_t *)bound_col.strlen_or_ind + row_offeset;\n \n-\t\t\tif (!SQL_SUCCEEDED(duckdb::GetDataStmtResult(statement_handle, col_idx + 1, bound_col.type, target_val_addr,\n+\t\t\tif (!SQL_SUCCEEDED(duckdb::GetDataStmtResult(hstmt, col_idx + 1, bound_col.type, target_val_addr,\n \t\t\t                                             bound_col.len, (SQLLEN *)target_len_addr))) {\n \t\t\t\tSetRowStatus(row_idx, SQL_ROW_ERROR);\n-\t\t\t\tstmt->error_messages.emplace_back(\"Error retriving #row: \" + std::to_string(row_idx) +\n-\t\t\t\t                                  \" and column: \" + stmt->stmt->GetNames()[col_idx]);\n+\t\t\t\thstmt->error_messages.emplace_back(\"Error retriving #row: \" + std::to_string(row_idx) +\n+\t\t\t\t                                   \" and column: \" + hstmt->stmt->GetNames()[col_idx]);\n \t\t\t\tret = SQL_SUCCESS_WITH_INFO;\n \t\t\t}\n \t\t}\n \t}\n \n-\tif (stmt->rows_fetched_ptr) {\n-\t\t*stmt->rows_fetched_ptr = rows_fetched;\n+\tif (hstmt->rows_fetched_ptr) {\n+\t\t*hstmt->rows_fetched_ptr = rows_fetched;\n \t}\n \n \treturn ret;\n@@ -460,7 +460,7 @@ SQLLEN OdbcFetch::GetRowCount() {\n }\n \n void OdbcFetch::SetRowStatus(idx_t row_idx, SQLINTEGER status) {\n-\tif (stmt_ref->row_desc->ird->header.sql_desc_array_status_ptr) {\n-\t\tstmt_ref->row_desc->ird->header.sql_desc_array_status_ptr[row_idx] = status;\n+\tif (hstmt_ref->row_desc->ird->header.sql_desc_array_status_ptr) {\n+\t\thstmt_ref->row_desc->ird->header.sql_desc_array_status_ptr[row_idx] = status;\n \t}\n }\ndiff --git a/tools/odbc/odbc_utils.cpp b/tools/odbc/odbc_utils.cpp\nindex 355d24f9b184..d3b21c17df64 100644\n--- a/tools/odbc/odbc_utils.cpp\n+++ b/tools/odbc/odbc_utils.cpp\n@@ -103,62 +103,62 @@ string OdbcUtils::GetQueryDuckdbColumns(const string &catalog_filter, const stri\n                                         const string &table_filter, const string &column_filter) {\n \tstring sql_duckdb_columns = R\"(\n \t\tSELECT\n-\t\t\tNULL \"TABLE_CAT\", \n-\t\t\tschema_name \"TABLE_SCHEM\", \n-\t\t\ttable_name \"TABLE_NAME\", \n-\t\t\tcolumn_name \"COLUMN_NAME\", \n-\t\t\tdata_type_id \"DATA_TYPE\", \n-\t\t\tdata_type \"TYPE_NAME\", \n-\t\t\tCASE \n-\t\t\t\tWHEN data_type='DATE' THEN 12 \n-\t\t\t\tWHEN data_type='TIME' THEN 15 \n-\t\t\t\tWHEN data_type LIKE 'TIMESTAMP%' THEN 26 \n-\t\t\t\tWHEN data_type='CHAR' OR data_type='BOOLEAN' THEN 1 \n-\t\t\t\tWHEN data_type='VARCHAR' OR data_type='BLOB' THEN character_maximum_length \n-\t\t\t\tWHEN data_type LIKE '%INT%' THEN numeric_precision \n-\t\t\t\tWHEN data_type like 'DECIMAL%' THEN numeric_precision \n-\t\t\t\tWHEN data_type='FLOAT' OR data_type='DOUBLE' THEN numeric_precision \n-\t\t\t\tELSE NULL \n-\t\t\tEND as \"COLUMN_SIZE\", \n-\t\t\tCASE \n-\t\t\t\tWHEN data_type='DATE' THEN 4 \n-\t\t\t\tWHEN data_type='TIME' THEN 8 \n-\t\t\t\tWHEN data_type LIKE 'TIMESTAMP%' THEN 8 \n-\t\t\t\tWHEN data_type='CHAR' OR data_type='BOOLEAN' THEN 1 \n-\t\t\t\tWHEN data_type='VARCHAR' OR data_type='BLOB' THEN 16 \n-\t\t\t\tWHEN data_type LIKE '%TINYINT' THEN 1 \n-\t\t\t\tWHEN data_type LIKE '%SMALLINT' THEN 2 \n-\t\t\t\tWHEN data_type LIKE '%INTEGER' THEN 4 \n-\t\t\t\tWHEN data_type LIKE '%BIGINT' THEN 8 \n-\t\t\t\tWHEN data_type='HUGEINT' THEN 16 \n-\t\t\t\tWHEN data_type='FLOAT' THEN 4 \n-\t\t\t\tWHEN data_type='DOUBLE' THEN 8 \n-\t\t\t\tELSE NULL \n-\t\t\tEND as \"BUFFER_LENGTH\", \n-\t\t\tnumeric_scale \"DECIMAL_DIGITS\", \n-\t\t\tnumeric_precision_radix \"NUM_PREC_RADIX\", \n-\t\t\tCASE is_nullable \n-\t\t\t\tWHEN false THEN 0 \n-\t\t\t\tWHEN true THEN 1 \n-\t\t\t\tELSE 2 \n-\t\t\tEND as \"NULLABLE\", \n-\t\t\tNULL \"REMARKS\", \n-\t\t\tcolumn_default \"COLUMN_DEF\", \n-\t\t\tdata_type_id  \"SQL_DATA_TYPE\", \n-\t\t\tCASE \n-\t\t\t\tWHEN data_type='DATE' OR data_type='TIME' OR data_type LIKE 'TIMESTAMP%' THEN data_type_id \n-\t\t\t\tELSE NULL \n-\t\t\tEND as \"SQL_DATETIME_SUB\", \n-\t\t\tCASE  \n-\t\t\t\tWHEN data_type='%CHAR' OR data_type='BLOB' THEN character_maximum_length \n-\t\t\t\tELSE NULL \n-\t\t\tEND as \"CHAR_OCTET_LENGTH\", \n-\t\t\tcolumn_index as \"ORDINAL_POSITION\", \n-\t\t\tCASE is_nullable \n-\t\t\t\tWHEN false THEN 'NO' \n-\t\t\t\tWHEN true THEN 'YES' \n-\t\t\t\tELSE '' \n-\t\t\tEND as \"IS_NULLABLE\" \n+\t\t\tNULL \"TABLE_CAT\",\n+\t\t\tschema_name \"TABLE_SCHEM\",\n+\t\t\ttable_name \"TABLE_NAME\",\n+\t\t\tcolumn_name \"COLUMN_NAME\",\n+\t\t\tdata_type_id \"DATA_TYPE\",\n+\t\t\tdata_type \"TYPE_NAME\",\n+\t\t\tCASE\n+\t\t\t\tWHEN data_type='DATE' THEN 12\n+\t\t\t\tWHEN data_type='TIME' THEN 15\n+\t\t\t\tWHEN data_type LIKE 'TIMESTAMP%' THEN 26\n+\t\t\t\tWHEN data_type='CHAR' OR data_type='BOOLEAN' THEN 1\n+\t\t\t\tWHEN data_type='VARCHAR' OR data_type='BLOB' THEN character_maximum_length\n+\t\t\t\tWHEN data_type LIKE '%INT%' THEN numeric_precision\n+\t\t\t\tWHEN data_type like 'DECIMAL%' THEN numeric_precision\n+\t\t\t\tWHEN data_type='FLOAT' OR data_type='DOUBLE' THEN numeric_precision\n+\t\t\t\tELSE NULL\n+\t\t\tEND as \"COLUMN_SIZE\",\n+\t\t\tCASE\n+\t\t\t\tWHEN data_type='DATE' THEN 4\n+\t\t\t\tWHEN data_type='TIME' THEN 8\n+\t\t\t\tWHEN data_type LIKE 'TIMESTAMP%' THEN 8\n+\t\t\t\tWHEN data_type='CHAR' OR data_type='BOOLEAN' THEN 1\n+\t\t\t\tWHEN data_type='VARCHAR' OR data_type='BLOB' THEN 16\n+\t\t\t\tWHEN data_type LIKE '%TINYINT' THEN 1\n+\t\t\t\tWHEN data_type LIKE '%SMALLINT' THEN 2\n+\t\t\t\tWHEN data_type LIKE '%INTEGER' THEN 4\n+\t\t\t\tWHEN data_type LIKE '%BIGINT' THEN 8\n+\t\t\t\tWHEN data_type='HUGEINT' THEN 16\n+\t\t\t\tWHEN data_type='FLOAT' THEN 4\n+\t\t\t\tWHEN data_type='DOUBLE' THEN 8\n+\t\t\t\tELSE NULL\n+\t\t\tEND as \"BUFFER_LENGTH\",\n+\t\t\tnumeric_scale \"DECIMAL_DIGITS\",\n+\t\t\tnumeric_precision_radix \"NUM_PREC_RADIX\",\n+\t\t\tCASE is_nullable\n+\t\t\t\tWHEN false THEN 0\n+\t\t\t\tWHEN true THEN 1\n+\t\t\t\tELSE 2\n+\t\t\tEND as \"NULLABLE\",\n+\t\t\tNULL \"REMARKS\",\n+\t\t\tcolumn_default \"COLUMN_DEF\",\n+\t\t\tdata_type_id  \"SQL_DATA_TYPE\",\n+\t\t\tCASE\n+\t\t\t\tWHEN data_type='DATE' OR data_type='TIME' OR data_type LIKE 'TIMESTAMP%' THEN data_type_id\n+\t\t\t\tELSE NULL\n+\t\t\tEND as \"SQL_DATETIME_SUB\",\n+\t\t\tCASE\n+\t\t\t\tWHEN data_type='%CHAR' OR data_type='BLOB' THEN character_maximum_length\n+\t\t\t\tELSE NULL\n+\t\t\tEND as \"CHAR_OCTET_LENGTH\",\n+\t\t\tcolumn_index as \"ORDINAL_POSITION\",\n+\t\t\tCASE is_nullable\n+\t\t\t\tWHEN false THEN 'NO'\n+\t\t\t\tWHEN true THEN 'YES'\n+\t\t\t\tELSE ''\n+\t\t\tEND as \"IS_NULLABLE\"\n \t\tFROM duckdb_columns\n \t)\";\n \n@@ -190,16 +190,16 @@ string OdbcUtils::GetQueryDuckdbColumns(const string &catalog_filter, const stri\n string OdbcUtils::GetQueryDuckdbTables(const string &schema_filter, const string &table_filter,\n                                        const string &table_type_filter) {\n \tstring sql_duckdb_tables = R\"(\n-\t\tSELECT \n-\t\t\ttable_catalog::VARCHAR \"TABLE_CAT\", \n-\t\t\ttable_schema \"TABLE_SCHEM\", \n-\t\t\ttable_name \"TABLE_NAME\", \n-\t\t\tCASE \n-\t\t\t\tWHEN table_type='BASE TABLE' \n-\t\t\t\tTHEN 'TABLE' \n-\t\t\t\tELSE table_type \n-\t\t\tEND \"TABLE_TYPE\", \n-\t\t\t'' \"REMARKS\"  \n+\t\tSELECT\n+\t\t\ttable_catalog::VARCHAR \"TABLE_CAT\",\n+\t\t\ttable_schema \"TABLE_SCHEM\",\n+\t\t\ttable_name \"TABLE_NAME\",\n+\t\t\tCASE\n+\t\t\t\tWHEN table_type='BASE TABLE'\n+\t\t\t\tTHEN 'TABLE'\n+\t\t\t\tELSE table_type\n+\t\t\tEND \"TABLE_TYPE\",\n+\t\t\t'' \"REMARKS\"\n \t\t\tFROM information_schema.tables\n \t)\";\n \n@@ -244,3 +244,7 @@ void OdbcUtils::SetValueFromConnStr(SQLCHAR *conn_c_str, const char *key, string\n \tstring conn_str((char *)conn_c_str);\n \tSetValueFromConnStr(conn_str, key, value);\n }\n+\n+SQLUINTEGER OdbcUtils::SQLPointerToSQLUInteger(SQLPOINTER value) {\n+\treturn static_cast<SQLUINTEGER>(reinterpret_cast<SQLULEN>(value));\n+}\ndiff --git a/tools/odbc/result.cpp b/tools/odbc/result.cpp\nindex de43685106b8..ae0b2c11e956 100644\n--- a/tools/odbc/result.cpp\n+++ b/tools/odbc/result.cpp\n@@ -9,8 +9,12 @@\n \n SQLRETURN SQL_API SQLGetData(SQLHSTMT statement_handle, SQLUSMALLINT col_or_param_num, SQLSMALLINT target_type,\n                              SQLPOINTER target_value_ptr, SQLLEN buffer_length, SQLLEN *str_len_or_ind_ptr) {\n+\tduckdb::OdbcHandleStmt *hstmt = nullptr;\n+\tif (ConvertHSTMTResult(statement_handle, hstmt) != SQL_SUCCESS) {\n+\t\treturn SQL_ERROR;\n+\t}\n \n-\treturn duckdb::GetDataStmtResult(statement_handle, col_or_param_num, target_type, target_value_ptr, buffer_length,\n+\treturn duckdb::GetDataStmtResult(hstmt, col_or_param_num, target_type, target_value_ptr, buffer_length,\n \t                                 str_len_or_ind_ptr);\n }\n \n@@ -50,7 +54,7 @@ SQLRETURN SQL_API SQLFetch(SQLHSTMT statement_handle) {\n \tif (ret != SQL_SUCCESS) {\n \t\treturn ret;\n \t}\n-\treturn duckdb::FetchStmtResult(statement_handle);\n+\treturn duckdb::FetchStmtResult(hstmt);\n }\n \n SQLRETURN SQL_API SQLFetchScroll(SQLHSTMT statement_handle, SQLSMALLINT fetch_orientation, SQLLEN fetch_offset) {\n@@ -58,9 +62,14 @@ SQLRETURN SQL_API SQLFetchScroll(SQLHSTMT statement_handle, SQLSMALLINT fetch_or\n \tcase SQL_FETCH_FIRST:\n \tcase SQL_FETCH_ABSOLUTE:\n \tcase SQL_FETCH_PRIOR:\n-\tcase SQL_FETCH_NEXT:\n+\tcase SQL_FETCH_NEXT: {\n \t\t// passing \"fetch_offset - 1\", the DuckDB's internal row index starts in 0\n-\t\treturn duckdb::FetchStmtResult(statement_handle, fetch_orientation, fetch_offset - 1);\n+\t\tduckdb::OdbcHandleStmt *hstmt = nullptr;\n+\t\tif (ConvertHSTMTPrepared(statement_handle, hstmt) != SQL_SUCCESS) {\n+\t\t\treturn SQL_ERROR;\n+\t\t}\n+\t\treturn duckdb::FetchStmtResult(hstmt, fetch_orientation, fetch_offset - 1);\n+\t}\n \tdefault:\n \t\treturn SQL_ERROR;\n \t}\ndiff --git a/tools/odbc/statement.cpp b/tools/odbc/statement.cpp\nindex 401fa3a5fc20..cb782647c033 100644\n--- a/tools/odbc/statement.cpp\n+++ b/tools/odbc/statement.cpp\n@@ -66,7 +66,7 @@ SQLRETURN SQL_API SQLSetStmtAttr(SQLHSTMT statement_handle, SQLINTEGER attribute\n \t\tif (value_ptr == nullptr) {\n \t\t\treturn SQL_ERROR;\n \t\t}\n-\t\thstmt->row_desc->ard->header.sql_desc_bind_type = *(SQLULEN *)value_ptr;\n+\t\thstmt->row_desc->ard->header.sql_desc_bind_type = (SQLULEN)value_ptr;\n \t\treturn SQL_SUCCESS;\n \t}\n \tcase SQL_ATTR_ROW_STATUS_PTR: {\ndiff --git a/tools/odbc/statement_functions.cpp b/tools/odbc/statement_functions.cpp\nindex d65d1a1d1864..3184bad1eac6 100644\n--- a/tools/odbc/statement_functions.cpp\n+++ b/tools/odbc/statement_functions.cpp\n@@ -89,7 +89,7 @@ SQLRETURN duckdb::BatchExecuteStmt(SQLHSTMT statement_handle) {\n \n \t// now, fetching the first chunk to verify constant folding (See: PR #2462 and issue #2452)\n \tif (ret == SQL_SUCCESS) {\n-\t\tauto fetch_ret = hstmt->odbc_fetcher->FetchFirst(statement_handle, hstmt);\n+\t\tauto fetch_ret = hstmt->odbc_fetcher->FetchFirst(hstmt);\n \t\tif (fetch_ret == SQL_ERROR) {\n \t\t\treturn fetch_ret;\n \t\t}\n@@ -130,22 +130,17 @@ SQLRETURN duckdb::SingleExecuteStmt(duckdb::OdbcHandleStmt *stmt) {\n \treturn SQL_SUCCESS;\n }\n \n-SQLRETURN duckdb::FetchStmtResult(SQLHSTMT statement_handle, SQLSMALLINT fetch_orientation, SQLLEN fetch_offset) {\n-\tduckdb::OdbcHandleStmt *hstmt = nullptr;\n-\tif (ConvertHSTMTResult(statement_handle, hstmt) != SQL_SUCCESS) {\n-\t\treturn SQL_ERROR;\n-\t}\n-\n+SQLRETURN duckdb::FetchStmtResult(duckdb::OdbcHandleStmt *hstmt, SQLSMALLINT fetch_orientation, SQLLEN fetch_offset) {\n \tif (!hstmt->open) {\n \t\treturn SQL_NO_DATA;\n \t}\n-\tSQLRETURN ret = hstmt->odbc_fetcher->Fetch(statement_handle, hstmt, fetch_orientation, fetch_offset);\n+\tSQLRETURN ret = hstmt->odbc_fetcher->Fetch(hstmt, fetch_orientation, fetch_offset);\n \tif (!SQL_SUCCEEDED(ret)) {\n \t\treturn ret;\n \t}\n \n \thstmt->odbc_fetcher->AssertCurrentChunk();\n-\treturn SQL_SUCCESS;\n+\treturn ret;\n }\n \n //! Static fuctions used by GetDataStmtResult //\n@@ -251,13 +246,8 @@ SQLRETURN GetVariableValue(const std::string &val_str, SQLUSMALLINT col_idx, duc\n \treturn ret;\n }\n \n-SQLRETURN duckdb::GetDataStmtResult(SQLHSTMT statement_handle, SQLUSMALLINT col_or_param_num, SQLSMALLINT target_type,\n+SQLRETURN duckdb::GetDataStmtResult(OdbcHandleStmt *hstmt, SQLUSMALLINT col_or_param_num, SQLSMALLINT target_type,\n                                     SQLPOINTER target_value_ptr, SQLLEN buffer_length, SQLLEN *str_len_or_ind_ptr) {\n-\tduckdb::OdbcHandleStmt *hstmt = nullptr;\n-\tif (ConvertHSTMTResult(statement_handle, hstmt) != SQL_SUCCESS) {\n-\t\treturn SQL_ERROR;\n-\t}\n-\n \tif (!target_value_ptr && !OdbcUtils::IsCharType(target_type)) {\n \t\treturn SQL_ERROR;\n \t}\n",
  "test_patch": "diff --git a/tools/odbc/test/CMakeLists.txt b/tools/odbc/test/CMakeLists.txt\nindex 192495c5ba9c..e418c1058187 100644\n--- a/tools/odbc/test/CMakeLists.txt\n+++ b/tools/odbc/test/CMakeLists.txt\n@@ -14,6 +14,7 @@ add_executable(\n   tests/connect.cpp\n   tests/diagnostics.cpp\n   tests/select.cpp\n-  tests/row_wise_fetching.cpp)\n+  tests/row_wise_fetching.cpp\n+  tests/set_attr.cpp)\n \n target_link_libraries(test_odbc duckdb_odbc ODBC::ODBC)\ndiff --git a/tools/odbc/test/psql_supported_tests b/tools/odbc/test/psql_supported_tests\nindex bb9c9a2df2dc..2cff0ad34f0c 100644\n--- a/tools/odbc/test/psql_supported_tests\n+++ b/tools/odbc/test/psql_supported_tests\n@@ -13,5 +13,4 @@ multicolumn-param-bind-test\n numeric-test\n quotes-test\n result-conversions-test\n-row-wise-fetching-test\n select-test\ndiff --git a/tools/odbc/test/tests/catalog_functions.cpp b/tools/odbc/test/tests/catalog_functions.cpp\nindex 880105534fa8..08fba2d116dc 100644\n--- a/tools/odbc/test/tests/catalog_functions.cpp\n+++ b/tools/odbc/test/tests/catalog_functions.cpp\n@@ -54,6 +54,67 @@ void TestGetTypeInfo(HSTMT &hstmt, std::map<SQLSMALLINT, SQLULEN> &types_map) {\n \t\t}\n \t\tDATA_CHECK(hstmt, i + 1, expected_data[i].second.c_str());\n \t}\n+\n+\t// Test SQLGetTypeInfo with SQL_ALL_TYPES and data_type\n+\tSQLINTEGER data_type;\n+\tSQLLEN row_count = 0;\n+\tSQLLEN len_or_ind_ptr;\n+\tEXECUTE_AND_CHECK(\"SQLBindCol\", SQLBindCol, hstmt, 2, SQL_INTEGER, &data_type, sizeof(data_type), &len_or_ind_ptr);\n+\tEXECUTE_AND_CHECK(\"SQLGetTypeInfo(SQL_ALL_TYPES)\", SQLGetTypeInfo, hstmt, SQL_ALL_TYPES);\n+\n+\tSQLINTEGER data_types[] = {\n+\t    SQL_CHAR,\n+\t    SQL_BIT,\n+\t    SQL_TINYINT,\n+\t    SQL_SMALLINT,\n+\t    SQL_INTEGER,\n+\t    SQL_BIGINT,\n+\t    SQL_TYPE_DATE,\n+\t    SQL_TYPE_TIME,\n+\t    SQL_TYPE_TIMESTAMP,\n+\t    SQL_DECIMAL,\n+\t    SQL_NUMERIC,\n+\t    SQL_FLOAT,\n+\t    SQL_DOUBLE,\n+\t    SQL_VARCHAR,\n+\t    SQL_VARBINARY,\n+\t    SQL_INTERVAL_YEAR,\n+\t    SQL_INTERVAL_MONTH,\n+\t    SQL_INTERVAL_DAY,\n+\t    SQL_INTERVAL_HOUR,\n+\t    SQL_INTERVAL_MINUTE,\n+\t    SQL_INTERVAL_SECOND,\n+\t    SQL_INTERVAL_YEAR_TO_MONTH,\n+\t    SQL_INTERVAL_DAY_TO_HOUR,\n+\t    SQL_INTERVAL_DAY_TO_MINUTE,\n+\t    SQL_INTERVAL_DAY_TO_SECOND,\n+\t    SQL_INTERVAL_HOUR_TO_MINUTE,\n+\t    SQL_INTERVAL_HOUR_TO_SECOND,\n+\t    SQL_INTERVAL_MINUTE_TO_SECOND,\n+\t};\n+\n+\twhile (SQLFetch(hstmt) != SQL_NO_DATA) {\n+\t\tREQUIRE(data_type == data_types[row_count]);\n+\t\trow_count++;\n+\t}\n+\n+\t// When type is not supported, SQLGetTypeInfo returns SQL_SUCCESS_WITH_INFO\n+\tEXECUTE_AND_CHECK(\"SQLBindCol\", SQLBindCol, hstmt, 2, SQL_C_SHORT, &data_type, sizeof(data_type), &len_or_ind_ptr);\n+\tEXECUTE_AND_CHECK(\"SQLGetTypeInfo(SQL_ALL_TYPES)\", SQLGetTypeInfo, hstmt, SQL_ALL_TYPES);\n+\n+\tSQLRETURN ret;\n+\twhile ((ret = SQLFetch(hstmt)) != SQL_NO_DATA) {\n+\t\tstd::string state, message;\n+\t\tREQUIRE(ret == SQL_SUCCESS_WITH_INFO);\n+\t\tACCESS_DIAGNOSTIC(state, message, hstmt, SQL_HANDLE_STMT);\n+\t\tREQUIRE(state == \"07006\");\n+\t\tREQUIRE(message == \"ODBC_DuckDB->GetDataStmtResult\\n\"\n+\t\t                   \"Unsupported type\");\n+\t\trow_count++;\n+\t}\n+\n+\t// unbind column\n+\tEXECUTE_AND_CHECK(\"SQLBindCol\", SQLBindCol, hstmt, 2, SQL_C_SHORT, nullptr, 0, nullptr);\n }\n \n static void TestSQLTables(HSTMT &hstmt, std::map<SQLSMALLINT, SQLULEN> &types_map) {\n@@ -85,7 +146,15 @@ static void TestSQLTables(HSTMT &hstmt, std::map<SQLSMALLINT, SQLULEN> &types_ma\n \t\tif (ret == SQL_NO_DATA) {\n \t\t\tbreak;\n \t\t}\n-\t\tODBC_CHECK(ret, \"SQLFetch\");\n+\t\tif (ret == SQL_SUCCESS_WITH_INFO) {\n+\t\t\tstd::string state, message;\n+\t\t\tACCESS_DIAGNOSTIC(state, message, hstmt, SQL_HANDLE_STMT);\n+\t\t\tREQUIRE(state == \"07006\");\n+\t\t\tREQUIRE(message == \"ODBC_DuckDB->GetInternalValue\\n\"\n+\t\t\t                   \"Invalid Input Error: Failed to cast value: Could not convert string 'main' to INT32\");\n+\t\t} else {\n+\t\t\tODBC_CHECK(ret, \"SQLFetch\");\n+\t\t}\n \t\tfetch_count++;\n \n \t\tDATA_CHECK(hstmt, 1, \"memory\");\n@@ -161,7 +230,17 @@ static void TestSQLColumns(HSTMT &hstmt, std::map<SQLSMALLINT, SQLULEN> &types_m\n \t    {\"test_view\", \"id\", \"13\", \"INTEGER\"},       {\"test_view\", \"t\", \"25\", \"VARCHAR\"}};\n \n \tfor (int i = 0; i < expected_data.size(); i++) {\n-\t\tEXECUTE_AND_CHECK(\"SQLFetch\", SQLFetch, hstmt);\n+\t\tSQLRETURN ret = SQLFetch(hstmt);\n+\t\tif (ret == SQL_SUCCESS_WITH_INFO) {\n+\t\t\tstd::string state, message;\n+\t\t\tACCESS_DIAGNOSTIC(state, message, hstmt, SQL_HANDLE_STMT);\n+\t\t\tREQUIRE(state == \"07006\");\n+\t\t\tREQUIRE(message == \"ODBC_DuckDB->GetInternalValue\\nInvalid Input Error: Failed to cast value: Could not \"\n+\t\t\t                   \"convert string 'main' to INT32\");\n+\t\t\tret = SQL_SUCCESS;\n+\t\t} else {\n+\t\t\tODBC_CHECK(ret, \"SQLFetch\");\n+\t\t}\n \n \t\tauto &entry = expected_data[i];\n \t\tDATA_CHECK(hstmt, 1, nullptr);\ndiff --git a/tools/odbc/test/tests/set_attr.cpp b/tools/odbc/test/tests/set_attr.cpp\nnew file mode 100644\nindex 000000000000..feaae48fa44a\n--- /dev/null\n+++ b/tools/odbc/test/tests/set_attr.cpp\n@@ -0,0 +1,77 @@\n+#include \"../common.h\"\n+\n+#include <iostream>\n+\n+using namespace odbc_test;\n+\n+TEST_CASE(\"Test SQL_ATTR_ROW_BIND_TYPE attribute in SQLSetStmtAttr\", \"[odbc]\") {\n+\tSQLHANDLE env;\n+\tSQLHANDLE dbc;\n+\n+\tHSTMT hstmt = SQL_NULL_HSTMT;\n+\n+\t// Connect to the database using SQLConnect\n+\tCONNECT_TO_DATABASE(env, dbc);\n+\n+\t// Allocate a statement handle\n+\tEXECUTE_AND_CHECK(\"SQLAllocHandle (HSTMT)\", SQLAllocHandle, SQL_HANDLE_STMT, dbc, &hstmt);\n+\n+\t// Set the statement attribute SQL_ATTR_ROW_BIND_TYPE\n+\tuint64_t row_len = 256;\n+\tEXECUTE_AND_CHECK(\"SQLSetStmtAttr (SQL_ATTR_ROW_BIND_TYPE)\", SQLSetStmtAttr, hstmt, SQL_ATTR_ROW_BIND_TYPE,\n+\t                  (SQLPOINTER)row_len, SQL_IS_INTEGER);\n+\n+\t// Check the statement attribute SQL_ATTR_ROW_BIND_TYPE\n+\tSQLULEN buf;\n+\tEXECUTE_AND_CHECK(\"SQLGetStmtAttr (SQL_ATTR_ROW_BIND_TYPE)\", SQLGetStmtAttr, hstmt, SQL_ATTR_ROW_BIND_TYPE, &buf,\n+\t                  sizeof(buf), nullptr);\n+\tREQUIRE(row_len == buf);\n+\n+\t// Free the statement handle\n+\tEXECUTE_AND_CHECK(\"SQLFreeStmt (HSTMT)\", SQLFreeStmt, hstmt, SQL_CLOSE);\n+\tEXECUTE_AND_CHECK(\"SQLFreeHandle (HSTMT)\", SQLFreeHandle, SQL_HANDLE_STMT, hstmt);\n+\n+\tDISCONNECT_FROM_DATABASE(env, dbc);\n+}\n+\n+TEST_CASE(\"Test SQL_ATTR_ACCESS_MODE and SQL_ATTR_METADATA_ID attribute in SQLSetConnectAttr\", \"[odbc]\") {\n+\tSQLHANDLE env;\n+\tSQLHANDLE dbc;\n+\n+\tHSTMT hstmt = SQL_NULL_HSTMT;\n+\n+\t// Connect to the database using SQLConnect\n+\tCONNECT_TO_DATABASE(env, dbc);\n+\n+\t// Allocate a statement handle\n+\tEXECUTE_AND_CHECK(\"SQLAllocHandle (HSTMT)\", SQLAllocHandle, SQL_HANDLE_STMT, dbc, &hstmt);\n+\n+\t// Set the Connect attribute SQL_ATTR_ACCESS_MODE to SQL_MODE_READ_ONLY\n+\tEXECUTE_AND_CHECK(\"SQLSetConnectAttr (SQL_ATTR_ACCESS_MODE)\", SQLSetConnectAttr, dbc, SQL_ATTR_ACCESS_MODE,\n+\t                  (SQLPOINTER)SQL_MODE_READ_ONLY, SQL_IS_INTEGER);\n+\n+\t// Check the Connect attribute SQL_ATTR_ACCESS_MODE\n+\tSQLUINTEGER buf;\n+\tEXECUTE_AND_CHECK(\"SQLGetConnectAttr (SQL_ATTR_ACCESS_MODE)\", SQLGetConnectAttr, dbc, SQL_ATTR_ACCESS_MODE, &buf,\n+\t                  sizeof(buf), nullptr);\n+\tREQUIRE(SQL_MODE_READ_ONLY == buf);\n+\n+\t// Set the Connect attribute SQL_ATTR_ACCESS_MODE to SQL_MODE_READ_WRITE\n+\tEXECUTE_AND_CHECK(\"SQLSetConnectAttr (SQL_ATTR_ACCESS_MODE)\", SQLSetConnectAttr, dbc, SQL_ATTR_ACCESS_MODE,\n+\t                  (SQLPOINTER)SQL_MODE_READ_WRITE, SQL_IS_INTEGER);\n+\n+\t// Check the Connect attribute SQL_ATTR_ACCESS_MODE\n+\tEXECUTE_AND_CHECK(\"SQLGetConnectAttr (SQL_ATTR_ACCESS_MODE)\", SQLGetConnectAttr, dbc, SQL_ATTR_ACCESS_MODE, &buf,\n+\t                  sizeof(buf), nullptr);\n+\tREQUIRE(SQL_MODE_READ_WRITE == buf);\n+\n+\t// Set the Connect attribute SQL_ATTR_METADATA_ID to SQL_TRUE\n+\tEXECUTE_AND_CHECK(\"SQLSetConnectAttr (SQL_ATTR_METADATA_ID)\", SQLSetConnectAttr, dbc, SQL_ATTR_METADATA_ID,\n+\t                  (SQLPOINTER)SQL_TRUE, SQL_IS_INTEGER);\n+\n+\t// Free the statement handle\n+\tEXECUTE_AND_CHECK(\"SQLFreeStmt (HSTMT)\", SQLFreeStmt, hstmt, SQL_CLOSE);\n+\tEXECUTE_AND_CHECK(\"SQLFreeHandle (HSTMT)\", SQLFreeHandle, SQL_HANDLE_STMT, hstmt);\n+\n+\tDISCONNECT_FROM_DATABASE(env, dbc);\n+}\n",
  "problem_statement": "ODBC: Crash calling SQLSetStmtAttr(SQL_ATTR_ROW_BIND_TYPE)\n### What happens?\n\nWe're seeing a SEGV trying to call SQLSetStmtAttr(SQL_ATTR_ROW_BIND_TYPE, <non-zero size>) in the DuckDB ODBC driver.\r\nI've traced the issue to SQLSetStmtAttr in duckdb-master\\tools\\odbc\\statement.cpp. This line:\r\n\r\n`stmt->row_desc->ard->header.sql_desc_bind_type = *(SQLULEN *)value_ptr;`\r\n\r\nis trying to dereference the passed-in value_ptr, but for this attribute the value in value_ptr is the actual SQLULEN value, NOT a pointer. This value should be stored as-is instead of being dereferenced.\n\n### To Reproduce\n\nrc = SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_BIND_TYPE, 256, SQL_IS_UINTEGER);\n\n### OS:\n\nRHEL 8.4 x64\n\n### DuckDB Version:\n\nv0.8.0\n\n### DuckDB Client:\n\nODBC 03.00.0000\n\n### Full Name:\n\nChris DeHart\n\n### Affiliation:\n\nSAS\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Hey, I am picking up some work on our ODBC driver. \r\n\r\nWhen using the code you provided we cannot get it to compile using C++ as `256` is an integer which cannot be converted to `SQLPOINTER` (aka `void *`). Can you maybe provide a bit more context/code on reproducing the segfault? This will also help us to permanently add this to our tests and prevent breaking in the future.\r\n\r\nThank you for tracing the issue to `tools\\odbc\\statement.cpp`, you are correct that the `value_ptr` is being cast to a `SQLULEN *` and is then deferenced. We are going to see if we can change that without breaking anything. As per API, it indeed expects a value, not a pointer. \nThanks for taking a look at this one.\r\n\r\nIn our production code, we just add a cast:\r\n\r\nuint64_t  rowLen;\r\nrowLen = 256;\r\nrc = SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_BIND_TYPE, **(SQLPOINTER)rowLen**, SQL_IS_UINTEGER);\nThanks for sending me your production code. \r\n\r\nI've debugged your code, and it looks like the segmentation fault actually happens when calling the function rather than in the function body.  So most likely it's the cast that is causing the segmentation fault as it passes the value of `rowLen` directly as a pointer, rather than passing a pointer to the variable using the address-of operator (`&`).  By casting `rowLen` to a pointer directly you are essentially passing the value of `rowLen` instead of its address, which is what the function expects.\r\n\r\nThe following should fix your segmentation fault and properly set the `SQL_ATTR_ROW_BIND_TYPE`.\r\n``` C\r\nuint64_t rowLen;\r\nrowLen = 256;\r\nrc = SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_BIND_TYPE, &rowLen, SQL_IS_UINTEGER);\r\n```\r\n\r\nNonetheless, I will still look at the code you pointed out in `tools\\odbc\\statement.cpp`, as it can definitely use some refining. \nThat's not quite how SQLSetStmtAttr works.  From the API doc [here](https://learn.microsoft.com/en-us/sql/odbc/reference/syntax/sqlsetstmtattr-function), the ValuePtr argument is:\r\n\r\n```\r\nValue to be associated with Attribute. Depending on the value of Attribute, ValuePtr will be one of the following:\r\n\r\n- An ODBC descriptor handle.\r\n- A SQLUINTEGER value.\r\n- A SQLULEN value.\r\n- A pointer to one of the following:\r\n    -     A null-terminated character string.\r\n    -     A binary buffer.\r\n    -     A value or array of type SQLLEN, SQLULEN, or SQLUSMALLINT.\r\n    -     A driver-defined value.\r\n```\r\nLater, in the description for SQL_ATTR_ROW_BIND_TYPE, there's this:\r\n\r\n`An SQLULEN value that sets the binding orientation to be used when...`\r\n\r\nThis means it's passed as a value rather than a pointer.\r\nThere's also an example in the doc for row-wise binding that shows setting it [here](https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/row-wise-binding).\r\n\r\n\nYes, I think you are correct.  I will have a closer look and alter the code accordingly.",
  "created_at": "2023-07-10T13:54:12Z"
}