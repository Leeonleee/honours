{
  "repo": "duckdb/duckdb",
  "pull_number": 1429,
  "instance_id": "duckdb__duckdb-1429",
  "issue_numbers": [
    "1415"
  ],
  "base_commit": "9b5955456aa58a854eebd9317810668d2eb0a01a",
  "patch": "diff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp\nindex bac7cb9f1275..dc1e37446600 100644\n--- a/src/common/operator/cast_operators.cpp\n+++ b/src/common/operator/cast_operators.cpp\n@@ -680,6 +680,9 @@ static bool IntegerCastLoop(const char *buf, idx_t len, T &result, bool strict)\n \t\t\t}\n \t\t\tif (ALLOW_EXPONENT) {\n \t\t\t\tif (buf[pos] == 'e' || buf[pos] == 'E') {\n+\t\t\t\t\tif (pos == start_pos) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n \t\t\t\t\tpos++;\n \t\t\t\t\tint64_t exponent = 0;\n \t\t\t\t\tint negative = buf[pos] == '-';\n@@ -856,6 +859,9 @@ static bool DoubleCastLoop(const char *buf, idx_t len, T &result, bool strict) {\n \t\t\t\tComputeDoubleResult<T, NEGATIVE>(result, decimal, decimal_factor);\n \t\t\t\treturn true;\n \t\t\t} else if (buf[pos] == 'e' || buf[pos] == 'E') {\n+\t\t\t\tif (pos == start_pos) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n \t\t\t\t// E power\n \t\t\t\t// parse an integer, this time not allowing another exponent\n \t\t\t\tpos++;\n",
  "test_patch": "diff --git a/test/sql/cast/test_exponent_in_cast.test b/test/sql/cast/test_exponent_in_cast.test\nnew file mode 100644\nindex 000000000000..58e7a21afa29\n--- /dev/null\n+++ b/test/sql/cast/test_exponent_in_cast.test\n@@ -0,0 +1,44 @@\n+# name: test/sql/cast/test_exponent_in_cast.test\n+# description: Test exponents in cast\n+# group: [cast]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement error\n+SELECT CAST('e1' AS INTEGER);\n+\n+statement error\n+SELECT CAST('  e1' AS INTEGER);\n+\n+statement error\n+SELECT CAST('  E1' AS INTEGER);\n+\n+statement error\n+SELECT CAST('e1' AS DOUBLE);\n+\n+statement error\n+SELECT CAST('  e1' AS DOUBLE);\n+\n+statement error\n+SELECT CAST('  E1' AS DOUBLE);\n+\n+query I\n+SELECT CAST('1e1' AS INTEGER);\n+----\n+10\n+\n+query I\n+SELECT CAST('  1e1' AS INTEGER);\n+----\n+10\n+\n+query I\n+SELECT CAST('1e1' AS DOUBLE);\n+----\n+10.0\n+\n+query I\n+SELECT CAST('   1e1' AS DOUBLE);\n+----\n+10.0\n\\ No newline at end of file\n",
  "problem_statement": "Exponential format casting\nSurprised to find my CSV with ID values like \"E41000051\" were being read by read_csv_auto as -2147483648.\r\n\r\nWhat seems to be happening is that strings like that can be CAST to integer without a warning:\r\n\r\n```\r\n select cast('E99999' as integer);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 CAST[INTEGER](E99999) \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 -2147483648           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nand so the CSV gets a column of those values. \r\n\r\nFigured this might have something to do with exponential notation (eg where \"2E3\" = 2000). The sqlite3 numeric literal syntax diagram:\r\n\r\n https://sqlite.org/syntax/numeric-literal.html\r\n\r\nshows it MUST have something before the E or its invalid, and SQLite does cast these strings to zero (as it seems to do with clearly non-numeric format strings). I can't find a syntax diagram for a numeric literal for duckdb though.\r\n\r\nAlthough duckdb casts 'E1' to integer as 0, it raises a conversion error when converting to numeric (decimal(18,3)). Not sure what's going on there.\r\n\r\nI've put together a quick test set with most of the possibilities I can think of, and run on duckdb and sqlite for comparison. Attached is a zip with the test SQL and outputs.\r\n\r\nThe problem at the moment is I don't know what the correct returned values for these cast operations should be - I'm guessing that \"the documentation is the code\" at the moment, but I'm also not sure if you are aiming for compatibility with any other SQL dialect.\r\n\r\nFor now I'll continue experimenting with duckdb but reading my CSVs as all varchars!\r\n\r\nThanks\r\n\r\n\r\n[parse_E.zip](https://github.com/cwida/duckdb/files/6004077/parse_E.zip)\r\n\r\n\r\n\n",
  "hints_text": "Thanks for the report! I completely agree that the scientific notation should fail to parse without a number preceding the E in strict mode. The fact that 'E9999' is parsed as an integer seems like a bug - this should trigger an overflow error similar to how e.g. `cast('10000000000000' as integer);` triggers an overflow. I will investigate.",
  "created_at": "2021-02-22T10:31:40Z"
}