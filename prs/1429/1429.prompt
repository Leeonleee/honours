You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Exponential format casting
Surprised to find my CSV with ID values like "E41000051" were being read by read_csv_auto as -2147483648.

What seems to be happening is that strings like that can be CAST to integer without a warning:

```
 select cast('E99999' as integer);
┌───────────────────────┐
│ CAST[INTEGER](E99999) │
├───────────────────────┤
│ -2147483648           │
└───────────────────────┘
```

and so the CSV gets a column of those values. 

Figured this might have something to do with exponential notation (eg where "2E3" = 2000). The sqlite3 numeric literal syntax diagram:

 https://sqlite.org/syntax/numeric-literal.html

shows it MUST have something before the E or its invalid, and SQLite does cast these strings to zero (as it seems to do with clearly non-numeric format strings). I can't find a syntax diagram for a numeric literal for duckdb though.

Although duckdb casts 'E1' to integer as 0, it raises a conversion error when converting to numeric (decimal(18,3)). Not sure what's going on there.

I've put together a quick test set with most of the possibilities I can think of, and run on duckdb and sqlite for comparison. Attached is a zip with the test SQL and outputs.

The problem at the moment is I don't know what the correct returned values for these cast operations should be - I'm guessing that "the documentation is the code" at the moment, but I'm also not sure if you are aiming for compatibility with any other SQL dialect.

For now I'll continue experimenting with duckdb but reading my CSVs as all varchars!

Thanks


[parse_E.zip](https://github.com/cwida/duckdb/files/6004077/parse_E.zip)




</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of src/common/operator/cast_operators.cpp]
1: #include "duckdb/common/operator/cast_operators.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/limits.hpp"
5: #include "duckdb/common/string_util.hpp"
6: #include "duckdb/common/types/blob.hpp"
7: #include "duckdb/common/types/cast_helpers.hpp"
8: #include "duckdb/common/types/date.hpp"
9: #include "duckdb/common/types/decimal.hpp"
10: #include "duckdb/common/types/hugeint.hpp"
11: #include "duckdb/common/types/interval.hpp"
12: #include "duckdb/common/types/time.hpp"
13: #include "duckdb/common/types/timestamp.hpp"
14: #include "duckdb/common/types/vector.hpp"
15: #include "fmt/format.h"
16: 
17: #include <cctype>
18: #include <cmath>
19: #include <cstdlib>
20: 
21: namespace duckdb {
22: 
23: template <class SRC, class DST>
24: static bool TryCastWithOverflowCheck(SRC value, DST &result) {
25: 	if (std::numeric_limits<SRC>::is_signed != std::numeric_limits<DST>::is_signed) {
26: 		if (std::numeric_limits<SRC>::is_signed) {
27: 			// signed to unsigned conversion
28: 			if (std::numeric_limits<SRC>::digits > std::numeric_limits<DST>::digits) {
29: 				if (value < 0 || value > (SRC)NumericLimits<DST>::Maximum()) {
30: 					return false;
31: 				}
32: 			} else {
33: 				if (value < 0 || (DST)value > NumericLimits<DST>::Maximum()) {
34: 					return false;
35: 				}
36: 			}
37: 
38: 			result = (DST)value;
39: 			return true;
40: 		} else {
41: 			// unsigned to signed conversion
42: 			if (std::numeric_limits<SRC>::digits > std::numeric_limits<DST>::digits) {
43: 				if (value <= (SRC)NumericLimits<DST>::Maximum()) {
44: 					result = (DST)value;
45: 					return true;
46: 				}
47: 			} else {
48: 				if ((DST)value <= NumericLimits<DST>::Maximum()) {
49: 					result = (DST)value;
50: 					return true;
51: 				}
52: 			}
53: 
54: 			return false;
55: 		}
56: 	} else {
57: 		if (value < NumericLimits<DST>::Minimum() || value > NumericLimits<DST>::Maximum()) {
58: 			return false;
59: 		}
60: 		result = (DST)value;
61: 		return true;
62: 	}
63: }
64: 
65: template <class SRC, class DST>
66: static DST CastWithOverflowCheck(SRC value) {
67: 	DST result;
68: 	if (!TryCastWithOverflowCheck<SRC, DST>(value, result)) {
69: 		throw ValueOutOfRangeException((double)value, GetTypeId<SRC>(), GetTypeId<DST>());
70: 	}
71: 	return result;
72: }
73: 
74: //===--------------------------------------------------------------------===//
75: // Numeric -> int8_t casts
76: //===--------------------------------------------------------------------===//
77: template <>
78: bool TryCast::Operation(uint8_t input, int8_t &result, bool strict) {
79: 	return TryCastWithOverflowCheck(input, result);
80: }
81: template <>
82: bool TryCast::Operation(uint16_t input, int8_t &result, bool strict) {
83: 	return TryCastWithOverflowCheck(input, result);
84: }
85: template <>
86: bool TryCast::Operation(uint32_t input, int8_t &result, bool strict) {
87: 	return TryCastWithOverflowCheck(input, result);
88: }
89: template <>
90: bool TryCast::Operation(uint64_t input, int8_t &result, bool strict) {
91: 	return TryCastWithOverflowCheck(input, result);
92: }
93: template <>
94: bool TryCast::Operation(int16_t input, int8_t &result, bool strict) {
95: 	return TryCastWithOverflowCheck(input, result);
96: }
97: template <>
98: bool TryCast::Operation(int32_t input, int8_t &result, bool strict) {
99: 	return TryCastWithOverflowCheck(input, result);
100: }
101: template <>
102: bool TryCast::Operation(int64_t input, int8_t &result, bool strict) {
103: 	return TryCastWithOverflowCheck(input, result);
104: }
105: template <>
106: bool TryCast::Operation(float input, int8_t &result, bool strict) {
107: 	return TryCastWithOverflowCheck(input, result);
108: }
109: template <>
110: bool TryCast::Operation(double input, int8_t &result, bool strict) {
111: 	return TryCastWithOverflowCheck(input, result);
112: }
113: 
114: template <>
115: int8_t Cast::Operation(uint8_t input) {
116: 	return CastWithOverflowCheck<uint8_t, int8_t>(input);
117: }
118: template <>
119: int8_t Cast::Operation(uint16_t input) {
120: 	return CastWithOverflowCheck<uint16_t, int8_t>(input);
121: }
122: template <>
123: int8_t Cast::Operation(uint32_t input) {
124: 	return CastWithOverflowCheck<uint32_t, int8_t>(input);
125: }
126: template <>
127: int8_t Cast::Operation(uint64_t input) {
128: 	return CastWithOverflowCheck<uint64_t, int8_t>(input);
129: }
130: template <>
131: int8_t Cast::Operation(int16_t input) {
132: 	return CastWithOverflowCheck<int16_t, int8_t>(input);
133: }
134: template <>
135: int8_t Cast::Operation(int32_t input) {
136: 	return CastWithOverflowCheck<int32_t, int8_t>(input);
137: }
138: template <>
139: int8_t Cast::Operation(int64_t input) {
140: 	return CastWithOverflowCheck<int64_t, int8_t>(input);
141: }
142: template <>
143: int8_t Cast::Operation(float input) {
144: 	return CastWithOverflowCheck<float, int8_t>(input);
145: }
146: template <>
147: int8_t Cast::Operation(double input) {
148: 	return CastWithOverflowCheck<double, int8_t>(input);
149: }
150: 
151: //===--------------------------------------------------------------------===//
152: // Numeric -> uint8_t casts
153: //===--------------------------------------------------------------------===//
154: template <>
155: bool TryCast::Operation(uint16_t input, uint8_t &result, bool strict) {
156: 	return TryCastWithOverflowCheck(input, result);
157: }
158: template <>
159: bool TryCast::Operation(uint32_t input, uint8_t &result, bool strict) {
160: 	return TryCastWithOverflowCheck(input, result);
161: }
162: template <>
163: bool TryCast::Operation(uint64_t input, uint8_t &result, bool strict) {
164: 	return TryCastWithOverflowCheck(input, result);
165: }
166: template <>
167: bool TryCast::Operation(int8_t input, uint8_t &result, bool strict) {
168: 	return TryCastWithOverflowCheck(input, result);
169: }
170: template <>
171: bool TryCast::Operation(int16_t input, uint8_t &result, bool strict) {
172: 	return TryCastWithOverflowCheck(input, result);
173: }
174: template <>
175: bool TryCast::Operation(int32_t input, uint8_t &result, bool strict) {
176: 	return TryCastWithOverflowCheck(input, result);
177: }
178: template <>
179: bool TryCast::Operation(int64_t input, uint8_t &result, bool strict) {
180: 	return TryCastWithOverflowCheck(input, result);
181: }
182: template <>
183: bool TryCast::Operation(float input, uint8_t &result, bool strict) {
184: 	return TryCastWithOverflowCheck(input, result);
185: }
186: template <>
187: bool TryCast::Operation(double input, uint8_t &result, bool strict) {
188: 	return TryCastWithOverflowCheck(input, result);
189: }
190: template <>
191: uint8_t Cast::Operation(uint16_t input) {
192: 	return CastWithOverflowCheck<uint16_t, uint8_t>(input);
193: }
194: template <>
195: uint8_t Cast::Operation(uint32_t input) {
196: 	return CastWithOverflowCheck<uint32_t, uint8_t>(input);
197: }
198: template <>
199: uint8_t Cast::Operation(uint64_t input) {
200: 	return CastWithOverflowCheck<uint64_t, uint8_t>(input);
201: }
202: template <>
203: uint8_t Cast::Operation(int8_t input) {
204: 	return CastWithOverflowCheck<int8_t, uint8_t>(input);
205: }
206: template <>
207: uint8_t Cast::Operation(int16_t input) {
208: 	return CastWithOverflowCheck<int16_t, uint8_t>(input);
209: }
210: template <>
211: uint8_t Cast::Operation(int32_t input) {
212: 	return CastWithOverflowCheck<int32_t, uint8_t>(input);
213: }
214: template <>
215: uint8_t Cast::Operation(int64_t input) {
216: 	return CastWithOverflowCheck<int64_t, uint8_t>(input);
217: }
218: template <>
219: uint8_t Cast::Operation(float input) {
220: 	return CastWithOverflowCheck<float, uint8_t>(input);
221: }
222: template <>
223: uint8_t Cast::Operation(double input) {
224: 	return CastWithOverflowCheck<double, uint8_t>(input);
225: }
226: 
227: //===--------------------------------------------------------------------===//
228: // Numeric -> int16_t casts
229: //===--------------------------------------------------------------------===//
230: template <>
231: bool TryCast::Operation(uint16_t input, int16_t &result, bool strict) {
232: 	return TryCastWithOverflowCheck(input, result);
233: }
234: template <>
235: bool TryCast::Operation(uint32_t input, int16_t &result, bool strict) {
236: 	return TryCastWithOverflowCheck(input, result);
237: }
238: template <>
239: bool TryCast::Operation(uint64_t input, int16_t &result, bool strict) {
240: 	return TryCastWithOverflowCheck(input, result);
241: }
242: template <>
243: bool TryCast::Operation(int32_t input, int16_t &result, bool strict) {
244: 	return TryCastWithOverflowCheck(input, result);
245: }
246: template <>
247: bool TryCast::Operation(int64_t input, int16_t &result, bool strict) {
248: 	return TryCastWithOverflowCheck(input, result);
249: }
250: template <>
251: bool TryCast::Operation(float input, int16_t &result, bool strict) {
252: 	return TryCastWithOverflowCheck(input, result);
253: }
254: template <>
255: bool TryCast::Operation(double input, int16_t &result, bool strict) {
256: 	return TryCastWithOverflowCheck(input, result);
257: }
258: 
259: template <>
260: int16_t Cast::Operation(uint16_t input) {
261: 	return CastWithOverflowCheck<uint16_t, int16_t>(input);
262: }
263: template <>
264: int16_t Cast::Operation(uint32_t input) {
265: 	return CastWithOverflowCheck<uint32_t, int16_t>(input);
266: }
267: template <>
268: int16_t Cast::Operation(uint64_t input) {
269: 	return CastWithOverflowCheck<uint64_t, int16_t>(input);
270: }
271: 
272: template <>
273: int16_t Cast::Operation(int32_t input) {
274: 	return CastWithOverflowCheck<int32_t, int16_t>(input);
275: }
276: template <>
277: int16_t Cast::Operation(int64_t input) {
278: 	return CastWithOverflowCheck<int64_t, int16_t>(input);
279: }
280: template <>
281: int16_t Cast::Operation(float input) {
282: 	return CastWithOverflowCheck<float, int16_t>(input);
283: }
284: template <>
285: int16_t Cast::Operation(double input) {
286: 	return CastWithOverflowCheck<double, int16_t>(input);
287: }
288: 
289: //===--------------------------------------------------------------------===//
290: // Numeric -> uint16_t casts
291: //===--------------------------------------------------------------------===//
292: 
293: template <>
294: bool TryCast::Operation(uint32_t input, uint16_t &result, bool strict) {
295: 	return TryCastWithOverflowCheck(input, result);
296: }
297: template <>
298: bool TryCast::Operation(uint64_t input, uint16_t &result, bool strict) {
299: 	return TryCastWithOverflowCheck(input, result);
300: }
301: template <>
302: bool TryCast::Operation(int8_t input, uint16_t &result, bool strict) {
303: 	return TryCastWithOverflowCheck(input, result);
304: }
305: 
306: template <>
307: bool TryCast::Operation(int16_t input, uint16_t &result, bool strict) {
308: 	return TryCastWithOverflowCheck(input, result);
309: }
310: template <>
311: bool TryCast::Operation(int32_t input, uint16_t &result, bool strict) {
312: 	return TryCastWithOverflowCheck(input, result);
313: }
314: template <>
315: bool TryCast::Operation(int64_t input, uint16_t &result, bool strict) {
316: 	return TryCastWithOverflowCheck(input, result);
317: }
318: template <>
319: bool TryCast::Operation(float input, uint16_t &result, bool strict) {
320: 	return TryCastWithOverflowCheck(input, result);
321: }
322: template <>
323: bool TryCast::Operation(double input, uint16_t &result, bool strict) {
324: 	return TryCastWithOverflowCheck(input, result);
325: }
326: 
327: template <>
328: uint16_t Cast::Operation(uint32_t input) {
329: 	return CastWithOverflowCheck<uint32_t, uint16_t>(input);
330: }
331: template <>
332: uint16_t Cast::Operation(uint64_t input) {
333: 	return CastWithOverflowCheck<uint64_t, uint16_t>(input);
334: }
335: 
336: template <>
337: uint16_t Cast::Operation(int8_t input) {
338: 	return CastWithOverflowCheck<int8_t, uint16_t>(input);
339: }
340: 
341: template <>
342: uint16_t Cast::Operation(int16_t input) {
343: 	return CastWithOverflowCheck<int16_t, uint16_t>(input);
344: }
345: template <>
346: uint16_t Cast::Operation(int32_t input) {
347: 	return CastWithOverflowCheck<int32_t, uint16_t>(input);
348: }
349: template <>
350: uint16_t Cast::Operation(int64_t input) {
351: 	return CastWithOverflowCheck<int64_t, uint16_t>(input);
352: }
353: template <>
354: uint16_t Cast::Operation(float input) {
355: 	return CastWithOverflowCheck<float, uint16_t>(input);
356: }
357: template <>
358: uint16_t Cast::Operation(double input) {
359: 	return CastWithOverflowCheck<double, uint16_t>(input);
360: }
361: //===--------------------------------------------------------------------===//
362: // Numeric -> int32_t casts
363: //===--------------------------------------------------------------------===//
364: template <>
365: bool TryCast::Operation(uint32_t input, int32_t &result, bool strict) {
366: 	return TryCastWithOverflowCheck(input, result);
367: }
368: template <>
369: bool TryCast::Operation(uint64_t input, int32_t &result, bool strict) {
370: 	return TryCastWithOverflowCheck(input, result);
371: }
372: template <>
373: bool TryCast::Operation(int64_t input, int32_t &result, bool strict) {
374: 	return TryCastWithOverflowCheck(input, result);
375: }
376: template <>
377: bool TryCast::Operation(float input, int32_t &result, bool strict) {
378: 	return TryCastWithOverflowCheck(input, result);
379: }
380: template <>
381: bool TryCast::Operation(double input, int32_t &result, bool strict) {
382: 	return TryCastWithOverflowCheck(input, result);
383: }
384: 
385: template <>
386: int32_t Cast::Operation(uint32_t input) {
387: 	return CastWithOverflowCheck<uint32_t, int32_t>(input);
388: }
389: template <>
390: int32_t Cast::Operation(uint64_t input) {
391: 	return CastWithOverflowCheck<uint64_t, int32_t>(input);
392: }
393: 
394: template <>
395: int32_t Cast::Operation(int64_t input) {
396: 	return CastWithOverflowCheck<int64_t, int32_t>(input);
397: }
398: template <>
399: int32_t Cast::Operation(float input) {
400: 	return CastWithOverflowCheck<float, int32_t>(input);
401: }
402: template <>
403: int32_t Cast::Operation(double input) {
404: 	return CastWithOverflowCheck<double, int32_t>(input);
405: }
406: 
407: //===--------------------------------------------------------------------===//
408: // Numeric -> uint32_t casts
409: //===--------------------------------------------------------------------===//
410: 
411: template <>
412: bool TryCast::Operation(uint64_t input, uint32_t &result, bool strict) {
413: 	return TryCastWithOverflowCheck(input, result);
414: }
415: template <>
416: bool TryCast::Operation(int8_t input, uint32_t &result, bool strict) {
417: 	return TryCastWithOverflowCheck(input, result);
418: }
419: template <>
420: bool TryCast::Operation(int16_t input, uint32_t &result, bool strict) {
421: 	return TryCastWithOverflowCheck(input, result);
422: }
423: template <>
424: bool TryCast::Operation(int32_t input, uint32_t &result, bool strict) {
425: 	return TryCastWithOverflowCheck(input, result);
426: }
427: template <>
428: bool TryCast::Operation(int64_t input, uint32_t &result, bool strict) {
429: 	return TryCastWithOverflowCheck(input, result);
430: }
431: template <>
432: bool TryCast::Operation(float input, uint32_t &result, bool strict) {
433: 	return TryCastWithOverflowCheck(input, result);
434: }
435: template <>
436: bool TryCast::Operation(double input, uint32_t &result, bool strict) {
437: 	return TryCastWithOverflowCheck(input, result);
438: }
439: 
440: template <>
441: uint32_t Cast::Operation(uint64_t input) {
442: 	return CastWithOverflowCheck<uint64_t, uint32_t>(input);
443: }
444: template <>
445: uint32_t Cast::Operation(int8_t input) {
446: 	return CastWithOverflowCheck<int8_t, uint32_t>(input);
447: }
448: template <>
449: uint32_t Cast::Operation(int16_t input) {
450: 	return CastWithOverflowCheck<int16_t, uint32_t>(input);
451: }
452: 
453: template <>
454: uint32_t Cast::Operation(int32_t input) {
455: 	return CastWithOverflowCheck<int32_t, uint32_t>(input);
456: }
457: template <>
458: uint32_t Cast::Operation(int64_t input) {
459: 	return CastWithOverflowCheck<int64_t, uint32_t>(input);
460: }
461: template <>
462: uint32_t Cast::Operation(float input) {
463: 	return CastWithOverflowCheck<float, uint32_t>(input);
464: }
465: template <>
466: uint32_t Cast::Operation(double input) {
467: 	return CastWithOverflowCheck<double, uint32_t>(input);
468: }
469: //===--------------------------------------------------------------------===//
470: // Numeric -> int64_t casts
471: //===--------------------------------------------------------------------===//
472: template <>
473: bool TryCast::Operation(uint64_t input, int64_t &result, bool strict) {
474: 	return TryCastWithOverflowCheck(input, result);
475: }
476: template <>
477: bool TryCast::Operation(float input, int64_t &result, bool strict) {
478: 	return TryCastWithOverflowCheck(input, result);
479: }
480: template <>
481: bool TryCast::Operation(double input, int64_t &result, bool strict) {
482: 	return TryCastWithOverflowCheck(input, result);
483: }
484: 
485: template <>
486: int64_t Cast::Operation(uint64_t input) {
487: 	return CastWithOverflowCheck<uint64_t, int64_t>(input);
488: }
489: template <>
490: int64_t Cast::Operation(float input) {
491: 	return CastWithOverflowCheck<float, int64_t>(input);
492: }
493: template <>
494: int64_t Cast::Operation(double input) {
495: 	return CastWithOverflowCheck<double, int64_t>(input);
496: }
497: 
498: //===--------------------------------------------------------------------===//
499: // Numeric -> uint64_t casts
500: //===--------------------------------------------------------------------===//
501: template <>
502: bool TryCast::Operation(int8_t input, uint64_t &result, bool strict) {
503: 	return TryCastWithOverflowCheck(input, result);
504: }
505: template <>
506: bool TryCast::Operation(int16_t input, uint64_t &result, bool strict) {
507: 	return TryCastWithOverflowCheck(input, result);
508: }
509: template <>
510: bool TryCast::Operation(int32_t input, uint64_t &result, bool strict) {
511: 	return TryCastWithOverflowCheck(input, result);
512: }
513: 
514: template <>
515: bool TryCast::Operation(int64_t input, uint64_t &result, bool strict) {
516: 	return TryCastWithOverflowCheck(input, result);
517: }
518: template <>
519: bool TryCast::Operation(float input, uint64_t &result, bool strict) {
520: 	return TryCastWithOverflowCheck(input, result);
521: }
522: template <>
523: bool TryCast::Operation(double input, uint64_t &result, bool strict) {
524: 	return TryCastWithOverflowCheck(input, result);
525: }
526: template <>
527: uint64_t Cast::Operation(int8_t input) {
528: 	return CastWithOverflowCheck<int8_t, uint64_t>(input);
529: }
530: template <>
531: uint64_t Cast::Operation(int16_t input) {
532: 	return CastWithOverflowCheck<int16_t, uint64_t>(input);
533: }
534: template <>
535: uint64_t Cast::Operation(int32_t input) {
536: 	return CastWithOverflowCheck<int32_t, uint64_t>(input);
537: }
538: 
539: template <>
540: uint64_t Cast::Operation(int64_t input) {
541: 	return CastWithOverflowCheck<int64_t, uint64_t>(input);
542: }
543: template <>
544: uint64_t Cast::Operation(float input) {
545: 	return CastWithOverflowCheck<float, uint64_t>(input);
546: }
547: template <>
548: uint64_t Cast::Operation(double input) {
549: 	return CastWithOverflowCheck<double, uint64_t>(input);
550: }
551: 
552: //===--------------------------------------------------------------------===//
553: // Double -> float casts
554: //===--------------------------------------------------------------------===//
555: template <>
556: bool TryCast::Operation(double input, float &result, bool strict) {
557: 	if (input < (double)NumericLimits<float>::Minimum() || input > (double)NumericLimits<float>::Maximum()) {
558: 		return false;
559: 	}
560: 	auto res = (float)input;
561: 	if (std::isnan(res) || std::isinf(res)) {
562: 		return false;
563: 	}
564: 	result = res;
565: 	return true;
566: }
567: 
568: template <>
569: float Cast::Operation(double input) {
570: 	float result;
571: 	bool strict = false;
572: 	if (!TryCast::Operation(input, result, strict)) {
573: 		throw ValueOutOfRangeException(input, GetTypeId<double>(), GetTypeId<float>());
574: 	}
575: 	return result;
576: }
577: 
578: //===--------------------------------------------------------------------===//
579: // Cast String -> Numeric
580: //===--------------------------------------------------------------------===//
581: template <class T>
582: static T TryCastString(string_t input) {
583: 	T result;
584: 	if (!TryCast::Operation<string_t, T>(input, result)) {
585: 		throw ConversionException("Could not convert string '%s' to %s", input.GetString(),
586: 		                          TypeIdToString(GetTypeId<T>()));
587: 	}
588: 	return result;
589: }
590: 
591: template <class T>
592: static T TryStrictCastString(string_t input) {
593: 	T result;
594: 	if (!TryCast::Operation<string_t, T>(input, result, true)) {
595: 		throw ConversionException("Could not convert string '%s' to %s", input.GetString(),
596: 		                          TypeIdToString(GetTypeId<T>()));
597: 	}
598: 	return result;
599: }
600: 
601: struct IntegerCastOperation {
602: 	template <class T, bool NEGATIVE>
603: 	static bool HandleDigit(T &result, uint8_t digit) {
604: 		if (NEGATIVE) {
605: 			if (result < (NumericLimits<T>::Minimum() + digit) / 10) {
606: 				return false;
607: 			}
608: 			result = result * 10 - digit;
609: 		} else {
610: 			if (result > (NumericLimits<T>::Maximum() - digit) / 10) {
611: 				return false;
612: 			}
613: 			result = result * 10 + digit;
614: 		}
615: 		return true;
616: 	}
617: 
618: 	template <class T>
619: 	static bool HandleExponent(T &result, int64_t exponent) {
620: 		double dbl_res = result * std::pow(10.0L, exponent);
621: 		if (dbl_res < NumericLimits<T>::Minimum() || dbl_res > NumericLimits<T>::Maximum()) {
622: 			return false;
623: 		}
624: 		result = (T)dbl_res;
625: 		return true;
626: 	}
627: 
628: 	template <class T, bool NEGATIVE>
629: 	static bool HandleDecimal(T &result, uint8_t digit) {
630: 		return true;
631: 	}
632: 
633: 	template <class T>
634: 	static bool Finalize(T &result) {
635: 		return true;
636: 	}
637: };
638: 
639: template <class T, bool NEGATIVE, bool ALLOW_EXPONENT, class OP = IntegerCastOperation>
640: static bool IntegerCastLoop(const char *buf, idx_t len, T &result, bool strict) {
641: 	idx_t start_pos = NEGATIVE || *buf == '+' ? 1 : 0;
642: 	idx_t pos = start_pos;
643: 	while (pos < len) {
644: 		if (!StringUtil::CharacterIsDigit(buf[pos])) {
645: 			// not a digit!
646: 			if (buf[pos] == '.') {
647: 				if (strict) {
648: 					return false;
649: 				}
650: 				bool number_before_period = pos > start_pos;
651: 				// decimal point: we accept decimal values for integers as well
652: 				// we just truncate them
653: 				// make sure everything after the period is a number
654: 				pos++;
655: 				idx_t start_digit = pos;
656: 				while (pos < len) {
657: 					if (!StringUtil::CharacterIsDigit(buf[pos])) {
658: 						return false;
659: 					}
660: 					if (!OP::template HandleDecimal<T, NEGATIVE>(result, buf[pos] - '0')) {
661: 						return false;
662: 					}
663: 					pos++;
664: 				}
665: 				if (!OP::template Finalize<T>(result)) {
666: 					return false;
667: 				}
668: 				// make sure there is either (1) one number after the period, or (2) one number before the period
669: 				// i.e. we accept "1." and ".1" as valid numbers, but not "."
670: 				return number_before_period || pos > start_digit;
671: 			}
672: 			if (StringUtil::CharacterIsSpace(buf[pos])) {
673: 				// skip any trailing spaces
674: 				while (++pos < len) {
675: 					if (!StringUtil::CharacterIsSpace(buf[pos])) {
676: 						return false;
677: 					}
678: 				}
679: 				break;
680: 			}
681: 			if (ALLOW_EXPONENT) {
682: 				if (buf[pos] == 'e' || buf[pos] == 'E') {
683: 					pos++;
684: 					int64_t exponent = 0;
685: 					int negative = buf[pos] == '-';
686: 					if (negative) {
687: 						if (!IntegerCastLoop<int64_t, true, false>(buf + pos, len - pos, exponent, strict)) {
688: 							return false;
689: 						}
690: 					} else {
691: 						if (!IntegerCastLoop<int64_t, false, false>(buf + pos, len - pos, exponent, strict)) {
692: 							return false;
693: 						}
694: 					}
695: 					return OP::template HandleExponent<T>(result, exponent);
696: 				}
697: 			}
698: 			return false;
699: 		}
700: 		uint8_t digit = buf[pos++] - '0';
701: 		if (!OP::template HandleDigit<T, NEGATIVE>(result, digit)) {
702: 			return false;
703: 		}
704: 	}
705: 	if (!OP::template Finalize<T>(result)) {
706: 		return false;
707: 	}
708: 	return pos > start_pos;
709: }
710: 
711: template <class T, bool ALLOW_EXPONENT = true, class OP = IntegerCastOperation, bool ZERO_INITIALIZE = true>
712: static bool TryIntegerCast(const char *buf, idx_t len, T &result, bool strict, bool unsigned_int = false) {
713: 	// skip any spaces at the start
714: 	while (len > 0 && StringUtil::CharacterIsSpace(*buf)) {
715: 		buf++;
716: 		len--;
717: 	}
718: 	if (len == 0) {
719: 		return false;
720: 	}
721: 	int negative = *buf == '-';
722: 
723: 	if (ZERO_INITIALIZE) {
724: 		memset(&result, 0, sizeof(T));
725: 	}
726: 	if (!negative) {
727: 		return IntegerCastLoop<T, false, ALLOW_EXPONENT, OP>(buf, len, result, strict);
728: 	} else {
729: 		if (unsigned_int) {
730: 			// Need to check if its not -0
731: 			idx_t pos = 1;
732: 			while (pos < len) {
733: 				if (buf[pos++] != '0') {
734: 					return false;
735: 				}
736: 			}
737: 		}
738: 		return IntegerCastLoop<T, true, ALLOW_EXPONENT, OP>(buf, len, result, strict);
739: 	}
740: }
741: 
742: template <>
743: bool TryCast::Operation(string_t input, bool &result, bool strict) {
744: 	auto input_data = input.GetDataUnsafe();
745: 	auto input_size = input.GetSize();
746: 
747: 	switch (input_size) {
748: 	case 1: {
749: 		char c = std::tolower(*input_data);
750: 		if (c == 't' || (!strict && c == '1')) {
751: 			result = true;
752: 			return true;
753: 		} else if (c == 'f' || (!strict && c == '0')) {
754: 			result = false;
755: 			return true;
756: 		}
757: 		return false;
758: 	}
759: 	case 4: {
760: 		char t = std::tolower(input_data[0]);
761: 		char r = std::tolower(input_data[1]);
762: 		char u = std::tolower(input_data[2]);
763: 		char e = std::tolower(input_data[3]);
764: 		if (t == 't' && r == 'r' && u == 'u' && e == 'e') {
765: 			result = true;
766: 			return true;
767: 		}
768: 		return false;
769: 	}
770: 	case 5: {
771: 		char f = std::tolower(input_data[0]);
772: 		char a = std::tolower(input_data[1]);
773: 		char l = std::tolower(input_data[2]);
774: 		char s = std::tolower(input_data[3]);
775: 		char e = std::tolower(input_data[4]);
776: 		if (f == 'f' && a == 'a' && l == 'l' && s == 's' && e == 'e') {
777: 			result = false;
778: 			return true;
779: 		}
780: 		return false;
781: 	}
782: 	default:
783: 		return false;
784: 	}
785: }
786: template <>
787: bool TryCast::Operation(string_t input, int8_t &result, bool strict) {
788: 	return TryIntegerCast<int8_t>(input.GetDataUnsafe(), input.GetSize(), result, strict);
789: }
790: template <>
791: bool TryCast::Operation(string_t input, int16_t &result, bool strict) {
792: 	return TryIntegerCast<int16_t>(input.GetDataUnsafe(), input.GetSize(), result, strict);
793: }
794: template <>
795: bool TryCast::Operation(string_t input, int32_t &result, bool strict) {
796: 	return TryIntegerCast<int32_t>(input.GetDataUnsafe(), input.GetSize(), result, strict);
797: }
798: template <>
799: bool TryCast::Operation(string_t input, int64_t &result, bool strict) {
800: 	return TryIntegerCast<int64_t>(input.GetDataUnsafe(), input.GetSize(), result, strict);
801: }
802: 
803: template <>
804: bool TryCast::Operation(string_t input, uint8_t &result, bool strict) {
805: 	return TryIntegerCast<uint8_t>(input.GetDataUnsafe(), input.GetSize(), result, strict, true);
806: }
807: template <>
808: bool TryCast::Operation(string_t input, uint16_t &result, bool strict) {
809: 	return TryIntegerCast<uint16_t>(input.GetDataUnsafe(), input.GetSize(), result, strict, true);
810: }
811: template <>
812: bool TryCast::Operation(string_t input, uint32_t &result, bool strict) {
813: 	return TryIntegerCast<uint32_t>(input.GetDataUnsafe(), input.GetSize(), result, strict, true);
814: }
815: template <>
816: bool TryCast::Operation(string_t input, uint64_t &result, bool strict) {
817: 	return TryIntegerCast<uint64_t>(input.GetDataUnsafe(), input.GetSize(), result, strict, true);
818: }
819: 
820: template <class T, bool NEGATIVE>
821: static void ComputeDoubleResult(T &result, idx_t decimal, idx_t decimal_factor) {
822: 	if (decimal_factor > 1) {
823: 		if (NEGATIVE) {
824: 			result -= (T)decimal / (T)decimal_factor;
825: 		} else {
826: 			result += (T)decimal / (T)decimal_factor;
827: 		}
828: 	}
829: }
830: 
831: template <class T, bool NEGATIVE>
832: static bool DoubleCastLoop(const char *buf, idx_t len, T &result, bool strict) {
833: 	idx_t start_pos = NEGATIVE || *buf == '+' ? 1 : 0;
834: 	idx_t pos = start_pos;
835: 	idx_t decimal = 0;
836: 	idx_t decimal_factor = 0;
837: 	while (pos < len) {
838: 		if (!StringUtil::CharacterIsDigit(buf[pos])) {
839: 			// not a digit!
840: 			if (buf[pos] == '.') {
841: 				// decimal point
842: 				if (decimal_factor != 0) {
843: 					// nested periods
844: 					return false;
845: 				}
846: 				decimal_factor = 1;
847: 				pos++;
848: 				continue;
849: 			} else if (StringUtil::CharacterIsSpace(buf[pos])) {
850: 				// skip any trailing spaces
851: 				while (++pos < len) {
852: 					if (!StringUtil::CharacterIsSpace(buf[pos])) {
853: 						return false;
854: 					}
855: 				}
856: 				ComputeDoubleResult<T, NEGATIVE>(result, decimal, decimal_factor);
857: 				return true;
858: 			} else if (buf[pos] == 'e' || buf[pos] == 'E') {
859: 				// E power
860: 				// parse an integer, this time not allowing another exponent
861: 				pos++;
862: 				int64_t exponent;
863: 				if (!TryIntegerCast<int64_t, false>(buf + pos, len - pos, exponent, strict)) {
864: 					return false;
865: 				}
866: 				ComputeDoubleResult<T, NEGATIVE>(result, decimal, decimal_factor);
867: 				if (result > NumericLimits<T>::Maximum() / std::pow(10.0L, exponent)) {
868: 					return false;
869: 				}
870: 				result = result * std::pow(10.0L, exponent);
871: 
872: 				return true;
873: 			} else {
874: 				return false;
875: 			}
876: 		}
877: 		T digit = buf[pos++] - '0';
878: 		if (decimal_factor == 0) {
879: 			result = result * 10 + (NEGATIVE ? -digit : digit);
880: 		} else {
881: 			if (decimal_factor >= 1000000000000000000) {
882: 				// decimal value will overflow if we parse more, ignore any subsequent numbers
883: 				continue;
884: 			}
885: 			decimal = decimal * 10 + digit;
886: 			decimal_factor *= 10;
887: 		}
888: 	}
889: 	ComputeDoubleResult<T, NEGATIVE>(result, decimal, decimal_factor);
890: 	return pos > start_pos;
891: }
892: 
893: template <class T>
894: bool CheckDoubleValidity(T value);
895: 
896: template <>
897: bool CheckDoubleValidity(float value) {
898: 	return Value::FloatIsValid(value);
899: }
900: 
901: template <>
902: bool CheckDoubleValidity(double value) {
903: 	return Value::DoubleIsValid(value);
904: }
905: 
906: template <class T>
907: static bool TryDoubleCast(const char *buf, idx_t len, T &result, bool strict) {
908: 	// skip any spaces at the start
909: 	while (len > 0 && StringUtil::CharacterIsSpace(*buf)) {
910: 		buf++;
911: 		len--;
912: 	}
913: 	if (len == 0) {
914: 		return false;
915: 	}
916: 	int negative = *buf == '-';
917: 
918: 	result = 0;
919: 	if (!negative) {
920: 		if (!DoubleCastLoop<T, false>(buf, len, result, strict)) {
921: 			return false;
922: 		}
923: 	} else {
924: 		if (!DoubleCastLoop<T, true>(buf, len, result, strict)) {
925: 			return false;
926: 		}
927: 	}
928: 	if (!CheckDoubleValidity<T>(result)) {
929: 		return false;
930: 	}
931: 	return true;
932: }
933: 
934: template <>
935: bool TryCast::Operation(string_t input, float &result, bool strict) {
936: 	return TryDoubleCast<float>(input.GetDataUnsafe(), input.GetSize(), result, strict);
937: }
938: template <>
939: bool TryCast::Operation(string_t input, double &result, bool strict) {
940: 	return TryDoubleCast<double>(input.GetDataUnsafe(), input.GetSize(), result, strict);
941: }
942: 
943: template <>
944: bool Cast::Operation(string_t input) {
945: 	return TryCastString<bool>(input);
946: }
947: template <>
948: int8_t Cast::Operation(string_t input) {
949: 	return TryCastString<int8_t>(input);
950: }
951: template <>
952: int16_t Cast::Operation(string_t input) {
953: 	return TryCastString<int16_t>(input);
954: }
955: template <>
956: int32_t Cast::Operation(string_t input) {
957: 	return TryCastString<int32_t>(input);
958: }
959: template <>
960: int64_t Cast::Operation(string_t input) {
961: 	return TryCastString<int64_t>(input);
962: }
963: template <>
964: uint8_t Cast::Operation(string_t input) {
965: 	return TryCastString<uint8_t>(input);
966: }
967: template <>
968: uint16_t Cast::Operation(string_t input) {
969: 	return TryCastString<uint16_t>(input);
970: }
971: template <>
972: uint32_t Cast::Operation(string_t input) {
973: 	return TryCastString<uint32_t>(input);
974: }
975: template <>
976: uint64_t Cast::Operation(string_t input) {
977: 	return TryCastString<uint64_t>(input);
978: }
979: 
980: template <>
981: float Cast::Operation(string_t input) {
982: 	return TryCastString<float>(input);
983: }
984: template <>
985: double Cast::Operation(string_t input) {
986: 	return TryCastString<double>(input);
987: }
988: 
989: template <>
990: bool StrictCast::Operation(string_t input) {
991: 	return TryStrictCastString<bool>(input);
992: }
993: template <>
994: int8_t StrictCast::Operation(string_t input) {
995: 	return TryStrictCastString<int8_t>(input);
996: }
997: template <>
998: int16_t StrictCast::Operation(string_t input) {
999: 	return TryStrictCastString<int16_t>(input);
1000: }
1001: template <>
1002: int32_t StrictCast::Operation(string_t input) {
1003: 	return TryStrictCastString<int32_t>(input);
1004: }
1005: template <>
1006: int64_t StrictCast::Operation(string_t input) {
1007: 	return TryStrictCastString<int64_t>(input);
1008: }
1009: template <>
1010: uint8_t StrictCast::Operation(string_t input) {
1011: 	return TryStrictCastString<uint8_t>(input);
1012: }
1013: template <>
1014: uint16_t StrictCast::Operation(string_t input) {
1015: 	return TryStrictCastString<uint16_t>(input);
1016: }
1017: template <>
1018: uint32_t StrictCast::Operation(string_t input) {
1019: 	return TryStrictCastString<uint32_t>(input);
1020: }
1021: template <>
1022: uint64_t StrictCast::Operation(string_t input) {
1023: 	return TryStrictCastString<uint64_t>(input);
1024: }
1025: template <>
1026: float StrictCast::Operation(string_t input) {
1027: 	return TryStrictCastString<float>(input);
1028: }
1029: template <>
1030: double StrictCast::Operation(string_t input) {
1031: 	return TryStrictCastString<double>(input);
1032: }
1033: 
1034: //===--------------------------------------------------------------------===//
1035: // Cast Numeric -> String
1036: //===--------------------------------------------------------------------===//
1037: template <class T>
1038: string CastToStandardString(T input) {
1039: 	Vector v(LogicalType::VARCHAR);
1040: 	return StringCast::Operation(input, v).GetString();
1041: }
1042: 
1043: template <>
1044: string Cast::Operation(bool input) {
1045: 	return CastToStandardString(input);
1046: }
1047: template <>
1048: string Cast::Operation(int8_t input) {
1049: 	return CastToStandardString(input);
1050: }
1051: template <>
1052: string Cast::Operation(int16_t input) {
1053: 	return CastToStandardString(input);
1054: }
1055: template <>
1056: string Cast::Operation(int32_t input) {
1057: 	return CastToStandardString(input);
1058: }
1059: template <>
1060: string Cast::Operation(int64_t input) {
1061: 	return CastToStandardString(input);
1062: }
1063: template <>
1064: string Cast::Operation(uint8_t input) {
1065: 	return CastToStandardString(input);
1066: }
1067: template <>
1068: string Cast::Operation(uint16_t input) {
1069: 	return CastToStandardString(input);
1070: }
1071: template <>
1072: string Cast::Operation(uint32_t input) {
1073: 	return CastToStandardString(input);
1074: }
1075: template <>
1076: string Cast::Operation(uint64_t input) {
1077: 	return CastToStandardString(input);
1078: }
1079: template <>
1080: string Cast::Operation(hugeint_t input) {
1081: 	return Hugeint::ToString(input);
1082: }
1083: template <>
1084: string Cast::Operation(float input) {
1085: 	return CastToStandardString(input);
1086: }
1087: template <>
1088: string Cast::Operation(double input) {
1089: 	return CastToStandardString(input);
1090: }
1091: template <>
1092: string Cast::Operation(string_t input) {
1093: 	return input.GetString();
1094: }
1095: 
1096: template <>
1097: string_t StringCast::Operation(bool input, Vector &vector) {
1098: 	if (input) {
1099: 		return StringVector::AddString(vector, "true", 4);
1100: 	} else {
1101: 		return StringVector::AddString(vector, "false", 5);
1102: 	}
1103: }
1104: 
1105: template <>
1106: string_t StringCast::Operation(int8_t input, Vector &vector) {
1107: 	return NumericHelper::FormatSigned<int8_t, uint8_t>(input, vector);
1108: }
1109: 
1110: template <>
1111: string_t StringCast::Operation(int16_t input, Vector &vector) {
1112: 	return NumericHelper::FormatSigned<int16_t, uint16_t>(input, vector);
1113: }
1114: template <>
1115: string_t StringCast::Operation(int32_t input, Vector &vector) {
1116: 	return NumericHelper::FormatSigned<int32_t, uint32_t>(input, vector);
1117: }
1118: 
1119: template <>
1120: string_t StringCast::Operation(int64_t input, Vector &vector) {
1121: 	return NumericHelper::FormatSigned<int64_t, uint64_t>(input, vector);
1122: }
1123: template <>
1124: duckdb::string_t StringCast::Operation(uint8_t input, Vector &vector) {
1125: 	return NumericHelper::FormatSigned<uint8_t, uint64_t>(input, vector);
1126: }
1127: template <>
1128: duckdb::string_t StringCast::Operation(uint16_t input, Vector &vector) {
1129: 	return NumericHelper::FormatSigned<uint16_t, uint64_t>(input, vector);
1130: }
1131: template <>
1132: duckdb::string_t StringCast::Operation(uint32_t input, Vector &vector) {
1133: 	return NumericHelper::FormatSigned<uint32_t, uint64_t>(input, vector);
1134: }
1135: template <>
1136: duckdb::string_t StringCast::Operation(uint64_t input, Vector &vector) {
1137: 	return NumericHelper::FormatSigned<uint64_t, uint64_t>(input, vector);
1138: }
1139: 
1140: template <>
1141: string_t StringCast::Operation(float input, Vector &vector) {
1142: 	std::string s = duckdb_fmt::format("{}", input);
1143: 	return StringVector::AddString(vector, s);
1144: }
1145: 
1146: template <>
1147: string_t StringCast::Operation(double input, Vector &vector) {
1148: 	std::string s = duckdb_fmt::format("{}", input);
1149: 	return StringVector::AddString(vector, s);
1150: }
1151: 
1152: template <>
1153: string_t StringCast::Operation(interval_t input, Vector &vector) {
1154: 	char buffer[70];
1155: 	idx_t length = IntervalToStringCast::Format(input, buffer);
1156: 	return StringVector::AddString(vector, buffer, length);
1157: }
1158: 
1159: template <>
1160: duckdb::string_t StringCast::Operation(hugeint_t input, Vector &vector) {
1161: 	return HugeintToStringCast::FormatSigned(input, vector);
1162: }
1163: 
1164: //===--------------------------------------------------------------------===//
1165: // Cast From Date
1166: //===--------------------------------------------------------------------===//
1167: template <>
1168: string_t CastFromDate::Operation(date_t input, Vector &vector) {
1169: 	int32_t date[3];
1170: 	Date::Convert(input, date[0], date[1], date[2]);
1171: 
1172: 	idx_t year_length;
1173: 	bool add_bc;
1174: 	idx_t length = DateToStringCast::Length(date, year_length, add_bc);
1175: 
1176: 	string_t result = StringVector::EmptyString(vector, length);
1177: 	auto data = result.GetDataWriteable();
1178: 
1179: 	DateToStringCast::Format(data, date, year_length, add_bc);
1180: 
1181: 	result.Finalize();
1182: 	return result;
1183: }
1184: 
1185: //===--------------------------------------------------------------------===//
1186: // Cast To Date
1187: //===--------------------------------------------------------------------===//
1188: template <>
1189: date_t CastToDate::Operation(string_t input) {
1190: 	return Date::FromCString(input.GetDataUnsafe(), input.GetSize());
1191: }
1192: 
1193: template <>
1194: date_t StrictCastToDate::Operation(string_t input) {
1195: 	return Date::FromCString(input.GetDataUnsafe(), input.GetSize(), true);
1196: }
1197: 
1198: //===--------------------------------------------------------------------===//
1199: // Cast From Time
1200: //===--------------------------------------------------------------------===//
1201: template <>
1202: string_t CastFromTime::Operation(dtime_t input, Vector &vector) {
1203: 	int32_t time[4];
1204: 	Time::Convert(input, time[0], time[1], time[2], time[3]);
1205: 
1206: 	char micro_buffer[10];
1207: 	idx_t length = TimeToStringCast::Length(time, micro_buffer);
1208: 
1209: 	string_t result = StringVector::EmptyString(vector, length);
1210: 	auto data = result.GetDataWriteable();
1211: 
1212: 	TimeToStringCast::Format(data, length, time, micro_buffer);
1213: 
1214: 	result.Finalize();
1215: 	return result;
1216: }
1217: 
1218: //===--------------------------------------------------------------------===//
1219: // Cast To Time
1220: //===--------------------------------------------------------------------===//
1221: template <>
1222: dtime_t CastToTime::Operation(string_t input) {
1223: 	return Time::FromCString(input.GetDataUnsafe(), input.GetSize());
1224: }
1225: 
1226: template <>
1227: dtime_t StrictCastToTime::Operation(string_t input) {
1228: 	return Time::FromCString(input.GetDataUnsafe(), input.GetSize(), true);
1229: }
1230: 
1231: template <>
1232: timestamp_t CastDateToTimestamp::Operation(date_t input) {
1233: 	return Timestamp::FromDatetime(input, Time::FromTime(0, 0, 0, 0));
1234: }
1235: 
1236: //===--------------------------------------------------------------------===//
1237: // Cast From Timestamps
1238: //===--------------------------------------------------------------------===//
1239: template <>
1240: string_t CastFromTimestamp::Operation(timestamp_t input, Vector &vector) {
1241: 	date_t date_entry;
1242: 	dtime_t time_entry;
1243: 	Timestamp::Convert(input, date_entry, time_entry);
1244: 
1245: 	int32_t date[3], time[4];
1246: 	Date::Convert(date_entry, date[0], date[1], date[2]);
1247: 	Time::Convert(time_entry, time[0], time[1], time[2], time[3]);
1248: 
1249: 	// format for timestamp is DATE TIME (separated by space)
1250: 	idx_t year_length;
1251: 	bool add_bc;
1252: 	char micro_buffer[6];
1253: 	idx_t date_length = DateToStringCast::Length(date, year_length, add_bc);
1254: 	idx_t time_length = TimeToStringCast::Length(time, micro_buffer);
1255: 	idx_t length = date_length + time_length + 1;
1256: 
1257: 	string_t result = StringVector::EmptyString(vector, length);
1258: 	auto data = result.GetDataWriteable();
1259: 
1260: 	DateToStringCast::Format(data, date, year_length, add_bc);
1261: 	data[date_length] = ' ';
1262: 	TimeToStringCast::Format(data + date_length + 1, time_length, time, micro_buffer);
1263: 
1264: 	result.Finalize();
1265: 	return result;
1266: }
1267: 
1268: template <>
1269: date_t CastTimestampToDate::Operation(timestamp_t input) {
1270: 	return Timestamp::GetDate(input);
1271: }
1272: 
1273: template <>
1274: dtime_t CastTimestampToTime::Operation(timestamp_t input) {
1275: 	return Timestamp::GetTime(input);
1276: }
1277: 
1278: //===--------------------------------------------------------------------===//
1279: // Cast To Timestamp
1280: //===--------------------------------------------------------------------===//
1281: template <>
1282: timestamp_t CastToTimestamp::Operation(string_t input) {
1283: 	return Timestamp::FromCString(input.GetDataUnsafe(), input.GetSize());
1284: }
1285: 
1286: //===--------------------------------------------------------------------===//
1287: // Cast From Blob
1288: //===--------------------------------------------------------------------===//
1289: template <>
1290: string_t CastFromBlob::Operation(string_t input, Vector &vector) {
1291: 	idx_t result_size = Blob::GetStringSize(input);
1292: 
1293: 	string_t result = StringVector::EmptyString(vector, result_size);
1294: 	Blob::ToString(input, result.GetDataWriteable());
1295: 	result.Finalize();
1296: 	return result;
1297: }
1298: 
1299: //===--------------------------------------------------------------------===//
1300: // Cast To Blob
1301: //===--------------------------------------------------------------------===//
1302: template <>
1303: string_t CastToBlob::Operation(string_t input, Vector &vector) {
1304: 	idx_t result_size = Blob::GetBlobSize(input);
1305: 
1306: 	string_t result = StringVector::EmptyString(vector, result_size);
1307: 	Blob::ToBlob(input, (data_ptr_t)result.GetDataWriteable());
1308: 	result.Finalize();
1309: 	return result;
1310: }
1311: 
1312: //===--------------------------------------------------------------------===//
1313: // Cast From Interval
1314: //===--------------------------------------------------------------------===//
1315: template <>
1316: bool TryCast::Operation(string_t input, interval_t &result, bool strict) {
1317: 	return Interval::FromCString(input.GetDataUnsafe(), input.GetSize(), result);
1318: }
1319: 
1320: template <>
1321: interval_t StrictCast::Operation(string_t input) {
1322: 	return TryStrictCastString<interval_t>(input);
1323: }
1324: 
1325: template <>
1326: interval_t Cast::Operation(string_t input) {
1327: 	return TryCastString<interval_t>(input);
1328: }
1329: 
1330: //===--------------------------------------------------------------------===//
1331: // Cast From Hugeint
1332: //===--------------------------------------------------------------------===//
1333: // parsing hugeint from string is done a bit differently for performance reasons
1334: // for other integer types we keep track of a single value
1335: // and multiply that value by 10 for every digit we read
1336: // however, for hugeints, multiplication is very expensive (>20X as expensive as for int64)
1337: // for that reason, we parse numbers first into an int64 value
1338: // when that value is full, we perform a HUGEINT multiplication to flush it into the hugeint
1339: // this takes the number of HUGEINT multiplications down from [0-38] to [0-2]
1340: struct HugeIntCastData {
1341: 	hugeint_t hugeint;
1342: 	int64_t intermediate;
1343: 	uint8_t digits;
1344: 
1345: 	bool Flush() {
1346: 		if (digits == 0 && intermediate == 0) {
1347: 			return true;
1348: 		}
1349: 		if (hugeint.lower != 0 || hugeint.upper != 0) {
1350: 			if (digits > 38) {
1351: 				return false;
1352: 			}
1353: 			if (!Hugeint::TryMultiply(hugeint, Hugeint::POWERS_OF_TEN[digits], hugeint)) {
1354: 				return false;
1355: 			}
1356: 		}
1357: 		if (!Hugeint::AddInPlace(hugeint, hugeint_t(intermediate))) {
1358: 			return false;
1359: 		}
1360: 		digits = 0;
1361: 		intermediate = 0;
1362: 		return true;
1363: 	}
1364: };
1365: 
1366: struct HugeIntegerCastOperation {
1367: 	template <class T, bool NEGATIVE>
1368: 	static bool HandleDigit(T &result, uint8_t digit) {
1369: 		if (NEGATIVE) {
1370: 			if (result.intermediate < (NumericLimits<int64_t>::Minimum() + digit) / 10) {
1371: 				// intermediate is full: need to flush it
1372: 				if (!result.Flush()) {
1373: 					return false;
1374: 				}
1375: 			}
1376: 			result.intermediate = result.intermediate * 10 - digit;
1377: 		} else {
1378: 			if (result.intermediate > (NumericLimits<int64_t>::Maximum() - digit) / 10) {
1379: 				if (!result.Flush()) {
1380: 					return false;
1381: 				}
1382: 			}
1383: 			result.intermediate = result.intermediate * 10 + digit;
1384: 		}
1385: 		result.digits++;
1386: 		return true;
1387: 	}
1388: 
1389: 	template <class T>
1390: 	static bool HandleExponent(T &result, int64_t exponent) {
1391: 		result.Flush();
1392: 		if (exponent < -38 || exponent > 38) {
1393: 			// out of range for exact exponent: use double and convert
1394: 			double dbl_res = Hugeint::Cast<double>(result.hugeint) * std::pow(10.0L, exponent);
1395: 			if (dbl_res < Hugeint::Cast<double>(NumericLimits<hugeint_t>::Minimum()) ||
1396: 			    dbl_res > Hugeint::Cast<double>(NumericLimits<hugeint_t>::Maximum())) {
1397: 				return false;
1398: 			}
1399: 			result.hugeint = Hugeint::Convert(dbl_res);
1400: 			return true;
1401: 		}
1402: 		if (exponent < 0) {
1403: 			// negative exponent: divide by power of 10
1404: 			result.hugeint = Hugeint::Divide(result.hugeint, Hugeint::POWERS_OF_TEN[-exponent]);
1405: 			return true;
1406: 		} else {
1407: 			// positive exponent: multiply by power of 10
1408: 			return Hugeint::TryMultiply(result.hugeint, Hugeint::POWERS_OF_TEN[exponent], result.hugeint);
1409: 		}
1410: 	}
1411: 
1412: 	template <class T, bool NEGATIVE>
1413: 	static bool HandleDecimal(T &result, uint8_t digit) {
1414: 		return true;
1415: 	}
1416: 
1417: 	template <class T>
1418: 	static bool Finalize(T &result) {
1419: 		return result.Flush();
1420: 	}
1421: };
1422: 
1423: template <>
1424: bool TryCast::Operation(string_t input, hugeint_t &result, bool strict) {
1425: 	HugeIntCastData data;
1426: 	if (!TryIntegerCast<HugeIntCastData, true, HugeIntegerCastOperation>(input.GetDataUnsafe(), input.GetSize(), data,
1427: 	                                                                     strict)) {
1428: 		return false;
1429: 	}
1430: 	result = data.hugeint;
1431: 	return true;
1432: }
1433: 
1434: template <>
1435: hugeint_t Cast::Operation(string_t input) {
1436: 	return TryCastString<hugeint_t>(input);
1437: }
1438: 
1439: template <>
1440: hugeint_t StrictCast::Operation(string_t input) {
1441: 	return TryStrictCastString<hugeint_t>(input);
1442: }
1443: 
1444: //===--------------------------------------------------------------------===//
1445: // Numeric -> Hugeint
1446: //===--------------------------------------------------------------------===//
1447: template <>
1448: bool TryCast::Operation(bool input, hugeint_t &result, bool strict) {
1449: 	result = Cast::Operation<bool, hugeint_t>(input);
1450: 	return true;
1451: }
1452: 
1453: template <>
1454: bool TryCast::Operation(int8_t input, hugeint_t &result, bool strict) {
1455: 	result = Cast::Operation<int8_t, hugeint_t>(input);
1456: 	return true;
1457: }
1458: 
1459: template <>
1460: bool TryCast::Operation(int16_t input, hugeint_t &result, bool strict) {
1461: 	result = Cast::Operation<int16_t, hugeint_t>(input);
1462: 	return true;
1463: }
1464: 
1465: template <>
1466: bool TryCast::Operation(int32_t input, hugeint_t &result, bool strict) {
1467: 	result = Cast::Operation<int32_t, hugeint_t>(input);
1468: 	return true;
1469: }
1470: 
1471: template <>
1472: bool TryCast::Operation(int64_t input, hugeint_t &result, bool strict) {
1473: 	result = Cast::Operation<int64_t, hugeint_t>(input);
1474: 	return true;
1475: }
1476: 
1477: template <>
1478: bool TryCast::Operation(uint8_t input, hugeint_t &result, bool strict) {
1479: 	result = Cast::Operation<uint8_t, hugeint_t>(input);
1480: 	return true;
1481: }
1482: template <>
1483: bool TryCast::Operation(uint16_t input, hugeint_t &result, bool strict) {
1484: 	result = Cast::Operation<uint16_t, hugeint_t>(input);
1485: 	return true;
1486: }
1487: template <>
1488: bool TryCast::Operation(uint32_t input, hugeint_t &result, bool strict) {
1489: 	result = Cast::Operation<uint32_t, hugeint_t>(input);
1490: 	return true;
1491: }
1492: template <>
1493: bool TryCast::Operation(uint64_t input, hugeint_t &result, bool strict) {
1494: 	result = Cast::Operation<uint64_t, hugeint_t>(input);
1495: 	return true;
1496: }
1497: 
1498: template <>
1499: bool TryCast::Operation(float input, hugeint_t &result, bool strict) {
1500: 	result = Cast::Operation<float, hugeint_t>(input);
1501: 	return true;
1502: }
1503: 
1504: template <>
1505: bool TryCast::Operation(double input, hugeint_t &result, bool strict) {
1506: 	result = Cast::Operation<double, hugeint_t>(input);
1507: 	return true;
1508: }
1509: 
1510: template <>
1511: hugeint_t Cast::Operation(bool input) {
1512: 	hugeint_t result;
1513: 	result.upper = 0;
1514: 	result.lower = input ? 1 : 0;
1515: 	return result;
1516: }
1517: 
1518: template <>
1519: hugeint_t Cast::Operation(uint8_t input) {
1520: 	return Hugeint::Convert<uint8_t>(input);
1521: }
1522: template <>
1523: hugeint_t Cast::Operation(uint16_t input) {
1524: 	return Hugeint::Convert<uint16_t>(input);
1525: }
1526: template <>
1527: hugeint_t Cast::Operation(uint32_t input) {
1528: 	return Hugeint::Convert<uint32_t>(input);
1529: }
1530: template <>
1531: hugeint_t Cast::Operation(uint64_t input) {
1532: 	return Hugeint::Convert<uint64_t>(input);
1533: }
1534: 
1535: template <>
1536: hugeint_t Cast::Operation(int8_t input) {
1537: 	return Hugeint::Convert<int8_t>(input);
1538: }
1539: template <>
1540: hugeint_t Cast::Operation(int16_t input) {
1541: 	return Hugeint::Convert<int16_t>(input);
1542: }
1543: template <>
1544: hugeint_t Cast::Operation(int32_t input) {
1545: 	return Hugeint::Convert<int32_t>(input);
1546: }
1547: template <>
1548: hugeint_t Cast::Operation(int64_t input) {
1549: 	return Hugeint::Convert<int64_t>(input);
1550: }
1551: template <>
1552: hugeint_t Cast::Operation(float input) {
1553: 	return Hugeint::Convert<float>(input);
1554: }
1555: template <>
1556: hugeint_t Cast::Operation(double input) {
1557: 	return Hugeint::Convert<double>(input);
1558: }
1559: 
1560: //===--------------------------------------------------------------------===//
1561: // Hugeint -> Numeric
1562: //===--------------------------------------------------------------------===//
1563: template <>
1564: bool TryCast::Operation(hugeint_t input, bool &result, bool strict) {
1565: 	// any positive number converts to true
1566: 	result = input.upper > 0 || (input.upper == 0 && input.lower > 0);
1567: 	return true;
1568: }
1569: 
1570: template <>
1571: bool TryCast::Operation(hugeint_t input, int8_t &result, bool strict) {
1572: 	return Hugeint::TryCast<int8_t>(input, result);
1573: }
1574: 
1575: template <>
1576: bool TryCast::Operation(hugeint_t input, int16_t &result, bool strict) {
1577: 	return Hugeint::TryCast<int16_t>(input, result);
1578: }
1579: 
1580: template <>
1581: bool TryCast::Operation(hugeint_t input, int32_t &result, bool strict) {
1582: 	return Hugeint::TryCast<int32_t>(input, result);
1583: }
1584: 
1585: template <>
1586: bool TryCast::Operation(hugeint_t input, int64_t &result, bool strict) {
1587: 	return Hugeint::TryCast<int64_t>(input, result);
1588: }
1589: 
1590: template <>
1591: bool TryCast::Operation(hugeint_t input, uint8_t &result, bool strict) {
1592: 	return Hugeint::TryCast<uint8_t>(input, result);
1593: }
1594: template <>
1595: bool TryCast::Operation(hugeint_t input, uint16_t &result, bool strict) {
1596: 	return Hugeint::TryCast<uint16_t>(input, result);
1597: }
1598: template <>
1599: bool TryCast::Operation(hugeint_t input, uint32_t &result, bool strict) {
1600: 	return Hugeint::TryCast<uint32_t>(input, result);
1601: }
1602: template <>
1603: bool TryCast::Operation(hugeint_t input, uint64_t &result, bool strict) {
1604: 	return Hugeint::TryCast<uint64_t>(input, result);
1605: }
1606: 
1607: template <>
1608: bool TryCast::Operation(hugeint_t input, float &result, bool strict) {
1609: 	return Hugeint::TryCast<float>(input, result);
1610: }
1611: 
1612: template <>
1613: bool TryCast::Operation(hugeint_t input, double &result, bool strict) {
1614: 	return Hugeint::TryCast<double>(input, result);
1615: }
1616: 
1617: template <>
1618: bool Cast::Operation(hugeint_t input) {
1619: 	bool result;
1620: 	TryCast::Operation(input, result);
1621: 	return result;
1622: }
1623: 
1624: template <class T>
1625: static T HugeintCastToNumeric(hugeint_t input) {
1626: 	T result;
1627: 	if (!TryCast::Operation<hugeint_t, T>(input, result)) {
1628: 		throw ValueOutOfRangeException(input, PhysicalType::INT128, GetTypeId<T>());
1629: 	}
1630: 	return result;
1631: }
1632: 
1633: template <>
1634: int8_t Cast::Operation(hugeint_t input) {
1635: 	return HugeintCastToNumeric<int8_t>(input);
1636: }
1637: 
1638: template <>
1639: int16_t Cast::Operation(hugeint_t input) {
1640: 	return HugeintCastToNumeric<int16_t>(input);
1641: }
1642: 
1643: template <>
1644: int32_t Cast::Operation(hugeint_t input) {
1645: 	return HugeintCastToNumeric<int32_t>(input);
1646: }
1647: 
1648: template <>
1649: int64_t Cast::Operation(hugeint_t input) {
1650: 	return HugeintCastToNumeric<int64_t>(input);
1651: }
1652: 
1653: template <>
1654: uint8_t Cast::Operation(hugeint_t input) {
1655: 	return HugeintCastToNumeric<uint8_t>(input);
1656: }
1657: template <>
1658: uint16_t Cast::Operation(hugeint_t input) {
1659: 	return HugeintCastToNumeric<uint16_t>(input);
1660: }
1661: template <>
1662: uint32_t Cast::Operation(hugeint_t input) {
1663: 	return HugeintCastToNumeric<uint32_t>(input);
1664: }
1665: template <>
1666: uint64_t Cast::Operation(hugeint_t input) {
1667: 	return HugeintCastToNumeric<uint64_t>(input);
1668: }
1669: 
1670: template <>
1671: float Cast::Operation(hugeint_t input) {
1672: 	return HugeintCastToNumeric<float>(input);
1673: }
1674: 
1675: template <>
1676: double Cast::Operation(hugeint_t input) {
1677: 	return HugeintCastToNumeric<double>(input);
1678: }
1679: 
1680: template <>
1681: bool TryCast::Operation(hugeint_t input, hugeint_t &result, bool strict) {
1682: 	result = input;
1683: 	return true;
1684: }
1685: 
1686: template <>
1687: hugeint_t Cast::Operation(hugeint_t input) {
1688: 	return input;
1689: }
1690: 
1691: //===--------------------------------------------------------------------===//
1692: // Decimal String Cast
1693: //===--------------------------------------------------------------------===//
1694: template <class T>
1695: struct DecimalCastData {
1696: 	T result;
1697: 	uint8_t width;
1698: 	uint8_t scale;
1699: 	uint8_t digit_count;
1700: 	uint8_t decimal_count;
1701: };
1702: 
1703: struct DecimalCastOperation {
1704: 	template <class T, bool NEGATIVE>
1705: 	static bool HandleDigit(T &state, uint8_t digit) {
1706: 		if (state.result == 0 && digit == 0) {
1707: 			// leading zero's don't count towards the digit count
1708: 			return true;
1709: 		}
1710: 		if (state.digit_count == state.width - state.scale) {
1711: 			// width of decimal type is exceeded!
1712: 			return false;
1713: 		}
1714: 		state.digit_count++;
1715: 		if (NEGATIVE) {
1716: 			state.result = state.result * 10 - digit;
1717: 		} else {
1718: 			state.result = state.result * 10 + digit;
1719: 		}
1720: 		return true;
1721: 	}
1722: 
1723: 	template <class T>
1724: 	static bool HandleExponent(T &state, int64_t exponent) {
1725: 		return false;
1726: 	}
1727: 
1728: 	template <class T, bool NEGATIVE>
1729: 	static bool HandleDecimal(T &state, uint8_t digit) {
1730: 		if (state.decimal_count == state.scale) {
1731: 			// we exceeded the amount of supported decimals
1732: 			// however, we don't throw an error here
1733: 			// we just truncate the decimal
1734: 			return true;
1735: 		}
1736: 		state.decimal_count++;
1737: 		if (NEGATIVE) {
1738: 			state.result = state.result * 10 - digit;
1739: 		} else {
1740: 			state.result = state.result * 10 + digit;
1741: 		}
1742: 		return true;
1743: 	}
1744: 
1745: 	template <class T>
1746: 	static bool Finalize(T &state) {
1747: 		// if we have not gotten exactly "scale" decimals, we need to multiply the result
1748: 		// e.g. if we have a string "1.0" that is cast to a DECIMAL(9,3), the value needs to be 1000
1749: 		// but we have only gotten the value "10" so far, so we multiply by 1000
1750: 		for (uint8_t i = state.decimal_count; i < state.scale; i++) {
1751: 			state.result *= 10;
1752: 		}
1753: 		return true;
1754: 	}
1755: };
1756: 
1757: template <class T>
1758: T DecimalStringCast(string_t input, uint8_t width, uint8_t scale) {
1759: 	DecimalCastData<T> state;
1760: 	state.result = 0;
1761: 	state.width = width;
1762: 	state.scale = scale;
1763: 	state.digit_count = 0;
1764: 	state.decimal_count = 0;
1765: 	if (!TryIntegerCast<DecimalCastData<T>, false, DecimalCastOperation, false>(input.GetDataUnsafe(), input.GetSize(),
1766: 	                                                                            state, false)) {
1767: 		throw ConversionException("Could not convert string \"%s\" to DECIMAL(%d,%d)", input.GetString(), (int)width,
1768: 		                          (int)scale);
1769: 	}
1770: 	return state.result;
1771: }
1772: 
1773: template <>
1774: int16_t CastToDecimal::Operation(string_t input, uint8_t width, uint8_t scale) {
1775: 	return DecimalStringCast<int16_t>(input, width, scale);
1776: }
1777: 
1778: template <>
1779: int32_t CastToDecimal::Operation(string_t input, uint8_t width, uint8_t scale) {
1780: 	return DecimalStringCast<int32_t>(input, width, scale);
1781: }
1782: 
1783: template <>
1784: int64_t CastToDecimal::Operation(string_t input, uint8_t width, uint8_t scale) {
1785: 	return DecimalStringCast<int64_t>(input, width, scale);
1786: }
1787: 
1788: template <>
1789: hugeint_t CastToDecimal::Operation(string_t input, uint8_t width, uint8_t scale) {
1790: 	return DecimalStringCast<hugeint_t>(input, width, scale);
1791: }
1792: 
1793: template <>
1794: string_t StringCastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale, Vector &result) {
1795: 	return DecimalToString::Format<int16_t, uint16_t>(input, scale, result);
1796: }
1797: 
1798: template <>
1799: string_t StringCastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale, Vector &result) {
1800: 	return DecimalToString::Format<int32_t, uint32_t>(input, scale, result);
1801: }
1802: 
1803: template <>
1804: string_t StringCastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale, Vector &result) {
1805: 	return DecimalToString::Format<int64_t, uint64_t>(input, scale, result);
1806: }
1807: 
1808: template <>
1809: string_t StringCastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale, Vector &result) {
1810: 	return HugeintToStringCast::FormatDecimal(input, scale, result);
1811: }
1812: 
1813: template <>
1814: int16_t CastToDecimal::Operation(bool input, uint8_t width, uint8_t scale) {
1815: 	return input ? NumericHelper::POWERS_OF_TEN[scale] : 0;
1816: }
1817: 
1818: template <>
1819: int32_t CastToDecimal::Operation(bool input, uint8_t width, uint8_t scale) {
1820: 	return input ? NumericHelper::POWERS_OF_TEN[scale] : 0;
1821: }
1822: 
1823: template <>
1824: int64_t CastToDecimal::Operation(bool input, uint8_t width, uint8_t scale) {
1825: 	return input ? NumericHelper::POWERS_OF_TEN[scale] : 0;
1826: }
1827: 
1828: template <>
1829: hugeint_t CastToDecimal::Operation(bool input, uint8_t width, uint8_t scale) {
1830: 	return input ? Hugeint::POWERS_OF_TEN[scale] : 0;
1831: }
1832: 
1833: template <>
1834: bool CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
1835: 	return Cast::Operation<int16_t, bool>(input);
1836: }
1837: 
1838: template <>
1839: bool CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
1840: 	return Cast::Operation<int32_t, bool>(input);
1841: }
1842: 
1843: template <>
1844: bool CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
1845: 	return Cast::Operation<int64_t, bool>(input);
1846: }
1847: 
1848: template <>
1849: bool CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
1850: 	return Cast::Operation<hugeint_t, bool>(input);
1851: }
1852: 
1853: //===--------------------------------------------------------------------===//
1854: // Numeric -> Decimal Cast
1855: //===--------------------------------------------------------------------===//
1856: template <class SRC, class DST>
1857: DST StandardNumericToDecimalCast(SRC input, uint8_t width, uint8_t scale) {
1858: 	// check for overflow
1859: 	DST max_width = NumericHelper::POWERS_OF_TEN[width - scale];
1860: 	if (int64_t(input) >= max_width || int64_t(input) <= -max_width) {
1861: 		throw OutOfRangeException("Could not cast value %d to DECIMAL(%d,%d)", input, width, scale);
1862: 	}
1863: 	return DST(input) * NumericHelper::POWERS_OF_TEN[scale];
1864: }
1865: 
1866: template <class SRC>
1867: hugeint_t NumericToHugeDecimalCast(SRC input, uint8_t width, uint8_t scale) {
1868: 	// check for overflow
1869: 	hugeint_t max_width = Hugeint::POWERS_OF_TEN[width - scale];
1870: 	hugeint_t hinput = hugeint_t(input);
1871: 	if (hinput >= max_width || hinput <= -max_width) {
1872: 		throw OutOfRangeException("Could not cast value %s to DECIMAL(%d,%d)", hinput.ToString(), width, scale);
1873: 	}
1874: 	return hinput * Hugeint::POWERS_OF_TEN[scale];
1875: }
1876: 
1877: // TINYINT -> DECIMAL
1878: template <>
1879: int16_t CastToDecimal::Operation(int8_t input, uint8_t width, uint8_t scale) {
1880: 	return StandardNumericToDecimalCast<int8_t, int16_t>(input, width, scale);
1881: }
1882: 
1883: template <>
1884: int32_t CastToDecimal::Operation(int8_t input, uint8_t width, uint8_t scale) {
1885: 	return StandardNumericToDecimalCast<int8_t, int32_t>(input, width, scale);
1886: }
1887: 
1888: template <>
1889: int64_t CastToDecimal::Operation(int8_t input, uint8_t width, uint8_t scale) {
1890: 	return StandardNumericToDecimalCast<int8_t, int64_t>(input, width, scale);
1891: }
1892: 
1893: template <>
1894: hugeint_t CastToDecimal::Operation(int8_t input, uint8_t width, uint8_t scale) {
1895: 	return NumericToHugeDecimalCast<int8_t>(input, width, scale);
1896: }
1897: 
1898: // UTINYINT -> DECIMAL
1899: template <>
1900: int16_t CastToDecimal::Operation(uint8_t input, uint8_t width, uint8_t scale) {
1901: 	return StandardNumericToDecimalCast<uint8_t, int16_t>(input, width, scale);
1902: }
1903: template <>
1904: int32_t CastToDecimal::Operation(uint8_t input, uint8_t width, uint8_t scale) {
1905: 	return StandardNumericToDecimalCast<uint8_t, int32_t>(input, width, scale);
1906: }
1907: template <>
1908: int64_t CastToDecimal::Operation(uint8_t input, uint8_t width, uint8_t scale) {
1909: 	return StandardNumericToDecimalCast<uint8_t, int64_t>(input, width, scale);
1910: }
1911: template <>
1912: hugeint_t CastToDecimal::Operation(uint8_t input, uint8_t width, uint8_t scale) {
1913: 	return NumericToHugeDecimalCast<uint8_t>(input, width, scale);
1914: }
1915: 
1916: // SMALLINT -> DECIMAL
1917: template <>
1918: int16_t CastToDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
1919: 	return StandardNumericToDecimalCast<int16_t, int16_t>(input, width, scale);
1920: }
1921: 
1922: template <>
1923: int32_t CastToDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
1924: 	return StandardNumericToDecimalCast<int16_t, int32_t>(input, width, scale);
1925: }
1926: 
1927: template <>
1928: int64_t CastToDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
1929: 	return StandardNumericToDecimalCast<int16_t, int64_t>(input, width, scale);
1930: }
1931: 
1932: template <>
1933: hugeint_t CastToDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
1934: 	return NumericToHugeDecimalCast<int16_t>(input, width, scale);
1935: }
1936: 
1937: // USMALLINT -> DECIMAL
1938: template <>
1939: int16_t CastToDecimal::Operation(uint16_t input, uint8_t width, uint8_t scale) {
1940: 	return StandardNumericToDecimalCast<uint16_t, int16_t>(input, width, scale);
1941: }
1942: template <>
1943: int32_t CastToDecimal::Operation(uint16_t input, uint8_t width, uint8_t scale) {
1944: 	return StandardNumericToDecimalCast<uint16_t, int32_t>(input, width, scale);
1945: }
1946: 
1947: template <>
1948: int64_t CastToDecimal::Operation(uint16_t input, uint8_t width, uint8_t scale) {
1949: 	return StandardNumericToDecimalCast<uint16_t, int64_t>(input, width, scale);
1950: }
1951: template <>
1952: hugeint_t CastToDecimal::Operation(uint16_t input, uint8_t width, uint8_t scale) {
1953: 	return NumericToHugeDecimalCast<uint16_t>(input, width, scale);
1954: }
1955: 
1956: // INTEGER -> DECIMAL
1957: template <>
1958: int16_t CastToDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
1959: 	return StandardNumericToDecimalCast<int32_t, int16_t>(input, width, scale);
1960: }
1961: 
1962: template <>
1963: int32_t CastToDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
1964: 	return StandardNumericToDecimalCast<int32_t, int32_t>(input, width, scale);
1965: }
1966: 
1967: template <>
1968: int64_t CastToDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
1969: 	return StandardNumericToDecimalCast<int32_t, int64_t>(input, width, scale);
1970: }
1971: 
1972: template <>
1973: hugeint_t CastToDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
1974: 	return NumericToHugeDecimalCast<int32_t>(input, width, scale);
1975: }
1976: 
1977: // UINTEGER -> DECIMAL
1978: 
1979: template <>
1980: int16_t CastToDecimal::Operation(uint32_t input, uint8_t width, uint8_t scale) {
1981: 	return StandardNumericToDecimalCast<uint32_t, int16_t>(input, width, scale);
1982: }
1983: template <>
1984: int32_t CastToDecimal::Operation(uint32_t input, uint8_t width, uint8_t scale) {
1985: 	return StandardNumericToDecimalCast<uint32_t, int32_t>(input, width, scale);
1986: }
1987: template <>
1988: int64_t CastToDecimal::Operation(uint32_t input, uint8_t width, uint8_t scale) {
1989: 	return StandardNumericToDecimalCast<uint32_t, int64_t>(input, width, scale);
1990: }
1991: template <>
1992: hugeint_t CastToDecimal::Operation(uint32_t input, uint8_t width, uint8_t scale) {
1993: 	return NumericToHugeDecimalCast<uint32_t>(input, width, scale);
1994: }
1995: 
1996: // BIGINT -> DECIMAL
1997: template <>
1998: int16_t CastToDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
1999: 	return StandardNumericToDecimalCast<int64_t, int16_t>(input, width, scale);
2000: }
2001: 
2002: template <>
2003: int32_t CastToDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2004: 	return StandardNumericToDecimalCast<int64_t, int32_t>(input, width, scale);
2005: }
2006: 
2007: template <>
2008: int64_t CastToDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2009: 	return StandardNumericToDecimalCast<int64_t, int64_t>(input, width, scale);
2010: }
2011: 
2012: template <>
2013: hugeint_t CastToDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2014: 	return NumericToHugeDecimalCast<int64_t>(input, width, scale);
2015: }
2016: 
2017: // BIGINT -> DECIMAL
2018: 
2019: template <>
2020: int16_t CastToDecimal::Operation(uint64_t input, uint8_t width, uint8_t scale) {
2021: 	return StandardNumericToDecimalCast<uint64_t, int16_t>(input, width, scale);
2022: }
2023: 
2024: template <>
2025: int32_t CastToDecimal::Operation(uint64_t input, uint8_t width, uint8_t scale) {
2026: 	return StandardNumericToDecimalCast<uint64_t, int32_t>(input, width, scale);
2027: }
2028: 
2029: template <>
2030: int64_t CastToDecimal::Operation(uint64_t input, uint8_t width, uint8_t scale) {
2031: 	return StandardNumericToDecimalCast<uint64_t, int64_t>(input, width, scale);
2032: }
2033: 
2034: template <>
2035: hugeint_t CastToDecimal::Operation(uint64_t input, uint8_t width, uint8_t scale) {
2036: 	return NumericToHugeDecimalCast<uint64_t>(input, width, scale);
2037: }
2038: 
2039: template <class DST>
2040: DST HugeintToDecimalCast(hugeint_t input, uint8_t width, uint8_t scale) {
2041: 	// check for overflow
2042: 	hugeint_t max_width = Hugeint::POWERS_OF_TEN[width - scale];
2043: 	if (input >= max_width || input <= -max_width) {
2044: 		throw OutOfRangeException("Could not cast value %s to DECIMAL(%d,%d)", input.ToString(), width, scale);
2045: 	}
2046: 	return Hugeint::Cast<DST>(input * Hugeint::POWERS_OF_TEN[scale]);
2047: }
2048: 
2049: // HUGEINT -> DECIMAL
2050: template <>
2051: int16_t CastToDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2052: 	return HugeintToDecimalCast<int16_t>(input, width, scale);
2053: }
2054: 
2055: template <>
2056: int32_t CastToDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2057: 	return HugeintToDecimalCast<int32_t>(input, width, scale);
2058: }
2059: 
2060: template <>
2061: int64_t CastToDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2062: 	return HugeintToDecimalCast<int64_t>(input, width, scale);
2063: }
2064: 
2065: template <>
2066: hugeint_t CastToDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2067: 	return HugeintToDecimalCast<hugeint_t>(input, width, scale);
2068: }
2069: 
2070: template <class SRC, class DST>
2071: DST DoubleToDecimalCast(SRC input, uint8_t width, uint8_t scale) {
2072: 	double value = input * NumericHelper::DOUBLE_POWERS_OF_TEN[scale];
2073: 	if (value <= -NumericHelper::DOUBLE_POWERS_OF_TEN[width] || value >= NumericHelper::DOUBLE_POWERS_OF_TEN[width]) {
2074: 		throw OutOfRangeException("Could not cast value %f to DECIMAL(%d,%d)", value, width, scale);
2075: 	}
2076: 	return Cast::Operation<SRC, DST>(value);
2077: }
2078: 
2079: // FLOAT -> DECIMAL
2080: template <>
2081: int16_t CastToDecimal::Operation(float input, uint8_t width, uint8_t scale) {
2082: 	return DoubleToDecimalCast<float, int16_t>(input, width, scale);
2083: }
2084: 
2085: template <>
2086: int32_t CastToDecimal::Operation(float input, uint8_t width, uint8_t scale) {
2087: 	return DoubleToDecimalCast<float, int32_t>(input, width, scale);
2088: }
2089: 
2090: template <>
2091: int64_t CastToDecimal::Operation(float input, uint8_t width, uint8_t scale) {
2092: 	return DoubleToDecimalCast<float, int64_t>(input, width, scale);
2093: }
2094: 
2095: template <>
2096: hugeint_t CastToDecimal::Operation(float input, uint8_t width, uint8_t scale) {
2097: 	return DoubleToDecimalCast<float, hugeint_t>(input, width, scale);
2098: }
2099: 
2100: // DOUBLE -> DECIMAL
2101: template <>
2102: int16_t CastToDecimal::Operation(double input, uint8_t width, uint8_t scale) {
2103: 	return DoubleToDecimalCast<double, int16_t>(input, width, scale);
2104: }
2105: 
2106: template <>
2107: int32_t CastToDecimal::Operation(double input, uint8_t width, uint8_t scale) {
2108: 	return DoubleToDecimalCast<double, int32_t>(input, width, scale);
2109: }
2110: 
2111: template <>
2112: int64_t CastToDecimal::Operation(double input, uint8_t width, uint8_t scale) {
2113: 	return DoubleToDecimalCast<double, int64_t>(input, width, scale);
2114: }
2115: 
2116: template <>
2117: hugeint_t CastToDecimal::Operation(double input, uint8_t width, uint8_t scale) {
2118: 	return DoubleToDecimalCast<double, hugeint_t>(input, width, scale);
2119: }
2120: 
2121: //===--------------------------------------------------------------------===//
2122: // Decimal -> Numeric Cast
2123: //===--------------------------------------------------------------------===//
2124: template <class SRC, class DST>
2125: DST CastDecimalToNumeric(SRC input, uint8_t scale) {
2126: 	return Cast::Operation<SRC, DST>(input / NumericHelper::POWERS_OF_TEN[scale]);
2127: }
2128: 
2129: template <class DST>
2130: DST CastHugeDecimalToNumeric(hugeint_t input, uint8_t scale) {
2131: 	return Cast::Operation<hugeint_t, DST>(input / Hugeint::POWERS_OF_TEN[scale]);
2132: }
2133: 
2134: // DECIMAL -> TINYINT
2135: template <>
2136: int8_t CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
2137: 	return CastDecimalToNumeric<int16_t, int8_t>(input, scale);
2138: }
2139: 
2140: template <>
2141: int8_t CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
2142: 	return CastDecimalToNumeric<int32_t, int8_t>(input, scale);
2143: }
2144: 
2145: template <>
2146: int8_t CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2147: 	return CastDecimalToNumeric<int64_t, int8_t>(input, scale);
2148: }
2149: 
2150: template <>
2151: int8_t CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2152: 	return CastHugeDecimalToNumeric<int8_t>(input, scale);
2153: }
2154: 
2155: // DECIMAL -> UTINYINT
2156: template <>
2157: uint8_t CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
2158: 	return CastDecimalToNumeric<int16_t, uint8_t>(input, scale);
2159: }
2160: template <>
2161: uint8_t CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
2162: 	return CastDecimalToNumeric<int32_t, uint8_t>(input, scale);
2163: }
2164: template <>
2165: uint8_t CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2166: 	return CastDecimalToNumeric<int64_t, uint8_t>(input, scale);
2167: }
2168: template <>
2169: uint8_t CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2170: 	return CastHugeDecimalToNumeric<uint8_t>(input, scale);
2171: }
2172: 
2173: // DECIMAL -> SMALLINT
2174: template <>
2175: int16_t CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
2176: 	return CastDecimalToNumeric<int16_t, int16_t>(input, scale);
2177: }
2178: 
2179: template <>
2180: int16_t CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
2181: 	return CastDecimalToNumeric<int32_t, int16_t>(input, scale);
2182: }
2183: 
2184: template <>
2185: int16_t CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2186: 	return CastDecimalToNumeric<int64_t, int16_t>(input, scale);
2187: }
2188: 
2189: template <>
2190: int16_t CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2191: 	return CastHugeDecimalToNumeric<int16_t>(input, scale);
2192: }
2193: 
2194: // DECIMAL -> USMALLINT
2195: template <>
2196: uint16_t CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
2197: 	return CastDecimalToNumeric<int16_t, uint16_t>(input, scale);
2198: }
2199: 
2200: template <>
2201: uint16_t CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
2202: 	return CastDecimalToNumeric<int32_t, uint16_t>(input, scale);
2203: }
2204: 
2205: template <>
2206: uint16_t CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2207: 	return CastDecimalToNumeric<int64_t, uint16_t>(input, scale);
2208: }
2209: 
2210: template <>
2211: uint16_t CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2212: 	return CastHugeDecimalToNumeric<uint16_t>(input, scale);
2213: }
2214: 
2215: // DECIMAL -> INTEGER
2216: template <>
2217: int32_t CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
2218: 	return CastDecimalToNumeric<int16_t, int32_t>(input, scale);
2219: }
2220: 
2221: template <>
2222: int32_t CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
2223: 	return CastDecimalToNumeric<int32_t, int32_t>(input, scale);
2224: }
2225: 
2226: template <>
2227: int32_t CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2228: 	return CastDecimalToNumeric<int64_t, int32_t>(input, scale);
2229: }
2230: 
2231: template <>
2232: int32_t CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2233: 	return CastHugeDecimalToNumeric<int32_t>(input, scale);
2234: }
2235: 
2236: // DECIMAL -> UINTEGER
2237: template <>
2238: uint32_t CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
2239: 	return CastDecimalToNumeric<int16_t, uint32_t>(input, scale);
2240: }
2241: template <>
2242: uint32_t CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
2243: 	return CastDecimalToNumeric<int32_t, uint32_t>(input, scale);
2244: }
2245: template <>
2246: uint32_t CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2247: 	return CastDecimalToNumeric<int64_t, uint32_t>(input, scale);
2248: }
2249: template <>
2250: uint32_t CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2251: 	return CastHugeDecimalToNumeric<uint32_t>(input, scale);
2252: }
2253: 
2254: // DECIMAL -> BIGINT
2255: template <>
2256: int64_t CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
2257: 	return CastDecimalToNumeric<int16_t, int64_t>(input, scale);
2258: }
2259: 
2260: template <>
2261: int64_t CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
2262: 	return CastDecimalToNumeric<int32_t, int64_t>(input, scale);
2263: }
2264: 
2265: template <>
2266: int64_t CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2267: 	return CastDecimalToNumeric<int64_t, int64_t>(input, scale);
2268: }
2269: 
2270: template <>
2271: int64_t CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2272: 	return CastHugeDecimalToNumeric<int64_t>(input, scale);
2273: }
2274: 
2275: // DECIMAL -> UBIGINT
2276: template <>
2277: uint64_t CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
2278: 	return CastDecimalToNumeric<int16_t, uint64_t>(input, scale);
2279: }
2280: template <>
2281: uint64_t CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
2282: 	return CastDecimalToNumeric<int32_t, uint64_t>(input, scale);
2283: }
2284: template <>
2285: uint64_t CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2286: 	return CastDecimalToNumeric<int64_t, uint64_t>(input, scale);
2287: }
2288: template <>
2289: uint64_t CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2290: 	return CastHugeDecimalToNumeric<uint64_t>(input, scale);
2291: }
2292: 
2293: // DECIMAL -> HUGEINT
2294: template <>
2295: hugeint_t CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
2296: 	return CastDecimalToNumeric<int16_t, hugeint_t>(input, scale);
2297: }
2298: 
2299: template <>
2300: hugeint_t CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
2301: 	return CastDecimalToNumeric<int32_t, hugeint_t>(input, scale);
2302: }
2303: 
2304: template <>
2305: hugeint_t CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2306: 	return CastDecimalToNumeric<int64_t, hugeint_t>(input, scale);
2307: }
2308: 
2309: template <>
2310: hugeint_t CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2311: 	return CastHugeDecimalToNumeric<hugeint_t>(input, scale);
2312: }
2313: 
2314: template <class SRC, class DST>
2315: DST CastDecimalToFloatingPoint(SRC input, uint8_t scale) {
2316: 	return Cast::Operation<SRC, DST>(input) / DST(NumericHelper::DOUBLE_POWERS_OF_TEN[scale]);
2317: }
2318: 
2319: // DECIMAL -> FLOAT
2320: template <>
2321: float CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
2322: 	return CastDecimalToFloatingPoint<int16_t, float>(input, scale);
2323: }
2324: 
2325: template <>
2326: float CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
2327: 	return CastDecimalToFloatingPoint<int32_t, float>(input, scale);
2328: }
2329: 
2330: template <>
2331: float CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2332: 	return CastDecimalToFloatingPoint<int64_t, float>(input, scale);
2333: }
2334: 
2335: template <>
2336: float CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2337: 	return CastDecimalToFloatingPoint<hugeint_t, float>(input, scale);
2338: }
2339: 
2340: // DECIMAL -> DOUBLE
2341: template <>
2342: double CastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale) {
2343: 	return CastDecimalToFloatingPoint<int16_t, double>(input, scale);
2344: }
2345: 
2346: template <>
2347: double CastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale) {
2348: 	return CastDecimalToFloatingPoint<int32_t, double>(input, scale);
2349: }
2350: 
2351: template <>
2352: double CastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale) {
2353: 	return CastDecimalToFloatingPoint<int64_t, double>(input, scale);
2354: }
2355: 
2356: template <>
2357: double CastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale) {
2358: 	return CastDecimalToFloatingPoint<hugeint_t, double>(input, scale);
2359: }
2360: 
2361: } // namespace duckdb
[end of src/common/operator/cast_operators.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: