{
  "repo": "duckdb/duckdb",
  "pull_number": 3380,
  "instance_id": "duckdb__duckdb-3380",
  "issue_numbers": [
    "3373"
  ],
  "base_commit": "31ae8ed9a283c7b5c237c1c04674637695b44f6c",
  "patch": "diff --git a/src/function/aggregate/distributive/arg_min_max.cpp b/src/function/aggregate/distributive/arg_min_max.cpp\nindex 798cd11930fa..552e76e284d9 100644\n--- a/src/function/aggregate/distributive/arg_min_max.cpp\n+++ b/src/function/aggregate/distributive/arg_min_max.cpp\n@@ -3,8 +3,7 @@\n #include \"duckdb/function/aggregate/distributive_functions.hpp\"\n #include \"duckdb/function/function_set.hpp\"\n #include \"duckdb/planner/expression/bound_aggregate_expression.hpp\"\n-\n-#include <utility>\n+#include \"duckdb/common/operator/comparison_operators.hpp\"\n \n namespace duckdb {\n \n@@ -15,39 +14,71 @@ struct ArgMinMaxState {\n \tbool is_initialized;\n };\n \n-struct ArgMinMaxOperation {\n-\ttemplate <class STATE>\n-\tstatic void Initialize(STATE *state) {\n-\t\tstate->is_initialized = false;\n+template <class T>\n+static void ArgMinMaxDestroyValue(T value) {\n+}\n+\n+template <>\n+void ArgMinMaxDestroyValue(string_t value) {\n+\tif (!value.IsInlined()) {\n+\t\tdelete[] value.GetDataUnsafe();\n \t}\n+}\n \n-\ttemplate <class T, class STATE>\n-\tstatic void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {\n-\t\tif (!state->is_initialized) {\n-\t\t\tmask.SetInvalid(idx);\n-\t\t} else {\n-\t\t\ttarget[idx] = state->arg;\n+template <class T>\n+static void ArgMinMaxAssignValue(T &target, T new_value, bool is_initialized) {\n+\ttarget = new_value;\n+}\n+\n+template <>\n+void ArgMinMaxAssignValue(string_t &target, string_t new_value, bool is_initialized) {\n+\tif (is_initialized) {\n+\t\tArgMinMaxDestroyValue(target);\n+\t}\n+\tif (new_value.IsInlined()) {\n+\t\ttarget = new_value;\n+\t} else {\n+\t\t// non-inlined string, need to allocate space for it\n+\t\tauto len = new_value.GetSize();\n+\t\tauto ptr = new char[len];\n+\t\tmemcpy(ptr, new_value.GetDataUnsafe(), len);\n+\n+\t\ttarget = string_t(ptr, len);\n+\t}\n+}\n+\n+template <class COMPARATOR>\n+struct ArgMinMaxBase {\n+\ttemplate <class STATE>\n+\tstatic void Destroy(STATE *state) {\n+\t\tif (state->is_initialized) {\n+\t\t\tArgMinMaxDestroyValue(state->arg);\n+\t\t\tArgMinMaxDestroyValue(state->value);\n \t\t}\n \t}\n \n-\tstatic bool IgnoreNull() {\n-\t\treturn true;\n+\ttemplate <class STATE>\n+\tstatic void Initialize(STATE *state) {\n+\t\tstate->is_initialized = false;\n \t}\n-};\n \n-struct ArgMinOperation : ArgMinMaxOperation {\n \ttemplate <class A_TYPE, class B_TYPE, class STATE, class OP>\n \tstatic void Operation(STATE *state, FunctionData *bind_data, A_TYPE *x_data, B_TYPE *y_data, ValidityMask &amask,\n \t                      ValidityMask &bmask, idx_t xidx, idx_t yidx) {\n \t\tif (!state->is_initialized) {\n-\t\t\tstate->value = y_data[yidx];\n-\t\t\tstate->arg = x_data[xidx];\n+\t\t\tArgMinMaxAssignValue<A_TYPE>(state->arg, x_data[xidx], false);\n+\t\t\tArgMinMaxAssignValue<B_TYPE>(state->value, y_data[yidx], false);\n \t\t\tstate->is_initialized = true;\n \t\t} else {\n-\t\t\tif (y_data[yidx] < state->value) {\n-\t\t\t\tstate->value = y_data[yidx];\n-\t\t\t\tstate->arg = x_data[xidx];\n-\t\t\t}\n+\t\t\tOP::template Execute<A_TYPE, B_TYPE, STATE>(state, x_data[xidx], y_data[yidx]);\n+\t\t}\n+\t}\n+\n+\ttemplate <class A_TYPE, class B_TYPE, class STATE>\n+\tstatic void Execute(STATE *state, A_TYPE x_data, B_TYPE y_data) {\n+\t\tif (COMPARATOR::Operation(y_data, state->value)) {\n+\t\t\tArgMinMaxAssignValue<A_TYPE>(state->arg, x_data, true);\n+\t\t\tArgMinMaxAssignValue<B_TYPE>(state->value, y_data, true);\n \t\t}\n \t}\n \n@@ -56,183 +87,98 @@ struct ArgMinOperation : ArgMinMaxOperation {\n \t\tif (!source.is_initialized) {\n \t\t\treturn;\n \t\t}\n-\t\tif (!target->is_initialized) {\n+\t\tif (!target->is_initialized || COMPARATOR::Operation(source.value, target->value)) {\n+\t\t\tArgMinMaxAssignValue(target->arg, source.arg, target->is_initialized);\n+\t\t\tArgMinMaxAssignValue(target->value, source.value, target->is_initialized);\n \t\t\ttarget->is_initialized = true;\n-\t\t\ttarget->value = source.value;\n-\t\t\ttarget->arg = source.arg;\n-\t\t\treturn;\n-\t\t}\n-\t\tif (source.value < target->value) {\n-\t\t\ttarget->value = source.value;\n-\t\t\ttarget->arg = source.arg;\n \t\t}\n \t}\n+\n+\tstatic bool IgnoreNull() {\n+\t\treturn true;\n+\t}\n };\n \n-struct ArgMaxOperation : ArgMinMaxOperation {\n-\ttemplate <class A_TYPE, class B_TYPE, class STATE, class OP>\n-\tstatic void Operation(STATE *state, FunctionData *bind_data, A_TYPE *x_data, B_TYPE *y_data, ValidityMask &amask,\n-\t                      ValidityMask &bmask, idx_t xidx, idx_t yidx) {\n+template <class COMPARATOR>\n+struct StringArgMinMax : public ArgMinMaxBase<COMPARATOR> {\n+\ttemplate <class T, class STATE>\n+\tstatic void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {\n \t\tif (!state->is_initialized) {\n-\t\t\tstate->value = y_data[yidx];\n-\t\t\tstate->arg = x_data[xidx];\n-\t\t\tstate->is_initialized = true;\n+\t\t\tmask.SetInvalid(idx);\n \t\t} else {\n-\t\t\tif (state->value < y_data[yidx]) {\n-\t\t\t\tstate->value = y_data[yidx];\n-\t\t\t\tstate->arg = x_data[xidx];\n-\t\t\t}\n+\t\t\ttarget[idx] = StringVector::AddStringOrBlob(result, state->arg);\n \t\t}\n \t}\n+};\n \n-\ttemplate <class STATE, class OP>\n-\tstatic void Combine(const STATE &source, STATE *target) {\n-\t\tif (!source.is_initialized) {\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!target->is_initialized) {\n-\t\t\ttarget->is_initialized = true;\n-\t\t\ttarget->value = source.value;\n-\t\t\ttarget->arg = source.arg;\n-\t\t\treturn;\n-\t\t}\n-\t\tif (target->value < source.value) {\n-\t\t\ttarget->value = source.value;\n-\t\t\ttarget->arg = source.arg;\n+template <class COMPARATOR>\n+struct NumericArgMinMax : public ArgMinMaxBase<COMPARATOR> {\n+\ttemplate <class T, class STATE>\n+\tstatic void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {\n+\t\tif (!state->is_initialized) {\n+\t\t\tmask.SetInvalid(idx);\n+\t\t} else {\n+\t\t\ttarget[idx] = state->arg;\n \t\t}\n \t}\n };\n \n+using NumericArgMinOperation = NumericArgMinMax<LessThan>;\n+using NumericArgMaxOperation = NumericArgMinMax<GreaterThan>;\n+using StringArgMinOperation = StringArgMinMax<LessThan>;\n+using StringArgMaxOperation = StringArgMinMax<GreaterThan>;\n+\n+template <class OP, class T, class T2>\n+AggregateFunction GetArgMinMaxFunctionInternal(const LogicalType &arg_2, const LogicalType &arg) {\n+\tauto function = AggregateFunction::BinaryAggregate<ArgMinMaxState<T, T2>, T, T2, T, OP>(arg, arg_2, arg);\n+\tif (arg.InternalType() == PhysicalType::VARCHAR || arg_2.InternalType() == PhysicalType::VARCHAR) {\n+\t\tfunction.destructor = AggregateFunction::StateDestroy<ArgMinMaxState<T, T2>, OP>;\n+\t}\n+\treturn function;\n+}\n template <class OP, class T>\n-AggregateFunction GetArgMinMaxFunctionArg2(LogicalTypeId arg_2, const LogicalType &arg) {\n-\tswitch (arg_2) {\n-\tcase LogicalTypeId::INTEGER:\n-\t\treturn AggregateFunction::BinaryAggregate<ArgMinMaxState<T, int32_t>, T, int32_t, T, OP>(\n-\t\t    arg, LogicalType::INTEGER, arg);\n-\tcase LogicalTypeId::BIGINT:\n-\t\treturn AggregateFunction::BinaryAggregate<ArgMinMaxState<T, int64_t>, T, int64_t, T, OP>(\n-\t\t    arg, LogicalType::BIGINT, arg);\n-\tcase LogicalTypeId::DOUBLE:\n-\t\treturn AggregateFunction::BinaryAggregate<ArgMinMaxState<T, double>, T, double, T, OP>(arg, LogicalType::DOUBLE,\n-\t\t                                                                                       arg);\n-\tcase LogicalTypeId::VARCHAR:\n-\t\treturn AggregateFunction::BinaryAggregate<ArgMinMaxState<T, string_t>, T, string_t, T, OP>(\n-\t\t    arg, LogicalType::VARCHAR, arg);\n-\tcase LogicalTypeId::DATE:\n-\t\treturn AggregateFunction::BinaryAggregate<ArgMinMaxState<T, date_t>, T, date_t, T, OP>(arg, LogicalType::DATE,\n-\t\t                                                                                       arg);\n-\tcase LogicalTypeId::TIMESTAMP:\n-\t\treturn AggregateFunction::BinaryAggregate<ArgMinMaxState<T, timestamp_t>, T, timestamp_t, T, OP>(\n-\t\t    arg, LogicalType::TIMESTAMP, arg);\n-\tcase LogicalTypeId::TIMESTAMP_TZ:\n-\t\treturn AggregateFunction::BinaryAggregate<ArgMinMaxState<T, timestamp_t>, T, timestamp_t, T, OP>(\n-\t\t    arg, LogicalType::TIMESTAMP_TZ, arg);\n-\tcase LogicalTypeId::BLOB:\n-\t\treturn AggregateFunction::BinaryAggregate<ArgMinMaxState<T, string_t>, T, string_t, T, OP>(\n-\t\t    arg, LogicalType::BLOB, arg);\n+AggregateFunction GetArgMinMaxFunctionArg2(const LogicalType &arg_2, const LogicalType &arg) {\n+\tswitch (arg_2.InternalType()) {\n+\tcase PhysicalType::INT32:\n+\t\treturn GetArgMinMaxFunctionInternal<OP, T, int32_t>(arg_2, arg);\n+\tcase PhysicalType::INT64:\n+\t\treturn GetArgMinMaxFunctionInternal<OP, T, int64_t>(arg_2, arg);\n+\tcase PhysicalType::DOUBLE:\n+\t\treturn GetArgMinMaxFunctionInternal<OP, T, double>(arg_2, arg);\n+\tcase PhysicalType::VARCHAR:\n+\t\treturn GetArgMinMaxFunctionInternal<OP, T, string_t>(arg_2, arg);\n \tdefault:\n \t\tthrow InternalException(\"Unimplemented arg_min/arg_max aggregate\");\n \t}\n }\n \n-template <class OP>\n-void GetArgMinMaxFunction(LogicalTypeId arg_1, AggregateFunctionSet &fun) {\n-\tswitch (arg_1) {\n-\tcase LogicalTypeId::INTEGER:\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::INTEGER, LogicalType::INTEGER));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::BIGINT, LogicalType::INTEGER));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::DOUBLE, LogicalType::INTEGER));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::VARCHAR, LogicalType::INTEGER));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::DATE, LogicalType::INTEGER));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::TIMESTAMP, LogicalType::INTEGER));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::INTEGER));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::BLOB, LogicalType::INTEGER));\n-\t\tbreak;\n-\tcase LogicalTypeId::BIGINT:\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::INTEGER, LogicalType::BIGINT));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::BIGINT, LogicalType::BIGINT));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::DOUBLE, LogicalType::BIGINT));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::VARCHAR, LogicalType::BIGINT));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::DATE, LogicalType::BIGINT));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::TIMESTAMP, LogicalType::BIGINT));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::BIGINT));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::BLOB, LogicalType::BIGINT));\n-\t\tbreak;\n-\tcase LogicalTypeId::DOUBLE:\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::INTEGER, LogicalType::DOUBLE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::BIGINT, LogicalType::DOUBLE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::DOUBLE, LogicalType::DOUBLE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::VARCHAR, LogicalType::DOUBLE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::DATE, LogicalType::DOUBLE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::TIMESTAMP, LogicalType::DOUBLE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::DOUBLE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::BLOB, LogicalType::DOUBLE));\n-\t\tbreak;\n-\tcase LogicalTypeId::VARCHAR:\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::INTEGER, LogicalType::VARCHAR));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::BIGINT, LogicalType::VARCHAR));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::DOUBLE, LogicalType::VARCHAR));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::VARCHAR, LogicalType::VARCHAR));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::DATE, LogicalType::VARCHAR));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::TIMESTAMP, LogicalType::VARCHAR));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::VARCHAR));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::BLOB, LogicalType::VARCHAR));\n-\t\tbreak;\n-\tcase LogicalTypeId::DATE:\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::INTEGER, LogicalType::DATE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::BIGINT, LogicalType::DATE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::DOUBLE, LogicalType::DATE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::VARCHAR, LogicalType::DATE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::DATE, LogicalType::DATE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::TIMESTAMP, LogicalType::DATE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::DATE));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::BLOB, LogicalType::DATE));\n-\t\tbreak;\n-\tcase LogicalTypeId::TIMESTAMP:\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::INTEGER, LogicalType::TIMESTAMP));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::BIGINT, LogicalType::TIMESTAMP));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::DOUBLE, LogicalType::TIMESTAMP));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::VARCHAR, LogicalType::TIMESTAMP));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::DATE, LogicalType::TIMESTAMP));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::TIMESTAMP, LogicalType::TIMESTAMP));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::TIMESTAMP));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::BLOB, LogicalType::TIMESTAMP));\n-\t\tbreak;\n-\tcase LogicalTypeId::TIMESTAMP_TZ:\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::INTEGER, LogicalType::TIMESTAMP_TZ));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::BIGINT, LogicalType::TIMESTAMP_TZ));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::DOUBLE, LogicalType::TIMESTAMP_TZ));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::VARCHAR, LogicalType::TIMESTAMP_TZ));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::DATE, LogicalType::TIMESTAMP_TZ));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::TIMESTAMP, LogicalType::TIMESTAMP_TZ));\n-\t\tfun.AddFunction(\n-\t\t    GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::TIMESTAMP_TZ));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::BLOB, LogicalType::TIMESTAMP_TZ));\n-\t\tbreak;\n-\tcase LogicalTypeId::BLOB:\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::INTEGER, LogicalType::BLOB));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::BIGINT, LogicalType::BLOB));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::DOUBLE, LogicalType::BLOB));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::VARCHAR, LogicalType::BLOB));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::DATE, LogicalType::BLOB));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::TIMESTAMP, LogicalType::BLOB));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::BLOB));\n-\t\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::BLOB, LogicalType::BLOB));\n-\t\tbreak;\n-\tdefault:\n-\t\tthrow InternalException(\"Unimplemented arg_min/arg_max aggregate\");\n-\t}\n+template <class OP, class T>\n+void AddArgMinMaxFunctionArg2(AggregateFunctionSet &fun, const LogicalType &arg) {\n+\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::INTEGER, arg));\n+\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::BIGINT, arg));\n+\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::DOUBLE, arg));\n+\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::VARCHAR, arg));\n+\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::DATE, arg));\n+\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::TIMESTAMP, arg));\n+\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::TIMESTAMP_TZ, arg));\n+\tfun.AddFunction(GetArgMinMaxFunctionArg2<OP, T>(LogicalType::BLOB, arg));\n+}\n+\n+template <class OP, class STRING_OP>\n+static void AddArgMinMaxFunctions(AggregateFunctionSet &fun) {\n+\tAddArgMinMaxFunctionArg2<OP, int32_t>(fun, LogicalType::INTEGER);\n+\tAddArgMinMaxFunctionArg2<OP, int64_t>(fun, LogicalType::BIGINT);\n+\tAddArgMinMaxFunctionArg2<OP, double>(fun, LogicalType::DOUBLE);\n+\tAddArgMinMaxFunctionArg2<STRING_OP, string_t>(fun, LogicalType::VARCHAR);\n+\tAddArgMinMaxFunctionArg2<OP, date_t>(fun, LogicalType::DATE);\n+\tAddArgMinMaxFunctionArg2<OP, timestamp_t>(fun, LogicalType::TIMESTAMP);\n+\tAddArgMinMaxFunctionArg2<OP, timestamp_t>(fun, LogicalType::TIMESTAMP_TZ);\n+\tAddArgMinMaxFunctionArg2<STRING_OP, string_t>(fun, LogicalType::BLOB);\n }\n+\n void ArgMinFun::RegisterFunction(BuiltinFunctions &set) {\n \tAggregateFunctionSet fun(\"argmin\");\n-\tGetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::INTEGER, fun);\n-\tGetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::BIGINT, fun);\n-\tGetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::DOUBLE, fun);\n-\tGetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::VARCHAR, fun);\n-\tGetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::DATE, fun);\n-\tGetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::TIMESTAMP, fun);\n-\tGetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::TIMESTAMP_TZ, fun);\n-\tGetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::BLOB, fun);\n+\tAddArgMinMaxFunctions<NumericArgMinOperation, StringArgMinOperation>(fun);\n \tset.AddFunction(fun);\n \n \t//! Add min_by alias\n@@ -246,14 +192,7 @@ void ArgMinFun::RegisterFunction(BuiltinFunctions &set) {\n \n void ArgMaxFun::RegisterFunction(BuiltinFunctions &set) {\n \tAggregateFunctionSet fun(\"argmax\");\n-\tGetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::INTEGER, fun);\n-\tGetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::BIGINT, fun);\n-\tGetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::DOUBLE, fun);\n-\tGetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::VARCHAR, fun);\n-\tGetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::DATE, fun);\n-\tGetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::TIMESTAMP, fun);\n-\tGetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::TIMESTAMP_TZ, fun);\n-\tGetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::BLOB, fun);\n+\tAddArgMinMaxFunctions<NumericArgMaxOperation, StringArgMaxOperation>(fun);\n \tset.AddFunction(fun);\n \n \t//! Add max_by alias\n",
  "test_patch": "diff --git a/test/issues/fuzz/argminmax_strings.test b/test/issues/fuzz/argminmax_strings.test\nnew file mode 100644\nindex 000000000000..bb32fdb20f41\n--- /dev/null\n+++ b/test/issues/fuzz/argminmax_strings.test\n@@ -0,0 +1,20 @@\n+# name: test/issues/fuzz/argminmax_strings.test\n+# description: Issue #3373: heap-use-after-free at string_type.hpp:76:10\n+# group: [fuzz]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE i_class_id AS\n+\tSELECT\n+\t\tLIST(i_category_id::integer) AS i_category_id,\n+\t\tLIST(i_category_id::VARCHAR) AS channel,\n+\t\tLIST([i_category_id]) AS sum_sales,\n+\t\tLIST({'a': i_category_id}) AS number_sales\n+\tFROM range(1, 6, 1) t1(i_category_id);\n+\n+query II\n+select argmin(i_category_id,i_category_id), argmax(i_category_id,i_category_id) from i_class_id;\n+----\n+[1, 2, 3, 4, 5]\t[1, 2, 3, 4, 5]\ndiff --git a/test/sql/aggregate/aggregates/test_arg_min_max_strings.test b/test/sql/aggregate/aggregates/test_arg_min_max_strings.test\nnew file mode 100644\nindex 000000000000..d680188a5326\n--- /dev/null\n+++ b/test/sql/aggregate/aggregates/test_arg_min_max_strings.test\n@@ -0,0 +1,70 @@\n+# name: test/sql/aggregate/aggregates/test_arg_min_max_strings.test\n+# description: Test arg_min/arg_max with strings\n+# group: [aggregates]\n+\n+statement ok\n+CREATE TABLE tbl(\n+\t\"DATE\" DATE,\n+\t\"TIMESTAMP\" TIMESTAMP,\n+\t\"INTEGER\" INTEGER,\n+\t\"BIGINT\" BIGINT,\n+\t\"DOUBLE\" DOUBLE,\n+\t\"VARCHAR\" VARCHAR);\n+\n+# fill up the table with some random gunk in the middle\n+statement ok\n+INSERT INTO tbl\n+\tSELECT\n+\t\tDATE '1992-01-02' + INTERVAL ((RANDOM() * 300)::INT) DAYS d,\n+\t\tTIMESTAMP '1992-01-02 23:20:11' + INTERVAL ((RANDOM() * 300)::INT) DAYS + INTERVAL ((RANDOM() * 60 * 60)::INT) SECONDS ts,\n+\t\t50 + (RANDOM() * 6000)::INT i,\n+\t\t10 + (RANDOM() * 899999999)::BIGINT bi,\n+\t\t1 + RANDOM() * 99 dbl,\n+\t\tconcat(chr(98 + (RANDOM() * 24)::INT), chr(98 + (RANDOM() * 24)::INT), chr(98 + (RANDOM() * 24)::INT), chr(98 + (RANDOM() * 24)::INT), repeat(chr(98 + (RANDOM() * 24)::INT), 29)) str\n+\tFROM\n+\t\trange(10000);\n+\n+# insert the min and the max values\n+statement ok\n+INSERT INTO tbl VALUES (\n+\tDATE '1992-01-01',\n+\tTIMESTAMP '1992-01-01 23:20:11',\n+\t42,\n+\t0,\n+\t0.5,\n+\t'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n+)\n+\n+statement ok\n+INSERT INTO tbl VALUES (\n+\tDATE '1993-01-01',\n+\tTIMESTAMP '1993-01-01 23:20:11',\n+\t8400,\n+\t999999999,\n+\t100.5,\n+\t'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'\n+)\n+\n+foreach type DATE TIMESTAMP INTEGER BIGINT VARCHAR\n+\n+query I\n+SELECT arg_min(\"VARCHAR\", \"${type}\") FROM tbl\n+----\n+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+\n+query I\n+SELECT arg_min(\"${type}\", \"VARCHAR\") FROM tbl EXCEPT SELECT MIN(\"${type}\") FROM tbl\n+----\n+\n+query I\n+SELECT arg_max(\"VARCHAR\", \"${type}\") FROM tbl\n+----\n+zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\n+\n+query I\n+SELECT arg_max(\"${type}\", \"VARCHAR\") FROM tbl EXCEPT SELECT MAX(\"${type}\") FROM tbl\n+----\n+\n+endloop\n+\n+\n",
  "problem_statement": "heap-use-after-free at string_type.hpp:76:10\n#### What happens?\r\nheap-use-after-free at string_type.hpp:76:10\r\n\r\n#### To Reproduce\r\n```sql\r\nCREATE TABLE i_class_id AS\r\n\tSELECT\r\n\t\tLIST(i_category_id::integer) AS i_category_id,\r\n\t\tLIST(i_category_id::VARCHAR) AS channel,\r\n\t\tLIST([i_category_id]) AS sum_sales,\r\n\t\tLIST({'a': i_category_id}) AS number_sales\r\n\tFROM range(1, 6, 1) t1(i_category_id)\r\n\r\n;\r\nselect argmin(i_category_id,i_category_id), argmax(i_category_id,i_category_id) from i_class_id;\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: linux\r\n - DuckDB Version: v0.3.3-dev1399 7c5ba6c0e\r\n - DuckDB Client: /usr/local/bin/duckdb\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\r\n#### ASAN detail\r\n```\r\n=================================================================\r\n==5251==ERROR: AddressSanitizer: heap-use-after-free on address 0x6210000d4900 at pc 0x000001a4cc34 bp 0x7ffc892b1bd0 sp 0x7ffc892b1390\r\nREAD of size 15 at 0x6210000d4900 thread T0\r\n    #0 0x1a4cc33 in memcpy (/root/bld_asan_debug/duckdb+0x1a4cc33)\r\n    #1 0x8d94fc1 in void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.tcc:225:6\r\n    #2 0x216e418 in duckdb::string_t::GetString[abi:cxx11]() const /root/duckdb/src/include/duckdb/common/types/string_type.hpp:76:10\r\n    #3 0x2477757 in duckdb::Vector::GetValue(unsigned long) const /root/duckdb/src/common/types/vector.cpp:485:20\r\n    #4 0x1ce3259 in sqlite3_column_has_value(sqlite3_stmt*, int, duckdb::LogicalType, duckdb::Value&) /root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:448:42\r\n    #5 0x1cddb6f in sqlite3_column_text /root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:481:7\r\n    #6 0x1c8f7a4 in exec_prepared_stmt_columnar /root/duckdb/tools/shell/shell.c:12727:24\r\n    #7 0x1c8ad27 in exec_prepared_stmt /root/duckdb/tools/shell/shell.c:12886:5\r\n    #8 0x1b7e8b3 in shell_exec /root/duckdb/tools/shell/shell.c:13204:7\r\n    #9 0x1c9f1d5 in runOneSqlLine /root/duckdb/tools/shell/shell.c:19991:8\r\n    #10 0x1b84691 in process_input /root/duckdb/tools/shell/shell.c:20106:17\r\n    #11 0x1b1c1db in main /root/duckdb/tools/shell/shell.c:20908:12\r\n    #12 0x7f66fe2350b2 in __libc_start_main /build/glibc-sMfBJT/glibc-2.31/csu/../csu/libc-start.c:308:16\r\n    #13 0x1a369fd in _start (/root/bld_asan_debug/duckdb+0x1a369fd)\r\n\r\n0x6210000d4900 is located 0 bytes inside of 4096-byte region [0x6210000d4900,0x6210000d5900)\r\nfreed by thread T0 here:\r\n    #0 0x1ae367d in operator delete[](void*) (/root/bld_asan_debug/duckdb+0x1ae367d)\r\n    #1 0x1d0d7e1 in std::enable_if<is_convertible<char (*) [], char (*) []>::value, void>::type std::default_delete<char []>::operator()<char>(char*) const /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:115:2\r\n    #2 0x1ce570a in std::unique_ptr<char [], std::default_delete<char []> >::~unique_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:559:4\r\n    #3 0x261a3f8 in duckdb::StringHeap::StringChunk::~StringChunk() /root/duckdb/src/include/duckdb/common/types/string_heap.hpp:59:3\r\n    #4 0x2619851 in std::default_delete<duckdb::StringHeap::StringChunk>::operator()(duckdb::StringHeap::StringChunk*) const /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:81:2\r\n    #5 0x2516141 in std::unique_ptr<duckdb::StringHeap::StringChunk, std::default_delete<duckdb::StringHeap::StringChunk> >::~unique_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:292:4\r\n    #6 0x278929c in duckdb::StringHeap::~StringHeap() /root/duckdb/src/include/duckdb/common/types/string_heap.hpp:18:7\r\n    #7 0x25d5781 in duckdb::VectorStringBuffer::~VectorStringBuffer() /root/duckdb/src/include/duckdb/common/types/vector_buffer.hpp:132:7\r\n    #8 0x27660d4 in void __gnu_cxx::new_allocator<duckdb::VectorStringBuffer>::destroy<duckdb::VectorStringBuffer>(duckdb::VectorStringBuffer*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/ext/new_allocator.h:152:10\r\n    #9 0x2765c16 in void std::allocator_traits<std::allocator<duckdb::VectorStringBuffer> >::destroy<duckdb::VectorStringBuffer>(std::allocator<duckdb::VectorStringBuffer>&, duckdb::VectorStringBuffer*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/alloc_traits.h:496:8\r\n    #10 0x2764db5 in std::_Sp_counted_ptr_inplace<duckdb::VectorStringBuffer, std::allocator<duckdb::VectorStringBuffer>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:557:2\r\n    #11 0x1d0a943 in std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:155:6\r\n    #12 0x1d0a5fc in std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:730:11\r\n    #13 0x2282f0c in std::__shared_ptr<duckdb::VectorBuffer, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:1169:31\r\n    #14 0x2282e28 in std::shared_ptr<duckdb::VectorBuffer>::~shared_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr.h:103:11\r\n    #15 0x2282d1c in duckdb::Vector::~Vector() /root/duckdb/src/include/duckdb/common/types/vector.hpp:37:7\r\n    #16 0x263cb50 in void std::_Destroy<duckdb::Vector>(duckdb::Vector*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:98:19\r\n    #17 0x263c97a in void std::_Destroy_aux<false>::__destroy<duckdb::Vector*>(duckdb::Vector*, duckdb::Vector*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:108:6\r\n    #18 0x263c8a4 in void std::_Destroy<duckdb::Vector*>(duckdb::Vector*, duckdb::Vector*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:136:7\r\n    #19 0x263c30c in void std::_Destroy<duckdb::Vector*, duckdb::Vector>(duckdb::Vector*, duckdb::Vector*, std::allocator<duckdb::Vector>&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:206:7\r\n    #20 0x246ee0b in std::vector<duckdb::Vector, std::allocator<duckdb::Vector> >::~vector() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:677:2\r\n    #21 0x246e445 in duckdb::DataChunk::~DataChunk() /root/duckdb/src/common/types/data_chunk.cpp:28:1\r\n    #22 0x1d04271 in std::default_delete<duckdb::DataChunk>::operator()(duckdb::DataChunk*) const /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:81:2\r\n    #23 0x1d030c1 in std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >::~unique_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:292:4\r\n    #24 0x2620900 in void std::_Destroy<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> > >(std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:98:19\r\n    #25 0x262072a in void std::_Destroy_aux<false>::__destroy<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*>(std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*, std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:108:6\r\n    #26 0x2620654 in void std::_Destroy<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*>(std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*, std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:136:7\r\n    #27 0x26200cc in void std::_Destroy<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*, std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> > >(std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*, std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*, std::allocator<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> > >&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:206:7\r\n    #28 0x261f1bb in std::vector<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >, std::allocator<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> > > >::~vector() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:677:2\r\n    #29 0x4a8388c in duckdb::PipelineExecutor::~PipelineExecutor() /root/duckdb/src/include/duckdb/parallel/pipeline_executor.hpp:24:7\r\n\r\npreviously allocated by thread T0 here:\r\n    #0 0x1ae2e2d in operator new[](unsigned long) (/root/bld_asan_debug/duckdb+0x1ae2e2d)\r\n    #1 0x2694422 in duckdb::StringHeap::StringChunk::StringChunk(unsigned long) /root/duckdb/src/include/duckdb/common/types/string_heap.hpp:50:30\r\n    #2 0x25157e1 in std::unique_ptr<duckdb::StringHeap::StringChunk, std::default_delete<duckdb::StringHeap::StringChunk> > duckdb::make_unique<duckdb::StringHeap::StringChunk, unsigned long>(unsigned long&&) /root/duckdb/src/include/duckdb/common/helper.hpp:41:27\r\n    #3 0x2514a06 in duckdb::StringHeap::EmptyString(unsigned long) /root/duckdb/src/common/types/string_heap.cpp:46:20\r\n    #4 0x2513a9b in duckdb::StringHeap::AddBlob(char const*, unsigned long) /root/duckdb/src/common/types/string_heap.cpp:35:23\r\n    #5 0x25c4f36 in duckdb::VectorStringBuffer::AddBlob(duckdb::string_t) /root/duckdb/src/include/duckdb/common/types/vector_buffer.hpp:144:15\r\n    #6 0x25acda2 in duckdb::StringVector::AddStringOrBlob(duckdb::Vector&, duckdb::string_t) /root/duckdb/src/common/types/vector.cpp:1238:23\r\n    #7 0x247c77f in duckdb::Vector::SetValue(unsigned long, duckdb::Value const&) /root/duckdb/src/common/types/vector.cpp:343:31\r\n    #8 0x27cc87b in duckdb::ValueStringCastSwitch(duckdb::Vector&, duckdb::Vector&, unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) /root/duckdb/src/common/vector_operations/vector_cast.cpp:561:12\r\n    #9 0x27a7cf1 in duckdb::ListCastSwitch(duckdb::Vector&, duckdb::Vector&, unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) /root/duckdb/src/common/vector_operations/vector_cast.cpp:604:10\r\n    #10 0x279abc9 in duckdb::VectorOperations::TryCast(duckdb::Vector&, duckdb::Vector&, unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, bool) /root/duckdb/src/common/vector_operations/vector_cast.cpp:857:10\r\n    #11 0x283f77d in duckdb::VectorOperations::Cast(duckdb::Vector&, duckdb::Vector&, unsigned long, bool) /root/duckdb/src/common/vector_operations/vector_cast.cpp:868:2\r\n    #12 0x3a58d51 in duckdb::ExpressionExecutor::Execute(duckdb::BoundCastExpression const&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::Vector&) /root/duckdb/src/execution/expression_executor/execute_cast.cpp:30:3\r\n    #13 0x44b0089 in duckdb::ExpressionExecutor::Execute(duckdb::Expression const&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::Vector&) /root/duckdb/src/execution/expression_executor.cpp:161:3\r\n    #14 0x44ac6d0 in duckdb::ExpressionExecutor::ExecuteExpression(unsigned long, duckdb::Vector&) /root/duckdb/src/execution/expression_executor.cpp:75:2\r\n    #15 0x44ab184 in duckdb::ExpressionExecutor::Execute(duckdb::DataChunk*, duckdb::DataChunk&) /root/duckdb/src/execution/expression_executor.cpp:46:3\r\n    #16 0x413cabc in duckdb::ExpressionExecutor::Execute(duckdb::DataChunk&, duckdb::DataChunk&) /root/duckdb/src/include/duckdb/execution/expression_executor.hpp:32:3\r\n    #17 0xa0d1b06 in duckdb::PhysicalProjection::Execute(duckdb::ExecutionContext&, duckdb::DataChunk&, duckdb::DataChunk&, duckdb::GlobalOperatorState&, duckdb::OperatorState&) const /root/duckdb/src/execution/operator/projection/physical_projection.cpp:29:17\r\n    #18 0x4a5162f in duckdb::PipelineExecutor::Execute(duckdb::DataChunk&, duckdb::DataChunk&, unsigned long) /root/duckdb/src/parallel/pipeline_executor.cpp:275:36\r\n    #19 0x4a4cb75 in duckdb::PipelineExecutor::ExecutePushInternal(duckdb::DataChunk&, unsigned long) /root/duckdb/src/parallel/pipeline_executor.cpp:91:13\r\n    #20 0x4a4bc3d in duckdb::PipelineExecutor::Execute(unsigned long) /root/duckdb/src/parallel/pipeline_executor.cpp:61:17\r\n    #21 0x4b05248 in duckdb::PipelineTask::ExecuteTask(duckdb::TaskExecutionMode) /root/duckdb/src/parallel/pipeline.cpp:42:39\r\n    #22 0x49e9ef1 in duckdb::ExecutorTask::Execute(duckdb::TaskExecutionMode) /root/duckdb/src/parallel/executor_task.cpp:17:10\r\n    #23 0x4a1d9fe in duckdb::Executor::ExecuteTask() /root/duckdb/src/parallel/executor.cpp:350:24\r\n    #24 0x47016f8 in duckdb::ClientContext::ExecuteTaskInternal(duckdb::ClientContextLock&, duckdb::PendingQueryResult&) /root/duckdb/src/main/client_context.cpp:336:41\r\n    #25 0x474ae17 in duckdb::PendingQueryResult::ExecuteTaskInternal(duckdb::ClientContextLock&) /root/duckdb/src/main/pending_query_result.cpp:45:18\r\n    #26 0x4709166 in duckdb::PendingQueryResult::ExecuteInternal(duckdb::ClientContextLock&, bool) /root/duckdb/src/main/pending_query_result.cpp:50:9\r\n    #27 0x470d3e6 in duckdb::PendingQueryResult::Execute(bool) /root/duckdb/src/main/pending_query_result.cpp:62:9\r\n    #28 0x4728e23 in duckdb::PreparedStatement::Execute(std::vector<duckdb::Value, std::allocator<duckdb::Value> >&, bool) /root/duckdb/src/main/prepared_statement.cpp:45:18\r\n    #29 0x1cd6073 in sqlite3_step /root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:221:36\r\n\r\nSUMMARY: AddressSanitizer: heap-use-after-free (/root/bld_asan_debug/duckdb+0x1a4cc33) in memcpy\r\nShadow bytes around the buggy address:\r\n  0x0c42800128d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c42800128e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c42800128f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c4280012900: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c4280012910: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n=>0x0c4280012920:[fd]fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\n  0x0c4280012930: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\n  0x0c4280012940: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\n  0x0c4280012950: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\n  0x0c4280012960: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\n  0x0c4280012970: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07 \r\n  Heap left redzone:       fa\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n  Left alloca redzone:     ca\r\n  Right alloca redzone:    cb\r\n  Shadow gap:              cc\r\n==5251==ABORTING\r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2022-04-05T09:20:45Z"
}