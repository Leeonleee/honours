You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
heap-use-after-free at string_type.hpp:76:10
#### What happens?
heap-use-after-free at string_type.hpp:76:10

#### To Reproduce
```sql
CREATE TABLE i_class_id AS
	SELECT
		LIST(i_category_id::integer) AS i_category_id,
		LIST(i_category_id::VARCHAR) AS channel,
		LIST([i_category_id]) AS sum_sales,
		LIST({'a': i_category_id}) AS number_sales
	FROM range(1, 6, 1) t1(i_category_id)

;
select argmin(i_category_id,i_category_id), argmax(i_category_id,i_category_id) from i_class_id;
```

#### Environment (please complete the following information):
 - OS: linux
 - DuckDB Version: v0.3.3-dev1399 7c5ba6c0e
 - DuckDB Client: /usr/local/bin/duckdb

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

#### ASAN detail
```
=================================================================
==5251==ERROR: AddressSanitizer: heap-use-after-free on address 0x6210000d4900 at pc 0x000001a4cc34 bp 0x7ffc892b1bd0 sp 0x7ffc892b1390
READ of size 15 at 0x6210000d4900 thread T0
    #0 0x1a4cc33 in memcpy (/root/bld_asan_debug/duckdb+0x1a4cc33)
    #1 0x8d94fc1 in void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.tcc:225:6
    #2 0x216e418 in duckdb::string_t::GetString[abi:cxx11]() const /root/duckdb/src/include/duckdb/common/types/string_type.hpp:76:10
    #3 0x2477757 in duckdb::Vector::GetValue(unsigned long) const /root/duckdb/src/common/types/vector.cpp:485:20
    #4 0x1ce3259 in sqlite3_column_has_value(sqlite3_stmt*, int, duckdb::LogicalType, duckdb::Value&) /root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:448:42
    #5 0x1cddb6f in sqlite3_column_text /root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:481:7
    #6 0x1c8f7a4 in exec_prepared_stmt_columnar /root/duckdb/tools/shell/shell.c:12727:24
    #7 0x1c8ad27 in exec_prepared_stmt /root/duckdb/tools/shell/shell.c:12886:5
    #8 0x1b7e8b3 in shell_exec /root/duckdb/tools/shell/shell.c:13204:7
    #9 0x1c9f1d5 in runOneSqlLine /root/duckdb/tools/shell/shell.c:19991:8
    #10 0x1b84691 in process_input /root/duckdb/tools/shell/shell.c:20106:17
    #11 0x1b1c1db in main /root/duckdb/tools/shell/shell.c:20908:12
    #12 0x7f66fe2350b2 in __libc_start_main /build/glibc-sMfBJT/glibc-2.31/csu/../csu/libc-start.c:308:16
    #13 0x1a369fd in _start (/root/bld_asan_debug/duckdb+0x1a369fd)

0x6210000d4900 is located 0 bytes inside of 4096-byte region [0x6210000d4900,0x6210000d5900)
freed by thread T0 here:
    #0 0x1ae367d in operator delete[](void*) (/root/bld_asan_debug/duckdb+0x1ae367d)
    #1 0x1d0d7e1 in std::enable_if<is_convertible<char (*) [], char (*) []>::value, void>::type std::default_delete<char []>::operator()<char>(char*) const /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:115:2
    #2 0x1ce570a in std::unique_ptr<char [], std::default_delete<char []> >::~unique_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:559:4
    #3 0x261a3f8 in duckdb::StringHeap::StringChunk::~StringChunk() /root/duckdb/src/include/duckdb/common/types/string_heap.hpp:59:3
    #4 0x2619851 in std::default_delete<duckdb::StringHeap::StringChunk>::operator()(duckdb::StringHeap::StringChunk*) const /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:81:2
    #5 0x2516141 in std::unique_ptr<duckdb::StringHeap::StringChunk, std::default_delete<duckdb::StringHeap::StringChunk> >::~unique_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:292:4
    #6 0x278929c in duckdb::StringHeap::~StringHeap() /root/duckdb/src/include/duckdb/common/types/string_heap.hpp:18:7
    #7 0x25d5781 in duckdb::VectorStringBuffer::~VectorStringBuffer() /root/duckdb/src/include/duckdb/common/types/vector_buffer.hpp:132:7
    #8 0x27660d4 in void __gnu_cxx::new_allocator<duckdb::VectorStringBuffer>::destroy<duckdb::VectorStringBuffer>(duckdb::VectorStringBuffer*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/ext/new_allocator.h:152:10
    #9 0x2765c16 in void std::allocator_traits<std::allocator<duckdb::VectorStringBuffer> >::destroy<duckdb::VectorStringBuffer>(std::allocator<duckdb::VectorStringBuffer>&, duckdb::VectorStringBuffer*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/alloc_traits.h:496:8
    #10 0x2764db5 in std::_Sp_counted_ptr_inplace<duckdb::VectorStringBuffer, std::allocator<duckdb::VectorStringBuffer>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:557:2
    #11 0x1d0a943 in std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:155:6
    #12 0x1d0a5fc in std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:730:11
    #13 0x2282f0c in std::__shared_ptr<duckdb::VectorBuffer, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr_base.h:1169:31
    #14 0x2282e28 in std::shared_ptr<duckdb::VectorBuffer>::~shared_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/shared_ptr.h:103:11
    #15 0x2282d1c in duckdb::Vector::~Vector() /root/duckdb/src/include/duckdb/common/types/vector.hpp:37:7
    #16 0x263cb50 in void std::_Destroy<duckdb::Vector>(duckdb::Vector*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:98:19
    #17 0x263c97a in void std::_Destroy_aux<false>::__destroy<duckdb::Vector*>(duckdb::Vector*, duckdb::Vector*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:108:6
    #18 0x263c8a4 in void std::_Destroy<duckdb::Vector*>(duckdb::Vector*, duckdb::Vector*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:136:7
    #19 0x263c30c in void std::_Destroy<duckdb::Vector*, duckdb::Vector>(duckdb::Vector*, duckdb::Vector*, std::allocator<duckdb::Vector>&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:206:7
    #20 0x246ee0b in std::vector<duckdb::Vector, std::allocator<duckdb::Vector> >::~vector() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:677:2
    #21 0x246e445 in duckdb::DataChunk::~DataChunk() /root/duckdb/src/common/types/data_chunk.cpp:28:1
    #22 0x1d04271 in std::default_delete<duckdb::DataChunk>::operator()(duckdb::DataChunk*) const /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:81:2
    #23 0x1d030c1 in std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >::~unique_ptr() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/unique_ptr.h:292:4
    #24 0x2620900 in void std::_Destroy<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> > >(std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:98:19
    #25 0x262072a in void std::_Destroy_aux<false>::__destroy<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*>(std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*, std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:108:6
    #26 0x2620654 in void std::_Destroy<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*>(std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*, std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:136:7
    #27 0x26200cc in void std::_Destroy<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*, std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> > >(std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*, std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >*, std::allocator<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> > >&) /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_construct.h:206:7
    #28 0x261f1bb in std::vector<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> >, std::allocator<std::unique_ptr<duckdb::DataChunk, std::default_delete<duckdb::DataChunk> > > >::~vector() /usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:677:2
    #29 0x4a8388c in duckdb::PipelineExecutor::~PipelineExecutor() /root/duckdb/src/include/duckdb/parallel/pipeline_executor.hpp:24:7

previously allocated by thread T0 here:
    #0 0x1ae2e2d in operator new[](unsigned long) (/root/bld_asan_debug/duckdb+0x1ae2e2d)
    #1 0x2694422 in duckdb::StringHeap::StringChunk::StringChunk(unsigned long) /root/duckdb/src/include/duckdb/common/types/string_heap.hpp:50:30
    #2 0x25157e1 in std::unique_ptr<duckdb::StringHeap::StringChunk, std::default_delete<duckdb::StringHeap::StringChunk> > duckdb::make_unique<duckdb::StringHeap::StringChunk, unsigned long>(unsigned long&&) /root/duckdb/src/include/duckdb/common/helper.hpp:41:27
    #3 0x2514a06 in duckdb::StringHeap::EmptyString(unsigned long) /root/duckdb/src/common/types/string_heap.cpp:46:20
    #4 0x2513a9b in duckdb::StringHeap::AddBlob(char const*, unsigned long) /root/duckdb/src/common/types/string_heap.cpp:35:23
    #5 0x25c4f36 in duckdb::VectorStringBuffer::AddBlob(duckdb::string_t) /root/duckdb/src/include/duckdb/common/types/vector_buffer.hpp:144:15
    #6 0x25acda2 in duckdb::StringVector::AddStringOrBlob(duckdb::Vector&, duckdb::string_t) /root/duckdb/src/common/types/vector.cpp:1238:23
    #7 0x247c77f in duckdb::Vector::SetValue(unsigned long, duckdb::Value const&) /root/duckdb/src/common/types/vector.cpp:343:31
    #8 0x27cc87b in duckdb::ValueStringCastSwitch(duckdb::Vector&, duckdb::Vector&, unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) /root/duckdb/src/common/vector_operations/vector_cast.cpp:561:12
    #9 0x27a7cf1 in duckdb::ListCastSwitch(duckdb::Vector&, duckdb::Vector&, unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) /root/duckdb/src/common/vector_operations/vector_cast.cpp:604:10
    #10 0x279abc9 in duckdb::VectorOperations::TryCast(duckdb::Vector&, duckdb::Vector&, unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, bool) /root/duckdb/src/common/vector_operations/vector_cast.cpp:857:10
    #11 0x283f77d in duckdb::VectorOperations::Cast(duckdb::Vector&, duckdb::Vector&, unsigned long, bool) /root/duckdb/src/common/vector_operations/vector_cast.cpp:868:2
    #12 0x3a58d51 in duckdb::ExpressionExecutor::Execute(duckdb::BoundCastExpression const&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::Vector&) /root/duckdb/src/execution/expression_executor/execute_cast.cpp:30:3
    #13 0x44b0089 in duckdb::ExpressionExecutor::Execute(duckdb::Expression const&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::Vector&) /root/duckdb/src/execution/expression_executor.cpp:161:3
    #14 0x44ac6d0 in duckdb::ExpressionExecutor::ExecuteExpression(unsigned long, duckdb::Vector&) /root/duckdb/src/execution/expression_executor.cpp:75:2
    #15 0x44ab184 in duckdb::ExpressionExecutor::Execute(duckdb::DataChunk*, duckdb::DataChunk&) /root/duckdb/src/execution/expression_executor.cpp:46:3
    #16 0x413cabc in duckdb::ExpressionExecutor::Execute(duckdb::DataChunk&, duckdb::DataChunk&) /root/duckdb/src/include/duckdb/execution/expression_executor.hpp:32:3
    #17 0xa0d1b06 in duckdb::PhysicalProjection::Execute(duckdb::ExecutionContext&, duckdb::DataChunk&, duckdb::DataChunk&, duckdb::GlobalOperatorState&, duckdb::OperatorState&) const /root/duckdb/src/execution/operator/projection/physical_projection.cpp:29:17
    #18 0x4a5162f in duckdb::PipelineExecutor::Execute(duckdb::DataChunk&, duckdb::DataChunk&, unsigned long) /root/duckdb/src/parallel/pipeline_executor.cpp:275:36
    #19 0x4a4cb75 in duckdb::PipelineExecutor::ExecutePushInternal(duckdb::DataChunk&, unsigned long) /root/duckdb/src/parallel/pipeline_executor.cpp:91:13
    #20 0x4a4bc3d in duckdb::PipelineExecutor::Execute(unsigned long) /root/duckdb/src/parallel/pipeline_executor.cpp:61:17
    #21 0x4b05248 in duckdb::PipelineTask::ExecuteTask(duckdb::TaskExecutionMode) /root/duckdb/src/parallel/pipeline.cpp:42:39
    #22 0x49e9ef1 in duckdb::ExecutorTask::Execute(duckdb::TaskExecutionMode) /root/duckdb/src/parallel/executor_task.cpp:17:10
    #23 0x4a1d9fe in duckdb::Executor::ExecuteTask() /root/duckdb/src/parallel/executor.cpp:350:24
    #24 0x47016f8 in duckdb::ClientContext::ExecuteTaskInternal(duckdb::ClientContextLock&, duckdb::PendingQueryResult&) /root/duckdb/src/main/client_context.cpp:336:41
    #25 0x474ae17 in duckdb::PendingQueryResult::ExecuteTaskInternal(duckdb::ClientContextLock&) /root/duckdb/src/main/pending_query_result.cpp:45:18
    #26 0x4709166 in duckdb::PendingQueryResult::ExecuteInternal(duckdb::ClientContextLock&, bool) /root/duckdb/src/main/pending_query_result.cpp:50:9
    #27 0x470d3e6 in duckdb::PendingQueryResult::Execute(bool) /root/duckdb/src/main/pending_query_result.cpp:62:9
    #28 0x4728e23 in duckdb::PreparedStatement::Execute(std::vector<duckdb::Value, std::allocator<duckdb::Value> >&, bool) /root/duckdb/src/main/prepared_statement.cpp:45:18
    #29 0x1cd6073 in sqlite3_step /root/duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:221:36

SUMMARY: AddressSanitizer: heap-use-after-free (/root/bld_asan_debug/duckdb+0x1a4cc33) in memcpy
Shadow bytes around the buggy address:
  0x0c42800128d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c42800128e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c42800128f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c4280012900: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c4280012910: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
=>0x0c4280012920:[fd]fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
  0x0c4280012930: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
  0x0c4280012940: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
  0x0c4280012950: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
  0x0c4280012960: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
  0x0c4280012970: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==5251==ABORTING
```


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of src/function/aggregate/distributive/arg_min_max.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/common/vector_operations/vector_operations.hpp"
3: #include "duckdb/function/aggregate/distributive_functions.hpp"
4: #include "duckdb/function/function_set.hpp"
5: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
6: 
7: #include <utility>
8: 
9: namespace duckdb {
10: 
11: template <class T, class T2>
12: struct ArgMinMaxState {
13: 	T arg;
14: 	T2 value;
15: 	bool is_initialized;
16: };
17: 
18: struct ArgMinMaxOperation {
19: 	template <class STATE>
20: 	static void Initialize(STATE *state) {
21: 		state->is_initialized = false;
22: 	}
23: 
24: 	template <class T, class STATE>
25: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
26: 		if (!state->is_initialized) {
27: 			mask.SetInvalid(idx);
28: 		} else {
29: 			target[idx] = state->arg;
30: 		}
31: 	}
32: 
33: 	static bool IgnoreNull() {
34: 		return true;
35: 	}
36: };
37: 
38: struct ArgMinOperation : ArgMinMaxOperation {
39: 	template <class A_TYPE, class B_TYPE, class STATE, class OP>
40: 	static void Operation(STATE *state, FunctionData *bind_data, A_TYPE *x_data, B_TYPE *y_data, ValidityMask &amask,
41: 	                      ValidityMask &bmask, idx_t xidx, idx_t yidx) {
42: 		if (!state->is_initialized) {
43: 			state->value = y_data[yidx];
44: 			state->arg = x_data[xidx];
45: 			state->is_initialized = true;
46: 		} else {
47: 			if (y_data[yidx] < state->value) {
48: 				state->value = y_data[yidx];
49: 				state->arg = x_data[xidx];
50: 			}
51: 		}
52: 	}
53: 
54: 	template <class STATE, class OP>
55: 	static void Combine(const STATE &source, STATE *target) {
56: 		if (!source.is_initialized) {
57: 			return;
58: 		}
59: 		if (!target->is_initialized) {
60: 			target->is_initialized = true;
61: 			target->value = source.value;
62: 			target->arg = source.arg;
63: 			return;
64: 		}
65: 		if (source.value < target->value) {
66: 			target->value = source.value;
67: 			target->arg = source.arg;
68: 		}
69: 	}
70: };
71: 
72: struct ArgMaxOperation : ArgMinMaxOperation {
73: 	template <class A_TYPE, class B_TYPE, class STATE, class OP>
74: 	static void Operation(STATE *state, FunctionData *bind_data, A_TYPE *x_data, B_TYPE *y_data, ValidityMask &amask,
75: 	                      ValidityMask &bmask, idx_t xidx, idx_t yidx) {
76: 		if (!state->is_initialized) {
77: 			state->value = y_data[yidx];
78: 			state->arg = x_data[xidx];
79: 			state->is_initialized = true;
80: 		} else {
81: 			if (state->value < y_data[yidx]) {
82: 				state->value = y_data[yidx];
83: 				state->arg = x_data[xidx];
84: 			}
85: 		}
86: 	}
87: 
88: 	template <class STATE, class OP>
89: 	static void Combine(const STATE &source, STATE *target) {
90: 		if (!source.is_initialized) {
91: 			return;
92: 		}
93: 		if (!target->is_initialized) {
94: 			target->is_initialized = true;
95: 			target->value = source.value;
96: 			target->arg = source.arg;
97: 			return;
98: 		}
99: 		if (target->value < source.value) {
100: 			target->value = source.value;
101: 			target->arg = source.arg;
102: 		}
103: 	}
104: };
105: 
106: template <class OP, class T>
107: AggregateFunction GetArgMinMaxFunctionArg2(LogicalTypeId arg_2, const LogicalType &arg) {
108: 	switch (arg_2) {
109: 	case LogicalTypeId::INTEGER:
110: 		return AggregateFunction::BinaryAggregate<ArgMinMaxState<T, int32_t>, T, int32_t, T, OP>(
111: 		    arg, LogicalType::INTEGER, arg);
112: 	case LogicalTypeId::BIGINT:
113: 		return AggregateFunction::BinaryAggregate<ArgMinMaxState<T, int64_t>, T, int64_t, T, OP>(
114: 		    arg, LogicalType::BIGINT, arg);
115: 	case LogicalTypeId::DOUBLE:
116: 		return AggregateFunction::BinaryAggregate<ArgMinMaxState<T, double>, T, double, T, OP>(arg, LogicalType::DOUBLE,
117: 		                                                                                       arg);
118: 	case LogicalTypeId::VARCHAR:
119: 		return AggregateFunction::BinaryAggregate<ArgMinMaxState<T, string_t>, T, string_t, T, OP>(
120: 		    arg, LogicalType::VARCHAR, arg);
121: 	case LogicalTypeId::DATE:
122: 		return AggregateFunction::BinaryAggregate<ArgMinMaxState<T, date_t>, T, date_t, T, OP>(arg, LogicalType::DATE,
123: 		                                                                                       arg);
124: 	case LogicalTypeId::TIMESTAMP:
125: 		return AggregateFunction::BinaryAggregate<ArgMinMaxState<T, timestamp_t>, T, timestamp_t, T, OP>(
126: 		    arg, LogicalType::TIMESTAMP, arg);
127: 	case LogicalTypeId::TIMESTAMP_TZ:
128: 		return AggregateFunction::BinaryAggregate<ArgMinMaxState<T, timestamp_t>, T, timestamp_t, T, OP>(
129: 		    arg, LogicalType::TIMESTAMP_TZ, arg);
130: 	case LogicalTypeId::BLOB:
131: 		return AggregateFunction::BinaryAggregate<ArgMinMaxState<T, string_t>, T, string_t, T, OP>(
132: 		    arg, LogicalType::BLOB, arg);
133: 	default:
134: 		throw InternalException("Unimplemented arg_min/arg_max aggregate");
135: 	}
136: }
137: 
138: template <class OP>
139: void GetArgMinMaxFunction(LogicalTypeId arg_1, AggregateFunctionSet &fun) {
140: 	switch (arg_1) {
141: 	case LogicalTypeId::INTEGER:
142: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::INTEGER, LogicalType::INTEGER));
143: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::BIGINT, LogicalType::INTEGER));
144: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::DOUBLE, LogicalType::INTEGER));
145: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::VARCHAR, LogicalType::INTEGER));
146: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::DATE, LogicalType::INTEGER));
147: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::TIMESTAMP, LogicalType::INTEGER));
148: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::INTEGER));
149: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int32_t>(LogicalTypeId::BLOB, LogicalType::INTEGER));
150: 		break;
151: 	case LogicalTypeId::BIGINT:
152: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::INTEGER, LogicalType::BIGINT));
153: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::BIGINT, LogicalType::BIGINT));
154: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::DOUBLE, LogicalType::BIGINT));
155: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::VARCHAR, LogicalType::BIGINT));
156: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::DATE, LogicalType::BIGINT));
157: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::TIMESTAMP, LogicalType::BIGINT));
158: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::BIGINT));
159: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, int64_t>(LogicalTypeId::BLOB, LogicalType::BIGINT));
160: 		break;
161: 	case LogicalTypeId::DOUBLE:
162: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::INTEGER, LogicalType::DOUBLE));
163: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::BIGINT, LogicalType::DOUBLE));
164: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::DOUBLE, LogicalType::DOUBLE));
165: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::VARCHAR, LogicalType::DOUBLE));
166: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::DATE, LogicalType::DOUBLE));
167: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::TIMESTAMP, LogicalType::DOUBLE));
168: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::DOUBLE));
169: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, double>(LogicalTypeId::BLOB, LogicalType::DOUBLE));
170: 		break;
171: 	case LogicalTypeId::VARCHAR:
172: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::INTEGER, LogicalType::VARCHAR));
173: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::BIGINT, LogicalType::VARCHAR));
174: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::DOUBLE, LogicalType::VARCHAR));
175: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::VARCHAR, LogicalType::VARCHAR));
176: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::DATE, LogicalType::VARCHAR));
177: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::TIMESTAMP, LogicalType::VARCHAR));
178: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::VARCHAR));
179: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::BLOB, LogicalType::VARCHAR));
180: 		break;
181: 	case LogicalTypeId::DATE:
182: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::INTEGER, LogicalType::DATE));
183: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::BIGINT, LogicalType::DATE));
184: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::DOUBLE, LogicalType::DATE));
185: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::VARCHAR, LogicalType::DATE));
186: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::DATE, LogicalType::DATE));
187: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::TIMESTAMP, LogicalType::DATE));
188: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::DATE));
189: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, date_t>(LogicalTypeId::BLOB, LogicalType::DATE));
190: 		break;
191: 	case LogicalTypeId::TIMESTAMP:
192: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::INTEGER, LogicalType::TIMESTAMP));
193: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::BIGINT, LogicalType::TIMESTAMP));
194: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::DOUBLE, LogicalType::TIMESTAMP));
195: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::VARCHAR, LogicalType::TIMESTAMP));
196: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::DATE, LogicalType::TIMESTAMP));
197: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::TIMESTAMP, LogicalType::TIMESTAMP));
198: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::TIMESTAMP));
199: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::BLOB, LogicalType::TIMESTAMP));
200: 		break;
201: 	case LogicalTypeId::TIMESTAMP_TZ:
202: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::INTEGER, LogicalType::TIMESTAMP_TZ));
203: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::BIGINT, LogicalType::TIMESTAMP_TZ));
204: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::DOUBLE, LogicalType::TIMESTAMP_TZ));
205: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::VARCHAR, LogicalType::TIMESTAMP_TZ));
206: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::DATE, LogicalType::TIMESTAMP_TZ));
207: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::TIMESTAMP, LogicalType::TIMESTAMP_TZ));
208: 		fun.AddFunction(
209: 		    GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::TIMESTAMP_TZ));
210: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, timestamp_t>(LogicalTypeId::BLOB, LogicalType::TIMESTAMP_TZ));
211: 		break;
212: 	case LogicalTypeId::BLOB:
213: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::INTEGER, LogicalType::BLOB));
214: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::BIGINT, LogicalType::BLOB));
215: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::DOUBLE, LogicalType::BLOB));
216: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::VARCHAR, LogicalType::BLOB));
217: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::DATE, LogicalType::BLOB));
218: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::TIMESTAMP, LogicalType::BLOB));
219: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::TIMESTAMP_TZ, LogicalType::BLOB));
220: 		fun.AddFunction(GetArgMinMaxFunctionArg2<OP, string_t>(LogicalTypeId::BLOB, LogicalType::BLOB));
221: 		break;
222: 	default:
223: 		throw InternalException("Unimplemented arg_min/arg_max aggregate");
224: 	}
225: }
226: void ArgMinFun::RegisterFunction(BuiltinFunctions &set) {
227: 	AggregateFunctionSet fun("argmin");
228: 	GetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::INTEGER, fun);
229: 	GetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::BIGINT, fun);
230: 	GetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::DOUBLE, fun);
231: 	GetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::VARCHAR, fun);
232: 	GetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::DATE, fun);
233: 	GetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::TIMESTAMP, fun);
234: 	GetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::TIMESTAMP_TZ, fun);
235: 	GetArgMinMaxFunction<ArgMinOperation>(LogicalTypeId::BLOB, fun);
236: 	set.AddFunction(fun);
237: 
238: 	//! Add min_by alias
239: 	fun.name = "min_by";
240: 	set.AddFunction(fun);
241: 
242: 	//! Add arg_min alias
243: 	fun.name = "arg_min";
244: 	set.AddFunction(fun);
245: }
246: 
247: void ArgMaxFun::RegisterFunction(BuiltinFunctions &set) {
248: 	AggregateFunctionSet fun("argmax");
249: 	GetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::INTEGER, fun);
250: 	GetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::BIGINT, fun);
251: 	GetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::DOUBLE, fun);
252: 	GetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::VARCHAR, fun);
253: 	GetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::DATE, fun);
254: 	GetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::TIMESTAMP, fun);
255: 	GetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::TIMESTAMP_TZ, fun);
256: 	GetArgMinMaxFunction<ArgMaxOperation>(LogicalTypeId::BLOB, fun);
257: 	set.AddFunction(fun);
258: 
259: 	//! Add max_by alias
260: 	fun.name = "max_by";
261: 	set.AddFunction(fun);
262: 
263: 	//! Add arg_max alias
264: 	fun.name = "arg_max";
265: 	set.AddFunction(fun);
266: }
267: 
268: } // namespace duckdb
[end of src/function/aggregate/distributive/arg_min_max.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: