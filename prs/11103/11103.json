{
  "repo": "duckdb/duckdb",
  "pull_number": 11103,
  "instance_id": "duckdb__duckdb-11103",
  "issue_numbers": [
    "10491",
    "10491"
  ],
  "base_commit": "86e38dd7812463c0ba291ce01b125f943fc5a3f2",
  "patch": "diff --git a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\nindex 91476fe021ee..8795ef3af849 100644\n--- a/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/column_alias_binder.hpp\n@@ -21,8 +21,8 @@ class ColumnAliasBinder {\n public:\n \tColumnAliasBinder(BoundSelectNode &node, const case_insensitive_map_t<idx_t> &alias_map);\n \n-\tbool BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth, bool root_expression,\n-\t               BindResult &result);\n+\tbool BindAlias(ExpressionBinder &enclosing_binder, unique_ptr<ParsedExpression> &expr_ptr, idx_t depth,\n+\t               bool root_expression, BindResult &result);\n \n private:\n \tBoundSelectNode &node;\ndiff --git a/src/planner/expression_binder/column_alias_binder.cpp b/src/planner/expression_binder/column_alias_binder.cpp\nindex 6496c919a887..df83dee41496 100644\n--- a/src/planner/expression_binder/column_alias_binder.cpp\n+++ b/src/planner/expression_binder/column_alias_binder.cpp\n@@ -12,16 +12,20 @@ ColumnAliasBinder::ColumnAliasBinder(BoundSelectNode &node, const case_insensiti\n     : node(node), alias_map(alias_map), visited_select_indexes() {\n }\n \n-bool ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, ColumnRefExpression &expr, idx_t depth,\n-                                  bool root_expression, BindResult &result) {\n+bool ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, unique_ptr<ParsedExpression> &expr_ptr,\n+                                  idx_t depth, bool root_expression, BindResult &result) {\n+\n+\tD_ASSERT(expr_ptr->GetExpressionClass() == ExpressionClass::COLUMN_REF);\n+\tauto &expr = expr_ptr->Cast<ColumnRefExpression>();\n+\n+\t// Qualified columns cannot be aliases.\n \tif (expr.IsQualified()) {\n-\t\t// qualified columns cannot be aliases\n \t\treturn false;\n \t}\n \n+\t// We try to find the alias in the alias_map and return false, if no alias exists.\n \tauto alias_entry = alias_map.find(expr.column_names[0]);\n \tif (alias_entry == alias_map.end()) {\n-\t\t// no alias found\n \t\treturn false;\n \t}\n \n@@ -30,13 +34,14 @@ bool ColumnAliasBinder::BindAlias(ExpressionBinder &enclosing_binder, ColumnRefE\n \t\treturn false;\n \t}\n \n-\t// found an alias: bind the alias expression\n-\tauto expression = node.original_expressions[alias_entry->second]->Copy();\n+\t// We found an alias, so we copy the alias expression into this expression.\n+\tauto original_expr = node.original_expressions[alias_entry->second]->Copy();\n+\texpr_ptr = std::move(original_expr);\n \tvisited_select_indexes.insert(alias_entry->second);\n \n-\t// since the alias has been found, pass a depth of 0. See Issue 4978 (#16)\n-\t// ColumnAliasBinders are only in Having, Qualify and Where Binders\n-\tresult = enclosing_binder.BindExpression(expression, depth, root_expression);\n+\t// Since the alias has been found, we pass a depth of 0. See issue 4978 (#16).\n+\t// Only HAVING, QUALIFY, and WHERE binders contain ColumnAliasBinders.\n+\tresult = enclosing_binder.BindExpression(expr_ptr, depth, root_expression);\n \tvisited_select_indexes.erase(alias_entry->second);\n \treturn true;\n }\ndiff --git a/src/planner/expression_binder/having_binder.cpp b/src/planner/expression_binder/having_binder.cpp\nindex 4df16339e354..9cc1e6c26aae 100644\n--- a/src/planner/expression_binder/having_binder.cpp\n+++ b/src/planner/expression_binder/having_binder.cpp\n@@ -16,13 +16,17 @@ HavingBinder::HavingBinder(Binder &binder, ClientContext &context, BoundSelectNo\n }\n \n BindResult HavingBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {\n-\tauto &expr = expr_ptr->Cast<ColumnRefExpression>();\n+\n+\t// Keep the original column name to return a meaningful error message.\n+\tauto column_name = expr_ptr->Cast<ColumnRefExpression>().GetColumnName();\n+\n+\t// Bind the alias.\n \tBindResult alias_result;\n-\tauto found_alias = column_alias_binder.BindAlias(*this, expr, depth, root_expression, alias_result);\n+\tauto found_alias = column_alias_binder.BindAlias(*this, expr_ptr, depth, root_expression, alias_result);\n+\n \tif (found_alias) {\n \t\tif (depth > 0) {\n-\t\t\tthrow BinderException(\"Having clause cannot reference alias \\\"%s\\\" in correlated subquery\",\n-\t\t\t                      expr.GetColumnName());\n+\t\t\tthrow BinderException(\"Having clause cannot reference alias \\\"%s\\\" in correlated subquery\", column_name);\n \t\t}\n \t\treturn alias_result;\n \t}\n@@ -30,20 +34,24 @@ BindResult HavingBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, i\n \tif (aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {\n \t\tif (depth > 0) {\n \t\t\tthrow BinderException(\n-\t\t\t    \"Having clause cannot reference column \\\"%s\\\" in correlated subquery and group by all\",\n-\t\t\t    expr.GetColumnName());\n+\t\t\t    \"Having clause cannot reference column \\\"%s\\\" in correlated subquery and group by all\", column_name);\n \t\t}\n+\n \t\tauto expr = duckdb::BaseSelectBinder::BindExpression(expr_ptr, depth);\n \t\tif (expr.HasError()) {\n \t\t\treturn expr;\n \t\t}\n-\t\tauto group_ref = make_uniq<BoundColumnRefExpression>(\n-\t\t    expr.expression->return_type, ColumnBinding(node.group_index, node.groups.group_expressions.size()));\n+\n+\t\t// Return a GROUP BY column reference expression.\n+\t\tauto return_type = expr.expression->return_type;\n+\t\tauto column_binding = ColumnBinding(node.group_index, node.groups.group_expressions.size());\n+\t\tauto group_ref = make_uniq<BoundColumnRefExpression>(return_type, column_binding);\n \t\tnode.groups.group_expressions.push_back(std::move(expr.expression));\n \t\treturn BindResult(std::move(group_ref));\n \t}\n+\n \treturn BindResult(StringUtil::Format(\n-\t    \"column %s must appear in the GROUP BY clause or be used in an aggregate function\", expr.ToString()));\n+\t    \"column %s must appear in the GROUP BY clause or be used in an aggregate function\", column_name));\n }\n \n BindResult HavingBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {\ndiff --git a/src/planner/expression_binder/qualify_binder.cpp b/src/planner/expression_binder/qualify_binder.cpp\nindex ceaf916a9a8c..7a486cf81f85 100644\n--- a/src/planner/expression_binder/qualify_binder.cpp\n+++ b/src/planner/expression_binder/qualify_binder.cpp\n@@ -16,20 +16,24 @@ QualifyBinder::QualifyBinder(Binder &binder, ClientContext &context, BoundSelect\n }\n \n BindResult QualifyBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {\n-\tauto &expr = expr_ptr->Cast<ColumnRefExpression>();\n+\n \tauto result = duckdb::BaseSelectBinder::BindExpression(expr_ptr, depth);\n \tif (!result.HasError()) {\n \t\treturn result;\n \t}\n \n+\t// Keep the original column reference's string to return a meaningful error message.\n+\tauto expr_string = expr_ptr->Cast<ColumnRefExpression>().ToString();\n+\n+\t// Try to bind as an alias.\n \tBindResult alias_result;\n-\tauto found_alias = column_alias_binder.BindAlias(*this, expr, depth, root_expression, alias_result);\n+\tauto found_alias = column_alias_binder.BindAlias(*this, expr_ptr, depth, root_expression, alias_result);\n \tif (found_alias) {\n \t\treturn alias_result;\n \t}\n \n-\treturn BindResult(StringUtil::Format(\"Referenced column %s not found in FROM clause and can't find in alias map.\",\n-\t                                     expr.ToString()));\n+\treturn BindResult(\n+\t    StringUtil::Format(\"Referenced column %s not found in FROM clause and can't find in alias map.\", expr_string));\n }\n \n BindResult QualifyBinder::BindExpression(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {\ndiff --git a/src/planner/expression_binder/where_binder.cpp b/src/planner/expression_binder/where_binder.cpp\nindex 9c868f671664..92b94cdb96e8 100644\n--- a/src/planner/expression_binder/where_binder.cpp\n+++ b/src/planner/expression_binder/where_binder.cpp\n@@ -10,17 +10,18 @@ WhereBinder::WhereBinder(Binder &binder, ClientContext &context, optional_ptr<Co\n }\n \n BindResult WhereBinder::BindColumnRef(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth, bool root_expression) {\n-\tauto &expr = expr_ptr->Cast<ColumnRefExpression>();\n+\n \tauto result = ExpressionBinder::BindExpression(expr_ptr, depth);\n \tif (!result.HasError() || !column_alias_binder) {\n \t\treturn result;\n \t}\n \n \tBindResult alias_result;\n-\tauto found_alias = column_alias_binder->BindAlias(*this, expr, depth, root_expression, alias_result);\n+\tauto found_alias = column_alias_binder->BindAlias(*this, expr_ptr, depth, root_expression, alias_result);\n \tif (found_alias) {\n \t\treturn alias_result;\n \t}\n+\n \treturn result;\n }\n \n",
  "test_patch": "diff --git a/test/sql/binder/test_alias_map_in_subquery.test b/test/sql/binder/test_alias_map_in_subquery.test\nnew file mode 100644\nindex 000000000000..f6cdf492a745\n--- /dev/null\n+++ b/test/sql/binder/test_alias_map_in_subquery.test\n@@ -0,0 +1,88 @@\n+# name: test/sql/binder/test_alias_map_in_subquery.test\n+# description: Test binding an alias in a subquery\n+# group: [binder]\n+\n+# Simple reproduction.\n+statement ok\n+CREATE OR REPLACE TABLE tbl (example VARCHAR);\n+\n+statement ok\n+INSERT INTO tbl VALUES ('hello');\n+\n+query I\n+SELECT (WITH keys AS (\n+    \t\tSELECT example AS k\n+    \t), nonNull AS (\n+    \t\tSELECT keys.k, example AS v\n+    \t\tFROM keys\n+    \t\tWHERE v IS NOT NULL\n+    \t)\n+    \tSELECT nonNull.v\n+    \tFROM nonNull\n+)\n+FROM tbl;\n+----\n+hello\n+\n+# With the JSON extension and lambdas.\n+require json\n+\n+statement ok\n+CREATE OR REPLACE TABLE testjson (example JSON);\n+\n+statement ok\n+INSERT INTO testjson VALUES ('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }');\n+\n+query I\n+SELECT (WITH keys AS (SELECT unnest(json_keys(example)) AS k), nonNull AS (\n+    \t\tSELECT keys.k, example->keys.k AS v\n+    \t\tFROM keys WHERE v IS NOT NULL\n+    \t)\n+    \tSELECT json_group_object(nonNull.k, nonNull.v)\n+    \tFROM nonNull\n+)\n+FROM testjson;\n+----\n+{\"location\":{\"address\":\"123 Main St\"},\"anotherField\":123,\"yetAnotherField\":\"abc\"}\n+\n+# With a MACRO (issue #10491).\n+statement ok\n+CREATE OR REPLACE MACRO strip_null_value(jsonValue) AS (\n+\tWITH keys AS (SELECT UNNEST(json_keys(jsonValue)) AS k),\n+\t\tnonNull AS (\n+\t\tSELECT keys.k, jsonValue->keys.k AS v\n+\t\tFROM keys WHERE v IS NOT NULL\n+\t)\n+\tSELECT json_group_object(nonNull.k, nonNull.v)\n+\tFROM nonNull\n+);\n+\n+query I\n+SELECT strip_null_value('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }')\n+AS example;\n+----\n+{\"location\":{\"address\":\"123 Main St\"},\"anotherField\":123,\"yetAnotherField\":\"abc\"}\n+\n+# Testing with a table.\n+\n+statement ok\n+CREATE OR REPLACE TABLE testjson (example JSON);\n+\n+statement ok\n+INSERT INTO testjson\n+VALUES ('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }');\n+\n+query I\n+SELECT strip_null_value(example) FROM testjson;\n+----\n+{\"location\":{\"address\":\"123 Main St\"},\"anotherField\":123,\"yetAnotherField\":\"abc\"}\n+\n+# Testing with a CTE.\n+query I\n+WITH x AS (\n+\tSELECT '{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }'\n+\tAS example)\n+SELECT strip_null_value(x.example) AS test\n+FROM x;\n+----\n+{\"location\":{\"address\":\"123 Main St\"},\"anotherField\":123,\"yetAnotherField\":\"abc\"}\n\\ No newline at end of file\n",
  "problem_statement": "[Bug] Binder Error: Referenced column not found in FROM clause when using macro\n### What happens?\n\nI wrote a macro that strips null values from JSON.  It works on a single value, but doesn't when selecting from a source, either a table or CTE.\n\n### To Reproduce\n\n1. Install and load JSON extension.\r\n2. Create the following macro:\r\n\r\n```sql\r\ncreate or replace macro strip_null_value(jsonValue) as (\r\n\twith keys as (\r\n\t\tSELECT unnest(json_keys(jsonValue)) as k\r\n\t)\r\n\t, nonNull as (\r\n\t\tSELECT\r\n\t\t\tkeys.k,\r\n\t\t\tjsonValue->keys.k as v\r\n\t\tfrom keys\r\n\t\twhere v is not null\r\n\t)\r\n\tselect json_group_object(nonNull.k, nonNull.v)\r\n\tfrom nonNull\r\n);\r\n```\r\n\r\n3. Try it out on a single value (will succeed):\r\n\r\n```sql\r\nselect strip_null_value('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }') as example;\r\n```\r\n\r\n4. Try it out on a table (will fail):\r\n\r\n```sql\r\ncreate table testjson (\r\n\texample json\r\n);\r\n\r\ninsert into testjson values ('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }');\r\n\r\nselect strip_null_value(example)\r\nfrom testjson;\r\n```\r\n\r\n5. Try it out on CTE (will fail):\r\n\r\n```sql\r\nwith x as (\r\n\tselect '{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }' as example\r\n)\r\nselect strip_null_value(x.example) as test\r\nfrom x;\r\n```\r\n\r\nBoth fail with some form of this error:\r\n\r\n```\r\nBinder Error: Referenced column \"v\" not found in FROM clause!\r\nCandidate bindings: \"x.example\"\r\n```\r\n\r\nIt's possible that it is misleading as per https://github.com/duckdb/duckdb/issues/10412\r\n\r\n```\r\n\u279c  duckdb-binaries-osx ./duckdb\r\nv0.9.3-dev3887 a8a5a6bcf9\r\nEnter \".help\" for usage hints.\r\nConnected to a transient in-memory database.\r\nUse \".open FILENAME\" to reopen on a persistent database.\r\nD INSTALL json;\r\nD LOAD json;\r\nD create or replace macro strip_null_value(jsonValue) as (\r\n  with keys as (\r\n  SELECT unnest(json_keys(jsonValue)) as k\r\n  )\r\n  , nonNull as (\r\n  SELECT\r\n  keys.k,\r\n  jsonValue->keys.k as v\r\n  from keys\r\n  where v is not null\r\n  )\r\n  select json_group_object(nonNull.k, nonNull.v)\r\n  from nonNull\r\n  );\r\nD select strip_null_value('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }') as example;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                                      example                                      \u2502\r\n\u2502                                       json                                        \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 {\"location\":{\"address\":\"123 Main St\"},\"anotherField\":123,\"yetAnotherField\":\"abc\"} \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD with x as (\r\n  select strip_null_value('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }') as example\r\n  )\r\n  select strip_null_value(x.example) as test\r\n  from x;\r\nError: Binder Error: Referenced column \"v\" not found in FROM clause!\r\nCandidate bindings: \"x.example\"\r\nLINE 7: select strip_null_value(x.example) as test\r\n```\n\n### OS:\n\nmacOS 14.2.1  M1 aarch64\n\n### DuckDB Version:\n\nv0.9.3-dev3887 a8a5a6bcf9\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nNat Elkins\n\n### Affiliation:\n\nKnoetic\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a nightly build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n[Bug] Binder Error: Referenced column not found in FROM clause when using macro\n### What happens?\n\nI wrote a macro that strips null values from JSON.  It works on a single value, but doesn't when selecting from a source, either a table or CTE.\n\n### To Reproduce\n\n1. Install and load JSON extension.\r\n2. Create the following macro:\r\n\r\n```sql\r\ncreate or replace macro strip_null_value(jsonValue) as (\r\n\twith keys as (\r\n\t\tSELECT unnest(json_keys(jsonValue)) as k\r\n\t)\r\n\t, nonNull as (\r\n\t\tSELECT\r\n\t\t\tkeys.k,\r\n\t\t\tjsonValue->keys.k as v\r\n\t\tfrom keys\r\n\t\twhere v is not null\r\n\t)\r\n\tselect json_group_object(nonNull.k, nonNull.v)\r\n\tfrom nonNull\r\n);\r\n```\r\n\r\n3. Try it out on a single value (will succeed):\r\n\r\n```sql\r\nselect strip_null_value('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }') as example;\r\n```\r\n\r\n4. Try it out on a table (will fail):\r\n\r\n```sql\r\ncreate table testjson (\r\n\texample json\r\n);\r\n\r\ninsert into testjson values ('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }');\r\n\r\nselect strip_null_value(example)\r\nfrom testjson;\r\n```\r\n\r\n5. Try it out on CTE (will fail):\r\n\r\n```sql\r\nwith x as (\r\n\tselect '{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }' as example\r\n)\r\nselect strip_null_value(x.example) as test\r\nfrom x;\r\n```\r\n\r\nBoth fail with some form of this error:\r\n\r\n```\r\nBinder Error: Referenced column \"v\" not found in FROM clause!\r\nCandidate bindings: \"x.example\"\r\n```\r\n\r\nIt's possible that it is misleading as per https://github.com/duckdb/duckdb/issues/10412\r\n\r\n```\r\n\u279c  duckdb-binaries-osx ./duckdb\r\nv0.9.3-dev3887 a8a5a6bcf9\r\nEnter \".help\" for usage hints.\r\nConnected to a transient in-memory database.\r\nUse \".open FILENAME\" to reopen on a persistent database.\r\nD INSTALL json;\r\nD LOAD json;\r\nD create or replace macro strip_null_value(jsonValue) as (\r\n  with keys as (\r\n  SELECT unnest(json_keys(jsonValue)) as k\r\n  )\r\n  , nonNull as (\r\n  SELECT\r\n  keys.k,\r\n  jsonValue->keys.k as v\r\n  from keys\r\n  where v is not null\r\n  )\r\n  select json_group_object(nonNull.k, nonNull.v)\r\n  from nonNull\r\n  );\r\nD select strip_null_value('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }') as example;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                                      example                                      \u2502\r\n\u2502                                       json                                        \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 {\"location\":{\"address\":\"123 Main St\"},\"anotherField\":123,\"yetAnotherField\":\"abc\"} \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD with x as (\r\n  select strip_null_value('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }') as example\r\n  )\r\n  select strip_null_value(x.example) as test\r\n  from x;\r\nError: Binder Error: Referenced column \"v\" not found in FROM clause!\r\nCandidate bindings: \"x.example\"\r\nLINE 7: select strip_null_value(x.example) as test\r\n```\n\n### OS:\n\nmacOS 14.2.1  M1 aarch64\n\n### DuckDB Version:\n\nv0.9.3-dev3887 a8a5a6bcf9\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nNat Elkins\n\n### Affiliation:\n\nKnoetic\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a nightly build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "Playing with this, a few other related queries seem off. With duckdb-0.9.3.dev3887-cp37-cp37m-win_amd64.whl\r\n\r\nRemoving the null check gives the error `BinderException: Binder Error: Referenced table \"keys\" not found!`\r\n\r\nErrors seem sensitive to the last select in the CTE. `select 1 FROM nonNull` gives `Binder Error: Referenced column \"v\" not found in FROM clause!`, but just `SELECT 1` gives no error.\r\n\nFor now you can use this workaround:\r\n```sql\r\nCREATE OR REPLACE MACRO strip_null_value(jsonValue) AS (\r\n\tWITH keys AS (\r\n\t\tSELECT unnest(json_keys(jsonValue::JSON)) AS k\r\n\t), nonNull AS (\r\n\t\tSELECT\r\n\t\t\tkeys.k,\r\n\t\t\tjson_extract(jsonValue::JSON, keys.k) AS v\r\n\t\tFROM keys\r\n\t\tWHERE json_extract(jsonValue::JSON, keys.k) IS NOT NULL\r\n\t)\r\n\tSELECT json_group_object(nonNull.k, nonNull.v)\r\n\tFROM nonNull\r\n);\r\n```\nHi @lnkuiper , I think there's a few edge cases not covered by that implementation.  Consider the following:\r\n\r\n```sql\r\nCREATE OR REPLACE MACRO strip_null_value(jsonValue) AS (\r\n\tWITH keys AS (\r\n\t\tSELECT unnest(json_keys(jsonValue::JSON)) AS k\r\n\t), nonNull AS (\r\n\t\tSELECT\r\n\t\t\tkeys.k,\r\n\t\t\tjson_extract(jsonValue::JSON, keys.k) AS v\r\n\t\tFROM keys\r\n\t\tWHERE json_extract(jsonValue::JSON, keys.k) IS NOT NULL\r\n\t)\r\n\tSELECT json_group_object(nonNull.k, nonNull.v)\r\n\tFROM nonNull\r\n);\r\n\r\ncreate or replace table test (\r\n\texample json\r\n);\r\n\r\ninsert into test values\r\n('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }'),\r\n('{ \"test\" : null}'),\r\n('{}'),\r\n(null);\r\n\r\nselect strip_null_value('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }');  -- Returns the correct value\r\nselect strip_null_value('{ \"test\" : null }'); -- Returns '{}' which is correct\r\nselect strip_null_value('{}'); -- Returns '{}' which is correct\r\nselect strip_null_value(null); -- Returns '{}', should be NULL\r\n\r\n-- This will fail with the error:\r\n-- Binder Error: Key and value list sizes don't match\r\nselect strip_null_value(example)\r\nfrom test; \r\n```\r\n\r\nHere's a different implementation that I found to work in all test cases:\r\n\r\n```sql\r\ncreate or replace macro strip_null_value(param) as (\r\n\twith wrapper as (\r\n\t\tselect param as jsonValue\r\n\t)\r\n\tselect  \r\n\t\tcase when exists (select jsonValue from wrapper where jsonValue is null) then null\r\n\t\tWHEN any_value(t.jsonValue) is null then '{}'::json else json_group_object(key,value)::json end\r\n\tfrom (select unnest(json_keys(w.jsonValue)), w.jsonValue from wrapper w) t(key,jsonValue), lateral (select jsonValue->key) t2(value) \r\n\twhere value is not null\r\n);\r\n\r\nselect strip_null_value('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }');  -- Returns the correct value\r\nselect strip_null_value('{ \"test\" : null }'); -- Returns '{}' which is correct\r\nselect strip_null_value('{}'); -- Returns '{}' which is correct\r\nselect strip_null_value(null); -- Returns NULL which is correct\r\n\r\n-- Returns all correct values, see below\r\nselect strip_null_value(example)\r\nfrom test;\r\n```\r\n\r\n![image](https://github.com/duckdb/duckdb/assets/1795462/eca12fe7-68b4-4c9f-a43a-883340029f07)\r\n\r\nAdmittedly the implementation is a bit janky and can probably be improved, but it works as one might expect it to.\r\n\r\nStill, I do think there might be a bug here (unless I'm badly misunderstanding how macros work).\nThere is a bug here indeed. I was hoping the workaround could help you in the meantime.\n\nThe bug is related to the binder, not to macro/json specifically.\nPlaying with this, a few other related queries seem off. With duckdb-0.9.3.dev3887-cp37-cp37m-win_amd64.whl\r\n\r\nRemoving the null check gives the error `BinderException: Binder Error: Referenced table \"keys\" not found!`\r\n\r\nErrors seem sensitive to the last select in the CTE. `select 1 FROM nonNull` gives `Binder Error: Referenced column \"v\" not found in FROM clause!`, but just `SELECT 1` gives no error.\r\n\nFor now you can use this workaround:\r\n```sql\r\nCREATE OR REPLACE MACRO strip_null_value(jsonValue) AS (\r\n\tWITH keys AS (\r\n\t\tSELECT unnest(json_keys(jsonValue::JSON)) AS k\r\n\t), nonNull AS (\r\n\t\tSELECT\r\n\t\t\tkeys.k,\r\n\t\t\tjson_extract(jsonValue::JSON, keys.k) AS v\r\n\t\tFROM keys\r\n\t\tWHERE json_extract(jsonValue::JSON, keys.k) IS NOT NULL\r\n\t)\r\n\tSELECT json_group_object(nonNull.k, nonNull.v)\r\n\tFROM nonNull\r\n);\r\n```\nHi @lnkuiper , I think there's a few edge cases not covered by that implementation.  Consider the following:\r\n\r\n```sql\r\nCREATE OR REPLACE MACRO strip_null_value(jsonValue) AS (\r\n\tWITH keys AS (\r\n\t\tSELECT unnest(json_keys(jsonValue::JSON)) AS k\r\n\t), nonNull AS (\r\n\t\tSELECT\r\n\t\t\tkeys.k,\r\n\t\t\tjson_extract(jsonValue::JSON, keys.k) AS v\r\n\t\tFROM keys\r\n\t\tWHERE json_extract(jsonValue::JSON, keys.k) IS NOT NULL\r\n\t)\r\n\tSELECT json_group_object(nonNull.k, nonNull.v)\r\n\tFROM nonNull\r\n);\r\n\r\ncreate or replace table test (\r\n\texample json\r\n);\r\n\r\ninsert into test values\r\n('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }'),\r\n('{ \"test\" : null}'),\r\n('{}'),\r\n(null);\r\n\r\nselect strip_null_value('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }');  -- Returns the correct value\r\nselect strip_null_value('{ \"test\" : null }'); -- Returns '{}' which is correct\r\nselect strip_null_value('{}'); -- Returns '{}' which is correct\r\nselect strip_null_value(null); -- Returns '{}', should be NULL\r\n\r\n-- This will fail with the error:\r\n-- Binder Error: Key and value list sizes don't match\r\nselect strip_null_value(example)\r\nfrom test; \r\n```\r\n\r\nHere's a different implementation that I found to work in all test cases:\r\n\r\n```sql\r\ncreate or replace macro strip_null_value(param) as (\r\n\twith wrapper as (\r\n\t\tselect param as jsonValue\r\n\t)\r\n\tselect  \r\n\t\tcase when exists (select jsonValue from wrapper where jsonValue is null) then null\r\n\t\tWHEN any_value(t.jsonValue) is null then '{}'::json else json_group_object(key,value)::json end\r\n\tfrom (select unnest(json_keys(w.jsonValue)), w.jsonValue from wrapper w) t(key,jsonValue), lateral (select jsonValue->key) t2(value) \r\n\twhere value is not null\r\n);\r\n\r\nselect strip_null_value('{ \"location\" : { \"address\" : \"123 Main St\" }, \"sampleField\" : null, \"anotherField\" : 123, \"yetAnotherField\" : \"abc\" }');  -- Returns the correct value\r\nselect strip_null_value('{ \"test\" : null }'); -- Returns '{}' which is correct\r\nselect strip_null_value('{}'); -- Returns '{}' which is correct\r\nselect strip_null_value(null); -- Returns NULL which is correct\r\n\r\n-- Returns all correct values, see below\r\nselect strip_null_value(example)\r\nfrom test;\r\n```\r\n\r\n![image](https://github.com/duckdb/duckdb/assets/1795462/eca12fe7-68b4-4c9f-a43a-883340029f07)\r\n\r\nAdmittedly the implementation is a bit janky and can probably be improved, but it works as one might expect it to.\r\n\r\nStill, I do think there might be a bug here (unless I'm badly misunderstanding how macros work).\nThere is a bug here indeed. I was hoping the workaround could help you in the meantime.\n\nThe bug is related to the binder, not to macro/json specifically.",
  "created_at": "2024-03-12T10:39:57Z"
}