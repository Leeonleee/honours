{
  "repo": "duckdb/duckdb",
  "pull_number": 9320,
  "instance_id": "duckdb__duckdb-9320",
  "issue_numbers": [
    "9260"
  ],
  "base_commit": "0ef2a6faa2ec98b92b4c0e28827c193c32121bd1",
  "patch": "diff --git a/extension/icu/icu-timebucket.cpp b/extension/icu/icu-timebucket.cpp\nindex 62bdbc74c474..1d928704660c 100644\n--- a/extension/icu/icu-timebucket.cpp\n+++ b/extension/icu/icu-timebucket.cpp\n@@ -76,24 +76,21 @@ struct ICUTimeBucket : public ICUDateFunc {\n \n \tstatic inline timestamp_t WidthConvertibleToDaysCommon(int32_t bucket_width_days, const timestamp_t ts,\n \t                                                       const timestamp_t origin, icu::Calendar *calendar) {\n-\t\tconst auto trunc_days = TruncationFactory(DatePartSpecifier::DAY);\n \t\tconst auto sub_days = SubtractFactory(DatePartSpecifier::DAY);\n \n-\t\tuint64_t tmp_micros = SetTime(calendar, ts);\n-\t\ttrunc_days(calendar, tmp_micros);\n-\t\ttimestamp_t truncated_ts = GetTimeUnsafe(calendar, tmp_micros);\n-\n-\t\tint64_t ts_days = sub_days(calendar, origin, truncated_ts);\n+\t\tint64_t ts_days = sub_days(calendar, origin, ts);\n \t\tint64_t result_days = (ts_days / bucket_width_days) * bucket_width_days;\n \t\tif (result_days < NumericLimits<int32_t>::Minimum() || result_days > NumericLimits<int32_t>::Maximum()) {\n \t\t\tthrow OutOfRangeException(\"Timestamp out of range\");\n \t\t}\n-\t\tif (ts_days < 0 && ts_days % bucket_width_days != 0) {\n-\t\t\tresult_days =\n-\t\t\t    SubtractOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(result_days, bucket_width_days);\n+\t\ttimestamp_t bucket = Add(calendar, origin, interval_t {0, static_cast<int32_t>(result_days), 0});\n+\t\tif (ts < bucket) {\n+\t\t\tD_ASSERT(ts < origin);\n+\t\t\tbucket = Add(calendar, bucket, interval_t {0, -bucket_width_days, 0});\n+\t\t\tD_ASSERT(ts > bucket);\n \t\t}\n \n-\t\treturn Add(calendar, origin, interval_t {0, static_cast<int32_t>(result_days), 0});\n+\t\treturn bucket;\n \t}\n \n \tstatic inline timestamp_t WidthConvertibleToMonthsCommon(int32_t bucket_width_months, const timestamp_t ts,\n",
  "test_patch": "diff --git a/test/sql/function/timestamp/test_icu_time_bucket_timestamptz.test b/test/sql/function/timestamp/test_icu_time_bucket_timestamptz.test\nindex 2fb9a5ec10f6..8cdfb01e9e24 100644\n--- a/test/sql/function/timestamp/test_icu_time_bucket_timestamptz.test\n+++ b/test/sql/function/timestamp/test_icu_time_bucket_timestamptz.test\n@@ -1213,3 +1213,134 @@ with t2 as (select '2000-10-28 00:00:00'::timestamptz + (n::text || 'hours')::in\n 2000-10-30 17:00:00-08\t2000-10-30 17:00:00-08\n 2000-10-30 20:00:00-08\t2000-10-30 20:00:00-08\n 2000-10-30 23:00:00-08\t2000-10-30 23:00:00-08\n+\n+query I\n+select\n+  time_bucket(interval '1' day, timestamptz '2000-01-03 17:40:00+00', origin)\n+from\n+  generate_series(timestamptz '2000-01-03 00:00:00+00',\n+                  timestamptz '2000-01-04 00:00:00+00',\n+\t\t  interval '1' hour) as t(origin)\n+order by\n+  origin\n+;\n+----\n+2000-01-02 16:00:00-08\n+2000-01-02 17:00:00-08\n+2000-01-02 18:00:00-08\n+2000-01-02 19:00:00-08\n+2000-01-02 20:00:00-08\n+2000-01-02 21:00:00-08\n+2000-01-02 22:00:00-08\n+2000-01-02 23:00:00-08\n+2000-01-03 00:00:00-08\n+2000-01-03 01:00:00-08\n+2000-01-03 02:00:00-08\n+2000-01-03 03:00:00-08\n+2000-01-03 04:00:00-08\n+2000-01-03 05:00:00-08\n+2000-01-03 06:00:00-08\n+2000-01-03 07:00:00-08\n+2000-01-03 08:00:00-08\n+2000-01-03 09:00:00-08\n+2000-01-02 10:00:00-08\n+2000-01-02 11:00:00-08\n+2000-01-02 12:00:00-08\n+2000-01-02 13:00:00-08\n+2000-01-02 14:00:00-08\n+2000-01-02 15:00:00-08\n+2000-01-02 16:00:00-08\n+\n+\n+statement ok\n+set TimeZone='UTC';\n+\n+query I\n+select\n+  time_bucket(interval '1' day, timestamptz '2023-10-07 16:08:09+00', origin)\n+from\n+  generate_series(timestamptz '2001-01-03 00:00:00+00',\n+                  timestamptz '2001-01-04 00:00:00+00',\n+                  interval '1' hour) as t(origin)\n+order by origin\n+;\n+----\n+2023-10-07 00:00:00+00\n+2023-10-07 01:00:00+00\n+2023-10-07 02:00:00+00\n+2023-10-07 03:00:00+00\n+2023-10-07 04:00:00+00\n+2023-10-07 05:00:00+00\n+2023-10-07 06:00:00+00\n+2023-10-07 07:00:00+00\n+2023-10-07 08:00:00+00\n+2023-10-07 09:00:00+00\n+2023-10-07 10:00:00+00\n+2023-10-07 11:00:00+00\n+2023-10-07 12:00:00+00\n+2023-10-07 13:00:00+00\n+2023-10-07 14:00:00+00\n+2023-10-07 15:00:00+00\n+2023-10-07 16:00:00+00\n+2023-10-06 17:00:00+00\n+2023-10-06 18:00:00+00\n+2023-10-06 19:00:00+00\n+2023-10-06 20:00:00+00\n+2023-10-06 21:00:00+00\n+2023-10-06 22:00:00+00\n+2023-10-06 23:00:00+00\n+2023-10-07 00:00:00+00\n+\n+\n+statement ok\n+set TimeZone='America/St_Johns';\n+\n+query I\n+select\n+  time_bucket(interval '1' day, timestamptz '2023-10-07 16:08:09+03', origin)\n+from\n+  generate_series(timestamptz '2001-01-03 00:00:00+05',\n+                  timestamptz '2001-01-04 00:00:00+05',\n+                  interval '1' hour) as t(origin)\n+order by origin\n+;\n+----\n+2023-10-06 16:30:00-02:30\n+2023-10-06 17:30:00-02:30\n+2023-10-06 18:30:00-02:30\n+2023-10-06 19:30:00-02:30\n+2023-10-06 20:30:00-02:30\n+2023-10-06 21:30:00-02:30\n+2023-10-06 22:30:00-02:30\n+2023-10-06 23:30:00-02:30\n+2023-10-07 00:30:00-02:30\n+2023-10-07 01:30:00-02:30\n+2023-10-07 02:30:00-02:30\n+2023-10-07 03:30:00-02:30\n+2023-10-07 04:30:00-02:30\n+2023-10-07 05:30:00-02:30\n+2023-10-07 06:30:00-02:30\n+2023-10-07 07:30:00-02:30\n+2023-10-07 08:30:00-02:30\n+2023-10-07 09:30:00-02:30\n+2023-10-07 10:30:00-02:30\n+2023-10-06 11:30:00-02:30\n+2023-10-06 12:30:00-02:30\n+2023-10-06 13:30:00-02:30\n+2023-10-06 14:30:00-02:30\n+2023-10-06 15:30:00-02:30\n+2023-10-06 16:30:00-02:30\n+\n+query I\n+select\n+  bool_and(\n+    date_part('epoch', time_bucket(interval '3' day, timestamptz '2023-06-07 16:08:09+00', origin))\n+    = date_part('epoch', time_bucket(interval '3' day, timestamp   '2023-06-07 16:08:09', origin at time zone 'UTC'))\n+  )\n+from\n+  generate_series(timestamptz '2023-01-03 00:00:00+05',\n+                  timestamptz '2024-01-04 00:00:00+05',\n+                  interval '7877' minute) as t(origin)\n+;\n+----\n+true\n",
  "problem_statement": "time_bucket selects wrong bin for day intervals with unaligned origins.\n### What happens?\r\n\r\nwhen binning using time_bucket and a day interval the bin is incorrect if the origin is not day aligned. verified that postgresql, when using date_bin, produces the expected result.\r\n\r\n### To Reproduce\r\n\r\nboth columns should be equal -- the tstz is wrong.\r\n```sql\r\nset TimeZone='UTC';\r\nselect\r\n  time_bucket(interval '1' day, timestamptz '2023-10-07 16:08:09+00', origin) tstz,\r\n  time_bucket(interval '1' day, timestamp   '2023-10-07 16:08:09', origin::timestamp) ts\r\nfrom\r\n  generate_series(timestamptz '2001-01-03 00:00:00+00',\r\n                  timestamptz '2001-01-03 01:00:00+00',\r\n                  interval '1' hour) as t(origin)\r\norder by origin\r\n;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502          tstz          \u2502         ts          \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 2023-10-07 00:00:00+00 \u2502 2023-10-07 00:00:00 \u2502\r\n\u2502 2023-10-06 01:00:00+00 \u2502 2023-10-07 01:00:00 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu 22.04.3 LTS x64\r\n\r\n### DuckDB Version:\r\n\r\nv0.9.0 \r\n\r\n### DuckDB Client:\r\n\r\ncli\r\n\r\n### Full Name:\r\n\r\nrob m\r\n\r\n### Affiliation:\r\n\r\nunaffiliated\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Have you tried this with [TimescaleDB](https://docs.timescale.com/api/latest/hyperfunctions/time_bucket/)?\n> Have you tried this with TimescaleDB?\r\n\r\nyes. results from the query are:\r\n```\r\nSET\r\n          tstz          |         ts          \r\n------------------------+---------------------\r\n 2023-10-07 00:00:00+00 | 2023-10-07 00:00:00\r\n 2023-10-07 01:00:00+00 | 2023-10-07 01:00:00\r\n(2 rows)\r\n```\nThanks - installing it was going to take a while...\nwasn't that bad with nix on linux, except for the setting up nix part.\r\n```sh\r\nnix-shell -p 'postgresql_15.withPackages(p: with p; [ timescaledb ])' --run $SHELL\r\n```\r\n```sh\r\ninitdb -D tscale\r\necho \"shared_preload_libraries = 'timescaledb'\" >> tscale/postgresql.conf\r\npg_ctl -D tscale -l logfile start -o \"--listen_addresses=''\" -o \"--unix_socket_directories='$PWD'\"\r\ncreatedb -h $PWD test\r\npsql -h $PWD test <<< \"CREATE EXTENSION timescaledb;\"\r\n\r\n```\nIt looks like there is an unwritten rule in TimescaleDB that the `origin` gets truncated to the day when using day-level intervals. But since the origin here is one hour later, the current code thinks it is in the previous day bin.\nonce the origin gets past hour 16 it will be truncated into the previous day bin too.\r\nchanging the query to show 25 hours from 2001-01-03 -> 2001-01-04.\r\n```sql\r\nset TimeZone='UTC';\r\nselect\r\n  origin,\r\n  time_bucket(interval '1' day, timestamptz '2023-10-07 16:08:09+00', origin) tstz,\r\n  time_bucket(interval '1' day, timestamp   '2023-10-07 16:08:09', origin::timestamp) ts\r\nfrom\r\n  generate_series(timestamptz '2001-01-03 00:00:00+00',\r\n                  timestamptz '2001-01-04 00:00:00+00',\r\n                  interval '1' hour) as t(origin)\r\norder by origin\r\n;\r\n```\r\nresult from timescaledb\r\n```\r\nSET\r\n         origin         |          tstz          |         ts          \r\n------------------------+------------------------+---------------------\r\n 2001-01-03 00:00:00+00 | 2023-10-07 00:00:00+00 | 2023-10-07 00:00:00\r\n 2001-01-03 01:00:00+00 | 2023-10-07 01:00:00+00 | 2023-10-07 01:00:00\r\n 2001-01-03 02:00:00+00 | 2023-10-07 02:00:00+00 | 2023-10-07 02:00:00\r\n 2001-01-03 03:00:00+00 | 2023-10-07 03:00:00+00 | 2023-10-07 03:00:00\r\n 2001-01-03 04:00:00+00 | 2023-10-07 04:00:00+00 | 2023-10-07 04:00:00\r\n 2001-01-03 05:00:00+00 | 2023-10-07 05:00:00+00 | 2023-10-07 05:00:00\r\n 2001-01-03 06:00:00+00 | 2023-10-07 06:00:00+00 | 2023-10-07 06:00:00\r\n 2001-01-03 07:00:00+00 | 2023-10-07 07:00:00+00 | 2023-10-07 07:00:00\r\n 2001-01-03 08:00:00+00 | 2023-10-07 08:00:00+00 | 2023-10-07 08:00:00\r\n 2001-01-03 09:00:00+00 | 2023-10-07 09:00:00+00 | 2023-10-07 09:00:00\r\n 2001-01-03 10:00:00+00 | 2023-10-07 10:00:00+00 | 2023-10-07 10:00:00\r\n 2001-01-03 11:00:00+00 | 2023-10-07 11:00:00+00 | 2023-10-07 11:00:00\r\n 2001-01-03 12:00:00+00 | 2023-10-07 12:00:00+00 | 2023-10-07 12:00:00\r\n 2001-01-03 13:00:00+00 | 2023-10-07 13:00:00+00 | 2023-10-07 13:00:00\r\n 2001-01-03 14:00:00+00 | 2023-10-07 14:00:00+00 | 2023-10-07 14:00:00\r\n 2001-01-03 15:00:00+00 | 2023-10-07 15:00:00+00 | 2023-10-07 15:00:00\r\n 2001-01-03 16:00:00+00 | 2023-10-07 16:00:00+00 | 2023-10-07 16:00:00\r\n 2001-01-03 17:00:00+00 | 2023-10-06 17:00:00+00 | 2023-10-06 17:00:00\r\n 2001-01-03 18:00:00+00 | 2023-10-06 18:00:00+00 | 2023-10-06 18:00:00\r\n 2001-01-03 19:00:00+00 | 2023-10-06 19:00:00+00 | 2023-10-06 19:00:00\r\n 2001-01-03 20:00:00+00 | 2023-10-06 20:00:00+00 | 2023-10-06 20:00:00\r\n 2001-01-03 21:00:00+00 | 2023-10-06 21:00:00+00 | 2023-10-06 21:00:00\r\n 2001-01-03 22:00:00+00 | 2023-10-06 22:00:00+00 | 2023-10-06 22:00:00\r\n 2001-01-03 23:00:00+00 | 2023-10-06 23:00:00+00 | 2023-10-06 23:00:00\r\n 2001-01-04 00:00:00+00 | 2023-10-07 00:00:00+00 | 2023-10-07 00:00:00\r\n(25 rows)\r\n```\nMore precisely, the `origin` and `argument` are both truncated to the `DAY` level, the number of days is computed and then added to the _untruncated_ `origin`.\nThanks - there is still a problem because it doesn't wrap at hour 17.\nActually it's simpler than that - no truncation required. Just subtract the number of days and offset.\nStill having problems with non-GMT time zones. What does\r\n\r\n```sql\r\nset Timezone='America/Los_Angeles';\r\nselect time_bucket('3 days'::interval, '1979-04-09 21:02:05.003003-08'::TIMESTAMPTZ);\r\n```\r\nproduce?\r\n\r\n(I'm on a MacBook in a waiting room, so things are a bit suboptimal...)\n```\r\nSET\r\n      time_bucket       \r\n------------------------\r\n 1979-04-07 16:00:00-08\r\n(1 row)\r\n```\nthis is what i get for `icu-timebucket.cpp:ICUTimeBucket::WidthConvertibleToDaysCommon`\r\n\r\n```c++\r\n    static inline timestamp_t WidthConvertibleToDaysCommon(int32_t bucket_width_days, const timestamp_t ts,\r\n                                                           const timestamp_t origin, icu::Calendar *calendar) {\r\n        const auto sub_days = SubtractFactory(DatePartSpecifier::DAY);\r\n\r\n        int64_t ts_days = sub_days(calendar, origin, ts);\r\n        int64_t result_days = (ts_days / bucket_width_days) * bucket_width_days;\r\n        if (result_days < NumericLimits<int32_t>::Minimum() || result_days > NumericLimits<int32_t>::Maximum()) {\r\n            throw OutOfRangeException(\"Timestamp out of range\");\r\n        }\r\n        timestamp_t result = Add(calendar, origin, interval_t {0, static_cast<int32_t>(result_days), 0});\r\n        if (ts < origin && ts != result) {\r\n            result_days =\r\n                SubtractOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(result_days, bucket_width_days);\r\n            result = Add(calendar, origin, interval_t {0, static_cast<int32_t>(result_days), 0});\r\n        }\r\n    \r\n        return result;\r\n    }\r\n```\nDoes that work for all the cases? It's close to what I was trying. If it works, can you please submit a PR with all your tests? (I didn't write this originally so I'm playing catch up...)\n> Does that work for all the cases? It's close to what I was trying. If it works, can you please submit a PR with all your tests? (I didn't write this originally so I'm playing catch up...)\r\n\r\nit passes all of the tests. will set up a PR.\nThanks - I had a very busy couple of days moving my son into a new apartment on a bank holiday, followed by the 0.9.1 release.",
  "created_at": "2023-10-11T20:52:07Z"
}