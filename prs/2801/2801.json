{
  "repo": "duckdb/duckdb",
  "pull_number": 2801,
  "instance_id": "duckdb__duckdb-2801",
  "issue_numbers": [
    "2687",
    "2687"
  ],
  "base_commit": "a5e6d9bd47f26a85b801ca7d811580c63a27486d",
  "patch": "diff --git a/src/common/types/interval.cpp b/src/common/types/interval.cpp\nindex 77bb846a55e5..5021a157ebfa 100644\n--- a/src/common/types/interval.cpp\n+++ b/src/common/types/interval.cpp\n@@ -476,4 +476,13 @@ dtime_t Interval::Add(dtime_t left, interval_t right, date_t &date) {\n \treturn left;\n }\n \n+timestamp_t Interval::Add(timestamp_t left, interval_t right) {\n+\tdate_t date;\n+\tdtime_t time;\n+\tTimestamp::Convert(left, date, time);\n+\tauto new_date = Interval::Add(date, right);\n+\tauto new_time = Interval::Add(time, right, new_date);\n+\treturn Timestamp::FromDatetime(new_date, new_time);\n+}\n+\n } // namespace duckdb\ndiff --git a/src/function/scalar/list/range.cpp b/src/function/scalar/list/range.cpp\nindex 9af33f1dfa0d..47c36f13be85 100644\n--- a/src/function/scalar/list/range.cpp\n+++ b/src/function/scalar/list/range.cpp\n@@ -5,6 +5,95 @@\n \n namespace duckdb {\n \n+struct NumericRangeInfo {\n+\tusing TYPE = int64_t;\n+\tusing INCREMENT_TYPE = int64_t;\n+\n+\tstatic int64_t DefaultStart() {\n+\t\treturn 0;\n+\t}\n+\tstatic int64_t DefaultIncrement() {\n+\t\treturn 1;\n+\t}\n+\n+\tstatic uint64_t ListLength(int64_t start_value, int64_t end_value, int64_t increment_value, bool inclusive_bound) {\n+\t\tif (increment_value == 0) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tif (start_value > end_value && increment_value > 0) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tif (start_value < end_value && increment_value < 0) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tint64_t total_diff = AbsValue(end_value - start_value);\n+\t\tint64_t increment = AbsValue(increment_value);\n+\t\tint64_t total_values = total_diff / increment;\n+\t\tif (total_diff % increment == 0) {\n+\t\t\tif (inclusive_bound) {\n+\t\t\t\ttotal_values++;\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttotal_values++;\n+\t\t}\n+\t\treturn total_values;\n+\t}\n+\n+\tstatic void Increment(int64_t &input, int64_t increment) {\n+\t\tinput += increment;\n+\t}\n+};\n+struct TimestampRangeInfo {\n+\tusing TYPE = timestamp_t;\n+\tusing INCREMENT_TYPE = interval_t;\n+\n+\tstatic timestamp_t DefaultStart() {\n+\t\tthrow InternalException(\"Default start not implemented for timestamp range\");\n+\t}\n+\tstatic interval_t DefaultIncrement() {\n+\t\tthrow InternalException(\"Default increment not implemented for timestamp range\");\n+\t}\n+\tstatic uint64_t ListLength(timestamp_t start_value, timestamp_t end_value, interval_t increment_value,\n+\t                           bool inclusive_bound) {\n+\t\tbool is_positive = increment_value.months > 0 || increment_value.days > 0 || increment_value.micros > 0;\n+\t\tbool is_negative = increment_value.months < 0 || increment_value.days < 0 || increment_value.micros < 0;\n+\t\tif (!is_negative && !is_positive) {\n+\t\t\t// interval is 0: no result\n+\t\t\treturn 0;\n+\t\t}\n+\t\tif (is_negative && is_positive) {\n+\t\t\t// we don't allow a mix of\n+\t\t\tthrow InvalidInputException(\"Interval with mix of negative/positive entries not supported\");\n+\t\t}\n+\t\tif (start_value > end_value && is_positive) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tif (start_value < end_value && is_negative) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tint64_t total_values = 0;\n+\t\tif (is_negative) {\n+\t\t\t// negative interval, start_value is going down\n+\t\t\twhile (inclusive_bound ? start_value >= end_value : start_value > end_value) {\n+\t\t\t\tstart_value = Interval::Add(start_value, increment_value);\n+\t\t\t\ttotal_values++;\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// positive interval, start_value is going up\n+\t\t\twhile (inclusive_bound ? start_value <= end_value : start_value < end_value) {\n+\t\t\t\tstart_value = Interval::Add(start_value, increment_value);\n+\t\t\t\ttotal_values++;\n+\t\t\t}\n+\t\t}\n+\t\treturn total_values;\n+\t}\n+\n+\tstatic void Increment(timestamp_t &input, interval_t increment) {\n+\t\tinput = Interval::Add(input, increment);\n+\t}\n+};\n+\n+template <class OP, bool INCLUSIVE_BOUND>\n class RangeInfoStruct {\n public:\n \texplicit RangeInfoStruct(DataChunk &args_p) : args(args_p) {\n@@ -36,64 +125,46 @@ class RangeInfoStruct {\n \t\treturn true;\n \t}\n \n-\tint64_t StartListValue(idx_t row_idx) {\n+\ttypename OP::TYPE StartListValue(idx_t row_idx) {\n \t\tif (args.ColumnCount() == 1) {\n-\t\t\treturn 0;\n+\t\t\treturn OP::DefaultStart();\n \t\t} else {\n-\t\t\tauto data = (int64_t *)vdata[0].data;\n+\t\t\tauto data = (typename OP::TYPE *)vdata[0].data;\n \t\t\tauto idx = vdata[0].sel->get_index(row_idx);\n \t\t\treturn data[idx];\n \t\t}\n \t}\n \n-\tint64_t EndListValue(idx_t row_idx) {\n+\ttypename OP::TYPE EndListValue(idx_t row_idx) {\n \t\tidx_t vdata_idx = args.ColumnCount() == 1 ? 0 : 1;\n-\t\tauto data = (int64_t *)vdata[vdata_idx].data;\n+\t\tauto data = (typename OP::TYPE *)vdata[vdata_idx].data;\n \t\tauto idx = vdata[vdata_idx].sel->get_index(row_idx);\n \t\treturn data[idx];\n \t}\n \n-\tint64_t ListIncrementValue(idx_t row_idx) {\n+\ttypename OP::INCREMENT_TYPE ListIncrementValue(idx_t row_idx) {\n \t\tif (args.ColumnCount() < 3) {\n-\t\t\treturn 1;\n+\t\t\treturn OP::DefaultIncrement();\n \t\t} else {\n-\t\t\tauto data = (int64_t *)vdata[2].data;\n+\t\t\tauto data = (typename OP::INCREMENT_TYPE *)vdata[2].data;\n \t\t\tauto idx = vdata[2].sel->get_index(row_idx);\n \t\t\treturn data[idx];\n \t\t}\n \t}\n \n-\tvoid GetListValues(idx_t row_idx, int64_t &start_value, int64_t &end_value, int64_t &increment_value) {\n+\tvoid GetListValues(idx_t row_idx, typename OP::TYPE &start_value, typename OP::TYPE &end_value,\n+\t                   typename OP::INCREMENT_TYPE &increment_value) {\n \t\tstart_value = StartListValue(row_idx);\n \t\tend_value = EndListValue(row_idx);\n \t\tincrement_value = ListIncrementValue(row_idx);\n \t}\n \n-\tuint64_t ListLength(idx_t row_idx, bool inclusive_bound) {\n-\t\tint64_t start_value;\n-\t\tint64_t end_value;\n-\t\tint64_t increment_value;\n+\tuint64_t ListLength(idx_t row_idx) {\n+\t\ttypename OP::TYPE start_value;\n+\t\ttypename OP::TYPE end_value;\n+\t\ttypename OP::INCREMENT_TYPE increment_value;\n \t\tGetListValues(row_idx, start_value, end_value, increment_value);\n-\t\tif (increment_value == 0) {\n-\t\t\treturn 0;\n-\t\t}\n-\t\tif (start_value > end_value && increment_value > 0) {\n-\t\t\treturn 0;\n-\t\t}\n-\t\tif (start_value < end_value && increment_value < 0) {\n-\t\t\treturn 0;\n-\t\t}\n-\t\tint64_t total_diff = AbsValue(end_value - start_value);\n-\t\tint64_t increment = AbsValue(increment_value);\n-\t\tint64_t total_values = total_diff / increment;\n-\t\tif (total_diff % increment == 0) {\n-\t\t\tif (inclusive_bound) {\n-\t\t\t\ttotal_values++;\n-\t\t\t}\n-\t\t} else {\n-\t\t\ttotal_values++;\n-\t\t}\n-\t\treturn total_values;\n+\t\treturn OP::ListLength(start_value, end_value, increment_value, INCLUSIVE_BOUND);\n \t}\n \n private:\n@@ -101,11 +172,11 @@ class RangeInfoStruct {\n \tVectorData vdata[3];\n };\n \n-template <bool INCLUSIVE_BOUND>\n+template <class OP, bool INCLUSIVE_BOUND>\n static void ListRangeFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tD_ASSERT(result.GetType().id() == LogicalTypeId::LIST);\n \n-\tRangeInfoStruct info(args);\n+\tRangeInfoStruct<OP, INCLUSIVE_BOUND> info(args);\n \tidx_t args_size = 1;\n \tauto result_type = VectorType::CONSTANT_VECTOR;\n \tfor (idx_t i = 0; i < args.ColumnCount(); i++) {\n@@ -125,23 +196,23 @@ static void ListRangeFunction(DataChunk &args, ExpressionState &state, Vector &r\n \t\t\tlist_data[i].length = 0;\n \t\t} else {\n \t\t\tlist_data[i].offset = total_size;\n-\t\t\tlist_data[i].length = info.ListLength(i, INCLUSIVE_BOUND);\n+\t\t\tlist_data[i].length = info.ListLength(i);\n \t\t\ttotal_size += list_data[i].length;\n \t\t}\n \t}\n \n \t// now construct the child vector of the list\n \tListVector::Reserve(result, total_size);\n-\tauto range_data = FlatVector::GetData<int64_t>(ListVector::GetEntry(result));\n+\tauto range_data = FlatVector::GetData<typename OP::TYPE>(ListVector::GetEntry(result));\n \tidx_t total_idx = 0;\n \tfor (idx_t i = 0; i < args_size; i++) {\n-\t\tint64_t start_value = info.StartListValue(i);\n-\t\tint64_t increment = info.ListIncrementValue(i);\n+\t\ttypename OP::TYPE start_value = info.StartListValue(i);\n+\t\ttypename OP::INCREMENT_TYPE increment = info.ListIncrementValue(i);\n \n-\t\tint64_t range_value = start_value;\n+\t\ttypename OP::TYPE range_value = start_value;\n \t\tfor (idx_t range_idx = 0; range_idx < list_data[i].length; range_idx++) {\n \t\t\trange_data[total_idx++] = range_value;\n-\t\t\trange_value += increment;\n+\t\t\tOP::Increment(range_value, increment);\n \t\t}\n \t}\n \n@@ -154,21 +225,31 @@ static void ListRangeFunction(DataChunk &args, ExpressionState &state, Vector &r\n void ListRangeFun::RegisterFunction(BuiltinFunctions &set) {\n \t// the arguments and return types are actually set in the binder function\n \tScalarFunctionSet range_set(\"range\");\n-\trange_set.AddFunction(\n-\t    ScalarFunction({LogicalType::BIGINT}, LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<false>));\n+\trange_set.AddFunction(ScalarFunction({LogicalType::BIGINT}, LogicalType::LIST(LogicalType::BIGINT),\n+\t                                     ListRangeFunction<NumericRangeInfo, false>));\n \trange_set.AddFunction(ScalarFunction({LogicalType::BIGINT, LogicalType::BIGINT},\n-\t                                     LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<false>));\n+\t                                     LogicalType::LIST(LogicalType::BIGINT),\n+\t                                     ListRangeFunction<NumericRangeInfo, false>));\n \trange_set.AddFunction(ScalarFunction({LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT},\n-\t                                     LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<false>));\n+\t                                     LogicalType::LIST(LogicalType::BIGINT),\n+\t                                     ListRangeFunction<NumericRangeInfo, false>));\n+\trange_set.AddFunction(ScalarFunction({LogicalType::TIMESTAMP, LogicalType::TIMESTAMP, LogicalType::INTERVAL},\n+\t                                     LogicalType::LIST(LogicalType::TIMESTAMP),\n+\t                                     ListRangeFunction<TimestampRangeInfo, false>));\n \tset.AddFunction(range_set);\n \n \tScalarFunctionSet generate_series(\"generate_series\");\n-\tgenerate_series.AddFunction(\n-\t    ScalarFunction({LogicalType::BIGINT}, LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<true>));\n+\tgenerate_series.AddFunction(ScalarFunction({LogicalType::BIGINT}, LogicalType::LIST(LogicalType::BIGINT),\n+\t                                           ListRangeFunction<NumericRangeInfo, true>));\n \tgenerate_series.AddFunction(ScalarFunction({LogicalType::BIGINT, LogicalType::BIGINT},\n-\t                                           LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<true>));\n+\t                                           LogicalType::LIST(LogicalType::BIGINT),\n+\t                                           ListRangeFunction<NumericRangeInfo, true>));\n \tgenerate_series.AddFunction(ScalarFunction({LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT},\n-\t                                           LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<true>));\n+\t                                           LogicalType::LIST(LogicalType::BIGINT),\n+\t                                           ListRangeFunction<NumericRangeInfo, true>));\n+\tgenerate_series.AddFunction(ScalarFunction({LogicalType::TIMESTAMP, LogicalType::TIMESTAMP, LogicalType::INTERVAL},\n+\t                                           LogicalType::LIST(LogicalType::TIMESTAMP),\n+\t                                           ListRangeFunction<TimestampRangeInfo, true>));\n \tset.AddFunction(generate_series);\n }\n \ndiff --git a/src/function/scalar/operators/add.cpp b/src/function/scalar/operators/add.cpp\nindex 45c2c978236f..b2c2dc084466 100644\n--- a/src/function/scalar/operators/add.cpp\n+++ b/src/function/scalar/operators/add.cpp\n@@ -68,12 +68,7 @@ date_t AddOperator::Operation(interval_t left, date_t right) {\n \n template <>\n timestamp_t AddOperator::Operation(timestamp_t left, interval_t right) {\n-\tdate_t date;\n-\tdtime_t time;\n-\tTimestamp::Convert(left, date, time);\n-\tauto new_date = Interval::Add(date, right);\n-\tauto new_time = Interval::Add(time, right, new_date);\n-\treturn Timestamp::FromDatetime(new_date, new_time);\n+\treturn Interval::Add(left, right);\n }\n \n template <>\ndiff --git a/src/include/duckdb/common/types/interval.hpp b/src/include/duckdb/common/types/interval.hpp\nindex d52331bb14df..273d7aa368fb 100644\n--- a/src/include/duckdb/common/types/interval.hpp\n+++ b/src/include/duckdb/common/types/interval.hpp\n@@ -77,6 +77,8 @@ class Interval {\n \n \t//! Add an interval to a date\n \tstatic date_t Add(date_t left, interval_t right);\n+\t//! Add an interval to a timestamp\n+\tstatic timestamp_t Add(timestamp_t left, interval_t right);\n \t//! Add an interval to a time. In case the time overflows or underflows, modify the date by the overflow.\n \t//! For example if we go from 23:00 to 02:00, we add a day to the date\n \tstatic dtime_t Add(dtime_t left, interval_t right, date_t &date);\n",
  "test_patch": "diff --git a/test/sql/function/list/generate_series_timestamp.test b/test/sql/function/list/generate_series_timestamp.test\nnew file mode 100644\nindex 000000000000..d5221254879d\n--- /dev/null\n+++ b/test/sql/function/list/generate_series_timestamp.test\n@@ -0,0 +1,76 @@\n+# name: test/sql/function/list/generate_series_timestamp.test\n+# description: Test generate_series/range function\n+# group: [list]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# standard generate_series (inclusive bound)\n+query I\n+SELECT generate_series(timestamp '2020-01-01', timestamp '2020-07-01', interval '3' month);\n+----\n+[2020-01-01 00:00:00, 2020-04-01 00:00:00, 2020-07-01 00:00:00]\n+\n+# exclusive bound\n+query I\n+SELECT range(timestamp '2020-01-01', timestamp '2020-07-01', interval '3' month);\n+----\n+[2020-01-01 00:00:00, 2020-04-01 00:00:00]\n+\n+# negative interval\n+query I\n+SELECT generate_series(timestamp '2020-06-01', timestamp '2020-01-01', -interval '3' month);\n+----\n+[2020-06-01 00:00:00, 2020-03-01 00:00:00]\n+\n+# start = end\n+query I\n+SELECT generate_series(timestamp '2020-01-01', timestamp '2020-01-01', interval '1' day);\n+----\n+[2020-01-01 00:00:00]\n+\n+query I\n+SELECT range(timestamp '2020-01-01', timestamp '2020-01-01', interval '1' day);\n+----\n+[]\n+\n+# positive interval but start > end\n+query I\n+SELECT generate_series(timestamp '2020-06-01', timestamp '2020-01-01', interval '3' month);\n+----\n+[]\n+\n+# negative interval but start < end\n+query I\n+SELECT generate_series(timestamp '2020-01-01', timestamp '2020-06-01', -interval '3' month);\n+----\n+[]\n+\n+# null values\n+query I\n+SELECT generate_series(NULL, timestamp '2020-06-01', -interval '3' month);\n+----\n+NULL\n+\n+query I\n+SELECT generate_series(timestamp '2020-01-01', NULL, -interval '3' month);\n+----\n+NULL\n+\n+query I\n+SELECT generate_series(timestamp '2020-01-01', timestamp '2020-06-01', NULL);\n+----\n+NULL\n+\n+\n+# > vector size\n+query I\n+SELECT count(*) FROM (\n+\tSELECT unnest(generate_series(timestamp '2000-01-01', timestamp '2020-06-01', interval '1' day))\n+);\n+----\n+7458\n+\n+# mixed sign interval not supported\n+statement error\n+SELECT generate_series(timestamp '2020-01-01', timestamp '2020-06-01', interval '3' month - interval '3' day);\n",
  "problem_statement": "Timestamp Sequence Error Contradicts Documentation\n#### What happens?\r\nContrary to what the documentation states, the `range` and `generate_series` functions do not appear to be compatible with the `TIMESTAMP` data type. \r\n\r\n[Documentation](https://duckdb.org/docs/sql/functions/timestamp):\r\n\r\n<html>\r\n<body>\r\n<!--StartFragment-->\r\n\r\nFunction | Description | Example\r\n-- | -- | --\r\ngenerate_series(timestamp,\u00a0timestamp,\u00a0interval) | Generate a table of timestamps in the closed range, stepping by the interval | generate_series(TIMESTAMP '2001-04-10', TIMESTAMP '2001-04-11', INTERVAL 30 MINUTE)\r\nrange(timestamp,\u00a0timestamp,\u00a0interval) | Generate a table of timestamps in the half open range, stepping by the interval | range(TIMESTAMP '2001-04-10', TIMESTAMP '2001-04-11', INTERVAL 30 MINUTE)\r\n\r\n<!--EndFragment-->\r\n</body>\r\n</html>\r\n\r\nResult of query `SELECT generate_series(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`:\r\n\r\n```\r\nRuntimeError: Binder Error: No function matches the given name and argument types 'generate_series(TIMESTAMP, TIMESTAMP, INTERVAL)'. You might need to add explicit type casts.\r\n\tCandidate functions:\r\n\tgenerate_series(BIGINT) -> LIST<BIGINT>\r\n\tgenerate_series(BIGINT, BIGINT) -> LIST<BIGINT>\r\n\tgenerate_series(BIGINT, BIGINT, BIGINT) -> LIST<BIGINT>\r\n\r\nLINE 1: SELECT generate_series(TIMESTAMP '2021-01-01 0...\r\n```\r\n\r\n#### To Reproduce\r\n`SELECT generate_series(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`\r\n`SELECT range(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`\r\n\r\n#### Environment (please complete the following information):\r\n - OS: [Windows 10]\r\n - DuckDB Version: [0.3.2-dev273]\r\n - DuckDB Client: [Python]\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nTimestamp Sequence Error Contradicts Documentation\n#### What happens?\r\nContrary to what the documentation states, the `range` and `generate_series` functions do not appear to be compatible with the `TIMESTAMP` data type. \r\n\r\n[Documentation](https://duckdb.org/docs/sql/functions/timestamp):\r\n\r\n<html>\r\n<body>\r\n<!--StartFragment-->\r\n\r\nFunction | Description | Example\r\n-- | -- | --\r\ngenerate_series(timestamp,\u00a0timestamp,\u00a0interval) | Generate a table of timestamps in the closed range, stepping by the interval | generate_series(TIMESTAMP '2001-04-10', TIMESTAMP '2001-04-11', INTERVAL 30 MINUTE)\r\nrange(timestamp,\u00a0timestamp,\u00a0interval) | Generate a table of timestamps in the half open range, stepping by the interval | range(TIMESTAMP '2001-04-10', TIMESTAMP '2001-04-11', INTERVAL 30 MINUTE)\r\n\r\n<!--EndFragment-->\r\n</body>\r\n</html>\r\n\r\nResult of query `SELECT generate_series(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`:\r\n\r\n```\r\nRuntimeError: Binder Error: No function matches the given name and argument types 'generate_series(TIMESTAMP, TIMESTAMP, INTERVAL)'. You might need to add explicit type casts.\r\n\tCandidate functions:\r\n\tgenerate_series(BIGINT) -> LIST<BIGINT>\r\n\tgenerate_series(BIGINT, BIGINT) -> LIST<BIGINT>\r\n\tgenerate_series(BIGINT, BIGINT, BIGINT) -> LIST<BIGINT>\r\n\r\nLINE 1: SELECT generate_series(TIMESTAMP '2021-01-01 0...\r\n```\r\n\r\n#### To Reproduce\r\n`SELECT generate_series(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`\r\n`SELECT range(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`\r\n\r\n#### Environment (please complete the following information):\r\n - OS: [Windows 10]\r\n - DuckDB Version: [0.3.2-dev273]\r\n - DuckDB Client: [Python]\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "This is a bit confusing since the `range/generate_series` mentioned on that page relate to the table function, e.g.:\r\n\r\n```sql\r\nSELECT * FROM generate_series(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY);\r\n```\r\n\r\nBut indeed the scalar and table functions should have the same semantics.\nAhh now it makes sense.  Thanks for pointing that out!\nThis is a bit confusing since the `range/generate_series` mentioned on that page relate to the table function, e.g.:\r\n\r\n```sql\r\nSELECT * FROM generate_series(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY);\r\n```\r\n\r\nBut indeed the scalar and table functions should have the same semantics.\nAhh now it makes sense.  Thanks for pointing that out!",
  "created_at": "2021-12-16T12:27:42Z"
}