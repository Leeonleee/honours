You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Timestamp Sequence Error Contradicts Documentation
#### What happens?
Contrary to what the documentation states, the `range` and `generate_series` functions do not appear to be compatible with the `TIMESTAMP` data type. 

[Documentation](https://duckdb.org/docs/sql/functions/timestamp):

<html>
<body>
<!--StartFragment-->

Function | Description | Example
-- | -- | --
generate_series(timestamp, timestamp, interval) | Generate a table of timestamps in the closed range, stepping by the interval | generate_series(TIMESTAMP '2001-04-10', TIMESTAMP '2001-04-11', INTERVAL 30 MINUTE)
range(timestamp, timestamp, interval) | Generate a table of timestamps in the half open range, stepping by the interval | range(TIMESTAMP '2001-04-10', TIMESTAMP '2001-04-11', INTERVAL 30 MINUTE)

<!--EndFragment-->
</body>
</html>

Result of query `SELECT generate_series(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`:

```
RuntimeError: Binder Error: No function matches the given name and argument types 'generate_series(TIMESTAMP, TIMESTAMP, INTERVAL)'. You might need to add explicit type casts.
	Candidate functions:
	generate_series(BIGINT) -> LIST<BIGINT>
	generate_series(BIGINT, BIGINT) -> LIST<BIGINT>
	generate_series(BIGINT, BIGINT, BIGINT) -> LIST<BIGINT>

LINE 1: SELECT generate_series(TIMESTAMP '2021-01-01 0...
```

#### To Reproduce
`SELECT generate_series(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`
`SELECT range(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`

#### Environment (please complete the following information):
 - OS: [Windows 10]
 - DuckDB Version: [0.3.2-dev273]
 - DuckDB Client: [Python]

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

Timestamp Sequence Error Contradicts Documentation
#### What happens?
Contrary to what the documentation states, the `range` and `generate_series` functions do not appear to be compatible with the `TIMESTAMP` data type. 

[Documentation](https://duckdb.org/docs/sql/functions/timestamp):

<html>
<body>
<!--StartFragment-->

Function | Description | Example
-- | -- | --
generate_series(timestamp, timestamp, interval) | Generate a table of timestamps in the closed range, stepping by the interval | generate_series(TIMESTAMP '2001-04-10', TIMESTAMP '2001-04-11', INTERVAL 30 MINUTE)
range(timestamp, timestamp, interval) | Generate a table of timestamps in the half open range, stepping by the interval | range(TIMESTAMP '2001-04-10', TIMESTAMP '2001-04-11', INTERVAL 30 MINUTE)

<!--EndFragment-->
</body>
</html>

Result of query `SELECT generate_series(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`:

```
RuntimeError: Binder Error: No function matches the given name and argument types 'generate_series(TIMESTAMP, TIMESTAMP, INTERVAL)'. You might need to add explicit type casts.
	Candidate functions:
	generate_series(BIGINT) -> LIST<BIGINT>
	generate_series(BIGINT, BIGINT) -> LIST<BIGINT>
	generate_series(BIGINT, BIGINT, BIGINT) -> LIST<BIGINT>

LINE 1: SELECT generate_series(TIMESTAMP '2021-01-01 0...
```

#### To Reproduce
`SELECT generate_series(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`
`SELECT range(TIMESTAMP '2021-01-01', TIMESTAMP '2021-11-29', INTERVAL 1 DAY)`

#### Environment (please complete the following information):
 - OS: [Windows 10]
 - DuckDB Version: [0.3.2-dev273]
 - DuckDB Client: [Python]

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/common/types/interval.cpp]
1: #include "duckdb/common/types/interval.hpp"
2: #include "duckdb/common/operator/cast_operators.hpp"
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/enums/date_part_specifier.hpp"
5: #include "duckdb/common/types/date.hpp"
6: #include "duckdb/common/types/timestamp.hpp"
7: #include "duckdb/common/types/time.hpp"
8: #include "duckdb/common/types/cast_helpers.hpp"
9: #include "duckdb/common/operator/add.hpp"
10: #include "duckdb/common/operator/multiply.hpp"
11: #include "duckdb/common/string_util.hpp"
12: 
13: namespace duckdb {
14: 
15: bool Interval::FromString(const string &str, interval_t &result) {
16: 	string error_message;
17: 	return Interval::FromCString(str.c_str(), str.size(), result, &error_message, false);
18: }
19: 
20: template <class T>
21: void IntervalTryAddition(T &target, int64_t input, int64_t multiplier) {
22: 	int64_t addition;
23: 	if (!TryMultiplyOperator::Operation<int64_t, int64_t, int64_t>(input, multiplier, addition)) {
24: 		throw OutOfRangeException("interval value is out of range");
25: 	}
26: 	T addition_base = Cast::Operation<int64_t, T>(addition);
27: 	if (!TryAddOperator::Operation<T, T, T>(target, addition_base, target)) {
28: 		throw OutOfRangeException("interval value is out of range");
29: 	}
30: }
31: 
32: bool Interval::FromCString(const char *str, idx_t len, interval_t &result, string *error_message, bool strict) {
33: 	idx_t pos = 0;
34: 	idx_t start_pos;
35: 	bool negative;
36: 	bool found_any = false;
37: 	int64_t number;
38: 	DatePartSpecifier specifier;
39: 	string specifier_str;
40: 
41: 	result.days = 0;
42: 	result.micros = 0;
43: 	result.months = 0;
44: 
45: 	if (len == 0) {
46: 		return false;
47: 	}
48: 
49: 	switch (str[pos]) {
50: 	case '@':
51: 		pos++;
52: 		goto standard_interval;
53: 	case 'P':
54: 	case 'p':
55: 		pos++;
56: 		goto posix_interval;
57: 	default:
58: 		goto standard_interval;
59: 	}
60: standard_interval:
61: 	// start parsing a standard interval (e.g. 2 years 3 months...)
62: 	for (; pos < len; pos++) {
63: 		char c = str[pos];
64: 		if (c == ' ' || c == '\t' || c == '\n') {
65: 			// skip spaces
66: 			continue;
67: 		} else if (c >= '0' && c <= '9') {
68: 			// start parsing a positive number
69: 			negative = false;
70: 			goto interval_parse_number;
71: 		} else if (c == '-') {
72: 			// negative number
73: 			negative = true;
74: 			pos++;
75: 			goto interval_parse_number;
76: 		} else if (c == 'a' || c == 'A') {
77: 			// parse the word "ago" as the final specifier
78: 			goto interval_parse_ago;
79: 		} else {
80: 			// unrecognized character, expected a number or end of string
81: 			return false;
82: 		}
83: 	}
84: 	goto end_of_string;
85: interval_parse_number:
86: 	start_pos = pos;
87: 	for (; pos < len; pos++) {
88: 		char c = str[pos];
89: 		if (c >= '0' && c <= '9') {
90: 			// the number continues
91: 			continue;
92: 		} else if (c == ':') {
93: 			// colon: we are parsing a time
94: 			goto interval_parse_time;
95: 		} else {
96: 			if (pos == start_pos) {
97: 				return false;
98: 			}
99: 			// finished the number, parse it from the string
100: 			string_t nr_string(str + start_pos, pos - start_pos);
101: 			number = Cast::Operation<string_t, int64_t>(nr_string);
102: 			if (negative) {
103: 				number = -number;
104: 			}
105: 			goto interval_parse_identifier;
106: 		}
107: 	}
108: 	goto end_of_string;
109: interval_parse_time : {
110: 	// parse the remainder of the time as a Time type
111: 	dtime_t time;
112: 	idx_t pos;
113: 	if (!Time::TryConvertTime(str + start_pos, len, pos, time)) {
114: 		return false;
115: 	}
116: 	result.micros += time.micros;
117: 	found_any = true;
118: 	goto end_of_string;
119: }
120: interval_parse_identifier:
121: 	for (; pos < len; pos++) {
122: 		char c = str[pos];
123: 		if (c == ' ' || c == '\t' || c == '\n') {
124: 			// skip spaces at the start
125: 			continue;
126: 		} else {
127: 			break;
128: 		}
129: 	}
130: 	// now parse the identifier
131: 	start_pos = pos;
132: 	for (; pos < len; pos++) {
133: 		char c = str[pos];
134: 		if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
135: 			// keep parsing the string
136: 			continue;
137: 		} else {
138: 			break;
139: 		}
140: 	}
141: 	specifier_str = string(str + start_pos, pos - start_pos);
142: 	if (!TryGetDatePartSpecifier(specifier_str, specifier)) {
143: 		HandleCastError::AssignError(StringUtil::Format("extract specifier \"%s\" not recognized", specifier_str),
144: 		                             error_message);
145: 		return false;
146: 	}
147: 	// add the specifier to the interval
148: 	switch (specifier) {
149: 	case DatePartSpecifier::MILLENNIUM:
150: 		IntervalTryAddition<int32_t>(result.months, number, MONTHS_PER_MILLENIUM);
151: 		break;
152: 	case DatePartSpecifier::CENTURY:
153: 		IntervalTryAddition<int32_t>(result.months, number, MONTHS_PER_CENTURY);
154: 		break;
155: 	case DatePartSpecifier::DECADE:
156: 		IntervalTryAddition<int32_t>(result.months, number, MONTHS_PER_DECADE);
157: 		break;
158: 	case DatePartSpecifier::YEAR:
159: 		IntervalTryAddition<int32_t>(result.months, number, MONTHS_PER_YEAR);
160: 		break;
161: 	case DatePartSpecifier::QUARTER:
162: 		IntervalTryAddition<int32_t>(result.months, number, MONTHS_PER_QUARTER);
163: 		break;
164: 	case DatePartSpecifier::MONTH:
165: 		IntervalTryAddition<int32_t>(result.months, number, 1);
166: 		break;
167: 	case DatePartSpecifier::DAY:
168: 		IntervalTryAddition<int32_t>(result.days, number, 1);
169: 		break;
170: 	case DatePartSpecifier::WEEK:
171: 		IntervalTryAddition<int32_t>(result.days, number, DAYS_PER_WEEK);
172: 		break;
173: 	case DatePartSpecifier::MICROSECONDS:
174: 		IntervalTryAddition<int64_t>(result.micros, number, 1);
175: 		break;
176: 	case DatePartSpecifier::MILLISECONDS:
177: 		IntervalTryAddition<int64_t>(result.micros, number, MICROS_PER_MSEC);
178: 		break;
179: 	case DatePartSpecifier::SECOND:
180: 		IntervalTryAddition<int64_t>(result.micros, number, MICROS_PER_SEC);
181: 		break;
182: 	case DatePartSpecifier::MINUTE:
183: 		IntervalTryAddition<int64_t>(result.micros, number, MICROS_PER_MINUTE);
184: 		break;
185: 	case DatePartSpecifier::HOUR:
186: 		IntervalTryAddition<int64_t>(result.micros, number, MICROS_PER_HOUR);
187: 		break;
188: 	default:
189: 		HandleCastError::AssignError(
190: 		    StringUtil::Format("extract specifier \"%s\" not supported for interval", specifier_str), error_message);
191: 		return false;
192: 	}
193: 	found_any = true;
194: 	goto standard_interval;
195: interval_parse_ago:
196: 	D_ASSERT(str[pos] == 'a' || str[pos] == 'A');
197: 	// parse the "ago" string at the end of the interval
198: 	if (len - pos < 3) {
199: 		return false;
200: 	}
201: 	pos++;
202: 	if (!(str[pos] == 'g' || str[pos] == 'G')) {
203: 		return false;
204: 	}
205: 	pos++;
206: 	if (!(str[pos] == 'o' || str[pos] == 'O')) {
207: 		return false;
208: 	}
209: 	pos++;
210: 	// parse any trailing whitespace
211: 	for (; pos < len; pos++) {
212: 		char c = str[pos];
213: 		if (c == ' ' || c == '\t' || c == '\n') {
214: 			continue;
215: 		} else {
216: 			return false;
217: 		}
218: 	}
219: 	// invert all the values
220: 	result.months = -result.months;
221: 	result.days = -result.days;
222: 	result.micros = -result.micros;
223: 	goto end_of_string;
224: end_of_string:
225: 	if (!found_any) {
226: 		// end of string and no identifiers were found: cannot convert empty interval
227: 		return false;
228: 	}
229: 	return true;
230: posix_interval:
231: 	return false;
232: }
233: 
234: string Interval::ToString(const interval_t &interval) {
235: 	char buffer[70];
236: 	idx_t length = IntervalToStringCast::Format(interval, buffer);
237: 	return string(buffer, length);
238: }
239: 
240: int64_t Interval::GetMilli(const interval_t &val) {
241: 	int64_t milli_month, milli_day, milli;
242: 	if (!TryMultiplyOperator::Operation((int64_t)val.months, Interval::MICROS_PER_MONTH / 1000, milli_month)) {
243: 		throw ConversionException("Could not convert Interval to Milliseconds");
244: 	}
245: 	if (!TryMultiplyOperator::Operation((int64_t)val.days, Interval::MICROS_PER_DAY / 1000, milli_day)) {
246: 		throw ConversionException("Could not convert Interval to Milliseconds");
247: 	}
248: 	milli = val.micros / 1000;
249: 	if (!TryAddOperator::Operation<int64_t, int64_t, int64_t>(milli, milli_month, milli)) {
250: 		throw ConversionException("Could not convert Interval to Milliseconds");
251: 	}
252: 	if (!TryAddOperator::Operation<int64_t, int64_t, int64_t>(milli, milli_day, milli)) {
253: 		throw ConversionException("Could not convert Interval to Milliseconds");
254: 	}
255: 	return milli;
256: }
257: 
258: int64_t Interval::GetMicro(const interval_t &val) {
259: 	int64_t micro_month, micro_day, micro_total;
260: 	micro_total = val.micros;
261: 	if (!TryMultiplyOperator::Operation((int64_t)val.months, MICROS_PER_MONTH, micro_month)) {
262: 		throw ConversionException("Could not convert Month to Microseconds");
263: 	}
264: 	if (!TryMultiplyOperator::Operation((int64_t)val.days, MICROS_PER_DAY, micro_day)) {
265: 		throw ConversionException("Could not convert Day to Microseconds");
266: 	}
267: 	if (!TryAddOperator::Operation<int64_t, int64_t, int64_t>(micro_total, micro_month, micro_total)) {
268: 		throw ConversionException("Could not convert Interval to Microseconds");
269: 	}
270: 	if (!TryAddOperator::Operation<int64_t, int64_t, int64_t>(micro_total, micro_day, micro_total)) {
271: 		throw ConversionException("Could not convert Interval to Microseconds");
272: 	}
273: 
274: 	return micro_total;
275: }
276: 
277: int64_t Interval::GetNanoseconds(const interval_t &val) {
278: 	int64_t nano;
279: 	const auto micro_total = GetMicro(val);
280: 	if (!TryMultiplyOperator::Operation(micro_total, NANOS_PER_MICRO, nano)) {
281: 		throw ConversionException("Could not convert Interval to Nanoseconds");
282: 	}
283: 
284: 	return nano;
285: }
286: 
287: interval_t Interval::GetAge(timestamp_t timestamp_1, timestamp_t timestamp_2) {
288: 	date_t date1, date2;
289: 	dtime_t time1, time2;
290: 
291: 	Timestamp::Convert(timestamp_1, date1, time1);
292: 	Timestamp::Convert(timestamp_2, date2, time2);
293: 
294: 	// and from date extract the years, months and days
295: 	int32_t year1, month1, day1;
296: 	int32_t year2, month2, day2;
297: 	Date::Convert(date1, year1, month1, day1);
298: 	Date::Convert(date2, year2, month2, day2);
299: 	// finally perform the differences
300: 	auto year_diff = year1 - year2;
301: 	auto month_diff = month1 - month2;
302: 	auto day_diff = day1 - day2;
303: 
304: 	// and from time extract hours, minutes, seconds and milliseconds
305: 	int32_t hour1, min1, sec1, micros1;
306: 	int32_t hour2, min2, sec2, micros2;
307: 	Time::Convert(time1, hour1, min1, sec1, micros1);
308: 	Time::Convert(time2, hour2, min2, sec2, micros2);
309: 	// finally perform the differences
310: 	auto hour_diff = hour1 - hour2;
311: 	auto min_diff = min1 - min2;
312: 	auto sec_diff = sec1 - sec2;
313: 	auto micros_diff = micros1 - micros2;
314: 
315: 	// flip sign if necessary
316: 	bool sign_flipped = false;
317: 	if (timestamp_1 < timestamp_2) {
318: 		year_diff = -year_diff;
319: 		month_diff = -month_diff;
320: 		day_diff = -day_diff;
321: 		hour_diff = -hour_diff;
322: 		min_diff = -min_diff;
323: 		sec_diff = -sec_diff;
324: 		micros_diff = -micros_diff;
325: 		sign_flipped = true;
326: 	}
327: 	// now propagate any negative field into the next higher field
328: 	while (micros_diff < 0) {
329: 		micros_diff += MICROS_PER_SEC;
330: 		sec_diff--;
331: 	}
332: 	while (sec_diff < 0) {
333: 		sec_diff += SECS_PER_MINUTE;
334: 		min_diff--;
335: 	}
336: 	while (min_diff < 0) {
337: 		min_diff += MINS_PER_HOUR;
338: 		hour_diff--;
339: 	}
340: 	while (hour_diff < 0) {
341: 		hour_diff += HOURS_PER_DAY;
342: 		day_diff--;
343: 	}
344: 	while (day_diff < 0) {
345: 		if (timestamp_1 < timestamp_2) {
346: 			day_diff += Date::IsLeapYear(year1) ? Date::LEAP_DAYS[month1] : Date::NORMAL_DAYS[month1];
347: 			month_diff--;
348: 		} else {
349: 			day_diff += Date::IsLeapYear(year2) ? Date::LEAP_DAYS[month2] : Date::NORMAL_DAYS[month2];
350: 			month_diff--;
351: 		}
352: 	}
353: 	while (month_diff < 0) {
354: 		month_diff += MONTHS_PER_YEAR;
355: 		year_diff--;
356: 	}
357: 
358: 	// recover sign if necessary
359: 	if (sign_flipped) {
360: 		year_diff = -year_diff;
361: 		month_diff = -month_diff;
362: 		day_diff = -day_diff;
363: 		hour_diff = -hour_diff;
364: 		min_diff = -min_diff;
365: 		sec_diff = -sec_diff;
366: 		micros_diff = -micros_diff;
367: 	}
368: 	interval_t interval;
369: 	interval.months = year_diff * MONTHS_PER_YEAR + month_diff;
370: 	interval.days = day_diff;
371: 	interval.micros = Time::FromTime(hour_diff, min_diff, sec_diff, micros_diff).micros;
372: 
373: 	return interval;
374: }
375: 
376: interval_t Interval::GetDifference(timestamp_t timestamp_1, timestamp_t timestamp_2) {
377: 	const auto us_1 = Timestamp::GetEpochMicroSeconds(timestamp_1);
378: 	const auto us_2 = Timestamp::GetEpochMicroSeconds(timestamp_2);
379: 	const auto delta_us = us_1 - us_2;
380: 	return FromMicro(delta_us);
381: }
382: 
383: interval_t Interval::FromMicro(int64_t delta_us) {
384: 	interval_t result;
385: 	result.months = 0;
386: 	result.days = delta_us / Interval::MICROS_PER_DAY;
387: 	result.micros = delta_us % Interval::MICROS_PER_DAY;
388: 
389: 	return result;
390: }
391: 
392: static void NormalizeIntervalEntries(interval_t input, int64_t &months, int64_t &days, int64_t &micros) {
393: 	int64_t extra_months_d = input.days / Interval::DAYS_PER_MONTH;
394: 	int64_t extra_months_micros = input.micros / Interval::MICROS_PER_MONTH;
395: 	input.days -= extra_months_d * Interval::DAYS_PER_MONTH;
396: 	input.micros -= extra_months_micros * Interval::MICROS_PER_MONTH;
397: 
398: 	int64_t extra_days_micros = input.micros / Interval::MICROS_PER_DAY;
399: 	input.micros -= extra_days_micros * Interval::MICROS_PER_DAY;
400: 
401: 	months = input.months + extra_months_d + extra_months_micros;
402: 	days = input.days + extra_days_micros;
403: 	micros = input.micros;
404: }
405: 
406: bool Interval::Equals(interval_t left, interval_t right) {
407: 	return left.months == right.months && left.days == right.days && left.micros == right.micros;
408: }
409: 
410: bool Interval::GreaterThan(interval_t left, interval_t right) {
411: 	int64_t lmonths, ldays, lmicros;
412: 	int64_t rmonths, rdays, rmicros;
413: 	NormalizeIntervalEntries(left, lmonths, ldays, lmicros);
414: 	NormalizeIntervalEntries(right, rmonths, rdays, rmicros);
415: 
416: 	if (lmonths > rmonths) {
417: 		return true;
418: 	} else if (lmonths < rmonths) {
419: 		return false;
420: 	}
421: 	if (ldays > rdays) {
422: 		return true;
423: 	} else if (ldays < rdays) {
424: 		return false;
425: 	}
426: 	return lmicros > rmicros;
427: }
428: 
429: bool Interval::GreaterThanEquals(interval_t left, interval_t right) {
430: 	return GreaterThan(left, right) || Equals(left, right);
431: }
432: 
433: date_t Interval::Add(date_t left, interval_t right) {
434: 	date_t result;
435: 	if (right.months != 0) {
436: 		int32_t year, month, day;
437: 		Date::Convert(left, year, month, day);
438: 		int32_t year_diff = right.months / Interval::MONTHS_PER_YEAR;
439: 		year += year_diff;
440: 		month += right.months - year_diff * Interval::MONTHS_PER_YEAR;
441: 		if (month > Interval::MONTHS_PER_YEAR) {
442: 			year++;
443: 			month -= Interval::MONTHS_PER_YEAR;
444: 		} else if (month <= 0) {
445: 			year--;
446: 			month += Interval::MONTHS_PER_YEAR;
447: 		}
448: 		day = MinValue<int32_t>(day, Date::MonthDays(year, month));
449: 		result = Date::FromDate(year, month, day);
450: 	} else {
451: 		result = left;
452: 	}
453: 	if (right.days != 0) {
454: 		if (!TryAddOperator::Operation(result.days, right.days, result.days)) {
455: 			throw OutOfRangeException("Date out of range");
456: 		}
457: 	}
458: 	if (right.micros != 0) {
459: 		if (!TryAddOperator::Operation(result.days, int32_t(right.micros / Interval::MICROS_PER_DAY), result.days)) {
460: 			throw OutOfRangeException("Date out of range");
461: 		}
462: 	}
463: 	return result;
464: }
465: 
466: dtime_t Interval::Add(dtime_t left, interval_t right, date_t &date) {
467: 	int64_t diff = right.micros - ((right.micros / Interval::MICROS_PER_DAY) * Interval::MICROS_PER_DAY);
468: 	left += diff;
469: 	if (left.micros >= Interval::MICROS_PER_DAY) {
470: 		left.micros -= Interval::MICROS_PER_DAY;
471: 		date.days++;
472: 	} else if (left.micros < 0) {
473: 		left.micros += Interval::MICROS_PER_DAY;
474: 		date.days--;
475: 	}
476: 	return left;
477: }
478: 
479: } // namespace duckdb
[end of src/common/types/interval.cpp]
[start of src/function/scalar/list/range.cpp]
1: #include "duckdb/planner/expression/bound_function_expression.hpp"
2: #include "duckdb/function/scalar/nested_functions.hpp"
3: #include "duckdb/common/types/data_chunk.hpp"
4: #include "duckdb/common/types/vector.hpp"
5: 
6: namespace duckdb {
7: 
8: class RangeInfoStruct {
9: public:
10: 	explicit RangeInfoStruct(DataChunk &args_p) : args(args_p) {
11: 		switch (args.ColumnCount()) {
12: 		case 1:
13: 			args.data[0].Orrify(args.size(), vdata[0]);
14: 			break;
15: 		case 2:
16: 			args.data[0].Orrify(args.size(), vdata[0]);
17: 			args.data[1].Orrify(args.size(), vdata[1]);
18: 			break;
19: 		case 3:
20: 			args.data[0].Orrify(args.size(), vdata[0]);
21: 			args.data[1].Orrify(args.size(), vdata[1]);
22: 			args.data[2].Orrify(args.size(), vdata[2]);
23: 			break;
24: 		default:
25: 			throw InternalException("Unsupported number of parameters for range");
26: 		}
27: 	}
28: 
29: 	bool RowIsValid(idx_t row_idx) {
30: 		for (idx_t i = 0; i < args.ColumnCount(); i++) {
31: 			auto idx = vdata[i].sel->get_index(row_idx);
32: 			if (!vdata[i].validity.RowIsValid(idx)) {
33: 				return false;
34: 			}
35: 		}
36: 		return true;
37: 	}
38: 
39: 	int64_t StartListValue(idx_t row_idx) {
40: 		if (args.ColumnCount() == 1) {
41: 			return 0;
42: 		} else {
43: 			auto data = (int64_t *)vdata[0].data;
44: 			auto idx = vdata[0].sel->get_index(row_idx);
45: 			return data[idx];
46: 		}
47: 	}
48: 
49: 	int64_t EndListValue(idx_t row_idx) {
50: 		idx_t vdata_idx = args.ColumnCount() == 1 ? 0 : 1;
51: 		auto data = (int64_t *)vdata[vdata_idx].data;
52: 		auto idx = vdata[vdata_idx].sel->get_index(row_idx);
53: 		return data[idx];
54: 	}
55: 
56: 	int64_t ListIncrementValue(idx_t row_idx) {
57: 		if (args.ColumnCount() < 3) {
58: 			return 1;
59: 		} else {
60: 			auto data = (int64_t *)vdata[2].data;
61: 			auto idx = vdata[2].sel->get_index(row_idx);
62: 			return data[idx];
63: 		}
64: 	}
65: 
66: 	void GetListValues(idx_t row_idx, int64_t &start_value, int64_t &end_value, int64_t &increment_value) {
67: 		start_value = StartListValue(row_idx);
68: 		end_value = EndListValue(row_idx);
69: 		increment_value = ListIncrementValue(row_idx);
70: 	}
71: 
72: 	uint64_t ListLength(idx_t row_idx, bool inclusive_bound) {
73: 		int64_t start_value;
74: 		int64_t end_value;
75: 		int64_t increment_value;
76: 		GetListValues(row_idx, start_value, end_value, increment_value);
77: 		if (increment_value == 0) {
78: 			return 0;
79: 		}
80: 		if (start_value > end_value && increment_value > 0) {
81: 			return 0;
82: 		}
83: 		if (start_value < end_value && increment_value < 0) {
84: 			return 0;
85: 		}
86: 		int64_t total_diff = AbsValue(end_value - start_value);
87: 		int64_t increment = AbsValue(increment_value);
88: 		int64_t total_values = total_diff / increment;
89: 		if (total_diff % increment == 0) {
90: 			if (inclusive_bound) {
91: 				total_values++;
92: 			}
93: 		} else {
94: 			total_values++;
95: 		}
96: 		return total_values;
97: 	}
98: 
99: private:
100: 	DataChunk &args;
101: 	VectorData vdata[3];
102: };
103: 
104: template <bool INCLUSIVE_BOUND>
105: static void ListRangeFunction(DataChunk &args, ExpressionState &state, Vector &result) {
106: 	D_ASSERT(result.GetType().id() == LogicalTypeId::LIST);
107: 
108: 	RangeInfoStruct info(args);
109: 	idx_t args_size = 1;
110: 	auto result_type = VectorType::CONSTANT_VECTOR;
111: 	for (idx_t i = 0; i < args.ColumnCount(); i++) {
112: 		if (args.data[i].GetVectorType() != VectorType::CONSTANT_VECTOR) {
113: 			args_size = args.size();
114: 			result_type = VectorType::FLAT_VECTOR;
115: 			break;
116: 		}
117: 	}
118: 	auto list_data = FlatVector::GetData<list_entry_t>(result);
119: 	auto &result_validity = FlatVector::Validity(result);
120: 	int64_t total_size = 0;
121: 	for (idx_t i = 0; i < args_size; i++) {
122: 		if (!info.RowIsValid(i)) {
123: 			result_validity.SetInvalid(i);
124: 			list_data[i].offset = total_size;
125: 			list_data[i].length = 0;
126: 		} else {
127: 			list_data[i].offset = total_size;
128: 			list_data[i].length = info.ListLength(i, INCLUSIVE_BOUND);
129: 			total_size += list_data[i].length;
130: 		}
131: 	}
132: 
133: 	// now construct the child vector of the list
134: 	ListVector::Reserve(result, total_size);
135: 	auto range_data = FlatVector::GetData<int64_t>(ListVector::GetEntry(result));
136: 	idx_t total_idx = 0;
137: 	for (idx_t i = 0; i < args_size; i++) {
138: 		int64_t start_value = info.StartListValue(i);
139: 		int64_t increment = info.ListIncrementValue(i);
140: 
141: 		int64_t range_value = start_value;
142: 		for (idx_t range_idx = 0; range_idx < list_data[i].length; range_idx++) {
143: 			range_data[total_idx++] = range_value;
144: 			range_value += increment;
145: 		}
146: 	}
147: 
148: 	ListVector::SetListSize(result, total_size);
149: 	result.SetVectorType(result_type);
150: 
151: 	result.Verify(args.size());
152: }
153: 
154: void ListRangeFun::RegisterFunction(BuiltinFunctions &set) {
155: 	// the arguments and return types are actually set in the binder function
156: 	ScalarFunctionSet range_set("range");
157: 	range_set.AddFunction(
158: 	    ScalarFunction({LogicalType::BIGINT}, LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<false>));
159: 	range_set.AddFunction(ScalarFunction({LogicalType::BIGINT, LogicalType::BIGINT},
160: 	                                     LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<false>));
161: 	range_set.AddFunction(ScalarFunction({LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT},
162: 	                                     LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<false>));
163: 	set.AddFunction(range_set);
164: 
165: 	ScalarFunctionSet generate_series("generate_series");
166: 	generate_series.AddFunction(
167: 	    ScalarFunction({LogicalType::BIGINT}, LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<true>));
168: 	generate_series.AddFunction(ScalarFunction({LogicalType::BIGINT, LogicalType::BIGINT},
169: 	                                           LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<true>));
170: 	generate_series.AddFunction(ScalarFunction({LogicalType::BIGINT, LogicalType::BIGINT, LogicalType::BIGINT},
171: 	                                           LogicalType::LIST(LogicalType::BIGINT), ListRangeFunction<true>));
172: 	set.AddFunction(generate_series);
173: }
174: 
175: } // namespace duckdb
[end of src/function/scalar/list/range.cpp]
[start of src/function/scalar/operators/add.cpp]
1: #include "duckdb/common/operator/add.hpp"
2: 
3: #include "duckdb/common/limits.hpp"
4: #include "duckdb/common/types/value.hpp"
5: 
6: #include "duckdb/common/types/date.hpp"
7: #include "duckdb/common/types/interval.hpp"
8: #include "duckdb/common/types/timestamp.hpp"
9: #include "duckdb/common/types/hugeint.hpp"
10: #include "duckdb/common/windows_undefs.hpp"
11: 
12: #include <limits>
13: 
14: namespace duckdb {
15: 
16: //===--------------------------------------------------------------------===//
17: // + [add]
18: //===--------------------------------------------------------------------===//
19: template <>
20: float AddOperator::Operation(float left, float right) {
21: 	auto result = left + right;
22: 	if (!Value::FloatIsValid(result)) {
23: 		throw OutOfRangeException("Overflow in addition of float!");
24: 	}
25: 	return result;
26: }
27: 
28: template <>
29: double AddOperator::Operation(double left, double right) {
30: 	auto result = left + right;
31: 	if (!Value::DoubleIsValid(result)) {
32: 		throw OutOfRangeException("Overflow in addition of double!");
33: 	}
34: 	return result;
35: }
36: 
37: template <>
38: interval_t AddOperator::Operation(interval_t left, interval_t right) {
39: 	left.months = AddOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.months, right.months);
40: 	left.days = AddOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.days, right.days);
41: 	left.micros = AddOperatorOverflowCheck::Operation<int64_t, int64_t, int64_t>(left.micros, right.micros);
42: 	return left;
43: }
44: 
45: template <>
46: date_t AddOperator::Operation(date_t left, int32_t right) {
47: 	int32_t result;
48: 	if (!TryAddOperator::Operation(left.days, right, result)) {
49: 		throw OutOfRangeException("Date out of range");
50: 	}
51: 	return date_t(result);
52: }
53: 
54: template <>
55: date_t AddOperator::Operation(int32_t left, date_t right) {
56: 	return AddOperator::Operation<date_t, int32_t, date_t>(right, left);
57: }
58: 
59: template <>
60: date_t AddOperator::Operation(date_t left, interval_t right) {
61: 	return Interval::Add(left, right);
62: }
63: 
64: template <>
65: date_t AddOperator::Operation(interval_t left, date_t right) {
66: 	return AddOperator::Operation<date_t, interval_t, date_t>(right, left);
67: }
68: 
69: template <>
70: timestamp_t AddOperator::Operation(timestamp_t left, interval_t right) {
71: 	date_t date;
72: 	dtime_t time;
73: 	Timestamp::Convert(left, date, time);
74: 	auto new_date = Interval::Add(date, right);
75: 	auto new_time = Interval::Add(time, right, new_date);
76: 	return Timestamp::FromDatetime(new_date, new_time);
77: }
78: 
79: template <>
80: timestamp_t AddOperator::Operation(interval_t left, timestamp_t right) {
81: 	return AddOperator::Operation<timestamp_t, interval_t, timestamp_t>(right, left);
82: }
83: 
84: //===--------------------------------------------------------------------===//
85: // + [add] with overflow check
86: //===--------------------------------------------------------------------===//
87: struct OverflowCheckedAddition {
88: 	template <class SRCTYPE, class UTYPE>
89: 	static inline bool Operation(SRCTYPE left, SRCTYPE right, SRCTYPE &result) {
90: 		UTYPE uresult = AddOperator::Operation<UTYPE, UTYPE, UTYPE>(UTYPE(left), UTYPE(right));
91: 		if (uresult < NumericLimits<SRCTYPE>::Minimum() || uresult > NumericLimits<SRCTYPE>::Maximum()) {
92: 			return false;
93: 		}
94: 		result = SRCTYPE(uresult);
95: 		return true;
96: 	}
97: };
98: 
99: template <>
100: bool TryAddOperator::Operation(uint8_t left, uint8_t right, uint8_t &result) {
101: 	return OverflowCheckedAddition::Operation<uint8_t, uint16_t>(left, right, result);
102: }
103: template <>
104: bool TryAddOperator::Operation(uint16_t left, uint16_t right, uint16_t &result) {
105: 	return OverflowCheckedAddition::Operation<uint16_t, uint32_t>(left, right, result);
106: }
107: template <>
108: bool TryAddOperator::Operation(uint32_t left, uint32_t right, uint32_t &result) {
109: 	return OverflowCheckedAddition::Operation<uint32_t, uint64_t>(left, right, result);
110: }
111: 
112: template <>
113: bool TryAddOperator::Operation(uint64_t left, uint64_t right, uint64_t &result) {
114: 	if (NumericLimits<uint64_t>::Maximum() - left < right) {
115: 		return false;
116: 	}
117: 	return OverflowCheckedAddition::Operation<uint64_t, uint64_t>(left, right, result);
118: }
119: 
120: template <>
121: bool TryAddOperator::Operation(int8_t left, int8_t right, int8_t &result) {
122: 	return OverflowCheckedAddition::Operation<int8_t, int16_t>(left, right, result);
123: }
124: 
125: template <>
126: bool TryAddOperator::Operation(int16_t left, int16_t right, int16_t &result) {
127: 	return OverflowCheckedAddition::Operation<int16_t, int32_t>(left, right, result);
128: }
129: 
130: template <>
131: bool TryAddOperator::Operation(int32_t left, int32_t right, int32_t &result) {
132: 	return OverflowCheckedAddition::Operation<int32_t, int64_t>(left, right, result);
133: }
134: 
135: template <>
136: bool TryAddOperator::Operation(int64_t left, int64_t right, int64_t &result) {
137: #if (__GNUC__ >= 5) || defined(__clang__)
138: 	if (__builtin_add_overflow(left, right, &result)) {
139: 		return false;
140: 	}
141: #else
142: 	// https://blog.regehr.org/archives/1139
143: 	result = int64_t((uint64_t)left + (uint64_t)right);
144: 	if ((left < 0 && right < 0 && result >= 0) || (left >= 0 && right >= 0 && result < 0)) {
145: 		return false;
146: 	}
147: #endif
148: 	return true;
149: }
150: 
151: //===--------------------------------------------------------------------===//
152: // add decimal with overflow check
153: //===--------------------------------------------------------------------===//
154: template <class T, T min, T max>
155: bool TryDecimalAddTemplated(T left, T right, T &result) {
156: 	if (right < 0) {
157: 		if (min - right > left) {
158: 			return false;
159: 		}
160: 	} else {
161: 		if (max - right < left) {
162: 			return false;
163: 		}
164: 	}
165: 	result = left + right;
166: 	return true;
167: }
168: 
169: template <>
170: bool TryDecimalAdd::Operation(int16_t left, int16_t right, int16_t &result) {
171: 	return TryDecimalAddTemplated<int16_t, -9999, 9999>(left, right, result);
172: }
173: 
174: template <>
175: bool TryDecimalAdd::Operation(int32_t left, int32_t right, int32_t &result) {
176: 	return TryDecimalAddTemplated<int32_t, -999999999, 999999999>(left, right, result);
177: }
178: 
179: template <>
180: bool TryDecimalAdd::Operation(int64_t left, int64_t right, int64_t &result) {
181: 	return TryDecimalAddTemplated<int64_t, -999999999999999999, 999999999999999999>(left, right, result);
182: }
183: 
184: template <>
185: bool TryDecimalAdd::Operation(hugeint_t left, hugeint_t right, hugeint_t &result) {
186: 	result = left + right;
187: 	if (result <= -Hugeint::POWERS_OF_TEN[38] || result >= Hugeint::POWERS_OF_TEN[38]) {
188: 		return false;
189: 	}
190: 	return true;
191: }
192: 
193: template <>
194: hugeint_t DecimalAddOverflowCheck::Operation(hugeint_t left, hugeint_t right) {
195: 	hugeint_t result;
196: 	if (!TryDecimalAdd::Operation(left, right, result)) {
197: 		throw OutOfRangeException("Overflow in addition of DECIMAL(38) (%s + %s);", left.ToString(), right.ToString());
198: 	}
199: 	return result;
200: }
201: 
202: //===--------------------------------------------------------------------===//
203: // add time operator
204: //===--------------------------------------------------------------------===//
205: template <>
206: dtime_t AddTimeOperator::Operation(dtime_t left, interval_t right) {
207: 	date_t date(0);
208: 	return Interval::Add(left, right, date);
209: }
210: 
211: template <>
212: dtime_t AddTimeOperator::Operation(interval_t left, dtime_t right) {
213: 	return AddTimeOperator::Operation<dtime_t, interval_t, dtime_t>(right, left);
214: }
215: 
216: } // namespace duckdb
[end of src/function/scalar/operators/add.cpp]
[start of src/include/duckdb/common/types/interval.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/interval.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/types.hpp"
12: 
13: namespace duckdb {
14: 
15: //! The Interval class is a static class that holds helper functions for the Interval
16: //! type.
17: class Interval {
18: public:
19: 	static constexpr const int32_t MONTHS_PER_MILLENIUM = 12000;
20: 	static constexpr const int32_t MONTHS_PER_CENTURY = 1200;
21: 	static constexpr const int32_t MONTHS_PER_DECADE = 120;
22: 	static constexpr const int32_t MONTHS_PER_YEAR = 12;
23: 	static constexpr const int32_t MONTHS_PER_QUARTER = 3;
24: 	static constexpr const int32_t DAYS_PER_WEEK = 7;
25: 	//! only used for interval comparison/ordering purposes, in which case a month counts as 30 days
26: 	static constexpr const int64_t DAYS_PER_MONTH = 30;
27: 	static constexpr const int64_t DAYS_PER_YEAR = 365;
28: 	static constexpr const int64_t MSECS_PER_SEC = 1000;
29: 	static constexpr const int32_t SECS_PER_MINUTE = 60;
30: 	static constexpr const int32_t MINS_PER_HOUR = 60;
31: 	static constexpr const int32_t HOURS_PER_DAY = 24;
32: 	static constexpr const int32_t SECS_PER_HOUR = SECS_PER_MINUTE * MINS_PER_HOUR;
33: 	static constexpr const int32_t SECS_PER_DAY = SECS_PER_HOUR * HOURS_PER_DAY;
34: 	static constexpr const int32_t SECS_PER_WEEK = SECS_PER_DAY * DAYS_PER_WEEK;
35: 
36: 	static constexpr const int64_t MICROS_PER_MSEC = 1000;
37: 	static constexpr const int64_t MICROS_PER_SEC = MICROS_PER_MSEC * MSECS_PER_SEC;
38: 	static constexpr const int64_t MICROS_PER_MINUTE = MICROS_PER_SEC * SECS_PER_MINUTE;
39: 	static constexpr const int64_t MICROS_PER_HOUR = MICROS_PER_MINUTE * MINS_PER_HOUR;
40: 	static constexpr const int64_t MICROS_PER_DAY = MICROS_PER_HOUR * HOURS_PER_DAY;
41: 	static constexpr const int64_t MICROS_PER_WEEK = MICROS_PER_DAY * DAYS_PER_WEEK;
42: 	static constexpr const int64_t MICROS_PER_MONTH = MICROS_PER_DAY * DAYS_PER_MONTH;
43: 
44: 	static constexpr const int64_t NANOS_PER_MICRO = 1000;
45: 	static constexpr const int64_t NANOS_PER_MSEC = NANOS_PER_MICRO * MICROS_PER_MSEC;
46: 	static constexpr const int64_t NANOS_PER_SEC = NANOS_PER_MSEC * MSECS_PER_SEC;
47: 	static constexpr const int64_t NANOS_PER_MINUTE = NANOS_PER_SEC * SECS_PER_MINUTE;
48: 	static constexpr const int64_t NANOS_PER_HOUR = NANOS_PER_MINUTE * MINS_PER_HOUR;
49: 	static constexpr const int64_t NANOS_PER_DAY = NANOS_PER_HOUR * HOURS_PER_DAY;
50: 	static constexpr const int64_t NANOS_PER_WEEK = NANOS_PER_DAY * DAYS_PER_WEEK;
51: 
52: public:
53: 	//! Convert a string to an interval object
54: 	static bool FromString(const string &str, interval_t &result);
55: 	//! Convert a string to an interval object
56: 	static bool FromCString(const char *str, idx_t len, interval_t &result, string *error_message, bool strict);
57: 	//! Convert an interval object to a string
58: 	static string ToString(const interval_t &val);
59: 
60: 	//! Convert milliseconds to a normalised interval
61: 	DUCKDB_API static interval_t FromMicro(int64_t micros);
62: 
63: 	//! Get Interval in milliseconds
64: 	static int64_t GetMilli(const interval_t &val);
65: 
66: 	//! Get Interval in microseconds
67: 	static int64_t GetMicro(const interval_t &val);
68: 
69: 	//! Get Interval in Nanoseconds
70: 	static int64_t GetNanoseconds(const interval_t &val);
71: 
72: 	//! Returns the age between two timestamps (including 30 day months)
73: 	static interval_t GetAge(timestamp_t timestamp_1, timestamp_t timestamp_2);
74: 
75: 	//! Returns the exact difference between two timestamps (days and seconds)
76: 	static interval_t GetDifference(timestamp_t timestamp_1, timestamp_t timestamp_2);
77: 
78: 	//! Add an interval to a date
79: 	static date_t Add(date_t left, interval_t right);
80: 	//! Add an interval to a time. In case the time overflows or underflows, modify the date by the overflow.
81: 	//! For example if we go from 23:00 to 02:00, we add a day to the date
82: 	static dtime_t Add(dtime_t left, interval_t right, date_t &date);
83: 
84: 	//! Comparison operators
85: 	static bool Equals(interval_t left, interval_t right);
86: 	static bool GreaterThan(interval_t left, interval_t right);
87: 	static bool GreaterThanEquals(interval_t left, interval_t right);
88: };
89: } // namespace duckdb
[end of src/include/duckdb/common/types/interval.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: