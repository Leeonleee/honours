{
  "repo": "duckdb/duckdb",
  "pull_number": 3608,
  "instance_id": "duckdb__duckdb-3608",
  "issue_numbers": [
    "3549",
    "3549"
  ],
  "base_commit": "d8a2743d8848376c27bfe6b2b37eb39ac4ae42f7",
  "patch": "diff --git a/src/include/duckdb/main/client_config.hpp b/src/include/duckdb/main/client_config.hpp\nindex 5a7da65209d0..bcbb7e520b73 100644\n--- a/src/include/duckdb/main/client_config.hpp\n+++ b/src/include/duckdb/main/client_config.hpp\n@@ -38,6 +38,8 @@ struct ClientConfig {\n \t//! Preserve identifier case while parsing.\n \t//! If false, all unquoted identifiers are lower-cased (e.g. \"MyTable\" -> \"mytable\").\n \tbool preserve_identifier_case = true;\n+\t//! The maximum expression depth limit in the parser\n+\tidx_t max_expression_depth = 1000;\n \n \t// Whether or not aggressive query verification is enabled\n \tbool query_verification_enabled = false;\ndiff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp\nindex f5878e155c03..73d7a12a38c3 100644\n--- a/src/include/duckdb/main/settings.hpp\n+++ b/src/include/duckdb/main/settings.hpp\n@@ -169,6 +169,16 @@ struct LogQueryPathSetting {\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n+struct MaximumExpressionDepthSetting {\n+\tstatic constexpr const char *Name = \"max_expression_depth\";\n+\tstatic constexpr const char *Description =\n+\t    \"The maximum expression depth limit in the parser. WARNING: increasing this setting and using very deep \"\n+\t    \"expressions might lead to stack overflow errors.\";\n+\tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;\n+\tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic Value GetSetting(ClientContext &context);\n+};\n+\n struct MaximumMemorySetting {\n \tstatic constexpr const char *Name = \"max_memory\";\n \tstatic constexpr const char *Description = \"The maximum memory of the system (e.g. 1GB)\";\ndiff --git a/src/include/duckdb/parser/parser.hpp b/src/include/duckdb/parser/parser.hpp\nindex f154dd17f2b3..2815a1ee1898 100644\n--- a/src/include/duckdb/parser/parser.hpp\n+++ b/src/include/duckdb/parser/parser.hpp\n@@ -23,6 +23,7 @@ namespace duckdb {\n \n struct ParserOptions {\n \tbool preserve_identifier_case = true;\n+\tidx_t max_expression_depth = 1000;\n };\n \n //! The parser is responsible for parsing the query and converting it into a set\ndiff --git a/src/include/duckdb/parser/transformer.hpp b/src/include/duckdb/parser/transformer.hpp\nindex 861f8b81fc85..d7332c5d7240 100644\n--- a/src/include/duckdb/parser/transformer.hpp\n+++ b/src/include/duckdb/parser/transformer.hpp\n@@ -32,12 +32,11 @@ struct GroupingExpressionMap;\n //! The transformer class is responsible for transforming the internal Postgres\n //! parser representation into the DuckDB representation\n class Transformer {\n-\tstatic constexpr const idx_t DEFAULT_MAX_EXPRESSION_DEPTH = 1000;\n-\n \tfriend class StackChecker;\n \n public:\n-\texplicit Transformer(Transformer *parent = nullptr, idx_t max_expression_depth_p = DEFAULT_MAX_EXPRESSION_DEPTH);\n+\texplicit Transformer(idx_t max_expression_depth_p);\n+\texplicit Transformer(Transformer *parent);\n \n \t//! Transforms a Postgres parse tree into a set of SQL Statements\n \tbool TransformParseTree(duckdb_libpgquery::PGList *tree, vector<unique_ptr<SQLStatement>> &statements);\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex 2e04a66eb9f5..711a8c887c02 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -1131,6 +1131,7 @@ bool ClientContext::TryGetCurrentSetting(const std::string &key, Value &result)\n ParserOptions ClientContext::GetParserOptions() {\n \tParserOptions options;\n \toptions.preserve_identifier_case = ClientConfig::GetConfig(*this).preserve_identifier_case;\n+\toptions.max_expression_depth = ClientConfig::GetConfig(*this).max_expression_depth;\n \treturn options;\n }\n \ndiff --git a/src/main/config.cpp b/src/main/config.cpp\nindex 8d131f331deb..ceecd611fb38 100644\n--- a/src/main/config.cpp\n+++ b/src/main/config.cpp\n@@ -40,6 +40,7 @@ static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting\n                                                  DUCKDB_GLOBAL(ExternalThreadsSetting),\n                                                  DUCKDB_GLOBAL(ForceCompressionSetting),\n                                                  DUCKDB_LOCAL(LogQueryPathSetting),\n+                                                 DUCKDB_LOCAL(MaximumExpressionDepthSetting),\n                                                  DUCKDB_GLOBAL(MaximumMemorySetting),\n                                                  DUCKDB_GLOBAL_ALIAS(\"memory_limit\", MaximumMemorySetting),\n                                                  DUCKDB_GLOBAL_ALIAS(\"null_order\", DefaultNullOrderSetting),\ndiff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp\nindex aa3b8b2dc5bf..f8b647d6e30a 100644\n--- a/src/main/settings/settings.cpp\n+++ b/src/main/settings/settings.cpp\n@@ -392,6 +392,17 @@ Value LogQueryPathSetting::GetSetting(ClientContext &context) {\n \treturn client_data.log_query_writer ? Value(client_data.log_query_writer->path) : Value();\n }\n \n+//===--------------------------------------------------------------------===//\n+// Maximum Expression Depth\n+//===--------------------------------------------------------------------===//\n+void MaximumExpressionDepthSetting::SetLocal(ClientContext &context, const Value &input) {\n+\tClientConfig::GetConfig(context).max_expression_depth = input.GetValue<uint64_t>();\n+}\n+\n+Value MaximumExpressionDepthSetting::GetSetting(ClientContext &context) {\n+\treturn Value::UBIGINT(ClientConfig::GetConfig(context).max_expression_depth);\n+}\n+\n //===--------------------------------------------------------------------===//\n // Maximum Memory\n //===--------------------------------------------------------------------===//\ndiff --git a/src/parser/parser.cpp b/src/parser/parser.cpp\nindex 159f643c11c4..1172d1828673 100644\n--- a/src/parser/parser.cpp\n+++ b/src/parser/parser.cpp\n@@ -18,7 +18,7 @@ Parser::Parser(ParserOptions options_p) : options(options_p) {\n }\n \n void Parser::ParseQuery(const string &query) {\n-\tTransformer transformer;\n+\tTransformer transformer(options.max_expression_depth);\n \t{\n \t\tPostgresParser::SetPreserveIdentifierCase(options.preserve_identifier_case);\n \t\tPostgresParser parser;\ndiff --git a/src/parser/transformer.cpp b/src/parser/transformer.cpp\nindex 438917de6d72..d8cd18a8323c 100644\n--- a/src/parser/transformer.cpp\n+++ b/src/parser/transformer.cpp\n@@ -20,9 +20,12 @@ StackChecker::StackChecker(StackChecker &&other) noexcept\n \tother.stack_usage = 0;\n }\n \n-Transformer::Transformer(Transformer *parent, idx_t max_expression_depth_p)\n-    : parent(parent), max_expression_depth(parent ? parent->max_expression_depth : max_expression_depth_p),\n-      stack_depth(DConstants::INVALID_INDEX) {\n+Transformer::Transformer(idx_t max_expression_depth_p)\n+    : parent(nullptr), max_expression_depth(max_expression_depth_p), stack_depth(DConstants::INVALID_INDEX) {\n+}\n+\n+Transformer::Transformer(Transformer *parent)\n+    : parent(parent), max_expression_depth(parent->max_expression_depth), stack_depth(DConstants::INVALID_INDEX) {\n }\n \n bool Transformer::TransformParseTree(duckdb_libpgquery::PGList *tree, vector<unique_ptr<SQLStatement>> &statements) {\n@@ -48,7 +51,9 @@ StackChecker Transformer::StackCheck(idx_t extra_stack) {\n \t}\n \tD_ASSERT(node->stack_depth != DConstants::INVALID_INDEX);\n \tif (node->stack_depth + extra_stack >= max_expression_depth) {\n-\t\tthrow ParserException(\"Max expression depth limit of %lld exceeded\", max_expression_depth);\n+\t\tthrow ParserException(\"Max expression depth limit of %lld exceeded. Use \\\"SET max_expression_depth TO x\\\" to \"\n+\t\t                      \"increase the maximum expression depth.\",\n+\t\t                      max_expression_depth);\n \t}\n \treturn StackChecker(*node, extra_stack);\n }\n",
  "test_patch": "diff --git a/test/sql/parser/expression_depth_limit.test b/test/sql/parser/expression_depth_limit.test\nnew file mode 100644\nindex 000000000000..27c9527b96af\n--- /dev/null\n+++ b/test/sql/parser/expression_depth_limit.test\n@@ -0,0 +1,18 @@\n+# name: test/sql/parser/expression_depth_limit.test\n+# description: Test max expression depth limit\n+# group: [parser]\n+\n+statement ok\n+SELECT (1+(1+(1+(1+(1+(1+(1+1)))))));\n+\n+statement ok\n+SET max_expression_depth TO 3;\n+\n+statement error\n+SELECT (1+(1+(1+(1+(1+(1+(1+1)))))));\n+\n+statement ok\n+SET max_expression_depth TO 1000;\n+\n+statement ok\n+SELECT (1+(1+(1+(1+(1+(1+(1+1)))))));\n",
  "problem_statement": "Turn off max expression depth limit\nI'm issuing a large query with >1000 cases.\r\nI got the following errors:\r\nParser Error: Max expression depth limit of 1000 exceeded\r\n\r\nIs there any way to turn off the limit, or increase it? Thank you!\nTurn off max expression depth limit\nI'm issuing a large query with >1000 cases.\r\nI got the following errors:\r\nParser Error: Max expression depth limit of 1000 exceeded\r\n\r\nIs there any way to turn off the limit, or increase it? Thank you!\n",
  "hints_text": "Hello!\r\n\r\nCould you please provide the query and your environment details (OS, DuckDB client and version)? It will help us debug as well as potentially make a test to prevent future regressions. Thanks!\nMy query is very large with >1000 CASE WHEN END\r\nI think it's not a bug, but some special query that touches the limit.\r\n\r\nEnvironment:\r\n    OS: Linux\r\n    DuckDB Version: 0.3.3\r\n    DuckDB Client: python\r\n\nOne other thought for a workaround! Could you create a mapping table and use a join instead of those case when statements?\nHow?\r\nLet say I have a table R(A,B,C)\r\nI have \r\nCASE1: A=1\r\nCASE2: A=2 AND C =3\r\nCASE3: A=3 OR B=2\r\nCASE4: A != 2\r\n...\r\nIt would be tricky to express OR, != ... predicates right? \nThe expression depth limit is there to avoid stack overflow. This limit is defined in `transformer.hpp` and you are of course welcome to change it yourself and recompile. \nThank you for the suggestion! I temporarily solve this error by create temporal tables to store intermediate results.\nLarge case expressions shouldn't trigger the expression depth limit, see [e.g. our big_case test](https://github.com/duckdb/duckdb/blob/master/test/sql/function/generic/big_case.test#L9). Could you share the exact query that triggers this?\r\n\r\nI agree that we should make the expression depth limit configurable though.\nHello!\r\n\r\nCould you please provide the query and your environment details (OS, DuckDB client and version)? It will help us debug as well as potentially make a test to prevent future regressions. Thanks!\nMy query is very large with >1000 CASE WHEN END\r\nI think it's not a bug, but some special query that touches the limit.\r\n\r\nEnvironment:\r\n    OS: Linux\r\n    DuckDB Version: 0.3.3\r\n    DuckDB Client: python\r\n\nOne other thought for a workaround! Could you create a mapping table and use a join instead of those case when statements?\nHow?\r\nLet say I have a table R(A,B,C)\r\nI have \r\nCASE1: A=1\r\nCASE2: A=2 AND C =3\r\nCASE3: A=3 OR B=2\r\nCASE4: A != 2\r\n...\r\nIt would be tricky to express OR, != ... predicates right? \nThe expression depth limit is there to avoid stack overflow. This limit is defined in `transformer.hpp` and you are of course welcome to change it yourself and recompile. \nThank you for the suggestion! I temporarily solve this error by create temporal tables to store intermediate results.\nLarge case expressions shouldn't trigger the expression depth limit, see [e.g. our big_case test](https://github.com/duckdb/duckdb/blob/master/test/sql/function/generic/big_case.test#L9). Could you share the exact query that triggers this?\r\n\r\nI agree that we should make the expression depth limit configurable though.",
  "created_at": "2022-05-10T13:54:20Z"
}