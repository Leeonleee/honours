{
  "repo": "duckdb/duckdb",
  "pull_number": 12209,
  "instance_id": "duckdb__duckdb-12209",
  "issue_numbers": [
    "12191"
  ],
  "base_commit": "d6c92486f3639c471b1a168fd7548ade6692b2aa",
  "patch": "diff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp\nindex fe47d9336797..34b73778106e 100644\n--- a/src/include/duckdb/main/config.hpp\n+++ b/src/include/duckdb/main/config.hpp\n@@ -208,6 +208,8 @@ struct DBConfigOptions {\n \tbool allow_extensions_metadata_mismatch = false;\n \t//! Enable emitting FSST Vectors\n \tbool enable_fsst_vectors = false;\n+\t//! Enable VIEWs to create dependencies\n+\tbool enable_view_dependencies = false;\n \t//! Start transactions immediately in all attached databases - instead of lazily when a database is referenced\n \tbool immediate_transaction_mode = false;\n \t//! Debug setting - how to initialize  blocks in the storage layer when allocating\ndiff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp\nindex 10d9fe30feb0..ced0835ca4e3 100644\n--- a/src/include/duckdb/main/settings.hpp\n+++ b/src/include/duckdb/main/settings.hpp\n@@ -206,6 +206,16 @@ struct EnableExternalAccessSetting {\n \tstatic Value GetSetting(const ClientContext &context);\n };\n \n+struct EnableViewDependencies {\n+\tstatic constexpr const char *Name = \"enable_view_dependencies\";\n+\tstatic constexpr const char *Description =\n+\t    \"Enable created VIEWs to create dependencies on the referenced objects (such as tables)\";\n+\tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n+\tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n+\tstatic Value GetSetting(const ClientContext &context);\n+};\n+\n struct EnableFSSTVectors {\n \tstatic constexpr const char *Name = \"enable_fsst_vectors\";\n \tstatic constexpr const char *Description =\ndiff --git a/src/main/config.cpp b/src/main/config.cpp\nindex 86bfacb4e2f0..409ae1f9308f 100644\n--- a/src/main/config.cpp\n+++ b/src/main/config.cpp\n@@ -94,6 +94,7 @@ static const ConfigurationOption internal_options[] = {\n     DUCKDB_GLOBAL(ForceBitpackingModeSetting),\n     DUCKDB_LOCAL(HomeDirectorySetting),\n     DUCKDB_LOCAL(LogQueryPathSetting),\n+    DUCKDB_GLOBAL(EnableViewDependencies),\n     DUCKDB_GLOBAL(LockConfigurationSetting),\n     DUCKDB_GLOBAL(ImmediateTransactionModeSetting),\n     DUCKDB_LOCAL(IntegerDivisionSetting),\ndiff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp\nindex 6db7a8c946c4..2b5ae50c5d33 100644\n--- a/src/main/settings/settings.cpp\n+++ b/src/main/settings/settings.cpp\n@@ -437,6 +437,22 @@ Value EnableExternalAccessSetting::GetSetting(const ClientContext &context) {\n \treturn Value::BOOLEAN(config.options.enable_external_access);\n }\n \n+//===--------------------------------------------------------------------===//\n+// Enable View Dependencies\n+//===--------------------------------------------------------------------===//\n+void EnableViewDependencies::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {\n+\tconfig.options.enable_view_dependencies = input.GetValue<bool>();\n+}\n+\n+void EnableViewDependencies::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.enable_view_dependencies = DBConfig().options.enable_view_dependencies;\n+}\n+\n+Value EnableViewDependencies::GetSetting(const ClientContext &context) {\n+\tauto &config = DBConfig::GetConfig(context);\n+\treturn Value::BOOLEAN(config.options.enable_view_dependencies);\n+}\n+\n //===--------------------------------------------------------------------===//\n // Enable FSST Vectors\n //===--------------------------------------------------------------------===//\ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex eb31c9529518..64fb2e9a3f45 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -145,13 +145,19 @@ void Binder::BindCreateViewInfo(CreateViewInfo &base) {\n \tauto view_binder = Binder::CreateBinder(context);\n \tauto &dependencies = base.dependencies;\n \tauto &catalog = Catalog::GetCatalog(context, base.catalog);\n-\tview_binder->SetCatalogLookupCallback([&dependencies, &catalog](CatalogEntry &entry) {\n-\t\tif (&catalog != &entry.ParentCatalog()) {\n-\t\t\t// Don't register dependencies between catalogs\n-\t\t\treturn;\n-\t\t}\n-\t\tdependencies.AddDependency(entry);\n-\t});\n+\n+\tauto &db_config = DBConfig::GetConfig(context);\n+\tauto should_create_dependencies = db_config.options.enable_view_dependencies;\n+\n+\tif (should_create_dependencies) {\n+\t\tview_binder->SetCatalogLookupCallback([&dependencies, &catalog](CatalogEntry &entry) {\n+\t\t\tif (&catalog != &entry.ParentCatalog()) {\n+\t\t\t\t// Don't register dependencies between catalogs\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tdependencies.AddDependency(entry);\n+\t\t});\n+\t}\n \tview_binder->can_contain_nulls = true;\n \n \tauto copy = base.query->Copy();\n",
  "test_patch": "diff --git a/test/api/test_reset.cpp b/test/api/test_reset.cpp\nindex 14269f292764..5a949c0e5841 100644\n--- a/test/api/test_reset.cpp\n+++ b/test/api/test_reset.cpp\n@@ -60,6 +60,7 @@ OptionValueSet &GetValueForOption(const string &name) {\n \t    {\"prefer_range_joins\", {Value(true)}},\n \t    {\"allow_persistent_secrets\", {Value(false)}},\n \t    {\"secret_directory\", {\"/tmp/some/path\"}},\n+\t    {\"enable_view_dependencies\", {Value(true)}},\n \t    {\"default_secret_storage\", {\"custom_storage\"}},\n \t    {\"custom_extension_repository\", {\"duckdb.org/no-extensions-here\", \"duckdb.org/no-extensions-here\"}},\n \t    {\"autoinstall_extension_repository\", {\"duckdb.org/no-extensions-here\", \"duckdb.org/no-extensions-here\"}},\ndiff --git a/test/fuzzer/pedro/view_not_rebound_error.test b/test/fuzzer/pedro/view_not_rebound_error.test\nindex e985626bbc08..d2d3665e63ac 100644\n--- a/test/fuzzer/pedro/view_not_rebound_error.test\n+++ b/test/fuzzer/pedro/view_not_rebound_error.test\n@@ -4,6 +4,9 @@\n # FIXME: for this to work we need to serialize/deserialize dependencies\n require skip_reload\n \n+statement ok\n+set enable_view_dependencies=true\n+\n statement ok\n CREATE TABLE t1 (c1 INT);\n \ndiff --git a/test/fuzzer/pedro/view_not_rebound_error_no_view_dependencies.test b/test/fuzzer/pedro/view_not_rebound_error_no_view_dependencies.test\nnew file mode 100644\nindex 000000000000..b2719a97e973\n--- /dev/null\n+++ b/test/fuzzer/pedro/view_not_rebound_error_no_view_dependencies.test\n@@ -0,0 +1,24 @@\n+# name: test/fuzzer/pedro/view_not_rebound_error_no_view_dependencies.test\n+# group: [pedro]\n+\n+# FIXME: for this to work we need to serialize/deserialize dependencies\n+require skip_reload\n+\n+statement ok\n+CREATE TABLE t1 (c1 INT);\n+\n+statement ok\n+CREATE VIEW t0 AS SELECT 1 FROM t1 GROUP BY c1;\n+\n+statement ok\n+DROP TABLE t1;\n+\n+statement ok\n+CREATE TABLE t2 (c1 INT);\n+\n+statement ok\n+CREATE TABLE t1 (c2 INT);\n+\n+statement error\n+SELECT 1 FROM t2 JOIN t1 ON (SELECT TRUE FROM t0);\n+----\ndiff --git a/test/sql/aggregate/qualify/test_qualify_view.test b/test/sql/aggregate/qualify/test_qualify_view.test\nindex 8359750a096c..7f6545248533 100644\n--- a/test/sql/aggregate/qualify/test_qualify_view.test\n+++ b/test/sql/aggregate/qualify/test_qualify_view.test\n@@ -7,6 +7,9 @@ require skip_reload\n # load the DB from disk\n load __TEST_DIR__/view_storage.db\n \n+statement ok\n+set enable_view_dependencies=true\n+\n statement ok\n PRAGMA disable_checkpoint_on_shutdown\n \ndiff --git a/test/sql/aggregate/qualify/test_qualify_view_no_view_dependencies.test b/test/sql/aggregate/qualify/test_qualify_view_no_view_dependencies.test\nnew file mode 100644\nindex 000000000000..83d4c9669756\n--- /dev/null\n+++ b/test/sql/aggregate/qualify/test_qualify_view_no_view_dependencies.test\n@@ -0,0 +1,73 @@\n+# name: test/sql/aggregate/qualify/test_qualify_view_no_view_dependencies.test\n+# description: Test QUALIFY clause in a view over different runs\n+# group: [qualify]\n+\n+require skip_reload\n+\n+# load the DB from disk\n+load __TEST_DIR__/view_storage.db\n+\n+statement ok\n+PRAGMA disable_checkpoint_on_shutdown\n+\n+statement ok\n+PRAGMA wal_autocheckpoint='1TB';\n+\n+# create a schema and view\n+statement ok\n+CREATE SCHEMA test;\n+\n+statement ok\n+CREATE TABLE test.t (a INTEGER, b INTEGER);\n+\n+statement ok\n+INSERT INTO test.t VALUES (11, 22), (13, 22), (12, 21)\n+\n+statement ok\n+CREATE VIEW test.v AS SELECT * FROM test.t QUALIFY row_number() OVER (PARTITION BY b) = 1;\n+\n+query II\n+SELECT b, SUM(a) \n+FROM test.v \n+GROUP BY b \n+QUALIFY row_number() OVER (PARTITION BY b) = 1\n+ORDER BY ALL\n+----\n+21\t12\n+22\t11\n+\n+# drop the table the view is based on\n+statement ok\n+DROP TABLE test.t\n+\n+loop i 0 2\n+\n+# restart the system\n+restart\n+\n+# after recreating the table, we can query the view again\n+statement ok\n+CREATE TABLE test.t (a INTEGER, b INTEGER);\n+\n+statement ok\n+INSERT INTO test.t VALUES (11, 22), (13, 22), (12, 21)\n+\n+query II\n+SELECT b, SUM(a) \n+FROM test.v \n+GROUP BY b \n+QUALIFY row_number() OVER (PARTITION BY b) = 1\n+ORDER BY ALL\n+----\n+21\t12\n+22\t11\n+\n+# drop the table again\n+statement ok\n+DROP TABLE test.t\n+\n+statement error\n+SELECT * FROM test.v\n+----\n+\n+endloop\ndiff --git a/test/sql/catalog/view/recursive_view_with_dependencies.test b/test/sql/catalog/view/recursive_view_with_dependencies.test\nindex 6ee89c28e9d9..138ed3d10689 100644\n--- a/test/sql/catalog/view/recursive_view_with_dependencies.test\n+++ b/test/sql/catalog/view/recursive_view_with_dependencies.test\n@@ -5,6 +5,9 @@\n statement ok\n set storage_compatibility_version='latest'\n \n+statement ok\n+set enable_view_dependencies=true\n+\n statement ok\n PRAGMA enable_verification\n \ndiff --git a/test/sql/catalog/view/test_view_schema_change_with_dependencies.test b/test/sql/catalog/view/test_view_schema_change_with_dependencies.test\nindex e0cc2c27e12c..3ec9283089e7 100644\n--- a/test/sql/catalog/view/test_view_schema_change_with_dependencies.test\n+++ b/test/sql/catalog/view/test_view_schema_change_with_dependencies.test\n@@ -5,6 +5,9 @@\n statement ok\n set storage_compatibility_version='latest'\n \n+statement ok\n+set enable_view_dependencies=true\n+\n statement ok\n PRAGMA enable_verification\n \ndiff --git a/test/sql/catalog/view/test_view_sql_with_dependencies.test b/test/sql/catalog/view/test_view_sql_with_dependencies.test\nindex 66a8a3f23849..75d8640575f7 100644\n--- a/test/sql/catalog/view/test_view_sql_with_dependencies.test\n+++ b/test/sql/catalog/view/test_view_sql_with_dependencies.test\n@@ -5,6 +5,9 @@\n statement ok\n set storage_compatibility_version='latest'\n \n+statement ok\n+set enable_view_dependencies=true\n+\n statement ok\n PRAGMA enable_verification\n \ndiff --git a/test/sql/storage/catalog/test_view_explicit_aliases.test b/test/sql/storage/catalog/test_view_explicit_aliases.test\nindex f55c3081f362..2d6f6c7344c8 100644\n--- a/test/sql/storage/catalog/test_view_explicit_aliases.test\n+++ b/test/sql/storage/catalog/test_view_explicit_aliases.test\n@@ -8,6 +8,9 @@ require skip_reload\n # load the DB from disk\n load __TEST_DIR__/view_explicit_aliases_storage.db\n \n+statement ok\n+set enable_view_dependencies=true\n+\n # create a database and insert the table/view\n statement ok\n CREATE SCHEMA test;\ndiff --git a/test/sql/storage/catalog/test_view_storage.test b/test/sql/storage/catalog/test_view_storage.test\nindex 3218dec01092..d2efb3c72e06 100644\n--- a/test/sql/storage/catalog/test_view_storage.test\n+++ b/test/sql/storage/catalog/test_view_storage.test\n@@ -8,6 +8,9 @@ require skip_reload\n # load the DB from disk\n load __TEST_DIR__/view_storage.db\n \n+statement ok\n+set enable_view_dependencies=true\n+\n # create a schema and view\n statement ok\n CREATE SCHEMA test;\ndiff --git a/test/sql/storage/catalog/test_view_storage_no_view_dependencies.test b/test/sql/storage/catalog/test_view_storage_no_view_dependencies.test\nnew file mode 100644\nindex 000000000000..195ac67e3cd9\n--- /dev/null\n+++ b/test/sql/storage/catalog/test_view_storage_no_view_dependencies.test\n@@ -0,0 +1,79 @@\n+# name: test/sql/storage/catalog/test_view_storage_no_view_dependencies.test\n+# description: Create and drop a view over different runs\n+# group: [catalog]\n+\n+# load the DB from disk\n+load __TEST_DIR__/view_storage.db\n+\n+# create a schema and view\n+statement ok\n+CREATE SCHEMA test;\n+\n+statement ok\n+CREATE TABLE test.t (a INTEGER, b INTEGER);\n+\n+statement ok\n+CREATE VIEW test.v AS SELECT * FROM test.t;\n+\n+# read the info from the view\n+query IIIIII\n+PRAGMA table_info('test.v')\n+----\n+0\ta\tINTEGER\t0\tNULL\t0\n+1\tb\tINTEGER\t0\tNULL\t0\n+\n+# drop the table the view is based on\n+statement ok\n+DROP TABLE test.t\n+\n+# we can still query the types and column names\n+query IIIIII\n+PRAGMA table_info('test.v')\n+----\n+0\ta\tINTEGER\t0\tNULL\t0\n+1\tb\tINTEGER\t0\tNULL\t0\n+\n+# but querying the view fails\n+statement error\n+SELECT * FROM test.v\n+----\n+\n+\n+loop i 0 2\n+\n+# restart the system\n+restart\n+\n+# the view still exists, but the table does not\n+# we can check the types, but not query it\n+query IIIIII\n+PRAGMA table_info('test.v')\n+----\n+0\ta\tINTEGER\t0\tNULL\t0\n+1\tb\tINTEGER\t0\tNULL\t0\n+\n+statement error\n+SELECT * FROM test.v\n+----\n+\n+# after recreating the table, we can query the view again\n+statement ok\n+CREATE TABLE test.t (a INTEGER, b INTEGER);\n+\n+statement ok\n+SELECT * FROM test.t\n+\n+statement ok\n+SELECT * FROM test.v\n+\n+query IIIIII\n+PRAGMA table_info('test.v')\n+----\n+0\ta\tINTEGER\t0\tNULL\t0\n+1\tb\tINTEGER\t0\tNULL\t0\n+\n+# drop the table again\n+statement ok\n+DROP TABLE test.t\n+\n+endloop\ndiff --git a/test/sql/storage/wal/wal_view_explicit_aliases.test b/test/sql/storage/wal/wal_view_explicit_aliases.test\nindex fbfe63f59614..6a7375f4a435 100644\n--- a/test/sql/storage/wal/wal_view_explicit_aliases.test\n+++ b/test/sql/storage/wal/wal_view_explicit_aliases.test\n@@ -4,10 +4,12 @@\n \n require skip_reload\n \n-\n # load the DB from disk\n load __TEST_DIR__/view_explicit_aliases_storage.db\n \n+statement ok\n+set enable_view_dependencies=true\n+\n statement ok\n PRAGMA disable_checkpoint_on_shutdown\n \ndiff --git a/test/sql/storage/wal/wal_view_explicit_aliases_no_view_dependencies.test b/test/sql/storage/wal/wal_view_explicit_aliases_no_view_dependencies.test\nnew file mode 100644\nindex 000000000000..1ae05c663d5b\n--- /dev/null\n+++ b/test/sql/storage/wal/wal_view_explicit_aliases_no_view_dependencies.test\n@@ -0,0 +1,74 @@\n+# name: test/sql/storage/wal/wal_view_explicit_aliases_no_view_dependencies.test\n+# description: Test views with explicit column aliases\n+# group: [wal]\n+\n+require skip_reload\n+\n+\n+# load the DB from disk\n+load __TEST_DIR__/view_explicit_aliases_storage.db\n+\n+statement ok\n+PRAGMA disable_checkpoint_on_shutdown\n+\n+statement ok\n+PRAGMA wal_autocheckpoint='1TB';\n+\n+# create a database and insert the table/view\n+statement ok\n+CREATE SCHEMA test;\n+\n+statement ok\n+CREATE TABLE test.t (a INTEGER, b INTEGER);\n+\n+# the view has aliases (b, c)\n+statement ok\n+CREATE VIEW test.v (b,c) AS SELECT * FROM test.t;\n+\n+# check the view info\n+query II nosort view_info\n+PRAGMA table_info('test.v')\n+----\n+\n+statement ok\n+SELECT * FROM test.v\n+\n+statement ok\n+DROP TABLE test.t\n+\n+# we can still query this after the table is gone\n+query II nosort view_info\n+PRAGMA table_info('test.v')\n+----\n+\n+loop i 0 2\n+\n+# now reload\n+restart\n+\n+statement ok\n+PRAGMA disable_checkpoint_on_shutdown\n+\n+# can check info, but not query the view\n+query II nosort view_info\n+PRAGMA table_info('test.v')\n+----\n+\n+statement error\n+SELECT * FROM test.v\n+----\n+\n+# we can query again after recreating the table\n+statement ok\n+CREATE TABLE test.t (a INTEGER, b INTEGER);\n+\n+statement ok\n+SELECT * FROM test.t\n+\n+statement ok\n+SELECT b,c FROM test.v\n+\n+statement ok\n+DROP TABLE test.t\n+\n+endloop\ndiff --git a/test/sql/storage/wal/wal_view_storage.test b/test/sql/storage/wal/wal_view_storage.test\nindex e87a6b423eca..be0915a0aeae 100644\n--- a/test/sql/storage/wal/wal_view_storage.test\n+++ b/test/sql/storage/wal/wal_view_storage.test\n@@ -4,10 +4,12 @@\n \n require skip_reload\n \n-\n # load the DB from disk\n load __TEST_DIR__/view_storage.db\n \n+statement ok\n+set enable_view_dependencies=true\n+\n statement ok\n PRAGMA disable_checkpoint_on_shutdown\n \ndiff --git a/test/sql/storage/wal/wal_view_storage_no_view_dependencies.test b/test/sql/storage/wal/wal_view_storage_no_view_dependencies.test\nnew file mode 100644\nindex 000000000000..7214c3f4942b\n--- /dev/null\n+++ b/test/sql/storage/wal/wal_view_storage_no_view_dependencies.test\n@@ -0,0 +1,97 @@\n+# name: test/sql/storage/wal/wal_view_storage_no_view_dependencies.test\n+# description: Create and drop a view over different runs\n+# group: [wal]\n+\n+require skip_reload\n+\n+\n+# load the DB from disk\n+load __TEST_DIR__/view_storage.db\n+\n+statement ok\n+PRAGMA disable_checkpoint_on_shutdown\n+\n+statement ok\n+PRAGMA wal_autocheckpoint='1TB';\n+\n+# create a schema and view\n+statement ok\n+CREATE SCHEMA test;\n+\n+statement ok\n+CREATE TABLE test.t (a INTEGER, b INTEGER);\n+\n+statement ok\n+CREATE VIEW test.v AS SELECT * FROM test.t;\n+\n+# read the info from the view\n+query IIIIII\n+PRAGMA table_info('test.v')\n+----\n+0\ta\tINTEGER\t0\tNULL\t0\n+1\tb\tINTEGER\t0\tNULL\t0\n+\n+# drop the table the view is based on\n+statement ok\n+DROP TABLE test.t\n+\n+# we can still query the types and column names\n+query IIIIII\n+PRAGMA table_info('test.v')\n+----\n+0\ta\tINTEGER\t0\tNULL\t0\n+1\tb\tINTEGER\t0\tNULL\t0\n+\n+# but querying the view fails\n+statement error\n+SELECT * FROM test.v\n+----\n+\n+statement ok\n+CREATE VIEW test.v2 AS SELECT 42\n+\n+statement ok\n+DROP VIEW test.v2\n+\n+loop i 0 2\n+\n+# restart the system\n+restart\n+\n+# the view still exists, but the table does not\n+# we can check the types, but not query it\n+query IIIIII\n+PRAGMA table_info('test.v')\n+----\n+0\ta\tINTEGER\t0\tNULL\t0\n+1\tb\tINTEGER\t0\tNULL\t0\n+\n+statement error\n+SELECT * FROM test.v\n+----\n+\n+# after recreating the table, we can query the view again\n+statement ok\n+CREATE TABLE test.t (a INTEGER, b INTEGER);\n+\n+statement ok\n+SELECT * FROM test.t\n+\n+statement ok\n+SELECT * FROM test.v\n+\n+query IIIIII\n+PRAGMA table_info('test.v')\n+----\n+0\ta\tINTEGER\t0\tNULL\t0\n+1\tb\tINTEGER\t0\tNULL\t0\n+\n+# drop the table again\n+statement ok\n+DROP TABLE test.t\n+\n+statement error\n+SELECT * FROM test.v2\n+----\n+\n+endloop\n",
  "problem_statement": "CREATE OR REPLACE...AS no longer works if there are downstream views that reference the target table\n### What happens?\r\n\r\nhttps://github.com/duckdb/duckdb/pull/12159 has introduced the `DROP ... CASCADE` mechanics to drop entities that have downstream dependencies (like views).\r\n\r\nUnfortunately this broke the `CREATE OR REPLACE` queries which now fail with:\r\n```\r\nCannot drop entry... because there are entries that depend on it... Use DROP...CASCADE to drop all dependents.\r\n```\r\nwhen the target table or a view has a view downstream from it.\r\n\r\nThis behavior seems weird since the replacement suppose to happen atomically, as a single operation. Doesn't requiring the use of `DROP...CASCADE` defeat the purpose of `CREATE OR REPLACE`?\r\n\r\n### To Reproduce\r\n\r\n1. Create a table or a view.\r\n2. Create a view which references the table / view created in (1).\r\n3. Run `CREATE OR REPLACE ... AS SELECT ...` targeting the table / view created in (1).\r\n\r\n```\r\nIn [1]: import duckdb\r\n\r\nIn [2]: conn = duckdb.connect()\r\n\r\nIn [3]: conn.execute(\"CREATE OR REPLACE TABLE tbl_a  AS SELECT 1 AS a\")\r\nOut[3]: <duckdb.duckdb.DuckDBPyConnection at 0x102b7a8f0>\r\n\r\nIn [4]: conn.execute(\"CREATE OR REPLACE VIEW view_a AS SELECT * FROM tbl_a\")\r\nOut[4]: <duckdb.duckdb.DuckDBPyConnection at 0x102b7a8f0>\r\n\r\nIn [5]: conn.execute(\"CREATE OR REPLACE TABLE tbl_a  AS SELECT 2 AS a\")\r\n---------------------------------------------------------------------------\r\nError                                     Traceback (most recent call last)\r\nCell In[5], line 1\r\n----> 1 conn.execute(\"CREATE OR REPLACE TABLE tbl_a  AS SELECT 2 AS a\")\r\n\r\nError: Cannot drop entry \"tbl_a\" because there are entries that depend on it.\r\nview \"view_a\" depends on table \"tbl_a\".\r\nUse DROP...CASCADE to drop all dependents.\r\n```\r\n\r\n### OS:\r\n\r\nMacOS\r\n\r\n### DuckDB Version:\r\n\r\n0.10.3\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nIaroslav Zeigerman\r\n\r\n### Affiliation:\r\n\r\nTobikoData\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\n0.10.3\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNo - Other reason (please specify in the issue body)\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "That PR is not relevant here, this one is\r\nhttps://github.com/duckdb/duckdb/pull/11493\r\n\r\nViews create dependencies now\n> Doesn't requiring the use of `DROP...CASCADE` defeat the purpose of `CREATE OR REPLACE`\r\n\r\nI don't agree, I just think what is missing here is the option to provide `CASCADE` to `CREATE OR REPLACE`\r\nThey control two different intentions\r\n\r\nCREATE OR REPLACE indicates your intent to drop the table, it doesn't necessarily indicate your intent to drop the views/indexes/sequences, etc.. that have a dependency on the table\r\n\r\nWe could argue whether the VIEW should be recreated instead of dropped if CASCADE is provided, but that's a different discussion. I don't think performing a CASCADE implicitly when OR REPLACE is used is the right move\n> We could argue whether the VIEW should be recreated instead of dropped if CASCADE is provided, but that's a different discussion. I don't think performing a CASCADE implicitly when OR REPLACE is used is the right move\r\n\r\nI do believe that `CREATE OR REPLACE` should not be destructive towards downstream dependencies. With or without `CASCADE`. \r\n\r\nA typical use case for `CREATE OR REPLACE` is to atomically refresh the entire table / view without changing the schema and without exposing the clients to partial (empty) data caused by the intermediate table truncation step. Though the argument can be made that this can be achieved by doing these 2 steps as part of a transaction. But this doesn't help with views.\r\n\r\nAnother use case is to change both data and the schema of the table in a non-descrtuctive way.\r\n\r\nThe existing behavior renders the latter use cases impossible. Is there a way to disable binding for views and go back to previous behavior? ",
  "created_at": "2024-05-23T10:43:59Z"
}