{
  "repo": "duckdb/duckdb",
  "pull_number": 14113,
  "instance_id": "duckdb__duckdb-14113",
  "issue_numbers": [
    "14105"
  ],
  "base_commit": "b5743d080cf6e0988b30ef00c630c3f621803071",
  "patch": "diff --git a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\nindex 13acaffe5883..5850eb246267 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n@@ -324,7 +324,6 @@ struct DuckDBPyConnection : public enable_shared_from_this<DuckDBPyConnection> {\n \n private:\n \tPathLike GetPathLike(const py::object &object);\n-\tunique_lock<std::mutex> AcquireConnectionLock();\n \tScalarFunction CreateScalarUDF(const string &name, const py::function &udf, const py::object &parameters,\n \t                               const shared_ptr<DuckDBPyType> &return_type, bool vectorized,\n \t                               FunctionNullHandling null_handling, PythonExceptionHandling exception_handling,\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 7c52e0241502..39b8dcf30a32 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -416,6 +416,7 @@ void DuckDBPyConnection::Initialize(py::handle &m) {\n }\n \n shared_ptr<DuckDBPyConnection> DuckDBPyConnection::ExecuteMany(const py::object &query, py::object params_p) {\n+\tpy::gil_scoped_acquire gil;\n \tcon.SetResult(nullptr);\n \tif (params_p.is_none()) {\n \t\tparams_p = py::list();\n@@ -541,6 +542,7 @@ unique_ptr<PreparedStatement> DuckDBPyConnection::PrepareQuery(unique_ptr<SQLSta\n \tauto &connection = con.GetConnection();\n \tunique_ptr<PreparedStatement> prep;\n \t{\n+\t\tD_ASSERT(py::gil_check());\n \t\tpy::gil_scoped_release release;\n \t\tunique_lock<mutex> lock(py_connection_lock);\n \n@@ -561,6 +563,7 @@ unique_ptr<QueryResult> DuckDBPyConnection::ExecuteInternal(PreparedStatement &p\n \tauto named_values = TransformPreparedParameters(prep, params);\n \tunique_ptr<QueryResult> res;\n \t{\n+\t\tD_ASSERT(py::gil_check());\n \t\tpy::gil_scoped_release release;\n \t\tunique_lock<std::mutex> lock(py_connection_lock);\n \n@@ -598,6 +601,7 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::ExecuteFromString(const strin\n }\n \n shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Execute(const py::object &query, py::object params) {\n+\tpy::gil_scoped_acquire gil;\n \tcon.SetResult(nullptr);\n \n \tauto statements = GetStatements(query);\n@@ -877,6 +881,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadJSON(\n \t\tauto_detect = true;\n \t}\n \n+\tD_ASSERT(py::gil_check());\n \tpy::gil_scoped_release gil;\n \tauto read_json_relation =\n \t    make_shared_ptr<ReadJSONRelation>(connection.context, name, std::move(options), auto_detect);\n@@ -1387,6 +1392,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(const py::object &name_\n \n \t// Create the ReadCSV Relation using the 'options'\n \n+\tD_ASSERT(py::gil_check());\n \tpy::gil_scoped_release gil;\n \tauto read_csv_p = connection.ReadCSV(name, std::move(bind_parameters));\n \tauto &read_csv = read_csv_p->Cast<ReadCSVRelation>();\n@@ -1399,6 +1405,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(const py::object &name_\n \n void DuckDBPyConnection::ExecuteImmediately(vector<unique_ptr<SQLStatement>> statements) {\n \tauto &connection = con.GetConnection();\n+\tD_ASSERT(py::gil_check());\n \tpy::gil_scoped_release release;\n \tif (statements.empty()) {\n \t\treturn;\n@@ -1443,6 +1450,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::RunQuery(const py::object &quer\n \tif (py::none().is(params)) {\n \t\t// FIXME: currently we can't create relations with prepared parameters\n \t\t{\n+\t\t\tD_ASSERT(py::gil_check());\n \t\t\tpy::gil_scoped_release gil;\n \t\t\tauto statement_type = last_statement->type;\n \t\t\tswitch (statement_type) {\n@@ -1557,6 +1565,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromParquet(const string &file_\n \t\t}\n \t\tnamed_parameters[\"compression\"] = Value(py::str(compression));\n \t}\n+\tD_ASSERT(py::gil_check());\n \tpy::gil_scoped_release gil;\n \treturn make_uniq<DuckDBPyRelation>(connection.TableFunction(\"parquet_scan\", params, named_parameters)->Alias(name));\n }\n@@ -1646,6 +1655,7 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::UnregisterPythonObject(const\n \tif (!registered_objects.count(name)) {\n \t\treturn shared_from_this();\n \t}\n+\tD_ASSERT(py::gil_check());\n \tpy::gil_scoped_release release;\n \t// FIXME: DROP TEMPORARY VIEW? doesn't exist?\n \tconnection.Query(\"DROP VIEW \\\"\" + name + \"\\\"\");\n@@ -1691,6 +1701,8 @@ int DuckDBPyConnection::GetRowcount() {\n \n void DuckDBPyConnection::Close() {\n \tcon.SetResult(nullptr);\n+\tD_ASSERT(py::gil_check());\n+\tpy::gil_scoped_release release;\n \tcon.SetConnection(nullptr);\n \tcon.SetDatabase(nullptr);\n \t// https://peps.python.org/pep-0249/#Connection.close\n@@ -1783,6 +1795,9 @@ void DuckDBPyConnection::Cursors::ClearCursors() {\n \t\t\t// The cursor has already been closed\n \t\t\tcontinue;\n \t\t}\n+\t\t// This is *only* needed because we have a py::gil_scoped_release in Close, so it *needs* the GIL in order to\n+\t\t// release it don't ask me why it can't just realize there is no GIL and move on\n+\t\tpy::gil_scoped_acquire gil;\n \t\tcursor->Close();\n \t}\n \n@@ -1939,6 +1954,7 @@ static shared_ptr<DuckDBPyConnection> FetchOrCreateInstance(const string &databa\n \tbool cache_instance = database_path != \":memory:\" && !database_path.empty();\n \tconfig.replacement_scans.emplace_back(PythonReplacementScan::Replace);\n \t{\n+\t\tD_ASSERT(py::gil_check());\n \t\tpy::gil_scoped_release release;\n \t\tunique_lock<mutex> lock(res->py_connection_lock);\n \t\tauto database =\n@@ -2195,14 +2211,4 @@ bool DuckDBPyConnection::IsAcceptedArrowObject(const py::object &object) {\n \treturn DuckDBPyConnection::GetArrowType(object) != PyArrowObjectType::Invalid;\n }\n \n-unique_lock<std::mutex> DuckDBPyConnection::AcquireConnectionLock() {\n-\t// we first release the gil and then acquire the connection lock\n-\tunique_lock<std::mutex> lock(py_connection_lock, std::defer_lock);\n-\t{\n-\t\tpy::gil_scoped_release release;\n-\t\tlock.lock();\n-\t}\n-\treturn lock;\n-}\n-\n } // namespace duckdb\ndiff --git a/tools/pythonpkg/src/pyrelation.cpp b/tools/pythonpkg/src/pyrelation.cpp\nindex 9775deb9c110..b89a8e74479e 100644\n--- a/tools/pythonpkg/src/pyrelation.cpp\n+++ b/tools/pythonpkg/src/pyrelation.cpp\n@@ -58,10 +58,8 @@ bool DuckDBPyRelation::CanBeRegisteredBy(shared_ptr<ClientContext> &con) {\n }\n \n DuckDBPyRelation::~DuckDBPyRelation() {\n-\t// FIXME: It makes sense to release the GIL here, but it causes a crash\n-\t// because pybind11's gil_scoped_acquire and gil_scoped_release can not be nested\n-\t// The Relation will need to call the destructor of the ExternalDependency, which might need to hold the GIL\n-\t// py::gil_scoped_release gil;\n+\tD_ASSERT(py::gil_check());\n+\tpy::gil_scoped_release gil;\n \trel.reset();\n }\n \n@@ -780,6 +778,7 @@ static unique_ptr<QueryResult> PyExecuteRelation(const shared_ptr<Relation> &rel\n \t\treturn nullptr;\n \t}\n \tauto context = rel->context.GetContext();\n+\tD_ASSERT(py::gil_check());\n \tpy::gil_scoped_release release;\n \tauto pending_query = context->PendingQuery(rel, stream_result);\n \treturn DuckDBPyConnection::CompletePendingQuery(*pending_query);\n@@ -791,6 +790,7 @@ unique_ptr<QueryResult> DuckDBPyRelation::ExecuteInternal(bool stream_result) {\n }\n \n void DuckDBPyRelation::ExecuteOrThrow(bool stream_result) {\n+\tpy::gil_scoped_acquire gil;\n \tresult.reset();\n \tauto query_result = ExecuteInternal(stream_result);\n \tif (!query_result) {\n@@ -1358,6 +1358,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyRelation::Query(const string &view_name, co\n \t\treturn Query(view_name, query);\n \t}\n \t{\n+\t\tD_ASSERT(py::gil_check());\n \t\tpy::gil_scoped_release release;\n \t\tauto query_result = rel->context.GetContext()->Query(std::move(parser.statements[0]), false);\n \t\t// Execute it anyways, for creation/altering statements\n@@ -1394,6 +1395,7 @@ void DuckDBPyRelation::Insert(const py::object &params) {\n \t}\n \tvector<vector<Value>> values {DuckDBPyConnection::TransformPythonParamList(params)};\n \n+\tD_ASSERT(py::gil_check());\n \tpy::gil_scoped_release release;\n \trel->Insert(values);\n }\n@@ -1500,6 +1502,7 @@ static void DisplayHTML(const string &html) {\n \n string DuckDBPyRelation::Explain(ExplainType type) {\n \tAssertRelation();\n+\tD_ASSERT(py::gil_check());\n \tpy::gil_scoped_release release;\n \n \tauto explain_format = GetExplainFormat(type);\ndiff --git a/tools/pythonpkg/src/pyresult.cpp b/tools/pythonpkg/src/pyresult.cpp\nindex b6ba40315b9e..13d741eff065 100644\n--- a/tools/pythonpkg/src/pyresult.cpp\n+++ b/tools/pythonpkg/src/pyresult.cpp\n@@ -31,6 +31,7 @@ DuckDBPyResult::DuckDBPyResult(unique_ptr<QueryResult> result_p) : result(std::m\n \n DuckDBPyResult::~DuckDBPyResult() {\n \ttry {\n+\t\tD_ASSERT(py::gil_check());\n \t\tpy::gil_scoped_release gil;\n \t\tresult.reset();\n \t\tcurrent_chunk.reset();\n@@ -109,6 +110,7 @@ unique_ptr<DataChunk> DuckDBPyResult::FetchNextRaw(QueryResult &query_result) {\n \n Optional<py::tuple> DuckDBPyResult::Fetchone() {\n \t{\n+\t\tD_ASSERT(py::gil_check());\n \t\tpy::gil_scoped_release release;\n \t\tif (!result) {\n \t\t\tthrow InvalidInputException(\"result closed\");\n@@ -246,6 +248,7 @@ py::dict DuckDBPyResult::FetchNumpyInternal(bool stream, idx_t vectors_per_chunk\n \t\t\t}\n \t\t\tunique_ptr<DataChunk> chunk;\n \t\t\t{\n+\t\t\t\tD_ASSERT(py::gil_check());\n \t\t\t\tpy::gil_scoped_release release;\n \t\t\t\tchunk = FetchNextRaw(stream_result);\n \t\t\t}\n@@ -339,6 +342,7 @@ bool DuckDBPyResult::FetchArrowChunk(ChunkScanState &scan_state, py::list &batch\n \tidx_t count;\n \tauto &query_result = *result.get();\n \t{\n+\t\tD_ASSERT(py::gil_check());\n \t\tpy::gil_scoped_release release;\n \t\tcount = ArrowUtil::FetchChunk(scan_state, query_result.client_properties, rows_per_batch, &data);\n \t}\ndiff --git a/tools/pythonpkg/src/python_udf.cpp b/tools/pythonpkg/src/python_udf.cpp\nindex 8cac9a0d0d4e..7667c3ba21e4 100644\n--- a/tools/pythonpkg/src/python_udf.cpp\n+++ b/tools/pythonpkg/src/python_udf.cpp\n@@ -68,6 +68,7 @@ void AreExtensionsRegistered(const LogicalType &arrow_type, const LogicalType &d\n static void ConvertArrowTableToVector(const py::object &table, Vector &out, ClientContext &context, idx_t count) {\n \t// Create the stream factory from the Table object\n \tauto ptr = table.ptr();\n+\tD_ASSERT(py::gil_check());\n \tpy::gil_scoped_release gil;\n \n \tauto stream_factory = make_uniq<PythonTableArrowArrayStreamFactory>(ptr, context.GetClientProperties());\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/arrow/test_polars.py b/tools/pythonpkg/tests/fast/arrow/test_polars.py\nindex d61cd11d7203..1238bd3ec10e 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_polars.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_polars.py\n@@ -67,7 +67,9 @@ def test_polars_from_json(self, duckdb_cursor):\n         res = duckdb_cursor.read_json(string).pl()\n         assert str(res['entry'][0][0]) == \"{'content': {'ManagedSystem': {'test': None}}}\"\n \n-    @pytest.mark.skipif(sys.version_info < (3, 8), reason=\"Polars PanicException is not supported in earlier versions\")\n+    @pytest.mark.skipif(\n+        not hasattr(pl.exceptions, \"PanicException\"), reason=\"Polars has no PanicException in this version\"\n+    )\n     def test_polars_from_json_error(self, duckdb_cursor):\n         from io import StringIO\n \n",
  "problem_statement": "Unit tests of built Python package fail on OSX (in conda-forge build)\n### What happens?\n\nRunning the unit tests with a built `python-duckdb` on conda-forge fails with a segmentation fault in the `tools/pythonpkg/tests/fast/test_filesystem.py::TestPythonFilesystem::test_database_attach`\r\n\r\nSee the following stack trace:\r\n\r\n```\r\ntools/pythonpkg/tests/fast/test_filesystem.py::TestPythonFilesystem::test_database_attach Assertion failed: (!py::gil_check()), function Seek, file src/pyfilesystem.cpp, line 156.\r\nProcess 42452 stopped\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = hit program assert\r\n    frame #4: 0x0000000106c640ec duckdb.cpython-311-darwin.so`duckdb::PythonFilesystem::Seek(duckdb::FileHandle&, unsigned long long) + 212\r\nduckdb.cpython-311-darwin.so`duckdb::PythonFilesystem::Seek:\r\n->  0x106c640ec <+212>: mov    w0, #0x1 ; =1\r\n    0x106c640f0 <+216>: bl     0x106cc0fc0    ; symbol stub for: PyErr_PrintEx\r\n    0x106c640f4 <+220>: mov    w0, #0x10 ; =16\r\n    0x106c640f8 <+224>: bl     0x106cc1bd8    ; symbol stub for: __cxa_allocate_exception\r\nTarget 0: (python) stopped.\r\n(lldb) bt all\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = hit program assert\r\n    frame #0: 0x000000018a0655d0 libsystem_kernel.dylib`__pthread_kill + 8\r\n    frame #1: 0x000000018a09dc20 libsystem_pthread.dylib`pthread_kill + 288\r\n    frame #2: 0x0000000189faaa30 libsystem_c.dylib`abort + 180\r\n    frame #3: 0x0000000189fa9d20 libsystem_c.dylib`__assert_rtn + 284\r\n  * frame #4: 0x0000000106c640ec duckdb.cpython-311-darwin.so`duckdb::PythonFilesystem::Seek(duckdb::FileHandle&, unsigned long long) + 212\r\n    frame #5: 0x0000000106c635cc duckdb.cpython-311-darwin.so`duckdb::PythonFilesystem::Write(duckdb::FileHandle&, void*, long long, unsigned long long) + 48\r\n    frame #6: 0x0000000106a4f238 duckdb.cpython-311-darwin.so`duckdb::BlockManager::ConvertToPersistent(long long, duckdb::shared_ptr<duckdb::BlockHandle, true>) + 668\r\n    frame #7: 0x0000000106b19c8c duckdb.cpython-311-darwin.so`duckdb::ColumnSegment::ConvertToPersistent(duckdb::optional_ptr<duckdb::BlockManager, true>, long long) + 124\r\n    frame #8: 0x0000000106b1991c duckdb.cpython-311-darwin.so`duckdb::PartialBlockForCheckpoint::Flush(unsigned long long) + 360\r\n    frame #9: 0x0000000106a11f04 duckdb.cpython-311-darwin.so`duckdb::SingleFileCheckpointWriter::WriteTable(duckdb::TableCatalogEntry&, duckdb::Serializer&) + 444\r\n    frame #10: 0x0000000106a0f308 duckdb.cpython-311-darwin.so`duckdb::SingleFileCheckpointWriter::CreateCheckpoint() + 2656\r\n    frame #11: 0x0000000106a27a24 duckdb.cpython-311-darwin.so`duckdb::SingleFileStorageManager::CreateCheckpoint(duckdb::CheckpointOptions) + 484\r\n    frame #12: 0x00000001066ef59c duckdb.cpython-311-darwin.so`duckdb::AttachedDatabase::Close() + 304\r\n    frame #13: 0x000000010670865c duckdb.cpython-311-darwin.so`duckdb::DatabaseManager::ResetDatabases(duckdb::unique_ptr<duckdb::TaskScheduler, std::__1::default_delete<duckdb::TaskScheduler>, true>&) + 156\r\n    frame #14: 0x0000000106708370 duckdb.cpython-311-darwin.so`duckdb::DatabaseInstance::~DatabaseInstance() + 40\r\n    frame #15: 0x00000001067741d4 duckdb.cpython-311-darwin.so`std::__1::__shared_ptr_emplace<duckdb::DuckDB, std::__1::allocator<duckdb::DuckDB>>::__on_zero_shared() + 64\r\n    frame #16: 0x0000000106c1ca1c duckdb.cpython-311-darwin.so`duckdb::DuckDBPyConnection::Close() + 100\r\n    frame #17: 0x0000000106c1c7f4 duckdb.cpython-311-darwin.so`duckdb::DuckDBPyConnection::Exit(duckdb::DuckDBPyConnection&, pybind11::object const&, pybind11::object const&, pybind11::object const&) + 24\r\n    frame #18: 0x0000000106c4d92c duckdb.cpython-311-darwin.so`void pybind11::cpp_function::initialize<void (*&)(duckdb::DuckDBPyConnection&, pybind11::object const&, pybind11::object const&, pybind11::object const&), void, duckdb::DuckDBPyConnection&, pybind11::object const&, pybind11::object const&, pybind11::object const&, pybind11::name, pybind11::is_method, pybind11::sibling, pybind11::arg, pybind11::arg, pybind11::arg>(void (*&)(duckdb::DuckDBPyConnection&, pybind11::object const&, pybind11::object const&, pybind11::object const&), void (*)(duckdb::DuckDBPyConnection&, pybind11::object const&, pybind11::object const&, pybind11::object const&), pybind11::name const&, pybind11::is_method const&, pybind11::sibling const&, pybind11::arg const&, pybind11::arg const&, pybind11::arg const&)::'lambda'(pybind11::detail::function_call&)::operator()(pybind11::detail::function_call&) const + 140\r\n    frame #19: 0x0000000106c4d878 duckdb.cpython-311-darwin.so`void pybind11::cpp_function::initialize<void (*&)(duckdb::DuckDBPyConnection&, pybind11::object const&, pybind11::object const&, pybind11::object const&), void, duckdb::DuckDBPyConnection&, pybind11::object const&, pybind11::object const&, pybind11::object const&, pybind11::name, pybind11::is_method, pybind11::sibling, pybind11::arg, pybind11::arg, pybind11::arg>(void (*&)(duckdb::DuckDBPyConnection&, pybind11::object const&, pybind11::object const&, pybind11::object const&), void (*)(duckdb::DuckDBPyConnection&, pybind11::object const&, pybind11::object const&, pybind11::object const&), pybind11::name const&, pybind11::is_method const&, pybind11::sibling const&, pybind11::arg const&, pybind11::arg const&, pybind11::arg const&)::'lambda'(pybind11::detail::function_call&)::__invoke(pybind11::detail::function_call&) + 40\r\n    frame #20: 0x0000000106b755a8 duckdb.cpython-311-darwin.so`pybind11::cpp_function::dispatcher(_object*, _object*, _object*) + 4312\r\n    frame #21: 0x00000001000b7f4c python`cfunction_call + 124\r\n    frame #22: 0x00000001000606f0 python`_PyObject_MakeTpCall + 332\r\n    frame #23: 0x0000000100064200 python`method_vectorcall + 276\r\n    frame #24: 0x0000000100060ffc python`PyObject_Vectorcall + 76\r\n    frame #25: 0x0000000100162e3c python`_PyEval_EvalFrameDefault + 46484\r\n    frame #26: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #27: 0x0000000100064198 python`method_vectorcall + 172\r\n    frame #28: 0x0000000100060e68 python`_PyVectorcall_Call + 132\r\n    frame #29: 0x0000000100164dac python`_PyEval_EvalFrameDefault + 54532\r\n    frame #30: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #31: 0x0000000100164dac python`_PyEval_EvalFrameDefault + 54532\r\n    frame #32: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #33: 0x00000001000608b8 python`_PyObject_FastCallDictTstate + 156\r\n    frame #34: 0x00000001000617f0 python`_PyObject_Call_Prepend + 176\r\n    frame #35: 0x00000001000db278 python`slot_tp_call + 172\r\n    frame #36: 0x00000001000606f0 python`_PyObject_MakeTpCall + 332\r\n    frame #37: 0x0000000100162e3c python`_PyEval_EvalFrameDefault + 46484\r\n    frame #38: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #39: 0x0000000100164dac python`_PyEval_EvalFrameDefault + 54532\r\n    frame #40: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #41: 0x00000001000608b8 python`_PyObject_FastCallDictTstate + 156\r\n    frame #42: 0x00000001000617f0 python`_PyObject_Call_Prepend + 176\r\n    frame #43: 0x00000001000db278 python`slot_tp_call + 172\r\n    frame #44: 0x000000010006126c python`_PyObject_Call + 236\r\n    frame #45: 0x0000000100164dac python`_PyEval_EvalFrameDefault + 54532\r\n    frame #46: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #47: 0x0000000100164dac python`_PyEval_EvalFrameDefault + 54532\r\n    frame #48: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #49: 0x0000000100164dac python`_PyEval_EvalFrameDefault + 54532\r\n    frame #50: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #51: 0x00000001000608b8 python`_PyObject_FastCallDictTstate + 156\r\n    frame #52: 0x00000001000617f0 python`_PyObject_Call_Prepend + 176\r\n    frame #53: 0x00000001000db278 python`slot_tp_call + 172\r\n    frame #54: 0x00000001000606f0 python`_PyObject_MakeTpCall + 332\r\n    frame #55: 0x0000000100162e3c python`_PyEval_EvalFrameDefault + 46484\r\n    frame #56: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #57: 0x0000000100164dac python`_PyEval_EvalFrameDefault + 54532\r\n    frame #58: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #59: 0x00000001000608b8 python`_PyObject_FastCallDictTstate + 156\r\n    frame #60: 0x00000001000617f0 python`_PyObject_Call_Prepend + 176\r\n    frame #61: 0x00000001000db278 python`slot_tp_call + 172\r\n    frame #62: 0x00000001000606f0 python`_PyObject_MakeTpCall + 332\r\n    frame #63: 0x0000000100162e3c python`_PyEval_EvalFrameDefault + 46484\r\n    frame #64: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #65: 0x0000000100164dac python`_PyEval_EvalFrameDefault + 54532\r\n    frame #66: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #67: 0x00000001000608b8 python`_PyObject_FastCallDictTstate + 156\r\n    frame #68: 0x00000001000617f0 python`_PyObject_Call_Prepend + 176\r\n    frame #69: 0x00000001000db278 python`slot_tp_call + 172\r\n    frame #70: 0x00000001000606f0 python`_PyObject_MakeTpCall + 332\r\n    frame #71: 0x0000000100162e3c python`_PyEval_EvalFrameDefault + 46484\r\n    frame #72: 0x00000001001568f4 python`PyEval_EvalCode + 220\r\n    frame #73: 0x00000001001526a4 python`builtin_exec + 1156\r\n    frame #74: 0x00000001000b8c68 python`cfunction_vectorcall_FASTCALL_KEYWORDS + 168\r\n    frame #75: 0x0000000100060ffc python`PyObject_Vectorcall + 76\r\n    frame #76: 0x0000000100162e3c python`_PyEval_EvalFrameDefault + 46484\r\n    frame #77: 0x00000001001674c8 python`_PyEval_Vector + 184\r\n    frame #78: 0x00000001001e2588 python`pymain_run_module + 272\r\n    frame #79: 0x00000001001e1f74 python`Py_RunMain + 2476\r\n    frame #80: 0x00000001001e3050 python`pymain_main + 1252\r\n    frame #81: 0x0000000100003398 python`main + 56\r\n    frame #82: 0x0000000189d13154 dyld`start + 2476\r\n  thread #2\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #3\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #4\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #5\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #6\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #7\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #8\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #9\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #10\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #11\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #12\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #13\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #14\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #15\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #16\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #17\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #18\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #19\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #20\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #21\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #22\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n  thread #23\r\n    frame #0: 0x000000018a05cd50 libsystem_kernel.dylib`semaphore_wait_trap + 8\r\n    frame #1: 0x0000000106898230 duckdb.cpython-311-darwin.so`duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) + 608\r\n    frame #2: 0x000000010689ecec duckdb.cpython-311-darwin.so`void* std::__1::__thread_proxy[abi:ue170006]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>>(void*) + 72\r\n    frame #3: 0x000000018a09df94 libsystem_pthread.dylib`_pthread_start + 136\r\n(lldb)\r\n```\n\n### To Reproduce\n\nTo reproduce, you can build the conda-forge feedstock from the PR in https://github.com/conda-forge/python-duckdb-feedstock/pull/114 using `conda-build -m .ci_support/osx_arm64_python3.11.____cpython.yaml recipe`\n\n### OS:\n\nOSX\n\n### DuckDB Version:\n\n1.1.1\n\n### DuckDB Client:\n\nPython\n\n### Hardware:\n\nOSX (all architectures)\n\n### Full Name:\n\nUwe Korn\n\n### Affiliation:\n\nconda-forge (in this case)\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "@xhochy thanks, we'll take a look!",
  "created_at": "2024-09-25T09:30:15Z"
}