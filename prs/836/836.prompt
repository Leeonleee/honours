You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
R: Rethink src_duckdb()?
In recent dbplyr, connections (of class `"DBIConnection"`) can be used interchangeably with objects of class `"src"`. Do we still need `src_duckdb()`?

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="30">
2: 
3: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of examples/R/dplyr.R]
1: library("DBI")
2: library("dplyr")
3: 
4: dsrc <- duckdb::src_duckdb()
5: 
6: # taken from the dbplyr vignette
7: # https://cran.r-project.org/web/packages/dbplyr/vignettes/dbplyr.html
8: 
9: copy_to(dsrc, nycflights13::flights, "flights", temporary = FALSE)
10: 
11: flights_db <- tbl(dsrc, "flights")
12: 
13: flights_db %>%
14:   group_by(dest) %>%
15:   summarise(delay = mean(dep_time))
16: 
[end of examples/R/dplyr.R]
[start of tools/rpkg/NAMESPACE]
1: # Generated by roxygen2: do not edit by hand
2: 
3: export(duckdb)
4: export(duckdb_register)
5: export(duckdb_shutdown)
6: export(duckdb_unregister)
7: export(read_csv_duckdb)
8: export(src_duckdb)
9: exportClasses(duckdb_connection)
10: exportClasses(duckdb_driver)
11: exportClasses(duckdb_result)
12: exportMethods(dbBegin)
13: exportMethods(dbBind)
14: exportMethods(dbClearResult)
15: exportMethods(dbColumnInfo)
16: exportMethods(dbCommit)
17: exportMethods(dbConnect)
18: exportMethods(dbDataType)
19: exportMethods(dbDisconnect)
20: exportMethods(dbExistsTable)
21: exportMethods(dbFetch)
22: exportMethods(dbGetInfo)
23: exportMethods(dbGetRowCount)
24: exportMethods(dbGetRowsAffected)
25: exportMethods(dbGetStatement)
26: exportMethods(dbHasCompleted)
27: exportMethods(dbIsValid)
28: exportMethods(dbListFields)
29: exportMethods(dbListTables)
30: exportMethods(dbRemoveTable)
31: exportMethods(dbRollback)
32: exportMethods(dbSendQuery)
33: exportMethods(dbWriteTable)
34: exportMethods(show)
35: import(DBI)
36: import(methods)
37: importFrom(DBI,dbConnect)
38: importFrom(utils,head)
39: useDynLib(duckdb, .registration = TRUE)
[end of tools/rpkg/NAMESPACE]
[start of tools/rpkg/R/Driver.R]
1: DBDIR_MEMORY <- ":memory:"
2: 
3: #' @title DuckDB Driver
4: #'
5: #' @description A DuckDB database instance.
6: #'
7: #' @param dbdir The file in which the DuckDB database should be stored
8: #' @param read_only Whether the database file should be opened in read-only mode
9: #'
10: #' @name duckdb_driver
11: #' @import methods DBI
12: #' @export
13: #' @examples
14: #' \dontrun{
15: #' duckdb::duckdb()
16: #' }
17: #'
18: duckdb <- function(dbdir = DBDIR_MEMORY, read_only = FALSE) {
19:   check_flag(read_only)
20:   new(
21:     "duckdb_driver",
22:     database_ref = .Call(duckdb_startup_R, dbdir, read_only),
23:     dbdir = dbdir,
24:     read_only = read_only
25:   )
26: }
27: 
28: check_flag <- function(x) {
29:   if (is.null(x) || length(x) != 1 || is.na(x) || !is.logical(x)) {
30:     stop("flags need to be scalar logicals")
31:   }
32: }
33: 
34: #' @rdname duckdb_driver
35: #' @export
36: setClass("duckdb_driver", contains = "DBIDriver", slots = list(database_ref = "externalptr", dbdir = "character", read_only = "logical"))
37: 
38: extptr_str <- function(e, n = 5) {
39:   x <- .Call(duckdb_ptr_to_str, e)
40:   substr(x, nchar(x) - n + 1, nchar(x))
41: }
42: 
43: drv_to_string <- function(drv) {
44:   if (!is(drv, "duckdb_driver")) {
45:     stop("pass a duckdb_driver object")
46:   }
47:   sprintf("<duckdb_driver %s dbdir='%s' read_only=%s>", extptr_str(drv@database_ref), drv@dbdir, drv@read_only)
48: }
49: 
50: #' @rdname duckdb_driver
51: #' @inheritParams methods::show
52: #' @export
53: setMethod(
54:   "show", "duckdb_driver",
55:   function(object) {
56:     cat(drv_to_string(object))
57:     cat("\n")
58:   }
59: )
60: 
61: #' @rdname duckdb_driver
62: #' @inheritParams DBI::dbConnect
63: #' @param debug Print additional debug information such as queries
64: #' @export
65: setMethod(
66:   "dbConnect", "duckdb_driver",
67:   function(drv, dbdir = DBDIR_MEMORY, ..., debug = getOption("duckdb.debug", FALSE), read_only = FALSE) {
68: 
69:     check_flag(debug)
70: 
71:     missing_dbdir <- missing(dbdir)
72:     dbdir <- path.expand(as.character(dbdir))
73: 
74: 
75:     # aha, a late comer. let's make a new instance.
76:     if (!missing_dbdir && dbdir != drv@dbdir) {
77:       duckdb_shutdown(drv)
78:       drv <- duckdb(dbdir, read_only)
79:     }
80: 
81:     duckdb_connection(drv, debug = debug)
82:   }
83: )
84: 
85: #' @rdname duckdb_driver
86: #' @inheritParams DBI::dbDataType
87: #' @export
88: setMethod(
89:   "dbDataType", "duckdb_driver",
90:   function(dbObj, obj, ...) {
91: 
92:     if (is.null(obj)) stop("NULL parameter")
93:     if (is.data.frame(obj)) {
94:       return(vapply(obj, function(x) dbDataType(dbObj, x), FUN.VALUE = "character"))
95:     }
96:     #  else if (int64 && inherits(obj, "integer64")) "BIGINT"
97:     else if (inherits(obj, "Date")) {
98:       "DATE"
99:     } else if (inherits(obj, "difftime")) {
100:       "TIME"
101:     } else if (is.logical(obj)) {
102:       "BOOLEAN"
103:     } else if (is.integer(obj)) {
104:       "INTEGER"
105:     } else if (is.numeric(obj)) {
106:       "DOUBLE"
107:     } else if (inherits(obj, "POSIXt")) {
108:       "TIMESTAMP"
109:     } else if (is.list(obj) && all(vapply(obj, typeof, FUN.VALUE = "character") == "raw" || is.na(obj))) {
110:       "BLOB"
111:     } else {
112:       "STRING"
113:     }
114: 
115:   }
116: )
117: 
118: #' @rdname duckdb_driver
119: #' @inheritParams DBI::dbIsValid
120: #' @export
121: setMethod(
122:   "dbIsValid", "duckdb_driver",
123:   function(dbObj, ...) {
124:     valid <- FALSE
125:     tryCatch(
126:       {
127:         con <- dbConnect(dbObj)
128:         dbExecute(con, SQL("SELECT 1"))
129:         dbDisconnect(con)
130:         valid <- TRUE
131:       },
132:       error = function(c) {
133:       }
134:     )
135:     valid
136:   }
137: )
138: 
139: #' @rdname duckdb_driver
140: #' @inheritParams DBI::dbGetInfo
141: #' @export
142: setMethod(
143:   "dbGetInfo", "duckdb_driver",
144:   function(dbObj, ...) {
145:     list(driver.version = NA, client.version = NA)
146:   }
147: )
148: 
149: 
150: #' @rdname duckdb_driver
151: #' @export
152: duckdb_shutdown <- function(drv) {
153:   if (!is(drv, "duckdb_driver")) {
154:     stop("pass a duckdb_driver object")
155:   }
156:   if (!dbIsValid(drv)) {
157:     warning("invalid driver object, already closed?")
158:     invisible(FALSE)
159:   }
160:   .Call(duckdb_shutdown_R, drv@database_ref)
161:   invisible(TRUE)
162: }
163: 
164: is_installed <- function(pkg) {
165:   as.logical(requireNamespace(pkg, quietly = TRUE)) == TRUE
166: }
167: 
168: 
169: #' @importFrom DBI dbConnect
170: #' @param path The file in which the DuckDB database should be stored
171: #' @param create Create a new database if none is present in `path`
172: #' @rdname duckdb_driver
173: #' @export
174: src_duckdb <- function(path = ":memory:", create = FALSE, read_only = FALSE) {
175:   requireNamespace("dbplyr", quietly = TRUE)
176:   if (path != ":memory:" && !create && !file.exists(path)) {
177:     stop("`path` '", path, "' must already exist, unless `create` = TRUE")
178:   }
179:   con <- DBI::dbConnect(duckdb::duckdb(), path, read_only = read_only)
180:   dbplyr::src_dbi(con, auto_disconnect = TRUE)
181: }
[end of tools/rpkg/R/Driver.R]
[start of tools/rpkg/man/duckdb_driver.Rd]
1: % Generated by roxygen2: do not edit by hand
2: % Please edit documentation in R/Driver.R
3: \docType{class}
4: \name{duckdb_driver}
5: \alias{duckdb_driver}
6: \alias{duckdb}
7: \alias{duckdb_driver-class}
8: \alias{show,duckdb_driver-method}
9: \alias{dbConnect,duckdb_driver-method}
10: \alias{dbDataType,duckdb_driver-method}
11: \alias{dbIsValid,duckdb_driver-method}
12: \alias{dbGetInfo,duckdb_driver-method}
13: \alias{duckdb_shutdown}
14: \alias{src_duckdb}
15: \title{DuckDB Driver}
16: \usage{
17: duckdb(dbdir = DBDIR_MEMORY, read_only = FALSE)
18: 
19: \S4method{show}{duckdb_driver}(object)
20: 
21: \S4method{dbConnect}{duckdb_driver}(
22:   drv,
23:   dbdir = DBDIR_MEMORY,
24:   ...,
25:   debug = getOption("duckdb.debug", FALSE),
26:   read_only = FALSE
27: )
28: 
29: \S4method{dbDataType}{duckdb_driver}(dbObj, obj, ...)
30: 
31: \S4method{dbIsValid}{duckdb_driver}(dbObj, ...)
32: 
33: \S4method{dbGetInfo}{duckdb_driver}(dbObj, ...)
34: 
35: duckdb_shutdown(drv)
36: 
37: src_duckdb(path = ":memory:", create = FALSE, read_only = FALSE)
38: }
39: \arguments{
40: \item{dbdir}{The file in which the DuckDB database should be stored}
41: 
42: \item{read_only}{Whether the database file should be opened in read-only mode}
43: 
44: \item{object}{Any R object}
45: 
46: \item{drv}{an object that inherits from \linkS4class{DBIDriver},
47: or an existing \linkS4class{DBIConnection}
48: object (in order to clone an existing connection).}
49: 
50: \item{...}{authentication arguments needed by the DBMS instance; these
51: typically include \code{user}, \code{password}, \code{host}, \code{port}, \code{dbname}, etc.
52: For details see the appropriate \code{DBIDriver}.}
53: 
54: \item{debug}{Print additional debug information such as queries}
55: 
56: \item{dbObj}{A object inheriting from \linkS4class{DBIDriver}
57: or \linkS4class{DBIConnection}}
58: 
59: \item{obj}{An R object whose SQL type we want to determine.}
60: 
61: \item{path}{The file in which the DuckDB database should be stored}
62: 
63: \item{create}{Create a new database if none is present in `path`}
64: }
65: \description{
66: A DuckDB database instance.
67: }
68: \examples{
69: \dontrun{
70: duckdb::duckdb()
71: }
72: 
73: }
[end of tools/rpkg/man/duckdb_driver.Rd]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: