{
  "repo": "duckdb/duckdb",
  "pull_number": 14332,
  "instance_id": "duckdb__duckdb-14332",
  "issue_numbers": [
    "14207"
  ],
  "base_commit": "c4a0f6f9f154225b41e1f337f4079e70d6a0ea24",
  "patch": "diff --git a/extension/httpfs/create_secret_functions.cpp b/extension/httpfs/create_secret_functions.cpp\nindex daf000ab85dd..bcfdd82c3115 100644\n--- a/extension/httpfs/create_secret_functions.cpp\n+++ b/extension/httpfs/create_secret_functions.cpp\n@@ -60,13 +60,13 @@ unique_ptr<BaseSecret> CreateS3SecretFunctions::CreateSecretFunctionInternal(Cli\n \t\t\t\tthrow InvalidInputException(\"Invalid type past to secret option: '%s', found '%s', expected: 'BOOLEAN'\",\n \t\t\t\t                            lower_name, named_param.second.type().ToString());\n \t\t\t}\n-\t\t\tsecret->secret_map[\"use_ssl\"] = named_param.second.GetValue<bool>();\n+\t\t\tsecret->secret_map[\"use_ssl\"] = Value::BOOLEAN(named_param.second.GetValue<bool>());\n \t\t} else if (lower_name == \"url_compatibility_mode\") {\n \t\t\tif (named_param.second.type() != LogicalType::BOOLEAN) {\n \t\t\t\tthrow InvalidInputException(\"Invalid type past to secret option: '%s', found '%s', expected: 'BOOLEAN'\",\n \t\t\t\t                            lower_name, named_param.second.type().ToString());\n \t\t\t}\n-\t\t\tsecret->secret_map[\"url_compatibility_mode\"] = named_param.second.GetValue<bool>();\n+\t\t\tsecret->secret_map[\"url_compatibility_mode\"] = Value::BOOLEAN(named_param.second.GetValue<bool>());\n \t\t} else if (lower_name == \"account_id\") {\n \t\t\tcontinue; // handled already\n \t\t} else {\ndiff --git a/src/function/table/system/duckdb_secrets.cpp b/src/function/table/system/duckdb_secrets.cpp\nindex 44557e349426..6069344bfaed 100644\n--- a/src/function/table/system/duckdb_secrets.cpp\n+++ b/src/function/table/system/duckdb_secrets.cpp\n@@ -107,13 +107,21 @@ void DuckDBSecretsFunction(ClientContext &context, TableFunctionInput &data_p, D\n \n \t\tconst auto &secret = *secret_entry.secret;\n \n-\t\toutput.SetValue(0, count, secret.GetName());\n-\t\toutput.SetValue(1, count, Value(secret.GetType()));\n-\t\toutput.SetValue(2, count, Value(secret.GetProvider()));\n-\t\toutput.SetValue(3, count, Value(secret_entry.persist_type == SecretPersistType::PERSISTENT));\n-\t\toutput.SetValue(4, count, Value(secret_entry.storage_mode));\n-\t\toutput.SetValue(5, count, Value::LIST(LogicalType::VARCHAR, scope_value));\n-\t\toutput.SetValue(6, count, secret.ToString(bind_data.redact));\n+\t\tidx_t i = 0;\n+\t\t// name\n+\t\toutput.SetValue(i++, count, secret.GetName());\n+\t\t// type\n+\t\toutput.SetValue(i++, count, Value(secret.GetType()));\n+\t\t// provider\n+\t\toutput.SetValue(i++, count, Value(secret.GetProvider()));\n+\t\t// persistent\n+\t\toutput.SetValue(i++, count, Value(secret_entry.persist_type == SecretPersistType::PERSISTENT));\n+\t\t// storage\n+\t\toutput.SetValue(i++, count, Value(secret_entry.storage_mode));\n+\t\t// scope\n+\t\toutput.SetValue(i++, count, Value::LIST(LogicalType::VARCHAR, scope_value));\n+\t\t// secret_string\n+\t\toutput.SetValue(i++, count, secret.ToString(bind_data.redact));\n \n \t\tdata.offset++;\n \t\tcount++;\ndiff --git a/src/include/duckdb/main/secret/secret.hpp b/src/include/duckdb/main/secret/secret.hpp\nindex decd62ed05e0..f3257f005217 100644\n--- a/src/include/duckdb/main/secret/secret.hpp\n+++ b/src/include/duckdb/main/secret/secret.hpp\n@@ -37,7 +37,8 @@ struct CreateSecretInput {\n \tcase_insensitive_map_t<Value> options;\n };\n \n-typedef unique_ptr<BaseSecret> (*secret_deserializer_t)(Deserializer &deserializer, BaseSecret base_secret);\n+typedef unique_ptr<BaseSecret> (*secret_deserializer_t)(Deserializer &deserializer, BaseSecret base_secret,\n+                                                        const named_parameter_type_map_t &options);\n typedef unique_ptr<BaseSecret> (*create_secret_function_t)(ClientContext &context, CreateSecretInput &input);\n \n //! A CreateSecretFunction is a function adds a provider for a secret type.\n@@ -180,14 +181,30 @@ class KeyValueSecret : public BaseSecret {\n \n \t// FIXME: use serialization scripts\n \ttemplate <class TYPE>\n-\tstatic unique_ptr<BaseSecret> Deserialize(Deserializer &deserializer, BaseSecret base_secret) {\n+\tstatic unique_ptr<BaseSecret> Deserialize(Deserializer &deserializer, BaseSecret base_secret,\n+\t                                          const named_parameter_type_map_t &options) {\n \t\tauto result = make_uniq<TYPE>(base_secret);\n \t\tValue secret_map_value;\n \t\tdeserializer.ReadProperty(201, \"secret_map\", secret_map_value);\n \n \t\tfor (const auto &entry : ListValue::GetChildren(secret_map_value)) {\n \t\t\tauto kv_struct = StructValue::GetChildren(entry);\n-\t\t\tresult->secret_map[kv_struct[0].ToString()] = kv_struct[1].ToString();\n+\t\t\tauto key = kv_struct[0].ToString();\n+\t\t\tauto raw_value = kv_struct[1].ToString();\n+\n+\t\t\tauto it = options.find(key);\n+\t\t\tif (it == options.end()) {\n+\t\t\t\tthrow IOException(\"Failed to deserialize secret '%s', it contains an unexpected key: '%s'\",\n+\t\t\t\t                  base_secret.GetName(), key);\n+\t\t\t}\n+\t\t\tauto &logical_type = it->second;\n+\t\t\tValue value;\n+\t\t\tif (logical_type.id() == LogicalTypeId::VARCHAR) {\n+\t\t\t\tvalue = Value(raw_value);\n+\t\t\t} else {\n+\t\t\t\tvalue = Value(raw_value).DefaultCastAs(logical_type);\n+\t\t\t}\n+\t\t\tresult->secret_map[key] = value;\n \t\t}\n \n \t\tValue redact_set_value;\ndiff --git a/src/main/secret/secret_manager.cpp b/src/main/secret/secret_manager.cpp\nindex 72f5b924bd07..1a21d2db1ae0 100644\n--- a/src/main/secret/secret_manager.cpp\n+++ b/src/main/secret/secret_manager.cpp\n@@ -108,7 +108,15 @@ unique_ptr<BaseSecret> SecretManager::DeserializeSecret(Deserializer &deserializ\n \t\t    \"Attempted to deserialize secret type '%s' which does not have a deserialization method\", type);\n \t}\n \n-\treturn deserialized_type.deserializer(deserializer, {scope, type, provider, name});\n+\tauto function_entry = LookupFunctionInternal(type, provider);\n+\tif (!function_entry) {\n+\t\tthrow InternalException(\n+\t\t    \"Attempted to deserialize secret (type: '%s', provider: '%s') which does not have any functions registered\",\n+\t\t    type, provider);\n+\t}\n+\n+\treturn deserialized_type.deserializer(deserializer, {scope, type, provider, name},\n+\t                                      function_entry->named_parameters);\n }\n \n void SecretManager::RegisterSecretType(SecretType &type) {\n",
  "test_patch": "diff --git a/test/sql/secrets/persistent_key_value_secret.test b/test/sql/secrets/persistent_key_value_secret.test\nnew file mode 100644\nindex 000000000000..89448fa9a811\n--- /dev/null\n+++ b/test/sql/secrets/persistent_key_value_secret.test\n@@ -0,0 +1,28 @@\n+# name: test/sql/secrets/persistent_key_value_secret.test\n+# group: [secrets]\n+\n+load __TEST_DIR__/persistent_extra_headers\n+\n+require httpfs\n+\n+require json\n+\n+statement ok\n+CREATE PERSISTENT SECRET http (\n+\tTYPE HTTP,\n+\tEXTRA_HTTP_HEADERS MAP {\n+\t\t'Authorization': 'Bearer sk_test_not_valid_key'\n+\t}\n+);\n+\n+restart\n+\n+# Because this is an https host, the 'EXTRA_HTTP_HEADERS' will be used, as long as this doesn't crash anything\n+# we are happy with this test throwing an IO error.\n+statement error\n+select\n+\tunnest(data) as customers\n+from\n+\tread_json('https://non.existant/endpoint');\n+----\n+IO Error: Could not establish connection error for HTTP HEAD to 'https://non.existant/endpoint'\n",
  "problem_statement": "Persistent HTTP secrets work only one time, cause `INTERNAL Error: ExtraValueInfo type mismatch` on 2nd usage.\n### What happens?\n\nWhen creating a persistent HTTP secret on either an in-memory or a file persistent database, the secret will cause any HTTP interaction within it's scope to fail with `INTERNAL Error: ExtraValueInfo type mismatch`\n\n### To Reproduce\n\nExample from motherduck.com, added persistent, first call works\r\n\r\n```bash\r\nduckdb -c \"\r\nCREATE PERSISTENT SECRET http (\r\n    TYPE HTTP,\r\n    EXTRA_HTTP_HEADERS MAP {\r\n        'Authorization': 'Bearer sk_test_VePHdqKTYQjKNInc7u56JBrQ'\r\n    }\r\n);\r\nselect unnest(data) as customers \r\nfrom read_json('https://api.stripe.com/v1/customers')\"\r\n```\r\n\r\nRerun (duckdb must be restarted)\r\n\r\n```bash\r\nduckdb -c \"select unnest(data) as customers \r\nfrom read_json('https://api.stripe.com/v1/customers')\"\r\n```\r\n\r\nResult:\r\n\r\n```\r\nINTERNAL Error: ExtraValueInfo type mismatch\r\nThis error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.\r\nFor more information, see https://duckdb.org/docs/dev/internal_errors\r\n```\r\n\r\n\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\nv1.1.0 fa5c2fe15f\n\n### DuckDB Client:\n\nDuckDB CLI\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nMichael Simons\n\n### Affiliation:\n\nNeo4j, Inc.\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have not tested with any build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "Thanks, I could reproduce this locally. We'll take a look.",
  "created_at": "2024-10-11T12:14:01Z"
}