You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Persistent HTTP secrets work only one time, cause `INTERNAL Error: ExtraValueInfo type mismatch` on 2nd usage.
### What happens?

When creating a persistent HTTP secret on either an in-memory or a file persistent database, the secret will cause any HTTP interaction within it's scope to fail with `INTERNAL Error: ExtraValueInfo type mismatch`

### To Reproduce

Example from motherduck.com, added persistent, first call works

```bash
duckdb -c "
CREATE PERSISTENT SECRET http (
    TYPE HTTP,
    EXTRA_HTTP_HEADERS MAP {
        'Authorization': 'Bearer sk_test_VePHdqKTYQjKNInc7u56JBrQ'
    }
);
select unnest(data) as customers 
from read_json('https://api.stripe.com/v1/customers')"
```

Rerun (duckdb must be restarted)

```bash
duckdb -c "select unnest(data) as customers 
from read_json('https://api.stripe.com/v1/customers')"
```

Result:

```
INTERNAL Error: ExtraValueInfo type mismatch
This error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.
For more information, see https://duckdb.org/docs/dev/internal_errors
```



### OS:

MacOS

### DuckDB Version:

v1.1.0 fa5c2fe15f

### DuckDB Client:

DuckDB CLI

### Hardware:

_No response_

### Full Name:

Michael Simons

### Affiliation:

Neo4j, Inc.

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of extension/httpfs/create_secret_functions.cpp]
1: #include "create_secret_functions.hpp"
2: #include "s3fs.hpp"
3: #include "duckdb/main/extension_util.hpp"
4: #include "duckdb/common/local_file_system.hpp"
5: 
6: namespace duckdb {
7: 
8: void CreateS3SecretFunctions::Register(DatabaseInstance &instance) {
9: 	RegisterCreateSecretFunction(instance, "s3");
10: 	RegisterCreateSecretFunction(instance, "r2");
11: 	RegisterCreateSecretFunction(instance, "gcs");
12: }
13: 
14: unique_ptr<BaseSecret> CreateS3SecretFunctions::CreateSecretFunctionInternal(ClientContext &context,
15:                                                                              CreateSecretInput &input) {
16: 	// Set scope to user provided scope or the default
17: 	auto scope = input.scope;
18: 	if (scope.empty()) {
19: 		if (input.type == "s3") {
20: 			scope.push_back("s3://");
21: 			scope.push_back("s3n://");
22: 			scope.push_back("s3a://");
23: 		} else if (input.type == "r2") {
24: 			scope.push_back("r2://");
25: 		} else if (input.type == "gcs") {
26: 			scope.push_back("gcs://");
27: 			scope.push_back("gs://");
28: 		} else {
29: 			throw InternalException("Unknown secret type found in httpfs extension: '%s'", input.type);
30: 		}
31: 	}
32: 
33: 	auto secret = make_uniq<KeyValueSecret>(scope, input.type, input.provider, input.name);
34: 	secret->redact_keys = {"secret", "session_token"};
35: 
36: 	// for r2 we can set the endpoint using the account id
37: 	if (input.type == "r2" && input.options.find("account_id") != input.options.end()) {
38: 		secret->secret_map["endpoint"] = input.options["account_id"].ToString() + ".r2.cloudflarestorage.com";
39: 		secret->secret_map["url_style"] = "path";
40: 	}
41: 
42: 	// apply any overridden settings
43: 	for (const auto &named_param : input.options) {
44: 		auto lower_name = StringUtil::Lower(named_param.first);
45: 
46: 		if (lower_name == "key_id") {
47: 			secret->secret_map["key_id"] = named_param.second;
48: 		} else if (lower_name == "secret") {
49: 			secret->secret_map["secret"] = named_param.second;
50: 		} else if (lower_name == "region") {
51: 			secret->secret_map["region"] = named_param.second.ToString();
52: 		} else if (lower_name == "session_token") {
53: 			secret->secret_map["session_token"] = named_param.second.ToString();
54: 		} else if (lower_name == "endpoint") {
55: 			secret->secret_map["endpoint"] = named_param.second.ToString();
56: 		} else if (lower_name == "url_style") {
57: 			secret->secret_map["url_style"] = named_param.second.ToString();
58: 		} else if (lower_name == "use_ssl") {
59: 			if (named_param.second.type() != LogicalType::BOOLEAN) {
60: 				throw InvalidInputException("Invalid type past to secret option: '%s', found '%s', expected: 'BOOLEAN'",
61: 				                            lower_name, named_param.second.type().ToString());
62: 			}
63: 			secret->secret_map["use_ssl"] = named_param.second.GetValue<bool>();
64: 		} else if (lower_name == "url_compatibility_mode") {
65: 			if (named_param.second.type() != LogicalType::BOOLEAN) {
66: 				throw InvalidInputException("Invalid type past to secret option: '%s', found '%s', expected: 'BOOLEAN'",
67: 				                            lower_name, named_param.second.type().ToString());
68: 			}
69: 			secret->secret_map["url_compatibility_mode"] = named_param.second.GetValue<bool>();
70: 		} else if (lower_name == "account_id") {
71: 			continue; // handled already
72: 		} else {
73: 			throw InternalException("Unknown named parameter passed to CreateSecretFunctionInternal: " + lower_name);
74: 		}
75: 	}
76: 
77: 	return std::move(secret);
78: }
79: 
80: unique_ptr<BaseSecret> CreateS3SecretFunctions::CreateS3SecretFromConfig(ClientContext &context,
81:                                                                          CreateSecretInput &input) {
82: 	return CreateSecretFunctionInternal(context, input);
83: }
84: 
85: void CreateS3SecretFunctions::SetBaseNamedParams(CreateSecretFunction &function, string &type) {
86: 	function.named_parameters["key_id"] = LogicalType::VARCHAR;
87: 	function.named_parameters["secret"] = LogicalType::VARCHAR;
88: 	function.named_parameters["region"] = LogicalType::VARCHAR;
89: 	function.named_parameters["session_token"] = LogicalType::VARCHAR;
90: 	function.named_parameters["endpoint"] = LogicalType::VARCHAR;
91: 	function.named_parameters["url_style"] = LogicalType::VARCHAR;
92: 	function.named_parameters["use_ssl"] = LogicalType::BOOLEAN;
93: 	function.named_parameters["url_compatibility_mode"] = LogicalType::BOOLEAN;
94: 
95: 	if (type == "r2") {
96: 		function.named_parameters["account_id"] = LogicalType::VARCHAR;
97: 	}
98: }
99: 
100: void CreateS3SecretFunctions::RegisterCreateSecretFunction(DatabaseInstance &instance, string type) {
101: 	// Register the new type
102: 	SecretType secret_type;
103: 	secret_type.name = type;
104: 	secret_type.deserializer = KeyValueSecret::Deserialize<KeyValueSecret>;
105: 	secret_type.default_provider = "config";
106: 
107: 	ExtensionUtil::RegisterSecretType(instance, secret_type);
108: 
109: 	CreateSecretFunction from_empty_config_fun2 = {type, "config", CreateS3SecretFromConfig};
110: 	SetBaseNamedParams(from_empty_config_fun2, type);
111: 	ExtensionUtil::RegisterFunction(instance, from_empty_config_fun2);
112: }
113: 
114: void CreateBearerTokenFunctions::Register(DatabaseInstance &instance) {
115: 	// HuggingFace secret
116: 	SecretType secret_type_hf;
117: 	secret_type_hf.name = HUGGINGFACE_TYPE;
118: 	secret_type_hf.deserializer = KeyValueSecret::Deserialize<KeyValueSecret>;
119: 	secret_type_hf.default_provider = "config";
120: 	ExtensionUtil::RegisterSecretType(instance, secret_type_hf);
121: 
122: 	// Huggingface config provider
123: 	CreateSecretFunction hf_config_fun = {HUGGINGFACE_TYPE, "config", CreateBearerSecretFromConfig};
124: 	hf_config_fun.named_parameters["token"] = LogicalType::VARCHAR;
125: 	ExtensionUtil::RegisterFunction(instance, hf_config_fun);
126: 
127: 	// Huggingface credential_chain provider
128: 	CreateSecretFunction hf_cred_fun = {HUGGINGFACE_TYPE, "credential_chain",
129: 	                                    CreateHuggingFaceSecretFromCredentialChain};
130: 	ExtensionUtil::RegisterFunction(instance, hf_cred_fun);
131: }
132: 
133: unique_ptr<BaseSecret> CreateBearerTokenFunctions::CreateSecretFunctionInternal(ClientContext &context,
134:                                                                                 CreateSecretInput &input,
135:                                                                                 const string &token) {
136: 	// Set scope to user provided scope or the default
137: 	auto scope = input.scope;
138: 	if (scope.empty()) {
139: 		if (input.type == HUGGINGFACE_TYPE) {
140: 			scope.push_back("hf://");
141: 		} else {
142: 			throw InternalException("Unknown secret type found in httpfs extension: '%s'", input.type);
143: 		}
144: 	}
145: 	auto return_value = make_uniq<KeyValueSecret>(scope, input.type, input.provider, input.name);
146: 
147: 	//! Set key value map
148: 	return_value->secret_map["token"] = token;
149: 
150: 	//! Set redact keys
151: 	return_value->redact_keys = {"token"};
152: 
153: 	return std::move(return_value);
154: }
155: 
156: unique_ptr<BaseSecret> CreateBearerTokenFunctions::CreateBearerSecretFromConfig(ClientContext &context,
157:                                                                                 CreateSecretInput &input) {
158: 	string token;
159: 
160: 	for (const auto &named_param : input.options) {
161: 		auto lower_name = StringUtil::Lower(named_param.first);
162: 		if (lower_name == "token") {
163: 			token = named_param.second.ToString();
164: 		}
165: 	}
166: 
167: 	return CreateSecretFunctionInternal(context, input, token);
168: }
169: 
170: static string TryReadTokenFile(const string &token_path, const string error_source_message,
171:                                bool fail_on_exception = true) {
172: 	try {
173: 		LocalFileSystem fs;
174: 		auto handle = fs.OpenFile(token_path, {FileOpenFlags::FILE_FLAGS_READ});
175: 		return handle->ReadLine();
176: 	} catch (std::exception &ex) {
177: 		if (!fail_on_exception) {
178: 			return "";
179: 		}
180: 		ErrorData error(ex);
181: 		throw IOException("Failed to read token path '%s'%s. (error: %s)", token_path, error_source_message,
182: 		                  error.RawMessage());
183: 	}
184: }
185: 
186: unique_ptr<BaseSecret>
187: CreateBearerTokenFunctions::CreateHuggingFaceSecretFromCredentialChain(ClientContext &context,
188:                                                                        CreateSecretInput &input) {
189: 	// Step 1: Try the ENV variable HF_TOKEN
190: 	const char *hf_token_env = std::getenv("HF_TOKEN");
191: 	if (hf_token_env) {
192: 		return CreateSecretFunctionInternal(context, input, hf_token_env);
193: 	}
194: 	// Step 2: Try the ENV variable HF_TOKEN_PATH
195: 	const char *hf_token_path_env = std::getenv("HF_TOKEN_PATH");
196: 	if (hf_token_path_env) {
197: 		auto token = TryReadTokenFile(hf_token_path_env, " fetched from HF_TOKEN_PATH env variable");
198: 		return CreateSecretFunctionInternal(context, input, token);
199: 	}
200: 
201: 	// Step 3: Try the path $HF_HOME/token
202: 	const char *hf_home_env = std::getenv("HF_HOME");
203: 	if (hf_home_env) {
204: 		auto token_path = LocalFileSystem().JoinPath(hf_home_env, "token");
205: 		auto token = TryReadTokenFile(token_path, " constructed using the HF_HOME variable: '$HF_HOME/token'");
206: 		return CreateSecretFunctionInternal(context, input, token);
207: 	}
208: 
209: 	// Step 4: Check the default path
210: 	auto token = TryReadTokenFile("~/.cache/huggingface/token", "", false);
211: 	return CreateSecretFunctionInternal(context, input, token);
212: }
213: } // namespace duckdb
[end of extension/httpfs/create_secret_functions.cpp]
[start of src/function/table/system/duckdb_secrets.cpp]
1: #include "duckdb/function/table/system_functions.hpp"
2: 
3: #include "duckdb/common/file_system.hpp"
4: #include "duckdb/common/map.hpp"
5: #include "duckdb/common/string_util.hpp"
6: #include "duckdb/function/function_set.hpp"
7: #include "duckdb/main/client_context.hpp"
8: #include "duckdb/main/database.hpp"
9: #include "duckdb/main/extension_helper.hpp"
10: #include "duckdb/main/secret/secret_manager.hpp"
11: 
12: namespace duckdb {
13: 
14: struct DuckDBSecretsData : public GlobalTableFunctionState {
15: 	DuckDBSecretsData() : offset(0) {
16: 	}
17: 	idx_t offset;
18: 	duckdb::vector<duckdb::SecretEntry> secrets;
19: };
20: 
21: struct DuckDBSecretsBindData : public FunctionData {
22: public:
23: 	unique_ptr<FunctionData> Copy() const override {
24: 		return make_uniq<DuckDBSecretsBindData>();
25: 	};
26: 
27: 	bool Equals(const FunctionData &other_p) const override {
28: 		auto &other = other_p.Cast<DuckDBSecretsBindData>();
29: 		return redact == other.redact;
30: 	}
31: 	SecretDisplayType redact = SecretDisplayType::REDACTED;
32: };
33: 
34: static unique_ptr<FunctionData> DuckDBSecretsBind(ClientContext &context, TableFunctionBindInput &input,
35:                                                   vector<LogicalType> &return_types, vector<string> &names) {
36: 	auto result = make_uniq<DuckDBSecretsBindData>();
37: 
38: 	auto entry = input.named_parameters.find("redact");
39: 	if (entry != input.named_parameters.end()) {
40: 		if (BooleanValue::Get(entry->second)) {
41: 			result->redact = SecretDisplayType::REDACTED;
42: 		} else {
43: 			result->redact = SecretDisplayType::UNREDACTED;
44: 		}
45: 	}
46: 
47: 	if (!DBConfig::GetConfig(context).options.allow_unredacted_secrets &&
48: 	    result->redact == SecretDisplayType::UNREDACTED) {
49: 		throw InvalidInputException("Displaying unredacted secrets is disabled");
50: 	}
51: 
52: 	names.emplace_back("name");
53: 	return_types.emplace_back(LogicalType::VARCHAR);
54: 
55: 	names.emplace_back("type");
56: 	return_types.emplace_back(LogicalType::VARCHAR);
57: 
58: 	names.emplace_back("provider");
59: 	return_types.emplace_back(LogicalType::VARCHAR);
60: 
61: 	names.emplace_back("persistent");
62: 	return_types.emplace_back(LogicalType::BOOLEAN);
63: 
64: 	names.emplace_back("storage");
65: 	return_types.emplace_back(LogicalType::VARCHAR);
66: 
67: 	names.emplace_back("scope");
68: 	return_types.emplace_back(LogicalType::LIST(LogicalType::VARCHAR));
69: 
70: 	names.emplace_back("secret_string");
71: 	return_types.emplace_back(LogicalType::VARCHAR);
72: 
73: 	return std::move(result);
74: }
75: 
76: unique_ptr<GlobalTableFunctionState> DuckDBSecretsInit(ClientContext &context, TableFunctionInitInput &input) {
77: 	auto result = make_uniq<DuckDBSecretsData>();
78: 	return std::move(result);
79: }
80: 
81: void DuckDBSecretsFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {
82: 	auto &data = data_p.global_state->Cast<DuckDBSecretsData>();
83: 	auto &bind_data = data_p.bind_data->Cast<DuckDBSecretsBindData>();
84: 
85: 	auto &secret_manager = SecretManager::Get(context);
86: 
87: 	auto transaction = CatalogTransaction::GetSystemCatalogTransaction(context);
88: 
89: 	if (data.secrets.empty()) {
90: 		data.secrets = secret_manager.AllSecrets(transaction);
91: 	}
92: 	auto &secrets = data.secrets;
93: 	if (data.offset >= secrets.size()) {
94: 		// finished returning values
95: 		return;
96: 	}
97: 	// start returning values
98: 	// either fill up the chunk or return all the remaining columns
99: 	idx_t count = 0;
100: 	while (data.offset < secrets.size() && count < STANDARD_VECTOR_SIZE) {
101: 		auto &secret_entry = secrets[data.offset];
102: 
103: 		vector<Value> scope_value;
104: 		for (const auto &scope_entry : secret_entry.secret->GetScope()) {
105: 			scope_value.push_back(scope_entry);
106: 		}
107: 
108: 		const auto &secret = *secret_entry.secret;
109: 
110: 		output.SetValue(0, count, secret.GetName());
111: 		output.SetValue(1, count, Value(secret.GetType()));
112: 		output.SetValue(2, count, Value(secret.GetProvider()));
113: 		output.SetValue(3, count, Value(secret_entry.persist_type == SecretPersistType::PERSISTENT));
114: 		output.SetValue(4, count, Value(secret_entry.storage_mode));
115: 		output.SetValue(5, count, Value::LIST(LogicalType::VARCHAR, scope_value));
116: 		output.SetValue(6, count, secret.ToString(bind_data.redact));
117: 
118: 		data.offset++;
119: 		count++;
120: 	}
121: 	output.SetCardinality(count);
122: }
123: 
124: void DuckDBSecretsFun::RegisterFunction(BuiltinFunctions &set) {
125: 	TableFunctionSet functions("duckdb_secrets");
126: 	auto fun = TableFunction({}, DuckDBSecretsFunction, DuckDBSecretsBind, DuckDBSecretsInit);
127: 	fun.named_parameters["redact"] = LogicalType::BOOLEAN;
128: 	functions.AddFunction(fun);
129: 	set.AddFunction(functions);
130: }
131: 
132: } // namespace duckdb
[end of src/function/table/system/duckdb_secrets.cpp]
[start of src/include/duckdb/main/secret/secret.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/secret/secret.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/named_parameter_map.hpp"
13: #include "duckdb/common/serializer/deserializer.hpp"
14: #include "duckdb/common/serializer/serializer.hpp"
15: 
16: namespace duckdb {
17: class BaseSecret;
18: struct SecretEntry;
19: struct FileOpenerInfo;
20: 
21: //! Whether a secret is persistent or temporary
22: enum class SecretPersistType : uint8_t { DEFAULT, TEMPORARY, PERSISTENT };
23: 
24: //! Input passed to a CreateSecretFunction
25: struct CreateSecretInput {
26: 	//! type
27: 	string type;
28: 	//! mode
29: 	string provider;
30: 	//! should the secret be persisted?
31: 	string storage_type;
32: 	//! (optional) alias provided by user
33: 	string name;
34: 	//! (optional) scope provided by user
35: 	vector<string> scope;
36: 	//! (optional) named parameter map, each create secret function has defined it's own set of these
37: 	case_insensitive_map_t<Value> options;
38: };
39: 
40: typedef unique_ptr<BaseSecret> (*secret_deserializer_t)(Deserializer &deserializer, BaseSecret base_secret);
41: typedef unique_ptr<BaseSecret> (*create_secret_function_t)(ClientContext &context, CreateSecretInput &input);
42: 
43: //! A CreateSecretFunction is a function adds a provider for a secret type.
44: class CreateSecretFunction {
45: public:
46: 	string secret_type;
47: 	string provider;
48: 	create_secret_function_t function;
49: 	named_parameter_type_map_t named_parameters;
50: };
51: 
52: //! CreateSecretFunctionsSet contains multiple functions of a single type, identified by the provider. The provider
53: //! should be seen as the method of secret creation. (e.g. user-provided config, env variables, auto-detect)
54: class CreateSecretFunctionSet {
55: public:
56: 	explicit CreateSecretFunctionSet(string &name) : name(name) {};
57: 
58: public:
59: 	bool ProviderExists(const string &provider_name);
60: 	void AddFunction(CreateSecretFunction &function, OnCreateConflict on_conflict);
61: 	CreateSecretFunction &GetFunction(const string &provider);
62: 
63: protected:
64: 	//! Create Secret Function type name
65: 	string name;
66: 	//! Maps of provider -> function
67: 	case_insensitive_map_t<CreateSecretFunction> functions;
68: };
69: 
70: //! Determines whether the secrets are allowed to be shown
71: enum class SecretDisplayType : uint8_t { REDACTED, UNREDACTED };
72: 
73: //! Secret types contain the base settings of a secret
74: struct SecretType {
75: 	//! Unique name identifying the secret type
76: 	string name;
77: 	//! The deserialization function for the type
78: 	secret_deserializer_t deserializer;
79: 	//! Provider to use when non is specified
80: 	string default_provider;
81: };
82: 
83: //! Base class from which BaseSecret classes can be made.
84: class BaseSecret {
85: 	friend class SecretManager;
86: 
87: public:
88: 	BaseSecret(vector<string> prefix_paths_p, string type_p, string provider_p, string name_p)
89: 	    : prefix_paths(std::move(prefix_paths_p)), type(std::move(type_p)), provider(std::move(provider_p)),
90: 	      name(std::move(name_p)), serializable(false) {
91: 		D_ASSERT(!type.empty());
92: 	}
93: 	BaseSecret(const BaseSecret &other)
94: 	    : prefix_paths(other.prefix_paths), type(other.type), provider(other.provider), name(other.name),
95: 	      serializable(other.serializable) {
96: 		D_ASSERT(!type.empty());
97: 	}
98: 	virtual ~BaseSecret() = default;
99: 
100: 	//! The score of how well this secret's scope matches the path (by default: the length of the longest matching
101: 	//! prefix)
102: 	virtual int64_t MatchScore(const string &path) const;
103: 	//! Prints the secret as a string
104: 	virtual string ToString(SecretDisplayType mode = SecretDisplayType::REDACTED) const;
105: 	//! Serialize this secret
106: 	virtual void Serialize(Serializer &serializer) const;
107: 
108: 	virtual unique_ptr<const BaseSecret> Clone() const {
109: 		D_ASSERT(typeid(BaseSecret) == typeid(*this));
110: 		return make_uniq<BaseSecret>(*this);
111: 	}
112: 
113: 	//! Getters
114: 	const vector<string> &GetScope() const {
115: 		return prefix_paths;
116: 	}
117: 	const string &GetType() const {
118: 		return type;
119: 	}
120: 	const string &GetProvider() const {
121: 		return provider;
122: 	}
123: 	const string &GetName() const {
124: 		return name;
125: 	}
126: 	bool IsSerializable() const {
127: 		return serializable;
128: 	}
129: 
130: protected:
131: 	//! Helper function to serialize the base BaseSecret class variables
132: 	virtual void SerializeBaseSecret(Serializer &serializer) const final;
133: 
134: 	//! prefixes to which the secret applies
135: 	vector<string> prefix_paths;
136: 
137: 	//! Type of secret
138: 	string type;
139: 	//! Provider of the secret
140: 	string provider;
141: 	//! Name of the secret
142: 	string name;
143: 	//! Whether the secret can be serialized/deserialized
144: 	bool serializable;
145: };
146: 
147: //! The KeyValueSecret is a class that implements a Secret as a set of key -> values. This class can be used
148: //! for most use-cases of secrets as secrets generally tend to fit in a key value map.
149: class KeyValueSecret : public BaseSecret {
150: public:
151: 	KeyValueSecret(const vector<string> &prefix_paths, const string &type, const string &provider, const string &name)
152: 	    : BaseSecret(prefix_paths, type, provider, name) {
153: 		D_ASSERT(!type.empty());
154: 		serializable = true;
155: 	}
156: 	explicit KeyValueSecret(const BaseSecret &secret)
157: 	    : BaseSecret(secret.GetScope(), secret.GetType(), secret.GetProvider(), secret.GetName()) {
158: 		serializable = true;
159: 	};
160: 	KeyValueSecret(const KeyValueSecret &secret)
161: 	    : BaseSecret(secret.GetScope(), secret.GetType(), secret.GetProvider(), secret.GetName()) {
162: 		secret_map = secret.secret_map;
163: 		redact_keys = secret.redact_keys;
164: 		serializable = true;
165: 	};
166: 	KeyValueSecret(KeyValueSecret &&secret) noexcept
167: 	    : BaseSecret(std::move(secret.prefix_paths), std::move(secret.type), std::move(secret.provider),
168: 	                 std::move(secret.name)) {
169: 		secret_map = std::move(secret.secret_map);
170: 		redact_keys = std::move(secret.redact_keys);
171: 		serializable = true;
172: 	};
173: 
174: 	//! Print the secret as a key value map in the format 'key1=value;key2=value2'
175: 	string ToString(SecretDisplayType mode = SecretDisplayType::REDACTED) const override;
176: 	void Serialize(Serializer &serializer) const override;
177: 
178: 	//! Tries to get the value at key <key>, depending on error_on_missing will throw or return Value()
179: 	Value TryGetValue(const string &key, bool error_on_missing = false) const;
180: 
181: 	// FIXME: use serialization scripts
182: 	template <class TYPE>
183: 	static unique_ptr<BaseSecret> Deserialize(Deserializer &deserializer, BaseSecret base_secret) {
184: 		auto result = make_uniq<TYPE>(base_secret);
185: 		Value secret_map_value;
186: 		deserializer.ReadProperty(201, "secret_map", secret_map_value);
187: 
188: 		for (const auto &entry : ListValue::GetChildren(secret_map_value)) {
189: 			auto kv_struct = StructValue::GetChildren(entry);
190: 			result->secret_map[kv_struct[0].ToString()] = kv_struct[1].ToString();
191: 		}
192: 
193: 		Value redact_set_value;
194: 		deserializer.ReadProperty(202, "redact_keys", redact_set_value);
195: 		for (const auto &entry : ListValue::GetChildren(redact_set_value)) {
196: 			result->redact_keys.insert(entry.ToString());
197: 		}
198: 
199: 		return duckdb::unique_ptr_cast<TYPE, BaseSecret>(std::move(result));
200: 	}
201: 
202: 	unique_ptr<const BaseSecret> Clone() const override {
203: 		return make_uniq<KeyValueSecret>(*this);
204: 	}
205: 
206: 	// Get a value from the secret
207: 	bool TryGetValue(const string &key, Value &result) const {
208: 		auto lookup = secret_map.find(key);
209: 		if (lookup == secret_map.end()) {
210: 			return false;
211: 		}
212: 		result = lookup->second;
213: 		return true;
214: 	}
215: 
216: 	bool TrySetValue(const string &key, const CreateSecretInput &input) {
217: 		auto lookup = input.options.find(key);
218: 		if (lookup != input.options.end()) {
219: 			secret_map[key] = lookup->second;
220: 			return true;
221: 		}
222: 		return false;
223: 	}
224: 
225: 	//! the map of key -> values that make up the secret
226: 	case_insensitive_tree_t<Value> secret_map;
227: 	//! keys that are sensitive and should be redacted
228: 	case_insensitive_set_t redact_keys;
229: };
230: 
231: // Helper class to fetch secret parameters in a cascading way. The idea being that in many cases there is a direct
232: // connection between a KeyValueSecret key and a setting and we want to:
233: // - check if the secret has a specific key, if so return the corresponding value
234: // - check if a setting exists, if so return its value
235: // - return a default value
236: 
237: class KeyValueSecretReader {
238: public:
239: 	//! Manually pass in a secret reference
240: 	KeyValueSecretReader(const KeyValueSecret &secret_p, FileOpener &opener_p) : secret(secret_p) {};
241: 
242: 	//! Initializes the KeyValueSecretReader by fetching the secret automatically
243: 	KeyValueSecretReader(FileOpener &opener_p, optional_ptr<FileOpenerInfo> info, const char **secret_types,
244: 	                     idx_t secret_types_len);
245: 	KeyValueSecretReader(FileOpener &opener_p, optional_ptr<FileOpenerInfo> info, const char *secret_type);
246: 
247: 	//! Initialize KeyValueSecretReader from a db instance
248: 	KeyValueSecretReader(DatabaseInstance &db, const char **secret_types, idx_t secret_types_len, string path);
249: 	KeyValueSecretReader(DatabaseInstance &db, const char *secret_type, string path);
250: 
251: 	// Initialize KeyValueSecretReader from a client context
252: 	KeyValueSecretReader(ClientContext &context, const char **secret_types, idx_t secret_types_len, string path);
253: 	KeyValueSecretReader(ClientContext &context, const char *secret_type, string path);
254: 
255: 	~KeyValueSecretReader();
256: 
257: 	//! Lookup a KeyValueSecret value
258: 	SettingLookupResult TryGetSecretKey(const string &secret_key, Value &result);
259: 	//! Lookup a KeyValueSecret value or a setting
260: 	SettingLookupResult TryGetSecretKeyOrSetting(const string &secret_key, const string &setting_name, Value &result);
261: 	//! Lookup a KeyValueSecret value or a setting, throws InvalidInputException on not found
262: 	Value GetSecretKey(const string &secret_key);
263: 	//! Lookup a KeyValueSecret value or a setting, throws InvalidInputException on not found
264: 	Value GetSecretKeyOrSetting(const string &secret_key, const string &setting_name);
265: 
266: 	//! Templating around TryGetSecretKey
267: 	template <class TYPE>
268: 	SettingLookupResult TryGetSecretKey(const string &secret_key, TYPE &value_out) {
269: 		Value result;
270: 		auto lookup_result = TryGetSecretKey(secret_key, result);
271: 		if (lookup_result) {
272: 			value_out = result.GetValue<TYPE>();
273: 		}
274: 		return lookup_result;
275: 	}
276: 
277: 	//! Templating around TryGetSecretOrSetting
278: 	template <class TYPE>
279: 	SettingLookupResult TryGetSecretKeyOrSetting(const string &secret_key, const string &setting_name,
280: 	                                             TYPE &value_out) {
281: 		Value result;
282: 		auto lookup_result = TryGetSecretKeyOrSetting(secret_key, setting_name, result);
283: 		if (lookup_result) {
284: 			value_out = result.GetValue<TYPE>();
285: 		}
286: 		return lookup_result;
287: 	}
288: 
289: 	// Like a templated GetSecretOrSetting but instead of throwing on not found, return the default value
290: 	template <class TYPE>
291: 	TYPE GetSecretKeyOrSettingOrDefault(const string &secret_key, const string &setting_name, TYPE default_value) {
292: 		TYPE result;
293: 		if (TryGetSecretKeyOrSetting(secret_key, setting_name, result)) {
294: 			return result;
295: 		}
296: 		return default_value;
297: 	}
298: 
299: protected:
300: 	void Initialize(const char **secret_types, idx_t secret_types_len);
301: 
302: 	[[noreturn]] void ThrowNotFoundError(const string &secret_key);
303: 	[[noreturn]] void ThrowNotFoundError(const string &secret_key, const string &setting_name);
304: 
305: 	//! Fetching the secret
306: 	optional_ptr<const KeyValueSecret> secret;
307: 	//! Optionally an owning pointer to the secret entry
308: 	shared_ptr<SecretEntry> secret_entry;
309: 
310: 	//! Secrets/settings will be fetched either through a context (local + global settings) or a databaseinstance
311: 	//! (global only)
312: 	optional_ptr<DatabaseInstance> db;
313: 	optional_ptr<ClientContext> context;
314: 
315: 	string path;
316: };
317: 
318: } // namespace duckdb
[end of src/include/duckdb/main/secret/secret.hpp]
[start of src/main/secret/secret_manager.cpp]
1: #include "duckdb/main/secret/secret_manager.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry.hpp"
4: #include "duckdb/common/common.hpp"
5: #include "duckdb/common/file_system.hpp"
6: #include "duckdb/common/local_file_system.hpp"
7: #include "duckdb/common/mutex.hpp"
8: #include "duckdb/common/serializer/binary_deserializer.hpp"
9: #include "duckdb/common/serializer/binary_serializer.hpp"
10: #include "duckdb/common/serializer/buffered_file_reader.hpp"
11: #include "duckdb/common/serializer/deserializer.hpp"
12: #include "duckdb/common/serializer/serializer.hpp"
13: #include "duckdb/function/function_set.hpp"
14: #include "duckdb/main/client_context.hpp"
15: #include "duckdb/main/extension_helper.hpp"
16: #include "duckdb/main/secret/secret_storage.hpp"
17: #include "duckdb/main/secret/default_secrets.hpp"
18: #include "duckdb/parser/parsed_data/create_secret_info.hpp"
19: #include "duckdb/parser/statement/create_statement.hpp"
20: #include "duckdb/planner/operator/logical_create_secret.hpp"
21: 
22: namespace duckdb {
23: 
24: SecretCatalogEntry::SecretCatalogEntry(unique_ptr<SecretEntry> secret_p, Catalog &catalog)
25:     : InCatalogEntry(CatalogType::SECRET_ENTRY, catalog, secret_p->secret->GetName()), secret(std::move(secret_p)) {
26: 	internal = true;
27: }
28: 
29: SecretCatalogEntry::SecretCatalogEntry(unique_ptr<const BaseSecret> secret_p, Catalog &catalog)
30:     : InCatalogEntry(CatalogType::SECRET_ENTRY, catalog, secret_p->GetName()) {
31: 	internal = true;
32: 	secret = make_uniq<SecretEntry>(std::move(secret_p));
33: }
34: 
35: const BaseSecret &SecretMatch::GetSecret() const {
36: 	return *secret_entry->secret;
37: }
38: 
39: constexpr const char *SecretManager::TEMPORARY_STORAGE_NAME;
40: constexpr const char *SecretManager::LOCAL_FILE_STORAGE_NAME;
41: 
42: void SecretManager::Initialize(DatabaseInstance &db) {
43: 	lock_guard<mutex> lck(manager_lock);
44: 
45: 	// Construct default path
46: 	LocalFileSystem fs;
47: 	config.default_secret_path = fs.GetHomeDirectory();
48: 	vector<string> path_components = {".duckdb", "stored_secrets"};
49: 	for (auto &path_ele : path_components) {
50: 		config.default_secret_path = fs.JoinPath(config.default_secret_path, path_ele);
51: 	}
52: 	config.secret_path = config.default_secret_path;
53: 
54: 	// Set the defaults for persistent storage
55: 	config.default_persistent_storage = LOCAL_FILE_STORAGE_NAME;
56: 
57: 	// Store the current db for enabling autoloading
58: 	this->db = &db;
59: 
60: 	// Register default types
61: 	for (auto &type : CreateHTTPSecretFunctions::GetDefaultSecretTypes()) {
62: 		RegisterSecretTypeInternal(type);
63: 	}
64: 
65: 	// Register default functions
66: 	for (auto &function : CreateHTTPSecretFunctions::GetDefaultSecretFunctions()) {
67: 		RegisterSecretFunctionInternal(function, OnCreateConflict::ERROR_ON_CONFLICT);
68: 	}
69: }
70: 
71: void SecretManager::LoadSecretStorage(unique_ptr<SecretStorage> storage) {
72: 	lock_guard<mutex> lck(manager_lock);
73: 	return LoadSecretStorageInternal(std::move(storage));
74: }
75: 
76: void SecretManager::LoadSecretStorageInternal(unique_ptr<SecretStorage> storage) {
77: 	if (secret_storages.find(storage->GetName()) != secret_storages.end()) {
78: 		throw InternalException("Secret Storage with name '%s' already registered!", storage->GetName());
79: 	}
80: 
81: 	// Check for tie-break offset collisions to ensure we can always tie-break cleanly
82: 	for (const auto &storage_ptr : secret_storages) {
83: 		if (storage_ptr.second->GetTieBreakOffset() == storage->GetTieBreakOffset()) {
84: 			throw InternalException("Failed to load secret storage '%s', tie break score collides with '%s'",
85: 			                        storage->GetName(), storage_ptr.second->GetName());
86: 		}
87: 	}
88: 
89: 	secret_storages[storage->GetName()] = std::move(storage);
90: }
91: 
92: // FIXME: use serialization scripts?
93: unique_ptr<BaseSecret> SecretManager::DeserializeSecret(Deserializer &deserializer, const string &secret_path) {
94: 	auto type = deserializer.ReadProperty<string>(100, "type");
95: 	auto provider = deserializer.ReadProperty<string>(101, "provider");
96: 	auto name = deserializer.ReadProperty<string>(102, "name");
97: 	vector<string> scope;
98: 	deserializer.ReadList(103, "scope",
99: 	                      [&](Deserializer::List &list, idx_t i) { scope.push_back(list.ReadElement<string>()); });
100: 
101: 	SecretType deserialized_type;
102: 	if (!TryLookupTypeInternal(type, deserialized_type)) {
103: 		ThrowTypeNotFoundError(type, secret_path);
104: 	}
105: 
106: 	if (!deserialized_type.deserializer) {
107: 		throw InternalException(
108: 		    "Attempted to deserialize secret type '%s' which does not have a deserialization method", type);
109: 	}
110: 
111: 	return deserialized_type.deserializer(deserializer, {scope, type, provider, name});
112: }
113: 
114: void SecretManager::RegisterSecretType(SecretType &type) {
115: 	lock_guard<mutex> lck(manager_lock);
116: 	RegisterSecretTypeInternal(type);
117: }
118: 
119: void SecretManager::RegisterSecretFunction(CreateSecretFunction function, OnCreateConflict on_conflict) {
120: 	unique_lock<mutex> lck(manager_lock);
121: 	RegisterSecretFunctionInternal(std::move(function), on_conflict);
122: }
123: 
124: unique_ptr<SecretEntry> SecretManager::RegisterSecret(CatalogTransaction transaction,
125:                                                       unique_ptr<const BaseSecret> secret, OnCreateConflict on_conflict,
126:                                                       SecretPersistType persist_type, const string &storage) {
127: 	InitializeSecrets(transaction);
128: 	return RegisterSecretInternal(transaction, std::move(secret), on_conflict, persist_type, storage);
129: }
130: 
131: unique_ptr<SecretEntry> SecretManager::RegisterSecretInternal(CatalogTransaction transaction,
132:                                                               unique_ptr<const BaseSecret> secret,
133:                                                               OnCreateConflict on_conflict,
134:                                                               SecretPersistType persist_type, const string &storage) {
135: 	//! Ensure we only create secrets for known types;
136: 	LookupTypeInternal(secret->GetType());
137: 
138: 	//! Handle default for persist type
139: 	if (persist_type == SecretPersistType::DEFAULT) {
140: 		if (storage.empty()) {
141: 			persist_type = config.default_persist_type;
142: 		} else if (storage == TEMPORARY_STORAGE_NAME) {
143: 			persist_type = SecretPersistType::TEMPORARY;
144: 		} else {
145: 			persist_type = SecretPersistType::PERSISTENT;
146: 		}
147: 	}
148: 
149: 	//! Resolve storage
150: 	string resolved_storage;
151: 	if (storage.empty()) {
152: 		resolved_storage =
153: 		    persist_type == SecretPersistType::PERSISTENT ? config.default_persistent_storage : TEMPORARY_STORAGE_NAME;
154: 	} else {
155: 		resolved_storage = storage;
156: 	}
157: 
158: 	//! Lookup which backend to store the secret in
159: 	auto backend = GetSecretStorage(resolved_storage);
160: 	if (!backend) {
161: 		if (!config.allow_persistent_secrets &&
162: 		    (persist_type == SecretPersistType::PERSISTENT || storage == LOCAL_FILE_STORAGE_NAME)) {
163: 			throw InvalidInputException("Persistent secrets are disabled. Restart DuckDB and enable persistent secrets "
164: 			                            "through 'SET allow_persistent_secrets=true'");
165: 		}
166: 		throw InvalidInputException("Secret storage '%s' not found!", resolved_storage);
167: 	}
168: 
169: 	// Validation on both allow_persistent_secrets and storage backend's own persist type
170: 	if (persist_type == SecretPersistType::PERSISTENT) {
171: 		if (backend->persistent) {
172: 			if (!config.allow_persistent_secrets) {
173: 				throw InvalidInputException(
174: 				    "Persistent secrets are currently disabled. To enable them, restart duckdb and "
175: 				    "run 'SET allow_persistent_secrets=true'");
176: 			}
177: 		} else { // backend is temp
178: 			throw InvalidInputException("Cannot create persistent secrets in a temporary secret storage!");
179: 		}
180: 	} else { // SecretPersistType::TEMPORARY
181: 		if (backend->persistent) {
182: 			throw InvalidInputException("Cannot create temporary secrets in a persistent secret storage!");
183: 		}
184: 	}
185: 	return backend->StoreSecret(std::move(secret), on_conflict, &transaction);
186: }
187: 
188: optional_ptr<CreateSecretFunction> SecretManager::LookupFunctionInternal(const string &type, const string &provider) {
189: 	unique_lock<mutex> lck(manager_lock);
190: 	auto lookup = secret_functions.find(type);
191: 
192: 	if (lookup != secret_functions.end()) {
193: 		if (lookup->second.ProviderExists(provider)) {
194: 			return &lookup->second.GetFunction(provider);
195: 		}
196: 	}
197: 
198: 	// Try autoloading
199: 	lck.unlock();
200: 	AutoloadExtensionForFunction(type, provider);
201: 	lck.lock();
202: 
203: 	lookup = secret_functions.find(type);
204: 
205: 	if (lookup != secret_functions.end()) {
206: 		if (lookup->second.ProviderExists(provider)) {
207: 			return &lookup->second.GetFunction(provider);
208: 		}
209: 	}
210: 
211: 	return nullptr;
212: }
213: 
214: unique_ptr<SecretEntry> SecretManager::CreateSecret(ClientContext &context, const CreateSecretInfo &info) {
215: 	// Note that a context is required for CreateSecret, as the CreateSecretFunction expects one
216: 	auto transaction = CatalogTransaction::GetSystemCatalogTransaction(context);
217: 	InitializeSecrets(transaction);
218: 
219: 	// Make a copy to set the provider to default if necessary
220: 	CreateSecretInput function_input {info.type, info.provider, info.storage_type, info.name, info.scope, info.options};
221: 	if (function_input.provider.empty()) {
222: 		auto secret_type = LookupTypeInternal(function_input.type);
223: 		function_input.provider = secret_type.default_provider;
224: 	}
225: 
226: 	// Lookup function
227: 	auto function_lookup = LookupFunctionInternal(function_input.type, function_input.provider);
228: 	if (!function_lookup) {
229: 		ThrowProviderNotFoundError(info.type, info.provider);
230: 	}
231: 
232: 	// Call the function
233: 	auto secret = function_lookup->function(context, function_input);
234: 
235: 	if (!secret) {
236: 		throw InternalException("CreateSecretFunction for type: '%s' and provider: '%s' did not return a secret!",
237: 		                        info.type, info.provider);
238: 	}
239: 
240: 	// Register the secret at the secret_manager
241: 	return RegisterSecretInternal(transaction, std::move(secret), info.on_conflict, info.persist_type,
242: 	                              info.storage_type);
243: }
244: 
245: BoundStatement SecretManager::BindCreateSecret(CatalogTransaction transaction, CreateSecretInfo &info) {
246: 	InitializeSecrets(transaction);
247: 
248: 	auto type = info.type;
249: 	auto provider = info.provider;
250: 	bool default_provider = false;
251: 
252: 	if (provider.empty()) {
253: 		default_provider = true;
254: 		auto secret_type = LookupTypeInternal(type);
255: 		provider = secret_type.default_provider;
256: 	}
257: 
258: 	string default_string = default_provider ? "default " : "";
259: 
260: 	auto function = LookupFunctionInternal(type, provider);
261: 
262: 	if (!function) {
263: 		ThrowProviderNotFoundError(info.type, info.provider, default_provider);
264: 	}
265: 
266: 	auto bound_info = info;
267: 	bound_info.options.clear();
268: 
269: 	// We cast the passed parameters
270: 	for (const auto &param : info.options) {
271: 		auto matched_param = function->named_parameters.find(param.first);
272: 		if (matched_param == function->named_parameters.end()) {
273: 			throw BinderException("Unknown parameter '%s' for secret type '%s' with %sprovider '%s'", param.first, type,
274: 			                      default_string, provider);
275: 		}
276: 
277: 		// Cast the provided value to the expected type
278: 		string error_msg;
279: 		Value cast_value;
280: 		if (!param.second.DefaultTryCastAs(matched_param->second, cast_value, &error_msg)) {
281: 			throw BinderException("Failed to cast option '%s' to type '%s': '%s'", matched_param->first,
282: 			                      matched_param->second.ToString(), error_msg);
283: 		}
284: 
285: 		bound_info.options[matched_param->first] = {cast_value};
286: 	}
287: 
288: 	BoundStatement result;
289: 	result.names = {"Success"};
290: 	result.types = {LogicalType::BOOLEAN};
291: 	result.plan = make_uniq<LogicalCreateSecret>(std::move(bound_info));
292: 	return result;
293: }
294: 
295: SecretMatch SecretManager::LookupSecret(CatalogTransaction transaction, const string &path, const string &type) {
296: 	InitializeSecrets(transaction);
297: 
298: 	int64_t best_match_score = NumericLimits<int64_t>::Minimum();
299: 	unique_ptr<SecretEntry> best_match = nullptr;
300: 
301: 	for (const auto &storage_ref : GetSecretStorages()) {
302: 		if (!storage_ref.get().IncludeInLookups()) {
303: 			continue;
304: 		}
305: 		auto match = storage_ref.get().LookupSecret(path, StringUtil::Lower(type), &transaction);
306: 		if (match.HasMatch() && match.score > best_match_score) {
307: 			best_match = std::move(match.secret_entry);
308: 			best_match_score = match.score;
309: 		}
310: 	}
311: 
312: 	if (best_match) {
313: 		return SecretMatch(*best_match, best_match_score);
314: 	}
315: 
316: 	return SecretMatch();
317: }
318: 
319: unique_ptr<SecretEntry> SecretManager::GetSecretByName(CatalogTransaction transaction, const string &name,
320:                                                        const string &storage) {
321: 	InitializeSecrets(transaction);
322: 
323: 	unique_ptr<SecretEntry> result = nullptr;
324: 	bool found = false;
325: 
326: 	if (!storage.empty()) {
327: 		auto storage_lookup = GetSecretStorage(storage);
328: 
329: 		if (!storage_lookup) {
330: 			throw InvalidInputException("Unknown secret storage found: '%s'", storage);
331: 		}
332: 
333: 		return storage_lookup->GetSecretByName(name, &transaction);
334: 	}
335: 
336: 	for (const auto &storage_ref : GetSecretStorages()) {
337: 		auto lookup = storage_ref.get().GetSecretByName(name, &transaction);
338: 		if (lookup) {
339: 			if (found) {
340: 				throw InternalException(
341: 				    "Ambiguity detected for secret name '%s', secret occurs in multiple storage backends.", name);
342: 			}
343: 
344: 			result = std::move(lookup);
345: 			found = true;
346: 		}
347: 	}
348: 
349: 	return result;
350: }
351: 
352: void SecretManager::DropSecretByName(CatalogTransaction transaction, const string &name,
353:                                      OnEntryNotFound on_entry_not_found, SecretPersistType persist_type,
354:                                      const string &storage) {
355: 	InitializeSecrets(transaction);
356: 
357: 	vector<reference<SecretStorage>> matches;
358: 
359: 	// storage to drop from was specified directly
360: 	if (!storage.empty()) {
361: 		auto storage_lookup = GetSecretStorage(storage);
362: 		if (!storage_lookup) {
363: 			throw InvalidInputException("Unknown storage type found for drop secret: '%s'", storage);
364: 		}
365: 		matches.push_back(*storage_lookup.get());
366: 	} else {
367: 		for (const auto &storage_ref : GetSecretStorages()) {
368: 			if (persist_type == SecretPersistType::PERSISTENT && !storage_ref.get().Persistent()) {
369: 				continue;
370: 			}
371: 			if (persist_type == SecretPersistType::TEMPORARY && storage_ref.get().Persistent()) {
372: 				continue;
373: 			}
374: 
375: 			auto lookup = storage_ref.get().GetSecretByName(name, &transaction);
376: 			if (lookup) {
377: 				matches.push_back(storage_ref.get());
378: 			}
379: 		}
380: 	}
381: 
382: 	if (matches.size() > 1) {
383: 		string list_of_matches;
384: 		for (const auto &match : matches) {
385: 			list_of_matches += match.get().GetName() + ",";
386: 		}
387: 		list_of_matches.pop_back(); // trailing comma
388: 
389: 		throw InvalidInputException(
390: 		    "Ambiguity found for secret name '%s', secret occurs in multiple storages: [%s] Please specify which "
391: 		    "secret to drop using: 'DROP <PERSISTENT|TEMPORARY> SECRET [FROM <storage>]'.",
392: 		    name, list_of_matches);
393: 	}
394: 
395: 	if (matches.empty()) {
396: 		if (on_entry_not_found == OnEntryNotFound::THROW_EXCEPTION) {
397: 			string storage_str;
398: 			if (!storage.empty()) {
399: 				storage_str = " for storage '" + storage + "'";
400: 			}
401: 			throw InvalidInputException("Failed to remove non-existent secret with name '%s'%s", name, storage_str);
402: 		}
403: 		// Do nothing on OnEntryNotFound::RETURN_NULL...
404: 	} else {
405: 		matches[0].get().DropSecretByName(name, on_entry_not_found, &transaction);
406: 	}
407: }
408: 
409: SecretType SecretManager::LookupType(const string &type) {
410: 	return LookupTypeInternal(type);
411: }
412: 
413: void SecretManager::RegisterSecretTypeInternal(SecretType &type) {
414: 	auto lookup = secret_types.find(type.name);
415: 	if (lookup != secret_types.end()) {
416: 		throw InternalException("Attempted to register an already registered secret type: '%s'", type.name);
417: 	}
418: 	secret_types[type.name] = type;
419: }
420: 
421: bool SecretManager::TryLookupTypeInternal(const string &type, SecretType &type_out) {
422: 	unique_lock<mutex> lck(manager_lock);
423: 	auto lookup = secret_types.find(type);
424: 	if (lookup != secret_types.end()) {
425: 		type_out = lookup->second;
426: 		return true;
427: 	}
428: 
429: 	// Try autoloading
430: 	lck.unlock();
431: 	AutoloadExtensionForType(type);
432: 	lck.lock();
433: 
434: 	lookup = secret_types.find(type);
435: 	if (lookup != secret_types.end()) {
436: 		type_out = lookup->second;
437: 		return true;
438: 	}
439: 
440: 	return false;
441: }
442: 
443: SecretType SecretManager::LookupTypeInternal(const string &type) {
444: 	SecretType return_value;
445: 	if (!TryLookupTypeInternal(type, return_value)) {
446: 		ThrowTypeNotFoundError(type);
447: 	}
448: 	return return_value;
449: }
450: 
451: void SecretManager::RegisterSecretFunctionInternal(CreateSecretFunction function, OnCreateConflict on_conflict) {
452: 	auto lookup = secret_functions.find(function.secret_type);
453: 	if (lookup != secret_functions.end()) {
454: 		lookup->second.AddFunction(function, on_conflict);
455: 		return;
456: 	}
457: 	CreateSecretFunctionSet new_set(function.secret_type);
458: 	new_set.AddFunction(function, OnCreateConflict::ERROR_ON_CONFLICT);
459: 	secret_functions.insert({function.secret_type, new_set});
460: }
461: 
462: vector<SecretEntry> SecretManager::AllSecrets(CatalogTransaction transaction) {
463: 	InitializeSecrets(transaction);
464: 
465: 	vector<SecretEntry> result;
466: 
467: 	// Add results from all backends to the result set
468: 	for (const auto &backend : secret_storages) {
469: 		auto backend_result = backend.second->AllSecrets(&transaction);
470: 		for (const auto &it : backend_result) {
471: 			result.push_back(it);
472: 		}
473: 	}
474: 
475: 	return result;
476: }
477: 
478: void SecretManager::ThrowOnSettingChangeIfInitialized() {
479: 	if (initialized) {
480: 		throw InvalidInputException(
481: 		    "Changing Secret Manager settings after the secret manager is used is not allowed!");
482: 	}
483: }
484: 
485: void SecretManager::SetEnablePersistentSecrets(bool enabled) {
486: 	ThrowOnSettingChangeIfInitialized();
487: 	config.allow_persistent_secrets = enabled;
488: }
489: 
490: void SecretManager::ResetEnablePersistentSecrets() {
491: 	ThrowOnSettingChangeIfInitialized();
492: 	config.allow_persistent_secrets = SecretManagerConfig::DEFAULT_ALLOW_PERSISTENT_SECRETS;
493: }
494: 
495: bool SecretManager::PersistentSecretsEnabled() {
496: 	return config.allow_persistent_secrets;
497: }
498: 
499: void SecretManager::SetDefaultStorage(const string &storage) {
500: 	config.default_persistent_storage = storage;
501: }
502: 
503: void SecretManager::ResetDefaultStorage() {
504: 	config.default_persistent_storage = SecretManager::LOCAL_FILE_STORAGE_NAME;
505: }
506: 
507: string SecretManager::DefaultStorage() {
508: 	return config.default_persistent_storage;
509: }
510: 
511: void SecretManager::SetPersistentSecretPath(const string &path) {
512: 	ThrowOnSettingChangeIfInitialized();
513: 	config.secret_path = path;
514: }
515: 
516: void SecretManager::ResetPersistentSecretPath() {
517: 	ThrowOnSettingChangeIfInitialized();
518: 	config.secret_path = config.default_secret_path;
519: }
520: 
521: string SecretManager::PersistentSecretPath() {
522: 	return config.secret_path;
523: }
524: 
525: void SecretManager::InitializeSecrets(CatalogTransaction transaction) {
526: 	if (!initialized) {
527: 		lock_guard<mutex> lck(manager_lock);
528: 		if (initialized) {
529: 			// some sneaky other thread beat us to it
530: 			return;
531: 		}
532: 
533: 		// load the tmp storage
534: 		LoadSecretStorageInternal(make_uniq<TemporarySecretStorage>(TEMPORARY_STORAGE_NAME, *transaction.db));
535: 
536: 		if (config.allow_persistent_secrets) {
537: 			// load the persistent storage if enabled
538: 			LoadSecretStorageInternal(
539: 			    make_uniq<LocalFileSecretStorage>(*this, *transaction.db, LOCAL_FILE_STORAGE_NAME, config.secret_path));
540: 		}
541: 
542: 		initialized = true;
543: 	}
544: }
545: 
546: void SecretManager::AutoloadExtensionForType(const string &type) {
547: 	ExtensionHelper::TryAutoloadFromEntry(*db, StringUtil::Lower(type), EXTENSION_SECRET_TYPES);
548: }
549: 
550: void SecretManager::ThrowTypeNotFoundError(const string &type, const string &secret_path) {
551: 	auto entry = ExtensionHelper::FindExtensionInEntries(StringUtil::Lower(type), EXTENSION_SECRET_TYPES);
552: 	string error_message;
553: 
554: 	if (!entry.empty() && db) {
555: 		error_message = "Secret type '" + type + "' does not exist, but it exists in the " + entry + " extension.";
556: 		error_message = ExtensionHelper::AddExtensionInstallHintToErrorMsg(*db, error_message, entry);
557: 
558: 		if (!secret_path.empty()) {
559: 			error_message += "\n\nAlternatively, ";
560: 		}
561: 	} else {
562: 		error_message = StringUtil::Format("Secret type '%s' not found", type);
563: 
564: 		if (!secret_path.empty()) {
565: 			error_message += ", ";
566: 		}
567: 	}
568: 
569: 	if (!secret_path.empty()) {
570: 		error_message += StringUtil::Format("try removing the secret at path '%s'.", secret_path);
571: 	}
572: 
573: 	throw InvalidInputException(error_message);
574: }
575: 
576: void SecretManager::AutoloadExtensionForFunction(const string &type, const string &provider) {
577: 	ExtensionHelper::TryAutoloadFromEntry(*db, StringUtil::Lower(type) + "/" + StringUtil::Lower(provider),
578: 	                                      EXTENSION_SECRET_PROVIDERS);
579: }
580: 
581: void SecretManager::ThrowProviderNotFoundError(const string &type, const string &provider, bool was_default) {
582: 	auto entry = ExtensionHelper::FindExtensionInEntries(StringUtil::Lower(type) + "/" + StringUtil::Lower(provider),
583: 	                                                     EXTENSION_SECRET_PROVIDERS);
584: 	if (!entry.empty() && db) {
585: 		string error_message = was_default ? "Default secret provider" : "Secret provider";
586: 		error_message +=
587: 		    " '" + provider + "' for type '" + type + "' does not exist, but it exists in the " + entry + " extension.";
588: 		error_message = ExtensionHelper::AddExtensionInstallHintToErrorMsg(*db, error_message, entry);
589: 
590: 		throw InvalidInputException(error_message);
591: 	}
592: 	throw InvalidInputException("Secret provider '%s' not found for type '%s'", provider, type);
593: }
594: 
595: optional_ptr<SecretStorage> SecretManager::GetSecretStorage(const string &name) {
596: 	lock_guard<mutex> lock(manager_lock);
597: 
598: 	auto lookup = secret_storages.find(name);
599: 	if (lookup != secret_storages.end()) {
600: 		return lookup->second.get();
601: 	}
602: 
603: 	return nullptr;
604: }
605: 
606: vector<reference<SecretStorage>> SecretManager::GetSecretStorages() {
607: 	lock_guard<mutex> lock(manager_lock);
608: 
609: 	vector<reference<SecretStorage>> result;
610: 
611: 	for (const auto &storage : secret_storages) {
612: 		result.push_back(*storage.second);
613: 	}
614: 
615: 	return result;
616: }
617: 
618: DefaultSecretGenerator::DefaultSecretGenerator(Catalog &catalog, SecretManager &secret_manager,
619:                                                case_insensitive_set_t &persistent_secrets)
620:     : DefaultGenerator(catalog), secret_manager(secret_manager), persistent_secrets(persistent_secrets) {
621: }
622: 
623: unique_ptr<CatalogEntry> DefaultSecretGenerator::CreateDefaultEntryInternal(const string &entry_name) {
624: 	auto secret_lu = persistent_secrets.find(entry_name);
625: 	if (secret_lu == persistent_secrets.end()) {
626: 		return nullptr;
627: 	}
628: 
629: 	LocalFileSystem fs;
630: 
631: 	string base_secret_path = secret_manager.PersistentSecretPath();
632: 	string secret_path = fs.JoinPath(base_secret_path, entry_name + ".duckdb_secret");
633: 
634: 	// Note each file should contain 1 secret
635: 	try {
636: 		auto file_reader = BufferedFileReader(fs, secret_path.c_str());
637: 
638: 		if (!LocalFileSystem::IsPrivateFile(secret_path, nullptr)) {
639: 			throw IOException(
640: 			    "The secret file '%s' has incorrect permissions! Please set correct permissions or remove file",
641: 			    secret_path);
642: 		}
643: 
644: 		if (!file_reader.Finished()) {
645: 			BinaryDeserializer deserializer(file_reader);
646: 
647: 			deserializer.Begin();
648: 			auto deserialized_secret = secret_manager.DeserializeSecret(deserializer, secret_path);
649: 			deserializer.End();
650: 
651: 			auto entry = make_uniq<SecretCatalogEntry>(std::move(deserialized_secret), catalog);
652: 			entry->secret->storage_mode = SecretManager::LOCAL_FILE_STORAGE_NAME;
653: 			entry->secret->persist_type = SecretPersistType::PERSISTENT;
654: 
655: 			// Finally: we remove the default entry from the persistent_secrets, otherwise we aren't able to drop it
656: 			// later
657: 			persistent_secrets.erase(secret_lu);
658: 
659: 			return std::move(entry);
660: 		}
661: 	} catch (std::exception &ex) {
662: 		ErrorData error(ex);
663: 		switch (error.Type()) {
664: 		case ExceptionType::SERIALIZATION:
665: 			throw SerializationException(
666: 			    "Failed to deserialize the persistent secret file: '%s'. The file maybe be "
667: 			    "corrupt, please remove the file, restart and try again. (error message: '%s')",
668: 			    secret_path, error.RawMessage());
669: 		case ExceptionType::IO:
670: 			throw IOException(
671: 			    "Failed to open the persistent secret file: '%s'. Some other process may have removed it, "
672: 			    "please restart and try again. (error message: '%s')",
673: 			    secret_path, error.RawMessage());
674: 		default:
675: 			throw;
676: 		}
677: 	}
678: 
679: 	throw SerializationException("Failed to deserialize secret '%s' from '%s': file appears empty! Please remove the "
680: 	                             "file, restart and try again",
681: 	                             entry_name, secret_path);
682: }
683: 
684: unique_ptr<CatalogEntry> DefaultSecretGenerator::CreateDefaultEntry(CatalogTransaction transaction,
685:                                                                     const string &entry_name) {
686: 	return CreateDefaultEntryInternal(entry_name);
687: }
688: 
689: unique_ptr<CatalogEntry> DefaultSecretGenerator::CreateDefaultEntry(ClientContext &context, const string &entry_name) {
690: 	return CreateDefaultEntryInternal(entry_name);
691: }
692: 
693: vector<string> DefaultSecretGenerator::GetDefaultEntries() {
694: 	vector<string> ret;
695: 
696: 	for (const auto &res : persistent_secrets) {
697: 		ret.push_back(res);
698: 	}
699: 
700: 	return ret;
701: }
702: 
703: SecretManager &SecretManager::Get(ClientContext &context) {
704: 	return *DBConfig::GetConfig(context).secret_manager;
705: }
706: SecretManager &SecretManager::Get(DatabaseInstance &db) {
707: 	return *DBConfig::GetConfig(db).secret_manager;
708: }
709: 
710: void SecretManager::DropSecretByName(ClientContext &context, const string &name, OnEntryNotFound on_entry_not_found,
711:                                      SecretPersistType persist_type, const string &storage) {
712: 	auto transaction = CatalogTransaction::GetSystemCatalogTransaction(context);
713: 	return DropSecretByName(transaction, name, on_entry_not_found, persist_type, storage);
714: }
715: 
716: } // namespace duckdb
[end of src/main/secret/secret_manager.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: