{
  "repo": "duckdb/duckdb",
  "pull_number": 14102,
  "instance_id": "duckdb__duckdb-14102",
  "issue_numbers": [
    "14099"
  ],
  "base_commit": "4a55e2334232afe94e47ab398ddb44f88fcd6658",
  "patch": "diff --git a/src/include/duckdb/parser/transformer.hpp b/src/include/duckdb/parser/transformer.hpp\nindex 760526b15fa7..0125f2f1f925 100644\n--- a/src/include/duckdb/parser/transformer.hpp\n+++ b/src/include/duckdb/parser/transformer.hpp\n@@ -323,6 +323,8 @@ class Transformer {\n \t//! Transform a range var into a (schema) qualified name\n \tQualifiedName TransformQualifiedName(duckdb_libpgquery::PGRangeVar &root);\n \n+\t//! Transform a Postgres TypeName string into a LogicalType (non-LIST types)\n+\tLogicalType TransformTypeNameInternal(duckdb_libpgquery::PGTypeName &name);\n \t//! Transform a Postgres TypeName string into a LogicalType\n \tLogicalType TransformTypeName(duckdb_libpgquery::PGTypeName &name);\n \ndiff --git a/src/parser/transform/helpers/transform_typename.cpp b/src/parser/transform/helpers/transform_typename.cpp\nindex e3cab9205f6e..bd6b97a10d0c 100644\n--- a/src/parser/transform/helpers/transform_typename.cpp\n+++ b/src/parser/transform/helpers/transform_typename.cpp\n@@ -71,12 +71,7 @@ vector<Value> Transformer::TransformTypeModifiers(duckdb_libpgquery::PGTypeName\n \treturn type_mods;\n }\n \n-LogicalType Transformer::TransformTypeName(duckdb_libpgquery::PGTypeName &type_name) {\n-\tif (type_name.type != duckdb_libpgquery::T_PGTypeName) {\n-\t\tthrow ParserException(\"Expected a type\");\n-\t}\n-\tauto stack_checker = StackCheck();\n-\n+LogicalType Transformer::TransformTypeNameInternal(duckdb_libpgquery::PGTypeName &type_name) {\n \tif (type_name.names->length > 1) {\n \t\t// qualified typename\n \t\tvector<string> names;\n@@ -85,24 +80,27 @@ LogicalType Transformer::TransformTypeName(duckdb_libpgquery::PGTypeName &type_n\n \t\t}\n \t\tvector<Value> type_mods = TransformTypeModifiers(type_name);\n \t\tswitch (type_name.names->length) {\n-\t\tcase 2:\n+\t\tcase 2: {\n \t\t\treturn LogicalType::USER(INVALID_CATALOG, std::move(names[0]), std::move(names[1]), std::move(type_mods));\n-\t\tcase 3:\n+\t\t}\n+\t\tcase 3: {\n \t\t\treturn LogicalType::USER(std::move(names[0]), std::move(names[1]), std::move(names[2]),\n \t\t\t                         std::move(type_mods));\n+\t\t}\n \t\tdefault:\n \t\t\tthrow ParserException(\n \t\t\t    \"Too many qualifications for type name - expected [catalog.schema.name] or [schema.name]\");\n \t\t}\n \t}\n+\n \tauto name = PGPointerCast<duckdb_libpgquery::PGValue>(type_name.names->tail->data.ptr_value)->val.str;\n \t// transform it to the SQL type\n \tLogicalTypeId base_type = TransformStringToLogicalTypeId(name);\n \n-\tLogicalType result_type;\n \tif (base_type == LogicalTypeId::LIST) {\n \t\tthrow ParserException(\"LIST is not valid as a stand-alone type\");\n-\t} else if (base_type == LogicalTypeId::ENUM) {\n+\t}\n+\tif (base_type == LogicalTypeId::ENUM) {\n \t\tif (!type_name.typmods || type_name.typmods->length == 0) {\n \t\t\tthrow ParserException(\"Enum needs a set of entries\");\n \t\t}\n@@ -118,7 +116,8 @@ LogicalType Transformer::TransformTypeName(duckdb_libpgquery::PGTypeName &type_n\n \t\t\tstring_data[pos++] = StringVector::AddString(enum_vector, constant_value->val.val.str);\n \t\t}\n \t\treturn LogicalType::ENUM(enum_vector, NumericCast<idx_t>(type_name.typmods->length));\n-\t} else if (base_type == LogicalTypeId::STRUCT) {\n+\t}\n+\tif (base_type == LogicalTypeId::STRUCT) {\n \t\tif (!type_name.typmods || type_name.typmods->length == 0) {\n \t\t\tthrow ParserException(\"Struct needs a name and entries\");\n \t\t}\n@@ -148,9 +147,9 @@ LogicalType Transformer::TransformTypeName(duckdb_libpgquery::PGTypeName &type_n\n \t\t\tchildren.push_back(make_pair(entry_name, entry_type));\n \t\t}\n \t\tD_ASSERT(!children.empty());\n-\t\tresult_type = LogicalType::STRUCT(children);\n-\n-\t} else if (base_type == LogicalTypeId::MAP) {\n+\t\treturn LogicalType::STRUCT(children);\n+\t}\n+\tif (base_type == LogicalTypeId::MAP) {\n \t\tif (!type_name.typmods || type_name.typmods->length != 2) {\n \t\t\tthrow ParserException(\"Map type needs exactly two entries, key and value type\");\n \t\t}\n@@ -159,8 +158,9 @@ LogicalType Transformer::TransformTypeName(duckdb_libpgquery::PGTypeName &type_n\n \t\tauto value_type =\n \t\t    TransformTypeName(*PGPointerCast<duckdb_libpgquery::PGTypeName>(type_name.typmods->tail->data.ptr_value));\n \n-\t\tresult_type = LogicalType::MAP(std::move(key_type), std::move(value_type));\n-\t} else if (base_type == LogicalTypeId::UNION) {\n+\t\treturn LogicalType::MAP(std::move(key_type), std::move(value_type));\n+\t}\n+\tif (base_type == LogicalTypeId::UNION) {\n \t\tif (!type_name.typmods || type_name.typmods->length == 0) {\n \t\t\tthrow ParserException(\"Union type needs at least one member\");\n \t\t}\n@@ -195,81 +195,83 @@ LogicalType Transformer::TransformTypeName(duckdb_libpgquery::PGTypeName &type_n\n \t\t\tchildren.push_back(make_pair(entry_name, entry_type));\n \t\t}\n \t\tD_ASSERT(!children.empty());\n-\t\tresult_type = LogicalType::UNION(std::move(children));\n-\t} else if (base_type == LogicalTypeId::USER) {\n+\t\treturn LogicalType::UNION(std::move(children));\n+\t}\n+\tif (base_type == LogicalTypeId::USER) {\n \t\tstring user_type_name {name};\n \t\tvector<Value> type_mods = TransformTypeModifiers(type_name);\n-\t\tresult_type = LogicalType::USER(user_type_name, type_mods);\n-\t} else {\n-\t\tSizeModifiers modifiers = GetSizeModifiers(type_name, base_type);\n-\t\tswitch (base_type) {\n-\t\tcase LogicalTypeId::VARCHAR:\n-\t\t\tif (modifiers.count > 1) {\n-\t\t\t\tthrow ParserException(\"VARCHAR only supports a single modifier\");\n-\t\t\t}\n-\t\t\t// FIXME: create CHECK constraint based on varchar width\n-\t\t\tmodifiers.width = 0;\n-\t\t\tresult_type = LogicalType::VARCHAR;\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::DECIMAL:\n-\t\t\tif (modifiers.count > 2) {\n-\t\t\t\tthrow ParserException(\"DECIMAL only supports a maximum of two modifiers\");\n-\t\t\t}\n-\t\t\tif (modifiers.count == 1) {\n-\t\t\t\t// only width is provided: set scale to 0\n-\t\t\t\tmodifiers.scale = 0;\n-\t\t\t}\n-\t\t\tif (modifiers.width <= 0 || modifiers.width > Decimal::MAX_WIDTH_DECIMAL) {\n-\t\t\t\tthrow ParserException(\"Width must be between 1 and %d!\", (int)Decimal::MAX_WIDTH_DECIMAL);\n-\t\t\t}\n-\t\t\tif (modifiers.scale > modifiers.width) {\n-\t\t\t\tthrow ParserException(\"Scale cannot be bigger than width\");\n-\t\t\t}\n-\t\t\tresult_type =\n-\t\t\t    LogicalType::DECIMAL(NumericCast<uint8_t>(modifiers.width), NumericCast<uint8_t>(modifiers.scale));\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::INTERVAL:\n-\t\t\tif (modifiers.count > 1) {\n-\t\t\t\tthrow ParserException(\"INTERVAL only supports a single modifier\");\n-\t\t\t}\n-\t\t\tmodifiers.width = 0;\n-\t\t\tresult_type = LogicalType::INTERVAL;\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::BIT:\n-\t\t\tif (!modifiers.width && type_name.typmods) {\n-\t\t\t\tthrow ParserException(\"Type %s does not support any modifiers!\", LogicalType(base_type).ToString());\n-\t\t\t}\n-\t\t\tresult_type = LogicalType(base_type);\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::TIMESTAMP:\n-\t\t\tif (modifiers.count == 0) {\n-\t\t\t\tresult_type = LogicalType::TIMESTAMP;\n-\t\t\t} else {\n-\t\t\t\tif (modifiers.count > 1) {\n-\t\t\t\t\tthrow ParserException(\"TIMESTAMP only supports a single modifier\");\n-\t\t\t\t}\n-\t\t\t\tif (modifiers.width > 10) {\n-\t\t\t\t\tthrow ParserException(\"TIMESTAMP only supports until nano-second precision (9)\");\n-\t\t\t\t}\n-\t\t\t\tif (modifiers.width == 0) {\n-\t\t\t\t\tresult_type = LogicalType::TIMESTAMP_S;\n-\t\t\t\t} else if (modifiers.width <= 3) {\n-\t\t\t\t\tresult_type = LogicalType::TIMESTAMP_MS;\n-\t\t\t\t} else if (modifiers.width <= 6) {\n-\t\t\t\t\tresult_type = LogicalType::TIMESTAMP;\n-\t\t\t\t} else {\n-\t\t\t\t\tresult_type = LogicalType::TIMESTAMP_NS;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\tif (modifiers.count > 0) {\n-\t\t\t\tthrow ParserException(\"Type %s does not support any modifiers!\", LogicalType(base_type).ToString());\n-\t\t\t}\n-\t\t\tresult_type = LogicalType(base_type);\n-\t\t\tbreak;\n+\t\treturn LogicalType::USER(user_type_name, type_mods);\n+\t}\n+\n+\tSizeModifiers modifiers = GetSizeModifiers(type_name, base_type);\n+\tswitch (base_type) {\n+\tcase LogicalTypeId::VARCHAR:\n+\t\tif (modifiers.count > 1) {\n+\t\t\tthrow ParserException(\"VARCHAR only supports a single modifier\");\n+\t\t}\n+\t\t// FIXME: create CHECK constraint based on varchar width\n+\t\tmodifiers.width = 0;\n+\t\treturn LogicalType::VARCHAR;\n+\tcase LogicalTypeId::DECIMAL:\n+\t\tif (modifiers.count > 2) {\n+\t\t\tthrow ParserException(\"DECIMAL only supports a maximum of two modifiers\");\n+\t\t}\n+\t\tif (modifiers.count == 1) {\n+\t\t\t// only width is provided: set scale to 0\n+\t\t\tmodifiers.scale = 0;\n+\t\t}\n+\t\tif (modifiers.width <= 0 || modifiers.width > Decimal::MAX_WIDTH_DECIMAL) {\n+\t\t\tthrow ParserException(\"Width must be between 1 and %d!\", (int)Decimal::MAX_WIDTH_DECIMAL);\n+\t\t}\n+\t\tif (modifiers.scale > modifiers.width) {\n+\t\t\tthrow ParserException(\"Scale cannot be bigger than width\");\n+\t\t}\n+\t\treturn LogicalType::DECIMAL(NumericCast<uint8_t>(modifiers.width), NumericCast<uint8_t>(modifiers.scale));\n+\tcase LogicalTypeId::INTERVAL:\n+\t\tif (modifiers.count > 1) {\n+\t\t\tthrow ParserException(\"INTERVAL only supports a single modifier\");\n+\t\t}\n+\t\tmodifiers.width = 0;\n+\t\treturn LogicalType::INTERVAL;\n+\tcase LogicalTypeId::BIT:\n+\t\tif (!modifiers.width && type_name.typmods) {\n+\t\t\tthrow ParserException(\"Type %s does not support any modifiers!\", LogicalType(base_type).ToString());\n+\t\t}\n+\t\treturn LogicalType(base_type);\n+\tcase LogicalTypeId::TIMESTAMP:\n+\t\tif (modifiers.count == 0) {\n+\t\t\treturn LogicalType::TIMESTAMP;\n+\t\t}\n+\t\tif (modifiers.count > 1) {\n+\t\t\tthrow ParserException(\"TIMESTAMP only supports a single modifier\");\n \t\t}\n+\t\tif (modifiers.width > 10) {\n+\t\t\tthrow ParserException(\"TIMESTAMP only supports until nano-second precision (9)\");\n+\t\t}\n+\t\tif (modifiers.width == 0) {\n+\t\t\treturn LogicalType::TIMESTAMP_S;\n+\t\t}\n+\t\tif (modifiers.width <= 3) {\n+\t\t\treturn LogicalType::TIMESTAMP_MS;\n+\t\t}\n+\t\tif (modifiers.width <= 6) {\n+\t\t\treturn LogicalType::TIMESTAMP;\n+\t\t}\n+\t\treturn LogicalType::TIMESTAMP_NS;\n+\tdefault:\n+\t\tif (modifiers.count > 0) {\n+\t\t\tthrow ParserException(\"Type %s does not support any modifiers!\", LogicalType(base_type).ToString());\n+\t\t}\n+\t\treturn LogicalType(base_type);\n+\t}\n+}\n+\n+LogicalType Transformer::TransformTypeName(duckdb_libpgquery::PGTypeName &type_name) {\n+\tif (type_name.type != duckdb_libpgquery::T_PGTypeName) {\n+\t\tthrow ParserException(\"Expected a type\");\n \t}\n+\tauto stack_checker = StackCheck();\n+\tauto result_type = TransformTypeNameInternal(type_name);\n \tif (type_name.arrayBounds) {\n \t\t// array bounds: turn the type into a list\n \t\tidx_t extra_stack = 0;\n",
  "test_patch": "diff --git a/test/sql/create/create_table_with_arraybounds.test b/test/sql/create/create_table_with_arraybounds.test\nnew file mode 100644\nindex 000000000000..5b00229b7191\n--- /dev/null\n+++ b/test/sql/create/create_table_with_arraybounds.test\n@@ -0,0 +1,46 @@\n+# name: test/sql/create/create_table_with_arraybounds.test\n+# group: [create]\n+\n+require noforcestorage\n+\n+# Create a table with an ENUM[] type\n+statement ok\n+create table T (\n+\tvis enum ('hide', 'visible')[]\n+);\n+\n+query I\n+select column_type from (describe T);\n+----\n+ENUM('hide', 'visible')[]\n+\n+statement ok\n+attach ':memory:' as db2;\n+\n+statement ok\n+create schema schema2;\n+\n+statement ok\n+create schema db2.schema3;\n+\n+statement ok\n+create type schema2.foo as VARCHAR;\n+\n+statement ok\n+create type db2.schema3.bar as BOOL;\n+\n+# Create a table with a USER[] type qualified with a schema\n+statement error\n+create table B (\n+\tvis schema2.foo[]\n+);\n+----\n+syntax error at or near\n+\n+# Create a table with a USER[] type qualified with a schema and a catalog\n+statement error\n+create table B (\n+\tvis db2.schema3.bar[]\n+);\n+----\n+syntax error at or near\n",
  "problem_statement": "To create table containing a column with enum array\n### What happens?\n\nI've tried to create a table containing enum array.\r\n\r\nFollowwing query was expect result.\r\n\r\n```sql\r\nD create type Visibility as enum ('hide', 'visible');\r\nD create or replace table T (vis Visibility[]);\r\nD DESCRIBE T;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 column_name \u2502        column_type        \u2502  null   \u2502   key   \u2502 default \u2502  extra  \u2502\r\n\u2502   varchar   \u2502          varchar          \u2502 varchar \u2502 varchar \u2502 varchar \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 vis         \u2502 ENUM('hide', 'visible')[] \u2502 YES     \u2502         \u2502         \u2502         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nFollowwing query was created as enum but not enum array.\r\n\r\n```sql\r\nD create or replace table T (vis enum ('hide', 'visible')[]);\r\nD DESCRIBE T;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 column_name \u2502       column_type       \u2502  null   \u2502   key   \u2502 default \u2502  extra  \u2502\r\n\u2502   varchar   \u2502         varchar         \u2502 varchar \u2502 varchar \u2502 varchar \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 vis         \u2502 ENUM('hide', 'visible') \u2502 YES     \u2502         \u2502         \u2502         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nOf course, inserting enum array has failed.\r\n\r\n```sql\r\nD insert into T values (['hide', 'visible']);\r\nConversion Error: Unimplemented type for cast (VARCHAR[] -> ENUM('hide', 'visible'))\r\nLINE 1: insert into T values (['hide', 'visible']);\r\n```\r\n\r\nIs this expected feature?\r\n\n\n### To Reproduce\n\nIn `duckdb_cli`\r\n\r\n```sql\r\ncreate or replace table T (vis enum ('hide', 'visible')[]);\r\n```\r\n\r\nExpected result:\r\n\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 column_name \u2502        column_type        \u2502  null   \u2502   key   \u2502 default \u2502  extra  \u2502\r\n\u2502   varchar   \u2502          varchar          \u2502 varchar \u2502 varchar \u2502 varchar \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 vis         \u2502 ENUM('hide', 'visible')[] \u2502 YES     \u2502         \u2502         \u2502         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nActual result:\r\n\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 column_name \u2502       column_type       \u2502  null   \u2502   key   \u2502 default \u2502  extra  \u2502\r\n\u2502   varchar   \u2502         varchar         \u2502 varchar \u2502 varchar \u2502 varchar \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 vis         \u2502 ENUM('hide', 'visible') \u2502 YES     \u2502         \u2502         \u2502         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n\n### OS:\n\nMacOS Ventura 13.6.7 (x86_64 16GB RAM)\n\n### DuckDB Version:\n\n1.1.0\n\n### DuckDB Client:\n\nduckdb_cli\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nKazuhiko TAMURA\n\n### Affiliation:\n\nFree\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have not tested with any build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "That sounds like a bug, thanks for the report \ud83d\udc4d ",
  "created_at": "2024-09-24T16:42:09Z"
}