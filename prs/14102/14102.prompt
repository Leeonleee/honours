You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
To create table containing a column with enum array
### What happens?

I've tried to create a table containing enum array.

Followwing query was expect result.

```sql
D create type Visibility as enum ('hide', 'visible');
D create or replace table T (vis Visibility[]);
D DESCRIBE T;
┌─────────────┬───────────────────────────┬─────────┬─────────┬─────────┬─────────┐
│ column_name │        column_type        │  null   │   key   │ default │  extra  │
│   varchar   │          varchar          │ varchar │ varchar │ varchar │ varchar │
├─────────────┼───────────────────────────┼─────────┼─────────┼─────────┼─────────┤
│ vis         │ ENUM('hide', 'visible')[] │ YES     │         │         │         │
└─────────────┴───────────────────────────┴─────────┴─────────┴─────────┴─────────┘
```

Followwing query was created as enum but not enum array.

```sql
D create or replace table T (vis enum ('hide', 'visible')[]);
D DESCRIBE T;
┌─────────────┬─────────────────────────┬─────────┬─────────┬─────────┬─────────┐
│ column_name │       column_type       │  null   │   key   │ default │  extra  │
│   varchar   │         varchar         │ varchar │ varchar │ varchar │ varchar │
├─────────────┼─────────────────────────┼─────────┼─────────┼─────────┼─────────┤
│ vis         │ ENUM('hide', 'visible') │ YES     │         │         │         │
└─────────────┴─────────────────────────┴─────────┴─────────┴─────────┴─────────┘

Of course, inserting enum array has failed.

```sql
D insert into T values (['hide', 'visible']);
Conversion Error: Unimplemented type for cast (VARCHAR[] -> ENUM('hide', 'visible'))
LINE 1: insert into T values (['hide', 'visible']);
```

Is this expected feature?


### To Reproduce

In `duckdb_cli`

```sql
create or replace table T (vis enum ('hide', 'visible')[]);
```

Expected result:

```
┌─────────────┬───────────────────────────┬─────────┬─────────┬─────────┬─────────┐
│ column_name │        column_type        │  null   │   key   │ default │  extra  │
│   varchar   │          varchar          │ varchar │ varchar │ varchar │ varchar │
├─────────────┼───────────────────────────┼─────────┼─────────┼─────────┼─────────┤
│ vis         │ ENUM('hide', 'visible')[] │ YES     │         │         │         │
└─────────────┴───────────────────────────┴─────────┴─────────┴─────────┴─────────┘
```

Actual result:

```
┌─────────────┬─────────────────────────┬─────────┬─────────┬─────────┬─────────┐
│ column_name │       column_type       │  null   │   key   │ default │  extra  │
│   varchar   │         varchar         │ varchar │ varchar │ varchar │ varchar │
├─────────────┼─────────────────────────┼─────────┼─────────┼─────────┼─────────┤
│ vis         │ ENUM('hide', 'visible') │ YES     │         │         │         │
└─────────────┴─────────────────────────┴─────────┴─────────┴─────────┴─────────┘
```

### OS:

MacOS Ventura 13.6.7 (x86_64 16GB RAM)

### DuckDB Version:

1.1.0

### DuckDB Client:

duckdb_cli

### Hardware:

_No response_

### Full Name:

Kazuhiko TAMURA

### Affiliation:

Free

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have not tested with any build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/include/duckdb/parser/transformer.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parser/transformer.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/case_insensitive_map.hpp"
12: #include "duckdb/common/constants.hpp"
13: #include "duckdb/common/enums/expression_type.hpp"
14: #include "duckdb/common/stack_checker.hpp"
15: #include "duckdb/common/types.hpp"
16: #include "duckdb/common/unordered_map.hpp"
17: #include "duckdb/parser/group_by_node.hpp"
18: #include "duckdb/parser/parsed_data/create_info.hpp"
19: #include "duckdb/parser/parsed_data/create_secret_info.hpp"
20: #include "duckdb/parser/qualified_name.hpp"
21: #include "duckdb/parser/query_node.hpp"
22: #include "duckdb/parser/query_node/cte_node.hpp"
23: #include "duckdb/parser/tokens.hpp"
24: #include "nodes/parsenodes.hpp"
25: #include "nodes/primnodes.hpp"
26: #include "pg_definitions.hpp"
27: #include "duckdb/parser/expression/parameter_expression.hpp"
28: #include "duckdb/common/enums/on_entry_not_found.hpp"
29: 
30: namespace duckdb {
31: 
32: class ColumnDefinition;
33: struct OrderByNode;
34: struct CopyInfo;
35: struct CommonTableExpressionInfo;
36: struct GroupingExpressionMap;
37: class OnConflictInfo;
38: class UpdateSetInfo;
39: class MacroFunction;
40: struct ParserOptions;
41: struct PivotColumn;
42: struct PivotColumnEntry;
43: 
44: //! The transformer class is responsible for transforming the internal Postgres
45: //! parser representation into the DuckDB representation
46: class Transformer {
47: 	friend class StackChecker<Transformer>;
48: 
49: 	struct CreatePivotEntry {
50: 		string enum_name;
51: 		unique_ptr<SelectNode> base;
52: 		unique_ptr<ParsedExpression> column;
53: 		unique_ptr<QueryNode> subquery;
54: 		bool has_parameters;
55: 	};
56: 
57: public:
58: 	explicit Transformer(ParserOptions &options);
59: 	Transformer(Transformer &parent);
60: 	~Transformer();
61: 
62: 	//! Transforms a Postgres parse tree into a set of SQL Statements
63: 	bool TransformParseTree(duckdb_libpgquery::PGList *tree, vector<unique_ptr<SQLStatement>> &statements);
64: 	string NodetypeToString(duckdb_libpgquery::PGNodeTag type);
65: 
66: 	idx_t ParamCount() const;
67: 
68: private:
69: 	optional_ptr<Transformer> parent;
70: 	//! Parser options
71: 	ParserOptions &options;
72: 	//! The current prepared statement parameter index
73: 	idx_t prepared_statement_parameter_index = 0;
74: 	//! Map from named parameter to parameter index;
75: 	case_insensitive_map_t<idx_t> named_param_map;
76: 	//! Last parameter type
77: 	PreparedParamType last_param_type = PreparedParamType::INVALID;
78: 	//! Holds window expressions defined by name. We need those when transforming the expressions referring to them.
79: 	case_insensitive_map_t<duckdb_libpgquery::PGWindowDef *> window_clauses;
80: 	//! The set of pivot entries to create
81: 	vector<unique_ptr<CreatePivotEntry>> pivot_entries;
82: 	//! Sets of stored CTEs, if any
83: 	vector<CommonTableExpressionMap *> stored_cte_map;
84: 	//! Whether or not we are currently binding a window definition
85: 	bool in_window_definition = false;
86: 
87: 	void Clear();
88: 	bool InWindowDefinition();
89: 
90: 	Transformer &RootTransformer();
91: 	const Transformer &RootTransformer() const;
92: 	void SetParamCount(idx_t new_count);
93: 	void ClearParameters();
94: 	void SetParam(const string &name, idx_t index, PreparedParamType type);
95: 	bool GetParam(const string &name, idx_t &index, PreparedParamType type);
96: 
97: 	void AddPivotEntry(string enum_name, unique_ptr<SelectNode> source, unique_ptr<ParsedExpression> column,
98: 	                   unique_ptr<QueryNode> subquery, bool has_parameters);
99: 	unique_ptr<SQLStatement> GenerateCreateEnumStmt(unique_ptr<CreatePivotEntry> entry);
100: 	bool HasPivotEntries();
101: 	idx_t PivotEntryCount();
102: 	vector<unique_ptr<CreatePivotEntry>> &GetPivotEntries();
103: 	void PivotEntryCheck(const string &type);
104: 	void ExtractCTEsRecursive(CommonTableExpressionMap &cte_map);
105: 
106: private:
107: 	//! Transforms a Postgres statement into a single SQL statement
108: 	unique_ptr<SQLStatement> TransformStatement(duckdb_libpgquery::PGNode &stmt);
109: 	//! Transforms a Postgres statement into a single SQL statement
110: 	unique_ptr<SQLStatement> TransformStatementInternal(duckdb_libpgquery::PGNode &stmt);
111: 	//===--------------------------------------------------------------------===//
112: 	// Statement transformation
113: 	//===--------------------------------------------------------------------===//
114: 	//! Transform a Postgres duckdb_libpgquery::T_PGSelectStmt node into a SelectStatement
115: 	unique_ptr<SelectStatement> TransformSelectStmt(duckdb_libpgquery::PGSelectStmt &select, bool is_select = true);
116: 	unique_ptr<SelectStatement> TransformSelectStmt(duckdb_libpgquery::PGNode &node, bool is_select = true);
117: 	//! Transform a Postgres T_AlterStmt node into a AlterStatement
118: 	unique_ptr<AlterStatement> TransformAlter(duckdb_libpgquery::PGAlterTableStmt &stmt);
119: 	//! Transform a Postgres duckdb_libpgquery::T_PGRenameStmt node into a RenameStatement
120: 	unique_ptr<AlterStatement> TransformRename(duckdb_libpgquery::PGRenameStmt &stmt);
121: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateStmt node into a CreateStatement
122: 	unique_ptr<CreateStatement> TransformCreateTable(duckdb_libpgquery::PGCreateStmt &node);
123: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateStmt node into a CreateStatement
124: 	unique_ptr<CreateStatement> TransformCreateTableAs(duckdb_libpgquery::PGCreateTableAsStmt &stmt);
125: 	//! Transform a Postgres node into a CreateStatement
126: 	unique_ptr<CreateStatement> TransformCreateSchema(duckdb_libpgquery::PGCreateSchemaStmt &stmt);
127: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateSeqStmt node into a CreateStatement
128: 	unique_ptr<CreateStatement> TransformCreateSequence(duckdb_libpgquery::PGCreateSeqStmt &node);
129: 	//! Transform a Postgres duckdb_libpgquery::T_PGViewStmt node into a CreateStatement
130: 	unique_ptr<CreateStatement> TransformCreateView(duckdb_libpgquery::PGViewStmt &node);
131: 	//! Transform a Postgres duckdb_libpgquery::T_PGIndexStmt node into CreateStatement
132: 	unique_ptr<CreateStatement> TransformCreateIndex(duckdb_libpgquery::PGIndexStmt &stmt);
133: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateFunctionStmt node into CreateStatement
134: 	unique_ptr<CreateStatement> TransformCreateFunction(duckdb_libpgquery::PGCreateFunctionStmt &stmt);
135: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateTypeStmt node into CreateStatement
136: 	unique_ptr<CreateStatement> TransformCreateType(duckdb_libpgquery::PGCreateTypeStmt &stmt);
137: 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateTypeStmt node into CreateStatement
138: 	unique_ptr<AlterStatement> TransformCommentOn(duckdb_libpgquery::PGCommentOnStmt &stmt);
139: 	//! Transform a Postgres duckdb_libpgquery::T_PGAlterSeqStmt node into CreateStatement
140: 	unique_ptr<AlterStatement> TransformAlterSequence(duckdb_libpgquery::PGAlterSeqStmt &stmt);
141: 	//! Transform a Postgres duckdb_libpgquery::T_PGDropStmt node into a Drop[Table,Schema]Statement
142: 	unique_ptr<SQLStatement> TransformDrop(duckdb_libpgquery::PGDropStmt &stmt);
143: 	//! Transform a Postgres duckdb_libpgquery::T_PGInsertStmt node into a InsertStatement
144: 	unique_ptr<InsertStatement> TransformInsert(duckdb_libpgquery::PGInsertStmt &stmt);
145: 
146: 	//! Transform a Postgres duckdb_libpgquery::T_PGOnConflictClause node into a OnConflictInfo
147: 	unique_ptr<OnConflictInfo> TransformOnConflictClause(duckdb_libpgquery::PGOnConflictClause *node,
148: 	                                                     const string &relname);
149: 	//! Transform a ON CONFLICT shorthand into a OnConflictInfo
150: 	unique_ptr<OnConflictInfo> DummyOnConflictClause(duckdb_libpgquery::PGOnConflictActionAlias type,
151: 	                                                 const string &relname);
152: 	//! Transform a Postgres duckdb_libpgquery::T_PGCopyStmt node into a CopyStatement
153: 	unique_ptr<CopyStatement> TransformCopy(duckdb_libpgquery::PGCopyStmt &stmt);
154: 	void TransformCopyOptions(CopyInfo &info, optional_ptr<duckdb_libpgquery::PGList> options);
155: 	void TransformCreateSecretOptions(CreateSecretInfo &info, optional_ptr<duckdb_libpgquery::PGList> options);
156: 	//! Transform a Postgres duckdb_libpgquery::T_PGTransactionStmt node into a TransactionStatement
157: 	unique_ptr<TransactionStatement> TransformTransaction(duckdb_libpgquery::PGTransactionStmt &stmt);
158: 	//! Transform a Postgres T_DeleteStatement node into a DeleteStatement
159: 	unique_ptr<DeleteStatement> TransformDelete(duckdb_libpgquery::PGDeleteStmt &stmt);
160: 	//! Transform a Postgres duckdb_libpgquery::T_PGUpdateStmt node into a UpdateStatement
161: 	unique_ptr<UpdateStatement> TransformUpdate(duckdb_libpgquery::PGUpdateStmt &stmt);
162: 	//! Transform a Postgres duckdb_libpgquery::T_PGUpdateExtensionsStmt node into a UpdateExtensionsStatement
163: 	unique_ptr<UpdateExtensionsStatement> TransformUpdateExtensions(duckdb_libpgquery::PGUpdateExtensionsStmt &stmt);
164: 	//! Transform a Postgres duckdb_libpgquery::T_PGPragmaStmt node into a PragmaStatement
165: 	unique_ptr<SQLStatement> TransformPragma(duckdb_libpgquery::PGPragmaStmt &stmt);
166: 	//! Transform a Postgres duckdb_libpgquery::T_PGExportStmt node into a ExportStatement
167: 	unique_ptr<ExportStatement> TransformExport(duckdb_libpgquery::PGExportStmt &stmt);
168: 	//! Transform a Postgres duckdb_libpgquery::T_PGImportStmt node into a PragmaStatement
169: 	unique_ptr<PragmaStatement> TransformImport(duckdb_libpgquery::PGImportStmt &stmt);
170: 	unique_ptr<ExplainStatement> TransformExplain(duckdb_libpgquery::PGExplainStmt &stmt);
171: 	unique_ptr<SQLStatement> TransformVacuum(duckdb_libpgquery::PGVacuumStmt &stmt);
172: 	unique_ptr<QueryNode> TransformShow(duckdb_libpgquery::PGVariableShowStmt &stmt);
173: 	unique_ptr<SelectStatement> TransformShowStmt(duckdb_libpgquery::PGVariableShowStmt &stmt);
174: 	unique_ptr<QueryNode> TransformShowSelect(duckdb_libpgquery::PGVariableShowSelectStmt &stmt);
175: 	unique_ptr<SelectStatement> TransformShowSelectStmt(duckdb_libpgquery::PGVariableShowSelectStmt &stmt);
176: 	unique_ptr<AttachStatement> TransformAttach(duckdb_libpgquery::PGAttachStmt &stmt);
177: 	unique_ptr<DetachStatement> TransformDetach(duckdb_libpgquery::PGDetachStmt &stmt);
178: 	unique_ptr<SetStatement> TransformUse(duckdb_libpgquery::PGUseStmt &stmt);
179: 	unique_ptr<SQLStatement> TransformCopyDatabase(duckdb_libpgquery::PGCopyDatabaseStmt &stmt);
180: 	unique_ptr<CreateStatement> TransformSecret(duckdb_libpgquery::PGCreateSecretStmt &stmt);
181: 	unique_ptr<DropStatement> TransformDropSecret(duckdb_libpgquery::PGDropSecretStmt &stmt);
182: 
183: 	unique_ptr<PrepareStatement> TransformPrepare(duckdb_libpgquery::PGPrepareStmt &stmt);
184: 	unique_ptr<ExecuteStatement> TransformExecute(duckdb_libpgquery::PGExecuteStmt &stmt);
185: 	unique_ptr<CallStatement> TransformCall(duckdb_libpgquery::PGCallStmt &stmt);
186: 	unique_ptr<DropStatement> TransformDeallocate(duckdb_libpgquery::PGDeallocateStmt &stmt);
187: 	unique_ptr<QueryNode> TransformPivotStatement(duckdb_libpgquery::PGSelectStmt &select);
188: 	unique_ptr<SQLStatement> CreatePivotStatement(unique_ptr<SQLStatement> statement);
189: 	PivotColumn TransformPivotColumn(duckdb_libpgquery::PGPivot &pivot, bool is_pivot);
190: 	vector<PivotColumn> TransformPivotList(duckdb_libpgquery::PGList &list, bool is_pivot);
191: 	static bool TransformPivotInList(unique_ptr<ParsedExpression> &expr, PivotColumnEntry &entry,
192: 	                                 bool root_entry = true);
193: 
194: 	//===--------------------------------------------------------------------===//
195: 	// SetStatement Transform
196: 	//===--------------------------------------------------------------------===//
197: 	unique_ptr<SetStatement> TransformSet(duckdb_libpgquery::PGVariableSetStmt &set);
198: 	unique_ptr<SetStatement> TransformSetVariable(duckdb_libpgquery::PGVariableSetStmt &stmt);
199: 	unique_ptr<SetStatement> TransformResetVariable(duckdb_libpgquery::PGVariableSetStmt &stmt);
200: 
201: 	unique_ptr<SQLStatement> TransformCheckpoint(duckdb_libpgquery::PGCheckPointStmt &stmt);
202: 	unique_ptr<LoadStatement> TransformLoad(duckdb_libpgquery::PGLoadStmt &stmt);
203: 
204: 	//===--------------------------------------------------------------------===//
205: 	// Query Node Transform
206: 	//===--------------------------------------------------------------------===//
207: 	//! Transform a Postgres duckdb_libpgquery::T_PGSelectStmt node into a QueryNode
208: 	unique_ptr<QueryNode> TransformSelectNode(duckdb_libpgquery::PGNode &select, bool is_select = true);
209: 	unique_ptr<QueryNode> TransformSelectNodeInternal(duckdb_libpgquery::PGSelectStmt &select, bool is_select = true);
210: 	unique_ptr<QueryNode> TransformSelectInternal(duckdb_libpgquery::PGSelectStmt &select);
211: 	void TransformModifiers(duckdb_libpgquery::PGSelectStmt &stmt, QueryNode &node);
212: 
213: 	//===--------------------------------------------------------------------===//
214: 	// Expression Transform
215: 	//===--------------------------------------------------------------------===//
216: 	//! Transform a Postgres boolean expression into an Expression
217: 	unique_ptr<ParsedExpression> TransformBoolExpr(duckdb_libpgquery::PGBoolExpr &root);
218: 	//! Transform a Postgres case expression into an Expression
219: 	unique_ptr<ParsedExpression> TransformCase(duckdb_libpgquery::PGCaseExpr &root);
220: 	//! Transform a Postgres type cast into an Expression
221: 	unique_ptr<ParsedExpression> TransformTypeCast(duckdb_libpgquery::PGTypeCast &root);
222: 	//! Transform a Postgres coalesce into an Expression
223: 	unique_ptr<ParsedExpression> TransformCoalesce(duckdb_libpgquery::PGAExpr &root);
224: 	//! Transform a Postgres column reference into an Expression
225: 	unique_ptr<ParsedExpression> TransformColumnRef(duckdb_libpgquery::PGColumnRef &root);
226: 	//! Transform a Postgres constant value into an Expression
227: 	unique_ptr<ConstantExpression> TransformValue(duckdb_libpgquery::PGValue val);
228: 	//! Transform a Postgres operator into an Expression
229: 	unique_ptr<ParsedExpression> TransformAExpr(duckdb_libpgquery::PGAExpr &root);
230: 	unique_ptr<ParsedExpression> TransformAExprInternal(duckdb_libpgquery::PGAExpr &root);
231: 	//! Transform a Postgres abstract expression into an Expression
232: 	unique_ptr<ParsedExpression> TransformExpression(optional_ptr<duckdb_libpgquery::PGNode> node);
233: 	unique_ptr<ParsedExpression> TransformExpression(duckdb_libpgquery::PGNode &node);
234: 	//! Transform a Postgres function call into an Expression
235: 	unique_ptr<ParsedExpression> TransformFuncCall(duckdb_libpgquery::PGFuncCall &root);
236: 	//! Transform a Postgres boolean expression into an Expression
237: 	unique_ptr<ParsedExpression> TransformInterval(duckdb_libpgquery::PGIntervalConstant &root);
238: 	//! Transform a Postgres lambda node [e.g. (x, y) -> x + y] into a lambda expression
239: 	unique_ptr<ParsedExpression> TransformLambda(duckdb_libpgquery::PGLambdaFunction &node);
240: 	//! Transform a Postgres array access node (e.g. x[1] or x[1:3])
241: 	unique_ptr<ParsedExpression> TransformArrayAccess(duckdb_libpgquery::PGAIndirection &node);
242: 	//! Transform a positional reference (e.g. #1)
243: 	unique_ptr<ParsedExpression> TransformPositionalReference(duckdb_libpgquery::PGPositionalReference &node);
244: 	unique_ptr<ParsedExpression> TransformStarExpression(duckdb_libpgquery::PGAStar &node);
245: 	unique_ptr<ParsedExpression> TransformBooleanTest(duckdb_libpgquery::PGBooleanTest &node);
246: 
247: 	//! Transform a Postgres constant value into an Expression
248: 	unique_ptr<ParsedExpression> TransformConstant(duckdb_libpgquery::PGAConst &c);
249: 	unique_ptr<ParsedExpression> TransformGroupingFunction(duckdb_libpgquery::PGGroupingFunc &n);
250: 	unique_ptr<ParsedExpression> TransformResTarget(duckdb_libpgquery::PGResTarget &root);
251: 	unique_ptr<ParsedExpression> TransformNullTest(duckdb_libpgquery::PGNullTest &root);
252: 	unique_ptr<ParsedExpression> TransformParamRef(duckdb_libpgquery::PGParamRef &node);
253: 	unique_ptr<ParsedExpression> TransformNamedArg(duckdb_libpgquery::PGNamedArgExpr &root);
254: 
255: 	//! Transform multi assignment reference into an Expression
256: 	unique_ptr<ParsedExpression> TransformMultiAssignRef(duckdb_libpgquery::PGMultiAssignRef &root);
257: 
258: 	unique_ptr<ParsedExpression> TransformSQLValueFunction(duckdb_libpgquery::PGSQLValueFunction &node);
259: 
260: 	unique_ptr<ParsedExpression> TransformSubquery(duckdb_libpgquery::PGSubLink &root);
261: 	//===--------------------------------------------------------------------===//
262: 	// Constraints transform
263: 	//===--------------------------------------------------------------------===//
264: 	unique_ptr<Constraint> TransformConstraint(duckdb_libpgquery::PGListCell &cell);
265: 	unique_ptr<Constraint> TransformConstraint(duckdb_libpgquery::PGListCell &cell, ColumnDefinition &column,
266: 	                                           idx_t index);
267: 
268: 	//===--------------------------------------------------------------------===//
269: 	// Update transform
270: 	//===--------------------------------------------------------------------===//
271: 	unique_ptr<UpdateSetInfo> TransformUpdateSetInfo(duckdb_libpgquery::PGList *target_list,
272: 	                                                 duckdb_libpgquery::PGNode *where_clause);
273: 
274: 	//===--------------------------------------------------------------------===//
275: 	// Index transform
276: 	//===--------------------------------------------------------------------===//
277: 	vector<unique_ptr<ParsedExpression>> TransformIndexParameters(duckdb_libpgquery::PGList &list,
278: 	                                                              const string &relation_name);
279: 
280: 	//===--------------------------------------------------------------------===//
281: 	// Collation transform
282: 	//===--------------------------------------------------------------------===//
283: 	unique_ptr<ParsedExpression> TransformCollateExpr(duckdb_libpgquery::PGCollateClause &collate);
284: 
285: 	string TransformCollation(optional_ptr<duckdb_libpgquery::PGCollateClause> collate);
286: 
287: 	ColumnDefinition TransformColumnDefinition(duckdb_libpgquery::PGColumnDef &cdef);
288: 	//===--------------------------------------------------------------------===//
289: 	// Helpers
290: 	//===--------------------------------------------------------------------===//
291: 	OnCreateConflict TransformOnConflict(duckdb_libpgquery::PGOnCreateConflict conflict);
292: 	string TransformAlias(duckdb_libpgquery::PGAlias *root, vector<string> &column_name_alias);
293: 	vector<string> TransformStringList(duckdb_libpgquery::PGList *list);
294: 	void TransformCTE(duckdb_libpgquery::PGWithClause &de_with_clause, CommonTableExpressionMap &cte_map);
295: 	static unique_ptr<QueryNode> TransformMaterializedCTE(unique_ptr<QueryNode> root);
296: 	unique_ptr<SelectStatement> TransformRecursiveCTE(duckdb_libpgquery::PGCommonTableExpr &node,
297: 	                                                  CommonTableExpressionInfo &info);
298: 
299: 	unique_ptr<ParsedExpression> TransformUnaryOperator(const string &op, unique_ptr<ParsedExpression> child);
300: 	unique_ptr<ParsedExpression> TransformBinaryOperator(string op, unique_ptr<ParsedExpression> left,
301: 	                                                     unique_ptr<ParsedExpression> right);
302: 	static bool ConstructConstantFromExpression(const ParsedExpression &expr, Value &value);
303: 	//===--------------------------------------------------------------------===//
304: 	// TableRef transform
305: 	//===--------------------------------------------------------------------===//
306: 	//! Transform a Postgres node into a TableRef
307: 	unique_ptr<TableRef> TransformTableRefNode(duckdb_libpgquery::PGNode &n);
308: 	//! Transform a Postgres FROM clause into a TableRef
309: 	unique_ptr<TableRef> TransformFrom(optional_ptr<duckdb_libpgquery::PGList> root);
310: 	//! Transform a Postgres table reference into a TableRef
311: 	unique_ptr<TableRef> TransformRangeVar(duckdb_libpgquery::PGRangeVar &root);
312: 	//! Transform a Postgres table-producing function into a TableRef
313: 	unique_ptr<TableRef> TransformRangeFunction(duckdb_libpgquery::PGRangeFunction &root);
314: 	//! Transform a Postgres join node into a TableRef
315: 	unique_ptr<TableRef> TransformJoin(duckdb_libpgquery::PGJoinExpr &root);
316: 	//! Transform a Postgres pivot node into a TableRef
317: 	unique_ptr<TableRef> TransformPivot(duckdb_libpgquery::PGPivotExpr &root);
318: 	//! Transform a table producing subquery into a TableRef
319: 	unique_ptr<TableRef> TransformRangeSubselect(duckdb_libpgquery::PGRangeSubselect &root);
320: 	//! Transform a VALUES list into a set of expressions
321: 	unique_ptr<TableRef> TransformValuesList(duckdb_libpgquery::PGList *list);
322: 
323: 	//! Transform a range var into a (schema) qualified name
324: 	QualifiedName TransformQualifiedName(duckdb_libpgquery::PGRangeVar &root);
325: 
326: 	//! Transform a Postgres TypeName string into a LogicalType
327: 	LogicalType TransformTypeName(duckdb_libpgquery::PGTypeName &name);
328: 
329: 	//! Transform a list of type modifiers into a list of values
330: 	vector<Value> TransformTypeModifiers(duckdb_libpgquery::PGTypeName &name);
331: 
332: 	//! Transform a Postgres GROUP BY expression into a list of Expression
333: 	bool TransformGroupBy(optional_ptr<duckdb_libpgquery::PGList> group, SelectNode &result);
334: 	void TransformGroupByNode(duckdb_libpgquery::PGNode &n, GroupingExpressionMap &map, SelectNode &result,
335: 	                          vector<GroupingSet> &result_sets);
336: 	void AddGroupByExpression(unique_ptr<ParsedExpression> expression, GroupingExpressionMap &map, GroupByNode &result,
337: 	                          vector<idx_t> &result_set);
338: 	void TransformGroupByExpression(duckdb_libpgquery::PGNode &n, GroupingExpressionMap &map, GroupByNode &result,
339: 	                                vector<idx_t> &result_set);
340: 	//! Transform a Postgres ORDER BY expression into an OrderByDescription
341: 	bool TransformOrderBy(duckdb_libpgquery::PGList *order, vector<OrderByNode> &result);
342: 
343: 	//! Transform to a IN or NOT IN expression
344: 	unique_ptr<ParsedExpression> TransformInExpression(const string &name, duckdb_libpgquery::PGAExpr &root);
345: 
346: 	//! Transform a Postgres SELECT clause into a list of Expressions
347: 	void TransformExpressionList(duckdb_libpgquery::PGList &list, vector<unique_ptr<ParsedExpression>> &result);
348: 
349: 	//! Transform a Postgres PARTITION BY/ORDER BY specification into lists of expressions
350: 	void TransformWindowDef(duckdb_libpgquery::PGWindowDef &window_spec, WindowExpression &expr,
351: 	                        const char *window_name = nullptr);
352: 	//! Transform a Postgres window frame specification into frame expressions
353: 	void TransformWindowFrame(duckdb_libpgquery::PGWindowDef &window_spec, WindowExpression &expr);
354: 
355: 	unique_ptr<SampleOptions> TransformSampleOptions(optional_ptr<duckdb_libpgquery::PGNode> options);
356: 	//! Returns true if an expression is only a star (i.e. "*", without any other decorators)
357: 	bool ExpressionIsEmptyStar(ParsedExpression &expr);
358: 
359: 	OnEntryNotFound TransformOnEntryNotFound(bool missing_ok);
360: 
361: 	Vector PGListToVector(optional_ptr<duckdb_libpgquery::PGList> column_list, idx_t &size);
362: 	vector<string> TransformConflictTarget(duckdb_libpgquery::PGList &list);
363: 
364: 	unique_ptr<MacroFunction> TransformMacroFunction(duckdb_libpgquery::PGFunctionDefinition &function);
365: 
366: 	void ParseGenericOptionListEntry(case_insensitive_map_t<vector<Value>> &result_options, string &name,
367: 	                                 duckdb_libpgquery::PGNode *arg);
368: 
369: public:
370: 	static void SetQueryLocation(ParsedExpression &expr, int query_location);
371: 	static void SetQueryLocation(TableRef &ref, int query_location);
372: 
373: private:
374: 	//! Current stack depth
375: 	idx_t stack_depth;
376: 
377: 	void InitializeStackCheck();
378: 	StackChecker<Transformer> StackCheck(idx_t extra_stack = 1);
379: 
380: public:
381: 	template <class T>
382: 	static T &PGCast(duckdb_libpgquery::PGNode &node) {
383: 		return reinterpret_cast<T &>(node);
384: 	}
385: 	template <class T>
386: 	static optional_ptr<T> PGPointerCast(void *ptr) {
387: 		return optional_ptr<T>(reinterpret_cast<T *>(ptr));
388: 	}
389: };
390: 
391: vector<string> ReadPgListToString(duckdb_libpgquery::PGList *column_list);
392: 
393: } // namespace duckdb
[end of src/include/duckdb/parser/transformer.hpp]
[start of src/parser/transform/helpers/transform_typename.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/common/pair.hpp"
3: #include "duckdb/common/case_insensitive_map.hpp"
4: 
5: #include "duckdb/parser/transformer.hpp"
6: #include "duckdb/common/types/decimal.hpp"
7: #include "duckdb/common/types/vector.hpp"
8: #include "duckdb/parser/expression/constant_expression.hpp"
9: 
10: namespace duckdb {
11: 
12: struct SizeModifiers {
13: 	int64_t width = 0;
14: 	int64_t scale = 0;
15: 	// How many modifiers were found
16: 	idx_t count = 0;
17: };
18: 
19: static SizeModifiers GetSizeModifiers(duckdb_libpgquery::PGTypeName &type_name, LogicalTypeId base_type) {
20: 
21: 	SizeModifiers result;
22: 
23: 	if (base_type == LogicalTypeId::DECIMAL) {
24: 		// Defaults for DECIMAL
25: 		result.width = 18;
26: 		result.scale = 3;
27: 	}
28: 
29: 	if (type_name.typmods) {
30: 		for (auto node = type_name.typmods->head; node; node = node->next) {
31: 			auto &const_val = *Transformer::PGPointerCast<duckdb_libpgquery::PGAConst>(node->data.ptr_value);
32: 			if (const_val.type != duckdb_libpgquery::T_PGAConst ||
33: 			    const_val.val.type != duckdb_libpgquery::T_PGInteger) {
34: 				throw ParserException("Expected an integer constant as type modifier");
35: 			}
36: 			if (const_val.val.val.ival < 0) {
37: 				throw ParserException("Negative modifier not supported");
38: 			}
39: 			if (result.count == 0) {
40: 				result.width = const_val.val.val.ival;
41: 				if (base_type == LogicalTypeId::BIT && const_val.location != -1) {
42: 					result.width = 0;
43: 				}
44: 			} else if (result.count == 1) {
45: 				result.scale = const_val.val.val.ival;
46: 			} else {
47: 				throw ParserException("A maximum of two modifiers is supported");
48: 			}
49: 			result.count++;
50: 		}
51: 	}
52: 	return result;
53: }
54: 
55: vector<Value> Transformer::TransformTypeModifiers(duckdb_libpgquery::PGTypeName &type_name) {
56: 	vector<Value> type_mods;
57: 	if (type_name.typmods) {
58: 		for (auto node = type_name.typmods->head; node; node = node->next) {
59: 			if (type_mods.size() > 9) {
60: 				auto name = PGPointerCast<duckdb_libpgquery::PGValue>(type_name.names->tail->data.ptr_value)->val.str;
61: 				throw ParserException("'%s': a maximum of 9 type modifiers is allowed", name);
62: 			}
63: 			auto &const_val = *PGPointerCast<duckdb_libpgquery::PGAConst>(node->data.ptr_value);
64: 			if (const_val.type != duckdb_libpgquery::T_PGAConst) {
65: 				throw ParserException("Expected a constant as type modifier");
66: 			}
67: 			auto const_expr = TransformValue(const_val.val);
68: 			type_mods.push_back(std::move(const_expr->value));
69: 		}
70: 	}
71: 	return type_mods;
72: }
73: 
74: LogicalType Transformer::TransformTypeName(duckdb_libpgquery::PGTypeName &type_name) {
75: 	if (type_name.type != duckdb_libpgquery::T_PGTypeName) {
76: 		throw ParserException("Expected a type");
77: 	}
78: 	auto stack_checker = StackCheck();
79: 
80: 	if (type_name.names->length > 1) {
81: 		// qualified typename
82: 		vector<string> names;
83: 		for (auto cell = type_name.names->head; cell; cell = cell->next) {
84: 			names.push_back(PGPointerCast<duckdb_libpgquery::PGValue>(cell->data.ptr_value)->val.str);
85: 		}
86: 		vector<Value> type_mods = TransformTypeModifiers(type_name);
87: 		switch (type_name.names->length) {
88: 		case 2:
89: 			return LogicalType::USER(INVALID_CATALOG, std::move(names[0]), std::move(names[1]), std::move(type_mods));
90: 		case 3:
91: 			return LogicalType::USER(std::move(names[0]), std::move(names[1]), std::move(names[2]),
92: 			                         std::move(type_mods));
93: 		default:
94: 			throw ParserException(
95: 			    "Too many qualifications for type name - expected [catalog.schema.name] or [schema.name]");
96: 		}
97: 	}
98: 	auto name = PGPointerCast<duckdb_libpgquery::PGValue>(type_name.names->tail->data.ptr_value)->val.str;
99: 	// transform it to the SQL type
100: 	LogicalTypeId base_type = TransformStringToLogicalTypeId(name);
101: 
102: 	LogicalType result_type;
103: 	if (base_type == LogicalTypeId::LIST) {
104: 		throw ParserException("LIST is not valid as a stand-alone type");
105: 	} else if (base_type == LogicalTypeId::ENUM) {
106: 		if (!type_name.typmods || type_name.typmods->length == 0) {
107: 			throw ParserException("Enum needs a set of entries");
108: 		}
109: 		Vector enum_vector(LogicalType::VARCHAR, NumericCast<idx_t>(type_name.typmods->length));
110: 		auto string_data = FlatVector::GetData<string_t>(enum_vector);
111: 		idx_t pos = 0;
112: 		for (auto node = type_name.typmods->head; node; node = node->next) {
113: 			auto constant_value = PGPointerCast<duckdb_libpgquery::PGAConst>(node->data.ptr_value);
114: 			if (constant_value->type != duckdb_libpgquery::T_PGAConst ||
115: 			    constant_value->val.type != duckdb_libpgquery::T_PGString) {
116: 				throw ParserException("Enum type requires a set of strings as type modifiers");
117: 			}
118: 			string_data[pos++] = StringVector::AddString(enum_vector, constant_value->val.val.str);
119: 		}
120: 		return LogicalType::ENUM(enum_vector, NumericCast<idx_t>(type_name.typmods->length));
121: 	} else if (base_type == LogicalTypeId::STRUCT) {
122: 		if (!type_name.typmods || type_name.typmods->length == 0) {
123: 			throw ParserException("Struct needs a name and entries");
124: 		}
125: 		child_list_t<LogicalType> children;
126: 		case_insensitive_set_t name_collision_set;
127: 
128: 		for (auto node = type_name.typmods->head; node; node = node->next) {
129: 			auto &type_val = *PGPointerCast<duckdb_libpgquery::PGList>(node->data.ptr_value);
130: 			if (type_val.length != 2) {
131: 				throw ParserException("Struct entry needs an entry name and a type name");
132: 			}
133: 
134: 			auto entry_name_node = PGPointerCast<duckdb_libpgquery::PGValue>(type_val.head->data.ptr_value);
135: 			D_ASSERT(entry_name_node->type == duckdb_libpgquery::T_PGString);
136: 			auto entry_type_node = PGPointerCast<duckdb_libpgquery::PGTypeName>(type_val.tail->data.ptr_value);
137: 			D_ASSERT(entry_type_node->type == duckdb_libpgquery::T_PGTypeName);
138: 
139: 			auto entry_name = string(entry_name_node->val.str);
140: 			D_ASSERT(!entry_name.empty());
141: 
142: 			if (name_collision_set.find(entry_name) != name_collision_set.end()) {
143: 				throw ParserException("Duplicate struct entry name \"%s\"", entry_name);
144: 			}
145: 			name_collision_set.insert(entry_name);
146: 			auto entry_type = TransformTypeName(*entry_type_node);
147: 
148: 			children.push_back(make_pair(entry_name, entry_type));
149: 		}
150: 		D_ASSERT(!children.empty());
151: 		result_type = LogicalType::STRUCT(children);
152: 
153: 	} else if (base_type == LogicalTypeId::MAP) {
154: 		if (!type_name.typmods || type_name.typmods->length != 2) {
155: 			throw ParserException("Map type needs exactly two entries, key and value type");
156: 		}
157: 		auto key_type =
158: 		    TransformTypeName(*PGPointerCast<duckdb_libpgquery::PGTypeName>(type_name.typmods->head->data.ptr_value));
159: 		auto value_type =
160: 		    TransformTypeName(*PGPointerCast<duckdb_libpgquery::PGTypeName>(type_name.typmods->tail->data.ptr_value));
161: 
162: 		result_type = LogicalType::MAP(std::move(key_type), std::move(value_type));
163: 	} else if (base_type == LogicalTypeId::UNION) {
164: 		if (!type_name.typmods || type_name.typmods->length == 0) {
165: 			throw ParserException("Union type needs at least one member");
166: 		}
167: 		if (type_name.typmods->length > (int)UnionType::MAX_UNION_MEMBERS) {
168: 			throw ParserException("Union types can have at most %d members", UnionType::MAX_UNION_MEMBERS);
169: 		}
170: 
171: 		child_list_t<LogicalType> children;
172: 		case_insensitive_set_t name_collision_set;
173: 
174: 		for (auto node = type_name.typmods->head; node; node = node->next) {
175: 			auto &type_val = *PGPointerCast<duckdb_libpgquery::PGList>(node->data.ptr_value);
176: 			if (type_val.length != 2) {
177: 				throw ParserException("Union type member needs a tag name and a type name");
178: 			}
179: 
180: 			auto entry_name_node = PGPointerCast<duckdb_libpgquery::PGValue>(type_val.head->data.ptr_value);
181: 			D_ASSERT(entry_name_node->type == duckdb_libpgquery::T_PGString);
182: 			auto entry_type_node = PGPointerCast<duckdb_libpgquery::PGTypeName>(type_val.tail->data.ptr_value);
183: 			D_ASSERT(entry_type_node->type == duckdb_libpgquery::T_PGTypeName);
184: 
185: 			auto entry_name = string(entry_name_node->val.str);
186: 			D_ASSERT(!entry_name.empty());
187: 
188: 			if (name_collision_set.find(entry_name) != name_collision_set.end()) {
189: 				throw ParserException("Duplicate union type tag name \"%s\"", entry_name);
190: 			}
191: 
192: 			name_collision_set.insert(entry_name);
193: 
194: 			auto entry_type = TransformTypeName(*entry_type_node);
195: 			children.push_back(make_pair(entry_name, entry_type));
196: 		}
197: 		D_ASSERT(!children.empty());
198: 		result_type = LogicalType::UNION(std::move(children));
199: 	} else if (base_type == LogicalTypeId::USER) {
200: 		string user_type_name {name};
201: 		vector<Value> type_mods = TransformTypeModifiers(type_name);
202: 		result_type = LogicalType::USER(user_type_name, type_mods);
203: 	} else {
204: 		SizeModifiers modifiers = GetSizeModifiers(type_name, base_type);
205: 		switch (base_type) {
206: 		case LogicalTypeId::VARCHAR:
207: 			if (modifiers.count > 1) {
208: 				throw ParserException("VARCHAR only supports a single modifier");
209: 			}
210: 			// FIXME: create CHECK constraint based on varchar width
211: 			modifiers.width = 0;
212: 			result_type = LogicalType::VARCHAR;
213: 			break;
214: 		case LogicalTypeId::DECIMAL:
215: 			if (modifiers.count > 2) {
216: 				throw ParserException("DECIMAL only supports a maximum of two modifiers");
217: 			}
218: 			if (modifiers.count == 1) {
219: 				// only width is provided: set scale to 0
220: 				modifiers.scale = 0;
221: 			}
222: 			if (modifiers.width <= 0 || modifiers.width > Decimal::MAX_WIDTH_DECIMAL) {
223: 				throw ParserException("Width must be between 1 and %d!", (int)Decimal::MAX_WIDTH_DECIMAL);
224: 			}
225: 			if (modifiers.scale > modifiers.width) {
226: 				throw ParserException("Scale cannot be bigger than width");
227: 			}
228: 			result_type =
229: 			    LogicalType::DECIMAL(NumericCast<uint8_t>(modifiers.width), NumericCast<uint8_t>(modifiers.scale));
230: 			break;
231: 		case LogicalTypeId::INTERVAL:
232: 			if (modifiers.count > 1) {
233: 				throw ParserException("INTERVAL only supports a single modifier");
234: 			}
235: 			modifiers.width = 0;
236: 			result_type = LogicalType::INTERVAL;
237: 			break;
238: 		case LogicalTypeId::BIT:
239: 			if (!modifiers.width && type_name.typmods) {
240: 				throw ParserException("Type %s does not support any modifiers!", LogicalType(base_type).ToString());
241: 			}
242: 			result_type = LogicalType(base_type);
243: 			break;
244: 		case LogicalTypeId::TIMESTAMP:
245: 			if (modifiers.count == 0) {
246: 				result_type = LogicalType::TIMESTAMP;
247: 			} else {
248: 				if (modifiers.count > 1) {
249: 					throw ParserException("TIMESTAMP only supports a single modifier");
250: 				}
251: 				if (modifiers.width > 10) {
252: 					throw ParserException("TIMESTAMP only supports until nano-second precision (9)");
253: 				}
254: 				if (modifiers.width == 0) {
255: 					result_type = LogicalType::TIMESTAMP_S;
256: 				} else if (modifiers.width <= 3) {
257: 					result_type = LogicalType::TIMESTAMP_MS;
258: 				} else if (modifiers.width <= 6) {
259: 					result_type = LogicalType::TIMESTAMP;
260: 				} else {
261: 					result_type = LogicalType::TIMESTAMP_NS;
262: 				}
263: 			}
264: 			break;
265: 		default:
266: 			if (modifiers.count > 0) {
267: 				throw ParserException("Type %s does not support any modifiers!", LogicalType(base_type).ToString());
268: 			}
269: 			result_type = LogicalType(base_type);
270: 			break;
271: 		}
272: 	}
273: 	if (type_name.arrayBounds) {
274: 		// array bounds: turn the type into a list
275: 		idx_t extra_stack = 0;
276: 		for (auto cell = type_name.arrayBounds->head; cell != nullptr; cell = cell->next) {
277: 			StackCheck(extra_stack++);
278: 			auto val = PGPointerCast<duckdb_libpgquery::PGValue>(cell->data.ptr_value);
279: 			if (val->type != duckdb_libpgquery::T_PGInteger) {
280: 				throw ParserException("Expected integer value as array bound");
281: 			}
282: 			auto array_size = val->val.ival;
283: 			if (array_size < 0) {
284: 				// -1 if bounds are empty
285: 				result_type = LogicalType::LIST(result_type);
286: 			} else if (array_size == 0) {
287: 				// Empty arrays are not supported
288: 				throw ParserException("Arrays must have a size of at least 1");
289: 			} else if (array_size > static_cast<int64_t>(ArrayType::MAX_ARRAY_SIZE)) {
290: 				throw ParserException("Arrays must have a size of at most %d", ArrayType::MAX_ARRAY_SIZE);
291: 			} else {
292: 				result_type = LogicalType::ARRAY(result_type, NumericCast<idx_t>(array_size));
293: 			}
294: 		}
295: 	}
296: 	return result_type;
297: }
298: 
299: } // namespace duckdb
[end of src/parser/transform/helpers/transform_typename.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: