{
  "repo": "duckdb/duckdb",
  "pull_number": 9907,
  "instance_id": "duckdb__duckdb-9907",
  "issue_numbers": [
    "8905",
    "8905"
  ],
  "base_commit": "6867e5842be1408cb2b1149c482e429ad444618f",
  "patch": "diff --git a/src/main/capi/result-c.cpp b/src/main/capi/result-c.cpp\nindex 0773406dea52..d646500b41e0 100644\n--- a/src/main/capi/result-c.cpp\n+++ b/src/main/capi/result-c.cpp\n@@ -431,10 +431,21 @@ idx_t duckdb_rows_changed(duckdb_result *result) {\n \tif (!result) {\n \t\treturn 0;\n \t}\n-\tif (!duckdb::deprecated_materialize_result(result)) {\n+\tauto &result_data = *(reinterpret_cast<duckdb::DuckDBResultData *>(result->internal_data));\n+\tif (result_data.result_set_type == duckdb::CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED) {\n+\t\t// not a materialized result\n+\t\treturn result->__deprecated_rows_changed;\n+\t}\n+\tauto &materialized = reinterpret_cast<duckdb::MaterializedQueryResult &>(*result_data.result);\n+\tif (materialized.properties.return_type != duckdb::StatementReturnType::CHANGED_ROWS) {\n+\t\t// we can only use this function for CHANGED_ROWS result types\n+\t\treturn 0;\n+\t}\n+\tif (materialized.RowCount() != 1 || materialized.ColumnCount() != 1) {\n+\t\t// CHANGED_ROWS should return exactly one row\n \t\treturn 0;\n \t}\n-\treturn result->__deprecated_rows_changed;\n+\treturn materialized.GetValue(0, 0).GetValue<uint64_t>();\n }\n \n void *duckdb_column_data(duckdb_result *result, idx_t col) {\n",
  "test_patch": "diff --git a/test/api/capi/test_capi.cpp b/test/api/capi/test_capi.cpp\nindex 3c0f39d50e2c..ee0f64c168db 100644\n--- a/test/api/capi/test_capi.cpp\n+++ b/test/api/capi/test_capi.cpp\n@@ -89,6 +89,7 @@ TEST_CASE(\"Basic test of C API\", \"[capi]\") {\n \t// NULL selection\n \tresult = tester.Query(\"SELECT a, b FROM test ORDER BY a\");\n \tREQUIRE_NO_FAIL(*result);\n+\tREQUIRE(result->rows_changed() == 0);\n \t// NULL, 11, 13\n \tREQUIRE(result->IsNull(0, 0));\n \tREQUIRE(result->Fetch<int32_t>(0, 1) == 11);\n",
  "problem_statement": "Calling duckdb_rows_changed causes data chunk to return invalid data\n### What happens?\n\nIf you have a `duckdb_result` instance and call `duckdb_rows_changed` with it, subsequent calls to `duckdb_result_get_chunk` return an empty pointer. If I reorder calls everything works as expected. I would expect order not to have affect on the return value of `duckdb_result_get_chunk`\r\n\r\n![image](https://github.com/duckdb/duckdb/assets/580749/5d359202-7fea-4eb7-a830-d73f2b195874)\r\n\r\nWorks fine if I change the order\r\n![image](https://github.com/duckdb/duckdb/assets/580749/92e980d5-7e68-4dec-9340-9afc7c9b9e49)\r\n\r\n\n\n### To Reproduce\n\nObtain `duckdb_result` instance and call `duckdb_rows_changed` followed by a call to `duckdb_result_get_chunk`\n\n### OS:\n\nWindows 11 x64\n\n### DuckDB Version:\n\n0.8.1\n\n### DuckDB Client:\n\nC# client via C API\n\n### Full Name:\n\nGiorgi Dalakishvili\n\n### Affiliation:\n\nSpace International\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\nCalling duckdb_rows_changed causes data chunk to return invalid data\n### What happens?\n\nIf you have a `duckdb_result` instance and call `duckdb_rows_changed` with it, subsequent calls to `duckdb_result_get_chunk` return an empty pointer. If I reorder calls everything works as expected. I would expect order not to have affect on the return value of `duckdb_result_get_chunk`\r\n\r\n![image](https://github.com/duckdb/duckdb/assets/580749/5d359202-7fea-4eb7-a830-d73f2b195874)\r\n\r\nWorks fine if I change the order\r\n![image](https://github.com/duckdb/duckdb/assets/580749/92e980d5-7e68-4dec-9340-9afc7c9b9e49)\r\n\r\n\n\n### To Reproduce\n\nObtain `duckdb_result` instance and call `duckdb_rows_changed` followed by a call to `duckdb_result_get_chunk`\n\n### OS:\n\nWindows 11 x64\n\n### DuckDB Version:\n\n0.8.1\n\n### DuckDB Client:\n\nC# client via C API\n\n### Full Name:\n\nGiorgi Dalakishvili\n\n### Affiliation:\n\nSpace International\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "They are not part of the same API\n`rows_changed` will call:\n```\n        if (!duckdb::deprecated_materialize_result(result)) {\n```\nThis will set the result type:\n```\n        result_data->result_set_type = CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED;\n```\n\notherwise it can't give you an answer, the result could be streaming\n\n`result_get_chunk` expects a non-deprecated materialized result\nIn that case, how do I get the number of `rows_changed` without using a deprecated API?\nLooks like you need `duckdb_row_count`\nAnd yes I agree this is extremely confusing\nIf I have an `Update` statement how do I get the number of changed rows? `duckdb_row_count` returns 1. It will also probably give the wrong result for `Insert .. returning` statements too.\nFor an update statement that's the data that's returned, it returns 1 because it produces 1 tuple/row - that tuple is a BIGINT of the number of changed rows.\r\n\r\nFor RETURNING the output of `duckdb_row_count` would be what you're looking for because for every affected row you get one tuple/row \nSo if previously I could use `duckdb_rows_changed` to find the number of changed rows, now I have to read the first item of the first row to get it right?\nI checked the source code and the two other functions that call `deprecated_materialize_result` are `duckdb_column_data` and `duckdb_nullmask_data`. Both of them [are documented](https://duckdb.org/docs/api/c/query) as **DEPRECATED** but `duckdb_rows_changed` isn't. I would send a PR to mark it as DEPRECATED but I don't know what to suggest as an alternative.\nThey are not part of the same API\n`rows_changed` will call:\n```\n        if (!duckdb::deprecated_materialize_result(result)) {\n```\nThis will set the result type:\n```\n        result_data->result_set_type = CAPIResultSetType::CAPI_RESULT_TYPE_DEPRECATED;\n```\n\notherwise it can't give you an answer, the result could be streaming\n\n`result_get_chunk` expects a non-deprecated materialized result\nIn that case, how do I get the number of `rows_changed` without using a deprecated API?\nLooks like you need `duckdb_row_count`\nAnd yes I agree this is extremely confusing\nIf I have an `Update` statement how do I get the number of changed rows? `duckdb_row_count` returns 1. It will also probably give the wrong result for `Insert .. returning` statements too.\nFor an update statement that's the data that's returned, it returns 1 because it produces 1 tuple/row - that tuple is a BIGINT of the number of changed rows.\r\n\r\nFor RETURNING the output of `duckdb_row_count` would be what you're looking for because for every affected row you get one tuple/row \nSo if previously I could use `duckdb_rows_changed` to find the number of changed rows, now I have to read the first item of the first row to get it right?\nI checked the source code and the two other functions that call `deprecated_materialize_result` are `duckdb_column_data` and `duckdb_nullmask_data`. Both of them [are documented](https://duckdb.org/docs/api/c/query) as **DEPRECATED** but `duckdb_rows_changed` isn't. I would send a PR to mark it as DEPRECATED but I don't know what to suggest as an alternative.",
  "created_at": "2023-12-06T13:36:45Z"
}