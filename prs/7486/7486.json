{
  "repo": "duckdb/duckdb",
  "pull_number": 7486,
  "instance_id": "duckdb__duckdb-7486",
  "issue_numbers": [
    "7472"
  ],
  "base_commit": "599c3b68c2dbaf082d589b1922851abf2660377a",
  "patch": "diff --git a/extension/json/json_functions/json_transform.cpp b/extension/json/json_functions/json_transform.cpp\nindex c19c15909a22..9ee3d9ad0518 100644\n--- a/extension/json/json_functions/json_transform.cpp\n+++ b/extension/json/json_functions/json_transform.cpp\n@@ -658,7 +658,7 @@ static bool TransformObjectToMap(yyjson_val *objects[], yyjson_alc *alc, Vector\n \t// Transform keys\n \tif (!JSONTransform::Transform(keys, alc, MapVector::GetKeys(result), list_size, options)) {\n \t\tthrow ConversionException(\n-\t\t    StringUtil::Format(options.error_message, \". Cannot default to NULL, because map keys cannot be NULL\"));\n+\t\t    StringUtil::Format(options.error_message + \". Cannot default to NULL, because map keys cannot be NULL\"));\n \t}\n \n \t// Transform values\ndiff --git a/src/common/exception.cpp b/src/common/exception.cpp\nindex 42a0d7154abd..15af4b9e5712 100644\n--- a/src/common/exception.cpp\n+++ b/src/common/exception.cpp\n@@ -59,6 +59,23 @@ string Exception::GetStackTrace(int max_depth) {\n }\n \n string Exception::ConstructMessageRecursive(const string &msg, std::vector<ExceptionFormatValue> &values) {\n+#ifdef DEBUG\n+\t// Verify that we have the required amount of values for the message\n+\tidx_t parameter_count = 0;\n+\tfor (idx_t i = 0; i < msg.size(); i++) {\n+\t\tif (msg[i] != '%') {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tif (i < msg.size() && msg[i + 1] == '%') {\n+\t\t\ti++;\n+\t\t\tcontinue;\n+\t\t}\n+\t\tparameter_count++;\n+\t}\n+\tif (parameter_count != values.size()) {\n+\t\tthrow InternalException(\"Expected %d parameters, received %d\", parameter_count, values.size());\n+\t}\n+#endif\n \treturn ExceptionFormatValue::Format(msg, values);\n }\n \ndiff --git a/src/common/exception_format_value.cpp b/src/common/exception_format_value.cpp\nindex 3f7848bfe4da..e97a36194b39 100644\n--- a/src/common/exception_format_value.cpp\n+++ b/src/common/exception_format_value.cpp\n@@ -3,6 +3,7 @@\n #include \"fmt/format.h\"\n #include \"fmt/printf.h\"\n #include \"duckdb/common/types/hugeint.hpp\"\n+#include \"duckdb/parser/keyword_helper.hpp\"\n \n namespace duckdb {\n \n@@ -40,6 +41,19 @@ template <>\n ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(string value) {\n \treturn ExceptionFormatValue(std::move(value));\n }\n+\n+template <>\n+ExceptionFormatValue\n+ExceptionFormatValue::CreateFormatValue(SQLString value) { // NOLINT: templating requires us to copy value here\n+\treturn KeywordHelper::WriteQuoted(value.raw_string, '\\'');\n+}\n+\n+template <>\n+ExceptionFormatValue\n+ExceptionFormatValue::CreateFormatValue(SQLIdentifier value) { // NOLINT: templating requires us to copy value here\n+\treturn KeywordHelper::WriteOptionallyQuoted(value.raw_string, '\"');\n+}\n+\n template <>\n ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(const char *value) {\n \treturn ExceptionFormatValue(string(value));\ndiff --git a/src/common/types.cpp b/src/common/types.cpp\nindex 221ccea966ab..3030cb3be23b 100644\n--- a/src/common/types.cpp\n+++ b/src/common/types.cpp\n@@ -349,7 +349,7 @@ string LogicalType::ToString() const {\n \t\tauto &child_types = StructType::GetChildTypes(*this);\n \t\tstring ret = \"STRUCT(\";\n \t\tfor (size_t i = 0; i < child_types.size(); i++) {\n-\t\t\tret += KeywordHelper::WriteOptionallyQuoted(child_types[i].first) + \" \" + child_types[i].second.ToString();\n+\t\t\tret += StringUtil::Format(\"%s %s\", SQLIdentifier(child_types[i].first), child_types[i].second);\n \t\t\tif (i < child_types.size() - 1) {\n \t\t\t\tret += \", \";\n \t\t\t}\ndiff --git a/src/execution/operator/persistent/physical_export.cpp b/src/execution/operator/persistent/physical_export.cpp\nindex 57a1f6e219bb..e836688fec11 100644\n--- a/src/execution/operator/persistent/physical_export.cpp\n+++ b/src/execution/operator/persistent/physical_export.cpp\n@@ -51,8 +51,8 @@ static void WriteCopyStatement(FileSystem &fs, stringstream &ss, CopyInfo &info,\n \t\tss << KeywordHelper::WriteOptionallyQuoted(exported_table.schema_name) << \".\";\n \t}\n \n-\tss << KeywordHelper::WriteOptionallyQuoted(exported_table.table_name) << \" FROM '\" << exported_table.file_path\n-\t   << \"' (\";\n+\tss << StringUtil::Format(\"%s FROM %s (\", SQLIdentifier(exported_table.table_name),\n+\t                         SQLString(exported_table.file_path));\n \n \t// write the copy options\n \tss << \"FORMAT '\" << info.format << \"'\";\ndiff --git a/src/function/pragma/pragma_queries.cpp b/src/function/pragma/pragma_queries.cpp\nindex 8f03ca02b8a7..820521ba405a 100644\n--- a/src/function/pragma/pragma_queries.cpp\n+++ b/src/function/pragma/pragma_queries.cpp\n@@ -41,7 +41,7 @@ string PragmaShowTables(ClientContext &context, const FunctionParameters &parame\n \t)\n \tSELECT \"name\"\n \tFROM db_objects\n-\tORDER BY \"name\";)EOF\", where_clause, where_clause, where_clause);\n+\tORDER BY \"name\";)EOF\", where_clause, where_clause);\n \t// clang-format on\n \n \treturn pragma_query;\ndiff --git a/src/include/duckdb/common/exception_format_value.hpp b/src/include/duckdb/common/exception_format_value.hpp\nindex 6fa683719bd1..1834663e5203 100644\n--- a/src/include/duckdb/common/exception_format_value.hpp\n+++ b/src/include/duckdb/common/exception_format_value.hpp\n@@ -15,6 +15,28 @@\n \n namespace duckdb {\n \n+// Helper class to support custom overloading\n+// Escaping \" and quoting the value with \"\n+class SQLIdentifier {\n+public:\n+\tSQLIdentifier(const string &raw_string) : raw_string(raw_string) {\n+\t}\n+\n+public:\n+\tstring raw_string;\n+};\n+\n+// Helper class to support custom overloading\n+// Escaping ' and quoting the value with '\n+class SQLString {\n+public:\n+\tSQLString(const string &raw_string) : raw_string(raw_string) {\n+\t}\n+\n+public:\n+\tstring raw_string;\n+};\n+\n enum class PhysicalType : uint8_t;\n struct LogicalType;\n \n@@ -47,6 +69,10 @@ struct ExceptionFormatValue {\n template <>\n DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(PhysicalType value);\n template <>\n+DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(SQLString value);\n+template <>\n+DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(SQLIdentifier value);\n+template <>\n DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(LogicalType value);\n template <>\n DUCKDB_API ExceptionFormatValue ExceptionFormatValue::CreateFormatValue(float value);\ndiff --git a/src/include/duckdb/common/string_util.hpp b/src/include/duckdb/common/string_util.hpp\nindex 5112b1df2f6a..bef4789d41be 100644\n--- a/src/include/duckdb/common/string_util.hpp\n+++ b/src/include/duckdb/common/string_util.hpp\n@@ -15,6 +15,7 @@\n #include <cstring>\n \n namespace duckdb {\n+\n /**\n  * String Utility Functions\n  * Note that these are not the most efficient implementations (i.e., they copy\n@@ -85,6 +86,23 @@ class StringUtil {\n \t\treturn false;\n \t}\n \n+\ttemplate <class TO>\n+\tstatic vector<TO> ConvertStrings(const vector<string> &strings) {\n+\t\tvector<TO> result;\n+\t\tfor (auto &string : strings) {\n+\t\t\tresult.emplace_back(string);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic vector<SQLIdentifier> ConvertToSQLIdentifiers(const vector<string> &strings) {\n+\t\treturn ConvertStrings<SQLIdentifier>(strings);\n+\t}\n+\n+\tstatic vector<SQLString> ConvertToSQLStrings(const vector<string> &strings) {\n+\t\treturn ConvertStrings<SQLString>(strings);\n+\t}\n+\n \t//! Returns true if the needle string exists in the haystack\n \tDUCKDB_API static bool Contains(const string &haystack, const string &needle);\n \ndiff --git a/src/include/duckdb/parser/expression/function_expression.hpp b/src/include/duckdb/parser/expression/function_expression.hpp\nindex 0452cdb8dcc1..0c15bbc13acc 100644\n--- a/src/include/duckdb/parser/expression/function_expression.hpp\n+++ b/src/include/duckdb/parser/expression/function_expression.hpp\n@@ -92,7 +92,7 @@ class FunctionExpression : public ParsedExpression {\n \t\tresult += StringUtil::Join(entry.children, entry.children.size(), \", \", [&](const unique_ptr<BASE> &child) {\n \t\t\treturn child->alias.empty() || !add_alias\n \t\t\t           ? child->ToString()\n-\t\t\t           : KeywordHelper::WriteOptionallyQuoted(child->alias) + \" := \" + child->ToString();\n+\t\t\t           : StringUtil::Format(\"%s := %s\", SQLIdentifier(child->alias), child->ToString());\n \t\t});\n \t\t// ordered aggregate\n \t\tif (order_bys && !order_bys->orders.empty()) {\ndiff --git a/src/include/duckdb/parser/expression/operator_expression.hpp b/src/include/duckdb/parser/expression/operator_expression.hpp\nindex 61ffff30d830..91967875716f 100644\n--- a/src/include/duckdb/parser/expression/operator_expression.hpp\n+++ b/src/include/duckdb/parser/expression/operator_expression.hpp\n@@ -96,8 +96,8 @@ class OperatorExpression : public ParsedExpression {\n \t\t\tauto child_string = entry.children[1]->ToString();\n \t\t\tD_ASSERT(child_string.size() >= 3);\n \t\t\tD_ASSERT(child_string[0] == '\\'' && child_string[child_string.size() - 1] == '\\'');\n-\t\t\treturn \"(\" + entry.children[0]->ToString() + \").\" +\n-\t\t\t       KeywordHelper::WriteOptionallyQuoted(child_string.substr(1, child_string.size() - 2));\n+\t\t\treturn StringUtil::Format(\"(%s).%s\", entry.children[0]->ToString(),\n+\t\t\t                          SQLIdentifier(child_string.substr(1, child_string.size() - 2)));\n \t\t}\n \t\tcase ExpressionType::ARRAY_CONSTRUCTOR: {\n \t\t\tstring result = \"(ARRAY[\";\ndiff --git a/src/include/duckdb/parser/keyword_helper.hpp b/src/include/duckdb/parser/keyword_helper.hpp\nindex 23cef007432e..05c1664fdeb5 100644\n--- a/src/include/duckdb/parser/keyword_helper.hpp\n+++ b/src/include/duckdb/parser/keyword_helper.hpp\n@@ -17,9 +17,14 @@ class KeywordHelper {\n \t//! Returns true if the given text matches a keyword of the parser\n \tstatic bool IsKeyword(const string &text);\n \n+\tstatic string EscapeQuotes(const string &text, char quote = '\"');\n+\n \t//! Returns true if the given string needs to be quoted when written as an identifier\n \tstatic bool RequiresQuotes(const string &text, bool allow_caps = true);\n \n+\t//! Writes a string that is quoted\n+\tstatic string WriteQuoted(const string &text, char quote = '\\'');\n+\n \t//! Writes a string that is optionally quoted + escaped so it can be used as an identifier\n \tstatic string WriteOptionallyQuoted(const string &text, char quote = '\"', bool allow_caps = true);\n };\ndiff --git a/src/parser/expression/collate_expression.cpp b/src/parser/expression/collate_expression.cpp\nindex e57af4c09eba..863ec09bd8b7 100644\n--- a/src/parser/expression/collate_expression.cpp\n+++ b/src/parser/expression/collate_expression.cpp\n@@ -15,7 +15,7 @@ CollateExpression::CollateExpression(string collation_p, unique_ptr<ParsedExpres\n }\n \n string CollateExpression::ToString() const {\n-\treturn child->ToString() + \" COLLATE \" + KeywordHelper::WriteOptionallyQuoted(collation);\n+\treturn StringUtil::Format(\"%s COLLATE %s\", child->ToString(), SQLIdentifier(collation));\n }\n \n bool CollateExpression::Equal(const CollateExpression *a, const CollateExpression *b) {\ndiff --git a/src/parser/keyword_helper.cpp b/src/parser/keyword_helper.cpp\nindex b0add2e4c7e7..e74b6c748f32 100644\n--- a/src/parser/keyword_helper.cpp\n+++ b/src/parser/keyword_helper.cpp\n@@ -29,11 +29,21 @@ bool KeywordHelper::RequiresQuotes(const string &text, bool allow_caps) {\n \treturn IsKeyword(text);\n }\n \n+string KeywordHelper::EscapeQuotes(const string &text, char quote) {\n+\treturn StringUtil::Replace(text, string(1, quote), string(2, quote));\n+}\n+\n+string KeywordHelper::WriteQuoted(const string &text, char quote) {\n+\t// 1. Escapes all occurences of 'quote' by doubling them (escape in SQL)\n+\t// 2. Adds quotes around the string\n+\treturn string(1, quote) + EscapeQuotes(text) + string(1, quote);\n+}\n+\n string KeywordHelper::WriteOptionallyQuoted(const string &text, char quote, bool allow_caps) {\n \tif (!RequiresQuotes(text, allow_caps)) {\n \t\treturn text;\n \t}\n-\treturn string(1, quote) + StringUtil::Replace(text, string(1, quote), string(2, quote)) + string(1, quote);\n+\treturn WriteQuoted(text, quote);\n }\n \n } // namespace duckdb\ndiff --git a/src/parser/query_node/select_node.cpp b/src/parser/query_node/select_node.cpp\nindex 4f20224248af..635878d2a72c 100644\n--- a/src/parser/query_node/select_node.cpp\n+++ b/src/parser/query_node/select_node.cpp\n@@ -39,7 +39,7 @@ string SelectNode::ToString() const {\n \t\t}\n \t\tresult += select_list[i]->ToString();\n \t\tif (!select_list[i]->alias.empty()) {\n-\t\t\tresult += \" AS \" + KeywordHelper::WriteOptionallyQuoted(select_list[i]->alias);\n+\t\t\tresult += StringUtil::Format(\" AS %s\", SQLIdentifier(select_list[i]->alias));\n \t\t}\n \t}\n \tif (from_table && from_table->type != TableReferenceType::EMPTY) {\ndiff --git a/src/parser/statement/copy_statement.cpp b/src/parser/statement/copy_statement.cpp\nindex 175911031c31..9031de28636e 100644\n--- a/src/parser/statement/copy_statement.cpp\n+++ b/src/parser/statement/copy_statement.cpp\n@@ -86,7 +86,7 @@ string CopyStatement::ToString() const {\n \t\tD_ASSERT(!select_statement);\n \t\tresult += TablePart(*info);\n \t\tresult += \" FROM\";\n-\t\tresult += StringUtil::Format(\" '%s'\", info->file_path);\n+\t\tresult += StringUtil::Format(\" %s\", SQLString(info->file_path));\n \t\tresult += CopyOptionsToString(info->format, info->options);\n \t} else {\n \t\tif (select_statement) {\n@@ -96,7 +96,7 @@ string CopyStatement::ToString() const {\n \t\t\tresult += TablePart(*info);\n \t\t}\n \t\tresult += \" TO \";\n-\t\tresult += StringUtil::Format(\"'%s'\", info->file_path);\n+\t\tresult += StringUtil::Format(\"%s\", SQLString(info->file_path));\n \t\tresult += CopyOptionsToString(info->format, info->options);\n \t}\n \treturn result;\ndiff --git a/src/parser/tableref.cpp b/src/parser/tableref.cpp\nindex b5bfd9a6bcbc..0815ee20a1d8 100644\n--- a/src/parser/tableref.cpp\n+++ b/src/parser/tableref.cpp\n@@ -16,7 +16,7 @@ string TableRef::BaseToString(string result) const {\n \n string TableRef::BaseToString(string result, const vector<string> &column_name_alias) const {\n \tif (!alias.empty()) {\n-\t\tresult += \" AS \" + KeywordHelper::WriteOptionallyQuoted(alias);\n+\t\tresult += StringUtil::Format(\" AS %s\", SQLIdentifier(alias));\n \t}\n \tif (!column_name_alias.empty()) {\n \t\tD_ASSERT(!alias.empty());\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 387046d127db..bd83ff38ad7d 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -521,9 +521,17 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Append(const string &name, co\n \t\tfor (auto &column : df_columns) {\n \t\t\tcolumn_names.push_back(std::string(py::str(column)));\n \t\t}\n-\t\tcolumns = StringUtil::Format(\"(%s)\", StringUtil::Join(column_names, \",\"));\n+\t\tcolumns += \"(\";\n+\t\tfor (idx_t i = 0; i < column_names.size(); i++) {\n+\t\t\tauto &column = column_names[i];\n+\t\t\tif (i != 0) {\n+\t\t\t\tcolumns += \", \";\n+\t\t\t}\n+\t\t\tcolumns += StringUtil::Format(\"%s\", SQLIdentifier(column));\n+\t\t}\n+\t\tcolumns += \")\";\n \t}\n-\treturn Execute(StringUtil::Format(\"INSERT INTO \\\"%s\\\"%s SELECT * FROM __append_df\", name, columns));\n+\treturn Execute(StringUtil::Format(\"INSERT INTO %s %s SELECT * FROM __append_df\", SQLIdentifier(name), columns));\n }\n \n void DuckDBPyConnection::RegisterArrowObject(const py::object &arrow_object, const string &name) {\n",
  "test_patch": "diff --git a/test/sqlite/result_helper.cpp b/test/sqlite/result_helper.cpp\nindex 7400705da7d0..bdf13b72ccc7 100644\n--- a/test/sqlite/result_helper.cpp\n+++ b/test/sqlite/result_helper.cpp\n@@ -300,7 +300,7 @@ vector<string> TestResultHelper::LoadResultFromFile(string fname, vector<string>\n \t\tif (i > 0) {\n \t\t\tstruct_definition += \", \";\n \t\t}\n-\t\tstruct_definition += KeywordHelper::WriteOptionallyQuoted(names[i]) + \" := 'VARCHAR'\";\n+\t\tstruct_definition += StringUtil::Format(\"%s := VARCHAR\", SQLIdentifier(names[i]));\n \t}\n \tstruct_definition += \")\";\n \ndiff --git a/tools/pythonpkg/tests/fast/pandas/test_append_df.py b/tools/pythonpkg/tests/fast/pandas/test_append_df.py\nindex 9ad0ffb71eea..51faeb37214e 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_append_df.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_append_df.py\n@@ -29,7 +29,20 @@ def test_append_by_name(self, pandas):\n         con.append('tbl', df_in, by_name=True)\n         res = con.table('tbl').fetchall()\n         assert res == [(4, False, 'duck'), (2, True, 'db')]\n-    \n+\n+    @pytest.mark.parametrize('pandas', [NumpyPandas(), ArrowPandas()])\n+    def test_append_by_name_quoted(self, pandas):\n+        con = duckdb.connect()\n+        con.execute(\"\"\"\n+            create table tbl (\"needs to be quoted\" integer, other varchar)\n+        \"\"\")\n+        df_in = pandas.DataFrame({\n+            \"needs to be quoted\": [1,2,3]\n+        })\n+        con.append('tbl', df_in, by_name=True)\n+        res = con.table('tbl').fetchall()\n+        assert res == [(1, None), (2, None), (3, None)]\n+\n     @pytest.mark.parametrize('pandas', [NumpyPandas(), ArrowPandas()])\n     def test_append_by_name_no_exact_match(self, pandas):\n         con = duckdb.connect()\n",
  "problem_statement": "append by_name can cause ParserException because quoting\n### What happens?\r\n\r\nThis fails with `ParserException` if any of a DataFrame's columns need quoting:\r\n- #7300\r\n\r\nI _assume_ because:\r\nhttps://github.com/duckdb/duckdb/blob/e97702367a86ab26ba646f415c99bcb511670c94/tools/pythonpkg/src/pyconnection.cpp#L524\r\n\r\n### To Reproduce\r\n\r\n```python\r\nimport duckdb\r\nimport pandas as pd\r\n\r\ncol_name = '0'  # change to 'a' and it works\r\n\r\ndf = pd.DataFrame({col_name: [1]})\r\ncon = duckdb.connect(':memory:')\r\ncon.sql('create table foo as select * from df')\r\n\r\ndf = pd.DataFrame({col_name: [1, 2]})\r\ncon.append('foo', df, by_name=True) # set to False and it works\r\n\r\nprint(con.sql('select * from foo').fetchall())\r\n```\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/home/dave/ng/duckdb-append-bug.py\", line 11, in <module>\r\n    con.append('foo', df, by_name=True)\r\nduckdb.ParserException: Parser Error: syntax error at or near \"0\"\r\nLINE 1: INSERT INTO \"foo\"(0) SELECT * FROM __append_df\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu 20.04.4 LTS x64\r\n\r\n### DuckDB Version:\r\n\r\n0.7.2.dev3402\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nDave Tapley\r\n\r\n### Affiliation:\r\n\r\nJE Fuller\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "Yea that assumption is right, maybe we should add %c to our StringUtil::Format options, which would output a OptionallyQuoted string instead\r\n\r\nI feel like the column quoting is something that falls through the cracks quite easily\n> Yea that assumption is right, maybe we should add %c to our StringUtil::Format options, which would output a OptionallyQuoted string instead\r\n> \r\n> I feel like the column quoting is something that falls through the cracks quite easily\r\n\r\nPerhaps we can add two classes (`SQLIdentifier` and `SQLString`) that have overloads in the `ExceptionFormatValue` to call the appropriate `KeywordHelper` method (either quote with `\"` when required + escape double quotes, or quote with `'` and escape single quotes).\r\n\r\nWe could add additional helper methods as well, like `ConvertToSQLIdentifiers` or `ConvertToSQLStrings` that convert lists of strings to SQL identifiers/strings.\nI added them, but it's not directly useful in many places.\r\nAlso not in this instance, because StringUtil::Join expects a vector of strings, we could also add overloads to that for the SQLString and SQLIdentifier, but then we're just slowly duplicating all of our StringUtil class to add support for this",
  "created_at": "2023-05-12T14:25:54Z"
}