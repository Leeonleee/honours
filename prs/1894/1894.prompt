You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
INTERVAL not working as expected across day boundry
When subtracting x minutes from a timestamp, the wrong timestamp occurs if the new timestamp crosses a day boundary (midnight).

e.g. _SELECT TIMESTAMP '2000-01-01 00:00:00' - INTERVAL 1 MINUTE_ 
should return '1999-12-31 23:59:00', instead it returns '2000-01-01 23:59:00'



</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/function/scalar/operators/add.cpp]
1: #include "duckdb/common/operator/add.hpp"
2: 
3: #include "duckdb/common/limits.hpp"
4: #include "duckdb/common/types/value.hpp"
5: 
6: #include "duckdb/common/types/date.hpp"
7: #include "duckdb/common/types/interval.hpp"
8: #include "duckdb/common/types/timestamp.hpp"
9: #include "duckdb/common/types/hugeint.hpp"
10: #include "duckdb/common/windows_undefs.hpp"
11: 
12: #include <limits>
13: 
14: namespace duckdb {
15: 
16: //===--------------------------------------------------------------------===//
17: // + [add]
18: //===--------------------------------------------------------------------===//
19: template <>
20: float AddOperator::Operation(float left, float right) {
21: 	auto result = left + right;
22: 	if (!Value::FloatIsValid(result)) {
23: 		throw OutOfRangeException("Overflow in addition of float!");
24: 	}
25: 	return result;
26: }
27: 
28: template <>
29: double AddOperator::Operation(double left, double right) {
30: 	auto result = left + right;
31: 	if (!Value::DoubleIsValid(result)) {
32: 		throw OutOfRangeException("Overflow in addition of double!");
33: 	}
34: 	return result;
35: }
36: 
37: template <>
38: interval_t AddOperator::Operation(interval_t left, interval_t right) {
39: 	left.months = AddOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.months, right.months);
40: 	left.days = AddOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.days, right.days);
41: 	left.micros = AddOperatorOverflowCheck::Operation<int64_t, int64_t, int64_t>(left.micros, right.micros);
42: 	return left;
43: }
44: 
45: template <>
46: date_t AddOperator::Operation(date_t left, interval_t right) {
47: 	date_t result;
48: 	if (right.months != 0) {
49: 		int32_t year, month, day;
50: 		Date::Convert(left, year, month, day);
51: 		int32_t year_diff = right.months / Interval::MONTHS_PER_YEAR;
52: 		year += year_diff;
53: 		month += right.months - year_diff * Interval::MONTHS_PER_YEAR;
54: 		if (month > Interval::MONTHS_PER_YEAR) {
55: 			year++;
56: 			month -= Interval::MONTHS_PER_YEAR;
57: 		} else if (month <= 0) {
58: 			year--;
59: 			month += Interval::MONTHS_PER_YEAR;
60: 		}
61: 		result = Date::FromDate(year, month, day);
62: 	} else {
63: 		result = left;
64: 	}
65: 	if (right.days != 0) {
66: 		result += right.days;
67: 	}
68: 	if (right.micros != 0) {
69: 		result += right.micros / Interval::MICROS_PER_DAY;
70: 	}
71: 	return result;
72: }
73: 
74: template <>
75: date_t AddOperator::Operation(interval_t left, date_t right) {
76: 	return AddOperator::Operation<date_t, interval_t, date_t>(right, left);
77: }
78: 
79: template <>
80: timestamp_t AddOperator::Operation(timestamp_t left, interval_t right) {
81: 	date_t date;
82: 	dtime_t time;
83: 	Timestamp::Convert(left, date, time);
84: 	auto new_date = AddOperator::Operation<date_t, interval_t, date_t>(date, right);
85: 	auto new_time = AddTimeOperator::Operation<dtime_t, interval_t, dtime_t>(time, right);
86: 	return Timestamp::FromDatetime(new_date, new_time);
87: }
88: 
89: template <>
90: timestamp_t AddOperator::Operation(interval_t left, timestamp_t right) {
91: 	return AddOperator::Operation<timestamp_t, interval_t, timestamp_t>(right, left);
92: }
93: 
94: //===--------------------------------------------------------------------===//
95: // + [add] with overflow check
96: //===--------------------------------------------------------------------===//
97: struct OverflowCheckedAddition {
98: 	template <class SRCTYPE, class UTYPE>
99: 	static inline bool Operation(SRCTYPE left, SRCTYPE right, SRCTYPE &result) {
100: 		UTYPE uresult = AddOperator::Operation<UTYPE, UTYPE, UTYPE>(UTYPE(left), UTYPE(right));
101: 		if (uresult < NumericLimits<SRCTYPE>::Minimum() || uresult > NumericLimits<SRCTYPE>::Maximum()) {
102: 			return false;
103: 		}
104: 		result = SRCTYPE(uresult);
105: 		return true;
106: 	}
107: };
108: 
109: template <>
110: bool TryAddOperator::Operation(uint8_t left, uint8_t right, uint8_t &result) {
111: 	return OverflowCheckedAddition::Operation<uint8_t, uint16_t>(left, right, result);
112: }
113: template <>
114: bool TryAddOperator::Operation(uint16_t left, uint16_t right, uint16_t &result) {
115: 	return OverflowCheckedAddition::Operation<uint16_t, uint32_t>(left, right, result);
116: }
117: template <>
118: bool TryAddOperator::Operation(uint32_t left, uint32_t right, uint32_t &result) {
119: 	return OverflowCheckedAddition::Operation<uint32_t, uint64_t>(left, right, result);
120: }
121: 
122: template <>
123: bool TryAddOperator::Operation(uint64_t left, uint64_t right, uint64_t &result) {
124: 	if (NumericLimits<uint64_t>::Maximum() - left < right) {
125: 		return false;
126: 	}
127: 	return OverflowCheckedAddition::Operation<uint64_t, uint64_t>(left, right, result);
128: }
129: 
130: template <>
131: bool TryAddOperator::Operation(int8_t left, int8_t right, int8_t &result) {
132: 	return OverflowCheckedAddition::Operation<int8_t, int16_t>(left, right, result);
133: }
134: 
135: template <>
136: bool TryAddOperator::Operation(int16_t left, int16_t right, int16_t &result) {
137: 	return OverflowCheckedAddition::Operation<int16_t, int32_t>(left, right, result);
138: }
139: 
140: template <>
141: bool TryAddOperator::Operation(int32_t left, int32_t right, int32_t &result) {
142: 	return OverflowCheckedAddition::Operation<int32_t, int64_t>(left, right, result);
143: }
144: 
145: template <>
146: bool TryAddOperator::Operation(int64_t left, int64_t right, int64_t &result) {
147: #if (__GNUC__ >= 5) || defined(__clang__)
148: 	if (__builtin_add_overflow(left, right, &result)) {
149: 		return false;
150: 	}
151: #else
152: 	// https://blog.regehr.org/archives/1139
153: 	result = int64_t((uint64_t)left + (uint64_t)right);
154: 	if ((left < 0 && right < 0 && result >= 0) || (left >= 0 && right >= 0 && result < 0)) {
155: 		return false;
156: 	}
157: #endif
158: 	return true;
159: }
160: 
161: //===--------------------------------------------------------------------===//
162: // add decimal with overflow check
163: //===--------------------------------------------------------------------===//
164: template <class T, T min, T max>
165: bool TryDecimalAddTemplated(T left, T right, T &result) {
166: 	if (right < 0) {
167: 		if (min - right > left) {
168: 			return false;
169: 		}
170: 	} else {
171: 		if (max - right < left) {
172: 			return false;
173: 		}
174: 	}
175: 	result = left + right;
176: 	return true;
177: }
178: 
179: template <>
180: bool TryDecimalAdd::Operation(int16_t left, int16_t right, int16_t &result) {
181: 	return TryDecimalAddTemplated<int16_t, -9999, 9999>(left, right, result);
182: }
183: 
184: template <>
185: bool TryDecimalAdd::Operation(int32_t left, int32_t right, int32_t &result) {
186: 	return TryDecimalAddTemplated<int32_t, -999999999, 999999999>(left, right, result);
187: }
188: 
189: template <>
190: bool TryDecimalAdd::Operation(int64_t left, int64_t right, int64_t &result) {
191: 	return TryDecimalAddTemplated<int64_t, -999999999999999999, 999999999999999999>(left, right, result);
192: }
193: 
194: template <>
195: bool TryDecimalAdd::Operation(hugeint_t left, hugeint_t right, hugeint_t &result) {
196: 	result = left + right;
197: 	if (result <= -Hugeint::POWERS_OF_TEN[38] || result >= Hugeint::POWERS_OF_TEN[38]) {
198: 		return false;
199: 	}
200: 	return true;
201: }
202: 
203: template <>
204: hugeint_t DecimalAddOverflowCheck::Operation(hugeint_t left, hugeint_t right) {
205: 	hugeint_t result;
206: 	if (!TryDecimalAdd::Operation(left, right, result)) {
207: 		throw OutOfRangeException("Overflow in addition of DECIMAL(38) (%s + %s);", left.ToString(), right.ToString());
208: 	}
209: 	return result;
210: }
211: 
212: //===--------------------------------------------------------------------===//
213: // add time operator
214: //===--------------------------------------------------------------------===//
215: template <>
216: dtime_t AddTimeOperator::Operation(dtime_t left, interval_t right) {
217: 	int64_t diff = right.micros - ((right.micros / Interval::MICROS_PER_DAY) * Interval::MICROS_PER_DAY);
218: 	left += diff;
219: 	if (left.micros >= Interval::MICROS_PER_DAY) {
220: 		left.micros -= Interval::MICROS_PER_DAY;
221: 	} else if (left.micros < 0) {
222: 		left.micros += Interval::MICROS_PER_DAY;
223: 	}
224: 	return left;
225: }
226: 
227: template <>
228: dtime_t AddTimeOperator::Operation(interval_t left, dtime_t right) {
229: 	return AddTimeOperator::Operation<dtime_t, interval_t, dtime_t>(right, left);
230: }
231: 
232: } // namespace duckdb
[end of src/function/scalar/operators/add.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: