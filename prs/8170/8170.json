{
  "repo": "duckdb/duckdb",
  "pull_number": 8170,
  "instance_id": "duckdb__duckdb-8170",
  "issue_numbers": [
    "8134"
  ],
  "base_commit": "f7e7dce5eafa0be66fb7ee3308746eacc624f496",
  "patch": "diff --git a/tools/pythonpkg/duckdb_python.cpp b/tools/pythonpkg/duckdb_python.cpp\nindex d8ed141bffad..038469468536 100644\n--- a/tools/pythonpkg/duckdb_python.cpp\n+++ b/tools/pythonpkg/duckdb_python.cpp\n@@ -152,11 +152,7 @@ static void InitializeConnectionMethods(py::module_ &m) {\n \tm.def(\"values\", &PyConnectionWrapper::Values, \"Create a relation object from the passed values\", py::arg(\"values\"),\n \t      py::arg(\"connection\") = py::none());\n \tm.def(\"from_query\", &PyConnectionWrapper::FromQuery, \"Create a relation object from the given SQL query\",\n-\t      py::arg(\"query\"), py::arg(\"alias\") = \"query_relation\", py::arg(\"connection\") = py::none());\n-\tm.def(\"query\", &PyConnectionWrapper::RunQuery,\n-\t      \"Run a SQL query. If it is a SELECT statement, create a relation object from the given SQL query, otherwise \"\n-\t      \"run the query as-is.\",\n-\t      py::arg(\"query\"), py::arg(\"alias\") = \"query_relation\", py::arg(\"connection\") = py::none());\n+\t      py::arg(\"query\"), py::arg(\"alias\") = \"\", py::arg(\"connection\") = py::none());\n \tm.def(\"from_substrait\", &PyConnectionWrapper::FromSubstrait, \"Creates a query object from the substrait plan\",\n \t      py::arg(\"proto\"), py::arg(\"connection\") = py::none());\n \tm.def(\"get_substrait\", &PyConnectionWrapper::GetSubstrait, \"Serialize a query object to protobuf\", py::arg(\"query\"),\n@@ -231,7 +227,7 @@ static void InitializeConnectionMethods(py::module_ &m) {\n \tDefineMethod({\"query\", \"sql\"}, m, &PyConnectionWrapper::RunQuery,\n \t             \"Run a SQL query. If it is a SELECT statement, create a relation object from the given SQL query, \"\n \t             \"otherwise run the query as-is.\",\n-\t             py::arg(\"query\"), py::arg(\"alias\") = \"query_relation\", py::arg(\"connection\") = py::none());\n+\t             py::arg(\"query\"), py::arg(\"alias\") = \"\", py::arg(\"connection\") = py::none());\n \n \tDefineMethod({\"from_parquet\", \"read_parquet\"}, m, &PyConnectionWrapper::FromParquet,\n \t             \"Create a relation object from the Parquet files in file_glob\", py::arg(\"file_glob\"),\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\nindex da577fb39c67..cedf4c0868f1 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n@@ -119,8 +119,8 @@ struct DuckDBPyConnection : public std::enable_shared_from_this<DuckDBPyConnecti\n \n \tvoid LoadExtension(const string &extension);\n \n-\tunique_ptr<DuckDBPyRelation> FromQuery(const string &query, const string &alias = \"query_relation\");\n-\tunique_ptr<DuckDBPyRelation> RunQuery(const string &query, const string &alias = \"query_relation\");\n+\tunique_ptr<DuckDBPyRelation> FromQuery(const string &query, string alias = \"\");\n+\tunique_ptr<DuckDBPyRelation> RunQuery(const string &query, string alias = \"\");\n \n \tunique_ptr<DuckDBPyRelation> Table(const string &tname);\n \ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 26b9331e5b1e..4c97a4fabdef 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -203,7 +203,7 @@ static void InitializeConnectionMethods(py::class_<DuckDBPyConnection, shared_pt\n \tDefineMethod({\"sql\", \"query\", \"from_query\"}, m, &DuckDBPyConnection::RunQuery,\n \t             \"Run a SQL query. If it is a SELECT statement, create a relation object from the given SQL query, \"\n \t             \"otherwise run the query as-is.\",\n-\t             py::arg(\"query\"), py::arg(\"alias\") = \"query_relation\");\n+\t             py::arg(\"query\"), py::arg(\"alias\") = \"\");\n \n \tDefineMethod({\"read_csv\", \"from_csv_auto\"}, m, &DuckDBPyConnection::ReadCSV,\n \t             \"Create a relation object from the CSV file in 'name'\", py::arg(\"name\"), py::kw_only(),\n@@ -903,10 +903,13 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \treturn make_uniq<DuckDBPyRelation>(read_csv_p->Alias(name));\n }\n \n-unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromQuery(const string &query, const string &alias) {\n+unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromQuery(const string &query, string alias) {\n \tif (!connection) {\n \t\tthrow ConnectionException(\"Connection has already been closed\");\n \t}\n+\tif (alias.empty()) {\n+\t\talias = \"unnamed_relation_\" + StringUtil::GenerateRandomName(16);\n+\t}\n \tconst char *duckdb_query_error = R\"(duckdb.from_query cannot be used to run arbitrary SQL queries.\n It can only be used to run individual SELECT statements, and converts the result of that SELECT\n statement into a Relation object.\n@@ -914,10 +917,13 @@ Use duckdb.sql to run arbitrary SQL queries.)\";\n \treturn make_uniq<DuckDBPyRelation>(connection->RelationFromQuery(query, alias, duckdb_query_error));\n }\n \n-unique_ptr<DuckDBPyRelation> DuckDBPyConnection::RunQuery(const string &query, const string &alias) {\n+unique_ptr<DuckDBPyRelation> DuckDBPyConnection::RunQuery(const string &query, string alias) {\n \tif (!connection) {\n \t\tthrow ConnectionException(\"Connection has already been closed\");\n \t}\n+\tif (alias.empty()) {\n+\t\talias = \"unnamed_relation_\" + StringUtil::GenerateRandomName(16);\n+\t}\n \tParser parser(connection->context->GetParserOptions());\n \tparser.ParseQuery(query);\n \tif (parser.statements.size() == 1 && parser.statements[0]->type == StatementType::SELECT_STATEMENT) {\ndiff --git a/tools/pythonpkg/src/pyrelation.cpp b/tools/pythonpkg/src/pyrelation.cpp\nindex 514d77f814a7..984c09a089b5 100644\n--- a/tools/pythonpkg/src/pyrelation.cpp\n+++ b/tools/pythonpkg/src/pyrelation.cpp\n@@ -663,6 +663,12 @@ unique_ptr<DuckDBPyRelation> DuckDBPyRelation::Join(DuckDBPyRelation *other, con\n \t} else {\n \t\tthrow InvalidInputException(\"Unsupported join type %s\t try 'inner' or 'left'\", type_string);\n \t}\n+\tauto alias = GetAlias();\n+\tauto other_alias = other->GetAlias();\n+\tif (StringUtil::CIEquals(alias, other_alias)) {\n+\t\tthrow InvalidInputException(\"Both relations have the same alias, please change the alias of one or both \"\n+\t\t                            \"relations using 'rel = rel.set_alias(<new alias>)'\");\n+\t}\n \treturn make_uniq<DuckDBPyRelation>(rel->Join(other->rel, condition, dtype));\n }\n \n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_join.py b/tools/pythonpkg/tests/fast/api/test_join.py\nnew file mode 100644\nindex 000000000000..16b2632f0cd8\n--- /dev/null\n+++ b/tools/pythonpkg/tests/fast/api/test_join.py\n@@ -0,0 +1,44 @@\n+import duckdb\n+import pytest\n+\n+class TestJoin(object):\n+    def test_alias_from_sql(self):\n+        con = duckdb.connect()\n+        rel1 = con.sql(\"SELECT 1 AS col1, 2 AS col2\")\n+        rel2 = con.sql(\"SELECT 1 AS col1, 3 AS col3\")\n+\n+        rel = con.sql('select * from rel1 JOIN rel2 USING (col1)')\n+        rel.show()\n+        res = rel.fetchall()\n+        assert res == [(1, 2, 3)]\n+\n+    def test_relational_join(self):\n+        con = duckdb.connect()\n+\n+        rel1 = con.sql(\"SELECT 1 AS col1, 2 AS col2\")\n+        rel2 = con.sql(\"SELECT 1 AS col1, 3 AS col3\")\n+\n+        rel = rel1.join(rel2, 'col1')\n+        res = rel.fetchall()\n+        assert res == [(1, 2, 3)]\n+\n+    def test_relational_join_alias_collision(self):\n+        con = duckdb.connect()\n+\n+        rel1 = con.sql(\"SELECT 1 AS col1, 2 AS col2\").set_alias('a')\n+        rel2 = con.sql(\"SELECT 1 AS col1, 3 AS col3\").set_alias('a')\n+\n+        with pytest.raises(duckdb.InvalidInputException, match='Both relations have the same alias'):\n+            rel = rel1.join(rel2, 'col1')\n+\n+    def test_relational_join_with_condition(self):\n+        con = duckdb.connect()\n+\n+        rel1 = con.sql(\"SELECT 1 AS col1, 2 AS col2\", 'rel1')\n+        rel2 = con.sql(\"SELECT 1 AS col1, 3 AS col3\", 'rel2')\n+\n+        # This makes a USING clause, which is kind of unexpected behavior\n+        rel = rel1.join(rel2, 'rel1.col1 = rel2.col1')\n+        rel.show()\n+        res = rel.fetchall()\n+        assert res == [(1, 2, 1, 3)]\ndiff --git a/tools/pythonpkg/tests/fast/relational_api/test_rapi_close.py b/tools/pythonpkg/tests/fast/relational_api/test_rapi_close.py\nindex bf4d6f258694..5183bffa31b1 100644\n--- a/tools/pythonpkg/tests/fast/relational_api/test_rapi_close.py\n+++ b/tools/pythonpkg/tests/fast/relational_api/test_rapi_close.py\n@@ -52,7 +52,7 @@ def test_close_conn_rel(self, duckdb_cursor):\n \t\twith pytest.raises(duckdb.ConnectionException, match='Connection has already been closed'):\n \t\t\trel.intersect(rel)\n \t\twith pytest.raises(duckdb.ConnectionException, match='Connection has already been closed'):\n-\t\t\trel.join(rel, \"\")\n+\t\t\trel.join(rel.set_alias('other'), \"a\")\n \t\twith pytest.raises(duckdb.ConnectionException, match='Connection has already been closed'):\n \t\t\trel.distinct()\n \t\twith pytest.raises(duckdb.ConnectionException, match='Connection has already been closed'):\n@@ -124,7 +124,7 @@ def test_close_conn_rel(self, duckdb_cursor):\n \t\twith pytest.raises(duckdb.ConnectionException, match='Connection has already been closed'):\n \t\t\tvalid_rel.intersect(rel)\n \t\twith pytest.raises(duckdb.ConnectionException, match='Connection has already been closed'):\n-\t\t\tvalid_rel.join(rel, \"rel.items = valid_rel.items\")\n+\t\t\tvalid_rel.join(rel.set_alias('rel'), \"rel.items = valid_rel.items\")\n \n \tdef test_del_conn(self, duckdb_cursor):\n \t\tcon = duckdb.connect()\n",
  "problem_statement": "Python DB API using join() on sql() relation causes BinderException - duplicate alias \"query_relation\" in query\n### What happens?\n\nUsing the `join()` relation API in python gives me this error.\n\n### To Reproduce\n\n1. Run this python script\r\n```python\r\nimport duckdb\r\n\r\nrel1 = duckdb.sql(\"SELECT 1 AS col1, 2 AS col2\")\r\nrel2 = duckdb.sql(\"SELECT 1 AS col1, 3 AS col3\")\r\n\r\nrel = rel1.join(rel2, \"col1\")\r\n```\r\n\r\n2. Error message:\r\n```\r\nBinderException: Binder Error: Duplicate alias \"query_relation\" in query!\r\n```\n\n### OS:\n\nWindows 10 x64\n\n### DuckDB Version:\n\n0.8.1\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nTing Teck Pei\n\n### Affiliation:\n\nHobbyist coder\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "When using `sql()` you can provide an alias\r\nThe default is `query_relation` which causes this issue.\r\n\r\nTry setting aliases for the relations\r\n\r\n```py\r\nimport duckdb\r\n\r\nrel1 = duckdb.sql(\"SELECT 1 AS col1, 2 AS col2\", 'rel1')\r\nrel2 = duckdb.sql(\"SELECT 1 AS col1, 3 AS col3\", 'rel2')\r\n\r\nrel = rel1.join(rel2, \"col1\")\r\nrel.show()\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 col1  \u2502 col2  \u2502 col3  \u2502\r\n\u2502 int32 \u2502 int32 \u2502 int32 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502     2 \u2502     3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nI thought the python variable name as an alias is automatically inferred based on this [overview page](https://duckdb.org/docs/api/python/overview).\r\n\r\nDoes it make sense for this alias collision to be fixed behind the scene? Just wondering. I think for `read_parquet()` there is some kind of `parquet_hash` alias?\nYou're thinking of this:\r\n```py\r\nimport duckdb\r\n\r\nrel1 = duckdb.sql(\"SELECT 1 AS col1, 2 AS col2\")\r\nrel2 = duckdb.sql(\"SELECT 1 AS col1, 3 AS col3\")\r\n\r\nrel = duckdb.sql('select * from rel1 JOIN rel2 USING (col1)')\r\nrel.show()\r\n```\nWe could probably create two new relations aliased to `a` and `b` to perform the join, I don't immediately see how that would be a problem\r\n\r\nEDIT: \r\nThere is a problem with it, logic like this currently works and won't work anymore if we automatically alias the two relations.\r\n```py\r\n    def test_relational_join_with_condition(self):\r\n        con = duckdb.connect()\r\n\r\n        rel1 = con.sql(\"SELECT 1 AS col1, 2 AS col2\", 'rel1')\r\n        rel2 = con.sql(\"SELECT 1 AS col1, 3 AS col3\", 'rel2')\r\n\r\n        rel = rel1.join(rel2, 'rel1.col1 = rel2.col1')\r\n        rel.show()\r\n```",
  "created_at": "2023-07-06T14:38:34Z"
}