{
  "repo": "duckdb/duckdb",
  "pull_number": 6039,
  "instance_id": "duckdb__duckdb-6039",
  "issue_numbers": [
    "5821"
  ],
  "base_commit": "bfe330e2e0b2a712b5567f701961be7f4268ed8d",
  "patch": "diff --git a/src/include/duckdb/planner/expression_binder/table_function_binder.hpp b/src/include/duckdb/planner/expression_binder/table_function_binder.hpp\nindex 4bbc0698a001..f20a5fe0b465 100644\n--- a/src/include/duckdb/planner/expression_binder/table_function_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/table_function_binder.hpp\n@@ -18,7 +18,7 @@ class TableFunctionBinder : public ExpressionBinder {\n \tTableFunctionBinder(Binder &binder, ClientContext &context);\n \n protected:\n-\tBindResult BindColumnReference(ColumnRefExpression &expr);\n+\tBindResult BindColumnReference(ColumnRefExpression &expr, idx_t depth);\n \tBindResult BindExpression(unique_ptr<ParsedExpression> *expr, idx_t depth, bool root_expression = false) override;\n \n \tstring UnsupportedAggregateMessage() override;\ndiff --git a/src/planner/expression_binder/table_function_binder.cpp b/src/planner/expression_binder/table_function_binder.cpp\nindex 7579801b303b..d1bf31ed4383 100644\n--- a/src/planner/expression_binder/table_function_binder.cpp\n+++ b/src/planner/expression_binder/table_function_binder.cpp\n@@ -1,13 +1,26 @@\n #include \"duckdb/planner/expression_binder/table_function_binder.hpp\"\n #include \"duckdb/parser/expression/columnref_expression.hpp\"\n #include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n+#include \"duckdb/planner/table_binding.hpp\"\n \n namespace duckdb {\n \n TableFunctionBinder::TableFunctionBinder(Binder &binder, ClientContext &context) : ExpressionBinder(binder, context) {\n }\n \n-BindResult TableFunctionBinder::BindColumnReference(ColumnRefExpression &expr) {\n+BindResult TableFunctionBinder::BindColumnReference(ColumnRefExpression &expr, idx_t depth) {\n+\n+\t// if this is a lambda parameters, then we temporarily add a BoundLambdaRef,\n+\t// which we capture and remove later\n+\tif (lambda_bindings) {\n+\t\tauto &colref = (ColumnRefExpression &)expr;\n+\t\tfor (idx_t i = 0; i < lambda_bindings->size(); i++) {\n+\t\t\tif (colref.GetColumnName() == (*lambda_bindings)[i].dummy_name) {\n+\t\t\t\treturn (*lambda_bindings)[i].Bind(colref, i, depth);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tauto result_name = StringUtil::Join(expr.column_names, \".\");\n \treturn BindResult(make_unique<BoundConstantExpression>(Value(result_name)));\n }\n@@ -17,7 +30,7 @@ BindResult TableFunctionBinder::BindExpression(unique_ptr<ParsedExpression> *exp\n \tauto &expr = **expr_ptr;\n \tswitch (expr.GetExpressionClass()) {\n \tcase ExpressionClass::COLUMN_REF:\n-\t\treturn BindColumnReference((ColumnRefExpression &)expr);\n+\t\treturn BindColumnReference((ColumnRefExpression &)expr, depth);\n \tcase ExpressionClass::SUBQUERY:\n \t\tthrow BinderException(\"Table function cannot contain subqueries\");\n \tcase ExpressionClass::DEFAULT:\n",
  "test_patch": "diff --git a/test/sql/function/list/lambdas/table_functions.test b/test/sql/function/list/lambdas/table_functions.test\nnew file mode 100644\nindex 000000000000..273622412400\n--- /dev/null\n+++ b/test/sql/function/list/lambdas/table_functions.test\n@@ -0,0 +1,68 @@\n+# name: test/sql/function/list/lambdas/table_functions.test\n+# description: Test list lambdas in table functions\n+# group: [lambdas]\n+\n+require parquet\n+\n+statement ok\n+CREATE TABLE tmp AS SELECT range AS id FROM range(10);\n+\n+# create a parquet file\n+query I\n+COPY tmp TO '__TEST_DIR__/my_file_cba.parquet' (FORMAT PARQUET);\n+----\n+10\n+\n+# now test different table functions\n+query I\n+SELECT COUNT(*) FROM read_parquet('__TEST_DIR__/my_file_' ||\n+list_aggr(list_transform(['C', 'B', 'A'], s -> lower(s)), 'string_agg', '') || '.parquet');\n+----\n+10\n+\n+query I\n+SELECT COUNT(*) FROM read_parquet('__TEST_DIR__/my_file_' ||\n+list_aggr(list_transform(list_sort(['a', 'b', 'c'], 'DESC'), s -> lower(s)), 'string_agg', '') || '.parquet');\n+----\n+10\n+\n+# nested lambdas\n+query I\n+SELECT COUNT(*) FROM read_parquet('__TEST_DIR__/my_file_' ||\n+list_aggr(list_transform(list_filter(['s', 'c', 'b', NULL, 'a'], x -> x IS NOT NULL AND x != 's'),\n+s -> lower(s)), 'string_agg', '') || '.parquet');\n+----\n+10\n+\n+query I\n+SELECT COUNT(*) FROM read_parquet('__TEST_DIR__/my_file_' ||\n+list_aggr(list_transform(list_filter(\n+list_filter(['s', 'c', 'b', NULL, 'a'], y -> y != 's'), x -> x IS NOT NULL),\n+s -> lower(s)), 'string_agg', '') || '.parquet');\n+----\n+10\n+\n+# lambda parameters in rhs\n+query I\n+COPY tmp TO '__TEST_DIR__/my_file_ac.parquet' (FORMAT PARQUET);\n+----\n+10\n+\n+query I\n+SELECT COUNT(*) FROM read_parquet('__TEST_DIR__/my_file_' ||\n+list_aggr(list_transform(['a'], x -> list_transform(['a', 'c'], y -> x || y)[2]), 'string_agg', '') || '.parquet');\n+----\n+10\n+\n+# issue 5821 (without httpfs)\n+query I\n+COPY tmp TO '__TEST_DIR__/my_file_a=1,b=2,c=3.parquet' (FORMAT PARQUET);\n+----\n+10\n+\n+query I\n+SELECT COUNT(*) FROM read_parquet('__TEST_DIR__/my_file_' ||\n+list_string_agg([lower(s) for s in ['a=1', 'b=2', 'c=3']]) || '.parquet');\n+----\n+10\n+\n",
  "problem_statement": "List comprehensions and lambdas not evaluated correctly when wrapped in a table function\n### What happens?\n\nWhen using [list comprehensions](https://duckdb.org/docs/sql/functions/nested#list-comprehension) or [lambda functions](https://duckdb.org/docs/sql/functions/nested#lambda-functions) they execute on the variable name instead of the variable's value *only when wrapped in a table loading function*.\n\n### To Reproduce\n\nHere's an example of a list comprehension that outputs a varchar correctly:\r\n\r\n```sql\r\nSELECT 'http://example.com/?files=' || list_string_agg([lower(s) for s in ['a=1', 'b=2', 'c=3']]);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 ('http://example.com/?files=' || list_string_agg(main.list_apply(main.list_value('a=1', 'b=2', 'c=3'), s -> lower(s)))) \u2502\r\n\u2502                                                         varchar                                                         \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 http://example.com/?files=a=1,b=2,c=3                                                                                   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nWhen running the exact same statement wrapped in `read_csv` or `read_parquet`:\r\n\r\n```sql\r\nD load httpfs;\r\nD SELECT * FROM read_parquet('http://example.com/?files=' || list_string_agg([lower(s) for s in ['a=1', 'b=2', 'c=3']]));\r\nError: Invalid Input Error: No magic bytes found at end of file 'http://example.com/?files=s,s,s' -- <- 's' here being the variable name used.\r\nD SELECT * FROM read_parquet('http://example.com/?files=' || list_string_agg([lower(duck) for duck in ['a=1', 'b=2', 'c=3']]));\r\nError: Invalid Input Error: No magic bytes found at end of file 'http://example.com/?files=duck,duck,duck\r\n```\r\n\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\nv0.6.1\n\n### DuckDB Client:\n\ncli, wasm\n\n### Full Name:\n\nOz Katz\n\n### Affiliation:\n\nTreeverse Inc.\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-01-30T14:07:06Z"
}