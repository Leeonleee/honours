{
  "repo": "duckdb/duckdb",
  "pull_number": 961,
  "instance_id": "duckdb__duckdb-961",
  "issue_numbers": [
    "956"
  ],
  "base_commit": "6befce1fd92cf587215e8c4964087bc6c155c97b",
  "patch": "diff --git a/src/execution/index/art/art.cpp b/src/execution/index/art/art.cpp\nindex 7fb36ea39443..314b97d7bce7 100644\n--- a/src/execution/index/art/art.cpp\n+++ b/src/execution/index/art/art.cpp\n@@ -507,6 +507,13 @@ bool ART::IteratorScan(ARTIndexScanState *state, Iterator *it, Key *bound, idx_t\n \treturn true;\n }\n \n+void Iterator::SetEntry(idx_t entry_depth, IteratorEntry entry) {\n+\tif (stack.size() < entry_depth + 1) {\n+\t\tstack.resize(MaxValue<idx_t>(8, MaxValue<idx_t>(entry_depth + 1, stack.size() * 2)));\n+\t}\n+\tstack[entry_depth] = entry;\n+}\n+\n bool ART::IteratorNext(Iterator &it) {\n \t// Skip leaf\n \tif ((it.depth) && ((it.stack[it.depth - 1].node)->type == NodeType::NLeaf)) {\n@@ -528,8 +535,7 @@ bool ART::IteratorNext(Iterator &it) {\n \t\ttop.pos = node->GetNextPos(top.pos);\n \t\tif (top.pos != INVALID_INDEX) {\n \t\t\t// next node found: go there\n-\t\t\tit.stack[it.depth].node = node->GetChild(top.pos)->get();\n-\t\t\tit.stack[it.depth].pos = INVALID_INDEX;\n+\t\t\tit.SetEntry(it.depth, IteratorEntry(node->GetChild(top.pos)->get(), INVALID_INDEX));\n \t\t\tit.depth++;\n \t\t} else {\n \t\t\t// no node found: move up the tree\n@@ -554,8 +560,8 @@ bool ART::Bound(unique_ptr<Node> &n, Key &key, Iterator &it, bool inclusive) {\n \n \tidx_t depth = 0;\n \twhile (true) {\n+\t\tit.SetEntry(it.depth, IteratorEntry(node, 0));\n \t\tauto &top = it.stack[it.depth];\n-\t\ttop.node = node;\n \t\tit.depth++;\n \t\tif (!equal) {\n \t\t\twhile (node->type != NodeType::NLeaf) {\n@@ -678,8 +684,7 @@ static Leaf &FindMinimum(Iterator &it, Node &node) {\n \t\tbreak;\n \t}\n \t}\n-\tit.stack[it.depth].node = &node;\n-\tit.stack[it.depth].pos = pos;\n+\tit.SetEntry(it.depth, IteratorEntry(&node, pos));\n \tit.depth++;\n \treturn FindMinimum(it, *next);\n }\ndiff --git a/src/include/duckdb/execution/index/art/art.hpp b/src/include/duckdb/execution/index/art/art.hpp\nindex d37fbd53b1a3..dab9508a4eba 100644\n--- a/src/include/duckdb/execution/index/art/art.hpp\n+++ b/src/include/duckdb/execution/index/art/art.hpp\n@@ -25,6 +25,9 @@\n \n namespace duckdb {\n struct IteratorEntry {\n+\tIteratorEntry(){}\n+\tIteratorEntry(Node *node, idx_t pos) : node(node), pos(pos) {}\n+\n \tNode *node = nullptr;\n \tidx_t pos = 0;\n };\n@@ -34,10 +37,12 @@ struct Iterator {\n \tLeaf *node = nullptr;\n \t//! The current depth\n \tint32_t depth = 0;\n-\t//! Stack, actually the size is determined at runtime\n-\tIteratorEntry stack[9];\n+\t//! Stack, the size is determined at runtime\n+\tvector<IteratorEntry> stack;\n \n \tbool start = false;\n+\n+\tvoid SetEntry(idx_t depth, IteratorEntry entry);\n };\n \n struct ARTIndexScanState : public IndexScanState {\n",
  "test_patch": "diff --git a/test/issues/rigger/test_956.test b/test/issues/rigger/test_956.test\nnew file mode 100644\nindex 000000000000..dfe0d4326262\n--- /dev/null\n+++ b/test/issues/rigger/test_956.test\n@@ -0,0 +1,13 @@\n+# name: test/issues/rigger/test_956.test\n+# description: Issue 956\n+# group: [rigger]\n+\n+# Buffer overflow in duckdb::ART::IteratorNext\n+statement ok\n+CREATE TABLE t0(c0 VARCHAR UNIQUE);\n+\n+statement ok\n+INSERT INTO t0 VALUES('19691214 051350'), (1), ('19700118'), (0), ('1969-1214 102704'), ('1969-12-14'), ('1969-12-14 114142'), ('1969-12-30 040325'), ('1969-12-18 044750'), ('1969-12-14 100915');\n+\n+statement ok\n+SELECT * FROM t0 WHERE '19691' > c0;\n",
  "problem_statement": "Buffer overflow in duckdb::ART::IteratorNext\nThe test case below triggers a heap buffer overflow in version 3d0e99c6d:\r\n\r\n```sql\r\nCREATE TABLE t0(c0 VARCHAR UNIQUE);\r\nINSERT INTO t0 VALUES('19691214 051350'), (1), ('19700118'), (0), ('1969-1214 102704'), ('1969-12-14'), ('1969-12-14 114142'), ('1969-12-30 040325'), ('1969-12-18 044750'), ('1969-12-14 100915');\r\nSELECT * FROM t0 WHERE '19691' > c0;\r\n```\r\nWhen using ASan, the following error is printed:\r\n```\r\n/duckdb/src/execution/index/art/art.cpp:531:21: runtime error: index 9 out of bounds for type 'IteratorEntry [9]'\r\n/duckdb/src/execution/index/art/art.cpp:532:21: runtime error: index 9 out of bounds for type 'IteratorEntry [9]'\r\n=================================================================\r\n==17069==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x616000024bb8 at pc 0x56470ed123d7 bp 0x7ffe1d509340 sp 0x7ffe1d509330\r\nWRITE of size 8 at 0x616000024bb8 thread T0\r\n    #0 0x56470ed123d6 in duckdb::ART::IteratorNext(duckdb::Iterator&) /duckdb/src/execution/index/art/art.cpp:532\r\n    #1 0x56470ed2bd84 in bool duckdb::ART::IteratorScan<true, false>(duckdb::ARTIndexScanState*, duckdb::Iterator*, duckdb::Key*, unsigned long, std::vector<long, std::allocator<long> >&) /duckdb/src/execution/index/art/art.cpp:505\r\n    #2 0x56470ed16d39 in duckdb::ART::SearchLess(duckdb::ARTIndexScanState*, bool, unsigned long, std::vector<long, std::allocator<long> >&) /duckdb/src/execution/index/art/art.cpp:708\r\n    #3 0x56470ed187ff in duckdb::ART::Scan(duckdb::Transaction&, duckdb::DataTable&, duckdb::IndexScanState&, unsigned long, std::vector<long, std::allocator<long> >&) /duckdb/src/execution/index/art/art.cpp:761\r\n    #4 0x56470e8437e1 in duckdb::table_scan_pushdown_complex_filter(duckdb::ClientContext&, duckdb::LogicalGet&, duckdb::FunctionData*, std::vector<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> >, std::allocator<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> > > >&) /duckdb/src/function/table/table_scan.cpp:284\r\n    #5 0x56470edf8e00 in duckdb::FilterPushdown::PushdownGet(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/pushdown/pushdown_get.cpp:23\r\n    #6 0x56470e1076ae in duckdb::FilterPushdown::Rewrite(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/filter_pushdown.cpp:38\r\n    #7 0x56470edf8170 in duckdb::FilterPushdown::PushdownFilter(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/pushdown/pushdown_filter.cpp:21\r\n    #8 0x56470e107056 in duckdb::FilterPushdown::Rewrite(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/filter_pushdown.cpp:18\r\n    #9 0x56470ee04198 in duckdb::FilterPushdown::PushdownProjection(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/pushdown/pushdown_projection.cpp:45\r\n    #10 0x56470e1072b1 in duckdb::FilterPushdown::Rewrite(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/filter_pushdown.cpp:26\r\n    #11 0x56470e109dd1 in duckdb::FilterPushdown::FinishPushdown(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/filter_pushdown.cpp:106\r\n    #12 0x56470e10776e in duckdb::FilterPushdown::Rewrite(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/filter_pushdown.cpp:40\r\n    #13 0x56470e1266ff in duckdb::Optimizer::Optimize(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/optimizer.cpp:50\r\n    #14 0x56470dd5a1d3 in duckdb::ClientContext::CreatePreparedStatement(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /duckdb/src/main/client_context.cpp:184\r\n    #15 0x56470dd5fbb6 in duckdb::ClientContext::RunStatementInternal(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, bool) /duckdb/src/main/client_context.cpp:349\r\n    #16 0x56470dd60c34 in duckdb::ClientContext::RunStatement(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, bool) /duckdb/src/main/client_context.cpp:382\r\n    #17 0x56470dd5d3d0 in duckdb::ClientContext::Prepare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) /duckdb/src/main/client_context.cpp:294\r\n    #18 0x56470dd73f1e in duckdb::Connection::Prepare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) /duckdb/src/main/connection.cpp:78\r\n```\r\nWhen executing the test case using the release build and exiting the CLI, the following error is printed:\r\n\r\n```\r\nmunmap_chunk(): invalid pointer\r\nAborted\r\n```\n",
  "hints_text": "",
  "created_at": "2020-09-26T11:31:32Z"
}