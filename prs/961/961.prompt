You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Buffer overflow in duckdb::ART::IteratorNext
The test case below triggers a heap buffer overflow in version 3d0e99c6d:

```sql
CREATE TABLE t0(c0 VARCHAR UNIQUE);
INSERT INTO t0 VALUES('19691214 051350'), (1), ('19700118'), (0), ('1969-1214 102704'), ('1969-12-14'), ('1969-12-14 114142'), ('1969-12-30 040325'), ('1969-12-18 044750'), ('1969-12-14 100915');
SELECT * FROM t0 WHERE '19691' > c0;
```
When using ASan, the following error is printed:
```
/duckdb/src/execution/index/art/art.cpp:531:21: runtime error: index 9 out of bounds for type 'IteratorEntry [9]'
/duckdb/src/execution/index/art/art.cpp:532:21: runtime error: index 9 out of bounds for type 'IteratorEntry [9]'
=================================================================
==17069==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x616000024bb8 at pc 0x56470ed123d7 bp 0x7ffe1d509340 sp 0x7ffe1d509330
WRITE of size 8 at 0x616000024bb8 thread T0
    #0 0x56470ed123d6 in duckdb::ART::IteratorNext(duckdb::Iterator&) /duckdb/src/execution/index/art/art.cpp:532
    #1 0x56470ed2bd84 in bool duckdb::ART::IteratorScan<true, false>(duckdb::ARTIndexScanState*, duckdb::Iterator*, duckdb::Key*, unsigned long, std::vector<long, std::allocator<long> >&) /duckdb/src/execution/index/art/art.cpp:505
    #2 0x56470ed16d39 in duckdb::ART::SearchLess(duckdb::ARTIndexScanState*, bool, unsigned long, std::vector<long, std::allocator<long> >&) /duckdb/src/execution/index/art/art.cpp:708
    #3 0x56470ed187ff in duckdb::ART::Scan(duckdb::Transaction&, duckdb::DataTable&, duckdb::IndexScanState&, unsigned long, std::vector<long, std::allocator<long> >&) /duckdb/src/execution/index/art/art.cpp:761
    #4 0x56470e8437e1 in duckdb::table_scan_pushdown_complex_filter(duckdb::ClientContext&, duckdb::LogicalGet&, duckdb::FunctionData*, std::vector<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> >, std::allocator<std::unique_ptr<duckdb::Expression, std::default_delete<duckdb::Expression> > > >&) /duckdb/src/function/table/table_scan.cpp:284
    #5 0x56470edf8e00 in duckdb::FilterPushdown::PushdownGet(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/pushdown/pushdown_get.cpp:23
    #6 0x56470e1076ae in duckdb::FilterPushdown::Rewrite(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/filter_pushdown.cpp:38
    #7 0x56470edf8170 in duckdb::FilterPushdown::PushdownFilter(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/pushdown/pushdown_filter.cpp:21
    #8 0x56470e107056 in duckdb::FilterPushdown::Rewrite(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/filter_pushdown.cpp:18
    #9 0x56470ee04198 in duckdb::FilterPushdown::PushdownProjection(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/pushdown/pushdown_projection.cpp:45
    #10 0x56470e1072b1 in duckdb::FilterPushdown::Rewrite(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/filter_pushdown.cpp:26
    #11 0x56470e109dd1 in duckdb::FilterPushdown::FinishPushdown(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/filter_pushdown.cpp:106
    #12 0x56470e10776e in duckdb::FilterPushdown::Rewrite(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/filter_pushdown.cpp:40
    #13 0x56470e1266ff in duckdb::Optimizer::Optimize(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/optimizer/optimizer.cpp:50
    #14 0x56470dd5a1d3 in duckdb::ClientContext::CreatePreparedStatement(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /duckdb/src/main/client_context.cpp:184
    #15 0x56470dd5fbb6 in duckdb::ClientContext::RunStatementInternal(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, bool) /duckdb/src/main/client_context.cpp:349
    #16 0x56470dd60c34 in duckdb::ClientContext::RunStatement(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, bool) /duckdb/src/main/client_context.cpp:382
    #17 0x56470dd5d3d0 in duckdb::ClientContext::Prepare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) /duckdb/src/main/client_context.cpp:294
    #18 0x56470dd73f1e in duckdb::Connection::Prepare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) /duckdb/src/main/connection.cpp:78
```
When executing the test case using the release build and exiting the CLI, the following error is printed:

```
munmap_chunk(): invalid pointer
Aborted
```

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="30">
2: 
3: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of src/execution/index/art/art.cpp]
1: #include "duckdb/execution/index/art/art.hpp"
2: #include "duckdb/execution/expression_executor.hpp"
3: #include "duckdb/common/vector_operations/vector_operations.hpp"
4: #include <algorithm>
5: #include <ctgmath>
6: 
7: namespace duckdb {
8: 
9: using namespace std;
10: 
11: ART::ART(vector<column_t> column_ids, vector<unique_ptr<Expression>> unbound_expressions, bool is_unique)
12:     : Index(IndexType::ART, column_ids, move(unbound_expressions)), is_unique(is_unique) {
13: 	tree = nullptr;
14: 	expression_result.Initialize(logical_types);
15: 	int n = 1;
16: 	//! little endian if true
17: 	if (*(char *)&n == 1) {
18: 		is_little_endian = true;
19: 	} else {
20: 		is_little_endian = false;
21: 	}
22: 	switch (types[0]) {
23: 	case PhysicalType::BOOL:
24: 	case PhysicalType::INT8:
25: 	case PhysicalType::INT16:
26: 	case PhysicalType::INT32:
27: 	case PhysicalType::INT64:
28: 	case PhysicalType::FLOAT:
29: 	case PhysicalType::DOUBLE:
30: 	case PhysicalType::VARCHAR:
31: 		break;
32: 	default:
33: 		throw InvalidTypeException(types[0], "Invalid type for index");
34: 	}
35: }
36: 
37: ART::~ART() {
38: }
39: 
40: bool ART::LeafMatches(Node *node, Key &key, unsigned depth) {
41: 	auto leaf = static_cast<Leaf *>(node);
42: 	Key &leaf_key = *leaf->value;
43: 	for (idx_t i = depth; i < leaf_key.len; i++) {
44: 		if (leaf_key[i] != key[i]) {
45: 			return false;
46: 		}
47: 	}
48: 
49: 	return true;
50: }
51: 
52: unique_ptr<IndexScanState> ART::InitializeScanSinglePredicate(Transaction &transaction, Value value,
53:                                                               ExpressionType expression_type) {
54: 	auto result = make_unique<ARTIndexScanState>();
55: 	result->values[0] = value;
56: 	result->expressions[0] = expression_type;
57: 	return move(result);
58: }
59: 
60: unique_ptr<IndexScanState> ART::InitializeScanTwoPredicates(Transaction &transaction, Value low_value,
61:                                                             ExpressionType low_expression_type, Value high_value,
62:                                                             ExpressionType high_expression_type) {
63: 	auto result = make_unique<ARTIndexScanState>();
64: 	result->values[0] = low_value;
65: 	result->expressions[0] = low_expression_type;
66: 	result->values[1] = high_value;
67: 	result->expressions[1] = high_expression_type;
68: 	return move(result);
69: }
70: 
71: //===--------------------------------------------------------------------===//
72: // Insert
73: //===--------------------------------------------------------------------===//
74: template <class T>
75: static void generate_keys(Vector &input, idx_t count, vector<unique_ptr<Key>> &keys, bool is_little_endian) {
76: 	VectorData idata;
77: 	input.Orrify(count, idata);
78: 
79: 	auto input_data = (T *)idata.data;
80: 	for (idx_t i = 0; i < count; i++) {
81: 		auto idx = idata.sel->get_index(i);
82: 		if ((*idata.nullmask)[idx]) {
83: 			keys.push_back(nullptr);
84: 		} else {
85: 			keys.push_back(Key::CreateKey<T>(input_data[idx], is_little_endian));
86: 		}
87: 	}
88: }
89: 
90: template <class T>
91: static void concatenate_keys(Vector &input, idx_t count, vector<unique_ptr<Key>> &keys, bool is_little_endian) {
92: 	VectorData idata;
93: 	input.Orrify(count, idata);
94: 
95: 	auto input_data = (T *)idata.data;
96: 	for (idx_t i = 0; i < count; i++) {
97: 		auto idx = idata.sel->get_index(i);
98: 		if ((*idata.nullmask)[idx] || !keys[i]) {
99: 			// either this column is NULL, or the previous column is NULL!
100: 			keys[i] = nullptr;
101: 		} else {
102: 			// concatenate the keys
103: 			auto old_key = move(keys[i]);
104: 			auto new_key = Key::CreateKey<T>(input_data[idx], is_little_endian);
105: 			auto keyLen = old_key->len + new_key->len;
106: 			auto compound_data = unique_ptr<data_t[]>(new data_t[keyLen]);
107: 			memcpy(compound_data.get(), old_key->data.get(), old_key->len);
108: 			memcpy(compound_data.get() + old_key->len, new_key->data.get(), new_key->len);
109: 			keys[i] = make_unique<Key>(move(compound_data), keyLen);
110: 		}
111: 	}
112: }
113: 
114: void ART::GenerateKeys(DataChunk &input, vector<unique_ptr<Key>> &keys) {
115: 	keys.reserve(STANDARD_VECTOR_SIZE);
116: 	// generate keys for the first input column
117: 	switch (input.data[0].type.InternalType()) {
118: 	case PhysicalType::BOOL:
119: 		generate_keys<bool>(input.data[0], input.size(), keys, is_little_endian);
120: 		break;
121: 	case PhysicalType::INT8:
122: 		generate_keys<int8_t>(input.data[0], input.size(), keys, is_little_endian);
123: 		break;
124: 	case PhysicalType::INT16:
125: 		generate_keys<int16_t>(input.data[0], input.size(), keys, is_little_endian);
126: 		break;
127: 	case PhysicalType::INT32:
128: 		generate_keys<int32_t>(input.data[0], input.size(), keys, is_little_endian);
129: 		break;
130: 	case PhysicalType::INT64:
131: 		generate_keys<int64_t>(input.data[0], input.size(), keys, is_little_endian);
132: 		break;
133: 	case PhysicalType::FLOAT:
134: 		generate_keys<float>(input.data[0], input.size(), keys, is_little_endian);
135: 		break;
136: 	case PhysicalType::DOUBLE:
137: 		generate_keys<double>(input.data[0], input.size(), keys, is_little_endian);
138: 		break;
139: 	case PhysicalType::VARCHAR:
140: 		generate_keys<string_t>(input.data[0], input.size(), keys, is_little_endian);
141: 		break;
142: 	default:
143: 		throw InvalidTypeException(input.data[0].type, "Invalid type for index");
144: 	}
145: 	for (idx_t i = 1; i < input.column_count(); i++) {
146: 		// for each of the remaining columns, concatenate
147: 		switch (input.data[i].type.InternalType()) {
148: 		case PhysicalType::BOOL:
149: 			concatenate_keys<bool>(input.data[i], input.size(), keys, is_little_endian);
150: 			break;
151: 		case PhysicalType::INT8:
152: 			concatenate_keys<int8_t>(input.data[i], input.size(), keys, is_little_endian);
153: 			break;
154: 		case PhysicalType::INT16:
155: 			concatenate_keys<int16_t>(input.data[i], input.size(), keys, is_little_endian);
156: 			break;
157: 		case PhysicalType::INT32:
158: 			concatenate_keys<int32_t>(input.data[i], input.size(), keys, is_little_endian);
159: 			break;
160: 		case PhysicalType::INT64:
161: 			concatenate_keys<int64_t>(input.data[i], input.size(), keys, is_little_endian);
162: 			break;
163: 		case PhysicalType::FLOAT:
164: 			concatenate_keys<float>(input.data[i], input.size(), keys, is_little_endian);
165: 			break;
166: 		case PhysicalType::DOUBLE:
167: 			concatenate_keys<double>(input.data[i], input.size(), keys, is_little_endian);
168: 			break;
169: 		case PhysicalType::VARCHAR:
170: 			concatenate_keys<string_t>(input.data[i], input.size(), keys, is_little_endian);
171: 			break;
172: 		default:
173: 			throw InvalidTypeException(input.data[0].type, "Invalid type for index");
174: 		}
175: 	}
176: }
177: 
178: bool ART::Insert(IndexLock &lock, DataChunk &input, Vector &row_ids) {
179: 	assert(row_ids.type.InternalType() == ROW_TYPE);
180: 	assert(logical_types[0] == input.data[0].type);
181: 
182: 	// generate the keys for the given input
183: 	vector<unique_ptr<Key>> keys;
184: 	GenerateKeys(input, keys);
185: 
186: 	// now insert the elements into the index
187: 	row_ids.Normalify(input.size());
188: 	auto row_identifiers = FlatVector::GetData<row_t>(row_ids);
189: 	idx_t failed_index = INVALID_INDEX;
190: 	for (idx_t i = 0; i < input.size(); i++) {
191: 		if (!keys[i]) {
192: 			continue;
193: 		}
194: 
195: 		row_t row_id = row_identifiers[i];
196: 		if (!Insert(tree, move(keys[i]), 0, row_id)) {
197: 			// failed to insert because of constraint violation
198: 			failed_index = i;
199: 			break;
200: 		}
201: 	}
202: 	if (failed_index != INVALID_INDEX) {
203: 		// failed to insert because of constraint violation: remove previously inserted entries
204: 		// generate keys again
205: 		keys.clear();
206: 		GenerateKeys(input, keys);
207: 		unique_ptr<Key> key;
208: 
209: 		// now erase the entries
210: 		for (idx_t i = 0; i < failed_index; i++) {
211: 			if (!keys[i]) {
212: 				continue;
213: 			}
214: 			row_t row_id = row_identifiers[i];
215: 			Erase(tree, *keys[i], 0, row_id);
216: 		}
217: 		return false;
218: 	}
219: 	return true;
220: }
221: 
222: bool ART::Append(IndexLock &lock, DataChunk &appended_data, Vector &row_identifiers) {
223: 	// first resolve the expressions for the index
224: 	ExecuteExpressions(appended_data, expression_result);
225: 
226: 	// now insert into the index
227: 	return Insert(lock, expression_result, row_identifiers);
228: }
229: 
230: void ART::VerifyAppend(DataChunk &chunk) {
231: 	if (!is_unique) {
232: 		return;
233: 	}
234: 	// unique index, check
235: 	lock_guard<mutex> l(lock);
236: 	// first resolve the expressions for the index
237: 	ExecuteExpressions(chunk, expression_result);
238: 
239: 	// generate the keys for the given input
240: 	vector<unique_ptr<Key>> keys;
241: 	GenerateKeys(expression_result, keys);
242: 
243: 	for (idx_t i = 0; i < chunk.size(); i++) {
244: 		if (!keys[i]) {
245: 			continue;
246: 		}
247: 		if (Lookup(tree, *keys[i], 0) != nullptr) {
248: 			// node already exists in tree
249: 			throw ConstraintException("duplicate key value violates primary key or unique constraint");
250: 		}
251: 	}
252: }
253: 
254: bool ART::InsertToLeaf(Leaf &leaf, row_t row_id) {
255: 	if (is_unique && leaf.num_elements != 0) {
256: 		return false;
257: 	}
258: 	leaf.Insert(row_id);
259: 	return true;
260: }
261: 
262: bool ART::Insert(unique_ptr<Node> &node, unique_ptr<Key> value, unsigned depth, row_t row_id) {
263: 	Key &key = *value;
264: 	if (!node) {
265: 		// node is currently empty, create a leaf here with the key
266: 		node = make_unique<Leaf>(*this, move(value), row_id);
267: 		return true;
268: 	}
269: 
270: 	if (node->type == NodeType::NLeaf) {
271: 		// Replace leaf with Node4 and store both leaves in it
272: 		auto leaf = static_cast<Leaf *>(node.get());
273: 
274: 		Key &existingKey = *leaf->value;
275: 		uint32_t newPrefixLength = 0;
276: 		// Leaf node is already there, update row_id vector
277: 		if (depth + newPrefixLength == existingKey.len && existingKey.len == key.len) {
278: 			return InsertToLeaf(*leaf, row_id);
279: 		}
280: 		while (existingKey[depth + newPrefixLength] == key[depth + newPrefixLength]) {
281: 			newPrefixLength++;
282: 			// Leaf node is already there, update row_id vector
283: 			if (depth + newPrefixLength == existingKey.len && existingKey.len == key.len) {
284: 				return InsertToLeaf(*leaf, row_id);
285: 			}
286: 		}
287: 
288: 		unique_ptr<Node> newNode = make_unique<Node4>(*this, newPrefixLength);
289: 		newNode->prefix_length = newPrefixLength;
290: 		memcpy(newNode->prefix.get(), &key[depth], newPrefixLength);
291: 		Node4::insert(*this, newNode, existingKey[depth + newPrefixLength], node);
292: 		unique_ptr<Node> leaf_node = make_unique<Leaf>(*this, move(value), row_id);
293: 		Node4::insert(*this, newNode, key[depth + newPrefixLength], leaf_node);
294: 		node = move(newNode);
295: 		return true;
296: 	}
297: 
298: 	// Handle prefix of inner node
299: 	if (node->prefix_length) {
300: 		uint32_t mismatchPos = Node::PrefixMismatch(*this, node.get(), key, depth);
301: 		if (mismatchPos != node->prefix_length) {
302: 			// Prefix differs, create new node
303: 			unique_ptr<Node> newNode = make_unique<Node4>(*this, mismatchPos);
304: 			newNode->prefix_length = mismatchPos;
305: 			memcpy(newNode->prefix.get(), node->prefix.get(), mismatchPos);
306: 			// Break up prefix
307: 			auto node_ptr = node.get();
308: 			Node4::insert(*this, newNode, node->prefix[mismatchPos], node);
309: 			node_ptr->prefix_length -= (mismatchPos + 1);
310: 			memmove(node_ptr->prefix.get(), node_ptr->prefix.get() + mismatchPos + 1, node_ptr->prefix_length);
311: 			unique_ptr<Node> leaf_node = make_unique<Leaf>(*this, move(value), row_id);
312: 			Node4::insert(*this, newNode, key[depth + mismatchPos], leaf_node);
313: 			node = move(newNode);
314: 			return true;
315: 		}
316: 		depth += node->prefix_length;
317: 	}
318: 
319: 	// Recurse
320: 	idx_t pos = node->GetChildPos(key[depth]);
321: 	if (pos != INVALID_INDEX) {
322: 		auto child = node->GetChild(pos);
323: 		return Insert(*child, move(value), depth + 1, row_id);
324: 	}
325: 	unique_ptr<Node> newNode = make_unique<Leaf>(*this, move(value), row_id);
326: 	Node::InsertLeaf(*this, node, key[depth], newNode);
327: 	return true;
328: }
329: 
330: //===--------------------------------------------------------------------===//
331: // Delete
332: //===--------------------------------------------------------------------===//
333: void ART::Delete(IndexLock &state, DataChunk &input, Vector &row_ids) {
334: 	// first resolve the expressions
335: 	ExecuteExpressions(input, expression_result);
336: 
337: 	// then generate the keys for the given input
338: 	vector<unique_ptr<Key>> keys;
339: 	GenerateKeys(expression_result, keys);
340: 
341: 	// now erase the elements from the database
342: 	row_ids.Normalify(input.size());
343: 	auto row_identifiers = FlatVector::GetData<row_t>(row_ids);
344: 
345: 	for (idx_t i = 0; i < input.size(); i++) {
346: 		if (!keys[i]) {
347: 			continue;
348: 		}
349: 		Erase(tree, *keys[i], 0, row_identifiers[i]);
350: 	}
351: }
352: 
353: void ART::Erase(unique_ptr<Node> &node, Key &key, unsigned depth, row_t row_id) {
354: 	if (!node) {
355: 		return;
356: 	}
357: 	// Delete a leaf from a tree
358: 	if (node->type == NodeType::NLeaf) {
359: 		// Make sure we have the right leaf
360: 		if (ART::LeafMatches(node.get(), key, depth)) {
361: 			auto leaf = static_cast<Leaf *>(node.get());
362: 			leaf->Remove(row_id);
363: 			if (leaf->num_elements == 0) {
364: 				node.reset();
365: 			}
366: 		}
367: 		return;
368: 	}
369: 
370: 	// Handle prefix
371: 	if (node->prefix_length) {
372: 		if (Node::PrefixMismatch(*this, node.get(), key, depth) != node->prefix_length) {
373: 			return;
374: 		}
375: 		depth += node->prefix_length;
376: 	}
377: 	idx_t pos = node->GetChildPos(key[depth]);
378: 	if (pos != INVALID_INDEX) {
379: 		auto child = node->GetChild(pos);
380: 		assert(child);
381: 
382: 		unique_ptr<Node> &child_ref = *child;
383: 		if (child_ref->type == NodeType::NLeaf && LeafMatches(child_ref.get(), key, depth)) {
384: 			// Leaf found, remove entry
385: 			auto leaf = static_cast<Leaf *>(child_ref.get());
386: 			leaf->Remove(row_id);
387: 			if (leaf->num_elements == 0) {
388: 				// Leaf is empty, delete leaf, decrement node counter and maybe shrink node
389: 				Node::Erase(*this, node, pos);
390: 			}
391: 		} else {
392: 			// Recurse
393: 			Erase(*child, key, depth + 1, row_id);
394: 		}
395: 	}
396: }
397: 
398: //===--------------------------------------------------------------------===//
399: // Point Query
400: //===--------------------------------------------------------------------===//
401: static unique_ptr<Key> CreateKey(ART &art, PhysicalType type, Value &value) {
402: 	assert(type == value.type().InternalType());
403: 	switch (type) {
404: 	case PhysicalType::BOOL:
405: 		return Key::CreateKey<bool>(value.value_.boolean, art.is_little_endian);
406: 	case PhysicalType::INT8:
407: 		return Key::CreateKey<int8_t>(value.value_.tinyint, art.is_little_endian);
408: 	case PhysicalType::INT16:
409: 		return Key::CreateKey<int16_t>(value.value_.smallint, art.is_little_endian);
410: 	case PhysicalType::INT32:
411: 		return Key::CreateKey<int32_t>(value.value_.integer, art.is_little_endian);
412: 	case PhysicalType::INT64:
413: 		return Key::CreateKey<int64_t>(value.value_.bigint, art.is_little_endian);
414: 	case PhysicalType::FLOAT:
415: 		return Key::CreateKey<float>(value.value_.float_, art.is_little_endian);
416: 	case PhysicalType::DOUBLE:
417: 		return Key::CreateKey<double>(value.value_.double_, art.is_little_endian);
418: 	case PhysicalType::VARCHAR:
419: 		return Key::CreateKey<string_t>(string_t(value.str_value.c_str(), value.str_value.size()),
420: 		                                art.is_little_endian);
421: 	default:
422: 		throw InvalidTypeException(type, "Invalid type for index");
423: 	}
424: }
425: 
426: bool ART::SearchEqual(ARTIndexScanState *state, idx_t max_count, vector<row_t> &result_ids) {
427: 	auto key = CreateKey(*this, types[0], state->values[0]);
428: 	auto leaf = static_cast<Leaf *>(Lookup(tree, *key, 0));
429: 	if (!leaf) {
430: 		return true;
431: 	}
432: 	if (leaf->num_elements > max_count) {
433: 		return false;
434: 	}
435: 	for (idx_t i = 0; i < leaf->num_elements; i++) {
436: 		row_t row_id = leaf->GetRowId(i);
437: 		result_ids.push_back(row_id);
438: 	}
439: 	return true;
440: }
441: 
442: Node *ART::Lookup(unique_ptr<Node> &node, Key &key, unsigned depth) {
443: 	auto node_val = node.get();
444: 
445: 	while (node_val) {
446: 		if (node_val->type == NodeType::NLeaf) {
447: 			auto leaf = static_cast<Leaf *>(node_val);
448: 			Key &leafKey = *leaf->value;
449: 			//! Check leaf
450: 			for (idx_t i = depth; i < leafKey.len; i++) {
451: 				if (leafKey[i] != key[i]) {
452: 					return nullptr;
453: 				}
454: 			}
455: 			return node_val;
456: 		}
457: 		if (node_val->prefix_length) {
458: 			for (idx_t pos = 0; pos < node_val->prefix_length; pos++) {
459: 				if (key[depth + pos] != node_val->prefix[pos]) {
460: 					return nullptr;
461: 				}
462: 			}
463: 			depth += node_val->prefix_length;
464: 		}
465: 		idx_t pos = node_val->GetChildPos(key[depth]);
466: 		if (pos == INVALID_INDEX) {
467: 			return nullptr;
468: 		}
469: 		node_val = node_val->GetChild(pos)->get();
470: 		assert(node_val);
471: 
472: 		depth++;
473: 	}
474: 
475: 	return nullptr;
476: }
477: 
478: //===--------------------------------------------------------------------===//
479: // Iterator scans
480: //===--------------------------------------------------------------------===//
481: template <bool HAS_BOUND, bool INCLUSIVE>
482: bool ART::IteratorScan(ARTIndexScanState *state, Iterator *it, Key *bound, idx_t max_count, vector<row_t> &result_ids) {
483: 	bool has_next;
484: 	do {
485: 		if (HAS_BOUND) {
486: 			assert(bound);
487: 			if (INCLUSIVE) {
488: 				if (*it->node->value > *bound) {
489: 					break;
490: 				}
491: 			} else {
492: 				if (*it->node->value >= *bound) {
493: 					break;
494: 				}
495: 			}
496: 		}
497: 		if (result_ids.size() + it->node->num_elements > max_count) {
498: 			// adding these elements would exceed the max count
499: 			return false;
500: 		}
501: 		for (idx_t i = 0; i < it->node->num_elements; i++) {
502: 			row_t row_id = it->node->GetRowId(i);
503: 			result_ids.push_back(row_id);
504: 		}
505: 		has_next = ART::IteratorNext(*it);
506: 	} while (has_next);
507: 	return true;
508: }
509: 
510: bool ART::IteratorNext(Iterator &it) {
511: 	// Skip leaf
512: 	if ((it.depth) && ((it.stack[it.depth - 1].node)->type == NodeType::NLeaf)) {
513: 		it.depth--;
514: 	}
515: 
516: 	// Look for the next leaf
517: 	while (it.depth > 0) {
518: 		auto &top = it.stack[it.depth - 1];
519: 		Node *node = top.node;
520: 
521: 		if (node->type == NodeType::NLeaf) {
522: 			// found a leaf: move to next node
523: 			it.node = (Leaf *)node;
524: 			return true;
525: 		}
526: 
527: 		// Find next node
528: 		top.pos = node->GetNextPos(top.pos);
529: 		if (top.pos != INVALID_INDEX) {
530: 			// next node found: go there
531: 			it.stack[it.depth].node = node->GetChild(top.pos)->get();
532: 			it.stack[it.depth].pos = INVALID_INDEX;
533: 			it.depth++;
534: 		} else {
535: 			// no node found: move up the tree
536: 			it.depth--;
537: 		}
538: 	}
539: 	return false;
540: }
541: 
542: //===--------------------------------------------------------------------===//
543: // Greater Than
544: // Returns: True (If found leaf >= key)
545: //          False (Otherwise)
546: //===--------------------------------------------------------------------===//
547: bool ART::Bound(unique_ptr<Node> &n, Key &key, Iterator &it, bool inclusive) {
548: 	it.depth = 0;
549: 	bool equal = false;
550: 	if (!n) {
551: 		return false;
552: 	}
553: 	Node *node = n.get();
554: 
555: 	idx_t depth = 0;
556: 	while (true) {
557: 		auto &top = it.stack[it.depth];
558: 		top.node = node;
559: 		it.depth++;
560: 		if (!equal) {
561: 			while (node->type != NodeType::NLeaf) {
562: 				node = node->GetChild(node->GetMin())->get();
563: 				auto &c_top = it.stack[it.depth];
564: 				c_top.node = node;
565: 				it.depth++;
566: 			}
567: 		}
568: 		if (node->type == NodeType::NLeaf) {
569: 			// found a leaf node: check if it is bigger or equal than the current key
570: 			auto leaf = static_cast<Leaf *>(node);
571: 			it.node = leaf;
572: 			// if the search is not inclusive the leaf node could still be equal to the current value
573: 			// check if leaf is equal to the current key
574: 			if (*leaf->value == key) {
575: 				// if its not inclusive check if there is a next leaf
576: 				if (!inclusive && !IteratorNext(it)) {
577: 					return false;
578: 				} else {
579: 					return true;
580: 				}
581: 			}
582: 
583: 			if (*leaf->value > key) {
584: 				return true;
585: 			}
586: 			// Leaf is lower than key
587: 			// Check if next leaf is still lower than key
588: 			while (IteratorNext(it)) {
589: 				if (*it.node->value == key) {
590: 					// if its not inclusive check if there is a next leaf
591: 					if (!inclusive && !IteratorNext(it)) {
592: 						return false;
593: 					} else {
594: 						return true;
595: 					}
596: 				} else if (*it.node->value > key) {
597: 					// if its not inclusive check if there is a next leaf
598: 					return true;
599: 				}
600: 			}
601: 			return false;
602: 		}
603: 		uint32_t mismatchPos = Node::PrefixMismatch(*this, node, key, depth);
604: 		if (mismatchPos != node->prefix_length) {
605: 			if (node->prefix[mismatchPos] < key[depth + mismatchPos]) {
606: 				// Less
607: 				it.depth--;
608: 				return IteratorNext(it);
609: 			} else {
610: 				// Greater
611: 				top.pos = INVALID_INDEX;
612: 				return IteratorNext(it);
613: 			}
614: 		}
615: 		// prefix matches, search inside the child for the key
616: 		depth += node->prefix_length;
617: 
618: 		top.pos = node->GetChildGreaterEqual(key[depth], equal);
619: 		if (top.pos == INVALID_INDEX) {
620: 			// Find min leaf
621: 			top.pos = node->GetMin();
622: 		}
623: 		node = node->GetChild(top.pos)->get();
624: 		//! This means all children of this node qualify as geq
625: 
626: 		depth++;
627: 	}
628: }
629: 
630: bool ART::SearchGreater(ARTIndexScanState *state, bool inclusive, idx_t max_count, vector<row_t> &result_ids) {
631: 	Iterator *it = &state->iterator;
632: 	auto key = CreateKey(*this, types[0], state->values[0]);
633: 
634: 	// greater than scan: first set the iterator to the node at which we will start our scan by finding the lowest node
635: 	// that satisfies our requirement
636: 	if (!it->start) {
637: 		bool found = ART::Bound(tree, *key, *it, inclusive);
638: 		if (!found) {
639: 			return true;
640: 		}
641: 		it->start = true;
642: 	}
643: 	// after that we continue the scan; we don't need to check the bounds as any value following this value is
644: 	// automatically bigger and hence satisfies our predicate
645: 	return IteratorScan<false, false>(state, it, nullptr, max_count, result_ids);
646: }
647: 
648: //===--------------------------------------------------------------------===//
649: // Less Than
650: //===--------------------------------------------------------------------===//
651: static Leaf &FindMinimum(Iterator &it, Node &node) {
652: 	Node *next = nullptr;
653: 	idx_t pos = 0;
654: 	switch (node.type) {
655: 	case NodeType::NLeaf:
656: 		it.node = (Leaf *)&node;
657: 		return (Leaf &)node;
658: 	case NodeType::N4:
659: 		next = ((Node4 &)node).child[0].get();
660: 		break;
661: 	case NodeType::N16:
662: 		next = ((Node16 &)node).child[0].get();
663: 		break;
664: 	case NodeType::N48: {
665: 		auto &n48 = (Node48 &)node;
666: 		while (n48.childIndex[pos] == Node::EMPTY_MARKER) {
667: 			pos++;
668: 		}
669: 		next = n48.child[n48.childIndex[pos]].get();
670: 		break;
671: 	}
672: 	case NodeType::N256: {
673: 		auto &n256 = (Node256 &)node;
674: 		while (!n256.child[pos]) {
675: 			pos++;
676: 		}
677: 		next = n256.child[pos].get();
678: 		break;
679: 	}
680: 	}
681: 	it.stack[it.depth].node = &node;
682: 	it.stack[it.depth].pos = pos;
683: 	it.depth++;
684: 	return FindMinimum(it, *next);
685: }
686: 
687: bool ART::SearchLess(ARTIndexScanState *state, bool inclusive, idx_t max_count, vector<row_t> &result_ids) {
688: 	if (!tree) {
689: 		return true;
690: 	}
691: 
692: 	Iterator *it = &state->iterator;
693: 	auto upper_bound = CreateKey(*this, types[0], state->values[0]);
694: 
695: 	if (!it->start) {
696: 		// first find the minimum value in the ART: we start scanning from this value
697: 		auto &minimum = FindMinimum(state->iterator, *tree);
698: 		// early out min value higher than upper bound query
699: 		if (*minimum.value > *upper_bound) {
700: 			return true;
701: 		}
702: 		it->start = true;
703: 	}
704: 	// now continue the scan until we reach the upper bound
705: 	if (inclusive) {
706: 		return IteratorScan<true, true>(state, it, upper_bound.get(), max_count, result_ids);
707: 	} else {
708: 		return IteratorScan<true, false>(state, it, upper_bound.get(), max_count, result_ids);
709: 	}
710: }
711: 
712: //===--------------------------------------------------------------------===//
713: // Closed Range Query
714: //===--------------------------------------------------------------------===//
715: bool ART::SearchCloseRange(ARTIndexScanState *state, bool left_inclusive, bool right_inclusive, idx_t max_count,
716:                            vector<row_t> &result_ids) {
717: 	auto lower_bound = CreateKey(*this, types[0], state->values[0]);
718: 	auto upper_bound = CreateKey(*this, types[0], state->values[1]);
719: 	Iterator *it = &state->iterator;
720: 	// first find the first node that satisfies the left predicate
721: 	if (!it->start) {
722: 		bool found = ART::Bound(tree, *lower_bound, *it, left_inclusive);
723: 		if (!found) {
724: 			return true;
725: 		}
726: 		it->start = true;
727: 	}
728: 	// now continue the scan until we reach the upper bound
729: 	if (right_inclusive) {
730: 		return IteratorScan<true, true>(state, it, upper_bound.get(), max_count, result_ids);
731: 	} else {
732: 		return IteratorScan<true, false>(state, it, upper_bound.get(), max_count, result_ids);
733: 	}
734: }
735: 
736: bool ART::Scan(Transaction &transaction, DataTable &table, IndexScanState &table_state, idx_t max_count,
737:                vector<row_t> &result_ids) {
738: 	auto state = (ARTIndexScanState *)&table_state;
739: 
740: 	assert(state->values[0].type().InternalType() == types[0]);
741: 
742: 	vector<row_t> row_ids;
743: 	bool success = true;
744: 	if (state->values[1].is_null) {
745: 		lock_guard<mutex> l(lock);
746: 		// single predicate
747: 		switch (state->expressions[0]) {
748: 		case ExpressionType::COMPARE_EQUAL:
749: 			success = SearchEqual(state, max_count, row_ids);
750: 			break;
751: 		case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
752: 			success = SearchGreater(state, true, max_count, row_ids);
753: 			break;
754: 		case ExpressionType::COMPARE_GREATERTHAN:
755: 			success = SearchGreater(state, false, max_count, row_ids);
756: 			break;
757: 		case ExpressionType::COMPARE_LESSTHANOREQUALTO:
758: 			success = SearchLess(state, true, max_count, row_ids);
759: 			break;
760: 		case ExpressionType::COMPARE_LESSTHAN:
761: 			success = SearchLess(state, false, max_count, row_ids);
762: 			break;
763: 		default:
764: 			throw NotImplementedException("Operation not implemented");
765: 		}
766: 	} else {
767: 		lock_guard<mutex> l(lock);
768: 		// two predicates
769: 		assert(state->values[1].type().InternalType() == types[0]);
770: 		bool left_inclusive = state->expressions[0] == ExpressionType ::COMPARE_GREATERTHANOREQUALTO;
771: 		bool right_inclusive = state->expressions[1] == ExpressionType ::COMPARE_LESSTHANOREQUALTO;
772: 		success = SearchCloseRange(state, left_inclusive, right_inclusive, max_count, row_ids);
773: 	}
774: 	if (!success) {
775: 		return false;
776: 	}
777: 	if (row_ids.size() == 0) {
778: 		return true;
779: 	}
780: 	// sort the row ids
781: 	sort(row_ids.begin(), row_ids.end());
782: 	// duplicate eliminate the row ids and append them to the row ids of the state
783: 	result_ids.reserve(row_ids.size());
784: 
785: 	result_ids.push_back(row_ids[0]);
786: 	for (idx_t i = 1; i < row_ids.size(); i++) {
787: 		if (row_ids[i] != row_ids[i - 1]) {
788: 			result_ids.push_back(row_ids[i]);
789: 		}
790: 	}
791: 	return true;
792: }
793: 
794: } // namespace duckdb
[end of src/execution/index/art/art.cpp]
[start of src/include/duckdb/execution/index/art/art.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/index/art/art.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types/data_chunk.hpp"
13: #include "duckdb/common/types/vector.hpp"
14: #include "duckdb/parser/parsed_expression.hpp"
15: #include "duckdb/storage/data_table.hpp"
16: #include "duckdb/storage/index.hpp"
17: 
18: #include "duckdb/execution/index/art/art_key.hpp"
19: #include "duckdb/execution/index/art/leaf.hpp"
20: #include "duckdb/execution/index/art/node.hpp"
21: #include "duckdb/execution/index/art/node4.hpp"
22: #include "duckdb/execution/index/art/node16.hpp"
23: #include "duckdb/execution/index/art/node48.hpp"
24: #include "duckdb/execution/index/art/node256.hpp"
25: 
26: namespace duckdb {
27: struct IteratorEntry {
28: 	Node *node = nullptr;
29: 	idx_t pos = 0;
30: };
31: 
32: struct Iterator {
33: 	//! The current Leaf Node, valid if depth>0
34: 	Leaf *node = nullptr;
35: 	//! The current depth
36: 	int32_t depth = 0;
37: 	//! Stack, actually the size is determined at runtime
38: 	IteratorEntry stack[9];
39: 
40: 	bool start = false;
41: };
42: 
43: struct ARTIndexScanState : public IndexScanState {
44: 	ARTIndexScanState() : checked(false), result_index(0) {
45: 	}
46: 
47: 	Value values[2];
48: 	ExpressionType expressions[2];
49: 	bool checked;
50: 	idx_t result_index = 0;
51: 	vector<row_t> result_ids;
52: 	Iterator iterator;
53: };
54: 
55: class ART : public Index {
56: public:
57: 	ART(vector<column_t> column_ids, vector<unique_ptr<Expression>> unbound_expressions, bool is_unique = false);
58: 	~ART();
59: 
60: 	//! Root of the tree
61: 	unique_ptr<Node> tree;
62: 	//! True if machine is little endian
63: 	bool is_little_endian;
64: 	//! Whether or not the ART is an index built to enforce a UNIQUE constraint
65: 	bool is_unique;
66: 
67: public:
68: 	//! Initialize a scan on the index with the given expression and column ids
69: 	//! to fetch from the base table for a single predicate
70: 	unique_ptr<IndexScanState> InitializeScanSinglePredicate(Transaction &transaction, Value value,
71: 	                                                         ExpressionType expressionType) override;
72: 
73: 	//! Initialize a scan on the index with the given expression and column ids
74: 	//! to fetch from the base table for two predicates
75: 	unique_ptr<IndexScanState> InitializeScanTwoPredicates(Transaction &transaction, Value low_value,
76: 	                                                       ExpressionType low_expression_type, Value high_value,
77: 	                                                       ExpressionType high_expression_type) override;
78: 
79: 	//! Perform a lookup on the index
80: 	bool Scan(Transaction &transaction, DataTable &table, IndexScanState &state, idx_t max_count,
81: 	          vector<row_t> &result_ids) override;
82: 	//! Append entries to the index
83: 	bool Append(IndexLock &lock, DataChunk &entries, Vector &row_identifiers) override;
84: 	//! Verify that data can be appended to the index
85: 	void VerifyAppend(DataChunk &chunk) override;
86: 	//! Delete entries in the index
87: 	void Delete(IndexLock &lock, DataChunk &entries, Vector &row_identifiers) override;
88: 
89: 	//! Insert data into the index.
90: 	bool Insert(IndexLock &lock, DataChunk &data, Vector &row_ids) override;
91: 
92: private:
93: 	DataChunk expression_result;
94: 
95: private:
96: 	//! Insert a row id into a leaf node
97: 	bool InsertToLeaf(Leaf &leaf, row_t row_id);
98: 	//! Insert the leaf value into the tree
99: 	bool Insert(unique_ptr<Node> &node, unique_ptr<Key> key, unsigned depth, row_t row_id);
100: 
101: 	//! Erase element from leaf (if leaf has more than one value) or eliminate the leaf itself
102: 	void Erase(unique_ptr<Node> &node, Key &key, unsigned depth, row_t row_id);
103: 
104: 	//! Check if the key of the leaf is equal to the searched key
105: 	bool LeafMatches(Node *node, Key &key, unsigned depth);
106: 
107: 	//! Find the node with a matching key, optimistic version
108: 	Node *Lookup(unique_ptr<Node> &node, Key &key, unsigned depth);
109: 
110: 	//! Find the first node that is bigger (or equal to) a specific key
111: 	bool Bound(unique_ptr<Node> &node, Key &key, Iterator &iterator, bool inclusive);
112: 
113: 	//! Gets next node for range queries
114: 	bool IteratorNext(Iterator &iter);
115: 
116: 	bool SearchEqual(ARTIndexScanState *state, idx_t max_count, vector<row_t> &result_ids);
117: 	bool SearchGreater(ARTIndexScanState *state, bool inclusive, idx_t max_count, vector<row_t> &result_ids);
118: 	bool SearchLess(ARTIndexScanState *state, bool inclusive, idx_t max_count, vector<row_t> &result_ids);
119: 	bool SearchCloseRange(ARTIndexScanState *state, bool left_inclusive, bool right_inclusive, idx_t max_count,
120: 	                      vector<row_t> &result_ids);
121: 
122: private:
123: 	template <bool HAS_BOUND, bool INCLUSIVE>
124: 	bool IteratorScan(ARTIndexScanState *state, Iterator *it, Key *upper_bound, idx_t max_count,
125: 	                  vector<row_t> &result_ids);
126: 
127: 	void GenerateKeys(DataChunk &input, vector<unique_ptr<Key>> &keys);
128: };
129: 
130: } // namespace duckdb
[end of src/include/duckdb/execution/index/art/art.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: