You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Error with MACRO Definition
**What does happen?**
Comparison expressions with '=' raise errors with defined MACRO

**What should happen?**
Should not raise error

**To Reproduce**
See code below:
```python
import duckdb
import pandas as pd

conn = duckdb.connect()
conn.execute("CREATE FUNCTION if_else(a, b, c) AS CASE WHEN a THEN b ELSE c END")
conn.execute("create table Foo as select 1 as X")
# works as expected
conn.execute("select if_else(X != 1, 1, 0) from Foo")
# raise RuntimeError: invalid type specifier
conn.execute("select if_else(X = 1, 1, 0) from Foo")
```

**Environment (please complete the following information):**
 - OS: Linux
 - DuckDB Version: 0.28

**Before submitting**
- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?
- [ ] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds


</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![codecov](https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN)](https://codecov.io/gh/duckdb/duckdb)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of extension/fts/fts_indexing.cpp]
1: #include "fts_indexing.hpp"
2: 
3: #include "duckdb/main/connection.hpp"
4: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/common/string_util.hpp"
7: #include "duckdb/parser/qualified_name.hpp"
8: 
9: namespace duckdb {
10: 
11: static string fts_schema_name(const string &schema, const string &table) {
12: 	return "fts_" + schema + "_" + table;
13: }
14: 
15: string drop_fts_index_query(ClientContext &context, const FunctionParameters &parameters) {
16: 	auto qname = QualifiedName::Parse(parameters.values[0].str_value);
17: 	qname.schema = qname.schema == INVALID_SCHEMA ? DEFAULT_SCHEMA : qname.schema;
18: 	string fts_schema = fts_schema_name(qname.schema, qname.name);
19: 
20: 	auto &catalog = Catalog::GetCatalog(context);
21: 	if (!catalog.schemas->GetEntry(context, fts_schema)) {
22: 		throw CatalogException(
23: 		    "a FTS index does not exist on table '%s.%s'. Create one with 'PRAGMA create_fts_index()'.", qname.schema,
24: 		    qname.name);
25: 	}
26: 
27: 	return "DROP SCHEMA " + fts_schema + " CASCADE;";
28: }
29: 
30: static string indexing_script(const string &input_schema, const string &input_table, const string &input_id,
31:                               const vector<string> &input_values, const string &stemmer, const string &stopwords,
32:                               const string &ignore, bool strip_accents, bool lower) {
33: 	// clang-format off
34:     string result = R"(
35:         DROP SCHEMA IF EXISTS %fts_schema% CASCADE;
36:         CREATE SCHEMA %fts_schema%;
37:         CREATE TABLE %fts_schema%.stopwords (sw VARCHAR);
38:     )";
39: 	// clang-format on
40: 
41: 	if (stopwords == "none") {
42: 		// do nothing
43: 	} else if (stopwords == "english") {
44: 		// default list of english stopwords from "The SMART system"
45: 		// clang-format off
46:         result += R"(
47:             INSERT INTO %fts_schema%.stopwords VALUES ('a'), ('a''s'), ('able'), ('about'), ('above'), ('according'), ('accordingly'), ('across'), ('actually'), ('after'), ('afterwards'), ('again'), ('against'), ('ain''t'), ('all'), ('allow'), ('allows'), ('almost'), ('alone'), ('along'), ('already'), ('also'), ('although'), ('always'), ('am'), ('among'), ('amongst'), ('an'), ('and'), ('another'), ('any'), ('anybody'), ('anyhow'), ('anyone'), ('anything'), ('anyway'), ('anyways'), ('anywhere'), ('apart'), ('appear'), ('appreciate'), ('appropriate'), ('are'), ('aren''t'), ('around'), ('as'), ('aside'), ('ask'), ('asking'), ('associated'), ('at'), ('available'), ('away'), ('awfully'), ('b'), ('be'), ('became'), ('because'), ('become'), ('becomes'), ('becoming'), ('been'), ('before'), ('beforehand'), ('behind'), ('being'), ('believe'), ('below'), ('beside'), ('besides'), ('best'), ('better'), ('between'), ('beyond'), ('both'), ('brief'), ('but'), ('by'), ('c'), ('c''mon'), ('c''s'), ('came'), ('can'), ('can''t'), ('cannot'), ('cant'), ('cause'), ('causes'), ('certain'), ('certainly'), ('changes'), ('clearly'), ('co'), ('com'), ('come'), ('comes'), ('concerning'), ('consequently'), ('consider'), ('considering'), ('contain'), ('containing'), ('contains'), ('corresponding'), ('could'), ('couldn''t'), ('course'), ('currently'), ('d'), ('definitely'), ('described'), ('despite'), ('did'), ('didn''t'), ('different'), ('do'), ('does'), ('doesn''t'), ('doing'), ('don''t'), ('done'), ('down'), ('downwards'), ('during'), ('e'), ('each'), ('edu'), ('eg'), ('eight'), ('either'), ('else'), ('elsewhere'), ('enough'), ('entirely'), ('especially'), ('et'), ('etc'), ('even'), ('ever'), ('every'), ('everybody'), ('everyone'), ('everything'), ('everywhere'), ('ex'), ('exactly'), ('example'), ('except'), ('f'), ('far'), ('few'), ('fifth'), ('first'), ('five'), ('followed'), ('following'), ('follows'), ('for'), ('former'), ('formerly'), ('forth'), ('four'), ('from'), ('further'), ('furthermore'), ('g'), ('get'), ('gets'), ('getting'), ('given'), ('gives'), ('go'), ('goes'), ('going'), ('gone'), ('got'), ('gotten'), ('greetings'), ('h'), ('had'), ('hadn''t'), ('happens'), ('hardly'), ('has'), ('hasn''t'), ('have'), ('haven''t'), ('having'), ('he'), ('he''s'), ('hello'), ('help'), ('hence'), ('her'), ('here'), ('here''s'), ('hereafter'), ('hereby'), ('herein'), ('hereupon'), ('hers'), ('herself'), ('hi'), ('him'), ('himself'), ('his'), ('hither'), ('hopefully'), ('how'), ('howbeit'), ('however'), ('i'), ('i''d'), ('i''ll'), ('i''m'), ('i''ve'), ('ie'), ('if'), ('ignored'), ('immediate'), ('in'), ('inasmuch'), ('inc'), ('indeed'), ('indicate'), ('indicated'), ('indicates'), ('inner'), ('insofar'), ('instead'), ('into'), ('inward'), ('is'), ('isn''t'), ('it'), ('it''d'), ('it''ll'), ('it''s'), ('its'), ('itself'), ('j'), ('just'), ('k'), ('keep'), ('keeps'), ('kept'), ('know'), ('knows'), ('known'), ('l'), ('last'), ('lately'), ('later'), ('latter'), ('latterly'), ('least'), ('less'), ('lest'), ('let'), ('let''s'), ('like'), ('liked'), ('likely'), ('little'), ('look'), ('looking'), ('looks'), ('ltd'), ('m'), ('mainly'), ('many'), ('may'), ('maybe'), ('me'), ('mean'), ('meanwhile'), ('merely'), ('might'), ('more'), ('moreover'), ('most'), ('mostly'), ('much'), ('must'), ('my'), ('myself'), ('n'), ('name'), ('namely'), ('nd'), ('near'), ('nearly'), ('necessary'), ('need'), ('needs'), ('neither'), ('never'), ('nevertheless'), ('new'), ('next'), ('nine'), ('no'), ('nobody'), ('non'), ('none'), ('noone'), ('nor'), ('normally'), ('not'), ('nothing'), ('novel'), ('now'), ('nowhere'), ('o'), ('obviously'), ('of'), ('off'), ('often'), ('oh'), ('ok'), ('okay'), ('old'), ('on'), ('once'), ('one'), ('ones'), ('only'), ('onto'), ('or'), ('other'), ('others'), ('otherwise'), ('ought'), ('our'), ('ours'), ('ourselves'), ('out'), ('outside'), ('over'), ('overall'), ('own');
48:             INSERT INTO %fts_schema%.stopwords VALUES ('p'), ('particular'), ('particularly'), ('per'), ('perhaps'), ('placed'), ('please'), ('plus'), ('possible'), ('presumably'), ('probably'), ('provides'), ('q'), ('que'), ('quite'), ('qv'), ('r'), ('rather'), ('rd'), ('re'), ('really'), ('reasonably'), ('regarding'), ('regardless'), ('regards'), ('relatively'), ('respectively'), ('right'), ('s'), ('said'), ('same'), ('saw'), ('say'), ('saying'), ('says'), ('second'), ('secondly'), ('see'), ('seeing'), ('seem'), ('seemed'), ('seeming'), ('seems'), ('seen'), ('self'), ('selves'), ('sensible'), ('sent'), ('serious'), ('seriously'), ('seven'), ('several'), ('shall'), ('she'), ('should'), ('shouldn''t'), ('since'), ('six'), ('so'), ('some'), ('somebody'), ('somehow'), ('someone'), ('something'), ('sometime'), ('sometimes'), ('somewhat'), ('somewhere'), ('soon'), ('sorry'), ('specified'), ('specify'), ('specifying'), ('still'), ('sub'), ('such'), ('sup'), ('sure'), ('t'), ('t''s'), ('take'), ('taken'), ('tell'), ('tends'), ('th'), ('than'), ('thank'), ('thanks'), ('thanx'), ('that'), ('that''s'), ('thats'), ('the'), ('their'), ('theirs'), ('them'), ('themselves'), ('then'), ('thence'), ('there'), ('there''s'), ('thereafter'), ('thereby'), ('therefore'), ('therein'), ('theres'), ('thereupon'), ('these'), ('they'), ('they''d'), ('they''ll'), ('they''re'), ('they''ve'), ('think'), ('third'), ('this'), ('thorough'), ('thoroughly'), ('those'), ('though'), ('three'), ('through'), ('throughout'), ('thru'), ('thus'), ('to'), ('together'), ('too'), ('took'), ('toward'), ('towards'), ('tried'), ('tries'), ('truly'), ('try'), ('trying'), ('twice'), ('two'), ('u'), ('un'), ('under'), ('unfortunately'), ('unless'), ('unlikely'), ('until'), ('unto'), ('up'), ('upon'), ('us'), ('use'), ('used'), ('useful'), ('uses'), ('using'), ('usually'), ('uucp'), ('v'), ('value'), ('various'), ('very'), ('via'), ('viz'), ('vs'), ('w'), ('want'), ('wants'), ('was'), ('wasn''t'), ('way'), ('we'), ('we''d'), ('we''ll'), ('we''re'), ('we''ve'), ('welcome'), ('well'), ('went'), ('were'), ('weren''t'), ('what'), ('what''s'), ('whatever'), ('when'), ('whence'), ('whenever'), ('where'), ('where''s'), ('whereafter'), ('whereas'), ('whereby'), ('wherein'), ('whereupon'), ('wherever'), ('whether'), ('which'), ('while'), ('whither'), ('who'), ('who''s'), ('whoever'), ('whole'), ('whom'), ('whose'), ('why'), ('will'), ('willing'), ('wish'), ('with'), ('within'), ('without'), ('won''t'), ('wonder'), ('would'), ('would'), ('wouldn''t'), ('x'), ('y'), ('yes'), ('yet'), ('you'), ('you''d'), ('you''ll'), ('you''re'), ('you''ve'), ('your'), ('yours'), ('yourself'), ('yourselves'), ('z'), ('zero');
49:         )";
50: 		// clang-format on
51: 	} else {
52: 		// custom stopwords
53: 		result += "INSERT INTO %fts_schema%.stopwords SELECT * FROM " + stopwords + ";";
54: 	}
55: 
56: 	// create tokenize macro based on parameters
57: 	string tokenize = "s";
58: 	vector<string> before;
59: 	vector<string> after;
60: 	if (strip_accents) {
61: 		tokenize = "strip_accents(" + tokenize + ")";
62: 	}
63: 	if (lower) {
64: 		tokenize = "lower(" + tokenize + ")";
65: 	}
66: 	tokenize = "regexp_replace(" + tokenize + ", '" + ignore + "', " + "' ', 'g')";
67: 	tokenize = "string_split_regex(" + tokenize + ", '\\s+')";
68: 	result += "CREATE MACRO %fts_schema%.tokenize(s) AS " + tokenize + ";";
69: 
70: 	// parameterized definition of indexing and retrieval model
71: 	// clang-format off
72: 	result += R"(
73:         CREATE TABLE %fts_schema%.docs AS (
74:             SELECT rowid AS docid,
75:                    "%input_id%" AS name
76:             FROM %input_schema%.%input_table%
77:         );
78: 
79: 	    CREATE TABLE %fts_schema%.fields (fieldid BIGINT, field VARCHAR);
80: 	    INSERT INTO %fts_schema%.fields VALUES %field_values%;
81: 
82:         CREATE TABLE %fts_schema%.terms AS
83:         WITH tokenized AS (
84:             %union_fields_query%
85:         ),
86: 	    stemmed_stopped AS (
87:             SELECT stem(t.w, '%stemmer%') AS term,
88: 	               t.docid AS docid,
89:                    t.fieldid AS fieldid
90: 	        FROM tokenized AS t
91: 	        WHERE t.w NOT NULL
92:               AND len(t.w) > 0
93: 	          AND t.w NOT IN (SELECT sw FROM %fts_schema%.stopwords)
94:         )
95: 	    SELECT ss.term,
96: 	           ss.docid,
97: 	           ss.fieldid
98:         FROM stemmed_stopped AS ss;
99: 
100:         ALTER TABLE %fts_schema%.docs ADD len BIGINT;
101:         UPDATE %fts_schema%.docs d
102:         SET len = (
103:             SELECT count(term)
104:             FROM %fts_schema%.terms AS t
105:             WHERE t.docid = d.docid
106:         );
107: 
108:         CREATE TABLE %fts_schema%.dict AS
109:         WITH distinct_terms AS (
110:             SELECT DISTINCT term
111:             FROM %fts_schema%.terms
112:         )
113:         SELECT row_number() OVER (PARTITION BY (SELECT NULL)) - 1 AS termid,
114:                dt.term
115:         FROM distinct_terms AS dt;
116: 
117:         ALTER TABLE %fts_schema%.terms ADD termid BIGINT;
118:         UPDATE %fts_schema%.terms t
119:         SET termid = (
120:             SELECT termid
121:             FROM %fts_schema%.dict d
122:             WHERE t.term = d.term
123:         );
124:         ALTER TABLE %fts_schema%.terms DROP term;
125: 
126:         ALTER TABLE %fts_schema%.dict ADD df BIGINT;
127:         UPDATE %fts_schema%.dict d
128:         SET df = (
129:             SELECT count(distinct docid)
130:             FROM %fts_schema%.terms t
131:             WHERE d.termid = t.termid
132:             GROUP BY termid
133:         );
134: 
135:         CREATE TABLE %fts_schema%.stats AS (
136:             SELECT COUNT(docs.docid) AS num_docs,
137:                    SUM(docs.len) / COUNT(docs.len) AS avgdl
138:             FROM %fts_schema%.docs AS docs
139:         );
140: 
141:         CREATE MACRO %fts_schema%.match_bm25(docname, query_string, fields=NULL, k=1.2, b=0.75, conjunctive=0) AS (
142:             WITH tokens AS (
143:                 SELECT DISTINCT stem(unnest(%fts_schema%.tokenize(query_string)), '%stemmer%') AS t
144:             ),
145:             fieldids AS (
146:                 SELECT fieldid
147:                 FROM %fts_schema%.fields
148:                 WHERE CASE WHEN fields IS NULL THEN 1 ELSE field IN (SELECT * FROM (SELECT UNNEST(string_split(fields, ','))) AS fsq) END
149:             ),
150:             qtermids AS (
151:                 SELECT termid
152:                 FROM %fts_schema%.dict AS dict,
153:                      tokens
154:                 WHERE dict.term = tokens.t
155:             ),
156:             qterms AS (
157:                 SELECT termid,
158:                        docid
159:                 FROM %fts_schema%.terms AS terms
160:                 WHERE CASE WHEN fields IS NULL THEN 1 ELSE fieldid IN (SELECT * FROM fieldids) END
161:                   AND termid IN (SELECT qtermids.termid FROM qtermids)
162:             ),
163:             subscores AS (
164:                 SELECT docs.docid,
165:                        len,
166:                        term_tf.termid,
167:                        tf,
168:                        df,
169:                        (log(((SELECT num_docs FROM %fts_schema%.stats) - df + 0.5) / (df + 0.5))* ((tf * (k + 1)/(tf + k * (1 - b + b * (len / (SELECT avgdl FROM %fts_schema%.stats))))))) AS subscore
170:                 FROM (
171:                     SELECT termid,
172:                            docid,
173:                            COUNT(*) AS tf
174:                     FROM qterms
175:                     GROUP BY docid,
176:                              termid
177:                 ) AS term_tf
178:                 JOIN (
179:                     SELECT docid
180:                     FROM qterms
181:                     GROUP BY docid
182:                     HAVING CASE WHEN conjunctive THEN COUNT(DISTINCT termid) = (SELECT COUNT(*) FROM tokens) ELSE 1 END
183:                 ) AS cdocs
184:                 ON term_tf.docid = cdocs.docid
185:                 JOIN %fts_schema%.docs AS docs
186:                 ON term_tf.docid = docs.docid
187:                 JOIN %fts_schema%.dict AS dict
188:                 ON term_tf.termid = dict.termid
189:             )
190:             SELECT score
191:             FROM (
192:                 SELECT docid,
193:                        sum(subscore) AS score
194:                 FROM subscores
195:                 GROUP BY docid
196:             ) AS scores
197:             JOIN %fts_schema%.docs AS docs
198:             ON  scores.docid = docs.docid
199:             AND docs.name = docname
200:         );
201:     )";
202: 
203:     // we may have more than 1 input field, therefore we union over the fields, retaining information which field it came from
204: 	string tokenize_field_query = R"(
205:         SELECT unnest(%fts_schema%.tokenize(fts_ii."%input_value%")) AS w,
206: 	           rowid AS docid,
207: 	           (SELECT fieldid FROM %fts_schema%.fields WHERE field = '%input_value%') AS fieldid
208:         FROM %input_schema%.%input_table% AS fts_ii
209:     )";
210: 	// clang-format on
211: 	vector<string> field_values;
212: 	vector<string> tokenize_fields;
213: 	for (idx_t i = 0; i < input_values.size(); i++) {
214: 		field_values.push_back(StringUtil::Format("(%i, '%s')", i, input_values[i]));
215: 		tokenize_fields.push_back(StringUtil::Replace(tokenize_field_query, "%input_value%", input_values[i]));
216: 	}
217: 	result = StringUtil::Replace(result, "%field_values%", StringUtil::Join(field_values, ", "));
218: 	result = StringUtil::Replace(result, "%union_fields_query%", StringUtil::Join(tokenize_fields, " UNION ALL "));
219: 
220: 	string fts_schema = fts_schema_name(input_schema, input_table);
221: 
222: 	// fill in variables (inefficiently, but keeps SQL script readable)
223: 	result = StringUtil::Replace(result, "%fts_schema%", fts_schema);
224: 	result = StringUtil::Replace(result, "%input_schema%", input_schema);
225: 	result = StringUtil::Replace(result, "%input_table%", input_table);
226: 	result = StringUtil::Replace(result, "%input_id%", input_id);
227: 	result = StringUtil::Replace(result, "%stemmer%", stemmer);
228: 
229: 	return result;
230: }
231: 
232: void check_exists(ClientContext &context, QualifiedName &qname) {
233: 	auto &catalog = Catalog::GetCatalog(context);
234: 	catalog.GetEntry<TableCatalogEntry>(context, qname.schema, qname.name);
235: }
236: 
237: string create_fts_index_query(ClientContext &context, const FunctionParameters &parameters) {
238: 	auto qname = QualifiedName::Parse(parameters.values[0].str_value);
239: 	qname.schema = qname.schema == INVALID_SCHEMA ? DEFAULT_SCHEMA : qname.schema;
240: 	check_exists(context, qname);
241: 	string fts_schema = fts_schema_name(qname.schema, qname.name);
242: 
243: 	// get named parameters
244: 	string stemmer = "porter";
245: 	auto stemmer_entry = parameters.named_parameters.find("stemmer");
246: 	if (stemmer_entry != parameters.named_parameters.end()) {
247: 		stemmer = stemmer_entry->second.str_value;
248: 	}
249: 	string stopwords = "english";
250: 
251: 	auto stopword_entry = parameters.named_parameters.find("stopwords");
252: 	if (stopword_entry != parameters.named_parameters.end()) {
253: 		stopwords = stopword_entry->second.str_value;
254: 		if (stopwords != "english" && stopwords != "none") {
255: 			auto stopwords_qname = QualifiedName::Parse(stopwords);
256: 			stopwords_qname.schema = stopwords_qname.schema == INVALID_SCHEMA ? DEFAULT_SCHEMA : stopwords_qname.schema;
257: 			check_exists(context, stopwords_qname);
258: 		}
259: 	}
260: 	string ignore = "(\\\\.|[^a-z])+";
261: 	auto ignore_entry = parameters.named_parameters.find("ignore");
262: 	if (ignore_entry != parameters.named_parameters.end()) {
263: 		ignore = ignore_entry->second.str_value;
264: 	}
265: 	bool strip_accents = true;
266: 	auto strip_accents_entry = parameters.named_parameters.find("strip_accents");
267: 	if (strip_accents_entry != parameters.named_parameters.end()) {
268: 		strip_accents = strip_accents_entry->second.value_.boolean;
269: 	}
270: 	bool lower = true;
271: 	auto lower_entry = parameters.named_parameters.find("lower");
272: 	if (lower_entry != parameters.named_parameters.end()) {
273: 		lower = lower_entry->second.value_.boolean;
274: 	}
275: 	bool overwrite = false;
276: 	auto overwrite_entry = parameters.named_parameters.find("overwrite");
277: 	if (overwrite_entry != parameters.named_parameters.end()) {
278: 		overwrite = overwrite_entry->second.value_.boolean;
279: 	}
280: 
281: 	// throw error if an index already exists on this table
282: 	auto &catalog = Catalog::GetCatalog(context);
283: 	if (catalog.schemas->GetEntry(context, fts_schema) && !overwrite) {
284: 		throw CatalogException("a FTS index already exists on table '%s.%s'. Supply 'overwite=1' to overwrite, or "
285: 		                       "drop the existing index with 'PRAGMA drop_fts_index()' before creating a new one.",
286: 		                       qname.schema, qname.name);
287: 	}
288: 
289: 	// positional parameters
290: 	auto doc_id = parameters.values[1].str_value;
291: 	// check all specified columns
292: 	auto table = catalog.GetEntry<TableCatalogEntry>(context, qname.schema, qname.name);
293: 	vector<string> doc_values;
294: 	for (idx_t i = 2; i < parameters.values.size(); i++) {
295: 		string col_name = parameters.values[i].str_value;
296: 		if (col_name == "*") {
297: 			// star found - get all columns
298: 			doc_values.clear();
299: 			for (auto &cd : table->columns) {
300: 				if (cd.type == LogicalType::VARCHAR) {
301: 					doc_values.push_back(cd.name);
302: 				}
303: 			}
304: 			break;
305: 		}
306: 		if (table->name_map.find(col_name) == table->name_map.end()) {
307: 			// we check this here because else we we end up with an error halfway the indexing script
308: 			throw CatalogException("Table '%s.%s' does not have a column named '%s'!", qname.schema, qname.name,
309: 			                       col_name);
310: 		}
311: 		doc_values.push_back(col_name);
312: 	}
313: 	if (doc_values.empty()) {
314: 		throw Exception("at least one column must be supplied for indexing!");
315: 	}
316: 
317: 	return indexing_script(qname.schema, qname.name, doc_id, doc_values, stemmer, stopwords, ignore, strip_accents,
318: 	                       lower);
319: }
320: 
321: } // namespace duckdb
[end of extension/fts/fts_indexing.cpp]
[start of src/function/macro_function.cpp]
1: #include "duckdb/function/macro_function.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/catalog/catalog_entry/macro_catalog_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
5: #include "duckdb/parser/expression/columnref_expression.hpp"
6: #include "duckdb/parser/expression/comparison_expression.hpp"
7: #include "duckdb/parser/expression/function_expression.hpp"
8: 
9: namespace duckdb {
10: 
11: MacroFunction::MacroFunction(unique_ptr<ParsedExpression> expression) : expression(move(expression)) {
12: }
13: 
14: string MacroFunction::ValidateArguments(MacroCatalogEntry &macro_func, FunctionExpression &function_expr,
15:                                         vector<unique_ptr<ParsedExpression>> &positionals,
16:                                         unordered_map<string, unique_ptr<ParsedExpression>> &defaults) {
17: 	// separate positional and default arguments
18: 	auto &macro_def = *macro_func.function;
19: 	for (auto &arg : function_expr.children) {
20: 		if (arg->type == ExpressionType::COMPARE_EQUAL) {
21: 			// default argument
22: 			auto &comp_expr = (ComparisonExpression &)*arg;
23: 			if (macro_def.default_parameters.find(comp_expr.left->ToString()) == macro_def.default_parameters.end()) {
24: 				return StringUtil::Format("Macro '%s()' does not have default parameter '%'s", macro_func.name,
25: 				                          comp_expr.left->ToString());
26: 			}
27: 			defaults[comp_expr.left->ToString()] = move(comp_expr.right);
28: 		} else if (!defaults.empty()) {
29: 			return "Positional parameters cannot come after parameters with a default value!";
30: 		} else {
31: 			// positional argument
32: 			positionals.push_back(move(arg));
33: 		}
34: 	}
35: 
36: 	// validate if the right number of arguments was supplied
37: 	string error;
38: 	auto &parameters = macro_func.function->parameters;
39: 	if (parameters.size() != positionals.size()) {
40: 		error = StringUtil::Format(
41: 		    "Macro function '%s(%s)' requires ", macro_func.name,
42: 		    StringUtil::Join(parameters, parameters.size(), ", ", [](const unique_ptr<ParsedExpression> &p) {
43: 			    return ((ColumnRefExpression &)*p).column_name;
44: 		    }));
45: 		error += parameters.size() == 1 ? "a single positional argument"
46: 		                                : StringUtil::Format("%i positional arguments", parameters.size());
47: 		error += ", but ";
48: 		error += positionals.size() == 1 ? "a single positional argument was"
49: 		                                 : StringUtil::Format("%i positional arguments were", positionals.size());
50: 		error += " provided.";
51: 		return error;
52: 	}
53: 
54: 	// fill in default value where this was not supplied
55: 	for (auto it = macro_def.default_parameters.begin(); it != macro_def.default_parameters.end(); it++) {
56: 		if (defaults.find(it->first) == defaults.end()) {
57: 			defaults[it->first] = it->second->Copy();
58: 		}
59: 	}
60: 
61: 	return error;
62: }
63: 
64: unique_ptr<MacroFunction> MacroFunction::Copy() {
65: 	auto result = make_unique<MacroFunction>(expression->Copy());
66: 	for (auto &param : parameters) {
67: 		result->parameters.push_back(param->Copy());
68: 	}
69: 	for (auto &kv : default_parameters) {
70: 		result->default_parameters[kv.first] = kv.second->Copy();
71: 	}
72: 	return result;
73: }
74: 
75: } // namespace duckdb
[end of src/function/macro_function.cpp]
[start of src/parser/transform/statement/transform_create_function.cpp]
1: #include "duckdb/function/macro_function.hpp"
2: #include "duckdb/parser/parsed_data/create_macro_info.hpp"
3: #include "duckdb/parser/statement/create_statement.hpp"
4: #include "duckdb/parser/expression/comparison_expression.hpp"
5: #include "duckdb/parser/transformer.hpp"
6: 
7: namespace duckdb {
8: 
9: unique_ptr<CreateStatement> Transformer::TransformCreateFunction(duckdb_libpgquery::PGNode *node) {
10: 	D_ASSERT(node);
11: 	D_ASSERT(node->type == duckdb_libpgquery::T_PGCreateFunctionStmt);
12: 
13: 	auto stmt = reinterpret_cast<duckdb_libpgquery::PGCreateFunctionStmt *>(node);
14: 	D_ASSERT(stmt);
15: 
16: 	auto result = make_unique<CreateStatement>();
17: 	auto info = make_unique<CreateMacroInfo>();
18: 
19: 	auto qname = TransformQualifiedName(stmt->name);
20: 	info->schema = qname.schema;
21: 	info->name = qname.name;
22: 
23: 	auto function = TransformExpression(stmt->function, 0);
24: 	D_ASSERT(function);
25: 	auto macro_func = make_unique<MacroFunction>(move(function));
26: 
27: 	if (stmt->params) {
28: 		vector<unique_ptr<ParsedExpression>> parameters;
29: 		TransformExpressionList(*stmt->params, parameters, 0);
30: 		for (auto &param : parameters) {
31: 			if (param->type == ExpressionType::COMPARE_EQUAL) {
32: 				// parameters with default value
33: 				auto &comp_expr = (ComparisonExpression &)*param;
34: 				if (comp_expr.left->GetExpressionClass() != ExpressionClass::COLUMN_REF) {
35: 					throw ParserException("Invalid parameter: '%s'", comp_expr.left->ToString());
36: 				}
37: 				if (comp_expr.right->GetExpressionClass() != ExpressionClass::CONSTANT) {
38: 					throw ParserException("Parameters may only have constants as default value!");
39: 				}
40: 				auto &param_name_expr = (ColumnRefExpression &)*comp_expr.left;
41: 				if (!param_name_expr.table_name.empty()) {
42: 					throw BinderException("Invalid parameter name '%s'", param_name_expr.ToString());
43: 				}
44: 				macro_func->default_parameters[comp_expr.left->ToString()] = move(comp_expr.right);
45: 			} else if (param->GetExpressionClass() == ExpressionClass::COLUMN_REF) {
46: 				// positional parameters
47: 				if (!macro_func->default_parameters.empty()) {
48: 					throw ParserException("Positional parameters cannot come after parameters with a default value!");
49: 				}
50: 				macro_func->parameters.push_back(move(param));
51: 			} else {
52: 				throw ParserException("Invalid parameter: '%s'", param->ToString());
53: 			}
54: 		}
55: 	}
56: 
57: 	info->function = move(macro_func);
58: 	result->info = move(info);
59: 	return result;
60: }
61: 
62: } // namespace duckdb
[end of src/parser/transform/statement/transform_create_function.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: