diff --git a/extension/fts/fts_indexing.cpp b/extension/fts/fts_indexing.cpp
index d0f870d42b30..bc4ebd56f0f1 100644
--- a/extension/fts/fts_indexing.cpp
+++ b/extension/fts/fts_indexing.cpp
@@ -138,7 +138,7 @@ static string indexing_script(const string &input_schema, const string &input_ta
             FROM %fts_schema%.docs AS docs
         );
 
-        CREATE MACRO %fts_schema%.match_bm25(docname, query_string, fields=NULL, k=1.2, b=0.75, conjunctive=0) AS (
+        CREATE MACRO %fts_schema%.match_bm25(docname, query_string, fields := NULL, k := 1.2, b := 0.75, conjunctive := 0) AS (
             WITH tokens AS (
                 SELECT DISTINCT stem(unnest(%fts_schema%.tokenize(query_string)), '%stemmer%') AS t
             ),
diff --git a/src/function/macro_function.cpp b/src/function/macro_function.cpp
index 2f11cd4c6e40..194728ce44a3 100644
--- a/src/function/macro_function.cpp
+++ b/src/function/macro_function.cpp
@@ -1,7 +1,8 @@
 #include "duckdb/function/macro_function.hpp"
-#include "duckdb/common/string_util.hpp"
+
 #include "duckdb/catalog/catalog_entry/macro_catalog_entry.hpp"
 #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
+#include "duckdb/common/string_util.hpp"
 #include "duckdb/parser/expression/columnref_expression.hpp"
 #include "duckdb/parser/expression/comparison_expression.hpp"
 #include "duckdb/parser/expression/function_expression.hpp"
@@ -17,14 +18,14 @@ string MacroFunction::ValidateArguments(MacroCatalogEntry &macro_func, FunctionE
 	// separate positional and default arguments
 	auto &macro_def = *macro_func.function;
 	for (auto &arg : function_expr.children) {
-		if (arg->type == ExpressionType::COMPARE_EQUAL) {
+		if (arg->type == ExpressionType::VALUE_CONSTANT && !arg->alias.empty()) {
 			// default argument
-			auto &comp_expr = (ComparisonExpression &)*arg;
-			if (macro_def.default_parameters.find(comp_expr.left->ToString()) == macro_def.default_parameters.end()) {
-				return StringUtil::Format("Macro '%s()' does not have default parameter '%'s", macro_func.name,
-				                          comp_expr.left->ToString());
+			if (macro_def.default_parameters.find(arg->alias) == macro_def.default_parameters.end()) {
+				return StringUtil::Format("Macro %s does not have default parameter %s!", macro_func.name, arg->alias);
+			} else if (defaults.find(arg->alias) != defaults.end()) {
+				return StringUtil::Format("Duplicate default parameters %s!", arg->alias);
 			}
-			defaults[comp_expr.left->ToString()] = move(comp_expr.right);
+			defaults[arg->alias] = move(arg);
 		} else if (!defaults.empty()) {
 			return "Positional parameters cannot come after parameters with a default value!";
 		} else {
diff --git a/src/parser/transform/statement/transform_create_function.cpp b/src/parser/transform/statement/transform_create_function.cpp
index a242966c42f8..74f4dcfb101b 100644
--- a/src/parser/transform/statement/transform_create_function.cpp
+++ b/src/parser/transform/statement/transform_create_function.cpp
@@ -28,20 +28,15 @@ unique_ptr<CreateStatement> Transformer::TransformCreateFunction(duckdb_libpgque
 		vector<unique_ptr<ParsedExpression>> parameters;
 		TransformExpressionList(*stmt->params, parameters, 0);
 		for (auto &param : parameters) {
-			if (param->type == ExpressionType::COMPARE_EQUAL) {
-				// parameters with default value
-				auto &comp_expr = (ComparisonExpression &)*param;
-				if (comp_expr.left->GetExpressionClass() != ExpressionClass::COLUMN_REF) {
-					throw ParserException("Invalid parameter: '%s'", comp_expr.left->ToString());
+			if (param->type == ExpressionType::VALUE_CONSTANT) {
+				// parameters with default value (must have an alias)
+				if (param->alias.empty()) {
+					throw ParserException("Invalid parameter: '%s'", param->ToString());
 				}
-				if (comp_expr.right->GetExpressionClass() != ExpressionClass::CONSTANT) {
-					throw ParserException("Parameters may only have constants as default value!");
+				if (macro_func->default_parameters.find(param->alias) != macro_func->default_parameters.end()) {
+					throw ParserException("Duplicate default parameter: '%s'", param->alias);
 				}
-				auto &param_name_expr = (ColumnRefExpression &)*comp_expr.left;
-				if (!param_name_expr.table_name.empty()) {
-					throw BinderException("Invalid parameter name '%s'", param_name_expr.ToString());
-				}
-				macro_func->default_parameters[comp_expr.left->ToString()] = move(comp_expr.right);
+				macro_func->default_parameters[param->alias] = move(param);
 			} else if (param->GetExpressionClass() == ExpressionClass::COLUMN_REF) {
 				// positional parameters
 				if (!macro_func->default_parameters.empty()) {
