{
  "repo": "duckdb/duckdb",
  "pull_number": 2188,
  "instance_id": "duckdb__duckdb-2188",
  "issue_numbers": [
    "2182"
  ],
  "base_commit": "42c12815540adeffe514221ce90dc1e67fb64d15",
  "patch": "diff --git a/extension/fts/fts_indexing.cpp b/extension/fts/fts_indexing.cpp\nindex d0f870d42b30..bc4ebd56f0f1 100644\n--- a/extension/fts/fts_indexing.cpp\n+++ b/extension/fts/fts_indexing.cpp\n@@ -138,7 +138,7 @@ static string indexing_script(const string &input_schema, const string &input_ta\n             FROM %fts_schema%.docs AS docs\n         );\n \n-        CREATE MACRO %fts_schema%.match_bm25(docname, query_string, fields=NULL, k=1.2, b=0.75, conjunctive=0) AS (\n+        CREATE MACRO %fts_schema%.match_bm25(docname, query_string, fields := NULL, k := 1.2, b := 0.75, conjunctive := 0) AS (\n             WITH tokens AS (\n                 SELECT DISTINCT stem(unnest(%fts_schema%.tokenize(query_string)), '%stemmer%') AS t\n             ),\ndiff --git a/src/function/macro_function.cpp b/src/function/macro_function.cpp\nindex 2f11cd4c6e40..194728ce44a3 100644\n--- a/src/function/macro_function.cpp\n+++ b/src/function/macro_function.cpp\n@@ -1,7 +1,8 @@\n #include \"duckdb/function/macro_function.hpp\"\n-#include \"duckdb/common/string_util.hpp\"\n+\n #include \"duckdb/catalog/catalog_entry/macro_catalog_entry.hpp\"\n #include \"duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/parser/expression/columnref_expression.hpp\"\n #include \"duckdb/parser/expression/comparison_expression.hpp\"\n #include \"duckdb/parser/expression/function_expression.hpp\"\n@@ -17,14 +18,14 @@ string MacroFunction::ValidateArguments(MacroCatalogEntry &macro_func, FunctionE\n \t// separate positional and default arguments\n \tauto &macro_def = *macro_func.function;\n \tfor (auto &arg : function_expr.children) {\n-\t\tif (arg->type == ExpressionType::COMPARE_EQUAL) {\n+\t\tif (arg->type == ExpressionType::VALUE_CONSTANT && !arg->alias.empty()) {\n \t\t\t// default argument\n-\t\t\tauto &comp_expr = (ComparisonExpression &)*arg;\n-\t\t\tif (macro_def.default_parameters.find(comp_expr.left->ToString()) == macro_def.default_parameters.end()) {\n-\t\t\t\treturn StringUtil::Format(\"Macro '%s()' does not have default parameter '%'s\", macro_func.name,\n-\t\t\t\t                          comp_expr.left->ToString());\n+\t\t\tif (macro_def.default_parameters.find(arg->alias) == macro_def.default_parameters.end()) {\n+\t\t\t\treturn StringUtil::Format(\"Macro %s does not have default parameter %s!\", macro_func.name, arg->alias);\n+\t\t\t} else if (defaults.find(arg->alias) != defaults.end()) {\n+\t\t\t\treturn StringUtil::Format(\"Duplicate default parameters %s!\", arg->alias);\n \t\t\t}\n-\t\t\tdefaults[comp_expr.left->ToString()] = move(comp_expr.right);\n+\t\t\tdefaults[arg->alias] = move(arg);\n \t\t} else if (!defaults.empty()) {\n \t\t\treturn \"Positional parameters cannot come after parameters with a default value!\";\n \t\t} else {\ndiff --git a/src/parser/transform/statement/transform_create_function.cpp b/src/parser/transform/statement/transform_create_function.cpp\nindex a242966c42f8..74f4dcfb101b 100644\n--- a/src/parser/transform/statement/transform_create_function.cpp\n+++ b/src/parser/transform/statement/transform_create_function.cpp\n@@ -28,20 +28,15 @@ unique_ptr<CreateStatement> Transformer::TransformCreateFunction(duckdb_libpgque\n \t\tvector<unique_ptr<ParsedExpression>> parameters;\n \t\tTransformExpressionList(*stmt->params, parameters, 0);\n \t\tfor (auto &param : parameters) {\n-\t\t\tif (param->type == ExpressionType::COMPARE_EQUAL) {\n-\t\t\t\t// parameters with default value\n-\t\t\t\tauto &comp_expr = (ComparisonExpression &)*param;\n-\t\t\t\tif (comp_expr.left->GetExpressionClass() != ExpressionClass::COLUMN_REF) {\n-\t\t\t\t\tthrow ParserException(\"Invalid parameter: '%s'\", comp_expr.left->ToString());\n+\t\t\tif (param->type == ExpressionType::VALUE_CONSTANT) {\n+\t\t\t\t// parameters with default value (must have an alias)\n+\t\t\t\tif (param->alias.empty()) {\n+\t\t\t\t\tthrow ParserException(\"Invalid parameter: '%s'\", param->ToString());\n \t\t\t\t}\n-\t\t\t\tif (comp_expr.right->GetExpressionClass() != ExpressionClass::CONSTANT) {\n-\t\t\t\t\tthrow ParserException(\"Parameters may only have constants as default value!\");\n+\t\t\t\tif (macro_func->default_parameters.find(param->alias) != macro_func->default_parameters.end()) {\n+\t\t\t\t\tthrow ParserException(\"Duplicate default parameter: '%s'\", param->alias);\n \t\t\t\t}\n-\t\t\t\tauto &param_name_expr = (ColumnRefExpression &)*comp_expr.left;\n-\t\t\t\tif (!param_name_expr.table_name.empty()) {\n-\t\t\t\t\tthrow BinderException(\"Invalid parameter name '%s'\", param_name_expr.ToString());\n-\t\t\t\t}\n-\t\t\t\tmacro_func->default_parameters[comp_expr.left->ToString()] = move(comp_expr.right);\n+\t\t\t\tmacro_func->default_parameters[param->alias] = move(param);\n \t\t\t} else if (param->GetExpressionClass() == ExpressionClass::COLUMN_REF) {\n \t\t\t\t// positional parameters\n \t\t\t\tif (!macro_func->default_parameters.empty()) {\n",
  "test_patch": "diff --git a/test/sql/catalog/function/test_simple_macro.test b/test/sql/catalog/function/test_simple_macro.test\nindex 0b4be7011361..8345e5060304 100644\n--- a/test/sql/catalog/function/test_simple_macro.test\n+++ b/test/sql/catalog/function/test_simple_macro.test\n@@ -137,6 +137,16 @@ SELECT IFELSE(0,'true','false')\n ----\n false\n \n+query T\n+SELECT IFELSE(a = 1, 'true', 'false') FROM integers\n+----\n+true\n+\n+query T\n+SELECT IFELSE(a = 0, 'true', 'false') FROM integers\n+----\n+false\n+\n # incorrect number of arguments\n statement error\n SELECT IFELSE();\n@@ -206,10 +216,10 @@ CREATE MACRO star() AS *\n \n # macro's with default arguments\n statement error\n-CREATE MACRO conflict(a, a=1) AS a + a\n+CREATE MACRO conflict(a, a := 1) AS a + a\n \n statement ok\n-CREATE MACRO add_default5(a, b=5) AS a + b\n+CREATE MACRO add_default5(a, b := 5) AS a + b\n \n statement error\n SELECT add_default5(3, 6)\n@@ -220,23 +230,50 @@ SELECT add_default5(3)\n 8\n \n query T\n-SELECT add_default5(3, b=6)\n+SELECT add_default5(3, b := 6)\n ----\n 9\n \n statement error\n-SELECT add_default5(b=6, 3)\n+SELECT add_default5(b := 6, 3)\n \n statement error\n-CREATE MACRO wrong_order(a, b=3, c)\n+CREATE MACRO wrong_order(a, b := 3, c)\n \n statement error\n-CREATE MACRO wrong_order(a=3, b)\n+CREATE MACRO wrong_order(a := 3, b)\n \n # only constant default values are allowed\n statement error\n-CREATE MACRO select_plus_floats(a, f=b) AS (SELECT a + f FROM floats)\n+CREATE MACRO select_plus_floats(a, f := b) AS (SELECT a + f FROM floats)\n \n # +(FLOAT, VARCHAR) does not work - constant types are checked at create time\n statement error\n CREATE MACRO wrong_type(s='not a float') AS (SELECT b + s FROM floats)\n+\n+statement error\n+CREATE MACRO two_default_params(a := 4, a := 2) AS a + a\n+\n+statement ok\n+CREATE MACRO two_default_params(a := 4, b := 2) AS a + b\n+\n+query T\n+SELECT two_default_params()\n+----\n+6\n+\n+query T\n+SELECT two_default_params(a := 5)\n+----\n+7\n+\n+query T\n+SELECT two_default_params(b := 3)\n+----\n+7\n+\n+statement error\n+SELECT two_default_params(a := 5, a := 3)\n+\n+statement error\n+SELECT two_default_params(b := 5, b := 3)\ndiff --git a/test/sql/fts/test_indexing.test_slow b/test/sql/fts/test_indexing.test_slow\nindex 8ca648520036..a50c20a69f7b 100644\n--- a/test/sql/fts/test_indexing.test_slow\n+++ b/test/sql/fts/test_indexing.test_slow\n@@ -167,38 +167,38 @@ EXECUTE fts_query(NULL)\n \n # different order by changing the parameters\n query III\n-SELECT id, body, author FROM (SELECT *, fts_main_documents.match_bm25(id, 'quacked barked', k=0.6, b=0.1) AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n+SELECT id, body, author FROM (SELECT *, fts_main_documents.match_bm25(id, 'quacked barked', k := 0.6, b := 0.1) AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n ----\n doc2\t B\u00c1RKING+B\u00c1RKING+B\u00c1RKING+B\u00c1RKING\tMark\n doc1\t QU\u00c1CKING+QU\u00c1CKING+QU\u00c1CKING\tHannes\n \n # no results for conjunctive query because no document contains both 'mark' and 'laurens\n query I\n-SELECT id FROM (SELECT *, fts_main_documents.match_bm25(id, 'mark laurens', conjunctive=1) AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n+SELECT id FROM (SELECT *, fts_main_documents.match_bm25(id, 'mark laurens', conjunctive := 1) AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n ----\n \n # strings 'mark' and 'laurens' are not found in the 'body' field of the table 'documents'\n query I\n-SELECT id FROM (SELECT *, fts_main_documents.match_bm25(id, 'mark laurens', fields='body') AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n+SELECT id FROM (SELECT *, fts_main_documents.match_bm25(id, 'mark laurens', fields := 'body') AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n ----\n \n # but they are found in the 'author' field!\n query I\n-SELECT id FROM (SELECT *, fts_main_documents.match_bm25(id, 'mark laurens', fields='author') AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n+SELECT id FROM (SELECT *, fts_main_documents.match_bm25(id, 'mark laurens', fields := 'author') AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n ----\n doc2\n doc3\n \n # if we search both the 'author' and 'body' fields then we get the same behaviour as leaving the fields empty\n query I\n-SELECT id FROM (SELECT *, fts_main_documents.match_bm25(id, 'mark laurens', fields='body,author') AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n+SELECT id FROM (SELECT *, fts_main_documents.match_bm25(id, 'mark laurens', fields := 'body,author') AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n ----\n doc2\n doc3\n \n # if we don't search any fields, we won't get any results\n query I\n-SELECT id FROM (SELECT *, fts_main_documents.match_bm25(id, 'hannes mark laurens', fields='') AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n+SELECT id FROM (SELECT *, fts_main_documents.match_bm25(id, 'hannes mark laurens', fields := '') AS score FROM documents) sq WHERE score IS NOT NULL ORDER BY score DESC\n ----\n \n # re-index with different stopwords table\ndiff --git a/test/sql/storage/catalog/test_macro_storage.test b/test/sql/storage/catalog/test_macro_storage.test\nindex 7505345ae143..0654258161e2 100644\n--- a/test/sql/storage/catalog/test_macro_storage.test\n+++ b/test/sql/storage/catalog/test_macro_storage.test\n@@ -49,7 +49,7 @@ endloop\n \n # create a macro without deleting it this time\n statement ok\n-CREATE MACRO plus2(a, b=2) AS a + b\n+CREATE MACRO plus2(a, b := 2) AS a + b\n \n loop i 0 2\n \n",
  "problem_statement": "Error with MACRO Definition\n**What does happen?**\r\nComparison expressions with '=' raise errors with defined MACRO\r\n\r\n**What should happen?**\r\nShould not raise error\r\n\r\n**To Reproduce**\r\nSee code below:\r\n```python\r\nimport duckdb\r\nimport pandas as pd\r\n\r\nconn = duckdb.connect()\r\nconn.execute(\"CREATE FUNCTION if_else(a, b, c) AS CASE WHEN a THEN b ELSE c END\")\r\nconn.execute(\"create table Foo as select 1 as X\")\r\n# works as expected\r\nconn.execute(\"select if_else(X != 1, 1, 0) from Foo\")\r\n# raise RuntimeError: invalid type specifier\r\nconn.execute(\"select if_else(X = 1, 1, 0) from Foo\")\r\n```\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Linux\r\n - DuckDB Version: 0.28\r\n\r\n**Before submitting**\r\n- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [ ] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\n",
  "hints_text": "It thinks X is a named parameter for the macro I believe. @lnkuiper ?\nI think that would throw a different error, actually, so I am not sure what is happening here. I will investigate this tomorrow!",
  "created_at": "2021-08-27T07:21:00Z"
}