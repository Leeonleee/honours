You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
No order preservation for OR in where clause
### What happens?

https://duckdb.org/docs/stable/sql/dialect/order_preservation.html says that the prefer of results is preserved with where clauses. But this does not work when there is an `or` in the query.

### To Reproduce

```sql
CREATE TABLE tbl AS
    SELECT *
    FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c')) t(x, y);

SELECT *
FROM tbl;
```

```sql
 select * from tbl where y = 'b' or y = 'a';
```

Results in 

```
┌───────┬─────────┐
│   x   │    y    │
│ int32 │ varchar │
├───────┼─────────┤
│     2 │ b       │
│     1 │ a       │
└───────┴─────────┘
```

when it should be 

```
┌───────┬─────────┐
│   x   │    y    │
│ int32 │ varchar │
├───────┼─────────┤
│     1 │ a       │
│     2 │ b       │
└───────┴─────────┘
```

### OS:

macOS

### DuckDB Version:

v1.2.2 7c039464e4

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

Dominik Moritz

### Affiliation:

CMU

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [ ] Yes, I have
No order preservation for OR in where clause
### What happens?

https://duckdb.org/docs/stable/sql/dialect/order_preservation.html says that the prefer of results is preserved with where clauses. But this does not work when there is an `or` in the query.

### To Reproduce

```sql
CREATE TABLE tbl AS
    SELECT *
    FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c')) t(x, y);

SELECT *
FROM tbl;
```

```sql
 select * from tbl where y = 'b' or y = 'a';
```

Results in 

```
┌───────┬─────────┐
│   x   │    y    │
│ int32 │ varchar │
├───────┼─────────┤
│     2 │ b       │
│     1 │ a       │
└───────┴─────────┘
```

when it should be 

```
┌───────┬─────────┐
│   x   │    y    │
│ int32 │ varchar │
├───────┼─────────┤
│     1 │ a       │
│     2 │ b       │
└───────┴─────────┘
```

### OS:

macOS

### DuckDB Version:

v1.2.2 7c039464e4

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

Dominik Moritz

### Affiliation:

CMU

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [ ] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/stable/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/stable/clients/cli/overview) and has clients for [Python](https://duckdb.org/docs/stable/clients/python/overview), [R](https://duckdb.org/docs/stable/clients/r), [Java](https://duckdb.org/docs/stable/clients/java), [Wasm](https://duckdb.org/docs/stable/clients/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdb.org/docs/stable/clients/r#duckplyr-dplyr-api).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/stable/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/stable/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/stable/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/docs/stable/dev/building/overview) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/common/types/selection_vector.cpp]
1: #include "duckdb/common/types/selection_vector.hpp"
2: 
3: #include "duckdb/common/printer.hpp"
4: #include "duckdb/common/to_string.hpp"
5: 
6: namespace duckdb {
7: 
8: SelectionData::SelectionData(idx_t count) {
9: 	owned_data = Allocator::DefaultAllocator().Allocate(MaxValue<idx_t>(count, 1) * sizeof(sel_t));
10: #ifdef DEBUG
11: 	auto data_ptr = reinterpret_cast<sel_t *>(owned_data.get());
12: 	for (idx_t i = 0; i < count; i++) {
13: 		data_ptr[i] = std::numeric_limits<sel_t>::max();
14: 	}
15: #endif
16: }
17: 
18: // LCOV_EXCL_START
19: string SelectionVector::ToString(idx_t count) const {
20: 	string result = "Selection Vector (" + to_string(count) + ") [";
21: 	for (idx_t i = 0; i < count; i++) {
22: 		if (i != 0) {
23: 			result += ", ";
24: 		}
25: 		result += to_string(get_index(i));
26: 	}
27: 	result += "]";
28: 	return result;
29: }
30: 
31: void SelectionVector::Print(idx_t count) const {
32: 	Printer::Print(ToString(count));
33: }
34: // LCOV_EXCL_STOP
35: 
36: buffer_ptr<SelectionData> SelectionVector::Slice(const SelectionVector &sel, idx_t count) const {
37: 	auto data = make_buffer<SelectionData>(count);
38: 	auto result_ptr = reinterpret_cast<sel_t *>(data->owned_data.get());
39: 	// for every element, we perform result[i] = target[new[i]]
40: 	for (idx_t i = 0; i < count; i++) {
41: 		auto new_idx = sel.get_index(i);
42: 		auto idx = this->get_index(new_idx);
43: 		result_ptr[i] = UnsafeNumericCast<sel_t>(idx);
44: 	}
45: 	return data;
46: }
47: 
48: void SelectionVector::Verify(idx_t count, idx_t vector_size) const {
49: #ifdef DEBUG
50: 	D_ASSERT(vector_size >= 1);
51: 	for (idx_t i = 0; i < count; i++) {
52: 		auto index = get_index(i);
53: 		if (index >= vector_size) {
54: 			throw InternalException(
55: 			    "Provided SelectionVector is invalid, index %d points to %d, which is out of range. "
56: 			    "the valid range (0-%d)",
57: 			    i, index, vector_size - 1);
58: 		}
59: 	}
60: #endif
61: }
62: 
63: } // namespace duckdb
[end of src/common/types/selection_vector.cpp]
[start of src/execution/expression_executor/execute_conjunction.cpp]
1: #include "duckdb/common/vector_operations/vector_operations.hpp"
2: #include "duckdb/execution/expression_executor.hpp"
3: #include "duckdb/planner/expression/bound_conjunction_expression.hpp"
4: #include "duckdb/execution/adaptive_filter.hpp"
5: 
6: #include <random>
7: 
8: namespace duckdb {
9: 
10: struct ConjunctionState : public ExpressionState {
11: 	ConjunctionState(const Expression &expr, ExpressionExecutorState &root) : ExpressionState(expr, root) {
12: 		adaptive_filter = make_uniq<AdaptiveFilter>(expr);
13: 	}
14: 	unique_ptr<AdaptiveFilter> adaptive_filter;
15: };
16: 
17: unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const BoundConjunctionExpression &expr,
18:                                                                 ExpressionExecutorState &root) {
19: 	auto result = make_uniq<ConjunctionState>(expr, root);
20: 	for (auto &child : expr.children) {
21: 		result->AddChild(*child);
22: 	}
23: 
24: 	result->Finalize();
25: 	return std::move(result);
26: }
27: 
28: void ExpressionExecutor::Execute(const BoundConjunctionExpression &expr, ExpressionState *state,
29:                                  const SelectionVector *sel, idx_t count, Vector &result) {
30: 	// execute the children
31: 	state->intermediate_chunk.Reset();
32: 	for (idx_t i = 0; i < expr.children.size(); i++) {
33: 		auto &current_result = state->intermediate_chunk.data[i];
34: 		Execute(*expr.children[i], state->child_states[i].get(), sel, count, current_result);
35: 		if (i == 0) {
36: 			// move the result
37: 			result.Reference(current_result);
38: 		} else {
39: 			Vector intermediate(LogicalType::BOOLEAN);
40: 			// AND/OR together
41: 			switch (expr.GetExpressionType()) {
42: 			case ExpressionType::CONJUNCTION_AND:
43: 				VectorOperations::And(current_result, result, intermediate, count);
44: 				break;
45: 			case ExpressionType::CONJUNCTION_OR:
46: 				VectorOperations::Or(current_result, result, intermediate, count);
47: 				break;
48: 			default:
49: 				throw InternalException("Unknown conjunction type!");
50: 			}
51: 			result.Reference(intermediate);
52: 		}
53: 	}
54: }
55: 
56: idx_t ExpressionExecutor::Select(const BoundConjunctionExpression &expr, ExpressionState *state_p,
57:                                  const SelectionVector *sel, idx_t count, SelectionVector *true_sel,
58:                                  SelectionVector *false_sel) {
59: 	auto &state = state_p->Cast<ConjunctionState>();
60: 
61: 	if (expr.GetExpressionType() == ExpressionType::CONJUNCTION_AND) {
62: 		// get runtime statistics
63: 		auto filter_state = state.adaptive_filter->BeginFilter();
64: 		const SelectionVector *current_sel = sel;
65: 		idx_t current_count = count;
66: 		idx_t false_count = 0;
67: 
68: 		unique_ptr<SelectionVector> temp_true, temp_false;
69: 		if (false_sel) {
70: 			temp_false = make_uniq<SelectionVector>(STANDARD_VECTOR_SIZE);
71: 		}
72: 		if (!true_sel) {
73: 			temp_true = make_uniq<SelectionVector>(STANDARD_VECTOR_SIZE);
74: 			true_sel = temp_true.get();
75: 		}
76: 		for (idx_t i = 0; i < expr.children.size(); i++) {
77: 			idx_t tcount = Select(*expr.children[state.adaptive_filter->permutation[i]],
78: 			                      state.child_states[state.adaptive_filter->permutation[i]].get(), current_sel,
79: 			                      current_count, true_sel, temp_false.get());
80: 			idx_t fcount = current_count - tcount;
81: 			if (fcount > 0 && false_sel) {
82: 				// move failing tuples into the false_sel
83: 				// tuples passed, move them into the actual result vector
84: 				for (idx_t i = 0; i < fcount; i++) {
85: 					false_sel->set_index(false_count++, temp_false->get_index(i));
86: 				}
87: 			}
88: 			current_count = tcount;
89: 			if (current_count == 0) {
90: 				break;
91: 			}
92: 			if (current_count < count) {
93: 				// tuples were filtered out: move on to using the true_sel to only evaluate passing tuples in subsequent
94: 				// iterations
95: 				current_sel = true_sel;
96: 			}
97: 		}
98: 		// adapt runtime statistics
99: 		state.adaptive_filter->EndFilter(filter_state);
100: 		return current_count;
101: 	} else {
102: 		// get runtime statistics
103: 		auto filter_state = state.adaptive_filter->BeginFilter();
104: 
105: 		const SelectionVector *current_sel = sel;
106: 		idx_t current_count = count;
107: 		idx_t result_count = 0;
108: 
109: 		unique_ptr<SelectionVector> temp_true, temp_false;
110: 		if (true_sel) {
111: 			temp_true = make_uniq<SelectionVector>(STANDARD_VECTOR_SIZE);
112: 		}
113: 		if (!false_sel) {
114: 			temp_false = make_uniq<SelectionVector>(STANDARD_VECTOR_SIZE);
115: 			false_sel = temp_false.get();
116: 		}
117: 		for (idx_t i = 0; i < expr.children.size(); i++) {
118: 			idx_t tcount = Select(*expr.children[state.adaptive_filter->permutation[i]],
119: 			                      state.child_states[state.adaptive_filter->permutation[i]].get(), current_sel,
120: 			                      current_count, temp_true.get(), false_sel);
121: 			if (tcount > 0) {
122: 				if (true_sel) {
123: 					// tuples passed, move them into the actual result vector
124: 					for (idx_t i = 0; i < tcount; i++) {
125: 						true_sel->set_index(result_count++, temp_true->get_index(i));
126: 					}
127: 				}
128: 				// now move on to check only the non-passing tuples
129: 				current_count -= tcount;
130: 				current_sel = false_sel;
131: 			}
132: 		}
133: 
134: 		// adapt runtime statistics
135: 		state.adaptive_filter->EndFilter(filter_state);
136: 		return result_count;
137: 	}
138: }
139: 
140: } // namespace duckdb
[end of src/execution/expression_executor/execute_conjunction.cpp]
[start of src/include/duckdb/common/types/selection_vector.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/selection_vector.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/allocator.hpp"
12: #include "duckdb/common/common.hpp"
13: #include "duckdb/common/numeric_utils.hpp"
14: #include "duckdb/common/types.hpp"
15: #include "duckdb/common/vector_size.hpp"
16: 
17: namespace duckdb {
18: class VectorBuffer;
19: 
20: struct SelectionData {
21: 	DUCKDB_API explicit SelectionData(idx_t count);
22: 
23: 	AllocatedData owned_data;
24: };
25: 
26: struct SelectionVector {
27: 	SelectionVector() : sel_vector(nullptr) {
28: 	}
29: 	explicit SelectionVector(sel_t *sel) {
30: 		Initialize(sel);
31: 	}
32: 	explicit SelectionVector(idx_t count) {
33: 		Initialize(count);
34: 	}
35: 	SelectionVector(idx_t start, idx_t count) {
36: 		Initialize(MaxValue<idx_t>(count, STANDARD_VECTOR_SIZE));
37: 		for (idx_t i = 0; i < count; i++) {
38: 			set_index(i, start + i);
39: 		}
40: 	}
41: 	SelectionVector(const SelectionVector &sel_vector) {
42: 		Initialize(sel_vector);
43: 	}
44: 	explicit SelectionVector(buffer_ptr<SelectionData> data) {
45: 		Initialize(std::move(data));
46: 	}
47: 	SelectionVector &operator=(SelectionVector &&other) noexcept {
48: 		sel_vector = other.sel_vector;
49: 		other.sel_vector = nullptr;
50: 		selection_data = std::move(other.selection_data);
51: 		return *this;
52: 	}
53: 
54: public:
55: 	static idx_t Inverted(const SelectionVector &src, SelectionVector &dst, idx_t source_size, idx_t count) {
56: 		idx_t src_idx = 0;
57: 		idx_t dst_idx = 0;
58: 		for (idx_t i = 0; i < count; i++) {
59: 			if (src_idx < source_size && src.get_index(src_idx) == i) {
60: 				src_idx++;
61: 				// This index is selected by 'src', skip it in 'dst'
62: 				continue;
63: 			}
64: 			// This index does not exist in 'src', add it to the selection of 'dst'
65: 			dst.set_index(dst_idx++, i);
66: 		}
67: 		return dst_idx;
68: 	}
69: 
70: 	void Initialize(sel_t *sel) {
71: 		selection_data.reset();
72: 		sel_vector = sel;
73: 	}
74: 	void Initialize(idx_t count = STANDARD_VECTOR_SIZE) {
75: 		selection_data = make_shared_ptr<SelectionData>(count);
76: 		sel_vector = reinterpret_cast<sel_t *>(selection_data->owned_data.get());
77: 	}
78: 	void Initialize(buffer_ptr<SelectionData> data) {
79: 		selection_data = std::move(data);
80: 		sel_vector = reinterpret_cast<sel_t *>(selection_data->owned_data.get());
81: 	}
82: 	void Initialize(const SelectionVector &other) {
83: 		selection_data = other.selection_data;
84: 		sel_vector = other.sel_vector;
85: 	}
86: 
87: 	inline void set_index(idx_t idx, idx_t loc) { // NOLINT: allow casing for legacy reasons
88: 		sel_vector[idx] = UnsafeNumericCast<sel_t>(loc);
89: 	}
90: 	inline void swap(idx_t i, idx_t j) { // NOLINT: allow casing for legacy reasons
91: 		sel_t tmp = sel_vector[i];
92: 		sel_vector[i] = sel_vector[j];
93: 		sel_vector[j] = tmp;
94: 	}
95: 	inline idx_t get_index(idx_t idx) const { // NOLINT: allow casing for legacy reasons
96: 		return sel_vector ? sel_vector[idx] : idx;
97: 	}
98: 	sel_t *data() { // NOLINT: allow casing for legacy reasons
99: 		return sel_vector;
100: 	}
101: 	const sel_t *data() const { // NOLINT: allow casing for legacy reasons
102: 		return sel_vector;
103: 	}
104: 	buffer_ptr<SelectionData> sel_data() { // NOLINT: allow casing for legacy reasons
105: 		return selection_data;
106: 	}
107: 	buffer_ptr<SelectionData> Slice(const SelectionVector &sel, idx_t count) const;
108: 
109: 	string ToString(idx_t count = 0) const;
110: 	void Print(idx_t count = 0) const;
111: 
112: 	inline sel_t &operator[](idx_t index) const {
113: 		return sel_vector[index];
114: 	}
115: 	inline bool IsSet() const {
116: 		return sel_vector;
117: 	}
118: 	void Verify(idx_t count, idx_t vector_size) const;
119: 
120: private:
121: 	sel_t *sel_vector;
122: 	buffer_ptr<SelectionData> selection_data;
123: };
124: 
125: class OptionalSelection {
126: public:
127: 	explicit OptionalSelection(SelectionVector *sel_p) {
128: 		Initialize(sel_p);
129: 	}
130: 	void Initialize(SelectionVector *sel_p) {
131: 		sel = sel_p;
132: 		if (sel) {
133: 			vec.Initialize(sel->data());
134: 			sel = &vec;
135: 		}
136: 	}
137: 
138: 	inline operator SelectionVector *() { // NOLINT: allow implicit conversion to SelectionVector
139: 		return sel;
140: 	}
141: 
142: 	inline void Append(idx_t &count, const idx_t idx) {
143: 		if (sel) {
144: 			sel->set_index(count, idx);
145: 		}
146: 		++count;
147: 	}
148: 
149: 	inline void Advance(idx_t completed) {
150: 		if (sel) {
151: 			sel->Initialize(sel->data() + completed);
152: 		}
153: 	}
154: 
155: private:
156: 	SelectionVector *sel;
157: 	SelectionVector vec;
158: };
159: 
160: // Contains a selection vector, combined with a count
161: class ManagedSelection {
162: public:
163: 	explicit inline ManagedSelection(idx_t size, bool initialize = true)
164: 	    : initialized(initialize), size(size), internal_opt_selvec(nullptr) {
165: 		count = 0;
166: 		if (!initialized) {
167: 			return;
168: 		}
169: 		sel_vec.Initialize(size);
170: 		internal_opt_selvec.Initialize(&sel_vec);
171: 	}
172: 
173: public:
174: 	bool Initialized() const {
175: 		return initialized;
176: 	}
177: 	void Initialize(idx_t new_size) {
178: 		D_ASSERT(!initialized);
179: 		this->size = new_size;
180: 		sel_vec.Initialize(new_size);
181: 		internal_opt_selvec.Initialize(&sel_vec);
182: 		initialized = true;
183: 	}
184: 
185: 	inline idx_t operator[](idx_t index) const {
186: 		D_ASSERT(index < size);
187: 		return sel_vec.get_index(index);
188: 	}
189: 	inline bool IndexMapsToLocation(idx_t idx, idx_t location) const {
190: 		return idx < count && sel_vec.get_index(idx) == location;
191: 	}
192: 	inline void Append(const idx_t idx) {
193: 		internal_opt_selvec.Append(count, idx);
194: 	}
195: 	inline idx_t Count() const {
196: 		return count;
197: 	}
198: 	inline idx_t Size() const {
199: 		return size;
200: 	}
201: 	inline const SelectionVector &Selection() const {
202: 		return sel_vec;
203: 	}
204: 	inline SelectionVector &Selection() {
205: 		return sel_vec;
206: 	}
207: 
208: private:
209: 	bool initialized = false;
210: 	idx_t count;
211: 	idx_t size;
212: 	SelectionVector sel_vec;
213: 	OptionalSelection internal_opt_selvec;
214: };
215: 
216: } // namespace duckdb
[end of src/include/duckdb/common/types/selection_vector.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: