{
  "repo": "duckdb/duckdb",
  "pull_number": 7424,
  "instance_id": "duckdb__duckdb-7424",
  "issue_numbers": [
    "6611",
    "6611"
  ],
  "base_commit": "c54a5ca25b722d4022a1968f55998936c0b15cc7",
  "patch": "diff --git a/src/core_functions/scalar/list/list_lambdas.cpp b/src/core_functions/scalar/list/list_lambdas.cpp\nindex 237cf91da661..0f34d43cecf5 100644\n--- a/src/core_functions/scalar/list/list_lambdas.cpp\n+++ b/src/core_functions/scalar/list/list_lambdas.cpp\n@@ -60,11 +60,15 @@ static void AppendFilteredToResult(Vector &lambda_vector, list_entry_t *result_e\n \n \tidx_t true_count = 0;\n \tSelectionVector true_sel(elem_cnt);\n-\tauto lambda_values = FlatVector::GetData<bool>(lambda_vector);\n-\tauto &lambda_validity = FlatVector::Validity(lambda_vector);\n+\tUnifiedVectorFormat lambda_data;\n+\tlambda_vector.ToUnifiedFormat(elem_cnt, lambda_data);\n+\n+\tauto lambda_values = (bool *)lambda_data.data;\n+\tauto &lambda_validity = lambda_data.validity;\n \n \t// compute the new lengths and offsets, and create a selection vector\n \tfor (idx_t i = 0; i < elem_cnt; i++) {\n+\t\tauto entry = lambda_data.sel->get_index(i);\n \n \t\twhile (appended_lists_cnt < lists_len.size() && lists_len[appended_lists_cnt] == 0) {\n \t\t\tresult_entries[appended_lists_cnt].offset = curr_list_offset;\n@@ -73,12 +77,11 @@ static void AppendFilteredToResult(Vector &lambda_vector, list_entry_t *result_e\n \t\t}\n \n \t\t// found a true value\n-\t\tif (lambda_validity.RowIsValid(i)) {\n-\t\t\tif (lambda_values[i] > 0) {\n-\t\t\t\ttrue_sel.set_index(true_count++, i);\n-\t\t\t\tcurr_list_len++;\n-\t\t\t}\n+\t\tif (lambda_validity.RowIsValid(entry) && lambda_values[entry] > 0) {\n+\t\t\ttrue_sel.set_index(true_count++, i);\n+\t\t\tcurr_list_len++;\n \t\t}\n+\n \t\tcurr_original_list_len++;\n \n \t\tif (lists_len[appended_lists_cnt] == curr_original_list_len) {\n",
  "test_patch": "diff --git a/test/sql/function/list/lambdas/filter.test b/test/sql/function/list/lambdas/filter.test\nindex 1f1c920feda9..da3da080e45e 100644\n--- a/test/sql/function/list/lambdas/filter.test\n+++ b/test/sql/function/list/lambdas/filter.test\n@@ -233,4 +233,9 @@ SELECT list_apply([[5,6]], x -> list_filter(x, y -> y));\n statement error\n SELECT list_transform([['abc']], x -> list_filter(x, y -> y));\n ----\n-Conversion Error: Could not convert string 'abc' to BOOL\n\\ No newline at end of file\n+Conversion Error: Could not convert string 'abc' to BOOL\n+\n+query II\n+select [[y] for y in range(5)] as c, [x for x in c if x IS NOT NULL];\n+----\n+[[0], [1], [2], [3], [4]]\t[[0], [1], [2], [3], [4]]\ndiff --git a/test/sql/function/list/lambdas/filter_vector_types.test b/test/sql/function/list/lambdas/filter_vector_types.test\nnew file mode 100644\nindex 000000000000..e711632d73de\n--- /dev/null\n+++ b/test/sql/function/list/lambdas/filter_vector_types.test\n@@ -0,0 +1,38 @@\n+# name: test/sql/function/list/lambdas/filter_vector_types.test\n+# description: Test list_filter function with 'test_vector_types'\n+# group: [lambdas]\n+\n+require vector_size 2048\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+select [x for x in c if x IS NOT NULL] FROM test_vector_types(NULL::INT[], false) t(c);\n+----\n+[-2147483648, 2147483647]\n+[]\n+[]\n+[-2147483648, 2147483647]\n+[-2147483648, 2147483647]\n+[-2147483648, 2147483647]\n+[]\n+[]\n+[3, 5]\n+[]\n+[7]\n+\n+query I\n+select [x for x in c if x IS NULL] FROM test_vector_types(NULL::INT[], false) t(c);\n+----\n+[]\n+[]\n+[NULL]\n+[]\n+[]\n+[]\n+[]\n+[NULL]\n+[]\n+[]\n+[]\n",
  "problem_statement": "LIST filter INTERNAL ERROR, related to VectorTypes\n### What happens?\r\n\r\nWhile testing some things for `map_extract`, I came across an internal exception caused by testing with `test_vector_types`\r\n\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nselect [x for x in c if x != NULL] FROM test_vector_types(NULL::INT[], false) t(c);\r\n```\r\n(simpler version)\r\n```sql\r\nselect [[y] for y in range(5)] as c, [x for x in c if x != NULL];\r\n```\r\n```\r\nError: INTERNAL Error: Assertion triggered in file \"/Users/thijs/DuckDBLabs/duckdb/src/include/duckdb/common/types/vector.hpp\" on line 302: vector.GetVectorType() == VectorType::FLAT_VECTOR\r\n```\r\n\r\n### OS:\r\n\r\nMacOS\r\n\r\n### DuckDB Version:\r\n\r\nmaster\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nThijs Bruineman\r\n\r\n### Affiliation:\r\n\r\nDuckDB Labs\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\nLIST filter INTERNAL ERROR, related to VectorTypes\n### What happens?\r\n\r\nWhile testing some things for `map_extract`, I came across an internal exception caused by testing with `test_vector_types`\r\n\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nselect [x for x in c if x != NULL] FROM test_vector_types(NULL::INT[], false) t(c);\r\n```\r\n(simpler version)\r\n```sql\r\nselect [[y] for y in range(5)] as c, [x for x in c if x != NULL];\r\n```\r\n```\r\nError: INTERNAL Error: Assertion triggered in file \"/Users/thijs/DuckDBLabs/duckdb/src/include/duckdb/common/types/vector.hpp\" on line 302: vector.GetVectorType() == VectorType::FLAT_VECTOR\r\n```\r\n\r\n### OS:\r\n\r\nMacOS\r\n\r\n### DuckDB Version:\r\n\r\nmaster\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Full Name:\r\n\r\nThijs Bruineman\r\n\r\n### Affiliation:\r\n\r\nDuckDB Labs\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "Related to UnifiedVectorFormat, but after fixing that, the behavior of this seems wrong as well:\r\n```c++\r\n\t\tif (lambda_validity.RowIsValid(entry) && lambda_values[entry] > 0) {\r\n\t\t\ttrue_sel.set_index(true_count++, entry);\r\n\t\t\tcurr_list_len++;\r\n\t\t}\r\n```\r\nIf the input is NULL, the resulting `lambda_validity.RowIsValid(entry)` is false - regardless if the input list contains NULL\nThink I found the cause, not sure where the fix is yet though\r\n```\r\n(lldb) p expr.ToString()\r\n(std::string) $10 = \"(x != CAST(#2 AS INTEGER))\"\r\n```\r\nIn this case `#2` is NULL, casting this to INTEGER results in CONSTANT NULL\r\nFeeding that to ComparisonOperators calls the binary executor:\r\n```c++\r\n\t\tif ((LEFT_CONSTANT && ConstantVector::IsNull(left)) || (RIGHT_CONSTANT && ConstantVector::IsNull(right))) {\r\n\t\t\t// either left or right is constant NULL: result is constant NULL\r\n\t\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\r\n\t\t\tConstantVector::SetNull(result, true);\r\n\t\t\treturn;\r\n\t\t}\r\n```\r\nWhich results in our `lambda_vector` being CONSTANT NULL as well\nI fixed the first issue, by using unified vector format:\r\n```patch\r\ndiff --git a/src/function/scalar/list/list_lambdas.cpp b/src/function/scalar/list/list_lambdas.cpp\r\nindex 11a741f1cc..3ed4212321 100644\r\n--- a/src/function/scalar/list/list_lambdas.cpp\r\n+++ b/src/function/scalar/list/list_lambdas.cpp\r\n@@ -59,11 +59,16 @@ static void AppendFilteredToResult(Vector &lambda_vector, list_entry_t *result_e\r\n \r\n \tidx_t true_count = 0;\r\n \tSelectionVector true_sel(elem_cnt);\r\n-\tauto lambda_values = FlatVector::GetData<bool>(lambda_vector);\r\n-\tauto &lambda_validity = FlatVector::Validity(lambda_vector);\r\n+\r\n+\tUnifiedVectorFormat lambda_data;\r\n+\tlambda_vector.ToUnifiedFormat(elem_cnt, lambda_data);\r\n+\r\n+\tauto lambda_values = (bool *)lambda_data.data;\r\n+\tauto &lambda_validity = lambda_data.validity;\r\n \r\n \t// compute the new lengths and offsets, and create a selection vector\r\n \tfor (idx_t i = 0; i < elem_cnt; i++) {\r\n+\t\tauto entry = lambda_data.sel->get_index(i);\r\n \r\n \t\twhile (appended_lists_cnt < lists_len.size() && lists_len[appended_lists_cnt] == 0) {\r\n \t\t\tresult_entries[appended_lists_cnt].offset = curr_list_offset;\r\n@@ -72,11 +77,11 @@ static void AppendFilteredToResult(Vector &lambda_vector, list_entry_t *result_e\r\n \t\t}\r\n \r\n \t\t// found a true value\r\n-\t\tif (lambda_validity.RowIsValid(i)) {\r\n-\t\t\tif (lambda_values[i] > 0) {\r\n-\t\t\t\ttrue_sel.set_index(true_count++, i);\r\n-\t\t\t\tcurr_list_len++;\r\n-\t\t\t}\r\n+\t\tif (lambda_validity.RowIsValid(entry) && lambda_values[entry] > 0) {\r\n+\t\t\t// FIXME: not sure if this should be 'i', or 'entry'\r\n+\t\t\t// I think this is correct, but needs verifying\r\n+\t\t\ttrue_sel.set_index(true_count++, i);\r\n+\t\t\tcurr_list_len++;\r\n \t\t}\r\n \t\tcurr_original_list_len++;\r\n \r\n```\nRelated to UnifiedVectorFormat, but after fixing that, the behavior of this seems wrong as well:\r\n```c++\r\n\t\tif (lambda_validity.RowIsValid(entry) && lambda_values[entry] > 0) {\r\n\t\t\ttrue_sel.set_index(true_count++, entry);\r\n\t\t\tcurr_list_len++;\r\n\t\t}\r\n```\r\nIf the input is NULL, the resulting `lambda_validity.RowIsValid(entry)` is false - regardless if the input list contains NULL\nThink I found the cause, not sure where the fix is yet though\r\n```\r\n(lldb) p expr.ToString()\r\n(std::string) $10 = \"(x != CAST(#2 AS INTEGER))\"\r\n```\r\nIn this case `#2` is NULL, casting this to INTEGER results in CONSTANT NULL\r\nFeeding that to ComparisonOperators calls the binary executor:\r\n```c++\r\n\t\tif ((LEFT_CONSTANT && ConstantVector::IsNull(left)) || (RIGHT_CONSTANT && ConstantVector::IsNull(right))) {\r\n\t\t\t// either left or right is constant NULL: result is constant NULL\r\n\t\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\r\n\t\t\tConstantVector::SetNull(result, true);\r\n\t\t\treturn;\r\n\t\t}\r\n```\r\nWhich results in our `lambda_vector` being CONSTANT NULL as well\nI fixed the first issue, by using unified vector format:\r\n```patch\r\ndiff --git a/src/function/scalar/list/list_lambdas.cpp b/src/function/scalar/list/list_lambdas.cpp\r\nindex 11a741f1cc..3ed4212321 100644\r\n--- a/src/function/scalar/list/list_lambdas.cpp\r\n+++ b/src/function/scalar/list/list_lambdas.cpp\r\n@@ -59,11 +59,16 @@ static void AppendFilteredToResult(Vector &lambda_vector, list_entry_t *result_e\r\n \r\n \tidx_t true_count = 0;\r\n \tSelectionVector true_sel(elem_cnt);\r\n-\tauto lambda_values = FlatVector::GetData<bool>(lambda_vector);\r\n-\tauto &lambda_validity = FlatVector::Validity(lambda_vector);\r\n+\r\n+\tUnifiedVectorFormat lambda_data;\r\n+\tlambda_vector.ToUnifiedFormat(elem_cnt, lambda_data);\r\n+\r\n+\tauto lambda_values = (bool *)lambda_data.data;\r\n+\tauto &lambda_validity = lambda_data.validity;\r\n \r\n \t// compute the new lengths and offsets, and create a selection vector\r\n \tfor (idx_t i = 0; i < elem_cnt; i++) {\r\n+\t\tauto entry = lambda_data.sel->get_index(i);\r\n \r\n \t\twhile (appended_lists_cnt < lists_len.size() && lists_len[appended_lists_cnt] == 0) {\r\n \t\t\tresult_entries[appended_lists_cnt].offset = curr_list_offset;\r\n@@ -72,11 +77,11 @@ static void AppendFilteredToResult(Vector &lambda_vector, list_entry_t *result_e\r\n \t\t}\r\n \r\n \t\t// found a true value\r\n-\t\tif (lambda_validity.RowIsValid(i)) {\r\n-\t\t\tif (lambda_values[i] > 0) {\r\n-\t\t\t\ttrue_sel.set_index(true_count++, i);\r\n-\t\t\t\tcurr_list_len++;\r\n-\t\t\t}\r\n+\t\tif (lambda_validity.RowIsValid(entry) && lambda_values[entry] > 0) {\r\n+\t\t\t// FIXME: not sure if this should be 'i', or 'entry'\r\n+\t\t\t// I think this is correct, but needs verifying\r\n+\t\t\ttrue_sel.set_index(true_count++, i);\r\n+\t\t\tcurr_list_len++;\r\n \t\t}\r\n \t\tcurr_original_list_len++;\r\n \r\n```",
  "created_at": "2023-05-09T13:35:54Z"
}