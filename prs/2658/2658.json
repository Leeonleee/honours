{
  "repo": "duckdb/duckdb",
  "pull_number": 2658,
  "instance_id": "duckdb__duckdb-2658",
  "issue_numbers": [
    "2507"
  ],
  "base_commit": "1e8295d66c249cc9dd7878f03827a9fc8d74de49",
  "patch": "diff --git a/.github/workflows/Cancel.yml b/.github/workflows/Cancel.yml\nindex d7bb734e18f4..383b0d6892c8 100644\n--- a/.github/workflows/Cancel.yml\n+++ b/.github/workflows/Cancel.yml\n@@ -1,7 +1,7 @@\n name: Cancel\n on:\n   workflow_run:\n-    workflows: [\"Main\"]\n+    workflows: [\"Main\", \"LinuxRelease\", \"NodeJS\", \"OSX\", \"Python\", \"R\", \"Windows\"]\n     types:\n       - requested\n jobs:\ndiff --git a/CMakeLists.txt b/CMakeLists.txt\nindex 9f5dcce84b58..9dd4d888c10f 100644\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -73,7 +73,7 @@ if(${FORCE_COLORED_OUTPUT})\n   endif()\n endif()\n \n-option( \"Enable address sanitizer.\" TRUE)\n+option(\"Enable address sanitizer.\" TRUE)\n \n set(M32_FLAG \"\")\n if(FORCE_32_BIT)\n@@ -297,7 +297,7 @@ if(NOT MSVC)\n   endif()\n else()\n   set(CMAKE_CXX_WINDOWS_FLAGS\n-      \"/wd4244 /wd4267 /wd4200 /wd26451 /wd26495 /D_CRT_SECURE_NO_WARNINGS\")\n+      \"/wd4244 /wd4267 /wd4200 /wd26451 /wd26495 /D_CRT_SECURE_NO_WARNINGS /utf-8\")\n   if(TREAT_WARNINGS_AS_ERRORS)\n     set(CMAKE_CXX_WINDOWS_FLAGS \"${CMAKE_CXX_WINDOWS_FLAGS} /WX\")\n   endif()\n@@ -305,7 +305,7 @@ else()\n   string(REGEX REPLACE \"/W[0-4]\" \"\" CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\")\n   # add to-be-ignored warnings\n   set(CMAKE_CXX_FLAGS\n-      \"${CMAKE_CXX_FLAGS} /wd4244 /wd4267 /wd4200 /wd26451 /wd26495 /D_CRT_SECURE_NO_WARNINGS\"\n+      \"${CMAKE_CXX_FLAGS} ${CMAKE_CXX_WINDOWS_FLAGS}\"\n   )\n endif()\n \ndiff --git \"a/data/csv/issue2628_\\344\\270\\255\\346\\226\\207.csv\" \"b/data/csv/issue2628_\\344\\270\\255\\346\\226\\207.csv\"\nnew file mode 100644\nindex 000000000000..91eaddc8e729\n--- /dev/null\n+++ \"b/data/csv/issue2628_\\344\\270\\255\\346\\226\\207.csv\"\n@@ -0,0 +1,4 @@\n+col1|col2\n+1|1\n+2|2\n+3|3\ndiff --git \"a/data/csv/\\344\\270\\255\\346\\226\\207/\\344\\270\\255.csv\" \"b/data/csv/\\344\\270\\255\\346\\226\\207/\\344\\270\\255.csv\"\nnew file mode 100644\nindex 000000000000..08781b975295\n--- /dev/null\n+++ \"b/data/csv/\\344\\270\\255\\346\\226\\207/\\344\\270\\255.csv\"\n@@ -0,0 +1,3 @@\n+col1|col2\n+1|1\n+2|2\n\\ No newline at end of file\ndiff --git \"a/data/csv/\\344\\270\\255\\346\\226\\207/\\346\\226\\207.csv\" \"b/data/csv/\\344\\270\\255\\346\\226\\207/\\346\\226\\207.csv\"\nnew file mode 100644\nindex 000000000000..5a2df27825f0\n--- /dev/null\n+++ \"b/data/csv/\\344\\270\\255\\346\\226\\207/\\346\\226\\207.csv\"\n@@ -0,0 +1,3 @@\n+col1|col2\n+3|3\n+4|4\n\\ No newline at end of file\ndiff --git a/src/common/CMakeLists.txt b/src/common/CMakeLists.txt\nindex ba2fdfb9dec3..efab485efa30 100644\n--- a/src/common/CMakeLists.txt\n+++ b/src/common/CMakeLists.txt\n@@ -33,7 +33,8 @@ add_library_unity(\n   symbols.cpp\n   tree_renderer.cpp\n   types.cpp\n-  virtual_file_system.cpp)\n+  virtual_file_system.cpp\n+  windows_util.cpp)\n set(ALL_OBJECT_FILES\n     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_common>\n     PARENT_SCOPE)\ndiff --git a/src/common/local_file_system.cpp b/src/common/local_file_system.cpp\nindex 500251b9b20a..592a3bd5f3ff 100644\n--- a/src/common/local_file_system.cpp\n+++ b/src/common/local_file_system.cpp\n@@ -20,6 +20,7 @@\n #include <sys/types.h>\n #include <unistd.h>\n #else\n+#include \"duckdb/common/windows_util.hpp\"\n #include <string>\n \n #ifdef __MINGW32__\n@@ -490,8 +491,9 @@ unique_ptr<FileHandle> LocalFileSystem::OpenFile(const string &path, uint8_t fla\n \tif (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {\n \t\tflags_and_attributes |= FILE_FLAG_NO_BUFFERING;\n \t}\n-\tHANDLE hFile =\n-\t    CreateFileA(path.c_str(), desired_access, share_mode, NULL, creation_disposition, flags_and_attributes, NULL);\n+\tauto unicode_path = WindowsUtil::UTF8ToUnicode(path.c_str());\n+\tHANDLE hFile = CreateFileW(unicode_path.c_str(), desired_access, share_mode, NULL, creation_disposition,\n+\t                           flags_and_attributes, NULL);\n \tif (hFile == INVALID_HANDLE_VALUE) {\n \t\tauto error = GetLastErrorAsString();\n \t\tthrow IOException(\"Cannot open file \\\"%s\\\": %s\", path.c_str(), error);\n@@ -641,13 +643,18 @@ void LocalFileSystem::Truncate(FileHandle &handle, int64_t new_size) {\n \t}\n }\n \n+static DWORD WindowsGetFileAttributes(const string &filename) {\n+\tauto unicode_path = WindowsUtil::UTF8ToUnicode(filename.c_str());\n+\treturn GetFileAttributesW(unicode_path.c_str());\n+}\n+\n bool LocalFileSystem::DirectoryExists(const string &directory) {\n-\tDWORD attrs = GetFileAttributesA(directory.c_str());\n+\tDWORD attrs = WindowsGetFileAttributes(directory);\n \treturn (attrs != INVALID_FILE_ATTRIBUTES && (attrs & FILE_ATTRIBUTE_DIRECTORY));\n }\n \n bool LocalFileSystem::FileExists(const string &filename) {\n-\tDWORD attrs = GetFileAttributesA(filename.c_str());\n+\tDWORD attrs = WindowsGetFileAttributes(filename);\n \treturn (attrs != INVALID_FILE_ATTRIBUTES && !(attrs & FILE_ATTRIBUTE_DIRECTORY));\n }\n \n@@ -655,79 +662,58 @@ void LocalFileSystem::CreateDirectory(const string &directory) {\n \tif (DirectoryExists(directory)) {\n \t\treturn;\n \t}\n-\tif (directory.empty() || !CreateDirectoryA(directory.c_str(), NULL) || !DirectoryExists(directory)) {\n+\tauto unicode_path = WindowsUtil::UTF8ToUnicode(directory.c_str());\n+\tif (directory.empty() || !CreateDirectoryW(unicode_path.c_str(), NULL) || !DirectoryExists(directory)) {\n \t\tthrow IOException(\"Could not create directory!\");\n \t}\n }\n \n-static void delete_dir_special_snowflake_windows(FileSystem &fs, string directory) {\n-\tif (directory.size() + 3 > MAX_PATH) {\n-\t\tthrow IOException(\"Pathname too long\");\n-\t}\n-\t// create search pattern\n-\tTCHAR szDir[MAX_PATH];\n-\tsnprintf(szDir, MAX_PATH, \"%s\\\\*\", directory.c_str());\n-\n-\tWIN32_FIND_DATA ffd;\n-\tHANDLE hFind = FindFirstFile(szDir, &ffd);\n-\tif (hFind == INVALID_HANDLE_VALUE) {\n-\t\treturn;\n-\t}\n-\n-\tdo {\n-\t\tif (string(ffd.cFileName) == \".\" || string(ffd.cFileName) == \"..\") {\n-\t\t\tcontinue;\n-\t\t}\n-\t\tif (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n-\t\t\t// recurse to zap directory contents\n-\t\t\tdelete_dir_special_snowflake_windows(fs, fs.JoinPath(directory, ffd.cFileName));\n+static void DeleteDirectoryRecursive(FileSystem &fs, string directory) {\n+\tfs.ListFiles(directory, [&](const string &fname, bool is_directory) {\n+\t\tif (is_directory) {\n+\t\t\tDeleteDirectoryRecursive(fs, fs.JoinPath(directory, fname));\n \t\t} else {\n-\t\t\tif (strlen(ffd.cFileName) + directory.size() + 1 > MAX_PATH) {\n-\t\t\t\tthrow IOException(\"Pathname too long\");\n-\t\t\t}\n-\t\t\t// create search pattern\n-\t\t\tTCHAR del_path[MAX_PATH];\n-\t\t\tsnprintf(del_path, MAX_PATH, \"%s\\\\%s\", directory.c_str(), ffd.cFileName);\n-\t\t\tif (!DeleteFileA(del_path)) {\n-\t\t\t\tthrow IOException(\"Failed to delete directory entry\");\n-\t\t\t}\n+\t\t\tfs.RemoveFile(fs.JoinPath(directory, fname));\n \t\t}\n-\t} while (FindNextFile(hFind, &ffd) != 0);\n-\n-\tDWORD dwError = GetLastError();\n-\tif (dwError != ERROR_NO_MORE_FILES) {\n-\t\tthrow IOException(\"Something went wrong\");\n-\t}\n-\tFindClose(hFind);\n-\n-\tif (!RemoveDirectoryA(directory.c_str())) {\n+\t});\n+\tauto unicode_path = WindowsUtil::UTF8ToUnicode(directory.c_str());\n+\tif (!RemoveDirectoryW(unicode_path.c_str())) {\n \t\tthrow IOException(\"Failed to delete directory\");\n \t}\n }\n \n void LocalFileSystem::RemoveDirectory(const string &directory) {\n-\tdelete_dir_special_snowflake_windows(*this, directory.c_str());\n+\tif (FileExists(directory)) {\n+\t\tthrow IOException(\"Attempting to delete directory \\\"%s\\\", but it is a file and not a directory!\", directory);\n+\t}\n+\tif (!DirectoryExists(directory)) {\n+\t\treturn;\n+\t}\n+\tDeleteDirectoryRecursive(*this, directory.c_str());\n }\n \n void LocalFileSystem::RemoveFile(const string &filename) {\n-\tDeleteFileA(filename.c_str());\n+\tauto unicode_path = WindowsUtil::UTF8ToUnicode(filename.c_str());\n+\tDeleteFileW(unicode_path.c_str());\n }\n \n bool LocalFileSystem::ListFiles(const string &directory, const std::function<void(string, bool)> &callback) {\n \tstring search_dir = JoinPath(directory, \"*\");\n \n-\tWIN32_FIND_DATA ffd;\n-\tHANDLE hFind = FindFirstFile(search_dir.c_str(), &ffd);\n+\tauto unicode_path = WindowsUtil::UTF8ToUnicode(search_dir.c_str());\n+\n+\tWIN32_FIND_DATAW ffd;\n+\tHANDLE hFind = FindFirstFileW(unicode_path.c_str(), &ffd);\n \tif (hFind == INVALID_HANDLE_VALUE) {\n \t\treturn false;\n \t}\n \tdo {\n-\t\tstring cFileName = string(ffd.cFileName);\n+\t\tstring cFileName = WindowsUtil::UnicodeToUTF8(ffd.cFileName);\n \t\tif (cFileName == \".\" || cFileName == \"..\") {\n \t\t\tcontinue;\n \t\t}\n \t\tcallback(cFileName, ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);\n-\t} while (FindNextFile(hFind, &ffd) != 0);\n+\t} while (FindNextFileW(hFind, &ffd) != 0);\n \n \tDWORD dwError = GetLastError();\n \tif (dwError != ERROR_NO_MORE_FILES) {\n@@ -747,7 +733,9 @@ void LocalFileSystem::FileSync(FileHandle &handle) {\n }\n \n void LocalFileSystem::MoveFile(const string &source, const string &target) {\n-\tif (!MoveFileA(source.c_str(), target.c_str())) {\n+\tauto source_unicode = WindowsUtil::UTF8ToUnicode(source.c_str());\n+\tauto target_unicode = WindowsUtil::UTF8ToUnicode(target.c_str());\n+\tif (!MoveFileW(source_unicode.c_str(), target_unicode.c_str())) {\n \t\tthrow IOException(\"Could not move file\");\n \t}\n }\n@@ -758,7 +746,7 @@ FileType LocalFileSystem::GetFileType(FileHandle &handle) {\n \tif (strncmp(path.c_str(), PIPE_PREFIX, strlen(PIPE_PREFIX)) == 0) {\n \t\treturn FileType::FILE_TYPE_FIFO;\n \t}\n-\tDWORD attrs = GetFileAttributesA(path.c_str());\n+\tDWORD attrs = WindowsGetFileAttributes(path.c_str());\n \tif (attrs != INVALID_FILE_ATTRIBUTES) {\n \t\tif (attrs & FILE_ATTRIBUTE_DIRECTORY) {\n \t\t\treturn FileType::FILE_TYPE_DIR;\ndiff --git a/src/common/printer.cpp b/src/common/printer.cpp\nindex fee64ce776ce..012e8983d086 100644\n--- a/src/common/printer.cpp\n+++ b/src/common/printer.cpp\n@@ -1,12 +1,28 @@\n #include \"duckdb/common/printer.hpp\"\n #include \"duckdb/common/progress_bar.hpp\"\n+#include \"duckdb/common/windows_util.hpp\"\n+#include \"duckdb/common/windows.hpp\"\n #include <stdio.h>\n \n+#ifndef DUCKDB_DISABLE_PRINT\n+#ifdef DUCKDB_WINDOWS\n+#include <io.h>\n+#endif\n+#endif\n+\n namespace duckdb {\n \n // LCOV_EXCL_START\n void Printer::Print(const string &str) {\n #ifndef DUCKDB_DISABLE_PRINT\n+#ifdef DUCKDB_WINDOWS\n+\tif (IsTerminal()) {\n+\t\t// print utf8 to terminal\n+\t\tauto unicode = WindowsUtil::UTF8ToMBCS(str.c_str());\n+\t\tfprintf(stderr, \"%s\\n\", unicode.c_str());\n+\t\treturn;\n+\t}\n+#endif\n \tfprintf(stderr, \"%s\\n\", str.c_str());\n #endif\n }\n@@ -27,6 +43,17 @@ void Printer::FinishProgressBarPrint(const char *pbstr, int pbwidth) {\n \tfflush(stdout);\n #endif\n }\n+\n+bool Printer::IsTerminal() {\n+#ifndef DUCKDB_DISABLE_PRINT\n+#ifdef DUCKDB_WINDOWS\n+\treturn GetFileType(stderr) == FILE_TYPE_CHAR;\n+#else\n+\tthrow InternalException(\"IsTerminal is only implemented for Windows\");\n+#endif\n+#endif\n+\treturn false;\n+}\n // LCOV_EXCL_STOP\n \n } // namespace duckdb\ndiff --git a/src/common/windows_util.cpp b/src/common/windows_util.cpp\nnew file mode 100644\nindex 000000000000..8855456f4482\n--- /dev/null\n+++ b/src/common/windows_util.cpp\n@@ -0,0 +1,53 @@\n+#include \"duckdb/common/windows_util.hpp\"\n+\n+namespace duckdb {\n+\n+#ifdef DUCKDB_WINDOWS\n+\n+std::wstring WindowsUtil::UTF8ToUnicode(const char *input) {\n+\tidx_t result_size;\n+\n+\tresult_size = MultiByteToWideChar(CP_UTF8, 0, input, -1, nullptr, 0);\n+\tif (result_size == 0) {\n+\t\tthrow IOException(\"Failure in MultiByteToWideChar\");\n+\t}\n+\tauto buffer = unique_ptr<wchar_t[]>(new wchar_t[result_size]);\n+\tresult_size = MultiByteToWideChar(CP_UTF8, 0, input, -1, buffer.get(), result_size);\n+\tif (result_size == 0) {\n+\t\tthrow IOException(\"Failure in MultiByteToWideChar\");\n+\t}\n+\treturn std::wstring(buffer.get(), result_size);\n+}\n+\n+static string WideCharToMultiByteWrapper(LPCWSTR input, uint32_t code_page) {\n+\tidx_t result_size;\n+\n+\tresult_size = WideCharToMultiByte(code_page, 0, input, -1, 0, 0, 0, 0);\n+\tif (result_size == 0) {\n+\t\tthrow IOException(\"Failure in WideCharToMultiByte\");\n+\t}\n+\tauto buffer = unique_ptr<char[]>(new char[result_size]);\n+\tresult_size = WideCharToMultiByte(code_page, 0, input, -1, buffer.get(), result_size, 0, 0);\n+\tif (result_size == 0) {\n+\t\tthrow IOException(\"Failure in WideCharToMultiByte\");\n+\t}\n+\treturn string(buffer.get(), result_size - 1);\n+}\n+\n+string WindowsUtil::UnicodeToUTF8(LPCWSTR input) {\n+\treturn WideCharToMultiByteWrapper(input, CP_UTF8);\n+}\n+\n+static string WindowsUnicodeToMBCS(LPCWSTR unicode_text, int use_ansi) {\n+\tuint32_t code_page = use_ansi ? CP_ACP : CP_OEMCP;\n+\treturn WideCharToMultiByteWrapper(unicode_text, code_page);\n+}\n+\n+string WindowsUtil::UTF8ToMBCS(const char *input, bool use_ansi) {\n+\tauto unicode = WindowsUtil::UTF8ToUnicode(input);\n+\treturn WindowsUnicodeToMBCS(unicode.c_str(), use_ansi);\n+}\n+\n+#endif\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/common/helper.hpp b/src/include/duckdb/common/helper.hpp\nindex 2fa2305a7719..a8dd308b2399 100644\n--- a/src/include/duckdb/common/helper.hpp\n+++ b/src/include/duckdb/common/helper.hpp\n@@ -15,6 +15,12 @@\n #define suint64_t int64_t\n #endif\n \n+#if defined(_WIN32) || defined(_WIN64)\n+#define DUCKDB_WINDOWS\n+#elif defined(__unix__) || defined(__unix) || (defined(__APPLE__) && defined(__MACH__))\n+#define DUCKDB_POSIX\n+#endif\n+\n namespace duckdb {\n #if !defined(_MSC_VER) && (__cplusplus < 201402L)\n template <typename T, typename... Args>\ndiff --git a/src/include/duckdb/common/printer.hpp b/src/include/duckdb/common/printer.hpp\nindex 495cb958adf8..7f6e3673108c 100644\n--- a/src/include/duckdb/common/printer.hpp\n+++ b/src/include/duckdb/common/printer.hpp\n@@ -21,5 +21,7 @@ class Printer {\n \tstatic void PrintProgress(int percentage, const char *pbstr, int pbwidth);\n \t//! Prints an empty line when progress bar is done\n \tstatic void FinishProgressBarPrint(const char *pbstr, int pbwidth);\n+\t//! Whether or not we are printing to a terminal\n+\tstatic bool IsTerminal();\n };\n } // namespace duckdb\ndiff --git a/src/include/duckdb/common/tree_renderer.hpp b/src/include/duckdb/common/tree_renderer.hpp\nindex e8cee4b3ac2c..d97910add787 100644\n--- a/src/include/duckdb/common/tree_renderer.hpp\n+++ b/src/include/duckdb/common/tree_renderer.hpp\n@@ -56,19 +56,19 @@ struct TreeRendererConfig {\n \tbool detailed = false;\n \n #ifndef DUCKDB_ASCII_TREE_RENDERER\n-\tconst char *LTCORNER = \"\u250c\";\n-\tconst char *RTCORNER = \"\u2510\";\n-\tconst char *LDCORNER = \"\u2514\";\n-\tconst char *RDCORNER = \"\u2518\";\n-\n-\tconst char *MIDDLE = \"\u253c\";\n-\tconst char *TMIDDLE = \"\u252c\";\n-\tconst char *LMIDDLE = \"\u251c\";\n-\tconst char *RMIDDLE = \"\u2524\";\n-\tconst char *DMIDDLE = \"\u2534\";\n-\n-\tconst char *VERTICAL = \"\u2502\";\n-\tconst char *HORIZONTAL = \"\u2500\";\n+\tconst char *LTCORNER = \"\\342\\224\\214\"; // \"\u250c\";\n+\tconst char *RTCORNER = \"\\342\\224\\220\"; // \"\u2510\";\n+\tconst char *LDCORNER = \"\\342\\224\\224\"; // \"\u2514\";\n+\tconst char *RDCORNER = \"\\342\\224\\230\"; // \"\u2518\";\n+\n+\tconst char *MIDDLE = \"\\342\\224\\274\";  // \"\u253c\";\n+\tconst char *TMIDDLE = \"\\342\\224\\254\"; // \"\u252c\";\n+\tconst char *LMIDDLE = \"\\342\\224\\234\"; // \"\u251c\";\n+\tconst char *RMIDDLE = \"\\342\\224\\244\"; // \"\u2524\";\n+\tconst char *DMIDDLE = \"\\342\\224\\264\"; // \"\u2534\";\n+\n+\tconst char *VERTICAL = \"\\342\\224\\202\";   // \"\u2502\";\n+\tconst char *HORIZONTAL = \"\\342\\224\\200\"; // \"\u2500\";\n #else\n \t// ASCII version\n \tconst char *LTCORNER = \"<\";\ndiff --git a/src/include/duckdb/common/windows_util.hpp b/src/include/duckdb/common/windows_util.hpp\nnew file mode 100644\nindex 000000000000..18a02d0972ad\n--- /dev/null\n+++ b/src/include/duckdb/common/windows_util.hpp\n@@ -0,0 +1,29 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/windows_util.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/common.hpp\"\n+#include \"duckdb/common/constants.hpp\"\n+#include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/vector.hpp\"\n+#include \"duckdb/common/windows.hpp\"\n+\n+namespace duckdb {\n+\n+#ifdef DUCKDB_WINDOWS\n+class WindowsUtil {\n+public:\n+\t//! Windows helper functions\n+\tstatic std::wstring UTF8ToUnicode(const char *input);\n+\tstatic string UnicodeToUTF8(LPCWSTR input);\n+\tstatic string UTF8ToMBCS(const char *input, bool use_ansi = false);\n+};\n+#endif\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/planner/logical_operator.hpp b/src/include/duckdb/planner/logical_operator.hpp\nindex 9f1e33f13d9a..5b8f5cc0a457 100644\n--- a/src/include/duckdb/planner/logical_operator.hpp\n+++ b/src/include/duckdb/planner/logical_operator.hpp\n@@ -56,7 +56,7 @@ class LogicalOperator {\n \n \tvirtual string GetName() const;\n \tvirtual string ParamsToString() const;\n-\tvirtual string ToString(idx_t depth = 0) const;\n+\tvirtual string ToString() const;\n \tvoid Print();\n \t//! Debug method: verify that the integrity of expressions & child nodes are maintained\n \tvirtual void Verify();\ndiff --git a/src/planner/logical_operator.cpp b/src/planner/logical_operator.cpp\nindex 1fda6b975b04..27d38003c3d5 100644\n--- a/src/planner/logical_operator.cpp\n+++ b/src/planner/logical_operator.cpp\n@@ -71,7 +71,7 @@ vector<ColumnBinding> LogicalOperator::MapBindings(const vector<ColumnBinding> &\n \t}\n }\n \n-string LogicalOperator::ToString(idx_t depth) const {\n+string LogicalOperator::ToString() const {\n \tTreeRenderer renderer;\n \treturn renderer.ToString(*this);\n }\ndiff --git a/third_party/libpg_query/src_backend_parser_scan.cpp b/third_party/libpg_query/src_backend_parser_scan.cpp\nindex 6a92b35c295d..879222335ccb 100644\n--- a/third_party/libpg_query/src_backend_parser_scan.cpp\n+++ b/third_party/libpg_query/src_backend_parser_scan.cpp\n@@ -309,7 +309,7 @@ namespace duckdb_libpgquery {\n #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n \n /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,\n- * if you want the limit (max/min) macros for int types. \n+ * if you want the limit (max/min) macros for int types.\n  */\n #ifndef __STDC_LIMIT_MACROS\n #define __STDC_LIMIT_MACROS 1\n@@ -327,7 +327,7 @@ typedef uint64_t flex_uint64_t;\n typedef signed char flex_int8_t;\n typedef short int flex_int16_t;\n typedef int flex_int32_t;\n-typedef unsigned char flex_uint8_t; \n+typedef unsigned char flex_uint8_t;\n typedef unsigned short int flex_uint16_t;\n typedef unsigned int flex_uint32_t;\n \n@@ -451,10 +451,10 @@ typedef size_t yy_size_t;\n #define EOB_ACT_CONTINUE_SCAN 0\n #define EOB_ACT_END_OF_FILE 1\n #define EOB_ACT_LAST_MATCH 2\n-    \n+\n     #define YY_LESS_LINENO(n)\n     #define YY_LINENO_REWIND_TO(ptr)\n-    \n+\n /* Return all but the first \"n\" matched characters back to the input stream. */\n #define yyless(n) \\\n \tdo \\\n@@ -1364,9 +1364,9 @@ static int yy_init_globals ( yyscan_t yyscanner );\n     /* This must go here because YYSTYPE and YYLTYPE are included\n      * from bison output in section 1.*/\n     #    define yylval yyg->yylval_r\n-    \n+\n     #    define yylloc yyg->yylloc_r\n-    \n+\n int yylex_init (yyscan_t* scanner);\n \n int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);\n@@ -1409,9 +1409,9 @@ YYSTYPE * yyget_lval ( yyscan_t yyscanner );\n void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );\n \n        YYLTYPE *yyget_lloc ( yyscan_t yyscanner );\n-    \n+\n         void yyset_lloc ( YYLTYPE * yylloc_param , yyscan_t yyscanner );\n-    \n+\n /* Macros after this point can all be overridden by user definitions in\n  * section 1.\n  */\n@@ -1425,7 +1425,7 @@ extern int yywrap ( yyscan_t yyscanner );\n #endif\n \n #ifndef YY_NO_UNPUT\n-    \n+\n #endif\n \n #ifndef yytext_ptr\n@@ -3123,7 +3123,7 @@ static void yy_load_buffer_state  (yyscan_t yyscanner)\n     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)\n {\n \tYY_BUFFER_STATE b;\n-    \n+\n \tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );\n \tif ( ! b )\n \t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n@@ -3189,7 +3189,7 @@ static void yy_load_buffer_state  (yyscan_t yyscanner)\n     }\n \n         b->yy_is_interactive = 0;\n-    \n+\n \terrno = oerrno;\n }\n \n@@ -3331,7 +3331,7 @@ static void yyensure_buffer_stack (yyscan_t yyscanner)\n YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n {\n \tYY_BUFFER_STATE b;\n-    \n+\n \tif ( size < 2 ||\n \t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n \t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n@@ -3367,7 +3367,7 @@ YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscann\n  */\n YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)\n {\n-    \n+\n \treturn yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);\n }\n \n@@ -3384,7 +3384,7 @@ YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, yy_size_t  _yybytes_len ,\n \tchar *buf;\n \tyy_size_t n;\n \tyy_size_t i;\n-    \n+\n \t/* Get memory for full buffer, including space for trailing EOB's. */\n \tn = (yy_size_t) (_yybytes_len + 2);\n \tbuf = (char *) yyalloc( n , yyscanner );\n@@ -3416,7 +3416,6 @@ static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)\n {\n \tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \t(void)yyg;\n-\tfprintf( stderr, \"%s\\n\", msg );\n \tthrow std::runtime_error(msg); // YY_EXIT_FAILURE );\n }\n \n@@ -3457,7 +3456,7 @@ int yyget_lineno  (yyscan_t yyscanner)\n \n         if (! YY_CURRENT_BUFFER)\n             return 0;\n-    \n+\n     return yylineno;\n }\n \n@@ -3470,7 +3469,7 @@ int yyget_column  (yyscan_t yyscanner)\n \n         if (! YY_CURRENT_BUFFER)\n             return 0;\n-    \n+\n     return yycolumn;\n }\n \n@@ -3532,7 +3531,7 @@ void yyset_lineno (int  _line_number , yyscan_t yyscanner)\n         /* lineno is only valid if an input buffer exists. */\n         if (! YY_CURRENT_BUFFER )\n            YY_FATAL_ERROR( \"yyset_lineno called with no buffer\" );\n-    \n+\n     yylineno = _line_number;\n }\n \n@@ -3547,7 +3546,7 @@ void yyset_column (int  _column_no , yyscan_t yyscanner)\n         /* column is only valid if an input buffer exists. */\n         if (! YY_CURRENT_BUFFER )\n            YY_FATAL_ERROR( \"yyset_column called with no buffer\" );\n-    \n+\n     yycolumn = _column_no;\n }\n \n@@ -3600,13 +3599,13 @@ YYLTYPE *yyget_lloc  (yyscan_t yyscanner)\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     return yylloc;\n }\n-    \n+\n void yyset_lloc (YYLTYPE *  yylloc_param , yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n     yylloc = yylloc_param;\n }\n-    \n+\n /* User-visible API */\n \n /* yylex_init is special because it creates the scanner itself, so it is\n@@ -3686,13 +3685,8 @@ static int yy_init_globals (yyscan_t yyscanner)\n     yyg->yy_start_stack =  NULL;\n \n /* Defined in main.c */\n-#ifdef YY_STDINIT\n-    yyin = stdin;\n-    yyout = stdout;\n-#else\n     yyin = NULL;\n     yyout = NULL;\n-#endif\n \n     /* For future reference: Set errno on error, since we are called by\n      * yylex_init()\ndiff --git a/tools/shell/shell.c b/tools/shell/shell.c\nindex 5379979ce95a..313d51af829e 100644\n--- a/tools/shell/shell.c\n+++ b/tools/shell/shell.c\n@@ -11607,19 +11607,19 @@ static int shell_callback(\n       if (nArg != 2) {\n         break;\n       }\n-      fputs(\"\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\", p->out);\n-      fputs(\"\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\\n\", p->out);\n+      utf8_printf(p->out, \"\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\");\n+      utf8_printf(p->out, \"\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\\n\");\n       if (strcmp(azArg[0], \"logical_plan\") == 0) {\n-      fputs(\"\u2502\u2502 Unoptimized Logical Plan  \u2502\u2502\\n\", p->out);\n+      utf8_printf(p->out, \"\u2502\u2502 Unoptimized Logical Plan  \u2502\u2502\\n\");\n       } else if (strcmp(azArg[0], \"logical_opt\") == 0) {\n-      fputs(\"\u2502\u2502  Optimized Logical Plan   \u2502\u2502\\n\", p->out);\n+      utf8_printf(p->out, \"\u2502\u2502  Optimized Logical Plan   \u2502\u2502\\n\");\n       } else if (strcmp(azArg[0], \"physical_plan\") == 0) {\n-      fputs(\"\u2502\u2502       Physical Plan       \u2502\u2502\\n\", p->out);\n+      utf8_printf(p->out, \"\u2502\u2502       Physical Plan       \u2502\u2502\\n\");\n \n       }\n-      fputs(\"\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\\n\", p->out);\n-      fputs(\"\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\", p->out);\n-      fputs(azArg[1], p->out);\n+      utf8_printf(p->out, \"\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\\n\");\n+      utf8_printf(p->out, \"\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\");\n+      utf8_printf(p->out, \"%s\", azArg[1]);\n       break;\n     }\n     case MODE_Semi: {   /* .schema and .fullschema output */\n",
  "test_patch": "diff --git a/test/sql/copy/csv/unicode_filename.test b/test/sql/copy/csv/unicode_filename.test\nnew file mode 100644\nindex 000000000000..a2df68173d9e\n--- /dev/null\n+++ b/test/sql/copy/csv/unicode_filename.test\n@@ -0,0 +1,38 @@\n+# name: test/sql/copy/csv/unicode_filename.test\n+# description: Issue #2628: CSV with Chinese name cannot copy into DuckDB in Windows\n+# group: [csv]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query II\n+SELECT * FROM 'data/csv/issue2628_\u4e2d\u6587.csv'\n+----\n+1\t1\n+2\t2\n+3\t3\n+\n+# unicode glob\n+query II\n+SELECT * FROM 'data/csv/*\u4e2d\u6587.csv'\n+----\n+1\t1\n+2\t2\n+3\t3\n+\n+# unicode directory\n+query II\n+SELECT * FROM 'data/csv/\u4e2d\u6587/*.csv' ORDER BY 1\n+----\n+1\t1\n+2\t2\n+3\t3\n+4\t4\n+\n+query II\n+SELECT * FROM 'data/csv/\u4e2d*/*.csv' ORDER BY 1\n+----\n+1\t1\n+2\t2\n+3\t3\n+4\t4\n\\ No newline at end of file\ndiff --git a/test/sql/storage/unicode_filename.test b/test/sql/storage/unicode_filename.test\nnew file mode 100644\nindex 000000000000..67fe51cdb9fa\n--- /dev/null\n+++ b/test/sql/storage/unicode_filename.test\n@@ -0,0 +1,104 @@\n+# name: test/sql/storage/unicode_filename.test\n+# description: Test storage with a unicode filename\n+# group: [storage]\n+\n+# load the DB from disk\n+load __TEST_DIR__/\u4e2d\u6587.db\n+\n+# create a database and insert values\n+statement ok\n+CREATE TABLE test (a INTEGER, b INTEGER);\n+\n+statement ok\n+INSERT INTO test VALUES (11, 22), (13, 22), (12, 21), (NULL, NULL)\n+\n+statement ok\n+CREATE TABLE test2 (a INTEGER);\n+\n+statement ok\n+INSERT INTO test2 VALUES (13), (12), (11)\n+\n+query II\n+SELECT * FROM test ORDER BY a\n+----\n+NULL\tNULL\n+11\t22\n+12\t21\n+13\t22\n+\n+query I\n+SELECT * FROM test2 ORDER BY a\n+----\n+11\n+12\n+13\n+\n+loop i 0 10\n+\n+statement ok\n+CHECKPOINT;\n+\n+query II\n+SELECT * FROM test ORDER BY a\n+----\n+NULL\tNULL\n+11\t22\n+12\t21\n+13\t22\n+\n+query I\n+SELECT * FROM test2 ORDER BY a\n+----\n+11\n+12\n+13\n+\n+endloop\n+\n+# verify that the tables are still there after a restart\n+restart\n+\n+query II\n+SELECT * FROM test ORDER BY a\n+----\n+NULL\tNULL\n+11\t22\n+12\t21\n+13\t22\n+\n+query I\n+SELECT * FROM test2 ORDER BY a\n+----\n+11\n+12\n+13\n+\n+# append a row\n+statement ok\n+INSERT INTO test VALUES (14, 23)\n+\n+query II\n+SELECT * FROM test ORDER BY a\n+----\n+NULL\tNULL\n+11\t22\n+12\t21\n+13\t22\n+14\t23\n+\n+restart\n+\n+query II\n+SELECT * FROM test ORDER BY a\n+----\n+NULL\tNULL\n+11\t22\n+12\t21\n+13\t22\n+14\t23\n+\n+statement ok\n+DROP TABLE test\n+\n+statement ok\n+DROP TABLE test2\n",
  "problem_statement": "how to show explain query results in ascii mode?\n#### What happens?\r\n\r\nwhen explain a sql.  \r\nit printed a big table with strange characters. \r\n\r\n\r\n#### Environment (please complete the following information):\r\n - OS: windows 7 Chinese version. \r\n - DuckDB Version: 0.30\r\n - DuckDB Client: CLI\r\n\r\n#### Before Submitting\r\n\r\n- [ ] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [ ] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "",
  "created_at": "2021-11-23T14:00:41Z"
}