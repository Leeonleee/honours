diff --git a/.github/workflows/Cancel.yml b/.github/workflows/Cancel.yml
index d7bb734e18f4..383b0d6892c8 100644
--- a/.github/workflows/Cancel.yml
+++ b/.github/workflows/Cancel.yml
@@ -1,7 +1,7 @@
 name: Cancel
 on:
   workflow_run:
-    workflows: ["Main"]
+    workflows: ["Main", "LinuxRelease", "NodeJS", "OSX", "Python", "R", "Windows"]
     types:
       - requested
 jobs:
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 9f5dcce84b58..9dd4d888c10f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -73,7 +73,7 @@ if(${FORCE_COLORED_OUTPUT})
   endif()
 endif()
 
-option( "Enable address sanitizer." TRUE)
+option("Enable address sanitizer." TRUE)
 
 set(M32_FLAG "")
 if(FORCE_32_BIT)
@@ -297,7 +297,7 @@ if(NOT MSVC)
   endif()
 else()
   set(CMAKE_CXX_WINDOWS_FLAGS
-      "/wd4244 /wd4267 /wd4200 /wd26451 /wd26495 /D_CRT_SECURE_NO_WARNINGS")
+      "/wd4244 /wd4267 /wd4200 /wd26451 /wd26495 /D_CRT_SECURE_NO_WARNINGS /utf-8")
   if(TREAT_WARNINGS_AS_ERRORS)
     set(CMAKE_CXX_WINDOWS_FLAGS "${CMAKE_CXX_WINDOWS_FLAGS} /WX")
   endif()
@@ -305,7 +305,7 @@ else()
   string(REGEX REPLACE "/W[0-4]" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
   # add to-be-ignored warnings
   set(CMAKE_CXX_FLAGS
-      "${CMAKE_CXX_FLAGS} /wd4244 /wd4267 /wd4200 /wd26451 /wd26495 /D_CRT_SECURE_NO_WARNINGS"
+      "${CMAKE_CXX_FLAGS} ${CMAKE_CXX_WINDOWS_FLAGS}"
   )
 endif()
 
diff --git "a/data/csv/issue2628_\344\270\255\346\226\207.csv" "b/data/csv/issue2628_\344\270\255\346\226\207.csv"
new file mode 100644
index 000000000000..91eaddc8e729
--- /dev/null
+++ "b/data/csv/issue2628_\344\270\255\346\226\207.csv"
@@ -0,0 +1,4 @@
+col1|col2
+1|1
+2|2
+3|3
diff --git "a/data/csv/\344\270\255\346\226\207/\344\270\255.csv" "b/data/csv/\344\270\255\346\226\207/\344\270\255.csv"
new file mode 100644
index 000000000000..08781b975295
--- /dev/null
+++ "b/data/csv/\344\270\255\346\226\207/\344\270\255.csv"
@@ -0,0 +1,3 @@
+col1|col2
+1|1
+2|2
\ No newline at end of file
diff --git "a/data/csv/\344\270\255\346\226\207/\346\226\207.csv" "b/data/csv/\344\270\255\346\226\207/\346\226\207.csv"
new file mode 100644
index 000000000000..5a2df27825f0
--- /dev/null
+++ "b/data/csv/\344\270\255\346\226\207/\346\226\207.csv"
@@ -0,0 +1,3 @@
+col1|col2
+3|3
+4|4
\ No newline at end of file
diff --git a/src/common/CMakeLists.txt b/src/common/CMakeLists.txt
index ba2fdfb9dec3..efab485efa30 100644
--- a/src/common/CMakeLists.txt
+++ b/src/common/CMakeLists.txt
@@ -33,7 +33,8 @@ add_library_unity(
   symbols.cpp
   tree_renderer.cpp
   types.cpp
-  virtual_file_system.cpp)
+  virtual_file_system.cpp
+  windows_util.cpp)
 set(ALL_OBJECT_FILES
     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_common>
     PARENT_SCOPE)
diff --git a/src/common/local_file_system.cpp b/src/common/local_file_system.cpp
index 500251b9b20a..592a3bd5f3ff 100644
--- a/src/common/local_file_system.cpp
+++ b/src/common/local_file_system.cpp
@@ -20,6 +20,7 @@
 #include <sys/types.h>
 #include <unistd.h>
 #else
+#include "duckdb/common/windows_util.hpp"
 #include <string>
 
 #ifdef __MINGW32__
@@ -490,8 +491,9 @@ unique_ptr<FileHandle> LocalFileSystem::OpenFile(const string &path, uint8_t fla
 	if (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {
 		flags_and_attributes |= FILE_FLAG_NO_BUFFERING;
 	}
-	HANDLE hFile =
-	    CreateFileA(path.c_str(), desired_access, share_mode, NULL, creation_disposition, flags_and_attributes, NULL);
+	auto unicode_path = WindowsUtil::UTF8ToUnicode(path.c_str());
+	HANDLE hFile = CreateFileW(unicode_path.c_str(), desired_access, share_mode, NULL, creation_disposition,
+	                           flags_and_attributes, NULL);
 	if (hFile == INVALID_HANDLE_VALUE) {
 		auto error = GetLastErrorAsString();
 		throw IOException("Cannot open file \"%s\": %s", path.c_str(), error);
@@ -641,13 +643,18 @@ void LocalFileSystem::Truncate(FileHandle &handle, int64_t new_size) {
 	}
 }
 
+static DWORD WindowsGetFileAttributes(const string &filename) {
+	auto unicode_path = WindowsUtil::UTF8ToUnicode(filename.c_str());
+	return GetFileAttributesW(unicode_path.c_str());
+}
+
 bool LocalFileSystem::DirectoryExists(const string &directory) {
-	DWORD attrs = GetFileAttributesA(directory.c_str());
+	DWORD attrs = WindowsGetFileAttributes(directory);
 	return (attrs != INVALID_FILE_ATTRIBUTES && (attrs & FILE_ATTRIBUTE_DIRECTORY));
 }
 
 bool LocalFileSystem::FileExists(const string &filename) {
-	DWORD attrs = GetFileAttributesA(filename.c_str());
+	DWORD attrs = WindowsGetFileAttributes(filename);
 	return (attrs != INVALID_FILE_ATTRIBUTES && !(attrs & FILE_ATTRIBUTE_DIRECTORY));
 }
 
@@ -655,79 +662,58 @@ void LocalFileSystem::CreateDirectory(const string &directory) {
 	if (DirectoryExists(directory)) {
 		return;
 	}
-	if (directory.empty() || !CreateDirectoryA(directory.c_str(), NULL) || !DirectoryExists(directory)) {
+	auto unicode_path = WindowsUtil::UTF8ToUnicode(directory.c_str());
+	if (directory.empty() || !CreateDirectoryW(unicode_path.c_str(), NULL) || !DirectoryExists(directory)) {
 		throw IOException("Could not create directory!");
 	}
 }
 
-static void delete_dir_special_snowflake_windows(FileSystem &fs, string directory) {
-	if (directory.size() + 3 > MAX_PATH) {
-		throw IOException("Pathname too long");
-	}
-	// create search pattern
-	TCHAR szDir[MAX_PATH];
-	snprintf(szDir, MAX_PATH, "%s\\*", directory.c_str());
-
-	WIN32_FIND_DATA ffd;
-	HANDLE hFind = FindFirstFile(szDir, &ffd);
-	if (hFind == INVALID_HANDLE_VALUE) {
-		return;
-	}
-
-	do {
-		if (string(ffd.cFileName) == "." || string(ffd.cFileName) == "..") {
-			continue;
-		}
-		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
-			// recurse to zap directory contents
-			delete_dir_special_snowflake_windows(fs, fs.JoinPath(directory, ffd.cFileName));
+static void DeleteDirectoryRecursive(FileSystem &fs, string directory) {
+	fs.ListFiles(directory, [&](const string &fname, bool is_directory) {
+		if (is_directory) {
+			DeleteDirectoryRecursive(fs, fs.JoinPath(directory, fname));
 		} else {
-			if (strlen(ffd.cFileName) + directory.size() + 1 > MAX_PATH) {
-				throw IOException("Pathname too long");
-			}
-			// create search pattern
-			TCHAR del_path[MAX_PATH];
-			snprintf(del_path, MAX_PATH, "%s\\%s", directory.c_str(), ffd.cFileName);
-			if (!DeleteFileA(del_path)) {
-				throw IOException("Failed to delete directory entry");
-			}
+			fs.RemoveFile(fs.JoinPath(directory, fname));
 		}
-	} while (FindNextFile(hFind, &ffd) != 0);
-
-	DWORD dwError = GetLastError();
-	if (dwError != ERROR_NO_MORE_FILES) {
-		throw IOException("Something went wrong");
-	}
-	FindClose(hFind);
-
-	if (!RemoveDirectoryA(directory.c_str())) {
+	});
+	auto unicode_path = WindowsUtil::UTF8ToUnicode(directory.c_str());
+	if (!RemoveDirectoryW(unicode_path.c_str())) {
 		throw IOException("Failed to delete directory");
 	}
 }
 
 void LocalFileSystem::RemoveDirectory(const string &directory) {
-	delete_dir_special_snowflake_windows(*this, directory.c_str());
+	if (FileExists(directory)) {
+		throw IOException("Attempting to delete directory \"%s\", but it is a file and not a directory!", directory);
+	}
+	if (!DirectoryExists(directory)) {
+		return;
+	}
+	DeleteDirectoryRecursive(*this, directory.c_str());
 }
 
 void LocalFileSystem::RemoveFile(const string &filename) {
-	DeleteFileA(filename.c_str());
+	auto unicode_path = WindowsUtil::UTF8ToUnicode(filename.c_str());
+	DeleteFileW(unicode_path.c_str());
 }
 
 bool LocalFileSystem::ListFiles(const string &directory, const std::function<void(string, bool)> &callback) {
 	string search_dir = JoinPath(directory, "*");
 
-	WIN32_FIND_DATA ffd;
-	HANDLE hFind = FindFirstFile(search_dir.c_str(), &ffd);
+	auto unicode_path = WindowsUtil::UTF8ToUnicode(search_dir.c_str());
+
+	WIN32_FIND_DATAW ffd;
+	HANDLE hFind = FindFirstFileW(unicode_path.c_str(), &ffd);
 	if (hFind == INVALID_HANDLE_VALUE) {
 		return false;
 	}
 	do {
-		string cFileName = string(ffd.cFileName);
+		string cFileName = WindowsUtil::UnicodeToUTF8(ffd.cFileName);
 		if (cFileName == "." || cFileName == "..") {
 			continue;
 		}
 		callback(cFileName, ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
-	} while (FindNextFile(hFind, &ffd) != 0);
+	} while (FindNextFileW(hFind, &ffd) != 0);
 
 	DWORD dwError = GetLastError();
 	if (dwError != ERROR_NO_MORE_FILES) {
@@ -747,7 +733,9 @@ void LocalFileSystem::FileSync(FileHandle &handle) {
 }
 
 void LocalFileSystem::MoveFile(const string &source, const string &target) {
-	if (!MoveFileA(source.c_str(), target.c_str())) {
+	auto source_unicode = WindowsUtil::UTF8ToUnicode(source.c_str());
+	auto target_unicode = WindowsUtil::UTF8ToUnicode(target.c_str());
+	if (!MoveFileW(source_unicode.c_str(), target_unicode.c_str())) {
 		throw IOException("Could not move file");
 	}
 }
@@ -758,7 +746,7 @@ FileType LocalFileSystem::GetFileType(FileHandle &handle) {
 	if (strncmp(path.c_str(), PIPE_PREFIX, strlen(PIPE_PREFIX)) == 0) {
 		return FileType::FILE_TYPE_FIFO;
 	}
-	DWORD attrs = GetFileAttributesA(path.c_str());
+	DWORD attrs = WindowsGetFileAttributes(path.c_str());
 	if (attrs != INVALID_FILE_ATTRIBUTES) {
 		if (attrs & FILE_ATTRIBUTE_DIRECTORY) {
 			return FileType::FILE_TYPE_DIR;
diff --git a/src/common/printer.cpp b/src/common/printer.cpp
index fee64ce776ce..012e8983d086 100644
--- a/src/common/printer.cpp
+++ b/src/common/printer.cpp
@@ -1,12 +1,28 @@
 #include "duckdb/common/printer.hpp"
 #include "duckdb/common/progress_bar.hpp"
+#include "duckdb/common/windows_util.hpp"
+#include "duckdb/common/windows.hpp"
 #include <stdio.h>
 
+#ifndef DUCKDB_DISABLE_PRINT
+#ifdef DUCKDB_WINDOWS
+#include <io.h>
+#endif
+#endif
+
 namespace duckdb {
 
 // LCOV_EXCL_START
 void Printer::Print(const string &str) {
 #ifndef DUCKDB_DISABLE_PRINT
+#ifdef DUCKDB_WINDOWS
+	if (IsTerminal()) {
+		// print utf8 to terminal
+		auto unicode = WindowsUtil::UTF8ToMBCS(str.c_str());
+		fprintf(stderr, "%s
", unicode.c_str());
+		return;
+	}
+#endif
 	fprintf(stderr, "%s
", str.c_str());
 #endif
 }
@@ -27,6 +43,17 @@ void Printer::FinishProgressBarPrint(const char *pbstr, int pbwidth) {
 	fflush(stdout);
 #endif
 }
+
+bool Printer::IsTerminal() {
+#ifndef DUCKDB_DISABLE_PRINT
+#ifdef DUCKDB_WINDOWS
+	return GetFileType(stderr) == FILE_TYPE_CHAR;
+#else
+	throw InternalException("IsTerminal is only implemented for Windows");
+#endif
+#endif
+	return false;
+}
 // LCOV_EXCL_STOP
 
 } // namespace duckdb
diff --git a/src/common/windows_util.cpp b/src/common/windows_util.cpp
new file mode 100644
index 000000000000..8855456f4482
--- /dev/null
+++ b/src/common/windows_util.cpp
@@ -0,0 +1,53 @@
+#include "duckdb/common/windows_util.hpp"
+
+namespace duckdb {
+
+#ifdef DUCKDB_WINDOWS
+
+std::wstring WindowsUtil::UTF8ToUnicode(const char *input) {
+	idx_t result_size;
+
+	result_size = MultiByteToWideChar(CP_UTF8, 0, input, -1, nullptr, 0);
+	if (result_size == 0) {
+		throw IOException("Failure in MultiByteToWideChar");
+	}
+	auto buffer = unique_ptr<wchar_t[]>(new wchar_t[result_size]);
+	result_size = MultiByteToWideChar(CP_UTF8, 0, input, -1, buffer.get(), result_size);
+	if (result_size == 0) {
+		throw IOException("Failure in MultiByteToWideChar");
+	}
+	return std::wstring(buffer.get(), result_size);
+}
+
+static string WideCharToMultiByteWrapper(LPCWSTR input, uint32_t code_page) {
+	idx_t result_size;
+
+	result_size = WideCharToMultiByte(code_page, 0, input, -1, 0, 0, 0, 0);
+	if (result_size == 0) {
+		throw IOException("Failure in WideCharToMultiByte");
+	}
+	auto buffer = unique_ptr<char[]>(new char[result_size]);
+	result_size = WideCharToMultiByte(code_page, 0, input, -1, buffer.get(), result_size, 0, 0);
+	if (result_size == 0) {
+		throw IOException("Failure in WideCharToMultiByte");
+	}
+	return string(buffer.get(), result_size - 1);
+}
+
+string WindowsUtil::UnicodeToUTF8(LPCWSTR input) {
+	return WideCharToMultiByteWrapper(input, CP_UTF8);
+}
+
+static string WindowsUnicodeToMBCS(LPCWSTR unicode_text, int use_ansi) {
+	uint32_t code_page = use_ansi ? CP_ACP : CP_OEMCP;
+	return WideCharToMultiByteWrapper(unicode_text, code_page);
+}
+
+string WindowsUtil::UTF8ToMBCS(const char *input, bool use_ansi) {
+	auto unicode = WindowsUtil::UTF8ToUnicode(input);
+	return WindowsUnicodeToMBCS(unicode.c_str(), use_ansi);
+}
+
+#endif
+
+} // namespace duckdb
diff --git a/src/include/duckdb/common/helper.hpp b/src/include/duckdb/common/helper.hpp
index 2fa2305a7719..a8dd308b2399 100644
--- a/src/include/duckdb/common/helper.hpp
+++ b/src/include/duckdb/common/helper.hpp
@@ -15,6 +15,12 @@
 #define suint64_t int64_t
 #endif
 
+#if defined(_WIN32) || defined(_WIN64)
+#define DUCKDB_WINDOWS
+#elif defined(__unix__) || defined(__unix) || (defined(__APPLE__) && defined(__MACH__))
+#define DUCKDB_POSIX
+#endif
+
 namespace duckdb {
 #if !defined(_MSC_VER) && (__cplusplus < 201402L)
 template <typename T, typename... Args>
diff --git a/src/include/duckdb/common/printer.hpp b/src/include/duckdb/common/printer.hpp
index 495cb958adf8..7f6e3673108c 100644
--- a/src/include/duckdb/common/printer.hpp
+++ b/src/include/duckdb/common/printer.hpp
@@ -21,5 +21,7 @@ class Printer {
 	static void PrintProgress(int percentage, const char *pbstr, int pbwidth);
 	//! Prints an empty line when progress bar is done
 	static void FinishProgressBarPrint(const char *pbstr, int pbwidth);
+	//! Whether or not we are printing to a terminal
+	static bool IsTerminal();
 };
 } // namespace duckdb
diff --git a/src/include/duckdb/common/tree_renderer.hpp b/src/include/duckdb/common/tree_renderer.hpp
index e8cee4b3ac2c..d97910add787 100644
--- a/src/include/duckdb/common/tree_renderer.hpp
+++ b/src/include/duckdb/common/tree_renderer.hpp
@@ -56,19 +56,19 @@ struct TreeRendererConfig {
 	bool detailed = false;
 
 #ifndef DUCKDB_ASCII_TREE_RENDERER
-	const char *LTCORNER = "┌";
-	const char *RTCORNER = "┐";
-	const char *LDCORNER = "└";
-	const char *RDCORNER = "┘";
-
-	const char *MIDDLE = "┼";
-	const char *TMIDDLE = "┬";
-	const char *LMIDDLE = "├";
-	const char *RMIDDLE = "┤";
-	const char *DMIDDLE = "┴";
-
-	const char *VERTICAL = "│";
-	const char *HORIZONTAL = "─";
+	const char *LTCORNER = "\342\224\214"; // "┌";
+	const char *RTCORNER = "\342\224\220"; // "┐";
+	const char *LDCORNER = "\342\224\224"; // "└";
+	const char *RDCORNER = "\342\224\230"; // "┘";
+
+	const char *MIDDLE = "\342\224\274";  // "┼";
+	const char *TMIDDLE = "\342\224\254"; // "┬";
+	const char *LMIDDLE = "\342\224\234"; // "├";
+	const char *RMIDDLE = "\342\224\244"; // "┤";
+	const char *DMIDDLE = "\342\224\264"; // "┴";
+
+	const char *VERTICAL = "\342\224\202";   // "│";
+	const char *HORIZONTAL = "\342\224\200"; // "─";
 #else
 	// ASCII version
 	const char *LTCORNER = "<";
diff --git a/src/include/duckdb/common/windows_util.hpp b/src/include/duckdb/common/windows_util.hpp
new file mode 100644
index 000000000000..18a02d0972ad
--- /dev/null
+++ b/src/include/duckdb/common/windows_util.hpp
@@ -0,0 +1,29 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// duckdb/common/windows_util.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include "duckdb/common/common.hpp"
+#include "duckdb/common/constants.hpp"
+#include "duckdb/common/exception.hpp"
+#include "duckdb/common/vector.hpp"
+#include "duckdb/common/windows.hpp"
+
+namespace duckdb {
+
+#ifdef DUCKDB_WINDOWS
+class WindowsUtil {
+public:
+	//! Windows helper functions
+	static std::wstring UTF8ToUnicode(const char *input);
+	static string UnicodeToUTF8(LPCWSTR input);
+	static string UTF8ToMBCS(const char *input, bool use_ansi = false);
+};
+#endif
+
+} // namespace duckdb
diff --git a/src/include/duckdb/planner/logical_operator.hpp b/src/include/duckdb/planner/logical_operator.hpp
index 9f1e33f13d9a..5b8f5cc0a457 100644
--- a/src/include/duckdb/planner/logical_operator.hpp
+++ b/src/include/duckdb/planner/logical_operator.hpp
@@ -56,7 +56,7 @@ class LogicalOperator {
 
 	virtual string GetName() const;
 	virtual string ParamsToString() const;
-	virtual string ToString(idx_t depth = 0) const;
+	virtual string ToString() const;
 	void Print();
 	//! Debug method: verify that the integrity of expressions & child nodes are maintained
 	virtual void Verify();
diff --git a/src/planner/logical_operator.cpp b/src/planner/logical_operator.cpp
index 1fda6b975b04..27d38003c3d5 100644
--- a/src/planner/logical_operator.cpp
+++ b/src/planner/logical_operator.cpp
@@ -71,7 +71,7 @@ vector<ColumnBinding> LogicalOperator::MapBindings(const vector<ColumnBinding> &
 	}
 }
 
-string LogicalOperator::ToString(idx_t depth) const {
+string LogicalOperator::ToString() const {
 	TreeRenderer renderer;
 	return renderer.ToString(*this);
 }
diff --git a/third_party/libpg_query/src_backend_parser_scan.cpp b/third_party/libpg_query/src_backend_parser_scan.cpp
index 6a92b35c295d..879222335ccb 100644
--- a/third_party/libpg_query/src_backend_parser_scan.cpp
+++ b/third_party/libpg_query/src_backend_parser_scan.cpp
@@ -309,7 +309,7 @@ namespace duckdb_libpgquery {
 #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
 
 /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
+ * if you want the limit (max/min) macros for int types.
  */
 #ifndef __STDC_LIMIT_MACROS
 #define __STDC_LIMIT_MACROS 1
@@ -327,7 +327,7 @@ typedef uint64_t flex_uint64_t;
 typedef signed char flex_int8_t;
 typedef short int flex_int16_t;
 typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
+typedef unsigned char flex_uint8_t;
 typedef unsigned short int flex_uint16_t;
 typedef unsigned int flex_uint32_t;
 
@@ -451,10 +451,10 @@ typedef size_t yy_size_t;
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
-    
+
     #define YY_LESS_LINENO(n)
     #define YY_LINENO_REWIND_TO(ptr)
-    
+
 /* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
@@ -1364,9 +1364,9 @@ static int yy_init_globals ( yyscan_t yyscanner );
     /* This must go here because YYSTYPE and YYLTYPE are included
      * from bison output in section 1.*/
     #    define yylval yyg->yylval_r
-    
+
     #    define yylloc yyg->yylloc_r
-    
+
 int yylex_init (yyscan_t* scanner);
 
 int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);
@@ -1409,9 +1409,9 @@ YYSTYPE * yyget_lval ( yyscan_t yyscanner );
 void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );
 
        YYLTYPE *yyget_lloc ( yyscan_t yyscanner );
-    
+
         void yyset_lloc ( YYLTYPE * yylloc_param , yyscan_t yyscanner );
-    
+
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
  */
@@ -1425,7 +1425,7 @@ extern int yywrap ( yyscan_t yyscanner );
 #endif
 
 #ifndef YY_NO_UNPUT
-    
+
 #endif
 
 #ifndef yytext_ptr
@@ -3123,7 +3123,7 @@ static void yy_load_buffer_state  (yyscan_t yyscanner)
     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
 {
 	YY_BUFFER_STATE b;
-    
+
 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
@@ -3189,7 +3189,7 @@ static void yy_load_buffer_state  (yyscan_t yyscanner)
     }
 
         b->yy_is_interactive = 0;
-    
+
 	errno = oerrno;
 }
 
@@ -3331,7 +3331,7 @@ static void yyensure_buffer_stack (yyscan_t yyscanner)
 YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
 {
 	YY_BUFFER_STATE b;
-    
+
 	if ( size < 2 ||
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
@@ -3367,7 +3367,7 @@ YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscann
  */
 YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)
 {
-    
+
 	return yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);
 }
 
@@ -3384,7 +3384,7 @@ YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, yy_size_t  _yybytes_len ,
 	char *buf;
 	yy_size_t n;
 	yy_size_t i;
-    
+
 	/* Get memory for full buffer, including space for trailing EOB's. */
 	n = (yy_size_t) (_yybytes_len + 2);
 	buf = (char *) yyalloc( n , yyscanner );
@@ -3416,7 +3416,6 @@ static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 	(void)yyg;
-	fprintf( stderr, "%s
", msg );
 	throw std::runtime_error(msg); // YY_EXIT_FAILURE );
 }
 
@@ -3457,7 +3456,7 @@ int yyget_lineno  (yyscan_t yyscanner)
 
         if (! YY_CURRENT_BUFFER)
             return 0;
-    
+
     return yylineno;
 }
 
@@ -3470,7 +3469,7 @@ int yyget_column  (yyscan_t yyscanner)
 
         if (! YY_CURRENT_BUFFER)
             return 0;
-    
+
     return yycolumn;
 }
 
@@ -3532,7 +3531,7 @@ void yyset_lineno (int  _line_number , yyscan_t yyscanner)
         /* lineno is only valid if an input buffer exists. */
         if (! YY_CURRENT_BUFFER )
            YY_FATAL_ERROR( "yyset_lineno called with no buffer" );
-    
+
     yylineno = _line_number;
 }
 
@@ -3547,7 +3546,7 @@ void yyset_column (int  _column_no , yyscan_t yyscanner)
         /* column is only valid if an input buffer exists. */
         if (! YY_CURRENT_BUFFER )
            YY_FATAL_ERROR( "yyset_column called with no buffer" );
-    
+
     yycolumn = _column_no;
 }
 
@@ -3600,13 +3599,13 @@ YYLTYPE *yyget_lloc  (yyscan_t yyscanner)
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
     return yylloc;
 }
-    
+
 void yyset_lloc (YYLTYPE *  yylloc_param , yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
     yylloc = yylloc_param;
 }
-    
+
 /* User-visible API */
 
 /* yylex_init is special because it creates the scanner itself, so it is
@@ -3686,13 +3685,8 @@ static int yy_init_globals (yyscan_t yyscanner)
     yyg->yy_start_stack =  NULL;
 
 /* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
     yyin = NULL;
     yyout = NULL;
-#endif
 
     /* For future reference: Set errno on error, since we are called by
      * yylex_init()
diff --git a/tools/shell/shell.c b/tools/shell/shell.c
index 5379979ce95a..313d51af829e 100644
--- a/tools/shell/shell.c
+++ b/tools/shell/shell.c
@@ -11607,19 +11607,19 @@ static int shell_callback(
       if (nArg != 2) {
         break;
       }
-      fputs("
┌─────────────────────────────┐
", p->out);
-      fputs("│┌───────────────────────────┐│
", p->out);
+      utf8_printf(p->out, "
┌─────────────────────────────┐
");
+      utf8_printf(p->out, "│┌───────────────────────────┐│
");
       if (strcmp(azArg[0], "logical_plan") == 0) {
-      fputs("││ Unoptimized Logical Plan  ││
", p->out);
+      utf8_printf(p->out, "││ Unoptimized Logical Plan  ││
");
       } else if (strcmp(azArg[0], "logical_opt") == 0) {
-      fputs("││  Optimized Logical Plan   ││
", p->out);
+      utf8_printf(p->out, "││  Optimized Logical Plan   ││
");
       } else if (strcmp(azArg[0], "physical_plan") == 0) {
-      fputs("││       Physical Plan       ││
", p->out);
+      utf8_printf(p->out, "││       Physical Plan       ││
");
 
       }
-      fputs("│└───────────────────────────┘│
", p->out);
-      fputs("└─────────────────────────────┘
", p->out);
-      fputs(azArg[1], p->out);
+      utf8_printf(p->out, "│└───────────────────────────┘│
");
+      utf8_printf(p->out, "└─────────────────────────────┘
");
+      utf8_printf(p->out, "%s", azArg[1]);
       break;
     }
     case MODE_Semi: {   /* .schema and .fullschema output */
