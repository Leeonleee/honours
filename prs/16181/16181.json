{
  "repo": "duckdb/duckdb",
  "pull_number": 16181,
  "instance_id": "duckdb__duckdb-16181",
  "issue_numbers": [
    "16122",
    "16122"
  ],
  "base_commit": "8b582bcabd995a9bd657c3740737af9f4c833f4c",
  "patch": "diff --git a/src/catalog/catalog_entry_retriever.cpp b/src/catalog/catalog_entry_retriever.cpp\nindex c37562d72144..eb283de5b4b7 100644\n--- a/src/catalog/catalog_entry_retriever.cpp\n+++ b/src/catalog/catalog_entry_retriever.cpp\n@@ -76,7 +76,7 @@ void CatalogEntryRetriever::Inherit(const CatalogEntryRetriever &parent) {\n \tthis->search_path = parent.search_path;\n }\n \n-CatalogSearchPath &CatalogEntryRetriever::GetSearchPath() {\n+const CatalogSearchPath &CatalogEntryRetriever::GetSearchPath() const {\n \tif (search_path) {\n \t\treturn *search_path;\n \t}\ndiff --git a/src/catalog/catalog_search_path.cpp b/src/catalog/catalog_search_path.cpp\nindex 793de909b9f6..9ce71f283cfe 100644\n--- a/src/catalog/catalog_search_path.cpp\n+++ b/src/catalog/catalog_search_path.cpp\n@@ -189,11 +189,11 @@ void CatalogSearchPath::Set(CatalogSearchEntry new_value, CatalogSetPathType set\n \tSet(std::move(new_paths), set_type);\n }\n \n-const vector<CatalogSearchEntry> &CatalogSearchPath::Get() {\n+const vector<CatalogSearchEntry> &CatalogSearchPath::Get() const {\n \treturn paths;\n }\n \n-string CatalogSearchPath::GetDefaultSchema(const string &catalog) {\n+string CatalogSearchPath::GetDefaultSchema(const string &catalog) const {\n \tfor (auto &path : paths) {\n \t\tif (path.catalog == TEMP_CATALOG) {\n \t\t\tcontinue;\n@@ -205,7 +205,7 @@ string CatalogSearchPath::GetDefaultSchema(const string &catalog) {\n \treturn DEFAULT_SCHEMA;\n }\n \n-string CatalogSearchPath::GetDefaultSchema(ClientContext &context, const string &catalog) {\n+string CatalogSearchPath::GetDefaultSchema(ClientContext &context, const string &catalog) const {\n \tfor (auto &path : paths) {\n \t\tif (path.catalog == TEMP_CATALOG) {\n \t\t\tcontinue;\n@@ -221,7 +221,7 @@ string CatalogSearchPath::GetDefaultSchema(ClientContext &context, const string\n \treturn DEFAULT_SCHEMA;\n }\n \n-string CatalogSearchPath::GetDefaultCatalog(const string &schema) {\n+string CatalogSearchPath::GetDefaultCatalog(const string &schema) const {\n \tif (DefaultSchemaGenerator::IsDefaultSchema(schema)) {\n \t\treturn SYSTEM_CATALOG;\n \t}\n@@ -236,7 +236,7 @@ string CatalogSearchPath::GetDefaultCatalog(const string &schema) {\n \treturn INVALID_CATALOG;\n }\n \n-vector<string> CatalogSearchPath::GetCatalogsForSchema(const string &schema) {\n+vector<string> CatalogSearchPath::GetCatalogsForSchema(const string &schema) const {\n \tvector<string> catalogs;\n \tif (DefaultSchemaGenerator::IsDefaultSchema(schema)) {\n \t\tcatalogs.push_back(SYSTEM_CATALOG);\n@@ -250,7 +250,7 @@ vector<string> CatalogSearchPath::GetCatalogsForSchema(const string &schema) {\n \treturn catalogs;\n }\n \n-vector<string> CatalogSearchPath::GetSchemasForCatalog(const string &catalog) {\n+vector<string> CatalogSearchPath::GetSchemasForCatalog(const string &catalog) const {\n \tvector<string> schemas;\n \tfor (auto &path : paths) {\n \t\tif (StringUtil::CIEquals(path.catalog, catalog)) {\n@@ -260,7 +260,7 @@ vector<string> CatalogSearchPath::GetSchemasForCatalog(const string &catalog) {\n \treturn schemas;\n }\n \n-const CatalogSearchEntry &CatalogSearchPath::GetDefault() {\n+const CatalogSearchEntry &CatalogSearchPath::GetDefault() const {\n \tconst auto &paths = Get();\n \tD_ASSERT(paths.size() >= 2);\n \treturn paths[1];\n@@ -281,7 +281,7 @@ void CatalogSearchPath::SetPathsInternal(vector<CatalogSearchEntry> new_paths) {\n }\n \n bool CatalogSearchPath::SchemaInSearchPath(ClientContext &context, const string &catalog_name,\n-                                           const string &schema_name) {\n+                                           const string &schema_name) const {\n \tfor (auto &path : paths) {\n \t\tif (!StringUtil::CIEquals(path.schema, schema_name)) {\n \t\t\tcontinue;\ndiff --git a/src/include/duckdb/catalog/catalog_entry_retriever.hpp b/src/include/duckdb/catalog/catalog_entry_retriever.hpp\nindex 4e771cdc589e..08425f00ad87 100644\n--- a/src/include/duckdb/catalog/catalog_entry_retriever.hpp\n+++ b/src/include/duckdb/catalog/catalog_entry_retriever.hpp\n@@ -56,7 +56,7 @@ class CatalogEntryRetriever {\n \t                                           OnEntryNotFound on_entry_not_found = OnEntryNotFound::THROW_EXCEPTION,\n \t                                           QueryErrorContext error_context = QueryErrorContext());\n \n-\tCatalogSearchPath &GetSearchPath();\n+\tconst CatalogSearchPath &GetSearchPath() const;\n \tvoid SetSearchPath(vector<CatalogSearchEntry> entries);\n \n \tvoid SetCallback(catalog_entry_callback_t callback);\ndiff --git a/src/include/duckdb/catalog/catalog_search_path.hpp b/src/include/duckdb/catalog/catalog_search_path.hpp\nindex f128a4962e75..e5b6cd254962 100644\n--- a/src/include/duckdb/catalog/catalog_search_path.hpp\n+++ b/src/include/duckdb/catalog/catalog_search_path.hpp\n@@ -48,20 +48,21 @@ class CatalogSearchPath {\n \tDUCKDB_API void Set(vector<CatalogSearchEntry> new_paths, CatalogSetPathType set_type);\n \tDUCKDB_API void Reset();\n \n-\tDUCKDB_API const vector<CatalogSearchEntry> &Get();\n-\tconst vector<CatalogSearchEntry> &GetSetPaths() {\n+\tDUCKDB_API const vector<CatalogSearchEntry> &Get() const;\n+\tconst vector<CatalogSearchEntry> &GetSetPaths() const {\n \t\treturn set_paths;\n \t}\n-\tDUCKDB_API const CatalogSearchEntry &GetDefault();\n+\tDUCKDB_API const CatalogSearchEntry &GetDefault() const;\n \t//! FIXME: this method is deprecated\n-\tDUCKDB_API string GetDefaultSchema(const string &catalog);\n-\tDUCKDB_API string GetDefaultSchema(ClientContext &context, const string &catalog);\n-\tDUCKDB_API string GetDefaultCatalog(const string &schema);\n+\tDUCKDB_API string GetDefaultSchema(const string &catalog) const;\n+\tDUCKDB_API string GetDefaultSchema(ClientContext &context, const string &catalog) const;\n+\tDUCKDB_API string GetDefaultCatalog(const string &schema) const;\n \n-\tDUCKDB_API vector<string> GetSchemasForCatalog(const string &catalog);\n-\tDUCKDB_API vector<string> GetCatalogsForSchema(const string &schema);\n+\tDUCKDB_API vector<string> GetSchemasForCatalog(const string &catalog) const;\n+\tDUCKDB_API vector<string> GetCatalogsForSchema(const string &schema) const;\n \n-\tDUCKDB_API bool SchemaInSearchPath(ClientContext &context, const string &catalog_name, const string &schema_name);\n+\tDUCKDB_API bool SchemaInSearchPath(ClientContext &context, const string &catalog_name,\n+\t                                   const string &schema_name) const;\n \n private:\n \t//! Set paths without checking if they exist\ndiff --git a/src/planner/binder/statement/bind_create_table.cpp b/src/planner/binder/statement/bind_create_table.cpp\nindex 80d50d074e00..15a553b81605 100644\n--- a/src/planner/binder/statement/bind_create_table.cpp\n+++ b/src/planner/binder/statement/bind_create_table.cpp\n@@ -271,13 +271,14 @@ void Binder::BindDefaultValues(const ColumnList &columns, vector<unique_ptr<Expr\n \t\tschema_name = DEFAULT_SCHEMA;\n \t}\n \n-\t// FIXME: We might want to save the existing search path of the binder\n \tvector<CatalogSearchEntry> defaults_search_path;\n \tdefaults_search_path.emplace_back(catalog_name, schema_name);\n \tif (schema_name != DEFAULT_SCHEMA) {\n \t\tdefaults_search_path.emplace_back(catalog_name, DEFAULT_SCHEMA);\n \t}\n-\tentry_retriever.SetSearchPath(std::move(defaults_search_path));\n+\n+\tauto default_binder = Binder::CreateBinder(context, *this);\n+\tdefault_binder->entry_retriever.SetSearchPath(std::move(defaults_search_path));\n \n \tfor (auto &column : columns.Physical()) {\n \t\tunique_ptr<Expression> bound_default;\n@@ -288,9 +289,9 @@ void Binder::BindDefaultValues(const ColumnList &columns, vector<unique_ptr<Expr\n \t\t\tif (default_copy->HasParameter()) {\n \t\t\t\tthrow BinderException(\"DEFAULT values cannot contain parameters\");\n \t\t\t}\n-\t\t\tConstantBinder default_binder(*this, context, \"DEFAULT value\");\n-\t\t\tdefault_binder.target_type = column.Type();\n-\t\t\tbound_default = default_binder.Bind(default_copy);\n+\t\t\tConstantBinder default_value_binder(*default_binder, context, \"DEFAULT value\");\n+\t\t\tdefault_value_binder.target_type = column.Type();\n+\t\t\tbound_default = default_value_binder.Bind(default_copy);\n \t\t} else {\n \t\t\t// no default value specified: push a default value of constant null\n \t\t\tbound_default = make_uniq<BoundConstantExpression>(Value(column.Type()));\n",
  "test_patch": "diff --git a/test/sql/attach/attach_issue16122.test b/test/sql/attach/attach_issue16122.test\nnew file mode 100644\nindex 000000000000..b47365bf20e2\n--- /dev/null\n+++ b/test/sql/attach/attach_issue16122.test\n@@ -0,0 +1,30 @@\n+# name: test/sql/attach/attach_issue16122.test\n+# description: Issue #16122 - Attach binding to incorrect table\n+# group: [attach]\n+\n+require noforcestorage\n+\n+load __TEST_DIR__/issue16122.db\n+\n+\n+statement ok\n+create table mytable (C1 VARCHAR(10));\n+\n+statement ok\n+insert into mytable values ('a');\n+\n+statement ok\n+attach '__TEST_DIR__/issue16122_new.db' as TOMERGE;\n+\n+statement ok\n+create table TOMERGE.mytable (C1 VARCHAR(10));\n+\n+query I\n+insert into TOMERGE.mytable SELECT * FROM mytable;\n+----\n+1\n+\n+query I\n+select * from TOMERGE.mytable;\n+----\n+a\n",
  "problem_statement": "v1.2 ATTACH DATABASE not working?\n### What happens?\n\nIs there any difference in attach syntax in version 1.2?\n\n```sql\n.open \"mydb.db\";\ncreate table mytable (C1 VARCHAR(10));\ninsert into mytable values ('a');\nselect * from mytable; -- 1 row\nattach 'mynewdb.db' as TOMERGE;\ncreate table TOMERGE.mytable (C1 VARCHAR(10));\ninsert into TOMERGE.mytable SELECT * FROM mytable;\nselect * from TOMERGE.mytable; -- no rows: error!\nDETACH TOMERGE;\n```\n\n### To Reproduce\n\nPrevious stable version was working\n\n### OS:\n\nWindows 10\n\n### DuckDB Version:\n\n1.2\n\n### DuckDB Client:\n\ncommand line\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nL. Brasio\n\n### Affiliation:\n\nnone\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\nv1.2 ATTACH DATABASE not working?\n### What happens?\n\nIs there any difference in attach syntax in version 1.2?\n\n```sql\n.open \"mydb.db\";\ncreate table mytable (C1 VARCHAR(10));\ninsert into mytable values ('a');\nselect * from mytable; -- 1 row\nattach 'mynewdb.db' as TOMERGE;\ncreate table TOMERGE.mytable (C1 VARCHAR(10));\ninsert into TOMERGE.mytable SELECT * FROM mytable;\nselect * from TOMERGE.mytable; -- no rows: error!\nDETACH TOMERGE;\n```\n\n### To Reproduce\n\nPrevious stable version was working\n\n### OS:\n\nWindows 10\n\n### DuckDB Version:\n\n1.2\n\n### DuckDB Client:\n\ncommand line\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nL. Brasio\n\n### Affiliation:\n\nnone\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2025-02-11T12:53:38Z"
}