{
  "repo": "duckdb/duckdb",
  "pull_number": 2708,
  "instance_id": "duckdb__duckdb-2708",
  "issue_numbers": [
    "2701"
  ],
  "base_commit": "ae85627931461937c10a9e082d552593ce088497",
  "patch": "diff --git a/src/execution/aggregate_hashtable.cpp b/src/execution/aggregate_hashtable.cpp\nindex ebee45c3720c..66a36a439b1c 100644\n--- a/src/execution/aggregate_hashtable.cpp\n+++ b/src/execution/aggregate_hashtable.cpp\n@@ -677,7 +677,9 @@ idx_t GroupedAggregateHashTable::Scan(idx_t &scan_position, DataChunk &result) {\n }\n \n void GroupedAggregateHashTable::Finalize() {\n-\tD_ASSERT(!is_finalized);\n+\tif (is_finalized) {\n+\t\treturn;\n+\t}\n \n \t// early release hashes, not needed for partition/scan\n \thashes_hdl.reset();\ndiff --git a/src/execution/operator/scan/physical_expression_scan.cpp b/src/execution/operator/scan/physical_expression_scan.cpp\nindex d2e411c5ec13..6bed84636c2c 100644\n--- a/src/execution/operator/scan/physical_expression_scan.cpp\n+++ b/src/execution/operator/scan/physical_expression_scan.cpp\n@@ -4,7 +4,7 @@\n \n namespace duckdb {\n \n-class ExpressionScanState : public GlobalSourceState {\n+class ExpressionScanState : public OperatorState {\n public:\n \texplicit ExpressionScanState(const PhysicalExpressionScan &op) : expression_index(0) {\n \t\ttemp_chunk.Initialize(op.GetTypes());\n@@ -16,16 +16,26 @@ class ExpressionScanState : public GlobalSourceState {\n \tDataChunk temp_chunk;\n };\n \n-class ExpressionSinkState : public GlobalSinkState {\n-public:\n-\tExpressionSinkState() {\n-\t}\n+unique_ptr<OperatorState> PhysicalExpressionScan::GetOperatorState(ClientContext &context) const {\n+\treturn make_unique<ExpressionScanState>(*this);\n+}\n \n-\tDataChunk child_chunk;\n-};\n+OperatorResultType PhysicalExpressionScan::Execute(ExecutionContext &context, DataChunk &input, DataChunk &chunk,\n+                                                   OperatorState &state_p) const {\n+\tauto &state = (ExpressionScanState &)state_p;\n \n-unique_ptr<GlobalSourceState> PhysicalExpressionScan::GetGlobalSourceState(ClientContext &context) const {\n-\treturn make_unique<ExpressionScanState>(*this);\n+\tfor (; chunk.size() + input.size() <= STANDARD_VECTOR_SIZE && state.expression_index < expressions.size();\n+\t     state.expression_index++) {\n+\t\tstate.temp_chunk.Reset();\n+\t\tEvaluateExpression(state.expression_index, &input, state.temp_chunk);\n+\t\tchunk.Append(state.temp_chunk);\n+\t}\n+\tif (state.expression_index < expressions.size()) {\n+\t\treturn OperatorResultType::HAVE_MORE_OUTPUT;\n+\t} else {\n+\t\tstate.expression_index = 0;\n+\t\treturn OperatorResultType::NEED_MORE_INPUT;\n+\t}\n }\n \n void PhysicalExpressionScan::EvaluateExpression(idx_t expression_idx, DataChunk *child_chunk, DataChunk &result) const {\n@@ -38,20 +48,6 @@ void PhysicalExpressionScan::EvaluateExpression(idx_t expression_idx, DataChunk\n \t}\n }\n \n-void PhysicalExpressionScan::GetData(ExecutionContext &context, DataChunk &chunk, GlobalSourceState &gstate_p,\n-                                     LocalSourceState &lstate) const {\n-\tD_ASSERT(sink_state);\n-\tauto &state = (ExpressionScanState &)gstate_p;\n-\tauto &gstate = (ExpressionSinkState &)*sink_state;\n-\n-\tfor (; chunk.size() < STANDARD_VECTOR_SIZE && state.expression_index < expressions.size();\n-\t     state.expression_index++) {\n-\t\tstate.temp_chunk.Reset();\n-\t\tEvaluateExpression(state.expression_index, &gstate.child_chunk, state.temp_chunk);\n-\t\tchunk.Append(state.temp_chunk);\n-\t}\n-}\n-\n bool PhysicalExpressionScan::IsFoldable() const {\n \tfor (auto &expr_list : expressions) {\n \t\tfor (auto &expr : expr_list) {\n@@ -63,22 +59,4 @@ bool PhysicalExpressionScan::IsFoldable() const {\n \treturn true;\n }\n \n-SinkResultType PhysicalExpressionScan::Sink(ExecutionContext &context, GlobalSinkState &gstate_p,\n-                                            LocalSinkState &lstate, DataChunk &input) const {\n-\tauto &gstate = (ExpressionSinkState &)gstate_p;\n-\n-\tD_ASSERT(children.size() == 1);\n-\tD_ASSERT(gstate.child_chunk.size() == 0);\n-\tif (input.size() != 1) {\n-\t\tthrow InternalException(\"Expected expression scan child to have exactly one element\");\n-\t}\n-\tgstate.child_chunk.Move(input);\n-\tgstate.child_chunk.Verify();\n-\treturn SinkResultType::FINISHED;\n-}\n-\n-unique_ptr<GlobalSinkState> PhysicalExpressionScan::GetGlobalSinkState(ClientContext &context) const {\n-\treturn make_unique<ExpressionSinkState>();\n-}\n-\n } // namespace duckdb\ndiff --git a/src/include/duckdb/execution/operator/scan/physical_expression_scan.hpp b/src/include/duckdb/execution/operator/scan/physical_expression_scan.hpp\nindex 180a828bdc2c..141c966ba24c 100644\n--- a/src/include/duckdb/execution/operator/scan/physical_expression_scan.hpp\n+++ b/src/include/duckdb/execution/operator/scan/physical_expression_scan.hpp\n@@ -27,18 +27,11 @@ class PhysicalExpressionScan : public PhysicalOperator {\n \tvector<vector<unique_ptr<Expression>>> expressions;\n \n public:\n-\tunique_ptr<GlobalSourceState> GetGlobalSourceState(ClientContext &context) const override;\n-\tvoid GetData(ExecutionContext &context, DataChunk &chunk, GlobalSourceState &gstate,\n-\t             LocalSourceState &lstate) const override;\n+\tunique_ptr<OperatorState> GetOperatorState(ClientContext &context) const override;\n+\tOperatorResultType Execute(ExecutionContext &context, DataChunk &input, DataChunk &chunk,\n+\t                           OperatorState &state) const override;\n \n-public:\n-\t// Sink interface\n-\tSinkResultType Sink(ExecutionContext &context, GlobalSinkState &gstate, LocalSinkState &lstate,\n-\t                    DataChunk &input) const override;\n-\n-\tunique_ptr<GlobalSinkState> GetGlobalSinkState(ClientContext &context) const override;\n-\n-\tbool IsSink() const override {\n+\tbool ParallelOperator() const override {\n \t\treturn true;\n \t}\n \ndiff --git a/src/parallel/executor.cpp b/src/parallel/executor.cpp\nindex 7a2b2c249b92..a6c081c09dfa 100644\n--- a/src/parallel/executor.cpp\n+++ b/src/parallel/executor.cpp\n@@ -410,7 +410,6 @@ void Executor::BuildPipelines(PhysicalOperator *op, Pipeline *current) {\n \t\tcase PhysicalOperatorType::TOP_N:\n \t\tcase PhysicalOperatorType::COPY_TO_FILE:\n \t\tcase PhysicalOperatorType::LIMIT:\n-\t\tcase PhysicalOperatorType::EXPRESSION_SCAN:\n \t\tcase PhysicalOperatorType::EXPLAIN_ANALYZE:\n \t\t\tD_ASSERT(op->children.size() == 1);\n \t\t\t// single operator:\ndiff --git a/src/planner/expression_iterator.cpp b/src/planner/expression_iterator.cpp\nindex 5077105ee916..17cce4b6a819 100644\n--- a/src/planner/expression_iterator.cpp\n+++ b/src/planner/expression_iterator.cpp\n@@ -146,6 +146,15 @@ void ExpressionIterator::EnumerateTableRefChildren(BoundTableRef &ref,\n \t\tEnumerateTableRefChildren(*bound_crossproduct.right, callback);\n \t\tbreak;\n \t}\n+\tcase TableReferenceType::EXPRESSION_LIST: {\n+\t\tauto &bound_expr_list = (BoundExpressionListRef &)ref;\n+\t\tfor (auto &expr_list : bound_expr_list.values) {\n+\t\t\tfor (auto &expr : expr_list) {\n+\t\t\t\tEnumerateExpression(expr, callback);\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\t}\n \tcase TableReferenceType::JOIN: {\n \t\tauto &bound_join = (BoundJoinRef &)ref;\n \t\tEnumerateExpression(bound_join.condition, callback);\ndiff --git a/src/planner/subquery/flatten_dependent_join.cpp b/src/planner/subquery/flatten_dependent_join.cpp\nindex 6263dc401088..46e91e85cdfb 100644\n--- a/src/planner/subquery/flatten_dependent_join.cpp\n+++ b/src/planner/subquery/flatten_dependent_join.cpp\n@@ -314,6 +314,29 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \tcase LogicalOperatorType::LOGICAL_DISTINCT:\n \t\tplan->children[0] = PushDownDependentJoin(move(plan->children[0]));\n \t\treturn plan;\n+\tcase LogicalOperatorType::LOGICAL_EXPRESSION_GET: {\n+\t\t// expression get\n+\t\t// first we flatten the dependent join in the child\n+\t\tplan->children[0] = PushDownDependentJoinInternal(move(plan->children[0]));\n+\t\t// then we replace any correlated expressions with the corresponding entry in the correlated_map\n+\t\tRewriteCorrelatedExpressions rewriter(base_binding, correlated_map);\n+\t\trewriter.VisitOperator(*plan);\n+\t\t// now we add all the correlated columns to each of the expressions of the expression scan\n+\t\tauto expr_get = (LogicalExpressionGet *)plan.get();\n+\t\tfor (idx_t i = 0; i < correlated_columns.size(); i++) {\n+\t\t\tfor (auto &expr_list : expr_get->expressions) {\n+\t\t\t\tauto colref = make_unique<BoundColumnRefExpression>(\n+\t\t\t\t    correlated_columns[i].type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));\n+\t\t\t\texpr_list.push_back(move(colref));\n+\t\t\t}\n+\t\t\texpr_get->expr_types.push_back(correlated_columns[i].type);\n+\t\t}\n+\n+\t\tbase_binding.table_index = expr_get->table_index;\n+\t\tthis->delim_offset = base_binding.column_index = expr_get->expr_types.size() - correlated_columns.size();\n+\t\tthis->data_offset = 0;\n+\t\treturn plan;\n+\t}\n \tcase LogicalOperatorType::LOGICAL_ORDER_BY:\n \t\tthrow ParserException(\"ORDER BY not supported in correlated subquery\");\n \tdefault:\n",
  "test_patch": "diff --git a/test/sql/subquery/scalar/expression_get.test b/test/sql/subquery/scalar/expression_get.test\nnew file mode 100644\nindex 000000000000..cbd8138bf92a\n--- /dev/null\n+++ b/test/sql/subquery/scalar/expression_get.test\n@@ -0,0 +1,101 @@\n+# name: test/sql/subquery/scalar/expression_get.test\n+# description: Issue #2701: Nested selecting max from column values gives dependent join internal error\n+# group: [scalar]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# basic correlated VALUES clause in subquery\n+statement ok\n+CREATE TABLE test AS SELECT CAST((i % 10) AS INTEGER) AS i, CAST(((i * 2) % 10) AS INTEGER) AS j FROM generate_series(0, 9, 1) tbl(i);\n+\n+query III\n+SELECT i, j, (SELECT max(x) FROM (VALUES (i), (j)) AS X(x)) as maxn FROM test;\n+----\n+0\t0\t0\n+1\t2\t2\n+2\t4\t4\n+3\t6\t6\n+4\t8\t8\n+5\t0\t5\n+6\t2\t6\n+7\t4\t7\n+8\t6\t8\n+9\t8\t9\n+\n+# mix of correlated and non-correlated values\n+query III\n+SELECT i, j, (SELECT max(x) FROM (VALUES (i), (j), (3), (NULL), (5)) AS X(x)) as maxn FROM test;\n+----\n+0\t0\t5\n+1\t2\t5\n+2\t4\t5\n+3\t6\t6\n+4\t8\t8\n+5\t0\t5\n+6\t2\t6\n+7\t4\t7\n+8\t6\t8\n+9\t8\t9\n+\n+# more complex correlated queries involving VALUES lists\n+statement ok\n+CREATE TABLE integers(i INTEGER);\n+\n+statement ok\n+INSERT INTO integers VALUES (1), (2), (3), (NULL);\n+\n+# subquery within correlated values list\n+query I\n+SELECT (SELECT max(x) FROM (VALUES ((SELECT i))) tbl(x)) FROM integers ORDER BY i;\n+----\n+NULL\n+1\n+2\n+3\n+\n+# correlated values list within correlated values list\n+query I\n+SELECT (SELECT max(x) FROM (VALUES ((SELECT * FROM (VALUES (i)) tbl3(x)))) tbl(x)) FROM integers ORDER BY i;\n+----\n+NULL\n+1\n+2\n+3\n+\n+# join between correlated values lists\n+query I\n+SELECT (SELECT max(x) FROM (VALUES (i)) tbl(x) JOIN (VALUES (i)) tbl2(x) USING (x)) FROM integers ORDER BY i;\n+----\n+NULL\n+1\n+2\n+3\n+\n+# many rows\n+statement ok\n+CREATE TABLE test2 AS SELECT (i % 10)::INTEGER AS i, ((i * 2) % 10)::INTEGER AS j FROM generate_series(0, 99999, 1) tbl(i);\n+\n+query IIII\n+SELECT SUM(i), SUM(j), SUM(GREATEST(i, j)), SUM((SELECT max(x) FROM (VALUES (i), (j)) AS X(x))) as maxn FROM test2;\n+----\n+450000\t400000\t550000\t550000\n+\n+query IIII\n+SELECT SUM(i), SUM(j), SUM(GREATEST(i, j)), SUM((SELECT max(x) FROM (VALUES (i), (j), (i), (j), (i), (j)) AS X(x))) as maxn FROM test2;\n+----\n+450000\t400000\t550000\t550000\n+\n+# NULLs\n+statement ok\n+CREATE TABLE test3 AS SELECT CASE WHEN i%7=2 THEN NULL ELSE (i % 10)::INTEGER END AS i, CASE WHEN i%9=2 THEN NULL ELSE ((i * 2) % 10)::INTEGER END AS j FROM generate_series(0, 99999, 1) tbl(i);\n+\n+query III\n+SELECT SUM(i), SUM(j), SUM((SELECT max(x) FROM (VALUES (i), (j)) AS X(x))) as maxn FROM test3;\n+----\n+385713\t355556\t512700\n+\n+query III\n+SELECT SUM(i), SUM(j), SUM((SELECT max(x) FROM (VALUES (i), (j), (NULL), (NULL), (6)) AS X(x))) as maxn FROM test3;\n+----\n+385713\t355556\t671748\ndiff --git a/test/sql/subquery/scalar/values_list_large.test_slow b/test/sql/subquery/scalar/values_list_large.test_slow\nnew file mode 100644\nindex 000000000000..3e5b6114dc31\n--- /dev/null\n+++ b/test/sql/subquery/scalar/values_list_large.test_slow\n@@ -0,0 +1,11 @@\n+# name: test/sql/subquery/scalar/values_list_large.test_slow\n+# description: Test large correlated subquery with VALUES list\n+# group: [scalar]\n+\n+statement ok\n+CREATE TABLE test AS SELECT CASE WHEN i%7=2 THEN NULL ELSE i::INTEGER END AS i, CASE WHEN i%9=2 THEN NULL ELSE i::INTEGER+2 END AS j FROM generate_series(0, 9999999, 1) tbl(i);\n+\n+query III\n+SELECT SUM(i), SUM(j), SUM((SELECT max(x) FROM (VALUES (i), (j)) AS X(x))) as maxn FROM test;\n+----\n+42857134285714\t44444461111111\t49206358253971\n",
  "problem_statement": "Nested selecting max from column values gives dependent join internal error\n#### What happens?\r\n\r\nThe reproduction query results in an internal error.\r\n\r\n```\r\nError: INTERNAL Error: Logical operator type \"EXPRESSION_GET\" for dependent join\r\n```\r\n\r\n#### To Reproduce\r\n\r\n```sql\r\nCREATE TABLE test AS SELECT (i % 100)::INTEGER AS i, ((i * 2) % 100)::INTEGER AS j FROM range(0, 100000) tbl(i);\r\nSELECT i, j, (SELECT max(x) FROM (VALUES (i), (j)) AS X(x)) as maxn FROM test;\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Windows 10\r\n - DuckDB Version: 0.3.1\r\n - DuckDB Client: CLI\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "Hello and thanks for using DuckDB!\r\nI'm looking at your query and trying to understand your goal. Would this query work instead?\r\n```sql\r\nSelect i, j,  max(x) as maxn \r\nFrom test\r\nGroup by i, j\r\n```\n@Alex-Monahan That query isn't valid, so no. The query is equivalent to this:\r\n\r\n```sql\r\nSELECT i, j, greatest(i, j) as maxn FROM test;\r\n```\r\n\r\nThe point of this bug report is not to get a working alternative for the query however, it's to eliminate the internal error.\r\n",
  "created_at": "2021-12-01T18:59:55Z"
}