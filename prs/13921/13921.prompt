You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Namespace resolution for VIEW does not work for views from ATTACH-ed database
### What happens?

Persistent `.duckdb` database exist, in which two views are defined:
- `first_view` is defined as a select over a  `read_parquet(...)` function
- `second_view` is defined as a view on top of `first_view`

Both these views can be queried when the `.duckdb` database is opened with the CLI tool.

After using `ATTACH` from another database (eg :memory) attempts to query `second_view` fails with:
```
CatalogException
This cell raised an exception: CatalogException('Catalog Error: Table with name first_view does not exist! Did you mean "demo.first_view"?')
``` 

Details:
```
Traceback (most recent call last):
  File "C:\Users\jbi\Repos\marimo\bugreport\.venv\Lib\site-packages\marimo\_runtime\executor.py", line 170, in execute_cell
    exec(cell.body, glbls)
  Cell marimo://C:\Users\jbi\Repos\marimo\bugreport\notebooks\Myname.py#cell=cell-3, line 1, in <module>
    _df = mo.sql(
          ^^^^^^^
  File "C:\Users\jbi\Repos\marimo\bugreport\.venv\Lib\site-packages\marimo\_sql\sql.py", line 40, in sql
    relation = duckdb.sql(query=query)
               ^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\jbi\Repos\marimo\bugreport\.venv\Lib\site-packages\duckdb\__init__.py", line 457, in sql
    return conn.sql(query, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
duckdb.duckdb.CatalogException: Catalog Error: Table with name first_view does not exist!
Did you mean "demo.first_view"?
``` 


### To Reproduce


DuckDB CLI is first used to create a .parquet file. Start CLI in memory mode:
```shell
duckdb
``` 

Execute statements:
```
CREATE TABLE mytable (id INTEGER PRIMARY KEY, j VARCHAR);
INSERT INTO mytable VALUES (1, 'a');
INSERT INTO mytable VALUES (b, '2');

COPY
  (SELECT * FROM mytable)
  TO 'demo.parquet'
  (FORMAT 'parquet');
``` 

Exit CLI tool. 

Next step is to create the persistent .duckdb database. Open/create DB:
```shell
duckdb demo.duckdb
``` 

Execute statements to create view. Note that full-path to demo.parquet file is required. 
```
CREATE VIEW first_view AS SELECT id, j FROM read_parquet('C:\Temp\demo.parquet');
CREATE VIEW second_view AS SELECT * FROM first_view;
``` 

Edit by @szarnyasg – Bash one-liner:

```bash
duckdb demo.duckdb -c "CREATE VIEW first_view AS SELECT id, j FROM read_parquet('`pwd`/demo.parquet'); CREATE VIEW second_view AS SELECT * FROM first_view;"
```

These views can both be queried as one would expect. 

Exit CLI tool, and open new a transient duck-db database:
```shell
duckdb
```

Attach the .duckdb database
```
ATTACH 'demo.duckdb';
```

Query of `first_view` works:
```
SELECT * FROM demo.main.first_view;
```

Query of `second_view` **fails**:
```
SELECT * FROM demo.main.second_view;
``` 

Changing the namespace makes the second query work:
```
USE demo.main;
```



### OS:

Windows 11 x64

### DuckDB Version:

1.0.0

### DuckDB Client:

duckdb cli

### Full Name:

Jannick Bitsch

### Affiliation:

Danske Commodities A/S

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
Namespace resolution for VIEW does not work for views from ATTACH-ed database
### What happens?

Persistent `.duckdb` database exist, in which two views are defined:
- `first_view` is defined as a select over a  `read_parquet(...)` function
- `second_view` is defined as a view on top of `first_view`

Both these views can be queried when the `.duckdb` database is opened with the CLI tool.

After using `ATTACH` from another database (eg :memory) attempts to query `second_view` fails with:
```
CatalogException
This cell raised an exception: CatalogException('Catalog Error: Table with name first_view does not exist! Did you mean "demo.first_view"?')
``` 

Details:
```
Traceback (most recent call last):
  File "C:\Users\jbi\Repos\marimo\bugreport\.venv\Lib\site-packages\marimo\_runtime\executor.py", line 170, in execute_cell
    exec(cell.body, glbls)
  Cell marimo://C:\Users\jbi\Repos\marimo\bugreport\notebooks\Myname.py#cell=cell-3, line 1, in <module>
    _df = mo.sql(
          ^^^^^^^
  File "C:\Users\jbi\Repos\marimo\bugreport\.venv\Lib\site-packages\marimo\_sql\sql.py", line 40, in sql
    relation = duckdb.sql(query=query)
               ^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\jbi\Repos\marimo\bugreport\.venv\Lib\site-packages\duckdb\__init__.py", line 457, in sql
    return conn.sql(query, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
duckdb.duckdb.CatalogException: Catalog Error: Table with name first_view does not exist!
Did you mean "demo.first_view"?
``` 


### To Reproduce


DuckDB CLI is first used to create a .parquet file. Start CLI in memory mode:
```shell
duckdb
``` 

Execute statements:
```
CREATE TABLE mytable (id INTEGER PRIMARY KEY, j VARCHAR);
INSERT INTO mytable VALUES (1, 'a');
INSERT INTO mytable VALUES (b, '2');

COPY
  (SELECT * FROM mytable)
  TO 'demo.parquet'
  (FORMAT 'parquet');
``` 

Exit CLI tool. 

Next step is to create the persistent .duckdb database. Open/create DB:
```shell
duckdb demo.duckdb
``` 

Execute statements to create view. Note that full-path to demo.parquet file is required. 
```
CREATE VIEW first_view AS SELECT id, j FROM read_parquet('C:\Temp\demo.parquet');
CREATE VIEW second_view AS SELECT * FROM first_view;
``` 

Edit by @szarnyasg – Bash one-liner:

```bash
duckdb demo.duckdb -c "CREATE VIEW first_view AS SELECT id, j FROM read_parquet('`pwd`/demo.parquet'); CREATE VIEW second_view AS SELECT * FROM first_view;"
```

These views can both be queried as one would expect. 

Exit CLI tool, and open new a transient duck-db database:
```shell
duckdb
```

Attach the .duckdb database
```
ATTACH 'demo.duckdb';
```

Query of `first_view` works:
```
SELECT * FROM demo.main.first_view;
```

Query of `second_view` **fails**:
```
SELECT * FROM demo.main.second_view;
``` 

Changing the namespace makes the second query work:
```
USE demo.main;
```



### OS:

Windows 11 x64

### DuckDB Version:

1.0.0

### DuckDB Client:

duckdb cli

### Full Name:

Jannick Bitsch

### Affiliation:

Danske Commodities A/S

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of Makefile]
1: .PHONY: all opt unit clean debug release test unittest allunit benchmark docs doxygen format sqlite
2: 
3: all: release
4: opt: release
5: unit: unittest
6: 
7: EXTENSION_CONFIG_STEP ?=
8: ifdef USE_MERGED_VCPKG_MANIFEST
9: 	EXTENSION_CONFIG_STEP = build/extension_configuration/vcpkg.json
10: endif
11: 
12: GENERATOR ?=
13: FORCE_COLOR ?=
14: WARNINGS_AS_ERRORS ?=
15: FORCE_WARN_UNUSED_FLAG ?=
16: DISABLE_UNITY_FLAG ?=
17: DISABLE_SANITIZER_FLAG ?=
18: FORCE_32_BIT_FLAG ?=
19: 
20: MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))
21: PROJ_DIR := $(dir $(MKFILE_PATH))
22: 
23: ifeq ($(GEN),ninja)
24: 	GENERATOR=-G "Ninja"
25: 	FORCE_COLOR=-DFORCE_COLORED_OUTPUT=1
26: endif
27: ifeq (${TREAT_WARNINGS_AS_ERRORS}, 1)
28: 	WARNINGS_AS_ERRORS=-DTREAT_WARNINGS_AS_ERRORS=1
29: endif
30: ifeq (${FORCE_32_BIT}, 1)
31: 	FORCE_32_BIT_FLAG=-DFORCE_32_BIT=1
32: endif
33: ifeq (${FORCE_WARN_UNUSED}, 1)
34: 	FORCE_WARN_UNUSED_FLAG=-DFORCE_WARN_UNUSED=1
35: endif
36: ifeq (${DISABLE_UNITY}, 1)
37: 	DISABLE_UNITY_FLAG=-DDISABLE_UNITY=1
38: endif
39: ifeq (${DISABLE_SANITIZER}, 1)
40: 	DISABLE_SANITIZER_FLAG=-DENABLE_SANITIZER=FALSE -DENABLE_UBSAN=0
41: endif
42: ifeq (${DISABLE_UBSAN}, 1)
43: 	DISABLE_SANITIZER_FLAG=-DENABLE_UBSAN=0
44: endif
45: ifeq (${DISABLE_VPTR_SANITIZER}, 1)
46: 	DISABLE_SANITIZER_FLAG:=${DISABLE_SANITIZER_FLAG} -DDISABLE_VPTR_SANITIZER=1
47: endif
48: ifeq (${FORCE_SANITIZER}, 1)
49: 	DISABLE_SANITIZER_FLAG:=${DISABLE_SANITIZER_FLAG} -DFORCE_SANITIZER=1
50: endif
51: ifeq (${THREADSAN}, 1)
52: 	DISABLE_SANITIZER_FLAG:=${DISABLE_SANITIZER_FLAG} -DENABLE_THREAD_SANITIZER=1
53: endif
54: ifeq (${STATIC_LIBCPP}, 1)
55: 	STATIC_LIBCPP=-DSTATIC_LIBCPP=TRUE
56: endif
57: 
58: COMMON_CMAKE_VARS ?=
59: CMAKE_VARS_BUILD ?=
60: CMAKE_LLVM_VARS ?=
61: SKIP_EXTENSIONS ?=
62: BUILD_EXTENSIONS ?=
63: CORE_EXTENSIONS ?=
64: UNSAFE_NUMERIC_CAST ?=
65: ifdef OVERRIDE_GIT_DESCRIBE
66:         COMMON_CMAKE_VARS:=${COMMON_CMAKE_VARS} -DOVERRIDE_GIT_DESCRIBE="${OVERRIDE_GIT_DESCRIBE}"
67: else
68:         COMMON_CMAKE_VARS:=${COMMON_CMAKE_VARS} -DOVERRIDE_GIT_DESCRIBE=""
69: endif
70: ifneq (${CXX_STANDARD}, )
71:         CMAKE_VARS:=${CMAKE_VARS} -DCMAKE_CXX_STANDARD="${CXX_STANDARD}"
72: endif
73: ifneq (${DUCKDB_EXTENSIONS}, )
74: 	BUILD_EXTENSIONS:=${DUCKDB_EXTENSIONS}
75: endif
76: ifneq (${CORE_EXTENSIONS}, )
77: 	CORE_EXTENSIONS:=${CORE_EXTENSIONS}
78: endif
79: ifeq (${DISABLE_PARQUET}, 1)
80: 	SKIP_EXTENSIONS:=${SKIP_EXTENSIONS};parquet
81: endif
82: ifeq (${DISABLE_MAIN_DUCKDB_LIBRARY}, 1)
83: 	CMAKE_VARS:=${CMAKE_VARS} -DBUILD_MAIN_DUCKDB_LIBRARY=0
84: endif
85: ifeq (${EXTENSION_STATIC_BUILD}, 1)
86: 	CMAKE_VARS:=${CMAKE_VARS} -DEXTENSION_STATIC_BUILD=1
87: endif
88: ifeq (${DISABLE_BUILTIN_EXTENSIONS}, 1)
89: 	CMAKE_VARS:=${CMAKE_VARS} -DDISABLE_BUILTIN_EXTENSIONS=1
90: endif
91: ifneq (${ENABLE_EXTENSION_AUTOLOADING}, "")
92: 	CMAKE_VARS:=${CMAKE_VARS} -DENABLE_EXTENSION_AUTOLOADING=${ENABLE_EXTENSION_AUTOLOADING}
93: endif
94: ifneq (${ENABLE_EXTENSION_AUTOINSTALL}, "")
95: 	CMAKE_VARS:=${CMAKE_VARS} -DENABLE_EXTENSION_AUTOINSTALL=${ENABLE_EXTENSION_AUTOINSTALL}
96: endif
97: ifneq (${UNSAFE_NUMERIC_CAST}, )
98: 	CMAKE_VARS:=${CMAKE_VARS} -DUNSAFE_NUMERIC_CAST=1
99: endif
100: ifeq (${BUILD_EXTENSIONS_ONLY}, 1)
101: 	CMAKE_VARS:=${CMAKE_VARS} -DBUILD_EXTENSIONS_ONLY=1
102: endif
103: 
104: ifeq (${BUILD_BENCHMARK}, 1)
105: 	CMAKE_VARS:=${CMAKE_VARS} -DBUILD_BENCHMARKS=1
106: endif
107: ifeq (${BUILD_AUTOCOMPLETE}, 1)
108: 	BUILD_EXTENSIONS:=${BUILD_EXTENSIONS};autocomplete
109: endif
110: ifeq (${BUILD_ICU}, 1)
111: 	BUILD_EXTENSIONS:=${BUILD_EXTENSIONS};icu
112: endif
113: ifeq (${BUILD_TPCH}, 1)
114: 	BUILD_EXTENSIONS:=${BUILD_EXTENSIONS};tpch
115: endif
116: ifeq (${BUILD_TPCDS}, 1)
117: 	BUILD_EXTENSIONS:=${BUILD_EXTENSIONS};tpcds
118: endif
119: ifeq (${BUILD_FTS}, 1)
120: 	BUILD_EXTENSIONS:=${BUILD_EXTENSIONS};fts
121: endif
122: ifeq (${BUILD_HTTPFS}, 1)
123: 	BUILD_EXTENSIONS:=${BUILD_EXTENSIONS};httpfs
124: endif
125: ifeq (${BUILD_JSON}, 1)
126: 	BUILD_EXTENSIONS:=${BUILD_EXTENSIONS};json
127: endif
128: ifeq (${BUILD_JEMALLOC}, 1)
129: 	BUILD_EXTENSIONS:=${BUILD_EXTENSIONS};jemalloc
130: endif
131: ifeq (${BUILD_ALL_EXT}, 1)
132: 	CMAKE_VARS:=${CMAKE_VARS} -DDUCKDB_EXTENSION_CONFIGS=".github/config/in_tree_extensions.cmake;.github/config/out_of_tree_extensions.cmake"
133: else ifeq (${BUILD_ALL_IT_EXT}, 1)
134: 	CMAKE_VARS:=${CMAKE_VARS} -DDUCKDB_EXTENSION_CONFIGS=".github/config/in_tree_extensions.cmake"
135: else ifeq (${BUILD_ALL_OOT_EXT}, 1)
136: 	CMAKE_VARS:=${CMAKE_VARS} -DDUCKDB_EXTENSION_CONFIGS=".github/config/out_of_tree_extensions.cmake"
137: endif
138: ifeq (${STATIC_OPENSSL}, 1)
139: 	CMAKE_VARS:=${CMAKE_VARS} -DOPENSSL_USE_STATIC_LIBS=1
140: endif
141: ifeq (${BUILD_TPCE}, 1)
142: 	CMAKE_VARS:=${CMAKE_VARS} -DBUILD_TPCE=1
143: endif
144: ifeq (${BUILD_PYTHON}, 1)
145: 	CMAKE_VARS:=${CMAKE_VARS} -DBUILD_PYTHON=1 -DDUCKDB_EXTENSION_CONFIGS="tools/pythonpkg/duckdb_extension_config.cmake"
146: endif
147: ifeq (${PYTHON_USER_SPACE}, 1)
148: 	CMAKE_VARS:=${CMAKE_VARS} -DUSER_SPACE=1
149: endif
150: ifeq (${PYTHON_EDITABLE_BUILD}, 1)
151: 	CMAKE_VARS:=${CMAKE_VARS} -DPYTHON_EDITABLE_BUILD=1
152: endif
153: ifeq (${CONFIGURE_R}, 1)
154: 	CMAKE_VARS:=${CMAKE_VARS} -DCONFIGURE_R=1
155: endif
156: ifneq ($(TIDY_THREADS),)
157: 	TIDY_THREAD_PARAMETER := -j ${TIDY_THREADS}
158: endif
159: ifneq ($(TIDY_BINARY),)
160: 	TIDY_BINARY_PARAMETER := -clang-tidy-binary ${TIDY_BINARY}
161: endif
162: ifneq ($(TIDY_CHECKS),)
163:         TIDY_PERFORM_CHECKS := '-checks=${TIDY_CHECKS}'
164: endif
165: ifneq ("${FORCE_QUERY_LOG}a", "a")
166: 	CMAKE_VARS:=${CMAKE_VARS} -DFORCE_QUERY_LOG=${FORCE_QUERY_LOG}
167: endif
168: ifneq ($(BUILD_EXTENSIONS),)
169: 	CMAKE_VARS:=${CMAKE_VARS} -DBUILD_EXTENSIONS="$(BUILD_EXTENSIONS)"
170: endif
171: ifneq ($(CORE_EXTENSIONS),)
172: 	CMAKE_VARS:=${CMAKE_VARS} -DCORE_EXTENSIONS="$(CORE_EXTENSIONS)"
173: endif
174: ifneq ($(SKIP_EXTENSIONS),)
175: 	CMAKE_VARS:=${CMAKE_VARS} -DSKIP_EXTENSIONS="$(SKIP_EXTENSIONS)"
176: endif
177: ifneq ($(EXTENSION_CONFIGS),)
178: 	CMAKE_VARS:=${CMAKE_VARS} -DDUCKDB_EXTENSION_CONFIGS="$(EXTENSION_CONFIGS)"
179: endif
180: ifeq ($(EXTENSION_TESTS_ONLY), 1)
181: 	CMAKE_VARS:=${CMAKE_VARS} -DEXTENSION_TESTS_ONLY=1
182: endif
183: ifneq ($(EXTRA_CMAKE_VARIABLES),)
184: 	CMAKE_VARS:=${CMAKE_VARS} ${EXTRA_CMAKE_VARIABLES}
185: endif
186: ifeq (${CRASH_ON_ASSERT}, 1)
187: 	CMAKE_VARS:=${CMAKE_VARS} -DASSERT_EXCEPTION=0
188: endif
189: ifeq (${DISABLE_STRING_INLINE}, 1)
190: 	CMAKE_VARS:=${CMAKE_VARS} -DDISABLE_STR_INLINE=1
191: endif
192: ifeq (${DISABLE_MEMORY_SAFETY}, 1)
193: 	CMAKE_VARS:=${CMAKE_VARS} -DDISABLE_MEMORY_SAFETY=1
194: endif
195: ifeq (${DISABLE_ASSERTIONS}, 1)
196: 	CMAKE_VARS:=${CMAKE_VARS} -DDISABLE_ASSERTIONS=1
197: endif
198: ifeq (${DESTROY_UNPINNED_BLOCKS}, 1)
199: 	CMAKE_VARS:=${CMAKE_VARS} -DDESTROY_UNPINNED_BLOCKS=1
200: endif
201: ifeq (${FORCE_ASYNC_SINK_SOURCE}, 1)
202: 	CMAKE_VARS:=${CMAKE_VARS} -DFORCE_ASYNC_SINK_SOURCE=1
203: endif
204: ifeq (${RUN_SLOW_VERIFIERS}, 1)
205: 	CMAKE_VARS:=${CMAKE_VARS} -DRUN_SLOW_VERIFIERS=1
206: endif
207: ifeq (${ALTERNATIVE_VERIFY}, 1)
208: 	CMAKE_VARS:=${CMAKE_VARS} -DALTERNATIVE_VERIFY=1
209: endif
210: ifeq (${LATEST_STORAGE}, 1)
211: 	CMAKE_VARS:=${CMAKE_VARS} -DLATEST_STORAGE=1
212: endif
213: ifeq (${BLOCK_VERIFICATION}, 1)
214: 	CMAKE_VARS:=${CMAKE_VARS} -DBLOCK_VERIFICATION=1
215: endif
216: ifneq (${VERIFY_VECTOR}, )
217: 	CMAKE_VARS:=${CMAKE_VARS} -DVERIFY_VECTOR=${VERIFY_VECTOR}
218: endif
219: ifeq (${DEBUG_MOVE}, 1)
220: 	CMAKE_VARS:=${CMAKE_VARS} -DDEBUG_MOVE=1
221: endif
222: ifeq (${DEBUG_ALLOCATION}, 1)
223: 	CMAKE_VARS:=${CMAKE_VARS} -DDEBUG_ALLOCATION=1
224: endif
225: ifeq (${DEBUG_STACKTRACE}, 1)
226: 	CMAKE_VARS:=${CMAKE_VARS} -DDEBUG_STACKTRACE=1
227: endif
228: ifeq (${DISABLE_CORE_FUNCTIONS}, 1)
229: 	CMAKE_VARS:=${CMAKE_VARS} -DBUILD_CORE_FUNCTIONS_EXTENSION=0
230: endif
231: ifeq (${DISABLE_EXTENSION_LOAD}, 1)
232: 	CMAKE_VARS:=${CMAKE_VARS} -DDISABLE_EXTENSION_LOAD=1
233: endif
234: CMAKE_VARS:=${CMAKE_VARS} -DLOCAL_EXTENSION_REPO="${LOCAL_EXTENSION_REPO}"
235: ifneq (${OSX_BUILD_ARCH}, )
236: 	CMAKE_VARS:=${CMAKE_VARS} -DOSX_BUILD_ARCH=${OSX_BUILD_ARCH}
237: endif
238: ifeq (${OSX_BUILD_UNIVERSAL}, 1)
239: 	CMAKE_VARS:=${CMAKE_VARS} -DOSX_BUILD_UNIVERSAL=1
240: endif
241: ifneq ("${CUSTOM_LINKER}", "")
242: 	CMAKE_VARS:=${CMAKE_VARS} -DCUSTOM_LINKER=${CUSTOM_LINKER}
243: endif
244: ifdef SKIP_PLATFORM_UTIL
245: 	CMAKE_VARS:=${CMAKE_VARS} -DSKIP_PLATFORM_UTIL=1
246: endif
247: ifdef DEBUG_STACKTRACE
248: 	CMAKE_VARS:=${CMAKE_VARS} -DDEBUG_STACKTRACE=1
249: endif
250: 
251: # Optional overrides
252: ifneq (${STANDARD_VECTOR_SIZE}, )
253: 	CMAKE_VARS:=${CMAKE_VARS} -DSTANDARD_VECTOR_SIZE=${STANDARD_VECTOR_SIZE}
254: endif
255: ifneq (${BLOCK_ALLOC_SIZE}, )
256: 	CMAKE_VARS:=${CMAKE_VARS} -DBLOCK_ALLOC_SIZE=${BLOCK_ALLOC_SIZE}
257: endif
258: 
259: # Enable VCPKG for this build
260: ifneq ("${VCPKG_TOOLCHAIN_PATH}", "")
261: 	CMAKE_VARS_BUILD:=${CMAKE_VARS_BUILD} -DCMAKE_TOOLCHAIN_FILE='${VCPKG_TOOLCHAIN_PATH}' -DVCPKG_BUILD=1
262: endif
263: ifneq ("${VCPKG_TARGET_TRIPLET}", "")
264: 	CMAKE_VARS_BUILD:=${CMAKE_VARS_BUILD} -DVCPKG_TARGET_TRIPLET='${VCPKG_TARGET_TRIPLET}'
265: endif
266: ifeq (${USE_MERGED_VCPKG_MANIFEST}, 1)
267: 	CMAKE_VARS:=${CMAKE_VARS} -DVCPKG_MANIFEST_DIR='${PROJ_DIR}build/extension_configuration'
268: endif
269: 
270: ifneq ("${LTO}", "")
271: 	CMAKE_VARS:=${CMAKE_VARS} -DCMAKE_LTO='${LTO}'
272: endif
273: ifneq ("${CMAKE_LLVM_PATH}", "")
274: 	CMAKE_VARS:=${CMAKE_VARS} -DCMAKE_RANLIB='${CMAKE_LLVM_PATH}/bin/llvm-ranlib' -DCMAKE_AR='${CMAKE_LLVM_PATH}/bin/llvm-ar' -DCMAKE_CXX_COMPILER='${CMAKE_LLVM_PATH}/bin/clang++' -DCMAKE_C_COMPILER='${CMAKE_LLVM_PATH}/bin/clang'
275: endif
276: 
277: CMAKE_VARS:=${CMAKE_VARS} ${COMMON_CMAKE_VARS}
278: 
279: ifdef DUCKDB_PLATFORM
280: 	ifneq ("${DUCKDB_PLATFORM}", "")
281: 		CMAKE_VARS:=${CMAKE_VARS} -DDUCKDB_EXPLICIT_PLATFORM='${DUCKDB_PLATFORM}'
282: 	endif
283: endif
284: 
285: clean:
286: 	rm -rf build
287: 
288: clean-python:
289: 	tools/pythonpkg/clean.sh
290: 
291: debug: ${EXTENSION_CONFIG_STEP}
292: 	mkdir -p ./build/debug && \
293: 	cd build/debug && \
294: 	echo ${DUCKDB_EXTENSION_SUBSTRAIT_PATH} && \
295: 	cmake $(GENERATOR) $(FORCE_COLOR) ${WARNINGS_AS_ERRORS} ${FORCE_32_BIT_FLAG} ${DISABLE_UNITY_FLAG} ${DISABLE_SANITIZER_FLAG} ${STATIC_LIBCPP} ${CMAKE_VARS} ${CMAKE_VARS_BUILD} -DDEBUG_MOVE=1 -DCMAKE_BUILD_TYPE=Debug ../.. && \
296: 	cmake --build . --config Debug
297: 
298: release: ${EXTENSION_CONFIG_STEP}
299: 	mkdir -p ./build/release && \
300: 	cd build/release && \
301: 	cmake $(GENERATOR) $(FORCE_COLOR) ${WARNINGS_AS_ERRORS} ${FORCE_WARN_UNUSED_FLAG} ${FORCE_32_BIT_FLAG} ${DISABLE_UNITY_FLAG} ${DISABLE_SANITIZER_FLAG} ${STATIC_LIBCPP} ${CMAKE_VARS} ${CMAKE_VARS_BUILD} -DCMAKE_BUILD_TYPE=Release ../.. && \
302: 	cmake --build . --config Release
303: 
304: wasm_mvp: ${EXTENSION_CONFIG_STEP}
305: 	mkdir -p ./build/wasm_mvp && \
306: 	emcmake cmake $(GENERATOR) -DWASM_LOADABLE_EXTENSIONS=1 -DBUILD_EXTENSIONS_ONLY=1 -Bbuild/wasm_mvp -DCMAKE_CXX_FLAGS="-DDUCKDB_CUSTOM_PLATFORM=wasm_mvp" -DDUCKDB_EXPLICIT_PLATFORM="wasm_mvp" ${COMMON_CMAKE_VARS} ${TOOLCHAIN_FLAGS} && \
307: 	emmake make -j8 -Cbuild/wasm_mvp
308: 
309: wasm_eh: ${EXTENSION_CONFIG_STEP}
310: 	mkdir -p ./build/wasm_eh && \
311: 	emcmake cmake $(GENERATOR) -DWASM_LOADABLE_EXTENSIONS=1 -DBUILD_EXTENSIONS_ONLY=1 -Bbuild/wasm_eh -DCMAKE_CXX_FLAGS="-fwasm-exceptions -DWEBDB_FAST_EXCEPTIONS=1 -DDUCKDB_CUSTOM_PLATFORM=wasm_eh" -DDUCKDB_EXPLICIT_PLATFORM="wasm_eh" ${COMMON_CMAKE_VARS} ${TOOLCHAIN_FLAGS} && \
312: 	emmake make -j8 -Cbuild/wasm_eh
313: 
314: wasm_threads: ${EXTENSION_CONFIG_STEP}
315: 	mkdir -p ./build/wasm_threads && \
316: 	emcmake cmake $(GENERATOR) -DWASM_LOADABLE_EXTENSIONS=1 -DBUILD_EXTENSIONS_ONLY=1 -Bbuild/wasm_threads -DCMAKE_CXX_FLAGS="-fwasm-exceptions -DWEBDB_FAST_EXCEPTIONS=1 -DWITH_WASM_THREADS=1 -DWITH_WASM_SIMD=1 -DWITH_WASM_BULK_MEMORY=1 -DDUCKDB_CUSTOM_PLATFORM=wasm_threads -pthread" -DDUCKDB_EXPLICIT_PLATFORM="wasm_threads" ${COMMON_CMAKE_VARS} -DUSE_WASM_THREADS=1 -DCMAKE_C_FLAGS="-pthread" ${TOOLCHAIN_FLAGS} && \
317: 	emmake make -j8 -Cbuild/wasm_threads
318: 
319: cldebug: ${EXTENSION_CONFIG_STEP}
320: 	mkdir -p ./build/cldebug && \
321: 	cd build/cldebug && \
322: 	cmake $(GENERATOR) $(FORCE_COLOR) ${WARNINGS_AS_ERRORS} ${FORCE_32_BIT_FLAG} ${DISABLE_UNITY_FLAG} ${CMAKE_VARS} ${CMAKE_VARS_BUILD} -DBUILD_PYTHON=1 -DENABLE_SANITIZER=0 -DENABLE_UBSAN=0 -DCMAKE_BUILD_TYPE=Debug ../.. && \
323: 	cmake --build . --config Debug
324: 
325: clreldebug:
326: 	mkdir -p ./build/clreldebug && \
327: 	cd build/clreldebug && \
328: 	cmake $(GENERATOR) $(FORCE_COLOR) ${WARNINGS_AS_ERRORS} ${FORCE_32_BIT_FLAG} ${DISABLE_UNITY_FLAG} ${STATIC_LIBCPP} ${CMAKE_VARS} -DBUILD_PYTHON=1 -DBUILD_FTS_EXTENSION=1 -DENABLE_SANITIZER=0 -DENABLE_UBSAN=0 -DCMAKE_BUILD_TYPE=RelWithDebInfo ../.. && \
329: 	cmake --build . --config RelWithDebInfo
330: 
331: extension_configuration: build/extension_configuration/vcpkg.json
332: 
333: extension/extension_config_local.cmake:
334: 	touch extension/extension_config_local.cmake
335: 
336: build/extension_configuration/vcpkg.json: extension/extension_config_local.cmake extension/extension_config.cmake
337: 	mkdir -p ./build/extension_configuration && \
338: 	cd build/extension_configuration && \
339: 	cmake $(GENERATOR) $(FORCE_COLOR) ${CMAKE_VARS} -DEXTENSION_CONFIG_BUILD=TRUE -DVCPKG_BUILD=1 -DCMAKE_BUILD_TYPE=Debug ../.. && \
340: 	cmake --build . --config RelWithDebInfo
341: 
342: unittest: debug
343: 	build/debug/test/unittest
344: 	build/debug/tools/sqlite3_api_wrapper/test_sqlite3_api_wrapper
345: 
346: unittest_release: release
347: 	build/release/test/unittest
348: 	build/release/tools/sqlite3_api_wrapper/test_sqlite3_api_wrapper
349: 
350: unittestci:
351: 	python3 scripts/run_tests_one_by_one.py build/debug/test/unittest
352: 	build/debug/tools/sqlite3_api_wrapper/test_sqlite3_api_wrapper
353: 
354: unittestarrow:
355: 	build/debug/test/unittest "[arrow]"
356: 
357: 
358: allunit: release # uses release build because otherwise allunit takes forever
359: 	build/release/test/unittest "*"
360: 
361: docs:
362: 	mkdir -p ./build/docs && \
363: 	doxygen Doxyfile
364: 
365: doxygen: docs
366: 	open build/docs/html/index.html
367: 
368: reldebug: ${EXTENSION_CONFIG_STEP}
369: 	mkdir -p ./build/reldebug && \
370: 	cd build/reldebug && \
371: 	cmake $(GENERATOR) $(FORCE_COLOR) ${WARNINGS_AS_ERRORS} ${FORCE_32_BIT_FLAG} ${DISABLE_UNITY_FLAG} ${DISABLE_SANITIZER_FLAG} ${STATIC_LIBCPP} ${CMAKE_VARS} ${CMAKE_VARS_BUILD} -DCMAKE_BUILD_TYPE=RelWithDebInfo ../.. && \
372: 	cmake --build . --config RelWithDebInfo
373: 
374: relassert: ${EXTENSION_CONFIG_STEP}
375: 	mkdir -p ./build/relassert && \
376: 	cd build/relassert && \
377: 	cmake $(GENERATOR) $(FORCE_COLOR) ${WARNINGS_AS_ERRORS} ${FORCE_32_BIT_FLAG} ${DISABLE_UNITY_FLAG} ${DISABLE_SANITIZER_FLAG} ${STATIC_LIBCPP} ${CMAKE_VARS} ${CMAKE_VARS_BUILD} -DFORCE_ASSERT=1 -DCMAKE_BUILD_TYPE=RelWithDebInfo ../.. && \
378: 	cmake --build . --config RelWithDebInfo
379: 
380: benchmark:
381: 	mkdir -p ./build/release && \
382: 	cd build/release && \
383: 	cmake $(GENERATOR) $(FORCE_COLOR) ${WARNINGS_AS_ERRORS} ${FORCE_WARN_UNUSED_FLAG} ${FORCE_32_BIT_FLAG} ${DISABLE_UNITY_FLAG} ${DISABLE_SANITIZER_FLAG} ${STATIC_LIBCPP} ${CMAKE_VARS} -DBUILD_BENCHMARKS=1 -DCMAKE_BUILD_TYPE=Release ../.. && \
384: 	cmake --build . --config Release
385: 
386: amaldebug:
387: 	mkdir -p ./build/amaldebug && \
388: 	python3 scripts/amalgamation.py && \
389: 	cd build/amaldebug && \
390: 	cmake $(GENERATOR) $(FORCE_COLOR) ${STATIC_LIBCPP} ${CMAKE_VARS} ${FORCE_32_BIT_FLAG} -DAMALGAMATION_BUILD=1 -DCMAKE_BUILD_TYPE=Debug ../.. && \
391: 	cmake --build . --config Debug
392: 
393: tidy-check:
394: 	mkdir -p ./build/tidy && \
395: 	cd build/tidy && \
396: 	cmake -DCLANG_TIDY=1 -DDISABLE_UNITY=1 -DBUILD_EXTENSIONS=parquet -DBUILD_PYTHON_PKG=TRUE -DBUILD_SHELL=0 ../.. && \
397: 	python3 ../../scripts/run-clang-tidy.py -quiet ${TIDY_THREAD_PARAMETER} ${TIDY_BINARY_PARAMETER} ${TIDY_PERFORM_CHECKS}
398: 
399: tidy-check-diff:
400: 	mkdir -p ./build/tidy && \
401: 	cd build/tidy && \
402: 	cmake -DCLANG_TIDY=1 -DDISABLE_UNITY=1 -DBUILD_EXTENSIONS=parquet -DBUILD_PYTHON_PKG=TRUE -DBUILD_SHELL=0 ../.. && \
403: 	cd ../../ && \
404: 	git diff origin/main . ':(exclude)tools' ':(exclude)extension' ':(exclude)test' ':(exclude)benchmark' ':(exclude)third_party' ':(exclude)src/common/adbc' ':(exclude)src/main/capi' | python3 scripts/clang-tidy-diff.py -path build/tidy -quiet ${TIDY_THREAD_PARAMETER} ${TIDY_BINARY_PARAMETER} ${TIDY_PERFORM_CHECKS} -p1
405: 
406: tidy-fix:
407: 	mkdir -p ./build/tidy && \
408: 	cd build/tidy && \
409: 	cmake -DCLANG_TIDY=1 -DDISABLE_UNITY=1 -DBUILD_EXTENSIONS=parquet -DBUILD_SHELL=0 ../.. && \
410: 	python3 ../../scripts/run-clang-tidy.py -fix
411: 
412: test_compile: # test compilation of individual cpp files
413: 	python3 scripts/amalgamation.py --compile
414: 
415: format-check:
416: 	python3 scripts/format.py --all --check
417: 
418: format-check-silent:
419: 	python3 scripts/format.py --all --check --silent
420: 
421: format-fix:
422: 	rm -rf src/amalgamation/*
423: 	python3 scripts/format.py --all --fix --noconfirm
424: 
425: format-head:
426: 	python3 scripts/format.py HEAD --fix --noconfirm
427: 
428: format-changes:
429: 	python3 scripts/format.py HEAD --fix --noconfirm
430: 
431: format-main:
432: 	python3 scripts/format.py main --fix --noconfirm
433: 
434: format-feature:
435: 	python3 scripts/format.py feature --fix --noconfirm
436: 
437: third_party/sqllogictest:
438: 	git clone --depth=1 --branch hawkfish-statistical-rounding https://github.com/cwida/sqllogictest.git third_party/sqllogictest
439: 
440: sqlite: release | third_party/sqllogictest
441: 	git --git-dir third_party/sqllogictest/.git pull
442: 	./build/release/test/unittest "[sqlitelogic]"
443: 
444: sqlsmith: debug
445: 	./build/debug/third_party/sqlsmith/sqlsmith --duckdb=:memory:
446: 
447: # Bloaty: a size profiler for binaries, is a project backed by Google engineers, https://github.com/google/bloaty for more info
448: # works both on executable, libraries (-> .duckdb_extension) and on WebAssembly
449: bloaty/bloaty:
450: 	git clone https://github.com/google/bloaty.git
451: 	cd bloaty && git submodule update --init --recursive && cmake -Bm build -G Ninja -S . && cmake --build build
452: 	mv bloaty/build/bloaty bloaty/bloaty
453: 
454: bloaty: reldebug bloaty/bloaty
455: 	cd build/reldebug && dsymutil duckdb
456: 	./bloaty/bloaty  build/reldebug/duckdb -d symbols -n 20 --debug-file=build/reldebug/duckdb.dSYM/Contents/Resources/DWARF/duckdb
457: 	# ./bloaty/bloaty  build/reldebug/extension/parquet/parquet.duckdb_extension -d symbols -n 20 # to execute on extension
458: 
459: clangd:
460: 	cmake -DCMAKE_BUILD_TYPE=Debug ${CMAKE_VARS} -B build/clangd .
461: 
462: coverage-check:
463: 	./scripts/coverage_check.sh
464: 
465: generate-files:
466: 	python3 scripts/generate_c_api.py
467: 	python3 scripts/generate_functions.py
468: 	python3 scripts/generate_serialization.py
469: 	python3 scripts/generate_enum_util.py
470: 	-@python3 tools/pythonpkg/scripts/generate_connection_code.py || echo "Warning: generate_connection_code.py failed, cxxheaderparser & pcpp are required to perform this step"
471: # Run the formatter again after (re)generating the files
472: 	$(MAKE) format-main
473: 
474: bundle-library: release
475: 	cd build/release && \
476: 	mkdir -p bundle && \
477: 	cp src/libduckdb_static.a bundle/. && \
478: 	cp third_party/*/libduckdb_*.a bundle/. && \
479: 	cp extension/*/lib*_extension.a bundle/. && \
480: 	cd bundle && \
481: 	find . -name '*.a' -exec ${AR} -x {} \; && \
482: 	${AR} cr ../libduckdb_bundle.a *.o
[end of Makefile]
[start of src/catalog/catalog.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: 
3: #include "duckdb/catalog/catalog_search_path.hpp"
4: #include "duckdb/catalog/catalog_entry/list.hpp"
5: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
6: #include "duckdb/catalog/catalog_set.hpp"
7: #include "duckdb/catalog/default/default_schemas.hpp"
8: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
9: #include "duckdb/common/exception.hpp"
10: #include "duckdb/main/client_context.hpp"
11: #include "duckdb/main/client_data.hpp"
12: #include "duckdb/main/database.hpp"
13: #include "duckdb/parser/expression/function_expression.hpp"
14: #include "duckdb/main/extension_helper.hpp"
15: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
16: #include "duckdb/parser/parsed_data/create_aggregate_function_info.hpp"
17: #include "duckdb/parser/parsed_data/create_collation_info.hpp"
18: #include "duckdb/parser/parsed_data/create_copy_function_info.hpp"
19: #include "duckdb/parser/parsed_data/create_index_info.hpp"
20: #include "duckdb/parser/parsed_data/create_pragma_function_info.hpp"
21: #include "duckdb/parser/parsed_data/create_secret_info.hpp"
22: #include "duckdb/parser/parsed_data/create_scalar_function_info.hpp"
23: #include "duckdb/parser/parsed_data/create_schema_info.hpp"
24: #include "duckdb/parser/parsed_data/create_sequence_info.hpp"
25: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
26: #include "duckdb/parser/parsed_data/create_type_info.hpp"
27: #include "duckdb/parser/parsed_data/create_view_info.hpp"
28: #include "duckdb/parser/parsed_data/drop_info.hpp"
29: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
30: #include "duckdb/planner/binder.hpp"
31: #include "duckdb/catalog/default/default_types.hpp"
32: #include "duckdb/main/extension_entries.hpp"
33: #include "duckdb/main/extension/generated_extension_loader.hpp"
34: #include "duckdb/main/connection.hpp"
35: #include "duckdb/main/attached_database.hpp"
36: #include "duckdb/main/database_manager.hpp"
37: #include "duckdb/function/built_in_functions.hpp"
38: #include "duckdb/catalog/similar_catalog_entry.hpp"
39: #include "duckdb/storage/database_size.hpp"
40: #include <algorithm>
41: 
42: namespace duckdb {
43: 
44: Catalog::Catalog(AttachedDatabase &db) : db(db) {
45: }
46: 
47: Catalog::~Catalog() {
48: }
49: 
50: DatabaseInstance &Catalog::GetDatabase() {
51: 	return db.GetDatabase();
52: }
53: 
54: AttachedDatabase &Catalog::GetAttached() {
55: 	return db;
56: }
57: 
58: const AttachedDatabase &Catalog::GetAttached() const {
59: 	return db;
60: }
61: 
62: const string &Catalog::GetName() const {
63: 	return GetAttached().GetName();
64: }
65: 
66: idx_t Catalog::GetOid() {
67: 	return GetAttached().oid;
68: }
69: 
70: Catalog &Catalog::GetSystemCatalog(ClientContext &context) {
71: 	return Catalog::GetSystemCatalog(*context.db);
72: }
73: 
74: optional_ptr<Catalog> Catalog::GetCatalogEntry(ClientContext &context, const string &catalog_name) {
75: 	auto &db_manager = DatabaseManager::Get(context);
76: 	if (catalog_name == TEMP_CATALOG) {
77: 		return &ClientData::Get(context).temporary_objects->GetCatalog();
78: 	}
79: 	if (catalog_name == SYSTEM_CATALOG) {
80: 		return &GetSystemCatalog(context);
81: 	}
82: 	auto entry = db_manager.GetDatabase(
83: 	    context, IsInvalidCatalog(catalog_name) ? DatabaseManager::GetDefaultDatabase(context) : catalog_name);
84: 	if (!entry) {
85: 		return nullptr;
86: 	}
87: 	return &entry->GetCatalog();
88: }
89: 
90: Catalog &Catalog::GetCatalog(ClientContext &context, const string &catalog_name) {
91: 	auto catalog = Catalog::GetCatalogEntry(context, catalog_name);
92: 	if (!catalog) {
93: 		throw BinderException("Catalog \"%s\" does not exist!", catalog_name);
94: 	}
95: 	return *catalog;
96: }
97: 
98: //===--------------------------------------------------------------------===//
99: // Schema
100: //===--------------------------------------------------------------------===//
101: optional_ptr<CatalogEntry> Catalog::CreateSchema(ClientContext &context, CreateSchemaInfo &info) {
102: 	return CreateSchema(GetCatalogTransaction(context), info);
103: }
104: 
105: CatalogTransaction Catalog::GetCatalogTransaction(ClientContext &context) {
106: 	return CatalogTransaction(*this, context);
107: }
108: 
109: //===--------------------------------------------------------------------===//
110: // Table
111: //===--------------------------------------------------------------------===//
112: optional_ptr<CatalogEntry> Catalog::CreateTable(ClientContext &context, BoundCreateTableInfo &info) {
113: 	return CreateTable(GetCatalogTransaction(context), info);
114: }
115: 
116: optional_ptr<CatalogEntry> Catalog::CreateTable(ClientContext &context, unique_ptr<CreateTableInfo> info) {
117: 	auto binder = Binder::CreateBinder(context);
118: 	auto bound_info = binder->BindCreateTableInfo(std::move(info));
119: 	return CreateTable(context, *bound_info);
120: }
121: 
122: optional_ptr<CatalogEntry> Catalog::CreateTable(CatalogTransaction transaction, SchemaCatalogEntry &schema,
123:                                                 BoundCreateTableInfo &info) {
124: 	return schema.CreateTable(transaction, info);
125: }
126: 
127: optional_ptr<CatalogEntry> Catalog::CreateTable(CatalogTransaction transaction, BoundCreateTableInfo &info) {
128: 	auto &schema = GetSchema(transaction, info.base->schema);
129: 	return CreateTable(transaction, schema, info);
130: }
131: 
132: //===--------------------------------------------------------------------===//
133: // View
134: //===--------------------------------------------------------------------===//
135: optional_ptr<CatalogEntry> Catalog::CreateView(CatalogTransaction transaction, CreateViewInfo &info) {
136: 	auto &schema = GetSchema(transaction, info.schema);
137: 	return CreateView(transaction, schema, info);
138: }
139: 
140: optional_ptr<CatalogEntry> Catalog::CreateView(ClientContext &context, CreateViewInfo &info) {
141: 	return CreateView(GetCatalogTransaction(context), info);
142: }
143: 
144: optional_ptr<CatalogEntry> Catalog::CreateView(CatalogTransaction transaction, SchemaCatalogEntry &schema,
145:                                                CreateViewInfo &info) {
146: 	return schema.CreateView(transaction, info);
147: }
148: 
149: //===--------------------------------------------------------------------===//
150: // Sequence
151: //===--------------------------------------------------------------------===//
152: optional_ptr<CatalogEntry> Catalog::CreateSequence(CatalogTransaction transaction, CreateSequenceInfo &info) {
153: 	auto &schema = GetSchema(transaction, info.schema);
154: 	return CreateSequence(transaction, schema, info);
155: }
156: 
157: optional_ptr<CatalogEntry> Catalog::CreateSequence(ClientContext &context, CreateSequenceInfo &info) {
158: 	return CreateSequence(GetCatalogTransaction(context), info);
159: }
160: 
161: optional_ptr<CatalogEntry> Catalog::CreateSequence(CatalogTransaction transaction, SchemaCatalogEntry &schema,
162:                                                    CreateSequenceInfo &info) {
163: 	return schema.CreateSequence(transaction, info);
164: }
165: 
166: //===--------------------------------------------------------------------===//
167: // Type
168: //===--------------------------------------------------------------------===//
169: optional_ptr<CatalogEntry> Catalog::CreateType(CatalogTransaction transaction, CreateTypeInfo &info) {
170: 	auto &schema = GetSchema(transaction, info.schema);
171: 	return CreateType(transaction, schema, info);
172: }
173: 
174: optional_ptr<CatalogEntry> Catalog::CreateType(ClientContext &context, CreateTypeInfo &info) {
175: 	return CreateType(GetCatalogTransaction(context), info);
176: }
177: 
178: optional_ptr<CatalogEntry> Catalog::CreateType(CatalogTransaction transaction, SchemaCatalogEntry &schema,
179:                                                CreateTypeInfo &info) {
180: 	return schema.CreateType(transaction, info);
181: }
182: 
183: //===--------------------------------------------------------------------===//
184: // Table Function
185: //===--------------------------------------------------------------------===//
186: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(CatalogTransaction transaction, CreateTableFunctionInfo &info) {
187: 	auto &schema = GetSchema(transaction, info.schema);
188: 	return CreateTableFunction(transaction, schema, info);
189: }
190: 
191: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(ClientContext &context, CreateTableFunctionInfo &info) {
192: 	return CreateTableFunction(GetCatalogTransaction(context), info);
193: }
194: 
195: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
196:                                                         CreateTableFunctionInfo &info) {
197: 	return schema.CreateTableFunction(transaction, info);
198: }
199: 
200: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(ClientContext &context,
201:                                                         optional_ptr<CreateTableFunctionInfo> info) {
202: 	return CreateTableFunction(context, *info);
203: }
204: 
205: //===--------------------------------------------------------------------===//
206: // Copy Function
207: //===--------------------------------------------------------------------===//
208: optional_ptr<CatalogEntry> Catalog::CreateCopyFunction(CatalogTransaction transaction, CreateCopyFunctionInfo &info) {
209: 	auto &schema = GetSchema(transaction, info.schema);
210: 	return CreateCopyFunction(transaction, schema, info);
211: }
212: 
213: optional_ptr<CatalogEntry> Catalog::CreateCopyFunction(ClientContext &context, CreateCopyFunctionInfo &info) {
214: 	return CreateCopyFunction(GetCatalogTransaction(context), info);
215: }
216: 
217: optional_ptr<CatalogEntry> Catalog::CreateCopyFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
218:                                                        CreateCopyFunctionInfo &info) {
219: 	return schema.CreateCopyFunction(transaction, info);
220: }
221: 
222: //===--------------------------------------------------------------------===//
223: // Pragma Function
224: //===--------------------------------------------------------------------===//
225: optional_ptr<CatalogEntry> Catalog::CreatePragmaFunction(CatalogTransaction transaction,
226:                                                          CreatePragmaFunctionInfo &info) {
227: 	auto &schema = GetSchema(transaction, info.schema);
228: 	return CreatePragmaFunction(transaction, schema, info);
229: }
230: 
231: optional_ptr<CatalogEntry> Catalog::CreatePragmaFunction(ClientContext &context, CreatePragmaFunctionInfo &info) {
232: 	return CreatePragmaFunction(GetCatalogTransaction(context), info);
233: }
234: 
235: optional_ptr<CatalogEntry> Catalog::CreatePragmaFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
236:                                                          CreatePragmaFunctionInfo &info) {
237: 	return schema.CreatePragmaFunction(transaction, info);
238: }
239: 
240: //===--------------------------------------------------------------------===//
241: // Function
242: //===--------------------------------------------------------------------===//
243: optional_ptr<CatalogEntry> Catalog::CreateFunction(CatalogTransaction transaction, CreateFunctionInfo &info) {
244: 	auto &schema = GetSchema(transaction, info.schema);
245: 	return CreateFunction(transaction, schema, info);
246: }
247: 
248: optional_ptr<CatalogEntry> Catalog::CreateFunction(ClientContext &context, CreateFunctionInfo &info) {
249: 	return CreateFunction(GetCatalogTransaction(context), info);
250: }
251: 
252: optional_ptr<CatalogEntry> Catalog::CreateFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
253:                                                    CreateFunctionInfo &info) {
254: 	return schema.CreateFunction(transaction, info);
255: }
256: 
257: optional_ptr<CatalogEntry> Catalog::AddFunction(ClientContext &context, CreateFunctionInfo &info) {
258: 	info.on_conflict = OnCreateConflict::ALTER_ON_CONFLICT;
259: 	return CreateFunction(context, info);
260: }
261: 
262: //===--------------------------------------------------------------------===//
263: // Collation
264: //===--------------------------------------------------------------------===//
265: optional_ptr<CatalogEntry> Catalog::CreateCollation(CatalogTransaction transaction, CreateCollationInfo &info) {
266: 	auto &schema = GetSchema(transaction, info.schema);
267: 	return CreateCollation(transaction, schema, info);
268: }
269: 
270: optional_ptr<CatalogEntry> Catalog::CreateCollation(ClientContext &context, CreateCollationInfo &info) {
271: 	return CreateCollation(GetCatalogTransaction(context), info);
272: }
273: 
274: optional_ptr<CatalogEntry> Catalog::CreateCollation(CatalogTransaction transaction, SchemaCatalogEntry &schema,
275:                                                     CreateCollationInfo &info) {
276: 	return schema.CreateCollation(transaction, info);
277: }
278: 
279: //===--------------------------------------------------------------------===//
280: // Index
281: //===--------------------------------------------------------------------===//
282: optional_ptr<CatalogEntry> Catalog::CreateIndex(CatalogTransaction transaction, CreateIndexInfo &info) {
283: 	auto &schema = GetSchema(transaction, info.schema);
284: 	auto &table = schema.GetEntry(transaction, CatalogType::TABLE_ENTRY, info.table)->Cast<TableCatalogEntry>();
285: 	return schema.CreateIndex(transaction, info, table);
286: }
287: 
288: optional_ptr<CatalogEntry> Catalog::CreateIndex(ClientContext &context, CreateIndexInfo &info) {
289: 	return CreateIndex(GetCatalogTransaction(context), info);
290: }
291: 
292: //===--------------------------------------------------------------------===//
293: // Lookup Structures
294: //===--------------------------------------------------------------------===//
295: struct CatalogLookup {
296: 	CatalogLookup(Catalog &catalog, string schema_p) : catalog(catalog), schema(std::move(schema_p)) {
297: 	}
298: 
299: 	Catalog &catalog;
300: 	string schema;
301: };
302: 
303: //! Return value of Catalog::LookupEntry
304: struct CatalogEntryLookup {
305: 	optional_ptr<SchemaCatalogEntry> schema;
306: 	optional_ptr<CatalogEntry> entry;
307: 	ErrorData error;
308: 
309: 	DUCKDB_API bool Found() const {
310: 		return entry;
311: 	}
312: };
313: 
314: //===--------------------------------------------------------------------===//
315: // Generic
316: //===--------------------------------------------------------------------===//
317: void Catalog::DropEntry(ClientContext &context, DropInfo &info) {
318: 	if (info.type == CatalogType::SCHEMA_ENTRY) {
319: 		// DROP SCHEMA
320: 		DropSchema(context, info);
321: 		return;
322: 	}
323: 
324: 	auto lookup = LookupEntry(context, info.type, info.schema, info.name, info.if_not_found);
325: 
326: 	if (!lookup.Found()) {
327: 		return;
328: 	}
329: 
330: 	lookup.schema->DropEntry(context, info);
331: }
332: 
333: SchemaCatalogEntry &Catalog::GetSchema(ClientContext &context, const string &name, QueryErrorContext error_context) {
334: 	return *Catalog::GetSchema(context, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
335: }
336: 
337: optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(ClientContext &context, const string &schema_name,
338:                                                     OnEntryNotFound if_not_found, QueryErrorContext error_context) {
339: 	return GetSchema(GetCatalogTransaction(context), schema_name, if_not_found, error_context);
340: }
341: 
342: SchemaCatalogEntry &Catalog::GetSchema(ClientContext &context, const string &catalog_name, const string &schema_name,
343:                                        QueryErrorContext error_context) {
344: 	return *Catalog::GetSchema(context, catalog_name, schema_name, OnEntryNotFound::THROW_EXCEPTION, error_context);
345: }
346: 
347: SchemaCatalogEntry &Catalog::GetSchema(CatalogTransaction transaction, const string &name,
348:                                        QueryErrorContext error_context) {
349: 	return *GetSchema(transaction, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
350: }
351: 
352: //===--------------------------------------------------------------------===//
353: // Lookup
354: //===--------------------------------------------------------------------===//
355: SimilarCatalogEntry Catalog::SimilarEntryInSchemas(ClientContext &context, const string &entry_name, CatalogType type,
356:                                                    const reference_set_t<SchemaCatalogEntry> &schemas) {
357: 	SimilarCatalogEntry result;
358: 	for (auto schema_ref : schemas) {
359: 		auto &schema = schema_ref.get();
360: 		auto transaction = schema.catalog.GetCatalogTransaction(context);
361: 		auto entry = schema.GetSimilarEntry(transaction, type, entry_name);
362: 		if (!entry.Found()) {
363: 			// no similar entry found
364: 			continue;
365: 		}
366: 		if (!result.Found() || result.score < entry.score) {
367: 			result = entry;
368: 			result.schema = &schema;
369: 		}
370: 	}
371: 	return result;
372: }
373: 
374: vector<CatalogSearchEntry> GetCatalogEntries(ClientContext &context, const string &catalog, const string &schema) {
375: 	vector<CatalogSearchEntry> entries;
376: 	auto &search_path = *context.client_data->catalog_search_path;
377: 	if (IsInvalidCatalog(catalog) && IsInvalidSchema(schema)) {
378: 		// no catalog or schema provided - scan the entire search path
379: 		entries = search_path.Get();
380: 	} else if (IsInvalidCatalog(catalog)) {
381: 		auto catalogs = search_path.GetCatalogsForSchema(schema);
382: 		for (auto &catalog_name : catalogs) {
383: 			entries.emplace_back(catalog_name, schema);
384: 		}
385: 		if (entries.empty()) {
386: 			entries.emplace_back(DatabaseManager::GetDefaultDatabase(context), schema);
387: 		}
388: 	} else if (IsInvalidSchema(schema)) {
389: 		auto schemas = search_path.GetSchemasForCatalog(catalog);
390: 		for (auto &schema_name : schemas) {
391: 			entries.emplace_back(catalog, schema_name);
392: 		}
393: 		if (entries.empty()) {
394: 			entries.emplace_back(catalog, DEFAULT_SCHEMA);
395: 		}
396: 	} else {
397: 		// specific catalog and schema provided
398: 		entries.emplace_back(catalog, schema);
399: 	}
400: 	return entries;
401: }
402: 
403: void FindMinimalQualification(ClientContext &context, const string &catalog_name, const string &schema_name,
404:                               bool &qualify_database, bool &qualify_schema) {
405: 	// check if we can we qualify ONLY the schema
406: 	bool found = false;
407: 	auto entries = GetCatalogEntries(context, INVALID_CATALOG, schema_name);
408: 	for (auto &entry : entries) {
409: 		if (entry.catalog == catalog_name && entry.schema == schema_name) {
410: 			found = true;
411: 			break;
412: 		}
413: 	}
414: 	if (found) {
415: 		qualify_database = false;
416: 		qualify_schema = true;
417: 		return;
418: 	}
419: 	// check if we can qualify ONLY the catalog
420: 	found = false;
421: 	entries = GetCatalogEntries(context, catalog_name, INVALID_SCHEMA);
422: 	for (auto &entry : entries) {
423: 		if (entry.catalog == catalog_name && entry.schema == schema_name) {
424: 			found = true;
425: 			break;
426: 		}
427: 	}
428: 	if (found) {
429: 		qualify_database = true;
430: 		qualify_schema = false;
431: 		return;
432: 	}
433: 	// need to qualify both catalog and schema
434: 	qualify_database = true;
435: 	qualify_schema = true;
436: }
437: 
438: bool Catalog::TryAutoLoad(ClientContext &context, const string &original_name) noexcept {
439: 	string extension_name = ExtensionHelper::ApplyExtensionAlias(original_name);
440: 	if (context.db->ExtensionIsLoaded(extension_name)) {
441: 		return true;
442: 	}
443: #ifndef DUCKDB_DISABLE_EXTENSION_LOAD
444: 	auto &dbconfig = DBConfig::GetConfig(context);
445: 	if (!dbconfig.options.autoload_known_extensions) {
446: 		return false;
447: 	}
448: 	try {
449: 		if (ExtensionHelper::CanAutoloadExtension(extension_name)) {
450: 			return ExtensionHelper::TryAutoLoadExtension(context, extension_name);
451: 		}
452: 	} catch (...) {
453: 		return false;
454: 	}
455: #endif
456: 	return false;
457: }
458: 
459: void Catalog::AutoloadExtensionByConfigName(ClientContext &context, const string &configuration_name) {
460: #ifndef DUCKDB_DISABLE_EXTENSION_LOAD
461: 	auto &dbconfig = DBConfig::GetConfig(context);
462: 	if (dbconfig.options.autoload_known_extensions) {
463: 		auto extension_name = ExtensionHelper::FindExtensionInEntries(configuration_name, EXTENSION_SETTINGS);
464: 		if (ExtensionHelper::CanAutoloadExtension(extension_name)) {
465: 			ExtensionHelper::AutoLoadExtension(context, extension_name);
466: 			return;
467: 		}
468: 	}
469: #endif
470: 
471: 	throw Catalog::UnrecognizedConfigurationError(context, configuration_name);
472: }
473: 
474: static bool IsAutoloadableFunction(CatalogType type) {
475: 	return (type == CatalogType::TABLE_FUNCTION_ENTRY || type == CatalogType::SCALAR_FUNCTION_ENTRY ||
476: 	        type == CatalogType::AGGREGATE_FUNCTION_ENTRY || type == CatalogType::PRAGMA_FUNCTION_ENTRY);
477: }
478: 
479: static bool CompareCatalogTypes(CatalogType type_a, CatalogType type_b) {
480: 	if (type_a == type_b) {
481: 		// Types are same
482: 		return true;
483: 	}
484: 	if (!IsAutoloadableFunction(type_a)) {
485: 		D_ASSERT(IsAutoloadableFunction(type_b));
486: 		// Make sure that `type_a` is an autoloadable function
487: 		return CompareCatalogTypes(type_b, type_a);
488: 	}
489: 	if (type_a == CatalogType::TABLE_FUNCTION_ENTRY) {
490: 		// These are all table functions
491: 		return type_b == CatalogType::TABLE_MACRO_ENTRY || type_b == CatalogType::PRAGMA_FUNCTION_ENTRY;
492: 	} else if (type_a == CatalogType::SCALAR_FUNCTION_ENTRY) {
493: 		// These are all scalar functions
494: 		return type_b == CatalogType::MACRO_ENTRY;
495: 	} else if (type_a == CatalogType::PRAGMA_FUNCTION_ENTRY) {
496: 		// These are all table functions
497: 		return type_b == CatalogType::TABLE_MACRO_ENTRY || type_b == CatalogType::TABLE_FUNCTION_ENTRY;
498: 	}
499: 	return false;
500: }
501: 
502: bool Catalog::AutoLoadExtensionByCatalogEntry(DatabaseInstance &db, CatalogType type, const string &entry_name) {
503: #ifndef DUCKDB_DISABLE_EXTENSION_LOAD
504: 	auto &dbconfig = DBConfig::GetConfig(db);
505: 	if (dbconfig.options.autoload_known_extensions) {
506: 		string extension_name;
507: 		if (IsAutoloadableFunction(type)) {
508: 			auto lookup_result = ExtensionHelper::FindExtensionInFunctionEntries(entry_name, EXTENSION_FUNCTIONS);
509: 			if (lookup_result.empty()) {
510: 				return false;
511: 			}
512: 			for (auto &function : lookup_result) {
513: 				auto function_type = function.second;
514: 				// FIXME: what if there are two functions with the same name, from different extensions?
515: 				if (CompareCatalogTypes(type, function_type)) {
516: 					extension_name = function.first;
517: 					break;
518: 				}
519: 			}
520: 		} else if (type == CatalogType::COPY_FUNCTION_ENTRY) {
521: 			extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COPY_FUNCTIONS);
522: 		} else if (type == CatalogType::TYPE_ENTRY) {
523: 			extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_TYPES);
524: 		} else if (type == CatalogType::COLLATION_ENTRY) {
525: 			extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COLLATIONS);
526: 		}
527: 
528: 		if (!extension_name.empty() && ExtensionHelper::CanAutoloadExtension(extension_name)) {
529: 			ExtensionHelper::AutoLoadExtension(db, extension_name);
530: 			return true;
531: 		}
532: 	}
533: #endif
534: 
535: 	return false;
536: }
537: 
538: CatalogException Catalog::UnrecognizedConfigurationError(ClientContext &context, const string &name) {
539: 	// check if the setting exists in any extensions
540: 	auto extension_name = ExtensionHelper::FindExtensionInEntries(name, EXTENSION_SETTINGS);
541: 	if (!extension_name.empty()) {
542: 		auto error_message = "Setting with name \"" + name + "\" is not in the catalog, but it exists in the " +
543: 		                     extension_name + " extension.";
544: 		error_message = ExtensionHelper::AddExtensionInstallHintToErrorMsg(context, error_message, extension_name);
545: 		return CatalogException(error_message);
546: 	}
547: 	// the setting is not in an extension
548: 	// get a list of all options
549: 	vector<string> potential_names = DBConfig::GetOptionNames();
550: 	for (auto &entry : DBConfig::GetConfig(context).extension_parameters) {
551: 		potential_names.push_back(entry.first);
552: 	}
553: 	throw CatalogException::MissingEntry("configuration parameter", name, potential_names);
554: }
555: 
556: CatalogException Catalog::CreateMissingEntryException(ClientContext &context, const string &entry_name,
557:                                                       CatalogType type,
558:                                                       const reference_set_t<SchemaCatalogEntry> &schemas,
559:                                                       QueryErrorContext error_context) {
560: 	auto entry = SimilarEntryInSchemas(context, entry_name, type, schemas);
561: 
562: 	reference_set_t<SchemaCatalogEntry> unseen_schemas;
563: 	auto &db_manager = DatabaseManager::Get(context);
564: 	auto databases = db_manager.GetDatabases(context);
565: 	auto &config = DBConfig::GetConfig(context);
566: 
567: 	auto max_schema_count = config.options.catalog_error_max_schemas;
568: 	for (auto database : databases) {
569: 		if (unseen_schemas.size() >= max_schema_count) {
570: 			break;
571: 		}
572: 		auto &catalog = database.get().GetCatalog();
573: 		auto current_schemas = catalog.GetAllSchemas(context);
574: 		for (auto &current_schema : current_schemas) {
575: 			if (unseen_schemas.size() >= max_schema_count) {
576: 				break;
577: 			}
578: 			unseen_schemas.insert(current_schema.get());
579: 		}
580: 	}
581: 	// check if the entry exists in any extension
582: 	string extension_name;
583: 	if (type == CatalogType::TABLE_FUNCTION_ENTRY || type == CatalogType::SCALAR_FUNCTION_ENTRY ||
584: 	    type == CatalogType::AGGREGATE_FUNCTION_ENTRY || type == CatalogType::PRAGMA_FUNCTION_ENTRY) {
585: 		auto lookup_result = ExtensionHelper::FindExtensionInFunctionEntries(entry_name, EXTENSION_FUNCTIONS);
586: 		do {
587: 			if (lookup_result.empty()) {
588: 				break;
589: 			}
590: 			vector<string> other_types;
591: 			string extension_for_error;
592: 			for (auto &function : lookup_result) {
593: 				auto function_type = function.second;
594: 				if (CompareCatalogTypes(type, function_type)) {
595: 					extension_name = function.first;
596: 					break;
597: 				}
598: 				extension_for_error = function.first;
599: 				other_types.push_back(CatalogTypeToString(function_type));
600: 			}
601: 			if (!extension_name.empty()) {
602: 				break;
603: 			}
604: 			if (other_types.size() == 1) {
605: 				auto &function_type = other_types[0];
606: 				auto error =
607: 				    CatalogException("%s with name \"%s\" is not in the catalog, a function by this name exists "
608: 				                     "in the %s extension, but it's of a different type, namely %s",
609: 				                     CatalogTypeToString(type), entry_name, extension_for_error, function_type);
610: 				return error;
611: 			} else {
612: 				D_ASSERT(!other_types.empty());
613: 				auto list_of_types = StringUtil::Join(other_types, ", ");
614: 				auto error =
615: 				    CatalogException("%s with name \"%s\" is not in the catalog, functions with this name exist "
616: 				                     "in the %s extension, but they are of different types, namely %s",
617: 				                     CatalogTypeToString(type), entry_name, extension_for_error, list_of_types);
618: 				return error;
619: 			}
620: 		} while (false);
621: 	} else if (type == CatalogType::TYPE_ENTRY) {
622: 		extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_TYPES);
623: 	} else if (type == CatalogType::COPY_FUNCTION_ENTRY) {
624: 		extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COPY_FUNCTIONS);
625: 	} else if (type == CatalogType::COLLATION_ENTRY) {
626: 		extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COLLATIONS);
627: 	}
628: 
629: 	// if we found an extension that can handle this catalog entry, create an error hinting the user
630: 	if (!extension_name.empty()) {
631: 		auto error_message = CatalogTypeToString(type) + " with name \"" + entry_name +
632: 		                     "\" is not in the catalog, but it exists in the " + extension_name + " extension.";
633: 		error_message = ExtensionHelper::AddExtensionInstallHintToErrorMsg(context, error_message, extension_name);
634: 		return CatalogException(error_message);
635: 	}
636: 
637: 	// entries in other schemas get a penalty
638: 	// however, if there is an exact match in another schema, we will always show it
639: 	static constexpr const double UNSEEN_PENALTY = 0.2;
640: 	auto unseen_entry = SimilarEntryInSchemas(context, entry_name, type, unseen_schemas);
641: 	string did_you_mean;
642: 	if (unseen_entry.Found() && (unseen_entry.score == 1.0 || unseen_entry.score - UNSEEN_PENALTY > entry.score)) {
643: 		// the closest matching entry requires qualification as it is not in the default search path
644: 		// check how to minimally qualify this entry
645: 		auto catalog_name = unseen_entry.schema->catalog.GetName();
646: 		auto schema_name = unseen_entry.schema->name;
647: 		bool qualify_database;
648: 		bool qualify_schema;
649: 		FindMinimalQualification(context, catalog_name, schema_name, qualify_database, qualify_schema);
650: 		did_you_mean = unseen_entry.GetQualifiedName(qualify_database, qualify_schema);
651: 	} else if (entry.Found()) {
652: 		did_you_mean = entry.name;
653: 	}
654: 	return CatalogException::MissingEntry(type, entry_name, did_you_mean, error_context);
655: }
656: 
657: CatalogEntryLookup Catalog::TryLookupEntryInternal(CatalogTransaction transaction, CatalogType type,
658:                                                    const string &schema, const string &name) {
659: 	auto schema_entry = GetSchema(transaction, schema, OnEntryNotFound::RETURN_NULL);
660: 	if (!schema_entry) {
661: 		return {nullptr, nullptr, ErrorData()};
662: 	}
663: 	auto entry = schema_entry->GetEntry(transaction, type, name);
664: 	if (!entry) {
665: 		return {schema_entry, nullptr, ErrorData()};
666: 	}
667: 	return {schema_entry, entry, ErrorData()};
668: }
669: 
670: CatalogEntryLookup Catalog::TryLookupEntry(ClientContext &context, CatalogType type, const string &schema,
671:                                            const string &name, OnEntryNotFound if_not_found,
672:                                            QueryErrorContext error_context) {
673: 	reference_set_t<SchemaCatalogEntry> schemas;
674: 	if (IsInvalidSchema(schema)) {
675: 		// try all schemas for this catalog
676: 		auto entries = GetCatalogEntries(context, GetName(), INVALID_SCHEMA);
677: 		for (auto &entry : entries) {
678: 			auto &candidate_schema = entry.schema;
679: 			auto transaction = GetCatalogTransaction(context);
680: 			auto result = TryLookupEntryInternal(transaction, type, candidate_schema, name);
681: 			if (result.Found()) {
682: 				return result;
683: 			}
684: 			if (result.schema) {
685: 				schemas.insert(*result.schema);
686: 			}
687: 		}
688: 	} else {
689: 		auto transaction = GetCatalogTransaction(context);
690: 		auto result = TryLookupEntryInternal(transaction, type, schema, name);
691: 		if (result.Found()) {
692: 			return result;
693: 		}
694: 		if (result.schema) {
695: 			schemas.insert(*result.schema);
696: 		}
697: 	}
698: 
699: 	if (if_not_found == OnEntryNotFound::RETURN_NULL) {
700: 		return {nullptr, nullptr, ErrorData()};
701: 	} else {
702: 		auto except = CreateMissingEntryException(context, name, type, schemas, error_context);
703: 		return {nullptr, nullptr, ErrorData(except)};
704: 	}
705: }
706: 
707: CatalogEntryLookup Catalog::LookupEntry(ClientContext &context, CatalogType type, const string &schema,
708:                                         const string &name, OnEntryNotFound if_not_found,
709:                                         QueryErrorContext error_context) {
710: 	auto res = TryLookupEntry(context, type, schema, name, if_not_found, error_context);
711: 
712: 	if (res.error.HasError()) {
713: 		res.error.Throw();
714: 	}
715: 
716: 	return res;
717: }
718: 
719: CatalogEntryLookup Catalog::TryLookupEntry(ClientContext &context, vector<CatalogLookup> &lookups, CatalogType type,
720:                                            const string &name, OnEntryNotFound if_not_found,
721:                                            QueryErrorContext error_context) {
722: 	reference_set_t<SchemaCatalogEntry> schemas;
723: 	for (auto &lookup : lookups) {
724: 		auto transaction = lookup.catalog.GetCatalogTransaction(context);
725: 		auto result = lookup.catalog.TryLookupEntryInternal(transaction, type, lookup.schema, name);
726: 		if (result.Found()) {
727: 			return result;
728: 		}
729: 		if (result.schema) {
730: 			schemas.insert(*result.schema);
731: 		}
732: 	}
733: 
734: 	if (if_not_found == OnEntryNotFound::RETURN_NULL) {
735: 		return {nullptr, nullptr, ErrorData()};
736: 	} else {
737: 		auto except = CreateMissingEntryException(context, name, type, schemas, error_context);
738: 		return {nullptr, nullptr, ErrorData(except)};
739: 	}
740: }
741: 
742: CatalogEntryLookup Catalog::TryLookupEntry(ClientContext &context, CatalogType type, const string &catalog,
743:                                            const string &schema, const string &name, OnEntryNotFound if_not_found,
744:                                            QueryErrorContext error_context) {
745: 	auto entries = GetCatalogEntries(context, catalog, schema);
746: 	vector<CatalogLookup> lookups;
747: 	vector<CatalogLookup> final_lookups;
748: 	lookups.reserve(entries.size());
749: 	for (auto &entry : entries) {
750: 		optional_ptr<Catalog> catalog_entry;
751: 		if (if_not_found == OnEntryNotFound::RETURN_NULL) {
752: 			catalog_entry = Catalog::GetCatalogEntry(context, entry.catalog);
753: 		} else {
754: 			catalog_entry = &Catalog::GetCatalog(context, entry.catalog);
755: 		}
756: 		if (!catalog_entry) {
757: 			return {nullptr, nullptr, ErrorData()};
758: 		}
759: 		D_ASSERT(catalog_entry);
760: 		auto lookup_behavior = catalog_entry->CatalogTypeLookupRule(type);
761: 		if (lookup_behavior == CatalogLookupBehavior::STANDARD) {
762: 			lookups.emplace_back(*catalog_entry, entry.schema);
763: 		} else if (lookup_behavior == CatalogLookupBehavior::LOWER_PRIORITY) {
764: 			final_lookups.emplace_back(*catalog_entry, entry.schema);
765: 		}
766: 	}
767: 	for (auto &lookup : final_lookups) {
768: 		lookups.emplace_back(std::move(lookup));
769: 	}
770: 	return Catalog::TryLookupEntry(context, lookups, type, name, if_not_found, error_context);
771: }
772: 
773: optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema_name,
774:                                              const string &name, OnEntryNotFound if_not_found,
775:                                              QueryErrorContext error_context) {
776: 	auto lookup_entry = TryLookupEntry(context, type, schema_name, name, if_not_found, error_context);
777: 
778: 	// Try autoloading extension to resolve lookup
779: 	if (!lookup_entry.Found()) {
780: 		if (AutoLoadExtensionByCatalogEntry(*context.db, type, name)) {
781: 			lookup_entry = TryLookupEntry(context, type, schema_name, name, if_not_found, error_context);
782: 		}
783: 	}
784: 
785: 	if (lookup_entry.error.HasError()) {
786: 		lookup_entry.error.Throw();
787: 	}
788: 
789: 	return lookup_entry.entry.get();
790: }
791: 
792: CatalogEntry &Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema, const string &name,
793:                                 QueryErrorContext error_context) {
794: 	return *Catalog::GetEntry(context, type, schema, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
795: }
796: 
797: optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType type, const string &catalog,
798:                                              const string &schema, const string &name, OnEntryNotFound if_not_found,
799:                                              QueryErrorContext error_context) {
800: 	auto result = TryLookupEntry(context, type, catalog, schema, name, if_not_found, error_context);
801: 
802: 	// Try autoloading extension to resolve lookup
803: 	if (!result.Found()) {
804: 		if (AutoLoadExtensionByCatalogEntry(*context.db, type, name)) {
805: 			result = TryLookupEntry(context, type, catalog, schema, name, if_not_found, error_context);
806: 		}
807: 	}
808: 
809: 	if (result.error.HasError()) {
810: 		result.error.Throw();
811: 	}
812: 
813: 	if (!result.Found()) {
814: 		D_ASSERT(if_not_found == OnEntryNotFound::RETURN_NULL);
815: 		return nullptr;
816: 	}
817: 	return result.entry.get();
818: }
819: 
820: CatalogEntry &Catalog::GetEntry(ClientContext &context, CatalogType type, const string &catalog, const string &schema,
821:                                 const string &name, QueryErrorContext error_context) {
822: 	return *Catalog::GetEntry(context, type, catalog, schema, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
823: }
824: 
825: optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(ClientContext &context, const string &catalog_name,
826:                                                     const string &schema_name, OnEntryNotFound if_not_found,
827:                                                     QueryErrorContext error_context) {
828: 	auto entries = GetCatalogEntries(context, catalog_name, schema_name);
829: 	for (idx_t i = 0; i < entries.size(); i++) {
830: 		auto on_not_found = i + 1 == entries.size() ? if_not_found : OnEntryNotFound::RETURN_NULL;
831: 		auto &catalog = Catalog::GetCatalog(context, entries[i].catalog);
832: 		auto result = catalog.GetSchema(context, schema_name, on_not_found, error_context);
833: 		if (result) {
834: 			return result;
835: 		}
836: 	}
837: 	return nullptr;
838: }
839: 
840: vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(ClientContext &context) {
841: 	vector<reference<SchemaCatalogEntry>> schemas;
842: 	ScanSchemas(context, [&](SchemaCatalogEntry &entry) { schemas.push_back(entry); });
843: 	return schemas;
844: }
845: 
846: vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(ClientContext &context, const string &catalog_name) {
847: 	vector<reference<Catalog>> catalogs;
848: 	if (IsInvalidCatalog(catalog_name)) {
849: 		reference_set_t<Catalog> inserted_catalogs;
850: 
851: 		auto &search_path = *context.client_data->catalog_search_path;
852: 		for (auto &entry : search_path.Get()) {
853: 			auto &catalog = Catalog::GetCatalog(context, entry.catalog);
854: 			if (inserted_catalogs.find(catalog) != inserted_catalogs.end()) {
855: 				continue;
856: 			}
857: 			inserted_catalogs.insert(catalog);
858: 			catalogs.push_back(catalog);
859: 		}
860: 	} else {
861: 		catalogs.push_back(Catalog::GetCatalog(context, catalog_name));
862: 	}
863: 	vector<reference<SchemaCatalogEntry>> result;
864: 	for (auto catalog : catalogs) {
865: 		auto schemas = catalog.get().GetSchemas(context);
866: 		result.insert(result.end(), schemas.begin(), schemas.end());
867: 	}
868: 	return result;
869: }
870: 
871: vector<reference<SchemaCatalogEntry>> Catalog::GetAllSchemas(ClientContext &context) {
872: 	vector<reference<SchemaCatalogEntry>> result;
873: 
874: 	auto &db_manager = DatabaseManager::Get(context);
875: 	auto databases = db_manager.GetDatabases(context);
876: 	for (auto database : databases) {
877: 		auto &catalog = database.get().GetCatalog();
878: 		auto new_schemas = catalog.GetSchemas(context);
879: 		result.insert(result.end(), new_schemas.begin(), new_schemas.end());
880: 	}
881: 	sort(result.begin(), result.end(),
882: 	     [&](reference<SchemaCatalogEntry> left_p, reference<SchemaCatalogEntry> right_p) {
883: 		     auto &left = left_p.get();
884: 		     auto &right = right_p.get();
885: 		     if (left.catalog.GetName() < right.catalog.GetName()) {
886: 			     return true;
887: 		     }
888: 		     if (left.catalog.GetName() == right.catalog.GetName()) {
889: 			     return left.name < right.name;
890: 		     }
891: 		     return false;
892: 	     });
893: 
894: 	return result;
895: }
896: 
897: void Catalog::Alter(CatalogTransaction transaction, AlterInfo &info) {
898: 	if (transaction.HasContext()) {
899: 		auto lookup =
900: 		    LookupEntry(transaction.GetContext(), info.GetCatalogType(), info.schema, info.name, info.if_not_found);
901: 		if (!lookup.Found()) {
902: 			return;
903: 		}
904: 		return lookup.schema->Alter(transaction, info);
905: 	}
906: 	D_ASSERT(info.if_not_found == OnEntryNotFound::THROW_EXCEPTION);
907: 	auto &schema = GetSchema(transaction, info.schema);
908: 	return schema.Alter(transaction, info);
909: }
910: 
911: void Catalog::Alter(ClientContext &context, AlterInfo &info) {
912: 	Alter(GetCatalogTransaction(context), info);
913: }
914: 
915: vector<MetadataBlockInfo> Catalog::GetMetadataInfo(ClientContext &context) {
916: 	return vector<MetadataBlockInfo>();
917: }
918: 
919: void Catalog::Verify() {
920: }
921: 
922: bool Catalog::IsSystemCatalog() const {
923: 	return db.IsSystem();
924: }
925: 
926: bool Catalog::IsTemporaryCatalog() const {
927: 	return db.IsTemporary();
928: }
929: 
930: } // namespace duckdb
[end of src/catalog/catalog.cpp]
[start of src/catalog/catalog_entry_retriever.cpp]
1: #include "duckdb/catalog/catalog_entry_retriever.hpp"
2: #include "duckdb/catalog/catalog.hpp"
3: #include "duckdb/catalog/catalog_entry.hpp"
4: #include "duckdb/parser/query_error_context.hpp"
5: #include "duckdb/main/client_context.hpp"
6: #include "duckdb/common/enums/on_entry_not_found.hpp"
7: #include "duckdb/common/enums/catalog_type.hpp"
8: #include "duckdb/common/optional_ptr.hpp"
9: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
10: 
11: namespace duckdb {
12: 
13: LogicalType CatalogEntryRetriever::GetType(Catalog &catalog, const string &schema, const string &name,
14:                                            OnEntryNotFound on_entry_not_found) {
15: 	QueryErrorContext error_context;
16: 	auto result = GetEntry(CatalogType::TYPE_ENTRY, catalog, schema, name, on_entry_not_found, error_context);
17: 	if (!result) {
18: 		return LogicalType::INVALID;
19: 	}
20: 	auto &type_entry = result->Cast<TypeCatalogEntry>();
21: 	return type_entry.user_type;
22: }
23: 
24: LogicalType CatalogEntryRetriever::GetType(const string &catalog, const string &schema, const string &name,
25:                                            OnEntryNotFound on_entry_not_found) {
26: 	QueryErrorContext error_context;
27: 	auto result = GetEntry(CatalogType::TYPE_ENTRY, catalog, schema, name, on_entry_not_found, error_context);
28: 	if (!result) {
29: 		return LogicalType::INVALID;
30: 	}
31: 	auto &type_entry = result->Cast<TypeCatalogEntry>();
32: 	return type_entry.user_type;
33: }
34: 
35: optional_ptr<CatalogEntry> CatalogEntryRetriever::GetEntry(CatalogType type, const string &catalog,
36:                                                            const string &schema, const string &name,
37:                                                            OnEntryNotFound on_entry_not_found,
38:                                                            QueryErrorContext error_context) {
39: 	return GetEntryInternal(
40: 	    [&]() { return Catalog::GetEntry(context, type, catalog, schema, name, on_entry_not_found, error_context); });
41: }
42: 
43: optional_ptr<SchemaCatalogEntry> CatalogEntryRetriever::GetSchema(const string &catalog, const string &name,
44:                                                                   OnEntryNotFound on_entry_not_found,
45:                                                                   QueryErrorContext error_context) {
46: 	auto result = Catalog::GetSchema(context, catalog, name, on_entry_not_found, error_context);
47: 	if (!result) {
48: 		return result;
49: 	}
50: 	if (callback) {
51: 		// Call the callback if it's set
52: 		callback(*result);
53: 	}
54: 	return result;
55: }
56: 
57: optional_ptr<CatalogEntry> CatalogEntryRetriever::GetEntry(CatalogType type, Catalog &catalog, const string &schema,
58:                                                            const string &name, OnEntryNotFound on_entry_not_found,
59:                                                            QueryErrorContext error_context) {
60: 	return GetEntryInternal(
61: 	    [&]() { return catalog.GetEntry(context, type, schema, name, on_entry_not_found, error_context); });
62: }
63: 
64: } // namespace duckdb
[end of src/catalog/catalog_entry_retriever.cpp]
[start of src/catalog/catalog_search_path.cpp]
1: #include "duckdb/catalog/catalog_search_path.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/common/constants.hpp"
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/common/string_util.hpp"
7: #include "duckdb/main/client_context.hpp"
8: #include "duckdb/main/database_manager.hpp"
9: 
10: namespace duckdb {
11: 
12: CatalogSearchEntry::CatalogSearchEntry(string catalog_p, string schema_p)
13:     : catalog(std::move(catalog_p)), schema(std::move(schema_p)) {
14: }
15: 
16: string CatalogSearchEntry::ToString() const {
17: 	if (catalog.empty()) {
18: 		return WriteOptionallyQuoted(schema);
19: 	} else {
20: 		return WriteOptionallyQuoted(catalog) + "." + WriteOptionallyQuoted(schema);
21: 	}
22: }
23: 
24: string CatalogSearchEntry::WriteOptionallyQuoted(const string &input) {
25: 	for (idx_t i = 0; i < input.size(); i++) {
26: 		if (input[i] == '.' || input[i] == ',') {
27: 			return "\"" + input + "\"";
28: 		}
29: 	}
30: 	return input;
31: }
32: 
33: string CatalogSearchEntry::ListToString(const vector<CatalogSearchEntry> &input) {
34: 	string result;
35: 	for (auto &entry : input) {
36: 		if (!result.empty()) {
37: 			result += ",";
38: 		}
39: 		result += entry.ToString();
40: 	}
41: 	return result;
42: }
43: 
44: CatalogSearchEntry CatalogSearchEntry::ParseInternal(const string &input, idx_t &idx) {
45: 	string catalog;
46: 	string schema;
47: 	string entry;
48: 	bool finished = false;
49: normal:
50: 	for (; idx < input.size(); idx++) {
51: 		if (input[idx] == '"') {
52: 			idx++;
53: 			goto quoted;
54: 		} else if (input[idx] == '.') {
55: 			goto separator;
56: 		} else if (input[idx] == ',') {
57: 			finished = true;
58: 			goto separator;
59: 		}
60: 		entry += input[idx];
61: 	}
62: 	finished = true;
63: 	goto separator;
64: quoted:
65: 	//! look for another quote
66: 	for (; idx < input.size(); idx++) {
67: 		if (input[idx] == '"') {
68: 			//! unquote
69: 			idx++;
70: 			if (idx < input.size() && input[idx] == '"') {
71: 				// escaped quote
72: 				entry += input[idx];
73: 				continue;
74: 			}
75: 			goto normal;
76: 		}
77: 		entry += input[idx];
78: 	}
79: 	throw ParserException("Unterminated quote in qualified name!");
80: separator:
81: 	if (entry.empty()) {
82: 		throw ParserException("Unexpected dot - empty CatalogSearchEntry");
83: 	}
84: 	if (schema.empty()) {
85: 		// if we parse one entry it is the schema
86: 		schema = std::move(entry);
87: 	} else if (catalog.empty()) {
88: 		// if we parse two entries it is [catalog.schema]
89: 		catalog = std::move(schema);
90: 		schema = std::move(entry);
91: 	} else {
92: 		throw ParserException("Too many dots - expected [schema] or [catalog.schema] for CatalogSearchEntry");
93: 	}
94: 	entry = "";
95: 	idx++;
96: 	if (finished) {
97: 		goto final;
98: 	}
99: 	goto normal;
100: final:
101: 	if (schema.empty()) {
102: 		throw ParserException("Unexpected end of entry - empty CatalogSearchEntry");
103: 	}
104: 	return CatalogSearchEntry(std::move(catalog), std::move(schema));
105: }
106: 
107: CatalogSearchEntry CatalogSearchEntry::Parse(const string &input) {
108: 	idx_t pos = 0;
109: 	auto result = ParseInternal(input, pos);
110: 	if (pos < input.size()) {
111: 		throw ParserException("Failed to convert entry \"%s\" to CatalogSearchEntry - expected a single entry", input);
112: 	}
113: 	return result;
114: }
115: 
116: vector<CatalogSearchEntry> CatalogSearchEntry::ParseList(const string &input) {
117: 	idx_t pos = 0;
118: 	vector<CatalogSearchEntry> result;
119: 	while (pos < input.size()) {
120: 		auto entry = ParseInternal(input, pos);
121: 		result.push_back(entry);
122: 	}
123: 	return result;
124: }
125: 
126: CatalogSearchPath::CatalogSearchPath(ClientContext &context_p) : context(context_p) {
127: 	Reset();
128: }
129: 
130: void CatalogSearchPath::Reset() {
131: 	vector<CatalogSearchEntry> empty;
132: 	SetPaths(empty);
133: }
134: 
135: string CatalogSearchPath::GetSetName(CatalogSetPathType set_type) {
136: 	switch (set_type) {
137: 	case CatalogSetPathType::SET_SCHEMA:
138: 		return "SET schema";
139: 	case CatalogSetPathType::SET_SCHEMAS:
140: 		return "SET search_path";
141: 	default:
142: 		throw InternalException("Unrecognized CatalogSetPathType");
143: 	}
144: }
145: 
146: void CatalogSearchPath::Set(vector<CatalogSearchEntry> new_paths, CatalogSetPathType set_type) {
147: 	if (set_type != CatalogSetPathType::SET_SCHEMAS && new_paths.size() != 1) {
148: 		throw CatalogException("%s can set only 1 schema. This has %d", GetSetName(set_type), new_paths.size());
149: 	}
150: 	for (auto &path : new_paths) {
151: 		auto schema_entry = Catalog::GetSchema(context, path.catalog, path.schema, OnEntryNotFound::RETURN_NULL);
152: 		if (schema_entry) {
153: 			// we are setting a schema - update the catalog and schema
154: 			if (path.catalog.empty()) {
155: 				path.catalog = GetDefault().catalog;
156: 			}
157: 			continue;
158: 		}
159: 		// only schema supplied - check if this is a catalog instead
160: 		if (path.catalog.empty()) {
161: 			auto catalog = Catalog::GetCatalogEntry(context, path.schema);
162: 			if (catalog) {
163: 				auto schema = catalog->GetSchema(context, DEFAULT_SCHEMA, OnEntryNotFound::RETURN_NULL);
164: 				if (schema) {
165: 					path.catalog = std::move(path.schema);
166: 					path.schema = schema->name;
167: 					continue;
168: 				}
169: 			}
170: 		}
171: 		throw CatalogException("%s: No catalog + schema named \"%s\" found.", GetSetName(set_type), path.ToString());
172: 	}
173: 	if (set_type == CatalogSetPathType::SET_SCHEMA) {
174: 		if (new_paths[0].catalog == TEMP_CATALOG || new_paths[0].catalog == SYSTEM_CATALOG) {
175: 			throw CatalogException("%s cannot be set to internal schema \"%s\"", GetSetName(set_type),
176: 			                       new_paths[0].catalog);
177: 		}
178: 	}
179: 	this->set_paths = std::move(new_paths);
180: 	SetPaths(set_paths);
181: }
182: 
183: void CatalogSearchPath::Set(CatalogSearchEntry new_value, CatalogSetPathType set_type) {
184: 	vector<CatalogSearchEntry> new_paths {std::move(new_value)};
185: 	Set(std::move(new_paths), set_type);
186: }
187: 
188: const vector<CatalogSearchEntry> &CatalogSearchPath::Get() {
189: 	return paths;
190: }
191: 
192: string CatalogSearchPath::GetDefaultSchema(const string &catalog) {
193: 	for (auto &path : paths) {
194: 		if (path.catalog == TEMP_CATALOG) {
195: 			continue;
196: 		}
197: 		if (StringUtil::CIEquals(path.catalog, catalog)) {
198: 			return path.schema;
199: 		}
200: 	}
201: 	return DEFAULT_SCHEMA;
202: }
203: 
204: string CatalogSearchPath::GetDefaultCatalog(const string &schema) {
205: 	for (auto &path : paths) {
206: 		if (path.catalog == TEMP_CATALOG) {
207: 			continue;
208: 		}
209: 		if (StringUtil::CIEquals(path.schema, schema)) {
210: 			return path.catalog;
211: 		}
212: 	}
213: 	return INVALID_CATALOG;
214: }
215: 
216: vector<string> CatalogSearchPath::GetCatalogsForSchema(const string &schema) {
217: 	vector<string> schemas;
218: 	for (auto &path : paths) {
219: 		if (StringUtil::CIEquals(path.schema, schema)) {
220: 			schemas.push_back(path.catalog);
221: 		}
222: 	}
223: 	return schemas;
224: }
225: 
226: vector<string> CatalogSearchPath::GetSchemasForCatalog(const string &catalog) {
227: 	vector<string> schemas;
228: 	for (auto &path : paths) {
229: 		if (StringUtil::CIEquals(path.catalog, catalog)) {
230: 			schemas.push_back(path.schema);
231: 		}
232: 	}
233: 	return schemas;
234: }
235: 
236: const CatalogSearchEntry &CatalogSearchPath::GetDefault() {
237: 	const auto &paths = Get();
238: 	D_ASSERT(paths.size() >= 2);
239: 	return paths[1];
240: }
241: 
242: void CatalogSearchPath::SetPaths(vector<CatalogSearchEntry> new_paths) {
243: 	paths.clear();
244: 	paths.reserve(new_paths.size() + 3);
245: 	paths.emplace_back(TEMP_CATALOG, DEFAULT_SCHEMA);
246: 	for (auto &path : new_paths) {
247: 		paths.push_back(std::move(path));
248: 	}
249: 	paths.emplace_back(INVALID_CATALOG, DEFAULT_SCHEMA);
250: 	paths.emplace_back(SYSTEM_CATALOG, DEFAULT_SCHEMA);
251: 	paths.emplace_back(SYSTEM_CATALOG, "pg_catalog");
252: }
253: 
254: bool CatalogSearchPath::SchemaInSearchPath(ClientContext &context, const string &catalog_name,
255:                                            const string &schema_name) {
256: 	for (auto &path : paths) {
257: 		if (!StringUtil::CIEquals(path.schema, schema_name)) {
258: 			continue;
259: 		}
260: 		if (StringUtil::CIEquals(path.catalog, catalog_name)) {
261: 			return true;
262: 		}
263: 		if (IsInvalidCatalog(path.catalog) &&
264: 		    StringUtil::CIEquals(catalog_name, DatabaseManager::GetDefaultDatabase(context))) {
265: 			return true;
266: 		}
267: 	}
268: 	return false;
269: }
270: 
271: } // namespace duckdb
[end of src/catalog/catalog_search_path.cpp]
[start of src/include/duckdb/catalog/catalog.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/catalog/catalog.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/catalog_entry.hpp"
12: #include "duckdb/common/mutex.hpp"
13: #include "duckdb/parser/query_error_context.hpp"
14: #include "duckdb/catalog/catalog_transaction.hpp"
15: #include "duckdb/common/reference_map.hpp"
16: #include "duckdb/common/atomic.hpp"
17: #include "duckdb/common/map.hpp"
18: #include "duckdb/common/optional_ptr.hpp"
19: #include "duckdb/common/enums/on_entry_not_found.hpp"
20: #include "duckdb/common/error_data.hpp"
21: #include "duckdb/common/exception/catalog_exception.hpp"
22: #include "duckdb/common/enums/catalog_lookup_behavior.hpp"
23: #include <functional>
24: 
25: namespace duckdb {
26: struct CreateSchemaInfo;
27: struct DropInfo;
28: struct BoundCreateTableInfo;
29: struct AlterTableInfo;
30: struct CreateTableFunctionInfo;
31: struct CreateCopyFunctionInfo;
32: struct CreatePragmaFunctionInfo;
33: struct CreateFunctionInfo;
34: struct CreateViewInfo;
35: struct CreateSequenceInfo;
36: struct CreateCollationInfo;
37: struct CreateIndexInfo;
38: struct CreateTypeInfo;
39: struct CreateTableInfo;
40: struct DatabaseSize;
41: struct MetadataBlockInfo;
42: 
43: class AttachedDatabase;
44: class ClientContext;
45: class Transaction;
46: 
47: class AggregateFunctionCatalogEntry;
48: class CollateCatalogEntry;
49: class SchemaCatalogEntry;
50: class TableCatalogEntry;
51: class ViewCatalogEntry;
52: class SequenceCatalogEntry;
53: class TableFunctionCatalogEntry;
54: class CopyFunctionCatalogEntry;
55: class PragmaFunctionCatalogEntry;
56: class CatalogSet;
57: class DatabaseInstance;
58: class DependencyManager;
59: 
60: struct CatalogLookup;
61: struct CatalogEntryLookup;
62: struct SimilarCatalogEntry;
63: 
64: class Binder;
65: class LogicalOperator;
66: class PhysicalOperator;
67: class LogicalCreateIndex;
68: class LogicalCreateTable;
69: class LogicalInsert;
70: class LogicalDelete;
71: class LogicalUpdate;
72: class CreateStatement;
73: 
74: //! The Catalog object represents the catalog of the database.
75: class Catalog {
76: public:
77: 	explicit Catalog(AttachedDatabase &db);
78: 	virtual ~Catalog();
79: 
80: public:
81: 	//! Get the SystemCatalog from the ClientContext
82: 	DUCKDB_API static Catalog &GetSystemCatalog(ClientContext &context);
83: 	//! Get the SystemCatalog from the DatabaseInstance
84: 	DUCKDB_API static Catalog &GetSystemCatalog(DatabaseInstance &db);
85: 	//! Get the specified Catalog from the ClientContext
86: 	DUCKDB_API static Catalog &GetCatalog(ClientContext &context, const string &catalog_name);
87: 	//! Get the specified Catalog from the DatabaseInstance
88: 	DUCKDB_API static Catalog &GetCatalog(DatabaseInstance &db, const string &catalog_name);
89: 	//! Gets the specified Catalog from the database if it exists
90: 	DUCKDB_API static optional_ptr<Catalog> GetCatalogEntry(ClientContext &context, const string &catalog_name);
91: 	//! Get the specific Catalog from the AttachedDatabase
92: 	DUCKDB_API static Catalog &GetCatalog(AttachedDatabase &db);
93: 
94: 	DUCKDB_API AttachedDatabase &GetAttached();
95: 	DUCKDB_API const AttachedDatabase &GetAttached() const;
96: 	DUCKDB_API DatabaseInstance &GetDatabase();
97: 
98: 	virtual bool IsDuckCatalog() {
99: 		return false;
100: 	}
101: 	virtual void Initialize(bool load_builtin) = 0;
102: 
103: 	bool IsSystemCatalog() const;
104: 	bool IsTemporaryCatalog() const;
105: 
106: 	//! Returns a version number that uniquely characterizes the current catalog snapshot.
107: 	//! If there are transaction-local changes, the version returned is >= TRANSACTION_START, o.w. it is a simple number
108: 	//! starting at 0 that is incremented at each commit that has had catalog changes.
109: 	//! If the catalog does not support versioning, no index is returned.
110: 	DUCKDB_API virtual optional_idx GetCatalogVersion(ClientContext &context) {
111: 		return {}; // don't return anything by default
112: 	}
113: 
114: 	//! Returns the catalog name - based on how the catalog was attached
115: 	DUCKDB_API const string &GetName() const;
116: 	DUCKDB_API idx_t GetOid();
117: 	DUCKDB_API virtual string GetCatalogType() = 0;
118: 
119: 	DUCKDB_API CatalogTransaction GetCatalogTransaction(ClientContext &context);
120: 
121: 	//! Creates a schema in the catalog.
122: 	DUCKDB_API virtual optional_ptr<CatalogEntry> CreateSchema(CatalogTransaction transaction,
123: 	                                                           CreateSchemaInfo &info) = 0;
124: 	DUCKDB_API optional_ptr<CatalogEntry> CreateSchema(ClientContext &context, CreateSchemaInfo &info);
125: 	//! Creates a table in the catalog.
126: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTable(CatalogTransaction transaction, BoundCreateTableInfo &info);
127: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTable(ClientContext &context, BoundCreateTableInfo &info);
128: 	//! Creates a table in the catalog.
129: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTable(ClientContext &context, unique_ptr<CreateTableInfo> info);
130: 	//! Create a table function in the catalog
131: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTableFunction(CatalogTransaction transaction,
132: 	                                                          CreateTableFunctionInfo &info);
133: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTableFunction(ClientContext &context, CreateTableFunctionInfo &info);
134: 	// Kept for backwards compatibility
135: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTableFunction(ClientContext &context,
136: 	                                                          optional_ptr<CreateTableFunctionInfo> info);
137: 	//! Create a copy function in the catalog
138: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCopyFunction(CatalogTransaction transaction,
139: 	                                                         CreateCopyFunctionInfo &info);
140: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCopyFunction(ClientContext &context, CreateCopyFunctionInfo &info);
141: 	//! Create a pragma function in the catalog
142: 	DUCKDB_API optional_ptr<CatalogEntry> CreatePragmaFunction(CatalogTransaction transaction,
143: 	                                                           CreatePragmaFunctionInfo &info);
144: 	DUCKDB_API optional_ptr<CatalogEntry> CreatePragmaFunction(ClientContext &context, CreatePragmaFunctionInfo &info);
145: 	//! Create a scalar or aggregate function in the catalog
146: 	DUCKDB_API optional_ptr<CatalogEntry> CreateFunction(CatalogTransaction transaction, CreateFunctionInfo &info);
147: 	DUCKDB_API optional_ptr<CatalogEntry> CreateFunction(ClientContext &context, CreateFunctionInfo &info);
148: 	//! Creates a table in the catalog.
149: 	DUCKDB_API optional_ptr<CatalogEntry> CreateView(CatalogTransaction transaction, CreateViewInfo &info);
150: 	DUCKDB_API optional_ptr<CatalogEntry> CreateView(ClientContext &context, CreateViewInfo &info);
151: 	//! Creates a sequence in the catalog.
152: 	DUCKDB_API optional_ptr<CatalogEntry> CreateSequence(CatalogTransaction transaction, CreateSequenceInfo &info);
153: 	DUCKDB_API optional_ptr<CatalogEntry> CreateSequence(ClientContext &context, CreateSequenceInfo &info);
154: 	//! Creates a Enum in the catalog.
155: 	DUCKDB_API optional_ptr<CatalogEntry> CreateType(CatalogTransaction transaction, CreateTypeInfo &info);
156: 	DUCKDB_API optional_ptr<CatalogEntry> CreateType(ClientContext &context, CreateTypeInfo &info);
157: 	//! Creates a collation in the catalog
158: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCollation(CatalogTransaction transaction, CreateCollationInfo &info);
159: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCollation(ClientContext &context, CreateCollationInfo &info);
160: 	//! Creates an index in the catalog
161: 	DUCKDB_API optional_ptr<CatalogEntry> CreateIndex(CatalogTransaction transaction, CreateIndexInfo &info);
162: 	DUCKDB_API optional_ptr<CatalogEntry> CreateIndex(ClientContext &context, CreateIndexInfo &info);
163: 
164: 	//! Creates a table in the catalog.
165: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTable(CatalogTransaction transaction, SchemaCatalogEntry &schema,
166: 	                                                  BoundCreateTableInfo &info);
167: 	//! Create a table function in the catalog
168: 	DUCKDB_API optional_ptr<CatalogEntry>
169: 	CreateTableFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema, CreateTableFunctionInfo &info);
170: 	//! Create a copy function in the catalog
171: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCopyFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
172: 	                                                         CreateCopyFunctionInfo &info);
173: 	//! Create a pragma function in the catalog
174: 	DUCKDB_API optional_ptr<CatalogEntry>
175: 	CreatePragmaFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema, CreatePragmaFunctionInfo &info);
176: 	//! Create a scalar or aggregate function in the catalog
177: 	DUCKDB_API optional_ptr<CatalogEntry> CreateFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
178: 	                                                     CreateFunctionInfo &info);
179: 	//! Creates a view in the catalog
180: 	DUCKDB_API optional_ptr<CatalogEntry> CreateView(CatalogTransaction transaction, SchemaCatalogEntry &schema,
181: 	                                                 CreateViewInfo &info);
182: 	//! Creates a table in the catalog.
183: 	DUCKDB_API optional_ptr<CatalogEntry> CreateSequence(CatalogTransaction transaction, SchemaCatalogEntry &schema,
184: 	                                                     CreateSequenceInfo &info);
185: 	//! Creates a enum in the catalog.
186: 	DUCKDB_API optional_ptr<CatalogEntry> CreateType(CatalogTransaction transaction, SchemaCatalogEntry &schema,
187: 	                                                 CreateTypeInfo &info);
188: 	//! Creates a collation in the catalog
189: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCollation(CatalogTransaction transaction, SchemaCatalogEntry &schema,
190: 	                                                      CreateCollationInfo &info);
191: 
192: 	//! Drops an entry from the catalog
193: 	DUCKDB_API void DropEntry(ClientContext &context, DropInfo &info);
194: 
195: 	//! Returns the schema object with the specified name, or throws an exception if it does not exist
196: 	DUCKDB_API SchemaCatalogEntry &GetSchema(ClientContext &context, const string &name,
197: 	                                         QueryErrorContext error_context = QueryErrorContext());
198: 	DUCKDB_API optional_ptr<SchemaCatalogEntry> GetSchema(ClientContext &context, const string &name,
199: 	                                                      OnEntryNotFound if_not_found,
200: 	                                                      QueryErrorContext error_context = QueryErrorContext());
201: 	//! Overloadable method for giving warnings on ambiguous naming id.tab due to a database and schema with name id
202: 	DUCKDB_API virtual bool CheckAmbiguousCatalogOrSchema(ClientContext &context, const string &name) {
203: 		return !!GetSchema(context, name, OnEntryNotFound::RETURN_NULL);
204: 	}
205: 	DUCKDB_API SchemaCatalogEntry &GetSchema(CatalogTransaction transaction, const string &name,
206: 	                                         QueryErrorContext error_context = QueryErrorContext());
207: 	DUCKDB_API virtual optional_ptr<SchemaCatalogEntry>
208: 	GetSchema(CatalogTransaction transaction, const string &schema_name, OnEntryNotFound if_not_found,
209: 	          QueryErrorContext error_context = QueryErrorContext()) = 0;
210: 	DUCKDB_API static SchemaCatalogEntry &GetSchema(ClientContext &context, const string &catalog_name,
211: 	                                                const string &schema_name,
212: 	                                                QueryErrorContext error_context = QueryErrorContext());
213: 	DUCKDB_API static optional_ptr<SchemaCatalogEntry> GetSchema(ClientContext &context, const string &catalog_name,
214: 	                                                             const string &schema_name,
215: 	                                                             OnEntryNotFound if_not_found,
216: 	                                                             QueryErrorContext error_context = QueryErrorContext());
217: 	//! Scans all the schemas in the system one-by-one, invoking the callback for each entry
218: 	DUCKDB_API virtual void ScanSchemas(ClientContext &context, std::function<void(SchemaCatalogEntry &)> callback) = 0;
219: 
220: 	//! Gets the "schema.name" entry of the specified type, if entry does not exist behavior depends on OnEntryNotFound
221: 	DUCKDB_API optional_ptr<CatalogEntry> GetEntry(ClientContext &context, CatalogType type, const string &schema,
222: 	                                               const string &name, OnEntryNotFound if_not_found,
223: 	                                               QueryErrorContext error_context = QueryErrorContext());
224: 	DUCKDB_API CatalogEntry &GetEntry(ClientContext &context, CatalogType type, const string &schema,
225: 	                                  const string &name, QueryErrorContext error_context = QueryErrorContext());
226: 	//! Gets the "catalog.schema.name" entry of the specified type, if entry does not exist behavior depends on
227: 	//! OnEntryNotFound
228: 	DUCKDB_API static optional_ptr<CatalogEntry> GetEntry(ClientContext &context, CatalogType type,
229: 	                                                      const string &catalog, const string &schema,
230: 	                                                      const string &name, OnEntryNotFound if_not_found,
231: 	                                                      QueryErrorContext error_context = QueryErrorContext());
232: 	DUCKDB_API static CatalogEntry &GetEntry(ClientContext &context, CatalogType type, const string &catalog,
233: 	                                         const string &schema, const string &name,
234: 	                                         QueryErrorContext error_context = QueryErrorContext());
235: 
236: 	template <class T>
237: 	optional_ptr<T> GetEntry(ClientContext &context, const string &schema_name, const string &name,
238: 	                         OnEntryNotFound if_not_found, QueryErrorContext error_context = QueryErrorContext()) {
239: 		auto entry = GetEntry(context, T::Type, schema_name, name, if_not_found, error_context);
240: 		if (!entry) {
241: 			return nullptr;
242: 		}
243: 		if (entry->type != T::Type) {
244: 			throw CatalogException(error_context, "%s is not an %s", name, T::Name);
245: 		}
246: 		return &entry->template Cast<T>();
247: 	}
248: 	template <class T>
249: 	T &GetEntry(ClientContext &context, const string &schema_name, const string &name,
250: 	            QueryErrorContext error_context = QueryErrorContext()) {
251: 		auto entry = GetEntry<T>(context, schema_name, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
252: 		return *entry;
253: 	}
254: 
255: 	//! Append a scalar or aggregate function to the catalog
256: 	DUCKDB_API optional_ptr<CatalogEntry> AddFunction(ClientContext &context, CreateFunctionInfo &info);
257: 
258: 	//! Alter an existing entry in the catalog.
259: 	DUCKDB_API void Alter(CatalogTransaction transaction, AlterInfo &info);
260: 	DUCKDB_API void Alter(ClientContext &context, AlterInfo &info);
261: 
262: 	virtual unique_ptr<PhysicalOperator> PlanCreateTableAs(ClientContext &context, LogicalCreateTable &op,
263: 	                                                       unique_ptr<PhysicalOperator> plan) = 0;
264: 	virtual unique_ptr<PhysicalOperator> PlanInsert(ClientContext &context, LogicalInsert &op,
265: 	                                                unique_ptr<PhysicalOperator> plan) = 0;
266: 	virtual unique_ptr<PhysicalOperator> PlanDelete(ClientContext &context, LogicalDelete &op,
267: 	                                                unique_ptr<PhysicalOperator> plan) = 0;
268: 	virtual unique_ptr<PhysicalOperator> PlanUpdate(ClientContext &context, LogicalUpdate &op,
269: 	                                                unique_ptr<PhysicalOperator> plan) = 0;
270: 	virtual unique_ptr<LogicalOperator> BindCreateIndex(Binder &binder, CreateStatement &stmt, TableCatalogEntry &table,
271: 	                                                    unique_ptr<LogicalOperator> plan) = 0;
272: 
273: 	virtual DatabaseSize GetDatabaseSize(ClientContext &context) = 0;
274: 	virtual vector<MetadataBlockInfo> GetMetadataInfo(ClientContext &context);
275: 
276: 	virtual bool InMemory() = 0;
277: 	virtual string GetDBPath() = 0;
278: 
279: 	//! Whether or not this catalog should search a specific type with the standard priority
280: 	DUCKDB_API virtual CatalogLookupBehavior CatalogTypeLookupRule(CatalogType type) const {
281: 		return CatalogLookupBehavior::STANDARD;
282: 	}
283: 
284: public:
285: 	template <class T>
286: 	static optional_ptr<T> GetEntry(ClientContext &context, const string &catalog_name, const string &schema_name,
287: 	                                const string &name, OnEntryNotFound if_not_found,
288: 	                                QueryErrorContext error_context = QueryErrorContext()) {
289: 		auto entry = GetEntry(context, T::Type, catalog_name, schema_name, name, if_not_found, error_context);
290: 		if (!entry) {
291: 			return nullptr;
292: 		}
293: 		if (entry->type != T::Type) {
294: 			throw CatalogException(error_context, "%s is not an %s", name, T::Name);
295: 		}
296: 		return &entry->template Cast<T>();
297: 	}
298: 	template <class T>
299: 	static T &GetEntry(ClientContext &context, const string &catalog_name, const string &schema_name,
300: 	                   const string &name, QueryErrorContext error_context = QueryErrorContext()) {
301: 		auto entry =
302: 		    GetEntry<T>(context, catalog_name, schema_name, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
303: 		return *entry;
304: 	}
305: 
306: 	DUCKDB_API vector<reference<SchemaCatalogEntry>> GetSchemas(ClientContext &context);
307: 	DUCKDB_API static vector<reference<SchemaCatalogEntry>> GetSchemas(ClientContext &context,
308: 	                                                                   const string &catalog_name);
309: 	DUCKDB_API static vector<reference<SchemaCatalogEntry>> GetAllSchemas(ClientContext &context);
310: 
311: 	virtual void Verify();
312: 
313: 	static CatalogException UnrecognizedConfigurationError(ClientContext &context, const string &name);
314: 
315: 	//! Autoload the extension required for `configuration_name` or throw a CatalogException
316: 	static void AutoloadExtensionByConfigName(ClientContext &context, const string &configuration_name);
317: 	//! Autoload the extension required for `function_name` or throw a CatalogException
318: 	static bool AutoLoadExtensionByCatalogEntry(DatabaseInstance &db, CatalogType type, const string &entry_name);
319: 	DUCKDB_API static bool TryAutoLoad(ClientContext &context, const string &extension_name) noexcept;
320: 
321: protected:
322: 	//! Reference to the database
323: 	AttachedDatabase &db;
324: 
325: public:
326: private:
327: 	//! Lookup an entry in the schema, returning a lookup with the entry and schema if they exist
328: 	CatalogEntryLookup TryLookupEntryInternal(CatalogTransaction transaction, CatalogType type, const string &schema,
329: 	                                          const string &name);
330: 	//! Calls LookupEntryInternal on the schema, trying other schemas if the schema is invalid. Sets
331: 	//! CatalogEntryLookup->error depending on if_not_found when no entry is found
332: 	CatalogEntryLookup TryLookupEntry(ClientContext &context, CatalogType type, const string &schema,
333: 	                                  const string &name, OnEntryNotFound if_not_found,
334: 	                                  QueryErrorContext error_context = QueryErrorContext());
335: 	//! Lookup an entry using TryLookupEntry, throws if entry not found and if_not_found == THROW_EXCEPTION
336: 	CatalogEntryLookup LookupEntry(ClientContext &context, CatalogType type, const string &schema, const string &name,
337: 	                               OnEntryNotFound if_not_found, QueryErrorContext error_context = QueryErrorContext());
338: 	static CatalogEntryLookup TryLookupEntry(ClientContext &context, vector<CatalogLookup> &lookups, CatalogType type,
339: 	                                         const string &name, OnEntryNotFound if_not_found,
340: 	                                         QueryErrorContext error_context = QueryErrorContext());
341: 	static CatalogEntryLookup TryLookupEntry(ClientContext &context, CatalogType type, const string &catalog,
342: 	                                         const string &schema, const string &name, OnEntryNotFound if_not_found,
343: 	                                         QueryErrorContext error_context);
344: 
345: 	//! Return an exception with did-you-mean suggestion.
346: 	static CatalogException CreateMissingEntryException(ClientContext &context, const string &entry_name,
347: 	                                                    CatalogType type,
348: 	                                                    const reference_set_t<SchemaCatalogEntry> &schemas,
349: 	                                                    QueryErrorContext error_context);
350: 
351: 	//! Return the close entry name, the distance and the belonging schema.
352: 	static SimilarCatalogEntry SimilarEntryInSchemas(ClientContext &context, const string &entry_name, CatalogType type,
353: 	                                                 const reference_set_t<SchemaCatalogEntry> &schemas);
354: 
355: 	virtual void DropSchema(ClientContext &context, DropInfo &info) = 0;
356: 
357: public:
358: 	template <class TARGET>
359: 	TARGET &Cast() {
360: 		DynamicCastCheck<TARGET>(this);
361: 		return reinterpret_cast<TARGET &>(*this);
362: 	}
363: 
364: 	template <class TARGET>
365: 	const TARGET &Cast() const {
366: 		DynamicCastCheck<TARGET>(this);
367: 		return reinterpret_cast<const TARGET &>(*this);
368: 	}
369: };
370: 
371: } // namespace duckdb
[end of src/include/duckdb/catalog/catalog.hpp]
[start of src/include/duckdb/catalog/catalog_entry_retriever.hpp]
1: #pragma once
2: 
3: #include <functional>
4: #include "duckdb/common/enums/catalog_type.hpp"
5: #include "duckdb/common/enums/on_entry_not_found.hpp"
6: #include "duckdb/common/string.hpp"
7: #include "duckdb/parser/query_error_context.hpp"
8: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
9: 
10: namespace duckdb {
11: 
12: class ClientContext;
13: class Catalog;
14: class CatalogEntry;
15: 
16: using catalog_entry_callback_t = std::function<void(CatalogEntry &)>;
17: 
18: // Wraps the Catalog::GetEntry method
19: class CatalogEntryRetriever {
20: public:
21: 	explicit CatalogEntryRetriever(ClientContext &context) : context(context) {
22: 	}
23: 	CatalogEntryRetriever(const CatalogEntryRetriever &other) : callback(other.callback), context(other.context) {
24: 	}
25: 
26: public:
27: 	optional_ptr<CatalogEntry> GetEntry(CatalogType type, const string &catalog, const string &schema,
28: 	                                    const string &name,
29: 	                                    OnEntryNotFound on_entry_not_found = OnEntryNotFound::THROW_EXCEPTION,
30: 	                                    QueryErrorContext error_context = QueryErrorContext());
31: 
32: 	optional_ptr<CatalogEntry> GetEntry(CatalogType type, Catalog &catalog, const string &schema, const string &name,
33: 	                                    OnEntryNotFound on_entry_not_found = OnEntryNotFound::THROW_EXCEPTION,
34: 	                                    QueryErrorContext error_context = QueryErrorContext());
35: 
36: 	LogicalType GetType(const string &catalog, const string &schema, const string &name,
37: 	                    OnEntryNotFound on_entry_not_found = OnEntryNotFound::RETURN_NULL);
38: 	LogicalType GetType(Catalog &catalog, const string &schema, const string &name,
39: 	                    OnEntryNotFound on_entry_not_found = OnEntryNotFound::RETURN_NULL);
40: 
41: 	optional_ptr<SchemaCatalogEntry> GetSchema(const string &catalog, const string &name,
42: 	                                           OnEntryNotFound on_entry_not_found = OnEntryNotFound::THROW_EXCEPTION,
43: 	                                           QueryErrorContext error_context = QueryErrorContext());
44: 
45: 	void SetCallback(catalog_entry_callback_t callback) {
46: 		this->callback = std::move(callback);
47: 	}
48: 	catalog_entry_callback_t GetCallback() {
49: 		return callback;
50: 	}
51: 
52: private:
53: 	using catalog_entry_retrieve_func_t = std::function<optional_ptr<CatalogEntry>()>;
54: 	optional_ptr<CatalogEntry> GetEntryInternal(const catalog_entry_retrieve_func_t &retriever) {
55: 		auto result = retriever();
56: 		if (!result) {
57: 			return result;
58: 		}
59: 		if (callback) {
60: 			// Call the callback if it's set
61: 			callback(*result);
62: 		}
63: 		return result;
64: 	}
65: 
66: private:
67: 	//! (optional) callback, called on every succesful entry retrieval
68: 	catalog_entry_callback_t callback = nullptr;
69: 	ClientContext &context;
70: };
71: 
72: } // namespace duckdb
[end of src/include/duckdb/catalog/catalog_entry_retriever.hpp]
[start of src/include/duckdb/catalog/catalog_search_path.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/catalog/catalog_search_path.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include <functional>
12: #include "duckdb/common/enums/catalog_type.hpp"
13: #include "duckdb/common/string.hpp"
14: #include "duckdb/common/vector.hpp"
15: #include "duckdb/common/types/value.hpp"
16: 
17: namespace duckdb {
18: 
19: class ClientContext;
20: 
21: struct CatalogSearchEntry {
22: 	CatalogSearchEntry(string catalog, string schema);
23: 
24: 	string catalog;
25: 	string schema;
26: 
27: public:
28: 	string ToString() const;
29: 	static string ListToString(const vector<CatalogSearchEntry> &input);
30: 	static CatalogSearchEntry Parse(const string &input);
31: 	static vector<CatalogSearchEntry> ParseList(const string &input);
32: 
33: private:
34: 	static CatalogSearchEntry ParseInternal(const string &input, idx_t &pos);
35: 	static string WriteOptionallyQuoted(const string &input);
36: };
37: 
38: enum class CatalogSetPathType { SET_SCHEMA, SET_SCHEMAS };
39: 
40: //! The schema search path, in order by which entries are searched if no schema entry is provided
41: class CatalogSearchPath {
42: public:
43: 	DUCKDB_API explicit CatalogSearchPath(ClientContext &client_p);
44: 	CatalogSearchPath(const CatalogSearchPath &other) = delete;
45: 
46: 	DUCKDB_API void Set(CatalogSearchEntry new_value, CatalogSetPathType set_type);
47: 	DUCKDB_API void Set(vector<CatalogSearchEntry> new_paths, CatalogSetPathType set_type);
48: 	DUCKDB_API void Reset();
49: 
50: 	DUCKDB_API const vector<CatalogSearchEntry> &Get();
51: 	const vector<CatalogSearchEntry> &GetSetPaths() {
52: 		return set_paths;
53: 	}
54: 	DUCKDB_API const CatalogSearchEntry &GetDefault();
55: 	DUCKDB_API string GetDefaultSchema(const string &catalog);
56: 	DUCKDB_API string GetDefaultCatalog(const string &schema);
57: 
58: 	DUCKDB_API vector<string> GetSchemasForCatalog(const string &catalog);
59: 	DUCKDB_API vector<string> GetCatalogsForSchema(const string &schema);
60: 
61: 	DUCKDB_API bool SchemaInSearchPath(ClientContext &context, const string &catalog_name, const string &schema_name);
62: 
63: private:
64: 	void SetPaths(vector<CatalogSearchEntry> new_paths);
65: 
66: 	string GetSetName(CatalogSetPathType set_type);
67: 
68: private:
69: 	ClientContext &context;
70: 	vector<CatalogSearchEntry> paths;
71: 	//! Only the paths that were explicitly set (minus the always included paths)
72: 	vector<CatalogSearchEntry> set_paths;
73: };
74: 
75: } // namespace duckdb
[end of src/include/duckdb/catalog/catalog_search_path.hpp]
[start of src/include/duckdb/main/database_manager.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/database_manager.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/atomic.hpp"
12: #include "duckdb/common/case_insensitive_map.hpp"
13: #include "duckdb/common/common.hpp"
14: #include "duckdb/common/enums/access_mode.hpp"
15: #include "duckdb/common/enums/on_entry_not_found.hpp"
16: #include "duckdb/common/mutex.hpp"
17: #include "duckdb/common/optional_ptr.hpp"
18: #include "duckdb/main/config.hpp"
19: #include "duckdb/parser/parsed_data/attach_info.hpp"
20: 
21: namespace duckdb {
22: class AttachedDatabase;
23: class Catalog;
24: class CatalogSet;
25: class ClientContext;
26: class DatabaseInstance;
27: class TaskScheduler;
28: struct AttachOptions;
29: 
30: //! The DatabaseManager is a class that sits at the root of all attached databases
31: class DatabaseManager {
32: 	friend class Catalog;
33: 
34: public:
35: 	explicit DatabaseManager(DatabaseInstance &db);
36: 	~DatabaseManager();
37: 
38: public:
39: 	static DatabaseManager &Get(DatabaseInstance &db);
40: 	static DatabaseManager &Get(ClientContext &db);
41: 	static DatabaseManager &Get(AttachedDatabase &db);
42: 
43: 	//! Initializes the system catalog of the attached SYSTEM_DATABASE.
44: 	void InitializeSystemCatalog();
45: 	//! Get an attached database by its name
46: 	optional_ptr<AttachedDatabase> GetDatabase(ClientContext &context, const string &name);
47: 	//! Attach a new database
48: 	optional_ptr<AttachedDatabase> AttachDatabase(ClientContext &context, const AttachInfo &info,
49: 	                                              const AttachOptions &options);
50: 	//! Detach an existing database
51: 	void DetachDatabase(ClientContext &context, const string &name, OnEntryNotFound if_not_found);
52: 	//! Returns a reference to the system catalog
53: 	Catalog &GetSystemCatalog();
54: 
55: 	static const string &GetDefaultDatabase(ClientContext &context);
56: 	void SetDefaultDatabase(ClientContext &context, const string &new_value);
57: 
58: 	//! Inserts a path to name mapping to the database paths map
59: 	void InsertDatabasePath(ClientContext &context, const string &path, const string &name);
60: 	//! Erases a path from the database paths map
61: 	void EraseDatabasePath(const string &path);
62: 
63: 	//! Returns the database type. This might require checking the header of the file, in which case the file handle is
64: 	//! necessary. We can only grab the file handle, if it is not yet held, even for uncommitted changes. Thus, we have
65: 	//! to lock for this operation.
66: 	void GetDatabaseType(ClientContext &context, AttachInfo &info, const DBConfig &config, AttachOptions &options);
67: 	//! Scans the catalog set and adds each committed database entry, and each database entry of the current
68: 	//! transaction, to a vector holding AttachedDatabase references
69: 	vector<reference<AttachedDatabase>> GetDatabases(ClientContext &context);
70: 	//! Removes all databases from the catalog set. This is necessary for the database instance's destructor,
71: 	//! as the database manager has to be alive when destroying the catalog set objects.
72: 	void ResetDatabases(unique_ptr<TaskScheduler> &scheduler);
73: 
74: 	transaction_t GetNewQueryNumber() {
75: 		return current_query_number++;
76: 	}
77: 	transaction_t ActiveQueryNumber() const {
78: 		return current_query_number;
79: 	}
80: 	idx_t NextOid() {
81: 		return next_oid++;
82: 	}
83: 	bool HasDefaultDatabase() {
84: 		return !default_database.empty();
85: 	}
86: 
87: private:
88: 	//! Returns a database with a specified path
89: 	optional_ptr<AttachedDatabase> GetDatabaseFromPath(ClientContext &context, const string &path);
90: 	void CheckPathConflict(ClientContext &context, const string &path);
91: 
92: private:
93: 	//! The system database is a special database that holds system entries (e.g. functions)
94: 	unique_ptr<AttachedDatabase> system;
95: 	//! The set of attached databases
96: 	unique_ptr<CatalogSet> databases;
97: 	//! The next object id handed out by the NextOid method
98: 	atomic<idx_t> next_oid;
99: 	//! The current query number
100: 	atomic<transaction_t> current_query_number;
101: 	//! The current default database
102: 	string default_database;
103: 
104: 	//! The lock to add entries to the database path map
105: 	mutex db_paths_lock;
106: 	//! A set containing all attached database path
107: 	//! This allows to attach many databases efficiently, and to avoid attaching the
108: 	//! same file path twice
109: 	case_insensitive_set_t db_paths;
110: };
111: 
112: } // namespace duckdb
[end of src/include/duckdb/main/database_manager.hpp]
[start of src/include/duckdb/parser/parsed_data/comment_on_column_info.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/parser/parsed_data/comment_on_column_info.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/enums/catalog_type.hpp"
12: #include "duckdb/common/types/value.hpp"
13: #include "duckdb/parser/parsed_data/alter_info.hpp"
14: #include "duckdb/parser/qualified_name.hpp"
15: #include "duckdb/catalog/catalog_entry_retriever.hpp"
16: 
17: namespace duckdb {
18: class ClientContext;
19: class CatalogEntry;
20: 
21: struct SetColumnCommentInfo : public AlterInfo {
22: public:
23: 	static constexpr const ParseInfoType TYPE = ParseInfoType::COMMENT_ON_COLUMN_INFO;
24: 
25: public:
26: 	SetColumnCommentInfo();
27: 	SetColumnCommentInfo(string catalog, string schema, string name, string column_name, Value comment_value,
28: 	                     OnEntryNotFound if_not_found);
29: 
30: 	//! The resolved Catalog Type
31: 	CatalogType catalog_entry_type;
32: 
33: 	//! name of the column to comment on
34: 	string column_name;
35: 	//! The comment, can be NULL or a string
36: 	Value comment_value;
37: 
38: public:
39: 	optional_ptr<CatalogEntry> TryResolveCatalogEntry(CatalogEntryRetriever &retriever);
40: 	unique_ptr<AlterInfo> Copy() const override;
41: 	CatalogType GetCatalogType() const override;
42: 	string ToString() const override;
43: 
44: 	void Serialize(Serializer &serializer) const override;
45: 	static unique_ptr<AlterInfo> Deserialize(Deserializer &deserializer);
46: };
47: 
48: } // namespace duckdb
[end of src/include/duckdb/parser/parsed_data/comment_on_column_info.hpp]
[start of src/planner/binder.cpp]
1: #include "duckdb/planner/binder.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
6: #include "duckdb/common/enum_util.hpp"
7: #include "duckdb/common/helper.hpp"
8: #include "duckdb/main/config.hpp"
9: #include "duckdb/main/database.hpp"
10: #include "duckdb/parser/expression/function_expression.hpp"
11: #include "duckdb/parser/expression/subquery_expression.hpp"
12: #include "duckdb/parser/parsed_expression_iterator.hpp"
13: #include "duckdb/parser/query_node/list.hpp"
14: #include "duckdb/parser/query_node/select_node.hpp"
15: #include "duckdb/parser/statement/list.hpp"
16: #include "duckdb/parser/tableref/list.hpp"
17: #include "duckdb/parser/tableref/table_function_ref.hpp"
18: #include "duckdb/planner/bound_query_node.hpp"
19: #include "duckdb/planner/expression.hpp"
20: #include "duckdb/planner/expression_binder/returning_binder.hpp"
21: #include "duckdb/planner/operator/logical_projection.hpp"
22: #include "duckdb/planner/operator/logical_sample.hpp"
23: #include "duckdb/planner/query_node/list.hpp"
24: #include "duckdb/planner/tableref/list.hpp"
25: 
26: #include <algorithm>
27: 
28: namespace duckdb {
29: 
30: Binder &Binder::GetRootBinder() {
31: 	reference<Binder> root = *this;
32: 	while (root.get().parent) {
33: 		root = *root.get().parent;
34: 	}
35: 	return root.get();
36: }
37: 
38: idx_t Binder::GetBinderDepth() const {
39: 	const_reference<Binder> root = *this;
40: 	idx_t depth = 1;
41: 	while (root.get().parent) {
42: 		depth++;
43: 		root = *root.get().parent;
44: 	}
45: 	return depth;
46: }
47: 
48: shared_ptr<Binder> Binder::CreateBinder(ClientContext &context, optional_ptr<Binder> parent, BinderType binder_type) {
49: 	auto depth = parent ? parent->GetBinderDepth() : 0;
50: 	if (depth > context.config.max_expression_depth) {
51: 		throw BinderException("Max expression depth limit of %lld exceeded. Use \"SET max_expression_depth TO x\" to "
52: 		                      "increase the maximum expression depth.",
53: 		                      context.config.max_expression_depth);
54: 	}
55: 	return shared_ptr<Binder>(new Binder(context, parent ? parent->shared_from_this() : nullptr, binder_type));
56: }
57: 
58: Binder::Binder(ClientContext &context, shared_ptr<Binder> parent_p, BinderType binder_type)
59:     : context(context), bind_context(*this), parent(std::move(parent_p)), bound_tables(0), binder_type(binder_type),
60:       entry_retriever(context) {
61: 	if (parent) {
62: 		entry_retriever.SetCallback(parent->entry_retriever.GetCallback());
63: 
64: 		// We have to inherit macro and lambda parameter bindings and from the parent binder, if there is a parent.
65: 		macro_binding = parent->macro_binding;
66: 		lambda_bindings = parent->lambda_bindings;
67: 
68: 		if (binder_type == BinderType::REGULAR_BINDER) {
69: 			// We have to inherit CTE bindings from the parent bind_context, if there is a parent.
70: 			bind_context.SetCTEBindings(parent->bind_context.GetCTEBindings());
71: 			bind_context.cte_references = parent->bind_context.cte_references;
72: 			parameters = parent->parameters;
73: 		}
74: 	}
75: }
76: 
77: unique_ptr<BoundCTENode> Binder::BindMaterializedCTE(CommonTableExpressionMap &cte_map) {
78: 	// Extract materialized CTEs from cte_map
79: 	vector<unique_ptr<CTENode>> materialized_ctes;
80: 	for (auto &cte : cte_map.map) {
81: 		auto &cte_entry = cte.second;
82: 		if (cte_entry->materialized == CTEMaterialize::CTE_MATERIALIZE_ALWAYS) {
83: 			auto mat_cte = make_uniq<CTENode>();
84: 			mat_cte->ctename = cte.first;
85: 			mat_cte->query = cte_entry->query->node->Copy();
86: 			mat_cte->aliases = cte_entry->aliases;
87: 			materialized_ctes.push_back(std::move(mat_cte));
88: 		}
89: 	}
90: 
91: 	if (materialized_ctes.empty()) {
92: 		return nullptr;
93: 	}
94: 
95: 	unique_ptr<CTENode> cte_root = nullptr;
96: 	while (!materialized_ctes.empty()) {
97: 		unique_ptr<CTENode> node_result;
98: 		node_result = std::move(materialized_ctes.back());
99: 		node_result->cte_map = cte_map.Copy();
100: 		if (cte_root) {
101: 			node_result->child = std::move(cte_root);
102: 		} else {
103: 			node_result->child = nullptr;
104: 		}
105: 		cte_root = std::move(node_result);
106: 		materialized_ctes.pop_back();
107: 	}
108: 
109: 	AddCTEMap(cte_map);
110: 	auto bound_cte = BindCTE(cte_root->Cast<CTENode>());
111: 
112: 	return bound_cte;
113: }
114: 
115: template <class T>
116: BoundStatement Binder::BindWithCTE(T &statement) {
117: 	BoundStatement bound_statement;
118: 	auto bound_cte = BindMaterializedCTE(statement.template Cast<T>().cte_map);
119: 	if (bound_cte) {
120: 		reference<BoundCTENode> tail_ref = *bound_cte;
121: 
122: 		while (tail_ref.get().child && tail_ref.get().child->type == QueryNodeType::CTE_NODE) {
123: 			tail_ref = tail_ref.get().child->Cast<BoundCTENode>();
124: 		}
125: 
126: 		auto &tail = tail_ref.get();
127: 		bound_statement = tail.child_binder->Bind(statement.template Cast<T>());
128: 
129: 		tail.types = bound_statement.types;
130: 		tail.names = bound_statement.names;
131: 
132: 		for (auto &c : tail.query_binder->correlated_columns) {
133: 			tail.child_binder->AddCorrelatedColumn(c);
134: 		}
135: 		MoveCorrelatedExpressions(*tail.child_binder);
136: 
137: 		auto plan = std::move(bound_statement.plan);
138: 		bound_statement.plan = CreatePlan(*bound_cte, std::move(plan));
139: 	} else {
140: 		bound_statement = Bind(statement.template Cast<T>());
141: 	}
142: 	return bound_statement;
143: }
144: 
145: BoundStatement Binder::Bind(SQLStatement &statement) {
146: 	root_statement = &statement;
147: 	switch (statement.type) {
148: 	case StatementType::SELECT_STATEMENT:
149: 		return Bind(statement.Cast<SelectStatement>());
150: 	case StatementType::INSERT_STATEMENT:
151: 		return BindWithCTE(statement.Cast<InsertStatement>());
152: 	case StatementType::COPY_STATEMENT:
153: 		return Bind(statement.Cast<CopyStatement>(), CopyToType::COPY_TO_FILE);
154: 	case StatementType::DELETE_STATEMENT:
155: 		return BindWithCTE(statement.Cast<DeleteStatement>());
156: 	case StatementType::UPDATE_STATEMENT:
157: 		return BindWithCTE(statement.Cast<UpdateStatement>());
158: 	case StatementType::RELATION_STATEMENT:
159: 		return Bind(statement.Cast<RelationStatement>());
160: 	case StatementType::CREATE_STATEMENT:
161: 		return Bind(statement.Cast<CreateStatement>());
162: 	case StatementType::DROP_STATEMENT:
163: 		return Bind(statement.Cast<DropStatement>());
164: 	case StatementType::ALTER_STATEMENT:
165: 		return Bind(statement.Cast<AlterStatement>());
166: 	case StatementType::TRANSACTION_STATEMENT:
167: 		return Bind(statement.Cast<TransactionStatement>());
168: 	case StatementType::PRAGMA_STATEMENT:
169: 		return Bind(statement.Cast<PragmaStatement>());
170: 	case StatementType::EXPLAIN_STATEMENT:
171: 		return Bind(statement.Cast<ExplainStatement>());
172: 	case StatementType::VACUUM_STATEMENT:
173: 		return Bind(statement.Cast<VacuumStatement>());
174: 	case StatementType::CALL_STATEMENT:
175: 		return Bind(statement.Cast<CallStatement>());
176: 	case StatementType::EXPORT_STATEMENT:
177: 		return Bind(statement.Cast<ExportStatement>());
178: 	case StatementType::SET_STATEMENT:
179: 		return Bind(statement.Cast<SetStatement>());
180: 	case StatementType::LOAD_STATEMENT:
181: 		return Bind(statement.Cast<LoadStatement>());
182: 	case StatementType::EXTENSION_STATEMENT:
183: 		return Bind(statement.Cast<ExtensionStatement>());
184: 	case StatementType::PREPARE_STATEMENT:
185: 		return Bind(statement.Cast<PrepareStatement>());
186: 	case StatementType::EXECUTE_STATEMENT:
187: 		return Bind(statement.Cast<ExecuteStatement>());
188: 	case StatementType::LOGICAL_PLAN_STATEMENT:
189: 		return Bind(statement.Cast<LogicalPlanStatement>());
190: 	case StatementType::ATTACH_STATEMENT:
191: 		return Bind(statement.Cast<AttachStatement>());
192: 	case StatementType::DETACH_STATEMENT:
193: 		return Bind(statement.Cast<DetachStatement>());
194: 	case StatementType::COPY_DATABASE_STATEMENT:
195: 		return Bind(statement.Cast<CopyDatabaseStatement>());
196: 	case StatementType::UPDATE_EXTENSIONS_STATEMENT:
197: 		return Bind(statement.Cast<UpdateExtensionsStatement>());
198: 	default: // LCOV_EXCL_START
199: 		throw NotImplementedException("Unimplemented statement type \"%s\" for Bind",
200: 		                              StatementTypeToString(statement.type));
201: 	} // LCOV_EXCL_STOP
202: }
203: 
204: void Binder::AddCTEMap(CommonTableExpressionMap &cte_map) {
205: 	for (auto &cte_it : cte_map.map) {
206: 		AddCTE(cte_it.first, *cte_it.second);
207: 	}
208: }
209: 
210: static void GetTableRefCountsNode(case_insensitive_map_t<idx_t> &cte_ref_counts, QueryNode &node);
211: 
212: static void GetTableRefCountsExpr(case_insensitive_map_t<idx_t> &cte_ref_counts, ParsedExpression &expr) {
213: 	if (expr.type == ExpressionType::SUBQUERY) {
214: 		auto &subquery = expr.Cast<SubqueryExpression>();
215: 		GetTableRefCountsNode(cte_ref_counts, *subquery.subquery->node);
216: 	} else {
217: 		ParsedExpressionIterator::EnumerateChildren(
218: 		    expr, [&](ParsedExpression &expr) { GetTableRefCountsExpr(cte_ref_counts, expr); });
219: 	}
220: }
221: 
222: static void GetTableRefCountsNode(case_insensitive_map_t<idx_t> &cte_ref_counts, QueryNode &node) {
223: 	ParsedExpressionIterator::EnumerateQueryNodeChildren(
224: 	    node, [&](unique_ptr<ParsedExpression> &child) { GetTableRefCountsExpr(cte_ref_counts, *child); },
225: 	    [&](TableRef &ref) {
226: 		    if (ref.type != TableReferenceType::BASE_TABLE) {
227: 			    return;
228: 		    }
229: 		    auto cte_ref_counts_it = cte_ref_counts.find(ref.Cast<BaseTableRef>().table_name);
230: 		    if (cte_ref_counts_it != cte_ref_counts.end()) {
231: 			    cte_ref_counts_it->second++;
232: 		    }
233: 	    });
234: }
235: 
236: static bool ParsedExpressionIsAggregate(Binder &binder, const ParsedExpression &expr) {
237: 	if (expr.GetExpressionClass() == ExpressionClass::FUNCTION) {
238: 		auto &function = expr.Cast<FunctionExpression>();
239: 		QueryErrorContext error_context;
240: 		auto entry = binder.GetCatalogEntry(CatalogType::SCALAR_FUNCTION_ENTRY, function.catalog, function.schema,
241: 		                                    function.function_name, OnEntryNotFound::RETURN_NULL, error_context);
242: 		if (entry && entry->type == CatalogType::AGGREGATE_FUNCTION_ENTRY) {
243: 			return true;
244: 		}
245: 	}
246: 	bool is_aggregate = false;
247: 	ParsedExpressionIterator::EnumerateChildren(
248: 	    expr, [&](const ParsedExpression &child) { is_aggregate |= ParsedExpressionIsAggregate(binder, child); });
249: 	return is_aggregate;
250: }
251: 
252: bool Binder::OptimizeCTEs(QueryNode &node) {
253: 	D_ASSERT(context.config.enable_optimizer);
254: 
255: 	// only applies to nodes that have at least one CTE
256: 	auto &cte_map = node.cte_map.map;
257: 	if (cte_map.empty()) {
258: 		return false;
259: 	}
260: 
261: 	// initialize counts with the CTE names
262: 	case_insensitive_map_t<idx_t> cte_ref_counts;
263: 	for (auto &cte : cte_map) {
264: 		cte_ref_counts[cte.first];
265: 	}
266: 
267: 	// count the references of each CTE
268: 	GetTableRefCountsNode(cte_ref_counts, node);
269: 
270: 	// determine for each CTE whether it should be materialized
271: 	bool result = false;
272: 	for (auto &cte : cte_map) {
273: 		if (cte.second->materialized != CTEMaterialize::CTE_MATERIALIZE_DEFAULT) {
274: 			continue; // only triggers when nothing is specified
275: 		}
276: 		if (bind_context.GetCTEBinding(cte.first)) {
277: 			continue; // there's a CTE in the bind context with an overlapping name, we can't also materialize this
278: 		}
279: 
280: 		auto cte_ref_counts_it = cte_ref_counts.find(cte.first);
281: 		D_ASSERT(cte_ref_counts_it != cte_ref_counts.end());
282: 
283: 		// only applies to CTEs that are referenced more than once
284: 		if (cte_ref_counts_it->second <= 1) {
285: 			continue;
286: 		}
287: 
288: 		// if the cte is a SELECT node
289: 		if (cte.second->query->node->type != QueryNodeType::SELECT_NODE) {
290: 			continue;
291: 		}
292: 
293: 		// we materialize if the CTE ends in an aggregation
294: 		auto &cte_node = cte.second->query->node->Cast<SelectNode>();
295: 		bool materialize = !cte_node.groups.group_expressions.empty() || !cte_node.groups.grouping_sets.empty();
296: 		// or has a distinct modifier
297: 		for (auto &modifier : cte_node.modifiers) {
298: 			if (materialize) {
299: 				break;
300: 			}
301: 			if (modifier->type == ResultModifierType::DISTINCT_MODIFIER) {
302: 				materialize = true;
303: 			}
304: 		}
305: 		for (auto &sel : cte_node.select_list) {
306: 			if (materialize) {
307: 				break;
308: 			}
309: 			materialize |= ParsedExpressionIsAggregate(*this, *sel);
310: 		}
311: 
312: 		if (materialize) {
313: 			cte.second->materialized = CTEMaterialize::CTE_MATERIALIZE_ALWAYS;
314: 			result = true;
315: 		}
316: 	}
317: 	return result;
318: }
319: 
320: unique_ptr<BoundQueryNode> Binder::BindNode(QueryNode &node) {
321: 	// first we visit the set of CTEs and add them to the bind context
322: 	AddCTEMap(node.cte_map);
323: 	// now we bind the node
324: 	unique_ptr<BoundQueryNode> result;
325: 	switch (node.type) {
326: 	case QueryNodeType::SELECT_NODE:
327: 		result = BindNode(node.Cast<SelectNode>());
328: 		break;
329: 	case QueryNodeType::RECURSIVE_CTE_NODE:
330: 		result = BindNode(node.Cast<RecursiveCTENode>());
331: 		break;
332: 	case QueryNodeType::CTE_NODE:
333: 		result = BindNode(node.Cast<CTENode>());
334: 		break;
335: 	default:
336: 		D_ASSERT(node.type == QueryNodeType::SET_OPERATION_NODE);
337: 		result = BindNode(node.Cast<SetOperationNode>());
338: 		break;
339: 	}
340: 	return result;
341: }
342: 
343: BoundStatement Binder::Bind(QueryNode &node) {
344: 	BoundStatement result;
345: 	if (context.db->config.options.disabled_optimizers.find(OptimizerType::MATERIALIZED_CTE) ==
346: 	        context.db->config.options.disabled_optimizers.end() &&
347: 	    context.config.enable_optimizer && OptimizeCTEs(node)) {
348: 		switch (node.type) {
349: 		case QueryNodeType::SELECT_NODE:
350: 			result = BindWithCTE(node.Cast<SelectNode>());
351: 			break;
352: 		case QueryNodeType::RECURSIVE_CTE_NODE:
353: 			result = BindWithCTE(node.Cast<RecursiveCTENode>());
354: 			break;
355: 		case QueryNodeType::CTE_NODE:
356: 			result = BindWithCTE(node.Cast<CTENode>());
357: 			break;
358: 		default:
359: 			D_ASSERT(node.type == QueryNodeType::SET_OPERATION_NODE);
360: 			result = BindWithCTE(node.Cast<SetOperationNode>());
361: 			break;
362: 		}
363: 	} else {
364: 		auto bound_node = BindNode(node);
365: 
366: 		result.names = bound_node->names;
367: 		result.types = bound_node->types;
368: 
369: 		// and plan it
370: 		result.plan = CreatePlan(*bound_node);
371: 	}
372: 	return result;
373: }
374: 
375: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundQueryNode &node) {
376: 	switch (node.type) {
377: 	case QueryNodeType::SELECT_NODE:
378: 		return CreatePlan(node.Cast<BoundSelectNode>());
379: 	case QueryNodeType::SET_OPERATION_NODE:
380: 		return CreatePlan(node.Cast<BoundSetOperationNode>());
381: 	case QueryNodeType::RECURSIVE_CTE_NODE:
382: 		return CreatePlan(node.Cast<BoundRecursiveCTENode>());
383: 	case QueryNodeType::CTE_NODE:
384: 		return CreatePlan(node.Cast<BoundCTENode>());
385: 	default:
386: 		throw InternalException("Unsupported bound query node type");
387: 	}
388: }
389: 
390: unique_ptr<BoundTableRef> Binder::Bind(TableRef &ref) {
391: 	unique_ptr<BoundTableRef> result;
392: 	switch (ref.type) {
393: 	case TableReferenceType::BASE_TABLE:
394: 		result = Bind(ref.Cast<BaseTableRef>());
395: 		break;
396: 	case TableReferenceType::JOIN:
397: 		result = Bind(ref.Cast<JoinRef>());
398: 		break;
399: 	case TableReferenceType::SUBQUERY:
400: 		result = Bind(ref.Cast<SubqueryRef>());
401: 		break;
402: 	case TableReferenceType::EMPTY_FROM:
403: 		result = Bind(ref.Cast<EmptyTableRef>());
404: 		break;
405: 	case TableReferenceType::TABLE_FUNCTION:
406: 		result = Bind(ref.Cast<TableFunctionRef>());
407: 		break;
408: 	case TableReferenceType::EXPRESSION_LIST:
409: 		result = Bind(ref.Cast<ExpressionListRef>());
410: 		break;
411: 	case TableReferenceType::COLUMN_DATA:
412: 		result = Bind(ref.Cast<ColumnDataRef>());
413: 		break;
414: 	case TableReferenceType::PIVOT:
415: 		result = Bind(ref.Cast<PivotRef>());
416: 		break;
417: 	case TableReferenceType::SHOW_REF:
418: 		result = Bind(ref.Cast<ShowRef>());
419: 		break;
420: 	case TableReferenceType::DELIM_GET:
421: 		result = Bind(ref.Cast<DelimGetRef>());
422: 		break;
423: 	case TableReferenceType::CTE:
424: 	case TableReferenceType::INVALID:
425: 	default:
426: 		throw InternalException("Unknown table ref type (%s)", EnumUtil::ToString(ref.type));
427: 	}
428: 	result->sample = std::move(ref.sample);
429: 	return result;
430: }
431: 
432: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundTableRef &ref) {
433: 	unique_ptr<LogicalOperator> root;
434: 	switch (ref.type) {
435: 	case TableReferenceType::BASE_TABLE:
436: 		root = CreatePlan(ref.Cast<BoundBaseTableRef>());
437: 		break;
438: 	case TableReferenceType::SUBQUERY:
439: 		root = CreatePlan(ref.Cast<BoundSubqueryRef>());
440: 		break;
441: 	case TableReferenceType::JOIN:
442: 		root = CreatePlan(ref.Cast<BoundJoinRef>());
443: 		break;
444: 	case TableReferenceType::TABLE_FUNCTION:
445: 		root = CreatePlan(ref.Cast<BoundTableFunction>());
446: 		break;
447: 	case TableReferenceType::EMPTY_FROM:
448: 		root = CreatePlan(ref.Cast<BoundEmptyTableRef>());
449: 		break;
450: 	case TableReferenceType::EXPRESSION_LIST:
451: 		root = CreatePlan(ref.Cast<BoundExpressionListRef>());
452: 		break;
453: 	case TableReferenceType::COLUMN_DATA:
454: 		root = CreatePlan(ref.Cast<BoundColumnDataRef>());
455: 		break;
456: 	case TableReferenceType::CTE:
457: 		root = CreatePlan(ref.Cast<BoundCTERef>());
458: 		break;
459: 	case TableReferenceType::PIVOT:
460: 		root = CreatePlan(ref.Cast<BoundPivotRef>());
461: 		break;
462: 	case TableReferenceType::DELIM_GET:
463: 		root = CreatePlan(ref.Cast<BoundDelimGetRef>());
464: 		break;
465: 	case TableReferenceType::INVALID:
466: 	default:
467: 		throw InternalException("Unsupported bound table ref type (%s)", EnumUtil::ToString(ref.type));
468: 	}
469: 	// plan the sample clause
470: 	if (ref.sample) {
471: 		root = make_uniq<LogicalSample>(std::move(ref.sample), std::move(root));
472: 	}
473: 	return root;
474: }
475: 
476: void Binder::AddCTE(const string &name, CommonTableExpressionInfo &info) {
477: 	D_ASSERT(!name.empty());
478: 	auto entry = CTE_bindings.find(name);
479: 	if (entry != CTE_bindings.end()) {
480: 		throw InternalException("Duplicate CTE \"%s\" in query!", name);
481: 	}
482: 	CTE_bindings.insert(make_pair(name, reference<CommonTableExpressionInfo>(info)));
483: }
484: 
485: vector<reference<CommonTableExpressionInfo>> Binder::FindCTE(const string &name, bool skip) {
486: 	auto entry = CTE_bindings.find(name);
487: 	vector<reference<CommonTableExpressionInfo>> ctes;
488: 	if (entry != CTE_bindings.end()) {
489: 		if (!skip || entry->second.get().query->node->type == QueryNodeType::RECURSIVE_CTE_NODE) {
490: 			ctes.push_back(entry->second);
491: 		}
492: 	}
493: 	if (parent && binder_type == BinderType::REGULAR_BINDER) {
494: 		auto parent_ctes = parent->FindCTE(name, name == alias);
495: 		ctes.insert(ctes.end(), parent_ctes.begin(), parent_ctes.end());
496: 	}
497: 	return ctes;
498: }
499: 
500: bool Binder::CTEIsAlreadyBound(CommonTableExpressionInfo &cte) {
501: 	if (bound_ctes.find(cte) != bound_ctes.end()) {
502: 		return true;
503: 	}
504: 	if (parent && binder_type == BinderType::REGULAR_BINDER) {
505: 		return parent->CTEIsAlreadyBound(cte);
506: 	}
507: 	return false;
508: }
509: 
510: void Binder::AddBoundView(ViewCatalogEntry &view) {
511: 	// check if the view is already bound
512: 	auto current = this;
513: 	while (current) {
514: 		if (current->bound_views.find(view) != current->bound_views.end()) {
515: 			throw BinderException("infinite recursion detected: attempting to recursively bind view \"%s\"", view.name);
516: 		}
517: 		current = current->parent.get();
518: 	}
519: 	bound_views.insert(view);
520: }
521: 
522: idx_t Binder::GenerateTableIndex() {
523: 	auto &root_binder = GetRootBinder();
524: 	return root_binder.bound_tables++;
525: }
526: 
527: StatementProperties &Binder::GetStatementProperties() {
528: 	auto &root_binder = GetRootBinder();
529: 	return root_binder.prop;
530: }
531: 
532: void Binder::PushExpressionBinder(ExpressionBinder &binder) {
533: 	GetActiveBinders().push_back(binder);
534: }
535: 
536: void Binder::PopExpressionBinder() {
537: 	D_ASSERT(HasActiveBinder());
538: 	GetActiveBinders().pop_back();
539: }
540: 
541: void Binder::SetActiveBinder(ExpressionBinder &binder) {
542: 	D_ASSERT(HasActiveBinder());
543: 	GetActiveBinders().back() = binder;
544: }
545: 
546: ExpressionBinder &Binder::GetActiveBinder() {
547: 	return GetActiveBinders().back();
548: }
549: 
550: bool Binder::HasActiveBinder() {
551: 	return !GetActiveBinders().empty();
552: }
553: 
554: vector<reference<ExpressionBinder>> &Binder::GetActiveBinders() {
555: 	reference<Binder> root = *this;
556: 	while (root.get().parent && root.get().binder_type == BinderType::REGULAR_BINDER) {
557: 		root = *root.get().parent;
558: 	}
559: 	auto &root_binder = root.get();
560: 	return root_binder.active_binders;
561: }
562: 
563: void Binder::AddUsingBindingSet(unique_ptr<UsingColumnSet> set) {
564: 	auto &root_binder = GetRootBinder();
565: 	root_binder.bind_context.AddUsingBindingSet(std::move(set));
566: }
567: 
568: void Binder::MoveCorrelatedExpressions(Binder &other) {
569: 	MergeCorrelatedColumns(other.correlated_columns);
570: 	other.correlated_columns.clear();
571: }
572: 
573: void Binder::MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other) {
574: 	for (idx_t i = 0; i < other.size(); i++) {
575: 		AddCorrelatedColumn(other[i]);
576: 	}
577: }
578: 
579: void Binder::AddCorrelatedColumn(const CorrelatedColumnInfo &info) {
580: 	// we only add correlated columns to the list if they are not already there
581: 	if (std::find(correlated_columns.begin(), correlated_columns.end(), info) == correlated_columns.end()) {
582: 		correlated_columns.push_back(info);
583: 	}
584: }
585: 
586: bool Binder::HasMatchingBinding(const string &table_name, const string &column_name, ErrorData &error) {
587: 	string empty_schema;
588: 	return HasMatchingBinding(empty_schema, table_name, column_name, error);
589: }
590: 
591: bool Binder::HasMatchingBinding(const string &schema_name, const string &table_name, const string &column_name,
592:                                 ErrorData &error) {
593: 	string empty_catalog;
594: 	return HasMatchingBinding(empty_catalog, schema_name, table_name, column_name, error);
595: }
596: 
597: bool Binder::HasMatchingBinding(const string &catalog_name, const string &schema_name, const string &table_name,
598:                                 const string &column_name, ErrorData &error) {
599: 	optional_ptr<Binding> binding;
600: 	D_ASSERT(!lambda_bindings);
601: 	if (macro_binding && table_name == macro_binding->alias) {
602: 		binding = optional_ptr<Binding>(macro_binding.get());
603: 	} else {
604: 		binding = bind_context.GetBinding(table_name, error);
605: 	}
606: 
607: 	if (!binding) {
608: 		return false;
609: 	}
610: 	if (!catalog_name.empty() || !schema_name.empty()) {
611: 		auto catalog_entry = binding->GetStandardEntry();
612: 		if (!catalog_entry) {
613: 			return false;
614: 		}
615: 		if (!catalog_name.empty() && catalog_entry->catalog.GetName() != catalog_name) {
616: 			return false;
617: 		}
618: 		if (!schema_name.empty() && catalog_entry->schema.name != schema_name) {
619: 			return false;
620: 		}
621: 		if (catalog_entry->name != table_name) {
622: 			return false;
623: 		}
624: 	}
625: 	bool binding_found;
626: 	binding_found = binding->HasMatchingBinding(column_name);
627: 	if (!binding_found) {
628: 		error = binding->ColumnNotFoundError(column_name);
629: 	}
630: 	return binding_found;
631: }
632: 
633: void Binder::SetBindingMode(BindingMode mode) {
634: 	auto &root_binder = GetRootBinder();
635: 	root_binder.mode = mode;
636: }
637: 
638: BindingMode Binder::GetBindingMode() {
639: 	auto &root_binder = GetRootBinder();
640: 	return root_binder.mode;
641: }
642: 
643: void Binder::SetCanContainNulls(bool can_contain_nulls_p) {
644: 	can_contain_nulls = can_contain_nulls_p;
645: }
646: 
647: void Binder::SetAlwaysRequireRebind() {
648: 	auto &properties = GetStatementProperties();
649: 	properties.always_require_rebind = true;
650: }
651: 
652: void Binder::AddTableName(string table_name) {
653: 	auto &root_binder = GetRootBinder();
654: 	root_binder.table_names.insert(std::move(table_name));
655: }
656: 
657: void Binder::AddReplacementScan(const string &table_name, unique_ptr<TableRef> replacement) {
658: 	auto &root_binder = GetRootBinder();
659: 	auto it = root_binder.replacement_scans.find(table_name);
660: 	replacement->column_name_alias.clear();
661: 	replacement->alias.clear();
662: 	if (it == root_binder.replacement_scans.end()) {
663: 		root_binder.replacement_scans[table_name] = std::move(replacement);
664: 	} else {
665: 		// A replacement scan by this name was previously registered, we can just use it
666: 	}
667: }
668: 
669: const unordered_set<string> &Binder::GetTableNames() {
670: 	auto &root_binder = GetRootBinder();
671: 	return root_binder.table_names;
672: }
673: 
674: case_insensitive_map_t<unique_ptr<TableRef>> &Binder::GetReplacementScans() {
675: 	auto &root_binder = GetRootBinder();
676: 	return root_binder.replacement_scans;
677: }
678: 
679: // FIXME: this is extremely naive
680: void VerifyNotExcluded(ParsedExpression &expr) {
681: 	if (expr.type == ExpressionType::COLUMN_REF) {
682: 		auto &column_ref = expr.Cast<ColumnRefExpression>();
683: 		if (!column_ref.IsQualified()) {
684: 			return;
685: 		}
686: 		auto &table_name = column_ref.GetTableName();
687: 		if (table_name == "excluded") {
688: 			throw NotImplementedException("'excluded' qualified columns are not supported in the RETURNING clause yet");
689: 		}
690: 		return;
691: 	}
692: 	ParsedExpressionIterator::EnumerateChildren(
693: 	    expr, [&](const ParsedExpression &child) { VerifyNotExcluded((ParsedExpression &)child); });
694: }
695: 
696: BoundStatement Binder::BindReturning(vector<unique_ptr<ParsedExpression>> returning_list, TableCatalogEntry &table,
697:                                      const string &alias, idx_t update_table_index,
698:                                      unique_ptr<LogicalOperator> child_operator, BoundStatement result) {
699: 
700: 	vector<LogicalType> types;
701: 	vector<std::string> names;
702: 
703: 	auto binder = Binder::CreateBinder(context);
704: 
705: 	vector<column_t> bound_columns;
706: 	idx_t column_count = 0;
707: 	for (auto &col : table.GetColumns().Logical()) {
708: 		names.push_back(col.Name());
709: 		types.push_back(col.Type());
710: 		if (!col.Generated()) {
711: 			bound_columns.push_back(column_count);
712: 		}
713: 		column_count++;
714: 	}
715: 
716: 	binder->bind_context.AddBaseTable(update_table_index, alias.empty() ? table.name : alias, names, types,
717: 	                                  bound_columns, &table, false);
718: 	ReturningBinder returning_binder(*binder, context);
719: 
720: 	vector<unique_ptr<Expression>> projection_expressions;
721: 	LogicalType result_type;
722: 	vector<unique_ptr<ParsedExpression>> new_returning_list;
723: 	binder->ExpandStarExpressions(returning_list, new_returning_list);
724: 	for (auto &returning_expr : new_returning_list) {
725: 		VerifyNotExcluded(*returning_expr);
726: 		auto expr = returning_binder.Bind(returning_expr, &result_type);
727: 		result.names.push_back(expr->GetName());
728: 		result.types.push_back(result_type);
729: 		projection_expressions.push_back(std::move(expr));
730: 	}
731: 	if (new_returning_list.empty()) {
732: 		throw BinderException("RETURNING list is empty!");
733: 	}
734: 	auto projection = make_uniq<LogicalProjection>(GenerateTableIndex(), std::move(projection_expressions));
735: 	projection->AddChild(std::move(child_operator));
736: 	D_ASSERT(result.types.size() == result.names.size());
737: 	result.plan = std::move(projection);
738: 	// If an insert/delete/update statement returns data, there are sometimes issues with streaming results
739: 	// where the data modification doesn't take place until the streamed result is exhausted. Once a row is
740: 	// returned, it should be guaranteed that the row has been inserted.
741: 	// see https://github.com/duckdb/duckdb/issues/8310
742: 	auto &properties = GetStatementProperties();
743: 	properties.allow_stream_result = false;
744: 	properties.return_type = StatementReturnType::QUERY_RESULT;
745: 	return result;
746: }
747: 
748: optional_ptr<CatalogEntry> Binder::GetCatalogEntry(CatalogType type, const string &catalog, const string &schema,
749:                                                    const string &name, OnEntryNotFound on_entry_not_found,
750:                                                    QueryErrorContext &error_context) {
751: 	return entry_retriever.GetEntry(type, catalog, schema, name, on_entry_not_found, error_context);
752: }
753: 
754: } // namespace duckdb
[end of src/planner/binder.cpp]
[start of src/planner/binder/tableref/bind_basetableref.cpp]
1: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
2: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
3: #include "duckdb/common/string_util.hpp"
4: #include "duckdb/main/client_context.hpp"
5: #include "duckdb/main/config.hpp"
6: #include "duckdb/main/extension_helper.hpp"
7: #include "duckdb/parser/query_node/select_node.hpp"
8: #include "duckdb/parser/statement/select_statement.hpp"
9: #include "duckdb/parser/tableref/basetableref.hpp"
10: #include "duckdb/parser/tableref/subqueryref.hpp"
11: #include "duckdb/parser/tableref/table_function_ref.hpp"
12: #include "duckdb/planner/binder.hpp"
13: #include "duckdb/planner/operator/logical_get.hpp"
14: #include "duckdb/planner/tableref/bound_basetableref.hpp"
15: #include "duckdb/planner/tableref/bound_cteref.hpp"
16: #include "duckdb/planner/tableref/bound_dummytableref.hpp"
17: #include "duckdb/planner/tableref/bound_subqueryref.hpp"
18: 
19: namespace duckdb {
20: 
21: static bool TryLoadExtensionForReplacementScan(ClientContext &context, const string &table_name) {
22: 	auto lower_name = StringUtil::Lower(table_name);
23: 	auto &dbconfig = DBConfig::GetConfig(context);
24: 
25: 	if (!dbconfig.options.autoload_known_extensions) {
26: 		return false;
27: 	}
28: 
29: 	for (const auto &entry : EXTENSION_FILE_POSTFIXES) {
30: 		if (StringUtil::EndsWith(lower_name, entry.name)) {
31: 			ExtensionHelper::AutoLoadExtension(context, entry.extension);
32: 			return true;
33: 		}
34: 	}
35: 
36: 	for (const auto &entry : EXTENSION_FILE_CONTAINS) {
37: 		if (StringUtil::Contains(lower_name, entry.name)) {
38: 			ExtensionHelper::AutoLoadExtension(context, entry.extension);
39: 			return true;
40: 		}
41: 	}
42: 
43: 	return false;
44: }
45: 
46: unique_ptr<BoundTableRef> Binder::BindWithReplacementScan(ClientContext &context, BaseTableRef &ref) {
47: 	auto &config = DBConfig::GetConfig(context);
48: 	if (!context.config.use_replacement_scans) {
49: 		return nullptr;
50: 	}
51: 	for (auto &scan : config.replacement_scans) {
52: 		ReplacementScanInput input(ref.catalog_name, ref.schema_name, ref.table_name);
53: 		auto replacement_function = scan.function(context, input, scan.data.get());
54: 		if (!replacement_function) {
55: 			continue;
56: 		}
57: 		if (!ref.alias.empty()) {
58: 			// user-provided alias overrides the default alias
59: 			replacement_function->alias = ref.alias;
60: 		} else if (replacement_function->alias.empty()) {
61: 			// if the replacement scan itself did not provide an alias we use the table name
62: 			replacement_function->alias = ref.table_name;
63: 		}
64: 		if (replacement_function->type == TableReferenceType::TABLE_FUNCTION) {
65: 			auto &table_function = replacement_function->Cast<TableFunctionRef>();
66: 			table_function.column_name_alias = ref.column_name_alias;
67: 		} else if (replacement_function->type == TableReferenceType::SUBQUERY) {
68: 			auto &subquery = replacement_function->Cast<SubqueryRef>();
69: 			subquery.column_name_alias = ref.column_name_alias;
70: 		} else {
71: 			throw InternalException("Replacement scan should return either a table function or a subquery");
72: 		}
73: 		if (GetBindingMode() == BindingMode::EXTRACT_REPLACEMENT_SCANS) {
74: 			AddReplacementScan(ref.table_name, replacement_function->Copy());
75: 		}
76: 		return Bind(*replacement_function);
77: 	}
78: 	return nullptr;
79: }
80: 
81: unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {
82: 	QueryErrorContext error_context(ref.query_location);
83: 	// CTEs and views are also referred to using BaseTableRefs, hence need to distinguish here
84: 	// check if the table name refers to a CTE
85: 
86: 	// CTE name should never be qualified (i.e. schema_name should be empty)
87: 	vector<reference<CommonTableExpressionInfo>> found_ctes;
88: 	if (ref.schema_name.empty()) {
89: 		found_ctes = FindCTE(ref.table_name, ref.table_name == alias);
90: 	}
91: 
92: 	if (!found_ctes.empty()) {
93: 		// Check if there is a CTE binding in the BindContext
94: 		bool circular_cte = false;
95: 		for (auto found_cte : found_ctes) {
96: 			auto &cte = found_cte.get();
97: 			auto ctebinding = bind_context.GetCTEBinding(ref.table_name);
98: 			if (ctebinding && (cte.query->node->type == QueryNodeType::RECURSIVE_CTE_NODE ||
99: 			                   cte.materialized == CTEMaterialize::CTE_MATERIALIZE_ALWAYS)) {
100: 				// There is a CTE binding in the BindContext.
101: 				// This can only be the case if there is a recursive CTE,
102: 				// or a materialized CTE present.
103: 				auto index = GenerateTableIndex();
104: 				auto materialized = cte.materialized;
105: 				if (materialized == CTEMaterialize::CTE_MATERIALIZE_DEFAULT) {
106: #ifdef DUCKDB_ALTERNATIVE_VERIFY
107: 					materialized = CTEMaterialize::CTE_MATERIALIZE_ALWAYS;
108: #else
109: 					materialized = CTEMaterialize::CTE_MATERIALIZE_NEVER;
110: #endif
111: 				}
112: 				auto result = make_uniq<BoundCTERef>(index, ctebinding->index, materialized);
113: 				auto alias = ref.alias.empty() ? ref.table_name : ref.alias;
114: 				auto names = BindContext::AliasColumnNames(alias, ctebinding->names, ref.column_name_alias);
115: 
116: 				bind_context.AddGenericBinding(index, alias, names, ctebinding->types);
117: 				// Update references to CTE
118: 				auto cteref = bind_context.cte_references[ref.table_name];
119: 				(*cteref)++;
120: 
121: 				result->types = ctebinding->types;
122: 				result->bound_columns = std::move(names);
123: 				return std::move(result);
124: 			} else {
125: 				if (CTEIsAlreadyBound(cte)) {
126: 					// remember error state
127: 					circular_cte = true;
128: 					// retry with next candidate CTE
129: 					continue;
130: 				}
131: 
132: 				// If we have found a materialized CTE, but no corresponding CTE binding,
133: 				// something is wrong.
134: 				if (cte.materialized == CTEMaterialize::CTE_MATERIALIZE_ALWAYS) {
135: 					throw BinderException(
136: 					    "There is a WITH item named \"%s\", but it cannot be referenced from this part of the query.",
137: 					    ref.table_name);
138: 				}
139: 
140: 				// Move CTE to subquery and bind recursively
141: 				SubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(cte.query->Copy()));
142: 				subquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;
143: 				subquery.column_name_alias = cte.aliases;
144: 				for (idx_t i = 0; i < ref.column_name_alias.size(); i++) {
145: 					if (i < subquery.column_name_alias.size()) {
146: 						subquery.column_name_alias[i] = ref.column_name_alias[i];
147: 					} else {
148: 						subquery.column_name_alias.push_back(ref.column_name_alias[i]);
149: 					}
150: 				}
151: 				return Bind(subquery, &found_cte.get());
152: 			}
153: 		}
154: 		if (circular_cte) {
155: 			auto replacement_scan_bind_result = BindWithReplacementScan(context, ref);
156: 			if (replacement_scan_bind_result) {
157: 				return replacement_scan_bind_result;
158: 			}
159: 
160: 			throw BinderException(
161: 			    "Circular reference to CTE \"%s\", There are two possible solutions. \n1. use WITH RECURSIVE to "
162: 			    "use recursive CTEs. \n2. If "
163: 			    "you want to use the TABLE name \"%s\" the same as the CTE name, please explicitly add "
164: 			    "\"SCHEMA\" before table name. You can try \"main.%s\" (main is the duckdb default schema)",
165: 			    ref.table_name, ref.table_name, ref.table_name);
166: 		}
167: 	}
168: 	// not a CTE
169: 	// extract a table or view from the catalog
170: 	BindSchemaOrCatalog(ref.catalog_name, ref.schema_name);
171: 	auto table_or_view = entry_retriever.GetEntry(CatalogType::TABLE_ENTRY, ref.catalog_name, ref.schema_name,
172: 	                                              ref.table_name, OnEntryNotFound::RETURN_NULL, error_context);
173: 	// we still didn't find the table
174: 	if (GetBindingMode() == BindingMode::EXTRACT_NAMES) {
175: 		if (!table_or_view || table_or_view->type == CatalogType::TABLE_ENTRY) {
176: 			// if we are in EXTRACT_NAMES, we create a dummy table ref
177: 			AddTableName(ref.table_name);
178: 
179: 			// add a bind context entry
180: 			auto table_index = GenerateTableIndex();
181: 			auto alias = ref.alias.empty() ? ref.table_name : ref.alias;
182: 			vector<LogicalType> types {LogicalType::INTEGER};
183: 			vector<string> names {"__dummy_col" + to_string(table_index)};
184: 			bind_context.AddGenericBinding(table_index, alias, names, types);
185: 			return make_uniq_base<BoundTableRef, BoundEmptyTableRef>(table_index);
186: 		}
187: 	}
188: 	if (!table_or_view) {
189: 		// table could not be found: try to bind a replacement scan
190: 		// Try replacement scan bind
191: 		auto replacement_scan_bind_result = BindWithReplacementScan(context, ref);
192: 		if (replacement_scan_bind_result) {
193: 			return replacement_scan_bind_result;
194: 		}
195: 
196: 		// Try autoloading an extension, then retry the replacement scan bind
197: 		auto full_path = ReplacementScan::GetFullPath(ref.catalog_name, ref.schema_name, ref.table_name);
198: 		auto extension_loaded = TryLoadExtensionForReplacementScan(context, full_path);
199: 		if (extension_loaded) {
200: 			replacement_scan_bind_result = BindWithReplacementScan(context, ref);
201: 			if (replacement_scan_bind_result) {
202: 				return replacement_scan_bind_result;
203: 			}
204: 		}
205: 		auto &config = DBConfig::GetConfig(context);
206: 		if (context.config.use_replacement_scans && config.options.enable_external_access &&
207: 		    ExtensionHelper::IsFullPath(full_path)) {
208: 			auto &fs = FileSystem::GetFileSystem(context);
209: 			if (fs.FileExists(full_path)) {
210: 				throw BinderException(
211: 				    "No extension found that is capable of reading the file \"%s\"\n* If this file is a supported file "
212: 				    "format you can explicitly use the reader functions, such as read_csv, read_json or read_parquet",
213: 				    full_path);
214: 			}
215: 		}
216: 
217: 		// could not find an alternative: bind again to get the error
218: 		(void)entry_retriever.GetEntry(CatalogType::TABLE_ENTRY, ref.catalog_name, ref.schema_name, ref.table_name,
219: 		                               OnEntryNotFound::THROW_EXCEPTION, error_context);
220: 		throw InternalException("Catalog::GetEntry should have thrown an exception above");
221: 	}
222: 
223: 	switch (table_or_view->type) {
224: 	case CatalogType::TABLE_ENTRY: {
225: 		// base table: create the BoundBaseTableRef node
226: 		auto table_index = GenerateTableIndex();
227: 		auto &table = table_or_view->Cast<TableCatalogEntry>();
228: 
229: 		auto &properties = GetStatementProperties();
230: 		properties.RegisterDBRead(table.ParentCatalog(), context);
231: 
232: 		unique_ptr<FunctionData> bind_data;
233: 		auto scan_function = table.GetScanFunction(context, bind_data);
234: 		auto alias = ref.alias.empty() ? ref.table_name : ref.alias;
235: 		// TODO: bundle the type and name vector in a struct (e.g PackedColumnMetadata)
236: 		vector<LogicalType> table_types;
237: 		vector<string> table_names;
238: 		vector<TableColumnType> table_categories;
239: 
240: 		vector<LogicalType> return_types;
241: 		vector<string> return_names;
242: 		for (auto &col : table.GetColumns().Logical()) {
243: 			table_types.push_back(col.Type());
244: 			table_names.push_back(col.Name());
245: 			return_types.push_back(col.Type());
246: 			return_names.push_back(col.Name());
247: 		}
248: 		table_names = BindContext::AliasColumnNames(alias, table_names, ref.column_name_alias);
249: 
250: 		auto logical_get = make_uniq<LogicalGet>(table_index, scan_function, std::move(bind_data),
251: 		                                         std::move(return_types), std::move(return_names));
252: 		bind_context.AddBaseTable(table_index, alias, table_names, table_types, logical_get->GetMutableColumnIds(),
253: 		                          logical_get->GetTable().get());
254: 		return make_uniq_base<BoundTableRef, BoundBaseTableRef>(table, std::move(logical_get));
255: 	}
256: 	case CatalogType::VIEW_ENTRY: {
257: 		// the node is a view: get the query that the view represents
258: 		auto &view_catalog_entry = table_or_view->Cast<ViewCatalogEntry>();
259: 		// We need to use a new binder for the view that doesn't reference any CTEs
260: 		// defined for this binder so there are no collisions between the CTEs defined
261: 		// for the view and for the current query
262: 		auto view_binder = Binder::CreateBinder(context, this, BinderType::VIEW_BINDER);
263: 		view_binder->can_contain_nulls = true;
264: 		SubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(view_catalog_entry.query->Copy()));
265: 		subquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;
266: 		// construct view names by first (1) taking the view aliases, (2) adding the view names, then (3) applying
267: 		// subquery aliases
268: 		vector<string> view_names = view_catalog_entry.aliases;
269: 		for (idx_t n = view_names.size(); n < view_catalog_entry.names.size(); n++) {
270: 			view_names.push_back(view_catalog_entry.names[n]);
271: 		}
272: 		subquery.column_name_alias = BindContext::AliasColumnNames(subquery.alias, view_names, ref.column_name_alias);
273: 		// bind the child subquery
274: 		view_binder->AddBoundView(view_catalog_entry);
275: 		auto bound_child = view_binder->Bind(subquery);
276: 		if (!view_binder->correlated_columns.empty()) {
277: 			throw BinderException("Contents of view were altered - view bound correlated columns");
278: 		}
279: 
280: 		D_ASSERT(bound_child->type == TableReferenceType::SUBQUERY);
281: 		// verify that the types and names match up with the expected types and names
282: 		auto &bound_subquery = bound_child->Cast<BoundSubqueryRef>();
283: 		if (GetBindingMode() != BindingMode::EXTRACT_NAMES) {
284: 			if (bound_subquery.subquery->types != view_catalog_entry.types) {
285: 				auto actual_types = StringUtil::ToString(bound_subquery.subquery->types, ", ");
286: 				auto expected_types = StringUtil::ToString(view_catalog_entry.types, ", ");
287: 				throw BinderException(
288: 				    "Contents of view were altered: types don't match! Expected [%s], but found [%s] instead",
289: 				    expected_types, actual_types);
290: 			}
291: 			if (bound_subquery.subquery->names.size() == view_catalog_entry.names.size() &&
292: 			    bound_subquery.subquery->names != view_catalog_entry.names) {
293: 				auto actual_names = StringUtil::Join(bound_subquery.subquery->names, ", ");
294: 				auto expected_names = StringUtil::Join(view_catalog_entry.names, ", ");
295: 				throw BinderException(
296: 				    "Contents of view were altered: names don't match! Expected [%s], but found [%s] instead",
297: 				    expected_names, actual_names);
298: 			}
299: 		}
300: 		bind_context.AddView(bound_subquery.subquery->GetRootIndex(), subquery.alias, subquery,
301: 		                     *bound_subquery.subquery, &view_catalog_entry);
302: 		return bound_child;
303: 	}
304: 	default:
305: 		throw InternalException("Catalog entry type");
306: 	}
307: }
308: } // namespace duckdb
[end of src/planner/binder/tableref/bind_basetableref.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: