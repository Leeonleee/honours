{
  "repo": "duckdb/duckdb",
  "pull_number": 13921,
  "instance_id": "duckdb__duckdb-13921",
  "issue_numbers": [
    "13769",
    "13769"
  ],
  "base_commit": "ca0c09c0960a86297c2a51cde642b2bccfafef98",
  "patch": "diff --git a/Makefile b/Makefile\nindex e1c4d723eb22..f621e71b3cfb 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -231,6 +231,9 @@ endif\n ifeq (${DISABLE_EXTENSION_LOAD}, 1)\n \tCMAKE_VARS:=${CMAKE_VARS} -DDISABLE_EXTENSION_LOAD=1\n endif\n+ifeq (${DISABLE_SHELL}, 1)\n+\tCMAKE_VARS:=${CMAKE_VARS} -DBUILD_SHELL=0\n+endif\n CMAKE_VARS:=${CMAKE_VARS} -DLOCAL_EXTENSION_REPO=\"${LOCAL_EXTENSION_REPO}\"\n ifneq (${OSX_BUILD_ARCH}, )\n \tCMAKE_VARS:=${CMAKE_VARS} -DOSX_BUILD_ARCH=${OSX_BUILD_ARCH}\ndiff --git a/src/catalog/catalog.cpp b/src/catalog/catalog.cpp\nindex 08a01d93d593..cd232c6d11ac 100644\n--- a/src/catalog/catalog.cpp\n+++ b/src/catalog/catalog.cpp\n@@ -71,7 +71,12 @@ Catalog &Catalog::GetSystemCatalog(ClientContext &context) {\n \treturn Catalog::GetSystemCatalog(*context.db);\n }\n \n-optional_ptr<Catalog> Catalog::GetCatalogEntry(ClientContext &context, const string &catalog_name) {\n+const string &GetDefaultCatalog(CatalogEntryRetriever &retriever) {\n+\treturn DatabaseManager::GetDefaultDatabase(retriever.GetContext());\n+}\n+\n+optional_ptr<Catalog> Catalog::GetCatalogEntry(CatalogEntryRetriever &retriever, const string &catalog_name) {\n+\tauto &context = retriever.GetContext();\n \tauto &db_manager = DatabaseManager::Get(context);\n \tif (catalog_name == TEMP_CATALOG) {\n \t\treturn &ClientData::Get(context).temporary_objects->GetCatalog();\n@@ -79,22 +84,32 @@ optional_ptr<Catalog> Catalog::GetCatalogEntry(ClientContext &context, const str\n \tif (catalog_name == SYSTEM_CATALOG) {\n \t\treturn &GetSystemCatalog(context);\n \t}\n-\tauto entry = db_manager.GetDatabase(\n-\t    context, IsInvalidCatalog(catalog_name) ? DatabaseManager::GetDefaultDatabase(context) : catalog_name);\n+\tauto entry =\n+\t    db_manager.GetDatabase(context, IsInvalidCatalog(catalog_name) ? GetDefaultCatalog(retriever) : catalog_name);\n \tif (!entry) {\n \t\treturn nullptr;\n \t}\n \treturn &entry->GetCatalog();\n }\n \n-Catalog &Catalog::GetCatalog(ClientContext &context, const string &catalog_name) {\n-\tauto catalog = Catalog::GetCatalogEntry(context, catalog_name);\n+optional_ptr<Catalog> Catalog::GetCatalogEntry(ClientContext &context, const string &catalog_name) {\n+\tCatalogEntryRetriever entry_retriever(context);\n+\treturn GetCatalogEntry(entry_retriever, catalog_name);\n+}\n+\n+Catalog &Catalog::GetCatalog(CatalogEntryRetriever &retriever, const string &catalog_name) {\n+\tauto catalog = Catalog::GetCatalogEntry(retriever, catalog_name);\n \tif (!catalog) {\n \t\tthrow BinderException(\"Catalog \\\"%s\\\" does not exist!\", catalog_name);\n \t}\n \treturn *catalog;\n }\n \n+Catalog &Catalog::GetCatalog(ClientContext &context, const string &catalog_name) {\n+\tCatalogEntryRetriever entry_retriever(context);\n+\treturn GetCatalog(entry_retriever, catalog_name);\n+}\n+\n //===--------------------------------------------------------------------===//\n // Schema\n //===--------------------------------------------------------------------===//\n@@ -321,8 +336,8 @@ void Catalog::DropEntry(ClientContext &context, DropInfo &info) {\n \t\treturn;\n \t}\n \n-\tauto lookup = LookupEntry(context, info.type, info.schema, info.name, info.if_not_found);\n-\n+\tCatalogEntryRetriever retriever(context);\n+\tauto lookup = LookupEntry(retriever, info.type, info.schema, info.name, info.if_not_found);\n \tif (!lookup.Found()) {\n \t\treturn;\n \t}\n@@ -371,9 +386,11 @@ SimilarCatalogEntry Catalog::SimilarEntryInSchemas(ClientContext &context, const\n \treturn result;\n }\n \n-vector<CatalogSearchEntry> GetCatalogEntries(ClientContext &context, const string &catalog, const string &schema) {\n+vector<CatalogSearchEntry> GetCatalogEntries(CatalogEntryRetriever &retriever, const string &catalog,\n+                                             const string &schema) {\n+\tauto &context = retriever.GetContext();\n \tvector<CatalogSearchEntry> entries;\n-\tauto &search_path = *context.client_data->catalog_search_path;\n+\tauto &search_path = retriever.GetSearchPath();\n \tif (IsInvalidCatalog(catalog) && IsInvalidSchema(schema)) {\n \t\t// no catalog or schema provided - scan the entire search path\n \t\tentries = search_path.Get();\n@@ -400,11 +417,11 @@ vector<CatalogSearchEntry> GetCatalogEntries(ClientContext &context, const strin\n \treturn entries;\n }\n \n-void FindMinimalQualification(ClientContext &context, const string &catalog_name, const string &schema_name,\n+void FindMinimalQualification(CatalogEntryRetriever &retriever, const string &catalog_name, const string &schema_name,\n                               bool &qualify_database, bool &qualify_schema) {\n \t// check if we can we qualify ONLY the schema\n \tbool found = false;\n-\tauto entries = GetCatalogEntries(context, INVALID_CATALOG, schema_name);\n+\tauto entries = GetCatalogEntries(retriever, INVALID_CATALOG, schema_name);\n \tfor (auto &entry : entries) {\n \t\tif (entry.catalog == catalog_name && entry.schema == schema_name) {\n \t\t\tfound = true;\n@@ -418,7 +435,7 @@ void FindMinimalQualification(ClientContext &context, const string &catalog_name\n \t}\n \t// check if we can qualify ONLY the catalog\n \tfound = false;\n-\tentries = GetCatalogEntries(context, catalog_name, INVALID_SCHEMA);\n+\tentries = GetCatalogEntries(retriever, catalog_name, INVALID_SCHEMA);\n \tfor (auto &entry : entries) {\n \t\tif (entry.catalog == catalog_name && entry.schema == schema_name) {\n \t\t\tfound = true;\n@@ -553,10 +570,11 @@ CatalogException Catalog::UnrecognizedConfigurationError(ClientContext &context,\n \tthrow CatalogException::MissingEntry(\"configuration parameter\", name, potential_names);\n }\n \n-CatalogException Catalog::CreateMissingEntryException(ClientContext &context, const string &entry_name,\n+CatalogException Catalog::CreateMissingEntryException(CatalogEntryRetriever &retriever, const string &entry_name,\n                                                       CatalogType type,\n                                                       const reference_set_t<SchemaCatalogEntry> &schemas,\n                                                       QueryErrorContext error_context) {\n+\tauto &context = retriever.GetContext();\n \tauto entry = SimilarEntryInSchemas(context, entry_name, type, schemas);\n \n \treference_set_t<SchemaCatalogEntry> unseen_schemas;\n@@ -646,7 +664,7 @@ CatalogException Catalog::CreateMissingEntryException(ClientContext &context, co\n \t\tauto schema_name = unseen_entry.schema->name;\n \t\tbool qualify_database;\n \t\tbool qualify_schema;\n-\t\tFindMinimalQualification(context, catalog_name, schema_name, qualify_database, qualify_schema);\n+\t\tFindMinimalQualification(retriever, catalog_name, schema_name, qualify_database, qualify_schema);\n \t\tdid_you_mean = unseen_entry.GetQualifiedName(qualify_database, qualify_schema);\n \t} else if (entry.Found()) {\n \t\tdid_you_mean = entry.name;\n@@ -667,13 +685,14 @@ CatalogEntryLookup Catalog::TryLookupEntryInternal(CatalogTransaction transactio\n \treturn {schema_entry, entry, ErrorData()};\n }\n \n-CatalogEntryLookup Catalog::TryLookupEntry(ClientContext &context, CatalogType type, const string &schema,\n+CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &schema,\n                                            const string &name, OnEntryNotFound if_not_found,\n                                            QueryErrorContext error_context) {\n+\tauto &context = retriever.GetContext();\n \treference_set_t<SchemaCatalogEntry> schemas;\n \tif (IsInvalidSchema(schema)) {\n \t\t// try all schemas for this catalog\n-\t\tauto entries = GetCatalogEntries(context, GetName(), INVALID_SCHEMA);\n+\t\tauto entries = GetCatalogEntries(retriever, GetName(), INVALID_SCHEMA);\n \t\tfor (auto &entry : entries) {\n \t\t\tauto &candidate_schema = entry.schema;\n \t\t\tauto transaction = GetCatalogTransaction(context);\n@@ -699,15 +718,15 @@ CatalogEntryLookup Catalog::TryLookupEntry(ClientContext &context, CatalogType t\n \tif (if_not_found == OnEntryNotFound::RETURN_NULL) {\n \t\treturn {nullptr, nullptr, ErrorData()};\n \t} else {\n-\t\tauto except = CreateMissingEntryException(context, name, type, schemas, error_context);\n+\t\tauto except = CreateMissingEntryException(retriever, name, type, schemas, error_context);\n \t\treturn {nullptr, nullptr, ErrorData(except)};\n \t}\n }\n \n-CatalogEntryLookup Catalog::LookupEntry(ClientContext &context, CatalogType type, const string &schema,\n+CatalogEntryLookup Catalog::LookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &schema,\n                                         const string &name, OnEntryNotFound if_not_found,\n                                         QueryErrorContext error_context) {\n-\tauto res = TryLookupEntry(context, type, schema, name, if_not_found, error_context);\n+\tauto res = TryLookupEntry(retriever, type, schema, name, if_not_found, error_context);\n \n \tif (res.error.HasError()) {\n \t\tres.error.Throw();\n@@ -716,9 +735,10 @@ CatalogEntryLookup Catalog::LookupEntry(ClientContext &context, CatalogType type\n \treturn res;\n }\n \n-CatalogEntryLookup Catalog::TryLookupEntry(ClientContext &context, vector<CatalogLookup> &lookups, CatalogType type,\n-                                           const string &name, OnEntryNotFound if_not_found,\n+CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, vector<CatalogLookup> &lookups,\n+                                           CatalogType type, const string &name, OnEntryNotFound if_not_found,\n                                            QueryErrorContext error_context) {\n+\tauto &context = retriever.GetContext();\n \treference_set_t<SchemaCatalogEntry> schemas;\n \tfor (auto &lookup : lookups) {\n \t\tauto transaction = lookup.catalog.GetCatalogTransaction(context);\n@@ -734,24 +754,24 @@ CatalogEntryLookup Catalog::TryLookupEntry(ClientContext &context, vector<Catalo\n \tif (if_not_found == OnEntryNotFound::RETURN_NULL) {\n \t\treturn {nullptr, nullptr, ErrorData()};\n \t} else {\n-\t\tauto except = CreateMissingEntryException(context, name, type, schemas, error_context);\n+\t\tauto except = CreateMissingEntryException(retriever, name, type, schemas, error_context);\n \t\treturn {nullptr, nullptr, ErrorData(except)};\n \t}\n }\n \n-CatalogEntryLookup Catalog::TryLookupEntry(ClientContext &context, CatalogType type, const string &catalog,\n+CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &catalog,\n                                            const string &schema, const string &name, OnEntryNotFound if_not_found,\n                                            QueryErrorContext error_context) {\n-\tauto entries = GetCatalogEntries(context, catalog, schema);\n+\tauto entries = GetCatalogEntries(retriever, catalog, schema);\n \tvector<CatalogLookup> lookups;\n \tvector<CatalogLookup> final_lookups;\n \tlookups.reserve(entries.size());\n \tfor (auto &entry : entries) {\n \t\toptional_ptr<Catalog> catalog_entry;\n \t\tif (if_not_found == OnEntryNotFound::RETURN_NULL) {\n-\t\t\tcatalog_entry = Catalog::GetCatalogEntry(context, entry.catalog);\n+\t\t\tcatalog_entry = Catalog::GetCatalogEntry(retriever, entry.catalog);\n \t\t} else {\n-\t\t\tcatalog_entry = &Catalog::GetCatalog(context, entry.catalog);\n+\t\t\tcatalog_entry = &Catalog::GetCatalog(retriever, entry.catalog);\n \t\t}\n \t\tif (!catalog_entry) {\n \t\t\treturn {nullptr, nullptr, ErrorData()};\n@@ -767,18 +787,18 @@ CatalogEntryLookup Catalog::TryLookupEntry(ClientContext &context, CatalogType t\n \tfor (auto &lookup : final_lookups) {\n \t\tlookups.emplace_back(std::move(lookup));\n \t}\n-\treturn Catalog::TryLookupEntry(context, lookups, type, name, if_not_found, error_context);\n+\treturn Catalog::TryLookupEntry(retriever, lookups, type, name, if_not_found, error_context);\n }\n \n-optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema_name,\n-                                             const string &name, OnEntryNotFound if_not_found,\n-                                             QueryErrorContext error_context) {\n-\tauto lookup_entry = TryLookupEntry(context, type, schema_name, name, if_not_found, error_context);\n+optional_ptr<CatalogEntry> Catalog::GetEntry(CatalogEntryRetriever &retriever, CatalogType type,\n+                                             const string &schema_name, const string &name,\n+                                             OnEntryNotFound if_not_found, QueryErrorContext error_context) {\n+\tauto lookup_entry = TryLookupEntry(retriever, type, schema_name, name, if_not_found, error_context);\n \n \t// Try autoloading extension to resolve lookup\n \tif (!lookup_entry.Found()) {\n-\t\tif (AutoLoadExtensionByCatalogEntry(*context.db, type, name)) {\n-\t\t\tlookup_entry = TryLookupEntry(context, type, schema_name, name, if_not_found, error_context);\n+\t\tif (AutoLoadExtensionByCatalogEntry(*retriever.GetContext().db, type, name)) {\n+\t\t\tlookup_entry = TryLookupEntry(retriever, type, schema_name, name, if_not_found, error_context);\n \t\t}\n \t}\n \n@@ -789,20 +809,27 @@ optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType\n \treturn lookup_entry.entry.get();\n }\n \n+optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema_name,\n+                                             const string &name, OnEntryNotFound if_not_found,\n+                                             QueryErrorContext error_context) {\n+\tCatalogEntryRetriever retriever(context);\n+\treturn GetEntry(retriever, type, schema_name, name, if_not_found, error_context);\n+}\n+\n CatalogEntry &Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema, const string &name,\n                                 QueryErrorContext error_context) {\n \treturn *Catalog::GetEntry(context, type, schema, name, OnEntryNotFound::THROW_EXCEPTION, error_context);\n }\n \n-optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType type, const string &catalog,\n+optional_ptr<CatalogEntry> Catalog::GetEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &catalog,\n                                              const string &schema, const string &name, OnEntryNotFound if_not_found,\n                                              QueryErrorContext error_context) {\n-\tauto result = TryLookupEntry(context, type, catalog, schema, name, if_not_found, error_context);\n+\tauto result = TryLookupEntry(retriever, type, catalog, schema, name, if_not_found, error_context);\n \n \t// Try autoloading extension to resolve lookup\n \tif (!result.Found()) {\n-\t\tif (AutoLoadExtensionByCatalogEntry(*context.db, type, name)) {\n-\t\t\tresult = TryLookupEntry(context, type, catalog, schema, name, if_not_found, error_context);\n+\t\tif (AutoLoadExtensionByCatalogEntry(*retriever.GetContext().db, type, name)) {\n+\t\t\tresult = TryLookupEntry(retriever, type, catalog, schema, name, if_not_found, error_context);\n \t\t}\n \t}\n \n@@ -816,20 +843,26 @@ optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType\n \t}\n \treturn result.entry.get();\n }\n+optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType type, const string &catalog,\n+                                             const string &schema, const string &name, OnEntryNotFound if_not_found,\n+                                             QueryErrorContext error_context) {\n+\tCatalogEntryRetriever retriever(context);\n+\treturn GetEntry(retriever, type, catalog, schema, name, if_not_found, error_context);\n+}\n \n CatalogEntry &Catalog::GetEntry(ClientContext &context, CatalogType type, const string &catalog, const string &schema,\n                                 const string &name, QueryErrorContext error_context) {\n \treturn *Catalog::GetEntry(context, type, catalog, schema, name, OnEntryNotFound::THROW_EXCEPTION, error_context);\n }\n \n-optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(ClientContext &context, const string &catalog_name,\n+optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(CatalogEntryRetriever &retriever, const string &catalog_name,\n                                                     const string &schema_name, OnEntryNotFound if_not_found,\n                                                     QueryErrorContext error_context) {\n-\tauto entries = GetCatalogEntries(context, catalog_name, schema_name);\n+\tauto entries = GetCatalogEntries(retriever, catalog_name, schema_name);\n \tfor (idx_t i = 0; i < entries.size(); i++) {\n \t\tauto on_not_found = i + 1 == entries.size() ? if_not_found : OnEntryNotFound::RETURN_NULL;\n-\t\tauto &catalog = Catalog::GetCatalog(context, entries[i].catalog);\n-\t\tauto result = catalog.GetSchema(context, schema_name, on_not_found, error_context);\n+\t\tauto &catalog = Catalog::GetCatalog(retriever, entries[i].catalog);\n+\t\tauto result = catalog.GetSchema(retriever.GetContext(), schema_name, on_not_found, error_context);\n \t\tif (result) {\n \t\t\treturn result;\n \t\t}\n@@ -837,20 +870,28 @@ optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(ClientContext &context, cons\n \treturn nullptr;\n }\n \n+optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(ClientContext &context, const string &catalog_name,\n+                                                    const string &schema_name, OnEntryNotFound if_not_found,\n+                                                    QueryErrorContext error_context) {\n+\tCatalogEntryRetriever retriever(context);\n+\treturn GetSchema(retriever, catalog_name, schema_name, if_not_found, error_context);\n+}\n+\n vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(ClientContext &context) {\n \tvector<reference<SchemaCatalogEntry>> schemas;\n \tScanSchemas(context, [&](SchemaCatalogEntry &entry) { schemas.push_back(entry); });\n \treturn schemas;\n }\n \n-vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(ClientContext &context, const string &catalog_name) {\n+vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(CatalogEntryRetriever &retriever,\n+                                                          const string &catalog_name) {\n \tvector<reference<Catalog>> catalogs;\n \tif (IsInvalidCatalog(catalog_name)) {\n \t\treference_set_t<Catalog> inserted_catalogs;\n \n-\t\tauto &search_path = *context.client_data->catalog_search_path;\n+\t\tauto &search_path = retriever.GetSearchPath();\n \t\tfor (auto &entry : search_path.Get()) {\n-\t\t\tauto &catalog = Catalog::GetCatalog(context, entry.catalog);\n+\t\t\tauto &catalog = Catalog::GetCatalog(retriever, entry.catalog);\n \t\t\tif (inserted_catalogs.find(catalog) != inserted_catalogs.end()) {\n \t\t\t\tcontinue;\n \t\t\t}\n@@ -858,16 +899,21 @@ vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(ClientContext &context\n \t\t\tcatalogs.push_back(catalog);\n \t\t}\n \t} else {\n-\t\tcatalogs.push_back(Catalog::GetCatalog(context, catalog_name));\n+\t\tcatalogs.push_back(Catalog::GetCatalog(retriever, catalog_name));\n \t}\n \tvector<reference<SchemaCatalogEntry>> result;\n \tfor (auto catalog : catalogs) {\n-\t\tauto schemas = catalog.get().GetSchemas(context);\n+\t\tauto schemas = catalog.get().GetSchemas(retriever.GetContext());\n \t\tresult.insert(result.end(), schemas.begin(), schemas.end());\n \t}\n \treturn result;\n }\n \n+vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(ClientContext &context, const string &catalog_name) {\n+\tCatalogEntryRetriever retriever(context);\n+\treturn GetSchemas(retriever, catalog_name);\n+}\n+\n vector<reference<SchemaCatalogEntry>> Catalog::GetAllSchemas(ClientContext &context) {\n \tvector<reference<SchemaCatalogEntry>> result;\n \n@@ -896,8 +942,8 @@ vector<reference<SchemaCatalogEntry>> Catalog::GetAllSchemas(ClientContext &cont\n \n void Catalog::Alter(CatalogTransaction transaction, AlterInfo &info) {\n \tif (transaction.HasContext()) {\n-\t\tauto lookup =\n-\t\t    LookupEntry(transaction.GetContext(), info.GetCatalogType(), info.schema, info.name, info.if_not_found);\n+\t\tCatalogEntryRetriever retriever(transaction.GetContext());\n+\t\tauto lookup = LookupEntry(retriever, info.GetCatalogType(), info.schema, info.name, info.if_not_found);\n \t\tif (!lookup.Found()) {\n \t\t\treturn;\n \t\t}\ndiff --git a/src/catalog/catalog_entry_retriever.cpp b/src/catalog/catalog_entry_retriever.cpp\nindex db0d0d423984..c37562d72144 100644\n--- a/src/catalog/catalog_entry_retriever.cpp\n+++ b/src/catalog/catalog_entry_retriever.cpp\n@@ -7,6 +7,7 @@\n #include \"duckdb/common/enums/catalog_type.hpp\"\n #include \"duckdb/common/optional_ptr.hpp\"\n #include \"duckdb/catalog/catalog_entry/type_catalog_entry.hpp\"\n+#include \"duckdb/main/client_data.hpp\"\n \n namespace duckdb {\n \n@@ -36,14 +37,13 @@ optional_ptr<CatalogEntry> CatalogEntryRetriever::GetEntry(CatalogType type, con\n                                                            const string &schema, const string &name,\n                                                            OnEntryNotFound on_entry_not_found,\n                                                            QueryErrorContext error_context) {\n-\treturn GetEntryInternal(\n-\t    [&]() { return Catalog::GetEntry(context, type, catalog, schema, name, on_entry_not_found, error_context); });\n+\treturn ReturnAndCallback(Catalog::GetEntry(*this, type, catalog, schema, name, on_entry_not_found, error_context));\n }\n \n optional_ptr<SchemaCatalogEntry> CatalogEntryRetriever::GetSchema(const string &catalog, const string &name,\n                                                                   OnEntryNotFound on_entry_not_found,\n                                                                   QueryErrorContext error_context) {\n-\tauto result = Catalog::GetSchema(context, catalog, name, on_entry_not_found, error_context);\n+\tauto result = Catalog::GetSchema(*this, catalog, name, on_entry_not_found, error_context);\n \tif (!result) {\n \t\treturn result;\n \t}\n@@ -57,8 +57,63 @@ optional_ptr<SchemaCatalogEntry> CatalogEntryRetriever::GetSchema(const string &\n optional_ptr<CatalogEntry> CatalogEntryRetriever::GetEntry(CatalogType type, Catalog &catalog, const string &schema,\n                                                            const string &name, OnEntryNotFound on_entry_not_found,\n                                                            QueryErrorContext error_context) {\n-\treturn GetEntryInternal(\n-\t    [&]() { return catalog.GetEntry(context, type, schema, name, on_entry_not_found, error_context); });\n+\treturn ReturnAndCallback(catalog.GetEntry(*this, type, schema, name, on_entry_not_found, error_context));\n+}\n+\n+optional_ptr<CatalogEntry> CatalogEntryRetriever::ReturnAndCallback(optional_ptr<CatalogEntry> result) {\n+\tif (!result) {\n+\t\treturn result;\n+\t}\n+\tif (callback) {\n+\t\t// Call the callback if it's set\n+\t\tcallback(*result);\n+\t}\n+\treturn result;\n+}\n+\n+void CatalogEntryRetriever::Inherit(const CatalogEntryRetriever &parent) {\n+\tthis->callback = parent.callback;\n+\tthis->search_path = parent.search_path;\n+}\n+\n+CatalogSearchPath &CatalogEntryRetriever::GetSearchPath() {\n+\tif (search_path) {\n+\t\treturn *search_path;\n+\t}\n+\treturn *ClientData::Get(context).catalog_search_path;\n+}\n+\n+void CatalogEntryRetriever::SetSearchPath(vector<CatalogSearchEntry> entries) {\n+\tvector<CatalogSearchEntry> new_path;\n+\tfor (auto &entry : entries) {\n+\t\tif (IsInvalidCatalog(entry.catalog) || entry.catalog == SYSTEM_CATALOG || entry.catalog == TEMP_CATALOG) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tnew_path.push_back(std::move(entry));\n+\t}\n+\tif (new_path.empty()) {\n+\t\treturn;\n+\t}\n+\n+\t// push the set paths from the ClientContext behind the provided paths\n+\tauto &client_search_path = *ClientData::Get(context).catalog_search_path;\n+\tauto &set_paths = client_search_path.GetSetPaths();\n+\tfor (auto path : set_paths) {\n+\t\tif (IsInvalidCatalog(path.catalog)) {\n+\t\t\tpath.catalog = DatabaseManager::GetDefaultDatabase(context);\n+\t\t}\n+\t\tnew_path.push_back(std::move(path));\n+\t}\n+\n+\tthis->search_path = make_shared_ptr<CatalogSearchPath>(context, std::move(new_path));\n+}\n+\n+void CatalogEntryRetriever::SetCallback(catalog_entry_callback_t callback) {\n+\tthis->callback = std::move(callback);\n+}\n+\n+catalog_entry_callback_t CatalogEntryRetriever::GetCallback() {\n+\treturn callback;\n }\n \n } // namespace duckdb\ndiff --git a/src/catalog/catalog_search_path.cpp b/src/catalog/catalog_search_path.cpp\nindex 9368e300f4ad..fe314dde7478 100644\n--- a/src/catalog/catalog_search_path.cpp\n+++ b/src/catalog/catalog_search_path.cpp\n@@ -123,13 +123,17 @@ vector<CatalogSearchEntry> CatalogSearchEntry::ParseList(const string &input) {\n \treturn result;\n }\n \n-CatalogSearchPath::CatalogSearchPath(ClientContext &context_p) : context(context_p) {\n-\tReset();\n+CatalogSearchPath::CatalogSearchPath(ClientContext &context_p, vector<CatalogSearchEntry> entries)\n+    : context(context_p) {\n+\tSetPathsInternal(std::move(entries));\n+}\n+\n+CatalogSearchPath::CatalogSearchPath(ClientContext &context_p) : CatalogSearchPath(context_p, {}) {\n }\n \n void CatalogSearchPath::Reset() {\n \tvector<CatalogSearchEntry> empty;\n-\tSetPaths(empty);\n+\tSetPathsInternal(empty);\n }\n \n string CatalogSearchPath::GetSetName(CatalogSetPathType set_type) {\n@@ -176,8 +180,7 @@ void CatalogSearchPath::Set(vector<CatalogSearchEntry> new_paths, CatalogSetPath\n \t\t\t                       new_paths[0].catalog);\n \t\t}\n \t}\n-\tthis->set_paths = std::move(new_paths);\n-\tSetPaths(set_paths);\n+\tSetPathsInternal(std::move(new_paths));\n }\n \n void CatalogSearchPath::Set(CatalogSearchEntry new_value, CatalogSetPathType set_type) {\n@@ -239,12 +242,14 @@ const CatalogSearchEntry &CatalogSearchPath::GetDefault() {\n \treturn paths[1];\n }\n \n-void CatalogSearchPath::SetPaths(vector<CatalogSearchEntry> new_paths) {\n+void CatalogSearchPath::SetPathsInternal(vector<CatalogSearchEntry> new_paths) {\n+\tthis->set_paths = std::move(new_paths);\n+\n \tpaths.clear();\n-\tpaths.reserve(new_paths.size() + 3);\n+\tpaths.reserve(set_paths.size() + 3);\n \tpaths.emplace_back(TEMP_CATALOG, DEFAULT_SCHEMA);\n-\tfor (auto &path : new_paths) {\n-\t\tpaths.push_back(std::move(path));\n+\tfor (auto &path : set_paths) {\n+\t\tpaths.push_back(path);\n \t}\n \tpaths.emplace_back(INVALID_CATALOG, DEFAULT_SCHEMA);\n \tpaths.emplace_back(SYSTEM_CATALOG, DEFAULT_SCHEMA);\ndiff --git a/src/include/duckdb/catalog/catalog.hpp b/src/include/duckdb/catalog/catalog.hpp\nindex 278866020439..2bf7fad6e3c2 100644\n--- a/src/include/duckdb/catalog/catalog.hpp\n+++ b/src/include/duckdb/catalog/catalog.hpp\n@@ -70,6 +70,7 @@ class LogicalInsert;\n class LogicalDelete;\n class LogicalUpdate;\n class CreateStatement;\n+class CatalogEntryRetriever;\n \n //! The Catalog object represents the catalog of the database.\n class Catalog {\n@@ -84,10 +85,15 @@ class Catalog {\n \tDUCKDB_API static Catalog &GetSystemCatalog(DatabaseInstance &db);\n \t//! Get the specified Catalog from the ClientContext\n \tDUCKDB_API static Catalog &GetCatalog(ClientContext &context, const string &catalog_name);\n+\t//! Get the specified Catalog from the ClientContext\n+\tDUCKDB_API static Catalog &GetCatalog(CatalogEntryRetriever &retriever, const string &catalog_name);\n \t//! Get the specified Catalog from the DatabaseInstance\n \tDUCKDB_API static Catalog &GetCatalog(DatabaseInstance &db, const string &catalog_name);\n \t//! Gets the specified Catalog from the database if it exists\n \tDUCKDB_API static optional_ptr<Catalog> GetCatalogEntry(ClientContext &context, const string &catalog_name);\n+\t//! Gets the specified Catalog from the database if it exists\n+\tDUCKDB_API static optional_ptr<Catalog> GetCatalogEntry(CatalogEntryRetriever &retriever,\n+\t                                                        const string &catalog_name);\n \t//! Get the specific Catalog from the AttachedDatabase\n \tDUCKDB_API static Catalog &GetCatalog(AttachedDatabase &db);\n \n@@ -214,6 +220,10 @@ class Catalog {\n \t                                                             const string &schema_name,\n \t                                                             OnEntryNotFound if_not_found,\n \t                                                             QueryErrorContext error_context = QueryErrorContext());\n+\tDUCKDB_API static optional_ptr<SchemaCatalogEntry> GetSchema(CatalogEntryRetriever &retriever,\n+\t                                                             const string &catalog_name, const string &schema_name,\n+\t                                                             OnEntryNotFound if_not_found,\n+\t                                                             QueryErrorContext error_context = QueryErrorContext());\n \t//! Scans all the schemas in the system one-by-one, invoking the callback for each entry\n \tDUCKDB_API virtual void ScanSchemas(ClientContext &context, std::function<void(SchemaCatalogEntry &)> callback) = 0;\n \n@@ -221,6 +231,10 @@ class Catalog {\n \tDUCKDB_API optional_ptr<CatalogEntry> GetEntry(ClientContext &context, CatalogType type, const string &schema,\n \t                                               const string &name, OnEntryNotFound if_not_found,\n \t                                               QueryErrorContext error_context = QueryErrorContext());\n+\tDUCKDB_API optional_ptr<CatalogEntry> GetEntry(CatalogEntryRetriever &retriever, CatalogType type,\n+\t                                               const string &schema, const string &name,\n+\t                                               OnEntryNotFound if_not_found,\n+\t                                               QueryErrorContext error_context = QueryErrorContext());\n \tDUCKDB_API CatalogEntry &GetEntry(ClientContext &context, CatalogType type, const string &schema,\n \t                                  const string &name, QueryErrorContext error_context = QueryErrorContext());\n \t//! Gets the \"catalog.schema.name\" entry of the specified type, if entry does not exist behavior depends on\n@@ -229,6 +243,10 @@ class Catalog {\n \t                                                      const string &catalog, const string &schema,\n \t                                                      const string &name, OnEntryNotFound if_not_found,\n \t                                                      QueryErrorContext error_context = QueryErrorContext());\n+\tDUCKDB_API static optional_ptr<CatalogEntry> GetEntry(CatalogEntryRetriever &retriever, CatalogType type,\n+\t                                                      const string &catalog, const string &schema,\n+\t                                                      const string &name, OnEntryNotFound if_not_found,\n+\t                                                      QueryErrorContext error_context = QueryErrorContext());\n \tDUCKDB_API static CatalogEntry &GetEntry(ClientContext &context, CatalogType type, const string &catalog,\n \t                                         const string &schema, const string &name,\n \t                                         QueryErrorContext error_context = QueryErrorContext());\n@@ -306,6 +324,8 @@ class Catalog {\n \tDUCKDB_API vector<reference<SchemaCatalogEntry>> GetSchemas(ClientContext &context);\n \tDUCKDB_API static vector<reference<SchemaCatalogEntry>> GetSchemas(ClientContext &context,\n \t                                                                   const string &catalog_name);\n+\tDUCKDB_API static vector<reference<SchemaCatalogEntry>> GetSchemas(CatalogEntryRetriever &retriever,\n+\t                                                                   const string &catalog_name);\n \tDUCKDB_API static vector<reference<SchemaCatalogEntry>> GetAllSchemas(ClientContext &context);\n \n \tvirtual void Verify();\n@@ -329,21 +349,22 @@ class Catalog {\n \t                                          const string &name);\n \t//! Calls LookupEntryInternal on the schema, trying other schemas if the schema is invalid. Sets\n \t//! CatalogEntryLookup->error depending on if_not_found when no entry is found\n-\tCatalogEntryLookup TryLookupEntry(ClientContext &context, CatalogType type, const string &schema,\n+\tCatalogEntryLookup TryLookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &schema,\n \t                                  const string &name, OnEntryNotFound if_not_found,\n \t                                  QueryErrorContext error_context = QueryErrorContext());\n \t//! Lookup an entry using TryLookupEntry, throws if entry not found and if_not_found == THROW_EXCEPTION\n-\tCatalogEntryLookup LookupEntry(ClientContext &context, CatalogType type, const string &schema, const string &name,\n-\t                               OnEntryNotFound if_not_found, QueryErrorContext error_context = QueryErrorContext());\n-\tstatic CatalogEntryLookup TryLookupEntry(ClientContext &context, vector<CatalogLookup> &lookups, CatalogType type,\n-\t                                         const string &name, OnEntryNotFound if_not_found,\n+\tCatalogEntryLookup LookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &schema,\n+\t                               const string &name, OnEntryNotFound if_not_found,\n+\t                               QueryErrorContext error_context = QueryErrorContext());\n+\tstatic CatalogEntryLookup TryLookupEntry(CatalogEntryRetriever &retriever, vector<CatalogLookup> &lookups,\n+\t                                         CatalogType type, const string &name, OnEntryNotFound if_not_found,\n \t                                         QueryErrorContext error_context = QueryErrorContext());\n-\tstatic CatalogEntryLookup TryLookupEntry(ClientContext &context, CatalogType type, const string &catalog,\n+\tstatic CatalogEntryLookup TryLookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &catalog,\n \t                                         const string &schema, const string &name, OnEntryNotFound if_not_found,\n \t                                         QueryErrorContext error_context);\n \n \t//! Return an exception with did-you-mean suggestion.\n-\tstatic CatalogException CreateMissingEntryException(ClientContext &context, const string &entry_name,\n+\tstatic CatalogException CreateMissingEntryException(CatalogEntryRetriever &retriever, const string &entry_name,\n \t                                                    CatalogType type,\n \t                                                    const reference_set_t<SchemaCatalogEntry> &schemas,\n \t                                                    QueryErrorContext error_context);\ndiff --git a/src/include/duckdb/catalog/catalog_entry_retriever.hpp b/src/include/duckdb/catalog/catalog_entry_retriever.hpp\nindex 28b3874c4d7e..f51b63002350 100644\n--- a/src/include/duckdb/catalog/catalog_entry_retriever.hpp\n+++ b/src/include/duckdb/catalog/catalog_entry_retriever.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/catalog/catalog_entry_retriever.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include <functional>\n@@ -6,6 +14,7 @@\n #include \"duckdb/common/string.hpp\"\n #include \"duckdb/parser/query_error_context.hpp\"\n #include \"duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\"\n+#include \"duckdb/catalog/catalog_search_path.hpp\"\n \n namespace duckdb {\n \n@@ -24,6 +33,11 @@ class CatalogEntryRetriever {\n \t}\n \n public:\n+\tvoid Inherit(const CatalogEntryRetriever &parent);\n+\tClientContext &GetContext() {\n+\t\treturn context;\n+\t}\n+\n \toptional_ptr<CatalogEntry> GetEntry(CatalogType type, const string &catalog, const string &schema,\n \t                                    const string &name,\n \t                                    OnEntryNotFound on_entry_not_found = OnEntryNotFound::THROW_EXCEPTION,\n@@ -42,31 +56,20 @@ class CatalogEntryRetriever {\n \t                                           OnEntryNotFound on_entry_not_found = OnEntryNotFound::THROW_EXCEPTION,\n \t                                           QueryErrorContext error_context = QueryErrorContext());\n \n-\tvoid SetCallback(catalog_entry_callback_t callback) {\n-\t\tthis->callback = std::move(callback);\n-\t}\n-\tcatalog_entry_callback_t GetCallback() {\n-\t\treturn callback;\n-\t}\n+\tCatalogSearchPath &GetSearchPath();\n+\tvoid SetSearchPath(vector<CatalogSearchEntry> entries);\n+\n+\tvoid SetCallback(catalog_entry_callback_t callback);\n+\tcatalog_entry_callback_t GetCallback();\n \n private:\n-\tusing catalog_entry_retrieve_func_t = std::function<optional_ptr<CatalogEntry>()>;\n-\toptional_ptr<CatalogEntry> GetEntryInternal(const catalog_entry_retrieve_func_t &retriever) {\n-\t\tauto result = retriever();\n-\t\tif (!result) {\n-\t\t\treturn result;\n-\t\t}\n-\t\tif (callback) {\n-\t\t\t// Call the callback if it's set\n-\t\t\tcallback(*result);\n-\t\t}\n-\t\treturn result;\n-\t}\n+\toptional_ptr<CatalogEntry> ReturnAndCallback(optional_ptr<CatalogEntry> result);\n \n private:\n \t//! (optional) callback, called on every succesful entry retrieval\n \tcatalog_entry_callback_t callback = nullptr;\n \tClientContext &context;\n+\tshared_ptr<CatalogSearchPath> search_path;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/catalog/catalog_search_path.hpp b/src/include/duckdb/catalog/catalog_search_path.hpp\nindex 479d6c5298cf..ff0def0fcd30 100644\n--- a/src/include/duckdb/catalog/catalog_search_path.hpp\n+++ b/src/include/duckdb/catalog/catalog_search_path.hpp\n@@ -41,6 +41,7 @@ enum class CatalogSetPathType { SET_SCHEMA, SET_SCHEMAS };\n class CatalogSearchPath {\n public:\n \tDUCKDB_API explicit CatalogSearchPath(ClientContext &client_p);\n+\tDUCKDB_API CatalogSearchPath(ClientContext &client_p, vector<CatalogSearchEntry> entries);\n \tCatalogSearchPath(const CatalogSearchPath &other) = delete;\n \n \tDUCKDB_API void Set(CatalogSearchEntry new_value, CatalogSetPathType set_type);\n@@ -61,8 +62,8 @@ class CatalogSearchPath {\n \tDUCKDB_API bool SchemaInSearchPath(ClientContext &context, const string &catalog_name, const string &schema_name);\n \n private:\n-\tvoid SetPaths(vector<CatalogSearchEntry> new_paths);\n-\n+\t//! Set paths without checking if they exist\n+\tvoid SetPathsInternal(vector<CatalogSearchEntry> new_paths);\n \tstring GetSetName(CatalogSetPathType set_type);\n \n private:\ndiff --git a/src/include/duckdb/main/database_manager.hpp b/src/include/duckdb/main/database_manager.hpp\nindex c06b5505aa78..2ac5c4ae5512 100644\n--- a/src/include/duckdb/main/database_manager.hpp\n+++ b/src/include/duckdb/main/database_manager.hpp\n@@ -21,6 +21,7 @@\n namespace duckdb {\n class AttachedDatabase;\n class Catalog;\n+class CatalogEntryRetriever;\n class CatalogSet;\n class ClientContext;\n class DatabaseInstance;\ndiff --git a/src/include/duckdb/parser/parsed_data/comment_on_column_info.hpp b/src/include/duckdb/parser/parsed_data/comment_on_column_info.hpp\nindex c274ffb5559b..60aa36ef01e0 100644\n--- a/src/include/duckdb/parser/parsed_data/comment_on_column_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/comment_on_column_info.hpp\n@@ -12,9 +12,9 @@\n #include \"duckdb/common/types/value.hpp\"\n #include \"duckdb/parser/parsed_data/alter_info.hpp\"\n #include \"duckdb/parser/qualified_name.hpp\"\n-#include \"duckdb/catalog/catalog_entry_retriever.hpp\"\n \n namespace duckdb {\n+class CatalogEntryRetriever;\n class ClientContext;\n class CatalogEntry;\n \ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex fa490303dcee..465ce2e220c2 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -59,7 +59,7 @@ Binder::Binder(ClientContext &context, shared_ptr<Binder> parent_p, BinderType b\n     : context(context), bind_context(*this), parent(std::move(parent_p)), bound_tables(0), binder_type(binder_type),\n       entry_retriever(context) {\n \tif (parent) {\n-\t\tentry_retriever.SetCallback(parent->entry_retriever.GetCallback());\n+\t\tentry_retriever.Inherit(parent->entry_retriever);\n \n \t\t// We have to inherit macro and lambda parameter bindings and from the parent binder, if there is a parent.\n \t\tmacro_binding = parent->macro_binding;\ndiff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex 40f2662d4500..a7ebe4335749 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -15,6 +15,7 @@\n #include \"duckdb/planner/tableref/bound_cteref.hpp\"\n #include \"duckdb/planner/tableref/bound_dummytableref.hpp\"\n #include \"duckdb/planner/tableref/bound_subqueryref.hpp\"\n+#include \"duckdb/catalog/catalog_search_path.hpp\"\n \n namespace duckdb {\n \n@@ -259,6 +260,16 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \t\t\tview_names.push_back(view_catalog_entry.names[n]);\n \t\t}\n \t\tsubquery.column_name_alias = BindContext::AliasColumnNames(subquery.alias, view_names, ref.column_name_alias);\n+\n+\t\t// when binding a view, we always look into the catalog/schema where the view is stored first\n+\t\tvector<CatalogSearchEntry> view_search_path;\n+\t\tauto &catalog_name = view_catalog_entry.ParentCatalog().GetName();\n+\t\tauto &schema_name = view_catalog_entry.ParentSchema().name;\n+\t\tview_search_path.emplace_back(catalog_name, schema_name);\n+\t\tif (schema_name != DEFAULT_SCHEMA) {\n+\t\t\tview_search_path.emplace_back(view_catalog_entry.ParentCatalog().GetName(), DEFAULT_SCHEMA);\n+\t\t}\n+\t\tview_binder->entry_retriever.SetSearchPath(std::move(view_search_path));\n \t\t// bind the child subquery\n \t\tview_binder->AddBoundView(view_catalog_entry);\n \t\tauto bound_child = view_binder->Bind(subquery);\n",
  "test_patch": "diff --git a/test/sql/attach/attach_view_search_path.test b/test/sql/attach/attach_view_search_path.test\nnew file mode 100644\nindex 000000000000..01a1f6eeddd8\n--- /dev/null\n+++ b/test/sql/attach/attach_view_search_path.test\n@@ -0,0 +1,78 @@\n+# name: test/sql/attach/attach_view_search_path.test\n+# description: Test ATTACH with search path\n+# group: [attach]\n+\n+# avoid loading a storage database because it changes the initial database name\n+require noforcestorage\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+ATTACH DATABASE '__TEST_DIR__/view_search_path.db' AS view_search_path;\n+\n+statement ok\n+USE view_search_path\n+\n+statement ok\n+CREATE TABLE my_tbl(i INTEGER)\n+\n+statement ok\n+INSERT INTO my_tbl VALUES (42)\n+\n+statement ok\n+CREATE VIEW my_view AS FROM my_tbl\n+\n+query I\n+FROM my_view\n+----\n+42\n+\n+statement ok\n+CREATE SCHEMA my_schema\n+\n+statement ok\n+USE my_schema\n+\n+statement ok\n+CREATE TABLE my_tbl(i INTEGER)\n+\n+statement ok\n+INSERT INTO my_tbl VALUES (84)\n+\n+statement ok\n+CREATE VIEW my_view AS FROM my_tbl\n+\n+query I\n+FROM my_view\n+----\n+84\n+\n+statement ok\n+USE memory\n+\n+query I\n+FROM view_search_path.my_view\n+----\n+42\n+\n+query I\n+FROM view_search_path.my_schema.my_view\n+----\n+84\n+\n+statement ok\n+DETACH view_search_path\n+\n+statement ok\n+ATTACH DATABASE '__TEST_DIR__/view_search_path.db' AS view_search_path;\n+\n+query I\n+FROM view_search_path.my_view\n+----\n+42\n+\n+query I\n+FROM view_search_path.my_schema.my_view\n+----\n+84\ndiff --git a/test/sql/attach/attach_views.test b/test/sql/attach/attach_views.test\nindex 6311e9e702fb..c64c0fbf6505 100644\n--- a/test/sql/attach/attach_views.test\n+++ b/test/sql/attach/attach_views.test\n@@ -2,7 +2,7 @@\n # description: Test views in an attached database\n # group: [attach]\n \n-require skip_reload\n+require noforcestorage\n \n statement ok\n PRAGMA enable_verification\n@@ -46,7 +46,7 @@ SELECT * FROM ${prefix}.v1\n \n # reference tables from different databases in view\n statement ok\n-CREATE OR REPLACE VIEW ${prefix}.v1 AS SELECT * FROM ${prefix}.t1 UNION ALL FROM t1 ORDER BY ALL\n+CREATE OR REPLACE VIEW ${prefix}.v1 AS SELECT * FROM ${prefix}.t1 UNION ALL FROM memory.t1 ORDER BY ALL\n \n query I\n SELECT * FROM ${prefix}.v1\n",
  "problem_statement": "Namespace resolution for VIEW does not work for views from ATTACH-ed database\n### What happens?\r\n\r\nPersistent `.duckdb` database exist, in which two views are defined:\r\n- `first_view` is defined as a select over a  `read_parquet(...)` function\r\n- `second_view` is defined as a view on top of `first_view`\r\n\r\nBoth these views can be queried when the `.duckdb` database is opened with the CLI tool.\r\n\r\nAfter using `ATTACH` from another database (eg :memory) attempts to query `second_view` fails with:\r\n```\r\nCatalogException\r\nThis cell raised an exception: CatalogException('Catalog Error: Table with name first_view does not exist! Did you mean \"demo.first_view\"?')\r\n``` \r\n\r\nDetails:\r\n```\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\jbi\\Repos\\marimo\\bugreport\\.venv\\Lib\\site-packages\\marimo\\_runtime\\executor.py\", line 170, in execute_cell\r\n    exec(cell.body, glbls)\r\n  Cell marimo://C:\\Users\\jbi\\Repos\\marimo\\bugreport\\notebooks\\Myname.py#cell=cell-3, line 1, in <module>\r\n    _df = mo.sql(\r\n          ^^^^^^^\r\n  File \"C:\\Users\\jbi\\Repos\\marimo\\bugreport\\.venv\\Lib\\site-packages\\marimo\\_sql\\sql.py\", line 40, in sql\r\n    relation = duckdb.sql(query=query)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\Users\\jbi\\Repos\\marimo\\bugreport\\.venv\\Lib\\site-packages\\duckdb\\__init__.py\", line 457, in sql\r\n    return conn.sql(query, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\nduckdb.duckdb.CatalogException: Catalog Error: Table with name first_view does not exist!\r\nDid you mean \"demo.first_view\"?\r\n``` \r\n\r\n\r\n### To Reproduce\r\n\r\n\r\nDuckDB CLI is first used to create a .parquet file. Start CLI in memory mode:\r\n```shell\r\nduckdb\r\n``` \r\n\r\nExecute statements:\r\n```\r\nCREATE TABLE mytable (id INTEGER PRIMARY KEY, j VARCHAR);\r\nINSERT INTO mytable VALUES (1, 'a');\r\nINSERT INTO mytable VALUES (b, '2');\r\n\r\nCOPY\r\n  (SELECT * FROM mytable)\r\n  TO 'demo.parquet'\r\n  (FORMAT 'parquet');\r\n``` \r\n\r\nExit CLI tool. \r\n\r\nNext step is to create the persistent .duckdb database. Open/create DB:\r\n```shell\r\nduckdb demo.duckdb\r\n``` \r\n\r\nExecute statements to create view. Note that full-path to demo.parquet file is required. \r\n```\r\nCREATE VIEW first_view AS SELECT id, j FROM read_parquet('C:\\Temp\\demo.parquet');\r\nCREATE VIEW second_view AS SELECT * FROM first_view;\r\n``` \r\n\r\nEdit by @szarnyasg \u2013 Bash one-liner:\r\n\r\n```bash\r\nduckdb demo.duckdb -c \"CREATE VIEW first_view AS SELECT id, j FROM read_parquet('`pwd`/demo.parquet'); CREATE VIEW second_view AS SELECT * FROM first_view;\"\r\n```\r\n\r\nThese views can both be queried as one would expect. \r\n\r\nExit CLI tool, and open new a transient duck-db database:\r\n```shell\r\nduckdb\r\n```\r\n\r\nAttach the .duckdb database\r\n```\r\nATTACH 'demo.duckdb';\r\n```\r\n\r\nQuery of `first_view` works:\r\n```\r\nSELECT * FROM demo.main.first_view;\r\n```\r\n\r\nQuery of `second_view` **fails**:\r\n```\r\nSELECT * FROM demo.main.second_view;\r\n``` \r\n\r\nChanging the namespace makes the second query work:\r\n```\r\nUSE demo.main;\r\n```\r\n\r\n\r\n\r\n### OS:\r\n\r\nWindows 11 x64\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0\r\n\r\n### DuckDB Client:\r\n\r\nduckdb cli\r\n\r\n### Full Name:\r\n\r\nJannick Bitsch\r\n\r\n### Affiliation:\r\n\r\nDanske Commodities A/S\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\nNamespace resolution for VIEW does not work for views from ATTACH-ed database\n### What happens?\r\n\r\nPersistent `.duckdb` database exist, in which two views are defined:\r\n- `first_view` is defined as a select over a  `read_parquet(...)` function\r\n- `second_view` is defined as a view on top of `first_view`\r\n\r\nBoth these views can be queried when the `.duckdb` database is opened with the CLI tool.\r\n\r\nAfter using `ATTACH` from another database (eg :memory) attempts to query `second_view` fails with:\r\n```\r\nCatalogException\r\nThis cell raised an exception: CatalogException('Catalog Error: Table with name first_view does not exist! Did you mean \"demo.first_view\"?')\r\n``` \r\n\r\nDetails:\r\n```\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\jbi\\Repos\\marimo\\bugreport\\.venv\\Lib\\site-packages\\marimo\\_runtime\\executor.py\", line 170, in execute_cell\r\n    exec(cell.body, glbls)\r\n  Cell marimo://C:\\Users\\jbi\\Repos\\marimo\\bugreport\\notebooks\\Myname.py#cell=cell-3, line 1, in <module>\r\n    _df = mo.sql(\r\n          ^^^^^^^\r\n  File \"C:\\Users\\jbi\\Repos\\marimo\\bugreport\\.venv\\Lib\\site-packages\\marimo\\_sql\\sql.py\", line 40, in sql\r\n    relation = duckdb.sql(query=query)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"C:\\Users\\jbi\\Repos\\marimo\\bugreport\\.venv\\Lib\\site-packages\\duckdb\\__init__.py\", line 457, in sql\r\n    return conn.sql(query, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\nduckdb.duckdb.CatalogException: Catalog Error: Table with name first_view does not exist!\r\nDid you mean \"demo.first_view\"?\r\n``` \r\n\r\n\r\n### To Reproduce\r\n\r\n\r\nDuckDB CLI is first used to create a .parquet file. Start CLI in memory mode:\r\n```shell\r\nduckdb\r\n``` \r\n\r\nExecute statements:\r\n```\r\nCREATE TABLE mytable (id INTEGER PRIMARY KEY, j VARCHAR);\r\nINSERT INTO mytable VALUES (1, 'a');\r\nINSERT INTO mytable VALUES (b, '2');\r\n\r\nCOPY\r\n  (SELECT * FROM mytable)\r\n  TO 'demo.parquet'\r\n  (FORMAT 'parquet');\r\n``` \r\n\r\nExit CLI tool. \r\n\r\nNext step is to create the persistent .duckdb database. Open/create DB:\r\n```shell\r\nduckdb demo.duckdb\r\n``` \r\n\r\nExecute statements to create view. Note that full-path to demo.parquet file is required. \r\n```\r\nCREATE VIEW first_view AS SELECT id, j FROM read_parquet('C:\\Temp\\demo.parquet');\r\nCREATE VIEW second_view AS SELECT * FROM first_view;\r\n``` \r\n\r\nEdit by @szarnyasg \u2013 Bash one-liner:\r\n\r\n```bash\r\nduckdb demo.duckdb -c \"CREATE VIEW first_view AS SELECT id, j FROM read_parquet('`pwd`/demo.parquet'); CREATE VIEW second_view AS SELECT * FROM first_view;\"\r\n```\r\n\r\nThese views can both be queried as one would expect. \r\n\r\nExit CLI tool, and open new a transient duck-db database:\r\n```shell\r\nduckdb\r\n```\r\n\r\nAttach the .duckdb database\r\n```\r\nATTACH 'demo.duckdb';\r\n```\r\n\r\nQuery of `first_view` works:\r\n```\r\nSELECT * FROM demo.main.first_view;\r\n```\r\n\r\nQuery of `second_view` **fails**:\r\n```\r\nSELECT * FROM demo.main.second_view;\r\n``` \r\n\r\nChanging the namespace makes the second query work:\r\n```\r\nUSE demo.main;\r\n```\r\n\r\n\r\n\r\n### OS:\r\n\r\nWindows 11 x64\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0\r\n\r\n### DuckDB Client:\r\n\r\nduckdb cli\r\n\r\n### Full Name:\r\n\r\nJannick Bitsch\r\n\r\n### Affiliation:\r\n\r\nDanske Commodities A/S\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "@jbit84 thanks, I could reproduce the issue!\n@jbit84 thanks, I could reproduce the issue!",
  "created_at": "2024-09-13T10:59:46Z"
}