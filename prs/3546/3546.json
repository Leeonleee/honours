{
  "repo": "duckdb/duckdb",
  "pull_number": 3546,
  "instance_id": "duckdb__duckdb-3546",
  "issue_numbers": [
    "2910"
  ],
  "base_commit": "fe433d3178a786d68b37ca91405983f4b2300d1a",
  "patch": "diff --git a/tools/pythonpkg/src/include/duckdb_python/vector_conversion.hpp b/tools/pythonpkg/src/include/duckdb_python/vector_conversion.hpp\nindex 9ceb1da82510..6bacfa737fc9 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/vector_conversion.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/vector_conversion.hpp\n@@ -15,6 +15,7 @@\n namespace duckdb {\n \n enum class PandasType : uint8_t {\n+\tBOOL,\n \tBOOLEAN,\n \tTINYINT,\n \tSMALLINT,\ndiff --git a/tools/pythonpkg/src/vector_conversion.cpp b/tools/pythonpkg/src/vector_conversion.cpp\nindex b68041434244..ea1058660a20 100644\n--- a/tools/pythonpkg/src/vector_conversion.cpp\n+++ b/tools/pythonpkg/src/vector_conversion.cpp\n@@ -47,7 +47,7 @@ void ScanPandasCategory(py::array &column, idx_t count, idx_t offset, Vector &ou\n }\n \n template <class T>\n-void ScanPandasNumeric(PandasColumnBindData &bind_data, idx_t count, idx_t offset, Vector &out) {\n+void ScanPandasMasked(PandasColumnBindData &bind_data, idx_t count, idx_t offset, Vector &out) {\n \tScanPandasColumn<T>(bind_data.numpy_col, bind_data.numpy_stride, offset, out, count);\n \tauto &result_mask = FlatVector::Validity(out);\n \tif (bind_data.mask) {\n@@ -113,31 +113,34 @@ void VectorConversion::NumpyToDuckDB(PandasColumnBindData &bind_data, py::array\n                                      Vector &out) {\n \tswitch (bind_data.pandas_type) {\n \tcase PandasType::BOOLEAN:\n+\t\tScanPandasMasked<bool>(bind_data, count, offset, out);\n+\t\tbreak;\n+\tcase PandasType::BOOL:\n \t\tScanPandasColumn<bool>(numpy_col, bind_data.numpy_stride, offset, out, count);\n \t\tbreak;\n \tcase PandasType::UTINYINT:\n-\t\tScanPandasNumeric<uint8_t>(bind_data, count, offset, out);\n+\t\tScanPandasMasked<uint8_t>(bind_data, count, offset, out);\n \t\tbreak;\n \tcase PandasType::USMALLINT:\n-\t\tScanPandasNumeric<uint16_t>(bind_data, count, offset, out);\n+\t\tScanPandasMasked<uint16_t>(bind_data, count, offset, out);\n \t\tbreak;\n \tcase PandasType::UINTEGER:\n-\t\tScanPandasNumeric<uint32_t>(bind_data, count, offset, out);\n+\t\tScanPandasMasked<uint32_t>(bind_data, count, offset, out);\n \t\tbreak;\n \tcase PandasType::UBIGINT:\n-\t\tScanPandasNumeric<uint64_t>(bind_data, count, offset, out);\n+\t\tScanPandasMasked<uint64_t>(bind_data, count, offset, out);\n \t\tbreak;\n \tcase PandasType::TINYINT:\n-\t\tScanPandasNumeric<int8_t>(bind_data, count, offset, out);\n+\t\tScanPandasMasked<int8_t>(bind_data, count, offset, out);\n \t\tbreak;\n \tcase PandasType::SMALLINT:\n-\t\tScanPandasNumeric<int16_t>(bind_data, count, offset, out);\n+\t\tScanPandasMasked<int16_t>(bind_data, count, offset, out);\n \t\tbreak;\n \tcase PandasType::INTEGER:\n-\t\tScanPandasNumeric<int32_t>(bind_data, count, offset, out);\n+\t\tScanPandasMasked<int32_t>(bind_data, count, offset, out);\n \t\tbreak;\n \tcase PandasType::BIGINT:\n-\t\tScanPandasNumeric<int64_t>(bind_data, count, offset, out);\n+\t\tScanPandasMasked<int64_t>(bind_data, count, offset, out);\n \t\tbreak;\n \tcase PandasType::FLOAT:\n \t\tScanPandasFpColumn<float>((float *)numpy_col.data(), count, offset, out);\n@@ -287,6 +290,9 @@ void VectorConversion::NumpyToDuckDB(PandasColumnBindData &bind_data, py::array\n \n static void ConvertPandasType(const string &col_type, LogicalType &duckdb_col_type, PandasType &pandas_type) {\n \tif (col_type == \"bool\") {\n+\t\tduckdb_col_type = LogicalType::BOOLEAN;\n+\t\tpandas_type = PandasType::BOOL;\n+\t} else if (col_type == \"boolean\") {\n \t\tduckdb_col_type = LogicalType::BOOLEAN;\n \t\tpandas_type = PandasType::BOOLEAN;\n \t} else if (col_type == \"uint8\" || col_type == \"Uint8\") {\n@@ -370,8 +376,9 @@ void VectorConversion::BindPandas(py::handle original_df, vector<PandasColumnBin\n \t\tLogicalType duckdb_col_type;\n \t\tPandasColumnBindData bind_data;\n \t\tauto col_type = string(py::str(df_types[col_idx]));\n-\t\tif (col_type == \"Int8\" || col_type == \"Int16\" || col_type == \"Int32\" || col_type == \"Int64\") {\n-\t\t\t// numeric object\n+\t\tif (col_type == \"Int8\" || col_type == \"Int16\" || col_type == \"Int32\" || col_type == \"Int64\" ||\n+\t\t    col_type == \"boolean\") {\n+\t\t\t// masked object\n \t\t\t// fetch the internal data and mask array\n \t\t\tbind_data.numpy_col = get_fun(df_columns[col_idx]).attr(\"array\").attr(\"_data\");\n \t\t\tbind_data.mask = make_unique<NumPyArrayWrapper>(get_fun(df_columns[col_idx]).attr(\"array\").attr(\"_mask\"));\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py b/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py\nindex 899995b261c7..2b3c11a9da9b 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_pandas_types.py\n@@ -22,7 +22,20 @@ def test_pandas_unsigned(self, duckdb_cursor):\n     def test_pandas_bool(self, duckdb_cursor):\n         data = numpy.array([True,False,False,True])\n         round_trip(data,'bool')\n-        \n+    \n+    def test_pandas_boolean(self, duckdb_cursor):\n+        data = numpy.array([True,None,pd.NA,numpy.nan,True])\n+        df_in = pd.DataFrame({\n+            'object': pd.Series(data, dtype='boolean'),\n+        })\n+\n+        df_out = duckdb.query_df(df_in, \"data\", \"SELECT * FROM data\").df()\n+        assert df_out['object'][0] == df_in['object'][0]\n+        assert numpy.isnan(df_out['object'][1])\n+        assert numpy.isnan(df_out['object'][2])\n+        assert numpy.isnan(df_out['object'][3])\n+        assert df_out['object'][4] == df_in['object'][4]\n+\n     def test_pandas_float32(self, duckdb_cursor):\n         data = numpy.array([0.1,0.32,0.78, numpy.nan])\n         df_in = pd.DataFrame({\n",
  "problem_statement": "Support pandas nullable boolean type\n#### What happens?\r\nPandas dataframes containing any columns of the (experimental) [nullable boolean type ](https://pandas.pydata.org/pandas-docs/stable/user_guide/boolean.html) will fail to register with duckdb.\r\n\r\n#### To Reproduce\r\n\r\n```\r\nIn [3]: df1 = pandas.DataFrame({\"foo\": [True, None, False]})\r\n   ...: df2 = pandas.DataFrame({\"foo\": [True, None, False]}, dtype=\"boolean\")\r\n\r\nIn [4]: df1.dtypes\r\nOut[4]:\r\nfoo    object\r\ndtype: object\r\n\r\nIn [5]: df2.dtypes\r\nOut[5]:\r\nfoo    boolean\r\ndtype: object\r\n\r\nIn [6]: con = duckdb.connect(database=\":memory:\", read_only=False)\r\n\r\nIn [7]: con.register(\"df1\", df1)\r\nOut[7]: <duckdb.DuckDBPyConnection at 0x127c35530>\r\n\r\nIn [8]: con.register(\"df2\", df2)\r\n---------------------------------------------------------------------------\r\nRuntimeError                              Traceback (most recent call last)\r\n<ipython-input-8-e94dc73d8e5d> in <module>\r\n----> 1 con.register(\"df2\", df2)\r\n\r\nRuntimeError: unsupported python type boolean\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: [e.g. iOS]: Mac OS\r\n - DuckDB Version: [e.g. 22]: 0.3.1\r\n - DuckDB Client: [e.g. Python]: python\r\n\r\n\n",
  "hints_text": "My team could really use this support, any idea where we can start out helping to get it done?\nFor preferential support on issues you can contact [DuckDB Labs](https://duckdblabs.com). If you want to provide a code contribution instead you could have a look at the Python package source code, happy to review a PR as well!",
  "created_at": "2022-04-30T21:52:39Z"
}