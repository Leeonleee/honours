diff --git a/extension/parquet/include/struct_column_reader.hpp b/extension/parquet/include/struct_column_reader.hpp
index 58f3bdb6854e..a6ad89d92a01 100644
--- a/extension/parquet/include/struct_column_reader.hpp
+++ b/extension/parquet/include/struct_column_reader.hpp
@@ -37,15 +37,19 @@ class StructColumnReader : public ColumnReader {
 	           Vector &result) override {
 		auto &struct_entries = StructVector::GetEntries(result);
 		D_ASSERT(StructType::GetChildTypes(Type()).size() == struct_entries.size());
+
+		idx_t read_count = num_values;
 		for (idx_t i = 0; i < struct_entries.size(); i++) {
 			auto child_num_values =
 			    child_readers[i]->Read(num_values, filter, define_out, repeat_out, *struct_entries[i]);
-			if (child_num_values != num_values) {
+			if (i == 0) {
+				read_count = child_num_values;
+			} else if (read_count != child_num_values) {
 				throw std::runtime_error("Struct child row count mismatch");
 			}
 		}
 
-		return num_values;
+		return read_count;
 	}
 
 	virtual void Skip(idx_t num_values) override {
@@ -53,6 +57,11 @@ class StructColumnReader : public ColumnReader {
 	}
 
 	idx_t GroupRowsAvailable() override {
+		for (idx_t i = 0; i < child_readers.size(); i++) {
+			if (child_readers[i]->Type().id() != LogicalTypeId::LIST) {
+				return child_readers[i]->GroupRowsAvailable();
+			}
+		}
 		return child_readers[0]->GroupRowsAvailable();
 	}
 
