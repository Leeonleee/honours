You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
"Struct child row count mismatch" on parquet read
```
>>> duckdb.query("select * from 'test.parquet'").fetchone()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
RuntimeError: Struct child row count mismatch
```

Expect duckdb to be able to read from the parquet file.

Minimal offending parquet file attached.

 - OS: MacOS 11.5
 - DuckDB Version: 0.2.9 and 0.2.10.dev247
[test.parquet.zip](https://github.com/duckdb/duckdb/files/7148879/test.parquet.zip)


</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![codecov](https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN)](https://codecov.io/gh/duckdb/duckdb)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of extension/parquet/include/struct_column_reader.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // struct_column_reader.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "column_reader.hpp"
12: #include "templated_column_reader.hpp"
13: 
14: namespace duckdb {
15: 
16: class StructColumnReader : public ColumnReader {
17: public:
18: 	StructColumnReader(ParquetReader &reader, LogicalType type_p, const SchemaElement &schema_p, idx_t schema_idx_p,
19: 	                   idx_t max_define_p, idx_t max_repeat_p, vector<unique_ptr<ColumnReader>> child_readers_p)
20: 	    : ColumnReader(reader, move(type_p), schema_p, schema_idx_p, max_define_p, max_repeat_p),
21: 	      child_readers(move(child_readers_p)) {
22: 		D_ASSERT(type.id() == LogicalTypeId::STRUCT);
23: 		D_ASSERT(!StructType::GetChildTypes(type).empty());
24: 	};
25: 
26: 	ColumnReader *GetChildReader(idx_t child_idx) {
27: 		return child_readers[child_idx].get();
28: 	}
29: 
30: 	void InitializeRead(const std::vector<ColumnChunk> &columns, TProtocol &protocol_p) override {
31: 		for (auto &child : child_readers) {
32: 			child->InitializeRead(columns, protocol_p);
33: 		}
34: 	}
35: 
36: 	idx_t Read(uint64_t num_values, parquet_filter_t &filter, uint8_t *define_out, uint8_t *repeat_out,
37: 	           Vector &result) override {
38: 		auto &struct_entries = StructVector::GetEntries(result);
39: 		D_ASSERT(StructType::GetChildTypes(Type()).size() == struct_entries.size());
40: 		for (idx_t i = 0; i < struct_entries.size(); i++) {
41: 			auto child_num_values =
42: 			    child_readers[i]->Read(num_values, filter, define_out, repeat_out, *struct_entries[i]);
43: 			if (child_num_values != num_values) {
44: 				throw std::runtime_error("Struct child row count mismatch");
45: 			}
46: 		}
47: 
48: 		return num_values;
49: 	}
50: 
51: 	virtual void Skip(idx_t num_values) override {
52: 		D_ASSERT(0);
53: 	}
54: 
55: 	idx_t GroupRowsAvailable() override {
56: 		return child_readers[0]->GroupRowsAvailable();
57: 	}
58: 
59: 	vector<unique_ptr<ColumnReader>> child_readers;
60: };
61: 
62: } // namespace duckdb
[end of extension/parquet/include/struct_column_reader.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: