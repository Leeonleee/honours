diff --git a/scripts/runsqlsmith.py b/scripts/runsqlsmith.py
index ef6d48bf0555..9e80625a0f66 100644
--- a/scripts/runsqlsmith.py
+++ b/scripts/runsqlsmith.py
@@ -3,17 +3,43 @@
 import os
 import re
 import subprocess
+import sys
+import sqlite3
+
+sqlsmith_db = 'sqlsmith.db'
+sqlsmith_test_dir = 'test/sqlsmith/queries'
+
+export_queries = False
+
+con = sqlite3.connect(sqlsmith_db)
+c = con.cursor()
+
+if len(sys.argv) == 2:
+	if sys.argv[1] == '--export':
+		export_queries = True
+	elif sys.argv[1] == '--reset':
+		c.execute('DROP TABLE IF EXISTS sqlsmith_errors')
+	else:
+		print('Unknown query option ' + sys.argv[1])
+		exit(1)
+
+if export_queries:
+	c.execute('SELECT query FROM sqlsmith_errors')
+	results = c.fetchall()
+	for fname in os.listdir(sqlsmith_test_dir):
+		os.remove(os.path.join(sqlsmith_test_dir, fname))
+
+	for i in range(len(results)):
+		with open(os.path.join(sqlsmith_test_dir, 'sqlsmith-%d.sql' % (i + 1)), 'w+') as f:
+			f.write(results[i][0] + "
")
+	exit(0)
 
 def run_sqlsmith():
 	subprocess.call(['build/debug/third_party/sqlsmith/sqlsmith', '--duckdb=:memory:'])
 
-def get_file(i):
-	return 'sqlsmith-queries/sqlsmith-%s.sql' % str(i)
 
-i = 1
-os.system('mkdir -p sqlsmith-queries')
-while os.path.isfile(get_file(i)):
-	i += 1
+c.execute('CREATE TABLE IF NOT EXISTS sqlsmith_errors(query VARCHAR)')
+
 while True:
 	# run SQL smith
 	run_sqlsmith()
@@ -21,8 +47,6 @@ def get_file(i):
 	with open('sqlsmith.log', 'r') as f:
 		text = re.sub('[ \t
]+', ' ', f.read())
 
-	with open(get_file(i), 'w+') as f:
-		f.write(text)
-		f.write('
')
-	i += 1
+	c.execute('INSERT INTO sqlsmith_errors VALUES (?)', (text,))
+	con.commit()
 
diff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp
index 9e05c9b8b9e6..cd0ffb998ffb 100644
--- a/src/common/types/vector.cpp
+++ b/src/common/types/vector.cpp
@@ -237,15 +237,25 @@ void Vector::SetValue(idx_t index, Value val) {
 }
 
 Value Vector::GetValue(idx_t index) const {
-	if (vector_type == VectorType::CONSTANT_VECTOR) {
+	switch(vector_type) {
+	case VectorType::CONSTANT_VECTOR:
 		index = 0;
-	} else if (vector_type == VectorType::DICTIONARY_VECTOR) {
+		break;
+	case VectorType::FLAT_VECTOR:
+		break;
 		// dictionary: apply dictionary and forward to child
+	case VectorType::DICTIONARY_VECTOR: {
 		auto &sel_vector = DictionaryVector::SelVector(*this);
 		auto &child = DictionaryVector::Child(*this);
 		return child.GetValue(sel_vector.get_index(index));
-	} else {
-		assert(vector_type == VectorType::FLAT_VECTOR);
+	}
+	case VectorType::SEQUENCE_VECTOR: {
+		int64_t start, increment;
+		SequenceVector::GetSequence(*this, start, increment);
+		return Value::Numeric(type, start + increment * index);
+	}
+	default:
+		throw NotImplementedException("Unimplemented vector type for Vector::GetValue");
 	}
 
 	if (nullmask[index]) {
@@ -626,6 +636,7 @@ void Vector::Verify(const SelectionVector &sel, idx_t count) {
 	}
 	if (vector_type == VectorType::DICTIONARY_VECTOR) {
 		auto &child = DictionaryVector::Child(*this);
+		assert(child.vector_type != VectorType::DICTIONARY_VECTOR);
 		auto &dict_sel = DictionaryVector::SelVector(*this);
 		for (idx_t i = 0; i < count; i++) {
 			auto oidx = sel.get_index(i);
@@ -638,6 +649,9 @@ void Vector::Verify(const SelectionVector &sel, idx_t count) {
 		child.Verify(new_sel, count);
 		return;
 	}
+	if (TypeIsConstantSize(type) && (vector_type == VectorType::CONSTANT_VECTOR || vector_type == VectorType::FLAT_VECTOR)) {
+		assert(!auxiliary);
+	}
 	if (type == TypeId::DOUBLE) {
 		// verify that there are no INF or NAN values
 		switch (vector_type) {
diff --git a/src/planner/binder/tableref/plan_joinref.cpp b/src/planner/binder/tableref/plan_joinref.cpp
index 2efd47145c76..d6f36d64c8ba 100644
--- a/src/planner/binder/tableref/plan_joinref.cpp
+++ b/src/planner/binder/tableref/plan_joinref.cpp
@@ -51,28 +51,30 @@ unique_ptr<LogicalOperator> LogicalComparisonJoin::CreateJoin(JoinType type, uni
 	// first check if we can create
 	for (idx_t i = 0; i < expressions.size(); i++) {
 		auto &expr = expressions[i];
-		auto total_side = JoinSide::GetJoinSide(*expr, left_bindings, right_bindings);
-		if (total_side != JoinSide::BOTH) {
-			// join condition does not reference both sides, add it as filter under the join
-			if (type == JoinType::LEFT && total_side == JoinSide::RIGHT) {
-				// filter is on RHS and the join is a LEFT OUTER join, we can push it in the right child
-				if (right_child->type != LogicalOperatorType::FILTER) {
-					// not a filter yet, push a new empty filter
-					auto filter = make_unique<LogicalFilter>();
-					filter->AddChild(move(right_child));
-					right_child = move(filter);
+		if (!expr->HasSubquery()) {
+			auto total_side = JoinSide::GetJoinSide(*expr, left_bindings, right_bindings);
+			if (total_side != JoinSide::BOTH) {
+				// join condition does not reference both sides, add it as filter under the join
+				if (type == JoinType::LEFT && total_side == JoinSide::RIGHT) {
+					// filter is on RHS and the join is a LEFT OUTER join, we can push it in the right child
+					if (right_child->type != LogicalOperatorType::FILTER) {
+						// not a filter yet, push a new empty filter
+						auto filter = make_unique<LogicalFilter>();
+						filter->AddChild(move(right_child));
+						right_child = move(filter);
+					}
+					// push the expression into the filter
+					auto &filter = (LogicalFilter &)*right_child;
+					filter.expressions.push_back(move(expr));
+					continue;
+				}
+			} else if (expr->type >= ExpressionType::COMPARE_EQUAL &&
+					expr->type <= ExpressionType::COMPARE_GREATERTHANOREQUALTO) {
+				// comparison, check if we can create a comparison JoinCondition
+				if (CreateJoinCondition(*expr, left_bindings, right_bindings, conditions)) {
+					// successfully created the join condition
+					continue;
 				}
-				// push the expression into the filter
-				auto &filter = (LogicalFilter &)*right_child;
-				filter.expressions.push_back(move(expr));
-				continue;
-			}
-		} else if (expr->type >= ExpressionType::COMPARE_EQUAL &&
-		           expr->type <= ExpressionType::COMPARE_GREATERTHANOREQUALTO) {
-			// comparison, check if we can create a comparison JoinCondition
-			if (CreateJoinCondition(*expr, left_bindings, right_bindings, conditions)) {
-				// successfully created the join condition
-				continue;
 			}
 		}
 		arbitrary_expressions.push_back(move(expr));
diff --git a/src/planner/logical_operator_visitor.cpp b/src/planner/logical_operator_visitor.cpp
index c49593582817..5799b0e7e122 100644
--- a/src/planner/logical_operator_visitor.cpp
+++ b/src/planner/logical_operator_visitor.cpp
@@ -52,6 +52,12 @@ void LogicalOperatorVisitor::VisitOperatorExpressions(LogicalOperator &op) {
 	}
 	case LogicalOperatorType::DELIM_JOIN:
 	case LogicalOperatorType::COMPARISON_JOIN: {
+		if (op.type == LogicalOperatorType::DELIM_JOIN) {
+			auto &delim_join = (LogicalDelimJoin &)op;
+			for(auto &expr : delim_join.duplicate_eliminated_columns) {
+				VisitExpression(&expr);
+			}
+		}
 		auto &join = (LogicalComparisonJoin &)op;
 		for (auto &cond : join.conditions) {
 			VisitExpression(&cond.left);
diff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp
index 27e0ccea6e01..699599f6b1cc 100644
--- a/src/storage/data_table.cpp
+++ b/src/storage/data_table.cpp
@@ -218,6 +218,7 @@ void DataTable::Scan(Transaction &transaction, DataChunk &result, TableScanState
 		if (result.size() > 0) {
 			return;
 		}
+		result.Reset();
 	}
 	// scan the transient segments
 	while (ScanBaseTable(transaction, result, state, state.current_transient_row, state.max_transient_row,
@@ -225,6 +226,7 @@ void DataTable::Scan(Transaction &transaction, DataChunk &result, TableScanState
 		if (result.size() > 0) {
 			return;
 		}
+		result.Reset();
 	}
 
 	// scan the transaction-local segments
diff --git a/third_party/sqlsmith/duckdb.cc b/third_party/sqlsmith/duckdb.cc
index 6f8312dae3b1..2fc0f80f9b35 100644
--- a/third_party/sqlsmith/duckdb.cc
+++ b/third_party/sqlsmith/duckdb.cc
@@ -73,18 +73,18 @@ schema_duckdb::schema_duckdb(std::string &conninfo, bool no_catalog) : duckdb_co
 		register_operator(o);                                                                                          \
 	} while (0)
 
-	// BINOP(||, TEXT);
+	BINOP(||, TEXT);
 	BINOP(*, INTEGER);
 	BINOP(/, INTEGER);
 
 	BINOP(+, INTEGER);
 	BINOP(-, INTEGER);
 
-	// BINOP(>>, INTEGER);
-	// BINOP(<<, INTEGER);
+	BINOP(>>, INTEGER);
+	BINOP(<<, INTEGER);
 
-	// BINOP(&, INTEGER);
-	// BINOP(|, INTEGER);
+	BINOP(&, INTEGER);
+	BINOP(|, INTEGER);
 
 	BINOP(<, INTEGER);
 	BINOP(<=, INTEGER);
@@ -137,12 +137,12 @@ schema_duckdb::schema_duckdb(std::string &conninfo, bool no_catalog) : duckdb_co
 
 	FUNC1(abs, INTEGER, REAL);
 	// FUNC1(hex, TEXT, TEXT);
-	// FUNC1(length, INTEGER, TEXT);
-	// FUNC1(lower, TEXT, TEXT);
+	FUNC1(length, INTEGER, TEXT);
+	FUNC1(lower, TEXT, TEXT);
 	// FUNC1(ltrim, TEXT, TEXT);
 	// FUNC1(quote, TEXT, TEXT);
 	// FUNC1(randomblob, TEXT, INTEGER);
-	// FUNC1(round, INTEGER, REAL);
+	FUNC1(round, INTEGER, REAL);
 	// FUNC1(rtrim, TEXT, TEXT);
 	// FUNC1(soundex, TEXT, TEXT);
 	// FUNC1(sqlite_compileoption_get, TEXT, INTEGER);
@@ -153,7 +153,7 @@ schema_duckdb::schema_duckdb(std::string &conninfo, bool no_catalog) : duckdb_co
 	// FUNC1(typeof, TEXT, REAL);
 	// FUNC1(typeof, TEXT, TEXT);
 	// FUNC1(unicode, INTEGER, TEXT);
-	// FUNC1(upper, TEXT, TEXT);
+	FUNC1(upper, TEXT, TEXT);
 	// FUNC1(zeroblob, TEXT, INTEGER);
 
 	// FUNC2(glob, INTEGER, TEXT, TEXT);
@@ -163,10 +163,10 @@ schema_duckdb::schema_duckdb(std::string &conninfo, bool no_catalog) : duckdb_co
 	// FUNC2(rtrim, TEXT, TEXT, TEXT);
 	// FUNC2(trim, TEXT, TEXT, TEXT);
 	// FUNC2(round, INTEGER, REAL, INTEGER);
-	// FUNC2(substr, TEXT, TEXT, INTEGER);
+	FUNC2(substr, TEXT, TEXT, INTEGER);
 
-	// FUNC3(substr, TEXT, TEXT, INTEGER, INTEGER);
-	// FUNC3(replace, TEXT, TEXT, TEXT, TEXT);
+	FUNC3(substr, TEXT, TEXT, INTEGER, INTEGER);
+	FUNC3(replace, TEXT, TEXT, TEXT, TEXT);
 
 #define AGG(n, r, a)                                                                                                   \
 	do {                                                                                                               \
@@ -180,7 +180,7 @@ schema_duckdb::schema_duckdb(std::string &conninfo, bool no_catalog) : duckdb_co
 	AGG(count, INTEGER, REAL);
 	AGG(count, INTEGER, TEXT);
 	AGG(count, INTEGER, INTEGER);
-	// AGG(group_concat, TEXT, TEXT);
+	AGG(string_agg, TEXT, TEXT);
 	AGG(max, REAL, REAL);
 	AGG(max, INTEGER, INTEGER);
 	AGG(min, REAL, REAL);
@@ -204,7 +204,7 @@ schema_duckdb::schema_duckdb(std::string &conninfo, bool no_catalog) : duckdb_co
 
 dut_duckdb::dut_duckdb(std::string &conninfo) : duckdb_connection(conninfo) {
 	cerr << "Generating TPC-H...";
-	tpch::dbgen(0.1, *database);
+	tpch::dbgen(0.01, *database);
 	cerr << "done." << endl;
 	// q("PRAGMA main.auto_vacuum = 2");
 }
