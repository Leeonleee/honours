{
  "repo": "duckdb/duckdb",
  "pull_number": 2444,
  "instance_id": "duckdb__duckdb-2444",
  "issue_numbers": [
    "2440",
    "2440"
  ],
  "base_commit": "442a4f3cef465dadc9b7c8944b02caa160f7ffc2",
  "patch": "diff --git a/tools/pythonpkg/src/pyrelation.cpp b/tools/pythonpkg/src/pyrelation.cpp\nindex 78248eab8b3f..c22fddab7052 100644\n--- a/tools/pythonpkg/src/pyrelation.cpp\n+++ b/tools/pythonpkg/src/pyrelation.cpp\n@@ -305,7 +305,7 @@ py::list DuckDBPyRelation::Columns() {\n \tfor (auto &col : rel->Columns()) {\n \t\tres.append(col.name);\n \t}\n-\treturn move(res);\n+\treturn res;\n }\n \n py::list DuckDBPyRelation::ColumnTypes() {\n@@ -313,7 +313,7 @@ py::list DuckDBPyRelation::ColumnTypes() {\n \tfor (auto &col : rel->Columns()) {\n \t\tres.append(col.type.ToString());\n \t}\n-\treturn move(res);\n+\treturn res;\n }\n \n } // namespace duckdb\ndiff --git a/tools/pythonpkg/src/pyresult.cpp b/tools/pythonpkg/src/pyresult.cpp\nindex f6fb0e80bb16..eb0b534e8ad0 100644\n--- a/tools/pythonpkg/src/pyresult.cpp\n+++ b/tools/pythonpkg/src/pyresult.cpp\n@@ -131,12 +131,28 @@ py::object GetValueToPython(Value &val, const LogicalType &type) {\n \t}\n }\n \n+unique_ptr<DataChunk> FetchNext(QueryResult &result) {\n+\tauto chunk = result.Fetch();\n+\tif (!result.success) {\n+\t\tthrow std::runtime_error(result.error);\n+\t}\n+\treturn chunk;\n+}\n+\n+unique_ptr<DataChunk> FetchNextRaw(QueryResult &result) {\n+\tauto chunk = result.FetchRaw();\n+\tif (!result.success) {\n+\t\tthrow std::runtime_error(result.error);\n+\t}\n+\treturn chunk;\n+}\n+\n py::object DuckDBPyResult::Fetchone() {\n \tif (!result) {\n \t\tthrow std::runtime_error(\"result closed\");\n \t}\n \tif (!current_chunk || chunk_offset >= current_chunk->size()) {\n-\t\tcurrent_chunk = result->Fetch();\n+\t\tcurrent_chunk = FetchNext(*result);\n \t\tchunk_offset = 0;\n \t}\n \tif (!current_chunk || current_chunk->size() == 0) {\n@@ -211,7 +227,7 @@ py::dict DuckDBPyResult::FetchNumpyInternal(bool stream, idx_t vectors_per_chunk\n \t} else {\n \t\tif (!stream) {\n \t\t\twhile (true) {\n-\t\t\t\tauto chunk = result->FetchRaw();\n+\t\t\t\tauto chunk = FetchNextRaw(*result);\n \t\t\t\tif (!chunk || chunk->size() == 0) {\n \t\t\t\t\t//! finished\n \t\t\t\t\tbreak;\n@@ -224,7 +240,7 @@ py::dict DuckDBPyResult::FetchNumpyInternal(bool stream, idx_t vectors_per_chunk\n \t\t\t\tif (!stream_result->is_open) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\tauto chunk = stream_result->FetchRaw();\n+\t\t\t\tauto chunk = FetchNextRaw(*stream_result);\n \t\t\t\tif (!chunk || chunk->size() == 0) {\n \t\t\t\t\t//! finished\n \t\t\t\t\tbreak;\n@@ -271,7 +287,7 @@ bool FetchArrowChunk(QueryResult *result, py::list &batches,\n \t\t\treturn false;\n \t\t}\n \t}\n-\tauto data_chunk = result->Fetch();\n+\tauto data_chunk = FetchNext(*result);\n \tif (!data_chunk || data_chunk->size() == 0) {\n \t\treturn false;\n \t}\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/test_runtime_error.py b/tools/pythonpkg/tests/fast/test_runtime_error.py\nnew file mode 100644\nindex 000000000000..54db79d6c102\n--- /dev/null\n+++ b/tools/pythonpkg/tests/fast/test_runtime_error.py\n@@ -0,0 +1,36 @@\n+import duckdb\n+\n+class TestRuntimeError(object):\n+    def test_fetch_error(self, duckdb_cursor):\n+        con = duckdb.connect()\n+        con.execute(\"create table tbl as select 'hello' i\")\n+        raised_error = False\n+        try:\n+            con.execute(\"select i::int from tbl\").fetchall()\n+        except:\n+            raised_error = True\n+        assert raised_error == True\n+\n+    def test_df_error(self, duckdb_cursor):\n+        con = duckdb.connect()\n+        con.execute(\"create table tbl as select 'hello' i\")\n+        raised_error = False\n+        try:\n+            con.execute(\"select i::int from tbl\").df()\n+        except:\n+            raised_error = True\n+        assert raised_error == True\n+\n+    def test_arrow_error(self, duckdb_cursor):\n+        try:\n+            import pyarrow\n+        except:\n+            return\n+        con = duckdb.connect()\n+        con.execute(\"create table tbl as select 'hello' i\")\n+        raised_error = False\n+        try:\n+            con.execute(\"select i::int from tbl\").arrow()\n+        except:\n+            raised_error = True\n+        assert raised_error == True\n",
  "problem_statement": "CAST from TIMESTAMP to BIGINT\n**What does happen?**\r\nIt looks like when you do a CAST from timestamp to bigint or ubigint it fails silently. Is this supported ?\r\n```SELECT CAST(TIME AS ubigint) , VALUE from table```\r\n\r\nIs there a way to enable debug logs in python runtime to see what really happens.\r\n\r\n**To Reproduce**\r\n```SELECT CAST(TIME AS ubigint) , VALUE from table```\nCAST from TIMESTAMP to BIGINT\n**What does happen?**\r\nIt looks like when you do a CAST from timestamp to bigint or ubigint it fails silently. Is this supported ?\r\n```SELECT CAST(TIME AS ubigint) , VALUE from table```\r\n\r\nIs there a way to enable debug logs in python runtime to see what really happens.\r\n\r\n**To Reproduce**\r\n```SELECT CAST(TIME AS ubigint) , VALUE from table```\n",
  "hints_text": "\n",
  "created_at": "2021-10-18T13:01:07Z"
}