diff --git a/grammar/test.html b/grammar/test.html
deleted file mode 100644
index 754c08752e0b..000000000000
--- a/grammar/test.html
+++ /dev/null
@@ -1,13 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-  <head>
-    <meta charset="utf-8">
-    <title>title</title>
-    <link rel="stylesheet" href="railroad.css">
-  </head>
-  <body>
-	  <div id="rrdiagram"></div>
-  </body>
-  <script src="railroad.js"></script>
-  <script src="delete.js"></script>
-</html>
\ No newline at end of file
diff --git a/test/common/test_file_system.cpp b/test/common/test_file_system.cpp
index 00b5f938510e..e5141b14797f 100644
--- a/test/common/test_file_system.cpp
+++ b/test/common/test_file_system.cpp
@@ -75,7 +75,7 @@ TEST_CASE("Test file operations", "[file_system]") {
 	// standard reading/writing test
 
 	// open file for writing
-	REQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::WRITE | FileFlags::FILE_CREATE, FileLockType::NO_LOCK));
+	REQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE, FileLockType::NO_LOCK));
 	// write 10 integers
 	REQUIRE_NOTHROW(handle->Write((void *)test_data, sizeof(int64_t) * INTEGER_COUNT, 0));
 	// close the file
@@ -85,7 +85,7 @@ TEST_CASE("Test file operations", "[file_system]") {
 		test_data[i] = 0;
 	}
 	// now open the file for reading
-	REQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::READ, FileLockType::NO_LOCK));
+	REQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::FILE_FLAGS_READ, FileLockType::NO_LOCK));
 	// read the 10 integers back
 	REQUIRE_NOTHROW(handle->Read((void *)test_data, sizeof(int64_t) * INTEGER_COUNT, 0));
 	// check the values of the integers
@@ -110,7 +110,7 @@ TEST_CASE("Test file buffers for reading/writing to file", "[file_system]") {
 	}
 
 	// open file for writing
-	REQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::WRITE | FileFlags::FILE_CREATE | FileFlags::DIRECT_IO,
+	REQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE | FileFlags::FILE_FLAGS_DIRECT_IO,
 	                                     FileLockType::WRITE_LOCK));
 	// write the buffer
 	REQUIRE_NOTHROW(buf->Write(*handle, 0));
diff --git a/test/sql/copy/csv/data/test/dateformat.csv b/test/sql/copy/csv/data/test/dateformat.csv
new file mode 100644
index 000000000000..c032d1bc410e
--- /dev/null
+++ b/test/sql/copy/csv/data/test/dateformat.csv
@@ -0,0 +1,1 @@
+05/06/2019
\ No newline at end of file
diff --git a/test/sql/copy/csv/data/test/timestampformat.csv b/test/sql/copy/csv/data/test/timestampformat.csv
new file mode 100644
index 000000000000..6c1bc88dd722
--- /dev/null
+++ b/test/sql/copy/csv/data/test/timestampformat.csv
@@ -0,0 +1,1 @@
+Mon 30, June 2003, 12:03:10 PM
\ No newline at end of file
diff --git a/test/sql/copy/csv/test_dateformat.test b/test/sql/copy/csv/test_dateformat.test
new file mode 100644
index 000000000000..683f655e4c43
--- /dev/null
+++ b/test/sql/copy/csv/test_dateformat.test
@@ -0,0 +1,48 @@
+# name: test/sql/copy/csv/test_dateformat.test
+# description: Test CSVs with a variable date format
+# group: [csv]
+
+statement ok
+CREATE TABLE dates (d DATE);
+
+# base date format does not work here
+statement error
+COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (HEADER 0)
+
+statement ok
+COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (HEADER 0, DATEFORMAT '%d/%m/%Y')
+
+query I
+SELECT * FROM dates
+----
+2019-06-05
+
+# if we reverse the date format, we get a different result
+statement ok
+COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (HEADER 0, DATEFORMAT '%m/%d/%Y')
+
+query I
+SELECT * FROM dates ORDER BY d
+----
+2019-05-06
+2019-06-05
+
+# timestamp format
+statement ok
+CREATE TABLE timestamps(t TIMESTAMP);
+
+# timestamp format
+statement ok
+COPY timestamps FROM 'test/sql/copy/csv/data/test/timestampformat.csv' (HEADER 0, DELIMITER '|', TIMESTAMPFORMAT '%a %d, %B %Y, %I:%M:%S %p')
+
+query I
+SELECT * FROM timestamps
+----
+2003-06-30 12:03:10
+
+# incorrect date/timestamp format results in an error
+statement error
+COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (HEADER 0, DATEFORMAT '%')
+
+statement error
+COPY timestamps FROM 'test/sql/copy/csv/data/test/timestampformat.csv' (HEADER 0, DELIMITER '|', TIMESTAMPFORMAT '%')
\ No newline at end of file
diff --git a/test/sql/copy/csv/test_read_csv.test b/test/sql/copy/csv/test_read_csv.test
index c09370f79d8b..c60fe3111d37 100644
--- a/test/sql/copy/csv/test_read_csv.test
+++ b/test/sql/copy/csv/test_read_csv.test
@@ -1,10 +1,60 @@
 # name: test/sql/copy/csv/test_read_csv.test
-# description: Test read CSV function with lineitem
+# description: Test read CSV function
 # group: [csv]
 
+# read csv with explicit separator
+statement ok
+CREATE TABLE abac_tbl (a VARCHAR, b VARCHAR, c VARCHAR);
+
+query I
+INSERT INTO abac_tbl SELECT * FROM read_csv('test/sql/copy/csv/data/abac/abac.csv', columns=STRUCT_PACK(a := 'VARCHAR', b := 'VARCHAR', c := 'VARCHAR'), sep='ABAC')
+----
+1
+
+query TTT
+SELECT * FROM abac_tbl
+----
+AB	ABAB	NULL
+
+# dateformat
+statement ok
+CREATE TABLE dates (d DATE);
+
+# base date format does not work here
+statement error
+INSERT INTO dates SELECT * FROM read_csv('test/sql/copy/csv/data/test/dateformat.csv', columns=STRUCT_PACK(d := 'DATE'), header=0)
+
+# have to specify it ourselves
+statement ok
+INSERT INTO dates SELECT * FROM read_csv('test/sql/copy/csv/data/test/dateformat.csv', columns=STRUCT_PACK(d := 'DATE'), header=0, dateformat='%d/%m/%Y')
+
+query I
+SELECT * FROM dates
+----
+2019-06-05
+
+# dateformat should also work with auto format
+statement ok
+INSERT INTO dates SELECT * FROM read_csv('test/sql/copy/csv/data/test/dateformat.csv', dateformat='%m/%d/%Y')
+
+query I
+SELECT * FROM dates ORDER BY 1
+----
+2019-05-06
+2019-06-05
+
+# we can also do this for timestamps
+statement ok
+CREATE TABLE timestamps AS SELECT * FROM read_csv('test/sql/copy/csv/data/test/dateformat.csv', timestampformat='%m/%d/%Y')
+
+query I
+SELECT * FROM timestamps
+----
+2019-05-06 00:00:00
+
 # create a view using the read_csv function
 statement ok
-CREATE VIEW lineitem AS SELECT * FROM read_csv('test/sql/copy/csv/data/real/lineitem_sample.csv', '|', STRUCT_PACK(l_orderkey := 'INT', l_partkey := 'INT', l_suppkey := 'INT', l_linenumber := 'INT', l_quantity := 'INTEGER', l_extendedprice := 'DOUBLE', l_discount := 'DOUBLE', l_tax := 'DOUBLE', l_returnflag := 'VARCHAR', l_linestatus := 'VARCHAR', l_shipdate := 'DATE', l_commitdate := 'DATE', l_receiptdate := 'DATE', l_shipinstruct := 'VARCHAR', l_shipmode := 'VARCHAR', l_comment := 'VARCHAR'));
+CREATE VIEW lineitem AS SELECT * FROM read_csv('test/sql/copy/csv/data/real/lineitem_sample.csv', sep='|', columns=STRUCT_PACK(l_orderkey := 'INT', l_partkey := 'INT', l_suppkey := 'INT', l_linenumber := 'INT', l_quantity := 'INTEGER', l_extendedprice := 'DOUBLE', l_discount := 'DOUBLE', l_tax := 'DOUBLE', l_returnflag := 'VARCHAR', l_linestatus := 'VARCHAR', l_shipdate := 'DATE', l_commitdate := 'DATE', l_receiptdate := 'DATE', l_shipinstruct := 'VARCHAR', l_shipmode := 'VARCHAR', l_comment := 'VARCHAR'));
 
 # each of these will read the CSV again through the view
 query I
@@ -13,10 +63,10 @@ SELECT COUNT(*) FROM lineitem
 10
 
 query IT
-SELECT l_partkey, l_comment FROM lineitem WHERE l_orderkey=1 ORDER BY l_linenumber;
+SELECT l_partkey, RTRIM(l_comment) FROM lineitem WHERE l_orderkey=1 ORDER BY l_linenumber;
 ----
 15519	egular courts above the
-6731	ly final dependencies: slyly bold 
+6731	ly final dependencies: slyly bold
 6370	riously. regular, express dep
 214	lites. fluffily even de
 2403	 pending foxes. slyly re
@@ -25,5 +75,5 @@ SELECT l_partkey, l_comment FROM lineitem WHERE l_orderkey=1 ORDER BY l_linenumb
 # test incorrect usage of read_csv function
 # wrong argument type
 statement error
-SELECT * FROM read_csv('test/sql/copy/csv/data/real/lineitem_sample.csv', '|', STRUCT_PACK(l_orderkey := 5))
+SELECT * FROM read_csv('test/sql/copy/csv/data/real/lineitem_sample.csv', sep='|', columns=STRUCT_PACK(l_orderkey := 5))
 
diff --git a/test/sql/function/date/test_strftime.test b/test/sql/function/date/test_strftime.test
new file mode 100644
index 000000000000..84a7df7427b3
--- /dev/null
+++ b/test/sql/function/date/test_strftime.test
@@ -0,0 +1,88 @@
+# name: test/sql/function/date/test_strftime.test
+# description: Test strftime function
+# group: [date]
+
+statement ok
+PRAGMA enable_verification
+
+# simple single specifier
+query I
+SELECT strftime(DATE '1992-01-01', '%Y');
+----
+1992
+
+# some literals
+query I
+SELECT strftime(DATE '1992-01-01', '(%Y)');
+----
+(1992)
+
+# escapes
+query I
+SELECT strftime(DATE '1992-01-01', '%% %Y %%');
+----
+% 1992 %
+
+# many consecutive escapes
+query I
+SELECT strftime(DATE '1992-01-01', '%%%%%% %Y %%%%%%');
+----
+%%% 1992 %%%
+
+# multiple specifiers
+query I
+SELECT strftime(DATE '1992-02-01', '%d/%m/%Y');
+----
+01/02/1992
+
+# we can repeat the same specifier many times
+query I
+SELECT strftime(DATE '1992-02-01', '%Y %Y %Y %Y');
+----
+1992 1992 1992 1992
+
+# test on a table
+statement ok
+CREATE TABLE dates(d DATE);
+INSERT INTO dates VALUES ('1992-01-01'), ('1993-03-20'), (NULL);
+
+query I
+SELECT strftime(d, '%d/%m/%Y') FROM dates ORDER BY d;
+----
+NULL
+01/01/1992
+20/03/1993
+
+# null date
+query I
+SELECT strftime(NULL::DATE, '%d/%m/%Y') FROM dates ORDER BY d;
+----
+NULL
+NULL
+NULL
+
+# null format
+query I
+SELECT strftime(d, NULL) FROM dates ORDER BY d;
+----
+NULL
+NULL
+NULL
+
+# no specifiers, only constant
+query I
+SELECT strftime(DATE '1992-01-01', 'hello world');
+----
+hello world
+
+# non-constant format not supported
+statement error
+SELECT strftime(d, d::VARCHAR) FROM dates ORDER BY d;
+
+# unterminated escape
+statement error
+SELECT strftime(DATE '1992-01-01', '%');
+
+# unrecognized code
+statement error
+SELECT strftime(DATE '1992-01-01', '%R');
diff --git a/test/sql/function/date/test_strftime_exhaustive.test b/test/sql/function/date/test_strftime_exhaustive.test
new file mode 100644
index 000000000000..542d821df1ab
--- /dev/null
+++ b/test/sql/function/date/test_strftime_exhaustive.test
@@ -0,0 +1,354 @@
+# name: test/sql/function/date/test_strftime_exhausted.test
+# description: Test all strftime % codes with the date type
+# group: [date]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE dates(d DATE);
+INSERT INTO dates VALUES ('1992-01-01'), ('1993-03-20'), ('2020-08-09'), ('2020-08-10'), (NULL);
+
+# %a: Abbreviated weekday name
+query I
+SELECT strftime(d, '%a') FROM dates ORDER BY d;
+----
+NULL
+Wed
+Sat
+Sun
+Mon
+
+# %A: Full weekday name
+query I
+SELECT strftime(d, '%A') FROM dates ORDER BY d;
+----
+NULL
+Wednesday
+Saturday
+Sunday
+Monday
+
+# %w - Weekday as a decimal number.
+query I
+SELECT strftime(d, '%w') FROM dates ORDER BY d;
+----
+NULL
+3
+6
+0
+1
+
+# %d - Day of the month as a zero-padded decimal.
+query I
+SELECT strftime(d, '%d') FROM dates ORDER BY d;
+----
+NULL
+01
+20
+09
+10
+
+# %-d - Day of the month as a decimal number.
+query I
+SELECT strftime(d, '%-d') FROM dates ORDER BY d;
+----
+NULL
+1
+20
+9
+10
+
+# %b - Abbreviated month name.
+query I
+SELECT strftime(d, '%b') FROM dates ORDER BY d;
+----
+NULL
+Jan
+Mar
+Aug
+Aug
+
+# %h - alias for %b
+query I
+SELECT strftime(d, '%h') FROM dates ORDER BY d;
+----
+NULL
+Jan
+Mar
+Aug
+Aug
+
+# %B - Full month name
+query I
+SELECT strftime(d, '%B') FROM dates ORDER BY d;
+----
+NULL
+January
+March
+August
+August
+
+# %m - Month as a zero-padded decimal number
+query I
+SELECT strftime(d, '%m') FROM dates ORDER BY d;
+----
+NULL
+01
+03
+08
+08
+
+# %-m - Month as a decimal number. (1, 2, ..., 12)
+query I
+SELECT strftime(d, '%-m') FROM dates ORDER BY d;
+----
+NULL
+1
+3
+8
+8
+
+# %y - Year without century as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%y') FROM dates ORDER BY d;
+----
+NULL
+92
+93
+20
+20
+
+# %-y - Year without century as a decimal number.
+query I
+SELECT strftime(d, '%-y') FROM dates ORDER BY d;
+----
+NULL
+92
+93
+20
+20
+
+query I
+SELECT strftime(DATE '2001-01-01', '%-y')
+----
+1
+
+# %Y - Year with century as a decimal number.
+query I
+SELECT strftime(d, '%Y') FROM dates ORDER BY d;
+----
+NULL
+1992
+1993
+2020
+2020
+
+# %H - Hour (24-hour clock) as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%H') FROM dates ORDER BY d;
+----
+NULL
+00
+00
+00
+00
+
+# %-H - Hour (24-hour clock) as a decimal number. (0, 1, ..., 23)
+query I
+SELECT strftime(d, '%-H') FROM dates ORDER BY d;
+----
+NULL
+0
+0
+0
+0
+
+# %I - Hour (12-hour clock) as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%I') FROM dates ORDER BY d;
+----
+NULL
+12
+12
+12
+12
+
+# %-I - Hour (12-hour clock) as a decimal number. (1, 2, ... 12)
+query I
+SELECT strftime(d, '%-I') FROM dates ORDER BY d;
+----
+NULL
+12
+12
+12
+12
+
+# %p - Locale’s AM or PM.
+query I
+SELECT strftime(d, '%p') FROM dates ORDER BY d;
+----
+NULL
+AM
+AM
+AM
+AM
+
+# %M - Minute as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%M') FROM dates ORDER BY d;
+----
+NULL
+00
+00
+00
+00
+
+# %-M - Minute as a decimal number. (0, 1, ..., 59)
+query I
+SELECT strftime(d, '%-M') FROM dates ORDER BY d;
+----
+NULL
+0
+0
+0
+0
+
+# %S - Second as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%S') FROM dates ORDER BY d;
+----
+NULL
+00
+00
+00
+00
+
+# %-S - Second as a decimal number. (0, 1, ..., 59)
+query I
+SELECT strftime(d, '%-S') FROM dates ORDER BY d;
+----
+NULL
+0
+0
+0
+0
+
+# %f - Microsecond as a decimal number, zero-padded on the left.
+query I
+SELECT strftime(d, '%f') FROM dates ORDER BY d;
+----
+NULL
+000000
+000000
+000000
+000000
+
+# %z - UTC offset in the form +HHMM or -HHMM.
+query I
+SELECT strftime(d, '%z') FROM dates ORDER BY d;
+----
+NULL
+(empty)
+(empty)
+(empty)
+(empty)
+
+# %Z - Time zone name.
+query I
+SELECT strftime(d, '%Z') FROM dates ORDER BY d;
+----
+NULL
+(empty)
+(empty)
+(empty)
+(empty)
+
+# %j - Day of the year as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%j') FROM dates ORDER BY d;
+----
+NULL
+001
+079
+222
+223
+
+# %-j - Day of the year as a decimal number. (1, 2, ..., 366)
+query I
+SELECT strftime(d, '%-j') FROM dates ORDER BY d;
+----
+NULL
+1
+79
+222
+223
+
+# %U - Week number of the year (Sunday as the first day of the week).
+query I
+SELECT strftime(d, '%U') FROM dates ORDER BY d;
+----
+NULL
+00
+11
+32
+32
+
+# %W - Week number of the year (Monday as the first day of the week).
+query I
+SELECT strftime(d, '%W') FROM dates ORDER BY d;
+----
+NULL
+00
+11
+31
+32
+
+# %c - Locale’s appropriate date and time representation.
+query I
+SELECT strftime(d, '%c') FROM dates ORDER BY d;
+----
+NULL
+1992-01-01 00:00:00
+1993-03-20 00:00:00
+2020-08-09 00:00:00
+2020-08-10 00:00:00
+
+query I
+SELECT strftime(d, 'XX%cXX') FROM dates ORDER BY d;
+----
+NULL
+XX1992-01-01 00:00:00XX
+XX1993-03-20 00:00:00XX
+XX2020-08-09 00:00:00XX
+XX2020-08-10 00:00:00XX
+
+# %x - Locale’s appropriate date representation.
+query I
+SELECT strftime(d, '%x') FROM dates ORDER BY d;
+----
+NULL
+1992-01-01
+1993-03-20
+2020-08-09
+2020-08-10
+
+# X - Locale’s appropriate time representation.
+query I
+SELECT strftime(d, '%X') FROM dates ORDER BY d;
+----
+NULL
+00:00:00
+00:00:00
+00:00:00
+00:00:00
+
+
+query I
+SELECT strftime(d, 'XX%cXX%xXX%XXX') FROM dates ORDER BY d;
+----
+NULL
+XX1992-01-01 00:00:00XX1992-01-01XX00:00:00XX
+XX1993-03-20 00:00:00XX1993-03-20XX00:00:00XX
+XX2020-08-09 00:00:00XX2020-08-09XX00:00:00XX
+XX2020-08-10 00:00:00XX2020-08-10XX00:00:00XX
diff --git a/test/sql/function/timestamp/age.test b/test/sql/function/timestamp/age.test
index 2bce28ad61dd..4e7475054919 100644
--- a/test/sql/function/timestamp/age.test
+++ b/test/sql/function/timestamp/age.test
@@ -140,3 +140,15 @@ query T
 SELECT AGE(NULL, TIMESTAMP '1957-06-13');
 ----
 NULL
+
+# date can also be used with AGE
+# hopefully the clock is not off by more than a century
+query T
+SELECT INTERVAL '1' DAY < AGE(DATE '1900-06-13');
+----
+1
+
+query T
+SELECT AGE(DATE '1900-01-01', DATE '1950-01-01');
+----
+50 years
diff --git a/test/sql/function/timestamp/test_strftime_timestamp.test b/test/sql/function/timestamp/test_strftime_timestamp.test
new file mode 100644
index 000000000000..ac6dabd151a3
--- /dev/null
+++ b/test/sql/function/timestamp/test_strftime_timestamp.test
@@ -0,0 +1,336 @@
+# name: test/sql/function/date/test_strftime_exhausted.test
+# description: Test all strftime % codes with the date type
+# group: [date]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+CREATE TABLE timestamps(d TIMESTAMP);
+INSERT INTO timestamps VALUES ('1992-01-01 01:20:30'), ('1993-03-20 23:50:01'), ('2020-08-09 12:01:55'), ('2020-08-10 10:10:10'), (NULL);
+
+# %a: Abbreviated weekday name
+query I
+SELECT strftime(d, '%a') FROM timestamps ORDER BY d;
+----
+NULL
+Wed
+Sat
+Sun
+Mon
+
+# %A: Full weekday name
+query I
+SELECT strftime(d, '%A') FROM timestamps ORDER BY d;
+----
+NULL
+Wednesday
+Saturday
+Sunday
+Monday
+
+# %w - Weekday as a decimal number.
+query I
+SELECT strftime(d, '%w') FROM timestamps ORDER BY d;
+----
+NULL
+3
+6
+0
+1
+
+# %d - Day of the month as a zero-padded decimal.
+query I
+SELECT strftime(d, '%d') FROM timestamps ORDER BY d;
+----
+NULL
+01
+20
+09
+10
+
+# %-d - Day of the month as a decimal number.
+query I
+SELECT strftime(d, '%-d') FROM timestamps ORDER BY d;
+----
+NULL
+1
+20
+9
+10
+
+# %b - Abbreviated month name.
+query I
+SELECT strftime(d, '%b') FROM timestamps ORDER BY d;
+----
+NULL
+Jan
+Mar
+Aug
+Aug
+
+# %h - alias for %b
+query I
+SELECT strftime(d, '%h') FROM timestamps ORDER BY d;
+----
+NULL
+Jan
+Mar
+Aug
+Aug
+
+# %B - Full month name
+query I
+SELECT strftime(d, '%B') FROM timestamps ORDER BY d;
+----
+NULL
+January
+March
+August
+August
+
+# %m - Month as a zero-padded decimal number
+query I
+SELECT strftime(d, '%m') FROM timestamps ORDER BY d;
+----
+NULL
+01
+03
+08
+08
+
+# %-m - Month as a decimal number. (1, 2, ..., 12)
+query I
+SELECT strftime(d, '%-m') FROM timestamps ORDER BY d;
+----
+NULL
+1
+3
+8
+8
+
+# %y - Year without century as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%y') FROM timestamps ORDER BY d;
+----
+NULL
+92
+93
+20
+20
+
+# %-y - Year without century as a decimal number.
+query I
+SELECT strftime(d, '%-y') FROM timestamps ORDER BY d;
+----
+NULL
+92
+93
+20
+20
+
+query I
+SELECT strftime(DATE '2001-01-01', '%-y')
+----
+1
+
+# %Y - Year with century as a decimal number.
+query I
+SELECT strftime(d, '%Y') FROM timestamps ORDER BY d;
+----
+NULL
+1992
+1993
+2020
+2020
+
+# %H - Hour (24-hour clock) as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%H') FROM timestamps ORDER BY d;
+----
+NULL
+01
+23
+12
+10
+
+# %-H - Hour (24-hour clock) as a decimal number. (0, 1, ..., 23)
+query I
+SELECT strftime(d, '%-H') FROM timestamps ORDER BY d;
+----
+NULL
+1
+23
+12
+10
+
+# %I - Hour (12-hour clock) as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%I') FROM timestamps ORDER BY d;
+----
+NULL
+01
+11
+12
+10
+
+# %-I - Hour (12-hour clock) as a decimal number. (1, 2, ... 12)
+query I
+SELECT strftime(d, '%-I') FROM timestamps ORDER BY d;
+----
+NULL
+1
+11
+12
+10
+
+# %p - Locale’s AM or PM.
+query I
+SELECT strftime(d, '%p') FROM timestamps ORDER BY d;
+----
+NULL
+AM
+PM
+PM
+AM
+
+# %M - Minute as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%M') FROM timestamps ORDER BY d;
+----
+NULL
+20
+50
+01
+10
+
+# %-M - Minute as a decimal number. (0, 1, ..., 59)
+query I
+SELECT strftime(d, '%-M') FROM timestamps ORDER BY d;
+----
+NULL
+20
+50
+1
+10
+
+# %S - Second as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%S') FROM timestamps ORDER BY d;
+----
+NULL
+30
+01
+55
+10
+
+# %-S - Second as a decimal number. (0, 1, ..., 59)
+query I
+SELECT strftime(d, '%-S') FROM timestamps ORDER BY d;
+----
+NULL
+30
+1
+55
+10
+
+# %f - Microsecond as a decimal number, zero-padded on the left.
+query I
+SELECT strftime(d, '%f') FROM timestamps ORDER BY d;
+----
+NULL
+000000
+000000
+000000
+000000
+
+# %z - UTC offset in the form +HHMM or -HHMM.
+query I
+SELECT strftime(d, '%z') FROM timestamps ORDER BY d;
+----
+NULL
+(empty)
+(empty)
+(empty)
+(empty)
+
+# %Z - Time zone name.
+query I
+SELECT strftime(d, '%Z') FROM timestamps ORDER BY d;
+----
+NULL
+(empty)
+(empty)
+(empty)
+(empty)
+
+# %j - Day of the year as a zero-padded decimal number.
+query I
+SELECT strftime(d, '%j') FROM timestamps ORDER BY d;
+----
+NULL
+001
+079
+222
+223
+
+# %-j - Day of the year as a decimal number. (1, 2, ..., 366)
+query I
+SELECT strftime(d, '%-j') FROM timestamps ORDER BY d;
+----
+NULL
+1
+79
+222
+223
+
+
+# %U - Week number of the year (Sunday as the first day of the week).
+query I
+SELECT strftime(d, '%U') FROM timestamps ORDER BY d;
+----
+NULL
+00
+11
+32
+32
+
+# %W - Week number of the year (Monday as the first day of the week).
+query I
+SELECT strftime(d, '%W') FROM timestamps ORDER BY d;
+----
+NULL
+00
+11
+31
+32
+
+# %c - Locale’s appropriate date and time representation.
+query I
+SELECT strftime(d, '%c') FROM timestamps ORDER BY d;
+----
+NULL
+1992-01-01 01:20:30
+1993-03-20 23:50:01
+2020-08-09 12:01:55
+2020-08-10 10:10:10
+
+# %x - Locale’s appropriate date representation.
+query I
+SELECT strftime(d, '%x') FROM timestamps ORDER BY d;
+----
+NULL
+1992-01-01
+1993-03-20
+2020-08-09
+2020-08-10
+
+# X - Locale’s appropriate time representation.
+query I
+SELECT strftime(d, '%X') FROM timestamps ORDER BY d;
+----
+NULL
+01:20:30
+23:50:01
+12:01:55
+10:10:10
diff --git a/test/sql/function/timestamp/test_strptime.test b/test/sql/function/timestamp/test_strptime.test
new file mode 100644
index 000000000000..785c0111587f
--- /dev/null
+++ b/test/sql/function/timestamp/test_strptime.test
@@ -0,0 +1,194 @@
+# name: test/sql/function/timestamp/test_strptime.test
+# description: Test strptime function
+# group: [timestamp]
+
+statement ok
+PRAGMA enable_verification
+
+query I
+SELECT strptime('21 June, 2018', '%d %B, %Y')
+----
+2018-06-21 00:00:00
+
+query I
+SELECT strptime('21/10/2018', '%d/%m/%Y')
+----
+2018-10-21 00:00:00
+
+query I
+SELECT strptime('2018-20-10', '%Y-%d-%m')
+----
+2018-10-20 00:00:00
+
+query I
+SELECT strptime('Mon 30, June 2003, 12:03:10 AM', '%a %d, %B %Y, %I:%M:%S %p')
+----
+2003-06-30 00:03:10
+
+query I
+SELECT strptime('Mon 30, June 2003, 12:03:10 PM', '%a %d, %B %Y, %I:%M:%S %p')
+----
+2003-06-30 12:03:10
+
+query I
+SELECT strptime('Mon 30, December 2003, 7:3:5 PM', '%a %d, %B %Y, %I:%M:%S %p')
+----
+2003-12-30 19:03:05
+
+query I
+SELECT strptime('Tuesday 30, December 2003, 7:3:5 PM', '%A %d, %B %Y, %I:%M:%S %p')
+----
+2003-12-30 19:03:05
+
+query I
+SELECT strptime('Mon 30, December 30, 7:3:5 PM', '%a %d, %B %y, %I:%M:%S %p')
+----
+2030-12-30 19:03:05
+
+# for strptime there is no difference between %- and %
+query I
+SELECT strptime('Mon 30, June 2003, 12:03:10 AM', '%a %-d, %B %Y, %-I:%-M:%-S %p')
+----
+2003-06-30 00:03:10
+
+# lowercase also works
+query I
+SELECT strptime('mon', '%a')
+----
+1900-01-01 00:00:00
+
+query I
+SELECT strptime('tuesday', '%A')
+----
+1900-01-01 00:00:00
+
+query I
+SELECT strptime('jun', '%b')
+----
+1900-06-01 00:00:00
+
+# empty specifier and string
+query I
+SELECT strptime('', '')
+----
+1900-01-01 00:00:00
+
+query I
+SELECT strptime(NULL, '')
+----
+NULL
+
+query I
+SELECT strptime('', NULL)
+----
+NULL
+
+# different errors
+# month out of range
+statement error
+SELECT strptime('2018-20-10', '%Y-%m-%d')
+
+# day out of range
+statement error
+SELECT strptime('2018-10-100', '%Y-%m-%d')
+
+# year without century out of range
+statement error
+SELECT strptime('969-10-10', '%y-%m-%d')
+
+# literal part does not match
+statement error
+SELECT strptime('2000/10/10', '%Y-%m-%d')
+
+# incorrect date
+statement error
+SELECT strptime('2001-02-30', '%Y-%m-%d')
+
+# incorrect date
+statement error
+SELECT strptime('2000-10-hello', '%Y-%m-%d')
+
+# incorrect hour
+statement error
+SELECT strptime('2000-10-01 24:00:00', '%Y-%m-%d %H:%M:%S')
+
+# incorrect hour with 12 hour clock
+statement error
+SELECT strptime('2000-10-01 00:00:00 AM', '%Y-%m-%d %I:%M:%S %p')
+
+statement error
+SELECT strptime('2000-10-01 13:00:00 AM', '%Y-%m-%d %I:%M:%S %p')
+
+# incorrect minute
+statement error
+SELECT strptime('2000-10-01 23:60:00', '%Y-%m-%d %H:%M:%S')
+
+# incorrect seconds
+statement error
+SELECT strptime('2000-10-01 23:59:60', '%Y-%m-%d %H:%M:%S')
+
+# incorrect microseconds
+statement error
+SELECT strptime('2000-10-01 23:59:59.10000000', '%Y-%m-%d %H:%M:%S.%f')
+
+# huge number
+statement error
+SELECT strptime('2000-10-01 23:59:59.1000000000000000000000000000', '%Y-%m-%d %H:%M:%S.%f')
+
+# empty string
+statement error
+SELECT strptime('', '%Y-%m-%d %H:%M:%S.%f')
+
+# empty string with am/pm
+statement error
+SELECT strptime('', '%p')
+
+statement error
+SELECT strptime('a', '%p')
+
+# incorrect am/pm
+statement error
+SELECT strptime('mp', '%p')
+
+statement error
+SELECT strptime('pp', '%p')
+
+# incorrect abbreviated weekday name
+statement error
+SELECT strptime('moa', '%a')
+
+# incorrect weekday name
+statement error
+SELECT strptime('moaday', '%A')
+
+statement error
+SELECT strptime('mondayy', '%A')
+
+# incorrect abbreviated month name
+statement error
+SELECT strptime('juk', '%b')
+
+# incorrect weekday name
+statement error
+SELECT strptime('juke', '%B')
+
+statement error
+SELECT strptime('junee', '%B')
+
+# day of year not supported
+statement error
+SELECT strptime('30', '%j')
+
+statement error
+SELECT strptime('30', '%-j')
+
+# week numbers not supported
+statement error
+SELECT strptime('30', '%U')
+
+statement error
+SELECT strptime('30', '%W')
+
+# AM/PM out of range
+statement error
+SELECT strptime('Mon 30, December 30, 20:3:5 PM', '%a %d, %B %y, %H:%M:%S %p')
diff --git a/test/sql/storage/test_checksum.cpp b/test/sql/storage/test_checksum.cpp
index bfd52b2f70c8..b6b6e980cb0b 100644
--- a/test/sql/storage/test_checksum.cpp
+++ b/test/sql/storage/test_checksum.cpp
@@ -25,7 +25,7 @@ TEST_CASE("Test functioning of checksum", "[storage]") {
 	database.reset();
 
 	// now write random values into the file
-	auto handle = fs.OpenFile(storage_database, FileFlags::WRITE);
+	auto handle = fs.OpenFile(storage_database, FileFlags::FILE_FLAGS_WRITE);
 	int8_t value = 0x22;
 	fs.Write(*handle, &value, sizeof(int8_t), 100);
 	handle->Sync();
diff --git a/test/sql/storage/test_database_size.cpp b/test/sql/storage/test_database_size.cpp
index 3c9fac7eec54..27cb3d7513b1 100644
--- a/test/sql/storage/test_database_size.cpp
+++ b/test/sql/storage/test_database_size.cpp
@@ -40,7 +40,7 @@ TEST_CASE("Test that database size does not grow after many checkpoints", "[stor
 	// get the size of the database
 	int64_t size;
 	{
-		auto handle = fs.OpenFile(storage_database, FileFlags::READ);
+		auto handle = fs.OpenFile(storage_database, FileFlags::FILE_FLAGS_READ);
 		size = fs.GetFileSize(*handle);
 		REQUIRE(size >= 0);
 	}
@@ -61,7 +61,7 @@ TEST_CASE("Test that database size does not grow after many checkpoints", "[stor
 	// get the new file size
 	int64_t new_size;
 	{
-		auto handle = fs.OpenFile(storage_database, FileFlags::READ);
+		auto handle = fs.OpenFile(storage_database, FileFlags::FILE_FLAGS_READ);
 		new_size = fs.GetFileSize(*handle);
 		REQUIRE(new_size >= 0);
 	}
diff --git a/test/sql/storage/test_readonly.cpp b/test/sql/storage/test_readonly.cpp
index 9dc3cb1cad8b..88d216586c6d 100644
--- a/test/sql/storage/test_readonly.cpp
+++ b/test/sql/storage/test_readonly.cpp
@@ -8,7 +8,7 @@ namespace duckdb {
 
 class ReadOnlyFileSystem : public FileSystem {
 	unique_ptr<FileHandle> OpenFile(const char *path, uint8_t flags, FileLockType lock_type) override {
-		if (flags & FileFlags::WRITE) {
+		if (flags & FileFlags::FILE_FLAGS_WRITE) {
 			throw Exception("RO file system");
 		}
 		return FileSystem::OpenFile(path, flags, lock_type);
diff --git a/test/sql/types/timestamp/test_timestamp.test b/test/sql/types/timestamp/test_timestamp.test
index 9be3ef6a7dd2..0cd4ddfe3ea5 100644
--- a/test/sql/types/timestamp/test_timestamp.test
+++ b/test/sql/types/timestamp/test_timestamp.test
@@ -16,6 +16,29 @@ SELECT timestamp '2017-07-23 13:10:11';
 ----
 2017-07-23 13:10:11
 
+# iso timestamps
+query TT
+SELECT timestamp '2017-07-23T13:10:11', timestamp '2017-07-23T13:10:11Z';
+----
+2017-07-23 13:10:11
+2017-07-23 13:10:11
+
+# spaces everywhere
+query T
+SELECT timestamp '    2017-07-23     13:10:11    ';
+----
+2017-07-23 13:10:11
+
+# other trailing, preceding, or middle gunk is not accepted
+statement error
+SELECT timestamp '    2017-07-23     13:10:11    AA';
+
+statement error
+SELECT timestamp 'AA2017-07-23 13:10:11';
+
+statement error
+SELECT timestamp '2017-07-23A13:10:11';
+
 query T
 SELECT t FROM timestamp ORDER BY t;
 ----
diff --git a/test/sql/types/timestamp/test_timestamp_ms.test b/test/sql/types/timestamp/test_timestamp_ms.test
index 81fcea167f21..e91b493c13be 100644
--- a/test/sql/types/timestamp/test_timestamp_ms.test
+++ b/test/sql/types/timestamp/test_timestamp_ms.test
@@ -7,3 +7,8 @@ SELECT CAST('2001-04-20 14:42:11.123' AS TIMESTAMP) a, CAST('2001-04-20 14:42:11
 ----
 2001-04-20 14:42:11.123	2001-04-20 14:42:11
 
+#  many ms
+query I
+SELECT TIMESTAMP '2001-04-20 14:42:11.12300000000000000000';
+----
+2001-04-20 14:42:11.123
diff --git a/test/sqlite/test_sqllogictest.cpp b/test/sqlite/test_sqllogictest.cpp
index f1e68d506f77..252c98faf43c 100644
--- a/test/sqlite/test_sqllogictest.cpp
+++ b/test/sqlite/test_sqllogictest.cpp
@@ -81,6 +81,10 @@ struct SQLLogicTestRunner {
 	unique_ptr<DBConfig> config;
 	unordered_set<string> extensions;
 	unordered_map<string, unique_ptr<Connection>> named_connection_map;
+	bool output_hash_mode = false;
+	bool output_result_mode = false;
+	bool debug_mode = false;
+	int hashThreshold = DEFAULT_HASH_THRESHOLD; /* Threshold for hashing res */
 };
 
 /*
@@ -511,9 +515,6 @@ struct Query : public Command {
 	idx_t expected_column_count = 0;
 	SortStyle sort_style = SortStyle::NO_SORT;
 	vector<string> values;
-	bool output_result_mode = false;
-	int hashThreshold = 0;
-	bool output_hash_mode = false;
 	bool query_has_label = false;
 	string query_label;
 
@@ -530,10 +531,21 @@ struct RestartCommand : public Command {
 void Statement::Execute() {
 	auto connection = CommandConnection();
 
+	if (runner.output_result_mode || runner.debug_mode) {
+		print_line_sep();
+		print_header("File " + file_name + ":" + to_string(query_line) + ")");
+		print_sql(sql_query);
+		print_line_sep();
+	}
+
 	query_break(query_line);
 	auto result = connection->Query(sql_query);
 	bool error = !result->success;
 
+	if (runner.output_result_mode || runner.debug_mode) {
+		result->Print();
+	}
+
 	/* Check to see if we are expecting success or failure */
 	if (!expect_ok) {
 		error = !error;
@@ -566,6 +578,13 @@ void Query::ColumnCountMismatch(MaterializedQueryResult &result, int expected_co
 void Query::Execute() {
 	auto connection = CommandConnection();
 
+	if (runner.output_result_mode || runner.debug_mode) {
+		print_line_sep();
+		print_header("File " + file_name + ":" + to_string(query_line) + ")");
+		print_sql(sql_query);
+		print_line_sep();
+	}
+
 	query_break(query_line);
 	auto result = connection->Query(sql_query);
 	if (!result->success) {
@@ -581,10 +600,7 @@ void Query::Execute() {
 	vector<string> azResult;
 	int nResult;
 	duckdbConvertResult(*result, azResult, nResult);
-	if (output_result_mode) {
-		print_line_sep();
-		print_sql(sql_query);
-		print_line_sep();
+	if (runner.output_result_mode) {
 		// names
 		for(idx_t c = 0; c < result->column_count(); c++) {
 			if (c != 0) {
@@ -652,21 +668,21 @@ void Query::Execute() {
 		std::sort(azResult.begin(), azResult.end());
 	}
 	char zHash[100];                            /* Storage space for hash results */
-	int compare_hash = query_has_label || (hashThreshold > 0 && nResult > hashThreshold);
+	int compare_hash = query_has_label || (runner.hashThreshold > 0 && nResult > runner.hashThreshold);
 	// check if the current line (the first line of the result) is a hash value
 	if (values.size() == 1 && result_is_hash(values[0])) {
 		compare_hash = true;
 	}
 	/* Hash the results if we are over the hash threshold or if we
 	** there is a hash label */
-	if (output_hash_mode || compare_hash) {
+	if (runner.output_hash_mode || compare_hash) {
 		md5_add(""); /* make sure md5 is reset, even if no results */
 		for (int i = 0; i < nResult; i++) {
 			md5_add(azResult[i].c_str());
 			md5_add("
");
 		}
 		snprintf(zHash, sizeof(zHash), "%d values hashing to %s", nResult, md5_finish());
-		if (output_hash_mode) {
+		if (runner.output_hash_mode) {
 			print_line_sep();
 			print_sql(sql_query);
 			print_line_sep();
@@ -877,10 +893,7 @@ void SQLLogicTestRunner::ExecuteFile(string script) {
 	int nSkipped = 0;                           /* Number of SQL statements skipped */
 	Script sScript;                             /* Script parsing status */
 	FILE *in;                                   /* For reading script */
-	int hashThreshold = DEFAULT_HASH_THRESHOLD; /* Threshold for hashing res */
 	int bHt = 0;                                /* True if -ht command-line option */
-	int output_hash_mode = 0;
-	int output_result_mode = 0;
 	bool in_loop = false;
 	string loop_iterator_name;
 	int loop_start;
@@ -1024,9 +1037,6 @@ void SQLLogicTestRunner::ExecuteFile(string script) {
 
 			command->file_name = zScriptFile;
 			command->query_line = sScript.nLine;
-			command->hashThreshold = hashThreshold;
-			command->output_hash_mode = output_hash_mode;
-			command->output_result_mode = output_result_mode;
 
 			/* Verify that the type string consists of one or more
 			 *characters
@@ -1135,9 +1145,11 @@ void SQLLogicTestRunner::ExecuteFile(string script) {
 			break;
 		} else if (strcmp(sScript.azToken[0], "mode") == 0) {
 			if (strcmp(sScript.azToken[1], "output_hash") == 0) {
-				output_hash_mode = 1;
+				output_hash_mode = true;
 			} else if (strcmp(sScript.azToken[1], "output_result") == 0) {
-				output_result_mode = 1;
+				output_result_mode = true;
+			} else if (strcmp(sScript.azToken[1], "debug") == 0) {
+				debug_mode = true;
 			} else if (strcmp(sScript.azToken[1], "skip") == 0) {
 				skip_execution = true;
 			} else if (strcmp(sScript.azToken[1], "unskip") == 0) {
