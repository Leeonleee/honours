{
  "repo": "duckdb/duckdb",
  "pull_number": 824,
  "instance_id": "duckdb__duckdb-824",
  "issue_numbers": [
    "822"
  ],
  "base_commit": "49cacac98d489610df9f0beb531cab37814a2dd2",
  "patch": "diff --git a/benchmark/interpreted_benchmark.cpp b/benchmark/interpreted_benchmark.cpp\nindex 395e452f5045..f25b19df904d 100644\n--- a/benchmark/interpreted_benchmark.cpp\n+++ b/benchmark/interpreted_benchmark.cpp\n@@ -120,7 +120,10 @@ unique_ptr<BenchmarkState> InterpretedBenchmark::Initialize() {\n \tLoadBenchmark();\n \n \tauto state = make_unique<InterpretedBenchmarkState>();\n-\tstate->con.Query(init_query);\n+\tauto result = state->con.Query(init_query);\n+\tif (!result->success) {\n+\t\tthrow Exception(result->error);\n+\t}\n \treturn state;\n }\n \ndiff --git a/benchmark/micro/cast/strftime.benchmark b/benchmark/micro/cast/strftime.benchmark\nnew file mode 100644\nindex 000000000000..5c003550d705\n--- /dev/null\n+++ b/benchmark/micro/cast/strftime.benchmark\n@@ -0,0 +1,12 @@\n+# name: benchmark/micro/cast/strftime.benchmark\n+# description: Use strftime to convert dates to strings\n+# group: [cast]\n+\n+load\n+CREATE TABLE dates AS SELECT DATE '1992-01-01' + i::INTEGER AS d FROM range(0, 10000000) tbl(i);\n+\n+run\n+SELECT MIN(strftime(d, '%Y/%m/%d')) FROM dates\n+\n+result I\n+10000/01/01\n\\ No newline at end of file\ndiff --git a/benchmark/micro/cast/strptime.benchmark b/benchmark/micro/cast/strptime.benchmark\nnew file mode 100644\nindex 000000000000..62aa18f68ca9\n--- /dev/null\n+++ b/benchmark/micro/cast/strptime.benchmark\n@@ -0,0 +1,12 @@\n+# name: benchmark/micro/cast/strptime.benchmark\n+# description: Use strptime to convert strings to dates\n+# group: [cast]\n+\n+load\n+CREATE TABLE dates AS SELECT strftime(DATE '1992-01-01' + i::INTEGER, '%Y/%m/%d') AS d FROM range(0, 10000000) tbl(i);\n+\n+run\n+SELECT MIN(strptime(d, '%Y/%m/%d')) FROM dates\n+\n+result I\n+1992-01-01\ndiff --git a/extension/parquet/parquet-extension.cpp b/extension/parquet/parquet-extension.cpp\nindex b90e72e3a696..011041bd8411 100644\n--- a/extension/parquet/parquet-extension.cpp\n+++ b/extension/parquet/parquet-extension.cpp\n@@ -328,7 +328,7 @@ class ParquetScanFunction : public TableFunction {\n \t}\n \n private:\n-\tstatic unique_ptr<FunctionData> parquet_scan_bind(ClientContext &context, vector<Value> inputs,\n+\tstatic unique_ptr<FunctionData> parquet_scan_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n \t                                                  vector<SQLType> &return_types, vector<string> &names) {\n \n \t\tauto file_name = inputs[0].GetValue<string>();\n@@ -1254,7 +1254,7 @@ unique_ptr<GlobalFunctionData> parquet_write_initialize_global(ClientContext &co\n \n \t// initialize the file writer\n \tglobal_state->writer = make_unique<BufferedFileWriter>(context.db.GetFileSystem(), parquet_bind.file_name.c_str(),\n-\t                                                       FileFlags::WRITE | FileFlags::FILE_CREATE_NEW);\n+\t                                                       FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE_NEW);\n \t// parquet files start with the string \"PAR1\"\n \tglobal_state->writer->WriteData((const_data_ptr_t) \"PAR1\", 4);\n \tTCompactProtocolFactoryT<MyTransport> tproto_factory;\ndiff --git a/grammar/delete.js b/grammar/delete.js\ndeleted file mode 100644\nindex d428baae596f..000000000000\n--- a/grammar/delete.js\n+++ /dev/null\n@@ -1,119 +0,0 @@\n-\n-function GenerateValues(options) {\n-\treturn [\n-\t\tKeyword(\"VALUES\"),\n-\t\tOneOrMore(\n-\t\t\tSequence([\n-\t\t\t\tKeyword(\"(\"),\n-\t\t\t\tOneOrMore(Expression(), \",\"),\n-\t\t\t\tKeyword(\")\")\n-\t\t\t]), Keyword(\",\"))\n-\t]\n-}\n-\n-function GenerateDistinctClause(options) {\n-\treturn [\n-\t\tChoice(0, [\n-\t\t\tnew Skip(),\n-\t\t\tSequence([\n-\t\t\t\tKeyword(\"DISTINCT\"),\n-\t\t\t\tOptional(Sequence([\n-\t\t\t\t\tKeyword(\"(\"),\n-\t\t\t\t\tOneOrMore(Expression(\"distinct-term\"), \",\"),\n-\t\t\t\t\tKeyword(\")\"),\n-\t\t\t\t]) , \"skip\")\n-\t\t\t]),\n-\t\t\tKeyword(\"ALL\")\n-\t\t])\n-\t]\n-}\n-\n-function GenerateSelectNode(options) {\n-\treturn [Stack([\n-\t\tSequence([\n-\t\t\tKeyword(\"SELECT\"),\n-\t\t\tExpandable(\"distinct-clause\", options, \"distinct-clause\", GenerateDistinctClause),\n-\t\t\tOneOrMore(Expression(), \",\")\n-\t\t]),\n-\t\tSequence([\n-\t\t\tOptional(Sequence([\n-\t\t\t\tKeyword(\"FROM\"),\n-\t\t\t\tChoice(0, [\n-\t\t\t\t\tOneOrMore(Expression(\"table-or-subquery\"), \",\"),\n-\t\t\t\t\tSequence([Expression(\"join-clause\")])\n-\t\t\t\t])\n-\t\t\t])),\n-\t\t\tOptional(\n-\t\t\t\tSequence([\n-\t\t\t\t\tKeyword(\"WHERE\"),\n-\t\t\t\t\tExpression()\n-\t\t\t\t])\n-\t\t\t)\n-\t\t]),\n-\t\tSequence([\n-\t\t\tOptional(Sequence([\n-\t\t\t\tKeyword(\"GROUP\"),\n-\t\t\t\tKeyword(\"BY\"),\n-\t\t\t\tOneOrMore(Expression(), \",\"),\n-\t\t\t])),\n-\t\t\tOptional(Sequence([\n-\t\t\t\tKeyword(\"HAVING\"),\n-\t\t\t\tExpression()\n-\t\t\t]))\n-\t\t]),\n-\t\tOptional(\n-\t\t\tSequence([Sequence([\n-\t\t\t\t\tKeyword(\"WINDOW\"),\n-\t\t\t\t\tExpression(\"window-name\"),\n-\t\t\t\t\tKeyword(\"AS\"),\n-\t\t\t\t\tExpression(\"window-definition\")\n-\t\t\t\t])\n-\t\t\t]), \"skip\"),\n-\t\tSequence([\n-\t\t\tOptional(Sequence([\n-\t\t\t\tKeyword(\"ORDER\"),\n-\t\t\t\tKeyword(\"BY\"),\n-\t\t\t\tOneOrMore(Expression(\"ordering-term\"), \",\")\n-\t\t\t]))\n-\t\t]),\n-\t\tOptional(Sequence([\n-\t\t\tKeyword(\"LIMIT\"),\n-\t\t\tExpression(),\n-\t\t\tOptional(Sequence([\n-\t\t\t\tKeyword(\"OFFSET\"),\n-\t\t\t\tExpression()\n-\t\t\t]), \"skip\")\n-\t\t]))\n-\t])]\n-}\n-\n-function GenerateDelete(options = {}) {\n-\treturn Diagram([\n-\t\tStack([\n-\t\t\tOptional(\n-\t\t\t\tSequence([\n-\t\t\t\t\tKeyword(\"WITH\"),\n-\t\t\t\t\tOptional(Keyword(\"RECURSIVE\"), \"skip\"),\n-\t\t\t\t\tOneOrMore(Expression(\"common-table-expr\"), \",\")\n-\t\t\t\t]), \"skip\"),\n-\t\t\tChoice(0, [\n-\t\t\t\tExpandable(\"select-node\", options, \"select-node\", GenerateSelectNode),\n-\t\t\t\tExpandable(\"values-list\", options, \"values\", GenerateValues)\n-\t\t\t])\n-\t\t])\n-\t])\n-}\n-\n-function Initialize(options = {}) {\n-\tdocument.getElementById(\"rrdiagram\").innerHTML = GenerateDelete(options).toString();\n-}\n-\n-function Refresh(node_name, set_node) {\n-\toptions[node_name] = set_node;\n-\tInitialize(options);\n-}\n-\n-options = {}\n-Initialize()\n-\n-\ndiff --git a/grammar/railroad.css b/grammar/railroad.css\ndeleted file mode 100644\nindex e1b8a524cbde..000000000000\n--- a/grammar/railroad.css\n+++ /dev/null\n@@ -1,59 +0,0 @@\n-svg {\n-\tbackground-color: hsl(30,20%,95%);\n-}\n-path {\n-\tstroke-width: 3;\n-\tstroke: black;\n-\tfill: rgba(0,0,0,0);\n-}\n-text {\n-\tfont: bold 14px monospace;\n-\ttext-anchor: middle;\n-\twhite-space: pre;\n-}\n-text.diagram-text {\n-\tfont-size: 12px;\n-}\n-text.diagram-arrow {\n-\tfont-size: 16px;\n-}\n-text.label {\n-\ttext-anchor: start;\n-}\n-text.comment {\n-\tfont: italic 12px monospace;\n-}\n-g.non-terminal text {\n-\t/*font-style: italic;*/\n-}\n-rect {\n-\tstroke-width: 3;\n-\tstroke: black;\n-\tfill: hsl(120,100%,90%);\n-}\n-.expandable, .expanded {\n-\tcursor:pointer;\n-\t-webkit-user-select: none; /* Safari */\n-\t-moz-user-select: none; /* Firefox */\n-\t-ms-user-select: none; /* IE10+/Edge */\n-\tuser-select: none; /* Standard */\n-}\n-rect.expandable, rect.expanded, rect.expression {\n-\tfill:#f6d573;\n-}\n-text.expandable, text.expanded, text.expression {\n-\tfont:14px monospace;\n-\tfont-style:italic;\n-}\n-.non-terminal:hover rect.expandable, .non-terminal:hover rect.expanded {\n-\tfill:#f8d9aa;\n-}\n-path.diagram-text {\n-\tstroke-width: 3;\n-\tstroke: black;\n-\tfill: white;\n-\tcursor: help;\n-}\n-g.diagram-text:hover path.diagram-text {\n-\tfill: #eee;\n-}\ndiff --git a/grammar/railroad.js b/grammar/railroad.js\ndeleted file mode 100644\nindex c6049a034ba6..000000000000\n--- a/grammar/railroad.js\n+++ /dev/null\n@@ -1,1460 +0,0 @@\n-\"use strict\";\n-/*\n-Railroad DiagramNodes\n-by Tab Atkins Jr. (and others)\n-http://xanthir.com\n-http://twitter.com/tabatkins\n-http://github.com/tabatkins/railroad-diagrams\n-\n-This document and all associated files in the github project are licensed under CC0: http://creativecommons.org/publicdomain/zero/1.0/\n-This means you can reuse, remix, or otherwise appropriate this project for your own use WITHOUT RESTRICTION.\n-(The actual legal meaning can be found at the above link.)\n-Don't ask me for permission to use any part of this project, JUST USE IT.\n-I would appreciate attribution, but that is not required by the license.\n-*/\n-\n-/*\n-This file uses a module pattern to avoid leaking names into the global scope.\n-Should be compatible with AMD, CommonJS, and plain ol' browser JS.\n-\n-As well, several configuration constants are passed into the module function at the bottom of this file.\n-At runtime, these constants can be found on the DiagramNode class,\n-and can be changed before creating a DiagramNode.\n-*/\n-\n-(function(options) {\n-\tvar funcs = {};\n-\n-\tfunction subclassOf(baseClass, superClass) {\n-\t\tbaseClass.prototype = Object.create(superClass.prototype);\n-\t\tbaseClass.prototype.$super = superClass.prototype;\n-\t}\n-\n-\tfunction unnull(/* children */) {\n-\t\treturn [].slice.call(arguments).reduce(function(sofar, x) { return sofar !== undefined ? sofar : x; });\n-\t}\n-\n-\tfunction determineGaps(outer, inner) {\n-\t\tvar diff = outer - inner;\n-\t\tswitch(DiagramNode.INTERNAL_ALIGNMENT) {\n-\t\t\tcase 'left': return [0, diff]; break;\n-\t\t\tcase 'right': return [diff, 0]; break;\n-\t\t\tcase 'center':\n-\t\t\tdefault: return [diff/2, diff/2]; break;\n-\t\t}\n-\t}\n-\n-\tfunction wrapString(value) {\n-\t\treturn value instanceof FakeSVG ? value : new Terminal(\"\"+value);\n-\t}\n-\n-\tfunction sum(iter, func) {\n-\t\tif(!func) func = function(x) { return x; };\n-\t\treturn iter.map(func).reduce(function(a,b){return a+b}, 0);\n-\t}\n-\n-\tfunction max(iter, func) {\n-\t\tif(!func) func = function(x) { return x; };\n-\t\treturn Math.max.apply(null, iter.map(func));\n-\t}\n-\n-\tfunction* enumerate(iter) {\n-\t\tvar count = 0;\n-\t\tfor(const x of iter) {\n-\t\t\tyield [count, x];\n-\t\t\tcount++;\n-\t\t}\n-\t}\n-\n-\tvar SVG = funcs.SVG = function SVG(name, attrs, text) {\n-\t\tattrs = attrs || {};\n-\t\ttext = text || '';\n-\t\tvar el = document.createElementNS(\"http://www.w3.org/2000/svg\",name);\n-\t\tfor(var attr in attrs) {\n-\t\t\tif(attr === 'xlink:href')\n-\t\t\t\tel.setAttributeNS(\"http://www.w3.org/1999/xlink\", 'href', attrs[attr]);\n-\t\t\telse\n-\t\t\t\tel.setAttribute(attr, attrs[attr]);\n-\t\t}\n-\t\tel.textContent = text;\n-\t\treturn el;\n-\t}\n-\n-\tvar FakeSVG = funcs.FakeSVG = function FakeSVG(tagName, attrs, text){\n-\t\tif(!(this instanceof FakeSVG)) return new FakeSVG(tagName, attrs, text);\n-\t\tif(text) this.children = text;\n-\t\telse this.children = [];\n-\t\tthis.tagName = tagName;\n-\t\tthis.attrs = unnull(attrs, {});\n-\t\treturn this;\n-\t};\n-\tFakeSVG.prototype.format = function(x, y, width) {\n-\t\t// Virtual\n-\t};\n-\tFakeSVG.prototype.addTo = function(parent) {\n-\t\tif(parent instanceof FakeSVG) {\n-\t\t\tparent.children.push(this);\n-\t\t\treturn this;\n-\t\t} else {\n-\t\t\tvar svg = this.toSVG();\n-\t\t\tparent.appendChild(svg);\n-\t\t\treturn svg;\n-\t\t}\n-\t};\n-\tFakeSVG.prototype.escapeString = function(string) {\n-\t\t// Escape markdown and HTML special characters\n-\t\treturn string.replace(/[*_\\`\\[\\]<&]/g, function(charString) {\n-\t\t\treturn '&#' + charString.charCodeAt(0) + ';';\n-\t\t});\n-\t};\n-\tFakeSVG.prototype.toSVG = function() {\n-\t\tvar el = SVG(this.tagName, this.attrs);\n-\t\tif(typeof this.children == 'string') {\n-\t\t\tel.textContent = this.children;\n-\t\t} else {\n-\t\t\tthis.children.forEach(function(e) {\n-\t\t\t\tel.appendChild(e.toSVG());\n-\t\t\t});\n-\t\t}\n-\t\treturn el;\n-\t};\n-\tFakeSVG.prototype.toString = function() {\n-\t\tvar str = '<' + this.tagName;\n-\t\tvar group = this.tagName == \"g\" || this.tagName == \"svg\";\n-\t\tfor(var attr in this.attrs) {\n-\t\t\tstr += ' ' + attr + '=\"' + (this.attrs[attr]+'').replace(/&/g, '&amp;').replace(/\"/g, '&quot;') + '\"';\n-\t\t}\n-\t\tstr += '>';\n-\t\tif(group) str += \"\\n\";\n-\t\tif(typeof this.children == 'string') {\n-\t\t\tstr += FakeSVG.prototype.escapeString(this.children);\n-\t\t} else {\n-\t\t\tthis.children.forEach(function(e) {\n-\t\t\t\tstr += e;\n-\t\t\t});\n-\t\t}\n-\t\tstr += '</' + this.tagName + '>\\n';\n-\t\treturn str;\n-\t}\n-\tFakeSVG.prototype.walk = function(cb) {\n-\t\tcb(this);\n-\t}\n-\n-\tvar Path = funcs.Path = function Path(x,y) {\n-\t\tif(!(this instanceof Path)) return new Path(x,y);\n-\t\tFakeSVG.call(this, 'path');\n-\t\tthis.attrs.d = \"M\"+x+' '+y;\n-\t}\n-\tsubclassOf(Path, FakeSVG);\n-\tPath.prototype.m = function(x,y) {\n-\t\tthis.attrs.d += 'm'+x+' '+y;\n-\t\treturn this;\n-\t}\n-\tPath.prototype.h = function(val) {\n-\t\tthis.attrs.d += 'h'+val;\n-\t\treturn this;\n-\t}\n-\tPath.prototype.right = function(val) { return this.h(Math.max(0, val)); }\n-\tPath.prototype.left = function(val) { return this.h(-Math.max(0, val)); }\n-\tPath.prototype.v = function(val) {\n-\t\tthis.attrs.d += 'v'+val;\n-\t\treturn this;\n-\t}\n-\tPath.prototype.down = function(val) { return this.v(Math.max(0, val)); }\n-\tPath.prototype.up = function(val) { return this.v(-Math.max(0, val)); }\n-\tPath.prototype.arc = function(sweep){\n-\t\t// 1/4 of a circle\n-\t\tvar x = DiagramNode.ARC_RADIUS;\n-\t\tvar y = DiagramNode.ARC_RADIUS;\n-\t\tif(sweep[0] == 'e' || sweep[1] == 'w') {\n-\t\t\tx *= -1;\n-\t\t}\n-\t\tif(sweep[0] == 's' || sweep[1] == 'n') {\n-\t\t\ty *= -1;\n-\t\t}\n-\t\tif(sweep == 'ne' || sweep == 'es' || sweep == 'sw' || sweep == 'wn') {\n-\t\t\tvar cw = 1;\n-\t\t} else {\n-\t\t\tvar cw = 0;\n-\t\t}\n-\t\tthis.attrs.d += \"a\"+DiagramNode.ARC_RADIUS+\" \"+DiagramNode.ARC_RADIUS+\" 0 0 \"+cw+' '+x+' '+y;\n-\t\treturn this;\n-\t}\n-\tPath.prototype.arc_8 = function(start, dir) {\n-\t\t// 1/8 of a circle\n-\t\tconst arc = DiagramNode.ARC_RADIUS;\n-\t\tconst s2 = 1/Math.sqrt(2) * arc;\n-\t\tconst s2inv = (arc - s2);\n-\t\tlet path = \"a \" + arc + \" \" + arc + \" 0 0 \" + (dir=='cw' ? \"1\" : \"0\") + \" \";\n-\t\tconst sd = start+dir;\n-\t\tconst offset =\n-\t\t\tsd == 'ncw'   ? [s2, s2inv] :\n-\t\t\tsd == 'necw'  ? [s2inv, s2] :\n-\t\t\tsd == 'ecw'   ? [-s2inv, s2] :\n-\t\t\tsd == 'secw'  ? [-s2, s2inv] :\n-\t\t\tsd == 'scw'   ? [-s2, -s2inv] :\n-\t\t\tsd == 'swcw'  ? [-s2inv, -s2] :\n-\t\t\tsd == 'wcw'   ? [s2inv, -s2] :\n-\t\t\tsd == 'nwcw'  ? [s2, -s2inv] :\n-\t\t\tsd == 'nccw'  ? [-s2, s2inv] :\n-\t\t\tsd == 'nwccw' ? [-s2inv, s2] :\n-\t\t\tsd == 'wccw'  ? [s2inv, s2] :\n-\t\t\tsd == 'swccw' ? [s2, s2inv] :\n-\t\t\tsd == 'sccw'  ? [s2, -s2inv] :\n-\t\t\tsd == 'seccw' ? [s2inv, -s2] :\n-\t\t\tsd == 'eccw'  ? [-s2inv, -s2] :\n-\t\t\tsd == 'neccw' ? [-s2, -s2inv] : null\n-\t\t;\n-\t\tpath += offset.join(\" \");\n-\t\tthis.attrs.d += path;\n-\t\treturn this;\n-\t}\n-\tPath.prototype.l = function(x, y) {\n-\t\tthis.attrs.d += 'l'+x+' '+y;\n-\t\treturn this;\n-\t}\n-\tPath.prototype.format = function() {\n-\t\t// All paths in this library start/end horizontally.\n-\t\t// The extra .5 ensures a minor overlap, so there's no seams in bad rasterizers.\n-\t\tthis.attrs.d += 'h.5';\n-\t\treturn this;\n-\t}\n-\n-\n-\tvar DiagramNodeMultiContainer = funcs.DiagramNodeMultiContainer = function DiagramNodeMultiContainer(tagName, items, attrs, text) {\n-\t\tFakeSVG.call(this, tagName, attrs, text);\n-\t\tthis.items = items.map(wrapString);\n-\t}\n-\tsubclassOf(DiagramNodeMultiContainer, FakeSVG);\n-\tDiagramNodeMultiContainer.prototype.walk = function(cb) {\n-\t\tcb(this);\n-\t\tthis.items.forEach(x=>w.walk(cb));\n-\t}\n-\n-\n-\tvar DiagramNode = funcs.DiagramNode = function DiagramNode(items) {\n-\t\tif(!(this instanceof DiagramNode)) return new DiagramNode([].slice.call(arguments));\n-\t\tDiagramNodeMultiContainer.call(this, 'svg', items, {class: DiagramNode.DIAGRAM_CLASS});\n-\t\tif(!(this.items[0] instanceof Start)) {\n-\t\t\tthis.items.unshift(new Start());\n-\t\t}\n-\t\tif(!(this.items[this.items.length-1] instanceof End)) {\n-\t\t\tthis.items.push(new End());\n-\t\t}\n-\t\tthis.up = this.down = this.height = this.width = 0;\n-\t\tfor(var i = 0; i < this.items.length; i++) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tthis.width += item.width + (item.needsSpace?20:0);\n-\t\t\tthis.up = Math.max(this.up, item.up - this.height);\n-\t\t\tthis.height += item.height;\n-\t\t\tthis.down = Math.max(this.down - item.height, item.down);\n-\t\t}\n-\t\tthis.formatted = false;\n-\t}\n-\tsubclassOf(DiagramNode, DiagramNodeMultiContainer);\n-\tfor(var option in options) {\n-\t\tDiagramNode[option] = options[option];\n-\t}\n-\tDiagramNode.prototype.format = function(paddingt, paddingr, paddingb, paddingl) {\n-\t\tpaddingt = unnull(paddingt, 20);\n-\t\tpaddingr = unnull(paddingr, paddingt, 20);\n-\t\tpaddingb = unnull(paddingb, paddingt, 20);\n-\t\tpaddingl = unnull(paddingl, paddingr, 20);\n-\t\tvar x = paddingl;\n-\t\tvar y = paddingt;\n-\t\ty += this.up;\n-\t\tvar g = FakeSVG('g', DiagramNode.STROKE_ODD_PIXEL_LENGTH ? {transform:'translate(.5 .5)'} : {});\n-\t\tfor(var i = 0; i < this.items.length; i++) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tif(item.needsSpace) {\n-\t\t\t\tPath(x,y).h(10).addTo(g);\n-\t\t\t\tx += 10;\n-\t\t\t}\n-\t\t\titem.format(x, y, item.width).addTo(g);\n-\t\t\tx += item.width;\n-\t\t\ty += item.height;\n-\t\t\tif(item.needsSpace) {\n-\t\t\t\tPath(x,y).h(10).addTo(g);\n-\t\t\t\tx += 10;\n-\t\t\t}\n-\t\t}\n-\t\tthis.attrs.width = this.width + paddingl + paddingr;\n-\t\tthis.attrs.height = this.up + this.height + this.down + paddingt + paddingb;\n-\t\tthis.attrs.viewBox = \"0 0 \" + this.attrs.width + \" \" + this.attrs.height;\n-\t\tg.addTo(this);\n-\t\tthis.formatted = true;\n-\t\treturn this;\n-\t}\n-\tDiagramNode.prototype.addTo = function(parent) {\n-\t\tif(!parent) {\n-\t\t\tvar scriptTag = document.getElementsByTagName('script');\n-\t\t\tscriptTag = scriptTag[scriptTag.length - 1];\n-\t\t\tparent = scriptTag.parentNode;\n-\t\t}\n-\t\treturn this.$super.addTo.call(this, parent);\n-\t}\n-\tDiagramNode.prototype.toSVG = function() {\n-\t\tif (!this.formatted) {\n-\t\t\tthis.format();\n-\t\t}\n-\t\treturn this.$super.toSVG.call(this);\n-\t}\n-\tDiagramNode.prototype.toString = function() {\n-\t\tif (!this.formatted) {\n-\t\t\tthis.format();\n-\t\t}\n-\t\treturn this.$super.toString.call(this);\n-\t}\n-\tDiagramNode.DEBUG = false;\n-\n-\tvar ComplexDiagramNode = funcs.ComplexDiagramNode = function ComplexDiagramNode() {\n-\t\tvar diagram = new DiagramNode([].slice.call(arguments));\n-\t\tvar items = diagram.items;\n-\t\titems.shift();\n-\t\titems.pop();\n-\t\titems.unshift(new Start({type:\"complex\"}));\n-\t\titems.push(new End({type:\"complex\"}));\n-\t\tdiagram.items = items;\n-\t\treturn diagram;\n-\t}\n-\n-\tvar SequenceNode = funcs.SequenceNode = function SequenceNode(items) {\n-\t\tif(!(this instanceof SequenceNode)) return new SequenceNode([].slice.call(arguments));\n-\t\tDiagramNodeMultiContainer.call(this, 'g', items);\n-\t\tvar numberOfItems = this.items.length;\n-\t\tthis.needsSpace = true;\n-\t\tthis.up = this.down = this.height = this.width = 0;\n-\t\tfor(var i = 0; i < this.items.length; i++) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tthis.width += item.width + (item.needsSpace?20:0);\n-\t\t\tthis.up = Math.max(this.up, item.up - this.height);\n-\t\t\tthis.height += item.height;\n-\t\t\tthis.down = Math.max(this.down - item.height, item.down);\n-\t\t}\n-\t\tif(this.items[0].needsSpace) this.width -= 10;\n-\t\tif(this.items[this.items.length-1].needsSpace) this.width -= 10;\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"sequence\"\n-\t\t}\n-\t}\n-\tsubclassOf(SequenceNode, DiagramNodeMultiContainer);\n-\tSequenceNode.prototype.format = function(x,y,width) {\n-\t\t// Hook up the two sides if this is narrower than its stated width.\n-\t\tvar gaps = determineGaps(width, this.width);\n-\t\tPath(x,y).h(gaps[0]).addTo(this);\n-\t\tPath(x+gaps[0]+this.width,y+this.height).h(gaps[1]).addTo(this);\n-\t\tx += gaps[0];\n-\n-\t\tfor(var i = 0; i < this.items.length; i++) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tif(item.needsSpace && i > 0) {\n-\t\t\t\tPath(x,y).h(10).addTo(this);\n-\t\t\t\tx += 10;\n-\t\t\t}\n-\t\t\titem.format(x, y, item.width).addTo(this);\n-\t\t\tx += item.width;\n-\t\t\ty += item.height;\n-\t\t\tif(item.needsSpace && i < this.items.length-1) {\n-\t\t\t\tPath(x,y).h(10).addTo(this);\n-\t\t\t\tx += 10;\n-\t\t\t}\n-\t\t}\n-\t\treturn this;\n-\t}\n-\n-\tvar StackNode = funcs.StackNode = function StackNode(items) {\n-\t\tif(!(this instanceof StackNode)) return new StackNode([].slice.call(arguments));\n-\t\tDiagramNodeMultiContainer.call(this, 'g', items);\n-\t\tif( items.length === 0 ) {\n-\t\t\tthrow new RangeError(\"StackNode() must have at least one child.\");\n-\t\t}\n-\t\tthis.width = Math.max.apply(null, this.items.map(function(e) { return e.width + (e.needsSpace?20:0); }));\n-\t\t//if(this.items[0].needsSpace) this.width -= 10;\n-\t\t//if(this.items[this.items.length-1].needsSpace) this.width -= 10;\n-\t\tif(this.items.length > 1){\n-\t\t\tthis.width += DiagramNode.ARC_RADIUS*2;\n-\t\t}\n-\t\tthis.needsSpace = true;\n-\t\tthis.up = this.items[0].up;\n-\t\tthis.down = this.items[this.items.length-1].down;\n-\n-\t\tthis.height = 0;\n-\t\tvar last = this.items.length - 1;\n-\t\tfor(var i = 0; i < this.items.length; i++) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tthis.height += item.height;\n-\t\t\tif(i > 0) {\n-\t\t\t\tthis.height += Math.max(DiagramNode.ARC_RADIUS*2, item.up + DiagramNode.VERTICAL_SEPARATION);\n-\t\t\t}\n-\t\t\tif(i < last) {\n-\t\t\t\tthis.height += Math.max(DiagramNode.ARC_RADIUS*2, item.down + DiagramNode.VERTICAL_SEPARATION);\n-\t\t\t}\n-\t\t}\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"stack\"\n-\t\t}\n-\t}\n-\tsubclassOf(StackNode, DiagramNodeMultiContainer);\n-\tStackNode.prototype.format = function(x,y,width) {\n-\t\tvar gaps = determineGaps(width, this.width);\n-\t\tPath(x,y).h(gaps[0]).addTo(this);\n-\t\tx += gaps[0];\n-\t\tvar xInitial = x;\n-\t\tif(this.items.length > 1) {\n-\t\t\tPath(x, y).h(DiagramNode.ARC_RADIUS).addTo(this);\n-\t\t\tx += DiagramNode.ARC_RADIUS;\n-\t\t}\n-\n-\t\tfor(var i = 0; i < this.items.length; i++) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tvar innerWidth = this.width - (this.items.length>1 ? DiagramNode.ARC_RADIUS*2 : 0);\n-\t\t\titem.format(x, y, innerWidth).addTo(this);\n-\t\t\tx += innerWidth;\n-\t\t\ty += item.height;\n-\n-\t\t\tif(i !== this.items.length-1) {\n-\t\t\t\tPath(x, y)\n-\t\t\t\t\t.arc('ne').down(Math.max(0, item.down + DiagramNode.VERTICAL_SEPARATION - DiagramNode.ARC_RADIUS*2))\n-\t\t\t\t\t.arc('es').left(innerWidth)\n-\t\t\t\t\t.arc('nw').down(Math.max(0, this.items[i+1].up + DiagramNode.VERTICAL_SEPARATION - DiagramNode.ARC_RADIUS*2))\n-\t\t\t\t\t.arc('ws').addTo(this);\n-\t\t\t\ty += Math.max(item.down + DiagramNode.VERTICAL_SEPARATION, DiagramNode.ARC_RADIUS*2) + Math.max(this.items[i+1].up + DiagramNode.VERTICAL_SEPARATION, DiagramNode.ARC_RADIUS*2);\n-\t\t\t\t//y += Math.max(DiagramNode.ARC_RADIUS*4, item.down + DiagramNode.VERTICAL_SEPARATION*2 + this.items[i+1].up)\n-\t\t\t\tx = xInitial+DiagramNode.ARC_RADIUS;\n-\t\t\t}\n-\n-\t\t}\n-\n-\t\tif(this.items.length > 1) {\n-\t\t\tPath(x,y).h(DiagramNode.ARC_RADIUS).addTo(this);\n-\t\t\tx += DiagramNode.ARC_RADIUS;\n-\t\t}\n-\t\tPath(x,y).h(gaps[1]).addTo(this);\n-\n-\t\treturn this;\n-\t}\n-\n-\tvar OptionalSequenceNode = funcs.OptionalSequenceNode = function OptionalSequenceNode(items) {\n-\t\tif(!(this instanceof OptionalSequenceNode)) return new OptionalSequenceNode([].slice.call(arguments));\n-\t\tDiagramNodeMultiContainer.call(this, 'g', items);\n-\t\tif( items.length === 0 ) {\n-\t\t\tthrow new RangeError(\"OptionalSequenceNode() must have at least one child.\");\n-\t\t}\n-\t\tif( items.length === 1 ) {\n-\t\t\treturn new SequenceNode(items);\n-\t\t}\n-\t\tvar arc = DiagramNode.ARC_RADIUS;\n-\t\tthis.needsSpace = false;\n-\t\tthis.width = 0;\n-\t\tthis.up = 0;\n-\t\tthis.height = sum(this.items, function(x){return x.height});\n-\t\tthis.down = this.items[0].down;\n-\t\tvar heightSoFar = 0;\n-\t\tfor(var i = 0; i < this.items.length; i++) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tthis.up = Math.max(this.up, Math.max(arc*2, item.up + DiagramNode.VERTICAL_SEPARATION) - heightSoFar);\n-\t\t\theightSoFar += item.height;\n-\t\t\tif(i > 0) {\n-\t\t\t\tthis.down = Math.max(this.height + this.down, heightSoFar + Math.max(arc*2, item.down + DiagramNode.VERTICAL_SEPARATION)) - this.height;\n-\t\t\t}\n-\t\t\tvar itemWidth = (item.needsSpace?10:0) + item.width;\n-\t\t\tif(i == 0) {\n-\t\t\t\tthis.width += arc + Math.max(itemWidth, arc);\n-\t\t\t} else {\n-\t\t\t\tthis.width += arc*2 + Math.max(itemWidth, arc) + arc;\n-\t\t\t}\n-\t\t}\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"optseq\"\n-\t\t}\n-\t}\n-\tsubclassOf(OptionalSequenceNode, DiagramNodeMultiContainer);\n-\tOptionalSequenceNode.prototype.format = function(x, y, width) {\n-\t\tvar arc = DiagramNode.ARC_RADIUS;\n-\t\tvar gaps = determineGaps(width, this.width);\n-\t\tPath(x, y).right(gaps[0]).addTo(this);\n-\t\tPath(x + gaps[0] + this.width, y + this.height).right(gaps[1]).addTo(this);\n-\t\tx += gaps[0]\n-\t\tvar upperLineY = y - this.up;\n-\t\tvar last = this.items.length - 1;\n-\t\tfor(var i = 0; i < this.items.length; i++) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tvar itemSpace = (item.needsSpace?10:0);\n-\t\t\tvar itemWidth = item.width + itemSpace;\n-\t\t\tif(i == 0) {\n-\t\t\t\t// Upper skip\n-\t\t\t\tPath(x,y)\n-\t\t\t\t\t.arc('se')\n-\t\t\t\t\t.up(y - upperLineY - arc*2)\n-\t\t\t\t\t.arc('wn')\n-\t\t\t\t\t.right(itemWidth - arc)\n-\t\t\t\t\t.arc('ne')\n-\t\t\t\t\t.down(y + item.height - upperLineY - arc*2)\n-\t\t\t\t\t.arc('ws')\n-\t\t\t\t\t.addTo(this);\n-\t\t\t\t// Straight line\n-\t\t\t\tPath(x, y)\n-\t\t\t\t\t.right(itemSpace + arc)\n-\t\t\t\t\t.addTo(this);\n-\t\t\t\titem.format(x + itemSpace + arc, y, item.width).addTo(this);\n-\t\t\t\tx += itemWidth + arc;\n-\t\t\t\ty += item.height;\n-\t\t\t\t// x ends on the far side of the first element,\n-\t\t\t\t// where the next element's skip needs to begin\n-\t\t\t} else if(i < last) {\n-\t\t\t\t// Upper skip\n-\t\t\t\tPath(x, upperLineY)\n-\t\t\t\t\t.right(arc*2 + Math.max(itemWidth, arc) + arc)\n-\t\t\t\t\t.arc('ne')\n-\t\t\t\t\t.down(y - upperLineY + item.height - arc*2)\n-\t\t\t\t\t.arc('ws')\n-\t\t\t\t\t.addTo(this);\n-\t\t\t\t// Straight line\n-\t\t\t\tPath(x,y)\n-\t\t\t\t\t.right(arc*2)\n-\t\t\t\t\t.addTo(this);\n-\t\t\t\titem.format(x + arc*2, y, item.width).addTo(this);\n-\t\t\t\tPath(x + item.width + arc*2, y + item.height)\n-\t\t\t\t\t.right(itemSpace + arc)\n-\t\t\t\t\t.addTo(this);\n-\t\t\t\t// Lower skip\n-\t\t\t\tPath(x,y)\n-\t\t\t\t\t.arc('ne')\n-\t\t\t\t\t.down(item.height + Math.max(item.down + DiagramNode.VERTICAL_SEPARATION, arc*2) - arc*2)\n-\t\t\t\t\t.arc('ws')\n-\t\t\t\t\t.right(itemWidth - arc)\n-\t\t\t\t\t.arc('se')\n-\t\t\t\t\t.up(item.down + DiagramNode.VERTICAL_SEPARATION - arc*2)\n-\t\t\t\t\t.arc('wn')\n-\t\t\t\t\t.addTo(this);\n-\t\t\t\tx += arc*2 + Math.max(itemWidth, arc) + arc;\n-\t\t\t\ty += item.height;\n-\t\t\t} else {\n-\t\t\t\t// Straight line\n-\t\t\t\tPath(x, y)\n-\t\t\t\t\t.right(arc*2)\n-\t\t\t\t\t.addTo(this);\n-\t\t\t\titem.format(x + arc*2, y, item.width).addTo(this);\n-\t\t\t\tPath(x + arc*2 + item.width, y + item.height)\n-\t\t\t\t\t.right(itemSpace + arc)\n-\t\t\t\t\t.addTo(this);\n-\t\t\t\t// Lower skip\n-\t\t\t\tPath(x,y)\n-\t\t\t\t\t.arc('ne')\n-\t\t\t\t\t.down(item.height + Math.max(item.down + DiagramNode.VERTICAL_SEPARATION, arc*2) - arc*2)\n-\t\t\t\t\t.arc('ws')\n-\t\t\t\t\t.right(itemWidth - arc)\n-\t\t\t\t\t.arc('se')\n-\t\t\t\t\t.up(item.down + DiagramNode.VERTICAL_SEPARATION - arc*2)\n-\t\t\t\t\t.arc('wn')\n-\t\t\t\t\t.addTo(this);\n-\t\t\t}\n-\t\t}\n-\t\treturn this;\n-\t}\n-\n-\tvar AlternatingSequenceNode = funcs.AlternatingSequenceNode = function AlternatingSequenceNode(items) {\n-\t\tif(!(this instanceof AlternatingSequenceNode)) return new AlternatingSequenceNode([].slice.call(arguments));\n-\t\tDiagramNodeMultiContainer.call(this, 'g', items);\n-\t\tif( items.length === 1 ) {\n-\t\t\treturn new SequenceNode(items);\n-\t\t}\n-\t\tif( items.length !== 2 ) {\n-\t\t\tthrow new RangeError(\"AlternatingSequenceNode() must have one or two children.\");\n-\t\t}\n-\t\tthis.needsSpace = false;\n-\n-\t\tconst arc = DiagramNode.ARC_RADIUS;\n-\t\tconst vert = DiagramNode.VERTICAL_SEPARATION;\n-\t\tconst max = Math.max;\n-\t\tconst first = this.items[0];\n-\t\tconst second = this.items[1];\n-\n-\t\tconst arcX = 1 / Math.sqrt(2) * arc * 2;\n-\t\tconst arcY = (1 - 1 / Math.sqrt(2)) * arc * 2;\n-\t\tconst crossY = Math.max(arc, DiagramNode.VERTICAL_SEPARATION);\n-\t\tconst crossX = (crossY - arcY) + arcX;\n-\n-\t\tconst firstOut = max(arc + arc, crossY/2 + arc + arc, crossY/2 + vert + first.down);\n-\t\tthis.up = firstOut + first.height + first.up;\n-\n-\t\tconst secondIn = max(arc + arc, crossY/2 + arc + arc, crossY/2 + vert + second.up);\n-\t\tthis.down = secondIn + second.height + second.down;\n-\n-\t\tthis.height = 0;\n-\n-\t\tconst firstWidth = 2*(first.needsSpace?10:0) + first.width;\n-\t\tconst secondWidth = 2*(second.needsSpace?10:0) + second.width;\n-\t\tthis.width = 2*arc + max(firstWidth, crossX, secondWidth) + 2*arc;\n-\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"altseq\"\n-\t\t}\n-\t}\n-\tsubclassOf(AlternatingSequenceNode, DiagramNodeMultiContainer);\n-\tAlternatingSequenceNode.prototype.format = function(x, y, width) {\n-\t\tconst arc = DiagramNode.ARC_RADIUS;\n-\t\tconst gaps = determineGaps(width, this.width);\n-\t\tPath(x,y).right(gaps[0]).addTo(this);\n-\t\tconsole.log(gaps);\n-\t\tx += gaps[0];\n-\t\tPath(x+this.width, y).right(gaps[1]).addTo(this);\n-\t\t// bounding box\n-\t\t//Path(x+gaps[0], y).up(this.up).right(this.width).down(this.up+this.down).left(this.width).up(this.down).addTo(this);\n-\t\tconst first = this.items[0];\n-\t\tconst second = this.items[1];\n-\n-\t\t// top\n-\t\tconst firstIn = this.up - first.up;\n-\t\tconst firstOut = this.up - first.up - first.height;\n-\t\tPath(x,y).arc('se').up(firstIn-2*arc).arc('wn').addTo(this);\n-\t\tfirst.format(x + 2*arc, y - firstIn, this.width - 4*arc).addTo(this);\n-\t\tPath(x + this.width - 2*arc, y - firstOut).arc('ne').down(firstOut - 2*arc).arc('ws').addTo(this);\n-\n-\t\t// bottom\n-\t\tconst secondIn = this.down - second.down - second.height;\n-\t\tconst secondOut = this.down - second.down;\n-\t\tPath(x,y).arc('ne').down(secondIn - 2*arc).arc('ws').addTo(this);\n-\t\tsecond.format(x + 2*arc, y + secondIn, this.width - 4*arc).addTo(this);\n-\t\tPath(x + this.width - 2*arc, y + secondOut).arc('se').up(secondOut - 2*arc).arc('wn').addTo(this);\n-\n-\t\t// crossover\n-\t\tconst arcX = 1 / Math.sqrt(2) * arc * 2;\n-\t\tconst arcY = (1 - 1 / Math.sqrt(2)) * arc * 2;\n-\t\tconst crossY = Math.max(arc, DiagramNode.VERTICAL_SEPARATION);\n-\t\tconst crossX = (crossY - arcY) + arcX;\n-\t\tconst crossBar = (this.width - 4*arc - crossX)/2;\n-\t\tPath(x+arc, y - crossY/2 - arc).arc('ws').right(crossBar)\n-\t\t\t.arc_8('n', 'cw').l(crossX - arcX, crossY - arcY).arc_8('sw', 'ccw')\n-\t\t\t.right(crossBar).arc('ne').addTo(this);\n-\t\tPath(x+arc, y + crossY/2 + arc).arc('wn').right(crossBar)\n-\t\t\t.arc_8('s', 'ccw').l(crossX - arcX, -(crossY - arcY)).arc_8('nw', 'cw')\n-\t\t\t.right(crossBar).arc('se').addTo(this);\n-\n-\t\treturn this;\n-\t}\n-\n-\tvar ChoiceNode = funcs.ChoiceNode = function ChoiceNode(normal, items) {\n-\t\tif(!(this instanceof ChoiceNode)) return new ChoiceNode(normal, [].slice.call(arguments,1));\n-\t\tDiagramNodeMultiContainer.call(this, 'g', items);\n-\t\tif( typeof normal !== \"number\" || normal !== Math.floor(normal) ) {\n-\t\t\tthrow new TypeError(\"The first argument of ChoiceNode() must be an integer.\");\n-\t\t} else if(normal < 0 || normal >= items.length) {\n-\t\t\tthrow new RangeError(\"The first argument of ChoiceNode() must be an index for one of the items.\");\n-\t\t} else {\n-\t\t\tthis.normal = normal;\n-\t\t}\n-\t\tvar first = 0;\n-\t\tvar last = items.length - 1;\n-\t\tthis.width = Math.max.apply(null, this.items.map(function(el){return el.width})) + DiagramNode.ARC_RADIUS*4;\n-\t\tthis.height = this.items[normal].height;\n-\t\tthis.up = this.items[first].up;\n-\t\tfor(var i = first; i < normal; i++) {\n-\t\t\tif(i == normal-1) var arcs = DiagramNode.ARC_RADIUS*2;\n-\t\t\telse var arcs = DiagramNode.ARC_RADIUS;\n-\t\t\tthis.up += Math.max(arcs, this.items[i].height + this.items[i].down + DiagramNode.VERTICAL_SEPARATION + this.items[i+1].up);\n-\t\t}\n-\t\tthis.down = this.items[last].down;\n-\t\tfor(var i = normal+1; i <= last; i++) {\n-\t\t\tif(i == normal+1) var arcs = DiagramNode.ARC_RADIUS*2;\n-\t\t\telse var arcs = DiagramNode.ARC_RADIUS;\n-\t\t\tthis.down += Math.max(arcs, this.items[i-1].height + this.items[i-1].down + DiagramNode.VERTICAL_SEPARATION + this.items[i].up);\n-\t\t}\n-\t\tthis.down -= this.items[normal].height; // already counted in ChoiceNode.height\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"choice\"\n-\t\t}\n-\t}\n-\tsubclassOf(ChoiceNode, DiagramNodeMultiContainer);\n-\tChoiceNode.prototype.format = function(x,y,width) {\n-\t\t// Hook up the two sides if this is narrower than its stated width.\n-\t\tvar gaps = determineGaps(width, this.width);\n-\t\tPath(x,y).h(gaps[0]).addTo(this);\n-\t\tPath(x+gaps[0]+this.width,y+this.height).h(gaps[1]).addTo(this);\n-\t\tx += gaps[0];\n-\n-\t\tvar last = this.items.length -1;\n-\t\tvar innerWidth = this.width - DiagramNode.ARC_RADIUS*4;\n-\n-\t\t// Do the elements that curve above\n-\t\tfor(var i = this.normal - 1; i >= 0; i--) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tif( i == this.normal - 1 ) {\n-\t\t\t\tvar distanceFromY = Math.max(DiagramNode.ARC_RADIUS*2, this.items[this.normal].up + DiagramNode.VERTICAL_SEPARATION + item.down + item.height);\n-\t\t\t}\n-\t\t\tPath(x,y)\n-\t\t\t\t.arc('se')\n-\t\t\t\t.up(distanceFromY - DiagramNode.ARC_RADIUS*2)\n-\t\t\t\t.arc('wn').addTo(this);\n-\t\t\titem.format(x+DiagramNode.ARC_RADIUS*2,y - distanceFromY,innerWidth).addTo(this);\n-\t\t\tPath(x+DiagramNode.ARC_RADIUS*2+innerWidth, y-distanceFromY+item.height)\n-\t\t\t\t.arc('ne')\n-\t\t\t\t.down(distanceFromY - item.height + this.height - DiagramNode.ARC_RADIUS*2)\n-\t\t\t\t.arc('ws').addTo(this);\n-\t\t\tdistanceFromY += Math.max(DiagramNode.ARC_RADIUS, item.up + DiagramNode.VERTICAL_SEPARATION + (i == 0 ? 0 : this.items[i-1].down+this.items[i-1].height));\n-\t\t}\n-\n-\t\t// Do the straight-line path.\n-\t\tPath(x,y).right(DiagramNode.ARC_RADIUS*2).addTo(this);\n-\t\tthis.items[this.normal].format(x+DiagramNode.ARC_RADIUS*2, y, innerWidth).addTo(this);\n-\t\tPath(x+DiagramNode.ARC_RADIUS*2+innerWidth, y+this.height).right(DiagramNode.ARC_RADIUS*2).addTo(this);\n-\n-\t\t// Do the elements that curve below\n-\t\tfor(var i = this.normal+1; i <= last; i++) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tif( i == this.normal + 1 ) {\n-\t\t\t\tvar distanceFromY = Math.max(DiagramNode.ARC_RADIUS*2, this.height + this.items[this.normal].down + DiagramNode.VERTICAL_SEPARATION + item.up);\n-\t\t\t}\n-\t\t\tPath(x,y)\n-\t\t\t\t.arc('ne')\n-\t\t\t\t.down(distanceFromY - DiagramNode.ARC_RADIUS*2)\n-\t\t\t\t.arc('ws').addTo(this);\n-\t\t\titem.format(x+DiagramNode.ARC_RADIUS*2, y+distanceFromY, innerWidth).addTo(this);\n-\t\t\tPath(x+DiagramNode.ARC_RADIUS*2+innerWidth, y+distanceFromY+item.height)\n-\t\t\t\t.arc('se')\n-\t\t\t\t.up(distanceFromY - DiagramNode.ARC_RADIUS*2 + item.height - this.height)\n-\t\t\t\t.arc('wn').addTo(this);\n-\t\t\tdistanceFromY += Math.max(DiagramNode.ARC_RADIUS, item.height + item.down + DiagramNode.VERTICAL_SEPARATION + (i == last ? 0 : this.items[i+1].up));\n-\t\t}\n-\n-\t\treturn this;\n-\t}\n-\n-\n-\tvar HorizontalChoiceNode = funcs.HorizontalChoiceNode = function HorizontalChoiceNode(items) {\n-\t\tif(!(this instanceof HorizontalChoiceNode)) return new HorizontalChoiceNode([].slice.call(arguments));\n-\t\tif( items.length === 0 ) {\n-\t\t\tthrow new RangeError(\"HorizontalChoiceNode() must have at least one child.\");\n-\t\t}\n-\t\tif( items.length === 1) {\n-\t\t\treturn new SequenceNode(items);\n-\t\t}\n-\t\tDiagramNodeMultiContainer.call(this, 'g', items);\n-\n-\t\tconst allButLast = this.items.slice(0, -1);\n-\t\tconst middles = this.items.slice(1, -1);\n-\t\tconst first = this.items[0];\n-\t\tconst last = this.items[this.items.length - 1];\n-\t\tthis.needsSpace = false;\n-\n-\t\tthis.width = DiagramNode.ARC_RADIUS; // starting track\n-\t\tthis.width += DiagramNode.ARC_RADIUS*2 * (this.items.length-1); // inbetween tracks\n-\t\tthis.width += sum(this.items, x=>x.width + (x.needsSpace?20:0)); // items\n-\t\tthis.width += (last.height > 0 ? DiagramNode.ARC_RADIUS : 0); // needs space to curve up\n-\t\tthis.width += DiagramNode.ARC_RADIUS; //ending track\n-\n-\t\t// Always exits at entrance height\n-\t\tthis.height = 0;\n-\n-\t\t// All but the last have a track running above them\n-\t\tthis._upperTrack = Math.max(\n-\t\t\tDiagramNode.ARC_RADIUS*2,\n-\t\t\tDiagramNode.VERTICAL_SEPARATION,\n-\t\t\tmax(allButLast, x=>x.up) + DiagramNode.VERTICAL_SEPARATION\n-\t\t);\n-\t\tthis.up = Math.max(this._upperTrack, last.up);\n-\n-\t\t// All but the first have a track running below them\n-\t\t// Last either straight-lines or curves up, so has different calculation\n-\t\tthis._lowerTrack = Math.max(\n-\t\t\tDiagramNode.VERTICAL_SEPARATION,\n-\t\t\tmax(middles, x=>x.height+Math.max(x.down+DiagramNode.VERTICAL_SEPARATION, DiagramNode.ARC_RADIUS*2)),\n-\t\t\tlast.height + last.down + DiagramNode.VERTICAL_SEPARATION\n-\t\t);\n-\t\tif(first.height < this._lowerTrack) {\n-\t\t\t// Make sure there's at least 2*AR room between first exit and lower track\n-\t\t\tthis._lowerTrack = Math.max(this._lowerTrack, first.height + DiagramNode.ARC_RADIUS*2);\n-\t\t}\n-\t\tthis.down = Math.max(this._lowerTrack, first.height + first.down);\n-\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"horizontalchoice\"\n-\t\t}\n-\t}\n-\tsubclassOf(HorizontalChoiceNode, DiagramNodeMultiContainer);\n-\tHorizontalChoiceNode.prototype.format = function(x,y,width) {\n-\t\t// Hook up the two sides if this is narrower than its stated width.\n-\t\tvar gaps = determineGaps(width, this.width);\n-\t\tnew Path(x,y).h(gaps[0]).addTo(this);\n-\t\tnew Path(x+gaps[0]+this.width,y+this.height).h(gaps[1]).addTo(this);\n-\t\tx += gaps[0];\n-\n-\t\tconst first = this.items[0];\n-\t\tconst last = this.items[this.items.length-1];\n-\t\tconst allButFirst = this.items.slice(1);\n-\t\tconst allButLast = this.items.slice(0, -1);\n-\n-\t\t// upper track\n-\t\tvar upperSpan = (sum(allButLast, x=>x.width+(x.needsSpace?20:0))\n-\t\t\t+ (this.items.length - 2) * DiagramNode.ARC_RADIUS*2\n-\t\t\t- DiagramNode.ARC_RADIUS\n-\t\t);\n-\t\tnew Path(x,y)\n-\t\t\t.arc('se')\n-\t\t\t.v(-(this._upperTrack - DiagramNode.ARC_RADIUS*2))\n-\t\t\t.arc('wn')\n-\t\t\t.h(upperSpan)\n-\t\t\t.addTo(this);\n-\n-\t\t// lower track\n-\t\tvar lowerSpan = (sum(allButFirst, x=>x.width+(x.needsSpace?20:0))\n-\t\t\t+ (this.items.length - 2) * DiagramNode.ARC_RADIUS*2\n-\t\t\t+ (last.height > 0 ? DiagramNode.ARC_RADIUS : 0)\n-\t\t\t- DiagramNode.ARC_RADIUS\n-\t\t);\n-\t\tvar lowerStart = x + DiagramNode.ARC_RADIUS + first.width+(first.needsSpace?20:0) + DiagramNode.ARC_RADIUS*2;\n-\t\tnew Path(lowerStart, y+this._lowerTrack)\n-\t\t\t.h(lowerSpan)\n-\t\t\t.arc('se')\n-\t\t\t.v(-(this._lowerTrack - DiagramNode.ARC_RADIUS*2))\n-\t\t\t.arc('wn')\n-\t\t\t.addTo(this);\n-\n-\t\t// Items\n-\t\tfor(const [i, item] of enumerate(this.items)) {\n-\t\t\t// input track\n-\t\t\tif(i === 0) {\n-\t\t\t\tnew Path(x,y)\n-\t\t\t\t\t.h(DiagramNode.ARC_RADIUS)\n-\t\t\t\t\t.addTo(this);\n-\t\t\t\tx += DiagramNode.ARC_RADIUS;\n-\t\t\t} else {\n-\t\t\t\tnew Path(x, y - this._upperTrack)\n-\t\t\t\t\t.arc('ne')\n-\t\t\t\t\t.v(this._upperTrack - DiagramNode.ARC_RADIUS*2)\n-\t\t\t\t\t.arc('ws')\n-\t\t\t\t\t.addTo(this);\n-\t\t\t\tx += DiagramNode.ARC_RADIUS*2;\n-\t\t\t}\n-\n-\t\t\t// item\n-\t\t\tvar itemWidth = item.width + (item.needsSpace?20:0);\n-\t\t\titem.format(x, y, itemWidth).addTo(this);\n-\t\t\tx += itemWidth;\n-\n-\t\t\t// output track\n-\t\t\tif(i === this.items.length-1) {\n-\t\t\t\tif(item.height === 0) {\n-\t\t\t\t\tnew Path(x,y)\n-\t\t\t\t\t\t.h(DiagramNode.ARC_RADIUS)\n-\t\t\t\t\t\t.addTo(this);\n-\t\t\t\t} else {\n-\t\t\t\t\tnew Path(x,y+item.height)\n-\t\t\t\t\t.arc('se')\n-\t\t\t\t\t.addTo(this);\n-\t\t\t\t}\n-\t\t\t} else if(i === 0 && item.height > this._lowerTrack) {\n-\t\t\t\t// Needs to arc up to meet the lower track, not down.\n-\t\t\t\tif(item.height - this._lowerTrack >= DiagramNode.ARC_RADIUS*2) {\n-\t\t\t\t\tnew Path(x, y+item.height)\n-\t\t\t\t\t\t.arc('se')\n-\t\t\t\t\t\t.v(this._lowerTrack - item.height + DiagramNode.ARC_RADIUS*2)\n-\t\t\t\t\t\t.arc('wn')\n-\t\t\t\t\t\t.addTo(this);\n-\t\t\t\t} else {\n-\t\t\t\t\t// Not enough space to fit two arcs\n-\t\t\t\t\t// so just bail and draw a straight line for now.\n-\t\t\t\t\tnew Path(x, y+item.height)\n-\t\t\t\t\t\t.l(DiagramNode.ARC_RADIUS*2, this._lowerTrack - item.height)\n-\t\t\t\t\t\t.addTo(this);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tnew Path(x, y+item.height)\n-\t\t\t\t\t.arc('ne')\n-\t\t\t\t\t.v(this._lowerTrack - item.height - DiagramNode.ARC_RADIUS*2)\n-\t\t\t\t\t.arc('ws')\n-\t\t\t\t\t.addTo(this);\n-\t\t\t}\n-\t\t}\n-\t\treturn this;\n-\t}\n-\n-\n-\tvar MultipleChoiceNode = funcs.MultipleChoiceNode = function MultipleChoiceNode(normal, type, items) {\n-\t\tif(!(this instanceof MultipleChoiceNode)) return new MultipleChoiceNode(normal, type, [].slice.call(arguments,2));\n-\t\tDiagramNodeMultiContainer.call(this, 'g', items);\n-\t\tif( typeof normal !== \"number\" || normal !== Math.floor(normal) ) {\n-\t\t\tthrow new TypeError(\"The first argument of MultipleChoiceNode() must be an integer.\");\n-\t\t} else if(normal < 0 || normal >= items.length) {\n-\t\t\tthrow new RangeError(\"The first argument of MultipleChoiceNode() must be an index for one of the items.\");\n-\t\t} else {\n-\t\t\tthis.normal = normal;\n-\t\t}\n-\t\tif( type != \"any\" && type != \"all\" ) {\n-\t\t\tthrow new SyntaxError(\"The second argument of MultipleChoiceNode must be 'any' or 'all'.\");\n-\t\t} else {\n-\t\t\tthis.type = type;\n-\t\t}\n-\t\tthis.needsSpace = true;\n-\t\tthis.innerWidth = max(this.items, function(x){return x.width});\n-\t\tthis.width = 30 + DiagramNode.ARC_RADIUS + this.innerWidth + DiagramNode.ARC_RADIUS + 20;\n-\t\tthis.up = this.items[0].up;\n-\t\tthis.down = this.items[this.items.length-1].down;\n-\t\tthis.height = this.items[normal].height;\n-\t\tfor(var i = 0; i < this.items.length; i++) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tif(i == normal - 1 || i == normal + 1) var minimum = 10 + DiagramNode.ARC_RADIUS;\n-\t\t\telse var minimum = DiagramNode.ARC_RADIUS;\n-\t\t\tif(i < normal) {\n-\t\t\t\tthis.up += Math.max(minimum, item.height + item.down + DiagramNode.VERTICAL_SEPARATION + this.items[i+1].up);\n-\t\t\t} else if(i > normal) {\n-\t\t\t\tthis.down += Math.max(minimum, item.up + DiagramNode.VERTICAL_SEPARATION + this.items[i-1].down + this.items[i-1].height);\n-\t\t\t}\n-\t\t}\n-\t\tthis.down -= this.items[normal].height; // already counted in this.height\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"multiplechoice\"\n-\t\t}\n-\t}\n-\tsubclassOf(MultipleChoiceNode, DiagramNodeMultiContainer);\n-\tMultipleChoiceNode.prototype.format = function(x, y, width) {\n-\t\tvar gaps = determineGaps(width, this.width);\n-\t\tPath(x, y).right(gaps[0]).addTo(this);\n-\t\tPath(x + gaps[0] + this.width, y + this.height).right(gaps[1]).addTo(this);\n-\t\tx += gaps[0];\n-\n-\t\tvar normal = this.items[this.normal];\n-\n-\t\t// Do the elements that curve above\n-\t\tfor(var i = this.normal - 1; i >= 0; i--) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tif( i == this.normal - 1 ) {\n-\t\t\t\tvar distanceFromY = Math.max(10 + DiagramNode.ARC_RADIUS, normal.up + DiagramNode.VERTICAL_SEPARATION + item.down + item.height);\n-\t\t\t}\n-\t\t\tPath(x + 30,y)\n-\t\t\t\t.up(distanceFromY - DiagramNode.ARC_RADIUS)\n-\t\t\t\t.arc('wn').addTo(this);\n-\t\t\titem.format(x + 30 + DiagramNode.ARC_RADIUS, y - distanceFromY, this.innerWidth).addTo(this);\n-\t\t\tPath(x + 30 + DiagramNode.ARC_RADIUS + this.innerWidth, y - distanceFromY + item.height)\n-\t\t\t\t.arc('ne')\n-\t\t\t\t.down(distanceFromY - item.height + this.height - DiagramNode.ARC_RADIUS - 10)\n-\t\t\t\t.addTo(this);\n-\t\t\tif(i != 0) {\n-\t\t\t\tdistanceFromY += Math.max(DiagramNode.ARC_RADIUS, item.up + DiagramNode.VERTICAL_SEPARATION + this.items[i-1].down + this.items[i-1].height);\n-\t\t\t}\n-\t\t}\n-\n-\t\tPath(x + 30, y).right(DiagramNode.ARC_RADIUS).addTo(this);\n-\t\tnormal.format(x + 30 + DiagramNode.ARC_RADIUS, y, this.innerWidth).addTo(this);\n-\t\tPath(x + 30 + DiagramNode.ARC_RADIUS + this.innerWidth, y + this.height).right(DiagramNode.ARC_RADIUS).addTo(this);\n-\n-\t\tfor(var i = this.normal+1; i < this.items.length; i++) {\n-\t\t\tvar item = this.items[i];\n-\t\t\tif(i == this.normal + 1) {\n-\t\t\t\tvar distanceFromY = Math.max(10+DiagramNode.ARC_RADIUS, normal.height + normal.down + DiagramNode.VERTICAL_SEPARATION + item.up);\n-\t\t\t}\n-\t\t\tPath(x + 30, y)\n-\t\t\t\t.down(distanceFromY - DiagramNode.ARC_RADIUS)\n-\t\t\t\t.arc('ws')\n-\t\t\t\t.addTo(this);\n-\t\t\titem.format(x + 30 + DiagramNode.ARC_RADIUS, y + distanceFromY, this.innerWidth).addTo(this)\n-\t\t\tPath(x + 30 + DiagramNode.ARC_RADIUS + this.innerWidth, y + distanceFromY + item.height)\n-\t\t\t\t.arc('se')\n-\t\t\t\t.up(distanceFromY - DiagramNode.ARC_RADIUS + item.height - normal.height)\n-\t\t\t\t.addTo(this);\n-\t\t\tif(i != this.items.length - 1) {\n-\t\t\t\tdistanceFromY += Math.max(DiagramNode.ARC_RADIUS, item.height + item.down + DiagramNode.VERTICAL_SEPARATION + this.items[i+1].up);\n-\t\t\t}\n-\t\t}\n-\t\tvar text = FakeSVG('g', {\"class\": \"diagram-text\"}).addTo(this)\n-\t\tFakeSVG('title', {}, (this.type==\"any\"?\"take one or more branches, once each, in any order\":\"take all branches, once each, in any order\")).addTo(text)\n-\t\tFakeSVG('path', {\n-\t\t\t\"d\": \"M \"+(x+30)+\" \"+(y-10)+\" h -26 a 4 4 0 0 0 -4 4 v 12 a 4 4 0 0 0 4 4 h 26 z\",\n-\t\t\t\"class\": \"diagram-text\"\n-\t\t\t}).addTo(text)\n-\t\tFakeSVG('text', {\n-\t\t\t\"x\": x + 15,\n-\t\t\t\"y\": y + 4,\n-\t\t\t\"class\": \"diagram-text\"\n-\t\t\t}, (this.type==\"any\"?\"1+\":\"all\")).addTo(text)\n-\t\tFakeSVG('path', {\n-\t\t\t\"d\": \"M \"+(x+this.width-20)+\" \"+(y-10)+\" h 16 a 4 4 0 0 1 4 4 v 12 a 4 4 0 0 1 -4 4 h -16 z\",\n-\t\t\t\"class\": \"diagram-text\"\n-\t\t\t}).addTo(text)\n-\t\tFakeSVG('path', {\n-\t\t\t\"d\": \"M \"+(x+this.width-13)+\" \"+(y-2)+\" a 4 4 0 1 0 6 -1 m 2.75 -1 h -4 v 4 m 0 -3 h 2\",\n-\t\t\t\"style\": \"stroke-width: 1.75\"\n-\t\t}).addTo(text)\n-\t\treturn this;\n-\t};\n-\n-\tvar OptionalNode = funcs.OptionalNode = function OptionalNode(item, skip) {\n-\t\tif( skip === undefined )\n-\t\t\treturn ChoiceNode(1, Skip(), item);\n-\t\telse if ( skip === \"skip\" )\n-\t\t\treturn ChoiceNode(0, Skip(), item);\n-\t\telse\n-\t\t\tthrow \"Unknown value for OptionalNode()'s 'skip' argument.\";\n-\t}\n-\n-\tvar OneOrMoreNode = funcs.OneOrMoreNode = function OneOrMoreNode(item, rep) {\n-\t\tif(!(this instanceof OneOrMoreNode)) return new OneOrMoreNode(item, rep);\n-\t\tFakeSVG.call(this, 'g');\n-\t\trep = rep || (new Skip);\n-\t\tthis.item = wrapString(item);\n-\t\tthis.rep = wrapString(rep);\n-\t\tthis.width = Math.max(this.item.width, this.rep.width) + DiagramNode.ARC_RADIUS*2;\n-\t\tthis.height = this.item.height;\n-\t\tthis.up = this.item.up;\n-\t\tthis.down = Math.max(DiagramNode.ARC_RADIUS*2, this.item.down + DiagramNode.VERTICAL_SEPARATION + this.rep.up + this.rep.height + this.rep.down);\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"oneormore\"\n-\t\t}\n-\t}\n-\tsubclassOf(OneOrMoreNode, FakeSVG);\n-\tOneOrMoreNode.prototype.needsSpace = true;\n-\tOneOrMoreNode.prototype.format = function(x,y,width) {\n-\t\t// Hook up the two sides if this is narrower than its stated width.\n-\t\tvar gaps = determineGaps(width, this.width);\n-\t\tPath(x,y).h(gaps[0]).addTo(this);\n-\t\tPath(x+gaps[0]+this.width,y+this.height).h(gaps[1]).addTo(this);\n-\t\tx += gaps[0];\n-\n-\t\t// Draw item\n-\t\tPath(x,y).right(DiagramNode.ARC_RADIUS).addTo(this);\n-\t\tthis.item.format(x+DiagramNode.ARC_RADIUS,y,this.width-DiagramNode.ARC_RADIUS*2).addTo(this);\n-\t\tPath(x+this.width-DiagramNode.ARC_RADIUS,y+this.height).right(DiagramNode.ARC_RADIUS).addTo(this);\n-\n-\t\t// Draw repeat arc\n-\t\tvar distanceFromY = Math.max(DiagramNode.ARC_RADIUS*2, this.item.height+this.item.down+DiagramNode.VERTICAL_SEPARATION+this.rep.up);\n-\t\tPath(x+DiagramNode.ARC_RADIUS,y).arc('nw').down(distanceFromY-DiagramNode.ARC_RADIUS*2).arc('ws').addTo(this);\n-\t\tthis.rep.format(x+DiagramNode.ARC_RADIUS, y+distanceFromY, this.width - DiagramNode.ARC_RADIUS*2).addTo(this);\n-\t\tPath(x+this.width-DiagramNode.ARC_RADIUS, y+distanceFromY+this.rep.height).arc('se').up(distanceFromY-DiagramNode.ARC_RADIUS*2+this.rep.height-this.item.height).arc('en').addTo(this);\n-\n-\t\treturn this;\n-\t}\n-\tOneOrMoreNode.prototype.walk = function(cb) {\n-\t\tcb(this);\n-\t\tthis.item.walk(cb);\n-\t\tthis.rep.walk(cb);\n-\t}\n-\n-\tvar ZeroOrMore = funcs.ZeroOrMore = function ZeroOrMore(item, rep, skip) {\n-\t\treturn OptionalNode(OneOrMoreNode(item, rep), skip);\n-\t}\n-\n-\tvar Start = funcs.Start = function Start({type=\"simple\", label}={}) {\n-\t\tif(!(this instanceof Start)) return new Start({type, label});\n-\t\tFakeSVG.call(this, 'g');\n-\t\tthis.width = 20;\n-\t\tthis.height = 0;\n-\t\tthis.up = 10;\n-\t\tthis.down = 10;\n-\t\tthis.type = type;\n-\t\tif(label != undefined) {\n-\t\t\tthis.label = \"\"+label;\n-\t\t\tthis.width = Math.max(20, this.label.length * DiagramNode.CHAR_WIDTH + 10);\n-\t\t}\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"start\"\n-\t\t}\n-\t}\n-\tsubclassOf(Start, FakeSVG);\n-\tStart.prototype.format = function(x,y) {\n-\t\tlet path = new Path(x, y-10);\n-\t\tif (this.type === \"complex\") {\n-\t\t\tpath.down(20)\n-\t\t\t\t.m(0, -10)\n-\t\t\t\t.right(this.width)\n-\t\t\t\t.addTo(this);\n-\t\t} else {\n-\t\t\tpath.down(20)\n-\t\t\t\t.m(10, -20)\n-\t\t\t\t.down(20)\n-\t\t\t\t.m(-10, -10)\n-\t\t\t\t.right(this.width)\n-\t\t\t\t.addTo(this);\n-\t\t}\n-\t\tif(this.label) {\n-\t\t\tnew FakeSVG('text', {x:x, y:y-15, style:\"text-anchor:start\"}, this.label).addTo(this);\n-\t\t}\n-\t\treturn this;\n-\t}\n-\n-\tvar End = funcs.End = function End({type=\"simple\"}={}) {\n-\t\tif(!(this instanceof End)) return new End({type});\n-\t\tFakeSVG.call(this, 'path');\n-\t\tthis.width = 20;\n-\t\tthis.height = 0;\n-\t\tthis.up = 10;\n-\t\tthis.down = 10;\n-\t\tthis.type = type;\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"end\"\n-\t\t}\n-\t}\n-\tsubclassOf(End, FakeSVG);\n-\tEnd.prototype.format = function(x,y) {\n-\t\tif (this.type === \"complex\") {\n-\t\t\tthis.attrs.d = 'M '+x+' '+y+' h 20 m 0 -10 v 20';\n-\t\t} else {\n-\t\t\tthis.attrs.d = 'M '+x+' '+y+' h 20 m -10 -10 v 20 m 10 -20 v 20';\n-\t\t}\n-\t\treturn this;\n-\t}\n-\n-\tvar Terminal = funcs.Terminal = function Terminal(text, {href, title}={}) {\n-\t\tif(!(this instanceof Terminal)) return new Terminal(text, {href, title});\n-\t\tFakeSVG.call(this, 'g', {'class': 'terminal'});\n-\t\tthis.text = \"\"+text;\n-\t\tthis.href = href;\n-\t\tthis.title = title;\n-\t\tthis.width = this.text.length * DiagramNode.CHAR_WIDTH + 20;\n-\t\tthis.height = 0;\n-\t\tthis.up = 11;\n-\t\tthis.down = 11;\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"terminal\"\n-\t\t}\n-\t}\n-\tsubclassOf(Terminal, FakeSVG);\n-\tTerminal.prototype.needsSpace = true;\n-\tTerminal.prototype.format = function(x, y, width) {\n-\t\t// Hook up the two sides if this is narrower than its stated width.\n-\t\tvar gaps = determineGaps(width, this.width);\n-\t\tPath(x,y).h(gaps[0]).addTo(this);\n-\t\tPath(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);\n-\t\tx += gaps[0];\n-\n-\t\tFakeSVG('rect', {x:x, y:y-11, width:this.width, height:this.up+this.down, rx:10, ry:10}).addTo(this);\n-\t\tvar text = FakeSVG('text', {x:x+this.width/2, y:y+4}, this.text);\n-\t\tif(this.href)\n-\t\t\tFakeSVG('a', {'xlink:href': this.href}, [text]).addTo(this);\n-\t\telse\n-\t\t\ttext.addTo(this);\n-\t\tif(this.title)\n-\t\t\tnew FakeSVG('title', {}, this.title).addTo(this);\n-\t\treturn this;\n-\t}\n-\n-\tvar NonTerminal = funcs.NonTerminal = function NonTerminal(text, element_class, on_click, {href, title}={}) {\n-\t\tif(!(this instanceof NonTerminal)) return new NonTerminal(text, {href, title});\n-\t\tFakeSVG.call(this, 'g', {'class': 'non-terminal'});\n-\t\tthis.text = \"\"+text;\n-\t\tthis.href = href;\n-\t\tthis.title = title;\n-\t\tthis.width = this.text.length * DiagramNode.CHAR_WIDTH + 20;\n-\t\tthis.height = 0;\n-\t\tthis.element_class = element_class;\n-\t\tthis.on_click = on_click;\n-\t\tthis.up = 11;\n-\t\tthis.down = 11;\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"nonterminal\"\n-\t\t}\n-\t}\n-\tsubclassOf(NonTerminal, FakeSVG);\n-\tNonTerminal.prototype.needsSpace = true;\n-\tNonTerminal.prototype.format = function(x, y, width) {\n-\t\t// Hook up the two sides if this is narrower than its stated width.\n-\t\tvar gaps = determineGaps(width, this.width);\n-\t\tPath(x,y).h(gaps[0]).addTo(this);\n-\t\tPath(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);\n-\t\tx += gaps[0];\n-\n-\t\tvar rect = FakeSVG('rect', {x:x, y:y-11, width:this.width, height:this.up+this.down})\n-\t\trect.attrs['class'] = this.element_class\n-\t\trect.addTo(this);\n-\t\tif (this.on_click !== undefined) {\n-\t\t\trect.attrs['onclick'] = this.on_click;\n-\t\t}\n-\n-\t\tvar text = FakeSVG('text', {x:x+this.width/2, y:y+4}, this.text);\n-\t\ttext.attrs['class'] = this.element_class\n-\t\tif (this.on_click !== undefined) {\n-\t\t\tconsole.log(this.on_click);\n-\t\t\ttext.attrs['onclick'] = this.on_click;\n-\t\t}\n-\t\tif(this.href)\n-\t\t\tFakeSVG('a', {'xlink:href': this.href}, [text]).addTo(this);\n-\t\telse\n-\t\t\ttext.addTo(this);\n-\t\tif(this.title)\n-\t\t\tnew FakeSVG('title', {}, this.title).addTo(this);\n-\t\treturn this;\n-\t}\n-\n-\tvar Comment = funcs.Comment = function Comment(text, {href, title}={}) {\n-\t\tif(!(this instanceof Comment)) return new Comment(text, {href, title});\n-\t\tFakeSVG.call(this, 'g');\n-\t\tthis.text = \"\"+text;\n-\t\tthis.href = href;\n-\t\tthis.title = title;\n-\t\tthis.width = this.text.length * DiagramNode.COMMENT_CHAR_WIDTH + 10;\n-\t\tthis.height = 0;\n-\t\tthis.up = 11;\n-\t\tthis.down = 11;\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"comment\"\n-\t\t}\n-\t}\n-\tsubclassOf(Comment, FakeSVG);\n-\tComment.prototype.needsSpace = true;\n-\tComment.prototype.format = function(x, y, width) {\n-\t\t// Hook up the two sides if this is narrower than its stated width.\n-\t\tvar gaps = determineGaps(width, this.width);\n-\t\tPath(x,y).h(gaps[0]).addTo(this);\n-\t\tPath(x+gaps[0]+this.width,y+this.height).h(gaps[1]).addTo(this);\n-\t\tx += gaps[0];\n-\n-\t\tvar text = FakeSVG('text', {x:x+this.width/2, y:y+5, class:'comment'}, this.text);\n-\t\tif(this.href)\n-\t\t\tFakeSVG('a', {'xlink:href': this.href}, [text]).addTo(this);\n-\t\telse\n-\t\t\ttext.addTo(this);\n-\t\tif(this.title)\n-\t\t\tnew FakeSVG('title', {}, this.title).addTo(this);\n-\t\treturn this;\n-\t}\n-\n-\tvar Skip = funcs.Skip = function Skip() {\n-\t\tif(!(this instanceof Skip)) return new Skip();\n-\t\tFakeSVG.call(this, 'g');\n-\t\tthis.width = 0;\n-\t\tthis.height = 0;\n-\t\tthis.up = 0;\n-\t\tthis.down = 0;\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down\n-\t\t\tthis.attrs['data-type'] = \"skip\"\n-\t\t}\n-\t}\n-\tsubclassOf(Skip, FakeSVG);\n-\tSkip.prototype.format = function(x, y, width) {\n-\t\tPath(x,y).right(width).addTo(this);\n-\t\treturn this;\n-\t}\n-\n-\n-\tvar Block = funcs.Block = function Block({width=50, up=15, height=25, down=15, needsSpace=true}={}) {\n-\t\tif(!(this instanceof Block)) return new Block({width, up, height, down, needsSpace});\n-\t\tFakeSVG.call(this, 'g');\n-\t\tthis.width = width;\n-\t\tthis.height = height;\n-\t\tthis.up = up;\n-\t\tthis.down = down;\n-\t\tthis.needsSpace = true;\n-\t\tif(DiagramNode.DEBUG) {\n-\t\t\tthis.attrs['data-updown'] = this.up + \" \" + this.height + \" \" + this.down;\n-\t\t\tthis.attrs['data-type'] = \"block\"\n-\t\t}\n-\t}\n-\tsubclassOf(Block, FakeSVG);\n-\tBlock.prototype.format = function(x, y, width) {\n-\t\t// Hook up the two sides if this is narrower than its stated width.\n-\t\tvar gaps = determineGaps(width, this.width);\n-\t\tnew Path(x,y).h(gaps[0]).addTo(this);\n-\t\tnew Path(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);\n-\t\tx += gaps[0];\n-\n-\t\tnew FakeSVG('rect', {x:x, y:y-this.up, width:this.width, height:this.up+this.height+this.down}).addTo(this);\n-\t\treturn this;\n-\t}\n-\n-\tvar root;\n-\tif (typeof define === 'function' && define.amd) {\n-\t\t// AMD. Register as an anonymous module.\n-\t\troot = {};\n-\t\tdefine([], function() {\n-\t\t\treturn root;\n-\t\t});\n-\t} else if (typeof exports === 'object') {\n-\t\t// CommonJS for node\n-\t\troot = exports;\n-\t} else {\n-\t\t// Browser globals (root is window)\n-\t\troot = this;\n-\t}\n-\n-\tfor(var name in funcs) {\n-\t\troot[name] = funcs[name];\n-\t}\n-}).call(this,\n-\t{\n-\tVERTICAL_SEPARATION: 8,\n-\tARC_RADIUS: 10,\n-\tDIAGRAM_CLASS: 'railroad-diagram',\n-\tSTROKE_ODD_PIXEL_LENGTH: true,\n-\tINTERNAL_ALIGNMENT: 'left',\n-\tCHAR_WIDTH: 8.5, // width of each monospace character. play until you find the right value for your font\n-\tCOMMENT_CHAR_WIDTH: 7, // comments are in smaller text by default\n-\t}\n-);\n-\n-function Diagram(items) {\n-\treturn new DiagramNode(items);\n-}\n-\n-function Sequence(items) {\n-\treturn new SequenceNode(items);\n-}\n-\n-function Stack(items) {\n-\treturn new StackNode(items);\n-}\n-\n-function Optional(items, skip) {\n-\treturn new OptionalNode(items, skip);\n-}\n-\n-function OptionalSequence(items) {\n-\treturn new OptionalSequenceNode(items);\n-}\n-\n-function OneOrMore(items, rep) {\n-\treturn new OneOrMoreNode(items, rep);\n-}\n-\n-function Choice(normal, items) {\n-\treturn new ChoiceNode(normal, items);\n-}\n-\n-function Expression(text=\"expr\", cl=\"expression\", on_click=undefined) {\n-\treturn Sequence([new NonTerminal(text, cl, on_click)]);\n-}\n-\n-function Keyword(text) {\n-\treturn new Terminal(text);\n-\t// return new Terminal(text)\n-}\n-\n-function Expandable(text, options, node_name, expand_func) {\n-\tif (options[node_name]) {\n-\t\tvar sequence = expand_func(options);\n-\t\tsequence.unshift(Expression(\"-\", \"expanded\", \"Refresh(\\\"\" + node_name + \"\\\", false)\"));\n-\t\treturn Sequence(sequence)\n-\t} else {\n-\t\treturn Expression(text, \"expandable\", \"Refresh(\\\"\" + node_name + \"\\\", true)\");\n-\t}\n-}\n-\n-\n-// # see https://github.com/tabatkins/railroad-diagrams\n-\n-// literal = Choice(0,\n-// \tExpression(\"numeric-literal\"),\n-// \tExpression(\"string-literal\"),\n-// \tKeyword(\"NULL\"),\n-// \tKeyword(\"TRUE\"),\n-// \tKeyword(\"FALSE\"),\n-// \tKeyword(\"CURRENT_TIME\"),\n-// \tKeyword(\"CURRENT_DATE\"),\n-// \tKeyword(\"CURRENT_TIMESTAMP\")\n-// )\n-\n-// expr = Diagram(\n-// \tChoice(0,\n-// \t\tSequence(Expression(\"literal\")),\n-// \t\tSequence(Expression(\"bind-parameter\")),\n-// \t\tSequence(\n-// \t\t\tOptional(Sequence(\n-// \t\t\t\tExpression(\"table-name\"),\n-// \t\t\t\tKeyword(\".\")\n-// \t\t\t),\tskip=True),\n-// \t\t\tExpression(\"column-name\")\n-// \t\t),\n-// \t\tSequence(\n-// \t\t\tExpression(\"function-name\"),\n-// \t\t\tKeyword(\"(\"),\n-// \t\t\tOptional(\n-// \t\t\t\tSequence(\n-// \t\t\t\t\tOptional(Keyword(\"DISTINCT\"), skip=True),\n-// \t\t\t\t\tOneOrMore(\n-// \t\t\t\t\t\tExpression(), repeat=\",\"\n-// \t\t\t\t\t)\n-// \t\t\t\t), skip=False\n-// \t\t\t),\n-// \t\t\tKeyword(\")\"),\n-// \t\t\tOptional(Expression(\"filter-clause\"), skip=True),\n-// \t\t\tOptional(Expression(\"over-clause\"), skip=True)\n-// \t\t),\n-// \t\tSequence(\n-// \t\t\tKeyword(\"(\"),\n-// \t\t\tExpression(\"select-node\"),\n-// \t\t\tKeyword(\")\")\n-// \t\t),\n-// \t\tSequence(\n-// \t\t\tKeyword(\"CAST\"),\n-// \t\t\tKeyword(\"(\"),\n-// \t\t\tExpression(),\n-// \t\t\tKeyword(\"AS\"),\n-// \t\t\tExpression(\"type-name\"),\n-// \t\t\tKeyword(\")\")\n-// \t\t),\n-// \t\tSequence(\n-// \t\t\tExpression(),\n-// \t\t\tKeyword(\"::\"),\n-// \t\t\tExpression(\"type-name\")\n-// \t\t),\n-// \t\tSequence(\n-// \t\t\tExpression(),\n-// \t\t\tKeyword(\"IS\"),\n-// \t\t\tOptional(Keyword(\"NOT\"), skip=True),\n-// \t\t\tKeyword(\"NULL\")\n-// \t\t),\n-// \t\tSequence(\n-// \t\t\tExpression(),\n-// \t\t\tOptional(Keyword(\"NOT\"), skip=True),\n-// \t\t\tChoice(0,\n-// \t\t\t\tKeyword(\"LIKE\"),\n-// \t\t\t\tSequence(\n-// \t\t\t\t\tKeyword(\"SIMILAR\"),\n-// \t\t\t\t\tKeyword(\"TO\")\n-// \t\t\t\t)),\n-// \t\t\tExpression(),\n-// \t\t\tOptional(Sequence(Keyword(\"ESCAPE\"), Expression()), skip=True)\n-// \t\t),\n-// \t\tSequence(\n-// \t\t\tExpression(),\n-// \t\t\tOptional(Keyword(\"NOT\"), skip=True),\n-// \t\t\tKeyword(\"BETWEEN\"),\n-// \t\t\tExpression(),\n-// \t\t\tKeyword(\"AND\"),\n-// \t\t\tExpression()\n-// \t\t),\n-// \t\tSequence(\n-// \t\t\tExpression(),\n-// \t\t\tOptional(Keyword(\"NOT\"), skip=True),\n-// \t\t\tKeyword(\"IN\"),\n-// \t\t\tChoice(0,\n-// \t\t\t\tOneOrMore(\n-// \t\t\t\t\tExpression(), \",\"\n-// \t\t\t\t),\n-// \t\t\t\tExpression(\"select-node\")\n-// \t\t\t)\n-// \t\t),\n-// \t\tSequence(\n-// \t\t\tOptional(Keyword(\"NOT\"), skip=True),\n-// \t\t\tKeyword(\"EXISTS\"),\n-// \t\t\tExpression(\"select-node\")\n-// \t\t),\n-// \t\tSequence(\n-// \t\t\tKeyword(\"CASE\"),\n-// \t\t\tExpression(),\n-// \t\t\tOneOrMore(\n-// \t\t\t\tSequence(\n-// \t\t\t\t\tKeyword(\"WHEN\"),\n-// \t\t\t\t\tExpression(),\n-// \t\t\t\t\tKeyword(\"THEN\"),\n-// \t\t\t\t\tExpression()\n-// \t\t\t\t)\n-// \t\t\t),\n-// \t\t\tKeyword(\"ELSE\"),\n-// \t\t\tExpression(),\n-// \t\t\tKeyword(\"END\")\n-// \t\t)\n-// \t)\n-// )\ndiff --git a/src/common/file_system.cpp b/src/common/file_system.cpp\nindex 511ecee6f101..69a6acbbf02b 100644\n--- a/src/common/file_system.cpp\n+++ b/src/common/file_system.cpp\n@@ -18,13 +18,13 @@ FileSystem &FileSystem::GetFileSystem(ClientContext &context) {\n \n static void AssertValidFileFlags(uint8_t flags) {\n \t// cannot combine Read and Write flags\n-\tassert(!(flags & FileFlags::READ && flags & FileFlags::WRITE));\n+\tassert(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_WRITE));\n \t// cannot combine Read and CREATE/Append flags\n-\tassert(!(flags & FileFlags::READ && flags & FileFlags::APPEND));\n-\tassert(!(flags & FileFlags::READ && flags & FileFlags::FILE_CREATE));\n-\tassert(!(flags & FileFlags::READ && flags & FileFlags::FILE_CREATE_NEW));\n+\tassert(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_APPEND));\n+\tassert(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_FILE_CREATE));\n+\tassert(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW));\n \t// cannot combine CREATE and CREATE_NEW flags\n-\tassert(!(flags & FileFlags::FILE_CREATE && flags & FileFlags::FILE_CREATE_NEW));\n+\tassert(!(flags & FileFlags::FILE_FLAGS_FILE_CREATE && flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW));\n }\n \n #ifndef _WIN32\n@@ -69,22 +69,22 @@ unique_ptr<FileHandle> FileSystem::OpenFile(const char *path, uint8_t flags, Fil\n \n \tint open_flags = 0;\n \tint rc;\n-\tif (flags & FileFlags::READ) {\n+\tif (flags & FileFlags::FILE_FLAGS_READ) {\n \t\topen_flags = O_RDONLY;\n \t} else {\n \t\t// need Read or Write\n-\t\tassert(flags & FileFlags::WRITE);\n+\t\tassert(flags & FileFlags::FILE_FLAGS_WRITE);\n \t\topen_flags = O_RDWR | O_CLOEXEC;\n-\t\tif (flags & FileFlags::FILE_CREATE) {\n+\t\tif (flags & FileFlags::FILE_FLAGS_FILE_CREATE) {\n \t\t\topen_flags |= O_CREAT;\n-\t\t} else if (flags & FileFlags::FILE_CREATE_NEW) {\n+\t\t} else if (flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW) {\n \t\t\topen_flags |= O_CREAT | O_TRUNC;\n \t\t}\n-\t\tif (flags & FileFlags::APPEND) {\n+\t\tif (flags & FileFlags::FILE_FLAGS_APPEND) {\n \t\t\topen_flags |= O_APPEND;\n \t\t}\n \t}\n-\tif (flags & FileFlags::DIRECT_IO) {\n+\tif (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {\n #if defined(__sun) && defined(__SVR4)\n \t\tthrow Exception(\"DIRECT_IO not supported on Solaris\");\n #endif\n@@ -100,7 +100,7 @@ unique_ptr<FileHandle> FileSystem::OpenFile(const char *path, uint8_t flags, Fil\n \t\tthrow IOException(\"Cannot open file \\\"%s\\\": %s\", path, strerror(errno));\n \t}\n \t// #if defined(__DARWIN__) || defined(__APPLE__)\n-\t// \tif (flags & FileFlags::DIRECT_IO) {\n+\t// \tif (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {\n \t// \t\t// OSX requires fcntl for Direct IO\n \t// \t\trc = fcntl(fd, F_NOCACHE, 1);\n \t// \t\tif (fd == -1) {\n@@ -365,24 +365,24 @@ unique_ptr<FileHandle> FileSystem::OpenFile(const char *path, uint8_t flags, Fil\n \tDWORD share_mode;\n \tDWORD creation_disposition = OPEN_EXISTING;\n \tDWORD flags_and_attributes = FILE_ATTRIBUTE_NORMAL;\n-\tif (flags & FileFlags::READ) {\n+\tif (flags & FileFlags::FILE_FLAGS_READ) {\n \t\tdesired_access = GENERIC_READ;\n \t\tshare_mode = FILE_SHARE_READ;\n \t} else {\n \t\t// need Read or Write\n-\t\tassert(flags & FileFlags::WRITE);\n+\t\tassert(flags & FileFlags::FILE_FLAGS_WRITE);\n \t\tdesired_access = GENERIC_READ | GENERIC_WRITE;\n \t\tshare_mode = 0;\n-\t\tif (flags & FileFlags::FILE_CREATE) {\n+\t\tif (flags & FileFlags::FILE_FLAGS_FILE_CREATE) {\n \t\t\tcreation_disposition = OPEN_ALWAYS;\n-\t\t} else if (flags & FileFlags::FILE_CREATE_NEW) {\n+\t\t} else if (flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW) {\n \t\t\tcreation_disposition = CREATE_ALWAYS;\n \t\t}\n-\t\tif (flags & FileFlags::DIRECT_IO) {\n+\t\tif (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {\n \t\t\tflags_and_attributes |= FILE_FLAG_WRITE_THROUGH;\n \t\t}\n \t}\n-\tif (flags & FileFlags::DIRECT_IO) {\n+\tif (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {\n \t\tflags_and_attributes |= FILE_FLAG_NO_BUFFERING;\n \t}\n \tHANDLE hFile =\n@@ -392,7 +392,7 @@ unique_ptr<FileHandle> FileSystem::OpenFile(const char *path, uint8_t flags, Fil\n \t\tthrow IOException(\"Cannot open file \\\"%s\\\": %s\", path, error.c_str());\n \t}\n \tauto handle = make_unique<WindowsFileHandle>(*this, path, hFile);\n-\tif (flags & FileFlags::APPEND) {\n+\tif (flags & FileFlags::FILE_FLAGS_APPEND) {\n \t\tSetFilePointer(*handle, GetFileSize(*handle));\n \t}\n \treturn move(handle);\ndiff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp\nindex 6e19153232bf..47613c1fa438 100644\n--- a/src/common/operator/cast_operators.cpp\n+++ b/src/common/operator/cast_operators.cpp\n@@ -5,6 +5,7 @@\n #include \"duckdb/common/types/date.hpp\"\n #include \"duckdb/common/types/hugeint.hpp\"\n #include \"duckdb/common/types/interval.hpp\"\n+#include \"duckdb/common/types/numeric_helper.hpp\"\n #include \"duckdb/common/types/time.hpp\"\n #include \"duckdb/common/types/timestamp.hpp\"\n #include \"duckdb/common/types/vector.hpp\"\n@@ -552,129 +553,19 @@ template <> string_t StringCast::Operation(bool input, Vector &vector) {\n \t}\n }\n \n-struct StringToIntegerCast {\n-\ttemplate <class T> static int UnsignedLength(T value);\n-\n-\t// Formats value in reverse and returns a pointer to the beginning.\n-\ttemplate <class T> static char *FormatUnsigned(T value, char *ptr) {\n-\t\twhile (value >= 100) {\n-\t\t\t// Integer division is slow so do it for a group of two digits instead\n-\t\t\t// of for every digit. The idea comes from the talk by Alexandrescu\n-\t\t\t// \"Three Optimization Tips for C++\". See speed-test for a comparison.\n-\t\t\tauto index = static_cast<unsigned>((value % 100) * 2);\n-\t\t\tvalue /= 100;\n-\t\t\t*--ptr = duckdb_fmt::internal::data::digits[index + 1];\n-\t\t\t*--ptr = duckdb_fmt::internal::data::digits[index];\n-\t\t}\n-\t\tif (value < 10) {\n-\t\t\t*--ptr = static_cast<char>('0' + value);\n-\t\t\treturn ptr;\n-\t\t}\n-\t\tauto index = static_cast<unsigned>(value * 2);\n-\t\t*--ptr = duckdb_fmt::internal::data::digits[index + 1];\n-\t\t*--ptr = duckdb_fmt::internal::data::digits[index];\n-\t\treturn ptr;\n-\t}\n-\n-\ttemplate <class SIGNED, class UNSIGNED> static string_t FormatSigned(SIGNED value, Vector &vector) {\n-\t\tint sign = -(value < 0);\n-\t\tUNSIGNED unsigned_value = (value ^ sign) - sign;\n-\t\tint length = UnsignedLength<UNSIGNED>(unsigned_value) - sign;\n-\t\tstring_t result = StringVector::EmptyString(vector, length);\n-\t\tauto dataptr = result.GetData();\n-\t\tauto endptr = dataptr + length;\n-\t\tendptr = FormatUnsigned(unsigned_value, endptr);\n-\t\tif (sign) {\n-\t\t\t*--endptr = '-';\n-\t\t}\n-\t\tresult.Finalize();\n-\t\treturn result;\n-\t}\n-};\n-\n-template <> int StringToIntegerCast::UnsignedLength(uint8_t value) {\n-\tint length = 1;\n-\tlength += value >= 10;\n-\tlength += value >= 100;\n-\treturn length;\n-}\n-\n-template <> int StringToIntegerCast::UnsignedLength(uint16_t value) {\n-\tint length = 1;\n-\tlength += value >= 10;\n-\tlength += value >= 100;\n-\tlength += value >= 1000;\n-\tlength += value >= 10000;\n-\treturn length;\n-}\n-\n-template <> int StringToIntegerCast::UnsignedLength(uint32_t value) {\n-\tif (value >= 10000) {\n-\t\tint length = 5;\n-\t\tlength += value >= 100000;\n-\t\tlength += value >= 1000000;\n-\t\tlength += value >= 10000000;\n-\t\tlength += value >= 100000000;\n-\t\tlength += value >= 1000000000;\n-\t\treturn length;\n-\t} else {\n-\t\tint length = 1;\n-\t\tlength += value >= 10;\n-\t\tlength += value >= 100;\n-\t\tlength += value >= 1000;\n-\t\treturn length;\n-\t}\n-}\n-\n-template <> int StringToIntegerCast::UnsignedLength(uint64_t value) {\n-\tif (value >= 10000000000ULL) {\n-\t\tif (value >= 1000000000000000ULL) {\n-\t\t\tint length = 16;\n-\t\t\tlength += value >= 10000000000000000ULL;\n-\t\t\tlength += value >= 100000000000000000ULL;\n-\t\t\tlength += value >= 1000000000000000000ULL;\n-\t\t\tlength += value >= 10000000000000000000ULL;\n-\t\t\treturn length;\n-\t\t} else {\n-\t\t\tint length = 11;\n-\t\t\tlength += value >= 100000000000ULL;\n-\t\t\tlength += value >= 1000000000000ULL;\n-\t\t\tlength += value >= 10000000000000ULL;\n-\t\t\tlength += value >= 100000000000000ULL;\n-\t\t\treturn length;\n-\t\t}\n-\t} else {\n-\t\tif (value >= 100000ULL) {\n-\t\t\tint length = 6;\n-\t\t\tlength += value >= 1000000ULL;\n-\t\t\tlength += value >= 10000000ULL;\n-\t\t\tlength += value >= 100000000ULL;\n-\t\t\tlength += value >= 1000000000ULL;\n-\t\t\treturn length;\n-\t\t} else {\n-\t\t\tint length = 1;\n-\t\t\tlength += value >= 10ULL;\n-\t\t\tlength += value >= 100ULL;\n-\t\t\tlength += value >= 1000ULL;\n-\t\t\tlength += value >= 10000ULL;\n-\t\t\treturn length;\n-\t\t}\n-\t}\n-}\n-\n template <> string_t StringCast::Operation(int8_t input, Vector &vector) {\n-\treturn StringToIntegerCast::FormatSigned<int8_t, uint8_t>(input, vector);\n+\treturn NumericHelper::FormatSigned<int8_t, uint8_t>(input, vector);\n }\n \n template <> string_t StringCast::Operation(int16_t input, Vector &vector) {\n-\treturn StringToIntegerCast::FormatSigned<int16_t, uint16_t>(input, vector);\n+\treturn NumericHelper::FormatSigned<int16_t, uint16_t>(input, vector);\n }\n template <> string_t StringCast::Operation(int32_t input, Vector &vector) {\n-\treturn StringToIntegerCast::FormatSigned<int32_t, uint32_t>(input, vector);\n+\treturn NumericHelper::FormatSigned<int32_t, uint32_t>(input, vector);\n }\n \n template <> string_t StringCast::Operation(int64_t input, Vector &vector) {\n-\treturn StringToIntegerCast::FormatSigned<int64_t, uint64_t>(input, vector);\n+\treturn NumericHelper::FormatSigned<int64_t, uint64_t>(input, vector);\n }\n \n template <> string_t StringCast::Operation(float input, Vector &vector) {\n@@ -696,7 +587,7 @@ struct HugeintToStringCast {\n \tstatic int UnsignedLength(hugeint_t value) {\n \t\tassert(value.upper >= 0);\n \t\tif (value.upper == 0) {\n-\t\t\treturn StringToIntegerCast::UnsignedLength<uint64_t>(value.lower);\n+\t\t\treturn NumericHelper::UnsignedLength<uint64_t>(value.lower);\n \t\t}\n \t\t// search the length using the PowersOfTen array\n \t\t// the length has to be between [17] and [38], because the hugeint is bigger than 2^63\n@@ -773,7 +664,7 @@ struct HugeintToStringCast {\n \t\t\tauto startptr = ptr;\n \t\t\t// now we format the remainder: note that we need to pad with zero's in case\n \t\t\t// the remainder is small (i.e. less than 10000000000000000)\n-\t\t\tptr = StringToIntegerCast::FormatUnsigned<uint64_t>(remainder, ptr);\n+\t\t\tptr = NumericHelper::FormatUnsigned<uint64_t>(remainder, ptr);\n \n \t\t\tint format_length = startptr - ptr;\n \t\t\t// pad with zero\n@@ -782,7 +673,7 @@ struct HugeintToStringCast {\n \t\t\t}\n \t\t}\n \t\t// once the value falls in the range of a uint64_t, fallback to formatting as uint64_t to avoid hugeint division\n-\t\treturn StringToIntegerCast::FormatUnsigned<uint64_t>(value.lower, ptr);\n+\t\treturn NumericHelper::FormatUnsigned<uint64_t>(value.lower, ptr);\n \t}\n \n \tstatic string_t FormatSigned(hugeint_t value, Vector &vector) {\n@@ -796,7 +687,7 @@ struct HugeintToStringCast {\n \t\tauto endptr = dataptr + length;\n \t\tif (value.upper == 0) {\n \t\t\t// small value: format as uint64_t\n-\t\t\tendptr = StringToIntegerCast::FormatUnsigned<uint64_t>(value.lower, endptr);\n+\t\t\tendptr = NumericHelper::FormatUnsigned<uint64_t>(value.lower, endptr);\n \t\t} else {\n \t\t\tendptr = FormatUnsigned(value, endptr);\n \t\t}\n@@ -842,7 +733,7 @@ struct DateToStringCast {\n \tstatic void Format(char *data, int32_t date[], idx_t year_length, bool add_bc) {\n \t\t// now we write the string, first write the year\n \t\tauto endptr = data + year_length;\n-\t\tendptr = StringToIntegerCast::FormatUnsigned(date[0], endptr);\n+\t\tendptr = NumericHelper::FormatUnsigned(date[0], endptr);\n \t\t// add optional leading zeros\n \t\twhile (endptr > data) {\n \t\t\t*--endptr = '0';\n@@ -930,7 +821,7 @@ struct TimeToStringCast {\n \t\t// now optionally write ms at the end\n \t\tif (time[3] > 0) {\n \t\t\tauto start = ptr;\n-\t\t\tptr = StringToIntegerCast::FormatUnsigned(time[3], data + length);\n+\t\t\tptr = NumericHelper::FormatUnsigned(time[3], data + length);\n \t\t\twhile (ptr > start) {\n \t\t\t\t*--ptr = '0';\n \t\t\t}\n@@ -1011,7 +902,7 @@ template <> dtime_t CastTimestampToTime::Operation(timestamp_t input) {\n // Cast To Timestamp\n //===--------------------------------------------------------------------===//\n template <> timestamp_t CastToTimestamp::Operation(string_t input) {\n-\treturn Timestamp::FromString(input.GetData());\n+\treturn Timestamp::FromCString(input.GetData(), input.GetSize());\n }\n \n //===--------------------------------------------------------------------===//\ndiff --git a/src/common/serializer/buffered_file_reader.cpp b/src/common/serializer/buffered_file_reader.cpp\nindex 575d87a2ecdc..677d8cb1c016 100644\n--- a/src/common/serializer/buffered_file_reader.cpp\n+++ b/src/common/serializer/buffered_file_reader.cpp\n@@ -10,7 +10,7 @@ using namespace std;\n \n BufferedFileReader::BufferedFileReader(FileSystem &fs, const char *path)\n     : fs(fs), data(unique_ptr<data_t[]>(new data_t[FILE_BUFFER_SIZE])), offset(0), read_data(0), total_read(0) {\n-\thandle = fs.OpenFile(path, FileFlags::READ, FileLockType::READ_LOCK);\n+\thandle = fs.OpenFile(path, FileFlags::FILE_FLAGS_READ, FileLockType::READ_LOCK);\n \tfile_size = fs.GetFileSize(*handle);\n }\n \ndiff --git a/src/common/types/CMakeLists.txt b/src/common/types/CMakeLists.txt\nindex e56ee124c77b..39654e3a7a5a 100644\n--- a/src/common/types/CMakeLists.txt\n+++ b/src/common/types/CMakeLists.txt\n@@ -7,6 +7,7 @@ add_library_unity(duckdb_common_types\n                   hugeint.cpp\n                   hyperloglog.cpp\n                   interval.cpp\n+                  numeric_helper.cpp\n                   null_value.cpp\n                   selection_vector.cpp\n                   string_heap.cpp\ndiff --git a/src/common/types/date.cpp b/src/common/types/date.cpp\nindex 4b13649b400a..1d272e7db9d8 100644\n--- a/src/common/types/date.cpp\n+++ b/src/common/types/date.cpp\n@@ -12,6 +12,11 @@\n using namespace duckdb;\n using namespace std;\n \n+string_t Date::MonthNamesAbbreviated[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n+string_t Date::MonthNames[] = {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n+string_t Date::DayNames[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n+string_t Date::DayNamesAbbreviated[] = {\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"};\n+\n // Taken from MonetDB mtime.c\n \n static int NORMALDAYS[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n@@ -111,10 +116,10 @@ static bool ParseDoubleDigit(const char *buf, idx_t &pos, int32_t &result) {\n \treturn false;\n }\n \n-static bool TryConvertDate(const char *buf, date_t &result, bool strict = false) {\n+bool Date::TryConvertDate(const char *buf, idx_t &pos, date_t &result, bool strict) {\n \tint32_t day = 0, month = -1;\n \tint32_t year = 0, yearneg = (buf[0] == '-');\n-\tidx_t pos = 0;\n+\tpos = 0;\n \tint sep;\n \n \t// skip leading spaces\n@@ -187,7 +192,8 @@ static bool TryConvertDate(const char *buf, date_t &result, bool strict = false)\n \n date_t Date::FromCString(const char *buf, bool strict) {\n \tdate_t result;\n-\tif (!TryConvertDate(buf, result, strict)) {\n+\tidx_t pos;\n+\tif (!TryConvertDate(buf, pos, result, strict)) {\n \t\tthrow ConversionException(\"date/time field value out of range: \\\"%s\\\", \"\n \t\t                          \"expected format is (YYYY-MM-DD)\",\n \t\t                          buf);\n@@ -289,8 +295,8 @@ int32_t Date::ExtractISODayOfTheWeek(date_t date) {\n \t}\n }\n \n-static int32_t GetWeek(int32_t year, int32_t month, int32_t day) {\n-\tauto day_of_the_year = (leapyear(year) ? CUMLEAPDAYS[month] : CUMDAYS[month]) + day;\n+static int32_t GetISOWeek(int32_t year, int32_t month, int32_t day) {\n+\tauto day_of_the_year = (Date::IsLeapYear(year) ? CUMLEAPDAYS[month] : CUMDAYS[month]) + day;\n \t// get the first day of the first week of the year\n \t// the first week is the week that has the 4th of January in it\n \tauto day_of_the_fourth = Date::ExtractISODayOfTheWeek(Date::FromDate(year, 1, 4));\n@@ -301,16 +307,47 @@ static int32_t GetWeek(int32_t year, int32_t month, int32_t day) {\n \tauto first_day_of_the_first_week = day_of_the_fourth >= 4 ? 0 : 5 - day_of_the_fourth;\n \tif (day_of_the_year < first_day_of_the_first_week) {\n \t\t// day is part of last year\n-\t\treturn GetWeek(year - 1, 12, day);\n+\t\treturn GetISOWeek(year - 1, 12, day);\n \t} else {\n \t\treturn ((day_of_the_year - first_day_of_the_first_week) / 7) + 1;\n \t}\n }\n \n-int32_t Date::ExtractWeekNumber(date_t date) {\n+int32_t Date::ExtractISOWeekNumber(date_t date) {\n+\tint32_t year, month, day;\n+\tDate::Convert(date, year, month, day);\n+\treturn GetISOWeek(year, month - 1, day - 1);\n+}\n+\n+int32_t Date::ExtractWeekNumberRegular(date_t date, bool monday_first) {\n \tint32_t year, month, day;\n \tDate::Convert(date, year, month, day);\n-\treturn GetWeek(year, month - 1, day - 1);\n+\tmonth -= 1;\n+\tday -= 1;\n+\t// get the day of the year\n+\tauto day_of_the_year = (Date::IsLeapYear(year) ? CUMLEAPDAYS[month] : CUMDAYS[month]) + day;\n+\t// now figure out the first monday or sunday of the year\n+\t// what day is January 1st?\n+\tauto day_of_jan_first = Date::ExtractISODayOfTheWeek(Date::FromDate(year, 1, 1));\n+\t// monday = 1, sunday = 7\n+\tint32_t first_week_start;\n+\tif (monday_first) {\n+\t\t// have to find next \"1\"\n+\t\tif (day_of_jan_first == 1) {\n+\t\t\t// jan 1 is monday: starts immediately\n+\t\t\tfirst_week_start = 0;\n+\t\t} else {\n+\t\t\t// jan 1 is not monday: count days until next monday\n+\t\t\tfirst_week_start = 8 - day_of_jan_first;\n+\t\t}\n+\t} else {\n+\t\tfirst_week_start = 7 - day_of_jan_first;\n+\t}\n+\tif (day_of_the_year < first_week_start) {\n+\t\t// day occurs before first week starts: week 0\n+\t\treturn 0;\n+\t}\n+\treturn ((day_of_the_year - first_week_start) / 7) + 1;\n }\n \n // Returns the date of the monday of the current week.\ndiff --git a/src/common/types/numeric_helper.cpp b/src/common/types/numeric_helper.cpp\nnew file mode 100644\nindex 000000000000..a83e0353dacf\n--- /dev/null\n+++ b/src/common/types/numeric_helper.cpp\n@@ -0,0 +1,75 @@\n+#include \"duckdb/common/types/numeric_helper.hpp\"\n+\n+namespace duckdb {\n+\n+template <> int NumericHelper::UnsignedLength(uint8_t value) {\n+\tint length = 1;\n+\tlength += value >= 10;\n+\tlength += value >= 100;\n+\treturn length;\n+}\n+\n+template <> int NumericHelper::UnsignedLength(uint16_t value) {\n+\tint length = 1;\n+\tlength += value >= 10;\n+\tlength += value >= 100;\n+\tlength += value >= 1000;\n+\tlength += value >= 10000;\n+\treturn length;\n+}\n+\n+template <> int NumericHelper::UnsignedLength(uint32_t value) {\n+\tif (value >= 10000) {\n+\t\tint length = 5;\n+\t\tlength += value >= 100000;\n+\t\tlength += value >= 1000000;\n+\t\tlength += value >= 10000000;\n+\t\tlength += value >= 100000000;\n+\t\tlength += value >= 1000000000;\n+\t\treturn length;\n+\t} else {\n+\t\tint length = 1;\n+\t\tlength += value >= 10;\n+\t\tlength += value >= 100;\n+\t\tlength += value >= 1000;\n+\t\treturn length;\n+\t}\n+}\n+\n+template <> int NumericHelper::UnsignedLength(uint64_t value) {\n+\tif (value >= 10000000000ULL) {\n+\t\tif (value >= 1000000000000000ULL) {\n+\t\t\tint length = 16;\n+\t\t\tlength += value >= 10000000000000000ULL;\n+\t\t\tlength += value >= 100000000000000000ULL;\n+\t\t\tlength += value >= 1000000000000000000ULL;\n+\t\t\tlength += value >= 10000000000000000000ULL;\n+\t\t\treturn length;\n+\t\t} else {\n+\t\t\tint length = 11;\n+\t\t\tlength += value >= 100000000000ULL;\n+\t\t\tlength += value >= 1000000000000ULL;\n+\t\t\tlength += value >= 10000000000000ULL;\n+\t\t\tlength += value >= 100000000000000ULL;\n+\t\t\treturn length;\n+\t\t}\n+\t} else {\n+\t\tif (value >= 100000ULL) {\n+\t\t\tint length = 6;\n+\t\t\tlength += value >= 1000000ULL;\n+\t\t\tlength += value >= 10000000ULL;\n+\t\t\tlength += value >= 100000000ULL;\n+\t\t\tlength += value >= 1000000000ULL;\n+\t\t\treturn length;\n+\t\t} else {\n+\t\t\tint length = 1;\n+\t\t\tlength += value >= 10ULL;\n+\t\t\tlength += value >= 100ULL;\n+\t\t\tlength += value >= 1000ULL;\n+\t\t\tlength += value >= 10000ULL;\n+\t\t\treturn length;\n+\t\t}\n+\t}\n+}\n+\n+}\n\\ No newline at end of file\ndiff --git a/src/common/types/time.cpp b/src/common/types/time.cpp\nindex 355b44d9a400..efb2865b68b6 100644\n--- a/src/common/types/time.cpp\n+++ b/src/common/types/time.cpp\n@@ -57,9 +57,9 @@ static bool ParseDoubleDigit2(const char *buf, idx_t &pos, int32_t &result) {\n \treturn false;\n }\n \n-static bool TryConvertTime(const char *buf, dtime_t &result, bool strict = false) {\n+bool Time::TryConvertTime(const char *buf, idx_t &pos, dtime_t &result, bool strict) {\n \tint32_t hour = -1, min = -1, sec = -1, msec = -1;\n-\tidx_t pos = 0;\n+\tpos = 0;\n \tint sep;\n \n \t// skip leading spaces\n@@ -107,8 +107,10 @@ static bool TryConvertTime(const char *buf, dtime_t &result, bool strict = false\n \tsep = buf[pos++];\n \tif (sep == '.') { // we expect some milliseconds\n \t\tuint8_t mult = 100;\n-\t\tfor (; std::isdigit((unsigned char)buf[pos]) && mult > 0; pos++, mult /= 10) {\n-\t\t\tmsec += (buf[pos] - '0') * mult;\n+\t\tfor (; std::isdigit((unsigned char)buf[pos]); pos++, mult /= 10) {\n+\t\t\tif (mult > 0) {\n+\t\t\t\tmsec += (buf[pos] - '0') * mult;\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -130,9 +132,10 @@ static bool TryConvertTime(const char *buf, dtime_t &result, bool strict = false\n \n dtime_t Time::FromCString(const char *buf, bool strict) {\n \tdtime_t result;\n-\tif (!TryConvertTime(buf, result, strict)) {\n+\tidx_t pos;\n+\tif (!TryConvertTime(buf, pos, result, strict)) {\n \t\t// last chance, check if we can parse as timestamp\n-\t\tif (strlen(buf) > 10 && !strict) {\n+\t\tif (!strict) {\n \t\t\treturn Timestamp::GetTime(Timestamp::FromString(buf));\n \t\t}\n \t\tthrow ConversionException(\"time field value out of range: \\\"%s\\\", \"\ndiff --git a/src/common/types/timestamp.cpp b/src/common/types/timestamp.cpp\nindex db93477afa65..3fc84041bb45 100644\n--- a/src/common/types/timestamp.cpp\n+++ b/src/common/types/timestamp.cpp\n@@ -12,7 +12,6 @@ using namespace std;\n \n namespace duckdb {\n \n-constexpr const int32_t STD_TIMESTAMP_LENGTH = 19;\n constexpr const int32_t TM_START_YEAR = 1900;\n \n // timestamp/datetime uses 64 bits, high 32 bits for date and low 32 bits for time\n@@ -21,33 +20,53 @@ constexpr const int32_t TM_START_YEAR = 1900;\n // Z is optional\n // ISO 8601\n \n-timestamp_t Timestamp::FromString(string str) {\n-\tassert(sizeof(timestamp_t) == 8);\n-\tassert(sizeof(date_t) == 4);\n-\tassert(sizeof(dtime_t) == 4);\n-\n-\t// In case we have only date we add a default time\n-\tif (str.size() == 10) {\n-\t\tstr += \" 00:00:00\";\n+timestamp_t Timestamp::FromCString(const char *str, idx_t len) {\n+\tidx_t pos;\n+\tdate_t date;\n+\tdtime_t time;\n+\tif (!Date::TryConvertDate(str, pos, date)) {\n+\t\tthrow ConversionException(\"timestamp field value out of range: \\\"%s\\\", \"\n+\t\t                          \"expected format is (YYYY-MM-DD HH:MM:SS[.MS])\",\n+\t\t                          str);\n \t}\n-\t// Character length\t19 positions minimum to 23 maximum\n-\tif (str.size() < STD_TIMESTAMP_LENGTH) {\n+\tif (pos == len) {\n+\t\t// no time: only a date\n+\t\treturn (int64_t)date << 32;\n+\t}\n+\t// try to parse a time field\n+\tif (str[pos] == ' ' || str[pos] == 'T') {\n+\t\tpos++;\n+\t}\n+\tidx_t time_pos = 0;\n+\tif (!Time::TryConvertTime(str + pos, time_pos, time)) {\n \t\tthrow ConversionException(\"timestamp field value out of range: \\\"%s\\\", \"\n \t\t                          \"expected format is (YYYY-MM-DD HH:MM:SS[.MS])\",\n-\t\t                          str.c_str());\n+\t\t                          str);\n+\t}\n+\tpos += time_pos;\n+\tif (pos < len) {\n+\t\t// skip a \"Z\" at the end (as per the ISO8601 specs)\n+\t\tif (str[pos] == 'Z') {\n+\t\t\tpos++;\n+\t\t}\n+\t\t// skip any spaces at the end\n+\t\twhile(pos < len && std::isspace(str[pos])) {\n+\t\t\tpos++;\n+\t\t}\n+\t\tif (pos < len) {\n+\t\t\tthrow ConversionException(\"timestamp field value out of range: \\\"%s\\\", \"\n+\t\t\t\t\t\t\t\t\t\"expected format is (YYYY-MM-DD HH:MM:SS[.MS])\",\n+\t\t\t\t\t\t\t\t\tstr);\n+\t\t}\n \t}\n-\n-\tdate_t date = Date::FromString(str.substr(0, 10));\n-\tdtime_t time = Time::FromString(str.substr(10));\n-\n \treturn ((int64_t)date << 32 | (int32_t)time);\n }\n \n-string Timestamp::ToString(timestamp_t timestamp) {\n-\tassert(sizeof(timestamp_t) == 8);\n-\tassert(sizeof(date_t) == 4);\n-\tassert(sizeof(dtime_t) == 4);\n+timestamp_t Timestamp::FromString(string str) {\n+\treturn Timestamp::FromCString(str.c_str(), str.size());\n+}\n \n+string Timestamp::ToString(timestamp_t timestamp) {\n \treturn Date::ToString(GetDate(timestamp)) + \" \" + Time::ToString(GetTime(timestamp));\n }\n \ndiff --git a/src/execution/operator/persistent/buffered_csv_reader.cpp b/src/execution/operator/persistent/buffered_csv_reader.cpp\nindex cc5ea6195f20..2ebd590d4ffb 100644\n--- a/src/execution/operator/persistent/buffered_csv_reader.cpp\n+++ b/src/execution/operator/persistent/buffered_csv_reader.cpp\n@@ -5,7 +5,9 @@\n #include \"duckdb/common/gzip_stream.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/common/vector_operations/vector_operations.hpp\"\n+#include \"duckdb/common/vector_operations/unary_executor.hpp\"\n #include \"duckdb/execution/operator/persistent/physical_copy_from_file.hpp\"\n+#include \"duckdb/function/scalar/strftime.hpp\"\n #include \"duckdb/main/database.hpp\"\n #include \"duckdb/parser/column_definition.hpp\"\n #include \"duckdb/storage/data_table.hpp\"\n@@ -14,11 +16,11 @@\n #include <algorithm>\n #include <cstring>\n #include <fstream>\n-#include <queue>\n \n-using namespace duckdb;\n using namespace std;\n \n+namespace duckdb {\n+\n static char is_newline(char c) {\n \treturn c == '\\n' || c == '\\r';\n }\n@@ -256,6 +258,22 @@ bool BufferedCSVReader::JumpToNextSample() {\n \treturn true;\n }\n \n+bool BufferedCSVReader::TryCastValue(Value value, SQLType sql_type) {\n+\ttry {\n+\t\tif (options.has_date_format && sql_type.id == SQLTypeId::DATE) {\n+\t\t\toptions.date_format.ParseDate(value.str_value);\n+\t\t} else if (options.has_timestamp_format && sql_type.id == SQLTypeId::TIMESTAMP) {\n+\t\t\toptions.timestamp_format.ParseTimestamp(value.str_value);\n+\t\t} else {\n+\t\t\tvalue.CastAs(SQLType::VARCHAR, sql_type, true);\n+\t\t}\n+\t\treturn true;\n+\t} catch (const Exception &e) {\n+\t\treturn false;\n+\t}\n+\treturn false;\n+}\n+\n vector<SQLType> BufferedCSVReader::SniffCSV(vector<SQLType> requested_types) {\n \t// TODO: sniff for uncommon (UTF-8) delimiter variants in first lines and add them to the list\n \tconst vector<string> delim_candidates = {\",\", \"|\", \";\", \"\\t\"};\n@@ -386,10 +404,9 @@ vector<SQLType> BufferedCSVReader::SniffCSV(vector<SQLType> requested_types) {\n \t\t\t\t\tconst auto &sql_type = col_type_candidates.back();\n \t\t\t\t\t// try cast from string to sql_type\n \t\t\t\t\tauto dummy_val = parse_chunk.GetValue(col, row);\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tdummy_val.CastAs(SQLType::VARCHAR, sql_type, true);\n+\t\t\t\t\tif (TryCastValue(dummy_val, sql_type)) {\n \t\t\t\t\t\tbreak;\n-\t\t\t\t\t} catch (const Exception &e) {\n+\t\t\t\t\t} else {\n \t\t\t\t\t\tcol_type_candidates.pop_back();\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -479,12 +496,8 @@ vector<SQLType> BufferedCSVReader::SniffCSV(vector<SQLType> requested_types) {\n \t\t\t// try cast to sql_type of column\n \t\t\tvector<SQLType> &col_type_candidates = best_sql_types_candidates[col];\n \t\t\tconst auto &sql_type = col_type_candidates.back();\n-\n-\t\t\ttry {\n-\t\t\t\tdummy_val.CastAs(SQLType::VARCHAR, sql_type, true);\n-\t\t\t} catch (const Exception &e) {\n+\t\t\tif (!TryCastValue(dummy_val, sql_type)) {\n \t\t\t\tfirst_row_consistent = false;\n-\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t}\n@@ -1084,7 +1097,6 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {\n \tinsert_chunk.SetCardinality(parse_chunk);\n \tfor (idx_t col_idx = 0; col_idx < sql_types.size(); col_idx++) {\n \t\tif (sql_types[col_idx].id == SQLTypeId::VARCHAR) {\n-\n \t\t\t// target type is varchar: no need to convert\n \t\t\t// just test that all strings are valid utf-8 strings\n \t\t\tauto parse_data = FlatVector::GetData<string_t>(parse_chunk.data[col_idx]);\n@@ -1107,8 +1119,17 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\n \t\t\tinsert_chunk.data[col_idx].Reference(parse_chunk.data[col_idx]);\n+\t\t} else if (options.has_date_format && sql_types[col_idx].id == SQLTypeId::DATE) {\n+\t\t\t// use the date format to cast the chunk\n+\t\t\tUnaryExecutor::Execute<string_t, date_t, true>(parse_chunk.data[col_idx], insert_chunk.data[col_idx], parse_chunk.size(), [&](string_t input) {\n+\t\t\t\treturn options.date_format.ParseDate(input);\n+\t\t\t});\n+\t\t} else if (options.has_timestamp_format && sql_types[col_idx].id == SQLTypeId::TIMESTAMP) {\n+\t\t\t// use the date format to cast the chunk\n+\t\t\tUnaryExecutor::Execute<string_t, timestamp_t, true>(parse_chunk.data[col_idx], insert_chunk.data[col_idx], parse_chunk.size(), [&](string_t input) {\n+\t\t\t\treturn options.timestamp_format.ParseTimestamp(input);\n+\t\t\t});\n \t\t} else {\n \t\t\t// target type is not varchar: perform a cast\n \t\t\tVectorOperations::Cast(parse_chunk.data[col_idx], insert_chunk.data[col_idx], SQLType::VARCHAR,\n@@ -1117,3 +1138,5 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {\n \t}\n \tparse_chunk.Reset();\n }\n+\n+}\ndiff --git a/src/function/cast_rules.cpp b/src/function/cast_rules.cpp\nindex 1c41bd3b3ef1..7a6b0b70f421 100644\n--- a/src/function/cast_rules.cpp\n+++ b/src/function/cast_rules.cpp\n@@ -15,6 +15,8 @@ static int64_t TargetTypeCost(SQLType type) {\n \t\treturn 102;\n \tcase SQLTypeId::HUGEINT:\n \t\treturn 120;\n+\tcase SQLTypeId::TIMESTAMP:\n+\t\treturn 120;\n \tcase SQLTypeId::VARCHAR:\n \t\treturn 199;\n \tdefault:\n@@ -105,6 +107,16 @@ static int64_t ImplicitCastHugeint(SQLType to) {\n \t}\n }\n \n+static int64_t ImplicitCastDate(SQLType to) {\n+\tswitch (to.id) {\n+\tcase SQLTypeId::TIMESTAMP:\n+\t\treturn TargetTypeCost(to);\n+\tdefault:\n+\t\treturn -1;\n+\t}\n+}\n+\n+\n int64_t CastRules::ImplicitCast(SQLType from, SQLType to) {\n \tif (to.id == SQLTypeId::ANY) {\n \t\t// anything can be cast to ANY type for no cost\n@@ -137,6 +149,8 @@ int64_t CastRules::ImplicitCast(SQLType from, SQLType to) {\n \t\treturn ImplicitCastFloat(to);\n \tcase SQLTypeId::DOUBLE:\n \t\treturn ImplicitCastDouble(to);\n+\tcase SQLTypeId::DATE:\n+\t\treturn ImplicitCastDate(to);\n \tdefault:\n \t\treturn -1;\n \t}\ndiff --git a/src/function/scalar/date/CMakeLists.txt b/src/function/scalar/date/CMakeLists.txt\nindex 667e3e3fdb55..f8357abfaf01 100644\n--- a/src/function/scalar/date/CMakeLists.txt\n+++ b/src/function/scalar/date/CMakeLists.txt\n@@ -5,7 +5,8 @@ add_library_unity(\n   current.cpp\n   epoch.cpp\n   date_trunc.cpp\n-  date_part.cpp)\n+  date_part.cpp\n+  strftime.cpp)\n set(ALL_OBJECT_FILES\n     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_func_date>\n     PARENT_SCOPE)\ndiff --git a/src/function/scalar/date/age.cpp b/src/function/scalar/date/age.cpp\nindex c10d32177252..01315f9daee1 100644\n--- a/src/function/scalar/date/age.cpp\n+++ b/src/function/scalar/date/age.cpp\n@@ -15,7 +15,7 @@ static void age_function_standard(DataChunk &input, ExpressionState &state, Vect\n \tauto current_timestamp = Timestamp::GetCurrentTimestamp();\n \n \tUnaryExecutor::Execute<timestamp_t, interval_t, true>(input.data[0], result, input.size(), [&](timestamp_t input) {\n-\t\treturn Interval::GetDifference(input, current_timestamp);\n+\t\treturn Interval::GetDifference(current_timestamp, input);\n \t});\n }\n \ndiff --git a/src/function/scalar/date/date_part.cpp b/src/function/scalar/date/date_part.cpp\nindex 9c6d64a30953..6c5a3a4e97ff 100644\n--- a/src/function/scalar/date/date_part.cpp\n+++ b/src/function/scalar/date/date_part.cpp\n@@ -161,7 +161,7 @@ template <> int64_t DayOfYearOperator::Operation(timestamp_t input) {\n \n struct WeekOperator {\n \ttemplate <class TA, class TR> static inline TR Operation(TA input) {\n-\t\treturn Date::ExtractWeekNumber(input);\n+\t\treturn Date::ExtractISOWeekNumber(input);\n \t}\n };\n \n@@ -306,20 +306,15 @@ template <> date_t LastDayOperator::Operation(timestamp_t input) {\n \treturn LastDayOperator::Operation<date_t, date_t>(Timestamp::GetDate(input));\n }\n \n-static string_t s_monthNames[] = {\"January\", \"February\", \"March\",     \"April\",   \"May\",      \"June\",\n-                                  \"July\",    \"August\",   \"September\", \"October\", \"November\", \"December\"};\n-\n struct MonthNameOperator {\n \ttemplate <class TA, class TR> static inline TR Operation(TA input) {\n-\t\treturn s_monthNames[MonthOperator::Operation<TA, int64_t>(input) - 1];\n+\t\treturn Date::MonthNames[MonthOperator::Operation<TA, int64_t>(input) - 1];\n \t}\n };\n \n-static string_t s_dayNames[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n-\n struct DayNameOperator {\n \ttemplate <class TA, class TR> static inline TR Operation(TA input) {\n-\t\treturn s_dayNames[DayOfWeekOperator::Operation<TA, int64_t>(input)];\n+\t\treturn Date::DayNames[DayOfWeekOperator::Operation<TA, int64_t>(input)];\n \t}\n };\n \ndiff --git a/src/function/scalar/date/strftime.cpp b/src/function/scalar/date/strftime.cpp\nnew file mode 100644\nindex 000000000000..e4d366f43bf7\n--- /dev/null\n+++ b/src/function/scalar/date/strftime.cpp\n@@ -0,0 +1,1020 @@\n+#include \"duckdb/function/scalar/date_functions.hpp\"\n+\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+\n+#include \"duckdb/common/types/date.hpp\"\n+#include \"duckdb/common/types/time.hpp\"\n+#include \"duckdb/common/types/timestamp.hpp\"\n+#include \"duckdb/common/types/numeric_helper.hpp\"\n+\n+#include \"duckdb/function/scalar/strftime.hpp\"\n+\n+#include \"duckdb/common/vector_operations/unary_executor.hpp\"\n+\n+#include \"duckdb/execution/expression_executor.hpp\"\n+\n+#include \"re2/re2.h\"\n+\n+namespace duckdb {\n+\n+idx_t StrfTimepecifierSize(StrTimeSpecifier specifier) {\n+\tswitch(specifier) {\n+\tcase StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME:\n+\tcase StrTimeSpecifier::ABBREVIATED_MONTH_NAME:\n+\t\treturn 3;\n+\tcase StrTimeSpecifier::WEEKDAY_DECIMAL:\n+\t\treturn 1;\n+\tcase StrTimeSpecifier::DAY_OF_MONTH_PADDED:\n+\tcase StrTimeSpecifier::MONTH_DECIMAL_PADDED:\n+\tcase StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED:\n+\tcase StrTimeSpecifier::HOUR_24_PADDED:\n+\tcase StrTimeSpecifier::HOUR_12_PADDED:\n+\tcase StrTimeSpecifier::MINUTE_PADDED:\n+\tcase StrTimeSpecifier::SECOND_PADDED:\n+\tcase StrTimeSpecifier::AM_PM:\n+\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:\n+\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:\n+\t\treturn 2;\n+\tcase StrTimeSpecifier::MICROSECOND_PADDED:\n+\t\treturn 6;\n+\tcase StrTimeSpecifier::DAY_OF_YEAR_PADDED:\n+\t\treturn 3;\n+\tdefault:\n+\t\treturn 0;\n+\t}\n+}\n+\n+void StrTimeFormat::AddLiteral(string literal) {\n+\tconstant_size += literal.size();\n+\tliterals.push_back(move(literal));\n+}\n+\n+void StrTimeFormat::AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier) {\n+\tAddLiteral(move(preceding_literal));\n+\tspecifiers.push_back(specifier);\n+}\n+\n+\n+void StrfTimeFormat::AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier) {\n+\tis_date_specifier.push_back(IsDateSpecifier(specifier));\n+\tidx_t specifier_size = StrfTimepecifierSize(specifier);\n+\tif (specifier_size == 0) {\n+\t\t// variable length specifier\n+\t\tvar_length_specifiers.push_back(specifier);\n+\t} else {\n+\t\t// constant size specifier\n+\t\tconstant_size += specifier_size;\n+\t}\n+\tStrTimeFormat::AddFormatSpecifier(move(preceding_literal), specifier);\n+}\n+\n+idx_t StrfTimeFormat::GetSpecifierLength(StrTimeSpecifier specifier, date_t date, time_t time) {\n+\tswitch(specifier) {\n+\tcase StrTimeSpecifier::FULL_WEEKDAY_NAME:\n+\t\treturn Date::DayNames[Date::ExtractISODayOfTheWeek(date) % 7].GetSize();\n+\tcase StrTimeSpecifier::FULL_MONTH_NAME:\n+\t\treturn Date::MonthNames[Date::ExtractMonth(date) - 1].GetSize();\n+\tcase StrTimeSpecifier::YEAR_DECIMAL: {\n+\t\tauto year = Date::ExtractYear(date);\n+\t\treturn NumericHelper::SignedLength<int32_t, uint32_t>(year);\n+\t}\n+\tcase StrTimeSpecifier::MONTH_DECIMAL: {\n+\t\tidx_t len = 1;\n+\t\tauto month = Date::ExtractMonth(date);\n+\t\tlen += month >= 10;\n+\t\treturn len;\n+\t}\n+\tcase StrTimeSpecifier::UTC_OFFSET:\n+\tcase StrTimeSpecifier::TZ_NAME:\n+\t\t// empty for now\n+\t\treturn 0;\n+\tcase StrTimeSpecifier::HOUR_24_DECIMAL:\n+\tcase StrTimeSpecifier::HOUR_12_DECIMAL:\n+\tcase StrTimeSpecifier::MINUTE_DECIMAL:\n+\tcase StrTimeSpecifier::SECOND_DECIMAL: {\n+\t\t// time specifiers\n+\t\tidx_t len = 1;\n+\t\tint32_t hour, min, sec, msec;\n+\t\tTime::Convert(time, hour, min, sec, msec);\n+\t\tswitch(specifier) {\n+\t\tcase StrTimeSpecifier::HOUR_24_DECIMAL:\n+\t\t\tlen += hour >= 10;\n+\t\t\tbreak;\n+\t\tcase StrTimeSpecifier::HOUR_12_DECIMAL:\n+\t\t\thour = hour % 12;\n+\t\t\tif (hour == 0) {\n+\t\t\t\thour = 12;\n+\t\t\t}\n+\t\t\tlen += hour >= 10;\n+\t\t\tbreak;\n+\t\tcase StrTimeSpecifier::MINUTE_DECIMAL:\n+\t\t\tlen += min >= 10;\n+\t\t\tbreak;\n+\t\tcase StrTimeSpecifier::SECOND_DECIMAL:\n+\t\t\tlen += sec >= 10;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn len;\n+\t}\n+\tcase StrTimeSpecifier::DAY_OF_MONTH:\n+\t\treturn NumericHelper::UnsignedLength<uint32_t>(Date::ExtractDay(date));\n+\tcase StrTimeSpecifier::DAY_OF_YEAR_DECIMAL:\n+\t\treturn NumericHelper::UnsignedLength<uint32_t>(Date::ExtractDayOfTheYear(date));\n+\tcase StrTimeSpecifier::YEAR_WITHOUT_CENTURY:\n+\t\treturn NumericHelper::UnsignedLength<uint32_t>(Date::ExtractYear(date) % 100);\n+\tdefault:\n+\t\tthrow NotImplementedException(\"Unimplemented specifier for GetSpecifierLength\");\n+\t}\n+}\n+\n+//! Returns the total length of the date formatted by this format specifier\n+idx_t StrfTimeFormat::GetLength(date_t date, time_t time) {\n+\tidx_t size = constant_size;\n+\tif (var_length_specifiers.size() > 0) {\n+\t\tfor(auto &specifier : var_length_specifiers) {\n+\t\t\tsize += GetSpecifierLength(specifier, date, time);\n+\t\t}\n+\t}\n+\treturn size;\n+}\n+\n+char* StrfTimeFormat::WriteString(char *target, string_t &str) {\n+\tidx_t size = str.GetSize();\n+\tmemcpy(target, str.GetData(), str.GetSize());\n+\treturn target + size;\n+}\n+\n+// write a value in the range of 0..99 unpadded (e.g. \"1\", \"2\", ... \"98\", \"99\")\n+char *StrfTimeFormat::Write2(char *target, uint8_t value) {\n+\tif (value >= 10) {\n+\t\treturn WritePadded2(target, value);\n+\t} else {\n+\t\t*target = '0' + value;\n+\t\treturn target + 1;\n+\t}\n+}\n+\n+// write a value in the range of 0..99 padded to 2 digits\n+char* StrfTimeFormat::WritePadded2(char *target, int32_t value) {\n+\tauto index = static_cast<unsigned>(value * 2);\n+\t*target++ = duckdb_fmt::internal::data::digits[index];\n+\t*target++ = duckdb_fmt::internal::data::digits[index + 1];\n+\treturn target;\n+}\n+\n+// write a value in the range of 0..999 padded\n+char *StrfTimeFormat::WritePadded3(char *target, uint32_t value) {\n+\tif (value >= 100) {\n+\t\tWritePadded2(target + 1, value % 100);\n+\t\t*target = '0' + value / 100;\n+\t\treturn target + 3;\n+\t} else {\n+\t\t*target = '0';\n+\t\ttarget++;\n+\t\treturn WritePadded2(target, value);\n+\t}\n+}\n+\n+// write a value in the range of 0..999999 padded to 6 digits\n+char* StrfTimeFormat::WritePadded(char *target, int32_t value, int32_t padding) {\n+\tassert(padding % 2 == 0);\n+\tfor(int i = 0; i < padding / 2; i++) {\n+\t\tint decimals = value % 100;\n+\t\tWritePadded2(target + padding - 2 * (i + 1), decimals);\n+\t\tvalue /= 100;\n+\t}\n+\treturn target + padding;\n+}\n+\n+bool StrfTimeFormat::IsDateSpecifier(StrTimeSpecifier specifier) {\n+\tswitch(specifier) {\n+\tcase StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME:\n+\tcase StrTimeSpecifier::FULL_WEEKDAY_NAME:\n+\tcase StrTimeSpecifier::WEEKDAY_DECIMAL:\n+\tcase StrTimeSpecifier::DAY_OF_YEAR_PADDED:\n+\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:\n+\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:\n+\tcase StrTimeSpecifier::DAY_OF_YEAR_DECIMAL:\n+\t\treturn true;\n+\tdefault:\n+\t\treturn false;\n+\t}\n+}\n+\n+char* StrfTimeFormat::WriteDateSpecifier(StrTimeSpecifier specifier, date_t date, char *target) {\n+\tswitch(specifier) {\n+\tcase StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME: {\n+\t\tdate_t dow = Date::ExtractISODayOfTheWeek(date);\n+\t\ttarget = WriteString(target, Date::DayNamesAbbreviated[dow % 7]);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::FULL_WEEKDAY_NAME: {\n+\t\tdate_t dow = Date::ExtractISODayOfTheWeek(date);\n+\t\ttarget = WriteString(target, Date::DayNames[dow % 7]);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::WEEKDAY_DECIMAL: {\n+\t\tdate_t dow = Date::ExtractISODayOfTheWeek(date);\n+\t\t*target = '0' + (dow % 7);\n+\t\ttarget++;\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::DAY_OF_YEAR_PADDED: {\n+\t\tint32_t doy = Date::ExtractDayOfTheYear(date);\n+\t\ttarget = WritePadded3(target, doy);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:\n+\t\ttarget = WritePadded2(target, Date::ExtractWeekNumberRegular(date, true));\n+\t\tbreak;\n+\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:\n+\t\ttarget = WritePadded2(target, Date::ExtractWeekNumberRegular(date, false));\n+\t\tbreak;\n+\tcase StrTimeSpecifier::DAY_OF_YEAR_DECIMAL: {\n+\t\tuint32_t doy = Date::ExtractDayOfTheYear(date);\n+\t\ttarget += NumericHelper::UnsignedLength<uint32_t>(doy);\n+\t\tNumericHelper::FormatUnsigned(doy, target);\n+\t\tbreak;\n+\t}\n+\tdefault:\n+\t\tthrow NotImplementedException(\"Unimplemented date specifier for strftime\");\n+\t}\n+\treturn target;\n+}\n+\n+char* StrfTimeFormat::WriteStandardSpecifier(StrTimeSpecifier specifier, int32_t data[], char *target) {\n+\t// data contains [0] year, [1] month, [2] day, [3] hour, [4] minute, [5] second, [6] msec\n+\tswitch(specifier) {\n+\tcase StrTimeSpecifier::DAY_OF_MONTH_PADDED:\n+\t\ttarget = WritePadded2(target, data[2]);\n+\t\tbreak;\n+\tcase StrTimeSpecifier::ABBREVIATED_MONTH_NAME: {\n+\t\tauto &month_name = Date::MonthNamesAbbreviated[data[1] - 1];\n+\t\treturn WriteString(target, month_name);\n+\t}\n+\tcase StrTimeSpecifier::FULL_MONTH_NAME: {\n+\t\tauto &month_name = Date::MonthNames[data[1] - 1];\n+\t\treturn WriteString(target, month_name);\n+\t}\n+\tcase StrTimeSpecifier::MONTH_DECIMAL_PADDED:\n+\t\ttarget = WritePadded2(target, data[1]);\n+\t\tbreak;\n+\tcase StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED:\n+\t\ttarget = WritePadded2(target, data[0] % 100);\n+\t\tbreak;\n+\tcase StrTimeSpecifier::YEAR_DECIMAL:\n+\t\tif (data[0] >= 0 && data[0] <= 9999) {\n+\t\t\ttarget = WritePadded(target, data[0], 4);\n+\t\t} else {\n+\t\t\tint32_t year = data[0];\n+\t\t\tif (data[0] < 0) {\n+\t\t\t\t*target = '-';\n+\t\t\t\tyear = -year;\n+\t\t\t\ttarget++;\n+\t\t\t}\n+\t\t\tauto len = NumericHelper::UnsignedLength<uint32_t>(year);\n+\t\t\tNumericHelper::FormatUnsigned(year, target + len);\n+\t\t\ttarget += len;\n+\t\t}\n+\t\tbreak;\n+\tcase StrTimeSpecifier::HOUR_24_PADDED: {\n+\t\ttarget = WritePadded2(target, data[3]);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::HOUR_12_PADDED: {\n+\t\tint hour = data[3] % 12;\n+\t\tif (hour == 0) {\n+\t\t\thour = 12;\n+\t\t}\n+\t\ttarget = WritePadded2(target, hour);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::AM_PM:\n+\t\t*target++ = data[3] >= 12 ? 'P' : 'A';\n+\t\t*target++ = 'M';\n+\t\tbreak;\n+\tcase StrTimeSpecifier::MINUTE_PADDED: {\n+\t\ttarget = WritePadded2(target, data[4]);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::SECOND_PADDED:\n+\t\ttarget = WritePadded2(target, data[5]);\n+\t\tbreak;\n+\tcase StrTimeSpecifier::MICROSECOND_PADDED:\n+\t\ttarget = WritePadded(target, data[6] * 1000, 6);\n+\t\tbreak;\n+\tcase StrTimeSpecifier::UTC_OFFSET:\n+\tcase StrTimeSpecifier::TZ_NAME:\n+\t\t// always empty for now, FIXME when we have timestamp with tz\n+\t\tbreak;\n+\tcase StrTimeSpecifier::DAY_OF_MONTH: {\n+\t\ttarget = Write2(target, data[2] % 100);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::MONTH_DECIMAL: {\n+\t\ttarget = Write2(target, data[1]);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::YEAR_WITHOUT_CENTURY: {\n+\t\ttarget = Write2(target, data[0] % 100);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::HOUR_24_DECIMAL: {\n+\t\ttarget = Write2(target, data[3]);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::HOUR_12_DECIMAL: {\n+\t\tint hour = data[3] % 12;\n+\t\tif (hour == 0) {\n+\t\t\thour = 12;\n+\t\t}\n+\t\ttarget = Write2(target, hour);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::MINUTE_DECIMAL: {\n+\t\ttarget = Write2(target, data[4]);\n+\t\tbreak;\n+\t}\n+\tcase StrTimeSpecifier::SECOND_DECIMAL: {\n+\t\ttarget = Write2(target, data[5]);\n+\t\tbreak;\n+\t}\n+\tdefault:\n+\t\tthrow NotImplementedException(\"Unimplemented specifier for WriteStandardSpecifier in strftime\");\n+\t}\n+\treturn target;\n+}\n+\n+void StrfTimeFormat::FormatString(date_t date, int32_t data[7], char *target) {\n+\tidx_t i;\n+\tfor(i = 0; i < specifiers.size(); i++) {\n+\t\t// first copy the current literal\n+\t\tmemcpy(target, literals[i].c_str(), literals[i].size());\n+\t\ttarget += literals[i].size();\n+\t\t// now copy the specifier\n+\t\tif (is_date_specifier[i]) {\n+\t\t\ttarget = WriteDateSpecifier(specifiers[i], date, target);\n+\t\t} else {\n+\t\t\ttarget = WriteStandardSpecifier(specifiers[i], data, target);\n+\t\t}\n+\t}\n+\t// copy the final literal into the target\n+\tmemcpy(target, literals[i].c_str(), literals[i].size());\n+\n+}\n+\n+void StrfTimeFormat::FormatString(date_t date, time_t time, char *target) {\n+\tint32_t data[7]; // year, month, day, hour, min, sec, msec\n+\tDate::Convert(date, data[0], data[1], data[2]);\n+\tTime::Convert(time, data[3], data[4], data[5], data[6]);\n+\n+\tFormatString(date, data, target);\n+}\n+\n+string StrTimeFormat::ParseFormatSpecifier(string format_string, StrTimeFormat &format) {\n+\tformat.constant_size = 0;\n+\tidx_t pos = 0;\n+\tstring current_literal;\n+\tfor(idx_t i = 0; i < format_string.size(); i++) {\n+\t\tif (format_string[i] == '%') {\n+\t\t\tif (i + 1 == format_string.size()) {\n+\t\t\t\treturn \"Trailing format character %\";\n+\t\t\t}\n+\t\t\tif (i > pos) {\n+\t\t\t\t// push the previous string to the current literal\n+\t\t\t\tcurrent_literal += format_string.substr(pos, i - pos);\n+\t\t\t}\n+\t\t\tchar format_char = format_string[++i];\n+\t\t\tif (format_char == '%') {\n+\t\t\t\t// special case: %%\n+\t\t\t\t// set the pos for the next literal and continue\n+\t\t\t\tpos = i;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tStrTimeSpecifier specifier;\n+\t\t\tif (format_char == '-' && i + 1 < format_string.size()) {\n+\t\t\t\tformat_char = format_string[++i];\n+\t\t\t\tswitch(format_char) {\n+\t\t\t\tcase 'd':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::DAY_OF_MONTH;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'm':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::MONTH_DECIMAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'y':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::YEAR_WITHOUT_CENTURY;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'H':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::HOUR_24_DECIMAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'I':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::HOUR_12_DECIMAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'M':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::MINUTE_DECIMAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'S':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::SECOND_DECIMAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'j':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::DAY_OF_YEAR_DECIMAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\treturn \"Unrecognized format for strftime/strptime: %-\" + string(format_char, 1);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tswitch(format_char) {\n+\t\t\t\tcase 'a':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'A':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::FULL_WEEKDAY_NAME;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'w':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::WEEKDAY_DECIMAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'd':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::DAY_OF_MONTH_PADDED;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'h':\n+\t\t\t\tcase 'b':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::ABBREVIATED_MONTH_NAME;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'B':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::FULL_MONTH_NAME;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'm':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::MONTH_DECIMAL_PADDED;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'y':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'Y':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::YEAR_DECIMAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'H':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::HOUR_24_PADDED;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'I':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::HOUR_12_PADDED;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'p':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::AM_PM;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'M':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::MINUTE_PADDED;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'S':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::SECOND_PADDED;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'f':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::MICROSECOND_PADDED;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'z':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::UTC_OFFSET;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'Z':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::TZ_NAME;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'j':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::DAY_OF_YEAR_PADDED;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'U':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'W':\n+\t\t\t\t\tspecifier = StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'c':\n+\t\t\t\tcase 'x':\n+\t\t\t\tcase 'X': {\n+\t\t\t\t\tstring subformat;\n+\t\t\t\t\tif (format_char == 'c') {\n+\t\t\t\t\t\t// %c: Locale\u2019s appropriate date and time representation.\n+\t\t\t\t\t\t// we push the ISO timestamp representation here\n+\t\t\t\t\t\tsubformat = \"%Y-%m-%d %H:%M:%S\";\n+\t\t\t\t\t} else if (format_char == 'x') {\n+\t\t\t\t\t\t// %x - Locale\u2019s appropriate date representation.\n+\t\t\t\t\t\t// we push the ISO date format here\n+\t\t\t\t\t\tsubformat = \"%Y-%m-%d\";\n+\t\t\t\t\t} else if (format_char == 'X') {\n+\t\t\t\t\t\t// %X - Locale\u2019s appropriate time representation.\n+\t\t\t\t\t\t// we push the ISO time format here\n+\t\t\t\t\t\tsubformat = \"%H:%M:%S\";\n+\t\t\t\t\t}\n+\t\t\t\t\t// parse the subformat in a separate format specifier\n+\t\t\t\t\tStrfTimeFormat locale_format;\n+\t\t\t\t\tstring error = StrTimeFormat::ParseFormatSpecifier(subformat, locale_format);\n+\t\t\t\t\tassert(error.empty());\n+\t\t\t\t\t// add the previous literal to the first literal of the subformat\n+\t\t\t\t\tlocale_format.literals[0] = move(current_literal) + locale_format.literals[0];\n+\t\t\t\t\t// now push the subformat into the current format specifier\n+\t\t\t\t\tfor(idx_t i = 0; i < locale_format.specifiers.size(); i++) {\n+\t\t\t\t\t\tformat.AddFormatSpecifier(move(locale_format.literals[i]), locale_format.specifiers[i]);\n+\t\t\t\t\t}\n+\t\t\t\t\tpos = i + 1;\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tdefault:\n+\t\t\t\t\treturn \"Unrecognized format for strftime/strptime: %\" + string(format_char, 1);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tformat.AddFormatSpecifier(move(current_literal), specifier);\n+\t\t\tpos = i + 1;\n+\t\t}\n+\t}\n+\t// add the final literal\n+\tif (pos < format_string.size()) {\n+\t\tcurrent_literal += format_string.substr(pos, format_string.size() - pos);\n+\t}\n+\tformat.AddLiteral(move(current_literal));\n+\treturn string();\n+}\n+\n+struct StrfTimeBindData : public FunctionData {\n+\tStrfTimeBindData(StrfTimeFormat format) : format(move(format)) {}\n+\n+\tStrfTimeFormat format;\n+\n+\tunique_ptr<FunctionData> Copy() override {\n+\t\treturn make_unique<StrfTimeBindData>(format);\n+\t}\n+};\n+\n+static unique_ptr<FunctionData> strftime_bind_function(BoundFunctionExpression &expr, ClientContext &context) {\n+\tif (!expr.children[1]->IsScalar()) {\n+\t\tthrow InvalidInputException(\"strftime format must be a constant\");\n+\t}\n+\tValue options_str = ExpressionExecutor::EvaluateScalar(*expr.children[1]);\n+\tStrfTimeFormat format;\n+\tif (!options_str.is_null && options_str.type == TypeId::VARCHAR) {\n+\t\tstring error = StrTimeFormat::ParseFormatSpecifier(options_str.str_value, format);\n+\t\tif (!error.empty()) {\n+\t\t\tthrow InvalidInputException(\"Failed to parse format specifier %s: %s\", options_str.str_value.c_str(), error.c_str());\n+\t\t}\n+\t}\n+\treturn make_unique<StrfTimeBindData>(format);\n+}\n+\n+static void strftime_function_date(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tauto &func_expr = (BoundFunctionExpression &)state.expr;\n+\tauto &info = (StrfTimeBindData &)*func_expr.bind_info;\n+\n+\tif (ConstantVector::IsNull(args.data[1])) {\n+\t\tresult.vector_type = VectorType::CONSTANT_VECTOR;\n+\t\tConstantVector::SetNull(result, true);\n+\t\treturn;\n+\t}\n+\n+\ttime_t time = 0;\n+\tUnaryExecutor::Execute<date_t, string_t, true>(args.data[0], result, args.size(), [&](date_t date) {\n+\t\tidx_t len = info.format.GetLength(date, time);\n+\t\tstring_t target = StringVector::EmptyString(result, len);\n+\t\tinfo.format.FormatString(date, time, target.GetData());\n+\t\ttarget.Finalize();\n+\t\treturn target;\n+\t});\n+}\n+\n+static void strftime_function_timestamp(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tauto &func_expr = (BoundFunctionExpression &)state.expr;\n+\tauto &info = (StrfTimeBindData &)*func_expr.bind_info;\n+\n+\tif (ConstantVector::IsNull(args.data[1])) {\n+\t\tresult.vector_type = VectorType::CONSTANT_VECTOR;\n+\t\tConstantVector::SetNull(result, true);\n+\t\treturn;\n+\t}\n+\n+\tUnaryExecutor::Execute<timestamp_t, string_t, true>(args.data[0], result, args.size(), [&](timestamp_t timestamp) {\n+\t\tdate_t date;\n+\t\tdtime_t time;\n+\t\tTimestamp::Convert(timestamp, date, time);\n+\t\tidx_t len = info.format.GetLength(date, time);\n+\t\tstring_t target = StringVector::EmptyString(result, len);\n+\t\tinfo.format.FormatString(date, time, target.GetData());\n+\t\ttarget.Finalize();\n+\t\treturn target;\n+\t});\n+}\n+\n+void StrfTimeFun::RegisterFunction(BuiltinFunctions &set) {\n+\tScalarFunctionSet strftime(\"strftime\");\n+\n+\tstrftime.AddFunction(ScalarFunction({SQLType::DATE, SQLType::VARCHAR}, SQLType::VARCHAR,\n+\t                               strftime_function_date, false, strftime_bind_function));\n+\n+\tstrftime.AddFunction(ScalarFunction({SQLType::TIMESTAMP, SQLType::VARCHAR}, SQLType::VARCHAR,\n+\t                               strftime_function_timestamp, false, strftime_bind_function));\n+\n+\tset.AddFunction(strftime);\n+}\n+\n+void StrpTimeFormat::AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier) {\n+\tswitch(specifier) {\n+\tcase StrTimeSpecifier::DAY_OF_YEAR_PADDED:\n+\tcase StrTimeSpecifier::DAY_OF_YEAR_DECIMAL:\n+\tcase StrTimeSpecifier::WEEKDAY_DECIMAL:\n+\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:\n+\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:\n+\t\tthrow NotImplementedException(\"Unimplemented specifier for strptime\");\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\tis_numeric.push_back(IsNumericSpecifier(specifier));\n+\tStrTimeFormat::AddFormatSpecifier(move(preceding_literal), specifier);\n+}\n+\n+bool StrpTimeFormat::IsNumericSpecifier(StrTimeSpecifier specifier) {\n+\tswitch(specifier) {\n+\tcase StrTimeSpecifier::WEEKDAY_DECIMAL:\n+\tcase StrTimeSpecifier::DAY_OF_MONTH_PADDED:\n+\tcase StrTimeSpecifier::DAY_OF_MONTH:\n+\tcase StrTimeSpecifier::MONTH_DECIMAL_PADDED:\n+\tcase StrTimeSpecifier::MONTH_DECIMAL:\n+\tcase StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED:\n+\tcase StrTimeSpecifier::YEAR_WITHOUT_CENTURY:\n+\tcase StrTimeSpecifier::YEAR_DECIMAL:\n+\tcase StrTimeSpecifier::HOUR_24_PADDED:\n+\tcase StrTimeSpecifier::HOUR_24_DECIMAL:\n+\tcase StrTimeSpecifier::HOUR_12_PADDED:\n+\tcase StrTimeSpecifier::HOUR_12_DECIMAL:\n+\tcase StrTimeSpecifier::MINUTE_PADDED:\n+\tcase StrTimeSpecifier::MINUTE_DECIMAL:\n+\tcase StrTimeSpecifier::SECOND_PADDED:\n+\tcase StrTimeSpecifier::SECOND_DECIMAL:\n+\tcase StrTimeSpecifier::MICROSECOND_PADDED:\n+\tcase StrTimeSpecifier::DAY_OF_YEAR_PADDED:\n+\tcase StrTimeSpecifier::DAY_OF_YEAR_DECIMAL:\n+\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:\n+\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:\n+\t\treturn true;\n+\tdefault:\n+\t\treturn false;\n+\t}\n+}\n+\n+enum class TimeSpecifierAMOrPM : uint8_t {\n+\tTIME_SPECIFIER_NONE = 0,\n+\tTIME_SPECIFIER_AM = 1,\n+\tTIME_SPECIFIER_PM = 2\n+};\n+\n+int32_t StrpTimeFormat::TryParseCollection(const char *data, idx_t &pos, idx_t size, string_t collection[], idx_t collection_count) {\n+\tfor(idx_t c = 0; c < collection_count; c++) {\n+\t\tauto &entry = collection[c];\n+\t\tauto entry_data = entry.GetData();\n+\t\tauto entry_size = entry.GetSize();\n+\t\t// check if this entry matches\n+\t\tif (pos + entry_size > size) {\n+\t\t\t// too big: can't match\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// compare the characters\n+\t\tidx_t i;\n+\t\tfor(i = 0; i < entry_size; i++) {\n+\t\t\tif (std::tolower(entry_data[i]) != std::tolower(data[pos + i])) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tif (i == entry_size) {\n+\t\t\t// full match\n+\t\t\tpos += entry_size;\n+\t\t\treturn c;\n+\t\t}\n+\t}\n+\treturn -1;\n+}\n+\n+//! Parses a timestamp using the given specifier\n+bool StrpTimeFormat::Parse(string_t str, int32_t result_data[], string &error_message, idx_t &error_position) {\n+\t// initialize the result\n+\tresult_data[0] = 1900;\n+\tresult_data[1] = 1;\n+\tresult_data[2] = 1;\n+\tresult_data[3] = 0;\n+\tresult_data[4] = 0;\n+\tresult_data[5] = 0;\n+\tresult_data[6] = 0;\n+\n+\tauto data = str.GetData();\n+\tidx_t size = str.GetSize();\n+\t// skip leading spaces\n+\twhile(std::isspace(*data)) {\n+\t\tdata++;\n+\t\tsize--;\n+\t}\n+\tidx_t pos = 0;\n+\tTimeSpecifierAMOrPM ampm = TimeSpecifierAMOrPM::TIME_SPECIFIER_NONE;\n+\n+\tfor(idx_t i = 0; ; i++) {\n+\t\t// first compare the literal\n+\t\tif (literals[i].size() > (size - pos) || memcmp(data + pos, literals[i].c_str(), literals[i].size()) != 0) {\n+\t\t\t// literal does not match\n+\t\t\terror_message = \"Literal does not match, expected \" + literals[i];\n+\t\t\terror_position = pos;\n+\t\t\treturn false;\n+\t\t}\n+\t\tpos += literals[i].size();\n+\t\tif (i == specifiers.size()) {\n+\t\t\tbreak;\n+\t\t}\n+\t\t// now parse the specifier\n+\t\tif (is_numeric[i]) {\n+\t\t\t// numeric specifier: parse a number\n+\t\t\tuint64_t number = 0;\n+\t\t\tsize_t start_pos = pos;\n+\t\t\twhile(pos < size && std::isdigit(data[pos])) {\n+\t\t\t\tif (number > 1000000ULL) {\n+\t\t\t\t\t// no number bigger than this is required anywhere\n+\t\t\t\t\terror_message = \"Number is out of range of format specifier\";\n+\t\t\t\t\terror_position = start_pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tnumber = number * 10 + data[pos] - '0';\n+\t\t\t\tpos++;\n+\t\t\t}\n+\t\t\tif (pos == start_pos) {\n+\t\t\t\t// expected a number here\n+\t\t\t\terror_message = \"Expected a number\";\n+\t\t\t\terror_position = start_pos;\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tswitch(specifiers[i]) {\n+\t\t\tcase StrTimeSpecifier::DAY_OF_MONTH_PADDED:\n+\t\t\tcase StrTimeSpecifier::DAY_OF_MONTH:\n+\t\t\t\tif (number < 1 || number > 31) {\n+\t\t\t\t\terror_message = \"Day out of range, expected a value between 1 and 31\";\n+\t\t\t\t\terror_position = start_pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\t// day of the month\n+\t\t\t\tresult_data[2] = number;\n+\t\t\t\tbreak;\n+\t\t\tcase StrTimeSpecifier::MONTH_DECIMAL_PADDED:\n+\t\t\tcase StrTimeSpecifier::MONTH_DECIMAL:\n+\t\t\t\tif (number < 1 || number > 12) {\n+\t\t\t\t\terror_message = \"Month out of range, expected a value between 1 and 12\";\n+\t\t\t\t\terror_position = start_pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\t// month number\n+\t\t\t\tresult_data[1] = number;\n+\t\t\t\tbreak;\n+\t\t\tcase StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED:\n+\t\t\tcase StrTimeSpecifier::YEAR_WITHOUT_CENTURY:\n+\t\t\t\t// year without century..\n+\t\t\t\t// Python uses 69 as a crossover point (i.e. >= 69 is 19.., < 69 is 20..)\n+\t\t\t\tif (number >= 100) {\n+\t\t\t\t\t// %y only supports numbers between [0..99]\n+\t\t\t\t\terror_message = \"Year without century out of range, expected a value between 0 and 99\";\n+\t\t\t\t\terror_position = start_pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tif (number >= 69) {\n+\t\t\t\t\tresult_data[0] = 1900 + number;\n+\t\t\t\t} else {\n+\t\t\t\t\tresult_data[0] = 2000 + number;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase StrTimeSpecifier::YEAR_DECIMAL:\n+\t\t\t\t// year as full number\n+\t\t\t\tresult_data[0] = number;\n+\t\t\t\tbreak;\n+\t\t\tcase StrTimeSpecifier::HOUR_24_PADDED:\n+\t\t\tcase StrTimeSpecifier::HOUR_24_DECIMAL:\n+\t\t\t\tif (number >= 24) {\n+\t\t\t\t\terror_message = \"Hour out of range, expected a value between 0 and 23\";\n+\t\t\t\t\terror_position = start_pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\t// hour as full number\n+\t\t\t\tresult_data[3] = number;\n+\t\t\t\tbreak;\n+\t\t\tcase StrTimeSpecifier::HOUR_12_PADDED:\n+\t\t\tcase StrTimeSpecifier::HOUR_12_DECIMAL:\n+\t\t\t\tif (number < 1 || number > 12) {\n+\t\t\t\t\terror_message = \"Hour12 out of range, expected a value between 1 and 12\";\n+\t\t\t\t\terror_position = start_pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\t// 12-hour number: start off by just storing the number\n+\t\t\t\tresult_data[3] = number;\n+\t\t\t\tbreak;\n+\t\t\tcase StrTimeSpecifier::MINUTE_PADDED:\n+\t\t\tcase StrTimeSpecifier::MINUTE_DECIMAL:\n+\t\t\t\tif (number >= 60) {\n+\t\t\t\t\terror_message = \"Minutes out of range, expected a value between 0 and 59\";\n+\t\t\t\t\terror_position = start_pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\t// minutes\n+\t\t\t\tresult_data[4] = number;\n+\t\t\t\tbreak;\n+\t\t\tcase StrTimeSpecifier::SECOND_PADDED:\n+\t\t\tcase StrTimeSpecifier::SECOND_DECIMAL:\n+\t\t\t\tif (number >= 60) {\n+\t\t\t\t\terror_message = \"Seconds out of range, expected a value between 0 and 59\";\n+\t\t\t\t\terror_position = start_pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\t// seconds\n+\t\t\t\tresult_data[5] = number;\n+\t\t\t\tbreak;\n+\t\t\tcase StrTimeSpecifier::MICROSECOND_PADDED:\n+\t\t\t\tif (number >= 1000000ULL) {\n+\t\t\t\t\terror_message = \"Microseconds out of range, expected a value between 0 and 999999\";\n+\t\t\t\t\terror_position = start_pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\t// microseconds\n+\t\t\t\tresult_data[6] = number * 1000;\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow NotImplementedException(\"Unsupported specifier for strptime\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\tswitch(specifiers[i]) {\n+\t\t\tcase StrTimeSpecifier::AM_PM: {\n+\t\t\t\t// parse the next 2 characters\n+\t\t\t\tif (pos + 2 > size) {\n+\t\t\t\t\t// no characters left to parse\n+\t\t\t\t\terror_message = \"Expected AM/PM\";\n+\t\t\t\t\terror_position = pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tchar pa_char = std::tolower(data[pos]);\n+\t\t\t\tchar m_char = std::tolower(data[pos + 1]);\n+\t\t\t\tif (m_char != 'm') {\n+\t\t\t\t\terror_message = \"Expected AM/PM\";\n+\t\t\t\t\terror_position = pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tif (pa_char == 'p') {\n+\t\t\t\t\tampm = TimeSpecifierAMOrPM::TIME_SPECIFIER_PM;\n+\t\t\t\t} else if (pa_char == 'a') {\n+\t\t\t\t\tampm = TimeSpecifierAMOrPM::TIME_SPECIFIER_AM;\n+\t\t\t\t} else {\n+\t\t\t\t\terror_message = \"Expected AM/PM\";\n+\t\t\t\t\terror_position = pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tpos += 2;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\t// we parse weekday names, but we don't use them as information\n+\t\t\tcase StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME:\n+\t\t\t\tif (TryParseCollection(data, pos, size, Date::DayNamesAbbreviated, 7) < 0) {\n+\t\t\t\t\terror_message = \"Expected an abbreviated day name (Mon, Tue, Wed, Thu, Fri, Sat, Sun)\";\n+\t\t\t\t\terror_position = pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase StrTimeSpecifier::FULL_WEEKDAY_NAME:\n+\t\t\t\tif (TryParseCollection(data, pos, size, Date::DayNames, 7) < 0) {\n+\t\t\t\t\terror_message = \"Expected a full day name (Monday, Tuesday, etc...)\";\n+\t\t\t\t\terror_position = pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase StrTimeSpecifier::ABBREVIATED_MONTH_NAME: {\n+\t\t\t\tint32_t month = TryParseCollection(data, pos, size, Date::MonthNamesAbbreviated, 12);\n+\t\t\t\tif (month < 0) {\n+\t\t\t\t\terror_message = \"Expected an abbreviated month name (Jan, Feb, Mar, etc..)\";\n+\t\t\t\t\terror_position = pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tresult_data[1] = month + 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tcase StrTimeSpecifier::FULL_MONTH_NAME: {\n+\t\t\t\tint32_t month = TryParseCollection(data, pos, size, Date::MonthNames, 12);\n+\t\t\t\tif (month < 0) {\n+\t\t\t\t\terror_message = \"Expected a full month name (January, February, etc...)\";\n+\t\t\t\t\terror_position = pos;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tresult_data[1] = month + 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tthrow NotImplementedException(\"Unsupported specifier for strptime\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\t// skip trailing spaces\n+\twhile(std::isspace(data[pos])) {\n+\t\tpos++;\n+\t}\n+\tif (pos != size) {\n+\t\terror_message = \"Full specifier did not match: trailing characters\";\n+\t\terror_position = pos;\n+\t\treturn false;\n+\t}\n+\tif (ampm != TimeSpecifierAMOrPM::TIME_SPECIFIER_NONE) {\n+\t\t// fixme: adjust the hours based on the AM or PM specifier\n+\t\tif (ampm == TimeSpecifierAMOrPM::TIME_SPECIFIER_AM) {\n+\t\t\t// AM: 12AM=0, 1AM=1, 2AM=2, ..., 11AM=11\n+\t\t\tif (result_data[3] == 12) {\n+\t\t\t\tresult_data[3] = 0;\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// PM: 12PM=12, 1PM=13, 2PM=14, ..., 11PM=23\n+\t\t\tif (result_data[3] != 12) {\n+\t\t\t\tresult_data[3] += 12;\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn true;\n+}\n+\n+struct StrpTimeBindData : public FunctionData {\n+\tStrpTimeBindData(StrpTimeFormat format) : format(move(format)) {}\n+\n+\tStrpTimeFormat format;\n+\n+\tunique_ptr<FunctionData> Copy() override {\n+\t\treturn make_unique<StrpTimeBindData>(format);\n+\t}\n+};\n+\n+static unique_ptr<FunctionData> strptime_bind_function(BoundFunctionExpression &expr, ClientContext &context) {\n+\tif (!expr.children[1]->IsScalar()) {\n+\t\tthrow InvalidInputException(\"strftime format must be a constant\");\n+\t}\n+\tValue options_str = ExpressionExecutor::EvaluateScalar(*expr.children[1]);\n+\tStrpTimeFormat format;\n+\tif (!options_str.is_null && options_str.type == TypeId::VARCHAR) {\n+\t\tformat.format_specifier = options_str.str_value;\n+\t\tstring error = StrTimeFormat::ParseFormatSpecifier(options_str.str_value, format);\n+\t\tif (!error.empty()) {\n+\t\t\tthrow InvalidInputException(\"Failed to parse format specifier %s: %s\", options_str.str_value.c_str(), error.c_str());\n+\t\t}\n+\t}\n+\treturn make_unique<StrpTimeBindData>(format);\n+}\n+\n+string StrpTimeFormat::FormatStrpTimeError(string input, idx_t position) {\n+\tif (position == INVALID_INDEX) {\n+\t\treturn string();\n+\t}\n+\treturn input + \"\\n\" + string(position, ' ') + \"^\";\n+}\n+\n+date_t StrpTimeFormat::ParseDate(string_t input) {\n+\tstring error_message;\n+\tidx_t error_position = INVALID_INDEX;\n+\tint32_t result_data[7];\n+\tif (!Parse(input, result_data, error_message, error_position)) {\n+\t\tthrow InvalidInputException(\"Could not parse string \\\"%s\\\" according to format specifier \\\"%s\\\"\\n%s\\nError: %s\",\n+\t\t\tinput.GetData(),\n+\t\t\tformat_specifier.c_str(),\n+\t\t\tFormatStrpTimeError(string(input.GetData(), input.GetSize()), error_position).c_str(),\n+\t\t\terror_message.c_str());\n+\t}\n+\treturn Date::FromDate(result_data[0], result_data[1], result_data[2]);\n+}\n+\n+timestamp_t StrpTimeFormat::ParseTimestamp(string_t input) {\n+\tstring error_message;\n+\tidx_t error_position = INVALID_INDEX;\n+\tint32_t result_data[7];\n+\tif (!Parse(input, result_data, error_message, error_position)) {\n+\t\tthrow InvalidInputException(\"Could not parse string \\\"%s\\\" according to format specifier \\\"%s\\\"\\n%s\\nError: %s\",\n+\t\t\tinput.GetData(),\n+\t\t\tformat_specifier.c_str(),\n+\t\t\tFormatStrpTimeError(string(input.GetData(), input.GetSize()), error_position).c_str(),\n+\t\t\terror_message.c_str());\n+\t}\n+\tdate_t date = Date::FromDate(result_data[0], result_data[1], result_data[2]);\n+\tdtime_t time = Time::FromTime(result_data[3], result_data[4], result_data[5], result_data[6]);\n+\treturn Timestamp::FromDatetime(date, time);\n+}\n+\n+static void strptime_function(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tauto &func_expr = (BoundFunctionExpression &)state.expr;\n+\tauto &info = (StrpTimeBindData &)*func_expr.bind_info;\n+\n+\tif (ConstantVector::IsNull(args.data[1])) {\n+\t\tresult.vector_type = VectorType::CONSTANT_VECTOR;\n+\t\tConstantVector::SetNull(result, true);\n+\t\treturn;\n+\t}\n+\tUnaryExecutor::Execute<string_t, timestamp_t, true>(args.data[0], result, args.size(), [&](string_t input) {\n+\t\treturn info.format.ParseTimestamp(input);\n+\t});\n+}\n+\n+void StrpTimeFun::RegisterFunction(BuiltinFunctions &set) {\n+\tScalarFunctionSet strptime(\"strptime\");\n+\n+\tstrptime.AddFunction(ScalarFunction({SQLType::VARCHAR, SQLType::VARCHAR}, SQLType::TIMESTAMP,\n+\t                               strptime_function, false, strptime_bind_function));\n+\n+\tset.AddFunction(strptime);\n+}\n+\n+\n+}\ndiff --git a/src/function/scalar/date_functions.cpp b/src/function/scalar/date_functions.cpp\nindex 78c8cd84dcb8..9a334f241dc3 100644\n--- a/src/function/scalar/date_functions.cpp\n+++ b/src/function/scalar/date_functions.cpp\n@@ -11,4 +11,6 @@ void BuiltinFunctions::RegisterDateFunctions() {\n \tRegister<CurrentDateFun>();\n \tRegister<CurrentTimestampFun>();\n \tRegister<EpochFun>();\n+\tRegister<StrfTimeFun>();\n+\tRegister<StrpTimeFun>();\n }\ndiff --git a/src/function/table/copy_csv.cpp b/src/function/table/copy_csv.cpp\nindex 57bbe1293d5a..20eb83f12f7d 100644\n--- a/src/function/table/copy_csv.cpp\n+++ b/src/function/table/copy_csv.cpp\n@@ -60,6 +60,14 @@ struct ReadCSVData : public BaseCSVData {\n \tvector<SQLType> sql_types;\n \t//! True, if column with that index must be quoted\n \tvector<bool> force_not_null;\n+\t//! The DATE_FORMAT to use to read or write dates\n+\tStrpTimeFormat date_format;\n+\t//! Whether or not there is a date format specified\n+\tbool has_date_format = false;\n+\t//! The DATE_FORMAT to use to read or write dates\n+\tStrpTimeFormat timestamp_format;\n+\t//! Whether or not there is a date format specified\n+\tbool has_timestamp_format = false;\n };\n \n void SubstringDetection(string &str_1, string &str_2, string name_str_1, string name_str_2) {\n@@ -226,6 +234,22 @@ static unique_ptr<FunctionData> read_csv_bind(ClientContext &context, CopyInfo &\n \t\t\tcontinue;\n \t\t} else if (loption == \"force_not_null\") {\n \t\t\tbind_data->force_not_null = ParseColumnList(set, expected_names);\n+\t\t}  else if (loption == \"date_format\" || loption == \"dateformat\") {\n+\t\t\tstring format = ParseString(set);\n+\t\t\tstring error = StrTimeFormat::ParseFormatSpecifier(format, bind_data->date_format);\n+\t\t\tbind_data->date_format.format_specifier = format;\n+\t\t\tif (!error.empty()) {\n+\t\t\t\tthrow InvalidInputException(\"Could not parse DATEFORMAT: %s\", error.c_str());\n+\t\t\t}\n+\t\t\tbind_data->has_date_format = true;\n+\t\t} else if (loption == \"timestamp_format\" || loption == \"timestampformat\") {\n+\t\t\tstring format = ParseString(set);\n+\t\t\tstring error = StrTimeFormat::ParseFormatSpecifier(format, bind_data->timestamp_format);\n+\t\t\tbind_data->timestamp_format.format_specifier = format;\n+\t\t\tif (!error.empty()) {\n+\t\t\t\tthrow InvalidInputException(\"Could not parse TIMESTAMPFORMAT: %s\", error.c_str());\n+\t\t\t}\n+\t\t\tbind_data->has_timestamp_format = true;\n \t\t} else {\n \t\t\tthrow NotImplementedException(\"Unrecognized option for CSV: %s\", option.first.c_str());\n \t\t}\n@@ -376,7 +400,7 @@ struct LocalReadCSVData : public LocalFunctionData {\n \n struct GlobalWriteCSVData : public GlobalFunctionData {\n \tGlobalWriteCSVData(FileSystem &fs, string file_path) : fs(fs) {\n-\t\thandle = fs.OpenFile(file_path, FileFlags::WRITE | FileFlags::FILE_CREATE_NEW, FileLockType::WRITE_LOCK);\n+\t\thandle = fs.OpenFile(file_path, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE_NEW, FileLockType::WRITE_LOCK);\n \t}\n \n \tvoid WriteData(const_data_ptr_t data, idx_t size) {\n@@ -513,6 +537,10 @@ unique_ptr<GlobalFunctionData> read_csv_initialize(ClientContext &context, Funct\n \toptions.skip_rows = 0;\n \toptions.num_cols = bind_data.sql_types.size();\n \toptions.force_not_null = bind_data.force_not_null;\n+\toptions.has_date_format = bind_data.has_date_format;\n+\toptions.date_format = move(bind_data.date_format);\n+\toptions.has_timestamp_format = bind_data.has_timestamp_format;\n+\toptions.timestamp_format = move(bind_data.timestamp_format);\n \n \tglobal_data->csv_reader = make_unique<BufferedCSVReader>(context, move(options), bind_data.sql_types);\n \treturn move(global_data);\ndiff --git a/src/function/table/range.cpp b/src/function/table/range.cpp\nindex 892436616a2c..a81a25f41a5d 100644\n--- a/src/function/table/range.cpp\n+++ b/src/function/table/range.cpp\n@@ -14,7 +14,7 @@ struct RangeFunctionData : public TableFunctionData {\n \tidx_t current_idx;\n };\n \n-static unique_ptr<FunctionData> range_function_bind(ClientContext &context, vector<Value> inputs,\n+static unique_ptr<FunctionData> range_function_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n                                               vector<SQLType> &return_types, vector<string> &names) {\n \tauto result = make_unique<RangeFunctionData>();\n \tif (inputs.size() < 2) {\ndiff --git a/src/function/table/read_csv.cpp b/src/function/table/read_csv.cpp\nindex b5a07637e0b8..f5e6723ee56c 100644\n--- a/src/function/table/read_csv.cpp\n+++ b/src/function/table/read_csv.cpp\n@@ -16,35 +16,82 @@ struct ReadCSVFunctionData : public TableFunctionData {\n \tunique_ptr<BufferedCSVReader> csv_reader;\n };\n \n-static unique_ptr<FunctionData> read_csv_bind(ClientContext &context, vector<Value> inputs,\n+static unique_ptr<FunctionData> read_csv_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n                                               vector<SQLType> &return_types, vector<string> &names) {\n \n \tif (!context.db.config.enable_copy) {\n \t\tthrow Exception(\"read_csv is disabled by configuration\");\n \t}\n-\tfor (auto &val : inputs[2].struct_value) {\n-\t\tnames.push_back(val.first);\n-\t\tif (val.second.type != TypeId::VARCHAR) {\n-\t\t\tthrow BinderException(\"read_csv requires a type specification as string\");\n-\t\t}\n-\t\treturn_types.push_back(TransformStringToSQLType(val.second.str_value.c_str()));\n-\t}\n-\tif (names.size() == 0) {\n-\t\tthrow BinderException(\"read_csv requires at least a single column as input!\");\n-\t}\n \tauto result = make_unique<ReadCSVFunctionData>();\n \n \tBufferedCSVReaderOptions options;\n-\toptions.auto_detect = false;\n \toptions.file_path = inputs[0].str_value;\n+\toptions.auto_detect = true;\n \toptions.header = false;\n-\toptions.delimiter = inputs[1].str_value;\n-\n-\tresult->csv_reader = make_unique<BufferedCSVReader>(context, move(options), return_types);\n+\toptions.delimiter = \",\";\n+\toptions.quote = \"\\\"\";\n+\n+\tfor(auto &kv : named_parameters) {\n+\t\tif (kv.first == \"sep\") {\n+\t\t\toptions.auto_detect = false;\n+\t\t\toptions.delimiter = kv.second.str_value;\n+\t\t} else if (kv.first == \"header\") {\n+\t\t\toptions.auto_detect = false;\n+\t\t\toptions.header = kv.second.value_.boolean;\n+\t\t} else if (kv.first == \"quote\") {\n+\t\t\toptions.auto_detect = false;\n+\t\t\toptions.quote = kv.second.str_value;\n+\t\t} else if (kv.first == \"escape\") {\n+\t\t\toptions.auto_detect = false;\n+\t\t\toptions.escape = kv.second.str_value;\n+\t\t} else if (kv.first == \"nullstr\") {\n+\t\t\toptions.auto_detect = false;\n+\t\t\toptions.null_str = kv.second.str_value;\n+\t\t} else if (kv.first == \"dateformat\") {\n+\t\t\toptions.has_date_format = true;\n+\t\t\toptions.date_format.format_specifier = kv.second.str_value;\n+\t\t\tstring error = StrTimeFormat::ParseFormatSpecifier(kv.second.str_value, options.date_format);\n+\t\t\tif (!error.empty()) {\n+\t\t\t\tthrow InvalidInputException(\"Could not parse DATEFORMAT: %s\", error.c_str());\n+\t\t\t}\n+\t\t} else if (kv.first == \"timestampformat\") {\n+\t\t\toptions.has_timestamp_format = true;\n+\t\t\toptions.timestamp_format.format_specifier = kv.second.str_value;\n+\t\t\tstring error = StrTimeFormat::ParseFormatSpecifier(kv.second.str_value, options.timestamp_format);\n+\t\t\tif (!error.empty()) {\n+\t\t\t\tthrow InvalidInputException(\"Could not parse TIMESTAMPFORMAT: %s\", error.c_str());\n+\t\t\t}\n+\t\t} else if (kv.first == \"columns\") {\n+\t\t\toptions.auto_detect = false;\n+\t\t\tfor (auto &val : kv.second.struct_value) {\n+\t\t\t\tnames.push_back(val.first);\n+\t\t\t\tif (val.second.type != TypeId::VARCHAR) {\n+\t\t\t\t\tthrow BinderException(\"read_csv requires a type specification as string\");\n+\t\t\t\t}\n+\t\t\t\treturn_types.push_back(TransformStringToSQLType(val.second.str_value.c_str()));\n+\t\t\t}\n+\t\t\tif (names.size() == 0) {\n+\t\t\t\tthrow BinderException(\"read_csv requires at least a single column as input!\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif (!options.auto_detect && return_types.size() == 0) {\n+\t\tthrow BinderException(\"Specifying CSV options requires columns to be specified as well (for now)\");\n+\t}\n+\tif (return_types.size() > 0) {\n+\t\t// return types specified: no auto detect\n+\t\tresult->csv_reader = make_unique<BufferedCSVReader>(context, move(options), return_types);\n+\t} else {\n+\t\t// auto detect options\n+\t\tresult->csv_reader = make_unique<BufferedCSVReader>(context, move(options));\n+\n+\t\treturn_types.assign(result->csv_reader->sql_types.begin(), result->csv_reader->sql_types.end());\n+\t\tnames.assign(result->csv_reader->col_names.begin(), result->csv_reader->col_names.end());\n+\t}\n \treturn move(result);\n }\n \n-static unique_ptr<FunctionData> read_csv_auto_bind(ClientContext &context, vector<Value> inputs,\n+static unique_ptr<FunctionData> read_csv_auto_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n                                                    vector<SQLType> &return_types, vector<string> &names) {\n \n \tif (!context.db.config.enable_copy) {\n@@ -71,9 +118,18 @@ static void read_csv_info(ClientContext &context, vector<Value> &input, DataChun\n \n void ReadCSVTableFunction::RegisterFunction(BuiltinFunctions &set) {\n \tTableFunctionSet read_csv(\"read_csv\");\n-\tread_csv.AddFunction(\n-\t    TableFunction({SQLType::VARCHAR, SQLType::VARCHAR, SQLType::STRUCT}, read_csv_bind, read_csv_info, nullptr));\n-\tread_csv.AddFunction(TableFunction({SQLType::VARCHAR}, read_csv_auto_bind, read_csv_info, nullptr));\n+\n+\tTableFunction read_csv_function = TableFunction({SQLType::VARCHAR}, read_csv_bind, read_csv_info, nullptr);\n+\tread_csv_function.named_parameters[\"sep\"] = SQLType::VARCHAR;\n+\tread_csv_function.named_parameters[\"quote\"] = SQLType::VARCHAR;\n+\tread_csv_function.named_parameters[\"escape\"] = SQLType::VARCHAR;\n+\tread_csv_function.named_parameters[\"nullstr\"] = SQLType::VARCHAR;\n+\tread_csv_function.named_parameters[\"columns\"] = SQLType::STRUCT;\n+\tread_csv_function.named_parameters[\"header\"] = SQLType::BOOLEAN;\n+\tread_csv_function.named_parameters[\"dateformat\"] = SQLType::VARCHAR;\n+\tread_csv_function.named_parameters[\"timestampformat\"] = SQLType::VARCHAR;\n+\n+\tread_csv.AddFunction(move(read_csv_function));\n \n \tset.AddFunction(read_csv);\n \tset.AddFunction(TableFunction(\"read_csv_auto\", {SQLType::VARCHAR}, read_csv_auto_bind, read_csv_info, nullptr));\ndiff --git a/src/function/table/repeat.cpp b/src/function/table/repeat.cpp\nindex 970d066e339e..bf49c523f0e9 100644\n--- a/src/function/table/repeat.cpp\n+++ b/src/function/table/repeat.cpp\n@@ -12,7 +12,7 @@ struct RepeatFunctionData : public TableFunctionData {\n \tidx_t target_count;\n };\n \n-static unique_ptr<FunctionData> repeat_bind(ClientContext &context, vector<Value> inputs,\n+static unique_ptr<FunctionData> repeat_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n                                               vector<SQLType> &return_types, vector<string> &names) {\n \t// the repeat function returns the type of the first argument\n \treturn_types.push_back(inputs[0].GetSQLType());\ndiff --git a/src/function/table/sqlite/pragma_collations.cpp b/src/function/table/sqlite/pragma_collations.cpp\nindex d36d398995a4..5284e3307465 100644\n--- a/src/function/table/sqlite/pragma_collations.cpp\n+++ b/src/function/table/sqlite/pragma_collations.cpp\n@@ -19,7 +19,7 @@ struct PragmaCollateData : public TableFunctionData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> pragma_collate_bind(ClientContext &context, vector<Value> inputs,\n+static unique_ptr<FunctionData> pragma_collate_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n                                                     vector<SQLType> &return_types, vector<string> &names) {\n \tnames.push_back(\"collname\");\n \treturn_types.push_back(SQLType::VARCHAR);\ndiff --git a/src/function/table/sqlite/pragma_database_list.cpp b/src/function/table/sqlite/pragma_database_list.cpp\nindex 593d8e317201..4bd353273154 100644\n--- a/src/function/table/sqlite/pragma_database_list.cpp\n+++ b/src/function/table/sqlite/pragma_database_list.cpp\n@@ -13,7 +13,7 @@ struct PragmaDatabaseListData : public TableFunctionData {\n \tbool finished;\n };\n \n-static unique_ptr<FunctionData> pragma_database_list_bind(ClientContext &context, vector<Value> inputs,\n+static unique_ptr<FunctionData> pragma_database_list_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n                                                    vector<SQLType> &return_types, vector<string> &names) {\n \tnames.push_back(\"seq\");\n \treturn_types.push_back(SQLType::INTEGER);\ndiff --git a/src/function/table/sqlite/pragma_table_info.cpp b/src/function/table/sqlite/pragma_table_info.cpp\nindex fa4a63087f52..8aff1609bc28 100644\n--- a/src/function/table/sqlite/pragma_table_info.cpp\n+++ b/src/function/table/sqlite/pragma_table_info.cpp\n@@ -19,7 +19,7 @@ struct PragmaTableFunctionData : public TableFunctionData {\n \tidx_t offset;\n };\n \n-static unique_ptr<FunctionData> pragma_table_info_bind(ClientContext &context, vector<Value> inputs,\n+static unique_ptr<FunctionData> pragma_table_info_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n                                                        vector<SQLType> &return_types, vector<string> &names) {\n \tnames.push_back(\"cid\");\n \treturn_types.push_back(SQLType::INTEGER);\ndiff --git a/src/function/table/sqlite/sqlite_master.cpp b/src/function/table/sqlite/sqlite_master.cpp\nindex f448fbb6a89a..eab40a6e81ca 100644\n--- a/src/function/table/sqlite/sqlite_master.cpp\n+++ b/src/function/table/sqlite/sqlite_master.cpp\n@@ -45,7 +45,7 @@ string GenerateQuery(CatalogEntry *entry) {\n \t}\n }\n \n-static unique_ptr<FunctionData> sqlite_master_bind(ClientContext &context, vector<Value> inputs,\n+static unique_ptr<FunctionData> sqlite_master_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n                                                    vector<SQLType> &return_types, vector<string> &names) {\n \tnames.push_back(\"type\");\n \treturn_types.push_back(SQLType::VARCHAR);\ndiff --git a/src/function/table/version/pragma_version.cpp b/src/function/table/version/pragma_version.cpp\nindex 6e4dd266050c..475f720299a9 100644\n--- a/src/function/table/version/pragma_version.cpp\n+++ b/src/function/table/version/pragma_version.cpp\n@@ -9,7 +9,7 @@ struct PragmaVersionData : public TableFunctionData {\n \tbool done;\n };\n \n-static unique_ptr<FunctionData> pragma_version_bind(ClientContext &context, vector<Value> inputs,\n+static unique_ptr<FunctionData> pragma_version_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n                                                     vector<SQLType> &return_types, vector<string> &names) {\n \tnames.push_back(\"library_version\");\n \treturn_types.push_back(SQLType::VARCHAR);\ndiff --git a/src/include/duckdb/common/file_system.hpp b/src/include/duckdb/common/file_system.hpp\nindex 0cde62872420..9fb17c48d54b 100644\n--- a/src/include/duckdb/common/file_system.hpp\n+++ b/src/include/duckdb/common/file_system.hpp\n@@ -47,17 +47,17 @@ enum class FileLockType : uint8_t { NO_LOCK = 0, READ_LOCK = 1, WRITE_LOCK = 2 }\n class FileFlags {\n public:\n \t//! Open file with read access\n-\tstatic constexpr uint8_t READ = 1 << 0;\n+\tstatic constexpr uint8_t FILE_FLAGS_READ = 1 << 0;\n \t//! Open file with read/write access\n-\tstatic constexpr uint8_t WRITE = 1 << 1;\n+\tstatic constexpr uint8_t FILE_FLAGS_WRITE = 1 << 1;\n \t//! Use direct IO when reading/writing to the file\n-\tstatic constexpr uint8_t DIRECT_IO = 1 << 2;\n+\tstatic constexpr uint8_t FILE_FLAGS_DIRECT_IO = 1 << 2;\n \t//! Create file if not exists, can only be used together with WRITE\n-\tstatic constexpr uint8_t FILE_CREATE = 1 << 3;\n+\tstatic constexpr uint8_t FILE_FLAGS_FILE_CREATE = 1 << 3;\n \t//! Always create a new file. If a file exists, the file is truncated. Cannot be used together with CREATE.\n-\tstatic constexpr uint8_t FILE_CREATE_NEW = 1 << 4;\n+\tstatic constexpr uint8_t FILE_FLAGS_FILE_CREATE_NEW = 1 << 4;\n \t//! Open file in append mode\n-\tstatic constexpr uint8_t APPEND = 1 << 5;\n+\tstatic constexpr uint8_t FILE_FLAGS_APPEND = 1 << 5;\n };\n \n class FileSystem {\ndiff --git a/src/include/duckdb/common/serializer/buffered_file_writer.hpp b/src/include/duckdb/common/serializer/buffered_file_writer.hpp\nindex 118c500c8a04..dcba725a7a6a 100644\n--- a/src/include/duckdb/common/serializer/buffered_file_writer.hpp\n+++ b/src/include/duckdb/common/serializer/buffered_file_writer.hpp\n@@ -19,7 +19,7 @@ class BufferedFileWriter : public Serializer {\n public:\n \t//! Serializes to a buffer allocated by the serializer, will expand when\n \t//! writing past the initial threshold\n-\tBufferedFileWriter(FileSystem &fs, string path, uint8_t open_flags = FileFlags::WRITE | FileFlags::FILE_CREATE);\n+\tBufferedFileWriter(FileSystem &fs, string path, uint8_t open_flags = FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE);\n \n \tFileSystem &fs;\n \tunique_ptr<data_t[]> data;\ndiff --git a/src/include/duckdb/common/types/date.hpp b/src/include/duckdb/common/types/date.hpp\nindex 2c01da3ca388..683b752d4cef 100644\n--- a/src/include/duckdb/common/types/date.hpp\n+++ b/src/include/duckdb/common/types/date.hpp\n@@ -15,6 +15,11 @@ namespace duckdb {\n //! The Date class is a static class that holds helper functions for the Date\n //! type.\n class Date {\n+public:\n+\tstatic string_t MonthNames[12];\n+\tstatic string_t MonthNamesAbbreviated[12];\n+\tstatic string_t DayNames[7];\n+\tstatic string_t DayNamesAbbreviated[7];\n public:\n \t//! Convert a string in the format \"YYYY-MM-DD\" to a date object\n \tstatic date_t FromString(string str, bool strict = false);\n@@ -22,6 +27,8 @@ class Date {\n \tstatic date_t FromCString(const char *str, bool strict = false);\n \t//! Convert a date object to a string in the format \"YYYY-MM-DD\"\n \tstatic string ToString(date_t date);\n+\t//! Try to convert text in a buffer to a date; returns true if parsing was successful\n+\tstatic bool TryConvertDate(const char *buf, idx_t &pos, date_t &result, bool strict = false);\n \n \t//! Create a string \"YYYY-MM-DD\" from a specified (year, month, day)\n \t//! combination\n@@ -53,8 +60,17 @@ class Date {\n \tstatic int32_t ExtractISODayOfTheWeek(date_t date);\n \t//! Extract the day of the year\n \tstatic int32_t ExtractDayOfTheYear(date_t date);\n-\t//! Extract the week number\n-\tstatic int32_t ExtractWeekNumber(date_t date);\n+\t//! Extract the ISO week number\n+\t//! ISO weeks start on Monday and the first week of a year\n+\t//! contains January 4 of that year.\n+\t//! In the ISO week-numbering system, it is possible for early-January dates\n+\t//! to be part of the 52nd or 53rd week of the previous year.\n+\tstatic int32_t ExtractISOWeekNumber(date_t date);\n+\t//! Extract the week number as Python handles it.\n+\t//! Either Monday or Sunday is the first day of the week,\n+\t//! and any date before the first Monday/Sunday returns week 0\n+\t//! This is a bit more consistent because week numbers in a year are always incrementing\n+\tstatic int32_t ExtractWeekNumberRegular(date_t date, bool monday_first = true);\n \t//! Returns the date of the monday of the current week.\n \tstatic date_t GetMondayOfCurrentWeek(date_t date);\n };\ndiff --git a/src/include/duckdb/common/types/numeric_helper.hpp b/src/include/duckdb/common/types/numeric_helper.hpp\nnew file mode 100644\nindex 000000000000..d0cf37c5d5c7\n--- /dev/null\n+++ b/src/include/duckdb/common/types/numeric_helper.hpp\n@@ -0,0 +1,70 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/types/numeric_helper.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/common.hpp\"\n+#include \"duckdb/common/types/string_type.hpp\"\n+#include \"duckdb/common/types/vector.hpp\"\n+#include \"fmt/format.h\"\n+\n+namespace duckdb {\n+\n+//! NumericHelper is a static class that holds helper functions for integers/doubles\n+class NumericHelper {\n+public:\n+\ttemplate <class T> static int UnsignedLength(T value);\n+\ttemplate <class SIGNED, class UNSIGNED> static int SignedLength(SIGNED value) {\n+\t\tint sign = -(value < 0);\n+\t\tUNSIGNED unsigned_value = (value ^ sign) - sign;\n+\t\treturn UnsignedLength(unsigned_value);\n+\t}\n+\n+\t// Formats value in reverse and returns a pointer to the beginning.\n+\ttemplate <class T> static char *FormatUnsigned(T value, char *ptr) {\n+\t\twhile (value >= 100) {\n+\t\t\t// Integer division is slow so do it for a group of two digits instead\n+\t\t\t// of for every digit. The idea comes from the talk by Alexandrescu\n+\t\t\t// \"Three Optimization Tips for C++\". See speed-test for a comparison.\n+\t\t\tauto index = static_cast<unsigned>((value % 100) * 2);\n+\t\t\tvalue /= 100;\n+\t\t\t*--ptr = duckdb_fmt::internal::data::digits[index + 1];\n+\t\t\t*--ptr = duckdb_fmt::internal::data::digits[index];\n+\t\t}\n+\t\tif (value < 10) {\n+\t\t\t*--ptr = static_cast<char>('0' + value);\n+\t\t\treturn ptr;\n+\t\t}\n+\t\tauto index = static_cast<unsigned>(value * 2);\n+\t\t*--ptr = duckdb_fmt::internal::data::digits[index + 1];\n+\t\t*--ptr = duckdb_fmt::internal::data::digits[index];\n+\t\treturn ptr;\n+\t}\n+\n+\ttemplate <class SIGNED, class UNSIGNED> static string_t FormatSigned(SIGNED value, Vector &vector) {\n+\t\tint sign = -(value < 0);\n+\t\tUNSIGNED unsigned_value = (value ^ sign) - sign;\n+\t\tint length = UnsignedLength<UNSIGNED>(unsigned_value) - sign;\n+\t\tstring_t result = StringVector::EmptyString(vector, length);\n+\t\tauto dataptr = result.GetData();\n+\t\tauto endptr = dataptr + length;\n+\t\tendptr = FormatUnsigned(unsigned_value, endptr);\n+\t\tif (sign) {\n+\t\t\t*--endptr = '-';\n+\t\t}\n+\t\tresult.Finalize();\n+\t\treturn result;\n+\t}\n+};\n+\n+template <> int NumericHelper::UnsignedLength(uint8_t value);\n+template <> int NumericHelper::UnsignedLength(uint16_t value);\n+template <> int NumericHelper::UnsignedLength(uint32_t value);\n+template <> int NumericHelper::UnsignedLength(uint64_t value);\n+\n+}\ndiff --git a/src/include/duckdb/common/types/time.hpp b/src/include/duckdb/common/types/time.hpp\nindex f0064698a47f..0542894a9484 100644\n--- a/src/include/duckdb/common/types/time.hpp\n+++ b/src/include/duckdb/common/types/time.hpp\n@@ -12,13 +12,14 @@\n \n namespace duckdb {\n \n-//! The Date class is a static class that holds helper functions for the Time\n+//! The Time class is a static class that holds helper functions for the Time\n //! type.\n class Time {\n public:\n \t//! Convert a string in the format \"hh:mm:ss\" to a time object\n \tstatic dtime_t FromString(string str, bool strict = false);\n \tstatic dtime_t FromCString(const char *buf, bool strict = false);\n+\tstatic bool TryConvertTime(const char *buf, idx_t &pos, dtime_t &result, bool strict = false);\n \n \t//! Convert a time object to a string in the format \"hh:mm:ss\"\n \tstatic string ToString(dtime_t time);\ndiff --git a/src/include/duckdb/common/types/timestamp.hpp b/src/include/duckdb/common/types/timestamp.hpp\nindex 3e3196dd8776..51cd59e687c0 100644\n--- a/src/include/duckdb/common/types/timestamp.hpp\n+++ b/src/include/duckdb/common/types/timestamp.hpp\n@@ -27,7 +27,8 @@ class Timestamp {\n public:\n \t//! Convert a string in the format \"YYYY-MM-DD hh:mm:ss\" to a timestamp object\n \tstatic timestamp_t FromString(string str);\n-\t//! Convert a date object to a string in the format \"YYYY-MM-DDThh:mm:ssZ\"\n+\tstatic timestamp_t FromCString(const char *str, idx_t len);\n+\t//! Convert a date object to a string in the format \"YYYY-MM-DD hh:mm:ss\"\n \tstatic string ToString(timestamp_t timestamp);\n \n \tstatic date_t GetDate(timestamp_t timestamp);\ndiff --git a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\nindex 29277ebc3595..388162d386fd 100644\n--- a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\n+++ b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\n@@ -10,6 +10,8 @@\n \n #include \"duckdb/execution/physical_operator.hpp\"\n #include \"duckdb/parser/parsed_data/copy_info.hpp\"\n+#include \"duckdb/function/scalar/strftime.hpp\"\n+\n #include <sstream>\n \n #define SAMPLE_CHUNK_SIZE 100\n@@ -20,6 +22,7 @@\n \n namespace duckdb {\n struct CopyInfo;\n+struct StrpTimeFormat;\n \n //! The shifts array allows for linear searching of multi-byte values. For each position, it determines the next\n //! position given that we encounter a byte with the given value.\n@@ -65,6 +68,14 @@ struct BufferedCSVReaderOptions  {\n     string null_str;\n     //! True, if column with that index must skip null check\n     vector<bool> force_not_null;\n+\t//! The date format to use (if any is specified)\n+\tStrpTimeFormat date_format;\n+\t//! Whether or not a date format is specified\n+\tbool has_date_format = false;\n+\t//! The timestamp format to use (if any is specified)\n+\tStrpTimeFormat timestamp_format;\n+\t//! Whether or not a timestamp format is specified\n+\tbool has_timestamp_format = false;\n };\n \n enum class QuoteRule : uint8_t { QUOTES_RFC = 0, QUOTES_OTHER = 1, NO_QUOTES = 2 };\n@@ -86,7 +97,7 @@ class BufferedCSVReader {\n \tBufferedCSVReader(ClientContext &context, BufferedCSVReaderOptions options, vector<SQLType> requested_types = vector<SQLType>());\n \tBufferedCSVReader(BufferedCSVReaderOptions options, vector<SQLType> requested_types, unique_ptr<std::istream> source);\n \n-    BufferedCSVReaderOptions options;\n+\tBufferedCSVReaderOptions options;\n \tvector<SQLType> sql_types;\n \tvector<string> col_names;\n \tunique_ptr<std::istream> source;\n@@ -129,6 +140,8 @@ class BufferedCSVReader {\n \tvoid ParseCSV(ParserMode mode, DataChunk &insert_chunk = DUMMY_CHUNK);\n \t//! Sniffs CSV dialect and determines skip rows, header row, column types and column names\n \tvector<SQLType> SniffCSV(vector<SQLType> requested_types);\n+\t//! Try to cast a string value to the specified sql type\n+\tbool TryCastValue(Value value, SQLType sql_type);\n \t//! Skips header rows and skip_rows in the input stream\n \tvoid SkipHeader();\n \t//! Jumps back to the beginning of input stream and resets necessary internal states\ndiff --git a/src/include/duckdb/function/scalar/date_functions.hpp b/src/include/duckdb/function/scalar/date_functions.hpp\nindex 617c6711ac59..d972db8758b4 100644\n--- a/src/include/duckdb/function/scalar/date_functions.hpp\n+++ b/src/include/duckdb/function/scalar/date_functions.hpp\n@@ -41,4 +41,12 @@ struct EpochFun {\n \tstatic void RegisterFunction(BuiltinFunctions &set);\n };\n \n+struct StrfTimeFun {\n+\tstatic void RegisterFunction(BuiltinFunctions &set);\n+};\n+\n+struct StrpTimeFun {\n+\tstatic void RegisterFunction(BuiltinFunctions &set);\n+};\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/function/scalar/strftime.hpp b/src/include/duckdb/function/scalar/strftime.hpp\nnew file mode 100644\nindex 000000000000..d13a0ec3ef66\n--- /dev/null\n+++ b/src/include/duckdb/function/scalar/strftime.hpp\n@@ -0,0 +1,106 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/function/scalar/strftime.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/function/scalar_function.hpp\"\n+#include \"duckdb/common/vector.hpp\"\n+\n+namespace duckdb {\n+\n+enum class StrTimeSpecifier : uint8_t {\n+\tABBREVIATED_WEEKDAY_NAME = 0,          // %a - Abbreviated weekday name. (Sun, Mon, ...)\n+\tFULL_WEEKDAY_NAME = 1,                 // %A Full weekday name. (Sunday, Monday, ...)\n+\tWEEKDAY_DECIMAL = 2,                   // %w - Weekday as a decimal number. (0, 1, ..., 6)\n+\tDAY_OF_MONTH_PADDED = 3,               // %d - Day of the month as a zero-padded decimal. (01, 02, ..., 31)\n+\tDAY_OF_MONTH = 4,                      // %-d - Day of the month as a decimal number. (1, 2, ..., 30)\n+\tABBREVIATED_MONTH_NAME = 5,            // %b - Abbreviated month name. (Jan, Feb, ..., Dec)\n+\tFULL_MONTH_NAME = 6,                   // %B - Full month name. (January, February, ...)\n+\tMONTH_DECIMAL_PADDED = 7,              // %m - Month as a zero-padded decimal number. (01, 02, ..., 12)\n+\tMONTH_DECIMAL = 8,                     // %-m - Month as a decimal number. (1, 2, ..., 12)\n+\tYEAR_WITHOUT_CENTURY_PADDED = 9,       // %y - Year without century as a zero-padded decimal number. (00, 01, ..., 99)\n+\tYEAR_WITHOUT_CENTURY = 10,             // %-y - Year without century as a decimal number. (0, 1, ..., 99)\n+\tYEAR_DECIMAL = 11,                     // %Y - Year with century as a decimal number. (2013, 2019 etc.)\n+\tHOUR_24_PADDED = 12,                   // %H - Hour (24-hour clock) as a zero-padded decimal number. (00, 01, ..., 23)\n+\tHOUR_24_DECIMAL = 13,                  // %-H - Hour (24-hour clock) as a decimal number. (0, 1, ..., 23)\n+\tHOUR_12_PADDED = 14,                   // %I - Hour (12-hour clock) as a zero-padded decimal number. (01, 02, ..., 12)\n+\tHOUR_12_DECIMAL = 15,                  // %-I - Hour (12-hour clock) as a decimal number. (1, 2, ... 12)\n+\tAM_PM = 16,                            // %p - Locale\u2019s AM or PM. (AM, PM)\n+\tMINUTE_PADDED = 17,                    // %M - Minute as a zero-padded decimal number. (00, 01, ..., 59)\n+\tMINUTE_DECIMAL = 18,                   // %-M - Minute as a decimal number. (0, 1, ..., 59)\n+\tSECOND_PADDED = 19,                    // %S - Second as a zero-padded decimal number. (00, 01, ..., 59)\n+\tSECOND_DECIMAL = 20,                   // %-S - Second as a decimal number. (0, 1, ..., 59)\n+\tMICROSECOND_PADDED = 21,               // %f - Microsecond as a decimal number, zero-padded on the left. (000000 - 999999)\n+\tUTC_OFFSET = 22,                       // %z - UTC offset in the form +HHMM or -HHMM. ( )\n+\tTZ_NAME = 23,                          // %Z - Time zone name. ( )\n+\tDAY_OF_YEAR_PADDED = 24,               // %j - Day of the year as a zero-padded decimal number. (001, 002, ..., 366)\n+\tDAY_OF_YEAR_DECIMAL = 25,              // %-j - Day of the year as a decimal number. (1, 2, ..., 366)\n+\tWEEK_NUMBER_PADDED_SUN_FIRST = 26,     // %U - Week number of the year (Sunday as the first day of the week). All days in a new year preceding the first Sunday are considered to be in week 0. (00, 01, ..., 53)\n+\tWEEK_NUMBER_PADDED_MON_FIRST = 27,     // %W - Week number of the year (Monday as the first day of the week). All days in a new year preceding the first Monday are considered to be in week 0. (00, 01, ..., 53)\n+\tLOCALE_APPROPRIATE_DATE_AND_TIME = 28, // %c - Locale\u2019s appropriate date and time representation. (Mon Sep 30 07:06:05 2013)\n+\tLOCALE_APPROPRIATE_DATE = 29,          // %x - Locale\u2019s appropriate date representation. (09/30/13)\n+\tLOCALE_APPROPRIATE_TIME = 30           // %X - Locale\u2019s appropriate time representation. (07:06:05)\n+};\n+\n+struct StrTimeFormat {\n+public:\n+\tstatic string ParseFormatSpecifier(string format_string, StrTimeFormat &format);\n+protected:\n+\t//! The format specifiers\n+\tvector<StrTimeSpecifier> specifiers;\n+\t//! The literals that appear in between the format specifiers\n+\t//! The following must hold: literals.size() = specifiers.size() + 1\n+\t//! Format is literals[0], specifiers[0], literals[1], ..., specifiers[n - 1], literals[n]\n+\tvector<string> literals;\n+\t//! The constant size that appears in the format string\n+\tidx_t constant_size;\n+\t//! Whether or not the specifier is a numeric specifier (i.e. is parsed as a number)\n+\tvector<bool> is_numeric;\n+\tvoid AddLiteral(string literal);\n+\tvirtual void AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier);\n+};\n+\n+struct StrfTimeFormat : public StrTimeFormat {\n+\tidx_t GetLength(date_t date, time_t time);\n+\n+\tvoid FormatString(date_t date, int32_t data[7], char *target);\n+\tvoid FormatString(date_t date, time_t time, char *target);\n+protected:\n+\t//! The variable-length specifiers. To determine total string size, these need to be checked.\n+\tvector<StrTimeSpecifier> var_length_specifiers;\n+\t//! Whether or not the current specifier is a special \"date\" specifier (i.e. one that requires a date_t object to generate)\n+\tvector<bool> is_date_specifier;\n+\n+\tvoid AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier) override;\n+\tstatic idx_t GetSpecifierLength(StrTimeSpecifier specifier, date_t date, time_t time);\n+\tchar* WriteString(char *target, string_t &str);\n+\tchar *Write2(char *target, uint8_t value);\n+\tchar* WritePadded2(char *target, int32_t value);\n+\tchar *WritePadded3(char *target, uint32_t value);\n+\tchar* WritePadded(char *target, int32_t value, int32_t padding);\n+\tbool IsDateSpecifier(StrTimeSpecifier specifier);\n+\tchar* WriteDateSpecifier(StrTimeSpecifier specifier, date_t date, char *target);\n+\tchar* WriteStandardSpecifier(StrTimeSpecifier specifier, int32_t data[], char *target);\n+};\n+\n+struct StrpTimeFormat : public StrTimeFormat {\n+public:\n+\t//! The full format specifier, for error messages\n+\tstring format_specifier;\n+\n+\tbool Parse(string_t str, int32_t result_data[], string &error_message, idx_t &error_position);\n+\tdate_t ParseDate(string_t str);\n+\ttimestamp_t ParseTimestamp(string_t str);\n+protected:\n+\tstring FormatStrpTimeError(string input, idx_t position);\n+\tvoid AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier);\n+\tbool IsNumericSpecifier(StrTimeSpecifier specifier);\n+\tint32_t TryParseCollection(const char *data, idx_t &pos, idx_t size, string_t collection[], idx_t collection_count);\n+};\n+\n+}\ndiff --git a/src/include/duckdb/function/table_function.hpp b/src/include/duckdb/function/table_function.hpp\nindex 6609db81c319..50326ee7f644 100644\n--- a/src/include/duckdb/function/table_function.hpp\n+++ b/src/include/duckdb/function/table_function.hpp\n@@ -9,11 +9,12 @@\n #pragma once\n \n #include \"duckdb/function/function.hpp\"\n+#include \"duckdb/common/unordered_map.hpp\"\n \n namespace duckdb {\n \n //! Function used for determining the return type of a table producing function\n-typedef unique_ptr<FunctionData> (*table_function_bind_t)(ClientContext &context, vector<Value> inputs,\n+typedef unique_ptr<FunctionData> (*table_function_bind_t)(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n                                                           vector<SQLType> &return_types, vector<string> &names);\n //! Type used for table-returning function\n typedef void (*table_function_t)(ClientContext &context, vector<Value> &input, DataChunk &output,\n@@ -39,6 +40,8 @@ class TableFunction : public SimpleFunction {\n \ttable_function_t function;\n \t//! Final function pointer\n \ttable_function_final_t final;\n+\t//! Supported named parameters by the function\n+\tunordered_map<string, SQLType> named_parameters;\n \t//! Whether or not the table function supports projection\n \tbool supports_projection;\n \ndiff --git a/src/main/relation/read_csv_relation.cpp b/src/main/relation/read_csv_relation.cpp\nindex a938abef159a..5dd933adceb2 100644\n--- a/src/main/relation/read_csv_relation.cpp\n+++ b/src/main/relation/read_csv_relation.cpp\n@@ -3,6 +3,8 @@\n #include \"duckdb/parser/tableref/basetableref.hpp\"\n #include \"duckdb/parser/query_node/select_node.hpp\"\n #include \"duckdb/parser/expression/star_expression.hpp\"\n+#include \"duckdb/parser/expression/columnref_expression.hpp\"\n+#include \"duckdb/parser/expression/comparison_expression.hpp\"\n #include \"duckdb/parser/expression/constant_expression.hpp\"\n #include \"duckdb/parser/expression/function_expression.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n@@ -31,13 +33,13 @@ unique_ptr<TableRef> ReadCSVRelation::GetTableRef() {\n \tvector<unique_ptr<ParsedExpression>> children;\n \t// CSV file\n \tchildren.push_back(make_unique<ConstantExpression>(SQLType::VARCHAR, Value(csv_file)));\n-\tchildren.push_back(make_unique<ConstantExpression>(SQLType::VARCHAR, Value(\",\")));\n \t// parameters\n \tchild_list_t<Value> column_names;\n \tfor (idx_t i = 0; i < columns.size(); i++) {\n \t\tcolumn_names.push_back(make_pair(columns[i].name, Value(SQLTypeToString(columns[i].type))));\n \t}\n-\tchildren.push_back(make_unique<ConstantExpression>(SQLType::STRUCT, Value::STRUCT(move(column_names))));\n+\tauto colnames = make_unique<ConstantExpression>(SQLType::STRUCT, Value::STRUCT(move(column_names)));\n+\tchildren.push_back(make_unique<ComparisonExpression>(ExpressionType::COMPARE_EQUAL, make_unique<ColumnRefExpression>(\"columns\"), move(colnames)));\n \ttable_ref->function = make_unique<FunctionExpression>(\"read_csv\", children);\n \treturn move(table_ref);\n }\ndiff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp\nindex a4512f6da0ed..133bfd4a2047 100644\n--- a/src/planner/binder/tableref/bind_table_function.cpp\n+++ b/src/planner/binder/tableref/bind_table_function.cpp\n@@ -2,6 +2,8 @@\n #include \"duckdb/parser/expression/function_expression.hpp\"\n #include \"duckdb/parser/tableref/table_function_ref.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n+#include \"duckdb/parser/expression/columnref_expression.hpp\"\n+#include \"duckdb/parser/expression/comparison_expression.hpp\"\n #include \"duckdb/planner/expression_binder/constant_binder.hpp\"\n #include \"duckdb/planner/tableref/bound_table_function.hpp\"\n #include \"duckdb/execution/expression_executor.hpp\"\n@@ -19,15 +21,36 @@ unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {\n \t// evalate the input parameters to the function\n \tvector<SQLType> arguments;\n \tvector<Value> parameters;\n+\tunordered_map<string, Value> named_parameters;\n \tfor (auto &child : fexpr->children) {\n+\t\tstring parameter_name;\n+\n \t\tConstantBinder binder(*this, context, \"TABLE FUNCTION parameter\");\n+\t\tif (child->type == ExpressionType::COMPARE_EQUAL) {\n+\t\t\t// comparison, check if the LHS is a columnref\n+\t\t\tauto &comp = (ComparisonExpression&) *child;\n+\t\t\tif (comp.left->type == ExpressionType::COLUMN_REF) {\n+\t\t\t\tauto &colref = (ColumnRefExpression &) *comp.left;\n+\t\t\t\tif (colref.table_name.empty()) {\n+\t\t\t\t\tparameter_name = colref.column_name;\n+\t\t\t\t\tchild = move(comp.right);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tSQLType sql_type;\n \t\tauto expr = binder.Bind(child, &sql_type);\n \t\tauto constant = ExpressionExecutor::EvaluateScalar(*expr);\n \t\tconstant.SetSQLType(sql_type);\n-\n-\t\targuments.push_back(sql_type);\n-\t\tparameters.push_back(move(constant));\n+\t\tif (parameter_name.empty()) {\n+\t\t\t// unnamed parameter\n+\t\t\tif (named_parameters.size() > 0) {\n+\t\t\t\tthrow BinderException(\"Unnamed parameters cannot come after named parameters\");\n+\t\t\t}\n+\t\t\targuments.push_back(sql_type);\n+\t\t\tparameters.push_back(move(constant));\n+\t\t} else {\n+\t\t\tnamed_parameters[parameter_name] = move(constant);\n+\t\t}\n \t}\n \t// fetch the function from the catalog\n \tauto function =\n@@ -37,6 +60,15 @@ unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {\n \tidx_t best_function_idx = Function::BindFunction(function->name, function->functions, arguments);\n \tauto &table_function = function->functions[best_function_idx];\n \n+\t// now check the named parameters\n+\tfor(auto &kv : named_parameters) {\n+\t\tauto entry = table_function.named_parameters.find(kv.first);\n+\t\tif (entry == table_function.named_parameters.end()) {\n+\t\t\tthrow BinderException(\"Invalid named parameter \\\"%s\\\" for function %s\", kv.first.c_str(), table_function.name.c_str());\n+\t\t}\n+\t\tkv.second = kv.second.CastAs(kv.second.GetSQLType(), entry->second);\n+\t}\n+\n \t// cast the parameters to the type of the function\n \tauto result = make_unique<BoundTableFunction>(table_function, bind_index);\n \tfor(idx_t i = 0; i < arguments.size(); i++) {\n@@ -48,7 +80,7 @@ unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {\n \t}\n \n \t// perform the binding\n-\tresult->bind_data = table_function.bind(context, result->parameters, result->return_types, result->names);\n+\tresult->bind_data = table_function.bind(context, result->parameters, named_parameters, result->return_types, result->names);\n \tassert(result->return_types.size() == result->names.size());\n \tassert(result->return_types.size() > 0);\n \tvector<string> names;\ndiff --git a/src/storage/buffer_manager.cpp b/src/storage/buffer_manager.cpp\nindex 3fc6cd151dd9..1cad4e2e6ed7 100644\n--- a/src/storage/buffer_manager.cpp\n+++ b/src/storage/buffer_manager.cpp\n@@ -230,7 +230,7 @@ void BufferManager::WriteTemporaryBuffer(ManagedBuffer &buffer) {\n \t// get the path to write to\n \tauto path = GetTemporaryPath(buffer.id);\n \t// create the file and write the size followed by the buffer contents\n-\tauto handle = fs.OpenFile(path, FileFlags::WRITE | FileFlags::FILE_CREATE);\n+\tauto handle = fs.OpenFile(path, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE);\n \thandle->Write(&buffer.size, sizeof(idx_t), 0);\n \tbuffer.Write(*handle, sizeof(idx_t));\n }\n@@ -243,7 +243,7 @@ unique_ptr<BufferHandle> BufferManager::ReadTemporaryBuffer(block_id_t id) {\n \tidx_t alloc_size;\n \t// open the temporary file and read the size\n \tauto path = GetTemporaryPath(id);\n-\tauto handle = fs.OpenFile(path, FileFlags::READ);\n+\tauto handle = fs.OpenFile(path, FileFlags::FILE_FLAGS_READ);\n \thandle->Read(&alloc_size, sizeof(idx_t), 0);\n \t// first evict blocks until we can handle the size\n \twhile (current_memory + alloc_size > maximum_memory) {\ndiff --git a/src/storage/single_file_block_manager.cpp b/src/storage/single_file_block_manager.cpp\nindex 5d83092191ad..7be58861b299 100644\n--- a/src/storage/single_file_block_manager.cpp\n+++ b/src/storage/single_file_block_manager.cpp\n@@ -17,17 +17,17 @@ SingleFileBlockManager::SingleFileBlockManager(FileSystem &fs, string path, bool\n \tFileLockType lock;\n \tif (read_only) {\n \t\tassert(!create_new);\n-\t\tflags = FileFlags::READ;\n+\t\tflags = FileFlags::FILE_FLAGS_READ;\n \t\tlock = FileLockType::READ_LOCK;\n \t} else {\n-\t\tflags = FileFlags::WRITE;\n+\t\tflags = FileFlags::FILE_FLAGS_WRITE;\n \t\tlock = FileLockType::WRITE_LOCK;\n \t\tif (create_new) {\n-\t\t\tflags |= FileFlags::FILE_CREATE;\n+\t\t\tflags |= FileFlags::FILE_FLAGS_FILE_CREATE;\n \t\t}\n \t}\n \tif (use_direct_io) {\n-\t\tflags |= FileFlags::DIRECT_IO;\n+\t\tflags |= FileFlags::FILE_FLAGS_DIRECT_IO;\n \t}\n \t// open the RDBMS handle\n \thandle = fs.OpenFile(path, flags, lock);\ndiff --git a/src/storage/write_ahead_log.cpp b/src/storage/write_ahead_log.cpp\nindex 04429af976db..4a1587af3929 100644\n--- a/src/storage/write_ahead_log.cpp\n+++ b/src/storage/write_ahead_log.cpp\n@@ -13,7 +13,7 @@ WriteAheadLog::WriteAheadLog(DuckDB &database) : initialized(false), database(da\n }\n \n void WriteAheadLog::Initialize(string &path) {\n-\twriter = make_unique<BufferedFileWriter>(database.GetFileSystem(), path.c_str(), FileFlags::WRITE | FileFlags::FILE_CREATE | FileFlags::APPEND);\n+\twriter = make_unique<BufferedFileWriter>(database.GetFileSystem(), path.c_str(), FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE | FileFlags::FILE_FLAGS_APPEND);\n \tinitialized = true;\n }\n \ndiff --git a/tools/pythonpkg/duckdb_python.cpp b/tools/pythonpkg/duckdb_python.cpp\nindex 182c6dcb2fa3..7ae1941955be 100644\n--- a/tools/pythonpkg/duckdb_python.cpp\n+++ b/tools/pythonpkg/duckdb_python.cpp\n@@ -112,7 +112,7 @@ struct PandasScanFunction : public TableFunction {\n \tPandasScanFunction()\n \t    : TableFunction(\"pandas_scan\", {SQLType::VARCHAR}, pandas_scan_bind, pandas_scan_function, nullptr){};\n \n-\tstatic unique_ptr<FunctionData> pandas_scan_bind(ClientContext &context, vector<Value> inputs,\n+\tstatic unique_ptr<FunctionData> pandas_scan_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n \t                                                 vector<SQLType> &return_types, vector<string> &names) {\n \t\t// Hey, it works (TM)\n \t\tpy::handle df((PyObject *)std::stoull(inputs[0].GetValue<string>(), nullptr, 16));\ndiff --git a/tools/rpkg/src/duckdbr.cpp b/tools/rpkg/src/duckdbr.cpp\nindex c551a880888b..699ef51c5b42 100644\n--- a/tools/rpkg/src/duckdbr.cpp\n+++ b/tools/rpkg/src/duckdbr.cpp\n@@ -612,7 +612,7 @@ struct DataFrameScanFunction : public TableFunction {\n \tDataFrameScanFunction()\n \t    : TableFunction(\"dataframe_scan\", {SQLType::VARCHAR}, dataframe_scan_bind, dataframe_scan_function, nullptr){};\n \n-\tstatic unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> inputs,\n+\tstatic unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,\n \t                                                    vector<SQLType> &return_types, vector<string> &names) {\n \t\t// TODO have a better way to pass this pointer\n \t\tSEXP df((SEXP)std::stoull(inputs[0].GetValue<string>(), nullptr, 16));\n",
  "test_patch": "diff --git a/grammar/test.html b/grammar/test.html\ndeleted file mode 100644\nindex 754c08752e0b..000000000000\n--- a/grammar/test.html\n+++ /dev/null\n@@ -1,13 +0,0 @@\n-<!DOCTYPE html>\n-<html lang=\"en\">\n-  <head>\n-    <meta charset=\"utf-8\">\n-    <title>title</title>\n-    <link rel=\"stylesheet\" href=\"railroad.css\">\n-  </head>\n-  <body>\n-\t  <div id=\"rrdiagram\"></div>\n-  </body>\n-  <script src=\"railroad.js\"></script>\n-  <script src=\"delete.js\"></script>\n-</html>\n\\ No newline at end of file\ndiff --git a/test/common/test_file_system.cpp b/test/common/test_file_system.cpp\nindex 00b5f938510e..e5141b14797f 100644\n--- a/test/common/test_file_system.cpp\n+++ b/test/common/test_file_system.cpp\n@@ -75,7 +75,7 @@ TEST_CASE(\"Test file operations\", \"[file_system]\") {\n \t// standard reading/writing test\n \n \t// open file for writing\n-\tREQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::WRITE | FileFlags::FILE_CREATE, FileLockType::NO_LOCK));\n+\tREQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE, FileLockType::NO_LOCK));\n \t// write 10 integers\n \tREQUIRE_NOTHROW(handle->Write((void *)test_data, sizeof(int64_t) * INTEGER_COUNT, 0));\n \t// close the file\n@@ -85,7 +85,7 @@ TEST_CASE(\"Test file operations\", \"[file_system]\") {\n \t\ttest_data[i] = 0;\n \t}\n \t// now open the file for reading\n-\tREQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::READ, FileLockType::NO_LOCK));\n+\tREQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::FILE_FLAGS_READ, FileLockType::NO_LOCK));\n \t// read the 10 integers back\n \tREQUIRE_NOTHROW(handle->Read((void *)test_data, sizeof(int64_t) * INTEGER_COUNT, 0));\n \t// check the values of the integers\n@@ -110,7 +110,7 @@ TEST_CASE(\"Test file buffers for reading/writing to file\", \"[file_system]\") {\n \t}\n \n \t// open file for writing\n-\tREQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::WRITE | FileFlags::FILE_CREATE | FileFlags::DIRECT_IO,\n+\tREQUIRE_NOTHROW(handle = fs.OpenFile(fname, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE | FileFlags::FILE_FLAGS_DIRECT_IO,\n \t                                     FileLockType::WRITE_LOCK));\n \t// write the buffer\n \tREQUIRE_NOTHROW(buf->Write(*handle, 0));\ndiff --git a/test/sql/copy/csv/data/test/dateformat.csv b/test/sql/copy/csv/data/test/dateformat.csv\nnew file mode 100644\nindex 000000000000..c032d1bc410e\n--- /dev/null\n+++ b/test/sql/copy/csv/data/test/dateformat.csv\n@@ -0,0 +1,1 @@\n+05/06/2019\n\\ No newline at end of file\ndiff --git a/test/sql/copy/csv/data/test/timestampformat.csv b/test/sql/copy/csv/data/test/timestampformat.csv\nnew file mode 100644\nindex 000000000000..6c1bc88dd722\n--- /dev/null\n+++ b/test/sql/copy/csv/data/test/timestampformat.csv\n@@ -0,0 +1,1 @@\n+Mon 30, June 2003, 12:03:10 PM\n\\ No newline at end of file\ndiff --git a/test/sql/copy/csv/test_dateformat.test b/test/sql/copy/csv/test_dateformat.test\nnew file mode 100644\nindex 000000000000..683f655e4c43\n--- /dev/null\n+++ b/test/sql/copy/csv/test_dateformat.test\n@@ -0,0 +1,48 @@\n+# name: test/sql/copy/csv/test_dateformat.test\n+# description: Test CSVs with a variable date format\n+# group: [csv]\n+\n+statement ok\n+CREATE TABLE dates (d DATE);\n+\n+# base date format does not work here\n+statement error\n+COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (HEADER 0)\n+\n+statement ok\n+COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (HEADER 0, DATEFORMAT '%d/%m/%Y')\n+\n+query I\n+SELECT * FROM dates\n+----\n+2019-06-05\n+\n+# if we reverse the date format, we get a different result\n+statement ok\n+COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (HEADER 0, DATEFORMAT '%m/%d/%Y')\n+\n+query I\n+SELECT * FROM dates ORDER BY d\n+----\n+2019-05-06\n+2019-06-05\n+\n+# timestamp format\n+statement ok\n+CREATE TABLE timestamps(t TIMESTAMP);\n+\n+# timestamp format\n+statement ok\n+COPY timestamps FROM 'test/sql/copy/csv/data/test/timestampformat.csv' (HEADER 0, DELIMITER '|', TIMESTAMPFORMAT '%a %d, %B %Y, %I:%M:%S %p')\n+\n+query I\n+SELECT * FROM timestamps\n+----\n+2003-06-30 12:03:10\n+\n+# incorrect date/timestamp format results in an error\n+statement error\n+COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (HEADER 0, DATEFORMAT '%')\n+\n+statement error\n+COPY timestamps FROM 'test/sql/copy/csv/data/test/timestampformat.csv' (HEADER 0, DELIMITER '|', TIMESTAMPFORMAT '%')\n\\ No newline at end of file\ndiff --git a/test/sql/copy/csv/test_read_csv.test b/test/sql/copy/csv/test_read_csv.test\nindex c09370f79d8b..c60fe3111d37 100644\n--- a/test/sql/copy/csv/test_read_csv.test\n+++ b/test/sql/copy/csv/test_read_csv.test\n@@ -1,10 +1,60 @@\n # name: test/sql/copy/csv/test_read_csv.test\n-# description: Test read CSV function with lineitem\n+# description: Test read CSV function\n # group: [csv]\n \n+# read csv with explicit separator\n+statement ok\n+CREATE TABLE abac_tbl (a VARCHAR, b VARCHAR, c VARCHAR);\n+\n+query I\n+INSERT INTO abac_tbl SELECT * FROM read_csv('test/sql/copy/csv/data/abac/abac.csv', columns=STRUCT_PACK(a := 'VARCHAR', b := 'VARCHAR', c := 'VARCHAR'), sep='ABAC')\n+----\n+1\n+\n+query TTT\n+SELECT * FROM abac_tbl\n+----\n+AB\tABAB\tNULL\n+\n+# dateformat\n+statement ok\n+CREATE TABLE dates (d DATE);\n+\n+# base date format does not work here\n+statement error\n+INSERT INTO dates SELECT * FROM read_csv('test/sql/copy/csv/data/test/dateformat.csv', columns=STRUCT_PACK(d := 'DATE'), header=0)\n+\n+# have to specify it ourselves\n+statement ok\n+INSERT INTO dates SELECT * FROM read_csv('test/sql/copy/csv/data/test/dateformat.csv', columns=STRUCT_PACK(d := 'DATE'), header=0, dateformat='%d/%m/%Y')\n+\n+query I\n+SELECT * FROM dates\n+----\n+2019-06-05\n+\n+# dateformat should also work with auto format\n+statement ok\n+INSERT INTO dates SELECT * FROM read_csv('test/sql/copy/csv/data/test/dateformat.csv', dateformat='%m/%d/%Y')\n+\n+query I\n+SELECT * FROM dates ORDER BY 1\n+----\n+2019-05-06\n+2019-06-05\n+\n+# we can also do this for timestamps\n+statement ok\n+CREATE TABLE timestamps AS SELECT * FROM read_csv('test/sql/copy/csv/data/test/dateformat.csv', timestampformat='%m/%d/%Y')\n+\n+query I\n+SELECT * FROM timestamps\n+----\n+2019-05-06 00:00:00\n+\n # create a view using the read_csv function\n statement ok\n-CREATE VIEW lineitem AS SELECT * FROM read_csv('test/sql/copy/csv/data/real/lineitem_sample.csv', '|', STRUCT_PACK(l_orderkey := 'INT', l_partkey := 'INT', l_suppkey := 'INT', l_linenumber := 'INT', l_quantity := 'INTEGER', l_extendedprice := 'DOUBLE', l_discount := 'DOUBLE', l_tax := 'DOUBLE', l_returnflag := 'VARCHAR', l_linestatus := 'VARCHAR', l_shipdate := 'DATE', l_commitdate := 'DATE', l_receiptdate := 'DATE', l_shipinstruct := 'VARCHAR', l_shipmode := 'VARCHAR', l_comment := 'VARCHAR'));\n+CREATE VIEW lineitem AS SELECT * FROM read_csv('test/sql/copy/csv/data/real/lineitem_sample.csv', sep='|', columns=STRUCT_PACK(l_orderkey := 'INT', l_partkey := 'INT', l_suppkey := 'INT', l_linenumber := 'INT', l_quantity := 'INTEGER', l_extendedprice := 'DOUBLE', l_discount := 'DOUBLE', l_tax := 'DOUBLE', l_returnflag := 'VARCHAR', l_linestatus := 'VARCHAR', l_shipdate := 'DATE', l_commitdate := 'DATE', l_receiptdate := 'DATE', l_shipinstruct := 'VARCHAR', l_shipmode := 'VARCHAR', l_comment := 'VARCHAR'));\n \n # each of these will read the CSV again through the view\n query I\n@@ -13,10 +63,10 @@ SELECT COUNT(*) FROM lineitem\n 10\n \n query IT\n-SELECT l_partkey, l_comment FROM lineitem WHERE l_orderkey=1 ORDER BY l_linenumber;\n+SELECT l_partkey, RTRIM(l_comment) FROM lineitem WHERE l_orderkey=1 ORDER BY l_linenumber;\n ----\n 15519\tegular courts above the\n-6731\tly final dependencies: slyly bold \n+6731\tly final dependencies: slyly bold\n 6370\triously. regular, express dep\n 214\tlites. fluffily even de\n 2403\t pending foxes. slyly re\n@@ -25,5 +75,5 @@ SELECT l_partkey, l_comment FROM lineitem WHERE l_orderkey=1 ORDER BY l_linenumb\n # test incorrect usage of read_csv function\n # wrong argument type\n statement error\n-SELECT * FROM read_csv('test/sql/copy/csv/data/real/lineitem_sample.csv', '|', STRUCT_PACK(l_orderkey := 5))\n+SELECT * FROM read_csv('test/sql/copy/csv/data/real/lineitem_sample.csv', sep='|', columns=STRUCT_PACK(l_orderkey := 5))\n \ndiff --git a/test/sql/function/date/test_strftime.test b/test/sql/function/date/test_strftime.test\nnew file mode 100644\nindex 000000000000..84a7df7427b3\n--- /dev/null\n+++ b/test/sql/function/date/test_strftime.test\n@@ -0,0 +1,88 @@\n+# name: test/sql/function/date/test_strftime.test\n+# description: Test strftime function\n+# group: [date]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# simple single specifier\n+query I\n+SELECT strftime(DATE '1992-01-01', '%Y');\n+----\n+1992\n+\n+# some literals\n+query I\n+SELECT strftime(DATE '1992-01-01', '(%Y)');\n+----\n+(1992)\n+\n+# escapes\n+query I\n+SELECT strftime(DATE '1992-01-01', '%% %Y %%');\n+----\n+% 1992 %\n+\n+# many consecutive escapes\n+query I\n+SELECT strftime(DATE '1992-01-01', '%%%%%% %Y %%%%%%');\n+----\n+%%% 1992 %%%\n+\n+# multiple specifiers\n+query I\n+SELECT strftime(DATE '1992-02-01', '%d/%m/%Y');\n+----\n+01/02/1992\n+\n+# we can repeat the same specifier many times\n+query I\n+SELECT strftime(DATE '1992-02-01', '%Y %Y %Y %Y');\n+----\n+1992 1992 1992 1992\n+\n+# test on a table\n+statement ok\n+CREATE TABLE dates(d DATE);\n+INSERT INTO dates VALUES ('1992-01-01'), ('1993-03-20'), (NULL);\n+\n+query I\n+SELECT strftime(d, '%d/%m/%Y') FROM dates ORDER BY d;\n+----\n+NULL\n+01/01/1992\n+20/03/1993\n+\n+# null date\n+query I\n+SELECT strftime(NULL::DATE, '%d/%m/%Y') FROM dates ORDER BY d;\n+----\n+NULL\n+NULL\n+NULL\n+\n+# null format\n+query I\n+SELECT strftime(d, NULL) FROM dates ORDER BY d;\n+----\n+NULL\n+NULL\n+NULL\n+\n+# no specifiers, only constant\n+query I\n+SELECT strftime(DATE '1992-01-01', 'hello world');\n+----\n+hello world\n+\n+# non-constant format not supported\n+statement error\n+SELECT strftime(d, d::VARCHAR) FROM dates ORDER BY d;\n+\n+# unterminated escape\n+statement error\n+SELECT strftime(DATE '1992-01-01', '%');\n+\n+# unrecognized code\n+statement error\n+SELECT strftime(DATE '1992-01-01', '%R');\ndiff --git a/test/sql/function/date/test_strftime_exhaustive.test b/test/sql/function/date/test_strftime_exhaustive.test\nnew file mode 100644\nindex 000000000000..542d821df1ab\n--- /dev/null\n+++ b/test/sql/function/date/test_strftime_exhaustive.test\n@@ -0,0 +1,354 @@\n+# name: test/sql/function/date/test_strftime_exhausted.test\n+# description: Test all strftime % codes with the date type\n+# group: [date]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE dates(d DATE);\n+INSERT INTO dates VALUES ('1992-01-01'), ('1993-03-20'), ('2020-08-09'), ('2020-08-10'), (NULL);\n+\n+# %a: Abbreviated weekday name\n+query I\n+SELECT strftime(d, '%a') FROM dates ORDER BY d;\n+----\n+NULL\n+Wed\n+Sat\n+Sun\n+Mon\n+\n+# %A: Full weekday name\n+query I\n+SELECT strftime(d, '%A') FROM dates ORDER BY d;\n+----\n+NULL\n+Wednesday\n+Saturday\n+Sunday\n+Monday\n+\n+# %w - Weekday as a decimal number.\n+query I\n+SELECT strftime(d, '%w') FROM dates ORDER BY d;\n+----\n+NULL\n+3\n+6\n+0\n+1\n+\n+# %d - Day of the month as a zero-padded decimal.\n+query I\n+SELECT strftime(d, '%d') FROM dates ORDER BY d;\n+----\n+NULL\n+01\n+20\n+09\n+10\n+\n+# %-d - Day of the month as a decimal number.\n+query I\n+SELECT strftime(d, '%-d') FROM dates ORDER BY d;\n+----\n+NULL\n+1\n+20\n+9\n+10\n+\n+# %b - Abbreviated month name.\n+query I\n+SELECT strftime(d, '%b') FROM dates ORDER BY d;\n+----\n+NULL\n+Jan\n+Mar\n+Aug\n+Aug\n+\n+# %h - alias for %b\n+query I\n+SELECT strftime(d, '%h') FROM dates ORDER BY d;\n+----\n+NULL\n+Jan\n+Mar\n+Aug\n+Aug\n+\n+# %B - Full month name\n+query I\n+SELECT strftime(d, '%B') FROM dates ORDER BY d;\n+----\n+NULL\n+January\n+March\n+August\n+August\n+\n+# %m - Month as a zero-padded decimal number\n+query I\n+SELECT strftime(d, '%m') FROM dates ORDER BY d;\n+----\n+NULL\n+01\n+03\n+08\n+08\n+\n+# %-m - Month as a decimal number. (1, 2, ..., 12)\n+query I\n+SELECT strftime(d, '%-m') FROM dates ORDER BY d;\n+----\n+NULL\n+1\n+3\n+8\n+8\n+\n+# %y - Year without century as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%y') FROM dates ORDER BY d;\n+----\n+NULL\n+92\n+93\n+20\n+20\n+\n+# %-y - Year without century as a decimal number.\n+query I\n+SELECT strftime(d, '%-y') FROM dates ORDER BY d;\n+----\n+NULL\n+92\n+93\n+20\n+20\n+\n+query I\n+SELECT strftime(DATE '2001-01-01', '%-y')\n+----\n+1\n+\n+# %Y - Year with century as a decimal number.\n+query I\n+SELECT strftime(d, '%Y') FROM dates ORDER BY d;\n+----\n+NULL\n+1992\n+1993\n+2020\n+2020\n+\n+# %H - Hour (24-hour clock) as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%H') FROM dates ORDER BY d;\n+----\n+NULL\n+00\n+00\n+00\n+00\n+\n+# %-H - Hour (24-hour clock) as a decimal number. (0, 1, ..., 23)\n+query I\n+SELECT strftime(d, '%-H') FROM dates ORDER BY d;\n+----\n+NULL\n+0\n+0\n+0\n+0\n+\n+# %I - Hour (12-hour clock) as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%I') FROM dates ORDER BY d;\n+----\n+NULL\n+12\n+12\n+12\n+12\n+\n+# %-I - Hour (12-hour clock) as a decimal number. (1, 2, ... 12)\n+query I\n+SELECT strftime(d, '%-I') FROM dates ORDER BY d;\n+----\n+NULL\n+12\n+12\n+12\n+12\n+\n+# %p - Locale\u2019s AM or PM.\n+query I\n+SELECT strftime(d, '%p') FROM dates ORDER BY d;\n+----\n+NULL\n+AM\n+AM\n+AM\n+AM\n+\n+# %M - Minute as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%M') FROM dates ORDER BY d;\n+----\n+NULL\n+00\n+00\n+00\n+00\n+\n+# %-M - Minute as a decimal number. (0, 1, ..., 59)\n+query I\n+SELECT strftime(d, '%-M') FROM dates ORDER BY d;\n+----\n+NULL\n+0\n+0\n+0\n+0\n+\n+# %S - Second as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%S') FROM dates ORDER BY d;\n+----\n+NULL\n+00\n+00\n+00\n+00\n+\n+# %-S - Second as a decimal number. (0, 1, ..., 59)\n+query I\n+SELECT strftime(d, '%-S') FROM dates ORDER BY d;\n+----\n+NULL\n+0\n+0\n+0\n+0\n+\n+# %f - Microsecond as a decimal number, zero-padded on the left.\n+query I\n+SELECT strftime(d, '%f') FROM dates ORDER BY d;\n+----\n+NULL\n+000000\n+000000\n+000000\n+000000\n+\n+# %z - UTC offset in the form +HHMM or -HHMM.\n+query I\n+SELECT strftime(d, '%z') FROM dates ORDER BY d;\n+----\n+NULL\n+(empty)\n+(empty)\n+(empty)\n+(empty)\n+\n+# %Z - Time zone name.\n+query I\n+SELECT strftime(d, '%Z') FROM dates ORDER BY d;\n+----\n+NULL\n+(empty)\n+(empty)\n+(empty)\n+(empty)\n+\n+# %j - Day of the year as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%j') FROM dates ORDER BY d;\n+----\n+NULL\n+001\n+079\n+222\n+223\n+\n+# %-j - Day of the year as a decimal number. (1, 2, ..., 366)\n+query I\n+SELECT strftime(d, '%-j') FROM dates ORDER BY d;\n+----\n+NULL\n+1\n+79\n+222\n+223\n+\n+# %U - Week number of the year (Sunday as the first day of the week).\n+query I\n+SELECT strftime(d, '%U') FROM dates ORDER BY d;\n+----\n+NULL\n+00\n+11\n+32\n+32\n+\n+# %W - Week number of the year (Monday as the first day of the week).\n+query I\n+SELECT strftime(d, '%W') FROM dates ORDER BY d;\n+----\n+NULL\n+00\n+11\n+31\n+32\n+\n+# %c - Locale\u2019s appropriate date and time representation.\n+query I\n+SELECT strftime(d, '%c') FROM dates ORDER BY d;\n+----\n+NULL\n+1992-01-01 00:00:00\n+1993-03-20 00:00:00\n+2020-08-09 00:00:00\n+2020-08-10 00:00:00\n+\n+query I\n+SELECT strftime(d, 'XX%cXX') FROM dates ORDER BY d;\n+----\n+NULL\n+XX1992-01-01 00:00:00XX\n+XX1993-03-20 00:00:00XX\n+XX2020-08-09 00:00:00XX\n+XX2020-08-10 00:00:00XX\n+\n+# %x - Locale\u2019s appropriate date representation.\n+query I\n+SELECT strftime(d, '%x') FROM dates ORDER BY d;\n+----\n+NULL\n+1992-01-01\n+1993-03-20\n+2020-08-09\n+2020-08-10\n+\n+# X - Locale\u2019s appropriate time representation.\n+query I\n+SELECT strftime(d, '%X') FROM dates ORDER BY d;\n+----\n+NULL\n+00:00:00\n+00:00:00\n+00:00:00\n+00:00:00\n+\n+\n+query I\n+SELECT strftime(d, 'XX%cXX%xXX%XXX') FROM dates ORDER BY d;\n+----\n+NULL\n+XX1992-01-01 00:00:00XX1992-01-01XX00:00:00XX\n+XX1993-03-20 00:00:00XX1993-03-20XX00:00:00XX\n+XX2020-08-09 00:00:00XX2020-08-09XX00:00:00XX\n+XX2020-08-10 00:00:00XX2020-08-10XX00:00:00XX\ndiff --git a/test/sql/function/timestamp/age.test b/test/sql/function/timestamp/age.test\nindex 2bce28ad61dd..4e7475054919 100644\n--- a/test/sql/function/timestamp/age.test\n+++ b/test/sql/function/timestamp/age.test\n@@ -140,3 +140,15 @@ query T\n SELECT AGE(NULL, TIMESTAMP '1957-06-13');\n ----\n NULL\n+\n+# date can also be used with AGE\n+# hopefully the clock is not off by more than a century\n+query T\n+SELECT INTERVAL '1' DAY < AGE(DATE '1900-06-13');\n+----\n+1\n+\n+query T\n+SELECT AGE(DATE '1900-01-01', DATE '1950-01-01');\n+----\n+50 years\ndiff --git a/test/sql/function/timestamp/test_strftime_timestamp.test b/test/sql/function/timestamp/test_strftime_timestamp.test\nnew file mode 100644\nindex 000000000000..ac6dabd151a3\n--- /dev/null\n+++ b/test/sql/function/timestamp/test_strftime_timestamp.test\n@@ -0,0 +1,336 @@\n+# name: test/sql/function/date/test_strftime_exhausted.test\n+# description: Test all strftime % codes with the date type\n+# group: [date]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE timestamps(d TIMESTAMP);\n+INSERT INTO timestamps VALUES ('1992-01-01 01:20:30'), ('1993-03-20 23:50:01'), ('2020-08-09 12:01:55'), ('2020-08-10 10:10:10'), (NULL);\n+\n+# %a: Abbreviated weekday name\n+query I\n+SELECT strftime(d, '%a') FROM timestamps ORDER BY d;\n+----\n+NULL\n+Wed\n+Sat\n+Sun\n+Mon\n+\n+# %A: Full weekday name\n+query I\n+SELECT strftime(d, '%A') FROM timestamps ORDER BY d;\n+----\n+NULL\n+Wednesday\n+Saturday\n+Sunday\n+Monday\n+\n+# %w - Weekday as a decimal number.\n+query I\n+SELECT strftime(d, '%w') FROM timestamps ORDER BY d;\n+----\n+NULL\n+3\n+6\n+0\n+1\n+\n+# %d - Day of the month as a zero-padded decimal.\n+query I\n+SELECT strftime(d, '%d') FROM timestamps ORDER BY d;\n+----\n+NULL\n+01\n+20\n+09\n+10\n+\n+# %-d - Day of the month as a decimal number.\n+query I\n+SELECT strftime(d, '%-d') FROM timestamps ORDER BY d;\n+----\n+NULL\n+1\n+20\n+9\n+10\n+\n+# %b - Abbreviated month name.\n+query I\n+SELECT strftime(d, '%b') FROM timestamps ORDER BY d;\n+----\n+NULL\n+Jan\n+Mar\n+Aug\n+Aug\n+\n+# %h - alias for %b\n+query I\n+SELECT strftime(d, '%h') FROM timestamps ORDER BY d;\n+----\n+NULL\n+Jan\n+Mar\n+Aug\n+Aug\n+\n+# %B - Full month name\n+query I\n+SELECT strftime(d, '%B') FROM timestamps ORDER BY d;\n+----\n+NULL\n+January\n+March\n+August\n+August\n+\n+# %m - Month as a zero-padded decimal number\n+query I\n+SELECT strftime(d, '%m') FROM timestamps ORDER BY d;\n+----\n+NULL\n+01\n+03\n+08\n+08\n+\n+# %-m - Month as a decimal number. (1, 2, ..., 12)\n+query I\n+SELECT strftime(d, '%-m') FROM timestamps ORDER BY d;\n+----\n+NULL\n+1\n+3\n+8\n+8\n+\n+# %y - Year without century as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%y') FROM timestamps ORDER BY d;\n+----\n+NULL\n+92\n+93\n+20\n+20\n+\n+# %-y - Year without century as a decimal number.\n+query I\n+SELECT strftime(d, '%-y') FROM timestamps ORDER BY d;\n+----\n+NULL\n+92\n+93\n+20\n+20\n+\n+query I\n+SELECT strftime(DATE '2001-01-01', '%-y')\n+----\n+1\n+\n+# %Y - Year with century as a decimal number.\n+query I\n+SELECT strftime(d, '%Y') FROM timestamps ORDER BY d;\n+----\n+NULL\n+1992\n+1993\n+2020\n+2020\n+\n+# %H - Hour (24-hour clock) as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%H') FROM timestamps ORDER BY d;\n+----\n+NULL\n+01\n+23\n+12\n+10\n+\n+# %-H - Hour (24-hour clock) as a decimal number. (0, 1, ..., 23)\n+query I\n+SELECT strftime(d, '%-H') FROM timestamps ORDER BY d;\n+----\n+NULL\n+1\n+23\n+12\n+10\n+\n+# %I - Hour (12-hour clock) as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%I') FROM timestamps ORDER BY d;\n+----\n+NULL\n+01\n+11\n+12\n+10\n+\n+# %-I - Hour (12-hour clock) as a decimal number. (1, 2, ... 12)\n+query I\n+SELECT strftime(d, '%-I') FROM timestamps ORDER BY d;\n+----\n+NULL\n+1\n+11\n+12\n+10\n+\n+# %p - Locale\u2019s AM or PM.\n+query I\n+SELECT strftime(d, '%p') FROM timestamps ORDER BY d;\n+----\n+NULL\n+AM\n+PM\n+PM\n+AM\n+\n+# %M - Minute as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%M') FROM timestamps ORDER BY d;\n+----\n+NULL\n+20\n+50\n+01\n+10\n+\n+# %-M - Minute as a decimal number. (0, 1, ..., 59)\n+query I\n+SELECT strftime(d, '%-M') FROM timestamps ORDER BY d;\n+----\n+NULL\n+20\n+50\n+1\n+10\n+\n+# %S - Second as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%S') FROM timestamps ORDER BY d;\n+----\n+NULL\n+30\n+01\n+55\n+10\n+\n+# %-S - Second as a decimal number. (0, 1, ..., 59)\n+query I\n+SELECT strftime(d, '%-S') FROM timestamps ORDER BY d;\n+----\n+NULL\n+30\n+1\n+55\n+10\n+\n+# %f - Microsecond as a decimal number, zero-padded on the left.\n+query I\n+SELECT strftime(d, '%f') FROM timestamps ORDER BY d;\n+----\n+NULL\n+000000\n+000000\n+000000\n+000000\n+\n+# %z - UTC offset in the form +HHMM or -HHMM.\n+query I\n+SELECT strftime(d, '%z') FROM timestamps ORDER BY d;\n+----\n+NULL\n+(empty)\n+(empty)\n+(empty)\n+(empty)\n+\n+# %Z - Time zone name.\n+query I\n+SELECT strftime(d, '%Z') FROM timestamps ORDER BY d;\n+----\n+NULL\n+(empty)\n+(empty)\n+(empty)\n+(empty)\n+\n+# %j - Day of the year as a zero-padded decimal number.\n+query I\n+SELECT strftime(d, '%j') FROM timestamps ORDER BY d;\n+----\n+NULL\n+001\n+079\n+222\n+223\n+\n+# %-j - Day of the year as a decimal number. (1, 2, ..., 366)\n+query I\n+SELECT strftime(d, '%-j') FROM timestamps ORDER BY d;\n+----\n+NULL\n+1\n+79\n+222\n+223\n+\n+\n+# %U - Week number of the year (Sunday as the first day of the week).\n+query I\n+SELECT strftime(d, '%U') FROM timestamps ORDER BY d;\n+----\n+NULL\n+00\n+11\n+32\n+32\n+\n+# %W - Week number of the year (Monday as the first day of the week).\n+query I\n+SELECT strftime(d, '%W') FROM timestamps ORDER BY d;\n+----\n+NULL\n+00\n+11\n+31\n+32\n+\n+# %c - Locale\u2019s appropriate date and time representation.\n+query I\n+SELECT strftime(d, '%c') FROM timestamps ORDER BY d;\n+----\n+NULL\n+1992-01-01 01:20:30\n+1993-03-20 23:50:01\n+2020-08-09 12:01:55\n+2020-08-10 10:10:10\n+\n+# %x - Locale\u2019s appropriate date representation.\n+query I\n+SELECT strftime(d, '%x') FROM timestamps ORDER BY d;\n+----\n+NULL\n+1992-01-01\n+1993-03-20\n+2020-08-09\n+2020-08-10\n+\n+# X - Locale\u2019s appropriate time representation.\n+query I\n+SELECT strftime(d, '%X') FROM timestamps ORDER BY d;\n+----\n+NULL\n+01:20:30\n+23:50:01\n+12:01:55\n+10:10:10\ndiff --git a/test/sql/function/timestamp/test_strptime.test b/test/sql/function/timestamp/test_strptime.test\nnew file mode 100644\nindex 000000000000..785c0111587f\n--- /dev/null\n+++ b/test/sql/function/timestamp/test_strptime.test\n@@ -0,0 +1,194 @@\n+# name: test/sql/function/timestamp/test_strptime.test\n+# description: Test strptime function\n+# group: [timestamp]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+SELECT strptime('21 June, 2018', '%d %B, %Y')\n+----\n+2018-06-21 00:00:00\n+\n+query I\n+SELECT strptime('21/10/2018', '%d/%m/%Y')\n+----\n+2018-10-21 00:00:00\n+\n+query I\n+SELECT strptime('2018-20-10', '%Y-%d-%m')\n+----\n+2018-10-20 00:00:00\n+\n+query I\n+SELECT strptime('Mon 30, June 2003, 12:03:10 AM', '%a %d, %B %Y, %I:%M:%S %p')\n+----\n+2003-06-30 00:03:10\n+\n+query I\n+SELECT strptime('Mon 30, June 2003, 12:03:10 PM', '%a %d, %B %Y, %I:%M:%S %p')\n+----\n+2003-06-30 12:03:10\n+\n+query I\n+SELECT strptime('Mon 30, December 2003, 7:3:5 PM', '%a %d, %B %Y, %I:%M:%S %p')\n+----\n+2003-12-30 19:03:05\n+\n+query I\n+SELECT strptime('Tuesday 30, December 2003, 7:3:5 PM', '%A %d, %B %Y, %I:%M:%S %p')\n+----\n+2003-12-30 19:03:05\n+\n+query I\n+SELECT strptime('Mon 30, December 30, 7:3:5 PM', '%a %d, %B %y, %I:%M:%S %p')\n+----\n+2030-12-30 19:03:05\n+\n+# for strptime there is no difference between %- and %\n+query I\n+SELECT strptime('Mon 30, June 2003, 12:03:10 AM', '%a %-d, %B %Y, %-I:%-M:%-S %p')\n+----\n+2003-06-30 00:03:10\n+\n+# lowercase also works\n+query I\n+SELECT strptime('mon', '%a')\n+----\n+1900-01-01 00:00:00\n+\n+query I\n+SELECT strptime('tuesday', '%A')\n+----\n+1900-01-01 00:00:00\n+\n+query I\n+SELECT strptime('jun', '%b')\n+----\n+1900-06-01 00:00:00\n+\n+# empty specifier and string\n+query I\n+SELECT strptime('', '')\n+----\n+1900-01-01 00:00:00\n+\n+query I\n+SELECT strptime(NULL, '')\n+----\n+NULL\n+\n+query I\n+SELECT strptime('', NULL)\n+----\n+NULL\n+\n+# different errors\n+# month out of range\n+statement error\n+SELECT strptime('2018-20-10', '%Y-%m-%d')\n+\n+# day out of range\n+statement error\n+SELECT strptime('2018-10-100', '%Y-%m-%d')\n+\n+# year without century out of range\n+statement error\n+SELECT strptime('969-10-10', '%y-%m-%d')\n+\n+# literal part does not match\n+statement error\n+SELECT strptime('2000/10/10', '%Y-%m-%d')\n+\n+# incorrect date\n+statement error\n+SELECT strptime('2001-02-30', '%Y-%m-%d')\n+\n+# incorrect date\n+statement error\n+SELECT strptime('2000-10-hello', '%Y-%m-%d')\n+\n+# incorrect hour\n+statement error\n+SELECT strptime('2000-10-01 24:00:00', '%Y-%m-%d %H:%M:%S')\n+\n+# incorrect hour with 12 hour clock\n+statement error\n+SELECT strptime('2000-10-01 00:00:00 AM', '%Y-%m-%d %I:%M:%S %p')\n+\n+statement error\n+SELECT strptime('2000-10-01 13:00:00 AM', '%Y-%m-%d %I:%M:%S %p')\n+\n+# incorrect minute\n+statement error\n+SELECT strptime('2000-10-01 23:60:00', '%Y-%m-%d %H:%M:%S')\n+\n+# incorrect seconds\n+statement error\n+SELECT strptime('2000-10-01 23:59:60', '%Y-%m-%d %H:%M:%S')\n+\n+# incorrect microseconds\n+statement error\n+SELECT strptime('2000-10-01 23:59:59.10000000', '%Y-%m-%d %H:%M:%S.%f')\n+\n+# huge number\n+statement error\n+SELECT strptime('2000-10-01 23:59:59.1000000000000000000000000000', '%Y-%m-%d %H:%M:%S.%f')\n+\n+# empty string\n+statement error\n+SELECT strptime('', '%Y-%m-%d %H:%M:%S.%f')\n+\n+# empty string with am/pm\n+statement error\n+SELECT strptime('', '%p')\n+\n+statement error\n+SELECT strptime('a', '%p')\n+\n+# incorrect am/pm\n+statement error\n+SELECT strptime('mp', '%p')\n+\n+statement error\n+SELECT strptime('pp', '%p')\n+\n+# incorrect abbreviated weekday name\n+statement error\n+SELECT strptime('moa', '%a')\n+\n+# incorrect weekday name\n+statement error\n+SELECT strptime('moaday', '%A')\n+\n+statement error\n+SELECT strptime('mondayy', '%A')\n+\n+# incorrect abbreviated month name\n+statement error\n+SELECT strptime('juk', '%b')\n+\n+# incorrect weekday name\n+statement error\n+SELECT strptime('juke', '%B')\n+\n+statement error\n+SELECT strptime('junee', '%B')\n+\n+# day of year not supported\n+statement error\n+SELECT strptime('30', '%j')\n+\n+statement error\n+SELECT strptime('30', '%-j')\n+\n+# week numbers not supported\n+statement error\n+SELECT strptime('30', '%U')\n+\n+statement error\n+SELECT strptime('30', '%W')\n+\n+# AM/PM out of range\n+statement error\n+SELECT strptime('Mon 30, December 30, 20:3:5 PM', '%a %d, %B %y, %H:%M:%S %p')\ndiff --git a/test/sql/storage/test_checksum.cpp b/test/sql/storage/test_checksum.cpp\nindex bfd52b2f70c8..b6b6e980cb0b 100644\n--- a/test/sql/storage/test_checksum.cpp\n+++ b/test/sql/storage/test_checksum.cpp\n@@ -25,7 +25,7 @@ TEST_CASE(\"Test functioning of checksum\", \"[storage]\") {\n \tdatabase.reset();\n \n \t// now write random values into the file\n-\tauto handle = fs.OpenFile(storage_database, FileFlags::WRITE);\n+\tauto handle = fs.OpenFile(storage_database, FileFlags::FILE_FLAGS_WRITE);\n \tint8_t value = 0x22;\n \tfs.Write(*handle, &value, sizeof(int8_t), 100);\n \thandle->Sync();\ndiff --git a/test/sql/storage/test_database_size.cpp b/test/sql/storage/test_database_size.cpp\nindex 3c9fac7eec54..27cb3d7513b1 100644\n--- a/test/sql/storage/test_database_size.cpp\n+++ b/test/sql/storage/test_database_size.cpp\n@@ -40,7 +40,7 @@ TEST_CASE(\"Test that database size does not grow after many checkpoints\", \"[stor\n \t// get the size of the database\n \tint64_t size;\n \t{\n-\t\tauto handle = fs.OpenFile(storage_database, FileFlags::READ);\n+\t\tauto handle = fs.OpenFile(storage_database, FileFlags::FILE_FLAGS_READ);\n \t\tsize = fs.GetFileSize(*handle);\n \t\tREQUIRE(size >= 0);\n \t}\n@@ -61,7 +61,7 @@ TEST_CASE(\"Test that database size does not grow after many checkpoints\", \"[stor\n \t// get the new file size\n \tint64_t new_size;\n \t{\n-\t\tauto handle = fs.OpenFile(storage_database, FileFlags::READ);\n+\t\tauto handle = fs.OpenFile(storage_database, FileFlags::FILE_FLAGS_READ);\n \t\tnew_size = fs.GetFileSize(*handle);\n \t\tREQUIRE(new_size >= 0);\n \t}\ndiff --git a/test/sql/storage/test_readonly.cpp b/test/sql/storage/test_readonly.cpp\nindex 9dc3cb1cad8b..88d216586c6d 100644\n--- a/test/sql/storage/test_readonly.cpp\n+++ b/test/sql/storage/test_readonly.cpp\n@@ -8,7 +8,7 @@ namespace duckdb {\n \n class ReadOnlyFileSystem : public FileSystem {\n \tunique_ptr<FileHandle> OpenFile(const char *path, uint8_t flags, FileLockType lock_type) override {\n-\t\tif (flags & FileFlags::WRITE) {\n+\t\tif (flags & FileFlags::FILE_FLAGS_WRITE) {\n \t\t\tthrow Exception(\"RO file system\");\n \t\t}\n \t\treturn FileSystem::OpenFile(path, flags, lock_type);\ndiff --git a/test/sql/types/timestamp/test_timestamp.test b/test/sql/types/timestamp/test_timestamp.test\nindex 9be3ef6a7dd2..0cd4ddfe3ea5 100644\n--- a/test/sql/types/timestamp/test_timestamp.test\n+++ b/test/sql/types/timestamp/test_timestamp.test\n@@ -16,6 +16,29 @@ SELECT timestamp '2017-07-23 13:10:11';\n ----\n 2017-07-23 13:10:11\n \n+# iso timestamps\n+query TT\n+SELECT timestamp '2017-07-23T13:10:11', timestamp '2017-07-23T13:10:11Z';\n+----\n+2017-07-23 13:10:11\n+2017-07-23 13:10:11\n+\n+# spaces everywhere\n+query T\n+SELECT timestamp '    2017-07-23     13:10:11    ';\n+----\n+2017-07-23 13:10:11\n+\n+# other trailing, preceding, or middle gunk is not accepted\n+statement error\n+SELECT timestamp '    2017-07-23     13:10:11    AA';\n+\n+statement error\n+SELECT timestamp 'AA2017-07-23 13:10:11';\n+\n+statement error\n+SELECT timestamp '2017-07-23A13:10:11';\n+\n query T\n SELECT t FROM timestamp ORDER BY t;\n ----\ndiff --git a/test/sql/types/timestamp/test_timestamp_ms.test b/test/sql/types/timestamp/test_timestamp_ms.test\nindex 81fcea167f21..e91b493c13be 100644\n--- a/test/sql/types/timestamp/test_timestamp_ms.test\n+++ b/test/sql/types/timestamp/test_timestamp_ms.test\n@@ -7,3 +7,8 @@ SELECT CAST('2001-04-20 14:42:11.123' AS TIMESTAMP) a, CAST('2001-04-20 14:42:11\n ----\n 2001-04-20 14:42:11.123\t2001-04-20 14:42:11\n \n+#  many ms\n+query I\n+SELECT TIMESTAMP '2001-04-20 14:42:11.12300000000000000000';\n+----\n+2001-04-20 14:42:11.123\ndiff --git a/test/sqlite/test_sqllogictest.cpp b/test/sqlite/test_sqllogictest.cpp\nindex f1e68d506f77..252c98faf43c 100644\n--- a/test/sqlite/test_sqllogictest.cpp\n+++ b/test/sqlite/test_sqllogictest.cpp\n@@ -81,6 +81,10 @@ struct SQLLogicTestRunner {\n \tunique_ptr<DBConfig> config;\n \tunordered_set<string> extensions;\n \tunordered_map<string, unique_ptr<Connection>> named_connection_map;\n+\tbool output_hash_mode = false;\n+\tbool output_result_mode = false;\n+\tbool debug_mode = false;\n+\tint hashThreshold = DEFAULT_HASH_THRESHOLD; /* Threshold for hashing res */\n };\n \n /*\n@@ -511,9 +515,6 @@ struct Query : public Command {\n \tidx_t expected_column_count = 0;\n \tSortStyle sort_style = SortStyle::NO_SORT;\n \tvector<string> values;\n-\tbool output_result_mode = false;\n-\tint hashThreshold = 0;\n-\tbool output_hash_mode = false;\n \tbool query_has_label = false;\n \tstring query_label;\n \n@@ -530,10 +531,21 @@ struct RestartCommand : public Command {\n void Statement::Execute() {\n \tauto connection = CommandConnection();\n \n+\tif (runner.output_result_mode || runner.debug_mode) {\n+\t\tprint_line_sep();\n+\t\tprint_header(\"File \" + file_name + \":\" + to_string(query_line) + \")\");\n+\t\tprint_sql(sql_query);\n+\t\tprint_line_sep();\n+\t}\n+\n \tquery_break(query_line);\n \tauto result = connection->Query(sql_query);\n \tbool error = !result->success;\n \n+\tif (runner.output_result_mode || runner.debug_mode) {\n+\t\tresult->Print();\n+\t}\n+\n \t/* Check to see if we are expecting success or failure */\n \tif (!expect_ok) {\n \t\terror = !error;\n@@ -566,6 +578,13 @@ void Query::ColumnCountMismatch(MaterializedQueryResult &result, int expected_co\n void Query::Execute() {\n \tauto connection = CommandConnection();\n \n+\tif (runner.output_result_mode || runner.debug_mode) {\n+\t\tprint_line_sep();\n+\t\tprint_header(\"File \" + file_name + \":\" + to_string(query_line) + \")\");\n+\t\tprint_sql(sql_query);\n+\t\tprint_line_sep();\n+\t}\n+\n \tquery_break(query_line);\n \tauto result = connection->Query(sql_query);\n \tif (!result->success) {\n@@ -581,10 +600,7 @@ void Query::Execute() {\n \tvector<string> azResult;\n \tint nResult;\n \tduckdbConvertResult(*result, azResult, nResult);\n-\tif (output_result_mode) {\n-\t\tprint_line_sep();\n-\t\tprint_sql(sql_query);\n-\t\tprint_line_sep();\n+\tif (runner.output_result_mode) {\n \t\t// names\n \t\tfor(idx_t c = 0; c < result->column_count(); c++) {\n \t\t\tif (c != 0) {\n@@ -652,21 +668,21 @@ void Query::Execute() {\n \t\tstd::sort(azResult.begin(), azResult.end());\n \t}\n \tchar zHash[100];                            /* Storage space for hash results */\n-\tint compare_hash = query_has_label || (hashThreshold > 0 && nResult > hashThreshold);\n+\tint compare_hash = query_has_label || (runner.hashThreshold > 0 && nResult > runner.hashThreshold);\n \t// check if the current line (the first line of the result) is a hash value\n \tif (values.size() == 1 && result_is_hash(values[0])) {\n \t\tcompare_hash = true;\n \t}\n \t/* Hash the results if we are over the hash threshold or if we\n \t** there is a hash label */\n-\tif (output_hash_mode || compare_hash) {\n+\tif (runner.output_hash_mode || compare_hash) {\n \t\tmd5_add(\"\"); /* make sure md5 is reset, even if no results */\n \t\tfor (int i = 0; i < nResult; i++) {\n \t\t\tmd5_add(azResult[i].c_str());\n \t\t\tmd5_add(\"\\n\");\n \t\t}\n \t\tsnprintf(zHash, sizeof(zHash), \"%d values hashing to %s\", nResult, md5_finish());\n-\t\tif (output_hash_mode) {\n+\t\tif (runner.output_hash_mode) {\n \t\t\tprint_line_sep();\n \t\t\tprint_sql(sql_query);\n \t\t\tprint_line_sep();\n@@ -877,10 +893,7 @@ void SQLLogicTestRunner::ExecuteFile(string script) {\n \tint nSkipped = 0;                           /* Number of SQL statements skipped */\n \tScript sScript;                             /* Script parsing status */\n \tFILE *in;                                   /* For reading script */\n-\tint hashThreshold = DEFAULT_HASH_THRESHOLD; /* Threshold for hashing res */\n \tint bHt = 0;                                /* True if -ht command-line option */\n-\tint output_hash_mode = 0;\n-\tint output_result_mode = 0;\n \tbool in_loop = false;\n \tstring loop_iterator_name;\n \tint loop_start;\n@@ -1024,9 +1037,6 @@ void SQLLogicTestRunner::ExecuteFile(string script) {\n \n \t\t\tcommand->file_name = zScriptFile;\n \t\t\tcommand->query_line = sScript.nLine;\n-\t\t\tcommand->hashThreshold = hashThreshold;\n-\t\t\tcommand->output_hash_mode = output_hash_mode;\n-\t\t\tcommand->output_result_mode = output_result_mode;\n \n \t\t\t/* Verify that the type string consists of one or more\n \t\t\t *characters\n@@ -1135,9 +1145,11 @@ void SQLLogicTestRunner::ExecuteFile(string script) {\n \t\t\tbreak;\n \t\t} else if (strcmp(sScript.azToken[0], \"mode\") == 0) {\n \t\t\tif (strcmp(sScript.azToken[1], \"output_hash\") == 0) {\n-\t\t\t\toutput_hash_mode = 1;\n+\t\t\t\toutput_hash_mode = true;\n \t\t\t} else if (strcmp(sScript.azToken[1], \"output_result\") == 0) {\n-\t\t\t\toutput_result_mode = 1;\n+\t\t\t\toutput_result_mode = true;\n+\t\t\t} else if (strcmp(sScript.azToken[1], \"debug\") == 0) {\n+\t\t\t\tdebug_mode = true;\n \t\t\t} else if (strcmp(sScript.azToken[1], \"skip\") == 0) {\n \t\t\t\tskip_execution = true;\n \t\t\t} else if (strcmp(sScript.azToken[1], \"unskip\") == 0) {\n",
  "problem_statement": "Error when insert timestamps containing T delimiter\nI'm trying to import a table that contains a series of timestamps that contain a 'T' delimiter (e.g. 2009-11-11T15:21:19) as per the ISO 8601 standard but I'm getting an error from duckdb. As a short example (using the python interface):\r\n```\r\ncon = duckdb.connect(database=':memory:', read_only=False)\r\ncon.execute(f\"CREATE TABLE tmp(testdate TIMESTAMP);\")\r\ncon.execute(f\"INSERT INTO tmp VALUES ('2009-11-11 15:21:19'), ('2009-11-11T15:21:19');\")\r\n```\r\nresults in the following error\r\n```\r\nRuntimeError: Conversion: time field value out of range: \"T15:21:19\", expected format is ([YYY-MM-DD ]HH:MM:SS[.MS])\r\n```\r\nIt seemed odd to me that only the second part of the data format was returned as an error. I did some digging and FromString(string str) in 'src/common/types/timestamp.cpp' seems to indicate that the 'T' should be accepted, at least based on the comments and my quick read of the code. \r\n```\r\n// string format is YYYY-MM-DDThh:mm:ssZ\r\n// T may be a space\r\n```\r\n\r\nAm I doing something incorrect in my insertion in the above example or is there some sort of quotes/escaping I can use to make this work? \r\n\r\n\r\n\r\n\r\n\r\n\n",
  "hints_text": "Thanks for the bug report! This seems to be an issue in the timestamp parsing, the comment seems to not indicate exactly what is actually going on in the code. The code parses the DATE and TIME separately. The space works because the TIME parsing skips any leading or trailing spaces, but the \"T\" is not accepted by the parser here. I will fix it next week.",
  "created_at": "2020-08-10T15:49:17Z"
}