diff --git a/benchmark/interpreted_benchmark.cpp b/benchmark/interpreted_benchmark.cpp
index 395e452f5045..f25b19df904d 100644
--- a/benchmark/interpreted_benchmark.cpp
+++ b/benchmark/interpreted_benchmark.cpp
@@ -120,7 +120,10 @@ unique_ptr<BenchmarkState> InterpretedBenchmark::Initialize() {
 	LoadBenchmark();
 
 	auto state = make_unique<InterpretedBenchmarkState>();
-	state->con.Query(init_query);
+	auto result = state->con.Query(init_query);
+	if (!result->success) {
+		throw Exception(result->error);
+	}
 	return state;
 }
 
diff --git a/benchmark/micro/cast/strftime.benchmark b/benchmark/micro/cast/strftime.benchmark
new file mode 100644
index 000000000000..5c003550d705
--- /dev/null
+++ b/benchmark/micro/cast/strftime.benchmark
@@ -0,0 +1,12 @@
+# name: benchmark/micro/cast/strftime.benchmark
+# description: Use strftime to convert dates to strings
+# group: [cast]
+
+load
+CREATE TABLE dates AS SELECT DATE '1992-01-01' + i::INTEGER AS d FROM range(0, 10000000) tbl(i);
+
+run
+SELECT MIN(strftime(d, '%Y/%m/%d')) FROM dates
+
+result I
+10000/01/01
\ No newline at end of file
diff --git a/benchmark/micro/cast/strptime.benchmark b/benchmark/micro/cast/strptime.benchmark
new file mode 100644
index 000000000000..62aa18f68ca9
--- /dev/null
+++ b/benchmark/micro/cast/strptime.benchmark
@@ -0,0 +1,12 @@
+# name: benchmark/micro/cast/strptime.benchmark
+# description: Use strptime to convert strings to dates
+# group: [cast]
+
+load
+CREATE TABLE dates AS SELECT strftime(DATE '1992-01-01' + i::INTEGER, '%Y/%m/%d') AS d FROM range(0, 10000000) tbl(i);
+
+run
+SELECT MIN(strptime(d, '%Y/%m/%d')) FROM dates
+
+result I
+1992-01-01
diff --git a/extension/parquet/parquet-extension.cpp b/extension/parquet/parquet-extension.cpp
index b90e72e3a696..011041bd8411 100644
--- a/extension/parquet/parquet-extension.cpp
+++ b/extension/parquet/parquet-extension.cpp
@@ -328,7 +328,7 @@ class ParquetScanFunction : public TableFunction {
 	}
 
 private:
-	static unique_ptr<FunctionData> parquet_scan_bind(ClientContext &context, vector<Value> inputs,
+	static unique_ptr<FunctionData> parquet_scan_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
 	                                                  vector<SQLType> &return_types, vector<string> &names) {
 
 		auto file_name = inputs[0].GetValue<string>();
@@ -1254,7 +1254,7 @@ unique_ptr<GlobalFunctionData> parquet_write_initialize_global(ClientContext &co
 
 	// initialize the file writer
 	global_state->writer = make_unique<BufferedFileWriter>(context.db.GetFileSystem(), parquet_bind.file_name.c_str(),
-	                                                       FileFlags::WRITE | FileFlags::FILE_CREATE_NEW);
+	                                                       FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE_NEW);
 	// parquet files start with the string "PAR1"
 	global_state->writer->WriteData((const_data_ptr_t) "PAR1", 4);
 	TCompactProtocolFactoryT<MyTransport> tproto_factory;
diff --git a/grammar/delete.js b/grammar/delete.js
deleted file mode 100644
index d428baae596f..000000000000
--- a/grammar/delete.js
+++ /dev/null
@@ -1,119 +0,0 @@
-
-function GenerateValues(options) {
-	return [
-		Keyword("VALUES"),
-		OneOrMore(
-			Sequence([
-				Keyword("("),
-				OneOrMore(Expression(), ","),
-				Keyword(")")
-			]), Keyword(","))
-	]
-}
-
-function GenerateDistinctClause(options) {
-	return [
-		Choice(0, [
-			new Skip(),
-			Sequence([
-				Keyword("DISTINCT"),
-				Optional(Sequence([
-					Keyword("("),
-					OneOrMore(Expression("distinct-term"), ","),
-					Keyword(")"),
-				]) , "skip")
-			]),
-			Keyword("ALL")
-		])
-	]
-}
-
-function GenerateSelectNode(options) {
-	return [Stack([
-		Sequence([
-			Keyword("SELECT"),
-			Expandable("distinct-clause", options, "distinct-clause", GenerateDistinctClause),
-			OneOrMore(Expression(), ",")
-		]),
-		Sequence([
-			Optional(Sequence([
-				Keyword("FROM"),
-				Choice(0, [
-					OneOrMore(Expression("table-or-subquery"), ","),
-					Sequence([Expression("join-clause")])
-				])
-			])),
-			Optional(
-				Sequence([
-					Keyword("WHERE"),
-					Expression()
-				])
-			)
-		]),
-		Sequence([
-			Optional(Sequence([
-				Keyword("GROUP"),
-				Keyword("BY"),
-				OneOrMore(Expression(), ","),
-			])),
-			Optional(Sequence([
-				Keyword("HAVING"),
-				Expression()
-			]))
-		]),
-		Optional(
-			Sequence([Sequence([
-					Keyword("WINDOW"),
-					Expression("window-name"),
-					Keyword("AS"),
-					Expression("window-definition")
-				])
-			]), "skip"),
-		Sequence([
-			Optional(Sequence([
-				Keyword("ORDER"),
-				Keyword("BY"),
-				OneOrMore(Expression("ordering-term"), ",")
-			]))
-		]),
-		Optional(Sequence([
-			Keyword("LIMIT"),
-			Expression(),
-			Optional(Sequence([
-				Keyword("OFFSET"),
-				Expression()
-			]), "skip")
-		]))
-	])]
-}
-
-function GenerateDelete(options = {}) {
-	return Diagram([
-		Stack([
-			Optional(
-				Sequence([
-					Keyword("WITH"),
-					Optional(Keyword("RECURSIVE"), "skip"),
-					OneOrMore(Expression("common-table-expr"), ",")
-				]), "skip"),
-			Choice(0, [
-				Expandable("select-node", options, "select-node", GenerateSelectNode),
-				Expandable("values-list", options, "values", GenerateValues)
-			])
-		])
-	])
-}
-
-function Initialize(options = {}) {
-	document.getElementById("rrdiagram").innerHTML = GenerateDelete(options).toString();
-}
-
-function Refresh(node_name, set_node) {
-	options[node_name] = set_node;
-	Initialize(options);
-}
-
-options = {}
-Initialize()
-
-
diff --git a/grammar/railroad.css b/grammar/railroad.css
deleted file mode 100644
index e1b8a524cbde..000000000000
--- a/grammar/railroad.css
+++ /dev/null
@@ -1,59 +0,0 @@
-svg {
-	background-color: hsl(30,20%,95%);
-}
-path {
-	stroke-width: 3;
-	stroke: black;
-	fill: rgba(0,0,0,0);
-}
-text {
-	font: bold 14px monospace;
-	text-anchor: middle;
-	white-space: pre;
-}
-text.diagram-text {
-	font-size: 12px;
-}
-text.diagram-arrow {
-	font-size: 16px;
-}
-text.label {
-	text-anchor: start;
-}
-text.comment {
-	font: italic 12px monospace;
-}
-g.non-terminal text {
-	/*font-style: italic;*/
-}
-rect {
-	stroke-width: 3;
-	stroke: black;
-	fill: hsl(120,100%,90%);
-}
-.expandable, .expanded {
-	cursor:pointer;
-	-webkit-user-select: none; /* Safari */
-	-moz-user-select: none; /* Firefox */
-	-ms-user-select: none; /* IE10+/Edge */
-	user-select: none; /* Standard */
-}
-rect.expandable, rect.expanded, rect.expression {
-	fill:#f6d573;
-}
-text.expandable, text.expanded, text.expression {
-	font:14px monospace;
-	font-style:italic;
-}
-.non-terminal:hover rect.expandable, .non-terminal:hover rect.expanded {
-	fill:#f8d9aa;
-}
-path.diagram-text {
-	stroke-width: 3;
-	stroke: black;
-	fill: white;
-	cursor: help;
-}
-g.diagram-text:hover path.diagram-text {
-	fill: #eee;
-}
diff --git a/grammar/railroad.js b/grammar/railroad.js
deleted file mode 100644
index c6049a034ba6..000000000000
--- a/grammar/railroad.js
+++ /dev/null
@@ -1,1460 +0,0 @@
-"use strict";
-/*
-Railroad DiagramNodes
-by Tab Atkins Jr. (and others)
-http://xanthir.com
-http://twitter.com/tabatkins
-http://github.com/tabatkins/railroad-diagrams
-
-This document and all associated files in the github project are licensed under CC0: http://creativecommons.org/publicdomain/zero/1.0/
-This means you can reuse, remix, or otherwise appropriate this project for your own use WITHOUT RESTRICTION.
-(The actual legal meaning can be found at the above link.)
-Don't ask me for permission to use any part of this project, JUST USE IT.
-I would appreciate attribution, but that is not required by the license.
-*/
-
-/*
-This file uses a module pattern to avoid leaking names into the global scope.
-Should be compatible with AMD, CommonJS, and plain ol' browser JS.
-
-As well, several configuration constants are passed into the module function at the bottom of this file.
-At runtime, these constants can be found on the DiagramNode class,
-and can be changed before creating a DiagramNode.
-*/
-
-(function(options) {
-	var funcs = {};
-
-	function subclassOf(baseClass, superClass) {
-		baseClass.prototype = Object.create(superClass.prototype);
-		baseClass.prototype.$super = superClass.prototype;
-	}
-
-	function unnull(/* children */) {
-		return [].slice.call(arguments).reduce(function(sofar, x) { return sofar !== undefined ? sofar : x; });
-	}
-
-	function determineGaps(outer, inner) {
-		var diff = outer - inner;
-		switch(DiagramNode.INTERNAL_ALIGNMENT) {
-			case 'left': return [0, diff]; break;
-			case 'right': return [diff, 0]; break;
-			case 'center':
-			default: return [diff/2, diff/2]; break;
-		}
-	}
-
-	function wrapString(value) {
-		return value instanceof FakeSVG ? value : new Terminal(""+value);
-	}
-
-	function sum(iter, func) {
-		if(!func) func = function(x) { return x; };
-		return iter.map(func).reduce(function(a,b){return a+b}, 0);
-	}
-
-	function max(iter, func) {
-		if(!func) func = function(x) { return x; };
-		return Math.max.apply(null, iter.map(func));
-	}
-
-	function* enumerate(iter) {
-		var count = 0;
-		for(const x of iter) {
-			yield [count, x];
-			count++;
-		}
-	}
-
-	var SVG = funcs.SVG = function SVG(name, attrs, text) {
-		attrs = attrs || {};
-		text = text || '';
-		var el = document.createElementNS("http://www.w3.org/2000/svg",name);
-		for(var attr in attrs) {
-			if(attr === 'xlink:href')
-				el.setAttributeNS("http://www.w3.org/1999/xlink", 'href', attrs[attr]);
-			else
-				el.setAttribute(attr, attrs[attr]);
-		}
-		el.textContent = text;
-		return el;
-	}
-
-	var FakeSVG = funcs.FakeSVG = function FakeSVG(tagName, attrs, text){
-		if(!(this instanceof FakeSVG)) return new FakeSVG(tagName, attrs, text);
-		if(text) this.children = text;
-		else this.children = [];
-		this.tagName = tagName;
-		this.attrs = unnull(attrs, {});
-		return this;
-	};
-	FakeSVG.prototype.format = function(x, y, width) {
-		// Virtual
-	};
-	FakeSVG.prototype.addTo = function(parent) {
-		if(parent instanceof FakeSVG) {
-			parent.children.push(this);
-			return this;
-		} else {
-			var svg = this.toSVG();
-			parent.appendChild(svg);
-			return svg;
-		}
-	};
-	FakeSVG.prototype.escapeString = function(string) {
-		// Escape markdown and HTML special characters
-		return string.replace(/[*_\`\[\]<&]/g, function(charString) {
-			return '&#' + charString.charCodeAt(0) + ';';
-		});
-	};
-	FakeSVG.prototype.toSVG = function() {
-		var el = SVG(this.tagName, this.attrs);
-		if(typeof this.children == 'string') {
-			el.textContent = this.children;
-		} else {
-			this.children.forEach(function(e) {
-				el.appendChild(e.toSVG());
-			});
-		}
-		return el;
-	};
-	FakeSVG.prototype.toString = function() {
-		var str = '<' + this.tagName;
-		var group = this.tagName == "g" || this.tagName == "svg";
-		for(var attr in this.attrs) {
-			str += ' ' + attr + '="' + (this.attrs[attr]+'').replace(/&/g, '&amp;').replace(/"/g, '&quot;') + '"';
-		}
-		str += '>';
-		if(group) str += "
";
-		if(typeof this.children == 'string') {
-			str += FakeSVG.prototype.escapeString(this.children);
-		} else {
-			this.children.forEach(function(e) {
-				str += e;
-			});
-		}
-		str += '</' + this.tagName + '>
';
-		return str;
-	}
-	FakeSVG.prototype.walk = function(cb) {
-		cb(this);
-	}
-
-	var Path = funcs.Path = function Path(x,y) {
-		if(!(this instanceof Path)) return new Path(x,y);
-		FakeSVG.call(this, 'path');
-		this.attrs.d = "M"+x+' '+y;
-	}
-	subclassOf(Path, FakeSVG);
-	Path.prototype.m = function(x,y) {
-		this.attrs.d += 'm'+x+' '+y;
-		return this;
-	}
-	Path.prototype.h = function(val) {
-		this.attrs.d += 'h'+val;
-		return this;
-	}
-	Path.prototype.right = function(val) { return this.h(Math.max(0, val)); }
-	Path.prototype.left = function(val) { return this.h(-Math.max(0, val)); }
-	Path.prototype.v = function(val) {
-		this.attrs.d += 'v'+val;
-		return this;
-	}
-	Path.prototype.down = function(val) { return this.v(Math.max(0, val)); }
-	Path.prototype.up = function(val) { return this.v(-Math.max(0, val)); }
-	Path.prototype.arc = function(sweep){
-		// 1/4 of a circle
-		var x = DiagramNode.ARC_RADIUS;
-		var y = DiagramNode.ARC_RADIUS;
-		if(sweep[0] == 'e' || sweep[1] == 'w') {
-			x *= -1;
-		}
-		if(sweep[0] == 's' || sweep[1] == 'n') {
-			y *= -1;
-		}
-		if(sweep == 'ne' || sweep == 'es' || sweep == 'sw' || sweep == 'wn') {
-			var cw = 1;
-		} else {
-			var cw = 0;
-		}
-		this.attrs.d += "a"+DiagramNode.ARC_RADIUS+" "+DiagramNode.ARC_RADIUS+" 0 0 "+cw+' '+x+' '+y;
-		return this;
-	}
-	Path.prototype.arc_8 = function(start, dir) {
-		// 1/8 of a circle
-		const arc = DiagramNode.ARC_RADIUS;
-		const s2 = 1/Math.sqrt(2) * arc;
-		const s2inv = (arc - s2);
-		let path = "a " + arc + " " + arc + " 0 0 " + (dir=='cw' ? "1" : "0") + " ";
-		const sd = start+dir;
-		const offset =
-			sd == 'ncw'   ? [s2, s2inv] :
-			sd == 'necw'  ? [s2inv, s2] :
-			sd == 'ecw'   ? [-s2inv, s2] :
-			sd == 'secw'  ? [-s2, s2inv] :
-			sd == 'scw'   ? [-s2, -s2inv] :
-			sd == 'swcw'  ? [-s2inv, -s2] :
-			sd == 'wcw'   ? [s2inv, -s2] :
-			sd == 'nwcw'  ? [s2, -s2inv] :
-			sd == 'nccw'  ? [-s2, s2inv] :
-			sd == 'nwccw' ? [-s2inv, s2] :
-			sd == 'wccw'  ? [s2inv, s2] :
-			sd == 'swccw' ? [s2, s2inv] :
-			sd == 'sccw'  ? [s2, -s2inv] :
-			sd == 'seccw' ? [s2inv, -s2] :
-			sd == 'eccw'  ? [-s2inv, -s2] :
-			sd == 'neccw' ? [-s2, -s2inv] : null
-		;
-		path += offset.join(" ");
-		this.attrs.d += path;
-		return this;
-	}
-	Path.prototype.l = function(x, y) {
-		this.attrs.d += 'l'+x+' '+y;
-		return this;
-	}
-	Path.prototype.format = function() {
-		// All paths in this library start/end horizontally.
-		// The extra .5 ensures a minor overlap, so there's no seams in bad rasterizers.
-		this.attrs.d += 'h.5';
-		return this;
-	}
-
-
-	var DiagramNodeMultiContainer = funcs.DiagramNodeMultiContainer = function DiagramNodeMultiContainer(tagName, items, attrs, text) {
-		FakeSVG.call(this, tagName, attrs, text);
-		this.items = items.map(wrapString);
-	}
-	subclassOf(DiagramNodeMultiContainer, FakeSVG);
-	DiagramNodeMultiContainer.prototype.walk = function(cb) {
-		cb(this);
-		this.items.forEach(x=>w.walk(cb));
-	}
-
-
-	var DiagramNode = funcs.DiagramNode = function DiagramNode(items) {
-		if(!(this instanceof DiagramNode)) return new DiagramNode([].slice.call(arguments));
-		DiagramNodeMultiContainer.call(this, 'svg', items, {class: DiagramNode.DIAGRAM_CLASS});
-		if(!(this.items[0] instanceof Start)) {
-			this.items.unshift(new Start());
-		}
-		if(!(this.items[this.items.length-1] instanceof End)) {
-			this.items.push(new End());
-		}
-		this.up = this.down = this.height = this.width = 0;
-		for(var i = 0; i < this.items.length; i++) {
-			var item = this.items[i];
-			this.width += item.width + (item.needsSpace?20:0);
-			this.up = Math.max(this.up, item.up - this.height);
-			this.height += item.height;
-			this.down = Math.max(this.down - item.height, item.down);
-		}
-		this.formatted = false;
-	}
-	subclassOf(DiagramNode, DiagramNodeMultiContainer);
-	for(var option in options) {
-		DiagramNode[option] = options[option];
-	}
-	DiagramNode.prototype.format = function(paddingt, paddingr, paddingb, paddingl) {
-		paddingt = unnull(paddingt, 20);
-		paddingr = unnull(paddingr, paddingt, 20);
-		paddingb = unnull(paddingb, paddingt, 20);
-		paddingl = unnull(paddingl, paddingr, 20);
-		var x = paddingl;
-		var y = paddingt;
-		y += this.up;
-		var g = FakeSVG('g', DiagramNode.STROKE_ODD_PIXEL_LENGTH ? {transform:'translate(.5 .5)'} : {});
-		for(var i = 0; i < this.items.length; i++) {
-			var item = this.items[i];
-			if(item.needsSpace) {
-				Path(x,y).h(10).addTo(g);
-				x += 10;
-			}
-			item.format(x, y, item.width).addTo(g);
-			x += item.width;
-			y += item.height;
-			if(item.needsSpace) {
-				Path(x,y).h(10).addTo(g);
-				x += 10;
-			}
-		}
-		this.attrs.width = this.width + paddingl + paddingr;
-		this.attrs.height = this.up + this.height + this.down + paddingt + paddingb;
-		this.attrs.viewBox = "0 0 " + this.attrs.width + " " + this.attrs.height;
-		g.addTo(this);
-		this.formatted = true;
-		return this;
-	}
-	DiagramNode.prototype.addTo = function(parent) {
-		if(!parent) {
-			var scriptTag = document.getElementsByTagName('script');
-			scriptTag = scriptTag[scriptTag.length - 1];
-			parent = scriptTag.parentNode;
-		}
-		return this.$super.addTo.call(this, parent);
-	}
-	DiagramNode.prototype.toSVG = function() {
-		if (!this.formatted) {
-			this.format();
-		}
-		return this.$super.toSVG.call(this);
-	}
-	DiagramNode.prototype.toString = function() {
-		if (!this.formatted) {
-			this.format();
-		}
-		return this.$super.toString.call(this);
-	}
-	DiagramNode.DEBUG = false;
-
-	var ComplexDiagramNode = funcs.ComplexDiagramNode = function ComplexDiagramNode() {
-		var diagram = new DiagramNode([].slice.call(arguments));
-		var items = diagram.items;
-		items.shift();
-		items.pop();
-		items.unshift(new Start({type:"complex"}));
-		items.push(new End({type:"complex"}));
-		diagram.items = items;
-		return diagram;
-	}
-
-	var SequenceNode = funcs.SequenceNode = function SequenceNode(items) {
-		if(!(this instanceof SequenceNode)) return new SequenceNode([].slice.call(arguments));
-		DiagramNodeMultiContainer.call(this, 'g', items);
-		var numberOfItems = this.items.length;
-		this.needsSpace = true;
-		this.up = this.down = this.height = this.width = 0;
-		for(var i = 0; i < this.items.length; i++) {
-			var item = this.items[i];
-			this.width += item.width + (item.needsSpace?20:0);
-			this.up = Math.max(this.up, item.up - this.height);
-			this.height += item.height;
-			this.down = Math.max(this.down - item.height, item.down);
-		}
-		if(this.items[0].needsSpace) this.width -= 10;
-		if(this.items[this.items.length-1].needsSpace) this.width -= 10;
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "sequence"
-		}
-	}
-	subclassOf(SequenceNode, DiagramNodeMultiContainer);
-	SequenceNode.prototype.format = function(x,y,width) {
-		// Hook up the two sides if this is narrower than its stated width.
-		var gaps = determineGaps(width, this.width);
-		Path(x,y).h(gaps[0]).addTo(this);
-		Path(x+gaps[0]+this.width,y+this.height).h(gaps[1]).addTo(this);
-		x += gaps[0];
-
-		for(var i = 0; i < this.items.length; i++) {
-			var item = this.items[i];
-			if(item.needsSpace && i > 0) {
-				Path(x,y).h(10).addTo(this);
-				x += 10;
-			}
-			item.format(x, y, item.width).addTo(this);
-			x += item.width;
-			y += item.height;
-			if(item.needsSpace && i < this.items.length-1) {
-				Path(x,y).h(10).addTo(this);
-				x += 10;
-			}
-		}
-		return this;
-	}
-
-	var StackNode = funcs.StackNode = function StackNode(items) {
-		if(!(this instanceof StackNode)) return new StackNode([].slice.call(arguments));
-		DiagramNodeMultiContainer.call(this, 'g', items);
-		if( items.length === 0 ) {
-			throw new RangeError("StackNode() must have at least one child.");
-		}
-		this.width = Math.max.apply(null, this.items.map(function(e) { return e.width + (e.needsSpace?20:0); }));
-		//if(this.items[0].needsSpace) this.width -= 10;
-		//if(this.items[this.items.length-1].needsSpace) this.width -= 10;
-		if(this.items.length > 1){
-			this.width += DiagramNode.ARC_RADIUS*2;
-		}
-		this.needsSpace = true;
-		this.up = this.items[0].up;
-		this.down = this.items[this.items.length-1].down;
-
-		this.height = 0;
-		var last = this.items.length - 1;
-		for(var i = 0; i < this.items.length; i++) {
-			var item = this.items[i];
-			this.height += item.height;
-			if(i > 0) {
-				this.height += Math.max(DiagramNode.ARC_RADIUS*2, item.up + DiagramNode.VERTICAL_SEPARATION);
-			}
-			if(i < last) {
-				this.height += Math.max(DiagramNode.ARC_RADIUS*2, item.down + DiagramNode.VERTICAL_SEPARATION);
-			}
-		}
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "stack"
-		}
-	}
-	subclassOf(StackNode, DiagramNodeMultiContainer);
-	StackNode.prototype.format = function(x,y,width) {
-		var gaps = determineGaps(width, this.width);
-		Path(x,y).h(gaps[0]).addTo(this);
-		x += gaps[0];
-		var xInitial = x;
-		if(this.items.length > 1) {
-			Path(x, y).h(DiagramNode.ARC_RADIUS).addTo(this);
-			x += DiagramNode.ARC_RADIUS;
-		}
-
-		for(var i = 0; i < this.items.length; i++) {
-			var item = this.items[i];
-			var innerWidth = this.width - (this.items.length>1 ? DiagramNode.ARC_RADIUS*2 : 0);
-			item.format(x, y, innerWidth).addTo(this);
-			x += innerWidth;
-			y += item.height;
-
-			if(i !== this.items.length-1) {
-				Path(x, y)
-					.arc('ne').down(Math.max(0, item.down + DiagramNode.VERTICAL_SEPARATION - DiagramNode.ARC_RADIUS*2))
-					.arc('es').left(innerWidth)
-					.arc('nw').down(Math.max(0, this.items[i+1].up + DiagramNode.VERTICAL_SEPARATION - DiagramNode.ARC_RADIUS*2))
-					.arc('ws').addTo(this);
-				y += Math.max(item.down + DiagramNode.VERTICAL_SEPARATION, DiagramNode.ARC_RADIUS*2) + Math.max(this.items[i+1].up + DiagramNode.VERTICAL_SEPARATION, DiagramNode.ARC_RADIUS*2);
-				//y += Math.max(DiagramNode.ARC_RADIUS*4, item.down + DiagramNode.VERTICAL_SEPARATION*2 + this.items[i+1].up)
-				x = xInitial+DiagramNode.ARC_RADIUS;
-			}
-
-		}
-
-		if(this.items.length > 1) {
-			Path(x,y).h(DiagramNode.ARC_RADIUS).addTo(this);
-			x += DiagramNode.ARC_RADIUS;
-		}
-		Path(x,y).h(gaps[1]).addTo(this);
-
-		return this;
-	}
-
-	var OptionalSequenceNode = funcs.OptionalSequenceNode = function OptionalSequenceNode(items) {
-		if(!(this instanceof OptionalSequenceNode)) return new OptionalSequenceNode([].slice.call(arguments));
-		DiagramNodeMultiContainer.call(this, 'g', items);
-		if( items.length === 0 ) {
-			throw new RangeError("OptionalSequenceNode() must have at least one child.");
-		}
-		if( items.length === 1 ) {
-			return new SequenceNode(items);
-		}
-		var arc = DiagramNode.ARC_RADIUS;
-		this.needsSpace = false;
-		this.width = 0;
-		this.up = 0;
-		this.height = sum(this.items, function(x){return x.height});
-		this.down = this.items[0].down;
-		var heightSoFar = 0;
-		for(var i = 0; i < this.items.length; i++) {
-			var item = this.items[i];
-			this.up = Math.max(this.up, Math.max(arc*2, item.up + DiagramNode.VERTICAL_SEPARATION) - heightSoFar);
-			heightSoFar += item.height;
-			if(i > 0) {
-				this.down = Math.max(this.height + this.down, heightSoFar + Math.max(arc*2, item.down + DiagramNode.VERTICAL_SEPARATION)) - this.height;
-			}
-			var itemWidth = (item.needsSpace?10:0) + item.width;
-			if(i == 0) {
-				this.width += arc + Math.max(itemWidth, arc);
-			} else {
-				this.width += arc*2 + Math.max(itemWidth, arc) + arc;
-			}
-		}
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "optseq"
-		}
-	}
-	subclassOf(OptionalSequenceNode, DiagramNodeMultiContainer);
-	OptionalSequenceNode.prototype.format = function(x, y, width) {
-		var arc = DiagramNode.ARC_RADIUS;
-		var gaps = determineGaps(width, this.width);
-		Path(x, y).right(gaps[0]).addTo(this);
-		Path(x + gaps[0] + this.width, y + this.height).right(gaps[1]).addTo(this);
-		x += gaps[0]
-		var upperLineY = y - this.up;
-		var last = this.items.length - 1;
-		for(var i = 0; i < this.items.length; i++) {
-			var item = this.items[i];
-			var itemSpace = (item.needsSpace?10:0);
-			var itemWidth = item.width + itemSpace;
-			if(i == 0) {
-				// Upper skip
-				Path(x,y)
-					.arc('se')
-					.up(y - upperLineY - arc*2)
-					.arc('wn')
-					.right(itemWidth - arc)
-					.arc('ne')
-					.down(y + item.height - upperLineY - arc*2)
-					.arc('ws')
-					.addTo(this);
-				// Straight line
-				Path(x, y)
-					.right(itemSpace + arc)
-					.addTo(this);
-				item.format(x + itemSpace + arc, y, item.width).addTo(this);
-				x += itemWidth + arc;
-				y += item.height;
-				// x ends on the far side of the first element,
-				// where the next element's skip needs to begin
-			} else if(i < last) {
-				// Upper skip
-				Path(x, upperLineY)
-					.right(arc*2 + Math.max(itemWidth, arc) + arc)
-					.arc('ne')
-					.down(y - upperLineY + item.height - arc*2)
-					.arc('ws')
-					.addTo(this);
-				// Straight line
-				Path(x,y)
-					.right(arc*2)
-					.addTo(this);
-				item.format(x + arc*2, y, item.width).addTo(this);
-				Path(x + item.width + arc*2, y + item.height)
-					.right(itemSpace + arc)
-					.addTo(this);
-				// Lower skip
-				Path(x,y)
-					.arc('ne')
-					.down(item.height + Math.max(item.down + DiagramNode.VERTICAL_SEPARATION, arc*2) - arc*2)
-					.arc('ws')
-					.right(itemWidth - arc)
-					.arc('se')
-					.up(item.down + DiagramNode.VERTICAL_SEPARATION - arc*2)
-					.arc('wn')
-					.addTo(this);
-				x += arc*2 + Math.max(itemWidth, arc) + arc;
-				y += item.height;
-			} else {
-				// Straight line
-				Path(x, y)
-					.right(arc*2)
-					.addTo(this);
-				item.format(x + arc*2, y, item.width).addTo(this);
-				Path(x + arc*2 + item.width, y + item.height)
-					.right(itemSpace + arc)
-					.addTo(this);
-				// Lower skip
-				Path(x,y)
-					.arc('ne')
-					.down(item.height + Math.max(item.down + DiagramNode.VERTICAL_SEPARATION, arc*2) - arc*2)
-					.arc('ws')
-					.right(itemWidth - arc)
-					.arc('se')
-					.up(item.down + DiagramNode.VERTICAL_SEPARATION - arc*2)
-					.arc('wn')
-					.addTo(this);
-			}
-		}
-		return this;
-	}
-
-	var AlternatingSequenceNode = funcs.AlternatingSequenceNode = function AlternatingSequenceNode(items) {
-		if(!(this instanceof AlternatingSequenceNode)) return new AlternatingSequenceNode([].slice.call(arguments));
-		DiagramNodeMultiContainer.call(this, 'g', items);
-		if( items.length === 1 ) {
-			return new SequenceNode(items);
-		}
-		if( items.length !== 2 ) {
-			throw new RangeError("AlternatingSequenceNode() must have one or two children.");
-		}
-		this.needsSpace = false;
-
-		const arc = DiagramNode.ARC_RADIUS;
-		const vert = DiagramNode.VERTICAL_SEPARATION;
-		const max = Math.max;
-		const first = this.items[0];
-		const second = this.items[1];
-
-		const arcX = 1 / Math.sqrt(2) * arc * 2;
-		const arcY = (1 - 1 / Math.sqrt(2)) * arc * 2;
-		const crossY = Math.max(arc, DiagramNode.VERTICAL_SEPARATION);
-		const crossX = (crossY - arcY) + arcX;
-
-		const firstOut = max(arc + arc, crossY/2 + arc + arc, crossY/2 + vert + first.down);
-		this.up = firstOut + first.height + first.up;
-
-		const secondIn = max(arc + arc, crossY/2 + arc + arc, crossY/2 + vert + second.up);
-		this.down = secondIn + second.height + second.down;
-
-		this.height = 0;
-
-		const firstWidth = 2*(first.needsSpace?10:0) + first.width;
-		const secondWidth = 2*(second.needsSpace?10:0) + second.width;
-		this.width = 2*arc + max(firstWidth, crossX, secondWidth) + 2*arc;
-
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "altseq"
-		}
-	}
-	subclassOf(AlternatingSequenceNode, DiagramNodeMultiContainer);
-	AlternatingSequenceNode.prototype.format = function(x, y, width) {
-		const arc = DiagramNode.ARC_RADIUS;
-		const gaps = determineGaps(width, this.width);
-		Path(x,y).right(gaps[0]).addTo(this);
-		console.log(gaps);
-		x += gaps[0];
-		Path(x+this.width, y).right(gaps[1]).addTo(this);
-		// bounding box
-		//Path(x+gaps[0], y).up(this.up).right(this.width).down(this.up+this.down).left(this.width).up(this.down).addTo(this);
-		const first = this.items[0];
-		const second = this.items[1];
-
-		// top
-		const firstIn = this.up - first.up;
-		const firstOut = this.up - first.up - first.height;
-		Path(x,y).arc('se').up(firstIn-2*arc).arc('wn').addTo(this);
-		first.format(x + 2*arc, y - firstIn, this.width - 4*arc).addTo(this);
-		Path(x + this.width - 2*arc, y - firstOut).arc('ne').down(firstOut - 2*arc).arc('ws').addTo(this);
-
-		// bottom
-		const secondIn = this.down - second.down - second.height;
-		const secondOut = this.down - second.down;
-		Path(x,y).arc('ne').down(secondIn - 2*arc).arc('ws').addTo(this);
-		second.format(x + 2*arc, y + secondIn, this.width - 4*arc).addTo(this);
-		Path(x + this.width - 2*arc, y + secondOut).arc('se').up(secondOut - 2*arc).arc('wn').addTo(this);
-
-		// crossover
-		const arcX = 1 / Math.sqrt(2) * arc * 2;
-		const arcY = (1 - 1 / Math.sqrt(2)) * arc * 2;
-		const crossY = Math.max(arc, DiagramNode.VERTICAL_SEPARATION);
-		const crossX = (crossY - arcY) + arcX;
-		const crossBar = (this.width - 4*arc - crossX)/2;
-		Path(x+arc, y - crossY/2 - arc).arc('ws').right(crossBar)
-			.arc_8('n', 'cw').l(crossX - arcX, crossY - arcY).arc_8('sw', 'ccw')
-			.right(crossBar).arc('ne').addTo(this);
-		Path(x+arc, y + crossY/2 + arc).arc('wn').right(crossBar)
-			.arc_8('s', 'ccw').l(crossX - arcX, -(crossY - arcY)).arc_8('nw', 'cw')
-			.right(crossBar).arc('se').addTo(this);
-
-		return this;
-	}
-
-	var ChoiceNode = funcs.ChoiceNode = function ChoiceNode(normal, items) {
-		if(!(this instanceof ChoiceNode)) return new ChoiceNode(normal, [].slice.call(arguments,1));
-		DiagramNodeMultiContainer.call(this, 'g', items);
-		if( typeof normal !== "number" || normal !== Math.floor(normal) ) {
-			throw new TypeError("The first argument of ChoiceNode() must be an integer.");
-		} else if(normal < 0 || normal >= items.length) {
-			throw new RangeError("The first argument of ChoiceNode() must be an index for one of the items.");
-		} else {
-			this.normal = normal;
-		}
-		var first = 0;
-		var last = items.length - 1;
-		this.width = Math.max.apply(null, this.items.map(function(el){return el.width})) + DiagramNode.ARC_RADIUS*4;
-		this.height = this.items[normal].height;
-		this.up = this.items[first].up;
-		for(var i = first; i < normal; i++) {
-			if(i == normal-1) var arcs = DiagramNode.ARC_RADIUS*2;
-			else var arcs = DiagramNode.ARC_RADIUS;
-			this.up += Math.max(arcs, this.items[i].height + this.items[i].down + DiagramNode.VERTICAL_SEPARATION + this.items[i+1].up);
-		}
-		this.down = this.items[last].down;
-		for(var i = normal+1; i <= last; i++) {
-			if(i == normal+1) var arcs = DiagramNode.ARC_RADIUS*2;
-			else var arcs = DiagramNode.ARC_RADIUS;
-			this.down += Math.max(arcs, this.items[i-1].height + this.items[i-1].down + DiagramNode.VERTICAL_SEPARATION + this.items[i].up);
-		}
-		this.down -= this.items[normal].height; // already counted in ChoiceNode.height
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "choice"
-		}
-	}
-	subclassOf(ChoiceNode, DiagramNodeMultiContainer);
-	ChoiceNode.prototype.format = function(x,y,width) {
-		// Hook up the two sides if this is narrower than its stated width.
-		var gaps = determineGaps(width, this.width);
-		Path(x,y).h(gaps[0]).addTo(this);
-		Path(x+gaps[0]+this.width,y+this.height).h(gaps[1]).addTo(this);
-		x += gaps[0];
-
-		var last = this.items.length -1;
-		var innerWidth = this.width - DiagramNode.ARC_RADIUS*4;
-
-		// Do the elements that curve above
-		for(var i = this.normal - 1; i >= 0; i--) {
-			var item = this.items[i];
-			if( i == this.normal - 1 ) {
-				var distanceFromY = Math.max(DiagramNode.ARC_RADIUS*2, this.items[this.normal].up + DiagramNode.VERTICAL_SEPARATION + item.down + item.height);
-			}
-			Path(x,y)
-				.arc('se')
-				.up(distanceFromY - DiagramNode.ARC_RADIUS*2)
-				.arc('wn').addTo(this);
-			item.format(x+DiagramNode.ARC_RADIUS*2,y - distanceFromY,innerWidth).addTo(this);
-			Path(x+DiagramNode.ARC_RADIUS*2+innerWidth, y-distanceFromY+item.height)
-				.arc('ne')
-				.down(distanceFromY - item.height + this.height - DiagramNode.ARC_RADIUS*2)
-				.arc('ws').addTo(this);
-			distanceFromY += Math.max(DiagramNode.ARC_RADIUS, item.up + DiagramNode.VERTICAL_SEPARATION + (i == 0 ? 0 : this.items[i-1].down+this.items[i-1].height));
-		}
-
-		// Do the straight-line path.
-		Path(x,y).right(DiagramNode.ARC_RADIUS*2).addTo(this);
-		this.items[this.normal].format(x+DiagramNode.ARC_RADIUS*2, y, innerWidth).addTo(this);
-		Path(x+DiagramNode.ARC_RADIUS*2+innerWidth, y+this.height).right(DiagramNode.ARC_RADIUS*2).addTo(this);
-
-		// Do the elements that curve below
-		for(var i = this.normal+1; i <= last; i++) {
-			var item = this.items[i];
-			if( i == this.normal + 1 ) {
-				var distanceFromY = Math.max(DiagramNode.ARC_RADIUS*2, this.height + this.items[this.normal].down + DiagramNode.VERTICAL_SEPARATION + item.up);
-			}
-			Path(x,y)
-				.arc('ne')
-				.down(distanceFromY - DiagramNode.ARC_RADIUS*2)
-				.arc('ws').addTo(this);
-			item.format(x+DiagramNode.ARC_RADIUS*2, y+distanceFromY, innerWidth).addTo(this);
-			Path(x+DiagramNode.ARC_RADIUS*2+innerWidth, y+distanceFromY+item.height)
-				.arc('se')
-				.up(distanceFromY - DiagramNode.ARC_RADIUS*2 + item.height - this.height)
-				.arc('wn').addTo(this);
-			distanceFromY += Math.max(DiagramNode.ARC_RADIUS, item.height + item.down + DiagramNode.VERTICAL_SEPARATION + (i == last ? 0 : this.items[i+1].up));
-		}
-
-		return this;
-	}
-
-
-	var HorizontalChoiceNode = funcs.HorizontalChoiceNode = function HorizontalChoiceNode(items) {
-		if(!(this instanceof HorizontalChoiceNode)) return new HorizontalChoiceNode([].slice.call(arguments));
-		if( items.length === 0 ) {
-			throw new RangeError("HorizontalChoiceNode() must have at least one child.");
-		}
-		if( items.length === 1) {
-			return new SequenceNode(items);
-		}
-		DiagramNodeMultiContainer.call(this, 'g', items);
-
-		const allButLast = this.items.slice(0, -1);
-		const middles = this.items.slice(1, -1);
-		const first = this.items[0];
-		const last = this.items[this.items.length - 1];
-		this.needsSpace = false;
-
-		this.width = DiagramNode.ARC_RADIUS; // starting track
-		this.width += DiagramNode.ARC_RADIUS*2 * (this.items.length-1); // inbetween tracks
-		this.width += sum(this.items, x=>x.width + (x.needsSpace?20:0)); // items
-		this.width += (last.height > 0 ? DiagramNode.ARC_RADIUS : 0); // needs space to curve up
-		this.width += DiagramNode.ARC_RADIUS; //ending track
-
-		// Always exits at entrance height
-		this.height = 0;
-
-		// All but the last have a track running above them
-		this._upperTrack = Math.max(
-			DiagramNode.ARC_RADIUS*2,
-			DiagramNode.VERTICAL_SEPARATION,
-			max(allButLast, x=>x.up) + DiagramNode.VERTICAL_SEPARATION
-		);
-		this.up = Math.max(this._upperTrack, last.up);
-
-		// All but the first have a track running below them
-		// Last either straight-lines or curves up, so has different calculation
-		this._lowerTrack = Math.max(
-			DiagramNode.VERTICAL_SEPARATION,
-			max(middles, x=>x.height+Math.max(x.down+DiagramNode.VERTICAL_SEPARATION, DiagramNode.ARC_RADIUS*2)),
-			last.height + last.down + DiagramNode.VERTICAL_SEPARATION
-		);
-		if(first.height < this._lowerTrack) {
-			// Make sure there's at least 2*AR room between first exit and lower track
-			this._lowerTrack = Math.max(this._lowerTrack, first.height + DiagramNode.ARC_RADIUS*2);
-		}
-		this.down = Math.max(this._lowerTrack, first.height + first.down);
-
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "horizontalchoice"
-		}
-	}
-	subclassOf(HorizontalChoiceNode, DiagramNodeMultiContainer);
-	HorizontalChoiceNode.prototype.format = function(x,y,width) {
-		// Hook up the two sides if this is narrower than its stated width.
-		var gaps = determineGaps(width, this.width);
-		new Path(x,y).h(gaps[0]).addTo(this);
-		new Path(x+gaps[0]+this.width,y+this.height).h(gaps[1]).addTo(this);
-		x += gaps[0];
-
-		const first = this.items[0];
-		const last = this.items[this.items.length-1];
-		const allButFirst = this.items.slice(1);
-		const allButLast = this.items.slice(0, -1);
-
-		// upper track
-		var upperSpan = (sum(allButLast, x=>x.width+(x.needsSpace?20:0))
-			+ (this.items.length - 2) * DiagramNode.ARC_RADIUS*2
-			- DiagramNode.ARC_RADIUS
-		);
-		new Path(x,y)
-			.arc('se')
-			.v(-(this._upperTrack - DiagramNode.ARC_RADIUS*2))
-			.arc('wn')
-			.h(upperSpan)
-			.addTo(this);
-
-		// lower track
-		var lowerSpan = (sum(allButFirst, x=>x.width+(x.needsSpace?20:0))
-			+ (this.items.length - 2) * DiagramNode.ARC_RADIUS*2
-			+ (last.height > 0 ? DiagramNode.ARC_RADIUS : 0)
-			- DiagramNode.ARC_RADIUS
-		);
-		var lowerStart = x + DiagramNode.ARC_RADIUS + first.width+(first.needsSpace?20:0) + DiagramNode.ARC_RADIUS*2;
-		new Path(lowerStart, y+this._lowerTrack)
-			.h(lowerSpan)
-			.arc('se')
-			.v(-(this._lowerTrack - DiagramNode.ARC_RADIUS*2))
-			.arc('wn')
-			.addTo(this);
-
-		// Items
-		for(const [i, item] of enumerate(this.items)) {
-			// input track
-			if(i === 0) {
-				new Path(x,y)
-					.h(DiagramNode.ARC_RADIUS)
-					.addTo(this);
-				x += DiagramNode.ARC_RADIUS;
-			} else {
-				new Path(x, y - this._upperTrack)
-					.arc('ne')
-					.v(this._upperTrack - DiagramNode.ARC_RADIUS*2)
-					.arc('ws')
-					.addTo(this);
-				x += DiagramNode.ARC_RADIUS*2;
-			}
-
-			// item
-			var itemWidth = item.width + (item.needsSpace?20:0);
-			item.format(x, y, itemWidth).addTo(this);
-			x += itemWidth;
-
-			// output track
-			if(i === this.items.length-1) {
-				if(item.height === 0) {
-					new Path(x,y)
-						.h(DiagramNode.ARC_RADIUS)
-						.addTo(this);
-				} else {
-					new Path(x,y+item.height)
-					.arc('se')
-					.addTo(this);
-				}
-			} else if(i === 0 && item.height > this._lowerTrack) {
-				// Needs to arc up to meet the lower track, not down.
-				if(item.height - this._lowerTrack >= DiagramNode.ARC_RADIUS*2) {
-					new Path(x, y+item.height)
-						.arc('se')
-						.v(this._lowerTrack - item.height + DiagramNode.ARC_RADIUS*2)
-						.arc('wn')
-						.addTo(this);
-				} else {
-					// Not enough space to fit two arcs
-					// so just bail and draw a straight line for now.
-					new Path(x, y+item.height)
-						.l(DiagramNode.ARC_RADIUS*2, this._lowerTrack - item.height)
-						.addTo(this);
-				}
-			} else {
-				new Path(x, y+item.height)
-					.arc('ne')
-					.v(this._lowerTrack - item.height - DiagramNode.ARC_RADIUS*2)
-					.arc('ws')
-					.addTo(this);
-			}
-		}
-		return this;
-	}
-
-
-	var MultipleChoiceNode = funcs.MultipleChoiceNode = function MultipleChoiceNode(normal, type, items) {
-		if(!(this instanceof MultipleChoiceNode)) return new MultipleChoiceNode(normal, type, [].slice.call(arguments,2));
-		DiagramNodeMultiContainer.call(this, 'g', items);
-		if( typeof normal !== "number" || normal !== Math.floor(normal) ) {
-			throw new TypeError("The first argument of MultipleChoiceNode() must be an integer.");
-		} else if(normal < 0 || normal >= items.length) {
-			throw new RangeError("The first argument of MultipleChoiceNode() must be an index for one of the items.");
-		} else {
-			this.normal = normal;
-		}
-		if( type != "any" && type != "all" ) {
-			throw new SyntaxError("The second argument of MultipleChoiceNode must be 'any' or 'all'.");
-		} else {
-			this.type = type;
-		}
-		this.needsSpace = true;
-		this.innerWidth = max(this.items, function(x){return x.width});
-		this.width = 30 + DiagramNode.ARC_RADIUS + this.innerWidth + DiagramNode.ARC_RADIUS + 20;
-		this.up = this.items[0].up;
-		this.down = this.items[this.items.length-1].down;
-		this.height = this.items[normal].height;
-		for(var i = 0; i < this.items.length; i++) {
-			var item = this.items[i];
-			if(i == normal - 1 || i == normal + 1) var minimum = 10 + DiagramNode.ARC_RADIUS;
-			else var minimum = DiagramNode.ARC_RADIUS;
-			if(i < normal) {
-				this.up += Math.max(minimum, item.height + item.down + DiagramNode.VERTICAL_SEPARATION + this.items[i+1].up);
-			} else if(i > normal) {
-				this.down += Math.max(minimum, item.up + DiagramNode.VERTICAL_SEPARATION + this.items[i-1].down + this.items[i-1].height);
-			}
-		}
-		this.down -= this.items[normal].height; // already counted in this.height
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "multiplechoice"
-		}
-	}
-	subclassOf(MultipleChoiceNode, DiagramNodeMultiContainer);
-	MultipleChoiceNode.prototype.format = function(x, y, width) {
-		var gaps = determineGaps(width, this.width);
-		Path(x, y).right(gaps[0]).addTo(this);
-		Path(x + gaps[0] + this.width, y + this.height).right(gaps[1]).addTo(this);
-		x += gaps[0];
-
-		var normal = this.items[this.normal];
-
-		// Do the elements that curve above
-		for(var i = this.normal - 1; i >= 0; i--) {
-			var item = this.items[i];
-			if( i == this.normal - 1 ) {
-				var distanceFromY = Math.max(10 + DiagramNode.ARC_RADIUS, normal.up + DiagramNode.VERTICAL_SEPARATION + item.down + item.height);
-			}
-			Path(x + 30,y)
-				.up(distanceFromY - DiagramNode.ARC_RADIUS)
-				.arc('wn').addTo(this);
-			item.format(x + 30 + DiagramNode.ARC_RADIUS, y - distanceFromY, this.innerWidth).addTo(this);
-			Path(x + 30 + DiagramNode.ARC_RADIUS + this.innerWidth, y - distanceFromY + item.height)
-				.arc('ne')
-				.down(distanceFromY - item.height + this.height - DiagramNode.ARC_RADIUS - 10)
-				.addTo(this);
-			if(i != 0) {
-				distanceFromY += Math.max(DiagramNode.ARC_RADIUS, item.up + DiagramNode.VERTICAL_SEPARATION + this.items[i-1].down + this.items[i-1].height);
-			}
-		}
-
-		Path(x + 30, y).right(DiagramNode.ARC_RADIUS).addTo(this);
-		normal.format(x + 30 + DiagramNode.ARC_RADIUS, y, this.innerWidth).addTo(this);
-		Path(x + 30 + DiagramNode.ARC_RADIUS + this.innerWidth, y + this.height).right(DiagramNode.ARC_RADIUS).addTo(this);
-
-		for(var i = this.normal+1; i < this.items.length; i++) {
-			var item = this.items[i];
-			if(i == this.normal + 1) {
-				var distanceFromY = Math.max(10+DiagramNode.ARC_RADIUS, normal.height + normal.down + DiagramNode.VERTICAL_SEPARATION + item.up);
-			}
-			Path(x + 30, y)
-				.down(distanceFromY - DiagramNode.ARC_RADIUS)
-				.arc('ws')
-				.addTo(this);
-			item.format(x + 30 + DiagramNode.ARC_RADIUS, y + distanceFromY, this.innerWidth).addTo(this)
-			Path(x + 30 + DiagramNode.ARC_RADIUS + this.innerWidth, y + distanceFromY + item.height)
-				.arc('se')
-				.up(distanceFromY - DiagramNode.ARC_RADIUS + item.height - normal.height)
-				.addTo(this);
-			if(i != this.items.length - 1) {
-				distanceFromY += Math.max(DiagramNode.ARC_RADIUS, item.height + item.down + DiagramNode.VERTICAL_SEPARATION + this.items[i+1].up);
-			}
-		}
-		var text = FakeSVG('g', {"class": "diagram-text"}).addTo(this)
-		FakeSVG('title', {}, (this.type=="any"?"take one or more branches, once each, in any order":"take all branches, once each, in any order")).addTo(text)
-		FakeSVG('path', {
-			"d": "M "+(x+30)+" "+(y-10)+" h -26 a 4 4 0 0 0 -4 4 v 12 a 4 4 0 0 0 4 4 h 26 z",
-			"class": "diagram-text"
-			}).addTo(text)
-		FakeSVG('text', {
-			"x": x + 15,
-			"y": y + 4,
-			"class": "diagram-text"
-			}, (this.type=="any"?"1+":"all")).addTo(text)
-		FakeSVG('path', {
-			"d": "M "+(x+this.width-20)+" "+(y-10)+" h 16 a 4 4 0 0 1 4 4 v 12 a 4 4 0 0 1 -4 4 h -16 z",
-			"class": "diagram-text"
-			}).addTo(text)
-		FakeSVG('path', {
-			"d": "M "+(x+this.width-13)+" "+(y-2)+" a 4 4 0 1 0 6 -1 m 2.75 -1 h -4 v 4 m 0 -3 h 2",
-			"style": "stroke-width: 1.75"
-		}).addTo(text)
-		return this;
-	};
-
-	var OptionalNode = funcs.OptionalNode = function OptionalNode(item, skip) {
-		if( skip === undefined )
-			return ChoiceNode(1, Skip(), item);
-		else if ( skip === "skip" )
-			return ChoiceNode(0, Skip(), item);
-		else
-			throw "Unknown value for OptionalNode()'s 'skip' argument.";
-	}
-
-	var OneOrMoreNode = funcs.OneOrMoreNode = function OneOrMoreNode(item, rep) {
-		if(!(this instanceof OneOrMoreNode)) return new OneOrMoreNode(item, rep);
-		FakeSVG.call(this, 'g');
-		rep = rep || (new Skip);
-		this.item = wrapString(item);
-		this.rep = wrapString(rep);
-		this.width = Math.max(this.item.width, this.rep.width) + DiagramNode.ARC_RADIUS*2;
-		this.height = this.item.height;
-		this.up = this.item.up;
-		this.down = Math.max(DiagramNode.ARC_RADIUS*2, this.item.down + DiagramNode.VERTICAL_SEPARATION + this.rep.up + this.rep.height + this.rep.down);
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "oneormore"
-		}
-	}
-	subclassOf(OneOrMoreNode, FakeSVG);
-	OneOrMoreNode.prototype.needsSpace = true;
-	OneOrMoreNode.prototype.format = function(x,y,width) {
-		// Hook up the two sides if this is narrower than its stated width.
-		var gaps = determineGaps(width, this.width);
-		Path(x,y).h(gaps[0]).addTo(this);
-		Path(x+gaps[0]+this.width,y+this.height).h(gaps[1]).addTo(this);
-		x += gaps[0];
-
-		// Draw item
-		Path(x,y).right(DiagramNode.ARC_RADIUS).addTo(this);
-		this.item.format(x+DiagramNode.ARC_RADIUS,y,this.width-DiagramNode.ARC_RADIUS*2).addTo(this);
-		Path(x+this.width-DiagramNode.ARC_RADIUS,y+this.height).right(DiagramNode.ARC_RADIUS).addTo(this);
-
-		// Draw repeat arc
-		var distanceFromY = Math.max(DiagramNode.ARC_RADIUS*2, this.item.height+this.item.down+DiagramNode.VERTICAL_SEPARATION+this.rep.up);
-		Path(x+DiagramNode.ARC_RADIUS,y).arc('nw').down(distanceFromY-DiagramNode.ARC_RADIUS*2).arc('ws').addTo(this);
-		this.rep.format(x+DiagramNode.ARC_RADIUS, y+distanceFromY, this.width - DiagramNode.ARC_RADIUS*2).addTo(this);
-		Path(x+this.width-DiagramNode.ARC_RADIUS, y+distanceFromY+this.rep.height).arc('se').up(distanceFromY-DiagramNode.ARC_RADIUS*2+this.rep.height-this.item.height).arc('en').addTo(this);
-
-		return this;
-	}
-	OneOrMoreNode.prototype.walk = function(cb) {
-		cb(this);
-		this.item.walk(cb);
-		this.rep.walk(cb);
-	}
-
-	var ZeroOrMore = funcs.ZeroOrMore = function ZeroOrMore(item, rep, skip) {
-		return OptionalNode(OneOrMoreNode(item, rep), skip);
-	}
-
-	var Start = funcs.Start = function Start({type="simple", label}={}) {
-		if(!(this instanceof Start)) return new Start({type, label});
-		FakeSVG.call(this, 'g');
-		this.width = 20;
-		this.height = 0;
-		this.up = 10;
-		this.down = 10;
-		this.type = type;
-		if(label != undefined) {
-			this.label = ""+label;
-			this.width = Math.max(20, this.label.length * DiagramNode.CHAR_WIDTH + 10);
-		}
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "start"
-		}
-	}
-	subclassOf(Start, FakeSVG);
-	Start.prototype.format = function(x,y) {
-		let path = new Path(x, y-10);
-		if (this.type === "complex") {
-			path.down(20)
-				.m(0, -10)
-				.right(this.width)
-				.addTo(this);
-		} else {
-			path.down(20)
-				.m(10, -20)
-				.down(20)
-				.m(-10, -10)
-				.right(this.width)
-				.addTo(this);
-		}
-		if(this.label) {
-			new FakeSVG('text', {x:x, y:y-15, style:"text-anchor:start"}, this.label).addTo(this);
-		}
-		return this;
-	}
-
-	var End = funcs.End = function End({type="simple"}={}) {
-		if(!(this instanceof End)) return new End({type});
-		FakeSVG.call(this, 'path');
-		this.width = 20;
-		this.height = 0;
-		this.up = 10;
-		this.down = 10;
-		this.type = type;
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "end"
-		}
-	}
-	subclassOf(End, FakeSVG);
-	End.prototype.format = function(x,y) {
-		if (this.type === "complex") {
-			this.attrs.d = 'M '+x+' '+y+' h 20 m 0 -10 v 20';
-		} else {
-			this.attrs.d = 'M '+x+' '+y+' h 20 m -10 -10 v 20 m 10 -20 v 20';
-		}
-		return this;
-	}
-
-	var Terminal = funcs.Terminal = function Terminal(text, {href, title}={}) {
-		if(!(this instanceof Terminal)) return new Terminal(text, {href, title});
-		FakeSVG.call(this, 'g', {'class': 'terminal'});
-		this.text = ""+text;
-		this.href = href;
-		this.title = title;
-		this.width = this.text.length * DiagramNode.CHAR_WIDTH + 20;
-		this.height = 0;
-		this.up = 11;
-		this.down = 11;
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "terminal"
-		}
-	}
-	subclassOf(Terminal, FakeSVG);
-	Terminal.prototype.needsSpace = true;
-	Terminal.prototype.format = function(x, y, width) {
-		// Hook up the two sides if this is narrower than its stated width.
-		var gaps = determineGaps(width, this.width);
-		Path(x,y).h(gaps[0]).addTo(this);
-		Path(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);
-		x += gaps[0];
-
-		FakeSVG('rect', {x:x, y:y-11, width:this.width, height:this.up+this.down, rx:10, ry:10}).addTo(this);
-		var text = FakeSVG('text', {x:x+this.width/2, y:y+4}, this.text);
-		if(this.href)
-			FakeSVG('a', {'xlink:href': this.href}, [text]).addTo(this);
-		else
-			text.addTo(this);
-		if(this.title)
-			new FakeSVG('title', {}, this.title).addTo(this);
-		return this;
-	}
-
-	var NonTerminal = funcs.NonTerminal = function NonTerminal(text, element_class, on_click, {href, title}={}) {
-		if(!(this instanceof NonTerminal)) return new NonTerminal(text, {href, title});
-		FakeSVG.call(this, 'g', {'class': 'non-terminal'});
-		this.text = ""+text;
-		this.href = href;
-		this.title = title;
-		this.width = this.text.length * DiagramNode.CHAR_WIDTH + 20;
-		this.height = 0;
-		this.element_class = element_class;
-		this.on_click = on_click;
-		this.up = 11;
-		this.down = 11;
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "nonterminal"
-		}
-	}
-	subclassOf(NonTerminal, FakeSVG);
-	NonTerminal.prototype.needsSpace = true;
-	NonTerminal.prototype.format = function(x, y, width) {
-		// Hook up the two sides if this is narrower than its stated width.
-		var gaps = determineGaps(width, this.width);
-		Path(x,y).h(gaps[0]).addTo(this);
-		Path(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);
-		x += gaps[0];
-
-		var rect = FakeSVG('rect', {x:x, y:y-11, width:this.width, height:this.up+this.down})
-		rect.attrs['class'] = this.element_class
-		rect.addTo(this);
-		if (this.on_click !== undefined) {
-			rect.attrs['onclick'] = this.on_click;
-		}
-
-		var text = FakeSVG('text', {x:x+this.width/2, y:y+4}, this.text);
-		text.attrs['class'] = this.element_class
-		if (this.on_click !== undefined) {
-			console.log(this.on_click);
-			text.attrs['onclick'] = this.on_click;
-		}
-		if(this.href)
-			FakeSVG('a', {'xlink:href': this.href}, [text]).addTo(this);
-		else
-			text.addTo(this);
-		if(this.title)
-			new FakeSVG('title', {}, this.title).addTo(this);
-		return this;
-	}
-
-	var Comment = funcs.Comment = function Comment(text, {href, title}={}) {
-		if(!(this instanceof Comment)) return new Comment(text, {href, title});
-		FakeSVG.call(this, 'g');
-		this.text = ""+text;
-		this.href = href;
-		this.title = title;
-		this.width = this.text.length * DiagramNode.COMMENT_CHAR_WIDTH + 10;
-		this.height = 0;
-		this.up = 11;
-		this.down = 11;
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "comment"
-		}
-	}
-	subclassOf(Comment, FakeSVG);
-	Comment.prototype.needsSpace = true;
-	Comment.prototype.format = function(x, y, width) {
-		// Hook up the two sides if this is narrower than its stated width.
-		var gaps = determineGaps(width, this.width);
-		Path(x,y).h(gaps[0]).addTo(this);
-		Path(x+gaps[0]+this.width,y+this.height).h(gaps[1]).addTo(this);
-		x += gaps[0];
-
-		var text = FakeSVG('text', {x:x+this.width/2, y:y+5, class:'comment'}, this.text);
-		if(this.href)
-			FakeSVG('a', {'xlink:href': this.href}, [text]).addTo(this);
-		else
-			text.addTo(this);
-		if(this.title)
-			new FakeSVG('title', {}, this.title).addTo(this);
-		return this;
-	}
-
-	var Skip = funcs.Skip = function Skip() {
-		if(!(this instanceof Skip)) return new Skip();
-		FakeSVG.call(this, 'g');
-		this.width = 0;
-		this.height = 0;
-		this.up = 0;
-		this.down = 0;
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down
-			this.attrs['data-type'] = "skip"
-		}
-	}
-	subclassOf(Skip, FakeSVG);
-	Skip.prototype.format = function(x, y, width) {
-		Path(x,y).right(width).addTo(this);
-		return this;
-	}
-
-
-	var Block = funcs.Block = function Block({width=50, up=15, height=25, down=15, needsSpace=true}={}) {
-		if(!(this instanceof Block)) return new Block({width, up, height, down, needsSpace});
-		FakeSVG.call(this, 'g');
-		this.width = width;
-		this.height = height;
-		this.up = up;
-		this.down = down;
-		this.needsSpace = true;
-		if(DiagramNode.DEBUG) {
-			this.attrs['data-updown'] = this.up + " " + this.height + " " + this.down;
-			this.attrs['data-type'] = "block"
-		}
-	}
-	subclassOf(Block, FakeSVG);
-	Block.prototype.format = function(x, y, width) {
-		// Hook up the two sides if this is narrower than its stated width.
-		var gaps = determineGaps(width, this.width);
-		new Path(x,y).h(gaps[0]).addTo(this);
-		new Path(x+gaps[0]+this.width,y).h(gaps[1]).addTo(this);
-		x += gaps[0];
-
-		new FakeSVG('rect', {x:x, y:y-this.up, width:this.width, height:this.up+this.height+this.down}).addTo(this);
-		return this;
-	}
-
-	var root;
-	if (typeof define === 'function' && define.amd) {
-		// AMD. Register as an anonymous module.
-		root = {};
-		define([], function() {
-			return root;
-		});
-	} else if (typeof exports === 'object') {
-		// CommonJS for node
-		root = exports;
-	} else {
-		// Browser globals (root is window)
-		root = this;
-	}
-
-	for(var name in funcs) {
-		root[name] = funcs[name];
-	}
-}).call(this,
-	{
-	VERTICAL_SEPARATION: 8,
-	ARC_RADIUS: 10,
-	DIAGRAM_CLASS: 'railroad-diagram',
-	STROKE_ODD_PIXEL_LENGTH: true,
-	INTERNAL_ALIGNMENT: 'left',
-	CHAR_WIDTH: 8.5, // width of each monospace character. play until you find the right value for your font
-	COMMENT_CHAR_WIDTH: 7, // comments are in smaller text by default
-	}
-);
-
-function Diagram(items) {
-	return new DiagramNode(items);
-}
-
-function Sequence(items) {
-	return new SequenceNode(items);
-}
-
-function Stack(items) {
-	return new StackNode(items);
-}
-
-function Optional(items, skip) {
-	return new OptionalNode(items, skip);
-}
-
-function OptionalSequence(items) {
-	return new OptionalSequenceNode(items);
-}
-
-function OneOrMore(items, rep) {
-	return new OneOrMoreNode(items, rep);
-}
-
-function Choice(normal, items) {
-	return new ChoiceNode(normal, items);
-}
-
-function Expression(text="expr", cl="expression", on_click=undefined) {
-	return Sequence([new NonTerminal(text, cl, on_click)]);
-}
-
-function Keyword(text) {
-	return new Terminal(text);
-	// return new Terminal(text)
-}
-
-function Expandable(text, options, node_name, expand_func) {
-	if (options[node_name]) {
-		var sequence = expand_func(options);
-		sequence.unshift(Expression("-", "expanded", "Refresh(\"" + node_name + "\", false)"));
-		return Sequence(sequence)
-	} else {
-		return Expression(text, "expandable", "Refresh(\"" + node_name + "\", true)");
-	}
-}
-
-
-// # see https://github.com/tabatkins/railroad-diagrams
-
-// literal = Choice(0,
-// 	Expression("numeric-literal"),
-// 	Expression("string-literal"),
-// 	Keyword("NULL"),
-// 	Keyword("TRUE"),
-// 	Keyword("FALSE"),
-// 	Keyword("CURRENT_TIME"),
-// 	Keyword("CURRENT_DATE"),
-// 	Keyword("CURRENT_TIMESTAMP")
-// )
-
-// expr = Diagram(
-// 	Choice(0,
-// 		Sequence(Expression("literal")),
-// 		Sequence(Expression("bind-parameter")),
-// 		Sequence(
-// 			Optional(Sequence(
-// 				Expression("table-name"),
-// 				Keyword(".")
-// 			),	skip=True),
-// 			Expression("column-name")
-// 		),
-// 		Sequence(
-// 			Expression("function-name"),
-// 			Keyword("("),
-// 			Optional(
-// 				Sequence(
-// 					Optional(Keyword("DISTINCT"), skip=True),
-// 					OneOrMore(
-// 						Expression(), repeat=","
-// 					)
-// 				), skip=False
-// 			),
-// 			Keyword(")"),
-// 			Optional(Expression("filter-clause"), skip=True),
-// 			Optional(Expression("over-clause"), skip=True)
-// 		),
-// 		Sequence(
-// 			Keyword("("),
-// 			Expression("select-node"),
-// 			Keyword(")")
-// 		),
-// 		Sequence(
-// 			Keyword("CAST"),
-// 			Keyword("("),
-// 			Expression(),
-// 			Keyword("AS"),
-// 			Expression("type-name"),
-// 			Keyword(")")
-// 		),
-// 		Sequence(
-// 			Expression(),
-// 			Keyword("::"),
-// 			Expression("type-name")
-// 		),
-// 		Sequence(
-// 			Expression(),
-// 			Keyword("IS"),
-// 			Optional(Keyword("NOT"), skip=True),
-// 			Keyword("NULL")
-// 		),
-// 		Sequence(
-// 			Expression(),
-// 			Optional(Keyword("NOT"), skip=True),
-// 			Choice(0,
-// 				Keyword("LIKE"),
-// 				Sequence(
-// 					Keyword("SIMILAR"),
-// 					Keyword("TO")
-// 				)),
-// 			Expression(),
-// 			Optional(Sequence(Keyword("ESCAPE"), Expression()), skip=True)
-// 		),
-// 		Sequence(
-// 			Expression(),
-// 			Optional(Keyword("NOT"), skip=True),
-// 			Keyword("BETWEEN"),
-// 			Expression(),
-// 			Keyword("AND"),
-// 			Expression()
-// 		),
-// 		Sequence(
-// 			Expression(),
-// 			Optional(Keyword("NOT"), skip=True),
-// 			Keyword("IN"),
-// 			Choice(0,
-// 				OneOrMore(
-// 					Expression(), ","
-// 				),
-// 				Expression("select-node")
-// 			)
-// 		),
-// 		Sequence(
-// 			Optional(Keyword("NOT"), skip=True),
-// 			Keyword("EXISTS"),
-// 			Expression("select-node")
-// 		),
-// 		Sequence(
-// 			Keyword("CASE"),
-// 			Expression(),
-// 			OneOrMore(
-// 				Sequence(
-// 					Keyword("WHEN"),
-// 					Expression(),
-// 					Keyword("THEN"),
-// 					Expression()
-// 				)
-// 			),
-// 			Keyword("ELSE"),
-// 			Expression(),
-// 			Keyword("END")
-// 		)
-// 	)
-// )
diff --git a/src/common/file_system.cpp b/src/common/file_system.cpp
index 511ecee6f101..69a6acbbf02b 100644
--- a/src/common/file_system.cpp
+++ b/src/common/file_system.cpp
@@ -18,13 +18,13 @@ FileSystem &FileSystem::GetFileSystem(ClientContext &context) {
 
 static void AssertValidFileFlags(uint8_t flags) {
 	// cannot combine Read and Write flags
-	assert(!(flags & FileFlags::READ && flags & FileFlags::WRITE));
+	assert(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_WRITE));
 	// cannot combine Read and CREATE/Append flags
-	assert(!(flags & FileFlags::READ && flags & FileFlags::APPEND));
-	assert(!(flags & FileFlags::READ && flags & FileFlags::FILE_CREATE));
-	assert(!(flags & FileFlags::READ && flags & FileFlags::FILE_CREATE_NEW));
+	assert(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_APPEND));
+	assert(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_FILE_CREATE));
+	assert(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW));
 	// cannot combine CREATE and CREATE_NEW flags
-	assert(!(flags & FileFlags::FILE_CREATE && flags & FileFlags::FILE_CREATE_NEW));
+	assert(!(flags & FileFlags::FILE_FLAGS_FILE_CREATE && flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW));
 }
 
 #ifndef _WIN32
@@ -69,22 +69,22 @@ unique_ptr<FileHandle> FileSystem::OpenFile(const char *path, uint8_t flags, Fil
 
 	int open_flags = 0;
 	int rc;
-	if (flags & FileFlags::READ) {
+	if (flags & FileFlags::FILE_FLAGS_READ) {
 		open_flags = O_RDONLY;
 	} else {
 		// need Read or Write
-		assert(flags & FileFlags::WRITE);
+		assert(flags & FileFlags::FILE_FLAGS_WRITE);
 		open_flags = O_RDWR | O_CLOEXEC;
-		if (flags & FileFlags::FILE_CREATE) {
+		if (flags & FileFlags::FILE_FLAGS_FILE_CREATE) {
 			open_flags |= O_CREAT;
-		} else if (flags & FileFlags::FILE_CREATE_NEW) {
+		} else if (flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW) {
 			open_flags |= O_CREAT | O_TRUNC;
 		}
-		if (flags & FileFlags::APPEND) {
+		if (flags & FileFlags::FILE_FLAGS_APPEND) {
 			open_flags |= O_APPEND;
 		}
 	}
-	if (flags & FileFlags::DIRECT_IO) {
+	if (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {
 #if defined(__sun) && defined(__SVR4)
 		throw Exception("DIRECT_IO not supported on Solaris");
 #endif
@@ -100,7 +100,7 @@ unique_ptr<FileHandle> FileSystem::OpenFile(const char *path, uint8_t flags, Fil
 		throw IOException("Cannot open file \"%s\": %s", path, strerror(errno));
 	}
 	// #if defined(__DARWIN__) || defined(__APPLE__)
-	// 	if (flags & FileFlags::DIRECT_IO) {
+	// 	if (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {
 	// 		// OSX requires fcntl for Direct IO
 	// 		rc = fcntl(fd, F_NOCACHE, 1);
 	// 		if (fd == -1) {
@@ -365,24 +365,24 @@ unique_ptr<FileHandle> FileSystem::OpenFile(const char *path, uint8_t flags, Fil
 	DWORD share_mode;
 	DWORD creation_disposition = OPEN_EXISTING;
 	DWORD flags_and_attributes = FILE_ATTRIBUTE_NORMAL;
-	if (flags & FileFlags::READ) {
+	if (flags & FileFlags::FILE_FLAGS_READ) {
 		desired_access = GENERIC_READ;
 		share_mode = FILE_SHARE_READ;
 	} else {
 		// need Read or Write
-		assert(flags & FileFlags::WRITE);
+		assert(flags & FileFlags::FILE_FLAGS_WRITE);
 		desired_access = GENERIC_READ | GENERIC_WRITE;
 		share_mode = 0;
-		if (flags & FileFlags::FILE_CREATE) {
+		if (flags & FileFlags::FILE_FLAGS_FILE_CREATE) {
 			creation_disposition = OPEN_ALWAYS;
-		} else if (flags & FileFlags::FILE_CREATE_NEW) {
+		} else if (flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW) {
 			creation_disposition = CREATE_ALWAYS;
 		}
-		if (flags & FileFlags::DIRECT_IO) {
+		if (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {
 			flags_and_attributes |= FILE_FLAG_WRITE_THROUGH;
 		}
 	}
-	if (flags & FileFlags::DIRECT_IO) {
+	if (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {
 		flags_and_attributes |= FILE_FLAG_NO_BUFFERING;
 	}
 	HANDLE hFile =
@@ -392,7 +392,7 @@ unique_ptr<FileHandle> FileSystem::OpenFile(const char *path, uint8_t flags, Fil
 		throw IOException("Cannot open file \"%s\": %s", path, error.c_str());
 	}
 	auto handle = make_unique<WindowsFileHandle>(*this, path, hFile);
-	if (flags & FileFlags::APPEND) {
+	if (flags & FileFlags::FILE_FLAGS_APPEND) {
 		SetFilePointer(*handle, GetFileSize(*handle));
 	}
 	return move(handle);
diff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp
index 6e19153232bf..47613c1fa438 100644
--- a/src/common/operator/cast_operators.cpp
+++ b/src/common/operator/cast_operators.cpp
@@ -5,6 +5,7 @@
 #include "duckdb/common/types/date.hpp"
 #include "duckdb/common/types/hugeint.hpp"
 #include "duckdb/common/types/interval.hpp"
+#include "duckdb/common/types/numeric_helper.hpp"
 #include "duckdb/common/types/time.hpp"
 #include "duckdb/common/types/timestamp.hpp"
 #include "duckdb/common/types/vector.hpp"
@@ -552,129 +553,19 @@ template <> string_t StringCast::Operation(bool input, Vector &vector) {
 	}
 }
 
-struct StringToIntegerCast {
-	template <class T> static int UnsignedLength(T value);
-
-	// Formats value in reverse and returns a pointer to the beginning.
-	template <class T> static char *FormatUnsigned(T value, char *ptr) {
-		while (value >= 100) {
-			// Integer division is slow so do it for a group of two digits instead
-			// of for every digit. The idea comes from the talk by Alexandrescu
-			// "Three Optimization Tips for C++". See speed-test for a comparison.
-			auto index = static_cast<unsigned>((value % 100) * 2);
-			value /= 100;
-			*--ptr = duckdb_fmt::internal::data::digits[index + 1];
-			*--ptr = duckdb_fmt::internal::data::digits[index];
-		}
-		if (value < 10) {
-			*--ptr = static_cast<char>('0' + value);
-			return ptr;
-		}
-		auto index = static_cast<unsigned>(value * 2);
-		*--ptr = duckdb_fmt::internal::data::digits[index + 1];
-		*--ptr = duckdb_fmt::internal::data::digits[index];
-		return ptr;
-	}
-
-	template <class SIGNED, class UNSIGNED> static string_t FormatSigned(SIGNED value, Vector &vector) {
-		int sign = -(value < 0);
-		UNSIGNED unsigned_value = (value ^ sign) - sign;
-		int length = UnsignedLength<UNSIGNED>(unsigned_value) - sign;
-		string_t result = StringVector::EmptyString(vector, length);
-		auto dataptr = result.GetData();
-		auto endptr = dataptr + length;
-		endptr = FormatUnsigned(unsigned_value, endptr);
-		if (sign) {
-			*--endptr = '-';
-		}
-		result.Finalize();
-		return result;
-	}
-};
-
-template <> int StringToIntegerCast::UnsignedLength(uint8_t value) {
-	int length = 1;
-	length += value >= 10;
-	length += value >= 100;
-	return length;
-}
-
-template <> int StringToIntegerCast::UnsignedLength(uint16_t value) {
-	int length = 1;
-	length += value >= 10;
-	length += value >= 100;
-	length += value >= 1000;
-	length += value >= 10000;
-	return length;
-}
-
-template <> int StringToIntegerCast::UnsignedLength(uint32_t value) {
-	if (value >= 10000) {
-		int length = 5;
-		length += value >= 100000;
-		length += value >= 1000000;
-		length += value >= 10000000;
-		length += value >= 100000000;
-		length += value >= 1000000000;
-		return length;
-	} else {
-		int length = 1;
-		length += value >= 10;
-		length += value >= 100;
-		length += value >= 1000;
-		return length;
-	}
-}
-
-template <> int StringToIntegerCast::UnsignedLength(uint64_t value) {
-	if (value >= 10000000000ULL) {
-		if (value >= 1000000000000000ULL) {
-			int length = 16;
-			length += value >= 10000000000000000ULL;
-			length += value >= 100000000000000000ULL;
-			length += value >= 1000000000000000000ULL;
-			length += value >= 10000000000000000000ULL;
-			return length;
-		} else {
-			int length = 11;
-			length += value >= 100000000000ULL;
-			length += value >= 1000000000000ULL;
-			length += value >= 10000000000000ULL;
-			length += value >= 100000000000000ULL;
-			return length;
-		}
-	} else {
-		if (value >= 100000ULL) {
-			int length = 6;
-			length += value >= 1000000ULL;
-			length += value >= 10000000ULL;
-			length += value >= 100000000ULL;
-			length += value >= 1000000000ULL;
-			return length;
-		} else {
-			int length = 1;
-			length += value >= 10ULL;
-			length += value >= 100ULL;
-			length += value >= 1000ULL;
-			length += value >= 10000ULL;
-			return length;
-		}
-	}
-}
-
 template <> string_t StringCast::Operation(int8_t input, Vector &vector) {
-	return StringToIntegerCast::FormatSigned<int8_t, uint8_t>(input, vector);
+	return NumericHelper::FormatSigned<int8_t, uint8_t>(input, vector);
 }
 
 template <> string_t StringCast::Operation(int16_t input, Vector &vector) {
-	return StringToIntegerCast::FormatSigned<int16_t, uint16_t>(input, vector);
+	return NumericHelper::FormatSigned<int16_t, uint16_t>(input, vector);
 }
 template <> string_t StringCast::Operation(int32_t input, Vector &vector) {
-	return StringToIntegerCast::FormatSigned<int32_t, uint32_t>(input, vector);
+	return NumericHelper::FormatSigned<int32_t, uint32_t>(input, vector);
 }
 
 template <> string_t StringCast::Operation(int64_t input, Vector &vector) {
-	return StringToIntegerCast::FormatSigned<int64_t, uint64_t>(input, vector);
+	return NumericHelper::FormatSigned<int64_t, uint64_t>(input, vector);
 }
 
 template <> string_t StringCast::Operation(float input, Vector &vector) {
@@ -696,7 +587,7 @@ struct HugeintToStringCast {
 	static int UnsignedLength(hugeint_t value) {
 		assert(value.upper >= 0);
 		if (value.upper == 0) {
-			return StringToIntegerCast::UnsignedLength<uint64_t>(value.lower);
+			return NumericHelper::UnsignedLength<uint64_t>(value.lower);
 		}
 		// search the length using the PowersOfTen array
 		// the length has to be between [17] and [38], because the hugeint is bigger than 2^63
@@ -773,7 +664,7 @@ struct HugeintToStringCast {
 			auto startptr = ptr;
 			// now we format the remainder: note that we need to pad with zero's in case
 			// the remainder is small (i.e. less than 10000000000000000)
-			ptr = StringToIntegerCast::FormatUnsigned<uint64_t>(remainder, ptr);
+			ptr = NumericHelper::FormatUnsigned<uint64_t>(remainder, ptr);
 
 			int format_length = startptr - ptr;
 			// pad with zero
@@ -782,7 +673,7 @@ struct HugeintToStringCast {
 			}
 		}
 		// once the value falls in the range of a uint64_t, fallback to formatting as uint64_t to avoid hugeint division
-		return StringToIntegerCast::FormatUnsigned<uint64_t>(value.lower, ptr);
+		return NumericHelper::FormatUnsigned<uint64_t>(value.lower, ptr);
 	}
 
 	static string_t FormatSigned(hugeint_t value, Vector &vector) {
@@ -796,7 +687,7 @@ struct HugeintToStringCast {
 		auto endptr = dataptr + length;
 		if (value.upper == 0) {
 			// small value: format as uint64_t
-			endptr = StringToIntegerCast::FormatUnsigned<uint64_t>(value.lower, endptr);
+			endptr = NumericHelper::FormatUnsigned<uint64_t>(value.lower, endptr);
 		} else {
 			endptr = FormatUnsigned(value, endptr);
 		}
@@ -842,7 +733,7 @@ struct DateToStringCast {
 	static void Format(char *data, int32_t date[], idx_t year_length, bool add_bc) {
 		// now we write the string, first write the year
 		auto endptr = data + year_length;
-		endptr = StringToIntegerCast::FormatUnsigned(date[0], endptr);
+		endptr = NumericHelper::FormatUnsigned(date[0], endptr);
 		// add optional leading zeros
 		while (endptr > data) {
 			*--endptr = '0';
@@ -930,7 +821,7 @@ struct TimeToStringCast {
 		// now optionally write ms at the end
 		if (time[3] > 0) {
 			auto start = ptr;
-			ptr = StringToIntegerCast::FormatUnsigned(time[3], data + length);
+			ptr = NumericHelper::FormatUnsigned(time[3], data + length);
 			while (ptr > start) {
 				*--ptr = '0';
 			}
@@ -1011,7 +902,7 @@ template <> dtime_t CastTimestampToTime::Operation(timestamp_t input) {
 // Cast To Timestamp
 //===--------------------------------------------------------------------===//
 template <> timestamp_t CastToTimestamp::Operation(string_t input) {
-	return Timestamp::FromString(input.GetData());
+	return Timestamp::FromCString(input.GetData(), input.GetSize());
 }
 
 //===--------------------------------------------------------------------===//
diff --git a/src/common/serializer/buffered_file_reader.cpp b/src/common/serializer/buffered_file_reader.cpp
index 575d87a2ecdc..677d8cb1c016 100644
--- a/src/common/serializer/buffered_file_reader.cpp
+++ b/src/common/serializer/buffered_file_reader.cpp
@@ -10,7 +10,7 @@ using namespace std;
 
 BufferedFileReader::BufferedFileReader(FileSystem &fs, const char *path)
     : fs(fs), data(unique_ptr<data_t[]>(new data_t[FILE_BUFFER_SIZE])), offset(0), read_data(0), total_read(0) {
-	handle = fs.OpenFile(path, FileFlags::READ, FileLockType::READ_LOCK);
+	handle = fs.OpenFile(path, FileFlags::FILE_FLAGS_READ, FileLockType::READ_LOCK);
 	file_size = fs.GetFileSize(*handle);
 }
 
diff --git a/src/common/types/CMakeLists.txt b/src/common/types/CMakeLists.txt
index e56ee124c77b..39654e3a7a5a 100644
--- a/src/common/types/CMakeLists.txt
+++ b/src/common/types/CMakeLists.txt
@@ -7,6 +7,7 @@ add_library_unity(duckdb_common_types
                   hugeint.cpp
                   hyperloglog.cpp
                   interval.cpp
+                  numeric_helper.cpp
                   null_value.cpp
                   selection_vector.cpp
                   string_heap.cpp
diff --git a/src/common/types/date.cpp b/src/common/types/date.cpp
index 4b13649b400a..1d272e7db9d8 100644
--- a/src/common/types/date.cpp
+++ b/src/common/types/date.cpp
@@ -12,6 +12,11 @@
 using namespace duckdb;
 using namespace std;
 
+string_t Date::MonthNamesAbbreviated[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
+string_t Date::MonthNames[] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
+string_t Date::DayNames[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
+string_t Date::DayNamesAbbreviated[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
+
 // Taken from MonetDB mtime.c
 
 static int NORMALDAYS[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
@@ -111,10 +116,10 @@ static bool ParseDoubleDigit(const char *buf, idx_t &pos, int32_t &result) {
 	return false;
 }
 
-static bool TryConvertDate(const char *buf, date_t &result, bool strict = false) {
+bool Date::TryConvertDate(const char *buf, idx_t &pos, date_t &result, bool strict) {
 	int32_t day = 0, month = -1;
 	int32_t year = 0, yearneg = (buf[0] == '-');
-	idx_t pos = 0;
+	pos = 0;
 	int sep;
 
 	// skip leading spaces
@@ -187,7 +192,8 @@ static bool TryConvertDate(const char *buf, date_t &result, bool strict = false)
 
 date_t Date::FromCString(const char *buf, bool strict) {
 	date_t result;
-	if (!TryConvertDate(buf, result, strict)) {
+	idx_t pos;
+	if (!TryConvertDate(buf, pos, result, strict)) {
 		throw ConversionException("date/time field value out of range: \"%s\", "
 		                          "expected format is (YYYY-MM-DD)",
 		                          buf);
@@ -289,8 +295,8 @@ int32_t Date::ExtractISODayOfTheWeek(date_t date) {
 	}
 }
 
-static int32_t GetWeek(int32_t year, int32_t month, int32_t day) {
-	auto day_of_the_year = (leapyear(year) ? CUMLEAPDAYS[month] : CUMDAYS[month]) + day;
+static int32_t GetISOWeek(int32_t year, int32_t month, int32_t day) {
+	auto day_of_the_year = (Date::IsLeapYear(year) ? CUMLEAPDAYS[month] : CUMDAYS[month]) + day;
 	// get the first day of the first week of the year
 	// the first week is the week that has the 4th of January in it
 	auto day_of_the_fourth = Date::ExtractISODayOfTheWeek(Date::FromDate(year, 1, 4));
@@ -301,16 +307,47 @@ static int32_t GetWeek(int32_t year, int32_t month, int32_t day) {
 	auto first_day_of_the_first_week = day_of_the_fourth >= 4 ? 0 : 5 - day_of_the_fourth;
 	if (day_of_the_year < first_day_of_the_first_week) {
 		// day is part of last year
-		return GetWeek(year - 1, 12, day);
+		return GetISOWeek(year - 1, 12, day);
 	} else {
 		return ((day_of_the_year - first_day_of_the_first_week) / 7) + 1;
 	}
 }
 
-int32_t Date::ExtractWeekNumber(date_t date) {
+int32_t Date::ExtractISOWeekNumber(date_t date) {
+	int32_t year, month, day;
+	Date::Convert(date, year, month, day);
+	return GetISOWeek(year, month - 1, day - 1);
+}
+
+int32_t Date::ExtractWeekNumberRegular(date_t date, bool monday_first) {
 	int32_t year, month, day;
 	Date::Convert(date, year, month, day);
-	return GetWeek(year, month - 1, day - 1);
+	month -= 1;
+	day -= 1;
+	// get the day of the year
+	auto day_of_the_year = (Date::IsLeapYear(year) ? CUMLEAPDAYS[month] : CUMDAYS[month]) + day;
+	// now figure out the first monday or sunday of the year
+	// what day is January 1st?
+	auto day_of_jan_first = Date::ExtractISODayOfTheWeek(Date::FromDate(year, 1, 1));
+	// monday = 1, sunday = 7
+	int32_t first_week_start;
+	if (monday_first) {
+		// have to find next "1"
+		if (day_of_jan_first == 1) {
+			// jan 1 is monday: starts immediately
+			first_week_start = 0;
+		} else {
+			// jan 1 is not monday: count days until next monday
+			first_week_start = 8 - day_of_jan_first;
+		}
+	} else {
+		first_week_start = 7 - day_of_jan_first;
+	}
+	if (day_of_the_year < first_week_start) {
+		// day occurs before first week starts: week 0
+		return 0;
+	}
+	return ((day_of_the_year - first_week_start) / 7) + 1;
 }
 
 // Returns the date of the monday of the current week.
diff --git a/src/common/types/numeric_helper.cpp b/src/common/types/numeric_helper.cpp
new file mode 100644
index 000000000000..a83e0353dacf
--- /dev/null
+++ b/src/common/types/numeric_helper.cpp
@@ -0,0 +1,75 @@
+#include "duckdb/common/types/numeric_helper.hpp"
+
+namespace duckdb {
+
+template <> int NumericHelper::UnsignedLength(uint8_t value) {
+	int length = 1;
+	length += value >= 10;
+	length += value >= 100;
+	return length;
+}
+
+template <> int NumericHelper::UnsignedLength(uint16_t value) {
+	int length = 1;
+	length += value >= 10;
+	length += value >= 100;
+	length += value >= 1000;
+	length += value >= 10000;
+	return length;
+}
+
+template <> int NumericHelper::UnsignedLength(uint32_t value) {
+	if (value >= 10000) {
+		int length = 5;
+		length += value >= 100000;
+		length += value >= 1000000;
+		length += value >= 10000000;
+		length += value >= 100000000;
+		length += value >= 1000000000;
+		return length;
+	} else {
+		int length = 1;
+		length += value >= 10;
+		length += value >= 100;
+		length += value >= 1000;
+		return length;
+	}
+}
+
+template <> int NumericHelper::UnsignedLength(uint64_t value) {
+	if (value >= 10000000000ULL) {
+		if (value >= 1000000000000000ULL) {
+			int length = 16;
+			length += value >= 10000000000000000ULL;
+			length += value >= 100000000000000000ULL;
+			length += value >= 1000000000000000000ULL;
+			length += value >= 10000000000000000000ULL;
+			return length;
+		} else {
+			int length = 11;
+			length += value >= 100000000000ULL;
+			length += value >= 1000000000000ULL;
+			length += value >= 10000000000000ULL;
+			length += value >= 100000000000000ULL;
+			return length;
+		}
+	} else {
+		if (value >= 100000ULL) {
+			int length = 6;
+			length += value >= 1000000ULL;
+			length += value >= 10000000ULL;
+			length += value >= 100000000ULL;
+			length += value >= 1000000000ULL;
+			return length;
+		} else {
+			int length = 1;
+			length += value >= 10ULL;
+			length += value >= 100ULL;
+			length += value >= 1000ULL;
+			length += value >= 10000ULL;
+			return length;
+		}
+	}
+}
+
+}
\ No newline at end of file
diff --git a/src/common/types/time.cpp b/src/common/types/time.cpp
index 355b44d9a400..efb2865b68b6 100644
--- a/src/common/types/time.cpp
+++ b/src/common/types/time.cpp
@@ -57,9 +57,9 @@ static bool ParseDoubleDigit2(const char *buf, idx_t &pos, int32_t &result) {
 	return false;
 }
 
-static bool TryConvertTime(const char *buf, dtime_t &result, bool strict = false) {
+bool Time::TryConvertTime(const char *buf, idx_t &pos, dtime_t &result, bool strict) {
 	int32_t hour = -1, min = -1, sec = -1, msec = -1;
-	idx_t pos = 0;
+	pos = 0;
 	int sep;
 
 	// skip leading spaces
@@ -107,8 +107,10 @@ static bool TryConvertTime(const char *buf, dtime_t &result, bool strict = false
 	sep = buf[pos++];
 	if (sep == '.') { // we expect some milliseconds
 		uint8_t mult = 100;
-		for (; std::isdigit((unsigned char)buf[pos]) && mult > 0; pos++, mult /= 10) {
-			msec += (buf[pos] - '0') * mult;
+		for (; std::isdigit((unsigned char)buf[pos]); pos++, mult /= 10) {
+			if (mult > 0) {
+				msec += (buf[pos] - '0') * mult;
+			}
 		}
 	}
 
@@ -130,9 +132,10 @@ static bool TryConvertTime(const char *buf, dtime_t &result, bool strict = false
 
 dtime_t Time::FromCString(const char *buf, bool strict) {
 	dtime_t result;
-	if (!TryConvertTime(buf, result, strict)) {
+	idx_t pos;
+	if (!TryConvertTime(buf, pos, result, strict)) {
 		// last chance, check if we can parse as timestamp
-		if (strlen(buf) > 10 && !strict) {
+		if (!strict) {
 			return Timestamp::GetTime(Timestamp::FromString(buf));
 		}
 		throw ConversionException("time field value out of range: \"%s\", "
diff --git a/src/common/types/timestamp.cpp b/src/common/types/timestamp.cpp
index db93477afa65..3fc84041bb45 100644
--- a/src/common/types/timestamp.cpp
+++ b/src/common/types/timestamp.cpp
@@ -12,7 +12,6 @@ using namespace std;
 
 namespace duckdb {
 
-constexpr const int32_t STD_TIMESTAMP_LENGTH = 19;
 constexpr const int32_t TM_START_YEAR = 1900;
 
 // timestamp/datetime uses 64 bits, high 32 bits for date and low 32 bits for time
@@ -21,33 +20,53 @@ constexpr const int32_t TM_START_YEAR = 1900;
 // Z is optional
 // ISO 8601
 
-timestamp_t Timestamp::FromString(string str) {
-	assert(sizeof(timestamp_t) == 8);
-	assert(sizeof(date_t) == 4);
-	assert(sizeof(dtime_t) == 4);
-
-	// In case we have only date we add a default time
-	if (str.size() == 10) {
-		str += " 00:00:00";
+timestamp_t Timestamp::FromCString(const char *str, idx_t len) {
+	idx_t pos;
+	date_t date;
+	dtime_t time;
+	if (!Date::TryConvertDate(str, pos, date)) {
+		throw ConversionException("timestamp field value out of range: \"%s\", "
+		                          "expected format is (YYYY-MM-DD HH:MM:SS[.MS])",
+		                          str);
 	}
-	// Character length	19 positions minimum to 23 maximum
-	if (str.size() < STD_TIMESTAMP_LENGTH) {
+	if (pos == len) {
+		// no time: only a date
+		return (int64_t)date << 32;
+	}
+	// try to parse a time field
+	if (str[pos] == ' ' || str[pos] == 'T') {
+		pos++;
+	}
+	idx_t time_pos = 0;
+	if (!Time::TryConvertTime(str + pos, time_pos, time)) {
 		throw ConversionException("timestamp field value out of range: \"%s\", "
 		                          "expected format is (YYYY-MM-DD HH:MM:SS[.MS])",
-		                          str.c_str());
+		                          str);
+	}
+	pos += time_pos;
+	if (pos < len) {
+		// skip a "Z" at the end (as per the ISO8601 specs)
+		if (str[pos] == 'Z') {
+			pos++;
+		}
+		// skip any spaces at the end
+		while(pos < len && std::isspace(str[pos])) {
+			pos++;
+		}
+		if (pos < len) {
+			throw ConversionException("timestamp field value out of range: \"%s\", "
+									"expected format is (YYYY-MM-DD HH:MM:SS[.MS])",
+									str);
+		}
 	}
-
-	date_t date = Date::FromString(str.substr(0, 10));
-	dtime_t time = Time::FromString(str.substr(10));
-
 	return ((int64_t)date << 32 | (int32_t)time);
 }
 
-string Timestamp::ToString(timestamp_t timestamp) {
-	assert(sizeof(timestamp_t) == 8);
-	assert(sizeof(date_t) == 4);
-	assert(sizeof(dtime_t) == 4);
+timestamp_t Timestamp::FromString(string str) {
+	return Timestamp::FromCString(str.c_str(), str.size());
+}
 
+string Timestamp::ToString(timestamp_t timestamp) {
 	return Date::ToString(GetDate(timestamp)) + " " + Time::ToString(GetTime(timestamp));
 }
 
diff --git a/src/execution/operator/persistent/buffered_csv_reader.cpp b/src/execution/operator/persistent/buffered_csv_reader.cpp
index cc5ea6195f20..2ebd590d4ffb 100644
--- a/src/execution/operator/persistent/buffered_csv_reader.cpp
+++ b/src/execution/operator/persistent/buffered_csv_reader.cpp
@@ -5,7 +5,9 @@
 #include "duckdb/common/gzip_stream.hpp"
 #include "duckdb/common/string_util.hpp"
 #include "duckdb/common/vector_operations/vector_operations.hpp"
+#include "duckdb/common/vector_operations/unary_executor.hpp"
 #include "duckdb/execution/operator/persistent/physical_copy_from_file.hpp"
+#include "duckdb/function/scalar/strftime.hpp"
 #include "duckdb/main/database.hpp"
 #include "duckdb/parser/column_definition.hpp"
 #include "duckdb/storage/data_table.hpp"
@@ -14,11 +16,11 @@
 #include <algorithm>
 #include <cstring>
 #include <fstream>
-#include <queue>
 
-using namespace duckdb;
 using namespace std;
 
+namespace duckdb {
+
 static char is_newline(char c) {
 	return c == '
' || c == '\r';
 }
@@ -256,6 +258,22 @@ bool BufferedCSVReader::JumpToNextSample() {
 	return true;
 }
 
+bool BufferedCSVReader::TryCastValue(Value value, SQLType sql_type) {
+	try {
+		if (options.has_date_format && sql_type.id == SQLTypeId::DATE) {
+			options.date_format.ParseDate(value.str_value);
+		} else if (options.has_timestamp_format && sql_type.id == SQLTypeId::TIMESTAMP) {
+			options.timestamp_format.ParseTimestamp(value.str_value);
+		} else {
+			value.CastAs(SQLType::VARCHAR, sql_type, true);
+		}
+		return true;
+	} catch (const Exception &e) {
+		return false;
+	}
+	return false;
+}
+
 vector<SQLType> BufferedCSVReader::SniffCSV(vector<SQLType> requested_types) {
 	// TODO: sniff for uncommon (UTF-8) delimiter variants in first lines and add them to the list
 	const vector<string> delim_candidates = {",", "|", ";", "\t"};
@@ -386,10 +404,9 @@ vector<SQLType> BufferedCSVReader::SniffCSV(vector<SQLType> requested_types) {
 					const auto &sql_type = col_type_candidates.back();
 					// try cast from string to sql_type
 					auto dummy_val = parse_chunk.GetValue(col, row);
-					try {
-						dummy_val.CastAs(SQLType::VARCHAR, sql_type, true);
+					if (TryCastValue(dummy_val, sql_type)) {
 						break;
-					} catch (const Exception &e) {
+					} else {
 						col_type_candidates.pop_back();
 					}
 				}
@@ -479,12 +496,8 @@ vector<SQLType> BufferedCSVReader::SniffCSV(vector<SQLType> requested_types) {
 			// try cast to sql_type of column
 			vector<SQLType> &col_type_candidates = best_sql_types_candidates[col];
 			const auto &sql_type = col_type_candidates.back();
-
-			try {
-				dummy_val.CastAs(SQLType::VARCHAR, sql_type, true);
-			} catch (const Exception &e) {
+			if (!TryCastValue(dummy_val, sql_type)) {
 				first_row_consistent = false;
-				break;
 			}
 		}
 	}
@@ -1084,7 +1097,6 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {
 	insert_chunk.SetCardinality(parse_chunk);
 	for (idx_t col_idx = 0; col_idx < sql_types.size(); col_idx++) {
 		if (sql_types[col_idx].id == SQLTypeId::VARCHAR) {
-
 			// target type is varchar: no need to convert
 			// just test that all strings are valid utf-8 strings
 			auto parse_data = FlatVector::GetData<string_t>(parse_chunk.data[col_idx]);
@@ -1107,8 +1119,17 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {
 					}
 				}
 			}
-
 			insert_chunk.data[col_idx].Reference(parse_chunk.data[col_idx]);
+		} else if (options.has_date_format && sql_types[col_idx].id == SQLTypeId::DATE) {
+			// use the date format to cast the chunk
+			UnaryExecutor::Execute<string_t, date_t, true>(parse_chunk.data[col_idx], insert_chunk.data[col_idx], parse_chunk.size(), [&](string_t input) {
+				return options.date_format.ParseDate(input);
+			});
+		} else if (options.has_timestamp_format && sql_types[col_idx].id == SQLTypeId::TIMESTAMP) {
+			// use the date format to cast the chunk
+			UnaryExecutor::Execute<string_t, timestamp_t, true>(parse_chunk.data[col_idx], insert_chunk.data[col_idx], parse_chunk.size(), [&](string_t input) {
+				return options.timestamp_format.ParseTimestamp(input);
+			});
 		} else {
 			// target type is not varchar: perform a cast
 			VectorOperations::Cast(parse_chunk.data[col_idx], insert_chunk.data[col_idx], SQLType::VARCHAR,
@@ -1117,3 +1138,5 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {
 	}
 	parse_chunk.Reset();
 }
+
+}
diff --git a/src/function/cast_rules.cpp b/src/function/cast_rules.cpp
index 1c41bd3b3ef1..7a6b0b70f421 100644
--- a/src/function/cast_rules.cpp
+++ b/src/function/cast_rules.cpp
@@ -15,6 +15,8 @@ static int64_t TargetTypeCost(SQLType type) {
 		return 102;
 	case SQLTypeId::HUGEINT:
 		return 120;
+	case SQLTypeId::TIMESTAMP:
+		return 120;
 	case SQLTypeId::VARCHAR:
 		return 199;
 	default:
@@ -105,6 +107,16 @@ static int64_t ImplicitCastHugeint(SQLType to) {
 	}
 }
 
+static int64_t ImplicitCastDate(SQLType to) {
+	switch (to.id) {
+	case SQLTypeId::TIMESTAMP:
+		return TargetTypeCost(to);
+	default:
+		return -1;
+	}
+}
+
+
 int64_t CastRules::ImplicitCast(SQLType from, SQLType to) {
 	if (to.id == SQLTypeId::ANY) {
 		// anything can be cast to ANY type for no cost
@@ -137,6 +149,8 @@ int64_t CastRules::ImplicitCast(SQLType from, SQLType to) {
 		return ImplicitCastFloat(to);
 	case SQLTypeId::DOUBLE:
 		return ImplicitCastDouble(to);
+	case SQLTypeId::DATE:
+		return ImplicitCastDate(to);
 	default:
 		return -1;
 	}
diff --git a/src/function/scalar/date/CMakeLists.txt b/src/function/scalar/date/CMakeLists.txt
index 667e3e3fdb55..f8357abfaf01 100644
--- a/src/function/scalar/date/CMakeLists.txt
+++ b/src/function/scalar/date/CMakeLists.txt
@@ -5,7 +5,8 @@ add_library_unity(
   current.cpp
   epoch.cpp
   date_trunc.cpp
-  date_part.cpp)
+  date_part.cpp
+  strftime.cpp)
 set(ALL_OBJECT_FILES
     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_func_date>
     PARENT_SCOPE)
diff --git a/src/function/scalar/date/age.cpp b/src/function/scalar/date/age.cpp
index c10d32177252..01315f9daee1 100644
--- a/src/function/scalar/date/age.cpp
+++ b/src/function/scalar/date/age.cpp
@@ -15,7 +15,7 @@ static void age_function_standard(DataChunk &input, ExpressionState &state, Vect
 	auto current_timestamp = Timestamp::GetCurrentTimestamp();
 
 	UnaryExecutor::Execute<timestamp_t, interval_t, true>(input.data[0], result, input.size(), [&](timestamp_t input) {
-		return Interval::GetDifference(input, current_timestamp);
+		return Interval::GetDifference(current_timestamp, input);
 	});
 }
 
diff --git a/src/function/scalar/date/date_part.cpp b/src/function/scalar/date/date_part.cpp
index 9c6d64a30953..6c5a3a4e97ff 100644
--- a/src/function/scalar/date/date_part.cpp
+++ b/src/function/scalar/date/date_part.cpp
@@ -161,7 +161,7 @@ template <> int64_t DayOfYearOperator::Operation(timestamp_t input) {
 
 struct WeekOperator {
 	template <class TA, class TR> static inline TR Operation(TA input) {
-		return Date::ExtractWeekNumber(input);
+		return Date::ExtractISOWeekNumber(input);
 	}
 };
 
@@ -306,20 +306,15 @@ template <> date_t LastDayOperator::Operation(timestamp_t input) {
 	return LastDayOperator::Operation<date_t, date_t>(Timestamp::GetDate(input));
 }
 
-static string_t s_monthNames[] = {"January", "February", "March",     "April",   "May",      "June",
-                                  "July",    "August",   "September", "October", "November", "December"};
-
 struct MonthNameOperator {
 	template <class TA, class TR> static inline TR Operation(TA input) {
-		return s_monthNames[MonthOperator::Operation<TA, int64_t>(input) - 1];
+		return Date::MonthNames[MonthOperator::Operation<TA, int64_t>(input) - 1];
 	}
 };
 
-static string_t s_dayNames[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
-
 struct DayNameOperator {
 	template <class TA, class TR> static inline TR Operation(TA input) {
-		return s_dayNames[DayOfWeekOperator::Operation<TA, int64_t>(input)];
+		return Date::DayNames[DayOfWeekOperator::Operation<TA, int64_t>(input)];
 	}
 };
 
diff --git a/src/function/scalar/date/strftime.cpp b/src/function/scalar/date/strftime.cpp
new file mode 100644
index 000000000000..e4d366f43bf7
--- /dev/null
+++ b/src/function/scalar/date/strftime.cpp
@@ -0,0 +1,1020 @@
+#include "duckdb/function/scalar/date_functions.hpp"
+
+#include "duckdb/planner/expression/bound_function_expression.hpp"
+
+#include "duckdb/common/types/date.hpp"
+#include "duckdb/common/types/time.hpp"
+#include "duckdb/common/types/timestamp.hpp"
+#include "duckdb/common/types/numeric_helper.hpp"
+
+#include "duckdb/function/scalar/strftime.hpp"
+
+#include "duckdb/common/vector_operations/unary_executor.hpp"
+
+#include "duckdb/execution/expression_executor.hpp"
+
+#include "re2/re2.h"
+
+namespace duckdb {
+
+idx_t StrfTimepecifierSize(StrTimeSpecifier specifier) {
+	switch(specifier) {
+	case StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME:
+	case StrTimeSpecifier::ABBREVIATED_MONTH_NAME:
+		return 3;
+	case StrTimeSpecifier::WEEKDAY_DECIMAL:
+		return 1;
+	case StrTimeSpecifier::DAY_OF_MONTH_PADDED:
+	case StrTimeSpecifier::MONTH_DECIMAL_PADDED:
+	case StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED:
+	case StrTimeSpecifier::HOUR_24_PADDED:
+	case StrTimeSpecifier::HOUR_12_PADDED:
+	case StrTimeSpecifier::MINUTE_PADDED:
+	case StrTimeSpecifier::SECOND_PADDED:
+	case StrTimeSpecifier::AM_PM:
+	case StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:
+	case StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:
+		return 2;
+	case StrTimeSpecifier::MICROSECOND_PADDED:
+		return 6;
+	case StrTimeSpecifier::DAY_OF_YEAR_PADDED:
+		return 3;
+	default:
+		return 0;
+	}
+}
+
+void StrTimeFormat::AddLiteral(string literal) {
+	constant_size += literal.size();
+	literals.push_back(move(literal));
+}
+
+void StrTimeFormat::AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier) {
+	AddLiteral(move(preceding_literal));
+	specifiers.push_back(specifier);
+}
+
+
+void StrfTimeFormat::AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier) {
+	is_date_specifier.push_back(IsDateSpecifier(specifier));
+	idx_t specifier_size = StrfTimepecifierSize(specifier);
+	if (specifier_size == 0) {
+		// variable length specifier
+		var_length_specifiers.push_back(specifier);
+	} else {
+		// constant size specifier
+		constant_size += specifier_size;
+	}
+	StrTimeFormat::AddFormatSpecifier(move(preceding_literal), specifier);
+}
+
+idx_t StrfTimeFormat::GetSpecifierLength(StrTimeSpecifier specifier, date_t date, time_t time) {
+	switch(specifier) {
+	case StrTimeSpecifier::FULL_WEEKDAY_NAME:
+		return Date::DayNames[Date::ExtractISODayOfTheWeek(date) % 7].GetSize();
+	case StrTimeSpecifier::FULL_MONTH_NAME:
+		return Date::MonthNames[Date::ExtractMonth(date) - 1].GetSize();
+	case StrTimeSpecifier::YEAR_DECIMAL: {
+		auto year = Date::ExtractYear(date);
+		return NumericHelper::SignedLength<int32_t, uint32_t>(year);
+	}
+	case StrTimeSpecifier::MONTH_DECIMAL: {
+		idx_t len = 1;
+		auto month = Date::ExtractMonth(date);
+		len += month >= 10;
+		return len;
+	}
+	case StrTimeSpecifier::UTC_OFFSET:
+	case StrTimeSpecifier::TZ_NAME:
+		// empty for now
+		return 0;
+	case StrTimeSpecifier::HOUR_24_DECIMAL:
+	case StrTimeSpecifier::HOUR_12_DECIMAL:
+	case StrTimeSpecifier::MINUTE_DECIMAL:
+	case StrTimeSpecifier::SECOND_DECIMAL: {
+		// time specifiers
+		idx_t len = 1;
+		int32_t hour, min, sec, msec;
+		Time::Convert(time, hour, min, sec, msec);
+		switch(specifier) {
+		case StrTimeSpecifier::HOUR_24_DECIMAL:
+			len += hour >= 10;
+			break;
+		case StrTimeSpecifier::HOUR_12_DECIMAL:
+			hour = hour % 12;
+			if (hour == 0) {
+				hour = 12;
+			}
+			len += hour >= 10;
+			break;
+		case StrTimeSpecifier::MINUTE_DECIMAL:
+			len += min >= 10;
+			break;
+		case StrTimeSpecifier::SECOND_DECIMAL:
+			len += sec >= 10;
+			break;
+		default:
+			break;
+		}
+		return len;
+	}
+	case StrTimeSpecifier::DAY_OF_MONTH:
+		return NumericHelper::UnsignedLength<uint32_t>(Date::ExtractDay(date));
+	case StrTimeSpecifier::DAY_OF_YEAR_DECIMAL:
+		return NumericHelper::UnsignedLength<uint32_t>(Date::ExtractDayOfTheYear(date));
+	case StrTimeSpecifier::YEAR_WITHOUT_CENTURY:
+		return NumericHelper::UnsignedLength<uint32_t>(Date::ExtractYear(date) % 100);
+	default:
+		throw NotImplementedException("Unimplemented specifier for GetSpecifierLength");
+	}
+}
+
+//! Returns the total length of the date formatted by this format specifier
+idx_t StrfTimeFormat::GetLength(date_t date, time_t time) {
+	idx_t size = constant_size;
+	if (var_length_specifiers.size() > 0) {
+		for(auto &specifier : var_length_specifiers) {
+			size += GetSpecifierLength(specifier, date, time);
+		}
+	}
+	return size;
+}
+
+char* StrfTimeFormat::WriteString(char *target, string_t &str) {
+	idx_t size = str.GetSize();
+	memcpy(target, str.GetData(), str.GetSize());
+	return target + size;
+}
+
+// write a value in the range of 0..99 unpadded (e.g. "1", "2", ... "98", "99")
+char *StrfTimeFormat::Write2(char *target, uint8_t value) {
+	if (value >= 10) {
+		return WritePadded2(target, value);
+	} else {
+		*target = '0' + value;
+		return target + 1;
+	}
+}
+
+// write a value in the range of 0..99 padded to 2 digits
+char* StrfTimeFormat::WritePadded2(char *target, int32_t value) {
+	auto index = static_cast<unsigned>(value * 2);
+	*target++ = duckdb_fmt::internal::data::digits[index];
+	*target++ = duckdb_fmt::internal::data::digits[index + 1];
+	return target;
+}
+
+// write a value in the range of 0..999 padded
+char *StrfTimeFormat::WritePadded3(char *target, uint32_t value) {
+	if (value >= 100) {
+		WritePadded2(target + 1, value % 100);
+		*target = '0' + value / 100;
+		return target + 3;
+	} else {
+		*target = '0';
+		target++;
+		return WritePadded2(target, value);
+	}
+}
+
+// write a value in the range of 0..999999 padded to 6 digits
+char* StrfTimeFormat::WritePadded(char *target, int32_t value, int32_t padding) {
+	assert(padding % 2 == 0);
+	for(int i = 0; i < padding / 2; i++) {
+		int decimals = value % 100;
+		WritePadded2(target + padding - 2 * (i + 1), decimals);
+		value /= 100;
+	}
+	return target + padding;
+}
+
+bool StrfTimeFormat::IsDateSpecifier(StrTimeSpecifier specifier) {
+	switch(specifier) {
+	case StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME:
+	case StrTimeSpecifier::FULL_WEEKDAY_NAME:
+	case StrTimeSpecifier::WEEKDAY_DECIMAL:
+	case StrTimeSpecifier::DAY_OF_YEAR_PADDED:
+	case StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:
+	case StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:
+	case StrTimeSpecifier::DAY_OF_YEAR_DECIMAL:
+		return true;
+	default:
+		return false;
+	}
+}
+
+char* StrfTimeFormat::WriteDateSpecifier(StrTimeSpecifier specifier, date_t date, char *target) {
+	switch(specifier) {
+	case StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME: {
+		date_t dow = Date::ExtractISODayOfTheWeek(date);
+		target = WriteString(target, Date::DayNamesAbbreviated[dow % 7]);
+		break;
+	}
+	case StrTimeSpecifier::FULL_WEEKDAY_NAME: {
+		date_t dow = Date::ExtractISODayOfTheWeek(date);
+		target = WriteString(target, Date::DayNames[dow % 7]);
+		break;
+	}
+	case StrTimeSpecifier::WEEKDAY_DECIMAL: {
+		date_t dow = Date::ExtractISODayOfTheWeek(date);
+		*target = '0' + (dow % 7);
+		target++;
+		break;
+	}
+	case StrTimeSpecifier::DAY_OF_YEAR_PADDED: {
+		int32_t doy = Date::ExtractDayOfTheYear(date);
+		target = WritePadded3(target, doy);
+		break;
+	}
+	case StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:
+		target = WritePadded2(target, Date::ExtractWeekNumberRegular(date, true));
+		break;
+	case StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:
+		target = WritePadded2(target, Date::ExtractWeekNumberRegular(date, false));
+		break;
+	case StrTimeSpecifier::DAY_OF_YEAR_DECIMAL: {
+		uint32_t doy = Date::ExtractDayOfTheYear(date);
+		target += NumericHelper::UnsignedLength<uint32_t>(doy);
+		NumericHelper::FormatUnsigned(doy, target);
+		break;
+	}
+	default:
+		throw NotImplementedException("Unimplemented date specifier for strftime");
+	}
+	return target;
+}
+
+char* StrfTimeFormat::WriteStandardSpecifier(StrTimeSpecifier specifier, int32_t data[], char *target) {
+	// data contains [0] year, [1] month, [2] day, [3] hour, [4] minute, [5] second, [6] msec
+	switch(specifier) {
+	case StrTimeSpecifier::DAY_OF_MONTH_PADDED:
+		target = WritePadded2(target, data[2]);
+		break;
+	case StrTimeSpecifier::ABBREVIATED_MONTH_NAME: {
+		auto &month_name = Date::MonthNamesAbbreviated[data[1] - 1];
+		return WriteString(target, month_name);
+	}
+	case StrTimeSpecifier::FULL_MONTH_NAME: {
+		auto &month_name = Date::MonthNames[data[1] - 1];
+		return WriteString(target, month_name);
+	}
+	case StrTimeSpecifier::MONTH_DECIMAL_PADDED:
+		target = WritePadded2(target, data[1]);
+		break;
+	case StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED:
+		target = WritePadded2(target, data[0] % 100);
+		break;
+	case StrTimeSpecifier::YEAR_DECIMAL:
+		if (data[0] >= 0 && data[0] <= 9999) {
+			target = WritePadded(target, data[0], 4);
+		} else {
+			int32_t year = data[0];
+			if (data[0] < 0) {
+				*target = '-';
+				year = -year;
+				target++;
+			}
+			auto len = NumericHelper::UnsignedLength<uint32_t>(year);
+			NumericHelper::FormatUnsigned(year, target + len);
+			target += len;
+		}
+		break;
+	case StrTimeSpecifier::HOUR_24_PADDED: {
+		target = WritePadded2(target, data[3]);
+		break;
+	}
+	case StrTimeSpecifier::HOUR_12_PADDED: {
+		int hour = data[3] % 12;
+		if (hour == 0) {
+			hour = 12;
+		}
+		target = WritePadded2(target, hour);
+		break;
+	}
+	case StrTimeSpecifier::AM_PM:
+		*target++ = data[3] >= 12 ? 'P' : 'A';
+		*target++ = 'M';
+		break;
+	case StrTimeSpecifier::MINUTE_PADDED: {
+		target = WritePadded2(target, data[4]);
+		break;
+	}
+	case StrTimeSpecifier::SECOND_PADDED:
+		target = WritePadded2(target, data[5]);
+		break;
+	case StrTimeSpecifier::MICROSECOND_PADDED:
+		target = WritePadded(target, data[6] * 1000, 6);
+		break;
+	case StrTimeSpecifier::UTC_OFFSET:
+	case StrTimeSpecifier::TZ_NAME:
+		// always empty for now, FIXME when we have timestamp with tz
+		break;
+	case StrTimeSpecifier::DAY_OF_MONTH: {
+		target = Write2(target, data[2] % 100);
+		break;
+	}
+	case StrTimeSpecifier::MONTH_DECIMAL: {
+		target = Write2(target, data[1]);
+		break;
+	}
+	case StrTimeSpecifier::YEAR_WITHOUT_CENTURY: {
+		target = Write2(target, data[0] % 100);
+		break;
+	}
+	case StrTimeSpecifier::HOUR_24_DECIMAL: {
+		target = Write2(target, data[3]);
+		break;
+	}
+	case StrTimeSpecifier::HOUR_12_DECIMAL: {
+		int hour = data[3] % 12;
+		if (hour == 0) {
+			hour = 12;
+		}
+		target = Write2(target, hour);
+		break;
+	}
+	case StrTimeSpecifier::MINUTE_DECIMAL: {
+		target = Write2(target, data[4]);
+		break;
+	}
+	case StrTimeSpecifier::SECOND_DECIMAL: {
+		target = Write2(target, data[5]);
+		break;
+	}
+	default:
+		throw NotImplementedException("Unimplemented specifier for WriteStandardSpecifier in strftime");
+	}
+	return target;
+}
+
+void StrfTimeFormat::FormatString(date_t date, int32_t data[7], char *target) {
+	idx_t i;
+	for(i = 0; i < specifiers.size(); i++) {
+		// first copy the current literal
+		memcpy(target, literals[i].c_str(), literals[i].size());
+		target += literals[i].size();
+		// now copy the specifier
+		if (is_date_specifier[i]) {
+			target = WriteDateSpecifier(specifiers[i], date, target);
+		} else {
+			target = WriteStandardSpecifier(specifiers[i], data, target);
+		}
+	}
+	// copy the final literal into the target
+	memcpy(target, literals[i].c_str(), literals[i].size());
+
+}
+
+void StrfTimeFormat::FormatString(date_t date, time_t time, char *target) {
+	int32_t data[7]; // year, month, day, hour, min, sec, msec
+	Date::Convert(date, data[0], data[1], data[2]);
+	Time::Convert(time, data[3], data[4], data[5], data[6]);
+
+	FormatString(date, data, target);
+}
+
+string StrTimeFormat::ParseFormatSpecifier(string format_string, StrTimeFormat &format) {
+	format.constant_size = 0;
+	idx_t pos = 0;
+	string current_literal;
+	for(idx_t i = 0; i < format_string.size(); i++) {
+		if (format_string[i] == '%') {
+			if (i + 1 == format_string.size()) {
+				return "Trailing format character %";
+			}
+			if (i > pos) {
+				// push the previous string to the current literal
+				current_literal += format_string.substr(pos, i - pos);
+			}
+			char format_char = format_string[++i];
+			if (format_char == '%') {
+				// special case: %%
+				// set the pos for the next literal and continue
+				pos = i;
+				continue;
+			}
+			StrTimeSpecifier specifier;
+			if (format_char == '-' && i + 1 < format_string.size()) {
+				format_char = format_string[++i];
+				switch(format_char) {
+				case 'd':
+					specifier = StrTimeSpecifier::DAY_OF_MONTH;
+					break;
+				case 'm':
+					specifier = StrTimeSpecifier::MONTH_DECIMAL;
+					break;
+				case 'y':
+					specifier = StrTimeSpecifier::YEAR_WITHOUT_CENTURY;
+					break;
+				case 'H':
+					specifier = StrTimeSpecifier::HOUR_24_DECIMAL;
+					break;
+				case 'I':
+					specifier = StrTimeSpecifier::HOUR_12_DECIMAL;
+					break;
+				case 'M':
+					specifier = StrTimeSpecifier::MINUTE_DECIMAL;
+					break;
+				case 'S':
+					specifier = StrTimeSpecifier::SECOND_DECIMAL;
+					break;
+				case 'j':
+					specifier = StrTimeSpecifier::DAY_OF_YEAR_DECIMAL;
+					break;
+				default:
+					return "Unrecognized format for strftime/strptime: %-" + string(format_char, 1);
+				}
+			} else {
+				switch(format_char) {
+				case 'a':
+					specifier = StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME;
+					break;
+				case 'A':
+					specifier = StrTimeSpecifier::FULL_WEEKDAY_NAME;
+					break;
+				case 'w':
+					specifier = StrTimeSpecifier::WEEKDAY_DECIMAL;
+					break;
+				case 'd':
+					specifier = StrTimeSpecifier::DAY_OF_MONTH_PADDED;
+					break;
+				case 'h':
+				case 'b':
+					specifier = StrTimeSpecifier::ABBREVIATED_MONTH_NAME;
+					break;
+				case 'B':
+					specifier = StrTimeSpecifier::FULL_MONTH_NAME;
+					break;
+				case 'm':
+					specifier = StrTimeSpecifier::MONTH_DECIMAL_PADDED;
+					break;
+				case 'y':
+					specifier = StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED;
+					break;
+				case 'Y':
+					specifier = StrTimeSpecifier::YEAR_DECIMAL;
+					break;
+				case 'H':
+					specifier = StrTimeSpecifier::HOUR_24_PADDED;
+					break;
+				case 'I':
+					specifier = StrTimeSpecifier::HOUR_12_PADDED;
+					break;
+				case 'p':
+					specifier = StrTimeSpecifier::AM_PM;
+					break;
+				case 'M':
+					specifier = StrTimeSpecifier::MINUTE_PADDED;
+					break;
+				case 'S':
+					specifier = StrTimeSpecifier::SECOND_PADDED;
+					break;
+				case 'f':
+					specifier = StrTimeSpecifier::MICROSECOND_PADDED;
+					break;
+				case 'z':
+					specifier = StrTimeSpecifier::UTC_OFFSET;
+					break;
+				case 'Z':
+					specifier = StrTimeSpecifier::TZ_NAME;
+					break;
+				case 'j':
+					specifier = StrTimeSpecifier::DAY_OF_YEAR_PADDED;
+					break;
+				case 'U':
+					specifier = StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST;
+					break;
+				case 'W':
+					specifier = StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST;
+					break;
+				case 'c':
+				case 'x':
+				case 'X': {
+					string subformat;
+					if (format_char == 'c') {
+						// %c: Locales appropriate date and time representation.
+						// we push the ISO timestamp representation here
+						subformat = "%Y-%m-%d %H:%M:%S";
+					} else if (format_char == 'x') {
+						// %x - Locales appropriate date representation.
+						// we push the ISO date format here
+						subformat = "%Y-%m-%d";
+					} else if (format_char == 'X') {
+						// %X - Locales appropriate time representation.
+						// we push the ISO time format here
+						subformat = "%H:%M:%S";
+					}
+					// parse the subformat in a separate format specifier
+					StrfTimeFormat locale_format;
+					string error = StrTimeFormat::ParseFormatSpecifier(subformat, locale_format);
+					assert(error.empty());
+					// add the previous literal to the first literal of the subformat
+					locale_format.literals[0] = move(current_literal) + locale_format.literals[0];
+					// now push the subformat into the current format specifier
+					for(idx_t i = 0; i < locale_format.specifiers.size(); i++) {
+						format.AddFormatSpecifier(move(locale_format.literals[i]), locale_format.specifiers[i]);
+					}
+					pos = i + 1;
+					continue;
+				}
+				default:
+					return "Unrecognized format for strftime/strptime: %" + string(format_char, 1);
+				}
+			}
+			format.AddFormatSpecifier(move(current_literal), specifier);
+			pos = i + 1;
+		}
+	}
+	// add the final literal
+	if (pos < format_string.size()) {
+		current_literal += format_string.substr(pos, format_string.size() - pos);
+	}
+	format.AddLiteral(move(current_literal));
+	return string();
+}
+
+struct StrfTimeBindData : public FunctionData {
+	StrfTimeBindData(StrfTimeFormat format) : format(move(format)) {}
+
+	StrfTimeFormat format;
+
+	unique_ptr<FunctionData> Copy() override {
+		return make_unique<StrfTimeBindData>(format);
+	}
+};
+
+static unique_ptr<FunctionData> strftime_bind_function(BoundFunctionExpression &expr, ClientContext &context) {
+	if (!expr.children[1]->IsScalar()) {
+		throw InvalidInputException("strftime format must be a constant");
+	}
+	Value options_str = ExpressionExecutor::EvaluateScalar(*expr.children[1]);
+	StrfTimeFormat format;
+	if (!options_str.is_null && options_str.type == TypeId::VARCHAR) {
+		string error = StrTimeFormat::ParseFormatSpecifier(options_str.str_value, format);
+		if (!error.empty()) {
+			throw InvalidInputException("Failed to parse format specifier %s: %s", options_str.str_value.c_str(), error.c_str());
+		}
+	}
+	return make_unique<StrfTimeBindData>(format);
+}
+
+static void strftime_function_date(DataChunk &args, ExpressionState &state, Vector &result) {
+	auto &func_expr = (BoundFunctionExpression &)state.expr;
+	auto &info = (StrfTimeBindData &)*func_expr.bind_info;
+
+	if (ConstantVector::IsNull(args.data[1])) {
+		result.vector_type = VectorType::CONSTANT_VECTOR;
+		ConstantVector::SetNull(result, true);
+		return;
+	}
+
+	time_t time = 0;
+	UnaryExecutor::Execute<date_t, string_t, true>(args.data[0], result, args.size(), [&](date_t date) {
+		idx_t len = info.format.GetLength(date, time);
+		string_t target = StringVector::EmptyString(result, len);
+		info.format.FormatString(date, time, target.GetData());
+		target.Finalize();
+		return target;
+	});
+}
+
+static void strftime_function_timestamp(DataChunk &args, ExpressionState &state, Vector &result) {
+	auto &func_expr = (BoundFunctionExpression &)state.expr;
+	auto &info = (StrfTimeBindData &)*func_expr.bind_info;
+
+	if (ConstantVector::IsNull(args.data[1])) {
+		result.vector_type = VectorType::CONSTANT_VECTOR;
+		ConstantVector::SetNull(result, true);
+		return;
+	}
+
+	UnaryExecutor::Execute<timestamp_t, string_t, true>(args.data[0], result, args.size(), [&](timestamp_t timestamp) {
+		date_t date;
+		dtime_t time;
+		Timestamp::Convert(timestamp, date, time);
+		idx_t len = info.format.GetLength(date, time);
+		string_t target = StringVector::EmptyString(result, len);
+		info.format.FormatString(date, time, target.GetData());
+		target.Finalize();
+		return target;
+	});
+}
+
+void StrfTimeFun::RegisterFunction(BuiltinFunctions &set) {
+	ScalarFunctionSet strftime("strftime");
+
+	strftime.AddFunction(ScalarFunction({SQLType::DATE, SQLType::VARCHAR}, SQLType::VARCHAR,
+	                               strftime_function_date, false, strftime_bind_function));
+
+	strftime.AddFunction(ScalarFunction({SQLType::TIMESTAMP, SQLType::VARCHAR}, SQLType::VARCHAR,
+	                               strftime_function_timestamp, false, strftime_bind_function));
+
+	set.AddFunction(strftime);
+}
+
+void StrpTimeFormat::AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier) {
+	switch(specifier) {
+	case StrTimeSpecifier::DAY_OF_YEAR_PADDED:
+	case StrTimeSpecifier::DAY_OF_YEAR_DECIMAL:
+	case StrTimeSpecifier::WEEKDAY_DECIMAL:
+	case StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:
+	case StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:
+		throw NotImplementedException("Unimplemented specifier for strptime");
+	default:
+		break;
+	}
+	is_numeric.push_back(IsNumericSpecifier(specifier));
+	StrTimeFormat::AddFormatSpecifier(move(preceding_literal), specifier);
+}
+
+bool StrpTimeFormat::IsNumericSpecifier(StrTimeSpecifier specifier) {
+	switch(specifier) {
+	case StrTimeSpecifier::WEEKDAY_DECIMAL:
+	case StrTimeSpecifier::DAY_OF_MONTH_PADDED:
+	case StrTimeSpecifier::DAY_OF_MONTH:
+	case StrTimeSpecifier::MONTH_DECIMAL_PADDED:
+	case StrTimeSpecifier::MONTH_DECIMAL:
+	case StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED:
+	case StrTimeSpecifier::YEAR_WITHOUT_CENTURY:
+	case StrTimeSpecifier::YEAR_DECIMAL:
+	case StrTimeSpecifier::HOUR_24_PADDED:
+	case StrTimeSpecifier::HOUR_24_DECIMAL:
+	case StrTimeSpecifier::HOUR_12_PADDED:
+	case StrTimeSpecifier::HOUR_12_DECIMAL:
+	case StrTimeSpecifier::MINUTE_PADDED:
+	case StrTimeSpecifier::MINUTE_DECIMAL:
+	case StrTimeSpecifier::SECOND_PADDED:
+	case StrTimeSpecifier::SECOND_DECIMAL:
+	case StrTimeSpecifier::MICROSECOND_PADDED:
+	case StrTimeSpecifier::DAY_OF_YEAR_PADDED:
+	case StrTimeSpecifier::DAY_OF_YEAR_DECIMAL:
+	case StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:
+	case StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:
+		return true;
+	default:
+		return false;
+	}
+}
+
+enum class TimeSpecifierAMOrPM : uint8_t {
+	TIME_SPECIFIER_NONE = 0,
+	TIME_SPECIFIER_AM = 1,
+	TIME_SPECIFIER_PM = 2
+};
+
+int32_t StrpTimeFormat::TryParseCollection(const char *data, idx_t &pos, idx_t size, string_t collection[], idx_t collection_count) {
+	for(idx_t c = 0; c < collection_count; c++) {
+		auto &entry = collection[c];
+		auto entry_data = entry.GetData();
+		auto entry_size = entry.GetSize();
+		// check if this entry matches
+		if (pos + entry_size > size) {
+			// too big: can't match
+			continue;
+		}
+		// compare the characters
+		idx_t i;
+		for(i = 0; i < entry_size; i++) {
+			if (std::tolower(entry_data[i]) != std::tolower(data[pos + i])) {
+				break;
+			}
+		}
+		if (i == entry_size) {
+			// full match
+			pos += entry_size;
+			return c;
+		}
+	}
+	return -1;
+}
+
+//! Parses a timestamp using the given specifier
+bool StrpTimeFormat::Parse(string_t str, int32_t result_data[], string &error_message, idx_t &error_position) {
+	// initialize the result
+	result_data[0] = 1900;
+	result_data[1] = 1;
+	result_data[2] = 1;
+	result_data[3] = 0;
+	result_data[4] = 0;
+	result_data[5] = 0;
+	result_data[6] = 0;
+
+	auto data = str.GetData();
+	idx_t size = str.GetSize();
+	// skip leading spaces
+	while(std::isspace(*data)) {
+		data++;
+		size--;
+	}
+	idx_t pos = 0;
+	TimeSpecifierAMOrPM ampm = TimeSpecifierAMOrPM::TIME_SPECIFIER_NONE;
+
+	for(idx_t i = 0; ; i++) {
+		// first compare the literal
+		if (literals[i].size() > (size - pos) || memcmp(data + pos, literals[i].c_str(), literals[i].size()) != 0) {
+			// literal does not match
+			error_message = "Literal does not match, expected " + literals[i];
+			error_position = pos;
+			return false;
+		}
+		pos += literals[i].size();
+		if (i == specifiers.size()) {
+			break;
+		}
+		// now parse the specifier
+		if (is_numeric[i]) {
+			// numeric specifier: parse a number
+			uint64_t number = 0;
+			size_t start_pos = pos;
+			while(pos < size && std::isdigit(data[pos])) {
+				if (number > 1000000ULL) {
+					// no number bigger than this is required anywhere
+					error_message = "Number is out of range of format specifier";
+					error_position = start_pos;
+					return false;
+				}
+				number = number * 10 + data[pos] - '0';
+				pos++;
+			}
+			if (pos == start_pos) {
+				// expected a number here
+				error_message = "Expected a number";
+				error_position = start_pos;
+				return false;
+			}
+			switch(specifiers[i]) {
+			case StrTimeSpecifier::DAY_OF_MONTH_PADDED:
+			case StrTimeSpecifier::DAY_OF_MONTH:
+				if (number < 1 || number > 31) {
+					error_message = "Day out of range, expected a value between 1 and 31";
+					error_position = start_pos;
+					return false;
+				}
+				// day of the month
+				result_data[2] = number;
+				break;
+			case StrTimeSpecifier::MONTH_DECIMAL_PADDED:
+			case StrTimeSpecifier::MONTH_DECIMAL:
+				if (number < 1 || number > 12) {
+					error_message = "Month out of range, expected a value between 1 and 12";
+					error_position = start_pos;
+					return false;
+				}
+				// month number
+				result_data[1] = number;
+				break;
+			case StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED:
+			case StrTimeSpecifier::YEAR_WITHOUT_CENTURY:
+				// year without century..
+				// Python uses 69 as a crossover point (i.e. >= 69 is 19.., < 69 is 20..)
+				if (number >= 100) {
+					// %y only supports numbers between [0..99]
+					error_message = "Year without century out of range, expected a value between 0 and 99";
+					error_position = start_pos;
+					return false;
+				}
+				if (number >= 69) {
+					result_data[0] = 1900 + number;
+				} else {
+					result_data[0] = 2000 + number;
+				}
+				break;
+			case StrTimeSpecifier::YEAR_DECIMAL:
+				// year as full number
+				result_data[0] = number;
+				break;
+			case StrTimeSpecifier::HOUR_24_PADDED:
+			case StrTimeSpecifier::HOUR_24_DECIMAL:
+				if (number >= 24) {
+					error_message = "Hour out of range, expected a value between 0 and 23";
+					error_position = start_pos;
+					return false;
+				}
+				// hour as full number
+				result_data[3] = number;
+				break;
+			case StrTimeSpecifier::HOUR_12_PADDED:
+			case StrTimeSpecifier::HOUR_12_DECIMAL:
+				if (number < 1 || number > 12) {
+					error_message = "Hour12 out of range, expected a value between 1 and 12";
+					error_position = start_pos;
+					return false;
+				}
+				// 12-hour number: start off by just storing the number
+				result_data[3] = number;
+				break;
+			case StrTimeSpecifier::MINUTE_PADDED:
+			case StrTimeSpecifier::MINUTE_DECIMAL:
+				if (number >= 60) {
+					error_message = "Minutes out of range, expected a value between 0 and 59";
+					error_position = start_pos;
+					return false;
+				}
+				// minutes
+				result_data[4] = number;
+				break;
+			case StrTimeSpecifier::SECOND_PADDED:
+			case StrTimeSpecifier::SECOND_DECIMAL:
+				if (number >= 60) {
+					error_message = "Seconds out of range, expected a value between 0 and 59";
+					error_position = start_pos;
+					return false;
+				}
+				// seconds
+				result_data[5] = number;
+				break;
+			case StrTimeSpecifier::MICROSECOND_PADDED:
+				if (number >= 1000000ULL) {
+					error_message = "Microseconds out of range, expected a value between 0 and 999999";
+					error_position = start_pos;
+					return false;
+				}
+				// microseconds
+				result_data[6] = number * 1000;
+				break;
+			default:
+				throw NotImplementedException("Unsupported specifier for strptime");
+			}
+		} else {
+			switch(specifiers[i]) {
+			case StrTimeSpecifier::AM_PM: {
+				// parse the next 2 characters
+				if (pos + 2 > size) {
+					// no characters left to parse
+					error_message = "Expected AM/PM";
+					error_position = pos;
+					return false;
+				}
+				char pa_char = std::tolower(data[pos]);
+				char m_char = std::tolower(data[pos + 1]);
+				if (m_char != 'm') {
+					error_message = "Expected AM/PM";
+					error_position = pos;
+					return false;
+				}
+				if (pa_char == 'p') {
+					ampm = TimeSpecifierAMOrPM::TIME_SPECIFIER_PM;
+				} else if (pa_char == 'a') {
+					ampm = TimeSpecifierAMOrPM::TIME_SPECIFIER_AM;
+				} else {
+					error_message = "Expected AM/PM";
+					error_position = pos;
+					return false;
+				}
+				pos += 2;
+				break;
+			}
+			// we parse weekday names, but we don't use them as information
+			case StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME:
+				if (TryParseCollection(data, pos, size, Date::DayNamesAbbreviated, 7) < 0) {
+					error_message = "Expected an abbreviated day name (Mon, Tue, Wed, Thu, Fri, Sat, Sun)";
+					error_position = pos;
+					return false;
+				}
+				break;
+			case StrTimeSpecifier::FULL_WEEKDAY_NAME:
+				if (TryParseCollection(data, pos, size, Date::DayNames, 7) < 0) {
+					error_message = "Expected a full day name (Monday, Tuesday, etc...)";
+					error_position = pos;
+					return false;
+				}
+				break;
+			case StrTimeSpecifier::ABBREVIATED_MONTH_NAME: {
+				int32_t month = TryParseCollection(data, pos, size, Date::MonthNamesAbbreviated, 12);
+				if (month < 0) {
+					error_message = "Expected an abbreviated month name (Jan, Feb, Mar, etc..)";
+					error_position = pos;
+					return false;
+				}
+				result_data[1] = month + 1;
+				break;
+			}
+			case StrTimeSpecifier::FULL_MONTH_NAME: {
+				int32_t month = TryParseCollection(data, pos, size, Date::MonthNames, 12);
+				if (month < 0) {
+					error_message = "Expected a full month name (January, February, etc...)";
+					error_position = pos;
+					return false;
+				}
+				result_data[1] = month + 1;
+				break;
+			}
+			default:
+				throw NotImplementedException("Unsupported specifier for strptime");
+			}
+		}
+	}
+	// skip trailing spaces
+	while(std::isspace(data[pos])) {
+		pos++;
+	}
+	if (pos != size) {
+		error_message = "Full specifier did not match: trailing characters";
+		error_position = pos;
+		return false;
+	}
+	if (ampm != TimeSpecifierAMOrPM::TIME_SPECIFIER_NONE) {
+		// fixme: adjust the hours based on the AM or PM specifier
+		if (ampm == TimeSpecifierAMOrPM::TIME_SPECIFIER_AM) {
+			// AM: 12AM=0, 1AM=1, 2AM=2, ..., 11AM=11
+			if (result_data[3] == 12) {
+				result_data[3] = 0;
+			}
+		} else {
+			// PM: 12PM=12, 1PM=13, 2PM=14, ..., 11PM=23
+			if (result_data[3] != 12) {
+				result_data[3] += 12;
+			}
+		}
+	}
+	return true;
+}
+
+struct StrpTimeBindData : public FunctionData {
+	StrpTimeBindData(StrpTimeFormat format) : format(move(format)) {}
+
+	StrpTimeFormat format;
+
+	unique_ptr<FunctionData> Copy() override {
+		return make_unique<StrpTimeBindData>(format);
+	}
+};
+
+static unique_ptr<FunctionData> strptime_bind_function(BoundFunctionExpression &expr, ClientContext &context) {
+	if (!expr.children[1]->IsScalar()) {
+		throw InvalidInputException("strftime format must be a constant");
+	}
+	Value options_str = ExpressionExecutor::EvaluateScalar(*expr.children[1]);
+	StrpTimeFormat format;
+	if (!options_str.is_null && options_str.type == TypeId::VARCHAR) {
+		format.format_specifier = options_str.str_value;
+		string error = StrTimeFormat::ParseFormatSpecifier(options_str.str_value, format);
+		if (!error.empty()) {
+			throw InvalidInputException("Failed to parse format specifier %s: %s", options_str.str_value.c_str(), error.c_str());
+		}
+	}
+	return make_unique<StrpTimeBindData>(format);
+}
+
+string StrpTimeFormat::FormatStrpTimeError(string input, idx_t position) {
+	if (position == INVALID_INDEX) {
+		return string();
+	}
+	return input + "
" + string(position, ' ') + "^";
+}
+
+date_t StrpTimeFormat::ParseDate(string_t input) {
+	string error_message;
+	idx_t error_position = INVALID_INDEX;
+	int32_t result_data[7];
+	if (!Parse(input, result_data, error_message, error_position)) {
+		throw InvalidInputException("Could not parse string \"%s\" according to format specifier \"%s\"
%s
Error: %s",
+			input.GetData(),
+			format_specifier.c_str(),
+			FormatStrpTimeError(string(input.GetData(), input.GetSize()), error_position).c_str(),
+			error_message.c_str());
+	}
+	return Date::FromDate(result_data[0], result_data[1], result_data[2]);
+}
+
+timestamp_t StrpTimeFormat::ParseTimestamp(string_t input) {
+	string error_message;
+	idx_t error_position = INVALID_INDEX;
+	int32_t result_data[7];
+	if (!Parse(input, result_data, error_message, error_position)) {
+		throw InvalidInputException("Could not parse string \"%s\" according to format specifier \"%s\"
%s
Error: %s",
+			input.GetData(),
+			format_specifier.c_str(),
+			FormatStrpTimeError(string(input.GetData(), input.GetSize()), error_position).c_str(),
+			error_message.c_str());
+	}
+	date_t date = Date::FromDate(result_data[0], result_data[1], result_data[2]);
+	dtime_t time = Time::FromTime(result_data[3], result_data[4], result_data[5], result_data[6]);
+	return Timestamp::FromDatetime(date, time);
+}
+
+static void strptime_function(DataChunk &args, ExpressionState &state, Vector &result) {
+	auto &func_expr = (BoundFunctionExpression &)state.expr;
+	auto &info = (StrpTimeBindData &)*func_expr.bind_info;
+
+	if (ConstantVector::IsNull(args.data[1])) {
+		result.vector_type = VectorType::CONSTANT_VECTOR;
+		ConstantVector::SetNull(result, true);
+		return;
+	}
+	UnaryExecutor::Execute<string_t, timestamp_t, true>(args.data[0], result, args.size(), [&](string_t input) {
+		return info.format.ParseTimestamp(input);
+	});
+}
+
+void StrpTimeFun::RegisterFunction(BuiltinFunctions &set) {
+	ScalarFunctionSet strptime("strptime");
+
+	strptime.AddFunction(ScalarFunction({SQLType::VARCHAR, SQLType::VARCHAR}, SQLType::TIMESTAMP,
+	                               strptime_function, false, strptime_bind_function));
+
+	set.AddFunction(strptime);
+}
+
+
+}
diff --git a/src/function/scalar/date_functions.cpp b/src/function/scalar/date_functions.cpp
index 78c8cd84dcb8..9a334f241dc3 100644
--- a/src/function/scalar/date_functions.cpp
+++ b/src/function/scalar/date_functions.cpp
@@ -11,4 +11,6 @@ void BuiltinFunctions::RegisterDateFunctions() {
 	Register<CurrentDateFun>();
 	Register<CurrentTimestampFun>();
 	Register<EpochFun>();
+	Register<StrfTimeFun>();
+	Register<StrpTimeFun>();
 }
diff --git a/src/function/table/copy_csv.cpp b/src/function/table/copy_csv.cpp
index 57bbe1293d5a..20eb83f12f7d 100644
--- a/src/function/table/copy_csv.cpp
+++ b/src/function/table/copy_csv.cpp
@@ -60,6 +60,14 @@ struct ReadCSVData : public BaseCSVData {
 	vector<SQLType> sql_types;
 	//! True, if column with that index must be quoted
 	vector<bool> force_not_null;
+	//! The DATE_FORMAT to use to read or write dates
+	StrpTimeFormat date_format;
+	//! Whether or not there is a date format specified
+	bool has_date_format = false;
+	//! The DATE_FORMAT to use to read or write dates
+	StrpTimeFormat timestamp_format;
+	//! Whether or not there is a date format specified
+	bool has_timestamp_format = false;
 };
 
 void SubstringDetection(string &str_1, string &str_2, string name_str_1, string name_str_2) {
@@ -226,6 +234,22 @@ static unique_ptr<FunctionData> read_csv_bind(ClientContext &context, CopyInfo &
 			continue;
 		} else if (loption == "force_not_null") {
 			bind_data->force_not_null = ParseColumnList(set, expected_names);
+		}  else if (loption == "date_format" || loption == "dateformat") {
+			string format = ParseString(set);
+			string error = StrTimeFormat::ParseFormatSpecifier(format, bind_data->date_format);
+			bind_data->date_format.format_specifier = format;
+			if (!error.empty()) {
+				throw InvalidInputException("Could not parse DATEFORMAT: %s", error.c_str());
+			}
+			bind_data->has_date_format = true;
+		} else if (loption == "timestamp_format" || loption == "timestampformat") {
+			string format = ParseString(set);
+			string error = StrTimeFormat::ParseFormatSpecifier(format, bind_data->timestamp_format);
+			bind_data->timestamp_format.format_specifier = format;
+			if (!error.empty()) {
+				throw InvalidInputException("Could not parse TIMESTAMPFORMAT: %s", error.c_str());
+			}
+			bind_data->has_timestamp_format = true;
 		} else {
 			throw NotImplementedException("Unrecognized option for CSV: %s", option.first.c_str());
 		}
@@ -376,7 +400,7 @@ struct LocalReadCSVData : public LocalFunctionData {
 
 struct GlobalWriteCSVData : public GlobalFunctionData {
 	GlobalWriteCSVData(FileSystem &fs, string file_path) : fs(fs) {
-		handle = fs.OpenFile(file_path, FileFlags::WRITE | FileFlags::FILE_CREATE_NEW, FileLockType::WRITE_LOCK);
+		handle = fs.OpenFile(file_path, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE_NEW, FileLockType::WRITE_LOCK);
 	}
 
 	void WriteData(const_data_ptr_t data, idx_t size) {
@@ -513,6 +537,10 @@ unique_ptr<GlobalFunctionData> read_csv_initialize(ClientContext &context, Funct
 	options.skip_rows = 0;
 	options.num_cols = bind_data.sql_types.size();
 	options.force_not_null = bind_data.force_not_null;
+	options.has_date_format = bind_data.has_date_format;
+	options.date_format = move(bind_data.date_format);
+	options.has_timestamp_format = bind_data.has_timestamp_format;
+	options.timestamp_format = move(bind_data.timestamp_format);
 
 	global_data->csv_reader = make_unique<BufferedCSVReader>(context, move(options), bind_data.sql_types);
 	return move(global_data);
diff --git a/src/function/table/range.cpp b/src/function/table/range.cpp
index 892436616a2c..a81a25f41a5d 100644
--- a/src/function/table/range.cpp
+++ b/src/function/table/range.cpp
@@ -14,7 +14,7 @@ struct RangeFunctionData : public TableFunctionData {
 	idx_t current_idx;
 };
 
-static unique_ptr<FunctionData> range_function_bind(ClientContext &context, vector<Value> inputs,
+static unique_ptr<FunctionData> range_function_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
                                               vector<SQLType> &return_types, vector<string> &names) {
 	auto result = make_unique<RangeFunctionData>();
 	if (inputs.size() < 2) {
diff --git a/src/function/table/read_csv.cpp b/src/function/table/read_csv.cpp
index b5a07637e0b8..f5e6723ee56c 100644
--- a/src/function/table/read_csv.cpp
+++ b/src/function/table/read_csv.cpp
@@ -16,35 +16,82 @@ struct ReadCSVFunctionData : public TableFunctionData {
 	unique_ptr<BufferedCSVReader> csv_reader;
 };
 
-static unique_ptr<FunctionData> read_csv_bind(ClientContext &context, vector<Value> inputs,
+static unique_ptr<FunctionData> read_csv_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
                                               vector<SQLType> &return_types, vector<string> &names) {
 
 	if (!context.db.config.enable_copy) {
 		throw Exception("read_csv is disabled by configuration");
 	}
-	for (auto &val : inputs[2].struct_value) {
-		names.push_back(val.first);
-		if (val.second.type != TypeId::VARCHAR) {
-			throw BinderException("read_csv requires a type specification as string");
-		}
-		return_types.push_back(TransformStringToSQLType(val.second.str_value.c_str()));
-	}
-	if (names.size() == 0) {
-		throw BinderException("read_csv requires at least a single column as input!");
-	}
 	auto result = make_unique<ReadCSVFunctionData>();
 
 	BufferedCSVReaderOptions options;
-	options.auto_detect = false;
 	options.file_path = inputs[0].str_value;
+	options.auto_detect = true;
 	options.header = false;
-	options.delimiter = inputs[1].str_value;
-
-	result->csv_reader = make_unique<BufferedCSVReader>(context, move(options), return_types);
+	options.delimiter = ",";
+	options.quote = "\"";
+
+	for(auto &kv : named_parameters) {
+		if (kv.first == "sep") {
+			options.auto_detect = false;
+			options.delimiter = kv.second.str_value;
+		} else if (kv.first == "header") {
+			options.auto_detect = false;
+			options.header = kv.second.value_.boolean;
+		} else if (kv.first == "quote") {
+			options.auto_detect = false;
+			options.quote = kv.second.str_value;
+		} else if (kv.first == "escape") {
+			options.auto_detect = false;
+			options.escape = kv.second.str_value;
+		} else if (kv.first == "nullstr") {
+			options.auto_detect = false;
+			options.null_str = kv.second.str_value;
+		} else if (kv.first == "dateformat") {
+			options.has_date_format = true;
+			options.date_format.format_specifier = kv.second.str_value;
+			string error = StrTimeFormat::ParseFormatSpecifier(kv.second.str_value, options.date_format);
+			if (!error.empty()) {
+				throw InvalidInputException("Could not parse DATEFORMAT: %s", error.c_str());
+			}
+		} else if (kv.first == "timestampformat") {
+			options.has_timestamp_format = true;
+			options.timestamp_format.format_specifier = kv.second.str_value;
+			string error = StrTimeFormat::ParseFormatSpecifier(kv.second.str_value, options.timestamp_format);
+			if (!error.empty()) {
+				throw InvalidInputException("Could not parse TIMESTAMPFORMAT: %s", error.c_str());
+			}
+		} else if (kv.first == "columns") {
+			options.auto_detect = false;
+			for (auto &val : kv.second.struct_value) {
+				names.push_back(val.first);
+				if (val.second.type != TypeId::VARCHAR) {
+					throw BinderException("read_csv requires a type specification as string");
+				}
+				return_types.push_back(TransformStringToSQLType(val.second.str_value.c_str()));
+			}
+			if (names.size() == 0) {
+				throw BinderException("read_csv requires at least a single column as input!");
+			}
+		}
+	}
+	if (!options.auto_detect && return_types.size() == 0) {
+		throw BinderException("Specifying CSV options requires columns to be specified as well (for now)");
+	}
+	if (return_types.size() > 0) {
+		// return types specified: no auto detect
+		result->csv_reader = make_unique<BufferedCSVReader>(context, move(options), return_types);
+	} else {
+		// auto detect options
+		result->csv_reader = make_unique<BufferedCSVReader>(context, move(options));
+
+		return_types.assign(result->csv_reader->sql_types.begin(), result->csv_reader->sql_types.end());
+		names.assign(result->csv_reader->col_names.begin(), result->csv_reader->col_names.end());
+	}
 	return move(result);
 }
 
-static unique_ptr<FunctionData> read_csv_auto_bind(ClientContext &context, vector<Value> inputs,
+static unique_ptr<FunctionData> read_csv_auto_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
                                                    vector<SQLType> &return_types, vector<string> &names) {
 
 	if (!context.db.config.enable_copy) {
@@ -71,9 +118,18 @@ static void read_csv_info(ClientContext &context, vector<Value> &input, DataChun
 
 void ReadCSVTableFunction::RegisterFunction(BuiltinFunctions &set) {
 	TableFunctionSet read_csv("read_csv");
-	read_csv.AddFunction(
-	    TableFunction({SQLType::VARCHAR, SQLType::VARCHAR, SQLType::STRUCT}, read_csv_bind, read_csv_info, nullptr));
-	read_csv.AddFunction(TableFunction({SQLType::VARCHAR}, read_csv_auto_bind, read_csv_info, nullptr));
+
+	TableFunction read_csv_function = TableFunction({SQLType::VARCHAR}, read_csv_bind, read_csv_info, nullptr);
+	read_csv_function.named_parameters["sep"] = SQLType::VARCHAR;
+	read_csv_function.named_parameters["quote"] = SQLType::VARCHAR;
+	read_csv_function.named_parameters["escape"] = SQLType::VARCHAR;
+	read_csv_function.named_parameters["nullstr"] = SQLType::VARCHAR;
+	read_csv_function.named_parameters["columns"] = SQLType::STRUCT;
+	read_csv_function.named_parameters["header"] = SQLType::BOOLEAN;
+	read_csv_function.named_parameters["dateformat"] = SQLType::VARCHAR;
+	read_csv_function.named_parameters["timestampformat"] = SQLType::VARCHAR;
+
+	read_csv.AddFunction(move(read_csv_function));
 
 	set.AddFunction(read_csv);
 	set.AddFunction(TableFunction("read_csv_auto", {SQLType::VARCHAR}, read_csv_auto_bind, read_csv_info, nullptr));
diff --git a/src/function/table/repeat.cpp b/src/function/table/repeat.cpp
index 970d066e339e..bf49c523f0e9 100644
--- a/src/function/table/repeat.cpp
+++ b/src/function/table/repeat.cpp
@@ -12,7 +12,7 @@ struct RepeatFunctionData : public TableFunctionData {
 	idx_t target_count;
 };
 
-static unique_ptr<FunctionData> repeat_bind(ClientContext &context, vector<Value> inputs,
+static unique_ptr<FunctionData> repeat_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
                                               vector<SQLType> &return_types, vector<string> &names) {
 	// the repeat function returns the type of the first argument
 	return_types.push_back(inputs[0].GetSQLType());
diff --git a/src/function/table/sqlite/pragma_collations.cpp b/src/function/table/sqlite/pragma_collations.cpp
index d36d398995a4..5284e3307465 100644
--- a/src/function/table/sqlite/pragma_collations.cpp
+++ b/src/function/table/sqlite/pragma_collations.cpp
@@ -19,7 +19,7 @@ struct PragmaCollateData : public TableFunctionData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> pragma_collate_bind(ClientContext &context, vector<Value> inputs,
+static unique_ptr<FunctionData> pragma_collate_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
                                                     vector<SQLType> &return_types, vector<string> &names) {
 	names.push_back("collname");
 	return_types.push_back(SQLType::VARCHAR);
diff --git a/src/function/table/sqlite/pragma_database_list.cpp b/src/function/table/sqlite/pragma_database_list.cpp
index 593d8e317201..4bd353273154 100644
--- a/src/function/table/sqlite/pragma_database_list.cpp
+++ b/src/function/table/sqlite/pragma_database_list.cpp
@@ -13,7 +13,7 @@ struct PragmaDatabaseListData : public TableFunctionData {
 	bool finished;
 };
 
-static unique_ptr<FunctionData> pragma_database_list_bind(ClientContext &context, vector<Value> inputs,
+static unique_ptr<FunctionData> pragma_database_list_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
                                                    vector<SQLType> &return_types, vector<string> &names) {
 	names.push_back("seq");
 	return_types.push_back(SQLType::INTEGER);
diff --git a/src/function/table/sqlite/pragma_table_info.cpp b/src/function/table/sqlite/pragma_table_info.cpp
index fa4a63087f52..8aff1609bc28 100644
--- a/src/function/table/sqlite/pragma_table_info.cpp
+++ b/src/function/table/sqlite/pragma_table_info.cpp
@@ -19,7 +19,7 @@ struct PragmaTableFunctionData : public TableFunctionData {
 	idx_t offset;
 };
 
-static unique_ptr<FunctionData> pragma_table_info_bind(ClientContext &context, vector<Value> inputs,
+static unique_ptr<FunctionData> pragma_table_info_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
                                                        vector<SQLType> &return_types, vector<string> &names) {
 	names.push_back("cid");
 	return_types.push_back(SQLType::INTEGER);
diff --git a/src/function/table/sqlite/sqlite_master.cpp b/src/function/table/sqlite/sqlite_master.cpp
index f448fbb6a89a..eab40a6e81ca 100644
--- a/src/function/table/sqlite/sqlite_master.cpp
+++ b/src/function/table/sqlite/sqlite_master.cpp
@@ -45,7 +45,7 @@ string GenerateQuery(CatalogEntry *entry) {
 	}
 }
 
-static unique_ptr<FunctionData> sqlite_master_bind(ClientContext &context, vector<Value> inputs,
+static unique_ptr<FunctionData> sqlite_master_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
                                                    vector<SQLType> &return_types, vector<string> &names) {
 	names.push_back("type");
 	return_types.push_back(SQLType::VARCHAR);
diff --git a/src/function/table/version/pragma_version.cpp b/src/function/table/version/pragma_version.cpp
index 6e4dd266050c..475f720299a9 100644
--- a/src/function/table/version/pragma_version.cpp
+++ b/src/function/table/version/pragma_version.cpp
@@ -9,7 +9,7 @@ struct PragmaVersionData : public TableFunctionData {
 	bool done;
 };
 
-static unique_ptr<FunctionData> pragma_version_bind(ClientContext &context, vector<Value> inputs,
+static unique_ptr<FunctionData> pragma_version_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
                                                     vector<SQLType> &return_types, vector<string> &names) {
 	names.push_back("library_version");
 	return_types.push_back(SQLType::VARCHAR);
diff --git a/src/include/duckdb/common/file_system.hpp b/src/include/duckdb/common/file_system.hpp
index 0cde62872420..9fb17c48d54b 100644
--- a/src/include/duckdb/common/file_system.hpp
+++ b/src/include/duckdb/common/file_system.hpp
@@ -47,17 +47,17 @@ enum class FileLockType : uint8_t { NO_LOCK = 0, READ_LOCK = 1, WRITE_LOCK = 2 }
 class FileFlags {
 public:
 	//! Open file with read access
-	static constexpr uint8_t READ = 1 << 0;
+	static constexpr uint8_t FILE_FLAGS_READ = 1 << 0;
 	//! Open file with read/write access
-	static constexpr uint8_t WRITE = 1 << 1;
+	static constexpr uint8_t FILE_FLAGS_WRITE = 1 << 1;
 	//! Use direct IO when reading/writing to the file
-	static constexpr uint8_t DIRECT_IO = 1 << 2;
+	static constexpr uint8_t FILE_FLAGS_DIRECT_IO = 1 << 2;
 	//! Create file if not exists, can only be used together with WRITE
-	static constexpr uint8_t FILE_CREATE = 1 << 3;
+	static constexpr uint8_t FILE_FLAGS_FILE_CREATE = 1 << 3;
 	//! Always create a new file. If a file exists, the file is truncated. Cannot be used together with CREATE.
-	static constexpr uint8_t FILE_CREATE_NEW = 1 << 4;
+	static constexpr uint8_t FILE_FLAGS_FILE_CREATE_NEW = 1 << 4;
 	//! Open file in append mode
-	static constexpr uint8_t APPEND = 1 << 5;
+	static constexpr uint8_t FILE_FLAGS_APPEND = 1 << 5;
 };
 
 class FileSystem {
diff --git a/src/include/duckdb/common/serializer/buffered_file_writer.hpp b/src/include/duckdb/common/serializer/buffered_file_writer.hpp
index 118c500c8a04..dcba725a7a6a 100644
--- a/src/include/duckdb/common/serializer/buffered_file_writer.hpp
+++ b/src/include/duckdb/common/serializer/buffered_file_writer.hpp
@@ -19,7 +19,7 @@ class BufferedFileWriter : public Serializer {
 public:
 	//! Serializes to a buffer allocated by the serializer, will expand when
 	//! writing past the initial threshold
-	BufferedFileWriter(FileSystem &fs, string path, uint8_t open_flags = FileFlags::WRITE | FileFlags::FILE_CREATE);
+	BufferedFileWriter(FileSystem &fs, string path, uint8_t open_flags = FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE);
 
 	FileSystem &fs;
 	unique_ptr<data_t[]> data;
diff --git a/src/include/duckdb/common/types/date.hpp b/src/include/duckdb/common/types/date.hpp
index 2c01da3ca388..683b752d4cef 100644
--- a/src/include/duckdb/common/types/date.hpp
+++ b/src/include/duckdb/common/types/date.hpp
@@ -15,6 +15,11 @@ namespace duckdb {
 //! The Date class is a static class that holds helper functions for the Date
 //! type.
 class Date {
+public:
+	static string_t MonthNames[12];
+	static string_t MonthNamesAbbreviated[12];
+	static string_t DayNames[7];
+	static string_t DayNamesAbbreviated[7];
 public:
 	//! Convert a string in the format "YYYY-MM-DD" to a date object
 	static date_t FromString(string str, bool strict = false);
@@ -22,6 +27,8 @@ class Date {
 	static date_t FromCString(const char *str, bool strict = false);
 	//! Convert a date object to a string in the format "YYYY-MM-DD"
 	static string ToString(date_t date);
+	//! Try to convert text in a buffer to a date; returns true if parsing was successful
+	static bool TryConvertDate(const char *buf, idx_t &pos, date_t &result, bool strict = false);
 
 	//! Create a string "YYYY-MM-DD" from a specified (year, month, day)
 	//! combination
@@ -53,8 +60,17 @@ class Date {
 	static int32_t ExtractISODayOfTheWeek(date_t date);
 	//! Extract the day of the year
 	static int32_t ExtractDayOfTheYear(date_t date);
-	//! Extract the week number
-	static int32_t ExtractWeekNumber(date_t date);
+	//! Extract the ISO week number
+	//! ISO weeks start on Monday and the first week of a year
+	//! contains January 4 of that year.
+	//! In the ISO week-numbering system, it is possible for early-January dates
+	//! to be part of the 52nd or 53rd week of the previous year.
+	static int32_t ExtractISOWeekNumber(date_t date);
+	//! Extract the week number as Python handles it.
+	//! Either Monday or Sunday is the first day of the week,
+	//! and any date before the first Monday/Sunday returns week 0
+	//! This is a bit more consistent because week numbers in a year are always incrementing
+	static int32_t ExtractWeekNumberRegular(date_t date, bool monday_first = true);
 	//! Returns the date of the monday of the current week.
 	static date_t GetMondayOfCurrentWeek(date_t date);
 };
diff --git a/src/include/duckdb/common/types/numeric_helper.hpp b/src/include/duckdb/common/types/numeric_helper.hpp
new file mode 100644
index 000000000000..d0cf37c5d5c7
--- /dev/null
+++ b/src/include/duckdb/common/types/numeric_helper.hpp
@@ -0,0 +1,70 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// duckdb/common/types/numeric_helper.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include "duckdb/common/common.hpp"
+#include "duckdb/common/types/string_type.hpp"
+#include "duckdb/common/types/vector.hpp"
+#include "fmt/format.h"
+
+namespace duckdb {
+
+//! NumericHelper is a static class that holds helper functions for integers/doubles
+class NumericHelper {
+public:
+	template <class T> static int UnsignedLength(T value);
+	template <class SIGNED, class UNSIGNED> static int SignedLength(SIGNED value) {
+		int sign = -(value < 0);
+		UNSIGNED unsigned_value = (value ^ sign) - sign;
+		return UnsignedLength(unsigned_value);
+	}
+
+	// Formats value in reverse and returns a pointer to the beginning.
+	template <class T> static char *FormatUnsigned(T value, char *ptr) {
+		while (value >= 100) {
+			// Integer division is slow so do it for a group of two digits instead
+			// of for every digit. The idea comes from the talk by Alexandrescu
+			// "Three Optimization Tips for C++". See speed-test for a comparison.
+			auto index = static_cast<unsigned>((value % 100) * 2);
+			value /= 100;
+			*--ptr = duckdb_fmt::internal::data::digits[index + 1];
+			*--ptr = duckdb_fmt::internal::data::digits[index];
+		}
+		if (value < 10) {
+			*--ptr = static_cast<char>('0' + value);
+			return ptr;
+		}
+		auto index = static_cast<unsigned>(value * 2);
+		*--ptr = duckdb_fmt::internal::data::digits[index + 1];
+		*--ptr = duckdb_fmt::internal::data::digits[index];
+		return ptr;
+	}
+
+	template <class SIGNED, class UNSIGNED> static string_t FormatSigned(SIGNED value, Vector &vector) {
+		int sign = -(value < 0);
+		UNSIGNED unsigned_value = (value ^ sign) - sign;
+		int length = UnsignedLength<UNSIGNED>(unsigned_value) - sign;
+		string_t result = StringVector::EmptyString(vector, length);
+		auto dataptr = result.GetData();
+		auto endptr = dataptr + length;
+		endptr = FormatUnsigned(unsigned_value, endptr);
+		if (sign) {
+			*--endptr = '-';
+		}
+		result.Finalize();
+		return result;
+	}
+};
+
+template <> int NumericHelper::UnsignedLength(uint8_t value);
+template <> int NumericHelper::UnsignedLength(uint16_t value);
+template <> int NumericHelper::UnsignedLength(uint32_t value);
+template <> int NumericHelper::UnsignedLength(uint64_t value);
+
+}
diff --git a/src/include/duckdb/common/types/time.hpp b/src/include/duckdb/common/types/time.hpp
index f0064698a47f..0542894a9484 100644
--- a/src/include/duckdb/common/types/time.hpp
+++ b/src/include/duckdb/common/types/time.hpp
@@ -12,13 +12,14 @@
 
 namespace duckdb {
 
-//! The Date class is a static class that holds helper functions for the Time
+//! The Time class is a static class that holds helper functions for the Time
 //! type.
 class Time {
 public:
 	//! Convert a string in the format "hh:mm:ss" to a time object
 	static dtime_t FromString(string str, bool strict = false);
 	static dtime_t FromCString(const char *buf, bool strict = false);
+	static bool TryConvertTime(const char *buf, idx_t &pos, dtime_t &result, bool strict = false);
 
 	//! Convert a time object to a string in the format "hh:mm:ss"
 	static string ToString(dtime_t time);
diff --git a/src/include/duckdb/common/types/timestamp.hpp b/src/include/duckdb/common/types/timestamp.hpp
index 3e3196dd8776..51cd59e687c0 100644
--- a/src/include/duckdb/common/types/timestamp.hpp
+++ b/src/include/duckdb/common/types/timestamp.hpp
@@ -27,7 +27,8 @@ class Timestamp {
 public:
 	//! Convert a string in the format "YYYY-MM-DD hh:mm:ss" to a timestamp object
 	static timestamp_t FromString(string str);
-	//! Convert a date object to a string in the format "YYYY-MM-DDThh:mm:ssZ"
+	static timestamp_t FromCString(const char *str, idx_t len);
+	//! Convert a date object to a string in the format "YYYY-MM-DD hh:mm:ss"
 	static string ToString(timestamp_t timestamp);
 
 	static date_t GetDate(timestamp_t timestamp);
diff --git a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp
index 29277ebc3595..388162d386fd 100644
--- a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp
+++ b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp
@@ -10,6 +10,8 @@
 
 #include "duckdb/execution/physical_operator.hpp"
 #include "duckdb/parser/parsed_data/copy_info.hpp"
+#include "duckdb/function/scalar/strftime.hpp"
+
 #include <sstream>
 
 #define SAMPLE_CHUNK_SIZE 100
@@ -20,6 +22,7 @@
 
 namespace duckdb {
 struct CopyInfo;
+struct StrpTimeFormat;
 
 //! The shifts array allows for linear searching of multi-byte values. For each position, it determines the next
 //! position given that we encounter a byte with the given value.
@@ -65,6 +68,14 @@ struct BufferedCSVReaderOptions  {
     string null_str;
     //! True, if column with that index must skip null check
     vector<bool> force_not_null;
+	//! The date format to use (if any is specified)
+	StrpTimeFormat date_format;
+	//! Whether or not a date format is specified
+	bool has_date_format = false;
+	//! The timestamp format to use (if any is specified)
+	StrpTimeFormat timestamp_format;
+	//! Whether or not a timestamp format is specified
+	bool has_timestamp_format = false;
 };
 
 enum class QuoteRule : uint8_t { QUOTES_RFC = 0, QUOTES_OTHER = 1, NO_QUOTES = 2 };
@@ -86,7 +97,7 @@ class BufferedCSVReader {
 	BufferedCSVReader(ClientContext &context, BufferedCSVReaderOptions options, vector<SQLType> requested_types = vector<SQLType>());
 	BufferedCSVReader(BufferedCSVReaderOptions options, vector<SQLType> requested_types, unique_ptr<std::istream> source);
 
-    BufferedCSVReaderOptions options;
+	BufferedCSVReaderOptions options;
 	vector<SQLType> sql_types;
 	vector<string> col_names;
 	unique_ptr<std::istream> source;
@@ -129,6 +140,8 @@ class BufferedCSVReader {
 	void ParseCSV(ParserMode mode, DataChunk &insert_chunk = DUMMY_CHUNK);
 	//! Sniffs CSV dialect and determines skip rows, header row, column types and column names
 	vector<SQLType> SniffCSV(vector<SQLType> requested_types);
+	//! Try to cast a string value to the specified sql type
+	bool TryCastValue(Value value, SQLType sql_type);
 	//! Skips header rows and skip_rows in the input stream
 	void SkipHeader();
 	//! Jumps back to the beginning of input stream and resets necessary internal states
diff --git a/src/include/duckdb/function/scalar/date_functions.hpp b/src/include/duckdb/function/scalar/date_functions.hpp
index 617c6711ac59..d972db8758b4 100644
--- a/src/include/duckdb/function/scalar/date_functions.hpp
+++ b/src/include/duckdb/function/scalar/date_functions.hpp
@@ -41,4 +41,12 @@ struct EpochFun {
 	static void RegisterFunction(BuiltinFunctions &set);
 };
 
+struct StrfTimeFun {
+	static void RegisterFunction(BuiltinFunctions &set);
+};
+
+struct StrpTimeFun {
+	static void RegisterFunction(BuiltinFunctions &set);
+};
+
 } // namespace duckdb
diff --git a/src/include/duckdb/function/scalar/strftime.hpp b/src/include/duckdb/function/scalar/strftime.hpp
new file mode 100644
index 000000000000..d13a0ec3ef66
--- /dev/null
+++ b/src/include/duckdb/function/scalar/strftime.hpp
@@ -0,0 +1,106 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// duckdb/function/scalar/strftime.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include "duckdb/function/scalar_function.hpp"
+#include "duckdb/common/vector.hpp"
+
+namespace duckdb {
+
+enum class StrTimeSpecifier : uint8_t {
+	ABBREVIATED_WEEKDAY_NAME = 0,          // %a - Abbreviated weekday name. (Sun, Mon, ...)
+	FULL_WEEKDAY_NAME = 1,                 // %A Full weekday name. (Sunday, Monday, ...)
+	WEEKDAY_DECIMAL = 2,                   // %w - Weekday as a decimal number. (0, 1, ..., 6)
+	DAY_OF_MONTH_PADDED = 3,               // %d - Day of the month as a zero-padded decimal. (01, 02, ..., 31)
+	DAY_OF_MONTH = 4,                      // %-d - Day of the month as a decimal number. (1, 2, ..., 30)
+	ABBREVIATED_MONTH_NAME = 5,            // %b - Abbreviated month name. (Jan, Feb, ..., Dec)
+	FULL_MONTH_NAME = 6,                   // %B - Full month name. (January, February, ...)
+	MONTH_DECIMAL_PADDED = 7,              // %m - Month as a zero-padded decimal number. (01, 02, ..., 12)
+	MONTH_DECIMAL = 8,                     // %-m - Month as a decimal number. (1, 2, ..., 12)
+	YEAR_WITHOUT_CENTURY_PADDED = 9,       // %y - Year without century as a zero-padded decimal number. (00, 01, ..., 99)
+	YEAR_WITHOUT_CENTURY = 10,             // %-y - Year without century as a decimal number. (0, 1, ..., 99)
+	YEAR_DECIMAL = 11,                     // %Y - Year with century as a decimal number. (2013, 2019 etc.)
+	HOUR_24_PADDED = 12,                   // %H - Hour (24-hour clock) as a zero-padded decimal number. (00, 01, ..., 23)
+	HOUR_24_DECIMAL = 13,                  // %-H - Hour (24-hour clock) as a decimal number. (0, 1, ..., 23)
+	HOUR_12_PADDED = 14,                   // %I - Hour (12-hour clock) as a zero-padded decimal number. (01, 02, ..., 12)
+	HOUR_12_DECIMAL = 15,                  // %-I - Hour (12-hour clock) as a decimal number. (1, 2, ... 12)
+	AM_PM = 16,                            // %p - Locales AM or PM. (AM, PM)
+	MINUTE_PADDED = 17,                    // %M - Minute as a zero-padded decimal number. (00, 01, ..., 59)
+	MINUTE_DECIMAL = 18,                   // %-M - Minute as a decimal number. (0, 1, ..., 59)
+	SECOND_PADDED = 19,                    // %S - Second as a zero-padded decimal number. (00, 01, ..., 59)
+	SECOND_DECIMAL = 20,                   // %-S - Second as a decimal number. (0, 1, ..., 59)
+	MICROSECOND_PADDED = 21,               // %f - Microsecond as a decimal number, zero-padded on the left. (000000 - 999999)
+	UTC_OFFSET = 22,                       // %z - UTC offset in the form +HHMM or -HHMM. ( )
+	TZ_NAME = 23,                          // %Z - Time zone name. ( )
+	DAY_OF_YEAR_PADDED = 24,               // %j - Day of the year as a zero-padded decimal number. (001, 002, ..., 366)
+	DAY_OF_YEAR_DECIMAL = 25,              // %-j - Day of the year as a decimal number. (1, 2, ..., 366)
+	WEEK_NUMBER_PADDED_SUN_FIRST = 26,     // %U - Week number of the year (Sunday as the first day of the week). All days in a new year preceding the first Sunday are considered to be in week 0. (00, 01, ..., 53)
+	WEEK_NUMBER_PADDED_MON_FIRST = 27,     // %W - Week number of the year (Monday as the first day of the week). All days in a new year preceding the first Monday are considered to be in week 0. (00, 01, ..., 53)
+	LOCALE_APPROPRIATE_DATE_AND_TIME = 28, // %c - Locales appropriate date and time representation. (Mon Sep 30 07:06:05 2013)
+	LOCALE_APPROPRIATE_DATE = 29,          // %x - Locales appropriate date representation. (09/30/13)
+	LOCALE_APPROPRIATE_TIME = 30           // %X - Locales appropriate time representation. (07:06:05)
+};
+
+struct StrTimeFormat {
+public:
+	static string ParseFormatSpecifier(string format_string, StrTimeFormat &format);
+protected:
+	//! The format specifiers
+	vector<StrTimeSpecifier> specifiers;
+	//! The literals that appear in between the format specifiers
+	//! The following must hold: literals.size() = specifiers.size() + 1
+	//! Format is literals[0], specifiers[0], literals[1], ..., specifiers[n - 1], literals[n]
+	vector<string> literals;
+	//! The constant size that appears in the format string
+	idx_t constant_size;
+	//! Whether or not the specifier is a numeric specifier (i.e. is parsed as a number)
+	vector<bool> is_numeric;
+	void AddLiteral(string literal);
+	virtual void AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier);
+};
+
+struct StrfTimeFormat : public StrTimeFormat {
+	idx_t GetLength(date_t date, time_t time);
+
+	void FormatString(date_t date, int32_t data[7], char *target);
+	void FormatString(date_t date, time_t time, char *target);
+protected:
+	//! The variable-length specifiers. To determine total string size, these need to be checked.
+	vector<StrTimeSpecifier> var_length_specifiers;
+	//! Whether or not the current specifier is a special "date" specifier (i.e. one that requires a date_t object to generate)
+	vector<bool> is_date_specifier;
+
+	void AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier) override;
+	static idx_t GetSpecifierLength(StrTimeSpecifier specifier, date_t date, time_t time);
+	char* WriteString(char *target, string_t &str);
+	char *Write2(char *target, uint8_t value);
+	char* WritePadded2(char *target, int32_t value);
+	char *WritePadded3(char *target, uint32_t value);
+	char* WritePadded(char *target, int32_t value, int32_t padding);
+	bool IsDateSpecifier(StrTimeSpecifier specifier);
+	char* WriteDateSpecifier(StrTimeSpecifier specifier, date_t date, char *target);
+	char* WriteStandardSpecifier(StrTimeSpecifier specifier, int32_t data[], char *target);
+};
+
+struct StrpTimeFormat : public StrTimeFormat {
+public:
+	//! The full format specifier, for error messages
+	string format_specifier;
+
+	bool Parse(string_t str, int32_t result_data[], string &error_message, idx_t &error_position);
+	date_t ParseDate(string_t str);
+	timestamp_t ParseTimestamp(string_t str);
+protected:
+	string FormatStrpTimeError(string input, idx_t position);
+	void AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier);
+	bool IsNumericSpecifier(StrTimeSpecifier specifier);
+	int32_t TryParseCollection(const char *data, idx_t &pos, idx_t size, string_t collection[], idx_t collection_count);
+};
+
+}
diff --git a/src/include/duckdb/function/table_function.hpp b/src/include/duckdb/function/table_function.hpp
index 6609db81c319..50326ee7f644 100644
--- a/src/include/duckdb/function/table_function.hpp
+++ b/src/include/duckdb/function/table_function.hpp
@@ -9,11 +9,12 @@
 #pragma once
 
 #include "duckdb/function/function.hpp"
+#include "duckdb/common/unordered_map.hpp"
 
 namespace duckdb {
 
 //! Function used for determining the return type of a table producing function
-typedef unique_ptr<FunctionData> (*table_function_bind_t)(ClientContext &context, vector<Value> inputs,
+typedef unique_ptr<FunctionData> (*table_function_bind_t)(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
                                                           vector<SQLType> &return_types, vector<string> &names);
 //! Type used for table-returning function
 typedef void (*table_function_t)(ClientContext &context, vector<Value> &input, DataChunk &output,
@@ -39,6 +40,8 @@ class TableFunction : public SimpleFunction {
 	table_function_t function;
 	//! Final function pointer
 	table_function_final_t final;
+	//! Supported named parameters by the function
+	unordered_map<string, SQLType> named_parameters;
 	//! Whether or not the table function supports projection
 	bool supports_projection;
 
diff --git a/src/main/relation/read_csv_relation.cpp b/src/main/relation/read_csv_relation.cpp
index a938abef159a..5dd933adceb2 100644
--- a/src/main/relation/read_csv_relation.cpp
+++ b/src/main/relation/read_csv_relation.cpp
@@ -3,6 +3,8 @@
 #include "duckdb/parser/tableref/basetableref.hpp"
 #include "duckdb/parser/query_node/select_node.hpp"
 #include "duckdb/parser/expression/star_expression.hpp"
+#include "duckdb/parser/expression/columnref_expression.hpp"
+#include "duckdb/parser/expression/comparison_expression.hpp"
 #include "duckdb/parser/expression/constant_expression.hpp"
 #include "duckdb/parser/expression/function_expression.hpp"
 #include "duckdb/common/string_util.hpp"
@@ -31,13 +33,13 @@ unique_ptr<TableRef> ReadCSVRelation::GetTableRef() {
 	vector<unique_ptr<ParsedExpression>> children;
 	// CSV file
 	children.push_back(make_unique<ConstantExpression>(SQLType::VARCHAR, Value(csv_file)));
-	children.push_back(make_unique<ConstantExpression>(SQLType::VARCHAR, Value(",")));
 	// parameters
 	child_list_t<Value> column_names;
 	for (idx_t i = 0; i < columns.size(); i++) {
 		column_names.push_back(make_pair(columns[i].name, Value(SQLTypeToString(columns[i].type))));
 	}
-	children.push_back(make_unique<ConstantExpression>(SQLType::STRUCT, Value::STRUCT(move(column_names))));
+	auto colnames = make_unique<ConstantExpression>(SQLType::STRUCT, Value::STRUCT(move(column_names)));
+	children.push_back(make_unique<ComparisonExpression>(ExpressionType::COMPARE_EQUAL, make_unique<ColumnRefExpression>("columns"), move(colnames)));
 	table_ref->function = make_unique<FunctionExpression>("read_csv", children);
 	return move(table_ref);
 }
diff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp
index a4512f6da0ed..133bfd4a2047 100644
--- a/src/planner/binder/tableref/bind_table_function.cpp
+++ b/src/planner/binder/tableref/bind_table_function.cpp
@@ -2,6 +2,8 @@
 #include "duckdb/parser/expression/function_expression.hpp"
 #include "duckdb/parser/tableref/table_function_ref.hpp"
 #include "duckdb/planner/binder.hpp"
+#include "duckdb/parser/expression/columnref_expression.hpp"
+#include "duckdb/parser/expression/comparison_expression.hpp"
 #include "duckdb/planner/expression_binder/constant_binder.hpp"
 #include "duckdb/planner/tableref/bound_table_function.hpp"
 #include "duckdb/execution/expression_executor.hpp"
@@ -19,15 +21,36 @@ unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {
 	// evalate the input parameters to the function
 	vector<SQLType> arguments;
 	vector<Value> parameters;
+	unordered_map<string, Value> named_parameters;
 	for (auto &child : fexpr->children) {
+		string parameter_name;
+
 		ConstantBinder binder(*this, context, "TABLE FUNCTION parameter");
+		if (child->type == ExpressionType::COMPARE_EQUAL) {
+			// comparison, check if the LHS is a columnref
+			auto &comp = (ComparisonExpression&) *child;
+			if (comp.left->type == ExpressionType::COLUMN_REF) {
+				auto &colref = (ColumnRefExpression &) *comp.left;
+				if (colref.table_name.empty()) {
+					parameter_name = colref.column_name;
+					child = move(comp.right);
+				}
+			}
+		}
 		SQLType sql_type;
 		auto expr = binder.Bind(child, &sql_type);
 		auto constant = ExpressionExecutor::EvaluateScalar(*expr);
 		constant.SetSQLType(sql_type);
-
-		arguments.push_back(sql_type);
-		parameters.push_back(move(constant));
+		if (parameter_name.empty()) {
+			// unnamed parameter
+			if (named_parameters.size() > 0) {
+				throw BinderException("Unnamed parameters cannot come after named parameters");
+			}
+			arguments.push_back(sql_type);
+			parameters.push_back(move(constant));
+		} else {
+			named_parameters[parameter_name] = move(constant);
+		}
 	}
 	// fetch the function from the catalog
 	auto function =
@@ -37,6 +60,15 @@ unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {
 	idx_t best_function_idx = Function::BindFunction(function->name, function->functions, arguments);
 	auto &table_function = function->functions[best_function_idx];
 
+	// now check the named parameters
+	for(auto &kv : named_parameters) {
+		auto entry = table_function.named_parameters.find(kv.first);
+		if (entry == table_function.named_parameters.end()) {
+			throw BinderException("Invalid named parameter \"%s\" for function %s", kv.first.c_str(), table_function.name.c_str());
+		}
+		kv.second = kv.second.CastAs(kv.second.GetSQLType(), entry->second);
+	}
+
 	// cast the parameters to the type of the function
 	auto result = make_unique<BoundTableFunction>(table_function, bind_index);
 	for(idx_t i = 0; i < arguments.size(); i++) {
@@ -48,7 +80,7 @@ unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {
 	}
 
 	// perform the binding
-	result->bind_data = table_function.bind(context, result->parameters, result->return_types, result->names);
+	result->bind_data = table_function.bind(context, result->parameters, named_parameters, result->return_types, result->names);
 	assert(result->return_types.size() == result->names.size());
 	assert(result->return_types.size() > 0);
 	vector<string> names;
diff --git a/src/storage/buffer_manager.cpp b/src/storage/buffer_manager.cpp
index 3fc6cd151dd9..1cad4e2e6ed7 100644
--- a/src/storage/buffer_manager.cpp
+++ b/src/storage/buffer_manager.cpp
@@ -230,7 +230,7 @@ void BufferManager::WriteTemporaryBuffer(ManagedBuffer &buffer) {
 	// get the path to write to
 	auto path = GetTemporaryPath(buffer.id);
 	// create the file and write the size followed by the buffer contents
-	auto handle = fs.OpenFile(path, FileFlags::WRITE | FileFlags::FILE_CREATE);
+	auto handle = fs.OpenFile(path, FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE);
 	handle->Write(&buffer.size, sizeof(idx_t), 0);
 	buffer.Write(*handle, sizeof(idx_t));
 }
@@ -243,7 +243,7 @@ unique_ptr<BufferHandle> BufferManager::ReadTemporaryBuffer(block_id_t id) {
 	idx_t alloc_size;
 	// open the temporary file and read the size
 	auto path = GetTemporaryPath(id);
-	auto handle = fs.OpenFile(path, FileFlags::READ);
+	auto handle = fs.OpenFile(path, FileFlags::FILE_FLAGS_READ);
 	handle->Read(&alloc_size, sizeof(idx_t), 0);
 	// first evict blocks until we can handle the size
 	while (current_memory + alloc_size > maximum_memory) {
diff --git a/src/storage/single_file_block_manager.cpp b/src/storage/single_file_block_manager.cpp
index 5d83092191ad..7be58861b299 100644
--- a/src/storage/single_file_block_manager.cpp
+++ b/src/storage/single_file_block_manager.cpp
@@ -17,17 +17,17 @@ SingleFileBlockManager::SingleFileBlockManager(FileSystem &fs, string path, bool
 	FileLockType lock;
 	if (read_only) {
 		assert(!create_new);
-		flags = FileFlags::READ;
+		flags = FileFlags::FILE_FLAGS_READ;
 		lock = FileLockType::READ_LOCK;
 	} else {
-		flags = FileFlags::WRITE;
+		flags = FileFlags::FILE_FLAGS_WRITE;
 		lock = FileLockType::WRITE_LOCK;
 		if (create_new) {
-			flags |= FileFlags::FILE_CREATE;
+			flags |= FileFlags::FILE_FLAGS_FILE_CREATE;
 		}
 	}
 	if (use_direct_io) {
-		flags |= FileFlags::DIRECT_IO;
+		flags |= FileFlags::FILE_FLAGS_DIRECT_IO;
 	}
 	// open the RDBMS handle
 	handle = fs.OpenFile(path, flags, lock);
diff --git a/src/storage/write_ahead_log.cpp b/src/storage/write_ahead_log.cpp
index 04429af976db..4a1587af3929 100644
--- a/src/storage/write_ahead_log.cpp
+++ b/src/storage/write_ahead_log.cpp
@@ -13,7 +13,7 @@ WriteAheadLog::WriteAheadLog(DuckDB &database) : initialized(false), database(da
 }
 
 void WriteAheadLog::Initialize(string &path) {
-	writer = make_unique<BufferedFileWriter>(database.GetFileSystem(), path.c_str(), FileFlags::WRITE | FileFlags::FILE_CREATE | FileFlags::APPEND);
+	writer = make_unique<BufferedFileWriter>(database.GetFileSystem(), path.c_str(), FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE | FileFlags::FILE_FLAGS_APPEND);
 	initialized = true;
 }
 
diff --git a/tools/pythonpkg/duckdb_python.cpp b/tools/pythonpkg/duckdb_python.cpp
index 182c6dcb2fa3..7ae1941955be 100644
--- a/tools/pythonpkg/duckdb_python.cpp
+++ b/tools/pythonpkg/duckdb_python.cpp
@@ -112,7 +112,7 @@ struct PandasScanFunction : public TableFunction {
 	PandasScanFunction()
 	    : TableFunction("pandas_scan", {SQLType::VARCHAR}, pandas_scan_bind, pandas_scan_function, nullptr){};
 
-	static unique_ptr<FunctionData> pandas_scan_bind(ClientContext &context, vector<Value> inputs,
+	static unique_ptr<FunctionData> pandas_scan_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
 	                                                 vector<SQLType> &return_types, vector<string> &names) {
 		// Hey, it works (TM)
 		py::handle df((PyObject *)std::stoull(inputs[0].GetValue<string>(), nullptr, 16));
diff --git a/tools/rpkg/src/duckdbr.cpp b/tools/rpkg/src/duckdbr.cpp
index c551a880888b..699ef51c5b42 100644
--- a/tools/rpkg/src/duckdbr.cpp
+++ b/tools/rpkg/src/duckdbr.cpp
@@ -612,7 +612,7 @@ struct DataFrameScanFunction : public TableFunction {
 	DataFrameScanFunction()
 	    : TableFunction("dataframe_scan", {SQLType::VARCHAR}, dataframe_scan_bind, dataframe_scan_function, nullptr){};
 
-	static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> inputs,
+	static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> &inputs, unordered_map<string, Value> &named_parameters,
 	                                                    vector<SQLType> &return_types, vector<string> &names) {
 		// TODO have a better way to pass this pointer
 		SEXP df((SEXP)std::stoull(inputs[0].GetValue<string>(), nullptr, 16));
