{
  "repo": "duckdb/duckdb",
  "pull_number": 11815,
  "instance_id": "duckdb__duckdb-11815",
  "issue_numbers": [
    "1"
  ],
  "base_commit": "0a542716d9da018b230e91ba55fb15b710a1639b",
  "patch": "diff --git a/.github/config/out_of_tree_extensions.cmake b/.github/config/out_of_tree_extensions.cmake\nindex f9b21d795a60..4ba72f2414a9 100644\n--- a/.github/config/out_of_tree_extensions.cmake\n+++ b/.github/config/out_of_tree_extensions.cmake\n@@ -106,6 +106,7 @@ if (NOT WIN32)\n             LOAD_TESTS DONT_LINK\n             GIT_URL https://github.com/duckdb/substrait\n             GIT_TAG 237931391ebc7e6aee7aa81052fa1411f6c4128e\n+            APPLY_PATCHES\n             )\n endif()\n \ndiff --git a/.github/patches/extensions/substrait/pushdown_semi_anti.patch b/.github/patches/extensions/substrait/pushdown_semi_anti.patch\nnew file mode 100644\nindex 000000000000..6c4affbd966f\n--- /dev/null\n+++ b/.github/patches/extensions/substrait/pushdown_semi_anti.patch\n@@ -0,0 +1,17 @@\n+diff --git a/src/to_substrait.cpp b/src/to_substrait.cpp\n+index 90f7a67..f252aa7 100644\n+--- a/src/to_substrait.cpp\n++++ b/src/to_substrait.cpp\n+@@ -864,7 +864,11 @@ substrait::Rel *DuckDBToSubstrait::TransformComparisonJoin(LogicalOperator &dop)\n+ \tauto left_col_count = dop.children[0]->types.size();\n+ \tif (dop.children[0]->type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN) {\n+ \t\tauto child_join = (LogicalComparisonJoin *)dop.children[0].get();\n+-\t\tleft_col_count = child_join->left_projection_map.size() + child_join->right_projection_map.size();\n++\t\tif (child_join->join_type != JoinType::SEMI && child_join->join_type != JoinType::ANTI) {\n++\t\t\tleft_col_count = child_join->left_projection_map.size() + child_join->right_projection_map.size();\n++\t\t} else {\n++\t\t\tleft_col_count = child_join->left_projection_map.size();\n++\t\t}\n+ \t}\n+ \tsjoin->set_allocated_expression(\n+ \t    CreateConjunction(djoin.conditions, [&](JoinCondition &in) { return TransformJoinCond(in, left_col_count); }));\ndiff --git a/src/include/duckdb/common/enums/join_type.hpp b/src/include/duckdb/common/enums/join_type.hpp\nindex 4b3446963eaf..8ba8e27295f0 100644\n--- a/src/include/duckdb/common/enums/join_type.hpp\n+++ b/src/include/duckdb/common/enums/join_type.hpp\n@@ -29,8 +29,8 @@ enum class JoinType : uint8_t {\n \t             // (and NULL if no partner is found)\n \tRIGHT_SEMI = 9, // RIGHT SEMI join is created by the optimizer when the children of a semi join need to be switched\n \t                // so that the build side can be the smaller table\n-\tRIGHT_ANTI = 10 // RIGHT ANTI join is created by the optimizer when the children of an anti join need to be switched\n-\t                // so that the build side can be the smaller table\n+\tRIGHT_ANTI = 10 // RIGHT ANTI join is created by the optimizer when the children of an anti join need to be\n+\t                // switched so that the build side can be the smaller table\n };\n \n //! True if join is left or full outer join\ndiff --git a/src/include/duckdb/optimizer/join_order/cardinality_estimator.hpp b/src/include/duckdb/optimizer/join_order/cardinality_estimator.hpp\nindex e4862ff57855..5390357102b2 100644\n--- a/src/include/duckdb/optimizer/join_order/cardinality_estimator.hpp\n+++ b/src/include/duckdb/optimizer/join_order/cardinality_estimator.hpp\n@@ -14,7 +14,17 @@\n \n namespace duckdb {\n \n-struct FilterInfo;\n+class FilterInfo;\n+\n+struct DenomInfo {\n+\tDenomInfo(JoinRelationSet &numerator_relations, double filter_strength, double denominator)\n+\t    : numerator_relations(numerator_relations), filter_strength(filter_strength), denominator(denominator) {\n+\t}\n+\n+\tJoinRelationSet &numerator_relations;\n+\tdouble filter_strength;\n+\tdouble denominator;\n+};\n \n struct RelationsToTDom {\n \t//! column binding sets that are equivalent in a join plan.\n@@ -25,7 +35,7 @@ struct RelationsToTDom {\n \t//! the estimated total domains of each relation without using HLL\n \tidx_t tdom_no_hll;\n \tbool has_tdom_hll;\n-\tvector<FilterInfo *> filters;\n+\tvector<optional_ptr<FilterInfo>> filters;\n \tvector<string> column_names;\n \n \texplicit RelationsToTDom(const column_binding_set_t &column_binding_set)\n@@ -33,23 +43,43 @@ struct RelationsToTDom {\n \t      has_tdom_hll(false) {};\n };\n \n+class FilterInfoWithTotalDomains {\n+public:\n+\tFilterInfoWithTotalDomains(optional_ptr<FilterInfo> filter_info, RelationsToTDom &relation2tdom)\n+\t    : filter_info(filter_info), tdom_hll(relation2tdom.tdom_hll), tdom_no_hll(relation2tdom.tdom_no_hll),\n+\t      has_tdom_hll(relation2tdom.has_tdom_hll) {\n+\t}\n+\n+\toptional_ptr<FilterInfo> filter_info;\n+\t//!\tthe estimated total domains of the equivalent relations determined using HLL\n+\tidx_t tdom_hll;\n+\t//! the estimated total domains of each relation without using HLL\n+\tidx_t tdom_no_hll;\n+\tbool has_tdom_hll;\n+};\n+\n struct Subgraph2Denominator {\n-\tunordered_set<idx_t> relations;\n+\toptional_ptr<JoinRelationSet> relations;\n+\toptional_ptr<JoinRelationSet> numerator_relations;\n \tdouble denom;\n \n-\tSubgraph2Denominator() : relations(), denom(1) {};\n+\tSubgraph2Denominator() : relations(nullptr), numerator_relations(nullptr), denom(1) {};\n };\n \n class CardinalityHelper {\n public:\n \tCardinalityHelper() {\n \t}\n-\tCardinalityHelper(double cardinality_before_filters, double filter_string)\n-\t    : cardinality_before_filters(cardinality_before_filters), filter_strength(filter_string) {};\n+\texplicit CardinalityHelper(double cardinality_before_filters)\n+\t    : cardinality_before_filters(cardinality_before_filters) {};\n \n public:\n+\t// must be a double. Otherwise we can lose significance between different join orders.\n+\t// our cardinality estimator severely underestimates cardinalities for 3+ joins. However,\n+\t// if one join order has an estimate of 0.8, and another has an estimate of 0.6, rounding\n+\t// them means there is no estimated difference, when in reality there could be a very large\n+\t// difference.\n \tdouble cardinality_before_filters;\n-\tdouble filter_strength;\n \n \tvector<string> table_names_joined;\n \tvector<string> column_names;\n@@ -57,6 +87,7 @@ class CardinalityHelper {\n \n class CardinalityEstimator {\n public:\n+\tstatic constexpr double DEFAULT_SEMI_ANTI_SELECTIVITY = 5;\n \texplicit CardinalityEstimator() {};\n \n private:\n@@ -82,12 +113,21 @@ class CardinalityEstimator {\n \tvoid PrintRelationToTdomInfo();\n \n private:\n-\tbool SingleRelationFilter(FilterInfo &filter_info);\n-\tvector<idx_t> DetermineMatchingEquivalentSets(FilterInfo *filter_info);\n+\tdouble GetNumerator(JoinRelationSet &set);\n+\tDenomInfo GetDenominator(JoinRelationSet &set);\n+\n+\tbool SingleColumnFilter(FilterInfo &filter_info);\n+\tvector<idx_t> DetermineMatchingEquivalentSets(optional_ptr<FilterInfo> filter_info);\n \t//! Given a filter, add the column bindings to the matching equivalent set at the index\n \t//! given in matching equivalent sets.\n \t//! If there are multiple equivalence sets, they are merged.\n-\tvoid AddToEquivalenceSets(FilterInfo *filter_info, vector<idx_t> matching_equivalent_sets);\n+\tvoid AddToEquivalenceSets(optional_ptr<FilterInfo> filter_info, vector<idx_t> matching_equivalent_sets);\n+\n+\tdouble CalculateUpdatedDenom(Subgraph2Denominator left, Subgraph2Denominator right,\n+\t                             FilterInfoWithTotalDomains &filter);\n+\tJoinRelationSet &UpdateNumeratorRelations(Subgraph2Denominator left, Subgraph2Denominator right,\n+\t                                          FilterInfoWithTotalDomains &filter);\n+\n \tvoid AddRelationTdom(FilterInfo &filter_info);\n \tbool EmptyFilter(FilterInfo &filter_info);\n };\ndiff --git a/src/include/duckdb/optimizer/join_order/cost_model.hpp b/src/include/duckdb/optimizer/join_order/cost_model.hpp\nindex 446a127e19e5..d6a9245b8ed3 100644\n--- a/src/include/duckdb/optimizer/join_order/cost_model.hpp\n+++ b/src/include/duckdb/optimizer/join_order/cost_model.hpp\n@@ -8,6 +8,7 @@\n #pragma once\n \n #include \"duckdb/optimizer/join_order/join_node.hpp\"\n+#include \"duckdb/common/enums/join_type.hpp\"\n #include \"duckdb/optimizer/join_order/cardinality_estimator.hpp\"\n \n namespace duckdb {\ndiff --git a/src/include/duckdb/optimizer/join_order/query_graph.hpp b/src/include/duckdb/optimizer/join_order/query_graph.hpp\nindex f1c2ded0391e..e5ac67138978 100644\n--- a/src/include/duckdb/optimizer/join_order/query_graph.hpp\n+++ b/src/include/duckdb/optimizer/join_order/query_graph.hpp\n@@ -23,7 +23,7 @@\n \n namespace duckdb {\n \n-struct FilterInfo;\n+class FilterInfo;\n \n struct NeighborInfo {\n \texplicit NeighborInfo(optional_ptr<JoinRelationSet> neighbor) : neighbor(neighbor) {\ndiff --git a/src/include/duckdb/optimizer/join_order/query_graph_manager.hpp b/src/include/duckdb/optimizer/join_order/query_graph_manager.hpp\nindex af030b45e16e..f5d324bf3971 100644\n--- a/src/include/duckdb/optimizer/join_order/query_graph_manager.hpp\n+++ b/src/include/duckdb/optimizer/join_order/query_graph_manager.hpp\n@@ -9,13 +9,12 @@\n #pragma once\n \n #include \"duckdb/common/common.hpp\"\n+#include \"duckdb/common/enums/join_type.hpp\"\n #include \"duckdb/common/optional_ptr.hpp\"\n #include \"duckdb/common/pair.hpp\"\n-#include \"duckdb/common/enums/join_type.hpp\"\n #include \"duckdb/common/unordered_map.hpp\"\n #include \"duckdb/common/unordered_set.hpp\"\n #include \"duckdb/common/vector.hpp\"\n-\n #include \"duckdb/optimizer/join_order/join_node.hpp\"\n #include \"duckdb/optimizer/join_order/join_relation.hpp\"\n #include \"duckdb/optimizer/join_order/query_graph.hpp\"\n@@ -27,6 +26,8 @@\n \n namespace duckdb {\n \n+class QueryGraphEdges;\n+\n struct GenerateJoinRelation {\n \tGenerateJoinRelation(optional_ptr<JoinRelationSet> set, unique_ptr<LogicalOperator> op_p)\n \t    : set(set), op(std::move(op_p)) {\n@@ -38,14 +39,18 @@ struct GenerateJoinRelation {\n \n //! Filter info struct that is used by the cardinality estimator to set the initial cardinality\n //! but is also eventually transformed into a query edge.\n-struct FilterInfo {\n-\tFilterInfo(unique_ptr<Expression> filter, JoinRelationSet &set, idx_t filter_index)\n-\t    : filter(std::move(filter)), set(set), filter_index(filter_index) {\n+class FilterInfo {\n+public:\n+\tFilterInfo(unique_ptr<Expression> filter, JoinRelationSet &set, idx_t filter_index,\n+\t           JoinType join_type = JoinType::INNER)\n+\t    : filter(std::move(filter)), set(set), filter_index(filter_index), join_type(join_type) {\n \t}\n \n+public:\n \tunique_ptr<Expression> filter;\n \tJoinRelationSet &set;\n \tidx_t filter_index;\n+\tJoinType join_type;\n \toptional_ptr<JoinRelationSet> left_set;\n \toptional_ptr<JoinRelationSet> right_set;\n \tColumnBinding left_binding;\ndiff --git a/src/include/duckdb/optimizer/join_order/relation_manager.hpp b/src/include/duckdb/optimizer/join_order/relation_manager.hpp\nindex 54d557adddcf..8e25b796c74f 100644\n--- a/src/include/duckdb/optimizer/join_order/relation_manager.hpp\n+++ b/src/include/duckdb/optimizer/join_order/relation_manager.hpp\n@@ -20,7 +20,7 @@\n \n namespace duckdb {\n \n-struct FilterInfo;\n+class FilterInfo;\n \n //! Represents a single relation and any metadata accompanying that relation\n struct SingleJoinRelation {\ndiff --git a/src/optimizer/column_lifetime_analyzer.cpp b/src/optimizer/column_lifetime_analyzer.cpp\nindex d942e247eb5b..1f514e028c98 100644\n--- a/src/optimizer/column_lifetime_analyzer.cpp\n+++ b/src/optimizer/column_lifetime_analyzer.cpp\n@@ -73,10 +73,6 @@ void ColumnLifetimeAnalyzer::VisitOperator(LogicalOperator &op) {\n \t\t\tbreak;\n \t\t}\n \t\tauto &comp_join = op.Cast<LogicalComparisonJoin>();\n-\t\tif (comp_join.join_type == JoinType::MARK || comp_join.join_type == JoinType::SEMI ||\n-\t\t    comp_join.join_type == JoinType::ANTI) {\n-\t\t\tbreak;\n-\t\t}\n \t\t// FIXME for now, we only push into the projection map for equality (hash) joins\n \t\t// FIXME: add projection to LHS as well\n \t\tbool has_equality = false;\n@@ -93,7 +89,7 @@ void ColumnLifetimeAnalyzer::VisitOperator(LogicalOperator &op) {\n \t\tLogicalOperatorVisitor::VisitOperatorExpressions(op);\n \n \t\tcolumn_binding_set_t unused_bindings;\n-\t\tauto old_op_bindings = op.GetColumnBindings();\n+\t\tauto old_bindings = op.GetColumnBindings();\n \t\tExtractUnusedColumnBindings(op.children[1]->GetColumnBindings(), unused_bindings);\n \n \t\t// now recurse into the filter and its children\n@@ -101,6 +97,7 @@ void ColumnLifetimeAnalyzer::VisitOperator(LogicalOperator &op) {\n \n \t\t// then generate the projection map\n \t\tGenerateProjectionMap(op.children[1]->GetColumnBindings(), unused_bindings, comp_join.right_projection_map);\n+\t\tauto new_bindings = op.GetColumnBindings();\n \t\treturn;\n \t}\n \tcase LogicalOperatorType::LOGICAL_UNION:\ndiff --git a/src/optimizer/join_order/cardinality_estimator.cpp b/src/optimizer/join_order/cardinality_estimator.cpp\nindex 4745b00addde..b2767786199c 100644\n--- a/src/optimizer/join_order/cardinality_estimator.cpp\n+++ b/src/optimizer/join_order/cardinality_estimator.cpp\n@@ -1,9 +1,7 @@\n #include \"duckdb/function/table/table_scan.hpp\"\n #include \"duckdb/optimizer/join_order/join_node.hpp\"\n-#include \"duckdb/optimizer/join_order/join_order_optimizer.hpp\"\n-#include \"duckdb/planner/filter/conjunction_filter.hpp\"\n #include \"duckdb/planner/operator/logical_comparison_join.hpp\"\n-#include \"duckdb/planner/operator/logical_get.hpp\"\n+#include \"duckdb/optimizer/join_order/query_graph_manager.hpp\"\n #include \"duckdb/storage/data_table.hpp\"\n #include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n #include \"duckdb/common/printer.hpp\"\n@@ -37,7 +35,7 @@ void CardinalityEstimator::AddRelationTdom(FilterInfo &filter_info) {\n \trelations_to_tdoms.emplace_back(new_r2tdom);\n }\n \n-bool CardinalityEstimator::SingleRelationFilter(FilterInfo &filter_info) {\n+bool CardinalityEstimator::SingleColumnFilter(duckdb::FilterInfo &filter_info) {\n \tif (filter_info.left_set && filter_info.right_set && filter_info.set.count > 1) {\n \t\t// Both set and are from different relations\n \t\treturn false;\n@@ -48,7 +46,7 @@ bool CardinalityEstimator::SingleRelationFilter(FilterInfo &filter_info) {\n \treturn true;\n }\n \n-vector<idx_t> CardinalityEstimator::DetermineMatchingEquivalentSets(FilterInfo *filter_info) {\n+vector<idx_t> CardinalityEstimator::DetermineMatchingEquivalentSets(optional_ptr<FilterInfo> filter_info) {\n \tvector<idx_t> matching_equivalent_sets;\n \tidx_t equivalent_relation_index = 0;\n \n@@ -66,7 +64,8 @@ vector<idx_t> CardinalityEstimator::DetermineMatchingEquivalentSets(FilterInfo *\n \treturn matching_equivalent_sets;\n }\n \n-void CardinalityEstimator::AddToEquivalenceSets(FilterInfo *filter_info, vector<idx_t> matching_equivalent_sets) {\n+void CardinalityEstimator::AddToEquivalenceSets(optional_ptr<FilterInfo> filter_info,\n+                                                vector<idx_t> matching_equivalent_sets) {\n \tD_ASSERT(matching_equivalent_sets.size() <= 2);\n \tif (matching_equivalent_sets.size() > 1) {\n \t\t// an equivalence relation is connecting two sets of equivalence relations\n@@ -100,8 +99,8 @@ void CardinalityEstimator::InitEquivalentRelations(const vector<unique_ptr<Filte\n \t// For each filter, we fill keep track of the index of the equivalent relation set\n \t// the left and right relation needs to be added to.\n \tfor (auto &filter : filter_infos) {\n-\t\tif (SingleRelationFilter(*filter)) {\n-\t\t\t// Filter on one relation, (i.e string or range filter on a column).\n+\t\tif (SingleColumnFilter(*filter)) {\n+\t\t\t// Filter on one relation, (i.e. string or range filter on a column).\n \t\t\t// Grab the first relation and add it to  the equivalence_relations\n \t\t\tAddRelationTdom(*filter);\n \t\t\tcontinue;\n@@ -123,44 +122,117 @@ void CardinalityEstimator::RemoveEmptyTotalDomains() {\n \trelations_to_tdoms.erase(remove_start, relations_to_tdoms.end());\n }\n \n-void UpdateDenom(Subgraph2Denominator &relation_2_denom, RelationsToTDom &relation_to_tdom) {\n-\trelation_2_denom.denom *= relation_to_tdom.has_tdom_hll ? relation_to_tdom.tdom_hll : relation_to_tdom.tdom_no_hll;\n+double CardinalityEstimator::GetNumerator(JoinRelationSet &set) {\n+\tdouble numerator = 1;\n+\tfor (idx_t i = 0; i < set.count; i++) {\n+\t\tauto &single_node_set = set_manager.GetJoinRelation(set.relations[i]);\n+\t\tauto card_helper = relation_set_2_cardinality[single_node_set.ToString()];\n+\t\tnumerator *= card_helper.cardinality_before_filters == 0 ? 1 : card_helper.cardinality_before_filters;\n+\t}\n+\treturn numerator;\n }\n \n-void FindSubgraphMatchAndMerge(Subgraph2Denominator &merge_to, idx_t find_me,\n-                               vector<Subgraph2Denominator>::iterator subgraph,\n-                               vector<Subgraph2Denominator>::iterator end) {\n-\tfor (; subgraph != end; subgraph++) {\n-\t\tif (subgraph->relations.count(find_me) >= 1) {\n-\t\t\tfor (auto &relation : subgraph->relations) {\n-\t\t\t\tmerge_to.relations.insert(relation);\n+bool EdgeConnects(FilterInfoWithTotalDomains &edge, Subgraph2Denominator &subgraph) {\n+\tif (edge.filter_info->left_set) {\n+\t\tif (JoinRelationSet::IsSubset(*subgraph.relations, *edge.filter_info->left_set)) {\n+\t\t\t// cool\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\tif (edge.filter_info->right_set) {\n+\t\tif (JoinRelationSet::IsSubset(*subgraph.relations, *edge.filter_info->right_set)) {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\treturn false;\n+}\n+\n+vector<FilterInfoWithTotalDomains> GetEdges(vector<RelationsToTDom> &relations_to_tdom,\n+                                            JoinRelationSet &requested_set) {\n+\tvector<FilterInfoWithTotalDomains> res;\n+\tfor (auto &relation_2_tdom : relations_to_tdom) {\n+\t\tfor (auto &filter : relation_2_tdom.filters) {\n+\t\t\tif (JoinRelationSet::IsSubset(requested_set, filter->set)) {\n+\t\t\t\tFilterInfoWithTotalDomains new_edge(filter, relation_2_tdom);\n+\t\t\t\tres.push_back(new_edge);\n \t\t\t}\n-\t\t\tsubgraph->relations.clear();\n-\t\t\tmerge_to.denom *= subgraph->denom;\n-\t\t\treturn;\n \t\t}\n \t}\n+\treturn res;\n }\n \n-template <>\n-double CardinalityEstimator::EstimateCardinalityWithSet(JoinRelationSet &new_set) {\n+vector<idx_t> SubgraphsConnectedByEdge(FilterInfoWithTotalDomains &edge, vector<Subgraph2Denominator> &subgraphs) {\n+\tvector<idx_t> res;\n+\tif (subgraphs.empty()) {\n+\t\treturn res;\n+\t} else {\n+\t\t// check the combinations of subgraphs and see if the edge connects two of them,\n+\t\t// if so, return the indexes of the two subgraphs within the vector\n+\t\tfor (idx_t outer = 0; outer != subgraphs.size(); outer++) {\n+\t\t\t// check if the edge connects two subgraphs.\n+\t\t\tfor (idx_t inner = outer + 1; inner != subgraphs.size(); inner++) {\n+\t\t\t\tif (EdgeConnects(edge, subgraphs.at(outer)) && EdgeConnects(edge, subgraphs.at(inner))) {\n+\t\t\t\t\t// order is important because we will delete the inner subgraph later\n+\t\t\t\t\tres.push_back(outer);\n+\t\t\t\t\tres.push_back(inner);\n+\t\t\t\t\treturn res;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// if the edge does not connect two subgraphs, see if the edge connects with just outer\n+\t\t\t// merge subgraph.at(outer) with the RelationSet(s) that edge connects\n+\t\t\tif (EdgeConnects(edge, subgraphs.at(outer))) {\n+\t\t\t\tres.push_back(outer);\n+\t\t\t\treturn res;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t// this edge connects only the relations it connects. Return an empty result so a new subgraph is created.\n+\treturn res;\n+}\n \n-\tif (relation_set_2_cardinality.find(new_set.ToString()) != relation_set_2_cardinality.end()) {\n-\t\treturn relation_set_2_cardinality[new_set.ToString()].cardinality_before_filters;\n+JoinRelationSet &CardinalityEstimator::UpdateNumeratorRelations(Subgraph2Denominator left, Subgraph2Denominator right,\n+                                                                FilterInfoWithTotalDomains &filter) {\n+\tswitch (filter.filter_info->join_type) {\n+\tcase JoinType::SEMI:\n+\tcase JoinType::ANTI: {\n+\t\tif (JoinRelationSet::IsSubset(*left.relations, *filter.filter_info->left_set) &&\n+\t\t    JoinRelationSet::IsSubset(*right.relations, *filter.filter_info->right_set)) {\n+\t\t\treturn *left.numerator_relations;\n+\t\t}\n+\t\treturn *right.numerator_relations;\n \t}\n-\tdouble numerator = 1;\n-\tunordered_set<idx_t> actual_set;\n+\tdefault:\n+\t\t// cross product or inner join\n+\t\treturn set_manager.Union(*left.numerator_relations, *right.numerator_relations);\n+\t}\n+}\n \n-\tfor (idx_t i = 0; i < new_set.count; i++) {\n-\t\tauto &single_node_set = set_manager.GetJoinRelation(new_set.relations[i]);\n-\t\tauto card_helper = relation_set_2_cardinality[single_node_set.ToString()];\n-\t\tnumerator *= card_helper.cardinality_before_filters == 0 ? 1 : card_helper.cardinality_before_filters;\n-\t\tactual_set.insert(new_set.relations[i]);\n+double CardinalityEstimator::CalculateUpdatedDenom(Subgraph2Denominator left, Subgraph2Denominator right,\n+                                                   FilterInfoWithTotalDomains &filter) {\n+\tdouble new_denom = left.denom * right.denom;\n+\tswitch (filter.filter_info->join_type) {\n+\tcase JoinType::INNER: {\n+\t\tnew_denom *= filter.has_tdom_hll ? (double)filter.tdom_hll : (double)filter.tdom_no_hll;\n+\t\treturn new_denom;\n \t}\n+\tcase JoinType::SEMI:\n+\tcase JoinType::ANTI: {\n+\t\tif (JoinRelationSet::IsSubset(*left.relations, *filter.filter_info->left_set) &&\n+\t\t    JoinRelationSet::IsSubset(*right.relations, *filter.filter_info->right_set)) {\n+\t\t\tnew_denom = left.denom * CardinalityEstimator::DEFAULT_SEMI_ANTI_SELECTIVITY;\n+\t\t\treturn new_denom;\n+\t\t}\n+\t\tnew_denom = right.denom * CardinalityEstimator::DEFAULT_SEMI_ANTI_SELECTIVITY;\n+\t\treturn new_denom;\n+\t}\n+\tdefault:\n+\t\t// cross product\n+\t\treturn new_denom;\n+\t}\n+}\n \n+DenomInfo CardinalityEstimator::GetDenominator(JoinRelationSet &set) {\n \tvector<Subgraph2Denominator> subgraphs;\n-\tbool done = false;\n-\tbool found_match = false;\n \n \t// Finding the denominator is tricky. You need to go through the tdoms in decreasing order\n \t// Then loop through all filters in the equivalence set of the tdom to see if both the\n@@ -170,87 +242,104 @@ double CardinalityEstimator::EstimateCardinalityWithSet(JoinRelationSet &new_set\n \t// TODO: Implement a method to cache subgraphs so you don't have to build them up every\n \t// time the cardinality of a new set is requested\n \n-\t// relations_to_tdoms has already been sorted.\n-\tfor (auto &relation_2_tdom : relations_to_tdoms) {\n-\t\t// loop through each filter in the tdom.\n-\t\tif (done) {\n-\t\t\tbreak;\n-\t\t}\n-\t\tfor (auto &filter : relation_2_tdom.filters) {\n-\t\t\tif (actual_set.count(filter->left_binding.table_index) == 0 ||\n-\t\t\t    actual_set.count(filter->right_binding.table_index) == 0) {\n-\t\t\t\tcontinue;\n+\t// relations_to_tdoms has already been sorted by largest to smallest total domain\n+\t// then we look through the filters for the relations_to_tdoms,\n+\t// and we start to choose the filters that join relations in the set.\n+\n+\t// edges are guaranteed to be in order of largest tdom to smallest tdom.\n+\tauto edges = GetEdges(relations_to_tdoms, set);\n+\tfor (auto &edge : edges) {\n+\t\tauto subgraph_connections = SubgraphsConnectedByEdge(edge, subgraphs);\n+\n+\t\tif (subgraph_connections.empty()) {\n+\t\t\t// create a subgraph out of left and right, then merge right into left and add left to subgraphs.\n+\t\t\t// this helps cover a case where there are no subgraphs yet, and the only join filter is a SEMI JOIN\n+\t\t\tauto left_subgraph = Subgraph2Denominator();\n+\t\t\tauto right_subgraph = Subgraph2Denominator();\n+\t\t\tleft_subgraph.relations = edge.filter_info->left_set;\n+\t\t\tleft_subgraph.numerator_relations = edge.filter_info->left_set;\n+\t\t\tright_subgraph.relations = edge.filter_info->right_set;\n+\t\t\tright_subgraph.numerator_relations = edge.filter_info->right_set;\n+\n+\t\t\tleft_subgraph.numerator_relations = &UpdateNumeratorRelations(left_subgraph, right_subgraph, edge);\n+\t\t\tleft_subgraph.relations = &edge.filter_info->set;\n+\t\t\tleft_subgraph.denom = CalculateUpdatedDenom(left_subgraph, right_subgraph, edge);\n+\t\t\tsubgraphs.push_back(left_subgraph);\n+\t\t} else if (subgraph_connections.size() == 1) {\n+\t\t\tauto left_subgraph = &subgraphs.at(subgraph_connections.at(0));\n+\t\t\tauto right_subgraph = Subgraph2Denominator();\n+\t\t\tright_subgraph.relations = edge.filter_info->right_set;\n+\t\t\tright_subgraph.numerator_relations = edge.filter_info->right_set;\n+\t\t\tif (JoinRelationSet::IsSubset(*left_subgraph->relations, *right_subgraph.relations)) {\n+\t\t\t\tright_subgraph.relations = edge.filter_info->left_set;\n+\t\t\t\tright_subgraph.numerator_relations = edge.filter_info->left_set;\n \t\t\t}\n-\t\t\t// the join filter is on relations in the new set.\n-\t\t\tfound_match = false;\n-\t\t\tvector<Subgraph2Denominator>::iterator it;\n-\t\t\tfor (it = subgraphs.begin(); it != subgraphs.end(); it++) {\n-\t\t\t\tauto left_in = it->relations.count(filter->left_binding.table_index);\n-\t\t\t\tauto right_in = it->relations.count(filter->right_binding.table_index);\n-\t\t\t\tif (left_in && right_in) {\n-\t\t\t\t\t// if both left and right bindings are in the subgraph, continue.\n-\t\t\t\t\t// This means another filter is connecting relations already in the\n-\t\t\t\t\t// subgraph it, but it has a tdom that is less, and we don't care.\n-\t\t\t\t\tfound_match = true;\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tif (!left_in && !right_in) {\n-\t\t\t\t\t// if both left and right bindings are *not* in the subgraph, continue\n-\t\t\t\t\t// without finding a match. This will trigger the process to add a new\n-\t\t\t\t\t// subgraph\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tidx_t find_table;\n-\t\t\t\tif (left_in) {\n-\t\t\t\t\tfind_table = filter->right_binding.table_index;\n-\t\t\t\t} else {\n-\t\t\t\t\tD_ASSERT(right_in);\n-\t\t\t\t\tfind_table = filter->left_binding.table_index;\n-\t\t\t\t}\n-\t\t\t\tauto next_subgraph = it + 1;\n-\t\t\t\t// iterate through other subgraphs and merge.\n-\t\t\t\tFindSubgraphMatchAndMerge(*it, find_table, next_subgraph, subgraphs.end());\n-\t\t\t\t// Now insert the right binding and update denominator with the\n-\t\t\t\t// tdom of the filter\n-\t\t\t\tit->relations.insert(find_table);\n-\t\t\t\tUpdateDenom(*it, relation_2_tdom);\n-\t\t\t\tfound_match = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\t// means that the filter joins relations in the given set, but there is no\n-\t\t\t// connection to any subgraph in subgraphs. Add a new subgraph, and maybe later there will be\n-\t\t\t// a connection.\n-\t\t\tif (!found_match) {\n-\t\t\t\tsubgraphs.emplace_back();\n-\t\t\t\tauto &subgraph = subgraphs.back();\n-\t\t\t\tsubgraph.relations.insert(filter->left_binding.table_index);\n-\t\t\t\tsubgraph.relations.insert(filter->right_binding.table_index);\n-\t\t\t\tUpdateDenom(subgraph, relation_2_tdom);\n+\n+\t\t\tif (JoinRelationSet::IsSubset(*left_subgraph->relations, *edge.filter_info->left_set) &&\n+\t\t\t    JoinRelationSet::IsSubset(*left_subgraph->relations, *edge.filter_info->right_set)) {\n+\t\t\t\t// here we have an edge that connects the same subgraph to the same subgraph. Just continue. no need to\n+\t\t\t\t// update the denom\n+\t\t\t\tcontinue;\n \t\t\t}\n+\t\t\tleft_subgraph->numerator_relations = &UpdateNumeratorRelations(*left_subgraph, right_subgraph, edge);\n+\t\t\tleft_subgraph->relations = &set_manager.Union(*left_subgraph->relations, *right_subgraph.relations);\n+\t\t\tleft_subgraph->denom = CalculateUpdatedDenom(*left_subgraph, right_subgraph, edge);\n+\t\t} else if (subgraph_connections.size() == 2) {\n+\t\t\t// The two subgraphs in the subgraph_connections can be merged by this edge.\n+\t\t\tD_ASSERT(subgraph_connections.at(0) < subgraph_connections.at(1));\n+\t\t\tauto subgraph_to_merge_into = &subgraphs.at(subgraph_connections.at(0));\n+\t\t\tauto subgraph_to_delete = &subgraphs.at(subgraph_connections.at(1));\n+\t\t\tsubgraph_to_merge_into->relations =\n+\t\t\t    &set_manager.Union(*subgraph_to_merge_into->relations, *subgraph_to_delete->relations);\n+\t\t\tsubgraph_to_merge_into->numerator_relations =\n+\t\t\t    &UpdateNumeratorRelations(*subgraph_to_merge_into, *subgraph_to_delete, edge);\n+\t\t\tsubgraph_to_delete->relations = nullptr;\n+\t\t\tsubgraph_to_merge_into->denom = CalculateUpdatedDenom(*subgraph_to_merge_into, *subgraph_to_delete, edge);\n \t\t\tauto remove_start = std::remove_if(subgraphs.begin(), subgraphs.end(),\n-\t\t\t                                   [](Subgraph2Denominator &s) { return s.relations.empty(); });\n+\t\t\t                                   [](Subgraph2Denominator &s) { return !s.relations; });\n \t\t\tsubgraphs.erase(remove_start, subgraphs.end());\n+\t\t}\n+\t\tif (subgraphs.size() == 1 && subgraphs.at(0).relations->ToString() == set.ToString()) {\n+\t\t\t// the first subgraph has connected all the desired relations, no need to iterate\n+\t\t\t// through the rest of the edges.\n+\t\t\tbreak;\n+\t\t}\n+\t}\n \n-\t\t\tif (subgraphs.size() == 1 && subgraphs.at(0).relations.size() == new_set.count) {\n-\t\t\t\t// You have found enough filters to connect the relations. These are guaranteed\n-\t\t\t\t// to be the filters with the highest Tdoms.\n-\t\t\t\tdone = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n+\t// It's possible cross-products were added and are not present in the filters in the relation_2_tdom\n+\t// structures. When that's the case, merge all remaining subgraphs.\n+\tif (subgraphs.size() > 1) {\n+\t\tauto final_subgraph = subgraphs.at(0);\n+\t\tfor (auto merge_with = subgraphs.begin() + 1; merge_with != subgraphs.end(); merge_with++) {\n+\t\t\tD_ASSERT(final_subgraph.relations && merge_with->relations);\n+\t\t\tfinal_subgraph.relations = &set_manager.Union(*final_subgraph.relations, *merge_with->relations);\n+\t\t\tD_ASSERT(final_subgraph.numerator_relations && merge_with->numerator_relations);\n+\t\t\tfinal_subgraph.numerator_relations =\n+\t\t\t    &set_manager.Union(*final_subgraph.numerator_relations, *merge_with->numerator_relations);\n+\t\t\tfinal_subgraph.denom *= merge_with->denom;\n \t\t}\n \t}\n-\tdouble denom = 1;\n-\t// TODO: It's possible cross-products were added and are not present in the filters in the relation_2_tdom\n-\t//       structures. When that's the case, multiply the denom structures that have no intersection\n-\tfor (auto &match : subgraphs) {\n-\t\tdenom *= match.denom;\n+\t// can happen if a table has cardinality 0, a tdom is set to 0, or if a cross product is used.\n+\tif (subgraphs.empty() || subgraphs.at(0).denom == 0) {\n+\t\t// denominator is 1 and numerators are a cross product of cardinalities.\n+\t\treturn DenomInfo(set, 1, 1);\n \t}\n-\t// can happen if a table has cardinality 0, or a tdom is set to 0\n-\tif (denom <= 1) {\n-\t\tdenom = 1;\n+\treturn DenomInfo(*subgraphs.at(0).numerator_relations, 1, subgraphs.at(0).denom);\n+}\n+\n+template <>\n+double CardinalityEstimator::EstimateCardinalityWithSet(JoinRelationSet &new_set) {\n+\n+\tif (relation_set_2_cardinality.find(new_set.ToString()) != relation_set_2_cardinality.end()) {\n+\t\treturn relation_set_2_cardinality[new_set.ToString()].cardinality_before_filters;\n \t}\n-\tauto result = numerator / denom;\n-\tauto new_entry = CardinalityHelper((double)result, 1);\n+\n+\t// can happen if a table has cardinality 0, or a tdom is set to 0\n+\tauto denom = GetDenominator(new_set);\n+\tauto numerator = GetNumerator(denom.numerator_relations);\n+\n+\tdouble result = numerator / denom.denominator;\n+\tauto new_entry = CardinalityHelper(result);\n \trelation_set_2_cardinality[new_set.ToString()] = new_entry;\n \treturn result;\n }\n@@ -259,7 +348,7 @@ template <>\n idx_t CardinalityEstimator::EstimateCardinalityWithSet(JoinRelationSet &new_set) {\n \tauto cardinality_as_double = EstimateCardinalityWithSet<double>(new_set);\n \tauto max = NumericLimits<idx_t>::Maximum();\n-\tif (cardinality_as_double >= max) {\n+\tif (cardinality_as_double >= (double)max) {\n \t\treturn max;\n \t}\n \treturn (idx_t)cardinality_as_double;\n@@ -282,9 +371,8 @@ void CardinalityEstimator::InitCardinalityEstimatorProps(optional_ptr<JoinRelati\n \t// Get the join relation set\n \tD_ASSERT(stats.stats_initialized);\n \tauto relation_cardinality = stats.cardinality;\n-\tauto relation_filter = stats.filter_strength;\n \n-\tauto card_helper = CardinalityHelper(relation_cardinality, relation_filter);\n+\tauto card_helper = CardinalityHelper((double)relation_cardinality);\n \trelation_set_2_cardinality[set->ToString()] = card_helper;\n \n \tUpdateTotalDomains(set, stats);\ndiff --git a/src/optimizer/join_order/join_relation_set.cpp b/src/optimizer/join_order/join_relation_set.cpp\nindex d08ac4c89bb7..aa5767427ae7 100644\n--- a/src/optimizer/join_order/join_relation_set.cpp\n+++ b/src/optimizer/join_order/join_relation_set.cpp\n@@ -99,11 +99,15 @@ JoinRelationSet &JoinRelationSetManager::Union(JoinRelationSet &left, JoinRelati\n \t\t\t// left is smaller, progress left and add it to the set\n \t\t\trelations[count++] = left.relations[i];\n \t\t\ti++;\n-\t\t} else {\n-\t\t\tD_ASSERT(left.relations[i] > right.relations[j]);\n+\t\t} else if (left.relations[i] > right.relations[j]) {\n \t\t\t// right is smaller, progress right and add it to the set\n \t\t\trelations[count++] = right.relations[j];\n \t\t\tj++;\n+\t\t} else {\n+\t\t\tD_ASSERT(left.relations[i] == right.relations[j]);\n+\t\t\trelations[count++] = left.relations[i];\n+\t\t\ti++;\n+\t\t\tj++;\n \t\t}\n \t}\n \treturn GetJoinRelation(std::move(relations), count);\ndiff --git a/src/optimizer/join_order/plan_enumerator.cpp b/src/optimizer/join_order/plan_enumerator.cpp\nindex 712a6c429229..a5e618fc677a 100644\n--- a/src/optimizer/join_order/plan_enumerator.cpp\n+++ b/src/optimizer/join_order/plan_enumerator.cpp\n@@ -104,12 +104,24 @@ unique_ptr<DPJoinNode> PlanEnumerator::CreateJoinTree(JoinRelationSet &set,\n \t// FIXME: we should probably actually benchmark that as well\n \t// FIXME: should consider different join algorithms, should we pick a join algorithm here as well? (probably)\n \toptional_ptr<NeighborInfo> best_connection = nullptr;\n-\n-\t// cross products are techincally still connections, but the filter expression is a null_ptr\n+\t// cross products are technically still connections, but the filter expression is a null_ptr\n \tif (!possible_connections.empty()) {\n \t\tbest_connection = &possible_connections.back().get();\n \t}\n+\tauto join_type = JoinType::INVALID;\n+\tfor (auto &filter_binding : best_connection->filters) {\n+\t\tif (!filter_binding->left_set || !filter_binding->right_set) {\n+\t\t\tcontinue;\n+\t\t}\n \n+\t\tjoin_type = filter_binding->join_type;\n+\t\t// prefer joining on semi and anti joins as they have a higher chance of being more\n+\t\t// selective\n+\t\tif (join_type == JoinType::SEMI || join_type == JoinType::ANTI) {\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\t// need the filter info from the Neighborhood info.\n \tauto cost = cost_model.ComputeCost(left, right);\n \tauto result = make_uniq<DPJoinNode>(set, best_connection, left.set, right.set, cost);\n \tresult->cardinality = cost_model.cardinality_estimator.EstimateCardinalityWithSet<idx_t>(set);\ndiff --git a/src/optimizer/join_order/query_graph_manager.cpp b/src/optimizer/join_order/query_graph_manager.cpp\nindex 004dd551bdac..446a3ad610d8 100644\n--- a/src/optimizer/join_order/query_graph_manager.cpp\n+++ b/src/optimizer/join_order/query_graph_manager.cpp\n@@ -193,7 +193,15 @@ GenerateJoinRelation QueryGraphManager::GenerateJoins(vector<unique_ptr<LogicalO\n \t\t\tresult_operator = LogicalCrossProduct::Create(std::move(left.op), std::move(right.op));\n \t\t} else {\n \t\t\t// we have filters, create a join node\n-\t\t\tauto join = make_uniq<LogicalComparisonJoin>(JoinType::INNER);\n+\t\t\tauto chosen_filter = node->info->filters.at(0);\n+\t\t\tfor (idx_t i = 0; i < node->info->filters.size(); i++) {\n+\t\t\t\tif (node->info->filters.at(i)->join_type == JoinType::INNER) {\n+\t\t\t\t\tchosen_filter = node->info->filters.at(i);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tauto join = make_uniq<LogicalComparisonJoin>(chosen_filter->join_type);\n \t\t\t// Here we optimize build side probe side. Our build side is the right side\n \t\t\t// So the right plans should have lower cardinalities.\n \t\t\tjoin->children.push_back(std::move(left.op));\n@@ -216,7 +224,14 @@ GenerateJoinRelation QueryGraphManager::GenerateJoins(vector<unique_ptr<LogicalO\n \t\t\t\tauto &comparison = condition->Cast<BoundComparisonExpression>();\n \n \t\t\t\t// we need to figure out which side is which by looking at the relations available to us\n+\t\t\t\t// left/right (build side/probe side) optimizations happen later.\n \t\t\t\tbool invert = !JoinRelationSet::IsSubset(*left.set, *f->left_set);\n+\t\t\t\t// If the left and right set are inverted AND it is a semi or anti join\n+\t\t\t\t// swap left and right children back.\n+\t\t\t\tif (invert && (f->join_type == JoinType::SEMI || f->join_type == JoinType::ANTI)) {\n+\t\t\t\t\tstd::swap(left, right);\n+\t\t\t\t\tinvert = false;\n+\t\t\t\t}\n \t\t\t\tcond.left = !invert ? std::move(comparison.left) : std::move(comparison.right);\n \t\t\t\tcond.right = !invert ? std::move(comparison.right) : std::move(comparison.left);\n \t\t\t\tcond.comparison = condition->type;\ndiff --git a/src/optimizer/join_order/relation_manager.cpp b/src/optimizer/join_order/relation_manager.cpp\nindex 3df21b77e7fe..29710d7c1d31 100644\n--- a/src/optimizer/join_order/relation_manager.cpp\n+++ b/src/optimizer/join_order/relation_manager.cpp\n@@ -9,8 +9,6 @@\n #include \"duckdb/planner/expression/list.hpp\"\n #include \"duckdb/planner/operator/list.hpp\"\n \n-#include <cmath>\n-\n namespace duckdb {\n \n const vector<RelationStats> RelationManager::GetRelationStats() {\n@@ -102,6 +100,23 @@ static bool OperatorIsNonReorderable(LogicalOperatorType op_type) {\n \t}\n }\n \n+static bool JoinIsReorderable(LogicalOperator &op) {\n+\tif (op.type == LogicalOperatorType::LOGICAL_CROSS_PRODUCT) {\n+\t\treturn true;\n+\t} else if (op.type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN) {\n+\t\tauto &join = op.Cast<LogicalComparisonJoin>();\n+\t\tswitch (join.join_type) {\n+\t\tcase JoinType::INNER:\n+\t\tcase JoinType::SEMI:\n+\t\tcase JoinType::ANTI:\n+\t\t\treturn true;\n+\t\tdefault:\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\treturn false;\n+}\n+\n static bool HasNonReorderableChild(LogicalOperator &op) {\n \tLogicalOperator *tmp = &op;\n \twhile (tmp->children.size() == 1) {\n@@ -110,8 +125,7 @@ static bool HasNonReorderableChild(LogicalOperator &op) {\n \t\t}\n \t\ttmp = tmp->children[0].get();\n \t\tif (tmp->type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN) {\n-\t\t\tauto &join = tmp->Cast<LogicalComparisonJoin>();\n-\t\t\tif (join.join_type != JoinType::INNER) {\n+\t\t\tif (!JoinIsReorderable(*tmp)) {\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}\n@@ -141,8 +155,7 @@ bool RelationManager::ExtractJoinRelations(LogicalOperator &input_op,\n \t}\n \n \tif (op->type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN) {\n-\t\tauto &join = op->Cast<LogicalComparisonJoin>();\n-\t\tif (join.join_type == JoinType::INNER) {\n+\t\tif (JoinIsReorderable(*op)) {\n \t\t\t// extract join conditions from inner join\n \t\t\tfilter_operators.push_back(*op);\n \t\t} else {\n@@ -314,7 +327,6 @@ vector<unique_ptr<FilterInfo>> RelationManager::ExtractEdges(LogicalOperator &op\n \t\tif (f_op.type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN ||\n \t\t    f_op.type == LogicalOperatorType::LOGICAL_ASOF_JOIN) {\n \t\t\tauto &join = f_op.Cast<LogicalComparisonJoin>();\n-\t\t\tD_ASSERT(join.join_type == JoinType::INNER);\n \t\t\tD_ASSERT(join.expressions.empty());\n \t\t\tfor (auto &cond : join.conditions) {\n \t\t\t\tauto comparison =\n@@ -324,7 +336,8 @@ vector<unique_ptr<FilterInfo>> RelationManager::ExtractEdges(LogicalOperator &op\n \t\t\t\t\tunordered_set<idx_t> bindings;\n \t\t\t\t\tExtractBindings(*comparison, bindings);\n \t\t\t\t\tauto &set = set_manager.GetJoinRelation(bindings);\n-\t\t\t\t\tauto filter_info = make_uniq<FilterInfo>(std::move(comparison), set, filters_and_bindings.size());\n+\t\t\t\t\tauto filter_info =\n+\t\t\t\t\t    make_uniq<FilterInfo>(std::move(comparison), set, filters_and_bindings.size(), join.join_type);\n \t\t\t\t\tfilters_and_bindings.push_back(std::move(filter_info));\n \t\t\t\t}\n \t\t\t}\ndiff --git a/src/optimizer/join_order/relation_statistics_helper.cpp b/src/optimizer/join_order/relation_statistics_helper.cpp\nindex 79af3bd8ca33..7c061c4ade51 100644\n--- a/src/optimizer/join_order/relation_statistics_helper.cpp\n+++ b/src/optimizer/join_order/relation_statistics_helper.cpp\n@@ -59,10 +59,10 @@ RelationStats RelationStatisticsHelper::ExtractGetStats(LogicalGet &get, ClientC\n \tauto cardinality_after_filters = base_table_cardinality;\n \tunique_ptr<BaseStatistics> column_statistics;\n \n-\tauto table_thing = get.GetTable();\n+\tauto catalog_table = get.GetTable();\n \tauto name = string(\"some table\");\n-\tif (table_thing) {\n-\t\tname = table_thing->name;\n+\tif (catalog_table) {\n+\t\tname = catalog_table->name;\n \t\treturn_stats.table_name = name;\n \t}\n \n@@ -82,7 +82,8 @@ RelationStats RelationStatisticsHelper::ExtractGetStats(LogicalGet &get, ClientC\n \t\tif (get.function.statistics) {\n \t\t\tcolumn_statistics = get.function.statistics(context, get.bind_data.get(), get.column_ids[i]);\n \t\t\tif (column_statistics && have_catalog_table_statistics) {\n-\t\t\t\tauto column_distinct_count = DistinctCount({column_statistics->GetDistinctCount(), true});\n+\t\t\t\tauto distinct_count = MaxValue((idx_t)1, column_statistics->GetDistinctCount());\n+\t\t\t\tauto column_distinct_count = DistinctCount({distinct_count, true});\n \t\t\t\treturn_stats.column_distinct_count.push_back(column_distinct_count);\n \t\t\t\treturn_stats.column_names.push_back(name + \".\" + get.names.at(get.column_ids.at(i)));\n \t\t\t\thave_distinct_count_stats = true;\ndiff --git a/src/optimizer/statistics/operator/propagate_filter.cpp b/src/optimizer/statistics/operator/propagate_filter.cpp\nindex 6bd1d30c1603..7dbdc6da75bf 100644\n--- a/src/optimizer/statistics/operator/propagate_filter.cpp\n+++ b/src/optimizer/statistics/operator/propagate_filter.cpp\n@@ -241,7 +241,12 @@ unique_ptr<NodeStatistics> StatisticsPropagator::PropagateStatistics(LogicalFilt\n \t\t\tfilter.expressions.erase_at(i);\n \t\t\ti--;\n \t\t\tif (filter.expressions.empty()) {\n-\t\t\t\t// just break. The physical filter planner will plan a projection instead\n+\t\t\t\t// if there is a projection map, we should keep the filter\n+\t\t\t\t// the physical planner will eventually skip the filter, but will keep\n+\t\t\t\t// the correct columns.\n+\t\t\t\tif (filter.projection_map.empty()) {\n+\t\t\t\t\tnode_ptr = std::move(filter.children[0]);\n+\t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t} else if (ExpressionIsConstant(*condition, Value::BOOLEAN(false)) ||\n",
  "test_patch": "diff --git a/test/api/test_reset.cpp b/test/api/test_reset.cpp\nindex 630b971b9403..578aa6be2a23 100644\n--- a/test/api/test_reset.cpp\n+++ b/test/api/test_reset.cpp\n@@ -115,6 +115,7 @@ OptionValueSet &GetValueForOption(const string &name) {\n \t    {\"produce_arrow_string_view\", {true}},\n \t    {\"enable_http_logging\", {true}},\n \t    {\"http_logging_output\", {\"my_cool_outputfile\"}},\n+\t    {\"produce_arrow_string_view\", {true}},\n \t    {\"allocator_flush_threshold\", {\"4.0 GiB\"}},\n \t    {\"allocator_background_threads\", {true}}};\n \t// Every option that's not excluded has to be part of this map\ndiff --git a/test/fuzzer/duckfuzz/duck_fuzz_column_binding_tests.test b/test/fuzzer/duckfuzz/duck_fuzz_column_binding_tests.test\nindex f55e47d2c6c4..eae05e8f33d9 100644\n--- a/test/fuzzer/duckfuzz/duck_fuzz_column_binding_tests.test\n+++ b/test/fuzzer/duckfuzz/duck_fuzz_column_binding_tests.test\n@@ -8,22 +8,20 @@ create table all_types as select * exclude(small_enum, medium_enum, large_enum)\n # https://github.com/duckdb/duckdb-fuzzer/issues/1357\n # simplified query\n statement ok\n-SELECT     ref_8.uint AS c0, \n-           Argmin(Cast(ref_8.\"timestamp\" AS TIMESTAMP), Cast(ref_10.\"timestamp\" AS TIMESTAMP)) OVER (partition BY ref_10.\"nested_int_array\", ref_10.\"timestamp\" ORDER BY ref_8.hugeint)  AS c1 \n-FROM main.all_types AS ref_8 \n-INNER JOIN main.all_types AS ref_9 \n-INNER JOIN main.all_types AS ref_10 \n-ON        ( ref_10.dec38_10 IS NOT NULL) \n-                      OR         EXISTS \n-                                 ( SELECT ref_9.\"float\" FROM main.all_types) \n-ON         ((ref_9.\"smallint\" = ref_8.\"smallint\")) \n-\n+SELECT     ref_8.uint AS c0,\n+           Argmin(Cast(ref_8.\"timestamp\" AS TIMESTAMP), Cast(ref_10.\"timestamp\" AS TIMESTAMP)) OVER (partition BY ref_10.\"nested_int_array\", ref_10.\"timestamp\" ORDER BY ref_8.hugeint)  AS c1\n+FROM main.all_types AS ref_8\n+INNER JOIN main.all_types AS ref_9\n+INNER JOIN main.all_types AS ref_10\n+ON        ( ref_10.dec38_10 IS NOT NULL)\n+                      OR         EXISTS\n+                                 ( SELECT ref_9.\"float\" FROM main.all_types)\n+ON         ((ref_9.\"smallint\" = ref_8.\"smallint\"))\n \n # original query from fuzzer\n statement ok\n SELECT ref_8.uint AS c0, CASE  WHEN ((min_by(CAST(ref_8.\"varchar\" AS VARCHAR), CAST(ref_3.\"varchar\" AS VARCHAR)) OVER (PARTITION BY subq_3.c1, ref_10.double_array ORDER BY ref_7.\"varchar\") ~~* ref_10.\"varchar\")) THEN (argmin(CAST(ref_6.\"timestamp\" AS TIMESTAMP), CAST(ref_10.\"timestamp\" AS TIMESTAMP)) OVER (PARTITION BY ref_10.nested_int_array, ref_10.\"timestamp\" ORDER BY ref_8.hugeint)) ELSE argmin(CAST(ref_6.\"timestamp\" AS TIMESTAMP), CAST(ref_10.\"timestamp\" AS TIMESTAMP)) OVER (PARTITION BY ref_10.nested_int_array, ref_10.\"timestamp\" ORDER BY ref_8.hugeint) END AS c1 FROM main.all_types AS ref_0 INNER JOIN (SELECT ref_1.timestamp_array AS c1 FROM main.all_types AS ref_1 INNER JOIN main.all_types AS ref_2 ON (NULL) WHERE (((CAST(NULL AS VARCHAR) ~~~ CAST(NULL AS VARCHAR)) OR (ref_1.blob IS NOT NULL) OR 0) AND (ref_1.timestamp_ms IS NULL) AND ((SELECT histogram(\"varchar\") FROM main.all_types) IS NOT NULL) AND ((ref_2.timestamp_s IS NULL) OR (((ref_2.\"varchar\" ~~~ ref_1.\"varchar\") OR 1 OR (ref_2.\"varchar\" ~~ (SELECT \"varchar\" FROM main.all_types LIMIT 1 OFFSET 5))) AND (ref_2.\"varchar\" ~~ ref_2.\"varchar\")) OR ((SELECT \"varchar\" FROM main.all_types LIMIT 1 OFFSET 6) !~~* ref_1.\"varchar\")))) AS subq_0 ON (ref_0.\"varchar\") LEFT JOIN main.all_types AS ref_3 LEFT JOIN (SELECT ref_4.ubigint AS c0, 13 AS c1, ref_4.\"time\" AS c2, ref_4.\"float\" AS c3, (SELECT double_array FROM main.all_types LIMIT 1 OFFSET 6) AS c4 FROM main.all_types AS ref_4 WHERE NULL) AS subq_1 ON ((ref_3.\"float\" = subq_1.c3)) ON (NULL) INNER JOIN (SELECT ref_5.timestamp_ms AS c4 FROM main.all_types AS ref_5) AS subq_2 LEFT JOIN main.all_types AS ref_6 INNER JOIN main.all_types AS ref_7 ON (((SELECT \"varchar\" FROM main.all_types LIMIT 1 OFFSET 1) ~~* ref_7.\"varchar\")) INNER JOIN main.all_types AS ref_8 INNER JOIN main.all_types AS ref_9 INNER JOIN main.all_types AS ref_10 ON (((ref_9.\"varchar\" !~~* ref_9.\"varchar\") OR (ref_10.dec38_10 IS NOT NULL) OR EXISTS(SELECT ref_9.\"float\" AS c0, ref_9.usmallint AS c1, ref_10.\"bigint\" AS c2, (SELECT bool FROM main.all_types LIMIT 1 OFFSET 5) AS c3, ref_10.nested_int_array AS c4, ref_9.timestamp_ms AS c5, 4 AS c6, ref_11.\"map\" AS c7, (SELECT uint FROM main.all_types LIMIT 1 OFFSET 3) AS c8, ref_9.dec_4_1 AS c9 FROM main.all_types AS ref_11 WHERE (1 AND EXISTS(SELECT ref_10.varchar_array AS c0 FROM main.all_types AS ref_12 WHERE 0 LIMIT 149) AND 1) LIMIT 180))) ON (EXISTS(SELECT ref_8.double_array AS c0, ref_10.\"timestamp\" AS c1, ref_8.uuid AS c2, ref_13.dec_9_4 AS c3, ref_13.\"int\" AS c4, ref_13.timestamp_ns AS c5, ref_8.\"float\" AS c6, 63 AS c7 FROM main.all_types AS ref_13 WHERE (ref_13.\"varchar\" ~~ ref_9.\"varchar\"))) ON ((ref_7.\"smallint\" = ref_8.\"smallint\")) INNER JOIN (SELECT ref_14.\"interval\" AS c1 FROM main.all_types AS ref_14 WHERE ref_14.\"varchar\") AS subq_3 ON (EXISTS(SELECT ref_15.utinyint AS c0 FROM main.all_types AS ref_15 WHERE (ref_9.\"varchar\" ~~* (SELECT \"varchar\" FROM main.all_types LIMIT 1 OFFSET 4)))) ON ((ref_9.\"varchar\" !~~ ref_6.\"varchar\")) ON ((ref_3.timestamp_array = ref_6.timestamp_array))\n \n-\n # https://github.com/duckdb/duckdb-fuzzer/issues/1358\n statement ok\n SELECT subq_0.c6 AS c1, subq_0.c14 AS c2, subq_0.c7 AS c4, subq_0.c4 AS c5 FROM (SELECT (SELECT date FROM main.all_types LIMIT 1 OFFSET 6) AS c3, ref_2.\"time\" AS c4, (SELECT uuid FROM main.all_types LIMIT 1 OFFSET 1) AS c5, ref_3.array_of_structs AS c6, CASE  WHEN (((ref_0.\"varchar\" !~~* ref_1.\"varchar\") OR (ref_5.\"varchar\" ~~~ ref_6.\"varchar\"))) THEN (ref_2.\"bigint\") ELSE ref_2.\"bigint\" END AS c7, rtrim(CAST(CASE  WHEN ((((ref_8.\"varchar\" ~~~ ref_2.\"varchar\") AND (ref_2.\"varchar\" ~~~ ref_0.\"varchar\")) OR (1 AND (ref_7.\"varchar\" ~~ ref_2.\"varchar\")))) THEN (ref_8.\"varchar\") ELSE ref_8.\"varchar\" END AS VARCHAR), CAST(ref_2.\"varchar\" AS VARCHAR)) AS c9, ref_8.ubigint AS c14 FROM main.all_types AS ref_0 INNER JOIN main.all_types AS ref_1 INNER JOIN main.all_types AS ref_2 ON ((ref_1.int_array = ref_2.int_array)) ON (((ref_2.\"varchar\" !~~ ref_1.\"varchar\") OR (ref_1.blob IS NOT NULL))) INNER JOIN main.all_types AS ref_3 INNER JOIN main.all_types AS ref_4 RIGHT JOIN main.all_types AS ref_5 ON ((ref_4.dec_18_6 = ref_5.dec_18_6)) ON (ref_5.\"varchar\") LEFT JOIN main.all_types AS ref_6 RIGHT JOIN main.all_types AS ref_7 INNER JOIN main.all_types AS ref_8 ON ((ref_7.timestamp_array = ref_8.timestamp_array)) ON (1) ON (NULL) ON ((ref_0.dec_18_6 = ref_3.dec_18_6)) WHERE (ref_5.\"varchar\" ^@ (SELECT \"varchar\" FROM main.all_types LIMIT 1 OFFSET 6)) LIMIT 96) AS subq_0 WHERE subq_0.c9\ndiff --git a/test/optimizer/column_lifetime_analyzer/must_visit_operator_expressions_first.test b/test/optimizer/column_lifetime_analyzer/must_visit_operator_expressions_first.test\nnew file mode 100644\nindex 000000000000..5965e3b7af43\n--- /dev/null\n+++ b/test/optimizer/column_lifetime_analyzer/must_visit_operator_expressions_first.test\n@@ -0,0 +1,19 @@\n+# name: test/optimizer/column_lifetime_analyzer/must_visit_operator_expressions_first.test\n+# description: Test column lifetime analyzer\n+# group: [column_lifetime_analyzer]\n+\n+statement ok\n+create table t5 as select (range + 1000) a5, range b5, (range + 50)::INT::VARCHAR || '__suffix__' c5 from range(50);\n+\n+statement ok\n+create table t1 as select range::INT a1, (range + 45)::INT b1, (range)::INT::VARCHAR || '__suffix__' c1 from range(900);\n+\n+\n+query II\n+select a5, c1 from t1, t5 where b5=b1;\n+----\n+1045\t0__suffix__\n+1046\t1__suffix__\n+1047\t2__suffix__\n+1048\t3__suffix__\n+1049\t4__suffix__\ndiff --git a/test/optimizer/deliminator.test b/test/optimizer/deliminator.test\nindex cf450051949b..de5233c94b8b 100644\n--- a/test/optimizer/deliminator.test\n+++ b/test/optimizer/deliminator.test\n@@ -31,6 +31,7 @@ explain SELECT sum(l_extendedprice) / 7.0 AS avg_yearly FROM lineitem, part WHER\n ----\n logical_opt\t<!REGEX>:.*DELIM_JOIN.*\n \n+\n # Q 20: join with JoinType::SINGLE (created when pushing down dependent joins) is converted to LEFT\n query II\n explain SELECT s_name, s_address FROM supplier, nation WHERE s_suppkey IN ( SELECT ps_suppkey FROM partsupp WHERE ps_partkey IN ( SELECT p_partkey FROM part WHERE p_name LIKE 'forest%') AND ps_availqty > ( SELECT 0.5 * sum(l_quantity) FROM lineitem WHERE l_partkey = ps_partkey AND l_suppkey = ps_suppkey AND l_shipdate >= CAST('1994-01-01' AS date) AND l_shipdate < CAST('1995-01-01' AS date))) AND s_nationkey = n_nationkey AND n_name = 'CANADA' ORDER BY s_name;\ndiff --git a/test/optimizer/joins/pushdown_semi_anti.test b/test/optimizer/joins/pushdown_semi_anti.test\nnew file mode 100644\nindex 000000000000..6decef39690f\n--- /dev/null\n+++ b/test/optimizer/joins/pushdown_semi_anti.test\n@@ -0,0 +1,29 @@\n+# name: test/optimizer/joins/pushdown_semi_anti.test\n+# description: Verify semi anti joins are pushed down\n+# group: [joins]\n+\n+statement ok\n+create table tbl1 as select range a from range(10000);\n+\n+statement ok\n+create table tbl2 as select range b from range(1000);\n+\n+statement ok\n+create table tbl3 as select range c from range(100);\n+\n+statement ok\n+set disabled_optimizers='statistics_propagation';\n+\n+query II\n+EXPLAIN select * from tbl1, tbl2 where b in (select * from tbl3) and tbl1.a = tbl2.b;\n+----\n+physical_plan\t<REGEX>:.*INNER.*SEMI.*\n+\n+statement ok\n+set disabled_optimizers='statistics_propagation,join_order';\n+\n+# make sure non-optimized plan has semi on top of the inner\n+query II\n+EXPLAIN select * from tbl1, tbl2 where b in (select * from tbl3) and tbl1.a = tbl2.b;\n+----\n+physical_plan\t<REGEX>:.*SEMI.*INNER.*\ndiff --git a/test/sqlite/select4.test_slow b/test/sqlite/select4.test_slow\nindex 25a41e513ba2..39d2fa347397 100644\n--- a/test/sqlite/select4.test_slow\n+++ b/test/sqlite/select4.test_slow\n@@ -48300,4 +48300,3 @@ SELECT c6*856, x5\n    AND c5 in (820,44,696,824,668,723,598)\n ----\n 28 values hashing to 8ceb8232c1e6c7b7f5d87ea5c54e08d0\n-\n",
  "problem_statement": "CASE expressions\n\n",
  "hints_text": "",
  "created_at": "2024-04-24T14:24:47Z"
}