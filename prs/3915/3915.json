{
  "repo": "duckdb/duckdb",
  "pull_number": 3915,
  "instance_id": "duckdb__duckdb-3915",
  "issue_numbers": [
    "3885"
  ],
  "base_commit": "f8c5b215d860506f37d2bd5b49013f172752916d",
  "patch": "diff --git a/src/function/table/system/CMakeLists.txt b/src/function/table/system/CMakeLists.txt\nindex a23748d10b04..df00f9769fbb 100644\n--- a/src/function/table/system/CMakeLists.txt\n+++ b/src/function/table/system/CMakeLists.txt\n@@ -4,6 +4,7 @@ add_library_unity(\n   duckdb_columns.cpp\n   duckdb_constraints.cpp\n   duckdb_dependencies.cpp\n+  duckdb_extensions.cpp\n   duckdb_functions.cpp\n   duckdb_keywords.cpp\n   duckdb_indexes.cpp\ndiff --git a/src/function/table/system/duckdb_extensions.cpp b/src/function/table/system/duckdb_extensions.cpp\nnew file mode 100644\nindex 000000000000..0db911a6930c\n--- /dev/null\n+++ b/src/function/table/system/duckdb_extensions.cpp\n@@ -0,0 +1,146 @@\n+#include \"duckdb/function/table/system_functions.hpp\"\n+\n+#include \"duckdb/common/file_system.hpp\"\n+#include \"duckdb/common/map.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/function/function_set.hpp\"\n+#include \"duckdb/main/client_context.hpp\"\n+#include \"duckdb/main/database.hpp\"\n+#include \"duckdb/main/extension_helper.hpp\"\n+\n+namespace duckdb {\n+\n+struct ExtensionInformation {\n+\tstring name;\n+\tbool loaded = false;\n+\tbool installed = false;\n+\tstring file_path;\n+\tstring description;\n+};\n+\n+struct DuckDBExtensionsData : public GlobalTableFunctionState {\n+\tDuckDBExtensionsData() : offset(0) {\n+\t}\n+\n+\tvector<ExtensionInformation> entries;\n+\tidx_t offset;\n+};\n+\n+static unique_ptr<FunctionData> DuckDBExtensionsBind(ClientContext &context, TableFunctionBindInput &input,\n+                                                     vector<LogicalType> &return_types, vector<string> &names) {\n+\tnames.emplace_back(\"extension_name\");\n+\treturn_types.emplace_back(LogicalType::VARCHAR);\n+\n+\tnames.emplace_back(\"loaded\");\n+\treturn_types.emplace_back(LogicalType::BOOLEAN);\n+\n+\tnames.emplace_back(\"installed\");\n+\treturn_types.emplace_back(LogicalType::BOOLEAN);\n+\n+\tnames.emplace_back(\"install_path\");\n+\treturn_types.emplace_back(LogicalType::VARCHAR);\n+\n+\tnames.emplace_back(\"description\");\n+\treturn_types.emplace_back(LogicalType::VARCHAR);\n+\n+\treturn nullptr;\n+}\n+\n+unique_ptr<GlobalTableFunctionState> DuckDBExtensionsInit(ClientContext &context, TableFunctionInitInput &input) {\n+\tauto result = make_unique<DuckDBExtensionsData>();\n+\n+\tauto &fs = FileSystem::GetFileSystem(context);\n+\tauto &db = DatabaseInstance::GetDatabase(context);\n+\n+\tmap<string, ExtensionInformation> installed_extensions;\n+\tauto extension_count = ExtensionHelper::DefaultExtensionCount();\n+\tfor (idx_t i = 0; i < extension_count; i++) {\n+\t\tauto extension = ExtensionHelper::GetDefaultExtension(i);\n+\t\tExtensionInformation info;\n+\t\tinfo.name = extension.name;\n+\t\tinfo.installed = extension.statically_loaded;\n+\t\tinfo.loaded = false;\n+\t\tinfo.file_path = extension.statically_loaded ? \"(BUILT-IN)\" : string();\n+\t\tinfo.description = extension.description;\n+\t\tinstalled_extensions[info.name] = move(info);\n+\t}\n+\n+\t// scan the install directory for installed extensions\n+\tauto ext_directory = ExtensionHelper::ExtensionDirectory(fs);\n+\tfs.ListFiles(ext_directory, [&](const string &path, bool is_directory) {\n+\t\tif (!StringUtil::EndsWith(path, \".duckdb_extension\")) {\n+\t\t\treturn;\n+\t\t}\n+\t\tExtensionInformation info;\n+\t\tinfo.name = fs.ExtractBaseName(path);\n+\t\tinfo.loaded = false;\n+\t\tinfo.file_path = fs.JoinPath(ext_directory, path);\n+\t\tauto entry = installed_extensions.find(info.name);\n+\t\tif (entry == installed_extensions.end()) {\n+\t\t\tinstalled_extensions[info.name] = move(info);\n+\t\t} else {\n+\t\t\tif (!entry->second.loaded) {\n+\t\t\t\tentry->second.file_path = info.file_path;\n+\t\t\t}\n+\t\t\tentry->second.installed = true;\n+\t\t}\n+\t});\n+\n+\t// now check the list of currently loaded extensions\n+\tauto &loaded_extensions = db.LoadedExtensions();\n+\tfor (auto &ext_name : loaded_extensions) {\n+\t\tauto entry = installed_extensions.find(ext_name);\n+\t\tif (entry == installed_extensions.end()) {\n+\t\t\tExtensionInformation info;\n+\t\t\tinfo.name = ext_name;\n+\t\t\tinfo.loaded = true;\n+\t\t\tinstalled_extensions[ext_name] = move(info);\n+\t\t} else {\n+\t\t\tentry->second.loaded = true;\n+\t\t}\n+\t}\n+\n+\tresult->entries.reserve(installed_extensions.size());\n+\tfor (auto &kv : installed_extensions) {\n+\t\tresult->entries.push_back(move(kv.second));\n+\t}\n+\treturn move(result);\n+}\n+\n+void DuckDBExtensionsFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {\n+\tauto &data = (DuckDBExtensionsData &)*data_p.global_state;\n+\tif (data.offset >= data.entries.size()) {\n+\t\t// finished returning values\n+\t\treturn;\n+\t}\n+\t// start returning values\n+\t// either fill up the chunk or return all the remaining columns\n+\tidx_t count = 0;\n+\twhile (data.offset < data.entries.size() && count < STANDARD_VECTOR_SIZE) {\n+\t\tauto &entry = data.entries[data.offset];\n+\n+\t\t// return values:\n+\t\t// extension_name LogicalType::VARCHAR\n+\t\toutput.SetValue(0, count, Value(entry.name));\n+\t\t// loaded LogicalType::BOOLEAN\n+\t\toutput.SetValue(1, count, Value::BOOLEAN(entry.loaded));\n+\t\t// installed LogicalType::BOOLEAN\n+\t\toutput.SetValue(2, count, !entry.installed && entry.loaded ? Value() : Value::BOOLEAN(entry.installed));\n+\t\t// install_path LogicalType::VARCHAR\n+\t\toutput.SetValue(3, count, Value(entry.file_path));\n+\t\t// description LogicalType::VARCHAR\n+\t\toutput.SetValue(4, count, Value(entry.description));\n+\n+\t\tdata.offset++;\n+\t\tcount++;\n+\t}\n+\toutput.SetCardinality(count);\n+}\n+\n+void DuckDBExtensionsFun::RegisterFunction(BuiltinFunctions &set) {\n+\tTableFunctionSet functions(\"duckdb_extensions\");\n+\tfunctions.AddFunction(TableFunction({}, DuckDBExtensionsFunction, DuckDBExtensionsBind, DuckDBExtensionsInit));\n+\tset.AddFunction(functions);\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/function/table/system_functions.cpp b/src/function/table/system_functions.cpp\nindex d3e709d4aa68..5928ee14bcab 100644\n--- a/src/function/table/system_functions.cpp\n+++ b/src/function/table/system_functions.cpp\n@@ -26,6 +26,7 @@ void BuiltinFunctions::RegisterSQLiteFunctions() {\n \tDuckDBIndexesFun::RegisterFunction(*this);\n \tDuckDBSchemasFun::RegisterFunction(*this);\n \tDuckDBDependenciesFun::RegisterFunction(*this);\n+\tDuckDBExtensionsFun::RegisterFunction(*this);\n \tDuckDBSequencesFun::RegisterFunction(*this);\n \tDuckDBSettingsFun::RegisterFunction(*this);\n \tDuckDBTablesFun::RegisterFunction(*this);\ndiff --git a/src/include/duckdb/function/table/system_functions.hpp b/src/include/duckdb/function/table/system_functions.hpp\nindex 97edda80d831..70fe5f17f8c2 100644\n--- a/src/include/duckdb/function/table/system_functions.hpp\n+++ b/src/include/duckdb/function/table/system_functions.hpp\n@@ -64,6 +64,10 @@ struct DuckDBDependenciesFun {\n \tstatic void RegisterFunction(BuiltinFunctions &set);\n };\n \n+struct DuckDBExtensionsFun {\n+\tstatic void RegisterFunction(BuiltinFunctions &set);\n+};\n+\n struct DuckDBFunctionsFun {\n \tstatic void RegisterFunction(BuiltinFunctions &set);\n };\ndiff --git a/src/include/duckdb/main/database.hpp b/src/include/duckdb/main/database.hpp\nindex 234b86dcd59e..d3282c50faf4 100644\n--- a/src/include/duckdb/main/database.hpp\n+++ b/src/include/duckdb/main/database.hpp\n@@ -44,6 +44,8 @@ class DatabaseInstance : public std::enable_shared_from_this<DatabaseInstance> {\n \n \tDUCKDB_API static DatabaseInstance &GetDatabase(ClientContext &context);\n \n+\tDUCKDB_API const unordered_set<std::string> &LoadedExtensions();\n+\n private:\n \tvoid Initialize(const char *path, DBConfig *config);\n \ndiff --git a/src/include/duckdb/main/extension_helper.hpp b/src/include/duckdb/main/extension_helper.hpp\nindex 52ccb4c89254..9352fed473c0 100644\n--- a/src/include/duckdb/main/extension_helper.hpp\n+++ b/src/include/duckdb/main/extension_helper.hpp\n@@ -16,6 +16,12 @@ class DuckDB;\n \n enum class ExtensionLoadResult : uint8_t { LOADED_EXTENSION = 0, EXTENSION_UNKNOWN = 1, NOT_LOADED = 2 };\n \n+struct DefaultExtension {\n+\tconst char *name;\n+\tconst char *description;\n+\tbool statically_loaded;\n+};\n+\n class ExtensionHelper {\n public:\n \tstatic void LoadAllExtensions(DuckDB &db);\n@@ -25,6 +31,11 @@ class ExtensionHelper {\n \tstatic void InstallExtension(DatabaseInstance &db, const string &extension, bool force_install);\n \tstatic void LoadExternalExtension(DatabaseInstance &db, const string &extension);\n \n+\tstatic string ExtensionDirectory(FileSystem &fs);\n+\n+\tstatic idx_t DefaultExtensionCount();\n+\tstatic DefaultExtension GetDefaultExtension(idx_t index);\n+\n private:\n \tstatic const vector<string> PathComponents();\n \ndiff --git a/src/main/database.cpp b/src/main/database.cpp\nindex 7c9f6f3ce9af..5e95485be598 100644\n--- a/src/main/database.cpp\n+++ b/src/main/database.cpp\n@@ -240,6 +240,10 @@ idx_t DatabaseInstance::NumberOfThreads() {\n \treturn scheduler->NumberOfThreads();\n }\n \n+const unordered_set<std::string> &DatabaseInstance::LoadedExtensions() {\n+\treturn loaded_extensions;\n+}\n+\n idx_t DuckDB::NumberOfThreads() {\n \treturn instance->NumberOfThreads();\n }\ndiff --git a/src/main/extension/extension_helper.cpp b/src/main/extension/extension_helper.cpp\nindex 5ea2f2bffc4e..6c299eebbb00 100644\n--- a/src/main/extension/extension_helper.cpp\n+++ b/src/main/extension/extension_helper.cpp\n@@ -6,31 +6,52 @@\n #include \"duckdb/common/string_util.hpp\"\n \n #if defined(BUILD_ICU_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#define ICU_STATICALLY_LOADED true\n #include \"icu-extension.hpp\"\n+#else\n+#define ICU_STATICALLY_LOADED false\n #endif\n \n #if defined(BUILD_PARQUET_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#define PARQUET_STATICALLY_LOADED true\n #include \"parquet-extension.hpp\"\n+#else\n+#define PARQUET_STATICALLY_LOADED false\n #endif\n \n #if defined(BUILD_TPCH_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#define TPCH_STATICALLY_LOADED true\n #include \"tpch-extension.hpp\"\n+#else\n+#define TPCH_STATICALLY_LOADED false\n #endif\n \n #if defined(BUILD_TPCDS_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#define TPCDS_STATICALLY_LOADED true\n #include \"tpcds-extension.hpp\"\n+#else\n+#define TPCDS_STATICALLY_LOADED false\n #endif\n \n #if defined(BUILD_SUBSTRAIT_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#define SUBSTRAIT_STATICALLY_LOADED true\n #include \"substrait-extension.hpp\"\n+#else\n+#define SUBSTRAIT_STATICALLY_LOADED false\n #endif\n \n #if defined(BUILD_FTS_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#define FTS_STATICALLY_LOADED true\n #include \"fts-extension.hpp\"\n+#else\n+#define FTS_STATICALLY_LOADED false\n #endif\n \n #if defined(BUILD_HTTPFS_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#define HTTPFS_STATICALLY_LOADED true\n #include \"httpfs-extension.hpp\"\n+#else\n+#define HTTPFS_STATICALLY_LOADED false\n #endif\n \n #if defined(BUILD_VISUALIZER_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n@@ -38,7 +59,10 @@\n #endif\n \n #if defined(BUILD_JSON_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#define JSON_STATICALLY_LOADED true\n #include \"json-extension.hpp\"\n+#else\n+#define JSON_STATICALLY_LOADED false\n #endif\n \n #if defined(BUILD_EXCEL_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n@@ -51,6 +75,37 @@\n \n namespace duckdb {\n \n+//===--------------------------------------------------------------------===//\n+// Default Extensions\n+//===--------------------------------------------------------------------===//\n+static DefaultExtension internal_extensions[] = {\n+    {\"icu\", \"Adds support for time zones and collations using the ICU library\", ICU_STATICALLY_LOADED},\n+    {\"parquet\", \"Adds support for reading and writing parquet files\", PARQUET_STATICALLY_LOADED},\n+    {\"tpch\", \"Adds TPC-H data generation and query support\", TPCH_STATICALLY_LOADED},\n+    {\"tpcds\", \"Adds TPC-DS data generation and query support\", TPCDS_STATICALLY_LOADED},\n+    {\"substrait\", \"Adds support for the Substrait integration\", SUBSTRAIT_STATICALLY_LOADED},\n+    {\"fts\", \"Adds support for Full-Text Search Indexes\", FTS_STATICALLY_LOADED},\n+    {\"httpfs\", \"Adds support for reading and writing files over a HTTP(S) connection\", HTTPFS_STATICALLY_LOADED},\n+    {\"json\", \"Adds support for JSON operations\", JSON_STATICALLY_LOADED},\n+    {\"sqlite_scanner\", \"Adds support for reading SQLite database files\", false},\n+    {\"postgres_scanner\", \"Adds support for reading from a Postgres database\", false},\n+    {nullptr, nullptr, false}};\n+\n+idx_t ExtensionHelper::DefaultExtensionCount() {\n+\tidx_t index;\n+\tfor (index = 0; internal_extensions[index].name != nullptr; index++) {\n+\t}\n+\treturn index;\n+}\n+\n+DefaultExtension ExtensionHelper::GetDefaultExtension(idx_t index) {\n+\tD_ASSERT(index < DefaultExtensionCount());\n+\treturn internal_extensions[index];\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// Load Statically Compiled Extension\n+//===--------------------------------------------------------------------===//\n void ExtensionHelper::LoadAllExtensions(DuckDB &db) {\n \tunordered_set<string> extensions {\"parquet\",   \"icu\",        \"tpch\", \"tpcds\", \"fts\",     \"httpfs\",\n \t                                  \"substrait\", \"visualizer\", \"json\", \"excel\", \"sqlsmith\"};\n@@ -59,9 +114,6 @@ void ExtensionHelper::LoadAllExtensions(DuckDB &db) {\n \t}\n }\n \n-//===--------------------------------------------------------------------===//\n-// Load Statically Compiled Extension\n-//===--------------------------------------------------------------------===//\n ExtensionLoadResult ExtensionHelper::LoadExtension(DuckDB &db, const std::string &extension) {\n \treturn LoadExtensionInternal(db, extension, false);\n }\n@@ -85,28 +137,28 @@ ExtensionLoadResult ExtensionHelper::LoadExtensionInternal(DuckDB &db, const std\n \t}\n #endif\n \tif (extension == \"parquet\") {\n-#if defined(BUILD_PARQUET_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#if PARQUET_STATICALLY_LOADED\n \t\tdb.LoadExtension<ParquetExtension>();\n #else\n \t\t// parquet extension required but not build: skip this test\n \t\treturn ExtensionLoadResult::NOT_LOADED;\n #endif\n \t} else if (extension == \"icu\") {\n-#if defined(BUILD_ICU_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#if ICU_STATICALLY_LOADED\n \t\tdb.LoadExtension<ICUExtension>();\n #else\n \t\t// icu extension required but not build: skip this test\n \t\treturn ExtensionLoadResult::NOT_LOADED;\n #endif\n \t} else if (extension == \"tpch\") {\n-#if defined(BUILD_TPCH_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#if TPCH_STATICALLY_LOADED\n \t\tdb.LoadExtension<TPCHExtension>();\n #else\n \t\t// icu extension required but not build: skip this test\n \t\treturn ExtensionLoadResult::NOT_LOADED;\n #endif\n \t} else if (extension == \"substrait\") {\n-#if defined(BUILD_SUBSTRAIT_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#if SUBSTRAIT_STATICALLY_LOADED\n \n \t\tdb.LoadExtension<SubstraitExtension>();\n #else\n@@ -114,21 +166,21 @@ ExtensionLoadResult ExtensionHelper::LoadExtensionInternal(DuckDB &db, const std\n \t\treturn ExtensionLoadResult::NOT_LOADED;\n #endif\n \t} else if (extension == \"tpcds\") {\n-#if defined(BUILD_TPCDS_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#if TPCDS_STATICALLY_LOADED\n \t\tdb.LoadExtension<TPCDSExtension>();\n #else\n \t\t// icu extension required but not build: skip this test\n \t\treturn ExtensionLoadResult::NOT_LOADED;\n #endif\n \t} else if (extension == \"fts\") {\n-#if defined(BUILD_FTS_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#if FTS_STATICALLY_LOADED\n \t\tdb.LoadExtension<FTSExtension>();\n #else\n \t\t// fts extension required but not build: skip this test\n \t\treturn ExtensionLoadResult::NOT_LOADED;\n #endif\n \t} else if (extension == \"httpfs\") {\n-#if defined(BUILD_HTTPFS_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#if HTTPFS_STATICALLY_LOADED\n \t\tdb.LoadExtension<HTTPFsExtension>();\n #else\n \t\treturn ExtensionLoadResult::NOT_LOADED;\n@@ -141,7 +193,7 @@ ExtensionLoadResult ExtensionHelper::LoadExtensionInternal(DuckDB &db, const std\n \t\treturn ExtensionLoadResult::NOT_LOADED;\n #endif\n \t} else if (extension == \"json\") {\n-#if defined(BUILD_JSON_EXTENSION) && !defined(DISABLE_BUILTIN_EXTENSIONS)\n+#if JSON_STATICALLY_LOADED\n \t\tdb.LoadExtension<JSONExtension>();\n #else\n \t\t// json extension required but not build: skip this test\ndiff --git a/src/main/extension/extension_install.cpp b/src/main/extension/extension_install.cpp\nindex c1066a1ba51b..cdb7b996af95 100644\n--- a/src/main/extension/extension_install.cpp\n+++ b/src/main/extension/extension_install.cpp\n@@ -17,13 +17,7 @@ const vector<string> ExtensionHelper::PathComponents() {\n \treturn vector<string> {\".duckdb\", \"extensions\", DuckDB::SourceID(), DuckDB::Platform()};\n }\n \n-void ExtensionHelper::InstallExtension(DatabaseInstance &db, const string &extension, bool force_install) {\n-\tauto &config = DBConfig::GetConfig(db);\n-\tif (!config.enable_external_access) {\n-\t\tthrow PermissionException(\"Installing extensions is disabled through configuration\");\n-\t}\n-\tauto &fs = FileSystem::GetFileSystem(db);\n-\n+string ExtensionHelper::ExtensionDirectory(FileSystem &fs) {\n \tstring local_path = fs.GetHomeDirectory();\n \tif (!fs.DirectoryExists(local_path)) {\n \t\tthrow InternalException(\"Can't find the home directory at \" + local_path);\n@@ -35,6 +29,17 @@ void ExtensionHelper::InstallExtension(DatabaseInstance &db, const string &exten\n \t\t\tfs.CreateDirectory(local_path);\n \t\t}\n \t}\n+\treturn local_path;\n+}\n+\n+void ExtensionHelper::InstallExtension(DatabaseInstance &db, const string &extension, bool force_install) {\n+\tauto &config = DBConfig::GetConfig(db);\n+\tif (!config.enable_external_access) {\n+\t\tthrow PermissionException(\"Installing extensions is disabled through configuration\");\n+\t}\n+\tauto &fs = FileSystem::GetFileSystem(db);\n+\n+\tstring local_path = ExtensionDirectory(fs);\n \n \tauto extension_name = fs.ExtractBaseName(extension);\n \n",
  "test_patch": "diff --git a/test/sql/table_function/duckdb_extensions.test b/test/sql/table_function/duckdb_extensions.test\nnew file mode 100644\nindex 000000000000..6265015f7dc7\n--- /dev/null\n+++ b/test/sql/table_function/duckdb_extensions.test\n@@ -0,0 +1,13 @@\n+# name: test/sql/table_function/duckdb_extensions.test\n+# description: Test duckdb_extensions function\n+# group: [table_function]\n+\n+statement ok\n+SELECT * FROM duckdb_extensions();\n+\n+require tpch\n+\n+query I\n+SELECT extension_name FROM duckdb_extensions() WHERE loaded AND extension_name='tpch';\n+----\n+tpch\n",
  "problem_statement": "feat: function/pragma to list installed / loaded extensions\nThere's currently no way to list which extensions are installed or loaded -- it would be nice to have that information easily accessible.\n",
  "hints_text": "",
  "created_at": "2022-06-20T13:53:35Z"
}