diff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp
index 1d0d6516bb0f..7f0efbad62f6 100644
--- a/src/common/operator/cast_operators.cpp
+++ b/src/common/operator/cast_operators.cpp
@@ -595,13 +595,13 @@ struct DateToStringCast {
 			length += 5;
 			date[0] = -date[0];
 			add_bc = true;
-		} else {
-			// potentially add extra characters depending on length of year
-			year_length += date[0] >= 10000;
-			year_length += date[0] >= 100000;
-			year_length += date[0] >= 1000000;
-			year_length += date[0] >= 10000000;
 		}
+
+		// potentially add extra characters depending on length of year
+		year_length += date[0] >= 10000;
+		year_length += date[0] >= 100000;
+		year_length += date[0] >= 1000000;
+		year_length += date[0] >= 10000000;
 		length += year_length;
 		return length;
 	}
diff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp
index c8f030ccefa6..44cec9e5f5cb 100644
--- a/src/common/types/vector.cpp
+++ b/src/common/types/vector.cpp
@@ -488,11 +488,21 @@ void Vector::Orrify(idx_t count, VectorData &data) {
 	case VectorType::DICTIONARY_VECTOR: {
 		auto &sel = DictionaryVector::SelVector(*this);
 		auto &child = DictionaryVector::Child(*this);
-		child.Normalify(sel, count);
-
-		data.sel = &sel;
-		data.data = FlatVector::GetData(child);
-		data.nullmask = &FlatVector::Nullmask(child);
+		if (child.vector_type == VectorType::FLAT_VECTOR) {
+			data.sel = &sel;
+			data.data = FlatVector::GetData(child);
+			data.nullmask = &FlatVector::Nullmask(child);
+		} else {
+			// dictionary with non-flat child: create a new reference to the child and normalify it
+			auto new_aux = make_unique<VectorChildBuffer>();
+			new_aux->data.Reference(child);
+			new_aux->data.Normalify(sel, count);
+
+			data.sel = &sel;
+			data.data = FlatVector::GetData(new_aux->data);
+			data.nullmask = &FlatVector::Nullmask(new_aux->data);
+			this->auxiliary = move(new_aux);
+		}
 		break;
 	}
 	case VectorType::CONSTANT_VECTOR:
diff --git a/src/function/aggregate/distributive/first.cpp b/src/function/aggregate/distributive/first.cpp
index 4d5a94a8ccdf..4917e5d63e1c 100644
--- a/src/function/aggregate/distributive/first.cpp
+++ b/src/function/aggregate/distributive/first.cpp
@@ -106,7 +106,7 @@ template <class T> static AggregateFunction GetFirstAggregateTemplated(SQLType t
 AggregateFunction FirstFun::GetFunction(SQLType type) {
 	switch (type.id) {
 	case SQLTypeId::BOOLEAN:
-		return GetFirstAggregateTemplated<bool>(type);
+		return GetFirstAggregateTemplated<int8_t>(type);
 	case SQLTypeId::TINYINT:
 		return GetFirstAggregateTemplated<int8_t>(type);
 	case SQLTypeId::SMALLINT:
diff --git a/src/function/scalar/string/caseconvert.cpp b/src/function/scalar/string/caseconvert.cpp
index 57ea75e1a906..be500dc35449 100644
--- a/src/function/scalar/string/caseconvert.cpp
+++ b/src/function/scalar/string/caseconvert.cpp
@@ -11,8 +11,7 @@ using namespace std;
 
 namespace duckdb {
 
-template <bool IS_UPPER>
-static string_t strcase_unicode(Vector &result, const char *input_data, idx_t input_length) {
+template <bool IS_UPPER> static string_t strcase_unicode(Vector &result, const char *input_data, idx_t input_length) {
 	// first figure out the output length
 	// optimization: if only ascii then input_length = output_length
 	idx_t output_length = 0;
@@ -22,11 +21,11 @@ static string_t strcase_unicode(Vector &result, const char *input_data, idx_t in
 			int sz = 0;
 			int codepoint = utf8proc_codepoint(input_data + i, sz);
 			int converted_codepoint = IS_UPPER ? utf8proc_toupper(codepoint) : utf8proc_tolower(codepoint);
-			sz = utf8proc_codepoint_length(converted_codepoint);
-			if (sz < 0) {
+			int new_sz = utf8proc_codepoint_length(converted_codepoint);
+			if (new_sz < 0) {
 				throw InternalException("Invalid UTF8 encountered!");
 			}
-			output_length += sz;
+			output_length += new_sz;
 			i += sz;
 		} else {
 			// ascii
@@ -40,13 +39,13 @@ static string_t strcase_unicode(Vector &result, const char *input_data, idx_t in
 	for (idx_t i = 0; i < input_length;) {
 		if (input_data[i] & 0x80) {
 			// non-ascii character
-			int sz = 0;
+			int sz = 0, new_sz = 0;
 			int codepoint = utf8proc_codepoint(input_data + i, sz);
 			int converted_codepoint = IS_UPPER ? utf8proc_toupper(codepoint) : utf8proc_tolower(codepoint);
-			if (!utf8proc_codepoint_to_utf8(converted_codepoint, sz, result_data)) {
+			if (!utf8proc_codepoint_to_utf8(converted_codepoint, new_sz, result_data)) {
 				throw InternalException("Invalid UTF8 encountered!");
 			}
-			result_data += sz;
+			result_data += new_sz;
 			i += sz;
 		} else {
 			// ascii
@@ -88,7 +87,8 @@ void LowerFun::RegisterFunction(BuiltinFunctions &set) {
 }
 
 void UpperFun::RegisterFunction(BuiltinFunctions &set) {
-	set.AddFunction({"upper", "ucase"}, ScalarFunction({SQLType::VARCHAR}, SQLType::VARCHAR, caseconvert_upper_function));
+	set.AddFunction({"upper", "ucase"},
+	                ScalarFunction({SQLType::VARCHAR}, SQLType::VARCHAR, caseconvert_upper_function));
 }
 
 } // namespace duckdb
diff --git a/src/function/scalar/string/substring.cpp b/src/function/scalar/string/substring.cpp
index dbc8367b75da..faf35bdbd2bb 100644
--- a/src/function/scalar/string/substring.cpp
+++ b/src/function/scalar/string/substring.cpp
@@ -38,8 +38,11 @@ static string_t substring_scalar_function(Vector &result, string_t input, int of
 	}
 	if (ascii_only) {
 		// ascii only
-		length = std::min(offset + length, (int)input_size) - offset;
-		return substring_ascii_only(result, input_data, offset, length);
+		length = std::min(offset + length, (int)input_size);
+		if (offset >= length) {
+			return string_t((uint32_t)0);
+		}
+		return substring_ascii_only(result, input_data, offset, length - offset);
 	}
 
 	// size is at most the input size: alloc it
@@ -84,7 +87,8 @@ static void substring_function(DataChunk &args, ExpressionState &state, Vector &
 }
 
 void SubstringFun::RegisterFunction(BuiltinFunctions &set) {
-	set.AddFunction({"substring", "substr"}, ScalarFunction({SQLType::VARCHAR, SQLType::INTEGER, SQLType::INTEGER}, SQLType::VARCHAR, substring_function));
+	set.AddFunction({"substring", "substr"}, ScalarFunction({SQLType::VARCHAR, SQLType::INTEGER, SQLType::INTEGER},
+	                                                        SQLType::VARCHAR, substring_function));
 }
 
 } // namespace duckdb
diff --git a/src/include/duckdb/planner/expression/bound_cast_expression.hpp b/src/include/duckdb/planner/expression/bound_cast_expression.hpp
index 3671e6ec67e0..8da6035d63e7 100644
--- a/src/include/duckdb/planner/expression/bound_cast_expression.hpp
+++ b/src/include/duckdb/planner/expression/bound_cast_expression.hpp
@@ -26,6 +26,9 @@ class BoundCastExpression : public Expression {
 public:
 	//! Cast an expression to the specified SQL type if required
 	static unique_ptr<Expression> AddCastToType(unique_ptr<Expression> expr, SQLType source_type, SQLType target_type);
+	//! Returns true if a cast is invertible (i.e. CAST(s -> t -> s) = s for all values of s). This is not true for e.g.
+	//! boolean casts, because that can be e.g. -1 -> TRUE -> 1. This is necessary to prevent some optimizer bugs.
+	static bool CastIsInvertible(SQLType source_type, SQLType target_type);
 
 	string ToString() const override;
 
diff --git a/src/optimizer/rule/comparison_simplification.cpp b/src/optimizer/rule/comparison_simplification.cpp
index 2d7c9e9cd4f1..5376157a8f2c 100644
--- a/src/optimizer/rule/comparison_simplification.cpp
+++ b/src/optimizer/rule/comparison_simplification.cpp
@@ -34,9 +34,12 @@ unique_ptr<Expression> ComparisonSimplificationRule::Apply(LogicalOperator &op,
 	    constant_expr->expression_class == ExpressionClass::BOUND_CONSTANT) {
 		//! Here we check if we can apply the expression on the constant side
 		auto cast_expression = (BoundCastExpression *)column_ref_expr;
+		if (!BoundCastExpression::CastIsInvertible(cast_expression->source_type, cast_expression->target_type)) {
+			return nullptr;
+		}
 		auto bound_const_expr = (BoundConstantExpression *)constant_expr;
-		auto new_constant = (BoundConstantExpression *)bound_const_expr->value.TryCastAs(
-		    cast_expression->target_type.id, cast_expression->source_type.id);
+		auto new_constant =
+		    bound_const_expr->value.TryCastAs(cast_expression->target_type.id, cast_expression->source_type.id);
 		if (new_constant) {
 			auto child_expression = move(cast_expression->child);
 			constant_expr->return_type = bound_const_expr->value.type;
diff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp
index 3be52b4ade94..be7a05e09853 100644
--- a/src/planner/binder/statement/bind_create.cpp
+++ b/src/planner/binder/statement/bind_create.cpp
@@ -94,6 +94,11 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {
 			throw BinderException("Cannot create index on a view!");
 		}
 		auto &get = (LogicalGet &)*plan;
+		for (auto &column_id : get.column_ids) {
+			if (column_id == COLUMN_IDENTIFIER_ROW_ID) {
+				throw BinderException("Cannot create an index on the rowid!");
+			}
+		}
 		// this gives us a logical table scan
 		// we take the required columns from here
 		// create the logical operator
diff --git a/src/planner/expression/bound_cast_expression.cpp b/src/planner/expression/bound_cast_expression.cpp
index 5b1d60876d0c..49b4db5f118f 100644
--- a/src/planner/expression/bound_cast_expression.cpp
+++ b/src/planner/expression/bound_cast_expression.cpp
@@ -28,6 +28,25 @@ unique_ptr<Expression> BoundCastExpression::AddCastToType(unique_ptr<Expression>
 	return expr;
 }
 
+bool BoundCastExpression::CastIsInvertible(SQLType source_type, SQLType target_type) {
+	if (source_type.id == SQLTypeId::BOOLEAN || target_type.id == SQLTypeId::BOOLEAN) {
+		return false;
+	}
+	if (source_type.id == SQLTypeId::FLOAT || target_type.id == SQLTypeId::FLOAT) {
+		return false;
+	}
+	if (source_type.id == SQLTypeId::DOUBLE || target_type.id == SQLTypeId::DOUBLE) {
+		return false;
+	}
+	if (source_type.id == SQLTypeId::VARCHAR) {
+		return target_type.id == SQLTypeId::DATE || target_type.id == SQLTypeId::TIMESTAMP;
+	}
+	if (target_type.id == SQLTypeId::VARCHAR) {
+		return source_type.id == SQLTypeId::DATE || source_type.id == SQLTypeId::TIMESTAMP;
+	}
+	return true;
+}
+
 string BoundCastExpression::ToString() const {
 	return "CAST[" + TypeIdToString(return_type) + "](" + child->GetName() + ")";
 }
diff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp
index 2c0df50f1dbd..b2e841587893 100644
--- a/src/storage/data_table.cpp
+++ b/src/storage/data_table.cpp
@@ -120,13 +120,11 @@ bool checkZonemapString(TableScanState &state, TableFilter &table_filter, const
 	case ExpressionType::COMPARE_EQUAL:
 		return min_comp <= 0 && max_comp >= 0;
 	case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
-		return max_comp >= 0;
 	case ExpressionType::COMPARE_GREATERTHAN:
-		return max_comp > 0;
+		return max_comp >= 0;
+	case ExpressionType::COMPARE_LESSTHAN:
 	case ExpressionType::COMPARE_LESSTHANOREQUALTO:
 		return min_comp <= 0;
-	case ExpressionType::COMPARE_LESSTHAN:
-		return min_comp < 0;
 	default:
 		throw NotImplementedException("Operation not implemented");
 	}
diff --git a/src/storage/string_segment.cpp b/src/storage/string_segment.cpp
index 8782317d2aa6..eb1d8ff17139 100644
--- a/src/storage/string_segment.cpp
+++ b/src/storage/string_segment.cpp
@@ -73,9 +73,12 @@ void StringSegment::read_string(string_t *result_data, buffer_handle_set_t &hand
                                 size_t vector_index) {
 	if (string_updates && string_updates[vector_index]) {
 		auto &info = *string_updates[vector_index];
+		while (info.ids[update_idx] < src_idx) {
+			//! We need to catch the update_idx up to the src_idx
+			update_idx++;
+		}
 		if (update_idx < info.count && info.ids[update_idx] == src_idx) {
 			result_data[res_idx] = ReadString(handles, info.block_ids[update_idx], info.offsets[update_idx]);
-			update_idx++;
 		} else {
 			result_data[res_idx] = FetchStringFromDict(handles, baseptr, dict_offset[src_idx]);
 		}
@@ -133,30 +136,29 @@ void StringSegment::Select(ColumnScanState &state, Vector &result, SelectionVect
 			throw NotImplementedException("Unknown comparison type for filter pushed down to table!");
 		}
 	} else {
-		assert(tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHAN ||
-		       tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO);
-		assert(tableFilter[1].comparison_type == ExpressionType::COMPARE_LESSTHAN ||
-		       tableFilter[1].comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO);
-
-		if (tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHAN) {
-			if (tableFilter[1].comparison_type == ExpressionType::COMPARE_LESSTHAN) {
+	    bool isFirstGreater = tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHAN ||
+		       tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO;
+        auto less = isFirstGreater?tableFilter[1]:tableFilter[0];
+        auto greater = isFirstGreater?tableFilter[0]:tableFilter[1];
+		if (greater.comparison_type == ExpressionType::COMPARE_GREATERTHAN) {
+			if (less.comparison_type == ExpressionType::COMPARE_LESSTHAN) {
 				Select_String_Between<GreaterThan, LessThan>(
-				    state.handles, result, baseptr, base_data, sel, tableFilter[0].constant.str_value,
-				    tableFilter[1].constant.str_value, approved_tuple_count, base_nullmask, vector_index);
+				    state.handles, result, baseptr, base_data, sel, greater.constant.str_value,
+				    less.constant.str_value, approved_tuple_count, base_nullmask, vector_index);
 			} else {
 				Select_String_Between<GreaterThan, LessThanEquals>(
-				    state.handles, result, baseptr, base_data, sel, tableFilter[0].constant.str_value,
-				    tableFilter[1].constant.str_value, approved_tuple_count, base_nullmask, vector_index);
+				    state.handles, result, baseptr, base_data, sel, greater.constant.str_value,
+				    less.constant.str_value, approved_tuple_count, base_nullmask, vector_index);
 			}
 		} else {
-			if (tableFilter[1].comparison_type == ExpressionType::COMPARE_LESSTHAN) {
+			if (less.comparison_type == ExpressionType::COMPARE_LESSTHAN) {
 				Select_String_Between<GreaterThanEquals, LessThan>(
-				    state.handles, result, baseptr, base_data, sel, tableFilter[0].constant.str_value,
-				    tableFilter[1].constant.str_value, approved_tuple_count, base_nullmask, vector_index);
+				    state.handles, result, baseptr, base_data, sel, greater.constant.str_value,
+				    less.constant.str_value, approved_tuple_count, base_nullmask, vector_index);
 			} else {
 				Select_String_Between<GreaterThanEquals, LessThanEquals>(
-				    state.handles, result, baseptr, base_data, sel, tableFilter[0].constant.str_value,
-				    tableFilter[1].constant.str_value, approved_tuple_count, base_nullmask, vector_index);
+				    state.handles, result, baseptr, base_data, sel, greater.constant.str_value,
+				    less.constant.str_value, approved_tuple_count, base_nullmask, vector_index);
 			}
 		}
 	}
@@ -445,7 +447,9 @@ idx_t StringSegment::Append(SegmentStatistics &stats, Vector &data, idx_t offset
 static void update_min_max(string value, char *__restrict min, char *__restrict max) {
 	//! we can only fit 8 bytes, so we might need to trim our string
 	size_t value_size = value.size() > 7 ? 7 : value.size();
-	if (min[0] == '\0' && max[0] == '\0') {
+	//! This marks the min/max was not initialized
+	char marker = '1';
+	if (min[0] == '\0' && min[1] == marker && max[0] == '\0' && max[1] == marker) {
 		size_t min_end = value.copy(min, value_size);
 		size_t max_end = value.copy(max, value_size);
 		for (size_t i = min_end; i < 8; i++) {
@@ -698,6 +702,14 @@ string_update_info_t StringSegment::MergeStringUpdate(SegmentStatistics &stats,
 	// perform a merge between the new and old indexes
 	auto strings = FlatVector::GetData<string_t>(update);
 	auto &update_nullmask = FlatVector::Nullmask(update);
+	//! Check if we need to update the segment's nullmask
+	for (idx_t i = 0; i < update_count; i++) {
+		if (!update_nullmask[i]) {
+			auto min = (char *)stats.minimum.get();
+			auto max = (char *)stats.maximum.get();
+			update_min_max(strings[i].GetData(), min, max);
+		}
+	}
 	auto pick_new = [&](idx_t id, idx_t idx, idx_t count) {
 		info->ids[count] = id;
 		if (!update_nullmask[idx]) {
diff --git a/src/storage/table/column_segment.cpp b/src/storage/table/column_segment.cpp
index 90c209857b34..dcac2bc78fd1 100644
--- a/src/storage/table/column_segment.cpp
+++ b/src/storage/table/column_segment.cpp
@@ -96,8 +96,12 @@ void SegmentStatistics::Reset() {
 		initialize_max_min<double>(minimum.get(), maximum.get());
 		break;
 	case TypeId::VARCHAR: {
+		//! This marks the min/max was not initialized
+		char marker = '1';
 		memset(minimum.get(), padding, min_max_size);
 		memset(maximum.get(), padding, min_max_size);
+		minimum.get()[1] = marker;
+		maximum.get()[1] = marker;
 		break;
 	}
 	default:
diff --git a/tools/shell/linenoise.c b/tools/shell/linenoise.c
index 265cb3cf4ed0..27a7f172d1e0 100644
--- a/tools/shell/linenoise.c
+++ b/tools/shell/linenoise.c
@@ -568,7 +568,7 @@ static void refreshSingleLine(struct linenoiseState *l) {
 					break;
 				} else {
 					// we did not pass the cursor yet! remove characters from the start until it fits again
-					while(total_render_width >= remaining_render_width) {
+					while (total_render_width >= remaining_render_width) {
 						size_t start_char_width = utf8proc_render_width(buf, len, start_pos);
 						size_t new_start = utf8proc_next_grapheme_cluster(buf, len, start_pos);
 						total_render_width -= new_start - start_pos;
@@ -909,6 +909,7 @@ static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen,
 		}
 
 		switch (c) {
+		case 10:
 		case ENTER: /* enter */
 			history_len--;
 			free(history[history_len]);
@@ -1024,10 +1025,6 @@ static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen,
 				}
 			}
 			break;
-		default:
-			if (linenoiseEditInsert(&l, c))
-				return -1;
-			break;
 		case CTRL_U: /* Ctrl+u, delete the whole line. */
 			buf[0] = '\0';
 			l.pos = l.len = 0;
@@ -1051,6 +1048,10 @@ static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen,
 		case CTRL_W: /* ctrl+w, delete previous word */
 			linenoiseEditDeletePrevWord(&l);
 			break;
+		default:
+			if (linenoiseEditInsert(&l, c))
+				return -1;
+			break;
 		}
 	}
 	return l.len;
