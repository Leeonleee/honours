{
  "repo": "duckdb/duckdb",
  "pull_number": 593,
  "instance_id": "duckdb__duckdb-593",
  "issue_numbers": [
    "581",
    "588"
  ],
  "base_commit": "ed92e9c555299378c86d4342c94663e65ab8eef7",
  "patch": "diff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp\nindex 1d0d6516bb0f..7f0efbad62f6 100644\n--- a/src/common/operator/cast_operators.cpp\n+++ b/src/common/operator/cast_operators.cpp\n@@ -595,13 +595,13 @@ struct DateToStringCast {\n \t\t\tlength += 5;\n \t\t\tdate[0] = -date[0];\n \t\t\tadd_bc = true;\n-\t\t} else {\n-\t\t\t// potentially add extra characters depending on length of year\n-\t\t\tyear_length += date[0] >= 10000;\n-\t\t\tyear_length += date[0] >= 100000;\n-\t\t\tyear_length += date[0] >= 1000000;\n-\t\t\tyear_length += date[0] >= 10000000;\n \t\t}\n+\n+\t\t// potentially add extra characters depending on length of year\n+\t\tyear_length += date[0] >= 10000;\n+\t\tyear_length += date[0] >= 100000;\n+\t\tyear_length += date[0] >= 1000000;\n+\t\tyear_length += date[0] >= 10000000;\n \t\tlength += year_length;\n \t\treturn length;\n \t}\ndiff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp\nindex c8f030ccefa6..44cec9e5f5cb 100644\n--- a/src/common/types/vector.cpp\n+++ b/src/common/types/vector.cpp\n@@ -488,11 +488,21 @@ void Vector::Orrify(idx_t count, VectorData &data) {\n \tcase VectorType::DICTIONARY_VECTOR: {\n \t\tauto &sel = DictionaryVector::SelVector(*this);\n \t\tauto &child = DictionaryVector::Child(*this);\n-\t\tchild.Normalify(sel, count);\n-\n-\t\tdata.sel = &sel;\n-\t\tdata.data = FlatVector::GetData(child);\n-\t\tdata.nullmask = &FlatVector::Nullmask(child);\n+\t\tif (child.vector_type == VectorType::FLAT_VECTOR) {\n+\t\t\tdata.sel = &sel;\n+\t\t\tdata.data = FlatVector::GetData(child);\n+\t\t\tdata.nullmask = &FlatVector::Nullmask(child);\n+\t\t} else {\n+\t\t\t// dictionary with non-flat child: create a new reference to the child and normalify it\n+\t\t\tauto new_aux = make_unique<VectorChildBuffer>();\n+\t\t\tnew_aux->data.Reference(child);\n+\t\t\tnew_aux->data.Normalify(sel, count);\n+\n+\t\t\tdata.sel = &sel;\n+\t\t\tdata.data = FlatVector::GetData(new_aux->data);\n+\t\t\tdata.nullmask = &FlatVector::Nullmask(new_aux->data);\n+\t\t\tthis->auxiliary = move(new_aux);\n+\t\t}\n \t\tbreak;\n \t}\n \tcase VectorType::CONSTANT_VECTOR:\ndiff --git a/src/function/aggregate/distributive/first.cpp b/src/function/aggregate/distributive/first.cpp\nindex 4d5a94a8ccdf..4917e5d63e1c 100644\n--- a/src/function/aggregate/distributive/first.cpp\n+++ b/src/function/aggregate/distributive/first.cpp\n@@ -106,7 +106,7 @@ template <class T> static AggregateFunction GetFirstAggregateTemplated(SQLType t\n AggregateFunction FirstFun::GetFunction(SQLType type) {\n \tswitch (type.id) {\n \tcase SQLTypeId::BOOLEAN:\n-\t\treturn GetFirstAggregateTemplated<bool>(type);\n+\t\treturn GetFirstAggregateTemplated<int8_t>(type);\n \tcase SQLTypeId::TINYINT:\n \t\treturn GetFirstAggregateTemplated<int8_t>(type);\n \tcase SQLTypeId::SMALLINT:\ndiff --git a/src/function/scalar/string/caseconvert.cpp b/src/function/scalar/string/caseconvert.cpp\nindex 57ea75e1a906..be500dc35449 100644\n--- a/src/function/scalar/string/caseconvert.cpp\n+++ b/src/function/scalar/string/caseconvert.cpp\n@@ -11,8 +11,7 @@ using namespace std;\n \n namespace duckdb {\n \n-template <bool IS_UPPER>\n-static string_t strcase_unicode(Vector &result, const char *input_data, idx_t input_length) {\n+template <bool IS_UPPER> static string_t strcase_unicode(Vector &result, const char *input_data, idx_t input_length) {\n \t// first figure out the output length\n \t// optimization: if only ascii then input_length = output_length\n \tidx_t output_length = 0;\n@@ -22,11 +21,11 @@ static string_t strcase_unicode(Vector &result, const char *input_data, idx_t in\n \t\t\tint sz = 0;\n \t\t\tint codepoint = utf8proc_codepoint(input_data + i, sz);\n \t\t\tint converted_codepoint = IS_UPPER ? utf8proc_toupper(codepoint) : utf8proc_tolower(codepoint);\n-\t\t\tsz = utf8proc_codepoint_length(converted_codepoint);\n-\t\t\tif (sz < 0) {\n+\t\t\tint new_sz = utf8proc_codepoint_length(converted_codepoint);\n+\t\t\tif (new_sz < 0) {\n \t\t\t\tthrow InternalException(\"Invalid UTF8 encountered!\");\n \t\t\t}\n-\t\t\toutput_length += sz;\n+\t\t\toutput_length += new_sz;\n \t\t\ti += sz;\n \t\t} else {\n \t\t\t// ascii\n@@ -40,13 +39,13 @@ static string_t strcase_unicode(Vector &result, const char *input_data, idx_t in\n \tfor (idx_t i = 0; i < input_length;) {\n \t\tif (input_data[i] & 0x80) {\n \t\t\t// non-ascii character\n-\t\t\tint sz = 0;\n+\t\t\tint sz = 0, new_sz = 0;\n \t\t\tint codepoint = utf8proc_codepoint(input_data + i, sz);\n \t\t\tint converted_codepoint = IS_UPPER ? utf8proc_toupper(codepoint) : utf8proc_tolower(codepoint);\n-\t\t\tif (!utf8proc_codepoint_to_utf8(converted_codepoint, sz, result_data)) {\n+\t\t\tif (!utf8proc_codepoint_to_utf8(converted_codepoint, new_sz, result_data)) {\n \t\t\t\tthrow InternalException(\"Invalid UTF8 encountered!\");\n \t\t\t}\n-\t\t\tresult_data += sz;\n+\t\t\tresult_data += new_sz;\n \t\t\ti += sz;\n \t\t} else {\n \t\t\t// ascii\n@@ -88,7 +87,8 @@ void LowerFun::RegisterFunction(BuiltinFunctions &set) {\n }\n \n void UpperFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction({\"upper\", \"ucase\"}, ScalarFunction({SQLType::VARCHAR}, SQLType::VARCHAR, caseconvert_upper_function));\n+\tset.AddFunction({\"upper\", \"ucase\"},\n+\t                ScalarFunction({SQLType::VARCHAR}, SQLType::VARCHAR, caseconvert_upper_function));\n }\n \n } // namespace duckdb\ndiff --git a/src/function/scalar/string/substring.cpp b/src/function/scalar/string/substring.cpp\nindex dbc8367b75da..faf35bdbd2bb 100644\n--- a/src/function/scalar/string/substring.cpp\n+++ b/src/function/scalar/string/substring.cpp\n@@ -38,8 +38,11 @@ static string_t substring_scalar_function(Vector &result, string_t input, int of\n \t}\n \tif (ascii_only) {\n \t\t// ascii only\n-\t\tlength = std::min(offset + length, (int)input_size) - offset;\n-\t\treturn substring_ascii_only(result, input_data, offset, length);\n+\t\tlength = std::min(offset + length, (int)input_size);\n+\t\tif (offset >= length) {\n+\t\t\treturn string_t((uint32_t)0);\n+\t\t}\n+\t\treturn substring_ascii_only(result, input_data, offset, length - offset);\n \t}\n \n \t// size is at most the input size: alloc it\n@@ -84,7 +87,8 @@ static void substring_function(DataChunk &args, ExpressionState &state, Vector &\n }\n \n void SubstringFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction({\"substring\", \"substr\"}, ScalarFunction({SQLType::VARCHAR, SQLType::INTEGER, SQLType::INTEGER}, SQLType::VARCHAR, substring_function));\n+\tset.AddFunction({\"substring\", \"substr\"}, ScalarFunction({SQLType::VARCHAR, SQLType::INTEGER, SQLType::INTEGER},\n+\t                                                        SQLType::VARCHAR, substring_function));\n }\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression/bound_cast_expression.hpp b/src/include/duckdb/planner/expression/bound_cast_expression.hpp\nindex 3671e6ec67e0..8da6035d63e7 100644\n--- a/src/include/duckdb/planner/expression/bound_cast_expression.hpp\n+++ b/src/include/duckdb/planner/expression/bound_cast_expression.hpp\n@@ -26,6 +26,9 @@ class BoundCastExpression : public Expression {\n public:\n \t//! Cast an expression to the specified SQL type if required\n \tstatic unique_ptr<Expression> AddCastToType(unique_ptr<Expression> expr, SQLType source_type, SQLType target_type);\n+\t//! Returns true if a cast is invertible (i.e. CAST(s -> t -> s) = s for all values of s). This is not true for e.g.\n+\t//! boolean casts, because that can be e.g. -1 -> TRUE -> 1. This is necessary to prevent some optimizer bugs.\n+\tstatic bool CastIsInvertible(SQLType source_type, SQLType target_type);\n \n \tstring ToString() const override;\n \ndiff --git a/src/optimizer/rule/comparison_simplification.cpp b/src/optimizer/rule/comparison_simplification.cpp\nindex 2d7c9e9cd4f1..5376157a8f2c 100644\n--- a/src/optimizer/rule/comparison_simplification.cpp\n+++ b/src/optimizer/rule/comparison_simplification.cpp\n@@ -34,9 +34,12 @@ unique_ptr<Expression> ComparisonSimplificationRule::Apply(LogicalOperator &op,\n \t    constant_expr->expression_class == ExpressionClass::BOUND_CONSTANT) {\n \t\t//! Here we check if we can apply the expression on the constant side\n \t\tauto cast_expression = (BoundCastExpression *)column_ref_expr;\n+\t\tif (!BoundCastExpression::CastIsInvertible(cast_expression->source_type, cast_expression->target_type)) {\n+\t\t\treturn nullptr;\n+\t\t}\n \t\tauto bound_const_expr = (BoundConstantExpression *)constant_expr;\n-\t\tauto new_constant = (BoundConstantExpression *)bound_const_expr->value.TryCastAs(\n-\t\t    cast_expression->target_type.id, cast_expression->source_type.id);\n+\t\tauto new_constant =\n+\t\t    bound_const_expr->value.TryCastAs(cast_expression->target_type.id, cast_expression->source_type.id);\n \t\tif (new_constant) {\n \t\t\tauto child_expression = move(cast_expression->child);\n \t\t\tconstant_expr->return_type = bound_const_expr->value.type;\ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex 3be52b4ade94..be7a05e09853 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -94,6 +94,11 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {\n \t\t\tthrow BinderException(\"Cannot create index on a view!\");\n \t\t}\n \t\tauto &get = (LogicalGet &)*plan;\n+\t\tfor (auto &column_id : get.column_ids) {\n+\t\t\tif (column_id == COLUMN_IDENTIFIER_ROW_ID) {\n+\t\t\t\tthrow BinderException(\"Cannot create an index on the rowid!\");\n+\t\t\t}\n+\t\t}\n \t\t// this gives us a logical table scan\n \t\t// we take the required columns from here\n \t\t// create the logical operator\ndiff --git a/src/planner/expression/bound_cast_expression.cpp b/src/planner/expression/bound_cast_expression.cpp\nindex 5b1d60876d0c..49b4db5f118f 100644\n--- a/src/planner/expression/bound_cast_expression.cpp\n+++ b/src/planner/expression/bound_cast_expression.cpp\n@@ -28,6 +28,25 @@ unique_ptr<Expression> BoundCastExpression::AddCastToType(unique_ptr<Expression>\n \treturn expr;\n }\n \n+bool BoundCastExpression::CastIsInvertible(SQLType source_type, SQLType target_type) {\n+\tif (source_type.id == SQLTypeId::BOOLEAN || target_type.id == SQLTypeId::BOOLEAN) {\n+\t\treturn false;\n+\t}\n+\tif (source_type.id == SQLTypeId::FLOAT || target_type.id == SQLTypeId::FLOAT) {\n+\t\treturn false;\n+\t}\n+\tif (source_type.id == SQLTypeId::DOUBLE || target_type.id == SQLTypeId::DOUBLE) {\n+\t\treturn false;\n+\t}\n+\tif (source_type.id == SQLTypeId::VARCHAR) {\n+\t\treturn target_type.id == SQLTypeId::DATE || target_type.id == SQLTypeId::TIMESTAMP;\n+\t}\n+\tif (target_type.id == SQLTypeId::VARCHAR) {\n+\t\treturn source_type.id == SQLTypeId::DATE || source_type.id == SQLTypeId::TIMESTAMP;\n+\t}\n+\treturn true;\n+}\n+\n string BoundCastExpression::ToString() const {\n \treturn \"CAST[\" + TypeIdToString(return_type) + \"](\" + child->GetName() + \")\";\n }\ndiff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp\nindex 2c0df50f1dbd..b2e841587893 100644\n--- a/src/storage/data_table.cpp\n+++ b/src/storage/data_table.cpp\n@@ -120,13 +120,11 @@ bool checkZonemapString(TableScanState &state, TableFilter &table_filter, const\n \tcase ExpressionType::COMPARE_EQUAL:\n \t\treturn min_comp <= 0 && max_comp >= 0;\n \tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n-\t\treturn max_comp >= 0;\n \tcase ExpressionType::COMPARE_GREATERTHAN:\n-\t\treturn max_comp > 0;\n+\t\treturn max_comp >= 0;\n+\tcase ExpressionType::COMPARE_LESSTHAN:\n \tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n \t\treturn min_comp <= 0;\n-\tcase ExpressionType::COMPARE_LESSTHAN:\n-\t\treturn min_comp < 0;\n \tdefault:\n \t\tthrow NotImplementedException(\"Operation not implemented\");\n \t}\ndiff --git a/src/storage/string_segment.cpp b/src/storage/string_segment.cpp\nindex 8782317d2aa6..eb1d8ff17139 100644\n--- a/src/storage/string_segment.cpp\n+++ b/src/storage/string_segment.cpp\n@@ -73,9 +73,12 @@ void StringSegment::read_string(string_t *result_data, buffer_handle_set_t &hand\n                                 size_t vector_index) {\n \tif (string_updates && string_updates[vector_index]) {\n \t\tauto &info = *string_updates[vector_index];\n+\t\twhile (info.ids[update_idx] < src_idx) {\n+\t\t\t//! We need to catch the update_idx up to the src_idx\n+\t\t\tupdate_idx++;\n+\t\t}\n \t\tif (update_idx < info.count && info.ids[update_idx] == src_idx) {\n \t\t\tresult_data[res_idx] = ReadString(handles, info.block_ids[update_idx], info.offsets[update_idx]);\n-\t\t\tupdate_idx++;\n \t\t} else {\n \t\t\tresult_data[res_idx] = FetchStringFromDict(handles, baseptr, dict_offset[src_idx]);\n \t\t}\n@@ -133,30 +136,29 @@ void StringSegment::Select(ColumnScanState &state, Vector &result, SelectionVect\n \t\t\tthrow NotImplementedException(\"Unknown comparison type for filter pushed down to table!\");\n \t\t}\n \t} else {\n-\t\tassert(tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHAN ||\n-\t\t       tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO);\n-\t\tassert(tableFilter[1].comparison_type == ExpressionType::COMPARE_LESSTHAN ||\n-\t\t       tableFilter[1].comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO);\n-\n-\t\tif (tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHAN) {\n-\t\t\tif (tableFilter[1].comparison_type == ExpressionType::COMPARE_LESSTHAN) {\n+\t    bool isFirstGreater = tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHAN ||\n+\t\t       tableFilter[0].comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO;\n+        auto less = isFirstGreater?tableFilter[1]:tableFilter[0];\n+        auto greater = isFirstGreater?tableFilter[0]:tableFilter[1];\n+\t\tif (greater.comparison_type == ExpressionType::COMPARE_GREATERTHAN) {\n+\t\t\tif (less.comparison_type == ExpressionType::COMPARE_LESSTHAN) {\n \t\t\t\tSelect_String_Between<GreaterThan, LessThan>(\n-\t\t\t\t    state.handles, result, baseptr, base_data, sel, tableFilter[0].constant.str_value,\n-\t\t\t\t    tableFilter[1].constant.str_value, approved_tuple_count, base_nullmask, vector_index);\n+\t\t\t\t    state.handles, result, baseptr, base_data, sel, greater.constant.str_value,\n+\t\t\t\t    less.constant.str_value, approved_tuple_count, base_nullmask, vector_index);\n \t\t\t} else {\n \t\t\t\tSelect_String_Between<GreaterThan, LessThanEquals>(\n-\t\t\t\t    state.handles, result, baseptr, base_data, sel, tableFilter[0].constant.str_value,\n-\t\t\t\t    tableFilter[1].constant.str_value, approved_tuple_count, base_nullmask, vector_index);\n+\t\t\t\t    state.handles, result, baseptr, base_data, sel, greater.constant.str_value,\n+\t\t\t\t    less.constant.str_value, approved_tuple_count, base_nullmask, vector_index);\n \t\t\t}\n \t\t} else {\n-\t\t\tif (tableFilter[1].comparison_type == ExpressionType::COMPARE_LESSTHAN) {\n+\t\t\tif (less.comparison_type == ExpressionType::COMPARE_LESSTHAN) {\n \t\t\t\tSelect_String_Between<GreaterThanEquals, LessThan>(\n-\t\t\t\t    state.handles, result, baseptr, base_data, sel, tableFilter[0].constant.str_value,\n-\t\t\t\t    tableFilter[1].constant.str_value, approved_tuple_count, base_nullmask, vector_index);\n+\t\t\t\t    state.handles, result, baseptr, base_data, sel, greater.constant.str_value,\n+\t\t\t\t    less.constant.str_value, approved_tuple_count, base_nullmask, vector_index);\n \t\t\t} else {\n \t\t\t\tSelect_String_Between<GreaterThanEquals, LessThanEquals>(\n-\t\t\t\t    state.handles, result, baseptr, base_data, sel, tableFilter[0].constant.str_value,\n-\t\t\t\t    tableFilter[1].constant.str_value, approved_tuple_count, base_nullmask, vector_index);\n+\t\t\t\t    state.handles, result, baseptr, base_data, sel, greater.constant.str_value,\n+\t\t\t\t    less.constant.str_value, approved_tuple_count, base_nullmask, vector_index);\n \t\t\t}\n \t\t}\n \t}\n@@ -445,7 +447,9 @@ idx_t StringSegment::Append(SegmentStatistics &stats, Vector &data, idx_t offset\n static void update_min_max(string value, char *__restrict min, char *__restrict max) {\n \t//! we can only fit 8 bytes, so we might need to trim our string\n \tsize_t value_size = value.size() > 7 ? 7 : value.size();\n-\tif (min[0] == '\\0' && max[0] == '\\0') {\n+\t//! This marks the min/max was not initialized\n+\tchar marker = '1';\n+\tif (min[0] == '\\0' && min[1] == marker && max[0] == '\\0' && max[1] == marker) {\n \t\tsize_t min_end = value.copy(min, value_size);\n \t\tsize_t max_end = value.copy(max, value_size);\n \t\tfor (size_t i = min_end; i < 8; i++) {\n@@ -698,6 +702,14 @@ string_update_info_t StringSegment::MergeStringUpdate(SegmentStatistics &stats,\n \t// perform a merge between the new and old indexes\n \tauto strings = FlatVector::GetData<string_t>(update);\n \tauto &update_nullmask = FlatVector::Nullmask(update);\n+\t//! Check if we need to update the segment's nullmask\n+\tfor (idx_t i = 0; i < update_count; i++) {\n+\t\tif (!update_nullmask[i]) {\n+\t\t\tauto min = (char *)stats.minimum.get();\n+\t\t\tauto max = (char *)stats.maximum.get();\n+\t\t\tupdate_min_max(strings[i].GetData(), min, max);\n+\t\t}\n+\t}\n \tauto pick_new = [&](idx_t id, idx_t idx, idx_t count) {\n \t\tinfo->ids[count] = id;\n \t\tif (!update_nullmask[idx]) {\ndiff --git a/src/storage/table/column_segment.cpp b/src/storage/table/column_segment.cpp\nindex 90c209857b34..dcac2bc78fd1 100644\n--- a/src/storage/table/column_segment.cpp\n+++ b/src/storage/table/column_segment.cpp\n@@ -96,8 +96,12 @@ void SegmentStatistics::Reset() {\n \t\tinitialize_max_min<double>(minimum.get(), maximum.get());\n \t\tbreak;\n \tcase TypeId::VARCHAR: {\n+\t\t//! This marks the min/max was not initialized\n+\t\tchar marker = '1';\n \t\tmemset(minimum.get(), padding, min_max_size);\n \t\tmemset(maximum.get(), padding, min_max_size);\n+\t\tminimum.get()[1] = marker;\n+\t\tmaximum.get()[1] = marker;\n \t\tbreak;\n \t}\n \tdefault:\ndiff --git a/tools/shell/linenoise.c b/tools/shell/linenoise.c\nindex 265cb3cf4ed0..27a7f172d1e0 100644\n--- a/tools/shell/linenoise.c\n+++ b/tools/shell/linenoise.c\n@@ -568,7 +568,7 @@ static void refreshSingleLine(struct linenoiseState *l) {\n \t\t\t\t\tbreak;\n \t\t\t\t} else {\n \t\t\t\t\t// we did not pass the cursor yet! remove characters from the start until it fits again\n-\t\t\t\t\twhile(total_render_width >= remaining_render_width) {\n+\t\t\t\t\twhile (total_render_width >= remaining_render_width) {\n \t\t\t\t\t\tsize_t start_char_width = utf8proc_render_width(buf, len, start_pos);\n \t\t\t\t\t\tsize_t new_start = utf8proc_next_grapheme_cluster(buf, len, start_pos);\n \t\t\t\t\t\ttotal_render_width -= new_start - start_pos;\n@@ -909,6 +909,7 @@ static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen,\n \t\t}\n \n \t\tswitch (c) {\n+\t\tcase 10:\n \t\tcase ENTER: /* enter */\n \t\t\thistory_len--;\n \t\t\tfree(history[history_len]);\n@@ -1024,10 +1025,6 @@ static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen,\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n-\t\tdefault:\n-\t\t\tif (linenoiseEditInsert(&l, c))\n-\t\t\t\treturn -1;\n-\t\t\tbreak;\n \t\tcase CTRL_U: /* Ctrl+u, delete the whole line. */\n \t\t\tbuf[0] = '\\0';\n \t\t\tl.pos = l.len = 0;\n@@ -1051,6 +1048,10 @@ static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen,\n \t\tcase CTRL_W: /* ctrl+w, delete previous word */\n \t\t\tlinenoiseEditDeletePrevWord(&l);\n \t\t\tbreak;\n+\t\tdefault:\n+\t\t\tif (linenoiseEditInsert(&l, c))\n+\t\t\t\treturn -1;\n+\t\t\tbreak;\n \t\t}\n \t}\n \treturn l.len;\n",
  "test_patch": "diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp\nindex e265d5983f4c..e757601126a6 100644\n--- a/test/rigger/test_rigger.cpp\n+++ b/test/rigger/test_rigger.cpp\n@@ -540,4 +540,103 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tresult = con.Query(\"SELECT REVERSE('S\u0308a\ufe0d');\");\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {\"a\ufe0dS\u0308\"}));\n \t}\n+\tSECTION(\"571\") {\n+\t\t// Incorrect result for BETWEEN query that casts column to boolean #571\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (-1);\"));\n+\t\tcon.Query(\"explain SELECT t0.c0 FROM t0 WHERE NOT (0 BETWEEN 0 AND t0.c0::BOOL);\")->Print();\n+\n+\t\tresult = con.Query(\"SELECT t0.c0 FROM t0 WHERE NOT (0 BETWEEN 0 AND t0.c0::BOOL);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t}\n+\tSECTION(\"579\") {\n+\t\t// Updated value in column is not visible in a SELECT\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 VARCHAR, c1 VARCHAR);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES(0), ('');\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"UPDATE t0 SET c1 = 1;\"));\n+\t\t// -- expected: {1}, actual: {''}\n+\t\tresult = con.Query(\"SELECT t0.c1 FROM t0 WHERE '' = t0.c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"1\"}));\n+\t}\n+\tSECTION(\"580\") {\n+\t\t// SUBSTRING with an invalid start position causes a segmentation fault #580\n+\t\tresult = con.Query(\"SELECT SUBSTRING(0, 3, 0)\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"\"}));\n+\t}\n+\tSECTION(\"581\") {\n+\t\t// DISTINCT malfunctions for BOOLEAN\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 BOOLEAN);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (NULL), (false);\"));\n+\t\tresult = con.Query(\"SELECT DISTINCT t0.c0 FROM t0 ORDER BY 1;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {Value(), false}));\n+\t}\n+\tSECTION(\"583\") {\n+\t\t// Comparing a string with a boolean yields an incorrect result after UPDATE\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 VARCHAR);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"UPDATE t0 SET c0=0;\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"UPDATE t0 SET c0=true;\"));\n+\t\t// -- expected: {true}, actual: {}\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 = true;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"true\"}));\n+\t}\n+\tSECTION(\"584\") {\n+\t\t// A select with BETWEEN and VARCHAR cast results in an incorrect result\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INTEGER);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (-2);\"));\n+\t\tresult = con.Query(\"SELECT t0.c0 FROM t0 WHERE -1 BETWEEN t0.c0::VARCHAR AND 1;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {-2}));\n+\t}\n+\tSECTION(\"585\") {\n+\t\t// Predicate checking for an empty string yields an incorrect result\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 VARCHAR);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (''), (0)\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 = ''; \");\n+\t\t//  -- expected: {''}, actual: {}\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"\"}));\n+\t}\n+\tSECTION(\"586\") {\n+\t\t// NOACCENT.NOCASE comparison with a special character results in a segmentation fault\n+\t\tresult = con.Query(\"SELECT ''='\ua7b1';\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {false}));\n+\t\tresult = con.Query(\"SELECT '' COLLATE NOACCENT.NOCASE='\ua7b1';\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {false}));\n+\t}\n+\tSECTION(\"587\") {\n+\t\t// A negative DATE results in a \"double free or corruption\" crash\n+\t\tresult = con.Query(\"SELECT (DATE '-10000-01-01')::VARCHAR;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"10000-01-01 (BC)\"}));\n+\t}\n+\tSECTION(\"588\") {\n+\t\t// Query with complex ORDER BY causes an incorrect rowid value\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (1), (0), (1);\"));\n+\t\tresult = con.Query(\n+\t\t    \"SELECT t0.rowid FROM t0 WHERE t0.rowid ORDER BY CASE ((t0.c0) ::BOOL) WHEN 1 THEN t0.rowid END;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {1, 2}));\n+\t}\n+\tSECTION(\"589\") {\n+\t\t// Creating an index on rowid results in an internal error \"Failed to bind column reference\"\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_FAIL(con.Query(\"CREATE INDEX i0 ON t0(rowid, c0);\"));\n+\t}\n+\tSECTION(\"590\") {\n+\t\t// Comparison with a DATE yields an incorrect result\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 VARCHAR);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (DATE '2000-01-02');\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE DATE '2000-01-01' < t0.c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"2000-01-02\"}));\n+\t}\n+\tSECTION(\"591\") {\n+\t\t// Subtracting a large integer from a DATE results in a \"double free or corruption\"\n+\t\tresult = con.Query(\"SELECT (- 41756167 + '1969-12-11 032657' ::DATE)::VARCHAR;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"112356-06-10 (BC)\"}));\n+\t}\n+\tSECTION(\"592\"){\n+\t    // Expression with LIKE and comparison causes an assertion failure\n+\t    REQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 VARCHAR);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE c0 LIKE '' AND c0 < true;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t}\n }\n",
  "problem_statement": "DISTINCT malfunctions for BOOLEAN\nConsider the following statements:\r\n```sql\r\nCREATE TABLE t0(c0 BOOLEAN);\r\nINSERT INTO t0 VALUES (NULL), (false);\r\nSELECT DISTINCT t0.c0 FROM t0; -- expected: {NULL, false}, actual: {NULL, NULL}\r\n```\r\nUnexpectedly, the `DISTINCT` results in two `NULL` values being fetched. I found this bug based on the latest master version (ed92e9c555299378c86d4342c94663e65ab8eef7).\nQuery with complex ORDER BY causes an incorrect rowid value\nConsider the following statements:\r\n```sql\r\nCREATE TABLE t0(c0 INT);\r\nINSERT INTO t0 VALUES (1), (0), (1);\r\nSELECT t0.rowid FROM t0 WHERE t0.rowid ORDER BY CASE ((t0.c0) ::BOOL) WHEN 1 THEN t0.rowid END; -- expected: {0, 2}, actual: {140671047175328, 2}\r\n```\r\nUnexpectedly, the `rowid` for the first row is some non-deterministic, large value. I found this based on commit dc352a3729f57252a1f6bfa18077fed9c4598a54.\n",
  "hints_text": "\n",
  "created_at": "2020-04-26T17:07:05Z"
}