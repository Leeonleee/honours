diff --git a/src/parser/parser.cpp b/src/parser/parser.cpp
index ca7e1a71145f..77ad899f1ff4 100644
--- a/src/parser/parser.cpp
+++ b/src/parser/parser.cpp
@@ -369,25 +369,36 @@ vector<SimplifiedToken> Parser::TokenizeError(const string &error_msg) {
 
 	// now iterate over the
 	bool in_quotes = false;
+	char quote_char = '\0';
 	for (idx_t i = error_start; i < error_end; i++) {
-		if (error_msg[i] == '"' || error_msg[i] == '\'') {
-			SimplifiedToken token;
-			token.start = i;
-			if (!in_quotes) {
-				token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_STRING_CONSTANT;
-				token.start++;
-			} else {
+		if (in_quotes) {
+			// in a quote - look for the quote character
+			if (error_msg[i] == quote_char) {
+				SimplifiedToken token;
+				token.start = i;
 				token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER;
+				tokens.push_back(token);
+				in_quotes = false;
+			}
+			if (StringUtil::CharacterIsNewline(error_msg[i])) {
+				// found a newline in a quote, abort the quoted state entirely
+				tokens.pop_back();
+				in_quotes = false;
 			}
+		} else if (error_msg[i] == '"' || error_msg[i] == '\'') {
+			// not quoted and found a quote - enter the quoted state
+			SimplifiedToken token;
+			token.start = i;
+			token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_STRING_CONSTANT;
+			token.start++;
 			tokens.push_back(token);
-			in_quotes = !in_quotes;
+			quote_char = error_msg[i];
+			in_quotes = true;
 		}
 	}
-	if (in_quotes && error_end < error_msg.size()) {
-		SimplifiedToken token;
-		token.start = error_end;
-		token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER;
-		tokens.push_back(token);
+	if (in_quotes) {
+		// unterminated quotes at the end of the error - pop back the quoted state
+		tokens.pop_back();
 	}
 	if (line_pos.IsValid()) {
 		SimplifiedToken token;
diff --git a/tools/shell/shell_renderer.cpp b/tools/shell/shell_renderer.cpp
index d597583b8fd7..43ba0b58e972 100644
--- a/tools/shell/shell_renderer.cpp
+++ b/tools/shell/shell_renderer.cpp
@@ -331,7 +331,7 @@ class ModeExplainRenderer : public RowRenderer {
 	void RenderRow(RowResult &result) override {
 		auto &data = result.data;
 		if (data.size() != 2) {
-			throw std::runtime_error("Invalid usage of explain renderer - must have two data points per row");
+			return;
 		}
 		if (strcmp(data[0], "logical_plan") == 0 || strcmp(data[0], "logical_opt") == 0 ||
 		    strcmp(data[0], "physical_plan") == 0) {
