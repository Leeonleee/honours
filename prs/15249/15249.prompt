You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
DuckDB uncaught exception when using SELECT with EXPLAIN
### What happens?

The latest version of the DuckDB (latest main: v1.1.4-dev2210 1a3d614f0e) crashes when running the following SQL statement: 

```sql
EXPLAIN SELECT 'any_string' IN ?;
```

Here is the stack trace from v1.1.4-dev2210 1a3d614f0e: 

```
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x0000ffffb6c41aac in __GI_abort () at abort.c:79
#2  0x0000ffffb6f048bc in __gnu_cxx::__verbose_terminate_handler() () from /lib/aarch64-linux-gnu/libstdc++.so.6
#3  0x0000ffffb6f0220c in ?? () from /lib/aarch64-linux-gnu/libstdc++.so.6
#4  0x0000ffffb6f02270 in std::terminate() () from /lib/aarch64-linux-gnu/libstdc++.so.6
#5  0x0000ffffb6f02564 in __cxa_throw () from /lib/aarch64-linux-gnu/libstdc++.so.6
#6  0x0000000000498f34 in duckdb_shell::ModeExplainRenderer::RenderRow (this=<optimized out>, result=...) at ../../tools/shell/shell_renderer.cpp:334
#7  0x0000000000469e68 in duckdb_shell::ShellState::RenderRow (this=<optimized out>, renderer=..., result=...) at ../../tools/shell/shell.cpp:1294
#8  0x000000000046e500 in duckdb_shell::ShellState::ExecutePreparedStatement (this=0xfffff8effda8, pStmt=0x14fb34d0) at ../../tools/shell/shell.cpp:1722
#9  0x000000000046ef64 in duckdb_shell::ShellState::ExecuteSQL (this=<optimized out>, zSql=0x14d62830 "EXPLAIN SELECT 'any_string' IN ?;", pzErrMsg=<optimized out>) at ../../tools/shell/shell.cpp:1788
#10 0x0000000000484a84 in duckdb_shell::ShellState::RunOneSqlLine (this=0xfffff8effda8, zSql=0x14d62830 "EXPLAIN SELECT 'any_string' IN ?;") at ../../tools/shell/shell.cpp:4318
#11 0x000000000047f3cc in duckdb_shell::ShellState::ProcessInput (this=<optimized out>) at ../../tools/shell/shell.cpp:4433
#12 0x0000000000488b48 in main (argc=1, argv=0xfffff8f000f8) at ../../tools/shell/shell.cpp:5032
```

The bug is NOT reproducible on the latest release: 19864453f7, only reproducible on the latest main. Must be introduced recently. 

### To Reproduce

### To Reproduce

1. Clone the DuckDB Git from the official repo.
2. Checkout to the latest main (1a3d614f0e).
3. Compile the DuckDB binary by using either `make reldebug` or `make debug`.
4. Run the compiled DuckDB and input the following SQL:

```
EXPLAIN SELECT 'any_string' IN ?;
```

### OS:

Ubuntu 20.04 LTS ARM 64

### DuckDB Version:

 v1.1.4-dev2210 1a3d614f0e

### DuckDB Client:

cli

### Hardware:

_No response_

### Full Name:

Yu Liang

### Affiliation:

Pennsylvania State University

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a source build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/parser/parser.cpp]
1: #include "duckdb/parser/parser.hpp"
2: 
3: #include "duckdb/parser/expression/cast_expression.hpp"
4: #include "duckdb/parser/group_by_node.hpp"
5: #include "duckdb/parser/parsed_data/create_table_info.hpp"
6: #include "duckdb/parser/parser_extension.hpp"
7: #include "duckdb/parser/query_error_context.hpp"
8: #include "duckdb/parser/query_node/select_node.hpp"
9: #include "duckdb/parser/statement/create_statement.hpp"
10: #include "duckdb/parser/statement/extension_statement.hpp"
11: #include "duckdb/parser/statement/select_statement.hpp"
12: #include "duckdb/parser/statement/update_statement.hpp"
13: #include "duckdb/parser/tableref/expressionlistref.hpp"
14: #include "duckdb/parser/transformer.hpp"
15: #include "parser/parser.hpp"
16: #include "postgres_parser.hpp"
17: 
18: namespace duckdb {
19: 
20: Parser::Parser(ParserOptions options_p) : options(options_p) {
21: }
22: 
23: struct UnicodeSpace {
24: 	UnicodeSpace(idx_t pos, idx_t bytes) : pos(pos), bytes(bytes) {
25: 	}
26: 
27: 	idx_t pos;
28: 	idx_t bytes;
29: };
30: 
31: static bool ReplaceUnicodeSpaces(const string &query, string &new_query, vector<UnicodeSpace> &unicode_spaces) {
32: 	if (unicode_spaces.empty()) {
33: 		// no unicode spaces found
34: 		return false;
35: 	}
36: 	idx_t prev = 0;
37: 	for (auto &usp : unicode_spaces) {
38: 		new_query += query.substr(prev, usp.pos - prev);
39: 		new_query += " ";
40: 		prev = usp.pos + usp.bytes;
41: 	}
42: 	new_query += query.substr(prev, query.size() - prev);
43: 	return true;
44: }
45: 
46: static bool IsValidDollarQuotedStringTagFirstChar(const unsigned char &c) {
47: 	// the first character can be between A-Z, a-z, or \200 - \377
48: 	return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c >= 0x80;
49: }
50: 
51: static bool IsValidDollarQuotedStringTagSubsequentChar(const unsigned char &c) {
52: 	// subsequent characters can also be between 0-9
53: 	return IsValidDollarQuotedStringTagFirstChar(c) || (c >= '0' && c <= '9');
54: }
55: 
56: // This function strips unicode space characters from the query and replaces them with regular spaces
57: // It returns true if any unicode space characters were found and stripped
58: // See here for a list of unicode space characters - https://jkorpela.fi/chars/spaces.html
59: bool Parser::StripUnicodeSpaces(const string &query_str, string &new_query) {
60: 	const idx_t NBSP_LEN = 2;
61: 	const idx_t USP_LEN = 3;
62: 	idx_t pos = 0;
63: 	unsigned char quote;
64: 	string_t dollar_quote_tag;
65: 	vector<UnicodeSpace> unicode_spaces;
66: 	auto query = const_uchar_ptr_cast(query_str.c_str());
67: 	auto qsize = query_str.size();
68: 
69: regular:
70: 	for (; pos + 2 < qsize; pos++) {
71: 		if (query[pos] == 0xC2) {
72: 			if (query[pos + 1] == 0xA0) {
73: 				// U+00A0 - C2A0
74: 				unicode_spaces.emplace_back(pos, NBSP_LEN);
75: 			}
76: 		}
77: 		if (query[pos] == 0xE2) {
78: 			if (query[pos + 1] == 0x80) {
79: 				if (query[pos + 2] >= 0x80 && query[pos + 2] <= 0x8B) {
80: 					// U+2000 to U+200B
81: 					// E28080 - E2808B
82: 					unicode_spaces.emplace_back(pos, USP_LEN);
83: 				} else if (query[pos + 2] == 0xAF) {
84: 					// U+202F - E280AF
85: 					unicode_spaces.emplace_back(pos, USP_LEN);
86: 				}
87: 			} else if (query[pos + 1] == 0x81) {
88: 				if (query[pos + 2] == 0x9F) {
89: 					// U+205F - E2819f
90: 					unicode_spaces.emplace_back(pos, USP_LEN);
91: 				} else if (query[pos + 2] == 0xA0) {
92: 					// U+2060 - E281A0
93: 					unicode_spaces.emplace_back(pos, USP_LEN);
94: 				}
95: 			}
96: 		} else if (query[pos] == 0xE3) {
97: 			if (query[pos + 1] == 0x80 && query[pos + 2] == 0x80) {
98: 				// U+3000 - E38080
99: 				unicode_spaces.emplace_back(pos, USP_LEN);
100: 			}
101: 		} else if (query[pos] == 0xEF) {
102: 			if (query[pos + 1] == 0xBB && query[pos + 2] == 0xBF) {
103: 				// U+FEFF - EFBBBF
104: 				unicode_spaces.emplace_back(pos, USP_LEN);
105: 			}
106: 		} else if (query[pos] == '"' || query[pos] == '\'') {
107: 			quote = query[pos];
108: 			pos++;
109: 			goto in_quotes;
110: 		} else if (query[pos] == '$' &&
111: 		           (query[pos + 1] == '$' || IsValidDollarQuotedStringTagFirstChar(query[pos + 1]))) {
112: 			// (optionally tagged) dollar-quoted string
113: 			auto start = &query[++pos];
114: 			for (; pos + 2 < qsize; pos++) {
115: 				if (query[pos] == '$') {
116: 					// end of tag
117: 					dollar_quote_tag =
118: 					    string_t(const_char_ptr_cast(start), NumericCast<uint32_t, int64_t>(&query[pos] - start));
119: 					goto in_dollar_quotes;
120: 				}
121: 
122: 				if (!IsValidDollarQuotedStringTagSubsequentChar(query[pos])) {
123: 					// invalid char in dollar-quoted string, continue as normal
124: 					goto regular;
125: 				}
126: 			}
127: 			goto end;
128: 		} else if (query[pos] == '-' && query[pos + 1] == '-') {
129: 			goto in_comment;
130: 		}
131: 	}
132: 	goto end;
133: in_quotes:
134: 	for (; pos + 1 < qsize; pos++) {
135: 		if (query[pos] == quote) {
136: 			if (query[pos + 1] == quote) {
137: 				// escaped quote
138: 				pos++;
139: 				continue;
140: 			}
141: 			pos++;
142: 			goto regular;
143: 		}
144: 	}
145: 	goto end;
146: in_dollar_quotes:
147: 	for (; pos + 2 < qsize; pos++) {
148: 		if (query[pos] == '$' &&
149: 		    qsize - (pos + 1) >= dollar_quote_tag.GetSize() + 1 && // found '$' and enough space left
150: 		    query[pos + dollar_quote_tag.GetSize() + 1] == '$' &&  // ending '$' at the right spot
151: 		    memcmp(&query[pos + 1], dollar_quote_tag.GetData(), dollar_quote_tag.GetSize()) == 0) { // tags match
152: 			pos += dollar_quote_tag.GetSize() + 1;
153: 			goto regular;
154: 		}
155: 	}
156: 	goto end;
157: in_comment:
158: 	for (; pos < qsize; pos++) {
159: 		if (query[pos] == '\n' || query[pos] == '\r') {
160: 			goto regular;
161: 		}
162: 	}
163: 	goto end;
164: end:
165: 	return ReplaceUnicodeSpaces(query_str, new_query, unicode_spaces);
166: }
167: 
168: vector<string> SplitQueryStringIntoStatements(const string &query) {
169: 	// Break sql string down into sql statements using the tokenizer
170: 	vector<string> query_statements;
171: 	auto tokens = Parser::Tokenize(query);
172: 	idx_t next_statement_start = 0;
173: 	for (idx_t i = 1; i < tokens.size(); ++i) {
174: 		auto &t_prev = tokens[i - 1];
175: 		auto &t = tokens[i];
176: 		if (t_prev.type == SimplifiedTokenType::SIMPLIFIED_TOKEN_OPERATOR) {
177: 			// LCOV_EXCL_START
178: 			for (idx_t c = t_prev.start; c <= t.start; ++c) {
179: 				if (query.c_str()[c] == ';') {
180: 					query_statements.emplace_back(query.substr(next_statement_start, t.start - next_statement_start));
181: 					next_statement_start = tokens[i].start;
182: 				}
183: 			}
184: 			// LCOV_EXCL_STOP
185: 		}
186: 	}
187: 	query_statements.emplace_back(query.substr(next_statement_start, query.size() - next_statement_start));
188: 	return query_statements;
189: }
190: 
191: void Parser::ParseQuery(const string &query) {
192: 	Transformer transformer(options);
193: 	string parser_error;
194: 	optional_idx parser_error_location;
195: 	{
196: 		// check if there are any unicode spaces in the string
197: 		string new_query;
198: 		if (StripUnicodeSpaces(query, new_query)) {
199: 			// there are - strip the unicode spaces and re-run the query
200: 			ParseQuery(new_query);
201: 			return;
202: 		}
203: 	}
204: 	{
205: 		PostgresParser::SetPreserveIdentifierCase(options.preserve_identifier_case);
206: 		bool parsing_succeed = false;
207: 		// Creating a new scope to prevent multiple PostgresParser destructors being called
208: 		// which led to some memory issues
209: 		{
210: 			PostgresParser parser;
211: 			parser.Parse(query);
212: 			if (parser.success) {
213: 				if (!parser.parse_tree) {
214: 					// empty statement
215: 					return;
216: 				}
217: 
218: 				// if it succeeded, we transform the Postgres parse tree into a list of
219: 				// SQLStatements
220: 				transformer.TransformParseTree(parser.parse_tree, statements);
221: 				parsing_succeed = true;
222: 			} else {
223: 				parser_error = parser.error_message;
224: 				if (parser.error_location > 0) {
225: 					parser_error_location = NumericCast<idx_t>(parser.error_location - 1);
226: 				}
227: 			}
228: 		}
229: 		// If DuckDB fails to parse the entire sql string, break the string down into individual statements
230: 		// using ';' as the delimiter so that parser extensions can parse the statement
231: 		if (parsing_succeed) {
232: 			// no-op
233: 			// return here would require refactoring into another function. o.w. will just no-op in order to run wrap up
234: 			// code at the end of this function
235: 		} else if (!options.extensions || options.extensions->empty()) {
236: 			throw ParserException::SyntaxError(query, parser_error, parser_error_location);
237: 		} else {
238: 			// split sql string into statements and re-parse using extension
239: 			auto query_statements = SplitQueryStringIntoStatements(query);
240: 			idx_t stmt_loc = 0;
241: 			for (auto const &query_statement : query_statements) {
242: 				ErrorData another_parser_error;
243: 				// Creating a new scope to allow extensions to use PostgresParser, which is not reentrant
244: 				{
245: 					PostgresParser another_parser;
246: 					another_parser.Parse(query_statement);
247: 					// LCOV_EXCL_START
248: 					// first see if DuckDB can parse this individual query statement
249: 					if (another_parser.success) {
250: 						if (!another_parser.parse_tree) {
251: 							// empty statement
252: 							continue;
253: 						}
254: 						transformer.TransformParseTree(another_parser.parse_tree, statements);
255: 						// important to set in the case of a mixture of DDB and parser ext statements
256: 						statements.back()->stmt_length = query_statement.size() - 1;
257: 						statements.back()->stmt_location = stmt_loc;
258: 						stmt_loc += query_statement.size();
259: 						continue;
260: 					} else {
261: 						another_parser_error = ErrorData(another_parser.error_message);
262: 						if (another_parser.error_location > 0) {
263: 							another_parser_error.AddQueryLocation(
264: 							    NumericCast<idx_t>(another_parser.error_location - 1));
265: 						}
266: 					}
267: 				} // LCOV_EXCL_STOP
268: 				// LCOV_EXCL_START
269: 				// let extensions parse the statement which DuckDB failed to parse
270: 				bool parsed_single_statement = false;
271: 				for (auto &ext : *options.extensions) {
272: 					D_ASSERT(!parsed_single_statement);
273: 					D_ASSERT(ext.parse_function);
274: 					auto result = ext.parse_function(ext.parser_info.get(), query_statement);
275: 					if (result.type == ParserExtensionResultType::PARSE_SUCCESSFUL) {
276: 						auto statement = make_uniq<ExtensionStatement>(ext, std::move(result.parse_data));
277: 						statement->stmt_length = query_statement.size() - 1;
278: 						statement->stmt_location = stmt_loc;
279: 						stmt_loc += query_statement.size();
280: 						statements.push_back(std::move(statement));
281: 						parsed_single_statement = true;
282: 						break;
283: 					} else if (result.type == ParserExtensionResultType::DISPLAY_EXTENSION_ERROR) {
284: 						throw ParserException::SyntaxError(query, result.error, result.error_location);
285: 					} else {
286: 						// We move to the next one!
287: 					}
288: 				}
289: 				if (!parsed_single_statement) {
290: 					throw ParserException::SyntaxError(query, parser_error, parser_error_location);
291: 				} // LCOV_EXCL_STOP
292: 			}
293: 		}
294: 	}
295: 	if (!statements.empty()) {
296: 		auto &last_statement = statements.back();
297: 		last_statement->stmt_length = query.size() - last_statement->stmt_location;
298: 		for (auto &statement : statements) {
299: 			statement->query = query;
300: 			if (statement->type == StatementType::CREATE_STATEMENT) {
301: 				auto &create = statement->Cast<CreateStatement>();
302: 				create.info->sql = query.substr(statement->stmt_location, statement->stmt_length);
303: 			}
304: 		}
305: 	}
306: }
307: 
308: vector<SimplifiedToken> Parser::Tokenize(const string &query) {
309: 	auto pg_tokens = PostgresParser::Tokenize(query);
310: 	vector<SimplifiedToken> result;
311: 	result.reserve(pg_tokens.size());
312: 	for (auto &pg_token : pg_tokens) {
313: 		SimplifiedToken token;
314: 		switch (pg_token.type) {
315: 		case duckdb_libpgquery::PGSimplifiedTokenType::PG_SIMPLIFIED_TOKEN_IDENTIFIER:
316: 			token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER;
317: 			break;
318: 		case duckdb_libpgquery::PGSimplifiedTokenType::PG_SIMPLIFIED_TOKEN_NUMERIC_CONSTANT:
319: 			token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_NUMERIC_CONSTANT;
320: 			break;
321: 		case duckdb_libpgquery::PGSimplifiedTokenType::PG_SIMPLIFIED_TOKEN_STRING_CONSTANT:
322: 			token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_STRING_CONSTANT;
323: 			break;
324: 		case duckdb_libpgquery::PGSimplifiedTokenType::PG_SIMPLIFIED_TOKEN_OPERATOR:
325: 			token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_OPERATOR;
326: 			break;
327: 		case duckdb_libpgquery::PGSimplifiedTokenType::PG_SIMPLIFIED_TOKEN_KEYWORD:
328: 			token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_KEYWORD;
329: 			break;
330: 		// comments are not supported by our tokenizer right now
331: 		case duckdb_libpgquery::PGSimplifiedTokenType::PG_SIMPLIFIED_TOKEN_COMMENT: // LCOV_EXCL_START
332: 			token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_COMMENT;
333: 			break;
334: 		default:
335: 			throw InternalException("Unrecognized token category");
336: 		} // LCOV_EXCL_STOP
337: 		token.start = NumericCast<idx_t>(pg_token.start);
338: 		result.push_back(token);
339: 	}
340: 	return result;
341: }
342: 
343: vector<SimplifiedToken> Parser::TokenizeError(const string &error_msg) {
344: 	idx_t error_start = 0;
345: 	idx_t error_end = error_msg.size();
346: 
347: 	vector<SimplifiedToken> tokens;
348: 	// find "XXX Error:" - this marks the start of the error message
349: 	auto error = StringUtil::Find(error_msg, "Error: ");
350: 	if (error.IsValid()) {
351: 		SimplifiedToken token;
352: 		token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_ERROR;
353: 		token.start = 0;
354: 		tokens.push_back(token);
355: 
356: 		token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER;
357: 		token.start = error.GetIndex() + 6;
358: 		tokens.push_back(token);
359: 
360: 		error_start = error.GetIndex() + 7;
361: 	}
362: 
363: 	// find "LINE (number)" - this marks the end of the message
364: 	auto line_pos = StringUtil::Find(error_msg, "\nLINE ");
365: 	if (line_pos.IsValid()) {
366: 		// tokenize between
367: 		error_end = line_pos.GetIndex();
368: 	}
369: 
370: 	// now iterate over the
371: 	bool in_quotes = false;
372: 	for (idx_t i = error_start; i < error_end; i++) {
373: 		if (error_msg[i] == '"' || error_msg[i] == '\'') {
374: 			SimplifiedToken token;
375: 			token.start = i;
376: 			if (!in_quotes) {
377: 				token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_STRING_CONSTANT;
378: 				token.start++;
379: 			} else {
380: 				token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER;
381: 			}
382: 			tokens.push_back(token);
383: 			in_quotes = !in_quotes;
384: 		}
385: 	}
386: 	if (in_quotes && error_end < error_msg.size()) {
387: 		SimplifiedToken token;
388: 		token.start = error_end;
389: 		token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER;
390: 		tokens.push_back(token);
391: 	}
392: 	if (line_pos.IsValid()) {
393: 		SimplifiedToken token;
394: 		token.start = line_pos.GetIndex() + 1;
395: 		token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_COMMENT;
396: 		tokens.push_back(token);
397: 
398: 		// tokenize the LINE part
399: 		idx_t query_start;
400: 		for (query_start = line_pos.GetIndex() + 6; query_start < error_msg.size(); query_start++) {
401: 			if (error_msg[query_start] != ':' && !StringUtil::CharacterIsDigit(error_msg[query_start])) {
402: 				break;
403: 			}
404: 		}
405: 		if (query_start < error_msg.size()) {
406: 			token.start = query_start;
407: 			token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_IDENTIFIER;
408: 			tokens.push_back(token);
409: 
410: 			idx_t query_end;
411: 			for (query_end = query_start; query_end < error_msg.size(); query_end++) {
412: 				if (error_msg[query_end] == '\n') {
413: 					break;
414: 				}
415: 			}
416: 			// after LINE XXX: comes a caret - look for it
417: 			idx_t caret_position = error_msg.size();
418: 			bool place_caret = false;
419: 			idx_t caret_start = query_end + 1;
420: 			if (caret_start < error_msg.size()) {
421: 				for (idx_t i = caret_start; i < error_msg.size(); i++) {
422: 					if (error_msg[i] == '^') {
423: 						// found the caret
424: 						// to get the caret position in the query we need to
425: 						caret_position = i - caret_start - ((query_start - line_pos.GetIndex()) - 1);
426: 						place_caret = true;
427: 						break;
428: 					}
429: 				}
430: 			}
431: 			// tokenize the actual query
432: 			string query = error_msg.substr(query_start, query_end - query_start);
433: 			auto query_tokens = Tokenize(query);
434: 			for (auto &query_token : query_tokens) {
435: 				if (place_caret) {
436: 					if (query_token.start >= caret_position) {
437: 						// we need to place the caret here
438: 						query_token.start = query_start + caret_position;
439: 						query_token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_ERROR;
440: 						tokens.push_back(query_token);
441: 
442: 						place_caret = false;
443: 						continue;
444: 					}
445: 				}
446: 				query_token.start += query_start;
447: 				tokens.push_back(query_token);
448: 			}
449: 			// FIXME: find the caret position and highlight/bold the identifier it points to
450: 			if (query_end < error_msg.size()) {
451: 				token.start = query_end;
452: 				token.type = SimplifiedTokenType::SIMPLIFIED_TOKEN_ERROR;
453: 				tokens.push_back(token);
454: 			}
455: 		}
456: 	}
457: 	return tokens;
458: }
459: 
460: KeywordCategory ToKeywordCategory(duckdb_libpgquery::PGKeywordCategory type) {
461: 	switch (type) {
462: 	case duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_RESERVED:
463: 		return KeywordCategory::KEYWORD_RESERVED;
464: 	case duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_UNRESERVED:
465: 		return KeywordCategory::KEYWORD_UNRESERVED;
466: 	case duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_TYPE_FUNC:
467: 		return KeywordCategory::KEYWORD_TYPE_FUNC;
468: 	case duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_COL_NAME:
469: 		return KeywordCategory::KEYWORD_COL_NAME;
470: 	case duckdb_libpgquery::PGKeywordCategory::PG_KEYWORD_NONE:
471: 		return KeywordCategory::KEYWORD_NONE;
472: 	default:
473: 		throw InternalException("Unrecognized keyword category");
474: 	}
475: }
476: 
477: KeywordCategory Parser::IsKeyword(const string &text) {
478: 	return ToKeywordCategory(PostgresParser::IsKeyword(text));
479: }
480: 
481: vector<ParserKeyword> Parser::KeywordList() {
482: 	auto keywords = PostgresParser::KeywordList();
483: 	vector<ParserKeyword> result;
484: 	for (auto &kw : keywords) {
485: 		ParserKeyword res;
486: 		res.name = kw.text;
487: 		res.category = ToKeywordCategory(kw.category);
488: 		result.push_back(res);
489: 	}
490: 	return result;
491: }
492: 
493: vector<unique_ptr<ParsedExpression>> Parser::ParseExpressionList(const string &select_list, ParserOptions options) {
494: 	// construct a mock query prefixed with SELECT
495: 	string mock_query = "SELECT " + select_list;
496: 	// parse the query
497: 	Parser parser(options);
498: 	parser.ParseQuery(mock_query);
499: 	// check the statements
500: 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT_STATEMENT) {
501: 		throw ParserException("Expected a single SELECT statement");
502: 	}
503: 	auto &select = parser.statements[0]->Cast<SelectStatement>();
504: 	if (select.node->type != QueryNodeType::SELECT_NODE) {
505: 		throw ParserException("Expected a single SELECT node");
506: 	}
507: 	auto &select_node = select.node->Cast<SelectNode>();
508: 	return std::move(select_node.select_list);
509: }
510: 
511: GroupByNode Parser::ParseGroupByList(const string &group_by, ParserOptions options) {
512: 	// construct a mock SELECT query with our group_by expressions
513: 	string mock_query = StringUtil::Format("SELECT 42 GROUP BY %s", group_by);
514: 	// parse the query
515: 	Parser parser(options);
516: 	parser.ParseQuery(mock_query);
517: 	// check the result
518: 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT_STATEMENT) {
519: 		throw ParserException("Expected a single SELECT statement");
520: 	}
521: 	auto &select = parser.statements[0]->Cast<SelectStatement>();
522: 	D_ASSERT(select.node->type == QueryNodeType::SELECT_NODE);
523: 	auto &select_node = select.node->Cast<SelectNode>();
524: 	return std::move(select_node.groups);
525: }
526: 
527: vector<OrderByNode> Parser::ParseOrderList(const string &select_list, ParserOptions options) {
528: 	// construct a mock query
529: 	string mock_query = "SELECT * FROM tbl ORDER BY " + select_list;
530: 	// parse the query
531: 	Parser parser(options);
532: 	parser.ParseQuery(mock_query);
533: 	// check the statements
534: 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT_STATEMENT) {
535: 		throw ParserException("Expected a single SELECT statement");
536: 	}
537: 	auto &select = parser.statements[0]->Cast<SelectStatement>();
538: 	D_ASSERT(select.node->type == QueryNodeType::SELECT_NODE);
539: 	auto &select_node = select.node->Cast<SelectNode>();
540: 	if (select_node.modifiers.empty() || select_node.modifiers[0]->type != ResultModifierType::ORDER_MODIFIER ||
541: 	    select_node.modifiers.size() != 1) {
542: 		throw ParserException("Expected a single ORDER clause");
543: 	}
544: 	auto &order = select_node.modifiers[0]->Cast<OrderModifier>();
545: 	return std::move(order.orders);
546: }
547: 
548: void Parser::ParseUpdateList(const string &update_list, vector<string> &update_columns,
549:                              vector<unique_ptr<ParsedExpression>> &expressions, ParserOptions options) {
550: 	// construct a mock query
551: 	string mock_query = "UPDATE tbl SET " + update_list;
552: 	// parse the query
553: 	Parser parser(options);
554: 	parser.ParseQuery(mock_query);
555: 	// check the statements
556: 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::UPDATE_STATEMENT) {
557: 		throw ParserException("Expected a single UPDATE statement");
558: 	}
559: 	auto &update = parser.statements[0]->Cast<UpdateStatement>();
560: 	update_columns = std::move(update.set_info->columns);
561: 	expressions = std::move(update.set_info->expressions);
562: }
563: 
564: vector<vector<unique_ptr<ParsedExpression>>> Parser::ParseValuesList(const string &value_list, ParserOptions options) {
565: 	// construct a mock query
566: 	string mock_query = "VALUES " + value_list;
567: 	// parse the query
568: 	Parser parser(options);
569: 	parser.ParseQuery(mock_query);
570: 	// check the statements
571: 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::SELECT_STATEMENT) {
572: 		throw ParserException("Expected a single SELECT statement");
573: 	}
574: 	auto &select = parser.statements[0]->Cast<SelectStatement>();
575: 	if (select.node->type != QueryNodeType::SELECT_NODE) {
576: 		throw ParserException("Expected a single SELECT node");
577: 	}
578: 	auto &select_node = select.node->Cast<SelectNode>();
579: 	if (!select_node.from_table || select_node.from_table->type != TableReferenceType::EXPRESSION_LIST) {
580: 		throw ParserException("Expected a single VALUES statement");
581: 	}
582: 	auto &values_list = select_node.from_table->Cast<ExpressionListRef>();
583: 	return std::move(values_list.values);
584: }
585: 
586: ColumnList Parser::ParseColumnList(const string &column_list, ParserOptions options) {
587: 	string mock_query = "CREATE TABLE tbl (" + column_list + ")";
588: 	Parser parser(options);
589: 	parser.ParseQuery(mock_query);
590: 	if (parser.statements.size() != 1 || parser.statements[0]->type != StatementType::CREATE_STATEMENT) {
591: 		throw ParserException("Expected a single CREATE statement");
592: 	}
593: 	auto &create = parser.statements[0]->Cast<CreateStatement>();
594: 	if (create.info->type != CatalogType::TABLE_ENTRY) {
595: 		throw InternalException("Expected a single CREATE TABLE statement");
596: 	}
597: 	auto &info = create.info->Cast<CreateTableInfo>();
598: 	return std::move(info.columns);
599: }
600: 
601: } // namespace duckdb
[end of src/parser/parser.cpp]
[start of tools/shell/shell_renderer.cpp]
1: #include "shell_renderer.hpp"
2: 
3: #include "shell_state.hpp"
4: #include "duckdb_shell_wrapper.h"
5: #include "sqlite3.h"
6: #include <stdexcept>
7: #include <cstring>
8: 
9: namespace duckdb_shell {
10: 
11: bool ShellRenderer::IsColumnar(RenderMode mode) {
12: 	switch (mode) {
13: 	case RenderMode::COLUMN:
14: 	case RenderMode::TABLE:
15: 	case RenderMode::BOX:
16: 	case RenderMode::MARKDOWN:
17: 	case RenderMode::LATEX:
18: 		return true;
19: 	default:
20: 		return false;
21: 	}
22: }
23: 
24: ShellRenderer::ShellRenderer(ShellState &state)
25:     : state(state), show_header(state.showHeader), col_sep(state.colSeparator), row_sep(state.rowSeparator) {
26: }
27: 
28: //===--------------------------------------------------------------------===//
29: // Column Renderers
30: //===--------------------------------------------------------------------===//
31: ColumnRenderer::ColumnRenderer(ShellState &state) : ShellRenderer(state) {
32: }
33: 
34: void ColumnRenderer::RenderFooter(ColumnarResult &result) {
35: }
36: 
37: void ColumnRenderer::RenderAlignedValue(ColumnarResult &result, idx_t i) {
38: 	idx_t w = result.column_width[i];
39: 	idx_t n = state.RenderLength(result.data[i]);
40: 	state.PrintPadded("", (w - n) / 2);
41: 	state.Print(result.data[i]);
42: 	state.PrintPadded("", (w - n + 1) / 2);
43: }
44: 
45: class ModeColumnRenderer : public ColumnRenderer {
46: public:
47: 	explicit ModeColumnRenderer(ShellState &state) : ColumnRenderer(state) {
48: 	}
49: 
50: 	void RenderHeader(ColumnarResult &result) override {
51: 		if (!show_header) {
52: 			return;
53: 		}
54: 		for (idx_t i = 0; i < result.column_count; i++) {
55: 			state.UTF8WidthPrint(state.out, result.column_width[i], result.data[i], result.right_align[i]);
56: 			state.Print(i == result.column_count - 1 ? "\n" : "  ");
57: 		}
58: 		for (idx_t i = 0; i < result.column_count; i++) {
59: 			state.PrintDashes(result.column_width[i]);
60: 			state.Print(i == result.column_count - 1 ? "\n" : "  ");
61: 		}
62: 	}
63: 
64: 	const char *GetColumnSeparator() override {
65: 		return "  ";
66: 	}
67: 	const char *GetRowSeparator() override {
68: 		return "\n";
69: 	}
70: };
71: 
72: class ModeTableRenderer : public ColumnRenderer {
73: public:
74: 	explicit ModeTableRenderer(ShellState &state) : ColumnRenderer(state) {
75: 	}
76: 
77: 	void RenderHeader(ColumnarResult &result) override {
78: 		state.PrintRowSeparator(result.column_count, "+", result.column_width);
79: 		state.Print("| ");
80: 		for (idx_t i = 0; i < result.column_count; i++) {
81: 			RenderAlignedValue(result, i);
82: 			state.Print(i == result.column_count - 1 ? " |\n" : " | ");
83: 		}
84: 		state.PrintRowSeparator(result.column_count, "+", result.column_width);
85: 	}
86: 
87: 	void RenderFooter(ColumnarResult &result) override {
88: 		state.PrintRowSeparator(result.column_count, "+", result.column_width);
89: 	}
90: 
91: 	const char *GetColumnSeparator() override {
92: 		return " | ";
93: 	}
94: 	const char *GetRowSeparator() override {
95: 		return " |\n";
96: 	}
97: 	const char *GetRowStart() override {
98: 		return "| ";
99: 	}
100: };
101: 
102: class ModeMarkdownRenderer : public ColumnRenderer {
103: public:
104: 	explicit ModeMarkdownRenderer(ShellState &state) : ColumnRenderer(state) {
105: 	}
106: 
107: 	void RenderHeader(ColumnarResult &result) override {
108: 		state.Print(GetRowStart());
109: 		for (idx_t i = 0; i < result.column_count; i++) {
110: 			if (i > 0) {
111: 				state.Print(GetColumnSeparator());
112: 			}
113: 			RenderAlignedValue(result, i);
114: 		}
115: 		state.Print(GetRowSeparator());
116: 		state.PrintMarkdownSeparator(result.column_count, "|", result.types, result.column_width);
117: 	}
118: 
119: 	const char *GetColumnSeparator() override {
120: 		return " | ";
121: 	}
122: 	const char *GetRowSeparator() override {
123: 		return " |\n";
124: 	}
125: 	const char *GetRowStart() override {
126: 		return "| ";
127: 	}
128: };
129: 
130: /*
131: ** UTF8 box-drawing characters.  Imagine box lines like this:
132: **
133: **           1
134: **           |
135: **       4 --+-- 2
136: **           |
137: **           3
138: **
139: ** Each box characters has between 2 and 4 of the lines leading from
140: ** the center.  The characters are here identified by the numbers of
141: ** their corresponding lines.
142: */
143: #define BOX_24   "\342\224\200" /* U+2500 --- */
144: #define BOX_13   "\342\224\202" /* U+2502  |  */
145: #define BOX_23   "\342\224\214" /* U+250c  ,- */
146: #define BOX_34   "\342\224\220" /* U+2510 -,  */
147: #define BOX_12   "\342\224\224" /* U+2514  '- */
148: #define BOX_14   "\342\224\230" /* U+2518 -'  */
149: #define BOX_123  "\342\224\234" /* U+251c  |- */
150: #define BOX_134  "\342\224\244" /* U+2524 -|  */
151: #define BOX_234  "\342\224\254" /* U+252c -,- */
152: #define BOX_124  "\342\224\264" /* U+2534 -'- */
153: #define BOX_1234 "\342\224\274" /* U+253c -|- */
154: 
155: class ModeBoxRenderer : public ColumnRenderer {
156: public:
157: 	explicit ModeBoxRenderer(ShellState &state) : ColumnRenderer(state) {
158: 	}
159: 
160: 	void RenderHeader(ColumnarResult &result) override {
161: 		print_box_row_separator(result.column_count, BOX_23, BOX_234, BOX_34, result.column_width);
162: 		state.Print(BOX_13 " ");
163: 		for (idx_t i = 0; i < result.column_count; i++) {
164: 			RenderAlignedValue(result, i);
165: 			state.Print(i == result.column_count - 1 ? " " BOX_13 "\n" : " " BOX_13 " ");
166: 		}
167: 		print_box_row_separator(result.column_count, BOX_123, BOX_1234, BOX_134, result.column_width);
168: 	}
169: 
170: 	void RenderFooter(ColumnarResult &result) override {
171: 		print_box_row_separator(result.column_count, BOX_12, BOX_124, BOX_14, result.column_width);
172: 	}
173: 
174: 	const char *GetColumnSeparator() override {
175: 		return " " BOX_13 " ";
176: 	}
177: 	const char *GetRowSeparator() override {
178: 		return " " BOX_13 "\n";
179: 	}
180: 	const char *GetRowStart() override {
181: 		return BOX_13 " ";
182: 	}
183: 
184: private:
185: 	/* Draw horizontal line N characters long using unicode box
186: 	** characters
187: 	*/
188: 	void print_box_line(idx_t N) {
189: 		string box_line;
190: 		for (idx_t i = 0; i < N; i++) {
191: 			box_line += BOX_24;
192: 		}
193: 		state.Print(box_line);
194: 	}
195: 
196: 	/*
197: 	** Draw a horizontal separator for a RenderMode::Box table.
198: 	*/
199: 	void print_box_row_separator(int nArg, const char *zSep1, const char *zSep2, const char *zSep3,
200: 	                             const vector<idx_t> &actualWidth) {
201: 		int i;
202: 		if (nArg > 0) {
203: 			state.Print(zSep1);
204: 			print_box_line(actualWidth[0] + 2);
205: 			for (i = 1; i < nArg; i++) {
206: 				state.Print(zSep2);
207: 				print_box_line(actualWidth[i] + 2);
208: 			}
209: 			state.Print(zSep3);
210: 		}
211: 		state.Print("\n");
212: 	}
213: };
214: 
215: class ModeLatexRenderer : public ColumnRenderer {
216: public:
217: 	explicit ModeLatexRenderer(ShellState &state) : ColumnRenderer(state) {
218: 	}
219: 
220: 	void RenderHeader(ColumnarResult &result) override {
221: 		state.Print("\\begin{tabular}{|");
222: 		for (idx_t i = 0; i < result.column_count; i++) {
223: 			if (state.ColumnTypeIsInteger(result.type_names[i])) {
224: 				state.Print("r");
225: 			} else {
226: 				state.Print("l");
227: 			}
228: 		}
229: 		state.Print("|}\n");
230: 		state.Print("\\hline\n");
231: 		for (idx_t i = 0; i < result.column_count; i++) {
232: 			RenderAlignedValue(result, i);
233: 			state.Print(i == result.column_count - 1 ? GetRowSeparator() : GetColumnSeparator());
234: 		}
235: 		state.Print("\\hline\n");
236: 	}
237: 
238: 	void RenderFooter(ColumnarResult &) override {
239: 		state.Print("\\hline\n");
240: 		state.Print("\\end{tabular}\n");
241: 	}
242: 
243: 	const char *GetColumnSeparator() override {
244: 		return " & ";
245: 	}
246: 	const char *GetRowSeparator() override {
247: 		return " \\\\\n";
248: 	}
249: };
250: 
251: unique_ptr<ColumnRenderer> ShellState::GetColumnRenderer() {
252: 	switch (cMode) {
253: 	case RenderMode::COLUMN:
254: 		return unique_ptr<ColumnRenderer>(new ModeColumnRenderer(*this));
255: 	case RenderMode::TABLE:
256: 		return unique_ptr<ColumnRenderer>(new ModeTableRenderer(*this));
257: 	case RenderMode::MARKDOWN:
258: 		return unique_ptr<ColumnRenderer>(new ModeMarkdownRenderer(*this));
259: 	case RenderMode::BOX:
260: 		return unique_ptr<ColumnRenderer>(new ModeBoxRenderer(*this));
261: 	case RenderMode::LATEX:
262: 		return unique_ptr<ColumnRenderer>(new ModeLatexRenderer(*this));
263: 	default:
264: 		throw std::runtime_error("Unsupported mode for GetColumnRenderer");
265: 	}
266: }
267: 
268: //===--------------------------------------------------------------------===//
269: // Row Renderers
270: //===--------------------------------------------------------------------===//
271: RowRenderer::RowRenderer(ShellState &state) : ShellRenderer(state) {
272: }
273: 
274: void RowRenderer::Render(RowResult &result) {
275: 	if (first_row) {
276: 		RenderHeader(result);
277: 		first_row = false;
278: 	}
279: 	RenderRow(result);
280: }
281: 
282: void RowRenderer::RenderHeader(RowResult &result) {
283: }
284: 
285: void RowRenderer::RenderFooter(RowResult &result) {
286: }
287: 
288: class ModeLineRenderer : public RowRenderer {
289: public:
290: 	explicit ModeLineRenderer(ShellState &state) : RowRenderer(state) {
291: 	}
292: 
293: 	void Render(RowResult &result) override {
294: 		if (first_row) {
295: 			auto &col_names = result.column_names;
296: 			// determine the render width by going over the column names
297: 			header_width = 5;
298: 			for (idx_t i = 0; i < col_names.size(); i++) {
299: 				auto len = ShellState::StringLength(col_names[i] ? col_names[i] : "");
300: 				if (len > header_width) {
301: 					header_width = len;
302: 				}
303: 			}
304: 			first_row = false;
305: 		} else {
306: 			state.Print(state.rowSeparator);
307: 		}
308: 		// render the row
309: 		RenderRow(result);
310: 	}
311: 
312: 	void RenderRow(RowResult &result) override {
313: 		auto &data = result.data;
314: 		auto &col_names = result.column_names;
315: 		for (idx_t i = 0; i < data.size(); i++) {
316: 			state.PrintPadded(col_names[i], header_width);
317: 			state.Print(" = ");
318: 			state.PrintValue(data[i]);
319: 			state.Print(state.rowSeparator);
320: 		}
321: 	}
322: 
323: 	idx_t header_width = 0;
324: };
325: 
326: class ModeExplainRenderer : public RowRenderer {
327: public:
328: 	explicit ModeExplainRenderer(ShellState &state) : RowRenderer(state) {
329: 	}
330: 
331: 	void RenderRow(RowResult &result) override {
332: 		auto &data = result.data;
333: 		if (data.size() != 2) {
334: 			throw std::runtime_error("Invalid usage of explain renderer - must have two data points per row");
335: 		}
336: 		if (strcmp(data[0], "logical_plan") == 0 || strcmp(data[0], "logical_opt") == 0 ||
337: 		    strcmp(data[0], "physical_plan") == 0) {
338: 			state.Print("\n┌─────────────────────────────┐\n");
339: 			state.Print("│┌───────────────────────────┐│\n");
340: 			if (strcmp(data[0], "logical_plan") == 0) {
341: 				state.Print("││ Unoptimized Logical Plan  ││\n");
342: 			} else if (strcmp(data[0], "logical_opt") == 0) {
343: 				state.Print("││  Optimized Logical Plan   ││\n");
344: 			} else if (strcmp(data[0], "physical_plan") == 0) {
345: 				state.Print("││       Physical Plan       ││\n");
346: 			}
347: 			state.Print("│└───────────────────────────┘│\n");
348: 			state.Print("└─────────────────────────────┘\n");
349: 		}
350: 		state.Print(data[1]);
351: 	}
352: };
353: 
354: class ModeListRenderer : public RowRenderer {
355: public:
356: 	explicit ModeListRenderer(ShellState &state) : RowRenderer(state) {
357: 	}
358: 
359: 	void RenderHeader(RowResult &result) override {
360: 		if (!show_header) {
361: 			return;
362: 		}
363: 		auto &col_names = result.column_names;
364: 		for (idx_t i = 0; i < col_names.size(); i++) {
365: 			if (i > 0) {
366: 				state.Print(col_sep);
367: 			}
368: 			state.Print(col_names[i]);
369: 		}
370: 		state.Print(row_sep);
371: 	}
372: 
373: 	void RenderRow(RowResult &result) override {
374: 		auto &data = result.data;
375: 		for (idx_t i = 0; i < data.size(); i++) {
376: 			if (i > 0) {
377: 				state.Print(col_sep);
378: 			}
379: 			state.PrintValue(data[i]);
380: 		}
381: 		state.Print(row_sep);
382: 	}
383: };
384: 
385: class ModeHtmlRenderer : public RowRenderer {
386: public:
387: 	explicit ModeHtmlRenderer(ShellState &state) : RowRenderer(state) {
388: 	}
389: 
390: 	void RenderHeader(RowResult &result) override {
391: 		if (!show_header) {
392: 			return;
393: 		}
394: 		auto &col_names = result.column_names;
395: 		state.Print("<tr>");
396: 		for (idx_t i = 0; i < col_names.size(); i++) {
397: 			state.Print("<th>");
398: 			output_html_string(col_names[i]);
399: 			state.Print("</th>\n");
400: 		}
401: 		state.Print("</tr>\n");
402: 	}
403: 
404: 	void RenderRow(RowResult &result) override {
405: 		auto &data = result.data;
406: 		state.Print("<tr>");
407: 		for (idx_t i = 0; i < data.size(); i++) {
408: 			state.Print("<td>");
409: 			output_html_string(data[i] ? data[i] : state.nullValue.c_str());
410: 			state.Print("</td>\n");
411: 		}
412: 		state.Print("</tr>\n");
413: 	}
414: 
415: 	/*
416: 	** Output the given string with characters that are special to
417: 	** HTML escaped.
418: 	*/
419: 	void output_html_string(const char *z) {
420: 		if (z == 0)
421: 			z = "";
422: 		string escaped;
423: 		for (; *z; z++) {
424: 			switch (*z) {
425: 			case '<':
426: 				escaped += "&lt;";
427: 				break;
428: 			case '&':
429: 				escaped += "&amp;";
430: 				break;
431: 			case '>':
432: 				escaped += "&gt;";
433: 				break;
434: 			case '\"':
435: 				escaped += "&quot;";
436: 				break;
437: 			case '\'':
438: 				escaped += "&#39;";
439: 				break;
440: 			default:
441: 				escaped += *z;
442: 			}
443: 		}
444: 		state.Print(escaped);
445: 	}
446: };
447: 
448: class ModeTclRenderer : public RowRenderer {
449: public:
450: 	explicit ModeTclRenderer(ShellState &state) : RowRenderer(state) {
451: 	}
452: 
453: 	void RenderHeader(RowResult &result) override {
454: 		if (!show_header) {
455: 			return;
456: 		}
457: 		auto &col_names = result.column_names;
458: 		for (idx_t i = 0; i < col_names.size(); i++) {
459: 			if (i > 0) {
460: 				state.Print(col_sep);
461: 			}
462: 			state.OutputCString(col_names[i] ? col_names[i] : "");
463: 		}
464: 		state.Print(row_sep);
465: 	}
466: 
467: 	void RenderRow(RowResult &result) override {
468: 		auto &data = result.data;
469: 		for (idx_t i = 0; i < data.size(); i++) {
470: 			if (i > 0) {
471: 				state.Print(col_sep);
472: 			}
473: 			state.OutputCString(data[i] ? data[i] : state.nullValue.c_str());
474: 		}
475: 		state.Print(row_sep);
476: 	}
477: };
478: 
479: class ModeCsvRenderer : public RowRenderer {
480: public:
481: 	explicit ModeCsvRenderer(ShellState &state) : RowRenderer(state) {
482: 	}
483: 
484: 	void Render(RowResult &result) override {
485: 		state.SetBinaryMode();
486: 		RowRenderer::Render(result);
487: 		state.SetTextMode();
488: 	}
489: 	void RenderHeader(RowResult &result) override {
490: 		if (!show_header) {
491: 			return;
492: 		}
493: 		auto &col_names = result.column_names;
494: 		for (idx_t i = 0; i < col_names.size(); i++) {
495: 			state.OutputCSV(col_names[i] ? col_names[i] : "", i < col_names.size() - 1);
496: 		}
497: 		state.Print(row_sep);
498: 	}
499: 
500: 	void RenderRow(RowResult &result) override {
501: 		auto &data = result.data;
502: 		for (idx_t i = 0; i < data.size(); i++) {
503: 			state.OutputCSV(data[i], i < data.size() - 1);
504: 		}
505: 		state.Print(row_sep);
506: 	}
507: };
508: 
509: class ModeAsciiRenderer : public RowRenderer {
510: public:
511: 	explicit ModeAsciiRenderer(ShellState &state) : RowRenderer(state) {
512: 	}
513: 
514: 	void RenderHeader(RowResult &result) override {
515: 		if (!show_header) {
516: 			return;
517: 		}
518: 		auto &col_names = result.column_names;
519: 		for (idx_t i = 0; i < col_names.size(); i++) {
520: 			if (i > 0) {
521: 				state.Print(col_sep);
522: 			}
523: 			state.Print(col_names[i] ? col_names[i] : "");
524: 		}
525: 		state.Print(row_sep);
526: 	}
527: 
528: 	void RenderRow(RowResult &result) override {
529: 		auto &data = result.data;
530: 		for (idx_t i = 0; i < data.size(); i++) {
531: 			if (i > 0) {
532: 				state.Print(col_sep);
533: 			}
534: 			state.PrintValue(data[i]);
535: 		}
536: 		state.Print(row_sep);
537: 	}
538: };
539: 
540: class ModeQuoteRenderer : public RowRenderer {
541: public:
542: 	explicit ModeQuoteRenderer(ShellState &state) : RowRenderer(state) {
543: 	}
544: 
545: 	void RenderHeader(RowResult &result) override {
546: 		if (!show_header) {
547: 			return;
548: 		}
549: 		auto &col_names = result.column_names;
550: 		for (idx_t i = 0; i < col_names.size(); i++) {
551: 			if (i > 0) {
552: 				state.Print(col_sep);
553: 			}
554: 			state.OutputQuotedString(col_names[i]);
555: 		}
556: 		state.Print(row_sep);
557: 	}
558: 
559: 	void RenderRow(RowResult &result) override {
560: 		auto &data = result.data;
561: 		auto &types = result.types;
562: 		for (idx_t i = 0; i < data.size(); i++) {
563: 			if (i > 0)
564: 				state.Print(col_sep);
565: 			if ((data[i] == 0) || (!types.empty() && types[i] == SQLITE_NULL)) {
566: 				state.Print("NULL");
567: 			} else if (!types.empty() && (types[i] == SQLITE_TEXT || types[i] == SQLITE_BLOB)) {
568: 				state.OutputQuotedString(data[i]);
569: 			} else if (!types.empty() && (types[i] == SQLITE_INTEGER || types[i] == SQLITE_FLOAT)) {
570: 				state.Print(data[i]);
571: 			} else if (state.IsNumber(data[i], 0)) {
572: 				state.Print(data[i]);
573: 			} else {
574: 				state.OutputQuotedString(data[i]);
575: 			}
576: 		}
577: 		state.Print(row_sep);
578: 	}
579: };
580: 
581: class ModeJsonRenderer : public RowRenderer {
582: public:
583: 	explicit ModeJsonRenderer(ShellState &state, bool json_array) : RowRenderer(state), json_array(json_array) {
584: 	}
585: 
586: 	void Render(RowResult &result) override {
587: 		if (first_row) {
588: 			if (json_array) {
589: 				// wrap all JSON objects in an array
590: 				state.Print("[");
591: 			}
592: 			state.Print("{");
593: 			first_row = false;
594: 		} else {
595: 			if (json_array) {
596: 				// wrap all JSON objects in an array
597: 				state.Print(",");
598: 			}
599: 			state.Print("\n{");
600: 		}
601: 		RenderRow(result);
602: 	}
603: 
604: 	void RenderRow(RowResult &result) override {
605: 		auto &data = result.data;
606: 		auto &types = result.types;
607: 		auto &col_names = result.column_names;
608: 		for (idx_t i = 0; i < col_names.size(); i++) {
609: 			if (i > 0) {
610: 				state.Print(",");
611: 			}
612: 			state.OutputJSONString(col_names[i], -1);
613: 			state.Print(":");
614: 			if ((data[i] == 0) || (!types.empty() && types[i] == SQLITE_NULL)) {
615: 				state.Print("null");
616: 			} else if (!types.empty() && types[i] == SQLITE_FLOAT) {
617: 				if (strcmp(data[i], "inf") == 0) {
618: 					state.Print("1e999");
619: 				} else if (strcmp(data[i], "-inf") == 0) {
620: 					state.Print("-1e999");
621: 				} else if (strcmp(data[i], "nan") == 0) {
622: 					state.Print("null");
623: 				} else if (strcmp(data[i], "-nan") == 0) {
624: 					state.Print("null");
625: 				} else {
626: 					state.Print(data[i]);
627: 				}
628: 			} else if (!types.empty() && types[i] == SQLITE_BLOB && result.pStmt) {
629: 				const void *pBlob = sqlite3_column_blob(result.pStmt, i);
630: 				int nBlob = sqlite3_column_bytes(result.pStmt, i);
631: 				state.OutputJSONString((const char *)pBlob, nBlob);
632: 			} else if (!types.empty() && types[i] == SQLITE_TEXT) {
633: 				state.OutputJSONString(data[i], -1);
634: 			} else {
635: 				state.Print(data[i]);
636: 			}
637: 		}
638: 		state.Print("}");
639: 	}
640: 
641: 	void RenderFooter(RowResult &result) override {
642: 		if (json_array) {
643: 			state.Print("]\n");
644: 		} else {
645: 			state.Print("\n");
646: 		}
647: 	}
648: 
649: 	bool json_array;
650: };
651: 
652: class ModeInsertRenderer : public RowRenderer {
653: public:
654: 	explicit ModeInsertRenderer(ShellState &state) : RowRenderer(state) {
655: 	}
656: 
657: 	void RenderRow(RowResult &result) override {
658: 		auto &data = result.data;
659: 		auto &types = result.types;
660: 		auto &col_names = result.column_names;
661: 
662: 		state.Print("INSERT INTO ");
663: 		state.Print(state.zDestTable);
664: 		if (show_header) {
665: 			state.Print("(");
666: 			for (idx_t i = 0; i < col_names.size(); i++) {
667: 				if (i > 0) {
668: 					state.Print(",");
669: 				}
670: 				state.PrintOptionallyQuotedIdentifier(col_names[i]);
671: 			}
672: 			state.Print(")");
673: 		}
674: 		for (idx_t i = 0; i < data.size(); i++) {
675: 			state.Print(i > 0 ? "," : " VALUES(");
676: 			if ((data[i] == 0) || (!types.empty() && types[i] == SQLITE_NULL)) {
677: 				state.Print("NULL");
678: 			} else if (state.IsNumber(data[i], nullptr)) {
679: 				state.Print(data[i]);
680: 			} else if (state.ShellHasFlag(SHFLG_Newlines)) {
681: 				state.OutputQuotedString(data[i]);
682: 			} else {
683: 				state.OutputQuotedEscapedString(data[i]);
684: 			}
685: 		}
686: 		state.Print(");\n");
687: 	}
688: };
689: 
690: class ModeSemiRenderer : public RowRenderer {
691: public:
692: 	explicit ModeSemiRenderer(ShellState &state) : RowRenderer(state) {
693: 	}
694: 
695: 	void RenderRow(RowResult &result) override {
696: 		/* .schema and .fullschema output */
697: 		state.PrintSchemaLine(result.data[0], "\n");
698: 	}
699: };
700: 
701: class ModePrettyRenderer : public RowRenderer {
702: public:
703: 	explicit ModePrettyRenderer(ShellState &state) : RowRenderer(state) {
704: 	}
705: 
706: 	void RenderRow(RowResult &result) override {
707: 		auto &data = result.data;
708: 		/* .schema and .fullschema with --indent */
709: 		if (data.size() != 1) {
710: 			throw std::runtime_error("row must have exactly one value for pretty rendering");
711: 		}
712: 		char *z;
713: 		int j;
714: 		int nParen = 0;
715: 		char cEnd = 0;
716: 		char c;
717: 		int nLine = 0;
718: 		if (!data[0]) {
719: 			return;
720: 		}
721: 		if (sqlite3_strlike("CREATE VIEW%", data[0], 0) == 0 || sqlite3_strlike("CREATE TRIG%", data[0], 0) == 0) {
722: 			state.Print(data[0]);
723: 			state.Print(";\n");
724: 			return;
725: 		}
726: 		z = sqlite3_mprintf("%s", data[0]);
727: 		j = 0;
728: 		idx_t i;
729: 		for (i = 0; IsSpace(z[i]); i++) {
730: 		}
731: 		for (; (c = z[i]) != 0; i++) {
732: 			if (IsSpace(c)) {
733: 				if (z[j - 1] == '\r')
734: 					z[j - 1] = '\n';
735: 				if (IsSpace(z[j - 1]) || z[j - 1] == '(')
736: 					continue;
737: 			} else if ((c == '(' || c == ')') && j > 0 && IsSpace(z[j - 1])) {
738: 				j--;
739: 			}
740: 			z[j++] = c;
741: 		}
742: 		while (j > 0 && IsSpace(z[j - 1])) {
743: 			j--;
744: 		}
745: 		z[j] = 0;
746: 		if (state.StringLength(z) >= 79) {
747: 			for (i = j = 0; (c = z[i]) != 0; i++) { /* Copy from z[i] back to z[j] */
748: 				if (c == cEnd) {
749: 					cEnd = 0;
750: 				} else if (c == '"' || c == '\'' || c == '`') {
751: 					cEnd = c;
752: 				} else if (c == '[') {
753: 					cEnd = ']';
754: 				} else if (c == '-' && z[i + 1] == '-') {
755: 					cEnd = '\n';
756: 				} else if (c == '(') {
757: 					nParen++;
758: 				} else if (c == ')') {
759: 					nParen--;
760: 					if (nLine > 0 && nParen == 0 && j > 0) {
761: 						state.PrintSchemaLineN(z, j, "\n");
762: 						j = 0;
763: 					}
764: 				}
765: 				z[j++] = c;
766: 				if (nParen == 1 && cEnd == 0 && (c == '(' || c == '\n' || (c == ',' && !wsToEol(z + i + 1)))) {
767: 					if (c == '\n')
768: 						j--;
769: 					state.PrintSchemaLineN(z, j, "\n  ");
770: 					j = 0;
771: 					nLine++;
772: 					while (IsSpace(z[i + 1])) {
773: 						i++;
774: 					}
775: 				}
776: 			}
777: 			z[j] = 0;
778: 		}
779: 		state.PrintSchemaLine(z, ";\n");
780: 		sqlite3_free(z);
781: 	}
782: 
783: 	/*
784: 	** Return true if string z[] has nothing but whitespace and comments to the
785: 	** end of the first line.
786: 	*/
787: 	static bool wsToEol(const char *z) {
788: 		int i;
789: 		for (i = 0; z[i]; i++) {
790: 			if (z[i] == '\n') {
791: 				return true;
792: 			}
793: 			if (IsSpace(z[i])) {
794: 				continue;
795: 			}
796: 			if (z[i] == '-' && z[i + 1] == '-') {
797: 				return true;
798: 			}
799: 			return false;
800: 		}
801: 		return true;
802: 	}
803: };
804: 
805: unique_ptr<RowRenderer> ShellState::GetRowRenderer() {
806: 	return GetRowRenderer(cMode);
807: }
808: 
809: unique_ptr<RowRenderer> ShellState::GetRowRenderer(RenderMode mode) {
810: 	switch (mode) {
811: 	case RenderMode::LINE:
812: 		return unique_ptr<RowRenderer>(new ModeLineRenderer(*this));
813: 	case RenderMode::EXPLAIN:
814: 		return unique_ptr<RowRenderer>(new ModeExplainRenderer(*this));
815: 	case RenderMode::LIST:
816: 		return unique_ptr<RowRenderer>(new ModeListRenderer(*this));
817: 	case RenderMode::HTML:
818: 		return unique_ptr<RowRenderer>(new ModeHtmlRenderer(*this));
819: 	case RenderMode::TCL:
820: 		return unique_ptr<RowRenderer>(new ModeTclRenderer(*this));
821: 	case RenderMode::CSV:
822: 		return unique_ptr<RowRenderer>(new ModeCsvRenderer(*this));
823: 	case RenderMode::ASCII:
824: 		return unique_ptr<RowRenderer>(new ModeAsciiRenderer(*this));
825: 	case RenderMode::QUOTE:
826: 		return unique_ptr<RowRenderer>(new ModeQuoteRenderer(*this));
827: 	case RenderMode::JSON:
828: 		return unique_ptr<RowRenderer>(new ModeJsonRenderer(*this, true));
829: 	case RenderMode::JSONLINES:
830: 		return unique_ptr<RowRenderer>(new ModeJsonRenderer(*this, false));
831: 	case RenderMode::INSERT:
832: 		return unique_ptr<RowRenderer>(new ModeInsertRenderer(*this));
833: 	case RenderMode::SEMI:
834: 		return unique_ptr<RowRenderer>(new ModeSemiRenderer(*this));
835: 	case RenderMode::PRETTY:
836: 		return unique_ptr<RowRenderer>(new ModePrettyRenderer(*this));
837: 	default:
838: 		throw std::runtime_error("Unsupported mode for GetRowRenderer");
839: 	}
840: }
841: 
842: } // namespace duckdb_shell
[end of tools/shell/shell_renderer.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: