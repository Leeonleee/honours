{
  "repo": "duckdb/duckdb",
  "pull_number": 2408,
  "instance_id": "duckdb__duckdb-2408",
  "issue_numbers": [
    "2237"
  ],
  "base_commit": "1aeec0b3b9e72025edaafbd22019d507f6fab6da",
  "patch": "diff --git a/tools/rpkg/NAMESPACE b/tools/rpkg/NAMESPACE\nindex 8850579c34c0..df95a2bd175a 100644\n--- a/tools/rpkg/NAMESPACE\n+++ b/tools/rpkg/NAMESPACE\n@@ -9,6 +9,7 @@ export(duckdb_register_arrow)\n export(duckdb_shutdown)\n export(duckdb_unregister)\n export(duckdb_unregister_arrow)\n+export(duckdb_list_arrow)\n export(read_csv_duckdb)\n exportClasses(duckdb_connection)\n exportClasses(duckdb_driver)\ndiff --git a/tools/rpkg/R/register.R b/tools/rpkg/R/register.R\nindex f1cd0cbbe37d..236a6c9cbab0 100644\n--- a/tools/rpkg/R/register.R\n+++ b/tools/rpkg/R/register.R\n@@ -64,7 +64,12 @@ duckdb_register_arrow <- function(conn, name, arrow_scannable) {\n #' @rdname duckdb_register_arrow\n #' @export\n duckdb_unregister_arrow <- function(conn, name) {\n-  stopifnot(dbIsValid(conn))\n   .Call(duckdb_unregister_arrow_R, conn@conn_ref, as.character(name))\n   invisible(TRUE)\n+}\n+\n+#' @rdname duckdb_register_arrow\n+#' @export\n+duckdb_list_arrow <- function(conn) {\n+    sort(gsub(\"_registered_arrow_\", \"\", names(attributes(conn@driver@database_ref)), fixed=TRUE))\n }\n\\ No newline at end of file\ndiff --git a/tools/rpkg/man/duckdb_register_arrow.Rd b/tools/rpkg/man/duckdb_register_arrow.Rd\nindex 0f6caff2497e..78a718014195 100644\n--- a/tools/rpkg/man/duckdb_register_arrow.Rd\n+++ b/tools/rpkg/man/duckdb_register_arrow.Rd\n@@ -3,6 +3,7 @@\n \\name{duckdb_register_arrow}\n \\alias{duckdb_register_arrow}\n \\alias{duckdb_unregister_arrow}\n+\\alias{duckdb_list_arrow}\n \\title{Register an Arrow data source as a virtual table}\n \\usage{\n duckdb_register_arrow(conn, name, arrow_scannable)\ndiff --git a/tools/rpkg/src/connection.cpp b/tools/rpkg/src/connection.cpp\nindex 773451dcfe9b..96b093f346fc 100644\n--- a/tools/rpkg/src/connection.cpp\n+++ b/tools/rpkg/src/connection.cpp\n@@ -6,11 +6,11 @@ static SEXP duckdb_finalize_connection_R(SEXP connsexp) {\n \tif (TYPEOF(connsexp) != EXTPTRSXP) {\n \t\tRf_error(\"duckdb_finalize_connection_R: Need external pointer parameter\");\n \t}\n-\tConnection *connaddr = (Connection *)R_ExternalPtrAddr(connsexp);\n-\tif (connaddr) {\n+\tauto conn_wrapper = (ConnWrapper *)R_ExternalPtrAddr(connsexp);\n+\tif (conn_wrapper) {\n \t\tRf_warning(\"duckdb_finalize_connection_R: Connection is garbage-collected, use dbDisconnect() to avoid this.\");\n \t\tR_ClearExternalPtr(connsexp);\n-\t\tdelete connaddr;\n+\t\tdelete conn_wrapper;\n \t}\n \treturn R_NilValue;\n }\n@@ -19,13 +19,17 @@ SEXP RApi::Connect(SEXP dbsexp) {\n \tif (TYPEOF(dbsexp) != EXTPTRSXP) {\n \t\tRf_error(\"duckdb_connect_R: Need external pointer parameter\");\n \t}\n-\tDuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);\n-\tif (!dbaddr) {\n+\tauto db_wrapper = (DBWrapper *)R_ExternalPtrAddr(dbsexp);\n+\tif (!db_wrapper || !db_wrapper->db) {\n \t\tRf_error(\"duckdb_connect_R: Invalid database reference\");\n \t}\n \n \tRProtector r;\n-\tSEXP connsexp = r.Protect(R_MakeExternalPtr(new Connection(*dbaddr), R_NilValue, R_NilValue));\n+\tauto conn_wrapper = new ConnWrapper();\n+\tconn_wrapper->db_sexp = dbsexp;\n+\tconn_wrapper->conn = make_unique<Connection>(*db_wrapper->db);\n+\n+\tSEXP connsexp = r.Protect(R_MakeExternalPtr(conn_wrapper, R_NilValue, R_NilValue));\n \tR_RegisterCFinalizer(connsexp, (void (*)(SEXP))duckdb_finalize_connection_R);\n \n \treturn connsexp;\n@@ -35,10 +39,10 @@ SEXP RApi::Disconnect(SEXP connsexp) {\n \tif (TYPEOF(connsexp) != EXTPTRSXP) {\n \t\tRf_error(\"duckdb_disconnect_R: Need external pointer parameter\");\n \t}\n-\tConnection *connaddr = (Connection *)R_ExternalPtrAddr(connsexp);\n-\tif (connaddr) {\n+\tauto conn_wrapper = (ConnWrapper *)R_ExternalPtrAddr(connsexp);\n+\tif (conn_wrapper) {\n \t\tR_ClearExternalPtr(connsexp);\n-\t\tdelete connaddr;\n+\t\tdelete conn_wrapper;\n \t}\n \treturn R_NilValue;\n }\ndiff --git a/tools/rpkg/src/database.cpp b/tools/rpkg/src/database.cpp\nindex eb6e78583ea8..fcec6dad152e 100644\n--- a/tools/rpkg/src/database.cpp\n+++ b/tools/rpkg/src/database.cpp\n@@ -9,12 +9,12 @@ static SEXP duckdb_finalize_database_R(SEXP dbsexp) {\n \tif (TYPEOF(dbsexp) != EXTPTRSXP) {\n \t\tRf_error(\"duckdb_finalize_connection_R: Need external pointer parameter\");\n \t}\n-\tDuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);\n-\tif (dbaddr) {\n+\tauto db_wrapper = (DBWrapper *)R_ExternalPtrAddr(dbsexp);\n+\tif (db_wrapper) {\n \t\tRf_warning(\"duckdb_finalize_database_R: Database is garbage-collected, use dbDisconnect(con, shutdown=TRUE) or \"\n \t\t           \"duckdb::duckdb_shutdown(drv) to avoid this.\");\n \t\tR_ClearExternalPtr(dbsexp);\n-\t\tdelete dbaddr;\n+\t\tdelete db_wrapper;\n \t}\n \treturn R_NilValue;\n }\n@@ -42,7 +42,7 @@ SEXP RApi::Startup(SEXP dbdirsexp, SEXP readonlysexp, SEXP configsexp) {\n \tRProtector r;\n \tauto confignamessexp = r.Protect(GET_NAMES(configsexp));\n \n-\tfor (idx_t i = 0; i < Rf_length(configsexp); i++) {\n+\tfor (idx_t i = 0; i < (idx_t)Rf_length(configsexp); i++) {\n \t\tstring key = string(CHAR(STRING_ELT(confignamessexp, i)));\n \t\tstring val = string(CHAR(STRING_ELT(VECTOR_ELT(configsexp, i), 0)));\n \t\tauto config_property = DBConfig::GetOptionByName(key);\n@@ -56,24 +56,28 @@ SEXP RApi::Startup(SEXP dbdirsexp, SEXP readonlysexp, SEXP configsexp) {\n \t\t}\n \t}\n \n-\tDuckDB *dbaddr;\n+\tDBWrapper *wrapper;\n+\n \ttry {\n-\t\tdbaddr = new DuckDB(dbdir, &config);\n+\t\twrapper = new DBWrapper();\n+\t\tconfig.replacement_scans.emplace_back(ArrowScanReplacement, wrapper);\n+\t\twrapper->db = make_unique<DuckDB>(dbdir, &config);\n \t} catch (std::exception &e) {\n \t\tRf_error(\"duckdb_startup_R: Failed to open database: %s\", e.what());\n \t}\n-\tExtensionHelper::LoadAllExtensions(*dbaddr);\n+\tD_ASSERT(wrapper->db);\n+\tExtensionHelper::LoadAllExtensions(*wrapper->db);\n \n \tDataFrameScanFunction scan_fun;\n \tCreateTableFunctionInfo info(scan_fun);\n-\tConnection conn(*dbaddr);\n+\tConnection conn(*wrapper->db);\n \tauto &context = *conn.context;\n \tauto &catalog = Catalog::GetCatalog(context);\n \tcontext.transaction.BeginTransaction();\n \tcatalog.CreateTableFunction(context, &info);\n \tcontext.transaction.Commit();\n \n-\tSEXP dbsexp = r.Protect(R_MakeExternalPtr(dbaddr, R_NilValue, R_NilValue));\n+\tSEXP dbsexp = r.Protect(R_MakeExternalPtr(wrapper, R_NilValue, R_NilValue));\n \tR_RegisterCFinalizer(dbsexp, (void (*)(SEXP))duckdb_finalize_database_R);\n \treturn dbsexp;\n }\n@@ -82,10 +86,10 @@ SEXP RApi::Shutdown(SEXP dbsexp) {\n \tif (TYPEOF(dbsexp) != EXTPTRSXP) {\n \t\tRf_error(\"duckdb_finalize_connection_R: Need external pointer parameter\");\n \t}\n-\tDuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);\n-\tif (dbaddr) {\n+\tauto db_wrapper = (DBWrapper *)R_ExternalPtrAddr(dbsexp);\n+\tif (db_wrapper) {\n \t\tR_ClearExternalPtr(dbsexp);\n-\t\tdelete dbaddr;\n+\t\tdelete db_wrapper;\n \t}\n \n \treturn R_NilValue;\ndiff --git a/tools/rpkg/src/include/rapi.hpp b/tools/rpkg/src/include/rapi.hpp\nindex 5da5a8ce5220..fdba2e1d6dac 100644\n--- a/tools/rpkg/src/include/rapi.hpp\n+++ b/tools/rpkg/src/include/rapi.hpp\n@@ -6,9 +6,25 @@\n \n #include \"duckdb.hpp\"\n #include \"duckdb/function/table_function.hpp\"\n+#include \"duckdb/common/unordered_map.hpp\"\n+#include \"duckdb/parser/tableref/table_function_ref.hpp\"\n+#include \"duckdb/common/mutex.hpp\"\n \n namespace duckdb {\n \n+typedef unordered_map<std::string, SEXP> arrow_scans_t;\n+\n+struct DBWrapper {\n+\tunique_ptr<DuckDB> db;\n+\tarrow_scans_t arrow_scans;\n+\tmutex lock;\n+};\n+\n+struct ConnWrapper {\n+\tunique_ptr<Connection> conn;\n+\tSEXP db_sexp;\n+};\n+\n struct RApi {\n \n \tstatic SEXP Startup(SEXP dbdirsexp, SEXP readonlysexp, SEXP configsexp);\n@@ -39,6 +55,7 @@ struct RApi {\n \tstatic SEXP RegisterArrow(SEXP connsexp, SEXP namesexp, SEXP export_funsexp, SEXP valuesexp);\n \n \tstatic SEXP UnregisterArrow(SEXP connsexp, SEXP namesexp);\n+\tstatic unique_ptr<TableFunctionRef> ArrowScanReplacement(const string &table_name, void *data);\n \n \tstatic SEXP PointerToString(SEXP extptr);\n \tstatic SEXP StringsToSexp(vector<string> s);\ndiff --git a/tools/rpkg/src/register.cpp b/tools/rpkg/src/register.cpp\nindex 99b9334f5e1e..85d79eaf8457 100644\n--- a/tools/rpkg/src/register.cpp\n+++ b/tools/rpkg/src/register.cpp\n@@ -5,6 +5,8 @@\n #include \"duckdb/planner/table_filter.hpp\"\n #include \"duckdb/planner/filter/constant_filter.hpp\"\n #include \"duckdb/planner/filter/conjunction_filter.hpp\"\n+#include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/expression/function_expression.hpp\"\n \n using namespace duckdb;\n \n@@ -12,8 +14,8 @@ SEXP RApi::RegisterDataFrame(SEXP connsexp, SEXP namesexp, SEXP valuesexp) {\n \tif (TYPEOF(connsexp) != EXTPTRSXP) {\n \t\tRf_error(\"duckdb_register_R: Need external pointer parameter for connection\");\n \t}\n-\tConnection *conn = (Connection *)R_ExternalPtrAddr(connsexp);\n-\tif (!conn) {\n+\tauto conn_wrapper = (ConnWrapper *)R_ExternalPtrAddr(connsexp);\n+\tif (!conn_wrapper || !conn_wrapper->conn) {\n \t\tRf_error(\"duckdb_register_R: Invalid connection\");\n \t}\n \tif (TYPEOF(namesexp) != STRSXP || Rf_length(namesexp) != 1) {\n@@ -28,7 +30,8 @@ SEXP RApi::RegisterDataFrame(SEXP connsexp, SEXP namesexp, SEXP valuesexp) {\n \t\tRf_error(\"duckdb_register_R: Need at least one-column data frame parameter for value\");\n \t}\n \ttry {\n-\t\tconn->TableFunction(\"r_dataframe_scan\", {Value::POINTER((uintptr_t)valuesexp)})->CreateView(name, true, true);\n+\t\tconn_wrapper->conn->TableFunction(\"r_dataframe_scan\", {Value::POINTER((uintptr_t)valuesexp)})\n+\t\t    ->CreateView(name, true, true);\n \t\tauto key = Rf_install((\"_registered_df_\" + name).c_str());\n \t\tRf_setAttrib(connsexp, key, valuesexp);\n \t} catch (std::exception &e) {\n@@ -41,8 +44,8 @@ SEXP RApi::UnregisterDataFrame(SEXP connsexp, SEXP namesexp) {\n \tif (TYPEOF(connsexp) != EXTPTRSXP) {\n \t\tRf_error(\"duckdb_unregister_R: Need external pointer parameter for connection\");\n \t}\n-\tConnection *conn = (Connection *)R_ExternalPtrAddr(connsexp);\n-\tif (!conn) {\n+\tauto conn_wrapper = (ConnWrapper *)R_ExternalPtrAddr(connsexp);\n+\tif (!conn_wrapper || !conn_wrapper->conn) {\n \t\tRf_error(\"duckdb_unregister_R: Invalid connection\");\n \t}\n \tif (TYPEOF(namesexp) != STRSXP || Rf_length(namesexp) != 1) {\n@@ -51,7 +54,7 @@ SEXP RApi::UnregisterDataFrame(SEXP connsexp, SEXP namesexp) {\n \tauto name = string(CHAR(STRING_ELT(namesexp, 0)));\n \tauto key = Rf_install((\"_registered_df_\" + name).c_str());\n \tRf_setAttrib(connsexp, key, R_NilValue);\n-\tauto res = conn->Query(\"DROP VIEW IF EXISTS \\\"\" + name + \"\\\"\");\n+\tauto res = conn_wrapper->conn->Query(\"DROP VIEW IF EXISTS \\\"\" + name + \"\\\"\");\n \tif (!res->success) {\n \t\tRf_error(res->error.c_str());\n \t}\n@@ -220,12 +223,30 @@ static SEXP duckdb_finalize_arrow_factory_R(SEXP factorysexp) {\n \treturn R_NilValue;\n }\n \n+unique_ptr<TableFunctionRef> RApi::ArrowScanReplacement(const string &table_name, void *data) {\n+\tauto db_wrapper = (DBWrapper *)data;\n+\tlock_guard<mutex> arrow_scans_lock(db_wrapper->lock);\n+\tfor (auto &e : db_wrapper->arrow_scans) {\n+\t\tif (e.first == table_name) {\n+\t\t\tauto table_function = make_unique<TableFunctionRef>();\n+\t\t\tvector<unique_ptr<ParsedExpression>> children;\n+\t\t\tchildren.push_back(make_unique<ConstantExpression>(Value::POINTER((uintptr_t)R_ExternalPtrAddr(e.second))));\n+\t\t\tchildren.push_back(\n+\t\t\t    make_unique<ConstantExpression>(Value::POINTER((uintptr_t)RArrowTabularStreamFactory::Produce)));\n+\t\t\tchildren.push_back(make_unique<ConstantExpression>(Value::UBIGINT(100000)));\n+\t\t\ttable_function->function = make_unique<FunctionExpression>(\"arrow_scan\", move(children));\n+\t\t\treturn table_function;\n+\t\t}\n+\t}\n+\treturn nullptr;\n+}\n+\n SEXP RApi::RegisterArrow(SEXP connsexp, SEXP namesexp, SEXP export_funsexp, SEXP valuesexp) {\n \tif (TYPEOF(connsexp) != EXTPTRSXP) {\n \t\tRf_error(\"duckdb_register_R: Need external pointer parameter for connection\");\n \t}\n-\tConnection *conn = (Connection *)R_ExternalPtrAddr(connsexp);\n-\tif (!conn) {\n+\tauto conn_wrapper = (ConnWrapper *)R_ExternalPtrAddr(connsexp);\n+\tif (!conn_wrapper || !conn_wrapper->conn) {\n \t\tRf_error(\"duckdb_register_R: Invalid connection\");\n \t}\n \tif (TYPEOF(namesexp) != STRSXP || Rf_length(namesexp) != 1) {\n@@ -242,22 +263,24 @@ SEXP RApi::RegisterArrow(SEXP connsexp, SEXP namesexp, SEXP export_funsexp, SEXP\n \n \tRProtector r;\n \tauto stream_factory = new RArrowTabularStreamFactory(export_funsexp, valuesexp);\n-\tauto stream_factory_produce = RArrowTabularStreamFactory::Produce;\n-\tconn->TableFunction(\"arrow_scan\", {Value::POINTER((uintptr_t)stream_factory),\n-\t                                   Value::POINTER((uintptr_t)stream_factory_produce), Value::UBIGINT(100000)})\n-\t    ->CreateView(name, true, true);\n-\n \t// make r external ptr object to keep factory around until arrow table is unregistered\n \tSEXP factorysexp = r.Protect(R_MakeExternalPtr(stream_factory, R_NilValue, R_NilValue));\n \tR_RegisterCFinalizer(factorysexp, (void (*)(SEXP))duckdb_finalize_arrow_factory_R);\n \n+\t{\n+\t\tauto *db_wrapper = (DBWrapper *)R_ExternalPtrAddr(conn_wrapper->db_sexp);\n+\t\t// TODO check if this name already exists?\n+\t\tlock_guard<mutex> arrow_scans_lock(db_wrapper->lock);\n+\t\tauto &arrow_scans = db_wrapper->arrow_scans;\n+\t\tarrow_scans[name] = factorysexp;\n+\t}\n \tSEXP state_list = r.Protect(NEW_LIST(3));\n \tSET_VECTOR_ELT(state_list, 0, export_funsexp);\n \tSET_VECTOR_ELT(state_list, 1, valuesexp);\n \tSET_VECTOR_ELT(state_list, 2, factorysexp);\n \n \tauto key = Rf_install((\"_registered_arrow_\" + name).c_str());\n-\tRf_setAttrib(connsexp, key, state_list);\n+\tRf_setAttrib(conn_wrapper->db_sexp, key, state_list);\n \n \treturn R_NilValue;\n }\n@@ -266,19 +289,23 @@ SEXP RApi::UnregisterArrow(SEXP connsexp, SEXP namesexp) {\n \tif (TYPEOF(connsexp) != EXTPTRSXP) {\n \t\tRf_error(\"duckdb_unregister_R: Need external pointer parameter for connection\");\n \t}\n-\tConnection *conn = (Connection *)R_ExternalPtrAddr(connsexp);\n-\tif (!conn) {\n+\tauto conn_wrapper = (ConnWrapper *)R_ExternalPtrAddr(connsexp);\n+\tif (!conn_wrapper || !conn_wrapper->conn) {\n \t\tRf_error(\"duckdb_unregister_R: Invalid connection\");\n \t}\n \tif (TYPEOF(namesexp) != STRSXP || Rf_length(namesexp) != 1) {\n \t\tRf_error(\"duckdb_unregister_R: Need single string parameter for name\");\n \t}\n+\n \tauto name = string(CHAR(STRING_ELT(namesexp, 0)));\n-\tauto key = Rf_install((\"_registered_arrow_\" + name).c_str());\n-\tRf_setAttrib(connsexp, key, R_NilValue);\n-\tauto res = conn->Query(\"DROP VIEW IF EXISTS \\\"\" + name + \"\\\"\");\n-\tif (!res->success) {\n-\t\tRf_error(res->error.c_str());\n+\t{\n+\t\tauto *db_wrapper = (DBWrapper *)R_ExternalPtrAddr(conn_wrapper->db_sexp);\n+\t\tlock_guard<mutex> arrow_scans_lock(db_wrapper->lock);\n+\t\tauto &arrow_scans = db_wrapper->arrow_scans;\n+\t\tarrow_scans.erase(name);\n \t}\n+\tauto key = Rf_install((\"_registered_arrow_\" + name).c_str());\n+\tRf_setAttrib(conn_wrapper->db_sexp, key, R_NilValue);\n+\n \treturn R_NilValue;\n }\ndiff --git a/tools/rpkg/src/statement.cpp b/tools/rpkg/src/statement.cpp\nindex 435bf3a4ddc3..4cf19d6eac23 100644\n--- a/tools/rpkg/src/statement.cpp\n+++ b/tools/rpkg/src/statement.cpp\n@@ -54,12 +54,12 @@ SEXP RApi::Prepare(SEXP connsexp, SEXP querysexp) {\n \t\tRf_error(\"duckdb_prepare_R: No query\");\n \t}\n \n-\tConnection *conn = (Connection *)R_ExternalPtrAddr(connsexp);\n-\tif (!conn) {\n+\tauto conn_wrapper = (ConnWrapper *)R_ExternalPtrAddr(connsexp);\n+\tif (!conn_wrapper || !conn_wrapper->conn) {\n \t\tRf_error(\"duckdb_prepare_R: Invalid connection\");\n \t}\n \n-\tauto stmt = conn->Prepare(query);\n+\tauto stmt = conn_wrapper->conn->Prepare(query);\n \tif (!stmt->success) {\n \t\tRf_error(\"duckdb_prepare_R: Failed to prepare query %s\\nError: %s\", query, stmt->error.c_str());\n \t}\n",
  "test_patch": "diff --git a/tools/rpkg/tests/testthat/test_register_arrow.R b/tools/rpkg/tests/testthat/test_register_arrow.R\nindex 16786a64561c..e0e0ad10d5c0 100644\n--- a/tools/rpkg/tests/testthat/test_register_arrow.R\n+++ b/tools/rpkg/tests/testthat/test_register_arrow.R\n@@ -319,9 +319,51 @@ test_that(\"duckdb_register_arrow() under many threads\", {\n \n     expect_error(DBI::dbGetQuery(con, \"SELECT cyl, SUM(mpg) FROM mtcars_arrow GROUP BY cyl\"),NA)\n \n-\n     expect_error(DBI::dbGetQuery(con, \"SELECT cyl, AVG(mpg) FROM mtcars_arrow GROUP BY cyl\"),NA)\n+})\n \n+test_that(\"we can unregister in finalizers yay\", {\n+    con <- DBI::dbConnect(duckdb::duckdb())\n+    ds <- arrow::InMemoryDataset$create(mtcars)\n+\n+    # Creates an environment that disconnects the database when it's GC'd\n+    duckdb_disconnector <- function(con, table_name) {\n+      # we need to force the name here\n+      table_name_forced <- force(table_name)\n+      reg.finalizer(environment(), function(...) {\n+        duckdb::duckdb_unregister_arrow(con, table_name_forced)\n+      })\n+      environment()\n+    }\n+\n+    for (i in 1:100) {\n+      table_name <- paste0(\"mtcars_\", i)\n+      duckdb::duckdb_register_arrow(con, table_name, ds)\n+      object_to_clean <- duckdb_disconnector(con, table_name)\n+    }\n+    object_to_clean <- NULL # otherwise we leak one\n+    # force a gc run, now they should all be gone\n+    gc()\n+\n+    expect_equal(length(duckdb::duckdb_list_arrow(con)), 0)\n })\n \n \n+test_that(\"we can list registered arrow tables\", {\n+    con <- DBI::dbConnect(duckdb::duckdb())\n+    ds <- arrow::InMemoryDataset$create(mtcars)\n+\n+    expect_equal(length(duckdb::duckdb_list_arrow(con)), 0)\n+\n+    duckdb::duckdb_register_arrow(con, \"t1\", ds)\n+    duckdb::duckdb_register_arrow(con, \"t2\", ds)\n+\n+    expect_equal(duckdb::duckdb_list_arrow(con), c(\"t1\", \"t2\"))\n+\n+    duckdb::duckdb_unregister_arrow(con, \"t1\")\n+    expect_equal(duckdb::duckdb_list_arrow(con), c(\"t2\"))\n+    duckdb::duckdb_unregister_arrow(con, \"t2\")\n+\n+\n+    expect_equal(length(duckdb::duckdb_list_arrow(con)), 0)\n+})\n",
  "problem_statement": "Table clean up and hanging\nI'm working on polishing the DuckDB and Arrow integration and I'm trying to work out a way for ephemeral registrations to be closed. I'm following [a pattern I've seen in dbplyr](https://github.com/tidyverse/dbplyr/blob/47e53ce30402d41ae4b38c803de12e63d64a9b6c/R/src_dbi.R#L130-L139). But I'm seeing hanging behavior when the clean up happens.\r\n\r\nHere's a toy example that hangs around the 13th iteration for me. I've tried a number of `DBI` calls, and any that I've tried causes the hang. In the real code, instead of `DBI::dbIsValid(con)` (what I actually do in the integratoin is `duckdb::duckdb_unregister_arrow(con, tbl_name)`). \r\n\r\n```\r\nds <- arrow::InMemoryDataset$create(mtcars)\r\ncon <- DBI::dbConnect(duckdb::duckdb())\r\n\r\n# Creates an environment that disconnects the database when it's GC'd\r\nduckdb_disconnector <- function(con) {\r\n  reg.finalizer(environment(), function(...) {\r\n    print(\"cleaning ...\")\r\n    # basically any DBI call causes a hang, duckdb_unregister_arrow() also causes a hang\r\n    DBI::dbIsValid(con)\r\n  })\r\n  environment()\r\n}\r\n\r\nfor (i in 1:100) {\r\n  print(i)\r\n\r\n  table_name <- paste0(\"mtcars_\", i)\r\n  duckdb::duckdb_register_arrow(con, table_name, ds)\r\n\r\n  # setup an object with a finalizer\r\n  object_to_clean <- duckdb_disconnector(con)\r\n\r\n  DBI::dbGetQuery(\r\n    con,\r\n    paste0(\"SELECT mpg, cyl, wt FROM \", table_name, \" WHERE mpg < 22.0\")\r\n  )\r\n}\r\n```\r\n\r\noutput:\r\n```\r\n[1] 1\r\n[1] 2\r\n[1] 3\r\n[1] 4\r\n[1] 5\r\n[1] 6\r\n[1] 7\r\n[1] 8\r\n[1] 9\r\n[1] 10\r\n[1] 11\r\n[1] 12\r\n[1] 13\r\n[1] \"cleaning ...\"\r\n```\r\n\r\nIf I change the query or other operations, which iteration the hang happens on changes (which makes sense, since `duckdb_disconnector()` is only called on `gc()` and what memory is being allocated will change when that happens). I've tried this on both macOS and linux (ubuntu) and get the hang on both. \r\n\r\nInterestingly(?) I *don't* get this hang if I'm creating a table with `DBI::dbWriteTable()` or registering a data.frame with `duckdb::duckdb_register()`.\r\n\r\nIs this expected? Should I try another approach to cleaning up ephemeral tables?\n",
  "hints_text": "And here's a log from gdb when that hang is happening, in case that's useful:\r\n\r\n[gdb.log](https://github.com/duckdb/duckdb/files/7106000/gdb.log)\r\n\n@pdet @hannesmuehleisen Any thoughts on what might be going on here?\nI did have a look at it and could reproduce the behavior. I still don't have a solution for it, it doesn't seem to be related to the arrow integration locks. In any case, I'll have another go at this today/next week.\nThanks! I'm happy to test branches or help other ways. I did try and see if I could sequence calls to get the hang to happen (e.g. send query, but don't fetch results, and then call dbisvalid (which internally does a simple select) but that didn't produce the same behavior)\nI think I have an idea what causes this. The finaliser is running out-of-band whenever an allocation happens. This can be within a running DuckDB query, where the context lock is taken. The finaliser therefore cannot get that lock, too. I would probably find another way to clean this up that does not rely on finalizers. ",
  "created_at": "2021-10-12T10:43:43Z"
}