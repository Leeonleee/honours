You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Table clean up and hanging
I'm working on polishing the DuckDB and Arrow integration and I'm trying to work out a way for ephemeral registrations to be closed. I'm following [a pattern I've seen in dbplyr](https://github.com/tidyverse/dbplyr/blob/47e53ce30402d41ae4b38c803de12e63d64a9b6c/R/src_dbi.R#L130-L139). But I'm seeing hanging behavior when the clean up happens.

Here's a toy example that hangs around the 13th iteration for me. I've tried a number of `DBI` calls, and any that I've tried causes the hang. In the real code, instead of `DBI::dbIsValid(con)` (what I actually do in the integratoin is `duckdb::duckdb_unregister_arrow(con, tbl_name)`). 

```
ds <- arrow::InMemoryDataset$create(mtcars)
con <- DBI::dbConnect(duckdb::duckdb())

# Creates an environment that disconnects the database when it's GC'd
duckdb_disconnector <- function(con) {
  reg.finalizer(environment(), function(...) {
    print("cleaning ...")
    # basically any DBI call causes a hang, duckdb_unregister_arrow() also causes a hang
    DBI::dbIsValid(con)
  })
  environment()
}

for (i in 1:100) {
  print(i)

  table_name <- paste0("mtcars_", i)
  duckdb::duckdb_register_arrow(con, table_name, ds)

  # setup an object with a finalizer
  object_to_clean <- duckdb_disconnector(con)

  DBI::dbGetQuery(
    con,
    paste0("SELECT mpg, cyl, wt FROM ", table_name, " WHERE mpg < 22.0")
  )
}
```

output:
```
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
[1] 11
[1] 12
[1] 13
[1] "cleaning ..."
```

If I change the query or other operations, which iteration the hang happens on changes (which makes sense, since `duckdb_disconnector()` is only called on `gc()` and what memory is being allocated will change when that happens). I've tried this on both macOS and linux (ubuntu) and get the hang on both. 

Interestingly(?) I *don't* get this hang if I'm creating a table with `DBI::dbWriteTable()` or registering a data.frame with `duckdb::duckdb_register()`.

Is this expected? Should I try another approach to cleaning up ephemeral tables?

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of tools/rpkg/NAMESPACE]
1: # Generated by roxygen2: do not edit by hand
2: 
3: export(duckdb)
4: export(duckdb_fetch_arrow)
5: export(duckdb_fetch_record_batch)
6: export(duckdb_read_csv)
7: export(duckdb_register)
8: export(duckdb_register_arrow)
9: export(duckdb_shutdown)
10: export(duckdb_unregister)
11: export(duckdb_unregister_arrow)
12: export(read_csv_duckdb)
13: exportClasses(duckdb_connection)
14: exportClasses(duckdb_driver)
15: exportClasses(duckdb_result)
16: exportMethods(dbAppendTable)
17: exportMethods(dbBegin)
18: exportMethods(dbBind)
19: exportMethods(dbClearResult)
20: exportMethods(dbColumnInfo)
21: exportMethods(dbCommit)
22: exportMethods(dbConnect)
23: exportMethods(dbDataType)
24: exportMethods(dbDisconnect)
25: exportMethods(dbExistsTable)
26: exportMethods(dbFetch)
27: exportMethods(dbGetInfo)
28: exportMethods(dbGetRowCount)
29: exportMethods(dbGetRowsAffected)
30: exportMethods(dbGetStatement)
31: exportMethods(dbHasCompleted)
32: exportMethods(dbIsValid)
33: exportMethods(dbListFields)
34: exportMethods(dbListTables)
35: exportMethods(dbQuoteLiteral)
36: exportMethods(dbRemoveTable)
37: exportMethods(dbRollback)
38: exportMethods(dbSendQuery)
39: exportMethods(dbWriteTable)
40: exportMethods(show)
41: import(DBI)
42: import(methods)
43: importFrom(DBI,dbConnect)
44: importFrom(utils,head)
45: useDynLib(duckdb, .registration = TRUE)
[end of tools/rpkg/NAMESPACE]
[start of tools/rpkg/R/register.R]
1: #' Register a data frame as a virtual table
2: #'
3: #' `duckdb_register()` registers a data frame as a virtual table (view)
4: #'  in a DuckDB connection.
5: #'  No data is copied.
6: #'
7: #' `duckdb_unregister()` unregisters a previously registered data frame.
8: #' @param conn A DuckDB connection, created by `dbConnect()`.
9: #' @param name The name for the virtual table that is registered or unregistered
10: #' @param df A `data.frame` with the data for the virtual table
11: #' @return These functions are called for their side effect.
12: #' @export
13: #' @examples
14: #' con <- dbConnect(duckdb())
15: #'
16: #' data <- data.frame(a = 1:3, b = letters[1:3])
17: #'
18: #' duckdb_register(con, "data", data)
19: #' dbReadTable(con, "data")
20: #'
21: #' duckdb_unregister(con, "data")
22: #' try(dbReadTable(con, "data"))
23: #'
24: #' dbDisconnect(con)
25: duckdb_register <- function(conn, name, df) {
26:   stopifnot(dbIsValid(conn))
27:   .Call(duckdb_register_R, conn@conn_ref, as.character(name), as.data.frame(df))
28:   invisible(TRUE)
29: }
30: 
31: #' @rdname duckdb_register
32: #' @export
33: duckdb_unregister <- function(conn, name) {
34:   stopifnot(dbIsValid(conn))
35:   .Call(duckdb_unregister_R, conn@conn_ref, as.character(name))
36:   invisible(TRUE)
37: }
38: 
39: #' Register an Arrow data source as a virtual table
40: #'
41: #' `duckdb_register_arrow()` registers an Arrow data source as a virtual table (view)
42: #'  in a DuckDB connection.
43: #'  No data is copied.
44: #'
45: #' `duckdb_unregister_arrow()` unregisters a previously registered data frame.
46: #' @param conn A DuckDB connection, created by `dbConnect()`.
47: #' @param name The name for the virtual table that is registered or unregistered
48: #' @param arrow_scannable A scannable Arrow-object
49: #' @return These functions are called for their side effect.
50: #' @export
51: duckdb_register_arrow <- function(conn, name, arrow_scannable) {
52:   stopifnot(dbIsValid(conn))
53: 
54:     # create some R functions to pass to c-land
55:     export_fun <- function(arrow_scannable, stream_ptr, projection=NULL, filter=TRUE) {
56:         arrow::Scanner$create(arrow_scannable, projection, filter)$ToRecordBatchReader()$export_to_c(stream_ptr)
57:     }
58:    # pass some functions to c land so we don't have to look them up there
59:    function_list <- list(export_fun, arrow::Expression$create, arrow::Expression$field_ref, arrow::Expression$scalar)
60:   .Call(duckdb_register_arrow_R, conn@conn_ref, as.character(name), function_list, arrow_scannable)
61:   invisible(TRUE)
62: }
63: 
64: #' @rdname duckdb_register_arrow
65: #' @export
66: duckdb_unregister_arrow <- function(conn, name) {
67:   stopifnot(dbIsValid(conn))
68:   .Call(duckdb_unregister_arrow_R, conn@conn_ref, as.character(name))
69:   invisible(TRUE)
70: }
[end of tools/rpkg/R/register.R]
[start of tools/rpkg/man/duckdb_register_arrow.Rd]
1: % Generated by roxygen2: do not edit by hand
2: % Please edit documentation in R/register.R
3: \name{duckdb_register_arrow}
4: \alias{duckdb_register_arrow}
5: \alias{duckdb_unregister_arrow}
6: \title{Register an Arrow data source as a virtual table}
7: \usage{
8: duckdb_register_arrow(conn, name, arrow_scannable)
9: 
10: duckdb_unregister_arrow(conn, name)
11: }
12: \arguments{
13: \item{conn}{A DuckDB connection, created by \code{dbConnect()}.}
14: 
15: \item{name}{The name for the virtual table that is registered or unregistered}
16: 
17: \item{arrow_scannable}{A scannable Arrow-object}
18: }
19: \value{
20: These functions are called for their side effect.
21: }
22: \description{
23: \code{duckdb_register_arrow()} registers an Arrow data source as a virtual table (view)
24: in a DuckDB connection.
25: No data is copied.
26: }
27: \details{
28: \code{duckdb_unregister_arrow()} unregisters a previously registered data frame.
29: }
[end of tools/rpkg/man/duckdb_register_arrow.Rd]
[start of tools/rpkg/src/connection.cpp]
1: #include "rapi.hpp"
2: 
3: using namespace duckdb;
4: 
5: static SEXP duckdb_finalize_connection_R(SEXP connsexp) {
6: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
7: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
8: 	}
9: 	Connection *connaddr = (Connection *)R_ExternalPtrAddr(connsexp);
10: 	if (connaddr) {
11: 		Rf_warning("duckdb_finalize_connection_R: Connection is garbage-collected, use dbDisconnect() to avoid this.");
12: 		R_ClearExternalPtr(connsexp);
13: 		delete connaddr;
14: 	}
15: 	return R_NilValue;
16: }
17: 
18: SEXP RApi::Connect(SEXP dbsexp) {
19: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
20: 		Rf_error("duckdb_connect_R: Need external pointer parameter");
21: 	}
22: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
23: 	if (!dbaddr) {
24: 		Rf_error("duckdb_connect_R: Invalid database reference");
25: 	}
26: 
27: 	RProtector r;
28: 	SEXP connsexp = r.Protect(R_MakeExternalPtr(new Connection(*dbaddr), R_NilValue, R_NilValue));
29: 	R_RegisterCFinalizer(connsexp, (void (*)(SEXP))duckdb_finalize_connection_R);
30: 
31: 	return connsexp;
32: }
33: 
34: SEXP RApi::Disconnect(SEXP connsexp) {
35: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
36: 		Rf_error("duckdb_disconnect_R: Need external pointer parameter");
37: 	}
38: 	Connection *connaddr = (Connection *)R_ExternalPtrAddr(connsexp);
39: 	if (connaddr) {
40: 		R_ClearExternalPtr(connsexp);
41: 		delete connaddr;
42: 	}
43: 	return R_NilValue;
44: }
[end of tools/rpkg/src/connection.cpp]
[start of tools/rpkg/src/database.cpp]
1: #include "rapi.hpp"
2: #include "duckdb/main/client_context.hpp"
3: #include "extension/extension_helper.hpp"
4: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
5: 
6: using namespace duckdb;
7: 
8: static SEXP duckdb_finalize_database_R(SEXP dbsexp) {
9: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
10: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
11: 	}
12: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
13: 	if (dbaddr) {
14: 		Rf_warning("duckdb_finalize_database_R: Database is garbage-collected, use dbDisconnect(con, shutdown=TRUE) or "
15: 		           "duckdb::duckdb_shutdown(drv) to avoid this.");
16: 		R_ClearExternalPtr(dbsexp);
17: 		delete dbaddr;
18: 	}
19: 	return R_NilValue;
20: }
21: 
22: SEXP RApi::Startup(SEXP dbdirsexp, SEXP readonlysexp, SEXP configsexp) {
23: 	if (TYPEOF(dbdirsexp) != STRSXP || Rf_length(dbdirsexp) != 1) {
24: 		Rf_error("duckdb_startup_R: Need string parameter for dbdir");
25: 	}
26: 	char *dbdir = (char *)CHAR(STRING_ELT(dbdirsexp, 0));
27: 
28: 	if (TYPEOF(readonlysexp) != LGLSXP || Rf_length(readonlysexp) != 1) {
29: 		Rf_error("duckdb_startup_R: Need string parameter for read_only");
30: 	}
31: 	bool read_only = (bool)LOGICAL_ELT(readonlysexp, 0);
32: 
33: 	if (strlen(dbdir) == 0 || strcmp(dbdir, ":memory:") == 0) {
34: 		dbdir = NULL;
35: 	}
36: 
37: 	DBConfig config;
38: 	if (read_only) {
39: 		config.access_mode = AccessMode::READ_ONLY;
40: 	}
41: 
42: 	RProtector r;
43: 	auto confignamessexp = r.Protect(GET_NAMES(configsexp));
44: 
45: 	for (idx_t i = 0; i < Rf_length(configsexp); i++) {
46: 		string key = string(CHAR(STRING_ELT(confignamessexp, i)));
47: 		string val = string(CHAR(STRING_ELT(VECTOR_ELT(configsexp, i), 0)));
48: 		auto config_property = DBConfig::GetOptionByName(key);
49: 		if (!config_property) {
50: 			Rf_error("Unrecognized configuration property '%s'", key.c_str());
51: 		}
52: 		try {
53: 			config.SetOption(*config_property, Value(val));
54: 		} catch (std::exception &e) {
55: 			Rf_error("duckdb_startup_R: Failed to set configuration option: %s", e.what());
56: 		}
57: 	}
58: 
59: 	DuckDB *dbaddr;
60: 	try {
61: 		dbaddr = new DuckDB(dbdir, &config);
62: 	} catch (std::exception &e) {
63: 		Rf_error("duckdb_startup_R: Failed to open database: %s", e.what());
64: 	}
65: 	ExtensionHelper::LoadAllExtensions(*dbaddr);
66: 
67: 	DataFrameScanFunction scan_fun;
68: 	CreateTableFunctionInfo info(scan_fun);
69: 	Connection conn(*dbaddr);
70: 	auto &context = *conn.context;
71: 	auto &catalog = Catalog::GetCatalog(context);
72: 	context.transaction.BeginTransaction();
73: 	catalog.CreateTableFunction(context, &info);
74: 	context.transaction.Commit();
75: 
76: 	SEXP dbsexp = r.Protect(R_MakeExternalPtr(dbaddr, R_NilValue, R_NilValue));
77: 	R_RegisterCFinalizer(dbsexp, (void (*)(SEXP))duckdb_finalize_database_R);
78: 	return dbsexp;
79: }
80: 
81: SEXP RApi::Shutdown(SEXP dbsexp) {
82: 	if (TYPEOF(dbsexp) != EXTPTRSXP) {
83: 		Rf_error("duckdb_finalize_connection_R: Need external pointer parameter");
84: 	}
85: 	DuckDB *dbaddr = (DuckDB *)R_ExternalPtrAddr(dbsexp);
86: 	if (dbaddr) {
87: 		R_ClearExternalPtr(dbsexp);
88: 		delete dbaddr;
89: 	}
90: 
91: 	return R_NilValue;
92: }
[end of tools/rpkg/src/database.cpp]
[start of tools/rpkg/src/include/rapi.hpp]
1: #pragma once
2: 
3: #define R_NO_REMAP
4: #include <Rdefines.h>
5: #include <R_ext/Altrep.h>
6: 
7: #include "duckdb.hpp"
8: #include "duckdb/function/table_function.hpp"
9: 
10: namespace duckdb {
11: 
12: struct RApi {
13: 
14: 	static SEXP Startup(SEXP dbdirsexp, SEXP readonlysexp, SEXP configsexp);
15: 
16: 	static SEXP Shutdown(SEXP dbsexp);
17: 
18: 	static SEXP Connect(SEXP dbsexp);
19: 
20: 	static SEXP Disconnect(SEXP connsexp);
21: 
22: 	static SEXP Prepare(SEXP connsexp, SEXP querysexp);
23: 
24: 	static SEXP Bind(SEXP stmtsexp, SEXP paramsexp, SEXP arrowsexp);
25: 
26: 	static SEXP Execute(SEXP stmtsexp, SEXP arrowsexp);
27: 
28: 	static SEXP DuckDBExecuteArrow(SEXP query_resultsexp, SEXP streamsexp, SEXP vector_per_chunksexp,
29: 	                               SEXP return_tablesexp);
30: 
31: 	static SEXP DuckDBRecordBatchR(SEXP query_resultsexp);
32: 
33: 	static SEXP Release(SEXP stmtsexp);
34: 
35: 	static SEXP RegisterDataFrame(SEXP connsexp, SEXP namesexp, SEXP valuesexp);
36: 
37: 	static SEXP UnregisterDataFrame(SEXP connsexp, SEXP namesexp);
38: 
39: 	static SEXP RegisterArrow(SEXP connsexp, SEXP namesexp, SEXP export_funsexp, SEXP valuesexp);
40: 
41: 	static SEXP UnregisterArrow(SEXP connsexp, SEXP namesexp);
42: 
43: 	static SEXP PointerToString(SEXP extptr);
44: 	static SEXP StringsToSexp(vector<string> s);
45: 
46: 	static SEXP REvalThrows(SEXP call, SEXP env = R_GlobalEnv);
47: 	static SEXP REvalRerror(SEXP call, SEXP env = R_GlobalEnv);
48: };
49: 
50: struct RProtector {
51: 	RProtector() : protect_count(0) {
52: 	}
53: 	~RProtector() {
54: 		if (protect_count > 0) {
55: 			UNPROTECT(protect_count);
56: 		}
57: 	}
58: 
59: 	SEXP Protect(SEXP sexp) {
60: 		protect_count++;
61: 		return PROTECT(sexp);
62: 	}
63: 
64: private:
65: 	int protect_count;
66: };
67: 
68: struct DataFrameScanFunction : public TableFunction {
69: 	DataFrameScanFunction();
70: };
71: 
72: struct RStrings {
73: 	SEXP secs; // Rf_mkChar
74: 	SEXP mins;
75: 	SEXP hours;
76: 	SEXP days;
77: 	SEXP weeks;
78: 	SEXP POSIXct;
79: 	SEXP POSIXt;
80: 	SEXP UTC_str; // Rf_mkString
81: 	SEXP Date_str;
82: 	SEXP difftime_str;
83: 	SEXP secs_str;
84: 	SEXP arrow_str; // StringsToSexp
85: 	SEXP POSIXct_POSIXt_str;
86: 	SEXP str_ref_type_names_rtypes_n_param_str;
87: 	SEXP tzone_sym; // Rf_install
88: 	SEXP units_sym;
89: 	SEXP getNamespace_sym;
90: 	SEXP Table__from_record_batches_sym;
91: 	SEXP ImportSchema_sym;
92: 	SEXP ImportRecordBatch_sym;
93: 	SEXP ImportRecordBatchReader_sym;
94: 
95: 	static const RStrings &get() {
96: 		// On demand
97: 		static RStrings strings;
98: 		return strings;
99: 	}
100: 
101: private:
102: 	RStrings();
103: };
104: 
105: } // namespace duckdb
[end of tools/rpkg/src/include/rapi.hpp]
[start of tools/rpkg/src/register.cpp]
1: #include "rapi.hpp"
2: #include "typesr.hpp"
3: 
4: #include "duckdb/common/arrow_wrapper.hpp"
5: #include "duckdb/planner/table_filter.hpp"
6: #include "duckdb/planner/filter/constant_filter.hpp"
7: #include "duckdb/planner/filter/conjunction_filter.hpp"
8: 
9: using namespace duckdb;
10: 
11: SEXP RApi::RegisterDataFrame(SEXP connsexp, SEXP namesexp, SEXP valuesexp) {
12: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
13: 		Rf_error("duckdb_register_R: Need external pointer parameter for connection");
14: 	}
15: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
16: 	if (!conn) {
17: 		Rf_error("duckdb_register_R: Invalid connection");
18: 	}
19: 	if (TYPEOF(namesexp) != STRSXP || Rf_length(namesexp) != 1) {
20: 		Rf_error("duckdb_register_R: Need single string parameter for name");
21: 	}
22: 	auto name = string(CHAR(STRING_ELT(namesexp, 0)));
23: 	if (name.empty()) {
24: 		Rf_error("duckdb_register_R: name parameter cannot be empty");
25: 	}
26: 	if (TYPEOF(valuesexp) != VECSXP || Rf_length(valuesexp) < 1 ||
27: 	    strcmp("data.frame", CHAR(STRING_ELT(GET_CLASS(valuesexp), 0))) != 0) {
28: 		Rf_error("duckdb_register_R: Need at least one-column data frame parameter for value");
29: 	}
30: 	try {
31: 		conn->TableFunction("r_dataframe_scan", {Value::POINTER((uintptr_t)valuesexp)})->CreateView(name, true, true);
32: 		auto key = Rf_install(("_registered_df_" + name).c_str());
33: 		Rf_setAttrib(connsexp, key, valuesexp);
34: 	} catch (std::exception &e) {
35: 		Rf_error("duckdb_register_R: Failed to register data frame: %s", e.what());
36: 	}
37: 	return R_NilValue;
38: }
39: 
40: SEXP RApi::UnregisterDataFrame(SEXP connsexp, SEXP namesexp) {
41: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
42: 		Rf_error("duckdb_unregister_R: Need external pointer parameter for connection");
43: 	}
44: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
45: 	if (!conn) {
46: 		Rf_error("duckdb_unregister_R: Invalid connection");
47: 	}
48: 	if (TYPEOF(namesexp) != STRSXP || Rf_length(namesexp) != 1) {
49: 		Rf_error("duckdb_unregister_R: Need single string parameter for name");
50: 	}
51: 	auto name = string(CHAR(STRING_ELT(namesexp, 0)));
52: 	auto key = Rf_install(("_registered_df_" + name).c_str());
53: 	Rf_setAttrib(connsexp, key, R_NilValue);
54: 	auto res = conn->Query("DROP VIEW IF EXISTS \"" + name + "\"");
55: 	if (!res->success) {
56: 		Rf_error(res->error.c_str());
57: 	}
58: 	return R_NilValue;
59: }
60: 
61: class RArrowTabularStreamFactory {
62: public:
63: 	RArrowTabularStreamFactory(SEXP export_fun_p, SEXP arrow_scannable_p)
64: 	    : arrow_scannable(arrow_scannable_p), export_fun(export_fun_p) {};
65: 
66: 	static unique_ptr<ArrowArrayStreamWrapper>
67: 	Produce(uintptr_t factory_p, std::pair<std::unordered_map<idx_t, string>, std::vector<string>> &project_columns,
68: 	        TableFilterCollection *filters) {
69: 
70: 		RProtector r;
71: 		auto res = make_unique<ArrowArrayStreamWrapper>();
72: 		auto factory = (RArrowTabularStreamFactory *)factory_p;
73: 		auto stream_ptr_sexp =
74: 		    r.Protect(Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&res->arrow_array_stream))));
75: 		SEXP export_call;
76: 
77: 		auto export_fun = r.Protect(VECTOR_ELT(factory->export_fun, 0));
78: 		if (project_columns.second.empty()) {
79: 			export_call = r.Protect(Rf_lang3(export_fun, factory->arrow_scannable, stream_ptr_sexp));
80: 		} else {
81: 			auto projection_sexp = r.Protect(RApi::StringsToSexp(project_columns.second));
82: 			SEXP filters_sexp = r.Protect(Rf_ScalarLogical(true));
83: 			if (filters && filters->table_filters && !filters->table_filters->filters.empty()) {
84: 
85: 				filters_sexp = r.Protect(TransformFilter(*filters, project_columns.first, factory->export_fun));
86: 			}
87: 			export_call = r.Protect(
88: 			    Rf_lang5(export_fun, factory->arrow_scannable, stream_ptr_sexp, projection_sexp, filters_sexp));
89: 		}
90: 		RApi::REvalThrows(export_call);
91: 		return res;
92: 	}
93: 
94: 	SEXP arrow_scannable;
95: 	SEXP export_fun;
96: 
97: private:
98: 	static SEXP TransformFilterExpression(TableFilter &filter, const string &column_name, SEXP functions) {
99: 		RProtector r;
100: 		auto column_name_sexp = r.Protect(Rf_mkString(column_name.c_str()));
101: 		auto column_name_expr = r.Protect(CreateFieldRef(functions, column_name_sexp));
102: 
103: 		switch (filter.filter_type) {
104: 		case TableFilterType::CONSTANT_COMPARISON: {
105: 			auto constant_filter = (ConstantFilter &)filter;
106: 			auto constant_sexp = r.Protect(RApiTypes::ValueToSexp(constant_filter.constant));
107: 			auto constant_expr = r.Protect(CreateScalar(functions, constant_sexp));
108: 			switch (constant_filter.comparison_type) {
109: 			case ExpressionType::COMPARE_EQUAL: {
110: 				return CreateExpression(functions, "equal", column_name_expr, constant_expr);
111: 			}
112: 			case ExpressionType::COMPARE_GREATERTHAN: {
113: 				return CreateExpression(functions, "greater", column_name_expr, constant_expr);
114: 			}
115: 			case ExpressionType::COMPARE_GREATERTHANOREQUALTO: {
116: 				return CreateExpression(functions, "greater_equal", column_name_expr, constant_expr);
117: 			}
118: 			case ExpressionType::COMPARE_LESSTHAN: {
119: 				return CreateExpression(functions, "less", column_name_expr, constant_expr);
120: 			}
121: 			case ExpressionType::COMPARE_LESSTHANOREQUALTO: {
122: 				return CreateExpression(functions, "less_equal", column_name_expr, constant_expr);
123: 			}
124: 			case ExpressionType::COMPARE_NOTEQUAL: {
125: 				return CreateExpression(functions, "not_equal", column_name_expr, constant_expr);
126: 			}
127: 			default:
128: 				throw InternalException("%s can't be transformed to Arrow Scan Pushdown Filter",
129: 				                        filter.ToString(column_name));
130: 			}
131: 		}
132: 		case TableFilterType::IS_NULL: {
133: 			return CreateExpression(functions, "is_null", column_name_expr);
134: 		}
135: 		case TableFilterType::IS_NOT_NULL: {
136: 			auto is_null_expr = r.Protect(CreateExpression(functions, "is_null", column_name_expr));
137: 			return CreateExpression(functions, "invert", is_null_expr);
138: 		}
139: 		case TableFilterType::CONJUNCTION_AND: {
140: 			auto &and_filter = (ConjunctionAndFilter &)filter;
141: 			return TransformChildFilters(functions, column_name, "and", and_filter.child_filters);
142: 		}
143: 		case TableFilterType::CONJUNCTION_OR: {
144: 			auto &and_filter = (ConjunctionAndFilter &)filter;
145: 			return TransformChildFilters(functions, column_name, "or", and_filter.child_filters);
146: 		}
147: 
148: 		default:
149: 			throw NotImplementedException("Arrow table filter pushdown %s not supported yet",
150: 			                              filter.ToString(column_name));
151: 		}
152: 	}
153: 
154: 	static SEXP TransformChildFilters(SEXP functions, const string &column_name, const string op,
155: 	                                  vector<unique_ptr<TableFilter>> &filters) {
156: 		auto fit = filters.begin();
157: 		RProtector r;
158: 		auto conjunction_sexp = r.Protect(TransformFilterExpression(**fit, column_name, functions));
159: 		fit++;
160: 		for (; fit != filters.end(); ++fit) {
161: 			SEXP rhs = r.Protect(TransformFilterExpression(**fit, column_name, functions));
162: 			conjunction_sexp = r.Protect(CreateExpression(functions, op, conjunction_sexp, rhs));
163: 		}
164: 		return conjunction_sexp;
165: 	}
166: 
167: 	static SEXP TransformFilter(TableFilterCollection &filter_collection, std::unordered_map<idx_t, string> &columns,
168: 	                            SEXP functions) {
169: 		RProtector r;
170: 
171: 		auto fit = filter_collection.table_filters->filters.begin();
172: 		SEXP res = r.Protect(TransformFilterExpression(*fit->second, columns[fit->first], functions));
173: 		fit++;
174: 		for (; fit != filter_collection.table_filters->filters.end(); ++fit) {
175: 			SEXP rhs = r.Protect(TransformFilterExpression(*fit->second, columns[fit->first], functions));
176: 			res = r.Protect(CreateExpression(functions, "and", res, rhs));
177: 		}
178: 		return res;
179: 	}
180: 
181: 	static SEXP CallArrowFactory(SEXP functions, idx_t idx, SEXP op1, SEXP op2 = R_NilValue, SEXP op3 = R_NilValue) {
182: 		RProtector r;
183: 		auto create_fun = r.Protect(VECTOR_ELT(functions, idx));
184: 		SEXP create_call;
185: 		if (Rf_isNull(op2)) {
186: 			create_call = r.Protect(Rf_lang2(create_fun, op1));
187: 		} else if (Rf_isNull(op3)) {
188: 			create_call = r.Protect(Rf_lang3(create_fun, op1, op2));
189: 		} else {
190: 			create_call = r.Protect(Rf_lang4(create_fun, op1, op2, op3));
191: 		}
192: 
193: 		return RApi::REvalThrows(create_call);
194: 	}
195: 
196: 	static SEXP CreateExpression(SEXP functions, const string name, SEXP op1, SEXP op2 = R_NilValue) {
197: 		RProtector r;
198: 		auto name_sexp = r.Protect(Rf_mkString(name.c_str()));
199: 		return CallArrowFactory(functions, 1, name_sexp, op1, op2);
200: 	}
201: 
202: 	static SEXP CreateFieldRef(SEXP functions, SEXP op) {
203: 		return CallArrowFactory(functions, 2, op);
204: 	}
205: 
206: 	static SEXP CreateScalar(SEXP functions, SEXP op) {
207: 		return CallArrowFactory(functions, 3, op);
208: 	}
209: };
210: 
211: static SEXP duckdb_finalize_arrow_factory_R(SEXP factorysexp) {
212: 	if (TYPEOF(factorysexp) != EXTPTRSXP) {
213: 		Rf_error("duckdb_finalize_arrow_factory_R: Need external pointer parameter");
214: 	}
215: 	auto *factoryaddr = (RArrowTabularStreamFactory *)R_ExternalPtrAddr(factorysexp);
216: 	if (factoryaddr) {
217: 		R_ClearExternalPtr(factorysexp);
218: 		delete factoryaddr;
219: 	}
220: 	return R_NilValue;
221: }
222: 
223: SEXP RApi::RegisterArrow(SEXP connsexp, SEXP namesexp, SEXP export_funsexp, SEXP valuesexp) {
224: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
225: 		Rf_error("duckdb_register_R: Need external pointer parameter for connection");
226: 	}
227: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
228: 	if (!conn) {
229: 		Rf_error("duckdb_register_R: Invalid connection");
230: 	}
231: 	if (TYPEOF(namesexp) != STRSXP || Rf_length(namesexp) != 1) {
232: 		Rf_error("duckdb_register_R: Need single string parameter for name");
233: 	}
234: 	auto name = string(CHAR(STRING_ELT(namesexp, 0)));
235: 	if (name.empty()) {
236: 		Rf_error("duckdb_register_R: name parameter cannot be empty");
237: 	}
238: 
239: 	if (!IS_LIST(export_funsexp)) {
240: 		Rf_error("duckdb_register_R: Need function list for export function");
241: 	}
242: 
243: 	RProtector r;
244: 	auto stream_factory = new RArrowTabularStreamFactory(export_funsexp, valuesexp);
245: 	auto stream_factory_produce = RArrowTabularStreamFactory::Produce;
246: 	conn->TableFunction("arrow_scan", {Value::POINTER((uintptr_t)stream_factory),
247: 	                                   Value::POINTER((uintptr_t)stream_factory_produce), Value::UBIGINT(100000)})
248: 	    ->CreateView(name, true, true);
249: 
250: 	// make r external ptr object to keep factory around until arrow table is unregistered
251: 	SEXP factorysexp = r.Protect(R_MakeExternalPtr(stream_factory, R_NilValue, R_NilValue));
252: 	R_RegisterCFinalizer(factorysexp, (void (*)(SEXP))duckdb_finalize_arrow_factory_R);
253: 
254: 	SEXP state_list = r.Protect(NEW_LIST(3));
255: 	SET_VECTOR_ELT(state_list, 0, export_funsexp);
256: 	SET_VECTOR_ELT(state_list, 1, valuesexp);
257: 	SET_VECTOR_ELT(state_list, 2, factorysexp);
258: 
259: 	auto key = Rf_install(("_registered_arrow_" + name).c_str());
260: 	Rf_setAttrib(connsexp, key, state_list);
261: 
262: 	return R_NilValue;
263: }
264: 
265: SEXP RApi::UnregisterArrow(SEXP connsexp, SEXP namesexp) {
266: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
267: 		Rf_error("duckdb_unregister_R: Need external pointer parameter for connection");
268: 	}
269: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
270: 	if (!conn) {
271: 		Rf_error("duckdb_unregister_R: Invalid connection");
272: 	}
273: 	if (TYPEOF(namesexp) != STRSXP || Rf_length(namesexp) != 1) {
274: 		Rf_error("duckdb_unregister_R: Need single string parameter for name");
275: 	}
276: 	auto name = string(CHAR(STRING_ELT(namesexp, 0)));
277: 	auto key = Rf_install(("_registered_arrow_" + name).c_str());
278: 	Rf_setAttrib(connsexp, key, R_NilValue);
279: 	auto res = conn->Query("DROP VIEW IF EXISTS \"" + name + "\"");
280: 	if (!res->success) {
281: 		Rf_error(res->error.c_str());
282: 	}
283: 	return R_NilValue;
284: }
[end of tools/rpkg/src/register.cpp]
[start of tools/rpkg/src/statement.cpp]
1: #include "altrepstring.hpp"
2: #include "duckdb/common/arrow.hpp"
3: #include "duckdb/common/types/timestamp.hpp"
4: #include "rapi.hpp"
5: #include "typesr.hpp"
6: 
7: #include "duckdb/common/arrow_wrapper.hpp"
8: 
9: using namespace duckdb;
10: 
11: // converter for primitive types
12: template <class SRC, class DEST>
13: static void VectorToR(Vector &src_vec, size_t count, void *dest, uint64_t dest_offset, DEST na_val) {
14: 	auto src_ptr = FlatVector::GetData<SRC>(src_vec);
15: 	auto &mask = FlatVector::Validity(src_vec);
16: 	auto dest_ptr = ((DEST *)dest) + dest_offset;
17: 	for (size_t row_idx = 0; row_idx < count; row_idx++) {
18: 		dest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? na_val : src_ptr[row_idx];
19: 	}
20: }
21: 
22: struct RStatement {
23: 	unique_ptr<PreparedStatement> stmt;
24: 	vector<Value> parameters;
25: };
26: 
27: SEXP RApi::Release(SEXP stmtsexp) {
28: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
29: 		Rf_error("duckdb_release_R: Need external pointer parameter");
30: 	}
31: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
32: 	if (stmtsexp) {
33: 		R_ClearExternalPtr(stmtsexp);
34: 		delete stmtholder;
35: 	}
36: 	return R_NilValue;
37: }
38: 
39: static SEXP duckdb_finalize_statement_R(SEXP stmtsexp) {
40: 	return RApi::Release(stmtsexp);
41: }
42: 
43: SEXP RApi::Prepare(SEXP connsexp, SEXP querysexp) {
44: 	RProtector r;
45: 	if (TYPEOF(querysexp) != STRSXP || Rf_length(querysexp) != 1) {
46: 		Rf_error("duckdb_prepare_R: Need single string parameter for query");
47: 	}
48: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
49: 		Rf_error("duckdb_prepare_R: Need external pointer parameter for connections");
50: 	}
51: 
52: 	char *query = (char *)CHAR(STRING_ELT(querysexp, 0));
53: 	if (!query) {
54: 		Rf_error("duckdb_prepare_R: No query");
55: 	}
56: 
57: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
58: 	if (!conn) {
59: 		Rf_error("duckdb_prepare_R: Invalid connection");
60: 	}
61: 
62: 	auto stmt = conn->Prepare(query);
63: 	if (!stmt->success) {
64: 		Rf_error("duckdb_prepare_R: Failed to prepare query %s\nError: %s", query, stmt->error.c_str());
65: 	}
66: 
67: 	auto stmtholder = new RStatement();
68: 	stmtholder->stmt = move(stmt);
69: 
70: 	SEXP retlist = r.Protect(NEW_LIST(6));
71: 
72: 	SEXP stmtsexp = r.Protect(R_MakeExternalPtr(stmtholder, R_NilValue, R_NilValue));
73: 	R_RegisterCFinalizer(stmtsexp, (void (*)(SEXP))duckdb_finalize_statement_R);
74: 
75: 	SET_NAMES(retlist, RStrings::get().str_ref_type_names_rtypes_n_param_str);
76: 
77: 	SET_VECTOR_ELT(retlist, 0, querysexp);
78: 	SET_VECTOR_ELT(retlist, 1, stmtsexp);
79: 
80: 	SEXP stmt_type = RApi::StringsToSexp({StatementTypeToString(stmtholder->stmt->GetStatementType())});
81: 	SET_VECTOR_ELT(retlist, 2, stmt_type);
82: 
83: 	SEXP col_names = RApi::StringsToSexp(stmtholder->stmt->GetNames());
84: 	SET_VECTOR_ELT(retlist, 3, col_names);
85: 
86: 	vector<string> rtypes;
87: 
88: 	for (auto &stype : stmtholder->stmt->GetTypes()) {
89: 		string rtype = "";
90: 		switch (stype.id()) {
91: 		case LogicalTypeId::BOOLEAN:
92: 			rtype = "logical";
93: 			break;
94: 		case LogicalTypeId::UTINYINT:
95: 		case LogicalTypeId::TINYINT:
96: 		case LogicalTypeId::USMALLINT:
97: 		case LogicalTypeId::SMALLINT:
98: 		case LogicalTypeId::INTEGER:
99: 			rtype = "integer";
100: 			break;
101: 		case LogicalTypeId::TIMESTAMP:
102: 			rtype = "POSIXct";
103: 			break;
104: 		case LogicalTypeId::DATE:
105: 			rtype = "Date";
106: 			break;
107: 		case LogicalTypeId::TIME:
108: 			rtype = "difftime";
109: 			break;
110: 		case LogicalTypeId::UINTEGER:
111: 		case LogicalTypeId::UBIGINT:
112: 		case LogicalTypeId::BIGINT:
113: 		case LogicalTypeId::HUGEINT:
114: 		case LogicalTypeId::FLOAT:
115: 		case LogicalTypeId::DOUBLE:
116: 		case LogicalTypeId::DECIMAL:
117: 			rtype = "numeric";
118: 			break;
119: 		case LogicalTypeId::VARCHAR:
120: 			rtype = "character";
121: 			break;
122: 		case LogicalTypeId::BLOB:
123: 			rtype = "raw";
124: 			break;
125: 		case LogicalTypeId::LIST:
126: 			rtype = "list";
127: 			break;
128: 		default:
129: 			Rf_error("duckdb_prepare_R: Unknown column type for prepare: %s", stype.ToString().c_str());
130: 			break;
131: 		}
132: 		rtypes.push_back(rtype);
133: 	}
134: 
135: 	SEXP rtypessexp = StringsToSexp(rtypes);
136: 	SET_VECTOR_ELT(retlist, 4, rtypessexp);
137: 
138: 	SET_VECTOR_ELT(retlist, 5, Rf_ScalarInteger(stmtholder->stmt->n_param));
139: 
140: 	return retlist;
141: }
142: 
143: SEXP RApi::Bind(SEXP stmtsexp, SEXP paramsexp, SEXP arrowsexp) {
144: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
145: 		Rf_error("duckdb_bind_R: Need external pointer parameter");
146: 	}
147: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
148: 	if (!stmtholder || !stmtholder->stmt) {
149: 		Rf_error("duckdb_bind_R: Invalid statement");
150: 	}
151: 
152: 	stmtholder->parameters.clear();
153: 	stmtholder->parameters.resize(stmtholder->stmt->n_param);
154: 
155: 	if (stmtholder->stmt->n_param == 0) {
156: 		Rf_error("duckdb_bind_R: dbBind called but query takes no parameters");
157: 	}
158: 
159: 	if (TYPEOF(paramsexp) != VECSXP || (idx_t)Rf_length(paramsexp) != stmtholder->stmt->n_param) {
160: 		Rf_error("duckdb_bind_R: bind parameters need to be a list of length %i", stmtholder->stmt->n_param);
161: 	}
162: 
163: 	if (TYPEOF(arrowsexp) != LGLSXP) {
164: 		Rf_error("duckdb_bind_R: Need logical for third parameter");
165: 	}
166: 
167: 	bool arrow_fetch = LOGICAL_POINTER(arrowsexp)[0] != 0;
168: 
169: 	R_len_t n_rows = Rf_length(VECTOR_ELT(paramsexp, 0));
170: 
171: 	for (idx_t param_idx = 1; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {
172: 		SEXP valsexp = VECTOR_ELT(paramsexp, param_idx);
173: 		if (Rf_length(valsexp) != n_rows) {
174: 			Rf_error("duckdb_bind_R: bind parameter values need to have the same length");
175: 		}
176: 	}
177: 
178: 	if (n_rows != 1 && arrow_fetch) {
179: 		Rf_error("duckdb_bind_R: bind parameter values need to have length one for arrow queries");
180: 	}
181: 
182: 	RProtector r;
183: 	auto out = r.Protect(NEW_LIST(n_rows));
184: 
185: 	for (idx_t row_idx = 0; row_idx < n_rows; ++row_idx) {
186: 		for (idx_t param_idx = 0; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {
187: 			SEXP valsexp = VECTOR_ELT(paramsexp, param_idx);
188: 			auto val = RApiTypes::SexpToValue(valsexp, row_idx);
189: 			stmtholder->parameters[param_idx] = val;
190: 		}
191: 
192: 		// No protection, assigned immediately
193: 		auto exec_result = RApi::Execute(stmtsexp, arrowsexp);
194: 		SET_VECTOR_ELT(out, row_idx, exec_result);
195: 	}
196: 
197: 	return out;
198: }
199: 
200: static SEXP allocate(const LogicalType &type, RProtector &r_varvalue, idx_t nrows) {
201: 	SEXP varvalue = NULL;
202: 	switch (type.id()) {
203: 	case LogicalTypeId::BOOLEAN:
204: 		varvalue = r_varvalue.Protect(NEW_LOGICAL(nrows));
205: 		break;
206: 	case LogicalTypeId::UTINYINT:
207: 	case LogicalTypeId::TINYINT:
208: 	case LogicalTypeId::SMALLINT:
209: 	case LogicalTypeId::USMALLINT:
210: 	case LogicalTypeId::INTEGER:
211: 		varvalue = r_varvalue.Protect(NEW_INTEGER(nrows));
212: 		break;
213: 	case LogicalTypeId::UINTEGER:
214: 	case LogicalTypeId::UBIGINT:
215: 	case LogicalTypeId::BIGINT:
216: 	case LogicalTypeId::HUGEINT:
217: 	case LogicalTypeId::FLOAT:
218: 	case LogicalTypeId::DOUBLE:
219: 	case LogicalTypeId::DECIMAL:
220: 	case LogicalTypeId::TIMESTAMP:
221: 	case LogicalTypeId::DATE:
222: 	case LogicalTypeId::TIME:
223: 		varvalue = r_varvalue.Protect(NEW_NUMERIC(nrows));
224: 		break;
225: 	case LogicalTypeId::LIST:
226: 		varvalue = r_varvalue.Protect(NEW_LIST(nrows));
227: 		break;
228: 	case LogicalTypeId::VARCHAR: {
229: 		auto wrapper = new DuckDBAltrepStringWrapper();
230: 		wrapper->length = nrows;
231: 
232: 		auto ptr = PROTECT(R_MakeExternalPtr((void *)wrapper, R_NilValue, R_NilValue));
233: 		R_RegisterCFinalizer(ptr, AltrepString::Finalize);
234: 		varvalue = r_varvalue.Protect(R_new_altrep(AltrepString::rclass, ptr, R_NilValue));
235: 		UNPROTECT(1);
236: 		break;
237: 	}
238: 
239: 	case LogicalTypeId::BLOB:
240: 		varvalue = r_varvalue.Protect(NEW_LIST(nrows));
241: 		break;
242: 	default:
243: 		Rf_error("duckdb_execute_R: Unknown column type for execute: %s", type.ToString().c_str());
244: 	}
245: 	if (!varvalue) {
246: 		throw std::bad_alloc();
247: 	}
248: 	return varvalue;
249: }
250: 
251: static void transform(Vector &src_vec, SEXP &dest, idx_t dest_offset, idx_t n) {
252: 	switch (src_vec.GetType().id()) {
253: 	case LogicalTypeId::BOOLEAN:
254: 		VectorToR<int8_t, uint32_t>(src_vec, n, LOGICAL_POINTER(dest), dest_offset, NA_LOGICAL);
255: 		break;
256: 	case LogicalTypeId::UTINYINT:
257: 		VectorToR<uint8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
258: 		break;
259: 	case LogicalTypeId::TINYINT:
260: 		VectorToR<int8_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
261: 		break;
262: 	case LogicalTypeId::USMALLINT:
263: 		VectorToR<uint16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
264: 		break;
265: 	case LogicalTypeId::SMALLINT:
266: 		VectorToR<int16_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
267: 		break;
268: 	case LogicalTypeId::INTEGER:
269: 		VectorToR<int32_t, uint32_t>(src_vec, n, INTEGER_POINTER(dest), dest_offset, NA_INTEGER);
270: 		break;
271: 	case LogicalTypeId::TIMESTAMP: {
272: 		auto src_data = FlatVector::GetData<timestamp_t>(src_vec);
273: 		auto &mask = FlatVector::Validity(src_vec);
274: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
275: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
276: 			dest_ptr[row_idx] =
277: 			    !mask.RowIsValid(row_idx) ? NA_REAL : (double)Timestamp::GetEpochSeconds(src_data[row_idx]);
278: 		}
279: 
280: 		// some dresssup for R
281: 		SET_CLASS(dest, RStrings::get().POSIXct_POSIXt_str);
282: 		Rf_setAttrib(dest, RStrings::get().tzone_sym, RStrings::get().UTC_str);
283: 		break;
284: 	}
285: 	case LogicalTypeId::DATE: {
286: 		auto src_data = FlatVector::GetData<date_t>(src_vec);
287: 		auto &mask = FlatVector::Validity(src_vec);
288: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
289: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
290: 			dest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? NA_REAL : (double)int32_t(src_data[row_idx]);
291: 		}
292: 
293: 		// some dresssup for R
294: 		SET_CLASS(dest, RStrings::get().Date_str);
295: 		break;
296: 	}
297: 	case LogicalTypeId::TIME: {
298: 		auto src_data = FlatVector::GetData<dtime_t>(src_vec);
299: 		auto &mask = FlatVector::Validity(src_vec);
300: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
301: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
302: 			if (!mask.RowIsValid(row_idx)) {
303: 				dest_ptr[row_idx] = NA_REAL;
304: 			} else {
305: 				dtime_t n = src_data[row_idx];
306: 				dest_ptr[row_idx] = n.micros / 1000000.0;
307: 			}
308: 		}
309: 
310: 		// some dress-up for R
311: 		SET_CLASS(dest, RStrings::get().difftime_str);
312: 		Rf_setAttrib(dest, RStrings::get().units_sym, RStrings::get().secs_str);
313: 		break;
314: 	}
315: 	case LogicalTypeId::UINTEGER:
316: 		VectorToR<uint32_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
317: 		break;
318: 	case LogicalTypeId::UBIGINT:
319: 		VectorToR<uint64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
320: 		break;
321: 	case LogicalTypeId::BIGINT:
322: 		VectorToR<int64_t, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
323: 		break;
324: 	case LogicalTypeId::HUGEINT: {
325: 		auto src_data = FlatVector::GetData<hugeint_t>(src_vec);
326: 		auto &mask = FlatVector::Validity(src_vec);
327: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
328: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
329: 			if (!mask.RowIsValid(row_idx)) {
330: 				dest_ptr[row_idx] = NA_REAL;
331: 			} else {
332: 				Hugeint::TryCast(src_data[row_idx], dest_ptr[row_idx]);
333: 			}
334: 		}
335: 		break;
336: 	}
337: 	case LogicalTypeId::DECIMAL: {
338: 		auto &decimal_type = src_vec.GetType();
339: 		double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
340: 		auto dec_scale = DecimalType::GetScale(decimal_type);
341: 		switch (decimal_type.InternalType()) {
342: 		case PhysicalType::INT16:
343: 			RDecimalCastLoop<int16_t>(src_vec, n, dest_ptr, dec_scale);
344: 			break;
345: 		case PhysicalType::INT32:
346: 			RDecimalCastLoop<int32_t>(src_vec, n, dest_ptr, dec_scale);
347: 			break;
348: 		case PhysicalType::INT64:
349: 			RDecimalCastLoop<int64_t>(src_vec, n, dest_ptr, dec_scale);
350: 			break;
351: 		case PhysicalType::INT128:
352: 			RDecimalCastLoop<hugeint_t>(src_vec, n, dest_ptr, dec_scale);
353: 			break;
354: 		default:
355: 			throw NotImplementedException("Unimplemented internal type for DECIMAL");
356: 		}
357: 		break;
358: 	}
359: 	case LogicalTypeId::FLOAT:
360: 		VectorToR<float, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
361: 		break;
362: 
363: 	case LogicalTypeId::DOUBLE:
364: 		VectorToR<double, double>(src_vec, n, NUMERIC_POINTER(dest), dest_offset, NA_REAL);
365: 		break;
366: 	case LogicalTypeId::VARCHAR: {
367: 		auto wrapper = (DuckDBAltrepStringWrapper *)R_ExternalPtrAddr(R_altrep_data1(dest));
368: 		wrapper->vectors.emplace_back(LogicalType::VARCHAR, nullptr);
369: 		wrapper->vectors.back().Reference(src_vec);
370: 		break;
371: 	}
372: 	case LogicalTypeId::LIST: {
373: 		RProtector list_prot;
374: 		// figure out the total and max element length of the list vector child
375: 		auto src_data = ListVector::GetData(src_vec);
376: 		auto &child_type = ListType::GetChildType(src_vec.GetType());
377: 		Vector child_vector(child_type, nullptr);
378: 
379: 		// actual loop over rows
380: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
381: 			if (!FlatVector::Validity(src_vec).RowIsValid(row_idx)) {
382: 				SET_ELEMENT(dest, dest_offset + row_idx, Rf_ScalarLogical(NA_LOGICAL));
383: 			} else {
384: 				child_vector.Slice(ListVector::GetEntry(src_vec), src_data[row_idx].offset);
385: 
386: 				RProtector ele_prot;
387: 				// transform the list child vector to a single R SEXP
388: 				auto list_element =
389: 				    allocate(ListType::GetChildType(src_vec.GetType()), ele_prot, src_data[row_idx].length);
390: 				transform(child_vector, list_element, 0, src_data[row_idx].length);
391: 
392: 				// call R's own extract subset method
393: 				SET_ELEMENT(dest, dest_offset + row_idx, list_element);
394: 			}
395: 		}
396: 		break;
397: 	}
398: 	case LogicalTypeId::BLOB: {
399: 		auto src_ptr = FlatVector::GetData<string_t>(src_vec);
400: 		auto &mask = FlatVector::Validity(src_vec);
401: 		for (size_t row_idx = 0; row_idx < n; row_idx++) {
402: 			if (!mask.RowIsValid(row_idx)) {
403: 				SET_VECTOR_ELT(dest, dest_offset + row_idx, Rf_ScalarLogical(NA_LOGICAL));
404: 			} else {
405: 				SEXP rawval = NEW_RAW(src_ptr[row_idx].GetSize());
406: 				if (!rawval) {
407: 					throw std::bad_alloc();
408: 				}
409: 				memcpy(RAW_POINTER(rawval), src_ptr[row_idx].GetDataUnsafe(), src_ptr[row_idx].GetSize());
410: 				SET_VECTOR_ELT(dest, dest_offset + row_idx, rawval);
411: 			}
412: 		}
413: 		break;
414: 	}
415: 	default:
416: 		Rf_error("duckdb_execute_R: Unknown column type for convert: %s", src_vec.GetType().ToString().c_str());
417: 		break;
418: 	}
419: }
420: 
421: static SEXP duckdb_execute_R_impl(MaterializedQueryResult *result) {
422: 	RProtector r;
423: 	// step 2: create result data frame and allocate columns
424: 	uint32_t ncols = result->types.size();
425: 	if (ncols == 0) {
426: 		return Rf_ScalarReal(0); // no need for protection because no allocation can happen afterwards
427: 	}
428: 
429: 	uint64_t nrows = result->collection.Count();
430: 	SEXP retlist = r.Protect(NEW_LIST(ncols));
431: 	SET_NAMES(retlist, RApi::StringsToSexp(result->names));
432: 
433: 	for (size_t col_idx = 0; col_idx < ncols; col_idx++) {
434: 		// TODO move the protector to allocate?
435: 		RProtector r_varvalue;
436: 		auto varvalue = allocate(result->types[col_idx], r_varvalue, nrows);
437: 		SET_VECTOR_ELT(retlist, col_idx, varvalue);
438: 	}
439: 
440: 	// at this point retlist is fully allocated and the only protected SEXP
441: 
442: 	// step 3: set values from chunks
443: 	uint64_t dest_offset = 0;
444: 	idx_t chunk_idx = 0;
445: 	while (true) {
446: 		auto chunk = result->Fetch();
447: 		if (!chunk || chunk->size() == 0) {
448: 			break;
449: 		}
450: 
451: 		D_ASSERT(chunk->ColumnCount() == ncols);
452: 		D_ASSERT(chunk->ColumnCount() == (idx_t)Rf_length(retlist));
453: 		for (size_t col_idx = 0; col_idx < chunk->ColumnCount(); col_idx++) {
454: 			SEXP dest = VECTOR_ELT(retlist, col_idx);
455: 			transform(chunk->data[col_idx], dest, dest_offset, chunk->size());
456: 		}
457: 		dest_offset += chunk->size();
458: 		chunk_idx++;
459: 	}
460: 
461: 	D_ASSERT(dest_offset == nrows);
462: 	return retlist;
463: }
464: 
465: struct AppendableRList {
466: 	AppendableRList() {
467: 		the_list = r.Protect(NEW_LIST(capacity));
468: 	}
469: 	void PrepAppend() {
470: 		if (size >= capacity) {
471: 			capacity = capacity * 2;
472: 			SEXP new_list = r.Protect(NEW_LIST(capacity));
473: 			D_ASSERT(new_list);
474: 			for (idx_t i = 0; i < size; i++) {
475: 				SET_VECTOR_ELT(new_list, i, VECTOR_ELT(the_list, i));
476: 			}
477: 			the_list = new_list;
478: 		}
479: 	}
480: 
481: 	void Append(SEXP val) {
482: 		D_ASSERT(size < capacity);
483: 		D_ASSERT(the_list != R_NilValue);
484: 		SET_VECTOR_ELT(the_list, size++, val);
485: 	}
486: 	SEXP the_list;
487: 	idx_t capacity = 1000;
488: 	idx_t size = 0;
489: 	RProtector r;
490: };
491: 
492: struct RQueryResult {
493: 	unique_ptr<QueryResult> result;
494: };
495: 
496: bool FetchArrowChunk(QueryResult *result, AppendableRList &batches_list, ArrowArray &arrow_data,
497:                      ArrowSchema &arrow_schema, SEXP &batch_import_from_c, SEXP &arrow_namespace) {
498: 	if (result->type == QueryResultType::STREAM_RESULT) {
499: 		auto stream_result = (StreamQueryResult *)result;
500: 		if (!stream_result->is_open) {
501: 			return false;
502: 		}
503: 	}
504: 	unique_ptr<DataChunk> data_chunk = result->Fetch();
505: 	if (!data_chunk || data_chunk->size() == 0) {
506: 		return false;
507: 	}
508: 	result->ToArrowSchema(&arrow_schema);
509: 	data_chunk->ToArrowArray(&arrow_data);
510: 	batches_list.PrepAppend();
511: 	batches_list.Append(RApi::REvalRerror(batch_import_from_c, arrow_namespace));
512: 	return true;
513: }
514: 
515: // Turn a DuckDB result set into an Arrow Table
516: SEXP RApi::DuckDBExecuteArrow(SEXP query_resultsexp, SEXP streamsexp, SEXP vector_per_chunksexp,
517:                               SEXP return_tablesexp) {
518: 	RProtector r;
519: 	RQueryResult *query_result_holder = (RQueryResult *)R_ExternalPtrAddr(query_resultsexp);
520: 	auto result = query_result_holder->result.get();
521: 	// somewhat dark magic below
522: 	SEXP arrow_namespace_call = r.Protect(Rf_lang2(RStrings::get().getNamespace_sym, RStrings::get().arrow_str));
523: 	SEXP arrow_namespace = r.Protect(RApi::REvalRerror(arrow_namespace_call, R_GlobalEnv));
524: 	bool stream = LOGICAL_POINTER(streamsexp)[0] != 0;
525: 	int num_of_vectors = NUMERIC_POINTER(vector_per_chunksexp)[0];
526: 	bool return_table = LOGICAL_POINTER(return_tablesexp)[0] != 0;
527: 	if (TYPEOF(streamsexp) != LGLSXP || LENGTH(streamsexp) != 1) {
528: 		Rf_error("stream parameter needs to be single-value logical");
529: 	}
530: 	if (TYPEOF(return_tablesexp) != LGLSXP || LENGTH(return_tablesexp) != 1) {
531: 		Rf_error("return_table parameter needs to be single-value logical");
532: 	}
533: 	if (TYPEOF(vector_per_chunksexp) != REALSXP || LENGTH(vector_per_chunksexp) != 1) {
534: 		Rf_error("vector_per_chunks parameter needs to be single-value numeric");
535: 	}
536: 	// export schema setup
537: 	ArrowSchema arrow_schema;
538: 	auto schema_ptr_sexp = r.Protect(Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&arrow_schema))));
539: 	auto schema_import_from_c = r.Protect(Rf_lang2(RStrings::get().ImportSchema_sym, schema_ptr_sexp));
540: 
541: 	// export data setup
542: 	ArrowArray arrow_data;
543: 	auto data_ptr_sexp = r.Protect(Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&arrow_data))));
544: 	auto batch_import_from_c =
545: 	    r.Protect(Rf_lang3(RStrings::get().ImportRecordBatch_sym, data_ptr_sexp, schema_ptr_sexp));
546: 	// create data batches
547: 	AppendableRList batches_list;
548: 	if (stream) {
549: 		for (idx_t i = 0; i < num_of_vectors; i++) {
550: 			if (!FetchArrowChunk(result, batches_list, arrow_data, arrow_schema, batch_import_from_c,
551: 			                     arrow_namespace)) {
552: 				break;
553: 			}
554: 		}
555: 	} else {
556: 		while (FetchArrowChunk(result, batches_list, arrow_data, arrow_schema, batch_import_from_c, arrow_namespace)) {
557: 		}
558: 	}
559: 
560: 	SET_LENGTH(batches_list.the_list, batches_list.size);
561: 
562: 	result->ToArrowSchema(&arrow_schema);
563: 	SEXP schema_arrow_obj = r.Protect(RApi::REvalRerror(schema_import_from_c, arrow_namespace));
564: 
565: 	// create arrow::Table
566: 	if (return_table) {
567: 		auto from_record_batches = r.Protect(
568: 		    Rf_lang3(RStrings::get().Table__from_record_batches_sym, batches_list.the_list, schema_arrow_obj));
569: 		return RApi::REvalRerror(from_record_batches, arrow_namespace);
570: 	}
571: 	return batches_list.the_list;
572: }
573: 
574: // Turn a DuckDB result set into an RecordBatchReader
575: SEXP RApi::DuckDBRecordBatchR(SEXP query_resultsexp) {
576: 	RProtector r;
577: 	RQueryResult *query_result_holder = (RQueryResult *)R_ExternalPtrAddr(query_resultsexp);
578: 	// somewhat dark magic below
579: 	SEXP arrow_namespace_call = r.Protect(Rf_lang2(RStrings::get().getNamespace_sym, RStrings::get().arrow_str));
580: 	SEXP arrow_namespace = r.Protect(RApi::REvalRerror(arrow_namespace_call, R_GlobalEnv));
581: 
582: 	ResultArrowArrayStreamWrapper *result_stream = new ResultArrowArrayStreamWrapper(move(query_result_holder->result));
583: 	auto stream_ptr_sexp =
584: 	    r.Protect(Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&result_stream->stream))));
585: 	auto record_batch_reader = r.Protect(Rf_lang2(RStrings::get().ImportRecordBatchReader_sym, stream_ptr_sexp));
586: 	return RApi::REvalRerror(record_batch_reader, arrow_namespace);
587: }
588: 
589: static SEXP DuckDBFinalizeQueryR(SEXP query_resultsexp) {
590: 	RQueryResult *query_result_holder = (RQueryResult *)R_ExternalPtrAddr(query_resultsexp);
591: 	if (query_resultsexp) {
592: 		R_ClearExternalPtr(query_resultsexp);
593: 		delete query_result_holder;
594: 	}
595: 	return R_NilValue;
596: }
597: 
598: SEXP RApi::Execute(SEXP stmtsexp, SEXP arrowsexp) {
599: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
600: 		Rf_error("duckdb_execute_R: Need external pointer for first parameter");
601: 	}
602: 	if (TYPEOF(arrowsexp) != LGLSXP) {
603: 		Rf_error("duckdb_execute_R: Need logical for second parameter");
604: 	}
605: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
606: 	if (!stmtholder || !stmtholder->stmt) {
607: 		Rf_error("duckdb_execute_R: Invalid statement");
608: 	}
609: 
610: 	bool arrow_fetch = LOGICAL_POINTER(arrowsexp)[0] != 0;
611: 	auto generic_result = stmtholder->stmt->Execute(stmtholder->parameters, arrow_fetch);
612: 	if (!generic_result->success) {
613: 		Rf_error("duckdb_execute_R: Failed to run query\nError: %s", generic_result->error.c_str());
614: 	}
615: 
616: 	if (arrow_fetch) {
617: 		RProtector r;
618: 		auto query_result = new RQueryResult();
619: 		query_result->result = move(generic_result);
620: 		SEXP query_resultexp = r.Protect(R_MakeExternalPtr(query_result, R_NilValue, R_NilValue));
621: 		R_RegisterCFinalizer(query_resultexp, (void (*)(SEXP))DuckDBFinalizeQueryR);
622: 		return query_resultexp;
623: 	} else {
624: 		D_ASSERT(generic_result->type == QueryResultType::MATERIALIZED_RESULT);
625: 		MaterializedQueryResult *result = (MaterializedQueryResult *)generic_result.get();
626: 		return duckdb_execute_R_impl(result);
627: 	}
628: }
[end of tools/rpkg/src/statement.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: