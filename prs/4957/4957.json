{
  "repo": "duckdb/duckdb",
  "pull_number": 4957,
  "instance_id": "duckdb__duckdb-4957",
  "issue_numbers": [
    "3579"
  ],
  "base_commit": "0543dbc6fe1c192ad247054fc007d5e2a98df931",
  "patch": "diff --git a/.github/workflows/Main.yml b/.github/workflows/Main.yml\nindex f3df7b291758..86c5bd7d5acd 100644\n--- a/.github/workflows/Main.yml\n+++ b/.github/workflows/Main.yml\n@@ -147,6 +147,47 @@ jobs:\n       shell: bash\n       run: build/reldebug/test/unittest \"*\" --force-reload --force-storage\n \n+ no-string-inline:\n+    name: No String Inline\n+    runs-on: ubuntu-20.04\n+    needs: linux-debug\n+    env:\n+      CC: gcc-10\n+      CXX: g++-10\n+      GEN: ninja\n+      BUILD_ICU: 1\n+      BUILD_INET: 1\n+      BUILD_PARQUET: 1\n+      BUILD_TPCH: 1\n+      BUILD_TPCDS: 1\n+      BUILD_FTS: 1\n+      BUILD_VISUALIZER: 1\n+      BUILD_JSON: 1\n+      BUILD_EXCEL: 1\n+      DISABLE_STRING_INLINE: 1\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+      with:\n+        fetch-depth: 0\n+\n+    - name: Install\n+      shell: bash\n+      run: sudo apt-get update -y -qq && sudo apt-get install -y -qq ninja-build\n+\n+    - name: Setup Ccache\n+      uses: hendrikmuhs/ccache-action@main\n+      with:\n+        key: ${{ github.job }}\n+\n+    - name: Build\n+      shell: bash\n+      run: make debug\n+\n+    - name: Test\n+      shell: bash\n+      run: build/debug/test/unittest\n+\n  linux-arrow:\n       name: Linux Debug (Arrow Tests)\n       runs-on: ubuntu-20.04\ndiff --git a/CMakeLists.txt b/CMakeLists.txt\nindex dd60167f0313..2355f5ccf55c 100644\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -268,6 +268,7 @@ option(USER_SPACE \"Build the DuckDB Python in the user space\" FALSE)\n option(FORCE_QUERY_LOG \"If enabled, all queries will be logged to the specified path\" OFF)\n option(BUILD_SHELL \"Build the DuckDB Shell and SQLite API Wrappers\" TRUE)\n option(DISABLE_THREADS \"Disable support for multi-threading\" FALSE)\n+option(DISABLE_STR_INLINE \"Debug setting: disable inlining of strings\" FALSE)\n option(CLANG_TIDY \"Enable build for clang-tidy, this disables all source files excluding the core database. This does not produce a working build.\" FALSE)\n option(BUILD_UNITTESTS \"Build the C++ Unit Tests.\" TRUE)\n option(\n@@ -325,6 +326,10 @@ else()\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DDUCKDB_CRASH_ON_ASSERT\")\n endif()\n \n+if(DISABLE_STR_INLINE)\n+  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DDUCKDB_DEBUG_NO_INLINE\")\n+endif()\n+\n if(FORCE_ASSERT)\n   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DDUCKDB_FORCE_ASSERT\")\n endif()\ndiff --git a/Makefile b/Makefile\nindex 45b3698f974e..c0845dc17a96 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -141,6 +141,9 @@ endif\n ifeq (${CRASH_ON_ASSERT}, 1)\n \tEXTENSIONS:=${EXTENSIONS} -DASSERT_EXCEPTION=0\n endif\n+ifeq (${DISABLE_STRING_INLINE}, 1)\n+\tEXTENSIONS:=${EXTENSIONS} -DDISABLE_STR_INLINE=1\n+endif\n \n clean:\n \trm -rf build\ndiff --git a/src/common/row_operations/row_external.cpp b/src/common/row_operations/row_external.cpp\nindex fb6aa99ffd8d..b118572c5b08 100644\n--- a/src/common/row_operations/row_external.cpp\n+++ b/src/common/row_operations/row_external.cpp\n@@ -33,7 +33,7 @@ void RowOperations::SwizzleColumns(const RowLayout &layout, const data_ptr_t bas\n \t\t\t}\n \t\t\tdata_ptr_t col_ptr = row_ptr + layout.GetOffsets()[col_idx];\n \t\t\tif (physical_type == PhysicalType::VARCHAR) {\n-\t\t\t\tdata_ptr_t string_ptr = col_ptr + sizeof(uint32_t) + string_t::PREFIX_LENGTH;\n+\t\t\t\tdata_ptr_t string_ptr = col_ptr + string_t::HEADER_SIZE;\n \t\t\t\tfor (idx_t i = 0; i < next; i++) {\n \t\t\t\t\tif (Load<uint32_t>(col_ptr) > string_t::INLINE_LENGTH) {\n \t\t\t\t\t\t// Overwrite the string pointer with the within-row offset (if not inlined)\n@@ -137,7 +137,7 @@ void RowOperations::UnswizzlePointers(const RowLayout &layout, const data_ptr_t\n \t\t\t}\n \t\t\tdata_ptr_t col_ptr = row_ptr + layout.GetOffsets()[col_idx];\n \t\t\tif (physical_type == PhysicalType::VARCHAR) {\n-\t\t\t\tdata_ptr_t string_ptr = col_ptr + sizeof(uint32_t) + string_t::PREFIX_LENGTH;\n+\t\t\t\tdata_ptr_t string_ptr = col_ptr + string_t::HEADER_SIZE;\n \t\t\t\tfor (idx_t i = 0; i < next; i++) {\n \t\t\t\t\tif (Load<uint32_t>(col_ptr) > string_t::INLINE_LENGTH) {\n \t\t\t\t\t\t// Overwrite the string offset with the pointer (if not inlined)\ndiff --git a/src/common/row_operations/row_gather.cpp b/src/common/row_operations/row_gather.cpp\nindex c7f155343110..010eda3ce8af 100644\n--- a/src/common/row_operations/row_gather.cpp\n+++ b/src/common/row_operations/row_gather.cpp\n@@ -76,7 +76,7 @@ static void GatherVarchar(Vector &rows, const SelectionVector &row_sel, Vector &\n \t\t\t//\tNot inline, so unswizzle the copied pointer the pointer\n \t\t\tauto heap_ptr_ptr = row + heap_offset;\n \t\t\tauto heap_row_ptr = base_heap_ptr + Load<idx_t>(heap_ptr_ptr);\n-\t\t\tauto string_ptr = data_ptr_t(data + col_idx) + sizeof(uint32_t) + string_t::PREFIX_LENGTH;\n+\t\t\tauto string_ptr = data_ptr_t(data + col_idx) + string_t::HEADER_SIZE;\n \t\t\tStore<data_ptr_t>(heap_row_ptr + Load<idx_t>(string_ptr), string_ptr);\n #ifdef DEBUG\n \t\t\tdata[col_idx].Verify();\ndiff --git a/src/common/sort/comparators.cpp b/src/common/sort/comparators.cpp\nindex 90e0fbfcc8e4..3ea4b91ed6fd 100644\n--- a/src/common/sort/comparators.cpp\n+++ b/src/common/sort/comparators.cpp\n@@ -349,14 +349,14 @@ int Comparators::TemplatedCompareListLoop(data_ptr_t &left_ptr, data_ptr_t &righ\n \n void Comparators::UnswizzleSingleValue(data_ptr_t data_ptr, const data_ptr_t &heap_ptr, const LogicalType &type) {\n \tif (type.InternalType() == PhysicalType::VARCHAR) {\n-\t\tdata_ptr += sizeof(uint32_t) + string_t::PREFIX_LENGTH;\n+\t\tdata_ptr += string_t::HEADER_SIZE;\n \t}\n \tStore<data_ptr_t>(heap_ptr + Load<idx_t>(data_ptr), data_ptr);\n }\n \n void Comparators::SwizzleSingleValue(data_ptr_t data_ptr, const data_ptr_t &heap_ptr, const LogicalType &type) {\n \tif (type.InternalType() == PhysicalType::VARCHAR) {\n-\t\tdata_ptr += sizeof(uint32_t) + string_t::PREFIX_LENGTH;\n+\t\tdata_ptr += string_t::HEADER_SIZE;\n \t}\n \tStore<idx_t>(Load<data_ptr_t>(data_ptr) - heap_ptr, data_ptr);\n }\ndiff --git a/src/function/aggregate/distributive/first.cpp b/src/function/aggregate/distributive/first.cpp\nindex d0a9ebc03449..c19ee090d8ff 100644\n--- a/src/function/aggregate/distributive/first.cpp\n+++ b/src/function/aggregate/distributive/first.cpp\n@@ -69,6 +69,9 @@ template <bool LAST, bool SKIP_NULLS>\n struct FirstFunctionString : public FirstFunctionBase {\n \ttemplate <class STATE>\n \tstatic void SetValue(STATE *state, string_t value, bool is_null) {\n+\t\tif (LAST && state->is_set) {\n+\t\t\tDestroy(state);\n+\t\t}\n \t\tif (is_null) {\n \t\t\tif (!SKIP_NULLS) {\n \t\t\t\tstate->is_set = true;\ndiff --git a/src/include/duckdb/common/operator/comparison_operators.hpp b/src/include/duckdb/common/operator/comparison_operators.hpp\nindex a814e591c9dc..64ea3595eb88 100644\n--- a/src/include/duckdb/common/operator/comparison_operators.hpp\n+++ b/src/include/duckdb/common/operator/comparison_operators.hpp\n@@ -165,7 +165,7 @@ struct StringComparisonOperators {\n \t\t\t}\n \t\t} else {\n \t\t\t// large string: first check prefix and length\n-\t\t\tif (memcmp(&a, &b, sizeof(uint32_t) + string_t::PREFIX_LENGTH) == 0) {\n+\t\t\tif (memcmp(&a, &b, string_t::HEADER_SIZE) == 0) {\n \t\t\t\t// prefix and length are equal: check main string\n \t\t\t\tif (memcmp(a.value.pointer.ptr, b.value.pointer.ptr, a.GetSize()) == 0) {\n \t\t\t\t\t// entire string is equal\ndiff --git a/src/include/duckdb/common/types/string_type.hpp b/src/include/duckdb/common/types/string_type.hpp\nindex 5a12e233797c..e8890a8f7bb6 100644\n--- a/src/include/duckdb/common/types/string_type.hpp\n+++ b/src/include/duckdb/common/types/string_type.hpp\n@@ -20,8 +20,16 @@ struct string_t {\n \tfriend class StringSegment;\n \n public:\n-\tstatic constexpr idx_t PREFIX_LENGTH = 4 * sizeof(char);\n-\tstatic constexpr idx_t INLINE_LENGTH = 12;\n+\tstatic constexpr idx_t PREFIX_BYTES = 4 * sizeof(char);\n+\tstatic constexpr idx_t INLINE_BYTES = 12 * sizeof(char);\n+\tstatic constexpr idx_t HEADER_SIZE = sizeof(uint32_t) + PREFIX_BYTES;\n+#ifndef DUCKDB_DEBUG_NO_INLINE\n+\tstatic constexpr idx_t PREFIX_LENGTH = PREFIX_BYTES;\n+\tstatic constexpr idx_t INLINE_LENGTH = INLINE_BYTES;\n+#else\n+\tstatic constexpr idx_t PREFIX_LENGTH = 0;\n+\tstatic constexpr idx_t INLINE_LENGTH = 0;\n+#endif\n \n \tstring_t() = default;\n \texplicit string_t(uint32_t len) {\n@@ -33,7 +41,7 @@ struct string_t {\n \t\tif (IsInlined()) {\n \t\t\t// zero initialize the prefix first\n \t\t\t// this makes sure that strings with length smaller than 4 still have an equal prefix\n-\t\t\tmemset(value.inlined.inlined, 0, INLINE_LENGTH);\n+\t\t\tmemset(value.inlined.inlined, 0, INLINE_BYTES);\n \t\t\tif (GetSize() == 0) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -41,7 +49,11 @@ struct string_t {\n \t\t\tmemcpy(value.inlined.inlined, data, GetSize());\n \t\t} else {\n \t\t\t// large string: store pointer\n+#ifndef DUCKDB_DEBUG_NO_INLINE\n \t\t\tmemcpy(value.pointer.prefix, data, PREFIX_LENGTH);\n+#else\n+\t\t\tmemset(value.pointer.prefix, 0, PREFIX_BYTES);\n+#endif\n \t\t\tvalue.pointer.ptr = (char *)data;\n \t\t}\n \t}\n@@ -82,15 +94,19 @@ struct string_t {\n \n \tvoid Finalize() {\n \t\t// set trailing NULL byte\n-\t\tauto dataptr = (char *)GetDataUnsafe();\n \t\tif (GetSize() <= INLINE_LENGTH) {\n \t\t\t// fill prefix with zeros if the length is smaller than the prefix length\n-\t\t\tfor (idx_t i = GetSize(); i < INLINE_LENGTH; i++) {\n+\t\t\tfor (idx_t i = GetSize(); i < INLINE_BYTES; i++) {\n \t\t\t\tvalue.inlined.inlined[i] = '\\0';\n \t\t\t}\n \t\t} else {\n \t\t\t// copy the data into the prefix\n+#ifndef DUCKDB_DEBUG_NO_INLINE\n+\t\t\tauto dataptr = (char *)GetDataUnsafe();\n \t\t\tmemcpy(value.pointer.prefix, dataptr, PREFIX_LENGTH);\n+#else\n+\t\t\tmemset(value.pointer.prefix, 0, PREFIX_BYTES);\n+#endif\n \t\t}\n \t}\n \n",
  "test_patch": "diff --git a/test/extension/load_extension.test b/test/extension/load_extension.test\nindex 5c4a47069bd4..957787d8960c 100644\n--- a/test/extension/load_extension.test\n+++ b/test/extension/load_extension.test\n@@ -24,7 +24,7 @@ LOAD '__BUILD_DIRECTORY__/test/extension/loadable_extension_demo.duckdb_extensio\n query I\n SELECT hello('World');\n ----\n-Hello, World\n+10\n \n query I\n QUACK QUACK QUACK\ndiff --git a/test/extension/loadable_extension_demo.cpp b/test/extension/loadable_extension_demo.cpp\nindex 5021c7b169cb..e9db31333768 100644\n--- a/test/extension/loadable_extension_demo.cpp\n+++ b/test/extension/loadable_extension_demo.cpp\n@@ -11,8 +11,8 @@ using namespace duckdb;\n //===--------------------------------------------------------------------===//\n // Scalar function\n //===--------------------------------------------------------------------===//\n-inline string_t hello_fun(string_t what) {\n-\treturn \"Hello, \" + what.GetString();\n+inline int32_t hello_fun(string_t what) {\n+\treturn what.GetSize() + 5;\n }\n \n inline void TestAliasHello(DataChunk &args, ExpressionState &state, Vector &result) {\n@@ -225,8 +225,8 @@ DUCKDB_EXTENSION_API void loadable_extension_demo_init(duckdb::DatabaseInstance\n \tauto &client_context = *con.context;\n \tauto &catalog = Catalog::GetCatalog(client_context);\n \tcon.BeginTransaction();\n-\tcon.CreateScalarFunction<string_t, string_t>(\"hello\", {LogicalType(LogicalTypeId::VARCHAR)},\n-\t                                             LogicalType(LogicalTypeId::VARCHAR), &hello_fun);\n+\tcon.CreateScalarFunction<int32_t, string_t>(\"hello\", {LogicalType(LogicalTypeId::VARCHAR)},\n+\t                                            LogicalType(LogicalTypeId::INTEGER), &hello_fun);\n \n \tcatalog.CreateFunction(client_context, &hello_alias_info);\n \ndiff --git a/test/sql/aggregate/aggregates/test_arg_min_max_strings.test b/test/sql/aggregate/aggregates/test_arg_min_max_strings.test\nindex d680188a5326..a8e14a343012 100644\n--- a/test/sql/aggregate/aggregates/test_arg_min_max_strings.test\n+++ b/test/sql/aggregate/aggregates/test_arg_min_max_strings.test\n@@ -2,6 +2,8 @@\n # description: Test arg_min/arg_max with strings\n # group: [aggregates]\n \n+require strinline\n+\n statement ok\n CREATE TABLE tbl(\n \t\"DATE\" DATE,\ndiff --git a/test/sql/function/list/aggregates/mode.test b/test/sql/function/list/aggregates/mode.test\nindex 1e4b39ddb405..9c175dbb8542 100644\n--- a/test/sql/function/list/aggregates/mode.test\n+++ b/test/sql/function/list/aggregates/mode.test\n@@ -2,6 +2,8 @@\n # description: Test the list_mode aggregate function\n # group: [aggregates]\n \n+require strinline\n+\n # incorrect usage\n statement error\n select list_mode()\ndiff --git a/test/sql/function/list/aggregates/types.test b/test/sql/function/list/aggregates/types.test\nindex 45b19a45a805..5e379d76202a 100644\n--- a/test/sql/function/list/aggregates/types.test\n+++ b/test/sql/function/list/aggregates/types.test\n@@ -5,6 +5,8 @@\n # This file specifically tests the functionality for each type, \n # it does not necessarily test the correctness (statement ok suffices for some tests)\n \n+require strinline\n+\n # BOOLEAN\n \n # result False\ndiff --git a/test/sql/function/string/test_ascii.test b/test/sql/function/string/test_ascii.test\nindex 1854d074d30a..fc914be3f2c4 100644\n--- a/test/sql/function/string/test_ascii.test\n+++ b/test/sql/function/string/test_ascii.test\n@@ -2,8 +2,10 @@\n # description: test ascii() and chr() functions\n # group: [string]\n \n-#statement ok\n-#PRAGMA enable_verification\n+require strinline\n+\n+statement ok\n+PRAGMA enable_verification\n \n # Some ascii checks\n query I\ndiff --git a/test/sqlite/sqllogic_test_runner.cpp b/test/sqlite/sqllogic_test_runner.cpp\nindex 447e3675d67f..e1617c909d9b 100644\n--- a/test/sqlite/sqllogic_test_runner.cpp\n+++ b/test/sqlite/sqllogic_test_runner.cpp\n@@ -473,6 +473,10 @@ void SQLLogicTestRunner::ExecuteFile(string script) {\n \t\t\t\tif (TestForceStorage()) {\n \t\t\t\t\treturn;\n \t\t\t\t}\n+\t\t\t} else if (param == \"strinline\") {\n+#ifdef DUCKDB_DEBUG_NO_INLINE\n+\t\t\t\treturn;\n+#endif\n \t\t\t} else if (param == \"vector_size\") {\n \t\t\t\tif (token.parameters.size() != 2) {\n \t\t\t\t\tparser.Fail(\"require vector_size requires a parameter\");\n",
  "problem_statement": "String Udfs crashing in loadable_extension_demo\n#### What happens?\r\nA use-after-free crash occurs when running the loadable_extension_demo udf function on strings above the string_t inline limit. This seems to be caused by the fact that the string created in the udf will go be freed as the udf returns freeing the memory that the string_t returned points to.\r\n\r\n#### To Reproduce\r\n```\r\nmake debug\r\n./build/debug/duckdb\r\n```\r\nIn duckdb\r\n```\r\nLOAD 'build/debug/test/extension/loadable_extension_demo.duckdb_extension';\r\nselect hello('World from italy');\r\n```\n",
  "hints_text": "",
  "created_at": "2022-10-12T08:03:00Z"
}