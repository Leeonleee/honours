{
  "repo": "duckdb/duckdb",
  "pull_number": 1664,
  "instance_id": "duckdb__duckdb-1664",
  "issue_numbers": [
    "1662"
  ],
  "base_commit": "0f7631f844d0025b4f0047db675dc5af37f2caa4",
  "patch": "diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex 83b16718d087..dd4d4db9a139 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -119,7 +119,7 @@ if(BUILD_PYTHON OR BUILD_R)\n     else()\n       add_custom_target(\n         duckdb_python ALL\n-        COMMAND python3 setup.py install --user --binary-dir=${CMAKE_BINARY_DIR}\n+        COMMAND python3 setup.py install --binary-dir=${CMAKE_BINARY_DIR}\n                 --compile-flags=${ALL_COMPILE_FLAGS} --libs=\"${duckdb_libs}\"\n         DEPENDS duckdb\n         WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/tools/pythonpkg\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 22a7515cf04f..3d5a9cc381f0 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -333,6 +333,9 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromArrowTable(const py::object\n \n DuckDBPyConnection *DuckDBPyConnection::UnregisterDF(const string &name) {\n \tregistered_dfs[name] = py::none();\n+\tif (connection) {\n+\t\tconnection->Query(\"DROP VIEW \\\"\" + name + \"\\\"\");\n+\t}\n \treturn this;\n }\n \n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/pandas/test_pandas_unregister.py b/tools/pythonpkg/tests/pandas/test_pandas_unregister.py\nnew file mode 100644\nindex 000000000000..e576f212934b\n--- /dev/null\n+++ b/tools/pythonpkg/tests/pandas/test_pandas_unregister.py\n@@ -0,0 +1,52 @@\n+import duckdb\n+import pandas as pd\n+import pytest\n+import tempfile\n+import os\n+import gc\n+\n+class TestPandasUnregister(object):\n+    def test_pandas_unregister1(self, duckdb_cursor):\n+        df = pd.DataFrame([[1, 2, 3], [4, 5, 6]])\n+        connection = duckdb.connect(\":memory:\")\n+        connection.register(\"dataframe\", df)\n+\n+        df2 = connection.execute(\"SELECT * FROM dataframe;\").fetchdf()\n+        connection.unregister(\"dataframe\")\n+        with pytest.raises(RuntimeError):\n+            connection.execute(\"SELECT * FROM dataframe;\").fetchdf()\n+        with pytest.raises(RuntimeError):\n+            connection.execute(\"DROP VIEW dataframe;\")\n+        connection.execute(\"DROP VIEW IF EXISTS dataframe;\")\n+\n+\n+    def test_pandas_unregister2(self, duckdb_cursor):\n+        fd, db = tempfile.mkstemp()\n+        os.close(fd)\n+        os.remove(db)\n+\n+        connection = duckdb.connect(db)\n+        df = pd.DataFrame([[1, 2, 3], [4, 5, 6]])\n+\n+        connection.register(\"dataframe\", df)\n+        connection.unregister(\"dataframe\")  # Attempting to unregister.\n+        connection.close()\n+\n+        # Reconnecting while DataFrame still in mem.\n+        connection = duckdb.connect(db)\n+        assert len(connection.execute(\"PRAGMA show_tables;\").fetchall()) == 0\n+\n+        with pytest.raises(RuntimeError):\n+            connection.execute(\"SELECT * FROM dataframe;\").fetchdf()\n+\n+        connection.close()\n+\n+        del df\n+        gc.collect()\n+\n+        # Reconnecting after DataFrame freed.\n+        connection = duckdb.connect(db)\n+        assert len(connection.execute(\"PRAGMA show_tables;\").fetchall()) == 0\n+        with pytest.raises(RuntimeError):\n+            connection.execute(\"SELECT * FROM dataframe;\").fetchdf()\n+        connection.close()\n",
  "problem_statement": "Python relational API: `unregister` does not delete reference to relation/DataFrame\n**What does happen?**\r\nQueries can still be run against relation objects after `unregister`-ing the table names.\r\n\r\n**What should happen?**\r\nThe `unregister` method should delete references to a relation object / Pandas DataFrame.\r\n\r\n**To Reproduce**\r\n\r\n```python\r\nimport duckdb\r\nimport pandas as pd\r\ndf = pd.DataFrame([[1, 2, 3], [4, 5, 6]])\r\nconnection = duckdb.connect(\":memory:\")\r\nconnection.register(\"dataframe\", df)\r\n\r\nprint(connection.execute(\"SELECT * FROM dataframe;\").fetchdf())\r\n#    0  1  2\r\n# 0  1  2  3\r\n# 1  4  5  6\r\nconnection.unregister(\"dataframe\") # Should delete reference to dataframe.\r\nprint(connection.execute(\"SELECT * FROM dataframe;\").fetchdf())\r\n#    0  1  2\r\n# 0  1  2  3\r\n# 1  4  5  6\r\n\r\nconnection.execute(\"DROP VIEW dataframe;\")  # Drop view with SQL.\r\n# This _does_ stop us from printing the df.\r\nprint(connection.execute(\"SELECT * FROM dataframe;\").fetchdf())\r\n# Traceback (most recent call last):\r\n#   File \"<stdin>\", line 1, in <module>\r\n# RuntimeError: Catalog Error: Table with name dataframe does not exist!\r\n# Did you mean \"dataframe\"?\r\n# LINE 1: SELECT * FROM dataframe;\r\n#                       ^\r\n\r\n\r\n```\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Ubuntu 20.04\r\n - DuckDB Version: 0.2.5\r\n\r\n**Before submitting**\r\n- [X] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\n",
  "hints_text": "Indeed we don't drop the view in `unregister` yet. \nIt looks like the handle is saved in the database, so this can lead to a segfault if the dataframe is out of memory:\r\n\r\n```python\r\nimport gc\r\nimport duckdb\r\nimport pandas as pd\r\n\r\nconnection = duckdb.connect(\"some_database.db\")\r\ndf = pd.DataFrame([[1, 2, 3], [4, 5, 6]])\r\n\r\nconnection.register(\"dataframe\", df)\r\nconnection.unregister(\"dataframe\")  # Attempting to unregister.\r\n# Still saved in catalog.\r\nconnection.close()\r\n\r\n# Reconnecting while DataFrame still in mem.\r\nconnection = duckdb.connect(\"some_database.db\")\r\nprint(connection.execute(\"PRAGMA show_tables;\").fetchdf())\r\n#         name\r\n# 0  dataframe\r\nprint(connection.execute(\"SELECT * FROM dataframe;\").fetchdf())  # No issues printing.\r\n#    0  1  2\r\n# 0  1  2  3\r\n# 1  4  5  6\r\nconnection.close()\r\n\r\n# Force garbage collection of DataFrame.\r\ndel df\r\ngc.collect()\r\n\r\n# Reconnecting after DataFrame freed.\r\nconnection = duckdb.connect(\"some_database.db\")\r\nprint(connection.execute(\"PRAGMA show_tables;\").fetchdf())\r\n#         name\r\n# 0  dataframe\r\nprint(connection.execute(\"SELECT * FROM dataframe;\").fetchdf())\r\n# [1]    9807 segmentation fault (core dumped)\r\nconnection.close()\r\n```\nYes, that's exactly what will happen there. This is a bug and should be fixed.\nDoes the Python API keep track of everything that has been `register`ed? It could be a good idea to drop these implicitly when a connection is closed, but that might break some workflows if people are closing and reopening connections to a database file within the same process.\nIt does, and those are dropped when the connection is closed since its destroyed and the refs from pybind are destroyed too. ",
  "created_at": "2021-04-23T10:56:40Z"
}