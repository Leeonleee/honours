You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Python relational API: `unregister` does not delete reference to relation/DataFrame
**What does happen?**
Queries can still be run against relation objects after `unregister`-ing the table names.

**What should happen?**
The `unregister` method should delete references to a relation object / Pandas DataFrame.

**To Reproduce**

```python
import duckdb
import pandas as pd
df = pd.DataFrame([[1, 2, 3], [4, 5, 6]])
connection = duckdb.connect(":memory:")
connection.register("dataframe", df)

print(connection.execute("SELECT * FROM dataframe;").fetchdf())
#    0  1  2
# 0  1  2  3
# 1  4  5  6
connection.unregister("dataframe") # Should delete reference to dataframe.
print(connection.execute("SELECT * FROM dataframe;").fetchdf())
#    0  1  2
# 0  1  2  3
# 1  4  5  6

connection.execute("DROP VIEW dataframe;")  # Drop view with SQL.
# This _does_ stop us from printing the df.
print(connection.execute("SELECT * FROM dataframe;").fetchdf())
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# RuntimeError: Catalog Error: Table with name dataframe does not exist!
# Did you mean "dataframe"?
# LINE 1: SELECT * FROM dataframe;
#                       ^


```

**Environment (please complete the following information):**
 - OS: Ubuntu 20.04
 - DuckDB Version: 0.2.5

**Before submitting**
- [X] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?
- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds


</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of src/CMakeLists.txt]
1: add_definitions(-DDUCKDB)
2: 
3: if(NOT MSVC)
4:   set(CMAKE_CXX_FLAGS_DEBUG
5:       "${CMAKE_CXX_FLAGS_DEBUG} -Wextra -Wno-unused-parameter -Wno-redundant-move"
6:   )
7: endif()
8: 
9: # clang-tidy config from presto-cpp set(CMAKE_CXX_CLANG_TIDY clang-tidy
10: # --checks=*,-abseil-*,-android-*,-cert-err58-cpp,-clang-analyzer-
11: # osx-*,-cppcoreguidelines-avoid-c-arrays,-cppcoreguidelines-avoid-magic-
12: # numbers,-cppcoreguidelines-pro-bounds-array-to-pointer-
13: # decay,-cppcoreguidelines-pro-bounds-pointer-arithmetic,-cppcoreguidelines-pro-
14: # type-reinterpret-cast,-cppcoreguidelines-pro-type-
15: # vararg,-fuchsia-*,-google-*,-hicpp-avoid-c-arrays,-hicpp-deprecated-
16: # headers,-hicpp-no-array-decay,-hicpp-use-equals-default,-hicpp-
17: # vararg,-llvmlibc-*,-llvm-header-guard,-llvm-include-order,-mpi-*,-misc-non-
18: # private-member-variables-in-classes,-misc-no-recursion,-misc-unused-
19: # parameters,-modernize-avoid-c-arrays,-modernize-deprecated-headers,-modernize-
20: # use-nodiscard,-modernize-use-trailing-return-
21: # type,-objc-*,-openmp-*,-readability-avoid-const-params-in-decls,-readability-
22: # convert-member-functions-to-static,-readability-magic-numbers,-zircon-*)
23: 
24: if(AMALGAMATION_BUILD)
25: 
26:   if(WIN32)
27:     add_definitions(/bigobj)
28:   endif()
29: 
30:   add_library(duckdb SHARED "${PROJECT_SOURCE_DIR}/src/amalgamation/duckdb.cpp")
31:   add_library(duckdb_static STATIC
32:               "${PROJECT_SOURCE_DIR}/src/amalgamation/duckdb.cpp")
33: 
34:   link_threads(duckdb)
35:   link_threads(duckdb_static)
36: 
37:   install(FILES "${PROJECT_SOURCE_DIR}/src/amalgamation/duckdb.hpp"
38:                 "${PROJECT_SOURCE_DIR}/src/include/duckdb.h"
39:           DESTINATION "${INSTALL_INCLUDE_DIR}")
40:   install(FILES "${PROJECT_SOURCE_DIR}/src/include/duckdb/common/winapi.hpp"
41:           DESTINATION "${INSTALL_INCLUDE_DIR}/duckdb/common")
42: 
43: else()
44: 
45:   add_definitions(-DDUCKDB_MAIN_LIBRARY)
46: 
47:   add_subdirectory(optimizer)
48:   add_subdirectory(planner)
49:   add_subdirectory(parser)
50:   add_subdirectory(function)
51:   add_subdirectory(catalog)
52:   add_subdirectory(common)
53:   add_subdirectory(execution)
54:   add_subdirectory(main)
55:   add_subdirectory(parallel)
56:   add_subdirectory(storage)
57:   add_subdirectory(transaction)
58: 
59:   set(DUCKDB_LINK_LIBS
60:       ${CMAKE_DL_LIBS}
61:       fmt
62:       pg_query
63:       duckdb_re2
64:       miniz
65:       utf8proc
66:       hyperloglog)
67: 
68:   add_library(duckdb SHARED ${ALL_OBJECT_FILES})
69:   target_link_libraries(duckdb ${DUCKDB_LINK_LIBS})
70:   link_threads(duckdb)
71: 
72:   add_library(duckdb_static STATIC ${ALL_OBJECT_FILES})
73:   target_link_libraries(duckdb_static ${DUCKDB_LINK_LIBS})
74:   link_threads(duckdb_static)
75: 
76:   target_include_directories(
77:     duckdb PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
78:                   $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>)
79: 
80:   target_include_directories(
81:     duckdb_static PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
82:                          $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>)
83: 
84:   install(
85:     DIRECTORY "${PROJECT_SOURCE_DIR}/src/include/duckdb"
86:     DESTINATION "${INSTALL_INCLUDE_DIR}"
87:     FILES_MATCHING
88:     PATTERN "*.hpp")
89:   install(FILES "${PROJECT_SOURCE_DIR}/src/include/duckdb.hpp"
90:                 "${PROJECT_SOURCE_DIR}/src/include/duckdb.h"
91:           DESTINATION "${INSTALL_INCLUDE_DIR}")
92: 
93: endif()
94: 
95: if(BUILD_PYTHON OR BUILD_R)
96:   if(CMAKE_BUILD_TYPE STREQUAL "Debug")
97:     set(ALL_COMPILE_FLAGS "${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_DEBUG}")
98:   elseif(CMAKE_BUILD_TYPE STREQUAL "Release")
99:     set(ALL_COMPILE_FLAGS "${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_RELEASE}")
100:   elseif(CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")
101:     set(ALL_COMPILE_FLAGS
102:         "${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")
103:   else()
104:     set(ALL_COMPILE_FLAGS "${CMAKE_CXX_FLAGS}")
105:   endif()
106: 
107:   get_target_property(duckdb_libs duckdb LINK_LIBRARIES)
108: 
109:   if(BUILD_PYTHON)
110:     if(USER_SPACE)
111:       add_custom_target(
112:         duckdb_python ALL
113:         COMMAND python3 setup.py install --user --binary-dir=${CMAKE_BINARY_DIR}
114:                 --compile-flags=${ALL_COMPILE_FLAGS} --libs="${duckdb_libs}"
115:         DEPENDS duckdb
116:         WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/tools/pythonpkg
117:         COMMENT Build
118:         Python package)
119:     else()
120:       add_custom_target(
121:         duckdb_python ALL
122:         COMMAND python3 setup.py install --user --binary-dir=${CMAKE_BINARY_DIR}
123:                 --compile-flags=${ALL_COMPILE_FLAGS} --libs="${duckdb_libs}"
124:         DEPENDS duckdb
125:         WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/tools/pythonpkg
126:         COMMENT Build
127:         Python package)
128:     endif()
129:     add_extension_dependencies(duckdb_python)
130:   endif()
131:   if(BUILD_R)
132:     add_custom_target(
133:       duckdb_r ALL
134:       COMMAND
135:         DUCKDB_R_BINDIR=${CMAKE_BINARY_DIR}
136:         DUCKDB_R_CFLAGS=\"${ALL_COMPILE_FLAGS}\"
137:         DUCKDB_R_LIBS=\"${duckdb_libs}\" R CMD INSTALL .
138:       DEPENDS duckdb
139:       WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/tools/rpkg
140:       COMMENT Build
141:       R package)
142:     add_extension_dependencies(duckdb_r)
143:   endif()
144: endif()
145: 
146: install(
147:   TARGETS duckdb duckdb_static
148:   EXPORT "${DUCKDB_EXPORT_SET}"
149:   LIBRARY DESTINATION "${INSTALL_LIB_DIR}"
150:   ARCHIVE DESTINATION "${INSTALL_LIB_DIR}")
[end of src/CMakeLists.txt]
[start of tools/pythonpkg/src/pyconnection.cpp]
1: #include "duckdb_python/pyconnection.hpp"
2: #include "duckdb_python/pyresult.hpp"
3: #include "duckdb_python/pyrelation.hpp"
4: #include "duckdb_python/pandas_scan.hpp"
5: #include "duckdb_python/map.hpp"
6: 
7: #include "duckdb/common/arrow.hpp"
8: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
9: #include "duckdb/main/client_context.hpp"
10: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
11: #include "duckdb/common/types/vector.hpp"
12: #include "duckdb/common/printer.hpp"
13: #include "duckdb/main/config.hpp"
14: #include "duckdb/parser/expression/constant_expression.hpp"
15: #include "duckdb/parser/expression/function_expression.hpp"
16: #include "duckdb/parser/tableref/table_function_ref.hpp"
17: 
18: #include "extension/extension_helper.hpp"
19: 
20: #include "datetime.h" // from Python
21: 
22: #include <random>
23: 
24: namespace duckdb {
25: 
26: shared_ptr<DuckDBPyConnection> DuckDBPyConnection::default_connection = nullptr;
27: 
28: void DuckDBPyConnection::Initialize(py::handle &m) {
29: 	py::class_<DuckDBPyConnection, shared_ptr<DuckDBPyConnection>>(m, "DuckDBPyConnection")
30: 	    .def("cursor", &DuckDBPyConnection::Cursor, "Create a duplicate of the current connection")
31: 	    .def("duplicate", &DuckDBPyConnection::Cursor, "Create a duplicate of the current connection")
32: 	    .def("execute", &DuckDBPyConnection::Execute,
33: 	         "Execute the given SQL query, optionally using prepared statements with parameters set", py::arg("query"),
34: 	         py::arg("parameters") = py::list(), py::arg("multiple_parameter_sets") = false)
35: 	    .def("executemany", &DuckDBPyConnection::ExecuteMany,
36: 	         "Execute the given prepared statement multiple times using the list of parameter sets in parameters",
37: 	         py::arg("query"), py::arg("parameters") = py::list())
38: 	    .def("close", &DuckDBPyConnection::Close, "Close the connection")
39: 	    .def("fetchone", &DuckDBPyConnection::FetchOne, "Fetch a single row from a result following execute")
40: 	    .def("fetchall", &DuckDBPyConnection::FetchAll, "Fetch all rows from a result following execute")
41: 	    .def("fetchnumpy", &DuckDBPyConnection::FetchNumpy, "Fetch a result as list of NumPy arrays following execute")
42: 	    .def("fetchdf", &DuckDBPyConnection::FetchDF, "Fetch a result as Data.Frame following execute()")
43: 	    .def("fetch_df", &DuckDBPyConnection::FetchDF, "Fetch a result as Data.Frame following execute()")
44: 	    .def("fetch_df_chunk", &DuckDBPyConnection::FetchDFChunk,
45: 	         "Fetch a chunk of the result as Data.Frame following execute()")
46: 	    .def("df", &DuckDBPyConnection::FetchDF, "Fetch a result as Data.Frame following execute()")
47: 	    .def("fetch_arrow_table", &DuckDBPyConnection::FetchArrow, "Fetch a result as Arrow table following execute()")
48: 	    .def("arrow", &DuckDBPyConnection::FetchArrow, "Fetch a result as Arrow table following execute()")
49: 	    .def("begin", &DuckDBPyConnection::Begin, "Start a new transaction")
50: 	    .def("commit", &DuckDBPyConnection::Commit, "Commit changes performed within a transaction")
51: 	    .def("rollback", &DuckDBPyConnection::Rollback, "Roll back changes performed within a transaction")
52: 	    .def("append", &DuckDBPyConnection::Append, "Append the passed Data.Frame to the named table",
53: 	         py::arg("table_name"), py::arg("df"))
54: 	    .def("register", &DuckDBPyConnection::RegisterDF,
55: 	         "Register the passed Data.Frame value for querying with a view", py::arg("view_name"), py::arg("df"))
56: 	    .def("unregister", &DuckDBPyConnection::UnregisterDF, "Unregister the view name", py::arg("view_name"))
57: 	    .def("table", &DuckDBPyConnection::Table, "Create a relation object for the name'd table",
58: 	         py::arg("table_name"))
59: 	    .def("view", &DuckDBPyConnection::View, "Create a relation object for the name'd view", py::arg("view_name"))
60: 	    .def("values", &DuckDBPyConnection::Values, "Create a relation object from the passed values",
61: 	         py::arg("values"))
62: 	    .def("table_function", &DuckDBPyConnection::TableFunction,
63: 	         "Create a relation object from the name'd table function with given parameters", py::arg("name"),
64: 	         py::arg("parameters") = py::list())
65: 	    .def("from_df", &DuckDBPyConnection::FromDF, "Create a relation object from the Data.Frame in df",
66: 	         py::arg("df") = py::none())
67: 	    .def("from_arrow_table", &DuckDBPyConnection::FromArrowTable, "Create a relation object from an Arrow table",
68: 	         py::arg("table"))
69: 	    .def("df", &DuckDBPyConnection::FromDF, "Create a relation object from the Data.Frame in df (alias of from_df)",
70: 	         py::arg("df"))
71: 	    .def("from_csv_auto", &DuckDBPyConnection::FromCsvAuto,
72: 	         "Create a relation object from the CSV file in file_name", py::arg("file_name"))
73: 	    .def("from_parquet", &DuckDBPyConnection::FromParquet,
74: 	         "Create a relation object from the Parquet file in file_name", py::arg("file_name"))
75: 	    .def("__getattr__", &DuckDBPyConnection::GetAttr, "Get result set attributes, mainly column names");
76: 
77: 	PyDateTime_IMPORT;
78: }
79: 
80: DuckDBPyConnection::~DuckDBPyConnection() {
81: 	for (auto &element : registered_dfs) {
82: 		UnregisterDF(element.first);
83: 	}
84: }
85: 
86: DuckDBPyConnection *DuckDBPyConnection::ExecuteMany(const string &query, py::object params) {
87: 	Execute(query, std::move(params), true);
88: 	return this;
89: }
90: 
91: DuckDBPyConnection *DuckDBPyConnection::Execute(const string &query, py::object params, bool many) {
92: 	if (!connection) {
93: 		throw std::runtime_error("connection closed");
94: 	}
95: 	result = nullptr;
96: 
97: 	auto statements = connection->ExtractStatements(query);
98: 	if (statements.empty()) {
99: 		// no statements to execute
100: 		return this;
101: 	}
102: 	// if there are multiple statements, we directly execute the statements besides the last one
103: 	// we only return the result of the last statement to the user, unless one of the previous statements fails
104: 	for (idx_t i = 0; i + 1 < statements.size(); i++) {
105: 		auto res = connection->Query(move(statements[i]));
106: 		if (!res->success) {
107: 			throw std::runtime_error(res->error);
108: 		}
109: 	}
110: 
111: 	auto prep = connection->Prepare(move(statements.back()));
112: 	if (!prep->success) {
113: 		throw std::runtime_error(prep->error);
114: 	}
115: 
116: 	// this is a list of a list of parameters in executemany
117: 	py::list params_set;
118: 	if (!many) {
119: 		params_set = py::list(1);
120: 		params_set[0] = params;
121: 	} else {
122: 		params_set = params;
123: 	}
124: 
125: 	for (pybind11::handle single_query_params : params_set) {
126: 		if (prep->n_param != py::len(single_query_params)) {
127: 			throw std::runtime_error("Prepared statement needs " + to_string(prep->n_param) + " parameters, " +
128: 			                         to_string(py::len(single_query_params)) + " given");
129: 		}
130: 		auto args = DuckDBPyConnection::TransformPythonParamList(single_query_params);
131: 		auto res = make_unique<DuckDBPyResult>();
132: 		{
133: 			py::gil_scoped_release release;
134: 			res->result = prep->Execute(args);
135: 		}
136: 		if (!res->result->success) {
137: 			throw std::runtime_error(res->result->error);
138: 		}
139: 		if (!many) {
140: 			result = move(res);
141: 		}
142: 	}
143: 	return this;
144: }
145: 
146: DuckDBPyConnection *DuckDBPyConnection::Append(const string &name, py::object value) {
147: 	RegisterDF("__append_df", std::move(value));
148: 	return Execute("INSERT INTO \"" + name + "\" SELECT * FROM __append_df");
149: }
150: 
151: DuckDBPyConnection *DuckDBPyConnection::RegisterDF(const string &name, py::object value) {
152: 	if (!connection) {
153: 		throw std::runtime_error("connection closed");
154: 	}
155: 	connection->TableFunction("pandas_scan", {Value::POINTER((uintptr_t)value.ptr())})->CreateView(name, true, true);
156: 	// keep a reference
157: 	registered_dfs[name] = value;
158: 	return this;
159: }
160: 
161: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::Table(const string &tname) {
162: 	if (!connection) {
163: 		throw std::runtime_error("connection closed");
164: 	}
165: 	return make_unique<DuckDBPyRelation>(connection->Table(tname));
166: }
167: 
168: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::Values(py::object params) {
169: 	if (!connection) {
170: 		throw std::runtime_error("connection closed");
171: 	}
172: 	vector<vector<Value>> values {DuckDBPyConnection::TransformPythonParamList(std::move(params))};
173: 	return make_unique<DuckDBPyRelation>(connection->Values(values));
174: }
175: 
176: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::View(const string &vname) {
177: 	if (!connection) {
178: 		throw std::runtime_error("connection closed");
179: 	}
180: 	return make_unique<DuckDBPyRelation>(connection->View(vname));
181: }
182: 
183: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::TableFunction(const string &fname, py::object params) {
184: 	if (!connection) {
185: 		throw std::runtime_error("connection closed");
186: 	}
187: 
188: 	return make_unique<DuckDBPyRelation>(
189: 	    connection->TableFunction(fname, DuckDBPyConnection::TransformPythonParamList(std::move(params))));
190: }
191: 
192: static std::string GenerateRandomName() {
193: 	std::random_device rd;
194: 	std::mt19937 gen(rd());
195: 	std::uniform_int_distribution<> dis(0, 15);
196: 
197: 	std::stringstream ss;
198: 	int i;
199: 	ss << std::hex;
200: 	for (i = 0; i < 16; i++) {
201: 		ss << dis(gen);
202: 	}
203: 	return ss.str();
204: }
205: 
206: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromDF(py::object value) {
207: 	if (!connection) {
208: 		throw std::runtime_error("connection closed");
209: 	}
210: 	string name = "df_" + GenerateRandomName();
211: 	registered_dfs[name] = value;
212: 	vector<Value> params;
213: 	params.emplace_back(Value::POINTER((uintptr_t)value.ptr()));
214: 	return make_unique<DuckDBPyRelation>(connection->TableFunction("pandas_scan", params)->Alias(name));
215: }
216: 
217: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromCsvAuto(const string &filename) {
218: 	if (!connection) {
219: 		throw std::runtime_error("connection closed");
220: 	}
221: 	vector<Value> params;
222: 	params.emplace_back(filename);
223: 	return make_unique<DuckDBPyRelation>(connection->TableFunction("read_csv_auto", params)->Alias(filename));
224: }
225: 
226: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromParquet(const string &filename) {
227: 	if (!connection) {
228: 		throw std::runtime_error("connection closed");
229: 	}
230: 	vector<Value> params;
231: 	params.emplace_back(filename);
232: 	return make_unique<DuckDBPyRelation>(connection->TableFunction("parquet_scan", params)->Alias(filename));
233: }
234: 
235: struct PythonTableArrowArrayStream {
236: 	explicit PythonTableArrowArrayStream(const py::object &arrow_table) : arrow_table(arrow_table) {
237: 		stream.get_schema = PythonTableArrowArrayStream::MyStreamGetSchema;
238: 		stream.get_next = PythonTableArrowArrayStream::MyStreamGetNext;
239: 		stream.release = PythonTableArrowArrayStream::MyStreamRelease;
240: 		stream.get_last_error = PythonTableArrowArrayStream::MyStreamGetLastError;
241: 		stream.private_data = this;
242: 
243: 		batches = arrow_table.attr("to_batches")();
244: 	}
245: 
246: 	static int MyStreamGetSchema(struct ArrowArrayStream *stream, struct ArrowSchema *out) {
247: 		D_ASSERT(stream->private_data);
248: 		py::gil_scoped_acquire acquire;
249: 		auto my_stream = (PythonTableArrowArrayStream *)stream->private_data;
250: 		if (!stream->release) {
251: 			my_stream->last_error = "stream was released";
252: 			return -1;
253: 		}
254: 		auto schema = my_stream->arrow_table.attr("schema");
255: 		if (!py::hasattr(schema, "_export_to_c")) {
256: 			my_stream->last_error = "failed to acquire export_to_c function";
257: 			return -1;
258: 		}
259: 		auto export_to_c = schema.attr("_export_to_c");
260: 		export_to_c((uint64_t)out);
261: 		return 0;
262: 	}
263: 
264: 	static int MyStreamGetNext(struct ArrowArrayStream *stream, struct ArrowArray *out) {
265: 		D_ASSERT(stream->private_data);
266: 		py::gil_scoped_acquire acquire;
267: 		auto my_stream = (PythonTableArrowArrayStream *)stream->private_data;
268: 		if (!stream->release) {
269: 			my_stream->last_error = "stream was released";
270: 			return -1;
271: 		}
272: 		if (my_stream->batch_idx >= py::len(my_stream->batches)) {
273: 			out->release = nullptr;
274: 			return 0;
275: 		}
276: 		auto stream_batch = my_stream->batches[my_stream->batch_idx++];
277: 		if (!py::hasattr(stream_batch, "_export_to_c")) {
278: 			my_stream->last_error = "failed to acquire export_to_c function";
279: 			return -1;
280: 		}
281: 		auto export_to_c = stream_batch.attr("_export_to_c");
282: 		export_to_c((uint64_t)out);
283: 		return 0;
284: 	}
285: 
286: 	static void MyStreamRelease(struct ArrowArrayStream *stream) {
287: 		py::gil_scoped_acquire acquire;
288: 		if (!stream->release) {
289: 			return;
290: 		}
291: 		stream->release = nullptr;
292: 		delete (PythonTableArrowArrayStream *)stream->private_data;
293: 	}
294: 
295: 	static const char *MyStreamGetLastError(struct ArrowArrayStream *stream) {
296: 		py::gil_scoped_acquire acquire;
297: 		if (!stream->release) {
298: 			return "stream was released";
299: 		}
300: 		D_ASSERT(stream->private_data);
301: 		auto my_stream = (PythonTableArrowArrayStream *)stream->private_data;
302: 		return my_stream->last_error.c_str();
303: 	}
304: 
305: 	ArrowArrayStream stream;
306: 	string last_error;
307: 	py::object arrow_table;
308: 	py::list batches;
309: 	idx_t batch_idx = 0;
310: };
311: 
312: static string PtrToString(void const *ptr) {
313: 	std::ostringstream address;
314: 	address << ptr;
315: 	return address.str();
316: }
317: 
318: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromArrowTable(const py::object &table) {
319: 	if (!connection) {
320: 		throw std::runtime_error("connection closed");
321: 	}
322: 
323: 	// the following is a careful dance around having to depend on pyarrow
324: 	if (table.is_none() || string(py::str(table.get_type().attr("__name__"))) != "Table") {
325: 		throw std::runtime_error("Only arrow tables supported");
326: 	}
327: 
328: 	auto my_arrow_table = new PythonTableArrowArrayStream(table);
329: 	string name = "arrow_table_" + PtrToString((void *)my_arrow_table);
330: 	return make_unique<DuckDBPyRelation>(
331: 	    connection->TableFunction("arrow_scan", {Value::POINTER((uintptr_t)my_arrow_table)})->Alias(name));
332: }
333: 
334: DuckDBPyConnection *DuckDBPyConnection::UnregisterDF(const string &name) {
335: 	registered_dfs[name] = py::none();
336: 	return this;
337: }
338: 
339: DuckDBPyConnection *DuckDBPyConnection::Begin() {
340: 	Execute("BEGIN TRANSACTION");
341: 	return this;
342: }
343: 
344: DuckDBPyConnection *DuckDBPyConnection::Commit() {
345: 	if (connection->context->transaction.IsAutoCommit()) {
346: 		return this;
347: 	}
348: 	Execute("COMMIT");
349: 	return this;
350: }
351: 
352: DuckDBPyConnection *DuckDBPyConnection::Rollback() {
353: 	Execute("ROLLBACK");
354: 	return this;
355: }
356: 
357: py::object DuckDBPyConnection::GetAttr(const py::str &key) {
358: 	if (key.cast<string>() == "description") {
359: 		if (!result) {
360: 			throw std::runtime_error("no open result set");
361: 		}
362: 		return result->Description();
363: 	}
364: 	return py::none();
365: }
366: 
367: void DuckDBPyConnection::Close() {
368: 	result = nullptr;
369: 	connection = nullptr;
370: 	database = nullptr;
371: 	for (auto &cur : cursors) {
372: 		cur->Close();
373: 	}
374: 	cursors.clear();
375: }
376: 
377: // cursor() is stupid
378: shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Cursor() {
379: 	auto res = make_shared<DuckDBPyConnection>();
380: 	res->database = database;
381: 	res->connection = make_unique<Connection>(*res->database);
382: 	cursors.push_back(res);
383: 	return res;
384: }
385: 
386: // these should be functions on the result but well
387: py::object DuckDBPyConnection::FetchOne() {
388: 	if (!result) {
389: 		throw std::runtime_error("no open result set");
390: 	}
391: 	return result->Fetchone();
392: }
393: 
394: py::list DuckDBPyConnection::FetchAll() {
395: 	if (!result) {
396: 		throw std::runtime_error("no open result set");
397: 	}
398: 	return result->Fetchall();
399: }
400: 
401: py::dict DuckDBPyConnection::FetchNumpy() {
402: 	if (!result) {
403: 		throw std::runtime_error("no open result set");
404: 	}
405: 	return result->FetchNumpy();
406: }
407: py::object DuckDBPyConnection::FetchDF() {
408: 	if (!result) {
409: 		throw std::runtime_error("no open result set");
410: 	}
411: 	return result->FetchDF();
412: }
413: 
414: py::object DuckDBPyConnection::FetchDFChunk() const {
415: 	if (!result) {
416: 		throw std::runtime_error("no open result set");
417: 	}
418: 	return result->FetchDFChunk();
419: }
420: 
421: py::object DuckDBPyConnection::FetchArrow() {
422: 	if (!result) {
423: 		throw std::runtime_error("no open result set");
424: 	}
425: 	return result->FetchArrowTable();
426: }
427: 
428: static unique_ptr<TableFunctionRef> TryPandasReplacement(py::dict &dict, py::str &table_name) {
429: 	if (!dict.contains(table_name)) {
430: 		// not present in the globals
431: 		return nullptr;
432: 	}
433: 	auto entry = dict[table_name];
434: 
435: 	// check if there is a local or global variable
436: 	auto table_function = make_unique<TableFunctionRef>();
437: 	vector<unique_ptr<ParsedExpression>> children;
438: 	children.push_back(make_unique<ConstantExpression>(Value::POINTER((uintptr_t)entry.ptr())));
439: 	table_function->function = make_unique<FunctionExpression>("pandas_scan", children);
440: 	return table_function;
441: }
442: 
443: static unique_ptr<TableFunctionRef> PandasScanReplacement(const string &table_name, void *data) {
444: 	// look in the locals first
445: 	PyObject *p = PyEval_GetLocals();
446: 	auto py_table_name = py::str(table_name);
447: 	if (p) {
448: 		auto local_dict = py::reinterpret_borrow<py::dict>(p);
449: 		auto result = TryPandasReplacement(local_dict, py_table_name);
450: 		if (result) {
451: 			return result;
452: 		}
453: 	}
454: 	// otherwise look in the globals
455: 	auto global_dict = py::globals();
456: 	return TryPandasReplacement(global_dict, py_table_name);
457: }
458: 
459: shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const string &database, bool read_only) {
460: 	auto res = make_shared<DuckDBPyConnection>();
461: 	DBConfig config;
462: 	if (read_only) {
463: 		config.access_mode = AccessMode::READ_ONLY;
464: 	}
465: 	config.replacement_scans.emplace_back(PandasScanReplacement);
466: 
467: 	res->database = make_unique<DuckDB>(database, &config);
468: 	ExtensionHelper::LoadAllExtensions(*res->database);
469: 	res->connection = make_unique<Connection>(*res->database);
470: 
471: 	PandasScanFunction scan_fun;
472: 	CreateTableFunctionInfo scan_info(scan_fun);
473: 
474: 	MapFunction map_fun;
475: 	CreateTableFunctionInfo map_info(map_fun);
476: 
477: 	auto &context = *res->connection->context;
478: 	auto &catalog = Catalog::GetCatalog(context);
479: 	context.transaction.BeginTransaction();
480: 	catalog.CreateTableFunction(context, &scan_info);
481: 	catalog.CreateTableFunction(context, &map_info);
482: 
483: 	context.transaction.Commit();
484: 
485: 	return res;
486: }
487: 
488: vector<Value> DuckDBPyConnection::TransformPythonParamList(py::handle params) {
489: 	vector<Value> args;
490: 
491: 	auto datetime_mod = py::module::import("datetime");
492: 	auto datetime_date = datetime_mod.attr("date");
493: 	auto datetime_datetime = datetime_mod.attr("datetime");
494: 	auto datetime_time = datetime_mod.attr("time");
495: 	auto decimal_mod = py::module::import("decimal");
496: 	auto decimal_decimal = decimal_mod.attr("Decimal");
497: 
498: 	for (pybind11::handle ele : params) {
499: 		if (ele.is_none()) {
500: 			args.emplace_back();
501: 		} else if (py::isinstance<py::bool_>(ele)) {
502: 			args.push_back(Value::BOOLEAN(ele.cast<bool>()));
503: 		} else if (py::isinstance<py::int_>(ele)) {
504: 			args.push_back(Value::BIGINT(ele.cast<int64_t>()));
505: 		} else if (py::isinstance<py::float_>(ele)) {
506: 			args.push_back(Value::DOUBLE(ele.cast<double>()));
507: 		} else if (py::isinstance<py::str>(ele)) {
508: 			args.emplace_back(ele.cast<string>());
509: 		} else if (py::isinstance(ele, decimal_decimal)) {
510: 			args.emplace_back(py::str(ele).cast<string>());
511: 		} else if (py::isinstance(ele, datetime_datetime)) {
512: 			auto year = PyDateTime_GET_YEAR(ele.ptr());
513: 			auto month = PyDateTime_GET_MONTH(ele.ptr());
514: 			auto day = PyDateTime_GET_DAY(ele.ptr());
515: 			auto hour = PyDateTime_DATE_GET_HOUR(ele.ptr());
516: 			auto minute = PyDateTime_DATE_GET_MINUTE(ele.ptr());
517: 			auto second = PyDateTime_DATE_GET_SECOND(ele.ptr());
518: 			auto micros = PyDateTime_DATE_GET_MICROSECOND(ele.ptr());
519: 			args.push_back(Value::TIMESTAMP(year, month, day, hour, minute, second, micros));
520: 		} else if (py::isinstance(ele, datetime_time)) {
521: 			auto hour = PyDateTime_TIME_GET_HOUR(ele.ptr());
522: 			auto minute = PyDateTime_TIME_GET_MINUTE(ele.ptr());
523: 			auto second = PyDateTime_TIME_GET_SECOND(ele.ptr());
524: 			auto micros = PyDateTime_TIME_GET_MICROSECOND(ele.ptr());
525: 			args.push_back(Value::TIME(hour, minute, second, micros));
526: 		} else if (py::isinstance(ele, datetime_date)) {
527: 			auto year = PyDateTime_GET_YEAR(ele.ptr());
528: 			auto month = PyDateTime_GET_MONTH(ele.ptr());
529: 			auto day = PyDateTime_GET_DAY(ele.ptr());
530: 			args.push_back(Value::DATE(year, month, day));
531: 		} else {
532: 			throw std::runtime_error("unknown param type " + py::str(ele.get_type()).cast<string>());
533: 		}
534: 	}
535: 	return args;
536: }
537: 
538: DuckDBPyConnection *DuckDBPyConnection::DefaultConnection() {
539: 	if (!default_connection) {
540: 		default_connection = DuckDBPyConnection::Connect(":memory:", false);
541: 	}
542: 	return default_connection.get();
543: }
544: 
545: void DuckDBPyConnection::Cleanup() {
546: 	default_connection.reset();
547: }
548: 
549: } // namespace duckdb
[end of tools/pythonpkg/src/pyconnection.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: