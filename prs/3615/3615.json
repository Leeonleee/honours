{
  "repo": "duckdb/duckdb",
  "pull_number": 3615,
  "instance_id": "duckdb__duckdb-3615",
  "issue_numbers": [
    "1785",
    "1785"
  ],
  "base_commit": "d8a2743d8848376c27bfe6b2b37eb39ac4ae42f7",
  "patch": "diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp\nindex 083b51fc8562..478309537a13 100644\n--- a/src/catalog/catalog_entry/table_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp\n@@ -242,6 +242,9 @@ unique_ptr<CatalogEntry> TableCatalogEntry::AddColumn(ClientContext &context, Ad\n \tfor (idx_t i = 0; i < columns.size(); i++) {\n \t\tcreate_info->columns.push_back(columns[i].Copy());\n \t}\n+\tfor (auto &constraint : constraints) {\n+\t\tcreate_info->constraints.push_back(constraint->Copy());\n+\t}\n \tBinder::BindLogicalType(context, info.new_column.type, schema->name);\n \tinfo.new_column.oid = columns.size();\n \tcreate_info->columns.push_back(info.new_column.Copy());\n",
  "test_patch": "diff --git a/test/sql/storage/alter/alter_column_constraint.test b/test/sql/storage/alter/alter_column_constraint.test\nnew file mode 100644\nindex 000000000000..4e9bde22a84f\n--- /dev/null\n+++ b/test/sql/storage/alter/alter_column_constraint.test\n@@ -0,0 +1,75 @@\n+# name: test/sql/storage/alter/alter_column_constraint.test\n+# description: Issue #1785: ALTER TABLE causes constraints lost in database file after exiting\n+# group: [alter]\n+\n+# load the DB from disk\n+load __TEST_DIR__/add_column_constraint.db\n+\n+statement ok\n+CREATE TABLE IF NOT EXISTS a(id INT PRIMARY KEY);\n+\n+statement ok\n+INSERT INTO a(id) VALUES (1);\n+\n+# add column\n+statement ok\n+ALTER TABLE a ADD COLUMN c REAL;\n+\n+statement error\n+INSERT INTO a(id) VALUES (1);\n+\n+restart\n+\n+statement error\n+INSERT INTO a(id) VALUES (1);\n+\n+# add default\n+statement ok\n+ALTER TABLE a ALTER COLUMN c SET DEFAULT 10;\n+\n+statement error\n+INSERT INTO a(id) VALUES (1);\n+\n+restart\n+\n+statement error\n+INSERT INTO a(id) VALUES (1);\n+\n+# rename column\n+statement ok\n+ALTER TABLE a RENAME c TO d;\n+\n+statement error\n+INSERT INTO a(id) VALUES (1);\n+\n+restart\n+\n+statement error\n+INSERT INTO a(id) VALUES (1);\n+\n+# rename table\n+statement ok\n+ALTER TABLE a RENAME TO b;\n+\n+statement error\n+INSERT INTO b(id) VALUES (1);\n+\n+restart\n+\n+statement error\n+INSERT INTO b(id) VALUES (1);\n+\n+# drop column\n+statement ok\n+ALTER TABLE b DROP d;\n+\n+statement error\n+INSERT INTO b(id) VALUES (1);\n+\n+restart\n+\n+statement error\n+INSERT INTO b(id) VALUES (1);\n+\n+statement ok\n+INSERT INTO b(id) VALUES (2);\n\\ No newline at end of file\n",
  "problem_statement": "Python | ALTER TABLE causes constraints lost in database file after exiting\n**What does happen?**\r\nIn python, when I alter a table (I am adding columns to the table) the PRIMARY KEY constraint in the existing columns are lost, causing duplicated values when I insert new rows. The cli-tools, on the contrary, works correctly.\r\n\r\n**What should happen?**\r\nThe constraints remains\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n1. Create a table ```db.execute('CREATE TABLE IF NOT EXISTS a(id INT PRIMARY KEY)')```\r\n2. Insert a value ```db.execute('INSERT INTO a(id) VALUES (1)')```\r\n    | id |\r\n    | :-: |\r\n    | 1  |\r\n3. Add a new column ```db.execute('ALTER TABLE a ADD COLUMN c REAL')```\r\n4. Insert the value above again ```db.execute('INSERT INTO a(id) VALUES (1)')```\r\n5. Now there are two rows with id=1\r\n    | id |  c   |\r\n    | :-: |  :-:  |\r\n    | 1  |   -  |\r\n    | 1  |   -  |\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Windows 10 with Python 3.9.5\r\n - DuckDB Version 0.2.6\r\n\nPython | ALTER TABLE causes constraints lost in database file after exiting\n**What does happen?**\r\nIn python, when I alter a table (I am adding columns to the table) the PRIMARY KEY constraint in the existing columns are lost, causing duplicated values when I insert new rows. The cli-tools, on the contrary, works correctly.\r\n\r\n**What should happen?**\r\nThe constraints remains\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n1. Create a table ```db.execute('CREATE TABLE IF NOT EXISTS a(id INT PRIMARY KEY)')```\r\n2. Insert a value ```db.execute('INSERT INTO a(id) VALUES (1)')```\r\n    | id |\r\n    | :-: |\r\n    | 1  |\r\n3. Add a new column ```db.execute('ALTER TABLE a ADD COLUMN c REAL')```\r\n4. Insert the value above again ```db.execute('INSERT INTO a(id) VALUES (1)')```\r\n5. Now there are two rows with id=1\r\n    | id |  c   |\r\n    | :-: |  :-:  |\r\n    | 1  |   -  |\r\n    | 1  |   -  |\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Windows 10 with Python 3.9.5\r\n - DuckDB Version 0.2.6\r\n\n",
  "hints_text": "Thanks for the report! Testing this on the latest version of DuckDB it seems to me that the values are being correctly refused, however, no error seems to be reported. \r\n\r\n```python\r\nimport duckdb\r\ndb = duckdb.connect()\r\ndb.execute('CREATE TABLE IF NOT EXISTS a(id INT PRIMARY KEY)')\r\ndb.execute('INSERT INTO a(id) VALUES (1)')\r\ndb.execute('INSERT INTO a(id) VALUES (1)')\r\n# RuntimeError: Constraint Error: duplicate key value violates primary key or unique constraint\r\n\r\ndb.execute('select * from a').fetchall()\r\n# [(1,)]\r\n\r\ndb.execute('ALTER TABLE a ADD COLUMN c REAL')\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None)]\r\n\r\ndb.execute('INSERT INTO a(id) VALUES (1)')\r\n# no error when there should be an error\r\n# the row is not added though...\r\n\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None)]\r\n\r\n# inserting a non-conflicting row does work\r\ndb.execute('INSERT INTO a(id) VALUES (2)')\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None), (2, None)]\r\n\r\n\r\n\r\n```\nThanks a lot for the reply. Sorry I didn't have time to view the update on the issue in the last few days.\r\nI have figured out what caused the issue.\r\nIt happens when you use a real database file rather than an in-memory one.\r\n\r\n```python\r\nimport duckdb\r\ndb = duckdb.connect('a.db')\r\ndb.execute('CREATE TABLE IF NOT EXISTS a(id INT PRIMARY KEY)')\r\ndb.execute('INSERT INTO a(id) VALUES (1)')\r\n# Connect a db file. Create a table. Insert a value. Everything works fine.\r\n\r\ndb.execute('select * from a').fetchall()\r\n# [(1,)]\r\n\r\ndb.execute('ALTER TABLE a ADD COLUMN c REAL')\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None)]\r\n\r\nexit()\r\n# Close python.\r\n\r\nimport duckdb\r\ndb = duckdb.connect('a.db')\r\n# New python instance. Connect the db again.\r\n\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None)]\r\n# What we inserted last time.\r\n\r\ndb.execute('INSERT INTO a(id) VALUES (1)')\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None), (1, None)]\r\n# Now things go wrong. 2 rows, same value.\r\n```\nStill an issue\nThanks for the report! Testing this on the latest version of DuckDB it seems to me that the values are being correctly refused, however, no error seems to be reported. \r\n\r\n```python\r\nimport duckdb\r\ndb = duckdb.connect()\r\ndb.execute('CREATE TABLE IF NOT EXISTS a(id INT PRIMARY KEY)')\r\ndb.execute('INSERT INTO a(id) VALUES (1)')\r\ndb.execute('INSERT INTO a(id) VALUES (1)')\r\n# RuntimeError: Constraint Error: duplicate key value violates primary key or unique constraint\r\n\r\ndb.execute('select * from a').fetchall()\r\n# [(1,)]\r\n\r\ndb.execute('ALTER TABLE a ADD COLUMN c REAL')\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None)]\r\n\r\ndb.execute('INSERT INTO a(id) VALUES (1)')\r\n# no error when there should be an error\r\n# the row is not added though...\r\n\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None)]\r\n\r\n# inserting a non-conflicting row does work\r\ndb.execute('INSERT INTO a(id) VALUES (2)')\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None), (2, None)]\r\n\r\n\r\n\r\n```\nThanks a lot for the reply. Sorry I didn't have time to view the update on the issue in the last few days.\r\nI have figured out what caused the issue.\r\nIt happens when you use a real database file rather than an in-memory one.\r\n\r\n```python\r\nimport duckdb\r\ndb = duckdb.connect('a.db')\r\ndb.execute('CREATE TABLE IF NOT EXISTS a(id INT PRIMARY KEY)')\r\ndb.execute('INSERT INTO a(id) VALUES (1)')\r\n# Connect a db file. Create a table. Insert a value. Everything works fine.\r\n\r\ndb.execute('select * from a').fetchall()\r\n# [(1,)]\r\n\r\ndb.execute('ALTER TABLE a ADD COLUMN c REAL')\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None)]\r\n\r\nexit()\r\n# Close python.\r\n\r\nimport duckdb\r\ndb = duckdb.connect('a.db')\r\n# New python instance. Connect the db again.\r\n\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None)]\r\n# What we inserted last time.\r\n\r\ndb.execute('INSERT INTO a(id) VALUES (1)')\r\ndb.execute('select * from a').fetchall()\r\n# [(1, None), (1, None)]\r\n# Now things go wrong. 2 rows, same value.\r\n```\nStill an issue",
  "created_at": "2022-05-10T16:56:39Z"
}