{
  "repo": "duckdb/duckdb",
  "pull_number": 10533,
  "instance_id": "duckdb__duckdb-10533",
  "issue_numbers": [
    "10381"
  ],
  "base_commit": "9da08dfb1523059189a0fc986173a56f2b9dcc55",
  "patch": "diff --git a/tools/pythonpkg/duckdb-stubs/__init__.pyi b/tools/pythonpkg/duckdb-stubs/__init__.pyi\nindex 1495233b3734..39c997782748 100644\n--- a/tools/pythonpkg/duckdb-stubs/__init__.pyi\n+++ b/tools/pythonpkg/duckdb-stubs/__init__.pyi\n@@ -296,9 +296,9 @@ class DuckDBPyConnection:\n         self,\n         name: str,\n         func: Callable,\n-        args: Optional[List[DuckDBPyType]] = None,\n+        parameters: Optional[List[DuckDBPyType]] = None,\n         return_type: Optional[DuckDBPyType] = None,\n-        vectorized: Optional[bool] = False,\n+        type: Optional[PythonUDFType] = PythonUDFType.NATIVE,\n         null_handling: Optional[FunctionNullHandling] = FunctionNullHandling.DEFAULT,\n         exception_handling: Optional[PythonExceptionHandling] = PythonExceptionHandling.DEFAULT,\n         side_effects: Optional[bool] = False)  -> DuckDBPyConnection: ...\n@@ -680,7 +680,7 @@ def register(view_name: str, python_object: object, connection: DuckDBPyConnecti\n def remove_function(name: str, connection : DuckDBPyConnection = ...) -> DuckDBPyConnection: ...\n def create_function(\n     name: str,\n-    function: Callable,\n+    func: Callable,\n     parameters: Optional[List[DuckDBPyType]] = None,\n     return_type: Optional[DuckDBPyType] = None,\n     type: Optional[PythonUDFType] = PythonUDFType.NATIVE,\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp b/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\nindex f418f5ae9f25..84f699a52c51 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\n@@ -261,6 +261,8 @@ struct DuckDBPyRelation {\n \n \tstatic bool IsRelation(const py::object &object);\n \n+\tbool CanBeRegisteredBy(Connection &con);\n+\n \tRelation &GetRel();\n \n \tbool ContainsColumnByName(const string &name) const;\ndiff --git a/tools/pythonpkg/src/native/python_conversion.cpp b/tools/pythonpkg/src/native/python_conversion.cpp\nindex 2ba5f55954d9..cfee943ab438 100644\n--- a/tools/pythonpkg/src/native/python_conversion.cpp\n+++ b/tools/pythonpkg/src/native/python_conversion.cpp\n@@ -82,22 +82,28 @@ Value TransformDictionaryToStruct(const PyDictionary &dict, const LogicalType &t\n \treturn Value::STRUCT(std::move(struct_values));\n }\n \n-Value TransformStructFormatDictionaryToMap(const PyDictionary &dict) {\n+Value TransformStructFormatDictionaryToMap(const PyDictionary &dict, const LogicalType &target_type) {\n \tif (dict.len == 0) {\n \t\treturn EmptyMapValue();\n \t}\n \n+\tif (target_type.id() != LogicalTypeId::MAP) {\n+\t\tthrow InvalidInputException(\"Please provide a valid target type for transform from Python to Value\");\n+\t}\n \tauto size = py::len(dict.keys);\n \tD_ASSERT(size == py::len(dict.values));\n \n+\tauto key_target = MapType::KeyType(target_type);\n+\tauto value_target = MapType::ValueType(target_type);\n+\n \tLogicalType key_type = LogicalType::SQLNULL;\n \tLogicalType value_type = LogicalType::SQLNULL;\n \n \tvector<Value> elements;\n \tfor (idx_t i = 0; i < size; i++) {\n \n-\t\tValue new_key = TransformPythonValue(dict.keys.attr(\"__getitem__\")(i));\n-\t\tValue new_value = TransformPythonValue(dict.values.attr(\"__getitem__\")(i));\n+\t\tValue new_key = TransformPythonValue(dict.keys.attr(\"__getitem__\")(i), key_target);\n+\t\tValue new_value = TransformPythonValue(dict.values.attr(\"__getitem__\")(i), value_target);\n \n \t\tkey_type = LogicalType::ForceMaxLogicalType(key_type, new_key.type());\n \t\tvalue_type = LogicalType::ForceMaxLogicalType(value_type, new_value.type());\n@@ -117,7 +123,7 @@ Value TransformStructFormatDictionaryToMap(const PyDictionary &dict) {\n Value TransformDictionaryToMap(const PyDictionary &dict, const LogicalType &target_type = LogicalType::UNKNOWN) {\n \tif (target_type.id() != LogicalTypeId::UNKNOWN && !DictionaryHasMapFormat(dict)) {\n \t\t// dict == { 'k1': v1, 'k2': v2, ..., 'kn': vn }\n-\t\treturn TransformStructFormatDictionaryToMap(dict);\n+\t\treturn TransformStructFormatDictionaryToMap(dict, target_type);\n \t}\n \n \tauto keys = dict.values.attr(\"__getitem__\")(0);\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex e00fbb536659..8731eb35d94d 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -619,6 +619,10 @@ shared_ptr<DuckDBPyConnection> DuckDBPyConnection::RegisterPythonObject(const st\n \t\tRegisterArrowObject(arrow_object, name);\n \t} else if (DuckDBPyRelation::IsRelation(python_object)) {\n \t\tauto pyrel = py::cast<DuckDBPyRelation *>(python_object);\n+\t\tif (!pyrel->CanBeRegisteredBy(*connection)) {\n+\t\t\tthrow InvalidInputException(\n+\t\t\t    \"The relation you are attempting to register was not made from this connection\");\n+\t\t}\n \t\tpyrel->CreateView(name, true);\n \t} else {\n \t\tauto py_object_type = string(py::str(python_object.get_type().attr(\"__name__\")));\ndiff --git a/tools/pythonpkg/src/pyrelation.cpp b/tools/pythonpkg/src/pyrelation.cpp\nindex a1b54b2aa683..1b91cbdaf09c 100644\n--- a/tools/pythonpkg/src/pyrelation.cpp\n+++ b/tools/pythonpkg/src/pyrelation.cpp\n@@ -34,6 +34,15 @@ DuckDBPyRelation::DuckDBPyRelation(shared_ptr<Relation> rel_p) : rel(std::move(r\n \t}\n }\n \n+bool DuckDBPyRelation::CanBeRegisteredBy(Connection &con) {\n+\tif (!rel) {\n+\t\t// PyRelation without an internal relation can not be registered\n+\t\treturn false;\n+\t}\n+\tauto context = rel->context.GetContext();\n+\treturn context == con.context;\n+}\n+\n DuckDBPyRelation::DuckDBPyRelation(unique_ptr<DuckDBPyResult> result_p) : rel(nullptr), result(std::move(result_p)) {\n \tif (!result) {\n \t\tthrow InternalException(\"DuckDBPyRelation created without a result\");\n@@ -735,6 +744,7 @@ unique_ptr<QueryResult> DuckDBPyRelation::ExecuteInternal(bool stream_result) {\n }\n \n void DuckDBPyRelation::ExecuteOrThrow(bool stream_result) {\n+\tresult.reset();\n \tauto query_result = ExecuteInternal(stream_result);\n \tif (!query_result) {\n \t\tthrow InternalException(\"ExecuteOrThrow - no query available to execute\");\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_relation_to_view.py b/tools/pythonpkg/tests/fast/api/test_relation_to_view.py\nnew file mode 100644\nindex 000000000000..dbe09752c472\n--- /dev/null\n+++ b/tools/pythonpkg/tests/fast/api/test_relation_to_view.py\n@@ -0,0 +1,44 @@\n+import pytest\n+import duckdb\n+\n+\n+class TestRelationToView(object):\n+    def test_values_to_view(self, duckdb_cursor):\n+        rel = duckdb_cursor.values(['test', 'this is a long string'])\n+        res = rel.fetchall()\n+        assert res == [('test', 'this is a long string')]\n+\n+        rel.to_view('vw1')\n+\n+        view = duckdb_cursor.table('vw1')\n+        res = view.fetchall()\n+        assert res == [('test', 'this is a long string')]\n+\n+    def test_relation_to_view(self, duckdb_cursor):\n+        rel = duckdb_cursor.sql(\"select 'test', 'this is a long string'\")\n+\n+        res = rel.fetchall()\n+        assert res == [('test', 'this is a long string')]\n+\n+        rel.to_view('vw1')\n+\n+        view = duckdb_cursor.table('vw1')\n+        res = view.fetchall()\n+        assert res == [('test', 'this is a long string')]\n+\n+    def test_registered_relation(self, duckdb_cursor):\n+        rel = duckdb_cursor.sql(\"select 'test', 'this is a long string'\")\n+\n+        con = duckdb.connect()\n+        # Register on a different connection is not allowed\n+        with pytest.raises(\n+            duckdb.InvalidInputException,\n+            match='The relation you are attempting to register was not made from this connection',\n+        ):\n+            con.register('cross_connection', rel)\n+\n+        # Register on the same connection just creates a view\n+        duckdb_cursor.register('same_connection', rel)\n+        view = duckdb_cursor.table('same_connection')\n+        res = view.fetchall()\n+        assert res == [('test', 'this is a long string')]\ndiff --git a/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py b/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py\nindex 2277718d0809..9c6834ff8d23 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py\n@@ -230,6 +230,24 @@ def test_analyzing_nulls(self, pandas, duckdb_cursor, fill, sample_size, get_dat\n \n         pandas.testing.assert_frame_equal(df1, df)\n \n+    @pytest.mark.parametrize('pandas', [NumpyPandas(), ArrowPandas()])\n+    def test_nested_map(self, pandas, duckdb_cursor):\n+        df = pandas.DataFrame(data={'col1': [{'a': {'b': {'x': 'A', 'y': 'B'}}}, {'c': {'b': {'x': 'A'}}}]})\n+\n+        rel = duckdb_cursor.sql(\"select * from df\")\n+        expected_rel = duckdb_cursor.sql(\n+            \"\"\"\n+            select x::map(varchar, struct(b map(varchar, varchar))) col1 from (VALUES\n+                ('{a={b: {x=A, y=B}}}'),\n+                ('{c={b: {x=A}}}')\n+            ) t(x)\n+        \"\"\"\n+        )\n+\n+        res = str(rel)\n+        expected_res = str(expected_rel)\n+        assert res == expected_res\n+\n     @pytest.mark.parametrize('pandas', [NumpyPandas(), ArrowPandas()])\n     def test_map_value_upgrade(self, pandas, duckdb_cursor):\n         x = pandas.DataFrame(\n",
  "problem_statement": "InvalidInputException when using dicts with different set of keys in python\n### What happens?\n\nIn python, when trying to query a dataframe that has nested dict column values with different keys, duckdb throws `duckdb.duckdb.InvalidInputException: Invalid Input Error: Failed to cast value`.\r\n\r\nA similar issue has been raised in https://github.com/duckdb/duckdb/issues/7734 and it seems like the particular case in that issue seems to work now. But \r\n\r\nTested on duckdb 0.8.1, 0.9.2.\n\n### To Reproduce\n\nRunning this code\r\n```python\r\nimport duckdb\r\nimport pandas as pd\r\n\r\ncon = duckdb.connect(database=':memory')\r\n\r\ndf = pd.DataFrame(data={\r\n    'col1': [\r\n        {'a': {'b': {'x': 'A', 'y': 'B'}}},\r\n        {'c': {'b': {'x': 'A'}}}\r\n    ]\r\n})\r\n\r\n\r\ncon.register('tbl', df)\r\ncon.execute(\"SELECT * FROM tbl\").fetchdf()\r\n```\r\n\r\nwill result in:\r\n`duckdb.duckdb.InvalidInputException: Invalid Input Error: Failed to cast value: Unimplemented type for cast (STRUCT(b STRUCT(x VARCHAR)) -> MAP(VARCHAR, MAP(VARCHAR, VARCHAR)))`\r\n\r\nThe only difference between the dataframe created here and in https://github.com/duckdb/duckdb/issues/7734 is in 7734 the keys of the dict are the same but in here the key of the dicts are different.\r\n\n\n### OS:\n\nOSX\n\n### DuckDB Version:\n\n0.9.2\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nSuchan Lee\n\n### Affiliation:\n\nHex Technologies\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-02-08T13:12:27Z"
}