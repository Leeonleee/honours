{
  "repo": "duckdb/duckdb",
  "pull_number": 3292,
  "instance_id": "duckdb__duckdb-3292",
  "issue_numbers": [
    "3019"
  ],
  "base_commit": "39cfae40b31bd5be73f7686af889e8b801da21b7",
  "patch": "diff --git a/extension/parquet/column_writer.cpp b/extension/parquet/column_writer.cpp\nindex 7a1d26dc6030..42fb7dacfecd 100644\n--- a/extension/parquet/column_writer.cpp\n+++ b/extension/parquet/column_writer.cpp\n@@ -53,11 +53,7 @@ static void VarintEncode(uint32_t val, Serializer &ser) {\n static uint8_t GetVarintSize(uint32_t val) {\n \tuint8_t res = 0;\n \tdo {\n-\t\tuint8_t byte = val & 127;\n \t\tval >>= 7;\n-\t\tif (val != 0) {\n-\t\t\tbyte |= 128;\n-\t\t}\n \t\tres++;\n \t} while (val != 0);\n \treturn res;\ndiff --git a/extension/parquet/include/templated_column_reader.hpp b/extension/parquet/include/templated_column_reader.hpp\nindex 9cc36d4735cc..fc74aee33cef 100644\n--- a/extension/parquet/include/templated_column_reader.hpp\n+++ b/extension/parquet/include/templated_column_reader.hpp\n@@ -55,10 +55,6 @@ class TemplatedColumnReader : public ColumnReader {\n \t\t\t}\n \t\t\tif (filter[row_idx + result_offset]) {\n \t\t\t\tVALUE_TYPE val = VALUE_CONVERSION::DictRead(*dict, offsets[offset_idx++], *this);\n-\t\t\t\tif (!Value::IsValid(val)) {\n-\t\t\t\t\tresult_mask.SetInvalid(row_idx + result_offset);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n \t\t\t\tresult_ptr[row_idx + result_offset] = val;\n \t\t\t} else {\n \t\t\t\toffset_idx++;\n@@ -77,10 +73,6 @@ class TemplatedColumnReader : public ColumnReader {\n \t\t\t}\n \t\t\tif (filter[row_idx + result_offset]) {\n \t\t\t\tVALUE_TYPE val = VALUE_CONVERSION::PlainRead(*plain_data, *this);\n-\t\t\t\tif (!Value::IsValid(val)) {\n-\t\t\t\t\tresult_mask.SetInvalid(row_idx + result_offset);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n \t\t\t\tresult_ptr[row_idx + result_offset] = val;\n \t\t\t} else { // there is still some data there that we have to skip over\n \t\t\t\tVALUE_CONVERSION::PlainSkip(*plain_data, *this);\ndiff --git a/extension/parquet/parquet_statistics.cpp b/extension/parquet/parquet_statistics.cpp\nindex 4d42e7b2ac44..fd4e9e3f5d2f 100644\n--- a/extension/parquet/parquet_statistics.cpp\n+++ b/extension/parquet/parquet_statistics.cpp\n@@ -81,7 +81,7 @@ Value ParquetStatisticsUtils::ConvertValue(const LogicalType &type,\n \t\t\tthrow InternalException(\"Incorrect stats size for type FLOAT\");\n \t\t}\n \t\tauto val = Load<float>((data_ptr_t)stats.c_str());\n-\t\tif (!Value::FloatIsValid(val)) {\n+\t\tif (!Value::FloatIsFinite(val)) {\n \t\t\treturn Value();\n \t\t}\n \t\treturn Value::FLOAT(val);\n@@ -91,7 +91,7 @@ Value ParquetStatisticsUtils::ConvertValue(const LogicalType &type,\n \t\t\tthrow InternalException(\"Incorrect stats size for type DOUBLE\");\n \t\t}\n \t\tauto val = Load<double>((data_ptr_t)stats.c_str());\n-\t\tif (!Value::DoubleIsValid(val)) {\n+\t\tif (!Value::DoubleIsFinite(val)) {\n \t\t\treturn Value();\n \t\t}\n \t\treturn Value::DOUBLE(val);\ndiff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp\nindex 20d0f2a5a4ec..17f5385bb04e 100644\n--- a/src/common/operator/cast_operators.cpp\n+++ b/src/common/operator/cast_operators.cpp\n@@ -1012,19 +1012,6 @@ bool TryCast::Operation(string_t input, uint64_t &result, bool strict) {\n \treturn TryIntegerCast<uint64_t, false>(input.GetDataUnsafe(), input.GetSize(), result, strict);\n }\n \n-template <class T>\n-bool CheckDoubleValidity(T value);\n-\n-template <>\n-bool CheckDoubleValidity(float value) {\n-\treturn Value::FloatIsValid(value);\n-}\n-\n-template <>\n-bool CheckDoubleValidity(double value) {\n-\treturn Value::DoubleIsValid(value);\n-}\n-\n template <class T>\n static bool TryDoubleCast(const char *buf, idx_t len, T &result, bool strict) {\n \t// skip any spaces at the start\n@@ -1041,9 +1028,6 @@ static bool TryDoubleCast(const char *buf, idx_t len, T &result, bool strict) {\n \t}\n \tauto endptr = buf + len;\n \tauto parse_result = duckdb_fast_float::from_chars(buf, buf + len, result);\n-\tif (!CheckDoubleValidity<T>(result)) {\n-\t\treturn false;\n-\t}\n \tif (parse_result.ec != std::errc()) {\n \t\treturn false;\n \t}\ndiff --git a/src/common/radix.cpp b/src/common/radix.cpp\nindex c65370f7a91a..0a126b759626 100644\n--- a/src/common/radix.cpp\n+++ b/src/common/radix.cpp\n@@ -1,4 +1,6 @@\n #include \"duckdb/common/radix.hpp\"\n+#include \"duckdb/common/types/value.hpp\"\n+#include \"duckdb/common/types/string_type.hpp\"\n \n #include <cfloat>\n #include <cstring> // strlen() on Solaris\n@@ -28,15 +30,17 @@ uint32_t EncodeFloat(float x) {\n \t\tbuff |= (1u << 31);\n \t\treturn buff;\n \t}\n+\t// nan\n+\tif (Value::IsNan(x)) {\n+\t\treturn UINT_MAX;\n+\t}\n \t//! infinity\n \tif (x > FLT_MAX) {\n-\t\tthrow InternalException(\"+INFINITY detected in floating point number\");\n-\t\t// return UINT_MAX;\n+\t\treturn UINT_MAX - 1;\n \t}\n \t//! -infinity\n \tif (x < -FLT_MAX) {\n-\t\tthrow InternalException(\"-INFINITY detected in floating point number\");\n-\t\t// return 0;\n+\t\treturn 0;\n \t}\n \tbuff = Load<uint32_t>((const_data_ptr_t)&x);\n \tif ((buff & (1u << 31)) == 0) { //! +0 and positive numbers\n@@ -56,15 +60,17 @@ uint64_t EncodeDouble(double x) {\n \t\tbuff += (1ull << 63);\n \t\treturn buff;\n \t}\n+\t// nan\n+\tif (Value::IsNan(x)) {\n+\t\treturn ULLONG_MAX;\n+\t}\n \t//! infinity\n \tif (x > DBL_MAX) {\n-\t\tthrow InternalException(\"+INFINITY detected in floating point number\");\n-\t\t// return ULLONG_MAX;\n+\t\treturn ULLONG_MAX - 1;\n \t}\n \t//! -infinity\n \tif (x < -DBL_MAX) {\n-\t\tthrow InternalException(\"-INFINITY detected in floating point number\");\n-\t\t// return 0;\n+\t\treturn 0;\n \t}\n \tbuff = Load<uint64_t>((const_data_ptr_t)&x);\n \tif (buff < (1ull << 63)) { //! +0 and positive numbers\ndiff --git a/src/common/types.cpp b/src/common/types.cpp\nindex 9cc957d0d76d..4b0b7ecdd7ff 100644\n--- a/src/common/types.cpp\n+++ b/src/common/types.cpp\n@@ -745,11 +745,23 @@ void LogicalType::Verify() const {\n }\n \n bool ApproxEqual(float ldecimal, float rdecimal) {\n+\tif (Value::IsNan(ldecimal) && Value::IsNan(rdecimal)) {\n+\t\treturn true;\n+\t}\n+\tif (!Value::FloatIsFinite(ldecimal) || !Value::FloatIsFinite(rdecimal)) {\n+\t\treturn ldecimal == rdecimal;\n+\t}\n \tfloat epsilon = std::fabs(rdecimal) * 0.01;\n \treturn std::fabs(ldecimal - rdecimal) <= epsilon;\n }\n \n bool ApproxEqual(double ldecimal, double rdecimal) {\n+\tif (Value::IsNan(ldecimal) && Value::IsNan(rdecimal)) {\n+\t\treturn true;\n+\t}\n+\tif (!Value::DoubleIsFinite(ldecimal) || !Value::DoubleIsFinite(rdecimal)) {\n+\t\treturn ldecimal == rdecimal;\n+\t}\n \tdouble epsilon = std::fabs(rdecimal) * 0.01;\n \treturn std::fabs(ldecimal - rdecimal) <= epsilon;\n }\ndiff --git a/src/common/types/hugeint.cpp b/src/common/types/hugeint.cpp\nindex e6ba24c4e752..084907a79e02 100644\n--- a/src/common/types/hugeint.cpp\n+++ b/src/common/types/hugeint.cpp\n@@ -3,6 +3,7 @@\n #include \"duckdb/common/algorithm.hpp\"\n #include \"duckdb/common/limits.hpp\"\n #include \"duckdb/common/windows_undefs.hpp\"\n+#include \"duckdb/common/types/value.hpp\"\n \n #include <cmath>\n #include <limits>\n@@ -543,6 +544,9 @@ bool Hugeint::TryConvert(float value, hugeint_t &result) {\n \n template <class REAL_T>\n bool ConvertFloatingToBigint(REAL_T value, hugeint_t &result) {\n+\tif (!Value::IsFinite<REAL_T>(value)) {\n+\t\treturn false;\n+\t}\n \tif (value <= -170141183460469231731687303715884105728.0 || value >= 170141183460469231731687303715884105727.0) {\n \t\treturn false;\n \t}\ndiff --git a/src/common/types/value.cpp b/src/common/types/value.cpp\nindex aed60da5ff06..dd6401fe90b1 100644\n--- a/src/common/types/value.cpp\n+++ b/src/common/types/value.cpp\n@@ -1,5 +1,3 @@\n-#include <utility>\n-\n #include \"duckdb/common/types/value.hpp\"\n \n #include \"duckdb/common/exception.hpp\"\n@@ -29,6 +27,9 @@\n #include \"duckdb/common/types/cast_helpers.hpp\"\n #include \"duckdb/common/types/hash.hpp\"\n \n+#include <utility>\n+#include <cmath>\n+\n namespace duckdb {\n \n Value::Value(LogicalType type) : type_(move(type)), is_null(true) {\n@@ -43,16 +44,10 @@ Value::Value(int64_t val) : type_(LogicalType::BIGINT), is_null(false) {\n }\n \n Value::Value(float val) : type_(LogicalType::FLOAT), is_null(false) {\n-\tif (!Value::FloatIsValid(val)) {\n-\t\tthrow OutOfRangeException(\"Invalid float value %f\", val);\n-\t}\n \tvalue_.float_ = val;\n }\n \n Value::Value(double val) : type_(LogicalType::DOUBLE), is_null(false) {\n-\tif (!Value::DoubleIsValid(val)) {\n-\t\tthrow OutOfRangeException(\"Invalid double value %f\", val);\n-\t}\n \tvalue_.double_ = val;\n }\n \n@@ -326,14 +321,34 @@ Value Value::UBIGINT(uint64_t value) {\n \treturn result;\n }\n \n-bool Value::FloatIsValid(float value) {\n+bool Value::FloatIsFinite(float value) {\n \treturn !(std::isnan(value) || std::isinf(value));\n }\n \n-bool Value::DoubleIsValid(double value) {\n+bool Value::DoubleIsFinite(double value) {\n \treturn !(std::isnan(value) || std::isinf(value));\n }\n \n+template <>\n+bool Value::IsNan(float input) {\n+\treturn std::isnan(input);\n+}\n+\n+template <>\n+bool Value::IsNan(double input) {\n+\treturn std::isnan(input);\n+}\n+\n+template <>\n+bool Value::IsFinite(float input) {\n+\treturn Value::FloatIsFinite(input);\n+}\n+\n+template <>\n+bool Value::IsFinite(double input) {\n+\treturn Value::DoubleIsFinite(input);\n+}\n+\n bool Value::StringIsValid(const char *str, idx_t length) {\n \tauto utf_type = Utf8Proc::Analyze(str, length);\n \treturn utf_type != UnicodeType::INVALID;\n@@ -386,9 +401,6 @@ Value Value::DECIMAL(hugeint_t value, uint8_t width, uint8_t scale) {\n }\n \n Value Value::FLOAT(float value) {\n-\tif (!Value::FloatIsValid(value)) {\n-\t\tthrow OutOfRangeException(\"Invalid float value %f\", value);\n-\t}\n \tValue result(LogicalType::FLOAT);\n \tresult.value_.float_ = value;\n \tresult.is_null = false;\n@@ -396,9 +408,6 @@ Value Value::FLOAT(float value) {\n }\n \n Value Value::DOUBLE(double value) {\n-\tif (!Value::DoubleIsValid(value)) {\n-\t\tthrow OutOfRangeException(\"Invalid double value %f\", value);\n-\t}\n \tValue result(LogicalType::DOUBLE);\n \tresult.value_.double_ = value;\n \tresult.is_null = false;\n@@ -1399,6 +1408,22 @@ string Value::ToSQLString() const {\n \t\tret += \"}\";\n \t\treturn ret;\n \t}\n+\tcase LogicalTypeId::FLOAT:\n+\t\tif (!FloatIsFinite(FloatValue::Get(*this))) {\n+\t\t\treturn \"'\" + ToString() + \"'::\" + type_.ToString();\n+\t\t}\n+\t\treturn ToString();\n+\tcase LogicalTypeId::DOUBLE: {\n+\t\tdouble val = DoubleValue::Get(*this);\n+\t\tif (!DoubleIsFinite(val)) {\n+\t\t\tif (!Value::IsNan(val)) {\n+\t\t\t\t// to infinity and beyond\n+\t\t\t\treturn val < 0 ? \"-1e1000\" : \"1e1000\";\n+\t\t\t}\n+\t\t\treturn \"'\" + ToString() + \"'::\" + type_.ToString();\n+\t\t}\n+\t\treturn ToString();\n+\t}\n \tcase LogicalTypeId::LIST: {\n \t\tstring ret = \"[\";\n \t\tfor (size_t i = 0; i < list_value.size(); i++) {\n@@ -1778,14 +1803,4 @@ bool Value::ValuesAreEqual(const Value &result_value, const Value &value) {\n \t}\n }\n \n-template <>\n-bool Value::IsValid(float value) {\n-\treturn Value::FloatIsValid(value);\n-}\n-\n-template <>\n-bool Value::IsValid(double value) {\n-\treturn Value::DoubleIsValid(value);\n-}\n-\n } // namespace duckdb\ndiff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp\nindex b3b0b241400e..91772d7981f6 100644\n--- a/src/common/types/vector.cpp\n+++ b/src/common/types/vector.cpp\n@@ -984,30 +984,6 @@ void Vector::Verify(const SelectionVector &sel, idx_t count) {\n \t    (GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR)) {\n \t\tD_ASSERT(!auxiliary);\n \t}\n-\tif (GetType().InternalType() == PhysicalType::DOUBLE) {\n-\t\t// verify that there are no INF or NAN values\n-\t\tswitch (GetVectorType()) {\n-\t\tcase VectorType::CONSTANT_VECTOR: {\n-\t\t\tauto dbl = ConstantVector::GetData<double>(*this);\n-\t\t\tif (!ConstantVector::IsNull(*this)) {\n-\t\t\t\tD_ASSERT(Value::DoubleIsValid(*dbl));\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase VectorType::FLAT_VECTOR: {\n-\t\t\tauto doubles = FlatVector::GetData<double>(*this);\n-\t\t\tfor (idx_t i = 0; i < count; i++) {\n-\t\t\t\tauto oidx = sel.get_index(i);\n-\t\t\t\tif (validity.RowIsValid(oidx)) {\n-\t\t\t\t\tD_ASSERT(Value::DoubleIsValid(doubles[oidx]));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t}\n-\t\tdefault:\n-\t\t\tbreak;\n-\t\t}\n-\t}\n \tif (GetType().id() == LogicalTypeId::VARCHAR || GetType().id() == LogicalTypeId::JSON) {\n \t\t// verify that there are no '\\0' bytes in string values\n \t\tswitch (GetVectorType()) {\ndiff --git a/src/common/vector_operations/comparison_operators.cpp b/src/common/vector_operations/comparison_operators.cpp\nindex 0b479621fafc..c58813e0b0be 100644\n--- a/src/common/vector_operations/comparison_operators.cpp\n+++ b/src/common/vector_operations/comparison_operators.cpp\n@@ -9,8 +9,83 @@\n #include \"duckdb/common/vector_operations/binary_executor.hpp\"\n #include \"duckdb/common/vector_operations/vector_operations.hpp\"\n \n+#include \"duckdb/common/likely.hpp\"\n+\n namespace duckdb {\n \n+template <class T>\n+bool EqualsFloat(T left, T right) {\n+\tif (DUCKDB_UNLIKELY(Value::IsNan(left) && Value::IsNan(right))) {\n+\t\treturn true;\n+\t}\n+\treturn left == right;\n+}\n+\n+template <>\n+bool Equals::Operation(float left, float right) {\n+\treturn EqualsFloat<float>(left, right);\n+}\n+\n+template <>\n+bool Equals::Operation(double left, double right) {\n+\treturn EqualsFloat<double>(left, right);\n+}\n+\n+template <class T>\n+bool GreaterThanFloat(T left, T right) {\n+\t// handle nans\n+\t// nan is always bigger than everything else\n+\tbool left_is_nan = Value::IsNan(left);\n+\tbool right_is_nan = Value::IsNan(right);\n+\t// if right is nan, there is no number that is bigger than right\n+\tif (DUCKDB_UNLIKELY(right_is_nan)) {\n+\t\treturn false;\n+\t}\n+\t// if left is nan, but right is not, left is always bigger\n+\tif (DUCKDB_UNLIKELY(left_is_nan)) {\n+\t\treturn true;\n+\t}\n+\treturn left > right;\n+}\n+\n+template <>\n+bool GreaterThan::Operation(float left, float right) {\n+\treturn GreaterThanFloat<float>(left, right);\n+}\n+\n+template <>\n+bool GreaterThan::Operation(double left, double right) {\n+\treturn GreaterThanFloat<double>(left, right);\n+}\n+\n+template <class T>\n+bool GreaterThanEqualsFloat(T left, T right) {\n+\t// handle nans\n+\t// nan is always bigger than everything else\n+\tbool left_is_nan = Value::IsNan(left);\n+\tbool right_is_nan = Value::IsNan(right);\n+\t// if right is nan, there is no bigger number\n+\t// we only return true if left is also nan (in which case the numbers are equal)\n+\tif (DUCKDB_UNLIKELY(right_is_nan)) {\n+\t\treturn left_is_nan;\n+\t}\n+\t// if left is nan, but right is not, left is always bigger\n+\tif (DUCKDB_UNLIKELY(left_is_nan)) {\n+\t\treturn true;\n+\t}\n+\treturn left >= right;\n+}\n+\n+template <>\n+bool GreaterThanEquals::Operation(float left, float right) {\n+\treturn GreaterThanEqualsFloat<float>(left, right);\n+}\n+\n+template <>\n+bool GreaterThanEquals::Operation(double left, double right) {\n+\treturn GreaterThanEqualsFloat<double>(left, right);\n+}\n+\n struct ComparisonSelector {\n \ttemplate <typename OP>\n \tstatic idx_t Select(Vector &left, Vector &right, const SelectionVector *sel, idx_t count, SelectionVector *true_sel,\ndiff --git a/src/function/aggregate/algebraic/avg.cpp b/src/function/aggregate/algebraic/avg.cpp\nindex 90156a170a07..0b361ef22ccc 100644\n--- a/src/function/aggregate/algebraic/avg.cpp\n+++ b/src/function/aggregate/algebraic/avg.cpp\n@@ -121,7 +121,7 @@ struct NumericAverageOperation : public BaseSumOperation<AverageSetOperation, Re\n \t\tif (state->count == 0) {\n \t\t\tmask.SetInvalid(idx);\n \t\t} else {\n-\t\t\tif (!Value::DoubleIsValid(state->value)) {\n+\t\t\tif (!Value::DoubleIsFinite(state->value)) {\n \t\t\t\tthrow OutOfRangeException(\"AVG is out of range!\");\n \t\t\t}\n \t\t\ttarget[idx] = (state->value / state->count);\n@@ -135,7 +135,7 @@ struct KahanAverageOperation : public BaseSumOperation<AverageSetOperation, Kaha\n \t\tif (state->count == 0) {\n \t\t\tmask.SetInvalid(idx);\n \t\t} else {\n-\t\t\tif (!Value::DoubleIsValid(state->value)) {\n+\t\t\tif (!Value::DoubleIsFinite(state->value)) {\n \t\t\t\tthrow OutOfRangeException(\"AVG is out of range!\");\n \t\t\t}\n \t\t\ttarget[idx] = (state->value / state->count) + (state->err / state->count);\ndiff --git a/src/function/aggregate/distributive/kurtosis.cpp b/src/function/aggregate/distributive/kurtosis.cpp\nindex aa8cfabee530..72f40ee31bb1 100644\n--- a/src/function/aggregate/distributive/kurtosis.cpp\n+++ b/src/function/aggregate/distributive/kurtosis.cpp\n@@ -74,8 +74,8 @@ struct KurtosisOperation {\n \t\t\tmask.SetInvalid(idx);\n \t\t} // LCOV_EXCL_STOP\n \t\ttarget[idx] = (n - 1) * ((n + 1) * m4 / (m2 * m2) - 3 * (n - 1)) / ((n - 2) * (n - 3));\n-\t\tif (!Value::DoubleIsValid(target[idx])) {\n-\t\t\tmask.SetInvalid(idx);\n+\t\tif (!Value::DoubleIsFinite(target[idx])) {\n+\t\t\tthrow OutOfRangeException(\"Kurtosis is out of range!\");\n \t\t}\n \t}\n \ndiff --git a/src/function/aggregate/distributive/skew.cpp b/src/function/aggregate/distributive/skew.cpp\nindex 7f5c3d99bf4b..a1bd1282a4a1 100644\n--- a/src/function/aggregate/distributive/skew.cpp\n+++ b/src/function/aggregate/distributive/skew.cpp\n@@ -65,8 +65,8 @@ struct SkewnessOperation {\n \t\ttarget[idx] = temp1 * temp *\n \t\t              (state->sum_cub - 3 * state->sum_sqr * state->sum * temp + 2 * pow(state->sum, 3) * temp * temp) /\n \t\t              div;\n-\t\tif (!Value::DoubleIsValid(target[idx])) {\n-\t\t\tmask.SetInvalid(idx);\n+\t\tif (!Value::DoubleIsFinite(target[idx])) {\n+\t\t\tthrow OutOfRangeException(\"SKEW is out of range!\");\n \t\t}\n \t}\n \ndiff --git a/src/function/aggregate/distributive/sum.cpp b/src/function/aggregate/distributive/sum.cpp\nindex 8bb9af26936e..76472b797326 100644\n--- a/src/function/aggregate/distributive/sum.cpp\n+++ b/src/function/aggregate/distributive/sum.cpp\n@@ -52,7 +52,7 @@ struct DoubleSumOperation : public BaseSumOperation<SumSetOperation, ADD_OPERATO\n \t\tif (!state->isset) {\n \t\t\tmask.SetInvalid(idx);\n \t\t} else {\n-\t\t\tif (!Value::DoubleIsValid(state->value)) {\n+\t\t\tif (!Value::DoubleIsFinite(state->value)) {\n \t\t\t\tthrow OutOfRangeException(\"SUM is out of range!\");\n \t\t\t}\n \t\t\ttarget[idx] = state->value;\ndiff --git a/src/function/aggregate/regression/regr_r2.cpp b/src/function/aggregate/regression/regr_r2.cpp\nindex 38663a453041..eae4318d60fa 100644\n--- a/src/function/aggregate/regression/regr_r2.cpp\n+++ b/src/function/aggregate/regression/regr_r2.cpp\n@@ -42,7 +42,7 @@ struct RegrR2Operation {\n \ttemplate <class T, class STATE>\n \tstatic void Finalize(Vector &result, FunctionData *fd, STATE *state, T *target, ValidityMask &mask, idx_t idx) {\n \t\tauto var_pop_x = state->var_pop_x.count > 1 ? (state->var_pop_x.dsquared / state->var_pop_x.count) : 0;\n-\t\tif (!Value::DoubleIsValid(var_pop_x)) {\n+\t\tif (!Value::DoubleIsFinite(var_pop_x)) {\n \t\t\tthrow OutOfRangeException(\"VARPOP(X) is out of range!\");\n \t\t}\n \t\tif (var_pop_x == 0) {\n@@ -50,7 +50,7 @@ struct RegrR2Operation {\n \t\t\treturn;\n \t\t}\n \t\tauto var_pop_y = state->var_pop_y.count > 1 ? (state->var_pop_y.dsquared / state->var_pop_y.count) : 0;\n-\t\tif (!Value::DoubleIsValid(var_pop_y)) {\n+\t\tif (!Value::DoubleIsFinite(var_pop_y)) {\n \t\t\tthrow OutOfRangeException(\"VARPOP(Y) is out of range!\");\n \t\t}\n \t\tif (var_pop_y == 0) {\ndiff --git a/src/function/aggregate/regression/regr_sxx_syy.cpp b/src/function/aggregate/regression/regr_sxx_syy.cpp\nindex 21fd68c158de..abe41a47c166 100644\n--- a/src/function/aggregate/regression/regr_sxx_syy.cpp\n+++ b/src/function/aggregate/regression/regr_sxx_syy.cpp\n@@ -34,7 +34,7 @@ struct RegrBaseOperation {\n \t\t\treturn;\n \t\t}\n \t\tauto var_pop = state->var_pop.count > 1 ? (state->var_pop.dsquared / state->var_pop.count) : 0;\n-\t\tif (!Value::DoubleIsValid(var_pop)) {\n+\t\tif (!Value::DoubleIsFinite(var_pop)) {\n \t\t\tthrow OutOfRangeException(\"VARPOP is out of range!\");\n \t\t}\n \t\tRegrCountFunction::Finalize<T, size_t>(result, fd, &state->count, target, mask, idx);\ndiff --git a/src/function/scalar/math/numeric.cpp b/src/function/scalar/math/numeric.cpp\nindex 51f78c3f000a..406b33a5301b 100644\n--- a/src/function/scalar/math/numeric.cpp\n+++ b/src/function/scalar/math/numeric.cpp\n@@ -7,6 +7,7 @@\n #include \"duckdb/planner/expression/bound_function_expression.hpp\"\n #include \"duckdb/common/algorithm.hpp\"\n #include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/common/likely.hpp\"\n #include <cmath>\n #include <errno.h>\n \n@@ -37,51 +38,6 @@ static scalar_function_t GetScalarIntegerUnaryFunctionFixedReturn(const LogicalT\n \treturn function;\n }\n \n-template <class OP>\n-struct UnaryDoubleWrapper {\n-\ttemplate <class INPUT_TYPE, class RESULT_TYPE>\n-\tstatic RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {\n-\t\tRESULT_TYPE result = OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input);\n-\t\tif (std::isnan(result) || std::isinf(result) || errno != 0) {\n-\t\t\terrno = 0;\n-\t\t\tmask.SetInvalid(idx);\n-\t\t\treturn 0;\n-\t\t}\n-\t\treturn result;\n-\t}\n-};\n-\n-template <class T, class OP>\n-static void UnaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {\n-\tD_ASSERT(input.ColumnCount() >= 1);\n-\terrno = 0;\n-\tUnaryExecutor::GenericExecute<T, T, UnaryDoubleWrapper<OP>>(input.data[0], result, input.size(), nullptr, true);\n-}\n-\n-struct BinaryDoubleWrapper {\n-\ttemplate <class FUNC, class OP, class TA, class TB, class TR>\n-\tstatic inline TR Operation(FUNC fun, TA left, TB right, ValidityMask &mask, idx_t idx) {\n-\t\tTR result = OP::template Operation<TA, TB, TR>(left, right);\n-\t\tif (std::isnan(result) || std::isinf(result) || errno != 0) {\n-\t\t\terrno = 0;\n-\t\t\tmask.SetInvalid(idx);\n-\t\t\treturn 0;\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\tstatic bool AddsNulls() {\n-\t\treturn true;\n-\t}\n-};\n-\n-template <class T, class OP>\n-static void BinaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {\n-\tD_ASSERT(input.ColumnCount() >= 2);\n-\terrno = 0;\n-\tBinaryExecutor::Execute<T, T, T, OP, BinaryDoubleWrapper>(input.data[0], input.data[1], result, input.size());\n-}\n-\n //===--------------------------------------------------------------------===//\n // nextafter\n //===--------------------------------------------------------------------===//\n@@ -102,23 +58,14 @@ struct NextAfterOperator {\n \t}\n };\n \n-unique_ptr<FunctionData> BindNextAfter(ClientContext &context, ScalarFunction &function,\n-                                       vector<unique_ptr<Expression>> &arguments) {\n-\tif ((arguments[0]->return_type != arguments[1]->return_type) ||\n-\t    (arguments[0]->return_type != LogicalType::FLOAT && arguments[0]->return_type != LogicalType::DOUBLE)) {\n-\t\tthrow NotImplementedException(\"Unimplemented type for NextAfter Function\");\n-\t}\n-\treturn nullptr;\n-}\n-\n void NextAfterFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunctionSet next_after_fun(\"nextafter\");\n \tnext_after_fun.AddFunction(\n \t    ScalarFunction(\"nextafter\", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                   BinaryDoubleFunctionWrapper<double, NextAfterOperator>, false, BindNextAfter));\n+\t                   ScalarFunction::BinaryFunction<double, double, double, NextAfterOperator>, false));\n \tnext_after_fun.AddFunction(ScalarFunction(\"nextafter\", {LogicalType::FLOAT, LogicalType::FLOAT}, LogicalType::FLOAT,\n-\t                                          BinaryDoubleFunctionWrapper<float, NextAfterOperator>, false,\n-\t                                          BindNextAfter));\n+\t                                          ScalarFunction::BinaryFunction<float, float, float, NextAfterOperator>,\n+\t                                          false));\n \tset.AddFunction(next_after_fun);\n }\n \n@@ -195,10 +142,10 @@ void BitCountFun::RegisterFunction(BuiltinFunctions &set) {\n //===--------------------------------------------------------------------===//\n struct SignOperator {\n \ttemplate <class TA, class TR>\n-\tstatic inline TR Operation(TA left) {\n-\t\tif (left == TA(0)) {\n+\tstatic TR Operation(TA input) {\n+\t\tif (input == TA(0)) {\n \t\t\treturn 0;\n-\t\t} else if (left > TA(0)) {\n+\t\t} else if (input > TA(0)) {\n \t\t\treturn 1;\n \t\t} else {\n \t\t\treturn -1;\n@@ -206,6 +153,28 @@ struct SignOperator {\n \t}\n };\n \n+template <>\n+int8_t SignOperator::Operation(float input) {\n+\tif (input == 0 || Value::IsNan(input)) {\n+\t\treturn 0;\n+\t} else if (input > 0) {\n+\t\treturn 1;\n+\t} else {\n+\t\treturn -1;\n+\t}\n+}\n+\n+template <>\n+int8_t SignOperator::Operation(double input) {\n+\tif (input == 0 || Value::IsNan(input)) {\n+\t\treturn 0;\n+\t} else if (input > 0) {\n+\t\treturn 1;\n+\t} else {\n+\t\treturn -1;\n+\t}\n+}\n+\n void SignFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunctionSet sign(\"sign\");\n \tfor (auto &type : LogicalType::Numeric()) {\n@@ -585,7 +554,7 @@ struct ExpOperator {\n \n void ExpFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"exp\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, ExpOperator>));\n+\t                               ScalarFunction::UnaryFunction<double, double, ExpOperator>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -600,7 +569,7 @@ struct PowOperator {\n \n void PowFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunction power_function(\"pow\", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                              BinaryDoubleFunctionWrapper<double, PowOperator>);\n+\t                              ScalarFunction::BinaryFunction<double, double, double, PowOperator>);\n \tset.AddFunction(power_function);\n \tpower_function.name = \"power\";\n \tset.AddFunction(power_function);\n@@ -615,14 +584,17 @@ void PowFun::RegisterFunction(BuiltinFunctions &set) {\n //===--------------------------------------------------------------------===//\n struct SqrtOperator {\n \ttemplate <class TA, class TR>\n-\tstatic inline TR Operation(TA left) {\n-\t\treturn std::sqrt(left);\n+\tstatic inline TR Operation(TA input) {\n+\t\tif (input < 0) {\n+\t\t\tthrow OutOfRangeException(\"cannot take square root of a negative number\");\n+\t\t}\n+\t\treturn std::sqrt(input);\n \t}\n };\n \n void SqrtFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"sqrt\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, SqrtOperator>));\n+\t                               ScalarFunction::UnaryFunction<double, double, SqrtOperator>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -637,7 +609,7 @@ struct CbRtOperator {\n \n void CbrtFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"cbrt\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, CbRtOperator>));\n+\t                               ScalarFunction::UnaryFunction<double, double, CbRtOperator>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -646,14 +618,20 @@ void CbrtFun::RegisterFunction(BuiltinFunctions &set) {\n \n struct LnOperator {\n \ttemplate <class TA, class TR>\n-\tstatic inline TR Operation(TA left) {\n-\t\treturn std::log(left);\n+\tstatic inline TR Operation(TA input) {\n+\t\tif (input < 0) {\n+\t\t\tthrow OutOfRangeException(\"cannot take logarithm of a negative number\");\n+\t\t}\n+\t\tif (input == 0) {\n+\t\t\tthrow OutOfRangeException(\"cannot take logarithm of zero\");\n+\t\t}\n+\t\treturn std::log(input);\n \t}\n };\n \n void LnFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"ln\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, LnOperator>));\n+\t                               ScalarFunction::UnaryFunction<double, double, LnOperator>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -661,14 +639,20 @@ void LnFun::RegisterFunction(BuiltinFunctions &set) {\n //===--------------------------------------------------------------------===//\n struct Log10Operator {\n \ttemplate <class TA, class TR>\n-\tstatic inline TR Operation(TA left) {\n-\t\treturn std::log10(left);\n+\tstatic inline TR Operation(TA input) {\n+\t\tif (input < 0) {\n+\t\t\tthrow OutOfRangeException(\"cannot take logarithm of a negative number\");\n+\t\t}\n+\t\tif (input == 0) {\n+\t\t\tthrow OutOfRangeException(\"cannot take logarithm of zero\");\n+\t\t}\n+\t\treturn std::log10(input);\n \t}\n };\n \n void Log10Fun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction({\"log10\", \"log\"}, ScalarFunction({LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                                                 UnaryDoubleFunctionWrapper<double, Log10Operator>));\n+\t                                                 ScalarFunction::UnaryFunction<double, double, Log10Operator>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -676,14 +660,20 @@ void Log10Fun::RegisterFunction(BuiltinFunctions &set) {\n //===--------------------------------------------------------------------===//\n struct Log2Operator {\n \ttemplate <class TA, class TR>\n-\tstatic inline TR Operation(TA left) {\n-\t\treturn std::log2(left);\n+\tstatic inline TR Operation(TA input) {\n+\t\tif (input < 0) {\n+\t\t\tthrow OutOfRangeException(\"cannot take logarithm of a negative number\");\n+\t\t}\n+\t\tif (input == 0) {\n+\t\t\tthrow OutOfRangeException(\"cannot take logarithm of zero\");\n+\t\t}\n+\t\treturn std::log2(input);\n \t}\n };\n \n void Log2Fun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"log2\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, Log2Operator>));\n+\t                               ScalarFunction::UnaryFunction<double, double, Log2Operator>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -711,7 +701,7 @@ struct DegreesOperator {\n \n void DegreesFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"degrees\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, DegreesOperator>));\n+\t                               ScalarFunction::UnaryFunction<double, double, DegreesOperator>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -726,12 +716,83 @@ struct RadiansOperator {\n \n void RadiansFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"radians\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, RadiansOperator>));\n+\t                               ScalarFunction::UnaryFunction<double, double, RadiansOperator>));\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// isnan\n+//===--------------------------------------------------------------------===//\n+struct IsNanOperator {\n+\ttemplate <class TA, class TR>\n+\tstatic inline TR Operation(TA input) {\n+\t\treturn Value::IsNan(input);\n+\t}\n+};\n+\n+void IsNanFun::RegisterFunction(BuiltinFunctions &set) {\n+\tScalarFunctionSet funcs(\"isnan\");\n+\tfuncs.AddFunction(ScalarFunction({LogicalType::FLOAT}, LogicalType::BOOLEAN,\n+\t                                 ScalarFunction::UnaryFunction<float, bool, IsNanOperator>));\n+\tfuncs.AddFunction(ScalarFunction({LogicalType::DOUBLE}, LogicalType::BOOLEAN,\n+\t                                 ScalarFunction::UnaryFunction<double, bool, IsNanOperator>));\n+\tset.AddFunction(funcs);\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// isinf\n+//===--------------------------------------------------------------------===//\n+struct IsInfiniteOperator {\n+\ttemplate <class TA, class TR>\n+\tstatic inline TR Operation(TA input) {\n+\t\treturn !Value::IsNan(input) && !Value::IsFinite(input);\n+\t}\n+};\n+\n+void IsInfiniteFun::RegisterFunction(BuiltinFunctions &set) {\n+\tScalarFunctionSet funcs(\"isinf\");\n+\tfuncs.AddFunction(ScalarFunction({LogicalType::FLOAT}, LogicalType::BOOLEAN,\n+\t                                 ScalarFunction::UnaryFunction<float, bool, IsInfiniteOperator>));\n+\tfuncs.AddFunction(ScalarFunction({LogicalType::DOUBLE}, LogicalType::BOOLEAN,\n+\t                                 ScalarFunction::UnaryFunction<double, bool, IsInfiniteOperator>));\n+\tset.AddFunction(funcs);\n+}\n+\n+//===--------------------------------------------------------------------===//\n+// isfinite\n+//===--------------------------------------------------------------------===//\n+struct IsFiniteOperator {\n+\ttemplate <class TA, class TR>\n+\tstatic inline TR Operation(TA input) {\n+\t\treturn Value::IsFinite(input);\n+\t}\n+};\n+\n+void IsFiniteFun::RegisterFunction(BuiltinFunctions &set) {\n+\tScalarFunctionSet funcs(\"isfinite\");\n+\tfuncs.AddFunction(ScalarFunction({LogicalType::FLOAT}, LogicalType::BOOLEAN,\n+\t                                 ScalarFunction::UnaryFunction<float, bool, IsFiniteOperator>));\n+\tfuncs.AddFunction(ScalarFunction({LogicalType::DOUBLE}, LogicalType::BOOLEAN,\n+\t                                 ScalarFunction::UnaryFunction<double, bool, IsFiniteOperator>));\n+\tset.AddFunction(funcs);\n }\n \n //===--------------------------------------------------------------------===//\n // sin\n //===--------------------------------------------------------------------===//\n+template <class OP>\n+struct NoInfiniteDoubleWrapper {\n+\ttemplate <class INPUT_TYPE, class RESULT_TYPE>\n+\tstatic RESULT_TYPE Operation(INPUT_TYPE input) {\n+\t\tif (DUCKDB_UNLIKELY(!Value::IsFinite(input))) {\n+\t\t\tif (Value::IsNan(input)) {\n+\t\t\t\treturn input;\n+\t\t\t}\n+\t\t\tthrow OutOfRangeException(\"input value %lf is out of range for numeric function\", input);\n+\t\t}\n+\t\treturn OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input);\n+\t}\n+};\n+\n struct SinOperator {\n \ttemplate <class TA, class TR>\n \tstatic inline TR Operation(TA input) {\n@@ -740,8 +801,9 @@ struct SinOperator {\n };\n \n void SinFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction(ScalarFunction(\"sin\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, SinOperator>));\n+\tset.AddFunction(\n+\t    ScalarFunction(\"sin\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n+\t                   ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<SinOperator>>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -755,8 +817,9 @@ struct CosOperator {\n };\n \n void CosFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction(ScalarFunction(\"cos\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, CosOperator>));\n+\tset.AddFunction(\n+\t    ScalarFunction(\"cos\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n+\t                   ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<CosOperator>>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -770,8 +833,9 @@ struct TanOperator {\n };\n \n void TanFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction(ScalarFunction(\"tan\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, TanOperator>));\n+\tset.AddFunction(\n+\t    ScalarFunction(\"tan\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n+\t                   ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<TanOperator>>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -788,8 +852,9 @@ struct ASinOperator {\n };\n \n void AsinFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction(ScalarFunction(\"asin\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, ASinOperator>));\n+\tset.AddFunction(\n+\t    ScalarFunction(\"asin\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n+\t                   ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<ASinOperator>>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -804,7 +869,7 @@ struct ATanOperator {\n \n void AtanFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"atan\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, ATanOperator>));\n+\t                               ScalarFunction::UnaryFunction<double, double, ATanOperator>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -819,7 +884,7 @@ struct ATan2 {\n \n void Atan2Fun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"atan2\", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               BinaryDoubleFunctionWrapper<double, ATan2>));\n+\t                               ScalarFunction::BinaryFunction<double, double, double, ATan2>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -833,8 +898,8 @@ struct ACos {\n };\n \n void AcosFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction(\n-\t    ScalarFunction(\"acos\", {LogicalType::DOUBLE}, LogicalType::DOUBLE, UnaryDoubleFunctionWrapper<double, ACos>));\n+\tset.AddFunction(ScalarFunction(\"acos\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n+\t                               ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<ACos>>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -848,8 +913,9 @@ struct CotOperator {\n };\n \n void CotFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction(ScalarFunction(\"cot\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, CotOperator>));\n+\tset.AddFunction(\n+\t    ScalarFunction(\"cot\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n+\t                   ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<CotOperator>>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -857,14 +923,17 @@ void CotFun::RegisterFunction(BuiltinFunctions &set) {\n //===--------------------------------------------------------------------===//\n struct GammaOperator {\n \ttemplate <class TA, class TR>\n-\tstatic inline TR Operation(TA left) {\n-\t\treturn std::tgamma(left);\n+\tstatic inline TR Operation(TA input) {\n+\t\tif (input == 0) {\n+\t\t\tthrow OutOfRangeException(\"cannot take gamma of zero\");\n+\t\t}\n+\t\treturn std::tgamma(input);\n \t}\n };\n \n void GammaFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"gamma\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, GammaOperator>));\n+\t                               ScalarFunction::UnaryFunction<double, double, GammaOperator>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -872,14 +941,17 @@ void GammaFun::RegisterFunction(BuiltinFunctions &set) {\n //===--------------------------------------------------------------------===//\n struct LogGammaOperator {\n \ttemplate <class TA, class TR>\n-\tstatic inline TR Operation(TA left) {\n-\t\treturn std::lgamma(left);\n+\tstatic inline TR Operation(TA input) {\n+\t\tif (input == 0) {\n+\t\t\tthrow OutOfRangeException(\"cannot take log gamma of zero\");\n+\t\t}\n+\t\treturn std::lgamma(input);\n \t}\n };\n \n void LogGammaFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"lgamma\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, LogGammaOperator>));\n+\t                               ScalarFunction::UnaryFunction<double, double, LogGammaOperator>));\n }\n \n //===--------------------------------------------------------------------===//\n@@ -929,7 +1001,7 @@ struct EvenOperator {\n \n void EvenFun::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(ScalarFunction(\"even\", {LogicalType::DOUBLE}, LogicalType::DOUBLE,\n-\t                               UnaryDoubleFunctionWrapper<double, EvenOperator>));\n+\t                               ScalarFunction::UnaryFunction<double, double, EvenOperator>));\n }\n \n } // namespace duckdb\ndiff --git a/src/function/scalar/math_functions.cpp b/src/function/scalar/math_functions.cpp\nindex dc0bbb899314..3750303b79ab 100644\n--- a/src/function/scalar/math_functions.cpp\n+++ b/src/function/scalar/math_functions.cpp\n@@ -36,6 +36,10 @@ void BuiltinFunctions::RegisterMathFunctions() {\n \tRegister<NextAfterFun>();\n \n \tRegister<EvenFun>();\n+\n+\tRegister<IsNanFun>();\n+\tRegister<IsInfiniteFun>();\n+\tRegister<IsFiniteFun>();\n }\n \n } // namespace duckdb\ndiff --git a/src/function/scalar/operators/add.cpp b/src/function/scalar/operators/add.cpp\nindex 67afe8c8c98b..8c87513dd23e 100644\n--- a/src/function/scalar/operators/add.cpp\n+++ b/src/function/scalar/operators/add.cpp\n@@ -19,7 +19,7 @@ namespace duckdb {\n template <>\n float AddOperator::Operation(float left, float right) {\n \tauto result = left + right;\n-\tif (!Value::FloatIsValid(result)) {\n+\tif (!Value::FloatIsFinite(result)) {\n \t\tthrow OutOfRangeException(\"Overflow in addition of float!\");\n \t}\n \treturn result;\n@@ -28,7 +28,7 @@ float AddOperator::Operation(float left, float right) {\n template <>\n double AddOperator::Operation(double left, double right) {\n \tauto result = left + right;\n-\tif (!Value::DoubleIsValid(result)) {\n+\tif (!Value::DoubleIsFinite(result)) {\n \t\tthrow OutOfRangeException(\"Overflow in addition of double!\");\n \t}\n \treturn result;\ndiff --git a/src/function/scalar/operators/arithmetic.cpp b/src/function/scalar/operators/arithmetic.cpp\nindex c88a5af739f2..e9650f142829 100644\n--- a/src/function/scalar/operators/arithmetic.cpp\n+++ b/src/function/scalar/operators/arithmetic.cpp\n@@ -366,6 +366,16 @@ struct NegateOperator {\n \t}\n };\n \n+template <>\n+bool NegateOperator::CanNegate(float input) {\n+\treturn Value::FloatIsFinite(input);\n+}\n+\n+template <>\n+bool NegateOperator::CanNegate(double input) {\n+\treturn Value::DoubleIsFinite(input);\n+}\n+\n template <>\n interval_t NegateOperator::Operation(interval_t input) {\n \tinterval_t result;\n@@ -691,7 +701,7 @@ void MultiplyFun::RegisterFunction(BuiltinFunctions &set) {\n template <>\n float DivideOperator::Operation(float left, float right) {\n \tauto result = left / right;\n-\tif (!Value::FloatIsValid(result)) {\n+\tif (!Value::FloatIsFinite(result)) {\n \t\tthrow OutOfRangeException(\"Overflow in division of float!\");\n \t}\n \treturn result;\n@@ -700,7 +710,7 @@ float DivideOperator::Operation(float left, float right) {\n template <>\n double DivideOperator::Operation(double left, double right) {\n \tauto result = left / right;\n-\tif (!Value::DoubleIsValid(result)) {\n+\tif (!Value::DoubleIsFinite(result)) {\n \t\tthrow OutOfRangeException(\"Overflow in division of double!\");\n \t}\n \treturn result;\n@@ -812,13 +822,21 @@ void DivideFun::RegisterFunction(BuiltinFunctions &set) {\n template <>\n float ModuloOperator::Operation(float left, float right) {\n \tD_ASSERT(right != 0);\n-\treturn std::fmod(left, right);\n+\tauto result = std::fmod(left, right);\n+\tif (!Value::FloatIsFinite(result)) {\n+\t\tthrow OutOfRangeException(\"Overflow in modulo of float!\");\n+\t}\n+\treturn result;\n }\n \n template <>\n double ModuloOperator::Operation(double left, double right) {\n \tD_ASSERT(right != 0);\n-\treturn std::fmod(left, right);\n+\tauto result = std::fmod(left, right);\n+\tif (!Value::DoubleIsFinite(result)) {\n+\t\tthrow OutOfRangeException(\"Overflow in modulo of double!\");\n+\t}\n+\treturn result;\n }\n \n template <>\ndiff --git a/src/function/scalar/operators/multiply.cpp b/src/function/scalar/operators/multiply.cpp\nindex d8f3e38a0c30..47442aa9c737 100644\n--- a/src/function/scalar/operators/multiply.cpp\n+++ b/src/function/scalar/operators/multiply.cpp\n@@ -16,7 +16,7 @@ namespace duckdb {\n template <>\n float MultiplyOperator::Operation(float left, float right) {\n \tauto result = left * right;\n-\tif (!Value::FloatIsValid(result)) {\n+\tif (!Value::FloatIsFinite(result)) {\n \t\tthrow OutOfRangeException(\"Overflow in multiplication of float!\");\n \t}\n \treturn result;\n@@ -25,7 +25,7 @@ float MultiplyOperator::Operation(float left, float right) {\n template <>\n double MultiplyOperator::Operation(double left, double right) {\n \tauto result = left * right;\n-\tif (!Value::DoubleIsValid(result)) {\n+\tif (!Value::DoubleIsFinite(result)) {\n \t\tthrow OutOfRangeException(\"Overflow in multiplication of double!\");\n \t}\n \treturn result;\ndiff --git a/src/function/scalar/operators/subtract.cpp b/src/function/scalar/operators/subtract.cpp\nindex 6a370bb9af59..601f95fb3878 100644\n--- a/src/function/scalar/operators/subtract.cpp\n+++ b/src/function/scalar/operators/subtract.cpp\n@@ -16,7 +16,7 @@ namespace duckdb {\n template <>\n float SubtractOperator::Operation(float left, float right) {\n \tauto result = left - right;\n-\tif (!Value::FloatIsValid(result)) {\n+\tif (!Value::FloatIsFinite(result)) {\n \t\tthrow OutOfRangeException(\"Overflow in subtraction of float!\");\n \t}\n \treturn result;\n@@ -25,7 +25,7 @@ float SubtractOperator::Operation(float left, float right) {\n template <>\n double SubtractOperator::Operation(double left, double right) {\n \tauto result = left - right;\n-\tif (!Value::DoubleIsValid(result)) {\n+\tif (!Value::DoubleIsFinite(result)) {\n \t\tthrow OutOfRangeException(\"Overflow in subtraction of double!\");\n \t}\n \treturn result;\ndiff --git a/src/function/table/arrow.cpp b/src/function/table/arrow.cpp\nindex 7c6530aaca36..fa8a09e71366 100644\n--- a/src/function/table/arrow.cpp\n+++ b/src/function/table/arrow.cpp\n@@ -590,6 +590,7 @@ void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanState &scan\n \tcase LogicalTypeId::SMALLINT:\n \tcase LogicalTypeId::INTEGER:\n \tcase LogicalTypeId::FLOAT:\n+\tcase LogicalTypeId::DOUBLE:\n \tcase LogicalTypeId::UTINYINT:\n \tcase LogicalTypeId::USMALLINT:\n \tcase LogicalTypeId::UINTEGER:\n@@ -603,18 +604,6 @@ void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanState &scan\n \t\tDirectConversion(vector, array, scan_state, nested_offset);\n \t\tbreak;\n \t}\n-\tcase LogicalTypeId::DOUBLE: {\n-\t\tDirectConversion(vector, array, scan_state, nested_offset);\n-\t\t//! Need to check if there are NaNs, if yes, must turn that to null\n-\t\tauto data = (double *)vector.GetData();\n-\t\tauto &mask = FlatVector::Validity(vector);\n-\t\tfor (idx_t row_idx = 0; row_idx < size; row_idx++) {\n-\t\t\tif (!Value::DoubleIsValid(data[row_idx])) {\n-\t\t\t\tmask.SetInvalid(row_idx);\n-\t\t\t}\n-\t\t}\n-\t\tbreak;\n-\t}\n \tcase LogicalTypeId::JSON:\n \tcase LogicalTypeId::VARCHAR: {\n \t\tauto original_type = arrow_convert_data[col_idx]->variable_sz_type[arrow_convert_idx.first++];\ndiff --git a/src/include/duckdb/common/operator/comparison_operators.hpp b/src/include/duckdb/common/operator/comparison_operators.hpp\nindex 7b7028463cd2..a3d44e6bea00 100644\n--- a/src/include/duckdb/common/operator/comparison_operators.hpp\n+++ b/src/include/duckdb/common/operator/comparison_operators.hpp\n@@ -30,15 +30,17 @@ struct Equals {\n struct NotEquals {\n \ttemplate <class T>\n \tstatic inline bool Operation(T left, T right) {\n-\t\treturn left != right;\n+\t\treturn !Equals::Operation(left, right);\n \t}\n };\n+\n struct GreaterThan {\n \ttemplate <class T>\n \tstatic inline bool Operation(T left, T right) {\n \t\treturn left > right;\n \t}\n };\n+\n struct GreaterThanEquals {\n \ttemplate <class T>\n \tstatic inline bool Operation(T left, T right) {\n@@ -49,30 +51,46 @@ struct GreaterThanEquals {\n struct LessThan {\n \ttemplate <class T>\n \tstatic inline bool Operation(T left, T right) {\n-\t\treturn left < right;\n+\t\treturn GreaterThan::Operation(right, left);\n \t}\n };\n+\n struct LessThanEquals {\n \ttemplate <class T>\n \tstatic inline bool Operation(T left, T right) {\n-\t\treturn left <= right;\n+\t\treturn GreaterThanEquals::Operation(right, left);\n \t}\n };\n \n+template <>\n+bool Equals::Operation(float left, float right);\n+template <>\n+bool Equals::Operation(double left, double right);\n+\n+template <>\n+bool GreaterThan::Operation(float left, float right);\n+template <>\n+bool GreaterThan::Operation(double left, double right);\n+\n+template <>\n+bool GreaterThanEquals::Operation(float left, float right);\n+template <>\n+bool GreaterThanEquals::Operation(double left, double right);\n+\n // Distinct semantics are from Postgres record sorting. NULL = NULL and not-NULL < NULL\n // Deferring to the non-distinct operations removes the need for further specialisation.\n // TODO: To reverse the semantics, swap left_null and right_null for comparisons\n struct DistinctFrom {\n \ttemplate <class T>\n \tstatic inline bool Operation(T left, T right, bool left_null, bool right_null) {\n-\t\treturn (left_null != right_null) || (!left_null && !right_null && (left != right));\n+\t\treturn (left_null != right_null) || (!left_null && !right_null && NotEquals::Operation(left, right));\n \t}\n };\n \n struct NotDistinctFrom {\n \ttemplate <class T>\n \tstatic inline bool Operation(T left, T right, bool left_null, bool right_null) {\n-\t\treturn (left_null && right_null) || (!left_null && !right_null && (left == right));\n+\t\treturn (left_null && right_null) || (!left_null && !right_null && Equals::Operation(left, right));\n \t}\n };\n \ndiff --git a/src/include/duckdb/common/operator/numeric_cast.hpp b/src/include/duckdb/common/operator/numeric_cast.hpp\nindex 8f545cb83eeb..9edcc765d2d3 100644\n--- a/src/include/duckdb/common/operator/numeric_cast.hpp\n+++ b/src/include/duckdb/common/operator/numeric_cast.hpp\n@@ -10,11 +10,15 @@\n \n #include \"duckdb/common/operator/cast_operators.hpp\"\n #include \"duckdb/common/types/hugeint.hpp\"\n+#include \"duckdb/common/types/value.hpp\"\n \n namespace duckdb {\n \n template <class SRC, class DST>\n static bool TryCastWithOverflowCheck(SRC value, DST &result) {\n+\tif (!Value::IsFinite<SRC>(value)) {\n+\t\treturn false;\n+\t}\n \tif (NumericLimits<SRC>::IsSigned() != NumericLimits<DST>::IsSigned()) {\n \t\tif (NumericLimits<SRC>::IsSigned()) {\n \t\t\t// signed to unsigned conversion\n@@ -57,40 +61,58 @@ static bool TryCastWithOverflowCheck(SRC value, DST &result) {\n \t}\n }\n \n-template <>\n-bool TryCastWithOverflowCheck(float value, int32_t &result) {\n-\tif (!(value >= -2147483648.0f && value < 2147483648.0f)) {\n+template <class SRC, class T>\n+bool TryCastWithOverflowCheckFloat(SRC value, T &result, SRC min, SRC max) {\n+\tif (!Value::IsFinite<SRC>(value)) {\n \t\treturn false;\n \t}\n-\tresult = int32_t(value);\n+\tif (!(value >= min && value < max)) {\n+\t\treturn false;\n+\t}\n+\tresult = T(value);\n \treturn true;\n }\n \n+template <>\n+bool TryCastWithOverflowCheck(float value, int32_t &result) {\n+\treturn TryCastWithOverflowCheckFloat<float, int32_t>(value, result, -2147483648.0f, 2147483648.0f);\n+}\n+\n template <>\n bool TryCastWithOverflowCheck(float value, int64_t &result) {\n-\tif (!(value >= -9223372036854775808.0f && value < 9223372036854775808.0f)) {\n-\t\treturn false;\n-\t}\n-\tresult = int64_t(value);\n-\treturn true;\n+\treturn TryCastWithOverflowCheckFloat<float, int64_t>(value, result, -9223372036854775808.0f,\n+\t                                                     9223372036854775808.0f);\n }\n \n template <>\n bool TryCastWithOverflowCheck(double value, int64_t &result) {\n-\tif (!(value >= -9223372036854775808.0 && value < 9223372036854775808.0)) {\n-\t\treturn false;\n-\t}\n-\tresult = int64_t(value);\n+\treturn TryCastWithOverflowCheckFloat<double, int64_t>(value, result, -9223372036854775808.0, 9223372036854775808.0);\n+}\n+\n+template <>\n+bool TryCastWithOverflowCheck(float input, float &result) {\n+\tresult = input;\n+\treturn true;\n+}\n+template <>\n+bool TryCastWithOverflowCheck(float input, double &result) {\n+\tresult = double(input);\n+\treturn true;\n+}\n+template <>\n+bool TryCastWithOverflowCheck(double input, double &result) {\n+\tresult = input;\n \treturn true;\n }\n \n template <>\n bool TryCastWithOverflowCheck(double input, float &result) {\n-\tif (input < (double)NumericLimits<float>::Minimum() || input > (double)NumericLimits<float>::Maximum()) {\n-\t\treturn false;\n+\tif (!Value::IsFinite(input)) {\n+\t\tresult = float(input);\n+\t\treturn true;\n \t}\n-\tauto res = (float)input;\n-\tif (std::isnan(res) || std::isinf(res)) {\n+\tauto res = float(input);\n+\tif (!Value::FloatIsFinite(input)) {\n \t\treturn false;\n \t}\n \tresult = res;\ndiff --git a/src/include/duckdb/common/types/value.hpp b/src/include/duckdb/common/types/value.hpp\nindex 4c16c5b79805..9b67fd136ef8 100644\n--- a/src/include/duckdb/common/types/value.hpp\n+++ b/src/include/duckdb/common/types/value.hpp\n@@ -222,17 +222,20 @@ class Value {\n \tDUCKDB_API bool operator<=(const int64_t &rhs) const;\n \tDUCKDB_API bool operator>=(const int64_t &rhs) const;\n \n-\tDUCKDB_API static bool FloatIsValid(float value);\n-\tDUCKDB_API static bool DoubleIsValid(double value);\n-\tDUCKDB_API static bool StringIsValid(const char *str, idx_t length);\n-\tstatic bool StringIsValid(const string &str) {\n-\t\treturn StringIsValid(str.c_str(), str.size());\n+\tDUCKDB_API static bool FloatIsFinite(float value);\n+\tDUCKDB_API static bool DoubleIsFinite(double value);\n+\ttemplate <class T>\n+\tstatic bool IsNan(T value) {\n+\t\tthrow InternalException(\"Unimplemented template type for Value::IsNan\");\n \t}\n-\n \ttemplate <class T>\n-\tstatic bool IsValid(T value) {\n+\tstatic bool IsFinite(T value) {\n \t\treturn true;\n \t}\n+\tDUCKDB_API static bool StringIsValid(const char *str, idx_t length);\n+\tstatic bool StringIsValid(const string &str) {\n+\t\treturn StringIsValid(str.c_str(), str.size());\n+\t}\n \n \t//! Returns true if the values are (approximately) equivalent. Note this is NOT the SQL equivalence. For this\n \t//! function, NULL values are equivalent and floating point values that are close are equivalent.\n@@ -519,8 +522,13 @@ template <>\n DUCKDB_API interval_t &Value::GetReferenceUnsafe();\n \n template <>\n-DUCKDB_API bool Value::IsValid(float value);\n+DUCKDB_API bool Value::IsNan(float input);\n+template <>\n+DUCKDB_API bool Value::IsNan(double input);\n+\n+template <>\n+DUCKDB_API bool Value::IsFinite(float input);\n template <>\n-DUCKDB_API bool Value::IsValid(double value);\n+DUCKDB_API bool Value::IsFinite(double input);\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/function/aggregate/algebraic/corr.hpp b/src/include/duckdb/function/aggregate/algebraic/corr.hpp\nindex 0d87f1d44b0b..d62d6af92410 100644\n--- a/src/include/duckdb/function/aggregate/algebraic/corr.hpp\n+++ b/src/include/duckdb/function/aggregate/algebraic/corr.hpp\n@@ -54,12 +54,12 @@ struct CorrOperation {\n \t\t} else {\n \t\t\tauto cov = state->cov_pop.co_moment / state->cov_pop.count;\n \t\t\tauto std_x = state->dev_pop_x.count > 1 ? sqrt(state->dev_pop_x.dsquared / state->dev_pop_x.count) : 0;\n-\t\t\tif (!Value::DoubleIsValid(std_x)) {\n-\t\t\t\tthrow OutOfRangeException(\"STDDEV_POP for X is invalid!\");\n+\t\t\tif (!Value::DoubleIsFinite(std_x)) {\n+\t\t\t\tthrow OutOfRangeException(\"STDDEV_POP for X is out of range!\");\n \t\t\t}\n \t\t\tauto std_y = state->dev_pop_y.count > 1 ? sqrt(state->dev_pop_y.dsquared / state->dev_pop_y.count) : 0;\n-\t\t\tif (!Value::DoubleIsValid(std_y)) {\n-\t\t\t\tthrow OutOfRangeException(\"STDDEV_POP for Y is invalid!\");\n+\t\t\tif (!Value::DoubleIsFinite(std_y)) {\n+\t\t\t\tthrow OutOfRangeException(\"STDDEV_POP for Y is out of range!\");\n \t\t\t}\n \t\t\tif (std_x * std_y == 0) {\n \t\t\t\tmask.SetInvalid(idx);\ndiff --git a/src/include/duckdb/function/aggregate/algebraic/stddev.hpp b/src/include/duckdb/function/aggregate/algebraic/stddev.hpp\nindex edc688b63ba5..3594823d67b2 100644\n--- a/src/include/duckdb/function/aggregate/algebraic/stddev.hpp\n+++ b/src/include/duckdb/function/aggregate/algebraic/stddev.hpp\n@@ -79,7 +79,7 @@ struct VarSampOperation : public STDDevBaseOperation {\n \t\t\tmask.SetInvalid(idx);\n \t\t} else {\n \t\t\ttarget[idx] = state->dsquared / (state->count - 1);\n-\t\t\tif (!Value::DoubleIsValid(target[idx])) {\n+\t\t\tif (!Value::DoubleIsFinite(target[idx])) {\n \t\t\t\tthrow OutOfRangeException(\"VARSAMP is out of range!\");\n \t\t\t}\n \t\t}\n@@ -93,7 +93,7 @@ struct VarPopOperation : public STDDevBaseOperation {\n \t\t\tmask.SetInvalid(idx);\n \t\t} else {\n \t\t\ttarget[idx] = state->count > 1 ? (state->dsquared / state->count) : 0;\n-\t\t\tif (!Value::DoubleIsValid(target[idx])) {\n+\t\t\tif (!Value::DoubleIsFinite(target[idx])) {\n \t\t\t\tthrow OutOfRangeException(\"VARPOP is out of range!\");\n \t\t\t}\n \t\t}\n@@ -107,7 +107,7 @@ struct STDDevSampOperation : public STDDevBaseOperation {\n \t\t\tmask.SetInvalid(idx);\n \t\t} else {\n \t\t\ttarget[idx] = sqrt(state->dsquared / (state->count - 1));\n-\t\t\tif (!Value::DoubleIsValid(target[idx])) {\n+\t\t\tif (!Value::DoubleIsFinite(target[idx])) {\n \t\t\t\tthrow OutOfRangeException(\"STDDEV_SAMP is out of range!\");\n \t\t\t}\n \t\t}\n@@ -121,7 +121,7 @@ struct STDDevPopOperation : public STDDevBaseOperation {\n \t\t\tmask.SetInvalid(idx);\n \t\t} else {\n \t\t\ttarget[idx] = state->count > 1 ? sqrt(state->dsquared / state->count) : 0;\n-\t\t\tif (!Value::DoubleIsValid(target[idx])) {\n+\t\t\tif (!Value::DoubleIsFinite(target[idx])) {\n \t\t\t\tthrow OutOfRangeException(\"STDDEV_POP is out of range!\");\n \t\t\t}\n \t\t}\n@@ -135,7 +135,7 @@ struct StandardErrorOfTheMeanOperation : public STDDevBaseOperation {\n \t\t\tmask.SetInvalid(idx);\n \t\t} else {\n \t\t\ttarget[idx] = sqrt(state->dsquared / state->count) / sqrt((state->count));\n-\t\t\tif (!Value::DoubleIsValid(target[idx])) {\n+\t\t\tif (!Value::DoubleIsFinite(target[idx])) {\n \t\t\t\tthrow OutOfRangeException(\"SEM is out of range!\");\n \t\t\t}\n \t\t}\ndiff --git a/src/include/duckdb/function/aggregate/regression/regr_slope.hpp b/src/include/duckdb/function/aggregate/regression/regr_slope.hpp\nindex f27f00d2b076..e9a2a17e9a0d 100644\n--- a/src/include/duckdb/function/aggregate/regression/regr_slope.hpp\n+++ b/src/include/duckdb/function/aggregate/regression/regr_slope.hpp\n@@ -45,7 +45,7 @@ struct RegrSlopeOperation {\n \t\t} else {\n \t\t\tauto cov = state->cov_pop.co_moment / state->cov_pop.count;\n \t\t\tauto var_pop = state->var_pop.count > 1 ? (state->var_pop.dsquared / state->var_pop.count) : 0;\n-\t\t\tif (!Value::DoubleIsValid(var_pop)) {\n+\t\t\tif (!Value::DoubleIsFinite(var_pop)) {\n \t\t\t\tthrow OutOfRangeException(\"VARPOP is out of range!\");\n \t\t\t}\n \t\t\tif (var_pop == 0) {\ndiff --git a/src/include/duckdb/function/scalar/math_functions.hpp b/src/include/duckdb/function/scalar/math_functions.hpp\nindex e75785c75b84..37594429ca0d 100644\n--- a/src/include/duckdb/function/scalar/math_functions.hpp\n+++ b/src/include/duckdb/function/scalar/math_functions.hpp\n@@ -105,4 +105,16 @@ struct EvenFun {\n \tstatic void RegisterFunction(BuiltinFunctions &set);\n };\n \n+struct IsNanFun {\n+\tstatic void RegisterFunction(BuiltinFunctions &set);\n+};\n+\n+struct IsInfiniteFun {\n+\tstatic void RegisterFunction(BuiltinFunctions &set);\n+};\n+\n+struct IsFiniteFun {\n+\tstatic void RegisterFunction(BuiltinFunctions &set);\n+};\n+\n } // namespace duckdb\ndiff --git a/src/main/appender.cpp b/src/main/appender.cpp\nindex d182621a19c4..12e57ceadcfc 100644\n--- a/src/main/appender.cpp\n+++ b/src/main/appender.cpp\n@@ -208,17 +208,11 @@ void BaseAppender::Append(string_t value) {\n \n template <>\n void BaseAppender::Append(float value) {\n-\tif (!Value::FloatIsValid(value)) {\n-\t\tthrow InvalidInputException(\"Float value is out of range!\");\n-\t}\n \tAppendValueInternal<float>(value);\n }\n \n template <>\n void BaseAppender::Append(double value) {\n-\tif (!Value::DoubleIsValid(value)) {\n-\t\tthrow InvalidInputException(\"Double value is out of range!\");\n-\t}\n \tAppendValueInternal<double>(value);\n }\n \ndiff --git a/src/main/capi/hugeint-c.cpp b/src/main/capi/hugeint-c.cpp\nindex fc3d0b249291..253190039aae 100644\n--- a/src/main/capi/hugeint-c.cpp\n+++ b/src/main/capi/hugeint-c.cpp\n@@ -16,7 +16,7 @@ double duckdb_hugeint_to_double(duckdb_hugeint val) {\n \n duckdb_hugeint duckdb_double_to_hugeint(double val) {\n \thugeint_t internal_result;\n-\tif (!Value::DoubleIsValid(val) || !Hugeint::TryConvert<double>(val, internal_result)) {\n+\tif (!Value::DoubleIsFinite(val) || !Hugeint::TryConvert<double>(val, internal_result)) {\n \t\tinternal_result.lower = 0;\n \t\tinternal_result.upper = 0;\n \t}\ndiff --git a/src/main/capi/prepared-c.cpp b/src/main/capi/prepared-c.cpp\nindex ac6ad15004bd..0df1f4e9da2f 100644\n--- a/src/main/capi/prepared-c.cpp\n+++ b/src/main/capi/prepared-c.cpp\n@@ -112,16 +112,10 @@ duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, id\n }\n \n duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val) {\n-\tif (!Value::FloatIsValid(val)) {\n-\t\treturn DuckDBError;\n-\t}\n \treturn duckdb_bind_value(prepared_statement, param_idx, Value::FLOAT(val));\n }\n \n duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val) {\n-\tif (!Value::DoubleIsValid(val)) {\n-\t\treturn DuckDBError;\n-\t}\n \treturn duckdb_bind_value(prepared_statement, param_idx, Value::DOUBLE(val));\n }\n \ndiff --git a/src/main/query_profiler.cpp b/src/main/query_profiler.cpp\nindex 86b6672d5dcc..f72bb3127ed0 100644\n--- a/src/main/query_profiler.cpp\n+++ b/src/main/query_profiler.cpp\n@@ -239,7 +239,7 @@ void OperatorProfiler::AddTiming(const PhysicalOperator *op, double time, idx_t\n \tif (!enabled) {\n \t\treturn;\n \t}\n-\tif (!Value::DoubleIsValid(time)) {\n+\tif (!Value::DoubleIsFinite(time)) {\n \t\treturn;\n \t}\n \tauto entry = timings.find(op);\ndiff --git a/src/parser/transform/expression/transform_constant.cpp b/src/parser/transform/expression/transform_constant.cpp\nindex be3c73329f4f..ef1af6fde7dc 100644\n--- a/src/parser/transform/expression/transform_constant.cpp\n+++ b/src/parser/transform/expression/transform_constant.cpp\n@@ -63,9 +63,6 @@ unique_ptr<ConstantExpression> Transformer::TransformValue(duckdb_libpgquery::PG\n \t\t}\n \t\t// if there is a decimal or the value is too big to cast as either hugeint or bigint\n \t\tdouble dbl_value = Cast::Operation<string_t, double>(str_val);\n-\t\tif (!Value::DoubleIsValid(dbl_value)) {\n-\t\t\tthrow ParserException(\"Double value \\\"%s\\\" is out of range!\", val.val.str);\n-\t\t}\n \t\treturn make_unique<ConstantExpression>(Value::DOUBLE(dbl_value));\n \t}\n \tcase duckdb_libpgquery::T_PGNull:\ndiff --git a/tools/pythonpkg/src/vector_conversion.cpp b/tools/pythonpkg/src/vector_conversion.cpp\nindex 66496fb1903a..b68041434244 100644\n--- a/tools/pythonpkg/src/vector_conversion.cpp\n+++ b/tools/pythonpkg/src/vector_conversion.cpp\n@@ -68,12 +68,12 @@ bool ValueIsNull(T value) {\n \n template <>\n bool ValueIsNull(float value) {\n-\treturn !Value::FloatIsValid(value);\n+\treturn !Value::FloatIsFinite(value);\n }\n \n template <>\n bool ValueIsNull(double value) {\n-\treturn !Value::DoubleIsValid(value);\n+\treturn !Value::DoubleIsFinite(value);\n }\n \n template <class T>\n",
  "test_patch": "diff --git a/src/function/table/system/test_all_types.cpp b/src/function/table/system/test_all_types.cpp\nindex cfb5213c0196..e51332d2b67f 100644\n--- a/src/function/table/system/test_all_types.cpp\n+++ b/src/function/table/system/test_all_types.cpp\n@@ -1,5 +1,7 @@\n #include \"duckdb/function/table/system_functions.hpp\"\n #include \"duckdb/common/pair.hpp\"\n+#include <cmath>\n+#include <limits>\n \n namespace duckdb {\n \n@@ -102,6 +104,13 @@ static vector<TestType> GetTestTypes() {\n \t                             Value(LogicalType::INTEGER), Value::INTEGER(-42)});\n \tresult.emplace_back(int_list_type, \"int_array\", empty_int_list, int_list);\n \n+\tauto double_list_type = LogicalType::LIST(LogicalType::DOUBLE);\n+\tauto empty_double_list = Value::EMPTYLIST(LogicalType::DOUBLE);\n+\tauto double_list = Value::LIST(\n+\t    {Value::DOUBLE(42), Value::DOUBLE(NAN), Value::DOUBLE(std::numeric_limits<double>::infinity()),\n+\t     Value::DOUBLE(-std::numeric_limits<double>::infinity()), Value(LogicalType::DOUBLE), Value::DOUBLE(-42)});\n+\tresult.emplace_back(double_list_type, \"double_array\", empty_double_list, double_list);\n+\n \tauto varchar_list_type = LogicalType::LIST(LogicalType::VARCHAR);\n \tauto empty_varchar_list = Value::EMPTYLIST(LogicalType::VARCHAR);\n \tauto varchar_list =\ndiff --git a/test/api/capi/test_capi_prepared.cpp b/test/api/capi/test_capi_prepared.cpp\nindex b20ab3b5bfa6..d55f4db8c0e7 100644\n--- a/test/api/capi/test_capi_prepared.cpp\n+++ b/test/api/capi/test_capi_prepared.cpp\n@@ -93,8 +93,15 @@ TEST_CASE(\"Test prepared statements in C API\", \"[capi]\") {\n \tREQUIRE(duckdb_value_int64(&res, 0, 0) == 43);\n \tduckdb_destroy_result(&res);\n \n-\tREQUIRE(duckdb_bind_float(stmt, 1, NAN) == DuckDBError);\n-\tREQUIRE(duckdb_bind_double(stmt, 1, NAN) == DuckDBError);\n+\tREQUIRE(duckdb_bind_float(stmt, 1, NAN) == DuckDBSuccess);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBError);\n+\tduckdb_destroy_result(&res);\n+\n+\tREQUIRE(duckdb_bind_double(stmt, 1, NAN) == DuckDBSuccess);\n+\tstatus = duckdb_execute_prepared(stmt, &res);\n+\tREQUIRE(status == DuckDBError);\n+\tduckdb_destroy_result(&res);\n \n \tREQUIRE(duckdb_bind_varchar(stmt, 1, \"\\x80\\x40\\x41\") == DuckDBError);\n \tduckdb_bind_varchar(stmt, 1, \"44\");\ndiff --git a/test/api/udf_function/udf_functions_to_test.hpp b/test/api/udf_function/udf_functions_to_test.hpp\nindex bccfb61564a3..39f2331fce98 100644\n--- a/test/api/udf_function/udf_functions_to_test.hpp\n+++ b/test/api/udf_function/udf_functions_to_test.hpp\n@@ -345,7 +345,7 @@ struct UDFAverageFunction {\n \ttemplate <class T, class STATE>\n \tstatic void Finalize(Vector &result, FunctionData *bind_data, STATE *state, T *target, ValidityMask &mask,\n \t                     idx_t idx) {\n-\t\tif (!Value::DoubleIsValid(double(state->sum))) {\n+\t\tif (!Value::DoubleIsFinite(double(state->sum))) {\n \t\t\tthrow OutOfRangeException(\"AVG is out of range!\");\n \t\t} else if (state->count == 0) {\n \t\t\tmask.SetInvalid(idx);\n@@ -589,7 +589,7 @@ struct UDFSum {\n \t\tif (!state->isset) {\n \t\t\tmask.SetInvalid(idx);\n \t\t} else {\n-\t\t\tif (!Value::DoubleIsValid(state->value)) {\n+\t\t\tif (!Value::DoubleIsFinite(state->value)) {\n \t\t\t\tthrow OutOfRangeException(\"SUM is out of range!\");\n \t\t\t}\n \t\t\ttarget[idx] = state->value;\ndiff --git a/test/appender/test_appender.cpp b/test/appender/test_appender.cpp\nindex 13379b16e35e..918d430d9245 100644\n--- a/test/appender/test_appender.cpp\n+++ b/test/appender/test_appender.cpp\n@@ -212,25 +212,22 @@ TEST_CASE(\"Test incorrect usage of appender\", \"[appender]\") {\n \t}\n }\n \n-TEST_CASE(\"Test invalid input for appender\", \"[appender]\") {\n+TEST_CASE(\"Test appending NaN and INF using appender\", \"[appender]\") {\n \tunique_ptr<QueryResult> result;\n \tDuckDB db(nullptr);\n \tConnection con(db);\n \n \tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE doubles(d DOUBLE, f REAL)\"));\n-\t{\n-\t\t// appending NAN or INF fails\n-\t\tAppender appender(con, \"doubles\");\n-\t\tappender.BeginRow();\n-\t\tREQUIRE_THROWS(appender.Append<double>(1e308 + 1e308));\n-\t}\n-\t{\n-\t\t// appending NAN or INF fails\n-\t\tAppender appender(con, \"doubles\");\n-\t\tappender.BeginRow();\n-\t\tappender.Append<double>(1);\n-\t\tREQUIRE_THROWS(appender.Append<float>(1e38f * 1e38f));\n-\t}\n+\n+\t// appending NAN or INF succeeds\n+\tAppender appender(con, \"doubles\");\n+\tappender.AppendRow(1e308 + 1e308, 1e38f * 1e38f);\n+\tappender.AppendRow(NAN, NAN);\n+\tappender.Close();\n+\n+\tresult = con.Query(\"SELECT * FROM doubles\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::DOUBLE(1e308 + 1e308), Value::DOUBLE(NAN)}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value::FLOAT(1e38f * 1e38f), Value::FLOAT(NAN)}));\n }\n \n TEST_CASE(\"Test appender with quotes\", \"[appender]\") {\ndiff --git a/test/arrow/parquet_test.cpp b/test/arrow/parquet_test.cpp\nindex 812086831dbe..68bdf6a81daf 100644\n--- a/test/arrow/parquet_test.cpp\n+++ b/test/arrow/parquet_test.cpp\n@@ -120,13 +120,12 @@ TEST_CASE(\"Test Parquet File NaN\", \"[arrow]\") {\n \tduckdb::DuckDB db;\n \tduckdb::Connection conn {db};\n \n-\t//! Impossible to round-trip NaNs so we just validate that the duckdb table is correct-o\n \tstd::string parquet_path = \"data/parquet-testing/nan-float.parquet\";\n \tauto table = ReadParquetFile(parquet_path);\n \n \tauto result = ArrowToDuck(conn, *table);\n \tREQUIRE(result->success);\n-\tREQUIRE(CHECK_COLUMN(result, 0, {-1, nullptr, 2.5}));\n+\tREQUIRE(CHECK_COLUMN(result, 0, {-1, std::numeric_limits<double>::infinity(), 2.5}));\n \tREQUIRE(CHECK_COLUMN(result, 1, {\"foo\", \"bar\", \"baz\"}));\n \tREQUIRE(CHECK_COLUMN(result, 2, {true, false, true}));\n }\ndiff --git a/test/issues/rigger/division_by_zero_null.test b/test/issues/rigger/division_by_zero_null.test\nindex b129ae8a1c1d..b330c95dacca 100644\n--- a/test/issues/rigger/division_by_zero_null.test\n+++ b/test/issues/rigger/division_by_zero_null.test\n@@ -50,17 +50,16 @@ COMMIT;\n query II\n SELECT c0, exp(c0) IS NULL FROM t1;\n ----\n-10000.0\t1\n-0.0\t0\n+10000.0\tfalse\n+0.0\tfalse\n \n query II\n SELECT c0, exp(c0) FROM t1;\n ----\n-10000.0\tNULL\n+10000.0\tinf\n 0.0\t1\n \n query I\n SELECT c0 FROM t1 WHERE exp(c0) IS NULL;\n ----\n-10000.0\n \ndiff --git a/test/issues/rigger/test_518.test b/test/issues/rigger/test_518.test\nindex e469af616577..4b069cb56aab 100644\n--- a/test/issues/rigger/test_518.test\n+++ b/test/issues/rigger/test_518.test\n@@ -18,15 +18,11 @@ INSERT INTO t0(c0) VALUES (0);\n statement ok\n INSERT INTO t1(c0) VALUES (0), (0), (1), (-1);\n \n-query R\n+statement error\n SELECT LN(t1.c0) FROM t0, t1 WHERE LN(t1.c0) < t0.c0;\n ----\n \n-query IR\n+statement error\n SELECT t1.c0, LN(t1.c0) FROM t1 ORDER BY t1.c0;\n-----\n--1\tNULL\n-0\tNULL\n-0\tNULL\n-1\t0.000000\n+\n \ndiff --git a/test/parquet/test_parquet_reader.test b/test/parquet/test_parquet_reader.test\nindex c60189b16787..fa24fbbd3ccd 100644\n--- a/test/parquet/test_parquet_reader.test\n+++ b/test/parquet/test_parquet_reader.test\n@@ -284,7 +284,7 @@ query III\n SELECT * FROM parquet_scan('data/parquet-testing/nan-float.parquet') limit 50;\n ----\n -1.0\tfoo\tTrue\t\n-NULL\tbar\tFalse\t\n+inf\tbar\tFalse\n 2.5\tbaz\tTrue\t\n \n query I\ndiff --git a/test/sql/aggregate/aggregates/test_kurtosis.test b/test/sql/aggregate/aggregates/test_kurtosis.test\nindex e628bbcea836..bf31ad256a5a 100644\n--- a/test/sql/aggregate/aggregates/test_kurtosis.test\n+++ b/test/sql/aggregate/aggregates/test_kurtosis.test\n@@ -24,10 +24,9 @@ select kurtosis(i) from (values (0), (0), (0), (0), (0), (0)) tbl(i)\n ----\n NULL\n \n-query I\n+# out of range\n+statement error\n select kurtosis(i) from (values (2e304), (2e305), (2e306), (2e307)) tbl(i)\n-----\n-NULL\n \n # Constant Value (This should be an error)\n query I\ndiff --git a/test/sql/aggregate/aggregates/test_skewness.test b/test/sql/aggregate/aggregates/test_skewness.test\nindex 638b469e6555..0df8834795ce 100644\n--- a/test/sql/aggregate/aggregates/test_skewness.test\n+++ b/test/sql/aggregate/aggregates/test_skewness.test\n@@ -31,10 +31,9 @@ select skewness (10) from range (5) where 1 == 0\n ----\n NULL\n \n-query I\n+# out of range\n+statement error\n select skewness(i) from (values (-2e307), (0), (2e307)) tbl(i)\n-----\n-NULL\n \n statement ok\n create table aggr(k int, v decimal(10,2), v2 decimal(10, 2));\ndiff --git a/test/sql/cast/double_float_cast.test b/test/sql/cast/double_float_cast.test\nindex 71563e1f53e8..bf4ea579638b 100644\n--- a/test/sql/cast/double_float_cast.test\n+++ b/test/sql/cast/double_float_cast.test\n@@ -8,8 +8,22 @@ PRAGMA enable_verification\n statement error\n select 1e308::float;\n \n-statement error\n+query I\n select '1e308'::float;\n+----\n+inf\n \n-statement error\n+query I\n select '1e310'::double;\n+----\n+inf\n+\n+query I\n+select '-1e308'::float;\n+----\n+-inf\n+\n+query I\n+select '-1e310'::double;\n+----\n+-inf\ndiff --git a/test/sql/copy/parquet/parquet_nan.test b/test/sql/copy/parquet/parquet_nan.test\nindex 4c0fc2382f8b..c98bdeccfb7a 100644\n--- a/test/sql/copy/parquet/parquet_nan.test\n+++ b/test/sql/copy/parquet/parquet_nan.test\n@@ -7,7 +7,7 @@ require parquet\n query TTT\n select * from parquet_scan('data/parquet-testing/nan-float.parquet') order by 1\n ----\n-NULL\tbar\t0\n -1\tfoo\t1\n 2.5\tbaz\t1\n+inf\tbar\t0\n \ndiff --git a/test/sql/function/numeric/test_gamma.test b/test/sql/function/numeric/test_gamma.test\nindex 291ef67dbdc3..f4632678d365 100644\n--- a/test/sql/function/numeric/test_gamma.test\n+++ b/test/sql/function/numeric/test_gamma.test\n@@ -10,15 +10,13 @@ SELECT gamma(NULL)\n ----\n NULL\n \n-query I\n+statement error\n SELECT gamma(0)\n-----\n-NULL\n \n query I\n SELECT gamma(-1)\n ----\n-NULL\n+nan\n \n query I\n SELECT gamma(1)\n@@ -59,20 +57,18 @@ SELECT lgamma(NULL)\n ----\n NULL\n \n-query I\n+statement error\n SELECT lgamma(0)\n-----\n-NULL\n \n query I\n SELECT lgamma(-1)\n ----\n-NULL\n+inf\n \n query I\n SELECT lgamma(-100)\n ----\n-NULL\n+inf\n \n query I\n SELECT lgamma(1)\ndiff --git a/test/sql/function/numeric/test_invalid_math.test b/test/sql/function/numeric/test_invalid_math.test\nindex eb7ec6bacb14..a9aca5df3b3a 100644\n--- a/test/sql/function/numeric/test_invalid_math.test\n+++ b/test/sql/function/numeric/test_invalid_math.test\n@@ -5,28 +5,45 @@\n statement ok\n PRAGMA enable_verification\n \n-query RR\n-SELECT SQRT(-1), SQRT(0)\n-----\n-NULL\t0.000000\n+# cannot take log of negative number or zero\n+statement error\n+SELECTl log(0);\n+\n+statement error\n+SELECTl log(-1);\n+\n+statement error\n+SELECTl ln(0);\n+\n+statement error\n+SELECTl ln(-1);\n \n-query RRRRRR\n-SELECT LN(-1), LN(0), LOG10(-1), LOG10(0), LOG2(-1), LOG2(0)\n+statement error\n+SELECTl log10(0);\n+\n+statement error\n+SELECTl log10(-1);\n+\n+# cannot take square root of a negative number\n+statement error\n+SELECTl sqrt(-1);\n+\n+query I\n+SELECT SQRT(0)\n ----\n-NULL\tNULL\tNULL\tNULL\tNULL\tNULL\n+0\n \n query RRR\n SELECT POW(1e300,100), POW(-1e300,100), POW(-1.0, 0.5)\n ----\n-NULL\tNULL\tNULL\n+inf\tinf\tnan\n \n query RR\n SELECT EXP(1e300), EXP(1e100)\n ----\n-NULL\tNULL\n+inf\tinf\n \n query RRR\n SELECT ACOS(3), ACOS(100), DEGREES(1e308)\n ----\n-NULL\tNULL\tNULL\n-\n+nan\tnan\tinf\ndiff --git a/test/sql/function/numeric/test_is_nan.test b/test/sql/function/numeric/test_is_nan.test\nnew file mode 100644\nindex 000000000000..e06faa5ac497\n--- /dev/null\n+++ b/test/sql/function/numeric/test_is_nan.test\n@@ -0,0 +1,33 @@\n+# name: test/sql/function/numeric/test_is_nan.test\n+# description: isnan test\n+# group: [numeric]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+foreach type FLOAT DOUBLE\n+\n+query III\n+SELECT isnan(3::${type}), isnan('nan'::${type}), isnan(NULL::${type})\n+----\n+false\ttrue\tNULL\n+\n+statement ok\n+CREATE TABLE floats(f ${type})\n+\n+statement ok\n+INSERT INTO floats VALUES (3), ('nan'), ('inf'), ('-inf'), (NULL)\n+\n+query IIII\n+SELECT f, isnan(f), isinf(f), isfinite(f) FROM floats ORDER BY f\n+----\n+NULL\tNULL\tNULL\tNULL\n+-inf\tFalse\tTrue\tFalse\n+3\tFalse\tFalse\tTrue\n+inf\tFalse\tTrue\tFalse\n+nan\tTrue\tFalse\tFalse\n+\n+statement ok\n+DROP TABLE floats\n+\n+endloop\ndiff --git a/test/sql/function/numeric/test_nextafter.test b/test/sql/function/numeric/test_nextafter.test\nindex 5fdeaca13b94..80b823456300 100644\n--- a/test/sql/function/numeric/test_nextafter.test\n+++ b/test/sql/function/numeric/test_nextafter.test\n@@ -11,17 +11,20 @@ select nextafter()\n statement error\n select nextafter('bla','bla')\n \n-statement error\n+query I\n select nextafter(NULL,1)\n+----\n+NULL\n \n-\n-statement error\n+query I\n select nextafter(1,NULL)\n+----\n+NULL\n \n-\n-statement error\n+query I\n select nextafter(99, 1)\n-\n+----\n+99\n \n query R\n select nextafter(99.0::DOUBLE, 1.0::DOUBLE) < 99\ndiff --git a/test/sql/overflow/test_numeric_overflow.test b/test/sql/overflow/test_numeric_overflow.test\nindex 977ee0e8b1c2..d50a1c73a976 100644\n--- a/test/sql/overflow/test_numeric_overflow.test\n+++ b/test/sql/overflow/test_numeric_overflow.test\n@@ -5,20 +5,31 @@\n statement ok\n PRAGMA enable_verification\n \n-# out of range constants are not accepted\n-statement error\n+query I\n SELECT 1e1000\n+----\n+inf\n \n # overflow on cast from double to real results in an error\n statement error\n SELECT 1e308::REAL\n \n+# except we can cast inf -> inf\n+query I\n+SELECT 1e1000::REAL\n+----\n+inf\n+\n # test string casts\n-statement error\n+query I\n SELECT '1e1000'::DOUBLE\n+----\n+inf\n \n-statement error\n+query I\n SELECT '1e100'::REAL\n+----\n+inf\n \n # overflow in SUM/AVG results in an error\n statement error\ndiff --git a/test/sql/storage_version/storage_version.db b/test/sql/storage_version/storage_version.db\nindex a6e148beadf4..b3b33d9ebf9d 100644\nBinary files a/test/sql/storage_version/storage_version.db and b/test/sql/storage_version/storage_version.db differ\ndiff --git a/test/sql/types/float/infinity_test.test b/test/sql/types/float/infinity_test.test\nnew file mode 100644\nindex 000000000000..c694faf11afc\n--- /dev/null\n+++ b/test/sql/types/float/infinity_test.test\n@@ -0,0 +1,159 @@\n+# name: test/sql/types/float/infinity_test.test\n+# description: Test usage of the INF value\n+# group: [float]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+foreach type FLOAT DOUBLE\n+\n+foreach key UNIQUE CHECK(1)\n+\n+# inf as a constant\n+query II\n+SELECT 'INF'::${type}, '-INF'::${type}\n+----\n+inf\t-inf\n+\n+# inf comparison\n+query I\n+select 'inf'::${type} == 'inf'::${type}\n+----\n+true\n+\n+query I\n+select 'inf'::${type} <> 'inf'::${type}\n+----\n+false\n+\n+query I\n+select 'inf'::${type} <> 3.0::${type}\n+----\n+true\n+\n+# storing inf in a table\n+statement ok\n+CREATE TABLE floats(f ${type} ${key});\n+\n+statement ok\n+INSERT INTO floats VALUES ('INF'), (1), ('-INF')\n+\n+query I\n+SELECT * FROM floats\n+----\n+inf\n+1\n+-inf\n+\n+# table filters on inf\n+# =\n+query I\n+SELECT f FROM floats WHERE f=1\n+----\n+1\n+\n+query I\n+SELECT f FROM floats WHERE f='inf'::${type}\n+----\n+inf\n+\n+query I\n+SELECT f FROM floats WHERE f='-inf'::${type}\n+----\n+-inf\n+\n+# <>\n+query I\n+SELECT f FROM floats WHERE f<>1 ORDER BY 1\n+----\n+-inf\n+inf\n+\n+query I\n+SELECT f FROM floats WHERE f<>'inf'::${type} ORDER BY 1\n+----\n+-inf\n+1\n+\n+query I\n+SELECT f FROM floats WHERE f<>'-inf'::${type} ORDER BY 1\n+----\n+1\n+inf\n+\n+# >\n+query I\n+SELECT f FROM floats WHERE f>1 ORDER BY 1\n+----\n+inf\n+\n+query I\n+SELECT f FROM floats WHERE f>'-inf'::${type} ORDER BY 1\n+----\n+1\n+inf\n+\n+query I\n+SELECT f FROM floats WHERE f>'inf'::${type}\n+----\n+\n+# >=\n+query I\n+SELECT f FROM floats WHERE f>=1 ORDER BY ALL\n+----\n+1\n+inf\n+\n+query I\n+SELECT f FROM floats WHERE f>='-inf'::${type} ORDER BY ALL\n+----\n+-inf\n+1\n+inf\n+\n+query I\n+SELECT f FROM floats WHERE f>='inf'::${type} ORDER BY ALL\n+----\n+inf\n+\n+# <\n+query I\n+SELECT f FROM floats WHERE f<1\n+----\n+-inf\n+\n+query I\n+SELECT f FROM floats WHERE f<'inf'::${type} ORDER BY ALL\n+----\n+-inf\n+1\n+\n+query I\n+SELECT f FROM floats WHERE f<'-inf'::${type} ORDER BY ALL\n+----\n+\n+# <=\n+query I\n+SELECT f FROM floats WHERE f<=1 ORDER BY ALL\n+----\n+-inf\n+1\n+\n+query I\n+SELECT f FROM floats WHERE f<='inf'::${type} ORDER BY ALL\n+----\n+-inf\n+1\n+inf\n+\n+query I\n+SELECT f FROM floats WHERE f<='-inf'::${type} ORDER BY ALL\n+----\n+-inf\n+\n+statement ok\n+DROP TABLE floats\n+\n+endloop\n+\n+endloop\ndiff --git a/test/sql/types/float/nan_aggregate.test b/test/sql/types/float/nan_aggregate.test\nnew file mode 100644\nindex 000000000000..9c59d5d6b561\n--- /dev/null\n+++ b/test/sql/types/float/nan_aggregate.test\n@@ -0,0 +1,27 @@\n+# name: test/sql/types/float/nan_aggregate.test\n+# description: Test NaN and inf as aggregate groups\n+# group: [float]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# grouping by inf and nan\n+foreach type FLOAT DOUBLE\n+\n+statement ok\n+create table floats(f ${type}, i int);\n+\n+statement ok\n+insert into floats values ('inf', 1), ('inf', 7), ('-inf', 3), ('nan', 7), ('nan', 19), ('-inf', 2)\n+\n+query II\n+SELECT f, SUM(i) FROM floats GROUP BY f ORDER BY f;\n+----\n+-inf\t5\n+inf\t8\n+nan\t26\n+\n+statement ok\n+DROP TABLE floats\n+\n+endloop\ndiff --git a/test/sql/types/float/nan_aggregates.test b/test/sql/types/float/nan_aggregates.test\nnew file mode 100644\nindex 000000000000..6c696fec1e83\n--- /dev/null\n+++ b/test/sql/types/float/nan_aggregates.test\n@@ -0,0 +1,37 @@\n+# name: test/sql/types/float/nan_aggregates.test\n+# description: Test aggregates on NaN values\n+# group: [float]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+foreach type FLOAT DOUBLE\n+\n+statement error\n+SELECT SUM('inf'::${type}), SUM('-inf'::${type}), SUM('nan'::${type})\n+\n+query III\n+SELECT MIN('inf'::${type}), MIN('-inf'::${type}), MIN('nan'::${type})\n+----\n+inf\t-inf\tnan\n+\n+query III\n+SELECT MAX('inf'::${type}), MAX('-inf'::${type}), MAX('nan'::${type})\n+----\n+inf\t-inf\tnan\n+\n+statement ok\n+create table floats(f ${type});\n+\n+statement ok\n+insert into floats values ('inf'), ('-inf'), ('nan');\n+\n+query II\n+SELECT MIN(f), MAX(f) FROM floats\n+----\n+-inf\tnan\n+\n+statement ok\n+DROP TABLE floats\n+\n+endloop\ndiff --git a/test/sql/types/float/nan_arithmetic.test b/test/sql/types/float/nan_arithmetic.test\nnew file mode 100644\nindex 000000000000..72ac976c8fc4\n--- /dev/null\n+++ b/test/sql/types/float/nan_arithmetic.test\n@@ -0,0 +1,33 @@\n+# name: test/sql/types/float/nan_arithmetic.test\n+# description: Test arithmetic on NaN values\n+# group: [float]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+foreach type FLOAT DOUBLE\n+\n+foreach val nan inf -inf\n+\n+# any arithmetic on a nan or inf value will result in an overflow\n+statement error\n+SELECT '${val}'::${type} + 1\n+\n+statement error\n+SELECT '${val}'::${type} - 1\n+\n+statement error\n+SELECT '${val}'::${type} * 1\n+\n+statement error\n+SELECT '${val}'::${type} / 1\n+\n+statement error\n+SELECT '${val}'::${type} % 1\n+\n+statement error\n+SELECT -('${val}'::${type})\n+\n+endloop\n+\n+endloop\ndiff --git a/test/sql/types/float/nan_cast.test b/test/sql/types/float/nan_cast.test\nnew file mode 100644\nindex 000000000000..b7bab32753d1\n--- /dev/null\n+++ b/test/sql/types/float/nan_cast.test\n@@ -0,0 +1,50 @@\n+# name: test/sql/types/float/nan_cast.test\n+# description: Test casting of NaN and inf values\n+# group: [float]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# to integer/decimal casts\n+foreach source_type FLOAT DOUBLE\n+\n+foreach target_type <integral> DECIMAL(4,1) DECIMAL(9,1) DECIMAL(18,1) DECIMAL(38,1)\n+\n+foreach val nan inf -inf\n+\n+statement ok\n+SELECT '${val}'::${source_type}\n+\n+# cannot cast nan, inf or -inf to these types\n+statement error\n+SELECT '${val}'::${source_type}::${target_type}\n+\n+endloop\n+\n+endloop\n+\n+endloop\n+\n+# we can cast nan, inf and -inf between floats and doubles, as well as to/from strings\n+foreach source_type FLOAT DOUBLE VARCHAR\n+\n+foreach target_type FLOAT DOUBLE VARCHAR\n+\n+query I\n+SELECT 'nan'::${source_type}::${target_type}\n+----\n+nan\n+\n+query I\n+SELECT 'inf'::${source_type}::${target_type}\n+----\n+inf\n+\n+query I\n+SELECT '-inf'::${source_type}::${target_type}\n+----\n+-inf\n+\n+endloop\n+\n+endloop\ndiff --git a/test/sql/types/float/nan_functions.test b/test/sql/types/float/nan_functions.test\nnew file mode 100644\nindex 000000000000..7009520a1b86\n--- /dev/null\n+++ b/test/sql/types/float/nan_functions.test\n@@ -0,0 +1,132 @@\n+# name: test/sql/types/float/nan_functions.test\n+# description: Test functions on NaN values\n+# group: [float]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+foreach type FLOAT DOUBLE\n+\n+# nextafter\n+query I\n+SELECT nextafter(3, '-inf'::${type})\n+----\n+3.0\n+\n+query I\n+SELECT nextafter(3, 'inf'::${type})\n+----\n+3.0\n+\n+query I\n+SELECT nextafter('inf'::${type}, 'inf'::${type})\n+----\n+inf\n+\n+query I\n+SELECT nextafter('-inf'::${type}, '-inf'::${type})\n+----\n+-inf\n+\n+\n+query I\n+SELECT nextafter('nan'::${type}, '-inf'::${type})\n+----\n+nan\n+\n+query I\n+SELECT nextafter(0, 'nan'::${type})\n+----\n+nan\n+\n+# sign\n+query I\n+SELECT sign('-inf'::${type})\n+----\n+-1\n+\n+query I\n+SELECT sign('inf'::${type})\n+----\n+1\n+\n+query I\n+SELECT sign('nan'::${type})\n+----\n+0\n+\n+# nop unary functions\n+foreach unary_func ceil floor round\n+\n+query I\n+SELECT ${unary_func}('-inf'::${type})\n+----\n+-inf\n+\n+query I\n+SELECT ${unary_func}('inf'::${type})\n+----\n+inf\n+\n+query I\n+SELECT ${unary_func}('nan'::${type})\n+----\n+nan\n+\n+endloop\n+\n+statement ok\n+create table floats(f ${type});\n+\n+statement ok\n+insert into floats values ('inf'), ('-inf'), ('nan');\n+\n+# several numeric functions\n+query IIIIIIIIIIIII\n+select f, abs(f), exp(f), pow(f, 2), sqrt(case when f < 0 then NULL else f end), cbrt(f), ln(case when f < 0 then NULL else f end), degrees(f), radians(f), gamma(f), lgamma(f), atan(f), atan2(f, 0)\n+from floats;\n+----\n+inf\tinf\tinf\tinf\tinf\tinf\tinf\tinf\tinf\tinf\tinf\t1.570796\t1.570796\n+-inf\tinf\t0.000000\tinf\tNULL\t-inf\tNULL\t-inf\t-inf\tnan\tinf\t-1.570796\t-1.570796\n+nan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\tnan\n+\n+# numeric functions that are undefined on infinity\n+foreach unary_func sin sin cos tan asin acos cot\n+\n+statement error\n+select ${unary_func}('inf'::${type})\n+\n+statement error\n+select ${unary_func}('-inf'::${type})\n+\n+query I\n+select ${unary_func}('nan'::${type})\n+----\n+nan\n+\n+endloop\n+\n+statement ok\n+drop table floats\n+\n+endloop\n+\n+query I\n+SELECT nextafter('inf'::float, '-inf'::float)\n+----\n+340282346638528859811704183484516925440.000000\n+\n+query I\n+SELECT nextafter('-inf'::float, 'inf'::float)\n+----\n+-340282346638528859811704183484516925440.000000\n+\n+query I\n+SELECT nextafter('inf'::double, '-inf'::double)\n+----\n+179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000\n+\n+query I\n+SELECT nextafter('-inf'::double, 'inf'::double)\n+----\n+-179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000\ndiff --git a/test/sql/types/float/nan_join.test b/test/sql/types/float/nan_join.test\nnew file mode 100644\nindex 000000000000..e427805b360b\n--- /dev/null\n+++ b/test/sql/types/float/nan_join.test\n@@ -0,0 +1,48 @@\n+# name: test/sql/types/float/nan_join.test\n+# description: Test NaN and inf joins\n+# group: [float]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# test various types of joins on nan and inf values\n+foreach type FLOAT DOUBLE\n+\n+statement ok\n+create table floats(f ${type});\n+\n+statement ok\n+insert into floats values ('inf'), ('-inf'), ('nan');\n+\n+query I\n+SELECT * FROM floats JOIN (SELECT 'inf'::${type}) tbl(f) USING (f)\n+----\n+inf\n+\n+query I\n+SELECT * FROM floats JOIN (SELECT '-inf'::${type}) tbl(f) USING (f)\n+----\n+-inf\n+\n+query II\n+SELECT * FROM floats JOIN (SELECT 'inf'::${type}) tbl(f) ON (floats.f >= tbl.f) ORDER BY 1\n+----\n+inf\tinf\n+nan\tinf\n+\n+query II\n+SELECT * FROM floats JOIN (SELECT 'inf'::${type}) tbl(f) ON (floats.f <= tbl.f) ORDER BY 1\n+----\n+-inf\tinf\n+inf\tinf\n+\n+query III\n+SELECT * FROM floats JOIN (SELECT '-inf'::${type}, 'inf'::${type}) tbl(f,g ) ON (floats.f >= tbl.f AND floats.f <= tbl.g) ORDER BY 1\n+----\n+-inf\t-inf\tinf\n+inf\t-inf\tinf\n+\n+statement ok\n+DROP TABLE floats\n+\n+endloop\ndiff --git a/test/sql/types/float/nan_ordering.test b/test/sql/types/float/nan_ordering.test\nnew file mode 100644\nindex 000000000000..fb51356d58bf\n--- /dev/null\n+++ b/test/sql/types/float/nan_ordering.test\n@@ -0,0 +1,91 @@\n+# name: test/sql/types/float/nan_ordering.test\n+# description: Test ordering of NaN and infinity values\n+# group: [float]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+foreach type FLOAT DOUBLE\n+\n+# storing nan in a table\n+statement ok\n+CREATE TABLE floats(f ${type});\n+\n+statement ok\n+INSERT INTO floats VALUES ('NAN'), (1), ('infinity'), ('-infinity'), (-1), (NULL)\n+\n+# standard ordering\n+query I\n+SELECT f FROM floats ORDER BY f\n+----\n+NULL\n+-inf\n+-1.000000\n+1.000000\n+inf\n+nan\n+\n+query I\n+SELECT f FROM floats ORDER BY f DESC\n+----\n+NULL\n+nan\n+inf\n+1.000000\n+-1.000000\n+-inf\n+\n+# top-n\n+query I\n+SELECT f FROM floats ORDER BY f DESC NULLS LAST LIMIT 2\n+----\n+nan\n+inf\n+\n+query I\n+SELECT f FROM floats ORDER BY f NULLS LAST LIMIT 2\n+----\n+-inf\n+-1.0\n+\n+# top-n with many rows\n+statement ok\n+INSERT INTO floats SELECT '0'::${type} FROM range(10000)\n+\n+statement ok\n+INSERT INTO floats VALUES ('nan'::${type})\n+\n+statement ok\n+INSERT INTO floats VALUES ('-inf'::${type})\n+\n+query I\n+SELECT f FROM floats ORDER BY f DESC NULLS LAST LIMIT 4\n+----\n+nan\n+nan\n+inf\n+1.0\n+\n+query I\n+SELECT f FROM floats ORDER BY f NULLS LAST LIMIT 4\n+----\n+-inf\n+-inf\n+-1.0\n+0.0\n+\n+# count with filters\n+query I\n+SELECT COUNT(*) FROM floats WHERE f > 0\n+----\n+4\n+\n+query I\n+SELECT COUNT(*) FROM floats WHERE f < 0\n+----\n+3\n+\n+statement ok\n+DROP TABLE floats\n+\n+endloop\ndiff --git a/test/sql/types/float/nan_test.test b/test/sql/types/float/nan_test.test\nnew file mode 100644\nindex 000000000000..efa40c0c7ddf\n--- /dev/null\n+++ b/test/sql/types/float/nan_test.test\n@@ -0,0 +1,122 @@\n+# name: test/sql/types/float/nan_test.test\n+# description: Test usage of the NAN value\n+# group: [float]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+foreach type FLOAT DOUBLE\n+\n+foreach key UNIQUE CHECK(1)\n+\n+# nan as a constant\n+query I\n+SELECT 'NAN'::${type}\n+----\n+nan\n+\n+# storing nan in a table\n+statement ok\n+CREATE TABLE floats(f ${type} ${key});\n+\n+statement ok\n+INSERT INTO floats VALUES ('NAN'), (1)\n+\n+query I\n+SELECT * FROM floats\n+----\n+nan\n+1\n+\n+# nan comparison\n+query I\n+select 'nan'::${type} == 'nan'::${type}\n+----\n+true\n+\n+query I\n+select 'nan'::${type} <> 'nan'::${type}\n+----\n+false\n+\n+query I\n+select 'nan'::${type} <> 3.0::${type}\n+----\n+true\n+\n+# table filters on nan\n+# note: for postgres compatibility, nan is equal to itself\n+# =\n+query I\n+SELECT f FROM floats WHERE f=1\n+----\n+1\n+\n+query I\n+SELECT f FROM floats WHERE f='nan'::${type}\n+----\n+nan\n+\n+# <>\n+query I\n+SELECT f FROM floats WHERE f<>1\n+----\n+nan\n+\n+query I\n+SELECT f FROM floats WHERE f<>'nan'::${type}\n+----\n+1\n+\n+# >\n+# for postgres compatibility, nan is bigger than everything\n+query I\n+SELECT f FROM floats WHERE f>0\n+----\n+nan\n+1\n+\n+query I\n+SELECT f FROM floats WHERE f>'nan'::${type}\n+----\n+\n+# >=\n+query I\n+SELECT f FROM floats WHERE f>=1\n+----\n+nan\n+1\n+\n+query I\n+SELECT f FROM floats WHERE f>='nan'::${type}\n+----\n+nan\n+\n+# <\n+query I\n+SELECT f FROM floats WHERE f<1\n+----\n+\n+query I\n+SELECT f FROM floats WHERE f<'nan'::${type}\n+----\n+1\n+\n+# <=\n+query I\n+SELECT f FROM floats WHERE f<=1\n+----\n+1\n+\n+query I\n+SELECT f FROM floats WHERE f<='nan'::${type}\n+----\n+nan\n+1\n+\n+statement ok\n+DROP TABLE floats\n+\n+endloop\n+\n+endloop\ndiff --git a/test/sql/types/float/nan_window.test b/test/sql/types/float/nan_window.test\nnew file mode 100644\nindex 000000000000..5ad8cbed0666\n--- /dev/null\n+++ b/test/sql/types/float/nan_window.test\n@@ -0,0 +1,62 @@\n+# name: test/sql/types/float/nan_window.test\n+# description: Test NaN and inf in windowing functions\n+# group: [float]\n+\n+require vector_size 512\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# grouping by inf and nan\n+foreach type FLOAT DOUBLE\n+\n+statement ok\n+create table floats(f ${type}, i int);\n+\n+statement ok\n+insert into floats values ('inf', 1), ('inf', 7), ('-inf', 3), ('nan', 7), ('nan', 19), ('-inf', 2)\n+\n+query II\n+SELECT f, SUM(i) OVER (PARTITION BY f) FROM floats ORDER BY f\n+----\n+-inf\t5\n+-inf\t5\n+inf\t8\n+inf\t8\n+nan\t26\n+nan\t26\n+\n+query III\n+SELECT f, i, SUM(i) OVER (ORDER BY f, i) FROM floats ORDER BY f, i\n+----\n+-inf\t2\t2\n+-inf\t3\t5\n+inf\t1\t6\n+inf\t7\t13\n+nan\t7\t20\n+nan\t19\t39\n+\n+query III\n+SELECT f, i, SUM(i) OVER (PARTITION BY f ORDER BY f, i) FROM floats ORDER BY f, i\n+----\n+-inf\t2\t2\n+-inf\t3\t5\n+inf\t1\t1\n+inf\t7\t8\n+nan\t7\t7\n+nan\t19\t26\n+\n+query III\n+SELECT i, f, SUM(i) OVER (ORDER BY i, f) FROM floats ORDER BY i, f\n+----\n+1\tinf\t1\n+2\t-inf\t3\n+3\t-inf\t6\n+7\tinf\t13\n+7\tnan\t20\n+19\tnan\t39\n+\n+statement ok\n+DROP TABLE floats\n+\n+endloop\ndiff --git a/test/sql/types/float/nested_nan.test b/test/sql/types/float/nested_nan.test\nnew file mode 100644\nindex 000000000000..42ace036c50c\n--- /dev/null\n+++ b/test/sql/types/float/nested_nan.test\n@@ -0,0 +1,26 @@\n+# name: test/sql/types/float/nested_nan.test\n+# description: Test nested nans\n+# group: [float]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+SELECT ['nan'::double]\n+----\n+[nan]\n+\n+query I\n+SELECT UNNEST(['nan'::double])\n+----\n+nan\n+\n+query I\n+SELECT {'a': 'nan'::double}\n+----\n+{'a': nan}\n+\n+query I\n+SELECT ({'a': 'nan'::double}).a\n+----\n+nan\ndiff --git a/test/sql/types/test_all_types.test b/test/sql/types/test_all_types.test\nindex e43094987f7b..6c7ee7f1fe25 100644\n--- a/test/sql/types/test_all_types.test\n+++ b/test/sql/types/test_all_types.test\n@@ -5,12 +5,12 @@\n statement ok\n PRAGMA enable_verification\n \n-query IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\n+query IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\n SELECT * FROM test_all_types();\n ----\n-False\t-128\t-32768\t-2147483648\t-9223372036854775808\t-170141183460469231731687303715884105727\t0\t0\t0\t0\t5877642-06-23 (BC)\t00:00:00\t290309-12-22 (BC) 00:00:00\t290309-12-22 (BC) 00:00:00\t290309-12-22 (BC) 00:00:00\t1677-09-21 00:12:43.145225\t00:00:00+00\t290309-12-22 (BC) 00:00:00+00\t-340282346638528859811704183484516925440.000000\t-179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000\t-999.9\t-99999.9999\t-999999999999.999999\t-9999999999999999999999999999.9999999999\t00000000-0000-0000-0000-000000000001\t00:00:00\t\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\t\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\tthisisalongblob\\x00withnullbytes\tDUCK_DUCK_ENUM\tenum_0\tenum_0\t[]\t[]\t[]\t{'a': NULL, 'b': NULL}\t{'a': NULL, 'b': NULL}\t[]\t{}\n-True\t127\t32767\t2147483647\t9223372036854775807\t170141183460469231731687303715884105727\t255\t65535\t4294967295\t18446744073709551615\t5881580-07-11\t23:59:59.999999\t294247-01-10 04:00:54.775807\t294247-01-10 04:00:54\t294247-01-10 04:00:54.775\t2262-04-11 23:47:16.854775\t23:59:59.999999+00\t294247-01-10 04:00:54.775807+00\t340282346638528859811704183484516925440.000000\t179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000\t999.9\t99999.9999\t999999999999.999999\t9999999999999999999999999999.9999999999\tffffffff-ffff-ffff-ffff-ffffffffffff\t83 years 3 months 999 days 00:16:39.999999\tgoose\tgoose\t\\x5Cx00\\x5Cx00\\x5Cx00a\tGOOSE\tenum_299\tenum_69999\t[42, 999, NULL, NULL, -42]\t[\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, goose, NULL, ]\t[[], [42, 999, NULL, NULL, -42], NULL, [], [42, 999, NULL, NULL, -42]]\t{'a': 42, 'b': \ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86}\t{'a': [42, 999, NULL, NULL, -42], 'b': [\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, goose, NULL, ]}\t[{'a': NULL, 'b': NULL}, {'a': 42, 'b': \ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86}, NULL]\t{key1=\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, key2=goose}\n-NULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\n+False\t-128\t-32768\t-2147483648\t-9223372036854775808\t-170141183460469231731687303715884105727\t0\t0\t0\t0\t5877642-06-23 (BC)\t00:00:00\t290309-12-22 (BC) 00:00:00\t290309-12-22 (BC) 00:00:00\t290309-12-22 (BC) 00:00:00\t1677-09-21 00:12:43.145225\t00:00:00+00\t290309-12-22 (BC) 00:00:00+00\t-340282346638528859811704183484516925440.000000\t-179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000\t-999.9\t-99999.9999\t-999999999999.999999\t-9999999999999999999999999999.9999999999\t00000000-0000-0000-0000-000000000001\t00:00:00\t\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\t\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\tthisisalongblob\\x00withnullbytes\tDUCK_DUCK_ENUM\tenum_0\tenum_0\t[]\t[]\t[]\t[]\t{'a': NULL, 'b': NULL}\t{'a': NULL, 'b': NULL}\t[]\t{}\n+True\t127\t32767\t2147483647\t9223372036854775807\t170141183460469231731687303715884105727\t255\t65535\t4294967295\t18446744073709551615\t5881580-07-11\t23:59:59.999999\t294247-01-10 04:00:54.775807\t294247-01-10 04:00:54\t294247-01-10 04:00:54.775\t2262-04-11 23:47:16.854775\t23:59:59.999999+00\t294247-01-10 04:00:54.775807+00\t340282346638528859811704183484516925440.000000\t179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000\t999.9\t99999.9999\t999999999999.999999\t9999999999999999999999999999.9999999999\tffffffff-ffff-ffff-ffff-ffffffffffff\t83 years 3 months 999 days 00:16:39.999999\tgoose\tgoose\t\\x5Cx00\\x5Cx00\\x5Cx00a\tGOOSE\tenum_299\tenum_69999\t[42, 999, NULL, NULL, -42]\t[42.000000, nan, inf, -inf, NULL, -42.000000]\t[\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, goose, NULL, ]\t[[], [42, 999, NULL, NULL, -42], NULL, [], [42, 999, NULL, NULL, -42]]\t{'a': 42, 'b': \ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86}\t{'a': [42, 999, NULL, NULL, -42], 'b': [\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, goose, NULL, ]}\t[{'a': NULL, 'b': NULL}, {'a': 42, 'b': \ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86}, NULL]\t{key1=\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86, key2=goose}\n+NULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\tNULL\n \n statement ok\n CREATE TABLE all_types AS SELECT * FROM test_all_types();\ndiff --git a/tools/juliapkg/test.sh b/tools/juliapkg/test.sh\nindex 73ba241fdb62..dc05bf5c876f 100755\n--- a/tools/juliapkg/test.sh\n+++ b/tools/juliapkg/test.sh\n@@ -2,7 +2,7 @@ set -e\n \n #julia -e \"import Pkg; Pkg.activate(\\\".\\\"); Pkg.instantiate(); include(\\\"test/runtests.jl\\\")\" $1\n \n-#export JULIA_DUCKDB_LIBRARY=\"/Users/myth/Programs/duckdb-bugfix/build/debug/src/libduckdb.dylib\"\n+export JULIA_DUCKDB_LIBRARY=\"`pwd`/../../build/debug/src/libduckdb.dylib\"\n #export JULIA_DUCKDB_LIBRARY=\"/Users/myth/Programs/duckdb-bugfix/build/release/src/libduckdb.dylib\"\n \n julia -e \"import Pkg; Pkg.activate(\\\".\\\"); include(\\\"test/runtests.jl\\\")\" $1\ndiff --git a/tools/juliapkg/test/test_all_types.jl b/tools/juliapkg/test/test_all_types.jl\nindex a2c2769ae645..909200325987 100644\n--- a/tools/juliapkg/test/test_all_types.jl\n+++ b/tools/juliapkg/test/test_all_types.jl\n@@ -113,6 +113,7 @@\n     )\n     @test isequal(df.uuid, [UUID(1), UUID(UInt128(340282366920938463463374607431768211455)), missing])\n     @test isequal(df.int_array, [[], [42, 999, missing, missing, -42], missing])\n+    @test isequal(df.double_array, [[], [42, NaN, Inf, -Inf, missing, -42], missing])\n     @test isequal(df.varchar_array, [[], [\"\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\", \"goose\", missing, \"\"], missing])\n     @test isequal(\n         df.nested_int_array,\ndiff --git a/tools/pythonpkg/tests/fast/sqlite/test_types.py b/tools/pythonpkg/tests/fast/sqlite/test_types.py\nindex 759e0ea5b12c..7e3d5611c97c 100644\n--- a/tools/pythonpkg/tests/fast/sqlite/test_types.py\n+++ b/tools/pythonpkg/tests/fast/sqlite/test_types.py\n@@ -74,12 +74,19 @@ def test_CheckDecimal(self):\n         self.assertEqual(row[0], val)\n \n     def test_CheckNaN(self):\n-        with self.assertRaises(RuntimeError) as context:\n-            self.cur.execute(\"insert into test(f) values (?)\", (decimal.Decimal('nan'),))\n+        import math\n+        val = decimal.Decimal('nan')\n+        self.cur.execute(\"insert into test(f) values (?)\", (val,))\n+        self.cur.execute(\"select f from test\")\n+        row = self.cur.fetchone()\n+        self.assertEqual(math.isnan(row[0]), True)\n \n     def test_CheckInf(self):\n-        with self.assertRaises(RuntimeError) as context:\n-            self.cur.execute(\"insert into test(f) values (?)\", (decimal.Decimal('inf'),))\n+        val = decimal.Decimal('inf')\n+        self.cur.execute(\"insert into test(f) values (?)\", (val,))\n+        self.cur.execute(\"select f from test\")\n+        row = self.cur.fetchone()\n+        self.assertEqual(row[0], val)\n \n     def test_CheckBytesBlob(self):\n         val = b\"Guglhupf\"\ndiff --git a/tools/pythonpkg/tests/fast/test_all_types.py b/tools/pythonpkg/tests/fast/test_all_types.py\nindex 929cdbae8c04..0aa2ae338a8f 100644\n--- a/tools/pythonpkg/tests/fast/test_all_types.py\n+++ b/tools/pythonpkg/tests/fast/test_all_types.py\n@@ -15,6 +15,25 @@ def get_all_types():\n \n all_types = get_all_types()\n \n+# we need to write our own equality function that considers nan==nan for testing purposes\n+def recursive_equality(o1, o2):\n+\timport math\n+\tif o1 == o2:\n+\t\treturn True\n+\tif type(o1) != type(o2):\n+\t\treturn False\n+\tif type(o1) == float and math.isnan(o1) and math.isnan(o2):\n+\t\treturn True\n+\ttry:\n+\t\tif len(o1) != len(o2):\n+\t\t\treturn False\n+\t\tfor i in range(len(o1)):\n+\t\t\tif not recursive_equality(o1[i], o2[i]):\n+\t\t\t\treturn False\n+\t\treturn True\n+\texcept:\n+\t\treturn False\n+\n class TestAllTypes(object):\n \tdef test_fetchall(self, duckdb_cursor):\n \t\tconn = duckdb.connect()\n@@ -41,12 +60,13 @@ def test_fetchall(self, duckdb_cursor):\n \t\t\t, 'varchar': [('\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86',), ('goose',), (None,)], 'json': [('\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86',), ('goose',), (None,)], 'blob': [(b'thisisalongblob\\x00withnullbytes',), (b'\\\\x00\\\\x00\\\\x00a',), (None,)]\n \t\t\t, 'small_enum':[('DUCK_DUCK_ENUM',), ('GOOSE',), (None,)], 'medium_enum': [('enum_0',), ('enum_299',), (None,)], 'large_enum': [('enum_0',), ('enum_69999',), (None,)]\n \t\t\t, 'int_array': [([],), ([42, 999, None, None, -42],), (None,)], 'varchar_array': [([],), (['\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86', 'goose', None, ''],), (None,)]\n+\t\t\t, 'double_array': [([],), ([42.0, float('nan'), float('inf'), float('-inf'), None, -42.0],), (None,)]\n \t\t\t, 'nested_int_array': [([],), ([[], [42, 999, None, None, -42], None, [], [42, 999, None, None, -42]],), (None,)], 'struct': [({'a': None, 'b': None},), ({'a': 42, 'b': '\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86'},), (None,)]\n \t\t\t, 'struct_of_arrays': [({'a': None, 'b': None},), ({'a': [42, 999, None, None, -42], 'b': ['\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86', 'goose', None, '']},), (None,)]\n \t\t\t, 'array_of_structs': [([],), ([{'a': None, 'b': None}, {'a': 42, 'b': '\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86'}, None],), (None,)], 'map':[({'key': [], 'value': []},), ({'key': ['key1', 'key2'], 'value': ['\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86\ud83e\udd86', 'goose']},), (None,)]\n \t\t\t, 'time_tz':[(datetime.time(0, 0),), (datetime.time(23, 59, 59, 999999),), (None,)], 'interval': [(datetime.timedelta(0),), (datetime.timedelta(days=30969, seconds=999, microseconds=999999),), (None,)]\n \t\t\t, 'timestamp':[(datetime.datetime(1990, 1, 1, 0, 0),)], 'date':[(datetime.date(1990, 1, 1),)], 'timestamp_s':[(datetime.datetime(1990, 1, 1, 0, 0),)]\n-\t\t\t, 'timestamp_ns':[(datetime.datetime(1990, 1, 1, 0, 0),)], 'timestamp_ms':[(datetime.datetime(1990, 1, 1, 0, 0),)], 'timestamp_tz':[(datetime.datetime(1990, 1, 1, 0, 0),)]}\n+\t\t\t, 'timestamp_ns':[(datetime.datetime(1990, 1, 1, 0, 0),)], 'timestamp_ms':[(datetime.datetime(1990, 1, 1, 0, 0),)], 'timestamp_tz':[(datetime.datetime(1990, 1, 1, 0, 0),)],}\n \n \t\tfor cur_type in all_types:\n \t\t\tif cur_type in replacement_values:\n@@ -54,7 +74,7 @@ def test_fetchall(self, duckdb_cursor):\n \t\t\telse:\n \t\t\t\tresult = conn.execute(\"select \"+cur_type+\" from test_all_types()\").fetchall()\n \t\t\tcorrect_result = correct_answer_map[cur_type]\n-\t\t\tassert result == correct_result\n+\t\t\tassert recursive_equality(result, correct_result)\n \n \tdef test_arrow(self, duckdb_cursor):\n \t\ttry:\n@@ -64,7 +84,7 @@ def test_arrow(self, duckdb_cursor):\n \t\t# We skip those since the extreme ranges are not supported in arrow.\n \t\treplacement_values = {'interval': \"INTERVAL '2 years'\"}\n \t\t# We do not round trip enum types\n-\t\tenum_types = {'small_enum', 'medium_enum', 'large_enum'}\n+\t\tenum_types = {'small_enum', 'medium_enum', 'large_enum', 'double_array'}\n \t\tconn = duckdb.connect()\n \t\tfor cur_type in all_types:\n \t\t\tif cur_type in replacement_values:\n@@ -75,7 +95,7 @@ def test_arrow(self, duckdb_cursor):\n \t\t\t\tround_trip_arrow_table = conn.execute(\"select * from arrow_table\").arrow()\n \t\t\t\tresult_arrow = conn.execute(\"select * from arrow_table\").fetchall()\n \t\t\t\tresult_roundtrip = conn.execute(\"select * from round_trip_arrow_table\").fetchall()\n-\t\t\t\tassert result_arrow == result_roundtrip\n+\t\t\t\tassert recursive_equality(result_arrow, result_roundtrip)\n \t\t\telse:\n \t\t\t\tround_trip_arrow_table = conn.execute(\"select * from arrow_table\").arrow()\n \t\t\t\tassert arrow_table.equals(round_trip_arrow_table, check_metadata=True)\n@@ -98,4 +118,4 @@ def test_pandas(self, duckdb_cursor):\n \t\t\tround_trip_dataframe = conn.execute(\"select * from dataframe\").df()\n \t\t\tresult_dataframe = conn.execute(\"select * from dataframe\").fetchall()\n \t\t\tresult_roundtrip = conn.execute(\"select * from round_trip_dataframe\").fetchall()\n-\t\t\tassert result_dataframe == result_roundtrip\n+\t\t\tassert recursive_equality(result_dataframe, result_roundtrip)\n",
  "problem_statement": "Support NaN and Infinity in floating point columns\nAfter some discussion we want to remove the restriction we have on floating point columns where NaN and infinity values are not allowed (#530).\n",
  "hints_text": "",
  "created_at": "2022-03-24T22:01:38Z"
}