diff --git a/src/function/table/system/test_all_types.cpp b/src/function/table/system/test_all_types.cpp
index cfb5213c0196..e51332d2b67f 100644
--- a/src/function/table/system/test_all_types.cpp
+++ b/src/function/table/system/test_all_types.cpp
@@ -1,5 +1,7 @@
 #include "duckdb/function/table/system_functions.hpp"
 #include "duckdb/common/pair.hpp"
+#include <cmath>
+#include <limits>
 
 namespace duckdb {
 
@@ -102,6 +104,13 @@ static vector<TestType> GetTestTypes() {
 	                             Value(LogicalType::INTEGER), Value::INTEGER(-42)});
 	result.emplace_back(int_list_type, "int_array", empty_int_list, int_list);
 
+	auto double_list_type = LogicalType::LIST(LogicalType::DOUBLE);
+	auto empty_double_list = Value::EMPTYLIST(LogicalType::DOUBLE);
+	auto double_list = Value::LIST(
+	    {Value::DOUBLE(42), Value::DOUBLE(NAN), Value::DOUBLE(std::numeric_limits<double>::infinity()),
+	     Value::DOUBLE(-std::numeric_limits<double>::infinity()), Value(LogicalType::DOUBLE), Value::DOUBLE(-42)});
+	result.emplace_back(double_list_type, "double_array", empty_double_list, double_list);
+
 	auto varchar_list_type = LogicalType::LIST(LogicalType::VARCHAR);
 	auto empty_varchar_list = Value::EMPTYLIST(LogicalType::VARCHAR);
 	auto varchar_list =
diff --git a/test/api/capi/test_capi_prepared.cpp b/test/api/capi/test_capi_prepared.cpp
index b20ab3b5bfa6..d55f4db8c0e7 100644
--- a/test/api/capi/test_capi_prepared.cpp
+++ b/test/api/capi/test_capi_prepared.cpp
@@ -93,8 +93,15 @@ TEST_CASE("Test prepared statements in C API", "[capi]") {
 	REQUIRE(duckdb_value_int64(&res, 0, 0) == 43);
 	duckdb_destroy_result(&res);
 
-	REQUIRE(duckdb_bind_float(stmt, 1, NAN) == DuckDBError);
-	REQUIRE(duckdb_bind_double(stmt, 1, NAN) == DuckDBError);
+	REQUIRE(duckdb_bind_float(stmt, 1, NAN) == DuckDBSuccess);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBError);
+	duckdb_destroy_result(&res);
+
+	REQUIRE(duckdb_bind_double(stmt, 1, NAN) == DuckDBSuccess);
+	status = duckdb_execute_prepared(stmt, &res);
+	REQUIRE(status == DuckDBError);
+	duckdb_destroy_result(&res);
 
 	REQUIRE(duckdb_bind_varchar(stmt, 1, "\x80\x40\x41") == DuckDBError);
 	duckdb_bind_varchar(stmt, 1, "44");
diff --git a/test/api/udf_function/udf_functions_to_test.hpp b/test/api/udf_function/udf_functions_to_test.hpp
index bccfb61564a3..39f2331fce98 100644
--- a/test/api/udf_function/udf_functions_to_test.hpp
+++ b/test/api/udf_function/udf_functions_to_test.hpp
@@ -345,7 +345,7 @@ struct UDFAverageFunction {
 	template <class T, class STATE>
 	static void Finalize(Vector &result, FunctionData *bind_data, STATE *state, T *target, ValidityMask &mask,
 	                     idx_t idx) {
-		if (!Value::DoubleIsValid(double(state->sum))) {
+		if (!Value::DoubleIsFinite(double(state->sum))) {
 			throw OutOfRangeException("AVG is out of range!");
 		} else if (state->count == 0) {
 			mask.SetInvalid(idx);
@@ -589,7 +589,7 @@ struct UDFSum {
 		if (!state->isset) {
 			mask.SetInvalid(idx);
 		} else {
-			if (!Value::DoubleIsValid(state->value)) {
+			if (!Value::DoubleIsFinite(state->value)) {
 				throw OutOfRangeException("SUM is out of range!");
 			}
 			target[idx] = state->value;
diff --git a/test/appender/test_appender.cpp b/test/appender/test_appender.cpp
index 13379b16e35e..918d430d9245 100644
--- a/test/appender/test_appender.cpp
+++ b/test/appender/test_appender.cpp
@@ -212,25 +212,22 @@ TEST_CASE("Test incorrect usage of appender", "[appender]") {
 	}
 }
 
-TEST_CASE("Test invalid input for appender", "[appender]") {
+TEST_CASE("Test appending NaN and INF using appender", "[appender]") {
 	unique_ptr<QueryResult> result;
 	DuckDB db(nullptr);
 	Connection con(db);
 
 	REQUIRE_NO_FAIL(con.Query("CREATE TABLE doubles(d DOUBLE, f REAL)"));
-	{
-		// appending NAN or INF fails
-		Appender appender(con, "doubles");
-		appender.BeginRow();
-		REQUIRE_THROWS(appender.Append<double>(1e308 + 1e308));
-	}
-	{
-		// appending NAN or INF fails
-		Appender appender(con, "doubles");
-		appender.BeginRow();
-		appender.Append<double>(1);
-		REQUIRE_THROWS(appender.Append<float>(1e38f * 1e38f));
-	}
+
+	// appending NAN or INF succeeds
+	Appender appender(con, "doubles");
+	appender.AppendRow(1e308 + 1e308, 1e38f * 1e38f);
+	appender.AppendRow(NAN, NAN);
+	appender.Close();
+
+	result = con.Query("SELECT * FROM doubles");
+	REQUIRE(CHECK_COLUMN(result, 0, {Value::DOUBLE(1e308 + 1e308), Value::DOUBLE(NAN)}));
+	REQUIRE(CHECK_COLUMN(result, 1, {Value::FLOAT(1e38f * 1e38f), Value::FLOAT(NAN)}));
 }
 
 TEST_CASE("Test appender with quotes", "[appender]") {
diff --git a/test/arrow/parquet_test.cpp b/test/arrow/parquet_test.cpp
index 812086831dbe..68bdf6a81daf 100644
--- a/test/arrow/parquet_test.cpp
+++ b/test/arrow/parquet_test.cpp
@@ -120,13 +120,12 @@ TEST_CASE("Test Parquet File NaN", "[arrow]") {
 	duckdb::DuckDB db;
 	duckdb::Connection conn {db};
 
-	//! Impossible to round-trip NaNs so we just validate that the duckdb table is correct-o
 	std::string parquet_path = "data/parquet-testing/nan-float.parquet";
 	auto table = ReadParquetFile(parquet_path);
 
 	auto result = ArrowToDuck(conn, *table);
 	REQUIRE(result->success);
-	REQUIRE(CHECK_COLUMN(result, 0, {-1, nullptr, 2.5}));
+	REQUIRE(CHECK_COLUMN(result, 0, {-1, std::numeric_limits<double>::infinity(), 2.5}));
 	REQUIRE(CHECK_COLUMN(result, 1, {"foo", "bar", "baz"}));
 	REQUIRE(CHECK_COLUMN(result, 2, {true, false, true}));
 }
diff --git a/test/issues/rigger/division_by_zero_null.test b/test/issues/rigger/division_by_zero_null.test
index b129ae8a1c1d..b330c95dacca 100644
--- a/test/issues/rigger/division_by_zero_null.test
+++ b/test/issues/rigger/division_by_zero_null.test
@@ -50,17 +50,16 @@ COMMIT;
 query II
 SELECT c0, exp(c0) IS NULL FROM t1;
 ----
-10000.0	1
-0.0	0
+10000.0	false
+0.0	false
 
 query II
 SELECT c0, exp(c0) FROM t1;
 ----
-10000.0	NULL
+10000.0	inf
 0.0	1
 
 query I
 SELECT c0 FROM t1 WHERE exp(c0) IS NULL;
 ----
-10000.0
 
diff --git a/test/issues/rigger/test_518.test b/test/issues/rigger/test_518.test
index e469af616577..4b069cb56aab 100644
--- a/test/issues/rigger/test_518.test
+++ b/test/issues/rigger/test_518.test
@@ -18,15 +18,11 @@ INSERT INTO t0(c0) VALUES (0);
 statement ok
 INSERT INTO t1(c0) VALUES (0), (0), (1), (-1);
 
-query R
+statement error
 SELECT LN(t1.c0) FROM t0, t1 WHERE LN(t1.c0) < t0.c0;
 ----
 
-query IR
+statement error
 SELECT t1.c0, LN(t1.c0) FROM t1 ORDER BY t1.c0;
-----
--1	NULL
-0	NULL
-0	NULL
-1	0.000000
+
 
diff --git a/test/parquet/test_parquet_reader.test b/test/parquet/test_parquet_reader.test
index c60189b16787..fa24fbbd3ccd 100644
--- a/test/parquet/test_parquet_reader.test
+++ b/test/parquet/test_parquet_reader.test
@@ -284,7 +284,7 @@ query III
 SELECT * FROM parquet_scan('data/parquet-testing/nan-float.parquet') limit 50;
 ----
 -1.0	foo	True	
-NULL	bar	False	
+inf	bar	False
 2.5	baz	True	
 
 query I
diff --git a/test/sql/aggregate/aggregates/test_kurtosis.test b/test/sql/aggregate/aggregates/test_kurtosis.test
index e628bbcea836..bf31ad256a5a 100644
--- a/test/sql/aggregate/aggregates/test_kurtosis.test
+++ b/test/sql/aggregate/aggregates/test_kurtosis.test
@@ -24,10 +24,9 @@ select kurtosis(i) from (values (0), (0), (0), (0), (0), (0)) tbl(i)
 ----
 NULL
 
-query I
+# out of range
+statement error
 select kurtosis(i) from (values (2e304), (2e305), (2e306), (2e307)) tbl(i)
-----
-NULL
 
 # Constant Value (This should be an error)
 query I
diff --git a/test/sql/aggregate/aggregates/test_skewness.test b/test/sql/aggregate/aggregates/test_skewness.test
index 638b469e6555..0df8834795ce 100644
--- a/test/sql/aggregate/aggregates/test_skewness.test
+++ b/test/sql/aggregate/aggregates/test_skewness.test
@@ -31,10 +31,9 @@ select skewness (10) from range (5) where 1 == 0
 ----
 NULL
 
-query I
+# out of range
+statement error
 select skewness(i) from (values (-2e307), (0), (2e307)) tbl(i)
-----
-NULL
 
 statement ok
 create table aggr(k int, v decimal(10,2), v2 decimal(10, 2));
diff --git a/test/sql/cast/double_float_cast.test b/test/sql/cast/double_float_cast.test
index 71563e1f53e8..bf4ea579638b 100644
--- a/test/sql/cast/double_float_cast.test
+++ b/test/sql/cast/double_float_cast.test
@@ -8,8 +8,22 @@ PRAGMA enable_verification
 statement error
 select 1e308::float;
 
-statement error
+query I
 select '1e308'::float;
+----
+inf
 
-statement error
+query I
 select '1e310'::double;
+----
+inf
+
+query I
+select '-1e308'::float;
+----
+-inf
+
+query I
+select '-1e310'::double;
+----
+-inf
diff --git a/test/sql/copy/parquet/parquet_nan.test b/test/sql/copy/parquet/parquet_nan.test
index 4c0fc2382f8b..c98bdeccfb7a 100644
--- a/test/sql/copy/parquet/parquet_nan.test
+++ b/test/sql/copy/parquet/parquet_nan.test
@@ -7,7 +7,7 @@ require parquet
 query TTT
 select * from parquet_scan('data/parquet-testing/nan-float.parquet') order by 1
 ----
-NULL	bar	0
 -1	foo	1
 2.5	baz	1
+inf	bar	0
 
diff --git a/test/sql/function/numeric/test_gamma.test b/test/sql/function/numeric/test_gamma.test
index 291ef67dbdc3..f4632678d365 100644
--- a/test/sql/function/numeric/test_gamma.test
+++ b/test/sql/function/numeric/test_gamma.test
@@ -10,15 +10,13 @@ SELECT gamma(NULL)
 ----
 NULL
 
-query I
+statement error
 SELECT gamma(0)
-----
-NULL
 
 query I
 SELECT gamma(-1)
 ----
-NULL
+nan
 
 query I
 SELECT gamma(1)
@@ -59,20 +57,18 @@ SELECT lgamma(NULL)
 ----
 NULL
 
-query I
+statement error
 SELECT lgamma(0)
-----
-NULL
 
 query I
 SELECT lgamma(-1)
 ----
-NULL
+inf
 
 query I
 SELECT lgamma(-100)
 ----
-NULL
+inf
 
 query I
 SELECT lgamma(1)
diff --git a/test/sql/function/numeric/test_invalid_math.test b/test/sql/function/numeric/test_invalid_math.test
index eb7ec6bacb14..a9aca5df3b3a 100644
--- a/test/sql/function/numeric/test_invalid_math.test
+++ b/test/sql/function/numeric/test_invalid_math.test
@@ -5,28 +5,45 @@
 statement ok
 PRAGMA enable_verification
 
-query RR
-SELECT SQRT(-1), SQRT(0)
-----
-NULL	0.000000
+# cannot take log of negative number or zero
+statement error
+SELECTl log(0);
+
+statement error
+SELECTl log(-1);
+
+statement error
+SELECTl ln(0);
+
+statement error
+SELECTl ln(-1);
 
-query RRRRRR
-SELECT LN(-1), LN(0), LOG10(-1), LOG10(0), LOG2(-1), LOG2(0)
+statement error
+SELECTl log10(0);
+
+statement error
+SELECTl log10(-1);
+
+# cannot take square root of a negative number
+statement error
+SELECTl sqrt(-1);
+
+query I
+SELECT SQRT(0)
 ----
-NULL	NULL	NULL	NULL	NULL	NULL
+0
 
 query RRR
 SELECT POW(1e300,100), POW(-1e300,100), POW(-1.0, 0.5)
 ----
-NULL	NULL	NULL
+inf	inf	nan
 
 query RR
 SELECT EXP(1e300), EXP(1e100)
 ----
-NULL	NULL
+inf	inf
 
 query RRR
 SELECT ACOS(3), ACOS(100), DEGREES(1e308)
 ----
-NULL	NULL	NULL
-
+nan	nan	inf
diff --git a/test/sql/function/numeric/test_is_nan.test b/test/sql/function/numeric/test_is_nan.test
new file mode 100644
index 000000000000..e06faa5ac497
--- /dev/null
+++ b/test/sql/function/numeric/test_is_nan.test
@@ -0,0 +1,33 @@
+# name: test/sql/function/numeric/test_is_nan.test
+# description: isnan test
+# group: [numeric]
+
+statement ok
+PRAGMA enable_verification
+
+foreach type FLOAT DOUBLE
+
+query III
+SELECT isnan(3::${type}), isnan('nan'::${type}), isnan(NULL::${type})
+----
+false	true	NULL
+
+statement ok
+CREATE TABLE floats(f ${type})
+
+statement ok
+INSERT INTO floats VALUES (3), ('nan'), ('inf'), ('-inf'), (NULL)
+
+query IIII
+SELECT f, isnan(f), isinf(f), isfinite(f) FROM floats ORDER BY f
+----
+NULL	NULL	NULL	NULL
+-inf	False	True	False
+3	False	False	True
+inf	False	True	False
+nan	True	False	False
+
+statement ok
+DROP TABLE floats
+
+endloop
diff --git a/test/sql/function/numeric/test_nextafter.test b/test/sql/function/numeric/test_nextafter.test
index 5fdeaca13b94..80b823456300 100644
--- a/test/sql/function/numeric/test_nextafter.test
+++ b/test/sql/function/numeric/test_nextafter.test
@@ -11,17 +11,20 @@ select nextafter()
 statement error
 select nextafter('bla','bla')
 
-statement error
+query I
 select nextafter(NULL,1)
+----
+NULL
 
-
-statement error
+query I
 select nextafter(1,NULL)
+----
+NULL
 
-
-statement error
+query I
 select nextafter(99, 1)
-
+----
+99
 
 query R
 select nextafter(99.0::DOUBLE, 1.0::DOUBLE) < 99
diff --git a/test/sql/overflow/test_numeric_overflow.test b/test/sql/overflow/test_numeric_overflow.test
index 977ee0e8b1c2..d50a1c73a976 100644
--- a/test/sql/overflow/test_numeric_overflow.test
+++ b/test/sql/overflow/test_numeric_overflow.test
@@ -5,20 +5,31 @@
 statement ok
 PRAGMA enable_verification
 
-# out of range constants are not accepted
-statement error
+query I
 SELECT 1e1000
+----
+inf
 
 # overflow on cast from double to real results in an error
 statement error
 SELECT 1e308::REAL
 
+# except we can cast inf -> inf
+query I
+SELECT 1e1000::REAL
+----
+inf
+
 # test string casts
-statement error
+query I
 SELECT '1e1000'::DOUBLE
+----
+inf
 
-statement error
+query I
 SELECT '1e100'::REAL
+----
+inf
 
 # overflow in SUM/AVG results in an error
 statement error
diff --git a/test/sql/storage_version/storage_version.db b/test/sql/storage_version/storage_version.db
index a6e148beadf4..b3b33d9ebf9d 100644
Binary files a/test/sql/storage_version/storage_version.db and b/test/sql/storage_version/storage_version.db differ
diff --git a/test/sql/types/float/infinity_test.test b/test/sql/types/float/infinity_test.test
new file mode 100644
index 000000000000..c694faf11afc
--- /dev/null
+++ b/test/sql/types/float/infinity_test.test
@@ -0,0 +1,159 @@
+# name: test/sql/types/float/infinity_test.test
+# description: Test usage of the INF value
+# group: [float]
+
+statement ok
+PRAGMA enable_verification
+
+foreach type FLOAT DOUBLE
+
+foreach key UNIQUE CHECK(1)
+
+# inf as a constant
+query II
+SELECT 'INF'::${type}, '-INF'::${type}
+----
+inf	-inf
+
+# inf comparison
+query I
+select 'inf'::${type} == 'inf'::${type}
+----
+true
+
+query I
+select 'inf'::${type} <> 'inf'::${type}
+----
+false
+
+query I
+select 'inf'::${type} <> 3.0::${type}
+----
+true
+
+# storing inf in a table
+statement ok
+CREATE TABLE floats(f ${type} ${key});
+
+statement ok
+INSERT INTO floats VALUES ('INF'), (1), ('-INF')
+
+query I
+SELECT * FROM floats
+----
+inf
+1
+-inf
+
+# table filters on inf
+# =
+query I
+SELECT f FROM floats WHERE f=1
+----
+1
+
+query I
+SELECT f FROM floats WHERE f='inf'::${type}
+----
+inf
+
+query I
+SELECT f FROM floats WHERE f='-inf'::${type}
+----
+-inf
+
+# <>
+query I
+SELECT f FROM floats WHERE f<>1 ORDER BY 1
+----
+-inf
+inf
+
+query I
+SELECT f FROM floats WHERE f<>'inf'::${type} ORDER BY 1
+----
+-inf
+1
+
+query I
+SELECT f FROM floats WHERE f<>'-inf'::${type} ORDER BY 1
+----
+1
+inf
+
+# >
+query I
+SELECT f FROM floats WHERE f>1 ORDER BY 1
+----
+inf
+
+query I
+SELECT f FROM floats WHERE f>'-inf'::${type} ORDER BY 1
+----
+1
+inf
+
+query I
+SELECT f FROM floats WHERE f>'inf'::${type}
+----
+
+# >=
+query I
+SELECT f FROM floats WHERE f>=1 ORDER BY ALL
+----
+1
+inf
+
+query I
+SELECT f FROM floats WHERE f>='-inf'::${type} ORDER BY ALL
+----
+-inf
+1
+inf
+
+query I
+SELECT f FROM floats WHERE f>='inf'::${type} ORDER BY ALL
+----
+inf
+
+# <
+query I
+SELECT f FROM floats WHERE f<1
+----
+-inf
+
+query I
+SELECT f FROM floats WHERE f<'inf'::${type} ORDER BY ALL
+----
+-inf
+1
+
+query I
+SELECT f FROM floats WHERE f<'-inf'::${type} ORDER BY ALL
+----
+
+# <=
+query I
+SELECT f FROM floats WHERE f<=1 ORDER BY ALL
+----
+-inf
+1
+
+query I
+SELECT f FROM floats WHERE f<='inf'::${type} ORDER BY ALL
+----
+-inf
+1
+inf
+
+query I
+SELECT f FROM floats WHERE f<='-inf'::${type} ORDER BY ALL
+----
+-inf
+
+statement ok
+DROP TABLE floats
+
+endloop
+
+endloop
diff --git a/test/sql/types/float/nan_aggregate.test b/test/sql/types/float/nan_aggregate.test
new file mode 100644
index 000000000000..9c59d5d6b561
--- /dev/null
+++ b/test/sql/types/float/nan_aggregate.test
@@ -0,0 +1,27 @@
+# name: test/sql/types/float/nan_aggregate.test
+# description: Test NaN and inf as aggregate groups
+# group: [float]
+
+statement ok
+PRAGMA enable_verification
+
+# grouping by inf and nan
+foreach type FLOAT DOUBLE
+
+statement ok
+create table floats(f ${type}, i int);
+
+statement ok
+insert into floats values ('inf', 1), ('inf', 7), ('-inf', 3), ('nan', 7), ('nan', 19), ('-inf', 2)
+
+query II
+SELECT f, SUM(i) FROM floats GROUP BY f ORDER BY f;
+----
+-inf	5
+inf	8
+nan	26
+
+statement ok
+DROP TABLE floats
+
+endloop
diff --git a/test/sql/types/float/nan_aggregates.test b/test/sql/types/float/nan_aggregates.test
new file mode 100644
index 000000000000..6c696fec1e83
--- /dev/null
+++ b/test/sql/types/float/nan_aggregates.test
@@ -0,0 +1,37 @@
+# name: test/sql/types/float/nan_aggregates.test
+# description: Test aggregates on NaN values
+# group: [float]
+
+statement ok
+PRAGMA enable_verification
+
+foreach type FLOAT DOUBLE
+
+statement error
+SELECT SUM('inf'::${type}), SUM('-inf'::${type}), SUM('nan'::${type})
+
+query III
+SELECT MIN('inf'::${type}), MIN('-inf'::${type}), MIN('nan'::${type})
+----
+inf	-inf	nan
+
+query III
+SELECT MAX('inf'::${type}), MAX('-inf'::${type}), MAX('nan'::${type})
+----
+inf	-inf	nan
+
+statement ok
+create table floats(f ${type});
+
+statement ok
+insert into floats values ('inf'), ('-inf'), ('nan');
+
+query II
+SELECT MIN(f), MAX(f) FROM floats
+----
+-inf	nan
+
+statement ok
+DROP TABLE floats
+
+endloop
diff --git a/test/sql/types/float/nan_arithmetic.test b/test/sql/types/float/nan_arithmetic.test
new file mode 100644
index 000000000000..72ac976c8fc4
--- /dev/null
+++ b/test/sql/types/float/nan_arithmetic.test
@@ -0,0 +1,33 @@
+# name: test/sql/types/float/nan_arithmetic.test
+# description: Test arithmetic on NaN values
+# group: [float]
+
+statement ok
+PRAGMA enable_verification
+
+foreach type FLOAT DOUBLE
+
+foreach val nan inf -inf
+
+# any arithmetic on a nan or inf value will result in an overflow
+statement error
+SELECT '${val}'::${type} + 1
+
+statement error
+SELECT '${val}'::${type} - 1
+
+statement error
+SELECT '${val}'::${type} * 1
+
+statement error
+SELECT '${val}'::${type} / 1
+
+statement error
+SELECT '${val}'::${type} % 1
+
+statement error
+SELECT -('${val}'::${type})
+
+endloop
+
+endloop
diff --git a/test/sql/types/float/nan_cast.test b/test/sql/types/float/nan_cast.test
new file mode 100644
index 000000000000..b7bab32753d1
--- /dev/null
+++ b/test/sql/types/float/nan_cast.test
@@ -0,0 +1,50 @@
+# name: test/sql/types/float/nan_cast.test
+# description: Test casting of NaN and inf values
+# group: [float]
+
+statement ok
+PRAGMA enable_verification
+
+# to integer/decimal casts
+foreach source_type FLOAT DOUBLE
+
+foreach target_type <integral> DECIMAL(4,1) DECIMAL(9,1) DECIMAL(18,1) DECIMAL(38,1)
+
+foreach val nan inf -inf
+
+statement ok
+SELECT '${val}'::${source_type}
+
+# cannot cast nan, inf or -inf to these types
+statement error
+SELECT '${val}'::${source_type}::${target_type}
+
+endloop
+
+endloop
+
+endloop
+
+# we can cast nan, inf and -inf between floats and doubles, as well as to/from strings
+foreach source_type FLOAT DOUBLE VARCHAR
+
+foreach target_type FLOAT DOUBLE VARCHAR
+
+query I
+SELECT 'nan'::${source_type}::${target_type}
+----
+nan
+
+query I
+SELECT 'inf'::${source_type}::${target_type}
+----
+inf
+
+query I
+SELECT '-inf'::${source_type}::${target_type}
+----
+-inf
+
+endloop
+
+endloop
diff --git a/test/sql/types/float/nan_functions.test b/test/sql/types/float/nan_functions.test
new file mode 100644
index 000000000000..7009520a1b86
--- /dev/null
+++ b/test/sql/types/float/nan_functions.test
@@ -0,0 +1,132 @@
+# name: test/sql/types/float/nan_functions.test
+# description: Test functions on NaN values
+# group: [float]
+
+statement ok
+PRAGMA enable_verification
+
+foreach type FLOAT DOUBLE
+
+# nextafter
+query I
+SELECT nextafter(3, '-inf'::${type})
+----
+3.0
+
+query I
+SELECT nextafter(3, 'inf'::${type})
+----
+3.0
+
+query I
+SELECT nextafter('inf'::${type}, 'inf'::${type})
+----
+inf
+
+query I
+SELECT nextafter('-inf'::${type}, '-inf'::${type})
+----
+-inf
+
+
+query I
+SELECT nextafter('nan'::${type}, '-inf'::${type})
+----
+nan
+
+query I
+SELECT nextafter(0, 'nan'::${type})
+----
+nan
+
+# sign
+query I
+SELECT sign('-inf'::${type})
+----
+-1
+
+query I
+SELECT sign('inf'::${type})
+----
+1
+
+query I
+SELECT sign('nan'::${type})
+----
+0
+
+# nop unary functions
+foreach unary_func ceil floor round
+
+query I
+SELECT ${unary_func}('-inf'::${type})
+----
+-inf
+
+query I
+SELECT ${unary_func}('inf'::${type})
+----
+inf
+
+query I
+SELECT ${unary_func}('nan'::${type})
+----
+nan
+
+endloop
+
+statement ok
+create table floats(f ${type});
+
+statement ok
+insert into floats values ('inf'), ('-inf'), ('nan');
+
+# several numeric functions
+query IIIIIIIIIIIII
+select f, abs(f), exp(f), pow(f, 2), sqrt(case when f < 0 then NULL else f end), cbrt(f), ln(case when f < 0 then NULL else f end), degrees(f), radians(f), gamma(f), lgamma(f), atan(f), atan2(f, 0)
+from floats;
+----
+inf	inf	inf	inf	inf	inf	inf	inf	inf	inf	inf	1.570796	1.570796
+-inf	inf	0.000000	inf	NULL	-inf	NULL	-inf	-inf	nan	inf	-1.570796	-1.570796
+nan	nan	nan	nan	nan	nan	nan	nan	nan	nan	nan	nan	nan
+
+# numeric functions that are undefined on infinity
+foreach unary_func sin sin cos tan asin acos cot
+
+statement error
+select ${unary_func}('inf'::${type})
+
+statement error
+select ${unary_func}('-inf'::${type})
+
+query I
+select ${unary_func}('nan'::${type})
+----
+nan
+
+endloop
+
+statement ok
+drop table floats
+
+endloop
+
+query I
+SELECT nextafter('inf'::float, '-inf'::float)
+----
+340282346638528859811704183484516925440.000000
+
+query I
+SELECT nextafter('-inf'::float, 'inf'::float)
+----
+-340282346638528859811704183484516925440.000000
+
+query I
+SELECT nextafter('inf'::double, '-inf'::double)
+----
+179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
+
+query I
+SELECT nextafter('-inf'::double, 'inf'::double)
+----
+-179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
diff --git a/test/sql/types/float/nan_join.test b/test/sql/types/float/nan_join.test
new file mode 100644
index 000000000000..e427805b360b
--- /dev/null
+++ b/test/sql/types/float/nan_join.test
@@ -0,0 +1,48 @@
+# name: test/sql/types/float/nan_join.test
+# description: Test NaN and inf joins
+# group: [float]
+
+statement ok
+PRAGMA enable_verification
+
+# test various types of joins on nan and inf values
+foreach type FLOAT DOUBLE
+
+statement ok
+create table floats(f ${type});
+
+statement ok
+insert into floats values ('inf'), ('-inf'), ('nan');
+
+query I
+SELECT * FROM floats JOIN (SELECT 'inf'::${type}) tbl(f) USING (f)
+----
+inf
+
+query I
+SELECT * FROM floats JOIN (SELECT '-inf'::${type}) tbl(f) USING (f)
+----
+-inf
+
+query II
+SELECT * FROM floats JOIN (SELECT 'inf'::${type}) tbl(f) ON (floats.f >= tbl.f) ORDER BY 1
+----
+inf	inf
+nan	inf
+
+query II
+SELECT * FROM floats JOIN (SELECT 'inf'::${type}) tbl(f) ON (floats.f <= tbl.f) ORDER BY 1
+----
+-inf	inf
+inf	inf
+
+query III
+SELECT * FROM floats JOIN (SELECT '-inf'::${type}, 'inf'::${type}) tbl(f,g ) ON (floats.f >= tbl.f AND floats.f <= tbl.g) ORDER BY 1
+----
+-inf	-inf	inf
+inf	-inf	inf
+
+statement ok
+DROP TABLE floats
+
+endloop
diff --git a/test/sql/types/float/nan_ordering.test b/test/sql/types/float/nan_ordering.test
new file mode 100644
index 000000000000..fb51356d58bf
--- /dev/null
+++ b/test/sql/types/float/nan_ordering.test
@@ -0,0 +1,91 @@
+# name: test/sql/types/float/nan_ordering.test
+# description: Test ordering of NaN and infinity values
+# group: [float]
+
+statement ok
+PRAGMA enable_verification
+
+foreach type FLOAT DOUBLE
+
+# storing nan in a table
+statement ok
+CREATE TABLE floats(f ${type});
+
+statement ok
+INSERT INTO floats VALUES ('NAN'), (1), ('infinity'), ('-infinity'), (-1), (NULL)
+
+# standard ordering
+query I
+SELECT f FROM floats ORDER BY f
+----
+NULL
+-inf
+-1.000000
+1.000000
+inf
+nan
+
+query I
+SELECT f FROM floats ORDER BY f DESC
+----
+NULL
+nan
+inf
+1.000000
+-1.000000
+-inf
+
+# top-n
+query I
+SELECT f FROM floats ORDER BY f DESC NULLS LAST LIMIT 2
+----
+nan
+inf
+
+query I
+SELECT f FROM floats ORDER BY f NULLS LAST LIMIT 2
+----
+-inf
+-1.0
+
+# top-n with many rows
+statement ok
+INSERT INTO floats SELECT '0'::${type} FROM range(10000)
+
+statement ok
+INSERT INTO floats VALUES ('nan'::${type})
+
+statement ok
+INSERT INTO floats VALUES ('-inf'::${type})
+
+query I
+SELECT f FROM floats ORDER BY f DESC NULLS LAST LIMIT 4
+----
+nan
+nan
+inf
+1.0
+
+query I
+SELECT f FROM floats ORDER BY f NULLS LAST LIMIT 4
+----
+-inf
+-inf
+-1.0
+0.0
+
+# count with filters
+query I
+SELECT COUNT(*) FROM floats WHERE f > 0
+----
+4
+
+query I
+SELECT COUNT(*) FROM floats WHERE f < 0
+----
+3
+
+statement ok
+DROP TABLE floats
+
+endloop
diff --git a/test/sql/types/float/nan_test.test b/test/sql/types/float/nan_test.test
new file mode 100644
index 000000000000..efa40c0c7ddf
--- /dev/null
+++ b/test/sql/types/float/nan_test.test
@@ -0,0 +1,122 @@
+# name: test/sql/types/float/nan_test.test
+# description: Test usage of the NAN value
+# group: [float]
+
+statement ok
+PRAGMA enable_verification
+
+foreach type FLOAT DOUBLE
+
+foreach key UNIQUE CHECK(1)
+
+# nan as a constant
+query I
+SELECT 'NAN'::${type}
+----
+nan
+
+# storing nan in a table
+statement ok
+CREATE TABLE floats(f ${type} ${key});
+
+statement ok
+INSERT INTO floats VALUES ('NAN'), (1)
+
+query I
+SELECT * FROM floats
+----
+nan
+1
+
+# nan comparison
+query I
+select 'nan'::${type} == 'nan'::${type}
+----
+true
+
+query I
+select 'nan'::${type} <> 'nan'::${type}
+----
+false
+
+query I
+select 'nan'::${type} <> 3.0::${type}
+----
+true
+
+# table filters on nan
+# note: for postgres compatibility, nan is equal to itself
+# =
+query I
+SELECT f FROM floats WHERE f=1
+----
+1
+
+query I
+SELECT f FROM floats WHERE f='nan'::${type}
+----
+nan
+
+# <>
+query I
+SELECT f FROM floats WHERE f<>1
+----
+nan
+
+query I
+SELECT f FROM floats WHERE f<>'nan'::${type}
+----
+1
+
+# >
+# for postgres compatibility, nan is bigger than everything
+query I
+SELECT f FROM floats WHERE f>0
+----
+nan
+1
+
+query I
+SELECT f FROM floats WHERE f>'nan'::${type}
+----
+
+# >=
+query I
+SELECT f FROM floats WHERE f>=1
+----
+nan
+1
+
+query I
+SELECT f FROM floats WHERE f>='nan'::${type}
+----
+nan
+
+# <
+query I
+SELECT f FROM floats WHERE f<1
+----
+
+query I
+SELECT f FROM floats WHERE f<'nan'::${type}
+----
+1
+
+# <=
+query I
+SELECT f FROM floats WHERE f<=1
+----
+1
+
+query I
+SELECT f FROM floats WHERE f<='nan'::${type}
+----
+nan
+1
+
+statement ok
+DROP TABLE floats
+
+endloop
+
+endloop
diff --git a/test/sql/types/float/nan_window.test b/test/sql/types/float/nan_window.test
new file mode 100644
index 000000000000..5ad8cbed0666
--- /dev/null
+++ b/test/sql/types/float/nan_window.test
@@ -0,0 +1,62 @@
+# name: test/sql/types/float/nan_window.test
+# description: Test NaN and inf in windowing functions
+# group: [float]
+
+require vector_size 512
+
+statement ok
+PRAGMA enable_verification
+
+# grouping by inf and nan
+foreach type FLOAT DOUBLE
+
+statement ok
+create table floats(f ${type}, i int);
+
+statement ok
+insert into floats values ('inf', 1), ('inf', 7), ('-inf', 3), ('nan', 7), ('nan', 19), ('-inf', 2)
+
+query II
+SELECT f, SUM(i) OVER (PARTITION BY f) FROM floats ORDER BY f
+----
+-inf	5
+-inf	5
+inf	8
+inf	8
+nan	26
+nan	26
+
+query III
+SELECT f, i, SUM(i) OVER (ORDER BY f, i) FROM floats ORDER BY f, i
+----
+-inf	2	2
+-inf	3	5
+inf	1	6
+inf	7	13
+nan	7	20
+nan	19	39
+
+query III
+SELECT f, i, SUM(i) OVER (PARTITION BY f ORDER BY f, i) FROM floats ORDER BY f, i
+----
+-inf	2	2
+-inf	3	5
+inf	1	1
+inf	7	8
+nan	7	7
+nan	19	26
+
+query III
+SELECT i, f, SUM(i) OVER (ORDER BY i, f) FROM floats ORDER BY i, f
+----
+1	inf	1
+2	-inf	3
+3	-inf	6
+7	inf	13
+7	nan	20
+19	nan	39
+
+statement ok
+DROP TABLE floats
+
+endloop
diff --git a/test/sql/types/float/nested_nan.test b/test/sql/types/float/nested_nan.test
new file mode 100644
index 000000000000..42ace036c50c
--- /dev/null
+++ b/test/sql/types/float/nested_nan.test
@@ -0,0 +1,26 @@
+# name: test/sql/types/float/nested_nan.test
+# description: Test nested nans
+# group: [float]
+
+statement ok
+PRAGMA enable_verification
+
+query I
+SELECT ['nan'::double]
+----
+[nan]
+
+query I
+SELECT UNNEST(['nan'::double])
+----
+nan
+
+query I
+SELECT {'a': 'nan'::double}
+----
+{'a': nan}
+
+query I
+SELECT ({'a': 'nan'::double}).a
+----
+nan
diff --git a/test/sql/types/test_all_types.test b/test/sql/types/test_all_types.test
index e43094987f7b..6c7ee7f1fe25 100644
--- a/test/sql/types/test_all_types.test
+++ b/test/sql/types/test_all_types.test
@@ -5,12 +5,12 @@
 statement ok
 PRAGMA enable_verification
 
-query IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
+query IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
 SELECT * FROM test_all_types();
 ----
-False	-128	-32768	-2147483648	-9223372036854775808	-170141183460469231731687303715884105727	0	0	0	0	5877642-06-23 (BC)	00:00:00	290309-12-22 (BC) 00:00:00	290309-12-22 (BC) 00:00:00	290309-12-22 (BC) 00:00:00	1677-09-21 00:12:43.145225	00:00:00+00	290309-12-22 (BC) 00:00:00+00	-340282346638528859811704183484516925440.000000	-179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000	-999.9	-99999.9999	-999999999999.999999	-9999999999999999999999999999.9999999999	00000000-0000-0000-0000-000000000001	00:00:00	🦆🦆🦆🦆🦆🦆	🦆🦆🦆🦆🦆🦆	thisisalongblob\x00withnullbytes	DUCK_DUCK_ENUM	enum_0	enum_0	[]	[]	[]	{'a': NULL, 'b': NULL}	{'a': NULL, 'b': NULL}	[]	{}
-True	127	32767	2147483647	9223372036854775807	170141183460469231731687303715884105727	255	65535	4294967295	18446744073709551615	5881580-07-11	23:59:59.999999	294247-01-10 04:00:54.775807	294247-01-10 04:00:54	294247-01-10 04:00:54.775	2262-04-11 23:47:16.854775	23:59:59.999999+00	294247-01-10 04:00:54.775807+00	340282346638528859811704183484516925440.000000	179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000	999.9	99999.9999	999999999999.999999	9999999999999999999999999999.9999999999	ffffffff-ffff-ffff-ffff-ffffffffffff	83 years 3 months 999 days 00:16:39.999999	goose	goose	\x5Cx00\x5Cx00\x5Cx00a	GOOSE	enum_299	enum_69999	[42, 999, NULL, NULL, -42]	[🦆🦆🦆🦆🦆🦆, goose, NULL, ]	[[], [42, 999, NULL, NULL, -42], NULL, [], [42, 999, NULL, NULL, -42]]	{'a': 42, 'b': 🦆🦆🦆🦆🦆🦆}	{'a': [42, 999, NULL, NULL, -42], 'b': [🦆🦆🦆🦆🦆🦆, goose, NULL, ]}	[{'a': NULL, 'b': NULL}, {'a': 42, 'b': 🦆🦆🦆🦆🦆🦆}, NULL]	{key1=🦆🦆🦆🦆🦆🦆, key2=goose}
-NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
+False	-128	-32768	-2147483648	-9223372036854775808	-170141183460469231731687303715884105727	0	0	0	0	5877642-06-23 (BC)	00:00:00	290309-12-22 (BC) 00:00:00	290309-12-22 (BC) 00:00:00	290309-12-22 (BC) 00:00:00	1677-09-21 00:12:43.145225	00:00:00+00	290309-12-22 (BC) 00:00:00+00	-340282346638528859811704183484516925440.000000	-179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000	-999.9	-99999.9999	-999999999999.999999	-9999999999999999999999999999.9999999999	00000000-0000-0000-0000-000000000001	00:00:00	🦆🦆🦆🦆🦆🦆	🦆🦆🦆🦆🦆🦆	thisisalongblob\x00withnullbytes	DUCK_DUCK_ENUM	enum_0	enum_0	[]	[]	[]	[]	{'a': NULL, 'b': NULL}	{'a': NULL, 'b': NULL}	[]	{}
+True	127	32767	2147483647	9223372036854775807	170141183460469231731687303715884105727	255	65535	4294967295	18446744073709551615	5881580-07-11	23:59:59.999999	294247-01-10 04:00:54.775807	294247-01-10 04:00:54	294247-01-10 04:00:54.775	2262-04-11 23:47:16.854775	23:59:59.999999+00	294247-01-10 04:00:54.775807+00	340282346638528859811704183484516925440.000000	179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000	999.9	99999.9999	999999999999.999999	9999999999999999999999999999.9999999999	ffffffff-ffff-ffff-ffff-ffffffffffff	83 years 3 months 999 days 00:16:39.999999	goose	goose	\x5Cx00\x5Cx00\x5Cx00a	GOOSE	enum_299	enum_69999	[42, 999, NULL, NULL, -42]	[42.000000, nan, inf, -inf, NULL, -42.000000]	[🦆🦆🦆🦆🦆🦆, goose, NULL, ]	[[], [42, 999, NULL, NULL, -42], NULL, [], [42, 999, NULL, NULL, -42]]	{'a': 42, 'b': 🦆🦆🦆🦆🦆🦆}	{'a': [42, 999, NULL, NULL, -42], 'b': [🦆🦆🦆🦆🦆🦆, goose, NULL, ]}	[{'a': NULL, 'b': NULL}, {'a': 42, 'b': 🦆🦆🦆🦆🦆🦆}, NULL]	{key1=🦆🦆🦆🦆🦆🦆, key2=goose}
+NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
 
 statement ok
 CREATE TABLE all_types AS SELECT * FROM test_all_types();
diff --git a/tools/juliapkg/test.sh b/tools/juliapkg/test.sh
index 73ba241fdb62..dc05bf5c876f 100755
--- a/tools/juliapkg/test.sh
+++ b/tools/juliapkg/test.sh
@@ -2,7 +2,7 @@ set -e
 
 #julia -e "import Pkg; Pkg.activate(\".\"); Pkg.instantiate(); include(\"test/runtests.jl\")" $1
 
-#export JULIA_DUCKDB_LIBRARY="/Users/myth/Programs/duckdb-bugfix/build/debug/src/libduckdb.dylib"
+export JULIA_DUCKDB_LIBRARY="`pwd`/../../build/debug/src/libduckdb.dylib"
 #export JULIA_DUCKDB_LIBRARY="/Users/myth/Programs/duckdb-bugfix/build/release/src/libduckdb.dylib"
 
 julia -e "import Pkg; Pkg.activate(\".\"); include(\"test/runtests.jl\")" $1
diff --git a/tools/juliapkg/test/test_all_types.jl b/tools/juliapkg/test/test_all_types.jl
index a2c2769ae645..909200325987 100644
--- a/tools/juliapkg/test/test_all_types.jl
+++ b/tools/juliapkg/test/test_all_types.jl
@@ -113,6 +113,7 @@
     )
     @test isequal(df.uuid, [UUID(1), UUID(UInt128(340282366920938463463374607431768211455)), missing])
     @test isequal(df.int_array, [[], [42, 999, missing, missing, -42], missing])
+    @test isequal(df.double_array, [[], [42, NaN, Inf, -Inf, missing, -42], missing])
     @test isequal(df.varchar_array, [[], ["🦆🦆🦆🦆🦆🦆", "goose", missing, ""], missing])
     @test isequal(
         df.nested_int_array,
diff --git a/tools/pythonpkg/tests/fast/sqlite/test_types.py b/tools/pythonpkg/tests/fast/sqlite/test_types.py
index 759e0ea5b12c..7e3d5611c97c 100644
--- a/tools/pythonpkg/tests/fast/sqlite/test_types.py
+++ b/tools/pythonpkg/tests/fast/sqlite/test_types.py
@@ -74,12 +74,19 @@ def test_CheckDecimal(self):
         self.assertEqual(row[0], val)
 
     def test_CheckNaN(self):
-        with self.assertRaises(RuntimeError) as context:
-            self.cur.execute("insert into test(f) values (?)", (decimal.Decimal('nan'),))
+        import math
+        val = decimal.Decimal('nan')
+        self.cur.execute("insert into test(f) values (?)", (val,))
+        self.cur.execute("select f from test")
+        row = self.cur.fetchone()
+        self.assertEqual(math.isnan(row[0]), True)
 
     def test_CheckInf(self):
-        with self.assertRaises(RuntimeError) as context:
-            self.cur.execute("insert into test(f) values (?)", (decimal.Decimal('inf'),))
+        val = decimal.Decimal('inf')
+        self.cur.execute("insert into test(f) values (?)", (val,))
+        self.cur.execute("select f from test")
+        row = self.cur.fetchone()
+        self.assertEqual(row[0], val)
 
     def test_CheckBytesBlob(self):
         val = b"Guglhupf"
diff --git a/tools/pythonpkg/tests/fast/test_all_types.py b/tools/pythonpkg/tests/fast/test_all_types.py
index 929cdbae8c04..0aa2ae338a8f 100644
--- a/tools/pythonpkg/tests/fast/test_all_types.py
+++ b/tools/pythonpkg/tests/fast/test_all_types.py
@@ -15,6 +15,25 @@ def get_all_types():
 
 all_types = get_all_types()
 
+# we need to write our own equality function that considers nan==nan for testing purposes
+def recursive_equality(o1, o2):
+	import math
+	if o1 == o2:
+		return True
+	if type(o1) != type(o2):
+		return False
+	if type(o1) == float and math.isnan(o1) and math.isnan(o2):
+		return True
+	try:
+		if len(o1) != len(o2):
+			return False
+		for i in range(len(o1)):
+			if not recursive_equality(o1[i], o2[i]):
+				return False
+		return True
+	except:
+		return False
+
 class TestAllTypes(object):
 	def test_fetchall(self, duckdb_cursor):
 		conn = duckdb.connect()
@@ -41,12 +60,13 @@ def test_fetchall(self, duckdb_cursor):
 			, 'varchar': [('🦆🦆🦆🦆🦆🦆',), ('goose',), (None,)], 'json': [('🦆🦆🦆🦆🦆🦆',), ('goose',), (None,)], 'blob': [(b'thisisalongblob\x00withnullbytes',), (b'\\x00\\x00\\x00a',), (None,)]
 			, 'small_enum':[('DUCK_DUCK_ENUM',), ('GOOSE',), (None,)], 'medium_enum': [('enum_0',), ('enum_299',), (None,)], 'large_enum': [('enum_0',), ('enum_69999',), (None,)]
 			, 'int_array': [([],), ([42, 999, None, None, -42],), (None,)], 'varchar_array': [([],), (['🦆🦆🦆🦆🦆🦆', 'goose', None, ''],), (None,)]
+			, 'double_array': [([],), ([42.0, float('nan'), float('inf'), float('-inf'), None, -42.0],), (None,)]
 			, 'nested_int_array': [([],), ([[], [42, 999, None, None, -42], None, [], [42, 999, None, None, -42]],), (None,)], 'struct': [({'a': None, 'b': None},), ({'a': 42, 'b': '🦆🦆🦆🦆🦆🦆'},), (None,)]
 			, 'struct_of_arrays': [({'a': None, 'b': None},), ({'a': [42, 999, None, None, -42], 'b': ['🦆🦆🦆🦆🦆🦆', 'goose', None, '']},), (None,)]
 			, 'array_of_structs': [([],), ([{'a': None, 'b': None}, {'a': 42, 'b': '🦆🦆🦆🦆🦆🦆'}, None],), (None,)], 'map':[({'key': [], 'value': []},), ({'key': ['key1', 'key2'], 'value': ['🦆🦆🦆🦆🦆🦆', 'goose']},), (None,)]
 			, 'time_tz':[(datetime.time(0, 0),), (datetime.time(23, 59, 59, 999999),), (None,)], 'interval': [(datetime.timedelta(0),), (datetime.timedelta(days=30969, seconds=999, microseconds=999999),), (None,)]
 			, 'timestamp':[(datetime.datetime(1990, 1, 1, 0, 0),)], 'date':[(datetime.date(1990, 1, 1),)], 'timestamp_s':[(datetime.datetime(1990, 1, 1, 0, 0),)]
-			, 'timestamp_ns':[(datetime.datetime(1990, 1, 1, 0, 0),)], 'timestamp_ms':[(datetime.datetime(1990, 1, 1, 0, 0),)], 'timestamp_tz':[(datetime.datetime(1990, 1, 1, 0, 0),)]}
+			, 'timestamp_ns':[(datetime.datetime(1990, 1, 1, 0, 0),)], 'timestamp_ms':[(datetime.datetime(1990, 1, 1, 0, 0),)], 'timestamp_tz':[(datetime.datetime(1990, 1, 1, 0, 0),)],}
 
 		for cur_type in all_types:
 			if cur_type in replacement_values:
@@ -54,7 +74,7 @@ def test_fetchall(self, duckdb_cursor):
 			else:
 				result = conn.execute("select "+cur_type+" from test_all_types()").fetchall()
 			correct_result = correct_answer_map[cur_type]
-			assert result == correct_result
+			assert recursive_equality(result, correct_result)
 
 	def test_arrow(self, duckdb_cursor):
 		try:
@@ -64,7 +84,7 @@ def test_arrow(self, duckdb_cursor):
 		# We skip those since the extreme ranges are not supported in arrow.
 		replacement_values = {'interval': "INTERVAL '2 years'"}
 		# We do not round trip enum types
-		enum_types = {'small_enum', 'medium_enum', 'large_enum'}
+		enum_types = {'small_enum', 'medium_enum', 'large_enum', 'double_array'}
 		conn = duckdb.connect()
 		for cur_type in all_types:
 			if cur_type in replacement_values:
@@ -75,7 +95,7 @@ def test_arrow(self, duckdb_cursor):
 				round_trip_arrow_table = conn.execute("select * from arrow_table").arrow()
 				result_arrow = conn.execute("select * from arrow_table").fetchall()
 				result_roundtrip = conn.execute("select * from round_trip_arrow_table").fetchall()
-				assert result_arrow == result_roundtrip
+				assert recursive_equality(result_arrow, result_roundtrip)
 			else:
 				round_trip_arrow_table = conn.execute("select * from arrow_table").arrow()
 				assert arrow_table.equals(round_trip_arrow_table, check_metadata=True)
@@ -98,4 +118,4 @@ def test_pandas(self, duckdb_cursor):
 			round_trip_dataframe = conn.execute("select * from dataframe").df()
 			result_dataframe = conn.execute("select * from dataframe").fetchall()
 			result_roundtrip = conn.execute("select * from round_trip_dataframe").fetchall()
-			assert result_dataframe == result_roundtrip
+			assert recursive_equality(result_dataframe, result_roundtrip)
