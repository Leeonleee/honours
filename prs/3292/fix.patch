diff --git a/extension/parquet/column_writer.cpp b/extension/parquet/column_writer.cpp
index 7a1d26dc6030..42fb7dacfecd 100644
--- a/extension/parquet/column_writer.cpp
+++ b/extension/parquet/column_writer.cpp
@@ -53,11 +53,7 @@ static void VarintEncode(uint32_t val, Serializer &ser) {
 static uint8_t GetVarintSize(uint32_t val) {
 	uint8_t res = 0;
 	do {
-		uint8_t byte = val & 127;
 		val >>= 7;
-		if (val != 0) {
-			byte |= 128;
-		}
 		res++;
 	} while (val != 0);
 	return res;
diff --git a/extension/parquet/include/templated_column_reader.hpp b/extension/parquet/include/templated_column_reader.hpp
index 9cc36d4735cc..fc74aee33cef 100644
--- a/extension/parquet/include/templated_column_reader.hpp
+++ b/extension/parquet/include/templated_column_reader.hpp
@@ -55,10 +55,6 @@ class TemplatedColumnReader : public ColumnReader {
 			}
 			if (filter[row_idx + result_offset]) {
 				VALUE_TYPE val = VALUE_CONVERSION::DictRead(*dict, offsets[offset_idx++], *this);
-				if (!Value::IsValid(val)) {
-					result_mask.SetInvalid(row_idx + result_offset);
-					continue;
-				}
 				result_ptr[row_idx + result_offset] = val;
 			} else {
 				offset_idx++;
@@ -77,10 +73,6 @@ class TemplatedColumnReader : public ColumnReader {
 			}
 			if (filter[row_idx + result_offset]) {
 				VALUE_TYPE val = VALUE_CONVERSION::PlainRead(*plain_data, *this);
-				if (!Value::IsValid(val)) {
-					result_mask.SetInvalid(row_idx + result_offset);
-					continue;
-				}
 				result_ptr[row_idx + result_offset] = val;
 			} else { // there is still some data there that we have to skip over
 				VALUE_CONVERSION::PlainSkip(*plain_data, *this);
diff --git a/extension/parquet/parquet_statistics.cpp b/extension/parquet/parquet_statistics.cpp
index 4d42e7b2ac44..fd4e9e3f5d2f 100644
--- a/extension/parquet/parquet_statistics.cpp
+++ b/extension/parquet/parquet_statistics.cpp
@@ -81,7 +81,7 @@ Value ParquetStatisticsUtils::ConvertValue(const LogicalType &type,
 			throw InternalException("Incorrect stats size for type FLOAT");
 		}
 		auto val = Load<float>((data_ptr_t)stats.c_str());
-		if (!Value::FloatIsValid(val)) {
+		if (!Value::FloatIsFinite(val)) {
 			return Value();
 		}
 		return Value::FLOAT(val);
@@ -91,7 +91,7 @@ Value ParquetStatisticsUtils::ConvertValue(const LogicalType &type,
 			throw InternalException("Incorrect stats size for type DOUBLE");
 		}
 		auto val = Load<double>((data_ptr_t)stats.c_str());
-		if (!Value::DoubleIsValid(val)) {
+		if (!Value::DoubleIsFinite(val)) {
 			return Value();
 		}
 		return Value::DOUBLE(val);
diff --git a/src/common/operator/cast_operators.cpp b/src/common/operator/cast_operators.cpp
index 20d0f2a5a4ec..17f5385bb04e 100644
--- a/src/common/operator/cast_operators.cpp
+++ b/src/common/operator/cast_operators.cpp
@@ -1012,19 +1012,6 @@ bool TryCast::Operation(string_t input, uint64_t &result, bool strict) {
 	return TryIntegerCast<uint64_t, false>(input.GetDataUnsafe(), input.GetSize(), result, strict);
 }
 
-template <class T>
-bool CheckDoubleValidity(T value);
-
-template <>
-bool CheckDoubleValidity(float value) {
-	return Value::FloatIsValid(value);
-}
-
-template <>
-bool CheckDoubleValidity(double value) {
-	return Value::DoubleIsValid(value);
-}
-
 template <class T>
 static bool TryDoubleCast(const char *buf, idx_t len, T &result, bool strict) {
 	// skip any spaces at the start
@@ -1041,9 +1028,6 @@ static bool TryDoubleCast(const char *buf, idx_t len, T &result, bool strict) {
 	}
 	auto endptr = buf + len;
 	auto parse_result = duckdb_fast_float::from_chars(buf, buf + len, result);
-	if (!CheckDoubleValidity<T>(result)) {
-		return false;
-	}
 	if (parse_result.ec != std::errc()) {
 		return false;
 	}
diff --git a/src/common/radix.cpp b/src/common/radix.cpp
index c65370f7a91a..0a126b759626 100644
--- a/src/common/radix.cpp
+++ b/src/common/radix.cpp
@@ -1,4 +1,6 @@
 #include "duckdb/common/radix.hpp"
+#include "duckdb/common/types/value.hpp"
+#include "duckdb/common/types/string_type.hpp"
 
 #include <cfloat>
 #include <cstring> // strlen() on Solaris
@@ -28,15 +30,17 @@ uint32_t EncodeFloat(float x) {
 		buff |= (1u << 31);
 		return buff;
 	}
+	// nan
+	if (Value::IsNan(x)) {
+		return UINT_MAX;
+	}
 	//! infinity
 	if (x > FLT_MAX) {
-		throw InternalException("+INFINITY detected in floating point number");
-		// return UINT_MAX;
+		return UINT_MAX - 1;
 	}
 	//! -infinity
 	if (x < -FLT_MAX) {
-		throw InternalException("-INFINITY detected in floating point number");
-		// return 0;
+		return 0;
 	}
 	buff = Load<uint32_t>((const_data_ptr_t)&x);
 	if ((buff & (1u << 31)) == 0) { //! +0 and positive numbers
@@ -56,15 +60,17 @@ uint64_t EncodeDouble(double x) {
 		buff += (1ull << 63);
 		return buff;
 	}
+	// nan
+	if (Value::IsNan(x)) {
+		return ULLONG_MAX;
+	}
 	//! infinity
 	if (x > DBL_MAX) {
-		throw InternalException("+INFINITY detected in floating point number");
-		// return ULLONG_MAX;
+		return ULLONG_MAX - 1;
 	}
 	//! -infinity
 	if (x < -DBL_MAX) {
-		throw InternalException("-INFINITY detected in floating point number");
-		// return 0;
+		return 0;
 	}
 	buff = Load<uint64_t>((const_data_ptr_t)&x);
 	if (buff < (1ull << 63)) { //! +0 and positive numbers
diff --git a/src/common/types.cpp b/src/common/types.cpp
index 9cc957d0d76d..4b0b7ecdd7ff 100644
--- a/src/common/types.cpp
+++ b/src/common/types.cpp
@@ -745,11 +745,23 @@ void LogicalType::Verify() const {
 }
 
 bool ApproxEqual(float ldecimal, float rdecimal) {
+	if (Value::IsNan(ldecimal) && Value::IsNan(rdecimal)) {
+		return true;
+	}
+	if (!Value::FloatIsFinite(ldecimal) || !Value::FloatIsFinite(rdecimal)) {
+		return ldecimal == rdecimal;
+	}
 	float epsilon = std::fabs(rdecimal) * 0.01;
 	return std::fabs(ldecimal - rdecimal) <= epsilon;
 }
 
 bool ApproxEqual(double ldecimal, double rdecimal) {
+	if (Value::IsNan(ldecimal) && Value::IsNan(rdecimal)) {
+		return true;
+	}
+	if (!Value::DoubleIsFinite(ldecimal) || !Value::DoubleIsFinite(rdecimal)) {
+		return ldecimal == rdecimal;
+	}
 	double epsilon = std::fabs(rdecimal) * 0.01;
 	return std::fabs(ldecimal - rdecimal) <= epsilon;
 }
diff --git a/src/common/types/hugeint.cpp b/src/common/types/hugeint.cpp
index e6ba24c4e752..084907a79e02 100644
--- a/src/common/types/hugeint.cpp
+++ b/src/common/types/hugeint.cpp
@@ -3,6 +3,7 @@
 #include "duckdb/common/algorithm.hpp"
 #include "duckdb/common/limits.hpp"
 #include "duckdb/common/windows_undefs.hpp"
+#include "duckdb/common/types/value.hpp"
 
 #include <cmath>
 #include <limits>
@@ -543,6 +544,9 @@ bool Hugeint::TryConvert(float value, hugeint_t &result) {
 
 template <class REAL_T>
 bool ConvertFloatingToBigint(REAL_T value, hugeint_t &result) {
+	if (!Value::IsFinite<REAL_T>(value)) {
+		return false;
+	}
 	if (value <= -170141183460469231731687303715884105728.0 || value >= 170141183460469231731687303715884105727.0) {
 		return false;
 	}
diff --git a/src/common/types/value.cpp b/src/common/types/value.cpp
index aed60da5ff06..dd6401fe90b1 100644
--- a/src/common/types/value.cpp
+++ b/src/common/types/value.cpp
@@ -1,5 +1,3 @@
-#include <utility>
-
 #include "duckdb/common/types/value.hpp"
 
 #include "duckdb/common/exception.hpp"
@@ -29,6 +27,9 @@
 #include "duckdb/common/types/cast_helpers.hpp"
 #include "duckdb/common/types/hash.hpp"
 
+#include <utility>
+#include <cmath>
+
 namespace duckdb {
 
 Value::Value(LogicalType type) : type_(move(type)), is_null(true) {
@@ -43,16 +44,10 @@ Value::Value(int64_t val) : type_(LogicalType::BIGINT), is_null(false) {
 }
 
 Value::Value(float val) : type_(LogicalType::FLOAT), is_null(false) {
-	if (!Value::FloatIsValid(val)) {
-		throw OutOfRangeException("Invalid float value %f", val);
-	}
 	value_.float_ = val;
 }
 
 Value::Value(double val) : type_(LogicalType::DOUBLE), is_null(false) {
-	if (!Value::DoubleIsValid(val)) {
-		throw OutOfRangeException("Invalid double value %f", val);
-	}
 	value_.double_ = val;
 }
 
@@ -326,14 +321,34 @@ Value Value::UBIGINT(uint64_t value) {
 	return result;
 }
 
-bool Value::FloatIsValid(float value) {
+bool Value::FloatIsFinite(float value) {
 	return !(std::isnan(value) || std::isinf(value));
 }
 
-bool Value::DoubleIsValid(double value) {
+bool Value::DoubleIsFinite(double value) {
 	return !(std::isnan(value) || std::isinf(value));
 }
 
+template <>
+bool Value::IsNan(float input) {
+	return std::isnan(input);
+}
+
+template <>
+bool Value::IsNan(double input) {
+	return std::isnan(input);
+}
+
+template <>
+bool Value::IsFinite(float input) {
+	return Value::FloatIsFinite(input);
+}
+
+template <>
+bool Value::IsFinite(double input) {
+	return Value::DoubleIsFinite(input);
+}
+
 bool Value::StringIsValid(const char *str, idx_t length) {
 	auto utf_type = Utf8Proc::Analyze(str, length);
 	return utf_type != UnicodeType::INVALID;
@@ -386,9 +401,6 @@ Value Value::DECIMAL(hugeint_t value, uint8_t width, uint8_t scale) {
 }
 
 Value Value::FLOAT(float value) {
-	if (!Value::FloatIsValid(value)) {
-		throw OutOfRangeException("Invalid float value %f", value);
-	}
 	Value result(LogicalType::FLOAT);
 	result.value_.float_ = value;
 	result.is_null = false;
@@ -396,9 +408,6 @@ Value Value::FLOAT(float value) {
 }
 
 Value Value::DOUBLE(double value) {
-	if (!Value::DoubleIsValid(value)) {
-		throw OutOfRangeException("Invalid double value %f", value);
-	}
 	Value result(LogicalType::DOUBLE);
 	result.value_.double_ = value;
 	result.is_null = false;
@@ -1399,6 +1408,22 @@ string Value::ToSQLString() const {
 		ret += "}";
 		return ret;
 	}
+	case LogicalTypeId::FLOAT:
+		if (!FloatIsFinite(FloatValue::Get(*this))) {
+			return "'" + ToString() + "'::" + type_.ToString();
+		}
+		return ToString();
+	case LogicalTypeId::DOUBLE: {
+		double val = DoubleValue::Get(*this);
+		if (!DoubleIsFinite(val)) {
+			if (!Value::IsNan(val)) {
+				// to infinity and beyond
+				return val < 0 ? "-1e1000" : "1e1000";
+			}
+			return "'" + ToString() + "'::" + type_.ToString();
+		}
+		return ToString();
+	}
 	case LogicalTypeId::LIST: {
 		string ret = "[";
 		for (size_t i = 0; i < list_value.size(); i++) {
@@ -1778,14 +1803,4 @@ bool Value::ValuesAreEqual(const Value &result_value, const Value &value) {
 	}
 }
 
-template <>
-bool Value::IsValid(float value) {
-	return Value::FloatIsValid(value);
-}
-
-template <>
-bool Value::IsValid(double value) {
-	return Value::DoubleIsValid(value);
-}
-
 } // namespace duckdb
diff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp
index b3b0b241400e..91772d7981f6 100644
--- a/src/common/types/vector.cpp
+++ b/src/common/types/vector.cpp
@@ -984,30 +984,6 @@ void Vector::Verify(const SelectionVector &sel, idx_t count) {
 	    (GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR)) {
 		D_ASSERT(!auxiliary);
 	}
-	if (GetType().InternalType() == PhysicalType::DOUBLE) {
-		// verify that there are no INF or NAN values
-		switch (GetVectorType()) {
-		case VectorType::CONSTANT_VECTOR: {
-			auto dbl = ConstantVector::GetData<double>(*this);
-			if (!ConstantVector::IsNull(*this)) {
-				D_ASSERT(Value::DoubleIsValid(*dbl));
-			}
-			break;
-		}
-		case VectorType::FLAT_VECTOR: {
-			auto doubles = FlatVector::GetData<double>(*this);
-			for (idx_t i = 0; i < count; i++) {
-				auto oidx = sel.get_index(i);
-				if (validity.RowIsValid(oidx)) {
-					D_ASSERT(Value::DoubleIsValid(doubles[oidx]));
-				}
-			}
-			break;
-		}
-		default:
-			break;
-		}
-	}
 	if (GetType().id() == LogicalTypeId::VARCHAR || GetType().id() == LogicalTypeId::JSON) {
 		// verify that there are no '\0' bytes in string values
 		switch (GetVectorType()) {
diff --git a/src/common/vector_operations/comparison_operators.cpp b/src/common/vector_operations/comparison_operators.cpp
index 0b479621fafc..c58813e0b0be 100644
--- a/src/common/vector_operations/comparison_operators.cpp
+++ b/src/common/vector_operations/comparison_operators.cpp
@@ -9,8 +9,83 @@
 #include "duckdb/common/vector_operations/binary_executor.hpp"
 #include "duckdb/common/vector_operations/vector_operations.hpp"
 
+#include "duckdb/common/likely.hpp"
+
 namespace duckdb {
 
+template <class T>
+bool EqualsFloat(T left, T right) {
+	if (DUCKDB_UNLIKELY(Value::IsNan(left) && Value::IsNan(right))) {
+		return true;
+	}
+	return left == right;
+}
+
+template <>
+bool Equals::Operation(float left, float right) {
+	return EqualsFloat<float>(left, right);
+}
+
+template <>
+bool Equals::Operation(double left, double right) {
+	return EqualsFloat<double>(left, right);
+}
+
+template <class T>
+bool GreaterThanFloat(T left, T right) {
+	// handle nans
+	// nan is always bigger than everything else
+	bool left_is_nan = Value::IsNan(left);
+	bool right_is_nan = Value::IsNan(right);
+	// if right is nan, there is no number that is bigger than right
+	if (DUCKDB_UNLIKELY(right_is_nan)) {
+		return false;
+	}
+	// if left is nan, but right is not, left is always bigger
+	if (DUCKDB_UNLIKELY(left_is_nan)) {
+		return true;
+	}
+	return left > right;
+}
+
+template <>
+bool GreaterThan::Operation(float left, float right) {
+	return GreaterThanFloat<float>(left, right);
+}
+
+template <>
+bool GreaterThan::Operation(double left, double right) {
+	return GreaterThanFloat<double>(left, right);
+}
+
+template <class T>
+bool GreaterThanEqualsFloat(T left, T right) {
+	// handle nans
+	// nan is always bigger than everything else
+	bool left_is_nan = Value::IsNan(left);
+	bool right_is_nan = Value::IsNan(right);
+	// if right is nan, there is no bigger number
+	// we only return true if left is also nan (in which case the numbers are equal)
+	if (DUCKDB_UNLIKELY(right_is_nan)) {
+		return left_is_nan;
+	}
+	// if left is nan, but right is not, left is always bigger
+	if (DUCKDB_UNLIKELY(left_is_nan)) {
+		return true;
+	}
+	return left >= right;
+}
+
+template <>
+bool GreaterThanEquals::Operation(float left, float right) {
+	return GreaterThanEqualsFloat<float>(left, right);
+}
+
+template <>
+bool GreaterThanEquals::Operation(double left, double right) {
+	return GreaterThanEqualsFloat<double>(left, right);
+}
+
 struct ComparisonSelector {
 	template <typename OP>
 	static idx_t Select(Vector &left, Vector &right, const SelectionVector *sel, idx_t count, SelectionVector *true_sel,
diff --git a/src/function/aggregate/algebraic/avg.cpp b/src/function/aggregate/algebraic/avg.cpp
index 90156a170a07..0b361ef22ccc 100644
--- a/src/function/aggregate/algebraic/avg.cpp
+++ b/src/function/aggregate/algebraic/avg.cpp
@@ -121,7 +121,7 @@ struct NumericAverageOperation : public BaseSumOperation<AverageSetOperation, Re
 		if (state->count == 0) {
 			mask.SetInvalid(idx);
 		} else {
-			if (!Value::DoubleIsValid(state->value)) {
+			if (!Value::DoubleIsFinite(state->value)) {
 				throw OutOfRangeException("AVG is out of range!");
 			}
 			target[idx] = (state->value / state->count);
@@ -135,7 +135,7 @@ struct KahanAverageOperation : public BaseSumOperation<AverageSetOperation, Kaha
 		if (state->count == 0) {
 			mask.SetInvalid(idx);
 		} else {
-			if (!Value::DoubleIsValid(state->value)) {
+			if (!Value::DoubleIsFinite(state->value)) {
 				throw OutOfRangeException("AVG is out of range!");
 			}
 			target[idx] = (state->value / state->count) + (state->err / state->count);
diff --git a/src/function/aggregate/distributive/kurtosis.cpp b/src/function/aggregate/distributive/kurtosis.cpp
index aa8cfabee530..72f40ee31bb1 100644
--- a/src/function/aggregate/distributive/kurtosis.cpp
+++ b/src/function/aggregate/distributive/kurtosis.cpp
@@ -74,8 +74,8 @@ struct KurtosisOperation {
 			mask.SetInvalid(idx);
 		} // LCOV_EXCL_STOP
 		target[idx] = (n - 1) * ((n + 1) * m4 / (m2 * m2) - 3 * (n - 1)) / ((n - 2) * (n - 3));
-		if (!Value::DoubleIsValid(target[idx])) {
-			mask.SetInvalid(idx);
+		if (!Value::DoubleIsFinite(target[idx])) {
+			throw OutOfRangeException("Kurtosis is out of range!");
 		}
 	}
 
diff --git a/src/function/aggregate/distributive/skew.cpp b/src/function/aggregate/distributive/skew.cpp
index 7f5c3d99bf4b..a1bd1282a4a1 100644
--- a/src/function/aggregate/distributive/skew.cpp
+++ b/src/function/aggregate/distributive/skew.cpp
@@ -65,8 +65,8 @@ struct SkewnessOperation {
 		target[idx] = temp1 * temp *
 		              (state->sum_cub - 3 * state->sum_sqr * state->sum * temp + 2 * pow(state->sum, 3) * temp * temp) /
 		              div;
-		if (!Value::DoubleIsValid(target[idx])) {
-			mask.SetInvalid(idx);
+		if (!Value::DoubleIsFinite(target[idx])) {
+			throw OutOfRangeException("SKEW is out of range!");
 		}
 	}
 
diff --git a/src/function/aggregate/distributive/sum.cpp b/src/function/aggregate/distributive/sum.cpp
index 8bb9af26936e..76472b797326 100644
--- a/src/function/aggregate/distributive/sum.cpp
+++ b/src/function/aggregate/distributive/sum.cpp
@@ -52,7 +52,7 @@ struct DoubleSumOperation : public BaseSumOperation<SumSetOperation, ADD_OPERATO
 		if (!state->isset) {
 			mask.SetInvalid(idx);
 		} else {
-			if (!Value::DoubleIsValid(state->value)) {
+			if (!Value::DoubleIsFinite(state->value)) {
 				throw OutOfRangeException("SUM is out of range!");
 			}
 			target[idx] = state->value;
diff --git a/src/function/aggregate/regression/regr_r2.cpp b/src/function/aggregate/regression/regr_r2.cpp
index 38663a453041..eae4318d60fa 100644
--- a/src/function/aggregate/regression/regr_r2.cpp
+++ b/src/function/aggregate/regression/regr_r2.cpp
@@ -42,7 +42,7 @@ struct RegrR2Operation {
 	template <class T, class STATE>
 	static void Finalize(Vector &result, FunctionData *fd, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
 		auto var_pop_x = state->var_pop_x.count > 1 ? (state->var_pop_x.dsquared / state->var_pop_x.count) : 0;
-		if (!Value::DoubleIsValid(var_pop_x)) {
+		if (!Value::DoubleIsFinite(var_pop_x)) {
 			throw OutOfRangeException("VARPOP(X) is out of range!");
 		}
 		if (var_pop_x == 0) {
@@ -50,7 +50,7 @@ struct RegrR2Operation {
 			return;
 		}
 		auto var_pop_y = state->var_pop_y.count > 1 ? (state->var_pop_y.dsquared / state->var_pop_y.count) : 0;
-		if (!Value::DoubleIsValid(var_pop_y)) {
+		if (!Value::DoubleIsFinite(var_pop_y)) {
 			throw OutOfRangeException("VARPOP(Y) is out of range!");
 		}
 		if (var_pop_y == 0) {
diff --git a/src/function/aggregate/regression/regr_sxx_syy.cpp b/src/function/aggregate/regression/regr_sxx_syy.cpp
index 21fd68c158de..abe41a47c166 100644
--- a/src/function/aggregate/regression/regr_sxx_syy.cpp
+++ b/src/function/aggregate/regression/regr_sxx_syy.cpp
@@ -34,7 +34,7 @@ struct RegrBaseOperation {
 			return;
 		}
 		auto var_pop = state->var_pop.count > 1 ? (state->var_pop.dsquared / state->var_pop.count) : 0;
-		if (!Value::DoubleIsValid(var_pop)) {
+		if (!Value::DoubleIsFinite(var_pop)) {
 			throw OutOfRangeException("VARPOP is out of range!");
 		}
 		RegrCountFunction::Finalize<T, size_t>(result, fd, &state->count, target, mask, idx);
diff --git a/src/function/scalar/math/numeric.cpp b/src/function/scalar/math/numeric.cpp
index 51f78c3f000a..406b33a5301b 100644
--- a/src/function/scalar/math/numeric.cpp
+++ b/src/function/scalar/math/numeric.cpp
@@ -7,6 +7,7 @@
 #include "duckdb/planner/expression/bound_function_expression.hpp"
 #include "duckdb/common/algorithm.hpp"
 #include "duckdb/execution/expression_executor.hpp"
+#include "duckdb/common/likely.hpp"
 #include <cmath>
 #include <errno.h>
 
@@ -37,51 +38,6 @@ static scalar_function_t GetScalarIntegerUnaryFunctionFixedReturn(const LogicalT
 	return function;
 }
 
-template <class OP>
-struct UnaryDoubleWrapper {
-	template <class INPUT_TYPE, class RESULT_TYPE>
-	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
-		RESULT_TYPE result = OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input);
-		if (std::isnan(result) || std::isinf(result) || errno != 0) {
-			errno = 0;
-			mask.SetInvalid(idx);
-			return 0;
-		}
-		return result;
-	}
-};
-
-template <class T, class OP>
-static void UnaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {
-	D_ASSERT(input.ColumnCount() >= 1);
-	errno = 0;
-	UnaryExecutor::GenericExecute<T, T, UnaryDoubleWrapper<OP>>(input.data[0], result, input.size(), nullptr, true);
-}
-
-struct BinaryDoubleWrapper {
-	template <class FUNC, class OP, class TA, class TB, class TR>
-	static inline TR Operation(FUNC fun, TA left, TB right, ValidityMask &mask, idx_t idx) {
-		TR result = OP::template Operation<TA, TB, TR>(left, right);
-		if (std::isnan(result) || std::isinf(result) || errno != 0) {
-			errno = 0;
-			mask.SetInvalid(idx);
-			return 0;
-		}
-		return result;
-	}
-
-	static bool AddsNulls() {
-		return true;
-	}
-};
-
-template <class T, class OP>
-static void BinaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {
-	D_ASSERT(input.ColumnCount() >= 2);
-	errno = 0;
-	BinaryExecutor::Execute<T, T, T, OP, BinaryDoubleWrapper>(input.data[0], input.data[1], result, input.size());
-}
-
 //===--------------------------------------------------------------------===//
 // nextafter
 //===--------------------------------------------------------------------===//
@@ -102,23 +58,14 @@ struct NextAfterOperator {
 	}
 };
 
-unique_ptr<FunctionData> BindNextAfter(ClientContext &context, ScalarFunction &function,
-                                       vector<unique_ptr<Expression>> &arguments) {
-	if ((arguments[0]->return_type != arguments[1]->return_type) ||
-	    (arguments[0]->return_type != LogicalType::FLOAT && arguments[0]->return_type != LogicalType::DOUBLE)) {
-		throw NotImplementedException("Unimplemented type for NextAfter Function");
-	}
-	return nullptr;
-}
-
 void NextAfterFun::RegisterFunction(BuiltinFunctions &set) {
 	ScalarFunctionSet next_after_fun("nextafter");
 	next_after_fun.AddFunction(
 	    ScalarFunction("nextafter", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                   BinaryDoubleFunctionWrapper<double, NextAfterOperator>, false, BindNextAfter));
+	                   ScalarFunction::BinaryFunction<double, double, double, NextAfterOperator>, false));
 	next_after_fun.AddFunction(ScalarFunction("nextafter", {LogicalType::FLOAT, LogicalType::FLOAT}, LogicalType::FLOAT,
-	                                          BinaryDoubleFunctionWrapper<float, NextAfterOperator>, false,
-	                                          BindNextAfter));
+	                                          ScalarFunction::BinaryFunction<float, float, float, NextAfterOperator>,
+	                                          false));
 	set.AddFunction(next_after_fun);
 }
 
@@ -195,10 +142,10 @@ void BitCountFun::RegisterFunction(BuiltinFunctions &set) {
 //===--------------------------------------------------------------------===//
 struct SignOperator {
 	template <class TA, class TR>
-	static inline TR Operation(TA left) {
-		if (left == TA(0)) {
+	static TR Operation(TA input) {
+		if (input == TA(0)) {
 			return 0;
-		} else if (left > TA(0)) {
+		} else if (input > TA(0)) {
 			return 1;
 		} else {
 			return -1;
@@ -206,6 +153,28 @@ struct SignOperator {
 	}
 };
 
+template <>
+int8_t SignOperator::Operation(float input) {
+	if (input == 0 || Value::IsNan(input)) {
+		return 0;
+	} else if (input > 0) {
+		return 1;
+	} else {
+		return -1;
+	}
+}
+
+template <>
+int8_t SignOperator::Operation(double input) {
+	if (input == 0 || Value::IsNan(input)) {
+		return 0;
+	} else if (input > 0) {
+		return 1;
+	} else {
+		return -1;
+	}
+}
+
 void SignFun::RegisterFunction(BuiltinFunctions &set) {
 	ScalarFunctionSet sign("sign");
 	for (auto &type : LogicalType::Numeric()) {
@@ -585,7 +554,7 @@ struct ExpOperator {
 
 void ExpFun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("exp", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, ExpOperator>));
+	                               ScalarFunction::UnaryFunction<double, double, ExpOperator>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -600,7 +569,7 @@ struct PowOperator {
 
 void PowFun::RegisterFunction(BuiltinFunctions &set) {
 	ScalarFunction power_function("pow", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                              BinaryDoubleFunctionWrapper<double, PowOperator>);
+	                              ScalarFunction::BinaryFunction<double, double, double, PowOperator>);
 	set.AddFunction(power_function);
 	power_function.name = "power";
 	set.AddFunction(power_function);
@@ -615,14 +584,17 @@ void PowFun::RegisterFunction(BuiltinFunctions &set) {
 //===--------------------------------------------------------------------===//
 struct SqrtOperator {
 	template <class TA, class TR>
-	static inline TR Operation(TA left) {
-		return std::sqrt(left);
+	static inline TR Operation(TA input) {
+		if (input < 0) {
+			throw OutOfRangeException("cannot take square root of a negative number");
+		}
+		return std::sqrt(input);
 	}
 };
 
 void SqrtFun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("sqrt", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, SqrtOperator>));
+	                               ScalarFunction::UnaryFunction<double, double, SqrtOperator>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -637,7 +609,7 @@ struct CbRtOperator {
 
 void CbrtFun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("cbrt", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, CbRtOperator>));
+	                               ScalarFunction::UnaryFunction<double, double, CbRtOperator>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -646,14 +618,20 @@ void CbrtFun::RegisterFunction(BuiltinFunctions &set) {
 
 struct LnOperator {
 	template <class TA, class TR>
-	static inline TR Operation(TA left) {
-		return std::log(left);
+	static inline TR Operation(TA input) {
+		if (input < 0) {
+			throw OutOfRangeException("cannot take logarithm of a negative number");
+		}
+		if (input == 0) {
+			throw OutOfRangeException("cannot take logarithm of zero");
+		}
+		return std::log(input);
 	}
 };
 
 void LnFun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("ln", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, LnOperator>));
+	                               ScalarFunction::UnaryFunction<double, double, LnOperator>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -661,14 +639,20 @@ void LnFun::RegisterFunction(BuiltinFunctions &set) {
 //===--------------------------------------------------------------------===//
 struct Log10Operator {
 	template <class TA, class TR>
-	static inline TR Operation(TA left) {
-		return std::log10(left);
+	static inline TR Operation(TA input) {
+		if (input < 0) {
+			throw OutOfRangeException("cannot take logarithm of a negative number");
+		}
+		if (input == 0) {
+			throw OutOfRangeException("cannot take logarithm of zero");
+		}
+		return std::log10(input);
 	}
 };
 
 void Log10Fun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction({"log10", "log"}, ScalarFunction({LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                                                 UnaryDoubleFunctionWrapper<double, Log10Operator>));
+	                                                 ScalarFunction::UnaryFunction<double, double, Log10Operator>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -676,14 +660,20 @@ void Log10Fun::RegisterFunction(BuiltinFunctions &set) {
 //===--------------------------------------------------------------------===//
 struct Log2Operator {
 	template <class TA, class TR>
-	static inline TR Operation(TA left) {
-		return std::log2(left);
+	static inline TR Operation(TA input) {
+		if (input < 0) {
+			throw OutOfRangeException("cannot take logarithm of a negative number");
+		}
+		if (input == 0) {
+			throw OutOfRangeException("cannot take logarithm of zero");
+		}
+		return std::log2(input);
 	}
 };
 
 void Log2Fun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("log2", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, Log2Operator>));
+	                               ScalarFunction::UnaryFunction<double, double, Log2Operator>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -711,7 +701,7 @@ struct DegreesOperator {
 
 void DegreesFun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("degrees", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, DegreesOperator>));
+	                               ScalarFunction::UnaryFunction<double, double, DegreesOperator>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -726,12 +716,83 @@ struct RadiansOperator {
 
 void RadiansFun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("radians", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, RadiansOperator>));
+	                               ScalarFunction::UnaryFunction<double, double, RadiansOperator>));
+}
+
+//===--------------------------------------------------------------------===//
+// isnan
+//===--------------------------------------------------------------------===//
+struct IsNanOperator {
+	template <class TA, class TR>
+	static inline TR Operation(TA input) {
+		return Value::IsNan(input);
+	}
+};
+
+void IsNanFun::RegisterFunction(BuiltinFunctions &set) {
+	ScalarFunctionSet funcs("isnan");
+	funcs.AddFunction(ScalarFunction({LogicalType::FLOAT}, LogicalType::BOOLEAN,
+	                                 ScalarFunction::UnaryFunction<float, bool, IsNanOperator>));
+	funcs.AddFunction(ScalarFunction({LogicalType::DOUBLE}, LogicalType::BOOLEAN,
+	                                 ScalarFunction::UnaryFunction<double, bool, IsNanOperator>));
+	set.AddFunction(funcs);
+}
+
+//===--------------------------------------------------------------------===//
+// isinf
+//===--------------------------------------------------------------------===//
+struct IsInfiniteOperator {
+	template <class TA, class TR>
+	static inline TR Operation(TA input) {
+		return !Value::IsNan(input) && !Value::IsFinite(input);
+	}
+};
+
+void IsInfiniteFun::RegisterFunction(BuiltinFunctions &set) {
+	ScalarFunctionSet funcs("isinf");
+	funcs.AddFunction(ScalarFunction({LogicalType::FLOAT}, LogicalType::BOOLEAN,
+	                                 ScalarFunction::UnaryFunction<float, bool, IsInfiniteOperator>));
+	funcs.AddFunction(ScalarFunction({LogicalType::DOUBLE}, LogicalType::BOOLEAN,
+	                                 ScalarFunction::UnaryFunction<double, bool, IsInfiniteOperator>));
+	set.AddFunction(funcs);
+}
+
+//===--------------------------------------------------------------------===//
+// isfinite
+//===--------------------------------------------------------------------===//
+struct IsFiniteOperator {
+	template <class TA, class TR>
+	static inline TR Operation(TA input) {
+		return Value::IsFinite(input);
+	}
+};
+
+void IsFiniteFun::RegisterFunction(BuiltinFunctions &set) {
+	ScalarFunctionSet funcs("isfinite");
+	funcs.AddFunction(ScalarFunction({LogicalType::FLOAT}, LogicalType::BOOLEAN,
+	                                 ScalarFunction::UnaryFunction<float, bool, IsFiniteOperator>));
+	funcs.AddFunction(ScalarFunction({LogicalType::DOUBLE}, LogicalType::BOOLEAN,
+	                                 ScalarFunction::UnaryFunction<double, bool, IsFiniteOperator>));
+	set.AddFunction(funcs);
 }
 
 //===--------------------------------------------------------------------===//
 // sin
 //===--------------------------------------------------------------------===//
+template <class OP>
+struct NoInfiniteDoubleWrapper {
+	template <class INPUT_TYPE, class RESULT_TYPE>
+	static RESULT_TYPE Operation(INPUT_TYPE input) {
+		if (DUCKDB_UNLIKELY(!Value::IsFinite(input))) {
+			if (Value::IsNan(input)) {
+				return input;
+			}
+			throw OutOfRangeException("input value %lf is out of range for numeric function", input);
+		}
+		return OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input);
+	}
+};
+
 struct SinOperator {
 	template <class TA, class TR>
 	static inline TR Operation(TA input) {
@@ -740,8 +801,9 @@ struct SinOperator {
 };
 
 void SinFun::RegisterFunction(BuiltinFunctions &set) {
-	set.AddFunction(ScalarFunction("sin", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, SinOperator>));
+	set.AddFunction(
+	    ScalarFunction("sin", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
+	                   ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<SinOperator>>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -755,8 +817,9 @@ struct CosOperator {
 };
 
 void CosFun::RegisterFunction(BuiltinFunctions &set) {
-	set.AddFunction(ScalarFunction("cos", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, CosOperator>));
+	set.AddFunction(
+	    ScalarFunction("cos", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
+	                   ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<CosOperator>>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -770,8 +833,9 @@ struct TanOperator {
 };
 
 void TanFun::RegisterFunction(BuiltinFunctions &set) {
-	set.AddFunction(ScalarFunction("tan", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, TanOperator>));
+	set.AddFunction(
+	    ScalarFunction("tan", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
+	                   ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<TanOperator>>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -788,8 +852,9 @@ struct ASinOperator {
 };
 
 void AsinFun::RegisterFunction(BuiltinFunctions &set) {
-	set.AddFunction(ScalarFunction("asin", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, ASinOperator>));
+	set.AddFunction(
+	    ScalarFunction("asin", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
+	                   ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<ASinOperator>>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -804,7 +869,7 @@ struct ATanOperator {
 
 void AtanFun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("atan", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, ATanOperator>));
+	                               ScalarFunction::UnaryFunction<double, double, ATanOperator>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -819,7 +884,7 @@ struct ATan2 {
 
 void Atan2Fun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("atan2", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               BinaryDoubleFunctionWrapper<double, ATan2>));
+	                               ScalarFunction::BinaryFunction<double, double, double, ATan2>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -833,8 +898,8 @@ struct ACos {
 };
 
 void AcosFun::RegisterFunction(BuiltinFunctions &set) {
-	set.AddFunction(
-	    ScalarFunction("acos", {LogicalType::DOUBLE}, LogicalType::DOUBLE, UnaryDoubleFunctionWrapper<double, ACos>));
+	set.AddFunction(ScalarFunction("acos", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
+	                               ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<ACos>>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -848,8 +913,9 @@ struct CotOperator {
 };
 
 void CotFun::RegisterFunction(BuiltinFunctions &set) {
-	set.AddFunction(ScalarFunction("cot", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, CotOperator>));
+	set.AddFunction(
+	    ScalarFunction("cot", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
+	                   ScalarFunction::UnaryFunction<double, double, NoInfiniteDoubleWrapper<CotOperator>>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -857,14 +923,17 @@ void CotFun::RegisterFunction(BuiltinFunctions &set) {
 //===--------------------------------------------------------------------===//
 struct GammaOperator {
 	template <class TA, class TR>
-	static inline TR Operation(TA left) {
-		return std::tgamma(left);
+	static inline TR Operation(TA input) {
+		if (input == 0) {
+			throw OutOfRangeException("cannot take gamma of zero");
+		}
+		return std::tgamma(input);
 	}
 };
 
 void GammaFun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("gamma", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, GammaOperator>));
+	                               ScalarFunction::UnaryFunction<double, double, GammaOperator>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -872,14 +941,17 @@ void GammaFun::RegisterFunction(BuiltinFunctions &set) {
 //===--------------------------------------------------------------------===//
 struct LogGammaOperator {
 	template <class TA, class TR>
-	static inline TR Operation(TA left) {
-		return std::lgamma(left);
+	static inline TR Operation(TA input) {
+		if (input == 0) {
+			throw OutOfRangeException("cannot take log gamma of zero");
+		}
+		return std::lgamma(input);
 	}
 };
 
 void LogGammaFun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("lgamma", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, LogGammaOperator>));
+	                               ScalarFunction::UnaryFunction<double, double, LogGammaOperator>));
 }
 
 //===--------------------------------------------------------------------===//
@@ -929,7 +1001,7 @@ struct EvenOperator {
 
 void EvenFun::RegisterFunction(BuiltinFunctions &set) {
 	set.AddFunction(ScalarFunction("even", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
-	                               UnaryDoubleFunctionWrapper<double, EvenOperator>));
+	                               ScalarFunction::UnaryFunction<double, double, EvenOperator>));
 }
 
 } // namespace duckdb
diff --git a/src/function/scalar/math_functions.cpp b/src/function/scalar/math_functions.cpp
index dc0bbb899314..3750303b79ab 100644
--- a/src/function/scalar/math_functions.cpp
+++ b/src/function/scalar/math_functions.cpp
@@ -36,6 +36,10 @@ void BuiltinFunctions::RegisterMathFunctions() {
 	Register<NextAfterFun>();
 
 	Register<EvenFun>();
+
+	Register<IsNanFun>();
+	Register<IsInfiniteFun>();
+	Register<IsFiniteFun>();
 }
 
 } // namespace duckdb
diff --git a/src/function/scalar/operators/add.cpp b/src/function/scalar/operators/add.cpp
index 67afe8c8c98b..8c87513dd23e 100644
--- a/src/function/scalar/operators/add.cpp
+++ b/src/function/scalar/operators/add.cpp
@@ -19,7 +19,7 @@ namespace duckdb {
 template <>
 float AddOperator::Operation(float left, float right) {
 	auto result = left + right;
-	if (!Value::FloatIsValid(result)) {
+	if (!Value::FloatIsFinite(result)) {
 		throw OutOfRangeException("Overflow in addition of float!");
 	}
 	return result;
@@ -28,7 +28,7 @@ float AddOperator::Operation(float left, float right) {
 template <>
 double AddOperator::Operation(double left, double right) {
 	auto result = left + right;
-	if (!Value::DoubleIsValid(result)) {
+	if (!Value::DoubleIsFinite(result)) {
 		throw OutOfRangeException("Overflow in addition of double!");
 	}
 	return result;
diff --git a/src/function/scalar/operators/arithmetic.cpp b/src/function/scalar/operators/arithmetic.cpp
index c88a5af739f2..e9650f142829 100644
--- a/src/function/scalar/operators/arithmetic.cpp
+++ b/src/function/scalar/operators/arithmetic.cpp
@@ -366,6 +366,16 @@ struct NegateOperator {
 	}
 };
 
+template <>
+bool NegateOperator::CanNegate(float input) {
+	return Value::FloatIsFinite(input);
+}
+
+template <>
+bool NegateOperator::CanNegate(double input) {
+	return Value::DoubleIsFinite(input);
+}
+
 template <>
 interval_t NegateOperator::Operation(interval_t input) {
 	interval_t result;
@@ -691,7 +701,7 @@ void MultiplyFun::RegisterFunction(BuiltinFunctions &set) {
 template <>
 float DivideOperator::Operation(float left, float right) {
 	auto result = left / right;
-	if (!Value::FloatIsValid(result)) {
+	if (!Value::FloatIsFinite(result)) {
 		throw OutOfRangeException("Overflow in division of float!");
 	}
 	return result;
@@ -700,7 +710,7 @@ float DivideOperator::Operation(float left, float right) {
 template <>
 double DivideOperator::Operation(double left, double right) {
 	auto result = left / right;
-	if (!Value::DoubleIsValid(result)) {
+	if (!Value::DoubleIsFinite(result)) {
 		throw OutOfRangeException("Overflow in division of double!");
 	}
 	return result;
@@ -812,13 +822,21 @@ void DivideFun::RegisterFunction(BuiltinFunctions &set) {
 template <>
 float ModuloOperator::Operation(float left, float right) {
 	D_ASSERT(right != 0);
-	return std::fmod(left, right);
+	auto result = std::fmod(left, right);
+	if (!Value::FloatIsFinite(result)) {
+		throw OutOfRangeException("Overflow in modulo of float!");
+	}
+	return result;
 }
 
 template <>
 double ModuloOperator::Operation(double left, double right) {
 	D_ASSERT(right != 0);
-	return std::fmod(left, right);
+	auto result = std::fmod(left, right);
+	if (!Value::DoubleIsFinite(result)) {
+		throw OutOfRangeException("Overflow in modulo of double!");
+	}
+	return result;
 }
 
 template <>
diff --git a/src/function/scalar/operators/multiply.cpp b/src/function/scalar/operators/multiply.cpp
index d8f3e38a0c30..47442aa9c737 100644
--- a/src/function/scalar/operators/multiply.cpp
+++ b/src/function/scalar/operators/multiply.cpp
@@ -16,7 +16,7 @@ namespace duckdb {
 template <>
 float MultiplyOperator::Operation(float left, float right) {
 	auto result = left * right;
-	if (!Value::FloatIsValid(result)) {
+	if (!Value::FloatIsFinite(result)) {
 		throw OutOfRangeException("Overflow in multiplication of float!");
 	}
 	return result;
@@ -25,7 +25,7 @@ float MultiplyOperator::Operation(float left, float right) {
 template <>
 double MultiplyOperator::Operation(double left, double right) {
 	auto result = left * right;
-	if (!Value::DoubleIsValid(result)) {
+	if (!Value::DoubleIsFinite(result)) {
 		throw OutOfRangeException("Overflow in multiplication of double!");
 	}
 	return result;
diff --git a/src/function/scalar/operators/subtract.cpp b/src/function/scalar/operators/subtract.cpp
index 6a370bb9af59..601f95fb3878 100644
--- a/src/function/scalar/operators/subtract.cpp
+++ b/src/function/scalar/operators/subtract.cpp
@@ -16,7 +16,7 @@ namespace duckdb {
 template <>
 float SubtractOperator::Operation(float left, float right) {
 	auto result = left - right;
-	if (!Value::FloatIsValid(result)) {
+	if (!Value::FloatIsFinite(result)) {
 		throw OutOfRangeException("Overflow in subtraction of float!");
 	}
 	return result;
@@ -25,7 +25,7 @@ float SubtractOperator::Operation(float left, float right) {
 template <>
 double SubtractOperator::Operation(double left, double right) {
 	auto result = left - right;
-	if (!Value::DoubleIsValid(result)) {
+	if (!Value::DoubleIsFinite(result)) {
 		throw OutOfRangeException("Overflow in subtraction of double!");
 	}
 	return result;
diff --git a/src/function/table/arrow.cpp b/src/function/table/arrow.cpp
index 7c6530aaca36..fa8a09e71366 100644
--- a/src/function/table/arrow.cpp
+++ b/src/function/table/arrow.cpp
@@ -590,6 +590,7 @@ void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanState &scan
 	case LogicalTypeId::SMALLINT:
 	case LogicalTypeId::INTEGER:
 	case LogicalTypeId::FLOAT:
+	case LogicalTypeId::DOUBLE:
 	case LogicalTypeId::UTINYINT:
 	case LogicalTypeId::USMALLINT:
 	case LogicalTypeId::UINTEGER:
@@ -603,18 +604,6 @@ void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanState &scan
 		DirectConversion(vector, array, scan_state, nested_offset);
 		break;
 	}
-	case LogicalTypeId::DOUBLE: {
-		DirectConversion(vector, array, scan_state, nested_offset);
-		//! Need to check if there are NaNs, if yes, must turn that to null
-		auto data = (double *)vector.GetData();
-		auto &mask = FlatVector::Validity(vector);
-		for (idx_t row_idx = 0; row_idx < size; row_idx++) {
-			if (!Value::DoubleIsValid(data[row_idx])) {
-				mask.SetInvalid(row_idx);
-			}
-		}
-		break;
-	}
 	case LogicalTypeId::JSON:
 	case LogicalTypeId::VARCHAR: {
 		auto original_type = arrow_convert_data[col_idx]->variable_sz_type[arrow_convert_idx.first++];
diff --git a/src/include/duckdb/common/operator/comparison_operators.hpp b/src/include/duckdb/common/operator/comparison_operators.hpp
index 7b7028463cd2..a3d44e6bea00 100644
--- a/src/include/duckdb/common/operator/comparison_operators.hpp
+++ b/src/include/duckdb/common/operator/comparison_operators.hpp
@@ -30,15 +30,17 @@ struct Equals {
 struct NotEquals {
 	template <class T>
 	static inline bool Operation(T left, T right) {
-		return left != right;
+		return !Equals::Operation(left, right);
 	}
 };
+
 struct GreaterThan {
 	template <class T>
 	static inline bool Operation(T left, T right) {
 		return left > right;
 	}
 };
+
 struct GreaterThanEquals {
 	template <class T>
 	static inline bool Operation(T left, T right) {
@@ -49,30 +51,46 @@ struct GreaterThanEquals {
 struct LessThan {
 	template <class T>
 	static inline bool Operation(T left, T right) {
-		return left < right;
+		return GreaterThan::Operation(right, left);
 	}
 };
+
 struct LessThanEquals {
 	template <class T>
 	static inline bool Operation(T left, T right) {
-		return left <= right;
+		return GreaterThanEquals::Operation(right, left);
 	}
 };
 
+template <>
+bool Equals::Operation(float left, float right);
+template <>
+bool Equals::Operation(double left, double right);
+
+template <>
+bool GreaterThan::Operation(float left, float right);
+template <>
+bool GreaterThan::Operation(double left, double right);
+
+template <>
+bool GreaterThanEquals::Operation(float left, float right);
+template <>
+bool GreaterThanEquals::Operation(double left, double right);
+
 // Distinct semantics are from Postgres record sorting. NULL = NULL and not-NULL < NULL
 // Deferring to the non-distinct operations removes the need for further specialisation.
 // TODO: To reverse the semantics, swap left_null and right_null for comparisons
 struct DistinctFrom {
 	template <class T>
 	static inline bool Operation(T left, T right, bool left_null, bool right_null) {
-		return (left_null != right_null) || (!left_null && !right_null && (left != right));
+		return (left_null != right_null) || (!left_null && !right_null && NotEquals::Operation(left, right));
 	}
 };
 
 struct NotDistinctFrom {
 	template <class T>
 	static inline bool Operation(T left, T right, bool left_null, bool right_null) {
-		return (left_null && right_null) || (!left_null && !right_null && (left == right));
+		return (left_null && right_null) || (!left_null && !right_null && Equals::Operation(left, right));
 	}
 };
 
diff --git a/src/include/duckdb/common/operator/numeric_cast.hpp b/src/include/duckdb/common/operator/numeric_cast.hpp
index 8f545cb83eeb..9edcc765d2d3 100644
--- a/src/include/duckdb/common/operator/numeric_cast.hpp
+++ b/src/include/duckdb/common/operator/numeric_cast.hpp
@@ -10,11 +10,15 @@
 
 #include "duckdb/common/operator/cast_operators.hpp"
 #include "duckdb/common/types/hugeint.hpp"
+#include "duckdb/common/types/value.hpp"
 
 namespace duckdb {
 
 template <class SRC, class DST>
 static bool TryCastWithOverflowCheck(SRC value, DST &result) {
+	if (!Value::IsFinite<SRC>(value)) {
+		return false;
+	}
 	if (NumericLimits<SRC>::IsSigned() != NumericLimits<DST>::IsSigned()) {
 		if (NumericLimits<SRC>::IsSigned()) {
 			// signed to unsigned conversion
@@ -57,40 +61,58 @@ static bool TryCastWithOverflowCheck(SRC value, DST &result) {
 	}
 }
 
-template <>
-bool TryCastWithOverflowCheck(float value, int32_t &result) {
-	if (!(value >= -2147483648.0f && value < 2147483648.0f)) {
+template <class SRC, class T>
+bool TryCastWithOverflowCheckFloat(SRC value, T &result, SRC min, SRC max) {
+	if (!Value::IsFinite<SRC>(value)) {
 		return false;
 	}
-	result = int32_t(value);
+	if (!(value >= min && value < max)) {
+		return false;
+	}
+	result = T(value);
 	return true;
 }
 
+template <>
+bool TryCastWithOverflowCheck(float value, int32_t &result) {
+	return TryCastWithOverflowCheckFloat<float, int32_t>(value, result, -2147483648.0f, 2147483648.0f);
+}
+
 template <>
 bool TryCastWithOverflowCheck(float value, int64_t &result) {
-	if (!(value >= -9223372036854775808.0f && value < 9223372036854775808.0f)) {
-		return false;
-	}
-	result = int64_t(value);
-	return true;
+	return TryCastWithOverflowCheckFloat<float, int64_t>(value, result, -9223372036854775808.0f,
+	                                                     9223372036854775808.0f);
 }
 
 template <>
 bool TryCastWithOverflowCheck(double value, int64_t &result) {
-	if (!(value >= -9223372036854775808.0 && value < 9223372036854775808.0)) {
-		return false;
-	}
-	result = int64_t(value);
+	return TryCastWithOverflowCheckFloat<double, int64_t>(value, result, -9223372036854775808.0, 9223372036854775808.0);
+}
+
+template <>
+bool TryCastWithOverflowCheck(float input, float &result) {
+	result = input;
+	return true;
+}
+template <>
+bool TryCastWithOverflowCheck(float input, double &result) {
+	result = double(input);
+	return true;
+}
+template <>
+bool TryCastWithOverflowCheck(double input, double &result) {
+	result = input;
 	return true;
 }
 
 template <>
 bool TryCastWithOverflowCheck(double input, float &result) {
-	if (input < (double)NumericLimits<float>::Minimum() || input > (double)NumericLimits<float>::Maximum()) {
-		return false;
+	if (!Value::IsFinite(input)) {
+		result = float(input);
+		return true;
 	}
-	auto res = (float)input;
-	if (std::isnan(res) || std::isinf(res)) {
+	auto res = float(input);
+	if (!Value::FloatIsFinite(input)) {
 		return false;
 	}
 	result = res;
diff --git a/src/include/duckdb/common/types/value.hpp b/src/include/duckdb/common/types/value.hpp
index 4c16c5b79805..9b67fd136ef8 100644
--- a/src/include/duckdb/common/types/value.hpp
+++ b/src/include/duckdb/common/types/value.hpp
@@ -222,17 +222,20 @@ class Value {
 	DUCKDB_API bool operator<=(const int64_t &rhs) const;
 	DUCKDB_API bool operator>=(const int64_t &rhs) const;
 
-	DUCKDB_API static bool FloatIsValid(float value);
-	DUCKDB_API static bool DoubleIsValid(double value);
-	DUCKDB_API static bool StringIsValid(const char *str, idx_t length);
-	static bool StringIsValid(const string &str) {
-		return StringIsValid(str.c_str(), str.size());
+	DUCKDB_API static bool FloatIsFinite(float value);
+	DUCKDB_API static bool DoubleIsFinite(double value);
+	template <class T>
+	static bool IsNan(T value) {
+		throw InternalException("Unimplemented template type for Value::IsNan");
 	}
-
 	template <class T>
-	static bool IsValid(T value) {
+	static bool IsFinite(T value) {
 		return true;
 	}
+	DUCKDB_API static bool StringIsValid(const char *str, idx_t length);
+	static bool StringIsValid(const string &str) {
+		return StringIsValid(str.c_str(), str.size());
+	}
 
 	//! Returns true if the values are (approximately) equivalent. Note this is NOT the SQL equivalence. For this
 	//! function, NULL values are equivalent and floating point values that are close are equivalent.
@@ -519,8 +522,13 @@ template <>
 DUCKDB_API interval_t &Value::GetReferenceUnsafe();
 
 template <>
-DUCKDB_API bool Value::IsValid(float value);
+DUCKDB_API bool Value::IsNan(float input);
+template <>
+DUCKDB_API bool Value::IsNan(double input);
+
+template <>
+DUCKDB_API bool Value::IsFinite(float input);
 template <>
-DUCKDB_API bool Value::IsValid(double value);
+DUCKDB_API bool Value::IsFinite(double input);
 
 } // namespace duckdb
diff --git a/src/include/duckdb/function/aggregate/algebraic/corr.hpp b/src/include/duckdb/function/aggregate/algebraic/corr.hpp
index 0d87f1d44b0b..d62d6af92410 100644
--- a/src/include/duckdb/function/aggregate/algebraic/corr.hpp
+++ b/src/include/duckdb/function/aggregate/algebraic/corr.hpp
@@ -54,12 +54,12 @@ struct CorrOperation {
 		} else {
 			auto cov = state->cov_pop.co_moment / state->cov_pop.count;
 			auto std_x = state->dev_pop_x.count > 1 ? sqrt(state->dev_pop_x.dsquared / state->dev_pop_x.count) : 0;
-			if (!Value::DoubleIsValid(std_x)) {
-				throw OutOfRangeException("STDDEV_POP for X is invalid!");
+			if (!Value::DoubleIsFinite(std_x)) {
+				throw OutOfRangeException("STDDEV_POP for X is out of range!");
 			}
 			auto std_y = state->dev_pop_y.count > 1 ? sqrt(state->dev_pop_y.dsquared / state->dev_pop_y.count) : 0;
-			if (!Value::DoubleIsValid(std_y)) {
-				throw OutOfRangeException("STDDEV_POP for Y is invalid!");
+			if (!Value::DoubleIsFinite(std_y)) {
+				throw OutOfRangeException("STDDEV_POP for Y is out of range!");
 			}
 			if (std_x * std_y == 0) {
 				mask.SetInvalid(idx);
diff --git a/src/include/duckdb/function/aggregate/algebraic/stddev.hpp b/src/include/duckdb/function/aggregate/algebraic/stddev.hpp
index edc688b63ba5..3594823d67b2 100644
--- a/src/include/duckdb/function/aggregate/algebraic/stddev.hpp
+++ b/src/include/duckdb/function/aggregate/algebraic/stddev.hpp
@@ -79,7 +79,7 @@ struct VarSampOperation : public STDDevBaseOperation {
 			mask.SetInvalid(idx);
 		} else {
 			target[idx] = state->dsquared / (state->count - 1);
-			if (!Value::DoubleIsValid(target[idx])) {
+			if (!Value::DoubleIsFinite(target[idx])) {
 				throw OutOfRangeException("VARSAMP is out of range!");
 			}
 		}
@@ -93,7 +93,7 @@ struct VarPopOperation : public STDDevBaseOperation {
 			mask.SetInvalid(idx);
 		} else {
 			target[idx] = state->count > 1 ? (state->dsquared / state->count) : 0;
-			if (!Value::DoubleIsValid(target[idx])) {
+			if (!Value::DoubleIsFinite(target[idx])) {
 				throw OutOfRangeException("VARPOP is out of range!");
 			}
 		}
@@ -107,7 +107,7 @@ struct STDDevSampOperation : public STDDevBaseOperation {
 			mask.SetInvalid(idx);
 		} else {
 			target[idx] = sqrt(state->dsquared / (state->count - 1));
-			if (!Value::DoubleIsValid(target[idx])) {
+			if (!Value::DoubleIsFinite(target[idx])) {
 				throw OutOfRangeException("STDDEV_SAMP is out of range!");
 			}
 		}
@@ -121,7 +121,7 @@ struct STDDevPopOperation : public STDDevBaseOperation {
 			mask.SetInvalid(idx);
 		} else {
 			target[idx] = state->count > 1 ? sqrt(state->dsquared / state->count) : 0;
-			if (!Value::DoubleIsValid(target[idx])) {
+			if (!Value::DoubleIsFinite(target[idx])) {
 				throw OutOfRangeException("STDDEV_POP is out of range!");
 			}
 		}
@@ -135,7 +135,7 @@ struct StandardErrorOfTheMeanOperation : public STDDevBaseOperation {
 			mask.SetInvalid(idx);
 		} else {
 			target[idx] = sqrt(state->dsquared / state->count) / sqrt((state->count));
-			if (!Value::DoubleIsValid(target[idx])) {
+			if (!Value::DoubleIsFinite(target[idx])) {
 				throw OutOfRangeException("SEM is out of range!");
 			}
 		}
diff --git a/src/include/duckdb/function/aggregate/regression/regr_slope.hpp b/src/include/duckdb/function/aggregate/regression/regr_slope.hpp
index f27f00d2b076..e9a2a17e9a0d 100644
--- a/src/include/duckdb/function/aggregate/regression/regr_slope.hpp
+++ b/src/include/duckdb/function/aggregate/regression/regr_slope.hpp
@@ -45,7 +45,7 @@ struct RegrSlopeOperation {
 		} else {
 			auto cov = state->cov_pop.co_moment / state->cov_pop.count;
 			auto var_pop = state->var_pop.count > 1 ? (state->var_pop.dsquared / state->var_pop.count) : 0;
-			if (!Value::DoubleIsValid(var_pop)) {
+			if (!Value::DoubleIsFinite(var_pop)) {
 				throw OutOfRangeException("VARPOP is out of range!");
 			}
 			if (var_pop == 0) {
diff --git a/src/include/duckdb/function/scalar/math_functions.hpp b/src/include/duckdb/function/scalar/math_functions.hpp
index e75785c75b84..37594429ca0d 100644
--- a/src/include/duckdb/function/scalar/math_functions.hpp
+++ b/src/include/duckdb/function/scalar/math_functions.hpp
@@ -105,4 +105,16 @@ struct EvenFun {
 	static void RegisterFunction(BuiltinFunctions &set);
 };
 
+struct IsNanFun {
+	static void RegisterFunction(BuiltinFunctions &set);
+};
+
+struct IsInfiniteFun {
+	static void RegisterFunction(BuiltinFunctions &set);
+};
+
+struct IsFiniteFun {
+	static void RegisterFunction(BuiltinFunctions &set);
+};
+
 } // namespace duckdb
diff --git a/src/main/appender.cpp b/src/main/appender.cpp
index d182621a19c4..12e57ceadcfc 100644
--- a/src/main/appender.cpp
+++ b/src/main/appender.cpp
@@ -208,17 +208,11 @@ void BaseAppender::Append(string_t value) {
 
 template <>
 void BaseAppender::Append(float value) {
-	if (!Value::FloatIsValid(value)) {
-		throw InvalidInputException("Float value is out of range!");
-	}
 	AppendValueInternal<float>(value);
 }
 
 template <>
 void BaseAppender::Append(double value) {
-	if (!Value::DoubleIsValid(value)) {
-		throw InvalidInputException("Double value is out of range!");
-	}
 	AppendValueInternal<double>(value);
 }
 
diff --git a/src/main/capi/hugeint-c.cpp b/src/main/capi/hugeint-c.cpp
index fc3d0b249291..253190039aae 100644
--- a/src/main/capi/hugeint-c.cpp
+++ b/src/main/capi/hugeint-c.cpp
@@ -16,7 +16,7 @@ double duckdb_hugeint_to_double(duckdb_hugeint val) {
 
 duckdb_hugeint duckdb_double_to_hugeint(double val) {
 	hugeint_t internal_result;
-	if (!Value::DoubleIsValid(val) || !Hugeint::TryConvert<double>(val, internal_result)) {
+	if (!Value::DoubleIsFinite(val) || !Hugeint::TryConvert<double>(val, internal_result)) {
 		internal_result.lower = 0;
 		internal_result.upper = 0;
 	}
diff --git a/src/main/capi/prepared-c.cpp b/src/main/capi/prepared-c.cpp
index ac6ad15004bd..0df1f4e9da2f 100644
--- a/src/main/capi/prepared-c.cpp
+++ b/src/main/capi/prepared-c.cpp
@@ -112,16 +112,10 @@ duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, id
 }
 
 duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val) {
-	if (!Value::FloatIsValid(val)) {
-		return DuckDBError;
-	}
 	return duckdb_bind_value(prepared_statement, param_idx, Value::FLOAT(val));
 }
 
 duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val) {
-	if (!Value::DoubleIsValid(val)) {
-		return DuckDBError;
-	}
 	return duckdb_bind_value(prepared_statement, param_idx, Value::DOUBLE(val));
 }
 
diff --git a/src/main/query_profiler.cpp b/src/main/query_profiler.cpp
index 86b6672d5dcc..f72bb3127ed0 100644
--- a/src/main/query_profiler.cpp
+++ b/src/main/query_profiler.cpp
@@ -239,7 +239,7 @@ void OperatorProfiler::AddTiming(const PhysicalOperator *op, double time, idx_t
 	if (!enabled) {
 		return;
 	}
-	if (!Value::DoubleIsValid(time)) {
+	if (!Value::DoubleIsFinite(time)) {
 		return;
 	}
 	auto entry = timings.find(op);
diff --git a/src/parser/transform/expression/transform_constant.cpp b/src/parser/transform/expression/transform_constant.cpp
index be3c73329f4f..ef1af6fde7dc 100644
--- a/src/parser/transform/expression/transform_constant.cpp
+++ b/src/parser/transform/expression/transform_constant.cpp
@@ -63,9 +63,6 @@ unique_ptr<ConstantExpression> Transformer::TransformValue(duckdb_libpgquery::PG
 		}
 		// if there is a decimal or the value is too big to cast as either hugeint or bigint
 		double dbl_value = Cast::Operation<string_t, double>(str_val);
-		if (!Value::DoubleIsValid(dbl_value)) {
-			throw ParserException("Double value \"%s\" is out of range!", val.val.str);
-		}
 		return make_unique<ConstantExpression>(Value::DOUBLE(dbl_value));
 	}
 	case duckdb_libpgquery::T_PGNull:
diff --git a/tools/pythonpkg/src/vector_conversion.cpp b/tools/pythonpkg/src/vector_conversion.cpp
index 66496fb1903a..b68041434244 100644
--- a/tools/pythonpkg/src/vector_conversion.cpp
+++ b/tools/pythonpkg/src/vector_conversion.cpp
@@ -68,12 +68,12 @@ bool ValueIsNull(T value) {
 
 template <>
 bool ValueIsNull(float value) {
-	return !Value::FloatIsValid(value);
+	return !Value::FloatIsFinite(value);
 }
 
 template <>
 bool ValueIsNull(double value) {
-	return !Value::DoubleIsValid(value);
+	return !Value::DoubleIsFinite(value);
 }
 
 template <class T>
