You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Support NaN and Infinity in floating point columns
After some discussion we want to remove the restriction we have on floating point columns where NaN and infinity values are not allowed (#530).

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of extension/parquet/column_writer.cpp]
1: #include "column_writer.hpp"
2: #include "parquet_writer.hpp"
3: #include "parquet_rle_bp_decoder.hpp"
4: #include "parquet_rle_bp_encoder.hpp"
5: 
6: #include "duckdb.hpp"
7: #ifndef DUCKDB_AMALGAMATION
8: #include "duckdb/common/common.hpp"
9: #include "duckdb/common/exception.hpp"
10: #include "duckdb/common/mutex.hpp"
11: #include "duckdb/common/serializer/buffered_file_writer.hpp"
12: #include "duckdb/common/types/chunk_collection.hpp"
13: #include "duckdb/common/types/date.hpp"
14: #include "duckdb/common/types/hugeint.hpp"
15: #include "duckdb/common/types/time.hpp"
16: #include "duckdb/common/types/timestamp.hpp"
17: #include "duckdb/common/serializer/buffered_serializer.hpp"
18: #include "duckdb/common/operator/comparison_operators.hpp"
19: #endif
20: 
21: #include "snappy.h"
22: #include "miniz_wrapper.hpp"
23: #include "zstd.h"
24: 
25: namespace duckdb {
26: 
27: using namespace duckdb_parquet; // NOLINT
28: using namespace duckdb_miniz;   // NOLINT
29: 
30: using duckdb_parquet::format::CompressionCodec;
31: using duckdb_parquet::format::ConvertedType;
32: using duckdb_parquet::format::Encoding;
33: using duckdb_parquet::format::FieldRepetitionType;
34: using duckdb_parquet::format::FileMetaData;
35: using duckdb_parquet::format::PageHeader;
36: using duckdb_parquet::format::PageType;
37: using ParquetRowGroup = duckdb_parquet::format::RowGroup;
38: using duckdb_parquet::format::Type;
39: 
40: #define PARQUET_DEFINE_VALID 65535
41: 
42: static void VarintEncode(uint32_t val, Serializer &ser) {
43: 	do {
44: 		uint8_t byte = val & 127;
45: 		val >>= 7;
46: 		if (val != 0) {
47: 			byte |= 128;
48: 		}
49: 		ser.Write<uint8_t>(byte);
50: 	} while (val != 0);
51: }
52: 
53: static uint8_t GetVarintSize(uint32_t val) {
54: 	uint8_t res = 0;
55: 	do {
56: 		uint8_t byte = val & 127;
57: 		val >>= 7;
58: 		if (val != 0) {
59: 			byte |= 128;
60: 		}
61: 		res++;
62: 	} while (val != 0);
63: 	return res;
64: }
65: 
66: //===--------------------------------------------------------------------===//
67: // ColumnWriterStatistics
68: //===--------------------------------------------------------------------===//
69: ColumnWriterStatistics::~ColumnWriterStatistics() {
70: }
71: 
72: string ColumnWriterStatistics::GetMin() {
73: 	return string();
74: }
75: 
76: string ColumnWriterStatistics::GetMax() {
77: 	return string();
78: }
79: 
80: string ColumnWriterStatistics::GetMinValue() {
81: 	return string();
82: }
83: 
84: string ColumnWriterStatistics::GetMaxValue() {
85: 	return string();
86: }
87: 
88: //===--------------------------------------------------------------------===//
89: // RleBpEncoder
90: //===--------------------------------------------------------------------===//
91: RleBpEncoder::RleBpEncoder(uint32_t bit_width)
92:     : byte_width((bit_width + 7) / 8), byte_count(idx_t(-1)), run_count(idx_t(-1)) {
93: }
94: 
95: // we always RLE everything (for now)
96: void RleBpEncoder::BeginPrepare(uint32_t first_value) {
97: 	byte_count = 0;
98: 	run_count = 1;
99: 	current_run_count = 1;
100: 	last_value = first_value;
101: }
102: 
103: void RleBpEncoder::FinishRun() {
104: 	// last value, or value has changed
105: 	// write out the current run
106: 	byte_count += GetVarintSize(current_run_count << 1) + byte_width;
107: 	current_run_count = 1;
108: 	run_count++;
109: }
110: 
111: void RleBpEncoder::PrepareValue(uint32_t value) {
112: 	if (value != last_value) {
113: 		FinishRun();
114: 		last_value = value;
115: 	} else {
116: 		current_run_count++;
117: 	}
118: }
119: 
120: void RleBpEncoder::FinishPrepare() {
121: 	FinishRun();
122: }
123: 
124: idx_t RleBpEncoder::GetByteCount() {
125: 	D_ASSERT(byte_count != idx_t(-1));
126: 	return byte_count;
127: }
128: 
129: void RleBpEncoder::BeginWrite(Serializer &writer, uint32_t first_value) {
130: 	// start the RLE runs
131: 	last_value = first_value;
132: 	current_run_count = 1;
133: }
134: 
135: void RleBpEncoder::WriteRun(Serializer &writer) {
136: 	// write the header of the run
137: 	VarintEncode(current_run_count << 1, writer);
138: 	// now write the value
139: 	switch (byte_width) {
140: 	case 1:
141: 		writer.Write<uint8_t>(last_value);
142: 		break;
143: 	case 2:
144: 		writer.Write<uint16_t>(last_value);
145: 		break;
146: 	case 3:
147: 		writer.Write<uint8_t>(last_value & 0xFF);
148: 		writer.Write<uint8_t>((last_value >> 8) & 0xFF);
149: 		writer.Write<uint8_t>((last_value >> 16) & 0xFF);
150: 		break;
151: 	case 4:
152: 		writer.Write<uint32_t>(last_value);
153: 		break;
154: 	default:
155: 		throw InternalException("unsupported byte width for RLE encoding");
156: 	}
157: 	current_run_count = 1;
158: }
159: 
160: void RleBpEncoder::WriteValue(Serializer &writer, uint32_t value) {
161: 	if (value != last_value) {
162: 		WriteRun(writer);
163: 		last_value = value;
164: 	} else {
165: 		current_run_count++;
166: 	}
167: }
168: 
169: void RleBpEncoder::FinishWrite(Serializer &writer) {
170: 	WriteRun(writer);
171: }
172: 
173: //===--------------------------------------------------------------------===//
174: // ColumnWriter
175: //===--------------------------------------------------------------------===//
176: ColumnWriter::ColumnWriter(ParquetWriter &writer, idx_t schema_idx, vector<string> schema_path_p, idx_t max_repeat,
177:                            idx_t max_define, bool can_have_nulls)
178:     : writer(writer), schema_idx(schema_idx), schema_path(move(schema_path_p)), max_repeat(max_repeat),
179:       max_define(max_define), can_have_nulls(can_have_nulls), null_count(0) {
180: }
181: ColumnWriter::~ColumnWriter() {
182: }
183: 
184: ColumnWriterState::~ColumnWriterState() {
185: }
186: 
187: void ColumnWriter::CompressPage(BufferedSerializer &temp_writer, size_t &compressed_size, data_ptr_t &compressed_data,
188:                                 unique_ptr<data_t[]> &compressed_buf) {
189: 	switch (writer.codec) {
190: 	case CompressionCodec::UNCOMPRESSED:
191: 		compressed_size = temp_writer.blob.size;
192: 		compressed_data = temp_writer.blob.data.get();
193: 		break;
194: 	case CompressionCodec::SNAPPY: {
195: 		compressed_size = duckdb_snappy::MaxCompressedLength(temp_writer.blob.size);
196: 		compressed_buf = unique_ptr<data_t[]>(new data_t[compressed_size]);
197: 		duckdb_snappy::RawCompress((const char *)temp_writer.blob.data.get(), temp_writer.blob.size,
198: 		                           (char *)compressed_buf.get(), &compressed_size);
199: 		compressed_data = compressed_buf.get();
200: 		D_ASSERT(compressed_size <= duckdb_snappy::MaxCompressedLength(temp_writer.blob.size));
201: 		break;
202: 	}
203: 	case CompressionCodec::GZIP: {
204: 		MiniZStream s;
205: 		compressed_size = s.MaxCompressedLength(temp_writer.blob.size);
206: 		compressed_buf = unique_ptr<data_t[]>(new data_t[compressed_size]);
207: 		s.Compress((const char *)temp_writer.blob.data.get(), temp_writer.blob.size, (char *)compressed_buf.get(),
208: 		           &compressed_size);
209: 		compressed_data = compressed_buf.get();
210: 		break;
211: 	}
212: 	case CompressionCodec::ZSTD: {
213: 		compressed_size = duckdb_zstd::ZSTD_compressBound(temp_writer.blob.size);
214: 		compressed_buf = unique_ptr<data_t[]>(new data_t[compressed_size]);
215: 		compressed_size = duckdb_zstd::ZSTD_compress((void *)compressed_buf.get(), compressed_size,
216: 		                                             (const void *)temp_writer.blob.data.get(), temp_writer.blob.size,
217: 		                                             ZSTD_CLEVEL_DEFAULT);
218: 		compressed_data = compressed_buf.get();
219: 		break;
220: 	}
221: 	default:
222: 		throw InternalException("Unsupported codec for Parquet Writer");
223: 	}
224: 
225: 	if (compressed_size > idx_t(NumericLimits<int32_t>::Maximum())) {
226: 		throw InternalException("Parquet writer: %d compressed page size out of range for type integer",
227: 		                        temp_writer.blob.size);
228: 	}
229: }
230: 
231: class ColumnWriterPageState {
232: public:
233: 	virtual ~ColumnWriterPageState() {
234: 	}
235: };
236: 
237: struct PageInformation {
238: 	idx_t offset = 0;
239: 	idx_t row_count = 0;
240: 	idx_t empty_count = 0;
241: 	idx_t estimated_page_size = 0;
242: };
243: 
244: struct PageWriteInformation {
245: 	PageHeader page_header;
246: 	unique_ptr<BufferedSerializer> temp_writer;
247: 	unique_ptr<ColumnWriterPageState> page_state;
248: 	idx_t write_page_idx = 0;
249: 	idx_t write_count = 0;
250: 	idx_t max_write_count = 0;
251: 	size_t compressed_size;
252: 	data_ptr_t compressed_data;
253: 	unique_ptr<data_t[]> compressed_buf;
254: };
255: 
256: class StandardColumnWriterState : public ColumnWriterState {
257: public:
258: 	StandardColumnWriterState(duckdb_parquet::format::RowGroup &row_group, idx_t col_idx)
259: 	    : row_group(row_group), col_idx(col_idx) {
260: 		page_info.emplace_back();
261: 	}
262: 	~StandardColumnWriterState() override = default;
263: 
264: 	duckdb_parquet::format::RowGroup &row_group;
265: 	idx_t col_idx;
266: 	vector<PageInformation> page_info;
267: 	vector<PageWriteInformation> write_info;
268: 	unique_ptr<ColumnWriterStatistics> stats_state;
269: 	idx_t current_page = 0;
270: };
271: 
272: unique_ptr<ColumnWriterState> ColumnWriter::InitializeWriteState(duckdb_parquet::format::RowGroup &row_group) {
273: 	auto result = make_unique<StandardColumnWriterState>(row_group, row_group.columns.size());
274: 
275: 	duckdb_parquet::format::ColumnChunk column_chunk;
276: 	column_chunk.__isset.meta_data = true;
277: 	column_chunk.meta_data.codec = writer.codec;
278: 	column_chunk.meta_data.path_in_schema = schema_path;
279: 	column_chunk.meta_data.num_values = 0;
280: 	column_chunk.meta_data.type = writer.file_meta_data.schema[schema_idx].type;
281: 	row_group.columns.push_back(move(column_chunk));
282: 
283: 	return move(result);
284: }
285: 
286: void ColumnWriter::HandleRepeatLevels(ColumnWriterState &state, ColumnWriterState *parent, idx_t count,
287:                                       idx_t max_repeat) {
288: 	if (!parent) {
289: 		// no repeat levels without a parent node
290: 		return;
291: 	}
292: 	while (state.repetition_levels.size() < parent->repetition_levels.size()) {
293: 		state.repetition_levels.push_back(parent->repetition_levels[state.repetition_levels.size()]);
294: 	}
295: }
296: 
297: void ColumnWriter::HandleDefineLevels(ColumnWriterState &state, ColumnWriterState *parent, ValidityMask &validity,
298:                                       idx_t count, uint16_t define_value, uint16_t null_value) {
299: 	if (parent) {
300: 		// parent node: inherit definition level from the parent
301: 		idx_t vector_index = 0;
302: 		while (state.definition_levels.size() < parent->definition_levels.size()) {
303: 			idx_t current_index = state.definition_levels.size();
304: 			if (parent->definition_levels[current_index] != PARQUET_DEFINE_VALID) {
305: 				state.definition_levels.push_back(parent->definition_levels[current_index]);
306: 			} else if (validity.RowIsValid(vector_index)) {
307: 				state.definition_levels.push_back(define_value);
308: 			} else {
309: 				if (!can_have_nulls) {
310: 					throw IOException("Parquet writer: map key column is not allowed to contain NULL values");
311: 				}
312: 				null_count++;
313: 				state.definition_levels.push_back(null_value);
314: 			}
315: 			if (parent->is_empty.empty() || !parent->is_empty[current_index]) {
316: 				vector_index++;
317: 			}
318: 		}
319: 	} else {
320: 		// no parent: set definition levels only from this validity mask
321: 		for (idx_t i = 0; i < count; i++) {
322: 			if (validity.RowIsValid(i)) {
323: 				state.definition_levels.push_back(define_value);
324: 			} else {
325: 				if (!can_have_nulls) {
326: 					throw IOException("Parquet writer: map key column is not allowed to contain NULL values");
327: 				}
328: 				null_count++;
329: 				state.definition_levels.push_back(null_value);
330: 			}
331: 		}
332: 	}
333: }
334: 
335: void ColumnWriter::Prepare(ColumnWriterState &state_p, ColumnWriterState *parent, Vector &vector, idx_t count) {
336: 	auto &state = (StandardColumnWriterState &)state_p;
337: 	auto &col_chunk = state.row_group.columns[state.col_idx];
338: 
339: 	idx_t start = 0;
340: 	idx_t vcount = parent ? parent->definition_levels.size() - state.definition_levels.size() : count;
341: 	idx_t parent_index = state.definition_levels.size();
342: 	auto &validity = FlatVector::Validity(vector);
343: 	HandleRepeatLevels(state_p, parent, count, max_repeat);
344: 	HandleDefineLevels(state_p, parent, validity, count, max_define, max_define - 1);
345: 
346: 	idx_t vector_index = 0;
347: 	for (idx_t i = start; i < vcount; i++) {
348: 		auto &page_info = state.page_info.back();
349: 		page_info.row_count++;
350: 		col_chunk.meta_data.num_values++;
351: 		if (parent && !parent->is_empty.empty() && parent->is_empty[parent_index + i]) {
352: 			page_info.empty_count++;
353: 			continue;
354: 		}
355: 		if (validity.RowIsValid(vector_index)) {
356: 			page_info.estimated_page_size += GetRowSize(vector, vector_index);
357: 			if (page_info.estimated_page_size >= MAX_UNCOMPRESSED_PAGE_SIZE) {
358: 				PageInformation new_info;
359: 				new_info.offset = page_info.offset + page_info.row_count;
360: 				state.page_info.push_back(new_info);
361: 			}
362: 		}
363: 		vector_index++;
364: 	}
365: }
366: 
367: unique_ptr<ColumnWriterPageState> ColumnWriter::InitializePageState() {
368: 	return nullptr;
369: }
370: 
371: void ColumnWriter::FlushPageState(Serializer &temp_writer, ColumnWriterPageState *state) {
372: }
373: 
374: duckdb_parquet::format::Encoding::type ColumnWriter::GetEncoding() {
375: 	return Encoding::PLAIN;
376: }
377: 
378: void ColumnWriter::BeginWrite(ColumnWriterState &state_p) {
379: 	auto &state = (StandardColumnWriterState &)state_p;
380: 
381: 	// set up the page write info
382: 	state.stats_state = InitializeStatsState();
383: 	for (idx_t page_idx = 0; page_idx < state.page_info.size(); page_idx++) {
384: 		auto &page_info = state.page_info[page_idx];
385: 		if (page_info.row_count == 0) {
386: 			D_ASSERT(page_idx + 1 == state.page_info.size());
387: 			state.page_info.erase(state.page_info.begin() + page_idx);
388: 			break;
389: 		}
390: 		PageWriteInformation write_info;
391: 		// set up the header
392: 		auto &hdr = write_info.page_header;
393: 		hdr.compressed_page_size = 0;
394: 		hdr.uncompressed_page_size = 0;
395: 		hdr.type = PageType::DATA_PAGE;
396: 		hdr.__isset.data_page_header = true;
397: 
398: 		hdr.data_page_header.num_values = page_info.row_count;
399: 		hdr.data_page_header.encoding = GetEncoding();
400: 		hdr.data_page_header.definition_level_encoding = Encoding::RLE;
401: 		hdr.data_page_header.repetition_level_encoding = Encoding::RLE;
402: 
403: 		write_info.temp_writer = make_unique<BufferedSerializer>();
404: 		write_info.write_count = page_info.empty_count;
405: 		write_info.max_write_count = page_info.row_count;
406: 		write_info.page_state = InitializePageState();
407: 
408: 		write_info.compressed_size = 0;
409: 		write_info.compressed_data = nullptr;
410: 
411: 		state.write_info.push_back(move(write_info));
412: 	}
413: 
414: 	// start writing the first page
415: 	NextPage(state_p);
416: }
417: 
418: void ColumnWriter::WriteLevels(Serializer &temp_writer, const vector<uint16_t> &levels, idx_t max_value, idx_t offset,
419:                                idx_t count) {
420: 	if (levels.empty() || count == 0) {
421: 		return;
422: 	}
423: 
424: 	// write the levels using the RLE-BP encoding
425: 	auto bit_width = RleBpDecoder::ComputeBitWidth((max_value));
426: 	RleBpEncoder rle_encoder(bit_width);
427: 
428: 	rle_encoder.BeginPrepare(levels[offset]);
429: 	for (idx_t i = offset + 1; i < offset + count; i++) {
430: 		rle_encoder.PrepareValue(levels[i]);
431: 	}
432: 	rle_encoder.FinishPrepare();
433: 
434: 	// start off by writing the byte count as a uint32_t
435: 	temp_writer.Write<uint32_t>(rle_encoder.GetByteCount());
436: 	rle_encoder.BeginWrite(temp_writer, levels[offset]);
437: 	for (idx_t i = offset + 1; i < offset + count; i++) {
438: 		rle_encoder.WriteValue(temp_writer, levels[i]);
439: 	}
440: 	rle_encoder.FinishWrite(temp_writer);
441: }
442: 
443: void ColumnWriter::NextPage(ColumnWriterState &state_p) {
444: 	auto &state = (StandardColumnWriterState &)state_p;
445: 
446: 	if (state.current_page > 0) {
447: 		// need to flush the current page
448: 		FlushPage(state_p);
449: 	}
450: 	if (state.current_page >= state.write_info.size()) {
451: 		state.current_page = state.write_info.size() + 1;
452: 		return;
453: 	}
454: 	auto &page_info = state.page_info[state.current_page];
455: 	auto &write_info = state.write_info[state.current_page];
456: 	state.current_page++;
457: 
458: 	auto &temp_writer = *write_info.temp_writer;
459: 
460: 	// write the repetition levels
461: 	WriteLevels(temp_writer, state.repetition_levels, max_repeat, page_info.offset, page_info.row_count);
462: 
463: 	// write the definition levels
464: 	WriteLevels(temp_writer, state.definition_levels, max_define, page_info.offset, page_info.row_count);
465: }
466: 
467: void ColumnWriter::FlushPage(ColumnWriterState &state_p) {
468: 	auto &state = (StandardColumnWriterState &)state_p;
469: 	D_ASSERT(state.current_page > 0);
470: 	if (state.current_page > state.write_info.size()) {
471: 		return;
472: 	}
473: 
474: 	// compress the page info
475: 	auto &write_info = state.write_info[state.current_page - 1];
476: 	auto &temp_writer = *write_info.temp_writer;
477: 	auto &hdr = write_info.page_header;
478: 
479: 	FlushPageState(temp_writer, write_info.page_state.get());
480: 
481: 	// now that we have finished writing the data we know the uncompressed size
482: 	if (temp_writer.blob.size > idx_t(NumericLimits<int32_t>::Maximum())) {
483: 		throw InternalException("Parquet writer: %d uncompressed page size out of range for type integer",
484: 		                        temp_writer.blob.size);
485: 	}
486: 	hdr.uncompressed_page_size = temp_writer.blob.size;
487: 
488: 	// compress the data
489: 	CompressPage(temp_writer, write_info.compressed_size, write_info.compressed_data, write_info.compressed_buf);
490: 	hdr.compressed_page_size = write_info.compressed_size;
491: 	D_ASSERT(hdr.uncompressed_page_size > 0);
492: 	D_ASSERT(hdr.compressed_page_size > 0);
493: 
494: 	if (write_info.compressed_buf) {
495: 		// if the data has been compressed, we no longer need the compressed data
496: 		D_ASSERT(write_info.compressed_buf.get() == write_info.compressed_data);
497: 		write_info.temp_writer.reset();
498: 	}
499: }
500: 
501: unique_ptr<ColumnWriterStatistics> ColumnWriter::InitializeStatsState() {
502: 	return make_unique<ColumnWriterStatistics>();
503: }
504: 
505: void ColumnWriter::WriteVector(Serializer &temp_writer, ColumnWriterStatistics *stats,
506:                                ColumnWriterPageState *page_state, Vector &input_column, idx_t chunk_start,
507:                                idx_t chunk_end) {
508: 	throw InternalException("WriteVector unsupported for struct/list column writers");
509: }
510: 
511: idx_t ColumnWriter::GetRowSize(Vector &vector, idx_t index) {
512: 	throw InternalException("GetRowSize unsupported for struct/list column writers");
513: }
514: 
515: void ColumnWriter::Write(ColumnWriterState &state_p, Vector &vector, idx_t count) {
516: 	auto &state = (StandardColumnWriterState &)state_p;
517: 
518: 	idx_t remaining = count;
519: 	idx_t offset = 0;
520: 	while (remaining > 0) {
521: 		auto &write_info = state.write_info[state.current_page - 1];
522: 		if (!write_info.temp_writer) {
523: 			throw InternalException("Writes are not correctly aligned!?");
524: 		}
525: 		auto &temp_writer = *write_info.temp_writer;
526: 		idx_t write_count = MinValue<idx_t>(remaining, write_info.max_write_count - write_info.write_count);
527: 		D_ASSERT(write_count > 0);
528: 
529: 		WriteVector(temp_writer, state.stats_state.get(), write_info.page_state.get(), vector, offset,
530: 		            offset + write_count);
531: 
532: 		write_info.write_count += write_count;
533: 		if (write_info.write_count == write_info.max_write_count) {
534: 			NextPage(state_p);
535: 		}
536: 		offset += write_count;
537: 		remaining -= write_count;
538: 	}
539: }
540: 
541: void ColumnWriter::SetParquetStatistics(StandardColumnWriterState &state,
542:                                         duckdb_parquet::format::ColumnChunk &column_chunk) {
543: 	if (max_repeat == 0) {
544: 		column_chunk.meta_data.statistics.null_count = null_count;
545: 		column_chunk.meta_data.statistics.__isset.null_count = true;
546: 		column_chunk.meta_data.__isset.statistics = true;
547: 	}
548: 	// set min/max/min_value/max_value
549: 	// this code is not going to win any beauty contests, but well
550: 	auto min = state.stats_state->GetMin();
551: 	if (!min.empty()) {
552: 		column_chunk.meta_data.statistics.min = move(min);
553: 		column_chunk.meta_data.statistics.__isset.min = true;
554: 		column_chunk.meta_data.__isset.statistics = true;
555: 	}
556: 	auto max = state.stats_state->GetMax();
557: 	if (!max.empty()) {
558: 		column_chunk.meta_data.statistics.max = move(max);
559: 		column_chunk.meta_data.statistics.__isset.max = true;
560: 		column_chunk.meta_data.__isset.statistics = true;
561: 	}
562: 	auto min_value = state.stats_state->GetMinValue();
563: 	if (!min_value.empty()) {
564: 		column_chunk.meta_data.statistics.min_value = move(min_value);
565: 		column_chunk.meta_data.statistics.__isset.min_value = true;
566: 		column_chunk.meta_data.__isset.statistics = true;
567: 	}
568: 	auto max_value = state.stats_state->GetMaxValue();
569: 	if (!max_value.empty()) {
570: 		column_chunk.meta_data.statistics.max_value = move(max_value);
571: 		column_chunk.meta_data.statistics.__isset.max_value = true;
572: 		column_chunk.meta_data.__isset.statistics = true;
573: 	}
574: }
575: 
576: void ColumnWriter::FinalizeWrite(ColumnWriterState &state_p) {
577: 	auto &state = (StandardColumnWriterState &)state_p;
578: 	auto &column_chunk = state.row_group.columns[state.col_idx];
579: 
580: 	// flush the last page (if any remains)
581: 	FlushPage(state);
582: 	// flush the dictionary
583: 	FlushDictionary(state, state.stats_state.get());
584: 
585: 	// record the start position of the pages for this column
586: 	column_chunk.meta_data.data_page_offset = writer.writer->GetTotalWritten();
587: 	SetParquetStatistics(state, column_chunk);
588: 
589: 	// write the individual pages to disk
590: 	for (auto &write_info : state.write_info) {
591: 		D_ASSERT(write_info.page_header.uncompressed_page_size > 0);
592: 		write_info.page_header.write(writer.protocol.get());
593: 		writer.writer->WriteData(write_info.compressed_data, write_info.compressed_size);
594: 	}
595: 	column_chunk.meta_data.total_compressed_size =
596: 	    writer.writer->GetTotalWritten() - column_chunk.meta_data.data_page_offset;
597: }
598: 
599: void ColumnWriter::WriteDictionary(ColumnWriterState &state_p, unique_ptr<BufferedSerializer> temp_writer,
600:                                    idx_t row_count) {
601: 	auto &state = (StandardColumnWriterState &)state_p;
602: 	D_ASSERT(temp_writer);
603: 	D_ASSERT(temp_writer->blob.size > 0);
604: 
605: 	// write the dictionary page header
606: 	PageWriteInformation write_info;
607: 	// set up the header
608: 	auto &hdr = write_info.page_header;
609: 	hdr.uncompressed_page_size = temp_writer->blob.size;
610: 	hdr.type = PageType::DICTIONARY_PAGE;
611: 	hdr.__isset.dictionary_page_header = true;
612: 
613: 	hdr.dictionary_page_header.encoding = Encoding::PLAIN;
614: 	hdr.dictionary_page_header.is_sorted = false;
615: 	hdr.dictionary_page_header.num_values = row_count;
616: 
617: 	write_info.temp_writer = move(temp_writer);
618: 	write_info.write_count = 0;
619: 	write_info.max_write_count = 0;
620: 
621: 	// compress the contents of the dictionary page
622: 	CompressPage(*write_info.temp_writer, write_info.compressed_size, write_info.compressed_data,
623: 	             write_info.compressed_buf);
624: 	hdr.compressed_page_size = write_info.compressed_size;
625: 
626: 	// insert the dictionary page as the first page to write for this column
627: 	state.write_info.insert(state.write_info.begin(), move(write_info));
628: }
629: 
630: void ColumnWriter::FlushDictionary(ColumnWriterState &state, ColumnWriterStatistics *stats) {
631: 	// nop: standard pages do not have a dictionary
632: }
633: 
634: //===--------------------------------------------------------------------===//
635: // Standard Column Writer
636: //===--------------------------------------------------------------------===//
637: template <class SRC, class T, class OP>
638: class NumericStatisticsState : public ColumnWriterStatistics {
639: public:
640: 	NumericStatisticsState() : min(NumericLimits<T>::Maximum()), max(NumericLimits<T>::Minimum()) {
641: 	}
642: 
643: 	T min;
644: 	T max;
645: 
646: public:
647: 	bool HasStats() {
648: 		return min <= max;
649: 	}
650: 
651: 	string GetMin() override {
652: 		return NumericLimits<SRC>::IsSigned() ? GetMinValue() : string();
653: 	}
654: 	string GetMax() override {
655: 		return NumericLimits<SRC>::IsSigned() ? GetMaxValue() : string();
656: 	}
657: 	string GetMinValue() override {
658: 		return HasStats() ? string((char *)&min, sizeof(T)) : string();
659: 	}
660: 	string GetMaxValue() override {
661: 		return HasStats() ? string((char *)&max, sizeof(T)) : string();
662: 	}
663: };
664: 
665: struct BaseParquetOperator {
666: 	template <class SRC, class TGT>
667: 	static unique_ptr<ColumnWriterStatistics> InitializeStats() {
668: 		return make_unique<NumericStatisticsState<SRC, TGT, BaseParquetOperator>>();
669: 	}
670: 
671: 	template <class SRC, class TGT>
672: 	static void HandleStats(ColumnWriterStatistics *stats, SRC source_value, TGT target_value) {
673: 		auto &numeric_stats = (NumericStatisticsState<SRC, TGT, BaseParquetOperator> &)*stats;
674: 		if (LessThan::Operation(target_value, numeric_stats.min)) {
675: 			numeric_stats.min = target_value;
676: 		}
677: 		if (GreaterThan::Operation(target_value, numeric_stats.max)) {
678: 			numeric_stats.max = target_value;
679: 		}
680: 	}
681: };
682: 
683: struct ParquetCastOperator : public BaseParquetOperator {
684: 	template <class SRC, class TGT>
685: 	static TGT Operation(SRC input) {
686: 		return TGT(input);
687: 	}
688: };
689: 
690: struct ParquetTimestampNSOperator : public BaseParquetOperator {
691: 	template <class SRC, class TGT>
692: 	static TGT Operation(SRC input) {
693: 		return Timestamp::FromEpochNanoSeconds(input).value;
694: 	}
695: };
696: 
697: struct ParquetTimestampSOperator : public BaseParquetOperator {
698: 	template <class SRC, class TGT>
699: 	static TGT Operation(SRC input) {
700: 		return Timestamp::FromEpochSeconds(input).value;
701: 	}
702: };
703: 
704: struct ParquetHugeintOperator {
705: 	template <class SRC, class TGT>
706: 	static TGT Operation(SRC input) {
707: 		return Hugeint::Cast<double>(input);
708: 	}
709: 
710: 	template <class SRC, class TGT>
711: 	static unique_ptr<ColumnWriterStatistics> InitializeStats() {
712: 		return make_unique<ColumnWriterStatistics>();
713: 	}
714: 
715: 	template <class SRC, class TGT>
716: 	static void HandleStats(ColumnWriterStatistics *stats, SRC source_value, TGT target_value) {
717: 	}
718: };
719: 
720: template <class SRC, class TGT, class OP = ParquetCastOperator>
721: static void TemplatedWritePlain(Vector &col, ColumnWriterStatistics *stats, idx_t chunk_start, idx_t chunk_end,
722:                                 ValidityMask &mask, Serializer &ser) {
723: 	auto *ptr = FlatVector::GetData<SRC>(col);
724: 	for (idx_t r = chunk_start; r < chunk_end; r++) {
725: 		if (mask.RowIsValid(r)) {
726: 			TGT target_value = OP::template Operation<SRC, TGT>(ptr[r]);
727: 			OP::template HandleStats<SRC, TGT>(stats, ptr[r], target_value);
728: 			ser.Write<TGT>(target_value);
729: 		}
730: 	}
731: }
732: 
733: template <class SRC, class TGT, class OP = ParquetCastOperator>
734: class StandardColumnWriter : public ColumnWriter {
735: public:
736: 	StandardColumnWriter(ParquetWriter &writer, idx_t schema_idx, vector<string> schema_path_p, // NOLINT
737: 	                     idx_t max_repeat, idx_t max_define, bool can_have_nulls)
738: 	    : ColumnWriter(writer, schema_idx, move(schema_path_p), max_repeat, max_define, can_have_nulls) {
739: 	}
740: 	~StandardColumnWriter() override = default;
741: 
742: public:
743: 	unique_ptr<ColumnWriterStatistics> InitializeStatsState() override {
744: 		return OP::template InitializeStats<SRC, TGT>();
745: 	}
746: 
747: 	void WriteVector(Serializer &temp_writer, ColumnWriterStatistics *stats, ColumnWriterPageState *page_state,
748: 	                 Vector &input_column, idx_t chunk_start, idx_t chunk_end) override {
749: 		auto &mask = FlatVector::Validity(input_column);
750: 		TemplatedWritePlain<SRC, TGT, OP>(input_column, stats, chunk_start, chunk_end, mask, temp_writer);
751: 	}
752: 
753: 	idx_t GetRowSize(Vector &vector, idx_t index) override {
754: 		return sizeof(TGT);
755: 	}
756: };
757: 
758: //===--------------------------------------------------------------------===//
759: // Boolean Column Writer
760: //===--------------------------------------------------------------------===//
761: class BooleanStatisticsState : public ColumnWriterStatistics {
762: public:
763: 	BooleanStatisticsState() : min(true), max(false) {
764: 	}
765: 
766: 	bool min;
767: 	bool max;
768: 
769: public:
770: 	bool HasStats() {
771: 		return !(min && !max);
772: 	}
773: 
774: 	string GetMin() override {
775: 		return GetMinValue();
776: 	}
777: 	string GetMax() override {
778: 		return GetMaxValue();
779: 	}
780: 	string GetMinValue() override {
781: 		return HasStats() ? string((char *)&min, sizeof(bool)) : string();
782: 	}
783: 	string GetMaxValue() override {
784: 		return HasStats() ? string((char *)&max, sizeof(bool)) : string();
785: 	}
786: };
787: 
788: class BooleanWriterPageState : public ColumnWriterPageState {
789: public:
790: 	uint8_t byte = 0;
791: 	uint8_t byte_pos = 0;
792: };
793: 
794: class BooleanColumnWriter : public ColumnWriter {
795: public:
796: 	BooleanColumnWriter(ParquetWriter &writer, idx_t schema_idx, vector<string> schema_path_p, idx_t max_repeat,
797: 	                    idx_t max_define, bool can_have_nulls)
798: 	    : ColumnWriter(writer, schema_idx, move(schema_path_p), max_repeat, max_define, can_have_nulls) {
799: 	}
800: 	~BooleanColumnWriter() override = default;
801: 
802: public:
803: 	unique_ptr<ColumnWriterStatistics> InitializeStatsState() override {
804: 		return make_unique<BooleanStatisticsState>();
805: 	}
806: 
807: 	void WriteVector(Serializer &temp_writer, ColumnWriterStatistics *stats_p, ColumnWriterPageState *state_p,
808: 	                 Vector &input_column, idx_t chunk_start, idx_t chunk_end) override {
809: 		auto &stats = (BooleanStatisticsState &)*stats_p;
810: 		auto &state = (BooleanWriterPageState &)*state_p;
811: 		auto &mask = FlatVector::Validity(input_column);
812: 
813: 		auto *ptr = FlatVector::GetData<bool>(input_column);
814: 		for (idx_t r = chunk_start; r < chunk_end; r++) {
815: 			if (mask.RowIsValid(r)) {
816: 				// only encode if non-null
817: 				if (ptr[r]) {
818: 					stats.max = true;
819: 					state.byte |= 1 << state.byte_pos;
820: 				} else {
821: 					stats.min = false;
822: 				}
823: 				state.byte_pos++;
824: 
825: 				if (state.byte_pos == 8) {
826: 					temp_writer.Write<uint8_t>(state.byte);
827: 					state.byte = 0;
828: 					state.byte_pos = 0;
829: 				}
830: 			}
831: 		}
832: 	}
833: 
834: 	unique_ptr<ColumnWriterPageState> InitializePageState() override {
835: 		return make_unique<BooleanWriterPageState>();
836: 	}
837: 
838: 	void FlushPageState(Serializer &temp_writer, ColumnWriterPageState *state_p) override {
839: 		auto &state = (BooleanWriterPageState &)*state_p;
840: 		if (state.byte_pos > 0) {
841: 			temp_writer.Write<uint8_t>(state.byte);
842: 			state.byte = 0;
843: 			state.byte_pos = 0;
844: 		}
845: 	}
846: 
847: 	idx_t GetRowSize(Vector &vector, idx_t index) override {
848: 		return sizeof(bool);
849: 	}
850: };
851: 
852: //===--------------------------------------------------------------------===//
853: // Decimal Column Writer
854: //===--------------------------------------------------------------------===//
855: static void WriteParquetDecimal(hugeint_t input, data_ptr_t result) {
856: 	bool positive = input >= 0;
857: 	// numbers are stored as two's complement so some muckery is required
858: 	if (!positive) {
859: 		input = NumericLimits<hugeint_t>::Maximum() + input + 1;
860: 	}
861: 	uint64_t high_bytes = uint64_t(input.upper);
862: 	uint64_t low_bytes = input.lower;
863: 
864: 	for (idx_t i = 0; i < sizeof(uint64_t); i++) {
865: 		auto shift_count = (sizeof(uint64_t) - i - 1) * 8;
866: 		result[i] = (high_bytes >> shift_count) & 0xFF;
867: 	}
868: 	for (idx_t i = 0; i < sizeof(uint64_t); i++) {
869: 		auto shift_count = (sizeof(uint64_t) - i - 1) * 8;
870: 		result[sizeof(uint64_t) + i] = (low_bytes >> shift_count) & 0xFF;
871: 	}
872: 	if (!positive) {
873: 		result[0] |= 0x80;
874: 	}
875: }
876: 
877: class FixedDecimalStatistics : public ColumnWriterStatistics {
878: public:
879: 	FixedDecimalStatistics() : min(NumericLimits<hugeint_t>::Maximum()), max(NumericLimits<hugeint_t>::Minimum()) {
880: 	}
881: 
882: 	hugeint_t min;
883: 	hugeint_t max;
884: 
885: public:
886: 	string GetStats(hugeint_t &input) {
887: 		data_t buffer[16];
888: 		WriteParquetDecimal(input, buffer);
889: 		return string((char *)buffer, 16);
890: 	}
891: 
892: 	bool HasStats() {
893: 		return min <= max;
894: 	}
895: 
896: 	void Update(hugeint_t &val) {
897: 		if (LessThan::Operation(val, min)) {
898: 			min = val;
899: 		}
900: 		if (GreaterThan::Operation(val, max)) {
901: 			max = val;
902: 		}
903: 	}
904: 
905: 	string GetMin() override {
906: 		return GetMinValue();
907: 	}
908: 	string GetMax() override {
909: 		return GetMaxValue();
910: 	}
911: 	string GetMinValue() override {
912: 		return HasStats() ? GetStats(min) : string();
913: 	}
914: 	string GetMaxValue() override {
915: 		return HasStats() ? GetStats(max) : string();
916: 	}
917: };
918: 
919: class FixedDecimalColumnWriter : public ColumnWriter {
920: public:
921: 	FixedDecimalColumnWriter(ParquetWriter &writer, idx_t schema_idx, vector<string> schema_path_p, idx_t max_repeat,
922: 	                         idx_t max_define, bool can_have_nulls)
923: 	    : ColumnWriter(writer, schema_idx, move(schema_path_p), max_repeat, max_define, can_have_nulls) {
924: 	}
925: 	~FixedDecimalColumnWriter() override = default;
926: 
927: public:
928: 	unique_ptr<ColumnWriterStatistics> InitializeStatsState() override {
929: 		return make_unique<FixedDecimalStatistics>();
930: 	}
931: 
932: 	void WriteVector(Serializer &temp_writer, ColumnWriterStatistics *stats_p, ColumnWriterPageState *page_state,
933: 	                 Vector &input_column, idx_t chunk_start, idx_t chunk_end) override {
934: 		auto &mask = FlatVector::Validity(input_column);
935: 		auto *ptr = FlatVector::GetData<hugeint_t>(input_column);
936: 		auto &stats = (FixedDecimalStatistics &)*stats_p;
937: 
938: 		data_t temp_buffer[16];
939: 		for (idx_t r = chunk_start; r < chunk_end; r++) {
940: 			if (mask.RowIsValid(r)) {
941: 				stats.Update(ptr[r]);
942: 				WriteParquetDecimal(ptr[r], temp_buffer);
943: 				temp_writer.WriteData(temp_buffer, 16);
944: 			}
945: 		}
946: 	}
947: 
948: 	idx_t GetRowSize(Vector &vector, idx_t index) override {
949: 		return sizeof(hugeint_t);
950: 	}
951: };
952: 
953: //===--------------------------------------------------------------------===//
954: // UUID Column Writer
955: //===--------------------------------------------------------------------===//
956: class UUIDColumnWriter : public ColumnWriter {
957: 	static constexpr const idx_t PARQUET_UUID_SIZE = 16;
958: 
959: public:
960: 	UUIDColumnWriter(ParquetWriter &writer, idx_t schema_idx, vector<string> schema_path_p, idx_t max_repeat,
961: 	                 idx_t max_define, bool can_have_nulls)
962: 	    : ColumnWriter(writer, schema_idx, move(schema_path_p), max_repeat, max_define, can_have_nulls) {
963: 	}
964: 	~UUIDColumnWriter() override = default;
965: 
966: public:
967: 	static void WriteParquetUUID(hugeint_t input, data_ptr_t result) {
968: 		uint64_t high_bytes = input.upper ^ (int64_t(1) << 63);
969: 		uint64_t low_bytes = input.lower;
970: 
971: 		for (idx_t i = 0; i < sizeof(uint64_t); i++) {
972: 			auto shift_count = (sizeof(uint64_t) - i - 1) * 8;
973: 			result[i] = (high_bytes >> shift_count) & 0xFF;
974: 		}
975: 		for (idx_t i = 0; i < sizeof(uint64_t); i++) {
976: 			auto shift_count = (sizeof(uint64_t) - i - 1) * 8;
977: 			result[sizeof(uint64_t) + i] = (low_bytes >> shift_count) & 0xFF;
978: 		}
979: 	}
980: 
981: 	void WriteVector(Serializer &temp_writer, ColumnWriterStatistics *stats_p, ColumnWriterPageState *page_state,
982: 	                 Vector &input_column, idx_t chunk_start, idx_t chunk_end) override {
983: 		auto &mask = FlatVector::Validity(input_column);
984: 		auto *ptr = FlatVector::GetData<hugeint_t>(input_column);
985: 
986: 		data_t temp_buffer[PARQUET_UUID_SIZE];
987: 		for (idx_t r = chunk_start; r < chunk_end; r++) {
988: 			if (mask.RowIsValid(r)) {
989: 				WriteParquetUUID(ptr[r], temp_buffer);
990: 				temp_writer.WriteData(temp_buffer, PARQUET_UUID_SIZE);
991: 			}
992: 		}
993: 	}
994: 
995: 	idx_t GetRowSize(Vector &vector, idx_t index) override {
996: 		return PARQUET_UUID_SIZE;
997: 	}
998: };
999: 
1000: //===--------------------------------------------------------------------===//
1001: // Interval Column Writer
1002: //===--------------------------------------------------------------------===//
1003: class IntervalColumnWriter : public ColumnWriter {
1004: 	static constexpr const idx_t PARQUET_INTERVAL_SIZE = 12;
1005: 
1006: public:
1007: 	IntervalColumnWriter(ParquetWriter &writer, idx_t schema_idx, vector<string> schema_path_p, idx_t max_repeat,
1008: 	                     idx_t max_define, bool can_have_nulls)
1009: 	    : ColumnWriter(writer, schema_idx, move(schema_path_p), max_repeat, max_define, can_have_nulls) {
1010: 	}
1011: 	~IntervalColumnWriter() override = default;
1012: 
1013: public:
1014: 	static void WriteParquetInterval(interval_t input, data_ptr_t result) {
1015: 		if (input.days < 0 || input.months < 0 || input.micros < 0) {
1016: 			throw IOException("Parquet files do not support negative intervals");
1017: 		}
1018: 		Store<uint32_t>(input.months, result);
1019: 		Store<uint32_t>(input.days, result + sizeof(uint32_t));
1020: 		Store<uint32_t>(input.micros / 1000, result + sizeof(uint32_t) * 2);
1021: 	}
1022: 
1023: 	void WriteVector(Serializer &temp_writer, ColumnWriterStatistics *stats_p, ColumnWriterPageState *page_state,
1024: 	                 Vector &input_column, idx_t chunk_start, idx_t chunk_end) override {
1025: 		auto &mask = FlatVector::Validity(input_column);
1026: 		auto *ptr = FlatVector::GetData<interval_t>(input_column);
1027: 
1028: 		data_t temp_buffer[PARQUET_INTERVAL_SIZE];
1029: 		for (idx_t r = chunk_start; r < chunk_end; r++) {
1030: 			if (mask.RowIsValid(r)) {
1031: 				WriteParquetInterval(ptr[r], temp_buffer);
1032: 				temp_writer.WriteData(temp_buffer, PARQUET_INTERVAL_SIZE);
1033: 			}
1034: 		}
1035: 	}
1036: 
1037: 	idx_t GetRowSize(Vector &vector, idx_t index) override {
1038: 		return PARQUET_INTERVAL_SIZE;
1039: 	}
1040: };
1041: 
1042: //===--------------------------------------------------------------------===//
1043: // String Column Writer
1044: //===--------------------------------------------------------------------===//
1045: class StringStatisticsState : public ColumnWriterStatistics {
1046: 	static constexpr const idx_t MAX_STRING_STATISTICS_SIZE = 10000;
1047: 
1048: public:
1049: 	StringStatisticsState() : has_stats(false), values_too_big(false), min(), max() {
1050: 	}
1051: 
1052: 	bool has_stats;
1053: 	bool values_too_big;
1054: 	string min;
1055: 	string max;
1056: 
1057: public:
1058: 	bool HasStats() {
1059: 		return has_stats;
1060: 	}
1061: 
1062: 	void Update(const string_t &val) {
1063: 		if (values_too_big) {
1064: 			return;
1065: 		}
1066: 		auto str_len = val.GetSize();
1067: 		if (str_len > MAX_STRING_STATISTICS_SIZE) {
1068: 			// we avoid gathering stats when individual string values are too large
1069: 			// this is because the statistics are copied into the Parquet file meta data in uncompressed format
1070: 			// ideally we avoid placing several mega or giga-byte long strings there
1071: 			// we put a threshold of 10KB, if we see strings that exceed this threshold we avoid gathering stats
1072: 			values_too_big = true;
1073: 			min = string();
1074: 			max = string();
1075: 			return;
1076: 		}
1077: 		if (!has_stats || LessThan::Operation(val, string_t(min))) {
1078: 			min = val.GetString();
1079: 		}
1080: 		if (!has_stats || GreaterThan::Operation(val, string_t(max))) {
1081: 			max = val.GetString();
1082: 		}
1083: 		has_stats = true;
1084: 	}
1085: 
1086: 	string GetMin() override {
1087: 		return GetMinValue();
1088: 	}
1089: 	string GetMax() override {
1090: 		return GetMaxValue();
1091: 	}
1092: 	string GetMinValue() override {
1093: 		return HasStats() ? min : string();
1094: 	}
1095: 	string GetMaxValue() override {
1096: 		return HasStats() ? max : string();
1097: 	}
1098: };
1099: 
1100: class StringColumnWriter : public ColumnWriter {
1101: public:
1102: 	StringColumnWriter(ParquetWriter &writer, idx_t schema_idx, vector<string> schema_path_p, idx_t max_repeat,
1103: 	                   idx_t max_define, bool can_have_nulls)
1104: 	    : ColumnWriter(writer, schema_idx, move(schema_path_p), max_repeat, max_define, can_have_nulls) {
1105: 	}
1106: 	~StringColumnWriter() override = default;
1107: 
1108: public:
1109: 	unique_ptr<ColumnWriterStatistics> InitializeStatsState() override {
1110: 		return make_unique<StringStatisticsState>();
1111: 	}
1112: 
1113: 	void WriteVector(Serializer &temp_writer, ColumnWriterStatistics *stats_p, ColumnWriterPageState *page_state,
1114: 	                 Vector &input_column, idx_t chunk_start, idx_t chunk_end) override {
1115: 		auto &mask = FlatVector::Validity(input_column);
1116: 		auto &stats = (StringStatisticsState &)*stats_p;
1117: 
1118: 		auto *ptr = FlatVector::GetData<string_t>(input_column);
1119: 		for (idx_t r = chunk_start; r < chunk_end; r++) {
1120: 			if (mask.RowIsValid(r)) {
1121: 				stats.Update(ptr[r]);
1122: 				temp_writer.Write<uint32_t>(ptr[r].GetSize());
1123: 				temp_writer.WriteData((const_data_ptr_t)ptr[r].GetDataUnsafe(), ptr[r].GetSize());
1124: 			}
1125: 		}
1126: 	}
1127: 
1128: 	idx_t GetRowSize(Vector &vector, idx_t index) override {
1129: 		auto strings = FlatVector::GetData<string_t>(vector);
1130: 		return strings[index].GetSize();
1131: 	}
1132: };
1133: 
1134: //===--------------------------------------------------------------------===//
1135: // Enum Column Writer
1136: //===--------------------------------------------------------------------===//
1137: class EnumWriterPageState : public ColumnWriterPageState {
1138: public:
1139: 	explicit EnumWriterPageState(uint32_t bit_width) : encoder(bit_width), written_value(false) {
1140: 	}
1141: 
1142: 	RleBpEncoder encoder;
1143: 	bool written_value;
1144: };
1145: 
1146: class EnumColumnWriter : public ColumnWriter {
1147: public:
1148: 	EnumColumnWriter(ParquetWriter &writer, LogicalType enum_type_p, idx_t schema_idx, vector<string> schema_path_p,
1149: 	                 idx_t max_repeat, idx_t max_define, bool can_have_nulls)
1150: 	    : ColumnWriter(writer, schema_idx, move(schema_path_p), max_repeat, max_define, can_have_nulls),
1151: 	      enum_type(move(enum_type_p)) {
1152: 		bit_width = RleBpDecoder::ComputeBitWidth(EnumType::GetSize(enum_type));
1153: 	}
1154: 	~EnumColumnWriter() override = default;
1155: 
1156: 	LogicalType enum_type;
1157: 	uint32_t bit_width;
1158: 
1159: public:
1160: 	unique_ptr<ColumnWriterStatistics> InitializeStatsState() override {
1161: 		return make_unique<StringStatisticsState>();
1162: 	}
1163: 
1164: 	template <class T>
1165: 	void WriteEnumInternal(Serializer &temp_writer, Vector &input_column, idx_t chunk_start, idx_t chunk_end,
1166: 	                       EnumWriterPageState &page_state) {
1167: 		auto &mask = FlatVector::Validity(input_column);
1168: 		auto *ptr = FlatVector::GetData<T>(input_column);
1169: 		for (idx_t r = chunk_start; r < chunk_end; r++) {
1170: 			if (mask.RowIsValid(r)) {
1171: 				if (!page_state.written_value) {
1172: 					// first value
1173: 					// write the bit-width as a one-byte entry
1174: 					temp_writer.Write<uint8_t>(bit_width);
1175: 					// now begin writing the actual value
1176: 					page_state.encoder.BeginWrite(temp_writer, ptr[r]);
1177: 					page_state.written_value = true;
1178: 				} else {
1179: 					page_state.encoder.WriteValue(temp_writer, ptr[r]);
1180: 				}
1181: 			}
1182: 		}
1183: 	}
1184: 
1185: 	void WriteVector(Serializer &temp_writer, ColumnWriterStatistics *stats_p, ColumnWriterPageState *page_state_p,
1186: 	                 Vector &input_column, idx_t chunk_start, idx_t chunk_end) override {
1187: 		auto &page_state = (EnumWriterPageState &)*page_state_p;
1188: 		switch (enum_type.InternalType()) {
1189: 		case PhysicalType::UINT8:
1190: 			WriteEnumInternal<uint8_t>(temp_writer, input_column, chunk_start, chunk_end, page_state);
1191: 			break;
1192: 		case PhysicalType::UINT16:
1193: 			WriteEnumInternal<uint16_t>(temp_writer, input_column, chunk_start, chunk_end, page_state);
1194: 			break;
1195: 		case PhysicalType::UINT32:
1196: 			WriteEnumInternal<uint32_t>(temp_writer, input_column, chunk_start, chunk_end, page_state);
1197: 			break;
1198: 		default:
1199: 			throw InternalException("Unsupported internal enum type");
1200: 		}
1201: 	}
1202: 
1203: 	unique_ptr<ColumnWriterPageState> InitializePageState() override {
1204: 		return make_unique<EnumWriterPageState>(bit_width);
1205: 	}
1206: 
1207: 	void FlushPageState(Serializer &temp_writer, ColumnWriterPageState *state_p) override {
1208: 		auto &page_state = (EnumWriterPageState &)*state_p;
1209: 		if (!page_state.written_value) {
1210: 			// all values are null
1211: 			// just write the bit width
1212: 			temp_writer.Write<uint8_t>(bit_width);
1213: 			return;
1214: 		}
1215: 		page_state.encoder.FinishWrite(temp_writer);
1216: 	}
1217: 
1218: 	duckdb_parquet::format::Encoding::type GetEncoding() override {
1219: 		return Encoding::RLE_DICTIONARY;
1220: 	}
1221: 
1222: 	void FlushDictionary(ColumnWriterState &state, ColumnWriterStatistics *stats_p) override {
1223: 		auto &stats = (StringStatisticsState &)*stats_p;
1224: 		// write the enum values to a dictionary page
1225: 		auto &enum_values = EnumType::GetValuesInsertOrder(enum_type);
1226: 		auto enum_count = EnumType::GetSize(enum_type);
1227: 		auto string_values = FlatVector::GetData<string_t>(enum_values);
1228: 		// first write the contents of the dictionary page to a temporary buffer
1229: 		auto temp_writer = make_unique<BufferedSerializer>();
1230: 		for (idx_t r = 0; r < enum_count; r++) {
1231: 			D_ASSERT(!FlatVector::IsNull(enum_values, r));
1232: 			// update the statistics
1233: 			stats.Update(string_values[r]);
1234: 			// write this string value to the dictionary
1235: 			temp_writer->Write<uint32_t>(string_values[r].GetSize());
1236: 			temp_writer->WriteData((const_data_ptr_t)string_values[r].GetDataUnsafe(), string_values[r].GetSize());
1237: 		}
1238: 		// flush the dictionary page and add it to the to-be-written pages
1239: 		WriteDictionary(state, move(temp_writer), enum_count);
1240: 	}
1241: 
1242: 	idx_t GetRowSize(Vector &vector, idx_t index) override {
1243: 		return (bit_width + 7) / 8;
1244: 	}
1245: };
1246: 
1247: //===--------------------------------------------------------------------===//
1248: // Struct Column Writer
1249: //===--------------------------------------------------------------------===//
1250: class StructColumnWriter : public ColumnWriter {
1251: public:
1252: 	StructColumnWriter(ParquetWriter &writer, idx_t schema_idx, vector<string> schema_path_p, idx_t max_repeat,
1253: 	                   idx_t max_define, vector<unique_ptr<ColumnWriter>> child_writers_p, bool can_have_nulls)
1254: 	    : ColumnWriter(writer, schema_idx, move(schema_path_p), max_repeat, max_define, can_have_nulls),
1255: 	      child_writers(move(child_writers_p)) {
1256: 	}
1257: 	~StructColumnWriter() override = default;
1258: 
1259: 	vector<unique_ptr<ColumnWriter>> child_writers;
1260: 
1261: public:
1262: 	unique_ptr<ColumnWriterState> InitializeWriteState(duckdb_parquet::format::RowGroup &row_group) override;
1263: 	void Prepare(ColumnWriterState &state, ColumnWriterState *parent, Vector &vector, idx_t count) override;
1264: 
1265: 	void BeginWrite(ColumnWriterState &state) override;
1266: 	void Write(ColumnWriterState &state, Vector &vector, idx_t count) override;
1267: 	void FinalizeWrite(ColumnWriterState &state) override;
1268: };
1269: 
1270: class StructColumnWriterState : public ColumnWriterState {
1271: public:
1272: 	StructColumnWriterState(duckdb_parquet::format::RowGroup &row_group, idx_t col_idx)
1273: 	    : row_group(row_group), col_idx(col_idx) {
1274: 	}
1275: 	~StructColumnWriterState() override = default;
1276: 
1277: 	duckdb_parquet::format::RowGroup &row_group;
1278: 	idx_t col_idx;
1279: 	vector<unique_ptr<ColumnWriterState>> child_states;
1280: };
1281: 
1282: unique_ptr<ColumnWriterState> StructColumnWriter::InitializeWriteState(duckdb_parquet::format::RowGroup &row_group) {
1283: 	auto result = make_unique<StructColumnWriterState>(row_group, row_group.columns.size());
1284: 
1285: 	result->child_states.reserve(child_writers.size());
1286: 	for (auto &child_writer : child_writers) {
1287: 		result->child_states.push_back(child_writer->InitializeWriteState(row_group));
1288: 	}
1289: 	return move(result);
1290: }
1291: 
1292: void StructColumnWriter::Prepare(ColumnWriterState &state_p, ColumnWriterState *parent, Vector &vector, idx_t count) {
1293: 	auto &state = (StructColumnWriterState &)state_p;
1294: 
1295: 	auto &validity = FlatVector::Validity(vector);
1296: 	if (parent) {
1297: 		// propagate empty entries from the parent
1298: 		while (state.is_empty.size() < parent->is_empty.size()) {
1299: 			state.is_empty.push_back(parent->is_empty[state.is_empty.size()]);
1300: 		}
1301: 	}
1302: 	HandleRepeatLevels(state_p, parent, count, max_repeat);
1303: 	HandleDefineLevels(state_p, parent, validity, count, PARQUET_DEFINE_VALID, max_define - 1);
1304: 	auto &child_vectors = StructVector::GetEntries(vector);
1305: 	for (idx_t child_idx = 0; child_idx < child_writers.size(); child_idx++) {
1306: 		child_writers[child_idx]->Prepare(*state.child_states[child_idx], &state_p, *child_vectors[child_idx], count);
1307: 	}
1308: }
1309: 
1310: void StructColumnWriter::BeginWrite(ColumnWriterState &state_p) {
1311: 	auto &state = (StructColumnWriterState &)state_p;
1312: 	for (idx_t child_idx = 0; child_idx < child_writers.size(); child_idx++) {
1313: 		child_writers[child_idx]->BeginWrite(*state.child_states[child_idx]);
1314: 	}
1315: }
1316: 
1317: void StructColumnWriter::Write(ColumnWriterState &state_p, Vector &vector, idx_t count) {
1318: 	auto &state = (StructColumnWriterState &)state_p;
1319: 	auto &child_vectors = StructVector::GetEntries(vector);
1320: 	for (idx_t child_idx = 0; child_idx < child_writers.size(); child_idx++) {
1321: 		child_writers[child_idx]->Write(*state.child_states[child_idx], *child_vectors[child_idx], count);
1322: 	}
1323: }
1324: 
1325: void StructColumnWriter::FinalizeWrite(ColumnWriterState &state_p) {
1326: 	auto &state = (StructColumnWriterState &)state_p;
1327: 	for (idx_t child_idx = 0; child_idx < child_writers.size(); child_idx++) {
1328: 		// we add the null count of the struct to the null count of the children
1329: 		child_writers[child_idx]->null_count += null_count;
1330: 		child_writers[child_idx]->FinalizeWrite(*state.child_states[child_idx]);
1331: 	}
1332: }
1333: 
1334: //===--------------------------------------------------------------------===//
1335: // List Column Writer
1336: //===--------------------------------------------------------------------===//
1337: class ListColumnWriter : public ColumnWriter {
1338: public:
1339: 	ListColumnWriter(ParquetWriter &writer, idx_t schema_idx, vector<string> schema_path_p, idx_t max_repeat,
1340: 	                 idx_t max_define, unique_ptr<ColumnWriter> child_writer_p, bool can_have_nulls)
1341: 	    : ColumnWriter(writer, schema_idx, move(schema_path_p), max_repeat, max_define, can_have_nulls),
1342: 	      child_writer(move(child_writer_p)) {
1343: 	}
1344: 	~ListColumnWriter() override = default;
1345: 
1346: 	unique_ptr<ColumnWriter> child_writer;
1347: 
1348: public:
1349: 	unique_ptr<ColumnWriterState> InitializeWriteState(duckdb_parquet::format::RowGroup &row_group) override;
1350: 	void Prepare(ColumnWriterState &state, ColumnWriterState *parent, Vector &vector, idx_t count) override;
1351: 
1352: 	void BeginWrite(ColumnWriterState &state) override;
1353: 	void Write(ColumnWriterState &state, Vector &vector, idx_t count) override;
1354: 	void FinalizeWrite(ColumnWriterState &state) override;
1355: };
1356: 
1357: class ListColumnWriterState : public ColumnWriterState {
1358: public:
1359: 	ListColumnWriterState(duckdb_parquet::format::RowGroup &row_group, idx_t col_idx)
1360: 	    : row_group(row_group), col_idx(col_idx) {
1361: 	}
1362: 	~ListColumnWriterState() override = default;
1363: 
1364: 	duckdb_parquet::format::RowGroup &row_group;
1365: 	idx_t col_idx;
1366: 	unique_ptr<ColumnWriterState> child_state;
1367: 	idx_t parent_index = 0;
1368: };
1369: 
1370: unique_ptr<ColumnWriterState> ListColumnWriter::InitializeWriteState(duckdb_parquet::format::RowGroup &row_group) {
1371: 	auto result = make_unique<ListColumnWriterState>(row_group, row_group.columns.size());
1372: 	result->child_state = child_writer->InitializeWriteState(row_group);
1373: 	return move(result);
1374: }
1375: 
1376: void ListColumnWriter::Prepare(ColumnWriterState &state_p, ColumnWriterState *parent, Vector &vector, idx_t count) {
1377: 	auto &state = (ListColumnWriterState &)state_p;
1378: 
1379: 	auto list_data = FlatVector::GetData<list_entry_t>(vector);
1380: 	auto &validity = FlatVector::Validity(vector);
1381: 
1382: 	// write definition levels and repeats
1383: 	idx_t start = 0;
1384: 	idx_t vcount = parent ? parent->definition_levels.size() - state.parent_index : count;
1385: 	idx_t vector_index = 0;
1386: 	for (idx_t i = start; i < vcount; i++) {
1387: 		idx_t parent_index = state.parent_index + i;
1388: 		if (parent && !parent->is_empty.empty() && parent->is_empty[parent_index]) {
1389: 			state.definition_levels.push_back(parent->definition_levels[parent_index]);
1390: 			state.repetition_levels.push_back(parent->repetition_levels[parent_index]);
1391: 			state.is_empty.push_back(true);
1392: 			continue;
1393: 		}
1394: 		auto first_repeat_level =
1395: 		    parent && !parent->repetition_levels.empty() ? parent->repetition_levels[parent_index] : max_repeat;
1396: 		if (parent && parent->definition_levels[parent_index] != PARQUET_DEFINE_VALID) {
1397: 			state.definition_levels.push_back(parent->definition_levels[parent_index]);
1398: 			state.repetition_levels.push_back(first_repeat_level);
1399: 			state.is_empty.push_back(true);
1400: 		} else if (validity.RowIsValid(vector_index)) {
1401: 			// push the repetition levels
1402: 			if (list_data[vector_index].length == 0) {
1403: 				state.definition_levels.push_back(max_define);
1404: 				state.is_empty.push_back(true);
1405: 			} else {
1406: 				state.definition_levels.push_back(PARQUET_DEFINE_VALID);
1407: 				state.is_empty.push_back(false);
1408: 			}
1409: 			state.repetition_levels.push_back(first_repeat_level);
1410: 			for (idx_t k = 1; k < list_data[vector_index].length; k++) {
1411: 				state.repetition_levels.push_back(max_repeat + 1);
1412: 				state.definition_levels.push_back(PARQUET_DEFINE_VALID);
1413: 				state.is_empty.push_back(false);
1414: 			}
1415: 		} else {
1416: 			if (!can_have_nulls) {
1417: 				throw IOException("Parquet writer: map key column is not allowed to contain NULL values");
1418: 			}
1419: 			state.definition_levels.push_back(max_define - 1);
1420: 			state.repetition_levels.push_back(first_repeat_level);
1421: 			state.is_empty.push_back(true);
1422: 		}
1423: 		vector_index++;
1424: 	}
1425: 	state.parent_index += vcount;
1426: 
1427: 	auto &list_child = ListVector::GetEntry(vector);
1428: 	auto list_count = ListVector::GetListSize(vector);
1429: 	child_writer->Prepare(*state.child_state, &state_p, list_child, list_count);
1430: }
1431: 
1432: void ListColumnWriter::BeginWrite(ColumnWriterState &state_p) {
1433: 	auto &state = (ListColumnWriterState &)state_p;
1434: 	child_writer->BeginWrite(*state.child_state);
1435: }
1436: 
1437: void ListColumnWriter::Write(ColumnWriterState &state_p, Vector &vector, idx_t count) {
1438: 	auto &state = (ListColumnWriterState &)state_p;
1439: 
1440: 	auto &list_child = ListVector::GetEntry(vector);
1441: 	auto list_count = ListVector::GetListSize(vector);
1442: 	child_writer->Write(*state.child_state, list_child, list_count);
1443: }
1444: 
1445: void ListColumnWriter::FinalizeWrite(ColumnWriterState &state_p) {
1446: 	auto &state = (ListColumnWriterState &)state_p;
1447: 	child_writer->FinalizeWrite(*state.child_state);
1448: }
1449: 
1450: //===--------------------------------------------------------------------===//
1451: // Create Column Writer
1452: //===--------------------------------------------------------------------===//
1453: unique_ptr<ColumnWriter> ColumnWriter::CreateWriterRecursive(vector<duckdb_parquet::format::SchemaElement> &schemas,
1454:                                                              ParquetWriter &writer, const LogicalType &type,
1455:                                                              const string &name, vector<string> schema_path,
1456:                                                              idx_t max_repeat, idx_t max_define, bool can_have_nulls) {
1457: 	auto null_type = can_have_nulls ? FieldRepetitionType::OPTIONAL : FieldRepetitionType::REQUIRED;
1458: 	if (!can_have_nulls) {
1459: 		max_define--;
1460: 	}
1461: 	idx_t schema_idx = schemas.size();
1462: 	if (type.id() == LogicalTypeId::STRUCT) {
1463: 		auto &child_types = StructType::GetChildTypes(type);
1464: 		// set up the schema element for this struct
1465: 		duckdb_parquet::format::SchemaElement schema_element;
1466: 		schema_element.repetition_type = null_type;
1467: 		schema_element.num_children = child_types.size();
1468: 		schema_element.__isset.num_children = true;
1469: 		schema_element.__isset.type = false;
1470: 		schema_element.__isset.repetition_type = true;
1471: 		schema_element.name = name;
1472: 		schemas.push_back(move(schema_element));
1473: 		schema_path.push_back(name);
1474: 
1475: 		// construct the child types recursively
1476: 		vector<unique_ptr<ColumnWriter>> child_writers;
1477: 		child_writers.reserve(child_types.size());
1478: 		for (auto &child_type : child_types) {
1479: 			child_writers.push_back(CreateWriterRecursive(schemas, writer, child_type.second, child_type.first,
1480: 			                                              schema_path, max_repeat, max_define + 1));
1481: 		}
1482: 		return make_unique<StructColumnWriter>(writer, schema_idx, move(schema_path), max_repeat, max_define,
1483: 		                                       move(child_writers), can_have_nulls);
1484: 	}
1485: 	if (type.id() == LogicalTypeId::LIST) {
1486: 		auto &child_type = ListType::GetChildType(type);
1487: 		// set up the two schema elements for the list
1488: 		// for some reason we only set the converted type in the OPTIONAL element
1489: 		// first an OPTIONAL element
1490: 		duckdb_parquet::format::SchemaElement optional_element;
1491: 		optional_element.repetition_type = null_type;
1492: 		optional_element.num_children = 1;
1493: 		optional_element.converted_type = ConvertedType::LIST;
1494: 		optional_element.__isset.num_children = true;
1495: 		optional_element.__isset.type = false;
1496: 		optional_element.__isset.repetition_type = true;
1497: 		optional_element.__isset.converted_type = true;
1498: 		optional_element.name = name;
1499: 		schemas.push_back(move(optional_element));
1500: 		schema_path.push_back(name);
1501: 
1502: 		// then a REPEATED element
1503: 		duckdb_parquet::format::SchemaElement repeated_element;
1504: 		repeated_element.repetition_type = FieldRepetitionType::REPEATED;
1505: 		repeated_element.num_children = 1;
1506: 		repeated_element.__isset.num_children = true;
1507: 		repeated_element.__isset.type = false;
1508: 		repeated_element.__isset.repetition_type = true;
1509: 		repeated_element.name = "list";
1510: 		schemas.push_back(move(repeated_element));
1511: 		schema_path.emplace_back("list");
1512: 
1513: 		auto child_writer =
1514: 		    CreateWriterRecursive(schemas, writer, child_type, "element", schema_path, max_repeat + 1, max_define + 2);
1515: 		return make_unique<ListColumnWriter>(writer, schema_idx, move(schema_path), max_repeat, max_define,
1516: 		                                     move(child_writer), can_have_nulls);
1517: 	}
1518: 	if (type.id() == LogicalTypeId::MAP) {
1519: 		// map type
1520: 		// maps are stored as follows:
1521: 		// <map-repetition> group <name> (MAP) {
1522: 		// 	repeated group key_value {
1523: 		// 		required <key-type> key;
1524: 		// 		<value-repetition> <value-type> value;
1525: 		// 	}
1526: 		// }
1527: 		// top map element
1528: 		duckdb_parquet::format::SchemaElement top_element;
1529: 		top_element.repetition_type = null_type;
1530: 		top_element.num_children = 1;
1531: 		top_element.converted_type = ConvertedType::MAP;
1532: 		top_element.__isset.repetition_type = true;
1533: 		top_element.__isset.num_children = true;
1534: 		top_element.__isset.converted_type = true;
1535: 		top_element.__isset.type = false;
1536: 		top_element.name = name;
1537: 		schemas.push_back(move(top_element));
1538: 		schema_path.push_back(name);
1539: 
1540: 		// key_value element
1541: 		duckdb_parquet::format::SchemaElement kv_element;
1542: 		kv_element.repetition_type = FieldRepetitionType::REPEATED;
1543: 		kv_element.num_children = 2;
1544: 		kv_element.__isset.repetition_type = true;
1545: 		kv_element.__isset.num_children = true;
1546: 		kv_element.__isset.type = false;
1547: 		kv_element.name = "key_value";
1548: 		schemas.push_back(move(kv_element));
1549: 		schema_path.emplace_back("key_value");
1550: 
1551: 		// construct the child types recursively
1552: 		vector<LogicalType> kv_types {MapType::KeyType(type), MapType::ValueType(type)};
1553: 		vector<string> kv_names {"key", "value"};
1554: 		vector<unique_ptr<ColumnWriter>> child_writers;
1555: 		child_writers.reserve(2);
1556: 		for (idx_t i = 0; i < 2; i++) {
1557: 			// key needs to be marked as REQUIRED
1558: 			bool is_key = i == 0;
1559: 			auto child_writer = CreateWriterRecursive(schemas, writer, kv_types[i], kv_names[i], schema_path,
1560: 			                                          max_repeat + 1, max_define + 2, !is_key);
1561: 			auto list_writer = make_unique<ListColumnWriter>(writer, schema_idx, schema_path, max_repeat, max_define,
1562: 			                                                 move(child_writer), can_have_nulls);
1563: 			child_writers.push_back(move(list_writer));
1564: 		}
1565: 		return make_unique<StructColumnWriter>(writer, schema_idx, schema_path, max_repeat, max_define,
1566: 		                                       move(child_writers), can_have_nulls);
1567: 	}
1568: 	duckdb_parquet::format::SchemaElement schema_element;
1569: 	schema_element.type = ParquetWriter::DuckDBTypeToParquetType(type);
1570: 	schema_element.repetition_type = null_type;
1571: 	schema_element.num_children = 0;
1572: 	schema_element.__isset.num_children = true;
1573: 	schema_element.__isset.type = true;
1574: 	schema_element.__isset.repetition_type = true;
1575: 	schema_element.name = name;
1576: 	ParquetWriter::SetSchemaProperties(type, schema_element);
1577: 	schemas.push_back(move(schema_element));
1578: 	schema_path.push_back(name);
1579: 
1580: 	switch (type.id()) {
1581: 	case LogicalTypeId::BOOLEAN:
1582: 		return make_unique<BooleanColumnWriter>(writer, schema_idx, move(schema_path), max_repeat, max_define,
1583: 		                                        can_have_nulls);
1584: 	case LogicalTypeId::TINYINT:
1585: 		return make_unique<StandardColumnWriter<int8_t, int32_t>>(writer, schema_idx, move(schema_path), max_repeat,
1586: 		                                                          max_define, can_have_nulls);
1587: 	case LogicalTypeId::SMALLINT:
1588: 		return make_unique<StandardColumnWriter<int16_t, int32_t>>(writer, schema_idx, move(schema_path), max_repeat,
1589: 		                                                           max_define, can_have_nulls);
1590: 	case LogicalTypeId::INTEGER:
1591: 	case LogicalTypeId::DATE:
1592: 		return make_unique<StandardColumnWriter<int32_t, int32_t>>(writer, schema_idx, move(schema_path), max_repeat,
1593: 		                                                           max_define, can_have_nulls);
1594: 	case LogicalTypeId::BIGINT:
1595: 	case LogicalTypeId::TIME:
1596: 	case LogicalTypeId::TIME_TZ:
1597: 	case LogicalTypeId::TIMESTAMP:
1598: 	case LogicalTypeId::TIMESTAMP_TZ:
1599: 	case LogicalTypeId::TIMESTAMP_MS:
1600: 		return make_unique<StandardColumnWriter<int64_t, int64_t>>(writer, schema_idx, move(schema_path), max_repeat,
1601: 		                                                           max_define, can_have_nulls);
1602: 	case LogicalTypeId::HUGEINT:
1603: 		return make_unique<StandardColumnWriter<hugeint_t, double, ParquetHugeintOperator>>(
1604: 		    writer, schema_idx, move(schema_path), max_repeat, max_define, can_have_nulls);
1605: 	case LogicalTypeId::TIMESTAMP_NS:
1606: 		return make_unique<StandardColumnWriter<int64_t, int64_t, ParquetTimestampNSOperator>>(
1607: 		    writer, schema_idx, move(schema_path), max_repeat, max_define, can_have_nulls);
1608: 	case LogicalTypeId::TIMESTAMP_SEC:
1609: 		return make_unique<StandardColumnWriter<int64_t, int64_t, ParquetTimestampSOperator>>(
1610: 		    writer, schema_idx, move(schema_path), max_repeat, max_define, can_have_nulls);
1611: 	case LogicalTypeId::UTINYINT:
1612: 		return make_unique<StandardColumnWriter<uint8_t, int32_t>>(writer, schema_idx, move(schema_path), max_repeat,
1613: 		                                                           max_define, can_have_nulls);
1614: 	case LogicalTypeId::USMALLINT:
1615: 		return make_unique<StandardColumnWriter<uint16_t, int32_t>>(writer, schema_idx, move(schema_path), max_repeat,
1616: 		                                                            max_define, can_have_nulls);
1617: 	case LogicalTypeId::UINTEGER:
1618: 		return make_unique<StandardColumnWriter<uint32_t, uint32_t>>(writer, schema_idx, move(schema_path), max_repeat,
1619: 		                                                             max_define, can_have_nulls);
1620: 	case LogicalTypeId::UBIGINT:
1621: 		return make_unique<StandardColumnWriter<uint64_t, uint64_t>>(writer, schema_idx, move(schema_path), max_repeat,
1622: 		                                                             max_define, can_have_nulls);
1623: 	case LogicalTypeId::FLOAT:
1624: 		return make_unique<StandardColumnWriter<float, float>>(writer, schema_idx, move(schema_path), max_repeat,
1625: 		                                                       max_define, can_have_nulls);
1626: 	case LogicalTypeId::DOUBLE:
1627: 		return make_unique<StandardColumnWriter<double, double>>(writer, schema_idx, move(schema_path), max_repeat,
1628: 		                                                         max_define, can_have_nulls);
1629: 	case LogicalTypeId::DECIMAL:
1630: 		switch (type.InternalType()) {
1631: 		case PhysicalType::INT16:
1632: 			return make_unique<StandardColumnWriter<int16_t, int32_t>>(writer, schema_idx, move(schema_path),
1633: 			                                                           max_repeat, max_define, can_have_nulls);
1634: 		case PhysicalType::INT32:
1635: 			return make_unique<StandardColumnWriter<int32_t, int32_t>>(writer, schema_idx, move(schema_path),
1636: 			                                                           max_repeat, max_define, can_have_nulls);
1637: 		case PhysicalType::INT64:
1638: 			return make_unique<StandardColumnWriter<int64_t, int64_t>>(writer, schema_idx, move(schema_path),
1639: 			                                                           max_repeat, max_define, can_have_nulls);
1640: 		default:
1641: 			return make_unique<FixedDecimalColumnWriter>(writer, schema_idx, move(schema_path), max_repeat, max_define,
1642: 			                                             can_have_nulls);
1643: 		}
1644: 	case LogicalTypeId::BLOB:
1645: 	case LogicalTypeId::VARCHAR:
1646: 	case LogicalTypeId::JSON:
1647: 		return make_unique<StringColumnWriter>(writer, schema_idx, move(schema_path), max_repeat, max_define,
1648: 		                                       can_have_nulls);
1649: 	case LogicalTypeId::UUID:
1650: 		return make_unique<UUIDColumnWriter>(writer, schema_idx, move(schema_path), max_repeat, max_define,
1651: 		                                     can_have_nulls);
1652: 	case LogicalTypeId::INTERVAL:
1653: 		return make_unique<IntervalColumnWriter>(writer, schema_idx, move(schema_path), max_repeat, max_define,
1654: 		                                         can_have_nulls);
1655: 	case LogicalTypeId::ENUM:
1656: 		return make_unique<EnumColumnWriter>(writer, type, schema_idx, move(schema_path), max_repeat, max_define,
1657: 		                                     can_have_nulls);
1658: 	default:
1659: 		throw InternalException("Unsupported type \"%s\" in Parquet writer", type.ToString());
1660: 	}
1661: }
1662: 
1663: } // namespace duckdb
[end of extension/parquet/column_writer.cpp]
[start of extension/parquet/include/templated_column_reader.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // templated__column_reader.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "column_reader.hpp"
12: 
13: namespace duckdb {
14: 
15: template <class VALUE_TYPE>
16: struct TemplatedParquetValueConversion {
17: 	static VALUE_TYPE DictRead(ByteBuffer &dict, uint32_t &offset, ColumnReader &reader) {
18: 		D_ASSERT(offset < dict.len / sizeof(VALUE_TYPE));
19: 		return ((VALUE_TYPE *)dict.ptr)[offset];
20: 	}
21: 
22: 	static VALUE_TYPE PlainRead(ByteBuffer &plain_data, ColumnReader &reader) {
23: 		return plain_data.read<VALUE_TYPE>();
24: 	}
25: 
26: 	static void PlainSkip(ByteBuffer &plain_data, ColumnReader &reader) {
27: 		plain_data.inc(sizeof(VALUE_TYPE));
28: 	}
29: };
30: 
31: template <class VALUE_TYPE, class VALUE_CONVERSION>
32: class TemplatedColumnReader : public ColumnReader {
33: public:
34: 	TemplatedColumnReader(ParquetReader &reader, LogicalType type_p, const SchemaElement &schema_p, idx_t schema_idx_p,
35: 	                      idx_t max_define_p, idx_t max_repeat_p)
36: 	    : ColumnReader(reader, move(type_p), schema_p, schema_idx_p, max_define_p, max_repeat_p) {};
37: 
38: 	shared_ptr<ByteBuffer> dict;
39: 
40: public:
41: 	void Dictionary(shared_ptr<ByteBuffer> data, idx_t num_entries) override {
42: 		dict = move(data);
43: 	}
44: 
45: 	void Offsets(uint32_t *offsets, uint8_t *defines, uint64_t num_values, parquet_filter_t &filter,
46: 	             idx_t result_offset, Vector &result) override {
47: 		auto result_ptr = FlatVector::GetData<VALUE_TYPE>(result);
48: 		auto &result_mask = FlatVector::Validity(result);
49: 
50: 		idx_t offset_idx = 0;
51: 		for (idx_t row_idx = 0; row_idx < num_values; row_idx++) {
52: 			if (HasDefines() && defines[row_idx + result_offset] != max_define) {
53: 				result_mask.SetInvalid(row_idx + result_offset);
54: 				continue;
55: 			}
56: 			if (filter[row_idx + result_offset]) {
57: 				VALUE_TYPE val = VALUE_CONVERSION::DictRead(*dict, offsets[offset_idx++], *this);
58: 				if (!Value::IsValid(val)) {
59: 					result_mask.SetInvalid(row_idx + result_offset);
60: 					continue;
61: 				}
62: 				result_ptr[row_idx + result_offset] = val;
63: 			} else {
64: 				offset_idx++;
65: 			}
66: 		}
67: 	}
68: 
69: 	void Plain(shared_ptr<ByteBuffer> plain_data, uint8_t *defines, uint64_t num_values, parquet_filter_t &filter,
70: 	           idx_t result_offset, Vector &result) override {
71: 		auto result_ptr = FlatVector::GetData<VALUE_TYPE>(result);
72: 		auto &result_mask = FlatVector::Validity(result);
73: 		for (idx_t row_idx = 0; row_idx < num_values; row_idx++) {
74: 			if (HasDefines() && defines[row_idx + result_offset] != max_define) {
75: 				result_mask.SetInvalid(row_idx + result_offset);
76: 				continue;
77: 			}
78: 			if (filter[row_idx + result_offset]) {
79: 				VALUE_TYPE val = VALUE_CONVERSION::PlainRead(*plain_data, *this);
80: 				if (!Value::IsValid(val)) {
81: 					result_mask.SetInvalid(row_idx + result_offset);
82: 					continue;
83: 				}
84: 				result_ptr[row_idx + result_offset] = val;
85: 			} else { // there is still some data there that we have to skip over
86: 				VALUE_CONVERSION::PlainSkip(*plain_data, *this);
87: 			}
88: 		}
89: 	}
90: };
91: 
92: template <class PARQUET_PHYSICAL_TYPE, class DUCKDB_PHYSICAL_TYPE,
93:           DUCKDB_PHYSICAL_TYPE (*FUNC)(const PARQUET_PHYSICAL_TYPE &input)>
94: struct CallbackParquetValueConversion {
95: 	static DUCKDB_PHYSICAL_TYPE DictRead(ByteBuffer &dict, uint32_t &offset, ColumnReader &reader) {
96: 		return TemplatedParquetValueConversion<DUCKDB_PHYSICAL_TYPE>::DictRead(dict, offset, reader);
97: 	}
98: 
99: 	static DUCKDB_PHYSICAL_TYPE PlainRead(ByteBuffer &plain_data, ColumnReader &reader) {
100: 		return FUNC(plain_data.read<PARQUET_PHYSICAL_TYPE>());
101: 	}
102: 
103: 	static void PlainSkip(ByteBuffer &plain_data, ColumnReader &reader) {
104: 		plain_data.inc(sizeof(PARQUET_PHYSICAL_TYPE));
105: 	}
106: };
107: 
108: } // namespace duckdb
[end of extension/parquet/include/templated_column_reader.hpp]
[start of extension/parquet/parquet_statistics.cpp]
1: #include "parquet_statistics.hpp"
2: #include "parquet_decimal_utils.hpp"
3: #include "parquet_timestamp.hpp"
4: 
5: #include "duckdb.hpp"
6: #ifndef DUCKDB_AMALGAMATION
7: #include "duckdb/common/types/blob.hpp"
8: #include "duckdb/common/types/value.hpp"
9: #include "duckdb/storage/statistics/numeric_statistics.hpp"
10: #include "duckdb/storage/statistics/string_statistics.hpp"
11: #endif
12: 
13: namespace duckdb {
14: 
15: using duckdb_parquet::format::ConvertedType;
16: using duckdb_parquet::format::Type;
17: 
18: static unique_ptr<BaseStatistics> CreateNumericStats(const LogicalType &type,
19:                                                      const duckdb_parquet::format::SchemaElement &schema_ele,
20:                                                      const duckdb_parquet::format::Statistics &parquet_stats) {
21: 	auto stats = make_unique<NumericStatistics>(type);
22: 
23: 	// for reasons unknown to science, Parquet defines *both* `min` and `min_value` as well as `max` and
24: 	// `max_value`. All are optional. such elegance.
25: 	if (parquet_stats.__isset.min) {
26: 		stats->min = ParquetStatisticsUtils::ConvertValue(type, schema_ele, parquet_stats.min).CastAs(type);
27: 	} else if (parquet_stats.__isset.min_value) {
28: 		stats->min = ParquetStatisticsUtils::ConvertValue(type, schema_ele, parquet_stats.min_value).CastAs(type);
29: 	} else {
30: 		stats->min = Value(type);
31: 	}
32: 	if (parquet_stats.__isset.max) {
33: 		stats->max = ParquetStatisticsUtils::ConvertValue(type, schema_ele, parquet_stats.max).CastAs(type);
34: 	} else if (parquet_stats.__isset.max_value) {
35: 		stats->max = ParquetStatisticsUtils::ConvertValue(type, schema_ele, parquet_stats.max_value).CastAs(type);
36: 	} else {
37: 		stats->max = Value(type);
38: 	}
39: 	return move(stats);
40: }
41: 
42: Value ParquetStatisticsUtils::ConvertValue(const LogicalType &type,
43:                                            const duckdb_parquet::format::SchemaElement &schema_ele,
44:                                            const std::string &stats) {
45: 	if (stats.empty()) {
46: 		return Value();
47: 	}
48: 	switch (type.id()) {
49: 	case LogicalTypeId::BOOLEAN: {
50: 		if (stats.size() != sizeof(bool)) {
51: 			throw InternalException("Incorrect stats size for type BOOLEAN");
52: 		}
53: 		return Value::BOOLEAN(Load<bool>((data_ptr_t)stats.c_str()));
54: 	}
55: 	case LogicalTypeId::UTINYINT:
56: 	case LogicalTypeId::USMALLINT:
57: 	case LogicalTypeId::UINTEGER:
58: 		if (stats.size() != sizeof(uint32_t)) {
59: 			throw InternalException("Incorrect stats size for type UINTEGER");
60: 		}
61: 		return Value::UINTEGER(Load<uint32_t>((data_ptr_t)stats.c_str()));
62: 	case LogicalTypeId::UBIGINT:
63: 		if (stats.size() != sizeof(uint64_t)) {
64: 			throw InternalException("Incorrect stats size for type UBIGINT");
65: 		}
66: 		return Value::UBIGINT(Load<uint64_t>((data_ptr_t)stats.c_str()));
67: 	case LogicalTypeId::TINYINT:
68: 	case LogicalTypeId::SMALLINT:
69: 	case LogicalTypeId::INTEGER:
70: 		if (stats.size() != sizeof(int32_t)) {
71: 			throw InternalException("Incorrect stats size for type INTEGER");
72: 		}
73: 		return Value::INTEGER(Load<int32_t>((data_ptr_t)stats.c_str()));
74: 	case LogicalTypeId::BIGINT:
75: 		if (stats.size() != sizeof(int64_t)) {
76: 			throw InternalException("Incorrect stats size for type BIGINT");
77: 		}
78: 		return Value::BIGINT(Load<int64_t>((data_ptr_t)stats.c_str()));
79: 	case LogicalTypeId::FLOAT: {
80: 		if (stats.size() != sizeof(float)) {
81: 			throw InternalException("Incorrect stats size for type FLOAT");
82: 		}
83: 		auto val = Load<float>((data_ptr_t)stats.c_str());
84: 		if (!Value::FloatIsValid(val)) {
85: 			return Value();
86: 		}
87: 		return Value::FLOAT(val);
88: 	}
89: 	case LogicalTypeId::DOUBLE: {
90: 		if (stats.size() != sizeof(double)) {
91: 			throw InternalException("Incorrect stats size for type DOUBLE");
92: 		}
93: 		auto val = Load<double>((data_ptr_t)stats.c_str());
94: 		if (!Value::DoubleIsValid(val)) {
95: 			return Value();
96: 		}
97: 		return Value::DOUBLE(val);
98: 	}
99: 	case LogicalTypeId::DECIMAL: {
100: 		auto width = DecimalType::GetWidth(type);
101: 		auto scale = DecimalType::GetScale(type);
102: 		switch (schema_ele.type) {
103: 		case Type::INT32: {
104: 			if (stats.size() != sizeof(int32_t)) {
105: 				throw InternalException("Incorrect stats size for type %s", type.ToString());
106: 			}
107: 			return Value::DECIMAL(Load<int32_t>((data_ptr_t)stats.c_str()), width, scale);
108: 		}
109: 		case Type::INT64: {
110: 			if (stats.size() != sizeof(int64_t)) {
111: 				throw InternalException("Incorrect stats size for type %s", type.ToString());
112: 			}
113: 			return Value::DECIMAL(Load<int64_t>((data_ptr_t)stats.c_str()), width, scale);
114: 		}
115: 		case Type::BYTE_ARRAY:
116: 		case Type::FIXED_LEN_BYTE_ARRAY:
117: 			switch (type.InternalType()) {
118: 			case PhysicalType::INT16:
119: 				return Value::DECIMAL(
120: 				    ParquetDecimalUtils::ReadDecimalValue<int16_t>((const_data_ptr_t)stats.c_str(), stats.size()),
121: 				    width, scale);
122: 			case PhysicalType::INT32:
123: 				return Value::DECIMAL(
124: 				    ParquetDecimalUtils::ReadDecimalValue<int32_t>((const_data_ptr_t)stats.c_str(), stats.size()),
125: 				    width, scale);
126: 			case PhysicalType::INT64:
127: 				return Value::DECIMAL(
128: 				    ParquetDecimalUtils::ReadDecimalValue<int64_t>((const_data_ptr_t)stats.c_str(), stats.size()),
129: 				    width, scale);
130: 			case PhysicalType::INT128:
131: 				return Value::DECIMAL(
132: 				    ParquetDecimalUtils::ReadDecimalValue<hugeint_t>((const_data_ptr_t)stats.c_str(), stats.size()),
133: 				    width, scale);
134: 			default:
135: 				throw InternalException("Unsupported internal type for decimal");
136: 			}
137: 		default:
138: 			throw InternalException("Unsupported internal type for decimal?..");
139: 		}
140: 	}
141: 	case LogicalType::VARCHAR:
142: 	case LogicalType::BLOB:
143: 		if (Value::StringIsValid(stats)) {
144: 			return Value(stats);
145: 		} else {
146: 			return Value(Blob::ToString(string_t(stats)));
147: 		}
148: 	case LogicalTypeId::DATE:
149: 		if (stats.size() != sizeof(int32_t)) {
150: 			throw InternalException("Incorrect stats size for type DATE");
151: 		}
152: 		return Value::DATE(date_t(Load<int32_t>((data_ptr_t)stats.c_str())));
153: 	case LogicalTypeId::TIME:
154: 		if (stats.size() != sizeof(int64_t)) {
155: 			throw InternalException("Incorrect stats size for type TIME");
156: 		}
157: 		return Value::TIME(dtime_t(Load<int64_t>((data_ptr_t)stats.c_str())));
158: 	case LogicalTypeId::TIMESTAMP: {
159: 		if (schema_ele.type == Type::INT96) {
160: 			if (stats.size() != sizeof(Int96)) {
161: 				throw InternalException("Incorrect stats size for type TIMESTAMP");
162: 			}
163: 			return Value::TIMESTAMP(ImpalaTimestampToTimestamp(Load<Int96>((data_ptr_t)stats.c_str())));
164: 		} else {
165: 			D_ASSERT(schema_ele.type == Type::INT64);
166: 			if (stats.size() != sizeof(int64_t)) {
167: 				throw InternalException("Incorrect stats size for type TIMESTAMP");
168: 			}
169: 			auto val = Load<int64_t>((data_ptr_t)stats.c_str());
170: 			if (schema_ele.converted_type == duckdb_parquet::format::ConvertedType::TIMESTAMP_MILLIS) {
171: 				return Value::TIMESTAMPMS(timestamp_t(val));
172: 			} else {
173: 				return Value::TIMESTAMP(timestamp_t(val));
174: 			}
175: 		}
176: 	}
177: 	default:
178: 		throw InternalException("Unsupported type for stats %s", type.ToString());
179: 	}
180: }
181: 
182: unique_ptr<BaseStatistics> ParquetStatisticsUtils::TransformColumnStatistics(const SchemaElement &s_ele,
183:                                                                              const LogicalType &type,
184:                                                                              const ColumnChunk &column_chunk) {
185: 	if (!column_chunk.__isset.meta_data || !column_chunk.meta_data.__isset.statistics) {
186: 		// no stats present for row group
187: 		return nullptr;
188: 	}
189: 	auto &parquet_stats = column_chunk.meta_data.statistics;
190: 	unique_ptr<BaseStatistics> row_group_stats;
191: 
192: 	switch (type.id()) {
193: 	case LogicalTypeId::UTINYINT:
194: 	case LogicalTypeId::USMALLINT:
195: 	case LogicalTypeId::UINTEGER:
196: 	case LogicalTypeId::UBIGINT:
197: 	case LogicalTypeId::TINYINT:
198: 	case LogicalTypeId::SMALLINT:
199: 	case LogicalTypeId::INTEGER:
200: 	case LogicalTypeId::BIGINT:
201: 	case LogicalTypeId::FLOAT:
202: 	case LogicalTypeId::DOUBLE:
203: 	case LogicalTypeId::DATE:
204: 	case LogicalTypeId::TIME:
205: 	case LogicalTypeId::TIMESTAMP:
206: 	case LogicalTypeId::TIMESTAMP_SEC:
207: 	case LogicalTypeId::TIMESTAMP_MS:
208: 	case LogicalTypeId::TIMESTAMP_NS:
209: 	case LogicalTypeId::DECIMAL:
210: 		row_group_stats = CreateNumericStats(type, s_ele, parquet_stats);
211: 		break;
212: 	case LogicalTypeId::VARCHAR: {
213: 		auto string_stats = make_unique<StringStatistics>(type);
214: 		if (parquet_stats.__isset.min) {
215: 			string_stats->Update(parquet_stats.min);
216: 		} else if (parquet_stats.__isset.min_value) {
217: 			string_stats->Update(parquet_stats.min_value);
218: 		} else {
219: 			return nullptr;
220: 		}
221: 		if (parquet_stats.__isset.max) {
222: 			string_stats->Update(parquet_stats.max);
223: 		} else if (parquet_stats.__isset.max_value) {
224: 			string_stats->Update(parquet_stats.max_value);
225: 		} else {
226: 			return nullptr;
227: 		}
228: 		string_stats->has_unicode = true; // we dont know better
229: 		string_stats->max_string_length = NumericLimits<uint32_t>::Maximum();
230: 		row_group_stats = move(string_stats);
231: 		break;
232: 	}
233: 	default:
234: 		// no stats for you
235: 		break;
236: 	} // end of type switch
237: 
238: 	// null count is generic
239: 	if (row_group_stats) {
240: 		if (column_chunk.meta_data.type == duckdb_parquet::format::Type::FLOAT ||
241: 		    column_chunk.meta_data.type == duckdb_parquet::format::Type::DOUBLE) {
242: 			// floats/doubles can have infinity, which can become NULL
243: 			row_group_stats->validity_stats = make_unique<ValidityStatistics>(true);
244: 		} else if (parquet_stats.__isset.null_count) {
245: 			row_group_stats->validity_stats = make_unique<ValidityStatistics>(parquet_stats.null_count != 0);
246: 		} else {
247: 			row_group_stats->validity_stats = make_unique<ValidityStatistics>(true);
248: 		}
249: 	} else {
250: 		// if stats are missing from any row group we know squat
251: 		return nullptr;
252: 	}
253: 
254: 	return row_group_stats;
255: }
256: 
257: } // namespace duckdb
[end of extension/parquet/parquet_statistics.cpp]
[start of src/common/operator/cast_operators.cpp]
1: #include "duckdb/common/operator/cast_operators.hpp"
2: #include "duckdb/common/operator/string_cast.hpp"
3: #include "duckdb/common/operator/numeric_cast.hpp"
4: #include "duckdb/common/operator/decimal_cast_operators.hpp"
5: 
6: #include "duckdb/common/exception.hpp"
7: #include "duckdb/common/limits.hpp"
8: #include "duckdb/common/string_util.hpp"
9: #include "duckdb/common/types/blob.hpp"
10: #include "duckdb/common/types/cast_helpers.hpp"
11: #include "duckdb/common/types/date.hpp"
12: #include "duckdb/common/types/decimal.hpp"
13: #include "duckdb/common/types/hugeint.hpp"
14: #include "duckdb/common/types/uuid.hpp"
15: #include "duckdb/common/types/interval.hpp"
16: #include "duckdb/common/types/time.hpp"
17: #include "duckdb/common/types/timestamp.hpp"
18: #include "duckdb/common/types/vector.hpp"
19: #include "fast_float/fast_float.h"
20: #include "fmt/format.h"
21: 
22: #include <cctype>
23: #include <cmath>
24: #include <cstdlib>
25: 
26: namespace duckdb {
27: 
28: //===--------------------------------------------------------------------===//
29: // Cast bool -> Numeric
30: //===--------------------------------------------------------------------===//
31: template <>
32: bool TryCast::Operation(bool input, bool &result, bool strict) {
33: 	return NumericTryCast::Operation<bool, bool>(input, result, strict);
34: }
35: 
36: template <>
37: bool TryCast::Operation(bool input, int8_t &result, bool strict) {
38: 	return NumericTryCast::Operation<bool, int8_t>(input, result, strict);
39: }
40: 
41: template <>
42: bool TryCast::Operation(bool input, int16_t &result, bool strict) {
43: 	return NumericTryCast::Operation<bool, int16_t>(input, result, strict);
44: }
45: 
46: template <>
47: bool TryCast::Operation(bool input, int32_t &result, bool strict) {
48: 	return NumericTryCast::Operation<bool, int32_t>(input, result, strict);
49: }
50: 
51: template <>
52: bool TryCast::Operation(bool input, int64_t &result, bool strict) {
53: 	return NumericTryCast::Operation<bool, int64_t>(input, result, strict);
54: }
55: 
56: template <>
57: bool TryCast::Operation(bool input, hugeint_t &result, bool strict) {
58: 	return NumericTryCast::Operation<bool, hugeint_t>(input, result, strict);
59: }
60: 
61: template <>
62: bool TryCast::Operation(bool input, uint8_t &result, bool strict) {
63: 	return NumericTryCast::Operation<bool, uint8_t>(input, result, strict);
64: }
65: 
66: template <>
67: bool TryCast::Operation(bool input, uint16_t &result, bool strict) {
68: 	return NumericTryCast::Operation<bool, uint16_t>(input, result, strict);
69: }
70: 
71: template <>
72: bool TryCast::Operation(bool input, uint32_t &result, bool strict) {
73: 	return NumericTryCast::Operation<bool, uint32_t>(input, result, strict);
74: }
75: 
76: template <>
77: bool TryCast::Operation(bool input, uint64_t &result, bool strict) {
78: 	return NumericTryCast::Operation<bool, uint64_t>(input, result, strict);
79: }
80: 
81: template <>
82: bool TryCast::Operation(bool input, float &result, bool strict) {
83: 	return NumericTryCast::Operation<bool, float>(input, result, strict);
84: }
85: 
86: template <>
87: bool TryCast::Operation(bool input, double &result, bool strict) {
88: 	return NumericTryCast::Operation<bool, double>(input, result, strict);
89: }
90: 
91: //===--------------------------------------------------------------------===//
92: // Cast int8_t -> Numeric
93: //===--------------------------------------------------------------------===//
94: template <>
95: bool TryCast::Operation(int8_t input, bool &result, bool strict) {
96: 	return NumericTryCast::Operation<int8_t, bool>(input, result, strict);
97: }
98: 
99: template <>
100: bool TryCast::Operation(int8_t input, int8_t &result, bool strict) {
101: 	return NumericTryCast::Operation<int8_t, int8_t>(input, result, strict);
102: }
103: 
104: template <>
105: bool TryCast::Operation(int8_t input, int16_t &result, bool strict) {
106: 	return NumericTryCast::Operation<int8_t, int16_t>(input, result, strict);
107: }
108: 
109: template <>
110: bool TryCast::Operation(int8_t input, int32_t &result, bool strict) {
111: 	return NumericTryCast::Operation<int8_t, int32_t>(input, result, strict);
112: }
113: 
114: template <>
115: bool TryCast::Operation(int8_t input, int64_t &result, bool strict) {
116: 	return NumericTryCast::Operation<int8_t, int64_t>(input, result, strict);
117: }
118: 
119: template <>
120: bool TryCast::Operation(int8_t input, hugeint_t &result, bool strict) {
121: 	return NumericTryCast::Operation<int8_t, hugeint_t>(input, result, strict);
122: }
123: 
124: template <>
125: bool TryCast::Operation(int8_t input, uint8_t &result, bool strict) {
126: 	return NumericTryCast::Operation<int8_t, uint8_t>(input, result, strict);
127: }
128: 
129: template <>
130: bool TryCast::Operation(int8_t input, uint16_t &result, bool strict) {
131: 	return NumericTryCast::Operation<int8_t, uint16_t>(input, result, strict);
132: }
133: 
134: template <>
135: bool TryCast::Operation(int8_t input, uint32_t &result, bool strict) {
136: 	return NumericTryCast::Operation<int8_t, uint32_t>(input, result, strict);
137: }
138: 
139: template <>
140: bool TryCast::Operation(int8_t input, uint64_t &result, bool strict) {
141: 	return NumericTryCast::Operation<int8_t, uint64_t>(input, result, strict);
142: }
143: 
144: template <>
145: bool TryCast::Operation(int8_t input, float &result, bool strict) {
146: 	return NumericTryCast::Operation<int8_t, float>(input, result, strict);
147: }
148: 
149: template <>
150: bool TryCast::Operation(int8_t input, double &result, bool strict) {
151: 	return NumericTryCast::Operation<int8_t, double>(input, result, strict);
152: }
153: 
154: //===--------------------------------------------------------------------===//
155: // Cast int16_t -> Numeric
156: //===--------------------------------------------------------------------===//
157: template <>
158: bool TryCast::Operation(int16_t input, bool &result, bool strict) {
159: 	return NumericTryCast::Operation<int16_t, bool>(input, result, strict);
160: }
161: 
162: template <>
163: bool TryCast::Operation(int16_t input, int8_t &result, bool strict) {
164: 	return NumericTryCast::Operation<int16_t, int8_t>(input, result, strict);
165: }
166: 
167: template <>
168: bool TryCast::Operation(int16_t input, int16_t &result, bool strict) {
169: 	return NumericTryCast::Operation<int16_t, int16_t>(input, result, strict);
170: }
171: 
172: template <>
173: bool TryCast::Operation(int16_t input, int32_t &result, bool strict) {
174: 	return NumericTryCast::Operation<int16_t, int32_t>(input, result, strict);
175: }
176: 
177: template <>
178: bool TryCast::Operation(int16_t input, int64_t &result, bool strict) {
179: 	return NumericTryCast::Operation<int16_t, int64_t>(input, result, strict);
180: }
181: 
182: template <>
183: bool TryCast::Operation(int16_t input, hugeint_t &result, bool strict) {
184: 	return NumericTryCast::Operation<int16_t, hugeint_t>(input, result, strict);
185: }
186: 
187: template <>
188: bool TryCast::Operation(int16_t input, uint8_t &result, bool strict) {
189: 	return NumericTryCast::Operation<int16_t, uint8_t>(input, result, strict);
190: }
191: 
192: template <>
193: bool TryCast::Operation(int16_t input, uint16_t &result, bool strict) {
194: 	return NumericTryCast::Operation<int16_t, uint16_t>(input, result, strict);
195: }
196: 
197: template <>
198: bool TryCast::Operation(int16_t input, uint32_t &result, bool strict) {
199: 	return NumericTryCast::Operation<int16_t, uint32_t>(input, result, strict);
200: }
201: 
202: template <>
203: bool TryCast::Operation(int16_t input, uint64_t &result, bool strict) {
204: 	return NumericTryCast::Operation<int16_t, uint64_t>(input, result, strict);
205: }
206: 
207: template <>
208: bool TryCast::Operation(int16_t input, float &result, bool strict) {
209: 	return NumericTryCast::Operation<int16_t, float>(input, result, strict);
210: }
211: 
212: template <>
213: bool TryCast::Operation(int16_t input, double &result, bool strict) {
214: 	return NumericTryCast::Operation<int16_t, double>(input, result, strict);
215: }
216: 
217: //===--------------------------------------------------------------------===//
218: // Cast int32_t -> Numeric
219: //===--------------------------------------------------------------------===//
220: template <>
221: bool TryCast::Operation(int32_t input, bool &result, bool strict) {
222: 	return NumericTryCast::Operation<int32_t, bool>(input, result, strict);
223: }
224: 
225: template <>
226: bool TryCast::Operation(int32_t input, int8_t &result, bool strict) {
227: 	return NumericTryCast::Operation<int32_t, int8_t>(input, result, strict);
228: }
229: 
230: template <>
231: bool TryCast::Operation(int32_t input, int16_t &result, bool strict) {
232: 	return NumericTryCast::Operation<int32_t, int16_t>(input, result, strict);
233: }
234: 
235: template <>
236: bool TryCast::Operation(int32_t input, int32_t &result, bool strict) {
237: 	return NumericTryCast::Operation<int32_t, int32_t>(input, result, strict);
238: }
239: 
240: template <>
241: bool TryCast::Operation(int32_t input, int64_t &result, bool strict) {
242: 	return NumericTryCast::Operation<int32_t, int64_t>(input, result, strict);
243: }
244: 
245: template <>
246: bool TryCast::Operation(int32_t input, hugeint_t &result, bool strict) {
247: 	return NumericTryCast::Operation<int32_t, hugeint_t>(input, result, strict);
248: }
249: 
250: template <>
251: bool TryCast::Operation(int32_t input, uint8_t &result, bool strict) {
252: 	return NumericTryCast::Operation<int32_t, uint8_t>(input, result, strict);
253: }
254: 
255: template <>
256: bool TryCast::Operation(int32_t input, uint16_t &result, bool strict) {
257: 	return NumericTryCast::Operation<int32_t, uint16_t>(input, result, strict);
258: }
259: 
260: template <>
261: bool TryCast::Operation(int32_t input, uint32_t &result, bool strict) {
262: 	return NumericTryCast::Operation<int32_t, uint32_t>(input, result, strict);
263: }
264: 
265: template <>
266: bool TryCast::Operation(int32_t input, uint64_t &result, bool strict) {
267: 	return NumericTryCast::Operation<int32_t, uint64_t>(input, result, strict);
268: }
269: 
270: template <>
271: bool TryCast::Operation(int32_t input, float &result, bool strict) {
272: 	return NumericTryCast::Operation<int32_t, float>(input, result, strict);
273: }
274: 
275: template <>
276: bool TryCast::Operation(int32_t input, double &result, bool strict) {
277: 	return NumericTryCast::Operation<int32_t, double>(input, result, strict);
278: }
279: 
280: //===--------------------------------------------------------------------===//
281: // Cast int64_t -> Numeric
282: //===--------------------------------------------------------------------===//
283: template <>
284: bool TryCast::Operation(int64_t input, bool &result, bool strict) {
285: 	return NumericTryCast::Operation<int64_t, bool>(input, result, strict);
286: }
287: 
288: template <>
289: bool TryCast::Operation(int64_t input, int8_t &result, bool strict) {
290: 	return NumericTryCast::Operation<int64_t, int8_t>(input, result, strict);
291: }
292: 
293: template <>
294: bool TryCast::Operation(int64_t input, int16_t &result, bool strict) {
295: 	return NumericTryCast::Operation<int64_t, int16_t>(input, result, strict);
296: }
297: 
298: template <>
299: bool TryCast::Operation(int64_t input, int32_t &result, bool strict) {
300: 	return NumericTryCast::Operation<int64_t, int32_t>(input, result, strict);
301: }
302: 
303: template <>
304: bool TryCast::Operation(int64_t input, int64_t &result, bool strict) {
305: 	return NumericTryCast::Operation<int64_t, int64_t>(input, result, strict);
306: }
307: 
308: template <>
309: bool TryCast::Operation(int64_t input, hugeint_t &result, bool strict) {
310: 	return NumericTryCast::Operation<int64_t, hugeint_t>(input, result, strict);
311: }
312: 
313: template <>
314: bool TryCast::Operation(int64_t input, uint8_t &result, bool strict) {
315: 	return NumericTryCast::Operation<int64_t, uint8_t>(input, result, strict);
316: }
317: 
318: template <>
319: bool TryCast::Operation(int64_t input, uint16_t &result, bool strict) {
320: 	return NumericTryCast::Operation<int64_t, uint16_t>(input, result, strict);
321: }
322: 
323: template <>
324: bool TryCast::Operation(int64_t input, uint32_t &result, bool strict) {
325: 	return NumericTryCast::Operation<int64_t, uint32_t>(input, result, strict);
326: }
327: 
328: template <>
329: bool TryCast::Operation(int64_t input, uint64_t &result, bool strict) {
330: 	return NumericTryCast::Operation<int64_t, uint64_t>(input, result, strict);
331: }
332: 
333: template <>
334: bool TryCast::Operation(int64_t input, float &result, bool strict) {
335: 	return NumericTryCast::Operation<int64_t, float>(input, result, strict);
336: }
337: 
338: template <>
339: bool TryCast::Operation(int64_t input, double &result, bool strict) {
340: 	return NumericTryCast::Operation<int64_t, double>(input, result, strict);
341: }
342: 
343: //===--------------------------------------------------------------------===//
344: // Cast hugeint_t -> Numeric
345: //===--------------------------------------------------------------------===//
346: template <>
347: bool TryCast::Operation(hugeint_t input, bool &result, bool strict) {
348: 	return NumericTryCast::Operation<hugeint_t, bool>(input, result, strict);
349: }
350: 
351: template <>
352: bool TryCast::Operation(hugeint_t input, int8_t &result, bool strict) {
353: 	return NumericTryCast::Operation<hugeint_t, int8_t>(input, result, strict);
354: }
355: 
356: template <>
357: bool TryCast::Operation(hugeint_t input, int16_t &result, bool strict) {
358: 	return NumericTryCast::Operation<hugeint_t, int16_t>(input, result, strict);
359: }
360: 
361: template <>
362: bool TryCast::Operation(hugeint_t input, int32_t &result, bool strict) {
363: 	return NumericTryCast::Operation<hugeint_t, int32_t>(input, result, strict);
364: }
365: 
366: template <>
367: bool TryCast::Operation(hugeint_t input, int64_t &result, bool strict) {
368: 	return NumericTryCast::Operation<hugeint_t, int64_t>(input, result, strict);
369: }
370: 
371: template <>
372: bool TryCast::Operation(hugeint_t input, hugeint_t &result, bool strict) {
373: 	return NumericTryCast::Operation<hugeint_t, hugeint_t>(input, result, strict);
374: }
375: 
376: template <>
377: bool TryCast::Operation(hugeint_t input, uint8_t &result, bool strict) {
378: 	return NumericTryCast::Operation<hugeint_t, uint8_t>(input, result, strict);
379: }
380: 
381: template <>
382: bool TryCast::Operation(hugeint_t input, uint16_t &result, bool strict) {
383: 	return NumericTryCast::Operation<hugeint_t, uint16_t>(input, result, strict);
384: }
385: 
386: template <>
387: bool TryCast::Operation(hugeint_t input, uint32_t &result, bool strict) {
388: 	return NumericTryCast::Operation<hugeint_t, uint32_t>(input, result, strict);
389: }
390: 
391: template <>
392: bool TryCast::Operation(hugeint_t input, uint64_t &result, bool strict) {
393: 	return NumericTryCast::Operation<hugeint_t, uint64_t>(input, result, strict);
394: }
395: 
396: template <>
397: bool TryCast::Operation(hugeint_t input, float &result, bool strict) {
398: 	return NumericTryCast::Operation<hugeint_t, float>(input, result, strict);
399: }
400: 
401: template <>
402: bool TryCast::Operation(hugeint_t input, double &result, bool strict) {
403: 	return NumericTryCast::Operation<hugeint_t, double>(input, result, strict);
404: }
405: 
406: //===--------------------------------------------------------------------===//
407: // Cast uint8_t -> Numeric
408: //===--------------------------------------------------------------------===//
409: template <>
410: bool TryCast::Operation(uint8_t input, bool &result, bool strict) {
411: 	return NumericTryCast::Operation<uint8_t, bool>(input, result, strict);
412: }
413: 
414: template <>
415: bool TryCast::Operation(uint8_t input, int8_t &result, bool strict) {
416: 	return NumericTryCast::Operation<uint8_t, int8_t>(input, result, strict);
417: }
418: 
419: template <>
420: bool TryCast::Operation(uint8_t input, int16_t &result, bool strict) {
421: 	return NumericTryCast::Operation<uint8_t, int16_t>(input, result, strict);
422: }
423: 
424: template <>
425: bool TryCast::Operation(uint8_t input, int32_t &result, bool strict) {
426: 	return NumericTryCast::Operation<uint8_t, int32_t>(input, result, strict);
427: }
428: 
429: template <>
430: bool TryCast::Operation(uint8_t input, int64_t &result, bool strict) {
431: 	return NumericTryCast::Operation<uint8_t, int64_t>(input, result, strict);
432: }
433: 
434: template <>
435: bool TryCast::Operation(uint8_t input, hugeint_t &result, bool strict) {
436: 	return NumericTryCast::Operation<uint8_t, hugeint_t>(input, result, strict);
437: }
438: 
439: template <>
440: bool TryCast::Operation(uint8_t input, uint8_t &result, bool strict) {
441: 	return NumericTryCast::Operation<uint8_t, uint8_t>(input, result, strict);
442: }
443: 
444: template <>
445: bool TryCast::Operation(uint8_t input, uint16_t &result, bool strict) {
446: 	return NumericTryCast::Operation<uint8_t, uint16_t>(input, result, strict);
447: }
448: 
449: template <>
450: bool TryCast::Operation(uint8_t input, uint32_t &result, bool strict) {
451: 	return NumericTryCast::Operation<uint8_t, uint32_t>(input, result, strict);
452: }
453: 
454: template <>
455: bool TryCast::Operation(uint8_t input, uint64_t &result, bool strict) {
456: 	return NumericTryCast::Operation<uint8_t, uint64_t>(input, result, strict);
457: }
458: 
459: template <>
460: bool TryCast::Operation(uint8_t input, float &result, bool strict) {
461: 	return NumericTryCast::Operation<uint8_t, float>(input, result, strict);
462: }
463: 
464: template <>
465: bool TryCast::Operation(uint8_t input, double &result, bool strict) {
466: 	return NumericTryCast::Operation<uint8_t, double>(input, result, strict);
467: }
468: 
469: //===--------------------------------------------------------------------===//
470: // Cast uint16_t -> Numeric
471: //===--------------------------------------------------------------------===//
472: template <>
473: bool TryCast::Operation(uint16_t input, bool &result, bool strict) {
474: 	return NumericTryCast::Operation<uint16_t, bool>(input, result, strict);
475: }
476: 
477: template <>
478: bool TryCast::Operation(uint16_t input, int8_t &result, bool strict) {
479: 	return NumericTryCast::Operation<uint16_t, int8_t>(input, result, strict);
480: }
481: 
482: template <>
483: bool TryCast::Operation(uint16_t input, int16_t &result, bool strict) {
484: 	return NumericTryCast::Operation<uint16_t, int16_t>(input, result, strict);
485: }
486: 
487: template <>
488: bool TryCast::Operation(uint16_t input, int32_t &result, bool strict) {
489: 	return NumericTryCast::Operation<uint16_t, int32_t>(input, result, strict);
490: }
491: 
492: template <>
493: bool TryCast::Operation(uint16_t input, int64_t &result, bool strict) {
494: 	return NumericTryCast::Operation<uint16_t, int64_t>(input, result, strict);
495: }
496: 
497: template <>
498: bool TryCast::Operation(uint16_t input, hugeint_t &result, bool strict) {
499: 	return NumericTryCast::Operation<uint16_t, hugeint_t>(input, result, strict);
500: }
501: 
502: template <>
503: bool TryCast::Operation(uint16_t input, uint8_t &result, bool strict) {
504: 	return NumericTryCast::Operation<uint16_t, uint8_t>(input, result, strict);
505: }
506: 
507: template <>
508: bool TryCast::Operation(uint16_t input, uint16_t &result, bool strict) {
509: 	return NumericTryCast::Operation<uint16_t, uint16_t>(input, result, strict);
510: }
511: 
512: template <>
513: bool TryCast::Operation(uint16_t input, uint32_t &result, bool strict) {
514: 	return NumericTryCast::Operation<uint16_t, uint32_t>(input, result, strict);
515: }
516: 
517: template <>
518: bool TryCast::Operation(uint16_t input, uint64_t &result, bool strict) {
519: 	return NumericTryCast::Operation<uint16_t, uint64_t>(input, result, strict);
520: }
521: 
522: template <>
523: bool TryCast::Operation(uint16_t input, float &result, bool strict) {
524: 	return NumericTryCast::Operation<uint16_t, float>(input, result, strict);
525: }
526: 
527: template <>
528: bool TryCast::Operation(uint16_t input, double &result, bool strict) {
529: 	return NumericTryCast::Operation<uint16_t, double>(input, result, strict);
530: }
531: 
532: //===--------------------------------------------------------------------===//
533: // Cast uint32_t -> Numeric
534: //===--------------------------------------------------------------------===//
535: template <>
536: bool TryCast::Operation(uint32_t input, bool &result, bool strict) {
537: 	return NumericTryCast::Operation<uint32_t, bool>(input, result, strict);
538: }
539: 
540: template <>
541: bool TryCast::Operation(uint32_t input, int8_t &result, bool strict) {
542: 	return NumericTryCast::Operation<uint32_t, int8_t>(input, result, strict);
543: }
544: 
545: template <>
546: bool TryCast::Operation(uint32_t input, int16_t &result, bool strict) {
547: 	return NumericTryCast::Operation<uint32_t, int16_t>(input, result, strict);
548: }
549: 
550: template <>
551: bool TryCast::Operation(uint32_t input, int32_t &result, bool strict) {
552: 	return NumericTryCast::Operation<uint32_t, int32_t>(input, result, strict);
553: }
554: 
555: template <>
556: bool TryCast::Operation(uint32_t input, int64_t &result, bool strict) {
557: 	return NumericTryCast::Operation<uint32_t, int64_t>(input, result, strict);
558: }
559: 
560: template <>
561: bool TryCast::Operation(uint32_t input, hugeint_t &result, bool strict) {
562: 	return NumericTryCast::Operation<uint32_t, hugeint_t>(input, result, strict);
563: }
564: 
565: template <>
566: bool TryCast::Operation(uint32_t input, uint8_t &result, bool strict) {
567: 	return NumericTryCast::Operation<uint32_t, uint8_t>(input, result, strict);
568: }
569: 
570: template <>
571: bool TryCast::Operation(uint32_t input, uint16_t &result, bool strict) {
572: 	return NumericTryCast::Operation<uint32_t, uint16_t>(input, result, strict);
573: }
574: 
575: template <>
576: bool TryCast::Operation(uint32_t input, uint32_t &result, bool strict) {
577: 	return NumericTryCast::Operation<uint32_t, uint32_t>(input, result, strict);
578: }
579: 
580: template <>
581: bool TryCast::Operation(uint32_t input, uint64_t &result, bool strict) {
582: 	return NumericTryCast::Operation<uint32_t, uint64_t>(input, result, strict);
583: }
584: 
585: template <>
586: bool TryCast::Operation(uint32_t input, float &result, bool strict) {
587: 	return NumericTryCast::Operation<uint32_t, float>(input, result, strict);
588: }
589: 
590: template <>
591: bool TryCast::Operation(uint32_t input, double &result, bool strict) {
592: 	return NumericTryCast::Operation<uint32_t, double>(input, result, strict);
593: }
594: 
595: //===--------------------------------------------------------------------===//
596: // Cast uint64_t -> Numeric
597: //===--------------------------------------------------------------------===//
598: template <>
599: bool TryCast::Operation(uint64_t input, bool &result, bool strict) {
600: 	return NumericTryCast::Operation<uint64_t, bool>(input, result, strict);
601: }
602: 
603: template <>
604: bool TryCast::Operation(uint64_t input, int8_t &result, bool strict) {
605: 	return NumericTryCast::Operation<uint64_t, int8_t>(input, result, strict);
606: }
607: 
608: template <>
609: bool TryCast::Operation(uint64_t input, int16_t &result, bool strict) {
610: 	return NumericTryCast::Operation<uint64_t, int16_t>(input, result, strict);
611: }
612: 
613: template <>
614: bool TryCast::Operation(uint64_t input, int32_t &result, bool strict) {
615: 	return NumericTryCast::Operation<uint64_t, int32_t>(input, result, strict);
616: }
617: 
618: template <>
619: bool TryCast::Operation(uint64_t input, int64_t &result, bool strict) {
620: 	return NumericTryCast::Operation<uint64_t, int64_t>(input, result, strict);
621: }
622: 
623: template <>
624: bool TryCast::Operation(uint64_t input, hugeint_t &result, bool strict) {
625: 	return NumericTryCast::Operation<uint64_t, hugeint_t>(input, result, strict);
626: }
627: 
628: template <>
629: bool TryCast::Operation(uint64_t input, uint8_t &result, bool strict) {
630: 	return NumericTryCast::Operation<uint64_t, uint8_t>(input, result, strict);
631: }
632: 
633: template <>
634: bool TryCast::Operation(uint64_t input, uint16_t &result, bool strict) {
635: 	return NumericTryCast::Operation<uint64_t, uint16_t>(input, result, strict);
636: }
637: 
638: template <>
639: bool TryCast::Operation(uint64_t input, uint32_t &result, bool strict) {
640: 	return NumericTryCast::Operation<uint64_t, uint32_t>(input, result, strict);
641: }
642: 
643: template <>
644: bool TryCast::Operation(uint64_t input, uint64_t &result, bool strict) {
645: 	return NumericTryCast::Operation<uint64_t, uint64_t>(input, result, strict);
646: }
647: 
648: template <>
649: bool TryCast::Operation(uint64_t input, float &result, bool strict) {
650: 	return NumericTryCast::Operation<uint64_t, float>(input, result, strict);
651: }
652: 
653: template <>
654: bool TryCast::Operation(uint64_t input, double &result, bool strict) {
655: 	return NumericTryCast::Operation<uint64_t, double>(input, result, strict);
656: }
657: 
658: //===--------------------------------------------------------------------===//
659: // Cast float -> Numeric
660: //===--------------------------------------------------------------------===//
661: template <>
662: bool TryCast::Operation(float input, bool &result, bool strict) {
663: 	return NumericTryCast::Operation<float, bool>(input, result, strict);
664: }
665: 
666: template <>
667: bool TryCast::Operation(float input, int8_t &result, bool strict) {
668: 	return NumericTryCast::Operation<float, int8_t>(input, result, strict);
669: }
670: 
671: template <>
672: bool TryCast::Operation(float input, int16_t &result, bool strict) {
673: 	return NumericTryCast::Operation<float, int16_t>(input, result, strict);
674: }
675: 
676: template <>
677: bool TryCast::Operation(float input, int32_t &result, bool strict) {
678: 	return NumericTryCast::Operation<float, int32_t>(input, result, strict);
679: }
680: 
681: template <>
682: bool TryCast::Operation(float input, int64_t &result, bool strict) {
683: 	return NumericTryCast::Operation<float, int64_t>(input, result, strict);
684: }
685: 
686: template <>
687: bool TryCast::Operation(float input, hugeint_t &result, bool strict) {
688: 	return NumericTryCast::Operation<float, hugeint_t>(input, result, strict);
689: }
690: 
691: template <>
692: bool TryCast::Operation(float input, uint8_t &result, bool strict) {
693: 	return NumericTryCast::Operation<float, uint8_t>(input, result, strict);
694: }
695: 
696: template <>
697: bool TryCast::Operation(float input, uint16_t &result, bool strict) {
698: 	return NumericTryCast::Operation<float, uint16_t>(input, result, strict);
699: }
700: 
701: template <>
702: bool TryCast::Operation(float input, uint32_t &result, bool strict) {
703: 	return NumericTryCast::Operation<float, uint32_t>(input, result, strict);
704: }
705: 
706: template <>
707: bool TryCast::Operation(float input, uint64_t &result, bool strict) {
708: 	return NumericTryCast::Operation<float, uint64_t>(input, result, strict);
709: }
710: 
711: template <>
712: bool TryCast::Operation(float input, float &result, bool strict) {
713: 	return NumericTryCast::Operation<float, float>(input, result, strict);
714: }
715: 
716: template <>
717: bool TryCast::Operation(float input, double &result, bool strict) {
718: 	return NumericTryCast::Operation<float, double>(input, result, strict);
719: }
720: 
721: //===--------------------------------------------------------------------===//
722: // Cast double -> Numeric
723: //===--------------------------------------------------------------------===//
724: template <>
725: bool TryCast::Operation(double input, bool &result, bool strict) {
726: 	return NumericTryCast::Operation<double, bool>(input, result, strict);
727: }
728: 
729: template <>
730: bool TryCast::Operation(double input, int8_t &result, bool strict) {
731: 	return NumericTryCast::Operation<double, int8_t>(input, result, strict);
732: }
733: 
734: template <>
735: bool TryCast::Operation(double input, int16_t &result, bool strict) {
736: 	return NumericTryCast::Operation<double, int16_t>(input, result, strict);
737: }
738: 
739: template <>
740: bool TryCast::Operation(double input, int32_t &result, bool strict) {
741: 	return NumericTryCast::Operation<double, int32_t>(input, result, strict);
742: }
743: 
744: template <>
745: bool TryCast::Operation(double input, int64_t &result, bool strict) {
746: 	return NumericTryCast::Operation<double, int64_t>(input, result, strict);
747: }
748: 
749: template <>
750: bool TryCast::Operation(double input, hugeint_t &result, bool strict) {
751: 	return NumericTryCast::Operation<double, hugeint_t>(input, result, strict);
752: }
753: 
754: template <>
755: bool TryCast::Operation(double input, uint8_t &result, bool strict) {
756: 	return NumericTryCast::Operation<double, uint8_t>(input, result, strict);
757: }
758: 
759: template <>
760: bool TryCast::Operation(double input, uint16_t &result, bool strict) {
761: 	return NumericTryCast::Operation<double, uint16_t>(input, result, strict);
762: }
763: 
764: template <>
765: bool TryCast::Operation(double input, uint32_t &result, bool strict) {
766: 	return NumericTryCast::Operation<double, uint32_t>(input, result, strict);
767: }
768: 
769: template <>
770: bool TryCast::Operation(double input, uint64_t &result, bool strict) {
771: 	return NumericTryCast::Operation<double, uint64_t>(input, result, strict);
772: }
773: 
774: template <>
775: bool TryCast::Operation(double input, float &result, bool strict) {
776: 	return NumericTryCast::Operation<double, float>(input, result, strict);
777: }
778: 
779: template <>
780: bool TryCast::Operation(double input, double &result, bool strict) {
781: 	return NumericTryCast::Operation<double, double>(input, result, strict);
782: }
783: 
784: //===--------------------------------------------------------------------===//
785: // Cast String -> Numeric
786: //===--------------------------------------------------------------------===//
787: struct IntegerCastOperation {
788: 	template <class T, bool NEGATIVE>
789: 	static bool HandleDigit(T &result, uint8_t digit) {
790: 		if (NEGATIVE) {
791: 			if (result < (NumericLimits<T>::Minimum() + digit) / 10) {
792: 				return false;
793: 			}
794: 			result = result * 10 - digit;
795: 		} else {
796: 			if (result > (NumericLimits<T>::Maximum() - digit) / 10) {
797: 				return false;
798: 			}
799: 			result = result * 10 + digit;
800: 		}
801: 		return true;
802: 	}
803: 
804: 	template <class T, bool NEGATIVE>
805: 	static bool HandleExponent(T &result, int64_t exponent) {
806: 		double dbl_res = result * std::pow(10.0L, exponent);
807: 		if (dbl_res < NumericLimits<T>::Minimum() || dbl_res > NumericLimits<T>::Maximum()) {
808: 			return false;
809: 		}
810: 		result = (T)dbl_res;
811: 		return true;
812: 	}
813: 
814: 	template <class T, bool NEGATIVE>
815: 	static bool HandleDecimal(T &result, uint8_t digit) {
816: 		return true;
817: 	}
818: 
819: 	template <class T>
820: 	static bool Finalize(T &result) {
821: 		return true;
822: 	}
823: };
824: 
825: template <class T, bool NEGATIVE, bool ALLOW_EXPONENT, class OP = IntegerCastOperation>
826: static bool IntegerCastLoop(const char *buf, idx_t len, T &result, bool strict) {
827: 	idx_t start_pos = NEGATIVE || *buf == '+' ? 1 : 0;
828: 	idx_t pos = start_pos;
829: 	while (pos < len) {
830: 		if (!StringUtil::CharacterIsDigit(buf[pos])) {
831: 			// not a digit!
832: 			if (buf[pos] == '.') {
833: 				if (strict) {
834: 					return false;
835: 				}
836: 				bool number_before_period = pos > start_pos;
837: 				// decimal point: we accept decimal values for integers as well
838: 				// we just truncate them
839: 				// make sure everything after the period is a number
840: 				pos++;
841: 				idx_t start_digit = pos;
842: 				while (pos < len) {
843: 					if (!StringUtil::CharacterIsDigit(buf[pos])) {
844: 						break;
845: 					}
846: 					if (!OP::template HandleDecimal<T, NEGATIVE>(result, buf[pos] - '0')) {
847: 						return false;
848: 					}
849: 					pos++;
850: 				}
851: 				// make sure there is either (1) one number after the period, or (2) one number before the period
852: 				// i.e. we accept "1." and ".1" as valid numbers, but not "."
853: 				if (!(number_before_period || pos > start_digit)) {
854: 					return false;
855: 				}
856: 				if (pos >= len) {
857: 					break;
858: 				}
859: 			}
860: 			if (StringUtil::CharacterIsSpace(buf[pos])) {
861: 				// skip any trailing spaces
862: 				while (++pos < len) {
863: 					if (!StringUtil::CharacterIsSpace(buf[pos])) {
864: 						return false;
865: 					}
866: 				}
867: 				break;
868: 			}
869: 			if (ALLOW_EXPONENT) {
870: 				if (buf[pos] == 'e' || buf[pos] == 'E') {
871: 					if (pos == start_pos) {
872: 						return false;
873: 					}
874: 					pos++;
875: 					if (pos >= len) {
876: 						return false;
877: 					}
878: 					int32_t exponent = 0;
879: 					int negative = buf[pos] == '-';
880: 					if (negative) {
881: 						if (!IntegerCastLoop<int32_t, true, false>(buf + pos, len - pos, exponent, strict)) {
882: 							return false;
883: 						}
884: 					} else {
885: 						if (!IntegerCastLoop<int32_t, false, false>(buf + pos, len - pos, exponent, strict)) {
886: 							return false;
887: 						}
888: 					}
889: 					return OP::template HandleExponent<T, NEGATIVE>(result, exponent);
890: 				}
891: 			}
892: 			return false;
893: 		}
894: 		uint8_t digit = buf[pos++] - '0';
895: 		if (!OP::template HandleDigit<T, NEGATIVE>(result, digit)) {
896: 			return false;
897: 		}
898: 	}
899: 	if (!OP::template Finalize<T>(result)) {
900: 		return false;
901: 	}
902: 	return pos > start_pos;
903: }
904: 
905: template <class T, bool IS_SIGNED = true, bool ALLOW_EXPONENT = true, class OP = IntegerCastOperation,
906:           bool ZERO_INITIALIZE = true>
907: static bool TryIntegerCast(const char *buf, idx_t len, T &result, bool strict) {
908: 	// skip any spaces at the start
909: 	while (len > 0 && StringUtil::CharacterIsSpace(*buf)) {
910: 		buf++;
911: 		len--;
912: 	}
913: 	if (len == 0) {
914: 		return false;
915: 	}
916: 	int negative = *buf == '-';
917: 
918: 	if (ZERO_INITIALIZE) {
919: 		memset(&result, 0, sizeof(T));
920: 	}
921: 	if (!negative) {
922: 		return IntegerCastLoop<T, false, ALLOW_EXPONENT, OP>(buf, len, result, strict);
923: 	} else {
924: 		if (!IS_SIGNED) {
925: 			// Need to check if its not -0
926: 			idx_t pos = 1;
927: 			while (pos < len) {
928: 				if (buf[pos++] != '0') {
929: 					return false;
930: 				}
931: 			}
932: 		}
933: 		return IntegerCastLoop<T, true, ALLOW_EXPONENT, OP>(buf, len, result, strict);
934: 	}
935: }
936: 
937: template <>
938: bool TryCast::Operation(string_t input, bool &result, bool strict) {
939: 	auto input_data = input.GetDataUnsafe();
940: 	auto input_size = input.GetSize();
941: 
942: 	switch (input_size) {
943: 	case 1: {
944: 		char c = std::tolower(*input_data);
945: 		if (c == 't' || (!strict && c == '1')) {
946: 			result = true;
947: 			return true;
948: 		} else if (c == 'f' || (!strict && c == '0')) {
949: 			result = false;
950: 			return true;
951: 		}
952: 		return false;
953: 	}
954: 	case 4: {
955: 		char t = std::tolower(input_data[0]);
956: 		char r = std::tolower(input_data[1]);
957: 		char u = std::tolower(input_data[2]);
958: 		char e = std::tolower(input_data[3]);
959: 		if (t == 't' && r == 'r' && u == 'u' && e == 'e') {
960: 			result = true;
961: 			return true;
962: 		}
963: 		return false;
964: 	}
965: 	case 5: {
966: 		char f = std::tolower(input_data[0]);
967: 		char a = std::tolower(input_data[1]);
968: 		char l = std::tolower(input_data[2]);
969: 		char s = std::tolower(input_data[3]);
970: 		char e = std::tolower(input_data[4]);
971: 		if (f == 'f' && a == 'a' && l == 'l' && s == 's' && e == 'e') {
972: 			result = false;
973: 			return true;
974: 		}
975: 		return false;
976: 	}
977: 	default:
978: 		return false;
979: 	}
980: }
981: template <>
982: bool TryCast::Operation(string_t input, int8_t &result, bool strict) {
983: 	return TryIntegerCast<int8_t>(input.GetDataUnsafe(), input.GetSize(), result, strict);
984: }
985: template <>
986: bool TryCast::Operation(string_t input, int16_t &result, bool strict) {
987: 	return TryIntegerCast<int16_t>(input.GetDataUnsafe(), input.GetSize(), result, strict);
988: }
989: template <>
990: bool TryCast::Operation(string_t input, int32_t &result, bool strict) {
991: 	return TryIntegerCast<int32_t>(input.GetDataUnsafe(), input.GetSize(), result, strict);
992: }
993: template <>
994: bool TryCast::Operation(string_t input, int64_t &result, bool strict) {
995: 	return TryIntegerCast<int64_t>(input.GetDataUnsafe(), input.GetSize(), result, strict);
996: }
997: 
998: template <>
999: bool TryCast::Operation(string_t input, uint8_t &result, bool strict) {
1000: 	return TryIntegerCast<uint8_t, false>(input.GetDataUnsafe(), input.GetSize(), result, strict);
1001: }
1002: template <>
1003: bool TryCast::Operation(string_t input, uint16_t &result, bool strict) {
1004: 	return TryIntegerCast<uint16_t, false>(input.GetDataUnsafe(), input.GetSize(), result, strict);
1005: }
1006: template <>
1007: bool TryCast::Operation(string_t input, uint32_t &result, bool strict) {
1008: 	return TryIntegerCast<uint32_t, false>(input.GetDataUnsafe(), input.GetSize(), result, strict);
1009: }
1010: template <>
1011: bool TryCast::Operation(string_t input, uint64_t &result, bool strict) {
1012: 	return TryIntegerCast<uint64_t, false>(input.GetDataUnsafe(), input.GetSize(), result, strict);
1013: }
1014: 
1015: template <class T>
1016: bool CheckDoubleValidity(T value);
1017: 
1018: template <>
1019: bool CheckDoubleValidity(float value) {
1020: 	return Value::FloatIsValid(value);
1021: }
1022: 
1023: template <>
1024: bool CheckDoubleValidity(double value) {
1025: 	return Value::DoubleIsValid(value);
1026: }
1027: 
1028: template <class T>
1029: static bool TryDoubleCast(const char *buf, idx_t len, T &result, bool strict) {
1030: 	// skip any spaces at the start
1031: 	while (len > 0 && StringUtil::CharacterIsSpace(*buf)) {
1032: 		buf++;
1033: 		len--;
1034: 	}
1035: 	if (len == 0) {
1036: 		return false;
1037: 	}
1038: 	if (*buf == '+') {
1039: 		buf++;
1040: 		len--;
1041: 	}
1042: 	auto endptr = buf + len;
1043: 	auto parse_result = duckdb_fast_float::from_chars(buf, buf + len, result);
1044: 	if (!CheckDoubleValidity<T>(result)) {
1045: 		return false;
1046: 	}
1047: 	if (parse_result.ec != std::errc()) {
1048: 		return false;
1049: 	}
1050: 	auto current_end = parse_result.ptr;
1051: 	if (!strict) {
1052: 		while (current_end < endptr && StringUtil::CharacterIsSpace(*current_end)) {
1053: 			current_end++;
1054: 		}
1055: 	}
1056: 	return current_end == endptr;
1057: }
1058: 
1059: template <>
1060: bool TryCast::Operation(string_t input, float &result, bool strict) {
1061: 	return TryDoubleCast<float>(input.GetDataUnsafe(), input.GetSize(), result, strict);
1062: }
1063: 
1064: template <>
1065: bool TryCast::Operation(string_t input, double &result, bool strict) {
1066: 	return TryDoubleCast<double>(input.GetDataUnsafe(), input.GetSize(), result, strict);
1067: }
1068: 
1069: //===--------------------------------------------------------------------===//
1070: // Cast From Date
1071: //===--------------------------------------------------------------------===//
1072: template <>
1073: bool TryCast::Operation(date_t input, date_t &result, bool strict) {
1074: 	result = input;
1075: 	return true;
1076: }
1077: 
1078: template <>
1079: bool TryCast::Operation(date_t input, timestamp_t &result, bool strict) {
1080: 	return Timestamp::TryFromDatetime(input, Time::FromTime(0, 0, 0), result);
1081: }
1082: 
1083: //===--------------------------------------------------------------------===//
1084: // Cast From Time
1085: //===--------------------------------------------------------------------===//
1086: template <>
1087: bool TryCast::Operation(dtime_t input, dtime_t &result, bool strict) {
1088: 	result = input;
1089: 	return true;
1090: }
1091: 
1092: //===--------------------------------------------------------------------===//
1093: // Cast From Timestamps
1094: //===--------------------------------------------------------------------===//
1095: template <>
1096: bool TryCast::Operation(timestamp_t input, date_t &result, bool strict) {
1097: 	result = Timestamp::GetDate(input);
1098: 	return true;
1099: }
1100: 
1101: template <>
1102: bool TryCast::Operation(timestamp_t input, dtime_t &result, bool strict) {
1103: 	result = Timestamp::GetTime(input);
1104: 	return true;
1105: }
1106: 
1107: template <>
1108: bool TryCast::Operation(timestamp_t input, timestamp_t &result, bool strict) {
1109: 	result = input;
1110: 	return true;
1111: }
1112: 
1113: //===--------------------------------------------------------------------===//
1114: // Cast from Interval
1115: //===--------------------------------------------------------------------===//
1116: template <>
1117: bool TryCast::Operation(interval_t input, interval_t &result, bool strict) {
1118: 	result = input;
1119: 	return true;
1120: }
1121: 
1122: //===--------------------------------------------------------------------===//
1123: // Non-Standard Timestamps
1124: //===--------------------------------------------------------------------===//
1125: template <>
1126: duckdb::string_t CastFromTimestampNS::Operation(duckdb::timestamp_t input, Vector &result) {
1127: 	return StringCast::Operation<timestamp_t>(Timestamp::FromEpochNanoSeconds(input.value), result);
1128: }
1129: template <>
1130: duckdb::string_t CastFromTimestampMS::Operation(duckdb::timestamp_t input, Vector &result) {
1131: 	return StringCast::Operation<timestamp_t>(Timestamp::FromEpochMs(input.value), result);
1132: }
1133: template <>
1134: duckdb::string_t CastFromTimestampSec::Operation(duckdb::timestamp_t input, Vector &result) {
1135: 	return StringCast::Operation<timestamp_t>(Timestamp::FromEpochSeconds(input.value), result);
1136: }
1137: 
1138: template <>
1139: timestamp_t CastTimestampUsToMs::Operation(timestamp_t input) {
1140: 	timestamp_t cast_timestamp(Timestamp::GetEpochMs(input));
1141: 	return cast_timestamp;
1142: }
1143: 
1144: template <>
1145: timestamp_t CastTimestampUsToNs::Operation(timestamp_t input) {
1146: 	timestamp_t cast_timestamp(Timestamp::GetEpochNanoSeconds(input));
1147: 	return cast_timestamp;
1148: }
1149: 
1150: template <>
1151: timestamp_t CastTimestampUsToSec::Operation(timestamp_t input) {
1152: 	timestamp_t cast_timestamp(Timestamp::GetEpochSeconds(input));
1153: 	return cast_timestamp;
1154: }
1155: template <>
1156: timestamp_t CastTimestampMsToUs::Operation(timestamp_t input) {
1157: 	return Timestamp::FromEpochMs(input.value);
1158: }
1159: 
1160: template <>
1161: timestamp_t CastTimestampNsToUs::Operation(timestamp_t input) {
1162: 	return Timestamp::FromEpochNanoSeconds(input.value);
1163: }
1164: 
1165: template <>
1166: timestamp_t CastTimestampSecToUs::Operation(timestamp_t input) {
1167: 	return Timestamp::FromEpochSeconds(input.value);
1168: }
1169: 
1170: //===--------------------------------------------------------------------===//
1171: // Cast To Timestamp
1172: //===--------------------------------------------------------------------===//
1173: template <>
1174: bool TryCastToTimestampNS::Operation(string_t input, timestamp_t &result, bool strict) {
1175: 	if (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {
1176: 		return false;
1177: 	}
1178: 	result = Timestamp::GetEpochNanoSeconds(result);
1179: 	return true;
1180: }
1181: 
1182: template <>
1183: bool TryCastToTimestampMS::Operation(string_t input, timestamp_t &result, bool strict) {
1184: 	if (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {
1185: 		return false;
1186: 	}
1187: 	result = Timestamp::GetEpochMs(result);
1188: 	return true;
1189: }
1190: 
1191: template <>
1192: bool TryCastToTimestampSec::Operation(string_t input, timestamp_t &result, bool strict) {
1193: 	if (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {
1194: 		return false;
1195: 	}
1196: 	result = Timestamp::GetEpochSeconds(result);
1197: 	return true;
1198: }
1199: 
1200: //===--------------------------------------------------------------------===//
1201: // Cast From Blob
1202: //===--------------------------------------------------------------------===//
1203: template <>
1204: string_t CastFromBlob::Operation(string_t input, Vector &vector) {
1205: 	idx_t result_size = Blob::GetStringSize(input);
1206: 
1207: 	string_t result = StringVector::EmptyString(vector, result_size);
1208: 	Blob::ToString(input, result.GetDataWriteable());
1209: 	result.Finalize();
1210: 	return result;
1211: }
1212: 
1213: //===--------------------------------------------------------------------===//
1214: // Cast To Blob
1215: //===--------------------------------------------------------------------===//
1216: template <>
1217: bool TryCastToBlob::Operation(string_t input, string_t &result, Vector &result_vector, string *error_message,
1218:                               bool strict) {
1219: 	idx_t result_size;
1220: 	if (!Blob::TryGetBlobSize(input, result_size, error_message)) {
1221: 		return false;
1222: 	}
1223: 
1224: 	result = StringVector::EmptyString(result_vector, result_size);
1225: 	Blob::ToBlob(input, (data_ptr_t)result.GetDataWriteable());
1226: 	result.Finalize();
1227: 	return true;
1228: }
1229: 
1230: //===--------------------------------------------------------------------===//
1231: // Cast From UUID
1232: //===--------------------------------------------------------------------===//
1233: template <>
1234: string_t CastFromUUID::Operation(hugeint_t input, Vector &vector) {
1235: 	string_t result = StringVector::EmptyString(vector, 36);
1236: 	UUID::ToString(input, result.GetDataWriteable());
1237: 	result.Finalize();
1238: 	return result;
1239: }
1240: 
1241: //===--------------------------------------------------------------------===//
1242: // Cast To UUID
1243: //===--------------------------------------------------------------------===//
1244: template <>
1245: bool TryCastToUUID::Operation(string_t input, hugeint_t &result, Vector &result_vector, string *error_message,
1246:                               bool strict) {
1247: 	return UUID::FromString(input.GetString(), result);
1248: }
1249: 
1250: //===--------------------------------------------------------------------===//
1251: // Cast To Date
1252: //===--------------------------------------------------------------------===//
1253: template <>
1254: bool TryCastErrorMessage::Operation(string_t input, date_t &result, string *error_message, bool strict) {
1255: 	if (!TryCast::Operation<string_t, date_t>(input, result, strict)) {
1256: 		HandleCastError::AssignError(Date::ConversionError(input), error_message);
1257: 		return false;
1258: 	}
1259: 	return true;
1260: }
1261: 
1262: template <>
1263: bool TryCast::Operation(string_t input, date_t &result, bool strict) {
1264: 	idx_t pos;
1265: 	return Date::TryConvertDate(input.GetDataUnsafe(), input.GetSize(), pos, result, strict);
1266: }
1267: 
1268: template <>
1269: date_t Cast::Operation(string_t input) {
1270: 	return Date::FromCString(input.GetDataUnsafe(), input.GetSize());
1271: }
1272: 
1273: //===--------------------------------------------------------------------===//
1274: // Cast To Time
1275: //===--------------------------------------------------------------------===//
1276: template <>
1277: bool TryCastErrorMessage::Operation(string_t input, dtime_t &result, string *error_message, bool strict) {
1278: 	if (!TryCast::Operation<string_t, dtime_t>(input, result, strict)) {
1279: 		HandleCastError::AssignError(Time::ConversionError(input), error_message);
1280: 		return false;
1281: 	}
1282: 	return true;
1283: }
1284: 
1285: template <>
1286: bool TryCast::Operation(string_t input, dtime_t &result, bool strict) {
1287: 	idx_t pos;
1288: 	return Time::TryConvertTime(input.GetDataUnsafe(), input.GetSize(), pos, result, strict);
1289: }
1290: 
1291: template <>
1292: dtime_t Cast::Operation(string_t input) {
1293: 	return Time::FromCString(input.GetDataUnsafe(), input.GetSize());
1294: }
1295: 
1296: //===--------------------------------------------------------------------===//
1297: // Cast To Timestamp
1298: //===--------------------------------------------------------------------===//
1299: template <>
1300: bool TryCastErrorMessage::Operation(string_t input, timestamp_t &result, string *error_message, bool strict) {
1301: 	if (!TryCast::Operation<string_t, timestamp_t>(input, result, strict)) {
1302: 		HandleCastError::AssignError(Timestamp::ConversionError(input), error_message);
1303: 		return false;
1304: 	}
1305: 	return true;
1306: }
1307: 
1308: template <>
1309: bool TryCast::Operation(string_t input, timestamp_t &result, bool strict) {
1310: 	return Timestamp::TryConvertTimestamp(input.GetDataUnsafe(), input.GetSize(), result);
1311: }
1312: 
1313: template <>
1314: timestamp_t Cast::Operation(string_t input) {
1315: 	return Timestamp::FromCString(input.GetDataUnsafe(), input.GetSize());
1316: }
1317: 
1318: //===--------------------------------------------------------------------===//
1319: // Cast From Interval
1320: //===--------------------------------------------------------------------===//
1321: template <>
1322: bool TryCastErrorMessage::Operation(string_t input, interval_t &result, string *error_message, bool strict) {
1323: 	return Interval::FromCString(input.GetDataUnsafe(), input.GetSize(), result, error_message, strict);
1324: }
1325: 
1326: //===--------------------------------------------------------------------===//
1327: // Cast From Hugeint
1328: //===--------------------------------------------------------------------===//
1329: // parsing hugeint from string is done a bit differently for performance reasons
1330: // for other integer types we keep track of a single value
1331: // and multiply that value by 10 for every digit we read
1332: // however, for hugeints, multiplication is very expensive (>20X as expensive as for int64)
1333: // for that reason, we parse numbers first into an int64 value
1334: // when that value is full, we perform a HUGEINT multiplication to flush it into the hugeint
1335: // this takes the number of HUGEINT multiplications down from [0-38] to [0-2]
1336: struct HugeIntCastData {
1337: 	hugeint_t hugeint;
1338: 	int64_t intermediate;
1339: 	uint8_t digits;
1340: 
1341: 	bool Flush() {
1342: 		if (digits == 0 && intermediate == 0) {
1343: 			return true;
1344: 		}
1345: 		if (hugeint.lower != 0 || hugeint.upper != 0) {
1346: 			if (digits > 38) {
1347: 				return false;
1348: 			}
1349: 			if (!Hugeint::TryMultiply(hugeint, Hugeint::POWERS_OF_TEN[digits], hugeint)) {
1350: 				return false;
1351: 			}
1352: 		}
1353: 		if (!Hugeint::AddInPlace(hugeint, hugeint_t(intermediate))) {
1354: 			return false;
1355: 		}
1356: 		digits = 0;
1357: 		intermediate = 0;
1358: 		return true;
1359: 	}
1360: };
1361: 
1362: struct HugeIntegerCastOperation {
1363: 	template <class T, bool NEGATIVE>
1364: 	static bool HandleDigit(T &result, uint8_t digit) {
1365: 		if (NEGATIVE) {
1366: 			if (result.intermediate < (NumericLimits<int64_t>::Minimum() + digit) / 10) {
1367: 				// intermediate is full: need to flush it
1368: 				if (!result.Flush()) {
1369: 					return false;
1370: 				}
1371: 			}
1372: 			result.intermediate = result.intermediate * 10 - digit;
1373: 		} else {
1374: 			if (result.intermediate > (NumericLimits<int64_t>::Maximum() - digit) / 10) {
1375: 				if (!result.Flush()) {
1376: 					return false;
1377: 				}
1378: 			}
1379: 			result.intermediate = result.intermediate * 10 + digit;
1380: 		}
1381: 		result.digits++;
1382: 		return true;
1383: 	}
1384: 
1385: 	template <class T, bool NEGATIVE>
1386: 	static bool HandleExponent(T &result, int64_t exponent) {
1387: 		if (!result.Flush()) {
1388: 			return false;
1389: 		}
1390: 		if (exponent < -38 || exponent > 38) {
1391: 			// out of range for exact exponent: use double and convert
1392: 			double dbl_res = Hugeint::Cast<double>(result.hugeint) * std::pow(10.0L, exponent);
1393: 			if (dbl_res < Hugeint::Cast<double>(NumericLimits<hugeint_t>::Minimum()) ||
1394: 			    dbl_res > Hugeint::Cast<double>(NumericLimits<hugeint_t>::Maximum())) {
1395: 				return false;
1396: 			}
1397: 			result.hugeint = Hugeint::Convert(dbl_res);
1398: 			return true;
1399: 		}
1400: 		if (exponent < 0) {
1401: 			// negative exponent: divide by power of 10
1402: 			result.hugeint = Hugeint::Divide(result.hugeint, Hugeint::POWERS_OF_TEN[-exponent]);
1403: 			return true;
1404: 		} else {
1405: 			// positive exponent: multiply by power of 10
1406: 			return Hugeint::TryMultiply(result.hugeint, Hugeint::POWERS_OF_TEN[exponent], result.hugeint);
1407: 		}
1408: 	}
1409: 
1410: 	template <class T, bool NEGATIVE>
1411: 	static bool HandleDecimal(T &result, uint8_t digit) {
1412: 		return true;
1413: 	}
1414: 
1415: 	template <class T>
1416: 	static bool Finalize(T &result) {
1417: 		return result.Flush();
1418: 	}
1419: };
1420: 
1421: template <>
1422: bool TryCast::Operation(string_t input, hugeint_t &result, bool strict) {
1423: 	HugeIntCastData data;
1424: 	if (!TryIntegerCast<HugeIntCastData, true, true, HugeIntegerCastOperation>(input.GetDataUnsafe(), input.GetSize(),
1425: 	                                                                           data, strict)) {
1426: 		return false;
1427: 	}
1428: 	result = data.hugeint;
1429: 	return true;
1430: }
1431: 
1432: //===--------------------------------------------------------------------===//
1433: // Decimal String Cast
1434: //===--------------------------------------------------------------------===//
1435: template <class T>
1436: struct DecimalCastData {
1437: 	T result;
1438: 	uint8_t width;
1439: 	uint8_t scale;
1440: 	uint8_t digit_count;
1441: 	uint8_t decimal_count;
1442: };
1443: 
1444: struct DecimalCastOperation {
1445: 	template <class T, bool NEGATIVE>
1446: 	static bool HandleDigit(T &state, uint8_t digit) {
1447: 		if (state.result == 0 && digit == 0) {
1448: 			// leading zero's don't count towards the digit count
1449: 			return true;
1450: 		}
1451: 		if (state.digit_count == state.width - state.scale) {
1452: 			// width of decimal type is exceeded!
1453: 			return false;
1454: 		}
1455: 		state.digit_count++;
1456: 		if (NEGATIVE) {
1457: 			state.result = state.result * 10 - digit;
1458: 		} else {
1459: 			state.result = state.result * 10 + digit;
1460: 		}
1461: 		return true;
1462: 	}
1463: 
1464: 	template <class T, bool NEGATIVE>
1465: 	static bool HandleExponent(T &state, int64_t exponent) {
1466: 		Finalize<T>(state);
1467: 		if (exponent < 0) {
1468: 			for (idx_t i = 0; i < idx_t(-exponent); i++) {
1469: 				state.result /= 10;
1470: 				if (state.result == 0) {
1471: 					break;
1472: 				}
1473: 			}
1474: 			return true;
1475: 		} else {
1476: 			// positive exponent: append 0's
1477: 			for (idx_t i = 0; i < idx_t(exponent); i++) {
1478: 				if (!HandleDigit<T, NEGATIVE>(state, 0)) {
1479: 					return false;
1480: 				}
1481: 			}
1482: 			return true;
1483: 		}
1484: 	}
1485: 
1486: 	template <class T, bool NEGATIVE>
1487: 	static bool HandleDecimal(T &state, uint8_t digit) {
1488: 		if (state.decimal_count == state.scale) {
1489: 			// we exceeded the amount of supported decimals
1490: 			// however, we don't throw an error here
1491: 			// we just truncate the decimal
1492: 			return true;
1493: 		}
1494: 		state.decimal_count++;
1495: 		if (NEGATIVE) {
1496: 			state.result = state.result * 10 - digit;
1497: 		} else {
1498: 			state.result = state.result * 10 + digit;
1499: 		}
1500: 		return true;
1501: 	}
1502: 
1503: 	template <class T>
1504: 	static bool Finalize(T &state) {
1505: 		// if we have not gotten exactly "scale" decimals, we need to multiply the result
1506: 		// e.g. if we have a string "1.0" that is cast to a DECIMAL(9,3), the value needs to be 1000
1507: 		// but we have only gotten the value "10" so far, so we multiply by 1000
1508: 		for (uint8_t i = state.decimal_count; i < state.scale; i++) {
1509: 			state.result *= 10;
1510: 		}
1511: 		return true;
1512: 	}
1513: };
1514: 
1515: template <class T>
1516: bool TryDecimalStringCast(string_t input, T &result, string *error_message, uint8_t width, uint8_t scale) {
1517: 	DecimalCastData<T> state;
1518: 	state.result = 0;
1519: 	state.width = width;
1520: 	state.scale = scale;
1521: 	state.digit_count = 0;
1522: 	state.decimal_count = 0;
1523: 	if (!TryIntegerCast<DecimalCastData<T>, true, true, DecimalCastOperation, false>(input.GetDataUnsafe(),
1524: 	                                                                                 input.GetSize(), state, false)) {
1525: 		string error = StringUtil::Format("Could not convert string \"%s\" to DECIMAL(%d,%d)", input.GetString(),
1526: 		                                  (int)width, (int)scale);
1527: 		HandleCastError::AssignError(error, error_message);
1528: 		return false;
1529: 	}
1530: 	result = state.result;
1531: 	return true;
1532: }
1533: 
1534: template <>
1535: bool TryCastToDecimal::Operation(string_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1536: 	return TryDecimalStringCast<int16_t>(input, result, error_message, width, scale);
1537: }
1538: 
1539: template <>
1540: bool TryCastToDecimal::Operation(string_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1541: 	return TryDecimalStringCast<int32_t>(input, result, error_message, width, scale);
1542: }
1543: 
1544: template <>
1545: bool TryCastToDecimal::Operation(string_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1546: 	return TryDecimalStringCast<int64_t>(input, result, error_message, width, scale);
1547: }
1548: 
1549: template <>
1550: bool TryCastToDecimal::Operation(string_t input, hugeint_t &result, string *error_message, uint8_t width,
1551:                                  uint8_t scale) {
1552: 	return TryDecimalStringCast<hugeint_t>(input, result, error_message, width, scale);
1553: }
1554: 
1555: template <>
1556: string_t StringCastFromDecimal::Operation(int16_t input, uint8_t width, uint8_t scale, Vector &result) {
1557: 	return DecimalToString::Format<int16_t, uint16_t>(input, scale, result);
1558: }
1559: 
1560: template <>
1561: string_t StringCastFromDecimal::Operation(int32_t input, uint8_t width, uint8_t scale, Vector &result) {
1562: 	return DecimalToString::Format<int32_t, uint32_t>(input, scale, result);
1563: }
1564: 
1565: template <>
1566: string_t StringCastFromDecimal::Operation(int64_t input, uint8_t width, uint8_t scale, Vector &result) {
1567: 	return DecimalToString::Format<int64_t, uint64_t>(input, scale, result);
1568: }
1569: 
1570: template <>
1571: string_t StringCastFromDecimal::Operation(hugeint_t input, uint8_t width, uint8_t scale, Vector &result) {
1572: 	return HugeintToStringCast::FormatDecimal(input, scale, result);
1573: }
1574: 
1575: //===--------------------------------------------------------------------===//
1576: // Decimal Casts
1577: //===--------------------------------------------------------------------===//
1578: // Decimal <-> Bool
1579: //===--------------------------------------------------------------------===//
1580: template <class T, class OP = NumericHelper>
1581: bool TryCastBoolToDecimal(bool input, T &result, string *error_message, uint8_t width, uint8_t scale) {
1582: 	if (width > scale) {
1583: 		result = input ? OP::POWERS_OF_TEN[scale] : 0;
1584: 		return true;
1585: 	} else {
1586: 		return TryCast::Operation<bool, T>(input, result);
1587: 	}
1588: }
1589: 
1590: template <>
1591: bool TryCastToDecimal::Operation(bool input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1592: 	return TryCastBoolToDecimal<int16_t>(input, result, error_message, width, scale);
1593: }
1594: 
1595: template <>
1596: bool TryCastToDecimal::Operation(bool input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1597: 	return TryCastBoolToDecimal<int32_t>(input, result, error_message, width, scale);
1598: }
1599: 
1600: template <>
1601: bool TryCastToDecimal::Operation(bool input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1602: 	return TryCastBoolToDecimal<int64_t>(input, result, error_message, width, scale);
1603: }
1604: 
1605: template <>
1606: bool TryCastToDecimal::Operation(bool input, hugeint_t &result, string *error_message, uint8_t width, uint8_t scale) {
1607: 	return TryCastBoolToDecimal<hugeint_t, Hugeint>(input, result, error_message, width, scale);
1608: }
1609: 
1610: template <>
1611: bool TryCastFromDecimal::Operation(int16_t input, bool &result, string *error_message, uint8_t width, uint8_t scale) {
1612: 	return TryCast::Operation<int16_t, bool>(input, result);
1613: }
1614: 
1615: template <>
1616: bool TryCastFromDecimal::Operation(int32_t input, bool &result, string *error_message, uint8_t width, uint8_t scale) {
1617: 	return TryCast::Operation<int32_t, bool>(input, result);
1618: }
1619: 
1620: template <>
1621: bool TryCastFromDecimal::Operation(int64_t input, bool &result, string *error_message, uint8_t width, uint8_t scale) {
1622: 	return TryCast::Operation<int64_t, bool>(input, result);
1623: }
1624: 
1625: template <>
1626: bool TryCastFromDecimal::Operation(hugeint_t input, bool &result, string *error_message, uint8_t width, uint8_t scale) {
1627: 	return TryCast::Operation<hugeint_t, bool>(input, result);
1628: }
1629: 
1630: //===--------------------------------------------------------------------===//
1631: // Numeric -> Decimal Cast
1632: //===--------------------------------------------------------------------===//
1633: struct SignedToDecimalOperator {
1634: 	template <class SRC, class DST>
1635: 	static bool Operation(SRC input, DST max_width) {
1636: 		return int64_t(input) >= int64_t(max_width) || int64_t(input) <= int64_t(-max_width);
1637: 	}
1638: };
1639: 
1640: struct UnsignedToDecimalOperator {
1641: 	template <class SRC, class DST>
1642: 	static bool Operation(SRC input, DST max_width) {
1643: 		return uint64_t(input) >= uint64_t(max_width);
1644: 	}
1645: };
1646: 
1647: template <class SRC, class DST, class OP = SignedToDecimalOperator>
1648: bool StandardNumericToDecimalCast(SRC input, DST &result, string *error_message, uint8_t width, uint8_t scale) {
1649: 	// check for overflow
1650: 	DST max_width = NumericHelper::POWERS_OF_TEN[width - scale];
1651: 	if (OP::template Operation<SRC, DST>(input, max_width)) {
1652: 		string error = StringUtil::Format("Could not cast value %d to DECIMAL(%d,%d)", input, width, scale);
1653: 		HandleCastError::AssignError(error, error_message);
1654: 		return false;
1655: 	}
1656: 	result = DST(input) * NumericHelper::POWERS_OF_TEN[scale];
1657: 	return true;
1658: }
1659: 
1660: template <class SRC>
1661: bool NumericToHugeDecimalCast(SRC input, hugeint_t &result, string *error_message, uint8_t width, uint8_t scale) {
1662: 	// check for overflow
1663: 	hugeint_t max_width = Hugeint::POWERS_OF_TEN[width - scale];
1664: 	hugeint_t hinput = Hugeint::Convert(input);
1665: 	if (hinput >= max_width || hinput <= -max_width) {
1666: 		string error = StringUtil::Format("Could not cast value %s to DECIMAL(%d,%d)", hinput.ToString(), width, scale);
1667: 		HandleCastError::AssignError(error, error_message);
1668: 		return false;
1669: 	}
1670: 	result = hinput * Hugeint::POWERS_OF_TEN[scale];
1671: 	return true;
1672: }
1673: 
1674: //===--------------------------------------------------------------------===//
1675: // Cast int8_t -> Decimal
1676: //===--------------------------------------------------------------------===//
1677: template <>
1678: bool TryCastToDecimal::Operation(int8_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1679: 	return StandardNumericToDecimalCast<int8_t, int16_t>(input, result, error_message, width, scale);
1680: }
1681: template <>
1682: bool TryCastToDecimal::Operation(int8_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1683: 	return StandardNumericToDecimalCast<int8_t, int32_t>(input, result, error_message, width, scale);
1684: }
1685: template <>
1686: bool TryCastToDecimal::Operation(int8_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1687: 	return StandardNumericToDecimalCast<int8_t, int64_t>(input, result, error_message, width, scale);
1688: }
1689: template <>
1690: bool TryCastToDecimal::Operation(int8_t input, hugeint_t &result, string *error_message, uint8_t width, uint8_t scale) {
1691: 	return NumericToHugeDecimalCast<int8_t>(input, result, error_message, width, scale);
1692: }
1693: 
1694: //===--------------------------------------------------------------------===//
1695: // Cast int16_t -> Decimal
1696: //===--------------------------------------------------------------------===//
1697: template <>
1698: bool TryCastToDecimal::Operation(int16_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1699: 	return StandardNumericToDecimalCast<int16_t, int16_t>(input, result, error_message, width, scale);
1700: }
1701: template <>
1702: bool TryCastToDecimal::Operation(int16_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1703: 	return StandardNumericToDecimalCast<int16_t, int32_t>(input, result, error_message, width, scale);
1704: }
1705: template <>
1706: bool TryCastToDecimal::Operation(int16_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1707: 	return StandardNumericToDecimalCast<int16_t, int64_t>(input, result, error_message, width, scale);
1708: }
1709: template <>
1710: bool TryCastToDecimal::Operation(int16_t input, hugeint_t &result, string *error_message, uint8_t width,
1711:                                  uint8_t scale) {
1712: 	return NumericToHugeDecimalCast<int16_t>(input, result, error_message, width, scale);
1713: }
1714: 
1715: //===--------------------------------------------------------------------===//
1716: // Cast int32_t -> Decimal
1717: //===--------------------------------------------------------------------===//
1718: template <>
1719: bool TryCastToDecimal::Operation(int32_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1720: 	return StandardNumericToDecimalCast<int32_t, int16_t>(input, result, error_message, width, scale);
1721: }
1722: template <>
1723: bool TryCastToDecimal::Operation(int32_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1724: 	return StandardNumericToDecimalCast<int32_t, int32_t>(input, result, error_message, width, scale);
1725: }
1726: template <>
1727: bool TryCastToDecimal::Operation(int32_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1728: 	return StandardNumericToDecimalCast<int32_t, int64_t>(input, result, error_message, width, scale);
1729: }
1730: template <>
1731: bool TryCastToDecimal::Operation(int32_t input, hugeint_t &result, string *error_message, uint8_t width,
1732:                                  uint8_t scale) {
1733: 	return NumericToHugeDecimalCast<int32_t>(input, result, error_message, width, scale);
1734: }
1735: 
1736: //===--------------------------------------------------------------------===//
1737: // Cast int64_t -> Decimal
1738: //===--------------------------------------------------------------------===//
1739: template <>
1740: bool TryCastToDecimal::Operation(int64_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1741: 	return StandardNumericToDecimalCast<int64_t, int16_t>(input, result, error_message, width, scale);
1742: }
1743: template <>
1744: bool TryCastToDecimal::Operation(int64_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1745: 	return StandardNumericToDecimalCast<int64_t, int32_t>(input, result, error_message, width, scale);
1746: }
1747: template <>
1748: bool TryCastToDecimal::Operation(int64_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1749: 	return StandardNumericToDecimalCast<int64_t, int64_t>(input, result, error_message, width, scale);
1750: }
1751: template <>
1752: bool TryCastToDecimal::Operation(int64_t input, hugeint_t &result, string *error_message, uint8_t width,
1753:                                  uint8_t scale) {
1754: 	return NumericToHugeDecimalCast<int64_t>(input, result, error_message, width, scale);
1755: }
1756: 
1757: //===--------------------------------------------------------------------===//
1758: // Cast uint8_t -> Decimal
1759: //===--------------------------------------------------------------------===//
1760: template <>
1761: bool TryCastToDecimal::Operation(uint8_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1762: 	return StandardNumericToDecimalCast<uint8_t, int16_t, UnsignedToDecimalOperator>(input, result, error_message,
1763: 	                                                                                 width, scale);
1764: }
1765: template <>
1766: bool TryCastToDecimal::Operation(uint8_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1767: 	return StandardNumericToDecimalCast<uint8_t, int32_t, UnsignedToDecimalOperator>(input, result, error_message,
1768: 	                                                                                 width, scale);
1769: }
1770: template <>
1771: bool TryCastToDecimal::Operation(uint8_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1772: 	return StandardNumericToDecimalCast<uint8_t, int64_t, UnsignedToDecimalOperator>(input, result, error_message,
1773: 	                                                                                 width, scale);
1774: }
1775: template <>
1776: bool TryCastToDecimal::Operation(uint8_t input, hugeint_t &result, string *error_message, uint8_t width,
1777:                                  uint8_t scale) {
1778: 	return NumericToHugeDecimalCast<uint8_t>(input, result, error_message, width, scale);
1779: }
1780: 
1781: //===--------------------------------------------------------------------===//
1782: // Cast uint16_t -> Decimal
1783: //===--------------------------------------------------------------------===//
1784: template <>
1785: bool TryCastToDecimal::Operation(uint16_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1786: 	return StandardNumericToDecimalCast<uint16_t, int16_t, UnsignedToDecimalOperator>(input, result, error_message,
1787: 	                                                                                  width, scale);
1788: }
1789: template <>
1790: bool TryCastToDecimal::Operation(uint16_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1791: 	return StandardNumericToDecimalCast<uint16_t, int32_t, UnsignedToDecimalOperator>(input, result, error_message,
1792: 	                                                                                  width, scale);
1793: }
1794: template <>
1795: bool TryCastToDecimal::Operation(uint16_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1796: 	return StandardNumericToDecimalCast<uint16_t, int64_t, UnsignedToDecimalOperator>(input, result, error_message,
1797: 	                                                                                  width, scale);
1798: }
1799: template <>
1800: bool TryCastToDecimal::Operation(uint16_t input, hugeint_t &result, string *error_message, uint8_t width,
1801:                                  uint8_t scale) {
1802: 	return NumericToHugeDecimalCast<uint16_t>(input, result, error_message, width, scale);
1803: }
1804: 
1805: //===--------------------------------------------------------------------===//
1806: // Cast uint32_t -> Decimal
1807: //===--------------------------------------------------------------------===//
1808: template <>
1809: bool TryCastToDecimal::Operation(uint32_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1810: 	return StandardNumericToDecimalCast<uint32_t, int16_t, UnsignedToDecimalOperator>(input, result, error_message,
1811: 	                                                                                  width, scale);
1812: }
1813: template <>
1814: bool TryCastToDecimal::Operation(uint32_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1815: 	return StandardNumericToDecimalCast<uint32_t, int32_t, UnsignedToDecimalOperator>(input, result, error_message,
1816: 	                                                                                  width, scale);
1817: }
1818: template <>
1819: bool TryCastToDecimal::Operation(uint32_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1820: 	return StandardNumericToDecimalCast<uint32_t, int64_t, UnsignedToDecimalOperator>(input, result, error_message,
1821: 	                                                                                  width, scale);
1822: }
1823: template <>
1824: bool TryCastToDecimal::Operation(uint32_t input, hugeint_t &result, string *error_message, uint8_t width,
1825:                                  uint8_t scale) {
1826: 	return NumericToHugeDecimalCast<uint32_t>(input, result, error_message, width, scale);
1827: }
1828: 
1829: //===--------------------------------------------------------------------===//
1830: // Cast uint64_t -> Decimal
1831: //===--------------------------------------------------------------------===//
1832: template <>
1833: bool TryCastToDecimal::Operation(uint64_t input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1834: 	return StandardNumericToDecimalCast<uint64_t, int16_t, UnsignedToDecimalOperator>(input, result, error_message,
1835: 	                                                                                  width, scale);
1836: }
1837: template <>
1838: bool TryCastToDecimal::Operation(uint64_t input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1839: 	return StandardNumericToDecimalCast<uint64_t, int32_t, UnsignedToDecimalOperator>(input, result, error_message,
1840: 	                                                                                  width, scale);
1841: }
1842: template <>
1843: bool TryCastToDecimal::Operation(uint64_t input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1844: 	return StandardNumericToDecimalCast<uint64_t, int64_t, UnsignedToDecimalOperator>(input, result, error_message,
1845: 	                                                                                  width, scale);
1846: }
1847: template <>
1848: bool TryCastToDecimal::Operation(uint64_t input, hugeint_t &result, string *error_message, uint8_t width,
1849:                                  uint8_t scale) {
1850: 	return NumericToHugeDecimalCast<uint64_t>(input, result, error_message, width, scale);
1851: }
1852: 
1853: //===--------------------------------------------------------------------===//
1854: // Hugeint -> Decimal Cast
1855: //===--------------------------------------------------------------------===//
1856: template <class DST>
1857: bool HugeintToDecimalCast(hugeint_t input, DST &result, string *error_message, uint8_t width, uint8_t scale) {
1858: 	// check for overflow
1859: 	hugeint_t max_width = Hugeint::POWERS_OF_TEN[width - scale];
1860: 	if (input >= max_width || input <= -max_width) {
1861: 		string error = StringUtil::Format("Could not cast value %s to DECIMAL(%d,%d)", input.ToString(), width, scale);
1862: 		HandleCastError::AssignError(error, error_message);
1863: 		return false;
1864: 	}
1865: 	result = Hugeint::Cast<DST>(input * Hugeint::POWERS_OF_TEN[scale]);
1866: 	return true;
1867: }
1868: 
1869: template <>
1870: bool TryCastToDecimal::Operation(hugeint_t input, int16_t &result, string *error_message, uint8_t width,
1871:                                  uint8_t scale) {
1872: 	return HugeintToDecimalCast<int16_t>(input, result, error_message, width, scale);
1873: }
1874: 
1875: template <>
1876: bool TryCastToDecimal::Operation(hugeint_t input, int32_t &result, string *error_message, uint8_t width,
1877:                                  uint8_t scale) {
1878: 	return HugeintToDecimalCast<int32_t>(input, result, error_message, width, scale);
1879: }
1880: 
1881: template <>
1882: bool TryCastToDecimal::Operation(hugeint_t input, int64_t &result, string *error_message, uint8_t width,
1883:                                  uint8_t scale) {
1884: 	return HugeintToDecimalCast<int64_t>(input, result, error_message, width, scale);
1885: }
1886: 
1887: template <>
1888: bool TryCastToDecimal::Operation(hugeint_t input, hugeint_t &result, string *error_message, uint8_t width,
1889:                                  uint8_t scale) {
1890: 	return HugeintToDecimalCast<hugeint_t>(input, result, error_message, width, scale);
1891: }
1892: 
1893: //===--------------------------------------------------------------------===//
1894: // Float/Double -> Decimal Cast
1895: //===--------------------------------------------------------------------===//
1896: template <class SRC, class DST>
1897: bool DoubleToDecimalCast(SRC input, DST &result, string *error_message, uint8_t width, uint8_t scale) {
1898: 	double value = input * NumericHelper::DOUBLE_POWERS_OF_TEN[scale];
1899: 	// Add the sign (-1, 0, 1) times a tiny value to fix floating point issues (issue 3091)
1900: 	double sign = (double(0) < value) - (value < double(0));
1901: 	value += 1e-9 * sign;
1902: 	if (value <= -NumericHelper::DOUBLE_POWERS_OF_TEN[width] || value >= NumericHelper::DOUBLE_POWERS_OF_TEN[width]) {
1903: 		string error = StringUtil::Format("Could not cast value %f to DECIMAL(%d,%d)", value, width, scale);
1904: 		HandleCastError::AssignError(error, error_message);
1905: 		return false;
1906: 	}
1907: 	result = Cast::Operation<SRC, DST>(value);
1908: 	return true;
1909: }
1910: 
1911: template <>
1912: bool TryCastToDecimal::Operation(float input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1913: 	return DoubleToDecimalCast<float, int16_t>(input, result, error_message, width, scale);
1914: }
1915: 
1916: template <>
1917: bool TryCastToDecimal::Operation(float input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1918: 	return DoubleToDecimalCast<float, int32_t>(input, result, error_message, width, scale);
1919: }
1920: 
1921: template <>
1922: bool TryCastToDecimal::Operation(float input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1923: 	return DoubleToDecimalCast<float, int64_t>(input, result, error_message, width, scale);
1924: }
1925: 
1926: template <>
1927: bool TryCastToDecimal::Operation(float input, hugeint_t &result, string *error_message, uint8_t width, uint8_t scale) {
1928: 	return DoubleToDecimalCast<float, hugeint_t>(input, result, error_message, width, scale);
1929: }
1930: 
1931: template <>
1932: bool TryCastToDecimal::Operation(double input, int16_t &result, string *error_message, uint8_t width, uint8_t scale) {
1933: 	return DoubleToDecimalCast<double, int16_t>(input, result, error_message, width, scale);
1934: }
1935: 
1936: template <>
1937: bool TryCastToDecimal::Operation(double input, int32_t &result, string *error_message, uint8_t width, uint8_t scale) {
1938: 	return DoubleToDecimalCast<double, int32_t>(input, result, error_message, width, scale);
1939: }
1940: 
1941: template <>
1942: bool TryCastToDecimal::Operation(double input, int64_t &result, string *error_message, uint8_t width, uint8_t scale) {
1943: 	return DoubleToDecimalCast<double, int64_t>(input, result, error_message, width, scale);
1944: }
1945: 
1946: template <>
1947: bool TryCastToDecimal::Operation(double input, hugeint_t &result, string *error_message, uint8_t width, uint8_t scale) {
1948: 	return DoubleToDecimalCast<double, hugeint_t>(input, result, error_message, width, scale);
1949: }
1950: 
1951: //===--------------------------------------------------------------------===//
1952: // Decimal -> Numeric Cast
1953: //===--------------------------------------------------------------------===//
1954: template <class SRC, class DST>
1955: bool TryCastDecimalToNumeric(SRC input, DST &result, string *error_message, uint8_t scale) {
1956: 	auto scaled_value = input / NumericHelper::POWERS_OF_TEN[scale];
1957: 	if (!TryCast::Operation<SRC, DST>(scaled_value, result)) {
1958: 		string error = StringUtil::Format("Failed to cast decimal value %d to type %s", scaled_value, GetTypeId<DST>());
1959: 		HandleCastError::AssignError(error, error_message);
1960: 		return false;
1961: 	}
1962: 	return true;
1963: }
1964: 
1965: template <class DST>
1966: bool TryCastHugeDecimalToNumeric(hugeint_t input, DST &result, string *error_message, uint8_t scale) {
1967: 	auto scaled_value = input / Hugeint::POWERS_OF_TEN[scale];
1968: 	if (!TryCast::Operation<hugeint_t, DST>(scaled_value, result)) {
1969: 		string error = StringUtil::Format("Failed to cast decimal value %s to type %s",
1970: 		                                  ConvertToString::Operation(scaled_value), GetTypeId<DST>());
1971: 		HandleCastError::AssignError(error, error_message);
1972: 		return false;
1973: 	}
1974: 	return true;
1975: }
1976: 
1977: //===--------------------------------------------------------------------===//
1978: // Cast Decimal -> int8_t
1979: //===--------------------------------------------------------------------===//
1980: template <>
1981: bool TryCastFromDecimal::Operation(int16_t input, int8_t &result, string *error_message, uint8_t width, uint8_t scale) {
1982: 	return TryCastDecimalToNumeric<int16_t, int8_t>(input, result, error_message, scale);
1983: }
1984: template <>
1985: bool TryCastFromDecimal::Operation(int32_t input, int8_t &result, string *error_message, uint8_t width, uint8_t scale) {
1986: 	return TryCastDecimalToNumeric<int32_t, int8_t>(input, result, error_message, scale);
1987: }
1988: template <>
1989: bool TryCastFromDecimal::Operation(int64_t input, int8_t &result, string *error_message, uint8_t width, uint8_t scale) {
1990: 	return TryCastDecimalToNumeric<int64_t, int8_t>(input, result, error_message, scale);
1991: }
1992: template <>
1993: bool TryCastFromDecimal::Operation(hugeint_t input, int8_t &result, string *error_message, uint8_t width,
1994:                                    uint8_t scale) {
1995: 	return TryCastHugeDecimalToNumeric<int8_t>(input, result, error_message, scale);
1996: }
1997: 
1998: //===--------------------------------------------------------------------===//
1999: // Cast Decimal -> int16_t
2000: //===--------------------------------------------------------------------===//
2001: template <>
2002: bool TryCastFromDecimal::Operation(int16_t input, int16_t &result, string *error_message, uint8_t width,
2003:                                    uint8_t scale) {
2004: 	return TryCastDecimalToNumeric<int16_t, int16_t>(input, result, error_message, scale);
2005: }
2006: template <>
2007: bool TryCastFromDecimal::Operation(int32_t input, int16_t &result, string *error_message, uint8_t width,
2008:                                    uint8_t scale) {
2009: 	return TryCastDecimalToNumeric<int32_t, int16_t>(input, result, error_message, scale);
2010: }
2011: template <>
2012: bool TryCastFromDecimal::Operation(int64_t input, int16_t &result, string *error_message, uint8_t width,
2013:                                    uint8_t scale) {
2014: 	return TryCastDecimalToNumeric<int64_t, int16_t>(input, result, error_message, scale);
2015: }
2016: template <>
2017: bool TryCastFromDecimal::Operation(hugeint_t input, int16_t &result, string *error_message, uint8_t width,
2018:                                    uint8_t scale) {
2019: 	return TryCastHugeDecimalToNumeric<int16_t>(input, result, error_message, scale);
2020: }
2021: 
2022: //===--------------------------------------------------------------------===//
2023: // Cast Decimal -> int32_t
2024: //===--------------------------------------------------------------------===//
2025: template <>
2026: bool TryCastFromDecimal::Operation(int16_t input, int32_t &result, string *error_message, uint8_t width,
2027:                                    uint8_t scale) {
2028: 	return TryCastDecimalToNumeric<int16_t, int32_t>(input, result, error_message, scale);
2029: }
2030: template <>
2031: bool TryCastFromDecimal::Operation(int32_t input, int32_t &result, string *error_message, uint8_t width,
2032:                                    uint8_t scale) {
2033: 	return TryCastDecimalToNumeric<int32_t, int32_t>(input, result, error_message, scale);
2034: }
2035: template <>
2036: bool TryCastFromDecimal::Operation(int64_t input, int32_t &result, string *error_message, uint8_t width,
2037:                                    uint8_t scale) {
2038: 	return TryCastDecimalToNumeric<int64_t, int32_t>(input, result, error_message, scale);
2039: }
2040: template <>
2041: bool TryCastFromDecimal::Operation(hugeint_t input, int32_t &result, string *error_message, uint8_t width,
2042:                                    uint8_t scale) {
2043: 	return TryCastHugeDecimalToNumeric<int32_t>(input, result, error_message, scale);
2044: }
2045: 
2046: //===--------------------------------------------------------------------===//
2047: // Cast Decimal -> int64_t
2048: //===--------------------------------------------------------------------===//
2049: template <>
2050: bool TryCastFromDecimal::Operation(int16_t input, int64_t &result, string *error_message, uint8_t width,
2051:                                    uint8_t scale) {
2052: 	return TryCastDecimalToNumeric<int16_t, int64_t>(input, result, error_message, scale);
2053: }
2054: template <>
2055: bool TryCastFromDecimal::Operation(int32_t input, int64_t &result, string *error_message, uint8_t width,
2056:                                    uint8_t scale) {
2057: 	return TryCastDecimalToNumeric<int32_t, int64_t>(input, result, error_message, scale);
2058: }
2059: template <>
2060: bool TryCastFromDecimal::Operation(int64_t input, int64_t &result, string *error_message, uint8_t width,
2061:                                    uint8_t scale) {
2062: 	return TryCastDecimalToNumeric<int64_t, int64_t>(input, result, error_message, scale);
2063: }
2064: template <>
2065: bool TryCastFromDecimal::Operation(hugeint_t input, int64_t &result, string *error_message, uint8_t width,
2066:                                    uint8_t scale) {
2067: 	return TryCastHugeDecimalToNumeric<int64_t>(input, result, error_message, scale);
2068: }
2069: 
2070: //===--------------------------------------------------------------------===//
2071: // Cast Decimal -> uint8_t
2072: //===--------------------------------------------------------------------===//
2073: template <>
2074: bool TryCastFromDecimal::Operation(int16_t input, uint8_t &result, string *error_message, uint8_t width,
2075:                                    uint8_t scale) {
2076: 	return TryCastDecimalToNumeric<int16_t, uint8_t>(input, result, error_message, scale);
2077: }
2078: template <>
2079: bool TryCastFromDecimal::Operation(int32_t input, uint8_t &result, string *error_message, uint8_t width,
2080:                                    uint8_t scale) {
2081: 	return TryCastDecimalToNumeric<int32_t, uint8_t>(input, result, error_message, scale);
2082: }
2083: template <>
2084: bool TryCastFromDecimal::Operation(int64_t input, uint8_t &result, string *error_message, uint8_t width,
2085:                                    uint8_t scale) {
2086: 	return TryCastDecimalToNumeric<int64_t, uint8_t>(input, result, error_message, scale);
2087: }
2088: template <>
2089: bool TryCastFromDecimal::Operation(hugeint_t input, uint8_t &result, string *error_message, uint8_t width,
2090:                                    uint8_t scale) {
2091: 	return TryCastHugeDecimalToNumeric<uint8_t>(input, result, error_message, scale);
2092: }
2093: 
2094: //===--------------------------------------------------------------------===//
2095: // Cast Decimal -> uint16_t
2096: //===--------------------------------------------------------------------===//
2097: template <>
2098: bool TryCastFromDecimal::Operation(int16_t input, uint16_t &result, string *error_message, uint8_t width,
2099:                                    uint8_t scale) {
2100: 	return TryCastDecimalToNumeric<int16_t, uint16_t>(input, result, error_message, scale);
2101: }
2102: template <>
2103: bool TryCastFromDecimal::Operation(int32_t input, uint16_t &result, string *error_message, uint8_t width,
2104:                                    uint8_t scale) {
2105: 	return TryCastDecimalToNumeric<int32_t, uint16_t>(input, result, error_message, scale);
2106: }
2107: template <>
2108: bool TryCastFromDecimal::Operation(int64_t input, uint16_t &result, string *error_message, uint8_t width,
2109:                                    uint8_t scale) {
2110: 	return TryCastDecimalToNumeric<int64_t, uint16_t>(input, result, error_message, scale);
2111: }
2112: template <>
2113: bool TryCastFromDecimal::Operation(hugeint_t input, uint16_t &result, string *error_message, uint8_t width,
2114:                                    uint8_t scale) {
2115: 	return TryCastHugeDecimalToNumeric<uint16_t>(input, result, error_message, scale);
2116: }
2117: 
2118: //===--------------------------------------------------------------------===//
2119: // Cast Decimal -> uint32_t
2120: //===--------------------------------------------------------------------===//
2121: template <>
2122: bool TryCastFromDecimal::Operation(int16_t input, uint32_t &result, string *error_message, uint8_t width,
2123:                                    uint8_t scale) {
2124: 	return TryCastDecimalToNumeric<int16_t, uint32_t>(input, result, error_message, scale);
2125: }
2126: template <>
2127: bool TryCastFromDecimal::Operation(int32_t input, uint32_t &result, string *error_message, uint8_t width,
2128:                                    uint8_t scale) {
2129: 	return TryCastDecimalToNumeric<int32_t, uint32_t>(input, result, error_message, scale);
2130: }
2131: template <>
2132: bool TryCastFromDecimal::Operation(int64_t input, uint32_t &result, string *error_message, uint8_t width,
2133:                                    uint8_t scale) {
2134: 	return TryCastDecimalToNumeric<int64_t, uint32_t>(input, result, error_message, scale);
2135: }
2136: template <>
2137: bool TryCastFromDecimal::Operation(hugeint_t input, uint32_t &result, string *error_message, uint8_t width,
2138:                                    uint8_t scale) {
2139: 	return TryCastHugeDecimalToNumeric<uint32_t>(input, result, error_message, scale);
2140: }
2141: 
2142: //===--------------------------------------------------------------------===//
2143: // Cast Decimal -> uint64_t
2144: //===--------------------------------------------------------------------===//
2145: template <>
2146: bool TryCastFromDecimal::Operation(int16_t input, uint64_t &result, string *error_message, uint8_t width,
2147:                                    uint8_t scale) {
2148: 	return TryCastDecimalToNumeric<int16_t, uint64_t>(input, result, error_message, scale);
2149: }
2150: template <>
2151: bool TryCastFromDecimal::Operation(int32_t input, uint64_t &result, string *error_message, uint8_t width,
2152:                                    uint8_t scale) {
2153: 	return TryCastDecimalToNumeric<int32_t, uint64_t>(input, result, error_message, scale);
2154: }
2155: template <>
2156: bool TryCastFromDecimal::Operation(int64_t input, uint64_t &result, string *error_message, uint8_t width,
2157:                                    uint8_t scale) {
2158: 	return TryCastDecimalToNumeric<int64_t, uint64_t>(input, result, error_message, scale);
2159: }
2160: template <>
2161: bool TryCastFromDecimal::Operation(hugeint_t input, uint64_t &result, string *error_message, uint8_t width,
2162:                                    uint8_t scale) {
2163: 	return TryCastHugeDecimalToNumeric<uint64_t>(input, result, error_message, scale);
2164: }
2165: 
2166: //===--------------------------------------------------------------------===//
2167: // Cast Decimal -> hugeint_t
2168: //===--------------------------------------------------------------------===//
2169: template <>
2170: bool TryCastFromDecimal::Operation(int16_t input, hugeint_t &result, string *error_message, uint8_t width,
2171:                                    uint8_t scale) {
2172: 	return TryCastDecimalToNumeric<int16_t, hugeint_t>(input, result, error_message, scale);
2173: }
2174: template <>
2175: bool TryCastFromDecimal::Operation(int32_t input, hugeint_t &result, string *error_message, uint8_t width,
2176:                                    uint8_t scale) {
2177: 	return TryCastDecimalToNumeric<int32_t, hugeint_t>(input, result, error_message, scale);
2178: }
2179: template <>
2180: bool TryCastFromDecimal::Operation(int64_t input, hugeint_t &result, string *error_message, uint8_t width,
2181:                                    uint8_t scale) {
2182: 	return TryCastDecimalToNumeric<int64_t, hugeint_t>(input, result, error_message, scale);
2183: }
2184: template <>
2185: bool TryCastFromDecimal::Operation(hugeint_t input, hugeint_t &result, string *error_message, uint8_t width,
2186:                                    uint8_t scale) {
2187: 	return TryCastHugeDecimalToNumeric<hugeint_t>(input, result, error_message, scale);
2188: }
2189: 
2190: //===--------------------------------------------------------------------===//
2191: // Decimal -> Float/Double Cast
2192: //===--------------------------------------------------------------------===//
2193: template <class SRC, class DST>
2194: bool TryCastDecimalToFloatingPoint(SRC input, DST &result, uint8_t scale) {
2195: 	result = Cast::Operation<SRC, DST>(input) / DST(NumericHelper::DOUBLE_POWERS_OF_TEN[scale]);
2196: 	return true;
2197: }
2198: 
2199: // DECIMAL -> FLOAT
2200: template <>
2201: bool TryCastFromDecimal::Operation(int16_t input, float &result, string *error_message, uint8_t width, uint8_t scale) {
2202: 	return TryCastDecimalToFloatingPoint<int16_t, float>(input, result, scale);
2203: }
2204: 
2205: template <>
2206: bool TryCastFromDecimal::Operation(int32_t input, float &result, string *error_message, uint8_t width, uint8_t scale) {
2207: 	return TryCastDecimalToFloatingPoint<int32_t, float>(input, result, scale);
2208: }
2209: 
2210: template <>
2211: bool TryCastFromDecimal::Operation(int64_t input, float &result, string *error_message, uint8_t width, uint8_t scale) {
2212: 	return TryCastDecimalToFloatingPoint<int64_t, float>(input, result, scale);
2213: }
2214: 
2215: template <>
2216: bool TryCastFromDecimal::Operation(hugeint_t input, float &result, string *error_message, uint8_t width,
2217:                                    uint8_t scale) {
2218: 	return TryCastDecimalToFloatingPoint<hugeint_t, float>(input, result, scale);
2219: }
2220: 
2221: // DECIMAL -> DOUBLE
2222: template <>
2223: bool TryCastFromDecimal::Operation(int16_t input, double &result, string *error_message, uint8_t width, uint8_t scale) {
2224: 	return TryCastDecimalToFloatingPoint<int16_t, double>(input, result, scale);
2225: }
2226: 
2227: template <>
2228: bool TryCastFromDecimal::Operation(int32_t input, double &result, string *error_message, uint8_t width, uint8_t scale) {
2229: 	return TryCastDecimalToFloatingPoint<int32_t, double>(input, result, scale);
2230: }
2231: 
2232: template <>
2233: bool TryCastFromDecimal::Operation(int64_t input, double &result, string *error_message, uint8_t width, uint8_t scale) {
2234: 	return TryCastDecimalToFloatingPoint<int64_t, double>(input, result, scale);
2235: }
2236: 
2237: template <>
2238: bool TryCastFromDecimal::Operation(hugeint_t input, double &result, string *error_message, uint8_t width,
2239:                                    uint8_t scale) {
2240: 	return TryCastDecimalToFloatingPoint<hugeint_t, double>(input, result, scale);
2241: }
2242: 
2243: } // namespace duckdb
[end of src/common/operator/cast_operators.cpp]
[start of src/common/radix.cpp]
1: #include "duckdb/common/radix.hpp"
2: 
3: #include <cfloat>
4: #include <cstring> // strlen() on Solaris
5: #include <limits.h>
6: 
7: namespace duckdb {
8: 
9: bool IsLittleEndian() {
10: 	int n = 1;
11: 	if (*(char *)&n == 1) {
12: 		return true;
13: 	} else {
14: 		return false;
15: 	}
16: }
17: 
18: uint8_t FlipSign(uint8_t key_byte) {
19: 	return key_byte ^ 128;
20: }
21: 
22: uint32_t EncodeFloat(float x) {
23: 	uint64_t buff;
24: 
25: 	//! zero
26: 	if (x == 0) {
27: 		buff = 0;
28: 		buff |= (1u << 31);
29: 		return buff;
30: 	}
31: 	//! infinity
32: 	if (x > FLT_MAX) {
33: 		throw InternalException("+INFINITY detected in floating point number");
34: 		// return UINT_MAX;
35: 	}
36: 	//! -infinity
37: 	if (x < -FLT_MAX) {
38: 		throw InternalException("-INFINITY detected in floating point number");
39: 		// return 0;
40: 	}
41: 	buff = Load<uint32_t>((const_data_ptr_t)&x);
42: 	if ((buff & (1u << 31)) == 0) { //! +0 and positive numbers
43: 		buff |= (1u << 31);
44: 	} else {          //! negative numbers
45: 		buff = ~buff; //! complement 1
46: 	}
47: 
48: 	return buff;
49: }
50: 
51: uint64_t EncodeDouble(double x) {
52: 	uint64_t buff;
53: 	//! zero
54: 	if (x == 0) {
55: 		buff = 0;
56: 		buff += (1ull << 63);
57: 		return buff;
58: 	}
59: 	//! infinity
60: 	if (x > DBL_MAX) {
61: 		throw InternalException("+INFINITY detected in floating point number");
62: 		// return ULLONG_MAX;
63: 	}
64: 	//! -infinity
65: 	if (x < -DBL_MAX) {
66: 		throw InternalException("-INFINITY detected in floating point number");
67: 		// return 0;
68: 	}
69: 	buff = Load<uint64_t>((const_data_ptr_t)&x);
70: 	if (buff < (1ull << 63)) { //! +0 and positive numbers
71: 		buff += (1ull << 63);
72: 	} else {          //! negative numbers
73: 		buff = ~buff; //! complement 1
74: 	}
75: 	return buff;
76: }
77: 
78: template <>
79: void EncodeData(data_ptr_t dataptr, bool value, bool is_little_endian) {
80: 	Store<uint8_t>(value ? 1 : 0, dataptr);
81: }
82: 
83: template <>
84: void EncodeData(data_ptr_t dataptr, int8_t value, bool is_little_endian) {
85: 	Store<uint8_t>(value, dataptr);
86: 	dataptr[0] = FlipSign(dataptr[0]);
87: }
88: 
89: template <>
90: void EncodeData(data_ptr_t dataptr, int16_t value, bool is_little_endian) {
91: 	Store<uint16_t>(is_little_endian ? BSWAP16(value) : value, dataptr);
92: 	dataptr[0] = FlipSign(dataptr[0]);
93: }
94: 
95: template <>
96: void EncodeData(data_ptr_t dataptr, int32_t value, bool is_little_endian) {
97: 	Store<uint32_t>(is_little_endian ? BSWAP32(value) : value, dataptr);
98: 	dataptr[0] = FlipSign(dataptr[0]);
99: }
100: 
101: template <>
102: void EncodeData(data_ptr_t dataptr, int64_t value, bool is_little_endian) {
103: 	Store<uint64_t>(is_little_endian ? BSWAP64(value) : value, dataptr);
104: 	dataptr[0] = FlipSign(dataptr[0]);
105: }
106: 
107: template <>
108: void EncodeData(data_ptr_t dataptr, uint8_t value, bool is_little_endian) {
109: 	Store<uint8_t>(value, dataptr);
110: }
111: 
112: template <>
113: void EncodeData(data_ptr_t dataptr, uint16_t value, bool is_little_endian) {
114: 	Store<uint16_t>(is_little_endian ? BSWAP16(value) : value, dataptr);
115: }
116: 
117: template <>
118: void EncodeData(data_ptr_t dataptr, uint32_t value, bool is_little_endian) {
119: 	Store<uint32_t>(is_little_endian ? BSWAP32(value) : value, dataptr);
120: }
121: 
122: template <>
123: void EncodeData(data_ptr_t dataptr, uint64_t value, bool is_little_endian) {
124: 	Store<uint64_t>(is_little_endian ? BSWAP64(value) : value, dataptr);
125: }
126: 
127: template <>
128: void EncodeData(data_ptr_t dataptr, hugeint_t value, bool is_little_endian) {
129: 	EncodeData<int64_t>(dataptr, value.upper, is_little_endian);
130: 	EncodeData<uint64_t>(dataptr + sizeof(value.upper), value.lower, is_little_endian);
131: }
132: 
133: template <>
134: void EncodeData(data_ptr_t dataptr, float value, bool is_little_endian) {
135: 	uint32_t converted_value = EncodeFloat(value);
136: 	Store<uint32_t>(is_little_endian ? BSWAP32(converted_value) : converted_value, dataptr);
137: }
138: 
139: template <>
140: void EncodeData(data_ptr_t dataptr, double value, bool is_little_endian) {
141: 	uint64_t converted_value = EncodeDouble(value);
142: 	Store<uint64_t>(is_little_endian ? BSWAP64(converted_value) : converted_value, dataptr);
143: }
144: 
145: template <>
146: void EncodeData(data_ptr_t dataptr, interval_t value, bool is_little_endian) {
147: 	EncodeData<int32_t>(dataptr, value.months, is_little_endian);
148: 	dataptr += sizeof(value.months);
149: 	EncodeData<int32_t>(dataptr, value.days, is_little_endian);
150: 	dataptr += sizeof(value.days);
151: 	EncodeData<int64_t>(dataptr, value.micros, is_little_endian);
152: }
153: 
154: void EncodeStringDataPrefix(data_ptr_t dataptr, string_t value, idx_t prefix_len) {
155: 	auto len = value.GetSize();
156: 	memcpy(dataptr, value.GetDataUnsafe(), MinValue(len, prefix_len));
157: 	if (len < prefix_len) {
158: 		memset(dataptr + len, '\0', prefix_len - len);
159: 	}
160: }
161: 
162: } // namespace duckdb
[end of src/common/radix.cpp]
[start of src/common/types.cpp]
1: #include "duckdb/common/types.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
4: #include "duckdb/common/exception.hpp"
5: #include "duckdb/common/field_writer.hpp"
6: #include "duckdb/common/limits.hpp"
7: #include "duckdb/common/operator/comparison_operators.hpp"
8: #include "duckdb/common/string_util.hpp"
9: #include "duckdb/common/types/decimal.hpp"
10: #include "duckdb/common/types/hash.hpp"
11: #include "duckdb/common/types/string_type.hpp"
12: #include "duckdb/common/types/value.hpp"
13: #include "duckdb/common/types/vector.hpp"
14: #include "duckdb/common/unordered_map.hpp"
15: #include "duckdb/parser/keyword_helper.hpp"
16: #include "duckdb/parser/parser.hpp"
17: 
18: #include <cmath>
19: 
20: namespace duckdb {
21: 
22: LogicalType::LogicalType() : LogicalType(LogicalTypeId::INVALID) {
23: }
24: 
25: LogicalType::LogicalType(LogicalTypeId id) : id_(id) {
26: 	physical_type_ = GetInternalType();
27: }
28: LogicalType::LogicalType(LogicalTypeId id, shared_ptr<ExtraTypeInfo> type_info_p)
29:     : id_(id), type_info_(move(type_info_p)) {
30: 	physical_type_ = GetInternalType();
31: }
32: 
33: LogicalType::LogicalType(const LogicalType &other)
34:     : id_(other.id_), physical_type_(other.physical_type_), type_info_(other.type_info_) {
35: }
36: 
37: LogicalType::LogicalType(LogicalType &&other) noexcept
38:     : id_(other.id_), physical_type_(other.physical_type_), type_info_(move(other.type_info_)) {
39: }
40: 
41: hash_t LogicalType::Hash() const {
42: 	return duckdb::Hash<uint8_t>((uint8_t)id_);
43: }
44: 
45: PhysicalType LogicalType::GetInternalType() {
46: 	switch (id_) {
47: 	case LogicalTypeId::BOOLEAN:
48: 		return PhysicalType::BOOL;
49: 	case LogicalTypeId::TINYINT:
50: 		return PhysicalType::INT8;
51: 	case LogicalTypeId::UTINYINT:
52: 		return PhysicalType::UINT8;
53: 	case LogicalTypeId::SMALLINT:
54: 		return PhysicalType::INT16;
55: 	case LogicalTypeId::USMALLINT:
56: 		return PhysicalType::UINT16;
57: 	case LogicalTypeId::SQLNULL:
58: 	case LogicalTypeId::DATE:
59: 	case LogicalTypeId::INTEGER:
60: 		return PhysicalType::INT32;
61: 	case LogicalTypeId::UINTEGER:
62: 		return PhysicalType::UINT32;
63: 	case LogicalTypeId::BIGINT:
64: 	case LogicalTypeId::TIME:
65: 	case LogicalTypeId::TIMESTAMP:
66: 	case LogicalTypeId::TIMESTAMP_SEC:
67: 	case LogicalTypeId::TIMESTAMP_NS:
68: 	case LogicalTypeId::TIMESTAMP_MS:
69: 	case LogicalTypeId::TIME_TZ:
70: 	case LogicalTypeId::TIMESTAMP_TZ:
71: 		return PhysicalType::INT64;
72: 	case LogicalTypeId::UBIGINT:
73: 		return PhysicalType::UINT64;
74: 	case LogicalTypeId::HUGEINT:
75: 	case LogicalTypeId::UUID:
76: 		return PhysicalType::INT128;
77: 	case LogicalTypeId::FLOAT:
78: 		return PhysicalType::FLOAT;
79: 	case LogicalTypeId::DOUBLE:
80: 		return PhysicalType::DOUBLE;
81: 	case LogicalTypeId::DECIMAL: {
82: 		if (!type_info_) {
83: 			return PhysicalType::INVALID;
84: 		}
85: 		auto width = DecimalType::GetWidth(*this);
86: 		if (width <= Decimal::MAX_WIDTH_INT16) {
87: 			return PhysicalType::INT16;
88: 		} else if (width <= Decimal::MAX_WIDTH_INT32) {
89: 			return PhysicalType::INT32;
90: 		} else if (width <= Decimal::MAX_WIDTH_INT64) {
91: 			return PhysicalType::INT64;
92: 		} else if (width <= Decimal::MAX_WIDTH_INT128) {
93: 			return PhysicalType::INT128;
94: 		} else {
95: 			throw InternalException("Widths bigger than 38 are not supported");
96: 		}
97: 	}
98: 	case LogicalTypeId::VARCHAR:
99: 	case LogicalTypeId::CHAR:
100: 	case LogicalTypeId::BLOB:
101: 	case LogicalTypeId::JSON:
102: 		return PhysicalType::VARCHAR;
103: 	case LogicalTypeId::INTERVAL:
104: 		return PhysicalType::INTERVAL;
105: 	case LogicalTypeId::MAP:
106: 	case LogicalTypeId::STRUCT:
107: 		return PhysicalType::STRUCT;
108: 	case LogicalTypeId::LIST:
109: 		return PhysicalType::LIST;
110: 	case LogicalTypeId::HASH:
111: 		static_assert(sizeof(hash_t) == sizeof(uint64_t), "Hash must be uint64_t");
112: 		return PhysicalType::UINT64;
113: 	case LogicalTypeId::POINTER:
114: 		// LCOV_EXCL_START
115: 		if (sizeof(uintptr_t) == sizeof(uint32_t)) {
116: 			return PhysicalType::UINT32;
117: 		} else if (sizeof(uintptr_t) == sizeof(uint64_t)) {
118: 			return PhysicalType::UINT64;
119: 		} else {
120: 			throw InternalException("Unsupported pointer size");
121: 		}
122: 		// LCOV_EXCL_STOP
123: 	case LogicalTypeId::VALIDITY:
124: 		return PhysicalType::BIT;
125: 	case LogicalTypeId::ENUM: {
126: 		D_ASSERT(type_info_);
127: 		auto size = EnumType::GetSize(*this);
128: 		return EnumType::GetPhysicalType(size);
129: 	}
130: 	case LogicalTypeId::TABLE:
131: 	case LogicalTypeId::ANY:
132: 	case LogicalTypeId::INVALID:
133: 	case LogicalTypeId::UNKNOWN:
134: 		return PhysicalType::INVALID;
135: 	case LogicalTypeId::USER:
136: 		return PhysicalType::UNKNOWN;
137: 	case LogicalTypeId::AGGREGATE_STATE:
138: 		return PhysicalType::VARCHAR;
139: 	default:
140: 		throw InternalException("Invalid LogicalType %s", ToString());
141: 	}
142: }
143: 
144: constexpr const LogicalTypeId LogicalType::INVALID;
145: constexpr const LogicalTypeId LogicalType::SQLNULL;
146: constexpr const LogicalTypeId LogicalType::BOOLEAN;
147: constexpr const LogicalTypeId LogicalType::TINYINT;
148: constexpr const LogicalTypeId LogicalType::UTINYINT;
149: constexpr const LogicalTypeId LogicalType::SMALLINT;
150: constexpr const LogicalTypeId LogicalType::USMALLINT;
151: constexpr const LogicalTypeId LogicalType::INTEGER;
152: constexpr const LogicalTypeId LogicalType::UINTEGER;
153: constexpr const LogicalTypeId LogicalType::BIGINT;
154: constexpr const LogicalTypeId LogicalType::UBIGINT;
155: constexpr const LogicalTypeId LogicalType::HUGEINT;
156: constexpr const LogicalTypeId LogicalType::UUID;
157: constexpr const LogicalTypeId LogicalType::FLOAT;
158: constexpr const LogicalTypeId LogicalType::DOUBLE;
159: constexpr const LogicalTypeId LogicalType::DATE;
160: 
161: constexpr const LogicalTypeId LogicalType::TIMESTAMP;
162: constexpr const LogicalTypeId LogicalType::TIMESTAMP_MS;
163: constexpr const LogicalTypeId LogicalType::TIMESTAMP_NS;
164: constexpr const LogicalTypeId LogicalType::TIMESTAMP_S;
165: 
166: constexpr const LogicalTypeId LogicalType::TIME;
167: 
168: constexpr const LogicalTypeId LogicalType::TIME_TZ;
169: constexpr const LogicalTypeId LogicalType::TIMESTAMP_TZ;
170: 
171: constexpr const LogicalTypeId LogicalType::HASH;
172: constexpr const LogicalTypeId LogicalType::POINTER;
173: 
174: constexpr const LogicalTypeId LogicalType::VARCHAR;
175: constexpr const LogicalTypeId LogicalType::JSON;
176: 
177: constexpr const LogicalTypeId LogicalType::BLOB;
178: constexpr const LogicalTypeId LogicalType::INTERVAL;
179: constexpr const LogicalTypeId LogicalType::ROW_TYPE;
180: 
181: // TODO these are incomplete and should maybe not exist as such
182: constexpr const LogicalTypeId LogicalType::TABLE;
183: 
184: constexpr const LogicalTypeId LogicalType::ANY;
185: 
186: const vector<LogicalType> LogicalType::Numeric() {
187: 	vector<LogicalType> types = {LogicalType::TINYINT,   LogicalType::SMALLINT,  LogicalType::INTEGER,
188: 	                             LogicalType::BIGINT,    LogicalType::HUGEINT,   LogicalType::FLOAT,
189: 	                             LogicalType::DOUBLE,    LogicalTypeId::DECIMAL, LogicalType::UTINYINT,
190: 	                             LogicalType::USMALLINT, LogicalType::UINTEGER,  LogicalType::UBIGINT};
191: 	return types;
192: }
193: 
194: const vector<LogicalType> LogicalType::Integral() {
195: 	vector<LogicalType> types = {LogicalType::TINYINT,   LogicalType::SMALLINT, LogicalType::INTEGER,
196: 	                             LogicalType::BIGINT,    LogicalType::HUGEINT,  LogicalType::UTINYINT,
197: 	                             LogicalType::USMALLINT, LogicalType::UINTEGER, LogicalType::UBIGINT};
198: 	return types;
199: }
200: 
201: const vector<LogicalType> LogicalType::AllTypes() {
202: 	vector<LogicalType> types = {
203: 	    LogicalType::BOOLEAN,  LogicalType::TINYINT,   LogicalType::SMALLINT,     LogicalType::INTEGER,
204: 	    LogicalType::BIGINT,   LogicalType::DATE,      LogicalType::TIMESTAMP,    LogicalType::DOUBLE,
205: 	    LogicalType::FLOAT,    LogicalType::VARCHAR,   LogicalType::BLOB,         LogicalType::INTERVAL,
206: 	    LogicalType::HUGEINT,  LogicalTypeId::DECIMAL, LogicalType::UTINYINT,     LogicalType::USMALLINT,
207: 	    LogicalType::UINTEGER, LogicalType::UBIGINT,   LogicalType::TIME,         LogicalTypeId::LIST,
208: 	    LogicalTypeId::STRUCT, LogicalType::TIME_TZ,   LogicalType::TIMESTAMP_TZ, LogicalTypeId::MAP,
209: 	    LogicalType::UUID,     LogicalType::JSON};
210: 	return types;
211: }
212: 
213: const PhysicalType ROW_TYPE = PhysicalType::INT64;
214: 
215: // LCOV_EXCL_START
216: string TypeIdToString(PhysicalType type) {
217: 	switch (type) {
218: 	case PhysicalType::BOOL:
219: 		return "BOOL";
220: 	case PhysicalType::INT8:
221: 		return "INT8";
222: 	case PhysicalType::INT16:
223: 		return "INT16";
224: 	case PhysicalType::INT32:
225: 		return "INT32";
226: 	case PhysicalType::INT64:
227: 		return "INT64";
228: 	case PhysicalType::UINT8:
229: 		return "UINT8";
230: 	case PhysicalType::UINT16:
231: 		return "UINT16";
232: 	case PhysicalType::UINT32:
233: 		return "UINT32";
234: 	case PhysicalType::UINT64:
235: 		return "UINT64";
236: 	case PhysicalType::INT128:
237: 		return "INT128";
238: 	case PhysicalType::FLOAT:
239: 		return "FLOAT";
240: 	case PhysicalType::DOUBLE:
241: 		return "DOUBLE";
242: 	case PhysicalType::VARCHAR:
243: 		return "VARCHAR";
244: 	case PhysicalType::INTERVAL:
245: 		return "INTERVAL";
246: 	case PhysicalType::STRUCT:
247: 		return "STRUCT<?>";
248: 	case PhysicalType::LIST:
249: 		return "LIST<?>";
250: 	case PhysicalType::INVALID:
251: 		return "INVALID";
252: 	case PhysicalType::BIT:
253: 		return "BIT";
254: 	case PhysicalType::NA:
255: 		return "NA";
256: 	case PhysicalType::HALF_FLOAT:
257: 		return "HALF_FLOAT";
258: 	case PhysicalType::STRING:
259: 		return "ARROW_STRING";
260: 	case PhysicalType::BINARY:
261: 		return "BINARY";
262: 	case PhysicalType::FIXED_SIZE_BINARY:
263: 		return "FIXED_SIZE_BINARY";
264: 	case PhysicalType::DATE32:
265: 		return "DATE32";
266: 	case PhysicalType::DATE64:
267: 		return "DATE64";
268: 	case PhysicalType::TIMESTAMP:
269: 		return "TIMESTAMP";
270: 	case PhysicalType::TIME32:
271: 		return "TIME32";
272: 	case PhysicalType::TIME64:
273: 		return "TIME64";
274: 	case PhysicalType::UNION:
275: 		return "UNION";
276: 	case PhysicalType::DICTIONARY:
277: 		return "DICTIONARY";
278: 	case PhysicalType::MAP:
279: 		return "MAP";
280: 	case PhysicalType::EXTENSION:
281: 		return "EXTENSION";
282: 	case PhysicalType::FIXED_SIZE_LIST:
283: 		return "FIXED_SIZE_LIST";
284: 	case PhysicalType::DURATION:
285: 		return "DURATION";
286: 	case PhysicalType::LARGE_STRING:
287: 		return "LARGE_STRING";
288: 	case PhysicalType::LARGE_BINARY:
289: 		return "LARGE_BINARY";
290: 	case PhysicalType::LARGE_LIST:
291: 		return "LARGE_LIST";
292: 	case PhysicalType::UNKNOWN:
293: 		return "UNKNOWN";
294: 	}
295: 	return "INVALID";
296: }
297: // LCOV_EXCL_STOP
298: 
299: idx_t GetTypeIdSize(PhysicalType type) {
300: 	switch (type) {
301: 	case PhysicalType::BIT:
302: 	case PhysicalType::BOOL:
303: 		return sizeof(bool);
304: 	case PhysicalType::INT8:
305: 		return sizeof(int8_t);
306: 	case PhysicalType::INT16:
307: 		return sizeof(int16_t);
308: 	case PhysicalType::INT32:
309: 		return sizeof(int32_t);
310: 	case PhysicalType::INT64:
311: 		return sizeof(int64_t);
312: 	case PhysicalType::UINT8:
313: 		return sizeof(uint8_t);
314: 	case PhysicalType::UINT16:
315: 		return sizeof(uint16_t);
316: 	case PhysicalType::UINT32:
317: 		return sizeof(uint32_t);
318: 	case PhysicalType::UINT64:
319: 		return sizeof(uint64_t);
320: 	case PhysicalType::INT128:
321: 		return sizeof(hugeint_t);
322: 	case PhysicalType::FLOAT:
323: 		return sizeof(float);
324: 	case PhysicalType::DOUBLE:
325: 		return sizeof(double);
326: 	case PhysicalType::VARCHAR:
327: 		return sizeof(string_t);
328: 	case PhysicalType::INTERVAL:
329: 		return sizeof(interval_t);
330: 	case PhysicalType::STRUCT:
331: 	case PhysicalType::UNKNOWN:
332: 		return 0; // no own payload
333: 	case PhysicalType::LIST:
334: 		return sizeof(list_entry_t); // offset + len
335: 	default:
336: 		throw InternalException("Invalid PhysicalType for GetTypeIdSize");
337: 	}
338: }
339: 
340: bool TypeIsConstantSize(PhysicalType type) {
341: 	return (type >= PhysicalType::BOOL && type <= PhysicalType::DOUBLE) ||
342: 	       (type >= PhysicalType::FIXED_SIZE_BINARY && type <= PhysicalType::INTERVAL) ||
343: 	       type == PhysicalType::INTERVAL || type == PhysicalType::INT128;
344: }
345: bool TypeIsIntegral(PhysicalType type) {
346: 	return (type >= PhysicalType::UINT8 && type <= PhysicalType::INT64) || type == PhysicalType::INT128;
347: }
348: bool TypeIsNumeric(PhysicalType type) {
349: 	return (type >= PhysicalType::UINT8 && type <= PhysicalType::DOUBLE) || type == PhysicalType::INT128;
350: }
351: bool TypeIsInteger(PhysicalType type) {
352: 	return (type >= PhysicalType::UINT8 && type <= PhysicalType::INT64) || type == PhysicalType::INT128;
353: }
354: 
355: // LCOV_EXCL_START
356: string LogicalTypeIdToString(LogicalTypeId id) {
357: 	switch (id) {
358: 	case LogicalTypeId::BOOLEAN:
359: 		return "BOOLEAN";
360: 	case LogicalTypeId::TINYINT:
361: 		return "TINYINT";
362: 	case LogicalTypeId::SMALLINT:
363: 		return "SMALLINT";
364: 	case LogicalTypeId::INTEGER:
365: 		return "INTEGER";
366: 	case LogicalTypeId::BIGINT:
367: 		return "BIGINT";
368: 	case LogicalTypeId::HUGEINT:
369: 		return "HUGEINT";
370: 	case LogicalTypeId::UUID:
371: 		return "UUID";
372: 	case LogicalTypeId::UTINYINT:
373: 		return "UTINYINT";
374: 	case LogicalTypeId::USMALLINT:
375: 		return "USMALLINT";
376: 	case LogicalTypeId::UINTEGER:
377: 		return "UINTEGER";
378: 	case LogicalTypeId::UBIGINT:
379: 		return "UBIGINT";
380: 	case LogicalTypeId::DATE:
381: 		return "DATE";
382: 	case LogicalTypeId::TIME:
383: 		return "TIME";
384: 	case LogicalTypeId::TIMESTAMP:
385: 		return "TIMESTAMP";
386: 	case LogicalTypeId::TIMESTAMP_MS:
387: 		return "TIMESTAMP_MS";
388: 	case LogicalTypeId::TIMESTAMP_NS:
389: 		return "TIMESTAMP_NS";
390: 	case LogicalTypeId::TIMESTAMP_SEC:
391: 		return "TIMESTAMP_S";
392: 	case LogicalTypeId::TIMESTAMP_TZ:
393: 		return "TIMESTAMP WITH TIME ZONE";
394: 	case LogicalTypeId::TIME_TZ:
395: 		return "TIME WITH TIME ZONE";
396: 	case LogicalTypeId::FLOAT:
397: 		return "FLOAT";
398: 	case LogicalTypeId::DOUBLE:
399: 		return "DOUBLE";
400: 	case LogicalTypeId::DECIMAL:
401: 		return "DECIMAL";
402: 	case LogicalTypeId::VARCHAR:
403: 		return "VARCHAR";
404: 	case LogicalTypeId::BLOB:
405: 		return "BLOB";
406: 	case LogicalTypeId::CHAR:
407: 		return "CHAR";
408: 	case LogicalTypeId::INTERVAL:
409: 		return "INTERVAL";
410: 	case LogicalTypeId::SQLNULL:
411: 		return "NULL";
412: 	case LogicalTypeId::ANY:
413: 		return "ANY";
414: 	case LogicalTypeId::VALIDITY:
415: 		return "VALIDITY";
416: 	case LogicalTypeId::STRUCT:
417: 		return "STRUCT<?>";
418: 	case LogicalTypeId::LIST:
419: 		return "LIST<?>";
420: 	case LogicalTypeId::MAP:
421: 		return "MAP<?>";
422: 	case LogicalTypeId::HASH:
423: 		return "HASH";
424: 	case LogicalTypeId::POINTER:
425: 		return "POINTER";
426: 	case LogicalTypeId::TABLE:
427: 		return "TABLE";
428: 	case LogicalTypeId::INVALID:
429: 		return "INVALID";
430: 	case LogicalTypeId::UNKNOWN:
431: 		return "UNKNOWN";
432: 	case LogicalTypeId::ENUM:
433: 		return "ENUM";
434: 	case LogicalTypeId::AGGREGATE_STATE:
435: 		return "AGGREGATE_STATE<?>";
436: 	case LogicalTypeId::USER:
437: 		return "USER";
438: 	case LogicalTypeId::JSON:
439: 		return "JSON";
440: 	}
441: 	return "UNDEFINED";
442: }
443: 
444: string LogicalType::ToString() const {
445: 	switch (id_) {
446: 	case LogicalTypeId::STRUCT: {
447: 		if (!type_info_) {
448: 			return "STRUCT";
449: 		}
450: 		auto &child_types = StructType::GetChildTypes(*this);
451: 		string ret = "STRUCT(";
452: 		for (size_t i = 0; i < child_types.size(); i++) {
453: 			ret += child_types[i].first + " " + child_types[i].second.ToString();
454: 			if (i < child_types.size() - 1) {
455: 				ret += ", ";
456: 			}
457: 		}
458: 		ret += ")";
459: 		return ret;
460: 	}
461: 	case LogicalTypeId::LIST: {
462: 		if (!type_info_) {
463: 			return "LIST";
464: 		}
465: 		return ListType::GetChildType(*this).ToString() + "[]";
466: 	}
467: 	case LogicalTypeId::MAP: {
468: 		if (!type_info_) {
469: 			return "MAP";
470: 		}
471: 		auto &child_types = StructType::GetChildTypes(*this);
472: 		if (child_types.empty()) {
473: 			return "MAP(?)";
474: 		}
475: 		if (child_types.size() != 2) {
476: 			throw InternalException("Map needs exactly two child elements");
477: 		}
478: 		return "MAP(" + ListType::GetChildType(child_types[0].second).ToString() + ", " +
479: 		       ListType::GetChildType(child_types[1].second).ToString() + ")";
480: 	}
481: 	case LogicalTypeId::DECIMAL: {
482: 		if (!type_info_) {
483: 			return "DECIMAL";
484: 		}
485: 		auto width = DecimalType::GetWidth(*this);
486: 		auto scale = DecimalType::GetScale(*this);
487: 		if (width == 0) {
488: 			return "DECIMAL";
489: 		}
490: 		return StringUtil::Format("DECIMAL(%d,%d)", width, scale);
491: 	}
492: 	case LogicalTypeId::ENUM: {
493: 		return KeywordHelper::WriteOptionallyQuoted(EnumType::GetTypeName(*this));
494: 	}
495: 	case LogicalTypeId::USER: {
496: 		return KeywordHelper::WriteOptionallyQuoted(UserType::GetTypeName(*this));
497: 	}
498: 	case LogicalTypeId::AGGREGATE_STATE: {
499: 		return AggregateStateType::GetTypeName(*this);
500: 	}
501: 	default:
502: 		return LogicalTypeIdToString(id_);
503: 	}
504: }
505: // LCOV_EXCL_STOP
506: 
507: LogicalTypeId TransformStringToLogicalTypeId(const string &str) {
508: 	auto lower_str = StringUtil::Lower(str);
509: 	// Transform column type
510: 	if (lower_str == "int" || lower_str == "int4" || lower_str == "signed" || lower_str == "integer" ||
511: 	    lower_str == "integral" || lower_str == "int32") {
512: 		return LogicalTypeId::INTEGER;
513: 	} else if (lower_str == "varchar" || lower_str == "bpchar" || lower_str == "text" || lower_str == "string" ||
514: 	           lower_str == "char" || lower_str == "nvarchar") {
515: 		return LogicalTypeId::VARCHAR;
516: 	} else if (lower_str == "bytea" || lower_str == "blob" || lower_str == "varbinary" || lower_str == "binary") {
517: 		return LogicalTypeId::BLOB;
518: 	} else if (lower_str == "int8" || lower_str == "bigint" || lower_str == "int64" || lower_str == "long" ||
519: 	           lower_str == "oid") {
520: 		return LogicalTypeId::BIGINT;
521: 	} else if (lower_str == "int2" || lower_str == "smallint" || lower_str == "short" || lower_str == "int16") {
522: 		return LogicalTypeId::SMALLINT;
523: 	} else if (lower_str == "timestamp" || lower_str == "datetime" || lower_str == "timestamp_us") {
524: 		return LogicalTypeId::TIMESTAMP;
525: 	} else if (lower_str == "timestamp_ms") {
526: 		return LogicalTypeId::TIMESTAMP_MS;
527: 	} else if (lower_str == "timestamp_ns") {
528: 		return LogicalTypeId::TIMESTAMP_NS;
529: 	} else if (lower_str == "timestamp_s") {
530: 		return LogicalTypeId::TIMESTAMP_SEC;
531: 	} else if (lower_str == "bool" || lower_str == "boolean" || lower_str == "logical") {
532: 		return LogicalTypeId::BOOLEAN;
533: 	} else if (lower_str == "decimal" || lower_str == "dec" || lower_str == "numeric") {
534: 		return LogicalTypeId::DECIMAL;
535: 	} else if (lower_str == "real" || lower_str == "float4" || lower_str == "float") {
536: 		return LogicalTypeId::FLOAT;
537: 	} else if (lower_str == "double" || lower_str == "float8") {
538: 		return LogicalTypeId::DOUBLE;
539: 	} else if (lower_str == "tinyint" || lower_str == "int1") {
540: 		return LogicalTypeId::TINYINT;
541: 	} else if (lower_str == "date") {
542: 		return LogicalTypeId::DATE;
543: 	} else if (lower_str == "time") {
544: 		return LogicalTypeId::TIME;
545: 	} else if (lower_str == "interval") {
546: 		return LogicalTypeId::INTERVAL;
547: 	} else if (lower_str == "hugeint" || lower_str == "int128") {
548: 		return LogicalTypeId::HUGEINT;
549: 	} else if (lower_str == "uuid" || lower_str == "guid") {
550: 		return LogicalTypeId::UUID;
551: 	} else if (lower_str == "struct" || lower_str == "row") {
552: 		return LogicalTypeId::STRUCT;
553: 	} else if (lower_str == "map") {
554: 		return LogicalTypeId::MAP;
555: 	} else if (lower_str == "utinyint" || lower_str == "uint8") {
556: 		return LogicalTypeId::UTINYINT;
557: 	} else if (lower_str == "usmallint" || lower_str == "uint16") {
558: 		return LogicalTypeId::USMALLINT;
559: 	} else if (lower_str == "uinteger" || lower_str == "uint32") {
560: 		return LogicalTypeId::UINTEGER;
561: 	} else if (lower_str == "ubigint" || lower_str == "uint64") {
562: 		return LogicalTypeId::UBIGINT;
563: 	} else if (lower_str == "timestamptz") {
564: 		return LogicalTypeId::TIMESTAMP_TZ;
565: 	} else if (lower_str == "timetz") {
566: 		return LogicalTypeId::TIME_TZ;
567: 	} else if (lower_str == "json") {
568: 		return LogicalTypeId::JSON;
569: 	} else if (lower_str == "null") {
570: 		return LogicalTypeId::SQLNULL;
571: 	} else {
572: 		// This is a User Type, at this point we don't know if its one of the User Defined Types or an error
573: 		// It is checked in the binder
574: 		return LogicalTypeId::USER;
575: 	}
576: }
577: 
578: LogicalType TransformStringToLogicalType(const string &str) {
579: 	if (StringUtil::Lower(str) == "null") {
580: 		return LogicalType::SQLNULL;
581: 	}
582: 	return Parser::ParseColumnList("dummy " + str)[0].type;
583: }
584: 
585: bool LogicalType::IsIntegral() const {
586: 	switch (id_) {
587: 	case LogicalTypeId::TINYINT:
588: 	case LogicalTypeId::SMALLINT:
589: 	case LogicalTypeId::INTEGER:
590: 	case LogicalTypeId::BIGINT:
591: 	case LogicalTypeId::UTINYINT:
592: 	case LogicalTypeId::USMALLINT:
593: 	case LogicalTypeId::UINTEGER:
594: 	case LogicalTypeId::UBIGINT:
595: 	case LogicalTypeId::HUGEINT:
596: 		return true;
597: 	default:
598: 		return false;
599: 	}
600: }
601: 
602: bool LogicalType::IsNumeric() const {
603: 	switch (id_) {
604: 	case LogicalTypeId::TINYINT:
605: 	case LogicalTypeId::SMALLINT:
606: 	case LogicalTypeId::INTEGER:
607: 	case LogicalTypeId::BIGINT:
608: 	case LogicalTypeId::HUGEINT:
609: 	case LogicalTypeId::FLOAT:
610: 	case LogicalTypeId::DOUBLE:
611: 	case LogicalTypeId::DECIMAL:
612: 	case LogicalTypeId::UTINYINT:
613: 	case LogicalTypeId::USMALLINT:
614: 	case LogicalTypeId::UINTEGER:
615: 	case LogicalTypeId::UBIGINT:
616: 		return true;
617: 	default:
618: 		return false;
619: 	}
620: }
621: 
622: bool LogicalType::GetDecimalProperties(uint8_t &width, uint8_t &scale) const {
623: 	switch (id_) {
624: 	case LogicalTypeId::SQLNULL:
625: 		width = 0;
626: 		scale = 0;
627: 		break;
628: 	case LogicalTypeId::BOOLEAN:
629: 		width = 1;
630: 		scale = 0;
631: 		break;
632: 	case LogicalTypeId::TINYINT:
633: 		// tinyint: [-127, 127] = DECIMAL(3,0)
634: 		width = 3;
635: 		scale = 0;
636: 		break;
637: 	case LogicalTypeId::SMALLINT:
638: 		// smallint: [-32767, 32767] = DECIMAL(5,0)
639: 		width = 5;
640: 		scale = 0;
641: 		break;
642: 	case LogicalTypeId::INTEGER:
643: 		// integer: [-2147483647, 2147483647] = DECIMAL(10,0)
644: 		width = 10;
645: 		scale = 0;
646: 		break;
647: 	case LogicalTypeId::BIGINT:
648: 		// bigint: [-9223372036854775807, 9223372036854775807] = DECIMAL(19,0)
649: 		width = 19;
650: 		scale = 0;
651: 		break;
652: 	case LogicalTypeId::UTINYINT:
653: 		// UInt8 — [0 : 255]
654: 		width = 3;
655: 		scale = 0;
656: 		break;
657: 	case LogicalTypeId::USMALLINT:
658: 		// UInt16 — [0 : 65535]
659: 		width = 5;
660: 		scale = 0;
661: 		break;
662: 	case LogicalTypeId::UINTEGER:
663: 		// UInt32 — [0 : 4294967295]
664: 		width = 10;
665: 		scale = 0;
666: 		break;
667: 	case LogicalTypeId::UBIGINT:
668: 		// UInt64 — [0 : 18446744073709551615]
669: 		width = 20;
670: 		scale = 0;
671: 		break;
672: 	case LogicalTypeId::HUGEINT:
673: 		// hugeint: max size decimal (38, 0)
674: 		// note that a hugeint is not guaranteed to fit in this
675: 		width = 38;
676: 		scale = 0;
677: 		break;
678: 	case LogicalTypeId::DECIMAL:
679: 		width = DecimalType::GetWidth(*this);
680: 		scale = DecimalType::GetScale(*this);
681: 		break;
682: 	default:
683: 		return false;
684: 	}
685: 	return true;
686: }
687: 
688: LogicalType LogicalType::MaxLogicalType(const LogicalType &left, const LogicalType &right) {
689: 	if (left.id() < right.id()) {
690: 		return right;
691: 	} else if (right.id() < left.id()) {
692: 		return left;
693: 	} else {
694: 		// Since both left and right are equal we get the left type as our type_id for checks
695: 		auto type_id = left.id();
696: 		if (type_id == LogicalTypeId::ENUM) {
697: 			// If both types are different ENUMs we do a string comparison.
698: 			return left == right ? left : LogicalType::VARCHAR;
699: 		}
700: 		if (type_id == LogicalTypeId::VARCHAR) {
701: 			// varchar: use type that has collation (if any)
702: 			if (StringType::GetCollation(right).empty()) {
703: 				return left;
704: 			} else {
705: 				return right;
706: 			}
707: 		} else if (type_id == LogicalTypeId::DECIMAL) {
708: 			// use max width/scale of the two types
709: 			auto width = MaxValue<uint8_t>(DecimalType::GetWidth(left), DecimalType::GetWidth(right));
710: 			auto scale = MaxValue<uint8_t>(DecimalType::GetScale(left), DecimalType::GetScale(right));
711: 			return LogicalType::DECIMAL(width, scale);
712: 		} else if (type_id == LogicalTypeId::LIST) {
713: 			// list: perform max recursively on child type
714: 			auto new_child = MaxLogicalType(ListType::GetChildType(left), ListType::GetChildType(right));
715: 			return LogicalType::LIST(move(new_child));
716: 		} else if (type_id == LogicalTypeId::STRUCT) {
717: 			// struct: perform recursively
718: 			auto &left_child_types = StructType::GetChildTypes(left);
719: 			auto &right_child_types = StructType::GetChildTypes(right);
720: 			if (left_child_types.size() != right_child_types.size()) {
721: 				// child types are not of equal size, we can't cast anyway
722: 				// just return the left child
723: 				return left;
724: 			}
725: 			child_list_t<LogicalType> child_types;
726: 			for (idx_t i = 0; i < left_child_types.size(); i++) {
727: 				auto child_type = MaxLogicalType(left_child_types[i].second, right_child_types[i].second);
728: 				child_types.push_back(make_pair(left_child_types[i].first, move(child_type)));
729: 			}
730: 			return LogicalType::STRUCT(move(child_types));
731: 		} else {
732: 			// types are equal but no extra specifier: just return the type
733: 			return left;
734: 		}
735: 	}
736: }
737: 
738: void LogicalType::Verify() const {
739: #ifdef DEBUG
740: 	if (id_ == LogicalTypeId::DECIMAL) {
741: 		D_ASSERT(DecimalType::GetWidth(*this) >= 1 && DecimalType::GetWidth(*this) <= Decimal::MAX_WIDTH_DECIMAL);
742: 		D_ASSERT(DecimalType::GetScale(*this) >= 0 && DecimalType::GetScale(*this) <= DecimalType::GetWidth(*this));
743: 	}
744: #endif
745: }
746: 
747: bool ApproxEqual(float ldecimal, float rdecimal) {
748: 	float epsilon = std::fabs(rdecimal) * 0.01;
749: 	return std::fabs(ldecimal - rdecimal) <= epsilon;
750: }
751: 
752: bool ApproxEqual(double ldecimal, double rdecimal) {
753: 	double epsilon = std::fabs(rdecimal) * 0.01;
754: 	return std::fabs(ldecimal - rdecimal) <= epsilon;
755: }
756: 
757: //===--------------------------------------------------------------------===//
758: // Extra Type Info
759: //===--------------------------------------------------------------------===//
760: enum class ExtraTypeInfoType : uint8_t {
761: 	INVALID_TYPE_INFO = 0,
762: 	DECIMAL_TYPE_INFO = 1,
763: 	STRING_TYPE_INFO = 2,
764: 	LIST_TYPE_INFO = 3,
765: 	STRUCT_TYPE_INFO = 4,
766: 	ENUM_TYPE_INFO = 5,
767: 	USER_TYPE_INFO = 6,
768: 	AGGREGATE_STATE_TYPE_INFO = 7
769: };
770: 
771: struct ExtraTypeInfo {
772: 	explicit ExtraTypeInfo(ExtraTypeInfoType type) : type(type) {
773: 	}
774: 	virtual ~ExtraTypeInfo() {
775: 	}
776: 
777: 	ExtraTypeInfoType type;
778: 
779: public:
780: 	virtual bool Equals(ExtraTypeInfo *other) const = 0;
781: 	//! Serializes a ExtraTypeInfo to a stand-alone binary blob
782: 	virtual void Serialize(FieldWriter &writer) const = 0;
783: 	//! Serializes a ExtraTypeInfo to a stand-alone binary blob
784: 	static void Serialize(ExtraTypeInfo *info, FieldWriter &writer);
785: 	//! Deserializes a blob back into an ExtraTypeInfo
786: 	static shared_ptr<ExtraTypeInfo> Deserialize(FieldReader &reader);
787: };
788: 
789: //===--------------------------------------------------------------------===//
790: // Decimal Type
791: //===--------------------------------------------------------------------===//
792: struct DecimalTypeInfo : public ExtraTypeInfo {
793: 	DecimalTypeInfo(uint8_t width_p, uint8_t scale_p)
794: 	    : ExtraTypeInfo(ExtraTypeInfoType::DECIMAL_TYPE_INFO), width(width_p), scale(scale_p) {
795: 	}
796: 
797: 	uint8_t width;
798: 	uint8_t scale;
799: 
800: public:
801: 	bool Equals(ExtraTypeInfo *other_p) const override {
802: 		if (!other_p) {
803: 			return false;
804: 		}
805: 		if (type != other_p->type) {
806: 			return false;
807: 		}
808: 		auto &other = (DecimalTypeInfo &)*other_p;
809: 		return width == other.width && scale == other.scale;
810: 	}
811: 
812: 	void Serialize(FieldWriter &writer) const override {
813: 		writer.WriteField<uint8_t>(width);
814: 		writer.WriteField<uint8_t>(scale);
815: 	}
816: 
817: 	static shared_ptr<ExtraTypeInfo> Deserialize(FieldReader &reader) {
818: 		auto width = reader.ReadRequired<uint8_t>();
819: 		auto scale = reader.ReadRequired<uint8_t>();
820: 		return make_shared<DecimalTypeInfo>(width, scale);
821: 	}
822: };
823: 
824: uint8_t DecimalType::GetWidth(const LogicalType &type) {
825: 	D_ASSERT(type.id() == LogicalTypeId::DECIMAL);
826: 	auto info = type.AuxInfo();
827: 	D_ASSERT(info);
828: 	return ((DecimalTypeInfo &)*info).width;
829: }
830: 
831: uint8_t DecimalType::GetScale(const LogicalType &type) {
832: 	D_ASSERT(type.id() == LogicalTypeId::DECIMAL);
833: 	auto info = type.AuxInfo();
834: 	D_ASSERT(info);
835: 	return ((DecimalTypeInfo &)*info).scale;
836: }
837: 
838: LogicalType LogicalType::DECIMAL(int width, int scale) {
839: 	auto type_info = make_shared<DecimalTypeInfo>(width, scale);
840: 	return LogicalType(LogicalTypeId::DECIMAL, move(type_info));
841: }
842: 
843: //===--------------------------------------------------------------------===//
844: // String Type
845: //===--------------------------------------------------------------------===//
846: struct StringTypeInfo : public ExtraTypeInfo {
847: 	explicit StringTypeInfo(string collation_p)
848: 	    : ExtraTypeInfo(ExtraTypeInfoType::STRING_TYPE_INFO), collation(move(collation_p)) {
849: 	}
850: 
851: 	string collation;
852: 
853: public:
854: 	bool Equals(ExtraTypeInfo *other_p) const override {
855: 		// collation info has no impact on equality
856: 		return true;
857: 	}
858: 
859: 	void Serialize(FieldWriter &writer) const override {
860: 		writer.WriteString(collation);
861: 	}
862: 
863: 	static shared_ptr<ExtraTypeInfo> Deserialize(FieldReader &reader) {
864: 		auto collation = reader.ReadRequired<string>();
865: 		return make_shared<StringTypeInfo>(move(collation));
866: 	}
867: };
868: 
869: string StringType::GetCollation(const LogicalType &type) {
870: 	if (type.id() != LogicalTypeId::VARCHAR) {
871: 		return string();
872: 	}
873: 	auto info = type.AuxInfo();
874: 	if (!info) {
875: 		return string();
876: 	}
877: 	return ((StringTypeInfo &)*info).collation;
878: }
879: 
880: LogicalType LogicalType::VARCHAR_COLLATION(string collation) { // NOLINT
881: 	auto string_info = make_shared<StringTypeInfo>(move(collation));
882: 	return LogicalType(LogicalTypeId::VARCHAR, move(string_info));
883: }
884: 
885: //===--------------------------------------------------------------------===//
886: // List Type
887: //===--------------------------------------------------------------------===//
888: struct ListTypeInfo : public ExtraTypeInfo {
889: 	explicit ListTypeInfo(LogicalType child_type_p)
890: 	    : ExtraTypeInfo(ExtraTypeInfoType::LIST_TYPE_INFO), child_type(move(child_type_p)) {
891: 	}
892: 
893: 	LogicalType child_type;
894: 
895: public:
896: 	bool Equals(ExtraTypeInfo *other_p) const override {
897: 		if (!other_p) {
898: 			return false;
899: 		}
900: 		if (type != other_p->type) {
901: 			return false;
902: 		}
903: 		auto &other = (ListTypeInfo &)*other_p;
904: 		return child_type == other.child_type;
905: 	}
906: 
907: 	void Serialize(FieldWriter &writer) const override {
908: 		writer.WriteSerializable(child_type);
909: 	}
910: 
911: 	static shared_ptr<ExtraTypeInfo> Deserialize(FieldReader &reader) {
912: 		auto child_type = reader.ReadRequiredSerializable<LogicalType, LogicalType>();
913: 		return make_shared<ListTypeInfo>(move(child_type));
914: 	}
915: };
916: 
917: const LogicalType &ListType::GetChildType(const LogicalType &type) {
918: 	D_ASSERT(type.id() == LogicalTypeId::LIST);
919: 	auto info = type.AuxInfo();
920: 	D_ASSERT(info);
921: 	return ((ListTypeInfo &)*info).child_type;
922: }
923: 
924: LogicalType LogicalType::LIST(LogicalType child) {
925: 	auto info = make_shared<ListTypeInfo>(move(child));
926: 	return LogicalType(LogicalTypeId::LIST, move(info));
927: }
928: 
929: //===--------------------------------------------------------------------===//
930: // Struct Type
931: //===--------------------------------------------------------------------===//
932: struct StructTypeInfo : public ExtraTypeInfo {
933: 	explicit StructTypeInfo(child_list_t<LogicalType> child_types_p)
934: 	    : ExtraTypeInfo(ExtraTypeInfoType::STRUCT_TYPE_INFO), child_types(move(child_types_p)) {
935: 	}
936: 
937: 	child_list_t<LogicalType> child_types;
938: 
939: public:
940: 	bool Equals(ExtraTypeInfo *other_p) const override {
941: 		if (!other_p) {
942: 			return false;
943: 		}
944: 		if (type != other_p->type) {
945: 			return false;
946: 		}
947: 		auto &other = (StructTypeInfo &)*other_p;
948: 		return child_types == other.child_types;
949: 	}
950: 
951: 	void Serialize(FieldWriter &writer) const override {
952: 		writer.WriteField<uint32_t>(child_types.size());
953: 		auto &serializer = writer.GetSerializer();
954: 		for (idx_t i = 0; i < child_types.size(); i++) {
955: 			serializer.WriteString(child_types[i].first);
956: 			child_types[i].second.Serialize(serializer);
957: 		}
958: 	}
959: 
960: 	static shared_ptr<ExtraTypeInfo> Deserialize(FieldReader &reader) {
961: 		child_list_t<LogicalType> child_list;
962: 		auto child_types_size = reader.ReadRequired<uint32_t>();
963: 		auto &source = reader.GetSource();
964: 		for (uint32_t i = 0; i < child_types_size; i++) {
965: 			auto name = source.Read<string>();
966: 			auto type = LogicalType::Deserialize(source);
967: 			child_list.push_back(make_pair(move(name), move(type)));
968: 		}
969: 		return make_shared<StructTypeInfo>(move(child_list));
970: 	}
971: };
972: 
973: struct AggregateStateTypeInfo : public ExtraTypeInfo {
974: 	explicit AggregateStateTypeInfo(aggregate_state_t state_type_p)
975: 	    : ExtraTypeInfo(ExtraTypeInfoType::AGGREGATE_STATE_TYPE_INFO), state_type(move(state_type_p)) {
976: 	}
977: 
978: 	aggregate_state_t state_type;
979: 
980: public:
981: 	bool Equals(ExtraTypeInfo *other_p) const override {
982: 		if (!other_p) {
983: 			return false;
984: 		}
985: 		if (type != other_p->type) {
986: 			return false;
987: 		}
988: 		auto &other = (AggregateStateTypeInfo &)*other_p;
989: 		return state_type.function_name == other.state_type.function_name &&
990: 		       state_type.return_type == other.state_type.return_type &&
991: 		       state_type.bound_argument_types == other.state_type.bound_argument_types;
992: 	}
993: 
994: 	void Serialize(FieldWriter &writer) const override {
995: 		auto &serializer = writer.GetSerializer();
996: 		writer.WriteString(state_type.function_name);
997: 		state_type.return_type.Serialize(serializer);
998: 		writer.WriteField<uint32_t>(state_type.bound_argument_types.size());
999: 		for (idx_t i = 0; i < state_type.bound_argument_types.size(); i++) {
1000: 			state_type.bound_argument_types[i].Serialize(serializer);
1001: 		}
1002: 	}
1003: 
1004: 	static shared_ptr<ExtraTypeInfo> Deserialize(FieldReader &reader) {
1005: 		auto &source = reader.GetSource();
1006: 
1007: 		auto function_name = reader.ReadRequired<string>();
1008: 		auto return_type = LogicalType::Deserialize(source);
1009: 		auto bound_argument_types_size = reader.ReadRequired<uint32_t>();
1010: 		vector<LogicalType> bound_argument_types;
1011: 
1012: 		for (uint32_t i = 0; i < bound_argument_types_size; i++) {
1013: 			auto type = LogicalType::Deserialize(source);
1014: 			bound_argument_types.push_back(move(type));
1015: 		}
1016: 		return make_shared<AggregateStateTypeInfo>(
1017: 		    aggregate_state_t(move(function_name), move(return_type), move(bound_argument_types)));
1018: 	}
1019: };
1020: 
1021: const aggregate_state_t &AggregateStateType::GetStateType(const LogicalType &type) {
1022: 	D_ASSERT(type.id() == LogicalTypeId::AGGREGATE_STATE);
1023: 	auto info = type.AuxInfo();
1024: 	D_ASSERT(info);
1025: 	return ((AggregateStateTypeInfo &)*info).state_type;
1026: }
1027: 
1028: const string AggregateStateType::GetTypeName(const LogicalType &type) {
1029: 	D_ASSERT(type.id() == LogicalTypeId::AGGREGATE_STATE);
1030: 	auto info = type.AuxInfo();
1031: 	if (!info) {
1032: 		return "AGGREGATE_STATE<?>";
1033: 	}
1034: 	auto aggr_state = ((AggregateStateTypeInfo &)*info).state_type;
1035: 	return "AGGREGATE_STATE<" + aggr_state.function_name + "(" +
1036: 	       StringUtil::Join(aggr_state.bound_argument_types, aggr_state.bound_argument_types.size(), ", ",
1037: 	                        [](const LogicalType &arg_type) { return arg_type.ToString(); }) +
1038: 	       ")" + "::" + aggr_state.return_type.ToString() + ">";
1039: }
1040: 
1041: const child_list_t<LogicalType> &StructType::GetChildTypes(const LogicalType &type) {
1042: 	D_ASSERT(type.id() == LogicalTypeId::STRUCT || type.id() == LogicalTypeId::MAP);
1043: 	auto info = type.AuxInfo();
1044: 	D_ASSERT(info);
1045: 	return ((StructTypeInfo &)*info).child_types;
1046: }
1047: 
1048: const LogicalType &StructType::GetChildType(const LogicalType &type, idx_t index) {
1049: 	auto &child_types = StructType::GetChildTypes(type);
1050: 	D_ASSERT(index < child_types.size());
1051: 	return child_types[index].second;
1052: }
1053: 
1054: const string &StructType::GetChildName(const LogicalType &type, idx_t index) {
1055: 	auto &child_types = StructType::GetChildTypes(type);
1056: 	D_ASSERT(index < child_types.size());
1057: 	return child_types[index].first;
1058: }
1059: 
1060: idx_t StructType::GetChildCount(const LogicalType &type) {
1061: 	return StructType::GetChildTypes(type).size();
1062: }
1063: 
1064: LogicalType LogicalType::STRUCT(child_list_t<LogicalType> children) {
1065: 	auto info = make_shared<StructTypeInfo>(move(children));
1066: 	return LogicalType(LogicalTypeId::STRUCT, move(info));
1067: }
1068: 
1069: LogicalType LogicalType::AGGREGATE_STATE(aggregate_state_t state_type) { // NOLINT
1070: 	auto info = make_shared<AggregateStateTypeInfo>(move(state_type));
1071: 	return LogicalType(LogicalTypeId::AGGREGATE_STATE, move(info));
1072: }
1073: 
1074: //===--------------------------------------------------------------------===//
1075: // Map Type
1076: //===--------------------------------------------------------------------===//
1077: LogicalType LogicalType::MAP(child_list_t<LogicalType> children) {
1078: 	auto info = make_shared<StructTypeInfo>(move(children));
1079: 	return LogicalType(LogicalTypeId::MAP, move(info));
1080: }
1081: 
1082: LogicalType LogicalType::MAP(LogicalType key, LogicalType value) {
1083: 	child_list_t<LogicalType> child_types;
1084: 	child_types.push_back({"key", LogicalType::LIST(move(key))});
1085: 	child_types.push_back({"value", LogicalType::LIST(move(value))});
1086: 	return LogicalType::MAP(move(child_types));
1087: }
1088: 
1089: const LogicalType &MapType::KeyType(const LogicalType &type) {
1090: 	D_ASSERT(type.id() == LogicalTypeId::MAP);
1091: 	return ListType::GetChildType(StructType::GetChildTypes(type)[0].second);
1092: }
1093: 
1094: const LogicalType &MapType::ValueType(const LogicalType &type) {
1095: 	D_ASSERT(type.id() == LogicalTypeId::MAP);
1096: 	return ListType::GetChildType(StructType::GetChildTypes(type)[1].second);
1097: }
1098: 
1099: //===--------------------------------------------------------------------===//
1100: // User Type
1101: //===--------------------------------------------------------------------===//
1102: struct UserTypeInfo : public ExtraTypeInfo {
1103: 	explicit UserTypeInfo(string name_p)
1104: 	    : ExtraTypeInfo(ExtraTypeInfoType::USER_TYPE_INFO), user_type_name(move(name_p)) {
1105: 	}
1106: 
1107: 	string user_type_name;
1108: 
1109: public:
1110: 	bool Equals(ExtraTypeInfo *other_p) const override {
1111: 		if (!other_p) {
1112: 			return false;
1113: 		}
1114: 		if (type != other_p->type) {
1115: 			return false;
1116: 		}
1117: 		auto &other = (UserTypeInfo &)*other_p;
1118: 		return other.user_type_name == user_type_name;
1119: 	}
1120: 
1121: 	void Serialize(FieldWriter &writer) const override {
1122: 		writer.WriteString(user_type_name);
1123: 	}
1124: 
1125: 	static shared_ptr<ExtraTypeInfo> Deserialize(FieldReader &reader) {
1126: 		auto enum_name = reader.ReadRequired<string>();
1127: 		return make_shared<UserTypeInfo>(move(enum_name));
1128: 	}
1129: };
1130: 
1131: const string &UserType::GetTypeName(const LogicalType &type) {
1132: 	D_ASSERT(type.id() == LogicalTypeId::USER);
1133: 	auto info = type.AuxInfo();
1134: 	D_ASSERT(info);
1135: 	return ((UserTypeInfo &)*info).user_type_name;
1136: }
1137: 
1138: LogicalType LogicalType::USER(const string &user_type_name) {
1139: 	auto info = make_shared<UserTypeInfo>(user_type_name);
1140: 	return LogicalType(LogicalTypeId::USER, move(info));
1141: }
1142: 
1143: //===--------------------------------------------------------------------===//
1144: // Enum Type
1145: //===--------------------------------------------------------------------===//
1146: struct EnumTypeInfo : public ExtraTypeInfo {
1147: 	explicit EnumTypeInfo(string enum_name_p, Vector &values_insert_order_p, idx_t size)
1148: 	    : ExtraTypeInfo(ExtraTypeInfoType::ENUM_TYPE_INFO), enum_name(move(enum_name_p)),
1149: 	      values_insert_order(values_insert_order_p), size(size) {
1150: 	}
1151: 	string enum_name;
1152: 	Vector values_insert_order;
1153: 	idx_t size;
1154: 	TypeCatalogEntry *catalog_entry = nullptr;
1155: 
1156: public:
1157: 	// Equalities are only used in enums with different catalog entries
1158: 	bool Equals(ExtraTypeInfo *other_p) const override {
1159: 		if (!other_p) {
1160: 			return false;
1161: 		}
1162: 		if (type != other_p->type) {
1163: 			return false;
1164: 		}
1165: 		auto &other = (EnumTypeInfo &)*other_p;
1166: 
1167: 		// We must check if both enums have the same size
1168: 		if (other.size != size) {
1169: 			return false;
1170: 		}
1171: 		auto other_vector_ptr = FlatVector::GetData<string_t>(other.values_insert_order);
1172: 		auto this_vector_ptr = FlatVector::GetData<string_t>(values_insert_order);
1173: 
1174: 		// Now we must check if all strings are the same
1175: 		for (idx_t i = 0; i < size; i++) {
1176: 			if (!Equals::Operation(other_vector_ptr[i], this_vector_ptr[i])) {
1177: 				return false;
1178: 			}
1179: 		}
1180: 		return true;
1181: 	}
1182: 
1183: 	void Serialize(FieldWriter &writer) const override {
1184: 		writer.WriteField<uint32_t>(size);
1185: 		writer.WriteString(enum_name);
1186: 		((Vector &)values_insert_order).Serialize(size, writer.GetSerializer());
1187: 	}
1188: };
1189: 
1190: template <class T>
1191: struct EnumTypeInfoTemplated : public EnumTypeInfo {
1192: 	explicit EnumTypeInfoTemplated(const string &enum_name_p, Vector &values_insert_order_p, idx_t size_p)
1193: 	    : EnumTypeInfo(enum_name_p, values_insert_order_p, size_p) {
1194: 		for (idx_t count = 0; count < size_p; count++) {
1195: 			values[values_insert_order_p.GetValue(count).ToString()] = count;
1196: 		}
1197: 	}
1198: 
1199: 	static shared_ptr<EnumTypeInfoTemplated> Deserialize(FieldReader &reader, uint32_t size) {
1200: 		auto enum_name = reader.ReadRequired<string>();
1201: 		Vector values_insert_order(LogicalType::VARCHAR, size);
1202: 		values_insert_order.Deserialize(size, reader.GetSource());
1203: 		return make_shared<EnumTypeInfoTemplated>(move(enum_name), values_insert_order, size);
1204: 	}
1205: 	unordered_map<string, T> values;
1206: };
1207: 
1208: const string &EnumType::GetTypeName(const LogicalType &type) {
1209: 	D_ASSERT(type.id() == LogicalTypeId::ENUM);
1210: 	auto info = type.AuxInfo();
1211: 	D_ASSERT(info);
1212: 	return ((EnumTypeInfo &)*info).enum_name;
1213: }
1214: 
1215: LogicalType LogicalType::ENUM(const string &enum_name, Vector &ordered_data, idx_t size) {
1216: 	// Generate EnumTypeInfo
1217: 	shared_ptr<ExtraTypeInfo> info;
1218: 	auto enum_internal_type = EnumType::GetPhysicalType(size);
1219: 	switch (enum_internal_type) {
1220: 	case PhysicalType::UINT8:
1221: 		info = make_shared<EnumTypeInfoTemplated<uint8_t>>(enum_name, ordered_data, size);
1222: 		break;
1223: 	case PhysicalType::UINT16:
1224: 		info = make_shared<EnumTypeInfoTemplated<uint16_t>>(enum_name, ordered_data, size);
1225: 		break;
1226: 	case PhysicalType::UINT32:
1227: 		info = make_shared<EnumTypeInfoTemplated<uint32_t>>(enum_name, ordered_data, size);
1228: 		break;
1229: 	default:
1230: 		throw InternalException("Invalid Physical Type for ENUMs");
1231: 	}
1232: 	// Generate Actual Enum Type
1233: 	return LogicalType(LogicalTypeId::ENUM, info);
1234: }
1235: 
1236: template <class T>
1237: int64_t TemplatedGetPos(unordered_map<string, T> &map, const string &key) {
1238: 	auto it = map.find(key);
1239: 	if (it == map.end()) {
1240: 		return -1;
1241: 	}
1242: 	return it->second;
1243: }
1244: int64_t EnumType::GetPos(const LogicalType &type, const string &key) {
1245: 	auto info = type.AuxInfo();
1246: 	switch (type.InternalType()) {
1247: 	case PhysicalType::UINT8:
1248: 		return TemplatedGetPos(((EnumTypeInfoTemplated<uint8_t> &)*info).values, key);
1249: 	case PhysicalType::UINT16:
1250: 		return TemplatedGetPos(((EnumTypeInfoTemplated<uint16_t> &)*info).values, key);
1251: 	case PhysicalType::UINT32:
1252: 		return TemplatedGetPos(((EnumTypeInfoTemplated<uint32_t> &)*info).values, key);
1253: 	default:
1254: 		throw InternalException("ENUM can only have unsigned integers (except UINT64) as physical types");
1255: 	}
1256: }
1257: 
1258: const string EnumType::GetValue(const Value &val) {
1259: 	auto info = val.type().AuxInfo();
1260: 	auto &values_insert_order = ((EnumTypeInfo &)*info).values_insert_order;
1261: 	return StringValue::Get(values_insert_order.GetValue(val.GetValue<uint32_t>()));
1262: }
1263: 
1264: Vector &EnumType::GetValuesInsertOrder(const LogicalType &type) {
1265: 	D_ASSERT(type.id() == LogicalTypeId::ENUM);
1266: 	auto info = type.AuxInfo();
1267: 	D_ASSERT(info);
1268: 	return ((EnumTypeInfo &)*info).values_insert_order;
1269: }
1270: 
1271: idx_t EnumType::GetSize(const LogicalType &type) {
1272: 	D_ASSERT(type.id() == LogicalTypeId::ENUM);
1273: 	auto info = type.AuxInfo();
1274: 	D_ASSERT(info);
1275: 	return ((EnumTypeInfo &)*info).size;
1276: }
1277: 
1278: void EnumType::SetCatalog(LogicalType &type, TypeCatalogEntry *catalog_entry) {
1279: 	D_ASSERT(type.id() == LogicalTypeId::ENUM);
1280: 	auto info = type.AuxInfo();
1281: 	D_ASSERT(info);
1282: 	((EnumTypeInfo &)*info).catalog_entry = catalog_entry;
1283: }
1284: TypeCatalogEntry *EnumType::GetCatalog(const LogicalType &type) {
1285: 	D_ASSERT(type.id() == LogicalTypeId::ENUM);
1286: 	auto info = type.AuxInfo();
1287: 	D_ASSERT(info);
1288: 	return ((EnumTypeInfo &)*info).catalog_entry;
1289: }
1290: 
1291: PhysicalType EnumType::GetPhysicalType(idx_t size) {
1292: 	if (size <= NumericLimits<uint8_t>::Maximum()) {
1293: 		return PhysicalType::UINT8;
1294: 	} else if (size <= NumericLimits<uint16_t>::Maximum()) {
1295: 		return PhysicalType::UINT16;
1296: 	} else if (size <= NumericLimits<uint32_t>::Maximum()) {
1297: 		return PhysicalType::UINT32;
1298: 	} else {
1299: 		throw InternalException("Enum size must be lower than " + std::to_string(NumericLimits<uint32_t>::Maximum()));
1300: 	}
1301: }
1302: 
1303: //===--------------------------------------------------------------------===//
1304: // Extra Type Info
1305: //===--------------------------------------------------------------------===//
1306: void ExtraTypeInfo::Serialize(ExtraTypeInfo *info, FieldWriter &writer) {
1307: 	if (!info) {
1308: 		writer.WriteField<ExtraTypeInfoType>(ExtraTypeInfoType::INVALID_TYPE_INFO);
1309: 	} else {
1310: 		writer.WriteField<ExtraTypeInfoType>(info->type);
1311: 		info->Serialize(writer);
1312: 	}
1313: }
1314: shared_ptr<ExtraTypeInfo> ExtraTypeInfo::Deserialize(FieldReader &reader) {
1315: 	auto type = reader.ReadRequired<ExtraTypeInfoType>();
1316: 	switch (type) {
1317: 	case ExtraTypeInfoType::INVALID_TYPE_INFO:
1318: 		return nullptr;
1319: 	case ExtraTypeInfoType::DECIMAL_TYPE_INFO:
1320: 		return DecimalTypeInfo::Deserialize(reader);
1321: 	case ExtraTypeInfoType::STRING_TYPE_INFO:
1322: 		return StringTypeInfo::Deserialize(reader);
1323: 	case ExtraTypeInfoType::LIST_TYPE_INFO:
1324: 		return ListTypeInfo::Deserialize(reader);
1325: 	case ExtraTypeInfoType::STRUCT_TYPE_INFO:
1326: 		return StructTypeInfo::Deserialize(reader);
1327: 	case ExtraTypeInfoType::USER_TYPE_INFO:
1328: 		return UserTypeInfo::Deserialize(reader);
1329: 	case ExtraTypeInfoType::ENUM_TYPE_INFO: {
1330: 		auto enum_size = reader.ReadRequired<uint32_t>();
1331: 		auto enum_internal_type = EnumType::GetPhysicalType(enum_size);
1332: 		switch (enum_internal_type) {
1333: 		case PhysicalType::UINT8:
1334: 			return EnumTypeInfoTemplated<uint8_t>::Deserialize(reader, enum_size);
1335: 		case PhysicalType::UINT16:
1336: 			return EnumTypeInfoTemplated<uint16_t>::Deserialize(reader, enum_size);
1337: 		case PhysicalType::UINT32:
1338: 			return EnumTypeInfoTemplated<uint32_t>::Deserialize(reader, enum_size);
1339: 		default:
1340: 			throw InternalException("Invalid Physical Type for ENUMs");
1341: 		}
1342: 	}
1343: 	case ExtraTypeInfoType::AGGREGATE_STATE_TYPE_INFO:
1344: 		return AggregateStateTypeInfo::Deserialize(reader);
1345: 
1346: 	default:
1347: 		throw InternalException("Unimplemented type info in ExtraTypeInfo::Deserialize");
1348: 	}
1349: }
1350: 
1351: //===--------------------------------------------------------------------===//
1352: // Logical Type
1353: //===--------------------------------------------------------------------===//
1354: 
1355: // the destructor needs to know about the extra type info
1356: LogicalType::~LogicalType() {
1357: }
1358: 
1359: void LogicalType::Serialize(Serializer &serializer) const {
1360: 	FieldWriter writer(serializer);
1361: 	writer.WriteField<LogicalTypeId>(id_);
1362: 	ExtraTypeInfo::Serialize(type_info_.get(), writer);
1363: 	writer.Finalize();
1364: }
1365: 
1366: LogicalType LogicalType::Deserialize(Deserializer &source) {
1367: 	FieldReader reader(source);
1368: 	auto id = reader.ReadRequired<LogicalTypeId>();
1369: 	auto info = ExtraTypeInfo::Deserialize(reader);
1370: 	reader.Finalize();
1371: 
1372: 	return LogicalType(id, move(info));
1373: }
1374: 
1375: bool LogicalType::operator==(const LogicalType &rhs) const {
1376: 	if (id_ != rhs.id_) {
1377: 		return false;
1378: 	}
1379: 	if (type_info_.get() == rhs.type_info_.get()) {
1380: 		return true;
1381: 	}
1382: 	if (type_info_) {
1383: 		return type_info_->Equals(rhs.type_info_.get());
1384: 	} else {
1385: 		D_ASSERT(rhs.type_info_);
1386: 		return rhs.type_info_->Equals(type_info_.get());
1387: 	}
1388: }
1389: 
1390: } // namespace duckdb
[end of src/common/types.cpp]
[start of src/common/types/hugeint.cpp]
1: #include "duckdb/common/types/hugeint.hpp"
2: #include "duckdb/common/exception.hpp"
3: #include "duckdb/common/algorithm.hpp"
4: #include "duckdb/common/limits.hpp"
5: #include "duckdb/common/windows_undefs.hpp"
6: 
7: #include <cmath>
8: #include <limits>
9: 
10: namespace duckdb {
11: 
12: //===--------------------------------------------------------------------===//
13: // String Conversion
14: //===--------------------------------------------------------------------===//
15: const hugeint_t Hugeint::POWERS_OF_TEN[] {
16:     hugeint_t(1),
17:     hugeint_t(10),
18:     hugeint_t(100),
19:     hugeint_t(1000),
20:     hugeint_t(10000),
21:     hugeint_t(100000),
22:     hugeint_t(1000000),
23:     hugeint_t(10000000),
24:     hugeint_t(100000000),
25:     hugeint_t(1000000000),
26:     hugeint_t(10000000000),
27:     hugeint_t(100000000000),
28:     hugeint_t(1000000000000),
29:     hugeint_t(10000000000000),
30:     hugeint_t(100000000000000),
31:     hugeint_t(1000000000000000),
32:     hugeint_t(10000000000000000),
33:     hugeint_t(100000000000000000),
34:     hugeint_t(1000000000000000000),
35:     hugeint_t(1000000000000000000) * hugeint_t(10),
36:     hugeint_t(1000000000000000000) * hugeint_t(100),
37:     hugeint_t(1000000000000000000) * hugeint_t(1000),
38:     hugeint_t(1000000000000000000) * hugeint_t(10000),
39:     hugeint_t(1000000000000000000) * hugeint_t(100000),
40:     hugeint_t(1000000000000000000) * hugeint_t(1000000),
41:     hugeint_t(1000000000000000000) * hugeint_t(10000000),
42:     hugeint_t(1000000000000000000) * hugeint_t(100000000),
43:     hugeint_t(1000000000000000000) * hugeint_t(1000000000),
44:     hugeint_t(1000000000000000000) * hugeint_t(10000000000),
45:     hugeint_t(1000000000000000000) * hugeint_t(100000000000),
46:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000),
47:     hugeint_t(1000000000000000000) * hugeint_t(10000000000000),
48:     hugeint_t(1000000000000000000) * hugeint_t(100000000000000),
49:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000),
50:     hugeint_t(1000000000000000000) * hugeint_t(10000000000000000),
51:     hugeint_t(1000000000000000000) * hugeint_t(100000000000000000),
52:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000000),
53:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000000) * hugeint_t(10),
54:     hugeint_t(1000000000000000000) * hugeint_t(1000000000000000000) * hugeint_t(100)};
55: 
56: static uint8_t PositiveHugeintHighestBit(hugeint_t bits) {
57: 	uint8_t out = 0;
58: 	if (bits.upper) {
59: 		out = 64;
60: 		uint64_t up = bits.upper;
61: 		while (up) {
62: 			up >>= 1;
63: 			out++;
64: 		}
65: 	} else {
66: 		uint64_t low = bits.lower;
67: 		while (low) {
68: 			low >>= 1;
69: 			out++;
70: 		}
71: 	}
72: 	return out;
73: }
74: 
75: static bool PositiveHugeintIsBitSet(hugeint_t lhs, uint8_t bit_position) {
76: 	if (bit_position < 64) {
77: 		return lhs.lower & (uint64_t(1) << uint64_t(bit_position));
78: 	} else {
79: 		return lhs.upper & (uint64_t(1) << uint64_t(bit_position - 64));
80: 	}
81: }
82: 
83: hugeint_t PositiveHugeintLeftShift(hugeint_t lhs, uint32_t amount) {
84: 	D_ASSERT(amount > 0 && amount < 64);
85: 	hugeint_t result;
86: 	result.lower = lhs.lower << amount;
87: 	result.upper = (lhs.upper << amount) + (lhs.lower >> (64 - amount));
88: 	return result;
89: }
90: 
91: hugeint_t Hugeint::DivModPositive(hugeint_t lhs, uint64_t rhs, uint64_t &remainder) {
92: 	D_ASSERT(lhs.upper >= 0);
93: 	// DivMod code adapted from:
94: 	// https://github.com/calccrypto/uint128_t/blob/master/uint128_t.cpp
95: 
96: 	// initialize the result and remainder to 0
97: 	hugeint_t div_result;
98: 	div_result.lower = 0;
99: 	div_result.upper = 0;
100: 	remainder = 0;
101: 
102: 	uint8_t highest_bit_set = PositiveHugeintHighestBit(lhs);
103: 	// now iterate over the amount of bits that are set in the LHS
104: 	for (uint8_t x = highest_bit_set; x > 0; x--) {
105: 		// left-shift the current result and remainder by 1
106: 		div_result = PositiveHugeintLeftShift(div_result, 1);
107: 		remainder <<= 1;
108: 		// we get the value of the bit at position X, where position 0 is the least-significant bit
109: 		if (PositiveHugeintIsBitSet(lhs, x - 1)) {
110: 			// increment the remainder
111: 			remainder++;
112: 		}
113: 		if (remainder >= rhs) {
114: 			// the remainder has passed the division multiplier: add one to the divide result
115: 			remainder -= rhs;
116: 			div_result.lower++;
117: 			if (div_result.lower == 0) {
118: 				// overflow
119: 				div_result.upper++;
120: 			}
121: 		}
122: 	}
123: 	return div_result;
124: }
125: 
126: string Hugeint::ToString(hugeint_t input) {
127: 	uint64_t remainder;
128: 	string result;
129: 	bool negative = input.upper < 0;
130: 	if (negative) {
131: 		NegateInPlace(input);
132: 	}
133: 	while (true) {
134: 		if (!input.lower && !input.upper) {
135: 			break;
136: 		}
137: 		input = Hugeint::DivModPositive(input, 10, remainder);
138: 		result = string(1, '0' + remainder) + result; // NOLINT
139: 	}
140: 	if (result.empty()) {
141: 		// value is zero
142: 		return "0";
143: 	}
144: 	return negative ? "-" + result : result;
145: }
146: 
147: //===--------------------------------------------------------------------===//
148: // Multiply
149: //===--------------------------------------------------------------------===//
150: bool Hugeint::TryMultiply(hugeint_t lhs, hugeint_t rhs, hugeint_t &result) {
151: 	bool lhs_negative = lhs.upper < 0;
152: 	bool rhs_negative = rhs.upper < 0;
153: 	if (lhs_negative) {
154: 		NegateInPlace(lhs);
155: 	}
156: 	if (rhs_negative) {
157: 		NegateInPlace(rhs);
158: 	}
159: #if ((__GNUC__ >= 5) || defined(__clang__)) && defined(__SIZEOF_INT128__)
160: 	__uint128_t left = __uint128_t(lhs.lower) + (__uint128_t(lhs.upper) << 64);
161: 	__uint128_t right = __uint128_t(rhs.lower) + (__uint128_t(rhs.upper) << 64);
162: 	__uint128_t result_i128;
163: 	if (__builtin_mul_overflow(left, right, &result_i128)) {
164: 		return false;
165: 	}
166: 	uint64_t upper = uint64_t(result_i128 >> 64);
167: 	if (upper & 0x8000000000000000) {
168: 		return false;
169: 	}
170: 	result.upper = int64_t(upper);
171: 	result.lower = uint64_t(result_i128 & 0xffffffffffffffff);
172: #else
173: 	// Multiply code adapted from:
174: 	// https://github.com/calccrypto/uint128_t/blob/master/uint128_t.cpp
175: 
176: 	// split values into 4 32-bit parts
177: 	uint64_t top[4] = {uint64_t(lhs.upper) >> 32, uint64_t(lhs.upper) & 0xffffffff, lhs.lower >> 32,
178: 	                   lhs.lower & 0xffffffff};
179: 	uint64_t bottom[4] = {uint64_t(rhs.upper) >> 32, uint64_t(rhs.upper) & 0xffffffff, rhs.lower >> 32,
180: 	                      rhs.lower & 0xffffffff};
181: 	uint64_t products[4][4];
182: 
183: 	// multiply each component of the values
184: 	for (auto x = 0; x < 4; x++) {
185: 		for (auto y = 0; y < 4; y++) {
186: 			products[x][y] = top[x] * bottom[y];
187: 		}
188: 	}
189: 
190: 	// if any of these products are set to a non-zero value, there is always an overflow
191: 	if (products[0][0] || products[0][1] || products[0][2] || products[1][0] || products[2][0] || products[1][1]) {
192: 		return false;
193: 	}
194: 	// if the high bits of any of these are set, there is always an overflow
195: 	if ((products[0][3] & 0xffffffff80000000) || (products[1][2] & 0xffffffff80000000) ||
196: 	    (products[2][1] & 0xffffffff80000000) || (products[3][0] & 0xffffffff80000000)) {
197: 		return false;
198: 	}
199: 
200: 	// otherwise we merge the result of the different products together in-order
201: 
202: 	// first row
203: 	uint64_t fourth32 = (products[3][3] & 0xffffffff);
204: 	uint64_t third32 = (products[3][2] & 0xffffffff) + (products[3][3] >> 32);
205: 	uint64_t second32 = (products[3][1] & 0xffffffff) + (products[3][2] >> 32);
206: 	uint64_t first32 = (products[3][0] & 0xffffffff) + (products[3][1] >> 32);
207: 
208: 	// second row
209: 	third32 += (products[2][3] & 0xffffffff);
210: 	second32 += (products[2][2] & 0xffffffff) + (products[2][3] >> 32);
211: 	first32 += (products[2][1] & 0xffffffff) + (products[2][2] >> 32);
212: 
213: 	// third row
214: 	second32 += (products[1][3] & 0xffffffff);
215: 	first32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
216: 
217: 	// fourth row
218: 	first32 += (products[0][3] & 0xffffffff);
219: 
220: 	// move carry to next digit
221: 	third32 += fourth32 >> 32;
222: 	second32 += third32 >> 32;
223: 	first32 += second32 >> 32;
224: 
225: 	// check if the combination of the different products resulted in an overflow
226: 	if (first32 & 0xffffff80000000) {
227: 		return false;
228: 	}
229: 
230: 	// remove carry from current digit
231: 	fourth32 &= 0xffffffff;
232: 	third32 &= 0xffffffff;
233: 	second32 &= 0xffffffff;
234: 	first32 &= 0xffffffff;
235: 
236: 	// combine components
237: 	result.lower = (third32 << 32) | fourth32;
238: 	result.upper = (first32 << 32) | second32;
239: #endif
240: 	if (lhs_negative ^ rhs_negative) {
241: 		NegateInPlace(result);
242: 	}
243: 	return true;
244: }
245: 
246: hugeint_t Hugeint::Multiply(hugeint_t lhs, hugeint_t rhs) {
247: 	hugeint_t result;
248: 	if (!TryMultiply(lhs, rhs, result)) {
249: 		throw OutOfRangeException("Overflow in HUGEINT multiplication!");
250: 	}
251: 	return result;
252: }
253: 
254: //===--------------------------------------------------------------------===//
255: // Divide
256: //===--------------------------------------------------------------------===//
257: hugeint_t Hugeint::DivMod(hugeint_t lhs, hugeint_t rhs, hugeint_t &remainder) {
258: 	// division by zero not allowed
259: 	D_ASSERT(!(rhs.upper == 0 && rhs.lower == 0));
260: 
261: 	bool lhs_negative = lhs.upper < 0;
262: 	bool rhs_negative = rhs.upper < 0;
263: 	if (lhs_negative) {
264: 		Hugeint::NegateInPlace(lhs);
265: 	}
266: 	if (rhs_negative) {
267: 		Hugeint::NegateInPlace(rhs);
268: 	}
269: 	// DivMod code adapted from:
270: 	// https://github.com/calccrypto/uint128_t/blob/master/uint128_t.cpp
271: 
272: 	// initialize the result and remainder to 0
273: 	hugeint_t div_result;
274: 	div_result.lower = 0;
275: 	div_result.upper = 0;
276: 	remainder.lower = 0;
277: 	remainder.upper = 0;
278: 
279: 	uint8_t highest_bit_set = PositiveHugeintHighestBit(lhs);
280: 	// now iterate over the amount of bits that are set in the LHS
281: 	for (uint8_t x = highest_bit_set; x > 0; x--) {
282: 		// left-shift the current result and remainder by 1
283: 		div_result = PositiveHugeintLeftShift(div_result, 1);
284: 		remainder = PositiveHugeintLeftShift(remainder, 1);
285: 
286: 		// we get the value of the bit at position X, where position 0 is the least-significant bit
287: 		if (PositiveHugeintIsBitSet(lhs, x - 1)) {
288: 			// increment the remainder
289: 			Hugeint::AddInPlace(remainder, 1);
290: 		}
291: 		if (Hugeint::GreaterThanEquals(remainder, rhs)) {
292: 			// the remainder has passed the division multiplier: add one to the divide result
293: 			remainder = Hugeint::Subtract(remainder, rhs);
294: 			Hugeint::AddInPlace(div_result, 1);
295: 		}
296: 	}
297: 	if (lhs_negative ^ rhs_negative) {
298: 		Hugeint::NegateInPlace(div_result);
299: 	}
300: 	if (lhs_negative) {
301: 		Hugeint::NegateInPlace(remainder);
302: 	}
303: 	return div_result;
304: }
305: 
306: hugeint_t Hugeint::Divide(hugeint_t lhs, hugeint_t rhs) {
307: 	hugeint_t remainder;
308: 	return Hugeint::DivMod(lhs, rhs, remainder);
309: }
310: 
311: hugeint_t Hugeint::Modulo(hugeint_t lhs, hugeint_t rhs) {
312: 	hugeint_t remainder;
313: 	Hugeint::DivMod(lhs, rhs, remainder);
314: 	return remainder;
315: }
316: 
317: //===--------------------------------------------------------------------===//
318: // Add/Subtract
319: //===--------------------------------------------------------------------===//
320: bool Hugeint::AddInPlace(hugeint_t &lhs, hugeint_t rhs) {
321: 	int overflow = lhs.lower + rhs.lower < lhs.lower;
322: 	if (rhs.upper >= 0) {
323: 		// RHS is positive: check for overflow
324: 		if (lhs.upper > (std::numeric_limits<int64_t>::max() - rhs.upper - overflow)) {
325: 			return false;
326: 		}
327: 		lhs.upper = lhs.upper + overflow + rhs.upper;
328: 	} else {
329: 		// RHS is negative: check for underflow
330: 		if (lhs.upper < std::numeric_limits<int64_t>::min() - rhs.upper - overflow) {
331: 			return false;
332: 		}
333: 		lhs.upper = lhs.upper + (overflow + rhs.upper);
334: 	}
335: 	lhs.lower += rhs.lower;
336: 	if (lhs.upper == std::numeric_limits<int64_t>::min() && lhs.lower == 0) {
337: 		return false;
338: 	}
339: 	return true;
340: }
341: 
342: bool Hugeint::SubtractInPlace(hugeint_t &lhs, hugeint_t rhs) {
343: 	// underflow
344: 	int underflow = lhs.lower - rhs.lower > lhs.lower;
345: 	if (rhs.upper >= 0) {
346: 		// RHS is positive: check for underflow
347: 		if (lhs.upper < (std::numeric_limits<int64_t>::min() + rhs.upper + underflow)) {
348: 			return false;
349: 		}
350: 		lhs.upper = (lhs.upper - rhs.upper) - underflow;
351: 	} else {
352: 		// RHS is negative: check for overflow
353: 		if (lhs.upper > std::numeric_limits<int64_t>::min() &&
354: 		    lhs.upper - 1 >= (std::numeric_limits<int64_t>::max() + rhs.upper + underflow)) {
355: 			return false;
356: 		}
357: 		lhs.upper = lhs.upper - (rhs.upper + underflow);
358: 	}
359: 	lhs.lower -= rhs.lower;
360: 	if (lhs.upper == std::numeric_limits<int64_t>::min() && lhs.lower == 0) {
361: 		return false;
362: 	}
363: 	return true;
364: }
365: 
366: hugeint_t Hugeint::Add(hugeint_t lhs, hugeint_t rhs) {
367: 	if (!AddInPlace(lhs, rhs)) {
368: 		throw OutOfRangeException("Overflow in HUGEINT addition");
369: 	}
370: 	return lhs;
371: }
372: 
373: hugeint_t Hugeint::Subtract(hugeint_t lhs, hugeint_t rhs) {
374: 	if (!SubtractInPlace(lhs, rhs)) {
375: 		throw OutOfRangeException("Underflow in HUGEINT addition");
376: 	}
377: 	return lhs;
378: }
379: 
380: //===--------------------------------------------------------------------===//
381: // Hugeint Cast/Conversion
382: //===--------------------------------------------------------------------===//
383: template <class DST, bool SIGNED = true>
384: bool HugeintTryCastInteger(hugeint_t input, DST &result) {
385: 	switch (input.upper) {
386: 	case 0:
387: 		// positive number: check if the positive number is in range
388: 		if (input.lower <= uint64_t(NumericLimits<DST>::Maximum())) {
389: 			result = DST(input.lower);
390: 			return true;
391: 		}
392: 		break;
393: 	case -1:
394: 		if (!SIGNED) {
395: 			return false;
396: 		}
397: 		// negative number: check if the negative number is in range
398: 		if (input.lower >= NumericLimits<uint64_t>::Maximum() - uint64_t(NumericLimits<DST>::Maximum())) {
399: 			result = -DST(NumericLimits<uint64_t>::Maximum() - input.lower) - 1;
400: 			return true;
401: 		}
402: 		break;
403: 	default:
404: 		break;
405: 	}
406: 	return false;
407: }
408: 
409: template <>
410: bool Hugeint::TryCast(hugeint_t input, int8_t &result) {
411: 	return HugeintTryCastInteger<int8_t>(input, result);
412: }
413: 
414: template <>
415: bool Hugeint::TryCast(hugeint_t input, int16_t &result) {
416: 	return HugeintTryCastInteger<int16_t>(input, result);
417: }
418: 
419: template <>
420: bool Hugeint::TryCast(hugeint_t input, int32_t &result) {
421: 	return HugeintTryCastInteger<int32_t>(input, result);
422: }
423: 
424: template <>
425: bool Hugeint::TryCast(hugeint_t input, int64_t &result) {
426: 	return HugeintTryCastInteger<int64_t>(input, result);
427: }
428: 
429: template <>
430: bool Hugeint::TryCast(hugeint_t input, uint8_t &result) {
431: 	return HugeintTryCastInteger<uint8_t, false>(input, result);
432: }
433: 
434: template <>
435: bool Hugeint::TryCast(hugeint_t input, uint16_t &result) {
436: 	return HugeintTryCastInteger<uint16_t, false>(input, result);
437: }
438: 
439: template <>
440: bool Hugeint::TryCast(hugeint_t input, uint32_t &result) {
441: 	return HugeintTryCastInteger<uint32_t, false>(input, result);
442: }
443: 
444: template <>
445: bool Hugeint::TryCast(hugeint_t input, uint64_t &result) {
446: 	return HugeintTryCastInteger<uint64_t, false>(input, result);
447: }
448: 
449: template <>
450: bool Hugeint::TryCast(hugeint_t input, hugeint_t &result) {
451: 	result = input;
452: 	return true;
453: }
454: 
455: template <>
456: bool Hugeint::TryCast(hugeint_t input, float &result) {
457: 	double dbl_result;
458: 	Hugeint::TryCast(input, dbl_result);
459: 	result = (float)dbl_result;
460: 	return true;
461: }
462: 
463: template <class REAL_T>
464: bool CastBigintToFloating(hugeint_t input, REAL_T &result) {
465: 	switch (input.upper) {
466: 	case -1:
467: 		// special case for upper = -1 to avoid rounding issues in small negative numbers
468: 		result = -REAL_T(NumericLimits<uint64_t>::Maximum() - input.lower) - 1;
469: 		break;
470: 	default:
471: 		result = REAL_T(input.lower) + REAL_T(input.upper) * REAL_T(NumericLimits<uint64_t>::Maximum());
472: 		break;
473: 	}
474: 	return true;
475: }
476: 
477: template <>
478: bool Hugeint::TryCast(hugeint_t input, double &result) {
479: 	return CastBigintToFloating<double>(input, result);
480: }
481: 
482: template <>
483: bool Hugeint::TryCast(hugeint_t input, long double &result) {
484: 	return CastBigintToFloating<long double>(input, result);
485: }
486: 
487: template <class DST>
488: hugeint_t HugeintConvertInteger(DST input) {
489: 	hugeint_t result;
490: 	result.lower = (uint64_t)input;
491: 	result.upper = (input < 0) * -1;
492: 	return result;
493: }
494: 
495: template <>
496: bool Hugeint::TryConvert(int8_t value, hugeint_t &result) {
497: 	result = HugeintConvertInteger<int8_t>(value);
498: 	return true;
499: }
500: 
501: template <>
502: bool Hugeint::TryConvert(int16_t value, hugeint_t &result) {
503: 	result = HugeintConvertInteger<int16_t>(value);
504: 	return true;
505: }
506: 
507: template <>
508: bool Hugeint::TryConvert(int32_t value, hugeint_t &result) {
509: 	result = HugeintConvertInteger<int32_t>(value);
510: 	return true;
511: }
512: 
513: template <>
514: bool Hugeint::TryConvert(int64_t value, hugeint_t &result) {
515: 	result = HugeintConvertInteger<int64_t>(value);
516: 	return true;
517: }
518: template <>
519: bool Hugeint::TryConvert(uint8_t value, hugeint_t &result) {
520: 	result = HugeintConvertInteger<uint8_t>(value);
521: 	return true;
522: }
523: template <>
524: bool Hugeint::TryConvert(uint16_t value, hugeint_t &result) {
525: 	result = HugeintConvertInteger<uint16_t>(value);
526: 	return true;
527: }
528: template <>
529: bool Hugeint::TryConvert(uint32_t value, hugeint_t &result) {
530: 	result = HugeintConvertInteger<uint32_t>(value);
531: 	return true;
532: }
533: template <>
534: bool Hugeint::TryConvert(uint64_t value, hugeint_t &result) {
535: 	result = HugeintConvertInteger<uint64_t>(value);
536: 	return true;
537: }
538: 
539: template <>
540: bool Hugeint::TryConvert(float value, hugeint_t &result) {
541: 	return Hugeint::TryConvert(double(value), result);
542: }
543: 
544: template <class REAL_T>
545: bool ConvertFloatingToBigint(REAL_T value, hugeint_t &result) {
546: 	if (value <= -170141183460469231731687303715884105728.0 || value >= 170141183460469231731687303715884105727.0) {
547: 		return false;
548: 	}
549: 	bool negative = value < 0;
550: 	if (negative) {
551: 		value = -value;
552: 	}
553: 	result.lower = (uint64_t)fmod(value, REAL_T(NumericLimits<uint64_t>::Maximum()));
554: 	result.upper = (uint64_t)(value / REAL_T(NumericLimits<uint64_t>::Maximum()));
555: 	if (negative) {
556: 		Hugeint::NegateInPlace(result);
557: 	}
558: 	return true;
559: }
560: 
561: template <>
562: bool Hugeint::TryConvert(double value, hugeint_t &result) {
563: 	return ConvertFloatingToBigint<double>(value, result);
564: }
565: 
566: template <>
567: bool Hugeint::TryConvert(long double value, hugeint_t &result) {
568: 	return ConvertFloatingToBigint<long double>(value, result);
569: }
570: 
571: //===--------------------------------------------------------------------===//
572: // hugeint_t operators
573: //===--------------------------------------------------------------------===//
574: hugeint_t::hugeint_t(int64_t value) {
575: 	auto result = Hugeint::Convert(value);
576: 	this->lower = result.lower;
577: 	this->upper = result.upper;
578: }
579: 
580: bool hugeint_t::operator==(const hugeint_t &rhs) const {
581: 	return Hugeint::Equals(*this, rhs);
582: }
583: 
584: bool hugeint_t::operator!=(const hugeint_t &rhs) const {
585: 	return Hugeint::NotEquals(*this, rhs);
586: }
587: 
588: bool hugeint_t::operator<(const hugeint_t &rhs) const {
589: 	return Hugeint::LessThan(*this, rhs);
590: }
591: 
592: bool hugeint_t::operator<=(const hugeint_t &rhs) const {
593: 	return Hugeint::LessThanEquals(*this, rhs);
594: }
595: 
596: bool hugeint_t::operator>(const hugeint_t &rhs) const {
597: 	return Hugeint::GreaterThan(*this, rhs);
598: }
599: 
600: bool hugeint_t::operator>=(const hugeint_t &rhs) const {
601: 	return Hugeint::GreaterThanEquals(*this, rhs);
602: }
603: 
604: hugeint_t hugeint_t::operator+(const hugeint_t &rhs) const {
605: 	return Hugeint::Add(*this, rhs);
606: }
607: 
608: hugeint_t hugeint_t::operator-(const hugeint_t &rhs) const {
609: 	return Hugeint::Subtract(*this, rhs);
610: }
611: 
612: hugeint_t hugeint_t::operator*(const hugeint_t &rhs) const {
613: 	return Hugeint::Multiply(*this, rhs);
614: }
615: 
616: hugeint_t hugeint_t::operator/(const hugeint_t &rhs) const {
617: 	return Hugeint::Divide(*this, rhs);
618: }
619: 
620: hugeint_t hugeint_t::operator%(const hugeint_t &rhs) const {
621: 	return Hugeint::Modulo(*this, rhs);
622: }
623: 
624: hugeint_t hugeint_t::operator-() const {
625: 	return Hugeint::Negate(*this);
626: }
627: 
628: hugeint_t hugeint_t::operator>>(const hugeint_t &rhs) const {
629: 	if (upper < 0) {
630: 		return hugeint_t(0);
631: 	}
632: 	hugeint_t result;
633: 	uint64_t shift = rhs.lower;
634: 	if (rhs.upper != 0 || shift >= 128) {
635: 		return hugeint_t(0);
636: 	} else if (shift == 64) {
637: 		result.upper = 0;
638: 		result.lower = upper;
639: 	} else if (shift == 0) {
640: 		return *this;
641: 	} else if (shift < 64) {
642: 		// perform upper shift in unsigned integer, and mask away the most significant bit
643: 		result.lower = (uint64_t(upper) << (64 - shift)) + (lower >> shift);
644: 		result.upper = uint64_t(upper) >> shift;
645: 	} else {
646: 		D_ASSERT(shift < 128);
647: 		result.lower = uint64_t(upper) >> (shift - 64);
648: 		result.upper = 0;
649: 	}
650: 	return result;
651: }
652: 
653: hugeint_t hugeint_t::operator<<(const hugeint_t &rhs) const {
654: 	if (upper < 0) {
655: 		return hugeint_t(0);
656: 	}
657: 	hugeint_t result;
658: 	uint64_t shift = rhs.lower;
659: 	if (rhs.upper != 0 || shift >= 128) {
660: 		return hugeint_t(0);
661: 	} else if (shift == 64) {
662: 		result.upper = lower;
663: 		result.lower = 0;
664: 	} else if (shift == 0) {
665: 		return *this;
666: 	} else if (shift < 64) {
667: 		// perform upper shift in unsigned integer, and mask away the most significant bit
668: 		uint64_t upper_shift = ((uint64_t(upper) << shift) + (lower >> (64 - shift))) & 0x7FFFFFFFFFFFFFFF;
669: 		result.lower = lower << shift;
670: 		result.upper = upper_shift;
671: 	} else {
672: 		D_ASSERT(shift < 128);
673: 		result.lower = 0;
674: 		result.upper = (lower << (shift - 64)) & 0x7FFFFFFFFFFFFFFF;
675: 	}
676: 	return result;
677: }
678: 
679: hugeint_t hugeint_t::operator&(const hugeint_t &rhs) const {
680: 	hugeint_t result;
681: 	result.lower = lower & rhs.lower;
682: 	result.upper = upper & rhs.upper;
683: 	return result;
684: }
685: 
686: hugeint_t hugeint_t::operator|(const hugeint_t &rhs) const {
687: 	hugeint_t result;
688: 	result.lower = lower | rhs.lower;
689: 	result.upper = upper | rhs.upper;
690: 	return result;
691: }
692: 
693: hugeint_t hugeint_t::operator^(const hugeint_t &rhs) const {
694: 	hugeint_t result;
695: 	result.lower = lower ^ rhs.lower;
696: 	result.upper = upper ^ rhs.upper;
697: 	return result;
698: }
699: 
700: hugeint_t hugeint_t::operator~() const {
701: 	hugeint_t result;
702: 	result.lower = ~lower;
703: 	result.upper = ~upper;
704: 	return result;
705: }
706: 
707: hugeint_t &hugeint_t::operator+=(const hugeint_t &rhs) {
708: 	Hugeint::AddInPlace(*this, rhs);
709: 	return *this;
710: }
711: hugeint_t &hugeint_t::operator-=(const hugeint_t &rhs) {
712: 	Hugeint::SubtractInPlace(*this, rhs);
713: 	return *this;
714: }
715: hugeint_t &hugeint_t::operator*=(const hugeint_t &rhs) {
716: 	*this = Hugeint::Multiply(*this, rhs);
717: 	return *this;
718: }
719: hugeint_t &hugeint_t::operator/=(const hugeint_t &rhs) {
720: 	*this = Hugeint::Divide(*this, rhs);
721: 	return *this;
722: }
723: hugeint_t &hugeint_t::operator%=(const hugeint_t &rhs) {
724: 	*this = Hugeint::Modulo(*this, rhs);
725: 	return *this;
726: }
727: hugeint_t &hugeint_t::operator>>=(const hugeint_t &rhs) {
728: 	*this = *this >> rhs;
729: 	return *this;
730: }
731: hugeint_t &hugeint_t::operator<<=(const hugeint_t &rhs) {
732: 	*this = *this << rhs;
733: 	return *this;
734: }
735: hugeint_t &hugeint_t::operator&=(const hugeint_t &rhs) {
736: 	lower &= rhs.lower;
737: 	upper &= rhs.upper;
738: 	return *this;
739: }
740: hugeint_t &hugeint_t::operator|=(const hugeint_t &rhs) {
741: 	lower |= rhs.lower;
742: 	upper |= rhs.upper;
743: 	return *this;
744: }
745: hugeint_t &hugeint_t::operator^=(const hugeint_t &rhs) {
746: 	lower ^= rhs.lower;
747: 	upper ^= rhs.upper;
748: 	return *this;
749: }
750: 
751: string hugeint_t::ToString() const {
752: 	return Hugeint::ToString(*this);
753: }
754: 
755: } // namespace duckdb
[end of src/common/types/hugeint.cpp]
[start of src/common/types/value.cpp]
1: #include <utility>
2: 
3: #include "duckdb/common/types/value.hpp"
4: 
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/common/to_string.hpp"
7: #include "duckdb/common/limits.hpp"
8: #include "duckdb/common/operator/aggregate_operators.hpp"
9: #include "duckdb/common/operator/cast_operators.hpp"
10: #include "duckdb/common/operator/comparison_operators.hpp"
11: 
12: #include "utf8proc_wrapper.hpp"
13: #include "duckdb/common/operator/numeric_binary_operators.hpp"
14: #include "duckdb/common/printer.hpp"
15: #include "duckdb/common/field_writer.hpp"
16: #include "duckdb/common/types/blob.hpp"
17: #include "duckdb/common/types/date.hpp"
18: #include "duckdb/common/types/decimal.hpp"
19: #include "duckdb/common/types/hugeint.hpp"
20: #include "duckdb/common/types/uuid.hpp"
21: #include "duckdb/common/types/interval.hpp"
22: #include "duckdb/common/types/null_value.hpp"
23: #include "duckdb/common/types/time.hpp"
24: #include "duckdb/common/types/timestamp.hpp"
25: #include "duckdb/common/types/vector.hpp"
26: #include "duckdb/common/value_operations/value_operations.hpp"
27: #include "duckdb/common/vector_operations/vector_operations.hpp"
28: #include "duckdb/common/string_util.hpp"
29: #include "duckdb/common/types/cast_helpers.hpp"
30: #include "duckdb/common/types/hash.hpp"
31: 
32: namespace duckdb {
33: 
34: Value::Value(LogicalType type) : type_(move(type)), is_null(true) {
35: }
36: 
37: Value::Value(int32_t val) : type_(LogicalType::INTEGER), is_null(false) {
38: 	value_.integer = val;
39: }
40: 
41: Value::Value(int64_t val) : type_(LogicalType::BIGINT), is_null(false) {
42: 	value_.bigint = val;
43: }
44: 
45: Value::Value(float val) : type_(LogicalType::FLOAT), is_null(false) {
46: 	if (!Value::FloatIsValid(val)) {
47: 		throw OutOfRangeException("Invalid float value %f", val);
48: 	}
49: 	value_.float_ = val;
50: }
51: 
52: Value::Value(double val) : type_(LogicalType::DOUBLE), is_null(false) {
53: 	if (!Value::DoubleIsValid(val)) {
54: 		throw OutOfRangeException("Invalid double value %f", val);
55: 	}
56: 	value_.double_ = val;
57: }
58: 
59: Value::Value(const char *val) : Value(val ? string(val) : string()) {
60: }
61: 
62: Value::Value(std::nullptr_t val) : Value(LogicalType::VARCHAR) {
63: }
64: 
65: Value::Value(string_t val) : Value(string(val.GetDataUnsafe(), val.GetSize())) {
66: }
67: 
68: Value::Value(string val) : type_(LogicalType::VARCHAR), is_null(false), str_value(move(val)) {
69: 	if (!Value::StringIsValid(str_value.c_str(), str_value.size())) {
70: 		throw Exception("String value is not valid UTF8");
71: 	}
72: }
73: 
74: Value::~Value() {
75: }
76: 
77: Value::Value(const Value &other)
78:     : type_(other.type_), is_null(other.is_null), value_(other.value_), str_value(other.str_value),
79:       struct_value(other.struct_value), list_value(other.list_value) {
80: }
81: 
82: Value::Value(Value &&other) noexcept
83:     : type_(move(other.type_)), is_null(other.is_null), value_(other.value_), str_value(move(other.str_value)),
84:       struct_value(move(other.struct_value)), list_value(move(other.list_value)) {
85: }
86: 
87: Value &Value::operator=(const Value &other) {
88: 	type_ = other.type_;
89: 	is_null = other.is_null;
90: 	value_ = other.value_;
91: 	str_value = other.str_value;
92: 	struct_value = other.struct_value;
93: 	list_value = other.list_value;
94: 	return *this;
95: }
96: 
97: Value &Value::operator=(Value &&other) noexcept {
98: 	type_ = move(other.type_);
99: 	is_null = other.is_null;
100: 	value_ = other.value_;
101: 	str_value = move(other.str_value);
102: 	struct_value = move(other.struct_value);
103: 	list_value = move(other.list_value);
104: 	return *this;
105: }
106: 
107: Value Value::MinimumValue(const LogicalType &type) {
108: 	switch (type.id()) {
109: 	case LogicalTypeId::BOOLEAN:
110: 		return Value::BOOLEAN(false);
111: 	case LogicalTypeId::TINYINT:
112: 		return Value::TINYINT(NumericLimits<int8_t>::Minimum());
113: 	case LogicalTypeId::SMALLINT:
114: 		return Value::SMALLINT(NumericLimits<int16_t>::Minimum());
115: 	case LogicalTypeId::INTEGER:
116: 	case LogicalTypeId::SQLNULL:
117: 		return Value::INTEGER(NumericLimits<int32_t>::Minimum());
118: 	case LogicalTypeId::BIGINT:
119: 		return Value::BIGINT(NumericLimits<int64_t>::Minimum());
120: 	case LogicalTypeId::HUGEINT:
121: 		return Value::HUGEINT(NumericLimits<hugeint_t>::Minimum());
122: 	case LogicalTypeId::UUID:
123: 		return Value::UUID(NumericLimits<hugeint_t>::Minimum());
124: 	case LogicalTypeId::UTINYINT:
125: 		return Value::UTINYINT(NumericLimits<uint8_t>::Minimum());
126: 	case LogicalTypeId::USMALLINT:
127: 		return Value::USMALLINT(NumericLimits<uint16_t>::Minimum());
128: 	case LogicalTypeId::UINTEGER:
129: 		return Value::UINTEGER(NumericLimits<uint32_t>::Minimum());
130: 	case LogicalTypeId::UBIGINT:
131: 		return Value::UBIGINT(NumericLimits<uint64_t>::Minimum());
132: 	case LogicalTypeId::DATE:
133: 		return Value::DATE(Date::FromDate(Date::DATE_MIN_YEAR, Date::DATE_MIN_MONTH, Date::DATE_MIN_DAY));
134: 	case LogicalTypeId::TIME:
135: 		return Value::TIME(dtime_t(0));
136: 	case LogicalTypeId::TIMESTAMP:
137: 		return Value::TIMESTAMP(Date::FromDate(Timestamp::MIN_YEAR, Timestamp::MIN_MONTH, Timestamp::MIN_DAY),
138: 		                        dtime_t(0));
139: 	case LogicalTypeId::TIMESTAMP_SEC:
140: 		return MinimumValue(LogicalType::TIMESTAMP).CastAs(LogicalType::TIMESTAMP_S);
141: 	case LogicalTypeId::TIMESTAMP_MS:
142: 		return MinimumValue(LogicalType::TIMESTAMP).CastAs(LogicalType::TIMESTAMP_MS);
143: 	case LogicalTypeId::TIMESTAMP_NS:
144: 		return Value::TIMESTAMPNS(timestamp_t(NumericLimits<int64_t>::Minimum()));
145: 	case LogicalTypeId::TIME_TZ:
146: 		return Value::TIMETZ(dtime_t(0));
147: 	case LogicalTypeId::TIMESTAMP_TZ:
148: 		return Value::TIMESTAMPTZ(Timestamp::FromDatetime(
149: 		    Date::FromDate(Timestamp::MIN_YEAR, Timestamp::MIN_MONTH, Timestamp::MIN_DAY), dtime_t(0)));
150: 	case LogicalTypeId::FLOAT:
151: 		return Value::FLOAT(NumericLimits<float>::Minimum());
152: 	case LogicalTypeId::DOUBLE:
153: 		return Value::DOUBLE(NumericLimits<double>::Minimum());
154: 	case LogicalTypeId::DECIMAL: {
155: 		auto width = DecimalType::GetWidth(type);
156: 		auto scale = DecimalType::GetScale(type);
157: 		switch (type.InternalType()) {
158: 		case PhysicalType::INT16:
159: 			return Value::DECIMAL(int16_t(-NumericHelper::POWERS_OF_TEN[width] + 1), width, scale);
160: 		case PhysicalType::INT32:
161: 			return Value::DECIMAL(int32_t(-NumericHelper::POWERS_OF_TEN[width] + 1), width, scale);
162: 		case PhysicalType::INT64:
163: 			return Value::DECIMAL(int64_t(-NumericHelper::POWERS_OF_TEN[width] + 1), width, scale);
164: 		case PhysicalType::INT128:
165: 			return Value::DECIMAL(-Hugeint::POWERS_OF_TEN[width] + 1, width, scale);
166: 		default:
167: 			throw InternalException("Unknown decimal type");
168: 		}
169: 	}
170: 	case LogicalTypeId::ENUM:
171: 		return Value::ENUM(0, type);
172: 	default:
173: 		throw InvalidTypeException(type, "MinimumValue requires numeric type");
174: 	}
175: }
176: 
177: Value Value::MaximumValue(const LogicalType &type) {
178: 	switch (type.id()) {
179: 	case LogicalTypeId::BOOLEAN:
180: 		return Value::BOOLEAN(true);
181: 	case LogicalTypeId::TINYINT:
182: 		return Value::TINYINT(NumericLimits<int8_t>::Maximum());
183: 	case LogicalTypeId::SMALLINT:
184: 		return Value::SMALLINT(NumericLimits<int16_t>::Maximum());
185: 	case LogicalTypeId::INTEGER:
186: 	case LogicalTypeId::SQLNULL:
187: 		return Value::INTEGER(NumericLimits<int32_t>::Maximum());
188: 	case LogicalTypeId::BIGINT:
189: 		return Value::BIGINT(NumericLimits<int64_t>::Maximum());
190: 	case LogicalTypeId::HUGEINT:
191: 		return Value::HUGEINT(NumericLimits<hugeint_t>::Maximum());
192: 	case LogicalTypeId::UUID:
193: 		return Value::UUID(NumericLimits<hugeint_t>::Maximum());
194: 	case LogicalTypeId::UTINYINT:
195: 		return Value::UTINYINT(NumericLimits<uint8_t>::Maximum());
196: 	case LogicalTypeId::USMALLINT:
197: 		return Value::USMALLINT(NumericLimits<uint16_t>::Maximum());
198: 	case LogicalTypeId::UINTEGER:
199: 		return Value::UINTEGER(NumericLimits<uint32_t>::Maximum());
200: 	case LogicalTypeId::UBIGINT:
201: 		return Value::UBIGINT(NumericLimits<uint64_t>::Maximum());
202: 	case LogicalTypeId::DATE:
203: 		return Value::DATE(Date::FromDate(Date::DATE_MAX_YEAR, Date::DATE_MAX_MONTH, Date::DATE_MAX_DAY));
204: 	case LogicalTypeId::TIME:
205: 		return Value::TIME(dtime_t(Interval::SECS_PER_DAY * Interval::MICROS_PER_SEC - 1));
206: 	case LogicalTypeId::TIMESTAMP:
207: 		return Value::TIMESTAMP(timestamp_t(NumericLimits<int64_t>::Maximum()));
208: 	case LogicalTypeId::TIMESTAMP_MS:
209: 		return MaximumValue(LogicalType::TIMESTAMP).CastAs(LogicalType::TIMESTAMP_MS);
210: 	case LogicalTypeId::TIMESTAMP_NS:
211: 		return Value::TIMESTAMPNS(timestamp_t(NumericLimits<int64_t>::Maximum()));
212: 	case LogicalTypeId::TIMESTAMP_SEC:
213: 		return MaximumValue(LogicalType::TIMESTAMP).CastAs(LogicalType::TIMESTAMP_S);
214: 	case LogicalTypeId::TIME_TZ:
215: 		return Value::TIMETZ(dtime_t(Interval::SECS_PER_DAY * Interval::MICROS_PER_SEC - 1));
216: 	case LogicalTypeId::TIMESTAMP_TZ:
217: 		return Value::TIMESTAMPTZ(timestamp_t(NumericLimits<int64_t>::Maximum()));
218: 	case LogicalTypeId::FLOAT:
219: 		return Value::FLOAT(NumericLimits<float>::Maximum());
220: 	case LogicalTypeId::DOUBLE:
221: 		return Value::DOUBLE(NumericLimits<double>::Maximum());
222: 	case LogicalTypeId::DECIMAL: {
223: 		auto width = DecimalType::GetWidth(type);
224: 		auto scale = DecimalType::GetScale(type);
225: 		switch (type.InternalType()) {
226: 		case PhysicalType::INT16:
227: 			return Value::DECIMAL(int16_t(NumericHelper::POWERS_OF_TEN[width] - 1), width, scale);
228: 		case PhysicalType::INT32:
229: 			return Value::DECIMAL(int32_t(NumericHelper::POWERS_OF_TEN[width] - 1), width, scale);
230: 		case PhysicalType::INT64:
231: 			return Value::DECIMAL(int64_t(NumericHelper::POWERS_OF_TEN[width] - 1), width, scale);
232: 		case PhysicalType::INT128:
233: 			return Value::DECIMAL(Hugeint::POWERS_OF_TEN[width] - 1, width, scale);
234: 		default:
235: 			throw InternalException("Unknown decimal type");
236: 		}
237: 	}
238: 	case LogicalTypeId::ENUM:
239: 		return Value::ENUM(EnumType::GetSize(type) - 1, type);
240: 	default:
241: 		throw InvalidTypeException(type, "MaximumValue requires numeric type");
242: 	}
243: }
244: 
245: Value Value::BOOLEAN(int8_t value) {
246: 	Value result(LogicalType::BOOLEAN);
247: 	result.value_.boolean = value ? true : false;
248: 	result.is_null = false;
249: 	return result;
250: }
251: 
252: Value Value::TINYINT(int8_t value) {
253: 	Value result(LogicalType::TINYINT);
254: 	result.value_.tinyint = value;
255: 	result.is_null = false;
256: 	return result;
257: }
258: 
259: Value Value::SMALLINT(int16_t value) {
260: 	Value result(LogicalType::SMALLINT);
261: 	result.value_.smallint = value;
262: 	result.is_null = false;
263: 	return result;
264: }
265: 
266: Value Value::INTEGER(int32_t value) {
267: 	Value result(LogicalType::INTEGER);
268: 	result.value_.integer = value;
269: 	result.is_null = false;
270: 	return result;
271: }
272: 
273: Value Value::BIGINT(int64_t value) {
274: 	Value result(LogicalType::BIGINT);
275: 	result.value_.bigint = value;
276: 	result.is_null = false;
277: 	return result;
278: }
279: 
280: Value Value::HUGEINT(hugeint_t value) {
281: 	Value result(LogicalType::HUGEINT);
282: 	result.value_.hugeint = value;
283: 	result.is_null = false;
284: 	return result;
285: }
286: 
287: Value Value::UUID(hugeint_t value) {
288: 	Value result(LogicalType::UUID);
289: 	result.value_.hugeint = value;
290: 	result.is_null = false;
291: 	return result;
292: }
293: 
294: Value Value::UUID(const string &value) {
295: 	Value result(LogicalType::UUID);
296: 	result.value_.hugeint = UUID::FromString(value);
297: 	result.is_null = false;
298: 	return result;
299: }
300: 
301: Value Value::UTINYINT(uint8_t value) {
302: 	Value result(LogicalType::UTINYINT);
303: 	result.value_.utinyint = value;
304: 	result.is_null = false;
305: 	return result;
306: }
307: 
308: Value Value::USMALLINT(uint16_t value) {
309: 	Value result(LogicalType::USMALLINT);
310: 	result.value_.usmallint = value;
311: 	result.is_null = false;
312: 	return result;
313: }
314: 
315: Value Value::UINTEGER(uint32_t value) {
316: 	Value result(LogicalType::UINTEGER);
317: 	result.value_.uinteger = value;
318: 	result.is_null = false;
319: 	return result;
320: }
321: 
322: Value Value::UBIGINT(uint64_t value) {
323: 	Value result(LogicalType::UBIGINT);
324: 	result.value_.ubigint = value;
325: 	result.is_null = false;
326: 	return result;
327: }
328: 
329: bool Value::FloatIsValid(float value) {
330: 	return !(std::isnan(value) || std::isinf(value));
331: }
332: 
333: bool Value::DoubleIsValid(double value) {
334: 	return !(std::isnan(value) || std::isinf(value));
335: }
336: 
337: bool Value::StringIsValid(const char *str, idx_t length) {
338: 	auto utf_type = Utf8Proc::Analyze(str, length);
339: 	return utf_type != UnicodeType::INVALID;
340: }
341: 
342: Value Value::DECIMAL(int16_t value, uint8_t width, uint8_t scale) {
343: 	D_ASSERT(width <= Decimal::MAX_WIDTH_INT16);
344: 	Value result(LogicalType::DECIMAL(width, scale));
345: 	result.value_.smallint = value;
346: 	result.is_null = false;
347: 	return result;
348: }
349: 
350: Value Value::DECIMAL(int32_t value, uint8_t width, uint8_t scale) {
351: 	D_ASSERT(width >= Decimal::MAX_WIDTH_INT16 && width <= Decimal::MAX_WIDTH_INT32);
352: 	Value result(LogicalType::DECIMAL(width, scale));
353: 	result.value_.integer = value;
354: 	result.is_null = false;
355: 	return result;
356: }
357: 
358: Value Value::DECIMAL(int64_t value, uint8_t width, uint8_t scale) {
359: 	auto decimal_type = LogicalType::DECIMAL(width, scale);
360: 	Value result(decimal_type);
361: 	switch (decimal_type.InternalType()) {
362: 	case PhysicalType::INT16:
363: 		result.value_.smallint = value;
364: 		break;
365: 	case PhysicalType::INT32:
366: 		result.value_.integer = value;
367: 		break;
368: 	case PhysicalType::INT64:
369: 		result.value_.bigint = value;
370: 		break;
371: 	default:
372: 		result.value_.hugeint = value;
373: 		break;
374: 	}
375: 	result.type_.Verify();
376: 	result.is_null = false;
377: 	return result;
378: }
379: 
380: Value Value::DECIMAL(hugeint_t value, uint8_t width, uint8_t scale) {
381: 	D_ASSERT(width >= Decimal::MAX_WIDTH_INT64 && width <= Decimal::MAX_WIDTH_INT128);
382: 	Value result(LogicalType::DECIMAL(width, scale));
383: 	result.value_.hugeint = value;
384: 	result.is_null = false;
385: 	return result;
386: }
387: 
388: Value Value::FLOAT(float value) {
389: 	if (!Value::FloatIsValid(value)) {
390: 		throw OutOfRangeException("Invalid float value %f", value);
391: 	}
392: 	Value result(LogicalType::FLOAT);
393: 	result.value_.float_ = value;
394: 	result.is_null = false;
395: 	return result;
396: }
397: 
398: Value Value::DOUBLE(double value) {
399: 	if (!Value::DoubleIsValid(value)) {
400: 		throw OutOfRangeException("Invalid double value %f", value);
401: 	}
402: 	Value result(LogicalType::DOUBLE);
403: 	result.value_.double_ = value;
404: 	result.is_null = false;
405: 	return result;
406: }
407: 
408: Value Value::HASH(hash_t value) {
409: 	Value result(LogicalType::HASH);
410: 	result.value_.hash = value;
411: 	result.is_null = false;
412: 	return result;
413: }
414: 
415: Value Value::POINTER(uintptr_t value) {
416: 	Value result(LogicalType::POINTER);
417: 	result.value_.pointer = value;
418: 	result.is_null = false;
419: 	return result;
420: }
421: 
422: Value Value::DATE(date_t value) {
423: 	Value result(LogicalType::DATE);
424: 	result.value_.date = value;
425: 	result.is_null = false;
426: 	return result;
427: }
428: 
429: Value Value::DATE(int32_t year, int32_t month, int32_t day) {
430: 	return Value::DATE(Date::FromDate(year, month, day));
431: }
432: 
433: Value Value::TIME(dtime_t value) {
434: 	Value result(LogicalType::TIME);
435: 	result.value_.time = value;
436: 	result.is_null = false;
437: 	return result;
438: }
439: 
440: Value Value::TIMETZ(dtime_t value) {
441: 	Value result(LogicalType::TIME_TZ);
442: 	result.value_.time = value;
443: 	result.is_null = false;
444: 	return result;
445: }
446: 
447: Value Value::TIME(int32_t hour, int32_t min, int32_t sec, int32_t micros) {
448: 	return Value::TIME(Time::FromTime(hour, min, sec, micros));
449: }
450: 
451: Value Value::TIMESTAMP(timestamp_t value) {
452: 	Value result(LogicalType::TIMESTAMP);
453: 	result.value_.timestamp = value;
454: 	result.is_null = false;
455: 	return result;
456: }
457: 
458: Value Value::TIMESTAMPTZ(timestamp_t value) {
459: 	Value result(LogicalType::TIMESTAMP_TZ);
460: 	result.value_.timestamp = value;
461: 	result.is_null = false;
462: 	return result;
463: }
464: 
465: Value Value::TIMESTAMPNS(timestamp_t timestamp) {
466: 	Value result(LogicalType::TIMESTAMP_NS);
467: 	result.value_.timestamp = timestamp;
468: 	result.is_null = false;
469: 	return result;
470: }
471: 
472: Value Value::TIMESTAMPMS(timestamp_t timestamp) {
473: 	Value result(LogicalType::TIMESTAMP_MS);
474: 	result.value_.timestamp = timestamp;
475: 	result.is_null = false;
476: 	return result;
477: }
478: 
479: Value Value::TIMESTAMPSEC(timestamp_t timestamp) {
480: 	Value result(LogicalType::TIMESTAMP_S);
481: 	result.value_.timestamp = timestamp;
482: 	result.is_null = false;
483: 	return result;
484: }
485: 
486: Value Value::TIMESTAMP(date_t date, dtime_t time) {
487: 	return Value::TIMESTAMP(Timestamp::FromDatetime(date, time));
488: }
489: 
490: Value Value::TIMESTAMP(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t min, int32_t sec,
491:                        int32_t micros) {
492: 	auto val = Value::TIMESTAMP(Date::FromDate(year, month, day), Time::FromTime(hour, min, sec, micros));
493: 	val.type_ = LogicalType::TIMESTAMP;
494: 	return val;
495: }
496: 
497: Value Value::STRUCT(child_list_t<Value> values) {
498: 	Value result;
499: 	child_list_t<LogicalType> child_types;
500: 	for (auto &child : values) {
501: 		child_types.push_back(make_pair(move(child.first), child.second.type()));
502: 		result.struct_value.push_back(move(child.second));
503: 	}
504: 	result.type_ = LogicalType::STRUCT(move(child_types));
505: 
506: 	result.is_null = false;
507: 	return result;
508: }
509: 
510: Value Value::MAP(Value key, Value value) {
511: 	Value result;
512: 	child_list_t<LogicalType> child_types;
513: 	child_types.push_back({"key", key.type()});
514: 	child_types.push_back({"value", value.type()});
515: 
516: 	result.type_ = LogicalType::MAP(move(child_types));
517: 
518: 	result.struct_value.push_back(move(key));
519: 	result.struct_value.push_back(move(value));
520: 	result.is_null = false;
521: 	return result;
522: }
523: 
524: Value Value::LIST(vector<Value> values) {
525: 	if (values.empty()) {
526: 		throw InternalException("Value::LIST requires a non-empty list of values. Use Value::EMPTYLIST instead.");
527: 	}
528: #ifdef DEBUG
529: 	for (idx_t i = 1; i < values.size(); i++) {
530: 		D_ASSERT(values[i].type() == values[0].type());
531: 	}
532: #endif
533: 	Value result;
534: 	result.type_ = LogicalType::LIST(values[0].type());
535: 	result.list_value = move(values);
536: 	result.is_null = false;
537: 	return result;
538: }
539: 
540: Value Value::LIST(LogicalType child_type, vector<Value> values) {
541: 	if (values.empty()) {
542: 		return Value::EMPTYLIST(move(child_type));
543: 	}
544: 	for (auto &val : values) {
545: 		val = val.CastAs(child_type);
546: 	}
547: 	return Value::LIST(move(values));
548: }
549: 
550: Value Value::EMPTYLIST(LogicalType child_type) {
551: 	Value result;
552: 	result.type_ = LogicalType::LIST(move(child_type));
553: 	result.is_null = false;
554: 	return result;
555: }
556: 
557: Value Value::BLOB(const_data_ptr_t data, idx_t len) {
558: 	Value result(LogicalType::BLOB);
559: 	result.is_null = false;
560: 	result.str_value = string((const char *)data, len);
561: 	return result;
562: }
563: 
564: Value Value::BLOB(const string &data) {
565: 	Value result(LogicalType::BLOB);
566: 	result.is_null = false;
567: 	result.str_value = Blob::ToBlob(string_t(data));
568: 	return result;
569: }
570: 
571: Value Value::JSON(const char *val) {
572: 	auto result = Value(val);
573: 	result.type_ = LogicalTypeId::JSON;
574: 	return result;
575: }
576: 
577: Value Value::JSON(string_t val) {
578: 	auto result = Value(val);
579: 	result.type_ = LogicalTypeId::JSON;
580: 	return result;
581: }
582: 
583: Value Value::JSON(string val) {
584: 	auto result = Value(move(val));
585: 	result.type_ = LogicalTypeId::JSON;
586: 	return result;
587: }
588: 
589: Value Value::ENUM(uint64_t value, const LogicalType &original_type) {
590: 	D_ASSERT(original_type.id() == LogicalTypeId::ENUM);
591: 	Value result(original_type);
592: 	switch (original_type.InternalType()) {
593: 	case PhysicalType::UINT8:
594: 		result.value_.utinyint = value;
595: 		break;
596: 	case PhysicalType::UINT16:
597: 		result.value_.usmallint = value;
598: 		break;
599: 	case PhysicalType::UINT32:
600: 		result.value_.uinteger = value;
601: 		break;
602: 	default:
603: 		throw InternalException("Incorrect Physical Type for ENUM");
604: 	}
605: 	result.is_null = false;
606: 	return result;
607: }
608: 
609: Value Value::INTERVAL(int32_t months, int32_t days, int64_t micros) {
610: 	Value result(LogicalType::INTERVAL);
611: 	result.is_null = false;
612: 	result.value_.interval.months = months;
613: 	result.value_.interval.days = days;
614: 	result.value_.interval.micros = micros;
615: 	return result;
616: }
617: 
618: Value Value::INTERVAL(interval_t interval) {
619: 	return Value::INTERVAL(interval.months, interval.days, interval.micros);
620: }
621: 
622: //===--------------------------------------------------------------------===//
623: // CreateValue
624: //===--------------------------------------------------------------------===//
625: template <>
626: Value Value::CreateValue(bool value) {
627: 	return Value::BOOLEAN(value);
628: }
629: 
630: template <>
631: Value Value::CreateValue(int8_t value) {
632: 	return Value::TINYINT(value);
633: }
634: 
635: template <>
636: Value Value::CreateValue(int16_t value) {
637: 	return Value::SMALLINT(value);
638: }
639: 
640: template <>
641: Value Value::CreateValue(int32_t value) {
642: 	return Value::INTEGER(value);
643: }
644: 
645: template <>
646: Value Value::CreateValue(int64_t value) {
647: 	return Value::BIGINT(value);
648: }
649: 
650: template <>
651: Value Value::CreateValue(uint8_t value) {
652: 	return Value::UTINYINT(value);
653: }
654: 
655: template <>
656: Value Value::CreateValue(uint16_t value) {
657: 	return Value::USMALLINT(value);
658: }
659: 
660: template <>
661: Value Value::CreateValue(uint32_t value) {
662: 	return Value::UINTEGER(value);
663: }
664: 
665: template <>
666: Value Value::CreateValue(uint64_t value) {
667: 	return Value::UBIGINT(value);
668: }
669: 
670: template <>
671: Value Value::CreateValue(hugeint_t value) {
672: 	return Value::HUGEINT(value);
673: }
674: 
675: template <>
676: Value Value::CreateValue(date_t value) {
677: 	return Value::DATE(value);
678: }
679: 
680: template <>
681: Value Value::CreateValue(dtime_t value) {
682: 	return Value::TIME(value);
683: }
684: 
685: template <>
686: Value Value::CreateValue(timestamp_t value) {
687: 	return Value::TIMESTAMP(value);
688: }
689: 
690: template <>
691: Value Value::CreateValue(const char *value) {
692: 	return Value(string(value));
693: }
694: 
695: template <>
696: Value Value::CreateValue(string value) { // NOLINT: required for templating
697: 	return Value::BLOB(value);
698: }
699: 
700: template <>
701: Value Value::CreateValue(string_t value) {
702: 	return Value(value);
703: }
704: 
705: template <>
706: Value Value::CreateValue(float value) {
707: 	return Value::FLOAT(value);
708: }
709: 
710: template <>
711: Value Value::CreateValue(double value) {
712: 	return Value::DOUBLE(value);
713: }
714: 
715: template <>
716: Value Value::CreateValue(interval_t value) {
717: 	return Value::INTERVAL(value);
718: }
719: 
720: template <>
721: Value Value::CreateValue(Value value) {
722: 	return value;
723: }
724: 
725: //===--------------------------------------------------------------------===//
726: // GetValue
727: //===--------------------------------------------------------------------===//
728: template <class T>
729: T Value::GetValueInternal() const {
730: 	if (IsNull()) {
731: 		return NullValue<T>();
732: 	}
733: 	switch (type_.id()) {
734: 	case LogicalTypeId::BOOLEAN:
735: 		return Cast::Operation<bool, T>(value_.boolean);
736: 	case LogicalTypeId::TINYINT:
737: 		return Cast::Operation<int8_t, T>(value_.tinyint);
738: 	case LogicalTypeId::SMALLINT:
739: 		return Cast::Operation<int16_t, T>(value_.smallint);
740: 	case LogicalTypeId::INTEGER:
741: 		return Cast::Operation<int32_t, T>(value_.integer);
742: 	case LogicalTypeId::BIGINT:
743: 		return Cast::Operation<int64_t, T>(value_.bigint);
744: 	case LogicalTypeId::HUGEINT:
745: 	case LogicalTypeId::UUID:
746: 		return Cast::Operation<hugeint_t, T>(value_.hugeint);
747: 	case LogicalTypeId::DATE:
748: 		return Cast::Operation<date_t, T>(value_.date);
749: 	case LogicalTypeId::TIME:
750: 	case LogicalTypeId::TIME_TZ:
751: 		return Cast::Operation<dtime_t, T>(value_.time);
752: 	case LogicalTypeId::TIMESTAMP:
753: 	case LogicalTypeId::TIMESTAMP_TZ:
754: 		return Cast::Operation<timestamp_t, T>(value_.timestamp);
755: 	case LogicalTypeId::UTINYINT:
756: 		return Cast::Operation<uint8_t, T>(value_.utinyint);
757: 	case LogicalTypeId::USMALLINT:
758: 		return Cast::Operation<uint16_t, T>(value_.usmallint);
759: 	case LogicalTypeId::UINTEGER:
760: 		return Cast::Operation<uint32_t, T>(value_.uinteger);
761: 	case LogicalTypeId::TIMESTAMP_MS:
762: 	case LogicalTypeId::TIMESTAMP_NS:
763: 	case LogicalTypeId::TIMESTAMP_SEC:
764: 	case LogicalTypeId::UBIGINT:
765: 		return Cast::Operation<uint64_t, T>(value_.ubigint);
766: 	case LogicalTypeId::FLOAT:
767: 		return Cast::Operation<float, T>(value_.float_);
768: 	case LogicalTypeId::DOUBLE:
769: 		return Cast::Operation<double, T>(value_.double_);
770: 	case LogicalTypeId::VARCHAR:
771: 		return Cast::Operation<string_t, T>(str_value.c_str());
772: 	case LogicalTypeId::INTERVAL:
773: 		return Cast::Operation<interval_t, T>(value_.interval);
774: 	case LogicalTypeId::DECIMAL:
775: 		return CastAs(LogicalType::DOUBLE).GetValueInternal<T>();
776: 	case LogicalTypeId::ENUM: {
777: 		switch (type_.InternalType()) {
778: 		case PhysicalType::UINT8:
779: 			return Cast::Operation<uint8_t, T>(value_.utinyint);
780: 		case PhysicalType::UINT16:
781: 			return Cast::Operation<uint16_t, T>(value_.usmallint);
782: 		case PhysicalType::UINT32:
783: 			return Cast::Operation<uint32_t, T>(value_.uinteger);
784: 		default:
785: 			throw InternalException("Invalid Internal Type for ENUMs");
786: 		}
787: 	}
788: 
789: 	default:
790: 		throw NotImplementedException("Unimplemented type \"%s\" for GetValue()", type_.ToString());
791: 	}
792: }
793: 
794: template <>
795: bool Value::GetValue() const {
796: 	return GetValueInternal<int8_t>();
797: }
798: template <>
799: int8_t Value::GetValue() const {
800: 	return GetValueInternal<int8_t>();
801: }
802: template <>
803: int16_t Value::GetValue() const {
804: 	return GetValueInternal<int16_t>();
805: }
806: template <>
807: int32_t Value::GetValue() const {
808: 	if (type_.id() == LogicalTypeId::DATE) {
809: 		return value_.integer;
810: 	}
811: 	return GetValueInternal<int32_t>();
812: }
813: template <>
814: int64_t Value::GetValue() const {
815: 	switch (type_.id()) {
816: 	case LogicalTypeId::TIMESTAMP:
817: 	case LogicalTypeId::TIMESTAMP_SEC:
818: 	case LogicalTypeId::TIMESTAMP_NS:
819: 	case LogicalTypeId::TIMESTAMP_MS:
820: 	case LogicalTypeId::TIME:
821: 	case LogicalTypeId::TIME_TZ:
822: 	case LogicalTypeId::TIMESTAMP_TZ:
823: 		return value_.bigint;
824: 	default:
825: 		return GetValueInternal<int64_t>();
826: 	}
827: }
828: template <>
829: hugeint_t Value::GetValue() const {
830: 	return GetValueInternal<hugeint_t>();
831: }
832: template <>
833: uint8_t Value::GetValue() const {
834: 	return GetValueInternal<uint8_t>();
835: }
836: template <>
837: uint16_t Value::GetValue() const {
838: 	return GetValueInternal<uint16_t>();
839: }
840: template <>
841: uint32_t Value::GetValue() const {
842: 	return GetValueInternal<uint32_t>();
843: }
844: template <>
845: uint64_t Value::GetValue() const {
846: 	return GetValueInternal<uint64_t>();
847: }
848: template <>
849: string Value::GetValue() const {
850: 	return ToString();
851: }
852: template <>
853: float Value::GetValue() const {
854: 	return GetValueInternal<float>();
855: }
856: template <>
857: double Value::GetValue() const {
858: 	return GetValueInternal<double>();
859: }
860: template <>
861: date_t Value::GetValue() const {
862: 	return GetValueInternal<date_t>();
863: }
864: template <>
865: dtime_t Value::GetValue() const {
866: 	return GetValueInternal<dtime_t>();
867: }
868: template <>
869: timestamp_t Value::GetValue() const {
870: 	return GetValueInternal<timestamp_t>();
871: }
872: 
873: template <>
874: DUCKDB_API interval_t Value::GetValue() const {
875: 	return GetValueInternal<interval_t>();
876: }
877: 
878: uintptr_t Value::GetPointer() const {
879: 	D_ASSERT(type() == LogicalType::POINTER);
880: 	return value_.pointer;
881: }
882: 
883: Value Value::Numeric(const LogicalType &type, int64_t value) {
884: 	switch (type.id()) {
885: 	case LogicalTypeId::BOOLEAN:
886: 		D_ASSERT(value == 0 || value == 1);
887: 		return Value::BOOLEAN(value ? 1 : 0);
888: 	case LogicalTypeId::TINYINT:
889: 		D_ASSERT(value >= NumericLimits<int8_t>::Minimum() && value <= NumericLimits<int8_t>::Maximum());
890: 		return Value::TINYINT((int8_t)value);
891: 	case LogicalTypeId::SMALLINT:
892: 		D_ASSERT(value >= NumericLimits<int16_t>::Minimum() && value <= NumericLimits<int16_t>::Maximum());
893: 		return Value::SMALLINT((int16_t)value);
894: 	case LogicalTypeId::INTEGER:
895: 		D_ASSERT(value >= NumericLimits<int32_t>::Minimum() && value <= NumericLimits<int32_t>::Maximum());
896: 		return Value::INTEGER((int32_t)value);
897: 	case LogicalTypeId::BIGINT:
898: 		return Value::BIGINT(value);
899: 	case LogicalTypeId::UTINYINT:
900: 		D_ASSERT(value >= NumericLimits<uint8_t>::Minimum() && value <= NumericLimits<uint8_t>::Maximum());
901: 		return Value::UTINYINT((uint8_t)value);
902: 	case LogicalTypeId::USMALLINT:
903: 		D_ASSERT(value >= NumericLimits<uint16_t>::Minimum() && value <= NumericLimits<uint16_t>::Maximum());
904: 		return Value::USMALLINT((uint16_t)value);
905: 	case LogicalTypeId::UINTEGER:
906: 		D_ASSERT(value >= NumericLimits<uint32_t>::Minimum() && value <= NumericLimits<uint32_t>::Maximum());
907: 		return Value::UINTEGER((uint32_t)value);
908: 	case LogicalTypeId::UBIGINT:
909: 		D_ASSERT(value >= 0);
910: 		return Value::UBIGINT(value);
911: 	case LogicalTypeId::HUGEINT:
912: 		return Value::HUGEINT(value);
913: 	case LogicalTypeId::DECIMAL:
914: 		return Value::DECIMAL(value, DecimalType::GetWidth(type), DecimalType::GetScale(type));
915: 	case LogicalTypeId::FLOAT:
916: 		return Value((float)value);
917: 	case LogicalTypeId::DOUBLE:
918: 		return Value((double)value);
919: 	case LogicalTypeId::HASH:
920: 		return Value::HASH(value);
921: 	case LogicalTypeId::POINTER:
922: 		return Value::POINTER(value);
923: 	case LogicalTypeId::DATE:
924: 		D_ASSERT(value >= NumericLimits<int32_t>::Minimum() && value <= NumericLimits<int32_t>::Maximum());
925: 		return Value::DATE(date_t(value));
926: 	case LogicalTypeId::TIME:
927: 		return Value::TIME(dtime_t(value));
928: 	case LogicalTypeId::TIMESTAMP:
929: 		return Value::TIMESTAMP(timestamp_t(value));
930: 	case LogicalTypeId::TIMESTAMP_NS:
931: 		return Value::TIMESTAMPNS(timestamp_t(value));
932: 	case LogicalTypeId::TIMESTAMP_MS:
933: 		return Value::TIMESTAMPMS(timestamp_t(value));
934: 	case LogicalTypeId::TIMESTAMP_SEC:
935: 		return Value::TIMESTAMPSEC(timestamp_t(value));
936: 	case LogicalTypeId::TIME_TZ:
937: 		return Value::TIMETZ(dtime_t(value));
938: 	case LogicalTypeId::TIMESTAMP_TZ:
939: 		return Value::TIMESTAMPTZ(timestamp_t(value));
940: 	case LogicalTypeId::ENUM:
941: 		switch (type.InternalType()) {
942: 		case PhysicalType::UINT8:
943: 			D_ASSERT(value >= NumericLimits<uint8_t>::Minimum() && value <= NumericLimits<uint8_t>::Maximum());
944: 			return Value::UTINYINT((uint8_t)value);
945: 		case PhysicalType::UINT16:
946: 			D_ASSERT(value >= NumericLimits<uint16_t>::Minimum() && value <= NumericLimits<uint16_t>::Maximum());
947: 			return Value::USMALLINT((uint16_t)value);
948: 		case PhysicalType::UINT32:
949: 			D_ASSERT(value >= NumericLimits<uint32_t>::Minimum() && value <= NumericLimits<uint32_t>::Maximum());
950: 			return Value::UINTEGER((uint32_t)value);
951: 		default:
952: 			throw InternalException("Enum doesn't accept this physical type");
953: 		}
954: 	default:
955: 		throw InvalidTypeException(type, "Numeric requires numeric type");
956: 	}
957: }
958: 
959: Value Value::Numeric(const LogicalType &type, hugeint_t value) {
960: #ifdef DEBUG
961: 	// perform a throwing cast to verify that the type fits
962: 	Value::HUGEINT(value).CastAs(type);
963: #endif
964: 	switch (type.id()) {
965: 	case LogicalTypeId::HUGEINT:
966: 		return Value::HUGEINT(value);
967: 	case LogicalTypeId::UBIGINT:
968: 		return Value::UBIGINT(Hugeint::Cast<uint64_t>(value));
969: 	default:
970: 		return Value::Numeric(type, Hugeint::Cast<int64_t>(value));
971: 	}
972: }
973: 
974: //===--------------------------------------------------------------------===//
975: // GetValueUnsafe
976: //===--------------------------------------------------------------------===//
977: template <>
978: DUCKDB_API bool Value::GetValueUnsafe() const {
979: 	D_ASSERT(type_.InternalType() == PhysicalType::BOOL);
980: 	return value_.boolean;
981: }
982: 
983: template <>
984: int8_t Value::GetValueUnsafe() const {
985: 	D_ASSERT(type_.InternalType() == PhysicalType::INT8 || type_.InternalType() == PhysicalType::BOOL);
986: 	return value_.tinyint;
987: }
988: 
989: template <>
990: int16_t Value::GetValueUnsafe() const {
991: 	D_ASSERT(type_.InternalType() == PhysicalType::INT16);
992: 	return value_.smallint;
993: }
994: 
995: template <>
996: int32_t Value::GetValueUnsafe() const {
997: 	D_ASSERT(type_.InternalType() == PhysicalType::INT32);
998: 	return value_.integer;
999: }
1000: 
1001: template <>
1002: int64_t Value::GetValueUnsafe() const {
1003: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1004: 	return value_.bigint;
1005: }
1006: 
1007: template <>
1008: hugeint_t Value::GetValueUnsafe() const {
1009: 	D_ASSERT(type_.InternalType() == PhysicalType::INT128);
1010: 	return value_.hugeint;
1011: }
1012: 
1013: template <>
1014: uint8_t Value::GetValueUnsafe() const {
1015: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT8);
1016: 	return value_.utinyint;
1017: }
1018: 
1019: template <>
1020: uint16_t Value::GetValueUnsafe() const {
1021: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT16);
1022: 	return value_.usmallint;
1023: }
1024: 
1025: template <>
1026: uint32_t Value::GetValueUnsafe() const {
1027: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT32);
1028: 	return value_.uinteger;
1029: }
1030: 
1031: template <>
1032: uint64_t Value::GetValueUnsafe() const {
1033: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT64);
1034: 	return value_.ubigint;
1035: }
1036: 
1037: template <>
1038: string Value::GetValueUnsafe() const {
1039: 	D_ASSERT(type_.InternalType() == PhysicalType::VARCHAR);
1040: 	return str_value;
1041: }
1042: 
1043: template <>
1044: DUCKDB_API string_t Value::GetValueUnsafe() const {
1045: 	D_ASSERT(type_.InternalType() == PhysicalType::VARCHAR);
1046: 	return string_t(str_value);
1047: }
1048: 
1049: template <>
1050: float Value::GetValueUnsafe() const {
1051: 	D_ASSERT(type_.InternalType() == PhysicalType::FLOAT);
1052: 	return value_.float_;
1053: }
1054: 
1055: template <>
1056: double Value::GetValueUnsafe() const {
1057: 	D_ASSERT(type_.InternalType() == PhysicalType::DOUBLE);
1058: 	return value_.double_;
1059: }
1060: 
1061: template <>
1062: date_t Value::GetValueUnsafe() const {
1063: 	D_ASSERT(type_.InternalType() == PhysicalType::INT32);
1064: 	return value_.date;
1065: }
1066: 
1067: template <>
1068: dtime_t Value::GetValueUnsafe() const {
1069: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1070: 	return value_.time;
1071: }
1072: 
1073: template <>
1074: timestamp_t Value::GetValueUnsafe() const {
1075: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1076: 	return value_.timestamp;
1077: }
1078: 
1079: template <>
1080: interval_t Value::GetValueUnsafe() const {
1081: 	D_ASSERT(type_.InternalType() == PhysicalType::INTERVAL);
1082: 	return value_.interval;
1083: }
1084: 
1085: //===--------------------------------------------------------------------===//
1086: // GetReferenceUnsafe
1087: //===--------------------------------------------------------------------===//
1088: template <>
1089: int8_t &Value::GetReferenceUnsafe() {
1090: 	D_ASSERT(type_.InternalType() == PhysicalType::INT8 || type_.InternalType() == PhysicalType::BOOL);
1091: 	return value_.tinyint;
1092: }
1093: 
1094: template <>
1095: int16_t &Value::GetReferenceUnsafe() {
1096: 	D_ASSERT(type_.InternalType() == PhysicalType::INT16);
1097: 	return value_.smallint;
1098: }
1099: 
1100: template <>
1101: int32_t &Value::GetReferenceUnsafe() {
1102: 	D_ASSERT(type_.InternalType() == PhysicalType::INT32);
1103: 	return value_.integer;
1104: }
1105: 
1106: template <>
1107: int64_t &Value::GetReferenceUnsafe() {
1108: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1109: 	return value_.bigint;
1110: }
1111: 
1112: template <>
1113: hugeint_t &Value::GetReferenceUnsafe() {
1114: 	D_ASSERT(type_.InternalType() == PhysicalType::INT128);
1115: 	return value_.hugeint;
1116: }
1117: 
1118: template <>
1119: uint8_t &Value::GetReferenceUnsafe() {
1120: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT8);
1121: 	return value_.utinyint;
1122: }
1123: 
1124: template <>
1125: uint16_t &Value::GetReferenceUnsafe() {
1126: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT16);
1127: 	return value_.usmallint;
1128: }
1129: 
1130: template <>
1131: uint32_t &Value::GetReferenceUnsafe() {
1132: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT32);
1133: 	return value_.uinteger;
1134: }
1135: 
1136: template <>
1137: uint64_t &Value::GetReferenceUnsafe() {
1138: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT64);
1139: 	return value_.ubigint;
1140: }
1141: 
1142: template <>
1143: float &Value::GetReferenceUnsafe() {
1144: 	D_ASSERT(type_.InternalType() == PhysicalType::FLOAT);
1145: 	return value_.float_;
1146: }
1147: 
1148: template <>
1149: double &Value::GetReferenceUnsafe() {
1150: 	D_ASSERT(type_.InternalType() == PhysicalType::DOUBLE);
1151: 	return value_.double_;
1152: }
1153: 
1154: template <>
1155: date_t &Value::GetReferenceUnsafe() {
1156: 	D_ASSERT(type_.InternalType() == PhysicalType::INT32);
1157: 	return value_.date;
1158: }
1159: 
1160: template <>
1161: dtime_t &Value::GetReferenceUnsafe() {
1162: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1163: 	return value_.time;
1164: }
1165: 
1166: template <>
1167: timestamp_t &Value::GetReferenceUnsafe() {
1168: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1169: 	return value_.timestamp;
1170: }
1171: 
1172: template <>
1173: interval_t &Value::GetReferenceUnsafe() {
1174: 	D_ASSERT(type_.InternalType() == PhysicalType::INTERVAL);
1175: 	return value_.interval;
1176: }
1177: 
1178: //===--------------------------------------------------------------------===//
1179: // Hash
1180: //===--------------------------------------------------------------------===//
1181: hash_t Value::Hash() const {
1182: 	if (IsNull()) {
1183: 		return 0;
1184: 	}
1185: 	switch (type_.InternalType()) {
1186: 	case PhysicalType::BOOL:
1187: 		return duckdb::Hash(value_.boolean);
1188: 	case PhysicalType::INT8:
1189: 		return duckdb::Hash(value_.tinyint);
1190: 	case PhysicalType::INT16:
1191: 		return duckdb::Hash(value_.smallint);
1192: 	case PhysicalType::INT32:
1193: 		return duckdb::Hash(value_.integer);
1194: 	case PhysicalType::INT64:
1195: 		return duckdb::Hash(value_.bigint);
1196: 	case PhysicalType::UINT8:
1197: 		return duckdb::Hash(value_.utinyint);
1198: 	case PhysicalType::UINT16:
1199: 		return duckdb::Hash(value_.usmallint);
1200: 	case PhysicalType::UINT32:
1201: 		return duckdb::Hash(value_.uinteger);
1202: 	case PhysicalType::UINT64:
1203: 		return duckdb::Hash(value_.ubigint);
1204: 	case PhysicalType::INT128:
1205: 		return duckdb::Hash(value_.hugeint);
1206: 	case PhysicalType::FLOAT:
1207: 		return duckdb::Hash(value_.float_);
1208: 	case PhysicalType::DOUBLE:
1209: 		return duckdb::Hash(value_.double_);
1210: 	case PhysicalType::INTERVAL:
1211: 		return duckdb::Hash(value_.interval);
1212: 	case PhysicalType::VARCHAR:
1213: 		return duckdb::Hash(string_t(StringValue::Get(*this)));
1214: 	case PhysicalType::STRUCT: {
1215: 		auto &struct_children = StructValue::GetChildren(*this);
1216: 		hash_t hash = 0;
1217: 		for (auto &entry : struct_children) {
1218: 			hash ^= entry.Hash();
1219: 		}
1220: 		return hash;
1221: 	}
1222: 	case PhysicalType::LIST: {
1223: 		auto &list_children = ListValue::GetChildren(*this);
1224: 		hash_t hash = 0;
1225: 		for (auto &entry : list_children) {
1226: 			hash ^= entry.Hash();
1227: 		}
1228: 		return hash;
1229: 	}
1230: 	default:
1231: 		throw InternalException("Unimplemented type for value hash");
1232: 	}
1233: }
1234: 
1235: string Value::ToString() const {
1236: 	if (IsNull()) {
1237: 		return "NULL";
1238: 	}
1239: 	switch (type_.id()) {
1240: 	case LogicalTypeId::BOOLEAN:
1241: 		return value_.boolean ? "True" : "False";
1242: 	case LogicalTypeId::TINYINT:
1243: 		return to_string(value_.tinyint);
1244: 	case LogicalTypeId::SMALLINT:
1245: 		return to_string(value_.smallint);
1246: 	case LogicalTypeId::INTEGER:
1247: 		return to_string(value_.integer);
1248: 	case LogicalTypeId::BIGINT:
1249: 		return to_string(value_.bigint);
1250: 	case LogicalTypeId::UTINYINT:
1251: 		return to_string(value_.utinyint);
1252: 	case LogicalTypeId::USMALLINT:
1253: 		return to_string(value_.usmallint);
1254: 	case LogicalTypeId::UINTEGER:
1255: 		return to_string(value_.uinteger);
1256: 	case LogicalTypeId::UBIGINT:
1257: 		return to_string(value_.ubigint);
1258: 	case LogicalTypeId::HUGEINT:
1259: 		return Hugeint::ToString(value_.hugeint);
1260: 	case LogicalTypeId::UUID:
1261: 		return UUID::ToString(value_.hugeint);
1262: 	case LogicalTypeId::FLOAT:
1263: 		return to_string(value_.float_);
1264: 	case LogicalTypeId::DOUBLE:
1265: 		return to_string(value_.double_);
1266: 	case LogicalTypeId::DECIMAL: {
1267: 		auto internal_type = type_.InternalType();
1268: 		auto scale = DecimalType::GetScale(type_);
1269: 		if (internal_type == PhysicalType::INT16) {
1270: 			return Decimal::ToString(value_.smallint, scale);
1271: 		} else if (internal_type == PhysicalType::INT32) {
1272: 			return Decimal::ToString(value_.integer, scale);
1273: 		} else if (internal_type == PhysicalType::INT64) {
1274: 			return Decimal::ToString(value_.bigint, scale);
1275: 		} else {
1276: 			D_ASSERT(internal_type == PhysicalType::INT128);
1277: 			return Decimal::ToString(value_.hugeint, scale);
1278: 		}
1279: 	}
1280: 	case LogicalTypeId::DATE:
1281: 		return Date::ToString(value_.date);
1282: 	case LogicalTypeId::TIME:
1283: 		return Time::ToString(value_.time);
1284: 	case LogicalTypeId::TIMESTAMP:
1285: 		return Timestamp::ToString(value_.timestamp);
1286: 	case LogicalTypeId::TIME_TZ:
1287: 		return Time::ToString(value_.time) + Time::ToUTCOffset(0, 0);
1288: 	case LogicalTypeId::TIMESTAMP_TZ:
1289: 		return Timestamp::ToString(value_.timestamp) + Time::ToUTCOffset(0, 0);
1290: 	case LogicalTypeId::TIMESTAMP_SEC:
1291: 		return Timestamp::ToString(Timestamp::FromEpochSeconds(value_.timestamp.value));
1292: 	case LogicalTypeId::TIMESTAMP_MS:
1293: 		return Timestamp::ToString(Timestamp::FromEpochMs(value_.timestamp.value));
1294: 	case LogicalTypeId::TIMESTAMP_NS:
1295: 		return Timestamp::ToString(Timestamp::FromEpochNanoSeconds(value_.timestamp.value));
1296: 	case LogicalTypeId::INTERVAL:
1297: 		return Interval::ToString(value_.interval);
1298: 	case LogicalTypeId::JSON:
1299: 	case LogicalTypeId::VARCHAR:
1300: 		return str_value;
1301: 	case LogicalTypeId::BLOB:
1302: 		return Blob::ToString(string_t(str_value));
1303: 	case LogicalTypeId::POINTER:
1304: 		return to_string(value_.pointer);
1305: 	case LogicalTypeId::HASH:
1306: 		return to_string(value_.hash);
1307: 	case LogicalTypeId::STRUCT: {
1308: 		string ret = "{";
1309: 		auto &child_types = StructType::GetChildTypes(type_);
1310: 		for (size_t i = 0; i < struct_value.size(); i++) {
1311: 			auto &name = child_types[i].first;
1312: 			auto &child = struct_value[i];
1313: 			ret += "'" + name + "': " + child.ToString();
1314: 			if (i < struct_value.size() - 1) {
1315: 				ret += ", ";
1316: 			}
1317: 		}
1318: 		ret += "}";
1319: 		return ret;
1320: 	}
1321: 	case LogicalTypeId::LIST: {
1322: 		string ret = "[";
1323: 		for (size_t i = 0; i < list_value.size(); i++) {
1324: 			auto &child = list_value[i];
1325: 			ret += child.ToString();
1326: 			if (i < list_value.size() - 1) {
1327: 				ret += ", ";
1328: 			}
1329: 		}
1330: 		ret += "]";
1331: 		return ret;
1332: 	}
1333: 	case LogicalTypeId::MAP: {
1334: 		string ret = "{";
1335: 		auto &key_list = struct_value[0].list_value;
1336: 		auto &value_list = struct_value[1].list_value;
1337: 		for (size_t i = 0; i < key_list.size(); i++) {
1338: 			ret += key_list[i].ToString() + "=" + value_list[i].ToString();
1339: 			if (i < key_list.size() - 1) {
1340: 				ret += ", ";
1341: 			}
1342: 		}
1343: 		ret += "}";
1344: 		return ret;
1345: 	}
1346: 	case LogicalTypeId::ENUM: {
1347: 		auto &values_insert_order = EnumType::GetValuesInsertOrder(type_);
1348: 		uint64_t enum_idx;
1349: 		switch (type_.InternalType()) {
1350: 		case PhysicalType::UINT8:
1351: 			enum_idx = value_.utinyint;
1352: 			break;
1353: 		case PhysicalType::UINT16:
1354: 			enum_idx = value_.usmallint;
1355: 			break;
1356: 		case PhysicalType::UINT32:
1357: 			enum_idx = value_.uinteger;
1358: 			break;
1359: 		default:
1360: 			throw InternalException("ENUM can only have unsigned integers (except UINT64) as physical types");
1361: 		}
1362: 		return values_insert_order.GetValue(enum_idx).ToString();
1363: 	}
1364: 	default:
1365: 		throw NotImplementedException("Unimplemented type for printing: %s", type_.ToString());
1366: 	}
1367: }
1368: 
1369: string Value::ToSQLString() const {
1370: 	if (IsNull()) {
1371: 		return ToString();
1372: 	}
1373: 	switch (type_.id()) {
1374: 	case LogicalTypeId::UUID:
1375: 	case LogicalTypeId::DATE:
1376: 	case LogicalTypeId::TIME:
1377: 	case LogicalTypeId::TIMESTAMP:
1378: 	case LogicalTypeId::TIME_TZ:
1379: 	case LogicalTypeId::TIMESTAMP_TZ:
1380: 	case LogicalTypeId::TIMESTAMP_SEC:
1381: 	case LogicalTypeId::TIMESTAMP_MS:
1382: 	case LogicalTypeId::TIMESTAMP_NS:
1383: 	case LogicalTypeId::INTERVAL:
1384: 	case LogicalTypeId::BLOB:
1385: 		return "'" + ToString() + "'::" + type_.ToString();
1386: 	case LogicalTypeId::VARCHAR:
1387: 		return "'" + StringUtil::Replace(ToString(), "'", "''") + "'";
1388: 	case LogicalTypeId::STRUCT: {
1389: 		string ret = "{";
1390: 		auto &child_types = StructType::GetChildTypes(type_);
1391: 		for (size_t i = 0; i < struct_value.size(); i++) {
1392: 			auto &name = child_types[i].first;
1393: 			auto &child = struct_value[i];
1394: 			ret += "'" + name + "': " + child.ToSQLString();
1395: 			if (i < struct_value.size() - 1) {
1396: 				ret += ", ";
1397: 			}
1398: 		}
1399: 		ret += "}";
1400: 		return ret;
1401: 	}
1402: 	case LogicalTypeId::LIST: {
1403: 		string ret = "[";
1404: 		for (size_t i = 0; i < list_value.size(); i++) {
1405: 			auto &child = list_value[i];
1406: 			ret += child.ToSQLString();
1407: 			if (i < list_value.size() - 1) {
1408: 				ret += ", ";
1409: 			}
1410: 		}
1411: 		ret += "]";
1412: 		return ret;
1413: 	}
1414: 	default:
1415: 		return ToString();
1416: 	}
1417: }
1418: 
1419: //===--------------------------------------------------------------------===//
1420: // Type-specific getters
1421: //===--------------------------------------------------------------------===//
1422: bool BooleanValue::Get(const Value &value) {
1423: 	return value.GetValueUnsafe<bool>();
1424: }
1425: 
1426: int8_t TinyIntValue::Get(const Value &value) {
1427: 	return value.GetValueUnsafe<int8_t>();
1428: }
1429: 
1430: int16_t SmallIntValue::Get(const Value &value) {
1431: 	return value.GetValueUnsafe<int16_t>();
1432: }
1433: 
1434: int32_t IntegerValue::Get(const Value &value) {
1435: 	return value.GetValueUnsafe<int32_t>();
1436: }
1437: 
1438: int64_t BigIntValue::Get(const Value &value) {
1439: 	return value.GetValueUnsafe<int64_t>();
1440: }
1441: 
1442: hugeint_t HugeIntValue::Get(const Value &value) {
1443: 	return value.GetValueUnsafe<hugeint_t>();
1444: }
1445: 
1446: uint8_t UTinyIntValue::Get(const Value &value) {
1447: 	return value.GetValueUnsafe<uint8_t>();
1448: }
1449: 
1450: uint16_t USmallIntValue::Get(const Value &value) {
1451: 	return value.GetValueUnsafe<uint16_t>();
1452: }
1453: 
1454: uint32_t UIntegerValue::Get(const Value &value) {
1455: 	return value.GetValueUnsafe<uint32_t>();
1456: }
1457: 
1458: uint64_t UBigIntValue::Get(const Value &value) {
1459: 	return value.GetValueUnsafe<uint64_t>();
1460: }
1461: 
1462: float FloatValue::Get(const Value &value) {
1463: 	return value.GetValueUnsafe<float>();
1464: }
1465: 
1466: double DoubleValue::Get(const Value &value) {
1467: 	return value.GetValueUnsafe<double>();
1468: }
1469: 
1470: const string &StringValue::Get(const Value &value) {
1471: 	D_ASSERT(value.type().InternalType() == PhysicalType::VARCHAR);
1472: 	return value.str_value;
1473: }
1474: 
1475: date_t DateValue::Get(const Value &value) {
1476: 	return value.GetValueUnsafe<date_t>();
1477: }
1478: 
1479: dtime_t TimeValue::Get(const Value &value) {
1480: 	return value.GetValueUnsafe<dtime_t>();
1481: }
1482: 
1483: timestamp_t TimestampValue::Get(const Value &value) {
1484: 	return value.GetValueUnsafe<timestamp_t>();
1485: }
1486: 
1487: interval_t IntervalValue::Get(const Value &value) {
1488: 	return value.GetValueUnsafe<interval_t>();
1489: }
1490: 
1491: const vector<Value> &StructValue::GetChildren(const Value &value) {
1492: 	D_ASSERT(value.type().InternalType() == PhysicalType::STRUCT);
1493: 	return value.struct_value;
1494: }
1495: 
1496: const vector<Value> &ListValue::GetChildren(const Value &value) {
1497: 	D_ASSERT(value.type().InternalType() == PhysicalType::LIST);
1498: 	return value.list_value;
1499: }
1500: 
1501: hugeint_t IntegralValue::Get(const Value &value) {
1502: 	switch (value.type().InternalType()) {
1503: 	case PhysicalType::INT8:
1504: 		return TinyIntValue::Get(value);
1505: 	case PhysicalType::INT16:
1506: 		return SmallIntValue::Get(value);
1507: 	case PhysicalType::INT32:
1508: 		return IntegerValue::Get(value);
1509: 	case PhysicalType::INT64:
1510: 		return BigIntValue::Get(value);
1511: 	case PhysicalType::INT128:
1512: 		return HugeIntValue::Get(value);
1513: 	case PhysicalType::UINT8:
1514: 		return UTinyIntValue::Get(value);
1515: 	case PhysicalType::UINT16:
1516: 		return USmallIntValue::Get(value);
1517: 	case PhysicalType::UINT32:
1518: 		return UIntegerValue::Get(value);
1519: 	case PhysicalType::UINT64:
1520: 		return UBigIntValue::Get(value);
1521: 	default:
1522: 		throw InternalException("Invalid internal type \"%s\" for IntegralValue::Get", value.type().ToString());
1523: 	}
1524: }
1525: 
1526: //===--------------------------------------------------------------------===//
1527: // Comparison Operators
1528: //===--------------------------------------------------------------------===//
1529: bool Value::operator==(const Value &rhs) const {
1530: 	return ValueOperations::Equals(*this, rhs);
1531: }
1532: 
1533: bool Value::operator!=(const Value &rhs) const {
1534: 	return ValueOperations::NotEquals(*this, rhs);
1535: }
1536: 
1537: bool Value::operator<(const Value &rhs) const {
1538: 	return ValueOperations::LessThan(*this, rhs);
1539: }
1540: 
1541: bool Value::operator>(const Value &rhs) const {
1542: 	return ValueOperations::GreaterThan(*this, rhs);
1543: }
1544: 
1545: bool Value::operator<=(const Value &rhs) const {
1546: 	return ValueOperations::LessThanEquals(*this, rhs);
1547: }
1548: 
1549: bool Value::operator>=(const Value &rhs) const {
1550: 	return ValueOperations::GreaterThanEquals(*this, rhs);
1551: }
1552: 
1553: bool Value::operator==(const int64_t &rhs) const {
1554: 	return *this == Value::Numeric(type_, rhs);
1555: }
1556: 
1557: bool Value::operator!=(const int64_t &rhs) const {
1558: 	return *this != Value::Numeric(type_, rhs);
1559: }
1560: 
1561: bool Value::operator<(const int64_t &rhs) const {
1562: 	return *this < Value::Numeric(type_, rhs);
1563: }
1564: 
1565: bool Value::operator>(const int64_t &rhs) const {
1566: 	return *this > Value::Numeric(type_, rhs);
1567: }
1568: 
1569: bool Value::operator<=(const int64_t &rhs) const {
1570: 	return *this <= Value::Numeric(type_, rhs);
1571: }
1572: 
1573: bool Value::operator>=(const int64_t &rhs) const {
1574: 	return *this >= Value::Numeric(type_, rhs);
1575: }
1576: 
1577: bool Value::TryCastAs(const LogicalType &target_type, Value &new_value, string *error_message, bool strict) const {
1578: 	if (type_ == target_type) {
1579: 		new_value = Copy();
1580: 		return true;
1581: 	}
1582: 	Vector input(*this);
1583: 	Vector result(target_type);
1584: 	if (!VectorOperations::TryCast(input, result, 1, error_message, strict)) {
1585: 		return false;
1586: 	}
1587: 	new_value = result.GetValue(0);
1588: 	return true;
1589: }
1590: 
1591: Value Value::CastAs(const LogicalType &target_type, bool strict) const {
1592: 	Value new_value;
1593: 	string error_message;
1594: 	if (!TryCastAs(target_type, new_value, &error_message, strict)) {
1595: 		throw InvalidInputException("Failed to cast value: %s", error_message);
1596: 	}
1597: 	return new_value;
1598: }
1599: 
1600: bool Value::TryCastAs(const LogicalType &target_type, bool strict) {
1601: 	Value new_value;
1602: 	string error_message;
1603: 	if (!TryCastAs(target_type, new_value, &error_message, strict)) {
1604: 		return false;
1605: 	}
1606: 	type_ = target_type;
1607: 	is_null = new_value.is_null;
1608: 	value_ = new_value.value_;
1609: 	str_value = new_value.str_value;
1610: 	struct_value = new_value.struct_value;
1611: 	list_value = new_value.list_value;
1612: 	return true;
1613: }
1614: 
1615: void Value::Serialize(Serializer &main_serializer) const {
1616: 	FieldWriter writer(main_serializer);
1617: 	writer.WriteSerializable(type_);
1618: 	writer.WriteField<bool>(IsNull());
1619: 	if (!IsNull()) {
1620: 		auto &serializer = writer.GetSerializer();
1621: 		switch (type_.InternalType()) {
1622: 		case PhysicalType::BOOL:
1623: 			serializer.Write<int8_t>(value_.boolean);
1624: 			break;
1625: 		case PhysicalType::INT8:
1626: 			serializer.Write<int8_t>(value_.tinyint);
1627: 			break;
1628: 		case PhysicalType::INT16:
1629: 			serializer.Write<int16_t>(value_.smallint);
1630: 			break;
1631: 		case PhysicalType::INT32:
1632: 			serializer.Write<int32_t>(value_.integer);
1633: 			break;
1634: 		case PhysicalType::INT64:
1635: 			serializer.Write<int64_t>(value_.bigint);
1636: 			break;
1637: 		case PhysicalType::UINT8:
1638: 			serializer.Write<uint8_t>(value_.utinyint);
1639: 			break;
1640: 		case PhysicalType::UINT16:
1641: 			serializer.Write<uint16_t>(value_.usmallint);
1642: 			break;
1643: 		case PhysicalType::UINT32:
1644: 			serializer.Write<uint32_t>(value_.uinteger);
1645: 			break;
1646: 		case PhysicalType::UINT64:
1647: 			serializer.Write<uint64_t>(value_.ubigint);
1648: 			break;
1649: 		case PhysicalType::INT128:
1650: 			serializer.Write<hugeint_t>(value_.hugeint);
1651: 			break;
1652: 		case PhysicalType::FLOAT:
1653: 			serializer.Write<float>(value_.float_);
1654: 			break;
1655: 		case PhysicalType::DOUBLE:
1656: 			serializer.Write<double>(value_.double_);
1657: 			break;
1658: 		case PhysicalType::INTERVAL:
1659: 			serializer.Write<interval_t>(value_.interval);
1660: 			break;
1661: 		case PhysicalType::VARCHAR:
1662: 			serializer.WriteString(str_value);
1663: 			break;
1664: 		default: {
1665: 			Vector v(*this);
1666: 			v.Serialize(1, serializer);
1667: 			break;
1668: 		}
1669: 		}
1670: 	}
1671: 	writer.Finalize();
1672: }
1673: 
1674: Value Value::Deserialize(Deserializer &main_source) {
1675: 	FieldReader reader(main_source);
1676: 	auto type = reader.ReadRequiredSerializable<LogicalType, LogicalType>();
1677: 	auto is_null = reader.ReadRequired<bool>();
1678: 	Value new_value = Value(type);
1679: 	if (is_null) {
1680: 		return new_value;
1681: 	}
1682: 	new_value.is_null = false;
1683: 	auto &source = reader.GetSource();
1684: 	switch (type.InternalType()) {
1685: 	case PhysicalType::BOOL:
1686: 		new_value.value_.boolean = source.Read<int8_t>();
1687: 		break;
1688: 	case PhysicalType::INT8:
1689: 		new_value.value_.tinyint = source.Read<int8_t>();
1690: 		break;
1691: 	case PhysicalType::INT16:
1692: 		new_value.value_.smallint = source.Read<int16_t>();
1693: 		break;
1694: 	case PhysicalType::INT32:
1695: 		new_value.value_.integer = source.Read<int32_t>();
1696: 		break;
1697: 	case PhysicalType::INT64:
1698: 		new_value.value_.bigint = source.Read<int64_t>();
1699: 		break;
1700: 	case PhysicalType::UINT8:
1701: 		new_value.value_.utinyint = source.Read<uint8_t>();
1702: 		break;
1703: 	case PhysicalType::UINT16:
1704: 		new_value.value_.usmallint = source.Read<uint16_t>();
1705: 		break;
1706: 	case PhysicalType::UINT32:
1707: 		new_value.value_.uinteger = source.Read<uint32_t>();
1708: 		break;
1709: 	case PhysicalType::UINT64:
1710: 		new_value.value_.ubigint = source.Read<uint64_t>();
1711: 		break;
1712: 	case PhysicalType::INT128:
1713: 		new_value.value_.hugeint = source.Read<hugeint_t>();
1714: 		break;
1715: 	case PhysicalType::FLOAT:
1716: 		new_value.value_.float_ = source.Read<float>();
1717: 		break;
1718: 	case PhysicalType::DOUBLE:
1719: 		new_value.value_.double_ = source.Read<double>();
1720: 		break;
1721: 	case PhysicalType::INTERVAL:
1722: 		new_value.value_.interval = source.Read<interval_t>();
1723: 		break;
1724: 	case PhysicalType::VARCHAR:
1725: 		new_value.str_value = source.Read<string>();
1726: 		break;
1727: 	default: {
1728: 		Vector v(type);
1729: 		v.Deserialize(1, source);
1730: 		new_value = v.GetValue(0);
1731: 		break;
1732: 	}
1733: 	}
1734: 	reader.Finalize();
1735: 	return new_value;
1736: }
1737: 
1738: void Value::Print() const {
1739: 	Printer::Print(ToString());
1740: }
1741: 
1742: bool Value::ValuesAreEqual(const Value &result_value, const Value &value) {
1743: 	if (result_value.IsNull() != value.IsNull()) {
1744: 		return false;
1745: 	}
1746: 	if (result_value.IsNull() && value.IsNull()) {
1747: 		// NULL = NULL in checking code
1748: 		return true;
1749: 	}
1750: 	switch (value.type_.id()) {
1751: 	case LogicalTypeId::FLOAT: {
1752: 		auto other = result_value.CastAs(LogicalType::FLOAT);
1753: 		float ldecimal = value.value_.float_;
1754: 		float rdecimal = other.value_.float_;
1755: 		return ApproxEqual(ldecimal, rdecimal);
1756: 	}
1757: 	case LogicalTypeId::DOUBLE: {
1758: 		auto other = result_value.CastAs(LogicalType::DOUBLE);
1759: 		double ldecimal = value.value_.double_;
1760: 		double rdecimal = other.value_.double_;
1761: 		return ApproxEqual(ldecimal, rdecimal);
1762: 	}
1763: 	case LogicalTypeId::VARCHAR: {
1764: 		auto other = result_value.CastAs(LogicalType::VARCHAR);
1765: 		// some results might contain padding spaces, e.g. when rendering
1766: 		// VARCHAR(10) and the string only has 6 characters, they will be padded
1767: 		// with spaces to 10 in the rendering. We don't do that here yet as we
1768: 		// are looking at internal structures. So just ignore any extra spaces
1769: 		// on the right
1770: 		string left = other.str_value;
1771: 		string right = value.str_value;
1772: 		StringUtil::RTrim(left);
1773: 		StringUtil::RTrim(right);
1774: 		return left == right;
1775: 	}
1776: 	default:
1777: 		return value == result_value;
1778: 	}
1779: }
1780: 
1781: template <>
1782: bool Value::IsValid(float value) {
1783: 	return Value::FloatIsValid(value);
1784: }
1785: 
1786: template <>
1787: bool Value::IsValid(double value) {
1788: 	return Value::DoubleIsValid(value);
1789: }
1790: 
1791: } // namespace duckdb
[end of src/common/types/value.cpp]
[start of src/common/types/vector.cpp]
1: #include "duckdb/common/types/vector.hpp"
2: 
3: #include "duckdb/common/algorithm.hpp"
4: #include "duckdb/common/assert.hpp"
5: #include "duckdb/common/exception.hpp"
6: #include "duckdb/common/operator/comparison_operators.hpp"
7: #include "duckdb/common/pair.hpp"
8: #include "duckdb/common/printer.hpp"
9: #include "duckdb/common/serializer.hpp"
10: #include "duckdb/common/types/null_value.hpp"
11: #include "duckdb/common/types/sel_cache.hpp"
12: #include "duckdb/common/types/vector_cache.hpp"
13: #include "duckdb/common/vector_operations/vector_operations.hpp"
14: #include "duckdb/storage/buffer/buffer_handle.hpp"
15: 
16: #include <cstring> // strlen() on Solaris
17: 
18: namespace duckdb {
19: 
20: Vector::Vector(LogicalType type_p, bool create_data, bool zero_data, idx_t capacity)
21:     : vector_type(VectorType::FLAT_VECTOR), type(move(type_p)), data(nullptr) {
22: 	if (create_data) {
23: 		Initialize(zero_data, capacity);
24: 	}
25: }
26: 
27: Vector::Vector(LogicalType type_p, idx_t capacity) : Vector(move(type_p), true, false, capacity) {
28: }
29: 
30: Vector::Vector(LogicalType type_p, data_ptr_t dataptr)
31:     : vector_type(VectorType::FLAT_VECTOR), type(move(type_p)), data(dataptr) {
32: 	if (dataptr && type.id() == LogicalTypeId::INVALID) {
33: 		throw InternalException("Cannot create a vector of type INVALID!");
34: 	}
35: }
36: 
37: Vector::Vector(const VectorCache &cache) : type(cache.GetType()) {
38: 	ResetFromCache(cache);
39: }
40: 
41: Vector::Vector(Vector &other) : type(other.type) {
42: 	Reference(other);
43: }
44: 
45: Vector::Vector(Vector &other, const SelectionVector &sel, idx_t count) : type(other.type) {
46: 	Slice(other, sel, count);
47: }
48: 
49: Vector::Vector(Vector &other, idx_t offset) : type(other.type) {
50: 	Slice(other, offset);
51: }
52: 
53: Vector::Vector(const Value &value) : type(value.type()) {
54: 	Reference(value);
55: }
56: 
57: Vector::Vector(Vector &&other) noexcept
58:     : vector_type(other.vector_type), type(move(other.type)), data(other.data), validity(move(other.validity)),
59:       buffer(move(other.buffer)), auxiliary(move(other.auxiliary)) {
60: }
61: 
62: void Vector::Reference(const Value &value) {
63: 	D_ASSERT(GetType().id() == value.type().id());
64: 	this->vector_type = VectorType::CONSTANT_VECTOR;
65: 	buffer = VectorBuffer::CreateConstantVector(value.type());
66: 	auto internal_type = value.type().InternalType();
67: 	if (internal_type == PhysicalType::STRUCT) {
68: 		auto struct_buffer = make_unique<VectorStructBuffer>();
69: 		auto &child_types = StructType::GetChildTypes(value.type());
70: 		auto &child_vectors = struct_buffer->GetChildren();
71: 		auto &value_children = StructValue::GetChildren(value);
72: 		for (idx_t i = 0; i < child_types.size(); i++) {
73: 			auto vector = make_unique<Vector>(value.IsNull() ? Value(child_types[i].second) : value_children[i]);
74: 			child_vectors.push_back(move(vector));
75: 		}
76: 		auxiliary = move(struct_buffer);
77: 		if (value.IsNull()) {
78: 			SetValue(0, value);
79: 		}
80: 	} else if (internal_type == PhysicalType::LIST) {
81: 		auto list_buffer = make_unique<VectorListBuffer>(value.type());
82: 		auxiliary = move(list_buffer);
83: 		data = buffer->GetData();
84: 		SetValue(0, value);
85: 	} else {
86: 		auxiliary.reset();
87: 		data = buffer->GetData();
88: 		SetValue(0, value);
89: 	}
90: }
91: 
92: void Vector::Reference(Vector &other) {
93: 	D_ASSERT(other.GetType() == GetType());
94: 	Reinterpret(other);
95: }
96: 
97: void Vector::ReferenceAndSetType(Vector &other) {
98: 	type = other.GetType();
99: 	Reference(other);
100: }
101: 
102: void Vector::Reinterpret(Vector &other) {
103: 	vector_type = other.vector_type;
104: 	AssignSharedPointer(buffer, other.buffer);
105: 	AssignSharedPointer(auxiliary, other.auxiliary);
106: 	data = other.data;
107: 	validity = other.validity;
108: }
109: 
110: void Vector::ResetFromCache(const VectorCache &cache) {
111: 	cache.ResetFromCache(*this);
112: }
113: 
114: void Vector::Slice(Vector &other, idx_t offset) {
115: 	if (other.GetVectorType() == VectorType::CONSTANT_VECTOR) {
116: 		Reference(other);
117: 		return;
118: 	}
119: 	D_ASSERT(other.GetVectorType() == VectorType::FLAT_VECTOR);
120: 
121: 	auto internal_type = GetType().InternalType();
122: 	if (internal_type == PhysicalType::STRUCT) {
123: 		Vector new_vector(GetType());
124: 		auto &entries = StructVector::GetEntries(new_vector);
125: 		auto &other_entries = StructVector::GetEntries(other);
126: 		D_ASSERT(entries.size() == other_entries.size());
127: 		for (idx_t i = 0; i < entries.size(); i++) {
128: 			entries[i]->Slice(*other_entries[i], offset);
129: 		}
130: 		if (offset > 0) {
131: 			new_vector.validity.Slice(other.validity, offset);
132: 		} else {
133: 			new_vector.validity = other.validity;
134: 		}
135: 		Reference(new_vector);
136: 	} else {
137: 		Reference(other);
138: 		if (offset > 0) {
139: 			data = data + GetTypeIdSize(internal_type) * offset;
140: 			validity.Slice(other.validity, offset);
141: 		}
142: 	}
143: }
144: 
145: void Vector::Slice(Vector &other, const SelectionVector &sel, idx_t count) {
146: 	Reference(other);
147: 	Slice(sel, count);
148: }
149: 
150: void Vector::Slice(const SelectionVector &sel, idx_t count) {
151: 	if (GetVectorType() == VectorType::CONSTANT_VECTOR) {
152: 		// dictionary on a constant is just a constant
153: 		return;
154: 	}
155: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
156: 		// already a dictionary, slice the current dictionary
157: 		auto &current_sel = DictionaryVector::SelVector(*this);
158: 		auto sliced_dictionary = current_sel.Slice(sel, count);
159: 		buffer = make_buffer<DictionaryBuffer>(move(sliced_dictionary));
160: 		return;
161: 	}
162: 	Vector child_vector(*this);
163: 	auto child_ref = make_buffer<VectorChildBuffer>(move(child_vector));
164: 	auto dict_buffer = make_buffer<DictionaryBuffer>(sel);
165: 	vector_type = VectorType::DICTIONARY_VECTOR;
166: 	buffer = move(dict_buffer);
167: 	auxiliary = move(child_ref);
168: }
169: 
170: void Vector::Slice(const SelectionVector &sel, idx_t count, SelCache &cache) {
171: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
172: 		// dictionary vector: need to merge dictionaries
173: 		// check if we have a cached entry
174: 		auto &current_sel = DictionaryVector::SelVector(*this);
175: 		auto target_data = current_sel.data();
176: 		auto entry = cache.cache.find(target_data);
177: 		if (entry != cache.cache.end()) {
178: 			// cached entry exists: use that
179: 			this->buffer = make_buffer<DictionaryBuffer>(((DictionaryBuffer &)*entry->second).GetSelVector());
180: 			vector_type = VectorType::DICTIONARY_VECTOR;
181: 		} else {
182: 			Slice(sel, count);
183: 			cache.cache[target_data] = this->buffer;
184: 		}
185: 	} else {
186: 		Slice(sel, count);
187: 	}
188: }
189: 
190: void Vector::Initialize(bool zero_data, idx_t capacity) {
191: 	auxiliary.reset();
192: 	validity.Reset();
193: 	auto &type = GetType();
194: 	auto internal_type = type.InternalType();
195: 	if (internal_type == PhysicalType::STRUCT) {
196: 		auto struct_buffer = make_unique<VectorStructBuffer>(type, capacity);
197: 		auxiliary = move(struct_buffer);
198: 	} else if (internal_type == PhysicalType::LIST) {
199: 		auto list_buffer = make_unique<VectorListBuffer>(type);
200: 		auxiliary = move(list_buffer);
201: 	}
202: 	auto type_size = GetTypeIdSize(internal_type);
203: 	if (type_size > 0) {
204: 		buffer = VectorBuffer::CreateStandardVector(type, capacity);
205: 		data = buffer->GetData();
206: 		if (zero_data) {
207: 			memset(data, 0, capacity * type_size);
208: 		}
209: 	}
210: }
211: 
212: struct DataArrays {
213: 	Vector &vec;
214: 	data_ptr_t data;
215: 	VectorBuffer *buffer;
216: 	idx_t type_size;
217: 	bool is_nested;
218: 	DataArrays(Vector &vec, data_ptr_t data, VectorBuffer *buffer, idx_t type_size, bool is_nested)
219: 	    : vec(vec), data(data), buffer(buffer), type_size(type_size), is_nested(is_nested) {};
220: };
221: 
222: void FindChildren(std::vector<DataArrays> &to_resize, VectorBuffer &auxiliary) {
223: 	if (auxiliary.GetBufferType() == VectorBufferType::LIST_BUFFER) {
224: 		auto &buffer = (VectorListBuffer &)auxiliary;
225: 		auto &child = buffer.GetChild();
226: 		auto data = child.GetData();
227: 		if (!data) {
228: 			//! Nested type
229: 			DataArrays arrays(child, data, child.GetBuffer().get(), GetTypeIdSize(child.GetType().InternalType()),
230: 			                  true);
231: 			to_resize.emplace_back(arrays);
232: 			FindChildren(to_resize, *child.GetAuxiliary());
233: 		} else {
234: 			DataArrays arrays(child, data, child.GetBuffer().get(), GetTypeIdSize(child.GetType().InternalType()),
235: 			                  false);
236: 			to_resize.emplace_back(arrays);
237: 		}
238: 	} else if (auxiliary.GetBufferType() == VectorBufferType::STRUCT_BUFFER) {
239: 		auto &buffer = (VectorStructBuffer &)auxiliary;
240: 		auto &children = buffer.GetChildren();
241: 		for (auto &child : children) {
242: 			auto data = child->GetData();
243: 			if (!data) {
244: 				//! Nested type
245: 				DataArrays arrays(*child, data, child->GetBuffer().get(),
246: 				                  GetTypeIdSize(child->GetType().InternalType()), true);
247: 				to_resize.emplace_back(arrays);
248: 				FindChildren(to_resize, *child->GetAuxiliary());
249: 			} else {
250: 				DataArrays arrays(*child, data, child->GetBuffer().get(),
251: 				                  GetTypeIdSize(child->GetType().InternalType()), false);
252: 				to_resize.emplace_back(arrays);
253: 			}
254: 		}
255: 	}
256: }
257: void Vector::Resize(idx_t cur_size, idx_t new_size) {
258: 	std::vector<DataArrays> to_resize;
259: 	if (!buffer) {
260: 		buffer = make_unique<VectorBuffer>(0);
261: 	}
262: 	if (!data) {
263: 		//! this is a nested structure
264: 		DataArrays arrays(*this, data, buffer.get(), GetTypeIdSize(GetType().InternalType()), true);
265: 		to_resize.emplace_back(arrays);
266: 		FindChildren(to_resize, *auxiliary);
267: 	} else {
268: 		DataArrays arrays(*this, data, buffer.get(), GetTypeIdSize(GetType().InternalType()), false);
269: 		to_resize.emplace_back(arrays);
270: 	}
271: 	for (auto &data_to_resize : to_resize) {
272: 		if (!data_to_resize.is_nested) {
273: 			auto new_data = unique_ptr<data_t[]>(new data_t[new_size * data_to_resize.type_size]);
274: 			memcpy(new_data.get(), data_to_resize.data, cur_size * data_to_resize.type_size * sizeof(data_t));
275: 			data_to_resize.buffer->SetData(move(new_data));
276: 			data_to_resize.vec.data = data_to_resize.buffer->GetData();
277: 		}
278: 		data_to_resize.vec.validity.Resize(cur_size, new_size);
279: 	}
280: }
281: 
282: void Vector::SetValue(idx_t index, const Value &val) {
283: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
284: 		// dictionary: apply dictionary and forward to child
285: 		auto &sel_vector = DictionaryVector::SelVector(*this);
286: 		auto &child = DictionaryVector::Child(*this);
287: 		return child.SetValue(sel_vector.get_index(index), val);
288: 	}
289: 	if (val.type().InternalType() != GetType().InternalType()) {
290: 		SetValue(index, val.CastAs(GetType()));
291: 		return;
292: 	}
293: 
294: 	validity.EnsureWritable();
295: 	validity.Set(index, !val.IsNull());
296: 	if (val.IsNull() && GetType().InternalType() != PhysicalType::STRUCT) {
297: 		// for structs we still need to set the child-entries to NULL
298: 		// so we do not bail out yet
299: 		return;
300: 	}
301: 
302: 	switch (GetType().InternalType()) {
303: 	case PhysicalType::BOOL:
304: 		((bool *)data)[index] = val.GetValueUnsafe<bool>();
305: 		break;
306: 	case PhysicalType::INT8:
307: 		((int8_t *)data)[index] = val.GetValueUnsafe<int8_t>();
308: 		break;
309: 	case PhysicalType::INT16:
310: 		((int16_t *)data)[index] = val.GetValueUnsafe<int16_t>();
311: 		break;
312: 	case PhysicalType::INT32:
313: 		((int32_t *)data)[index] = val.GetValueUnsafe<int32_t>();
314: 		break;
315: 	case PhysicalType::INT64:
316: 		((int64_t *)data)[index] = val.GetValueUnsafe<int64_t>();
317: 		break;
318: 	case PhysicalType::INT128:
319: 		((hugeint_t *)data)[index] = val.GetValueUnsafe<hugeint_t>();
320: 		break;
321: 	case PhysicalType::UINT8:
322: 		((uint8_t *)data)[index] = val.GetValueUnsafe<uint8_t>();
323: 		break;
324: 	case PhysicalType::UINT16:
325: 		((uint16_t *)data)[index] = val.GetValueUnsafe<uint16_t>();
326: 		break;
327: 	case PhysicalType::UINT32:
328: 		((uint32_t *)data)[index] = val.GetValueUnsafe<uint32_t>();
329: 		break;
330: 	case PhysicalType::UINT64:
331: 		((uint64_t *)data)[index] = val.GetValueUnsafe<uint64_t>();
332: 		break;
333: 	case PhysicalType::FLOAT:
334: 		((float *)data)[index] = val.GetValueUnsafe<float>();
335: 		break;
336: 	case PhysicalType::DOUBLE:
337: 		((double *)data)[index] = val.GetValueUnsafe<double>();
338: 		break;
339: 	case PhysicalType::INTERVAL:
340: 		((interval_t *)data)[index] = val.GetValueUnsafe<interval_t>();
341: 		break;
342: 	case PhysicalType::VARCHAR:
343: 		((string_t *)data)[index] = StringVector::AddStringOrBlob(*this, StringValue::Get(val));
344: 		break;
345: 	case PhysicalType::STRUCT: {
346: 		D_ASSERT(GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR);
347: 
348: 		auto &children = StructVector::GetEntries(*this);
349: 		auto &val_children = StructValue::GetChildren(val);
350: 		D_ASSERT(val.IsNull() || children.size() == val_children.size());
351: 		for (size_t i = 0; i < children.size(); i++) {
352: 			auto &vec_child = children[i];
353: 			if (!val.IsNull()) {
354: 				auto &struct_child = val_children[i];
355: 				vec_child->SetValue(index, struct_child);
356: 			} else {
357: 				vec_child->SetValue(index, Value());
358: 			}
359: 		}
360: 		break;
361: 	}
362: 	case PhysicalType::LIST: {
363: 		auto offset = ListVector::GetListSize(*this);
364: 		auto &val_children = ListValue::GetChildren(val);
365: 		if (!val_children.empty()) {
366: 			for (idx_t i = 0; i < val_children.size(); i++) {
367: 				ListVector::PushBack(*this, val_children[i]);
368: 			}
369: 		}
370: 		//! now set the pointer
371: 		auto &entry = ((list_entry_t *)data)[index];
372: 		entry.length = val_children.size();
373: 		entry.offset = offset;
374: 		break;
375: 	}
376: 	default:
377: 		throw InternalException("Unimplemented type for Vector::SetValue");
378: 	}
379: }
380: 
381: Value Vector::GetValue(idx_t index) const {
382: 	switch (GetVectorType()) {
383: 	case VectorType::CONSTANT_VECTOR:
384: 		index = 0;
385: 		break;
386: 	case VectorType::FLAT_VECTOR:
387: 		break;
388: 		// dictionary: apply dictionary and forward to child
389: 	case VectorType::DICTIONARY_VECTOR: {
390: 		auto &sel_vector = DictionaryVector::SelVector(*this);
391: 		auto &child = DictionaryVector::Child(*this);
392: 		return child.GetValue(sel_vector.get_index(index));
393: 	}
394: 	case VectorType::SEQUENCE_VECTOR: {
395: 		int64_t start, increment;
396: 		SequenceVector::GetSequence(*this, start, increment);
397: 		return Value::Numeric(GetType(), start + increment * index);
398: 	}
399: 	default:
400: 		throw InternalException("Unimplemented vector type for Vector::GetValue");
401: 	}
402: 
403: 	if (!validity.RowIsValid(index)) {
404: 		return Value(GetType());
405: 	}
406: 	switch (GetType().id()) {
407: 	case LogicalTypeId::BOOLEAN:
408: 		return Value::BOOLEAN(((bool *)data)[index]);
409: 	case LogicalTypeId::TINYINT:
410: 		return Value::TINYINT(((int8_t *)data)[index]);
411: 	case LogicalTypeId::SMALLINT:
412: 		return Value::SMALLINT(((int16_t *)data)[index]);
413: 	case LogicalTypeId::INTEGER:
414: 		return Value::INTEGER(((int32_t *)data)[index]);
415: 	case LogicalTypeId::DATE:
416: 		return Value::DATE(((date_t *)data)[index]);
417: 	case LogicalTypeId::TIME:
418: 		return Value::TIME(((dtime_t *)data)[index]);
419: 	case LogicalTypeId::TIME_TZ:
420: 		return Value::TIMETZ(((dtime_t *)data)[index]);
421: 	case LogicalTypeId::BIGINT:
422: 		return Value::BIGINT(((int64_t *)data)[index]);
423: 	case LogicalTypeId::UTINYINT:
424: 		return Value::UTINYINT(((uint8_t *)data)[index]);
425: 	case LogicalTypeId::USMALLINT:
426: 		return Value::USMALLINT(((uint16_t *)data)[index]);
427: 	case LogicalTypeId::UINTEGER:
428: 		return Value::UINTEGER(((uint32_t *)data)[index]);
429: 	case LogicalTypeId::UBIGINT:
430: 		return Value::UBIGINT(((uint64_t *)data)[index]);
431: 	case LogicalTypeId::TIMESTAMP:
432: 		return Value::TIMESTAMP(((timestamp_t *)data)[index]);
433: 	case LogicalTypeId::TIMESTAMP_NS:
434: 		return Value::TIMESTAMPNS(((timestamp_t *)data)[index]);
435: 	case LogicalTypeId::TIMESTAMP_MS:
436: 		return Value::TIMESTAMPMS(((timestamp_t *)data)[index]);
437: 	case LogicalTypeId::TIMESTAMP_SEC:
438: 		return Value::TIMESTAMPSEC(((timestamp_t *)data)[index]);
439: 	case LogicalTypeId::TIMESTAMP_TZ:
440: 		return Value::TIMESTAMPTZ(((timestamp_t *)data)[index]);
441: 	case LogicalTypeId::HUGEINT:
442: 		return Value::HUGEINT(((hugeint_t *)data)[index]);
443: 	case LogicalTypeId::UUID:
444: 		return Value::UUID(((hugeint_t *)data)[index]);
445: 	case LogicalTypeId::DECIMAL: {
446: 		auto width = DecimalType::GetWidth(GetType());
447: 		auto scale = DecimalType::GetScale(GetType());
448: 		switch (GetType().InternalType()) {
449: 		case PhysicalType::INT16:
450: 			return Value::DECIMAL(((int16_t *)data)[index], width, scale);
451: 		case PhysicalType::INT32:
452: 			return Value::DECIMAL(((int32_t *)data)[index], width, scale);
453: 		case PhysicalType::INT64:
454: 			return Value::DECIMAL(((int64_t *)data)[index], width, scale);
455: 		case PhysicalType::INT128:
456: 			return Value::DECIMAL(((hugeint_t *)data)[index], width, scale);
457: 		default:
458: 			throw InternalException("Widths bigger than 38 are not supported");
459: 		}
460: 	}
461: 	case LogicalTypeId::ENUM: {
462: 		switch (type.InternalType()) {
463: 		case PhysicalType::UINT8:
464: 			return Value::ENUM(((uint8_t *)data)[index], GetType());
465: 		case PhysicalType::UINT16:
466: 			return Value::ENUM(((uint16_t *)data)[index], GetType());
467: 		case PhysicalType::UINT32:
468: 			return Value::ENUM(((uint32_t *)data)[index], GetType());
469: 		default:
470: 			throw InternalException("ENUM can only have unsigned integers (except UINT64) as physical types");
471: 		}
472: 	}
473: 	case LogicalTypeId::HASH:
474: 		return Value::HASH(((hash_t *)data)[index]);
475: 	case LogicalTypeId::POINTER:
476: 		return Value::POINTER(((uintptr_t *)data)[index]);
477: 	case LogicalTypeId::FLOAT:
478: 		return Value::FLOAT(((float *)data)[index]);
479: 	case LogicalTypeId::DOUBLE:
480: 		return Value::DOUBLE(((double *)data)[index]);
481: 	case LogicalTypeId::INTERVAL:
482: 		return Value::INTERVAL(((interval_t *)data)[index]);
483: 	case LogicalTypeId::VARCHAR: {
484: 		auto str = ((string_t *)data)[index];
485: 		return Value(str.GetString());
486: 	}
487: 	case LogicalTypeId::JSON: {
488: 		auto str = ((string_t *)data)[index];
489: 		return Value::JSON(str.GetString());
490: 	}
491: 	case LogicalTypeId::AGGREGATE_STATE:
492: 	case LogicalTypeId::BLOB: {
493: 		auto str = ((string_t *)data)[index];
494: 		return Value::BLOB((const_data_ptr_t)str.GetDataUnsafe(), str.GetSize());
495: 	}
496: 	case LogicalTypeId::MAP: {
497: 		auto &child_entries = StructVector::GetEntries(*this);
498: 		Value key = child_entries[0]->GetValue(index);
499: 		Value value = child_entries[1]->GetValue(index);
500: 		return Value::MAP(move(key), move(value));
501: 	}
502: 	case LogicalTypeId::STRUCT: {
503: 		// we can derive the value schema from the vector schema
504: 		auto &child_entries = StructVector::GetEntries(*this);
505: 		child_list_t<Value> children;
506: 		for (idx_t child_idx = 0; child_idx < child_entries.size(); child_idx++) {
507: 			auto &struct_child = child_entries[child_idx];
508: 			children.push_back(
509: 			    make_pair(StructType::GetChildName(GetType(), child_idx), struct_child->GetValue(index)));
510: 		}
511: 		return Value::STRUCT(move(children));
512: 	}
513: 	case LogicalTypeId::LIST: {
514: 		auto offlen = ((list_entry_t *)data)[index];
515: 		auto &child_vec = ListVector::GetEntry(*this);
516: 		vector<Value> children;
517: 		for (idx_t i = offlen.offset; i < offlen.offset + offlen.length; i++) {
518: 			children.push_back(child_vec.GetValue(i));
519: 		}
520: 		return Value::LIST(ListType::GetChildType(GetType()), move(children));
521: 	}
522: 	default:
523: 		throw InternalException("Unimplemented type for value access");
524: 	}
525: }
526: 
527: // LCOV_EXCL_START
528: string VectorTypeToString(VectorType type) {
529: 	switch (type) {
530: 	case VectorType::FLAT_VECTOR:
531: 		return "FLAT";
532: 	case VectorType::SEQUENCE_VECTOR:
533: 		return "SEQUENCE";
534: 	case VectorType::DICTIONARY_VECTOR:
535: 		return "DICTIONARY";
536: 	case VectorType::CONSTANT_VECTOR:
537: 		return "CONSTANT";
538: 	default:
539: 		return "UNKNOWN";
540: 	}
541: }
542: 
543: string Vector::ToString(idx_t count) const {
544: 	string retval =
545: 	    VectorTypeToString(GetVectorType()) + " " + GetType().ToString() + ": " + to_string(count) + " = [ ";
546: 	switch (GetVectorType()) {
547: 	case VectorType::FLAT_VECTOR:
548: 	case VectorType::DICTIONARY_VECTOR:
549: 		for (idx_t i = 0; i < count; i++) {
550: 			retval += GetValue(i).ToString() + (i == count - 1 ? "" : ", ");
551: 		}
552: 		break;
553: 	case VectorType::CONSTANT_VECTOR:
554: 		retval += GetValue(0).ToString();
555: 		break;
556: 	case VectorType::SEQUENCE_VECTOR: {
557: 		int64_t start, increment;
558: 		SequenceVector::GetSequence(*this, start, increment);
559: 		for (idx_t i = 0; i < count; i++) {
560: 			retval += to_string(start + increment * i) + (i == count - 1 ? "" : ", ");
561: 		}
562: 		break;
563: 	}
564: 	default:
565: 		retval += "UNKNOWN VECTOR TYPE";
566: 		break;
567: 	}
568: 	retval += "]";
569: 	return retval;
570: }
571: 
572: void Vector::Print(idx_t count) {
573: 	Printer::Print(ToString(count));
574: }
575: 
576: string Vector::ToString() const {
577: 	string retval = VectorTypeToString(GetVectorType()) + " " + GetType().ToString() + ": (UNKNOWN COUNT) [ ";
578: 	switch (GetVectorType()) {
579: 	case VectorType::FLAT_VECTOR:
580: 	case VectorType::DICTIONARY_VECTOR:
581: 		break;
582: 	case VectorType::CONSTANT_VECTOR:
583: 		retval += GetValue(0).ToString();
584: 		break;
585: 	case VectorType::SEQUENCE_VECTOR: {
586: 		break;
587: 	}
588: 	default:
589: 		retval += "UNKNOWN VECTOR TYPE";
590: 		break;
591: 	}
592: 	retval += "]";
593: 	return retval;
594: }
595: 
596: void Vector::Print() {
597: 	Printer::Print(ToString());
598: }
599: // LCOV_EXCL_STOP
600: 
601: template <class T>
602: static void TemplatedFlattenConstantVector(data_ptr_t data, data_ptr_t old_data, idx_t count) {
603: 	auto constant = Load<T>(old_data);
604: 	auto output = (T *)data;
605: 	for (idx_t i = 0; i < count; i++) {
606: 		output[i] = constant;
607: 	}
608: }
609: 
610: void Vector::Normalify(idx_t count) {
611: 	switch (GetVectorType()) {
612: 	case VectorType::FLAT_VECTOR:
613: 		// already a flat vector
614: 		break;
615: 	case VectorType::DICTIONARY_VECTOR: {
616: 		// create a new flat vector of this type
617: 		Vector other(GetType());
618: 		// now copy the data of this vector to the other vector, removing the selection vector in the process
619: 		VectorOperations::Copy(*this, other, count, 0, 0);
620: 		// create a reference to the data in the other vector
621: 		this->Reference(other);
622: 		break;
623: 	}
624: 	case VectorType::CONSTANT_VECTOR: {
625: 		bool is_null = ConstantVector::IsNull(*this);
626: 		// allocate a new buffer for the vector
627: 		auto old_buffer = move(buffer);
628: 		auto old_data = data;
629: 		buffer = VectorBuffer::CreateStandardVector(type, MaxValue<idx_t>(STANDARD_VECTOR_SIZE, count));
630: 		data = buffer->GetData();
631: 		vector_type = VectorType::FLAT_VECTOR;
632: 		if (is_null) {
633: 			// constant NULL, set nullmask
634: 			validity.EnsureWritable();
635: 			validity.SetAllInvalid(count);
636: 			return;
637: 		}
638: 		// non-null constant: have to repeat the constant
639: 		switch (GetType().InternalType()) {
640: 		case PhysicalType::BOOL:
641: 			TemplatedFlattenConstantVector<bool>(data, old_data, count);
642: 			break;
643: 		case PhysicalType::INT8:
644: 			TemplatedFlattenConstantVector<int8_t>(data, old_data, count);
645: 			break;
646: 		case PhysicalType::INT16:
647: 			TemplatedFlattenConstantVector<int16_t>(data, old_data, count);
648: 			break;
649: 		case PhysicalType::INT32:
650: 			TemplatedFlattenConstantVector<int32_t>(data, old_data, count);
651: 			break;
652: 		case PhysicalType::INT64:
653: 			TemplatedFlattenConstantVector<int64_t>(data, old_data, count);
654: 			break;
655: 		case PhysicalType::UINT8:
656: 			TemplatedFlattenConstantVector<uint8_t>(data, old_data, count);
657: 			break;
658: 		case PhysicalType::UINT16:
659: 			TemplatedFlattenConstantVector<uint16_t>(data, old_data, count);
660: 			break;
661: 		case PhysicalType::UINT32:
662: 			TemplatedFlattenConstantVector<uint32_t>(data, old_data, count);
663: 			break;
664: 		case PhysicalType::UINT64:
665: 			TemplatedFlattenConstantVector<uint64_t>(data, old_data, count);
666: 			break;
667: 		case PhysicalType::INT128:
668: 			TemplatedFlattenConstantVector<hugeint_t>(data, old_data, count);
669: 			break;
670: 		case PhysicalType::FLOAT:
671: 			TemplatedFlattenConstantVector<float>(data, old_data, count);
672: 			break;
673: 		case PhysicalType::DOUBLE:
674: 			TemplatedFlattenConstantVector<double>(data, old_data, count);
675: 			break;
676: 		case PhysicalType::INTERVAL:
677: 			TemplatedFlattenConstantVector<interval_t>(data, old_data, count);
678: 			break;
679: 		case PhysicalType::VARCHAR:
680: 			TemplatedFlattenConstantVector<string_t>(data, old_data, count);
681: 			break;
682: 		case PhysicalType::LIST: {
683: 			TemplatedFlattenConstantVector<list_entry_t>(data, old_data, count);
684: 			break;
685: 		}
686: 		case PhysicalType::STRUCT: {
687: 			auto normalified_buffer = make_unique<VectorStructBuffer>();
688: 
689: 			auto &new_children = normalified_buffer->GetChildren();
690: 
691: 			auto &child_entries = StructVector::GetEntries(*this);
692: 			for (auto &child : child_entries) {
693: 				D_ASSERT(child->GetVectorType() == VectorType::CONSTANT_VECTOR);
694: 				auto vector = make_unique<Vector>(*child);
695: 				vector->Normalify(count);
696: 				new_children.push_back(move(vector));
697: 			}
698: 			auxiliary = move(normalified_buffer);
699: 		} break;
700: 		default:
701: 			throw InternalException("Unimplemented type for VectorOperations::Normalify");
702: 		}
703: 		break;
704: 	}
705: 	case VectorType::SEQUENCE_VECTOR: {
706: 		int64_t start, increment;
707: 		SequenceVector::GetSequence(*this, start, increment);
708: 
709: 		buffer = VectorBuffer::CreateStandardVector(GetType());
710: 		data = buffer->GetData();
711: 		VectorOperations::GenerateSequence(*this, count, start, increment);
712: 		break;
713: 	}
714: 	default:
715: 		throw InternalException("Unimplemented type for normalify");
716: 	}
717: }
718: 
719: void Vector::Normalify(const SelectionVector &sel, idx_t count) {
720: 	switch (GetVectorType()) {
721: 	case VectorType::FLAT_VECTOR:
722: 		// already a flat vector
723: 		break;
724: 	case VectorType::SEQUENCE_VECTOR: {
725: 		int64_t start, increment;
726: 		SequenceVector::GetSequence(*this, start, increment);
727: 
728: 		buffer = VectorBuffer::CreateStandardVector(GetType());
729: 		data = buffer->GetData();
730: 		VectorOperations::GenerateSequence(*this, count, sel, start, increment);
731: 		break;
732: 	}
733: 	default:
734: 		throw InternalException("Unimplemented type for normalify with selection vector");
735: 	}
736: }
737: 
738: void Vector::Orrify(idx_t count, VectorData &data) {
739: 	switch (GetVectorType()) {
740: 	case VectorType::DICTIONARY_VECTOR: {
741: 		auto &sel = DictionaryVector::SelVector(*this);
742: 		auto &child = DictionaryVector::Child(*this);
743: 		if (child.GetVectorType() == VectorType::FLAT_VECTOR) {
744: 			data.sel = &sel;
745: 			data.data = FlatVector::GetData(child);
746: 			data.validity = FlatVector::Validity(child);
747: 		} else {
748: 			// dictionary with non-flat child: create a new reference to the child and normalify it
749: 			Vector child_vector(child);
750: 			child_vector.Normalify(sel, count);
751: 			auto new_aux = make_buffer<VectorChildBuffer>(move(child_vector));
752: 
753: 			data.sel = &sel;
754: 			data.data = FlatVector::GetData(new_aux->data);
755: 			data.validity = FlatVector::Validity(new_aux->data);
756: 			this->auxiliary = move(new_aux);
757: 		}
758: 		break;
759: 	}
760: 	case VectorType::CONSTANT_VECTOR:
761: 		data.sel = ConstantVector::ZeroSelectionVector(count, data.owned_sel);
762: 		data.data = ConstantVector::GetData(*this);
763: 		data.validity = ConstantVector::Validity(*this);
764: 		break;
765: 	default:
766: 		Normalify(count);
767: 		data.sel = FlatVector::IncrementalSelectionVector(count, data.owned_sel);
768: 		data.data = FlatVector::GetData(*this);
769: 		data.validity = FlatVector::Validity(*this);
770: 		break;
771: 	}
772: }
773: 
774: void Vector::Sequence(int64_t start, int64_t increment) {
775: 	this->vector_type = VectorType::SEQUENCE_VECTOR;
776: 	this->buffer = make_buffer<VectorBuffer>(sizeof(int64_t) * 2);
777: 	auto data = (int64_t *)buffer->GetData();
778: 	data[0] = start;
779: 	data[1] = increment;
780: 	validity.Reset();
781: 	auxiliary.reset();
782: }
783: 
784: void Vector::Serialize(idx_t count, Serializer &serializer) {
785: 	auto &type = GetType();
786: 
787: 	VectorData vdata;
788: 	Orrify(count, vdata);
789: 
790: 	const auto write_validity = (count > 0) && !vdata.validity.AllValid();
791: 	serializer.Write<bool>(write_validity);
792: 	if (write_validity) {
793: 		ValidityMask flat_mask(count);
794: 		for (idx_t i = 0; i < count; ++i) {
795: 			auto row_idx = vdata.sel->get_index(i);
796: 			flat_mask.Set(i, vdata.validity.RowIsValid(row_idx));
797: 		}
798: 		serializer.WriteData((const_data_ptr_t)flat_mask.GetData(), flat_mask.ValidityMaskSize(count));
799: 	}
800: 	if (TypeIsConstantSize(type.InternalType())) {
801: 		// constant size type: simple copy
802: 		idx_t write_size = GetTypeIdSize(type.InternalType()) * count;
803: 		auto ptr = unique_ptr<data_t[]>(new data_t[write_size]);
804: 		VectorOperations::WriteToStorage(*this, count, ptr.get());
805: 		serializer.WriteData(ptr.get(), write_size);
806: 	} else {
807: 		switch (type.InternalType()) {
808: 		case PhysicalType::VARCHAR: {
809: 			auto strings = (string_t *)vdata.data;
810: 			for (idx_t i = 0; i < count; i++) {
811: 				auto idx = vdata.sel->get_index(i);
812: 				auto source = !vdata.validity.RowIsValid(idx) ? NullValue<string_t>() : strings[idx];
813: 				serializer.WriteStringLen((const_data_ptr_t)source.GetDataUnsafe(), source.GetSize());
814: 			}
815: 			break;
816: 		}
817: 		case PhysicalType::STRUCT: {
818: 			Normalify(count);
819: 			auto &entries = StructVector::GetEntries(*this);
820: 			for (auto &entry : entries) {
821: 				entry->Serialize(count, serializer);
822: 			}
823: 			break;
824: 		}
825: 		case PhysicalType::LIST: {
826: 			auto &child = ListVector::GetEntry(*this);
827: 			auto list_size = ListVector::GetListSize(*this);
828: 
829: 			// serialize the list entries in a flat array
830: 			auto data = unique_ptr<list_entry_t[]>(new list_entry_t[count]);
831: 			auto source_array = (list_entry_t *)vdata.data;
832: 			for (idx_t i = 0; i < count; i++) {
833: 				auto idx = vdata.sel->get_index(i);
834: 				auto source = source_array[idx];
835: 				data[i].offset = source.offset;
836: 				data[i].length = source.length;
837: 			}
838: 
839: 			// write the list size
840: 			serializer.Write<idx_t>(list_size);
841: 			serializer.WriteData((data_ptr_t)data.get(), count * sizeof(list_entry_t));
842: 
843: 			child.Serialize(list_size, serializer);
844: 			break;
845: 		}
846: 		default:
847: 			throw InternalException("Unimplemented variable width type for Vector::Serialize!");
848: 		}
849: 	}
850: }
851: 
852: void Vector::Deserialize(idx_t count, Deserializer &source) {
853: 	auto &type = GetType();
854: 
855: 	auto &validity = FlatVector::Validity(*this);
856: 	validity.Reset();
857: 	const auto has_validity = source.Read<bool>();
858: 	if (has_validity) {
859: 		validity.Initialize(count);
860: 		source.ReadData((data_ptr_t)validity.GetData(), validity.ValidityMaskSize(count));
861: 	}
862: 
863: 	if (TypeIsConstantSize(type.InternalType())) {
864: 		// constant size type: read fixed amount of data from
865: 		auto column_size = GetTypeIdSize(type.InternalType()) * count;
866: 		auto ptr = unique_ptr<data_t[]>(new data_t[column_size]);
867: 		source.ReadData(ptr.get(), column_size);
868: 
869: 		VectorOperations::ReadFromStorage(ptr.get(), count, *this);
870: 	} else {
871: 		switch (type.InternalType()) {
872: 		case PhysicalType::VARCHAR: {
873: 			auto strings = FlatVector::GetData<string_t>(*this);
874: 			for (idx_t i = 0; i < count; i++) {
875: 				// read the strings
876: 				auto str = source.Read<string>();
877: 				// now add the string to the StringHeap of the vector
878: 				// and write the pointer into the vector
879: 				if (validity.RowIsValid(i)) {
880: 					strings[i] = StringVector::AddStringOrBlob(*this, str);
881: 				}
882: 			}
883: 			break;
884: 		}
885: 		case PhysicalType::STRUCT: {
886: 			auto &entries = StructVector::GetEntries(*this);
887: 			for (auto &entry : entries) {
888: 				entry->Deserialize(count, source);
889: 			}
890: 			break;
891: 		}
892: 		case PhysicalType::LIST: {
893: 			// read the list size
894: 			auto list_size = source.Read<idx_t>();
895: 			ListVector::Reserve(*this, list_size);
896: 			ListVector::SetListSize(*this, list_size);
897: 
898: 			// read the list entry
899: 			auto list_entries = FlatVector::GetData(*this);
900: 			source.ReadData(list_entries, count * sizeof(list_entry_t));
901: 
902: 			// deserialize the child vector
903: 			auto &child = ListVector::GetEntry(*this);
904: 			child.Deserialize(list_size, source);
905: 
906: 			break;
907: 		}
908: 		default:
909: 			throw InternalException("Unimplemented variable width type for Vector::Deserialize!");
910: 		}
911: 	}
912: }
913: 
914: void Vector::SetVectorType(VectorType vector_type_p) {
915: 	this->vector_type = vector_type_p;
916: 	if (TypeIsConstantSize(GetType().InternalType()) &&
917: 	    (GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR)) {
918: 		auxiliary.reset();
919: 	}
920: 	if (vector_type == VectorType::CONSTANT_VECTOR && GetType().InternalType() == PhysicalType::STRUCT) {
921: 		auto &entries = StructVector::GetEntries(*this);
922: 		for (auto &entry : entries) {
923: 			entry->SetVectorType(vector_type);
924: 		}
925: 	}
926: }
927: 
928: void Vector::UTFVerify(const SelectionVector &sel, idx_t count) {
929: #ifdef DEBUG
930: 	if (count == 0) {
931: 		return;
932: 	}
933: 	if (GetType().InternalType() == PhysicalType::VARCHAR) {
934: 		// we just touch all the strings and let the sanitizer figure out if any
935: 		// of them are deallocated/corrupt
936: 		switch (GetVectorType()) {
937: 		case VectorType::CONSTANT_VECTOR: {
938: 			auto string = ConstantVector::GetData<string_t>(*this);
939: 			if (!ConstantVector::IsNull(*this)) {
940: 				string->Verify();
941: 			}
942: 			break;
943: 		}
944: 		case VectorType::FLAT_VECTOR: {
945: 			auto strings = FlatVector::GetData<string_t>(*this);
946: 			for (idx_t i = 0; i < count; i++) {
947: 				auto oidx = sel.get_index(i);
948: 				if (validity.RowIsValid(oidx)) {
949: 					strings[oidx].Verify();
950: 				}
951: 			}
952: 			break;
953: 		}
954: 		default:
955: 			break;
956: 		}
957: 	}
958: #endif
959: }
960: 
961: void Vector::UTFVerify(idx_t count) {
962: 	SelectionVector owned_sel;
963: 	auto flat_sel = FlatVector::IncrementalSelectionVector(count, owned_sel);
964: 
965: 	UTFVerify(*flat_sel, count);
966: }
967: 
968: void Vector::Verify(const SelectionVector &sel, idx_t count) {
969: #ifdef DEBUG
970: 	if (count == 0) {
971: 		return;
972: 	}
973: 	if (GetVectorType() == VectorType::DICTIONARY_VECTOR) {
974: 		auto &child = DictionaryVector::Child(*this);
975: 		D_ASSERT(child.GetVectorType() != VectorType::DICTIONARY_VECTOR);
976: 		auto &dict_sel = DictionaryVector::SelVector(*this);
977: 		// merge the selection vectors and verify the child
978: 		auto new_buffer = dict_sel.Slice(sel, count);
979: 		SelectionVector new_sel(new_buffer);
980: 		child.Verify(new_sel, count);
981: 		return;
982: 	}
983: 	if (TypeIsConstantSize(GetType().InternalType()) &&
984: 	    (GetVectorType() == VectorType::CONSTANT_VECTOR || GetVectorType() == VectorType::FLAT_VECTOR)) {
985: 		D_ASSERT(!auxiliary);
986: 	}
987: 	if (GetType().InternalType() == PhysicalType::DOUBLE) {
988: 		// verify that there are no INF or NAN values
989: 		switch (GetVectorType()) {
990: 		case VectorType::CONSTANT_VECTOR: {
991: 			auto dbl = ConstantVector::GetData<double>(*this);
992: 			if (!ConstantVector::IsNull(*this)) {
993: 				D_ASSERT(Value::DoubleIsValid(*dbl));
994: 			}
995: 			break;
996: 		}
997: 		case VectorType::FLAT_VECTOR: {
998: 			auto doubles = FlatVector::GetData<double>(*this);
999: 			for (idx_t i = 0; i < count; i++) {
1000: 				auto oidx = sel.get_index(i);
1001: 				if (validity.RowIsValid(oidx)) {
1002: 					D_ASSERT(Value::DoubleIsValid(doubles[oidx]));
1003: 				}
1004: 			}
1005: 			break;
1006: 		}
1007: 		default:
1008: 			break;
1009: 		}
1010: 	}
1011: 	if (GetType().id() == LogicalTypeId::VARCHAR || GetType().id() == LogicalTypeId::JSON) {
1012: 		// verify that there are no '\0' bytes in string values
1013: 		switch (GetVectorType()) {
1014: 		case VectorType::FLAT_VECTOR: {
1015: 			auto strings = FlatVector::GetData<string_t>(*this);
1016: 			for (idx_t i = 0; i < count; i++) {
1017: 				auto oidx = sel.get_index(i);
1018: 				if (validity.RowIsValid(oidx)) {
1019: 					strings[oidx].VerifyNull();
1020: 				}
1021: 			}
1022: 			break;
1023: 		}
1024: 		default:
1025: 			break;
1026: 		}
1027: 	}
1028: 
1029: 	if (GetType().InternalType() == PhysicalType::STRUCT) {
1030: 		auto &child_types = StructType::GetChildTypes(GetType());
1031: 		D_ASSERT(!child_types.empty());
1032: 		if (GetVectorType() == VectorType::FLAT_VECTOR || GetVectorType() == VectorType::CONSTANT_VECTOR) {
1033: 			// create a selection vector of the non-null entries of the struct vector
1034: 			auto &children = StructVector::GetEntries(*this);
1035: 			D_ASSERT(child_types.size() == children.size());
1036: 			for (idx_t child_idx = 0; child_idx < children.size(); child_idx++) {
1037: 				if (GetVectorType() == VectorType::CONSTANT_VECTOR) {
1038: 					D_ASSERT(children[child_idx]->GetVectorType() == VectorType::CONSTANT_VECTOR);
1039: 					if (ConstantVector::IsNull(*this)) {
1040: 						D_ASSERT(ConstantVector::IsNull(*children[child_idx]));
1041: 					}
1042: 				} else if (GetVectorType() == VectorType::FLAT_VECTOR &&
1043: 				           children[child_idx]->GetVectorType() == VectorType::FLAT_VECTOR) {
1044: 					// for any NULL entry in the struct, the child should be NULL as well
1045: 					auto &validity = FlatVector::Validity(*this);
1046: 					auto &child_validity = FlatVector::Validity(*children[child_idx]);
1047: 					for (idx_t i = 0; i < count; i++) {
1048: 						auto index = sel.get_index(i);
1049: 						if (!validity.RowIsValid(index)) {
1050: 							D_ASSERT(!child_validity.RowIsValid(index));
1051: 						}
1052: 					}
1053: 				}
1054: 				D_ASSERT(children[child_idx]->GetType() == child_types[child_idx].second);
1055: 				children[child_idx]->Verify(sel, count);
1056: 			}
1057: 		}
1058: 	}
1059: 
1060: 	if (GetType().InternalType() == PhysicalType::LIST) {
1061: 		if (GetVectorType() == VectorType::CONSTANT_VECTOR) {
1062: 			if (!ConstantVector::IsNull(*this)) {
1063: 				auto &child = ListVector::GetEntry(*this);
1064: 				SelectionVector child_sel(ListVector::GetListSize(*this));
1065: 				idx_t child_count = 0;
1066: 				auto le = ConstantVector::GetData<list_entry_t>(*this);
1067: 				D_ASSERT(le->offset + le->length <= ListVector::GetListSize(*this));
1068: 				for (idx_t k = 0; k < le->length; k++) {
1069: 					child_sel.set_index(child_count++, le->offset + k);
1070: 				}
1071: 				child.Verify(child_sel, child_count);
1072: 			}
1073: 		} else if (GetVectorType() == VectorType::FLAT_VECTOR) {
1074: 			auto &child = ListVector::GetEntry(*this);
1075: 			auto child_size = ListVector::GetListSize(*this);
1076: 			auto list_data = FlatVector::GetData<list_entry_t>(*this);
1077: 			idx_t total_size = 0;
1078: 			for (idx_t i = 0; i < count; i++) {
1079: 				auto idx = sel.get_index(i);
1080: 				auto &le = list_data[idx];
1081: 				if (validity.RowIsValid(idx)) {
1082: 					D_ASSERT(le.offset + le.length <= child_size);
1083: 					total_size += le.length;
1084: 				}
1085: 			}
1086: 			SelectionVector child_sel(total_size);
1087: 			idx_t child_count = 0;
1088: 			for (idx_t i = 0; i < count; i++) {
1089: 				auto idx = sel.get_index(i);
1090: 				auto &le = list_data[idx];
1091: 				if (validity.RowIsValid(idx)) {
1092: 					D_ASSERT(le.offset + le.length <= child_size);
1093: 					for (idx_t k = 0; k < le.length; k++) {
1094: 						child_sel.set_index(child_count++, le.offset + k);
1095: 					}
1096: 				}
1097: 			}
1098: 			child.Verify(child_sel, child_count);
1099: 		}
1100: 	}
1101: #endif
1102: }
1103: 
1104: void Vector::Verify(idx_t count) {
1105: 	SelectionVector owned_sel;
1106: 	auto flat_sel = FlatVector::IncrementalSelectionVector(count, owned_sel);
1107: 	Verify(*flat_sel, count);
1108: }
1109: 
1110: void FlatVector::SetNull(Vector &vector, idx_t idx, bool is_null) {
1111: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR);
1112: 	vector.validity.Set(idx, !is_null);
1113: 	if (is_null && vector.GetType().InternalType() == PhysicalType::STRUCT) {
1114: 		// set all child entries to null as well
1115: 		auto &entries = StructVector::GetEntries(vector);
1116: 		for (auto &entry : entries) {
1117: 			FlatVector::SetNull(*entry, idx, is_null);
1118: 		}
1119: 	}
1120: }
1121: 
1122: void ConstantVector::SetNull(Vector &vector, bool is_null) {
1123: 	D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1124: 	vector.validity.Set(0, !is_null);
1125: 	if (is_null && vector.GetType().InternalType() == PhysicalType::STRUCT) {
1126: 		// set all child entries to null as well
1127: 		auto &entries = StructVector::GetEntries(vector);
1128: 		for (auto &entry : entries) {
1129: 			entry->SetVectorType(VectorType::CONSTANT_VECTOR);
1130: 			ConstantVector::SetNull(*entry, is_null);
1131: 		}
1132: 	}
1133: }
1134: 
1135: const SelectionVector *FlatVector::IncrementalSelectionVector(idx_t count, SelectionVector &owned_sel) {
1136: 	if (count <= STANDARD_VECTOR_SIZE) {
1137: 		return FlatVector::IncrementalSelectionVector();
1138: 	}
1139: 	owned_sel.Initialize(count);
1140: 	for (idx_t i = 0; i < count; i++) {
1141: 		owned_sel.set_index(i, i);
1142: 	}
1143: 	return &owned_sel;
1144: }
1145: 
1146: const SelectionVector *ConstantVector::ZeroSelectionVector(idx_t count, SelectionVector &owned_sel) {
1147: 	if (count <= STANDARD_VECTOR_SIZE) {
1148: 		return ConstantVector::ZeroSelectionVector();
1149: 	}
1150: 	owned_sel.Initialize(count);
1151: 	for (idx_t i = 0; i < count; i++) {
1152: 		owned_sel.set_index(i, 0);
1153: 	}
1154: 	return &owned_sel;
1155: }
1156: 
1157: void ConstantVector::Reference(Vector &vector, Vector &source, idx_t position, idx_t count) {
1158: 	D_ASSERT(position < count);
1159: 	auto &source_type = source.GetType();
1160: 	switch (source_type.InternalType()) {
1161: 	case PhysicalType::LIST: {
1162: 		// retrieve the list entry from the source vector
1163: 		VectorData vdata;
1164: 		source.Orrify(count, vdata);
1165: 
1166: 		auto list_index = vdata.sel->get_index(position);
1167: 		if (!vdata.validity.RowIsValid(list_index)) {
1168: 			// list is null: create null value
1169: 			Value null_value(source_type);
1170: 			vector.Reference(null_value);
1171: 			break;
1172: 		}
1173: 
1174: 		auto list_data = (list_entry_t *)vdata.data;
1175: 		auto list_entry = list_data[list_index];
1176: 
1177: 		// add the list entry as the first element of "vector"
1178: 		// FIXME: we only need to allocate space for 1 tuple here
1179: 		auto target_data = FlatVector::GetData<list_entry_t>(vector);
1180: 		target_data[0] = list_entry;
1181: 
1182: 		// create a reference to the child list of the source vector
1183: 		auto &child = ListVector::GetEntry(vector);
1184: 		child.Reference(ListVector::GetEntry(source));
1185: 
1186: 		ListVector::SetListSize(vector, ListVector::GetListSize(source));
1187: 		vector.SetVectorType(VectorType::CONSTANT_VECTOR);
1188: 		break;
1189: 	}
1190: 	case PhysicalType::STRUCT: {
1191: 		VectorData vdata;
1192: 		source.Orrify(count, vdata);
1193: 
1194: 		auto struct_index = vdata.sel->get_index(position);
1195: 		if (!vdata.validity.RowIsValid(struct_index)) {
1196: 			// null struct: create null value
1197: 			Value null_value(source_type);
1198: 			vector.Reference(null_value);
1199: 			break;
1200: 		}
1201: 
1202: 		// struct: pass constant reference into child entries
1203: 		auto &source_entries = StructVector::GetEntries(source);
1204: 		auto &target_entries = StructVector::GetEntries(vector);
1205: 		for (idx_t i = 0; i < source_entries.size(); i++) {
1206: 			ConstantVector::Reference(*target_entries[i], *source_entries[i], position, count);
1207: 		}
1208: 		vector.SetVectorType(VectorType::CONSTANT_VECTOR);
1209: 		break;
1210: 	}
1211: 	default:
1212: 		// default behavior: get a value from the vector and reference it
1213: 		// this is not that expensive for scalar types
1214: 		auto value = source.GetValue(position);
1215: 		vector.Reference(value);
1216: 		D_ASSERT(vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1217: 		break;
1218: 	}
1219: }
1220: 
1221: string_t StringVector::AddString(Vector &vector, const char *data, idx_t len) {
1222: 	return StringVector::AddString(vector, string_t(data, len));
1223: }
1224: 
1225: string_t StringVector::AddStringOrBlob(Vector &vector, const char *data, idx_t len) {
1226: 	return StringVector::AddStringOrBlob(vector, string_t(data, len));
1227: }
1228: 
1229: string_t StringVector::AddString(Vector &vector, const char *data) {
1230: 	return StringVector::AddString(vector, string_t(data, strlen(data)));
1231: }
1232: 
1233: string_t StringVector::AddString(Vector &vector, const string &data) {
1234: 	return StringVector::AddString(vector, string_t(data.c_str(), data.size()));
1235: }
1236: 
1237: string_t StringVector::AddString(Vector &vector, string_t data) {
1238: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::VARCHAR || vector.GetType().id() == LogicalTypeId::JSON);
1239: 	if (data.IsInlined()) {
1240: 		// string will be inlined: no need to store in string heap
1241: 		return data;
1242: 	}
1243: 	if (!vector.auxiliary) {
1244: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1245: 	}
1246: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1247: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1248: 	return string_buffer.AddString(data);
1249: }
1250: 
1251: string_t StringVector::AddStringOrBlob(Vector &vector, string_t data) {
1252: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1253: 	if (data.IsInlined()) {
1254: 		// string will be inlined: no need to store in string heap
1255: 		return data;
1256: 	}
1257: 	if (!vector.auxiliary) {
1258: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1259: 	}
1260: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1261: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1262: 	return string_buffer.AddBlob(data);
1263: }
1264: 
1265: string_t StringVector::EmptyString(Vector &vector, idx_t len) {
1266: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1267: 	if (len < string_t::INLINE_LENGTH) {
1268: 		return string_t(len);
1269: 	}
1270: 	if (!vector.auxiliary) {
1271: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1272: 	}
1273: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRING_BUFFER);
1274: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1275: 	return string_buffer.EmptyString(len);
1276: }
1277: 
1278: void StringVector::AddHandle(Vector &vector, unique_ptr<BufferHandle> handle) {
1279: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1280: 	if (!vector.auxiliary) {
1281: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1282: 	}
1283: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1284: 	string_buffer.AddHeapReference(make_buffer<ManagedVectorBuffer>(move(handle)));
1285: }
1286: 
1287: void StringVector::AddBuffer(Vector &vector, buffer_ptr<VectorBuffer> buffer) {
1288: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1289: 	D_ASSERT(buffer.get() != vector.auxiliary.get());
1290: 	if (!vector.auxiliary) {
1291: 		vector.auxiliary = make_buffer<VectorStringBuffer>();
1292: 	}
1293: 	auto &string_buffer = (VectorStringBuffer &)*vector.auxiliary;
1294: 	string_buffer.AddHeapReference(move(buffer));
1295: }
1296: 
1297: void StringVector::AddHeapReference(Vector &vector, Vector &other) {
1298: 	D_ASSERT(vector.GetType().InternalType() == PhysicalType::VARCHAR);
1299: 	D_ASSERT(other.GetType().InternalType() == PhysicalType::VARCHAR);
1300: 
1301: 	if (other.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1302: 		StringVector::AddHeapReference(vector, DictionaryVector::Child(other));
1303: 		return;
1304: 	}
1305: 	if (!other.auxiliary) {
1306: 		return;
1307: 	}
1308: 	StringVector::AddBuffer(vector, other.auxiliary);
1309: }
1310: 
1311: vector<unique_ptr<Vector>> &StructVector::GetEntries(Vector &vector) {
1312: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::STRUCT || vector.GetType().id() == LogicalTypeId::MAP);
1313: 	if (vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1314: 		auto &child = DictionaryVector::Child(vector);
1315: 		return StructVector::GetEntries(child);
1316: 	}
1317: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1318: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1319: 	D_ASSERT(vector.auxiliary);
1320: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::STRUCT_BUFFER);
1321: 	return ((VectorStructBuffer *)vector.auxiliary.get())->GetChildren();
1322: }
1323: 
1324: const vector<unique_ptr<Vector>> &StructVector::GetEntries(const Vector &vector) {
1325: 	return GetEntries((Vector &)vector);
1326: }
1327: 
1328: const Vector &ListVector::GetEntry(const Vector &vector) {
1329: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST);
1330: 	if (vector.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1331: 		auto &child = DictionaryVector::Child(vector);
1332: 		return ListVector::GetEntry(child);
1333: 	}
1334: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1335: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1336: 	D_ASSERT(vector.auxiliary);
1337: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::LIST_BUFFER);
1338: 	return ((VectorListBuffer *)vector.auxiliary.get())->GetChild();
1339: }
1340: 
1341: Vector &ListVector::GetEntry(Vector &vector) {
1342: 	const Vector &cvector = vector;
1343: 	return const_cast<Vector &>(ListVector::GetEntry(cvector));
1344: }
1345: 
1346: void ListVector::Reserve(Vector &vector, idx_t required_capacity) {
1347: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST);
1348: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1349: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1350: 	D_ASSERT(vector.auxiliary);
1351: 	D_ASSERT(vector.auxiliary->GetBufferType() == VectorBufferType::LIST_BUFFER);
1352: 	auto &child_buffer = *((VectorListBuffer *)vector.auxiliary.get());
1353: 	child_buffer.Reserve(required_capacity);
1354: }
1355: 
1356: template <class T>
1357: void TemplatedSearchInMap(Vector &list, T key, vector<idx_t> &offsets, bool is_key_null, idx_t offset, idx_t length) {
1358: 	auto &list_vector = ListVector::GetEntry(list);
1359: 	VectorData vector_data;
1360: 	list_vector.Orrify(ListVector::GetListSize(list), vector_data);
1361: 	auto data = (T *)vector_data.data;
1362: 	auto validity_mask = vector_data.validity;
1363: 
1364: 	if (is_key_null) {
1365: 		for (idx_t i = offset; i < offset + length; i++) {
1366: 			if (!validity_mask.RowIsValid(i)) {
1367: 				offsets.push_back(i);
1368: 			}
1369: 		}
1370: 	} else {
1371: 		for (idx_t i = offset; i < offset + length; i++) {
1372: 			if (!validity_mask.RowIsValid(i)) {
1373: 				continue;
1374: 			}
1375: 			if (key == data[i]) {
1376: 				offsets.push_back(i);
1377: 			}
1378: 		}
1379: 	}
1380: }
1381: 
1382: template <class T>
1383: void TemplatedSearchInMap(Vector &list, const Value &key, vector<idx_t> &offsets, bool is_key_null, idx_t offset,
1384:                           idx_t length) {
1385: 	TemplatedSearchInMap<T>(list, key.template GetValueUnsafe<T>(), offsets, is_key_null, offset, length);
1386: }
1387: 
1388: void SearchStringInMap(Vector &list, const string &key, vector<idx_t> &offsets, bool is_key_null, idx_t offset,
1389:                        idx_t length) {
1390: 	auto &list_vector = ListVector::GetEntry(list);
1391: 	VectorData vector_data;
1392: 	list_vector.Orrify(ListVector::GetListSize(list), vector_data);
1393: 	auto data = (string_t *)vector_data.data;
1394: 	auto validity_mask = vector_data.validity;
1395: 	if (is_key_null) {
1396: 		for (idx_t i = offset; i < offset + length; i++) {
1397: 			if (!validity_mask.RowIsValid(i)) {
1398: 				offsets.push_back(i);
1399: 			}
1400: 		}
1401: 	} else {
1402: 		string_t key_str_t(key);
1403: 		for (idx_t i = offset; i < offset + length; i++) {
1404: 			if (!validity_mask.RowIsValid(i)) {
1405: 				continue;
1406: 			}
1407: 			if (Equals::Operation<string_t>(data[i], key_str_t)) {
1408: 				offsets.push_back(i);
1409: 			}
1410: 		}
1411: 	}
1412: }
1413: 
1414: vector<idx_t> ListVector::Search(Vector &list, const Value &key, idx_t row) {
1415: 	vector<idx_t> offsets;
1416: 
1417: 	auto &list_vector = ListVector::GetEntry(list);
1418: 	auto &entry = ((list_entry_t *)list.GetData())[row];
1419: 
1420: 	switch (list_vector.GetType().InternalType()) {
1421: 	case PhysicalType::BOOL:
1422: 	case PhysicalType::INT8:
1423: 		TemplatedSearchInMap<int8_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1424: 		break;
1425: 	case PhysicalType::INT16:
1426: 		TemplatedSearchInMap<int16_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1427: 		break;
1428: 	case PhysicalType::INT32:
1429: 		TemplatedSearchInMap<int32_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1430: 		break;
1431: 	case PhysicalType::INT64:
1432: 		TemplatedSearchInMap<int64_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1433: 		break;
1434: 	case PhysicalType::INT128:
1435: 		TemplatedSearchInMap<hugeint_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1436: 		break;
1437: 	case PhysicalType::UINT8:
1438: 		TemplatedSearchInMap<uint8_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1439: 		break;
1440: 	case PhysicalType::UINT16:
1441: 		TemplatedSearchInMap<uint16_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1442: 		break;
1443: 	case PhysicalType::UINT32:
1444: 		TemplatedSearchInMap<uint32_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1445: 		break;
1446: 	case PhysicalType::UINT64:
1447: 		TemplatedSearchInMap<uint64_t>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1448: 		break;
1449: 	case PhysicalType::FLOAT:
1450: 		TemplatedSearchInMap<float>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1451: 		break;
1452: 	case PhysicalType::DOUBLE:
1453: 		TemplatedSearchInMap<double>(list, key, offsets, key.IsNull(), entry.offset, entry.length);
1454: 		break;
1455: 	case PhysicalType::VARCHAR:
1456: 		SearchStringInMap(list, StringValue::Get(key), offsets, key.IsNull(), entry.offset, entry.length);
1457: 		break;
1458: 	default:
1459: 		throw InvalidTypeException(list.GetType().id(), "Invalid type for List Vector Search");
1460: 	}
1461: 	return offsets;
1462: }
1463: 
1464: Value ListVector::GetValuesFromOffsets(Vector &list, vector<idx_t> &offsets) {
1465: 	auto &child_vec = ListVector::GetEntry(list);
1466: 	vector<Value> list_values;
1467: 	list_values.reserve(offsets.size());
1468: 	for (auto &offset : offsets) {
1469: 		list_values.push_back(child_vec.GetValue(offset));
1470: 	}
1471: 	return Value::LIST(ListType::GetChildType(list.GetType()), move(list_values));
1472: }
1473: 
1474: idx_t ListVector::GetListSize(const Vector &vec) {
1475: 	if (vec.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1476: 		auto &child = DictionaryVector::Child(vec);
1477: 		return ListVector::GetListSize(child);
1478: 	}
1479: 	D_ASSERT(vec.auxiliary);
1480: 	return ((VectorListBuffer &)*vec.auxiliary).size;
1481: }
1482: 
1483: void ListVector::ReferenceEntry(Vector &vector, Vector &other) {
1484: 	D_ASSERT(vector.GetType().id() == LogicalTypeId::LIST);
1485: 	D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR ||
1486: 	         vector.GetVectorType() == VectorType::CONSTANT_VECTOR);
1487: 	D_ASSERT(other.GetType().id() == LogicalTypeId::LIST);
1488: 	D_ASSERT(other.GetVectorType() == VectorType::FLAT_VECTOR || other.GetVectorType() == VectorType::CONSTANT_VECTOR);
1489: 	vector.auxiliary = other.auxiliary;
1490: }
1491: 
1492: void ListVector::SetListSize(Vector &vec, idx_t size) {
1493: 	if (vec.GetVectorType() == VectorType::DICTIONARY_VECTOR) {
1494: 		auto &child = DictionaryVector::Child(vec);
1495: 		ListVector::SetListSize(child, size);
1496: 	}
1497: 	((VectorListBuffer &)*vec.auxiliary).size = size;
1498: }
1499: 
1500: void ListVector::Append(Vector &target, const Vector &source, idx_t source_size, idx_t source_offset) {
1501: 	if (source_size - source_offset == 0) {
1502: 		//! Nothing to add
1503: 		return;
1504: 	}
1505: 	auto &target_buffer = (VectorListBuffer &)*target.auxiliary;
1506: 	target_buffer.Append(source, source_size, source_offset);
1507: }
1508: 
1509: void ListVector::Append(Vector &target, const Vector &source, const SelectionVector &sel, idx_t source_size,
1510:                         idx_t source_offset) {
1511: 	if (source_size - source_offset == 0) {
1512: 		//! Nothing to add
1513: 		return;
1514: 	}
1515: 	auto &target_buffer = (VectorListBuffer &)*target.auxiliary;
1516: 	target_buffer.Append(source, sel, source_size, source_offset);
1517: }
1518: 
1519: void ListVector::PushBack(Vector &target, const Value &insert) {
1520: 	auto &target_buffer = (VectorListBuffer &)*target.auxiliary;
1521: 	target_buffer.PushBack(insert);
1522: }
1523: 
1524: } // namespace duckdb
[end of src/common/types/vector.cpp]
[start of src/common/vector_operations/comparison_operators.cpp]
1: //===--------------------------------------------------------------------===//
2: // comparison_operators.cpp
3: // Description: This file contains the implementation of the comparison
4: // operations == != >= <= > <
5: //===--------------------------------------------------------------------===//
6: 
7: #include "duckdb/common/operator/comparison_operators.hpp"
8: 
9: #include "duckdb/common/vector_operations/binary_executor.hpp"
10: #include "duckdb/common/vector_operations/vector_operations.hpp"
11: 
12: namespace duckdb {
13: 
14: struct ComparisonSelector {
15: 	template <typename OP>
16: 	static idx_t Select(Vector &left, Vector &right, const SelectionVector *sel, idx_t count, SelectionVector *true_sel,
17: 	                    SelectionVector *false_sel) {
18: 		throw NotImplementedException("Unknown comparison operation!");
19: 	}
20: };
21: 
22: template <>
23: inline idx_t ComparisonSelector::Select<duckdb::Equals>(Vector &left, Vector &right, const SelectionVector *sel,
24:                                                         idx_t count, SelectionVector *true_sel,
25:                                                         SelectionVector *false_sel) {
26: 	return VectorOperations::Equals(left, right, sel, count, true_sel, false_sel);
27: }
28: 
29: template <>
30: inline idx_t ComparisonSelector::Select<duckdb::NotEquals>(Vector &left, Vector &right, const SelectionVector *sel,
31:                                                            idx_t count, SelectionVector *true_sel,
32:                                                            SelectionVector *false_sel) {
33: 	return VectorOperations::NotEquals(left, right, sel, count, true_sel, false_sel);
34: }
35: 
36: template <>
37: inline idx_t ComparisonSelector::Select<duckdb::GreaterThan>(Vector &left, Vector &right, const SelectionVector *sel,
38:                                                              idx_t count, SelectionVector *true_sel,
39:                                                              SelectionVector *false_sel) {
40: 	return VectorOperations::GreaterThan(left, right, sel, count, true_sel, false_sel);
41: }
42: 
43: template <>
44: inline idx_t ComparisonSelector::Select<duckdb::GreaterThanEquals>(Vector &left, Vector &right,
45:                                                                    const SelectionVector *sel, idx_t count,
46:                                                                    SelectionVector *true_sel,
47:                                                                    SelectionVector *false_sel) {
48: 	return VectorOperations::GreaterThanEquals(left, right, sel, count, true_sel, false_sel);
49: }
50: 
51: template <>
52: inline idx_t ComparisonSelector::Select<duckdb::LessThan>(Vector &left, Vector &right, const SelectionVector *sel,
53:                                                           idx_t count, SelectionVector *true_sel,
54:                                                           SelectionVector *false_sel) {
55: 	return VectorOperations::LessThan(left, right, sel, count, true_sel, false_sel);
56: }
57: 
58: template <>
59: inline idx_t ComparisonSelector::Select<duckdb::LessThanEquals>(Vector &left, Vector &right, const SelectionVector *sel,
60:                                                                 idx_t count, SelectionVector *true_sel,
61:                                                                 SelectionVector *false_sel) {
62: 	return VectorOperations::LessThanEquals(left, right, sel, count, true_sel, false_sel);
63: }
64: 
65: static idx_t ComparesNotNull(ValidityMask &vleft, ValidityMask &vright, ValidityMask &vresult, idx_t count,
66:                              SelectionVector &not_null) {
67: 	idx_t valid = 0;
68: 	for (idx_t i = 0; i < count; ++i) {
69: 		if (vleft.RowIsValid(i) && vright.RowIsValid(i)) {
70: 			not_null.set_index(valid++, i);
71: 		} else {
72: 			vresult.SetInvalid(i);
73: 		}
74: 	}
75: 	return valid;
76: }
77: 
78: template <typename OP>
79: static void NestedComparisonExecutor(Vector &left, Vector &right, Vector &result, idx_t count) {
80: 	const auto left_constant = left.GetVectorType() == VectorType::CONSTANT_VECTOR;
81: 	const auto right_constant = right.GetVectorType() == VectorType::CONSTANT_VECTOR;
82: 
83: 	if ((left_constant && ConstantVector::IsNull(left)) || (right_constant && ConstantVector::IsNull(right))) {
84: 		// either left or right is constant NULL: result is constant NULL
85: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
86: 		ConstantVector::SetNull(result, true);
87: 		return;
88: 	}
89: 
90: 	if (left_constant && right_constant) {
91: 		// both sides are constant, and neither is NULL so just compare one element.
92: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
93: 		SelectionVector true_sel(1);
94: 		auto match_count = ComparisonSelector::Select<OP>(left, right, nullptr, 1, &true_sel, nullptr);
95: 		auto result_data = ConstantVector::GetData<bool>(result);
96: 		result_data[0] = match_count > 0;
97: 		return;
98: 	}
99: 
100: 	result.SetVectorType(VectorType::FLAT_VECTOR);
101: 	auto result_data = FlatVector::GetData<bool>(result);
102: 	auto &validity = FlatVector::Validity(result);
103: 
104: 	VectorData leftv, rightv;
105: 	left.Orrify(count, leftv);
106: 	right.Orrify(count, rightv);
107: 
108: 	SelectionVector true_sel(count);
109: 	SelectionVector false_sel(count);
110: 
111: 	idx_t match_count = 0;
112: 	if (leftv.validity.AllValid() && rightv.validity.AllValid()) {
113: 		match_count = ComparisonSelector::Select<OP>(left, right, nullptr, count, &true_sel, &false_sel);
114: 	} else {
115: 		SelectionVector not_null(count);
116: 		count = ComparesNotNull(leftv.validity, rightv.validity, validity, count, not_null);
117: 		match_count = ComparisonSelector::Select<OP>(left, right, &not_null, count, &true_sel, &false_sel);
118: 	}
119: 
120: 	for (idx_t i = 0; i < match_count; ++i) {
121: 		const auto idx = true_sel.get_index(i);
122: 		result_data[idx] = true;
123: 	}
124: 
125: 	const idx_t no_match_count = count - match_count;
126: 	for (idx_t i = 0; i < no_match_count; ++i) {
127: 		const auto idx = false_sel.get_index(i);
128: 		result_data[idx] = false;
129: 	}
130: }
131: 
132: struct ComparisonExecutor {
133: private:
134: 	template <class T, class OP>
135: 	static inline void TemplatedExecute(Vector &left, Vector &right, Vector &result, idx_t count) {
136: 		BinaryExecutor::Execute<T, T, bool, OP>(left, right, result, count);
137: 	}
138: 
139: public:
140: 	template <class OP>
141: 	static inline void Execute(Vector &left, Vector &right, Vector &result, idx_t count) {
142: 		D_ASSERT(left.GetType() == right.GetType() && result.GetType() == LogicalType::BOOLEAN);
143: 		// the inplace loops take the result as the last parameter
144: 		switch (left.GetType().InternalType()) {
145: 		case PhysicalType::BOOL:
146: 		case PhysicalType::INT8:
147: 			TemplatedExecute<int8_t, OP>(left, right, result, count);
148: 			break;
149: 		case PhysicalType::INT16:
150: 			TemplatedExecute<int16_t, OP>(left, right, result, count);
151: 			break;
152: 		case PhysicalType::INT32:
153: 			TemplatedExecute<int32_t, OP>(left, right, result, count);
154: 			break;
155: 		case PhysicalType::INT64:
156: 			TemplatedExecute<int64_t, OP>(left, right, result, count);
157: 			break;
158: 		case PhysicalType::UINT8:
159: 			TemplatedExecute<uint8_t, OP>(left, right, result, count);
160: 			break;
161: 		case PhysicalType::UINT16:
162: 			TemplatedExecute<uint16_t, OP>(left, right, result, count);
163: 			break;
164: 		case PhysicalType::UINT32:
165: 			TemplatedExecute<uint32_t, OP>(left, right, result, count);
166: 			break;
167: 		case PhysicalType::UINT64:
168: 			TemplatedExecute<uint64_t, OP>(left, right, result, count);
169: 			break;
170: 		case PhysicalType::INT128:
171: 			TemplatedExecute<hugeint_t, OP>(left, right, result, count);
172: 			break;
173: 		case PhysicalType::FLOAT:
174: 			TemplatedExecute<float, OP>(left, right, result, count);
175: 			break;
176: 		case PhysicalType::DOUBLE:
177: 			TemplatedExecute<double, OP>(left, right, result, count);
178: 			break;
179: 		case PhysicalType::INTERVAL:
180: 			TemplatedExecute<interval_t, OP>(left, right, result, count);
181: 			break;
182: 		case PhysicalType::VARCHAR:
183: 			TemplatedExecute<string_t, OP>(left, right, result, count);
184: 			break;
185: 		case PhysicalType::LIST:
186: 		case PhysicalType::MAP:
187: 		case PhysicalType::STRUCT:
188: 			NestedComparisonExecutor<OP>(left, right, result, count);
189: 			break;
190: 		default:
191: 			throw InternalException("Invalid type for comparison");
192: 		}
193: 	}
194: };
195: 
196: void VectorOperations::Equals(Vector &left, Vector &right, Vector &result, idx_t count) {
197: 	ComparisonExecutor::Execute<duckdb::Equals>(left, right, result, count);
198: }
199: 
200: void VectorOperations::NotEquals(Vector &left, Vector &right, Vector &result, idx_t count) {
201: 	ComparisonExecutor::Execute<duckdb::NotEquals>(left, right, result, count);
202: }
203: 
204: void VectorOperations::GreaterThanEquals(Vector &left, Vector &right, Vector &result, idx_t count) {
205: 	ComparisonExecutor::Execute<duckdb::GreaterThanEquals>(left, right, result, count);
206: }
207: 
208: void VectorOperations::LessThanEquals(Vector &left, Vector &right, Vector &result, idx_t count) {
209: 	ComparisonExecutor::Execute<duckdb::LessThanEquals>(left, right, result, count);
210: }
211: 
212: void VectorOperations::GreaterThan(Vector &left, Vector &right, Vector &result, idx_t count) {
213: 	ComparisonExecutor::Execute<duckdb::GreaterThan>(left, right, result, count);
214: }
215: 
216: void VectorOperations::LessThan(Vector &left, Vector &right, Vector &result, idx_t count) {
217: 	ComparisonExecutor::Execute<duckdb::LessThan>(left, right, result, count);
218: }
219: 
220: } // namespace duckdb
[end of src/common/vector_operations/comparison_operators.cpp]
[start of src/function/aggregate/algebraic/avg.cpp]
1: #include "duckdb/function/aggregate/algebraic_functions.hpp"
2: #include "duckdb/function/aggregate/sum_helpers.hpp"
3: #include "duckdb/common/types/hugeint.hpp"
4: #include "duckdb/common/exception.hpp"
5: #include "duckdb/function/function_set.hpp"
6: #include "duckdb/planner/expression.hpp"
7: 
8: namespace duckdb {
9: 
10: template <class T>
11: struct AvgState {
12: 	uint64_t count;
13: 	T value;
14: 
15: 	void Initialize() {
16: 		this->count = 0;
17: 	}
18: 
19: 	void Combine(const AvgState<T> &other) {
20: 		this->count += other.count;
21: 		this->value += other.value;
22: 	}
23: };
24: 
25: struct KahanAvgState {
26: 	uint64_t count;
27: 	double value;
28: 	double err;
29: 
30: 	void Initialize() {
31: 		this->count = 0;
32: 		this->err = 0.0;
33: 	}
34: 
35: 	void Combine(const KahanAvgState &other) {
36: 		this->count += other.count;
37: 		KahanAddInternal(other.value, this->value, this->err);
38: 		KahanAddInternal(other.err, this->value, this->err);
39: 	}
40: };
41: 
42: struct AverageDecimalBindData : public FunctionData {
43: 	explicit AverageDecimalBindData(double scale) : scale(scale) {
44: 	}
45: 
46: 	double scale;
47: 
48: public:
49: 	unique_ptr<FunctionData> Copy() override {
50: 		return make_unique<AverageDecimalBindData>(scale);
51: 	};
52: };
53: 
54: struct AverageSetOperation {
55: 	template <class STATE>
56: 	static void Initialize(STATE *state) {
57: 		state->Initialize();
58: 	}
59: 	template <class STATE>
60: 	static void Combine(const STATE &source, STATE *target) {
61: 		target->Combine(source);
62: 	}
63: 	template <class STATE>
64: 	static void AddValues(STATE *state, idx_t count) {
65: 		state->count += count;
66: 	}
67: };
68: 
69: template <class T>
70: static T GetAverageDivident(uint64_t count, FunctionData *bind_data) {
71: 	T divident = T(count);
72: 	if (bind_data) {
73: 		auto &avg_bind_data = (AverageDecimalBindData &)*bind_data;
74: 		divident *= avg_bind_data.scale;
75: 	}
76: 	return divident;
77: }
78: 
79: struct IntegerAverageOperation : public BaseSumOperation<AverageSetOperation, RegularAdd> {
80: 	template <class T, class STATE>
81: 	static void Finalize(Vector &result, FunctionData *bind_data, STATE *state, T *target, ValidityMask &mask,
82: 	                     idx_t idx) {
83: 		if (state->count == 0) {
84: 			mask.SetInvalid(idx);
85: 		} else {
86: 			double divident = GetAverageDivident<double>(state->count, bind_data);
87: 			target[idx] = double(state->value) / divident;
88: 		}
89: 	}
90: };
91: 
92: struct IntegerAverageOperationHugeint : public BaseSumOperation<AverageSetOperation, HugeintAdd> {
93: 	template <class T, class STATE>
94: 	static void Finalize(Vector &result, FunctionData *bind_data, STATE *state, T *target, ValidityMask &mask,
95: 	                     idx_t idx) {
96: 		if (state->count == 0) {
97: 			mask.SetInvalid(idx);
98: 		} else {
99: 			long double divident = GetAverageDivident<long double>(state->count, bind_data);
100: 			target[idx] = Hugeint::Cast<long double>(state->value) / divident;
101: 		}
102: 	}
103: };
104: 
105: struct HugeintAverageOperation : public BaseSumOperation<AverageSetOperation, RegularAdd> {
106: 	template <class T, class STATE>
107: 	static void Finalize(Vector &result, FunctionData *bind_data, STATE *state, T *target, ValidityMask &mask,
108: 	                     idx_t idx) {
109: 		if (state->count == 0) {
110: 			mask.SetInvalid(idx);
111: 		} else {
112: 			long double divident = GetAverageDivident<long double>(state->count, bind_data);
113: 			target[idx] = Hugeint::Cast<long double>(state->value) / divident;
114: 		}
115: 	}
116: };
117: 
118: struct NumericAverageOperation : public BaseSumOperation<AverageSetOperation, RegularAdd> {
119: 	template <class T, class STATE>
120: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
121: 		if (state->count == 0) {
122: 			mask.SetInvalid(idx);
123: 		} else {
124: 			if (!Value::DoubleIsValid(state->value)) {
125: 				throw OutOfRangeException("AVG is out of range!");
126: 			}
127: 			target[idx] = (state->value / state->count);
128: 		}
129: 	}
130: };
131: 
132: struct KahanAverageOperation : public BaseSumOperation<AverageSetOperation, KahanAdd> {
133: 	template <class T, class STATE>
134: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
135: 		if (state->count == 0) {
136: 			mask.SetInvalid(idx);
137: 		} else {
138: 			if (!Value::DoubleIsValid(state->value)) {
139: 				throw OutOfRangeException("AVG is out of range!");
140: 			}
141: 			target[idx] = (state->value / state->count) + (state->err / state->count);
142: 		}
143: 	}
144: };
145: 
146: AggregateFunction GetAverageAggregate(PhysicalType type) {
147: 	switch (type) {
148: 	case PhysicalType::INT16:
149: 		return AggregateFunction::UnaryAggregate<AvgState<int64_t>, int16_t, double, IntegerAverageOperation>(
150: 		    LogicalType::SMALLINT, LogicalType::DOUBLE);
151: 	case PhysicalType::INT32: {
152: 		auto function =
153: 		    AggregateFunction::UnaryAggregate<AvgState<hugeint_t>, int32_t, double, IntegerAverageOperationHugeint>(
154: 		        LogicalType::INTEGER, LogicalType::DOUBLE);
155: 		return function;
156: 	}
157: 	case PhysicalType::INT64: {
158: 		auto function =
159: 		    AggregateFunction::UnaryAggregate<AvgState<hugeint_t>, int64_t, double, IntegerAverageOperationHugeint>(
160: 		        LogicalType::BIGINT, LogicalType::DOUBLE);
161: 		return function;
162: 	}
163: 	case PhysicalType::INT128:
164: 		return AggregateFunction::UnaryAggregate<AvgState<hugeint_t>, hugeint_t, double, HugeintAverageOperation>(
165: 		    LogicalType::HUGEINT, LogicalType::DOUBLE);
166: 	default:
167: 		throw InternalException("Unimplemented average aggregate");
168: 	}
169: }
170: 
171: unique_ptr<FunctionData> BindDecimalAvg(ClientContext &context, AggregateFunction &function,
172:                                         vector<unique_ptr<Expression>> &arguments) {
173: 	auto decimal_type = arguments[0]->return_type;
174: 	function = GetAverageAggregate(decimal_type.InternalType());
175: 	function.name = "avg";
176: 	function.arguments[0] = decimal_type;
177: 	function.return_type = LogicalType::DOUBLE;
178: 	return make_unique<AverageDecimalBindData>(
179: 	    Hugeint::Cast<double>(Hugeint::POWERS_OF_TEN[DecimalType::GetScale(decimal_type)]));
180: }
181: 
182: void AvgFun::RegisterFunction(BuiltinFunctions &set) {
183: 	AggregateFunctionSet avg("avg");
184: 	avg.AddFunction(AggregateFunction({LogicalTypeId::DECIMAL}, LogicalTypeId::DECIMAL, nullptr, nullptr, nullptr,
185: 	                                  nullptr, nullptr, nullptr, BindDecimalAvg));
186: 	avg.AddFunction(GetAverageAggregate(PhysicalType::INT16));
187: 	avg.AddFunction(GetAverageAggregate(PhysicalType::INT32));
188: 	avg.AddFunction(GetAverageAggregate(PhysicalType::INT64));
189: 	avg.AddFunction(GetAverageAggregate(PhysicalType::INT128));
190: 	avg.AddFunction(AggregateFunction::UnaryAggregate<AvgState<double>, double, double, NumericAverageOperation>(
191: 	    LogicalType::DOUBLE, LogicalType::DOUBLE));
192: 	set.AddFunction(avg);
193: 
194: 	AggregateFunctionSet favg("favg");
195: 	favg.AddFunction(AggregateFunction::UnaryAggregate<KahanAvgState, double, double, KahanAverageOperation>(
196: 	    LogicalType::DOUBLE, LogicalType::DOUBLE));
197: 	set.AddFunction(favg);
198: }
199: 
200: } // namespace duckdb
[end of src/function/aggregate/algebraic/avg.cpp]
[start of src/function/aggregate/distributive/kurtosis.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/common/vector_operations/vector_operations.hpp"
3: #include "duckdb/function/aggregate/distributive_functions.hpp"
4: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
5: 
6: namespace duckdb {
7: 
8: struct KurtosisState {
9: 	idx_t n;
10: 	double sum;
11: 	double sum_sqr;
12: 	double sum_cub;
13: 	double sum_four;
14: };
15: 
16: struct KurtosisOperation {
17: 	template <class STATE>
18: 	static void Initialize(STATE *state) {
19: 		state->n = 0;
20: 		state->sum = state->sum_sqr = state->sum_cub = state->sum_four = 0.0;
21: 	}
22: 
23: 	template <class INPUT_TYPE, class STATE, class OP>
24: 	static void ConstantOperation(STATE *state, FunctionData *bind_data, INPUT_TYPE *input, ValidityMask &mask,
25: 	                              idx_t count) {
26: 		for (idx_t i = 0; i < count; i++) {
27: 			Operation<INPUT_TYPE, STATE, OP>(state, bind_data, input, mask, 0);
28: 		}
29: 	}
30: 
31: 	template <class INPUT_TYPE, class STATE, class OP>
32: 	static void Operation(STATE *state, FunctionData *bind_data, INPUT_TYPE *data, ValidityMask &mask, idx_t idx) {
33: 		state->n++;
34: 		state->sum += data[idx];
35: 		state->sum_sqr += pow(data[idx], 2);
36: 		state->sum_cub += pow(data[idx], 3);
37: 		state->sum_four += pow(data[idx], 4);
38: 	}
39: 
40: 	template <class STATE, class OP>
41: 	static void Combine(const STATE &source, STATE *target) {
42: 		if (source.n == 0) {
43: 			return;
44: 		}
45: 		target->n += source.n;
46: 		target->sum += source.sum;
47: 		target->sum_sqr += source.sum_sqr;
48: 		target->sum_cub += source.sum_cub;
49: 		target->sum_four += source.sum_four;
50: 	}
51: 
52: 	template <class TARGET_TYPE, class STATE>
53: 	static void Finalize(Vector &result, FunctionData *bind_data, STATE *state, TARGET_TYPE *target, ValidityMask &mask,
54: 	                     idx_t idx) {
55: 		auto n = (double)state->n;
56: 		if (n <= 3) {
57: 			mask.SetInvalid(idx);
58: 			return;
59: 		}
60: 		double temp = 1 / n;
61: 		//! This is necessary due to linux 32 bits
62: 		long double temp_aux = 1 / n;
63: 		if (state->sum_sqr - state->sum * state->sum * temp == 0 ||
64: 		    state->sum_sqr - state->sum * state->sum * temp_aux == 0) {
65: 			mask.SetInvalid(idx);
66: 			return;
67: 		}
68: 		double m4 =
69: 		    temp * (state->sum_four - 4 * state->sum_cub * state->sum * temp +
70: 		            6 * state->sum_sqr * state->sum * state->sum * temp * temp - 3 * pow(state->sum, 4) * pow(temp, 3));
71: 
72: 		double m2 = temp * (state->sum_sqr - state->sum * state->sum * temp);
73: 		if (((m2 * m2) - 3 * (n - 1)) == 0 || ((n - 2) * (n - 3)) == 0) { // LCOV_EXCL_START
74: 			mask.SetInvalid(idx);
75: 		} // LCOV_EXCL_STOP
76: 		target[idx] = (n - 1) * ((n + 1) * m4 / (m2 * m2) - 3 * (n - 1)) / ((n - 2) * (n - 3));
77: 		if (!Value::DoubleIsValid(target[idx])) {
78: 			mask.SetInvalid(idx);
79: 		}
80: 	}
81: 
82: 	static bool IgnoreNull() {
83: 		return true;
84: 	}
85: };
86: 
87: void KurtosisFun::RegisterFunction(BuiltinFunctions &set) {
88: 	AggregateFunctionSet function_set("kurtosis");
89: 	function_set.AddFunction(AggregateFunction::UnaryAggregate<KurtosisState, double, double, KurtosisOperation>(
90: 	    LogicalType::DOUBLE, LogicalType::DOUBLE));
91: 	set.AddFunction(function_set);
92: }
93: 
94: } // namespace duckdb
[end of src/function/aggregate/distributive/kurtosis.cpp]
[start of src/function/aggregate/distributive/skew.cpp]
1: #include "duckdb/common/exception.hpp"
2: #include "duckdb/common/vector_operations/vector_operations.hpp"
3: #include "duckdb/function/aggregate/distributive_functions.hpp"
4: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
5: 
6: namespace duckdb {
7: 
8: struct SkewState {
9: 	size_t n;
10: 	double sum;
11: 	double sum_sqr;
12: 	double sum_cub;
13: };
14: 
15: struct SkewnessOperation {
16: 	template <class STATE>
17: 	static void Initialize(STATE *state) {
18: 		state->n = 0;
19: 		state->sum = state->sum_sqr = state->sum_cub = 0;
20: 	}
21: 
22: 	template <class INPUT_TYPE, class STATE, class OP>
23: 	static void ConstantOperation(STATE *state, FunctionData *bind_data, INPUT_TYPE *input, ValidityMask &mask,
24: 	                              idx_t count) {
25: 		for (idx_t i = 0; i < count; i++) {
26: 			Operation<INPUT_TYPE, STATE, OP>(state, bind_data, input, mask, 0);
27: 		}
28: 	}
29: 
30: 	template <class INPUT_TYPE, class STATE, class OP>
31: 	static void Operation(STATE *state, FunctionData *bind_data, INPUT_TYPE *data, ValidityMask &mask, idx_t idx) {
32: 		state->n++;
33: 		state->sum += data[idx];
34: 		state->sum_sqr += pow(data[idx], 2);
35: 		state->sum_cub += pow(data[idx], 3);
36: 	}
37: 
38: 	template <class STATE, class OP>
39: 	static void Combine(const STATE &source, STATE *target) {
40: 		if (source.n == 0) {
41: 			return;
42: 		}
43: 
44: 		target->n += source.n;
45: 		target->sum += source.sum;
46: 		target->sum_sqr += source.sum_sqr;
47: 		target->sum_cub += source.sum_cub;
48: 	}
49: 
50: 	template <class TARGET_TYPE, class STATE>
51: 	static void Finalize(Vector &result, FunctionData *bind_data, STATE *state, TARGET_TYPE *target, ValidityMask &mask,
52: 	                     idx_t idx) {
53: 		if (state->n <= 2) {
54: 			mask.SetInvalid(idx);
55: 			return;
56: 		}
57: 		double n = state->n;
58: 		double temp = 1 / n;
59: 		double div = (std::sqrt(std::pow(temp * (state->sum_sqr - state->sum * state->sum * temp), 3)));
60: 		if (div == 0) {
61: 			mask.SetInvalid(idx);
62: 			return;
63: 		}
64: 		double temp1 = std::sqrt(n * (n - 1)) / (n - 2);
65: 		target[idx] = temp1 * temp *
66: 		              (state->sum_cub - 3 * state->sum_sqr * state->sum * temp + 2 * pow(state->sum, 3) * temp * temp) /
67: 		              div;
68: 		if (!Value::DoubleIsValid(target[idx])) {
69: 			mask.SetInvalid(idx);
70: 		}
71: 	}
72: 
73: 	static bool IgnoreNull() {
74: 		return true;
75: 	}
76: };
77: 
78: void SkewFun::RegisterFunction(BuiltinFunctions &set) {
79: 	AggregateFunctionSet function_set("skewness");
80: 	function_set.AddFunction(AggregateFunction::UnaryAggregate<SkewState, double, double, SkewnessOperation>(
81: 	    LogicalType::DOUBLE, LogicalType::DOUBLE));
82: 	set.AddFunction(function_set);
83: }
84: 
85: } // namespace duckdb
[end of src/function/aggregate/distributive/skew.cpp]
[start of src/function/aggregate/distributive/sum.cpp]
1: #include "duckdb/function/aggregate/distributive_functions.hpp"
2: #include "duckdb/function/aggregate/sum_helpers.hpp"
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/types/decimal.hpp"
5: #include "duckdb/storage/statistics/numeric_statistics.hpp"
6: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
7: #include "duckdb/function/aggregate/algebraic_functions.hpp"
8: 
9: namespace duckdb {
10: 
11: struct SumSetOperation {
12: 	template <class STATE>
13: 	static void Initialize(STATE *state) {
14: 		state->Initialize();
15: 	}
16: 	template <class STATE>
17: 	static void Combine(const STATE &source, STATE *target) {
18: 		target->Combine(source);
19: 	}
20: 	template <class STATE>
21: 	static void AddValues(STATE *state, idx_t count) {
22: 		state->isset = true;
23: 	}
24: };
25: 
26: struct IntegerSumOperation : public BaseSumOperation<SumSetOperation, RegularAdd> {
27: 	template <class T, class STATE>
28: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
29: 		if (!state->isset) {
30: 			mask.SetInvalid(idx);
31: 		} else {
32: 			target[idx] = Hugeint::Convert(state->value);
33: 		}
34: 	}
35: };
36: 
37: struct SumToHugeintOperation : public BaseSumOperation<SumSetOperation, HugeintAdd> {
38: 	template <class T, class STATE>
39: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
40: 		if (!state->isset) {
41: 			mask.SetInvalid(idx);
42: 		} else {
43: 			target[idx] = state->value;
44: 		}
45: 	}
46: };
47: 
48: template <class ADD_OPERATOR>
49: struct DoubleSumOperation : public BaseSumOperation<SumSetOperation, ADD_OPERATOR> {
50: 	template <class T, class STATE>
51: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
52: 		if (!state->isset) {
53: 			mask.SetInvalid(idx);
54: 		} else {
55: 			if (!Value::DoubleIsValid(state->value)) {
56: 				throw OutOfRangeException("SUM is out of range!");
57: 			}
58: 			target[idx] = state->value;
59: 		}
60: 	}
61: };
62: 
63: using NumericSumOperation = DoubleSumOperation<RegularAdd>;
64: using KahanSumOperation = DoubleSumOperation<KahanAdd>;
65: 
66: struct HugeintSumOperation : public BaseSumOperation<SumSetOperation, RegularAdd> {
67: 	template <class T, class STATE>
68: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
69: 		if (!state->isset) {
70: 			mask.SetInvalid(idx);
71: 		} else {
72: 			target[idx] = state->value;
73: 		}
74: 	}
75: };
76: 
77: unique_ptr<BaseStatistics> SumPropagateStats(ClientContext &context, BoundAggregateExpression &expr,
78:                                              FunctionData *bind_data, vector<unique_ptr<BaseStatistics>> &child_stats,
79:                                              NodeStatistics *node_stats) {
80: 	if (child_stats[0] && node_stats && node_stats->has_max_cardinality) {
81: 		auto &numeric_stats = (NumericStatistics &)*child_stats[0];
82: 		if (numeric_stats.min.IsNull() || numeric_stats.max.IsNull()) {
83: 			return nullptr;
84: 		}
85: 		auto internal_type = numeric_stats.min.type().InternalType();
86: 		hugeint_t max_negative;
87: 		hugeint_t max_positive;
88: 		switch (internal_type) {
89: 		case PhysicalType::INT32:
90: 			max_negative = numeric_stats.min.GetValueUnsafe<int32_t>();
91: 			max_positive = numeric_stats.max.GetValueUnsafe<int32_t>();
92: 			break;
93: 		case PhysicalType::INT64:
94: 			max_negative = numeric_stats.min.GetValueUnsafe<int64_t>();
95: 			max_positive = numeric_stats.max.GetValueUnsafe<int64_t>();
96: 			break;
97: 		default:
98: 			throw InternalException("Unsupported type for propagate sum stats");
99: 		}
100: 		auto max_sum_negative = max_negative * hugeint_t(node_stats->max_cardinality);
101: 		auto max_sum_positive = max_positive * hugeint_t(node_stats->max_cardinality);
102: 		if (max_sum_positive >= NumericLimits<int64_t>::Maximum() ||
103: 		    max_sum_negative <= NumericLimits<int64_t>::Minimum()) {
104: 			// sum can potentially exceed int64_t bounds: use hugeint sum
105: 			return nullptr;
106: 		}
107: 		// total sum is guaranteed to fit in a single int64: use int64 sum instead of hugeint sum
108: 		switch (internal_type) {
109: 		case PhysicalType::INT32:
110: 			expr.function =
111: 			    AggregateFunction::UnaryAggregate<SumState<int64_t>, int32_t, hugeint_t, IntegerSumOperation>(
112: 			        LogicalType::INTEGER, LogicalType::HUGEINT);
113: 			expr.function.name = "sum";
114: 			break;
115: 		case PhysicalType::INT64:
116: 			expr.function =
117: 			    AggregateFunction::UnaryAggregate<SumState<int64_t>, int64_t, hugeint_t, IntegerSumOperation>(
118: 			        LogicalType::BIGINT, LogicalType::HUGEINT);
119: 			expr.function.name = "sum";
120: 			break;
121: 		default:
122: 			throw InternalException("Unsupported type for propagate sum stats");
123: 		}
124: 	}
125: 	return nullptr;
126: }
127: 
128: AggregateFunction SumFun::GetSumAggregate(PhysicalType type) {
129: 	switch (type) {
130: 	case PhysicalType::INT16:
131: 		return AggregateFunction::UnaryAggregate<SumState<int64_t>, int16_t, hugeint_t, IntegerSumOperation>(
132: 		    LogicalType::SMALLINT, LogicalType::HUGEINT);
133: 	case PhysicalType::INT32: {
134: 		auto function =
135: 		    AggregateFunction::UnaryAggregate<SumState<hugeint_t>, int32_t, hugeint_t, SumToHugeintOperation>(
136: 		        LogicalType::INTEGER, LogicalType::HUGEINT);
137: 		function.statistics = SumPropagateStats;
138: 		return function;
139: 	}
140: 	case PhysicalType::INT64: {
141: 		auto function =
142: 		    AggregateFunction::UnaryAggregate<SumState<hugeint_t>, int64_t, hugeint_t, SumToHugeintOperation>(
143: 		        LogicalType::BIGINT, LogicalType::HUGEINT);
144: 		function.statistics = SumPropagateStats;
145: 		return function;
146: 	}
147: 	case PhysicalType::INT128:
148: 		return AggregateFunction::UnaryAggregate<SumState<hugeint_t>, hugeint_t, hugeint_t, HugeintSumOperation>(
149: 		    LogicalType::HUGEINT, LogicalType::HUGEINT);
150: 	default:
151: 		throw InternalException("Unimplemented sum aggregate");
152: 	}
153: }
154: 
155: unique_ptr<FunctionData> BindDecimalSum(ClientContext &context, AggregateFunction &function,
156:                                         vector<unique_ptr<Expression>> &arguments) {
157: 	auto decimal_type = arguments[0]->return_type;
158: 	function = SumFun::GetSumAggregate(decimal_type.InternalType());
159: 	function.name = "sum";
160: 	function.arguments[0] = decimal_type;
161: 	function.return_type = LogicalType::DECIMAL(Decimal::MAX_WIDTH_DECIMAL, DecimalType::GetScale(decimal_type));
162: 	return nullptr;
163: }
164: 
165: void SumFun::RegisterFunction(BuiltinFunctions &set) {
166: 	AggregateFunctionSet sum("sum");
167: 	// decimal
168: 	sum.AddFunction(AggregateFunction({LogicalTypeId::DECIMAL}, LogicalTypeId::DECIMAL, nullptr, nullptr, nullptr,
169: 	                                  nullptr, nullptr, nullptr, BindDecimalSum));
170: 	sum.AddFunction(GetSumAggregate(PhysicalType::INT16));
171: 	sum.AddFunction(GetSumAggregate(PhysicalType::INT32));
172: 	sum.AddFunction(GetSumAggregate(PhysicalType::INT64));
173: 	sum.AddFunction(GetSumAggregate(PhysicalType::INT128));
174: 	sum.AddFunction(AggregateFunction::UnaryAggregate<SumState<double>, double, double, NumericSumOperation>(
175: 	    LogicalType::DOUBLE, LogicalType::DOUBLE));
176: 
177: 	set.AddFunction(sum);
178: 
179: 	// fsum
180: 	AggregateFunctionSet fsum("fsum");
181: 	fsum.AddFunction(AggregateFunction::UnaryAggregate<KahanSumState, double, double, KahanSumOperation>(
182: 	    LogicalType::DOUBLE, LogicalType::DOUBLE));
183: 
184: 	set.AddFunction(fsum);
185: 
186: 	fsum.name = "kahan_sum";
187: 	set.AddFunction(fsum);
188: 
189: 	fsum.name = "sumKahan";
190: 	set.AddFunction(fsum);
191: }
192: 
193: } // namespace duckdb
[end of src/function/aggregate/distributive/sum.cpp]
[start of src/function/aggregate/regression/regr_r2.cpp]
1: // Returns the coefficient of determination for non-null pairs in a group.
2: // It is computed for non-null pairs using the following formula:
3: // null                 if var_pop(x) = 0, else
4: // 1                    if var_pop(y) = 0 and var_pop(x) <> 0, else
5: // power(corr(y,x), 2)
6: 
7: #include "duckdb/function/aggregate/algebraic/corr.hpp"
8: #include "duckdb/function/function_set.hpp"
9: #include "duckdb/function/aggregate/regression_functions.hpp"
10: 
11: namespace duckdb {
12: struct RegrR2State {
13: 	CorrState corr;
14: 	StddevState var_pop_x;
15: 	StddevState var_pop_y;
16: };
17: 
18: struct RegrR2Operation {
19: 	template <class STATE>
20: 	static void Initialize(STATE *state) {
21: 		CorrOperation::Initialize<CorrState>(&state->corr);
22: 		STDDevBaseOperation::Initialize<StddevState>(&state->var_pop_x);
23: 		STDDevBaseOperation::Initialize<StddevState>(&state->var_pop_y);
24: 	}
25: 
26: 	template <class A_TYPE, class B_TYPE, class STATE, class OP>
27: 	static void Operation(STATE *state, FunctionData *bind_data, A_TYPE *x_data, B_TYPE *y_data, ValidityMask &amask,
28: 	                      ValidityMask &bmask, idx_t xidx, idx_t yidx) {
29: 		CorrOperation::Operation<A_TYPE, B_TYPE, CorrState, OP>(&state->corr, bind_data, y_data, x_data, bmask, amask,
30: 		                                                        yidx, xidx);
31: 		STDDevBaseOperation::Operation<A_TYPE, StddevState, OP>(&state->var_pop_x, bind_data, y_data, bmask, yidx);
32: 		STDDevBaseOperation::Operation<A_TYPE, StddevState, OP>(&state->var_pop_y, bind_data, x_data, amask, xidx);
33: 	}
34: 
35: 	template <class STATE, class OP>
36: 	static void Combine(const STATE &source, STATE *target) {
37: 		CorrOperation::Combine<CorrState, OP>(source.corr, &target->corr);
38: 		STDDevBaseOperation::Combine<StddevState, OP>(source.var_pop_x, &target->var_pop_x);
39: 		STDDevBaseOperation::Combine<StddevState, OP>(source.var_pop_y, &target->var_pop_y);
40: 	}
41: 
42: 	template <class T, class STATE>
43: 	static void Finalize(Vector &result, FunctionData *fd, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
44: 		auto var_pop_x = state->var_pop_x.count > 1 ? (state->var_pop_x.dsquared / state->var_pop_x.count) : 0;
45: 		if (!Value::DoubleIsValid(var_pop_x)) {
46: 			throw OutOfRangeException("VARPOP(X) is out of range!");
47: 		}
48: 		if (var_pop_x == 0) {
49: 			mask.SetInvalid(idx);
50: 			return;
51: 		}
52: 		auto var_pop_y = state->var_pop_y.count > 1 ? (state->var_pop_y.dsquared / state->var_pop_y.count) : 0;
53: 		if (!Value::DoubleIsValid(var_pop_y)) {
54: 			throw OutOfRangeException("VARPOP(Y) is out of range!");
55: 		}
56: 		if (var_pop_y == 0) {
57: 			target[idx] = 1;
58: 			return;
59: 		}
60: 		CorrOperation::Finalize<T, CorrState>(result, fd, &state->corr, target, mask, idx);
61: 		target[idx] = pow(target[idx], 2);
62: 	}
63: 
64: 	static bool IgnoreNull() {
65: 		return true;
66: 	}
67: };
68: 
69: void RegrR2Fun::RegisterFunction(BuiltinFunctions &set) {
70: 	AggregateFunctionSet fun("regr_r2");
71: 	fun.AddFunction(AggregateFunction::BinaryAggregate<RegrR2State, double, double, double, RegrR2Operation>(
72: 	    LogicalType::DOUBLE, LogicalType::DOUBLE, LogicalType::DOUBLE));
73: 	set.AddFunction(fun);
74: }
75: } // namespace duckdb
[end of src/function/aggregate/regression/regr_r2.cpp]
[start of src/function/aggregate/regression/regr_sxx_syy.cpp]
1: // regr_sxx
2: // Returns REGR_COUNT(y, x) * VAR_POP(x) for non-null pairs.
3: // regrsyy
4: // Returns REGR_COUNT(y, x) * VAR_POP(y) for non-null pairs.
5: 
6: #include "duckdb/function/aggregate/regression/regr_count.hpp"
7: #include "duckdb/function/function_set.hpp"
8: #include "duckdb/function/aggregate/regression_functions.hpp"
9: 
10: namespace duckdb {
11: 
12: struct RegrSState {
13: 	size_t count;
14: 	StddevState var_pop;
15: };
16: 
17: struct RegrBaseOperation {
18: 	template <class STATE>
19: 	static void Initialize(STATE *state) {
20: 		RegrCountFunction::Initialize<size_t>(&state->count);
21: 		STDDevBaseOperation::Initialize<StddevState>(&state->var_pop);
22: 	}
23: 
24: 	template <class STATE, class OP>
25: 	static void Combine(const STATE &source, STATE *target) {
26: 		RegrCountFunction::Combine<size_t, OP>(source.count, &target->count);
27: 		STDDevBaseOperation::Combine<StddevState, OP>(source.var_pop, &target->var_pop);
28: 	}
29: 
30: 	template <class T, class STATE>
31: 	static void Finalize(Vector &result, FunctionData *fd, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
32: 		if (state->var_pop.count == 0) {
33: 			mask.SetInvalid(idx);
34: 			return;
35: 		}
36: 		auto var_pop = state->var_pop.count > 1 ? (state->var_pop.dsquared / state->var_pop.count) : 0;
37: 		if (!Value::DoubleIsValid(var_pop)) {
38: 			throw OutOfRangeException("VARPOP is out of range!");
39: 		}
40: 		RegrCountFunction::Finalize<T, size_t>(result, fd, &state->count, target, mask, idx);
41: 		target[idx] *= var_pop;
42: 	}
43: 
44: 	static bool IgnoreNull() {
45: 		return true;
46: 	}
47: };
48: 
49: struct RegrSXXOperation : RegrBaseOperation {
50: 	template <class A_TYPE, class B_TYPE, class STATE, class OP>
51: 	static void Operation(STATE *state, FunctionData *bind_data, A_TYPE *x_data, B_TYPE *y_data, ValidityMask &amask,
52: 	                      ValidityMask &bmask, idx_t xidx, idx_t yidx) {
53: 		RegrCountFunction::Operation<A_TYPE, B_TYPE, size_t, OP>(&state->count, bind_data, y_data, x_data, bmask, amask,
54: 		                                                         yidx, xidx);
55: 		STDDevBaseOperation::Operation<A_TYPE, StddevState, OP>(&state->var_pop, bind_data, y_data, bmask, yidx);
56: 	}
57: };
58: 
59: struct RegrSYYOperation : RegrBaseOperation {
60: 	template <class A_TYPE, class B_TYPE, class STATE, class OP>
61: 	static void Operation(STATE *state, FunctionData *bind_data, A_TYPE *x_data, B_TYPE *y_data, ValidityMask &amask,
62: 	                      ValidityMask &bmask, idx_t xidx, idx_t yidx) {
63: 		RegrCountFunction::Operation<A_TYPE, B_TYPE, size_t, OP>(&state->count, bind_data, y_data, x_data, bmask, amask,
64: 		                                                         yidx, xidx);
65: 		STDDevBaseOperation::Operation<A_TYPE, StddevState, OP>(&state->var_pop, bind_data, x_data, bmask, xidx);
66: 	}
67: };
68: 
69: void RegrSXXFun::RegisterFunction(BuiltinFunctions &set) {
70: 	AggregateFunctionSet fun("regr_sxx");
71: 	fun.AddFunction(AggregateFunction::BinaryAggregate<RegrSState, double, double, double, RegrSXXOperation>(
72: 	    LogicalType::DOUBLE, LogicalType::DOUBLE, LogicalType::DOUBLE));
73: 	set.AddFunction(fun);
74: }
75: 
76: void RegrSYYFun::RegisterFunction(BuiltinFunctions &set) {
77: 	AggregateFunctionSet fun("regr_syy");
78: 	fun.AddFunction(AggregateFunction::BinaryAggregate<RegrSState, double, double, double, RegrSYYOperation>(
79: 	    LogicalType::DOUBLE, LogicalType::DOUBLE, LogicalType::DOUBLE));
80: 	set.AddFunction(fun);
81: }
82: 
83: } // namespace duckdb
[end of src/function/aggregate/regression/regr_sxx_syy.cpp]
[start of src/function/scalar/math/numeric.cpp]
1: #include "duckdb/function/scalar/math_functions.hpp"
2: #include "duckdb/common/vector_operations/vector_operations.hpp"
3: #include "duckdb/function/scalar/trigonometric_functions.hpp"
4: #include "duckdb/common/operator/abs.hpp"
5: #include "duckdb/common/types/hugeint.hpp"
6: #include "duckdb/common/types/cast_helpers.hpp"
7: #include "duckdb/planner/expression/bound_function_expression.hpp"
8: #include "duckdb/common/algorithm.hpp"
9: #include "duckdb/execution/expression_executor.hpp"
10: #include <cmath>
11: #include <errno.h>
12: 
13: namespace duckdb {
14: 
15: template <class TR, class OP>
16: static scalar_function_t GetScalarIntegerUnaryFunctionFixedReturn(const LogicalType &type) {
17: 	scalar_function_t function;
18: 	switch (type.id()) {
19: 	case LogicalTypeId::TINYINT:
20: 		function = &ScalarFunction::UnaryFunction<int8_t, TR, OP>;
21: 		break;
22: 	case LogicalTypeId::SMALLINT:
23: 		function = &ScalarFunction::UnaryFunction<int16_t, TR, OP>;
24: 		break;
25: 	case LogicalTypeId::INTEGER:
26: 		function = &ScalarFunction::UnaryFunction<int32_t, TR, OP>;
27: 		break;
28: 	case LogicalTypeId::BIGINT:
29: 		function = &ScalarFunction::UnaryFunction<int64_t, TR, OP>;
30: 		break;
31: 	case LogicalTypeId::HUGEINT:
32: 		function = &ScalarFunction::UnaryFunction<hugeint_t, TR, OP>;
33: 		break;
34: 	default:
35: 		throw NotImplementedException("Unimplemented type for GetScalarIntegerUnaryFunctionFixedReturn");
36: 	}
37: 	return function;
38: }
39: 
40: template <class OP>
41: struct UnaryDoubleWrapper {
42: 	template <class INPUT_TYPE, class RESULT_TYPE>
43: 	static RESULT_TYPE Operation(INPUT_TYPE input, ValidityMask &mask, idx_t idx, void *dataptr) {
44: 		RESULT_TYPE result = OP::template Operation<INPUT_TYPE, RESULT_TYPE>(input);
45: 		if (std::isnan(result) || std::isinf(result) || errno != 0) {
46: 			errno = 0;
47: 			mask.SetInvalid(idx);
48: 			return 0;
49: 		}
50: 		return result;
51: 	}
52: };
53: 
54: template <class T, class OP>
55: static void UnaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {
56: 	D_ASSERT(input.ColumnCount() >= 1);
57: 	errno = 0;
58: 	UnaryExecutor::GenericExecute<T, T, UnaryDoubleWrapper<OP>>(input.data[0], result, input.size(), nullptr, true);
59: }
60: 
61: struct BinaryDoubleWrapper {
62: 	template <class FUNC, class OP, class TA, class TB, class TR>
63: 	static inline TR Operation(FUNC fun, TA left, TB right, ValidityMask &mask, idx_t idx) {
64: 		TR result = OP::template Operation<TA, TB, TR>(left, right);
65: 		if (std::isnan(result) || std::isinf(result) || errno != 0) {
66: 			errno = 0;
67: 			mask.SetInvalid(idx);
68: 			return 0;
69: 		}
70: 		return result;
71: 	}
72: 
73: 	static bool AddsNulls() {
74: 		return true;
75: 	}
76: };
77: 
78: template <class T, class OP>
79: static void BinaryDoubleFunctionWrapper(DataChunk &input, ExpressionState &state, Vector &result) {
80: 	D_ASSERT(input.ColumnCount() >= 2);
81: 	errno = 0;
82: 	BinaryExecutor::Execute<T, T, T, OP, BinaryDoubleWrapper>(input.data[0], input.data[1], result, input.size());
83: }
84: 
85: //===--------------------------------------------------------------------===//
86: // nextafter
87: //===--------------------------------------------------------------------===//
88: 
89: struct NextAfterOperator {
90: 	template <class TA, class TB, class TR>
91: 	static inline TR Operation(TA base, TB exponent) {
92: 		throw NotImplementedException("Unimplemented type for NextAfter Function");
93: 	}
94: 
95: 	template <class TA, class TB, class TR>
96: 	static inline double Operation(double input, double approximate_to) {
97: 		return nextafter(input, approximate_to);
98: 	}
99: 	template <class TA, class TB, class TR>
100: 	static inline float Operation(float input, float approximate_to) {
101: 		return nextafterf(input, approximate_to);
102: 	}
103: };
104: 
105: unique_ptr<FunctionData> BindNextAfter(ClientContext &context, ScalarFunction &function,
106:                                        vector<unique_ptr<Expression>> &arguments) {
107: 	if ((arguments[0]->return_type != arguments[1]->return_type) ||
108: 	    (arguments[0]->return_type != LogicalType::FLOAT && arguments[0]->return_type != LogicalType::DOUBLE)) {
109: 		throw NotImplementedException("Unimplemented type for NextAfter Function");
110: 	}
111: 	return nullptr;
112: }
113: 
114: void NextAfterFun::RegisterFunction(BuiltinFunctions &set) {
115: 	ScalarFunctionSet next_after_fun("nextafter");
116: 	next_after_fun.AddFunction(
117: 	    ScalarFunction("nextafter", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,
118: 	                   BinaryDoubleFunctionWrapper<double, NextAfterOperator>, false, BindNextAfter));
119: 	next_after_fun.AddFunction(ScalarFunction("nextafter", {LogicalType::FLOAT, LogicalType::FLOAT}, LogicalType::FLOAT,
120: 	                                          BinaryDoubleFunctionWrapper<float, NextAfterOperator>, false,
121: 	                                          BindNextAfter));
122: 	set.AddFunction(next_after_fun);
123: }
124: 
125: //===--------------------------------------------------------------------===//
126: // abs
127: //===--------------------------------------------------------------------===//
128: template <class OP>
129: unique_ptr<FunctionData> DecimalUnaryOpBind(ClientContext &context, ScalarFunction &bound_function,
130:                                             vector<unique_ptr<Expression>> &arguments) {
131: 	auto decimal_type = arguments[0]->return_type;
132: 	switch (decimal_type.InternalType()) {
133: 	case PhysicalType::INT16:
134: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::SMALLINT);
135: 		break;
136: 	case PhysicalType::INT32:
137: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::INTEGER);
138: 		break;
139: 	case PhysicalType::INT64:
140: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::BIGINT);
141: 		break;
142: 	default:
143: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<OP>(LogicalTypeId::HUGEINT);
144: 		break;
145: 	}
146: 	bound_function.arguments[0] = decimal_type;
147: 	bound_function.return_type = decimal_type;
148: 	return nullptr;
149: }
150: 
151: void AbsFun::RegisterFunction(BuiltinFunctions &set) {
152: 	ScalarFunctionSet abs("abs");
153: 	for (auto &type : LogicalType::Numeric()) {
154: 		if (type.id() == LogicalTypeId::DECIMAL) {
155: 			abs.AddFunction(ScalarFunction({type}, type, nullptr, false, DecimalUnaryOpBind<AbsOperator>));
156: 		} else {
157: 			abs.AddFunction(ScalarFunction({type}, type, ScalarFunction::GetScalarUnaryFunction<AbsOperator>(type)));
158: 		}
159: 	}
160: 	set.AddFunction(abs);
161: 	abs.name = "@";
162: 	set.AddFunction(abs);
163: }
164: 
165: //===--------------------------------------------------------------------===//
166: // bit_count
167: //===--------------------------------------------------------------------===//
168: struct BitCntOperator {
169: 	template <class TA, class TR>
170: 	static inline TR Operation(TA input) {
171: 		using TU = typename std::make_unsigned<TA>::type;
172: 		TR count = 0;
173: 		for (auto value = TU(input); value > 0; value >>= 1) {
174: 			count += TR(value & 1);
175: 		}
176: 		return count;
177: 	}
178: };
179: 
180: void BitCountFun::RegisterFunction(BuiltinFunctions &set) {
181: 	ScalarFunctionSet functions("bit_count");
182: 	functions.AddFunction(ScalarFunction({LogicalType::TINYINT}, LogicalType::TINYINT,
183: 	                                     ScalarFunction::UnaryFunction<int8_t, int8_t, BitCntOperator>));
184: 	functions.AddFunction(ScalarFunction({LogicalType::SMALLINT}, LogicalType::TINYINT,
185: 	                                     ScalarFunction::UnaryFunction<int16_t, int8_t, BitCntOperator>));
186: 	functions.AddFunction(ScalarFunction({LogicalType::INTEGER}, LogicalType::TINYINT,
187: 	                                     ScalarFunction::UnaryFunction<int32_t, int8_t, BitCntOperator>));
188: 	functions.AddFunction(ScalarFunction({LogicalType::BIGINT}, LogicalType::TINYINT,
189: 	                                     ScalarFunction::UnaryFunction<int64_t, int8_t, BitCntOperator>));
190: 	set.AddFunction(functions);
191: }
192: 
193: //===--------------------------------------------------------------------===//
194: // sign
195: //===--------------------------------------------------------------------===//
196: struct SignOperator {
197: 	template <class TA, class TR>
198: 	static inline TR Operation(TA left) {
199: 		if (left == TA(0)) {
200: 			return 0;
201: 		} else if (left > TA(0)) {
202: 			return 1;
203: 		} else {
204: 			return -1;
205: 		}
206: 	}
207: };
208: 
209: void SignFun::RegisterFunction(BuiltinFunctions &set) {
210: 	ScalarFunctionSet sign("sign");
211: 	for (auto &type : LogicalType::Numeric()) {
212: 		if (type.id() == LogicalTypeId::DECIMAL) {
213: 			continue;
214: 		} else {
215: 			sign.AddFunction(
216: 			    ScalarFunction({type}, LogicalType::TINYINT,
217: 			                   ScalarFunction::GetScalarUnaryFunctionFixedReturn<int8_t, SignOperator>(type)));
218: 		}
219: 	}
220: 	set.AddFunction(sign);
221: }
222: 
223: //===--------------------------------------------------------------------===//
224: // ceil
225: //===--------------------------------------------------------------------===//
226: struct CeilOperator {
227: 	template <class TA, class TR>
228: 	static inline TR Operation(TA left) {
229: 		return std::ceil(left);
230: 	}
231: };
232: 
233: template <class T, class POWERS_OF_TEN, class OP>
234: static void GenericRoundFunctionDecimal(DataChunk &input, ExpressionState &state, Vector &result) {
235: 	auto &func_expr = (BoundFunctionExpression &)state.expr;
236: 	OP::template Operation<T, POWERS_OF_TEN>(input, DecimalType::GetScale(func_expr.children[0]->return_type), result);
237: }
238: 
239: template <class OP>
240: unique_ptr<FunctionData> BindGenericRoundFunctionDecimal(ClientContext &context, ScalarFunction &bound_function,
241:                                                          vector<unique_ptr<Expression>> &arguments) {
242: 	// ceil essentially removes the scale
243: 	auto &decimal_type = arguments[0]->return_type;
244: 	auto scale = DecimalType::GetScale(decimal_type);
245: 	auto width = DecimalType::GetWidth(decimal_type);
246: 	if (scale == 0) {
247: 		bound_function.function = ScalarFunction::NopFunction;
248: 	} else {
249: 		switch (decimal_type.InternalType()) {
250: 		case PhysicalType::INT16:
251: 			bound_function.function = GenericRoundFunctionDecimal<int16_t, NumericHelper, OP>;
252: 			break;
253: 		case PhysicalType::INT32:
254: 			bound_function.function = GenericRoundFunctionDecimal<int32_t, NumericHelper, OP>;
255: 			break;
256: 		case PhysicalType::INT64:
257: 			bound_function.function = GenericRoundFunctionDecimal<int64_t, NumericHelper, OP>;
258: 			break;
259: 		default:
260: 			bound_function.function = GenericRoundFunctionDecimal<hugeint_t, Hugeint, OP>;
261: 			break;
262: 		}
263: 	}
264: 	bound_function.arguments[0] = decimal_type;
265: 	bound_function.return_type = LogicalType::DECIMAL(width, 0);
266: 	return nullptr;
267: }
268: 
269: struct CeilDecimalOperator {
270: 	template <class T, class POWERS_OF_TEN_CLASS>
271: 	static void Operation(DataChunk &input, uint8_t scale, Vector &result) {
272: 		T power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[scale];
273: 		UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
274: 			if (input < 0) {
275: 				// below 0 we floor the number (e.g. -10.5 -> -10)
276: 				return input / power_of_ten;
277: 			} else {
278: 				// above 0 we ceil the number
279: 				return ((input - 1) / power_of_ten) + 1;
280: 			}
281: 		});
282: 	}
283: };
284: 
285: void CeilFun::RegisterFunction(BuiltinFunctions &set) {
286: 	ScalarFunctionSet ceil("ceil");
287: 	for (auto &type : LogicalType::Numeric()) {
288: 		scalar_function_t func = nullptr;
289: 		bind_scalar_function_t bind_func = nullptr;
290: 		if (type.IsIntegral()) {
291: 			// no ceil for integral numbers
292: 			continue;
293: 		}
294: 		switch (type.id()) {
295: 		case LogicalTypeId::FLOAT:
296: 			func = ScalarFunction::UnaryFunction<float, float, CeilOperator>;
297: 			break;
298: 		case LogicalTypeId::DOUBLE:
299: 			func = ScalarFunction::UnaryFunction<double, double, CeilOperator>;
300: 			break;
301: 		case LogicalTypeId::DECIMAL:
302: 			bind_func = BindGenericRoundFunctionDecimal<CeilDecimalOperator>;
303: 			break;
304: 		default:
305: 			throw InternalException("Unimplemented numeric type for function \"ceil\"");
306: 		}
307: 		ceil.AddFunction(ScalarFunction({type}, type, func, false, bind_func));
308: 	}
309: 
310: 	set.AddFunction(ceil);
311: 	ceil.name = "ceiling";
312: 	set.AddFunction(ceil);
313: }
314: 
315: //===--------------------------------------------------------------------===//
316: // floor
317: //===--------------------------------------------------------------------===//
318: struct FloorOperator {
319: 	template <class TA, class TR>
320: 	static inline TR Operation(TA left) {
321: 		return std::floor(left);
322: 	}
323: };
324: 
325: struct FloorDecimalOperator {
326: 	template <class T, class POWERS_OF_TEN_CLASS>
327: 	static void Operation(DataChunk &input, uint8_t scale, Vector &result) {
328: 		T power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[scale];
329: 		UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
330: 			if (input < 0) {
331: 				// below 0 we ceil the number (e.g. -10.5 -> -11)
332: 				return ((input + 1) / power_of_ten) - 1;
333: 			} else {
334: 				// above 0 we floor the number
335: 				return input / power_of_ten;
336: 			}
337: 		});
338: 	}
339: };
340: 
341: void FloorFun::RegisterFunction(BuiltinFunctions &set) {
342: 	ScalarFunctionSet floor("floor");
343: 	for (auto &type : LogicalType::Numeric()) {
344: 		scalar_function_t func = nullptr;
345: 		bind_scalar_function_t bind_func = nullptr;
346: 		if (type.IsIntegral()) {
347: 			// no floor for integral numbers
348: 			continue;
349: 		}
350: 		switch (type.id()) {
351: 		case LogicalTypeId::FLOAT:
352: 			func = ScalarFunction::UnaryFunction<float, float, FloorOperator>;
353: 			break;
354: 		case LogicalTypeId::DOUBLE:
355: 			func = ScalarFunction::UnaryFunction<double, double, FloorOperator>;
356: 			break;
357: 		case LogicalTypeId::DECIMAL:
358: 			bind_func = BindGenericRoundFunctionDecimal<FloorDecimalOperator>;
359: 			break;
360: 		default:
361: 			throw InternalException("Unimplemented numeric type for function \"floor\"");
362: 		}
363: 		floor.AddFunction(ScalarFunction({type}, type, func, false, bind_func));
364: 	}
365: 	set.AddFunction(floor);
366: }
367: 
368: //===--------------------------------------------------------------------===//
369: // round
370: //===--------------------------------------------------------------------===//
371: struct RoundOperatorPrecision {
372: 	template <class TA, class TB, class TR>
373: 	static inline TR Operation(TA input, TB precision) {
374: 		double rounded_value;
375: 		if (precision < 0) {
376: 			double modifier = std::pow(10, -precision);
377: 			rounded_value = (std::round(input / modifier)) * modifier;
378: 			if (std::isinf(rounded_value) || std::isnan(rounded_value)) {
379: 				return 0;
380: 			}
381: 		} else {
382: 			double modifier = std::pow(10, precision);
383: 			rounded_value = (std::round(input * modifier)) / modifier;
384: 			if (std::isinf(rounded_value) || std::isnan(rounded_value)) {
385: 				return input;
386: 			}
387: 		}
388: 		return rounded_value;
389: 	}
390: };
391: 
392: struct RoundOperator {
393: 	template <class TA, class TR>
394: 	static inline TR Operation(TA input) {
395: 		double rounded_value = round(input);
396: 		if (std::isinf(rounded_value) || std::isnan(rounded_value)) {
397: 			return input;
398: 		}
399: 		return rounded_value;
400: 	}
401: };
402: 
403: struct RoundDecimalOperator {
404: 	template <class T, class POWERS_OF_TEN_CLASS>
405: 	static void Operation(DataChunk &input, uint8_t scale, Vector &result) {
406: 		T power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[scale];
407: 		T addition = power_of_ten / 2;
408: 		// regular round rounds towards the nearest number
409: 		// in case of a tie we round away from zero
410: 		// i.e. -10.5 -> -11, 10.5 -> 11
411: 		// we implement this by adding (positive) or subtracting (negative) 0.5
412: 		// and then flooring the number
413: 		// e.g. 10.5 + 0.5 = 11, floor(11) = 11
414: 		//      10.4 + 0.5 = 10.9, floor(10.9) = 10
415: 		UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
416: 			if (input < 0) {
417: 				input -= addition;
418: 			} else {
419: 				input += addition;
420: 			}
421: 			return input / power_of_ten;
422: 		});
423: 	}
424: };
425: 
426: struct RoundPrecisionFunctionData : public FunctionData {
427: 	explicit RoundPrecisionFunctionData(int32_t target_scale) : target_scale(target_scale) {
428: 	}
429: 
430: 	int32_t target_scale;
431: 
432: 	unique_ptr<FunctionData> Copy() override {
433: 		return make_unique<RoundPrecisionFunctionData>(target_scale);
434: 	}
435: };
436: 
437: template <class T, class POWERS_OF_TEN_CLASS>
438: static void DecimalRoundNegativePrecisionFunction(DataChunk &input, ExpressionState &state, Vector &result) {
439: 	auto &func_expr = (BoundFunctionExpression &)state.expr;
440: 	auto &info = (RoundPrecisionFunctionData &)*func_expr.bind_info;
441: 	auto source_scale = DecimalType::GetScale(func_expr.children[0]->return_type);
442: 	auto width = DecimalType::GetWidth(func_expr.children[0]->return_type);
443: 	if (-info.target_scale >= width) {
444: 		// scale too big for width
445: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
446: 		result.SetValue(0, Value::INTEGER(0));
447: 		return;
448: 	}
449: 	T divide_power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[-info.target_scale + source_scale];
450: 	T multiply_power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[-info.target_scale];
451: 	T addition = divide_power_of_ten / 2;
452: 
453: 	UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
454: 		if (input < 0) {
455: 			input -= addition;
456: 		} else {
457: 			input += addition;
458: 		}
459: 		return input / divide_power_of_ten * multiply_power_of_ten;
460: 	});
461: }
462: 
463: template <class T, class POWERS_OF_TEN_CLASS>
464: static void DecimalRoundPositivePrecisionFunction(DataChunk &input, ExpressionState &state, Vector &result) {
465: 	auto &func_expr = (BoundFunctionExpression &)state.expr;
466: 	auto &info = (RoundPrecisionFunctionData &)*func_expr.bind_info;
467: 	auto source_scale = DecimalType::GetScale(func_expr.children[0]->return_type);
468: 	T power_of_ten = POWERS_OF_TEN_CLASS::POWERS_OF_TEN[source_scale - info.target_scale];
469: 	T addition = power_of_ten / 2;
470: 	UnaryExecutor::Execute<T, T>(input.data[0], result, input.size(), [&](T input) {
471: 		if (input < 0) {
472: 			input -= addition;
473: 		} else {
474: 			input += addition;
475: 		}
476: 		return input / power_of_ten;
477: 	});
478: }
479: 
480: unique_ptr<FunctionData> BindDecimalRoundPrecision(ClientContext &context, ScalarFunction &bound_function,
481:                                                    vector<unique_ptr<Expression>> &arguments) {
482: 	auto &decimal_type = arguments[0]->return_type;
483: 	if (!arguments[1]->IsFoldable()) {
484: 		throw NotImplementedException("ROUND(DECIMAL, INTEGER) with non-constant precision is not supported");
485: 	}
486: 	Value val = ExpressionExecutor::EvaluateScalar(*arguments[1]).CastAs(LogicalType::INTEGER);
487: 	if (val.IsNull()) {
488: 		throw NotImplementedException("ROUND(DECIMAL, INTEGER) with non-constant precision is not supported");
489: 	}
490: 	// our new precision becomes the round value
491: 	// e.g. ROUND(DECIMAL(18,3), 1) -> DECIMAL(18,1)
492: 	// but ONLY if the round value is positive
493: 	// if it is negative the scale becomes zero
494: 	// i.e. ROUND(DECIMAL(18,3), -1) -> DECIMAL(18,0)
495: 	int32_t round_value = IntegerValue::Get(val);
496: 	uint8_t target_scale;
497: 	auto width = DecimalType::GetWidth(decimal_type);
498: 	auto scale = DecimalType::GetScale(decimal_type);
499: 	if (round_value < 0) {
500: 		target_scale = 0;
501: 		switch (decimal_type.InternalType()) {
502: 		case PhysicalType::INT16:
503: 			bound_function.function = DecimalRoundNegativePrecisionFunction<int16_t, NumericHelper>;
504: 			break;
505: 		case PhysicalType::INT32:
506: 			bound_function.function = DecimalRoundNegativePrecisionFunction<int32_t, NumericHelper>;
507: 			break;
508: 		case PhysicalType::INT64:
509: 			bound_function.function = DecimalRoundNegativePrecisionFunction<int64_t, NumericHelper>;
510: 			break;
511: 		default:
512: 			bound_function.function = DecimalRoundNegativePrecisionFunction<hugeint_t, Hugeint>;
513: 			break;
514: 		}
515: 	} else {
516: 		if (round_value >= (int32_t)scale) {
517: 			// if round_value is bigger than or equal to scale we do nothing
518: 			bound_function.function = ScalarFunction::NopFunction;
519: 			target_scale = scale;
520: 		} else {
521: 			target_scale = round_value;
522: 			switch (decimal_type.InternalType()) {
523: 			case PhysicalType::INT16:
524: 				bound_function.function = DecimalRoundPositivePrecisionFunction<int16_t, NumericHelper>;
525: 				break;
526: 			case PhysicalType::INT32:
527: 				bound_function.function = DecimalRoundPositivePrecisionFunction<int32_t, NumericHelper>;
528: 				break;
529: 			case PhysicalType::INT64:
530: 				bound_function.function = DecimalRoundPositivePrecisionFunction<int64_t, NumericHelper>;
531: 				break;
532: 			default:
533: 				bound_function.function = DecimalRoundPositivePrecisionFunction<hugeint_t, Hugeint>;
534: 				break;
535: 			}
536: 		}
537: 	}
538: 	bound_function.arguments[0] = decimal_type;
539: 	bound_function.return_type = LogicalType::DECIMAL(width, target_scale);
540: 	return make_unique<RoundPrecisionFunctionData>(round_value);
541: }
542: 
543: void RoundFun::RegisterFunction(BuiltinFunctions &set) {
544: 	ScalarFunctionSet round("round");
545: 	for (auto &type : LogicalType::Numeric()) {
546: 		scalar_function_t round_prec_func = nullptr;
547: 		scalar_function_t round_func = nullptr;
548: 		bind_scalar_function_t bind_func = nullptr;
549: 		bind_scalar_function_t bind_prec_func = nullptr;
550: 		if (type.IsIntegral()) {
551: 			// no round for integral numbers
552: 			continue;
553: 		}
554: 		switch (type.id()) {
555: 		case LogicalTypeId::FLOAT:
556: 			round_func = ScalarFunction::UnaryFunction<float, float, RoundOperator>;
557: 			round_prec_func = ScalarFunction::BinaryFunction<float, int32_t, float, RoundOperatorPrecision>;
558: 			break;
559: 		case LogicalTypeId::DOUBLE:
560: 			round_func = ScalarFunction::UnaryFunction<double, double, RoundOperator>;
561: 			round_prec_func = ScalarFunction::BinaryFunction<double, int32_t, double, RoundOperatorPrecision>;
562: 			break;
563: 		case LogicalTypeId::DECIMAL:
564: 			bind_func = BindGenericRoundFunctionDecimal<RoundDecimalOperator>;
565: 			bind_prec_func = BindDecimalRoundPrecision;
566: 			break;
567: 		default:
568: 			throw InternalException("Unimplemented numeric type for function \"floor\"");
569: 		}
570: 		round.AddFunction(ScalarFunction({type}, type, round_func, false, bind_func));
571: 		round.AddFunction(ScalarFunction({type, LogicalType::INTEGER}, type, round_prec_func, false, bind_prec_func));
572: 	}
573: 	set.AddFunction(round);
574: }
575: 
576: //===--------------------------------------------------------------------===//
577: // exp
578: //===--------------------------------------------------------------------===//
579: struct ExpOperator {
580: 	template <class TA, class TR>
581: 	static inline TR Operation(TA left) {
582: 		return std::exp(left);
583: 	}
584: };
585: 
586: void ExpFun::RegisterFunction(BuiltinFunctions &set) {
587: 	set.AddFunction(ScalarFunction("exp", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
588: 	                               UnaryDoubleFunctionWrapper<double, ExpOperator>));
589: }
590: 
591: //===--------------------------------------------------------------------===//
592: // pow
593: //===--------------------------------------------------------------------===//
594: struct PowOperator {
595: 	template <class TA, class TB, class TR>
596: 	static inline TR Operation(TA base, TB exponent) {
597: 		return std::pow(base, exponent);
598: 	}
599: };
600: 
601: void PowFun::RegisterFunction(BuiltinFunctions &set) {
602: 	ScalarFunction power_function("pow", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,
603: 	                              BinaryDoubleFunctionWrapper<double, PowOperator>);
604: 	set.AddFunction(power_function);
605: 	power_function.name = "power";
606: 	set.AddFunction(power_function);
607: 	power_function.name = "**";
608: 	set.AddFunction(power_function);
609: 	power_function.name = "^";
610: 	set.AddFunction(power_function);
611: }
612: 
613: //===--------------------------------------------------------------------===//
614: // sqrt
615: //===--------------------------------------------------------------------===//
616: struct SqrtOperator {
617: 	template <class TA, class TR>
618: 	static inline TR Operation(TA left) {
619: 		return std::sqrt(left);
620: 	}
621: };
622: 
623: void SqrtFun::RegisterFunction(BuiltinFunctions &set) {
624: 	set.AddFunction(ScalarFunction("sqrt", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
625: 	                               UnaryDoubleFunctionWrapper<double, SqrtOperator>));
626: }
627: 
628: //===--------------------------------------------------------------------===//
629: // cbrt
630: //===--------------------------------------------------------------------===//
631: struct CbRtOperator {
632: 	template <class TA, class TR>
633: 	static inline TR Operation(TA left) {
634: 		return std::cbrt(left);
635: 	}
636: };
637: 
638: void CbrtFun::RegisterFunction(BuiltinFunctions &set) {
639: 	set.AddFunction(ScalarFunction("cbrt", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
640: 	                               UnaryDoubleFunctionWrapper<double, CbRtOperator>));
641: }
642: 
643: //===--------------------------------------------------------------------===//
644: // ln
645: //===--------------------------------------------------------------------===//
646: 
647: struct LnOperator {
648: 	template <class TA, class TR>
649: 	static inline TR Operation(TA left) {
650: 		return std::log(left);
651: 	}
652: };
653: 
654: void LnFun::RegisterFunction(BuiltinFunctions &set) {
655: 	set.AddFunction(ScalarFunction("ln", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
656: 	                               UnaryDoubleFunctionWrapper<double, LnOperator>));
657: }
658: 
659: //===--------------------------------------------------------------------===//
660: // log
661: //===--------------------------------------------------------------------===//
662: struct Log10Operator {
663: 	template <class TA, class TR>
664: 	static inline TR Operation(TA left) {
665: 		return std::log10(left);
666: 	}
667: };
668: 
669: void Log10Fun::RegisterFunction(BuiltinFunctions &set) {
670: 	set.AddFunction({"log10", "log"}, ScalarFunction({LogicalType::DOUBLE}, LogicalType::DOUBLE,
671: 	                                                 UnaryDoubleFunctionWrapper<double, Log10Operator>));
672: }
673: 
674: //===--------------------------------------------------------------------===//
675: // log2
676: //===--------------------------------------------------------------------===//
677: struct Log2Operator {
678: 	template <class TA, class TR>
679: 	static inline TR Operation(TA left) {
680: 		return std::log2(left);
681: 	}
682: };
683: 
684: void Log2Fun::RegisterFunction(BuiltinFunctions &set) {
685: 	set.AddFunction(ScalarFunction("log2", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
686: 	                               UnaryDoubleFunctionWrapper<double, Log2Operator>));
687: }
688: 
689: //===--------------------------------------------------------------------===//
690: // pi
691: //===--------------------------------------------------------------------===//
692: static void PiFunction(DataChunk &args, ExpressionState &state, Vector &result) {
693: 	D_ASSERT(args.ColumnCount() == 0);
694: 	Value pi_value = Value::DOUBLE(PI);
695: 	result.Reference(pi_value);
696: }
697: 
698: void PiFun::RegisterFunction(BuiltinFunctions &set) {
699: 	set.AddFunction(ScalarFunction("pi", {}, LogicalType::DOUBLE, PiFunction));
700: }
701: 
702: //===--------------------------------------------------------------------===//
703: // degrees
704: //===--------------------------------------------------------------------===//
705: struct DegreesOperator {
706: 	template <class TA, class TR>
707: 	static inline TR Operation(TA left) {
708: 		return left * (180 / PI);
709: 	}
710: };
711: 
712: void DegreesFun::RegisterFunction(BuiltinFunctions &set) {
713: 	set.AddFunction(ScalarFunction("degrees", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
714: 	                               UnaryDoubleFunctionWrapper<double, DegreesOperator>));
715: }
716: 
717: //===--------------------------------------------------------------------===//
718: // radians
719: //===--------------------------------------------------------------------===//
720: struct RadiansOperator {
721: 	template <class TA, class TR>
722: 	static inline TR Operation(TA left) {
723: 		return left * (PI / 180);
724: 	}
725: };
726: 
727: void RadiansFun::RegisterFunction(BuiltinFunctions &set) {
728: 	set.AddFunction(ScalarFunction("radians", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
729: 	                               UnaryDoubleFunctionWrapper<double, RadiansOperator>));
730: }
731: 
732: //===--------------------------------------------------------------------===//
733: // sin
734: //===--------------------------------------------------------------------===//
735: struct SinOperator {
736: 	template <class TA, class TR>
737: 	static inline TR Operation(TA input) {
738: 		return std::sin(input);
739: 	}
740: };
741: 
742: void SinFun::RegisterFunction(BuiltinFunctions &set) {
743: 	set.AddFunction(ScalarFunction("sin", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
744: 	                               UnaryDoubleFunctionWrapper<double, SinOperator>));
745: }
746: 
747: //===--------------------------------------------------------------------===//
748: // cos
749: //===--------------------------------------------------------------------===//
750: struct CosOperator {
751: 	template <class TA, class TR>
752: 	static inline TR Operation(TA input) {
753: 		return (double)std::cos(input);
754: 	}
755: };
756: 
757: void CosFun::RegisterFunction(BuiltinFunctions &set) {
758: 	set.AddFunction(ScalarFunction("cos", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
759: 	                               UnaryDoubleFunctionWrapper<double, CosOperator>));
760: }
761: 
762: //===--------------------------------------------------------------------===//
763: // tan
764: //===--------------------------------------------------------------------===//
765: struct TanOperator {
766: 	template <class TA, class TR>
767: 	static inline TR Operation(TA input) {
768: 		return (double)std::tan(input);
769: 	}
770: };
771: 
772: void TanFun::RegisterFunction(BuiltinFunctions &set) {
773: 	set.AddFunction(ScalarFunction("tan", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
774: 	                               UnaryDoubleFunctionWrapper<double, TanOperator>));
775: }
776: 
777: //===--------------------------------------------------------------------===//
778: // asin
779: //===--------------------------------------------------------------------===//
780: struct ASinOperator {
781: 	template <class TA, class TR>
782: 	static inline TR Operation(TA input) {
783: 		if (input < -1 || input > 1) {
784: 			throw Exception("ASIN is undefined outside [-1,1]");
785: 		}
786: 		return (double)std::asin(input);
787: 	}
788: };
789: 
790: void AsinFun::RegisterFunction(BuiltinFunctions &set) {
791: 	set.AddFunction(ScalarFunction("asin", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
792: 	                               UnaryDoubleFunctionWrapper<double, ASinOperator>));
793: }
794: 
795: //===--------------------------------------------------------------------===//
796: // atan
797: //===--------------------------------------------------------------------===//
798: struct ATanOperator {
799: 	template <class TA, class TR>
800: 	static inline TR Operation(TA input) {
801: 		return (double)std::atan(input);
802: 	}
803: };
804: 
805: void AtanFun::RegisterFunction(BuiltinFunctions &set) {
806: 	set.AddFunction(ScalarFunction("atan", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
807: 	                               UnaryDoubleFunctionWrapper<double, ATanOperator>));
808: }
809: 
810: //===--------------------------------------------------------------------===//
811: // atan2
812: //===--------------------------------------------------------------------===//
813: struct ATan2 {
814: 	template <class TA, class TB, class TR>
815: 	static inline TR Operation(TA left, TB right) {
816: 		return (double)std::atan2(left, right);
817: 	}
818: };
819: 
820: void Atan2Fun::RegisterFunction(BuiltinFunctions &set) {
821: 	set.AddFunction(ScalarFunction("atan2", {LogicalType::DOUBLE, LogicalType::DOUBLE}, LogicalType::DOUBLE,
822: 	                               BinaryDoubleFunctionWrapper<double, ATan2>));
823: }
824: 
825: //===--------------------------------------------------------------------===//
826: // acos
827: //===--------------------------------------------------------------------===//
828: struct ACos {
829: 	template <class TA, class TR>
830: 	static inline TR Operation(TA input) {
831: 		return (double)std::acos(input);
832: 	}
833: };
834: 
835: void AcosFun::RegisterFunction(BuiltinFunctions &set) {
836: 	set.AddFunction(
837: 	    ScalarFunction("acos", {LogicalType::DOUBLE}, LogicalType::DOUBLE, UnaryDoubleFunctionWrapper<double, ACos>));
838: }
839: 
840: //===--------------------------------------------------------------------===//
841: // cot
842: //===--------------------------------------------------------------------===//
843: struct CotOperator {
844: 	template <class TA, class TR>
845: 	static inline TR Operation(TA input) {
846: 		return 1.0 / (double)std::tan(input);
847: 	}
848: };
849: 
850: void CotFun::RegisterFunction(BuiltinFunctions &set) {
851: 	set.AddFunction(ScalarFunction("cot", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
852: 	                               UnaryDoubleFunctionWrapper<double, CotOperator>));
853: }
854: 
855: //===--------------------------------------------------------------------===//
856: // gamma
857: //===--------------------------------------------------------------------===//
858: struct GammaOperator {
859: 	template <class TA, class TR>
860: 	static inline TR Operation(TA left) {
861: 		return std::tgamma(left);
862: 	}
863: };
864: 
865: void GammaFun::RegisterFunction(BuiltinFunctions &set) {
866: 	set.AddFunction(ScalarFunction("gamma", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
867: 	                               UnaryDoubleFunctionWrapper<double, GammaOperator>));
868: }
869: 
870: //===--------------------------------------------------------------------===//
871: // gamma
872: //===--------------------------------------------------------------------===//
873: struct LogGammaOperator {
874: 	template <class TA, class TR>
875: 	static inline TR Operation(TA left) {
876: 		return std::lgamma(left);
877: 	}
878: };
879: 
880: void LogGammaFun::RegisterFunction(BuiltinFunctions &set) {
881: 	set.AddFunction(ScalarFunction("lgamma", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
882: 	                               UnaryDoubleFunctionWrapper<double, LogGammaOperator>));
883: }
884: 
885: //===--------------------------------------------------------------------===//
886: // factorial(), !
887: //===--------------------------------------------------------------------===//
888: 
889: struct FactorialOperator {
890: 	template <class TA, class TR>
891: 	static inline TR Operation(TA left) {
892: 		TR ret = 1;
893: 		for (TA i = 2; i <= left; i++) {
894: 			ret *= i;
895: 		}
896: 		return ret;
897: 	}
898: };
899: 
900: void FactorialFun::RegisterFunction(BuiltinFunctions &set) {
901: 	auto fun = ScalarFunction({LogicalType::INTEGER}, LogicalType::HUGEINT,
902: 	                          ScalarFunction::UnaryFunction<int32_t, hugeint_t, FactorialOperator>);
903: 
904: 	set.AddFunction({"factorial", "!__postfix"}, fun);
905: }
906: 
907: //===--------------------------------------------------------------------===//
908: // even
909: //===--------------------------------------------------------------------===//
910: struct EvenOperator {
911: 	template <class TA, class TR>
912: 	static inline TR Operation(TA left) {
913: 		double value;
914: 		if (left >= 0) {
915: 			value = std::ceil(left);
916: 		} else {
917: 			value = std::ceil(-left);
918: 			value = -value;
919: 		}
920: 		if (std::floor(value / 2) * 2 != value) {
921: 			if (left >= 0) {
922: 				return value += 1;
923: 			}
924: 			return value -= 1;
925: 		}
926: 		return value;
927: 	}
928: };
929: 
930: void EvenFun::RegisterFunction(BuiltinFunctions &set) {
931: 	set.AddFunction(ScalarFunction("even", {LogicalType::DOUBLE}, LogicalType::DOUBLE,
932: 	                               UnaryDoubleFunctionWrapper<double, EvenOperator>));
933: }
934: 
935: } // namespace duckdb
[end of src/function/scalar/math/numeric.cpp]
[start of src/function/scalar/math_functions.cpp]
1: #include "duckdb/function/scalar/math_functions.hpp"
2: #include "duckdb/common/exception.hpp"
3: 
4: namespace duckdb {
5: 
6: void BuiltinFunctions::RegisterMathFunctions() {
7: 	Register<AbsFun>();
8: 	Register<SignFun>();
9: 
10: 	Register<CeilFun>();
11: 	Register<FloorFun>();
12: 	Register<RoundFun>();
13: 
14: 	Register<DegreesFun>();
15: 	Register<RadiansFun>();
16: 
17: 	Register<CbrtFun>();
18: 	Register<ExpFun>();
19: 	Register<Log2Fun>();
20: 	Register<Log10Fun>();
21: 	Register<LnFun>();
22: 	Register<PowFun>();
23: 	Register<RandomFun>();
24: 	Register<SetseedFun>();
25: 	Register<SqrtFun>();
26: 
27: 	Register<PiFun>();
28: 
29: 	Register<BitCountFun>();
30: 
31: 	Register<GammaFun>();
32: 	Register<LogGammaFun>();
33: 
34: 	Register<FactorialFun>();
35: 
36: 	Register<NextAfterFun>();
37: 
38: 	Register<EvenFun>();
39: }
40: 
41: } // namespace duckdb
[end of src/function/scalar/math_functions.cpp]
[start of src/function/scalar/operators/add.cpp]
1: #include "duckdb/common/operator/add.hpp"
2: 
3: #include "duckdb/common/limits.hpp"
4: #include "duckdb/common/types/value.hpp"
5: 
6: #include "duckdb/common/types/date.hpp"
7: #include "duckdb/common/types/interval.hpp"
8: #include "duckdb/common/types/timestamp.hpp"
9: #include "duckdb/common/types/hugeint.hpp"
10: #include "duckdb/common/windows_undefs.hpp"
11: 
12: #include <limits>
13: 
14: namespace duckdb {
15: 
16: //===--------------------------------------------------------------------===//
17: // + [add]
18: //===--------------------------------------------------------------------===//
19: template <>
20: float AddOperator::Operation(float left, float right) {
21: 	auto result = left + right;
22: 	if (!Value::FloatIsValid(result)) {
23: 		throw OutOfRangeException("Overflow in addition of float!");
24: 	}
25: 	return result;
26: }
27: 
28: template <>
29: double AddOperator::Operation(double left, double right) {
30: 	auto result = left + right;
31: 	if (!Value::DoubleIsValid(result)) {
32: 		throw OutOfRangeException("Overflow in addition of double!");
33: 	}
34: 	return result;
35: }
36: 
37: template <>
38: interval_t AddOperator::Operation(interval_t left, interval_t right) {
39: 	left.months = AddOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.months, right.months);
40: 	left.days = AddOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.days, right.days);
41: 	left.micros = AddOperatorOverflowCheck::Operation<int64_t, int64_t, int64_t>(left.micros, right.micros);
42: 	return left;
43: }
44: 
45: template <>
46: date_t AddOperator::Operation(date_t left, int32_t right) {
47: 	int32_t result;
48: 	if (!TryAddOperator::Operation(left.days, right, result)) {
49: 		throw OutOfRangeException("Date out of range");
50: 	}
51: 	return date_t(result);
52: }
53: 
54: template <>
55: date_t AddOperator::Operation(int32_t left, date_t right) {
56: 	return AddOperator::Operation<date_t, int32_t, date_t>(right, left);
57: }
58: 
59: template <>
60: timestamp_t AddOperator::Operation(date_t left, dtime_t right) {
61: 	timestamp_t result;
62: 	if (!Timestamp::TryFromDatetime(left, right, result)) {
63: 		throw OutOfRangeException("Timestamp out of range");
64: 	}
65: 	return result;
66: }
67: 
68: template <>
69: timestamp_t AddOperator::Operation(dtime_t left, date_t right) {
70: 	return AddOperator::Operation<date_t, dtime_t, timestamp_t>(right, left);
71: }
72: 
73: template <>
74: date_t AddOperator::Operation(date_t left, interval_t right) {
75: 	return Interval::Add(left, right);
76: }
77: 
78: template <>
79: date_t AddOperator::Operation(interval_t left, date_t right) {
80: 	return AddOperator::Operation<date_t, interval_t, date_t>(right, left);
81: }
82: 
83: template <>
84: timestamp_t AddOperator::Operation(timestamp_t left, interval_t right) {
85: 	return Interval::Add(left, right);
86: }
87: 
88: template <>
89: timestamp_t AddOperator::Operation(interval_t left, timestamp_t right) {
90: 	return AddOperator::Operation<timestamp_t, interval_t, timestamp_t>(right, left);
91: }
92: 
93: //===--------------------------------------------------------------------===//
94: // + [add] with overflow check
95: //===--------------------------------------------------------------------===//
96: struct OverflowCheckedAddition {
97: 	template <class SRCTYPE, class UTYPE>
98: 	static inline bool Operation(SRCTYPE left, SRCTYPE right, SRCTYPE &result) {
99: 		UTYPE uresult = AddOperator::Operation<UTYPE, UTYPE, UTYPE>(UTYPE(left), UTYPE(right));
100: 		if (uresult < NumericLimits<SRCTYPE>::Minimum() || uresult > NumericLimits<SRCTYPE>::Maximum()) {
101: 			return false;
102: 		}
103: 		result = SRCTYPE(uresult);
104: 		return true;
105: 	}
106: };
107: 
108: template <>
109: bool TryAddOperator::Operation(uint8_t left, uint8_t right, uint8_t &result) {
110: 	return OverflowCheckedAddition::Operation<uint8_t, uint16_t>(left, right, result);
111: }
112: template <>
113: bool TryAddOperator::Operation(uint16_t left, uint16_t right, uint16_t &result) {
114: 	return OverflowCheckedAddition::Operation<uint16_t, uint32_t>(left, right, result);
115: }
116: template <>
117: bool TryAddOperator::Operation(uint32_t left, uint32_t right, uint32_t &result) {
118: 	return OverflowCheckedAddition::Operation<uint32_t, uint64_t>(left, right, result);
119: }
120: 
121: template <>
122: bool TryAddOperator::Operation(uint64_t left, uint64_t right, uint64_t &result) {
123: 	if (NumericLimits<uint64_t>::Maximum() - left < right) {
124: 		return false;
125: 	}
126: 	return OverflowCheckedAddition::Operation<uint64_t, uint64_t>(left, right, result);
127: }
128: 
129: template <>
130: bool TryAddOperator::Operation(int8_t left, int8_t right, int8_t &result) {
131: 	return OverflowCheckedAddition::Operation<int8_t, int16_t>(left, right, result);
132: }
133: 
134: template <>
135: bool TryAddOperator::Operation(int16_t left, int16_t right, int16_t &result) {
136: 	return OverflowCheckedAddition::Operation<int16_t, int32_t>(left, right, result);
137: }
138: 
139: template <>
140: bool TryAddOperator::Operation(int32_t left, int32_t right, int32_t &result) {
141: 	return OverflowCheckedAddition::Operation<int32_t, int64_t>(left, right, result);
142: }
143: 
144: template <>
145: bool TryAddOperator::Operation(int64_t left, int64_t right, int64_t &result) {
146: #if (__GNUC__ >= 5) || defined(__clang__)
147: 	if (__builtin_add_overflow(left, right, &result)) {
148: 		return false;
149: 	}
150: #else
151: 	// https://blog.regehr.org/archives/1139
152: 	result = int64_t((uint64_t)left + (uint64_t)right);
153: 	if ((left < 0 && right < 0 && result >= 0) || (left >= 0 && right >= 0 && result < 0)) {
154: 		return false;
155: 	}
156: #endif
157: 	return true;
158: }
159: 
160: //===--------------------------------------------------------------------===//
161: // add decimal with overflow check
162: //===--------------------------------------------------------------------===//
163: template <class T, T min, T max>
164: bool TryDecimalAddTemplated(T left, T right, T &result) {
165: 	if (right < 0) {
166: 		if (min - right > left) {
167: 			return false;
168: 		}
169: 	} else {
170: 		if (max - right < left) {
171: 			return false;
172: 		}
173: 	}
174: 	result = left + right;
175: 	return true;
176: }
177: 
178: template <>
179: bool TryDecimalAdd::Operation(int16_t left, int16_t right, int16_t &result) {
180: 	return TryDecimalAddTemplated<int16_t, -9999, 9999>(left, right, result);
181: }
182: 
183: template <>
184: bool TryDecimalAdd::Operation(int32_t left, int32_t right, int32_t &result) {
185: 	return TryDecimalAddTemplated<int32_t, -999999999, 999999999>(left, right, result);
186: }
187: 
188: template <>
189: bool TryDecimalAdd::Operation(int64_t left, int64_t right, int64_t &result) {
190: 	return TryDecimalAddTemplated<int64_t, -999999999999999999, 999999999999999999>(left, right, result);
191: }
192: 
193: template <>
194: bool TryDecimalAdd::Operation(hugeint_t left, hugeint_t right, hugeint_t &result) {
195: 	result = left + right;
196: 	if (result <= -Hugeint::POWERS_OF_TEN[38] || result >= Hugeint::POWERS_OF_TEN[38]) {
197: 		return false;
198: 	}
199: 	return true;
200: }
201: 
202: template <>
203: hugeint_t DecimalAddOverflowCheck::Operation(hugeint_t left, hugeint_t right) {
204: 	hugeint_t result;
205: 	if (!TryDecimalAdd::Operation(left, right, result)) {
206: 		throw OutOfRangeException("Overflow in addition of DECIMAL(38) (%s + %s);", left.ToString(), right.ToString());
207: 	}
208: 	return result;
209: }
210: 
211: //===--------------------------------------------------------------------===//
212: // add time operator
213: //===--------------------------------------------------------------------===//
214: template <>
215: dtime_t AddTimeOperator::Operation(dtime_t left, interval_t right) {
216: 	date_t date(0);
217: 	return Interval::Add(left, right, date);
218: }
219: 
220: template <>
221: dtime_t AddTimeOperator::Operation(interval_t left, dtime_t right) {
222: 	return AddTimeOperator::Operation<dtime_t, interval_t, dtime_t>(right, left);
223: }
224: 
225: } // namespace duckdb
[end of src/function/scalar/operators/add.cpp]
[start of src/function/scalar/operators/arithmetic.cpp]
1: #include "duckdb/common/operator/add.hpp"
2: #include "duckdb/common/operator/multiply.hpp"
3: #include "duckdb/common/operator/numeric_binary_operators.hpp"
4: #include "duckdb/common/operator/subtract.hpp"
5: #include "duckdb/common/types/date.hpp"
6: #include "duckdb/common/types/decimal.hpp"
7: #include "duckdb/common/types/hugeint.hpp"
8: #include "duckdb/common/types/interval.hpp"
9: #include "duckdb/common/types/time.hpp"
10: #include "duckdb/common/types/timestamp.hpp"
11: #include "duckdb/common/vector_operations/vector_operations.hpp"
12: #include "duckdb/function/scalar/operators.hpp"
13: #include "duckdb/planner/expression/bound_function_expression.hpp"
14: #include "duckdb/storage/statistics/numeric_statistics.hpp"
15: #include "duckdb/function/scalar/nested_functions.hpp"
16: 
17: #include <limits>
18: 
19: namespace duckdb {
20: 
21: template <class OP>
22: static scalar_function_t GetScalarIntegerFunction(PhysicalType type) {
23: 	scalar_function_t function;
24: 	switch (type) {
25: 	case PhysicalType::INT8:
26: 		function = &ScalarFunction::BinaryFunction<int8_t, int8_t, int8_t, OP>;
27: 		break;
28: 	case PhysicalType::INT16:
29: 		function = &ScalarFunction::BinaryFunction<int16_t, int16_t, int16_t, OP>;
30: 		break;
31: 	case PhysicalType::INT32:
32: 		function = &ScalarFunction::BinaryFunction<int32_t, int32_t, int32_t, OP>;
33: 		break;
34: 	case PhysicalType::INT64:
35: 		function = &ScalarFunction::BinaryFunction<int64_t, int64_t, int64_t, OP>;
36: 		break;
37: 	case PhysicalType::UINT8:
38: 		function = &ScalarFunction::BinaryFunction<uint8_t, uint8_t, uint8_t, OP>;
39: 		break;
40: 	case PhysicalType::UINT16:
41: 		function = &ScalarFunction::BinaryFunction<uint16_t, uint16_t, uint16_t, OP>;
42: 		break;
43: 	case PhysicalType::UINT32:
44: 		function = &ScalarFunction::BinaryFunction<uint32_t, uint32_t, uint32_t, OP>;
45: 		break;
46: 	case PhysicalType::UINT64:
47: 		function = &ScalarFunction::BinaryFunction<uint64_t, uint64_t, uint64_t, OP>;
48: 		break;
49: 	default:
50: 		throw NotImplementedException("Unimplemented type for GetScalarBinaryFunction");
51: 	}
52: 	return function;
53: }
54: 
55: template <class OP>
56: static scalar_function_t GetScalarBinaryFunction(PhysicalType type) {
57: 	scalar_function_t function;
58: 	switch (type) {
59: 	case PhysicalType::INT128:
60: 		function = &ScalarFunction::BinaryFunction<hugeint_t, hugeint_t, hugeint_t, OP>;
61: 		break;
62: 	case PhysicalType::FLOAT:
63: 		function = &ScalarFunction::BinaryFunction<float, float, float, OP>;
64: 		break;
65: 	case PhysicalType::DOUBLE:
66: 		function = &ScalarFunction::BinaryFunction<double, double, double, OP>;
67: 		break;
68: 	default:
69: 		function = GetScalarIntegerFunction<OP>(type);
70: 		break;
71: 	}
72: 	return function;
73: }
74: 
75: //===--------------------------------------------------------------------===//
76: // + [add]
77: //===--------------------------------------------------------------------===//
78: struct AddPropagateStatistics {
79: 	template <class T, class OP>
80: 	static bool Operation(LogicalType type, NumericStatistics &lstats, NumericStatistics &rstats, Value &new_min,
81: 	                      Value &new_max) {
82: 		T min, max;
83: 		// new min is min+min
84: 		if (!OP::Operation(lstats.min.GetValueUnsafe<T>(), rstats.min.GetValueUnsafe<T>(), min)) {
85: 			return true;
86: 		}
87: 		// new max is max+max
88: 		if (!OP::Operation(lstats.max.GetValueUnsafe<T>(), rstats.max.GetValueUnsafe<T>(), max)) {
89: 			return true;
90: 		}
91: 		new_min = Value::Numeric(type, min);
92: 		new_max = Value::Numeric(type, max);
93: 		return false;
94: 	}
95: };
96: 
97: struct SubtractPropagateStatistics {
98: 	template <class T, class OP>
99: 	static bool Operation(LogicalType type, NumericStatistics &lstats, NumericStatistics &rstats, Value &new_min,
100: 	                      Value &new_max) {
101: 		T min, max;
102: 		if (!OP::Operation(lstats.min.GetValueUnsafe<T>(), rstats.max.GetValueUnsafe<T>(), min)) {
103: 			return true;
104: 		}
105: 		if (!OP::Operation(lstats.max.GetValueUnsafe<T>(), rstats.min.GetValueUnsafe<T>(), max)) {
106: 			return true;
107: 		}
108: 		new_min = Value::Numeric(type, min);
109: 		new_max = Value::Numeric(type, max);
110: 		return false;
111: 	}
112: };
113: 
114: template <class OP, class PROPAGATE, class BASEOP>
115: static unique_ptr<BaseStatistics> PropagateNumericStats(ClientContext &context, BoundFunctionExpression &expr,
116:                                                         FunctionData *bind_data,
117:                                                         vector<unique_ptr<BaseStatistics>> &child_stats) {
118: 	D_ASSERT(child_stats.size() == 2);
119: 	// can only propagate stats if the children have stats
120: 	if (!child_stats[0] || !child_stats[1]) {
121: 		return nullptr;
122: 	}
123: 	auto &lstats = (NumericStatistics &)*child_stats[0];
124: 	auto &rstats = (NumericStatistics &)*child_stats[1];
125: 	Value new_min, new_max;
126: 	bool potential_overflow = true;
127: 	if (!lstats.min.IsNull() && !lstats.max.IsNull() && !rstats.min.IsNull() && !rstats.max.IsNull()) {
128: 		switch (expr.return_type.InternalType()) {
129: 		case PhysicalType::INT8:
130: 			potential_overflow =
131: 			    PROPAGATE::template Operation<int8_t, OP>(expr.return_type, lstats, rstats, new_min, new_max);
132: 			break;
133: 		case PhysicalType::INT16:
134: 			potential_overflow =
135: 			    PROPAGATE::template Operation<int16_t, OP>(expr.return_type, lstats, rstats, new_min, new_max);
136: 			break;
137: 		case PhysicalType::INT32:
138: 			potential_overflow =
139: 			    PROPAGATE::template Operation<int32_t, OP>(expr.return_type, lstats, rstats, new_min, new_max);
140: 			break;
141: 		case PhysicalType::INT64:
142: 			potential_overflow =
143: 			    PROPAGATE::template Operation<int64_t, OP>(expr.return_type, lstats, rstats, new_min, new_max);
144: 			break;
145: 		default:
146: 			return nullptr;
147: 		}
148: 	}
149: 	if (potential_overflow) {
150: 		new_min = Value(expr.return_type);
151: 		new_max = Value(expr.return_type);
152: 	} else {
153: 		// no potential overflow: replace with non-overflowing operator
154: 		expr.function.function = GetScalarIntegerFunction<BASEOP>(expr.return_type.InternalType());
155: 	}
156: 	auto stats = make_unique<NumericStatistics>(expr.return_type, move(new_min), move(new_max));
157: 	stats->validity_stats = ValidityStatistics::Combine(lstats.validity_stats, rstats.validity_stats);
158: 	return move(stats);
159: }
160: 
161: template <class OP, class OPOVERFLOWCHECK, bool IS_SUBTRACT = false>
162: unique_ptr<FunctionData> BindDecimalAddSubtract(ClientContext &context, ScalarFunction &bound_function,
163:                                                 vector<unique_ptr<Expression>> &arguments) {
164: 	// get the max width and scale of the input arguments
165: 	uint8_t max_width = 0, max_scale = 0, max_width_over_scale = 0;
166: 	for (idx_t i = 0; i < arguments.size(); i++) {
167: 		if (arguments[i]->return_type.id() == LogicalTypeId::UNKNOWN) {
168: 			continue;
169: 		}
170: 		uint8_t width, scale;
171: 		auto can_convert = arguments[i]->return_type.GetDecimalProperties(width, scale);
172: 		if (!can_convert) {
173: 			throw InternalException("Could not convert type %s to a decimal.", arguments[i]->return_type.ToString());
174: 		}
175: 		max_width = MaxValue<uint8_t>(width, max_width);
176: 		max_scale = MaxValue<uint8_t>(scale, max_scale);
177: 		max_width_over_scale = MaxValue<uint8_t>(width - scale, max_width_over_scale);
178: 	}
179: 	D_ASSERT(max_width > 0);
180: 	// for addition/subtraction, we add 1 to the width to ensure we don't overflow
181: 	bool check_overflow = false;
182: 	auto required_width = MaxValue<uint8_t>(max_scale + max_width_over_scale, max_width) + 1;
183: 	if (required_width > Decimal::MAX_WIDTH_INT64 && max_width <= Decimal::MAX_WIDTH_INT64) {
184: 		// we don't automatically promote past the hugeint boundary to avoid the large hugeint performance penalty
185: 		check_overflow = true;
186: 		required_width = Decimal::MAX_WIDTH_INT64;
187: 	}
188: 	if (required_width > Decimal::MAX_WIDTH_DECIMAL) {
189: 		// target width does not fit in decimal at all: truncate the scale and perform overflow detection
190: 		check_overflow = true;
191: 		required_width = Decimal::MAX_WIDTH_DECIMAL;
192: 	}
193: 	// arithmetic between two decimal arguments: check the types of the input arguments
194: 	LogicalType result_type = LogicalType::DECIMAL(required_width, max_scale);
195: 	// we cast all input types to the specified type
196: 	for (idx_t i = 0; i < arguments.size(); i++) {
197: 		// first check if the cast is necessary
198: 		// if the argument has a matching scale and internal type as the output type, no casting is necessary
199: 		auto &argument_type = arguments[i]->return_type;
200: 		uint8_t width, scale;
201: 		argument_type.GetDecimalProperties(width, scale);
202: 		if (scale == DecimalType::GetScale(result_type) && argument_type.InternalType() == result_type.InternalType()) {
203: 			bound_function.arguments[i] = argument_type;
204: 		} else {
205: 			bound_function.arguments[i] = result_type;
206: 		}
207: 	}
208: 	bound_function.return_type = result_type;
209: 	// now select the physical function to execute
210: 	if (check_overflow) {
211: 		bound_function.function = GetScalarBinaryFunction<OPOVERFLOWCHECK>(result_type.InternalType());
212: 	} else {
213: 		bound_function.function = GetScalarBinaryFunction<OP>(result_type.InternalType());
214: 	}
215: 	if (result_type.InternalType() != PhysicalType::INT128) {
216: 		if (IS_SUBTRACT) {
217: 			bound_function.statistics =
218: 			    PropagateNumericStats<TryDecimalSubtract, SubtractPropagateStatistics, SubtractOperator>;
219: 		} else {
220: 			bound_function.statistics = PropagateNumericStats<TryDecimalAdd, AddPropagateStatistics, AddOperator>;
221: 		}
222: 	}
223: 	return nullptr;
224: }
225: 
226: unique_ptr<FunctionData> NopDecimalBind(ClientContext &context, ScalarFunction &bound_function,
227:                                         vector<unique_ptr<Expression>> &arguments) {
228: 	bound_function.return_type = arguments[0]->return_type;
229: 	bound_function.arguments[0] = arguments[0]->return_type;
230: 	return nullptr;
231: }
232: 
233: ScalarFunction AddFun::GetFunction(const LogicalType &type) {
234: 	D_ASSERT(type.IsNumeric());
235: 	if (type.id() == LogicalTypeId::DECIMAL) {
236: 		return ScalarFunction("+", {type}, type, ScalarFunction::NopFunction, false, NopDecimalBind);
237: 	} else {
238: 		return ScalarFunction("+", {type}, type, ScalarFunction::NopFunction);
239: 	}
240: }
241: 
242: ScalarFunction AddFun::GetFunction(const LogicalType &left_type, const LogicalType &right_type) {
243: 	if (left_type.IsNumeric() && left_type.id() == right_type.id()) {
244: 		if (left_type.id() == LogicalTypeId::DECIMAL) {
245: 			return ScalarFunction("+", {left_type, right_type}, left_type, nullptr, false,
246: 			                      BindDecimalAddSubtract<AddOperator, DecimalAddOverflowCheck>);
247: 		} else if (left_type.IsIntegral() && left_type.id() != LogicalTypeId::HUGEINT) {
248: 			return ScalarFunction("+", {left_type, right_type}, left_type,
249: 			                      GetScalarIntegerFunction<AddOperatorOverflowCheck>(left_type.InternalType()), false,
250: 			                      nullptr, nullptr,
251: 			                      PropagateNumericStats<TryAddOperator, AddPropagateStatistics, AddOperator>);
252: 		} else {
253: 			return ScalarFunction("+", {left_type, right_type}, left_type,
254: 			                      GetScalarBinaryFunction<AddOperator>(left_type.InternalType()));
255: 		}
256: 	}
257: 
258: 	switch (left_type.id()) {
259: 	case LogicalTypeId::DATE:
260: 		if (right_type.id() == LogicalTypeId::INTEGER) {
261: 			return ScalarFunction("+", {left_type, right_type}, LogicalType::DATE,
262: 			                      ScalarFunction::BinaryFunction<date_t, int32_t, date_t, AddOperator>);
263: 		} else if (right_type.id() == LogicalTypeId::INTERVAL) {
264: 			return ScalarFunction("+", {left_type, right_type}, LogicalType::DATE,
265: 			                      ScalarFunction::BinaryFunction<date_t, interval_t, date_t, AddOperator>);
266: 		} else if (right_type.id() == LogicalTypeId::TIME) {
267: 			return ScalarFunction("+", {left_type, right_type}, LogicalType::TIMESTAMP,
268: 			                      ScalarFunction::BinaryFunction<date_t, dtime_t, timestamp_t, AddOperator>);
269: 		}
270: 		break;
271: 	case LogicalTypeId::INTEGER:
272: 		if (right_type.id() == LogicalTypeId::DATE) {
273: 			return ScalarFunction("+", {left_type, right_type}, right_type,
274: 			                      ScalarFunction::BinaryFunction<int32_t, date_t, date_t, AddOperator>);
275: 		}
276: 		break;
277: 	case LogicalTypeId::INTERVAL:
278: 		if (right_type.id() == LogicalTypeId::INTERVAL) {
279: 			return ScalarFunction("+", {left_type, right_type}, LogicalType::INTERVAL,
280: 			                      ScalarFunction::BinaryFunction<interval_t, interval_t, interval_t, AddOperator>);
281: 		} else if (right_type.id() == LogicalTypeId::DATE) {
282: 			return ScalarFunction("+", {left_type, right_type}, LogicalType::DATE,
283: 			                      ScalarFunction::BinaryFunction<interval_t, date_t, date_t, AddOperator>);
284: 		} else if (right_type.id() == LogicalTypeId::TIME) {
285: 			return ScalarFunction("+", {left_type, right_type}, LogicalType::TIME,
286: 			                      ScalarFunction::BinaryFunction<interval_t, dtime_t, dtime_t, AddTimeOperator>);
287: 		} else if (right_type.id() == LogicalTypeId::TIMESTAMP) {
288: 			return ScalarFunction("+", {left_type, right_type}, LogicalType::TIMESTAMP,
289: 			                      ScalarFunction::BinaryFunction<interval_t, timestamp_t, timestamp_t, AddOperator>);
290: 		}
291: 		break;
292: 	case LogicalTypeId::TIME:
293: 		if (right_type.id() == LogicalTypeId::INTERVAL) {
294: 			return ScalarFunction("+", {left_type, right_type}, LogicalType::TIME,
295: 			                      ScalarFunction::BinaryFunction<dtime_t, interval_t, dtime_t, AddTimeOperator>);
296: 		} else if (right_type.id() == LogicalTypeId::DATE) {
297: 			return ScalarFunction("+", {left_type, right_type}, LogicalType::TIMESTAMP,
298: 			                      ScalarFunction::BinaryFunction<dtime_t, date_t, timestamp_t, AddOperator>);
299: 		}
300: 		break;
301: 	case LogicalTypeId::TIMESTAMP:
302: 		if (right_type.id() == LogicalTypeId::INTERVAL) {
303: 			return ScalarFunction("+", {left_type, right_type}, LogicalType::TIMESTAMP,
304: 			                      ScalarFunction::BinaryFunction<timestamp_t, interval_t, timestamp_t, AddOperator>);
305: 		}
306: 		break;
307: 	default:
308: 		break;
309: 	}
310: 	// LCOV_EXCL_START
311: 	throw NotImplementedException("AddFun for types %s, %s", LogicalTypeIdToString(left_type.id()),
312: 	                              LogicalTypeIdToString(right_type.id()));
313: 	// LCOV_EXCL_STOP
314: }
315: 
316: void AddFun::RegisterFunction(BuiltinFunctions &set) {
317: 	ScalarFunctionSet functions("+");
318: 	for (auto &type : LogicalType::Numeric()) {
319: 		// unary add function is a nop, but only exists for numeric types
320: 		functions.AddFunction(GetFunction(type));
321: 		// binary add function adds two numbers together
322: 		functions.AddFunction(GetFunction(type, type));
323: 	}
324: 	// we can add integers to dates
325: 	functions.AddFunction(GetFunction(LogicalType::DATE, LogicalType::INTEGER));
326: 	functions.AddFunction(GetFunction(LogicalType::INTEGER, LogicalType::DATE));
327: 	// we can add intervals together
328: 	functions.AddFunction(GetFunction(LogicalType::INTERVAL, LogicalType::INTERVAL));
329: 	// we can add intervals to dates/times/timestamps
330: 	functions.AddFunction(GetFunction(LogicalType::DATE, LogicalType::INTERVAL));
331: 	functions.AddFunction(GetFunction(LogicalType::INTERVAL, LogicalType::DATE));
332: 
333: 	functions.AddFunction(GetFunction(LogicalType::TIME, LogicalType::INTERVAL));
334: 	functions.AddFunction(GetFunction(LogicalType::INTERVAL, LogicalType::TIME));
335: 
336: 	functions.AddFunction(GetFunction(LogicalType::TIMESTAMP, LogicalType::INTERVAL));
337: 	functions.AddFunction(GetFunction(LogicalType::INTERVAL, LogicalType::TIMESTAMP));
338: 
339: 	// we can add times to dates
340: 	functions.AddFunction(GetFunction(LogicalType::TIME, LogicalType::DATE));
341: 	functions.AddFunction(GetFunction(LogicalType::DATE, LogicalType::TIME));
342: 
343: 	// we can add lists together
344: 	functions.AddFunction(ListConcatFun::GetFunction());
345: 
346: 	set.AddFunction(functions);
347: }
348: 
349: //===--------------------------------------------------------------------===//
350: // - [subtract]
351: //===--------------------------------------------------------------------===//
352: struct NegateOperator {
353: 	template <class T>
354: 	static bool CanNegate(T input) {
355: 		using Limits = std::numeric_limits<T>;
356: 		return !(Limits::is_integer && Limits::is_signed && Limits::lowest() == input);
357: 	}
358: 
359: 	template <class TA, class TR>
360: 	static inline TR Operation(TA input) {
361: 		auto cast = (TR)input;
362: 		if (!CanNegate<TR>(cast)) {
363: 			throw OutOfRangeException("Overflow in negation of integer!");
364: 		}
365: 		return -cast;
366: 	}
367: };
368: 
369: template <>
370: interval_t NegateOperator::Operation(interval_t input) {
371: 	interval_t result;
372: 	result.months = NegateOperator::Operation<int32_t, int32_t>(input.months);
373: 	result.days = NegateOperator::Operation<int32_t, int32_t>(input.days);
374: 	result.micros = NegateOperator::Operation<int64_t, int64_t>(input.micros);
375: 	return result;
376: }
377: 
378: unique_ptr<FunctionData> DecimalNegateBind(ClientContext &context, ScalarFunction &bound_function,
379:                                            vector<unique_ptr<Expression>> &arguments) {
380: 	auto &decimal_type = arguments[0]->return_type;
381: 	auto width = DecimalType::GetWidth(decimal_type);
382: 	if (width <= Decimal::MAX_WIDTH_INT16) {
383: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<NegateOperator>(LogicalTypeId::SMALLINT);
384: 	} else if (width <= Decimal::MAX_WIDTH_INT32) {
385: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<NegateOperator>(LogicalTypeId::INTEGER);
386: 	} else if (width <= Decimal::MAX_WIDTH_INT64) {
387: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<NegateOperator>(LogicalTypeId::BIGINT);
388: 	} else {
389: 		D_ASSERT(width <= Decimal::MAX_WIDTH_INT128);
390: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<NegateOperator>(LogicalTypeId::HUGEINT);
391: 	}
392: 	decimal_type.Verify();
393: 	bound_function.arguments[0] = decimal_type;
394: 	bound_function.return_type = decimal_type;
395: 	return nullptr;
396: }
397: 
398: struct NegatePropagateStatistics {
399: 	template <class T>
400: 	static bool Operation(LogicalType type, NumericStatistics &istats, Value &new_min, Value &new_max) {
401: 		auto max_value = istats.max.GetValueUnsafe<T>();
402: 		auto min_value = istats.min.GetValueUnsafe<T>();
403: 		if (!NegateOperator::CanNegate<T>(min_value) || !NegateOperator::CanNegate<T>(max_value)) {
404: 			return true;
405: 		}
406: 		// new min is -max
407: 		new_min = Value::Numeric(type, NegateOperator::Operation<T, T>(max_value));
408: 		// new max is -min
409: 		new_max = Value::Numeric(type, NegateOperator::Operation<T, T>(min_value));
410: 		return false;
411: 	}
412: };
413: 
414: static unique_ptr<BaseStatistics> NegateBindStatistics(ClientContext &context, BoundFunctionExpression &expr,
415:                                                        FunctionData *bind_data,
416:                                                        vector<unique_ptr<BaseStatistics>> &child_stats) {
417: 	D_ASSERT(child_stats.size() == 1);
418: 	// can only propagate stats if the children have stats
419: 	if (!child_stats[0]) {
420: 		return nullptr;
421: 	}
422: 	auto &istats = (NumericStatistics &)*child_stats[0];
423: 	Value new_min, new_max;
424: 	bool potential_overflow = true;
425: 	if (!istats.min.IsNull() && !istats.max.IsNull()) {
426: 		switch (expr.return_type.InternalType()) {
427: 		case PhysicalType::INT8:
428: 			potential_overflow =
429: 			    NegatePropagateStatistics::Operation<int8_t>(expr.return_type, istats, new_min, new_max);
430: 			break;
431: 		case PhysicalType::INT16:
432: 			potential_overflow =
433: 			    NegatePropagateStatistics::Operation<int16_t>(expr.return_type, istats, new_min, new_max);
434: 			break;
435: 		case PhysicalType::INT32:
436: 			potential_overflow =
437: 			    NegatePropagateStatistics::Operation<int32_t>(expr.return_type, istats, new_min, new_max);
438: 			break;
439: 		case PhysicalType::INT64:
440: 			potential_overflow =
441: 			    NegatePropagateStatistics::Operation<int64_t>(expr.return_type, istats, new_min, new_max);
442: 			break;
443: 		default:
444: 			return nullptr;
445: 		}
446: 	}
447: 	if (potential_overflow) {
448: 		new_min = Value(expr.return_type);
449: 		new_max = Value(expr.return_type);
450: 	}
451: 	auto stats = make_unique<NumericStatistics>(expr.return_type, move(new_min), move(new_max));
452: 	if (istats.validity_stats) {
453: 		stats->validity_stats = istats.validity_stats->Copy();
454: 	}
455: 	return move(stats);
456: }
457: 
458: ScalarFunction SubtractFun::GetFunction(const LogicalType &type) {
459: 	if (type.id() == LogicalTypeId::INTERVAL) {
460: 		return ScalarFunction("-", {type}, type, ScalarFunction::UnaryFunction<interval_t, interval_t, NegateOperator>);
461: 	} else if (type.id() == LogicalTypeId::DECIMAL) {
462: 		return ScalarFunction("-", {type}, type, nullptr, false, DecimalNegateBind, nullptr, NegateBindStatistics);
463: 	} else {
464: 		D_ASSERT(type.IsNumeric());
465: 		return ScalarFunction("-", {type}, type, ScalarFunction::GetScalarUnaryFunction<NegateOperator>(type), false,
466: 		                      nullptr, nullptr, NegateBindStatistics);
467: 	}
468: }
469: 
470: ScalarFunction SubtractFun::GetFunction(const LogicalType &left_type, const LogicalType &right_type) {
471: 	if (left_type.IsNumeric() && left_type.id() == right_type.id()) {
472: 		if (left_type.id() == LogicalTypeId::DECIMAL) {
473: 			return ScalarFunction("-", {left_type, right_type}, left_type, nullptr, false,
474: 			                      BindDecimalAddSubtract<SubtractOperator, DecimalSubtractOverflowCheck, true>);
475: 		} else if (left_type.IsIntegral() && left_type.id() != LogicalTypeId::HUGEINT) {
476: 			return ScalarFunction(
477: 			    "-", {left_type, right_type}, left_type,
478: 			    GetScalarIntegerFunction<SubtractOperatorOverflowCheck>(left_type.InternalType()), false, nullptr,
479: 			    nullptr, PropagateNumericStats<TrySubtractOperator, SubtractPropagateStatistics, SubtractOperator>);
480: 		} else {
481: 			return ScalarFunction("-", {left_type, right_type}, left_type,
482: 			                      GetScalarBinaryFunction<SubtractOperator>(left_type.InternalType()));
483: 		}
484: 	}
485: 
486: 	switch (left_type.id()) {
487: 	case LogicalTypeId::DATE:
488: 		if (right_type.id() == LogicalTypeId::DATE) {
489: 			return ScalarFunction("-", {left_type, right_type}, LogicalType::BIGINT,
490: 			                      ScalarFunction::BinaryFunction<date_t, date_t, int64_t, SubtractOperator>);
491: 		} else if (right_type.id() == LogicalTypeId::INTEGER) {
492: 			return ScalarFunction("-", {left_type, right_type}, LogicalType::DATE,
493: 			                      ScalarFunction::BinaryFunction<date_t, int32_t, date_t, SubtractOperator>);
494: 		} else if (right_type.id() == LogicalTypeId::INTERVAL) {
495: 			return ScalarFunction("-", {left_type, right_type}, LogicalType::DATE,
496: 			                      ScalarFunction::BinaryFunction<date_t, interval_t, date_t, SubtractOperator>);
497: 		}
498: 		break;
499: 	case LogicalTypeId::TIMESTAMP:
500: 		if (right_type.id() == LogicalTypeId::TIMESTAMP) {
501: 			return ScalarFunction(
502: 			    "-", {left_type, right_type}, LogicalType::INTERVAL,
503: 			    ScalarFunction::BinaryFunction<timestamp_t, timestamp_t, interval_t, SubtractOperator>);
504: 		} else if (right_type.id() == LogicalTypeId::INTERVAL) {
505: 			return ScalarFunction(
506: 			    "-", {left_type, right_type}, LogicalType::TIMESTAMP,
507: 			    ScalarFunction::BinaryFunction<timestamp_t, interval_t, timestamp_t, SubtractOperator>);
508: 		}
509: 		break;
510: 	case LogicalTypeId::INTERVAL:
511: 		if (right_type.id() == LogicalTypeId::INTERVAL) {
512: 			return ScalarFunction("-", {left_type, right_type}, LogicalType::INTERVAL,
513: 			                      ScalarFunction::BinaryFunction<interval_t, interval_t, interval_t, SubtractOperator>);
514: 		}
515: 		break;
516: 	case LogicalTypeId::TIME:
517: 		if (right_type.id() == LogicalTypeId::INTERVAL) {
518: 			return ScalarFunction("-", {left_type, right_type}, LogicalType::TIME,
519: 			                      ScalarFunction::BinaryFunction<dtime_t, interval_t, dtime_t, SubtractTimeOperator>);
520: 		}
521: 		break;
522: 	default:
523: 		break;
524: 	}
525: 	// LCOV_EXCL_START
526: 	throw NotImplementedException("SubtractFun for types %s, %s", LogicalTypeIdToString(left_type.id()),
527: 	                              LogicalTypeIdToString(right_type.id()));
528: 	// LCOV_EXCL_STOP
529: }
530: 
531: void SubtractFun::RegisterFunction(BuiltinFunctions &set) {
532: 	ScalarFunctionSet functions("-");
533: 	for (auto &type : LogicalType::Numeric()) {
534: 		// unary subtract function, negates the input (i.e. multiplies by -1)
535: 		functions.AddFunction(GetFunction(type));
536: 		// binary subtract function "a - b", subtracts b from a
537: 		functions.AddFunction(GetFunction(type, type));
538: 	}
539: 	// we can subtract dates from each other
540: 	functions.AddFunction(GetFunction(LogicalType::DATE, LogicalType::DATE));
541: 	// we can subtract integers from dates
542: 	functions.AddFunction(GetFunction(LogicalType::DATE, LogicalType::INTEGER));
543: 	// we can subtract timestamps from each other
544: 	functions.AddFunction(GetFunction(LogicalType::TIMESTAMP, LogicalType::TIMESTAMP));
545: 	// we can subtract intervals from each other
546: 	functions.AddFunction(GetFunction(LogicalType::INTERVAL, LogicalType::INTERVAL));
547: 	// we can subtract intervals from dates/times/timestamps, but not the other way around
548: 	functions.AddFunction(GetFunction(LogicalType::DATE, LogicalType::INTERVAL));
549: 	functions.AddFunction(GetFunction(LogicalType::TIME, LogicalType::INTERVAL));
550: 	functions.AddFunction(GetFunction(LogicalType::TIMESTAMP, LogicalType::INTERVAL));
551: 	// we can negate intervals
552: 	functions.AddFunction(GetFunction(LogicalType::INTERVAL));
553: 	set.AddFunction(functions);
554: }
555: 
556: //===--------------------------------------------------------------------===//
557: // * [multiply]
558: //===--------------------------------------------------------------------===//
559: struct MultiplyPropagateStatistics {
560: 	template <class T, class OP>
561: 	static bool Operation(LogicalType type, NumericStatistics &lstats, NumericStatistics &rstats, Value &new_min,
562: 	                      Value &new_max) {
563: 		// statistics propagation on the multiplication is slightly less straightforward because of negative numbers
564: 		// the new min/max depend on the signs of the input types
565: 		// if both are positive the result is [lmin * rmin][lmax * rmax]
566: 		// if lmin/lmax are negative the result is [lmin * rmax][lmax * rmin]
567: 		// etc
568: 		// rather than doing all this switcheroo we just multiply all combinations of lmin/lmax with rmin/rmax
569: 		// and check what the minimum/maximum value is
570: 		T lvals[] {lstats.min.GetValueUnsafe<T>(), lstats.max.GetValueUnsafe<T>()};
571: 		T rvals[] {rstats.min.GetValueUnsafe<T>(), rstats.max.GetValueUnsafe<T>()};
572: 		T min = NumericLimits<T>::Maximum();
573: 		T max = NumericLimits<T>::Minimum();
574: 		// multiplications
575: 		for (idx_t l = 0; l < 2; l++) {
576: 			for (idx_t r = 0; r < 2; r++) {
577: 				T result;
578: 				if (!OP::Operation(lvals[l], rvals[r], result)) {
579: 					// potential overflow
580: 					return true;
581: 				}
582: 				if (result < min) {
583: 					min = result;
584: 				}
585: 				if (result > max) {
586: 					max = result;
587: 				}
588: 			}
589: 		}
590: 		new_min = Value::Numeric(type, min);
591: 		new_max = Value::Numeric(type, max);
592: 		return false;
593: 	}
594: };
595: 
596: unique_ptr<FunctionData> BindDecimalMultiply(ClientContext &context, ScalarFunction &bound_function,
597:                                              vector<unique_ptr<Expression>> &arguments) {
598: 	uint8_t result_width = 0, result_scale = 0;
599: 	uint8_t max_width = 0;
600: 	for (idx_t i = 0; i < arguments.size(); i++) {
601: 		if (arguments[i]->return_type.id() == LogicalTypeId::UNKNOWN) {
602: 			continue;
603: 		}
604: 		uint8_t width, scale;
605: 		auto can_convert = arguments[i]->return_type.GetDecimalProperties(width, scale);
606: 		if (!can_convert) {
607: 			throw InternalException("Could not convert type %s to a decimal?", arguments[i]->return_type.ToString());
608: 		}
609: 		if (width > max_width) {
610: 			max_width = width;
611: 		}
612: 		result_width += width;
613: 		result_scale += scale;
614: 	}
615: 	D_ASSERT(max_width > 0);
616: 	if (result_scale > Decimal::MAX_WIDTH_DECIMAL) {
617: 		throw OutOfRangeException(
618: 		    "Needed scale %d to accurately represent the multiplication result, but this is out of range of the "
619: 		    "DECIMAL type. Max scale is %d; could not perform an accurate multiplication. Either add a cast to DOUBLE, "
620: 		    "or add an explicit cast to a decimal with a lower scale.",
621: 		    result_scale, Decimal::MAX_WIDTH_DECIMAL);
622: 	}
623: 	bool check_overflow = false;
624: 	if (result_width > Decimal::MAX_WIDTH_INT64 && max_width <= Decimal::MAX_WIDTH_INT64 &&
625: 	    result_scale < Decimal::MAX_WIDTH_INT64) {
626: 		check_overflow = true;
627: 		result_width = Decimal::MAX_WIDTH_INT64;
628: 	}
629: 	if (result_width > Decimal::MAX_WIDTH_DECIMAL) {
630: 		check_overflow = true;
631: 		result_width = Decimal::MAX_WIDTH_DECIMAL;
632: 	}
633: 	LogicalType result_type = LogicalType::DECIMAL(result_width, result_scale);
634: 	// since our scale is the summation of our input scales, we do not need to cast to the result scale
635: 	// however, we might need to cast to the correct internal type
636: 	for (idx_t i = 0; i < arguments.size(); i++) {
637: 		auto &argument_type = arguments[i]->return_type;
638: 		if (argument_type.InternalType() == result_type.InternalType()) {
639: 			bound_function.arguments[i] = argument_type;
640: 		} else {
641: 			uint8_t width, scale;
642: 			if (!argument_type.GetDecimalProperties(width, scale)) {
643: 				scale = 0;
644: 			}
645: 
646: 			bound_function.arguments[i] = LogicalType::DECIMAL(result_width, scale);
647: 		}
648: 	}
649: 	result_type.Verify();
650: 	bound_function.return_type = result_type;
651: 	// now select the physical function to execute
652: 	if (check_overflow) {
653: 		bound_function.function = GetScalarBinaryFunction<DecimalMultiplyOverflowCheck>(result_type.InternalType());
654: 	} else {
655: 		bound_function.function = GetScalarBinaryFunction<MultiplyOperator>(result_type.InternalType());
656: 	}
657: 	if (result_type.InternalType() != PhysicalType::INT128) {
658: 		bound_function.statistics =
659: 		    PropagateNumericStats<TryDecimalMultiply, MultiplyPropagateStatistics, MultiplyOperator>;
660: 	}
661: 	return nullptr;
662: }
663: 
664: void MultiplyFun::RegisterFunction(BuiltinFunctions &set) {
665: 	ScalarFunctionSet functions("*");
666: 	for (auto &type : LogicalType::Numeric()) {
667: 		if (type.id() == LogicalTypeId::DECIMAL) {
668: 			functions.AddFunction(ScalarFunction({type, type}, type, nullptr, false, BindDecimalMultiply));
669: 		} else if (TypeIsIntegral(type.InternalType()) && type.id() != LogicalTypeId::HUGEINT) {
670: 			functions.AddFunction(ScalarFunction(
671: 			    {type, type}, type, GetScalarIntegerFunction<MultiplyOperatorOverflowCheck>(type.InternalType()), false,
672: 			    nullptr, nullptr,
673: 			    PropagateNumericStats<TryMultiplyOperator, MultiplyPropagateStatistics, MultiplyOperator>));
674: 		} else {
675: 			functions.AddFunction(
676: 			    ScalarFunction({type, type}, type, GetScalarBinaryFunction<MultiplyOperator>(type.InternalType())));
677: 		}
678: 	}
679: 	functions.AddFunction(
680: 	    ScalarFunction({LogicalType::INTERVAL, LogicalType::BIGINT}, LogicalType::INTERVAL,
681: 	                   ScalarFunction::BinaryFunction<interval_t, int64_t, interval_t, MultiplyOperator>));
682: 	functions.AddFunction(
683: 	    ScalarFunction({LogicalType::BIGINT, LogicalType::INTERVAL}, LogicalType::INTERVAL,
684: 	                   ScalarFunction::BinaryFunction<int64_t, interval_t, interval_t, MultiplyOperator>));
685: 	set.AddFunction(functions);
686: }
687: 
688: //===--------------------------------------------------------------------===//
689: // / [divide]
690: //===--------------------------------------------------------------------===//
691: template <>
692: float DivideOperator::Operation(float left, float right) {
693: 	auto result = left / right;
694: 	if (!Value::FloatIsValid(result)) {
695: 		throw OutOfRangeException("Overflow in division of float!");
696: 	}
697: 	return result;
698: }
699: 
700: template <>
701: double DivideOperator::Operation(double left, double right) {
702: 	auto result = left / right;
703: 	if (!Value::DoubleIsValid(result)) {
704: 		throw OutOfRangeException("Overflow in division of double!");
705: 	}
706: 	return result;
707: }
708: 
709: template <>
710: hugeint_t DivideOperator::Operation(hugeint_t left, hugeint_t right) {
711: 	if (right.lower == 0 && right.upper == 0) {
712: 		throw InternalException("Hugeint division by zero!");
713: 	}
714: 	return left / right;
715: }
716: 
717: template <>
718: interval_t DivideOperator::Operation(interval_t left, int64_t right) {
719: 	left.days /= right;
720: 	left.months /= right;
721: 	left.micros /= right;
722: 	return left;
723: }
724: 
725: struct BinaryZeroIsNullWrapper {
726: 	template <class FUNC, class OP, class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE>
727: 	static inline RESULT_TYPE Operation(FUNC fun, LEFT_TYPE left, RIGHT_TYPE right, ValidityMask &mask, idx_t idx) {
728: 		if (right == 0) {
729: 			mask.SetInvalid(idx);
730: 			return left;
731: 		} else {
732: 			return OP::template Operation<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE>(left, right);
733: 		}
734: 	}
735: 
736: 	static bool AddsNulls() {
737: 		return true;
738: 	}
739: };
740: 
741: struct BinaryZeroIsNullHugeintWrapper {
742: 	template <class FUNC, class OP, class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE>
743: 	static inline RESULT_TYPE Operation(FUNC fun, LEFT_TYPE left, RIGHT_TYPE right, ValidityMask &mask, idx_t idx) {
744: 		if (right.upper == 0 && right.lower == 0) {
745: 			mask.SetInvalid(idx);
746: 			return left;
747: 		} else {
748: 			return OP::template Operation<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE>(left, right);
749: 		}
750: 	}
751: 
752: 	static bool AddsNulls() {
753: 		return true;
754: 	}
755: };
756: 
757: template <class TA, class TB, class TC, class OP, class ZWRAPPER = BinaryZeroIsNullWrapper>
758: static void BinaryScalarFunctionIgnoreZero(DataChunk &input, ExpressionState &state, Vector &result) {
759: 	BinaryExecutor::Execute<TA, TB, TC, OP, ZWRAPPER>(input.data[0], input.data[1], result, input.size());
760: }
761: 
762: template <class OP>
763: static scalar_function_t GetBinaryFunctionIgnoreZero(const LogicalType &type) {
764: 	switch (type.id()) {
765: 	case LogicalTypeId::TINYINT:
766: 		return BinaryScalarFunctionIgnoreZero<int8_t, int8_t, int8_t, OP>;
767: 	case LogicalTypeId::SMALLINT:
768: 		return BinaryScalarFunctionIgnoreZero<int16_t, int16_t, int16_t, OP>;
769: 	case LogicalTypeId::INTEGER:
770: 		return BinaryScalarFunctionIgnoreZero<int32_t, int32_t, int32_t, OP>;
771: 	case LogicalTypeId::BIGINT:
772: 		return BinaryScalarFunctionIgnoreZero<int64_t, int64_t, int64_t, OP>;
773: 	case LogicalTypeId::UTINYINT:
774: 		return BinaryScalarFunctionIgnoreZero<uint8_t, uint8_t, uint8_t, OP>;
775: 	case LogicalTypeId::USMALLINT:
776: 		return BinaryScalarFunctionIgnoreZero<uint16_t, uint16_t, uint16_t, OP>;
777: 	case LogicalTypeId::UINTEGER:
778: 		return BinaryScalarFunctionIgnoreZero<uint32_t, uint32_t, uint32_t, OP>;
779: 	case LogicalTypeId::UBIGINT:
780: 		return BinaryScalarFunctionIgnoreZero<uint64_t, uint64_t, uint64_t, OP>;
781: 	case LogicalTypeId::HUGEINT:
782: 		return BinaryScalarFunctionIgnoreZero<hugeint_t, hugeint_t, hugeint_t, OP, BinaryZeroIsNullHugeintWrapper>;
783: 	case LogicalTypeId::FLOAT:
784: 		return BinaryScalarFunctionIgnoreZero<float, float, float, OP>;
785: 	case LogicalTypeId::DOUBLE:
786: 		return BinaryScalarFunctionIgnoreZero<double, double, double, OP>;
787: 	default:
788: 		throw NotImplementedException("Unimplemented type for GetScalarUnaryFunction");
789: 	}
790: }
791: 
792: void DivideFun::RegisterFunction(BuiltinFunctions &set) {
793: 	ScalarFunctionSet functions("/");
794: 	for (auto &type : LogicalType::Numeric()) {
795: 		if (type.id() == LogicalTypeId::DECIMAL) {
796: 			continue;
797: 		} else {
798: 			functions.AddFunction(
799: 			    ScalarFunction({type, type}, type, GetBinaryFunctionIgnoreZero<DivideOperator>(type)));
800: 		}
801: 	}
802: 	functions.AddFunction(
803: 	    ScalarFunction({LogicalType::INTERVAL, LogicalType::BIGINT}, LogicalType::INTERVAL,
804: 	                   BinaryScalarFunctionIgnoreZero<interval_t, int64_t, interval_t, DivideOperator>));
805: 
806: 	set.AddFunction(functions);
807: }
808: 
809: //===--------------------------------------------------------------------===//
810: // % [modulo]
811: //===--------------------------------------------------------------------===//
812: template <>
813: float ModuloOperator::Operation(float left, float right) {
814: 	D_ASSERT(right != 0);
815: 	return std::fmod(left, right);
816: }
817: 
818: template <>
819: double ModuloOperator::Operation(double left, double right) {
820: 	D_ASSERT(right != 0);
821: 	return std::fmod(left, right);
822: }
823: 
824: template <>
825: hugeint_t ModuloOperator::Operation(hugeint_t left, hugeint_t right) {
826: 	if (right.lower == 0 && right.upper == 0) {
827: 		throw InternalException("Hugeint division by zero!");
828: 	}
829: 	return left % right;
830: }
831: 
832: void ModFun::RegisterFunction(BuiltinFunctions &set) {
833: 	ScalarFunctionSet functions("%");
834: 	for (auto &type : LogicalType::Numeric()) {
835: 		if (type.id() == LogicalTypeId::DECIMAL) {
836: 			continue;
837: 		} else {
838: 			functions.AddFunction(
839: 			    ScalarFunction({type, type}, type, GetBinaryFunctionIgnoreZero<ModuloOperator>(type)));
840: 		}
841: 	}
842: 	set.AddFunction(functions);
843: 	functions.name = "mod";
844: 	set.AddFunction(functions);
845: }
846: 
847: } // namespace duckdb
[end of src/function/scalar/operators/arithmetic.cpp]
[start of src/function/scalar/operators/multiply.cpp]
1: #include "duckdb/common/operator/multiply.hpp"
2: 
3: #include "duckdb/common/limits.hpp"
4: #include "duckdb/common/types/hugeint.hpp"
5: #include "duckdb/common/types/value.hpp"
6: #include "duckdb/common/windows_undefs.hpp"
7: 
8: #include <limits>
9: #include <algorithm>
10: 
11: namespace duckdb {
12: 
13: //===--------------------------------------------------------------------===//
14: // * [multiply]
15: //===--------------------------------------------------------------------===//
16: template <>
17: float MultiplyOperator::Operation(float left, float right) {
18: 	auto result = left * right;
19: 	if (!Value::FloatIsValid(result)) {
20: 		throw OutOfRangeException("Overflow in multiplication of float!");
21: 	}
22: 	return result;
23: }
24: 
25: template <>
26: double MultiplyOperator::Operation(double left, double right) {
27: 	auto result = left * right;
28: 	if (!Value::DoubleIsValid(result)) {
29: 		throw OutOfRangeException("Overflow in multiplication of double!");
30: 	}
31: 	return result;
32: }
33: 
34: template <>
35: interval_t MultiplyOperator::Operation(interval_t left, int64_t right) {
36: 	left.months = MultiplyOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.months, right);
37: 	left.days = MultiplyOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.days, right);
38: 	left.micros = MultiplyOperatorOverflowCheck::Operation<int64_t, int64_t, int64_t>(left.micros, right);
39: 	return left;
40: }
41: 
42: template <>
43: interval_t MultiplyOperator::Operation(int64_t left, interval_t right) {
44: 	return MultiplyOperator::Operation<interval_t, int64_t, interval_t>(right, left);
45: }
46: 
47: //===--------------------------------------------------------------------===//
48: // * [multiply] with overflow check
49: //===--------------------------------------------------------------------===//
50: struct OverflowCheckedMultiply {
51: 	template <class SRCTYPE, class UTYPE>
52: 	static inline bool Operation(SRCTYPE left, SRCTYPE right, SRCTYPE &result) {
53: 		UTYPE uresult = MultiplyOperator::Operation<UTYPE, UTYPE, UTYPE>(UTYPE(left), UTYPE(right));
54: 		if (uresult < NumericLimits<SRCTYPE>::Minimum() || uresult > NumericLimits<SRCTYPE>::Maximum()) {
55: 			return false;
56: 		}
57: 		result = SRCTYPE(uresult);
58: 		return true;
59: 	}
60: };
61: 
62: template <>
63: bool TryMultiplyOperator::Operation(uint8_t left, uint8_t right, uint8_t &result) {
64: 	return OverflowCheckedMultiply::Operation<uint8_t, uint16_t>(left, right, result);
65: }
66: template <>
67: bool TryMultiplyOperator::Operation(uint16_t left, uint16_t right, uint16_t &result) {
68: 	return OverflowCheckedMultiply::Operation<uint16_t, uint32_t>(left, right, result);
69: }
70: template <>
71: bool TryMultiplyOperator::Operation(uint32_t left, uint32_t right, uint32_t &result) {
72: 	return OverflowCheckedMultiply::Operation<uint32_t, uint64_t>(left, right, result);
73: }
74: template <>
75: bool TryMultiplyOperator::Operation(uint64_t left, uint64_t right, uint64_t &result) {
76: 	if (left > right) {
77: 		std::swap(left, right);
78: 	}
79: 	if (left > NumericLimits<uint32_t>::Maximum()) {
80: 		return false;
81: 	}
82: 	uint32_t c = right >> 32;
83: 	uint32_t d = NumericLimits<uint32_t>::Maximum() & right;
84: 	uint64_t r = left * c;
85: 	uint64_t s = left * d;
86: 	if (r > NumericLimits<uint32_t>::Maximum()) {
87: 		return false;
88: 	}
89: 	r <<= 32;
90: 	if (NumericLimits<uint64_t>::Maximum() - s < r) {
91: 		return false;
92: 	}
93: 	return OverflowCheckedMultiply::Operation<uint64_t, uint64_t>(left, right, result);
94: }
95: 
96: template <>
97: bool TryMultiplyOperator::Operation(int8_t left, int8_t right, int8_t &result) {
98: 	return OverflowCheckedMultiply::Operation<int8_t, int16_t>(left, right, result);
99: }
100: 
101: template <>
102: bool TryMultiplyOperator::Operation(int16_t left, int16_t right, int16_t &result) {
103: 	return OverflowCheckedMultiply::Operation<int16_t, int32_t>(left, right, result);
104: }
105: 
106: template <>
107: bool TryMultiplyOperator::Operation(int32_t left, int32_t right, int32_t &result) {
108: 	return OverflowCheckedMultiply::Operation<int32_t, int64_t>(left, right, result);
109: }
110: 
111: template <>
112: bool TryMultiplyOperator::Operation(int64_t left, int64_t right, int64_t &result) {
113: #if (__GNUC__ >= 5) || defined(__clang__)
114: 	if (__builtin_mul_overflow(left, right, &result)) {
115: 		return false;
116: 	}
117: #else
118: 	if (left == std::numeric_limits<int64_t>::min()) {
119: 		if (right == 0) {
120: 			result = 0;
121: 			return true;
122: 		}
123: 		if (right == 1) {
124: 			result = left;
125: 			return true;
126: 		}
127: 		return false;
128: 	}
129: 	if (right == std::numeric_limits<int64_t>::min()) {
130: 		if (left == 0) {
131: 			result = 0;
132: 			return true;
133: 		}
134: 		if (left == 1) {
135: 			result = right;
136: 			return true;
137: 		}
138: 		return false;
139: 	}
140: 	uint64_t left_non_negative = uint64_t(std::abs(left));
141: 	uint64_t right_non_negative = uint64_t(std::abs(right));
142: 	// split values into 2 32-bit parts
143: 	uint64_t left_high_bits = left_non_negative >> 32;
144: 	uint64_t left_low_bits = left_non_negative & 0xffffffff;
145: 	uint64_t right_high_bits = right_non_negative >> 32;
146: 	uint64_t right_low_bits = right_non_negative & 0xffffffff;
147: 
148: 	// check the high bits of both
149: 	// the high bits define the overflow
150: 	if (left_high_bits == 0) {
151: 		if (right_high_bits != 0) {
152: 			// only the right has high bits set
153: 			// multiply the high bits of right with the low bits of left
154: 			// multiply the low bits, and carry any overflow to the high bits
155: 			// then check for any overflow
156: 			auto low_low = left_low_bits * right_low_bits;
157: 			auto low_high = left_low_bits * right_high_bits;
158: 			auto high_bits = low_high + (low_low >> 32);
159: 			if (high_bits & 0xffffff80000000) {
160: 				// there is! abort
161: 				return false;
162: 			}
163: 		}
164: 	} else if (right_high_bits == 0) {
165: 		// only the left has high bits set
166: 		// multiply the high bits of left with the low bits of right
167: 		// multiply the low bits, and carry any overflow to the high bits
168: 		// then check for any overflow
169: 		auto low_low = left_low_bits * right_low_bits;
170: 		auto high_low = left_high_bits * right_low_bits;
171: 		auto high_bits = high_low + (low_low >> 32);
172: 		if (high_bits & 0xffffff80000000) {
173: 			// there is! abort
174: 			return false;
175: 		}
176: 	} else {
177: 		// both left and right have high bits set: guaranteed overflow
178: 		// abort!
179: 		return false;
180: 	}
181: 	// now we know that there is no overflow, we can just perform the multiplication
182: 	result = left * right;
183: #endif
184: 	return true;
185: }
186: 
187: //===--------------------------------------------------------------------===//
188: // multiply  decimal with overflow check
189: //===--------------------------------------------------------------------===//
190: template <class T, T min, T max>
191: bool TryDecimalMultiplyTemplated(T left, T right, T &result) {
192: 	if (!TryMultiplyOperator::Operation(left, right, result) || result < min || result > max) {
193: 		return false;
194: 	}
195: 	return true;
196: }
197: 
198: template <>
199: bool TryDecimalMultiply::Operation(int16_t left, int16_t right, int16_t &result) {
200: 	return TryDecimalMultiplyTemplated<int16_t, -9999, 9999>(left, right, result);
201: }
202: 
203: template <>
204: bool TryDecimalMultiply::Operation(int32_t left, int32_t right, int32_t &result) {
205: 	return TryDecimalMultiplyTemplated<int32_t, -999999999, 999999999>(left, right, result);
206: }
207: 
208: template <>
209: bool TryDecimalMultiply::Operation(int64_t left, int64_t right, int64_t &result) {
210: 	return TryDecimalMultiplyTemplated<int64_t, -999999999999999999, 999999999999999999>(left, right, result);
211: }
212: 
213: template <>
214: bool TryDecimalMultiply::Operation(hugeint_t left, hugeint_t right, hugeint_t &result) {
215: 	result = left * right;
216: 	if (result <= -Hugeint::POWERS_OF_TEN[38] || result >= Hugeint::POWERS_OF_TEN[38]) {
217: 		return false;
218: 	}
219: 	return true;
220: }
221: 
222: template <>
223: hugeint_t DecimalMultiplyOverflowCheck::Operation(hugeint_t left, hugeint_t right) {
224: 	hugeint_t result;
225: 	if (!TryDecimalMultiply::Operation(left, right, result)) {
226: 		throw OutOfRangeException("Overflow in multiplication of DECIMAL(38) (%s * %s). You might want to add an "
227: 		                          "explicit cast to a decimal with a smaller scale.",
228: 		                          left.ToString(), right.ToString());
229: 	}
230: 	return result;
231: }
232: 
233: } // namespace duckdb
[end of src/function/scalar/operators/multiply.cpp]
[start of src/function/scalar/operators/subtract.cpp]
1: #include "duckdb/common/operator/subtract.hpp"
2: 
3: #include "duckdb/common/limits.hpp"
4: #include "duckdb/common/operator/add.hpp"
5: #include "duckdb/common/types/hugeint.hpp"
6: #include "duckdb/common/types/interval.hpp"
7: #include "duckdb/common/types/value.hpp"
8: 
9: #include <limits>
10: 
11: namespace duckdb {
12: 
13: //===--------------------------------------------------------------------===//
14: // - [subtract]
15: //===--------------------------------------------------------------------===//
16: template <>
17: float SubtractOperator::Operation(float left, float right) {
18: 	auto result = left - right;
19: 	if (!Value::FloatIsValid(result)) {
20: 		throw OutOfRangeException("Overflow in subtraction of float!");
21: 	}
22: 	return result;
23: }
24: 
25: template <>
26: double SubtractOperator::Operation(double left, double right) {
27: 	auto result = left - right;
28: 	if (!Value::DoubleIsValid(result)) {
29: 		throw OutOfRangeException("Overflow in subtraction of double!");
30: 	}
31: 	return result;
32: }
33: 
34: template <>
35: int64_t SubtractOperator::Operation(date_t left, date_t right) {
36: 	return int64_t(left.days) - int64_t(right.days);
37: }
38: 
39: template <>
40: date_t SubtractOperator::Operation(date_t left, int32_t right) {
41: 	int32_t result;
42: 	if (!TrySubtractOperator::Operation(left.days, right, result)) {
43: 		throw OutOfRangeException("Date out of range");
44: 	}
45: 	return date_t(result);
46: }
47: 
48: template <>
49: interval_t SubtractOperator::Operation(interval_t left, interval_t right) {
50: 	interval_t result;
51: 	result.months = left.months - right.months;
52: 	result.days = left.days - right.days;
53: 	result.micros = left.micros - right.micros;
54: 	return result;
55: }
56: 
57: template <>
58: date_t SubtractOperator::Operation(date_t left, interval_t right) {
59: 	right.months = -right.months;
60: 	right.days = -right.days;
61: 	right.micros = -right.micros;
62: 	return AddOperator::Operation<date_t, interval_t, date_t>(left, right);
63: }
64: 
65: template <>
66: timestamp_t SubtractOperator::Operation(timestamp_t left, interval_t right) {
67: 	right.months = -right.months;
68: 	right.days = -right.days;
69: 	right.micros = -right.micros;
70: 	return AddOperator::Operation<timestamp_t, interval_t, timestamp_t>(left, right);
71: }
72: 
73: template <>
74: interval_t SubtractOperator::Operation(timestamp_t left, timestamp_t right) {
75: 	return Interval::GetDifference(left, right);
76: }
77: 
78: //===--------------------------------------------------------------------===//
79: // - [subtract] with overflow check
80: //===--------------------------------------------------------------------===//
81: struct OverflowCheckedSubtract {
82: 	template <class SRCTYPE, class UTYPE>
83: 	static inline bool Operation(SRCTYPE left, SRCTYPE right, SRCTYPE &result) {
84: 		UTYPE uresult = SubtractOperator::Operation<UTYPE, UTYPE, UTYPE>(UTYPE(left), UTYPE(right));
85: 		if (uresult < NumericLimits<SRCTYPE>::Minimum() || uresult > NumericLimits<SRCTYPE>::Maximum()) {
86: 			return false;
87: 		}
88: 		result = SRCTYPE(uresult);
89: 		return true;
90: 	}
91: };
92: 
93: template <>
94: bool TrySubtractOperator::Operation(uint8_t left, uint8_t right, uint8_t &result) {
95: 	if (right > left) {
96: 		return false;
97: 	}
98: 	return OverflowCheckedSubtract::Operation<uint8_t, uint16_t>(left, right, result);
99: }
100: 
101: template <>
102: bool TrySubtractOperator::Operation(uint16_t left, uint16_t right, uint16_t &result) {
103: 	if (right > left) {
104: 		return false;
105: 	}
106: 	return OverflowCheckedSubtract::Operation<uint16_t, uint32_t>(left, right, result);
107: }
108: 
109: template <>
110: bool TrySubtractOperator::Operation(uint32_t left, uint32_t right, uint32_t &result) {
111: 	if (right > left) {
112: 		return false;
113: 	}
114: 	return OverflowCheckedSubtract::Operation<uint32_t, uint64_t>(left, right, result);
115: }
116: 
117: template <>
118: bool TrySubtractOperator::Operation(uint64_t left, uint64_t right, uint64_t &result) {
119: 	if (right > left) {
120: 		return false;
121: 	}
122: 	return OverflowCheckedSubtract::Operation<uint64_t, uint64_t>(left, right, result);
123: }
124: 
125: template <>
126: bool TrySubtractOperator::Operation(int8_t left, int8_t right, int8_t &result) {
127: 	return OverflowCheckedSubtract::Operation<int8_t, int16_t>(left, right, result);
128: }
129: 
130: template <>
131: bool TrySubtractOperator::Operation(int16_t left, int16_t right, int16_t &result) {
132: 	return OverflowCheckedSubtract::Operation<int16_t, int32_t>(left, right, result);
133: }
134: 
135: template <>
136: bool TrySubtractOperator::Operation(int32_t left, int32_t right, int32_t &result) {
137: 	return OverflowCheckedSubtract::Operation<int32_t, int64_t>(left, right, result);
138: }
139: 
140: template <>
141: bool TrySubtractOperator::Operation(int64_t left, int64_t right, int64_t &result) {
142: #if (__GNUC__ >= 5) || defined(__clang__)
143: 	if (__builtin_sub_overflow(left, right, &result)) {
144: 		return false;
145: 	}
146: #else
147: 	if (right < 0) {
148: 		if (NumericLimits<int64_t>::Maximum() + right < left) {
149: 			return false;
150: 		}
151: 	} else {
152: 		if (NumericLimits<int64_t>::Minimum() + right > left) {
153: 			return false;
154: 		}
155: 	}
156: 	result = left - right;
157: #endif
158: 	return true;
159: }
160: 
161: //===--------------------------------------------------------------------===//
162: // subtract decimal with overflow check
163: //===--------------------------------------------------------------------===//
164: template <class T, T min, T max>
165: bool TryDecimalSubtractTemplated(T left, T right, T &result) {
166: 	if (right < 0) {
167: 		if (max + right < left) {
168: 			return false;
169: 		}
170: 	} else {
171: 		if (min + right > left) {
172: 			return false;
173: 		}
174: 	}
175: 	result = left - right;
176: 	return true;
177: }
178: 
179: template <>
180: bool TryDecimalSubtract::Operation(int16_t left, int16_t right, int16_t &result) {
181: 	return TryDecimalSubtractTemplated<int16_t, -9999, 9999>(left, right, result);
182: }
183: 
184: template <>
185: bool TryDecimalSubtract::Operation(int32_t left, int32_t right, int32_t &result) {
186: 	return TryDecimalSubtractTemplated<int32_t, -999999999, 999999999>(left, right, result);
187: }
188: 
189: template <>
190: bool TryDecimalSubtract::Operation(int64_t left, int64_t right, int64_t &result) {
191: 	return TryDecimalSubtractTemplated<int64_t, -999999999999999999, 999999999999999999>(left, right, result);
192: }
193: 
194: template <>
195: bool TryDecimalSubtract::Operation(hugeint_t left, hugeint_t right, hugeint_t &result) {
196: 	result = left - right;
197: 	if (result <= -Hugeint::POWERS_OF_TEN[38] || result >= Hugeint::POWERS_OF_TEN[38]) {
198: 		return false;
199: 	}
200: 	return true;
201: }
202: 
203: template <>
204: hugeint_t DecimalSubtractOverflowCheck::Operation(hugeint_t left, hugeint_t right) {
205: 	hugeint_t result;
206: 	if (!TryDecimalSubtract::Operation(left, right, result)) {
207: 		throw OutOfRangeException("Overflow in subtract of DECIMAL(38) (%s - %s);", left.ToString(), right.ToString());
208: 	}
209: 	return result;
210: }
211: 
212: //===--------------------------------------------------------------------===//
213: // subtract time operator
214: //===--------------------------------------------------------------------===//
215: template <>
216: dtime_t SubtractTimeOperator::Operation(dtime_t left, interval_t right) {
217: 	right.micros = -right.micros;
218: 	return AddTimeOperator::Operation<dtime_t, interval_t, dtime_t>(left, right);
219: }
220: 
221: } // namespace duckdb
[end of src/function/scalar/operators/subtract.cpp]
[start of src/function/table/arrow.cpp]
1: #include "duckdb/common/arrow.hpp"
2: 
3: #include "duckdb.hpp"
4: #include "duckdb/common/arrow_wrapper.hpp"
5: #include "duckdb/common/limits.hpp"
6: #include "duckdb/common/to_string.hpp"
7: #include "duckdb/common/types/date.hpp"
8: #include "duckdb/common/types/hugeint.hpp"
9: #include "duckdb/common/types/time.hpp"
10: #include "duckdb/common/types/timestamp.hpp"
11: #include "duckdb/function/table/arrow.hpp"
12: #include "duckdb/function/table_function.hpp"
13: #include "duckdb/main/client_context.hpp"
14: #include "duckdb/main/connection.hpp"
15: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
16: #include "utf8proc_wrapper.hpp"
17: #include "duckdb/common/types/arrow_aux_data.hpp"
18: #include "duckdb/common/types/vector_buffer.hpp"
19: #include "duckdb/common/operator/multiply.hpp"
20: #include "duckdb/common/mutex.hpp"
21: #include <map>
22: 
23: namespace duckdb {
24: 
25: LogicalType GetArrowLogicalType(ArrowSchema &schema,
26:                                 std::unordered_map<idx_t, unique_ptr<ArrowConvertData>> &arrow_convert_data,
27:                                 idx_t col_idx) {
28: 	auto format = string(schema.format);
29: 	if (arrow_convert_data.find(col_idx) == arrow_convert_data.end()) {
30: 		arrow_convert_data[col_idx] = make_unique<ArrowConvertData>();
31: 	}
32: 	if (format == "n") {
33: 		return LogicalType::SQLNULL;
34: 	} else if (format == "b") {
35: 		return LogicalType::BOOLEAN;
36: 	} else if (format == "c") {
37: 		return LogicalType::TINYINT;
38: 	} else if (format == "s") {
39: 		return LogicalType::SMALLINT;
40: 	} else if (format == "i") {
41: 		return LogicalType::INTEGER;
42: 	} else if (format == "l") {
43: 		return LogicalType::BIGINT;
44: 	} else if (format == "C") {
45: 		return LogicalType::UTINYINT;
46: 	} else if (format == "S") {
47: 		return LogicalType::USMALLINT;
48: 	} else if (format == "I") {
49: 		return LogicalType::UINTEGER;
50: 	} else if (format == "L") {
51: 		return LogicalType::UBIGINT;
52: 	} else if (format == "f") {
53: 		return LogicalType::FLOAT;
54: 	} else if (format == "g") {
55: 		return LogicalType::DOUBLE;
56: 	} else if (format[0] == 'd') { //! this can be either decimal128 or decimal 256 (e.g., d:38,0)
57: 		std::string parameters = format.substr(format.find(':'));
58: 		uint8_t width = std::stoi(parameters.substr(1, parameters.find(',')));
59: 		uint8_t scale = std::stoi(parameters.substr(parameters.find(',') + 1));
60: 		if (width > 38) {
61: 			throw NotImplementedException("Unsupported Internal Arrow Type for Decimal %s", format);
62: 		}
63: 		return LogicalType::DECIMAL(width, scale);
64: 	} else if (format == "u") {
65: 		arrow_convert_data[col_idx]->variable_sz_type.emplace_back(ArrowVariableSizeType::NORMAL, 0);
66: 		return LogicalType::VARCHAR;
67: 	} else if (format == "U") {
68: 		arrow_convert_data[col_idx]->variable_sz_type.emplace_back(ArrowVariableSizeType::SUPER_SIZE, 0);
69: 		return LogicalType::VARCHAR;
70: 	} else if (format == "tsn:") {
71: 		return LogicalTypeId::TIMESTAMP_NS;
72: 	} else if (format == "tsu:") {
73: 		return LogicalTypeId::TIMESTAMP;
74: 	} else if (format == "tsm:") {
75: 		return LogicalTypeId::TIMESTAMP_MS;
76: 	} else if (format == "tss:") {
77: 		return LogicalTypeId::TIMESTAMP_SEC;
78: 	} else if (format == "tdD") {
79: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::DAYS);
80: 		return LogicalType::DATE;
81: 	} else if (format == "tdm") {
82: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::MILLISECONDS);
83: 		return LogicalType::DATE;
84: 	} else if (format == "tts") {
85: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::SECONDS);
86: 		return LogicalType::TIME;
87: 	} else if (format == "ttm") {
88: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::MILLISECONDS);
89: 		return LogicalType::TIME;
90: 	} else if (format == "ttu") {
91: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::MICROSECONDS);
92: 		return LogicalType::TIME;
93: 	} else if (format == "ttn") {
94: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::NANOSECONDS);
95: 		return LogicalType::TIME;
96: 	} else if (format == "tDs") {
97: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::SECONDS);
98: 		return LogicalType::INTERVAL;
99: 	} else if (format == "tDm") {
100: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::MILLISECONDS);
101: 		return LogicalType::INTERVAL;
102: 	} else if (format == "tDu") {
103: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::MICROSECONDS);
104: 		return LogicalType::INTERVAL;
105: 	} else if (format == "tDn") {
106: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::NANOSECONDS);
107: 		return LogicalType::INTERVAL;
108: 	} else if (format == "tiD") {
109: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::DAYS);
110: 		return LogicalType::INTERVAL;
111: 	} else if (format == "tiM") {
112: 		arrow_convert_data[col_idx]->date_time_precision.emplace_back(ArrowDateTimeType::MONTHS);
113: 		return LogicalType::INTERVAL;
114: 	} else if (format == "+l") {
115: 		arrow_convert_data[col_idx]->variable_sz_type.emplace_back(ArrowVariableSizeType::NORMAL, 0);
116: 		auto child_type = GetArrowLogicalType(*schema.children[0], arrow_convert_data, col_idx);
117: 		return LogicalType::LIST(child_type);
118: 	} else if (format == "+L") {
119: 		arrow_convert_data[col_idx]->variable_sz_type.emplace_back(ArrowVariableSizeType::SUPER_SIZE, 0);
120: 		auto child_type = GetArrowLogicalType(*schema.children[0], arrow_convert_data, col_idx);
121: 		return LogicalType::LIST(child_type);
122: 	} else if (format[0] == '+' && format[1] == 'w') {
123: 		std::string parameters = format.substr(format.find(':') + 1);
124: 		idx_t fixed_size = std::stoi(parameters);
125: 		arrow_convert_data[col_idx]->variable_sz_type.emplace_back(ArrowVariableSizeType::FIXED_SIZE, fixed_size);
126: 		auto child_type = GetArrowLogicalType(*schema.children[0], arrow_convert_data, col_idx);
127: 		return LogicalType::LIST(move(child_type));
128: 	} else if (format == "+s") {
129: 		child_list_t<LogicalType> child_types;
130: 		for (idx_t type_idx = 0; type_idx < (idx_t)schema.n_children; type_idx++) {
131: 			auto child_type = GetArrowLogicalType(*schema.children[type_idx], arrow_convert_data, col_idx);
132: 			child_types.push_back({schema.children[type_idx]->name, child_type});
133: 		}
134: 		return LogicalType::STRUCT(move(child_types));
135: 
136: 	} else if (format == "+m") {
137: 		child_list_t<LogicalType> child_types;
138: 		//! First type will be struct, so we skip it
139: 		auto &struct_schema = *schema.children[0];
140: 		for (idx_t type_idx = 0; type_idx < (idx_t)struct_schema.n_children; type_idx++) {
141: 			//! The other types must be added on lists
142: 			auto child_type = GetArrowLogicalType(*struct_schema.children[type_idx], arrow_convert_data, col_idx);
143: 
144: 			auto list_type = LogicalType::LIST(child_type);
145: 			child_types.push_back({struct_schema.children[type_idx]->name, list_type});
146: 		}
147: 		return LogicalType::MAP(move(child_types));
148: 	} else if (format == "z") {
149: 		arrow_convert_data[col_idx]->variable_sz_type.emplace_back(ArrowVariableSizeType::NORMAL, 0);
150: 		return LogicalType::BLOB;
151: 	} else if (format == "Z") {
152: 		arrow_convert_data[col_idx]->variable_sz_type.emplace_back(ArrowVariableSizeType::SUPER_SIZE, 0);
153: 		return LogicalType::BLOB;
154: 	} else if (format[0] == 'w') {
155: 		std::string parameters = format.substr(format.find(':') + 1);
156: 		idx_t fixed_size = std::stoi(parameters);
157: 		arrow_convert_data[col_idx]->variable_sz_type.emplace_back(ArrowVariableSizeType::FIXED_SIZE, fixed_size);
158: 		return LogicalType::BLOB;
159: 	} else {
160: 		throw NotImplementedException("Unsupported Internal Arrow Type %s", format);
161: 	}
162: }
163: 
164: unique_ptr<FunctionData> ArrowTableFunction::ArrowScanBind(ClientContext &context, TableFunctionBindInput &input,
165:                                                            vector<LogicalType> &return_types, vector<string> &names) {
166: 	typedef unique_ptr<ArrowArrayStreamWrapper> (*stream_factory_produce_t)(
167: 	    uintptr_t stream_factory_ptr,
168: 	    std::pair<std::unordered_map<idx_t, string>, std::vector<string>> & project_columns,
169: 	    TableFilterCollection * filters);
170: 	auto stream_factory_ptr = input.inputs[0].GetPointer();
171: 	auto stream_factory_produce = (stream_factory_produce_t)input.inputs[1].GetPointer();
172: 	auto rows_per_thread = input.inputs[2].GetValue<uint64_t>();
173: 	std::pair<std::unordered_map<idx_t, string>, std::vector<string>> project_columns;
174: #ifndef DUCKDB_NO_THREADS
175: 
176: 	auto res = make_unique<ArrowScanFunctionData>(rows_per_thread, stream_factory_produce, stream_factory_ptr,
177: 	                                              std::this_thread::get_id());
178: #else
179: 	auto res = make_unique<ArrowScanFunctionData>(rows_per_thread, stream_factory_produce, stream_factory_ptr);
180: #endif
181: 	auto &data = *res;
182: 	auto stream = stream_factory_produce(stream_factory_ptr, project_columns, nullptr);
183: 
184: 	data.number_of_rows = stream->number_of_rows;
185: 	if (!stream) {
186: 		throw InvalidInputException("arrow_scan: NULL pointer passed");
187: 	}
188: 
189: 	stream->GetSchema(data.schema_root);
190: 
191: 	for (idx_t col_idx = 0; col_idx < (idx_t)data.schema_root.arrow_schema.n_children; col_idx++) {
192: 		auto &schema = *data.schema_root.arrow_schema.children[col_idx];
193: 		if (!schema.release) {
194: 			throw InvalidInputException("arrow_scan: released schema passed");
195: 		}
196: 		if (schema.dictionary) {
197: 			res->arrow_convert_data[col_idx] =
198: 			    make_unique<ArrowConvertData>(GetArrowLogicalType(schema, res->arrow_convert_data, col_idx));
199: 			return_types.emplace_back(GetArrowLogicalType(*schema.dictionary, res->arrow_convert_data, col_idx));
200: 		} else {
201: 			return_types.emplace_back(GetArrowLogicalType(schema, res->arrow_convert_data, col_idx));
202: 		}
203: 		auto format = string(schema.format);
204: 		auto name = string(schema.name);
205: 		if (name.empty()) {
206: 			name = string("v") + to_string(col_idx);
207: 		}
208: 		names.push_back(name);
209: 	}
210: 	return move(res);
211: }
212: 
213: unique_ptr<ArrowArrayStreamWrapper> ProduceArrowScan(const ArrowScanFunctionData &function,
214:                                                      const vector<column_t> &column_ids,
215:                                                      TableFilterCollection *filters) {
216: 	//! Generate Projection Pushdown Vector
217: 	pair<unordered_map<idx_t, string>, vector<string>> project_columns;
218: 	D_ASSERT(!column_ids.empty());
219: 	for (idx_t idx = 0; idx < column_ids.size(); idx++) {
220: 		auto col_idx = column_ids[idx];
221: 		if (col_idx != COLUMN_IDENTIFIER_ROW_ID) {
222: 			auto &schema = *function.schema_root.arrow_schema.children[col_idx];
223: 			project_columns.first[idx] = schema.name;
224: 			project_columns.second.emplace_back(schema.name);
225: 		}
226: 	}
227: 	return function.scanner_producer(function.stream_factory_ptr, project_columns, filters);
228: }
229: 
230: unique_ptr<FunctionOperatorData> ArrowTableFunction::ArrowScanInit(ClientContext &context,
231:                                                                    const FunctionData *bind_data,
232:                                                                    const vector<column_t> &column_ids,
233:                                                                    TableFilterCollection *filters) {
234: 	auto current_chunk = make_unique<ArrowArrayWrapper>();
235: 	auto result = make_unique<ArrowScanState>(move(current_chunk));
236: 	result->column_ids = column_ids;
237: 	auto &data = (const ArrowScanFunctionData &)*bind_data;
238: 	result->stream = ProduceArrowScan(data, column_ids, filters);
239: 	return move(result);
240: }
241: 
242: void ShiftRight(unsigned char *ar, int size, int shift) {
243: 	int carry = 0;
244: 	while (shift--) {
245: 		for (int i = size - 1; i >= 0; --i) {
246: 			int next = (ar[i] & 1) ? 0x80 : 0;
247: 			ar[i] = carry | (ar[i] >> 1);
248: 			carry = next;
249: 		}
250: 	}
251: }
252: 
253: void SetValidityMask(Vector &vector, ArrowArray &array, ArrowScanState &scan_state, idx_t size, int64_t nested_offset,
254:                      bool add_null = false) {
255: 	auto &mask = FlatVector::Validity(vector);
256: 	if (array.null_count != 0 && array.buffers[0]) {
257: 		D_ASSERT(vector.GetVectorType() == VectorType::FLAT_VECTOR);
258: 		auto bit_offset = scan_state.chunk_offset + array.offset;
259: 		if (nested_offset != -1) {
260: 			bit_offset = nested_offset;
261: 		}
262: 		auto n_bitmask_bytes = (size + 8 - 1) / 8;
263: 		mask.EnsureWritable();
264: 		if (bit_offset % 8 == 0) {
265: 			//! just memcpy nullmask
266: 			memcpy((void *)mask.GetData(), (uint8_t *)array.buffers[0] + bit_offset / 8, n_bitmask_bytes);
267: 		} else {
268: 			//! need to re-align nullmask
269: 			std::vector<uint8_t> temp_nullmask(n_bitmask_bytes + 1);
270: 			memcpy(temp_nullmask.data(), (uint8_t *)array.buffers[0] + bit_offset / 8, n_bitmask_bytes + 1);
271: 			ShiftRight(temp_nullmask.data(), n_bitmask_bytes + 1,
272: 			           bit_offset % 8); //! why this has to be a right shift is a mystery to me
273: 			memcpy((void *)mask.GetData(), (data_ptr_t)temp_nullmask.data(), n_bitmask_bytes);
274: 		}
275: 	}
276: 	if (add_null) {
277: 		//! We are setting a validity mask of the data part of dictionary vector
278: 		//! For some reason, Nulls are allowed to be indexes, hence we need to set the last element here to be null
279: 		//! We might have to resize the mask
280: 		mask.Resize(size, size + 1);
281: 		mask.SetInvalid(size);
282: 	}
283: }
284: 
285: void GetValidityMask(ValidityMask &mask, ArrowArray &array, ArrowScanState &scan_state, idx_t size) {
286: 	if (array.null_count != 0 && array.buffers[0]) {
287: 		auto bit_offset = scan_state.chunk_offset + array.offset;
288: 		auto n_bitmask_bytes = (size + 8 - 1) / 8;
289: 		mask.EnsureWritable();
290: 		if (bit_offset % 8 == 0) {
291: 			//! just memcpy nullmask
292: 			memcpy((void *)mask.GetData(), (uint8_t *)array.buffers[0] + bit_offset / 8, n_bitmask_bytes);
293: 		} else {
294: 			//! need to re-align nullmask
295: 			std::vector<uint8_t> temp_nullmask(n_bitmask_bytes + 1);
296: 			memcpy(temp_nullmask.data(), (uint8_t *)array.buffers[0] + bit_offset / 8, n_bitmask_bytes + 1);
297: 			ShiftRight(temp_nullmask.data(), n_bitmask_bytes + 1,
298: 			           bit_offset % 8); //! why this has to be a right shift is a mystery to me
299: 			memcpy((void *)mask.GetData(), (data_ptr_t)temp_nullmask.data(), n_bitmask_bytes);
300: 		}
301: 	}
302: }
303: 
304: void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanState &scan_state, idx_t size,
305:                          std::unordered_map<idx_t, unique_ptr<ArrowConvertData>> &arrow_convert_data, idx_t col_idx,
306:                          std::pair<idx_t, idx_t> &arrow_convert_idx, int64_t nested_offset = -1,
307:                          ValidityMask *parent_mask = nullptr);
308: 
309: void ArrowToDuckDBList(Vector &vector, ArrowArray &array, ArrowScanState &scan_state, idx_t size,
310:                        std::unordered_map<idx_t, unique_ptr<ArrowConvertData>> &arrow_convert_data, idx_t col_idx,
311:                        std::pair<idx_t, idx_t> &arrow_convert_idx, int64_t nested_offset, ValidityMask *parent_mask) {
312: 	auto original_type = arrow_convert_data[col_idx]->variable_sz_type[arrow_convert_idx.first++];
313: 	idx_t list_size = 0;
314: 	SetValidityMask(vector, array, scan_state, size, nested_offset);
315: 	idx_t start_offset = 0;
316: 	idx_t cur_offset = 0;
317: 	if (original_type.first == ArrowVariableSizeType::FIXED_SIZE) {
318: 		//! Have to check validity mask before setting this up
319: 		idx_t offset = (scan_state.chunk_offset + array.offset) * original_type.second;
320: 		if (nested_offset != -1) {
321: 			offset = original_type.second * nested_offset;
322: 		}
323: 		start_offset = offset;
324: 		auto list_data = FlatVector::GetData<list_entry_t>(vector);
325: 		for (idx_t i = 0; i < size; i++) {
326: 			auto &le = list_data[i];
327: 			le.offset = cur_offset;
328: 			le.length = original_type.second;
329: 			cur_offset += original_type.second;
330: 		}
331: 		list_size = cur_offset;
332: 	} else if (original_type.first == ArrowVariableSizeType::NORMAL) {
333: 		auto offsets = (uint32_t *)array.buffers[1] + array.offset + scan_state.chunk_offset;
334: 		if (nested_offset != -1) {
335: 			offsets = (uint32_t *)array.buffers[1] + nested_offset;
336: 		}
337: 		start_offset = offsets[0];
338: 		auto list_data = FlatVector::GetData<list_entry_t>(vector);
339: 		for (idx_t i = 0; i < size; i++) {
340: 			auto &le = list_data[i];
341: 			le.offset = cur_offset;
342: 			le.length = offsets[i + 1] - offsets[i];
343: 			cur_offset += le.length;
344: 		}
345: 		list_size = offsets[size];
346: 	} else {
347: 		auto offsets = (uint64_t *)array.buffers[1] + array.offset + scan_state.chunk_offset;
348: 		if (nested_offset != -1) {
349: 			offsets = (uint64_t *)array.buffers[1] + nested_offset;
350: 		}
351: 		start_offset = offsets[0];
352: 		auto list_data = FlatVector::GetData<list_entry_t>(vector);
353: 		for (idx_t i = 0; i < size; i++) {
354: 			auto &le = list_data[i];
355: 			le.offset = cur_offset;
356: 			le.length = offsets[i + 1] - offsets[i];
357: 			cur_offset += le.length;
358: 		}
359: 		list_size = offsets[size];
360: 	}
361: 	list_size -= start_offset;
362: 	ListVector::Reserve(vector, list_size);
363: 	ListVector::SetListSize(vector, list_size);
364: 	auto &child_vector = ListVector::GetEntry(vector);
365: 	SetValidityMask(child_vector, *array.children[0], scan_state, list_size, start_offset);
366: 	auto &list_mask = FlatVector::Validity(vector);
367: 	if (parent_mask) {
368: 		//! Since this List is owned by a struct we must guarantee their validity map matches on Null
369: 		if (!parent_mask->AllValid()) {
370: 			for (idx_t i = 0; i < size; i++) {
371: 				if (!parent_mask->RowIsValid(i)) {
372: 					list_mask.SetInvalid(i);
373: 				}
374: 			}
375: 		}
376: 	}
377: 	if (list_size == 0 && start_offset == 0) {
378: 		ColumnArrowToDuckDB(child_vector, *array.children[0], scan_state, list_size, arrow_convert_data, col_idx,
379: 		                    arrow_convert_idx, -1);
380: 	} else {
381: 		ColumnArrowToDuckDB(child_vector, *array.children[0], scan_state, list_size, arrow_convert_data, col_idx,
382: 		                    arrow_convert_idx, start_offset);
383: 	}
384: }
385: 
386: void ArrowToDuckDBBlob(Vector &vector, ArrowArray &array, ArrowScanState &scan_state, idx_t size,
387:                        std::unordered_map<idx_t, unique_ptr<ArrowConvertData>> &arrow_convert_data, idx_t col_idx,
388:                        std::pair<idx_t, idx_t> &arrow_convert_idx, int64_t nested_offset) {
389: 	auto original_type = arrow_convert_data[col_idx]->variable_sz_type[arrow_convert_idx.first++];
390: 	SetValidityMask(vector, array, scan_state, size, nested_offset);
391: 	if (original_type.first == ArrowVariableSizeType::FIXED_SIZE) {
392: 		//! Have to check validity mask before setting this up
393: 		idx_t offset = (scan_state.chunk_offset + array.offset) * original_type.second;
394: 		if (nested_offset != -1) {
395: 			offset = original_type.second * nested_offset;
396: 		}
397: 		auto cdata = (char *)array.buffers[1];
398: 		for (idx_t row_idx = 0; row_idx < size; row_idx++) {
399: 			if (FlatVector::IsNull(vector, row_idx)) {
400: 				continue;
401: 			}
402: 			auto bptr = cdata + offset;
403: 			auto blob_len = original_type.second;
404: 			FlatVector::GetData<string_t>(vector)[row_idx] = StringVector::AddStringOrBlob(vector, bptr, blob_len);
405: 			offset += blob_len;
406: 		}
407: 	} else if (original_type.first == ArrowVariableSizeType::NORMAL) {
408: 		auto offsets = (uint32_t *)array.buffers[1] + array.offset + scan_state.chunk_offset;
409: 		if (nested_offset != -1) {
410: 			offsets = (uint32_t *)array.buffers[1] + array.offset + nested_offset;
411: 		}
412: 		auto cdata = (char *)array.buffers[2];
413: 		for (idx_t row_idx = 0; row_idx < size; row_idx++) {
414: 			if (FlatVector::IsNull(vector, row_idx)) {
415: 				continue;
416: 			}
417: 			auto bptr = cdata + offsets[row_idx];
418: 			auto blob_len = offsets[row_idx + 1] - offsets[row_idx];
419: 			FlatVector::GetData<string_t>(vector)[row_idx] = StringVector::AddStringOrBlob(vector, bptr, blob_len);
420: 		}
421: 	} else {
422: 		//! Check if last offset is higher than max uint32
423: 		if (((uint64_t *)array.buffers[1])[array.length] > NumericLimits<uint32_t>::Maximum()) { // LCOV_EXCL_START
424: 			throw std::runtime_error("DuckDB does not support Blobs over 4GB");
425: 		} // LCOV_EXCL_STOP
426: 		auto offsets = (uint64_t *)array.buffers[1] + array.offset + scan_state.chunk_offset;
427: 		if (nested_offset != -1) {
428: 			offsets = (uint64_t *)array.buffers[1] + array.offset + nested_offset;
429: 		}
430: 		auto cdata = (char *)array.buffers[2];
431: 		for (idx_t row_idx = 0; row_idx < size; row_idx++) {
432: 			if (FlatVector::IsNull(vector, row_idx)) {
433: 				continue;
434: 			}
435: 			auto bptr = cdata + offsets[row_idx];
436: 			auto blob_len = offsets[row_idx + 1] - offsets[row_idx];
437: 			FlatVector::GetData<string_t>(vector)[row_idx] = StringVector::AddStringOrBlob(vector, bptr, blob_len);
438: 		}
439: 	}
440: }
441: 
442: void ArrowToDuckDBMapList(Vector &vector, ArrowArray &array, ArrowScanState &scan_state, idx_t size,
443:                           std::unordered_map<idx_t, unique_ptr<ArrowConvertData>> &arrow_convert_data, idx_t col_idx,
444:                           std::pair<idx_t, idx_t> &arrow_convert_idx, uint32_t *offsets, ValidityMask *parent_mask) {
445: 	idx_t list_size = offsets[size] - offsets[0];
446: 	ListVector::Reserve(vector, list_size);
447: 
448: 	auto &child_vector = ListVector::GetEntry(vector);
449: 	auto list_data = FlatVector::GetData<list_entry_t>(vector);
450: 	auto cur_offset = 0;
451: 	for (idx_t i = 0; i < size; i++) {
452: 		auto &le = list_data[i];
453: 		le.offset = cur_offset;
454: 		le.length = offsets[i + 1] - offsets[i];
455: 		cur_offset += le.length;
456: 	}
457: 	ListVector::SetListSize(vector, list_size);
458: 	if (list_size == 0 && offsets[0] == 0) {
459: 		SetValidityMask(child_vector, array, scan_state, list_size, -1);
460: 	} else {
461: 		SetValidityMask(child_vector, array, scan_state, list_size, offsets[0]);
462: 	}
463: 
464: 	auto &list_mask = FlatVector::Validity(vector);
465: 	if (parent_mask) {
466: 		//! Since this List is owned by a struct we must guarantee their validity map matches on Null
467: 		if (!parent_mask->AllValid()) {
468: 			for (idx_t i = 0; i < size; i++) {
469: 				if (!parent_mask->RowIsValid(i)) {
470: 					list_mask.SetInvalid(i);
471: 				}
472: 			}
473: 		}
474: 	}
475: 	if (list_size == 0 && offsets[0] == 0) {
476: 		ColumnArrowToDuckDB(child_vector, array, scan_state, list_size, arrow_convert_data, col_idx, arrow_convert_idx,
477: 		                    -1);
478: 	} else {
479: 		ColumnArrowToDuckDB(child_vector, array, scan_state, list_size, arrow_convert_data, col_idx, arrow_convert_idx,
480: 		                    offsets[0]);
481: 	}
482: }
483: template <class T>
484: static void SetVectorString(Vector &vector, idx_t size, char *cdata, T *offsets) {
485: 	auto strings = FlatVector::GetData<string_t>(vector);
486: 	for (idx_t row_idx = 0; row_idx < size; row_idx++) {
487: 		if (FlatVector::IsNull(vector, row_idx)) {
488: 			continue;
489: 		}
490: 		auto cptr = cdata + offsets[row_idx];
491: 		auto str_len = offsets[row_idx + 1] - offsets[row_idx];
492: 		strings[row_idx] = string_t(cptr, str_len);
493: 	}
494: }
495: 
496: void DirectConversion(Vector &vector, ArrowArray &array, ArrowScanState &scan_state, int64_t nested_offset) {
497: 	auto internal_type = GetTypeIdSize(vector.GetType().InternalType());
498: 	auto data_ptr = (data_ptr_t)array.buffers[1] + internal_type * (scan_state.chunk_offset + array.offset);
499: 	if (nested_offset != -1) {
500: 		data_ptr = (data_ptr_t)array.buffers[1] + internal_type * (array.offset + nested_offset);
501: 	}
502: 	FlatVector::SetData(vector, data_ptr);
503: }
504: 
505: template <class T>
506: void TimeConversion(Vector &vector, ArrowArray &array, ArrowScanState &scan_state, int64_t nested_offset, idx_t size,
507:                     int64_t conversion) {
508: 	auto tgt_ptr = (dtime_t *)FlatVector::GetData(vector);
509: 	auto &validity_mask = FlatVector::Validity(vector);
510: 	auto src_ptr = (T *)array.buffers[1] + scan_state.chunk_offset + array.offset;
511: 	if (nested_offset != -1) {
512: 		src_ptr = (T *)array.buffers[1] + nested_offset + array.offset;
513: 	}
514: 	for (idx_t row = 0; row < size; row++) {
515: 		if (!validity_mask.RowIsValid(row)) {
516: 			continue;
517: 		}
518: 		if (!TryMultiplyOperator::Operation((int64_t)src_ptr[row], conversion, tgt_ptr[row].micros)) {
519: 			throw ConversionException("Could not convert Interval to Microsecond");
520: 		}
521: 	}
522: }
523: 
524: void IntervalConversionUs(Vector &vector, ArrowArray &array, ArrowScanState &scan_state, int64_t nested_offset,
525:                           idx_t size, int64_t conversion) {
526: 	auto tgt_ptr = (interval_t *)FlatVector::GetData(vector);
527: 	auto src_ptr = (int64_t *)array.buffers[1] + scan_state.chunk_offset + array.offset;
528: 	if (nested_offset != -1) {
529: 		src_ptr = (int64_t *)array.buffers[1] + nested_offset + array.offset;
530: 	}
531: 	for (idx_t row = 0; row < size; row++) {
532: 		tgt_ptr[row].days = 0;
533: 		tgt_ptr[row].months = 0;
534: 		if (!TryMultiplyOperator::Operation(src_ptr[row], conversion, tgt_ptr[row].micros)) {
535: 			throw ConversionException("Could not convert Interval to Microsecond");
536: 		}
537: 	}
538: }
539: 
540: void IntervalConversionMonths(Vector &vector, ArrowArray &array, ArrowScanState &scan_state, int64_t nested_offset,
541:                               idx_t size) {
542: 	auto tgt_ptr = (interval_t *)FlatVector::GetData(vector);
543: 	auto src_ptr = (int32_t *)array.buffers[1] + scan_state.chunk_offset + array.offset;
544: 	if (nested_offset != -1) {
545: 		src_ptr = (int32_t *)array.buffers[1] + nested_offset + array.offset;
546: 	}
547: 	for (idx_t row = 0; row < size; row++) {
548: 		tgt_ptr[row].days = 0;
549: 		tgt_ptr[row].micros = 0;
550: 		tgt_ptr[row].months = src_ptr[row];
551: 	}
552: }
553: 
554: void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanState &scan_state, idx_t size,
555:                          std::unordered_map<idx_t, unique_ptr<ArrowConvertData>> &arrow_convert_data, idx_t col_idx,
556:                          std::pair<idx_t, idx_t> &arrow_convert_idx, int64_t nested_offset, ValidityMask *parent_mask) {
557: 	switch (vector.GetType().id()) {
558: 	case LogicalTypeId::SQLNULL:
559: 		vector.Reference(Value());
560: 		break;
561: 	case LogicalTypeId::BOOLEAN: {
562: 		//! Arrow bit-packs boolean values
563: 		//! Lets first figure out where we are in the source array
564: 		auto src_ptr = (uint8_t *)array.buffers[1] + (scan_state.chunk_offset + array.offset) / 8;
565: 
566: 		if (nested_offset != -1) {
567: 			src_ptr = (uint8_t *)array.buffers[1] + (nested_offset + array.offset) / 8;
568: 		}
569: 		auto tgt_ptr = (uint8_t *)FlatVector::GetData(vector);
570: 		int src_pos = 0;
571: 		idx_t cur_bit = scan_state.chunk_offset % 8;
572: 		if (nested_offset != -1) {
573: 			cur_bit = nested_offset % 8;
574: 		}
575: 		for (idx_t row = 0; row < size; row++) {
576: 			if ((src_ptr[src_pos] & (1 << cur_bit)) == 0) {
577: 				tgt_ptr[row] = 0;
578: 			} else {
579: 				tgt_ptr[row] = 1;
580: 			}
581: 			cur_bit++;
582: 			if (cur_bit == 8) {
583: 				src_pos++;
584: 				cur_bit = 0;
585: 			}
586: 		}
587: 		break;
588: 	}
589: 	case LogicalTypeId::TINYINT:
590: 	case LogicalTypeId::SMALLINT:
591: 	case LogicalTypeId::INTEGER:
592: 	case LogicalTypeId::FLOAT:
593: 	case LogicalTypeId::UTINYINT:
594: 	case LogicalTypeId::USMALLINT:
595: 	case LogicalTypeId::UINTEGER:
596: 	case LogicalTypeId::UBIGINT:
597: 	case LogicalTypeId::BIGINT:
598: 	case LogicalTypeId::HUGEINT:
599: 	case LogicalTypeId::TIMESTAMP:
600: 	case LogicalTypeId::TIMESTAMP_SEC:
601: 	case LogicalTypeId::TIMESTAMP_MS:
602: 	case LogicalTypeId::TIMESTAMP_NS: {
603: 		DirectConversion(vector, array, scan_state, nested_offset);
604: 		break;
605: 	}
606: 	case LogicalTypeId::DOUBLE: {
607: 		DirectConversion(vector, array, scan_state, nested_offset);
608: 		//! Need to check if there are NaNs, if yes, must turn that to null
609: 		auto data = (double *)vector.GetData();
610: 		auto &mask = FlatVector::Validity(vector);
611: 		for (idx_t row_idx = 0; row_idx < size; row_idx++) {
612: 			if (!Value::DoubleIsValid(data[row_idx])) {
613: 				mask.SetInvalid(row_idx);
614: 			}
615: 		}
616: 		break;
617: 	}
618: 	case LogicalTypeId::JSON:
619: 	case LogicalTypeId::VARCHAR: {
620: 		auto original_type = arrow_convert_data[col_idx]->variable_sz_type[arrow_convert_idx.first++];
621: 		auto cdata = (char *)array.buffers[2];
622: 		if (original_type.first == ArrowVariableSizeType::SUPER_SIZE) {
623: 			if (((uint64_t *)array.buffers[1])[array.length] > NumericLimits<uint32_t>::Maximum()) { // LCOV_EXCL_START
624: 				throw std::runtime_error("DuckDB does not support Strings over 4GB");
625: 			} // LCOV_EXCL_STOP
626: 			auto offsets = (uint64_t *)array.buffers[1] + array.offset + scan_state.chunk_offset;
627: 			if (nested_offset != -1) {
628: 				offsets = (uint64_t *)array.buffers[1] + array.offset + nested_offset;
629: 			}
630: 			SetVectorString(vector, size, cdata, offsets);
631: 		} else {
632: 			auto offsets = (uint32_t *)array.buffers[1] + array.offset + scan_state.chunk_offset;
633: 			if (nested_offset != -1) {
634: 				offsets = (uint32_t *)array.buffers[1] + array.offset + nested_offset;
635: 			}
636: 			SetVectorString(vector, size, cdata, offsets);
637: 		}
638: 		break;
639: 	}
640: 	case LogicalTypeId::DATE: {
641: 		auto precision = arrow_convert_data[col_idx]->date_time_precision[arrow_convert_idx.second++];
642: 		switch (precision) {
643: 		case ArrowDateTimeType::DAYS: {
644: 			DirectConversion(vector, array, scan_state, nested_offset);
645: 			break;
646: 		}
647: 		case ArrowDateTimeType::MILLISECONDS: {
648: 			//! convert date from nanoseconds to days
649: 			auto src_ptr = (uint64_t *)array.buffers[1] + scan_state.chunk_offset + array.offset;
650: 			if (nested_offset != -1) {
651: 				src_ptr = (uint64_t *)array.buffers[1] + nested_offset + array.offset;
652: 			}
653: 			auto tgt_ptr = (date_t *)FlatVector::GetData(vector);
654: 			for (idx_t row = 0; row < size; row++) {
655: 				tgt_ptr[row] = date_t(int64_t(src_ptr[row]) / (1000 * 60 * 60 * 24));
656: 			}
657: 			break;
658: 		}
659: 		default:
660: 			throw std::runtime_error("Unsupported precision for Date Type ");
661: 		}
662: 		break;
663: 	}
664: 	case LogicalTypeId::TIME: {
665: 		auto precision = arrow_convert_data[col_idx]->date_time_precision[arrow_convert_idx.second++];
666: 		switch (precision) {
667: 		case ArrowDateTimeType::SECONDS: {
668: 			TimeConversion<int32_t>(vector, array, scan_state, nested_offset, size, 1000000);
669: 			break;
670: 		}
671: 		case ArrowDateTimeType::MILLISECONDS: {
672: 			TimeConversion<int32_t>(vector, array, scan_state, nested_offset, size, 1000);
673: 			break;
674: 		}
675: 		case ArrowDateTimeType::MICROSECONDS: {
676: 			TimeConversion<int64_t>(vector, array, scan_state, nested_offset, size, 1);
677: 			break;
678: 		}
679: 		case ArrowDateTimeType::NANOSECONDS: {
680: 			auto tgt_ptr = (dtime_t *)FlatVector::GetData(vector);
681: 			auto src_ptr = (int64_t *)array.buffers[1] + scan_state.chunk_offset + array.offset;
682: 			if (nested_offset != -1) {
683: 				src_ptr = (int64_t *)array.buffers[1] + nested_offset + array.offset;
684: 			}
685: 			for (idx_t row = 0; row < size; row++) {
686: 				tgt_ptr[row].micros = src_ptr[row] / 1000;
687: 			}
688: 			break;
689: 		}
690: 		default:
691: 			throw std::runtime_error("Unsupported precision for Time Type ");
692: 		}
693: 		break;
694: 	}
695: 	case LogicalTypeId::INTERVAL: {
696: 		auto precision = arrow_convert_data[col_idx]->date_time_precision[arrow_convert_idx.second++];
697: 		switch (precision) {
698: 		case ArrowDateTimeType::SECONDS: {
699: 			IntervalConversionUs(vector, array, scan_state, nested_offset, size, 1000000);
700: 			break;
701: 		}
702: 		case ArrowDateTimeType::DAYS:
703: 		case ArrowDateTimeType::MILLISECONDS: {
704: 			IntervalConversionUs(vector, array, scan_state, nested_offset, size, 1000);
705: 			break;
706: 		}
707: 		case ArrowDateTimeType::MICROSECONDS: {
708: 			IntervalConversionUs(vector, array, scan_state, nested_offset, size, 1);
709: 			break;
710: 		}
711: 		case ArrowDateTimeType::NANOSECONDS: {
712: 			auto tgt_ptr = (interval_t *)FlatVector::GetData(vector);
713: 			auto src_ptr = (int64_t *)array.buffers[1] + scan_state.chunk_offset + array.offset;
714: 			if (nested_offset != -1) {
715: 				src_ptr = (int64_t *)array.buffers[1] + nested_offset + array.offset;
716: 			}
717: 			for (idx_t row = 0; row < size; row++) {
718: 				tgt_ptr[row].micros = src_ptr[row] / 1000;
719: 				tgt_ptr[row].days = 0;
720: 				tgt_ptr[row].months = 0;
721: 			}
722: 			break;
723: 		}
724: 		case ArrowDateTimeType::MONTHS: {
725: 			IntervalConversionMonths(vector, array, scan_state, nested_offset, size);
726: 			break;
727: 		}
728: 		default:
729: 			throw std::runtime_error("Unsupported precision for Interval/Duration Type ");
730: 		}
731: 		break;
732: 	}
733: 	case LogicalTypeId::DECIMAL: {
734: 		auto val_mask = FlatVector::Validity(vector);
735: 		//! We have to convert from INT128
736: 		auto src_ptr = (hugeint_t *)array.buffers[1] + scan_state.chunk_offset + array.offset;
737: 		if (nested_offset != -1) {
738: 			src_ptr = (hugeint_t *)array.buffers[1] + nested_offset + array.offset;
739: 		}
740: 		switch (vector.GetType().InternalType()) {
741: 		case PhysicalType::INT16: {
742: 			auto tgt_ptr = (int16_t *)FlatVector::GetData(vector);
743: 			for (idx_t row = 0; row < size; row++) {
744: 				if (val_mask.RowIsValid(row)) {
745: 					auto result = Hugeint::TryCast(src_ptr[row], tgt_ptr[row]);
746: 					D_ASSERT(result);
747: 					(void)result;
748: 				}
749: 			}
750: 			break;
751: 		}
752: 		case PhysicalType::INT32: {
753: 			auto tgt_ptr = (int32_t *)FlatVector::GetData(vector);
754: 			for (idx_t row = 0; row < size; row++) {
755: 				if (val_mask.RowIsValid(row)) {
756: 					auto result = Hugeint::TryCast(src_ptr[row], tgt_ptr[row]);
757: 					D_ASSERT(result);
758: 					(void)result;
759: 				}
760: 			}
761: 			break;
762: 		}
763: 		case PhysicalType::INT64: {
764: 			auto tgt_ptr = (int64_t *)FlatVector::GetData(vector);
765: 			for (idx_t row = 0; row < size; row++) {
766: 				if (val_mask.RowIsValid(row)) {
767: 					auto result = Hugeint::TryCast(src_ptr[row], tgt_ptr[row]);
768: 					D_ASSERT(result);
769: 					(void)result;
770: 				}
771: 			}
772: 			break;
773: 		}
774: 		case PhysicalType::INT128: {
775: 			FlatVector::SetData(vector, (data_ptr_t)array.buffers[1] + GetTypeIdSize(vector.GetType().InternalType()) *
776: 			                                                               (scan_state.chunk_offset + array.offset));
777: 			break;
778: 		}
779: 		default:
780: 			throw std::runtime_error("Unsupported physical type for Decimal: " +
781: 			                         TypeIdToString(vector.GetType().InternalType()));
782: 		}
783: 		break;
784: 	}
785: 	case LogicalTypeId::BLOB: {
786: 		ArrowToDuckDBBlob(vector, array, scan_state, size, arrow_convert_data, col_idx, arrow_convert_idx,
787: 		                  nested_offset);
788: 		break;
789: 	}
790: 	case LogicalTypeId::LIST: {
791: 		ArrowToDuckDBList(vector, array, scan_state, size, arrow_convert_data, col_idx, arrow_convert_idx,
792: 		                  nested_offset, parent_mask);
793: 		break;
794: 	}
795: 	case LogicalTypeId::MAP: {
796: 		//! Since this is a map we skip first child, because its a struct
797: 		auto &struct_arrow = *array.children[0];
798: 		auto &child_entries = StructVector::GetEntries(vector);
799: 		D_ASSERT(child_entries.size() == 2);
800: 		auto offsets = (uint32_t *)array.buffers[1] + array.offset + scan_state.chunk_offset;
801: 		if (nested_offset != -1) {
802: 			offsets = (uint32_t *)array.buffers[1] + nested_offset;
803: 		}
804: 		auto &struct_validity_mask = FlatVector::Validity(vector);
805: 		//! Fill the children
806: 		for (idx_t type_idx = 0; type_idx < (idx_t)struct_arrow.n_children; type_idx++) {
807: 			ArrowToDuckDBMapList(*child_entries[type_idx], *struct_arrow.children[type_idx], scan_state, size,
808: 			                     arrow_convert_data, col_idx, arrow_convert_idx, offsets, &struct_validity_mask);
809: 		}
810: 		break;
811: 	}
812: 	case LogicalTypeId::STRUCT: {
813: 		//! Fill the children
814: 		auto &child_entries = StructVector::GetEntries(vector);
815: 		auto &struct_validity_mask = FlatVector::Validity(vector);
816: 		for (idx_t type_idx = 0; type_idx < (idx_t)array.n_children; type_idx++) {
817: 			SetValidityMask(*child_entries[type_idx], *array.children[type_idx], scan_state, size, nested_offset);
818: 			ColumnArrowToDuckDB(*child_entries[type_idx], *array.children[type_idx], scan_state, size,
819: 			                    arrow_convert_data, col_idx, arrow_convert_idx, nested_offset, &struct_validity_mask);
820: 		}
821: 		break;
822: 	}
823: 	default:
824: 		throw std::runtime_error("Unsupported type " + vector.GetType().ToString());
825: 	}
826: }
827: 
828: template <class T>
829: static void SetSelectionVectorLoop(SelectionVector &sel, data_ptr_t indices_p, idx_t size) {
830: 	auto indices = (T *)indices_p;
831: 	for (idx_t row = 0; row < size; row++) {
832: 		sel.set_index(row, indices[row]);
833: 	}
834: }
835: 
836: template <class T>
837: static void SetSelectionVectorLoopWithChecks(SelectionVector &sel, data_ptr_t indices_p, idx_t size) {
838: 
839: 	auto indices = (T *)indices_p;
840: 	for (idx_t row = 0; row < size; row++) {
841: 		if (indices[row] > NumericLimits<uint32_t>::Maximum()) {
842: 			throw std::runtime_error("DuckDB only supports indices that fit on an uint32");
843: 		}
844: 		sel.set_index(row, indices[row]);
845: 	}
846: }
847: 
848: template <class T>
849: static void SetMaskedSelectionVectorLoop(SelectionVector &sel, data_ptr_t indices_p, idx_t size, ValidityMask &mask,
850:                                          idx_t last_element_pos) {
851: 	auto indices = (T *)indices_p;
852: 	for (idx_t row = 0; row < size; row++) {
853: 		if (mask.RowIsValid(row)) {
854: 			sel.set_index(row, indices[row]);
855: 		} else {
856: 			//! Need to point out to last element
857: 			sel.set_index(row, last_element_pos);
858: 		}
859: 	}
860: }
861: 
862: void SetSelectionVector(SelectionVector &sel, data_ptr_t indices_p, LogicalType &logical_type, idx_t size,
863:                         ValidityMask *mask = nullptr, idx_t last_element_pos = 0) {
864: 	sel.Initialize(size);
865: 
866: 	if (mask) {
867: 		switch (logical_type.id()) {
868: 		case LogicalTypeId::UTINYINT:
869: 			SetMaskedSelectionVectorLoop<uint8_t>(sel, indices_p, size, *mask, last_element_pos);
870: 			break;
871: 		case LogicalTypeId::TINYINT:
872: 			SetMaskedSelectionVectorLoop<int8_t>(sel, indices_p, size, *mask, last_element_pos);
873: 			break;
874: 		case LogicalTypeId::USMALLINT:
875: 			SetMaskedSelectionVectorLoop<uint16_t>(sel, indices_p, size, *mask, last_element_pos);
876: 			break;
877: 		case LogicalTypeId::SMALLINT:
878: 			SetMaskedSelectionVectorLoop<int16_t>(sel, indices_p, size, *mask, last_element_pos);
879: 			break;
880: 		case LogicalTypeId::UINTEGER:
881: 			if (last_element_pos > NumericLimits<uint32_t>::Maximum()) {
882: 				//! Its guaranteed that our indices will point to the last element, so just throw an error
883: 				throw std::runtime_error("DuckDB only supports indices that fit on an uint32");
884: 			}
885: 			SetMaskedSelectionVectorLoop<uint32_t>(sel, indices_p, size, *mask, last_element_pos);
886: 			break;
887: 		case LogicalTypeId::INTEGER:
888: 			SetMaskedSelectionVectorLoop<int32_t>(sel, indices_p, size, *mask, last_element_pos);
889: 			break;
890: 		case LogicalTypeId::UBIGINT:
891: 			if (last_element_pos > NumericLimits<uint32_t>::Maximum()) {
892: 				//! Its guaranteed that our indices will point to the last element, so just throw an error
893: 				throw std::runtime_error("DuckDB only supports indices that fit on an uint32");
894: 			}
895: 			SetMaskedSelectionVectorLoop<uint64_t>(sel, indices_p, size, *mask, last_element_pos);
896: 			break;
897: 		case LogicalTypeId::BIGINT:
898: 			if (last_element_pos > NumericLimits<uint32_t>::Maximum()) {
899: 				//! Its guaranteed that our indices will point to the last element, so just throw an error
900: 				throw std::runtime_error("DuckDB only supports indices that fit on an uint32");
901: 			}
902: 			SetMaskedSelectionVectorLoop<int64_t>(sel, indices_p, size, *mask, last_element_pos);
903: 			break;
904: 
905: 		default:
906: 			throw std::runtime_error("(Arrow) Unsupported type for selection vectors " + logical_type.ToString());
907: 		}
908: 
909: 	} else {
910: 		switch (logical_type.id()) {
911: 		case LogicalTypeId::UTINYINT:
912: 			SetSelectionVectorLoop<uint8_t>(sel, indices_p, size);
913: 			break;
914: 		case LogicalTypeId::TINYINT:
915: 			SetSelectionVectorLoop<int8_t>(sel, indices_p, size);
916: 			break;
917: 		case LogicalTypeId::USMALLINT:
918: 			SetSelectionVectorLoop<uint16_t>(sel, indices_p, size);
919: 			break;
920: 		case LogicalTypeId::SMALLINT:
921: 			SetSelectionVectorLoop<int16_t>(sel, indices_p, size);
922: 			break;
923: 		case LogicalTypeId::UINTEGER:
924: 			SetSelectionVectorLoop<uint32_t>(sel, indices_p, size);
925: 			break;
926: 		case LogicalTypeId::INTEGER:
927: 			SetSelectionVectorLoop<int32_t>(sel, indices_p, size);
928: 			break;
929: 		case LogicalTypeId::UBIGINT:
930: 			if (last_element_pos > NumericLimits<uint32_t>::Maximum()) {
931: 				//! We need to check if our indexes fit in a uint32_t
932: 				SetSelectionVectorLoopWithChecks<uint64_t>(sel, indices_p, size);
933: 			} else {
934: 				SetSelectionVectorLoop<uint64_t>(sel, indices_p, size);
935: 			}
936: 			break;
937: 		case LogicalTypeId::BIGINT:
938: 			if (last_element_pos > NumericLimits<uint32_t>::Maximum()) {
939: 				//! We need to check if our indexes fit in a uint32_t
940: 				SetSelectionVectorLoopWithChecks<int64_t>(sel, indices_p, size);
941: 			} else {
942: 				SetSelectionVectorLoop<int64_t>(sel, indices_p, size);
943: 			}
944: 			break;
945: 		default:
946: 			throw std::runtime_error("(Arrow) Unsupported type for selection vectors " + logical_type.ToString());
947: 		}
948: 	}
949: }
950: 
951: void ColumnArrowToDuckDBDictionary(Vector &vector, ArrowArray &array, ArrowScanState &scan_state, idx_t size,
952:                                    std::unordered_map<idx_t, unique_ptr<ArrowConvertData>> &arrow_convert_data,
953:                                    idx_t col_idx, std::pair<idx_t, idx_t> &arrow_convert_idx) {
954: 	SelectionVector sel;
955: 	auto &dict_vectors = scan_state.arrow_dictionary_vectors;
956: 	if (dict_vectors.find(col_idx) == dict_vectors.end()) {
957: 		//! We need to set the dictionary data for this column
958: 		auto base_vector = make_unique<Vector>(vector.GetType(), array.dictionary->length);
959: 		SetValidityMask(*base_vector, *array.dictionary, scan_state, array.dictionary->length, 0, array.null_count > 0);
960: 		ColumnArrowToDuckDB(*base_vector, *array.dictionary, scan_state, array.dictionary->length, arrow_convert_data,
961: 		                    col_idx, arrow_convert_idx);
962: 		dict_vectors[col_idx] = move(base_vector);
963: 	}
964: 	auto dictionary_type = arrow_convert_data[col_idx]->dictionary_type;
965: 	//! Get Pointer to Indices of Dictionary
966: 	auto indices = (data_ptr_t)array.buffers[1] +
967: 	               GetTypeIdSize(dictionary_type.InternalType()) * (scan_state.chunk_offset + array.offset);
968: 	if (array.null_count > 0) {
969: 		ValidityMask indices_validity;
970: 		GetValidityMask(indices_validity, array, scan_state, size);
971: 		SetSelectionVector(sel, indices, dictionary_type, size, &indices_validity, array.dictionary->length);
972: 	} else {
973: 		SetSelectionVector(sel, indices, dictionary_type, size);
974: 	}
975: 	vector.Slice(*dict_vectors[col_idx], sel, size);
976: }
977: 
978: void ArrowTableFunction::ArrowToDuckDB(ArrowScanState &scan_state,
979:                                        std::unordered_map<idx_t, unique_ptr<ArrowConvertData>> &arrow_convert_data,
980:                                        DataChunk &output, idx_t start) {
981: 	for (idx_t idx = 0; idx < output.ColumnCount(); idx++) {
982: 		auto col_idx = scan_state.column_ids[idx];
983: 		std::pair<idx_t, idx_t> arrow_convert_idx {0, 0};
984: 		auto &array = *scan_state.chunk->arrow_array.children[idx];
985: 		if (!array.release) {
986: 			throw InvalidInputException("arrow_scan: released array passed");
987: 		}
988: 		if (array.length != scan_state.chunk->arrow_array.length) {
989: 			throw InvalidInputException("arrow_scan: array length mismatch");
990: 		}
991: 		output.data[idx].GetBuffer()->SetAuxiliaryData(make_unique<ArrowAuxiliaryData>(scan_state.chunk),
992: 		                                               VectorAuxiliaryDataType::ARROW_AUXILIARY);
993: 		if (array.dictionary) {
994: 			ColumnArrowToDuckDBDictionary(output.data[idx], array, scan_state, output.size(), arrow_convert_data,
995: 			                              col_idx, arrow_convert_idx);
996: 		} else {
997: 			SetValidityMask(output.data[idx], array, scan_state, output.size(), -1);
998: 			ColumnArrowToDuckDB(output.data[idx], array, scan_state, output.size(), arrow_convert_data, col_idx,
999: 			                    arrow_convert_idx);
1000: 		}
1001: 	}
1002: }
1003: 
1004: void ArrowTableFunction::ArrowScanFunction(ClientContext &context, const FunctionData *bind_data,
1005:                                            FunctionOperatorData *operator_state, DataChunk *input, DataChunk &output) {
1006: 
1007: 	auto &data = (ArrowScanFunctionData &)*bind_data;
1008: 	auto &state = (ArrowScanState &)*operator_state;
1009: 
1010: 	//! have we run out of data on the current chunk? move to next one
1011: 	while (state.chunk_offset >= (idx_t)state.chunk->arrow_array.length) {
1012: 		state.chunk_offset = 0;
1013: 		state.arrow_dictionary_vectors.clear();
1014: 		state.chunk = state.stream->GetNextChunk();
1015: 		//! have we run out of chunks? we are done
1016: 		if (!state.chunk->arrow_array.release) {
1017: 			return;
1018: 		}
1019: 	}
1020: 
1021: 	int64_t output_size = MinValue<int64_t>(STANDARD_VECTOR_SIZE, state.chunk->arrow_array.length - state.chunk_offset);
1022: 	data.lines_read += output_size;
1023: 	output.SetCardinality(output_size);
1024: 	ArrowToDuckDB(state, data.arrow_convert_data, output, data.lines_read - output_size);
1025: 	output.Verify();
1026: 	state.chunk_offset += output.size();
1027: }
1028: 
1029: void ArrowTableFunction::ArrowScanFunctionParallel(ClientContext &context, const FunctionData *bind_data,
1030:                                                    FunctionOperatorData *operator_state, DataChunk *input,
1031:                                                    DataChunk &output, ParallelState *parallel_state_p) {
1032: 	auto &data = (ArrowScanFunctionData &)*bind_data;
1033: 	auto &state = (ArrowScanState &)*operator_state;
1034: 	//! Out of tuples in this chunk
1035: 	if (state.chunk_offset >= (idx_t)state.chunk->arrow_array.length) {
1036: 		return;
1037: 	}
1038: 	int64_t output_size = MinValue<int64_t>(STANDARD_VECTOR_SIZE, state.chunk->arrow_array.length - state.chunk_offset);
1039: 	data.lines_read += output_size;
1040: 	output.SetCardinality(output_size);
1041: 	ArrowToDuckDB(state, data.arrow_convert_data, output, data.lines_read - output_size);
1042: 	output.Verify();
1043: 	state.chunk_offset += output.size();
1044: }
1045: 
1046: idx_t ArrowTableFunction::ArrowScanMaxThreads(ClientContext &context, const FunctionData *bind_data_p) {
1047: 	auto &bind_data = (const ArrowScanFunctionData &)*bind_data_p;
1048: 	if (bind_data.number_of_rows <= 0 || ClientConfig::GetConfig(context).verify_parallelism) {
1049: 		return context.db->NumberOfThreads();
1050: 	}
1051: 	return ((bind_data.number_of_rows + bind_data.rows_per_thread - 1) / bind_data.rows_per_thread) + 1;
1052: }
1053: 
1054: unique_ptr<ParallelState> ArrowTableFunction::ArrowScanInitParallelState(ClientContext &context,
1055:                                                                          const FunctionData *bind_data_p,
1056:                                                                          const vector<column_t> &column_ids,
1057:                                                                          TableFilterCollection *filters) {
1058: 	auto &bind_data = (const ArrowScanFunctionData &)*bind_data_p;
1059: 	auto result = make_unique<ParallelArrowScanState>();
1060: 	result->stream = ProduceArrowScan(bind_data, column_ids, filters);
1061: 	return move(result);
1062: }
1063: 
1064: bool ArrowTableFunction::ArrowScanParallelStateNext(ClientContext &context, const FunctionData *bind_data_p,
1065:                                                     FunctionOperatorData *operator_state,
1066:                                                     ParallelState *parallel_state_p) {
1067: 	auto &state = (ArrowScanState &)*operator_state;
1068: 	auto &parallel_state = (ParallelArrowScanState &)*parallel_state_p;
1069: 
1070: 	lock_guard<mutex> parallel_lock(parallel_state.main_mutex);
1071: 	state.chunk_offset = 0;
1072: 
1073: 	auto current_chunk = parallel_state.stream->GetNextChunk();
1074: 	while (current_chunk->arrow_array.length == 0 && current_chunk->arrow_array.release) {
1075: 		current_chunk = parallel_state.stream->GetNextChunk();
1076: 	}
1077: 	state.chunk = move(current_chunk);
1078: 	//! have we run out of chunks? we are done
1079: 	if (!state.chunk->arrow_array.release) {
1080: 		return false;
1081: 	}
1082: 	return true;
1083: }
1084: 
1085: unique_ptr<FunctionOperatorData>
1086: ArrowTableFunction::ArrowScanParallelInit(ClientContext &context, const FunctionData *bind_data_p, ParallelState *state,
1087:                                           const vector<column_t> &column_ids, TableFilterCollection *filters) {
1088: 	auto current_chunk = make_unique<ArrowArrayWrapper>();
1089: 	auto result = make_unique<ArrowScanState>(move(current_chunk));
1090: 	result->column_ids = column_ids;
1091: 	result->filters = filters;
1092: 	ArrowScanParallelStateNext(context, bind_data_p, result.get(), state);
1093: 	return move(result);
1094: }
1095: 
1096: unique_ptr<NodeStatistics> ArrowTableFunction::ArrowScanCardinality(ClientContext &context, const FunctionData *data) {
1097: 	auto &bind_data = (ArrowScanFunctionData &)*data;
1098: 	return make_unique<NodeStatistics>(bind_data.number_of_rows, bind_data.number_of_rows);
1099: }
1100: 
1101: double ArrowTableFunction::ArrowProgress(ClientContext &context, const FunctionData *bind_data_p) {
1102: 	auto &bind_data = (const ArrowScanFunctionData &)*bind_data_p;
1103: 	if (bind_data.number_of_rows == 0) {
1104: 		return 100;
1105: 	}
1106: 	auto percentage = bind_data.lines_read * 100.0 / bind_data.number_of_rows;
1107: 	return percentage;
1108: }
1109: 
1110: void ArrowTableFunction::RegisterFunction(BuiltinFunctions &set) {
1111: 	TableFunctionSet arrow("arrow_scan");
1112: 	arrow.AddFunction(TableFunction({LogicalType::POINTER, LogicalType::POINTER, LogicalType::UBIGINT},
1113: 	                                ArrowScanFunction, ArrowScanBind, ArrowScanInit, nullptr, nullptr, nullptr,
1114: 	                                ArrowScanCardinality, nullptr, nullptr, ArrowScanMaxThreads,
1115: 	                                ArrowScanInitParallelState, ArrowScanFunctionParallel, ArrowScanParallelInit,
1116: 	                                ArrowScanParallelStateNext, true, true, ArrowProgress));
1117: 	set.AddFunction(arrow);
1118: }
1119: 
1120: void BuiltinFunctions::RegisterArrowFunctions() {
1121: 	ArrowTableFunction::RegisterFunction(*this);
1122: }
1123: } // namespace duckdb
[end of src/function/table/arrow.cpp]
[start of src/include/duckdb/common/operator/comparison_operators.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/operator/comparison_operators.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/types/string_type.hpp"
12: #include "duckdb/common/types.hpp"
13: #include "duckdb/common/types/hugeint.hpp"
14: #include "duckdb/common/types/interval.hpp"
15: #include "duckdb/common/helper.hpp"
16: 
17: #include <cstring>
18: 
19: namespace duckdb {
20: 
21: //===--------------------------------------------------------------------===//
22: // Comparison Operations
23: //===--------------------------------------------------------------------===//
24: struct Equals {
25: 	template <class T>
26: 	static inline bool Operation(T left, T right) {
27: 		return left == right;
28: 	}
29: };
30: struct NotEquals {
31: 	template <class T>
32: 	static inline bool Operation(T left, T right) {
33: 		return left != right;
34: 	}
35: };
36: struct GreaterThan {
37: 	template <class T>
38: 	static inline bool Operation(T left, T right) {
39: 		return left > right;
40: 	}
41: };
42: struct GreaterThanEquals {
43: 	template <class T>
44: 	static inline bool Operation(T left, T right) {
45: 		return left >= right;
46: 	}
47: };
48: 
49: struct LessThan {
50: 	template <class T>
51: 	static inline bool Operation(T left, T right) {
52: 		return left < right;
53: 	}
54: };
55: struct LessThanEquals {
56: 	template <class T>
57: 	static inline bool Operation(T left, T right) {
58: 		return left <= right;
59: 	}
60: };
61: 
62: // Distinct semantics are from Postgres record sorting. NULL = NULL and not-NULL < NULL
63: // Deferring to the non-distinct operations removes the need for further specialisation.
64: // TODO: To reverse the semantics, swap left_null and right_null for comparisons
65: struct DistinctFrom {
66: 	template <class T>
67: 	static inline bool Operation(T left, T right, bool left_null, bool right_null) {
68: 		return (left_null != right_null) || (!left_null && !right_null && (left != right));
69: 	}
70: };
71: 
72: struct NotDistinctFrom {
73: 	template <class T>
74: 	static inline bool Operation(T left, T right, bool left_null, bool right_null) {
75: 		return (left_null && right_null) || (!left_null && !right_null && (left == right));
76: 	}
77: };
78: 
79: struct DistinctGreaterThan {
80: 	template <class T>
81: 	static inline bool Operation(T left, T right, bool left_null, bool right_null) {
82: 		return GreaterThan::Operation(left_null, right_null) ||
83: 		       (!left_null && !right_null && GreaterThan::Operation(left, right));
84: 	}
85: };
86: 
87: struct DistinctGreaterThanNullsFirst {
88: 	template <class T>
89: 	static inline bool Operation(T left, T right, bool left_null, bool right_null) {
90: 		return GreaterThan::Operation(right_null, left_null) ||
91: 		       (!left_null && !right_null && GreaterThan::Operation(left, right));
92: 	}
93: };
94: 
95: struct DistinctGreaterThanEquals {
96: 	template <class T>
97: 	static inline bool Operation(T left, T right, bool left_null, bool right_null) {
98: 		return left_null || (!left_null && !right_null && GreaterThanEquals::Operation(left, right));
99: 	}
100: };
101: 
102: struct DistinctLessThan {
103: 	template <class T>
104: 	static inline bool Operation(T left, T right, bool left_null, bool right_null) {
105: 		return LessThan::Operation(left_null, right_null) ||
106: 		       (!left_null && !right_null && LessThan::Operation(left, right));
107: 	}
108: };
109: 
110: struct DistinctLessThanNullsFirst {
111: 	template <class T>
112: 	static inline bool Operation(T left, T right, bool left_null, bool right_null) {
113: 		return LessThan::Operation(right_null, left_null) ||
114: 		       (!left_null && !right_null && LessThan::Operation(left, right));
115: 	}
116: };
117: 
118: struct DistinctLessThanEquals {
119: 	template <class T>
120: 	static inline bool Operation(T left, T right, bool left_null, bool right_null) {
121: 		return right_null || (!left_null && !right_null && LessThanEquals::Operation(left, right));
122: 	}
123: };
124: 
125: //===--------------------------------------------------------------------===//
126: // Specialized Boolean Comparison Operators
127: //===--------------------------------------------------------------------===//
128: template <>
129: inline bool GreaterThan::Operation(bool left, bool right) {
130: 	return !right && left;
131: }
132: template <>
133: inline bool LessThan::Operation(bool left, bool right) {
134: 	return !left && right;
135: }
136: //===--------------------------------------------------------------------===//
137: // Specialized String Comparison Operations
138: //===--------------------------------------------------------------------===//
139: struct StringComparisonOperators {
140: 	template <bool INVERSE>
141: 	static inline bool EqualsOrNot(const string_t a, const string_t b) {
142: 		if (a.IsInlined()) {
143: 			// small string: compare entire string
144: 			if (memcmp(&a, &b, sizeof(string_t)) == 0) {
145: 				// entire string is equal
146: 				return INVERSE ? false : true;
147: 			}
148: 		} else {
149: 			// large string: first check prefix and length
150: 			if (memcmp(&a, &b, sizeof(uint32_t) + string_t::PREFIX_LENGTH) == 0) {
151: 				// prefix and length are equal: check main string
152: 				if (memcmp(a.value.pointer.ptr, b.value.pointer.ptr, a.GetSize()) == 0) {
153: 					// entire string is equal
154: 					return INVERSE ? false : true;
155: 				}
156: 			}
157: 		}
158: 		// not equal
159: 		return INVERSE ? true : false;
160: 	}
161: };
162: 
163: template <>
164: inline bool Equals::Operation(string_t left, string_t right) {
165: 	return StringComparisonOperators::EqualsOrNot<false>(left, right);
166: }
167: template <>
168: inline bool NotEquals::Operation(string_t left, string_t right) {
169: 	return StringComparisonOperators::EqualsOrNot<true>(left, right);
170: }
171: 
172: template <>
173: inline bool NotDistinctFrom::Operation(string_t left, string_t right, bool left_null, bool right_null) {
174: 	return (left_null && right_null) ||
175: 	       (!left_null && !right_null && StringComparisonOperators::EqualsOrNot<false>(left, right));
176: }
177: template <>
178: inline bool DistinctFrom::Operation(string_t left, string_t right, bool left_null, bool right_null) {
179: 	return (left_null != right_null) ||
180: 	       (!left_null && !right_null && StringComparisonOperators::EqualsOrNot<true>(left, right));
181: }
182: 
183: // compare up to shared length. if still the same, compare lengths
184: template <class OP>
185: static bool templated_string_compare_op(string_t left, string_t right) {
186: 	auto memcmp_res =
187: 	    memcmp(left.GetDataUnsafe(), right.GetDataUnsafe(), MinValue<idx_t>(left.GetSize(), right.GetSize()));
188: 	auto final_res = memcmp_res == 0 ? OP::Operation(left.GetSize(), right.GetSize()) : OP::Operation(memcmp_res, 0);
189: 	return final_res;
190: }
191: 
192: template <>
193: inline bool GreaterThan::Operation(string_t left, string_t right) {
194: 	return templated_string_compare_op<GreaterThan>(left, right);
195: }
196: 
197: template <>
198: inline bool GreaterThanEquals::Operation(string_t left, string_t right) {
199: 	return templated_string_compare_op<GreaterThanEquals>(left, right);
200: }
201: 
202: template <>
203: inline bool LessThan::Operation(string_t left, string_t right) {
204: 	return templated_string_compare_op<LessThan>(left, right);
205: }
206: 
207: template <>
208: inline bool LessThanEquals::Operation(string_t left, string_t right) {
209: 	return templated_string_compare_op<LessThanEquals>(left, right);
210: }
211: //===--------------------------------------------------------------------===//
212: // Specialized Interval Comparison Operators
213: //===--------------------------------------------------------------------===//
214: template <>
215: inline bool Equals::Operation(interval_t left, interval_t right) {
216: 	return Interval::Equals(left, right);
217: }
218: template <>
219: inline bool NotEquals::Operation(interval_t left, interval_t right) {
220: 	return !Equals::Operation(left, right);
221: }
222: template <>
223: inline bool GreaterThan::Operation(interval_t left, interval_t right) {
224: 	return Interval::GreaterThan(left, right);
225: }
226: template <>
227: inline bool GreaterThanEquals::Operation(interval_t left, interval_t right) {
228: 	return Interval::GreaterThanEquals(left, right);
229: }
230: template <>
231: inline bool LessThan::Operation(interval_t left, interval_t right) {
232: 	return GreaterThan::Operation(right, left);
233: }
234: template <>
235: inline bool LessThanEquals::Operation(interval_t left, interval_t right) {
236: 	return GreaterThanEquals::Operation(right, left);
237: }
238: 
239: template <>
240: inline bool NotDistinctFrom::Operation(interval_t left, interval_t right, bool left_null, bool right_null) {
241: 	return (left_null && right_null) || (!left_null && !right_null && Interval::Equals(left, right));
242: }
243: template <>
244: inline bool DistinctFrom::Operation(interval_t left, interval_t right, bool left_null, bool right_null) {
245: 	return (left_null != right_null) || (!left_null && !right_null && !Equals::Operation(left, right));
246: }
247: inline bool operator<(const interval_t &lhs, const interval_t &rhs) {
248: 	return LessThan::Operation(lhs, rhs);
249: }
250: 
251: //===--------------------------------------------------------------------===//
252: // Specialized Hugeint Comparison Operators
253: //===--------------------------------------------------------------------===//
254: template <>
255: inline bool Equals::Operation(hugeint_t left, hugeint_t right) {
256: 	return Hugeint::Equals(left, right);
257: }
258: template <>
259: inline bool NotEquals::Operation(hugeint_t left, hugeint_t right) {
260: 	return Hugeint::NotEquals(left, right);
261: }
262: template <>
263: inline bool GreaterThan::Operation(hugeint_t left, hugeint_t right) {
264: 	return Hugeint::GreaterThan(left, right);
265: }
266: template <>
267: inline bool GreaterThanEquals::Operation(hugeint_t left, hugeint_t right) {
268: 	return Hugeint::GreaterThanEquals(left, right);
269: }
270: template <>
271: inline bool LessThan::Operation(hugeint_t left, hugeint_t right) {
272: 	return Hugeint::LessThan(left, right);
273: }
274: template <>
275: inline bool LessThanEquals::Operation(hugeint_t left, hugeint_t right) {
276: 	return Hugeint::LessThanEquals(left, right);
277: }
278: } // namespace duckdb
[end of src/include/duckdb/common/operator/comparison_operators.hpp]
[start of src/include/duckdb/common/operator/numeric_cast.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/operator/numeric_cast.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/operator/cast_operators.hpp"
12: #include "duckdb/common/types/hugeint.hpp"
13: 
14: namespace duckdb {
15: 
16: template <class SRC, class DST>
17: static bool TryCastWithOverflowCheck(SRC value, DST &result) {
18: 	if (NumericLimits<SRC>::IsSigned() != NumericLimits<DST>::IsSigned()) {
19: 		if (NumericLimits<SRC>::IsSigned()) {
20: 			// signed to unsigned conversion
21: 			if (NumericLimits<SRC>::Digits() > NumericLimits<DST>::Digits()) {
22: 				if (value < 0 || value > (SRC)NumericLimits<DST>::Maximum()) {
23: 					return false;
24: 				}
25: 			} else {
26: 				if (value < 0) {
27: 					return false;
28: 				}
29: 			}
30: 			result = (DST)value;
31: 			return true;
32: 		} else {
33: 			// unsigned to signed conversion
34: 			if (NumericLimits<SRC>::Digits() >= NumericLimits<DST>::Digits()) {
35: 				if (value <= (SRC)NumericLimits<DST>::Maximum()) {
36: 					result = (DST)value;
37: 					return true;
38: 				}
39: 				return false;
40: 			} else {
41: 				result = (DST)value;
42: 				return true;
43: 			}
44: 		}
45: 	} else {
46: 		// same sign conversion
47: 		if (NumericLimits<DST>::Digits() >= NumericLimits<SRC>::Digits()) {
48: 			result = (DST)value;
49: 			return true;
50: 		} else {
51: 			if (value < SRC(NumericLimits<DST>::Minimum()) || value > SRC(NumericLimits<DST>::Maximum())) {
52: 				return false;
53: 			}
54: 			result = (DST)value;
55: 			return true;
56: 		}
57: 	}
58: }
59: 
60: template <>
61: bool TryCastWithOverflowCheck(float value, int32_t &result) {
62: 	if (!(value >= -2147483648.0f && value < 2147483648.0f)) {
63: 		return false;
64: 	}
65: 	result = int32_t(value);
66: 	return true;
67: }
68: 
69: template <>
70: bool TryCastWithOverflowCheck(float value, int64_t &result) {
71: 	if (!(value >= -9223372036854775808.0f && value < 9223372036854775808.0f)) {
72: 		return false;
73: 	}
74: 	result = int64_t(value);
75: 	return true;
76: }
77: 
78: template <>
79: bool TryCastWithOverflowCheck(double value, int64_t &result) {
80: 	if (!(value >= -9223372036854775808.0 && value < 9223372036854775808.0)) {
81: 		return false;
82: 	}
83: 	result = int64_t(value);
84: 	return true;
85: }
86: 
87: template <>
88: bool TryCastWithOverflowCheck(double input, float &result) {
89: 	if (input < (double)NumericLimits<float>::Minimum() || input > (double)NumericLimits<float>::Maximum()) {
90: 		return false;
91: 	}
92: 	auto res = (float)input;
93: 	if (std::isnan(res) || std::isinf(res)) {
94: 		return false;
95: 	}
96: 	result = res;
97: 	return true;
98: }
99: 
100: //===--------------------------------------------------------------------===//
101: // Cast Numeric -> bool
102: //===--------------------------------------------------------------------===//
103: template <>
104: bool TryCastWithOverflowCheck(bool value, bool &result) {
105: 	result = bool(value);
106: 	return true;
107: }
108: 
109: template <>
110: bool TryCastWithOverflowCheck(int8_t value, bool &result) {
111: 	result = bool(value);
112: 	return true;
113: }
114: 
115: template <>
116: bool TryCastWithOverflowCheck(int16_t value, bool &result) {
117: 	result = bool(value);
118: 	return true;
119: }
120: 
121: template <>
122: bool TryCastWithOverflowCheck(int32_t value, bool &result) {
123: 	result = bool(value);
124: 	return true;
125: }
126: 
127: template <>
128: bool TryCastWithOverflowCheck(int64_t value, bool &result) {
129: 	result = bool(value);
130: 	return true;
131: }
132: 
133: template <>
134: bool TryCastWithOverflowCheck(uint8_t value, bool &result) {
135: 	result = bool(value);
136: 	return true;
137: }
138: 
139: template <>
140: bool TryCastWithOverflowCheck(uint16_t value, bool &result) {
141: 	result = bool(value);
142: 	return true;
143: }
144: 
145: template <>
146: bool TryCastWithOverflowCheck(uint32_t value, bool &result) {
147: 	result = bool(value);
148: 	return true;
149: }
150: 
151: template <>
152: bool TryCastWithOverflowCheck(uint64_t value, bool &result) {
153: 	result = bool(value);
154: 	return true;
155: }
156: 
157: template <>
158: bool TryCastWithOverflowCheck(float value, bool &result) {
159: 	result = bool(value);
160: 	return true;
161: }
162: 
163: template <>
164: bool TryCastWithOverflowCheck(double value, bool &result) {
165: 	result = bool(value);
166: 	return true;
167: }
168: 
169: template <>
170: bool TryCastWithOverflowCheck(hugeint_t input, bool &result) {
171: 	result = input.upper != 0 || input.lower != 0;
172: 	return true;
173: }
174: 
175: //===--------------------------------------------------------------------===//
176: // Cast bool -> Numeric
177: //===--------------------------------------------------------------------===//
178: template <>
179: bool TryCastWithOverflowCheck(bool value, int8_t &result) {
180: 	result = int8_t(value);
181: 	return true;
182: }
183: 
184: template <>
185: bool TryCastWithOverflowCheck(bool value, int16_t &result) {
186: 	result = int16_t(value);
187: 	return true;
188: }
189: 
190: template <>
191: bool TryCastWithOverflowCheck(bool value, int32_t &result) {
192: 	result = int32_t(value);
193: 	return true;
194: }
195: 
196: template <>
197: bool TryCastWithOverflowCheck(bool value, int64_t &result) {
198: 	result = int64_t(value);
199: 	return true;
200: }
201: 
202: template <>
203: bool TryCastWithOverflowCheck(bool value, uint8_t &result) {
204: 	result = uint8_t(value);
205: 	return true;
206: }
207: 
208: template <>
209: bool TryCastWithOverflowCheck(bool value, uint16_t &result) {
210: 	result = uint16_t(value);
211: 	return true;
212: }
213: 
214: template <>
215: bool TryCastWithOverflowCheck(bool value, uint32_t &result) {
216: 	result = uint32_t(value);
217: 	return true;
218: }
219: 
220: template <>
221: bool TryCastWithOverflowCheck(bool value, uint64_t &result) {
222: 	result = uint64_t(value);
223: 	return true;
224: }
225: 
226: template <>
227: bool TryCastWithOverflowCheck(bool value, float &result) {
228: 	result = float(value);
229: 	return true;
230: }
231: 
232: template <>
233: bool TryCastWithOverflowCheck(bool value, double &result) {
234: 	result = double(value);
235: 	return true;
236: }
237: 
238: template <>
239: bool TryCastWithOverflowCheck(bool input, hugeint_t &result) {
240: 	result.upper = 0;
241: 	result.lower = input ? 1 : 0;
242: 	return true;
243: }
244: 
245: //===--------------------------------------------------------------------===//
246: // Cast Numeric -> hugeint
247: //===--------------------------------------------------------------------===//
248: template <>
249: bool TryCastWithOverflowCheck(int8_t value, hugeint_t &result) {
250: 	return Hugeint::TryConvert(value, result);
251: }
252: 
253: template <>
254: bool TryCastWithOverflowCheck(int16_t value, hugeint_t &result) {
255: 	return Hugeint::TryConvert(value, result);
256: }
257: 
258: template <>
259: bool TryCastWithOverflowCheck(int32_t value, hugeint_t &result) {
260: 	return Hugeint::TryConvert(value, result);
261: }
262: 
263: template <>
264: bool TryCastWithOverflowCheck(int64_t value, hugeint_t &result) {
265: 	return Hugeint::TryConvert(value, result);
266: }
267: 
268: template <>
269: bool TryCastWithOverflowCheck(uint8_t value, hugeint_t &result) {
270: 	return Hugeint::TryConvert(value, result);
271: }
272: 
273: template <>
274: bool TryCastWithOverflowCheck(uint16_t value, hugeint_t &result) {
275: 	return Hugeint::TryConvert(value, result);
276: }
277: 
278: template <>
279: bool TryCastWithOverflowCheck(uint32_t value, hugeint_t &result) {
280: 	return Hugeint::TryConvert(value, result);
281: }
282: 
283: template <>
284: bool TryCastWithOverflowCheck(uint64_t value, hugeint_t &result) {
285: 	return Hugeint::TryConvert(value, result);
286: }
287: 
288: template <>
289: bool TryCastWithOverflowCheck(float value, hugeint_t &result) {
290: 	return Hugeint::TryConvert(value, result);
291: }
292: 
293: template <>
294: bool TryCastWithOverflowCheck(double value, hugeint_t &result) {
295: 	return Hugeint::TryConvert(value, result);
296: }
297: 
298: template <>
299: bool TryCastWithOverflowCheck(hugeint_t value, hugeint_t &result) {
300: 	result = value;
301: 	return true;
302: }
303: 
304: //===--------------------------------------------------------------------===//
305: // Cast Hugeint -> Numeric
306: //===--------------------------------------------------------------------===//
307: template <>
308: bool TryCastWithOverflowCheck(hugeint_t value, int8_t &result) {
309: 	return Hugeint::TryCast(value, result);
310: }
311: 
312: template <>
313: bool TryCastWithOverflowCheck(hugeint_t value, int16_t &result) {
314: 	return Hugeint::TryCast(value, result);
315: }
316: 
317: template <>
318: bool TryCastWithOverflowCheck(hugeint_t value, int32_t &result) {
319: 	return Hugeint::TryCast(value, result);
320: }
321: 
322: template <>
323: bool TryCastWithOverflowCheck(hugeint_t value, int64_t &result) {
324: 	return Hugeint::TryCast(value, result);
325: }
326: 
327: template <>
328: bool TryCastWithOverflowCheck(hugeint_t value, uint8_t &result) {
329: 	return Hugeint::TryCast(value, result);
330: }
331: 
332: template <>
333: bool TryCastWithOverflowCheck(hugeint_t value, uint16_t &result) {
334: 	return Hugeint::TryCast(value, result);
335: }
336: 
337: template <>
338: bool TryCastWithOverflowCheck(hugeint_t value, uint32_t &result) {
339: 	return Hugeint::TryCast(value, result);
340: }
341: 
342: template <>
343: bool TryCastWithOverflowCheck(hugeint_t value, uint64_t &result) {
344: 	return Hugeint::TryCast(value, result);
345: }
346: 
347: template <>
348: bool TryCastWithOverflowCheck(hugeint_t value, float &result) {
349: 	return Hugeint::TryCast(value, result);
350: }
351: 
352: template <>
353: bool TryCastWithOverflowCheck(hugeint_t value, double &result) {
354: 	return Hugeint::TryCast(value, result);
355: }
356: 
357: struct NumericTryCast {
358: 	template <class SRC, class DST>
359: 	static inline bool Operation(SRC input, DST &result, bool strict = false) {
360: 		return TryCastWithOverflowCheck(input, result);
361: 	}
362: };
363: 
364: struct NumericCast {
365: 	template <class SRC, class DST>
366: 	static inline DST Operation(SRC input) {
367: 		DST result;
368: 		if (!NumericTryCast::Operation(input, result)) {
369: 			throw InvalidInputException(CastExceptionText<SRC, DST>(input));
370: 		}
371: 		return result;
372: 	}
373: };
374: 
375: } // namespace duckdb
[end of src/include/duckdb/common/operator/numeric_cast.hpp]
[start of src/include/duckdb/common/types/value.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/value.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/exception.hpp"
13: #include "duckdb/common/types.hpp"
14: #include "duckdb/common/winapi.hpp"
15: 
16: namespace duckdb {
17: 
18: class Deserializer;
19: class Serializer;
20: 
21: //! The Value object holds a single arbitrary value of any type that can be
22: //! stored in the database.
23: class Value {
24: 	friend struct StringValue;
25: 	friend struct StructValue;
26: 	friend struct ListValue;
27: 
28: public:
29: 	//! Create an empty NULL value of the specified type
30: 	DUCKDB_API explicit Value(LogicalType type = LogicalType::SQLNULL);
31: 	//! Create an INTEGER value
32: 	DUCKDB_API Value(int32_t val); // NOLINT: Allow implicit conversion from `int32_t`
33: 	//! Create a BIGINT value
34: 	DUCKDB_API Value(int64_t val); // NOLINT: Allow implicit conversion from `int64_t`
35: 	//! Create a FLOAT value
36: 	DUCKDB_API Value(float val); // NOLINT: Allow implicit conversion from `float`
37: 	//! Create a DOUBLE value
38: 	DUCKDB_API Value(double val); // NOLINT: Allow implicit conversion from `double`
39: 	//! Create a VARCHAR value
40: 	DUCKDB_API Value(const char *val); // NOLINT: Allow implicit conversion from `const char *`
41: 	//! Create a NULL value
42: 	DUCKDB_API Value(std::nullptr_t val); // NOLINT: Allow implicit conversion from `nullptr_t`
43: 	//! Create a VARCHAR value
44: 	DUCKDB_API Value(string_t val); // NOLINT: Allow implicit conversion from `string_t`
45: 	//! Create a VARCHAR value
46: 	DUCKDB_API Value(string val); // NOLINT: Allow implicit conversion from `string`
47: 	//! Copy constructor
48: 	DUCKDB_API Value(const Value &other);
49: 	//! Move constructor
50: 	DUCKDB_API Value(Value &&other) noexcept;
51: 	//! Destructor
52: 	DUCKDB_API ~Value();
53: 
54: 	// copy assignment
55: 	DUCKDB_API Value &operator=(const Value &other);
56: 	// move assignment
57: 	DUCKDB_API Value &operator=(Value &&other) noexcept;
58: 
59: 	inline const LogicalType &type() const {
60: 		return type_;
61: 	}
62: 	inline bool IsNull() const {
63: 		return is_null;
64: 	}
65: 
66: 	//! Create the lowest possible value of a given type (numeric only)
67: 	DUCKDB_API static Value MinimumValue(const LogicalType &type);
68: 	//! Create the highest possible value of a given type (numeric only)
69: 	DUCKDB_API static Value MaximumValue(const LogicalType &type);
70: 	//! Create a Numeric value of the specified type with the specified value
71: 	DUCKDB_API static Value Numeric(const LogicalType &type, int64_t value);
72: 	DUCKDB_API static Value Numeric(const LogicalType &type, hugeint_t value);
73: 
74: 	//! Create a tinyint Value from a specified value
75: 	DUCKDB_API static Value BOOLEAN(int8_t value);
76: 	//! Create a tinyint Value from a specified value
77: 	DUCKDB_API static Value TINYINT(int8_t value);
78: 	//! Create a smallint Value from a specified value
79: 	DUCKDB_API static Value SMALLINT(int16_t value);
80: 	//! Create an integer Value from a specified value
81: 	DUCKDB_API static Value INTEGER(int32_t value);
82: 	//! Create a bigint Value from a specified value
83: 	DUCKDB_API static Value BIGINT(int64_t value);
84: 	//! Create an unsigned tinyint Value from a specified value
85: 	DUCKDB_API static Value UTINYINT(uint8_t value);
86: 	//! Create an unsigned smallint Value from a specified value
87: 	DUCKDB_API static Value USMALLINT(uint16_t value);
88: 	//! Create an unsigned integer Value from a specified value
89: 	DUCKDB_API static Value UINTEGER(uint32_t value);
90: 	//! Create an unsigned bigint Value from a specified value
91: 	DUCKDB_API static Value UBIGINT(uint64_t value);
92: 	//! Create a hugeint Value from a specified value
93: 	DUCKDB_API static Value HUGEINT(hugeint_t value);
94: 	//! Create a uuid Value from a specified value
95: 	DUCKDB_API static Value UUID(const string &value);
96: 	//! Create a uuid Value from a specified value
97: 	DUCKDB_API static Value UUID(hugeint_t value);
98: 	//! Create a hash Value from a specified value
99: 	DUCKDB_API static Value HASH(hash_t value);
100: 	//! Create a pointer Value from a specified value
101: 	DUCKDB_API static Value POINTER(uintptr_t value);
102: 	//! Create a date Value from a specified date
103: 	DUCKDB_API static Value DATE(date_t date);
104: 	//! Create a date Value from a specified date
105: 	DUCKDB_API static Value DATE(int32_t year, int32_t month, int32_t day);
106: 	//! Create a time Value from a specified time
107: 	DUCKDB_API static Value TIME(dtime_t time);
108: 	DUCKDB_API static Value TIMETZ(dtime_t time);
109: 	//! Create a time Value from a specified time
110: 	DUCKDB_API static Value TIME(int32_t hour, int32_t min, int32_t sec, int32_t micros);
111: 	//! Create a timestamp Value from a specified date/time combination
112: 	DUCKDB_API static Value TIMESTAMP(date_t date, dtime_t time);
113: 	//! Create a timestamp Value from a specified timestamp
114: 	DUCKDB_API static Value TIMESTAMP(timestamp_t timestamp);
115: 	DUCKDB_API static Value TIMESTAMPNS(timestamp_t timestamp);
116: 	DUCKDB_API static Value TIMESTAMPMS(timestamp_t timestamp);
117: 	DUCKDB_API static Value TIMESTAMPSEC(timestamp_t timestamp);
118: 	DUCKDB_API static Value TIMESTAMPTZ(timestamp_t timestamp);
119: 	//! Create a timestamp Value from a specified timestamp in separate values
120: 	DUCKDB_API static Value TIMESTAMP(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t min, int32_t sec,
121: 	                                  int32_t micros);
122: 	DUCKDB_API static Value INTERVAL(int32_t months, int32_t days, int64_t micros);
123: 	DUCKDB_API static Value INTERVAL(interval_t interval);
124: 	//! Creates a JSON Value
125: 	DUCKDB_API static Value JSON(const char *val);
126: 	DUCKDB_API static Value JSON(string_t val);
127: 	DUCKDB_API static Value JSON(string val);
128: 
129: 	// Create a enum Value from a specified uint value
130: 	DUCKDB_API static Value ENUM(uint64_t value, const LogicalType &original_type);
131: 
132: 	// Decimal values
133: 	DUCKDB_API static Value DECIMAL(int16_t value, uint8_t width, uint8_t scale);
134: 	DUCKDB_API static Value DECIMAL(int32_t value, uint8_t width, uint8_t scale);
135: 	DUCKDB_API static Value DECIMAL(int64_t value, uint8_t width, uint8_t scale);
136: 	DUCKDB_API static Value DECIMAL(hugeint_t value, uint8_t width, uint8_t scale);
137: 	//! Create a float Value from a specified value
138: 	DUCKDB_API static Value FLOAT(float value);
139: 	//! Create a double Value from a specified value
140: 	DUCKDB_API static Value DOUBLE(double value);
141: 	//! Create a struct value with given list of entries
142: 	DUCKDB_API static Value STRUCT(child_list_t<Value> values);
143: 	//! Create a list value with the given entries, list type is inferred from children
144: 	//! Cannot be called with an empty list, use either EMPTYLIST or LIST with a type instead
145: 	DUCKDB_API static Value LIST(vector<Value> values);
146: 	//! Create a list value with the given entries
147: 	DUCKDB_API static Value LIST(LogicalType child_type, vector<Value> values);
148: 	//! Create an empty list with the specified child-type
149: 	DUCKDB_API static Value EMPTYLIST(LogicalType child_type);
150: 	//! Creat a map value from a (key, value) pair
151: 	DUCKDB_API static Value MAP(Value key, Value value);
152: 
153: 	//! Create a blob Value from a data pointer and a length: no bytes are interpreted
154: 	DUCKDB_API static Value BLOB(const_data_ptr_t data, idx_t len);
155: 	DUCKDB_API static Value BLOB_RAW(const string &data) {
156: 		return Value::BLOB((const_data_ptr_t)data.c_str(), data.size());
157: 	}
158: 	//! Creates a blob by casting a specified string to a blob (i.e. interpreting \x characters)
159: 	DUCKDB_API static Value BLOB(const string &data);
160: 
161: 	template <class T>
162: 	T GetValue() const {
163: 		throw InternalException("Unimplemented template type for Value::GetValue");
164: 	}
165: 	template <class T>
166: 	static Value CreateValue(T value) {
167: 		throw InternalException("Unimplemented template type for Value::CreateValue");
168: 	}
169: 	// Returns the internal value. Unlike GetValue(), this method does not perform casting, and assumes T matches the
170: 	// type of the value. Only use this if you know what you are doing.
171: 	template <class T>
172: 	T GetValueUnsafe() const {
173: 		throw InternalException("Unimplemented template type for Value::GetValueUnsafe");
174: 	}
175: 	//! Returns a reference to the internal value. This can only be used for primitive types.
176: 	template <class T>
177: 	T &GetReferenceUnsafe() {
178: 		throw InternalException("Unimplemented template type for Value::GetReferenceUnsafe");
179: 	}
180: 
181: 	//! Return a copy of this value
182: 	Value Copy() const {
183: 		return Value(*this);
184: 	}
185: 
186: 	//! Hashes the Value
187: 	DUCKDB_API hash_t Hash() const;
188: 	//! Convert this value to a string
189: 	DUCKDB_API string ToString() const;
190: 	//! Convert this value to a SQL-parseable string
191: 	DUCKDB_API string ToSQLString() const;
192: 
193: 	DUCKDB_API uintptr_t GetPointer() const;
194: 
195: 	//! Cast this value to another type, throws exception if its not possible
196: 	DUCKDB_API Value CastAs(const LogicalType &target_type, bool strict = false) const;
197: 	//! Tries to cast this value to another type, and stores the result in "new_value"
198: 	DUCKDB_API bool TryCastAs(const LogicalType &target_type, Value &new_value, string *error_message,
199: 	                          bool strict = false) const;
200: 	//! Tries to cast this value to another type, and stores the result in THIS value again
201: 	DUCKDB_API bool TryCastAs(const LogicalType &target_type, bool strict = false);
202: 
203: 	//! Serializes a Value to a stand-alone binary blob
204: 	DUCKDB_API void Serialize(Serializer &serializer) const;
205: 	//! Deserializes a Value from a blob
206: 	DUCKDB_API static Value Deserialize(Deserializer &source);
207: 
208: 	//===--------------------------------------------------------------------===//
209: 	// Comparison Operators
210: 	//===--------------------------------------------------------------------===//
211: 	DUCKDB_API bool operator==(const Value &rhs) const;
212: 	DUCKDB_API bool operator!=(const Value &rhs) const;
213: 	DUCKDB_API bool operator<(const Value &rhs) const;
214: 	DUCKDB_API bool operator>(const Value &rhs) const;
215: 	DUCKDB_API bool operator<=(const Value &rhs) const;
216: 	DUCKDB_API bool operator>=(const Value &rhs) const;
217: 
218: 	DUCKDB_API bool operator==(const int64_t &rhs) const;
219: 	DUCKDB_API bool operator!=(const int64_t &rhs) const;
220: 	DUCKDB_API bool operator<(const int64_t &rhs) const;
221: 	DUCKDB_API bool operator>(const int64_t &rhs) const;
222: 	DUCKDB_API bool operator<=(const int64_t &rhs) const;
223: 	DUCKDB_API bool operator>=(const int64_t &rhs) const;
224: 
225: 	DUCKDB_API static bool FloatIsValid(float value);
226: 	DUCKDB_API static bool DoubleIsValid(double value);
227: 	DUCKDB_API static bool StringIsValid(const char *str, idx_t length);
228: 	static bool StringIsValid(const string &str) {
229: 		return StringIsValid(str.c_str(), str.size());
230: 	}
231: 
232: 	template <class T>
233: 	static bool IsValid(T value) {
234: 		return true;
235: 	}
236: 
237: 	//! Returns true if the values are (approximately) equivalent. Note this is NOT the SQL equivalence. For this
238: 	//! function, NULL values are equivalent and floating point values that are close are equivalent.
239: 	DUCKDB_API static bool ValuesAreEqual(const Value &result_value, const Value &value);
240: 
241: 	friend std::ostream &operator<<(std::ostream &out, const Value &val) {
242: 		out << val.ToString();
243: 		return out;
244: 	}
245: 	DUCKDB_API void Print() const;
246: 
247: private:
248: 	//! The logical of the value
249: 	LogicalType type_;
250: 
251: #if DUCKDB_API_VERSION < DUCKDB_API_0_3_2
252: public:
253: #endif
254: 	//! Whether or not the value is NULL
255: 	bool is_null;
256: 
257: 	//! The value of the object, if it is of a constant size Type
258: 	union Val {
259: 		int8_t boolean;
260: 		int8_t tinyint;
261: 		int16_t smallint;
262: 		int32_t integer;
263: 		int64_t bigint;
264: 		uint8_t utinyint;
265: 		uint16_t usmallint;
266: 		uint32_t uinteger;
267: 		uint64_t ubigint;
268: 		hugeint_t hugeint;
269: 		float float_;
270: 		double double_;
271: 		uintptr_t pointer;
272: 		uint64_t hash;
273: 		date_t date;
274: 		dtime_t time;
275: 		timestamp_t timestamp;
276: 		interval_t interval;
277: 	} value_;
278: 
279: 	//! The value of the object, if it is of a variable size type
280: 	string str_value;
281: 
282: 	vector<Value> struct_value;
283: 	vector<Value> list_value;
284: 
285: private:
286: 	template <class T>
287: 	T GetValueInternal() const;
288: };
289: 
290: //===--------------------------------------------------------------------===//
291: // Type-specific getters
292: //===--------------------------------------------------------------------===//
293: // Note that these are equivalent to calling GetValueUnsafe<X>, meaning no cast will be performed
294: // instead, an assertion will be triggered if the value is not of the correct type
295: struct BooleanValue {
296: 	DUCKDB_API static bool Get(const Value &value);
297: };
298: 
299: struct TinyIntValue {
300: 	DUCKDB_API static int8_t Get(const Value &value);
301: };
302: 
303: struct SmallIntValue {
304: 	DUCKDB_API static int16_t Get(const Value &value);
305: };
306: 
307: struct IntegerValue {
308: 	DUCKDB_API static int32_t Get(const Value &value);
309: };
310: 
311: struct BigIntValue {
312: 	DUCKDB_API static int64_t Get(const Value &value);
313: };
314: 
315: struct HugeIntValue {
316: 	DUCKDB_API static hugeint_t Get(const Value &value);
317: };
318: 
319: struct UTinyIntValue {
320: 	DUCKDB_API static uint8_t Get(const Value &value);
321: };
322: 
323: struct USmallIntValue {
324: 	DUCKDB_API static uint16_t Get(const Value &value);
325: };
326: 
327: struct UIntegerValue {
328: 	DUCKDB_API static uint32_t Get(const Value &value);
329: };
330: 
331: struct UBigIntValue {
332: 	DUCKDB_API static uint64_t Get(const Value &value);
333: };
334: 
335: struct FloatValue {
336: 	DUCKDB_API static float Get(const Value &value);
337: };
338: 
339: struct DoubleValue {
340: 	DUCKDB_API static double Get(const Value &value);
341: };
342: 
343: struct StringValue {
344: 	DUCKDB_API static const string &Get(const Value &value);
345: };
346: 
347: struct DateValue {
348: 	DUCKDB_API static date_t Get(const Value &value);
349: };
350: 
351: struct TimeValue {
352: 	DUCKDB_API static dtime_t Get(const Value &value);
353: };
354: 
355: struct TimestampValue {
356: 	DUCKDB_API static timestamp_t Get(const Value &value);
357: };
358: 
359: struct IntervalValue {
360: 	DUCKDB_API static interval_t Get(const Value &value);
361: };
362: 
363: struct StructValue {
364: 	DUCKDB_API static const vector<Value> &GetChildren(const Value &value);
365: };
366: 
367: struct ListValue {
368: 	DUCKDB_API static const vector<Value> &GetChildren(const Value &value);
369: };
370: 
371: //! Return the internal integral value for any type that is stored as an integral value internally
372: //! This can be used on values of type integer, uinteger, but also date, timestamp, decimal, etc
373: struct IntegralValue {
374: 	static hugeint_t Get(const Value &value);
375: };
376: 
377: template <>
378: Value DUCKDB_API Value::CreateValue(bool value);
379: template <>
380: Value DUCKDB_API Value::CreateValue(uint8_t value);
381: template <>
382: Value DUCKDB_API Value::CreateValue(uint16_t value);
383: template <>
384: Value DUCKDB_API Value::CreateValue(uint32_t value);
385: template <>
386: Value DUCKDB_API Value::CreateValue(uint64_t value);
387: template <>
388: Value DUCKDB_API Value::CreateValue(int8_t value);
389: template <>
390: Value DUCKDB_API Value::CreateValue(int16_t value);
391: template <>
392: Value DUCKDB_API Value::CreateValue(int32_t value);
393: template <>
394: Value DUCKDB_API Value::CreateValue(int64_t value);
395: template <>
396: Value DUCKDB_API Value::CreateValue(hugeint_t value);
397: template <>
398: Value DUCKDB_API Value::CreateValue(date_t value);
399: template <>
400: Value DUCKDB_API Value::CreateValue(dtime_t value);
401: template <>
402: Value DUCKDB_API Value::CreateValue(timestamp_t value);
403: template <>
404: Value DUCKDB_API Value::CreateValue(const char *value);
405: template <>
406: Value DUCKDB_API Value::CreateValue(string value);
407: template <>
408: Value DUCKDB_API Value::CreateValue(string_t value);
409: template <>
410: Value DUCKDB_API Value::CreateValue(float value);
411: template <>
412: Value DUCKDB_API Value::CreateValue(double value);
413: template <>
414: Value DUCKDB_API Value::CreateValue(interval_t value);
415: template <>
416: Value DUCKDB_API Value::CreateValue(Value value);
417: 
418: template <>
419: DUCKDB_API bool Value::GetValue() const;
420: template <>
421: DUCKDB_API int8_t Value::GetValue() const;
422: template <>
423: DUCKDB_API int16_t Value::GetValue() const;
424: template <>
425: DUCKDB_API int32_t Value::GetValue() const;
426: template <>
427: DUCKDB_API int64_t Value::GetValue() const;
428: template <>
429: DUCKDB_API uint8_t Value::GetValue() const;
430: template <>
431: DUCKDB_API uint16_t Value::GetValue() const;
432: template <>
433: DUCKDB_API uint32_t Value::GetValue() const;
434: template <>
435: DUCKDB_API uint64_t Value::GetValue() const;
436: template <>
437: DUCKDB_API hugeint_t Value::GetValue() const;
438: template <>
439: DUCKDB_API string Value::GetValue() const;
440: template <>
441: DUCKDB_API float Value::GetValue() const;
442: template <>
443: DUCKDB_API double Value::GetValue() const;
444: template <>
445: DUCKDB_API date_t Value::GetValue() const;
446: template <>
447: DUCKDB_API dtime_t Value::GetValue() const;
448: template <>
449: DUCKDB_API timestamp_t Value::GetValue() const;
450: template <>
451: DUCKDB_API interval_t Value::GetValue() const;
452: 
453: template <>
454: DUCKDB_API bool Value::GetValueUnsafe() const;
455: template <>
456: DUCKDB_API int8_t Value::GetValueUnsafe() const;
457: template <>
458: DUCKDB_API int16_t Value::GetValueUnsafe() const;
459: template <>
460: DUCKDB_API int32_t Value::GetValueUnsafe() const;
461: template <>
462: DUCKDB_API int64_t Value::GetValueUnsafe() const;
463: template <>
464: DUCKDB_API hugeint_t Value::GetValueUnsafe() const;
465: template <>
466: DUCKDB_API uint8_t Value::GetValueUnsafe() const;
467: template <>
468: DUCKDB_API uint16_t Value::GetValueUnsafe() const;
469: template <>
470: DUCKDB_API uint32_t Value::GetValueUnsafe() const;
471: template <>
472: DUCKDB_API uint64_t Value::GetValueUnsafe() const;
473: template <>
474: DUCKDB_API string Value::GetValueUnsafe() const;
475: template <>
476: DUCKDB_API string_t Value::GetValueUnsafe() const;
477: template <>
478: DUCKDB_API float Value::GetValueUnsafe() const;
479: template <>
480: DUCKDB_API double Value::GetValueUnsafe() const;
481: template <>
482: DUCKDB_API date_t Value::GetValueUnsafe() const;
483: template <>
484: DUCKDB_API dtime_t Value::GetValueUnsafe() const;
485: template <>
486: DUCKDB_API timestamp_t Value::GetValueUnsafe() const;
487: template <>
488: DUCKDB_API interval_t Value::GetValueUnsafe() const;
489: 
490: template <>
491: DUCKDB_API int8_t &Value::GetReferenceUnsafe();
492: template <>
493: DUCKDB_API int16_t &Value::GetReferenceUnsafe();
494: template <>
495: DUCKDB_API int32_t &Value::GetReferenceUnsafe();
496: template <>
497: DUCKDB_API int64_t &Value::GetReferenceUnsafe();
498: template <>
499: DUCKDB_API hugeint_t &Value::GetReferenceUnsafe();
500: template <>
501: DUCKDB_API uint8_t &Value::GetReferenceUnsafe();
502: template <>
503: DUCKDB_API uint16_t &Value::GetReferenceUnsafe();
504: template <>
505: DUCKDB_API uint32_t &Value::GetReferenceUnsafe();
506: template <>
507: DUCKDB_API uint64_t &Value::GetReferenceUnsafe();
508: template <>
509: DUCKDB_API float &Value::GetReferenceUnsafe();
510: template <>
511: DUCKDB_API double &Value::GetReferenceUnsafe();
512: template <>
513: DUCKDB_API date_t &Value::GetReferenceUnsafe();
514: template <>
515: DUCKDB_API dtime_t &Value::GetReferenceUnsafe();
516: template <>
517: DUCKDB_API timestamp_t &Value::GetReferenceUnsafe();
518: template <>
519: DUCKDB_API interval_t &Value::GetReferenceUnsafe();
520: 
521: template <>
522: DUCKDB_API bool Value::IsValid(float value);
523: template <>
524: DUCKDB_API bool Value::IsValid(double value);
525: 
526: } // namespace duckdb
[end of src/include/duckdb/common/types/value.hpp]
[start of src/include/duckdb/function/aggregate/algebraic/corr.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/aggregate/algebraic/corr.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/aggregate_function.hpp"
12: #include "duckdb/function/aggregate/algebraic_functions.hpp"
13: #include "duckdb/function/aggregate/algebraic/covar.hpp"
14: #include "duckdb/function/aggregate/algebraic/stddev.hpp"
15: 
16: namespace duckdb {
17: 
18: struct CorrState {
19: 	CovarState cov_pop;
20: 	StddevState dev_pop_x;
21: 	StddevState dev_pop_y;
22: };
23: 
24: // Returns the correlation coefficient for non-null pairs in a group.
25: // CORR(y, x) = COVAR_POP(y, x) / (STDDEV_POP(x) * STDDEV_POP(y))
26: struct CorrOperation {
27: 	template <class STATE>
28: 	static void Initialize(STATE *state) {
29: 		CovarOperation::Initialize<CovarState>(&state->cov_pop);
30: 		STDDevBaseOperation::Initialize<StddevState>(&state->dev_pop_x);
31: 		STDDevBaseOperation::Initialize<StddevState>(&state->dev_pop_y);
32: 	}
33: 
34: 	template <class A_TYPE, class B_TYPE, class STATE, class OP>
35: 	static void Operation(STATE *state, FunctionData *bind_data, A_TYPE *x_data, B_TYPE *y_data, ValidityMask &amask,
36: 	                      ValidityMask &bmask, idx_t xidx, idx_t yidx) {
37: 		CovarOperation::Operation<A_TYPE, B_TYPE, CovarState, OP>(&state->cov_pop, bind_data, x_data, y_data, amask,
38: 		                                                          bmask, xidx, yidx);
39: 		STDDevBaseOperation::Operation<A_TYPE, StddevState, OP>(&state->dev_pop_x, bind_data, x_data, amask, xidx);
40: 		STDDevBaseOperation::Operation<B_TYPE, StddevState, OP>(&state->dev_pop_y, bind_data, y_data, bmask, yidx);
41: 	}
42: 
43: 	template <class STATE, class OP>
44: 	static void Combine(const STATE &source, STATE *target) {
45: 		CovarOperation::Combine<CovarState, OP>(source.cov_pop, &target->cov_pop);
46: 		STDDevBaseOperation::Combine<StddevState, OP>(source.dev_pop_x, &target->dev_pop_x);
47: 		STDDevBaseOperation::Combine<StddevState, OP>(source.dev_pop_y, &target->dev_pop_y);
48: 	}
49: 
50: 	template <class T, class STATE>
51: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
52: 		if (state->cov_pop.count == 0 || state->dev_pop_x.count == 0 || state->dev_pop_y.count == 0) {
53: 			mask.SetInvalid(idx);
54: 		} else {
55: 			auto cov = state->cov_pop.co_moment / state->cov_pop.count;
56: 			auto std_x = state->dev_pop_x.count > 1 ? sqrt(state->dev_pop_x.dsquared / state->dev_pop_x.count) : 0;
57: 			if (!Value::DoubleIsValid(std_x)) {
58: 				throw OutOfRangeException("STDDEV_POP for X is invalid!");
59: 			}
60: 			auto std_y = state->dev_pop_y.count > 1 ? sqrt(state->dev_pop_y.dsquared / state->dev_pop_y.count) : 0;
61: 			if (!Value::DoubleIsValid(std_y)) {
62: 				throw OutOfRangeException("STDDEV_POP for Y is invalid!");
63: 			}
64: 			if (std_x * std_y == 0) {
65: 				mask.SetInvalid(idx);
66: 				return;
67: 			}
68: 			target[idx] = cov / (std_x * std_y);
69: 		}
70: 	}
71: 
72: 	static bool IgnoreNull() {
73: 		return true;
74: 	}
75: };
76: 
77: } // namespace duckdb
[end of src/include/duckdb/function/aggregate/algebraic/corr.hpp]
[start of src/include/duckdb/function/aggregate/algebraic/stddev.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/aggregate/algebraic/stddev.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/aggregate_function.hpp"
12: #include <ctgmath>
13: 
14: namespace duckdb {
15: 
16: struct StddevState {
17: 	uint64_t count;  //  n
18: 	double mean;     //  M1
19: 	double dsquared; //  M2
20: };
21: 
22: // Streaming approximate standard deviation using Welford's
23: // method, DOI: 10.2307/1266577
24: struct STDDevBaseOperation {
25: 	template <class STATE>
26: 	static void Initialize(STATE *state) {
27: 		state->count = 0;
28: 		state->mean = 0;
29: 		state->dsquared = 0;
30: 	}
31: 
32: 	template <class INPUT_TYPE, class STATE, class OP>
33: 	static void Operation(STATE *state, FunctionData *bind_data, INPUT_TYPE *input_data, ValidityMask &mask,
34: 	                      idx_t idx) {
35: 		// update running mean and d^2
36: 		state->count++;
37: 		const double input = input_data[idx];
38: 		const double mean_differential = (input - state->mean) / state->count;
39: 		const double new_mean = state->mean + mean_differential;
40: 		const double dsquared_increment = (input - new_mean) * (input - state->mean);
41: 		const double new_dsquared = state->dsquared + dsquared_increment;
42: 
43: 		state->mean = new_mean;
44: 		state->dsquared = new_dsquared;
45: 	}
46: 
47: 	template <class INPUT_TYPE, class STATE, class OP>
48: 	static void ConstantOperation(STATE *state, FunctionData *bind_data, INPUT_TYPE *input_data, ValidityMask &mask,
49: 	                              idx_t count) {
50: 		for (idx_t i = 0; i < count; i++) {
51: 			Operation<INPUT_TYPE, STATE, OP>(state, bind_data, input_data, mask, 0);
52: 		}
53: 	}
54: 
55: 	template <class STATE, class OP>
56: 	static void Combine(const STATE &source, STATE *target) {
57: 		if (target->count == 0) {
58: 			*target = source;
59: 		} else if (source.count > 0) {
60: 			const auto count = target->count + source.count;
61: 			const auto mean = (source.count * source.mean + target->count * target->mean) / count;
62: 			const auto delta = source.mean - target->mean;
63: 			target->dsquared =
64: 			    source.dsquared + target->dsquared + delta * delta * source.count * target->count / count;
65: 			target->mean = mean;
66: 			target->count = count;
67: 		}
68: 	}
69: 
70: 	static bool IgnoreNull() {
71: 		return true;
72: 	}
73: };
74: 
75: struct VarSampOperation : public STDDevBaseOperation {
76: 	template <class T, class STATE>
77: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
78: 		if (state->count <= 1) {
79: 			mask.SetInvalid(idx);
80: 		} else {
81: 			target[idx] = state->dsquared / (state->count - 1);
82: 			if (!Value::DoubleIsValid(target[idx])) {
83: 				throw OutOfRangeException("VARSAMP is out of range!");
84: 			}
85: 		}
86: 	}
87: };
88: 
89: struct VarPopOperation : public STDDevBaseOperation {
90: 	template <class T, class STATE>
91: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
92: 		if (state->count == 0) {
93: 			mask.SetInvalid(idx);
94: 		} else {
95: 			target[idx] = state->count > 1 ? (state->dsquared / state->count) : 0;
96: 			if (!Value::DoubleIsValid(target[idx])) {
97: 				throw OutOfRangeException("VARPOP is out of range!");
98: 			}
99: 		}
100: 	}
101: };
102: 
103: struct STDDevSampOperation : public STDDevBaseOperation {
104: 	template <class T, class STATE>
105: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
106: 		if (state->count <= 1) {
107: 			mask.SetInvalid(idx);
108: 		} else {
109: 			target[idx] = sqrt(state->dsquared / (state->count - 1));
110: 			if (!Value::DoubleIsValid(target[idx])) {
111: 				throw OutOfRangeException("STDDEV_SAMP is out of range!");
112: 			}
113: 		}
114: 	}
115: };
116: 
117: struct STDDevPopOperation : public STDDevBaseOperation {
118: 	template <class T, class STATE>
119: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
120: 		if (state->count == 0) {
121: 			mask.SetInvalid(idx);
122: 		} else {
123: 			target[idx] = state->count > 1 ? sqrt(state->dsquared / state->count) : 0;
124: 			if (!Value::DoubleIsValid(target[idx])) {
125: 				throw OutOfRangeException("STDDEV_POP is out of range!");
126: 			}
127: 		}
128: 	}
129: };
130: 
131: struct StandardErrorOfTheMeanOperation : public STDDevBaseOperation {
132: 	template <class T, class STATE>
133: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
134: 		if (state->count == 0) {
135: 			mask.SetInvalid(idx);
136: 		} else {
137: 			target[idx] = sqrt(state->dsquared / state->count) / sqrt((state->count));
138: 			if (!Value::DoubleIsValid(target[idx])) {
139: 				throw OutOfRangeException("SEM is out of range!");
140: 			}
141: 		}
142: 	}
143: };
144: } // namespace duckdb
[end of src/include/duckdb/function/aggregate/algebraic/stddev.hpp]
[start of src/include/duckdb/function/aggregate/regression/regr_slope.hpp]
1: // REGR_SLOPE(y, x)
2: // Returns the slope of the linear regression line for non-null pairs in a group.
3: // It is computed for non-null pairs using the following formula:
4: // COVAR_POP(x,y) / VAR_POP(x)
5: 
6: //! Input : Any numeric type
7: //! Output : Double
8: 
9: #pragma once
10: #include "duckdb/function/aggregate/algebraic/stddev.hpp"
11: #include "duckdb/function/aggregate/algebraic/covar.hpp"
12: 
13: namespace duckdb {
14: 
15: struct RegrSlopeState {
16: 	CovarState cov_pop;
17: 	StddevState var_pop;
18: };
19: 
20: struct RegrSlopeOperation {
21: 	template <class STATE>
22: 	static void Initialize(STATE *state) {
23: 		CovarOperation::Initialize<CovarState>(&state->cov_pop);
24: 		STDDevBaseOperation::Initialize<StddevState>(&state->var_pop);
25: 	}
26: 
27: 	template <class A_TYPE, class B_TYPE, class STATE, class OP>
28: 	static void Operation(STATE *state, FunctionData *bind_data, A_TYPE *x_data, B_TYPE *y_data, ValidityMask &amask,
29: 	                      ValidityMask &bmask, idx_t xidx, idx_t yidx) {
30: 		CovarOperation::Operation<A_TYPE, B_TYPE, CovarState, OP>(&state->cov_pop, bind_data, y_data, x_data, bmask,
31: 		                                                          amask, yidx, xidx);
32: 		STDDevBaseOperation::Operation<A_TYPE, StddevState, OP>(&state->var_pop, bind_data, y_data, bmask, yidx);
33: 	}
34: 
35: 	template <class STATE, class OP>
36: 	static void Combine(const STATE &source, STATE *target) {
37: 		CovarOperation::Combine<CovarState, OP>(source.cov_pop, &target->cov_pop);
38: 		STDDevBaseOperation::Combine<StddevState, OP>(source.var_pop, &target->var_pop);
39: 	}
40: 
41: 	template <class T, class STATE>
42: 	static void Finalize(Vector &result, FunctionData *, STATE *state, T *target, ValidityMask &mask, idx_t idx) {
43: 		if (state->cov_pop.count == 0 || state->var_pop.count == 0) {
44: 			mask.SetInvalid(idx);
45: 		} else {
46: 			auto cov = state->cov_pop.co_moment / state->cov_pop.count;
47: 			auto var_pop = state->var_pop.count > 1 ? (state->var_pop.dsquared / state->var_pop.count) : 0;
48: 			if (!Value::DoubleIsValid(var_pop)) {
49: 				throw OutOfRangeException("VARPOP is out of range!");
50: 			}
51: 			if (var_pop == 0) {
52: 				mask.SetInvalid(idx);
53: 				return;
54: 			}
55: 			target[idx] = cov / var_pop;
56: 		}
57: 	}
58: 
59: 	static bool IgnoreNull() {
60: 		return true;
61: 	}
62: };
63: } // namespace duckdb
[end of src/include/duckdb/function/aggregate/regression/regr_slope.hpp]
[start of src/include/duckdb/function/scalar/math_functions.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/scalar/math_functions.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/scalar_function.hpp"
12: #include "duckdb/function/function_set.hpp"
13: 
14: namespace duckdb {
15: 
16: struct AbsFun {
17: 	static void RegisterFunction(BuiltinFunctions &set);
18: };
19: 
20: struct SignFun {
21: 	static void RegisterFunction(BuiltinFunctions &set);
22: };
23: 
24: struct CeilFun {
25: 	static void RegisterFunction(BuiltinFunctions &set);
26: };
27: 
28: struct FloorFun {
29: 	static void RegisterFunction(BuiltinFunctions &set);
30: };
31: 
32: struct RoundFun {
33: 	static void RegisterFunction(BuiltinFunctions &set);
34: };
35: 
36: struct DegreesFun {
37: 	static void RegisterFunction(BuiltinFunctions &set);
38: };
39: 
40: struct RadiansFun {
41: 	static void RegisterFunction(BuiltinFunctions &set);
42: };
43: 
44: struct RandomFun {
45: 	static void RegisterFunction(BuiltinFunctions &set);
46: };
47: 
48: struct SetseedFun {
49: 	static void RegisterFunction(BuiltinFunctions &set);
50: };
51: 
52: struct CbrtFun {
53: 	static void RegisterFunction(BuiltinFunctions &set);
54: };
55: 
56: struct ExpFun {
57: 	static void RegisterFunction(BuiltinFunctions &set);
58: };
59: 
60: struct Log2Fun {
61: 	static void RegisterFunction(BuiltinFunctions &set);
62: };
63: 
64: struct Log10Fun {
65: 	static void RegisterFunction(BuiltinFunctions &set);
66: };
67: 
68: struct LnFun {
69: 	static void RegisterFunction(BuiltinFunctions &set);
70: };
71: 
72: struct PowFun {
73: 	static void RegisterFunction(BuiltinFunctions &set);
74: };
75: 
76: struct SqrtFun {
77: 	static void RegisterFunction(BuiltinFunctions &set);
78: };
79: 
80: struct PiFun {
81: 	static void RegisterFunction(BuiltinFunctions &set);
82: };
83: 
84: struct BitCountFun {
85: 	static void RegisterFunction(BuiltinFunctions &set);
86: };
87: 
88: struct GammaFun {
89: 	static void RegisterFunction(BuiltinFunctions &set);
90: };
91: 
92: struct LogGammaFun {
93: 	static void RegisterFunction(BuiltinFunctions &set);
94: };
95: 
96: struct FactorialFun {
97: 	static void RegisterFunction(BuiltinFunctions &set);
98: };
99: 
100: struct NextAfterFun {
101: 	static void RegisterFunction(BuiltinFunctions &set);
102: };
103: 
104: struct EvenFun {
105: 	static void RegisterFunction(BuiltinFunctions &set);
106: };
107: 
108: } // namespace duckdb
[end of src/include/duckdb/function/scalar/math_functions.hpp]
[start of src/main/appender.cpp]
1: #include "duckdb/main/appender.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
4: #include "duckdb/common/exception.hpp"
5: #include "duckdb/main/connection.hpp"
6: #include "duckdb/main/client_context.hpp"
7: #include "duckdb/main/database.hpp"
8: #include "duckdb/storage/data_table.hpp"
9: #include "duckdb/common/string_util.hpp"
10: #include "duckdb/common/operator/cast_operators.hpp"
11: #include "duckdb/common/operator/string_cast.hpp"
12: #include "duckdb/storage/data_table.hpp"
13: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
14: 
15: namespace duckdb {
16: 
17: BaseAppender::BaseAppender() : column(0) {
18: }
19: 
20: BaseAppender::BaseAppender(vector<LogicalType> types_p) : types(move(types_p)), column(0) {
21: 	InitializeChunk();
22: }
23: 
24: BaseAppender::~BaseAppender() {
25: }
26: 
27: void BaseAppender::Destructor() {
28: 	if (Exception::UncaughtException()) {
29: 		return;
30: 	}
31: 	// flush any remaining chunks, but only if we are not cleaning up the appender as part of an exception stack unwind
32: 	// wrapped in a try/catch because Close() can throw if the table was dropped in the meantime
33: 	try {
34: 		Close();
35: 	} catch (...) {
36: 	}
37: }
38: 
39: InternalAppender::InternalAppender(ClientContext &context_p, TableCatalogEntry &table_p)
40:     : BaseAppender(table_p.GetTypes()), context(context_p), table(table_p) {
41: }
42: 
43: InternalAppender::~InternalAppender() {
44: 	Destructor();
45: }
46: 
47: Appender::Appender(Connection &con, const string &schema_name, const string &table_name)
48:     : BaseAppender(), context(con.context) {
49: 	description = con.TableInfo(schema_name, table_name);
50: 	if (!description) {
51: 		// table could not be found
52: 		throw CatalogException(StringUtil::Format("Table \"%s.%s\" could not be found", schema_name, table_name));
53: 	}
54: 	for (auto &column : description->columns) {
55: 		types.push_back(column.type);
56: 	}
57: 	InitializeChunk();
58: }
59: 
60: Appender::Appender(Connection &con, const string &table_name) : Appender(con, DEFAULT_SCHEMA, table_name) {
61: }
62: 
63: Appender::~Appender() {
64: 	Destructor();
65: }
66: 
67: void BaseAppender::InitializeChunk() {
68: 	chunk = make_unique<DataChunk>();
69: 	chunk->Initialize(types);
70: }
71: 
72: void BaseAppender::BeginRow() {
73: }
74: 
75: void BaseAppender::EndRow() {
76: 	// check that all rows have been appended to
77: 	if (column != chunk->ColumnCount()) {
78: 		throw InvalidInputException("Call to EndRow before all rows have been appended to!");
79: 	}
80: 	column = 0;
81: 	chunk->SetCardinality(chunk->size() + 1);
82: 	if (chunk->size() >= STANDARD_VECTOR_SIZE) {
83: 		FlushChunk();
84: 	}
85: }
86: 
87: template <class SRC, class DST>
88: void BaseAppender::AppendValueInternal(Vector &col, SRC input) {
89: 	FlatVector::GetData<DST>(col)[chunk->size()] = Cast::Operation<SRC, DST>(input);
90: }
91: 
92: template <class T>
93: void BaseAppender::AppendValueInternal(T input) {
94: 	if (column >= types.size()) {
95: 		throw InvalidInputException("Too many appends for chunk!");
96: 	}
97: 	auto &col = chunk->data[column];
98: 	switch (col.GetType().InternalType()) {
99: 	case PhysicalType::BOOL:
100: 		AppendValueInternal<T, bool>(col, input);
101: 		break;
102: 	case PhysicalType::UINT8:
103: 		AppendValueInternal<T, uint8_t>(col, input);
104: 		break;
105: 	case PhysicalType::INT8:
106: 		AppendValueInternal<T, int8_t>(col, input);
107: 		break;
108: 	case PhysicalType::UINT16:
109: 		AppendValueInternal<T, uint16_t>(col, input);
110: 		break;
111: 	case PhysicalType::INT16:
112: 		AppendValueInternal<T, int16_t>(col, input);
113: 		break;
114: 	case PhysicalType::UINT32:
115: 		AppendValueInternal<T, uint32_t>(col, input);
116: 		break;
117: 	case PhysicalType::INT32:
118: 		AppendValueInternal<T, int32_t>(col, input);
119: 		break;
120: 	case PhysicalType::UINT64:
121: 		AppendValueInternal<T, uint64_t>(col, input);
122: 		break;
123: 	case PhysicalType::INT64:
124: 		AppendValueInternal<T, int64_t>(col, input);
125: 		break;
126: 	case PhysicalType::INT128:
127: 		AppendValueInternal<T, hugeint_t>(col, input);
128: 		break;
129: 	case PhysicalType::FLOAT:
130: 		AppendValueInternal<T, float>(col, input);
131: 		break;
132: 	case PhysicalType::DOUBLE:
133: 		AppendValueInternal<T, double>(col, input);
134: 		break;
135: 	case PhysicalType::VARCHAR:
136: 		FlatVector::GetData<string_t>(col)[chunk->size()] = StringCast::Operation<T>(input, col);
137: 		break;
138: 	default:
139: 		AppendValue(Value::CreateValue<T>(input));
140: 		return;
141: 	}
142: 	column++;
143: }
144: 
145: template <>
146: void BaseAppender::Append(bool value) {
147: 	AppendValueInternal<bool>(value);
148: }
149: 
150: template <>
151: void BaseAppender::Append(int8_t value) {
152: 	AppendValueInternal<int8_t>(value);
153: }
154: 
155: template <>
156: void BaseAppender::Append(int16_t value) {
157: 	AppendValueInternal<int16_t>(value);
158: }
159: 
160: template <>
161: void BaseAppender::Append(int32_t value) {
162: 	AppendValueInternal<int32_t>(value);
163: }
164: 
165: template <>
166: void BaseAppender::Append(int64_t value) {
167: 	AppendValueInternal<int64_t>(value);
168: }
169: 
170: template <>
171: void BaseAppender::Append(hugeint_t value) {
172: 	AppendValueInternal<hugeint_t>(value);
173: }
174: 
175: template <>
176: void BaseAppender::Append(uint8_t value) {
177: 	AppendValueInternal<uint8_t>(value);
178: }
179: 
180: template <>
181: void BaseAppender::Append(uint16_t value) {
182: 	AppendValueInternal<uint16_t>(value);
183: }
184: 
185: template <>
186: void BaseAppender::Append(uint32_t value) {
187: 	AppendValueInternal<uint32_t>(value);
188: }
189: 
190: template <>
191: void BaseAppender::Append(uint64_t value) {
192: 	AppendValueInternal<uint64_t>(value);
193: }
194: 
195: template <>
196: void BaseAppender::Append(const char *value) {
197: 	AppendValueInternal<string_t>(string_t(value));
198: }
199: 
200: void BaseAppender::Append(const char *value, uint32_t length) {
201: 	AppendValueInternal<string_t>(string_t(value, length));
202: }
203: 
204: template <>
205: void BaseAppender::Append(string_t value) {
206: 	AppendValueInternal<string_t>(value);
207: }
208: 
209: template <>
210: void BaseAppender::Append(float value) {
211: 	if (!Value::FloatIsValid(value)) {
212: 		throw InvalidInputException("Float value is out of range!");
213: 	}
214: 	AppendValueInternal<float>(value);
215: }
216: 
217: template <>
218: void BaseAppender::Append(double value) {
219: 	if (!Value::DoubleIsValid(value)) {
220: 		throw InvalidInputException("Double value is out of range!");
221: 	}
222: 	AppendValueInternal<double>(value);
223: }
224: 
225: template <>
226: void BaseAppender::Append(date_t value) {
227: 	AppendValueInternal<int32_t>(value.days);
228: }
229: 
230: template <>
231: void BaseAppender::Append(dtime_t value) {
232: 	AppendValueInternal<int64_t>(value.micros);
233: }
234: 
235: template <>
236: void BaseAppender::Append(timestamp_t value) {
237: 	AppendValueInternal<int64_t>(value.value);
238: }
239: 
240: template <>
241: void BaseAppender::Append(interval_t value) {
242: 	AppendValueInternal<interval_t>(value);
243: }
244: 
245: template <>
246: void BaseAppender::Append(Value value) { // NOLINT: template shtuff
247: 	if (column >= chunk->ColumnCount()) {
248: 		throw InvalidInputException("Too many appends for chunk!");
249: 	}
250: 	AppendValue(value);
251: }
252: 
253: template <>
254: void BaseAppender::Append(std::nullptr_t value) {
255: 	if (column >= chunk->ColumnCount()) {
256: 		throw InvalidInputException("Too many appends for chunk!");
257: 	}
258: 	auto &col = chunk->data[column++];
259: 	FlatVector::SetNull(col, chunk->size(), true);
260: }
261: 
262: void BaseAppender::AppendValue(const Value &value) {
263: 	chunk->SetValue(column, chunk->size(), value);
264: 	column++;
265: }
266: 
267: void BaseAppender::AppendDataChunk(DataChunk &chunk) {
268: 	if (chunk.GetTypes() != types) {
269: 		throw InvalidInputException("Type mismatch in Append DataChunk and the types required for appender");
270: 	}
271: 	collection.Append(chunk);
272: 	if (collection.ChunkCount() >= FLUSH_COUNT) {
273: 		Flush();
274: 	}
275: }
276: 
277: void BaseAppender::FlushChunk() {
278: 	if (chunk->size() == 0) {
279: 		return;
280: 	}
281: 	collection.Append(move(chunk));
282: 	InitializeChunk();
283: 	if (collection.ChunkCount() >= FLUSH_COUNT) {
284: 		Flush();
285: 	}
286: }
287: 
288: void BaseAppender::Flush() {
289: 	// check that all vectors have the same length before appending
290: 	if (column != 0) {
291: 		throw InvalidInputException("Failed to Flush appender: incomplete append to row!");
292: 	}
293: 
294: 	FlushChunk();
295: 	if (collection.Count() == 0) {
296: 		return;
297: 	}
298: 	FlushInternal(collection);
299: 
300: 	collection.Reset();
301: 	column = 0;
302: }
303: 
304: void Appender::FlushInternal(ChunkCollection &collection) {
305: 	context->Append(*description, collection);
306: }
307: 
308: void InternalAppender::FlushInternal(ChunkCollection &collection) {
309: 	for (auto &chunk : collection.Chunks()) {
310: 		table.storage->Append(table, context, *chunk);
311: 	}
312: }
313: 
314: void BaseAppender::Close() {
315: 	if (column == 0 || column == types.size()) {
316: 		Flush();
317: 	}
318: }
319: 
320: } // namespace duckdb
[end of src/main/appender.cpp]
[start of src/main/capi/hugeint-c.cpp]
1: #include "duckdb/main/capi_internal.hpp"
2: #include "duckdb/common/types/hugeint.hpp"
3: #include "duckdb/common/types/decimal.hpp"
4: #include "duckdb/common/operator/decimal_cast_operators.hpp"
5: 
6: using duckdb::Hugeint;
7: using duckdb::hugeint_t;
8: using duckdb::Value;
9: 
10: double duckdb_hugeint_to_double(duckdb_hugeint val) {
11: 	hugeint_t internal;
12: 	internal.lower = val.lower;
13: 	internal.upper = val.upper;
14: 	return Hugeint::Cast<double>(internal);
15: }
16: 
17: duckdb_hugeint duckdb_double_to_hugeint(double val) {
18: 	hugeint_t internal_result;
19: 	if (!Value::DoubleIsValid(val) || !Hugeint::TryConvert<double>(val, internal_result)) {
20: 		internal_result.lower = 0;
21: 		internal_result.upper = 0;
22: 	}
23: 
24: 	duckdb_hugeint result;
25: 	result.lower = internal_result.lower;
26: 	result.upper = internal_result.upper;
27: 	return result;
28: }
29: 
30: double duckdb_decimal_to_double(duckdb_decimal val) {
31: 	double result;
32: 	hugeint_t value;
33: 	value.lower = val.value.lower;
34: 	value.upper = val.value.upper;
35: 	duckdb::TryCastFromDecimal::Operation<hugeint_t, double>(value, result, nullptr, val.width, val.scale);
36: 	return result;
37: }
[end of src/main/capi/hugeint-c.cpp]
[start of src/main/capi/prepared-c.cpp]
1: #include "duckdb/main/capi_internal.hpp"
2: #include "duckdb/common/assert.hpp"
3: #include "duckdb/main/query_result.hpp"
4: #include "duckdb/main/prepared_statement_data.hpp"
5: 
6: using duckdb::Connection;
7: using duckdb::date_t;
8: using duckdb::dtime_t;
9: using duckdb::hugeint_t;
10: using duckdb::MaterializedQueryResult;
11: using duckdb::PreparedStatementWrapper;
12: using duckdb::QueryResultType;
13: using duckdb::timestamp_t;
14: using duckdb::Value;
15: 
16: duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,
17:                             duckdb_prepared_statement *out_prepared_statement) {
18: 	if (!connection || !query || !out_prepared_statement) {
19: 		return DuckDBError;
20: 	}
21: 	auto wrapper = new PreparedStatementWrapper();
22: 	Connection *conn = (Connection *)connection;
23: 	wrapper->statement = conn->Prepare(query);
24: 	*out_prepared_statement = (duckdb_prepared_statement)wrapper;
25: 	return wrapper->statement->success ? DuckDBSuccess : DuckDBError;
26: }
27: 
28: const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement) {
29: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
30: 	if (!wrapper || !wrapper->statement || wrapper->statement->success) {
31: 		return nullptr;
32: 	}
33: 	return wrapper->statement->error.c_str();
34: }
35: 
36: idx_t duckdb_nparams(duckdb_prepared_statement prepared_statement) {
37: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
38: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
39: 		return 0;
40: 	}
41: 	return wrapper->statement->n_param;
42: }
43: 
44: duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_t param_idx) {
45: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
46: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
47: 		return DUCKDB_TYPE_INVALID;
48: 	}
49: 	auto entry = wrapper->statement->data->value_map.find(param_idx);
50: 	if (entry == wrapper->statement->data->value_map.end()) {
51: 		return DUCKDB_TYPE_INVALID;
52: 	}
53: 	return ConvertCPPTypeToC(entry->second[0]->type());
54: }
55: 
56: static duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_statement, idx_t param_idx, Value val) {
57: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
58: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
59: 		return DuckDBError;
60: 	}
61: 	if (param_idx <= 0 || param_idx > wrapper->statement->n_param) {
62: 		return DuckDBError;
63: 	}
64: 	if (param_idx > wrapper->values.size()) {
65: 		wrapper->values.resize(param_idx);
66: 	}
67: 	wrapper->values[param_idx - 1] = val;
68: 	return DuckDBSuccess;
69: }
70: 
71: duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val) {
72: 	return duckdb_bind_value(prepared_statement, param_idx, Value::BOOLEAN(val));
73: }
74: 
75: duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val) {
76: 	return duckdb_bind_value(prepared_statement, param_idx, Value::TINYINT(val));
77: }
78: 
79: duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val) {
80: 	return duckdb_bind_value(prepared_statement, param_idx, Value::SMALLINT(val));
81: }
82: 
83: duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val) {
84: 	return duckdb_bind_value(prepared_statement, param_idx, Value::INTEGER(val));
85: }
86: 
87: duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val) {
88: 	return duckdb_bind_value(prepared_statement, param_idx, Value::BIGINT(val));
89: }
90: 
91: duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx, duckdb_hugeint val) {
92: 	hugeint_t internal;
93: 	internal.lower = val.lower;
94: 	internal.upper = val.upper;
95: 	return duckdb_bind_value(prepared_statement, param_idx, Value::HUGEINT(internal));
96: }
97: 
98: duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val) {
99: 	return duckdb_bind_value(prepared_statement, param_idx, Value::UTINYINT(val));
100: }
101: 
102: duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val) {
103: 	return duckdb_bind_value(prepared_statement, param_idx, Value::USMALLINT(val));
104: }
105: 
106: duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val) {
107: 	return duckdb_bind_value(prepared_statement, param_idx, Value::UINTEGER(val));
108: }
109: 
110: duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val) {
111: 	return duckdb_bind_value(prepared_statement, param_idx, Value::UBIGINT(val));
112: }
113: 
114: duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val) {
115: 	if (!Value::FloatIsValid(val)) {
116: 		return DuckDBError;
117: 	}
118: 	return duckdb_bind_value(prepared_statement, param_idx, Value::FLOAT(val));
119: }
120: 
121: duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val) {
122: 	if (!Value::DoubleIsValid(val)) {
123: 		return DuckDBError;
124: 	}
125: 	return duckdb_bind_value(prepared_statement, param_idx, Value::DOUBLE(val));
126: }
127: 
128: duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx, duckdb_date val) {
129: 	return duckdb_bind_value(prepared_statement, param_idx, Value::DATE(date_t(val.days)));
130: }
131: 
132: duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx, duckdb_time val) {
133: 	return duckdb_bind_value(prepared_statement, param_idx, Value::TIME(dtime_t(val.micros)));
134: }
135: 
136: duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,
137:                                    duckdb_timestamp val) {
138: 	return duckdb_bind_value(prepared_statement, param_idx, Value::TIMESTAMP(timestamp_t(val.micros)));
139: }
140: 
141: duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx, duckdb_interval val) {
142: 	return duckdb_bind_value(prepared_statement, param_idx, Value::INTERVAL(val.months, val.days, val.micros));
143: }
144: 
145: duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val) {
146: 	try {
147: 		return duckdb_bind_value(prepared_statement, param_idx, Value(val));
148: 	} catch (...) {
149: 		return DuckDBError;
150: 	}
151: }
152: 
153: duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx, const char *val,
154:                                         idx_t length) {
155: 	try {
156: 		return duckdb_bind_value(prepared_statement, param_idx, Value(std::string(val, length)));
157: 	} catch (...) {
158: 		return DuckDBError;
159: 	}
160: }
161: 
162: duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx, const void *data,
163:                               idx_t length) {
164: 	return duckdb_bind_value(prepared_statement, param_idx, Value::BLOB((duckdb::const_data_ptr_t)data, length));
165: }
166: 
167: duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx) {
168: 	return duckdb_bind_value(prepared_statement, param_idx, Value());
169: }
170: 
171: duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement, duckdb_result *out_result) {
172: 	auto wrapper = (PreparedStatementWrapper *)prepared_statement;
173: 	if (!wrapper || !wrapper->statement || !wrapper->statement->success) {
174: 		return DuckDBError;
175: 	}
176: 	auto result = wrapper->statement->Execute(wrapper->values, false);
177: 	return duckdb_translate_result(move(result), out_result);
178: }
179: 
180: void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement) {
181: 	if (!prepared_statement) {
182: 		return;
183: 	}
184: 	auto wrapper = (PreparedStatementWrapper *)*prepared_statement;
185: 	if (wrapper) {
186: 		delete wrapper;
187: 	}
188: 	*prepared_statement = nullptr;
189: }
[end of src/main/capi/prepared-c.cpp]
[start of src/main/query_profiler.cpp]
1: #include "duckdb/main/query_profiler.hpp"
2: #include "duckdb/common/to_string.hpp"
3: #include "duckdb/common/fstream.hpp"
4: #include "duckdb/common/printer.hpp"
5: #include "duckdb/common/string_util.hpp"
6: #include "duckdb/execution/physical_operator.hpp"
7: #include "duckdb/execution/operator/join/physical_delim_join.hpp"
8: #include "duckdb/execution/operator/helper/physical_execute.hpp"
9: #include "duckdb/common/tree_renderer.hpp"
10: #include "duckdb/parser/sql_statement.hpp"
11: #include "duckdb/common/limits.hpp"
12: #include "duckdb/execution/expression_executor.hpp"
13: #include "duckdb/planner/expression/bound_function_expression.hpp"
14: #include "duckdb/main/client_config.hpp"
15: #include "duckdb/main/client_context.hpp"
16: #include <utility>
17: #include <algorithm>
18: 
19: namespace duckdb {
20: 
21: QueryProfiler::QueryProfiler(ClientContext &context_p)
22:     : context(context_p), running(false), query_requires_profiling(false), is_explain_analyze(false) {
23: }
24: 
25: bool QueryProfiler::IsEnabled() const {
26: 	return is_explain_analyze ? true : ClientConfig::GetConfig(context).enable_profiler;
27: }
28: 
29: bool QueryProfiler::IsDetailedEnabled() const {
30: 	return is_explain_analyze ? false : ClientConfig::GetConfig(context).enable_detailed_profiling;
31: }
32: 
33: ProfilerPrintFormat QueryProfiler::GetPrintFormat() const {
34: 	return is_explain_analyze ? ProfilerPrintFormat::NONE : ClientConfig::GetConfig(context).profiler_print_format;
35: }
36: 
37: string QueryProfiler::GetSaveLocation() const {
38: 	return is_explain_analyze ? string() : ClientConfig::GetConfig(context).profiler_save_location;
39: }
40: 
41: QueryProfiler &QueryProfiler::Get(ClientContext &context) {
42: 	return *context.profiler;
43: }
44: 
45: void QueryProfiler::StartQuery(string query, bool is_explain_analyze) {
46: 	if (is_explain_analyze) {
47: 		StartExplainAnalyze();
48: 	}
49: 	if (!IsEnabled()) {
50: 		return;
51: 	}
52: 	this->running = true;
53: 	this->query = move(query);
54: 	tree_map.clear();
55: 	root = nullptr;
56: 	phase_timings.clear();
57: 	phase_stack.clear();
58: 
59: 	main_query.Start();
60: }
61: 
62: bool QueryProfiler::OperatorRequiresProfiling(PhysicalOperatorType op_type) {
63: 	switch (op_type) {
64: 	case PhysicalOperatorType::ORDER_BY:
65: 	case PhysicalOperatorType::RESERVOIR_SAMPLE:
66: 	case PhysicalOperatorType::STREAMING_SAMPLE:
67: 	case PhysicalOperatorType::LIMIT:
68: 	case PhysicalOperatorType::LIMIT_PERCENT:
69: 	case PhysicalOperatorType::TOP_N:
70: 	case PhysicalOperatorType::WINDOW:
71: 	case PhysicalOperatorType::UNNEST:
72: 	case PhysicalOperatorType::SIMPLE_AGGREGATE:
73: 	case PhysicalOperatorType::HASH_GROUP_BY:
74: 	case PhysicalOperatorType::FILTER:
75: 	case PhysicalOperatorType::PROJECTION:
76: 	case PhysicalOperatorType::COPY_TO_FILE:
77: 	case PhysicalOperatorType::TABLE_SCAN:
78: 	case PhysicalOperatorType::CHUNK_SCAN:
79: 	case PhysicalOperatorType::DELIM_SCAN:
80: 	case PhysicalOperatorType::EXPRESSION_SCAN:
81: 	case PhysicalOperatorType::BLOCKWISE_NL_JOIN:
82: 	case PhysicalOperatorType::NESTED_LOOP_JOIN:
83: 	case PhysicalOperatorType::HASH_JOIN:
84: 	case PhysicalOperatorType::CROSS_PRODUCT:
85: 	case PhysicalOperatorType::PIECEWISE_MERGE_JOIN:
86: 	case PhysicalOperatorType::IE_JOIN:
87: 	case PhysicalOperatorType::DELIM_JOIN:
88: 	case PhysicalOperatorType::UNION:
89: 	case PhysicalOperatorType::RECURSIVE_CTE:
90: 	case PhysicalOperatorType::EMPTY_RESULT:
91: 		return true;
92: 	default:
93: 		return false;
94: 	}
95: }
96: 
97: void QueryProfiler::Finalize(TreeNode &node) {
98: 	for (auto &child : node.children) {
99: 		Finalize(*child);
100: 		if (node.type == PhysicalOperatorType::UNION) {
101: 			node.info.elements += child->info.elements;
102: 		}
103: 	}
104: }
105: 
106: void QueryProfiler::StartExplainAnalyze() {
107: 	this->is_explain_analyze = true;
108: }
109: 
110: void QueryProfiler::EndQuery() {
111: 	lock_guard<mutex> guard(flush_lock);
112: 	if (!IsEnabled() || !running) {
113: 		return;
114: 	}
115: 
116: 	main_query.End();
117: 	if (root) {
118: 		Finalize(*root);
119: 	}
120: 	this->running = false;
121: 	auto automatic_print_format = GetPrintFormat();
122: 	// print or output the query profiling after termination, if this is enabled
123: 	if (automatic_print_format != ProfilerPrintFormat::NONE) {
124: 		// check if this query should be output based on the operator types
125: 		string query_info;
126: 		if (automatic_print_format == ProfilerPrintFormat::JSON) {
127: 			query_info = ToJSON();
128: 		} else if (automatic_print_format == ProfilerPrintFormat::QUERY_TREE) {
129: 			query_info = ToString();
130: 		} else if (automatic_print_format == ProfilerPrintFormat::QUERY_TREE_OPTIMIZER) {
131: 			query_info = ToString(true);
132: 		}
133: 		auto save_location = GetSaveLocation();
134: 		if (save_location.empty()) {
135: 			Printer::Print(query_info);
136: 			Printer::Print("\n");
137: 		} else {
138: 			WriteToFile(save_location.c_str(), query_info);
139: 		}
140: 	}
141: 	this->is_explain_analyze = false;
142: }
143: 
144: void QueryProfiler::StartPhase(string new_phase) {
145: 	if (!IsEnabled() || !running) {
146: 		return;
147: 	}
148: 
149: 	if (!phase_stack.empty()) {
150: 		// there are active phases
151: 		phase_profiler.End();
152: 		// add the timing to all phases prior to this one
153: 		string prefix = "";
154: 		for (auto &phase : phase_stack) {
155: 			phase_timings[phase] += phase_profiler.Elapsed();
156: 			prefix += phase + " > ";
157: 		}
158: 		// when there are previous phases, we prefix the current phase with those phases
159: 		new_phase = prefix + new_phase;
160: 	}
161: 
162: 	// start a new phase
163: 	phase_stack.push_back(new_phase);
164: 	// restart the timer
165: 	phase_profiler.Start();
166: }
167: 
168: void QueryProfiler::EndPhase() {
169: 	if (!IsEnabled() || !running) {
170: 		return;
171: 	}
172: 	D_ASSERT(phase_stack.size() > 0);
173: 
174: 	// end the timer
175: 	phase_profiler.End();
176: 	// add the timing to all currently active phases
177: 	for (auto &phase : phase_stack) {
178: 		phase_timings[phase] += phase_profiler.Elapsed();
179: 	}
180: 	// now remove the last added phase
181: 	phase_stack.pop_back();
182: 
183: 	if (!phase_stack.empty()) {
184: 		phase_profiler.Start();
185: 	}
186: }
187: 
188: void QueryProfiler::Initialize(PhysicalOperator *root_op) {
189: 	if (!IsEnabled() || !running) {
190: 		return;
191: 	}
192: 	this->query_requires_profiling = false;
193: 	this->root = CreateTree(root_op);
194: 	if (!query_requires_profiling) {
195: 		// query does not require profiling: disable profiling for this query
196: 		this->running = false;
197: 		tree_map.clear();
198: 		root = nullptr;
199: 		phase_timings.clear();
200: 		phase_stack.clear();
201: 	}
202: }
203: 
204: OperatorProfiler::OperatorProfiler(bool enabled_p) : enabled(enabled_p), active_operator(nullptr) {
205: }
206: 
207: void OperatorProfiler::StartOperator(const PhysicalOperator *phys_op) {
208: 	if (!enabled) {
209: 		return;
210: 	}
211: 
212: 	if (active_operator) {
213: 		throw InternalException("OperatorProfiler: Attempting to call StartOperator while another operator is active");
214: 	}
215: 
216: 	active_operator = phys_op;
217: 
218: 	// start timing for current element
219: 	op.Start();
220: }
221: 
222: void OperatorProfiler::EndOperator(DataChunk *chunk) {
223: 	if (!enabled) {
224: 		return;
225: 	}
226: 
227: 	if (!active_operator) {
228: 		throw InternalException("OperatorProfiler: Attempting to call EndOperator while another operator is active");
229: 	}
230: 
231: 	// finish timing for the current element
232: 	op.End();
233: 
234: 	AddTiming(active_operator, op.Elapsed(), chunk ? chunk->size() : 0);
235: 	active_operator = nullptr;
236: }
237: 
238: void OperatorProfiler::AddTiming(const PhysicalOperator *op, double time, idx_t elements) {
239: 	if (!enabled) {
240: 		return;
241: 	}
242: 	if (!Value::DoubleIsValid(time)) {
243: 		return;
244: 	}
245: 	auto entry = timings.find(op);
246: 	if (entry == timings.end()) {
247: 		// add new entry
248: 		timings[op] = OperatorInformation(time, elements);
249: 	} else {
250: 		// add to existing entry
251: 		entry->second.time += time;
252: 		entry->second.elements += elements;
253: 	}
254: }
255: void OperatorProfiler::Flush(const PhysicalOperator *phys_op, ExpressionExecutor *expression_executor,
256:                              const string &name, int id) {
257: 	auto entry = timings.find(phys_op);
258: 	if (entry == timings.end()) {
259: 		return;
260: 	}
261: 	auto &operator_timing = timings.find(phys_op)->second;
262: 	if (int(operator_timing.executors_info.size()) <= id) {
263: 		operator_timing.executors_info.resize(id + 1);
264: 	}
265: 	operator_timing.executors_info[id] = make_unique<ExpressionExecutorInfo>(*expression_executor, name, id);
266: 	operator_timing.name = phys_op->GetName();
267: }
268: 
269: void QueryProfiler::Flush(OperatorProfiler &profiler) {
270: 	lock_guard<mutex> guard(flush_lock);
271: 	if (!IsEnabled() || !running) {
272: 		return;
273: 	}
274: 	for (auto &node : profiler.timings) {
275: 		auto entry = tree_map.find(node.first);
276: 		D_ASSERT(entry != tree_map.end());
277: 
278: 		entry->second->info.time += node.second.time;
279: 		entry->second->info.elements += node.second.elements;
280: 		if (!IsDetailedEnabled()) {
281: 			continue;
282: 		}
283: 		for (auto &info : node.second.executors_info) {
284: 			if (!info) {
285: 				continue;
286: 			}
287: 			auto info_id = info->id;
288: 			if (int(entry->second->info.executors_info.size()) <= info_id) {
289: 				entry->second->info.executors_info.resize(info_id + 1);
290: 			}
291: 			entry->second->info.executors_info[info_id] = move(info);
292: 		}
293: 	}
294: 	profiler.timings.clear();
295: }
296: 
297: static string DrawPadded(const string &str, idx_t width) {
298: 	if (str.size() > width) {
299: 		return str.substr(0, width);
300: 	} else {
301: 		width -= str.size();
302: 		int half_spaces = width / 2;
303: 		int extra_left_space = width % 2 != 0 ? 1 : 0;
304: 		return string(half_spaces + extra_left_space, ' ') + str + string(half_spaces, ' ');
305: 	}
306: }
307: 
308: static string RenderTitleCase(string str) {
309: 	str = StringUtil::Lower(str);
310: 	str[0] = toupper(str[0]);
311: 	for (idx_t i = 0; i < str.size(); i++) {
312: 		if (str[i] == '_') {
313: 			str[i] = ' ';
314: 			if (i + 1 < str.size()) {
315: 				str[i + 1] = toupper(str[i + 1]);
316: 			}
317: 		}
318: 	}
319: 	return str;
320: }
321: 
322: static string RenderTiming(double timing) {
323: 	string timing_s;
324: 	if (timing >= 1) {
325: 		timing_s = StringUtil::Format("%.2f", timing);
326: 	} else if (timing >= 0.1) {
327: 		timing_s = StringUtil::Format("%.3f", timing);
328: 	} else {
329: 		timing_s = StringUtil::Format("%.4f", timing);
330: 	}
331: 	return timing_s + "s";
332: }
333: 
334: string QueryProfiler::ToString(bool print_optimizer_output) const {
335: 	std::stringstream str;
336: 	ToStream(str, print_optimizer_output);
337: 	return str.str();
338: }
339: 
340: void QueryProfiler::ToStream(std::ostream &ss, bool print_optimizer_output) const {
341: 	if (!IsEnabled()) {
342: 		ss << "Query profiling is disabled. Call "
343: 		      "Connection::EnableProfiling() to enable profiling!";
344: 		return;
345: 	}
346: 	ss << "┌─────────────────────────────────────┐\n";
347: 	ss << "│┌───────────────────────────────────┐│\n";
348: 	ss << "││    Query Profiling Information    ││\n";
349: 	ss << "│└───────────────────────────────────┘│\n";
350: 	ss << "└─────────────────────────────────────┘\n";
351: 	ss << StringUtil::Replace(query, "\n", " ") + "\n";
352: 	if (query.empty()) {
353: 		return;
354: 	}
355: 
356: 	constexpr idx_t TOTAL_BOX_WIDTH = 39;
357: 	ss << "┌─────────────────────────────────────┐\n";
358: 	ss << "│┌───────────────────────────────────┐│\n";
359: 	string total_time = "Total Time: " + RenderTiming(main_query.Elapsed());
360: 	ss << "││" + DrawPadded(total_time, TOTAL_BOX_WIDTH - 4) + "││\n";
361: 	ss << "│└───────────────────────────────────┘│\n";
362: 	ss << "└─────────────────────────────────────┘\n";
363: 	// print phase timings
364: 	if (print_optimizer_output) {
365: 		bool has_previous_phase = false;
366: 		for (const auto &entry : GetOrderedPhaseTimings()) {
367: 			if (!StringUtil::Contains(entry.first, " > ")) {
368: 				// primary phase!
369: 				if (has_previous_phase) {
370: 					ss << "│└───────────────────────────────────┘│\n";
371: 					ss << "└─────────────────────────────────────┘\n";
372: 				}
373: 				ss << "┌─────────────────────────────────────┐\n";
374: 				ss << "│" +
375: 				          DrawPadded(RenderTitleCase(entry.first) + ": " + RenderTiming(entry.second),
376: 				                     TOTAL_BOX_WIDTH - 2) +
377: 				          "│\n";
378: 				ss << "│┌───────────────────────────────────┐│\n";
379: 				has_previous_phase = true;
380: 			} else {
381: 				string entry_name = StringUtil::Split(entry.first, " > ")[1];
382: 				ss << "││" +
383: 				          DrawPadded(RenderTitleCase(entry_name) + ": " + RenderTiming(entry.second),
384: 				                     TOTAL_BOX_WIDTH - 4) +
385: 				          "││\n";
386: 			}
387: 		}
388: 		if (has_previous_phase) {
389: 			ss << "│└───────────────────────────────────┘│\n";
390: 			ss << "└─────────────────────────────────────┘\n";
391: 		}
392: 	}
393: 	// render the main operator tree
394: 	if (root) {
395: 		Render(*root, ss);
396: 	}
397: }
398: 
399: static string JSONSanitize(const string &text) {
400: 	string result;
401: 	result.reserve(text.size());
402: 	for (idx_t i = 0; i < text.size(); i++) {
403: 		switch (text[i]) {
404: 		case '\b':
405: 			result += "\\b";
406: 			break;
407: 		case '\f':
408: 			result += "\\f";
409: 			break;
410: 		case '\n':
411: 			result += "\\n";
412: 			break;
413: 		case '\r':
414: 			result += "\\r";
415: 			break;
416: 		case '\t':
417: 			result += "\\t";
418: 			break;
419: 		case '"':
420: 			result += "\\\"";
421: 			break;
422: 		case '\\':
423: 			result += "\\\\";
424: 			break;
425: 		default:
426: 			result += text[i];
427: 			break;
428: 		}
429: 	}
430: 	return result;
431: }
432: 
433: // Print a row
434: static void PrintRow(std::ostream &ss, const string &annotation, int id, const string &name, double time,
435:                      int sample_counter, int tuple_counter, const string &extra_info, int depth) {
436: 	ss << string(depth * 3, ' ') << " {\n";
437: 	ss << string(depth * 3, ' ') << "   \"annotation\": \"" + JSONSanitize(annotation) + "\",\n";
438: 	ss << string(depth * 3, ' ') << "   \"id\": " + to_string(id) + ",\n";
439: 	ss << string(depth * 3, ' ') << "   \"name\": \"" + JSONSanitize(name) + "\",\n";
440: #if defined(RDTSC)
441: 	ss << string(depth * 3, ' ') << "   \"timing\": \"NULL\" ,\n";
442: 	ss << string(depth * 3, ' ') << "   \"cycles_per_tuple\": " + StringUtil::Format("%.4f", time) + ",\n";
443: #else
444: 	ss << string(depth * 3, ' ') << "   \"timing\":" + to_string(time) + ",\n";
445: 	ss << string(depth * 3, ' ') << "   \"cycles_per_tuple\": \"NULL\" ,\n";
446: #endif
447: 	ss << string(depth * 3, ' ') << "   \"sample_size\": " << to_string(sample_counter) + ",\n";
448: 	ss << string(depth * 3, ' ') << "   \"input_size\": " << to_string(tuple_counter) + ",\n";
449: 	ss << string(depth * 3, ' ') << "   \"extra_info\": \"" << JSONSanitize(extra_info) + "\"\n";
450: 	ss << string(depth * 3, ' ') << " },\n";
451: }
452: 
453: static void ExtractFunctions(std::ostream &ss, ExpressionInfo &info, int &fun_id, int depth) {
454: 	if (info.hasfunction) {
455: 		D_ASSERT(info.sample_tuples_count != 0);
456: 		PrintRow(ss, "Function", fun_id++, info.function_name,
457: 		         int(info.function_time) / double(info.sample_tuples_count), info.sample_tuples_count,
458: 		         info.tuples_count, "", depth);
459: 	}
460: 	if (info.children.empty()) {
461: 		return;
462: 	}
463: 	// extract the children of this node
464: 	for (auto &child : info.children) {
465: 		ExtractFunctions(ss, *child, fun_id, depth);
466: 	}
467: }
468: 
469: static void ToJSONRecursive(QueryProfiler::TreeNode &node, std::ostream &ss, int depth = 1) {
470: 	ss << string(depth * 3, ' ') << " {\n";
471: 	ss << string(depth * 3, ' ') << "   \"name\": \"" + JSONSanitize(node.name) + "\",\n";
472: 	ss << string(depth * 3, ' ') << "   \"timing\":" + to_string(node.info.time) + ",\n";
473: 	ss << string(depth * 3, ' ') << "   \"cardinality\":" + to_string(node.info.elements) + ",\n";
474: 	ss << string(depth * 3, ' ') << "   \"extra_info\": \"" + JSONSanitize(node.extra_info) + "\",\n";
475: 	ss << string(depth * 3, ' ') << "   \"timings\": [";
476: 	int32_t function_counter = 1;
477: 	int32_t expression_counter = 1;
478: 	ss << "\n ";
479: 	for (auto &expr_executor : node.info.executors_info) {
480: 		// For each Expression tree
481: 		if (!expr_executor) {
482: 			continue;
483: 		}
484: 		for (auto &expr_timer : expr_executor->roots) {
485: 			D_ASSERT(expr_timer->sample_tuples_count != 0);
486: 			PrintRow(ss, "ExpressionRoot", expression_counter++, expr_timer->name,
487: 			         int(expr_timer->time) / double(expr_timer->sample_tuples_count), expr_timer->sample_tuples_count,
488: 			         expr_timer->tuples_count, expr_timer->extra_info, depth + 1);
489: 			// Extract all functions inside the tree
490: 			ExtractFunctions(ss, *expr_timer->root, function_counter, depth + 1);
491: 		}
492: 	}
493: 	ss.seekp(-2, ss.cur);
494: 	ss << "\n";
495: 	ss << string(depth * 3, ' ') << "   ],\n";
496: 	ss << string(depth * 3, ' ') << "   \"children\": [\n";
497: 	if (node.children.empty()) {
498: 		ss << string(depth * 3, ' ') << "   ]\n";
499: 	} else {
500: 		for (idx_t i = 0; i < node.children.size(); i++) {
501: 			if (i > 0) {
502: 				ss << ",\n";
503: 			}
504: 			ToJSONRecursive(*node.children[i], ss, depth + 1);
505: 		}
506: 		ss << string(depth * 3, ' ') << "   ]\n";
507: 	}
508: 	ss << string(depth * 3, ' ') << " }\n";
509: }
510: 
511: string QueryProfiler::ToJSON() const {
512: 	if (!IsEnabled()) {
513: 		return "{ \"result\": \"disabled\" }\n";
514: 	}
515: 	if (query.empty()) {
516: 		return "{ \"result\": \"empty\" }\n";
517: 	}
518: 	if (!root) {
519: 		return "{ \"result\": \"error\" }\n";
520: 	}
521: 	std::stringstream ss;
522: 	ss << "{\n";
523: 	ss << "   \"name\":  \"Query\", \n";
524: 	ss << "   \"result\": " + to_string(main_query.Elapsed()) + ",\n";
525: 	ss << "   \"timing\": " + to_string(main_query.Elapsed()) + ",\n";
526: 	ss << "   \"cardinality\": " + to_string(root->info.elements) + ",\n";
527: 	// JSON cannot have literal control characters in string literals
528: 	string extra_info = JSONSanitize(query);
529: 	ss << "   \"extra-info\": \"" + extra_info + "\", \n";
530: 	// print the phase timings
531: 	ss << "   \"timings\": [\n";
532: 	const auto &ordered_phase_timings = GetOrderedPhaseTimings();
533: 	for (idx_t i = 0; i < ordered_phase_timings.size(); i++) {
534: 		if (i > 0) {
535: 			ss << ",\n";
536: 		}
537: 		ss << "   {\n";
538: 		ss << "   \"annotation\": \"" + ordered_phase_timings[i].first + "\", \n";
539: 		ss << "   \"timing\": " + to_string(ordered_phase_timings[i].second) + "\n";
540: 		ss << "   }";
541: 	}
542: 	ss << "\n";
543: 	ss << "   ],\n";
544: 	// recursively print the physical operator tree
545: 	ss << "   \"children\": [\n";
546: 	ToJSONRecursive(*root, ss);
547: 	ss << "   ]\n";
548: 	ss << "}";
549: 	return ss.str();
550: }
551: 
552: void QueryProfiler::WriteToFile(const char *path, string &info) const {
553: 	ofstream out(path);
554: 	out << info;
555: 	out.close();
556: 	// throw an IO exception if it fails to write the file
557: 	if (out.fail()) {
558: 		throw IOException(strerror(errno));
559: 	}
560: }
561: 
562: unique_ptr<QueryProfiler::TreeNode> QueryProfiler::CreateTree(PhysicalOperator *root, idx_t depth) {
563: 	if (OperatorRequiresProfiling(root->type)) {
564: 		this->query_requires_profiling = true;
565: 	}
566: 	auto node = make_unique<QueryProfiler::TreeNode>();
567: 	node->type = root->type;
568: 	node->name = root->GetName();
569: 	node->extra_info = root->ParamsToString();
570: 	node->depth = depth;
571: 	tree_map[root] = node.get();
572: 	for (auto &child : root->children) {
573: 		auto child_node = CreateTree(child.get(), depth + 1);
574: 		node->children.push_back(move(child_node));
575: 	}
576: 	switch (root->type) {
577: 	case PhysicalOperatorType::DELIM_JOIN: {
578: 		auto &delim_join = (PhysicalDelimJoin &)*root;
579: 		auto child_node = CreateTree((PhysicalOperator *)delim_join.join.get(), depth + 1);
580: 		node->children.push_back(move(child_node));
581: 		child_node = CreateTree((PhysicalOperator *)delim_join.distinct.get(), depth + 1);
582: 		node->children.push_back(move(child_node));
583: 		break;
584: 	}
585: 	case PhysicalOperatorType::EXECUTE: {
586: 		auto &execute = (PhysicalExecute &)*root;
587: 		auto child_node = CreateTree((PhysicalOperator *)execute.plan, depth + 1);
588: 		node->children.push_back(move(child_node));
589: 		break;
590: 	}
591: 	default:
592: 		break;
593: 	}
594: 	return node;
595: }
596: 
597: void QueryProfiler::Render(const QueryProfiler::TreeNode &node, std::ostream &ss) const {
598: 	TreeRenderer renderer;
599: 	if (IsDetailedEnabled()) {
600: 		renderer.EnableDetailed();
601: 	} else {
602: 		renderer.EnableStandard();
603: 	}
604: 	renderer.Render(node, ss);
605: }
606: 
607: void QueryProfiler::Print() {
608: 	Printer::Print(ToString());
609: }
610: 
611: vector<QueryProfiler::PhaseTimingItem> QueryProfiler::GetOrderedPhaseTimings() const {
612: 	vector<PhaseTimingItem> result;
613: 	// first sort the phases alphabetically
614: 	vector<string> phases;
615: 	for (auto &entry : phase_timings) {
616: 		phases.push_back(entry.first);
617: 	}
618: 	std::sort(phases.begin(), phases.end());
619: 	for (const auto &phase : phases) {
620: 		auto entry = phase_timings.find(phase);
621: 		D_ASSERT(entry != phase_timings.end());
622: 		result.emplace_back(entry->first, entry->second);
623: 	}
624: 	return result;
625: }
626: void QueryProfiler::Propagate(QueryProfiler &qp) {
627: }
628: 
629: void ExpressionInfo::ExtractExpressionsRecursive(unique_ptr<ExpressionState> &state) {
630: 	if (state->child_states.empty()) {
631: 		return;
632: 	}
633: 	// extract the children of this node
634: 	for (auto &child : state->child_states) {
635: 		auto expr_info = make_unique<ExpressionInfo>();
636: 		if (child->expr.expression_class == ExpressionClass::BOUND_FUNCTION) {
637: 			expr_info->hasfunction = true;
638: 			expr_info->function_name = ((BoundFunctionExpression &)child->expr).function.ToString();
639: 			expr_info->function_time = child->profiler.time;
640: 			expr_info->sample_tuples_count = child->profiler.sample_tuples_count;
641: 			expr_info->tuples_count = child->profiler.tuples_count;
642: 		}
643: 		expr_info->ExtractExpressionsRecursive(child);
644: 		children.push_back(move(expr_info));
645: 	}
646: 	return;
647: }
648: 
649: ExpressionExecutorInfo::ExpressionExecutorInfo(ExpressionExecutor &executor, const string &name, int id) : id(id) {
650: 	// Extract Expression Root Information from ExpressionExecutorStats
651: 	for (auto &state : executor.GetStates()) {
652: 		roots.push_back(make_unique<ExpressionRootInfo>(*state, name));
653: 	}
654: }
655: 
656: ExpressionRootInfo::ExpressionRootInfo(ExpressionExecutorState &state, string name)
657:     : current_count(state.profiler.current_count), sample_count(state.profiler.sample_count),
658:       sample_tuples_count(state.profiler.sample_tuples_count), tuples_count(state.profiler.tuples_count),
659:       name(state.name), time(state.profiler.time) {
660: 	// Use the name of expression-tree as extra-info
661: 	extra_info = move(name);
662: 	auto expression_info_p = make_unique<ExpressionInfo>();
663: 	// Maybe root has a function
664: 	if (state.root_state->expr.expression_class == ExpressionClass::BOUND_FUNCTION) {
665: 		expression_info_p->hasfunction = true;
666: 		expression_info_p->function_name = ((BoundFunctionExpression &)state.root_state->expr).function.name;
667: 		expression_info_p->function_time = state.root_state->profiler.time;
668: 		expression_info_p->sample_tuples_count = state.root_state->profiler.sample_tuples_count;
669: 		expression_info_p->tuples_count = state.root_state->profiler.tuples_count;
670: 	}
671: 	expression_info_p->ExtractExpressionsRecursive(state.root_state);
672: 	root = move(expression_info_p);
673: }
674: } // namespace duckdb
[end of src/main/query_profiler.cpp]
[start of src/parser/transform/expression/transform_constant.cpp]
1: #include "duckdb/parser/expression/constant_expression.hpp"
2: #include "duckdb/parser/transformer.hpp"
3: #include "duckdb/common/operator/cast_operators.hpp"
4: #include "duckdb/common/limits.hpp"
5: #include "duckdb/common/types/decimal.hpp"
6: 
7: namespace duckdb {
8: 
9: unique_ptr<ConstantExpression> Transformer::TransformValue(duckdb_libpgquery::PGValue val) {
10: 	switch (val.type) {
11: 	case duckdb_libpgquery::T_PGInteger:
12: 		D_ASSERT(val.val.ival <= NumericLimits<int32_t>::Maximum());
13: 		return make_unique<ConstantExpression>(Value::INTEGER((int32_t)val.val.ival));
14: 	case duckdb_libpgquery::T_PGBitString: // FIXME: this should actually convert to BLOB
15: 	case duckdb_libpgquery::T_PGString:
16: 		return make_unique<ConstantExpression>(Value(string(val.val.str)));
17: 	case duckdb_libpgquery::T_PGFloat: {
18: 		string_t str_val(val.val.str);
19: 		bool try_cast_as_integer = true;
20: 		bool try_cast_as_decimal = true;
21: 		int decimal_position = -1;
22: 		for (idx_t i = 0; i < str_val.GetSize(); i++) {
23: 			if (val.val.str[i] == '.') {
24: 				// decimal point: cast as either decimal or double
25: 				try_cast_as_integer = false;
26: 				decimal_position = i;
27: 			}
28: 			if (val.val.str[i] == 'e' || val.val.str[i] == 'E') {
29: 				// found exponent, cast as double
30: 				try_cast_as_integer = false;
31: 				try_cast_as_decimal = false;
32: 			}
33: 		}
34: 		if (try_cast_as_integer) {
35: 			int64_t bigint_value;
36: 			// try to cast as bigint first
37: 			if (TryCast::Operation<string_t, int64_t>(str_val, bigint_value)) {
38: 				// successfully cast to bigint: bigint value
39: 				return make_unique<ConstantExpression>(Value::BIGINT(bigint_value));
40: 			}
41: 			hugeint_t hugeint_value;
42: 			// if that is not successful; try to cast as hugeint
43: 			if (TryCast::Operation<string_t, hugeint_t>(str_val, hugeint_value)) {
44: 				// successfully cast to bigint: bigint value
45: 				return make_unique<ConstantExpression>(Value::HUGEINT(hugeint_value));
46: 			}
47: 		}
48: 		idx_t decimal_offset = val.val.str[0] == '-' ? 3 : 2;
49: 		if (try_cast_as_decimal && decimal_position >= 0 &&
50: 		    str_val.GetSize() < Decimal::MAX_WIDTH_DECIMAL + decimal_offset) {
51: 			// figure out the width/scale based on the decimal position
52: 			auto width = uint8_t(str_val.GetSize() - 1);
53: 			auto scale = uint8_t(width - decimal_position);
54: 			if (val.val.str[0] == '-') {
55: 				width--;
56: 			}
57: 			if (width <= Decimal::MAX_WIDTH_DECIMAL) {
58: 				// we can cast the value as a decimal
59: 				Value val = Value(str_val);
60: 				val = val.CastAs(LogicalType::DECIMAL(width, scale));
61: 				return make_unique<ConstantExpression>(move(val));
62: 			}
63: 		}
64: 		// if there is a decimal or the value is too big to cast as either hugeint or bigint
65: 		double dbl_value = Cast::Operation<string_t, double>(str_val);
66: 		if (!Value::DoubleIsValid(dbl_value)) {
67: 			throw ParserException("Double value \"%s\" is out of range!", val.val.str);
68: 		}
69: 		return make_unique<ConstantExpression>(Value::DOUBLE(dbl_value));
70: 	}
71: 	case duckdb_libpgquery::T_PGNull:
72: 		return make_unique<ConstantExpression>(Value(LogicalType::SQLNULL));
73: 	default:
74: 		throw NotImplementedException("Value not implemented!");
75: 	}
76: }
77: 
78: unique_ptr<ParsedExpression> Transformer::TransformConstant(duckdb_libpgquery::PGAConst *c) {
79: 	return TransformValue(c->val);
80: }
81: 
82: } // namespace duckdb
[end of src/parser/transform/expression/transform_constant.cpp]
[start of tools/pythonpkg/src/vector_conversion.cpp]
1: #include "duckdb_python/vector_conversion.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/common/types/timestamp.hpp"
4: #include "utf8proc_wrapper.hpp"
5: 
6: namespace duckdb {
7: 
8: template <class T>
9: void ScanPandasColumn(py::array &numpy_col, idx_t stride, idx_t offset, Vector &out, idx_t count) {
10: 	auto src_ptr = (T *)numpy_col.data();
11: 	if (stride == sizeof(T)) {
12: 		FlatVector::SetData(out, (data_ptr_t)(src_ptr + offset));
13: 	} else {
14: 		auto tgt_ptr = (T *)FlatVector::GetData(out);
15: 		for (idx_t i = 0; i < count; i++) {
16: 			tgt_ptr[i] = src_ptr[stride / sizeof(T) * (i + offset)];
17: 		}
18: 	}
19: }
20: 
21: template <class T, class V>
22: void ScanPandasCategoryTemplated(py::array &column, idx_t offset, Vector &out, idx_t count) {
23: 	auto src_ptr = (T *)column.data();
24: 	auto tgt_ptr = (V *)FlatVector::GetData(out);
25: 	auto &tgt_mask = FlatVector::Validity(out);
26: 	for (idx_t i = 0; i < count; i++) {
27: 		if (src_ptr[i + offset] == -1) {
28: 			// Null value
29: 			tgt_mask.SetInvalid(i);
30: 		} else {
31: 			tgt_ptr[i] = src_ptr[i + offset];
32: 		}
33: 	}
34: }
35: 
36: template <class T>
37: void ScanPandasCategory(py::array &column, idx_t count, idx_t offset, Vector &out, string &src_type) {
38: 	if (src_type == "int8") {
39: 		ScanPandasCategoryTemplated<int8_t, T>(column, offset, out, count);
40: 	} else if (src_type == "int16") {
41: 		ScanPandasCategoryTemplated<int16_t, T>(column, offset, out, count);
42: 	} else if (src_type == "int32") {
43: 		ScanPandasCategoryTemplated<int32_t, T>(column, offset, out, count);
44: 	} else {
45: 		throw NotImplementedException("The Pandas type " + src_type + " for categorical types is not implemented yet");
46: 	}
47: }
48: 
49: template <class T>
50: void ScanPandasNumeric(PandasColumnBindData &bind_data, idx_t count, idx_t offset, Vector &out) {
51: 	ScanPandasColumn<T>(bind_data.numpy_col, bind_data.numpy_stride, offset, out, count);
52: 	auto &result_mask = FlatVector::Validity(out);
53: 	if (bind_data.mask) {
54: 		auto mask = (bool *)bind_data.mask->numpy_array.data();
55: 		for (idx_t i = 0; i < count; i++) {
56: 			auto is_null = mask[offset + i];
57: 			if (is_null) {
58: 				result_mask.SetInvalid(i);
59: 			}
60: 		}
61: 	}
62: }
63: 
64: template <class T>
65: bool ValueIsNull(T value) {
66: 	throw std::runtime_error("unsupported type for ValueIsNull");
67: }
68: 
69: template <>
70: bool ValueIsNull(float value) {
71: 	return !Value::FloatIsValid(value);
72: }
73: 
74: template <>
75: bool ValueIsNull(double value) {
76: 	return !Value::DoubleIsValid(value);
77: }
78: 
79: template <class T>
80: void ScanPandasFpColumn(T *src_ptr, idx_t count, idx_t offset, Vector &out) {
81: 	FlatVector::SetData(out, (data_ptr_t)(src_ptr + offset));
82: 	auto tgt_ptr = FlatVector::GetData<T>(out);
83: 	auto &mask = FlatVector::Validity(out);
84: 	for (idx_t i = 0; i < count; i++) {
85: 		if (ValueIsNull(tgt_ptr[i])) {
86: 			mask.SetInvalid(i);
87: 		}
88: 	}
89: }
90: 
91: template <class T>
92: static string_t DecodePythonUnicode(T *codepoints, idx_t codepoint_count, Vector &out) {
93: 	// first figure out how many bytes to allocate
94: 	idx_t utf8_length = 0;
95: 	for (idx_t i = 0; i < codepoint_count; i++) {
96: 		int len = Utf8Proc::CodepointLength(int(codepoints[i]));
97: 		D_ASSERT(len >= 1);
98: 		utf8_length += len;
99: 	}
100: 	int sz;
101: 	auto result = StringVector::EmptyString(out, utf8_length);
102: 	auto target = result.GetDataWriteable();
103: 	for (idx_t i = 0; i < codepoint_count; i++) {
104: 		Utf8Proc::CodepointToUtf8(int(codepoints[i]), sz, target);
105: 		D_ASSERT(sz >= 1);
106: 		target += sz;
107: 	}
108: 	result.Finalize();
109: 	return result;
110: }
111: 
112: void VectorConversion::NumpyToDuckDB(PandasColumnBindData &bind_data, py::array &numpy_col, idx_t count, idx_t offset,
113:                                      Vector &out) {
114: 	switch (bind_data.pandas_type) {
115: 	case PandasType::BOOLEAN:
116: 		ScanPandasColumn<bool>(numpy_col, bind_data.numpy_stride, offset, out, count);
117: 		break;
118: 	case PandasType::UTINYINT:
119: 		ScanPandasNumeric<uint8_t>(bind_data, count, offset, out);
120: 		break;
121: 	case PandasType::USMALLINT:
122: 		ScanPandasNumeric<uint16_t>(bind_data, count, offset, out);
123: 		break;
124: 	case PandasType::UINTEGER:
125: 		ScanPandasNumeric<uint32_t>(bind_data, count, offset, out);
126: 		break;
127: 	case PandasType::UBIGINT:
128: 		ScanPandasNumeric<uint64_t>(bind_data, count, offset, out);
129: 		break;
130: 	case PandasType::TINYINT:
131: 		ScanPandasNumeric<int8_t>(bind_data, count, offset, out);
132: 		break;
133: 	case PandasType::SMALLINT:
134: 		ScanPandasNumeric<int16_t>(bind_data, count, offset, out);
135: 		break;
136: 	case PandasType::INTEGER:
137: 		ScanPandasNumeric<int32_t>(bind_data, count, offset, out);
138: 		break;
139: 	case PandasType::BIGINT:
140: 		ScanPandasNumeric<int64_t>(bind_data, count, offset, out);
141: 		break;
142: 	case PandasType::FLOAT:
143: 		ScanPandasFpColumn<float>((float *)numpy_col.data(), count, offset, out);
144: 		break;
145: 	case PandasType::DOUBLE:
146: 		ScanPandasFpColumn<double>((double *)numpy_col.data(), count, offset, out);
147: 		break;
148: 	case PandasType::TIMESTAMP: {
149: 		auto src_ptr = (int64_t *)numpy_col.data();
150: 		auto tgt_ptr = FlatVector::GetData<timestamp_t>(out);
151: 		auto &mask = FlatVector::Validity(out);
152: 
153: 		for (idx_t row = 0; row < count; row++) {
154: 			auto source_idx = offset + row;
155: 			if (src_ptr[source_idx] <= NumericLimits<int64_t>::Minimum()) {
156: 				// pandas Not a Time (NaT)
157: 				mask.SetInvalid(row);
158: 				continue;
159: 			}
160: 			tgt_ptr[row] = Timestamp::FromEpochNanoSeconds(src_ptr[source_idx]);
161: 		}
162: 		break;
163: 	}
164: 	case PandasType::INTERVAL: {
165: 		auto src_ptr = (int64_t *)numpy_col.data();
166: 		auto tgt_ptr = FlatVector::GetData<interval_t>(out);
167: 		auto &mask = FlatVector::Validity(out);
168: 
169: 		for (idx_t row = 0; row < count; row++) {
170: 			auto source_idx = offset + row;
171: 			if (src_ptr[source_idx] <= NumericLimits<int64_t>::Minimum()) {
172: 				// pandas Not a Time (NaT)
173: 				mask.SetInvalid(row);
174: 				continue;
175: 			}
176: 			int64_t micro = src_ptr[source_idx] / 1000;
177: 			int64_t days = micro / Interval::MICROS_PER_DAY;
178: 			micro = micro % Interval::MICROS_PER_DAY;
179: 			int64_t months = days / Interval::DAYS_PER_MONTH;
180: 			days = days % Interval::DAYS_PER_MONTH;
181: 			interval_t interval;
182: 			interval.months = months;
183: 			interval.days = days;
184: 			interval.micros = micro;
185: 			tgt_ptr[row] = interval;
186: 		}
187: 		break;
188: 	}
189: 	case PandasType::VARCHAR:
190: 	case PandasType::OBJECT: {
191: 		auto src_ptr = (PyObject **)numpy_col.data();
192: 		auto tgt_ptr = FlatVector::GetData<string_t>(out);
193: 		auto &out_mask = FlatVector::Validity(out);
194: 		unique_ptr<PythonGILWrapper> gil;
195: 		for (idx_t row = 0; row < count; row++) {
196: 			auto source_idx = offset + row;
197: 			PyObject *val = src_ptr[source_idx];
198: 			if (bind_data.pandas_type == PandasType::OBJECT && !PyUnicode_CheckExact(val)) {
199: 				if (val == Py_None) {
200: 					out_mask.SetInvalid(row);
201: 					continue;
202: 				}
203: 				if (py::isinstance<py::float_>(val) && std::isnan(PyFloat_AsDouble(val))) {
204: 					out_mask.SetInvalid(row);
205: 					continue;
206: 				}
207: 				if (!py::isinstance<py::str>(val)) {
208: 					if (!gil) {
209: 						gil = bind_data.object_str_val.GetLock();
210: 					}
211: 					bind_data.object_str_val.AssignInternal<PyObject>(
212: 					    [](py::str &obj, PyObject &new_val) {
213: 						    py::handle object_handle = &new_val;
214: 						    obj = py::str(object_handle);
215: 					    },
216: 					    *val, *gil);
217: 					val = (PyObject *)bind_data.object_str_val.GetPointerTop()->ptr();
218: 				}
219: 			}
220: 			// Python 3 string representation:
221: 			// https://github.com/python/cpython/blob/3a8fdb28794b2f19f6c8464378fb8b46bce1f5f4/Include/cpython/unicodeobject.h#L79
222: 			if (!PyUnicode_CheckExact(val)) {
223: 				out_mask.SetInvalid(row);
224: 				continue;
225: 			}
226: 			if (PyUnicode_IS_COMPACT_ASCII(val)) {
227: 				// ascii string: we can zero copy
228: 				tgt_ptr[row] = string_t((const char *)PyUnicode_DATA(val), PyUnicode_GET_LENGTH(val));
229: 			} else {
230: 				// unicode gunk
231: 				auto ascii_obj = (PyASCIIObject *)val;
232: 				auto unicode_obj = (PyCompactUnicodeObject *)val;
233: 				// compact unicode string: is there utf8 data available?
234: 				if (unicode_obj->utf8) {
235: 					// there is! zero copy
236: 					tgt_ptr[row] = string_t((const char *)unicode_obj->utf8, unicode_obj->utf8_length);
237: 				} else if (PyUnicode_IS_COMPACT(unicode_obj) && !PyUnicode_IS_ASCII(unicode_obj)) {
238: 					auto kind = PyUnicode_KIND(val);
239: 					switch (kind) {
240: 					case PyUnicode_1BYTE_KIND:
241: 						tgt_ptr[row] =
242: 						    DecodePythonUnicode<Py_UCS1>(PyUnicode_1BYTE_DATA(val), PyUnicode_GET_LENGTH(val), out);
243: 						break;
244: 					case PyUnicode_2BYTE_KIND:
245: 						tgt_ptr[row] =
246: 						    DecodePythonUnicode<Py_UCS2>(PyUnicode_2BYTE_DATA(val), PyUnicode_GET_LENGTH(val), out);
247: 						break;
248: 					case PyUnicode_4BYTE_KIND:
249: 						tgt_ptr[row] =
250: 						    DecodePythonUnicode<Py_UCS4>(PyUnicode_4BYTE_DATA(val), PyUnicode_GET_LENGTH(val), out);
251: 						break;
252: 					default:
253: 						throw std::runtime_error("Unsupported typekind for Python Unicode Compact decode");
254: 					}
255: 				} else if (ascii_obj->state.kind == PyUnicode_WCHAR_KIND) {
256: 					throw std::runtime_error("Unsupported: decode not ready legacy string");
257: 				} else if (!PyUnicode_IS_COMPACT(unicode_obj) && ascii_obj->state.kind != PyUnicode_WCHAR_KIND) {
258: 					throw std::runtime_error("Unsupported: decode ready legacy string");
259: 				} else {
260: 					throw std::runtime_error("Unsupported string type: no clue what this string is");
261: 				}
262: 			}
263: 		}
264: 		break;
265: 	}
266: 	case PandasType::CATEGORY: {
267: 		switch (out.GetType().InternalType()) {
268: 		case PhysicalType::UINT8:
269: 			ScanPandasCategory<uint8_t>(numpy_col, count, offset, out, bind_data.internal_categorical_type);
270: 			break;
271: 		case PhysicalType::UINT16:
272: 			ScanPandasCategory<uint16_t>(numpy_col, count, offset, out, bind_data.internal_categorical_type);
273: 			break;
274: 		case PhysicalType::UINT32:
275: 			ScanPandasCategory<uint32_t>(numpy_col, count, offset, out, bind_data.internal_categorical_type);
276: 			break;
277: 		default:
278: 			throw InternalException("Invalid Physical Type for ENUMs");
279: 		}
280: 		break;
281: 	}
282: 
283: 	default:
284: 		throw std::runtime_error("Unsupported type " + out.GetType().ToString());
285: 	}
286: }
287: 
288: static void ConvertPandasType(const string &col_type, LogicalType &duckdb_col_type, PandasType &pandas_type) {
289: 	if (col_type == "bool") {
290: 		duckdb_col_type = LogicalType::BOOLEAN;
291: 		pandas_type = PandasType::BOOLEAN;
292: 	} else if (col_type == "uint8" || col_type == "Uint8") {
293: 		duckdb_col_type = LogicalType::UTINYINT;
294: 		pandas_type = PandasType::UTINYINT;
295: 	} else if (col_type == "uint16" || col_type == "Uint16") {
296: 		duckdb_col_type = LogicalType::USMALLINT;
297: 		pandas_type = PandasType::USMALLINT;
298: 	} else if (col_type == "uint32" || col_type == "Uint32") {
299: 		duckdb_col_type = LogicalType::UINTEGER;
300: 		pandas_type = PandasType::UINTEGER;
301: 	} else if (col_type == "uint64" || col_type == "Uint64") {
302: 		duckdb_col_type = LogicalType::UBIGINT;
303: 		pandas_type = PandasType::UBIGINT;
304: 	} else if (col_type == "int8" || col_type == "Int8") {
305: 		duckdb_col_type = LogicalType::TINYINT;
306: 		pandas_type = PandasType::TINYINT;
307: 	} else if (col_type == "int16" || col_type == "Int16") {
308: 		duckdb_col_type = LogicalType::SMALLINT;
309: 		pandas_type = PandasType::SMALLINT;
310: 	} else if (col_type == "int32" || col_type == "Int32") {
311: 		duckdb_col_type = LogicalType::INTEGER;
312: 		pandas_type = PandasType::INTEGER;
313: 	} else if (col_type == "int64" || col_type == "Int64") {
314: 		duckdb_col_type = LogicalType::BIGINT;
315: 		pandas_type = PandasType::BIGINT;
316: 	} else if (col_type == "float32") {
317: 		duckdb_col_type = LogicalType::FLOAT;
318: 		pandas_type = PandasType::FLOAT;
319: 	} else if (col_type == "float64") {
320: 		duckdb_col_type = LogicalType::DOUBLE;
321: 		pandas_type = PandasType::DOUBLE;
322: 	} else if (col_type == "object") {
323: 		//! this better be castable to strings
324: 		duckdb_col_type = LogicalType::VARCHAR;
325: 		pandas_type = PandasType::OBJECT;
326: 	} else if (col_type == "string") {
327: 		duckdb_col_type = LogicalType::VARCHAR;
328: 		pandas_type = PandasType::VARCHAR;
329: 	} else if (col_type == "timedelta64[ns]") {
330: 		duckdb_col_type = LogicalType::INTERVAL;
331: 		pandas_type = PandasType::INTERVAL;
332: 	} else {
333: 		throw std::runtime_error("unsupported python type " + col_type);
334: 	}
335: }
336: 
337: void VectorConversion::BindPandas(py::handle original_df, vector<PandasColumnBindData> &bind_columns,
338:                                   vector<LogicalType> &return_types, vector<string> &names) {
339: 	// This performs a shallow copy that allows us to rename the dataframe
340: 	auto df = original_df.attr("copy")(false);
341: 	auto df_columns = py::list(df.attr("columns"));
342: 	auto df_types = py::list(df.attr("dtypes"));
343: 	auto get_fun = df.attr("__getitem__");
344: 	// TODO support masked arrays as well
345: 	// TODO support dicts of numpy arrays as well
346: 	if (py::len(df_columns) == 0 || py::len(df_types) == 0 || py::len(df_columns) != py::len(df_types)) {
347: 		throw std::runtime_error("Need a DataFrame with at least one column");
348: 	}
349: 
350: 	// check if names in pandas dataframe are unique
351: 	unordered_map<string, idx_t> pandas_column_names_map;
352: 	py::array column_attributes = df.attr("columns").attr("values");
353: 	for (idx_t col_idx = 0; col_idx < py::len(df_columns); col_idx++) {
354: 		auto column_name_py = py::str(df_columns[col_idx]);
355: 		pandas_column_names_map[column_name_py]++;
356: 		if (pandas_column_names_map[column_name_py] > 1) {
357: 			// If the column name is repeated we start adding _x where x is the repetition number
358: 			string column_name = column_name_py;
359: 			column_name += "_" + to_string(pandas_column_names_map[column_name_py] - 1);
360: 			auto new_column_name_py = py::str(column_name);
361: 			names.emplace_back(new_column_name_py);
362: 			column_attributes[py::cast(col_idx)] = new_column_name_py;
363: 			pandas_column_names_map[new_column_name_py]++;
364: 		} else {
365: 			names.emplace_back(column_name_py);
366: 		}
367: 	}
368: 
369: 	for (idx_t col_idx = 0; col_idx < py::len(df_columns); col_idx++) {
370: 		LogicalType duckdb_col_type;
371: 		PandasColumnBindData bind_data;
372: 		auto col_type = string(py::str(df_types[col_idx]));
373: 		if (col_type == "Int8" || col_type == "Int16" || col_type == "Int32" || col_type == "Int64") {
374: 			// numeric object
375: 			// fetch the internal data and mask array
376: 			bind_data.numpy_col = get_fun(df_columns[col_idx]).attr("array").attr("_data");
377: 			bind_data.mask = make_unique<NumPyArrayWrapper>(get_fun(df_columns[col_idx]).attr("array").attr("_mask"));
378: 			ConvertPandasType(col_type, duckdb_col_type, bind_data.pandas_type);
379: 		} else if (StringUtil::StartsWith(col_type, "datetime64[ns") || col_type == "<M8[ns]") {
380: 			// timestamp type
381: 			bind_data.numpy_col = get_fun(df_columns[col_idx]).attr("array").attr("_data");
382: 			bind_data.mask = nullptr;
383: 			duckdb_col_type = LogicalType::TIMESTAMP;
384: 			bind_data.pandas_type = PandasType::TIMESTAMP;
385: 		} else {
386: 			// regular type
387: 			auto column = get_fun(df_columns[col_idx]);
388: 			if (col_type == "category") {
389: 				// for category types, we create an ENUM type for string or use the converted numpy type for the rest
390: 				D_ASSERT(py::hasattr(column, "cat"));
391: 				D_ASSERT(py::hasattr(column.attr("cat"), "categories"));
392: 				auto categories = py::array(column.attr("cat").attr("categories"));
393: 				auto category_type = string(py::str(categories.attr("dtype")));
394: 				if (category_type == "object") {
395: 					// Let's hope the object type is a string.
396: 					bind_data.pandas_type = PandasType::CATEGORY;
397: 					auto enum_name = string(py::str(df_columns[col_idx]));
398: 					vector<string> enum_entries = py::cast<vector<string>>(categories);
399: 					idx_t size = enum_entries.size();
400: 					Vector enum_entries_vec(LogicalType::VARCHAR, size);
401: 					auto enum_entries_ptr = FlatVector::GetData<string_t>(enum_entries_vec);
402: 					for (idx_t i = 0; i < size; i++) {
403: 						enum_entries_ptr[i] = StringVector::AddStringOrBlob(enum_entries_vec, enum_entries[i]);
404: 					}
405: 					D_ASSERT(py::hasattr(column.attr("cat"), "codes"));
406: 					duckdb_col_type = LogicalType::ENUM(enum_name, enum_entries_vec, size);
407: 					bind_data.numpy_col = py::array(column.attr("cat").attr("codes"));
408: 					bind_data.mask = nullptr;
409: 					D_ASSERT(py::hasattr(bind_data.numpy_col, "dtype"));
410: 					bind_data.internal_categorical_type = string(py::str(bind_data.numpy_col.attr("dtype")));
411: 				} else {
412: 					bind_data.numpy_col = py::array(column.attr("to_numpy")());
413: 					bind_data.mask = nullptr;
414: 					auto numpy_type = bind_data.numpy_col.attr("dtype");
415: 					// for category types (non-strings), we use the converted numpy type
416: 					category_type = string(py::str(numpy_type));
417: 					ConvertPandasType(category_type, duckdb_col_type, bind_data.pandas_type);
418: 				}
419: 			} else {
420: 				bind_data.numpy_col = py::array(column.attr("to_numpy")());
421: 				bind_data.mask = nullptr;
422: 				ConvertPandasType(col_type, duckdb_col_type, bind_data.pandas_type);
423: 			}
424: 		}
425: 		D_ASSERT(py::hasattr(bind_data.numpy_col, "strides"));
426: 		bind_data.numpy_stride = bind_data.numpy_col.attr("strides").attr("__getitem__")(0).cast<idx_t>();
427: 		return_types.push_back(duckdb_col_type);
428: 		bind_columns.push_back(move(bind_data));
429: 	}
430: }
431: } // namespace duckdb
[end of tools/pythonpkg/src/vector_conversion.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: