diff --git a/src/common/CMakeLists.txt b/src/common/CMakeLists.txt
index bb0ecad28593..3157188e6ec0 100644
--- a/src/common/CMakeLists.txt
+++ b/src/common/CMakeLists.txt
@@ -21,6 +21,7 @@ add_library_unity(
   file_buffer.cpp
   file_system.cpp
   gzip_file_system.cpp
+  pipe_file_system.cpp
   limits.cpp
   printer.cpp
   progress_bar.cpp
diff --git a/src/common/file_system.cpp b/src/common/file_system.cpp
index 52b61dd16fda..628318748afc 100644
--- a/src/common/file_system.cpp
+++ b/src/common/file_system.cpp
@@ -3,6 +3,7 @@
 #include "duckdb/common/checksum.hpp"
 #include "duckdb/common/exception.hpp"
 #include "duckdb/common/gzip_file_system.hpp"
+#include "duckdb/common/pipe_file_system.hpp"
 #include "duckdb/common/helper.hpp"
 #include "duckdb/common/string_util.hpp"
 #include "duckdb/function/scalar/string_functions.hpp"
@@ -227,6 +228,32 @@ time_t FileSystem::GetLastModifiedTime(FileHandle &handle) {
 	return s.st_mtime;
 }
 
+FileType FileSystem::GetFileType(FileHandle &handle) {
+	int fd = ((UnixFileHandle &)handle).fd;
+	struct stat s;
+	if (fstat(fd, &s) == -1) {
+		return FileType::FILE_TYPE_INVALID;
+	}
+	switch (s.st_mode & S_IFMT) {
+	case S_IFBLK:
+		return FileType::FILE_TYPE_BLOCKDEV;
+	case S_IFCHR:
+		return FileType::FILE_TYPE_CHARDEV;
+	case S_IFIFO:
+		return FileType::FILE_TYPE_FIFO;
+	case S_IFDIR:
+		return FileType::FILE_TYPE_DIR;
+	case S_IFLNK:
+		return FileType::FILE_TYPE_LINK;
+	case S_IFREG:
+		return FileType::FILE_TYPE_REGULAR;
+	case S_IFSOCK:
+		return FileType::FILE_TYPE_SOCKET;
+	default:
+		return FileType::FILE_TYPE_INVALID;
+	}
+}
+
 void FileSystem::Truncate(FileHandle &handle, int64_t new_size) {
 	int fd = ((UnixFileHandle &)handle).fd;
 	if (ftruncate(fd, new_size) != 0) {
@@ -402,6 +429,8 @@ string FileSystem::GetWorkingDirectory() {
 }
 #else
 
+constexpr char PIPE_PREFIX[] = "\\\\.\\pipe\\";
+
 // Returns the last Win32 error, in string format. Returns an empty string if there is no error.
 std::string GetLastErrorAsString() {
 	// Get the error message, if any.
@@ -765,6 +794,23 @@ string FileSystem::GetWorkingDirectory() {
 	}
 	return string(buffer.get(), ret);
 }
+
+FileType FileSystem::GetFileType(FileHandle &handle) {
+	auto path = ((WindowsFileHandle &)handle).path;
+	// pipes in windows are just files in '\\.\pipe\' folder
+	if (strncmp(path.c_str(), PIPE_PREFIX, strlen(PIPE_PREFIX)) == 0) {
+		return FileType::FILE_TYPE_FIFO;
+	}
+	DWORD attrs = GetFileAttributesA(path.c_str());
+	if (attrs != INVALID_FILE_ATTRIBUTES) {
+		if (attrs & FILE_ATTRIBUTE_DIRECTORY) {
+			return FileType::FILE_TYPE_DIR;
+		} else {
+			return FileType::FILE_TYPE_REGULAR;
+		}
+	}
+	return FileType::FILE_TYPE_INVALID;
+}
 #endif
 
 string FileSystem::GetHomeDirectory() {
@@ -891,6 +937,10 @@ void FileHandle::Truncate(int64_t new_size) {
 	file_system.Truncate(*this, new_size);
 }
 
+FileType FileHandle::GetType() {
+	return file_system.GetFileType(*this);
+}
+
 static bool HasGlob(const string &str) {
 	for (idx_t i = 0; i < str.size(); i++) {
 		switch (str[i]) {
@@ -1022,7 +1072,9 @@ unique_ptr<FileHandle> VirtualFileSystem::OpenFile(const string &path, uint8_t f
 	}
 	// open the base file handle
 	auto file_handle = FindFileSystem(path)->OpenFile(path, flags, lock, FileCompressionType::UNCOMPRESSED);
-	if (compression != FileCompressionType::UNCOMPRESSED) {
+	if (file_handle->GetType() == FileType::FILE_TYPE_FIFO) {
+		file_handle = PipeFileSystem::OpenPipe(move(file_handle));
+	} else if (compression != FileCompressionType::UNCOMPRESSED) {
 		switch (compression) {
 		case FileCompressionType::GZIP:
 			file_handle = GZipFileSystem::OpenCompressedFile(move(file_handle));
diff --git a/src/common/pipe_file_system.cpp b/src/common/pipe_file_system.cpp
new file mode 100644
index 000000000000..5e837c66c112
--- /dev/null
+++ b/src/common/pipe_file_system.cpp
@@ -0,0 +1,73 @@
+#include "duckdb/common/pipe_file_system.hpp"
+#include "duckdb/common/exception.hpp"
+#include "duckdb/common/file_system.hpp"
+
+namespace duckdb {
+class PipeFile : public FileHandle {
+public:
+	PipeFile(unique_ptr<FileHandle> child_handle_p, const string &path)
+	    : FileHandle(pipe_fs, path), child_handle(move(child_handle_p)) {
+	}
+
+	int64_t ReadChunk(void *buffer, int64_t nr_bytes);
+	int64_t WriteChunk(void *buffer, int64_t nr_bytes);
+
+	PipeFileSystem pipe_fs;
+	unique_ptr<FileHandle> child_handle;
+
+protected:
+	void Close() override {
+	}
+};
+
+int64_t PipeFile::ReadChunk(void *buffer, int64_t nr_bytes) {
+	return child_handle->Read(buffer, nr_bytes);
+}
+int64_t PipeFile::WriteChunk(void *buffer, int64_t nr_bytes) {
+	return child_handle->Write(buffer, nr_bytes);
+}
+
+void PipeFileSystem::Read(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location) {
+	throw NotImplementedException("Unsupported: Random read from pipe/stream");
+}
+
+int64_t PipeFileSystem::Read(FileHandle &handle, void *buffer, int64_t nr_bytes) {
+	auto &pipe = (PipeFile &)handle;
+	return pipe.ReadChunk(buffer, nr_bytes);
+}
+
+void PipeFileSystem::Write(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location) {
+	throw NotImplementedException("Unsupported: Random write to pipe/stream");
+}
+
+int64_t PipeFileSystem::Write(FileHandle &handle, void *buffer, int64_t nr_bytes) {
+	auto &pipe = (PipeFile &)handle;
+	return pipe.WriteChunk(buffer, nr_bytes);
+}
+
+void PipeFileSystem::Truncate(FileHandle &handle, int64_t new_size) {
+	throw NotImplementedException("Unsupported: Truncate pipe/stream");
+}
+
+void PipeFileSystem::FileSync(FileHandle &handle) {
+	throw NotImplementedException("Unsupported: Sync pipe/stream");
+}
+
+void PipeFileSystem::Seek(FileHandle &handle, idx_t location) {
+	throw NotImplementedException("Unsupported: Seek within pipe/stream");
+}
+
+void PipeFileSystem::Reset(FileHandle &handle) {
+	throw NotImplementedException("Unsupported: Reset pipe/stream");
+}
+
+int64_t PipeFileSystem::GetFileSize(FileHandle &handle) {
+	return 0;
+}
+
+unique_ptr<FileHandle> PipeFileSystem::OpenPipe(unique_ptr<FileHandle> handle) {
+	auto path = handle->path;
+	return make_unique<PipeFile>(move(handle), path);
+}
+
+} // namespace duckdb
diff --git a/src/include/duckdb/common/file_system.hpp b/src/include/duckdb/common/file_system.hpp
index 42b56a3b3d0b..5aaa179bd5e0 100644
--- a/src/include/duckdb/common/file_system.hpp
+++ b/src/include/duckdb/common/file_system.hpp
@@ -26,6 +26,25 @@ class ClientContext;
 class DatabaseInstance;
 class FileSystem;
 
+enum class FileType {
+	//! Regular file
+	FILE_TYPE_REGULAR,
+	//! Directory
+	FILE_TYPE_DIR,
+	//! FIFO named pipe
+	FILE_TYPE_FIFO,
+	//! Socket
+	FILE_TYPE_SOCKET,
+	//! Symbolic link
+	FILE_TYPE_LINK,
+	//! Block device
+	FILE_TYPE_BLOCKDEV,
+	//! Character device
+	FILE_TYPE_CHARDEV,
+	//! Unknown or invalid file handle
+	FILE_TYPE_INVALID,
+};
+
 struct FileHandle {
 public:
 	FileHandle(FileSystem &file_system, string path) : file_system(file_system), path(path) {
@@ -48,6 +67,7 @@ struct FileHandle {
 	bool CanSeek();
 	bool OnDiskFile();
 	idx_t GetFileSize();
+	FileType GetType();
 
 protected:
 	virtual void Close() = 0;
@@ -104,6 +124,8 @@ class FileSystem {
 	virtual int64_t GetFileSize(FileHandle &handle);
 	//! Returns the file last modified time of a file handle, returns timespec with zero on all attributes on error
 	virtual time_t GetLastModifiedTime(FileHandle &handle);
+	//! Returns the file last modified time of a file handle, returns timespec with zero on all attributes on error
+	virtual FileType GetFileType(FileHandle &handle);
 	//! Truncate a file to a maximum size of new_size, new_size should be smaller than or equal to the current size of
 	//! the file
 	virtual void Truncate(FileHandle &handle, int64_t new_size);
@@ -203,6 +225,9 @@ class VirtualFileSystem : public FileSystem {
 	time_t GetLastModifiedTime(FileHandle &handle) override {
 		return handle.file_system.GetLastModifiedTime(handle);
 	}
+	FileType GetFileType(FileHandle &handle) override {
+		return handle.file_system.GetFileType(handle);
+	}
 
 	void Truncate(FileHandle &handle, int64_t new_size) override {
 		handle.file_system.Truncate(handle, new_size);
diff --git a/src/include/duckdb/common/pipe_file_system.hpp b/src/include/duckdb/common/pipe_file_system.hpp
new file mode 100644
index 000000000000..f0161b08f844
--- /dev/null
+++ b/src/include/duckdb/common/pipe_file_system.hpp
@@ -0,0 +1,40 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// duckdb/common/pipe_file_system.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include "duckdb/common/file_system.hpp"
+
+namespace duckdb {
+
+class PipeFileSystem : public FileSystem {
+public:
+	static unique_ptr<FileHandle> OpenPipe(unique_ptr<FileHandle> handle);
+
+	void Read(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location) override;
+	int64_t Read(FileHandle &handle, void *buffer, int64_t nr_bytes) override;
+	void Write(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location) override;
+	int64_t Write(FileHandle &handle, void *buffer, int64_t nr_bytes) override;
+
+	// unsupported operations
+	void Truncate(FileHandle &handle, int64_t new_size) override;
+	void FileSync(FileHandle &handle) override;
+	void Seek(FileHandle &handle, idx_t location) override;
+	void Reset(FileHandle &handle) override;
+
+	int64_t GetFileSize(FileHandle &handle) override;
+
+	bool OnDiskFile(FileHandle &handle) override {
+		return false;
+	};
+	bool CanSeek() override {
+		return false;
+	}
+};
+
+} // namespace duckdb
