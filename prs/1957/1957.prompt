You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Feature: support read_csv_auto reading from the '/dev/stdin' file
The duckdb CLI command can read from a file using read_csv_auto():

```bash
duckdb mydb "create table mytable as select * from read_csv_auto('mydata.csv', HEADER=TRUE);"
```

When I try to send the same data to the /dev/stdin file and have duckdb load it from there, it fails:

```bash
cat mydata.csv | duckdb mydb "create table mytable as select * from read_csv_auto('/dev/stdin', HEADER=TRUE);" 
```

The error is:

```bash
Error: Invalid Input Error: Error in file "/dev/stdin": CSV options could not be auto-detected. Consider setting parser options manually.
```

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![codecov](https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN)](https://codecov.io/gh/duckdb/duckdb)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/common/CMakeLists.txt]
1: add_subdirectory(crypto)
2: add_subdirectory(enums)
3: add_subdirectory(operator)
4: add_subdirectory(row_operations)
5: add_subdirectory(serializer)
6: add_subdirectory(types)
7: add_subdirectory(value_operations)
8: add_subdirectory(vector_operations)
9: 
10: add_library_unity(
11:   duckdb_common
12:   OBJECT
13:   allocator.cpp
14:   arrow_wrapper.cpp
15:   assert.cpp
16:   bit_operations.cpp
17:   constants.cpp
18:   checksum.cpp
19:   exception.cpp
20:   exception_format_value.cpp
21:   file_buffer.cpp
22:   file_system.cpp
23:   gzip_file_system.cpp
24:   limits.cpp
25:   printer.cpp
26:   progress_bar.cpp
27:   serializer.cpp
28:   string_util.cpp
29:   symbols.cpp
30:   tree_renderer.cpp
31:   types.cpp
32:   fstream_util.cpp
33:   cycle_counter.cpp)
34: set(ALL_OBJECT_FILES
35:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_common>
36:     PARENT_SCOPE)
[end of src/common/CMakeLists.txt]
[start of src/common/file_system.cpp]
1: #include "duckdb/common/file_system.hpp"
2: 
3: #include "duckdb/common/checksum.hpp"
4: #include "duckdb/common/exception.hpp"
5: #include "duckdb/common/gzip_file_system.hpp"
6: #include "duckdb/common/helper.hpp"
7: #include "duckdb/common/string_util.hpp"
8: #include "duckdb/function/scalar/string_functions.hpp"
9: #include "duckdb/main/client_context.hpp"
10: #include "duckdb/main/database.hpp"
11: 
12: #include <cstdint>
13: #include <cstdio>
14: 
15: #ifndef _WIN32
16: #include <dirent.h>
17: #include <fcntl.h>
18: #include <string.h>
19: #include <sys/stat.h>
20: #include <sys/types.h>
21: #include <unistd.h>
22: #else
23: #include <string>
24: #ifndef NOMINMAX
25: #define NOMINMAX
26: #endif
27: #include <windows.h>
28: 
29: #ifdef __MINGW32__
30: // need to manually define this for mingw
31: extern "C" WINBASEAPI BOOL WINAPI GetPhysicallyInstalledSystemMemory(PULONGLONG);
32: #endif
33: 
34: #undef CreateDirectory
35: #undef MoveFile
36: #undef RemoveDirectory
37: #undef FILE_CREATE // woo mingw
38: #endif
39: 
40: namespace duckdb {
41: 
42: FileSystem &FileSystem::GetFileSystem(ClientContext &context) {
43: 	return *context.db->config.file_system;
44: }
45: 
46: static void AssertValidFileFlags(uint8_t flags) {
47: 	// cannot combine Read and Write flags
48: 	D_ASSERT(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_WRITE));
49: 	// cannot combine Read and CREATE/Append flags
50: 	D_ASSERT(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_APPEND));
51: 	D_ASSERT(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_FILE_CREATE));
52: 	D_ASSERT(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW));
53: 	// cannot combine CREATE and CREATE_NEW flags
54: 	D_ASSERT(!(flags & FileFlags::FILE_FLAGS_FILE_CREATE && flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW));
55: }
56: 
57: #ifndef _WIN32
58: // somehow sometimes this is missing
59: #ifndef O_CLOEXEC
60: #define O_CLOEXEC 0
61: #endif
62: 
63: // Solaris
64: #ifndef O_DIRECT
65: #define O_DIRECT 0
66: #endif
67: 
68: struct UnixFileHandle : public FileHandle {
69: public:
70: 	UnixFileHandle(FileSystem &file_system, string path, int fd) : FileHandle(file_system, move(path)), fd(fd) {
71: 	}
72: 	~UnixFileHandle() override {
73: 		Close();
74: 	}
75: 
76: protected:
77: 	void Close() override {
78: 		if (fd != -1) {
79: 			close(fd);
80: 		}
81: 	};
82: 
83: public:
84: 	int fd;
85: };
86: 
87: unique_ptr<FileHandle> FileSystem::OpenFile(const string &path, uint8_t flags, FileLockType lock_type,
88:                                             FileCompressionType compression) {
89: 	if (compression != FileCompressionType::UNCOMPRESSED) {
90: 		throw NotImplementedException("Unsupported compression type for default file system");
91: 	}
92: 
93: 	AssertValidFileFlags(flags);
94: 
95: 	int open_flags = 0;
96: 	int rc;
97: 	if (flags & FileFlags::FILE_FLAGS_READ) {
98: 		open_flags = O_RDONLY;
99: 	} else {
100: 		// need Read or Write
101: 		D_ASSERT(flags & FileFlags::FILE_FLAGS_WRITE);
102: 		open_flags = O_RDWR | O_CLOEXEC;
103: 		if (flags & FileFlags::FILE_FLAGS_FILE_CREATE) {
104: 			open_flags |= O_CREAT;
105: 		} else if (flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW) {
106: 			open_flags |= O_CREAT | O_TRUNC;
107: 		}
108: 		if (flags & FileFlags::FILE_FLAGS_APPEND) {
109: 			open_flags |= O_APPEND;
110: 		}
111: 	}
112: 	if (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {
113: #if defined(__sun) && defined(__SVR4)
114: 		throw Exception("DIRECT_IO not supported on Solaris");
115: #endif
116: #if defined(__DARWIN__) || defined(__APPLE__) || defined(__OpenBSD__)
117: 		// OSX does not have O_DIRECT, instead we need to use fcntl afterwards to support direct IO
118: 		open_flags |= O_SYNC;
119: #else
120: 		open_flags |= O_DIRECT | O_SYNC;
121: #endif
122: 	}
123: 	int fd = open(path.c_str(), open_flags, 0666);
124: 	if (fd == -1) {
125: 		throw IOException("Cannot open file \"%s\": %s", path, strerror(errno));
126: 	}
127: 	// #if defined(__DARWIN__) || defined(__APPLE__)
128: 	// 	if (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {
129: 	// 		// OSX requires fcntl for Direct IO
130: 	// 		rc = fcntl(fd, F_NOCACHE, 1);
131: 	// 		if (fd == -1) {
132: 	// 			throw IOException("Could not enable direct IO for file \"%s\": %s", path, strerror(errno));
133: 	// 		}
134: 	// 	}
135: 	// #endif
136: 	if (lock_type != FileLockType::NO_LOCK) {
137: 		// set lock on file
138: 		struct flock fl;
139: 		memset(&fl, 0, sizeof fl);
140: 		fl.l_type = lock_type == FileLockType::READ_LOCK ? F_RDLCK : F_WRLCK;
141: 		fl.l_whence = SEEK_SET;
142: 		fl.l_start = 0;
143: 		fl.l_len = 0;
144: 		rc = fcntl(fd, F_SETLK, &fl);
145: 		if (rc == -1) {
146: 			throw IOException("Could not set lock on file \"%s\": %s", path, strerror(errno));
147: 		}
148: 	}
149: 	return make_unique<UnixFileHandle>(*this, path, fd);
150: }
151: 
152: void FileSystem::SetFilePointer(FileHandle &handle, idx_t location) {
153: 	int fd = ((UnixFileHandle &)handle).fd;
154: 	off_t offset = lseek(fd, location, SEEK_SET);
155: 	if (offset == (off_t)-1) {
156: 		throw IOException("Could not seek to location %lld for file \"%s\": %s", location, handle.path,
157: 		                  strerror(errno));
158: 	}
159: }
160: 
161: idx_t FileSystem::GetFilePointer(FileHandle &handle) {
162: 	int fd = ((UnixFileHandle &)handle).fd;
163: 	off_t position = lseek(fd, 0, SEEK_CUR);
164: 	if (position == (off_t)-1) {
165: 		throw IOException("Could not get file position file \"%s\": %s", handle.path, strerror(errno));
166: 	}
167: 	return position;
168: }
169: 
170: void FileSystem::Read(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location) {
171: 	int fd = ((UnixFileHandle &)handle).fd;
172: 	int64_t bytes_read = pread(fd, buffer, nr_bytes, location);
173: 	if (bytes_read == -1) {
174: 		throw IOException("Could not read from file \"%s\": %s", handle.path, strerror(errno));
175: 	}
176: 	if (bytes_read != nr_bytes) {
177: 		throw IOException("Could not read all bytes from file \"%s\": wanted=%lld read=%lld", handle.path, nr_bytes,
178: 		                  bytes_read);
179: 	}
180: }
181: 
182: int64_t FileSystem::Read(FileHandle &handle, void *buffer, int64_t nr_bytes) {
183: 	int fd = ((UnixFileHandle &)handle).fd;
184: 	int64_t bytes_read = read(fd, buffer, nr_bytes);
185: 	if (bytes_read == -1) {
186: 		throw IOException("Could not read from file \"%s\": %s", handle.path, strerror(errno));
187: 	}
188: 	return bytes_read;
189: }
190: 
191: void FileSystem::Write(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location) {
192: 	int fd = ((UnixFileHandle &)handle).fd;
193: 	int64_t bytes_written = pwrite(fd, buffer, nr_bytes, location);
194: 	if (bytes_written == -1) {
195: 		throw IOException("Could not write file \"%s\": %s", handle.path, strerror(errno));
196: 	}
197: 	if (bytes_written != nr_bytes) {
198: 		throw IOException("Could not write all bytes to file \"%s\": wanted=%lld wrote=%lld", handle.path, nr_bytes,
199: 		                  bytes_written);
200: 	}
201: }
202: 
203: int64_t FileSystem::Write(FileHandle &handle, void *buffer, int64_t nr_bytes) {
204: 	int fd = ((UnixFileHandle &)handle).fd;
205: 	int64_t bytes_written = write(fd, buffer, nr_bytes);
206: 	if (bytes_written == -1) {
207: 		throw IOException("Could not write file \"%s\": %s", handle.path, strerror(errno));
208: 	}
209: 	return bytes_written;
210: }
211: 
212: int64_t FileSystem::GetFileSize(FileHandle &handle) {
213: 	int fd = ((UnixFileHandle &)handle).fd;
214: 	struct stat s;
215: 	if (fstat(fd, &s) == -1) {
216: 		return -1;
217: 	}
218: 	return s.st_size;
219: }
220: 
221: time_t FileSystem::GetLastModifiedTime(FileHandle &handle) {
222: 	int fd = ((UnixFileHandle &)handle).fd;
223: 	struct stat s;
224: 	if (fstat(fd, &s) == -1) {
225: 		return -1;
226: 	}
227: 	return s.st_mtime;
228: }
229: 
230: void FileSystem::Truncate(FileHandle &handle, int64_t new_size) {
231: 	int fd = ((UnixFileHandle &)handle).fd;
232: 	if (ftruncate(fd, new_size) != 0) {
233: 		throw IOException("Could not truncate file \"%s\": %s", handle.path, strerror(errno));
234: 	}
235: }
236: 
237: bool FileSystem::DirectoryExists(const string &directory) {
238: 	if (!directory.empty()) {
239: 		if (access(directory.c_str(), 0) == 0) {
240: 			struct stat status;
241: 			stat(directory.c_str(), &status);
242: 			if (status.st_mode & S_IFDIR) {
243: 				return true;
244: 			}
245: 		}
246: 	}
247: 	// if any condition fails
248: 	return false;
249: }
250: 
251: bool FileSystem::FileExists(const string &filename) {
252: 	if (!filename.empty()) {
253: 		if (access(filename.c_str(), 0) == 0) {
254: 			struct stat status;
255: 			stat(filename.c_str(), &status);
256: 			if (!(status.st_mode & S_IFDIR)) {
257: 				return true;
258: 			}
259: 		}
260: 	}
261: 	// if any condition fails
262: 	return false;
263: }
264: 
265: void FileSystem::CreateDirectory(const string &directory) {
266: 	struct stat st;
267: 
268: 	if (stat(directory.c_str(), &st) != 0) {
269: 		/* Directory does not exist. EEXIST for race condition */
270: 		if (mkdir(directory.c_str(), 0755) != 0 && errno != EEXIST) {
271: 			throw IOException("Failed to create directory \"%s\"!", directory);
272: 		}
273: 	} else if (!S_ISDIR(st.st_mode)) {
274: 		throw IOException("Failed to create directory \"%s\": path exists but is not a directory!", directory);
275: 	}
276: }
277: 
278: int RemoveDirectoryRecursive(const char *path) {
279: 	DIR *d = opendir(path);
280: 	idx_t path_len = (idx_t)strlen(path);
281: 	int r = -1;
282: 
283: 	if (d) {
284: 		struct dirent *p;
285: 		r = 0;
286: 		while (!r && (p = readdir(d))) {
287: 			int r2 = -1;
288: 			char *buf;
289: 			idx_t len;
290: 			/* Skip the names "." and ".." as we don't want to recurse on them. */
291: 			if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, "..")) {
292: 				continue;
293: 			}
294: 			len = path_len + (idx_t)strlen(p->d_name) + 2;
295: 			buf = new char[len];
296: 			if (buf) {
297: 				struct stat statbuf;
298: 				snprintf(buf, len, "%s/%s", path, p->d_name);
299: 				if (!stat(buf, &statbuf)) {
300: 					if (S_ISDIR(statbuf.st_mode)) {
301: 						r2 = RemoveDirectoryRecursive(buf);
302: 					} else {
303: 						r2 = unlink(buf);
304: 					}
305: 				}
306: 				delete[] buf;
307: 			}
308: 			r = r2;
309: 		}
310: 		closedir(d);
311: 	}
312: 	if (!r) {
313: 		r = rmdir(path);
314: 	}
315: 	return r;
316: }
317: 
318: void FileSystem::RemoveDirectory(const string &directory) {
319: 	RemoveDirectoryRecursive(directory.c_str());
320: }
321: 
322: void FileSystem::RemoveFile(const string &filename) {
323: 	if (std::remove(filename.c_str()) != 0) {
324: 		throw IOException("Could not remove file \"%s\": %s", filename, strerror(errno));
325: 	}
326: }
327: 
328: bool FileSystem::ListFiles(const string &directory, const std::function<void(string, bool)> &callback) {
329: 	if (!DirectoryExists(directory)) {
330: 		return false;
331: 	}
332: 	DIR *dir = opendir(directory.c_str());
333: 	if (!dir) {
334: 		return false;
335: 	}
336: 	struct dirent *ent;
337: 	// loop over all files in the directory
338: 	while ((ent = readdir(dir)) != nullptr) {
339: 		string name = string(ent->d_name);
340: 		// skip . .. and empty files
341: 		if (name.empty() || name == "." || name == "..") {
342: 			continue;
343: 		}
344: 		// now stat the file to figure out if it is a regular file or directory
345: 		string full_path = JoinPath(directory, name);
346: 		if (access(full_path.c_str(), 0) != 0) {
347: 			continue;
348: 		}
349: 		struct stat status;
350: 		stat(full_path.c_str(), &status);
351: 		if (!(status.st_mode & S_IFREG) && !(status.st_mode & S_IFDIR)) {
352: 			// not a file or directory: skip
353: 			continue;
354: 		}
355: 		// invoke callback
356: 		callback(name, status.st_mode & S_IFDIR);
357: 	}
358: 	closedir(dir);
359: 	return true;
360: }
361: 
362: string FileSystem::PathSeparator() {
363: 	return "/";
364: }
365: 
366: void FileSystem::FileSync(FileHandle &handle) {
367: 	int fd = ((UnixFileHandle &)handle).fd;
368: 	if (fsync(fd) != 0) {
369: 		throw FatalException("fsync failed!");
370: 	}
371: }
372: 
373: void FileSystem::MoveFile(const string &source, const string &target) {
374: 	//! FIXME: rename does not guarantee atomicity or overwriting target file if it exists
375: 	if (rename(source.c_str(), target.c_str()) != 0) {
376: 		throw IOException("Could not rename file!");
377: 	}
378: }
379: 
380: void FileSystem::SetWorkingDirectory(const string &path) {
381: 	if (chdir(path.c_str()) != 0) {
382: 		throw IOException("Could not change working directory!");
383: 	}
384: }
385: 
386: idx_t FileSystem::GetAvailableMemory() {
387: 	errno = 0;
388: 	idx_t max_memory = MinValue<idx_t>((idx_t)sysconf(_SC_PHYS_PAGES) * (idx_t)sysconf(_SC_PAGESIZE), UINTPTR_MAX);
389: 	if (errno != 0) {
390: 		throw IOException("Could not fetch available system memory!");
391: 	}
392: 	return max_memory;
393: }
394: 
395: string FileSystem::GetWorkingDirectory() {
396: 	auto buffer = unique_ptr<char[]>(new char[PATH_MAX]);
397: 	char *ret = getcwd(buffer.get(), PATH_MAX);
398: 	if (!ret) {
399: 		throw IOException("Could not get working directory!");
400: 	}
401: 	return string(buffer.get());
402: }
403: #else
404: 
405: // Returns the last Win32 error, in string format. Returns an empty string if there is no error.
406: std::string GetLastErrorAsString() {
407: 	// Get the error message, if any.
408: 	DWORD errorMessageID = GetLastError();
409: 	if (errorMessageID == 0)
410: 		return std::string(); // No error message has been recorded
411: 
412: 	LPSTR messageBuffer = nullptr;
413: 	idx_t size =
414: 	    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
415: 	                   NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);
416: 
417: 	std::string message(messageBuffer, size);
418: 
419: 	// Free the buffer.
420: 	LocalFree(messageBuffer);
421: 
422: 	return message;
423: }
424: 
425: struct WindowsFileHandle : public FileHandle {
426: public:
427: 	WindowsFileHandle(FileSystem &file_system, string path, HANDLE fd)
428: 	    : FileHandle(file_system, path), position(0), fd(fd) {
429: 	}
430: 	virtual ~WindowsFileHandle() {
431: 		Close();
432: 	}
433: 
434: protected:
435: 	void Close() override {
436: 		CloseHandle(fd);
437: 	};
438: 
439: public:
440: 	idx_t position;
441: 	HANDLE fd;
442: };
443: 
444: unique_ptr<FileHandle> FileSystem::OpenFile(const string &path, uint8_t flags, FileLockType lock_type,
445:                                             FileCompressionType compression) {
446: 	if (compression != FileCompressionType::UNCOMPRESSED) {
447: 		throw NotImplementedException("Unsupported compression type for default file system");
448: 	}
449: 	AssertValidFileFlags(flags);
450: 
451: 	DWORD desired_access;
452: 	DWORD share_mode;
453: 	DWORD creation_disposition = OPEN_EXISTING;
454: 	DWORD flags_and_attributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;
455: 	if (flags & FileFlags::FILE_FLAGS_READ) {
456: 		desired_access = GENERIC_READ;
457: 		share_mode = FILE_SHARE_READ;
458: 	} else {
459: 		// need Read or Write
460: 		D_ASSERT(flags & FileFlags::FILE_FLAGS_WRITE);
461: 		desired_access = GENERIC_READ | GENERIC_WRITE;
462: 		share_mode = 0;
463: 		if (flags & FileFlags::FILE_FLAGS_FILE_CREATE) {
464: 			creation_disposition = OPEN_ALWAYS;
465: 		} else if (flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW) {
466: 			creation_disposition = CREATE_ALWAYS;
467: 		}
468: 		if (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {
469: 			flags_and_attributes |= FILE_FLAG_WRITE_THROUGH;
470: 		}
471: 	}
472: 	if (flags & FileFlags::FILE_FLAGS_DIRECT_IO) {
473: 		flags_and_attributes |= FILE_FLAG_NO_BUFFERING;
474: 	}
475: 	HANDLE hFile =
476: 	    CreateFileA(path.c_str(), desired_access, share_mode, NULL, creation_disposition, flags_and_attributes, NULL);
477: 	if (hFile == INVALID_HANDLE_VALUE) {
478: 		auto error = GetLastErrorAsString();
479: 		throw IOException("Cannot open file \"%s\": %s", path.c_str(), error);
480: 	}
481: 	auto handle = make_unique<WindowsFileHandle>(*this, path.c_str(), hFile);
482: 	if (flags & FileFlags::FILE_FLAGS_APPEND) {
483: 		auto file_size = GetFileSize(*handle);
484: 		SetFilePointer(*handle, file_size);
485: 	}
486: 	return move(handle);
487: }
488: 
489: void FileSystem::SetFilePointer(FileHandle &handle, idx_t location) {
490: 	((WindowsFileHandle &)handle).position = location;
491: }
492: 
493: idx_t FileSystem::GetFilePointer(FileHandle &handle) {
494: 	return ((WindowsFileHandle &)handle).position;
495: }
496: 
497: void FileSystem::Read(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location) {
498: 	HANDLE hFile = ((WindowsFileHandle &)handle).fd;
499: 	DWORD bytes_read;
500: 	OVERLAPPED ov = {};
501: 	ov.Internal = 0;
502: 	ov.InternalHigh = 0;
503: 	ov.Offset = location & 0xFFFFFFFF;
504: 	ov.OffsetHigh = location >> 32;
505: 	ov.hEvent = 0;
506: 	ReadFile(hFile, buffer, (DWORD)nr_bytes, NULL, &ov);
507: 	auto rc = GetOverlappedResult(hFile, &ov, &bytes_read, true);
508: 	if (rc == 0) {
509: 		auto error = GetLastErrorAsString();
510: 		throw IOException("Could not read file \"%s\": %s", handle.path, error);
511: 	}
512: 	if (bytes_read != nr_bytes) {
513: 		throw IOException("Could not read all bytes from file \"%s\": wanted=%lld read=%lld", handle.path, nr_bytes,
514: 		                  bytes_read);
515: 	}
516: }
517: 
518: int64_t FileSystem::Read(FileHandle &handle, void *buffer, int64_t nr_bytes) {
519: 	HANDLE hFile = ((WindowsFileHandle &)handle).fd;
520: 	DWORD bytes_read;
521: 	auto &pos = ((WindowsFileHandle &)handle).position;
522: 	OVERLAPPED ov = {};
523: 	ov.Internal = 0;
524: 	ov.InternalHigh = 0;
525: 	ov.Offset = pos & 0xFFFFFFFF;
526: 	ov.OffsetHigh = pos >> 32;
527: 	ov.hEvent = 0;
528: 	auto n = std::min<idx_t>(std::max<idx_t>(GetFileSize(handle), pos) - pos, nr_bytes);
529: 	ReadFile(hFile, buffer, (DWORD)n, NULL, &ov);
530: 	auto rc = GetOverlappedResult(hFile, &ov, &bytes_read, true);
531: 	if (rc == 0) {
532: 		auto error = GetLastErrorAsString();
533: 		throw IOException("Could not read file \"%s\": %s", handle.path, error);
534: 	}
535: 	pos += bytes_read;
536: 	return bytes_read;
537: }
538: 
539: void FileSystem::Write(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location) {
540: 	HANDLE hFile = ((WindowsFileHandle &)handle).fd;
541: 	DWORD bytes_written;
542: 	OVERLAPPED ov = {};
543: 	ov.Internal = 0;
544: 	ov.InternalHigh = 0;
545: 	ov.Offset = location & 0xFFFFFFFF;
546: 	ov.OffsetHigh = location >> 32;
547: 	ov.hEvent = 0;
548: 	WriteFile(hFile, buffer, (DWORD)nr_bytes, NULL, &ov);
549: 	auto rc = GetOverlappedResult(hFile, &ov, &bytes_written, true);
550: 	if (rc == 0) {
551: 		auto error = GetLastErrorAsString();
552: 		throw IOException("Could not write file \"%s\": %s", handle.path, error);
553: 	}
554: 	if (bytes_written != nr_bytes) {
555: 		throw IOException("Could not write all bytes from file \"%s\": wanted=%lld wrote=%lld", handle.path, nr_bytes,
556: 		                  bytes_written);
557: 	}
558: }
559: 
560: int64_t FileSystem::Write(FileHandle &handle, void *buffer, int64_t nr_bytes) {
561: 	HANDLE hFile = ((WindowsFileHandle &)handle).fd;
562: 	DWORD bytes_written;
563: 	auto &pos = ((WindowsFileHandle &)handle).position;
564: 	OVERLAPPED ov = {};
565: 	ov.Internal = 0;
566: 	ov.InternalHigh = 0;
567: 	ov.Offset = pos & 0xFFFFFFFF;
568: 	ov.OffsetHigh = pos >> 32;
569: 	ov.hEvent = 0;
570: 	WriteFile(hFile, buffer, (DWORD)nr_bytes, NULL, &ov);
571: 	auto rc = GetOverlappedResult(hFile, &ov, &bytes_written, true);
572: 	if (rc == 0) {
573: 		auto error = GetLastErrorAsString();
574: 		throw IOException("Could not write file \"%s\": %s", handle.path, error);
575: 	}
576: 	pos += bytes_written;
577: 	return bytes_written;
578: }
579: 
580: int64_t FileSystem::GetFileSize(FileHandle &handle) {
581: 	HANDLE hFile = ((WindowsFileHandle &)handle).fd;
582: 	LARGE_INTEGER result;
583: 	if (!GetFileSizeEx(hFile, &result)) {
584: 		return -1;
585: 	}
586: 	return result.QuadPart;
587: }
588: 
589: time_t FileSystem::GetLastModifiedTime(FileHandle &handle) {
590: 	HANDLE hFile = ((WindowsFileHandle &)handle).fd;
591: 
592: 	// https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfiletime
593: 	FILETIME last_write;
594: 	if (GetFileTime(hFile, nullptr, nullptr, &last_write) == 0) {
595: 		return -1;
596: 	}
597: 
598: 	// https://stackoverflow.com/questions/29266743/what-is-dwlowdatetime-and-dwhighdatetime
599: 	ULARGE_INTEGER ul;
600: 	ul.LowPart = last_write.dwLowDateTime;
601: 	ul.HighPart = last_write.dwHighDateTime;
602: 	int64_t fileTime64 = ul.QuadPart;
603: 
604: 	// fileTime64 contains a 64-bit value representing the number of
605: 	// 100-nanosecond intervals since January 1, 1601 (UTC).
606: 	// https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime
607: 
608: 	// Adapted from: https://stackoverflow.com/questions/6161776/convert-windows-filetime-to-second-in-unix-linux
609: 	const auto WINDOWS_TICK = 10000000;
610: 	const auto SEC_TO_UNIX_EPOCH = 11644473600LL;
611: 	time_t result = (fileTime64 / WINDOWS_TICK - SEC_TO_UNIX_EPOCH);
612: 	return result;
613: }
614: 
615: void FileSystem::Truncate(FileHandle &handle, int64_t new_size) {
616: 	HANDLE hFile = ((WindowsFileHandle &)handle).fd;
617: 	// seek to the location
618: 	SetFilePointer(handle, new_size);
619: 	// now set the end of file position
620: 	if (!SetEndOfFile(hFile)) {
621: 		auto error = GetLastErrorAsString();
622: 		throw IOException("Failure in SetEndOfFile call on file \"%s\": %s", handle.path, error);
623: 	}
624: }
625: 
626: bool FileSystem::DirectoryExists(const string &directory) {
627: 	DWORD attrs = GetFileAttributesA(directory.c_str());
628: 	return (attrs != INVALID_FILE_ATTRIBUTES && (attrs & FILE_ATTRIBUTE_DIRECTORY));
629: }
630: 
631: bool FileSystem::FileExists(const string &filename) {
632: 	DWORD attrs = GetFileAttributesA(filename.c_str());
633: 	return (attrs != INVALID_FILE_ATTRIBUTES && !(attrs & FILE_ATTRIBUTE_DIRECTORY));
634: }
635: 
636: void FileSystem::CreateDirectory(const string &directory) {
637: 	if (DirectoryExists(directory)) {
638: 		return;
639: 	}
640: 	if (directory.empty() || !CreateDirectoryA(directory.c_str(), NULL) || !DirectoryExists(directory)) {
641: 		throw IOException("Could not create directory!");
642: 	}
643: }
644: 
645: static void delete_dir_special_snowflake_windows(string directory) {
646: 	if (directory.size() + 3 > MAX_PATH) {
647: 		throw IOException("Pathname too long");
648: 	}
649: 	// create search pattern
650: 	TCHAR szDir[MAX_PATH];
651: 	snprintf(szDir, MAX_PATH, "%s\\*", directory.c_str());
652: 
653: 	WIN32_FIND_DATA ffd;
654: 	HANDLE hFind = FindFirstFile(szDir, &ffd);
655: 	if (hFind == INVALID_HANDLE_VALUE) {
656: 		return;
657: 	}
658: 
659: 	do {
660: 		if (string(ffd.cFileName) == "." || string(ffd.cFileName) == "..") {
661: 			continue;
662: 		}
663: 		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
664: 			// recurse to zap directory contents
665: 			FileSystem fs;
666: 			delete_dir_special_snowflake_windows(fs.JoinPath(directory, ffd.cFileName));
667: 		} else {
668: 			if (strlen(ffd.cFileName) + directory.size() + 1 > MAX_PATH) {
669: 				throw IOException("Pathname too long");
670: 			}
671: 			// create search pattern
672: 			TCHAR del_path[MAX_PATH];
673: 			snprintf(del_path, MAX_PATH, "%s\\%s", directory.c_str(), ffd.cFileName);
674: 			if (!DeleteFileA(del_path)) {
675: 				throw IOException("Failed to delete directory entry");
676: 			}
677: 		}
678: 	} while (FindNextFile(hFind, &ffd) != 0);
679: 
680: 	DWORD dwError = GetLastError();
681: 	if (dwError != ERROR_NO_MORE_FILES) {
682: 		throw IOException("Something went wrong");
683: 	}
684: 	FindClose(hFind);
685: 
686: 	if (!RemoveDirectoryA(directory.c_str())) {
687: 		throw IOException("Failed to delete directory");
688: 	}
689: }
690: 
691: void FileSystem::RemoveDirectory(const string &directory) {
692: 	delete_dir_special_snowflake_windows(directory.c_str());
693: }
694: 
695: void FileSystem::RemoveFile(const string &filename) {
696: 	DeleteFileA(filename.c_str());
697: }
698: 
699: bool FileSystem::ListFiles(const string &directory, const std::function<void(string, bool)> &callback) {
700: 	string search_dir = JoinPath(directory, "*");
701: 
702: 	WIN32_FIND_DATA ffd;
703: 	HANDLE hFind = FindFirstFile(search_dir.c_str(), &ffd);
704: 	if (hFind == INVALID_HANDLE_VALUE) {
705: 		return false;
706: 	}
707: 	do {
708: 		string cFileName = string(ffd.cFileName);
709: 		if (cFileName == "." || cFileName == "..") {
710: 			continue;
711: 		}
712: 		callback(cFileName, ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
713: 	} while (FindNextFile(hFind, &ffd) != 0);
714: 
715: 	DWORD dwError = GetLastError();
716: 	if (dwError != ERROR_NO_MORE_FILES) {
717: 		FindClose(hFind);
718: 		return false;
719: 	}
720: 
721: 	FindClose(hFind);
722: 	return true;
723: }
724: 
725: string FileSystem::PathSeparator() {
726: 	return "\\";
727: }
728: 
729: void FileSystem::FileSync(FileHandle &handle) {
730: 	HANDLE hFile = ((WindowsFileHandle &)handle).fd;
731: 	if (FlushFileBuffers(hFile) == 0) {
732: 		throw IOException("Could not flush file handle to disk!");
733: 	}
734: }
735: 
736: void FileSystem::MoveFile(const string &source, const string &target) {
737: 	if (!MoveFileA(source.c_str(), target.c_str())) {
738: 		throw IOException("Could not move file");
739: 	}
740: }
741: 
742: void FileSystem::SetWorkingDirectory(const string &path) {
743: 	if (!SetCurrentDirectory(path.c_str())) {
744: 		throw IOException("Could not change working directory!");
745: 	}
746: }
747: 
748: idx_t FileSystem::GetAvailableMemory() {
749: 	ULONGLONG available_memory_kb;
750: 	if (!GetPhysicallyInstalledSystemMemory(&available_memory_kb)) {
751: 		throw IOException("Could not fetch available system memory!");
752: 	}
753: 	return MinValue<idx_t>(available_memory_kb * 1024, UINTPTR_MAX);
754: }
755: 
756: string FileSystem::GetWorkingDirectory() {
757: 	idx_t count = GetCurrentDirectory(0, nullptr);
758: 	if (count == 0) {
759: 		throw IOException("Could not get working directory!");
760: 	}
761: 	auto buffer = unique_ptr<char[]>(new char[count]);
762: 	idx_t ret = GetCurrentDirectory(count, buffer.get());
763: 	if (count != ret + 1) {
764: 		throw IOException("Could not get working directory!");
765: 	}
766: 	return string(buffer.get(), ret);
767: }
768: #endif
769: 
770: string FileSystem::GetHomeDirectory() {
771: 	const char *homedir = getenv("HOME");
772: 	if (!homedir) {
773: 		return string();
774: 	}
775: 	return homedir;
776: }
777: 
778: bool FileSystem::CanSeek() {
779: 	return true;
780: }
781: 
782: bool FileSystem::OnDiskFile(FileHandle &handle) {
783: 	return true;
784: }
785: 
786: void FileSystem::Seek(FileHandle &handle, idx_t location) {
787: 	if (!CanSeek()) {
788: 		throw IOException("Cannot seek in files of this type");
789: 	}
790: 	SetFilePointer(handle, location);
791: }
792: 
793: void FileSystem::Reset(FileHandle &handle) {
794: 	Seek(handle, 0);
795: }
796: 
797: idx_t FileSystem::SeekPosition(FileHandle &handle) {
798: 	if (!CanSeek()) {
799: 		throw IOException("Cannot seek in files of this type");
800: 	}
801: 	return GetFilePointer(handle);
802: }
803: 
804: string FileSystem::JoinPath(const string &a, const string &b) {
805: 	// FIXME: sanitize paths
806: 	return a + PathSeparator() + b;
807: }
808: 
809: string FileSystem::ConvertSeparators(const string &path) {
810: 	auto separator_str = PathSeparator();
811: 	char separator = separator_str[0];
812: 	if (separator == '/') {
813: 		// on unix-based systems we only accept / as a separator
814: 		return path;
815: 	}
816: 	// on windows-based systems we accept both
817: 	string result = path;
818: 	for (idx_t i = 0; i < result.size(); i++) {
819: 		if (result[i] == '/') {
820: 			result[i] = separator;
821: 		}
822: 	}
823: 	return result;
824: }
825: 
826: string FileSystem::ExtractBaseName(const string &path) {
827: 	auto sep = PathSeparator();
828: 	auto vec = StringUtil::Split(StringUtil::Split(path, sep).back(), ".");
829: 	return vec[0];
830: }
831: 
832: int64_t FileHandle::Read(void *buffer, idx_t nr_bytes) {
833: 	return file_system.Read(*this, buffer, nr_bytes);
834: }
835: 
836: int64_t FileHandle::Write(void *buffer, idx_t nr_bytes) {
837: 	return file_system.Write(*this, buffer, nr_bytes);
838: }
839: 
840: void FileHandle::Read(void *buffer, idx_t nr_bytes, idx_t location) {
841: 	file_system.Read(*this, buffer, nr_bytes, location);
842: }
843: 
844: void FileHandle::Write(void *buffer, idx_t nr_bytes, idx_t location) {
845: 	file_system.Write(*this, buffer, nr_bytes, location);
846: }
847: 
848: void FileHandle::Seek(idx_t location) {
849: 	file_system.Seek(*this, location);
850: }
851: 
852: void FileHandle::Reset() {
853: 	file_system.Reset(*this);
854: }
855: 
856: idx_t FileHandle::SeekPosition() {
857: 	return file_system.SeekPosition(*this);
858: }
859: 
860: bool FileHandle::CanSeek() {
861: 	return file_system.CanSeek();
862: }
863: 
864: string FileHandle::ReadLine() {
865: 	string result;
866: 	char buffer[1];
867: 	while (true) {
868: 		idx_t tuples_read = Read(buffer, 1);
869: 		if (tuples_read == 0 || buffer[0] == '\n') {
870: 			return result;
871: 		}
872: 		if (buffer[0] != '\r') {
873: 			result += buffer[0];
874: 		}
875: 	}
876: }
877: 
878: bool FileHandle::OnDiskFile() {
879: 	return file_system.OnDiskFile(*this);
880: }
881: 
882: idx_t FileHandle::GetFileSize() {
883: 	return file_system.GetFileSize(*this);
884: }
885: 
886: void FileHandle::Sync() {
887: 	file_system.FileSync(*this);
888: }
889: 
890: void FileHandle::Truncate(int64_t new_size) {
891: 	file_system.Truncate(*this, new_size);
892: }
893: 
894: static bool HasGlob(const string &str) {
895: 	for (idx_t i = 0; i < str.size(); i++) {
896: 		switch (str[i]) {
897: 		case '*':
898: 		case '?':
899: 		case '[':
900: 			return true;
901: 		default:
902: 			break;
903: 		}
904: 	}
905: 	return false;
906: }
907: 
908: static void GlobFiles(FileSystem &fs, const string &path, const string &glob, bool match_directory,
909:                       vector<string> &result, bool join_path) {
910: 	fs.ListFiles(path, [&](const string &fname, bool is_directory) {
911: 		if (is_directory != match_directory) {
912: 			return;
913: 		}
914: 		if (LikeFun::Glob(fname.c_str(), fname.size(), glob.c_str(), glob.size())) {
915: 			if (join_path) {
916: 				result.push_back(fs.JoinPath(path, fname));
917: 			} else {
918: 				result.push_back(fname);
919: 			}
920: 		}
921: 	});
922: }
923: 
924: vector<string> FileSystem::Glob(const string &path) {
925: 	if (path.empty()) {
926: 		return vector<string>();
927: 	}
928: 	// first check if the path has a glob at all
929: 	if (!HasGlob(path)) {
930: 		// no glob: return only the file (if it exists)
931: 		vector<string> result;
932: 		if (FileExists(path)) {
933: 			result.push_back(path);
934: 		}
935: 		return result;
936: 	}
937: 	// split up the path into separate chunks
938: 	vector<string> splits;
939: 	idx_t last_pos = 0;
940: 	for (idx_t i = 0; i < path.size(); i++) {
941: 		if (path[i] == '\\' || path[i] == '/') {
942: 			if (i == last_pos) {
943: 				// empty: skip this position
944: 				last_pos = i + 1;
945: 				continue;
946: 			}
947: 			if (splits.empty()) {
948: 				splits.push_back(path.substr(0, i));
949: 			} else {
950: 				splits.push_back(path.substr(last_pos, i - last_pos));
951: 			}
952: 			last_pos = i + 1;
953: 		}
954: 	}
955: 	splits.push_back(path.substr(last_pos, path.size() - last_pos));
956: 	// handle absolute paths
957: 	bool absolute_path = false;
958: 	if (path[0] == '/') {
959: 		// first character is a slash -  unix absolute path
960: 		absolute_path = true;
961: 	} else if (StringUtil::Contains(splits[0], ":")) {
962: 		// first split has a colon -  windows absolute path
963: 		absolute_path = true;
964: 	} else if (splits[0] == "~") {
965: 		// starts with home directory
966: 		auto home_directory = GetHomeDirectory();
967: 		if (!home_directory.empty()) {
968: 			absolute_path = true;
969: 			splits[0] = home_directory;
970: 		}
971: 	}
972: 	vector<string> previous_directories;
973: 	if (absolute_path) {
974: 		// for absolute paths, we don't start by scanning the current directory
975: 		previous_directories.push_back(splits[0]);
976: 	}
977: 	for (idx_t i = absolute_path ? 1 : 0; i < splits.size(); i++) {
978: 		bool is_last_chunk = i + 1 == splits.size();
979: 		bool has_glob = HasGlob(splits[i]);
980: 		// if it's the last chunk we need to find files, otherwise we find directories
981: 		// not the last chunk: gather a list of all directories that match the glob pattern
982: 		vector<string> result;
983: 		if (!has_glob) {
984: 			// no glob, just append as-is
985: 			if (previous_directories.empty()) {
986: 				result.push_back(splits[i]);
987: 			} else {
988: 				for (auto &prev_directory : previous_directories) {
989: 					result.push_back(JoinPath(prev_directory, splits[i]));
990: 				}
991: 			}
992: 		} else {
993: 			if (previous_directories.empty()) {
994: 				// no previous directories: list in the current path
995: 				GlobFiles(*this, ".", splits[i], !is_last_chunk, result, false);
996: 			} else {
997: 				// previous directories
998: 				// we iterate over each of the previous directories, and apply the glob of the current directory
999: 				for (auto &prev_directory : previous_directories) {
1000: 					GlobFiles(*this, prev_directory, splits[i], !is_last_chunk, result, true);
1001: 				}
1002: 			}
1003: 		}
1004: 		if (is_last_chunk || result.empty()) {
1005: 			return result;
1006: 		}
1007: 		previous_directories = move(result);
1008: 	}
1009: 	return vector<string>();
1010: }
1011: 
1012: unique_ptr<FileHandle> VirtualFileSystem::OpenFile(const string &path, uint8_t flags, FileLockType lock,
1013:                                                    FileCompressionType compression) {
1014: 	if (compression == FileCompressionType::AUTO_DETECT) {
1015: 		// auto detect compression settings based on file name
1016: 		auto lower_path = StringUtil::Lower(path);
1017: 		if (StringUtil::EndsWith(lower_path, ".gz")) {
1018: 			compression = FileCompressionType::GZIP;
1019: 		} else {
1020: 			compression = FileCompressionType::UNCOMPRESSED;
1021: 		}
1022: 	}
1023: 	// open the base file handle
1024: 	auto file_handle = FindFileSystem(path)->OpenFile(path, flags, lock, FileCompressionType::UNCOMPRESSED);
1025: 	if (compression != FileCompressionType::UNCOMPRESSED) {
1026: 		switch (compression) {
1027: 		case FileCompressionType::GZIP:
1028: 			file_handle = GZipFileSystem::OpenCompressedFile(move(file_handle));
1029: 			break;
1030: 		default:
1031: 			throw NotImplementedException("Unimplemented compression type");
1032: 		}
1033: 	}
1034: 	return file_handle;
1035: }
1036: 
1037: } // namespace duckdb
[end of src/common/file_system.cpp]
[start of src/include/duckdb/common/file_system.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/file_system.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/constants.hpp"
12: #include "duckdb/common/file_buffer.hpp"
13: #include "duckdb/common/vector.hpp"
14: #include "duckdb/common/unordered_map.hpp"
15: #include "duckdb/common/exception.hpp"
16: #include "duckdb/common/enums/file_compression_type.hpp"
17: 
18: #include <functional>
19: 
20: #undef CreateDirectory
21: #undef MoveFile
22: #undef RemoveDirectory
23: 
24: namespace duckdb {
25: class ClientContext;
26: class DatabaseInstance;
27: class FileSystem;
28: 
29: struct FileHandle {
30: public:
31: 	FileHandle(FileSystem &file_system, string path) : file_system(file_system), path(path) {
32: 	}
33: 	FileHandle(const FileHandle &) = delete;
34: 	virtual ~FileHandle() {
35: 	}
36: 
37: 	int64_t Read(void *buffer, idx_t nr_bytes);
38: 	int64_t Write(void *buffer, idx_t nr_bytes);
39: 	void Read(void *buffer, idx_t nr_bytes, idx_t location);
40: 	void Write(void *buffer, idx_t nr_bytes, idx_t location);
41: 	void Seek(idx_t location);
42: 	void Reset();
43: 	idx_t SeekPosition();
44: 	void Sync();
45: 	void Truncate(int64_t new_size);
46: 	string ReadLine();
47: 
48: 	bool CanSeek();
49: 	bool OnDiskFile();
50: 	idx_t GetFileSize();
51: 
52: protected:
53: 	virtual void Close() = 0;
54: 
55: public:
56: 	FileSystem &file_system;
57: 	string path;
58: };
59: 
60: enum class FileLockType : uint8_t { NO_LOCK = 0, READ_LOCK = 1, WRITE_LOCK = 2 };
61: 
62: class FileFlags {
63: public:
64: 	//! Open file with read access
65: 	static constexpr uint8_t FILE_FLAGS_READ = 1 << 0;
66: 	//! Open file with read/write access
67: 	static constexpr uint8_t FILE_FLAGS_WRITE = 1 << 1;
68: 	//! Use direct IO when reading/writing to the file
69: 	static constexpr uint8_t FILE_FLAGS_DIRECT_IO = 1 << 2;
70: 	//! Create file if not exists, can only be used together with WRITE
71: 	static constexpr uint8_t FILE_FLAGS_FILE_CREATE = 1 << 3;
72: 	//! Always create a new file. If a file exists, the file is truncated. Cannot be used together with CREATE.
73: 	static constexpr uint8_t FILE_FLAGS_FILE_CREATE_NEW = 1 << 4;
74: 	//! Open file in append mode
75: 	static constexpr uint8_t FILE_FLAGS_APPEND = 1 << 5;
76: };
77: 
78: class FileSystem {
79: public:
80: 	virtual ~FileSystem() {
81: 	}
82: 
83: public:
84: 	static FileSystem &GetFileSystem(ClientContext &context);
85: 	static FileSystem &GetFileSystem(DatabaseInstance &db);
86: 
87: 	virtual unique_ptr<FileHandle> OpenFile(const string &path, uint8_t flags,
88: 	                                        FileLockType lock = FileLockType::NO_LOCK,
89: 	                                        FileCompressionType compression = FileCompressionType::UNCOMPRESSED);
90: 
91: 	//! Read exactly nr_bytes from the specified location in the file. Fails if nr_bytes could not be read. This is
92: 	//! equivalent to calling SetFilePointer(location) followed by calling Read().
93: 	virtual void Read(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location);
94: 	//! Write exactly nr_bytes to the specified location in the file. Fails if nr_bytes could not be read. This is
95: 	//! equivalent to calling SetFilePointer(location) followed by calling Write().
96: 	virtual void Write(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location);
97: 	//! Read nr_bytes from the specified file into the buffer, moving the file pointer forward by nr_bytes. Returns the
98: 	//! amount of bytes read.
99: 	virtual int64_t Read(FileHandle &handle, void *buffer, int64_t nr_bytes);
100: 	//! Write nr_bytes from the buffer into the file, moving the file pointer forward by nr_bytes.
101: 	virtual int64_t Write(FileHandle &handle, void *buffer, int64_t nr_bytes);
102: 
103: 	//! Returns the file size of a file handle, returns -1 on error
104: 	virtual int64_t GetFileSize(FileHandle &handle);
105: 	//! Returns the file last modified time of a file handle, returns timespec with zero on all attributes on error
106: 	virtual time_t GetLastModifiedTime(FileHandle &handle);
107: 	//! Truncate a file to a maximum size of new_size, new_size should be smaller than or equal to the current size of
108: 	//! the file
109: 	virtual void Truncate(FileHandle &handle, int64_t new_size);
110: 
111: 	//! Check if a directory exists
112: 	virtual bool DirectoryExists(const string &directory);
113: 	//! Create a directory if it does not exist
114: 	virtual void CreateDirectory(const string &directory);
115: 	//! Recursively remove a directory and all files in it
116: 	virtual void RemoveDirectory(const string &directory);
117: 	//! List files in a directory, invoking the callback method for each one with (filename, is_dir)
118: 	virtual bool ListFiles(const string &directory, const std::function<void(string, bool)> &callback);
119: 	//! Move a file from source path to the target, StorageManager relies on this being an atomic action for ACID
120: 	//! properties
121: 	virtual void MoveFile(const string &source, const string &target);
122: 	//! Check if a file exists
123: 	virtual bool FileExists(const string &filename);
124: 	//! Remove a file from disk
125: 	virtual void RemoveFile(const string &filename);
126: 	//! Path separator for the current file system
127: 	virtual string PathSeparator();
128: 	//! Join two paths together
129: 	virtual string JoinPath(const string &a, const string &path);
130: 	//! Convert separators in a path to the local separators (e.g. convert "/" into \\ on windows)
131: 	virtual string ConvertSeparators(const string &path);
132: 	//! Extract the base name of a file (e.g. if the input is lib/example.dll the base name is example)
133: 	virtual string ExtractBaseName(const string &path);
134: 	//! Sync a file handle to disk
135: 	virtual void FileSync(FileHandle &handle);
136: 
137: 	//! Sets the working directory
138: 	virtual void SetWorkingDirectory(const string &path);
139: 	//! Gets the working directory
140: 	virtual string GetWorkingDirectory();
141: 	//! Gets the users home directory
142: 	virtual string GetHomeDirectory();
143: 
144: 	//! Runs a glob on the file system, returning a list of matching files
145: 	virtual vector<string> Glob(const string &path);
146: 
147: 	//! Returns the system-available memory in bytes
148: 	virtual idx_t GetAvailableMemory();
149: 
150: 	//! registers a sub-file system to handle certain file name prefixes, e.g. http:// etc.
151: 	virtual void RegisterSubSystem(unique_ptr<FileSystem> sub_fs) {
152: 		throw NotImplementedException("Can't register a sub system on a non-virtual file system");
153: 	}
154: 
155: 	virtual bool CanHandleFile(const string &fpath) {
156: 		//! Whether or not a sub-system can handle a specific file path
157: 		return false;
158: 	}
159: 
160: 	//! Set the file pointer of a file handle to a specified location. Reads and writes will happen from this location
161: 	virtual void Seek(FileHandle &handle, idx_t location);
162: 	//! Reset a file to the beginning (equivalent to Seek(handle, 0) for simple files)
163: 	virtual void Reset(FileHandle &handle);
164: 	virtual idx_t SeekPosition(FileHandle &handle);
165: 
166: 	//! Whether or not we can seek into the file
167: 	virtual bool CanSeek();
168: 	//! Whether or not the FS handles plain files on disk. This is relevant for certain optimizations, as random reads
169: 	//! in a file on-disk are much cheaper than e.g. random reads in a file over the network
170: 	virtual bool OnDiskFile(FileHandle &handle);
171: 
172: private:
173: 	//! Set the file pointer of a file handle to a specified location. Reads and writes will happen from this location
174: 	void SetFilePointer(FileHandle &handle, idx_t location);
175: 	virtual idx_t GetFilePointer(FileHandle &handle);
176: };
177: 
178: // bunch of wrappers to allow registering protocol handlers
179: class VirtualFileSystem : public FileSystem {
180: public:
181: 	unique_ptr<FileHandle> OpenFile(const string &path, uint8_t flags, FileLockType lock = FileLockType::NO_LOCK,
182: 	                                FileCompressionType compression = FileCompressionType::UNCOMPRESSED) override;
183: 
184: 	virtual void Read(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location) override {
185: 		handle.file_system.Read(handle, buffer, nr_bytes, location);
186: 	};
187: 
188: 	virtual void Write(FileHandle &handle, void *buffer, int64_t nr_bytes, idx_t location) override {
189: 		handle.file_system.Write(handle, buffer, nr_bytes, location);
190: 	}
191: 
192: 	int64_t Read(FileHandle &handle, void *buffer, int64_t nr_bytes) override {
193: 		return handle.file_system.Read(handle, buffer, nr_bytes);
194: 	}
195: 
196: 	int64_t Write(FileHandle &handle, void *buffer, int64_t nr_bytes) override {
197: 		return handle.file_system.Write(handle, buffer, nr_bytes);
198: 	}
199: 
200: 	int64_t GetFileSize(FileHandle &handle) override {
201: 		return handle.file_system.GetFileSize(handle);
202: 	}
203: 	time_t GetLastModifiedTime(FileHandle &handle) override {
204: 		return handle.file_system.GetLastModifiedTime(handle);
205: 	}
206: 
207: 	void Truncate(FileHandle &handle, int64_t new_size) override {
208: 		handle.file_system.Truncate(handle, new_size);
209: 	}
210: 
211: 	void FileSync(FileHandle &handle) override {
212: 		handle.file_system.FileSync(handle);
213: 	}
214: 
215: 	// need to look up correct fs for this
216: 	bool DirectoryExists(const string &directory) override {
217: 		return FindFileSystem(directory)->DirectoryExists(directory);
218: 	}
219: 	void CreateDirectory(const string &directory) override {
220: 		FindFileSystem(directory)->CreateDirectory(directory);
221: 	}
222: 
223: 	void RemoveDirectory(const string &directory) override {
224: 		FindFileSystem(directory)->RemoveDirectory(directory);
225: 	}
226: 
227: 	bool ListFiles(const string &directory, const std::function<void(string, bool)> &callback) override {
228: 		return FindFileSystem(directory)->ListFiles(directory, callback);
229: 	}
230: 
231: 	void MoveFile(const string &source, const string &target) override {
232: 		FindFileSystem(source)->MoveFile(source, target);
233: 	}
234: 
235: 	bool FileExists(const string &filename) override {
236: 		return FindFileSystem(filename)->FileExists(filename);
237: 	}
238: 
239: 	virtual void RemoveFile(const string &filename) override {
240: 		FindFileSystem(filename)->RemoveFile(filename);
241: 	}
242: 
243: 	vector<string> Glob(const string &path) override {
244: 		return FindFileSystem(path)->Glob(path);
245: 	}
246: 
247: 	// these goes to the default fs
248: 	void SetWorkingDirectory(const string &path) override {
249: 		default_fs.SetWorkingDirectory(path);
250: 	}
251: 
252: 	string GetWorkingDirectory() override {
253: 		return default_fs.GetWorkingDirectory();
254: 	}
255: 
256: 	string GetHomeDirectory() override {
257: 		return default_fs.GetWorkingDirectory();
258: 	}
259: 
260: 	idx_t GetAvailableMemory() override {
261: 		return default_fs.GetAvailableMemory();
262: 	}
263: 
264: 	void RegisterSubSystem(unique_ptr<FileSystem> fs) override {
265: 		sub_systems.push_back(move(fs));
266: 	}
267: 
268: private:
269: 	FileSystem *FindFileSystem(const string &path) {
270: 		for (auto &sub_system : sub_systems) {
271: 			if (sub_system->CanHandleFile(path)) {
272: 				return sub_system.get();
273: 			}
274: 		}
275: 		return &default_fs;
276: 	}
277: 
278: private:
279: 	vector<unique_ptr<FileSystem>> sub_systems;
280: 	FileSystem default_fs;
281: };
282: 
283: } // namespace duckdb
[end of src/include/duckdb/common/file_system.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: