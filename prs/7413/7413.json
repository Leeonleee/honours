{
  "repo": "duckdb/duckdb",
  "pull_number": 7413,
  "instance_id": "duckdb__duckdb-7413",
  "issue_numbers": [
    "6804"
  ],
  "base_commit": "d467627253231dbcd4e70b6245709106351d5811",
  "patch": "diff --git a/src/optimizer/rule/move_constants.cpp b/src/optimizer/rule/move_constants.cpp\nindex 3b221cb4d264..9704d665a132 100644\n--- a/src/optimizer/rule/move_constants.cpp\n+++ b/src/optimizer/rule/move_constants.cpp\n@@ -55,6 +55,9 @@ unique_ptr<Expression> MoveConstantsRule::Apply(LogicalOperator &op, vector<refe\n \t\t}\n \t\tauto result_value = Value::HUGEINT(outer_value);\n \t\tif (!result_value.DefaultTryCastAs(constant_type)) {\n+\t\t\tif (comparison.type != ExpressionType::COMPARE_EQUAL) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n \t\t\t// if the cast is not possible then the comparison is not possible\n \t\t\t// for example, if we have x + 5 = 3, where x is an unsigned number, we will get x = -2\n \t\t\t// since this is not possible we can remove the entire branch here\n",
  "test_patch": "diff --git a/test/fuzzer/fuzz_not_operator.test b/test/fuzzer/fuzz_not_operator.test\nnew file mode 100644\nindex 000000000000..d329a7368de3\n--- /dev/null\n+++ b/test/fuzzer/fuzz_not_operator.test\n@@ -0,0 +1,16 @@\n+# name: test/fuzzer/fuzz_not_operator.test\n+# group: [fuzzer]\n+\n+statement ok\n+pragma enable_verification\n+\n+# Because 2060771621 + -2134619525 becomes bigger than INTEGER (detected type for the constants)\n+# previously we would wrongfully strip the where clause and return an empty set.\n+query I\n+SELECT i FROM (select 1) tbl(i) WHERE ( 2060771621 != i + -2134619525 )\n+----\n+1\n+\n+query I\n+select i FROM (select 4195391146) tbl(i) WHERE ( 2060771621 != i + -2134619525)\n+----\n",
  "problem_statement": "On abnormal results of the not operator\n### What happens?\n\nWhen using duck db, we found a problem that was inconsistent with the expected result. When there was only one piece of data in the table, we used the specific values represented by t0. c0 and t0. c0 to query and returned inconsistent data.\r\n\n\n### To Reproduce\n\nCREATE TABLE t0(c0 SMALLINT DEFAULT(831652365), c1 BOOL DEFAULT('yxDVG*?'), PRIMARY KEY(c1));\r\nINSERT INTO t0(c1, c0) VALUES (-1486607961, 0.9263986431982463);\r\nANALYZE;\r\nSELECT t0.c0 FROM t0; --[1]\r\n\r\nStatement that triggers a bug\uff1a\r\nSELECT t0.c0 FROM t0 WHERE (NOT ((2060771621)=(((t0.c0)+(-2134619525))))); \r\nexpected\uff1a[1]\r\nactual:  []\n\n### OS:\n\nUbuntu 18.04.6 LTS (GNU/Linux 5.4.0-144-generic x86_64)\n\n### DuckDB Version:\n\n0.7.0\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nChenglin Tian\n\n### Affiliation:\n\nTianjin University\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Slightly simpler reproduction: \r\n\r\nNotes:\r\n- Changing c0 to bigint eliminates the issue\r\n- Casting c0 to bigint also eliminates the issue\r\n- Couldn't reproduce in Postgres 15.0.\r\n\r\n```\r\n\r\nimport duckdb \r\nwith duckdb.connect() as con:\r\n    con.execute(\"\"\"\r\n    CREATE TABLE t0(c0 SMALLINT);\r\n    INSERT INTO t0(c0) values(1);\"\"\")\r\n\r\n    df=con.execute(\"\"\"\r\n        SELECT c0, -- 1                                    \r\n                c0 = 1 as c0_is_one,  -- True\r\n                2=((c0)+(-2147483646)) as two_check, -- False\r\n          not(2=((c0)+(-2147483646))) as not_two_check, -- False ?????\r\n                1=((c0)+(-2147483646)) as one_check,  -- False\r\n         not(1=((c0)+(-2147483646))) as not_one_check -- True\r\n        FROM t0\"\"\").df()\r\n    display(df)\r\n    assert df[\"one_check\"].iat[0] == False and df[\"not_one_check\"].iat[0] == True\r\n    assert df[\"two_check\"].iat[0] == False and df[\"not_two_check\"].iat[0] == True\r\n```\r\n\nThank you for your suggestion. We solved this problem after converting the data type, so is this a bug\nThe optimizer is at fault here, when I run this with `pragma enable_verification;` I get:\r\n```\r\nActual result:\r\nInvalid Error: Unoptimized statement differs from original result!\r\nOriginal Result:\r\ni\r\nSMALLINT\r\n[ Rows: 0]\r\n\r\nUnoptimized:\r\ni\r\nSMALLINT\r\n[ Rows: 1]\r\n1\r\n```",
  "created_at": "2023-05-08T19:35:49Z"
}