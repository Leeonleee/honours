diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index bdc4c04d98dc..ac52b7734889 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -14,6 +14,7 @@ add_subdirectory(sql)
 add_subdirectory(planner)
 add_subdirectory(optimizer)
 add_subdirectory(parser)
+add_subdirectory(rigger)
 
 if(NOT WIN32 AND NOT SUN)
   add_subdirectory(sqlserver)
diff --git a/test/rigger/CMakeLists.txt b/test/rigger/CMakeLists.txt
new file mode 100644
index 000000000000..0bc50c18417e
--- /dev/null
+++ b/test/rigger/CMakeLists.txt
@@ -0,0 +1,4 @@
+add_library_unity(test_rigger OBJECT test_rigger.cpp)
+set(ALL_OBJECT_FILES
+    ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:test_rigger>
+    PARENT_SCOPE)
diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp
new file mode 100644
index 000000000000..2e5de0f5c93b
--- /dev/null
+++ b/test/rigger/test_rigger.cpp
@@ -0,0 +1,78 @@
+#include "catch.hpp"
+#include "test_helpers.hpp"
+
+using namespace duckdb;
+using namespace std;
+
+TEST_CASE("Tests found by Rigger", "[rigger]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db);
+	con.EnableQueryVerification();
+
+	SECTION("489") {
+		// A predicate NOT(NULL OR TRUE) unexpectedly evaluates to TRUE
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (0);"));
+		result = con.Query("SELECT * FROM t0 WHERE NOT(NULL OR TRUE);");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+		result = con.Query("SELECT NULL OR TRUE;");
+		REQUIRE(CHECK_COLUMN(result, 0, {true}));
+		result = con.Query("SELECT NOT(NULL OR TRUE);");
+		REQUIRE(CHECK_COLUMN(result, 0, {false}));
+	}
+	SECTION("490") {
+		// A comparison column=column unexpectedly evaluates to TRUE for column=NULL
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (NULL);"));
+		result = con.Query("SELECT * FROM t0 WHERE c0 = c0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+	}
+	SECTION("491") {
+		// PRAGMA table_info provides no output
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		result = con.Query("PRAGMA table_info('t0');");
+		REQUIRE(CHECK_COLUMN(result, 0, {0}));
+		REQUIRE(CHECK_COLUMN(result, 1, {"c0"}));
+		REQUIRE(CHECK_COLUMN(result, 2, {"INTEGER"}));
+		REQUIRE(CHECK_COLUMN(result, 3, {false}));
+		REQUIRE(CHECK_COLUMN(result, 4, {Value()}));
+		REQUIRE(CHECK_COLUMN(result, 5, {false}));
+		result = con.Query("SELECT * FROM pragma_table_info('t0');");
+		REQUIRE(CHECK_COLUMN(result, 0, {0}));
+		REQUIRE(CHECK_COLUMN(result, 1, {"c0"}));
+		REQUIRE(CHECK_COLUMN(result, 2, {"INTEGER"}));
+		REQUIRE(CHECK_COLUMN(result, 3, {false}));
+		REQUIRE(CHECK_COLUMN(result, 4, {Value()}));
+		REQUIRE(CHECK_COLUMN(result, 5, {false}));
+	}
+	SECTION("493") {
+		// SIMILAR TO results in an "Unknown error -1
+		result = con.Query("SELECT '' SIMILAR TO '';");
+		REQUIRE(CHECK_COLUMN(result, 0, {true}));
+	}
+	SECTION("495") {
+		// Comparison on UNIQUE NUMERIC column causes a query to omit a row in the result set
+		// REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 NUMERIC UNIQUE);"));
+		// REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (1163404482), (0), (488566);"));
+		// result = con.Query("SELECT * FROM t0 WHERE c0 > 0.1 ORDER BY 1;");
+		// REQUIRE(CHECK_COLUMN(result, 0, {488566, 1163404482}));
+		// result = con.Query("SELECT * FROM t0 WHERE c0 >= 0.1 ORDER BY 1;");
+		// REQUIRE(CHECK_COLUMN(result, 0, {488566, 1163404482}));
+		// result = con.Query("SELECT * FROM t0 WHERE 0.1 < c0 ORDER BY 1;");
+		// REQUIRE(CHECK_COLUMN(result, 0, {488566, 1163404482}));
+		// result = con.Query("SELECT * FROM t0 WHERE 0.1 <= c0 ORDER BY 1;");
+		// REQUIRE(CHECK_COLUMN(result, 0, {488566, 1163404482}));
+	}
+	SECTION("497") {
+		// Comparison of two boolean columns in different tables results in an error "Not implemented: Unimplemented type for sort"
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 BOOL);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 BOOL);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t1(c0) VALUES (0);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (0);"));
+		result = con.Query("SELECT t0.c0 FROM t0, t1 WHERE t1.c0 < t0.c0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+	}
+
+
+}
diff --git a/test/sql/function/test_table_function.cpp b/test/sql/function/test_table_function.cpp
index a4590ebcd6ae..4b731327ee41 100644
--- a/test/sql/function/test_table_function.cpp
+++ b/test/sql/function/test_table_function.cpp
@@ -18,7 +18,7 @@ TEST_CASE("Table functions", "[function]") {
 	REQUIRE(CHECK_COLUMN(result, 1, {"i", "j"}));
 	REQUIRE(CHECK_COLUMN(result, 2, {"INTEGER", "INTEGER"}));
 	REQUIRE(CHECK_COLUMN(result, 3, {false, false}));
-	REQUIRE(CHECK_COLUMN(result, 4, {"NULL", "NULL"}));
+	REQUIRE(CHECK_COLUMN(result, 4, {Value(), Value()}));
 	REQUIRE(CHECK_COLUMN(result, 5, {false, false}));
 
 	// project single column
diff --git a/test/sql/index/test_art_keys.cpp b/test/sql/index/test_art_keys.cpp
index a144558108e1..aeea1a59fb36 100644
--- a/test/sql/index/test_art_keys.cpp
+++ b/test/sql/index/test_art_keys.cpp
@@ -150,6 +150,16 @@ TEST_CASE("Test correct functioning of art keys", "[art]") {
 	TestKeys(keys);
 
 	keys.clear();
+
+	keys.push_back(Key::CreateKey<double>(0, is_little_endian));
+	keys.push_back(Key::CreateKey<double>(0.1, is_little_endian));
+	keys.push_back(Key::CreateKey<double>(488566, is_little_endian));
+	keys.push_back(Key::CreateKey<double>(1163404482, is_little_endian));
+
+	TestKeys(keys);
+
+	keys.clear();
+
 }
 
 TEST_CASE("Test correct functioning of art EncodeFloat/EncodeDouble", "[art-enc]") {
diff --git a/test/sql/pragma/test_show_tables.cpp b/test/sql/pragma/test_show_tables.cpp
index 165122fbf9c8..5ad35e1a6590 100644
--- a/test/sql/pragma/test_show_tables.cpp
+++ b/test/sql/pragma/test_show_tables.cpp
@@ -27,7 +27,7 @@ TEST_CASE("Test SHOW/DESCRIBE tables", "[pragma]") {
 	REQUIRE(CHECK_COLUMN(result, 1, {"INTEGER", "INTEGER"}));
 	REQUIRE(CHECK_COLUMN(result, 2, {"YES", "YES"}));
 	REQUIRE(CHECK_COLUMN(result, 3, {Value(), Value()}));
-	REQUIRE(CHECK_COLUMN(result, 4, {"NULL", "NULL"}));
+	REQUIRE(CHECK_COLUMN(result, 4, {Value(), Value()}));
 	REQUIRE(CHECK_COLUMN(result, 5, {Value(), Value()}));
 	// equivalent to PRAGMA SHOW('integers')
 	result = con.Query("PRAGMA SHOW('integers')");
@@ -36,7 +36,7 @@ TEST_CASE("Test SHOW/DESCRIBE tables", "[pragma]") {
 	REQUIRE(CHECK_COLUMN(result, 1, {"INTEGER", "INTEGER"}));
 	REQUIRE(CHECK_COLUMN(result, 2, {"YES", "YES"}));
 	REQUIRE(CHECK_COLUMN(result, 3, {Value(), Value()}));
-	REQUIRE(CHECK_COLUMN(result, 4, {"NULL", "NULL"}));
+	REQUIRE(CHECK_COLUMN(result, 4, {Value(), Value()}));
 	REQUIRE(CHECK_COLUMN(result, 5, {Value(), Value()}));
 
 	// we can also describe views
diff --git a/test/sql/pragma/test_table_info.cpp b/test/sql/pragma/test_table_info.cpp
index 83c32065d382..57215d79ce26 100644
--- a/test/sql/pragma/test_table_info.cpp
+++ b/test/sql/pragma/test_table_info.cpp
@@ -23,7 +23,7 @@ TEST_CASE("Test table_info pragma", "[pragma]") {
 	// NOT NULL
 	REQUIRE(CHECK_COLUMN(result, 3, {false, false}));
 	// DEFAULT VALUE
-	REQUIRE(CHECK_COLUMN(result, 4, {"1 + 3", "NULL"}));
+	REQUIRE(CHECK_COLUMN(result, 4, {"1 + 3", Value()}));
 	// PRIMARY KEY
 	REQUIRE(CHECK_COLUMN(result, 5, {false, false}));
 
diff --git a/tools/jdbc/src/test/java/nl/cwi/da/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/nl/cwi/da/duckdb/test/TestDuckDBJDBC.java
index 999d1b92e76f..0395cf050f80 100644
--- a/tools/jdbc/src/test/java/nl/cwi/da/duckdb/test/TestDuckDBJDBC.java
+++ b/tools/jdbc/src/test/java/nl/cwi/da/duckdb/test/TestDuckDBJDBC.java
@@ -1,5 +1,7 @@
 package nl.cwi.da.duckdb.test;
 
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 import java.sql.Connection;
 import java.sql.DriverManager;
 import java.sql.ResultSet;
@@ -341,13 +343,89 @@ public static void test_big_data() throws Exception {
 		conn.close();
 	}
 
+	public static void test_crash_bug496() throws Exception {
+		Connection conn = DriverManager.getConnection("jdbc:duckdb:");
+		Statement stmt = conn.createStatement();
+
+		stmt.execute("CREATE TABLE t0(c0 BOOLEAN, c1 INT)");
+		stmt.execute("CREATE INDEX i0 ON t0(c1, c0)");
+		stmt.execute("INSERT INTO t0(c1) VALUES (0)");
+		stmt.close();
+		conn.close();
+	}
+
+	public static void test_tablepragma_bug491() throws Exception {
+		Connection conn = DriverManager.getConnection("jdbc:duckdb:");
+		Statement stmt = conn.createStatement();
+
+		stmt.execute("CREATE TABLE t0(c0 INT)");
+
+		ResultSet rs = stmt.executeQuery("PRAGMA table_info('t0')");
+		assertTrue(rs.next());
+
+		assertEquals(rs.getInt("cid"), 0);
+		assertEquals(rs.getString("name"), "c0");
+		assertEquals(rs.getString("type"), "INTEGER");
+		assertEquals(rs.getBoolean("notnull"), false);
+		rs.getObject("dflt_value");
+		assertTrue(rs.wasNull());
+		assertEquals(rs.getBoolean("pk"), false);
+
+		assertFalse(rs.next());
+		rs.close();
+		stmt.close();
+		conn.close();
+	}
+
+	public static void test_nulltruth_bug489() throws Exception {
+		Connection conn = DriverManager.getConnection("jdbc:duckdb:");
+		Statement stmt = conn.createStatement();
+
+		stmt.execute("CREATE TABLE t0(c0 INT)");
+		stmt.execute("INSERT INTO t0(c0) VALUES (0)");
+
+		ResultSet rs = stmt.executeQuery("SELECT * FROM t0 WHERE NOT(NULL OR TRUE)");
+		assertFalse(rs.next());
+
+		rs = stmt.executeQuery("SELECT NOT(NULL OR TRUE)");
+		assertTrue(rs.next());
+		boolean res = rs.getBoolean(1);
+		assertEquals(res, false);
+		assertFalse(rs.wasNull());
+
+		rs.close();
+		stmt.close();
+		conn.close();
+
+	}
+
+	public static void test_empty_prepare_bug500() throws Exception {
+		String fileContent = "CREATE TABLE t0(c0 VARCHAR, c1 DOUBLE);
"
+				+ "CREATE TABLE t1(c0 DOUBLE, PRIMARY KEY(c0));
" + "INSERT INTO t0(c0) VALUES (0), (0), (0), (0);
"
+				+ "INSERT INTO t0(c0) VALUES (NULL), (NULL);
" + "INSERT INTO t1(c0) VALUES (0), (1);
" + "
"
+				+ "SELECT t0.c0 FROM t0, t1;";
+		Connection con = DriverManager.getConnection("jdbc:duckdb:");
+		for (String s : fileContent.split("
")) {
+			try (Statement st = con.createStatement()) {
+				try {
+					st.execute(s);
+				} catch (Exception e) {
+					// e.printStackTrace();
+				}
+			}
+		}
+		con.close();
+
+	}
+
 	public static void main(String[] args) throws Exception {
-		test_connection();
-		test_result();
-		test_empty_table();
-		test_broken_next();
-		test_multiple_connections();
-		test_big_data();
+		// Woo I can do reflection too, take this, JUnit!
+		Method[] methods = TestDuckDBJDBC.class.getMethods();
+		for (Method m : methods) {
+			if (m.getName().startsWith("test_")) {
+				m.invoke(null);
+			}
+		}
 		System.out.println("OK");
 	}
 }
diff --git a/tools/shell/shell-test.py b/tools/shell/shell-test.py
index 4bea66df865c..9a727a38040c 100644
--- a/tools/shell/shell-test.py
+++ b/tools/shell/shell-test.py
@@ -40,6 +40,9 @@ def tf():
 # basic test
 test('select \'asdf\' as a;', out='asdf')
 
+# test pragma
+test("CREATE TABLE t0(c0 INT);PRAGMA table_info('t0');", out='0|c0|INTEGER|false||false')
+
 datafile = tf()
 print("42
84",  file=open(datafile, 'w'))
 test('''
