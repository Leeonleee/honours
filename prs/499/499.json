{
  "repo": "duckdb/duckdb",
  "pull_number": 499,
  "instance_id": "duckdb__duckdb-499",
  "issue_numbers": [
    "490",
    "500",
    "500"
  ],
  "base_commit": "4ad62e9e13f4a1b3c6452bcb4f5f31eac3d86053",
  "patch": "diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex 79a144833922..e4e7b652af0e 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -39,7 +39,8 @@ else()\n       hyperloglog\n       re2\n       miniz\n-      utf8proc)\n+      utf8proc\n+      Threads::Threads)\n \n   add_library(duckdb SHARED ${ALL_OBJECT_FILES})\n   target_link_libraries(duckdb ${DUCKDB_LINK_LIBS})\ndiff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp\nindex 3a01ed265fc9..05ef7a59d93c 100644\n--- a/src/common/types/vector.cpp\n+++ b/src/common/types/vector.cpp\n@@ -152,7 +152,7 @@ void Vector::SetValue(idx_t index, Value val) {\n \t}\n \tswitch (type) {\n \tcase TypeId::BOOL:\n-\t\t((int8_t *)data)[index] = newVal.value_.boolean;\n+\t\t((bool *)data)[index] = newVal.value_.boolean;\n \t\tbreak;\n \tcase TypeId::INT8:\n \t\t((int8_t *)data)[index] = newVal.value_.tinyint;\n@@ -253,7 +253,7 @@ Value Vector::GetValue(idx_t index) const {\n \t}\n \tswitch (type) {\n \tcase TypeId::BOOL:\n-\t\treturn Value::BOOLEAN(((int8_t *)data)[index]);\n+\t\treturn Value::BOOLEAN(((bool *)data)[index]);\n \tcase TypeId::INT8:\n \t\treturn Value::TINYINT(((int8_t *)data)[index]);\n \tcase TypeId::INT16:\ndiff --git a/src/common/vector_operations/boolean_operators.cpp b/src/common/vector_operations/boolean_operators.cpp\nindex 3c6c42643a22..a46e15d0b583 100644\n--- a/src/common/vector_operations/boolean_operators.cpp\n+++ b/src/common/vector_operations/boolean_operators.cpp\n@@ -4,8 +4,6 @@\n // operations AND OR !\n //===--------------------------------------------------------------------===//\n \n-#include \"duckdb/common/operator/boolean_operators.hpp\"\n-\n #include \"duckdb/common/vector_operations/binary_executor.hpp\"\n #include \"duckdb/common/vector_operations/unary_executor.hpp\"\n #include \"duckdb/common/vector_operations/vector_operations.hpp\"\n@@ -16,7 +14,7 @@ using namespace std;\n //===--------------------------------------------------------------------===//\n // AND/OR\n //===--------------------------------------------------------------------===//\n-template <class OP, class NULLOP>\n+template <class OP>\n static void templated_boolean_nullmask(Vector &left, Vector &right, Vector &result, idx_t count) {\n \tassert(left.type == TypeId::BOOL && right.type == TypeId::BOOL && result.type == TypeId::BOOL);\n \n@@ -26,9 +24,9 @@ static void templated_boolean_nullmask(Vector &left, Vector &right, Vector &resu\n \t\tauto ldata = ConstantVector::GetData<bool>(left);\n \t\tauto rdata = ConstantVector::GetData<bool>(right);\n \t\tauto result_data = ConstantVector::GetData<bool>(result);\n-\t\t*result_data = OP::Operation(*ldata, *rdata);\n-\t\tConstantVector::SetNull(\n-\t\t    result, NULLOP::Operation(*ldata, *rdata, ConstantVector::IsNull(left), ConstantVector::IsNull(right)));\n+\n+\t\tbool is_null = OP::Operation(*ldata, *rdata, ConstantVector::IsNull(left), ConstantVector::IsNull(right), *result_data);\n+\t\tConstantVector::SetNull(result, is_null);\n \t} else {\n \t\t// perform generic loop\n \t\tVectorData ldata, rdata;\n@@ -44,26 +42,122 @@ static void templated_boolean_nullmask(Vector &left, Vector &right, Vector &resu\n \t\t\tfor (idx_t i = 0; i < count; i++) {\n \t\t\t\tauto lidx = ldata.sel->get_index(i);\n \t\t\t\tauto ridx = rdata.sel->get_index(i);\n-\t\t\t\tresult_data[i] = OP::Operation(left_data[lidx], right_data[ridx]);\n-\t\t\t\tresult_mask[i] = NULLOP::Operation(left_data[lidx], right_data[ridx], (*ldata.nullmask)[lidx],\n-\t\t\t\t                                   (*rdata.nullmask)[ridx]);\n+\t\t\t\tbool is_null = OP::Operation(left_data[lidx], right_data[ridx], (*ldata.nullmask)[lidx], (*rdata.nullmask)[ridx], result_data[i]);\n+\t\t\t\tresult_mask[i] = is_null;\n \t\t\t}\n \t\t} else {\n \t\t\tfor (idx_t i = 0; i < count; i++) {\n \t\t\t\tauto lidx = ldata.sel->get_index(i);\n \t\t\t\tauto ridx = rdata.sel->get_index(i);\n-\t\t\t\tresult_data[i] = OP::Operation(left_data[lidx], right_data[ridx]);\n+\t\t\t\tresult_data[i] = OP::SimpleOperation(left_data[lidx], right_data[ridx]);\n \t\t\t}\n \t\t}\n \t}\n }\n \n+/*\n+SQL AND Rules:\n+\n+TRUE  AND TRUE   = TRUE\n+TRUE  AND FALSE  = FALSE\n+TRUE  AND NULL   = NULL\n+FALSE AND TRUE   = FALSE\n+FALSE AND FALSE  = FALSE\n+FALSE AND NULL   = FALSE\n+NULL  AND TRUE   = NULL\n+NULL  AND FALSE  = FALSE\n+NULL  AND NULL   = NULL\n+\n+Basically:\n+- Only true if both are true\n+- False if either is false (regardless of NULLs)\n+- NULL otherwise\n+*/\n+struct TernaryAnd {\n+\tstatic bool SimpleOperation(bool left, bool right) {\n+\t\treturn left && right;\n+\t}\n+\tstatic bool Operation(bool left, bool right, bool left_null, bool right_null, bool &result) {\n+\t\tif (left_null && right_null) {\n+\t\t\t// both NULL:\n+\t\t\t// result is NULL\n+\t\t\treturn true;\n+\t\t} else if (left_null) {\n+\t\t\t// left is NULL:\n+\t\t\t// result is FALSE if right is false\n+\t\t\t// result is NULL if right is true\n+\t\t\tresult = right;\n+\t\t\treturn right;\n+\t\t} else if (right_null) {\n+\t\t\t// right is NULL:\n+\t\t\t// result is FALSE if left is false\n+\t\t\t// result is NULL if left is true\n+\t\t\tresult = left;\n+\t\t\treturn left;\n+\t\t} else {\n+\t\t\t// no NULL: perform the AND\n+\t\t\tresult = left && right;\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+};\n+\n void VectorOperations::And(Vector &left, Vector &right, Vector &result, idx_t count) {\n-\ttemplated_boolean_nullmask<duckdb::And, duckdb::AndMask>(left, right, result, count);\n+\ttemplated_boolean_nullmask<TernaryAnd>(left, right, result, count);\n }\n \n+/*\n+SQL OR Rules:\n+\n+OR\n+TRUE  OR TRUE  = TRUE\n+TRUE  OR FALSE = TRUE\n+TRUE  OR NULL  = TRUE\n+FALSE OR TRUE  = TRUE\n+FALSE OR FALSE = FALSE\n+FALSE OR NULL  = NULL\n+NULL  OR TRUE  = TRUE\n+NULL  OR FALSE = NULL\n+NULL  OR NULL  = NULL\n+\n+Basically:\n+- Only false if both are false\n+- True if either is true (regardless of NULLs)\n+- NULL otherwise\n+*/\n+\n+struct TernaryOr {\n+\tstatic bool SimpleOperation(bool left, bool right) {\n+\t\treturn left || right;\n+\t}\n+\tstatic bool Operation(bool left, bool right, bool left_null, bool right_null, bool &result) {\n+\t\tif (left_null && right_null) {\n+\t\t\t// both NULL:\n+\t\t\t// result is NULL\n+\t\t\treturn true;\n+\t\t} else if (left_null) {\n+\t\t\t// left is NULL:\n+\t\t\t// result is TRUE if right is true\n+\t\t\t// result is NULL if right is false\n+\t\t\tresult = right;\n+\t\t\treturn !right;\n+\t\t} else if (right_null) {\n+\t\t\t// right is NULL:\n+\t\t\t// result is TRUE if left is true\n+\t\t\t// result is NULL if left is false\n+\t\t\tresult = left;\n+\t\t\treturn !left;\n+\t\t} else {\n+\t\t\t// no NULL: perform the OR\n+\t\t\tresult = left || right;\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+};\n+\n+\n void VectorOperations::Or(Vector &left, Vector &right, Vector &result, idx_t count) {\n-\ttemplated_boolean_nullmask<duckdb::Or, duckdb::OrMask>(left, right, result, count);\n+\ttemplated_boolean_nullmask<TernaryOr>(left, right, result, count);\n }\n \n struct NotOperator {\ndiff --git a/src/execution/merge_join/merge_join.cpp b/src/execution/merge_join/merge_join.cpp\nindex 575fe5f29eb4..fbcc633d0a9a 100644\n--- a/src/execution/merge_join/merge_join.cpp\n+++ b/src/execution/merge_join/merge_join.cpp\n@@ -7,6 +7,7 @@ using namespace std;\n \n template <class MJ, class L_ARG, class R_ARG> static idx_t merge_join(L_ARG &l, R_ARG &r) {\n \tswitch (l.type) {\n+\tcase TypeId::BOOL:\n \tcase TypeId::INT8:\n \t\treturn MJ::template Operation<int8_t>(l, r);\n \tcase TypeId::INT16:\ndiff --git a/src/execution/operator/join/physical_piecewise_merge_join.cpp b/src/execution/operator/join/physical_piecewise_merge_join.cpp\nindex bd607cf210db..7f1587f06a4c 100644\n--- a/src/execution/operator/join/physical_piecewise_merge_join.cpp\n+++ b/src/execution/operator/join/physical_piecewise_merge_join.cpp\n@@ -285,6 +285,7 @@ void OrderVector(Vector &vector, idx_t count, MergeOrder &order) {\n \torder.count = not_null_count;\n \torder.order.Initialize(STANDARD_VECTOR_SIZE);\n \tswitch (vector.type) {\n+\tcase TypeId::BOOL:\n \tcase TypeId::INT8:\n \t\ttemplated_quicksort<int8_t>(vdata, not_null, not_null_count, order.order);\n \t\tbreak;\ndiff --git a/src/function/table/sqlite/pragma_table_info.cpp b/src/function/table/sqlite/pragma_table_info.cpp\nindex 29eb99529029..68262a3b66f2 100644\n--- a/src/function/table/sqlite/pragma_table_info.cpp\n+++ b/src/function/table/sqlite/pragma_table_info.cpp\n@@ -69,8 +69,8 @@ static void pragma_table_info_table(PragmaTableFunctionData &data, TableCatalogE\n \t\t// FIXME: look at constraints\n \t\toutput.SetValue(3, index, Value::BOOLEAN(false));\n \t\t// \"dflt_value\", TypeId::VARCHAR\n-\t\tstring def_value = column.default_value ? column.default_value->ToString() : \"NULL\";\n-\t\toutput.SetValue(4, index, Value(def_value));\n+\t\tValue def_value = column.default_value ? Value(column.default_value->ToString()) : Value();\n+\t\toutput.SetValue(4, index, def_value);\n \t\t// \"pk\", TypeId::BOOL\n \t\t// FIXME: look at constraints\n \t\toutput.SetValue(5, index, Value::BOOLEAN(false));\ndiff --git a/src/include/duckdb/common/operator/boolean_operators.hpp b/src/include/duckdb/common/operator/boolean_operators.hpp\ndeleted file mode 100644\nindex 2155e36e1b0e..000000000000\n--- a/src/include/duckdb/common/operator/boolean_operators.hpp\n+++ /dev/null\n@@ -1,73 +0,0 @@\n-//===----------------------------------------------------------------------===//\n-//                         DuckDB\n-//\n-// duckdb/common/operator/boolean_operators.hpp\n-//\n-//\n-//===----------------------------------------------------------------------===//\n-\n-#pragma once\n-\n-namespace duckdb {\n-\n-/*\n-SQL AND Rules:\n-\n-TRUE  AND TRUE   = TRUE\n-TRUE  AND FALSE  = FALSE\n-TRUE  AND NULL   = NULL\n-FALSE AND TRUE   = FALSE\n-FALSE AND FALSE  = FALSE\n-FALSE AND NULL   = FALSE\n-NULL  AND TRUE   = NULL\n-NULL  AND FALSE  = FALSE\n-NULL  AND NULL   = NULL\n-\n-Basically:\n-- Only true if both are true\n-- False if either is false (regardless of NULLs)\n-- NULL otherwise\n-*/\n-struct And {\n-\tstatic inline bool Operation(bool left, bool right) {\n-\t\treturn left && right;\n-\t}\n-};\n-\n-struct AndMask {\n-\tstatic inline bool Operation(bool left, bool right, bool left_null, bool right_null) {\n-\t\treturn (left_null && (right_null || right)) || (right_null && left);\n-\t}\n-};\n-\n-/*\n-SQL OR Rules:\n-\n-OR\n-TRUE  OR TRUE  = TRUE\n-TRUE  OR FALSE = TRUE\n-TRUE  OR NULL  = TRUE\n-FALSE OR TRUE  = TRUE\n-FALSE OR FALSE = FALSE\n-FALSE OR NULL  = NULL\n-NULL  OR TRUE  = TRUE\n-NULL  OR FALSE = NULL\n-NULL  OR NULL  = NULL\n-\n-Basically:\n-- Only false if both are false\n-- True if either is true (regardless of NULLs)\n-- NULL otherwise\n-*/\n-struct Or {\n-\tstatic inline bool Operation(bool left, bool right) {\n-\t\treturn left || right;\n-\t}\n-};\n-\n-struct OrMask {\n-\tstatic inline bool Operation(bool left, bool right, bool left_null, bool right_null) {\n-\t\treturn (left_null && (right_null || !right)) || (right_null && !left);\n-\t}\n-};\n-} // namespace duckdb\ndiff --git a/src/optimizer/filter_combiner.cpp b/src/optimizer/filter_combiner.cpp\nindex 245f7f52fff1..300af4b2bdec 100644\n--- a/src/optimizer/filter_combiner.cpp\n+++ b/src/optimizer/filter_combiner.cpp\n@@ -303,6 +303,9 @@ FilterResult FilterCombiner::AddFilter(Expression *expr) {\n \t\t// get the LHS and RHS nodes\n \t\tauto left_node = GetNode(comparison.left.get());\n \t\tauto right_node = GetNode(comparison.right.get());\n+\t\tif (BaseExpression::Equals(left_node, right_node)) {\n+\t\t\treturn FilterResult::UNSUPPORTED;\n+\t\t}\n \t\t// get the equivalence sets of the LHS and RHS\n \t\tauto left_equivalence_set = GetEquivalenceSet(left_node);\n \t\tauto right_equivalence_set = GetEquivalenceSet(right_node);\ndiff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp\nindex 0ce5c2c7e2b8..903be04607b7 100644\n--- a/tools/jdbc/src/jni/duckdb_java.cpp\n+++ b/tools/jdbc/src/jni/duckdb_java.cpp\n@@ -210,6 +210,9 @@ JNIEXPORT jobjectArray JNICALL Java_nl_cwi_da_duckdb_DuckDBNative_duckdb_1jdbc_1\n \t\tcase TypeId::VARCHAR:\n \t\t\tvarlen_data = env->NewObjectArray(row_count, env->FindClass(\"java/lang/String\"), nullptr);\n \t\t\tfor (idx_t row_idx = 0; row_idx < row_count; row_idx++) {\n+\t\t\t\tif (FlatVector::Nullmask(vec)[row_idx]) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \t\t\t\tenv->SetObjectArrayElement(\n \t\t\t\t    varlen_data, row_idx, env->NewStringUTF(((string_t *)FlatVector::GetData(vec))[row_idx].GetData()));\n \t\t\t}\ndiff --git a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBConnection.java b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBConnection.java\nindex 773f299c762f..b393c9872d68 100644\n--- a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBConnection.java\n+++ b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBConnection.java\n@@ -48,8 +48,13 @@ public void rollback() throws SQLException {\n \t\ts.execute(\"ROLLBACK\");\n \t\ts.close();\n \t}\n+\t\n+\tprotected void finalize() throws Throwable {\n+\t\tclose();\n+\t}\n+\n \n-\tpublic void close() throws SQLException {\n+\tpublic synchronized void close() throws SQLException {\n \t\tif (conn_ref != null) {\n \t\t\tDuckDBNative.duckdb_jdbc_disconnect(conn_ref);\n \t\t\tconn_ref = null;\ndiff --git a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBDatabase.java b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBDatabase.java\nindex 76cea9ff439b..0688072eb358 100644\n--- a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBDatabase.java\n+++ b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBDatabase.java\n@@ -16,7 +16,7 @@ public DuckDBDatabase(String url) throws SQLException {\n \t\tdb_ref = DuckDBNative.duckdb_jdbc_startup(db_dir, false);\n \t}\n \t\n-\tprotected void finalize() throws Throwable {\n+\tprotected synchronized void finalize() throws Throwable {\n \t\tif (db_ref != null) {\n \t\t\tDuckDBNative.duckdb_jdbc_shutdown(db_ref);\n \t\t\tdb_ref = null;\ndiff --git a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBResultSet.java b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBResultSet.java\nindex f8fdc10f6ab5..ee0dd2129920 100644\n--- a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBResultSet.java\n+++ b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBResultSet.java\n@@ -79,7 +79,7 @@ public boolean next() throws SQLException {\n \t\treturn true;\n \t}\n \n-\tpublic void close() throws SQLException {\n+\tpublic synchronized void close() throws SQLException {\n \t\tif (result_ref != null) {\n \t\t\tDuckDBNative.duckdb_jdbc_free_result(result_ref);\n \t\t\tresult_ref = null;\n@@ -89,6 +89,10 @@ public void close() throws SQLException {\n \t\tcurrent_chunk = null;\n \t}\n \n+\tprotected void finalize() throws Throwable {\n+\t\tclose();\n+\t}\n+\n \tpublic boolean isClosed() throws SQLException {\n \t\treturn result_ref == null;\n \t}\ndiff --git a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBStatement.java b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBStatement.java\nindex 0d49b86c3104..4e548aa5b7ab 100644\n--- a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBStatement.java\n+++ b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBStatement.java\n@@ -19,6 +19,8 @@ public DuckDBStatement(DuckDBConnection conn) {\n \t}\n \n \tpublic boolean execute(String sql) throws SQLException {\n+\t\tresult = null;\n+\t\tstmt_ref = null;\n \t\tstmt_ref = DuckDBNative.duckdb_jdbc_prepare(conn.conn_ref, sql);\n \t\tObject[] params = {};\n \t\tByteBuffer result_ref = DuckDBNative.duckdb_jdbc_execute(stmt_ref, params);\n@@ -48,12 +50,17 @@ public int executeUpdate(String sql) throws SQLException {\n \t\treturn affected;\n \t}\n \n-\tpublic void close() throws SQLException {\n+\tpublic synchronized void close() throws SQLException {\n \t\tif (stmt_ref != null) {\n \t\t\tDuckDBNative.duckdb_jdbc_release(stmt_ref);\n \t\t\tstmt_ref = null;\n \t\t}\n \t\tconn = null;\n+\t\tresult = null;\n+\t}\n+\n+\tprotected void finalize() throws Throwable {\n+\t\tclose();\n \t}\n \n \tpublic boolean isClosed() throws SQLException {\ndiff --git a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\nindex 05f6f9beb61b..91d89ba38914 100644\n--- a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n+++ b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n@@ -172,6 +172,7 @@ bool sqlite3_display_result(StatementType type) {\n \tswitch (type) {\n \tcase StatementType::EXECUTE:\n \tcase StatementType::EXPLAIN:\n+\tcase StatementType::PRAGMA:\n \tcase StatementType::SELECT:\n \t\treturn true;\n \tdefault:\n",
  "test_patch": "diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt\nindex bdc4c04d98dc..ac52b7734889 100644\n--- a/test/CMakeLists.txt\n+++ b/test/CMakeLists.txt\n@@ -14,6 +14,7 @@ add_subdirectory(sql)\n add_subdirectory(planner)\n add_subdirectory(optimizer)\n add_subdirectory(parser)\n+add_subdirectory(rigger)\n \n if(NOT WIN32 AND NOT SUN)\n   add_subdirectory(sqlserver)\ndiff --git a/test/rigger/CMakeLists.txt b/test/rigger/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..0bc50c18417e\n--- /dev/null\n+++ b/test/rigger/CMakeLists.txt\n@@ -0,0 +1,4 @@\n+add_library_unity(test_rigger OBJECT test_rigger.cpp)\n+set(ALL_OBJECT_FILES\n+    ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:test_rigger>\n+    PARENT_SCOPE)\ndiff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp\nnew file mode 100644\nindex 000000000000..2e5de0f5c93b\n--- /dev/null\n+++ b/test/rigger/test_rigger.cpp\n@@ -0,0 +1,78 @@\n+#include \"catch.hpp\"\n+#include \"test_helpers.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n+\tunique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\tcon.EnableQueryVerification();\n+\n+\tSECTION(\"489\") {\n+\t\t// A predicate NOT(NULL OR TRUE) unexpectedly evaluates to TRUE\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE NOT(NULL OR TRUE);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t\tresult = con.Query(\"SELECT NULL OR TRUE;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {true}));\n+\t\tresult = con.Query(\"SELECT NOT(NULL OR TRUE);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {false}));\n+\t}\n+\tSECTION(\"490\") {\n+\t\t// A comparison column=column unexpectedly evaluates to TRUE for column=NULL\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (NULL);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE c0 = c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t}\n+\tSECTION(\"491\") {\n+\t\t// PRAGMA table_info provides no output\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tresult = con.Query(\"PRAGMA table_info('t0');\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {0}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {\"c0\"}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 2, {\"INTEGER\"}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 3, {false}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 4, {Value()}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 5, {false}));\n+\t\tresult = con.Query(\"SELECT * FROM pragma_table_info('t0');\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {0}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {\"c0\"}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 2, {\"INTEGER\"}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 3, {false}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 4, {Value()}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 5, {false}));\n+\t}\n+\tSECTION(\"493\") {\n+\t\t// SIMILAR TO results in an \"Unknown error -1\n+\t\tresult = con.Query(\"SELECT '' SIMILAR TO '';\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {true}));\n+\t}\n+\tSECTION(\"495\") {\n+\t\t// Comparison on UNIQUE NUMERIC column causes a query to omit a row in the result set\n+\t\t// REQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 NUMERIC UNIQUE);\"));\n+\t\t// REQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (1163404482), (0), (488566);\"));\n+\t\t// result = con.Query(\"SELECT * FROM t0 WHERE c0 > 0.1 ORDER BY 1;\");\n+\t\t// REQUIRE(CHECK_COLUMN(result, 0, {488566, 1163404482}));\n+\t\t// result = con.Query(\"SELECT * FROM t0 WHERE c0 >= 0.1 ORDER BY 1;\");\n+\t\t// REQUIRE(CHECK_COLUMN(result, 0, {488566, 1163404482}));\n+\t\t// result = con.Query(\"SELECT * FROM t0 WHERE 0.1 < c0 ORDER BY 1;\");\n+\t\t// REQUIRE(CHECK_COLUMN(result, 0, {488566, 1163404482}));\n+\t\t// result = con.Query(\"SELECT * FROM t0 WHERE 0.1 <= c0 ORDER BY 1;\");\n+\t\t// REQUIRE(CHECK_COLUMN(result, 0, {488566, 1163404482}));\n+\t}\n+\tSECTION(\"497\") {\n+\t\t// Comparison of two boolean columns in different tables results in an error \"Not implemented: Unimplemented type for sort\"\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 BOOL);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 BOOL);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1(c0) VALUES (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0);\"));\n+\t\tresult = con.Query(\"SELECT t0.c0 FROM t0, t1 WHERE t1.c0 < t0.c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t}\n+\n+\n+}\ndiff --git a/test/sql/function/test_table_function.cpp b/test/sql/function/test_table_function.cpp\nindex a4590ebcd6ae..4b731327ee41 100644\n--- a/test/sql/function/test_table_function.cpp\n+++ b/test/sql/function/test_table_function.cpp\n@@ -18,7 +18,7 @@ TEST_CASE(\"Table functions\", \"[function]\") {\n \tREQUIRE(CHECK_COLUMN(result, 1, {\"i\", \"j\"}));\n \tREQUIRE(CHECK_COLUMN(result, 2, {\"INTEGER\", \"INTEGER\"}));\n \tREQUIRE(CHECK_COLUMN(result, 3, {false, false}));\n-\tREQUIRE(CHECK_COLUMN(result, 4, {\"NULL\", \"NULL\"}));\n+\tREQUIRE(CHECK_COLUMN(result, 4, {Value(), Value()}));\n \tREQUIRE(CHECK_COLUMN(result, 5, {false, false}));\n \n \t// project single column\ndiff --git a/test/sql/index/test_art_keys.cpp b/test/sql/index/test_art_keys.cpp\nindex a144558108e1..aeea1a59fb36 100644\n--- a/test/sql/index/test_art_keys.cpp\n+++ b/test/sql/index/test_art_keys.cpp\n@@ -150,6 +150,16 @@ TEST_CASE(\"Test correct functioning of art keys\", \"[art]\") {\n \tTestKeys(keys);\n \n \tkeys.clear();\n+\n+\tkeys.push_back(Key::CreateKey<double>(0, is_little_endian));\n+\tkeys.push_back(Key::CreateKey<double>(0.1, is_little_endian));\n+\tkeys.push_back(Key::CreateKey<double>(488566, is_little_endian));\n+\tkeys.push_back(Key::CreateKey<double>(1163404482, is_little_endian));\n+\n+\tTestKeys(keys);\n+\n+\tkeys.clear();\n+\n }\n \n TEST_CASE(\"Test correct functioning of art EncodeFloat/EncodeDouble\", \"[art-enc]\") {\ndiff --git a/test/sql/pragma/test_show_tables.cpp b/test/sql/pragma/test_show_tables.cpp\nindex 165122fbf9c8..5ad35e1a6590 100644\n--- a/test/sql/pragma/test_show_tables.cpp\n+++ b/test/sql/pragma/test_show_tables.cpp\n@@ -27,7 +27,7 @@ TEST_CASE(\"Test SHOW/DESCRIBE tables\", \"[pragma]\") {\n \tREQUIRE(CHECK_COLUMN(result, 1, {\"INTEGER\", \"INTEGER\"}));\n \tREQUIRE(CHECK_COLUMN(result, 2, {\"YES\", \"YES\"}));\n \tREQUIRE(CHECK_COLUMN(result, 3, {Value(), Value()}));\n-\tREQUIRE(CHECK_COLUMN(result, 4, {\"NULL\", \"NULL\"}));\n+\tREQUIRE(CHECK_COLUMN(result, 4, {Value(), Value()}));\n \tREQUIRE(CHECK_COLUMN(result, 5, {Value(), Value()}));\n \t// equivalent to PRAGMA SHOW('integers')\n \tresult = con.Query(\"PRAGMA SHOW('integers')\");\n@@ -36,7 +36,7 @@ TEST_CASE(\"Test SHOW/DESCRIBE tables\", \"[pragma]\") {\n \tREQUIRE(CHECK_COLUMN(result, 1, {\"INTEGER\", \"INTEGER\"}));\n \tREQUIRE(CHECK_COLUMN(result, 2, {\"YES\", \"YES\"}));\n \tREQUIRE(CHECK_COLUMN(result, 3, {Value(), Value()}));\n-\tREQUIRE(CHECK_COLUMN(result, 4, {\"NULL\", \"NULL\"}));\n+\tREQUIRE(CHECK_COLUMN(result, 4, {Value(), Value()}));\n \tREQUIRE(CHECK_COLUMN(result, 5, {Value(), Value()}));\n \n \t// we can also describe views\ndiff --git a/test/sql/pragma/test_table_info.cpp b/test/sql/pragma/test_table_info.cpp\nindex 83c32065d382..57215d79ce26 100644\n--- a/test/sql/pragma/test_table_info.cpp\n+++ b/test/sql/pragma/test_table_info.cpp\n@@ -23,7 +23,7 @@ TEST_CASE(\"Test table_info pragma\", \"[pragma]\") {\n \t// NOT NULL\n \tREQUIRE(CHECK_COLUMN(result, 3, {false, false}));\n \t// DEFAULT VALUE\n-\tREQUIRE(CHECK_COLUMN(result, 4, {\"1 + 3\", \"NULL\"}));\n+\tREQUIRE(CHECK_COLUMN(result, 4, {\"1 + 3\", Value()}));\n \t// PRIMARY KEY\n \tREQUIRE(CHECK_COLUMN(result, 5, {false, false}));\n \ndiff --git a/tools/jdbc/src/test/java/nl/cwi/da/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/nl/cwi/da/duckdb/test/TestDuckDBJDBC.java\nindex 999d1b92e76f..0395cf050f80 100644\n--- a/tools/jdbc/src/test/java/nl/cwi/da/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/nl/cwi/da/duckdb/test/TestDuckDBJDBC.java\n@@ -1,5 +1,7 @@\n package nl.cwi.da.duckdb.test;\n \n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n import java.sql.Connection;\n import java.sql.DriverManager;\n import java.sql.ResultSet;\n@@ -341,13 +343,89 @@ public static void test_big_data() throws Exception {\n \t\tconn.close();\n \t}\n \n+\tpublic static void test_crash_bug496() throws Exception {\n+\t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\tStatement stmt = conn.createStatement();\n+\n+\t\tstmt.execute(\"CREATE TABLE t0(c0 BOOLEAN, c1 INT)\");\n+\t\tstmt.execute(\"CREATE INDEX i0 ON t0(c1, c0)\");\n+\t\tstmt.execute(\"INSERT INTO t0(c1) VALUES (0)\");\n+\t\tstmt.close();\n+\t\tconn.close();\n+\t}\n+\n+\tpublic static void test_tablepragma_bug491() throws Exception {\n+\t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\tStatement stmt = conn.createStatement();\n+\n+\t\tstmt.execute(\"CREATE TABLE t0(c0 INT)\");\n+\n+\t\tResultSet rs = stmt.executeQuery(\"PRAGMA table_info('t0')\");\n+\t\tassertTrue(rs.next());\n+\n+\t\tassertEquals(rs.getInt(\"cid\"), 0);\n+\t\tassertEquals(rs.getString(\"name\"), \"c0\");\n+\t\tassertEquals(rs.getString(\"type\"), \"INTEGER\");\n+\t\tassertEquals(rs.getBoolean(\"notnull\"), false);\n+\t\trs.getObject(\"dflt_value\");\n+\t\tassertTrue(rs.wasNull());\n+\t\tassertEquals(rs.getBoolean(\"pk\"), false);\n+\n+\t\tassertFalse(rs.next());\n+\t\trs.close();\n+\t\tstmt.close();\n+\t\tconn.close();\n+\t}\n+\n+\tpublic static void test_nulltruth_bug489() throws Exception {\n+\t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\tStatement stmt = conn.createStatement();\n+\n+\t\tstmt.execute(\"CREATE TABLE t0(c0 INT)\");\n+\t\tstmt.execute(\"INSERT INTO t0(c0) VALUES (0)\");\n+\n+\t\tResultSet rs = stmt.executeQuery(\"SELECT * FROM t0 WHERE NOT(NULL OR TRUE)\");\n+\t\tassertFalse(rs.next());\n+\n+\t\trs = stmt.executeQuery(\"SELECT NOT(NULL OR TRUE)\");\n+\t\tassertTrue(rs.next());\n+\t\tboolean res = rs.getBoolean(1);\n+\t\tassertEquals(res, false);\n+\t\tassertFalse(rs.wasNull());\n+\n+\t\trs.close();\n+\t\tstmt.close();\n+\t\tconn.close();\n+\n+\t}\n+\n+\tpublic static void test_empty_prepare_bug500() throws Exception {\n+\t\tString fileContent = \"CREATE TABLE t0(c0 VARCHAR, c1 DOUBLE);\\n\"\n+\t\t\t\t+ \"CREATE TABLE t1(c0 DOUBLE, PRIMARY KEY(c0));\\n\" + \"INSERT INTO t0(c0) VALUES (0), (0), (0), (0);\\n\"\n+\t\t\t\t+ \"INSERT INTO t0(c0) VALUES (NULL), (NULL);\\n\" + \"INSERT INTO t1(c0) VALUES (0), (1);\\n\" + \"\\n\"\n+\t\t\t\t+ \"SELECT t0.c0 FROM t0, t1;\";\n+\t\tConnection con = DriverManager.getConnection(\"jdbc:duckdb:\");\n+\t\tfor (String s : fileContent.split(\"\\n\")) {\n+\t\t\ttry (Statement st = con.createStatement()) {\n+\t\t\t\ttry {\n+\t\t\t\t\tst.execute(s);\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t// e.printStackTrace();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tcon.close();\n+\n+\t}\n+\n \tpublic static void main(String[] args) throws Exception {\n-\t\ttest_connection();\n-\t\ttest_result();\n-\t\ttest_empty_table();\n-\t\ttest_broken_next();\n-\t\ttest_multiple_connections();\n-\t\ttest_big_data();\n+\t\t// Woo I can do reflection too, take this, JUnit!\n+\t\tMethod[] methods = TestDuckDBJDBC.class.getMethods();\n+\t\tfor (Method m : methods) {\n+\t\t\tif (m.getName().startsWith(\"test_\")) {\n+\t\t\t\tm.invoke(null);\n+\t\t\t}\n+\t\t}\n \t\tSystem.out.println(\"OK\");\n \t}\n }\ndiff --git a/tools/shell/shell-test.py b/tools/shell/shell-test.py\nindex 4bea66df865c..9a727a38040c 100644\n--- a/tools/shell/shell-test.py\n+++ b/tools/shell/shell-test.py\n@@ -40,6 +40,9 @@ def tf():\n # basic test\n test('select \\'asdf\\' as a;', out='asdf')\n \n+# test pragma\n+test(\"CREATE TABLE t0(c0 INT);PRAGMA table_info('t0');\", out='0|c0|INTEGER|false||false')\n+\n datafile = tf()\n print(\"42\\n84\",  file=open(datafile, 'w'))\n test('''\n",
  "problem_statement": "A comparison column=column unexpectedly evaluates to TRUE for column=NULL\nConsider the following statements:\r\n\r\n```sql\r\nCREATE TABLE t0(c0 INT);\r\nINSERT INTO t0(c0) VALUES (NULL);\r\nSELECT * FROM t0 WHERE c0 = c0; -- expected: {}, actual: {NULL}\r\n```\r\nUnexpectedly, the `SELECT` fetches a row. This is unexpected, since the value of `c0` is `NULL` and `NULL = NULL` should evaluate to `NULL`, and thus fetch no rows.\r\n\r\nI found this bug based on commit bc9f086b9fcffb058763a6d1723da01127cd9100.\nSELECT causes JDBC driver to crash\nConsider the following statements (note that the newline is significiant):\r\n\r\n```sql\r\nCREATE TABLE t0(c0 VARCHAR, c1 DOUBLE);\r\nCREATE TABLE t1(c0 DOUBLE, PRIMARY KEY(c0));\r\nINSERT INTO t0(c0) VALUES (0), (0), (0), (0);\r\nINSERT INTO t0(c0) VALUES (NULL), (NULL);\r\nINSERT INTO t1(c0) VALUES (0), (1);\r\n\r\nSELECT t0.c0 FROM t0, t1; -- A fatal error has been detected by the Java Runtime Environment\r\n```\r\n\r\nWhen executing the statements using the Java code below, the JVM crashes:\r\n\r\n```java\r\nConnection con = DriverManager.getConnection(\"jdbc:duckdb:\");\r\nfor (String s : fileContent.split(\"\\n\")) {\r\n    try (Statement st = con.createStatement()) {\r\n        try {\r\n            st.execute(s);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\ncon.close();\r\n```\r\n\r\nNote that for the newline, the following exception is thrown:\r\n```\r\njava.sql.SQLException: No statement to prepare!\r\n\tat nl.cwi.da.duckdb.DuckDBNative.duckdb_jdbc_prepare(Native Method)\r\n\tat nl.cwi.da.duckdb.DuckDBStatement.execute(DuckDBStatement.java:22)\r\n\tat reproduce.ExecuteDuckDB$2.run(ExecuteDuckDB.java:51)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\n```\r\nThe original test case that crashed the JVM did not have a newline in it.\r\n\r\nThe logs suggest that the following was executed during the crash:\r\n```\r\nj  nl.cwi.da.duckdb.DuckDBNative.duckdb_jdbc_fetch(Ljava/nio/ByteBuffer;)[Lnl/cwi/da/duckdb/DuckDBVector;+0\r\nj  nl.cwi.da.duckdb.DuckDBResultSet.<init>(Lnl/cwi/da/duckdb/DuckDBStatement;Ljava/nio/ByteBuffer;)V+34\r\nj  nl.cwi.da.duckdb.DuckDBStatement.execute(Ljava/lang/String;)Z+36\r\n```\r\nI found this bug based on commit c2ce42268b23967de165a0c54460b6c974c5e3e1.\nSELECT causes JDBC driver to crash\nConsider the following statements (note that the newline is significiant):\r\n\r\n```sql\r\nCREATE TABLE t0(c0 VARCHAR, c1 DOUBLE);\r\nCREATE TABLE t1(c0 DOUBLE, PRIMARY KEY(c0));\r\nINSERT INTO t0(c0) VALUES (0), (0), (0), (0);\r\nINSERT INTO t0(c0) VALUES (NULL), (NULL);\r\nINSERT INTO t1(c0) VALUES (0), (1);\r\n\r\nSELECT t0.c0 FROM t0, t1; -- A fatal error has been detected by the Java Runtime Environment\r\n```\r\n\r\nWhen executing the statements using the Java code below, the JVM crashes:\r\n\r\n```java\r\nConnection con = DriverManager.getConnection(\"jdbc:duckdb:\");\r\nfor (String s : fileContent.split(\"\\n\")) {\r\n    try (Statement st = con.createStatement()) {\r\n        try {\r\n            st.execute(s);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\ncon.close();\r\n```\r\n\r\nNote that for the newline, the following exception is thrown:\r\n```\r\njava.sql.SQLException: No statement to prepare!\r\n\tat nl.cwi.da.duckdb.DuckDBNative.duckdb_jdbc_prepare(Native Method)\r\n\tat nl.cwi.da.duckdb.DuckDBStatement.execute(DuckDBStatement.java:22)\r\n\tat reproduce.ExecuteDuckDB$2.run(ExecuteDuckDB.java:51)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\n```\r\nThe original test case that crashed the JVM did not have a newline in it.\r\n\r\nThe logs suggest that the following was executed during the crash:\r\n```\r\nj  nl.cwi.da.duckdb.DuckDBNative.duckdb_jdbc_fetch(Ljava/nio/ByteBuffer;)[Lnl/cwi/da/duckdb/DuckDBVector;+0\r\nj  nl.cwi.da.duckdb.DuckDBResultSet.<init>(Lnl/cwi/da/duckdb/DuckDBStatement;Ljava/nio/ByteBuffer;)V+34\r\nj  nl.cwi.da.duckdb.DuckDBStatement.execute(Ljava/lang/String;)Z+36\r\n```\r\nI found this bug based on commit c2ce42268b23967de165a0c54460b6c974c5e3e1.\n",
  "hints_text": "\n\n",
  "created_at": "2020-04-09T07:56:02Z"
}