diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 79a144833922..e4e7b652af0e 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -39,7 +39,8 @@ else()
       hyperloglog
       re2
       miniz
-      utf8proc)
+      utf8proc
+      Threads::Threads)
 
   add_library(duckdb SHARED ${ALL_OBJECT_FILES})
   target_link_libraries(duckdb ${DUCKDB_LINK_LIBS})
diff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp
index 3a01ed265fc9..05ef7a59d93c 100644
--- a/src/common/types/vector.cpp
+++ b/src/common/types/vector.cpp
@@ -152,7 +152,7 @@ void Vector::SetValue(idx_t index, Value val) {
 	}
 	switch (type) {
 	case TypeId::BOOL:
-		((int8_t *)data)[index] = newVal.value_.boolean;
+		((bool *)data)[index] = newVal.value_.boolean;
 		break;
 	case TypeId::INT8:
 		((int8_t *)data)[index] = newVal.value_.tinyint;
@@ -253,7 +253,7 @@ Value Vector::GetValue(idx_t index) const {
 	}
 	switch (type) {
 	case TypeId::BOOL:
-		return Value::BOOLEAN(((int8_t *)data)[index]);
+		return Value::BOOLEAN(((bool *)data)[index]);
 	case TypeId::INT8:
 		return Value::TINYINT(((int8_t *)data)[index]);
 	case TypeId::INT16:
diff --git a/src/common/vector_operations/boolean_operators.cpp b/src/common/vector_operations/boolean_operators.cpp
index 3c6c42643a22..a46e15d0b583 100644
--- a/src/common/vector_operations/boolean_operators.cpp
+++ b/src/common/vector_operations/boolean_operators.cpp
@@ -4,8 +4,6 @@
 // operations AND OR !
 //===--------------------------------------------------------------------===//
 
-#include "duckdb/common/operator/boolean_operators.hpp"
-
 #include "duckdb/common/vector_operations/binary_executor.hpp"
 #include "duckdb/common/vector_operations/unary_executor.hpp"
 #include "duckdb/common/vector_operations/vector_operations.hpp"
@@ -16,7 +14,7 @@ using namespace std;
 //===--------------------------------------------------------------------===//
 // AND/OR
 //===--------------------------------------------------------------------===//
-template <class OP, class NULLOP>
+template <class OP>
 static void templated_boolean_nullmask(Vector &left, Vector &right, Vector &result, idx_t count) {
 	assert(left.type == TypeId::BOOL && right.type == TypeId::BOOL && result.type == TypeId::BOOL);
 
@@ -26,9 +24,9 @@ static void templated_boolean_nullmask(Vector &left, Vector &right, Vector &resu
 		auto ldata = ConstantVector::GetData<bool>(left);
 		auto rdata = ConstantVector::GetData<bool>(right);
 		auto result_data = ConstantVector::GetData<bool>(result);
-		*result_data = OP::Operation(*ldata, *rdata);
-		ConstantVector::SetNull(
-		    result, NULLOP::Operation(*ldata, *rdata, ConstantVector::IsNull(left), ConstantVector::IsNull(right)));
+
+		bool is_null = OP::Operation(*ldata, *rdata, ConstantVector::IsNull(left), ConstantVector::IsNull(right), *result_data);
+		ConstantVector::SetNull(result, is_null);
 	} else {
 		// perform generic loop
 		VectorData ldata, rdata;
@@ -44,26 +42,122 @@ static void templated_boolean_nullmask(Vector &left, Vector &right, Vector &resu
 			for (idx_t i = 0; i < count; i++) {
 				auto lidx = ldata.sel->get_index(i);
 				auto ridx = rdata.sel->get_index(i);
-				result_data[i] = OP::Operation(left_data[lidx], right_data[ridx]);
-				result_mask[i] = NULLOP::Operation(left_data[lidx], right_data[ridx], (*ldata.nullmask)[lidx],
-				                                   (*rdata.nullmask)[ridx]);
+				bool is_null = OP::Operation(left_data[lidx], right_data[ridx], (*ldata.nullmask)[lidx], (*rdata.nullmask)[ridx], result_data[i]);
+				result_mask[i] = is_null;
 			}
 		} else {
 			for (idx_t i = 0; i < count; i++) {
 				auto lidx = ldata.sel->get_index(i);
 				auto ridx = rdata.sel->get_index(i);
-				result_data[i] = OP::Operation(left_data[lidx], right_data[ridx]);
+				result_data[i] = OP::SimpleOperation(left_data[lidx], right_data[ridx]);
 			}
 		}
 	}
 }
 
+/*
+SQL AND Rules:
+
+TRUE  AND TRUE   = TRUE
+TRUE  AND FALSE  = FALSE
+TRUE  AND NULL   = NULL
+FALSE AND TRUE   = FALSE
+FALSE AND FALSE  = FALSE
+FALSE AND NULL   = FALSE
+NULL  AND TRUE   = NULL
+NULL  AND FALSE  = FALSE
+NULL  AND NULL   = NULL
+
+Basically:
+- Only true if both are true
+- False if either is false (regardless of NULLs)
+- NULL otherwise
+*/
+struct TernaryAnd {
+	static bool SimpleOperation(bool left, bool right) {
+		return left && right;
+	}
+	static bool Operation(bool left, bool right, bool left_null, bool right_null, bool &result) {
+		if (left_null && right_null) {
+			// both NULL:
+			// result is NULL
+			return true;
+		} else if (left_null) {
+			// left is NULL:
+			// result is FALSE if right is false
+			// result is NULL if right is true
+			result = right;
+			return right;
+		} else if (right_null) {
+			// right is NULL:
+			// result is FALSE if left is false
+			// result is NULL if left is true
+			result = left;
+			return left;
+		} else {
+			// no NULL: perform the AND
+			result = left && right;
+			return false;
+		}
+	}
+};
+
 void VectorOperations::And(Vector &left, Vector &right, Vector &result, idx_t count) {
-	templated_boolean_nullmask<duckdb::And, duckdb::AndMask>(left, right, result, count);
+	templated_boolean_nullmask<TernaryAnd>(left, right, result, count);
 }
 
+/*
+SQL OR Rules:
+
+OR
+TRUE  OR TRUE  = TRUE
+TRUE  OR FALSE = TRUE
+TRUE  OR NULL  = TRUE
+FALSE OR TRUE  = TRUE
+FALSE OR FALSE = FALSE
+FALSE OR NULL  = NULL
+NULL  OR TRUE  = TRUE
+NULL  OR FALSE = NULL
+NULL  OR NULL  = NULL
+
+Basically:
+- Only false if both are false
+- True if either is true (regardless of NULLs)
+- NULL otherwise
+*/
+
+struct TernaryOr {
+	static bool SimpleOperation(bool left, bool right) {
+		return left || right;
+	}
+	static bool Operation(bool left, bool right, bool left_null, bool right_null, bool &result) {
+		if (left_null && right_null) {
+			// both NULL:
+			// result is NULL
+			return true;
+		} else if (left_null) {
+			// left is NULL:
+			// result is TRUE if right is true
+			// result is NULL if right is false
+			result = right;
+			return !right;
+		} else if (right_null) {
+			// right is NULL:
+			// result is TRUE if left is true
+			// result is NULL if left is false
+			result = left;
+			return !left;
+		} else {
+			// no NULL: perform the OR
+			result = left || right;
+			return false;
+		}
+	}
+};
+
+
 void VectorOperations::Or(Vector &left, Vector &right, Vector &result, idx_t count) {
-	templated_boolean_nullmask<duckdb::Or, duckdb::OrMask>(left, right, result, count);
+	templated_boolean_nullmask<TernaryOr>(left, right, result, count);
 }
 
 struct NotOperator {
diff --git a/src/execution/merge_join/merge_join.cpp b/src/execution/merge_join/merge_join.cpp
index 575fe5f29eb4..fbcc633d0a9a 100644
--- a/src/execution/merge_join/merge_join.cpp
+++ b/src/execution/merge_join/merge_join.cpp
@@ -7,6 +7,7 @@ using namespace std;
 
 template <class MJ, class L_ARG, class R_ARG> static idx_t merge_join(L_ARG &l, R_ARG &r) {
 	switch (l.type) {
+	case TypeId::BOOL:
 	case TypeId::INT8:
 		return MJ::template Operation<int8_t>(l, r);
 	case TypeId::INT16:
diff --git a/src/execution/operator/join/physical_piecewise_merge_join.cpp b/src/execution/operator/join/physical_piecewise_merge_join.cpp
index bd607cf210db..7f1587f06a4c 100644
--- a/src/execution/operator/join/physical_piecewise_merge_join.cpp
+++ b/src/execution/operator/join/physical_piecewise_merge_join.cpp
@@ -285,6 +285,7 @@ void OrderVector(Vector &vector, idx_t count, MergeOrder &order) {
 	order.count = not_null_count;
 	order.order.Initialize(STANDARD_VECTOR_SIZE);
 	switch (vector.type) {
+	case TypeId::BOOL:
 	case TypeId::INT8:
 		templated_quicksort<int8_t>(vdata, not_null, not_null_count, order.order);
 		break;
diff --git a/src/function/table/sqlite/pragma_table_info.cpp b/src/function/table/sqlite/pragma_table_info.cpp
index 29eb99529029..68262a3b66f2 100644
--- a/src/function/table/sqlite/pragma_table_info.cpp
+++ b/src/function/table/sqlite/pragma_table_info.cpp
@@ -69,8 +69,8 @@ static void pragma_table_info_table(PragmaTableFunctionData &data, TableCatalogE
 		// FIXME: look at constraints
 		output.SetValue(3, index, Value::BOOLEAN(false));
 		// "dflt_value", TypeId::VARCHAR
-		string def_value = column.default_value ? column.default_value->ToString() : "NULL";
-		output.SetValue(4, index, Value(def_value));
+		Value def_value = column.default_value ? Value(column.default_value->ToString()) : Value();
+		output.SetValue(4, index, def_value);
 		// "pk", TypeId::BOOL
 		// FIXME: look at constraints
 		output.SetValue(5, index, Value::BOOLEAN(false));
diff --git a/src/include/duckdb/common/operator/boolean_operators.hpp b/src/include/duckdb/common/operator/boolean_operators.hpp
deleted file mode 100644
index 2155e36e1b0e..000000000000
--- a/src/include/duckdb/common/operator/boolean_operators.hpp
+++ /dev/null
@@ -1,73 +0,0 @@
-//===----------------------------------------------------------------------===//
-//                         DuckDB
-//
-// duckdb/common/operator/boolean_operators.hpp
-//
-//
-//===----------------------------------------------------------------------===//
-
-#pragma once
-
-namespace duckdb {
-
-/*
-SQL AND Rules:
-
-TRUE  AND TRUE   = TRUE
-TRUE  AND FALSE  = FALSE
-TRUE  AND NULL   = NULL
-FALSE AND TRUE   = FALSE
-FALSE AND FALSE  = FALSE
-FALSE AND NULL   = FALSE
-NULL  AND TRUE   = NULL
-NULL  AND FALSE  = FALSE
-NULL  AND NULL   = NULL
-
-Basically:
-- Only true if both are true
-- False if either is false (regardless of NULLs)
-- NULL otherwise
-*/
-struct And {
-	static inline bool Operation(bool left, bool right) {
-		return left && right;
-	}
-};
-
-struct AndMask {
-	static inline bool Operation(bool left, bool right, bool left_null, bool right_null) {
-		return (left_null && (right_null || right)) || (right_null && left);
-	}
-};
-
-/*
-SQL OR Rules:
-
-OR
-TRUE  OR TRUE  = TRUE
-TRUE  OR FALSE = TRUE
-TRUE  OR NULL  = TRUE
-FALSE OR TRUE  = TRUE
-FALSE OR FALSE = FALSE
-FALSE OR NULL  = NULL
-NULL  OR TRUE  = TRUE
-NULL  OR FALSE = NULL
-NULL  OR NULL  = NULL
-
-Basically:
-- Only false if both are false
-- True if either is true (regardless of NULLs)
-- NULL otherwise
-*/
-struct Or {
-	static inline bool Operation(bool left, bool right) {
-		return left || right;
-	}
-};
-
-struct OrMask {
-	static inline bool Operation(bool left, bool right, bool left_null, bool right_null) {
-		return (left_null && (right_null || !right)) || (right_null && !left);
-	}
-};
-} // namespace duckdb
diff --git a/src/optimizer/filter_combiner.cpp b/src/optimizer/filter_combiner.cpp
index 245f7f52fff1..300af4b2bdec 100644
--- a/src/optimizer/filter_combiner.cpp
+++ b/src/optimizer/filter_combiner.cpp
@@ -303,6 +303,9 @@ FilterResult FilterCombiner::AddFilter(Expression *expr) {
 		// get the LHS and RHS nodes
 		auto left_node = GetNode(comparison.left.get());
 		auto right_node = GetNode(comparison.right.get());
+		if (BaseExpression::Equals(left_node, right_node)) {
+			return FilterResult::UNSUPPORTED;
+		}
 		// get the equivalence sets of the LHS and RHS
 		auto left_equivalence_set = GetEquivalenceSet(left_node);
 		auto right_equivalence_set = GetEquivalenceSet(right_node);
diff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp
index 0ce5c2c7e2b8..903be04607b7 100644
--- a/tools/jdbc/src/jni/duckdb_java.cpp
+++ b/tools/jdbc/src/jni/duckdb_java.cpp
@@ -210,6 +210,9 @@ JNIEXPORT jobjectArray JNICALL Java_nl_cwi_da_duckdb_DuckDBNative_duckdb_1jdbc_1
 		case TypeId::VARCHAR:
 			varlen_data = env->NewObjectArray(row_count, env->FindClass("java/lang/String"), nullptr);
 			for (idx_t row_idx = 0; row_idx < row_count; row_idx++) {
+				if (FlatVector::Nullmask(vec)[row_idx]) {
+					continue;
+				}
 				env->SetObjectArrayElement(
 				    varlen_data, row_idx, env->NewStringUTF(((string_t *)FlatVector::GetData(vec))[row_idx].GetData()));
 			}
diff --git a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBConnection.java b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBConnection.java
index 773f299c762f..b393c9872d68 100644
--- a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBConnection.java
+++ b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBConnection.java
@@ -48,8 +48,13 @@ public void rollback() throws SQLException {
 		s.execute("ROLLBACK");
 		s.close();
 	}
+	
+	protected void finalize() throws Throwable {
+		close();
+	}
+
 
-	public void close() throws SQLException {
+	public synchronized void close() throws SQLException {
 		if (conn_ref != null) {
 			DuckDBNative.duckdb_jdbc_disconnect(conn_ref);
 			conn_ref = null;
diff --git a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBDatabase.java b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBDatabase.java
index 76cea9ff439b..0688072eb358 100644
--- a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBDatabase.java
+++ b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBDatabase.java
@@ -16,7 +16,7 @@ public DuckDBDatabase(String url) throws SQLException {
 		db_ref = DuckDBNative.duckdb_jdbc_startup(db_dir, false);
 	}
 	
-	protected void finalize() throws Throwable {
+	protected synchronized void finalize() throws Throwable {
 		if (db_ref != null) {
 			DuckDBNative.duckdb_jdbc_shutdown(db_ref);
 			db_ref = null;
diff --git a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBResultSet.java b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBResultSet.java
index f8fdc10f6ab5..ee0dd2129920 100644
--- a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBResultSet.java
+++ b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBResultSet.java
@@ -79,7 +79,7 @@ public boolean next() throws SQLException {
 		return true;
 	}
 
-	public void close() throws SQLException {
+	public synchronized void close() throws SQLException {
 		if (result_ref != null) {
 			DuckDBNative.duckdb_jdbc_free_result(result_ref);
 			result_ref = null;
@@ -89,6 +89,10 @@ public void close() throws SQLException {
 		current_chunk = null;
 	}
 
+	protected void finalize() throws Throwable {
+		close();
+	}
+
 	public boolean isClosed() throws SQLException {
 		return result_ref == null;
 	}
diff --git a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBStatement.java b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBStatement.java
index 0d49b86c3104..4e548aa5b7ab 100644
--- a/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBStatement.java
+++ b/tools/jdbc/src/main/java/nl/cwi/da/duckdb/DuckDBStatement.java
@@ -19,6 +19,8 @@ public DuckDBStatement(DuckDBConnection conn) {
 	}
 
 	public boolean execute(String sql) throws SQLException {
+		result = null;
+		stmt_ref = null;
 		stmt_ref = DuckDBNative.duckdb_jdbc_prepare(conn.conn_ref, sql);
 		Object[] params = {};
 		ByteBuffer result_ref = DuckDBNative.duckdb_jdbc_execute(stmt_ref, params);
@@ -48,12 +50,17 @@ public int executeUpdate(String sql) throws SQLException {
 		return affected;
 	}
 
-	public void close() throws SQLException {
+	public synchronized void close() throws SQLException {
 		if (stmt_ref != null) {
 			DuckDBNative.duckdb_jdbc_release(stmt_ref);
 			stmt_ref = null;
 		}
 		conn = null;
+		result = null;
+	}
+
+	protected void finalize() throws Throwable {
+		close();
 	}
 
 	public boolean isClosed() throws SQLException {
diff --git a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp
index 05f6f9beb61b..91d89ba38914 100644
--- a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp
+++ b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp
@@ -172,6 +172,7 @@ bool sqlite3_display_result(StatementType type) {
 	switch (type) {
 	case StatementType::EXECUTE:
 	case StatementType::EXPLAIN:
+	case StatementType::PRAGMA:
 	case StatementType::SELECT:
 		return true;
 	default:
