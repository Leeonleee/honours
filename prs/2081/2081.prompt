You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Type inference for parameterized queries
**What does happen?**

``` r
library(DBI)

con <- dbConnect(duckdb::duckdb())
dbGetQuery(con, "SELECT ? + 1.0 AS a", params = list(2))
#> Error in .local(conn, statement, ...): duckdb_prepare_R: Failed to prepare query SELECT ? + 1.0 AS a
#> Error: INTERNAL Error: Could not convert type UNKNOWN to a decimal.
```

<sup>Created on 2021-07-30 by the [reprex package](https://reprex.tidyverse.org) (v2.0.0)</sup>

Context: #1240.


**What should happen?**

Can we make this query work out of the box?

**To Reproduce**

See reprex above.

**Environment (please complete the following information):**
 - OS: Ubuntu 20.04
 - DuckDB Version: R package 0.2.6

**Before submitting**
- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?
- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds


</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![codecov](https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN)](https://codecov.io/gh/duckdb/duckdb)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/function/scalar/operators/arithmetic.cpp]
1: #include "duckdb/function/scalar/operators.hpp"
2: #include "duckdb/common/vector_operations/vector_operations.hpp"
3: #include "duckdb/common/operator/numeric_binary_operators.hpp"
4: #include "duckdb/common/operator/add.hpp"
5: #include "duckdb/common/operator/multiply.hpp"
6: #include "duckdb/common/operator/subtract.hpp"
7: #include "duckdb/planner/expression/bound_function_expression.hpp"
8: #include "duckdb/storage/statistics/numeric_statistics.hpp"
9: 
10: #include "duckdb/common/types/date.hpp"
11: #include "duckdb/common/types/decimal.hpp"
12: #include "duckdb/common/types/hugeint.hpp"
13: #include "duckdb/common/types/interval.hpp"
14: #include "duckdb/common/types/time.hpp"
15: #include "duckdb/common/types/timestamp.hpp"
16: 
17: #include <limits>
18: 
19: namespace duckdb {
20: 
21: template <class OP>
22: static scalar_function_t GetScalarIntegerFunction(PhysicalType type) {
23: 	scalar_function_t function;
24: 	switch (type) {
25: 	case PhysicalType::INT8:
26: 		function = &ScalarFunction::BinaryFunction<int8_t, int8_t, int8_t, OP>;
27: 		break;
28: 	case PhysicalType::INT16:
29: 		function = &ScalarFunction::BinaryFunction<int16_t, int16_t, int16_t, OP>;
30: 		break;
31: 	case PhysicalType::INT32:
32: 		function = &ScalarFunction::BinaryFunction<int32_t, int32_t, int32_t, OP>;
33: 		break;
34: 	case PhysicalType::INT64:
35: 		function = &ScalarFunction::BinaryFunction<int64_t, int64_t, int64_t, OP>;
36: 		break;
37: 	case PhysicalType::UINT8:
38: 		function = &ScalarFunction::BinaryFunction<uint8_t, uint8_t, uint8_t, OP>;
39: 		break;
40: 	case PhysicalType::UINT16:
41: 		function = &ScalarFunction::BinaryFunction<uint16_t, uint16_t, uint16_t, OP>;
42: 		break;
43: 	case PhysicalType::UINT32:
44: 		function = &ScalarFunction::BinaryFunction<uint32_t, uint32_t, uint32_t, OP>;
45: 		break;
46: 	case PhysicalType::UINT64:
47: 		function = &ScalarFunction::BinaryFunction<uint64_t, uint64_t, uint64_t, OP>;
48: 		break;
49: 	default:
50: 		throw NotImplementedException("Unimplemented type for GetScalarBinaryFunction");
51: 	}
52: 	return function;
53: }
54: 
55: template <class OP>
56: static scalar_function_t GetScalarBinaryFunction(PhysicalType type) {
57: 	scalar_function_t function;
58: 	switch (type) {
59: 	case PhysicalType::INT128:
60: 		function = &ScalarFunction::BinaryFunction<hugeint_t, hugeint_t, hugeint_t, OP>;
61: 		break;
62: 	case PhysicalType::FLOAT:
63: 		function = &ScalarFunction::BinaryFunction<float, float, float, OP>;
64: 		break;
65: 	case PhysicalType::DOUBLE:
66: 		function = &ScalarFunction::BinaryFunction<double, double, double, OP>;
67: 		break;
68: 	default:
69: 		function = GetScalarIntegerFunction<OP>(type);
70: 		break;
71: 	}
72: 	return function;
73: }
74: 
75: //===--------------------------------------------------------------------===//
76: // + [add]
77: //===--------------------------------------------------------------------===//
78: struct AddPropagateStatistics {
79: 	template <class T, class OP>
80: 	static bool Operation(LogicalType type, NumericStatistics &lstats, NumericStatistics &rstats, Value &new_min,
81: 	                      Value &new_max) {
82: 		T min, max;
83: 		// new min is min+min
84: 		if (!OP::Operation(lstats.min.GetValueUnsafe<T>(), rstats.min.GetValueUnsafe<T>(), min)) {
85: 			return true;
86: 		}
87: 		// new max is max+max
88: 		if (!OP::Operation(lstats.max.GetValueUnsafe<T>(), rstats.max.GetValueUnsafe<T>(), max)) {
89: 			return true;
90: 		}
91: 		new_min = Value::Numeric(type, min);
92: 		new_max = Value::Numeric(type, max);
93: 		return false;
94: 	}
95: };
96: 
97: struct SubtractPropagateStatistics {
98: 	template <class T, class OP>
99: 	static bool Operation(LogicalType type, NumericStatistics &lstats, NumericStatistics &rstats, Value &new_min,
100: 	                      Value &new_max) {
101: 		T min, max;
102: 		if (!OP::Operation(lstats.min.GetValueUnsafe<T>(), rstats.max.GetValueUnsafe<T>(), min)) {
103: 			return true;
104: 		}
105: 		if (!OP::Operation(lstats.max.GetValueUnsafe<T>(), rstats.min.GetValueUnsafe<T>(), max)) {
106: 			return true;
107: 		}
108: 		new_min = Value::Numeric(type, min);
109: 		new_max = Value::Numeric(type, max);
110: 		return false;
111: 	}
112: };
113: 
114: template <class OP, class PROPAGATE, class BASEOP>
115: static unique_ptr<BaseStatistics> PropagateNumericStats(ClientContext &context, BoundFunctionExpression &expr,
116:                                                         FunctionData *bind_data,
117:                                                         vector<unique_ptr<BaseStatistics>> &child_stats) {
118: 	D_ASSERT(child_stats.size() == 2);
119: 	// can only propagate stats if the children have stats
120: 	if (!child_stats[0] || !child_stats[1]) {
121: 		return nullptr;
122: 	}
123: 	auto &lstats = (NumericStatistics &)*child_stats[0];
124: 	auto &rstats = (NumericStatistics &)*child_stats[1];
125: 	Value new_min, new_max;
126: 	bool potential_overflow = true;
127: 	if (!lstats.min.is_null && !lstats.max.is_null && !rstats.min.is_null && !rstats.max.is_null) {
128: 		switch (expr.return_type.InternalType()) {
129: 		case PhysicalType::INT8:
130: 			potential_overflow =
131: 			    PROPAGATE::template Operation<int8_t, OP>(expr.return_type, lstats, rstats, new_min, new_max);
132: 			break;
133: 		case PhysicalType::INT16:
134: 			potential_overflow =
135: 			    PROPAGATE::template Operation<int16_t, OP>(expr.return_type, lstats, rstats, new_min, new_max);
136: 			break;
137: 		case PhysicalType::INT32:
138: 			potential_overflow =
139: 			    PROPAGATE::template Operation<int32_t, OP>(expr.return_type, lstats, rstats, new_min, new_max);
140: 			break;
141: 		case PhysicalType::INT64:
142: 			potential_overflow =
143: 			    PROPAGATE::template Operation<int64_t, OP>(expr.return_type, lstats, rstats, new_min, new_max);
144: 			break;
145: 		default:
146: 			return nullptr;
147: 		}
148: 	}
149: 	if (potential_overflow) {
150: 		new_min = Value(expr.return_type);
151: 		new_max = Value(expr.return_type);
152: 	} else {
153: 		// no potential overflow: replace with non-overflowing operator
154: 		expr.function.function = GetScalarIntegerFunction<BASEOP>(expr.return_type.InternalType());
155: 	}
156: 	auto stats = make_unique<NumericStatistics>(expr.return_type, move(new_min), move(new_max));
157: 	stats->validity_stats = ValidityStatistics::Combine(lstats.validity_stats, rstats.validity_stats);
158: 	return move(stats);
159: }
160: 
161: template <class OP, class OPOVERFLOWCHECK, bool IS_SUBTRACT = false>
162: unique_ptr<FunctionData> BindDecimalAddSubtract(ClientContext &context, ScalarFunction &bound_function,
163:                                                 vector<unique_ptr<Expression>> &arguments) {
164: 	// get the max width and scale of the input arguments
165: 	uint8_t max_width = 0, max_scale = 0, max_width_over_scale = 0;
166: 	for (idx_t i = 0; i < arguments.size(); i++) {
167: 		uint8_t width, scale;
168: 		auto can_convert = arguments[i]->return_type.GetDecimalProperties(width, scale);
169: 		if (!can_convert) {
170: 			throw InternalException("Could not convert type %s to a decimal.", arguments[i]->return_type.ToString());
171: 		}
172: 		max_width = MaxValue<uint8_t>(width, max_width);
173: 		max_scale = MaxValue<uint8_t>(scale, max_scale);
174: 		max_width_over_scale = MaxValue<uint8_t>(width - scale, max_width_over_scale);
175: 	}
176: 	// for addition/subtraction, we add 1 to the width to ensure we don't overflow
177: 	bool check_overflow = false;
178: 	auto required_width = MaxValue<uint8_t>(max_scale + max_width_over_scale, max_width) + 1;
179: 	if (required_width > Decimal::MAX_WIDTH_INT64 && max_width <= Decimal::MAX_WIDTH_INT64) {
180: 		// we don't automatically promote past the hugeint boundary to avoid the large hugeint performance penalty
181: 		check_overflow = true;
182: 		required_width = Decimal::MAX_WIDTH_INT64;
183: 	}
184: 	if (required_width > Decimal::MAX_WIDTH_DECIMAL) {
185: 		// target width does not fit in decimal at all: truncate the scale and perform overflow detection
186: 		check_overflow = true;
187: 		required_width = Decimal::MAX_WIDTH_DECIMAL;
188: 	}
189: 	// arithmetic between two decimal arguments: check the types of the input arguments
190: 	LogicalType result_type = LogicalType::DECIMAL(required_width, max_scale);
191: 	// we cast all input types to the specified type
192: 	for (idx_t i = 0; i < arguments.size(); i++) {
193: 		// first check if the cast is necessary
194: 		// if the argument has a matching scale and internal type as the output type, no casting is necessary
195: 		auto &argument_type = arguments[i]->return_type;
196: 		uint8_t width, scale;
197: 		argument_type.GetDecimalProperties(width, scale);
198: 		if (scale == DecimalType::GetScale(result_type) && argument_type.InternalType() == result_type.InternalType()) {
199: 			bound_function.arguments[i] = argument_type;
200: 		} else {
201: 			bound_function.arguments[i] = result_type;
202: 		}
203: 	}
204: 	bound_function.return_type = result_type;
205: 	// now select the physical function to execute
206: 	if (check_overflow) {
207: 		bound_function.function = GetScalarBinaryFunction<OPOVERFLOWCHECK>(result_type.InternalType());
208: 	} else {
209: 		bound_function.function = GetScalarBinaryFunction<OP>(result_type.InternalType());
210: 	}
211: 	if (result_type.InternalType() != PhysicalType::INT128) {
212: 		if (IS_SUBTRACT) {
213: 			bound_function.statistics =
214: 			    PropagateNumericStats<TryDecimalSubtract, SubtractPropagateStatistics, SubtractOperator>;
215: 		} else {
216: 			bound_function.statistics = PropagateNumericStats<TryDecimalAdd, AddPropagateStatistics, AddOperator>;
217: 		}
218: 	}
219: 	return nullptr;
220: }
221: 
222: unique_ptr<FunctionData> NopDecimalBind(ClientContext &context, ScalarFunction &bound_function,
223:                                         vector<unique_ptr<Expression>> &arguments) {
224: 	bound_function.return_type = arguments[0]->return_type;
225: 	bound_function.arguments[0] = arguments[0]->return_type;
226: 	return nullptr;
227: }
228: 
229: void AddFun::RegisterFunction(BuiltinFunctions &set) {
230: 	ScalarFunctionSet functions("+");
231: 	// binary add function adds two numbers together
232: 	for (auto &type : LogicalType::NUMERIC) {
233: 		if (type.id() == LogicalTypeId::DECIMAL) {
234: 			functions.AddFunction(ScalarFunction({type, type}, type, nullptr, false,
235: 			                                     BindDecimalAddSubtract<AddOperator, DecimalAddOverflowCheck>));
236: 		} else if (TypeIsIntegral(type.InternalType()) && type.id() != LogicalTypeId::HUGEINT) {
237: 			functions.AddFunction(ScalarFunction(
238: 			    {type, type}, type, GetScalarIntegerFunction<AddOperatorOverflowCheck>(type.InternalType()), false,
239: 			    nullptr, nullptr, PropagateNumericStats<TryAddOperator, AddPropagateStatistics, AddOperator>));
240: 		} else {
241: 			functions.AddFunction(
242: 			    ScalarFunction({type, type}, type, GetScalarBinaryFunction<AddOperator>(type.InternalType())));
243: 		}
244: 	}
245: 	// we can add integers to dates
246: 	functions.AddFunction(ScalarFunction({LogicalType::DATE, LogicalType::INTEGER}, LogicalType::DATE,
247: 	                                     ScalarFunction::BinaryFunction<date_t, int32_t, date_t, AddOperator>));
248: 	functions.AddFunction(ScalarFunction({LogicalType::INTEGER, LogicalType::DATE}, LogicalType::DATE,
249: 	                                     ScalarFunction::BinaryFunction<int32_t, date_t, date_t, AddOperator>));
250: 	// we can add intervals together
251: 	functions.AddFunction(
252: 	    ScalarFunction({LogicalType::INTERVAL, LogicalType::INTERVAL}, LogicalType::INTERVAL,
253: 	                   ScalarFunction::BinaryFunction<interval_t, interval_t, interval_t, AddOperator>));
254: 	// we can add intervals to dates/times/timestamps
255: 	functions.AddFunction(ScalarFunction({LogicalType::DATE, LogicalType::INTERVAL}, LogicalType::DATE,
256: 	                                     ScalarFunction::BinaryFunction<date_t, interval_t, date_t, AddOperator>));
257: 	functions.AddFunction(ScalarFunction({LogicalType::INTERVAL, LogicalType::DATE}, LogicalType::DATE,
258: 	                                     ScalarFunction::BinaryFunction<interval_t, date_t, date_t, AddOperator>));
259: 
260: 	functions.AddFunction(
261: 	    ScalarFunction({LogicalType::TIME, LogicalType::INTERVAL}, LogicalType::TIME,
262: 	                   ScalarFunction::BinaryFunction<dtime_t, interval_t, dtime_t, AddTimeOperator>));
263: 	functions.AddFunction(
264: 	    ScalarFunction({LogicalType::INTERVAL, LogicalType::TIME}, LogicalType::TIME,
265: 	                   ScalarFunction::BinaryFunction<interval_t, dtime_t, dtime_t, AddTimeOperator>));
266: 
267: 	functions.AddFunction(
268: 	    ScalarFunction({LogicalType::TIMESTAMP, LogicalType::INTERVAL}, LogicalType::TIMESTAMP,
269: 	                   ScalarFunction::BinaryFunction<timestamp_t, interval_t, timestamp_t, AddOperator>));
270: 	functions.AddFunction(
271: 	    ScalarFunction({LogicalType::INTERVAL, LogicalType::TIMESTAMP}, LogicalType::TIMESTAMP,
272: 	                   ScalarFunction::BinaryFunction<interval_t, timestamp_t, timestamp_t, AddOperator>));
273: 	// unary add function is a nop, but only exists for numeric types
274: 	for (auto &type : LogicalType::NUMERIC) {
275: 		if (type.id() == LogicalTypeId::DECIMAL) {
276: 			functions.AddFunction(ScalarFunction({type}, type, ScalarFunction::NopFunction, false, NopDecimalBind));
277: 		} else {
278: 			functions.AddFunction(ScalarFunction({type}, type, ScalarFunction::NopFunction));
279: 		}
280: 	}
281: 	set.AddFunction(functions);
282: }
283: 
284: //===--------------------------------------------------------------------===//
285: // - [subtract]
286: //===--------------------------------------------------------------------===//
287: struct NegateOperator {
288: 	template <class TA, class TR>
289: 	static inline TR Operation(TA input) {
290: 		using Limits = std::numeric_limits<TR>;
291: 		auto cast = (TR)input;
292: 		if (Limits::is_integer && Limits::is_signed && Limits::lowest() == cast) {
293: 			throw OutOfRangeException("Overflow in negation of integer!");
294: 		}
295: 		return -cast;
296: 	}
297: };
298: 
299: template <>
300: interval_t NegateOperator::Operation(interval_t input) {
301: 	interval_t result;
302: 	result.months = NegateOperator::Operation<int32_t, int32_t>(input.months);
303: 	result.days = NegateOperator::Operation<int32_t, int32_t>(input.days);
304: 	result.micros = NegateOperator::Operation<int64_t, int64_t>(input.micros);
305: 	return result;
306: }
307: 
308: unique_ptr<FunctionData> DecimalNegateBind(ClientContext &context, ScalarFunction &bound_function,
309:                                            vector<unique_ptr<Expression>> &arguments) {
310: 	auto &decimal_type = arguments[0]->return_type;
311: 	auto width = DecimalType::GetWidth(decimal_type);
312: 	if (width <= Decimal::MAX_WIDTH_INT16) {
313: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<NegateOperator>(LogicalTypeId::SMALLINT);
314: 	} else if (width <= Decimal::MAX_WIDTH_INT32) {
315: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<NegateOperator>(LogicalTypeId::INTEGER);
316: 	} else if (width <= Decimal::MAX_WIDTH_INT64) {
317: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<NegateOperator>(LogicalTypeId::BIGINT);
318: 	} else {
319: 		D_ASSERT(width <= Decimal::MAX_WIDTH_INT128);
320: 		bound_function.function = ScalarFunction::GetScalarUnaryFunction<NegateOperator>(LogicalTypeId::HUGEINT);
321: 	}
322: 	decimal_type.Verify();
323: 	bound_function.arguments[0] = decimal_type;
324: 	bound_function.return_type = decimal_type;
325: 	return nullptr;
326: }
327: 
328: struct NegatePropagateStatistics {
329: 	template <class T>
330: 	static void Operation(LogicalType type, NumericStatistics &istats, Value &new_min, Value &new_max) {
331: 		// new min is -max
332: 		new_min = Value::Numeric(type, NegateOperator::Operation<T, T>(istats.max.GetValueUnsafe<T>()));
333: 		// new max is -min
334: 		new_max = Value::Numeric(type, NegateOperator::Operation<T, T>(istats.min.GetValueUnsafe<T>()));
335: 	}
336: };
337: 
338: static unique_ptr<BaseStatistics> NegateBindStatistics(ClientContext &context, BoundFunctionExpression &expr,
339:                                                        FunctionData *bind_data,
340:                                                        vector<unique_ptr<BaseStatistics>> &child_stats) {
341: 	D_ASSERT(child_stats.size() == 1);
342: 	// can only propagate stats if the children have stats
343: 	if (!child_stats[0]) {
344: 		return nullptr;
345: 	}
346: 	auto &istats = (NumericStatistics &)*child_stats[0];
347: 	Value new_min, new_max;
348: 	if (!istats.min.is_null && !istats.max.is_null) {
349: 		switch (expr.return_type.InternalType()) {
350: 		case PhysicalType::INT8:
351: 			NegatePropagateStatistics::Operation<int8_t>(expr.return_type, istats, new_min, new_max);
352: 			break;
353: 		case PhysicalType::INT16:
354: 			NegatePropagateStatistics::Operation<int16_t>(expr.return_type, istats, new_min, new_max);
355: 			break;
356: 		case PhysicalType::INT32:
357: 			NegatePropagateStatistics::Operation<int32_t>(expr.return_type, istats, new_min, new_max);
358: 			break;
359: 		case PhysicalType::INT64:
360: 			NegatePropagateStatistics::Operation<int64_t>(expr.return_type, istats, new_min, new_max);
361: 			break;
362: 		default:
363: 			return nullptr;
364: 		}
365: 	}
366: 	auto stats = make_unique<NumericStatistics>(expr.return_type, move(new_min), move(new_max));
367: 	if (istats.validity_stats) {
368: 		stats->validity_stats = istats.validity_stats->Copy();
369: 	}
370: 	return move(stats);
371: }
372: 
373: void SubtractFun::RegisterFunction(BuiltinFunctions &set) {
374: 	ScalarFunctionSet functions("-");
375: 	// binary subtract function "a - b", subtracts b from a
376: 	for (auto &type : LogicalType::NUMERIC) {
377: 		if (type.id() == LogicalTypeId::DECIMAL) {
378: 			functions.AddFunction(
379: 			    ScalarFunction({type, type}, type, nullptr, false,
380: 			                   BindDecimalAddSubtract<SubtractOperator, DecimalSubtractOverflowCheck, true>));
381: 		} else if (TypeIsIntegral(type.InternalType()) && type.id() != LogicalTypeId::HUGEINT) {
382: 			functions.AddFunction(ScalarFunction(
383: 			    {type, type}, type, GetScalarIntegerFunction<SubtractOperatorOverflowCheck>(type.InternalType()), false,
384: 			    nullptr, nullptr,
385: 			    PropagateNumericStats<TrySubtractOperator, SubtractPropagateStatistics, SubtractOperator>));
386: 		} else {
387: 			functions.AddFunction(
388: 			    ScalarFunction({type, type}, type, GetScalarBinaryFunction<SubtractOperator>(type.InternalType())));
389: 		}
390: 	}
391: 	// we can subtract dates from each other
392: 	functions.AddFunction(ScalarFunction({LogicalType::DATE, LogicalType::DATE}, LogicalType::BIGINT,
393: 	                                     ScalarFunction::BinaryFunction<date_t, date_t, int64_t, SubtractOperator>));
394: 	functions.AddFunction(ScalarFunction({LogicalType::DATE, LogicalType::INTEGER}, LogicalType::DATE,
395: 	                                     ScalarFunction::BinaryFunction<date_t, int32_t, date_t, SubtractOperator>));
396: 	// we can subtract timestamps from each other
397: 	functions.AddFunction(
398: 	    ScalarFunction({LogicalType::TIMESTAMP, LogicalType::TIMESTAMP}, LogicalType::INTERVAL,
399: 	                   ScalarFunction::BinaryFunction<timestamp_t, timestamp_t, interval_t, SubtractOperator>));
400: 	// we can subtract intervals from each other
401: 	functions.AddFunction(
402: 	    ScalarFunction({LogicalType::INTERVAL, LogicalType::INTERVAL}, LogicalType::INTERVAL,
403: 	                   ScalarFunction::BinaryFunction<interval_t, interval_t, interval_t, SubtractOperator>));
404: 	// we can subtract intervals from dates/times/timestamps, but not the other way around
405: 	functions.AddFunction(ScalarFunction({LogicalType::DATE, LogicalType::INTERVAL}, LogicalType::DATE,
406: 	                                     ScalarFunction::BinaryFunction<date_t, interval_t, date_t, SubtractOperator>));
407: 	functions.AddFunction(
408: 	    ScalarFunction({LogicalType::TIME, LogicalType::INTERVAL}, LogicalType::TIME,
409: 	                   ScalarFunction::BinaryFunction<dtime_t, interval_t, dtime_t, SubtractTimeOperator>));
410: 	functions.AddFunction(
411: 	    ScalarFunction({LogicalType::TIMESTAMP, LogicalType::INTERVAL}, LogicalType::TIMESTAMP,
412: 	                   ScalarFunction::BinaryFunction<timestamp_t, interval_t, timestamp_t, SubtractOperator>));
413: 
414: 	// unary subtract function, negates the input (i.e. multiplies by -1)
415: 	for (auto &type : LogicalType::NUMERIC) {
416: 		if (type.id() == LogicalTypeId::DECIMAL) {
417: 			functions.AddFunction(
418: 			    ScalarFunction({type}, type, nullptr, false, DecimalNegateBind, nullptr, NegateBindStatistics));
419: 		} else {
420: 			functions.AddFunction(ScalarFunction({type}, type,
421: 			                                     ScalarFunction::GetScalarUnaryFunction<NegateOperator>(type), false,
422: 			                                     nullptr, nullptr, NegateBindStatistics));
423: 		}
424: 	}
425: 	functions.AddFunction(ScalarFunction({LogicalType::INTERVAL}, LogicalType::INTERVAL,
426: 	                                     ScalarFunction::UnaryFunction<interval_t, interval_t, NegateOperator>));
427: 	set.AddFunction(functions);
428: }
429: 
430: //===--------------------------------------------------------------------===//
431: // * [multiply]
432: //===--------------------------------------------------------------------===//
433: struct MultiplyPropagateStatistics {
434: 	template <class T, class OP>
435: 	static bool Operation(LogicalType type, NumericStatistics &lstats, NumericStatistics &rstats, Value &new_min,
436: 	                      Value &new_max) {
437: 		// statistics propagation on the multiplication is slightly less straightforward because of negative numbers
438: 		// the new min/max depend on the signs of the input types
439: 		// if both are positive the result is [lmin * rmin][lmax * rmax]
440: 		// if lmin/lmax are negative the result is [lmin * rmax][lmax * rmin]
441: 		// etc
442: 		// rather than doing all this switcheroo we just multiply all combinations of lmin/lmax with rmin/rmax
443: 		// and check what the minimum/maximum value is
444: 		T lvals[] {lstats.min.GetValueUnsafe<T>(), lstats.max.GetValueUnsafe<T>()};
445: 		T rvals[] {rstats.min.GetValueUnsafe<T>(), rstats.max.GetValueUnsafe<T>()};
446: 		T min = NumericLimits<T>::Maximum();
447: 		T max = NumericLimits<T>::Minimum();
448: 		// multiplications
449: 		for (idx_t l = 0; l < 2; l++) {
450: 			for (idx_t r = 0; r < 2; r++) {
451: 				T result;
452: 				if (!OP::Operation(lvals[l], rvals[r], result)) {
453: 					// potential overflow
454: 					return true;
455: 				}
456: 				if (result < min) {
457: 					min = result;
458: 				}
459: 				if (result > max) {
460: 					max = result;
461: 				}
462: 			}
463: 		}
464: 		new_min = Value::Numeric(type, min);
465: 		new_max = Value::Numeric(type, max);
466: 		return false;
467: 	}
468: };
469: 
470: unique_ptr<FunctionData> BindDecimalMultiply(ClientContext &context, ScalarFunction &bound_function,
471:                                              vector<unique_ptr<Expression>> &arguments) {
472: 	uint8_t result_width = 0, result_scale = 0;
473: 	uint8_t max_width = 0;
474: 	for (idx_t i = 0; i < arguments.size(); i++) {
475: 		uint8_t width, scale;
476: 		auto can_convert = arguments[i]->return_type.GetDecimalProperties(width, scale);
477: 		if (!can_convert) {
478: 			throw InternalException("Could not convert type %s to a decimal?", arguments[i]->return_type.ToString());
479: 		}
480: 		if (width > max_width) {
481: 			max_width = width;
482: 		}
483: 		result_width += width;
484: 		result_scale += scale;
485: 	}
486: 	if (result_scale > Decimal::MAX_WIDTH_DECIMAL) {
487: 		throw OutOfRangeException(
488: 		    "Needed scale %d to accurately represent the multiplication result, but this is out of range of the "
489: 		    "DECIMAL type. Max scale is %d; could not perform an accurate multiplication. Either add a cast to DOUBLE, "
490: 		    "or add an explicit cast to a decimal with a lower scale.",
491: 		    result_scale, Decimal::MAX_WIDTH_DECIMAL);
492: 	}
493: 	bool check_overflow = false;
494: 	if (result_width > Decimal::MAX_WIDTH_INT64 && max_width <= Decimal::MAX_WIDTH_INT64 &&
495: 	    result_scale < Decimal::MAX_WIDTH_INT64) {
496: 		check_overflow = true;
497: 		result_width = Decimal::MAX_WIDTH_INT64;
498: 	}
499: 	if (result_width > Decimal::MAX_WIDTH_DECIMAL) {
500: 		check_overflow = true;
501: 		result_width = Decimal::MAX_WIDTH_DECIMAL;
502: 	}
503: 	LogicalType result_type = LogicalType::DECIMAL(result_width, result_scale);
504: 	// since our scale is the summation of our input scales, we do not need to cast to the result scale
505: 	// however, we might need to cast to the correct internal type
506: 	for (idx_t i = 0; i < arguments.size(); i++) {
507: 		auto &argument_type = arguments[i]->return_type;
508: 		if (argument_type.InternalType() == result_type.InternalType()) {
509: 			bound_function.arguments[i] = argument_type;
510: 		} else {
511: 			uint8_t width, scale;
512: 			argument_type.GetDecimalProperties(width, scale);
513: 
514: 			bound_function.arguments[i] = LogicalType::DECIMAL(result_width, scale);
515: 		}
516: 	}
517: 	result_type.Verify();
518: 	bound_function.return_type = result_type;
519: 	// now select the physical function to execute
520: 	if (check_overflow) {
521: 		bound_function.function = GetScalarBinaryFunction<DecimalMultiplyOverflowCheck>(result_type.InternalType());
522: 	} else {
523: 		bound_function.function = GetScalarBinaryFunction<MultiplyOperator>(result_type.InternalType());
524: 	}
525: 	if (result_type.InternalType() != PhysicalType::INT128) {
526: 		bound_function.statistics =
527: 		    PropagateNumericStats<TryDecimalMultiply, MultiplyPropagateStatistics, MultiplyOperator>;
528: 	}
529: 	return nullptr;
530: }
531: 
532: void MultiplyFun::RegisterFunction(BuiltinFunctions &set) {
533: 	ScalarFunctionSet functions("*");
534: 	for (auto &type : LogicalType::NUMERIC) {
535: 		if (type.id() == LogicalTypeId::DECIMAL) {
536: 			functions.AddFunction(ScalarFunction({type, type}, type, nullptr, false, BindDecimalMultiply));
537: 		} else if (TypeIsIntegral(type.InternalType()) && type.id() != LogicalTypeId::HUGEINT) {
538: 			functions.AddFunction(ScalarFunction(
539: 			    {type, type}, type, GetScalarIntegerFunction<MultiplyOperatorOverflowCheck>(type.InternalType()), false,
540: 			    nullptr, nullptr,
541: 			    PropagateNumericStats<TryMultiplyOperator, MultiplyPropagateStatistics, MultiplyOperator>));
542: 		} else {
543: 			functions.AddFunction(
544: 			    ScalarFunction({type, type}, type, GetScalarBinaryFunction<MultiplyOperator>(type.InternalType())));
545: 		}
546: 	}
547: 	functions.AddFunction(
548: 	    ScalarFunction({LogicalType::INTERVAL, LogicalType::BIGINT}, LogicalType::INTERVAL,
549: 	                   ScalarFunction::BinaryFunction<interval_t, int64_t, interval_t, MultiplyOperator>));
550: 	functions.AddFunction(
551: 	    ScalarFunction({LogicalType::BIGINT, LogicalType::INTERVAL}, LogicalType::INTERVAL,
552: 	                   ScalarFunction::BinaryFunction<int64_t, interval_t, interval_t, MultiplyOperator>));
553: 	set.AddFunction(functions);
554: }
555: 
556: //===--------------------------------------------------------------------===//
557: // / [divide]
558: //===--------------------------------------------------------------------===//
559: template <>
560: float DivideOperator::Operation(float left, float right) {
561: 	auto result = left / right;
562: 	if (!Value::FloatIsValid(result)) {
563: 		throw OutOfRangeException("Overflow in division of float!");
564: 	}
565: 	return result;
566: }
567: 
568: template <>
569: double DivideOperator::Operation(double left, double right) {
570: 	auto result = left / right;
571: 	if (!Value::DoubleIsValid(result)) {
572: 		throw OutOfRangeException("Overflow in division of double!");
573: 	}
574: 	return result;
575: }
576: 
577: template <>
578: hugeint_t DivideOperator::Operation(hugeint_t left, hugeint_t right) {
579: 	if (right.lower == 0 && right.upper == 0) {
580: 		throw InternalException("Hugeint division by zero!");
581: 	}
582: 	return left / right;
583: }
584: 
585: template <>
586: interval_t DivideOperator::Operation(interval_t left, int64_t right) {
587: 	left.days /= right;
588: 	left.months /= right;
589: 	left.micros /= right;
590: 	return left;
591: }
592: 
593: struct BinaryZeroIsNullWrapper {
594: 	template <class FUNC, class OP, class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE>
595: 	static inline RESULT_TYPE Operation(FUNC fun, LEFT_TYPE left, RIGHT_TYPE right, ValidityMask &mask, idx_t idx) {
596: 		if (right == 0) {
597: 			mask.SetInvalid(idx);
598: 			return left;
599: 		} else {
600: 			return OP::template Operation<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE>(left, right);
601: 		}
602: 	}
603: 
604: 	static bool AddsNulls() {
605: 		return true;
606: 	}
607: };
608: 
609: struct BinaryZeroIsNullHugeintWrapper {
610: 	template <class FUNC, class OP, class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE>
611: 	static inline RESULT_TYPE Operation(FUNC fun, LEFT_TYPE left, RIGHT_TYPE right, ValidityMask &mask, idx_t idx) {
612: 		if (right.upper == 0 && right.lower == 0) {
613: 			mask.SetInvalid(idx);
614: 			return left;
615: 		} else {
616: 			return OP::template Operation<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE>(left, right);
617: 		}
618: 	}
619: 
620: 	static bool AddsNulls() {
621: 		return true;
622: 	}
623: };
624: 
625: template <class TA, class TB, class TC, class OP, class ZWRAPPER = BinaryZeroIsNullWrapper>
626: static void BinaryScalarFunctionIgnoreZero(DataChunk &input, ExpressionState &state, Vector &result) {
627: 	BinaryExecutor::Execute<TA, TB, TC, OP, ZWRAPPER>(input.data[0], input.data[1], result, input.size());
628: }
629: 
630: template <class OP>
631: static scalar_function_t GetBinaryFunctionIgnoreZero(const LogicalType &type) {
632: 	switch (type.id()) {
633: 	case LogicalTypeId::TINYINT:
634: 		return BinaryScalarFunctionIgnoreZero<int8_t, int8_t, int8_t, OP>;
635: 	case LogicalTypeId::SMALLINT:
636: 		return BinaryScalarFunctionIgnoreZero<int16_t, int16_t, int16_t, OP>;
637: 	case LogicalTypeId::INTEGER:
638: 		return BinaryScalarFunctionIgnoreZero<int32_t, int32_t, int32_t, OP>;
639: 	case LogicalTypeId::BIGINT:
640: 		return BinaryScalarFunctionIgnoreZero<int64_t, int64_t, int64_t, OP>;
641: 	case LogicalTypeId::UTINYINT:
642: 		return BinaryScalarFunctionIgnoreZero<uint8_t, uint8_t, uint8_t, OP>;
643: 	case LogicalTypeId::USMALLINT:
644: 		return BinaryScalarFunctionIgnoreZero<uint16_t, uint16_t, uint16_t, OP>;
645: 	case LogicalTypeId::UINTEGER:
646: 		return BinaryScalarFunctionIgnoreZero<uint32_t, uint32_t, uint32_t, OP>;
647: 	case LogicalTypeId::UBIGINT:
648: 		return BinaryScalarFunctionIgnoreZero<uint64_t, uint64_t, uint64_t, OP>;
649: 	case LogicalTypeId::HUGEINT:
650: 		return BinaryScalarFunctionIgnoreZero<hugeint_t, hugeint_t, hugeint_t, OP, BinaryZeroIsNullHugeintWrapper>;
651: 	case LogicalTypeId::FLOAT:
652: 		return BinaryScalarFunctionIgnoreZero<float, float, float, OP>;
653: 	case LogicalTypeId::DOUBLE:
654: 		return BinaryScalarFunctionIgnoreZero<double, double, double, OP>;
655: 	default:
656: 		throw NotImplementedException("Unimplemented type for GetScalarUnaryFunction");
657: 	}
658: }
659: 
660: void DivideFun::RegisterFunction(BuiltinFunctions &set) {
661: 	ScalarFunctionSet functions("/");
662: 	for (auto &type : LogicalType::NUMERIC) {
663: 		if (type.id() == LogicalTypeId::DECIMAL) {
664: 			continue;
665: 		} else {
666: 			functions.AddFunction(
667: 			    ScalarFunction({type, type}, type, GetBinaryFunctionIgnoreZero<DivideOperator>(type)));
668: 		}
669: 	}
670: 	functions.AddFunction(
671: 	    ScalarFunction({LogicalType::INTERVAL, LogicalType::BIGINT}, LogicalType::INTERVAL,
672: 	                   BinaryScalarFunctionIgnoreZero<interval_t, int64_t, interval_t, DivideOperator>));
673: 
674: 	set.AddFunction(functions);
675: }
676: 
677: //===--------------------------------------------------------------------===//
678: // % [modulo]
679: //===--------------------------------------------------------------------===//
680: template <>
681: float ModuloOperator::Operation(float left, float right) {
682: 	D_ASSERT(right != 0);
683: 	return std::fmod(left, right);
684: }
685: 
686: template <>
687: double ModuloOperator::Operation(double left, double right) {
688: 	D_ASSERT(right != 0);
689: 	return std::fmod(left, right);
690: }
691: 
692: template <>
693: hugeint_t ModuloOperator::Operation(hugeint_t left, hugeint_t right) {
694: 	if (right.lower == 0 && right.upper == 0) {
695: 		throw InternalException("Hugeint division by zero!");
696: 	}
697: 	return left % right;
698: }
699: 
700: void ModFun::RegisterFunction(BuiltinFunctions &set) {
701: 	ScalarFunctionSet functions("%");
702: 	for (auto &type : LogicalType::NUMERIC) {
703: 		if (type.id() == LogicalTypeId::DECIMAL) {
704: 			continue;
705: 		} else {
706: 			functions.AddFunction(
707: 			    ScalarFunction({type, type}, type, GetBinaryFunctionIgnoreZero<ModuloOperator>(type)));
708: 		}
709: 	}
710: 	set.AddFunction(functions);
711: 	functions.name = "mod";
712: 	set.AddFunction(functions);
713: }
714: 
715: } // namespace duckdb
[end of src/function/scalar/operators/arithmetic.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: