{
  "repo": "duckdb/duckdb",
  "pull_number": 710,
  "instance_id": "duckdb__duckdb-710",
  "issue_numbers": [
    "709"
  ],
  "base_commit": "c9e32c3066c1913a66d8494cdb7faa1cef7fac62",
  "patch": "diff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp\nindex 699599f6b1cc..38193cb24046 100644\n--- a/src/storage/data_table.cpp\n+++ b/src/storage/data_table.cpp\n@@ -394,7 +394,8 @@ bool DataTable::ScanBaseTable(Transaction &transaction, DataChunk &result, Table\n \t\tauto start_time = high_resolution_clock::now();\n \t\tfor (idx_t i = 0; i < table_filters.size(); i++) {\n \t\t\tauto tf_idx = state.adaptive_filter->permutation[i];\n-\t\t\tcolumns[tf_idx]->Select(transaction, state.column_scans[tf_idx], result.data[tf_idx], sel,\n+\t\t\tauto col_idx = state.column_ids[tf_idx];\n+\t\t\tcolumns[col_idx]->Select(transaction, state.column_scans[tf_idx], result.data[tf_idx], sel,\n \t\t\t                        approved_tuple_count, table_filters[tf_idx]);\n \t\t}\n \t\tfor (auto &table_filter : table_filters) {\n",
  "test_patch": "diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp\nindex d3207d241166..d3a658f38c6a 100644\n--- a/test/rigger/test_rigger.cpp\n+++ b/test/rigger/test_rigger.cpp\n@@ -125,7 +125,7 @@ TEST_CASE(\"Test queries found by Rigger that cause problems in other systems\", \"\n \t}\n }\n \n-TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n+TEST_CASE(\"SQLancer\", \"[rigger]\") {\n \tunique_ptr<QueryResult> result;\n \tDuckDB db(nullptr);\n \tConnection con(db);\n@@ -758,4 +758,12 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {Value()}));\n \t\tREQUIRE(CHECK_COLUMN(result, 1, {\"0\"}));\n \t}\n+\tSECTION(\"709\") {\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 DATETIME DEFAULT(0.45428781614730807), c1 DATE, PRIMARY KEY(c1));\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 DOUBLE NOT NULL, c1 BOOLEAN);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"insert into t0 (c0, c1) values (NULL, '2019-11-26');\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"insert into t1 values (42, true);\"));\n+\n+\t\tREQUIRE_NO_FAIL(con.Query(\"SELECT t0.rowid, t1.c1, t1.c0 FROM t1, t0 WHERE (((t1.rowid NOT IN (((t1.c1) ::BOOLEAN), ((t1.c0) ::INT1))))AND((false BETWEEN '[' AND t1.c0))) UNION SELECT t0.rowid, t1.c1, t1.c0 FROM t1, t0 WHERE (NOT (((t1.rowid NOT IN (((t1.c1) ::BOOLEAN), ((t1.c0) ::INT1))))AND((false BETWEEN '[' AND t1.c0)))) UNION SELECT t0.rowid, t1.c1, t1.c0 FROM t1, t0 WHERE (((((t1.rowid NOT IN (((t1.c1) ::BOOLEAN), ((t1.c0) ::TINYINT))))AND((false BETWEEN '[' AND t1.c0)))) IS NULL);\"));\n+\t}\n }\n",
  "problem_statement": "Column ID mismatch in adaptive filters\nThis was found by @mrigger's SQLancer (somewhat minified by us)\r\n\r\n```SQL\r\nCREATE TABLE t0(c0 DATETIME DEFAULT(0.45428781614730807), c1 DATE, PRIMARY KEY(c1));\r\nCREATE TABLE t1(c0 DOUBLE NOT NULL, c1 BOOLEAN);\r\ninsert into t0 (c0, c1) values (NULL, '2019-11-26');\r\ninsert into t1 values (42, true);\r\n\r\nSELECT t0.rowid, t1.c1, t1.c0 FROM t1, t0 WHERE (((t1.rowid NOT IN (((t1.c1) ::BOOLEAN), ((t1.c0) ::INT1))))AND((false BETWEEN '[' AND t1.c0))) UNION SELECT t0.rowid, t1.c1, t1.c0 FROM t1, t0 WHERE (NOT (((t1.rowid NOT IN (((t1.c1) ::BOOLEAN), ((t1.c0) ::INT1))))AND((false BETWEEN '[' AND t1.c0)))) UNION SELECT t0.rowid, t1.c1, t1.c0 FROM t1, t0 WHERE (((((t1.rowid NOT IN (((t1.c1) ::BOOLEAN), ((t1.c0) ::TINYINT))))AND((false BETWEEN '[' AND t1.c0)))) IS NULL);\r\n```\r\n\r\n\r\nThe issue is an out of bound access in data_table.cpp line 399:\r\n\r\n```cpp\r\nauto tf_idx = state.adaptive_filter->permutation[i];\r\ncolumns[tf_idx]->Select(transaction, state.column_scans[tf_idx], result.data[tf_idx], sel, approved_tuple_count, table_filters[tf_idx]);\r\n```\n",
  "hints_text": "",
  "created_at": "2020-06-24T13:24:57Z"
}