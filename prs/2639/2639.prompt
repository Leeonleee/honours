You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
wrong results with extract(second from <interval>)
#### What happens?
When extracting the seconds component from an interval it returns the entire value in seconds. This is what `extract(epoch from <interval>)` should return.

#### To Reproduce
```
D select extract( second from interval '2 hours 2 minutes 10 seconds' ) as value_should_be_10;
┌────────────────────┐
│ value_should_be_10 │
├────────────────────┤
│ 7330               │
└────────────────────┘

D select extract( epoch from interval '2 hours 2 minutes 10 seconds' ) as value_should_be_7330;
┌──────────────────────┐
│ value_should_be_7330 │
├──────────────────────┤
│ 7330                 │
└──────────────────────┘
```
#### Environment (please complete the following information):
 - OS: macOS 11.5.2
 - DuckDB Version: 0.3.0
 - DuckDB Client: duckdb-cli

#### Before Submitting

- [ ] **Have you tried this on the latest `master` branch?**

No, but it's also incorrect in the test file here as well
https://github.com/duckdb/duckdb/blob/master/test/sql/function/interval/test_extract.test#L126

PostgreSQL 13.2
```
greg.rahn=# SELECT i, EXTRACT(second FROM i) FROM intervals;
       i       | date_part
---------------+-----------
 2 years       |         0
 1 year 4 mons |         0
 42 days       |         0
 00:34:26.3434 |   26.3434
 [NULL]        |    [NULL]
```

DuckDB
```
D SELECT i, EXTRACT(second FROM i) FROM intervals;
┌─────────────────┬──────────────────────┐
│        i        │ date_part(second, i) │
├─────────────────┼──────────────────────┤
│ 2 years         │ 0                    │
│ 1 year 4 months │ 0                    │
│ 42 days         │ 0                    │
│ 00:34:26.3434   │ 2066                 │ <<< should be 20.3434
│                 │                      │
└─────────────────┴──────────────────────┘
```


wrong results with extract(second from <interval>)
#### What happens?
When extracting the seconds component from an interval it returns the entire value in seconds. This is what `extract(epoch from <interval>)` should return.

#### To Reproduce
```
D select extract( second from interval '2 hours 2 minutes 10 seconds' ) as value_should_be_10;
┌────────────────────┐
│ value_should_be_10 │
├────────────────────┤
│ 7330               │
└────────────────────┘

D select extract( epoch from interval '2 hours 2 minutes 10 seconds' ) as value_should_be_7330;
┌──────────────────────┐
│ value_should_be_7330 │
├──────────────────────┤
│ 7330                 │
└──────────────────────┘
```
#### Environment (please complete the following information):
 - OS: macOS 11.5.2
 - DuckDB Version: 0.3.0
 - DuckDB Client: duckdb-cli

#### Before Submitting

- [ ] **Have you tried this on the latest `master` branch?**

No, but it's also incorrect in the test file here as well
https://github.com/duckdb/duckdb/blob/master/test/sql/function/interval/test_extract.test#L126

PostgreSQL 13.2
```
greg.rahn=# SELECT i, EXTRACT(second FROM i) FROM intervals;
       i       | date_part
---------------+-----------
 2 years       |         0
 1 year 4 mons |         0
 42 days       |         0
 00:34:26.3434 |   26.3434
 [NULL]        |    [NULL]
```

DuckDB
```
D SELECT i, EXTRACT(second FROM i) FROM intervals;
┌─────────────────┬──────────────────────┐
│        i        │ date_part(second, i) │
├─────────────────┼──────────────────────┤
│ 2 years         │ 0                    │
│ 1 year 4 months │ 0                    │
│ 42 days         │ 0                    │
│ 00:34:26.3434   │ 2066                 │ <<< should be 20.3434
│                 │                      │
└─────────────────┴──────────────────────┘
```



</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/common/types/interval.cpp]
1: #include "duckdb/common/types/interval.hpp"
2: #include "duckdb/common/operator/cast_operators.hpp"
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/enums/date_part_specifier.hpp"
5: #include "duckdb/common/types/date.hpp"
6: #include "duckdb/common/types/timestamp.hpp"
7: #include "duckdb/common/types/time.hpp"
8: #include "duckdb/common/types/cast_helpers.hpp"
9: #include "duckdb/common/operator/add.hpp"
10: #include "duckdb/common/operator/multiply.hpp"
11: #include "duckdb/common/string_util.hpp"
12: 
13: namespace duckdb {
14: 
15: bool Interval::FromString(const string &str, interval_t &result) {
16: 	string error_message;
17: 	return Interval::FromCString(str.c_str(), str.size(), result, &error_message, false);
18: }
19: 
20: template <class T>
21: void IntervalTryAddition(T &target, int64_t input, int64_t multiplier) {
22: 	int64_t addition;
23: 	if (!TryMultiplyOperator::Operation<int64_t, int64_t, int64_t>(input, multiplier, addition)) {
24: 		throw OutOfRangeException("interval value is out of range");
25: 	}
26: 	T addition_base = Cast::Operation<int64_t, T>(addition);
27: 	if (!TryAddOperator::Operation<T, T, T>(target, addition_base, target)) {
28: 		throw OutOfRangeException("interval value is out of range");
29: 	}
30: }
31: 
32: bool Interval::FromCString(const char *str, idx_t len, interval_t &result, string *error_message, bool strict) {
33: 	idx_t pos = 0;
34: 	idx_t start_pos;
35: 	bool negative;
36: 	bool found_any = false;
37: 	int64_t number;
38: 	DatePartSpecifier specifier;
39: 	string specifier_str;
40: 
41: 	result.days = 0;
42: 	result.micros = 0;
43: 	result.months = 0;
44: 
45: 	if (len == 0) {
46: 		return false;
47: 	}
48: 
49: 	switch (str[pos]) {
50: 	case '@':
51: 		pos++;
52: 		goto standard_interval;
53: 	case 'P':
54: 	case 'p':
55: 		pos++;
56: 		goto posix_interval;
57: 	default:
58: 		goto standard_interval;
59: 	}
60: standard_interval:
61: 	// start parsing a standard interval (e.g. 2 years 3 months...)
62: 	for (; pos < len; pos++) {
63: 		char c = str[pos];
64: 		if (c == ' ' || c == '\t' || c == '\n') {
65: 			// skip spaces
66: 			continue;
67: 		} else if (c >= '0' && c <= '9') {
68: 			// start parsing a positive number
69: 			negative = false;
70: 			goto interval_parse_number;
71: 		} else if (c == '-') {
72: 			// negative number
73: 			negative = true;
74: 			pos++;
75: 			goto interval_parse_number;
76: 		} else if (c == 'a' || c == 'A') {
77: 			// parse the word "ago" as the final specifier
78: 			goto interval_parse_ago;
79: 		} else {
80: 			// unrecognized character, expected a number or end of string
81: 			return false;
82: 		}
83: 	}
84: 	goto end_of_string;
85: interval_parse_number:
86: 	start_pos = pos;
87: 	for (; pos < len; pos++) {
88: 		char c = str[pos];
89: 		if (c >= '0' && c <= '9') {
90: 			// the number continues
91: 			continue;
92: 		} else if (c == ':') {
93: 			// colon: we are parsing a time
94: 			goto interval_parse_time;
95: 		} else {
96: 			if (pos == start_pos) {
97: 				return false;
98: 			}
99: 			// finished the number, parse it from the string
100: 			string_t nr_string(str + start_pos, pos - start_pos);
101: 			number = Cast::Operation<string_t, int64_t>(nr_string);
102: 			if (negative) {
103: 				number = -number;
104: 			}
105: 			goto interval_parse_identifier;
106: 		}
107: 	}
108: 	goto end_of_string;
109: interval_parse_time : {
110: 	// parse the remainder of the time as a Time type
111: 	dtime_t time;
112: 	idx_t pos;
113: 	if (!Time::TryConvertTime(str + start_pos, len, pos, time)) {
114: 		return false;
115: 	}
116: 	result.micros += time.micros;
117: 	found_any = true;
118: 	goto end_of_string;
119: }
120: interval_parse_identifier:
121: 	for (; pos < len; pos++) {
122: 		char c = str[pos];
123: 		if (c == ' ' || c == '\t' || c == '\n') {
124: 			// skip spaces at the start
125: 			continue;
126: 		} else {
127: 			break;
128: 		}
129: 	}
130: 	// now parse the identifier
131: 	start_pos = pos;
132: 	for (; pos < len; pos++) {
133: 		char c = str[pos];
134: 		if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
135: 			// keep parsing the string
136: 			continue;
137: 		} else {
138: 			break;
139: 		}
140: 	}
141: 	specifier_str = string(str + start_pos, pos - start_pos);
142: 	if (!TryGetDatePartSpecifier(specifier_str, specifier)) {
143: 		HandleCastError::AssignError(StringUtil::Format("extract specifier \"%s\" not recognized", specifier_str),
144: 		                             error_message);
145: 		return false;
146: 	}
147: 	// add the specifier to the interval
148: 	switch (specifier) {
149: 	case DatePartSpecifier::MILLENNIUM:
150: 		IntervalTryAddition<int32_t>(result.months, number, MONTHS_PER_MILLENIUM);
151: 		break;
152: 	case DatePartSpecifier::CENTURY:
153: 		IntervalTryAddition<int32_t>(result.months, number, MONTHS_PER_CENTURY);
154: 		break;
155: 	case DatePartSpecifier::DECADE:
156: 		IntervalTryAddition<int32_t>(result.months, number, MONTHS_PER_DECADE);
157: 		break;
158: 	case DatePartSpecifier::YEAR:
159: 		IntervalTryAddition<int32_t>(result.months, number, MONTHS_PER_YEAR);
160: 		break;
161: 	case DatePartSpecifier::QUARTER:
162: 		IntervalTryAddition<int32_t>(result.months, number, MONTHS_PER_QUARTER);
163: 		break;
164: 	case DatePartSpecifier::MONTH:
165: 		IntervalTryAddition<int32_t>(result.months, number, 1);
166: 		break;
167: 	case DatePartSpecifier::DAY:
168: 		IntervalTryAddition<int32_t>(result.days, number, 1);
169: 		break;
170: 	case DatePartSpecifier::WEEK:
171: 		IntervalTryAddition<int32_t>(result.days, number, DAYS_PER_WEEK);
172: 		break;
173: 	case DatePartSpecifier::MICROSECONDS:
174: 		IntervalTryAddition<int64_t>(result.micros, number, 1);
175: 		break;
176: 	case DatePartSpecifier::MILLISECONDS:
177: 		IntervalTryAddition<int64_t>(result.micros, number, MICROS_PER_MSEC);
178: 		break;
179: 	case DatePartSpecifier::SECOND:
180: 		IntervalTryAddition<int64_t>(result.micros, number, MICROS_PER_SEC);
181: 		break;
182: 	case DatePartSpecifier::MINUTE:
183: 		IntervalTryAddition<int64_t>(result.micros, number, MICROS_PER_MINUTE);
184: 		break;
185: 	case DatePartSpecifier::HOUR:
186: 		IntervalTryAddition<int64_t>(result.micros, number, MICROS_PER_HOUR);
187: 		break;
188: 	default:
189: 		HandleCastError::AssignError(
190: 		    StringUtil::Format("extract specifier \"%s\" not supported for interval", specifier_str), error_message);
191: 		return false;
192: 	}
193: 	found_any = true;
194: 	goto standard_interval;
195: interval_parse_ago:
196: 	D_ASSERT(str[pos] == 'a' || str[pos] == 'A');
197: 	// parse the "ago" string at the end of the interval
198: 	if (len - pos < 3) {
199: 		return false;
200: 	}
201: 	pos++;
202: 	if (!(str[pos] == 'g' || str[pos] == 'G')) {
203: 		return false;
204: 	}
205: 	pos++;
206: 	if (!(str[pos] == 'o' || str[pos] == 'O')) {
207: 		return false;
208: 	}
209: 	pos++;
210: 	// parse any trailing whitespace
211: 	for (; pos < len; pos++) {
212: 		char c = str[pos];
213: 		if (c == ' ' || c == '\t' || c == '\n') {
214: 			continue;
215: 		} else {
216: 			return false;
217: 		}
218: 	}
219: 	// invert all the values
220: 	result.months = -result.months;
221: 	result.days = -result.days;
222: 	result.micros = -result.micros;
223: 	goto end_of_string;
224: end_of_string:
225: 	if (!found_any) {
226: 		// end of string and no identifiers were found: cannot convert empty interval
227: 		return false;
228: 	}
229: 	return true;
230: posix_interval:
231: 	return false;
232: }
233: 
234: string Interval::ToString(const interval_t &interval) {
235: 	char buffer[70];
236: 	idx_t length = IntervalToStringCast::Format(interval, buffer);
237: 	return string(buffer, length);
238: }
239: 
240: int64_t Interval::GetMilli(const interval_t &val) {
241: 	int64_t milli_month, milli_day, milli;
242: 	if (!TryMultiplyOperator::Operation((int64_t)val.months, Interval::MICROS_PER_MONTH / 1000, milli_month)) {
243: 		throw ConversionException("Could not convert Interval to Milliseconds");
244: 	}
245: 	if (!TryMultiplyOperator::Operation((int64_t)val.days, Interval::MICROS_PER_DAY / 1000, milli_day)) {
246: 		throw ConversionException("Could not convert Interval to Milliseconds");
247: 	}
248: 	milli = val.micros / 1000;
249: 	if (!TryAddOperator::Operation<int64_t, int64_t, int64_t>(milli, milli_month, milli)) {
250: 		throw ConversionException("Could not convert Interval to Milliseconds");
251: 	}
252: 	if (!TryAddOperator::Operation<int64_t, int64_t, int64_t>(milli, milli_day, milli)) {
253: 		throw ConversionException("Could not convert Interval to Milliseconds");
254: 	}
255: 	return milli;
256: }
257: 
258: int64_t Interval::GetMicro(const interval_t &val) {
259: 	int64_t micro_month, micro_day, micro_total;
260: 	micro_total = val.micros;
261: 	if (!TryMultiplyOperator::Operation((int64_t)val.months, MICROS_PER_MONTH, micro_month)) {
262: 		throw ConversionException("Could not convert Month to Microseconds");
263: 	}
264: 	if (!TryMultiplyOperator::Operation((int64_t)val.days, MICROS_PER_DAY, micro_day)) {
265: 		throw ConversionException("Could not convert Day to Microseconds");
266: 	}
267: 	if (!TryAddOperator::Operation<int64_t, int64_t, int64_t>(micro_total, micro_month, micro_total)) {
268: 		throw ConversionException("Could not convert Interval to Microseconds");
269: 	}
270: 	if (!TryAddOperator::Operation<int64_t, int64_t, int64_t>(micro_total, micro_day, micro_total)) {
271: 		throw ConversionException("Could not convert Interval to Microseconds");
272: 	}
273: 
274: 	return micro_total;
275: }
276: 
277: int64_t Interval::GetNanoseconds(const interval_t &val) {
278: 	int64_t nano;
279: 	const auto micro_total = GetMicro(val);
280: 	if (!TryMultiplyOperator::Operation(micro_total, NANOS_PER_MICRO, nano)) {
281: 		throw ConversionException("Could not convert Interval to Nanoseconds");
282: 	}
283: 
284: 	return nano;
285: }
286: 
287: interval_t Interval::GetAge(timestamp_t timestamp_1, timestamp_t timestamp_2) {
288: 	date_t date1, date2;
289: 	dtime_t time1, time2;
290: 
291: 	Timestamp::Convert(timestamp_1, date1, time1);
292: 	Timestamp::Convert(timestamp_2, date2, time2);
293: 
294: 	// and from date extract the years, months and days
295: 	int32_t year1, month1, day1;
296: 	int32_t year2, month2, day2;
297: 	Date::Convert(date1, year1, month1, day1);
298: 	Date::Convert(date2, year2, month2, day2);
299: 	// finally perform the differences
300: 	auto year_diff = year1 - year2;
301: 	auto month_diff = month1 - month2;
302: 	auto day_diff = day1 - day2;
303: 
304: 	// and from time extract hours, minutes, seconds and milliseconds
305: 	int32_t hour1, min1, sec1, micros1;
306: 	int32_t hour2, min2, sec2, micros2;
307: 	Time::Convert(time1, hour1, min1, sec1, micros1);
308: 	Time::Convert(time2, hour2, min2, sec2, micros2);
309: 	// finally perform the differences
310: 	auto hour_diff = hour1 - hour2;
311: 	auto min_diff = min1 - min2;
312: 	auto sec_diff = sec1 - sec2;
313: 	auto micros_diff = micros1 - micros2;
314: 
315: 	// flip sign if necessary
316: 	bool sign_flipped = false;
317: 	if (timestamp_1 < timestamp_2) {
318: 		year_diff = -year_diff;
319: 		month_diff = -month_diff;
320: 		day_diff = -day_diff;
321: 		hour_diff = -hour_diff;
322: 		min_diff = -min_diff;
323: 		sec_diff = -sec_diff;
324: 		micros_diff = -micros_diff;
325: 		sign_flipped = true;
326: 	}
327: 	// now propagate any negative field into the next higher field
328: 	while (micros_diff < 0) {
329: 		micros_diff += MICROS_PER_SEC;
330: 		sec_diff--;
331: 	}
332: 	while (sec_diff < 0) {
333: 		sec_diff += SECS_PER_MINUTE;
334: 		min_diff--;
335: 	}
336: 	while (min_diff < 0) {
337: 		min_diff += MINS_PER_HOUR;
338: 		hour_diff--;
339: 	}
340: 	while (hour_diff < 0) {
341: 		hour_diff += HOURS_PER_DAY;
342: 		day_diff--;
343: 	}
344: 	while (day_diff < 0) {
345: 		if (timestamp_1 < timestamp_2) {
346: 			day_diff += Date::IsLeapYear(year1) ? Date::LEAP_DAYS[month1] : Date::NORMAL_DAYS[month1];
347: 			month_diff--;
348: 		} else {
349: 			day_diff += Date::IsLeapYear(year2) ? Date::LEAP_DAYS[month2] : Date::NORMAL_DAYS[month2];
350: 			month_diff--;
351: 		}
352: 	}
353: 	while (month_diff < 0) {
354: 		month_diff += MONTHS_PER_YEAR;
355: 		year_diff--;
356: 	}
357: 
358: 	// recover sign if necessary
359: 	if (sign_flipped) {
360: 		year_diff = -year_diff;
361: 		month_diff = -month_diff;
362: 		day_diff = -day_diff;
363: 		hour_diff = -hour_diff;
364: 		min_diff = -min_diff;
365: 		sec_diff = -sec_diff;
366: 		micros_diff = -micros_diff;
367: 	}
368: 	interval_t interval;
369: 	interval.months = year_diff * MONTHS_PER_YEAR + month_diff;
370: 	interval.days = day_diff;
371: 	interval.micros = Time::FromTime(hour_diff, min_diff, sec_diff, micros_diff).micros;
372: 
373: 	return interval;
374: }
375: 
376: interval_t Interval::GetDifference(timestamp_t timestamp_1, timestamp_t timestamp_2) {
377: 	const auto us_1 = Timestamp::GetEpochMicroSeconds(timestamp_1);
378: 	const auto us_2 = Timestamp::GetEpochMicroSeconds(timestamp_2);
379: 	const auto delta_us = us_1 - us_2;
380: 	return FromMicro(delta_us);
381: }
382: 
383: interval_t Interval::FromMicro(int64_t delta_us) {
384: 	interval_t result;
385: 	result.months = 0;
386: 	result.days = delta_us / Interval::MICROS_PER_DAY;
387: 	result.micros = delta_us % Interval::MICROS_PER_DAY;
388: 
389: 	return result;
390: }
391: 
392: static void NormalizeIntervalEntries(interval_t input, int64_t &months, int64_t &days, int64_t &micros) {
393: 	int64_t extra_months_d = input.days / Interval::DAYS_PER_MONTH;
394: 	int64_t extra_months_micros = input.micros / Interval::MICROS_PER_MONTH;
395: 	input.days -= extra_months_d * Interval::DAYS_PER_MONTH;
396: 	input.micros -= extra_months_micros * Interval::MICROS_PER_MONTH;
397: 
398: 	int64_t extra_days_micros = input.micros / Interval::MICROS_PER_DAY;
399: 	input.micros -= extra_days_micros * Interval::MICROS_PER_DAY;
400: 
401: 	months = input.months + extra_months_d + extra_months_micros;
402: 	days = input.days + extra_days_micros;
403: 	micros = input.micros;
404: }
405: 
406: bool Interval::Equals(interval_t left, interval_t right) {
407: 	return left.months == right.months && left.days == right.days && left.micros == right.micros;
408: }
409: 
410: bool Interval::GreaterThan(interval_t left, interval_t right) {
411: 	int64_t lmonths, ldays, lmicros;
412: 	int64_t rmonths, rdays, rmicros;
413: 	NormalizeIntervalEntries(left, lmonths, ldays, lmicros);
414: 	NormalizeIntervalEntries(right, rmonths, rdays, rmicros);
415: 
416: 	if (lmonths > rmonths) {
417: 		return true;
418: 	} else if (lmonths < rmonths) {
419: 		return false;
420: 	}
421: 	if (ldays > rdays) {
422: 		return true;
423: 	} else if (ldays < rdays) {
424: 		return false;
425: 	}
426: 	return lmicros > rmicros;
427: }
428: 
429: bool Interval::GreaterThanEquals(interval_t left, interval_t right) {
430: 	return GreaterThan(left, right) || Equals(left, right);
431: }
432: 
433: } // namespace duckdb
[end of src/common/types/interval.cpp]
[start of src/function/scalar/date/date_part.cpp]
1: #include "duckdb/function/scalar/date_functions.hpp"
2: #include "duckdb/common/enums/date_part_specifier.hpp"
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/types/date.hpp"
5: #include "duckdb/common/types/timestamp.hpp"
6: #include "duckdb/common/vector_operations/vector_operations.hpp"
7: #include "duckdb/common/string_util.hpp"
8: #include "duckdb/storage/statistics/numeric_statistics.hpp"
9: 
10: namespace duckdb {
11: 
12: bool TryGetDatePartSpecifier(const string &specifier_p, DatePartSpecifier &result) {
13: 	auto specifier = StringUtil::Lower(specifier_p);
14: 	if (specifier == "year" || specifier == "y" || specifier == "years") {
15: 		result = DatePartSpecifier::YEAR;
16: 	} else if (specifier == "month" || specifier == "mon" || specifier == "months" || specifier == "mons") {
17: 		result = DatePartSpecifier::MONTH;
18: 	} else if (specifier == "day" || specifier == "days" || specifier == "d") {
19: 		result = DatePartSpecifier::DAY;
20: 	} else if (specifier == "decade" || specifier == "decades") {
21: 		result = DatePartSpecifier::DECADE;
22: 	} else if (specifier == "century" || specifier == "centuries") {
23: 		result = DatePartSpecifier::CENTURY;
24: 	} else if (specifier == "millennium" || specifier == "millenia") {
25: 		result = DatePartSpecifier::MILLENNIUM;
26: 	} else if (specifier == "microseconds" || specifier == "microsecond") {
27: 		result = DatePartSpecifier::MICROSECONDS;
28: 	} else if (specifier == "milliseconds" || specifier == "millisecond" || specifier == "ms" || specifier == "msec" ||
29: 	           specifier == "msecs") {
30: 		result = DatePartSpecifier::MILLISECONDS;
31: 	} else if (specifier == "second" || specifier == "seconds" || specifier == "s") {
32: 		result = DatePartSpecifier::SECOND;
33: 	} else if (specifier == "minute" || specifier == "minutes" || specifier == "m") {
34: 		result = DatePartSpecifier::MINUTE;
35: 	} else if (specifier == "hour" || specifier == "hours" || specifier == "h") {
36: 		result = DatePartSpecifier::HOUR;
37: 	} else if (specifier == "epoch") {
38: 		// seconds since 1970-01-01
39: 		result = DatePartSpecifier::EPOCH;
40: 	} else if (specifier == "dow") {
41: 		// day of the week (Sunday = 0, Saturday = 6)
42: 		result = DatePartSpecifier::DOW;
43: 	} else if (specifier == "isodow") {
44: 		// isodow (Monday = 1, Sunday = 7)
45: 		result = DatePartSpecifier::ISODOW;
46: 	} else if (specifier == "week" || specifier == "weeks" || specifier == "w") {
47: 		// week number
48: 		result = DatePartSpecifier::WEEK;
49: 	} else if (specifier == "doy" || specifier == "dayofyear") {
50: 		// day of the year (1-365/366)
51: 		result = DatePartSpecifier::DOY;
52: 	} else if (specifier == "quarter" || specifier == "quarters") {
53: 		// quarter of the year (1-4)
54: 		result = DatePartSpecifier::QUARTER;
55: 	} else if (specifier == "yearweek") {
56: 		// Combined year and week YYYYWW
57: 		result = DatePartSpecifier::YEARWEEK;
58: 	} else {
59: 		return false;
60: 	}
61: 	return true;
62: }
63: 
64: DatePartSpecifier GetDatePartSpecifier(const string &specifier) {
65: 	DatePartSpecifier result;
66: 	if (!TryGetDatePartSpecifier(specifier, result)) {
67: 		throw ConversionException("extract specifier \"%s\" not recognized", specifier);
68: 	}
69: 	return result;
70: }
71: 
72: template <class T>
73: static void LastYearFunction(DataChunk &args, ExpressionState &state, Vector &result) {
74: 	int32_t last_year = 0;
75: 	UnaryExecutor::Execute<T, int64_t>(args.data[0], result, args.size(),
76: 	                                   [&](T input) { return Date::ExtractYear(input, &last_year); });
77: }
78: 
79: template <class T, class OP>
80: static unique_ptr<BaseStatistics> PropagateDatePartStatistics(vector<unique_ptr<BaseStatistics>> &child_stats) {
81: 	// we can only propagate complex date part stats if the child has stats
82: 	if (!child_stats[0]) {
83: 		return nullptr;
84: 	}
85: 	auto &nstats = (NumericStatistics &)*child_stats[0];
86: 	if (nstats.min.is_null || nstats.max.is_null) {
87: 		return nullptr;
88: 	}
89: 	// run the operator on both the min and the max, this gives us the [min, max] bound
90: 	auto min = nstats.min.GetValueUnsafe<T>();
91: 	auto max = nstats.max.GetValueUnsafe<T>();
92: 	if (min > max) {
93: 		return nullptr;
94: 	}
95: 	auto min_part = OP::template Operation<T, int64_t>(min);
96: 	auto max_part = OP::template Operation<T, int64_t>(max);
97: 	auto result = make_unique<NumericStatistics>(LogicalType::BIGINT, Value::BIGINT(min_part), Value::BIGINT(max_part));
98: 	if (child_stats[0]->validity_stats) {
99: 		result->validity_stats = child_stats[0]->validity_stats->Copy();
100: 	}
101: 	return move(result);
102: }
103: 
104: template <int64_t MIN, int64_t MAX>
105: static unique_ptr<BaseStatistics> PropagateSimpleDatePartStatistics(vector<unique_ptr<BaseStatistics>> &child_stats) {
106: 	// we can always propagate simple date part statistics
107: 	// since the min and max can never exceed these bounds
108: 	auto result = make_unique<NumericStatistics>(LogicalType::BIGINT, Value::BIGINT(MIN), Value::BIGINT(MAX));
109: 	if (!child_stats[0]) {
110: 		// if there are no child stats, we don't know
111: 		result->validity_stats = make_unique<ValidityStatistics>(true);
112: 	} else if (child_stats[0]->validity_stats) {
113: 		result->validity_stats = child_stats[0]->validity_stats->Copy();
114: 	}
115: 	return move(result);
116: }
117: 
118: struct DatePart {
119: 	struct YearOperator {
120: 		template <class TA, class TR>
121: 		static inline TR Operation(TA input) {
122: 			return Date::ExtractYear(input);
123: 		}
124: 
125: 		template <class T>
126: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
127: 		                                                      FunctionData *bind_data,
128: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
129: 			return PropagateDatePartStatistics<T, YearOperator>(child_stats);
130: 		}
131: 	};
132: 
133: 	struct MonthOperator {
134: 		template <class TA, class TR>
135: 		static inline TR Operation(TA input) {
136: 			return Date::ExtractMonth(input);
137: 		}
138: 
139: 		template <class T>
140: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
141: 		                                                      FunctionData *bind_data,
142: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
143: 			// min/max of month operator is [1, 12]
144: 			return PropagateSimpleDatePartStatistics<1, 12>(child_stats);
145: 		}
146: 	};
147: 
148: 	struct DayOperator {
149: 		template <class TA, class TR>
150: 		static inline TR Operation(TA input) {
151: 			return Date::ExtractDay(input);
152: 		}
153: 
154: 		template <class T>
155: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
156: 		                                                      FunctionData *bind_data,
157: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
158: 			// min/max of day operator is [1, 31]
159: 			return PropagateSimpleDatePartStatistics<1, 31>(child_stats);
160: 		}
161: 	};
162: 
163: 	struct DecadeOperator {
164: 		template <class TA, class TR>
165: 		static inline TR Operation(TA input) {
166: 			return YearOperator::Operation<TA, TR>(input) / 10;
167: 		}
168: 
169: 		template <class T>
170: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
171: 		                                                      FunctionData *bind_data,
172: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
173: 			return PropagateDatePartStatistics<T, DecadeOperator>(child_stats);
174: 		}
175: 	};
176: 
177: 	struct CenturyOperator {
178: 		template <class TA, class TR>
179: 		static inline TR Operation(TA input) {
180: 			return ((YearOperator::Operation<TA, TR>(input) - 1) / 100) + 1;
181: 		}
182: 
183: 		template <class T>
184: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
185: 		                                                      FunctionData *bind_data,
186: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
187: 			return PropagateDatePartStatistics<T, CenturyOperator>(child_stats);
188: 		}
189: 	};
190: 
191: 	struct MilleniumOperator {
192: 		template <class TA, class TR>
193: 		static inline TR Operation(TA input) {
194: 			return ((YearOperator::Operation<TA, TR>(input) - 1) / 1000) + 1;
195: 		}
196: 
197: 		template <class T>
198: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
199: 		                                                      FunctionData *bind_data,
200: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
201: 			return PropagateDatePartStatistics<T, MilleniumOperator>(child_stats);
202: 		}
203: 	};
204: 
205: 	struct QuarterOperator {
206: 		template <class TA, class TR>
207: 		static inline TR Operation(TA input) {
208: 			return (Date::ExtractMonth(input) - 1) / Interval::MONTHS_PER_QUARTER + 1;
209: 		}
210: 
211: 		template <class T>
212: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
213: 		                                                      FunctionData *bind_data,
214: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
215: 			// min/max of quarter operator is [1, 4]
216: 			return PropagateSimpleDatePartStatistics<1, 4>(child_stats);
217: 		}
218: 	};
219: 
220: 	struct DayOfWeekOperator {
221: 		template <class TA, class TR>
222: 		static inline TR Operation(TA input) {
223: 			// day of the week (Sunday = 0, Saturday = 6)
224: 			// turn sunday into 0 by doing mod 7
225: 			return Date::ExtractISODayOfTheWeek(input) % 7;
226: 		}
227: 
228: 		template <class T>
229: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
230: 		                                                      FunctionData *bind_data,
231: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
232: 			return PropagateSimpleDatePartStatistics<0, 6>(child_stats);
233: 		}
234: 	};
235: 
236: 	struct ISODayOfWeekOperator {
237: 		template <class TA, class TR>
238: 		static inline TR Operation(TA input) {
239: 			// isodow (Monday = 1, Sunday = 7)
240: 			return Date::ExtractISODayOfTheWeek(input);
241: 		}
242: 
243: 		template <class T>
244: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
245: 		                                                      FunctionData *bind_data,
246: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
247: 			return PropagateSimpleDatePartStatistics<1, 7>(child_stats);
248: 		}
249: 	};
250: 
251: 	struct DayOfYearOperator {
252: 		template <class TA, class TR>
253: 		static inline TR Operation(TA input) {
254: 			return Date::ExtractDayOfTheYear(input);
255: 		}
256: 
257: 		template <class T>
258: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
259: 		                                                      FunctionData *bind_data,
260: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
261: 			return PropagateSimpleDatePartStatistics<1, 366>(child_stats);
262: 		}
263: 	};
264: 
265: 	struct WeekOperator {
266: 		template <class TA, class TR>
267: 		static inline TR Operation(TA input) {
268: 			return Date::ExtractISOWeekNumber(input);
269: 		}
270: 
271: 		template <class T>
272: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
273: 		                                                      FunctionData *bind_data,
274: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
275: 			return PropagateSimpleDatePartStatistics<1, 54>(child_stats);
276: 		}
277: 	};
278: 
279: 	struct YearWeekOperator {
280: 		template <class TA, class TR>
281: 		static inline TR Operation(TA input) {
282: 			return YearOperator::Operation<TA, TR>(input) * 100 + WeekOperator::Operation<TA, TR>(input);
283: 		}
284: 
285: 		template <class T>
286: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
287: 		                                                      FunctionData *bind_data,
288: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
289: 			return PropagateDatePartStatistics<T, YearWeekOperator>(child_stats);
290: 		}
291: 	};
292: 
293: 	struct MicrosecondsOperator {
294: 		template <class TA, class TR>
295: 		static inline TR Operation(TA input) {
296: 			return 0;
297: 		}
298: 
299: 		template <class T>
300: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
301: 		                                                      FunctionData *bind_data,
302: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
303: 			return PropagateSimpleDatePartStatistics<0, 60000000>(child_stats);
304: 		}
305: 	};
306: 
307: 	struct MillisecondsOperator {
308: 		template <class TA, class TR>
309: 		static inline TR Operation(TA input) {
310: 			return 0;
311: 		}
312: 
313: 		template <class T>
314: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
315: 		                                                      FunctionData *bind_data,
316: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
317: 			return PropagateSimpleDatePartStatistics<0, 60000>(child_stats);
318: 		}
319: 	};
320: 
321: 	struct SecondsOperator {
322: 		template <class TA, class TR>
323: 		static inline TR Operation(TA input) {
324: 			return 0;
325: 		}
326: 
327: 		template <class T>
328: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
329: 		                                                      FunctionData *bind_data,
330: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
331: 			return PropagateSimpleDatePartStatistics<0, 60>(child_stats);
332: 		}
333: 	};
334: 
335: 	struct MinutesOperator {
336: 		template <class TA, class TR>
337: 		static inline TR Operation(TA input) {
338: 			return 0;
339: 		}
340: 
341: 		template <class T>
342: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
343: 		                                                      FunctionData *bind_data,
344: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
345: 			return PropagateSimpleDatePartStatistics<0, 60>(child_stats);
346: 		}
347: 	};
348: 
349: 	struct HoursOperator {
350: 		template <class TA, class TR>
351: 		static inline TR Operation(TA input) {
352: 			return 0;
353: 		}
354: 
355: 		template <class T>
356: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
357: 		                                                      FunctionData *bind_data,
358: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
359: 			return PropagateSimpleDatePartStatistics<0, 24>(child_stats);
360: 		}
361: 	};
362: 
363: 	struct EpochOperator {
364: 		template <class TA, class TR>
365: 		static inline TR Operation(TA input) {
366: 			return Date::Epoch(input);
367: 		}
368: 
369: 		template <class T>
370: 		static unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, BoundFunctionExpression &expr,
371: 		                                                      FunctionData *bind_data,
372: 		                                                      vector<unique_ptr<BaseStatistics>> &child_stats) {
373: 			return PropagateDatePartStatistics<T, EpochOperator>(child_stats);
374: 		}
375: 	};
376: };
377: 
378: template <>
379: int64_t DatePart::YearOperator::Operation(timestamp_t input) {
380: 	return YearOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
381: }
382: 
383: template <>
384: int64_t DatePart::YearOperator::Operation(interval_t input) {
385: 	return input.months / Interval::MONTHS_PER_YEAR;
386: }
387: 
388: template <>
389: int64_t DatePart::YearOperator::Operation(dtime_t input) {
390: 	throw NotImplementedException("\"time\" units \"year\" not recognized");
391: }
392: 
393: template <>
394: int64_t DatePart::MonthOperator::Operation(timestamp_t input) {
395: 	return MonthOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
396: }
397: 
398: template <>
399: int64_t DatePart::MonthOperator::Operation(interval_t input) {
400: 	return input.months % Interval::MONTHS_PER_YEAR;
401: }
402: 
403: template <>
404: int64_t DatePart::MonthOperator::Operation(dtime_t input) {
405: 	throw NotImplementedException("\"time\" units \"month\" not recognized");
406: }
407: 
408: template <>
409: int64_t DatePart::DayOperator::Operation(timestamp_t input) {
410: 	return DayOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
411: }
412: 
413: template <>
414: int64_t DatePart::DayOperator::Operation(interval_t input) {
415: 	return input.days;
416: }
417: 
418: template <>
419: int64_t DatePart::DayOperator::Operation(dtime_t input) {
420: 	throw NotImplementedException("\"time\" units \"day\" not recognized");
421: }
422: 
423: template <>
424: int64_t DatePart::DecadeOperator::Operation(interval_t input) {
425: 	return input.months / Interval::MONTHS_PER_DECADE;
426: }
427: 
428: template <>
429: int64_t DatePart::DecadeOperator::Operation(dtime_t input) {
430: 	throw NotImplementedException("\"time\" units \"decade\" not recognized");
431: }
432: 
433: template <>
434: int64_t DatePart::CenturyOperator::Operation(interval_t input) {
435: 	return input.months / Interval::MONTHS_PER_CENTURY;
436: }
437: 
438: template <>
439: int64_t DatePart::CenturyOperator::Operation(dtime_t input) {
440: 	throw NotImplementedException("\"time\" units \"century\" not recognized");
441: }
442: 
443: template <>
444: int64_t DatePart::MilleniumOperator::Operation(interval_t input) {
445: 	return input.months / Interval::MONTHS_PER_MILLENIUM;
446: }
447: 
448: template <>
449: int64_t DatePart::MilleniumOperator::Operation(dtime_t input) {
450: 	throw NotImplementedException("\"time\" units \"millennium\" not recognized");
451: }
452: 
453: template <>
454: int64_t DatePart::QuarterOperator::Operation(timestamp_t input) {
455: 	return QuarterOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
456: }
457: 
458: template <>
459: int64_t DatePart::QuarterOperator::Operation(interval_t input) {
460: 	return MonthOperator::Operation<interval_t, int64_t>(input) / Interval::MONTHS_PER_QUARTER + 1;
461: }
462: 
463: template <>
464: int64_t DatePart::QuarterOperator::Operation(dtime_t input) {
465: 	throw NotImplementedException("\"time\" units \"quarter\" not recognized");
466: }
467: 
468: template <>
469: int64_t DatePart::DayOfWeekOperator::Operation(timestamp_t input) {
470: 	return DayOfWeekOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
471: }
472: 
473: template <>
474: int64_t DatePart::DayOfWeekOperator::Operation(interval_t input) {
475: 	throw NotImplementedException("interval units \"dow\" not recognized");
476: }
477: 
478: template <>
479: int64_t DatePart::DayOfWeekOperator::Operation(dtime_t input) {
480: 	throw NotImplementedException("\"time\" units \"dow\" not recognized");
481: }
482: 
483: template <>
484: int64_t DatePart::ISODayOfWeekOperator::Operation(timestamp_t input) {
485: 	return ISODayOfWeekOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
486: }
487: 
488: template <>
489: int64_t DatePart::ISODayOfWeekOperator::Operation(interval_t input) {
490: 	throw NotImplementedException("interval units \"isodow\" not recognized");
491: }
492: 
493: template <>
494: int64_t DatePart::ISODayOfWeekOperator::Operation(dtime_t input) {
495: 	throw NotImplementedException("\"time\" units \"isodow\" not recognized");
496: }
497: 
498: template <>
499: int64_t DatePart::DayOfYearOperator::Operation(timestamp_t input) {
500: 	return DayOfYearOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
501: }
502: 
503: template <>
504: int64_t DatePart::DayOfYearOperator::Operation(interval_t input) {
505: 	throw NotImplementedException("interval units \"doy\" not recognized");
506: }
507: 
508: template <>
509: int64_t DatePart::DayOfYearOperator::Operation(dtime_t input) {
510: 	throw NotImplementedException("\"time\" units \"doy\" not recognized");
511: }
512: 
513: template <>
514: int64_t DatePart::WeekOperator::Operation(timestamp_t input) {
515: 	return WeekOperator::Operation<date_t, int64_t>(Timestamp::GetDate(input));
516: }
517: 
518: template <>
519: int64_t DatePart::WeekOperator::Operation(interval_t input) {
520: 	throw NotImplementedException("interval units \"week\" not recognized");
521: }
522: 
523: template <>
524: int64_t DatePart::WeekOperator::Operation(dtime_t input) {
525: 	throw NotImplementedException("\"time\" units \"week\" not recognized");
526: }
527: 
528: template <>
529: int64_t DatePart::YearWeekOperator::Operation(dtime_t input) {
530: 	throw NotImplementedException("\"time\" units \"yearweek\" not recognized");
531: }
532: 
533: template <>
534: int64_t DatePart::MicrosecondsOperator::Operation(timestamp_t input) {
535: 	auto time = Timestamp::GetTime(input);
536: 	// remove everything but the second & microsecond part
537: 	return time.micros % Interval::MICROS_PER_MINUTE;
538: }
539: 
540: template <>
541: int64_t DatePart::MicrosecondsOperator::Operation(interval_t input) {
542: 	// remove everything but the second & microsecond part
543: 	return input.micros;
544: }
545: 
546: template <>
547: int64_t DatePart::MicrosecondsOperator::Operation(dtime_t input) {
548: 	// remove everything but the second & microsecond part
549: 	return input.micros % Interval::MICROS_PER_MINUTE;
550: }
551: 
552: template <>
553: int64_t DatePart::MillisecondsOperator::Operation(timestamp_t input) {
554: 	return MicrosecondsOperator::Operation<timestamp_t, int64_t>(input) / Interval::MICROS_PER_MSEC;
555: }
556: 
557: template <>
558: int64_t DatePart::MillisecondsOperator::Operation(interval_t input) {
559: 	return MicrosecondsOperator::Operation<interval_t, int64_t>(input) / Interval::MICROS_PER_MSEC;
560: }
561: 
562: template <>
563: int64_t DatePart::MillisecondsOperator::Operation(dtime_t input) {
564: 	return MicrosecondsOperator::Operation<dtime_t, int64_t>(input) / Interval::MICROS_PER_MSEC;
565: }
566: 
567: template <>
568: int64_t DatePart::SecondsOperator::Operation(timestamp_t input) {
569: 	return MicrosecondsOperator::Operation<timestamp_t, int64_t>(input) / Interval::MICROS_PER_SEC;
570: }
571: 
572: template <>
573: int64_t DatePart::SecondsOperator::Operation(interval_t input) {
574: 	return MicrosecondsOperator::Operation<interval_t, int64_t>(input) / Interval::MICROS_PER_SEC;
575: }
576: 
577: template <>
578: int64_t DatePart::SecondsOperator::Operation(dtime_t input) {
579: 	return MicrosecondsOperator::Operation<dtime_t, int64_t>(input) / Interval::MICROS_PER_SEC;
580: }
581: 
582: template <>
583: int64_t DatePart::MinutesOperator::Operation(timestamp_t input) {
584: 	auto time = Timestamp::GetTime(input);
585: 	// remove the hour part, and truncate to minutes
586: 	return (time.micros % Interval::MICROS_PER_HOUR) / Interval::MICROS_PER_MINUTE;
587: }
588: 
589: template <>
590: int64_t DatePart::MinutesOperator::Operation(interval_t input) {
591: 	// remove the hour part, and truncate to minutes
592: 	return (input.micros % Interval::MICROS_PER_HOUR) / Interval::MICROS_PER_MINUTE;
593: }
594: 
595: template <>
596: int64_t DatePart::MinutesOperator::Operation(dtime_t input) {
597: 	// remove the hour part, and truncate to minutes
598: 	return (input.micros % Interval::MICROS_PER_HOUR) / Interval::MICROS_PER_MINUTE;
599: }
600: 
601: template <>
602: int64_t DatePart::HoursOperator::Operation(timestamp_t input) {
603: 	return Timestamp::GetTime(input).micros / Interval::MICROS_PER_HOUR;
604: }
605: 
606: template <>
607: int64_t DatePart::HoursOperator::Operation(interval_t input) {
608: 	return input.micros / Interval::MICROS_PER_HOUR;
609: }
610: 
611: template <>
612: int64_t DatePart::HoursOperator::Operation(dtime_t input) {
613: 	return input.micros / Interval::MICROS_PER_HOUR;
614: }
615: 
616: template <>
617: int64_t DatePart::EpochOperator::Operation(timestamp_t input) {
618: 	return Timestamp::GetEpochSeconds(input);
619: }
620: 
621: template <>
622: int64_t DatePart::EpochOperator::Operation(interval_t input) {
623: 	auto secs = SecondsOperator::Operation<interval_t, int64_t>(input);
624: 	return (input.months * Interval::DAYS_PER_MONTH + input.days) * Interval::SECS_PER_DAY + secs;
625: }
626: 
627: template <>
628: int64_t DatePart::EpochOperator::Operation(dtime_t input) {
629: 	return SecondsOperator::Operation<dtime_t, int64_t>(input);
630: }
631: 
632: template <>
633: unique_ptr<BaseStatistics>
634: DatePart::EpochOperator::PropagateStatistics<dtime_t>(ClientContext &context, BoundFunctionExpression &expr,
635:                                                       FunctionData *bind_data,
636:                                                       vector<unique_ptr<BaseStatistics>> &child_stats) {
637: 	// time seconds range over a single day
638: 	return PropagateSimpleDatePartStatistics<0, 86400>(child_stats);
639: }
640: 
641: template <class T>
642: static int64_t ExtractElement(DatePartSpecifier type, T element) {
643: 	switch (type) {
644: 	case DatePartSpecifier::YEAR:
645: 		return DatePart::YearOperator::template Operation<T, int64_t>(element);
646: 	case DatePartSpecifier::MONTH:
647: 		return DatePart::MonthOperator::template Operation<T, int64_t>(element);
648: 	case DatePartSpecifier::DAY:
649: 		return DatePart::DayOperator::template Operation<T, int64_t>(element);
650: 	case DatePartSpecifier::DECADE:
651: 		return DatePart::DecadeOperator::template Operation<T, int64_t>(element);
652: 	case DatePartSpecifier::CENTURY:
653: 		return DatePart::CenturyOperator::template Operation<T, int64_t>(element);
654: 	case DatePartSpecifier::MILLENNIUM:
655: 		return DatePart::MilleniumOperator::template Operation<T, int64_t>(element);
656: 	case DatePartSpecifier::QUARTER:
657: 		return DatePart::QuarterOperator::template Operation<T, int64_t>(element);
658: 	case DatePartSpecifier::DOW:
659: 		return DatePart::DayOfWeekOperator::template Operation<T, int64_t>(element);
660: 	case DatePartSpecifier::ISODOW:
661: 		return DatePart::ISODayOfWeekOperator::template Operation<T, int64_t>(element);
662: 	case DatePartSpecifier::DOY:
663: 		return DatePart::DayOfYearOperator::template Operation<T, int64_t>(element);
664: 	case DatePartSpecifier::WEEK:
665: 		return DatePart::WeekOperator::template Operation<T, int64_t>(element);
666: 	case DatePartSpecifier::YEARWEEK:
667: 		return DatePart::YearWeekOperator::template Operation<T, int64_t>(element);
668: 	case DatePartSpecifier::EPOCH:
669: 		return DatePart::EpochOperator::template Operation<T, int64_t>(element);
670: 	case DatePartSpecifier::MICROSECONDS:
671: 		return DatePart::MicrosecondsOperator::template Operation<T, int64_t>(element);
672: 	case DatePartSpecifier::MILLISECONDS:
673: 		return DatePart::MillisecondsOperator::template Operation<T, int64_t>(element);
674: 	case DatePartSpecifier::SECOND:
675: 		return DatePart::SecondsOperator::template Operation<T, int64_t>(element);
676: 	case DatePartSpecifier::MINUTE:
677: 		return DatePart::MinutesOperator::template Operation<T, int64_t>(element);
678: 	case DatePartSpecifier::HOUR:
679: 		return DatePart::HoursOperator::template Operation<T, int64_t>(element);
680: 	default:
681: 		throw NotImplementedException("Specifier type not implemented for DATEPART");
682: 	}
683: }
684: 
685: struct DatePartBinaryOperator {
686: 	template <class TA, class TB, class TR>
687: 	static inline TR Operation(TA specifier, TB date) {
688: 		return ExtractElement<TB>(GetDatePartSpecifier(specifier.GetString()), date);
689: 	}
690: };
691: 
692: template <typename T>
693: static void DatePartFunction(DataChunk &args, ExpressionState &state, Vector &result) {
694: 	D_ASSERT(args.ColumnCount() == 2);
695: 	auto &part_arg = args.data[0];
696: 	auto &date_arg = args.data[1];
697: 
698: 	BinaryExecutor::ExecuteStandard<string_t, T, int64_t, DatePartBinaryOperator>(part_arg, date_arg, result,
699: 	                                                                              args.size());
700: }
701: 
702: void AddGenericDatePartOperator(BuiltinFunctions &set, const string &name, scalar_function_t date_func,
703:                                 scalar_function_t ts_func, scalar_function_t interval_func,
704:                                 function_statistics_t date_stats, function_statistics_t ts_stats) {
705: 	ScalarFunctionSet operator_set(name);
706: 	operator_set.AddFunction(
707: 	    ScalarFunction({LogicalType::DATE}, LogicalType::BIGINT, move(date_func), false, nullptr, nullptr, date_stats));
708: 	operator_set.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::BIGINT, move(ts_func), false,
709: 	                                        nullptr, nullptr, ts_stats));
710: 	operator_set.AddFunction(ScalarFunction({LogicalType::INTERVAL}, LogicalType::BIGINT, move(interval_func)));
711: 	set.AddFunction(operator_set);
712: }
713: 
714: template <class OP>
715: static void AddDatePartOperator(BuiltinFunctions &set, string name) {
716: 	AddGenericDatePartOperator(set, name, ScalarFunction::UnaryFunction<date_t, int64_t, OP>,
717: 	                           ScalarFunction::UnaryFunction<timestamp_t, int64_t, OP>,
718: 	                           ScalarFunction::UnaryFunction<interval_t, int64_t, OP>,
719: 	                           OP::template PropagateStatistics<date_t>, OP::template PropagateStatistics<timestamp_t>);
720: }
721: 
722: void AddGenericTimePartOperator(BuiltinFunctions &set, const string &name, scalar_function_t date_func,
723:                                 scalar_function_t ts_func, scalar_function_t interval_func, scalar_function_t time_func,
724:                                 function_statistics_t date_stats, function_statistics_t ts_stats,
725:                                 function_statistics_t time_stats) {
726: 	ScalarFunctionSet operator_set(name);
727: 	operator_set.AddFunction(
728: 	    ScalarFunction({LogicalType::DATE}, LogicalType::BIGINT, move(date_func), false, nullptr, nullptr, date_stats));
729: 	operator_set.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::BIGINT, move(ts_func), false,
730: 	                                        nullptr, nullptr, ts_stats));
731: 	operator_set.AddFunction(ScalarFunction({LogicalType::INTERVAL}, LogicalType::BIGINT, move(interval_func)));
732: 	operator_set.AddFunction(
733: 	    ScalarFunction({LogicalType::TIME}, LogicalType::BIGINT, move(time_func), false, nullptr, nullptr, time_stats));
734: 	set.AddFunction(operator_set);
735: }
736: 
737: template <class OP>
738: static void AddTimePartOperator(BuiltinFunctions &set, string name) {
739: 	AddGenericTimePartOperator(
740: 	    set, name, ScalarFunction::UnaryFunction<date_t, int64_t, OP>,
741: 	    ScalarFunction::UnaryFunction<timestamp_t, int64_t, OP>, ScalarFunction::UnaryFunction<interval_t, int64_t, OP>,
742: 	    ScalarFunction::UnaryFunction<dtime_t, int64_t, OP>, OP::template PropagateStatistics<date_t>,
743: 	    OP::template PropagateStatistics<timestamp_t>, OP::template PropagateStatistics<dtime_t>);
744: }
745: 
746: struct LastDayOperator {
747: 	template <class TA, class TR>
748: 	static inline TR Operation(TA input) {
749: 		int32_t yyyy, mm, dd;
750: 		Date::Convert(input, yyyy, mm, dd);
751: 		yyyy += (mm / 12);
752: 		mm %= 12;
753: 		++mm;
754: 		return Date::FromDate(yyyy, mm, 1) - 1;
755: 	}
756: };
757: 
758: template <>
759: date_t LastDayOperator::Operation(timestamp_t input) {
760: 	return LastDayOperator::Operation<date_t, date_t>(Timestamp::GetDate(input));
761: }
762: 
763: struct MonthNameOperator {
764: 	template <class TA, class TR>
765: 	static inline TR Operation(TA input) {
766: 		return Date::MONTH_NAMES[DatePart::MonthOperator::Operation<TA, int64_t>(input) - 1];
767: 	}
768: };
769: 
770: struct DayNameOperator {
771: 	template <class TA, class TR>
772: 	static inline TR Operation(TA input) {
773: 		return Date::DAY_NAMES[DatePart::DayOfWeekOperator::Operation<TA, int64_t>(input)];
774: 	}
775: };
776: 
777: void DatePartFun::RegisterFunction(BuiltinFunctions &set) {
778: 	// register the individual operators
779: 	AddGenericDatePartOperator(set, "year", LastYearFunction<date_t>, LastYearFunction<timestamp_t>,
780: 	                           ScalarFunction::UnaryFunction<interval_t, int64_t, DatePart::YearOperator>,
781: 	                           DatePart::YearOperator::PropagateStatistics<date_t>,
782: 	                           DatePart::YearOperator::PropagateStatistics<timestamp_t>);
783: 	AddDatePartOperator<DatePart::MonthOperator>(set, "month");
784: 	AddDatePartOperator<DatePart::DayOperator>(set, "day");
785: 	AddDatePartOperator<DatePart::DecadeOperator>(set, "decade");
786: 	AddDatePartOperator<DatePart::CenturyOperator>(set, "century");
787: 	AddDatePartOperator<DatePart::MilleniumOperator>(set, "millenium");
788: 	AddDatePartOperator<DatePart::QuarterOperator>(set, "quarter");
789: 	AddDatePartOperator<DatePart::DayOfWeekOperator>(set, "dayofweek");
790: 	AddDatePartOperator<DatePart::ISODayOfWeekOperator>(set, "isodow");
791: 	AddDatePartOperator<DatePart::DayOfYearOperator>(set, "dayofyear");
792: 	AddDatePartOperator<DatePart::WeekOperator>(set, "week");
793: 	AddTimePartOperator<DatePart::EpochOperator>(set, "epoch");
794: 	AddTimePartOperator<DatePart::MicrosecondsOperator>(set, "microsecond");
795: 	AddTimePartOperator<DatePart::MillisecondsOperator>(set, "millisecond");
796: 	AddTimePartOperator<DatePart::SecondsOperator>(set, "second");
797: 	AddTimePartOperator<DatePart::MinutesOperator>(set, "minute");
798: 	AddTimePartOperator<DatePart::HoursOperator>(set, "hour");
799: 
800: 	//  register combinations
801: 	AddDatePartOperator<DatePart::YearWeekOperator>(set, "yearweek");
802: 
803: 	//  register various aliases
804: 	AddDatePartOperator<DatePart::DayOperator>(set, "dayofmonth");
805: 	AddDatePartOperator<DatePart::DayOfWeekOperator>(set, "weekday");
806: 	AddDatePartOperator<DatePart::WeekOperator>(set, "weekofyear"); //  Note that WeekOperator is ISO-8601, not US
807: 
808: 	//  register the last_day function
809: 	ScalarFunctionSet last_day("last_day");
810: 	last_day.AddFunction(ScalarFunction({LogicalType::DATE}, LogicalType::DATE,
811: 	                                    ScalarFunction::UnaryFunction<date_t, date_t, LastDayOperator>));
812: 	last_day.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::DATE,
813: 	                                    ScalarFunction::UnaryFunction<timestamp_t, date_t, LastDayOperator>));
814: 	set.AddFunction(last_day);
815: 
816: 	//  register the monthname function
817: 	ScalarFunctionSet monthname("monthname");
818: 	monthname.AddFunction(ScalarFunction({LogicalType::DATE}, LogicalType::VARCHAR,
819: 	                                     ScalarFunction::UnaryFunction<date_t, string_t, MonthNameOperator>));
820: 	monthname.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::VARCHAR,
821: 	                                     ScalarFunction::UnaryFunction<timestamp_t, string_t, MonthNameOperator>));
822: 	set.AddFunction(monthname);
823: 
824: 	//  register the dayname function
825: 	ScalarFunctionSet dayname("dayname");
826: 	dayname.AddFunction(ScalarFunction({LogicalType::DATE}, LogicalType::VARCHAR,
827: 	                                   ScalarFunction::UnaryFunction<date_t, string_t, DayNameOperator>));
828: 	dayname.AddFunction(ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::VARCHAR,
829: 	                                   ScalarFunction::UnaryFunction<timestamp_t, string_t, DayNameOperator>));
830: 	set.AddFunction(dayname);
831: 
832: 	// finally the actual date_part function
833: 	ScalarFunctionSet date_part("date_part");
834: 	date_part.AddFunction(
835: 	    ScalarFunction({LogicalType::VARCHAR, LogicalType::DATE}, LogicalType::BIGINT, DatePartFunction<date_t>));
836: 	date_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::TIMESTAMP}, LogicalType::BIGINT,
837: 	                                     DatePartFunction<timestamp_t>));
838: 	date_part.AddFunction(
839: 	    ScalarFunction({LogicalType::VARCHAR, LogicalType::TIME}, LogicalType::BIGINT, DatePartFunction<dtime_t>));
840: 	date_part.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::INTERVAL}, LogicalType::BIGINT,
841: 	                                     DatePartFunction<interval_t>));
842: 	set.AddFunction(date_part);
843: 	date_part.name = "datepart";
844: 	set.AddFunction(date_part);
845: }
846: 
847: } // namespace duckdb
[end of src/function/scalar/date/date_part.cpp]
[start of src/function/scalar/operators/add.cpp]
1: #include "duckdb/common/operator/add.hpp"
2: 
3: #include "duckdb/common/limits.hpp"
4: #include "duckdb/common/types/value.hpp"
5: 
6: #include "duckdb/common/types/date.hpp"
7: #include "duckdb/common/types/interval.hpp"
8: #include "duckdb/common/types/timestamp.hpp"
9: #include "duckdb/common/types/hugeint.hpp"
10: #include "duckdb/common/windows_undefs.hpp"
11: 
12: #include <limits>
13: 
14: namespace duckdb {
15: 
16: //===--------------------------------------------------------------------===//
17: // + [add]
18: //===--------------------------------------------------------------------===//
19: template <>
20: float AddOperator::Operation(float left, float right) {
21: 	auto result = left + right;
22: 	if (!Value::FloatIsValid(result)) {
23: 		throw OutOfRangeException("Overflow in addition of float!");
24: 	}
25: 	return result;
26: }
27: 
28: template <>
29: double AddOperator::Operation(double left, double right) {
30: 	auto result = left + right;
31: 	if (!Value::DoubleIsValid(result)) {
32: 		throw OutOfRangeException("Overflow in addition of double!");
33: 	}
34: 	return result;
35: }
36: 
37: template <>
38: interval_t AddOperator::Operation(interval_t left, interval_t right) {
39: 	left.months = AddOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.months, right.months);
40: 	left.days = AddOperatorOverflowCheck::Operation<int32_t, int32_t, int32_t>(left.days, right.days);
41: 	left.micros = AddOperatorOverflowCheck::Operation<int64_t, int64_t, int64_t>(left.micros, right.micros);
42: 	return left;
43: }
44: 
45: template <>
46: date_t AddOperator::Operation(date_t left, int32_t right) {
47: 	int32_t result;
48: 	if (!TryAddOperator::Operation(left.days, right, result)) {
49: 		throw OutOfRangeException("Date out of range");
50: 	}
51: 	return date_t(result);
52: }
53: 
54: template <>
55: date_t AddOperator::Operation(int32_t left, date_t right) {
56: 	return AddOperator::Operation<date_t, int32_t, date_t>(right, left);
57: }
58: 
59: template <>
60: date_t AddOperator::Operation(date_t left, interval_t right) {
61: 	date_t result;
62: 	if (right.months != 0) {
63: 		int32_t year, month, day;
64: 		Date::Convert(left, year, month, day);
65: 		int32_t year_diff = right.months / Interval::MONTHS_PER_YEAR;
66: 		year += year_diff;
67: 		month += right.months - year_diff * Interval::MONTHS_PER_YEAR;
68: 		if (month > Interval::MONTHS_PER_YEAR) {
69: 			year++;
70: 			month -= Interval::MONTHS_PER_YEAR;
71: 		} else if (month <= 0) {
72: 			year--;
73: 			month += Interval::MONTHS_PER_YEAR;
74: 		}
75: 		day = MinValue<int32_t>(day, Date::MonthDays(year, month));
76: 		result = Date::FromDate(year, month, day);
77: 	} else {
78: 		result = left;
79: 	}
80: 	if (right.days != 0) {
81: 		if (!TryAddOperator::Operation(result.days, right.days, result.days)) {
82: 			throw OutOfRangeException("Date out of range");
83: 		}
84: 	}
85: 	if (right.micros != 0) {
86: 		if (!TryAddOperator::Operation(result.days, int32_t(right.micros / Interval::MICROS_PER_DAY), result.days)) {
87: 			throw OutOfRangeException("Date out of range");
88: 		}
89: 	}
90: 	return result;
91: }
92: 
93: template <>
94: date_t AddOperator::Operation(interval_t left, date_t right) {
95: 	return AddOperator::Operation<date_t, interval_t, date_t>(right, left);
96: }
97: 
98: dtime_t AddIntervalToTimeOperation(dtime_t left, interval_t right, date_t &date) {
99: 	int64_t diff = right.micros - ((right.micros / Interval::MICROS_PER_DAY) * Interval::MICROS_PER_DAY);
100: 	left += diff;
101: 	if (left.micros >= Interval::MICROS_PER_DAY) {
102: 		left.micros -= Interval::MICROS_PER_DAY;
103: 		date.days++;
104: 	} else if (left.micros < 0) {
105: 		left.micros += Interval::MICROS_PER_DAY;
106: 		date.days--;
107: 	}
108: 	return left;
109: }
110: 
111: template <>
112: timestamp_t AddOperator::Operation(timestamp_t left, interval_t right) {
113: 	date_t date;
114: 	dtime_t time;
115: 	Timestamp::Convert(left, date, time);
116: 	auto new_date = AddOperator::Operation<date_t, interval_t, date_t>(date, right);
117: 	auto new_time = AddIntervalToTimeOperation(time, right, new_date);
118: 	return Timestamp::FromDatetime(new_date, new_time);
119: }
120: 
121: template <>
122: timestamp_t AddOperator::Operation(interval_t left, timestamp_t right) {
123: 	return AddOperator::Operation<timestamp_t, interval_t, timestamp_t>(right, left);
124: }
125: 
126: //===--------------------------------------------------------------------===//
127: // + [add] with overflow check
128: //===--------------------------------------------------------------------===//
129: struct OverflowCheckedAddition {
130: 	template <class SRCTYPE, class UTYPE>
131: 	static inline bool Operation(SRCTYPE left, SRCTYPE right, SRCTYPE &result) {
132: 		UTYPE uresult = AddOperator::Operation<UTYPE, UTYPE, UTYPE>(UTYPE(left), UTYPE(right));
133: 		if (uresult < NumericLimits<SRCTYPE>::Minimum() || uresult > NumericLimits<SRCTYPE>::Maximum()) {
134: 			return false;
135: 		}
136: 		result = SRCTYPE(uresult);
137: 		return true;
138: 	}
139: };
140: 
141: template <>
142: bool TryAddOperator::Operation(uint8_t left, uint8_t right, uint8_t &result) {
143: 	return OverflowCheckedAddition::Operation<uint8_t, uint16_t>(left, right, result);
144: }
145: template <>
146: bool TryAddOperator::Operation(uint16_t left, uint16_t right, uint16_t &result) {
147: 	return OverflowCheckedAddition::Operation<uint16_t, uint32_t>(left, right, result);
148: }
149: template <>
150: bool TryAddOperator::Operation(uint32_t left, uint32_t right, uint32_t &result) {
151: 	return OverflowCheckedAddition::Operation<uint32_t, uint64_t>(left, right, result);
152: }
153: 
154: template <>
155: bool TryAddOperator::Operation(uint64_t left, uint64_t right, uint64_t &result) {
156: 	if (NumericLimits<uint64_t>::Maximum() - left < right) {
157: 		return false;
158: 	}
159: 	return OverflowCheckedAddition::Operation<uint64_t, uint64_t>(left, right, result);
160: }
161: 
162: template <>
163: bool TryAddOperator::Operation(int8_t left, int8_t right, int8_t &result) {
164: 	return OverflowCheckedAddition::Operation<int8_t, int16_t>(left, right, result);
165: }
166: 
167: template <>
168: bool TryAddOperator::Operation(int16_t left, int16_t right, int16_t &result) {
169: 	return OverflowCheckedAddition::Operation<int16_t, int32_t>(left, right, result);
170: }
171: 
172: template <>
173: bool TryAddOperator::Operation(int32_t left, int32_t right, int32_t &result) {
174: 	return OverflowCheckedAddition::Operation<int32_t, int64_t>(left, right, result);
175: }
176: 
177: template <>
178: bool TryAddOperator::Operation(int64_t left, int64_t right, int64_t &result) {
179: #if (__GNUC__ >= 5) || defined(__clang__)
180: 	if (__builtin_add_overflow(left, right, &result)) {
181: 		return false;
182: 	}
183: #else
184: 	// https://blog.regehr.org/archives/1139
185: 	result = int64_t((uint64_t)left + (uint64_t)right);
186: 	if ((left < 0 && right < 0 && result >= 0) || (left >= 0 && right >= 0 && result < 0)) {
187: 		return false;
188: 	}
189: #endif
190: 	return true;
191: }
192: 
193: //===--------------------------------------------------------------------===//
194: // add decimal with overflow check
195: //===--------------------------------------------------------------------===//
196: template <class T, T min, T max>
197: bool TryDecimalAddTemplated(T left, T right, T &result) {
198: 	if (right < 0) {
199: 		if (min - right > left) {
200: 			return false;
201: 		}
202: 	} else {
203: 		if (max - right < left) {
204: 			return false;
205: 		}
206: 	}
207: 	result = left + right;
208: 	return true;
209: }
210: 
211: template <>
212: bool TryDecimalAdd::Operation(int16_t left, int16_t right, int16_t &result) {
213: 	return TryDecimalAddTemplated<int16_t, -9999, 9999>(left, right, result);
214: }
215: 
216: template <>
217: bool TryDecimalAdd::Operation(int32_t left, int32_t right, int32_t &result) {
218: 	return TryDecimalAddTemplated<int32_t, -999999999, 999999999>(left, right, result);
219: }
220: 
221: template <>
222: bool TryDecimalAdd::Operation(int64_t left, int64_t right, int64_t &result) {
223: 	return TryDecimalAddTemplated<int64_t, -999999999999999999, 999999999999999999>(left, right, result);
224: }
225: 
226: template <>
227: bool TryDecimalAdd::Operation(hugeint_t left, hugeint_t right, hugeint_t &result) {
228: 	result = left + right;
229: 	if (result <= -Hugeint::POWERS_OF_TEN[38] || result >= Hugeint::POWERS_OF_TEN[38]) {
230: 		return false;
231: 	}
232: 	return true;
233: }
234: 
235: template <>
236: hugeint_t DecimalAddOverflowCheck::Operation(hugeint_t left, hugeint_t right) {
237: 	hugeint_t result;
238: 	if (!TryDecimalAdd::Operation(left, right, result)) {
239: 		throw OutOfRangeException("Overflow in addition of DECIMAL(38) (%s + %s);", left.ToString(), right.ToString());
240: 	}
241: 	return result;
242: }
243: 
244: //===--------------------------------------------------------------------===//
245: // add time operator
246: //===--------------------------------------------------------------------===//
247: template <>
248: dtime_t AddTimeOperator::Operation(dtime_t left, interval_t right) {
249: 	date_t date(0);
250: 	return AddIntervalToTimeOperation(left, right, date);
251: }
252: 
253: template <>
254: dtime_t AddTimeOperator::Operation(interval_t left, dtime_t right) {
255: 	return AddTimeOperator::Operation<dtime_t, interval_t, dtime_t>(right, left);
256: }
257: 
258: } // namespace duckdb
[end of src/function/scalar/operators/add.cpp]
[start of src/include/duckdb/common/types/interval.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/interval.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/types.hpp"
12: 
13: namespace duckdb {
14: 
15: //! The Interval class is a static class that holds helper functions for the Interval
16: //! type.
17: class Interval {
18: public:
19: 	static constexpr const int32_t MONTHS_PER_MILLENIUM = 12000;
20: 	static constexpr const int32_t MONTHS_PER_CENTURY = 1200;
21: 	static constexpr const int32_t MONTHS_PER_DECADE = 120;
22: 	static constexpr const int32_t MONTHS_PER_YEAR = 12;
23: 	static constexpr const int32_t MONTHS_PER_QUARTER = 3;
24: 	static constexpr const int32_t DAYS_PER_WEEK = 7;
25: 	static constexpr const int64_t DAYS_PER_MONTH =
26: 	    30; // only used for interval comparison/ordering purposes, in which case a month counts as 30 days
27: 	static constexpr const int64_t MSECS_PER_SEC = 1000;
28: 	static constexpr const int32_t SECS_PER_MINUTE = 60;
29: 	static constexpr const int32_t MINS_PER_HOUR = 60;
30: 	static constexpr const int32_t HOURS_PER_DAY = 24;
31: 	static constexpr const int32_t SECS_PER_HOUR = SECS_PER_MINUTE * MINS_PER_HOUR;
32: 	static constexpr const int32_t SECS_PER_DAY = SECS_PER_HOUR * HOURS_PER_DAY;
33: 	static constexpr const int32_t SECS_PER_WEEK = SECS_PER_DAY * DAYS_PER_WEEK;
34: 
35: 	static constexpr const int64_t MICROS_PER_MSEC = 1000;
36: 	static constexpr const int64_t MICROS_PER_SEC = MICROS_PER_MSEC * MSECS_PER_SEC;
37: 	static constexpr const int64_t MICROS_PER_MINUTE = MICROS_PER_SEC * SECS_PER_MINUTE;
38: 	static constexpr const int64_t MICROS_PER_HOUR = MICROS_PER_MINUTE * MINS_PER_HOUR;
39: 	static constexpr const int64_t MICROS_PER_DAY = MICROS_PER_HOUR * HOURS_PER_DAY;
40: 	static constexpr const int64_t MICROS_PER_WEEK = MICROS_PER_DAY * DAYS_PER_WEEK;
41: 	static constexpr const int64_t MICROS_PER_MONTH = MICROS_PER_DAY * DAYS_PER_MONTH;
42: 
43: 	static constexpr const int64_t NANOS_PER_MICRO = 1000;
44: 	static constexpr const int64_t NANOS_PER_MSEC = NANOS_PER_MICRO * MICROS_PER_MSEC;
45: 	static constexpr const int64_t NANOS_PER_SEC = NANOS_PER_MSEC * MSECS_PER_SEC;
46: 	static constexpr const int64_t NANOS_PER_MINUTE = NANOS_PER_SEC * SECS_PER_MINUTE;
47: 	static constexpr const int64_t NANOS_PER_HOUR = NANOS_PER_MINUTE * MINS_PER_HOUR;
48: 	static constexpr const int64_t NANOS_PER_DAY = NANOS_PER_HOUR * HOURS_PER_DAY;
49: 	static constexpr const int64_t NANOS_PER_WEEK = NANOS_PER_DAY * DAYS_PER_WEEK;
50: 
51: public:
52: 	//! Convert a string to an interval object
53: 	static bool FromString(const string &str, interval_t &result);
54: 	//! Convert a string to an interval object
55: 	static bool FromCString(const char *str, idx_t len, interval_t &result, string *error_message, bool strict);
56: 	//! Convert an interval object to a string
57: 	static string ToString(const interval_t &val);
58: 
59: 	//! Convert milliseconds to a normalised interval
60: 	static interval_t FromMicro(int64_t micros);
61: 
62: 	//! Get Interval in milliseconds
63: 	static int64_t GetMilli(const interval_t &val);
64: 
65: 	//! Get Interval in microseconds
66: 	static int64_t GetMicro(const interval_t &val);
67: 
68: 	//! Get Interval in Nanoseconds
69: 	static int64_t GetNanoseconds(const interval_t &val);
70: 
71: 	//! Returns the age between two timestamps (including 30 day months)
72: 	static interval_t GetAge(timestamp_t timestamp_1, timestamp_t timestamp_2);
73: 
74: 	//! Returns the exact difference between two timestamps (days and seconds)
75: 	static interval_t GetDifference(timestamp_t timestamp_1, timestamp_t timestamp_2);
76: 
77: 	//! Comparison operators
78: 	static bool Equals(interval_t left, interval_t right);
79: 	static bool GreaterThan(interval_t left, interval_t right);
80: 	static bool GreaterThanEquals(interval_t left, interval_t right);
81: };
82: } // namespace duckdb
[end of src/include/duckdb/common/types/interval.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: