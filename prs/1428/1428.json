{
  "repo": "duckdb/duckdb",
  "pull_number": 1428,
  "instance_id": "duckdb__duckdb-1428",
  "issue_numbers": [
    "1427"
  ],
  "base_commit": "9b5955456aa58a854eebd9317810668d2eb0a01a",
  "patch": "diff --git a/extension/tpch/dbgen/dbgen.cpp b/extension/tpch/dbgen/dbgen.cpp\nindex 8b2f6c9c18e6..e104376be6f0 100644\n--- a/extension/tpch/dbgen/dbgen.cpp\n+++ b/extension/tpch/dbgen/dbgen.cpp\n@@ -548,8 +548,8 @@ template <class T> static void CreateTPCHTable(ClientContext &context, string sc\n \t\tinfo->columns.push_back(ColumnDefinition(T::Columns[i], T::Types[i]));\n \t\tinfo->constraints.push_back(make_unique<NotNullConstraint>(i));\n \t}\n-\tBinder binder(context);\n-\tauto bound_info = binder.BindCreateTableInfo(move(info));\n+\tauto binder = Binder::CreateBinder(context);\n+\tauto bound_info = binder->BindCreateTableInfo(move(info));\n \tauto &catalog = Catalog::GetCatalog(context);\n \n \tcatalog.CreateTable(context, bound_info.get());\ndiff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp\nindex da1d915166ce..4acb9d76f821 100644\n--- a/src/catalog/catalog_entry/table_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp\n@@ -190,8 +190,8 @@ unique_ptr<CatalogEntry> TableCatalogEntry::RenameColumn(ClientContext &context,\n \t\t}\n \t\tcreate_info->constraints.push_back(move(copy));\n \t}\n-\tBinder binder(context);\n-\tauto bound_create_info = binder.BindCreateTableInfo(move(create_info));\n+\tauto binder = Binder::CreateBinder(context);\n+\tauto bound_create_info = binder->BindCreateTableInfo(move(create_info));\n \treturn make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(), storage);\n }\n \n@@ -204,8 +204,8 @@ unique_ptr<CatalogEntry> TableCatalogEntry::AddColumn(ClientContext &context, Ad\n \tinfo.new_column.oid = columns.size();\n \tcreate_info->columns.push_back(info.new_column.Copy());\n \n-\tBinder binder(context);\n-\tauto bound_create_info = binder.BindCreateTableInfo(move(create_info));\n+\tauto binder = Binder::CreateBinder(context);\n+\tauto bound_create_info = binder->BindCreateTableInfo(move(create_info));\n \tauto new_storage =\n \t    make_shared<DataTable>(context, *storage, info.new_column, bound_create_info->bound_defaults.back().get());\n \treturn make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(),\n@@ -291,8 +291,8 @@ unique_ptr<CatalogEntry> TableCatalogEntry::RemoveColumn(ClientContext &context,\n \t\t}\n \t}\n \n-\tBinder binder(context);\n-\tauto bound_create_info = binder.BindCreateTableInfo(move(create_info));\n+\tauto binder = Binder::CreateBinder(context);\n+\tauto bound_create_info = binder->BindCreateTableInfo(move(create_info));\n \tauto new_storage = make_shared<DataTable>(context, *storage, removed_index);\n \treturn make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(),\n \t                                      new_storage);\n@@ -319,8 +319,8 @@ unique_ptr<CatalogEntry> TableCatalogEntry::SetDefault(ClientContext &context, S\n \t\tcreate_info->constraints.push_back(move(constraint));\n \t}\n \n-\tBinder binder(context);\n-\tauto bound_create_info = binder.BindCreateTableInfo(move(create_info));\n+\tauto binder = Binder::CreateBinder(context);\n+\tauto bound_create_info = binder->BindCreateTableInfo(move(create_info));\n \treturn make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(), storage);\n }\n \n@@ -366,13 +366,13 @@ unique_ptr<CatalogEntry> TableCatalogEntry::ChangeColumnType(ClientContext &cont\n \t\tcreate_info->constraints.push_back(move(constraint));\n \t}\n \n-\tBinder binder(context);\n+\tauto binder = Binder::CreateBinder(context);\n \t// bind the specified expression\n \tvector<column_t> bound_columns;\n-\tAlterBinder expr_binder(binder, context, name, columns, bound_columns, info.target_type);\n+\tAlterBinder expr_binder(*binder, context, name, columns, bound_columns, info.target_type);\n \tauto expression = info.expression->Copy();\n \tauto bound_expression = expr_binder.Bind(expression);\n-\tauto bound_create_info = binder.BindCreateTableInfo(move(create_info));\n+\tauto bound_create_info = binder->BindCreateTableInfo(move(create_info));\n \tif (bound_columns.empty()) {\n \t\tbound_columns.push_back(COLUMN_IDENTIFIER_ROW_ID);\n \t}\n@@ -532,8 +532,8 @@ unique_ptr<CatalogEntry> TableCatalogEntry::Copy(ClientContext &context) {\n \t\tcreate_info->constraints.push_back(move(constraint));\n \t}\n \n-\tBinder binder(context);\n-\tauto bound_create_info = binder.BindCreateTableInfo(move(create_info));\n+\tauto binder = Binder::CreateBinder(context);\n+\tauto bound_create_info = binder->BindCreateTableInfo(move(create_info));\n \treturn make_unique<TableCatalogEntry>(catalog, schema, (BoundCreateTableInfo *)bound_create_info.get(), storage);\n }\n \ndiff --git a/src/catalog/default/default_views.cpp b/src/catalog/default/default_views.cpp\nindex 27f7e20a0dd2..ef75ab38415e 100644\n--- a/src/catalog/default/default_views.cpp\n+++ b/src/catalog/default/default_views.cpp\n@@ -51,8 +51,8 @@ DefaultViewGenerator::DefaultViewGenerator(Catalog &catalog, SchemaCatalogEntry\n unique_ptr<CatalogEntry> DefaultViewGenerator::CreateDefaultEntry(ClientContext &context, const string &entry_name) {\n \tauto info = GetDefaultView(schema->name, entry_name);\n \tif (info) {\n-\t\tBinder binder(context);\n-\t\tbinder.BindCreateViewInfo(*info);\n+\t\tauto binder = Binder::CreateBinder(context);\n+\t\tbinder->BindCreateViewInfo(*info);\n \n \t\treturn make_unique_base<CatalogEntry, ViewCatalogEntry>(&catalog, schema, info.get());\n \t}\ndiff --git a/src/include/duckdb/common/types.hpp b/src/include/duckdb/common/types.hpp\nindex a273bc08767c..1b66c087e66a 100644\n--- a/src/include/duckdb/common/types.hpp\n+++ b/src/include/duckdb/common/types.hpp\n@@ -84,7 +84,7 @@ template <class T>\n using buffer_ptr = single_thread_ptr<T>;\n \n template <class T, typename... Args>\n-buffer_ptr<T> make_buffer(Args &&... args) {\n+buffer_ptr<T> make_buffer(Args &&...args) {\n \treturn single_thread_make_shared<T>(std::forward<Args>(args)...);\n }\n \ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex e9c22eaeef57..e3d8c03244d0 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -52,12 +52,12 @@ struct CorrelatedColumnInfo {\n   tables and columns in the catalog. In the process, it also resolves types of\n   all expressions.\n */\n-class Binder {\n+class Binder : public std::enable_shared_from_this<Binder> {\n \tfriend class ExpressionBinder;\n \tfriend class RecursiveSubqueryPlanner;\n \n public:\n-\texplicit Binder(ClientContext &context, Binder *parent = nullptr, bool inherit_ctes = true);\n+\tstatic shared_ptr<Binder> CreateBinder(ClientContext &context, Binder *parent = nullptr, bool inherit_ctes = true);\n \n \t//! The client context\n \tClientContext &context;\n@@ -127,7 +127,7 @@ class Binder {\n \n private:\n \t//! The parent binder (if any)\n-\tBinder *parent;\n+\tshared_ptr<Binder> parent;\n \t//! The vector of active binders\n \tvector<ExpressionBinder *> active_binders;\n \t//! The count of bound_tables\n@@ -223,6 +223,10 @@ class Binder {\n \n \tstring FindBinding(const string &using_column, const string &join_side);\n \tbool TryFindBinding(const string &using_column, const string &join_side, string &result);\n+\n+public:\n+\t// This should really be a private constructor, but make_shared does not allow it...\n+\tBinder(bool I_know_what_I_am_doing, ClientContext &context, shared_ptr<Binder> parent, bool inherit_ctes);\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression/bound_subquery_expression.hpp b/src/include/duckdb/planner/expression/bound_subquery_expression.hpp\nindex 8a517057429c..54b1bcc4bfc9 100644\n--- a/src/include/duckdb/planner/expression/bound_subquery_expression.hpp\n+++ b/src/include/duckdb/planner/expression/bound_subquery_expression.hpp\n@@ -24,7 +24,7 @@ class BoundSubqueryExpression : public Expression {\n \t}\n \n \t//! The binder used to bind the subquery node\n-\tunique_ptr<Binder> binder;\n+\tshared_ptr<Binder> binder;\n \t//! The bound subquery node\n \tunique_ptr<BoundQueryNode> subquery;\n \t//! The subquery type\ndiff --git a/src/include/duckdb/planner/planner.hpp b/src/include/duckdb/planner/planner.hpp\nindex 4898e0525e45..1c04bb5cb014 100644\n--- a/src/include/duckdb/planner/planner.hpp\n+++ b/src/include/duckdb/planner/planner.hpp\n@@ -29,7 +29,7 @@ class Planner {\n \tvector<LogicalType> types;\n \tunordered_map<idx_t, vector<unique_ptr<Value>>> value_map;\n \n-\tBinder binder;\n+\tshared_ptr<Binder> binder;\n \tClientContext &context;\n \n \tbool read_only;\ndiff --git a/src/include/duckdb/planner/query_node/bound_recursive_cte_node.hpp b/src/include/duckdb/planner/query_node/bound_recursive_cte_node.hpp\nindex 790bcda0d3f7..7ed87cce4220 100644\n--- a/src/include/duckdb/planner/query_node/bound_recursive_cte_node.hpp\n+++ b/src/include/duckdb/planner/query_node/bound_recursive_cte_node.hpp\n@@ -31,9 +31,9 @@ class BoundRecursiveCTENode : public BoundQueryNode {\n \t//! Index used by the set operation\n \tidx_t setop_index;\n \t//! The binder used by the left side of the set operation\n-\tunique_ptr<Binder> left_binder;\n+\tshared_ptr<Binder> left_binder;\n \t//! The binder used by the right side of the set operation\n-\tunique_ptr<Binder> right_binder;\n+\tshared_ptr<Binder> right_binder;\n \n public:\n \tidx_t GetRootIndex() override {\ndiff --git a/src/include/duckdb/planner/query_node/bound_set_operation_node.hpp b/src/include/duckdb/planner/query_node/bound_set_operation_node.hpp\nindex de3f2c7390cd..bfd9f7e9b26a 100644\n--- a/src/include/duckdb/planner/query_node/bound_set_operation_node.hpp\n+++ b/src/include/duckdb/planner/query_node/bound_set_operation_node.hpp\n@@ -30,9 +30,9 @@ class BoundSetOperationNode : public BoundQueryNode {\n \t//! Index used by the set operation\n \tidx_t setop_index;\n \t//! The binder used by the left side of the set operation\n-\tunique_ptr<Binder> left_binder;\n+\tshared_ptr<Binder> left_binder;\n \t//! The binder used by the right side of the set operation\n-\tunique_ptr<Binder> right_binder;\n+\tshared_ptr<Binder> right_binder;\n \n public:\n \tidx_t GetRootIndex() override {\ndiff --git a/src/include/duckdb/planner/tableref/bound_crossproductref.hpp b/src/include/duckdb/planner/tableref/bound_crossproductref.hpp\nindex 3c7b240b51db..034d158afc61 100644\n--- a/src/include/duckdb/planner/tableref/bound_crossproductref.hpp\n+++ b/src/include/duckdb/planner/tableref/bound_crossproductref.hpp\n@@ -20,9 +20,9 @@ class BoundCrossProductRef : public BoundTableRef {\n \t}\n \n \t//! The binder used to bind the LHS of the cross product\n-\tunique_ptr<Binder> left_binder;\n+\tshared_ptr<Binder> left_binder;\n \t//! The binder used to bind the RHS of the cross product\n-\tunique_ptr<Binder> right_binder;\n+\tshared_ptr<Binder> right_binder;\n \t//! The left hand side of the cross product\n \tunique_ptr<BoundTableRef> left;\n \t//! The right hand side of the cross product\ndiff --git a/src/include/duckdb/planner/tableref/bound_joinref.hpp b/src/include/duckdb/planner/tableref/bound_joinref.hpp\nindex dbff84d9e3d8..b583a9bc0d1b 100644\n--- a/src/include/duckdb/planner/tableref/bound_joinref.hpp\n+++ b/src/include/duckdb/planner/tableref/bound_joinref.hpp\n@@ -22,9 +22,9 @@ class BoundJoinRef : public BoundTableRef {\n \t}\n \n \t//! The binder used to bind the LHS of the join\n-\tunique_ptr<Binder> left_binder;\n+\tshared_ptr<Binder> left_binder;\n \t//! The binder used to bind the RHS of the join\n-\tunique_ptr<Binder> right_binder;\n+\tshared_ptr<Binder> right_binder;\n \t//! The left hand side of the join\n \tunique_ptr<BoundTableRef> left;\n \t//! The right hand side of the join\ndiff --git a/src/include/duckdb/planner/tableref/bound_subqueryref.hpp b/src/include/duckdb/planner/tableref/bound_subqueryref.hpp\nindex bd9379a5434f..78eaf2651ef0 100644\n--- a/src/include/duckdb/planner/tableref/bound_subqueryref.hpp\n+++ b/src/include/duckdb/planner/tableref/bound_subqueryref.hpp\n@@ -17,12 +17,12 @@ namespace duckdb {\n //! Represents a cross product\n class BoundSubqueryRef : public BoundTableRef {\n public:\n-\tBoundSubqueryRef(unique_ptr<Binder> binder, unique_ptr<BoundQueryNode> subquery)\n-\t    : BoundTableRef(TableReferenceType::SUBQUERY), binder(move(binder)), subquery(move(subquery)) {\n+\tBoundSubqueryRef(shared_ptr<Binder> binder_p, unique_ptr<BoundQueryNode> subquery)\n+\t    : BoundTableRef(TableReferenceType::SUBQUERY), binder(move(binder_p)), subquery(move(subquery)) {\n \t}\n \n \t//! The binder used to bind the subquery\n-\tunique_ptr<Binder> binder;\n+\tshared_ptr<Binder> binder;\n \t//! The bound subquery node\n \tunique_ptr<BoundQueryNode> subquery;\n };\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex b60e5543abf2..1adc29c589ec 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -166,7 +166,7 @@ shared_ptr<PreparedStatementData> ClientContext::CreatePreparedStatement(ClientC\n \n \tif (enable_optimizer) {\n \t\tprofiler.StartPhase(\"optimizer\");\n-\t\tOptimizer optimizer(planner.binder, *this);\n+\t\tOptimizer optimizer(*planner.binder, *this);\n \t\tplan = optimizer.Optimize(move(plan));\n \t\tD_ASSERT(plan);\n \t\tprofiler.EndPhase();\n@@ -730,8 +730,8 @@ void ClientContext::Append(TableDescription &description, DataChunk &chunk) {\n void ClientContext::TryBindRelation(Relation &relation, vector<ColumnDefinition> &result_columns) {\n \tRunFunctionInTransaction([&]() {\n \t\t// bind the expressions\n-\t\tBinder binder(*this);\n-\t\tauto result = relation.Bind(binder);\n+\t\tauto binder = Binder::CreateBinder(*this);\n+\t\tauto result = relation.Bind(*binder);\n \t\tD_ASSERT(result.names.size() == result.types.size());\n \t\tfor (idx_t i = 0; i < result.names.size(); i++) {\n \t\t\tresult_columns.emplace_back(result.names[i], result.types[i]);\ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex 1fa856989fb4..8c5a1ea84a7f 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -11,9 +11,13 @@\n \n namespace duckdb {\n \n-Binder::Binder(ClientContext &context, Binder *parent_p, bool inherit_ctes_p)\n-    : context(context), read_only(true), requires_valid_transaction(true), allow_stream_result(false), parent(parent_p),\n-      bound_tables(0), inherit_ctes(inherit_ctes_p) {\n+shared_ptr<Binder> Binder::CreateBinder(ClientContext &context, Binder *parent, bool inherit_ctes) {\n+\treturn make_shared<Binder>(true, context, parent ? parent->shared_from_this() : nullptr, inherit_ctes);\n+}\n+\n+Binder::Binder(bool, ClientContext &context, shared_ptr<Binder> parent_p, bool inherit_ctes_p)\n+    : context(context), read_only(true), requires_valid_transaction(true), allow_stream_result(false),\n+      parent(move(parent_p)), bound_tables(0), inherit_ctes(inherit_ctes_p) {\n \tif (parent) {\n \t\t// We have to inherit macro parameter bindings from the parent binder, if there is a parent.\n \t\tmacro_binding = parent->macro_binding;\ndiff --git a/src/planner/binder/expression/bind_subquery_expression.cpp b/src/planner/binder/expression/bind_subquery_expression.cpp\nindex 7addab3d9ba6..cbab7b4bbb0c 100644\n--- a/src/planner/binder/expression/bind_subquery_expression.cpp\n+++ b/src/planner/binder/expression/bind_subquery_expression.cpp\n@@ -8,13 +8,13 @@ namespace duckdb {\n \n class BoundSubqueryNode : public QueryNode {\n public:\n-\tBoundSubqueryNode(unique_ptr<Binder> subquery_binder, unique_ptr<BoundQueryNode> bound_node,\n+\tBoundSubqueryNode(shared_ptr<Binder> subquery_binder, unique_ptr<BoundQueryNode> bound_node,\n \t                  unique_ptr<SelectStatement> subquery)\n \t    : QueryNode(QueryNodeType::BOUND_SUBQUERY_NODE), subquery_binder(move(subquery_binder)),\n \t      bound_node(move(bound_node)), subquery(move(subquery)) {\n \t}\n \n-\tunique_ptr<Binder> subquery_binder;\n+\tshared_ptr<Binder> subquery_binder;\n \tunique_ptr<BoundQueryNode> bound_node;\n \tunique_ptr<SelectStatement> subquery;\n \n@@ -31,7 +31,7 @@ BindResult ExpressionBinder::BindExpression(SubqueryExpression &expr, idx_t dept\n \tif (expr.subquery->node->type != QueryNodeType::BOUND_SUBQUERY_NODE) {\n \t\tD_ASSERT(depth == 0);\n \t\t// first bind the actual subquery in a new binder\n-\t\tauto subquery_binder = make_unique<Binder>(context, &binder);\n+\t\tauto subquery_binder = Binder::CreateBinder(context, &binder);\n \t\tauto bound_node = subquery_binder->BindNode(*expr.subquery->node);\n \t\t// check the correlated columns of the subquery for correlated columns with depth > 1\n \t\tfor (idx_t i = 0; i < subquery_binder->correlated_columns.size(); i++) {\ndiff --git a/src/planner/binder/query_node/bind_recursive_cte_node.cpp b/src/planner/binder/query_node/bind_recursive_cte_node.cpp\nindex 90cd15cfdd47..ef22f4fa2e1a 100644\n--- a/src/planner/binder/query_node/bind_recursive_cte_node.cpp\n+++ b/src/planner/binder/query_node/bind_recursive_cte_node.cpp\n@@ -20,7 +20,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(RecursiveCTENode &statement) {\n \tresult->union_all = statement.union_all;\n \tresult->setop_index = GenerateTableIndex();\n \n-\tresult->left_binder = make_unique<Binder>(context, this);\n+\tresult->left_binder = Binder::CreateBinder(context, this);\n \tresult->left = result->left_binder->BindNode(*statement.left);\n \n \t// the result types of the CTE are the types of the LHS\n@@ -34,7 +34,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(RecursiveCTENode &statement) {\n \t// This allows the right side to reference the CTE recursively\n \tbind_context.AddGenericBinding(result->setop_index, statement.ctename, result->names, result->types);\n \n-\tresult->right_binder = make_unique<Binder>(context, this);\n+\tresult->right_binder = Binder::CreateBinder(context, this);\n \n \t// Add bindings of left side to temporary CTE bindings context\n \tresult->right_binder->bind_context.AddCTEBinding(result->setop_index, statement.ctename, result->names,\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 0a23d4484aba..a4c02a6ca928 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -39,8 +39,9 @@ unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, un\n \n unique_ptr<Expression> BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,\n                                      int64_t &delimiter_value) {\n-\tBinder new_binder(context);\n-\tExpressionBinder expr_binder(new_binder, context);\n+\n+\tauto new_binder = Binder::CreateBinder(context);\n+\tExpressionBinder expr_binder(*new_binder, context);\n \texpr_binder.target_type = LogicalType::UBIGINT;\n \tauto expr = expr_binder.Bind(delimiter);\n \tif (expr->IsFoldable()) {\ndiff --git a/src/planner/binder/query_node/bind_setop_node.cpp b/src/planner/binder/query_node/bind_setop_node.cpp\nindex 3c751f4d1285..349194253538 100644\n--- a/src/planner/binder/query_node/bind_setop_node.cpp\n+++ b/src/planner/binder/query_node/bind_setop_node.cpp\n@@ -68,10 +68,10 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SetOperationNode &statement) {\n \n \tresult->setop_index = GenerateTableIndex();\n \n-\tresult->left_binder = make_unique<Binder>(context, this);\n+\tresult->left_binder = Binder::CreateBinder(context, this);\n \tresult->left = result->left_binder->BindNode(*statement.left);\n \n-\tresult->right_binder = make_unique<Binder>(context, this);\n+\tresult->right_binder = Binder::CreateBinder(context, this);\n \tresult->right = result->right_binder->BindNode(*statement.right);\n \n \tif (!statement.modifiers.empty()) {\ndiff --git a/src/planner/binder/query_node/plan_subquery.cpp b/src/planner/binder/query_node/plan_subquery.cpp\nindex 7b9b38ce1eda..0509ceb50a4f 100644\n--- a/src/planner/binder/query_node/plan_subquery.cpp\n+++ b/src/planner/binder/query_node/plan_subquery.cpp\n@@ -296,9 +296,9 @@ unique_ptr<Expression> Binder::PlanSubquery(BoundSubqueryExpression &expr, uniqu\n \tD_ASSERT(root);\n \t// first we translate the QueryNode of the subquery into a logical plan\n \t// note that we do not plan nested subqueries yet\n-\tBinder sub_binder(context);\n-\tsub_binder.plan_subquery = false;\n-\tauto subquery_root = sub_binder.CreatePlan(*expr.subquery);\n+\tauto sub_binder = Binder::CreateBinder(context);\n+\tsub_binder->plan_subquery = false;\n+\tauto subquery_root = sub_binder->CreatePlan(*expr.subquery);\n \tD_ASSERT(subquery_root);\n \n \t// now we actually flatten the subquery\n@@ -310,7 +310,7 @@ unique_ptr<Expression> Binder::PlanSubquery(BoundSubqueryExpression &expr, uniqu\n \t\tresult_expression = PlanCorrelatedSubquery(*this, expr, root, move(plan));\n \t}\n \t// finally, we recursively plan the nested subqueries (if there are any)\n-\tif (sub_binder.has_unplanned_subqueries) {\n+\tif (sub_binder->has_unplanned_subqueries) {\n \t\tRecursiveSubqueryPlanner plan(*this);\n \t\tplan.VisitOperator(*root);\n \t}\ndiff --git a/src/planner/binder/statement/bind_export.cpp b/src/planner/binder/statement/bind_export.cpp\nindex 58841a3f09e5..2b73b1e274f4 100644\n--- a/src/planner/binder/statement/bind_export.cpp\n+++ b/src/planner/binder/statement/bind_export.cpp\n@@ -66,8 +66,8 @@ BoundStatement Binder::Bind(ExportStatement &stmt) {\n \t\tCopyStatement copy_stmt;\n \t\tcopy_stmt.info = move(info);\n \n-\t\tBinder copy_binder(context);\n-\t\tauto bound_statement = copy_binder.Bind(copy_stmt);\n+\t\tauto copy_binder = Binder::CreateBinder(context);\n+\t\tauto bound_statement = copy_binder->Bind(copy_stmt);\n \t\tif (child_operator) {\n \t\t\t// use UNION ALL to combine the individual copy statements into a single node\n \t\t\tauto copy_union =\ndiff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex 0d2e6c32c86a..6a69aa6f34d4 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -89,13 +89,13 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \t\t// defined for this binder so there are no collisions between the CTEs defined\n \t\t// for the view and for the current query\n \t\tbool inherit_ctes = false;\n-\t\tBinder view_binder(context, this, inherit_ctes);\n+\t\tauto view_binder = Binder::CreateBinder(context, this, inherit_ctes);\n \t\tSubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(view_catalog_entry->query->Copy()));\n \t\tsubquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;\n \t\tsubquery.column_name_alias =\n \t\t    BindContext::AliasColumnNames(subquery.alias, view_catalog_entry->aliases, ref.column_name_alias);\n \t\t// bind the child subquery\n-\t\tauto bound_child = view_binder.Bind(subquery);\n+\t\tauto bound_child = view_binder->Bind(subquery);\n \t\tD_ASSERT(bound_child->type == TableReferenceType::SUBQUERY);\n \t\t// verify that the types and names match up with the expected types and names\n \t\tauto &bound_subquery = (BoundSubqueryRef &)*bound_child;\ndiff --git a/src/planner/binder/tableref/bind_crossproductref.cpp b/src/planner/binder/tableref/bind_crossproductref.cpp\nindex 16abd6952405..79cb5de2e5f0 100644\n--- a/src/planner/binder/tableref/bind_crossproductref.cpp\n+++ b/src/planner/binder/tableref/bind_crossproductref.cpp\n@@ -6,8 +6,8 @@ namespace duckdb {\n \n unique_ptr<BoundTableRef> Binder::Bind(CrossProductRef &ref) {\n \tauto result = make_unique<BoundCrossProductRef>();\n-\tresult->left_binder = make_unique<Binder>(context, this);\n-\tresult->right_binder = make_unique<Binder>(context, this);\n+\tresult->left_binder = Binder::CreateBinder(context, this);\n+\tresult->right_binder = Binder::CreateBinder(context, this);\n \tauto &left_binder = *result->left_binder;\n \tauto &right_binder = *result->right_binder;\n \ndiff --git a/src/planner/binder/tableref/bind_joinref.cpp b/src/planner/binder/tableref/bind_joinref.cpp\nindex d728807f539f..8c193f906273 100644\n--- a/src/planner/binder/tableref/bind_joinref.cpp\n+++ b/src/planner/binder/tableref/bind_joinref.cpp\n@@ -92,8 +92,8 @@ static void SetPrimaryBinding(UsingColumnSet &set, JoinType join_type, const str\n \n unique_ptr<BoundTableRef> Binder::Bind(JoinRef &ref) {\n \tauto result = make_unique<BoundJoinRef>();\n-\tresult->left_binder = make_unique<Binder>(context, this);\n-\tresult->right_binder = make_unique<Binder>(context, this);\n+\tresult->left_binder = Binder::CreateBinder(context, this);\n+\tresult->right_binder = Binder::CreateBinder(context, this);\n \tauto &left_binder = *result->left_binder;\n \tauto &right_binder = *result->right_binder;\n \ndiff --git a/src/planner/binder/tableref/bind_subqueryref.cpp b/src/planner/binder/tableref/bind_subqueryref.cpp\nindex d27aae6ebc29..4fe116796f09 100644\n--- a/src/planner/binder/tableref/bind_subqueryref.cpp\n+++ b/src/planner/binder/tableref/bind_subqueryref.cpp\n@@ -5,7 +5,7 @@\n namespace duckdb {\n \n unique_ptr<BoundTableRef> Binder::Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte) {\n-\tauto binder = make_unique<Binder>(context, this);\n+\tauto binder = Binder::CreateBinder(context, this);\n \tif (cte) {\n \t\tbinder->bound_ctes.insert(cte);\n \t}\ndiff --git a/src/planner/planner.cpp b/src/planner/planner.cpp\nindex c418f71998f3..511266a67439 100644\n--- a/src/planner/planner.cpp\n+++ b/src/planner/planner.cpp\n@@ -17,7 +17,7 @@\n \n namespace duckdb {\n \n-Planner::Planner(ClientContext &context) : binder(context), context(context) {\n+Planner::Planner(ClientContext &context) : binder(Binder::CreateBinder(context)), context(context) {\n }\n \n void Planner::CreatePlan(SQLStatement &statement) {\n@@ -25,13 +25,13 @@ void Planner::CreatePlan(SQLStatement &statement) {\n \n \t// first bind the tables and columns to the catalog\n \tcontext.profiler.StartPhase(\"binder\");\n-\tbinder.parameters = &bound_parameters;\n-\tauto bound_statement = binder.Bind(statement);\n+\tbinder->parameters = &bound_parameters;\n+\tauto bound_statement = binder->Bind(statement);\n \tcontext.profiler.EndPhase();\n \n-\tthis->read_only = binder.read_only;\n-\tthis->requires_valid_transaction = binder.requires_valid_transaction;\n-\tthis->allow_stream_result = binder.allow_stream_result;\n+\tthis->read_only = binder->read_only;\n+\tthis->requires_valid_transaction = binder->requires_valid_transaction;\n+\tthis->allow_stream_result = binder->allow_stream_result;\n \tthis->names = bound_statement.names;\n \tthis->types = bound_statement.types;\n \tthis->plan = move(bound_statement.plan);\n@@ -100,7 +100,7 @@ void Planner::PlanExecute(unique_ptr<SQLStatement> statement) {\n \t// the bound prepared statement is ready: bind any supplied parameters\n \tvector<Value> bind_values;\n \tfor (idx_t i = 0; i < stmt.values.size(); i++) {\n-\t\tConstantBinder cbinder(binder, context, \"EXECUTE statement\");\n+\t\tConstantBinder cbinder(*binder, context, \"EXECUTE statement\");\n \t\tcbinder.target_type = prepared->GetType(i + 1);\n \t\tauto bound_expr = cbinder.Bind(stmt.values[i]);\n \ndiff --git a/src/storage/checkpoint_manager.cpp b/src/storage/checkpoint_manager.cpp\nindex eb8e5a0dea15..282edb58cb45 100644\n--- a/src/storage/checkpoint_manager.cpp\n+++ b/src/storage/checkpoint_manager.cpp\n@@ -264,8 +264,8 @@ void CheckpointManager::ReadTable(ClientContext &context, MetaBlockReader &reade\n \t// deserialize the table meta data\n \tauto info = TableCatalogEntry::Deserialize(reader);\n \t// bind the info\n-\tBinder binder(context);\n-\tauto bound_info = binder.BindCreateTableInfo(move(info));\n+\tauto binder = Binder::CreateBinder(context);\n+\tauto bound_info = binder->BindCreateTableInfo(move(info));\n \n \t// now read the actual table data and place it into the create table info\n \tauto block_id = reader.Read<block_id_t>();\ndiff --git a/src/storage/wal_replay.cpp b/src/storage/wal_replay.cpp\nindex 7f04c181e8c7..bdcf143cb571 100644\n--- a/src/storage/wal_replay.cpp\n+++ b/src/storage/wal_replay.cpp\n@@ -210,8 +210,8 @@ void ReplayState::ReplayCreateTable() {\n \t}\n \n \t// bind the constraints to the table again\n-\tBinder binder(context);\n-\tauto bound_info = binder.BindCreateTableInfo(move(info));\n+\tauto binder = Binder::CreateBinder(context);\n+\tauto bound_info = binder->BindCreateTableInfo(move(info));\n \n \tauto &catalog = Catalog::GetCatalog(context);\n \tcatalog.CreateTable(context, bound_info.get());\n",
  "test_patch": "diff --git a/test/issues/general/test_1427.test b/test/issues/general/test_1427.test\nnew file mode 100644\nindex 000000000000..f27c607e64e4\n--- /dev/null\n+++ b/test/issues/general/test_1427.test\n@@ -0,0 +1,27 @@\n+# name: test/issues/general/test_1427.test\n+# description: Issue 1427: Segment Fault Crash when select a view (which has IN statement)\n+# group: [general]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create table t as select 123 as a\n+\n+statement ok\n+select * from (select 123 as a) t where a in (select 123 );\n+\n+statement ok\n+select * from t where a in (select 123 );\n+\n+statement ok\n+create view t0 as select * from t where a in (select 123 );\n+\n+statement ok\n+select * from t0\n+\n+statement ok\n+create view t1 as select * from (select 123 as a) t where a in (select 123 );\n+\n+statement ok\n+select * from t1\n",
  "problem_statement": "Segment Fault Crash when select a view (which has IN statement)\nFor latest master branch (including 0.2.4 release), when I execute the following 2 sql, duckdb will crash with  segment fault error.\r\n\r\n```\r\ncreate view t1 as select * from (select 123 as a) t where a in (select 123 );\r\n\r\nselect * from t1\r\n```\r\n\r\n\r\nthe call stack for this crash will be:\r\n\r\n```\r\n=================================================================\r\n==70572==ERROR: AddressSanitizer: stack-buffer-underflow on address 0x7ffee1d00788 at pc 0x00010ec0ccba bp 0x7ffee1cfe630 sp 0x7ffee1cfe628\r\nREAD of size 8 at 0x7ffee1d00788 thread T0\r\n    #0 0x10ec0ccb9 in duckdb::Binder::GenerateTableIndex() binder.cpp:221\r\n    #1 0x10ec0cd48 in duckdb::Binder::GenerateTableIndex() binder.cpp:222\r\n    #2 0x10e7815d9 in duckdb::PlanUncorrelatedSubquery(duckdb::Binder&, duckdb::BoundSubqueryExpression&, std::__1::unique_ptr<duckdb::LogicalOperator, std::__1::default_delete<duckdb::LogicalOperator> >&, std::__1::unique_ptr<duckdb::LogicalOperator, std::__1::default_delete<duckdb::LogicalOperator> >) plan_subquery.cpp:115\r\n    #3 0x10e77be59 in duckdb::Binder::PlanSubquery(duckdb::BoundSubqueryExpression&, std::__1::unique_ptr<duckdb::LogicalOperator, std::__1::default_delete<duckdb::LogicalOperator> >&) plan_subquery.cpp:308\r\n    #4 0x10e76e5b3 in duckdb::Binder::PlanSubqueries(std::__1::unique_ptr<duckdb::Expression, std::__1::default_delete<duckdb::Expression> >*, std::__1::unique_ptr<duckdb::LogicalOperator, std::__1::default_delete<duckdb::LogicalOperator> >*) plan_subquery.cpp:340\r\n    #5 0x10e76d77a in duckdb::Binder::PlanFilter(std::__1::unique_ptr<duckdb::Expression, std::__1::default_delete<duckdb::Expression> >, std::__1::unique_ptr<duckdb::LogicalOperator, std::__1::default_delete<duckdb::LogicalOperator> >) plan_select_node.cpp:12\r\n    #6 0x10e76f5b5 in duckdb::Binder::CreatePlan(duckdb::BoundSelectNode&) plan_select_node.cpp:30\r\n    #7 0x10ec06a03 in duckdb::Binder::CreatePlan(duckdb::BoundQueryNode&) binder.cpp:109\r\n    #8 0x10e9be930 in duckdb::Binder::CreatePlan(duckdb::BoundSubqueryRef&) plan_subqueryref.cpp:10\r\n    #9 0x10ec08a38 in duckdb::Binder::CreatePlan(duckdb::BoundTableRef&) binder.cpp:157\r\n    #10 0x10e76f0a6 in duckdb::Binder::CreatePlan(duckdb::BoundSelectNode&) plan_select_node.cpp:21\r\n    #11 0x10ec06a03 in duckdb::Binder::CreatePlan(duckdb::BoundQueryNode&) binder.cpp:109\r\n    #12 0x10ec05d4f in duckdb::Binder::Bind(duckdb::QueryNode&) binder.cpp:102\r\n    #13 0x10e84da53 in duckdb::Binder::Bind(duckdb::SelectStatement&) bind_select.cpp:9\r\n    #14 0x10ec02260 in duckdb::Binder::Bind(duckdb::SQLStatement&) binder.cpp:33\r\n    #15 0x10ec2913a in duckdb::Planner::CreatePlan(duckdb::SQLStatement&) planner.cpp:29\r\n    #16 0x10ec2ef98 in duckdb::Planner::CreatePlan(std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >) planner.cpp:160\r\n    #17 0x11289d076 in duckdb::ClientContext::CreatePreparedStatement(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >) client_context.cpp:153\r\n    #18 0x112a29dc9 in duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >)::$_0::operator()() const client_context.cpp:270\r\n    #19 0x112a299f6 in decltype(std::__1::forward<duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >)::$_0&>(fp)()) std::__1::__invoke<duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >)::$_0&>(duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >)::$_0&) type_traits:4361\r\n    #20 0x112a29856 in void std::__1::__invoke_void_return_wrapper<void>::__call<duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >)::$_0&>(duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >)::$_0&) __functional_base:349\r\n    #21 0x112a297b2 in std::__1::__function::__alloc_func<duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >)::$_0, std::__1::allocator<duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >)::$_0>, void ()>::operator()() functional:1527\r\n    #22 0x112a23806 in std::__1::__function::__func<duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >)::$_0, std::__1::allocator<duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >)::$_0>, void ()>::operator()() functional:1651\r\n    #23 0x112a42864 in std::__1::__function::__value_func<void ()>::operator()() const functional:1799\r\n    #24 0x1128c0ec2 in std::__1::function<void ()>::operator()() const functional:2347\r\n    #25 0x1128a81dc in duckdb::ClientContext::RunFunctionInTransactionInternal(duckdb::ClientContextLock&, std::__1::function<void ()> const&, bool) client_context.cpp:669\r\n    #26 0x1128a77b6 in duckdb::ClientContext::PrepareInternal(duckdb::ClientContextLock&, std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >) client_context.cpp:269\r\n    #27 0x1128a93af in duckdb::ClientContext::Prepare(std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >) client_context.cpp:280\r\n    #28 0x1128ca2c8 in duckdb::Connection::Prepare(std::__1::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement> >) connection.cpp:80\r\n    #29 0x10e030bf7 in sqlite3_prepare_v2 sqlite3_api_wrapper.cpp:163\r\n    #30 0x10df523b4 in shell_exec shell.c:13106\r\n    #31 0x10e0082cc in runOneSqlLine shell.c:20022\r\n    #32 0x10df56ab0 in process_input shell.c:20122\r\n    #33 0x10df1a19f in main shell.c:20906\r\n    #34 0x7fff71b79cc8 in start (libdyld.dylib:x86_64+0x1acc8)\r\n\r\nAddress 0x7ffee1d00788 is located in stack of thread T0 at offset 8 in frame\r\n    #0 0x10e76d5ff in duckdb::Binder::PlanFilter(std::__1::unique_ptr<duckdb::Expression, std::__1::default_delete<duckdb::Expression> >, std::__1::unique_ptr<duckdb::LogicalOperator, std::__1::default_delete<duckdb::LogicalOperator> >) plan_select_node.cpp:11\r\n```\r\n\r\n\r\n\r\nSeems this only happens when \"create view\" (not create table\" && contains \"IN\" or \"NOT IN\".\r\n\n",
  "hints_text": "I can confirm that this segfaults. Thanks for the report! Will investigate.",
  "created_at": "2021-02-22T10:29:36Z"
}