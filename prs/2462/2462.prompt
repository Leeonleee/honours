You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Coalesce operator with subquery throws error
**What does happen?**
A query with a coalesce call with a subquery as argument, throws the error: Serialization Error: Cannot copy BoundSubqueryExpression

**What should happen?**
Output 1

**To Reproduce**
Steps to reproduce the behavior. Bonus points if those are only SQL queries.
1. SELECT 1 FROM (select 4) v1(vc0) WHERE (3) NOT IN (COALESCE((SELECT 1 WHERE FALSE), v1.vc0));

**Environment (please complete the following information):**
 - OS: Linux
 - DuckDB Version compiled from sources at changeset 8e2e97528

**Before submitting**
- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?
- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds

Coalesce operator with subquery throws error
**What does happen?**
A query with a coalesce call with a subquery as argument, throws the error: Serialization Error: Cannot copy BoundSubqueryExpression

**What should happen?**
Output 1

**To Reproduce**
Steps to reproduce the behavior. Bonus points if those are only SQL queries.
1. SELECT 1 FROM (select 4) v1(vc0) WHERE (3) NOT IN (COALESCE((SELECT 1 WHERE FALSE), v1.vc0));

**Environment (please complete the following information):**
 - OS: Linux
 - DuckDB Version compiled from sources at changeset 8e2e97528

**Before submitting**
- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?
- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/execution/expression_executor.cpp]
1: #include "duckdb/execution/expression_executor.hpp"
2: 
3: #include "duckdb/common/vector_operations/vector_operations.hpp"
4: #include "duckdb/execution/execution_context.hpp"
5: #include "duckdb/storage/statistics/base_statistics.hpp"
6: 
7: namespace duckdb {
8: 
9: ExpressionExecutor::ExpressionExecutor() {
10: }
11: 
12: ExpressionExecutor::ExpressionExecutor(const Expression *expression) : ExpressionExecutor() {
13: 	D_ASSERT(expression);
14: 	AddExpression(*expression);
15: }
16: 
17: ExpressionExecutor::ExpressionExecutor(const Expression &expression) : ExpressionExecutor() {
18: 	AddExpression(expression);
19: }
20: 
21: ExpressionExecutor::ExpressionExecutor(const vector<unique_ptr<Expression>> &exprs) : ExpressionExecutor() {
22: 	D_ASSERT(exprs.size() > 0);
23: 	for (auto &expr : exprs) {
24: 		AddExpression(*expr);
25: 	}
26: }
27: 
28: void ExpressionExecutor::AddExpression(const Expression &expr) {
29: 	expressions.push_back(&expr);
30: 	auto state = make_unique<ExpressionExecutorState>(expr.ToString());
31: 	Initialize(expr, *state);
32: 	states.push_back(move(state));
33: }
34: 
35: void ExpressionExecutor::Initialize(const Expression &expression, ExpressionExecutorState &state) {
36: 	state.root_state = InitializeState(expression, state);
37: 	state.executor = this;
38: }
39: 
40: void ExpressionExecutor::Execute(DataChunk *input, DataChunk &result) {
41: 	SetChunk(input);
42: 	D_ASSERT(expressions.size() == result.ColumnCount());
43: 	D_ASSERT(!expressions.empty());
44: 
45: 	for (idx_t i = 0; i < expressions.size(); i++) {
46: 		ExecuteExpression(i, result.data[i]);
47: 	}
48: 	result.SetCardinality(input ? input->size() : 1);
49: 	result.Verify();
50: }
51: 
52: void ExpressionExecutor::ExecuteExpression(DataChunk &input, Vector &result) {
53: 	SetChunk(&input);
54: 	ExecuteExpression(result);
55: }
56: 
57: idx_t ExpressionExecutor::SelectExpression(DataChunk &input, SelectionVector &sel) {
58: 	D_ASSERT(expressions.size() == 1);
59: 	SetChunk(&input);
60: 	states[0]->profiler.BeginSample();
61: 	idx_t selected_tuples = Select(*expressions[0], states[0]->root_state.get(), nullptr, input.size(), &sel, nullptr);
62: 	states[0]->profiler.EndSample(chunk ? chunk->size() : 0);
63: 	return selected_tuples;
64: }
65: 
66: void ExpressionExecutor::ExecuteExpression(Vector &result) {
67: 	D_ASSERT(expressions.size() == 1);
68: 	ExecuteExpression(0, result);
69: }
70: 
71: void ExpressionExecutor::ExecuteExpression(idx_t expr_idx, Vector &result) {
72: 	D_ASSERT(expr_idx < expressions.size());
73: 	D_ASSERT(result.GetType().id() == expressions[expr_idx]->return_type.id());
74: 	states[expr_idx]->profiler.BeginSample();
75: 	Execute(*expressions[expr_idx], states[expr_idx]->root_state.get(), nullptr, chunk ? chunk->size() : 1, result);
76: 	states[expr_idx]->profiler.EndSample(chunk ? chunk->size() : 0);
77: }
78: 
79: Value ExpressionExecutor::EvaluateScalar(const Expression &expr) {
80: 	D_ASSERT(expr.IsFoldable());
81: 	// use an ExpressionExecutor to execute the expression
82: 	ExpressionExecutor executor(expr);
83: 
84: 	Vector result(expr.return_type);
85: 	executor.ExecuteExpression(result);
86: 
87: 	D_ASSERT(result.GetVectorType() == VectorType::CONSTANT_VECTOR);
88: 	auto result_value = result.GetValue(0);
89: 	D_ASSERT(result_value.type().InternalType() == expr.return_type.InternalType());
90: 	return result_value;
91: }
92: 
93: void ExpressionExecutor::Verify(const Expression &expr, Vector &vector, idx_t count) {
94: 	D_ASSERT(expr.return_type.id() == vector.GetType().id());
95: 	vector.Verify(count);
96: 	if (expr.verification_stats) {
97: 		expr.verification_stats->Verify(vector, count);
98: 	}
99: }
100: 
101: unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const Expression &expr,
102:                                                                 ExpressionExecutorState &state) {
103: 	switch (expr.expression_class) {
104: 	case ExpressionClass::BOUND_REF:
105: 		return InitializeState((const BoundReferenceExpression &)expr, state);
106: 	case ExpressionClass::BOUND_BETWEEN:
107: 		return InitializeState((const BoundBetweenExpression &)expr, state);
108: 	case ExpressionClass::BOUND_CASE:
109: 		return InitializeState((const BoundCaseExpression &)expr, state);
110: 	case ExpressionClass::BOUND_CAST:
111: 		return InitializeState((const BoundCastExpression &)expr, state);
112: 	case ExpressionClass::BOUND_COMPARISON:
113: 		return InitializeState((const BoundComparisonExpression &)expr, state);
114: 	case ExpressionClass::BOUND_CONJUNCTION:
115: 		return InitializeState((const BoundConjunctionExpression &)expr, state);
116: 	case ExpressionClass::BOUND_CONSTANT:
117: 		return InitializeState((const BoundConstantExpression &)expr, state);
118: 	case ExpressionClass::BOUND_FUNCTION:
119: 		return InitializeState((const BoundFunctionExpression &)expr, state);
120: 	case ExpressionClass::BOUND_OPERATOR:
121: 		return InitializeState((const BoundOperatorExpression &)expr, state);
122: 	case ExpressionClass::BOUND_PARAMETER:
123: 		return InitializeState((const BoundParameterExpression &)expr, state);
124: 	default:
125: 		throw InternalException("Attempting to initialize state of expression of unknown type!");
126: 	}
127: }
128: 
129: void ExpressionExecutor::Execute(const Expression &expr, ExpressionState *state, const SelectionVector *sel,
130:                                  idx_t count, Vector &result) {
131: #ifdef DEBUG
132: 	if (result.GetVectorType() == VectorType::FLAT_VECTOR) {
133: 		D_ASSERT(FlatVector::Validity(result).CheckAllValid(count));
134: 	}
135: #endif
136: 
137: 	if (count == 0) {
138: 		return;
139: 	}
140: 	switch (expr.expression_class) {
141: 	case ExpressionClass::BOUND_BETWEEN:
142: 		Execute((const BoundBetweenExpression &)expr, state, sel, count, result);
143: 		break;
144: 	case ExpressionClass::BOUND_REF:
145: 		Execute((const BoundReferenceExpression &)expr, state, sel, count, result);
146: 		break;
147: 	case ExpressionClass::BOUND_CASE:
148: 		Execute((const BoundCaseExpression &)expr, state, sel, count, result);
149: 		break;
150: 	case ExpressionClass::BOUND_CAST:
151: 		Execute((const BoundCastExpression &)expr, state, sel, count, result);
152: 		break;
153: 	case ExpressionClass::BOUND_COMPARISON:
154: 		Execute((const BoundComparisonExpression &)expr, state, sel, count, result);
155: 		break;
156: 	case ExpressionClass::BOUND_CONJUNCTION:
157: 		Execute((const BoundConjunctionExpression &)expr, state, sel, count, result);
158: 		break;
159: 	case ExpressionClass::BOUND_CONSTANT:
160: 		Execute((const BoundConstantExpression &)expr, state, sel, count, result);
161: 		break;
162: 	case ExpressionClass::BOUND_FUNCTION:
163: 		Execute((const BoundFunctionExpression &)expr, state, sel, count, result);
164: 		break;
165: 	case ExpressionClass::BOUND_OPERATOR:
166: 		Execute((const BoundOperatorExpression &)expr, state, sel, count, result);
167: 		break;
168: 	case ExpressionClass::BOUND_PARAMETER:
169: 		Execute((const BoundParameterExpression &)expr, state, sel, count, result);
170: 		break;
171: 	default:
172: 		throw InternalException("Attempting to execute expression of unknown type!");
173: 	}
174: 	Verify(expr, result, count);
175: }
176: 
177: idx_t ExpressionExecutor::Select(const Expression &expr, ExpressionState *state, const SelectionVector *sel,
178:                                  idx_t count, SelectionVector *true_sel, SelectionVector *false_sel) {
179: 	if (count == 0) {
180: 		return 0;
181: 	}
182: 	D_ASSERT(true_sel || false_sel);
183: 	D_ASSERT(expr.return_type.id() == LogicalTypeId::BOOLEAN);
184: 	switch (expr.expression_class) {
185: 	case ExpressionClass::BOUND_BETWEEN:
186: 		return Select((BoundBetweenExpression &)expr, state, sel, count, true_sel, false_sel);
187: 	case ExpressionClass::BOUND_COMPARISON:
188: 		return Select((BoundComparisonExpression &)expr, state, sel, count, true_sel, false_sel);
189: 	case ExpressionClass::BOUND_CONJUNCTION:
190: 		return Select((BoundConjunctionExpression &)expr, state, sel, count, true_sel, false_sel);
191: 	default:
192: 		return DefaultSelect(expr, state, sel, count, true_sel, false_sel);
193: 	}
194: }
195: 
196: template <bool NO_NULL, bool HAS_TRUE_SEL, bool HAS_FALSE_SEL>
197: static inline idx_t DefaultSelectLoop(const SelectionVector *bsel, uint8_t *__restrict bdata, ValidityMask &mask,
198:                                       const SelectionVector *sel, idx_t count, SelectionVector *true_sel,
199:                                       SelectionVector *false_sel) {
200: 	idx_t true_count = 0, false_count = 0;
201: 	for (idx_t i = 0; i < count; i++) {
202: 		auto bidx = bsel->get_index(i);
203: 		auto result_idx = sel->get_index(i);
204: 		if (bdata[bidx] > 0 && (NO_NULL || mask.RowIsValid(bidx))) {
205: 			if (HAS_TRUE_SEL) {
206: 				true_sel->set_index(true_count++, result_idx);
207: 			}
208: 		} else {
209: 			if (HAS_FALSE_SEL) {
210: 				false_sel->set_index(false_count++, result_idx);
211: 			}
212: 		}
213: 	}
214: 	if (HAS_TRUE_SEL) {
215: 		return true_count;
216: 	} else {
217: 		return count - false_count;
218: 	}
219: }
220: 
221: template <bool NO_NULL>
222: static inline idx_t DefaultSelectSwitch(VectorData &idata, const SelectionVector *sel, idx_t count,
223:                                         SelectionVector *true_sel, SelectionVector *false_sel) {
224: 	if (true_sel && false_sel) {
225: 		return DefaultSelectLoop<NO_NULL, true, true>(idata.sel, (uint8_t *)idata.data, idata.validity, sel, count,
226: 		                                              true_sel, false_sel);
227: 	} else if (true_sel) {
228: 		return DefaultSelectLoop<NO_NULL, true, false>(idata.sel, (uint8_t *)idata.data, idata.validity, sel, count,
229: 		                                               true_sel, false_sel);
230: 	} else {
231: 		D_ASSERT(false_sel);
232: 		return DefaultSelectLoop<NO_NULL, false, true>(idata.sel, (uint8_t *)idata.data, idata.validity, sel, count,
233: 		                                               true_sel, false_sel);
234: 	}
235: }
236: 
237: idx_t ExpressionExecutor::DefaultSelect(const Expression &expr, ExpressionState *state, const SelectionVector *sel,
238:                                         idx_t count, SelectionVector *true_sel, SelectionVector *false_sel) {
239: 	// generic selection of boolean expression:
240: 	// resolve the true/false expression first
241: 	// then use that to generate the selection vector
242: 	bool intermediate_bools[STANDARD_VECTOR_SIZE];
243: 	Vector intermediate(LogicalType::BOOLEAN, (data_ptr_t)intermediate_bools);
244: 	Execute(expr, state, sel, count, intermediate);
245: 
246: 	VectorData idata;
247: 	intermediate.Orrify(count, idata);
248: 	if (!sel) {
249: 		sel = &FlatVector::INCREMENTAL_SELECTION_VECTOR;
250: 	}
251: 	if (!idata.validity.AllValid()) {
252: 		return DefaultSelectSwitch<false>(idata, sel, count, true_sel, false_sel);
253: 	} else {
254: 		return DefaultSelectSwitch<true>(idata, sel, count, true_sel, false_sel);
255: 	}
256: }
257: 
258: vector<unique_ptr<ExpressionExecutorState>> &ExpressionExecutor::GetStates() {
259: 	return states;
260: }
261: 
262: } // namespace duckdb
[end of src/execution/expression_executor.cpp]
[start of src/execution/expression_executor/execute_case.cpp]
1: #include "duckdb/common/vector_operations/vector_operations.hpp"
2: #include "duckdb/execution/expression_executor.hpp"
3: #include "duckdb/planner/expression/bound_case_expression.hpp"
4: #include "duckdb/common/types/chunk_collection.hpp"
5: 
6: namespace duckdb {
7: 
8: void Case(Vector &res_true, Vector &res_false, Vector &result, SelectionVector &tside, idx_t tcount,
9:           SelectionVector &fside, idx_t fcount);
10: 
11: struct CaseExpressionState : public ExpressionState {
12: 	CaseExpressionState(const Expression &expr, ExpressionExecutorState &root)
13: 	    : ExpressionState(expr, root), true_sel(STANDARD_VECTOR_SIZE), false_sel(STANDARD_VECTOR_SIZE) {
14: 	}
15: 
16: 	SelectionVector true_sel;
17: 	SelectionVector false_sel;
18: };
19: 
20: unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const BoundCaseExpression &expr,
21:                                                                 ExpressionExecutorState &root) {
22: 	auto result = make_unique<CaseExpressionState>(expr, root);
23: 	result->AddChild(expr.check.get());
24: 	result->AddChild(expr.result_if_true.get());
25: 	result->AddChild(expr.result_if_false.get());
26: 	result->Finalize();
27: 	return move(result);
28: }
29: 
30: void ExpressionExecutor::Execute(const BoundCaseExpression &expr, ExpressionState *state_p, const SelectionVector *sel,
31:                                  idx_t count, Vector &result) {
32: 	auto state = (CaseExpressionState *)state_p;
33: 
34: 	state->intermediate_chunk.Reset();
35: 	auto &res_true = state->intermediate_chunk.data[1];
36: 	auto &res_false = state->intermediate_chunk.data[2];
37: 
38: 	auto check_state = state->child_states[0].get();
39: 	auto res_true_state = state->child_states[1].get();
40: 	auto res_false_state = state->child_states[2].get();
41: 
42: 	// first execute the check expression
43: 	auto &true_sel = state->true_sel;
44: 	auto &false_sel = state->false_sel;
45: 	idx_t tcount = Select(*expr.check, check_state, sel, count, &true_sel, &false_sel);
46: 	idx_t fcount = count - tcount;
47: 	if (fcount == 0) {
48: 		// everything is true, only execute TRUE side
49: 		Execute(*expr.result_if_true, res_true_state, sel, count, result);
50: 	} else if (tcount == 0) {
51: 		// everything is false, only execute FALSE side
52: 		Execute(*expr.result_if_false, res_false_state, sel, count, result);
53: 	} else {
54: 		// have to execute both and mix and match
55: 		Execute(*expr.result_if_true, res_true_state, &true_sel, tcount, res_true);
56: 		Execute(*expr.result_if_false, res_false_state, &false_sel, fcount, res_false);
57: 
58: 		Case(res_true, res_false, result, true_sel, tcount, false_sel, fcount);
59: 		if (sel) {
60: 			result.Slice(*sel, count);
61: 		}
62: 	}
63: }
64: 
65: template <class T>
66: void TemplatedFillLoop(Vector &vector, Vector &result, SelectionVector &sel, sel_t count) {
67: 	result.SetVectorType(VectorType::FLAT_VECTOR);
68: 	auto res = FlatVector::GetData<T>(result);
69: 	auto &result_mask = FlatVector::Validity(result);
70: 	if (vector.GetVectorType() == VectorType::CONSTANT_VECTOR) {
71: 		auto data = ConstantVector::GetData<T>(vector);
72: 		if (ConstantVector::IsNull(vector)) {
73: 			for (idx_t i = 0; i < count; i++) {
74: 				result_mask.SetInvalid(sel.get_index(i));
75: 			}
76: 		} else {
77: 			for (idx_t i = 0; i < count; i++) {
78: 				res[sel.get_index(i)] = *data;
79: 			}
80: 		}
81: 	} else {
82: 		VectorData vdata;
83: 		vector.Orrify(count, vdata);
84: 		auto data = (T *)vdata.data;
85: 		for (idx_t i = 0; i < count; i++) {
86: 			auto source_idx = vdata.sel->get_index(i);
87: 			auto res_idx = sel.get_index(i);
88: 
89: 			res[res_idx] = data[source_idx];
90: 			result_mask.Set(res_idx, vdata.validity.RowIsValid(source_idx));
91: 		}
92: 	}
93: }
94: 
95: void ValidityFillLoop(Vector &vector, Vector &result, SelectionVector &sel, sel_t count) {
96: 	result.SetVectorType(VectorType::FLAT_VECTOR);
97: 	auto &result_mask = FlatVector::Validity(result);
98: 	if (vector.GetVectorType() == VectorType::CONSTANT_VECTOR) {
99: 		if (ConstantVector::IsNull(vector)) {
100: 			for (idx_t i = 0; i < count; i++) {
101: 				result_mask.SetInvalid(sel.get_index(i));
102: 			}
103: 		}
104: 	} else {
105: 		VectorData vdata;
106: 		vector.Orrify(count, vdata);
107: 		for (idx_t i = 0; i < count; i++) {
108: 			auto source_idx = vdata.sel->get_index(i);
109: 			auto res_idx = sel.get_index(i);
110: 
111: 			result_mask.Set(res_idx, vdata.validity.RowIsValid(source_idx));
112: 		}
113: 	}
114: }
115: 
116: template <class T>
117: void TemplatedCaseLoop(Vector &res_true, Vector &res_false, Vector &result, SelectionVector &tside, idx_t tcount,
118:                        SelectionVector &fside, idx_t fcount) {
119: 	TemplatedFillLoop<T>(res_true, result, tside, tcount);
120: 	TemplatedFillLoop<T>(res_false, result, fside, fcount);
121: }
122: 
123: void ValidityCaseLoop(Vector &res_true, Vector &res_false, Vector &result, SelectionVector &tside, idx_t tcount,
124:                       SelectionVector &fside, idx_t fcount) {
125: 	ValidityFillLoop(res_true, result, tside, tcount);
126: 	ValidityFillLoop(res_false, result, fside, fcount);
127: }
128: 
129: void Case(Vector &res_true, Vector &res_false, Vector &result, SelectionVector &tside, idx_t tcount,
130:           SelectionVector &fside, idx_t fcount) {
131: 	D_ASSERT(res_true.GetType() == res_false.GetType() && res_true.GetType() == result.GetType());
132: 
133: 	switch (result.GetType().InternalType()) {
134: 	case PhysicalType::BOOL:
135: 	case PhysicalType::INT8:
136: 		TemplatedCaseLoop<int8_t>(res_true, res_false, result, tside, tcount, fside, fcount);
137: 		break;
138: 	case PhysicalType::INT16:
139: 		TemplatedCaseLoop<int16_t>(res_true, res_false, result, tside, tcount, fside, fcount);
140: 		break;
141: 	case PhysicalType::INT32:
142: 		TemplatedCaseLoop<int32_t>(res_true, res_false, result, tside, tcount, fside, fcount);
143: 		break;
144: 	case PhysicalType::INT64:
145: 		TemplatedCaseLoop<int64_t>(res_true, res_false, result, tside, tcount, fside, fcount);
146: 		break;
147: 	case PhysicalType::UINT8:
148: 		TemplatedCaseLoop<uint8_t>(res_true, res_false, result, tside, tcount, fside, fcount);
149: 		break;
150: 	case PhysicalType::UINT16:
151: 		TemplatedCaseLoop<uint16_t>(res_true, res_false, result, tside, tcount, fside, fcount);
152: 		break;
153: 	case PhysicalType::UINT32:
154: 		TemplatedCaseLoop<uint32_t>(res_true, res_false, result, tside, tcount, fside, fcount);
155: 		break;
156: 	case PhysicalType::UINT64:
157: 		TemplatedCaseLoop<uint64_t>(res_true, res_false, result, tside, tcount, fside, fcount);
158: 		break;
159: 	case PhysicalType::INT128:
160: 		TemplatedCaseLoop<hugeint_t>(res_true, res_false, result, tside, tcount, fside, fcount);
161: 		break;
162: 	case PhysicalType::FLOAT:
163: 		TemplatedCaseLoop<float>(res_true, res_false, result, tside, tcount, fside, fcount);
164: 		break;
165: 	case PhysicalType::DOUBLE:
166: 		TemplatedCaseLoop<double>(res_true, res_false, result, tside, tcount, fside, fcount);
167: 		break;
168: 	case PhysicalType::INTERVAL:
169: 		TemplatedCaseLoop<interval_t>(res_true, res_false, result, tside, tcount, fside, fcount);
170: 		break;
171: 	case PhysicalType::VARCHAR:
172: 		TemplatedCaseLoop<string_t>(res_true, res_false, result, tside, tcount, fside, fcount);
173: 		StringVector::AddHeapReference(result, res_true);
174: 		StringVector::AddHeapReference(result, res_false);
175: 		break;
176: 	case PhysicalType::STRUCT: {
177: 		auto &res_true_entries = StructVector::GetEntries(res_true);
178: 		auto &res_false_entries = StructVector::GetEntries(res_false);
179: 		auto &result_entries = StructVector::GetEntries(result);
180: 		D_ASSERT(res_true_entries.size() == res_false_entries.size() &&
181: 		         res_true_entries.size() == result_entries.size());
182: 		ValidityCaseLoop(res_true, res_false, result, tside, tcount, fside, fcount);
183: 		for (idx_t i = 0; i < res_true_entries.size(); i++) {
184: 			Case(*res_true_entries[i], *res_false_entries[i], *result_entries[i], tside, tcount, fside, fcount);
185: 		}
186: 		break;
187: 	}
188: 	case PhysicalType::LIST: {
189: 		idx_t offset = 0;
190: 
191: 		auto &true_child = ListVector::GetEntry(res_true);
192: 		offset += ListVector::GetListSize(res_true);
193: 		ListVector::Append(result, true_child, ListVector::GetListSize(res_true));
194: 
195: 		auto &false_child = ListVector::GetEntry(res_false);
196: 		ListVector::Append(result, false_child, ListVector::GetListSize(res_false));
197: 
198: 		// all the false offsets need to be incremented by true_child.count
199: 		TemplatedFillLoop<list_entry_t>(res_true, result, tside, tcount);
200: 
201: 		// FIXME the nullmask here is likely borked
202: 		// TODO uuugly
203: 		VectorData fdata;
204: 		res_false.Orrify(fcount, fdata);
205: 
206: 		auto data = (list_entry_t *)fdata.data;
207: 		auto res = FlatVector::GetData<list_entry_t>(result);
208: 		auto &mask = FlatVector::Validity(result);
209: 
210: 		for (idx_t i = 0; i < fcount; i++) {
211: 			auto fidx = fdata.sel->get_index(i);
212: 			auto res_idx = fside.get_index(i);
213: 			auto list_entry = data[fidx];
214: 			list_entry.offset += offset;
215: 			res[res_idx] = list_entry;
216: 			mask.Set(res_idx, fdata.validity.RowIsValid(fidx));
217: 		}
218: 
219: 		result.Verify(tside, tcount);
220: 		result.Verify(fside, fcount);
221: 		break;
222: 	}
223: 	default:
224: 		throw NotImplementedException("Unimplemented type for case expression: %s", result.GetType().ToString());
225: 	}
226: }
227: 
228: } // namespace duckdb
[end of src/execution/expression_executor/execute_case.cpp]
[start of src/execution/expression_executor/execute_operator.cpp]
1: #include "duckdb/common/vector_operations/vector_operations.hpp"
2: #include "duckdb/execution/expression_executor.hpp"
3: #include "duckdb/planner/expression/bound_operator_expression.hpp"
4: 
5: namespace duckdb {
6: 
7: unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const BoundOperatorExpression &expr,
8:                                                                 ExpressionExecutorState &root) {
9: 	auto result = make_unique<ExpressionState>(expr, root);
10: 	for (auto &child : expr.children) {
11: 		result->AddChild(child.get());
12: 	}
13: 	result->Finalize();
14: 	return result;
15: }
16: 
17: void ExpressionExecutor::Execute(const BoundOperatorExpression &expr, ExpressionState *state,
18:                                  const SelectionVector *sel, idx_t count, Vector &result) {
19: 	// special handling for special snowflake 'IN'
20: 	// IN has n children
21: 	if (expr.type == ExpressionType::COMPARE_IN || expr.type == ExpressionType::COMPARE_NOT_IN) {
22: 		if (expr.children.size() < 2) {
23: 			throw Exception("IN needs at least two children");
24: 		}
25: 
26: 		Vector left(expr.children[0]->return_type);
27: 		// eval left side
28: 		Execute(*expr.children[0], state->child_states[0].get(), sel, count, left);
29: 
30: 		// init result to false
31: 		Vector intermediate(LogicalType::BOOLEAN);
32: 		Value false_val = Value::BOOLEAN(false);
33: 		intermediate.Reference(false_val);
34: 
35: 		// in rhs is a list of constants
36: 		// for every child, OR the result of the comparision with the left
37: 		// to get the overall result.
38: 		for (idx_t child = 1; child < expr.children.size(); child++) {
39: 			Vector vector_to_check(expr.children[child]->return_type);
40: 			Vector comp_res(LogicalType::BOOLEAN);
41: 
42: 			Execute(*expr.children[child], state->child_states[child].get(), sel, count, vector_to_check);
43: 			VectorOperations::Equals(left, vector_to_check, comp_res, count);
44: 
45: 			if (child == 1) {
46: 				// first child: move to result
47: 				intermediate.Reference(comp_res);
48: 			} else {
49: 				// otherwise OR together
50: 				Vector new_result(LogicalType::BOOLEAN, true, false);
51: 				VectorOperations::Or(intermediate, comp_res, new_result, count);
52: 				intermediate.Reference(new_result);
53: 			}
54: 		}
55: 		if (expr.type == ExpressionType::COMPARE_NOT_IN) {
56: 			// NOT IN: invert result
57: 			VectorOperations::Not(intermediate, result, count);
58: 		} else {
59: 			// directly use the result
60: 			result.Reference(intermediate);
61: 		}
62: 	} else if (expr.children.size() == 1) {
63: 		state->intermediate_chunk.Reset();
64: 		auto &child = state->intermediate_chunk.data[0];
65: 
66: 		Execute(*expr.children[0], state->child_states[0].get(), sel, count, child);
67: 		switch (expr.type) {
68: 		case ExpressionType::OPERATOR_NOT: {
69: 			VectorOperations::Not(child, result, count);
70: 			break;
71: 		}
72: 		case ExpressionType::OPERATOR_IS_NULL: {
73: 			VectorOperations::IsNull(child, result, count);
74: 			break;
75: 		}
76: 		case ExpressionType::OPERATOR_IS_NOT_NULL: {
77: 			VectorOperations::IsNotNull(child, result, count);
78: 			break;
79: 		}
80: 		default:
81: 			throw NotImplementedException("Unsupported operator type with 1 child!");
82: 		}
83: 	} else {
84: 		throw NotImplementedException("operator");
85: 	}
86: }
87: 
88: } // namespace duckdb
[end of src/execution/expression_executor/execute_operator.cpp]
[start of src/function/scalar/string/chr.cpp]
1: #include "duckdb/function/scalar/string_functions.hpp"
2: #include "utf8proc.hpp"
3: #include "utf8proc_wrapper.hpp"
4: 
5: namespace duckdb {
6: 
7: struct ChrOperator {
8: 	template <class TA, class TR>
9: 	static inline TR Operation(const TA &input) {
10: 		char c[5] = {'\0', '\0', '\0', '\0', '\0'};
11: 		int utf8_bytes = 4;
12: 		Utf8Proc::CodepointToUtf8(input, utf8_bytes, &c[0]);
13: 		return string_t(&c[0]);
14: 	}
15: };
16: 
17: void CHR::RegisterFunction(BuiltinFunctions &set) {
18: 	ScalarFunction chr("chr", {LogicalType::INTEGER}, LogicalType::VARCHAR,
19: 	                   ScalarFunction::UnaryFunction<int32_t, string_t, ChrOperator>);
20: 	set.AddFunction(chr);
21: }
22: 
23: } // namespace duckdb
[end of src/function/scalar/string/chr.cpp]
[start of src/function/scalar/string/printf.cpp]
1: #include "duckdb/function/scalar/string_functions.hpp"
2: #include "duckdb/planner/expression/bound_function_expression.hpp"
3: #include "duckdb/common/limits.hpp"
4: #include "fmt/format.h"
5: #include "fmt/printf.h"
6: 
7: namespace duckdb {
8: 
9: struct FMTPrintf {
10: 	template <class CTX>
11: 	static string OP(const char *format_str, std::vector<duckdb_fmt::basic_format_arg<CTX>> &format_args) {
12: 		return duckdb_fmt::vsprintf(
13: 		    format_str, duckdb_fmt::basic_format_args<CTX>(format_args.data(), static_cast<int>(format_args.size())));
14: 	}
15: };
16: 
17: struct FMTFormat {
18: 	template <class CTX>
19: 	static string OP(const char *format_str, std::vector<duckdb_fmt::basic_format_arg<CTX>> &format_args) {
20: 		return duckdb_fmt::vformat(
21: 		    format_str, duckdb_fmt::basic_format_args<CTX>(format_args.data(), static_cast<int>(format_args.size())));
22: 	}
23: };
24: 
25: unique_ptr<FunctionData> BindPrintfFunction(ClientContext &context, ScalarFunction &bound_function,
26:                                             vector<unique_ptr<Expression>> &arguments) {
27: 	for (idx_t i = 1; i < arguments.size(); i++) {
28: 		switch (arguments[i]->return_type.id()) {
29: 		case LogicalTypeId::BOOLEAN:
30: 		case LogicalTypeId::TINYINT:
31: 		case LogicalTypeId::SMALLINT:
32: 		case LogicalTypeId::INTEGER:
33: 		case LogicalTypeId::BIGINT:
34: 		case LogicalTypeId::FLOAT:
35: 		case LogicalTypeId::DOUBLE:
36: 		case LogicalTypeId::VARCHAR:
37: 			// these types are natively supported
38: 			bound_function.arguments.push_back(arguments[i]->return_type);
39: 			break;
40: 		case LogicalTypeId::DECIMAL:
41: 			// decimal type: add cast to double
42: 			bound_function.arguments.push_back(LogicalType::DOUBLE);
43: 			break;
44: 		default:
45: 			// all other types: add cast to string
46: 			bound_function.arguments.push_back(LogicalType::VARCHAR);
47: 			break;
48: 		}
49: 	}
50: 	return nullptr;
51: }
52: 
53: template <class FORMAT_FUN, class CTX>
54: static void PrintfFunction(DataChunk &args, ExpressionState &state, Vector &result) {
55: 	auto &format_string = args.data[0];
56: 	result.SetVectorType(VectorType::CONSTANT_VECTOR);
57: 	for (idx_t i = 0; i < args.ColumnCount(); i++) {
58: 		switch (args.data[i].GetVectorType()) {
59: 		case VectorType::CONSTANT_VECTOR:
60: 			if (ConstantVector::IsNull(args.data[i])) {
61: 				// constant null! result is always NULL regardless of other input
62: 				result.SetVectorType(VectorType::CONSTANT_VECTOR);
63: 				ConstantVector::SetNull(result, true);
64: 				return;
65: 			}
66: 			break;
67: 		default:
68: 			// FLAT VECTOR, we can directly OR the nullmask
69: 			args.data[i].Normalify(args.size());
70: 			result.SetVectorType(VectorType::FLAT_VECTOR);
71: 			FlatVector::Validity(result).Combine(FlatVector::Validity(args.data[i]), args.size());
72: 			break;
73: 		}
74: 	}
75: 	idx_t count = result.GetVectorType() == VectorType::CONSTANT_VECTOR ? 1 : args.size();
76: 
77: 	auto format_data = FlatVector::GetData<string_t>(format_string);
78: 	auto result_data = FlatVector::GetData<string_t>(result);
79: 	for (idx_t idx = 0; idx < count; idx++) {
80: 		if (result.GetVectorType() == VectorType::FLAT_VECTOR && FlatVector::IsNull(result, idx)) {
81: 			// this entry is NULL: skip it
82: 			continue;
83: 		}
84: 
85: 		// first fetch the format string
86: 		auto fmt_idx = format_string.GetVectorType() == VectorType::CONSTANT_VECTOR ? 0 : idx;
87: 		auto format_string = format_data[fmt_idx].GetString();
88: 
89: 		// now gather all the format arguments
90: 		std::vector<duckdb_fmt::basic_format_arg<CTX>> format_args;
91: 		std::vector<unique_ptr<data_t[]>> string_args;
92: 
93: 		for (idx_t col_idx = 1; col_idx < args.ColumnCount(); col_idx++) {
94: 			auto &col = args.data[col_idx];
95: 			idx_t arg_idx = col.GetVectorType() == VectorType::CONSTANT_VECTOR ? 0 : idx;
96: 			switch (col.GetType().id()) {
97: 			case LogicalTypeId::BOOLEAN: {
98: 				auto arg_data = FlatVector::GetData<bool>(col);
99: 				format_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));
100: 				break;
101: 			}
102: 			case LogicalTypeId::TINYINT: {
103: 				auto arg_data = FlatVector::GetData<int8_t>(col);
104: 				format_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));
105: 				break;
106: 			}
107: 			case LogicalTypeId::SMALLINT: {
108: 				auto arg_data = FlatVector::GetData<int8_t>(col);
109: 				format_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));
110: 				break;
111: 			}
112: 			case LogicalTypeId::INTEGER: {
113: 				auto arg_data = FlatVector::GetData<int32_t>(col);
114: 				format_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));
115: 				break;
116: 			}
117: 			case LogicalTypeId::BIGINT: {
118: 				auto arg_data = FlatVector::GetData<int64_t>(col);
119: 				format_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));
120: 				break;
121: 			}
122: 			case LogicalTypeId::FLOAT: {
123: 				auto arg_data = FlatVector::GetData<float>(col);
124: 				format_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));
125: 				break;
126: 			}
127: 			case LogicalTypeId::DOUBLE: {
128: 				auto arg_data = FlatVector::GetData<double>(col);
129: 				format_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(arg_data[arg_idx]));
130: 				break;
131: 			}
132: 			case LogicalTypeId::VARCHAR: {
133: 				auto arg_data = FlatVector::GetData<string_t>(col);
134: 				auto string_view =
135: 				    duckdb_fmt::basic_string_view<char>(arg_data[arg_idx].GetDataUnsafe(), arg_data[arg_idx].GetSize());
136: 				format_args.emplace_back(duckdb_fmt::internal::make_arg<CTX>(string_view));
137: 				break;
138: 			}
139: 			default:
140: 				throw InternalException("Unexpected type for printf format");
141: 			}
142: 		}
143: 		// finally actually perform the format
144: 		string dynamic_result = FORMAT_FUN::template OP<CTX>(format_string.c_str(), format_args);
145: 		result_data[idx] = StringVector::AddString(result, dynamic_result);
146: 	}
147: }
148: 
149: void PrintfFun::RegisterFunction(BuiltinFunctions &set) {
150: 	// duckdb_fmt::printf_context, duckdb_fmt::vsprintf
151: 	ScalarFunction printf_fun =
152: 	    ScalarFunction("printf", {LogicalType::VARCHAR}, LogicalType::VARCHAR,
153: 	                   PrintfFunction<FMTPrintf, duckdb_fmt::printf_context>, false, BindPrintfFunction);
154: 	printf_fun.varargs = LogicalType::ANY;
155: 	set.AddFunction(printf_fun);
156: 
157: 	// duckdb_fmt::format_context, duckdb_fmt::vformat
158: 	ScalarFunction format_fun =
159: 	    ScalarFunction("format", {LogicalType::VARCHAR}, LogicalType::VARCHAR,
160: 	                   PrintfFunction<FMTFormat, duckdb_fmt::format_context>, false, BindPrintfFunction);
161: 	format_fun.varargs = LogicalType::ANY;
162: 	set.AddFunction(format_fun);
163: }
164: 
165: } // namespace duckdb
[end of src/function/scalar/string/printf.cpp]
[start of src/include/duckdb/common/types/selection_vector.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/types/selection_vector.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types.hpp"
13: #include "duckdb/common/vector_size.hpp"
14: 
15: namespace duckdb {
16: class VectorBuffer;
17: 
18: struct SelectionData {
19: 	explicit SelectionData(idx_t count) {
20: 		owned_data = unique_ptr<sel_t[]>(new sel_t[count]);
21: 	}
22: 	unique_ptr<sel_t[]> owned_data;
23: };
24: 
25: struct SelectionVector {
26: 	SelectionVector() : sel_vector(nullptr) {
27: 	}
28: 	explicit SelectionVector(sel_t *sel) {
29: 		Initialize(sel);
30: 	}
31: 	explicit SelectionVector(idx_t count) {
32: 		Initialize(count);
33: 	}
34: 	SelectionVector(idx_t start, idx_t count) {
35: 		Initialize(STANDARD_VECTOR_SIZE);
36: 		for (idx_t i = 0; i < count; i++) {
37: 			set_index(i, start + i);
38: 		}
39: 	}
40: 	SelectionVector(const SelectionVector &sel_vector) {
41: 		Initialize(sel_vector);
42: 	}
43: 	explicit SelectionVector(buffer_ptr<SelectionData> data) {
44: 		Initialize(move(data));
45: 	}
46: 
47: public:
48: 	void Initialize(sel_t *sel) {
49: 		selection_data.reset();
50: 		sel_vector = sel;
51: 	}
52: 	void Initialize(idx_t count = STANDARD_VECTOR_SIZE) {
53: 		selection_data = make_buffer<SelectionData>(count);
54: 		sel_vector = selection_data->owned_data.get();
55: 	}
56: 	void Initialize(buffer_ptr<SelectionData> data) {
57: 		selection_data = move(data);
58: 		sel_vector = selection_data->owned_data.get();
59: 	}
60: 	void Initialize(const SelectionVector &other) {
61: 		selection_data = other.selection_data;
62: 		sel_vector = other.sel_vector;
63: 	}
64: 
65: 	void set_index(idx_t idx, idx_t loc) {
66: 		sel_vector[idx] = loc;
67: 	}
68: 	void swap(idx_t i, idx_t j) {
69: 		sel_t tmp = sel_vector[i];
70: 		sel_vector[i] = sel_vector[j];
71: 		sel_vector[j] = tmp;
72: 	}
73: 	idx_t get_index(idx_t idx) const {
74: 		return sel_vector ? sel_vector[idx] : idx;
75: 	}
76: 	sel_t *data() {
77: 		return sel_vector;
78: 	}
79: 	buffer_ptr<SelectionData> sel_data() {
80: 		return selection_data;
81: 	}
82: 	buffer_ptr<SelectionData> Slice(const SelectionVector &sel, idx_t count) const;
83: 
84: 	string ToString(idx_t count = 0) const;
85: 	void Print(idx_t count = 0) const;
86: 
87: 	sel_t &operator[](idx_t index) {
88: 		return sel_vector[index];
89: 	}
90: 
91: private:
92: 	sel_t *sel_vector;
93: 	buffer_ptr<SelectionData> selection_data;
94: };
95: 
96: class OptionalSelection {
97: public:
98: 	explicit inline OptionalSelection(SelectionVector *sel_p) : sel(sel_p) {
99: 
100: 		if (sel) {
101: 			vec.Initialize(sel->data());
102: 			sel = &vec;
103: 		}
104: 	}
105: 
106: 	inline operator SelectionVector *() {
107: 		return sel;
108: 	}
109: 
110: 	inline void Append(idx_t &count, const idx_t idx) {
111: 		if (sel) {
112: 			sel->set_index(count, idx);
113: 		}
114: 		++count;
115: 	}
116: 
117: 	inline void Advance(idx_t completed) {
118: 		if (sel) {
119: 			sel->Initialize(sel->data() + completed);
120: 		}
121: 	}
122: 
123: private:
124: 	SelectionVector *sel;
125: 	SelectionVector vec;
126: };
127: 
128: } // namespace duckdb
[end of src/include/duckdb/common/types/selection_vector.hpp]
[start of src/include/duckdb/execution/expression_executor.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/expression_executor.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/execution/expression_executor_state.hpp"
13: #include "duckdb/planner/bound_tokens.hpp"
14: #include "duckdb/planner/expression.hpp"
15: 
16: namespace duckdb {
17: class ExecutionContext;
18: //! ExpressionExecutor is responsible for executing a set of expressions and storing the result in a data chunk
19: class ExpressionExecutor {
20: public:
21: 	ExpressionExecutor();
22: 	explicit ExpressionExecutor(const Expression *expression);
23: 	explicit ExpressionExecutor(const Expression &expression);
24: 	explicit ExpressionExecutor(const vector<unique_ptr<Expression>> &expressions);
25: 
26: 	//! Add an expression to the set of to-be-executed expressions of the executor
27: 	void AddExpression(const Expression &expr);
28: 
29: 	//! Execute the set of expressions with the given input chunk and store the result in the output chunk
30: 	void Execute(DataChunk *input, DataChunk &result);
31: 	void Execute(DataChunk &input, DataChunk &result) {
32: 		Execute(&input, result);
33: 	}
34: 	void Execute(DataChunk &result) {
35: 		Execute(nullptr, result);
36: 	}
37: 
38: 	//! Execute the ExpressionExecutor and put the result in the result vector; this should only be used for expression
39: 	//! executors with a single expression
40: 	void ExecuteExpression(DataChunk &input, Vector &result);
41: 	//! Execute the ExpressionExecutor and put the result in the result vector; this should only be used for expression
42: 	//! executors with a single expression
43: 	void ExecuteExpression(Vector &result);
44: 	//! Execute the ExpressionExecutor and generate a selection vector from all true values in the result; this should
45: 	//! only be used with a single boolean expression
46: 	idx_t SelectExpression(DataChunk &input, SelectionVector &sel);
47: 
48: 	//! Execute the expression with index `expr_idx` and store the result in the result vector
49: 	void ExecuteExpression(idx_t expr_idx, Vector &result);
50: 	//! Evaluate a scalar expression and fold it into a single value
51: 	static Value EvaluateScalar(const Expression &expr);
52: 
53: 	//! Initialize the state of a given expression
54: 	static unique_ptr<ExpressionState> InitializeState(const Expression &expr, ExpressionExecutorState &state);
55: 
56: 	void SetChunk(DataChunk *chunk) {
57: 		this->chunk = chunk;
58: 	}
59: 	void SetChunk(DataChunk &chunk) {
60: 		SetChunk(&chunk);
61: 	}
62: 
63: 	vector<unique_ptr<ExpressionExecutorState>> &GetStates();
64: 
65: 	//! The expressions of the executor
66: 	vector<const Expression *> expressions;
67: 	//! The data chunk of the current physical operator, used to resolve
68: 	//! column references and determines the output cardinality
69: 	DataChunk *chunk = nullptr;
70: 
71: protected:
72: 	void Initialize(const Expression &expr, ExpressionExecutorState &state);
73: 
74: 	static unique_ptr<ExpressionState> InitializeState(const BoundReferenceExpression &expr,
75: 	                                                   ExpressionExecutorState &state);
76: 	static unique_ptr<ExpressionState> InitializeState(const BoundBetweenExpression &expr,
77: 	                                                   ExpressionExecutorState &state);
78: 	static unique_ptr<ExpressionState> InitializeState(const BoundCaseExpression &expr, ExpressionExecutorState &state);
79: 	static unique_ptr<ExpressionState> InitializeState(const BoundCastExpression &expr, ExpressionExecutorState &state);
80: 	static unique_ptr<ExpressionState> InitializeState(const BoundComparisonExpression &expr,
81: 	                                                   ExpressionExecutorState &state);
82: 	static unique_ptr<ExpressionState> InitializeState(const BoundConjunctionExpression &expr,
83: 	                                                   ExpressionExecutorState &state);
84: 	static unique_ptr<ExpressionState> InitializeState(const BoundConstantExpression &expr,
85: 	                                                   ExpressionExecutorState &state);
86: 	static unique_ptr<ExpressionState> InitializeState(const BoundFunctionExpression &expr,
87: 	                                                   ExpressionExecutorState &state);
88: 	static unique_ptr<ExpressionState> InitializeState(const BoundOperatorExpression &expr,
89: 	                                                   ExpressionExecutorState &state);
90: 	static unique_ptr<ExpressionState> InitializeState(const BoundParameterExpression &expr,
91: 	                                                   ExpressionExecutorState &state);
92: 
93: 	void Execute(const Expression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
94: 	             Vector &result);
95: 
96: 	void Execute(const BoundBetweenExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
97: 	             Vector &result);
98: 	void Execute(const BoundCaseExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
99: 	             Vector &result);
100: 	void Execute(const BoundCastExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
101: 	             Vector &result);
102: 
103: 	void Execute(const BoundComparisonExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
104: 	             Vector &result);
105: 	void Execute(const BoundConjunctionExpression &expr, ExpressionState *state, const SelectionVector *sel,
106: 	             idx_t count, Vector &result);
107: 	void Execute(const BoundConstantExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
108: 	             Vector &result);
109: 	void Execute(const BoundFunctionExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
110: 	             Vector &result);
111: 	void Execute(const BoundOperatorExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
112: 	             Vector &result);
113: 	void Execute(const BoundParameterExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
114: 	             Vector &result);
115: 	void Execute(const BoundReferenceExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
116: 	             Vector &result);
117: 
118: 	//! Execute the (boolean-returning) expression and generate a selection vector with all entries that are "true" in
119: 	//! the result
120: 	idx_t Select(const Expression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
121: 	             SelectionVector *true_sel, SelectionVector *false_sel);
122: 	idx_t DefaultSelect(const Expression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
123: 	                    SelectionVector *true_sel, SelectionVector *false_sel);
124: 
125: 	idx_t Select(const BoundBetweenExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
126: 	             SelectionVector *true_sel, SelectionVector *false_sel);
127: 	idx_t Select(const BoundComparisonExpression &expr, ExpressionState *state, const SelectionVector *sel, idx_t count,
128: 	             SelectionVector *true_sel, SelectionVector *false_sel);
129: 	idx_t Select(const BoundConjunctionExpression &expr, ExpressionState *state, const SelectionVector *sel,
130: 	             idx_t count, SelectionVector *true_sel, SelectionVector *false_sel);
131: 
132: 	//! Verify that the output of a step in the ExpressionExecutor is correct
133: 	void Verify(const Expression &expr, Vector &result, idx_t count);
134: 
135: private:
136: 	//! The states of the expression executor; this holds any intermediates and temporary states of expressions
137: 	vector<unique_ptr<ExpressionExecutorState>> states;
138: };
139: } // namespace duckdb
[end of src/include/duckdb/execution/expression_executor.hpp]
[start of src/optimizer/in_clause_rewriter.cpp]
1: #include "duckdb/optimizer/in_clause_rewriter.hpp"
2: #include "duckdb/optimizer/optimizer.hpp"
3: #include "duckdb/planner/binder.hpp"
4: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
5: #include "duckdb/planner/expression/bound_conjunction_expression.hpp"
6: #include "duckdb/planner/expression/bound_operator_expression.hpp"
7: #include "duckdb/planner/operator/logical_chunk_get.hpp"
8: #include "duckdb/planner/operator/logical_comparison_join.hpp"
9: #include "duckdb/execution/expression_executor.hpp"
10: 
11: namespace duckdb {
12: 
13: unique_ptr<LogicalOperator> InClauseRewriter::Rewrite(unique_ptr<LogicalOperator> op) {
14: 	if (op->children.size() == 1) {
15: 		root = move(op->children[0]);
16: 		VisitOperatorExpressions(*op);
17: 		op->children[0] = move(root);
18: 	}
19: 
20: 	for (auto &child : op->children) {
21: 		child = Rewrite(move(child));
22: 	}
23: 	return op;
24: }
25: 
26: unique_ptr<Expression> InClauseRewriter::VisitReplace(BoundOperatorExpression &expr, unique_ptr<Expression> *expr_ptr) {
27: 	if (expr.type != ExpressionType::COMPARE_IN && expr.type != ExpressionType::COMPARE_NOT_IN) {
28: 		return nullptr;
29: 	}
30: 	D_ASSERT(root);
31: 	auto in_type = expr.children[0]->return_type;
32: 	bool is_regular_in = expr.type == ExpressionType::COMPARE_IN;
33: 	bool all_scalar = true;
34: 	// IN clause with many children: try to generate a mark join that replaces this IN expression
35: 	// we can only do this if the expressions in the expression list are scalar
36: 	for (idx_t i = 1; i < expr.children.size(); i++) {
37: 		D_ASSERT(expr.children[i]->return_type == in_type);
38: 		if (!expr.children[i]->IsFoldable()) {
39: 			// non-scalar expression
40: 			all_scalar = false;
41: 		}
42: 	}
43: 	if (expr.children.size() == 2) {
44: 		// only one child
45: 		// IN: turn into X = 1
46: 		// NOT IN: turn into X <> 1
47: 		return make_unique<BoundComparisonExpression>(is_regular_in ? ExpressionType::COMPARE_EQUAL
48: 		                                                            : ExpressionType::COMPARE_NOTEQUAL,
49: 		                                              move(expr.children[0]), move(expr.children[1]));
50: 	}
51: 	if (expr.children.size() < 6 || !all_scalar) {
52: 		// low amount of children or not all scalar
53: 		// IN: turn into (X = 1 OR X = 2 OR X = 3...)
54: 		// NOT IN: turn into (X <> 1 AND X <> 2 AND X <> 3 ...)
55: 		auto conjunction = make_unique<BoundConjunctionExpression>(is_regular_in ? ExpressionType::CONJUNCTION_OR
56: 		                                                                         : ExpressionType::CONJUNCTION_AND);
57: 		for (idx_t i = 1; i < expr.children.size(); i++) {
58: 			conjunction->children.push_back(make_unique<BoundComparisonExpression>(
59: 			    is_regular_in ? ExpressionType::COMPARE_EQUAL : ExpressionType::COMPARE_NOTEQUAL,
60: 			    expr.children[0]->Copy(), move(expr.children[i])));
61: 		}
62: 		return move(conjunction);
63: 	}
64: 	// IN clause with many constant children
65: 	// generate a mark join that replaces this IN expression
66: 	// first generate a ChunkCollection from the set of expressions
67: 	vector<LogicalType> types = {in_type};
68: 	auto collection = make_unique<ChunkCollection>();
69: 	DataChunk chunk;
70: 	chunk.Initialize(types);
71: 	for (idx_t i = 1; i < expr.children.size(); i++) {
72: 		// reoslve this expression to a constant
73: 		auto value = ExpressionExecutor::EvaluateScalar(*expr.children[i]);
74: 		idx_t index = chunk.size();
75: 		chunk.SetCardinality(chunk.size() + 1);
76: 		chunk.SetValue(0, index, value);
77: 		if (chunk.size() == STANDARD_VECTOR_SIZE || i + 1 == expr.children.size()) {
78: 			// chunk full: append to chunk collection
79: 			collection->Append(chunk);
80: 			chunk.Reset();
81: 		}
82: 	}
83: 	// now generate a ChunkGet that scans this collection
84: 	auto chunk_index = optimizer.binder.GenerateTableIndex();
85: 	auto chunk_scan = make_unique<LogicalChunkGet>(chunk_index, types, move(collection));
86: 
87: 	// then we generate the MARK join with the chunk scan on the RHS
88: 	auto join = make_unique<LogicalComparisonJoin>(JoinType::MARK);
89: 	join->mark_index = chunk_index;
90: 	join->AddChild(move(root));
91: 	join->AddChild(move(chunk_scan));
92: 	// create the JOIN condition
93: 	JoinCondition cond;
94: 	cond.left = move(expr.children[0]);
95: 
96: 	cond.right = make_unique<BoundColumnRefExpression>(in_type, ColumnBinding(chunk_index, 0));
97: 	cond.comparison = ExpressionType::COMPARE_EQUAL;
98: 	join->conditions.push_back(move(cond));
99: 	root = move(join);
100: 
101: 	// we replace the original subquery with a BoundColumnRefExpression referring to the mark column
102: 	unique_ptr<Expression> result =
103: 	    make_unique<BoundColumnRefExpression>("IN (...)", LogicalType::BOOLEAN, ColumnBinding(chunk_index, 0));
104: 	if (!is_regular_in) {
105: 		// NOT IN: invert
106: 		auto invert = make_unique<BoundOperatorExpression>(ExpressionType::OPERATOR_NOT, LogicalType::BOOLEAN);
107: 		invert->children.push_back(move(result));
108: 		result = move(invert);
109: 	}
110: 	return result;
111: }
112: 
113: } // namespace duckdb
[end of src/optimizer/in_clause_rewriter.cpp]
[start of src/optimizer/rule/comparison_simplification.cpp]
1: #include "duckdb/planner/expression/list.hpp"
2: #include "duckdb/optimizer/rule/comparison_simplification.hpp"
3: 
4: #include "duckdb/execution/expression_executor.hpp"
5: #include "duckdb/planner/expression/bound_constant_expression.hpp"
6: 
7: namespace duckdb {
8: 
9: ComparisonSimplificationRule::ComparisonSimplificationRule(ExpressionRewriter &rewriter) : Rule(rewriter) {
10: 	// match on a ComparisonExpression that has a ConstantExpression as a check
11: 	auto op = make_unique<ComparisonExpressionMatcher>();
12: 	op->matchers.push_back(make_unique<FoldableConstantMatcher>());
13: 	op->policy = SetMatcher::Policy::SOME;
14: 	root = move(op);
15: }
16: 
17: unique_ptr<Expression> ComparisonSimplificationRule::Apply(LogicalOperator &op, vector<Expression *> &bindings,
18:                                                            bool &changes_made) {
19: 	D_ASSERT(bindings[0]->expression_class == ExpressionClass::BOUND_COMPARISON);
20: 	auto expr = (BoundComparisonExpression *)bindings[0];
21: 	auto constant_expr = bindings[1];
22: 	bool column_ref_left = expr->left.get() != constant_expr;
23: 	auto column_ref_expr = !column_ref_left ? expr->right.get() : expr->left.get();
24: 	// the constant_expr is a scalar expression that we have to fold
25: 	// use an ExpressionExecutor to execute the expression
26: 	D_ASSERT(constant_expr->IsFoldable());
27: 	auto constant_value = ExpressionExecutor::EvaluateScalar(*constant_expr);
28: 	if (constant_value.is_null && !(expr->type == ExpressionType::COMPARE_NOT_DISTINCT_FROM ||
29: 	                                expr->type == ExpressionType::COMPARE_DISTINCT_FROM)) {
30: 		// comparison with constant NULL, return NULL
31: 		return make_unique<BoundConstantExpression>(Value(LogicalType::BOOLEAN));
32: 	}
33: 	if (column_ref_expr->expression_class == ExpressionClass::BOUND_CAST) {
34: 		//! Here we check if we can apply the expression on the constant side
35: 		auto cast_expression = (BoundCastExpression *)column_ref_expr;
36: 		auto target_type = cast_expression->source_type();
37: 		if (!BoundCastExpression::CastIsInvertible(target_type, cast_expression->return_type)) {
38: 			return nullptr;
39: 		}
40: 		auto new_constant = constant_value.TryCastAs(target_type);
41: 		if (new_constant) {
42: 			auto child_expression = move(cast_expression->child);
43: 			auto new_constant_expr = make_unique<BoundConstantExpression>(constant_value);
44: 			//! We can cast, now we change our column_ref_expression from an operator cast to a column reference
45: 			if (column_ref_left) {
46: 				expr->left = move(child_expression);
47: 				expr->right = move(new_constant_expr);
48: 			} else {
49: 				expr->left = move(new_constant_expr);
50: 				expr->right = move(child_expression);
51: 			}
52: 		}
53: 	}
54: 	return nullptr;
55: }
56: 
57: } // namespace duckdb
[end of src/optimizer/rule/comparison_simplification.cpp]
[start of src/optimizer/rule/conjunction_simplification.cpp]
1: #include "duckdb/optimizer/rule/conjunction_simplification.hpp"
2: 
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/planner/expression/bound_conjunction_expression.hpp"
5: #include "duckdb/planner/expression/bound_constant_expression.hpp"
6: 
7: namespace duckdb {
8: 
9: ConjunctionSimplificationRule::ConjunctionSimplificationRule(ExpressionRewriter &rewriter) : Rule(rewriter) {
10: 	// match on a ComparisonExpression that has a ConstantExpression as a check
11: 	auto op = make_unique<ConjunctionExpressionMatcher>();
12: 	op->matchers.push_back(make_unique<FoldableConstantMatcher>());
13: 	op->policy = SetMatcher::Policy::SOME;
14: 	root = move(op);
15: }
16: 
17: unique_ptr<Expression> ConjunctionSimplificationRule::RemoveExpression(BoundConjunctionExpression &conj,
18:                                                                        Expression *expr) {
19: 	for (idx_t i = 0; i < conj.children.size(); i++) {
20: 		if (conj.children[i].get() == expr) {
21: 			// erase the expression
22: 			conj.children.erase(conj.children.begin() + i);
23: 			break;
24: 		}
25: 	}
26: 	if (conj.children.size() == 1) {
27: 		// one expression remaining: simply return that expression and erase the conjunction
28: 		return move(conj.children[0]);
29: 	}
30: 	return nullptr;
31: }
32: 
33: unique_ptr<Expression> ConjunctionSimplificationRule::Apply(LogicalOperator &op, vector<Expression *> &bindings,
34:                                                             bool &changes_made) {
35: 	auto conjunction = (BoundConjunctionExpression *)bindings[0];
36: 	auto constant_expr = bindings[1];
37: 	// the constant_expr is a scalar expression that we have to fold
38: 	// use an ExpressionExecutor to execute the expression
39: 	D_ASSERT(constant_expr->IsFoldable());
40: 	auto constant_value = ExpressionExecutor::EvaluateScalar(*constant_expr).CastAs(LogicalType::BOOLEAN);
41: 	if (constant_value.is_null) {
42: 		// we can't simplify conjunctions with a constant NULL
43: 		return nullptr;
44: 	}
45: 	if (conjunction->type == ExpressionType::CONJUNCTION_AND) {
46: 		if (!constant_value.value_.boolean) {
47: 			// FALSE in AND, result of expression is false
48: 			return make_unique<BoundConstantExpression>(Value::BOOLEAN(false));
49: 		} else {
50: 			// TRUE in AND, remove the expression from the set
51: 			return RemoveExpression(*conjunction, constant_expr);
52: 		}
53: 	} else {
54: 		D_ASSERT(conjunction->type == ExpressionType::CONJUNCTION_OR);
55: 		if (!constant_value.value_.boolean) {
56: 			// FALSE in OR, remove the expression from the set
57: 			return RemoveExpression(*conjunction, constant_expr);
58: 		} else {
59: 			// TRUE in OR, result of expression is true
60: 			return make_unique<BoundConstantExpression>(Value::BOOLEAN(true));
61: 		}
62: 	}
63: }
64: 
65: } // namespace duckdb
[end of src/optimizer/rule/conjunction_simplification.cpp]
[start of src/optimizer/rule/constant_folding.cpp]
1: #include "duckdb/optimizer/rule/constant_folding.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/execution/expression_executor.hpp"
5: #include "duckdb/optimizer/expression_rewriter.hpp"
6: #include "duckdb/planner/expression/bound_constant_expression.hpp"
7: 
8: namespace duckdb {
9: 
10: //! The ConstantFoldingExpressionMatcher matches on any scalar expression (i.e. Expression::IsFoldable is true)
11: class ConstantFoldingExpressionMatcher : public FoldableConstantMatcher {
12: public:
13: 	bool Match(Expression *expr, vector<Expression *> &bindings) override {
14: 		// we also do not match on ConstantExpressions, because we cannot fold those any further
15: 		if (expr->type == ExpressionType::VALUE_CONSTANT) {
16: 			return false;
17: 		}
18: 		return FoldableConstantMatcher::Match(expr, bindings);
19: 	}
20: };
21: 
22: ConstantFoldingRule::ConstantFoldingRule(ExpressionRewriter &rewriter) : Rule(rewriter) {
23: 	auto op = make_unique<ConstantFoldingExpressionMatcher>();
24: 	root = move(op);
25: }
26: 
27: unique_ptr<Expression> ConstantFoldingRule::Apply(LogicalOperator &op, vector<Expression *> &bindings,
28:                                                   bool &changes_made) {
29: 	auto root = bindings[0];
30: 	// the root is a scalar expression that we have to fold
31: 	D_ASSERT(root->IsFoldable() && root->type != ExpressionType::VALUE_CONSTANT);
32: 
33: 	// use an ExpressionExecutor to execute the expression
34: 	auto result_value = ExpressionExecutor::EvaluateScalar(*root);
35: 	D_ASSERT(result_value.type().InternalType() == root->return_type.InternalType());
36: 	// now get the value from the result vector and insert it back into the plan as a constant expression
37: 	return make_unique<BoundConstantExpression>(result_value);
38: }
39: 
40: } // namespace duckdb
[end of src/optimizer/rule/constant_folding.cpp]
[start of src/optimizer/statistics/expression/propagate_operator.cpp]
1: #include "duckdb/optimizer/statistics_propagator.hpp"
2: #include "duckdb/planner/expression/bound_constant_expression.hpp"
3: #include "duckdb/planner/expression/bound_operator_expression.hpp"
4: 
5: namespace duckdb {
6: 
7: unique_ptr<BaseStatistics> StatisticsPropagator::PropagateExpression(BoundOperatorExpression &expr,
8:                                                                      unique_ptr<Expression> *expr_ptr) {
9: 	bool all_have_stats = true;
10: 	vector<unique_ptr<BaseStatistics>> child_stats;
11: 	child_stats.reserve(expr.children.size());
12: 	for (auto &child : expr.children) {
13: 		auto stats = PropagateExpression(child);
14: 		if (!stats) {
15: 			all_have_stats = false;
16: 		}
17: 		child_stats.push_back(move(stats));
18: 	}
19: 	if (!all_have_stats) {
20: 		return nullptr;
21: 	}
22: 	switch (expr.type) {
23: 	case ExpressionType::OPERATOR_IS_NULL:
24: 		if (!child_stats[0]->CanHaveNull()) {
25: 			// child has no null values: x IS NULL will always be false
26: 			*expr_ptr = make_unique<BoundConstantExpression>(Value::BOOLEAN(false));
27: 			return PropagateExpression(*expr_ptr);
28: 		}
29: 		return nullptr;
30: 	case ExpressionType::OPERATOR_IS_NOT_NULL:
31: 		if (!child_stats[0]->CanHaveNull()) {
32: 			// child has no null values: x IS NOT NULL will always be true
33: 			*expr_ptr = make_unique<BoundConstantExpression>(Value::BOOLEAN(true));
34: 			return PropagateExpression(*expr_ptr);
35: 		}
36: 		return nullptr;
37: 	default:
38: 		return nullptr;
39: 	}
40: }
41: 
42: } // namespace duckdb
[end of src/optimizer/statistics/expression/propagate_operator.cpp]
[start of src/planner/binder/expression/bind_operator_expression.cpp]
1: #include "duckdb/parser/expression/operator_expression.hpp"
2: #include "duckdb/planner/expression/bound_cast_expression.hpp"
3: #include "duckdb/planner/expression/bound_operator_expression.hpp"
4: #include "duckdb/planner/expression/bound_case_expression.hpp"
5: #include "duckdb/parser/expression/function_expression.hpp"
6: #include "duckdb/planner/expression_binder.hpp"
7: 
8: namespace duckdb {
9: 
10: static LogicalType ResolveNotType(OperatorExpression &op, vector<BoundExpression *> &children) {
11: 	// NOT expression, cast child to BOOLEAN
12: 	D_ASSERT(children.size() == 1);
13: 	children[0]->expr = BoundCastExpression::AddCastToType(move(children[0]->expr), LogicalType::BOOLEAN);
14: 	return LogicalType(LogicalTypeId::BOOLEAN);
15: }
16: 
17: static LogicalType ResolveInType(OperatorExpression &op, vector<BoundExpression *> &children) {
18: 	if (children.empty()) {
19: 		return LogicalType::BOOLEAN;
20: 	}
21: 	// get the maximum type from the children
22: 	LogicalType max_type = children[0]->expr->return_type;
23: 	for (idx_t i = 1; i < children.size(); i++) {
24: 		max_type = LogicalType::MaxLogicalType(max_type, children[i]->expr->return_type);
25: 	}
26: 	ExpressionBinder::ResolveParameterType(max_type);
27: 
28: 	// cast all children to the same type
29: 	for (idx_t i = 0; i < children.size(); i++) {
30: 		children[i]->expr = BoundCastExpression::AddCastToType(move(children[i]->expr), max_type);
31: 	}
32: 	// (NOT) IN always returns a boolean
33: 	return LogicalType::BOOLEAN;
34: }
35: 
36: static LogicalType ResolveOperatorType(OperatorExpression &op, vector<BoundExpression *> &children) {
37: 	switch (op.type) {
38: 	case ExpressionType::OPERATOR_IS_NULL:
39: 	case ExpressionType::OPERATOR_IS_NOT_NULL:
40: 		// IS (NOT) NULL always returns a boolean, and does not cast its children
41: 		ExpressionBinder::ResolveParameterType(children[0]->expr);
42: 		return LogicalType::BOOLEAN;
43: 	case ExpressionType::COMPARE_IN:
44: 	case ExpressionType::COMPARE_NOT_IN:
45: 	case ExpressionType::OPERATOR_COALESCE:
46: 		return ResolveInType(op, children);
47: 	case ExpressionType::OPERATOR_NOT:
48: 		return ResolveNotType(op, children);
49: 	default:
50: 		throw InternalException("Unrecognized expression type for ResolveOperatorType");
51: 	}
52: }
53: 
54: BindResult ExpressionBinder::BindGroupingFunction(OperatorExpression &op, idx_t depth) {
55: 	return BindResult("GROUPING function is not supported here");
56: }
57: 
58: BindResult ExpressionBinder::BindExpression(OperatorExpression &op, idx_t depth) {
59: 	if (op.type == ExpressionType::GROUPING_FUNCTION) {
60: 		return BindGroupingFunction(op, depth);
61: 	}
62: 	// bind the children of the operator expression
63: 	string error;
64: 	for (idx_t i = 0; i < op.children.size(); i++) {
65: 		BindChild(op.children[i], depth, error);
66: 	}
67: 	if (!error.empty()) {
68: 		return BindResult(error);
69: 	}
70: 	// all children bound successfully
71: 	string function_name;
72: 	switch (op.type) {
73: 	case ExpressionType::ARRAY_EXTRACT: {
74: 		D_ASSERT(op.children[0]->expression_class == ExpressionClass::BOUND_EXPRESSION);
75: 		auto &b_exp = (BoundExpression &)*op.children[0];
76: 		if (b_exp.expr->return_type.id() == LogicalTypeId::MAP) {
77: 			function_name = "map_extract";
78: 		} else {
79: 			function_name = "array_extract";
80: 		}
81: 		break;
82: 	}
83: 	case ExpressionType::ARRAY_SLICE:
84: 		function_name = "array_slice";
85: 		break;
86: 	case ExpressionType::STRUCT_EXTRACT:
87: 		function_name = "struct_extract";
88: 		break;
89: 	case ExpressionType::ARRAY_CONSTRUCTOR:
90: 		function_name = "list_value";
91: 		break;
92: 	default:
93: 		break;
94: 	}
95: 	if (!function_name.empty()) {
96: 		auto function = make_unique<FunctionExpression>(function_name, move(op.children));
97: 		return BindExpression(*function, depth, nullptr);
98: 	}
99: 
100: 	vector<BoundExpression *> children;
101: 	for (idx_t i = 0; i < op.children.size(); i++) {
102: 		D_ASSERT(op.children[i]->expression_class == ExpressionClass::BOUND_EXPRESSION);
103: 		children.push_back((BoundExpression *)op.children[i].get());
104: 	}
105: 	// now resolve the types
106: 	LogicalType result_type = ResolveOperatorType(op, children);
107: 	if (op.type == ExpressionType::OPERATOR_COALESCE) {
108: 		if (children.empty()) {
109: 			return BindResult("COALESCE needs at least one child");
110: 		}
111: 		unique_ptr<Expression> current_node;
112: 		for (size_t i = children.size(); i > 0; i--) {
113: 			auto child = move(children[i - 1]->expr);
114: 			if (!current_node) {
115: 				// no node yet: simply move the child
116: 				current_node = move(child);
117: 			} else {
118: 				// create a case statement
119: 				auto check =
120: 				    make_unique<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);
121: 				check->children.push_back(child->Copy());
122: 				current_node = make_unique<BoundCaseExpression>(move(check), move(child), move(current_node));
123: 			}
124: 		}
125: 		return BindResult(move(current_node));
126: 	}
127: 
128: 	auto result = make_unique<BoundOperatorExpression>(op.type, result_type);
129: 	for (auto &child : children) {
130: 		result->children.push_back(move(child->expr));
131: 	}
132: 	return BindResult(move(result));
133: }
134: 
135: } // namespace duckdb
[end of src/planner/binder/expression/bind_operator_expression.cpp]
[start of tools/odbc/odbc_fetch.cpp]
1: #include "odbc_fetch.hpp"
2: #include "duckdb_odbc.hpp"
3: #include "statement_functions.hpp"
4: #include "api_info.hpp"
5: 
6: #include <sql.h>
7: #include <sqltypes.h>
8: #include <sqlext.h>
9: 
10: using duckdb::OdbcFetch;
11: using duckdb::OdbcHandleStmt;
12: 
13: OdbcFetch::~OdbcFetch() {
14: 	chunks.clear();
15: }
16: 
17: void OdbcFetch::IncreaseRowCount() {
18: 	if ((chunk_row + rowset_size) < current_chunk->size()) {
19: 		row_count += rowset_size;
20: 	} else {
21: 		row_count += current_chunk->size() - chunk_row;
22: 	}
23: }
24: 
25: SQLRETURN OdbcFetch::Materialize(OdbcHandleStmt *stmt) {
26: 	// preserve states before materialization
27: 	auto before_cur_chunk = current_chunk;
28: 	auto before_cur_chunk_idx = current_chunk_idx;
29: 	auto before_chunk_row = chunk_row;
30: 	auto before_prior_chunk_row = prior_chunk_row;
31: 
32: 	SQLRETURN ret;
33: 	do {
34: 		ret = FetchNext(stmt);
35: 	} while (SQL_SUCCEEDED(ret));
36: 
37: 	D_ASSERT(resultset_end);
38: 
39: 	// restore states
40: 	if (before_cur_chunk) {
41: 		current_chunk = before_cur_chunk;
42: 		current_chunk_idx = before_cur_chunk_idx;
43: 		chunk_row = before_chunk_row;
44: 		prior_chunk_row = before_prior_chunk_row;
45: 	} else {
46: 		if (!chunks.empty()) {
47: 			current_chunk = chunks.front().get();
48: 		}
49: 		current_chunk_idx = 0;
50: 		chunk_row = prior_chunk_row = -1;
51: 	}
52: 
53: 	if (ret == SQL_NO_DATA || ret == SQL_SUCCESS) {
54: 		return SQL_SUCCESS;
55: 	}
56: 
57: 	return ret;
58: }
59: 
60: SQLRETURN OdbcFetch::FetchNext(OdbcHandleStmt *stmt) {
61: 	// case hasn't reached the end of query result, then try to fetch
62: 	if (!resultset_end) {
63: 		try {
64: 			// it's need to reset the last_fetched_len
65: 			ResetLastFetchedVariableVal();
66: 			auto chunk = stmt->res->Fetch();
67: 			if (!chunk) {
68: 				resultset_end = true;
69: 				return SQL_NO_DATA;
70: 			}
71: 			if (cursor_type == SQL_CURSOR_FORWARD_ONLY) {
72: 				if (!chunks.empty()) {
73: 					// holding only one chunk to avoid full materialization in memory
74: 					chunks.clear();
75: 				}
76: 				chunks.emplace_back(move(chunk));
77: 			} else {
78: 				chunks.emplace_back(move(chunk));
79: 			}
80: 		} catch (duckdb::Exception &e) {
81: 			// TODO this is quite dirty, we should have separate error holder
82: 			stmt->res->error = e.what();
83: 			stmt->res->success = false;
84: 			stmt->open = false;
85: 			stmt->error_messages.emplace_back(std::string(e.what()));
86: 			return SQL_ERROR;
87: 		}
88: 	}
89: 
90: 	return SetCurrentChunk(stmt);
91: }
92: 
93: SQLRETURN OdbcFetch::SetCurrentChunk(OdbcHandleStmt *stmt) {
94: 	if (chunks.empty()) {
95: 		return SQL_NO_DATA;
96: 	}
97: 	if (cursor_type != SQL_CURSOR_FORWARD_ONLY && current_chunk_idx < (chunks.size() - 1)) {
98: 		++current_chunk_idx;
99: 		current_chunk = chunks[current_chunk_idx].get();
100: 		chunk_row = prior_chunk_row = -1;
101: 		return SQL_SUCCESS;
102: 	}
103: 	// get always the last chunk and set as the current one
104: 	current_chunk = chunks.back().get();
105: 	current_chunk_idx = chunks.size() - 1;
106: 	chunk_row = prior_chunk_row = -1;
107: 
108: 	return SQL_SUCCESS;
109: }
110: 
111: SQLRETURN OdbcFetch::SetPriorCurrentChunk(OdbcHandleStmt *stmt) {
112: 	prior_chunk_row -= rowset_size;
113: 
114: 	// case the current chunk is the first one and fetch prior has reached the position "before start"
115: 	if (current_chunk_idx == 0 && prior_chunk_row < -1) {
116: 		chunk_row = -1;
117: 		return SQL_NO_DATA;
118: 	}
119: 
120: 	if (prior_chunk_row < -1) {
121: 		--current_chunk_idx;
122: 		current_chunk = chunks[current_chunk_idx].get();
123: 		prior_chunk_row = current_chunk->size() - rowset_size - 1;
124: 		if (prior_chunk_row < 0) {
125: 			prior_chunk_row = -1;
126: 		}
127: 	}
128: 
129: 	chunk_row = prior_chunk_row;
130: 
131: 	return SQL_SUCCESS;
132: }
133: 
134: SQLRETURN OdbcFetch::BeforeStart() {
135: 	if (!chunks.empty()) {
136: 		current_chunk = chunks.front().get();
137: 	}
138: 	current_chunk_idx = 0;
139: 	chunk_row = prior_chunk_row = -1;
140: 	// it should stop
141: 	// the cursor is just positioned at the begin of the result set without needed to fetch data
142: 	return RETURN_FETCH_BEFORE_START;
143: }
144: 
145: SQLRETURN OdbcFetch::SetAbsoluteCurrentChunk(OdbcHandleStmt *stmt, SQLLEN fetch_offset) {
146: 	// there is no current_chunk, it requires fetch next
147: 	if (!current_chunk || chunks.empty()) {
148: 		FetchNext(stmt);
149: 	}
150: 	// it has reachted the last row
151: 	if (fetch_offset > (SQLLEN)current_chunk->size() && resultset_end) {
152: 		return SQL_NO_DATA;
153: 	}
154: 
155: 	// FetchOffset < 0 AND | FetchOffset | <= LastResultRow
156: 	if ((fetch_offset < 0) && ((duckdb::idx_t)std::abs(fetch_offset) <= current_chunk->size())) {
157: 		// LastResultRow + FetchOffset + 1
158: 		chunk_row = chunk_row + fetch_offset + 1;
159: 		if (chunk_row < -1) {
160: 			chunk_row = -1;
161: 		}
162: 		prior_chunk_row = chunk_row;
163: 		return SQL_SUCCESS;
164: 	}
165: 
166: 	// FetchOffset < 0    AND | FetchOffset |    > LastResultRow AND |FetchOffset | > RowsetSize
167: 	if ((fetch_offset < 0) && (std::abs(fetch_offset) > chunk_row) && ((SQLULEN)std::abs(fetch_offset) > rowset_size)) {
168: 		// Before start, return to BOF
169: 		return BeforeStart();
170: 	}
171: 
172: 	// FetchOffset < 0    AND | FetchOffset |   > LastResultRow AND | FetchOffset | <= RowsetSize
173: 	if ((fetch_offset < 0) && (std::abs(fetch_offset) > chunk_row) &&
174: 	    ((SQLULEN)std::abs(fetch_offset) <= rowset_size)) {
175: 		chunk_row = prior_chunk_row = 0;
176: 		return SQL_SUCCESS;
177: 	}
178: 
179: 	// FetchOffset = 0, i.e.,return to BOF
180: 	if (fetch_offset == 0) {
181: 		return BeforeStart();
182: 	}
183: 
184: 	// 1 <= FetchOffset <= LastResultRow
185: 	if ((fetch_offset >= 0) && (fetch_offset < (SQLLEN)current_chunk->size())) {
186: 		chunk_row = fetch_offset - 1;
187: 		prior_chunk_row = chunk_row;
188: 		return SQL_SUCCESS;
189: 	}
190: 
191: 	// FetchOffset > LastResultRow
192: 	if (fetch_offset >= (SQLLEN)current_chunk->size()) {
193: 		auto ret = FetchNext(stmt);
194: 		if (ret != SQL_SUCCESS) {
195: 			current_chunk_idx = 0; // reset chunk idx
196: 			return ret;
197: 		}
198: 		fetch_offset -= current_chunk->size();
199: 		// recall set absolute based on the new chunk and relative offset
200: 		return SetAbsoluteCurrentChunk(stmt, fetch_offset);
201: 	}
202: 
203: 	return SQL_ERROR;
204: }
205: 
206: SQLRETURN OdbcFetch::SetFirstCurrentChunk(OdbcHandleStmt *stmt) {
207: 	BeforeStart();
208: 	if (!current_chunk) {
209: 		return FetchNext(stmt);
210: 	}
211: 	return SQL_SUCCESS;
212: }
213: 
214: SQLRETURN OdbcFetch::FetchNextChunk(SQLULEN fetch_orientation, OdbcHandleStmt *stmt, SQLLEN fetch_offset) {
215: 	if (cursor_type == SQL_CURSOR_FORWARD_ONLY && fetch_orientation != SQL_FETCH_NEXT) {
216: 		stmt->error_messages.emplace_back("Incorrect fetch orientation for cursor type: SQL_CURSOR_FORWARD_ONLY.");
217: 		return SQL_ERROR;
218: 	}
219: 
220: 	switch (fetch_orientation) {
221: 	case SQL_FETCH_NEXT:
222: 		prior_chunk_row = chunk_row;
223: 		if (RequireFetch()) {
224: 			// check if the fetch already reached the end of result set and the current chunk index is the last one
225: 			if (resultset_end && (current_chunk_idx == chunks.size() - 1)) {
226: 				return SQL_NO_DATA;
227: 			}
228: 			return FetchNext(stmt);
229: 		}
230: 		return SQL_SUCCESS;
231: 	case SQL_FETCH_PRIOR:
232: 		return SetPriorCurrentChunk(stmt);
233: 	case SQL_FETCH_ABSOLUTE:
234: 		return SetAbsoluteCurrentChunk(stmt, fetch_offset);
235: 	case SQL_FETCH_FIRST:
236: 		return SetFirstCurrentChunk(stmt);
237: 	default:
238: 		return SQL_SUCCESS;
239: 	}
240: }
241: 
242: SQLRETURN OdbcFetch::GetValue(SQLUSMALLINT col_idx, duckdb::Value &value) {
243: 	if (!current_chunk) {
244: 		// TODO could throw an exception instead
245: 		return SQL_ERROR;
246: 	}
247: 	value = current_chunk->GetValue(col_idx, chunk_row);
248: 	return SQL_SUCCESS;
249: }
250: 
251: SQLRETURN OdbcFetch::Fetch(SQLHSTMT statement_handle, OdbcHandleStmt *stmt, SQLULEN fetch_orientation,
252:                            SQLLEN fetch_offset) {
253: 	SQLRETURN ret = FetchNextChunk(fetch_orientation, stmt, fetch_offset);
254: 	if (ret != SQL_SUCCESS) {
255: 		if (ret == RETURN_FETCH_BEFORE_START) {
256: 			return SQL_SUCCESS;
257: 		}
258: 		return ret;
259: 	}
260: 
261: 	// case there is no bound column
262: 	if (stmt->bound_cols.empty()) {
263: 		// increment fetched row
264: 		chunk_row += rowset_size;
265: 		if (stmt->rows_fetched_ptr) {
266: 			(*stmt->rows_fetched_ptr) = 1;
267: 		}
268: 		IncreaseRowCount();
269: 		return SQL_SUCCESS;
270: 	}
271: 
272: 	if (bind_orientation == FetchBindingOrientation::COLUMN) {
273: 		if (!SQL_SUCCEEDED(OdbcFetch::ColumnWise(statement_handle, stmt))) {
274: 			stmt->error_messages.emplace_back("Column-wise fetching failed.");
275: 			return SQL_ERROR;
276: 		}
277: 	} else {
278: 		if (!SQL_SUCCEEDED(duckdb::OdbcFetch::RowWise(statement_handle, stmt))) {
279: 			stmt->error_messages.emplace_back("Row-wise fetching failed.");
280: 			return SQL_ERROR;
281: 		}
282: 	}
283: 	IncreaseRowCount();
284: 	return SQL_SUCCESS;
285: }
286: 
287: SQLRETURN OdbcFetch::ColumnWise(SQLHSTMT statement_handle, OdbcHandleStmt *stmt) {
288: 	SQLRETURN ret = SQL_SUCCESS;
289: 
290: 	SQLLEN first_row_to_fetch = chunk_row + 1;
291: 	SQLULEN last_row_to_fetch = first_row_to_fetch + this->rowset_size;
292: 
293: 	if (last_row_to_fetch > current_chunk->size()) {
294: 		last_row_to_fetch = current_chunk->size();
295: 	}
296: 
297: 	for (SQLULEN row_idx = first_row_to_fetch; row_idx < last_row_to_fetch; ++row_idx) {
298: 		++chunk_row;
299: 
300: 		if (this->row_status_buff) {
301: 			this->row_status_buff[row_idx] = SQL_SUCCESS;
302: 		}
303: 		// now fill buffers in fetch if set
304: 		// TODO actually vectorize this
305: 		for (duckdb::idx_t col_idx = 0; col_idx < stmt->stmt->ColumnCount(); col_idx++) {
306: 			auto bound_col = stmt->bound_cols[col_idx];
307: 
308: 			if (!bound_col.IsBound() && !bound_col.IsVarcharBound()) {
309: 				continue;
310: 			}
311: 			auto target_val_addr = bound_col.ptr;
312: 			auto target_len_addr = bound_col.strlen_or_ind;
313: 
314: 			if (this->rowset_size != SINGLE_VALUE_FETCH) {
315: 				// need specialized pointer arithmetic according with the value type
316: 				auto pointer_size = ApiInfo::PointerSizeOf(bound_col.type);
317: 				if (pointer_size < 0) {
318: 					pointer_size = bound_col.len;
319: 				}
320: 				target_val_addr = (uint8_t *)target_val_addr + (row_idx * pointer_size);
321: 				target_len_addr += row_idx;
322: 			}
323: 
324: 			if (!SQL_SUCCEEDED(duckdb::GetDataStmtResult(statement_handle, col_idx + 1, bound_col.type, target_val_addr,
325: 			                                             bound_col.len, target_len_addr))) {
326: 
327: 				if (this->row_status_buff) {
328: 					this->row_status_buff[row_idx] = SQL_ROW_ERROR;
329: 				}
330: 				stmt->error_messages.emplace_back("Error retriving #row: " + std::to_string(row_idx) +
331: 				                                  " and column: " + stmt->stmt->GetNames()[col_idx]);
332: 				ret = SQL_SUCCESS_WITH_INFO;
333: 			}
334: 		}
335: 	}
336: 
337: 	if (stmt->rows_fetched_ptr) {
338: 		*stmt->rows_fetched_ptr = last_row_to_fetch - first_row_to_fetch;
339: 	}
340: 
341: 	return ret;
342: }
343: 
344: SQLRETURN OdbcFetch::RowWise(SQLHSTMT statement_handle, OdbcHandleStmt *stmt) {
345: 	SQLRETURN ret = SQL_SUCCESS;
346: 	SQLULEN row_size = *(SQLULEN *)this->row_length;
347: 
348: 	SQLLEN first_row_to_fetch = chunk_row + 1;
349: 	SQLULEN last_row_to_fetch = first_row_to_fetch + this->rowset_size;
350: 
351: 	if (last_row_to_fetch > current_chunk->size()) {
352: 		last_row_to_fetch = current_chunk->size();
353: 	}
354: 
355: 	SQLULEN rows_fetched = 0;
356: 	for (SQLULEN row_idx = first_row_to_fetch; row_idx < last_row_to_fetch; ++row_idx, ++rows_fetched) {
357: 		++chunk_row;
358: 
359: 		if (this->row_status_buff) {
360: 			this->row_status_buff[row_idx] = SQL_SUCCESS;
361: 		}
362: 		auto row_offeset = row_size * row_idx;
363: 		for (duckdb::idx_t col_idx = 0; col_idx < stmt->stmt->ColumnCount(); col_idx++) {
364: 			auto bound_col = stmt->bound_cols[col_idx];
365: 			if (!bound_col.IsBound()) {
366: 				continue;
367: 			}
368: 
369: 			// the addresses must be byte addressable for row offset pointer arithmetic
370: 			uint8_t *target_val_addr = (uint8_t *)bound_col.ptr + row_offeset;
371: 			uint8_t *target_len_addr = (uint8_t *)bound_col.strlen_or_ind + row_offeset;
372: 
373: 			if (!SQL_SUCCEEDED(duckdb::GetDataStmtResult(statement_handle, col_idx + 1, bound_col.type, target_val_addr,
374: 			                                             bound_col.len, (SQLLEN *)target_len_addr))) {
375: 				if (this->row_status_buff) {
376: 					this->row_status_buff[row_idx] = SQL_ROW_ERROR;
377: 				}
378: 				stmt->error_messages.emplace_back("Error retriving #row: " + std::to_string(row_idx) +
379: 				                                  " and column: " + stmt->stmt->GetNames()[col_idx]);
380: 				ret = SQL_SUCCESS_WITH_INFO;
381: 			}
382: 		}
383: 	}
384: 
385: 	if (stmt->rows_fetched_ptr) {
386: 		*stmt->rows_fetched_ptr = rows_fetched;
387: 	}
388: 
389: 	return ret;
390: }
391: 
392: void OdbcFetch::ClearChunks() {
393: 	chunks.clear();
394: 	current_chunk = nullptr;
395: 	chunk_row = prior_chunk_row = -1;
396: 	row_count = 0;
397: 	resultset_end = false;
398: }
399: 
400: void OdbcFetch::ResetLastFetchedVariableVal() {
401: 	last_fetched_variable_val.col_idx = -1;
402: 	last_fetched_variable_val.row_idx = -1;
403: 	last_fetched_variable_val.length = 0;
404: }
405: 
406: void OdbcFetch::SetLastFetchedVariableVal(row_t col_idx) {
407: 	if (last_fetched_variable_val.col_idx != col_idx || last_fetched_variable_val.row_idx != chunk_row) {
408: 		last_fetched_variable_val.length = 0;
409: 	}
410: 	last_fetched_variable_val.col_idx = col_idx;
411: 	last_fetched_variable_val.row_idx = chunk_row;
412: }
413: 
414: void OdbcFetch::SetLastFetchedLength(size_t new_len) {
415: 	last_fetched_variable_val.length = new_len;
416: }
417: 
418: size_t OdbcFetch::GetLastFetchedLength() {
419: 	return last_fetched_variable_val.length;
420: }
[end of tools/odbc/odbc_fetch.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: