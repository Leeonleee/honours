{
  "repo": "duckdb/duckdb",
  "pull_number": 2462,
  "instance_id": "duckdb__duckdb-2462",
  "issue_numbers": [
    "2452",
    "2452"
  ],
  "base_commit": "a88d74d55bfa620ee62a35930de4cc27356f6f3b",
  "patch": "diff --git a/src/execution/expression_executor.cpp b/src/execution/expression_executor.cpp\nindex 1b863ebf63d2..4d3b3630c186 100644\n--- a/src/execution/expression_executor.cpp\n+++ b/src/execution/expression_executor.cpp\n@@ -90,6 +90,15 @@ Value ExpressionExecutor::EvaluateScalar(const Expression &expr) {\n \treturn result_value;\n }\n \n+bool ExpressionExecutor::TryEvaluateScalar(const Expression &expr, Value &result) {\n+\ttry {\n+\t\tresult = EvaluateScalar(expr);\n+\t\treturn true;\n+\t} catch (...) {\n+\t\treturn false;\n+\t}\n+}\n+\n void ExpressionExecutor::Verify(const Expression &expr, Vector &vector, idx_t count) {\n \tD_ASSERT(expr.return_type.id() == vector.GetType().id());\n \tvector.Verify(count);\ndiff --git a/src/execution/expression_executor/execute_case.cpp b/src/execution/expression_executor/execute_case.cpp\nindex ed22ddc86b92..9eff84a0419f 100644\n--- a/src/execution/expression_executor/execute_case.cpp\n+++ b/src/execution/expression_executor/execute_case.cpp\n@@ -5,9 +5,6 @@\n \n namespace duckdb {\n \n-void Case(Vector &res_true, Vector &res_false, Vector &result, SelectionVector &tside, idx_t tcount,\n-          SelectionVector &fside, idx_t fcount);\n-\n struct CaseExpressionState : public ExpressionState {\n \tCaseExpressionState(const Expression &expr, ExpressionExecutorState &root)\n \t    : ExpressionState(expr, root), true_sel(STANDARD_VECTOR_SIZE), false_sel(STANDARD_VECTOR_SIZE) {\n@@ -55,7 +52,8 @@ void ExpressionExecutor::Execute(const BoundCaseExpression &expr, ExpressionStat\n \t\tExecute(*expr.result_if_true, res_true_state, &true_sel, tcount, res_true);\n \t\tExecute(*expr.result_if_false, res_false_state, &false_sel, fcount, res_false);\n \n-\t\tCase(res_true, res_false, result, true_sel, tcount, false_sel, fcount);\n+\t\tFillSwitch(res_true, result, true_sel, tcount);\n+\t\tFillSwitch(res_false, result, false_sel, fcount);\n \t\tif (sel) {\n \t\t\tresult.Slice(*sel, count);\n \t\t}\n@@ -113,111 +111,77 @@ void ValidityFillLoop(Vector &vector, Vector &result, SelectionVector &sel, sel_\n \t}\n }\n \n-template <class T>\n-void TemplatedCaseLoop(Vector &res_true, Vector &res_false, Vector &result, SelectionVector &tside, idx_t tcount,\n-                       SelectionVector &fside, idx_t fcount) {\n-\tTemplatedFillLoop<T>(res_true, result, tside, tcount);\n-\tTemplatedFillLoop<T>(res_false, result, fside, fcount);\n-}\n-\n-void ValidityCaseLoop(Vector &res_true, Vector &res_false, Vector &result, SelectionVector &tside, idx_t tcount,\n-                      SelectionVector &fside, idx_t fcount) {\n-\tValidityFillLoop(res_true, result, tside, tcount);\n-\tValidityFillLoop(res_false, result, fside, fcount);\n-}\n-\n-void Case(Vector &res_true, Vector &res_false, Vector &result, SelectionVector &tside, idx_t tcount,\n-          SelectionVector &fside, idx_t fcount) {\n-\tD_ASSERT(res_true.GetType() == res_false.GetType() && res_true.GetType() == result.GetType());\n-\n+void ExpressionExecutor::FillSwitch(Vector &vector, Vector &result, SelectionVector &sel, sel_t count) {\n \tswitch (result.GetType().InternalType()) {\n \tcase PhysicalType::BOOL:\n \tcase PhysicalType::INT8:\n-\t\tTemplatedCaseLoop<int8_t>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<int8_t>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::INT16:\n-\t\tTemplatedCaseLoop<int16_t>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<int16_t>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::INT32:\n-\t\tTemplatedCaseLoop<int32_t>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<int32_t>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::INT64:\n-\t\tTemplatedCaseLoop<int64_t>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<int64_t>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::UINT8:\n-\t\tTemplatedCaseLoop<uint8_t>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<uint8_t>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::UINT16:\n-\t\tTemplatedCaseLoop<uint16_t>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<uint16_t>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::UINT32:\n-\t\tTemplatedCaseLoop<uint32_t>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<uint32_t>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::UINT64:\n-\t\tTemplatedCaseLoop<uint64_t>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<uint64_t>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::INT128:\n-\t\tTemplatedCaseLoop<hugeint_t>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<hugeint_t>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::FLOAT:\n-\t\tTemplatedCaseLoop<float>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<float>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::DOUBLE:\n-\t\tTemplatedCaseLoop<double>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<double>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::INTERVAL:\n-\t\tTemplatedCaseLoop<interval_t>(res_true, res_false, result, tside, tcount, fside, fcount);\n+\t\tTemplatedFillLoop<interval_t>(vector, result, sel, count);\n \t\tbreak;\n \tcase PhysicalType::VARCHAR:\n-\t\tTemplatedCaseLoop<string_t>(res_true, res_false, result, tside, tcount, fside, fcount);\n-\t\tStringVector::AddHeapReference(result, res_true);\n-\t\tStringVector::AddHeapReference(result, res_false);\n+\t\tTemplatedFillLoop<string_t>(vector, result, sel, count);\n+\t\tStringVector::AddHeapReference(result, vector);\n \t\tbreak;\n \tcase PhysicalType::STRUCT: {\n-\t\tauto &res_true_entries = StructVector::GetEntries(res_true);\n-\t\tauto &res_false_entries = StructVector::GetEntries(res_false);\n+\t\tauto &vector_entries = StructVector::GetEntries(vector);\n \t\tauto &result_entries = StructVector::GetEntries(result);\n-\t\tD_ASSERT(res_true_entries.size() == res_false_entries.size() &&\n-\t\t         res_true_entries.size() == result_entries.size());\n-\t\tValidityCaseLoop(res_true, res_false, result, tside, tcount, fside, fcount);\n-\t\tfor (idx_t i = 0; i < res_true_entries.size(); i++) {\n-\t\t\tCase(*res_true_entries[i], *res_false_entries[i], *result_entries[i], tside, tcount, fside, fcount);\n+\t\tValidityFillLoop(vector, result, sel, count);\n+\t\tD_ASSERT(vector_entries.size() == result_entries.size());\n+\t\tfor (idx_t i = 0; i < vector_entries.size(); i++) {\n+\t\t\tFillSwitch(*vector_entries[i], *result_entries[i], sel, count);\n \t\t}\n \t\tbreak;\n \t}\n \tcase PhysicalType::LIST: {\n-\t\tidx_t offset = 0;\n-\n-\t\tauto &true_child = ListVector::GetEntry(res_true);\n-\t\toffset += ListVector::GetListSize(res_true);\n-\t\tListVector::Append(result, true_child, ListVector::GetListSize(res_true));\n-\n-\t\tauto &false_child = ListVector::GetEntry(res_false);\n-\t\tListVector::Append(result, false_child, ListVector::GetListSize(res_false));\n+\t\tidx_t offset = ListVector::GetListSize(result);\n+\t\tauto &list_child = ListVector::GetEntry(vector);\n+\t\tListVector::Append(result, list_child, ListVector::GetListSize(vector));\n \n \t\t// all the false offsets need to be incremented by true_child.count\n-\t\tTemplatedFillLoop<list_entry_t>(res_true, result, tside, tcount);\n-\n-\t\t// FIXME the nullmask here is likely borked\n-\t\t// TODO uuugly\n-\t\tVectorData fdata;\n-\t\tres_false.Orrify(fcount, fdata);\n-\n-\t\tauto data = (list_entry_t *)fdata.data;\n-\t\tauto res = FlatVector::GetData<list_entry_t>(result);\n-\t\tauto &mask = FlatVector::Validity(result);\n-\n-\t\tfor (idx_t i = 0; i < fcount; i++) {\n-\t\t\tauto fidx = fdata.sel->get_index(i);\n-\t\t\tauto res_idx = fside.get_index(i);\n-\t\t\tauto list_entry = data[fidx];\n-\t\t\tlist_entry.offset += offset;\n-\t\t\tres[res_idx] = list_entry;\n-\t\t\tmask.Set(res_idx, fdata.validity.RowIsValid(fidx));\n+\t\tTemplatedFillLoop<list_entry_t>(vector, result, sel, count);\n+\t\tif (offset == 0) {\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tauto result_data = FlatVector::GetData<list_entry_t>(result);\n+\t\tfor (idx_t i = 0; i < count; i++) {\n+\t\t\tauto result_idx = sel.get_index(i);\n+\t\t\tresult_data[result_idx].offset += offset;\n \t\t}\n \n-\t\tresult.Verify(tside, tcount);\n-\t\tresult.Verify(fside, fcount);\n+\t\tresult.Verify(sel, count);\n \t\tbreak;\n \t}\n \tdefault:\ndiff --git a/src/execution/expression_executor/execute_operator.cpp b/src/execution/expression_executor/execute_operator.cpp\nindex 6764f335141c..d5d05ee6b835 100644\n--- a/src/execution/expression_executor/execute_operator.cpp\n+++ b/src/execution/expression_executor/execute_operator.cpp\n@@ -59,6 +59,57 @@ void ExpressionExecutor::Execute(const BoundOperatorExpression &expr, Expression\n \t\t\t// directly use the result\n \t\t\tresult.Reference(intermediate);\n \t\t}\n+\t} else if (expr.type == ExpressionType::OPERATOR_COALESCE) {\n+\t\tSelectionVector sel_a(count);\n+\t\tSelectionVector sel_b(count);\n+\t\tSelectionVector slice_sel(count);\n+\t\tSelectionVector result_sel(count);\n+\t\tSelectionVector *next_sel = &sel_a;\n+\t\tconst SelectionVector *current_sel = sel;\n+\t\tidx_t remaining_count = count;\n+\t\tidx_t next_count;\n+\t\tfor (idx_t child = 0; child < expr.children.size(); child++) {\n+\t\t\tVector vector_to_check(expr.children[child]->return_type);\n+\t\t\tExecute(*expr.children[child], state->child_states[child].get(), current_sel, remaining_count,\n+\t\t\t        vector_to_check);\n+\n+\t\t\tVectorData vdata;\n+\t\t\tvector_to_check.Orrify(remaining_count, vdata);\n+\n+\t\t\tidx_t result_count = 0;\n+\t\t\tnext_count = 0;\n+\t\t\tfor (idx_t i = 0; i < remaining_count; i++) {\n+\t\t\t\tauto base_idx = current_sel ? current_sel->get_index(i) : i;\n+\t\t\t\tauto idx = vdata.sel->get_index(i);\n+\t\t\t\tif (vdata.validity.RowIsValid(idx)) {\n+\t\t\t\t\tslice_sel.set_index(result_count, i);\n+\t\t\t\t\tresult_sel.set_index(result_count++, base_idx);\n+\t\t\t\t} else {\n+\t\t\t\t\tnext_sel->set_index(next_count++, base_idx);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (result_count > 0) {\n+\t\t\t\tvector_to_check.Slice(slice_sel, result_count);\n+\t\t\t\tFillSwitch(vector_to_check, result, result_sel, result_count);\n+\t\t\t}\n+\t\t\tcurrent_sel = next_sel;\n+\t\t\tnext_sel = next_sel == &sel_a ? &sel_b : &sel_a;\n+\t\t\tremaining_count = next_count;\n+\t\t\tif (next_count == 0) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tif (remaining_count > 0) {\n+\t\t\tauto &result_mask = FlatVector::Validity(result);\n+\t\t\tfor (idx_t i = 0; i < remaining_count; i++) {\n+\t\t\t\tresult_mask.SetInvalid(current_sel->get_index(i));\n+\t\t\t}\n+\t\t}\n+\t\tif (sel) {\n+\t\t\tresult.Slice(*sel, count);\n+\t\t} else if (count == 1) {\n+\t\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\t\t}\n \t} else if (expr.children.size() == 1) {\n \t\tstate->intermediate_chunk.Reset();\n \t\tauto &child = state->intermediate_chunk.data[0];\ndiff --git a/src/function/scalar/string/chr.cpp b/src/function/scalar/string/chr.cpp\nindex dc4254e572cf..80faaa3f78d6 100644\n--- a/src/function/scalar/string/chr.cpp\n+++ b/src/function/scalar/string/chr.cpp\n@@ -9,7 +9,9 @@ struct ChrOperator {\n \tstatic inline TR Operation(const TA &input) {\n \t\tchar c[5] = {'\\0', '\\0', '\\0', '\\0', '\\0'};\n \t\tint utf8_bytes = 4;\n-\t\tUtf8Proc::CodepointToUtf8(input, utf8_bytes, &c[0]);\n+\t\tif (input < 0 || !Utf8Proc::CodepointToUtf8(input, utf8_bytes, &c[0])) {\n+\t\t\tthrow InvalidInputException(\"Invalid UTF8 Codepoint %d\", input);\n+\t\t}\n \t\treturn string_t(&c[0]);\n \t}\n };\ndiff --git a/src/function/scalar/string/printf.cpp b/src/function/scalar/string/printf.cpp\nindex d34d96e64f06..0393cea30db3 100644\n--- a/src/function/scalar/string/printf.cpp\n+++ b/src/function/scalar/string/printf.cpp\n@@ -53,7 +53,9 @@ unique_ptr<FunctionData> BindPrintfFunction(ClientContext &context, ScalarFuncti\n template <class FORMAT_FUN, class CTX>\n static void PrintfFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tauto &format_string = args.data[0];\n+\tauto &result_validity = FlatVector::Validity(result);\n \tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\tresult_validity.Initialize(args.size());\n \tfor (idx_t i = 0; i < args.ColumnCount(); i++) {\n \t\tswitch (args.data[i].GetVectorType()) {\n \t\tcase VectorType::CONSTANT_VECTOR:\n@@ -68,7 +70,7 @@ static void PrintfFunction(DataChunk &args, ExpressionState &state, Vector &resu\n \t\t\t// FLAT VECTOR, we can directly OR the nullmask\n \t\t\targs.data[i].Normalify(args.size());\n \t\t\tresult.SetVectorType(VectorType::FLAT_VECTOR);\n-\t\t\tFlatVector::Validity(result).Combine(FlatVector::Validity(args.data[i]), args.size());\n+\t\t\tresult_validity.Combine(FlatVector::Validity(args.data[i]), args.size());\n \t\t\tbreak;\n \t\t}\n \t}\ndiff --git a/src/include/duckdb/common/types/selection_vector.hpp b/src/include/duckdb/common/types/selection_vector.hpp\nindex 82067d9e713f..122fd7c4ecb1 100644\n--- a/src/include/duckdb/common/types/selection_vector.hpp\n+++ b/src/include/duckdb/common/types/selection_vector.hpp\n@@ -76,6 +76,9 @@ struct SelectionVector {\n \tsel_t *data() {\n \t\treturn sel_vector;\n \t}\n+\tconst sel_t *data() const {\n+\t\treturn sel_vector;\n+\t}\n \tbuffer_ptr<SelectionData> sel_data() {\n \t\treturn selection_data;\n \t}\ndiff --git a/src/include/duckdb/execution/expression_executor.hpp b/src/include/duckdb/execution/expression_executor.hpp\nindex 189cebb6eff8..326f01c7a061 100644\n--- a/src/include/duckdb/execution/expression_executor.hpp\n+++ b/src/include/duckdb/execution/expression_executor.hpp\n@@ -49,6 +49,8 @@ class ExpressionExecutor {\n \tvoid ExecuteExpression(idx_t expr_idx, Vector &result);\n \t//! Evaluate a scalar expression and fold it into a single value\n \tstatic Value EvaluateScalar(const Expression &expr);\n+\t//! Try to evaluate a scalar expression and fold it into a single value, returns false if an exception is thrown\n+\tstatic bool TryEvaluateScalar(const Expression &expr, Value &result);\n \n \t//! Initialize the state of a given expression\n \tstatic unique_ptr<ExpressionState> InitializeState(const Expression &expr, ExpressionExecutorState &state);\n@@ -132,6 +134,8 @@ class ExpressionExecutor {\n \t//! Verify that the output of a step in the ExpressionExecutor is correct\n \tvoid Verify(const Expression &expr, Vector &result, idx_t count);\n \n+\tvoid FillSwitch(Vector &vector, Vector &result, SelectionVector &sel, sel_t count);\n+\n private:\n \t//! The states of the expression executor; this holds any intermediates and temporary states of expressions\n \tvector<unique_ptr<ExpressionExecutorState>> states;\ndiff --git a/src/optimizer/in_clause_rewriter.cpp b/src/optimizer/in_clause_rewriter.cpp\nindex afc09c651a7a..2887e2fb1136 100644\n--- a/src/optimizer/in_clause_rewriter.cpp\n+++ b/src/optimizer/in_clause_rewriter.cpp\n@@ -69,7 +69,7 @@ unique_ptr<Expression> InClauseRewriter::VisitReplace(BoundOperatorExpression &e\n \tDataChunk chunk;\n \tchunk.Initialize(types);\n \tfor (idx_t i = 1; i < expr.children.size(); i++) {\n-\t\t// reoslve this expression to a constant\n+\t\t// resolve this expression to a constant\n \t\tauto value = ExpressionExecutor::EvaluateScalar(*expr.children[i]);\n \t\tidx_t index = chunk.size();\n \t\tchunk.SetCardinality(chunk.size() + 1);\ndiff --git a/src/optimizer/rule/comparison_simplification.cpp b/src/optimizer/rule/comparison_simplification.cpp\nindex f88bc9f994cf..d0d8eb867e47 100644\n--- a/src/optimizer/rule/comparison_simplification.cpp\n+++ b/src/optimizer/rule/comparison_simplification.cpp\n@@ -24,7 +24,10 @@ unique_ptr<Expression> ComparisonSimplificationRule::Apply(LogicalOperator &op,\n \t// the constant_expr is a scalar expression that we have to fold\n \t// use an ExpressionExecutor to execute the expression\n \tD_ASSERT(constant_expr->IsFoldable());\n-\tauto constant_value = ExpressionExecutor::EvaluateScalar(*constant_expr);\n+\tValue constant_value;\n+\tif (!ExpressionExecutor::TryEvaluateScalar(*constant_expr, constant_value)) {\n+\t\treturn nullptr;\n+\t}\n \tif (constant_value.is_null && !(expr->type == ExpressionType::COMPARE_NOT_DISTINCT_FROM ||\n \t                                expr->type == ExpressionType::COMPARE_DISTINCT_FROM)) {\n \t\t// comparison with constant NULL, return NULL\ndiff --git a/src/optimizer/rule/conjunction_simplification.cpp b/src/optimizer/rule/conjunction_simplification.cpp\nindex 5bb7ad68ff9e..bd53d33f5701 100644\n--- a/src/optimizer/rule/conjunction_simplification.cpp\n+++ b/src/optimizer/rule/conjunction_simplification.cpp\n@@ -37,7 +37,11 @@ unique_ptr<Expression> ConjunctionSimplificationRule::Apply(LogicalOperator &op,\n \t// the constant_expr is a scalar expression that we have to fold\n \t// use an ExpressionExecutor to execute the expression\n \tD_ASSERT(constant_expr->IsFoldable());\n-\tauto constant_value = ExpressionExecutor::EvaluateScalar(*constant_expr).CastAs(LogicalType::BOOLEAN);\n+\tValue constant_value;\n+\tif (!ExpressionExecutor::TryEvaluateScalar(*constant_expr, constant_value)) {\n+\t\treturn nullptr;\n+\t}\n+\tconstant_value = constant_value.CastAs(LogicalType::BOOLEAN);\n \tif (constant_value.is_null) {\n \t\t// we can't simplify conjunctions with a constant NULL\n \t\treturn nullptr;\ndiff --git a/src/optimizer/rule/constant_folding.cpp b/src/optimizer/rule/constant_folding.cpp\nindex 14735c74a895..9fc67ab5423a 100644\n--- a/src/optimizer/rule/constant_folding.cpp\n+++ b/src/optimizer/rule/constant_folding.cpp\n@@ -31,7 +31,11 @@ unique_ptr<Expression> ConstantFoldingRule::Apply(LogicalOperator &op, vector<Ex\n \tD_ASSERT(root->IsFoldable() && root->type != ExpressionType::VALUE_CONSTANT);\n \n \t// use an ExpressionExecutor to execute the expression\n-\tauto result_value = ExpressionExecutor::EvaluateScalar(*root);\n+\n+\tValue result_value;\n+\tif (!ExpressionExecutor::TryEvaluateScalar(*root, result_value)) {\n+\t\treturn nullptr;\n+\t}\n \tD_ASSERT(result_value.type().InternalType() == root->return_type.InternalType());\n \t// now get the value from the result vector and insert it back into the plan as a constant expression\n \treturn make_unique<BoundConstantExpression>(result_value);\ndiff --git a/src/optimizer/statistics/expression/propagate_operator.cpp b/src/optimizer/statistics/expression/propagate_operator.cpp\nindex 4daafceaece9..6cfbbb95d967 100644\n--- a/src/optimizer/statistics/expression/propagate_operator.cpp\n+++ b/src/optimizer/statistics/expression/propagate_operator.cpp\n@@ -20,6 +20,42 @@ unique_ptr<BaseStatistics> StatisticsPropagator::PropagateExpression(BoundOperat\n \t\treturn nullptr;\n \t}\n \tswitch (expr.type) {\n+\tcase ExpressionType::OPERATOR_COALESCE:\n+\t\t// COALESCE, merge stats of all children\n+\t\tfor (idx_t i = 0; i < expr.children.size(); i++) {\n+\t\t\tD_ASSERT(child_stats[i]);\n+\t\t\tif (!child_stats[i]->CanHaveNoNull()) {\n+\t\t\t\t// this child is always NULL, we can remove it from the coalesce\n+\t\t\t\t// UNLESS there is only one node remaining\n+\t\t\t\tif (expr.children.size() > 1) {\n+\t\t\t\t\texpr.children.erase(expr.children.begin() + i);\n+\t\t\t\t\tchild_stats.erase(child_stats.begin() + i);\n+\t\t\t\t\ti--;\n+\t\t\t\t}\n+\t\t\t} else if (!child_stats[i]->CanHaveNull()) {\n+\t\t\t\t// coalesce child cannot have NULL entries\n+\t\t\t\t// this is the last coalesce node that influences the result\n+\t\t\t\t// we can erase any children after this node\n+\t\t\t\tif (i + 1 < expr.children.size()) {\n+\t\t\t\t\texpr.children.erase(expr.children.begin() + i + 1, expr.children.end());\n+\t\t\t\t\tchild_stats.erase(child_stats.begin() + i + 1, child_stats.end());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tD_ASSERT(!expr.children.empty());\n+\t\tD_ASSERT(expr.children.size() == child_stats.size());\n+\t\tif (expr.children.size() == 1) {\n+\t\t\t// coalesce of one entry: simply return that entry\n+\t\t\t*expr_ptr = move(expr.children[0]);\n+\t\t} else {\n+\t\t\t// coalesce of multiple entries\n+\t\t\t// merge the stats\n+\t\t\tfor (idx_t i = 1; i < expr.children.size(); i++) {\n+\t\t\t\tchild_stats[0]->Merge(*child_stats[i]);\n+\t\t\t}\n+\t\t}\n+\t\treturn move(child_stats[0]);\n \tcase ExpressionType::OPERATOR_IS_NULL:\n \t\tif (!child_stats[0]->CanHaveNull()) {\n \t\t\t// child has no null values: x IS NULL will always be false\ndiff --git a/src/planner/binder/expression/bind_operator_expression.cpp b/src/planner/binder/expression/bind_operator_expression.cpp\nindex 8ef453d8d7e1..13607f10b11d 100644\n--- a/src/planner/binder/expression/bind_operator_expression.cpp\n+++ b/src/planner/binder/expression/bind_operator_expression.cpp\n@@ -16,7 +16,7 @@ static LogicalType ResolveNotType(OperatorExpression &op, vector<BoundExpression\n \n static LogicalType ResolveInType(OperatorExpression &op, vector<BoundExpression *> &children) {\n \tif (children.empty()) {\n-\t\treturn LogicalType::BOOLEAN;\n+\t\tthrow InternalException(\"IN requires at least a single child node\");\n \t}\n \t// get the maximum type from the children\n \tLogicalType max_type = children[0]->expr->return_type;\n@@ -42,8 +42,11 @@ static LogicalType ResolveOperatorType(OperatorExpression &op, vector<BoundExpre\n \t\treturn LogicalType::BOOLEAN;\n \tcase ExpressionType::COMPARE_IN:\n \tcase ExpressionType::COMPARE_NOT_IN:\n-\tcase ExpressionType::OPERATOR_COALESCE:\n \t\treturn ResolveInType(op, children);\n+\tcase ExpressionType::OPERATOR_COALESCE: {\n+\t\tResolveInType(op, children);\n+\t\treturn children[0]->expr->return_type;\n+\t}\n \tcase ExpressionType::OPERATOR_NOT:\n \t\treturn ResolveNotType(op, children);\n \tdefault:\n@@ -106,23 +109,11 @@ BindResult ExpressionBinder::BindExpression(OperatorExpression &op, idx_t depth)\n \tLogicalType result_type = ResolveOperatorType(op, children);\n \tif (op.type == ExpressionType::OPERATOR_COALESCE) {\n \t\tif (children.empty()) {\n-\t\t\treturn BindResult(\"COALESCE needs at least one child\");\n+\t\t\tthrow BinderException(\"COALESCE needs at least one child\");\n \t\t}\n-\t\tunique_ptr<Expression> current_node;\n-\t\tfor (size_t i = children.size(); i > 0; i--) {\n-\t\t\tauto child = move(children[i - 1]->expr);\n-\t\t\tif (!current_node) {\n-\t\t\t\t// no node yet: simply move the child\n-\t\t\t\tcurrent_node = move(child);\n-\t\t\t} else {\n-\t\t\t\t// create a case statement\n-\t\t\t\tauto check =\n-\t\t\t\t    make_unique<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);\n-\t\t\t\tcheck->children.push_back(child->Copy());\n-\t\t\t\tcurrent_node = make_unique<BoundCaseExpression>(move(check), move(child), move(current_node));\n-\t\t\t}\n+\t\tif (children.size() == 1) {\n+\t\t\treturn BindResult(move(children[0]->expr));\n \t\t}\n-\t\treturn BindResult(move(current_node));\n \t}\n \n \tauto result = make_unique<BoundOperatorExpression>(op.type, result_type);\ndiff --git a/tools/odbc/odbc_fetch.cpp b/tools/odbc/odbc_fetch.cpp\nindex 2642c7b033ea..629ec9d67330 100644\n--- a/tools/odbc/odbc_fetch.cpp\n+++ b/tools/odbc/odbc_fetch.cpp\n@@ -64,6 +64,11 @@ SQLRETURN OdbcFetch::FetchNext(OdbcHandleStmt *stmt) {\n \t\t\t// it's need to reset the last_fetched_len\n \t\t\tResetLastFetchedVariableVal();\n \t\t\tauto chunk = stmt->res->Fetch();\n+\t\t\tif (!stmt->res->success) {\n+\t\t\t\tstmt->open = false;\n+\t\t\t\tstmt->error_messages.emplace_back(stmt->res->error);\n+\t\t\t\treturn SQL_ERROR;\n+\t\t\t}\n \t\t\tif (!chunk) {\n \t\t\t\tresultset_end = true;\n \t\t\t\treturn SQL_NO_DATA;\n",
  "test_patch": "diff --git a/test/api/test_api.cpp b/test/api/test_api.cpp\nindex bd4a1bf8338e..176efec2e78c 100644\n--- a/test/api/test_api.cpp\n+++ b/test/api/test_api.cpp\n@@ -224,8 +224,8 @@ TEST_CASE(\"Test streaming API errors\", \"[api]\") {\n \t// \"result2\" we can read\n \tREQUIRE(CHECK_COLUMN(result2, 0, {42}));\n \n-\t// error in query\n-\tresult = con.SendQuery(\"SELECT 'hello'::INT;\");\n+\t// error in binding\n+\tresult = con.SendQuery(\"SELECT * FROM nonexistanttable\");\n \tREQUIRE(!result->ToString().empty());\n \tREQUIRE(result->type == QueryResultType::MATERIALIZED_RESULT);\n \tREQUIRE_FAIL(result);\ndiff --git a/test/issues/rigger/rowid_conjunction.test b/test/issues/rigger/rowid_conjunction.test\nnew file mode 100644\nindex 000000000000..c911261dbafc\n--- /dev/null\n+++ b/test/issues/rigger/rowid_conjunction.test\n@@ -0,0 +1,33 @@\n+# name: test/issues/rigger/rowid_conjunction.test\n+# description: SQLancer bug that detected an error in using rowid in conjunctions\n+# group: [rigger]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t0(c0 TINYINT);\n+\n+statement ok\n+INSERT INTO t0 VALUES (1), (2), (3), (NULL);\n+\n+query I\n+SELECT * FROM t0 WHERE (((0.7839485854397868 BETWEEN false AND PRINTF(((0.8341154324178778)NOT SIMILAR TO(t0.c0)), NULL, ((0.9015841357551267) ::VARCHAR), DATE '1969-12-25')))AND(t0.rowid))\n+UNION\n+SELECT * FROM t0 WHERE (NOT (((0.7839485854397868 BETWEEN false AND PRINTF(((0.8341154324178778)NOT SIMILAR TO(t0.c0)), NULL, ((0.9015841357551267) ::VARCHAR), DATE '1969-12-25')))AND(t0.rowid)))\n+UNION\n+SELECT * FROM t0 WHERE (((((0.7839485854397868 BETWEEN false AND PRINTF(((0.8341154324178778)NOT SIMILAR TO(t0.c0)), NULL, ((0.9015841357551267) ::VARCHAR), DATE '1969-12-25')))AND(t0.rowid))) IS NULL)\n+ORDER BY 1\n+----\n+NULL\n+1\n+2\n+3\n+\n+query I\n+SELECT DISTINCT * FROM t0 ORDER BY 1\n+----\n+NULL\n+1\n+2\n+3\ndiff --git a/test/optimizer/statistics/statistics_coalesce.test b/test/optimizer/statistics/statistics_coalesce.test\nnew file mode 100644\nindex 000000000000..7bac149a96af\n--- /dev/null\n+++ b/test/optimizer/statistics/statistics_coalesce.test\n@@ -0,0 +1,106 @@\n+# name: test/optimizer/statistics/statistics_coalesce.test\n+# description: Test statistics propagation in COALESCE expression\n+# group: [statistics]\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+statement ok\n+PRAGMA explain_output = OPTIMIZED_ONLY;\n+\n+statement ok\n+CREATE TABLE integers AS SELECT * FROM (VALUES (1), (2), (3)) tbl(i);\n+\n+# \"i\" does not contain null values, so the coalesce expression is short-circuited\n+# \"17\" is never output\n+query II\n+EXPLAIN SELECT * FROM integers WHERE (COALESCE(i, 17)=17);\n+----\n+logical_opt\t<REGEX>:.*EMPTY_RESULT.*\n+\n+# adding NULLs randomly into the coalesce does not change anything\n+query II\n+EXPLAIN SELECT * FROM integers WHERE (COALESCE(NULL, NULL, NULL, i, NULL, 17)=17);\n+----\n+logical_opt\t<REGEX>:.*EMPTY_RESULT.*\n+\n+# same here, i is never output, the expression is a constant false\n+query II\n+EXPLAIN SELECT * FROM integers WHERE (COALESCE(4, i, 17)=3);\n+----\n+logical_opt\t<REGEX>:.*EMPTY_RESULT.*\n+\n+query II\n+EXPLAIN SELECT * FROM integers WHERE (COALESCE(i, 4, 17)=3);\n+----\n+logical_opt\t<!REGEX>:.*EMPTY_RESULT.*\n+\n+# execute the queries\n+query I\n+SELECT * FROM integers WHERE (COALESCE(i, 17)=17);\n+----\n+\n+query I\n+SELECT * FROM integers WHERE (COALESCE(NULL, NULL, NULL, i, NULL, 17)=17);\n+----\n+\n+query I\n+SELECT * FROM integers WHERE (COALESCE(4, i, 17)=3);\n+----\n+\n+query I\n+SELECT * FROM integers WHERE (COALESCE(i, 4, 17)=3);\n+----\n+3\n+\n+statement ok\n+INSERT INTO integers VALUES (NULL);\n+\n+# after inserting a NULL, the coalesce result changes\n+query II\n+EXPLAIN SELECT * FROM integers WHERE (COALESCE(i, 17)=17);\n+----\n+logical_opt\t<!REGEX>:.*EMPTY_RESULT.*\n+\n+query II\n+EXPLAIN SELECT * FROM integers WHERE (COALESCE(NULL, NULL, NULL, i, NULL, 17)=17);\n+----\n+logical_opt\t<!REGEX>:.*EMPTY_RESULT.*\n+\n+query II\n+EXPLAIN SELECT * FROM integers WHERE (COALESCE(4, i, 17)=3);\n+----\n+logical_opt\t<REGEX>:.*EMPTY_RESULT.*\n+\n+query II\n+EXPLAIN SELECT * FROM integers WHERE (COALESCE(i, 4, 17)=3);\n+----\n+logical_opt\t<!REGEX>:.*EMPTY_RESULT.*\n+\n+# execute the queries\n+query I\n+SELECT * FROM integers WHERE (COALESCE(i, 17)=17);\n+----\n+NULL\n+\n+query I\n+SELECT * FROM integers WHERE (COALESCE(NULL, NULL, NULL, i, NULL, 17)=17);\n+----\n+NULL\n+\n+query I\n+SELECT * FROM integers WHERE (COALESCE(4, i, 17)=3);\n+----\n+\n+query I\n+SELECT * FROM integers WHERE (COALESCE(i, 4, 17)=3);\n+----\n+3\n+\n+# random needs disabled verification\n+statement ok\n+PRAGMA disable_verification\n+\n+# coalesce without stats\n+statement ok\n+SELECT COALESCE(CASE WHEN RANDOM()<100 THEN RANDOM() ELSE NULL END, NULL, 42) FROM range(10)\ndiff --git a/test/optimizer/using_optimizer.test b/test/optimizer/using_optimizer.test\nindex 3b3ce5d93655..082fb3429b6a 100644\n--- a/test/optimizer/using_optimizer.test\n+++ b/test/optimizer/using_optimizer.test\n@@ -117,7 +117,7 @@ select i from a full outer join b using (i);\n 43\n \n query I\n-select case when(a.i is not null) then a.i else b.i end from a full outer join b on (a.i=b.i);\n+select coalesce(a.i, b.i) from a full outer join b on (a.i=b.i);\n ----\n 42\n 43\n@@ -127,5 +127,5 @@ explain select i from a full outer join b using (i);\n ----\n \n query II nosort fullouter\n-explain select case when(a.i is not null) then a.i else b.i end from a full outer join b on (a.i=b.i);\n+explain select coalesce(a.i, b.i) from a full outer join b on (a.i=b.i);\n ----\ndiff --git a/test/sql/function/generic/test_case.test b/test/sql/function/generic/test_case.test\nindex 1b8a895e4703..52a093f62f1a 100644\n--- a/test/sql/function/generic/test_case.test\n+++ b/test/sql/function/generic/test_case.test\n@@ -5,8 +5,13 @@\n statement ok\n PRAGMA enable_verification\n \n+foreach type <numeric> DECIMAL(4,0) DECIMAL(9,0) DECIMAL(18,0) DECIMAL(38,0)\n+\n+statement ok\n+DROP TABLE IF EXISTS test\n+\n statement ok\n-CREATE TABLE test (a INTEGER, b INTEGER);\n+CREATE TABLE test (a ${type}, b ${type});\n \n statement ok\n INSERT INTO test VALUES (11, 22), (13, 22), (12, 21)\n@@ -94,3 +99,4 @@ SELECT CASE WHEN 'false' THEN NULL ELSE b+1 END FROM test ORDER BY b\n 23\n 23\n \n+endloop\ndiff --git a/test/sql/function/string/test_ascii.test b/test/sql/function/string/test_ascii.test\nindex c08a02fc71df..802fba65f717 100644\n--- a/test/sql/function/string/test_ascii.test\n+++ b/test/sql/function/string/test_ascii.test\n@@ -73,5 +73,8 @@ NULL\n statement error\n SELECT CHR(-10)\n \n+statement error\n+SELECT CHR(1073741824)\n+\n statement error\n SELECT CHR()\n\\ No newline at end of file\ndiff --git a/test/sql/projection/coalesce_error.test b/test/sql/projection/coalesce_error.test\nnew file mode 100644\nindex 000000000000..07429fbf7803\n--- /dev/null\n+++ b/test/sql/projection/coalesce_error.test\n@@ -0,0 +1,32 @@\n+# name: test/sql/projection/coalesce_error.test\n+# description: Test COALESCE error short-circuiting\n+# group: [projection]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# constant coalesce short-circuiting\n+query I\n+SELECT COALESCE(1, 'hello'::INT)\n+----\n+1\n+\n+statement error\n+SELECT COALESCE(NULL, 'hello'::INT)\n+\n+# non-constant\n+statement ok\n+CREATE TABLE vals AS SELECT * FROM (\n+\tVALUES (1, 'hello'), (NULL, '2'), (3, NULL)\n+) tbl(a, b)\n+\n+query I\n+SELECT COALESCE(a, b::INT) FROM vals\n+----\n+1\n+2\n+3\n+\n+statement error\n+SELECT COALESCE(NULL, b::INT) FROM vals\n+\ndiff --git a/test/sql/projection/coalesce_rowid.test b/test/sql/projection/coalesce_rowid.test\nnew file mode 100644\nindex 000000000000..874c9b3e656c\n--- /dev/null\n+++ b/test/sql/projection/coalesce_rowid.test\n@@ -0,0 +1,37 @@\n+# name: test/sql/projection/coalesce_rowid.test\n+# description: SELECT * REPLACE\n+# group: [projection]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create table tbl as select case when i%2=0 then null else i end as i from range(10) tbl(i);\n+\n+query II\n+select i, coalesce(rowid+i, rowid) from tbl ORDER BY rowid;\n+----\n+NULL\t0\n+1\t2\n+NULL\t2\n+3\t6\n+NULL\t4\n+5\t10\n+NULL\t6\n+7\t14\n+NULL\t8\n+9\t18\n+\n+query IIII\n+select i, rowid, rowid+i, COALESCE(rowid+i, NULL) IS NULL OR rowid+3=6 from tbl ORDER BY rowid;\n+----\n+NULL\t0\tNULL\tTrue\n+1\t1\t2\tFalse\n+NULL\t2\tNULL\tTrue\n+3\t3\t6\tTrue\n+NULL\t4\tNULL\tTrue\n+5\t5\t10\tFalse\n+NULL\t6\tNULL\tTrue\n+7\t7\t14\tFalse\n+NULL\t8\tNULL\tTrue\n+9\t9\t18\tFalse\ndiff --git a/test/sql/projection/test_coalesce.test b/test/sql/projection/test_coalesce.test\nnew file mode 100644\nindex 000000000000..06e02a9fb799\n--- /dev/null\n+++ b/test/sql/projection/test_coalesce.test\n@@ -0,0 +1,304 @@\n+# name: test/sql/projection/test_coalesce.test\n+# description: Test COALESCE expression\n+# group: [projection]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+foreach type <numeric> DECIMAL(4,0) DECIMAL(9,0) DECIMAL(18,0) DECIMAL(38,0)\n+\n+statement ok\n+DROP TABLE IF EXISTS exprtest\n+\n+statement ok\n+CREATE TABLE exprtest (a ${type}, b ${type})\n+\n+statement ok\n+INSERT INTO exprtest VALUES (42, 10), (43, 100), (NULL, 1), (45, 0)\n+\n+# COALESCE\n+statement error\n+SELECT COALESCE()\n+\n+query I\n+SELECT COALESCE(NULL)\n+----\n+NULL\n+\n+query I\n+SELECT COALESCE(42::${type})\n+----\n+42\n+\n+query I\n+SELECT COALESCE(a) FROM exprtest\n+----\n+42\n+43\n+NULL\n+45\n+\n+query I\n+SELECT COALESCE(NULL, NULL, 42, 43)\n+----\n+42\n+\n+query I\n+SELECT COALESCE(NULL, NULL, 42)\n+----\n+42\n+\n+query I\n+SELECT COALESCE(42, NULL, 43)\n+----\n+42\n+\n+query I\n+SELECT COALESCE(NULL, NULL, NULL)\n+----\n+NULL\n+\n+query I\n+SELECT COALESCE(a, b) FROM exprtest\n+----\n+42\n+43\n+1\n+45\n+\n+query I\n+SELECT COALESCE(NULL, NULL, NULL, a, NULL, b) FROM exprtest\n+----\n+42\n+43\n+1\n+45\n+\n+# OR/AND\n+query II\n+SELECT * FROM exprtest WHERE b=1 OR COALESCE(a, b)=42 ORDER BY 1\n+----\n+NULL\t1\n+42\t10\n+\n+query II\n+SELECT * FROM exprtest WHERE COALESCE(a, b)=1 OR COALESCE(a, b)=43 OR COALESCE(a, b)=45 ORDER BY 1\n+----\n+NULL\t1\n+43\t100\n+45\t0\n+\n+query II\n+SELECT * FROM exprtest WHERE COALESCE(a, b)=1 OR COALESCE(a, b)=42 OR COALESCE(a, b)=43 OR COALESCE(a, b)=45 ORDER BY 1\n+----\n+NULL\t1\n+42\t10\n+43\t100\n+45\t0\n+\n+query II\n+SELECT * FROM exprtest WHERE b=1 AND COALESCE(a, b)=1 ORDER BY 1\n+----\n+NULL\t1\n+\n+query II\n+SELECT * FROM exprtest WHERE (b=1 AND COALESCE(a, b)=1) OR (b=100 AND COALESCE(a, b)=43) ORDER BY 1\n+----\n+NULL\t1\n+43\t100\n+\n+endloop\n+\n+# test COALESCE on strings\n+statement ok\n+CREATE TABLE strings(n VARCHAR, s VARCHAR);\n+\n+statement ok\n+INSERT INTO strings (s) VALUES ('thisisalongstring'), ('thisisalsoalongstring'), ('hello'), ('world'), ('duckduckduckduckduck'), (NULL)\n+\n+query I\n+SELECT COALESCE(n, s) FROM strings\n+----\n+thisisalongstring\n+thisisalsoalongstring\n+hello\n+world\n+duckduckduckduckduck\n+NULL\n+\n+query I\n+SELECT COALESCE(n, n, n, n, n, n, n, n, n, n, s, n, n, n, n, n, n, n) FROM strings\n+----\n+thisisalongstring\n+thisisalsoalongstring\n+hello\n+world\n+duckduckduckduckduck\n+NULL\n+\n+query I\n+SELECT COALESCE(n, n, n, n, n, n, n, n, n, n, s, n, n, n, n, n, n, n, 'default') FROM strings\n+----\n+thisisalongstring\n+thisisalsoalongstring\n+hello\n+world\n+duckduckduckduckduck\n+default\n+\n+query I\n+SELECT COALESCE(n, n, n, n, n, n, n, n, n, n, s, n, n, n, n, n, n, n) FROM strings WHERE s NOT LIKE 'this%'\n+----\n+hello\n+world\n+duckduckduckduckduck\n+\n+statement ok\n+CREATE TABLE multistrings AS SELECT * FROM\n+\t(\n+\t\tVALUES\n+\t\t\t(NULL, NULL, NULL, NULL, NULL, NULL),\n+\t\t\t('thisisalongstring', NULL, NULL, NULL, NULL, NULL),\n+\t\t\t(NULL, 'thisisalsoalongstring', NULL, NULL, NULL, NULL),\n+\t\t\t(NULL, NULL, 'hello', NULL, NULL, NULL),\n+\t\t\t(NULL, NULL, NULL, 'world', NULL, NULL),\n+\t\t\t(NULL, NULL, NULL, NULL, 'duckduckduckduckduck', NULL),\n+\t\t\t(NULL, NULL, NULL, NULL, NULL, NULL)\n+\t) tbl(s1, s2, s3, s4, s5);\n+\n+query I\n+SELECT COALESCE(s1, s2, s3, s4, s5) FROM multistrings;\n+----\n+NULL\n+thisisalongstring\n+thisisalsoalongstring\n+hello\n+world\n+duckduckduckduckduck\n+NULL\n+\n+query I\n+SELECT COALESCE(s5, s4, s3, s2, s1) FROM multistrings;\n+----\n+NULL\n+thisisalongstring\n+thisisalsoalongstring\n+hello\n+world\n+duckduckduckduckduck\n+NULL\n+\n+query I\n+SELECT COALESCE(s5, s4, s3, s2, s1) FROM multistrings WHERE COALESCE(s5, s4, s3, s2, s1) IS NOT NULL\n+----\n+thisisalongstring\n+thisisalsoalongstring\n+hello\n+world\n+duckduckduckduckduck\n+\n+# lists\n+statement ok\n+CREATE TABLE multilists AS SELECT * FROM\n+\t(\n+\t\tVALUES\n+\t\t\t(NULL, NULL, NULL, NULL, NULL, NULL),\n+\t\t\t([1, 2, 3], NULL, NULL, NULL, NULL, NULL),\n+\t\t\t(NULL, [4, 5, 6, 7, 8, 9], NULL, NULL, NULL, NULL),\n+\t\t\t(NULL, NULL, [], NULL, NULL, NULL),\n+\t\t\t(NULL, NULL, NULL, [10, 11, NULL, 13, 14, 15, 16], NULL, NULL),\n+\t\t\t(NULL, NULL, NULL, NULL, [NULL, 18, NULL, 20], NULL),\n+\t\t\t(NULL, NULL, NULL, NULL, NULL, NULL)\n+\t) tbl(s1, s2, s3, s4, s5);\n+\n+query I\n+SELECT COALESCE(s1, s2, s3, s4, s5) FROM multilists;\n+----\n+NULL\n+[1, 2, 3]\n+[4, 5, 6, 7, 8, 9]\n+[]\n+[10, 11, NULL, 13, 14, 15, 16]\n+[NULL, 18, NULL, 20]\n+NULL\n+\n+query I\n+SELECT COALESCE(s5, s4, s3, s2, s1) FROM multilists;\n+----\n+NULL\n+[1, 2, 3]\n+[4, 5, 6, 7, 8, 9]\n+[]\n+[10, 11, NULL, 13, 14, 15, 16]\n+[NULL, 18, NULL, 20]\n+NULL\n+\n+query I\n+SELECT COALESCE(s5, s4, s3, s2, s1) FROM multilists WHERE COALESCE(s5, s4, s3, s2, s1) IS NOT NULL\n+----\n+[1, 2, 3]\n+[4, 5, 6, 7, 8, 9]\n+[]\n+[10, 11, NULL, 13, 14, 15, 16]\n+[NULL, 18, NULL, 20]\n+\n+statement ok\n+CREATE TABLE nestedtypes AS SELECT * FROM\n+\t(\n+\t\tVALUES\n+\t\t\t(NULL, NULL, NULL, NULL, NULL, NULL),\n+\t\t\t([NULL, [NULL, NULL]], NULL, NULL, NULL, NULL, NULL),\n+\t\t\t(NULL, [[{'x': [3, 4]}], [{'x': [17]}, {'x': [22, NULL]}]], NULL, NULL, NULL, NULL),\n+\t\t\t(NULL, NULL, [[], [], []], NULL, NULL, NULL),\n+\t\t\t(NULL, NULL, NULL, [[{'x': NULL}], NULL, [NULL, NULL], []], NULL, NULL),\n+\t\t\t(NULL, NULL, NULL, NULL, [[{'x': [10, 12, 13, 14, 15]}], [{'x': [NULL]}, NULL]], NULL),\n+\t\t\t(NULL, NULL, NULL, NULL, NULL, NULL)\n+\t) tbl(s1, s2, s3, s4, s5);\n+\n+query I\n+SELECT COALESCE(s1, s2, s3, s4, s5) FROM nestedtypes;\n+----\n+NULL\n+[NULL, [NULL, NULL]]\n+[[{'x': [3, 4]}], [{'x': [17]}, {'x': [22, NULL]}]]\n+[[], [], []]\n+[[{'x': NULL}], NULL, [NULL, NULL], []]\n+[[{'x': [10, 12, 13, 14, 15]}], [{'x': [NULL]}, NULL]]\n+NULL\n+\n+query I\n+SELECT COALESCE(s5, s4, s3, s2, s1) FROM nestedtypes;\n+----\n+NULL\n+[NULL, [NULL, NULL]]\n+[[{'x': [3, 4]}], [{'x': [17]}, {'x': [22, NULL]}]]\n+[[], [], []]\n+[[{'x': NULL}], NULL, [NULL, NULL], []]\n+[[{'x': [10, 12, 13, 14, 15]}], [{'x': [NULL]}, NULL]]\n+NULL\n+\n+query I\n+SELECT COALESCE(s5, s4, s3, s2, s1) FROM nestedtypes WHERE COALESCE(s5, s4, s3, s2, s1) IS NOT NULL\n+----\n+[NULL, [NULL, NULL]]\n+[[{'x': [3, 4]}], [{'x': [17]}, {'x': [22, NULL]}]]\n+[[], [], []]\n+[[{'x': NULL}], NULL, [NULL, NULL], []]\n+[[{'x': [10, 12, 13, 14, 15]}], [{'x': [NULL]}, NULL]]\n+\n+query I\n+SELECT UNNEST(COALESCE(s5, s4, s3, s2, s1)) FROM nestedtypes\n+----\n+NULL\n+[NULL, NULL]\n+[{'x': [3, 4]}]\n+[{'x': [17]}, {'x': [22, NULL]}]\n+[]\n+[]\n+[]\n+[{'x': NULL}]\n+NULL\n+[NULL, NULL]\n+[]\n+[{'x': [10, 12, 13, 14, 15]}]\n+[{'x': [NULL]}, NULL]\ndiff --git a/test/sql/projection/test_complex_expressions.test b/test/sql/projection/test_complex_expressions.test\nindex 246cdfc5179c..2bd40678067d 100644\n--- a/test/sql/projection/test_complex_expressions.test\n+++ b/test/sql/projection/test_complex_expressions.test\n@@ -61,58 +61,6 @@ SELECT CASE WHEN a = 42 THEN 100 WHEN a = 43 THEN 200 END FROM exprtest\n NULL\n NULL\n \n-# COALESCE\n-statement error\n-SELECT COALESCE()\n-\n-\n-query I\n-SELECT COALESCE(NULL)\n-----\n-NULL\n-\n-query I\n-SELECT COALESCE(42)\n-----\n-42\n-\n-query I\n-SELECT COALESCE(a) FROM exprtest\n-----\n-42\n-43\n-NULL\n-45\n-\n-\n-query I\n-SELECT COALESCE(NULL, NULL, 42, 43)\n-----\n-42\n-\n-query I\n-SELECT COALESCE(NULL, NULL, 42)\n-----\n-42\n-\n-query I\n-SELECT COALESCE(42, NULL, 43)\n-----\n-42\n-\n-query I\n-SELECT COALESCE(NULL, NULL, NULL)\n-----\n-NULL\n-\n-query I\n-SELECT COALESCE(a, b) FROM exprtest\n-----\n-42\n-43\n-1\n-45\n-\n # ABS\n query III\n SELECT ABS(1), ABS(-1), ABS(NULL)\ndiff --git a/test/sql/subquery/scalar/coalesce_subquery.test b/test/sql/subquery/scalar/coalesce_subquery.test\nnew file mode 100644\nindex 000000000000..17c9efc308e5\n--- /dev/null\n+++ b/test/sql/subquery/scalar/coalesce_subquery.test\n@@ -0,0 +1,11 @@\n+# name: test/sql/subquery/scalar/coalesce_subquery.test\n+# description: Issue #2452: Coalesce operator with subquery throws error\n+# group: [scalar]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+SELECT 1 FROM (select 4) v1(vc0) WHERE (3) NOT IN (COALESCE((SELECT 1 WHERE FALSE), v1.vc0));\n+----\n+1\ndiff --git a/tools/odbc/test/isql-test.py b/tools/odbc/test/isql-test.py\nindex 35287b5c72f9..790812e0ad47 100644\n--- a/tools/odbc/test/isql-test.py\n+++ b/tools/odbc/test/isql-test.py\n@@ -124,9 +124,9 @@ def test(cmd, out=None, err=None, extra_commands=None, input_file=None):\n \n test(\"SELECT timestamp '    2017-07-23     13:10:11    ';\", out='2017-07-23 13:10:11')\n \n-test(\"SELECT timestamp '    2017-07-23     13:10:11    AA';\", err=\"[ISQL]ERROR\")\n-test(\"SELECT timestamp 'AA2017-07-23 13:10:11';\", err=\"[ISQL]ERROR\")\n-test(\"SELECT timestamp '2017-07-23A13:10:11';\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT timestamp '    2017-07-23     13:10:11    AA';\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT timestamp 'AA2017-07-23 13:10:11';\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT timestamp '2017-07-23A13:10:11';\", err=\"[ISQL]ERROR\")\n \n test('SELECT t FROM timestamp ORDER BY t;',\n out=(\n@@ -194,14 +194,14 @@ def test(cmd, out=None, err=None, extra_commands=None, input_file=None):\n \"20:08:10.001\"\n ))\n \n-test(\"SELECT ''::TIME\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '  '::TIME\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '        '::TIME\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '1'::TIME\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '11'::TIME\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '11:'::TIME\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '11:11'::TIME\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '11:11:f'::TIME\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT ''::TIME\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '  '::TIME\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '        '::TIME\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '1'::TIME\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '11'::TIME\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '11:'::TIME\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '11:11'::TIME\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '11:11:f'::TIME\", err=\"[ISQL]ERROR\")\n \n ### FROM test/sql/types/time/test_time.test #################################\n test(\"SELECT NULL\", out='')\n@@ -246,14 +246,14 @@ def test(cmd, out=None, err=None, extra_commands=None, input_file=None):\n test(\"SELECT '   7   '::DECIMAL::VARCHAR, '9.'::DECIMAL::VARCHAR, '.1'::DECIMAL::VARCHAR;\", out='7.000|9.000|0.100')\n test(\"SELECT '0.123456789'::DECIMAL::VARCHAR, '-0.123456789'::DECIMAL::VARCHAR;\", out='0.123|-0.123')\n \n-test(\"SELECT '9223372036854788.758'::DECIMAL;\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '9223372036854788.758'::DECIMAL;\", err=\"[ISQL]ERROR\")\n \n test(\"SELECT '0.1'::DECIMAL(3, 0)::VARCHAR;\", out='0')\n test(\"SELECT '123.4'::DECIMAL(9)::VARCHAR;\", out='123')\n test(\"SELECT '0.1'::DECIMAL(3, 3)::VARCHAR, '-0.1'::DECIMAL(3, 3)::VARCHAR;\", out='0.100|-0.100')\n \n-test(\"SELECT '1'::DECIMAL(3, 3)::VARCHAR;\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '-1'::DECIMAL(3, 3)::VARCHAR;\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '1'::DECIMAL(3, 3)::VARCHAR;\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '-1'::DECIMAL(3, 3)::VARCHAR;\", err=\"[ISQL]ERROR\")\n \n test(\"SELECT '0.1'::DECIMAL::DECIMAL::DECIMAL;\", out='0.1')\n \n@@ -266,12 +266,12 @@ def test(cmd, out=None, err=None, extra_commands=None, input_file=None):\n test(\"SELECT '0'::DECIMAL(38,10)::VARCHAR;\", out='0.0000000000')\n test(\"SELECT '0.00003'::DECIMAL(38,10)::VARCHAR;\", out='0.0000300000')\n \n-test(\"SELECT '0.1'::DECIMAL(3, 4);\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '0.1'::DECIMAL('hello');\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '0.1'::DECIMAL(-17);\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '0.1'::DECIMAL(1000);\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '0.1'::DECIMAL(1, 2, 3);\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '1'::INTEGER(1000);\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '0.1'::DECIMAL(3, 4);\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '0.1'::DECIMAL('hello');\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '0.1'::DECIMAL(-17);\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '0.1'::DECIMAL(1000);\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '0.1'::DECIMAL(1, 2, 3);\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '1'::INTEGER(1000);\", err=\"[ISQL]ERROR\")\n \n ### FROM test/sql/types/date/test_date.test #################################\n test(\n@@ -293,13 +293,13 @@ def test(cmd, out=None, err=None, extra_commands=None, input_file=None):\n \n test(\"SELECT (i + 5) - i FROM dates\", out='5')\n \n-test(\"SELECT ''::DATE\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '  '::DATE\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '1992'::DATE\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '1992-'::DATE\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '1992-01'::DATE\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '1992-01-'::DATE\", err=\"[ISQL]ERROR\")\n-test(\"SELECT '30000307-01-01 (BC)'::DATE\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT ''::DATE\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '  '::DATE\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '1992'::DATE\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '1992-'::DATE\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '1992-01'::DATE\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '1992-01-'::DATE\", err=\"[ISQL]ERROR\")\n+# test(\"SELECT '30000307-01-01 (BC)'::DATE\", err=\"[ISQL]ERROR\")\n \n ### FROM test/sql/types/blob/test_blob.test #################################\n test(\n",
  "problem_statement": "Coalesce operator with subquery throws error\n**What does happen?**\r\nA query with a coalesce call with a subquery as argument, throws the error: Serialization Error: Cannot copy BoundSubqueryExpression\r\n\r\n**What should happen?**\r\nOutput 1\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n1. SELECT 1 FROM (select 4) v1(vc0) WHERE (3) NOT IN (COALESCE((SELECT 1 WHERE FALSE), v1.vc0));\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Linux\r\n - DuckDB Version compiled from sources at changeset 8e2e97528\r\n\r\n**Before submitting**\r\n- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\nCoalesce operator with subquery throws error\n**What does happen?**\r\nA query with a coalesce call with a subquery as argument, throws the error: Serialization Error: Cannot copy BoundSubqueryExpression\r\n\r\n**What should happen?**\r\nOutput 1\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n1. SELECT 1 FROM (select 4) v1(vc0) WHERE (3) NOT IN (COALESCE((SELECT 1 WHERE FALSE), v1.vc0));\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Linux\r\n - DuckDB Version compiled from sources at changeset 8e2e97528\r\n\r\n**Before submitting**\r\n- [x] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [x] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\n",
  "hints_text": "\n",
  "created_at": "2021-10-20T17:24:13Z"
}