You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Two settings named 'http_proxy'
### What happens?

There are two settings named 'http_proxy' : 

|        name         |         value         |                                       description                                        |
|---------------------|-----------------------|------------------------------------------------------------------------------------------|
| http_proxy          | 127.0.0.1:8999 | HTTP proxy host                                                                          |
| http_proxy_username |                       | Username for HTTP proxy                                                                  |
| http_proxy          |                       | Password for HTTP proxy                                                                  |
| http_logging_output |                       | The file to which HTTP logging output should be saved, or empty to print to the terminal |


### To Reproduce

```
D select name, value, description from duckdb_settings() where name like 'http%';
|        name         | value |                                       description                                        |
|---------------------|-------|------------------------------------------------------------------------------------------|
| http_proxy          |       | HTTP proxy host                                                                          |
| http_proxy_username |       | Username for HTTP proxy                                                                  |
| http_proxy          |       | Password for HTTP proxy                                                                  |
| http_logging_output |       | The file to which HTTP logging output should be saved, or empty to print to the terminal |
D set http_proxy to '127.0.0.1:8999' ;
D select name, value, description from duckdb_settings() where name like 'http%';
|        name         |         value         |                                       description                                        |
|---------------------|-----------------------|------------------------------------------------------------------------------------------|
| http_proxy          | 127.0.0.1:8999        | HTTP proxy host                                                                          |
| http_proxy_username |                       | Username for HTTP proxy                                                                  |
| http_proxy          |                       | Password for HTTP proxy                                                                  |
| http_logging_output |                       | The file to which HTTP logging output should be saved, or empty to print to the terminal |
```

### OS:

Windows 10 x86_64

### DuckDB Version:

v1.1.0 fa5c2fe15f

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

Phil Leach

### Affiliation:

Bloomberg

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a nightly build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
Two settings named 'http_proxy'
### What happens?

There are two settings named 'http_proxy' : 

|        name         |         value         |                                       description                                        |
|---------------------|-----------------------|------------------------------------------------------------------------------------------|
| http_proxy          | 127.0.0.1:8999 | HTTP proxy host                                                                          |
| http_proxy_username |                       | Username for HTTP proxy                                                                  |
| http_proxy          |                       | Password for HTTP proxy                                                                  |
| http_logging_output |                       | The file to which HTTP logging output should be saved, or empty to print to the terminal |


### To Reproduce

```
D select name, value, description from duckdb_settings() where name like 'http%';
|        name         | value |                                       description                                        |
|---------------------|-------|------------------------------------------------------------------------------------------|
| http_proxy          |       | HTTP proxy host                                                                          |
| http_proxy_username |       | Username for HTTP proxy                                                                  |
| http_proxy          |       | Password for HTTP proxy                                                                  |
| http_logging_output |       | The file to which HTTP logging output should be saved, or empty to print to the terminal |
D set http_proxy to '127.0.0.1:8999' ;
D select name, value, description from duckdb_settings() where name like 'http%';
|        name         |         value         |                                       description                                        |
|---------------------|-----------------------|------------------------------------------------------------------------------------------|
| http_proxy          | 127.0.0.1:8999        | HTTP proxy host                                                                          |
| http_proxy_username |                       | Username for HTTP proxy                                                                  |
| http_proxy          |                       | Password for HTTP proxy                                                                  |
| http_logging_output |                       | The file to which HTTP logging output should be saved, or empty to print to the terminal |
```

### OS:

Windows 10 x86_64

### DuckDB Version:

v1.1.0 fa5c2fe15f

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

Phil Leach

### Affiliation:

Bloomberg

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a nightly build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/include/duckdb/main/settings.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/settings.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types/value.hpp"
13: 
14: namespace duckdb {
15: class ClientContext;
16: class DatabaseInstance;
17: struct DBConfig;
18: 
19: const string GetDefaultUserAgent();
20: 
21: enum class SettingScope : uint8_t {
22: 	//! Setting is from the global Setting scope
23: 	GLOBAL,
24: 	//! Setting is from the local Setting scope
25: 	LOCAL,
26: 	//! Setting was not feteched from settings, but it was fetched from a secret instead
27: 	SECRET,
28: 	//! The setting was not found or invalid in some other way
29: 	INVALID
30: };
31: 
32: struct SettingLookupResult {
33: public:
34: 	SettingLookupResult() : scope(SettingScope::INVALID) {
35: 	}
36: 	explicit SettingLookupResult(SettingScope scope) : scope(scope) {
37: 		D_ASSERT(scope != SettingScope::INVALID);
38: 	}
39: 
40: public:
41: 	operator bool() { // NOLINT: allow implicit conversion to bool
42: 		return scope != SettingScope::INVALID;
43: 	}
44: 
45: public:
46: 	SettingScope GetScope() {
47: 		D_ASSERT(scope != SettingScope::INVALID);
48: 		return scope;
49: 	}
50: 
51: private:
52: 	SettingScope scope = SettingScope::INVALID;
53: };
54: 
55: struct AccessModeSetting {
56: 	static constexpr const char *Name = "access_mode";
57: 	static constexpr const char *Description = "Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE)";
58: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
59: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
60: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
61: 	static Value GetSetting(const ClientContext &context);
62: };
63: 
64: struct AllowPersistentSecrets {
65: 	static constexpr const char *Name = "allow_persistent_secrets";
66: 	static constexpr const char *Description =
67: 	    "Allow the creation of persistent secrets, that are stored and loaded on restarts";
68: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
69: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
70: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
71: 	static Value GetSetting(const ClientContext &context);
72: };
73: 
74: struct CatalogErrorMaxSchema {
75: 	static constexpr const char *Name = "catalog_error_max_schemas";
76: 	static constexpr const char *Description =
77: 	    "The maximum number of schemas the system will scan for \"did you mean...\" style errors in the catalog";
78: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;
79: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
80: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
81: 	static Value GetSetting(const ClientContext &context);
82: };
83: 
84: struct CheckpointThresholdSetting {
85: 	static constexpr const char *Name = "checkpoint_threshold";
86: 	static constexpr const char *Description =
87: 	    "The WAL size threshold at which to automatically trigger a checkpoint (e.g. 1GB)";
88: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
89: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
90: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
91: 	static Value GetSetting(const ClientContext &context);
92: };
93: 
94: struct DebugCheckpointAbort {
95: 	static constexpr const char *Name = "debug_checkpoint_abort";
96: 	static constexpr const char *Description =
97: 	    "DEBUG SETTING: trigger an abort while checkpointing for testing purposes";
98: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
99: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
100: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
101: 	static Value GetSetting(const ClientContext &context);
102: };
103: 
104: struct DebugForceExternal {
105: 	static constexpr const char *Name = "debug_force_external";
106: 	static constexpr const char *Description =
107: 	    "DEBUG SETTING: force out-of-core computation for operators that support it, used for testing";
108: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
109: 	static void SetLocal(ClientContext &context, const Value &parameter);
110: 	static void ResetLocal(ClientContext &context);
111: 	static Value GetSetting(const ClientContext &context);
112: };
113: 
114: struct DebugForceNoCrossProduct {
115: 	static constexpr const char *Name = "debug_force_no_cross_product";
116: 	static constexpr const char *Description =
117: 	    "DEBUG SETTING: Force disable cross product generation when hyper graph isn't connected, used for testing";
118: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
119: 	static void SetLocal(ClientContext &context, const Value &parameter);
120: 	static void ResetLocal(ClientContext &context);
121: 	static Value GetSetting(const ClientContext &context);
122: };
123: 
124: struct DebugSkipCheckpointOnCommit {
125: 	static constexpr const char *Name = "debug_skip_checkpoint_on_commit";
126: 	static constexpr const char *Description = "DEBUG SETTING: skip checkpointing on commit";
127: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
128: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
129: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
130: 	static Value GetSetting(const ClientContext &context);
131: };
132: 
133: struct OrderedAggregateThreshold {
134: 	static constexpr const char *Name = "ordered_aggregate_threshold"; // NOLINT
135: 	static constexpr const char *Description =                         // NOLINT
136: 	    "The number of rows to accumulate before sorting, used for tuning";
137: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT; // NOLINT
138: 	static void SetLocal(ClientContext &context, const Value &parameter);
139: 	static void ResetLocal(ClientContext &context);
140: 	static Value GetSetting(const ClientContext &context);
141: };
142: 
143: struct DebugAsOfIEJoin {
144: 	static constexpr const char *Name = "debug_asof_iejoin";                                                 // NOLINT
145: 	static constexpr const char *Description = "DEBUG SETTING: force use of IEJoin to implement AsOf joins"; // NOLINT
146: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;                                 // NOLINT
147: 	static void SetLocal(ClientContext &context, const Value &parameter);
148: 	static void ResetLocal(ClientContext &context);
149: 	static Value GetSetting(const ClientContext &context);
150: };
151: 
152: struct PreferRangeJoins {
153: 	static constexpr const char *Name = "prefer_range_joins";                                    // NOLINT
154: 	static constexpr const char *Description = "Force use of range joins with mixed predicates"; // NOLINT
155: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;                     // NOLINT
156: 	static void SetLocal(ClientContext &context, const Value &parameter);
157: 	static void ResetLocal(ClientContext &context);
158: 	static Value GetSetting(const ClientContext &context);
159: };
160: 
161: struct DebugWindowMode {
162: 	static constexpr const char *Name = "debug_window_mode";
163: 	static constexpr const char *Description = "DEBUG SETTING: switch window mode to use";
164: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
165: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
166: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
167: 	static Value GetSetting(const ClientContext &context);
168: };
169: 
170: struct DefaultCollationSetting {
171: 	static constexpr const char *Name = "default_collation";
172: 	static constexpr const char *Description = "The collation setting used when none is specified";
173: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
174: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
175: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
176: 	static void SetLocal(ClientContext &context, const Value &parameter);
177: 	static void ResetLocal(ClientContext &context);
178: 	static Value GetSetting(const ClientContext &context);
179: };
180: 
181: struct DefaultOrderSetting {
182: 	static constexpr const char *Name = "default_order";
183: 	static constexpr const char *Description = "The order type used when none is specified (ASC or DESC)";
184: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
185: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
186: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
187: 	static Value GetSetting(const ClientContext &context);
188: };
189: 
190: struct DefaultNullOrderSetting {
191: 	static constexpr const char *Name = "default_null_order";
192: 	static constexpr const char *Description = "Null ordering used when none is specified (NULLS_FIRST or NULLS_LAST)";
193: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
194: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
195: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
196: 	static Value GetSetting(const ClientContext &context);
197: };
198: 
199: struct DefaultSecretStorage {
200: 	static constexpr const char *Name = "default_secret_storage";
201: 	static constexpr const char *Description = "Allows switching the default storage for secrets";
202: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
203: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
204: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
205: 	static Value GetSetting(const ClientContext &context);
206: };
207: 
208: struct DisabledFileSystemsSetting {
209: 	static constexpr const char *Name = "disabled_filesystems";
210: 	static constexpr const char *Description = "Disable specific file systems preventing access (e.g. LocalFileSystem)";
211: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
212: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
213: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
214: 	static Value GetSetting(const ClientContext &context);
215: };
216: 
217: struct DisabledOptimizersSetting {
218: 	static constexpr const char *Name = "disabled_optimizers";
219: 	static constexpr const char *Description = "DEBUG SETTING: disable a specific set of optimizers (comma separated)";
220: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
221: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
222: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
223: 	static Value GetSetting(const ClientContext &context);
224: };
225: 
226: struct EnableExternalAccessSetting {
227: 	static constexpr const char *Name = "enable_external_access";
228: 	static constexpr const char *Description =
229: 	    "Allow the database to access external state (through e.g. loading/installing modules, COPY TO/FROM, CSV "
230: 	    "readers, pandas replacement scans, etc)";
231: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
232: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
233: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
234: 	static Value GetSetting(const ClientContext &context);
235: };
236: 
237: struct EnableMacrosDependencies {
238: 	static constexpr const char *Name = "enable_macro_dependencies";
239: 	static constexpr const char *Description =
240: 	    "Enable created MACROs to create dependencies on the referenced objects (such as tables)";
241: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
242: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
243: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
244: 	static Value GetSetting(const ClientContext &context);
245: };
246: 
247: struct EnableViewDependencies {
248: 	static constexpr const char *Name = "enable_view_dependencies";
249: 	static constexpr const char *Description =
250: 	    "Enable created VIEWs to create dependencies on the referenced objects (such as tables)";
251: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
252: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
253: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
254: 	static Value GetSetting(const ClientContext &context);
255: };
256: 
257: struct EnableFSSTVectors {
258: 	static constexpr const char *Name = "enable_fsst_vectors";
259: 	static constexpr const char *Description =
260: 	    "Allow scans on FSST compressed segments to emit compressed vectors to utilize late decompression";
261: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
262: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
263: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
264: 	static Value GetSetting(const ClientContext &context);
265: };
266: 
267: struct AllowUnsignedExtensionsSetting {
268: 	static constexpr const char *Name = "allow_unsigned_extensions";
269: 	static constexpr const char *Description = "Allow to load extensions with invalid or missing signatures";
270: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
271: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
272: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
273: 	static Value GetSetting(const ClientContext &context);
274: };
275: 
276: struct AllowCommunityExtensionsSetting {
277: 	static constexpr const char *Name = "allow_community_extensions";
278: 	static constexpr const char *Description = "Allow to load community built extensions";
279: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
280: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
281: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
282: 	static Value GetSetting(const ClientContext &context);
283: };
284: 
285: struct AllowExtensionsMetadataMismatchSetting {
286: 	static constexpr const char *Name = "allow_extensions_metadata_mismatch";
287: 	static constexpr const char *Description = "Allow to load extensions with not compatible metadata";
288: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
289: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
290: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
291: 	static Value GetSetting(const ClientContext &context);
292: };
293: 
294: struct AllowUnredactedSecretsSetting {
295: 	static constexpr const char *Name = "allow_unredacted_secrets";
296: 	static constexpr const char *Description = "Allow printing unredacted secrets";
297: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
298: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
299: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
300: 	static Value GetSetting(const ClientContext &context);
301: };
302: 
303: struct CustomExtensionRepository {
304: 	static constexpr const char *Name = "custom_extension_repository";
305: 	static constexpr const char *Description = "Overrides the custom endpoint for remote extension installation";
306: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
307: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
308: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
309: 	static Value GetSetting(const ClientContext &context);
310: };
311: 
312: struct AutoloadExtensionRepository {
313: 	static constexpr const char *Name = "autoinstall_extension_repository";
314: 	static constexpr const char *Description =
315: 	    "Overrides the custom endpoint for extension installation on autoloading";
316: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
317: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
318: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
319: 	static Value GetSetting(const ClientContext &context);
320: };
321: 
322: struct AutoinstallKnownExtensions {
323: 	static constexpr const char *Name = "autoinstall_known_extensions";
324: 	static constexpr const char *Description =
325: 	    "Whether known extensions are allowed to be automatically installed when a query depends on them";
326: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
327: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
328: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
329: 	static Value GetSetting(const ClientContext &context);
330: };
331: 
332: struct AutoloadKnownExtensions {
333: 	static constexpr const char *Name = "autoload_known_extensions";
334: 	static constexpr const char *Description =
335: 	    "Whether known extensions are allowed to be automatically loaded when a query depends on them";
336: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
337: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
338: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
339: 	static Value GetSetting(const ClientContext &context);
340: };
341: 
342: struct EnableObjectCacheSetting {
343: 	static constexpr const char *Name = "enable_object_cache";
344: 	static constexpr const char *Description = "Whether or not object cache is used to cache e.g. Parquet metadata";
345: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
346: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
347: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
348: 	static Value GetSetting(const ClientContext &context);
349: };
350: 
351: struct StorageCompatibilityVersion {
352: 	static constexpr const char *Name = "storage_compatibility_version";
353: 	static constexpr const char *Description = "Serialize on checkpoint with compatibility for a given duckdb version";
354: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
355: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
356: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
357: 	static Value GetSetting(const ClientContext &context);
358: };
359: 
360: struct EnableHTTPMetadataCacheSetting {
361: 	static constexpr const char *Name = "enable_http_metadata_cache";
362: 	static constexpr const char *Description = "Whether or not the global http metadata is used to cache HTTP metadata";
363: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
364: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
365: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
366: 	static Value GetSetting(const ClientContext &context);
367: };
368: 
369: struct EnableProfilingSetting {
370: 	static constexpr const char *Name = "enable_profiling";
371: 	static constexpr const char *Description =
372: 	    "Enables profiling, and sets the output format (JSON, QUERY_TREE, QUERY_TREE_OPTIMIZER)";
373: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
374: 	static void SetLocal(ClientContext &context, const Value &parameter);
375: 	static void ResetLocal(ClientContext &context);
376: 	static Value GetSetting(const ClientContext &context);
377: };
378: 
379: struct CustomProfilingSettings {
380: 	static constexpr const char *Name = "custom_profiling_settings";
381: 	static constexpr const char *Description = "Accepts a JSON enabling custom metrics";
382: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
383: 	static void SetLocal(ClientContext &context, const Value &parameter);
384: 	static void ResetLocal(ClientContext &context);
385: 	static Value GetSetting(const ClientContext &context);
386: };
387: 
388: struct EnableProgressBarSetting {
389: 	static constexpr const char *Name = "enable_progress_bar";
390: 	static constexpr const char *Description =
391: 	    "Enables the progress bar, printing progress to the terminal for long queries";
392: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
393: 	static void SetLocal(ClientContext &context, const Value &parameter);
394: 	static void ResetLocal(ClientContext &context);
395: 	static Value GetSetting(const ClientContext &context);
396: };
397: 
398: struct EnableProgressBarPrintSetting {
399: 	static constexpr const char *Name = "enable_progress_bar_print";
400: 	static constexpr const char *Description =
401: 	    "Controls the printing of the progress bar, when 'enable_progress_bar' is true";
402: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
403: 	static void SetLocal(ClientContext &context, const Value &parameter);
404: 	static void ResetLocal(ClientContext &context);
405: 	static Value GetSetting(const ClientContext &context);
406: };
407: 
408: struct ErrorsAsJsonSetting {
409: 	static constexpr const char *Name = "errors_as_json";
410: 	static constexpr const char *Description = "Output error messages as structured JSON instead of as a raw string";
411: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
412: 	static void SetLocal(ClientContext &context, const Value &parameter);
413: 	static void ResetLocal(ClientContext &context);
414: 	static Value GetSetting(const ClientContext &context);
415: };
416: 
417: struct ExplainOutputSetting {
418: 	static constexpr const char *Name = "explain_output";
419: 	static constexpr const char *Description = "Output of EXPLAIN statements (ALL, OPTIMIZED_ONLY, PHYSICAL_ONLY)";
420: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
421: 	static void SetLocal(ClientContext &context, const Value &parameter);
422: 	static void ResetLocal(ClientContext &context);
423: 	static Value GetSetting(const ClientContext &context);
424: };
425: 
426: struct ExportLargeBufferArrow {
427: 	static constexpr const char *Name = "arrow_large_buffer_size";
428: 	static constexpr const char *Description =
429: 	    "If arrow buffers for strings, blobs, uuids and bits should be exported using large buffers";
430: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
431: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
432: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
433: 	static Value GetSetting(const ClientContext &context);
434: };
435: 
436: struct ExtensionDirectorySetting {
437: 	static constexpr const char *Name = "extension_directory";
438: 	static constexpr const char *Description = "Set the directory to store extensions in";
439: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
440: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
441: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
442: 	static Value GetSetting(const ClientContext &context);
443: };
444: 
445: struct ExternalThreadsSetting {
446: 	static constexpr const char *Name = "external_threads";
447: 	static constexpr const char *Description = "The number of external threads that work on DuckDB tasks.";
448: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
449: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
450: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
451: 	static Value GetSetting(const ClientContext &context);
452: };
453: 
454: struct FileSearchPathSetting {
455: 	static constexpr const char *Name = "file_search_path";
456: 	static constexpr const char *Description = "A comma separated list of directories to search for input files";
457: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
458: 	static void SetLocal(ClientContext &context, const Value &parameter);
459: 	static void ResetLocal(ClientContext &context);
460: 	static Value GetSetting(const ClientContext &context);
461: };
462: 
463: struct ForceCompressionSetting {
464: 	static constexpr const char *Name = "force_compression";
465: 	static constexpr const char *Description = "DEBUG SETTING: forces a specific compression method to be used";
466: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
467: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
468: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
469: 	static Value GetSetting(const ClientContext &context);
470: };
471: 
472: struct ForceBitpackingModeSetting {
473: 	static constexpr const char *Name = "force_bitpacking_mode";
474: 	static constexpr const char *Description = "DEBUG SETTING: forces a specific bitpacking mode";
475: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
476: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
477: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
478: 	static Value GetSetting(const ClientContext &context);
479: };
480: 
481: struct HomeDirectorySetting {
482: 	static constexpr const char *Name = "home_directory";
483: 	static constexpr const char *Description = "Sets the home directory used by the system";
484: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
485: 	static void SetLocal(ClientContext &context, const Value &parameter);
486: 	static void ResetLocal(ClientContext &context);
487: 	static Value GetSetting(const ClientContext &context);
488: };
489: 
490: struct HTTPProxy {
491: 	static constexpr const char *Name = "http_proxy";
492: 	static constexpr const char *Description = "HTTP proxy host";
493: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
494: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
495: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
496: 	static Value GetSetting(const ClientContext &context);
497: };
498: 
499: struct HTTPProxyUsername {
500: 	static constexpr const char *Name = "http_proxy_username";
501: 	static constexpr const char *Description = "Username for HTTP proxy";
502: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
503: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
504: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
505: 	static Value GetSetting(const ClientContext &context);
506: };
507: 
508: struct HTTPProxyPassword {
509: 	static constexpr const char *Name = "http_proxy";
510: 	static constexpr const char *Description = "Password for HTTP proxy";
511: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
512: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
513: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
514: 	static Value GetSetting(const ClientContext &context);
515: };
516: 
517: struct IntegerDivisionSetting {
518: 	static constexpr const char *Name = "integer_division";
519: 	static constexpr const char *Description =
520: 	    "Whether or not the / operator defaults to integer division, or to floating point division";
521: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
522: 	static void SetLocal(ClientContext &context, const Value &parameter);
523: 	static void ResetLocal(ClientContext &context);
524: 	static Value GetSetting(const ClientContext &context);
525: };
526: 
527: struct LogQueryPathSetting {
528: 	static constexpr const char *Name = "log_query_path";
529: 	static constexpr const char *Description =
530: 	    "Specifies the path to which queries should be logged (default: NULL, queries are not logged)";
531: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
532: 	static void SetLocal(ClientContext &context, const Value &parameter);
533: 	static void ResetLocal(ClientContext &context);
534: 	static Value GetSetting(const ClientContext &context);
535: };
536: 
537: struct LockConfigurationSetting {
538: 	static constexpr const char *Name = "lock_configuration";
539: 	static constexpr const char *Description = "Whether or not the configuration can be altered";
540: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
541: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
542: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
543: 	static Value GetSetting(const ClientContext &context);
544: };
545: 
546: struct IEEEFloatingPointOpsSetting {
547: 	static constexpr const char *Name = "ieee_floating_point_ops";
548: 	static constexpr const char *Description =
549: 	    "Use IEE754-compliant floating point operations (returning NAN instead of errors/NULL)";
550: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
551: 	static void SetLocal(ClientContext &context, const Value &parameter);
552: 	static void ResetLocal(ClientContext &context);
553: 	static Value GetSetting(const ClientContext &context);
554: };
555: 
556: struct ImmediateTransactionModeSetting {
557: 	static constexpr const char *Name = "immediate_transaction_mode";
558: 	static constexpr const char *Description =
559: 	    "Whether transactions should be started lazily when needed, or immediately when BEGIN TRANSACTION is called";
560: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
561: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
562: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
563: 	static Value GetSetting(const ClientContext &context);
564: };
565: 
566: struct MaximumExpressionDepthSetting {
567: 	static constexpr const char *Name = "max_expression_depth";
568: 	static constexpr const char *Description =
569: 	    "The maximum expression depth limit in the parser. WARNING: increasing this setting and using very deep "
570: 	    "expressions might lead to stack overflow errors.";
571: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;
572: 	static void SetLocal(ClientContext &context, const Value &parameter);
573: 	static void ResetLocal(ClientContext &context);
574: 	static Value GetSetting(const ClientContext &context);
575: };
576: 
577: struct MaximumMemorySetting {
578: 	static constexpr const char *Name = "max_memory";
579: 	static constexpr const char *Description = "The maximum memory of the system (e.g. 1GB)";
580: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
581: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
582: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
583: 	static Value GetSetting(const ClientContext &context);
584: };
585: 
586: struct StreamingBufferSize {
587: 	static constexpr const char *Name = "streaming_buffer_size";
588: 	static constexpr const char *Description =
589: 	    "The maximum memory to buffer between fetching from a streaming result (e.g. 1GB)";
590: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
591: 	static void SetLocal(ClientContext &context, const Value &parameter);
592: 	static void ResetLocal(ClientContext &context);
593: 	static Value GetSetting(const ClientContext &context);
594: };
595: 
596: struct MaximumTempDirectorySize {
597: 	static constexpr const char *Name = "max_temp_directory_size";
598: 	static constexpr const char *Description =
599: 	    "The maximum amount of data stored inside the 'temp_directory' (when set) (e.g. 1GB)";
600: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
601: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
602: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
603: 	static Value GetSetting(const ClientContext &context);
604: };
605: 
606: struct MaximumVacuumTasks {
607: 	static constexpr const char *Name = "max_vacuum_tasks";
608: 	static constexpr const char *Description = "The maximum vacuum tasks to schedule during a checkpoint";
609: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;
610: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
611: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
612: 	static Value GetSetting(const ClientContext &context);
613: };
614: 
615: struct MergeJoinThreshold {
616: 	static constexpr const char *Name = "merge_join_threshold";
617: 	static constexpr const char *Description = "The number of rows we need on either table to choose a merge join";
618: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;
619: 	static void SetLocal(ClientContext &context, const Value &parameter);
620: 	static void ResetLocal(ClientContext &context);
621: 	static Value GetSetting(const ClientContext &context);
622: };
623: 
624: struct NestedLoopJoinThreshold {
625: 	static constexpr const char *Name = "nested_loop_join_threshold";
626: 	static constexpr const char *Description =
627: 	    "The number of rows we need on either table to choose a nested loop join";
628: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;
629: 	static void SetLocal(ClientContext &context, const Value &parameter);
630: 	static void ResetLocal(ClientContext &context);
631: 	static Value GetSetting(const ClientContext &context);
632: };
633: 
634: struct OldImplicitCasting {
635: 	static constexpr const char *Name = "old_implicit_casting";
636: 	static constexpr const char *Description = "Allow implicit casting to/from VARCHAR";
637: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
638: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
639: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
640: 	static Value GetSetting(const ClientContext &context);
641: };
642: 
643: struct OrderByNonIntegerLiteral {
644: 	static constexpr const char *Name = "order_by_non_integer_literal";
645: 	static constexpr const char *Description =
646: 	    "Allow ordering by non-integer literals - ordering by such literals has no effect";
647: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
648: 	static void SetLocal(ClientContext &context, const Value &parameter);
649: 	static void ResetLocal(ClientContext &context);
650: 	static Value GetSetting(const ClientContext &context);
651: };
652: 
653: struct PartitionedWriteFlushThreshold {
654: 	static constexpr const char *Name = "partitioned_write_flush_threshold";
655: 	static constexpr const char *Description =
656: 	    "The threshold in number of rows after which we flush a thread state when writing using PARTITION_BY";
657: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;
658: 	static void SetLocal(ClientContext &context, const Value &parameter);
659: 	static void ResetLocal(ClientContext &context);
660: 	static Value GetSetting(const ClientContext &context);
661: };
662: 
663: struct PartitionedWriteMaxOpenFiles {
664: 	static constexpr const char *Name = "partitioned_write_max_open_files";
665: 	static constexpr const char *Description =
666: 	    "The maximum amount of files the system can keep open before flushing to disk when writing using PARTITION_BY";
667: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;
668: 	static void SetLocal(ClientContext &context, const Value &parameter);
669: 	static void ResetLocal(ClientContext &context);
670: 	static Value GetSetting(const ClientContext &context);
671: };
672: 
673: struct DefaultBlockAllocSize {
674: 	static constexpr const char *Name = "default_block_size";
675: 	static constexpr const char *Description =
676: 	    "The default block size for new duckdb database files (new as-in, they do not yet exist).";
677: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;
678: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
679: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
680: 	static Value GetSetting(const ClientContext &context);
681: };
682: 
683: struct IndexScanPercentage {
684: 	static constexpr const char *Name = "index_scan_percentage";
685: 	static constexpr const char *Description =
686: 	    "The index scan percentage sets a threshold for index scans. If fewer than MAX(index_scan_max_count, "
687: 	    "index_scan_percentage * total_row_count) rows match, we perform an index scan instead of a table scan.";
688: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::DOUBLE;
689: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
690: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
691: 	static Value GetSetting(const ClientContext &context);
692: };
693: 
694: struct IndexScanMaxCount {
695: 	static constexpr const char *Name = "index_scan_max_count";
696: 	static constexpr const char *Description =
697: 	    "The maximum index scan count sets a threshold for index scans. If fewer than MAX(index_scan_max_count, "
698: 	    "index_scan_percentage * total_row_count) rows match, we perform an index scan instead of a table scan.";
699: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;
700: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
701: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
702: 	static Value GetSetting(const ClientContext &context);
703: };
704: 
705: struct PasswordSetting {
706: 	static constexpr const char *Name = "password";
707: 	static constexpr const char *Description = "The password to use. Ignored for legacy compatibility.";
708: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
709: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
710: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
711: 	static Value GetSetting(const ClientContext &context);
712: };
713: 
714: struct PerfectHashThresholdSetting {
715: 	static constexpr const char *Name = "perfect_ht_threshold";
716: 	static constexpr const char *Description = "Threshold in bytes for when to use a perfect hash table";
717: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
718: 	static void SetLocal(ClientContext &context, const Value &parameter);
719: 	static void ResetLocal(ClientContext &context);
720: 	static Value GetSetting(const ClientContext &context);
721: };
722: 
723: struct PivotFilterThreshold {
724: 	static constexpr const char *Name = "pivot_filter_threshold";
725: 	static constexpr const char *Description =
726: 	    "The threshold to switch from using filtered aggregates to LIST with a dedicated pivot operator";
727: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
728: 	static void SetLocal(ClientContext &context, const Value &parameter);
729: 	static void ResetLocal(ClientContext &context);
730: 	static Value GetSetting(const ClientContext &context);
731: };
732: 
733: struct PivotLimitSetting {
734: 	static constexpr const char *Name = "pivot_limit";
735: 	static constexpr const char *Description = "The maximum number of pivot columns in a pivot statement";
736: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
737: 	static void SetLocal(ClientContext &context, const Value &parameter);
738: 	static void ResetLocal(ClientContext &context);
739: 	static Value GetSetting(const ClientContext &context);
740: };
741: 
742: struct PreserveIdentifierCase {
743: 	static constexpr const char *Name = "preserve_identifier_case";
744: 	static constexpr const char *Description =
745: 	    "Whether or not to preserve the identifier case, instead of always lowercasing all non-quoted identifiers";
746: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
747: 	static void SetLocal(ClientContext &context, const Value &parameter);
748: 	static void ResetLocal(ClientContext &context);
749: 	static Value GetSetting(const ClientContext &context);
750: };
751: 
752: struct PreserveInsertionOrder {
753: 	static constexpr const char *Name = "preserve_insertion_order";
754: 	static constexpr const char *Description =
755: 	    "Whether or not to preserve insertion order. If set to false the system is allowed to re-order any results "
756: 	    "that do not contain ORDER BY clauses.";
757: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
758: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
759: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
760: 	static Value GetSetting(const ClientContext &context);
761: };
762: 
763: struct ArrowOutputListView {
764: 	static constexpr const char *Name = "arrow_output_list_view";
765: 	static constexpr const char *Description =
766: 	    "If export to arrow format should use ListView as the physical layout for LIST columns";
767: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
768: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
769: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
770: 	static Value GetSetting(const ClientContext &context);
771: };
772: 
773: struct LosslessConversionArrow {
774: 	static constexpr const char *Name = "arrow_lossless_conversion";
775: 	static constexpr const char *Description =
776: 	    "Whenever a DuckDB type does not have a clear native or canonical extension match in Arrow, export the types "
777: 	    "with a duckdb.type_name extension name.";
778: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
779: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
780: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
781: 	static Value GetSetting(const ClientContext &context);
782: };
783: 
784: struct ProduceArrowStringView {
785: 	static constexpr const char *Name = "produce_arrow_string_view";
786: 	static constexpr const char *Description =
787: 	    "If strings should be produced by DuckDB in Utf8View format instead of Utf8";
788: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
789: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
790: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
791: 	static Value GetSetting(const ClientContext &context);
792: };
793: 
794: struct ProfileOutputSetting {
795: 	static constexpr const char *Name = "profile_output";
796: 	static constexpr const char *Description =
797: 	    "The file to which profile output should be saved, or empty to print to the terminal";
798: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
799: 	static void SetLocal(ClientContext &context, const Value &parameter);
800: 	static void ResetLocal(ClientContext &context);
801: 	static Value GetSetting(const ClientContext &context);
802: };
803: 
804: struct ProfilingModeSetting {
805: 	static constexpr const char *Name = "profiling_mode";
806: 	static constexpr const char *Description = "The profiling mode (STANDARD or DETAILED)";
807: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
808: 	static void SetLocal(ClientContext &context, const Value &parameter);
809: 	static void ResetLocal(ClientContext &context);
810: 	static Value GetSetting(const ClientContext &context);
811: };
812: 
813: struct ProgressBarTimeSetting {
814: 	static constexpr const char *Name = "progress_bar_time";
815: 	static constexpr const char *Description =
816: 	    "Sets the time (in milliseconds) how long a query needs to take before we start printing a progress bar";
817: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
818: 	static void SetLocal(ClientContext &context, const Value &parameter);
819: 	static void ResetLocal(ClientContext &context);
820: 	static Value GetSetting(const ClientContext &context);
821: };
822: 
823: struct ScalarSubqueryErrorOnMultipleRows {
824: 	static constexpr const char *Name = "scalar_subquery_error_on_multiple_rows";
825: 	static constexpr const char *Description =
826: 	    "When a scalar subquery returns multiple rows - return a random row instead of returning an error";
827: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
828: 	static void SetLocal(ClientContext &context, const Value &parameter);
829: 	static void ResetLocal(ClientContext &context);
830: 	static Value GetSetting(const ClientContext &context);
831: };
832: 
833: struct SchemaSetting {
834: 	static constexpr const char *Name = "schema";
835: 	static constexpr const char *Description =
836: 	    "Sets the default search schema. Equivalent to setting search_path to a single value.";
837: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
838: 	static void SetLocal(ClientContext &context, const Value &parameter);
839: 	static void ResetLocal(ClientContext &context);
840: 	static Value GetSetting(const ClientContext &context);
841: };
842: 
843: struct SearchPathSetting {
844: 	static constexpr const char *Name = "search_path";
845: 	static constexpr const char *Description =
846: 	    "Sets the default catalog search path as a comma-separated list of values";
847: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
848: 	static void SetLocal(ClientContext &context, const Value &parameter);
849: 	static void ResetLocal(ClientContext &context);
850: 	static Value GetSetting(const ClientContext &context);
851: };
852: 
853: struct SecretDirectorySetting {
854: 	static constexpr const char *Name = "secret_directory";
855: 	static constexpr const char *Description = "Set the directory to which persistent secrets are stored";
856: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
857: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
858: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
859: 	static Value GetSetting(const ClientContext &context);
860: };
861: 
862: struct TempDirectorySetting {
863: 	static constexpr const char *Name = "temp_directory";
864: 	static constexpr const char *Description = "Set the directory to which to write temp files";
865: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
866: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
867: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
868: 	static Value GetSetting(const ClientContext &context);
869: };
870: 
871: struct ThreadsSetting {
872: 	static constexpr const char *Name = "threads";
873: 	static constexpr const char *Description = "The number of total threads used by the system.";
874: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
875: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
876: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
877: 	static Value GetSetting(const ClientContext &context);
878: };
879: 
880: struct UsernameSetting {
881: 	static constexpr const char *Name = "username";
882: 	static constexpr const char *Description = "The username to use. Ignored for legacy compatibility.";
883: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
884: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
885: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
886: 	static Value GetSetting(const ClientContext &context);
887: };
888: 
889: struct AllocatorFlushThreshold {
890: 	static constexpr const char *Name = "allocator_flush_threshold";
891: 	static constexpr const char *Description =
892: 	    "Peak allocation threshold at which to flush the allocator after completing a task.";
893: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
894: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
895: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
896: 	static Value GetSetting(const ClientContext &context);
897: };
898: 
899: struct AllocatorBulkDeallocationFlushThreshold {
900: 	static constexpr const char *Name = "allocator_bulk_deallocation_flush_threshold";
901: 	static constexpr const char *Description =
902: 	    "If a bulk deallocation larger than this occurs, flush outstanding allocations.";
903: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
904: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
905: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
906: 	static Value GetSetting(const ClientContext &context);
907: };
908: 
909: struct AllocatorBackgroundThreadsSetting {
910: 	static constexpr const char *Name = "allocator_background_threads";
911: 	static constexpr const char *Description = "Whether to enable the allocator background thread.";
912: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
913: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
914: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
915: 	static Value GetSetting(const ClientContext &context);
916: };
917: 
918: struct DuckDBApiSetting {
919: 	static constexpr const char *Name = "duckdb_api";
920: 	static constexpr const char *Description = "DuckDB API surface";
921: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
922: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
923: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
924: 	static Value GetSetting(const ClientContext &context);
925: };
926: 
927: struct CustomUserAgentSetting {
928: 	static constexpr const char *Name = "custom_user_agent";
929: 	static constexpr const char *Description = "Metadata from DuckDB callers";
930: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
931: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
932: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
933: 	static Value GetSetting(const ClientContext &context);
934: };
935: 
936: struct EnableHTTPLoggingSetting {
937: 	static constexpr const char *Name = "enable_http_logging";
938: 	static constexpr const char *Description = "Enables HTTP logging";
939: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
940: 	static void SetLocal(ClientContext &context, const Value &parameter);
941: 	static void ResetLocal(ClientContext &context);
942: 	static Value GetSetting(const ClientContext &context);
943: };
944: 
945: struct HTTPLoggingOutputSetting {
946: 	static constexpr const char *Name = "http_logging_output";
947: 	static constexpr const char *Description =
948: 	    "The file to which HTTP logging output should be saved, or empty to print to the terminal";
949: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
950: 	static void SetLocal(ClientContext &context, const Value &parameter);
951: 	static void ResetLocal(ClientContext &context);
952: 	static Value GetSetting(const ClientContext &context);
953: };
954: 
955: } // namespace duckdb
[end of src/include/duckdb/main/settings.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: