{
  "repo": "duckdb/duckdb",
  "pull_number": 11807,
  "instance_id": "duckdb__duckdb-11807",
  "issue_numbers": [
    "11804",
    "11804"
  ],
  "base_commit": "bc3cb2e2ec80904e36996d1fbf101ba6879c31e7",
  "patch": "diff --git a/extension/json/include/json_executors.hpp b/extension/json/include/json_executors.hpp\nindex 334170ee73b2..78da4526842f 100644\n--- a/extension/json/include/json_executors.hpp\n+++ b/extension/json/include/json_executors.hpp\n@@ -30,7 +30,7 @@ struct JSONExecutors {\n \t}\n \n \t//! Two-argument JSON read function (with path query), i.e. json_type('[1, 2, 3]', '$[0]')\n-\ttemplate <class T>\n+\ttemplate <class T, bool NULL_IF_NULL = true>\n \tstatic void BinaryExecute(DataChunk &args, ExpressionState &state, Vector &result,\n \t                          std::function<T(yyjson_val *, yyjson_alc *, Vector &)> fun) {\n \t\tauto &func_expr = state.expr.Cast<BoundFunctionExpression>();\n@@ -48,7 +48,7 @@ struct JSONExecutors {\n \t\t\t\t\t    auto doc =\n \t\t\t\t\t        JSONCommon::ReadDocument(input, JSONCommon::READ_FLAG, lstate.json_allocator.GetYYAlc());\n \t\t\t\t\t    auto val = JSONCommon::GetUnsafe(doc->root, ptr, len);\n-\t\t\t\t\t    if (!val || unsafe_yyjson_is_null(val)) {\n+\t\t\t\t\t    if (!val || (NULL_IF_NULL && unsafe_yyjson_is_null(val))) {\n \t\t\t\t\t\t    mask.SetInvalid(idx);\n \t\t\t\t\t\t    return T {};\n \t\t\t\t\t    } else {\n@@ -76,7 +76,7 @@ struct JSONExecutors {\n \t\t\t\t\tfor (idx_t i = 0; i < vals.size(); i++) {\n \t\t\t\t\t\tauto &val = vals[i];\n \t\t\t\t\t\tD_ASSERT(val != nullptr); // Wildcard extract shouldn't give back nullptrs\n-\t\t\t\t\t\tif (unsafe_yyjson_is_null(val)) {\n+\t\t\t\t\t\tif (NULL_IF_NULL && unsafe_yyjson_is_null(val)) {\n \t\t\t\t\t\t\tchild_validity.SetInvalid(current_size + i);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tchild_vals[current_size + i] = fun(val, alc, result);\n@@ -109,7 +109,7 @@ struct JSONExecutors {\n \t}\n \n \t//! JSON read function with list of path queries, i.e. json_type('[1, 2, 3]', ['$[0]', '$[1]'])\n-\ttemplate <class T>\n+\ttemplate <class T, bool NULL_IF_NULL = true>\n \tstatic void ExecuteMany(DataChunk &args, ExpressionState &state, Vector &result,\n \t                        std::function<T(yyjson_val *, yyjson_alc *, Vector &)> fun) {\n \t\tauto &func_expr = state.expr.Cast<BoundFunctionExpression>();\n@@ -148,7 +148,7 @@ struct JSONExecutors {\n \t\t\tfor (idx_t path_i = 0; path_i < num_paths; path_i++) {\n \t\t\t\tauto child_idx = offset + path_i;\n \t\t\t\tval = JSONCommon::GetUnsafe(doc->root, info.ptrs[path_i], info.lens[path_i]);\n-\t\t\t\tif (!val || unsafe_yyjson_is_null(val)) {\n+\t\t\t\tif (!val || (NULL_IF_NULL && unsafe_yyjson_is_null(val))) {\n \t\t\t\t\tchild_validity.SetInvalid(child_idx);\n \t\t\t\t} else {\n \t\t\t\t\tchild_data[child_idx] = fun(val, alc, child);\ndiff --git a/extension/json/json_functions/json_type.cpp b/extension/json/json_functions/json_type.cpp\nindex b1e9dbcc2d46..8f3fb3ad9722 100644\n--- a/extension/json/json_functions/json_type.cpp\n+++ b/extension/json/json_functions/json_type.cpp\n@@ -11,11 +11,11 @@ static void UnaryTypeFunction(DataChunk &args, ExpressionState &state, Vector &r\n }\n \n static void BinaryTypeFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONExecutors::BinaryExecute<string_t>(args, state, result, GetType);\n+\tJSONExecutors::BinaryExecute<string_t, false>(args, state, result, GetType);\n }\n \n static void ManyTypeFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tJSONExecutors::ExecuteMany<string_t>(args, state, result, GetType);\n+\tJSONExecutors::ExecuteMany<string_t, false>(args, state, result, GetType);\n }\n \n static void GetTypeFunctionsInternal(ScalarFunctionSet &set, const LogicalType &input_type) {\n",
  "test_patch": "diff --git a/test/sql/json/issues/issue11804.test b/test/sql/json/issues/issue11804.test\nnew file mode 100644\nindex 000000000000..014f7ba7460e\n--- /dev/null\n+++ b/test/sql/json/issues/issue11804.test\n@@ -0,0 +1,20 @@\n+# name: test/sql/json/issues/issue11804.test\n+# description: Test issue 11804 - json_type(...) with path does not return \"NULL\"\n+# group: [issues]\n+\n+require json\n+\n+query I\n+select json_type(JSON 'null') = 'NULL';\n+----\n+true\n+\n+query I\n+select json_type(JSON '{\"a\": null}', '/a') = 'NULL';\n+----\n+true\n+\n+query I\n+select json_type(JSON '{\"a\": null}', '$.a') = 'NULL';\n+----\n+true\n",
  "problem_statement": "`json_type(...)` with path does not return \"NULL\"\n### What happens?\r\n\r\nWhen using JSONPointer or JSONPath syntax to get type information from a JSON value using the `json_type(...)` function, I get the following unexpected behavior:\r\n\r\n```sql\r\n.nullvalue ''\r\n```\r\n```sql\r\nselect json_type(JSON 'null') as type;\r\n```\r\n```text\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  type   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 NULL    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nselect json_type(JSON '{\"a\": null}', '/a') as type;\r\n```\r\n```text\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  type   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nselect json_type(JSON '{\"a\": null}', '$.a') as type;\r\n```\r\n```text\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  type   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nI would expect the string `'NULL'` to be returned in each of the above situations\r\n\r\n### To Reproduce\r\n\r\nSee shell snippets above\r\n\r\n### OS:\r\n\r\nOS X, Apple Silicon\r\n\r\n### DuckDB Version:\r\n\r\n0.10.2\r\n\r\n### DuckDB Client:\r\n\r\nshell\r\n\r\n### Full Name:\r\n\r\nCarl Jackson\r\n\r\n### Affiliation:\r\n\r\nWatershed\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n`json_type(...)` with path does not return \"NULL\"\n### What happens?\r\n\r\nWhen using JSONPointer or JSONPath syntax to get type information from a JSON value using the `json_type(...)` function, I get the following unexpected behavior:\r\n\r\n```sql\r\n.nullvalue ''\r\n```\r\n```sql\r\nselect json_type(JSON 'null') as type;\r\n```\r\n```text\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  type   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 NULL    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nselect json_type(JSON '{\"a\": null}', '/a') as type;\r\n```\r\n```text\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  type   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nselect json_type(JSON '{\"a\": null}', '$.a') as type;\r\n```\r\n```text\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  type   \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nI would expect the string `'NULL'` to be returned in each of the above situations\r\n\r\n### To Reproduce\r\n\r\nSee shell snippets above\r\n\r\n### OS:\r\n\r\nOS X, Apple Silicon\r\n\r\n### DuckDB Version:\r\n\r\n0.10.2\r\n\r\n### DuckDB Client:\r\n\r\nshell\r\n\r\n### Full Name:\r\n\r\nCarl Jackson\r\n\r\n### Affiliation:\r\n\r\nWatershed\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2024-04-24T09:19:58Z"
}