You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Query parquet file throws runtime error: "Payload value bigger than allowed. Corrupted file?"
#### What happens?
Query parquet file with DuckDB throws this error: `Payload value bigger than allowed. Corrupted file?`. And I was able to read the same parquet file with other tools such as `parquet-tools` and `parquet-cli`.

#### To Reproduce
1. Download the parquet file: `wget https://github.com/guihaojin/duckdb/raw/master/yellowcab.parquet`.
2. In DuckDB CLI, run a SQL query: `select * from 'yellowcab.parquet' limit 5;`.

#### Environment (please complete the following information):
 - OS: MacOS v12.1
 - DuckDB Version: 3.2
 - DuckDB Client: CLI / Python

#### Before Submitting

- [Yes] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [Yes] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

Query parquet file throws runtime error: "Payload value bigger than allowed. Corrupted file?"
#### What happens?
Query parquet file with DuckDB throws this error: `Payload value bigger than allowed. Corrupted file?`. And I was able to read the same parquet file with other tools such as `parquet-tools` and `parquet-cli`.

#### To Reproduce
1. Download the parquet file: `wget https://github.com/guihaojin/duckdb/raw/master/yellowcab.parquet`.
2. In DuckDB CLI, run a SQL query: `select * from 'yellowcab.parquet' limit 5;`.

#### Environment (please complete the following information):
 - OS: MacOS v12.1
 - DuckDB Version: 3.2
 - DuckDB Client: CLI / Python

#### Before Submitting

- [Yes] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [Yes] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of extension/parquet/include/parquet_rle_bp_decoder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // parquet_rle_bp_decoder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: #include "parquet_types.h"
11: #include "thrift_tools.hpp"
12: #include "resizable_buffer.hpp"
13: #include "decode_utils.hpp"
14: 
15: namespace duckdb {
16: 
17: class RleBpDecoder {
18: public:
19: 	/// Create a decoder object. buffer/buffer_len is the decoded data.
20: 	/// bit_width is the width of each value (before encoding).
21: 	RleBpDecoder(const uint8_t *buffer, uint32_t buffer_len, uint32_t bit_width)
22: 	    : buffer_((char *)buffer, buffer_len), bit_width_(bit_width), current_value_(0), repeat_count_(0),
23: 	      literal_count_(0) {
24: 		if (bit_width >= 64) {
25: 			throw std::runtime_error("Decode bit width too large");
26: 		}
27: 		byte_encoded_len = ((bit_width_ + 7) / 8);
28: 		max_val = (1 << bit_width_) - 1;
29: 	}
30: 
31: 	template <typename T>
32: 	void GetBatch(char *values_target_ptr, uint32_t batch_size) {
33: 		auto values = (T *)values_target_ptr;
34: 		uint32_t values_read = 0;
35: 
36: 		while (values_read < batch_size) {
37: 			if (repeat_count_ > 0) {
38: 				int repeat_batch = MinValue(batch_size - values_read, static_cast<uint32_t>(repeat_count_));
39: 				std::fill(values + values_read, values + values_read + repeat_batch, static_cast<T>(current_value_));
40: 				repeat_count_ -= repeat_batch;
41: 				values_read += repeat_batch;
42: 			} else if (literal_count_ > 0) {
43: 				uint32_t literal_batch = MinValue(batch_size - values_read, static_cast<uint32_t>(literal_count_));
44: 				uint32_t actual_read = ParquetDecodeUtils::BitUnpack<T>(buffer_, bitpack_pos, values + values_read,
45: 				                                                        literal_batch, bit_width_);
46: 				if (literal_batch != actual_read) {
47: 					throw std::runtime_error("Did not find enough values");
48: 				}
49: 				literal_count_ -= literal_batch;
50: 				values_read += literal_batch;
51: 			} else {
52: 				if (!NextCounts<T>()) {
53: 					if (values_read != batch_size) {
54: 						throw std::runtime_error("RLE decode did not find enough values");
55: 					}
56: 					return;
57: 				}
58: 			}
59: 		}
60: 		if (values_read != batch_size) {
61: 			throw std::runtime_error("RLE decode did not find enough values");
62: 		}
63: 	}
64: 
65: 	static uint8_t ComputeBitWidth(idx_t val) {
66: 		if (val == 0) {
67: 			return 0;
68: 		}
69: 		uint8_t ret = 1;
70: 		while (((idx_t)(1 << ret) - 1) < val) {
71: 			ret++;
72: 		}
73: 		return ret;
74: 	}
75: 
76: private:
77: 	ByteBuffer buffer_;
78: 
79: 	/// Number of bits needed to encode the value. Must be between 0 and 64.
80: 	int bit_width_;
81: 	uint64_t current_value_;
82: 	uint32_t repeat_count_;
83: 	uint32_t literal_count_;
84: 	uint8_t byte_encoded_len;
85: 	uint32_t max_val;
86: 
87: 	uint8_t bitpack_pos = 0;
88: 
89: 	/// Fills literal_count_ and repeat_count_ with next values. Returns false if there
90: 	/// are no more.
91: 	template <typename T>
92: 	bool NextCounts() {
93: 		// Read the next run's indicator int, it could be a literal or repeated run.
94: 		// The int is encoded as a vlq-encoded value.
95: 		if (bitpack_pos != 0) {
96: 			buffer_.inc(1);
97: 			bitpack_pos = 0;
98: 		}
99: 		auto indicator_value = ParquetDecodeUtils::VarintDecode<uint32_t>(buffer_);
100: 
101: 		// lsb indicates if it is a literal run or repeated run
102: 		bool is_literal = indicator_value & 1;
103: 		if (is_literal) {
104: 			literal_count_ = (indicator_value >> 1) * 8;
105: 		} else {
106: 			repeat_count_ = indicator_value >> 1;
107: 			// (ARROW-4018) this is not big-endian compatible, lol
108: 			current_value_ = 0;
109: 			for (auto i = 0; i < byte_encoded_len; i++) {
110: 				current_value_ |= (buffer_.read<uint8_t>() << (i * 8));
111: 			}
112: 			// sanity check
113: 			if (repeat_count_ > 0 && current_value_ > max_val) {
114: 				throw std::runtime_error("Payload value bigger than allowed. Corrupted file?");
115: 			}
116: 		}
117: 		// TODO complain if we run out of buffer
118: 		return true;
119: 	}
120: };
121: } // namespace duckdb
[end of extension/parquet/include/parquet_rle_bp_decoder.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: