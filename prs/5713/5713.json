{
  "repo": "duckdb/duckdb",
  "pull_number": 5713,
  "instance_id": "duckdb__duckdb-5713",
  "issue_numbers": [
    "5712"
  ],
  "base_commit": "6bb4ee8fc83c36e44a03e4593959322bdff5c916",
  "patch": "diff --git a/extension/icu/icu-timezone.cpp b/extension/icu/icu-timezone.cpp\nindex da4903f56f54..95aafa0f80c4 100644\n--- a/extension/icu/icu-timezone.cpp\n+++ b/extension/icu/icu-timezone.cpp\n@@ -84,7 +84,7 @@ static void ICUTimeZoneFunction(ClientContext &context, TableFunctionInput &data\n \toutput.SetCardinality(index);\n }\n \n-struct ICUFromLocalTime : public ICUDateFunc {\n+struct ICUFromLocalTimestamp : public ICUDateFunc {\n \tstatic inline timestamp_t Operation(icu::Calendar *calendar, timestamp_t local) {\n \t\t// Extract the parts from the \"instant\"\n \t\tdate_t local_date;\n@@ -117,7 +117,7 @@ struct ICUFromLocalTime : public ICUDateFunc {\n \t}\n };\n \n-struct ICUToLocalTime : public ICUDateFunc {\n+struct ICUToLocalTimestamp : public ICUDateFunc {\n \tstatic inline timestamp_t Operation(icu::Calendar *calendar, timestamp_t instant) {\n \t\t// Extract the time zone parts\n \t\tauto micros = SetTime(calendar, instant);\n@@ -147,6 +147,84 @@ struct ICUToLocalTime : public ICUDateFunc {\n \t}\n };\n \n+struct ICULocalTimestampFunc : public ICUDateFunc {\n+\n+\tstruct BindDataNow : public BindData {\n+\t\texplicit BindDataNow(ClientContext &context) : BindData(context) {\n+\t\t\tnow = context.ActiveTransaction().start_timestamp;\n+\t\t}\n+\n+\t\tBindDataNow(const BindDataNow &other) : BindData(other), now(other.now) {\n+\t\t}\n+\n+\t\tbool Equals(const FunctionData &other_p) const override {\n+\t\t\tauto &other = (const BindDataNow &)other_p;\n+\t\t\tif (now != other.now) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\treturn BindData::Equals(other_p);\n+\t\t}\n+\n+\t\tunique_ptr<FunctionData> Copy() const override {\n+\t\t\treturn make_unique<BindDataNow>(*this);\n+\t\t}\n+\n+\t\ttimestamp_t now;\n+\t};\n+\n+\tstatic unique_ptr<FunctionData> BindNow(ClientContext &context, ScalarFunction &bound_function,\n+\t                                        vector<unique_ptr<Expression>> &arguments) {\n+\t\treturn make_unique<BindDataNow>(context);\n+\t}\n+\n+\tstatic timestamp_t GetLocalTimestamp(ExpressionState &state) {\n+\t\tauto &func_expr = (BoundFunctionExpression &)state.expr;\n+\t\tauto &info = (BindDataNow &)*func_expr.bind_info;\n+\t\tCalendarPtr calendar_ptr(info.calendar->clone());\n+\t\tauto calendar = calendar_ptr.get();\n+\n+\t\tconst auto now = info.now;\n+\t\treturn ICUToLocalTimestamp::Operation(calendar, now);\n+\t}\n+\n+\tstatic void Execute(DataChunk &input, ExpressionState &state, Vector &result) {\n+\t\tD_ASSERT(input.ColumnCount() == 0);\n+\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\t\tauto rdata = ConstantVector::GetData<timestamp_t>(result);\n+\t\trdata[0] = GetLocalTimestamp(state);\n+\t}\n+\n+\tstatic void AddFunction(const string &name, ClientContext &context) {\n+\t\tScalarFunctionSet set(name);\n+\t\tset.AddFunction(ScalarFunction({}, LogicalType::TIMESTAMP, Execute, BindNow));\n+\n+\t\tCreateScalarFunctionInfo func_info(set);\n+\t\tauto &catalog = Catalog::GetCatalog(context);\n+\t\tcatalog.AddFunction(context, &func_info);\n+\t}\n+};\n+\n+struct ICULocalTimeFunc : public ICUDateFunc {\n+\n+\tstatic void Execute(DataChunk &input, ExpressionState &state, Vector &result) {\n+\t\tD_ASSERT(input.ColumnCount() == 0);\n+\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\t\tauto rdata = ConstantVector::GetData<dtime_t>(result);\n+\t\tconst auto local = ICULocalTimestampFunc::GetLocalTimestamp(state);\n+\t\trdata[0] = Timestamp::GetTime(local);\n+\t}\n+\n+\tstatic void AddFunction(const string &name, ClientContext &context) {\n+\t\tScalarFunctionSet set(name);\n+\t\tset.AddFunction(ScalarFunction({}, LogicalType::TIME, Execute, ICULocalTimestampFunc::BindNow));\n+\n+\t\tCreateScalarFunctionInfo func_info(set);\n+\t\tauto &catalog = Catalog::GetCatalog(context);\n+\t\tcatalog.AddFunction(context, &func_info);\n+\t}\n+};\n+\n struct ICUTimeZoneFunc : public ICUDateFunc {\n \ttemplate <typename OP>\n \tstatic void Execute(DataChunk &input, ExpressionState &state, Vector &result) {\n@@ -189,9 +267,9 @@ struct ICUTimeZoneFunc : public ICUDateFunc {\n \tstatic void AddFunction(const string &name, ClientContext &context) {\n \t\tScalarFunctionSet set(name);\n \t\tset.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::TIMESTAMP}, LogicalType::TIMESTAMP_TZ,\n-\t\t                               Execute<ICUFromLocalTime>, Bind));\n+\t\t                               Execute<ICUFromLocalTimestamp>, Bind));\n \t\tset.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::TIMESTAMP_TZ}, LogicalType::TIMESTAMP,\n-\t\t                               Execute<ICUToLocalTime>, Bind));\n+\t\t                               Execute<ICUToLocalTimestamp>, Bind));\n \n \t\tCreateScalarFunctionInfo func_info(set);\n \t\tauto &catalog = Catalog::GetCatalog(context);\n@@ -206,6 +284,8 @@ void RegisterICUTimeZoneFunctions(ClientContext &context) {\n \tcatalog.CreateTableFunction(context, &tz_names_info);\n \n \tICUTimeZoneFunc::AddFunction(\"timezone\", context);\n+\tICULocalTimestampFunc::AddFunction(\"current_localtimestamp\", context);\n+\tICULocalTimeFunc::AddFunction(\"current_localtime\", context);\n }\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/main/extension_functions.hpp b/src/include/duckdb/main/extension_functions.hpp\nindex f3555af05035..f448cc40c691 100644\n--- a/src/include/duckdb/main/extension_functions.hpp\n+++ b/src/include/duckdb/main/extension_functions.hpp\n@@ -21,6 +21,8 @@ static constexpr ExtensionFunction EXTENSION_FUNCTIONS[] = {\n     {\"->>\", \"json\"},\n     {\"array_to_json\", \"json\"},\n     {\"create_fts_index\", \"fts\"},\n+    {\"current_localtime\", \"icu\"},\n+    {\"current_localtimestamp\", \"icu\"},\n     {\"dbgen\", \"tpch\"},\n     {\"drop_fts_index\", \"fts\"},\n     {\"dsdgen\", \"tpcds\"},\n",
  "test_patch": "diff --git a/test/sql/timezone/test_icu_timezone.test b/test/sql/timezone/test_icu_timezone.test\nindex 0bace5ca3548..bd84455e52c7 100644\n--- a/test/sql/timezone/test_icu_timezone.test\n+++ b/test/sql/timezone/test_icu_timezone.test\n@@ -146,6 +146,21 @@ infinity\tinfinity\n NULL\tNULL\n NULL\tNULL\n \n+#\n+# Verify local time functions are implemented.\n+#\n+statement ok\n+select localtimestamp;\n+\n+statement ok\n+select localtime;\n+\n+statement ok\n+select current_localtimestamp();\n+\n+statement ok\n+select current_localtime();\n+\n #\n # ICU time zone list\n #\n",
  "problem_statement": "Implement CURRENT_TIMESTAMP and CURRENT_TIME\n        > maybe `CURRENT_TIMESTAMP` should return a TIMESTAMP though.\r\n\r\nFrom the [PG docs](https://www.postgresql.org/docs/15/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT):\r\n\r\n> CURRENT_TIME and CURRENT_TIMESTAMP deliver values with time zone; LOCALTIME and LOCALTIMESTAMP deliver values without time zone.\r\n\r\nSo maybe what we need is `LOCALTIME` and `LOCALTIMESTAMP`. Although I think those are supposed to be non-instant values (which will create further confusion...)\r\n\r\n_Originally posted by @hawkfish in https://github.com/duckdb/duckdb/issues/5631#issuecomment-1342767054_\r\n      \n",
  "hints_text": "These are simple additions to the existing `AT TIME ZONE` functionality.",
  "created_at": "2022-12-15T15:03:58Z"
}