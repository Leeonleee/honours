{
  "repo": "duckdb/duckdb",
  "pull_number": 8090,
  "instance_id": "duckdb__duckdb-8090",
  "issue_numbers": [
    "8067"
  ],
  "base_commit": "c6e419cf12d901f3d577395c565a2bac307fdb10",
  "patch": "diff --git a/extension/parquet/parquet_extension.cpp b/extension/parquet/parquet_extension.cpp\nindex 9110a4c7674b..b585548643ac 100644\n--- a/extension/parquet/parquet_extension.cpp\n+++ b/extension/parquet/parquet_extension.cpp\n@@ -1,7 +1,8 @@\n #define DUCKDB_EXTENSION_MAIN\n \n-#include \"duckdb.hpp\"\n #include \"parquet_extension.hpp\"\n+\n+#include \"duckdb.hpp\"\n #include \"parquet_metadata.hpp\"\n #include \"parquet_reader.hpp\"\n #include \"parquet_writer.hpp\"\n@@ -712,12 +713,10 @@ static void GetFieldIDs(const Value &field_ids_value, ChildFieldIDs &field_ids,\n \n \t\tFieldID field_id;\n \t\tif (field_id_value) {\n-\t\t\tif (field_id_value->type().id() != LogicalTypeId::INTEGER) {\n-\t\t\t\tthrow BinderException(\"Expected an INTEGER in FIELD_IDS specification for column \\\"%s\\\"\", col_name);\n-\t\t\t}\n-\t\t\tconst uint32_t field_id_int = IntegerValue::Get(*field_id_value);\n+\t\t\tValue field_id_integer_value = field_id_value->DefaultCastAs(LogicalType::INTEGER);\n+\t\t\tconst uint32_t field_id_int = IntegerValue::Get(field_id_integer_value);\n \t\t\tif (!unique_field_ids.insert(field_id_int).second) {\n-\t\t\t\tthrow BinderException(\"Duplicate field_id %s found in FIELD_IDS\", field_id_value->ToString());\n+\t\t\t\tthrow BinderException(\"Duplicate field_id %s found in FIELD_IDS\", field_id_integer_value.ToString());\n \t\t\t}\n \t\t\tfield_id = FieldID(field_id_int);\n \t\t}\ndiff --git a/src/include/duckdb/parser/transformer.hpp b/src/include/duckdb/parser/transformer.hpp\nindex bba9e3ff5f78..d9db17138533 100644\n--- a/src/include/duckdb/parser/transformer.hpp\n+++ b/src/include/duckdb/parser/transformer.hpp\n@@ -8,21 +8,20 @@\n \n #pragma once\n \n+#include \"duckdb/common/case_insensitive_map.hpp\"\n #include \"duckdb/common/constants.hpp\"\n #include \"duckdb/common/enums/expression_type.hpp\"\n #include \"duckdb/common/types.hpp\"\n #include \"duckdb/common/unordered_map.hpp\"\n-#include \"duckdb/parser/qualified_name.hpp\"\n-#include \"duckdb/parser/tokens.hpp\"\n-#include \"duckdb/parser/parsed_data/create_info.hpp\"\n #include \"duckdb/parser/group_by_node.hpp\"\n+#include \"duckdb/parser/parsed_data/create_info.hpp\"\n+#include \"duckdb/parser/qualified_name.hpp\"\n #include \"duckdb/parser/query_node.hpp\"\n-#include \"duckdb/common/case_insensitive_map.hpp\"\n #include \"duckdb/parser/query_node/cte_node.hpp\"\n-\n-#include \"pg_definitions.hpp\"\n+#include \"duckdb/parser/tokens.hpp\"\n #include \"nodes/parsenodes.hpp\"\n #include \"nodes/primnodes.hpp\"\n+#include \"pg_definitions.hpp\"\n \n namespace duckdb {\n \n@@ -283,6 +282,7 @@ class Transformer {\n \tunique_ptr<ParsedExpression> TransformUnaryOperator(const string &op, unique_ptr<ParsedExpression> child);\n \tunique_ptr<ParsedExpression> TransformBinaryOperator(string op, unique_ptr<ParsedExpression> left,\n \t                                                     unique_ptr<ParsedExpression> right);\n+\tstatic bool ConstructConstantFromExpression(const ParsedExpression &expr, Value &value);\n \t//===--------------------------------------------------------------------===//\n \t// TableRef transform\n \t//===--------------------------------------------------------------------===//\ndiff --git a/src/parser/transform/expression/transform_constant.cpp b/src/parser/transform/expression/transform_constant.cpp\nindex 6794173e74cb..587a4a06307e 100644\n--- a/src/parser/transform/expression/transform_constant.cpp\n+++ b/src/parser/transform/expression/transform_constant.cpp\n@@ -1,8 +1,11 @@\n-#include \"duckdb/parser/expression/constant_expression.hpp\"\n-#include \"duckdb/parser/transformer.hpp\"\n-#include \"duckdb/common/operator/cast_operators.hpp\"\n+#include \"duckdb/common/enum_util.hpp\"\n #include \"duckdb/common/limits.hpp\"\n+#include \"duckdb/common/operator/cast_operators.hpp\"\n #include \"duckdb/common/types/decimal.hpp\"\n+#include \"duckdb/parser/expression/cast_expression.hpp\"\n+#include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/expression/function_expression.hpp\"\n+#include \"duckdb/parser/transformer.hpp\"\n \n namespace duckdb {\n \n@@ -76,4 +79,53 @@ unique_ptr<ParsedExpression> Transformer::TransformConstant(duckdb_libpgquery::P\n \treturn TransformValue(c.val);\n }\n \n+bool Transformer::ConstructConstantFromExpression(const ParsedExpression &expr, Value &value) {\n+\t// We have to construct it like this because we don't have the ClientContext for binding/executing the expr here\n+\tswitch (expr.type) {\n+\tcase ExpressionType::FUNCTION: {\n+\t\tauto &function = expr.Cast<FunctionExpression>();\n+\t\tif (function.function_name == \"struct_pack\") {\n+\t\t\tunordered_set<string> unique_names;\n+\t\t\tchild_list_t<Value> values;\n+\t\t\tvalues.reserve(function.children.size());\n+\t\t\tfor (const auto &child : function.children) {\n+\t\t\t\tif (!unique_names.insert(child->alias).second) {\n+\t\t\t\t\tthrow BinderException(\"Duplicate struct entry name \\\"%s\\\"\", child->alias);\n+\t\t\t\t}\n+\t\t\t\tValue child_value;\n+\t\t\t\tif (!ConstructConstantFromExpression(*child, child_value)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvalues.emplace_back(child->alias, std::move(child_value));\n+\t\t\t}\n+\t\t\tvalue = Value::STRUCT(std::move(values));\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\tcase ExpressionType::VALUE_CONSTANT: {\n+\t\tauto &constant = expr.Cast<ConstantExpression>();\n+\t\tvalue = constant.value;\n+\t\treturn true;\n+\t}\n+\tcase ExpressionType::OPERATOR_CAST: {\n+\t\tauto &cast = expr.Cast<CastExpression>();\n+\t\tValue dummy_value;\n+\t\tif (!ConstructConstantFromExpression(*cast.child, dummy_value)) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tstring error_message;\n+\t\tif (!dummy_value.DefaultTryCastAs(cast.cast_type, value, &error_message)) {\n+\t\t\tthrow ConversionException(\"Unable to cast %s to %s\", dummy_value.ToString(),\n+\t\t\t                          EnumUtil::ToString(cast.cast_type.id()));\n+\t\t}\n+\t\treturn true;\n+\t}\n+\tdefault:\n+\t\treturn false;\n+\t}\n+}\n+\n } // namespace duckdb\ndiff --git a/src/parser/transform/statement/transform_copy.cpp b/src/parser/transform/statement/transform_copy.cpp\nindex 539100356e51..41c8bea840cb 100644\n--- a/src/parser/transform/statement/transform_copy.cpp\n+++ b/src/parser/transform/statement/transform_copy.cpp\n@@ -11,35 +11,6 @@\n \n namespace duckdb {\n \n-static Value ConstructValueFromFunction(const ParsedExpression &expr) {\n-\t// We have to construct it like this because we don't have the ClientContext for binding/executing the expr here\n-\tswitch (expr.type) {\n-\tcase ExpressionType::FUNCTION: {\n-\t\tauto &function = expr.Cast<FunctionExpression>();\n-\t\tif (function.function_name == \"struct_pack\") {\n-\t\t\tunordered_set<string> unique_names;\n-\t\t\tchild_list_t<Value> values;\n-\t\t\tvalues.reserve(function.children.size());\n-\t\t\tfor (const auto &child : function.children) {\n-\t\t\t\tif (!unique_names.insert(child->alias).second) {\n-\t\t\t\t\tthrow BinderException(\"Duplicate struct entry name \\\"%s\\\"\", child->alias);\n-\t\t\t\t}\n-\t\t\t\tvalues.emplace_back(child->alias, ConstructValueFromFunction(*child));\n-\t\t\t}\n-\t\t\treturn Value::STRUCT(std::move(values));\n-\t\t} else {\n-\t\t\tthrow ParserException(\"Unsupported function in COPY options: %s\", function.function_name);\n-\t\t}\n-\t}\n-\tcase ExpressionType::VALUE_CONSTANT: {\n-\t\tauto &constant = expr.Cast<ConstantExpression>();\n-\t\treturn constant.value;\n-\t}\n-\tdefault:\n-\t\tthrow ParserException(\"Unsupported expression in COPY options: %s\", expr.ToString());\n-\t}\n-}\n-\n void Transformer::TransformCopyOptions(CopyInfo &info, optional_ptr<duckdb_libpgquery::PGList> options) {\n \tif (!options) {\n \t\treturn;\n@@ -81,7 +52,12 @@ void Transformer::TransformCopyOptions(CopyInfo &info, optional_ptr<duckdb_libpg\n \t\tcase duckdb_libpgquery::T_PGFuncCall: {\n \t\t\tauto func_call = PGPointerCast<duckdb_libpgquery::PGFuncCall>(def_elem->arg);\n \t\t\tauto func_expr = TransformFuncCall(*func_call);\n-\t\t\tinfo.options[def_elem->defname].push_back(ConstructValueFromFunction(*func_expr));\n+\n+\t\t\tValue value;\n+\t\t\tif (!Transformer::ConstructConstantFromExpression(*func_expr, value)) {\n+\t\t\t\tthrow ParserException(\"Unsupported expression in COPY options: %s\", func_expr->ToString());\n+\t\t\t}\n+\t\t\tinfo.options[def_elem->defname].push_back(std::move(value));\n \t\t\tbreak;\n \t\t}\n \t\tdefault: {\ndiff --git a/src/parser/transform/statement/transform_pragma.cpp b/src/parser/transform/statement/transform_pragma.cpp\nindex f684939395e6..6c9d25e272fc 100644\n--- a/src/parser/transform/statement/transform_pragma.cpp\n+++ b/src/parser/transform/statement/transform_pragma.cpp\n@@ -1,11 +1,12 @@\n-#include \"duckdb/parser/statement/pragma_statement.hpp\"\n-#include \"duckdb/parser/transformer.hpp\"\n-#include \"duckdb/parser/expression/constant_expression.hpp\"\n-#include \"duckdb/parser/expression/comparison_expression.hpp\"\n-#include \"duckdb/execution/expression_executor.hpp\"\n-#include \"duckdb/parser/statement/set_statement.hpp\"\n #include \"duckdb/common/case_insensitive_map.hpp\"\n+#include \"duckdb/common/enum_util.hpp\"\n+#include \"duckdb/execution/expression_executor.hpp\"\n #include \"duckdb/parser/expression/columnref_expression.hpp\"\n+#include \"duckdb/parser/expression/comparison_expression.hpp\"\n+#include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/statement/pragma_statement.hpp\"\n+#include \"duckdb/parser/statement/set_statement.hpp\"\n+#include \"duckdb/parser/transformer.hpp\"\n \n namespace duckdb {\n \n@@ -22,15 +23,17 @@ unique_ptr<SQLStatement> Transformer::TransformPragma(duckdb_libpgquery::PGPragm\n \n \t\t\tif (expr->type == ExpressionType::COMPARE_EQUAL) {\n \t\t\t\tauto &comp = expr->Cast<ComparisonExpression>();\n-\t\t\t\tif (comp.right->type != ExpressionType::VALUE_CONSTANT) {\n-\t\t\t\t\tthrow ParserException(\"Named parameter requires a constant on the RHS\");\n-\t\t\t\t}\n \t\t\t\tif (comp.left->type != ExpressionType::COLUMN_REF) {\n \t\t\t\t\tthrow ParserException(\"Named parameter requires a column reference on the LHS\");\n \t\t\t\t}\n \t\t\t\tauto &columnref = comp.left->Cast<ColumnRefExpression>();\n-\t\t\t\tauto &constant = comp.right->Cast<ConstantExpression>();\n-\t\t\t\tinfo.named_parameters[columnref.GetName()] = constant.value;\n+\n+\t\t\t\tValue rhs_value;\n+\t\t\t\tif (!Transformer::ConstructConstantFromExpression(*comp.right, rhs_value)) {\n+\t\t\t\t\tthrow ParserException(\"Named parameter requires a constant on the RHS\");\n+\t\t\t\t}\n+\n+\t\t\t\tinfo.named_parameters[columnref.GetName()] = rhs_value;\n \t\t\t} else if (node->type == duckdb_libpgquery::T_PGAConst) {\n \t\t\t\tauto constant = TransformConstant(*PGPointerCast<duckdb_libpgquery::PGAConst>(node.get()));\n \t\t\t\tinfo.parameters.push_back((constant->Cast<ConstantExpression>()).value);\n",
  "test_patch": "diff --git a/test/sql/copy/parquet/writer/parquet_write_field_id.test b/test/sql/copy/parquet/writer/parquet_write_field_id.test\nindex 009fad0aeb29..c21ad661a088 100644\n--- a/test/sql/copy/parquet/writer/parquet_write_field_id.test\n+++ b/test/sql/copy/parquet/writer/parquet_write_field_id.test\n@@ -18,7 +18,7 @@ Binder Error\n \n # we can't do functions here\n statement error\n-copy (select range as i from range(10)) to '__TEST_DIR__/my.parquet' (FIELD_IDS {j:42-1})\n+copy (select range as i from range(10)) to '__TEST_DIR__/my.parquet' (FIELD_IDS {i:42-1})\n ----\n Parser Error\n \n@@ -31,7 +31,49 @@ select field_id from parquet_schema('__TEST_DIR__/my.parquet') where name = 'i'\n ----\n 42\n \n-# this shouldn't\n+# needs to be castable to integer, so this works\n+statement ok\n+copy (select range as i from range(10)) to '__TEST_DIR__/my.parquet' (FIELD_IDS {i:'42'})\n+\n+query I\n+select field_id from parquet_schema('__TEST_DIR__/my.parquet') where name = 'i'\n+----\n+42\n+\n+# but this doesn't\n+statement error\n+copy (select range as i from range(10)) to '__TEST_DIR__/my.parquet' (FIELD_IDS {i:'abc'})\n+----\n+Invalid Input Error\n+\n+# we can do casts\n+statement ok\n+copy (select range as i from range(10)) to '__TEST_DIR__/my.parquet' (FIELD_IDS {i:42::hugeint})\n+\n+query I\n+select field_id from parquet_schema('__TEST_DIR__/my.parquet') where name = 'i'\n+----\n+42\n+\n+# wrong casts should lead to ConversionException\n+statement error\n+copy (select range as i from range(10)) to '__TEST_DIR__/my.parquet' (FIELD_IDS {i:1024::utinyint})\n+----\n+Conversion Error\n+\n+# we can't do functions inside of casts (this one is just for coverage)\n+statement error\n+copy (select range as i from range(10)) to '__TEST_DIR__/my.parquet' (FIELD_IDS {i:cast(42-1 as hugeint)})\n+----\n+Parser Error\n+\n+# field id can't be a colref\n+statement error\n+copy (select range as i from range(10)) to '__TEST_DIR__/my.parquet' (FIELD_IDS {i:i})\n+----\n+Parser Error\n+\n+# this shouldn't work\n statement error\n copy (select range as i from range(10)) to '__TEST_DIR__/my.parquet' (FIELD_IDS 'oops')\n ----\ndiff --git a/test/sql/fts/test_indexing.test_slow b/test/sql/fts/test_indexing.test_slow\nindex 42c26851d89c..1e1f33820d7f 100644\n--- a/test/sql/fts/test_indexing.test_slow\n+++ b/test/sql/fts/test_indexing.test_slow\n@@ -37,7 +37,7 @@ statement error\n PRAGMA create_fts_index('documents', 'id', 'body')\n \n statement ok\n-PRAGMA create_fts_index('documents', 'id', 'body', overwrite=1)\n+PRAGMA create_fts_index('documents', 'id', 'body', overwrite=true)\n \n # drop and re-create\n statement ok\n",
  "problem_statement": "fts extension: BOOLEAN params for create_fts_index only accepts INTEGERs\n### What happens?\n\nThe documentation for the `create_fts_index` PRAGMA statement indicates that its parameters `strip_accents`, `lower`, and `overwrite` take `BOOLEAN` values, however in practice, they currently only accept `INTEGER`s.\n\n### To Reproduce\n\nThis works ok:\r\n\r\n    PRAGMA create_fts_index('my_table', 'col_id', 'col', overwrite=1);\r\n\r\nWhereas this does not:\r\n\r\n    PRAGMA create_fts_index('my_table', 'col_id', 'col', overwrite=true);\r\n\r\nResulting in this error: `Error: Parser Error: Named parameter requires a constant on the RHS`\n\n### OS:\n\nUbuntu\n\n### DuckDB Version:\n\nv0.8.2-dev87 8a17511028\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nNed Letcher\n\n### Affiliation:\n\nThoughtworks\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-06-27T14:02:11Z"
}