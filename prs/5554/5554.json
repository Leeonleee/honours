{
  "repo": "duckdb/duckdb",
  "pull_number": 5554,
  "instance_id": "duckdb__duckdb-5554",
  "issue_numbers": [
    "5523"
  ],
  "base_commit": "45d857191be915d3a38c83b75a42a945ba04fe9d",
  "patch": "diff --git a/src/common/radix_partitioning.cpp b/src/common/radix_partitioning.cpp\nindex 6ef7313deea6..6468bcf7d5bc 100644\n--- a/src/common/radix_partitioning.cpp\n+++ b/src/common/radix_partitioning.cpp\n@@ -11,7 +11,7 @@\n namespace duckdb {\n \n template <class OP, class RETURN_TYPE, typename... ARGS>\n-RETURN_TYPE RadixBitsSwitch(idx_t radix_bits, ARGS &&... args) {\n+RETURN_TYPE RadixBitsSwitch(idx_t radix_bits, ARGS &&...args) {\n \tD_ASSERT(radix_bits <= sizeof(hash_t) * 8);\n \tswitch (radix_bits) {\n \tcase 1:\n@@ -40,7 +40,7 @@ RETURN_TYPE RadixBitsSwitch(idx_t radix_bits, ARGS &&... args) {\n }\n \n template <class OP, class RETURN_TYPE, idx_t radix_bits_1, typename... ARGS>\n-RETURN_TYPE DoubleRadixBitsSwitch2(idx_t radix_bits_2, ARGS &&... args) {\n+RETURN_TYPE DoubleRadixBitsSwitch2(idx_t radix_bits_2, ARGS &&...args) {\n \tD_ASSERT(radix_bits_2 <= sizeof(hash_t) * 8);\n \tswitch (radix_bits_2) {\n \tcase 1:\n@@ -69,7 +69,7 @@ RETURN_TYPE DoubleRadixBitsSwitch2(idx_t radix_bits_2, ARGS &&... args) {\n }\n \n template <class OP, class RETURN_TYPE, typename... ARGS>\n-RETURN_TYPE DoubleRadixBitsSwitch1(idx_t radix_bits_1, idx_t radix_bits_2, ARGS &&... args) {\n+RETURN_TYPE DoubleRadixBitsSwitch1(idx_t radix_bits_1, idx_t radix_bits_2, ARGS &&...args) {\n \tD_ASSERT(radix_bits_1 <= sizeof(hash_t) * 8);\n \tswitch (radix_bits_1) {\n \tcase 1:\ndiff --git a/src/function/aggregate/nested/list.cpp b/src/function/aggregate/nested/list.cpp\nindex 516d3e6e7e49..85a24e3abf05 100644\n--- a/src/function/aggregate/nested/list.cpp\n+++ b/src/function/aggregate/nested/list.cpp\n@@ -24,13 +24,16 @@ struct LinkedList {\n // forward declarations\n struct WriteDataToSegment;\n struct ReadDataFromSegment;\n+struct CopyDataFromSegment;\n typedef ListSegment *(*create_segment_t)(WriteDataToSegment &write_data_to_segment, Allocator &allocator,\n-                                         vector<AllocatedData> &owning_vector, uint16_t &capacity);\n+                                         vector<AllocatedData> &owning_vector, const uint16_t &capacity);\n typedef void (*write_data_to_segment_t)(WriteDataToSegment &write_data_to_segment, Allocator &allocator,\n                                         vector<AllocatedData> &owning_vector, ListSegment *segment, Vector &input,\n                                         idx_t &entry_idx, idx_t &count);\n-typedef void (*read_data_from_segment_t)(ReadDataFromSegment &read_data_from_segment, ListSegment *segment,\n+typedef void (*read_data_from_segment_t)(ReadDataFromSegment &read_data_from_segment, const ListSegment *segment,\n                                          Vector &result, idx_t &total_count);\n+typedef ListSegment *(*copy_data_from_segment_t)(CopyDataFromSegment &copy_data_from_segment, const ListSegment *source,\n+                                                 Allocator &allocator, vector<AllocatedData> &owning_vector);\n \n struct WriteDataToSegment {\n \tcreate_segment_t create_segment;\n@@ -41,6 +44,10 @@ struct ReadDataFromSegment {\n \tread_data_from_segment_t segment_function;\n \tvector<ReadDataFromSegment> child_functions;\n };\n+struct CopyDataFromSegment {\n+\tcopy_data_from_segment_t segment_function;\n+\tvector<CopyDataFromSegment> child_functions;\n+};\n \n // forward declarations\n static void AppendRow(WriteDataToSegment &write_data_to_segment, Allocator &allocator,\n@@ -48,24 +55,27 @@ static void AppendRow(WriteDataToSegment &write_data_to_segment, Allocator &allo\n                       idx_t &count);\n static void BuildListVector(ReadDataFromSegment &read_data_from_segment, LinkedList *linked_list, Vector &result,\n                             idx_t &initial_total_count);\n+static void CopyLinkedList(CopyDataFromSegment &copy_data_from_segment, const LinkedList *source_list,\n+                           LinkedList &target_list, Allocator &allocator, vector<AllocatedData> &owning_vector);\n \n template <class T>\n static data_ptr_t AllocatePrimitiveData(Allocator &allocator, vector<AllocatedData> &owning_vector,\n-                                        uint16_t &capacity) {\n+                                        const uint16_t &capacity) {\n \n \towning_vector.emplace_back(allocator.Allocate(sizeof(ListSegment) + capacity * (sizeof(bool) + sizeof(T))));\n \treturn owning_vector.back().get();\n }\n \n-static data_ptr_t AllocateListData(Allocator &allocator, vector<AllocatedData> &owning_vector, uint16_t &capacity) {\n+static data_ptr_t AllocateListData(Allocator &allocator, vector<AllocatedData> &owning_vector,\n+                                   const uint16_t &capacity) {\n \n \towning_vector.emplace_back(\n \t    allocator.Allocate(sizeof(ListSegment) + capacity * (sizeof(bool) + sizeof(uint64_t)) + sizeof(LinkedList)));\n \treturn owning_vector.back().get();\n }\n \n-static data_ptr_t AllocateStructData(Allocator &allocator, vector<AllocatedData> &owning_vector, uint16_t &capacity,\n-                                     idx_t child_count) {\n+static data_ptr_t AllocateStructData(Allocator &allocator, vector<AllocatedData> &owning_vector,\n+                                     const uint16_t &capacity, const idx_t &child_count) {\n \n \towning_vector.emplace_back(\n \t    allocator.Allocate(sizeof(ListSegment) + capacity * sizeof(bool) + child_count * sizeof(ListSegment *)));\n@@ -73,28 +83,28 @@ static data_ptr_t AllocateStructData(Allocator &allocator, vector<AllocatedData>\n }\n \n template <class T>\n-static T *GetPrimitiveData(ListSegment *segment) {\n+static T *GetPrimitiveData(const ListSegment *segment) {\n \treturn (T *)(((char *)segment) + sizeof(ListSegment) + segment->capacity * sizeof(bool));\n }\n \n-static uint64_t *GetListLengthData(ListSegment *segment) {\n+static uint64_t *GetListLengthData(const ListSegment *segment) {\n \treturn (uint64_t *)(((char *)segment) + sizeof(ListSegment) + segment->capacity * sizeof(bool));\n }\n \n-static LinkedList *GetListChildData(ListSegment *segment) {\n+static LinkedList *GetListChildData(const ListSegment *segment) {\n \treturn (LinkedList *)(((char *)segment) + sizeof(ListSegment) +\n \t                      segment->capacity * (sizeof(bool) + sizeof(uint64_t)));\n }\n \n-static ListSegment **GetStructData(ListSegment *segment) {\n+static ListSegment **GetStructData(const ListSegment *segment) {\n \treturn (ListSegment **)(((char *)segment) + sizeof(ListSegment) + segment->capacity * sizeof(bool));\n }\n \n-static bool *GetNullMask(ListSegment *segment) {\n+static bool *GetNullMask(const ListSegment *segment) {\n \treturn (bool *)(((char *)segment) + sizeof(ListSegment));\n }\n \n-static uint16_t GetCapacityForNewSegment(LinkedList *linked_list) {\n+static uint16_t GetCapacityForNewSegment(const LinkedList *linked_list) {\n \n \t// consecutive segments grow by the power of two\n \tuint16_t capacity = 4;\n@@ -107,7 +117,7 @@ static uint16_t GetCapacityForNewSegment(LinkedList *linked_list) {\n \n template <class T>\n static ListSegment *CreatePrimitiveSegment(WriteDataToSegment &, Allocator &allocator,\n-                                           vector<AllocatedData> &owning_vector, uint16_t &capacity) {\n+                                           vector<AllocatedData> &owning_vector, const uint16_t &capacity) {\n \n \t// allocate data and set the header\n \tauto segment = (ListSegment *)AllocatePrimitiveData<T>(allocator, owning_vector, capacity);\n@@ -118,7 +128,7 @@ static ListSegment *CreatePrimitiveSegment(WriteDataToSegment &, Allocator &allo\n }\n \n static ListSegment *CreateListSegment(WriteDataToSegment &, Allocator &allocator, vector<AllocatedData> &owning_vector,\n-                                      uint16_t &capacity) {\n+                                      const uint16_t &capacity) {\n \n \t// allocate data and set the header\n \tauto segment = (ListSegment *)AllocateListData(allocator, owning_vector, capacity);\n@@ -135,7 +145,7 @@ static ListSegment *CreateListSegment(WriteDataToSegment &, Allocator &allocator\n }\n \n static ListSegment *CreateStructSegment(WriteDataToSegment &write_data_to_segment, Allocator &allocator,\n-                                        vector<AllocatedData> &owning_vector, uint16_t &capacity) {\n+                                        vector<AllocatedData> &owning_vector, const uint16_t &capacity) {\n \n \t// allocate data and set header\n \tauto segment = (ListSegment *)AllocateStructData(allocator, owning_vector, capacity,\n@@ -329,7 +339,7 @@ static void AppendRow(WriteDataToSegment &write_data_to_segment, Allocator &allo\n }\n \n template <class T>\n-static void ReadDataFromPrimitiveSegment(ReadDataFromSegment &, ListSegment *segment, Vector &result,\n+static void ReadDataFromPrimitiveSegment(ReadDataFromSegment &, const ListSegment *segment, Vector &result,\n                                          idx_t &total_count) {\n \n \tauto &aggr_vector_validity = FlatVector::Validity(result);\n@@ -353,7 +363,7 @@ static void ReadDataFromPrimitiveSegment(ReadDataFromSegment &, ListSegment *seg\n \t}\n }\n \n-static void ReadDataFromVarcharSegment(ReadDataFromSegment &, ListSegment *segment, Vector &result,\n+static void ReadDataFromVarcharSegment(ReadDataFromSegment &, const ListSegment *segment, Vector &result,\n                                        idx_t &total_count) {\n \n \tauto &aggr_vector_validity = FlatVector::Validity(result);\n@@ -394,8 +404,8 @@ static void ReadDataFromVarcharSegment(ReadDataFromSegment &, ListSegment *segme\n \t}\n }\n \n-static void ReadDataFromListSegment(ReadDataFromSegment &read_data_from_segment, ListSegment *segment, Vector &result,\n-                                    idx_t &total_count) {\n+static void ReadDataFromListSegment(ReadDataFromSegment &read_data_from_segment, const ListSegment *segment,\n+                                    Vector &result, idx_t &total_count) {\n \n \tauto &aggr_vector_validity = FlatVector::Validity(result);\n \n@@ -434,8 +444,8 @@ static void ReadDataFromListSegment(ReadDataFromSegment &read_data_from_segment,\n \tBuildListVector(read_data_from_segment.child_functions[0], &linked_child_list, child_vector, starting_offset);\n }\n \n-static void ReadDataFromStructSegment(ReadDataFromSegment &read_data_from_segment, ListSegment *segment, Vector &result,\n-                                      idx_t &total_count) {\n+static void ReadDataFromStructSegment(ReadDataFromSegment &read_data_from_segment, const ListSegment *segment,\n+                                      Vector &result, idx_t &total_count) {\n \n \tauto &aggr_vector_validity = FlatVector::Validity(result);\n \n@@ -474,6 +484,86 @@ static void BuildListVector(ReadDataFromSegment &read_data_from_segment, LinkedL\n \tlinked_list->last_segment = nullptr;\n }\n \n+template <class T>\n+static ListSegment *CopyDataFromPrimitiveSegment(CopyDataFromSegment &, const ListSegment *source, Allocator &allocator,\n+                                                 vector<AllocatedData> &owning_vector) {\n+\n+\tauto target = (ListSegment *)AllocatePrimitiveData<T>(allocator, owning_vector, source->capacity);\n+\tmemcpy(target, source, sizeof(ListSegment) + source->capacity * (sizeof(bool) + sizeof(T)));\n+\ttarget->next = nullptr;\n+\treturn target;\n+}\n+\n+static ListSegment *CopyDataFromListSegment(CopyDataFromSegment &copy_data_from_segment, const ListSegment *source,\n+                                            Allocator &allocator, vector<AllocatedData> &owning_vector) {\n+\n+\t// create an empty linked list for the child vector of target\n+\tauto source_linked_child_list = Load<LinkedList>((data_ptr_t)GetListChildData(source));\n+\n+\t// create the segment\n+\tauto target = (ListSegment *)AllocateListData(allocator, owning_vector, source->capacity);\n+\tmemcpy(target, source,\n+\t       sizeof(ListSegment) + source->capacity * (sizeof(bool) + sizeof(uint64_t)) + sizeof(LinkedList));\n+\ttarget->next = nullptr;\n+\n+\tauto target_linked_list = GetListChildData(target);\n+\tLinkedList linked_list(source_linked_child_list.total_capacity, nullptr, nullptr);\n+\tStore<LinkedList>(linked_list, (data_ptr_t)target_linked_list);\n+\n+\t// recurse to copy the linked child list\n+\tauto target_linked_child_list = Load<LinkedList>((data_ptr_t)GetListChildData(target));\n+\tD_ASSERT(copy_data_from_segment.child_functions.size() == 1);\n+\tCopyLinkedList(copy_data_from_segment.child_functions[0], &source_linked_child_list, target_linked_child_list,\n+\t               allocator, owning_vector);\n+\n+\t// store the updated linked list\n+\tStore<LinkedList>(target_linked_child_list, (data_ptr_t)GetListChildData(target));\n+\treturn target;\n+}\n+\n+static ListSegment *CopyDataFromStructSegment(CopyDataFromSegment &copy_data_from_segment, const ListSegment *source,\n+                                              Allocator &allocator, vector<AllocatedData> &owning_vector) {\n+\n+\tauto source_child_count = copy_data_from_segment.child_functions.size();\n+\tauto target = (ListSegment *)AllocateStructData(allocator, owning_vector, source->capacity, source_child_count);\n+\tmemcpy(target, source,\n+\t       sizeof(ListSegment) + source->capacity * sizeof(bool) + source_child_count * sizeof(ListSegment *));\n+\ttarget->next = nullptr;\n+\n+\t// recurse and copy the children\n+\tauto source_child_segments = GetStructData(source);\n+\tauto target_child_segments = GetStructData(target);\n+\n+\tfor (idx_t i = 0; i < copy_data_from_segment.child_functions.size(); i++) {\n+\t\tauto child_function = copy_data_from_segment.child_functions[i];\n+\t\tauto source_child_segment = Load<ListSegment *>((data_ptr_t)(source_child_segments + i));\n+\t\tauto target_child_segment =\n+\t\t    child_function.segment_function(child_function, source_child_segment, allocator, owning_vector);\n+\t\tStore<ListSegment *>(target_child_segment, (data_ptr_t)(target_child_segments + i));\n+\t}\n+\treturn target;\n+}\n+\n+static void CopyLinkedList(CopyDataFromSegment &copy_data_from_segment, const LinkedList *source_list,\n+                           LinkedList &target_list, Allocator &allocator, vector<AllocatedData> &owning_vector) {\n+\n+\tauto source_segment = source_list->first_segment;\n+\n+\twhile (source_segment) {\n+\t\tauto target_segment =\n+\t\t    copy_data_from_segment.segment_function(copy_data_from_segment, source_segment, allocator, owning_vector);\n+\t\tsource_segment = source_segment->next;\n+\n+\t\tif (!target_list.first_segment) {\n+\t\t\ttarget_list.first_segment = target_segment;\n+\t\t}\n+\t\tif (target_list.last_segment) {\n+\t\t\ttarget_list.last_segment->next = target_segment;\n+\t\t}\n+\t\ttarget_list.last_segment = target_segment;\n+\t}\n+}\n+\n static void InitializeValidities(Vector &vector, idx_t &capacity) {\n \n \tauto &validity_mask = FlatVector::Validity(vector);\n@@ -517,6 +607,7 @@ struct ListBindData : public FunctionData {\n \tLogicalType stype;\n \tWriteDataToSegment write_data_to_segment;\n \tReadDataFromSegment read_data_from_segment;\n+\tCopyDataFromSegment copy_data_from_segment;\n \n \tunique_ptr<FunctionData> Copy() const override {\n \t\treturn make_unique<ListBindData>(stype);\n@@ -529,7 +620,8 @@ struct ListBindData : public FunctionData {\n };\n \n static void GetSegmentDataFunctions(WriteDataToSegment &write_data_to_segment,\n-                                    ReadDataFromSegment &read_data_from_segment, const LogicalType &type) {\n+                                    ReadDataFromSegment &read_data_from_segment,\n+                                    CopyDataFromSegment &copy_data_from_segment, const LogicalType &type) {\n \n \tauto physical_type = type.InternalType();\n \tswitch (physical_type) {\n@@ -538,113 +630,135 @@ static void GetSegmentDataFunctions(WriteDataToSegment &write_data_to_segment,\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<bool>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<bool>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<bool>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<bool>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::INT8: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<int8_t>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<int8_t>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<int8_t>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<int8_t>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::INT16: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<int16_t>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<int16_t>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<int16_t>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<int16_t>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::INT32: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<int32_t>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<int32_t>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<int32_t>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<int32_t>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::INT64: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<int64_t>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<int64_t>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<int64_t>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<int64_t>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::UINT8: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<uint8_t>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<uint8_t>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<uint8_t>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<uint8_t>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::UINT16: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<uint16_t>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<uint16_t>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<uint16_t>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<uint16_t>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::UINT32: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<uint32_t>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<uint32_t>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<uint32_t>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<uint32_t>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::UINT64: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<uint64_t>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<uint64_t>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<uint64_t>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<uint64_t>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::FLOAT: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<float>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<float>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<float>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<float>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::DOUBLE: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<double>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<double>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<double>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<double>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::INT128: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<hugeint_t>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<hugeint_t>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<hugeint_t>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<hugeint_t>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::INTERVAL: {\n \t\twrite_data_to_segment.create_segment = CreatePrimitiveSegment<interval_t>;\n \t\twrite_data_to_segment.segment_function = WriteDataToPrimitiveSegment<interval_t>;\n \t\tread_data_from_segment.segment_function = ReadDataFromPrimitiveSegment<interval_t>;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromPrimitiveSegment<interval_t>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::VARCHAR: {\n \t\twrite_data_to_segment.create_segment = CreateListSegment;\n \t\twrite_data_to_segment.segment_function = WriteDataToVarcharSegment;\n \t\tread_data_from_segment.segment_function = ReadDataFromVarcharSegment;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromListSegment;\n \n \t\twrite_data_to_segment.child_functions.emplace_back(WriteDataToSegment());\n \t\twrite_data_to_segment.child_functions.back().create_segment = CreatePrimitiveSegment<char>;\n+\t\tcopy_data_from_segment.child_functions.emplace_back(CopyDataFromSegment());\n+\t\tcopy_data_from_segment.child_functions.back().segment_function = CopyDataFromPrimitiveSegment<char>;\n \t\tbreak;\n \t}\n \tcase PhysicalType::LIST: {\n \t\twrite_data_to_segment.create_segment = CreateListSegment;\n \t\twrite_data_to_segment.segment_function = WriteDataToListSegment;\n \t\tread_data_from_segment.segment_function = ReadDataFromListSegment;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromListSegment;\n \n \t\t// recurse\n \t\twrite_data_to_segment.child_functions.emplace_back(WriteDataToSegment());\n \t\tread_data_from_segment.child_functions.emplace_back(ReadDataFromSegment());\n+\t\tcopy_data_from_segment.child_functions.emplace_back(CopyDataFromSegment());\n \t\tGetSegmentDataFunctions(write_data_to_segment.child_functions.back(),\n-\t\t                        read_data_from_segment.child_functions.back(), ListType::GetChildType(type));\n+\t\t                        read_data_from_segment.child_functions.back(),\n+\t\t                        copy_data_from_segment.child_functions.back(), ListType::GetChildType(type));\n \t\tbreak;\n \t}\n \tcase PhysicalType::STRUCT: {\n \t\twrite_data_to_segment.create_segment = CreateStructSegment;\n \t\twrite_data_to_segment.segment_function = WriteDataToStructSegment;\n \t\tread_data_from_segment.segment_function = ReadDataFromStructSegment;\n+\t\tcopy_data_from_segment.segment_function = CopyDataFromStructSegment;\n \n \t\t// recurse\n \t\tauto child_types = StructType::GetChildTypes(type);\n \t\tfor (idx_t i = 0; i < child_types.size(); i++) {\n \t\t\twrite_data_to_segment.child_functions.emplace_back(WriteDataToSegment());\n \t\t\tread_data_from_segment.child_functions.emplace_back(ReadDataFromSegment());\n+\t\t\tcopy_data_from_segment.child_functions.emplace_back(CopyDataFromSegment());\n \t\t\tGetSegmentDataFunctions(write_data_to_segment.child_functions.back(),\n-\t\t\t                        read_data_from_segment.child_functions.back(), child_types[i].second);\n+\t\t\t                        read_data_from_segment.child_functions.back(),\n+\t\t\t                        copy_data_from_segment.child_functions.back(), child_types[i].second);\n \t\t}\n \t\tbreak;\n \t}\n@@ -657,7 +771,7 @@ ListBindData::ListBindData(const LogicalType &stype_p) : stype(stype_p) {\n \n \t// always unnest once because the result vector is of type LIST\n \tauto type = ListType::GetChildType(stype_p);\n-\tGetSegmentDataFunctions(write_data_to_segment, read_data_from_segment, type);\n+\tGetSegmentDataFunctions(write_data_to_segment, read_data_from_segment, copy_data_from_segment, type);\n }\n \n ListBindData::~ListBindData() {\n@@ -725,11 +839,13 @@ static void ListUpdateFunction(Vector inputs[], AggregateInputData &aggr_input_d\n \t}\n }\n \n-static void ListCombineFunction(Vector &state, Vector &combined, AggregateInputData &, idx_t count) {\n+static void ListCombineFunction(Vector &state, Vector &combined, AggregateInputData &aggr_input_data, idx_t count) {\n \tUnifiedVectorFormat sdata;\n \tstate.ToUnifiedFormat(count, sdata);\n \tauto states_ptr = (ListAggState **)sdata.data;\n \n+\tauto &list_bind_data = (ListBindData &)*aggr_input_data.bind_data;\n+\n \tauto combined_ptr = FlatVector::GetData<ListAggState *>(combined);\n \tfor (idx_t i = 0; i < count; i++) {\n \t\tauto state = states_ptr[sdata.sel->get_index(i)];\n@@ -739,32 +855,27 @@ static void ListCombineFunction(Vector &state, Vector &combined, AggregateInputD\n \t\t}\n \t\tD_ASSERT(state->type);\n \t\tD_ASSERT(state->owning_vector);\n-\t\tif (!combined_ptr[i]->linked_list) {\n \n-\t\t\t// copy the linked list\n+\t\tif (!combined_ptr[i]->linked_list) {\n \t\t\tcombined_ptr[i]->linked_list = new LinkedList(0, nullptr, nullptr);\n-\t\t\tcombined_ptr[i]->linked_list->first_segment = state->linked_list->first_segment;\n-\t\t\tcombined_ptr[i]->linked_list->last_segment = state->linked_list->last_segment;\n-\t\t\tcombined_ptr[i]->linked_list->total_capacity = state->linked_list->total_capacity;\n-\n-\t\t\t// copy the type\n+\t\t\tcombined_ptr[i]->owning_vector = new vector<AllocatedData>;\n \t\t\tcombined_ptr[i]->type = new LogicalType(*state->type);\n+\t\t}\n+\t\tauto owning_vector = combined_ptr[i]->owning_vector;\n \n-\t\t\t// new owning_vector to hold the unique pointers\n-\t\t\tcombined_ptr[i]->owning_vector = new vector<AllocatedData>;\n+\t\t// copy the linked list of the state\n+\t\tauto copied_linked_list = LinkedList(state->linked_list->total_capacity, nullptr, nullptr);\n+\t\tCopyLinkedList(list_bind_data.copy_data_from_segment, state->linked_list, copied_linked_list,\n+\t\t               aggr_input_data.allocator, *owning_vector);\n \n+\t\t// append the copied linked list to the combined state\n+\t\tif (combined_ptr[i]->linked_list->last_segment) {\n+\t\t\tcombined_ptr[i]->linked_list->last_segment->next = copied_linked_list.first_segment;\n \t\t} else {\n-\t\t\tcombined_ptr[i]->linked_list->last_segment->next = state->linked_list->first_segment;\n-\t\t\tcombined_ptr[i]->linked_list->last_segment = state->linked_list->last_segment;\n-\t\t\tcombined_ptr[i]->linked_list->total_capacity += state->linked_list->total_capacity;\n-\t\t}\n-\n-\t\t// copy the owning vector (and its unique pointers to the allocated data)\n-\t\t// FIXME: more efficient way of copying the unique pointers?\n-\t\tauto &owning_vector = *state->owning_vector;\n-\t\tfor (idx_t j = 0; j < state->owning_vector->size(); j++) {\n-\t\t\tcombined_ptr[i]->owning_vector->push_back(move(owning_vector[j]));\n+\t\t\tcombined_ptr[i]->linked_list->first_segment = copied_linked_list.first_segment;\n \t\t}\n+\t\tcombined_ptr[i]->linked_list->last_segment = copied_linked_list.last_segment;\n+\t\tcombined_ptr[i]->linked_list->total_capacity += copied_linked_list.total_capacity;\n \t}\n }\n \ndiff --git a/src/include/duckdb/common/allocator.hpp b/src/include/duckdb/common/allocator.hpp\nindex d55467900677..05d59f25d252 100644\n--- a/src/include/duckdb/common/allocator.hpp\n+++ b/src/include/duckdb/common/allocator.hpp\n@@ -118,7 +118,7 @@ void DeleteArray(T *ptr, idx_t size) {\n }\n \n template <typename T, typename... ARGS>\n-T *AllocateObject(ARGS &&... args) {\n+T *AllocateObject(ARGS &&...args) {\n \tauto data = Allocator::DefaultAllocator().AllocateData(sizeof(T));\n \treturn new (data) T(std::forward<ARGS>(args)...);\n }\ndiff --git a/src/include/duckdb/common/field_writer.hpp b/src/include/duckdb/common/field_writer.hpp\nindex 8c7b41e64638..e603ff119bb5 100644\n--- a/src/include/duckdb/common/field_writer.hpp\n+++ b/src/include/duckdb/common/field_writer.hpp\n@@ -256,7 +256,7 @@ class FieldReader {\n \t}\n \n \ttemplate <class T, typename... ARGS>\n-\tunique_ptr<T> ReadOptional(unique_ptr<T> default_value, ARGS &&... args) {\n+\tunique_ptr<T> ReadOptional(unique_ptr<T> default_value, ARGS &&...args) {\n \t\tif (field_count >= max_field_count) {\n \t\t\t// field is not there, read the default value\n \t\t\treturn default_value;\n@@ -278,7 +278,7 @@ class FieldReader {\n \t}\n \n \ttemplate <class T, class RETURN_TYPE = unique_ptr<T>, typename... ARGS>\n-\tRETURN_TYPE ReadSerializable(RETURN_TYPE default_value, ARGS &&... args) {\n+\tRETURN_TYPE ReadSerializable(RETURN_TYPE default_value, ARGS &&...args) {\n \t\tif (field_count >= max_field_count) {\n \t\t\t// field is not there, read the default value\n \t\t\treturn default_value;\n@@ -300,7 +300,7 @@ class FieldReader {\n \t}\n \n \ttemplate <class T, class RETURN_TYPE = unique_ptr<T>, typename... ARGS>\n-\tRETURN_TYPE ReadRequiredSerializable(ARGS &&... args) {\n+\tRETURN_TYPE ReadRequiredSerializable(ARGS &&...args) {\n \t\tif (field_count >= max_field_count) {\n \t\t\t// field is not there, throw an exception\n \t\t\tthrow SerializationException(\"Attempting to read mandatory field, but field is missing\");\n@@ -311,7 +311,7 @@ class FieldReader {\n \t}\n \n \ttemplate <class T, class RETURN_TYPE = unique_ptr<T>, typename... ARGS>\n-\tvector<RETURN_TYPE> ReadRequiredSerializableList(ARGS &&... args) {\n+\tvector<RETURN_TYPE> ReadRequiredSerializableList(ARGS &&...args) {\n \t\tif (field_count >= max_field_count) {\n \t\t\t// field is not there, throw an exception\n \t\t\tthrow SerializationException(\"Attempting to read mandatory field, but field is missing\");\ndiff --git a/src/include/duckdb/common/serializer.hpp b/src/include/duckdb/common/serializer.hpp\nindex f3589da90650..549a452c9f31 100644\n--- a/src/include/duckdb/common/serializer.hpp\n+++ b/src/include/duckdb/common/serializer.hpp\n@@ -119,7 +119,7 @@ class Deserializer {\n \t}\n \n \ttemplate <class T, typename... ARGS>\n-\tvoid ReadList(vector<unique_ptr<T>> &list, ARGS &&... args) {\n+\tvoid ReadList(vector<unique_ptr<T>> &list, ARGS &&...args) {\n \t\tauto select_count = Read<uint32_t>();\n \t\tfor (uint32_t i = 0; i < select_count; i++) {\n \t\t\tauto child = T::Deserialize(*this, std::forward<ARGS>(args)...);\n@@ -128,7 +128,7 @@ class Deserializer {\n \t}\n \n \ttemplate <class T, class RETURN_TYPE = T, typename... ARGS>\n-\tunique_ptr<RETURN_TYPE> ReadOptional(ARGS &&... args) {\n+\tunique_ptr<RETURN_TYPE> ReadOptional(ARGS &&...args) {\n \t\tauto has_entry = Read<bool>();\n \t\tif (has_entry) {\n \t\t\treturn T::Deserialize(*this, std::forward<ARGS>(args)...);\ndiff --git a/tools/rpkg/src/relational.cpp b/tools/rpkg/src/relational.cpp\nindex 8529ae798e20..00b7af598c71 100644\n--- a/tools/rpkg/src/relational.cpp\n+++ b/tools/rpkg/src/relational.cpp\n@@ -26,7 +26,7 @@ using namespace duckdb;\n using namespace cpp11;\n \n template <typename T, typename... Args>\n-external_pointer<T> make_external(const string &rclass, Args &&... args) {\n+external_pointer<T> make_external(const string &rclass, Args &&...args) {\n \tauto extptr = external_pointer<T>(new T(std::forward<Args>(args)...));\n \t((sexp)extptr).attr(\"class\") = rclass;\n \treturn (extptr);\n",
  "test_patch": "diff --git a/test/sql/aggregate/aggregates/test_list_aggregate_function.test b/test/sql/aggregate/aggregates/test_list_aggregate_function.test\nindex 5a3445c6e25a..72581ffb9861 100644\n--- a/test/sql/aggregate/aggregates/test_list_aggregate_function.test\n+++ b/test/sql/aggregate/aggregates/test_list_aggregate_function.test\n@@ -197,4 +197,8 @@ SELECT g, list_count(LIST(i)) FROM long_str GROUP BY g ORDER BY g\n 0\t3\n 1\t3\n 2\t2\n-3\t2\n\\ No newline at end of file\n+3\t2\n+\n+# fix issue 5523\n+statement ok\n+SELECT LIST(i) OVER (PARTITION BY i % 10 ORDER BY i) FROM range(10000) t(i);\n",
  "problem_statement": "list() aggregate function segfaults when used as a window function\n### What happens?\n\nA segfault occurs when using the list() aggregate function as a window function on a Parquet file I have:\r\n\r\n```\r\n\u276f duckdb                                                     \r\nv0.6.0 2213f9c946\r\nEnter \".help\" for usage hints.\r\nConnected to a transient in-memory database.\r\nUse \".open FILENAME\" to reopen on a persistent database.\r\nD install parquet;\r\nD load parquet;\r\nD SELECT user_id, list(event_name) OVER (PARTITION BY user_id ORDER BY event_timestamp ASC) FROM 'github-sample.parquet';\r\nduckdb(80879,0x16f5db000) malloc: Incorrect checksum for freed object 0x131819200: probably modified after being freed.\r\nCorrupt value: 0x6873755000000009\r\nduckdb(80879,0x16f5db000) malloc: *** set a breakpoint in malloc_error_break to debug\r\nzsh: abort      duckdb\r\n```\r\n\r\nThe issue does not occur when using `list()` in a GROUP BY context. Only in a window context. I have tried other window functions on this data, and they work -- including `string_agg()` and `row_number()`.\r\n\r\nThis seems to be limited to `list()` being used as a window function.\n\n### To Reproduce\n\n`SELECT user_id, list(event_name) OVER (PARTITION BY user_id ORDER BY event_timestamp ASC) FROM 'github-sample.parquet';`\r\n\r\nThe sample data (14 MB) is available in this repository with a README that shares how to reproduce it: https://github.com/voberoi/duckdb-window-function-segfault\n\n### OS:\n\nMac OS -- M1 arm64\n\n### DuckDB Version:\n\n0.6.0 (also reproducible with 0.5.1)\n\n### DuckDB Client:\n\nDuckDB shell\n\n### Full Name:\n\nVikram Oberoi\n\n### Affiliation:\n\nNo affiliation\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2022-11-30T15:24:03Z"
}