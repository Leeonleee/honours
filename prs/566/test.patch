diff --git a/scripts/test_compile.py b/scripts/test_compile.py
new file mode 100644
index 000000000000..786c4361eb57
--- /dev/null
+++ b/scripts/test_compile.py
@@ -0,0 +1,53 @@
+import os, sys, amalgamation, pickle
+
+# where to cache which files have already been compiled, only used for --compile --resume
+cache_file = 'amalgamation.cache'
+
+resume = False
+
+for arg in sys.argv:
+	if arg == '--resume':
+		resume = True
+
+if not resume:
+	try:
+		os.remove(cache_file)
+	except:
+		pass
+
+def try_compilation(fpath, cache):
+	if fpath in cache:
+		return
+	print(fpath)
+
+	cmd = 'clang++ -std=c++11 -Wno-deprecated -Wno-writable-strings -S -MMD -MF dependencies.d -o deps.s ' + fpath + ' ' + ' '.join(["-I" + x for x in amalgamation.include_paths])
+	ret = os.system(cmd)
+	if ret != 0:
+		raise Exception('Failed compilation of file "' + fpath + '"!
 Command: ' + cmd)
+	cache[fpath] = True
+	with open(cache_file, 'wb') as cf:
+		pickle.dump(cache, cf)
+
+def compile_dir(dir, cache):
+	files = os.listdir(dir)
+	files.sort()
+	for fname in files:
+		if fname in amalgamation.excluded_compilation_files:
+			continue
+		fpath = os.path.join(dir, fname)
+		if os.path.isdir(fpath):
+			compile_dir(fpath, cache)
+		elif fname.endswith('.cpp') or fname.endswith('.hpp') or fname.endswith('.c') or fname.endswith('.cc'):
+			try_compilation(fpath, cache)
+
+# compilation pass only
+# compile all files in the src directory (including headers!) individually
+try:
+	with open(cache_file, 'rb') as cf:
+		cache = pickle.load(cf)
+except:
+	cache = {}
+
+for cdir in amalgamation.compile_directories:
+	compile_dir(cdir, cache)
+
diff --git a/test/sql/storage/CMakeLists.txt b/test/sql/storage/CMakeLists.txt
index 15d275b59950..39190f6bff2b 100644
--- a/test/sql/storage/CMakeLists.txt
+++ b/test/sql/storage/CMakeLists.txt
@@ -14,6 +14,7 @@ if(NOT WIN32 AND NOT SUN)
                     test_store_alter.cpp
                     test_views.cpp
                     test_readonly.cpp
+                    test_repeated_checkpoint.cpp
                     test_storage_tpch.cpp
                     test_storage_scan.cpp
                     test_database_size.cpp)
@@ -27,6 +28,7 @@ else()
                     test_storage_sequences.cpp
                     test_shutdown.cpp
                     test_big_storage.cpp
+                    test_repeated_checkpoint.cpp
                     test_storage.cpp
                     test_storage_defaults.cpp
                     test_store_alter.cpp
diff --git a/test/sql/storage/test_repeated_checkpoint.cpp b/test/sql/storage/test_repeated_checkpoint.cpp
new file mode 100644
index 000000000000..487b4fdc8a36
--- /dev/null
+++ b/test/sql/storage/test_repeated_checkpoint.cpp
@@ -0,0 +1,65 @@
+#include "catch.hpp"
+#include "duckdb/common/file_system.hpp"
+#include "test_helpers.hpp"
+#include "duckdb/storage/storage_info.hpp"
+
+#include <fstream>
+
+using namespace duckdb;
+using namespace std;
+
+TEST_CASE("Test repeated load and checkpoint of storage", "[storage][.]") {
+	unique_ptr<MaterializedQueryResult> result;
+	auto storage_database = TestCreatePath("repeated_load");
+	auto csv_file = TestCreatePath("rload.csv");
+	auto config = GetTestConfig();
+
+	vector<string> model { "M11", "F22", "U33" };
+	vector<string> shop { "www.goodshop.com", "www.badshop.com" };
+	vector<string> name { "Electronics  Something  One", "Electronics  Something  Two", "Electronics  Something  Three", "Electronics  Something  Four", "Electronics  Something  Five", "Electronics  Something  Six", "Electronics  Something  Seven", "Electronics  Something  Eight", "Electronics  Something  Nine", "Electronics  Something  Ten"};
+	vector<string> brand { "AAAAA", "BBBBB", "CCCC", "DDDDDD", "PPPP" };
+	vector<string> color { "violet", "indigo", "blue", "green", "yellow", "orange", "red" };
+	idx_t row_count = 1000;
+
+	DeleteDatabase(storage_database);
+	for(idx_t counter = 0; counter < 100; counter++) {
+		DuckDB db(storage_database);
+		Connection con(db);
+
+		if (counter > 0) {
+			result = con.Query("SELECT COUNT(*) FROM pdata");
+			REQUIRE(CHECK_COLUMN(result, 0, {Value::BIGINT(counter * row_count)}));
+		}
+		// generate the csv file
+		ofstream csv_writer(csv_file);
+		for(idx_t i = 0; i < row_count; i++) {
+			idx_t z = i + counter;
+			idx_t record_id = i + (row_count * counter);
+			csv_writer << record_id << "|";
+			csv_writer << i % 99 << "|";
+			csv_writer << shop[z % 2] << "|";
+			csv_writer << "electronics" << "|";
+			csv_writer << name[z % 10] << "|";
+			csv_writer << brand[z % 5] << "|";
+			csv_writer << color[z % 7] << "|";
+			csv_writer << model[z % 3] << "|";
+			csv_writer << "
";
+		}
+		csv_writer.close();
+		// create and load the table
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE IF NOT EXISTS pdata (record_id BIGINT PRIMARY KEY , price DOUBLE, shop VARCHAR, category VARCHAR, name VARCHAR, brand VARCHAR, color VARCHAR, model VARCHAR);"));
+		REQUIRE_NO_FAIL(con.Query("COPY pdata(record_id,price,shop,category,name,brand,color,model) FROM '" + csv_file + "' ( DELIMITER '|' );"));
+		result = con.Query("SELECT MIN(record_id), MIN(price), MIN(shop), MIN(category), MIN(name), MIN(brand), MIN(color), MIN(model) FROM pdata");
+		REQUIRE(CHECK_COLUMN(result, 0, {0}));
+		REQUIRE(CHECK_COLUMN(result, 1, {0}));
+		REQUIRE(CHECK_COLUMN(result, 2, {"www.badshop.com"}));
+		REQUIRE(CHECK_COLUMN(result, 3, {"electronics"}));
+		REQUIRE(CHECK_COLUMN(result, 4, {"Electronics  Something  Eight"}));
+		REQUIRE(CHECK_COLUMN(result, 5, {"AAAAA"}));
+		REQUIRE(CHECK_COLUMN(result, 6, {"blue"}));
+		REQUIRE(CHECK_COLUMN(result, 7, {"F22"}));
+
+		result = con.Query("SELECT COUNT(*) FROM pdata");
+		REQUIRE(CHECK_COLUMN(result, 0, {Value::BIGINT((counter + 1) * row_count)}));
+	}
+}
