{
  "repo": "duckdb/duckdb",
  "pull_number": 8153,
  "instance_id": "duckdb__duckdb-8153",
  "issue_numbers": [
    "7384"
  ],
  "base_commit": "f586db1b82fd73d0327092fb60d8d11df26d99c4",
  "patch": "diff --git a/extension/fts/fts_extension.cpp b/extension/fts/fts_extension.cpp\nindex cbbb86ccd783..1fd67be51dfc 100644\n--- a/extension/fts/fts_extension.cpp\n+++ b/extension/fts/fts_extension.cpp\n@@ -1,18 +1,18 @@\n #define DUCKDB_EXTENSION_MAIN\n #include \"fts_extension.hpp\"\n-#include \"fts_indexing.hpp\"\n-#include \"libstemmer.h\"\n \n #include \"duckdb.hpp\"\n #include \"duckdb/common/exception.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n-#include \"duckdb/function/scalar_function.hpp\"\n #include \"duckdb/function/pragma_function.hpp\"\n+#include \"duckdb/function/scalar_function.hpp\"\n #include \"duckdb/main/extension_util.hpp\"\n+#include \"fts_indexing.hpp\"\n+#include \"libstemmer.h\"\n \n namespace duckdb {\n \n-static void stem_function(DataChunk &args, ExpressionState &state, Vector &result) {\n+static void StemFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tauto &input_vector = args.data[0];\n \tauto &stemmer_vector = args.data[1];\n \n@@ -36,7 +36,8 @@ static void stem_function(DataChunk &args, ExpressionState &state, Vector &resul\n \t\t\t        StringUtil::Join(stemmers, n_stemmers, \"', '\", [](const char *st) { return st; })));\n \t\t    }\n \n-\t\t    auto output_data = (char *)sb_stemmer_stem(s, (const sb_symbol *)input_data, input_size);\n+\t\t    auto output_data =\n+\t\t        const_char_ptr_cast(sb_stemmer_stem(s, reinterpret_cast<const sb_symbol *>(input_data), input_size));\n \t\t    auto output_size = sb_stemmer_length(s);\n \t\t    auto output = StringVector::AddString(result, output_data, output_size);\n \n@@ -47,10 +48,11 @@ static void stem_function(DataChunk &args, ExpressionState &state, Vector &resul\n \n void FtsExtension::Load(DuckDB &db) {\n \tauto &db_instance = *db.instance;\n-\tScalarFunction stem_func(\"stem\", {LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::VARCHAR, stem_function);\n+\tScalarFunction stem_func(\"stem\", {LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::VARCHAR, StemFunction);\n \n-\tauto create_fts_index_func = PragmaFunction::PragmaCall(\n-\t    \"create_fts_index\", create_fts_index_query, {LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::VARCHAR);\n+\tauto create_fts_index_func =\n+\t    PragmaFunction::PragmaCall(\"create_fts_index\", FTSIndexing::CreateFTSIndexQuery,\n+\t                               {LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::VARCHAR);\n \tcreate_fts_index_func.named_parameters[\"stemmer\"] = LogicalType::VARCHAR;\n \tcreate_fts_index_func.named_parameters[\"stopwords\"] = LogicalType::VARCHAR;\n \tcreate_fts_index_func.named_parameters[\"ignore\"] = LogicalType::VARCHAR;\n@@ -59,7 +61,7 @@ void FtsExtension::Load(DuckDB &db) {\n \tcreate_fts_index_func.named_parameters[\"overwrite\"] = LogicalType::BOOLEAN;\n \n \tauto drop_fts_index_func =\n-\t    PragmaFunction::PragmaCall(\"drop_fts_index\", drop_fts_index_query, {LogicalType::VARCHAR});\n+\t    PragmaFunction::PragmaCall(\"drop_fts_index\", FTSIndexing::DropFTSIndexQuery, {LogicalType::VARCHAR});\n \n \tExtensionUtil::RegisterFunction(db_instance, stem_func);\n \tExtensionUtil::RegisterFunction(db_instance, create_fts_index_func);\ndiff --git a/extension/fts/fts_indexing.cpp b/extension/fts/fts_indexing.cpp\nindex fa073f9f8b81..71f971ff3f71 100644\n--- a/extension/fts/fts_indexing.cpp\n+++ b/extension/fts/fts_indexing.cpp\n@@ -1,38 +1,45 @@\n #include \"fts_indexing.hpp\"\n \n-#include \"duckdb/main/connection.hpp\"\n #include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n #include \"duckdb/catalog/catalog_search_path.hpp\"\n #include \"duckdb/common/exception.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n-#include \"duckdb/parser/qualified_name.hpp\"\n #include \"duckdb/main/client_data.hpp\"\n+#include \"duckdb/main/connection.hpp\"\n+#include \"duckdb/parser/qualified_name.hpp\"\n \n namespace duckdb {\n \n-static string fts_schema_name(const string &schema, const string &table) {\n-\treturn \"fts_\" + schema + \"_\" + table;\n-}\n-\n-string drop_fts_index_query(ClientContext &context, const FunctionParameters &parameters) {\n-\tauto qname = QualifiedName::Parse(StringValue::Get(parameters.values[0]));\n+static QualifiedName GetQualifiedName(ClientContext &context, const string &qname_str) {\n+\tauto qname = QualifiedName::Parse(qname_str);\n \tif (qname.schema == INVALID_SCHEMA) {\n-\t\tqname.schema = ClientData::Get(context).catalog_search_path->GetDefaultSchema(INVALID_CATALOG);\n+\t\tqname.schema = ClientData::Get(context).catalog_search_path->GetDefaultSchema(qname.catalog);\n \t}\n-\tstring fts_schema = fts_schema_name(qname.schema, qname.name);\n+\treturn qname;\n+}\n+\n+static string GetFTSSchema(QualifiedName &qname) {\n+\tauto result = qname.catalog == INVALID_CATALOG ? \"\" : StringUtil::Format(\"%s.\", qname.catalog);\n+\tresult += StringUtil::Format(\"fts_%s_%s\", qname.schema, qname.name);\n+\treturn result;\n+}\n \n-\tif (!Catalog::GetSchema(context, INVALID_CATALOG, fts_schema, OnEntryNotFound::RETURN_NULL)) {\n+string FTSIndexing::DropFTSIndexQuery(ClientContext &context, const FunctionParameters &parameters) {\n+\tauto qname = GetQualifiedName(context, StringValue::Get(parameters.values[0]));\n+\tstring fts_schema = GetFTSSchema(qname);\n+\n+\tif (!Catalog::GetSchema(context, qname.catalog, fts_schema, OnEntryNotFound::RETURN_NULL)) {\n \t\tthrow CatalogException(\n \t\t    \"a FTS index does not exist on table '%s.%s'. Create one with 'PRAGMA create_fts_index()'.\", qname.schema,\n \t\t    qname.name);\n \t}\n \n-\treturn \"DROP SCHEMA \" + fts_schema + \" CASCADE;\";\n+\treturn StringUtil::Format(\"DROP SCHEMA %s CASCADE;\", fts_schema);\n }\n \n-static string indexing_script(const string &input_schema, const string &input_table, const string &input_id,\n-                              const vector<string> &input_values, const string &stemmer, const string &stopwords,\n-                              const string &ignore, bool strip_accents, bool lower) {\n+static string IndexingScript(ClientContext &context, QualifiedName &qname, const string &input_id,\n+                             const vector<string> &input_values, const string &stemmer, const string &stopwords,\n+                             const string &ignore, bool strip_accents, bool lower) {\n \t// clang-format off\n     string result = R\"(\n         DROP SCHEMA IF EXISTS %fts_schema% CASCADE;\n@@ -76,7 +83,7 @@ static string indexing_script(const string &input_schema, const string &input_ta\n         CREATE TABLE %fts_schema%.docs AS (\n             SELECT rowid AS docid,\n                    \"%input_id%\" AS name\n-            FROM %input_schema%.%input_table%\n+            FROM %input_table%\n         );\n \n \t    CREATE TABLE %fts_schema%.fields (fieldid BIGINT, field VARCHAR);\n@@ -208,7 +215,7 @@ static string indexing_script(const string &input_schema, const string &input_ta\n         SELECT unnest(%fts_schema%.tokenize(fts_ii.\"%input_value%\")) AS w,\n \t           rowid AS docid,\n \t           (SELECT fieldid FROM %fts_schema%.fields WHERE field = '%input_value%') AS fieldid\n-        FROM %input_schema%.%input_table% AS fts_ii\n+        FROM %input_table% AS fts_ii\n     )\";\n \t// clang-format on\n \tvector<string> field_values;\n@@ -220,11 +227,12 @@ static string indexing_script(const string &input_schema, const string &input_ta\n \tresult = StringUtil::Replace(result, \"%field_values%\", StringUtil::Join(field_values, \", \"));\n \tresult = StringUtil::Replace(result, \"%union_fields_query%\", StringUtil::Join(tokenize_fields, \" UNION ALL \"));\n \n-\tstring fts_schema = fts_schema_name(input_schema, input_table);\n+\tstring fts_schema = GetFTSSchema(qname);\n+\tstring input_table = qname.catalog == INVALID_CATALOG ? \"\" : StringUtil::Format(\"%s.\", qname.catalog);\n+\tinput_table += StringUtil::Format(\"%s.%s\", qname.schema, qname.name);\n \n \t// fill in variables (inefficiently, but keeps SQL script readable)\n \tresult = StringUtil::Replace(result, \"%fts_schema%\", fts_schema);\n-\tresult = StringUtil::Replace(result, \"%input_schema%\", input_schema);\n \tresult = StringUtil::Replace(result, \"%input_table%\", input_table);\n \tresult = StringUtil::Replace(result, \"%input_id%\", input_id);\n \tresult = StringUtil::Replace(result, \"%stemmer%\", stemmer);\n@@ -232,17 +240,13 @@ static string indexing_script(const string &input_schema, const string &input_ta\n \treturn result;\n }\n \n-void check_exists(ClientContext &context, QualifiedName &qname) {\n-\tCatalog::GetEntry<TableCatalogEntry>(context, INVALID_CATALOG, qname.schema, qname.name);\n+static void CheckIfTableExists(ClientContext &context, QualifiedName &qname) {\n+\tCatalog::GetEntry<TableCatalogEntry>(context, qname.catalog, qname.schema, qname.name);\n }\n \n-string create_fts_index_query(ClientContext &context, const FunctionParameters &parameters) {\n-\tauto qname = QualifiedName::Parse(StringValue::Get(parameters.values[0]));\n-\tif (qname.schema == INVALID_SCHEMA) {\n-\t\tqname.schema = ClientData::Get(context).catalog_search_path->GetDefaultSchema(INVALID_CATALOG);\n-\t}\n-\tcheck_exists(context, qname);\n-\tstring fts_schema = fts_schema_name(qname.schema, qname.name);\n+string FTSIndexing::CreateFTSIndexQuery(ClientContext &context, const FunctionParameters &parameters) {\n+\tauto qname = GetQualifiedName(context, StringValue::Get(parameters.values[0]));\n+\tCheckIfTableExists(context, qname);\n \n \t// get named parameters\n \tstring stemmer = \"porter\";\n@@ -250,34 +254,35 @@ string create_fts_index_query(ClientContext &context, const FunctionParameters &\n \tif (stemmer_entry != parameters.named_parameters.end()) {\n \t\tstemmer = StringValue::Get(stemmer_entry->second);\n \t}\n-\tstring stopwords = \"english\";\n \n+\tstring stopwords = \"english\";\n \tauto stopword_entry = parameters.named_parameters.find(\"stopwords\");\n \tif (stopword_entry != parameters.named_parameters.end()) {\n \t\tstopwords = StringValue::Get(stopword_entry->second);\n \t\tif (stopwords != \"english\" && stopwords != \"none\") {\n-\t\t\tauto stopwords_qname = QualifiedName::Parse(stopwords);\n-\t\t\tif (qname.schema == INVALID_SCHEMA) {\n-\t\t\t\tqname.schema = ClientData::Get(context).catalog_search_path->GetDefaultSchema(INVALID_CATALOG);\n-\t\t\t}\n-\t\t\tcheck_exists(context, stopwords_qname);\n+\t\t\tauto stopwords_qname = GetQualifiedName(context, stopwords);\n+\t\t\tCheckIfTableExists(context, stopwords_qname);\n \t\t}\n \t}\n+\n \tstring ignore = \"(\\\\\\\\.|[^a-z])+\";\n \tauto ignore_entry = parameters.named_parameters.find(\"ignore\");\n \tif (ignore_entry != parameters.named_parameters.end()) {\n \t\tignore = StringValue::Get(ignore_entry->second);\n \t}\n+\n \tbool strip_accents = true;\n \tauto strip_accents_entry = parameters.named_parameters.find(\"strip_accents\");\n \tif (strip_accents_entry != parameters.named_parameters.end()) {\n \t\tstrip_accents = BooleanValue::Get(strip_accents_entry->second);\n \t}\n+\n \tbool lower = true;\n \tauto lower_entry = parameters.named_parameters.find(\"lower\");\n \tif (lower_entry != parameters.named_parameters.end()) {\n \t\tlower = BooleanValue::Get(lower_entry->second);\n \t}\n+\n \tbool overwrite = false;\n \tauto overwrite_entry = parameters.named_parameters.find(\"overwrite\");\n \tif (overwrite_entry != parameters.named_parameters.end()) {\n@@ -285,7 +290,8 @@ string create_fts_index_query(ClientContext &context, const FunctionParameters &\n \t}\n \n \t// throw error if an index already exists on this table\n-\tif (Catalog::GetSchema(context, INVALID_CATALOG, fts_schema, OnEntryNotFound::RETURN_NULL) && !overwrite) {\n+\tconst string fts_schema = GetFTSSchema(qname);\n+\tif (Catalog::GetSchema(context, qname.catalog, fts_schema, OnEntryNotFound::RETURN_NULL) && !overwrite) {\n \t\tthrow CatalogException(\"a FTS index already exists on table '%s.%s'. Supply 'overwrite=1' to overwrite, or \"\n \t\t                       \"drop the existing index with 'PRAGMA drop_fts_index()' before creating a new one.\",\n \t\t                       qname.schema, qname.name);\n@@ -294,7 +300,7 @@ string create_fts_index_query(ClientContext &context, const FunctionParameters &\n \t// positional parameters\n \tauto doc_id = StringValue::Get(parameters.values[1]);\n \t// check all specified columns\n-\tauto &table = Catalog::GetEntry<TableCatalogEntry>(context, INVALID_CATALOG, qname.schema, qname.name);\n+\tauto &table = Catalog::GetEntry<TableCatalogEntry>(context, qname.catalog, qname.schema, qname.name);\n \tvector<string> doc_values;\n \tfor (idx_t i = 2; i < parameters.values.size(); i++) {\n \t\tstring col_name = StringValue::Get(parameters.values[i]);\n@@ -319,8 +325,7 @@ string create_fts_index_query(ClientContext &context, const FunctionParameters &\n \t\tthrow Exception(\"at least one column must be supplied for indexing!\");\n \t}\n \n-\treturn indexing_script(qname.schema, qname.name, doc_id, doc_values, stemmer, stopwords, ignore, strip_accents,\n-\t                       lower);\n+\treturn IndexingScript(context, qname, doc_id, doc_values, stemmer, stopwords, ignore, strip_accents, lower);\n }\n \n } // namespace duckdb\ndiff --git a/extension/fts/include/fts_indexing.hpp b/extension/fts/include/fts_indexing.hpp\nindex b7949563346b..40f67e262c16 100644\n--- a/extension/fts/include/fts_indexing.hpp\n+++ b/extension/fts/include/fts_indexing.hpp\n@@ -12,7 +12,9 @@\n \n namespace duckdb {\n \n-string drop_fts_index_query(ClientContext &context, const FunctionParameters &parameters);\n-string create_fts_index_query(ClientContext &context, const FunctionParameters &parameters);\n+struct FTSIndexing {\n+\tstatic string DropFTSIndexQuery(ClientContext &context, const FunctionParameters &parameters);\n+\tstatic string CreateFTSIndexQuery(ClientContext &context, const FunctionParameters &parameters);\n+};\n \n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/fts/test_fts_attach.test b/test/sql/fts/test_fts_attach.test\nnew file mode 100644\nindex 000000000000..7c4c5c2820ac\n--- /dev/null\n+++ b/test/sql/fts/test_fts_attach.test\n@@ -0,0 +1,21 @@\n+# name: test/sql/fts/test_fts_attach.test\n+# description: Test FTS and attach\n+# group: [fts]\n+\n+# issue #7384 and #8141\n+\n+require fts\n+\n+require skip_reload\n+\n+statement ok\n+ATTACH '__TEST_DIR__/tester.db' as search_con\n+\n+statement ok\n+CREATE TABLE search_con.main.my_table AS SELECT 1 AS CustomerId, 'hans' as CustomerName\n+\n+statement ok\n+PRAGMA create_fts_index(search_con.main.my_table, 'CustomerId', 'CustomerName')\n+\n+statement ok\n+SELECT search_con.fts_main_my_table.match_bm25(1, 'han')\n",
  "problem_statement": "FTS and ATTACH cause errors\n### What happens?\n\nI have a duckdb file with a table containing a fulltext index. The FTS is on table `myexpo_customer`\r\n\r\nI attach that file using something like this:\r\n`ATTACH 'filename' as search_con`\r\n\r\nThen I try to query using:\r\n`SELECT search_con.fts_main_myexpo_customer.match_bm25(__search_id, 'something') AS __score, CustomerId FROM search_con.myexpo_customer WHERE __score IS NOT NULL`\r\n\r\nWhich gives me this error: \r\n`Catalog Error: Table with name terms does not exist!\\nDid you mean \\\"search_con.fts_main_myexpo_customer.terms\\\"?`\r\n\r\nSeems like the FTS extension searches for the table in the wrong location, ignoring that the DB was attached.\n\n### To Reproduce\n\nHere we go:\r\n```python\r\nimport duckdb\r\n\r\ncon = duckdb.connect(\"tester.db\")\r\ncon.execute(\"CREATE TABLE my_table AS SELECT 1 AS CustomerId, 'hans' as CustomerName\")\r\ncon.execute(\"PRAGMA create_fts_index(my_table, 'CustomerId', 'CustomerName')\")\r\ncon.execute(\"SELECT fts_main_my_table.match_bm25(1, 'han')\")\r\ncon.close()\r\ncon_2 = duckdb.connect()\r\ncon_2.execute(\"ATTACH 'tester.db' as search_con\")\r\ncon_2.execute(\"SELECT search_con.fts_main_my_table.match_bm25(1, 'han')\")\r\ncon_2.close()\r\n```\n\n### OS:\n\nWindows x64\n\n### DuckDB Version:\n\n0.7.1\n\n### DuckDB Client:\n\npython\n\n### Full Name:\n\nAdrian Ehrsam\n\n### Affiliation:\n\nBuilding Material Suisse\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-07-05T14:35:40Z"
}