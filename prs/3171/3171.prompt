You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
PRAGMA database_size on read_only connection crash python
#### What happens?
If trying to query pragma database_size  to know memory consumption on a connection to a db opened with read_only=True, 
It **crashes python**.

#### To Reproduce
```python
import duckdb

conn = duckdb.connect("db2.duckdb", read_only=False)
print("With read/write:")
df = conn.execute("PRAGMA database_size").fetchdf()
print(df)
conn.close()
conn = duckdb.connect("db2.duckdb", read_only=True)
print("With read only:")
df = conn.execute("PRAGMA database_size").fetchdf()
print(df)
conn.close()
```
results in:
```
With read/write:
  database_size  block_size  total_blocks  used_blocks  free_blocks wal_size memory_usage memory_limit
0       0 bytes      262144             0            0            0  0 bytes      0 bytes       13.7GB
With read only:
```
#### Environment (please complete the following information):
 - OS: Windows 10
 - DuckDB Version: 0.3.2
 - DuckDB Client: Python 3.8.10

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

PRAGMA database_size on read_only connection crash python
#### What happens?
If trying to query pragma database_size  to know memory consumption on a connection to a db opened with read_only=True, 
It **crashes python**.

#### To Reproduce
```python
import duckdb

conn = duckdb.connect("db2.duckdb", read_only=False)
print("With read/write:")
df = conn.execute("PRAGMA database_size").fetchdf()
print(df)
conn.close()
conn = duckdb.connect("db2.duckdb", read_only=True)
print("With read only:")
df = conn.execute("PRAGMA database_size").fetchdf()
print(df)
conn.close()
```
results in:
```
With read/write:
  database_size  block_size  total_blocks  used_blocks  free_blocks wal_size memory_usage memory_limit
0       0 bytes      262144             0            0            0  0 bytes      0 bytes       13.7GB
With read only:
```
#### Environment (please complete the following information):
 - OS: Windows 10
 - DuckDB Version: 0.3.2
 - DuckDB Client: Python 3.8.10

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
* **Python**: `pip install duckdb --upgrade --pre`
* **R**: `install.packages("https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz", repos = NULL)`
* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of src/function/table/system/pragma_database_size.cpp]
1: #include "duckdb/function/table/system_functions.hpp"
2: 
3: #include "duckdb/storage/storage_manager.hpp"
4: #include "duckdb/storage/block_manager.hpp"
5: #include "duckdb/storage/storage_info.hpp"
6: #include "duckdb/common/to_string.hpp"
7: #include "duckdb/common/string_util.hpp"
8: 
9: namespace duckdb {
10: 
11: struct PragmaDatabaseSizeData : public FunctionOperatorData {
12: 	PragmaDatabaseSizeData() : finished(false) {
13: 	}
14: 
15: 	bool finished;
16: };
17: 
18: static unique_ptr<FunctionData> PragmaDatabaseSizeBind(ClientContext &context, vector<Value> &inputs,
19:                                                        named_parameter_map_t &named_parameters,
20:                                                        vector<LogicalType> &input_table_types,
21:                                                        vector<string> &input_table_names,
22:                                                        vector<LogicalType> &return_types, vector<string> &names) {
23: 	names.emplace_back("database_size");
24: 	return_types.emplace_back(LogicalType::VARCHAR);
25: 
26: 	names.emplace_back("block_size");
27: 	return_types.emplace_back(LogicalType::BIGINT);
28: 
29: 	names.emplace_back("total_blocks");
30: 	return_types.emplace_back(LogicalType::BIGINT);
31: 
32: 	names.emplace_back("used_blocks");
33: 	return_types.emplace_back(LogicalType::BIGINT);
34: 
35: 	names.emplace_back("free_blocks");
36: 	return_types.emplace_back(LogicalType::BIGINT);
37: 
38: 	names.emplace_back("wal_size");
39: 	return_types.emplace_back(LogicalType::VARCHAR);
40: 
41: 	names.emplace_back("memory_usage");
42: 	return_types.emplace_back(LogicalType::VARCHAR);
43: 
44: 	names.emplace_back("memory_limit");
45: 	return_types.emplace_back(LogicalType::VARCHAR);
46: 
47: 	return nullptr;
48: }
49: 
50: unique_ptr<FunctionOperatorData> PragmaDatabaseSizeInit(ClientContext &context, const FunctionData *bind_data,
51:                                                         const vector<column_t> &column_ids,
52:                                                         TableFilterCollection *filters) {
53: 	return make_unique<PragmaDatabaseSizeData>();
54: }
55: 
56: void PragmaDatabaseSizeFunction(ClientContext &context, const FunctionData *bind_data,
57:                                 FunctionOperatorData *operator_state, DataChunk *input, DataChunk &output) {
58: 	auto &data = (PragmaDatabaseSizeData &)*operator_state;
59: 	if (data.finished) {
60: 		return;
61: 	}
62: 	auto &storage = StorageManager::GetStorageManager(context);
63: 	auto &block_manager = BlockManager::GetBlockManager(context);
64: 	auto &buffer_manager = BufferManager::GetBufferManager(context);
65: 
66: 	output.SetCardinality(1);
67: 	if (!storage.InMemory()) {
68: 		auto total_blocks = block_manager.TotalBlocks();
69: 		auto block_size = Storage::BLOCK_ALLOC_SIZE;
70: 		auto free_blocks = block_manager.FreeBlocks();
71: 		auto used_blocks = total_blocks - free_blocks;
72: 		auto bytes = (total_blocks * block_size);
73: 		auto wal_size = storage.GetWriteAheadLog()->GetWALSize();
74: 		output.data[0].SetValue(0, Value(StringUtil::BytesToHumanReadableString(bytes)));
75: 		output.data[1].SetValue(0, Value::BIGINT(block_size));
76: 		output.data[2].SetValue(0, Value::BIGINT(total_blocks));
77: 		output.data[3].SetValue(0, Value::BIGINT(used_blocks));
78: 		output.data[4].SetValue(0, Value::BIGINT(free_blocks));
79: 		output.data[5].SetValue(0, Value(StringUtil::BytesToHumanReadableString(wal_size)));
80: 	} else {
81: 		output.data[0].SetValue(0, Value());
82: 		output.data[1].SetValue(0, Value());
83: 		output.data[2].SetValue(0, Value());
84: 		output.data[3].SetValue(0, Value());
85: 		output.data[4].SetValue(0, Value());
86: 		output.data[5].SetValue(0, Value());
87: 	}
88: 	output.data[6].SetValue(0, Value(StringUtil::BytesToHumanReadableString(buffer_manager.GetUsedMemory())));
89: 	auto max_memory = buffer_manager.GetMaxMemory();
90: 	output.data[7].SetValue(0, max_memory == (idx_t)-1 ? Value("Unlimited")
91: 	                                                   : Value(StringUtil::BytesToHumanReadableString(max_memory)));
92: 
93: 	data.finished = true;
94: }
95: 
96: void PragmaDatabaseSize::RegisterFunction(BuiltinFunctions &set) {
97: 	set.AddFunction(TableFunction("pragma_database_size", {}, PragmaDatabaseSizeFunction, PragmaDatabaseSizeBind,
98: 	                              PragmaDatabaseSizeInit));
99: }
100: 
101: } // namespace duckdb
[end of src/function/table/system/pragma_database_size.cpp]
[start of third_party/sqlsmith/duckdb.cc]
1: #include "duckdb.hh"
2: #include "tpch-extension.hpp"
3: 
4: #include <cassert>
5: #include <cstring>
6: #include <iostream>
7: #include <stdexcept>
8: #include <thread>
9: #include <chrono>
10: 
11: #include <regex>
12: 
13: using namespace duckdb;
14: using namespace std;
15: 
16: static regex e_syntax("syntax error at or near .*");
17: 
18: duckdb_connection::duckdb_connection(string &conninfo) {
19: 	// in-memory database
20: 	database = make_unique<DuckDB>(nullptr);
21: 	connection = make_unique<Connection>(*database);
22: }
23: 
24: void duckdb_connection::q(const char *query) {
25: 	auto result = connection->Query(query);
26: 	if (!result->success) {
27: 		throw runtime_error(result->error);
28: 	}
29: }
30: 
31: schema_duckdb::schema_duckdb(std::string &conninfo, bool no_catalog) : duckdb_connection(conninfo) {
32: 	// generate empty TPC-H schema
33: 	connection->Query("CALL dbgen(sf=0)");
34: 
35: 	cerr << "Loading tables...";
36: 	auto result = connection->Query("SELECT * FROM sqlite_master WHERE type IN ('table', 'view')");
37: 	if (!result->success) {
38: 		throw runtime_error(result->error);
39: 	}
40: 	for (size_t i = 0; i < result->collection.Count(); i++) {
41: 		auto type = StringValue::Get(result->collection.GetValue(0, i));
42: 		auto name = StringValue::Get(result->collection.GetValue(2, i));
43: 		bool view = type == "view";
44: 		table tab(name, "main", !view, !view);
45: 		tables.push_back(tab);
46: 	}
47: 	cerr << "done." << endl;
48: 
49: 	if (tables.size() == 0) {
50: 		throw std::runtime_error("No tables available in catalog!");
51: 	}
52: 
53: 	cerr << "Loading columns and constraints...";
54: 
55: 	for (auto t = tables.begin(); t != tables.end(); ++t) {
56: 		result = connection->Query("PRAGMA table_info('" + t->name + "')");
57: 		if (!result->success) {
58: 			throw runtime_error(result->error);
59: 		}
60: 		for (size_t i = 0; i < result->collection.Count(); i++) {
61: 			auto name = StringValue::Get(result->collection.GetValue(1, i));
62: 			auto type = StringValue::Get(result->collection.GetValue(2, i));
63: 			column c(name, sqltype::get(type));
64: 			t->columns().push_back(c);
65: 		}
66: 	}
67: 
68: 	cerr << "done." << endl;
69: 
70: #define BINOP(n, t)                                                                                                    \
71: 	do {                                                                                                               \
72: 		op o(#n, sqltype::get(#t), sqltype::get(#t), sqltype::get(#t));                                                \
73: 		register_operator(o);                                                                                          \
74: 	} while (0)
75: 
76: 	BINOP(||, TEXT);
77: 	BINOP(*, INTEGER);
78: 	BINOP(/, INTEGER);
79: 
80: 	BINOP(+, INTEGER);
81: 	BINOP(-, INTEGER);
82: 
83: 	BINOP(>>, INTEGER);
84: 	BINOP(<<, INTEGER);
85: 
86: 	BINOP(&, INTEGER);
87: 	BINOP(|, INTEGER);
88: 
89: 	BINOP(<, INTEGER);
90: 	BINOP(<=, INTEGER);
91: 	BINOP(>, INTEGER);
92: 	BINOP(>=, INTEGER);
93: 
94: 	BINOP(=, INTEGER);
95: 	BINOP(<>, INTEGER);
96: 	BINOP(IS, INTEGER);
97: 	BINOP(IS NOT, INTEGER);
98: 
99: 	BINOP(AND, INTEGER);
100: 	BINOP(OR, INTEGER);
101: 
102: #define FUNC(n, r)                                                                                                     \
103: 	do {                                                                                                               \
104: 		routine proc("", "", sqltype::get(#r), #n);                                                                    \
105: 		register_routine(proc);                                                                                        \
106: 	} while (0)
107: 
108: #define FUNC1(n, r, a)                                                                                                 \
109: 	do {                                                                                                               \
110: 		routine proc("", "", sqltype::get(#r), #n);                                                                    \
111: 		proc.argtypes.push_back(sqltype::get(#a));                                                                     \
112: 		register_routine(proc);                                                                                        \
113: 	} while (0)
114: 
115: #define FUNC2(n, r, a, b)                                                                                              \
116: 	do {                                                                                                               \
117: 		routine proc("", "", sqltype::get(#r), #n);                                                                    \
118: 		proc.argtypes.push_back(sqltype::get(#a));                                                                     \
119: 		proc.argtypes.push_back(sqltype::get(#b));                                                                     \
120: 		register_routine(proc);                                                                                        \
121: 	} while (0)
122: 
123: #define FUNC3(n, r, a, b, c)                                                                                           \
124: 	do {                                                                                                               \
125: 		routine proc("", "", sqltype::get(#r), #n);                                                                    \
126: 		proc.argtypes.push_back(sqltype::get(#a));                                                                     \
127: 		proc.argtypes.push_back(sqltype::get(#b));                                                                     \
128: 		proc.argtypes.push_back(sqltype::get(#c));                                                                     \
129: 		register_routine(proc);                                                                                        \
130: 	} while (0)
131: 
132: 	// FUNC(last_insert_rowid, INTEGER);
133: 	// FUNC(random, INTEGER);
134: 	// FUNC(sqlite_source_id, TEXT);
135: 	// FUNC(sqlite_version, TEXT);
136: 	// FUNC(total_changes, INTEGER);
137: 
138: 	FUNC1(abs, INTEGER, REAL);
139: 	// FUNC1(hex, TEXT, TEXT);
140: 	FUNC1(length, INTEGER, TEXT);
141: 	FUNC1(lower, TEXT, TEXT);
142: 	// FUNC1(ltrim, TEXT, TEXT);
143: 	// FUNC1(quote, TEXT, TEXT);
144: 	// FUNC1(randomblob, TEXT, INTEGER);
145: 	FUNC1(round, INTEGER, REAL);
146: 	// FUNC1(rtrim, TEXT, TEXT);
147: 	// FUNC1(soundex, TEXT, TEXT);
148: 	// FUNC1(sqlite_compileoption_get, TEXT, INTEGER);
149: 	// FUNC1(sqlite_compileoption_used, INTEGER, TEXT);
150: 	// FUNC1(trim, TEXT, TEXT);
151: 	// FUNC1(typeof, TEXT, INTEGER);
152: 	// FUNC1(typeof, TEXT, NUMERIC);
153: 	// FUNC1(typeof, TEXT, REAL);
154: 	// FUNC1(typeof, TEXT, TEXT);
155: 	// FUNC1(unicode, INTEGER, TEXT);
156: 	FUNC1(upper, TEXT, TEXT);
157: 	// FUNC1(zeroblob, TEXT, INTEGER);
158: 
159: 	// FUNC2(glob, INTEGER, TEXT, TEXT);
160: 	// FUNC2(instr, INTEGER, TEXT, TEXT);
161: 	// FUNC2(like, INTEGER, TEXT, TEXT);
162: 	// FUNC2(ltrim, TEXT, TEXT, TEXT);
163: 	// FUNC2(rtrim, TEXT, TEXT, TEXT);
164: 	// FUNC2(trim, TEXT, TEXT, TEXT);
165: 	// FUNC2(round, INTEGER, REAL, INTEGER);
166: 	FUNC2(substr, TEXT, TEXT, INTEGER);
167: 
168: 	FUNC3(substr, TEXT, TEXT, INTEGER, INTEGER);
169: 	FUNC3(replace, TEXT, TEXT, TEXT, TEXT);
170: 
171: #define AGG(n, r, a)                                                                                                   \
172: 	do {                                                                                                               \
173: 		routine proc("", "", sqltype::get(#r), #n);                                                                    \
174: 		proc.argtypes.push_back(sqltype::get(#a));                                                                     \
175: 		register_aggregate(proc);                                                                                      \
176: 	} while (0)
177: 
178: 	AGG(avg, INTEGER, INTEGER);
179: 	AGG(avg, REAL, REAL);
180: 	AGG(count, INTEGER, REAL);
181: 	AGG(count, INTEGER, TEXT);
182: 	AGG(count, INTEGER, INTEGER);
183: 	AGG(string_agg, TEXT, TEXT);
184: 	AGG(max, REAL, REAL);
185: 	AGG(max, INTEGER, INTEGER);
186: 	AGG(min, REAL, REAL);
187: 	AGG(min, INTEGER, INTEGER);
188: 	AGG(sum, REAL, REAL);
189: 	AGG(sum, INTEGER, INTEGER);
190: 	// AGG(total, REAL, INTEGER);
191: 	// AGG(total, REAL, REAL);
192: 
193: 	booltype = sqltype::get("INTEGER");
194: 	inttype = sqltype::get("INTEGER");
195: 
196: 	internaltype = sqltype::get("internal");
197: 	arraytype = sqltype::get("ARRAY");
198: 
199: 	true_literal = "1";
200: 	false_literal = "0";
201: 
202: 	generate_indexes();
203: }
204: 
205: dut_duckdb::dut_duckdb(std::string &conninfo) : duckdb_connection(conninfo) {
206: 	cerr << "Generating TPC-H...";
207: 	connection->Query("CALL dbgen(sf=0.01)");
208: 	cerr << "done." << endl;
209: 	// q("PRAGMA main.auto_vacuum = 2");
210: }
211: 
212: volatile bool is_active = false;
213: // timeout is 10ms * TIMEOUT_TICKS
214: #define TIMEOUT_TICKS 50
215: 
216: void sleep_thread(Connection *connection) {
217: 	for (size_t i = 0; i < TIMEOUT_TICKS && is_active; i++) {
218: 		std::this_thread::sleep_for(std::chrono::milliseconds(10));
219: 	}
220: 	if (is_active) {
221: 		connection->Interrupt();
222: 	}
223: }
224: 
225: void dut_duckdb::test(const std::string &stmt) {
226: 	is_active = true;
227: 	thread interrupt_thread(sleep_thread, connection.get());
228: 	auto result = connection->Query(stmt);
229: 	is_active = false;
230: 	interrupt_thread.join();
231: 
232: 	if (!result->success) {
233: 		auto error = result->error.c_str();
234: 		try {
235: 			if (regex_match(error, e_syntax))
236: 				throw dut::syntax(error);
237: 			else
238: 				throw dut::failure(error);
239: 		} catch (dut::failure &e) {
240: 			throw;
241: 		}
242: 	}
243: }
[end of third_party/sqlsmith/duckdb.cc]
[start of third_party/sqlsmith/include/duckdb.hh]
1: /// @file
2: /// @brief schema and dut classes for DuckDB
3: 
4: #ifndef DUCKDB_HH
5: #define DUCKDB_HH
6: 
7: #include "duckdb.hpp"
8: 
9: #include "dut.hh"
10: #include "relmodel.hh"
11: #include "schema.hh"
12: 
13: struct duckdb_connection {
14: 	std::unique_ptr<duckdb::DuckDB> database;
15: 	std::unique_ptr<duckdb::Connection> connection;
16: 	char *zErrMsg = 0;
17: 	int rc;
18: 	void q(const char *query);
19: 	duckdb_connection(std::string &conninfo);
20: };
21: 
22: struct schema_duckdb : schema, duckdb_connection {
23: 	schema_duckdb(std::string &conninfo, bool no_catalog);
24: 	virtual std::string quote_name(const std::string &id) {
25: 		return id;
26: 	}
27: };
28: 
29: struct dut_duckdb : dut_base, duckdb_connection {
30: 	virtual void test(const std::string &stmt);
31: 	dut_duckdb(std::string &conninfo);
32: };
33: #endif
[end of third_party/sqlsmith/include/duckdb.hh]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: