diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp
index c12417629cf7..7486d56badc7 100644
--- a/test/rigger/test_rigger.cpp
+++ b/test/rigger/test_rigger.cpp
@@ -38,8 +38,7 @@ TEST_CASE("Test queries found by Rigger that cause problems in other systems", "
 	SECTION("#8 Query with RIGHT JOIN causes a server panic") {
 		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
 		REQUIRE_NO_FAIL(con.Query("CREATE VIEW v0(c0) AS SELECT 0 FROM t0 ORDER BY -t0.c0;"));
-		// FIXME: right join not supported
-		REQUIRE_FAIL(con.Query("SELECT * FROM v0 RIGHT JOIN t0 ON false;"));
+		REQUIRE_NO_FAIL(con.Query("SELECT * FROM v0 RIGHT JOIN t0 ON false;"));
 	}
 	// SQLite
 	SECTION("#15 './' LIKE './' does not match") {
@@ -195,4 +194,63 @@ TEST_CASE("Tests found by Rigger", "[rigger]") {
 		result = con.Query("SELECT t0.c0 FROM t0, t1 WHERE t1.c0 < t0.c0;");
 		REQUIRE(CHECK_COLUMN(result, 0, {}));
 	}
+	SECTION("503") {
+		// RIGHT JOIN with a predicate that compares two integer columns results in an "Unhandled type" error
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 INT);"));
+		result = con.Query("SELECT * FROM t0 RIGHT JOIN t1 ON t0.c0!=t1.c0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+		REQUIRE(CHECK_COLUMN(result, 1, {}));
+	}
+	SECTION("504") {
+		// INSERT results in an error "Not implemented: Cannot create data from this type"
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 BOOLEAN, c1 INT, PRIMARY KEY(c0, c1));"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c1, c0) VALUES (0, 0);"));
+		result = con.Query("SELECT * FROM t0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {false}));
+		REQUIRE(CHECK_COLUMN(result, 1, {0}));
+	}
+	SECTION("505") {
+		// A RIGHT JOIN unexpectedly fetches rows
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c1 BOOLEAN);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (1);"));
+		result = con.Query("SELECT * FROM t0 RIGHT JOIN t1 on true;");
+		REQUIRE(CHECK_COLUMN(result, 0, {}));
+		REQUIRE(CHECK_COLUMN(result, 1, {}));
+	}
+	SECTION("506") {
+		// Query results in an error "INTERNAL: Failed to bind column reference "c0" [5.0] (bindings: [6.0])"
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("SELECT * FROM t1 JOIN t0 ON t1.c0 < t1.c0 - t0.c0 WHERE t0.c0 <= t1.c0;"));
+		REQUIRE_NO_FAIL(con.Query("SELECT * FROM t1 JOIN t0 ON t0.c0 + t1.c0 < t1.c0 - t0.c0;"));
+	}
+	SECTION("507") {
+		// Creating an empty table results in a crash
+		REQUIRE_FAIL(con.Query("CREATE TABLE t0();"));
+	}
+	SECTION("508") {
+		// LEFT JOIN on column with NULL value results in a segmentation fault
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t1(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (0);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t1(c0) VALUES (NULL);"));
+		result = con.Query("SELECT * FROM t1 LEFT JOIN t0 ON t0.c0=t1.c0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {Value()}));
+		REQUIRE(CHECK_COLUMN(result, 1, {Value()}));
+	}
+	SECTION("510") {
+		// SIMILAR TO results in an incorrect result
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (-10);"));
+		result = con.Query("SELECT '-10' SIMILAR TO '0';");
+		REQUIRE(CHECK_COLUMN(result, 0, {false}));
+		result = con.Query("SELECT t0.c0 SIMILAR TO 0 FROM t0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {false}));
+		result = con.Query("SELECT t0.c0 NOT SIMILAR TO 0 FROM t0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {true}));
+		result = con.Query("SELECT * FROM t0 WHERE t0.c0 NOT SIMILAR TO 0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {-10}));
+	}
 }
diff --git a/test/sql/constraints/test_primarykey.cpp b/test/sql/constraints/test_primarykey.cpp
index b695ebc789bc..c1a6e187b50b 100644
--- a/test/sql/constraints/test_primarykey.cpp
+++ b/test/sql/constraints/test_primarykey.cpp
@@ -449,3 +449,19 @@ TEST_CASE("PRIMARY KEY constraint on multiple string columns with overlapping va
 	//! this should  work since it won't cause a duplicate
 	REQUIRE_NO_FAIL(con.Query("UPDATE tst SET b='hell' WHERE b='hel'"));
 }
+
+TEST_CASE("Multi-column boolean PRIMARY KEY constraint", "[constraints]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db);
+
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE integers(i INTEGER, j BOOLEAN, PRIMARY KEY(i, j))"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO integers VALUES (1, false), (1, true), (2, false)"));
+	// duplicate value!
+	REQUIRE_FAIL(con.Query("INSERT INTO integers VALUES (1, false)"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO integers VALUES (2, true)"));
+
+	result = con.Query("SELECT * FROM integers ORDER BY 1, 2");
+	REQUIRE(CHECK_COLUMN(result, 0, {1, 1, 2, 2}));
+	REQUIRE(CHECK_COLUMN(result, 1, {false, true, false, true}));
+}
diff --git a/test/sql/function/test_regex.cpp b/test/sql/function/test_regex.cpp
index 6c230933aa6f..ae4ba928a6c8 100644
--- a/test/sql/function/test_regex.cpp
+++ b/test/sql/function/test_regex.cpp
@@ -23,6 +23,11 @@ TEST_CASE("regex search test", "[regex]") {
 	// partial matches okay
 	result = con.Query("SELECT regexp_matches('asdf', 'sd')");
 	REQUIRE(CHECK_COLUMN(result, 0, {true}));
+	// full match requires entire match
+	result = con.Query("SELECT regexp_full_match('asdf', 'sd')");
+	REQUIRE(CHECK_COLUMN(result, 0, {false}));
+	result = con.Query("SELECT regexp_full_match('asdf', '.sd.')");
+	REQUIRE(CHECK_COLUMN(result, 0, {true}));
 
 	result = con.Query("SELECT regexp_matches('asdf', '^sdf$')");
 	REQUIRE(CHECK_COLUMN(result, 0, {false}));
diff --git a/test/sql/index/test_art_index.cpp b/test/sql/index/test_art_index.cpp
index 6ff0aa08e0c4..f78c1bbb67f4 100644
--- a/test/sql/index/test_art_index.cpp
+++ b/test/sql/index/test_art_index.cpp
@@ -1746,13 +1746,8 @@ TEST_CASE("Index Exceptions", "[art]") {
 	REQUIRE_NO_FAIL(con.Query("CREATE TABLE integers(i integer, j integer, k BOOLEAN)"));
 
 	REQUIRE_FAIL(con.Query("CREATE INDEX ON integers(i)"));
-
 	REQUIRE_FAIL(con.Query("CREATE INDEX i_index ON integers(i COLLATE \"de_DE\")"));
-
 	REQUIRE_FAIL(con.Query("CREATE INDEX i_index ON integers using blabla(i)"));
-
-	REQUIRE_FAIL(con.Query("CREATE INDEX i_index ON integers(k)"));
-
 	REQUIRE_FAIL(con.Query("CREATE INDEX i_index ON integers(f)"));
 }
 
diff --git a/test/sql/join/test_left_outer_join.cpp b/test/sql/join/test_left_outer_join.cpp
index bee2bbd51f8d..3b160d764835 100644
--- a/test/sql/join/test_left_outer_join.cpp
+++ b/test/sql/join/test_left_outer_join.cpp
@@ -24,6 +24,15 @@ TEST_CASE("Test LEFT OUTER JOIN", "[join]") {
 	REQUIRE(CHECK_COLUMN(result, 2, {1, 2, Value()}));
 	REQUIRE(CHECK_COLUMN(result, 3, {10, 20, Value()}));
 
+	// RIGHT OUTER JOIN is just LEFT OUTER JOIN but with arguments reversed
+	// with one caveat: SELECT * will project the columns of the LHS first!
+	result = con.Query("SELECT * FROM integers2 RIGHT OUTER JOIN integers ON "
+	                   "integers.i=integers2.k ORDER BY i");
+	REQUIRE(CHECK_COLUMN(result, 0, {1, 2, Value()}));
+	REQUIRE(CHECK_COLUMN(result, 1, {10, 20, Value()}));
+	REQUIRE(CHECK_COLUMN(result, 2, {1, 2, 3}));
+	REQUIRE(CHECK_COLUMN(result, 3, {2, 3, 4}));
+
 	// WHERE happens AFTER the join, thus [where k IS NOT NULL] filters out any tuples with generated NULL values from
 	// the LEFT OUTER JOIN. Because of this, this join is equivalent to an inner join.
 	result = con.Query("SELECT * FROM integers LEFT OUTER JOIN integers2 ON "
diff --git a/test/sql/simple/test_join.cpp b/test/sql/simple/test_join.cpp
index 949394c802eb..b86664860dcc 100644
--- a/test/sql/simple/test_join.cpp
+++ b/test/sql/simple/test_join.cpp
@@ -513,3 +513,35 @@ TEST_CASE("Test joins with various columns that are only used in the join", "[jo
 	result = con.Query("SELECT (TRUE OR a1.a=a2.b) FROM test a1, test a2 WHERE a1.a=11 AND a2.a>=10");
 	REQUIRE(CHECK_COLUMN(result, 0, {true, true, true}));
 }
+
+TEST_CASE("Test joins with comparisons involving both sides of the join", "[joins]") {
+	DuckDB db(nullptr);
+	Connection con(db);
+	unique_ptr<QueryResult> result;
+	con.EnableQueryVerification();
+
+	// create tables
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE test (a INTEGER, b INTEGER);"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (4, 1), (2, 2)"));
+
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE test2 (b INTEGER, c INTEGER);"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (1, 2), (3, 0)"));
+
+	result = con.Query("SELECT * FROM test JOIN test2 ON test.a+test2.c=test.b+test2.b");
+	REQUIRE(CHECK_COLUMN(result, 0, {4}));
+	REQUIRE(CHECK_COLUMN(result, 1, {1}));
+	REQUIRE(CHECK_COLUMN(result, 2, {3}));
+	REQUIRE(CHECK_COLUMN(result, 3, {0}));
+
+	result = con.Query("SELECT * FROM test LEFT JOIN test2 ON test.a+test2.c=test.b+test2.b ORDER BY 1");
+	REQUIRE(CHECK_COLUMN(result, 0, {2, 4}));
+	REQUIRE(CHECK_COLUMN(result, 1, {2, 1}));
+	REQUIRE(CHECK_COLUMN(result, 2, {Value(), 3}));
+	REQUIRE(CHECK_COLUMN(result, 3, {Value(), 0}));
+
+	result = con.Query("SELECT * FROM test RIGHT JOIN test2 ON test.a+test2.c=test.b+test2.b ORDER BY 1");
+	REQUIRE(CHECK_COLUMN(result, 0, {Value(), 4}));
+	REQUIRE(CHECK_COLUMN(result, 1, {Value(), 1}));
+	REQUIRE(CHECK_COLUMN(result, 2, {1, 3}));
+	REQUIRE(CHECK_COLUMN(result, 3, {2, 0}));
+}
diff --git a/test/sql/simple/test_similar.cpp b/test/sql/simple/test_similar.cpp
index a42c781ae09f..4500c6b5c262 100644
--- a/test/sql/simple/test_similar.cpp
+++ b/test/sql/simple/test_similar.cpp
@@ -54,10 +54,13 @@ TEST_CASE("Test scalar SIMILAR TO statement", "[similar]") {
 	result = connection.Query("SELECT 'aaa' !~ 'bbb'");
 	REQUIRE(CHECK_COLUMN(result, 0, {Value::BOOLEAN(true)}));
 
+	// similar to must match entire expression
 	result = connection.Query("SELECT 'aaa' ~ '^a'");
+	REQUIRE(CHECK_COLUMN(result, 0, {Value::BOOLEAN(false)}));
+	result = connection.Query("SELECT 'aaa' ~ '^a+'");
 	REQUIRE(CHECK_COLUMN(result, 0, {Value::BOOLEAN(true)}));
 
-	result = connection.Query("SELECT 'aaa' ~ '(a|b)'");
+	result = connection.Query("SELECT 'aaa' ~ '(a|b)*'");
 	REQUIRE(CHECK_COLUMN(result, 0, {Value::BOOLEAN(true)}));
 
 	result = connection.Query("SELECT 'abc' ~ '^(b|c)'");
