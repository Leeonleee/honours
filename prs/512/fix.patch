diff --git a/src/execution/index/art/art.cpp b/src/execution/index/art/art.cpp
index c5a1a0df359d..6e7467e301fd 100644
--- a/src/execution/index/art/art.cpp
+++ b/src/execution/index/art/art.cpp
@@ -20,6 +20,7 @@ ART::ART(DataTable &table, vector<column_t> column_ids, vector<unique_ptr<Expres
 		is_little_endian = false;
 	}
 	switch (types[0]) {
+	case TypeId::BOOL:
 	case TypeId::INT8:
 	case TypeId::INT16:
 	case TypeId::INT32:
diff --git a/src/execution/index/art/art_key.cpp b/src/execution/index/art/art_key.cpp
index 26b06def6d5e..5ef97a7885be 100644
--- a/src/execution/index/art/art_key.cpp
+++ b/src/execution/index/art/art_key.cpp
@@ -79,6 +79,12 @@ uint64_t Key::EncodeDouble(double x) {
 Key::Key(unique_ptr<data_t[]> data, idx_t len) : len(len), data(move(data)) {
 }
 
+template <> unique_ptr<data_t[]> Key::CreateData(bool value, bool is_little_endian) {
+	auto data = unique_ptr<data_t[]>(new data_t[sizeof(value)]);
+	data[0] = value ? 1 : 0;
+	return data;
+}
+
 template <> unique_ptr<data_t[]> Key::CreateData(int8_t value, bool is_little_endian) {
 	auto data = unique_ptr<data_t[]>(new data_t[sizeof(value)]);
 	reinterpret_cast<uint8_t *>(data.get())[0] = value;
diff --git a/src/execution/join_hashtable.cpp b/src/execution/join_hashtable.cpp
index 5c8c0c8660a0..6566029c855e 100644
--- a/src/execution/join_hashtable.cpp
+++ b/src/execution/join_hashtable.cpp
@@ -403,6 +403,11 @@ unique_ptr<ScanStructure> JoinHashTable::Probe(DataChunk &keys) {
 	// set up the scan structure
 	auto ss = make_unique<ScanStructure>(*this);
 
+	if (join_type != JoinType::INNER) {
+		ss->found_match = unique_ptr<bool[]>(new bool[STANDARD_VECTOR_SIZE]);
+		memset(ss->found_match.get(), 0, sizeof(bool) * STANDARD_VECTOR_SIZE);
+	}
+
 	// first prepare the keys for probing
 	const SelectionVector *current_sel;
 	ss->count = PrepareKeys(keys, ss->key_data, current_sel, ss->sel_vector);
@@ -417,11 +422,6 @@ unique_ptr<ScanStructure> JoinHashTable::Probe(DataChunk &keys) {
 	// now initialize the pointers of the scan structure based on the hashes
 	ApplyBitmask(hashes, *current_sel, ss->count, ss->pointers);
 
-	if (join_type != JoinType::INNER) {
-		ss->found_match = unique_ptr<bool[]>(new bool[STANDARD_VECTOR_SIZE]);
-		memset(ss->found_match.get(), 0, sizeof(bool) * STANDARD_VECTOR_SIZE);
-	}
-
 	// create the selection vector linking to only non-empty entries
 	idx_t count = 0;
 	auto pointers = FlatVector::GetData<data_ptr_t>(ss->pointers);
diff --git a/src/function/scalar/string/regexp.cpp b/src/function/scalar/string/regexp.cpp
index 6b6b9c2d49fd..08de684c36fc 100644
--- a/src/function/scalar/string/regexp.cpp
+++ b/src/function/scalar/string/regexp.cpp
@@ -31,6 +31,19 @@ static inline re2::StringPiece CreateStringPiece(string_t &input) {
 	return re2::StringPiece(input.GetData(), input.GetSize());
 }
 
+struct RegexPartialMatch {
+	static inline bool Operation(const re2::StringPiece &input, RE2 &re) {
+		return RE2::PartialMatch(input, re);
+	}
+};
+
+struct RegexFullMatch {
+	static inline bool Operation(const re2::StringPiece &input, RE2 &re) {
+		return RE2::FullMatch(input, re);
+	}
+};
+
+template<class OP>
 static void regexp_matches_function(DataChunk &args, ExpressionState &state, Vector &result) {
 	auto &strings = args.data[0];
 	auto &patterns = args.data[1];
@@ -44,7 +57,7 @@ static void regexp_matches_function(DataChunk &args, ExpressionState &state, Vec
 	if (info.constant_pattern) {
 		// FIXME: this should be a unary loop
 		UnaryExecutor::Execute<string_t, bool, true>(strings, result, args.size(), [&](string_t input) {
-			return RE2::PartialMatch(CreateStringPiece(input), *info.constant_pattern);
+			return OP::Operation(CreateStringPiece(input), *info.constant_pattern);
 		});
 	} else {
 		BinaryExecutor::Execute<string_t, string_t, bool, true>(
@@ -53,7 +66,7 @@ static void regexp_matches_function(DataChunk &args, ExpressionState &state, Vec
 			    if (!re.ok()) {
 				    throw Exception(re.error());
 			    }
-			    return RE2::PartialMatch(CreateStringPiece(input), re);
+			    return OP::Operation(CreateStringPiece(input), re);
 		    });
 	}
 }
@@ -105,8 +118,10 @@ static void regexp_replace_function(DataChunk &args, ExpressionState &state, Vec
 }
 
 void RegexpFun::RegisterFunction(BuiltinFunctions &set) {
+	set.AddFunction(ScalarFunction("regexp_full_match", {SQLType::VARCHAR, SQLType::VARCHAR}, SQLType::BOOLEAN,
+	                               regexp_matches_function<RegexFullMatch>, false, regexp_matches_get_bind_function));
 	set.AddFunction(ScalarFunction("regexp_matches", {SQLType::VARCHAR, SQLType::VARCHAR}, SQLType::BOOLEAN,
-	                               regexp_matches_function, false, regexp_matches_get_bind_function));
+	                               regexp_matches_function<RegexPartialMatch>, false, regexp_matches_get_bind_function));
 	set.AddFunction(ScalarFunction("regexp_replace", {SQLType::VARCHAR, SQLType::VARCHAR, SQLType::VARCHAR},
 	                               SQLType::VARCHAR, regexp_replace_function));
 }
diff --git a/src/include/duckdb/execution/index/art/art_key.hpp b/src/include/duckdb/execution/index/art/art_key.hpp
index 8b4405888382..27369e399379 100644
--- a/src/include/duckdb/execution/index/art/art_key.hpp
+++ b/src/include/duckdb/execution/index/art/art_key.hpp
@@ -49,6 +49,7 @@ class Key {
 	}
 };
 
+template <> unique_ptr<data_t[]> Key::CreateData(bool value, bool is_little_endian);
 template <> unique_ptr<data_t[]> Key::CreateData(int8_t value, bool is_little_endian);
 template <> unique_ptr<data_t[]> Key::CreateData(int16_t value, bool is_little_endian);
 template <> unique_ptr<data_t[]> Key::CreateData(int32_t value, bool is_little_endian);
diff --git a/src/optimizer/join_order_optimizer.cpp b/src/optimizer/join_order_optimizer.cpp
index 53e6be72aa5c..9fb94b3bbb4f 100644
--- a/src/optimizer/join_order_optimizer.cpp
+++ b/src/optimizer/join_order_optimizer.cpp
@@ -711,15 +711,16 @@ unique_ptr<LogicalOperator> JoinOrderOptimizer::Optimize(unique_ptr<LogicalOpera
 						query_graph.CreateEdge(filter_info->left_set, filter_info->right_set, filter_info);
 						query_graph.CreateEdge(filter_info->right_set, filter_info->left_set, filter_info);
 					} else {
+						continue;
 						// the sets are not disjoint, we create two sets of edges
-						auto left_difference = set_manager.Difference(filter_info->left_set, filter_info->right_set);
-						auto right_difference = set_manager.Difference(filter_info->right_set, filter_info->left_set);
-						// -> LEFT <-> RIGHT \ LEFT
-						query_graph.CreateEdge(filter_info->left_set, right_difference, filter_info);
-						query_graph.CreateEdge(right_difference, filter_info->left_set, filter_info);
-						// -> RIGHT <-> LEFT \ RIGHT
-						query_graph.CreateEdge(left_difference, filter_info->right_set, filter_info);
-						query_graph.CreateEdge(filter_info->right_set, left_difference, filter_info);
+						// auto left_difference = set_manager.Difference(filter_info->left_set, filter_info->right_set);
+						// auto right_difference = set_manager.Difference(filter_info->right_set, filter_info->left_set);
+						// // -> LEFT <-> RIGHT \ LEFT
+						// query_graph.CreateEdge(filter_info->left_set, right_difference, filter_info);
+						// query_graph.CreateEdge(right_difference, filter_info->left_set, filter_info);
+						// // -> RIGHT <-> LEFT \ RIGHT
+						// query_graph.CreateEdge(left_difference, filter_info->right_set, filter_info);
+						// query_graph.CreateEdge(filter_info->right_set, left_difference, filter_info);
 					}
 					continue;
 				}
diff --git a/src/parser/transform/expression/transform_operator.cpp b/src/parser/transform/expression/transform_operator.cpp
index 9425a8ed9a9e..13ee2dc71054 100644
--- a/src/parser/transform/expression/transform_operator.cpp
+++ b/src/parser/transform/expression/transform_operator.cpp
@@ -47,10 +47,10 @@ unique_ptr<ParsedExpression> Transformer::TransformBinaryOperator(string op, uni
 	children.push_back(move(right));
 
 	if (op == "~" || op == "!~") {
-		// rewrite SIMILAR TO into regexp_matches('asdf', '.*sd.*')
+		// rewrite 'asdf' SIMILAR TO '.*sd.*' into regexp_full_match('asdf', '.*sd.*')
 		bool invert_similar = op == "!~";
 
-		auto result = make_unique<FunctionExpression>(schema, "regexp_matches", children);
+		auto result = make_unique<FunctionExpression>(schema, "regexp_full_match", children);
 		if (invert_similar) {
 			return make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(result));
 		} else {
@@ -132,7 +132,7 @@ unique_ptr<ParsedExpression> Transformer::TransformAExpr(PGAExpr *root) {
 			return make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(compare_between));
 		}
 	} break;
-	// rewrite SIMILAR TO into regexp_matches('asdf', '.*sd.*')
+	// rewrite SIMILAR TO into regexp_full_match('asdf', '.*sd.*')
 	case PG_AEXPR_SIMILAR: {
 		auto left_expr = TransformExpression(root->lexpr);
 		auto right_expr = TransformExpression(root->rexpr);
@@ -160,7 +160,7 @@ unique_ptr<ParsedExpression> Transformer::TransformAExpr(PGAExpr *root) {
 			invert_similar = true;
 		}
 		const auto schema = DEFAULT_SCHEMA;
-		const auto regex_function = "regexp_matches";
+		const auto regex_function = "regexp_full_match";
 		auto result = make_unique<FunctionExpression>(schema, regex_function, children);
 
 		if (invert_similar) {
diff --git a/src/parser/transform/statement/transform_create_table.cpp b/src/parser/transform/statement/transform_create_table.cpp
index d3a600ecfac0..9b3a2af5285e 100644
--- a/src/parser/transform/statement/transform_create_table.cpp
+++ b/src/parser/transform/statement/transform_create_table.cpp
@@ -29,8 +29,9 @@ unique_ptr<CreateStatement> Transformer::TransformCreateTable(PGNode *node) {
 	    stmt->oncommit != PGOnCommitAction::PG_ONCOMMIT_NOOP) {
 		throw NotImplementedException("Only ON COMMIT PRESERVE ROWS is supported");
 	}
-
-	assert(stmt->tableElts);
+	if (!stmt->tableElts) {
+		throw ParserException("Table must have at least one column!");
+	}
 
 	for (auto c = stmt->tableElts->head; c != NULL; c = lnext(c)) {
 		auto node = reinterpret_cast<PGNode *>(c->data.ptr_value);
diff --git a/src/parser/transform/tableref/transform_join.cpp b/src/parser/transform/tableref/transform_join.cpp
index 05a49137c10a..75cfebb36a27 100644
--- a/src/parser/transform/tableref/transform_join.cpp
+++ b/src/parser/transform/tableref/transform_join.cpp
@@ -22,6 +22,10 @@ unique_ptr<TableRef> Transformer::TransformJoin(PGJoinExpr *root) {
 		result->type = JoinType::OUTER;
 		break;
 	}
+	case PG_JOIN_RIGHT: {
+		result->type = JoinType::RIGHT;
+		break;
+	}
 	case PG_JOIN_SEMI: {
 		result->type = JoinType::SEMI;
 		break;
diff --git a/src/planner/binder/tableref/plan_joinref.cpp b/src/planner/binder/tableref/plan_joinref.cpp
index 0c503135c464..757266b601ac 100644
--- a/src/planner/binder/tableref/plan_joinref.cpp
+++ b/src/planner/binder/tableref/plan_joinref.cpp
@@ -143,6 +143,10 @@ unique_ptr<LogicalOperator> LogicalComparisonJoin::CreateJoin(JoinType type, uni
 unique_ptr<LogicalOperator> Binder::CreatePlan(BoundJoinRef &ref) {
 	auto left = CreatePlan(*ref.left);
 	auto right = CreatePlan(*ref.right);
+	if (ref.type == JoinType::RIGHT) {
+		ref.type = JoinType::LEFT;
+		std::swap(left, right);
+	}
 
 	if (ref.type == JoinType::INNER) {
 		// inner join, generate a cross product + filter
