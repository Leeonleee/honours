{
  "repo": "duckdb/duckdb",
  "pull_number": 512,
  "instance_id": "duckdb__duckdb-512",
  "issue_numbers": [
    "510"
  ],
  "base_commit": "c52fc9bafd22e41a5554d3305530ebc1bf8364f9",
  "patch": "diff --git a/src/execution/index/art/art.cpp b/src/execution/index/art/art.cpp\nindex c5a1a0df359d..6e7467e301fd 100644\n--- a/src/execution/index/art/art.cpp\n+++ b/src/execution/index/art/art.cpp\n@@ -20,6 +20,7 @@ ART::ART(DataTable &table, vector<column_t> column_ids, vector<unique_ptr<Expres\n \t\tis_little_endian = false;\n \t}\n \tswitch (types[0]) {\n+\tcase TypeId::BOOL:\n \tcase TypeId::INT8:\n \tcase TypeId::INT16:\n \tcase TypeId::INT32:\ndiff --git a/src/execution/index/art/art_key.cpp b/src/execution/index/art/art_key.cpp\nindex 26b06def6d5e..5ef97a7885be 100644\n--- a/src/execution/index/art/art_key.cpp\n+++ b/src/execution/index/art/art_key.cpp\n@@ -79,6 +79,12 @@ uint64_t Key::EncodeDouble(double x) {\n Key::Key(unique_ptr<data_t[]> data, idx_t len) : len(len), data(move(data)) {\n }\n \n+template <> unique_ptr<data_t[]> Key::CreateData(bool value, bool is_little_endian) {\n+\tauto data = unique_ptr<data_t[]>(new data_t[sizeof(value)]);\n+\tdata[0] = value ? 1 : 0;\n+\treturn data;\n+}\n+\n template <> unique_ptr<data_t[]> Key::CreateData(int8_t value, bool is_little_endian) {\n \tauto data = unique_ptr<data_t[]>(new data_t[sizeof(value)]);\n \treinterpret_cast<uint8_t *>(data.get())[0] = value;\ndiff --git a/src/execution/join_hashtable.cpp b/src/execution/join_hashtable.cpp\nindex 5c8c0c8660a0..6566029c855e 100644\n--- a/src/execution/join_hashtable.cpp\n+++ b/src/execution/join_hashtable.cpp\n@@ -403,6 +403,11 @@ unique_ptr<ScanStructure> JoinHashTable::Probe(DataChunk &keys) {\n \t// set up the scan structure\n \tauto ss = make_unique<ScanStructure>(*this);\n \n+\tif (join_type != JoinType::INNER) {\n+\t\tss->found_match = unique_ptr<bool[]>(new bool[STANDARD_VECTOR_SIZE]);\n+\t\tmemset(ss->found_match.get(), 0, sizeof(bool) * STANDARD_VECTOR_SIZE);\n+\t}\n+\n \t// first prepare the keys for probing\n \tconst SelectionVector *current_sel;\n \tss->count = PrepareKeys(keys, ss->key_data, current_sel, ss->sel_vector);\n@@ -417,11 +422,6 @@ unique_ptr<ScanStructure> JoinHashTable::Probe(DataChunk &keys) {\n \t// now initialize the pointers of the scan structure based on the hashes\n \tApplyBitmask(hashes, *current_sel, ss->count, ss->pointers);\n \n-\tif (join_type != JoinType::INNER) {\n-\t\tss->found_match = unique_ptr<bool[]>(new bool[STANDARD_VECTOR_SIZE]);\n-\t\tmemset(ss->found_match.get(), 0, sizeof(bool) * STANDARD_VECTOR_SIZE);\n-\t}\n-\n \t// create the selection vector linking to only non-empty entries\n \tidx_t count = 0;\n \tauto pointers = FlatVector::GetData<data_ptr_t>(ss->pointers);\ndiff --git a/src/function/scalar/string/regexp.cpp b/src/function/scalar/string/regexp.cpp\nindex 6b6b9c2d49fd..08de684c36fc 100644\n--- a/src/function/scalar/string/regexp.cpp\n+++ b/src/function/scalar/string/regexp.cpp\n@@ -31,6 +31,19 @@ static inline re2::StringPiece CreateStringPiece(string_t &input) {\n \treturn re2::StringPiece(input.GetData(), input.GetSize());\n }\n \n+struct RegexPartialMatch {\n+\tstatic inline bool Operation(const re2::StringPiece &input, RE2 &re) {\n+\t\treturn RE2::PartialMatch(input, re);\n+\t}\n+};\n+\n+struct RegexFullMatch {\n+\tstatic inline bool Operation(const re2::StringPiece &input, RE2 &re) {\n+\t\treturn RE2::FullMatch(input, re);\n+\t}\n+};\n+\n+template<class OP>\n static void regexp_matches_function(DataChunk &args, ExpressionState &state, Vector &result) {\n \tauto &strings = args.data[0];\n \tauto &patterns = args.data[1];\n@@ -44,7 +57,7 @@ static void regexp_matches_function(DataChunk &args, ExpressionState &state, Vec\n \tif (info.constant_pattern) {\n \t\t// FIXME: this should be a unary loop\n \t\tUnaryExecutor::Execute<string_t, bool, true>(strings, result, args.size(), [&](string_t input) {\n-\t\t\treturn RE2::PartialMatch(CreateStringPiece(input), *info.constant_pattern);\n+\t\t\treturn OP::Operation(CreateStringPiece(input), *info.constant_pattern);\n \t\t});\n \t} else {\n \t\tBinaryExecutor::Execute<string_t, string_t, bool, true>(\n@@ -53,7 +66,7 @@ static void regexp_matches_function(DataChunk &args, ExpressionState &state, Vec\n \t\t\t    if (!re.ok()) {\n \t\t\t\t    throw Exception(re.error());\n \t\t\t    }\n-\t\t\t    return RE2::PartialMatch(CreateStringPiece(input), re);\n+\t\t\t    return OP::Operation(CreateStringPiece(input), re);\n \t\t    });\n \t}\n }\n@@ -105,8 +118,10 @@ static void regexp_replace_function(DataChunk &args, ExpressionState &state, Vec\n }\n \n void RegexpFun::RegisterFunction(BuiltinFunctions &set) {\n+\tset.AddFunction(ScalarFunction(\"regexp_full_match\", {SQLType::VARCHAR, SQLType::VARCHAR}, SQLType::BOOLEAN,\n+\t                               regexp_matches_function<RegexFullMatch>, false, regexp_matches_get_bind_function));\n \tset.AddFunction(ScalarFunction(\"regexp_matches\", {SQLType::VARCHAR, SQLType::VARCHAR}, SQLType::BOOLEAN,\n-\t                               regexp_matches_function, false, regexp_matches_get_bind_function));\n+\t                               regexp_matches_function<RegexPartialMatch>, false, regexp_matches_get_bind_function));\n \tset.AddFunction(ScalarFunction(\"regexp_replace\", {SQLType::VARCHAR, SQLType::VARCHAR, SQLType::VARCHAR},\n \t                               SQLType::VARCHAR, regexp_replace_function));\n }\ndiff --git a/src/include/duckdb/execution/index/art/art_key.hpp b/src/include/duckdb/execution/index/art/art_key.hpp\nindex 8b4405888382..27369e399379 100644\n--- a/src/include/duckdb/execution/index/art/art_key.hpp\n+++ b/src/include/duckdb/execution/index/art/art_key.hpp\n@@ -49,6 +49,7 @@ class Key {\n \t}\n };\n \n+template <> unique_ptr<data_t[]> Key::CreateData(bool value, bool is_little_endian);\n template <> unique_ptr<data_t[]> Key::CreateData(int8_t value, bool is_little_endian);\n template <> unique_ptr<data_t[]> Key::CreateData(int16_t value, bool is_little_endian);\n template <> unique_ptr<data_t[]> Key::CreateData(int32_t value, bool is_little_endian);\ndiff --git a/src/optimizer/join_order_optimizer.cpp b/src/optimizer/join_order_optimizer.cpp\nindex 53e6be72aa5c..9fb94b3bbb4f 100644\n--- a/src/optimizer/join_order_optimizer.cpp\n+++ b/src/optimizer/join_order_optimizer.cpp\n@@ -711,15 +711,16 @@ unique_ptr<LogicalOperator> JoinOrderOptimizer::Optimize(unique_ptr<LogicalOpera\n \t\t\t\t\t\tquery_graph.CreateEdge(filter_info->left_set, filter_info->right_set, filter_info);\n \t\t\t\t\t\tquery_graph.CreateEdge(filter_info->right_set, filter_info->left_set, filter_info);\n \t\t\t\t\t} else {\n+\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t// the sets are not disjoint, we create two sets of edges\n-\t\t\t\t\t\tauto left_difference = set_manager.Difference(filter_info->left_set, filter_info->right_set);\n-\t\t\t\t\t\tauto right_difference = set_manager.Difference(filter_info->right_set, filter_info->left_set);\n-\t\t\t\t\t\t// -> LEFT <-> RIGHT \\ LEFT\n-\t\t\t\t\t\tquery_graph.CreateEdge(filter_info->left_set, right_difference, filter_info);\n-\t\t\t\t\t\tquery_graph.CreateEdge(right_difference, filter_info->left_set, filter_info);\n-\t\t\t\t\t\t// -> RIGHT <-> LEFT \\ RIGHT\n-\t\t\t\t\t\tquery_graph.CreateEdge(left_difference, filter_info->right_set, filter_info);\n-\t\t\t\t\t\tquery_graph.CreateEdge(filter_info->right_set, left_difference, filter_info);\n+\t\t\t\t\t\t// auto left_difference = set_manager.Difference(filter_info->left_set, filter_info->right_set);\n+\t\t\t\t\t\t// auto right_difference = set_manager.Difference(filter_info->right_set, filter_info->left_set);\n+\t\t\t\t\t\t// // -> LEFT <-> RIGHT \\ LEFT\n+\t\t\t\t\t\t// query_graph.CreateEdge(filter_info->left_set, right_difference, filter_info);\n+\t\t\t\t\t\t// query_graph.CreateEdge(right_difference, filter_info->left_set, filter_info);\n+\t\t\t\t\t\t// // -> RIGHT <-> LEFT \\ RIGHT\n+\t\t\t\t\t\t// query_graph.CreateEdge(left_difference, filter_info->right_set, filter_info);\n+\t\t\t\t\t\t// query_graph.CreateEdge(filter_info->right_set, left_difference, filter_info);\n \t\t\t\t\t}\n \t\t\t\t\tcontinue;\n \t\t\t\t}\ndiff --git a/src/parser/transform/expression/transform_operator.cpp b/src/parser/transform/expression/transform_operator.cpp\nindex 9425a8ed9a9e..13ee2dc71054 100644\n--- a/src/parser/transform/expression/transform_operator.cpp\n+++ b/src/parser/transform/expression/transform_operator.cpp\n@@ -47,10 +47,10 @@ unique_ptr<ParsedExpression> Transformer::TransformBinaryOperator(string op, uni\n \tchildren.push_back(move(right));\n \n \tif (op == \"~\" || op == \"!~\") {\n-\t\t// rewrite SIMILAR TO into regexp_matches('asdf', '.*sd.*')\n+\t\t// rewrite 'asdf' SIMILAR TO '.*sd.*' into regexp_full_match('asdf', '.*sd.*')\n \t\tbool invert_similar = op == \"!~\";\n \n-\t\tauto result = make_unique<FunctionExpression>(schema, \"regexp_matches\", children);\n+\t\tauto result = make_unique<FunctionExpression>(schema, \"regexp_full_match\", children);\n \t\tif (invert_similar) {\n \t\t\treturn make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(result));\n \t\t} else {\n@@ -132,7 +132,7 @@ unique_ptr<ParsedExpression> Transformer::TransformAExpr(PGAExpr *root) {\n \t\t\treturn make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(compare_between));\n \t\t}\n \t} break;\n-\t// rewrite SIMILAR TO into regexp_matches('asdf', '.*sd.*')\n+\t// rewrite SIMILAR TO into regexp_full_match('asdf', '.*sd.*')\n \tcase PG_AEXPR_SIMILAR: {\n \t\tauto left_expr = TransformExpression(root->lexpr);\n \t\tauto right_expr = TransformExpression(root->rexpr);\n@@ -160,7 +160,7 @@ unique_ptr<ParsedExpression> Transformer::TransformAExpr(PGAExpr *root) {\n \t\t\tinvert_similar = true;\n \t\t}\n \t\tconst auto schema = DEFAULT_SCHEMA;\n-\t\tconst auto regex_function = \"regexp_matches\";\n+\t\tconst auto regex_function = \"regexp_full_match\";\n \t\tauto result = make_unique<FunctionExpression>(schema, regex_function, children);\n \n \t\tif (invert_similar) {\ndiff --git a/src/parser/transform/statement/transform_create_table.cpp b/src/parser/transform/statement/transform_create_table.cpp\nindex d3a600ecfac0..9b3a2af5285e 100644\n--- a/src/parser/transform/statement/transform_create_table.cpp\n+++ b/src/parser/transform/statement/transform_create_table.cpp\n@@ -29,8 +29,9 @@ unique_ptr<CreateStatement> Transformer::TransformCreateTable(PGNode *node) {\n \t    stmt->oncommit != PGOnCommitAction::PG_ONCOMMIT_NOOP) {\n \t\tthrow NotImplementedException(\"Only ON COMMIT PRESERVE ROWS is supported\");\n \t}\n-\n-\tassert(stmt->tableElts);\n+\tif (!stmt->tableElts) {\n+\t\tthrow ParserException(\"Table must have at least one column!\");\n+\t}\n \n \tfor (auto c = stmt->tableElts->head; c != NULL; c = lnext(c)) {\n \t\tauto node = reinterpret_cast<PGNode *>(c->data.ptr_value);\ndiff --git a/src/parser/transform/tableref/transform_join.cpp b/src/parser/transform/tableref/transform_join.cpp\nindex 05a49137c10a..75cfebb36a27 100644\n--- a/src/parser/transform/tableref/transform_join.cpp\n+++ b/src/parser/transform/tableref/transform_join.cpp\n@@ -22,6 +22,10 @@ unique_ptr<TableRef> Transformer::TransformJoin(PGJoinExpr *root) {\n \t\tresult->type = JoinType::OUTER;\n \t\tbreak;\n \t}\n+\tcase PG_JOIN_RIGHT: {\n+\t\tresult->type = JoinType::RIGHT;\n+\t\tbreak;\n+\t}\n \tcase PG_JOIN_SEMI: {\n \t\tresult->type = JoinType::SEMI;\n \t\tbreak;\ndiff --git a/src/planner/binder/tableref/plan_joinref.cpp b/src/planner/binder/tableref/plan_joinref.cpp\nindex 0c503135c464..757266b601ac 100644\n--- a/src/planner/binder/tableref/plan_joinref.cpp\n+++ b/src/planner/binder/tableref/plan_joinref.cpp\n@@ -143,6 +143,10 @@ unique_ptr<LogicalOperator> LogicalComparisonJoin::CreateJoin(JoinType type, uni\n unique_ptr<LogicalOperator> Binder::CreatePlan(BoundJoinRef &ref) {\n \tauto left = CreatePlan(*ref.left);\n \tauto right = CreatePlan(*ref.right);\n+\tif (ref.type == JoinType::RIGHT) {\n+\t\tref.type = JoinType::LEFT;\n+\t\tstd::swap(left, right);\n+\t}\n \n \tif (ref.type == JoinType::INNER) {\n \t\t// inner join, generate a cross product + filter\n",
  "test_patch": "diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp\nindex c12417629cf7..7486d56badc7 100644\n--- a/test/rigger/test_rigger.cpp\n+++ b/test/rigger/test_rigger.cpp\n@@ -38,8 +38,7 @@ TEST_CASE(\"Test queries found by Rigger that cause problems in other systems\", \"\n \tSECTION(\"#8 Query with RIGHT JOIN causes a server panic\") {\n \t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n \t\tREQUIRE_NO_FAIL(con.Query(\"CREATE VIEW v0(c0) AS SELECT 0 FROM t0 ORDER BY -t0.c0;\"));\n-\t\t// FIXME: right join not supported\n-\t\tREQUIRE_FAIL(con.Query(\"SELECT * FROM v0 RIGHT JOIN t0 ON false;\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"SELECT * FROM v0 RIGHT JOIN t0 ON false;\"));\n \t}\n \t// SQLite\n \tSECTION(\"#15 './' LIKE './' does not match\") {\n@@ -195,4 +194,63 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tresult = con.Query(\"SELECT t0.c0 FROM t0, t1 WHERE t1.c0 < t0.c0;\");\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n \t}\n+\tSECTION(\"503\") {\n+\t\t// RIGHT JOIN with a predicate that compares two integer columns results in an \"Unhandled type\" error\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 INT);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 RIGHT JOIN t1 ON t0.c0!=t1.c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {}));\n+\t}\n+\tSECTION(\"504\") {\n+\t\t// INSERT results in an error \"Not implemented: Cannot create data from this type\"\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 BOOLEAN, c1 INT, PRIMARY KEY(c0, c1));\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c1, c0) VALUES (0, 0);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {false}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {0}));\n+\t}\n+\tSECTION(\"505\") {\n+\t\t// A RIGHT JOIN unexpectedly fetches rows\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c1 BOOLEAN);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (1);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 RIGHT JOIN t1 on true;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {}));\n+\t}\n+\tSECTION(\"506\") {\n+\t\t// Query results in an error \"INTERNAL: Failed to bind column reference \"c0\" [5.0] (bindings: [6.0])\"\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"SELECT * FROM t1 JOIN t0 ON t1.c0 < t1.c0 - t0.c0 WHERE t0.c0 <= t1.c0;\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"SELECT * FROM t1 JOIN t0 ON t0.c0 + t1.c0 < t1.c0 - t0.c0;\"));\n+\t}\n+\tSECTION(\"507\") {\n+\t\t// Creating an empty table results in a crash\n+\t\tREQUIRE_FAIL(con.Query(\"CREATE TABLE t0();\"));\n+\t}\n+\tSECTION(\"508\") {\n+\t\t// LEFT JOIN on column with NULL value results in a segmentation fault\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1(c0) VALUES (NULL);\"));\n+\t\tresult = con.Query(\"SELECT * FROM t1 LEFT JOIN t0 ON t0.c0=t1.c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {Value()}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {Value()}));\n+\t}\n+\tSECTION(\"510\") {\n+\t\t// SIMILAR TO results in an incorrect result\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (-10);\"));\n+\t\tresult = con.Query(\"SELECT '-10' SIMILAR TO '0';\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {false}));\n+\t\tresult = con.Query(\"SELECT t0.c0 SIMILAR TO 0 FROM t0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {false}));\n+\t\tresult = con.Query(\"SELECT t0.c0 NOT SIMILAR TO 0 FROM t0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {true}));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 NOT SIMILAR TO 0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {-10}));\n+\t}\n }\ndiff --git a/test/sql/constraints/test_primarykey.cpp b/test/sql/constraints/test_primarykey.cpp\nindex b695ebc789bc..c1a6e187b50b 100644\n--- a/test/sql/constraints/test_primarykey.cpp\n+++ b/test/sql/constraints/test_primarykey.cpp\n@@ -449,3 +449,19 @@ TEST_CASE(\"PRIMARY KEY constraint on multiple string columns with overlapping va\n \t//! this should  work since it won't cause a duplicate\n \tREQUIRE_NO_FAIL(con.Query(\"UPDATE tst SET b='hell' WHERE b='hel'\"));\n }\n+\n+TEST_CASE(\"Multi-column boolean PRIMARY KEY constraint\", \"[constraints]\") {\n+\tunique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE integers(i INTEGER, j BOOLEAN, PRIMARY KEY(i, j))\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO integers VALUES (1, false), (1, true), (2, false)\"));\n+\t// duplicate value!\n+\tREQUIRE_FAIL(con.Query(\"INSERT INTO integers VALUES (1, false)\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO integers VALUES (2, true)\"));\n+\n+\tresult = con.Query(\"SELECT * FROM integers ORDER BY 1, 2\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 1, 2, 2}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {false, true, false, true}));\n+}\ndiff --git a/test/sql/function/test_regex.cpp b/test/sql/function/test_regex.cpp\nindex 6c230933aa6f..ae4ba928a6c8 100644\n--- a/test/sql/function/test_regex.cpp\n+++ b/test/sql/function/test_regex.cpp\n@@ -23,6 +23,11 @@ TEST_CASE(\"regex search test\", \"[regex]\") {\n \t// partial matches okay\n \tresult = con.Query(\"SELECT regexp_matches('asdf', 'sd')\");\n \tREQUIRE(CHECK_COLUMN(result, 0, {true}));\n+\t// full match requires entire match\n+\tresult = con.Query(\"SELECT regexp_full_match('asdf', 'sd')\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {false}));\n+\tresult = con.Query(\"SELECT regexp_full_match('asdf', '.sd.')\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {true}));\n \n \tresult = con.Query(\"SELECT regexp_matches('asdf', '^sdf$')\");\n \tREQUIRE(CHECK_COLUMN(result, 0, {false}));\ndiff --git a/test/sql/index/test_art_index.cpp b/test/sql/index/test_art_index.cpp\nindex 6ff0aa08e0c4..f78c1bbb67f4 100644\n--- a/test/sql/index/test_art_index.cpp\n+++ b/test/sql/index/test_art_index.cpp\n@@ -1746,13 +1746,8 @@ TEST_CASE(\"Index Exceptions\", \"[art]\") {\n \tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE integers(i integer, j integer, k BOOLEAN)\"));\n \n \tREQUIRE_FAIL(con.Query(\"CREATE INDEX ON integers(i)\"));\n-\n \tREQUIRE_FAIL(con.Query(\"CREATE INDEX i_index ON integers(i COLLATE \\\"de_DE\\\")\"));\n-\n \tREQUIRE_FAIL(con.Query(\"CREATE INDEX i_index ON integers using blabla(i)\"));\n-\n-\tREQUIRE_FAIL(con.Query(\"CREATE INDEX i_index ON integers(k)\"));\n-\n \tREQUIRE_FAIL(con.Query(\"CREATE INDEX i_index ON integers(f)\"));\n }\n \ndiff --git a/test/sql/join/test_left_outer_join.cpp b/test/sql/join/test_left_outer_join.cpp\nindex bee2bbd51f8d..3b160d764835 100644\n--- a/test/sql/join/test_left_outer_join.cpp\n+++ b/test/sql/join/test_left_outer_join.cpp\n@@ -24,6 +24,15 @@ TEST_CASE(\"Test LEFT OUTER JOIN\", \"[join]\") {\n \tREQUIRE(CHECK_COLUMN(result, 2, {1, 2, Value()}));\n \tREQUIRE(CHECK_COLUMN(result, 3, {10, 20, Value()}));\n \n+\t// RIGHT OUTER JOIN is just LEFT OUTER JOIN but with arguments reversed\n+\t// with one caveat: SELECT * will project the columns of the LHS first!\n+\tresult = con.Query(\"SELECT * FROM integers2 RIGHT OUTER JOIN integers ON \"\n+\t                   \"integers.i=integers2.k ORDER BY i\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 2, Value()}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {10, 20, Value()}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {1, 2, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {2, 3, 4}));\n+\n \t// WHERE happens AFTER the join, thus [where k IS NOT NULL] filters out any tuples with generated NULL values from\n \t// the LEFT OUTER JOIN. Because of this, this join is equivalent to an inner join.\n \tresult = con.Query(\"SELECT * FROM integers LEFT OUTER JOIN integers2 ON \"\ndiff --git a/test/sql/simple/test_join.cpp b/test/sql/simple/test_join.cpp\nindex 949394c802eb..b86664860dcc 100644\n--- a/test/sql/simple/test_join.cpp\n+++ b/test/sql/simple/test_join.cpp\n@@ -513,3 +513,35 @@ TEST_CASE(\"Test joins with various columns that are only used in the join\", \"[jo\n \tresult = con.Query(\"SELECT (TRUE OR a1.a=a2.b) FROM test a1, test a2 WHERE a1.a=11 AND a2.a>=10\");\n \tREQUIRE(CHECK_COLUMN(result, 0, {true, true, true}));\n }\n+\n+TEST_CASE(\"Test joins with comparisons involving both sides of the join\", \"[joins]\") {\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\tunique_ptr<QueryResult> result;\n+\tcon.EnableQueryVerification();\n+\n+\t// create tables\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE test (a INTEGER, b INTEGER);\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO test VALUES (4, 1), (2, 2)\"));\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE test2 (b INTEGER, c INTEGER);\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO test2 VALUES (1, 2), (3, 0)\"));\n+\n+\tresult = con.Query(\"SELECT * FROM test JOIN test2 ON test.a+test2.c=test.b+test2.b\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {4}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {1}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {3}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {0}));\n+\n+\tresult = con.Query(\"SELECT * FROM test LEFT JOIN test2 ON test.a+test2.c=test.b+test2.b ORDER BY 1\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {2, 4}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {2, 1}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {Value(), 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {Value(), 0}));\n+\n+\tresult = con.Query(\"SELECT * FROM test RIGHT JOIN test2 ON test.a+test2.c=test.b+test2.b ORDER BY 1\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value(), 4}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value(), 1}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {1, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {2, 0}));\n+}\ndiff --git a/test/sql/simple/test_similar.cpp b/test/sql/simple/test_similar.cpp\nindex a42c781ae09f..4500c6b5c262 100644\n--- a/test/sql/simple/test_similar.cpp\n+++ b/test/sql/simple/test_similar.cpp\n@@ -54,10 +54,13 @@ TEST_CASE(\"Test scalar SIMILAR TO statement\", \"[similar]\") {\n \tresult = connection.Query(\"SELECT 'aaa' !~ 'bbb'\");\n \tREQUIRE(CHECK_COLUMN(result, 0, {Value::BOOLEAN(true)}));\n \n+\t// similar to must match entire expression\n \tresult = connection.Query(\"SELECT 'aaa' ~ '^a'\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::BOOLEAN(false)}));\n+\tresult = connection.Query(\"SELECT 'aaa' ~ '^a+'\");\n \tREQUIRE(CHECK_COLUMN(result, 0, {Value::BOOLEAN(true)}));\n \n-\tresult = connection.Query(\"SELECT 'aaa' ~ '(a|b)'\");\n+\tresult = connection.Query(\"SELECT 'aaa' ~ '(a|b)*'\");\n \tREQUIRE(CHECK_COLUMN(result, 0, {Value::BOOLEAN(true)}));\n \n \tresult = connection.Query(\"SELECT 'abc' ~ '^(b|c)'\");\n",
  "problem_statement": "SIMILAR TO results in an incorrect result\nConsider the following statements:\r\n\r\n```sql\r\nCREATE TABLE t0(c0 INT);\r\nINSERT INTO t0(c0) VALUES (-10);\r\nSELECT * FROM t0 WHERE t0.c0 NOT SIMILAR TO 0; -- expected: {-10}, actual: {}\r\n```\r\nUnexpectedly, the row in `t0` is not fetched. As expected, the negated predicate does not fetch any rows:\r\n```sql\r\nSELECT * FROM t0 WHERE t0.c0 SIMILAR TO 0; -- {}\r\n```\r\n\r\nI'm a bit confused about this case, since DuckDB seems to indicate that the negated predicate should evaluate to TRUE:\r\n```sql\r\nSELECT t0.c0 SIMILAR TO 0 FROM t0; -- true\r\n```\r\n\r\nI found this bug based on the latest master commit (340d867b232b56faf198594e40adba733ecb7bc8).\n",
  "hints_text": "",
  "created_at": "2020-04-11T09:18:04Z"
}