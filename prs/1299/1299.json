{
  "repo": "duckdb/duckdb",
  "pull_number": 1299,
  "instance_id": "duckdb__duckdb-1299",
  "issue_numbers": [
    "1290"
  ],
  "base_commit": "f0406c25b7afb7b5f56c6bf5a06ab4d28f61d9de",
  "patch": "diff --git a/src/include/duckdb/planner/bind_context.hpp b/src/include/duckdb/planner/bind_context.hpp\nindex 4493b8c04ebd..cd96d1d94023 100644\n--- a/src/include/duckdb/planner/bind_context.hpp\n+++ b/src/include/duckdb/planner/bind_context.hpp\n@@ -25,6 +25,11 @@ class Binder;\n class LogicalGet;\n class BoundQueryNode;\n \n+struct UsingColumnSet {\n+\tstring primary_binding;\n+\tunordered_set<string> bindings;\n+};\n+\n //! The BindContext object keeps track of all the tables and columns that are\n //! encountered during the binding process.\n class BindContext {\n@@ -71,10 +76,15 @@ class BindContext {\n \t//! We need this to correctly bind recursive CTEs with multiple references.\n \tvoid AddCTEBinding(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types);\n \n-\t//! Hide a binding\n-\tvoid HideBinding(const string &binding_name, const string &column_name);\n-\t//! Returns true if the given column is hidden from the given binding\n-\tbool BindingIsHidden(const string &binding_name, const string &column_name);\n+\t//! Add an implicit join condition (e.g. USING (x))\n+\tvoid AddUsingBinding(const string &column_name, UsingColumnSet set);\n+\n+\t//! Returns any using column set for the given column name, or nullptr if there is none. On conflict (multiple using column sets with the same name) throw an exception.\n+\tUsingColumnSet *GetUsingBinding(const string &column_name);\n+\t//! Returns any using column set for the given column name, or nullptr if there is none\n+\tUsingColumnSet *GetUsingBinding(const string &column_name, const string &binding_name);\n+\t//! Erase a using binding from the set of using bindings\n+\tvoid RemoveUsingBinding(const string &column_name, UsingColumnSet *set);\n \n \tunordered_map<string, std::shared_ptr<Binding>> GetCTEBindings() {\n \t\treturn cte_bindings;\n@@ -96,15 +106,14 @@ class BindContext {\n \t//! Gets a binding of the specified name. Returns a nullptr and sets the out_error if the binding could not be\n \t//! found.\n \tBinding *GetBinding(const string &name, string &out_error);\n-\tvoid GenerateAllColumnExpressions(vector<unique_ptr<ParsedExpression>> &new_select_list, Binding *binding);\n \n private:\n \t//! The set of bindings\n \tunordered_map<string, unique_ptr<Binding>> bindings;\n \t//! The list of bindings in insertion order\n \tvector<std::pair<string, Binding *>> bindings_list;\n-\t//! The set of hidden columns from the result\n-\tqualified_column_set_t hidden_columns;\n+\t//! The set of columns used in USING join conditions\n+\tunordered_map<string, vector<UsingColumnSet>> using_columns;\n \n \t//! The set of CTE bindings\n \tunordered_map<string, std::shared_ptr<Binding>> cte_bindings;\ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 4d4f21b44858..79b60323734f 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -219,6 +219,9 @@ class Binder {\n \tunique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,\n \t                                                       vector<LogicalType> &target_types,\n \t                                                       unique_ptr<LogicalOperator> op);\n+\n+\tstring FindBinding(const string &using_column, const string &join_side);\n+\tbool TryFindBinding(const string &using_column, const string &join_side, string &result);\n };\n \n } // namespace duckdb\ndiff --git a/src/parser/transform/expression/transform_coalesce.cpp b/src/parser/transform/expression/transform_coalesce.cpp\nindex 4b362c06dd92..be093aa6d563 100644\n--- a/src/parser/transform/expression/transform_coalesce.cpp\n+++ b/src/parser/transform/expression/transform_coalesce.cpp\n@@ -1,4 +1,3 @@\n-#include \"duckdb/parser/expression/case_expression.hpp\"\n #include \"duckdb/parser/expression/operator_expression.hpp\"\n #include \"duckdb/parser/transformer.hpp\"\n \n@@ -14,31 +13,14 @@ unique_ptr<ParsedExpression> Transformer::TransformCoalesce(PGAExpr *root) {\n \t}\n \tauto coalesce_args = reinterpret_cast<PGList *>(root->lexpr);\n \tD_ASSERT(coalesce_args->length > 0); // parser ensures this already\n-\tif (coalesce_args->length == 1) {\n-\t\t// special case, dont need to do anything, bug #1222\n-\t\treturn TransformExpression(reinterpret_cast<PGNode *>(coalesce_args->head->data.ptr_value));\n-\t}\n-\tauto exp_root = make_unique<CaseExpression>();\n-\tauto cur_root = exp_root.get();\n-\tfor (auto cell = coalesce_args->head; cell && cell->next; cell = cell->next) {\n+\n+\tauto coalesce_op = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);\n+\tfor (auto cell = coalesce_args->head; cell; cell = cell->next) {\n \t\t// get the value of the COALESCE\n \t\tauto value_expr = TransformExpression(reinterpret_cast<PGNode *>(cell->data.ptr_value));\n-\t\t// perform an IS NOT NULL comparison with the value here\n-\t\tcur_root->check = make_unique<OperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, value_expr->Copy());\n-\t\t// if IS NOT NULL, we output the value\n-\t\tcur_root->result_if_true = move(value_expr);\n-\t\tif (cell->next->next == nullptr) {\n-\t\t\t// if there is no next in the chain, the COALESCE ends there\n-\t\t\tcur_root->result_if_false = TransformExpression(reinterpret_cast<PGNode *>(cell->next->data.ptr_value));\n-\t\t} else {\n-\t\t\t// more COALESCE parameters remain, create a nested CASE statement\n-\t\t\tauto next_case = make_unique<CaseExpression>();\n-\t\t\tauto case_ptr = next_case.get();\n-\t\t\tcur_root->result_if_false = move(next_case);\n-\t\t\tcur_root = case_ptr;\n-\t\t}\n+\t\tcoalesce_op->children.push_back(move(value_expr));\n \t}\n-\treturn move(exp_root);\n+\treturn move(coalesce_op);\n }\n \n } // namespace duckdb\ndiff --git a/src/planner/bind_context.cpp b/src/planner/bind_context.cpp\nindex 05aa59739766..d468146bd47d 100644\n--- a/src/planner/bind_context.cpp\n+++ b/src/planner/bind_context.cpp\n@@ -4,6 +4,7 @@\n #include \"duckdb/parser/tableref/subqueryref.hpp\"\n #include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n #include \"duckdb/planner/bound_query_node.hpp\"\n+#include \"duckdb/parser/expression/operator_expression.hpp\"\n \n #include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/common/pair.hpp\"\n@@ -16,13 +17,12 @@ string BindContext::GetMatchingBinding(const string &column_name) {\n \tstring result;\n \tfor (auto &kv : bindings) {\n \t\tauto binding = kv.second.get();\n+\t\tauto is_using_binding = GetUsingBinding(column_name, kv.first);\n+\t\tif (is_using_binding) {\n+\t\t\tcontinue;\n+\t\t}\n \t\tif (binding->HasMatchingBinding(column_name)) {\n-\t\t\t// check if the binding is ignored\n-\t\t\tif (BindingIsHidden(kv.first, column_name)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tif (!result.empty()) {\n+\t\t\tif (!result.empty() || is_using_binding) {\n \t\t\t\tthrow BinderException(\"Ambiguous reference to column name \\\"%s\\\" (use: \\\"%s.%s\\\" \"\n \t\t\t\t                      \"or \\\"%s.%s\\\")\",\n \t\t\t\t                      column_name, result, column_name, kv.first, column_name);\n@@ -45,13 +45,67 @@ vector<string> BindContext::GetSimilarBindings(const string &column_name) {\n \treturn StringUtil::TopNStrings(scores);\n }\n \n-void BindContext::HideBinding(const string &binding_name, const string &column_name) {\n-\thidden_columns.insert(QualifiedColumnName(binding_name, column_name));\n+void BindContext::AddUsingBinding(const string &column_name, UsingColumnSet set) {\n+\tusing_columns[column_name].push_back(move(set));\n+}\n+\n+UsingColumnSet *BindContext::GetUsingBinding(const string &column_name) {\n+\tauto entry = using_columns.find(column_name);\n+\tif (entry == using_columns.end()) {\n+\t\treturn nullptr;\n+\t}\n+\tif (entry->second.size() > 1) {\n+\t\tstring error = \"Ambiguous column reference: column \\\"\" + column_name + \"\\\" can refer to either:\\n\";\n+\t\tfor(auto &using_set : entry->second) {\n+\t\t\tstring result_bindings;\n+\t\t\tfor(auto &binding : using_set.bindings) {\n+\t\t\t\tif (result_bindings.empty()) {\n+\t\t\t\t\tresult_bindings = \"[\";\n+\t\t\t\t} else {\n+\t\t\t\t\tresult_bindings += \", \";\n+\t\t\t\t}\n+\t\t\t\tresult_bindings += binding + \".\" + column_name;\n+\t\t\t}\n+\t\t\terror += result_bindings + \"]\";\n+\t\t}\n+\t\tthrow BinderException(error);\n+\t}\n+\treturn &entry->second[0];\n+}\n+\n+UsingColumnSet *BindContext::GetUsingBinding(const string &column_name, const string &binding_name) {\n+\tif (binding_name.empty()) {\n+\t\treturn GetUsingBinding(column_name);\n+\t}\n+\tauto entry = using_columns.find(column_name);\n+\tif (entry == using_columns.end()) {\n+\t\treturn nullptr;\n+\t}\n+\tfor(auto &using_set : entry->second) {\n+\t\tauto &bindings = using_set.bindings;\n+\t\tif (bindings.find(binding_name) != bindings.end()) {\n+\t\t\treturn &using_set;\n+\t\t}\n+\t}\n+\treturn nullptr;\n }\n \n-bool BindContext::BindingIsHidden(const string &binding_name, const string &column_name) {\n-\tQualifiedColumnName qcolumn(binding_name, column_name);\n-\treturn hidden_columns.find(qcolumn) != hidden_columns.end();\n+void BindContext::RemoveUsingBinding(const string &column_name, UsingColumnSet *set) {\n+\tif (!set) {\n+\t\treturn;\n+\t}\n+\tauto entry = using_columns.find(column_name);\n+\tD_ASSERT(entry != using_columns.end());\n+\tauto &bindings = entry->second;\n+\tfor(size_t i = 0; i < bindings.size(); i++) {\n+\t\tif (&bindings[i] == set) {\n+\t\t\tbindings.erase(bindings.begin() + i);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\tif (bindings.empty()) {\n+\t\tusing_columns.erase(column_name);\n+\t}\n }\n \n unordered_set<string> BindContext::GetMatchingBindings(const string &column_name) {\n@@ -102,27 +156,43 @@ BindResult BindContext::BindColumn(ColumnRefExpression &colref, idx_t depth) {\n \treturn binding->Bind(colref, depth);\n }\n \n-void BindContext::GenerateAllColumnExpressions(vector<unique_ptr<ParsedExpression>> &new_select_list,\n-                                               Binding *binding) {\n-\tfor (auto &column_name : binding->names) {\n-\t\tD_ASSERT(!column_name.empty());\n-\t\tif (BindingIsHidden(binding->alias, column_name)) {\n-\t\t\tcontinue;\n-\t\t}\n-\t\tnew_select_list.push_back(make_unique<ColumnRefExpression>(column_name, binding->alias));\n-\t}\n-}\n-\n void BindContext::GenerateAllColumnExpressions(vector<unique_ptr<ParsedExpression>> &new_select_list,\n                                                string relation_name) {\n \tif (bindings_list.size() == 0) {\n \t\tthrow BinderException(\"SELECT * expression without FROM clause!\");\n \t}\n \tif (relation_name == \"\") { // SELECT * case\n-\t\t// we have to bind the tables and subqueries in order of table_index\n+\t\t// bind all expressions of each table in-order\n+\t\tunordered_set<UsingColumnSet*> handled_using_columns;\n \t\tfor (auto &entry : bindings_list) {\n \t\t\tauto binding = entry.second;\n-\t\t\tGenerateAllColumnExpressions(new_select_list, binding);\n+\t\t\tfor (auto &column_name : binding->names) {\n+\t\t\t\t// check if this column is a USING column\n+\t\t\t\tauto using_binding = GetUsingBinding(column_name, binding->alias);\n+\t\t\t\tif (using_binding) {\n+\t\t\t\t\t// it is!\n+\t\t\t\t\t// check if we have already emitted the using column\n+\t\t\t\t\tif (handled_using_columns.find(using_binding) != handled_using_columns.end()) {\n+\t\t\t\t\t\t// we have! bail out\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\t// we have not! output the using column\n+\t\t\t\t\tif (using_binding->primary_binding.empty()) {\n+\t\t\t\t\t\t// no primary binding: output a coalesce\n+\t\t\t\t\t\tauto coalesce = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);\n+\t\t\t\t\t\tfor(auto &child_binding : using_binding->bindings) {\n+\t\t\t\t\t\t\tcoalesce->children.push_back(make_unique<ColumnRefExpression>(column_name, child_binding));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tnew_select_list.push_back(move(coalesce));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// primary binding: output the qualified column ref\n+\t\t\t\t\t\tnew_select_list.push_back(make_unique<ColumnRefExpression>(column_name, using_binding->primary_binding));\n+\t\t\t\t\t}\n+\t\t\t\t\thandled_using_columns.insert(using_binding);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tnew_select_list.push_back(make_unique<ColumnRefExpression>(column_name, binding->alias));\n+\t\t\t}\n \t\t}\n \t} else { // SELECT tbl.* case\n \t\tstring error;\n@@ -130,7 +200,9 @@ void BindContext::GenerateAllColumnExpressions(vector<unique_ptr<ParsedExpressio\n \t\tif (!binding) {\n \t\t\tthrow BinderException(error);\n \t\t}\n-\t\tGenerateAllColumnExpressions(new_select_list, binding);\n+\t\tfor (auto &column_name : binding->names) {\n+\t\t\tnew_select_list.push_back(make_unique<ColumnRefExpression>(column_name, binding->alias));\n+\t\t}\n \t}\n }\n \n@@ -199,8 +271,17 @@ void BindContext::AddContext(BindContext other) {\n \tfor (auto &binding : other.bindings_list) {\n \t\tbindings_list.push_back(move(binding));\n \t}\n-\tfor (auto &hidden_column : other.hidden_columns) {\n-\t\thidden_columns.insert(hidden_column);\n+\tfor (auto &entry : other.using_columns) {\n+\t\tfor(auto &alias : entry.second) {\n+#ifdef DEBUG\n+\t\t\tfor(auto &other_alias : using_columns[entry.first]) {\n+\t\t\t\tfor(auto &col : alias.bindings) {\n+\t\t\t\t\tD_ASSERT(other_alias.bindings.find(col) == other_alias.bindings.end());\n+\t\t\t\t}\n+\t\t\t}\n+#endif\n+\t\t\tusing_columns[entry.first].push_back(alias);\n+\t\t}\n \t}\n }\n \ndiff --git a/src/planner/binder/expression/bind_columnref_expression.cpp b/src/planner/binder/expression/bind_columnref_expression.cpp\nindex f3c778b841fc..9f2deff669bc 100644\n--- a/src/planner/binder/expression/bind_columnref_expression.cpp\n+++ b/src/planner/binder/expression/bind_columnref_expression.cpp\n@@ -2,6 +2,7 @@\n #include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n+#include \"duckdb/parser/expression/operator_expression.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n \n namespace duckdb {\n@@ -11,6 +12,24 @@ BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref, idx_t d\n \t// individual column reference\n \t// resolve to either a base table or a subquery expression\n \tif (colref.table_name.empty()) {\n+\t\tauto using_binding = binder.bind_context.GetUsingBinding(colref.column_name);\n+\t\tif (using_binding) {\n+\t\t\t// we are referencing a USING column\n+\t\t\t// check if we can refer to one of the base columns directly\n+\t\t\tunique_ptr<Expression> expression;\n+\t\t\tif (!using_binding->primary_binding.empty()) {\n+\t\t\t\t// we can! just assign the table name and re-bind\n+\t\t\t\tcolref.table_name = using_binding->primary_binding;\n+\t\t\t\treturn BindExpression(colref, depth);\n+\t\t\t} else {\n+\t\t\t\t// we cannot! we need to bind this as a coalesce between all the relevant columns\n+\t\t\t\tauto coalesce = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);\n+\t\t\t\tfor(auto &entry : using_binding->bindings) {\n+\t\t\t\t\tcoalesce->children.push_back(make_unique<ColumnRefExpression>(colref.column_name, entry));\n+\t\t\t\t}\n+\t\t\t\treturn BindExpression(*coalesce, depth);\n+\t\t\t}\n+\t\t}\n \t\t// no table name: find a binding that contains this\n \t\tif (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {\n \t\t\t// priority to macro parameter bindings TODO: throw a warning when this name conflicts\ndiff --git a/src/planner/binder/expression/bind_operator_expression.cpp b/src/planner/binder/expression/bind_operator_expression.cpp\nindex 23771bab6359..a1bbda1aa545 100644\n--- a/src/planner/binder/expression/bind_operator_expression.cpp\n+++ b/src/planner/binder/expression/bind_operator_expression.cpp\n@@ -1,6 +1,7 @@\n #include \"duckdb/parser/expression/operator_expression.hpp\"\n #include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n #include \"duckdb/planner/expression/bound_operator_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_case_expression.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n \n namespace duckdb {\n@@ -13,6 +14,9 @@ static LogicalType ResolveNotType(OperatorExpression &op, vector<BoundExpression\n }\n \n static LogicalType ResolveInType(OperatorExpression &op, vector<BoundExpression *> &children) {\n+\tif (children.size() == 0) {\n+\t\treturn LogicalType::BOOLEAN;\n+\t}\n \t// get the maximum type from the children\n \tLogicalType max_type = children[0]->expr->return_type;\n \tfor (idx_t i = 1; i < children.size(); i++) {\n@@ -23,7 +27,7 @@ static LogicalType ResolveInType(OperatorExpression &op, vector<BoundExpression\n \t\tchildren[i]->expr = BoundCastExpression::AddCastToType(move(children[i]->expr), max_type);\n \t}\n \t// (NOT) IN always returns a boolean\n-\treturn LogicalType(LogicalTypeId::BOOLEAN);\n+\treturn LogicalType::BOOLEAN;\n }\n \n static LogicalType ResolveOperatorType(OperatorExpression &op, vector<BoundExpression *> &children) {\n@@ -34,6 +38,7 @@ static LogicalType ResolveOperatorType(OperatorExpression &op, vector<BoundExpre\n \t\treturn LogicalType::BOOLEAN;\n \tcase ExpressionType::COMPARE_IN:\n \tcase ExpressionType::COMPARE_NOT_IN:\n+\tcase ExpressionType::OPERATOR_COALESCE:\n \t\treturn ResolveInType(op, children);\n \tdefault:\n \t\tD_ASSERT(op.type == ExpressionType::OPERATOR_NOT);\n@@ -58,6 +63,25 @@ BindResult ExpressionBinder::BindExpression(OperatorExpression &op, idx_t depth)\n \t}\n \t// now resolve the types\n \tLogicalType result_type = ResolveOperatorType(op, children);\n+\tif (op.type == ExpressionType::OPERATOR_COALESCE) {\n+\t\tif (children.size() == 0) {\n+\t\t\treturn BindResult(\"COALESCE needs at least one child\");\n+\t\t}\n+\t\tunique_ptr<Expression> current_node;\n+\t\tfor(size_t i = children.size(); i > 0; i--) {\n+\t\t\tauto child = move(children[i - 1]->expr);\n+\t\t\tif (!current_node) {\n+\t\t\t\t// no node yet: simply move the child\n+\t\t\t\tcurrent_node = move(child);\n+\t\t\t} else {\n+\t\t\t\t// create a case statement\n+\t\t\t\tauto check = make_unique<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);\n+\t\t\t\tcheck->children.push_back(child->Copy());\n+\t\t\t\tcurrent_node = make_unique<BoundCaseExpression>(move(check), move(child), move(current_node));\n+\t\t\t}\n+\t\t}\n+\t\treturn BindResult(move(current_node));\n+\t}\n \n \tauto result = make_unique<BoundOperatorExpression>(op.type, result_type);\n \tfor (auto &child : children) {\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 72c8bedc5792..d975b5f5f958 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -200,8 +200,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {\n \t\t\t// * statement, expand to all columns from the FROM clause\n \t\t\tbind_context.GenerateAllColumnExpressions(new_select_list);\n \t\t} else if (select_element->GetExpressionType() == ExpressionType::TABLE_STAR) {\n-\t\t\tauto table_star =\n-\t\t\t    (TableStarExpression *)select_element.get(); // TODO this cast to explicit class is a bit dirty?\n+\t\t\tauto table_star = (TableStarExpression *)select_element.get();\n \t\t\tbind_context.GenerateAllColumnExpressions(new_select_list, table_star->relation_name);\n \t\t} else {\n \t\t\t// regular statement, add it to the list\ndiff --git a/src/planner/binder/tableref/bind_joinref.cpp b/src/planner/binder/tableref/bind_joinref.cpp\nindex ca4523fd417c..afb425b549f2 100644\n--- a/src/planner/binder/tableref/bind_joinref.cpp\n+++ b/src/planner/binder/tableref/bind_joinref.cpp\n@@ -2,23 +2,82 @@\n #include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/planner/expression_binder/where_binder.hpp\"\n #include \"duckdb/planner/tableref/bound_joinref.hpp\"\n+#include \"duckdb/parser/expression/comparison_expression.hpp\"\n #include \"duckdb/parser/expression/columnref_expression.hpp\"\n #include \"duckdb/parser/expression/constant_expression.hpp\"\n-#include \"duckdb/parser/expression/comparison_expression.hpp\"\n #include \"duckdb/parser/expression/conjunction_expression.hpp\"\n+#include \"duckdb/parser/expression/bound_expression.hpp\"\n \n namespace duckdb {\n \n-static void AddCondition(JoinRef &ref, string left_alias, string right_alias, string column_name) {\n-\tauto left_expr = make_unique<ColumnRefExpression>(column_name, left_alias);\n-\tauto right_expr = make_unique<ColumnRefExpression>(column_name, right_alias);\n-\tauto comp_expr =\n-\t    make_unique<ComparisonExpression>(ExpressionType::COMPARE_EQUAL, move(left_expr), move(right_expr));\n-\tif (!ref.condition) {\n-\t\tref.condition = move(comp_expr);\n+static unique_ptr<ParsedExpression> BindColumn(Binder &binder, ClientContext &context, const string &alias, const string &column_name) {\n+\tauto expr = make_unique_base<ParsedExpression, ColumnRefExpression>(column_name, alias);\n+\tExpressionBinder expr_binder(binder, context);\n+\tauto result = expr_binder.Bind(expr);\n+\treturn make_unique<BoundExpression>(move(result), nullptr);\n+}\n+\n+static unique_ptr<ParsedExpression> AddCondition(ClientContext &context, Binder &left_binder, Binder &right_binder, const string &left_alias, const string &right_alias, const string &column_name) {\n+\tExpressionBinder expr_binder(left_binder, context);\n+\tauto left = BindColumn(left_binder, context, left_alias, column_name);\n+\tauto right = BindColumn(right_binder, context, right_alias, column_name);\n+\treturn make_unique<ComparisonExpression>(ExpressionType::COMPARE_EQUAL, move(left), move(right));\n+}\n+\n+bool Binder::TryFindBinding(const string &using_column, const string &join_side, string &result) {\n+\t// for each using column, get the matching binding\n+\tauto bindings = bind_context.GetMatchingBindings(using_column);\n+\tif (bindings.size() == 0) {\n+\t\treturn false;\n+\t}\n+\t// find the join binding\n+\tfor (auto &binding : bindings) {\n+\t\tif (!result.empty()) {\n+\t\t\tstring error = \"Column name \\\"\" + using_column +\n+\t\t\t\t\t\t\t\"\\\" is ambiguous: it exists more than once on \" + join_side + \" side of join.\\nCandidates:\";\n+\t\t\tfor (auto &binding : bindings) {\n+\t\t\t\terror += \"\\n\\t\" + binding + \".\" + using_column;\n+\t\t\t}\n+\t\t\tthrow BinderException(error);\n+\t\t} else {\n+\t\t\tresult = binding;\n+\t\t}\n+\t}\n+\treturn true;\n+}\n+\n+string Binder::FindBinding(const string &using_column, const string &join_side) {\n+\tstring result;\n+\tif (!TryFindBinding(using_column, join_side, result)) {\n+\t\tthrow BinderException(\"Column \\\"%s\\\" does not exist on %s side of join!\", using_column, join_side);\n+\t}\n+\treturn result;\n+}\n+\n+\n+static void AddUsingBindings(UsingColumnSet &set, UsingColumnSet *input_set, const string &input_binding) {\n+\tif (input_set) {\n+\t\tfor(auto &entry : input_set->bindings) {\n+\t\t\tset.bindings.insert(entry);\n+\t\t}\n \t} else {\n-\t\tref.condition =\n-\t\t    make_unique<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, move(ref.condition), move(comp_expr));\n+\t\tset.bindings.insert(input_binding);\n+\t}\n+}\n+\n+static void SetPrimaryBinding(UsingColumnSet &set, JoinType join_type, const string &left_binding, const string &right_binding) {\n+\tswitch(join_type) {\n+\tcase JoinType::LEFT:\n+\tcase JoinType::INNER:\n+\tcase JoinType::SEMI:\n+\tcase JoinType::ANTI:\n+\t\tset.primary_binding = left_binding;\n+\t\tbreak;\n+\tcase JoinType::RIGHT:\n+\t\tset.primary_binding = right_binding;\n+\t\tbreak;\n+\tdefault:\n+\t\tbreak;\n \t}\n }\n \n@@ -32,6 +91,8 @@ unique_ptr<BoundTableRef> Binder::Bind(JoinRef &ref) {\n \tresult->type = ref.type;\n \tresult->left = left_binder.Bind(*ref.left);\n \tresult->right = right_binder.Bind(*ref.right);\n+\n+\tvector<unique_ptr<ParsedExpression>> extra_conditions;\n \tif (ref.is_natural) {\n \t\t// natural join, figure out which column names are present in both sides of the join\n \t\t// first bind the left hand side and get a list of all the tables and column names\n@@ -39,9 +100,6 @@ unique_ptr<BoundTableRef> Binder::Bind(JoinRef &ref) {\n \t\tauto &lhs_binding_list = left_binder.bind_context.GetBindingsList();\n \t\tfor (auto &binding : lhs_binding_list) {\n \t\t\tfor (auto &column_name : binding.second->names) {\n-\t\t\t\tif (left_binder.bind_context.BindingIsHidden(binding.first, column_name)) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n \t\t\t\tif (lhs_columns.find(column_name) == lhs_columns.end()) {\n \t\t\t\t\t// new column candidate: add it to the set\n \t\t\t\t\tlhs_columns[column_name] = binding.first;\n@@ -57,34 +115,38 @@ unique_ptr<BoundTableRef> Binder::Bind(JoinRef &ref) {\n \t\tfor (auto &column : lhs_columns) {\n \t\t\tauto &column_name = column.first;\n \t\t\tauto &left_binding = column.second;\n-\t\t\t// loop over the set of lhs columns, and figure out if there is a table in the rhs with the same name\n-\t\t\tauto right_bindings = right_binder.bind_context.GetMatchingBindings(column_name);\n-\t\t\tstring right_binding;\n \n-\t\t\tif (right_bindings.size() == 0) {\n-\t\t\t\t// no match found for this column on the rhs\n-\t\t\t\tcontinue;\n+\t\t\tauto left_using_binding = left_binder.bind_context.GetUsingBinding(column_name, left_binding);\n+\t\t\tauto right_using_binding = right_binder.bind_context.GetUsingBinding(column_name);\n+\n+\t\t\tstring right_binding;\n+\t\t\t// loop over the set of lhs columns, and figure out if there is a table in the rhs with the same name\n+\t\t\tif (!right_using_binding) {\n+\t\t\t\tif (!right_binder.TryFindBinding(column_name, \"right\", right_binding)) {\n+\t\t\t\t\t// no match found for this column on the rhs: skip\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \t\t\t}\n \t\t\t// found this column name in both the LHS and the RHS of this join\n \t\t\t// add it to the natural join!\n-\t\t\t// first check if the binding is ambiguous\n-\t\t\tbool left_ambiguous = left_binding.empty();\n-\t\t\tbool right_ambiguous = right_bindings.size() > 1;\n-\t\t\tif (left_ambiguous || right_ambiguous) {\n+\t\t\t// first check if the binding is ambiguous on the LHS\n+\t\t\tif (!left_using_binding && left_binding.empty()) {\n \t\t\t\t// binding is ambiguous on left or right side: throw an exception\n-\t\t\t\tstring error_msg = \"Column name \\\"\" + column_name + \"\\\" is ambiguous: it exists more than once on the \";\n-\t\t\t\terror_msg += left_ambiguous ? \"left\" : \"right\";\n-\t\t\t\terror_msg += \" side of the join.\";\n+\t\t\t\tstring error_msg = \"Column name \\\"\" + column_name + \"\\\" is ambiguous: it exists more than once on the left side of the join.\";\n \t\t\t\tthrow BinderException(FormatError(ref, error_msg));\n \t\t\t}\n-\t\t\tfor (auto &binding : right_bindings) {\n-\t\t\t\tright_binding = binding;\n-\t\t\t}\n \t\t\t// there is a match! create the join condition\n-\t\t\tAddCondition(ref, left_binding, right_binding, column_name);\n-\t\t\tbind_context.HideBinding(right_binding, column_name);\n+\t\t\textra_conditions.push_back(AddCondition(context, left_binder, right_binder, left_binding, right_binding, column_name));\n+\n+\t\t\tUsingColumnSet set;\n+\t\t\tAddUsingBindings(set, left_using_binding, left_binding);\n+\t\t\tAddUsingBindings(set, right_using_binding, right_binding);\n+\t\t\tSetPrimaryBinding(set, ref.type, left_binding, right_binding);\n+\t\t\tleft_binder.bind_context.RemoveUsingBinding(column_name, left_using_binding);\n+\t\t\tright_binder.bind_context.RemoveUsingBinding(column_name, right_using_binding);\n+\t\t\tbind_context.AddUsingBinding(column_name, move(set));\n \t\t}\n-\t\tif (!ref.condition) {\n+\t\tif (extra_conditions.size() == 0) {\n \t\t\t// no matching bindings found in natural join: throw an exception\n \t\t\tstring error_msg = \"No columns found to join on in NATURAL JOIN.\\n\";\n \t\t\terror_msg += \"Use CROSS JOIN if you intended for this to be a cross-product.\";\n@@ -114,70 +176,50 @@ unique_ptr<BoundTableRef> Binder::Bind(JoinRef &ref) {\n \t} else if (ref.using_columns.size() > 0) {\n \t\t// USING columns\n \t\tD_ASSERT(!result->condition);\n-\t\tvector<string> left_join_bindings;\n \n-\t\tfor (auto &using_column : ref.using_columns) {\n-\t\t\t// for each using column, get the matching binding\n-\t\t\tauto left_bindings = left_binder.bind_context.GetMatchingBindings(using_column);\n-\t\t\tif (left_bindings.size() == 0) {\n-\t\t\t\tthrow BinderException(\"Column \\\"%s\\\" does not exist on left side of join!\", using_column);\n-\t\t\t}\n-\t\t\t// find the join binding\n-\t\t\tstring left_binding;\n-\t\t\tfor (auto &binding : left_bindings) {\n-\t\t\t\tif (left_binder.bind_context.BindingIsHidden(binding, using_column)) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tif (!left_binding.empty()) {\n-\t\t\t\t\tstring error = \"Column name \\\"\" + using_column +\n-\t\t\t\t\t               \"\\\" is ambiguous: it exists more than once on left side of join.\\nCandidates:\";\n-\t\t\t\t\tfor (auto &binding : left_bindings) {\n-\t\t\t\t\t\terror += \"\\n\\t\" + binding + \".\" + using_column;\n-\t\t\t\t\t}\n-\t\t\t\t\tthrow BinderException(error);\n-\t\t\t\t} else {\n-\t\t\t\t\tleft_binding = binding;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tleft_join_bindings.push_back(left_binding);\n-\t\t}\n \t\tfor (idx_t i = 0; i < ref.using_columns.size(); i++) {\n \t\t\tauto &using_column = ref.using_columns[i];\n-\t\t\tauto left_binding = left_join_bindings[i];\n-\n-\t\t\tauto right_bindings = right_binder.bind_context.GetMatchingBindings(using_column);\n+\t\t\tstring left_binding;\n \t\t\tstring right_binding;\n-\t\t\tfor (auto &binding : right_bindings) {\n-\t\t\t\tif (right_binder.bind_context.BindingIsHidden(binding, using_column)) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tif (!right_binding.empty()) {\n-\t\t\t\t\tstring error = \"Column name \\\"\" + using_column +\n-\t\t\t\t\t               \"\\\" is ambiguous: it exists more than once on right side of join.\\nCandidates:\";\n-\t\t\t\t\tfor (auto &binding : right_bindings) {\n-\t\t\t\t\t\terror += \"\\n\\t\" + binding + \".\" + using_column;\n-\t\t\t\t\t}\n-\t\t\t\t\tthrow BinderException(error);\n-\t\t\t\t} else {\n-\t\t\t\t\tright_binding = binding;\n-\t\t\t\t}\n+\t\t\tauto left_using_binding = left_binder.bind_context.GetUsingBinding(using_column);\n+\t\t\tauto right_using_binding = right_binder.bind_context.GetUsingBinding(using_column);\n+\t\t\tif (!left_using_binding) {\n+\t\t\t\tleft_binding = left_binder.FindBinding(using_column, \"left\");\n+\t\t\t} else {\n+\t\t\t\tleft_binding = left_using_binding->primary_binding;\n \t\t\t}\n-\t\t\tif (right_binding.empty()) {\n-\t\t\t\tthrow BinderException(\"Column \\\"%s\\\" does not exist on right side of join!\", using_column);\n+\t\t\tif (!right_using_binding) {\n+\t\t\t\tright_binding = right_binder.FindBinding(using_column, \"right\");\n+\t\t\t} else {\n+\t\t\t\tright_binding = right_using_binding->primary_binding;\n \t\t\t}\n-\t\t\tD_ASSERT(!left_binding.empty());\n-\t\t\tAddCondition(ref, left_binding, right_binding, using_column);\n-\t\t\tright_binder.bind_context.HideBinding(right_binding, using_column);\n+\t\t\textra_conditions.push_back(AddCondition(context, left_binder, right_binder, left_binding, right_binding, using_column));\n+\n+\t\t\tUsingColumnSet set;\n+\t\t\tAddUsingBindings(set, left_using_binding, left_binding);\n+\t\t\tAddUsingBindings(set, right_using_binding, right_binding);\n+\t\t\tSetPrimaryBinding(set, ref.type, left_binding, right_binding);\n+\t\t\tleft_binder.bind_context.RemoveUsingBinding(using_column, left_using_binding);\n+\t\t\tright_binder.bind_context.RemoveUsingBinding(using_column, right_using_binding);\n+\t\t\tbind_context.AddUsingBinding(using_column, move(set));\n \t\t}\n \t}\n \tbind_context.AddContext(move(left_binder.bind_context));\n \tbind_context.AddContext(move(right_binder.bind_context));\n \tMoveCorrelatedExpressions(left_binder);\n \tMoveCorrelatedExpressions(right_binder);\n+\tfor(auto &condition : extra_conditions) {\n+\t\tif (ref.condition) {\n+\t\t\tref.condition = make_unique<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, move(ref.condition), move(condition));\n+\t\t} else {\n+\t\t\tref.condition = move(condition);\n+\t\t}\n+\t}\n \tif (ref.condition) {\n \t\tWhereBinder binder(*this, context);\n \t\tresult->condition = binder.Bind(ref.condition);\n \t}\n+\tD_ASSERT(result->condition);\n \treturn move(result);\n }\n \ndiff --git a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\nindex 7de4dddec291..0e3a6eb62ef1 100644\n--- a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n+++ b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n@@ -197,6 +197,7 @@ bool sqlite3_display_result(StatementType type) {\n \tcase StatementType::EXPLAIN_STATEMENT:\n \tcase StatementType::PRAGMA_STATEMENT:\n \tcase StatementType::SELECT_STATEMENT:\n+\tcase StatementType::SHOW_STATEMENT:\n \t\treturn true;\n \tdefault:\n \t\treturn false;\n",
  "test_patch": "diff --git a/test/issues/general/test_1290.test b/test/issues/general/test_1290.test\nnew file mode 100644\nindex 000000000000..df790b07193f\n--- /dev/null\n+++ b/test/issues/general/test_1290.test\n@@ -0,0 +1,123 @@\n+# name: test/issues/general/test_1248.test\n+# description: Issue 1290: FULL JOIN reports missing values for join key\n+# group: [general]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create table a as select 42 as i, 80 as j;\n+\n+statement ok\n+create table b as select 43 as i, 84 as k;\n+\n+statement ok\n+create table c as select 44 as i, 84 as l;\n+\n+query III\n+select i, a.i, b.i from a inner join b using (i);\n+----\n+\n+query III\n+select i, a.i, b.i from a left outer join b using (i);\n+----\n+42\t42\tNULL\n+\n+query III\n+select i, a.i, b.i from a right outer join b using (i);\n+----\n+43\tNULL\t43\n+\n+query III\n+select i, a.i, b.i from a natural full outer join b order by 1;\n+----\n+42\t42\tNULL\n+43\tNULL\t43\n+\n+query III\n+select i, a.i, b.i from a full outer join b using (i) order by 1;\n+----\n+42\t42\tNULL\n+43\tNULL\t43\n+\n+query III\n+select * from a full outer join b using (i) order by 1;\n+----\n+42\t80\tNULL\n+43\tNULL\t84\n+\n+query IIII\n+select i, a.i, b.i, c.i from a full outer join b using (i) full outer join c using (i) order by 1;\n+----\n+42\t42\tNULL\tNULL\n+43\tNULL\t43\tNULL\n+44\tNULL\tNULL\t44\n+\n+query IIII\n+select * from a full outer join b using (i) full outer join c using (i) order by 1;\n+----\n+42\t80\tNULL\tNULL\n+43\tNULL\t84\tNULL\n+44\tNULL\tNULL\t84\n+\n+query IIII\n+select i, a.i, b.i, c.i from a natural full outer join b natural full outer join (values (42)) c(i) order by 1;\n+----\n+42\t42\tNULL\t42\n+43\tNULL\t43\tNULL\n+\n+query IIII\n+select i, a.i, b.i, c.i from a natural full outer join b natural full outer join (values (43)) c(i) order by 1;\n+----\n+42\t42\tNULL\tNULL\n+43\tNULL\t43\t43\n+\n+query IIII\n+select i, a.i, b.i, c.i from a natural full outer join b natural full outer join (values (44)) c(i) order by 1;\n+----\n+42\t42\tNULL\tNULL\n+43\tNULL\t43\tNULL\n+44\tNULL\tNULL\t44\n+\n+query IIII\n+select i, a.i, b.i, c.i from a natural full outer join b natural full outer join c order by 1;\n+----\n+42\t42\tNULL\tNULL\n+43\tNULL\t43\tNULL\n+44\tNULL\tNULL\t44\n+\n+query IIII\n+select * from a natural full outer join b natural full outer join c order by 1;\n+----\n+42\t80\tNULL\tNULL\n+43\tNULL\t84\tNULL\n+44\tNULL\tNULL\t84\n+\n+# right join\n+query III\n+select * from a natural right outer join b order by 1;\n+----\n+43\tNULL\t84\n+\n+query IIIII\n+select * from a, b natural right outer join c;\n+----\n+42\t80\t44\tNULL\t84\n+\n+query IIIIIIIIII\n+select *, * from a, b natural right outer join c;\n+----\n+42\t80\t44\tNULL\t84\t42\t80\t44\tNULL\t84\n+\n+query IIIIII\n+select a.*, b.*, c.* from a, b natural right outer join c;\n+----\n+42\t80\tNULL\tNULL\t44\t84\n+\n+query IIIIII\n+select * from a natural full outer join b, a a1 natural full outer join c;\n+----\n+42\t80\tNULL\t42\t80\tNULL\n+42\t80\tNULL\t44\tNULL\t84\n+43\tNULL\t84\t42\t80\tNULL\n+43\tNULL\t84\t44\tNULL\t84\ndiff --git a/test/optimizer/using_optimizer.test b/test/optimizer/using_optimizer.test\nnew file mode 100644\nindex 000000000000..3b3ce5d93655\n--- /dev/null\n+++ b/test/optimizer/using_optimizer.test\n@@ -0,0 +1,131 @@\n+# name: test/optimizer/using_optimizer.test\n+# description: Test optimization of USING columns\n+# group: [optimizer]\n+\n+statement ok\n+PRAGMA explain_output='optimized_only';\n+\n+statement ok\n+create table a as select 42 as i, 80 as j;\n+\n+statement ok\n+create table b as select 43 as i, 84 as k;\n+\n+statement ok\n+create table c as select 44 as i, 84 as l;\n+\n+# inner join\n+query II nosort inner\n+explain select i from a inner join b using (i);\n+----\n+\n+query II nosort inner\n+explain select a.i from a, b where a.i=b.i;\n+----\n+\n+query II nosort inner\n+explain select a.i from a natural join b;\n+----\n+\n+# left join\n+query II nosort left\n+explain select i from a left outer join b using (i);\n+----\n+\n+query II nosort left\n+explain select a.i from a left outer join b using (i);\n+----\n+\n+query II nosort left\n+explain select a.i from a left outer join b on (a.i=b.i);\n+----\n+\n+# right join\n+query II nosort right\n+explain select i from a right outer join b using (i);\n+----\n+\n+query II nosort right\n+explain select b.i from a right outer join b using (i);\n+----\n+\n+query II nosort right\n+explain select b.i from a right outer join b on (a.i=b.i);\n+----\n+\n+# left join followed by inner join\n+query I\n+select i from a left outer join b using (i) inner join c using (i);\n+----\n+\n+query I\n+select a.i from a left outer join b on (a.i=b.i) inner join c on (a.i=c.i);\n+----\n+\n+query II nosort leftinner\n+explain select i from a left outer join b using (i) inner join c using (i);\n+----\n+\n+query II nosort leftinner\n+explain select a.i from a left outer join b on (a.i=b.i) inner join c on (a.i=c.i);\n+----\n+\n+# left join followed by left join\n+query I\n+select i from a left outer join b using (i) left outer join c using (i);\n+----\n+42\n+\n+query I\n+select a.i from a left outer join b on (a.i=b.i) left outer join c on (a.i=c.i);\n+----\n+42\n+\n+query II nosort leftleft\n+explain select i from a left outer join b using (i) left outer join c using (i);\n+----\n+\n+query II nosort leftleft\n+explain select a.i from a left outer join b on (a.i=b.i) left outer join c on (a.i=c.i);\n+----\n+\n+# left join followed by right join\n+query I\n+select i from a left outer join b using (i) right join c using (i);\n+----\n+44\n+\n+query I\n+select c.i from a left outer join b on (a.i=b.i) right join c on (a.i=c.i);\n+----\n+44\n+\n+query II nosort leftright\n+explain select i from a left outer join b using (i) right join c using (i);\n+----\n+\n+query II nosort leftright\n+explain select a.i from a left outer join b on (a.i=b.i) right join c on (a.i=c.i);\n+----\n+\n+# full outer join\n+# need to use a case expression here\n+query I\n+select i from a full outer join b using (i);\n+----\n+42\n+43\n+\n+query I\n+select case when(a.i is not null) then a.i else b.i end from a full outer join b on (a.i=b.i);\n+----\n+42\n+43\n+\n+query II nosort fullouter\n+explain select i from a full outer join b using (i);\n+----\n+\n+query II nosort fullouter\n+explain select case when(a.i is not null) then a.i else b.i end from a full outer join b on (a.i=b.i);\n+----\n",
  "problem_statement": "FULL JOIN reports missing values for join key\n`\r\n   select * from left_table as a full out joiner right_table as b\r\n      using(key1,key2)\r\n`\r\n\r\nSuppose that key1,key2 is missing on the left table, but present in the right table. The resulting table will report key1,key2 as null for those values in the right table. The only way to retrieve them is to type **coalesce(a.key1,b.key1) as key1**\r\n\r\nI don't think this is ideal behavior. \r\n\r\n\r\n\n",
  "hints_text": "Thanks for the report! I can confirm this behavior is inconsistent with Postgres. I will have a look.\nHere's a replicable example, bleeding edge as of 2 weeks ago\r\n\r\n![image](https://user-images.githubusercontent.com/8321252/104251956-de42e980-54ab-11eb-921a-01294115a0be.png)\r\n",
  "created_at": "2021-01-14T14:38:08Z"
}