You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
FULL JOIN reports missing values for join key
`
   select * from left_table as a full out joiner right_table as b
      using(key1,key2)
`

Suppose that key1,key2 is missing on the left table, but present in the right table. The resulting table will report key1,key2 as null for those values in the right table. The only way to retrieve them is to type **coalesce(a.key1,b.key1) as key1**

I don't think this is ideal behavior. 




</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3901452.svg)](https://zenodo.org/record/3901452)
7: 
8: 
9: ## Installation
10: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
11: 
12: ## Development
13: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
14: 
15: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
16: 
17: 
[end of README.md]
[start of src/include/duckdb/planner/bind_context.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/bind_context.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/catalog.hpp"
12: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
13: #include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
14: #include "duckdb/common/unordered_map.hpp"
15: #include "duckdb/common/unordered_set.hpp"
16: #include "duckdb/parser/expression/columnref_expression.hpp"
17: #include "duckdb/parser/parsed_expression.hpp"
18: #include "duckdb/parser/qualified_name_set.hpp"
19: #include "duckdb/planner/expression.hpp"
20: #include "duckdb/planner/expression_binder.hpp"
21: #include "duckdb/planner/table_binding.hpp"
22: 
23: namespace duckdb {
24: class Binder;
25: class LogicalGet;
26: class BoundQueryNode;
27: 
28: //! The BindContext object keeps track of all the tables and columns that are
29: //! encountered during the binding process.
30: class BindContext {
31: public:
32: 	//! Keep track of recursive CTE references
33: 	unordered_map<string, std::shared_ptr<idx_t>> cte_references;
34: 
35: public:
36: 	//! Given a column name, find the matching table it belongs to. Throws an
37: 	//! exception if no table has a column of the given name.
38: 	string GetMatchingBinding(const string &column_name);
39: 	//! Like GetMatchingBinding, but instead of throwing an error if multiple tables have the same binding it will
40: 	//! return a list of all the matching ones
41: 	unordered_set<string> GetMatchingBindings(const string &column_name);
42: 	//! Like GetMatchingBindings, but returns the top 3 most similar bindings (in levenshtein distance) instead of the
43: 	//! matching ones
44: 	vector<string> GetSimilarBindings(const string &column_name);
45: 
46: 	Binding *GetCTEBinding(const string &ctename);
47: 	//! Binds a column expression to the base table. Returns the bound expression
48: 	//! or throws an exception if the column could not be bound.
49: 	BindResult BindColumn(ColumnRefExpression &colref, idx_t depth);
50: 
51: 	//! Generate column expressions for all columns that are present in the
52: 	//! referenced tables. This is used to resolve the * expression in a
53: 	//! selection list.
54: 	void GenerateAllColumnExpressions(vector<unique_ptr<ParsedExpression>> &new_select_list, string relation_name = "");
55: 	const vector<std::pair<string, Binding *>> &GetBindingsList() {
56: 		return bindings_list;
57: 	}
58: 
59: 	//! Adds a base table with the given alias to the BindContext.
60: 	void AddBaseTable(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types,
61: 	                  LogicalGet &get);
62: 	//! Adds a call to a table function with the given alias to the BindContext.
63: 	void AddTableFunction(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types,
64: 	                      LogicalGet &get);
65: 	//! Adds a subquery with a given alias to the BindContext.
66: 	void AddSubquery(idx_t index, const string &alias, SubqueryRef &ref, BoundQueryNode &subquery);
67: 	//! Adds a base table with the given alias to the BindContext.
68: 	void AddGenericBinding(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types);
69: 
70: 	//! Adds a base table with the given alias to the CTE BindContext.
71: 	//! We need this to correctly bind recursive CTEs with multiple references.
72: 	void AddCTEBinding(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types);
73: 
74: 	//! Hide a binding
75: 	void HideBinding(const string &binding_name, const string &column_name);
76: 	//! Returns true if the given column is hidden from the given binding
77: 	bool BindingIsHidden(const string &binding_name, const string &column_name);
78: 
79: 	unordered_map<string, std::shared_ptr<Binding>> GetCTEBindings() {
80: 		return cte_bindings;
81: 	}
82: 	void SetCTEBindings(unordered_map<string, std::shared_ptr<Binding>> bindings) {
83: 		cte_bindings = bindings;
84: 	}
85: 
86: 	//! Alias a set of column names for the specified table, using the original names if there are not enough aliases
87: 	//! specified.
88: 	static vector<string> AliasColumnNames(string table_name, const vector<string> &names,
89: 	                                       const vector<string> &column_aliases);
90: 
91: 	//! Add all the bindings from a BindContext to this BindContext. The other BindContext is destroyed in the process.
92: 	void AddContext(BindContext other);
93: 
94: private:
95: 	void AddBinding(const string &alias, unique_ptr<Binding> binding);
96: 	//! Gets a binding of the specified name. Returns a nullptr and sets the out_error if the binding could not be
97: 	//! found.
98: 	Binding *GetBinding(const string &name, string &out_error);
99: 	void GenerateAllColumnExpressions(vector<unique_ptr<ParsedExpression>> &new_select_list, Binding *binding);
100: 
101: private:
102: 	//! The set of bindings
103: 	unordered_map<string, unique_ptr<Binding>> bindings;
104: 	//! The list of bindings in insertion order
105: 	vector<std::pair<string, Binding *>> bindings_list;
106: 	//! The set of hidden columns from the result
107: 	qualified_column_set_t hidden_columns;
108: 
109: 	//! The set of CTE bindings
110: 	unordered_map<string, std::shared_ptr<Binding>> cte_bindings;
111: };
112: } // namespace duckdb
[end of src/include/duckdb/planner/bind_context.hpp]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/parser/column_definition.hpp"
13: #include "duckdb/parser/tokens.hpp"
14: #include "duckdb/planner/bind_context.hpp"
15: #include "duckdb/planner/bound_tokens.hpp"
16: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
17: #include "duckdb/planner/logical_operator.hpp"
18: #include "duckdb/planner/bound_statement.hpp"
19: 
20: namespace duckdb {
21: class BoundResultModifier;
22: class ClientContext;
23: class ExpressionBinder;
24: class LimitModifier;
25: class OrderBinder;
26: class TableCatalogEntry;
27: class ViewCatalogEntry;
28: 
29: struct CreateInfo;
30: struct BoundCreateTableInfo;
31: struct BoundCreateFunctionInfo;
32: struct CommonTableExpressionInfo;
33: 
34: struct CorrelatedColumnInfo {
35: 	ColumnBinding binding;
36: 	LogicalType type;
37: 	string name;
38: 	idx_t depth;
39: 
40: 	CorrelatedColumnInfo(BoundColumnRefExpression &expr)
41: 	    : binding(expr.binding), type(expr.return_type), name(expr.GetName()), depth(expr.depth) {
42: 	}
43: 
44: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
45: 		return binding == rhs.binding;
46: 	}
47: };
48: 
49: //! Bind the parsed query tree to the actual columns present in the catalog.
50: /*!
51:   The binder is responsible for binding tables and columns to actual physical
52:   tables and columns in the catalog. In the process, it also resolves types of
53:   all expressions.
54: */
55: class Binder {
56: 	friend class ExpressionBinder;
57: 	friend class RecursiveSubqueryPlanner;
58: 
59: public:
60: 	Binder(ClientContext &context, Binder *parent = nullptr, bool inherit_ctes = true);
61: 
62: 	//! The client context
63: 	ClientContext &context;
64: 	//! A mapping of names to common table expressions
65: 	unordered_map<string, CommonTableExpressionInfo *> CTE_bindings;
66: 	//! The CTEs that have already been bound
67: 	unordered_set<CommonTableExpressionInfo*> bound_ctes;
68: 	//! The bind context
69: 	BindContext bind_context;
70: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
71: 	//! vector)
72: 	vector<CorrelatedColumnInfo> correlated_columns;
73: 	//! The set of parameter expressions bound by this binder
74: 	vector<BoundParameterExpression *> *parameters;
75: 	//! Whether or not the bound statement is read-only
76: 	bool read_only;
77: 	//! Whether or not the statement requires a valid transaction to run
78: 	bool requires_valid_transaction;
79: 	//! Whether or not the statement can be streamed to the client
80: 	bool allow_stream_result;
81: 	//! The alias for the currently processing subquery, if it exists
82: 	string alias;
83: 	//! Macro parameter bindings (if any)
84: 	MacroBinding *macro_binding = nullptr;
85: 
86: public:
87: 	BoundStatement Bind(SQLStatement &statement);
88: 	BoundStatement Bind(QueryNode &node);
89: 
90: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
91: 	void BindCreateViewInfo(CreateViewInfo &base);
92: 	SchemaCatalogEntry *BindSchema(CreateInfo &info);
93: 	SchemaCatalogEntry *BindCreateFunctionInfo(CreateInfo &info);
94: 
95: 	//! Check usage, and cast named parameters to their types
96: 	static void BindNamedParameters(unordered_map<string, LogicalType> &types, unordered_map<string, Value> &values,
97: 	                                QueryErrorContext &error_context, string &func_name);
98: 
99: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
100: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
101: 
102: 	//! Generates an unused index for a table
103: 	idx_t GenerateTableIndex();
104: 
105: 	//! Add a common table expression to the binder
106: 	void AddCTE(const string &name, CommonTableExpressionInfo *cte);
107: 	//! Find a common table expression by name; returns nullptr if none exists
108: 	CommonTableExpressionInfo *FindCTE(const string &name, bool skip = false);
109: 
110: 	bool CTEIsAlreadyBound(CommonTableExpressionInfo* cte);
111: 
112: 	void PushExpressionBinder(ExpressionBinder *binder);
113: 	void PopExpressionBinder();
114: 	void SetActiveBinder(ExpressionBinder *binder);
115: 	ExpressionBinder *GetActiveBinder();
116: 	bool HasActiveBinder();
117: 
118: 	vector<ExpressionBinder *> &GetActiveBinders();
119: 
120: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
121: 	//! Add a correlated column to this binder (if it does not exist)
122: 	void AddCorrelatedColumn(CorrelatedColumnInfo info);
123: 
124: 	string FormatError(ParsedExpression &expr_context, string message);
125: 	string FormatError(TableRef &ref_context, string message);
126: 	string FormatError(idx_t query_location, string message);
127: 
128: private:
129: 	//! The parent binder (if any)
130: 	Binder *parent;
131: 	//! The vector of active binders
132: 	vector<ExpressionBinder *> active_binders;
133: 	//! The count of bound_tables
134: 	idx_t bound_tables;
135: 	//! Whether or not the binder has any unplanned subqueries that still need to be planned
136: 	bool has_unplanned_subqueries = false;
137: 	//! Whether or not subqueries should be planned already
138: 	bool plan_subquery = true;
139: 	//! Whether CTEs should reference the parent binder (if it exists)
140: 	bool inherit_ctes = true;
141: 	//! The root statement of the query that is currently being parsed
142: 	SQLStatement *root_statement = nullptr;
143: 
144: private:
145: 	//! Bind the default values of the columns of a table
146: 	void BindDefaultValues(vector<ColumnDefinition> &columns, vector<unique_ptr<Expression>> &bound_defaults);
147: 
148: 	//! Move correlated expressions from the child binder to this binder
149: 	void MoveCorrelatedExpressions(Binder &other);
150: 
151: 	BoundStatement Bind(SelectStatement &stmt);
152: 	BoundStatement Bind(InsertStatement &stmt);
153: 	BoundStatement Bind(CopyStatement &stmt);
154: 	BoundStatement Bind(DeleteStatement &stmt);
155: 	BoundStatement Bind(UpdateStatement &stmt);
156: 	BoundStatement Bind(CreateStatement &stmt);
157: 	BoundStatement Bind(DropStatement &stmt);
158: 	BoundStatement Bind(AlterStatement &stmt);
159: 	BoundStatement Bind(TransactionStatement &stmt);
160: 	BoundStatement Bind(PragmaStatement &stmt);
161: 	BoundStatement Bind(ExplainStatement &stmt);
162: 	BoundStatement Bind(VacuumStatement &stmt);
163: 	BoundStatement Bind(RelationStatement &stmt);
164: 	BoundStatement Bind(ShowStatement &stmt);
165: 	BoundStatement Bind(CallStatement &stmt);
166: 	BoundStatement Bind(ExportStatement &stmt);
167: 
168: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
169: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
170: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
171: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
172: 
173: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
174: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
175: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
176: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
177: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
178: 
179: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
180: 	unique_ptr<BoundTableRef> Bind(CrossProductRef &ref);
181: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
182: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte = nullptr);
183: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
184: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
185: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
186: 
187: 	bool BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
188: 	                            vector<Value> &parameters, unordered_map<string, Value> &named_parameters,
189: 	                            string &error);
190: 
191: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
192: 	unique_ptr<LogicalOperator> CreatePlan(BoundCrossProductRef &ref);
193: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
194: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
195: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
196: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
197: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
198: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
199: 
200: 	unique_ptr<LogicalOperator> BindTable(TableCatalogEntry &table, BaseTableRef &ref);
201: 	unique_ptr<LogicalOperator> BindView(ViewCatalogEntry &view, BaseTableRef &ref);
202: 	unique_ptr<LogicalOperator> BindTableOrView(BaseTableRef &ref);
203: 
204: 	BoundStatement BindCopyTo(CopyStatement &stmt);
205: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
206: 
207: 	void BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
208: 	void BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index);
209: 
210: 	unique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);
211: 	unique_ptr<Expression> BindFilter(unique_ptr<ParsedExpression> condition);
212: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
213: 
214: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
215: 
216: 	void PlanSubqueries(unique_ptr<Expression> *expr, unique_ptr<LogicalOperator> *root);
217: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
218: 
219: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,
220: 	                                                       vector<LogicalType> &target_types,
221: 	                                                       unique_ptr<LogicalOperator> op);
222: };
223: 
224: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/parser/transform/expression/transform_coalesce.cpp]
1: #include "duckdb/parser/expression/case_expression.hpp"
2: #include "duckdb/parser/expression/operator_expression.hpp"
3: #include "duckdb/parser/transformer.hpp"
4: 
5: namespace duckdb {
6: 
7: using namespace duckdb_libpgquery;
8: 
9: // COALESCE(a,b,c) returns the first argument that is NOT NULL, so
10: // rewrite into CASE(a IS NOT NULL, a, CASE(b IS NOT NULL, b, c))
11: unique_ptr<ParsedExpression> Transformer::TransformCoalesce(PGAExpr *root) {
12: 	if (!root) {
13: 		return nullptr;
14: 	}
15: 	auto coalesce_args = reinterpret_cast<PGList *>(root->lexpr);
16: 	D_ASSERT(coalesce_args->length > 0); // parser ensures this already
17: 	if (coalesce_args->length == 1) {
18: 		// special case, dont need to do anything, bug #1222
19: 		return TransformExpression(reinterpret_cast<PGNode *>(coalesce_args->head->data.ptr_value));
20: 	}
21: 	auto exp_root = make_unique<CaseExpression>();
22: 	auto cur_root = exp_root.get();
23: 	for (auto cell = coalesce_args->head; cell && cell->next; cell = cell->next) {
24: 		// get the value of the COALESCE
25: 		auto value_expr = TransformExpression(reinterpret_cast<PGNode *>(cell->data.ptr_value));
26: 		// perform an IS NOT NULL comparison with the value here
27: 		cur_root->check = make_unique<OperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, value_expr->Copy());
28: 		// if IS NOT NULL, we output the value
29: 		cur_root->result_if_true = move(value_expr);
30: 		if (cell->next->next == nullptr) {
31: 			// if there is no next in the chain, the COALESCE ends there
32: 			cur_root->result_if_false = TransformExpression(reinterpret_cast<PGNode *>(cell->next->data.ptr_value));
33: 		} else {
34: 			// more COALESCE parameters remain, create a nested CASE statement
35: 			auto next_case = make_unique<CaseExpression>();
36: 			auto case_ptr = next_case.get();
37: 			cur_root->result_if_false = move(next_case);
38: 			cur_root = case_ptr;
39: 		}
40: 	}
41: 	return move(exp_root);
42: }
43: 
44: } // namespace duckdb
[end of src/parser/transform/expression/transform_coalesce.cpp]
[start of src/planner/bind_context.cpp]
1: #include "duckdb/planner/bind_context.hpp"
2: 
3: #include "duckdb/parser/expression/columnref_expression.hpp"
4: #include "duckdb/parser/tableref/subqueryref.hpp"
5: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
6: #include "duckdb/planner/bound_query_node.hpp"
7: 
8: #include "duckdb/common/string_util.hpp"
9: #include "duckdb/common/pair.hpp"
10: 
11: #include <algorithm>
12: 
13: namespace duckdb {
14: 
15: string BindContext::GetMatchingBinding(const string &column_name) {
16: 	string result;
17: 	for (auto &kv : bindings) {
18: 		auto binding = kv.second.get();
19: 		if (binding->HasMatchingBinding(column_name)) {
20: 			// check if the binding is ignored
21: 			if (BindingIsHidden(kv.first, column_name)) {
22: 				continue;
23: 			}
24: 
25: 			if (!result.empty()) {
26: 				throw BinderException("Ambiguous reference to column name \"%s\" (use: \"%s.%s\" "
27: 				                      "or \"%s.%s\")",
28: 				                      column_name, result, column_name, kv.first, column_name);
29: 			}
30: 			result = kv.first;
31: 		}
32: 	}
33: 	return result;
34: }
35: 
36: vector<string> BindContext::GetSimilarBindings(const string &column_name) {
37: 	vector<pair<string, idx_t>> scores;
38: 	for (auto &kv : bindings) {
39: 		auto binding = kv.second.get();
40: 		for (auto &name : binding->names) {
41: 			idx_t distance = StringUtil::LevenshteinDistance(name, column_name);
42: 			scores.push_back(make_pair(binding->alias + "." + name, distance));
43: 		}
44: 	}
45: 	return StringUtil::TopNStrings(scores);
46: }
47: 
48: void BindContext::HideBinding(const string &binding_name, const string &column_name) {
49: 	hidden_columns.insert(QualifiedColumnName(binding_name, column_name));
50: }
51: 
52: bool BindContext::BindingIsHidden(const string &binding_name, const string &column_name) {
53: 	QualifiedColumnName qcolumn(binding_name, column_name);
54: 	return hidden_columns.find(qcolumn) != hidden_columns.end();
55: }
56: 
57: unordered_set<string> BindContext::GetMatchingBindings(const string &column_name) {
58: 	unordered_set<string> result;
59: 	for (auto &kv : bindings) {
60: 		auto binding = kv.second.get();
61: 		if (binding->HasMatchingBinding(column_name)) {
62: 			result.insert(kv.first);
63: 		}
64: 	}
65: 	return result;
66: }
67: 
68: Binding *BindContext::GetCTEBinding(const string &ctename) {
69: 	auto match = cte_bindings.find(ctename);
70: 	if (match == cte_bindings.end()) {
71: 		return nullptr;
72: 	}
73: 	return match->second.get();
74: }
75: 
76: Binding *BindContext::GetBinding(const string &name, string &out_error) {
77: 	auto match = bindings.find(name);
78: 	if (match == bindings.end()) {
79: 		// alias not found in this BindContext
80: 		vector<string> candidates;
81: 		for (auto &kv : bindings) {
82: 			candidates.push_back(kv.first);
83: 		}
84: 		string candidate_str =
85: 		    StringUtil::CandidatesMessage(StringUtil::TopNLevenshtein(candidates, name), "Candidate tables");
86: 		out_error = StringUtil::Format("Referenced table \"%s\" not found!%s", name, candidate_str);
87: 		return nullptr;
88: 	}
89: 	return match->second.get();
90: }
91: 
92: BindResult BindContext::BindColumn(ColumnRefExpression &colref, idx_t depth) {
93: 	if (colref.table_name.empty()) {
94: 		return BindResult(StringUtil::Format("Could not bind alias \"%s\"!", colref.column_name));
95: 	}
96: 
97: 	string error;
98: 	auto binding = GetBinding(colref.table_name, error);
99: 	if (!binding) {
100: 		return BindResult(error);
101: 	}
102: 	return binding->Bind(colref, depth);
103: }
104: 
105: void BindContext::GenerateAllColumnExpressions(vector<unique_ptr<ParsedExpression>> &new_select_list,
106:                                                Binding *binding) {
107: 	for (auto &column_name : binding->names) {
108: 		D_ASSERT(!column_name.empty());
109: 		if (BindingIsHidden(binding->alias, column_name)) {
110: 			continue;
111: 		}
112: 		new_select_list.push_back(make_unique<ColumnRefExpression>(column_name, binding->alias));
113: 	}
114: }
115: 
116: void BindContext::GenerateAllColumnExpressions(vector<unique_ptr<ParsedExpression>> &new_select_list,
117:                                                string relation_name) {
118: 	if (bindings_list.size() == 0) {
119: 		throw BinderException("SELECT * expression without FROM clause!");
120: 	}
121: 	if (relation_name == "") { // SELECT * case
122: 		// we have to bind the tables and subqueries in order of table_index
123: 		for (auto &entry : bindings_list) {
124: 			auto binding = entry.second;
125: 			GenerateAllColumnExpressions(new_select_list, binding);
126: 		}
127: 	} else { // SELECT tbl.* case
128: 		string error;
129: 		auto binding = GetBinding(relation_name, error);
130: 		if (!binding) {
131: 			throw BinderException(error);
132: 		}
133: 		GenerateAllColumnExpressions(new_select_list, binding);
134: 	}
135: }
136: 
137: void BindContext::AddBinding(const string &alias, unique_ptr<Binding> binding) {
138: 	if (bindings.find(alias) != bindings.end()) {
139: 		throw BinderException("Duplicate alias \"%s\" in query!", alias);
140: 	}
141: 	bindings_list.push_back(make_pair(alias, binding.get()));
142: 	bindings[alias] = move(binding);
143: }
144: 
145: void BindContext::AddBaseTable(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types,
146:                                LogicalGet &get) {
147: 	AddBinding(alias, make_unique<TableBinding>(alias, move(types), move(names), get, index, true));
148: }
149: 
150: void BindContext::AddTableFunction(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types,
151:                                    LogicalGet &get) {
152: 	AddBinding(alias, make_unique<TableBinding>(alias, move(types), move(names), get, index));
153: }
154: 
155: vector<string> BindContext::AliasColumnNames(string table_name, const vector<string> &names,
156:                                              const vector<string> &column_aliases) {
157: 	vector<string> result;
158: 	if (column_aliases.size() > names.size()) {
159: 		throw BinderException("table \"%s\" has %lld columns available but %lld columns specified", table_name,
160: 		                      names.size(), column_aliases.size());
161: 	}
162: 	// use any provided column aliases first
163: 	for (idx_t i = 0; i < column_aliases.size(); i++) {
164: 		result.push_back(column_aliases[i]);
165: 	}
166: 	// if not enough aliases were provided, use the default names for remaining columns
167: 	for (idx_t i = column_aliases.size(); i < names.size(); i++) {
168: 		result.push_back(names[i]);
169: 	}
170: 	return result;
171: }
172: 
173: void BindContext::AddSubquery(idx_t index, const string &alias, SubqueryRef &ref, BoundQueryNode &subquery) {
174: 	auto names = AliasColumnNames(alias, subquery.names, ref.column_name_alias);
175: 	AddGenericBinding(index, alias, names, subquery.types);
176: }
177: 
178: void BindContext::AddGenericBinding(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types) {
179: 	AddBinding(alias, make_unique<Binding>(alias, move(types), move(names), index));
180: }
181: 
182: void BindContext::AddCTEBinding(idx_t index, const string &alias, vector<string> names, vector<LogicalType> types) {
183: 	auto binding = make_shared<Binding>(alias, move(types), move(names), index);
184: 
185: 	if (cte_bindings.find(alias) != cte_bindings.end()) {
186: 		throw BinderException("Duplicate alias \"%s\" in query!", alias);
187: 	}
188: 	cte_bindings[alias] = move(binding);
189: 	cte_references[alias] = std::make_shared<idx_t>(0);
190: }
191: 
192: void BindContext::AddContext(BindContext other) {
193: 	for (auto &binding : other.bindings) {
194: 		if (bindings.find(binding.first) != bindings.end()) {
195: 			throw BinderException("Duplicate alias \"%s\" in query!", binding.first);
196: 		}
197: 		bindings[binding.first] = move(binding.second);
198: 	}
199: 	for (auto &binding : other.bindings_list) {
200: 		bindings_list.push_back(move(binding));
201: 	}
202: 	for (auto &hidden_column : other.hidden_columns) {
203: 		hidden_columns.insert(hidden_column);
204: 	}
205: }
206: 
207: } // namespace duckdb
[end of src/planner/bind_context.cpp]
[start of src/planner/binder/expression/bind_columnref_expression.cpp]
1: #include "duckdb/parser/expression/columnref_expression.hpp"
2: #include "duckdb/planner/binder.hpp"
3: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
4: #include "duckdb/planner/expression_binder.hpp"
5: #include "duckdb/common/string_util.hpp"
6: 
7: namespace duckdb {
8: 
9: BindResult ExpressionBinder::BindExpression(ColumnRefExpression &colref, idx_t depth) {
10: 	D_ASSERT(!colref.column_name.empty());
11: 	// individual column reference
12: 	// resolve to either a base table or a subquery expression
13: 	if (colref.table_name.empty()) {
14: 		// no table name: find a binding that contains this
15: 		if (binder.macro_binding != nullptr && binder.macro_binding->HasMatchingBinding(colref.column_name)) {
16: 			// priority to macro parameter bindings TODO: throw a warning when this name conflicts
17: 			colref.table_name = binder.macro_binding->alias;
18: 		} else {
19: 			colref.table_name = binder.bind_context.GetMatchingBinding(colref.column_name);
20: 		}
21: 		if (colref.table_name.empty()) {
22: 			auto similar_bindings = binder.bind_context.GetSimilarBindings(colref.column_name);
23: 			string candidate_str = StringUtil::CandidatesMessage(similar_bindings, "Candidate bindings");
24: 			return BindResult(
25: 			    binder.FormatError(colref, StringUtil::Format("Referenced column \"%s\" not found in FROM clause!%s",
26: 			                                                  colref.column_name.c_str(), candidate_str)));
27: 		}
28: 	}
29: 	// if it was a macro parameter, let macro_binding bind it to the argument
30: 	BindResult result = binder.macro_binding != nullptr && colref.table_name == binder.macro_binding->alias
31: 	                        ? binder.macro_binding->Bind(colref, depth)
32: 	                        : binder.bind_context.BindColumn(colref, depth);
33: 	if (!result.HasError()) {
34: 		bound_columns = true;
35: 	} else {
36: 		result.error = binder.FormatError(colref, result.error);
37: 	}
38: 	return result;
39: }
40: 
41: } // namespace duckdb
[end of src/planner/binder/expression/bind_columnref_expression.cpp]
[start of src/planner/binder/expression/bind_operator_expression.cpp]
1: #include "duckdb/parser/expression/operator_expression.hpp"
2: #include "duckdb/planner/expression/bound_cast_expression.hpp"
3: #include "duckdb/planner/expression/bound_operator_expression.hpp"
4: #include "duckdb/planner/expression_binder.hpp"
5: 
6: namespace duckdb {
7: 
8: static LogicalType ResolveNotType(OperatorExpression &op, vector<BoundExpression *> &children) {
9: 	// NOT expression, cast child to BOOLEAN
10: 	D_ASSERT(children.size() == 1);
11: 	children[0]->expr = BoundCastExpression::AddCastToType(move(children[0]->expr), LogicalType::BOOLEAN);
12: 	return LogicalType(LogicalTypeId::BOOLEAN);
13: }
14: 
15: static LogicalType ResolveInType(OperatorExpression &op, vector<BoundExpression *> &children) {
16: 	// get the maximum type from the children
17: 	LogicalType max_type = children[0]->expr->return_type;
18: 	for (idx_t i = 1; i < children.size(); i++) {
19: 		max_type = LogicalType::MaxLogicalType(max_type, children[i]->expr->return_type);
20: 	}
21: 	// cast all children to the same type
22: 	for (idx_t i = 0; i < children.size(); i++) {
23: 		children[i]->expr = BoundCastExpression::AddCastToType(move(children[i]->expr), max_type);
24: 	}
25: 	// (NOT) IN always returns a boolean
26: 	return LogicalType(LogicalTypeId::BOOLEAN);
27: }
28: 
29: static LogicalType ResolveOperatorType(OperatorExpression &op, vector<BoundExpression *> &children) {
30: 	switch (op.type) {
31: 	case ExpressionType::OPERATOR_IS_NULL:
32: 	case ExpressionType::OPERATOR_IS_NOT_NULL:
33: 		// IS (NOT) NULL always returns a boolean, and does not cast its children
34: 		return LogicalType::BOOLEAN;
35: 	case ExpressionType::COMPARE_IN:
36: 	case ExpressionType::COMPARE_NOT_IN:
37: 		return ResolveInType(op, children);
38: 	default:
39: 		D_ASSERT(op.type == ExpressionType::OPERATOR_NOT);
40: 		return ResolveNotType(op, children);
41: 	}
42: }
43: 
44: BindResult ExpressionBinder::BindExpression(OperatorExpression &op, idx_t depth) {
45: 	// bind the children of the operator expression
46: 	string error;
47: 	for (idx_t i = 0; i < op.children.size(); i++) {
48: 		BindChild(op.children[i], depth, error);
49: 	}
50: 	if (!error.empty()) {
51: 		return BindResult(error);
52: 	}
53: 	// all children bound successfully, extract them
54: 	vector<BoundExpression *> children;
55: 	for (idx_t i = 0; i < op.children.size(); i++) {
56: 		D_ASSERT(op.children[i]->expression_class == ExpressionClass::BOUND_EXPRESSION);
57: 		children.push_back((BoundExpression *)op.children[i].get());
58: 	}
59: 	// now resolve the types
60: 	LogicalType result_type = ResolveOperatorType(op, children);
61: 
62: 	auto result = make_unique<BoundOperatorExpression>(op.type, result_type);
63: 	for (auto &child : children) {
64: 		result->children.push_back(move(child->expr));
65: 	}
66: 	return BindResult(move(result));
67: }
68: 
69: } // namespace duckdb
[end of src/planner/binder/expression/bind_operator_expression.cpp]
[start of src/planner/binder/query_node/bind_select_node.cpp]
1: #include "duckdb/parser/expression/columnref_expression.hpp"
2: #include "duckdb/parser/expression/comparison_expression.hpp"
3: #include "duckdb/parser/expression/constant_expression.hpp"
4: #include "duckdb/parser/query_node/select_node.hpp"
5: #include "duckdb/parser/tableref/joinref.hpp"
6: #include "duckdb/planner/binder.hpp"
7: #include "duckdb/main/config.hpp"
8: #include "duckdb/execution/expression_executor.hpp"
9: #include "duckdb/planner/expression_binder/constant_binder.hpp"
10: #include "duckdb/planner/expression_binder/group_binder.hpp"
11: #include "duckdb/planner/expression_binder/having_binder.hpp"
12: #include "duckdb/planner/expression_binder/order_binder.hpp"
13: #include "duckdb/planner/expression_binder/select_binder.hpp"
14: #include "duckdb/planner/expression_binder/where_binder.hpp"
15: #include "duckdb/planner/query_node/bound_select_node.hpp"
16: #include "duckdb/parser/expression/table_star_expression.hpp"
17: #include "duckdb/common/limits.hpp"
18: #include "duckdb/common/string_util.hpp"
19: 
20: namespace duckdb {
21: 
22: static int64_t BindConstant(Binder &binder, ClientContext &context, string clause, unique_ptr<ParsedExpression> &expr) {
23: 	ConstantBinder constant_binder(binder, context, clause);
24: 	auto bound_expr = constant_binder.Bind(expr);
25: 	if (!bound_expr->IsFoldable()) {
26: 		throw BinderException(
27: 		    "cannot use the expression \"%s\" in a %s, the expression has side-effects and is not foldable",
28: 		    bound_expr->ToString(), clause);
29: 	}
30: 	Value value = ExpressionExecutor::EvaluateScalar(*bound_expr).CastAs(LogicalType::BIGINT);
31: 	int64_t limit_value = value.GetValue<int64_t>();
32: 	if (limit_value < 0) {
33: 		throw BinderException("LIMIT must not be negative");
34: 	}
35: 	return limit_value;
36: }
37: 
38: unique_ptr<Expression> Binder::BindFilter(unique_ptr<ParsedExpression> condition) {
39: 	WhereBinder where_binder(*this, context);
40: 	return where_binder.Bind(condition);
41: }
42: 
43: unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {
44: 	// we treat the Distinct list as a order by
45: 	auto bound_expr = order_binder.Bind(move(expr));
46: 	if (!bound_expr) {
47: 		// DISTINCT ON non-integer constant
48: 		// remove the expression from the DISTINCT ON list
49: 		return nullptr;
50: 	}
51: 	D_ASSERT(bound_expr->type == ExpressionType::BOUND_COLUMN_REF);
52: 	return bound_expr;
53: }
54: 
55: unique_ptr<BoundResultModifier> Binder::BindLimit(LimitModifier &limit_mod) {
56: 	auto result = make_unique<BoundLimitModifier>();
57: 	if (limit_mod.limit) {
58: 		result->limit = BindConstant(*this, context, "LIMIT clause", limit_mod.limit);
59: 		result->offset = 0;
60: 	}
61: 	if (limit_mod.offset) {
62: 		result->offset = BindConstant(*this, context, "OFFSET clause", limit_mod.offset);
63: 		if (!limit_mod.limit) {
64: 			result->limit = NumericLimits<int64_t>::Maximum();
65: 		}
66: 	}
67: 	return move(result);
68: }
69: 
70: void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result) {
71: 	for (auto &mod : statement.modifiers) {
72: 		unique_ptr<BoundResultModifier> bound_modifier;
73: 		switch (mod->type) {
74: 		case ResultModifierType::DISTINCT_MODIFIER: {
75: 			auto &distinct = (DistinctModifier &)*mod;
76: 			auto bound_distinct = make_unique<BoundDistinctModifier>();
77: 			for (idx_t i = 0; i < distinct.distinct_on_targets.size(); i++) {
78: 				auto expr = BindOrderExpression(order_binder, move(distinct.distinct_on_targets[i]));
79: 				if (!expr) {
80: 					continue;
81: 				}
82: 				bound_distinct->target_distincts.push_back(move(expr));
83: 			}
84: 			bound_modifier = move(bound_distinct);
85: 			break;
86: 		}
87: 		case ResultModifierType::ORDER_MODIFIER: {
88: 			auto &order = (OrderModifier &)*mod;
89: 			auto bound_order = make_unique<BoundOrderModifier>();
90: 			auto &config = DBConfig::GetConfig(context);
91: 			for (idx_t i = 0; i < order.orders.size(); i++) {
92: 				auto order_expression = BindOrderExpression(order_binder, move(order.orders[i].expression));
93: 				if (!order_expression) {
94: 					continue;
95: 				}
96: 				auto type =
97: 				    order.orders[i].type == OrderType::ORDER_DEFAULT ? config.default_order_type : order.orders[i].type;
98: 				auto null_order = order.orders[i].null_order == OrderByNullType::ORDER_DEFAULT
99: 				                      ? config.default_null_order
100: 				                      : order.orders[i].null_order;
101: 				bound_order->orders.push_back(BoundOrderByNode(type, null_order, move(order_expression)));
102: 			}
103: 			if (bound_order->orders.size() > 0) {
104: 				bound_modifier = move(bound_order);
105: 			}
106: 			break;
107: 		}
108: 		case ResultModifierType::LIMIT_MODIFIER:
109: 			bound_modifier = BindLimit((LimitModifier &)*mod);
110: 			break;
111: 		default:
112: 			throw Exception("Unsupported result modifier");
113: 		}
114: 		if (bound_modifier) {
115: 			result.modifiers.push_back(move(bound_modifier));
116: 		}
117: 	}
118: }
119: 
120: void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index) {
121: 	for (auto &bound_mod : result.modifiers) {
122: 		switch (bound_mod->type) {
123: 		case ResultModifierType::DISTINCT_MODIFIER: {
124: 			auto &distinct = (BoundDistinctModifier &)*bound_mod;
125: 			if (distinct.target_distincts.size() == 0) {
126: 				// DISTINCT without a target: push references to the standard select list
127: 				for (idx_t i = 0; i < sql_types.size(); i++) {
128: 					distinct.target_distincts.push_back(
129: 					    make_unique<BoundColumnRefExpression>(sql_types[i], ColumnBinding(projection_index, i)));
130: 				}
131: 			} else {
132: 				// DISTINCT with target list: set types
133: 				for (idx_t i = 0; i < distinct.target_distincts.size(); i++) {
134: 					auto &expr = distinct.target_distincts[i];
135: 					D_ASSERT(expr->type == ExpressionType::BOUND_COLUMN_REF);
136: 					auto &bound_colref = (BoundColumnRefExpression &)*expr;
137: 					if (bound_colref.binding.column_index == INVALID_INDEX) {
138: 						throw BinderException("Ambiguous name in DISTINCT ON!");
139: 					}
140: 					D_ASSERT(bound_colref.binding.column_index < sql_types.size());
141: 					bound_colref.return_type = sql_types[bound_colref.binding.column_index];
142: 				}
143: 			}
144: 			for (idx_t i = 0; i < distinct.target_distincts.size(); i++) {
145: 				auto &bound_colref = (BoundColumnRefExpression &)*distinct.target_distincts[i];
146: 				auto sql_type = sql_types[bound_colref.binding.column_index];
147: 				if (sql_type.id() == LogicalTypeId::VARCHAR) {
148: 					distinct.target_distincts[i] = ExpressionBinder::PushCollation(
149: 					    context, move(distinct.target_distincts[i]), sql_type.collation(), true);
150: 				}
151: 			}
152: 			break;
153: 		}
154: 		case ResultModifierType::ORDER_MODIFIER: {
155: 			auto &order = (BoundOrderModifier &)*bound_mod;
156: 			for (idx_t i = 0; i < order.orders.size(); i++) {
157: 				auto &expr = order.orders[i].expression;
158: 				D_ASSERT(expr->type == ExpressionType::BOUND_COLUMN_REF);
159: 				auto &bound_colref = (BoundColumnRefExpression &)*expr;
160: 				if (bound_colref.binding.column_index == INVALID_INDEX) {
161: 					throw BinderException("Ambiguous name in ORDER BY!");
162: 				}
163: 				D_ASSERT(bound_colref.binding.column_index < sql_types.size());
164: 				auto sql_type = sql_types[bound_colref.binding.column_index];
165: 				bound_colref.return_type = sql_types[bound_colref.binding.column_index];
166: 				if (sql_type.id() == LogicalTypeId::VARCHAR) {
167: 					order.orders[i].expression = ExpressionBinder::PushCollation(
168: 					    context, move(order.orders[i].expression), sql_type.collation());
169: 				}
170: 			}
171: 			break;
172: 		}
173: 		default:
174: 			break;
175: 		}
176: 	}
177: }
178: 
179: unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
180: 	auto result = make_unique<BoundSelectNode>();
181: 	result->projection_index = GenerateTableIndex();
182: 	result->group_index = GenerateTableIndex();
183: 	result->aggregate_index = GenerateTableIndex();
184: 	result->window_index = GenerateTableIndex();
185: 	result->unnest_index = GenerateTableIndex();
186: 	result->prune_index = GenerateTableIndex();
187: 
188: 	// first bind the FROM table statement
189: 	result->from_table = Bind(*statement.from_table);
190: 
191: 	// bind the sample clause
192: 	if (statement.sample) {
193: 		result->sample_options = move(statement.sample);
194: 	}
195: 
196: 	// visit the select list and expand any "*" statements
197: 	vector<unique_ptr<ParsedExpression>> new_select_list;
198: 	for (auto &select_element : statement.select_list) {
199: 		if (select_element->GetExpressionType() == ExpressionType::STAR) {
200: 			// * statement, expand to all columns from the FROM clause
201: 			bind_context.GenerateAllColumnExpressions(new_select_list);
202: 		} else if (select_element->GetExpressionType() == ExpressionType::TABLE_STAR) {
203: 			auto table_star =
204: 			    (TableStarExpression *)select_element.get(); // TODO this cast to explicit class is a bit dirty?
205: 			bind_context.GenerateAllColumnExpressions(new_select_list, table_star->relation_name);
206: 		} else {
207: 			// regular statement, add it to the list
208: 			new_select_list.push_back(move(select_element));
209: 		}
210: 	}
211: 	statement.select_list = move(new_select_list);
212: 
213: 	// create a mapping of (alias -> index) and a mapping of (Expression -> index) for the SELECT list
214: 	unordered_map<string, idx_t> alias_map;
215: 	expression_map_t<idx_t> projection_map;
216: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
217: 		auto &expr = statement.select_list[i];
218: 		result->names.push_back(expr->GetName());
219: 		ExpressionBinder::BindTableNames(*this, *expr);
220: 		if (!expr->alias.empty()) {
221: 			alias_map[expr->alias] = i;
222: 			result->names[i] = expr->alias;
223: 		}
224: 		projection_map[expr.get()] = i;
225: 		result->original_expressions.push_back(expr->Copy());
226: 	}
227: 	result->column_count = statement.select_list.size();
228: 
229: 	// first visit the WHERE clause
230: 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
231: 	if (statement.where_clause) {
232: 		result->where_clause = BindFilter(move(statement.where_clause));
233: 	}
234: 
235: 	// now bind all the result modifiers; including DISTINCT and ORDER BY targets
236: 	OrderBinder order_binder({this}, result->projection_index, statement, alias_map, projection_map);
237: 	BindModifiers(order_binder, statement, *result);
238: 
239: 	vector<unique_ptr<ParsedExpression>> unbound_groups;
240: 	BoundGroupInformation info;
241: 	if (statement.groups.size() > 0) {
242: 		// the statement has a GROUP BY clause, bind it
243: 		unbound_groups.resize(statement.groups.size());
244: 		GroupBinder group_binder(*this, context, statement, result->group_index, alias_map, info.alias_map);
245: 		for (idx_t i = 0; i < statement.groups.size(); i++) {
246: 
247: 			// we keep a copy of the unbound expression;
248: 			// we keep the unbound copy around to check for group references in the SELECT and HAVING clause
249: 			// the reason we want the unbound copy is because we want to figure out whether an expression
250: 			// is a group reference BEFORE binding in the SELECT/HAVING binder
251: 			group_binder.unbound_expression = statement.groups[i]->Copy();
252: 			group_binder.bind_index = i;
253: 
254: 			// bind the groups
255: 			LogicalType group_type;
256: 			auto bound_expr = group_binder.Bind(statement.groups[i], &group_type);
257: 			D_ASSERT(bound_expr->return_type.id() != LogicalTypeId::INVALID);
258: 
259: 			// push a potential collation, if necessary
260: 			bound_expr = ExpressionBinder::PushCollation(context, move(bound_expr), group_type.collation(), true);
261: 			result->groups.push_back(move(bound_expr));
262: 
263: 			// in the unbound expression we DO bind the table names of any ColumnRefs
264: 			// we do this to make sure that "table.a" and "a" are treated the same
265: 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
266: 			// hence we convert "a" -> "test.a" in the unbound expression
267: 			unbound_groups[i] = move(group_binder.unbound_expression);
268: 			ExpressionBinder::BindTableNames(*this, *unbound_groups[i]);
269: 			info.map[unbound_groups[i].get()] = i;
270: 		}
271: 	}
272: 
273: 	// bind the HAVING clause, if any
274: 	if (statement.having) {
275: 		HavingBinder having_binder(*this, context, *result, info);
276: 		ExpressionBinder::BindTableNames(*this, *statement.having);
277: 		result->having = having_binder.Bind(statement.having);
278: 	}
279: 
280: 	// after that, we bind to the SELECT list
281: 	SelectBinder select_binder(*this, context, *result, info);
282: 	vector<LogicalType> internal_sql_types;
283: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
284: 		LogicalType result_type;
285: 		auto expr = select_binder.Bind(statement.select_list[i], &result_type);
286: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES && select_binder.BoundColumns()) {
287: 			if (select_binder.BoundAggregates()) {
288: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
289: 			}
290: 			// we are forcing aggregates, and the node has columns bound
291: 			// this entry becomes a group
292: 			auto group_ref = make_unique<BoundColumnRefExpression>(
293: 			    expr->return_type, ColumnBinding(result->group_index, result->groups.size()));
294: 			result->groups.push_back(move(expr));
295: 			expr = move(group_ref);
296: 		}
297: 		result->select_list.push_back(move(expr));
298: 		if (i < result->column_count) {
299: 			result->types.push_back(result_type);
300: 		}
301: 		internal_sql_types.push_back(result_type);
302: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
303: 			select_binder.ResetBindings();
304: 		}
305: 	}
306: 	result->need_prune = result->select_list.size() > result->column_count;
307: 
308: 	// in the normal select binder, we bind columns as if there is no aggregation
309: 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
310: 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
311: 	// we choose the former one [CONTROVERSIAL: this is the PostgreSQL behavior]
312: 	if (result->groups.size() > 0 || result->aggregates.size() > 0 || statement.having) {
313: 		if (statement.aggregate_handling == AggregateHandling::NO_AGGREGATES_ALLOWED) {
314: 			throw BinderException("Aggregates cannot be present in a Project relation!");
315: 		} else if (statement.aggregate_handling == AggregateHandling::STANDARD_HANDLING) {
316: 			if (select_binder.BoundColumns()) {
317: 				throw BinderException("column must appear in the GROUP BY clause or be used in an aggregate function");
318: 			}
319: 		}
320: 	}
321: 
322: 	// now that the SELECT list is bound, we set the types of DISTINCT/ORDER BY expressions
323: 	BindModifierTypes(*result, internal_sql_types, result->projection_index);
324: 	return move(result);
325: }
326: 
327: } // namespace duckdb
[end of src/planner/binder/query_node/bind_select_node.cpp]
[start of src/planner/binder/tableref/bind_joinref.cpp]
1: #include "duckdb/parser/tableref/joinref.hpp"
2: #include "duckdb/planner/binder.hpp"
3: #include "duckdb/planner/expression_binder/where_binder.hpp"
4: #include "duckdb/planner/tableref/bound_joinref.hpp"
5: #include "duckdb/parser/expression/columnref_expression.hpp"
6: #include "duckdb/parser/expression/constant_expression.hpp"
7: #include "duckdb/parser/expression/comparison_expression.hpp"
8: #include "duckdb/parser/expression/conjunction_expression.hpp"
9: 
10: namespace duckdb {
11: 
12: static void AddCondition(JoinRef &ref, string left_alias, string right_alias, string column_name) {
13: 	auto left_expr = make_unique<ColumnRefExpression>(column_name, left_alias);
14: 	auto right_expr = make_unique<ColumnRefExpression>(column_name, right_alias);
15: 	auto comp_expr =
16: 	    make_unique<ComparisonExpression>(ExpressionType::COMPARE_EQUAL, move(left_expr), move(right_expr));
17: 	if (!ref.condition) {
18: 		ref.condition = move(comp_expr);
19: 	} else {
20: 		ref.condition =
21: 		    make_unique<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, move(ref.condition), move(comp_expr));
22: 	}
23: }
24: 
25: unique_ptr<BoundTableRef> Binder::Bind(JoinRef &ref) {
26: 	auto result = make_unique<BoundJoinRef>();
27: 	result->left_binder = make_unique<Binder>(context, this);
28: 	result->right_binder = make_unique<Binder>(context, this);
29: 	auto &left_binder = *result->left_binder;
30: 	auto &right_binder = *result->right_binder;
31: 
32: 	result->type = ref.type;
33: 	result->left = left_binder.Bind(*ref.left);
34: 	result->right = right_binder.Bind(*ref.right);
35: 	if (ref.is_natural) {
36: 		// natural join, figure out which column names are present in both sides of the join
37: 		// first bind the left hand side and get a list of all the tables and column names
38: 		unordered_map<string, string> lhs_columns;
39: 		auto &lhs_binding_list = left_binder.bind_context.GetBindingsList();
40: 		for (auto &binding : lhs_binding_list) {
41: 			for (auto &column_name : binding.second->names) {
42: 				if (left_binder.bind_context.BindingIsHidden(binding.first, column_name)) {
43: 					continue;
44: 				}
45: 				if (lhs_columns.find(column_name) == lhs_columns.end()) {
46: 					// new column candidate: add it to the set
47: 					lhs_columns[column_name] = binding.first;
48: 				} else {
49: 					// this column candidate appears multiple times on the left-hand side of the join
50: 					// this is fine ONLY if the column name does not occur in the right hand side
51: 					// replace the binding with an empty string
52: 					lhs_columns[column_name] = string();
53: 				}
54: 			}
55: 		}
56: 		// now bind the rhs
57: 		for (auto &column : lhs_columns) {
58: 			auto &column_name = column.first;
59: 			auto &left_binding = column.second;
60: 			// loop over the set of lhs columns, and figure out if there is a table in the rhs with the same name
61: 			auto right_bindings = right_binder.bind_context.GetMatchingBindings(column_name);
62: 			string right_binding;
63: 
64: 			if (right_bindings.size() == 0) {
65: 				// no match found for this column on the rhs
66: 				continue;
67: 			}
68: 			// found this column name in both the LHS and the RHS of this join
69: 			// add it to the natural join!
70: 			// first check if the binding is ambiguous
71: 			bool left_ambiguous = left_binding.empty();
72: 			bool right_ambiguous = right_bindings.size() > 1;
73: 			if (left_ambiguous || right_ambiguous) {
74: 				// binding is ambiguous on left or right side: throw an exception
75: 				string error_msg = "Column name \"" + column_name + "\" is ambiguous: it exists more than once on the ";
76: 				error_msg += left_ambiguous ? "left" : "right";
77: 				error_msg += " side of the join.";
78: 				throw BinderException(FormatError(ref, error_msg));
79: 			}
80: 			for (auto &binding : right_bindings) {
81: 				right_binding = binding;
82: 			}
83: 			// there is a match! create the join condition
84: 			AddCondition(ref, left_binding, right_binding, column_name);
85: 			bind_context.HideBinding(right_binding, column_name);
86: 		}
87: 		if (!ref.condition) {
88: 			// no matching bindings found in natural join: throw an exception
89: 			string error_msg = "No columns found to join on in NATURAL JOIN.\n";
90: 			error_msg += "Use CROSS JOIN if you intended for this to be a cross-product.";
91: 			// gather all left/right candidates
92: 			string left_candidates, right_candidates;
93: 			auto &rhs_binding_list = right_binder.bind_context.GetBindingsList();
94: 			for (auto &binding : lhs_binding_list) {
95: 				for (auto &column_name : binding.second->names) {
96: 					if (!left_candidates.empty()) {
97: 						left_candidates += ", ";
98: 					}
99: 					left_candidates += binding.first + "." + column_name;
100: 				}
101: 			}
102: 			for (auto &binding : rhs_binding_list) {
103: 				for (auto &column_name : binding.second->names) {
104: 					if (!right_candidates.empty()) {
105: 						right_candidates += ", ";
106: 					}
107: 					right_candidates += binding.first + "." + column_name;
108: 				}
109: 			}
110: 			error_msg += "\n   Left candidates: " + left_candidates;
111: 			error_msg += "\n   Right candidates: " + right_candidates;
112: 			throw BinderException(FormatError(ref, error_msg));
113: 		}
114: 	} else if (ref.using_columns.size() > 0) {
115: 		// USING columns
116: 		D_ASSERT(!result->condition);
117: 		vector<string> left_join_bindings;
118: 
119: 		for (auto &using_column : ref.using_columns) {
120: 			// for each using column, get the matching binding
121: 			auto left_bindings = left_binder.bind_context.GetMatchingBindings(using_column);
122: 			if (left_bindings.size() == 0) {
123: 				throw BinderException("Column \"%s\" does not exist on left side of join!", using_column);
124: 			}
125: 			// find the join binding
126: 			string left_binding;
127: 			for (auto &binding : left_bindings) {
128: 				if (left_binder.bind_context.BindingIsHidden(binding, using_column)) {
129: 					continue;
130: 				}
131: 				if (!left_binding.empty()) {
132: 					string error = "Column name \"" + using_column +
133: 					               "\" is ambiguous: it exists more than once on left side of join.\nCandidates:";
134: 					for (auto &binding : left_bindings) {
135: 						error += "\n\t" + binding + "." + using_column;
136: 					}
137: 					throw BinderException(error);
138: 				} else {
139: 					left_binding = binding;
140: 				}
141: 			}
142: 			left_join_bindings.push_back(left_binding);
143: 		}
144: 		for (idx_t i = 0; i < ref.using_columns.size(); i++) {
145: 			auto &using_column = ref.using_columns[i];
146: 			auto left_binding = left_join_bindings[i];
147: 
148: 			auto right_bindings = right_binder.bind_context.GetMatchingBindings(using_column);
149: 			string right_binding;
150: 			for (auto &binding : right_bindings) {
151: 				if (right_binder.bind_context.BindingIsHidden(binding, using_column)) {
152: 					continue;
153: 				}
154: 				if (!right_binding.empty()) {
155: 					string error = "Column name \"" + using_column +
156: 					               "\" is ambiguous: it exists more than once on right side of join.\nCandidates:";
157: 					for (auto &binding : right_bindings) {
158: 						error += "\n\t" + binding + "." + using_column;
159: 					}
160: 					throw BinderException(error);
161: 				} else {
162: 					right_binding = binding;
163: 				}
164: 			}
165: 			if (right_binding.empty()) {
166: 				throw BinderException("Column \"%s\" does not exist on right side of join!", using_column);
167: 			}
168: 			D_ASSERT(!left_binding.empty());
169: 			AddCondition(ref, left_binding, right_binding, using_column);
170: 			right_binder.bind_context.HideBinding(right_binding, using_column);
171: 		}
172: 	}
173: 	bind_context.AddContext(move(left_binder.bind_context));
174: 	bind_context.AddContext(move(right_binder.bind_context));
175: 	MoveCorrelatedExpressions(left_binder);
176: 	MoveCorrelatedExpressions(right_binder);
177: 	if (ref.condition) {
178: 		WhereBinder binder(*this, context);
179: 		result->condition = binder.Bind(ref.condition);
180: 	}
181: 	return move(result);
182: }
183: 
184: } // namespace duckdb
[end of src/planner/binder/tableref/bind_joinref.cpp]
[start of tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp]
1: #include "sqlite3.h"
2: 
3: #include "duckdb.hpp"
4: #include "duckdb/parser/parser.hpp"
5: #include "duckdb/main/client_context.hpp"
6: 
7: #include <ctype.h>
8: #include <stdio.h>
9: #include <stdlib.h>
10: #include <string.h>
11: #include <time.h>
12: #include <string>
13: #include <chrono>
14: #include <cassert>
15: 
16: #include "extension_helper.hpp"
17: 
18: using namespace duckdb;
19: using namespace std;
20: 
21: static char *sqlite3_strdup(const char *str);
22: 
23: struct sqlite3_string_buffer {
24: 	//! String data
25: 	unique_ptr<char[]> data;
26: };
27: 
28: struct sqlite3_stmt {
29: 	//! The DB object that this statement belongs to
30: 	sqlite3 *db;
31: 	//! The query string
32: 	string query_string;
33: 	//! The prepared statement object, if successfully prepared
34: 	unique_ptr<PreparedStatement> prepared;
35: 	//! The result object, if successfully executed
36: 	unique_ptr<QueryResult> result;
37: 	//! The current chunk that we are iterating over
38: 	unique_ptr<DataChunk> current_chunk;
39: 	//! The current row into the current chunk that we are iterating over
40: 	int64_t current_row;
41: 	//! Bound values, used for binding to the prepared statement
42: 	vector<Value> bound_values;
43: 	//! Names of the prepared parameters
44: 	vector<string> bound_names;
45: 	//! The current column values converted to string, used and filled by sqlite3_column_text
46: 	unique_ptr<sqlite3_string_buffer[]> current_text;
47: };
48: 
49: struct sqlite3 {
50: 	unique_ptr<DuckDB> db;
51: 	unique_ptr<Connection> con;
52: 	string last_error;
53: };
54: 
55: void sqlite3_randomness(int N, void *pBuf) {
56: 	static bool init = false;
57: 	if (!init) {
58: 		srand(time(NULL));
59: 		init = true;
60: 	}
61: 	unsigned char *zBuf = (unsigned char *)pBuf;
62: 	while (N--) {
63: 		unsigned char nextByte = rand() % 255;
64: 		zBuf[N] = nextByte;
65: 	}
66: }
67: 
68: int sqlite3_open(const char *filename, /* Database filename (UTF-8) */
69:                  sqlite3 **ppDb        /* OUT: SQLite db handle */
70: ) {
71: 	return sqlite3_open_v2(filename, ppDb, 0, NULL);
72: }
73: 
74: int sqlite3_open_v2(const char *filename, /* Database filename (UTF-8) */
75:                     sqlite3 **ppDb,       /* OUT: SQLite db handle */
76:                     int flags,            /* Flags */
77:                     const char *zVfs      /* Name of VFS module to use */
78: ) {
79: 	if (filename && strcmp(filename, ":memory:") == 0) {
80: 		filename = NULL;
81: 	}
82: 	*ppDb = nullptr;
83: 	if (zVfs) { /* unsupported so if set we complain */
84: 		return SQLITE_ERROR;
85: 	}
86: 	sqlite3 *pDb = nullptr;
87: 	try {
88: 		pDb = new sqlite3();
89: 		DBConfig config;
90: 		config.access_mode = AccessMode::AUTOMATIC;
91: 		if (flags & SQLITE_OPEN_READONLY) {
92: 			config.access_mode = AccessMode::READ_ONLY;
93: 		}
94: 		pDb->db = make_unique<DuckDB>(filename, &config);
95: 		pDb->con = make_unique<Connection>(*pDb->db);
96: 
97: 		ExtensionHelper::LoadAllExtensions(*pDb->db);
98: 	} catch (std::exception &ex) {
99: 		if (pDb) {
100: 			pDb->last_error = ex.what();
101: 		}
102: 		return SQLITE_ERROR;
103: 	}
104: 	*ppDb = pDb;
105: 	return SQLITE_OK;
106: }
107: 
108: int sqlite3_close(sqlite3 *db) {
109: 	if (db) {
110: 		delete db;
111: 	}
112: 	return SQLITE_OK;
113: }
114: 
115: int sqlite3_shutdown(void) {
116: 	return SQLITE_OK;
117: }
118: 
119: /* In SQLite this function compiles the query into VDBE bytecode,
120:  * in the implementation it currently executes the query */
121: // TODO: prepare the statement instead of executing right away
122: int sqlite3_prepare_v2(sqlite3 *db,           /* Database handle */
123:                        const char *zSql,      /* SQL statement, UTF-8 encoded */
124:                        int nByte,             /* Maximum length of zSql in bytes. */
125:                        sqlite3_stmt **ppStmt, /* OUT: Statement handle */
126:                        const char **pzTail    /* OUT: Pointer to unused portion of zSql */
127: ) {
128: 	if (!db || !ppStmt || !zSql) {
129: 		return SQLITE_MISUSE;
130: 	}
131: 	*ppStmt = nullptr;
132: 	string query = nByte < 0 ? zSql : string(zSql, nByte);
133: 	if (pzTail) {
134: 		*pzTail = zSql + query.size();
135: 	}
136: 	try {
137: 		Parser parser;
138: 		parser.ParseQuery(query);
139: 		if (parser.statements.size() == 0) {
140: 			return SQLITE_OK;
141: 		}
142: 		// extract the remainder
143: 		idx_t next_location = parser.statements[0]->stmt_location + parser.statements[0]->stmt_length;
144: 		bool set_remainder = next_location < query.size();
145: 
146: 		// extract the first statement
147: 		vector<unique_ptr<SQLStatement>> statements;
148: 		statements.push_back(move(parser.statements[0]));
149: 
150: 		db->con->context->HandlePragmaStatements(statements);
151: 
152: 		// if there are multiple statements here, we are dealing with an import database statement
153: 		// we directly execute all statements besides the final one
154: 		for (idx_t i = 0; i + 1 < statements.size(); i++) {
155: 			auto res = db->con->Query(move(statements[i]));
156: 			if (!res->success) {
157: 				db->last_error = res->error;
158: 				return SQLITE_ERROR;
159: 			}
160: 		}
161: 
162: 		// now prepare the query
163: 		auto prepared = db->con->Prepare(move(statements.back()));
164: 		if (!prepared->success) {
165: 			// failed to prepare: set the error message
166: 			db->last_error = prepared->error;
167: 			return SQLITE_ERROR;
168: 		}
169: 
170: 		// create the statement entry
171: 		unique_ptr<sqlite3_stmt> stmt = make_unique<sqlite3_stmt>();
172: 		stmt->db = db;
173: 		stmt->query_string = query;
174: 		stmt->prepared = move(prepared);
175: 		stmt->current_row = -1;
176: 		for (idx_t i = 0; i < stmt->prepared->n_param; i++) {
177: 			stmt->bound_names.push_back("$" + to_string(i + 1));
178: 			stmt->bound_values.push_back(Value());
179: 		}
180: 
181: 		// extract the remainder of the query and assign it to the pzTail
182: 		if (pzTail && set_remainder) {
183: 			*pzTail = zSql + next_location + 1;
184: 		}
185: 
186: 		*ppStmt = stmt.release();
187: 		return SQLITE_OK;
188: 	} catch (std::exception &ex) {
189: 		db->last_error = ex.what();
190: 		return SQLITE_ERROR;
191: 	}
192: }
193: 
194: bool sqlite3_display_result(StatementType type) {
195: 	switch (type) {
196: 	case StatementType::EXECUTE_STATEMENT:
197: 	case StatementType::EXPLAIN_STATEMENT:
198: 	case StatementType::PRAGMA_STATEMENT:
199: 	case StatementType::SELECT_STATEMENT:
200: 		return true;
201: 	default:
202: 		return false;
203: 	}
204: }
205: 
206: /* Prepare the next result to be retrieved */
207: int sqlite3_step(sqlite3_stmt *pStmt) {
208: 	if (!pStmt) {
209: 		return SQLITE_MISUSE;
210: 	}
211: 	if (!pStmt->prepared) {
212: 		pStmt->db->last_error = "Attempting sqlite3_step() on a non-successfully prepared statement";
213: 		return SQLITE_ERROR;
214: 	}
215: 	pStmt->current_text = nullptr;
216: 	if (!pStmt->result) {
217: 		// no result yet! call Execute()
218: 		pStmt->result = pStmt->prepared->Execute(pStmt->bound_values, false);
219: 		if (!pStmt->result->success) {
220: 			// error in execute: clear prepared statement
221: 			pStmt->db->last_error = pStmt->result->error;
222: 			pStmt->prepared = nullptr;
223: 			return SQLITE_ERROR;
224: 		}
225: 		// fetch a chunk
226: 		pStmt->current_chunk = pStmt->result->Fetch();
227: 		pStmt->current_row = -1;
228: 		if (!sqlite3_display_result(pStmt->prepared->GetStatementType())) {
229: 			// only SELECT statements return results
230: 			sqlite3_reset(pStmt);
231: 		}
232: 	}
233: 	if (!pStmt->current_chunk || pStmt->current_chunk->size() == 0) {
234: 		return SQLITE_DONE;
235: 	}
236: 	pStmt->current_row++;
237: 	if (pStmt->current_row >= (int32_t)pStmt->current_chunk->size()) {
238: 		// have to fetch again!
239: 		pStmt->current_row = 0;
240: 		pStmt->current_chunk = pStmt->result->Fetch();
241: 		if (!pStmt->current_chunk || pStmt->current_chunk->size() == 0) {
242: 			sqlite3_reset(pStmt);
243: 			return SQLITE_DONE;
244: 		}
245: 	}
246: 	return SQLITE_ROW;
247: }
248: 
249: /* Execute multiple semicolon separated SQL statements
250:  * and execute the passed callback for each produced result,
251:  * largely copied from the original sqlite3 source */
252: int sqlite3_exec(sqlite3 *db,                /* The database on which the SQL executes */
253:                  const char *zSql,           /* The SQL to be executed */
254:                  sqlite3_callback xCallback, /* Invoke this callback routine */
255:                  void *pArg,                 /* First argument to xCallback() */
256:                  char **pzErrMsg             /* Write error messages here */
257: ) {
258: 	int rc = SQLITE_OK;            /* Return code */
259: 	const char *zLeftover;         /* Tail of unprocessed SQL */
260: 	sqlite3_stmt *pStmt = nullptr; /* The current SQL statement */
261: 	char **azCols = nullptr;       /* Names of result columns */
262: 	char **azVals = nullptr;       /* Result values */
263: 
264: 	if (zSql == nullptr) {
265: 		zSql = "";
266: 	}
267: 
268: 	while (rc == SQLITE_OK && zSql[0]) {
269: 		int nCol;
270: 
271: 		pStmt = nullptr;
272: 		rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
273: 		if (rc != SQLITE_OK) {
274: 			if (pzErrMsg) {
275: 				auto errmsg = sqlite3_errmsg(db);
276: 				*pzErrMsg = errmsg ? sqlite3_strdup(errmsg) : nullptr;
277: 			}
278: 			continue;
279: 		}
280: 		if (!pStmt) {
281: 			/* this happens for a comment or white-space */
282: 			zSql = zLeftover;
283: 			continue;
284: 		}
285: 
286: 		nCol = sqlite3_column_count(pStmt);
287: 		azCols = (char **)malloc(nCol * sizeof(const char *));
288: 		azVals = (char **)malloc(nCol * sizeof(const char *));
289: 		if (!azCols || !azVals) {
290: 			goto exec_out;
291: 		}
292: 		for (int i = 0; i < nCol; i++) {
293: 			azCols[i] = (char *)sqlite3_column_name(pStmt, i);
294: 		}
295: 
296: 		while (true) {
297: 			rc = sqlite3_step(pStmt);
298: 
299: 			/* Invoke the callback function if required */
300: 			if (xCallback && rc == SQLITE_ROW) {
301: 				for (int i = 0; i < nCol; i++) {
302: 					azVals[i] = (char *)sqlite3_column_text(pStmt, i);
303: 					if (!azVals[i] && sqlite3_column_type(pStmt, i) != SQLITE_NULL) {
304: 						fprintf(stderr, "sqlite3_exec: out of memory.\n");
305: 						goto exec_out;
306: 					}
307: 				}
308: 				if (xCallback(pArg, nCol, azVals, azCols)) {
309: 					/* EVIDENCE-OF: R-38229-40159 If the callback function to
310: 					** sqlite3_exec() returns non-zero, then sqlite3_exec() will
311: 					** return SQLITE_ABORT. */
312: 					rc = SQLITE_ABORT;
313: 					sqlite3_finalize(pStmt);
314: 					pStmt = 0;
315: 					fprintf(stderr, "sqlite3_exec: callback returned non-zero. "
316: 					                "Aborting.\n");
317: 					goto exec_out;
318: 				}
319: 			}
320: 			if (rc == SQLITE_DONE) {
321: 				rc = sqlite3_finalize(pStmt);
322: 				pStmt = nullptr;
323: 				zSql = zLeftover;
324: 				while (isspace(zSql[0]))
325: 					zSql++;
326: 				break;
327: 			} else if (rc != SQLITE_ROW) {
328: 				// error
329: 				if (pzErrMsg) {
330: 					auto errmsg = sqlite3_errmsg(db);
331: 					*pzErrMsg = errmsg ? sqlite3_strdup(errmsg) : nullptr;
332: 				}
333: 				goto exec_out;
334: 			}
335: 		}
336: 
337: 		sqlite3_free(azCols);
338: 		sqlite3_free(azVals);
339: 		azCols = nullptr;
340: 		azVals = nullptr;
341: 	}
342: 
343: exec_out:
344: 	if (pStmt) {
345: 		sqlite3_finalize(pStmt);
346: 	}
347: 	sqlite3_free(azCols);
348: 	sqlite3_free(azVals);
349: 	if (rc != SQLITE_OK && pzErrMsg && !*pzErrMsg) {
350: 		// error but no error message set
351: 		*pzErrMsg = sqlite3_strdup("Unknown error in DuckDB!");
352: 	}
353: 	return rc;
354: }
355: 
356: /* Return the text of the SQL that was used to prepare the statement */
357: const char *sqlite3_sql(sqlite3_stmt *pStmt) {
358: 	return pStmt->query_string.c_str();
359: }
360: 
361: int sqlite3_column_count(sqlite3_stmt *pStmt) {
362: 	if (!pStmt || !pStmt->prepared) {
363: 		return 0;
364: 	}
365: 	return (int)pStmt->prepared->ColumnCount();
366: }
367: 
368: ////////////////////////////
369: //     sqlite3_column     //
370: ////////////////////////////
371: int sqlite3_column_type(sqlite3_stmt *pStmt, int iCol) {
372: 	if (!pStmt || !pStmt->result || !pStmt->current_chunk) {
373: 		return 0;
374: 	}
375: 	if (FlatVector::IsNull(pStmt->current_chunk->data[iCol], pStmt->current_row)) {
376: 		return SQLITE_NULL;
377: 	}
378: 	auto column_type = pStmt->result->types[iCol];
379: 	switch (column_type.id()) {
380: 	case LogicalTypeId::BOOLEAN:
381: 	case LogicalTypeId::TINYINT:
382: 	case LogicalTypeId::SMALLINT:
383: 	case LogicalTypeId::INTEGER:
384: 	case LogicalTypeId::BIGINT: /* TODO: Maybe blob? */
385: 		return SQLITE_INTEGER;
386: 	case LogicalTypeId::FLOAT:
387: 	case LogicalTypeId::DOUBLE:
388: 	case LogicalTypeId::DECIMAL:
389: 		return SQLITE_FLOAT;
390: 	case LogicalTypeId::DATE:
391: 	case LogicalTypeId::TIME:
392: 	case LogicalTypeId::TIMESTAMP:
393: 	case LogicalTypeId::VARCHAR:
394: 	case LogicalTypeId::LIST:
395: 	case LogicalTypeId::STRUCT:
396: 		return SQLITE_TEXT;
397: 	case LogicalTypeId::BLOB:
398: 		return SQLITE_BLOB;
399: 	default:
400: 		return 0;
401: 	}
402: 	return 0;
403: }
404: 
405: const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N) {
406: 	if (!pStmt || !pStmt->prepared) {
407: 		return nullptr;
408: 	}
409: 	return pStmt->prepared->GetNames()[N].c_str();
410: }
411: 
412: static bool sqlite3_column_has_value(sqlite3_stmt *pStmt, int iCol, LogicalType target_type, Value &val) {
413: 	if (!pStmt || !pStmt->result || !pStmt->current_chunk) {
414: 		return false;
415: 	}
416: 	if (iCol < 0 || iCol >= (int)pStmt->result->types.size()) {
417: 		return false;
418: 	}
419: 	if (FlatVector::IsNull(pStmt->current_chunk->data[iCol], pStmt->current_row)) {
420: 		return false;
421: 	}
422: 	try {
423: 		val = pStmt->current_chunk->data[iCol].GetValue(pStmt->current_row).CastAs(target_type);
424: 	} catch (...) {
425: 		return false;
426: 	}
427: 	return true;
428: }
429: 
430: double sqlite3_column_double(sqlite3_stmt *stmt, int iCol) {
431: 	Value val;
432: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::DOUBLE, val)) {
433: 		return 0;
434: 	}
435: 	return val.value_.double_;
436: }
437: 
438: int sqlite3_column_int(sqlite3_stmt *stmt, int iCol) {
439: 	Value val;
440: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::INTEGER, val)) {
441: 		return 0;
442: 	}
443: 	return val.value_.integer;
444: }
445: 
446: sqlite3_int64 sqlite3_column_int64(sqlite3_stmt *stmt, int iCol) {
447: 	Value val;
448: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::BIGINT, val)) {
449: 		return 0;
450: 	}
451: 	return val.value_.bigint;
452: }
453: 
454: const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int iCol) {
455: 	Value val;
456: 	if (!sqlite3_column_has_value(pStmt, iCol, LogicalType::VARCHAR, val)) {
457: 		return nullptr;
458: 	}
459: 	try {
460: 		if (!pStmt->current_text) {
461: 			pStmt->current_text =
462: 			    unique_ptr<sqlite3_string_buffer[]>(new sqlite3_string_buffer[pStmt->result->types.size()]);
463: 		}
464: 		auto &entry = pStmt->current_text[iCol];
465: 		if (!entry.data) {
466: 			// not initialized yet, convert the value and initialize it
467: 			entry.data = unique_ptr<char[]>(new char[val.str_value.size() + 1]);
468: 			memcpy(entry.data.get(), val.str_value.c_str(), val.str_value.size() + 1);
469: 		}
470: 		return (const unsigned char *)entry.data.get();
471: 	} catch (...) {
472: 		// memory error!
473: 		return nullptr;
474: 	}
475: }
476: 
477: ////////////////////////////
478: //      sqlite3_bind      //
479: ////////////////////////////
480: int sqlite3_bind_parameter_count(sqlite3_stmt *stmt) {
481: 	if (!stmt) {
482: 		return 0;
483: 	}
484: 	return stmt->prepared->n_param;
485: }
486: 
487: const char *sqlite3_bind_parameter_name(sqlite3_stmt *stmt, int idx) {
488: 	if (!stmt) {
489: 		return nullptr;
490: 	}
491: 	if (idx < 1 || idx > (int)stmt->prepared->n_param) {
492: 		return nullptr;
493: 	}
494: 	return stmt->bound_names[idx - 1].c_str();
495: }
496: 
497: int sqlite3_bind_parameter_index(sqlite3_stmt *stmt, const char *zName) {
498: 	if (!stmt || !zName) {
499: 		return 0;
500: 	}
501: 	for (idx_t i = 0; i < stmt->bound_names.size(); i++) {
502: 		if (stmt->bound_names[i] == string(zName)) {
503: 			return i + 1;
504: 		}
505: 	}
506: 	return 0;
507: }
508: 
509: int sqlite3_internal_bind_value(sqlite3_stmt *stmt, int idx, Value value) {
510: 	if (!stmt || !stmt->prepared || stmt->result) {
511: 		return SQLITE_MISUSE;
512: 	}
513: 	if (idx < 1 || idx > (int)stmt->prepared->n_param) {
514: 		return SQLITE_RANGE;
515: 	}
516: 	stmt->bound_values[idx - 1] = value;
517: 	return SQLITE_OK;
518: }
519: 
520: int sqlite3_bind_int(sqlite3_stmt *stmt, int idx, int val) {
521: 	return sqlite3_internal_bind_value(stmt, idx, Value::INTEGER(val));
522: }
523: 
524: int sqlite3_bind_int64(sqlite3_stmt *stmt, int idx, sqlite3_int64 val) {
525: 	return sqlite3_internal_bind_value(stmt, idx, Value::BIGINT(val));
526: }
527: 
528: int sqlite3_bind_double(sqlite3_stmt *stmt, int idx, double val) {
529: 	return sqlite3_internal_bind_value(stmt, idx, Value::DOUBLE(val));
530: }
531: 
532: int sqlite3_bind_null(sqlite3_stmt *stmt, int idx) {
533: 	return sqlite3_internal_bind_value(stmt, idx, Value());
534: }
535: 
536: SQLITE_API int sqlite3_bind_value(sqlite3_stmt *, int, const sqlite3_value *) {
537: 	fprintf(stderr, "sqlite3_bind_value: unsupported.\n");
538: 	return SQLITE_ERROR;
539: }
540: 
541: int sqlite3_bind_text(sqlite3_stmt *stmt, int idx, const char *val, int length, void (*free_func)(void *)) {
542: 	if (!val) {
543: 		return SQLITE_MISUSE;
544: 	}
545: 	string value;
546: 	if (length < 0) {
547: 		value = string(val);
548: 	} else {
549: 		value = string(val, val + length);
550: 	}
551: 	if (free_func && ((ptrdiff_t)free_func) != -1) {
552: 		free_func((void *)val);
553: 	}
554: 	try {
555: 		return sqlite3_internal_bind_value(stmt, idx, Value(value));
556: 	} catch (std::exception &ex) {
557: 		return SQLITE_ERROR;
558: 	}
559: }
560: 
561: int sqlite3_clear_bindings(sqlite3_stmt *stmt) {
562: 	if (!stmt) {
563: 		return SQLITE_MISUSE;
564: 	}
565: 	return SQLITE_OK;
566: }
567: 
568: int sqlite3_initialize(void) {
569: 	return SQLITE_OK;
570: }
571: 
572: int sqlite3_finalize(sqlite3_stmt *pStmt) {
573: 	if (pStmt) {
574: 		if (pStmt->result && !pStmt->result->success) {
575: 			pStmt->db->last_error = string(pStmt->result->error);
576: 			delete pStmt;
577: 			return SQLITE_ERROR;
578: 		}
579: 
580: 		delete pStmt;
581: 	}
582: 	return SQLITE_OK;
583: }
584: 
585: /*
586: ** Some systems have stricmp().  Others have strcasecmp().  Because
587: ** there is no consistency, we will define our own.
588: **
589: ** IMPLEMENTATION-OF: R-30243-02494 The sqlite3_stricmp() and
590: ** sqlite3_strnicmp() APIs allow applications and extensions to compare
591: ** the contents of two buffers containing UTF-8 strings in a
592: ** case-independent fashion, using the same definition of "case
593: ** independence" that SQLite uses internally when comparing identifiers.
594: */
595: 
596: const unsigned char sqlite3UpperToLower[] = {
597:     0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,
598:     22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,
599:     44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  97,
600:     98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
601:     120, 121, 122, 91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
602:     110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
603:     132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,
604:     154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
605:     176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,
606:     198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
607:     220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
608:     242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255};
609: 
610: int sqlite3StrICmp(const char *zLeft, const char *zRight) {
611: 	unsigned char *a, *b;
612: 	int c;
613: 	a = (unsigned char *)zLeft;
614: 	b = (unsigned char *)zRight;
615: 	for (;;) {
616: 		c = (int)sqlite3UpperToLower[*a] - (int)sqlite3UpperToLower[*b];
617: 		if (c || *a == 0)
618: 			break;
619: 		a++;
620: 		b++;
621: 	}
622: 	return c;
623: }
624: 
625: SQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight) {
626: 	if (zLeft == 0) {
627: 		return zRight ? -1 : 0;
628: 	} else if (zRight == 0) {
629: 		return 1;
630: 	}
631: 	return sqlite3StrICmp(zLeft, zRight);
632: }
633: 
634: SQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N) {
635: 	unsigned char *a, *b;
636: 	if (zLeft == 0) {
637: 		return zRight ? -1 : 0;
638: 	} else if (zRight == 0) {
639: 		return 1;
640: 	}
641: 	a = (unsigned char *)zLeft;
642: 	b = (unsigned char *)zRight;
643: 	while (N-- > 0 && *a != 0 && sqlite3UpperToLower[*a] == sqlite3UpperToLower[*b]) {
644: 		a++;
645: 		b++;
646: 	}
647: 	return N < 0 ? 0 : sqlite3UpperToLower[*a] - sqlite3UpperToLower[*b];
648: }
649: 
650: char *sqlite3_strdup(const char *str) {
651: 	char *result = (char *)sqlite3_malloc64(strlen(str) + 1);
652: 	strcpy(result, str);
653: 	return result;
654: }
655: 
656: void *sqlite3_malloc64(sqlite3_uint64 n) {
657: 	return malloc(n);
658: }
659: void sqlite3_free(void *pVoid) {
660: 	free(pVoid);
661: }
662: 
663: void *sqlite3_malloc(int n) {
664: 	return sqlite3_malloc64(n);
665: }
666: 
667: void *sqlite3_realloc(void *ptr, int n) {
668: 	return sqlite3_realloc64(ptr, n);
669: }
670: 
671: void *sqlite3_realloc64(void *ptr, sqlite3_uint64 n) {
672: 	return realloc(ptr, n);
673: }
674: 
675: // TODO: stub
676: int sqlite3_config(int i, ...) {
677: 	return SQLITE_OK;
678: }
679: 
680: int sqlite3_errcode(sqlite3 *db) {
681: 	if (!db) {
682: 		return SQLITE_MISUSE;
683: 	}
684: 	return db->last_error.empty() ? SQLITE_OK : SQLITE_ERROR;
685: }
686: 
687: int sqlite3_extended_errcode(sqlite3 *db) {
688: 	return sqlite3_errcode(db);
689: }
690: 
691: const char *sqlite3_errmsg(sqlite3 *db) {
692: 	if (!db) {
693: 		return "";
694: 	}
695: 	return db->last_error.c_str();
696: }
697: 
698: void sqlite3_interrupt(sqlite3 *db) {
699: 	if (db) {
700: 		db->con->Interrupt();
701: 	}
702: }
703: 
704: const char *sqlite3_libversion(void) {
705: 	return DuckDB::LibraryVersion();
706: }
707: const char *sqlite3_sourceid(void) {
708: 	return DuckDB::SourceID();
709: }
710: 
711: int sqlite3_reset(sqlite3_stmt *stmt) {
712: 	if (stmt) {
713: 		stmt->result = nullptr;
714: 		stmt->current_chunk = nullptr;
715: 	}
716: 	return SQLITE_OK;
717: }
718: 
719: // support functions for shell.c
720: // most are dummies, we don't need them really
721: 
722: int sqlite3_db_status(sqlite3 *, int op, int *pCur, int *pHiwtr, int resetFlg) {
723: 	fprintf(stderr, "sqlite3_db_status: unsupported.\n");
724: 	return -1;
725: }
726: 
727: // TODO these should eventually be implemented
728: 
729: int sqlite3_changes(sqlite3 *db) {
730: 	fprintf(stderr, "sqlite3_changes: unsupported.\n");
731: 	return 0;
732: }
733: 
734: int sqlite3_total_changes(sqlite3 *) {
735: 	fprintf(stderr, "sqlite3_total_changes: unsupported.\n");
736: 	return 0;
737: }
738: 
739: // some code borrowed from sqlite
740: // its probably best to match its behavior
741: 
742: typedef uint8_t u8;
743: 
744: /*
745: ** Token types used by the sqlite3_complete() routine.  See the header
746: ** comments on that procedure for additional information.
747: */
748: #define tkSEMI 0
749: #define tkWS 1
750: #define tkOTHER 2
751: 
752: const unsigned char sqlite3CtypeMap[256] = {
753:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 00..07    ........ */
754:     0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, /* 08..0f    ........ */
755:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 10..17    ........ */
756:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 18..1f    ........ */
757:     0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80, /* 20..27     !"#$%&' */
758:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 28..2f    ()*+,-./ */
759:     0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, /* 30..37    01234567 */
760:     0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 38..3f    89:;<=>? */
761: 
762:     0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02, /* 40..47    @ABCDEFG */
763:     0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, /* 48..4f    HIJKLMNO */
764:     0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, /* 50..57    PQRSTUVW */
765:     0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40, /* 58..5f    XYZ[\]^_ */
766:     0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22, /* 60..67    `abcdefg */
767:     0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, /* 68..6f    hijklmno */
768:     0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, /* 70..77    pqrstuvw */
769:     0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, /* 78..7f    xyz{|}~. */
770: 
771:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 80..87    ........ */
772:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 88..8f    ........ */
773:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 90..97    ........ */
774:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 98..9f    ........ */
775:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* a0..a7    ........ */
776:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* a8..af    ........ */
777:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* b0..b7    ........ */
778:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* b8..bf    ........ */
779: 
780:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* c0..c7    ........ */
781:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* c8..cf    ........ */
782:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* d0..d7    ........ */
783:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* d8..df    ........ */
784:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* e0..e7    ........ */
785:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* e8..ef    ........ */
786:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* f0..f7    ........ */
787:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40  /* f8..ff    ........ */
788: };
789: 
790: // TODO this can probably be simplified
791: #define IdChar(C) ((sqlite3CtypeMap[(unsigned char)C] & 0x46) != 0)
792: 
793: int sqlite3_complete(const char *zSql) {
794: 	u8 state = 0; /* Current state, using numbers defined in header comment */
795: 	u8 token;     /* Value of the next token */
796: 
797: 	/* If triggers are not supported by this compile then the statement machine
798: 	 ** used to detect the end of a statement is much simpler
799: 	 */
800: 	static const u8 trans[3][3] = {
801: 	    /* Token:           */
802: 	    /* State:       **  SEMI  WS  OTHER */
803: 	    /* 0 INVALID: */ {
804: 	        1,
805: 	        0,
806: 	        2,
807: 	    },
808: 	    /* 1   START: */
809: 	    {
810: 	        1,
811: 	        1,
812: 	        2,
813: 	    },
814: 	    /* 2  NORMAL: */
815: 	    {
816: 	        1,
817: 	        2,
818: 	        2,
819: 	    },
820: 	};
821: 
822: 	while (*zSql) {
823: 		switch (*zSql) {
824: 		case ';': { /* A semicolon */
825: 			token = tkSEMI;
826: 			break;
827: 		}
828: 		case ' ':
829: 		case '\r':
830: 		case '\t':
831: 		case '\n':
832: 		case '\f': { /* White space is ignored */
833: 			token = tkWS;
834: 			break;
835: 		}
836: 		case '/': { /* C-style comments */
837: 			if (zSql[1] != '*') {
838: 				token = tkOTHER;
839: 				break;
840: 			}
841: 			zSql += 2;
842: 			while (zSql[0] && (zSql[0] != '*' || zSql[1] != '/')) {
843: 				zSql++;
844: 			}
845: 			if (zSql[0] == 0)
846: 				return 0;
847: 			zSql++;
848: 			token = tkWS;
849: 			break;
850: 		}
851: 		case '-': { /* SQL-style comments from "--" to end of line */
852: 			if (zSql[1] != '-') {
853: 				token = tkOTHER;
854: 				break;
855: 			}
856: 			while (*zSql && *zSql != '\n') {
857: 				zSql++;
858: 			}
859: 			if (*zSql == 0)
860: 				return state == 1;
861: 			token = tkWS;
862: 			break;
863: 		}
864: 		case '[': { /* Microsoft-style identifiers in [...] */
865: 			zSql++;
866: 			while (*zSql && *zSql != ']') {
867: 				zSql++;
868: 			}
869: 			if (*zSql == 0)
870: 				return 0;
871: 			token = tkOTHER;
872: 			break;
873: 		}
874: 		case '`': /* Grave-accent quoted symbols used by MySQL */
875: 		case '"': /* single- and double-quoted strings */
876: 		case '\'': {
877: 			int c = *zSql;
878: 			zSql++;
879: 			while (*zSql && *zSql != c) {
880: 				zSql++;
881: 			}
882: 			if (*zSql == 0)
883: 				return 0;
884: 			token = tkOTHER;
885: 			break;
886: 		}
887: 		default: {
888: 
889: 			if (IdChar((u8)*zSql)) {
890: 				/* Keywords and unquoted identifiers */
891: 				int nId;
892: 				for (nId = 1; IdChar(zSql[nId]); nId++) {
893: 				}
894: 				token = tkOTHER;
895: 
896: 				zSql += nId - 1;
897: 			} else {
898: 				/* Operators and special symbols */
899: 				token = tkOTHER;
900: 			}
901: 			break;
902: 		}
903: 		}
904: 		state = trans[state][token];
905: 		zSql++;
906: 	}
907: 	return state == 1;
908: }
909: 
910: // checks if input ends with ;
911: int sqlite3_complete_old(const char *sql) {
912: 	fprintf(stderr, "sqlite3_complete: unsupported. '%s'\n", sql);
913: 	return -1;
914: }
915: 
916: int sqlite3_bind_blob(sqlite3_stmt *, int, const void *, int n, void (*)(void *)) {
917: 	fprintf(stderr, "sqlite3_bind_blob: unsupported.\n");
918: 	return -1;
919: }
920: 
921: const void *sqlite3_column_blob(sqlite3_stmt *, int iCol) {
922: 	fprintf(stderr, "sqlite3_column_blob: unsupported.\n");
923: 	return nullptr;
924: }
925: 
926: // length of varchar or blob value
927: int sqlite3_column_bytes(sqlite3_stmt *, int iCol) {
928: 	fprintf(stderr, "sqlite3_column_bytes: unsupported.\n");
929: 	return -1;
930: }
931: 
932: sqlite3_value *sqlite3_column_value(sqlite3_stmt *, int iCol) {
933: 	fprintf(stderr, "sqlite3_column_value: unsupported.\n");
934: 	return nullptr;
935: }
936: 
937: int sqlite3_db_config(sqlite3 *, int op, ...) {
938: 	fprintf(stderr, "sqlite3_db_config: unsupported.\n");
939: 	return -1;
940: }
941: 
942: int sqlite3_get_autocommit(sqlite3 *db) {
943: 	return 1;
944: 	// TODO fix this
945: 	// return db->con->context->transaction.IsAutoCommit();
946: 	fprintf(stderr, "sqlite3_get_autocommit: unsupported.\n");
947: }
948: 
949: int sqlite3_limit(sqlite3 *, int id, int newVal) {
950: 	fprintf(stderr, "sqlite3_limit: unsupported.\n");
951: 	return -1;
952: }
953: 
954: int sqlite3_stmt_readonly(sqlite3_stmt *pStmt) {
955: 	fprintf(stderr, "sqlite3_stmt_readonly: unsupported.\n");
956: 	return -1;
957: }
958: 
959: // TODO pretty easy schema lookup
960: int sqlite3_table_column_metadata(sqlite3 *db,             /* Connection handle */
961:                                   const char *zDbName,     /* Database name or NULL */
962:                                   const char *zTableName,  /* Table name */
963:                                   const char *zColumnName, /* Column name */
964:                                   char const **pzDataType, /* OUTPUT: Declared data type */
965:                                   char const **pzCollSeq,  /* OUTPUT: Collation sequence name */
966:                                   int *pNotNull,           /* OUTPUT: True if NOT NULL constraint exists */
967:                                   int *pPrimaryKey,        /* OUTPUT: True if column part of PK */
968:                                   int *pAutoinc            /* OUTPUT: True if column is auto-increment */
969: ) {
970: 	fprintf(stderr, "sqlite3_table_column_metadata: unsupported.\n");
971: 	return -1;
972: }
973: 
974: const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int iCol) {
975: 	if (!pStmt || !pStmt->prepared) {
976: 		return NULL;
977: 	}
978: 	auto column_type = pStmt->prepared->GetTypes()[iCol];
979: 	switch (column_type.id()) {
980: 	case LogicalTypeId::BOOLEAN:
981: 		return "BOOLEAN";
982: 	case LogicalTypeId::TINYINT:
983: 		return "TINYINT";
984: 	case LogicalTypeId::SMALLINT:
985: 		return "SMALLINT";
986: 	case LogicalTypeId::INTEGER:
987: 		return "INTEGER";
988: 	case LogicalTypeId::BIGINT:
989: 		return "BIGINT";
990: 	case LogicalTypeId::FLOAT:
991: 		return "FLOAT";
992: 	case LogicalTypeId::DOUBLE:
993: 		return "DOUBLE";
994: 	case LogicalTypeId::DECIMAL:
995: 		return "DECIMAL";
996: 	case LogicalTypeId::DATE:
997: 		return "DATE";
998: 	case LogicalTypeId::TIME:
999: 		return "TIME";
1000: 	case LogicalTypeId::TIMESTAMP:
1001: 		return "TIMESTAMP";
1002: 	case LogicalTypeId::VARCHAR:
1003: 		return "VARCHAR";
1004: 	case LogicalTypeId::LIST:
1005: 		return "LIST";
1006: 	case LogicalTypeId::STRUCT:
1007: 		return "STRUCT";
1008: 	case LogicalTypeId::BLOB:
1009: 		return "BLOB";
1010: 	default:
1011: 		return NULL;
1012: 	}
1013: 	return NULL;
1014: }
1015: 
1016: int sqlite3_status64(int op, sqlite3_int64 *pCurrent, sqlite3_int64 *pHighwater, int resetFlag) {
1017: 	fprintf(stderr, "sqlite3_status64: unsupported.\n");
1018: 	return -1;
1019: }
1020: 
1021: int sqlite3_status64(sqlite3 *, int op, int *pCur, int *pHiwtr, int resetFlg) {
1022: 	fprintf(stderr, "sqlite3_status64: unsupported.\n");
1023: 	return -1;
1024: }
1025: 
1026: int sqlite3_stmt_status(sqlite3_stmt *, int op, int resetFlg) {
1027: 	fprintf(stderr, "sqlite3_stmt_status: unsupported.\n");
1028: 	return -1;
1029: }
1030: 
1031: int sqlite3_file_control(sqlite3 *, const char *zDbName, int op, void *) {
1032: 	fprintf(stderr, "sqlite3_file_control: unsupported.\n");
1033: 	return -1;
1034: }
1035: 
1036: int sqlite3_declare_vtab(sqlite3 *, const char *zSQL) {
1037: 	fprintf(stderr, "sqlite3_declare_vtab: unsupported.\n");
1038: 	return -1;
1039: }
1040: 
1041: const char *sqlite3_vtab_collation(sqlite3_index_info *, int) {
1042: 	fprintf(stderr, "sqlite3_vtab_collation: unsupported.\n");
1043: 	return nullptr;
1044: }
1045: 
1046: int sqlite3_sleep(int) {
1047: 	fprintf(stderr, "sqlite3_sleep: unsupported.\n");
1048: 	return -1;
1049: }
1050: 
1051: int sqlite3_busy_timeout(sqlite3 *, int ms) {
1052: 	fprintf(stderr, "sqlite3_busy_timeout: unsupported.\n");
1053: 	return -1;
1054: }
1055: 
1056: // unlikely to be supported
1057: 
1058: int sqlite3_trace_v2(sqlite3 *, unsigned uMask, int (*xCallback)(unsigned, void *, void *, void *), void *pCtx) {
1059: 	fprintf(stderr, "sqlite3_trace_v2: unsupported.\n");
1060: 	return -1;
1061: }
1062: 
1063: int sqlite3_test_control(int op, ...) {
1064: 	fprintf(stderr, "sqlite3_test_control: unsupported.\n");
1065: 	return -1;
1066: }
1067: 
1068: int sqlite3_enable_load_extension(sqlite3 *db, int onoff) {
1069: 	// fprintf(stderr, "sqlite3_enable_load_extension: unsupported.\n");
1070: 	return -1;
1071: }
1072: 
1073: int sqlite3_load_extension(sqlite3 *db,       /* Load the extension into this database connection */
1074:                            const char *zFile, /* Name of the shared library containing extension */
1075:                            const char *zProc, /* Entry point.  Derived from zFile if 0 */
1076:                            char **pzErrMsg    /* Put error message here if not 0 */
1077: ) {
1078: 	// fprintf(stderr, "sqlite3_load_extension: unsupported.\n");
1079: 	return -1;
1080: }
1081: 
1082: int sqlite3_create_module(sqlite3 *db,             /* SQLite connection to register module with */
1083:                           const char *zName,       /* Name of the module */
1084:                           const sqlite3_module *p, /* Methods for the module */
1085:                           void *pClientData        /* Client data for xCreate/xConnect */
1086: ) {
1087: 	// fprintf(stderr, "sqlite3_create_module: unsupported.\n");
1088: 	return -1;
1089: }
1090: 
1091: int sqlite3_create_function(sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep, void *pApp,
1092:                             void (*xFunc)(sqlite3_context *, int, sqlite3_value **),
1093:                             void (*xStep)(sqlite3_context *, int, sqlite3_value **),
1094:                             void (*xFinal)(sqlite3_context *)) {
1095: 	// fprintf(stderr, "sqlite3_create_function: unsupported.\n");
1096: 	return -1;
1097: }
1098: 
1099: int sqlite3_set_authorizer(sqlite3 *, int (*xAuth)(void *, int, const char *, const char *, const char *, const char *),
1100:                            void *pUserData) {
1101: 	fprintf(stderr, "sqlite3_set_authorizer: unsupported.\n");
1102: 	return -1;
1103: }
1104: 
1105: // needed in shell timer
1106: static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow) {
1107: 	using namespace std::chrono;
1108: 	*piNow = (sqlite3_int64)duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
1109: 	return SQLITE_OK;
1110: }
1111: 
1112: // virtual file system, providing some dummies to avoid crashes
1113: sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName) {
1114: 	// return a dummy because the shell does not check the return code.
1115: 	// fprintf(stderr, "sqlite3_vfs_find: unsupported.\n");
1116: 	sqlite3_vfs *res = (sqlite3_vfs *)sqlite3_malloc(sizeof(sqlite3_vfs));
1117: 	res->xCurrentTimeInt64 = unixCurrentTimeInt64;
1118: 	res->iVersion = 2;
1119: 	res->zName = "dummy";
1120: 	res->pNext = nullptr;
1121: 	assert(res);
1122: 	return res;
1123: }
1124: int sqlite3_vfs_register(sqlite3_vfs *, int makeDflt) {
1125: 	// fprintf(stderr, "sqlite3_vfs_register: unsupported.\n");
1126: 	return -1;
1127: }
1128: 
1129: // backups, unused
1130: 
1131: int sqlite3_backup_step(sqlite3_backup *p, int nPage) {
1132: 	fprintf(stderr, "sqlite3_backup_step: unsupported.\n");
1133: 	return -1;
1134: }
1135: int sqlite3_backup_finish(sqlite3_backup *p) {
1136: 	fprintf(stderr, "sqlite3_backup_finish: unsupported.\n");
1137: 	return -1;
1138: }
1139: 
1140: sqlite3_backup *sqlite3_backup_init(sqlite3 *pDest,         /* Destination database handle */
1141:                                     const char *zDestName,  /* Destination database name */
1142:                                     sqlite3 *pSource,       /* Source database handle */
1143:                                     const char *zSourceName /* Source database name */
1144: ) {
1145: 	fprintf(stderr, "sqlite3_backup_init: unsupported.\n");
1146: 	return nullptr;
1147: }
1148: 
1149: // UDF support stuff, unused for now. These cannot be called as create_function above is disabled
1150: 
1151: SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context *) {
1152: 	return nullptr;
1153: }
1154: 
1155: void *sqlite3_user_data(sqlite3_context *) {
1156: 	return nullptr;
1157: }
1158: 
1159: #ifdef _WIN32
1160: #include <windows.h>
1161: 
1162: static void *sqlite3MallocZero(size_t n) {
1163: 	auto res = sqlite3_malloc(n);
1164: 	assert(res);
1165: 	memset(res, 0, n);
1166: 	return res;
1167: }
1168: 
1169: static LPWSTR winUtf8ToUnicode(const char *zText) {
1170: 	int nChar;
1171: 	LPWSTR zWideText;
1172: 
1173: 	nChar = MultiByteToWideChar(CP_UTF8, 0, zText, -1, NULL, 0);
1174: 	if (nChar == 0) {
1175: 		return 0;
1176: 	}
1177: 	zWideText = (LPWSTR)sqlite3MallocZero(nChar * sizeof(WCHAR));
1178: 	if (zWideText == 0) {
1179: 		return 0;
1180: 	}
1181: 	nChar = MultiByteToWideChar(CP_UTF8, 0, zText, -1, zWideText, nChar);
1182: 	if (nChar == 0) {
1183: 		sqlite3_free(zWideText);
1184: 		zWideText = 0;
1185: 	}
1186: 	return zWideText;
1187: }
1188: 
1189: static char *winUnicodeToMbcs(LPCWSTR zWideText, int useAnsi) {
1190: 	int nByte;
1191: 	char *zText;
1192: 	int codepage = useAnsi ? CP_ACP : CP_OEMCP;
1193: 
1194: 	nByte = WideCharToMultiByte(codepage, 0, zWideText, -1, 0, 0, 0, 0);
1195: 	if (nByte == 0) {
1196: 		return 0;
1197: 	}
1198: 	zText = (char *)sqlite3MallocZero(nByte);
1199: 	if (zText == 0) {
1200: 		return 0;
1201: 	}
1202: 	nByte = WideCharToMultiByte(codepage, 0, zWideText, -1, zText, nByte, 0, 0);
1203: 	if (nByte == 0) {
1204: 		sqlite3_free(zText);
1205: 		zText = 0;
1206: 	}
1207: 	return zText;
1208: }
1209: 
1210: static char *winUtf8ToMbcs(const char *zText, int useAnsi) {
1211: 	char *zTextMbcs;
1212: 	LPWSTR zTmpWide;
1213: 
1214: 	zTmpWide = winUtf8ToUnicode(zText);
1215: 	if (zTmpWide == 0) {
1216: 		return 0;
1217: 	}
1218: 	zTextMbcs = winUnicodeToMbcs(zTmpWide, useAnsi);
1219: 	sqlite3_free(zTmpWide);
1220: 	return zTextMbcs;
1221: }
1222: 
1223: SQLITE_API char *sqlite3_win32_utf8_to_mbcs_v2(const char *zText, int useAnsi) {
1224: 	return winUtf8ToMbcs(zText, useAnsi);
1225: }
1226: 
1227: LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText) {
1228: 	return winUtf8ToUnicode(zText);
1229: }
1230: 
1231: static LPWSTR winMbcsToUnicode(const char *zText, int useAnsi) {
1232: 	int nByte;
1233: 	LPWSTR zMbcsText;
1234: 	int codepage = useAnsi ? CP_ACP : CP_OEMCP;
1235: 
1236: 	nByte = MultiByteToWideChar(codepage, 0, zText, -1, NULL, 0) * sizeof(WCHAR);
1237: 	if (nByte == 0) {
1238: 		return 0;
1239: 	}
1240: 	zMbcsText = (LPWSTR)sqlite3MallocZero(nByte * sizeof(WCHAR));
1241: 	if (zMbcsText == 0) {
1242: 		return 0;
1243: 	}
1244: 	nByte = MultiByteToWideChar(codepage, 0, zText, -1, zMbcsText, nByte);
1245: 	if (nByte == 0) {
1246: 		sqlite3_free(zMbcsText);
1247: 		zMbcsText = 0;
1248: 	}
1249: 	return zMbcsText;
1250: }
1251: 
1252: static char *winUnicodeToUtf8(LPCWSTR zWideText) {
1253: 	int nByte;
1254: 	char *zText;
1255: 
1256: 	nByte = WideCharToMultiByte(CP_UTF8, 0, zWideText, -1, 0, 0, 0, 0);
1257: 	if (nByte == 0) {
1258: 		return 0;
1259: 	}
1260: 	zText = (char *)sqlite3MallocZero(nByte);
1261: 	if (zText == 0) {
1262: 		return 0;
1263: 	}
1264: 	nByte = WideCharToMultiByte(CP_UTF8, 0, zWideText, -1, zText, nByte, 0, 0);
1265: 	if (nByte == 0) {
1266: 		sqlite3_free(zText);
1267: 		zText = 0;
1268: 	}
1269: 	return zText;
1270: }
1271: 
1272: static char *winMbcsToUtf8(const char *zText, int useAnsi) {
1273: 	char *zTextUtf8;
1274: 	LPWSTR zTmpWide;
1275: 
1276: 	zTmpWide = winMbcsToUnicode(zText, useAnsi);
1277: 	if (zTmpWide == 0) {
1278: 		return 0;
1279: 	}
1280: 	zTextUtf8 = winUnicodeToUtf8(zTmpWide);
1281: 	sqlite3_free(zTmpWide);
1282: 	return zTextUtf8;
1283: }
1284: 
1285: SQLITE_API char *sqlite3_win32_mbcs_to_utf8_v2(const char *zText, int useAnsi) {
1286: 	return winMbcsToUtf8(zText, useAnsi);
1287: }
1288: 
1289: SQLITE_API char *sqlite3_win32_unicode_to_utf8(LPCWSTR zWideText) {
1290: 	return winUnicodeToUtf8(zWideText);
1291: }
1292: 
1293: #endif
1294: 
1295: // TODO complain
1296: SQLITE_API void sqlite3_result_blob(sqlite3_context *, const void *, int, void (*)(void *)) {
1297: }
1298: SQLITE_API void sqlite3_result_blob64(sqlite3_context *, const void *, sqlite3_uint64, void (*)(void *)) {
1299: }
1300: SQLITE_API void sqlite3_result_double(sqlite3_context *, double) {
1301: }
1302: SQLITE_API void sqlite3_result_error(sqlite3_context *, const char *, int) {
1303: }
1304: SQLITE_API void sqlite3_result_error16(sqlite3_context *, const void *, int) {
1305: }
1306: SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *) {
1307: }
1308: SQLITE_API void sqlite3_result_error_nomem(sqlite3_context *) {
1309: }
1310: SQLITE_API void sqlite3_result_error_code(sqlite3_context *, int) {
1311: }
1312: SQLITE_API void sqlite3_result_int(sqlite3_context *, int) {
1313: }
1314: SQLITE_API void sqlite3_result_int64(sqlite3_context *, sqlite3_int64) {
1315: }
1316: SQLITE_API void sqlite3_result_null(sqlite3_context *) {
1317: }
1318: SQLITE_API void sqlite3_result_text(sqlite3_context *, const char *, int, void (*)(void *)) {
1319: }
1320: SQLITE_API void sqlite3_result_text64(sqlite3_context *, const char *, sqlite3_uint64, void (*)(void *),
1321:                                       unsigned char encoding) {
1322: }
1323: SQLITE_API void sqlite3_result_text16(sqlite3_context *, const void *, int, void (*)(void *)) {
1324: }
1325: SQLITE_API void sqlite3_result_text16le(sqlite3_context *, const void *, int, void (*)(void *)) {
1326: }
1327: SQLITE_API void sqlite3_result_text16be(sqlite3_context *, const void *, int, void (*)(void *)) {
1328: }
1329: SQLITE_API void sqlite3_result_value(sqlite3_context *, sqlite3_value *) {
1330: }
1331: SQLITE_API void sqlite3_result_pointer(sqlite3_context *, void *, const char *, void (*)(void *)) {
1332: }
1333: SQLITE_API void sqlite3_result_zeroblob(sqlite3_context *, int n) {
1334: }
1335: SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context *, sqlite3_uint64 n) {
1336: 	return -1;
1337: }
1338: 
1339: // TODO complain
1340: const void *sqlite3_value_blob(sqlite3_value *) {
1341: 	return nullptr;
1342: }
1343: double sqlite3_value_double(sqlite3_value *) {
1344: 	return 0;
1345: }
1346: int sqlite3_value_int(sqlite3_value *) {
1347: 	return 0;
1348: }
1349: sqlite3_int64 sqlite3_value_int64(sqlite3_value *) {
1350: 	return 0;
1351: }
1352: void *sqlite3_value_pointer(sqlite3_value *, const char *) {
1353: 	return nullptr;
1354: }
1355: const unsigned char *sqlite3_value_text(sqlite3_value *) {
1356: 	return nullptr;
1357: }
1358: SQLITE_API const void *sqlite3_value_text16(sqlite3_value *) {
1359: 	return nullptr;
1360: }
1361: SQLITE_API const void *sqlite3_value_text16le(sqlite3_value *) {
1362: 	return nullptr;
1363: }
1364: SQLITE_API const void *sqlite3_value_text16be(sqlite3_value *) {
1365: 	return nullptr;
1366: }
1367: SQLITE_API int sqlite3_value_bytes(sqlite3_value *) {
1368: 	return 0;
1369: }
1370: SQLITE_API int sqlite3_value_bytes16(sqlite3_value *) {
1371: 	return 0;
1372: }
1373: SQLITE_API int sqlite3_value_type(sqlite3_value *) {
1374: 	return 0;
1375: }
1376: SQLITE_API int sqlite3_value_numeric_type(sqlite3_value *) {
1377: 	return 0;
1378: }
1379: SQLITE_API int sqlite3_value_nochange(sqlite3_value *) {
1380: 	return 0;
1381: }
1382: 
1383: SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *, int nBytes) {
1384: 	fprintf(stderr, "sqlite3_aggregate_context: unsupported.\n");
1385: 
1386: 	return nullptr;
1387: }
1388: 
1389: SQLITE_API int sqlite3_create_collation(sqlite3 *, const char *zName, int eTextRep, void *pArg,
1390:                                         int (*xCompare)(void *, int, const void *, int, const void *)) {
1391: 	return SQLITE_ERROR;
1392: }
1393: 
1394: SQLITE_API int sqlite3_create_window_function(sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep,
1395:                                               void *pApp, void (*xStep)(sqlite3_context *, int, sqlite3_value **),
1396:                                               void (*xFinal)(sqlite3_context *), void (*xValue)(sqlite3_context *),
1397:                                               void (*xInverse)(sqlite3_context *, int, sqlite3_value **),
1398:                                               void (*xDestroy)(void *)) {
1399: 	fprintf(stderr, "sqlite3_create_window_function: unsupported.\n");
1400: 	return SQLITE_ERROR;
1401: }
1402: 
1403: SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *s) {
1404: 	return s->db;
1405: }
1406: 
1407: SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt) {
1408: 	fprintf(stderr, "sqlite3_expanded_sql: unsupported.\n");
1409: 	return nullptr;
1410: }
1411: 
1412: SQLITE_API int sqlite3_keyword_check(const char *str, int len) {
1413: 	return Parser::IsKeyword(std::string(str, len));
1414: }
1415: 
1416: SQLITE_API int sqlite3_keyword_count(void) {
1417: 	fprintf(stderr, "sqlite3_keyword_count: unsupported.\n");
1418: 	return 0;
1419: }
1420: 
1421: SQLITE_API int sqlite3_keyword_name(int, const char **, int *) {
1422: 	fprintf(stderr, "sqlite3_keyword_name: unsupported.\n");
1423: 	return 0;
1424: }
1425: 
1426: SQLITE_API void sqlite3_progress_handler(sqlite3 *, int, int (*)(void *), void *) {
1427: 	fprintf(stderr, "sqlite3_progress_handler: unsupported.\n");
1428: }
1429: 
1430: SQLITE_API int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt) {
1431: 	if (!pStmt || !pStmt->prepared) {
1432: 		return 0;
1433: 	}
1434: 	return pStmt->prepared->GetStatementType() == StatementType::EXPLAIN_STATEMENT;
1435: }
1436: 
1437: SQLITE_API int sqlite3_vtab_config(sqlite3 *, int op, ...) {
1438: 	fprintf(stderr, "sqlite3_vtab_config: unsupported.\n");
1439: 	return SQLITE_ERROR;
1440: }
[end of tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: