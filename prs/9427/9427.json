{
  "repo": "duckdb/duckdb",
  "pull_number": 9427,
  "instance_id": "duckdb__duckdb-9427",
  "issue_numbers": [
    "9134"
  ],
  "base_commit": "7a091e59d21b815f83ccb0307a782db7d9390629",
  "patch": "diff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 96a2438179ad..568e519988d7 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -48,6 +48,7 @@\n #include \"duckdb/parser/parsed_data/drop_info.hpp\"\n #include \"duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp\"\n #include \"duckdb/main/pending_query_result.hpp\"\n+#include \"duckdb/parser/keyword_helper.hpp\"\n \n #include <random>\n \n@@ -969,7 +970,13 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::Table(const string &tname) {\n \tif (qualified_name.schema.empty()) {\n \t\tqualified_name.schema = DEFAULT_SCHEMA;\n \t}\n-\treturn make_uniq<DuckDBPyRelation>(connection->Table(qualified_name.schema, qualified_name.name));\n+\ttry {\n+\t\treturn make_uniq<DuckDBPyRelation>(connection->Table(qualified_name.schema, qualified_name.name));\n+\t} catch (const CatalogException &e) {\n+\t\t// CatalogException will be of the type '... is not a table'\n+\t\t// Not a table in the database, make a query relation that can perform replacement scans\n+\t\treturn RunQuery(StringUtil::Format(\"from %s\", KeywordHelper::WriteOptionallyQuoted(tname)), tname);\n+\t}\n }\n \n unique_ptr<DuckDBPyRelation> DuckDBPyConnection::Values(py::object params) {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py b/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py\nindex 5ad632d74bf3..f02865b89ae1 100644\n--- a/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py\n+++ b/tools/pythonpkg/tests/fast/relational_api/test_rapi_query.py\n@@ -35,7 +35,7 @@ def test_query_table(self, tbl_table, input):\n         result = rel.execute()\n         assert result.fetchall() == [tuple([x]) for x in input]\n \n-    def test_query_table_unrelated(self, tbl_table):\n+    def test_query_table_basic(self, tbl_table):\n         con = duckdb.default_connection\n         rel = con.table(\"tbl\")\n         # Querying a table relation\ndiff --git a/tools/pythonpkg/tests/fast/test_replacement_scan.py b/tools/pythonpkg/tests/fast/test_replacement_scan.py\nindex 2aa52807624b..2ebb7f7b52b6 100644\n--- a/tools/pythonpkg/tests/fast/test_replacement_scan.py\n+++ b/tools/pythonpkg/tests/fast/test_replacement_scan.py\n@@ -2,6 +2,48 @@\n import os\n import pytest\n \n+pl = pytest.importorskip(\"polars\")\n+\n+\n+def using_table(con, to_scan, object_name):\n+    exec(f\"{object_name} = to_scan\")\n+    return con.table(object_name)\n+\n+\n+def using_sql(con, to_scan, object_name):\n+    exec(f\"{object_name} = to_scan\")\n+    return con.sql(f\"select * from to_scan\")\n+\n+\n+# Fetch methods\n+\n+\n+def fetch_polars(rel):\n+    return rel.pl()\n+\n+\n+def fetch_df(rel):\n+    return rel.df()\n+\n+\n+def fetch_arrow(rel):\n+    return rel.arrow()\n+\n+\n+def fetch_arrow_table(rel):\n+    return rel.fetch_arrow_table()\n+\n+\n+def fetch_arrow_record_batch(rel):\n+    # Note: this has to executed first, otherwise we'll create a deadlock\n+    # Because it will try to execute the input at the same time as executing the relation\n+    # On the same connection (that's the core of the issue)\n+    return rel.execute().record_batch()\n+\n+\n+def fetch_relation(rel):\n+    return rel\n+\n \n class TestReplacementScan(object):\n     def test_csv_replacement(self):\n@@ -16,6 +58,21 @@ def test_parquet_replacement(self):\n         res = con.execute(\"select count(*) from '%s'\" % (filename))\n         assert res.fetchone()[0] == 3\n \n+    @pytest.mark.parametrize('get_relation', [using_table, using_sql])\n+    @pytest.mark.parametrize(\n+        'fetch_method',\n+        [fetch_polars, fetch_df, fetch_arrow, fetch_arrow_table, fetch_arrow_record_batch, fetch_relation],\n+    )\n+    @pytest.mark.parametrize('object_name', ['tbl', 'table', 'select', 'update'])\n+    def test_table_replacement_scans(self, duckdb_cursor, get_relation, fetch_method, object_name):\n+        base_rel = duckdb_cursor.values([1, 2, 3])\n+        to_scan = fetch_method(base_rel)\n+        exec(f\"{object_name} = to_scan\")\n+\n+        rel = get_relation(duckdb_cursor, to_scan, object_name)\n+        res = rel.fetchall()\n+        assert res == [(1, 2, 3)]\n+\n     def test_replacement_scan_relapi(self):\n         con = duckdb.connect()\n         pyrel1 = con.query('from (values (42), (84), (120)) t(i)')\n",
  "problem_statement": "[Python] replacement scans do not work inside the `table` method\n### What happens?\n\nWhen calling `duck.table` and providing it with a table identifier of a variable in scope that should be queryable via a replacement scan (eg a Pandas or Polars dataframe), the DuckDB Python client instead responds with:\r\n\r\n    CatalogException: Catalog Error: Table 'df' does not exist!\r\n\r\nI discovered this by trying to adopt a common R pattern with `dplyr`/`dbplyr`, where you start your query with a relation formed from a table, and then build on top of it. The Python Relational API equivalent is:\r\n\r\n    duckdb.table(\"my_table\").more().methods()\r\n\r\nWhich is much cleaner that what you currently need to do when your table identifier is a dataframe:\r\n\r\n    duckdb.sql(\"FROM my_table\").more().methods()\n\n### To Reproduce\n\n```\r\ndf = duckdb.values([1,2,3]).df()\r\n\r\nduckdb.table(\"df\")\r\n```\n\n### OS:\n\nUbuntu 23.04\n\n### DuckDB Version:\n\n0.9.0\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nNed Letcher\n\n### Affiliation:\n\nThoughtworks\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a release build (and could not test with a main build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2023-10-22T10:01:55Z"
}