{
  "repo": "duckdb/duckdb",
  "pull_number": 3866,
  "instance_id": "duckdb__duckdb-3866",
  "issue_numbers": [
    "3822",
    "3822"
  ],
  "base_commit": "4d39f040c115177d7d00b5dd26b3306193f90149",
  "patch": "diff --git a/extension/json/json_functions/json_create.cpp b/extension/json/json_functions/json_create.cpp\nindex e951f631dfe7..8cb4bd55cffd 100644\n--- a/extension/json/json_functions/json_create.cpp\n+++ b/extension/json/json_functions/json_create.cpp\n@@ -435,6 +435,7 @@ CreateScalarFunctionInfo JSONFunctions::GetObjectFunction() {\n \tauto fun =\n \t    ScalarFunction(\"json_object\", {}, LogicalType::JSON, ObjectFunction, false, JSONObjectBind, nullptr, nullptr);\n \tfun.varargs = LogicalType::ANY;\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \treturn CreateScalarFunctionInfo(fun);\n }\n \n@@ -442,6 +443,7 @@ CreateScalarFunctionInfo JSONFunctions::GetArrayFunction() {\n \tauto fun =\n \t    ScalarFunction(\"json_array\", {}, LogicalType::JSON, ArrayFunction, false, JSONArrayBind, nullptr, nullptr);\n \tfun.varargs = LogicalType::ANY;\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \treturn CreateScalarFunctionInfo(fun);\n }\n \ndiff --git a/src/function/function.cpp b/src/function/function.cpp\nindex ecb8832203b7..f5da636cb5a6 100644\n--- a/src/function/function.cpp\n+++ b/src/function/function.cpp\n@@ -2,9 +2,9 @@\n \n #include \"duckdb/catalog/catalog.hpp\"\n #include \"duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp\"\n-#include \"duckdb/common/types/hash.hpp\"\n #include \"duckdb/common/limits.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/common/types/hash.hpp\"\n #include \"duckdb/function/aggregate_function.hpp\"\n #include \"duckdb/function/cast_rules.hpp\"\n #include \"duckdb/function/scalar/string_functions.hpp\"\n@@ -464,21 +464,19 @@ void BaseScalarFunction::CastToFunctionArguments(vector<unique_ptr<Expression>>\n \t}\n }\n \n-unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientContext &context, const string &schema,\n-                                                                       const string &name,\n-                                                                       vector<unique_ptr<Expression>> children,\n-                                                                       string &error, bool is_operator) {\n+unique_ptr<Expression> ScalarFunction::BindScalarFunction(ClientContext &context, const string &schema,\n+                                                          const string &name, vector<unique_ptr<Expression>> children,\n+                                                          string &error, bool is_operator, Binder *binder) {\n \t// bind the function\n \tauto function = Catalog::GetCatalog(context).GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, schema, name);\n \tD_ASSERT(function && function->type == CatalogType::SCALAR_FUNCTION_ENTRY);\n \treturn ScalarFunction::BindScalarFunction(context, (ScalarFunctionCatalogEntry &)*function, move(children), error,\n-\t                                          is_operator);\n+\t                                          is_operator, binder);\n }\n \n-unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientContext &context,\n-                                                                       ScalarFunctionCatalogEntry &func,\n-                                                                       vector<unique_ptr<Expression>> children,\n-                                                                       string &error, bool is_operator) {\n+unique_ptr<Expression> ScalarFunction::BindScalarFunction(ClientContext &context, ScalarFunctionCatalogEntry &func,\n+                                                          vector<unique_ptr<Expression>> children, string &error,\n+                                                          bool is_operator, Binder *binder) {\n \t// bind the function\n \tbool cast_parameters;\n \tidx_t best_function = Function::BindFunction(func.name, func.functions, children, error, cast_parameters);\n@@ -488,6 +486,18 @@ unique_ptr<BoundFunctionExpression> ScalarFunction::BindScalarFunction(ClientCon\n \n \t// found a matching function!\n \tauto &bound_function = func.functions[best_function];\n+\n+\tif (bound_function.null_handling == FunctionNullHandling::NULL_IN_NULL_OUT) {\n+\t\tfor (auto &child : children) {\n+\t\t\tif (child->return_type == LogicalTypeId::SQLNULL) {\n+\t\t\t\tif (binder) {\n+\t\t\t\t\tbinder->RemoveParameters(children);\n+\t\t\t\t}\n+\t\t\t\treturn make_unique<BoundConstantExpression>(Value(LogicalType::SQLNULL));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \treturn ScalarFunction::BindScalarFunction(context, bound_function, move(children), is_operator, cast_parameters);\n }\n \ndiff --git a/src/function/scalar/date/strftime.cpp b/src/function/scalar/date/strftime.cpp\nindex dde17103c042..b66d63834018 100644\n--- a/src/function/scalar/date/strftime.cpp\n+++ b/src/function/scalar/date/strftime.cpp\n@@ -1,20 +1,15 @@\n-#include \"duckdb/function/scalar/date_functions.hpp\"\n-\n-#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/function/scalar/strftime.hpp\"\n \n+#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/common/to_string.hpp\"\n+#include \"duckdb/common/types/cast_helpers.hpp\"\n #include \"duckdb/common/types/date.hpp\"\n #include \"duckdb/common/types/time.hpp\"\n #include \"duckdb/common/types/timestamp.hpp\"\n-#include \"duckdb/common/types/cast_helpers.hpp\"\n-\n-#include \"duckdb/common/string_util.hpp\"\n-#include \"duckdb/common/to_string.hpp\"\n-\n-#include \"duckdb/function/scalar/strftime.hpp\"\n-\n #include \"duckdb/common/vector_operations/unary_executor.hpp\"\n-\n #include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/function/scalar/date_functions.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n \n #include <cctype>\n \n@@ -1310,8 +1305,10 @@ static void StrpTimeFunction(DataChunk &args, ExpressionState &state, Vector &re\n void StrpTimeFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunctionSet strptime(\"strptime\");\n \n-\tstrptime.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::TIMESTAMP,\n-\t                                    StrpTimeFunction, false, false, StrpTimeBindFunction));\n+\tauto fun = ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::TIMESTAMP, StrpTimeFunction,\n+\t                          false, false, StrpTimeBindFunction);\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\tstrptime.AddFunction(fun);\n \n \tset.AddFunction(strptime);\n }\ndiff --git a/src/function/scalar/enum/enum_functions_implementation.cpp b/src/function/scalar/enum/enum_functions_implementation.cpp\nindex 35d7d19c7337..a23e5defdcab 100644\n--- a/src/function/scalar/enum/enum_functions_implementation.cpp\n+++ b/src/function/scalar/enum/enum_functions_implementation.cpp\n@@ -105,9 +105,11 @@ void EnumRange::RegisterFunction(BuiltinFunctions &set) {\n }\n \n void EnumRangeBoundary::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction(ScalarFunction(\"enum_range_boundary\", {LogicalType::ANY, LogicalType::ANY},\n-\t                               LogicalType::LIST(LogicalType::VARCHAR), EnumRangeBoundaryFunction, false,\n-\t                               BindEnumRangeBoundaryFunction));\n+\tauto fun = ScalarFunction(\"enum_range_boundary\", {LogicalType::ANY, LogicalType::ANY},\n+\t                          LogicalType::LIST(LogicalType::VARCHAR), EnumRangeBoundaryFunction, false,\n+\t                          BindEnumRangeBoundaryFunction);\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\tset.AddFunction(fun);\n }\n \n } // namespace duckdb\ndiff --git a/src/function/scalar/generic/current_setting.cpp b/src/function/scalar/generic/current_setting.cpp\nindex 112e56044981..c03a5a4c9d26 100644\n--- a/src/function/scalar/generic/current_setting.cpp\n+++ b/src/function/scalar/generic/current_setting.cpp\n@@ -57,8 +57,10 @@ unique_ptr<FunctionData> CurrentSettingBind(ClientContext &context, ScalarFuncti\n }\n \n void CurrentSettingFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction(ScalarFunction(\"current_setting\", {LogicalType::VARCHAR}, LogicalType::ANY, CurrentSettingFunction,\n-\t                               false, CurrentSettingBind));\n+\tauto fun = ScalarFunction(\"current_setting\", {LogicalType::VARCHAR}, LogicalType::ANY, CurrentSettingFunction,\n+\t                          false, CurrentSettingBind);\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\tset.AddFunction(fun);\n }\n \n } // namespace duckdb\ndiff --git a/src/function/scalar/generic/least.cpp b/src/function/scalar/generic/least.cpp\nindex 14c22c8eba0b..18a2e95158ba 100644\n--- a/src/function/scalar/generic/least.cpp\n+++ b/src/function/scalar/generic/least.cpp\n@@ -1,5 +1,5 @@\n-#include \"duckdb/function/scalar/generic_functions.hpp\"\n #include \"duckdb/common/operator/comparison_operators.hpp\"\n+#include \"duckdb/function/scalar/generic_functions.hpp\"\n \n namespace duckdb {\n \n@@ -97,22 +97,24 @@ static void LeastGreatestFunction(DataChunk &args, ExpressionState &state, Vecto\n template <typename T, class OP>\n ScalarFunction GetLeastGreatestFunction(const LogicalType &type) {\n \treturn ScalarFunction({type}, type, LeastGreatestFunction<T, OP>, true, false, nullptr, nullptr, nullptr, nullptr,\n-\t                      type);\n+\t                      type, FunctionNullHandling::SPECIAL_HANDLING);\n }\n \n template <class OP>\n static void RegisterLeastGreatest(BuiltinFunctions &set, const string &fun_name) {\n \tScalarFunctionSet fun_set(fun_name);\n \tfun_set.AddFunction(ScalarFunction({LogicalType::BIGINT}, LogicalType::BIGINT, LeastGreatestFunction<int64_t, OP>,\n-\t                                   true, false, nullptr, nullptr, nullptr, nullptr, LogicalType::BIGINT));\n+\t                                   true, false, nullptr, nullptr, nullptr, nullptr, LogicalType::BIGINT,\n+\t                                   FunctionNullHandling::SPECIAL_HANDLING));\n \tfun_set.AddFunction(ScalarFunction({LogicalType::HUGEINT}, LogicalType::HUGEINT,\n \t                                   LeastGreatestFunction<hugeint_t, OP>, true, false, nullptr, nullptr, nullptr,\n-\t                                   nullptr, LogicalType::HUGEINT));\n+\t                                   nullptr, LogicalType::HUGEINT, FunctionNullHandling::SPECIAL_HANDLING));\n \tfun_set.AddFunction(ScalarFunction({LogicalType::DOUBLE}, LogicalType::DOUBLE, LeastGreatestFunction<double, OP>,\n-\t                                   true, false, nullptr, nullptr, nullptr, nullptr, LogicalType::DOUBLE));\n+\t                                   true, false, nullptr, nullptr, nullptr, nullptr, LogicalType::DOUBLE,\n+\t                                   FunctionNullHandling::SPECIAL_HANDLING));\n \tfun_set.AddFunction(ScalarFunction({LogicalType::VARCHAR}, LogicalType::VARCHAR,\n \t                                   LeastGreatestFunction<string_t, OP, true>, true, false, nullptr, nullptr,\n-\t                                   nullptr, nullptr, LogicalType::VARCHAR));\n+\t                                   nullptr, nullptr, LogicalType::VARCHAR, FunctionNullHandling::SPECIAL_HANDLING));\n \n \tfun_set.AddFunction(GetLeastGreatestFunction<timestamp_t, OP>(LogicalType::TIMESTAMP));\n \tfun_set.AddFunction(GetLeastGreatestFunction<time_t, OP>(LogicalType::TIME));\ndiff --git a/src/function/scalar/list/array_slice.cpp b/src/function/scalar/list/array_slice.cpp\nindex 4c3440216075..644f02dcb342 100644\n--- a/src/function/scalar/list/array_slice.cpp\n+++ b/src/function/scalar/list/array_slice.cpp\n@@ -1,11 +1,11 @@\n-#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/common/pair.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n-#include \"duckdb/parser/expression/bound_expression.hpp\"\n-#include \"duckdb/function/scalar/nested_functions.hpp\"\n #include \"duckdb/common/types/chunk_collection.hpp\"\n #include \"duckdb/common/types/data_chunk.hpp\"\n-#include \"duckdb/common/pair.hpp\"\n+#include \"duckdb/function/scalar/nested_functions.hpp\"\n #include \"duckdb/function/scalar/string_functions.hpp\"\n+#include \"duckdb/parser/expression/bound_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n \n namespace duckdb {\n \n@@ -184,6 +184,7 @@ static unique_ptr<FunctionData> ArraySliceBind(ClientContext &context, ScalarFun\n \t\tbound_function.arguments[1] = LogicalType::INTEGER;\n \t\tbound_function.arguments[2] = LogicalType::INTEGER;\n \t\tbreak;\n+\tcase LogicalTypeId::SQLNULL:\n \tcase LogicalTypeId::UNKNOWN:\n \t\tbound_function.arguments[0] = LogicalTypeId::UNKNOWN;\n \t\tbound_function.return_type = LogicalType::SQLNULL;\n@@ -200,6 +201,7 @@ void ArraySliceFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunction fun({LogicalType::ANY, LogicalType::BIGINT, LogicalType::BIGINT}, LogicalType::ANY,\n \t                   ArraySliceFunction, false, false, ArraySliceBind);\n \tfun.varargs = LogicalType::ANY;\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tset.AddFunction({\"array_slice\", \"list_slice\"}, fun);\n }\n \ndiff --git a/src/function/scalar/list/contains_or_position.cpp b/src/function/scalar/list/contains_or_position.cpp\nindex 86174d56f5a0..0d0aa2d1153a 100644\n--- a/src/function/scalar/list/contains_or_position.cpp\n+++ b/src/function/scalar/list/contains_or_position.cpp\n@@ -1,5 +1,5 @@\n-#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n #include \"duckdb/function/scalar/nested_functions.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n \n namespace duckdb {\n@@ -169,17 +169,7 @@ static unique_ptr<FunctionData> ListContainsOrPositionBind(ClientContext &contex\n \n \tconst auto &list = arguments[0]->return_type; // change to list\n \tconst auto &value = arguments[1]->return_type;\n-\tif (list.id() == LogicalTypeId::SQLNULL && value.id() == LogicalTypeId::SQLNULL) {\n-\t\tbound_function.arguments[0] = LogicalType::SQLNULL;\n-\t\tbound_function.arguments[1] = LogicalType::SQLNULL;\n-\t\tbound_function.return_type = LogicalType::SQLNULL;\n-\t} else if (list.id() == LogicalTypeId::SQLNULL || value.id() == LogicalTypeId::SQLNULL) {\n-\t\t// In case either the list or the value is NULL, return NULL\n-\t\t// Similar to behaviour of prestoDB\n-\t\tbound_function.arguments[0] = list;\n-\t\tbound_function.arguments[1] = value;\n-\t\tbound_function.return_type = LogicalTypeId::SQLNULL;\n-\t} else if (list.id() == LogicalTypeId::UNKNOWN) {\n+\tif (list.id() == LogicalTypeId::UNKNOWN) {\n \t\tbound_function.return_type = RETURN_TYPE;\n \t\tif (value.id() != LogicalTypeId::UNKNOWN) {\n \t\t\t// only list is a parameter, cast it to a list of value type\ndiff --git a/src/function/scalar/list/flatten.cpp b/src/function/scalar/list/flatten.cpp\nindex 1d143f595a9e..0f4f7a25c1b3 100644\n--- a/src/function/scalar/list/flatten.cpp\n+++ b/src/function/scalar/list/flatten.cpp\n@@ -93,10 +93,6 @@ static unique_ptr<FunctionData> ListFlattenBind(ClientContext &context, ScalarFu\n \n \tauto &input_type = arguments[0]->return_type;\n \tbound_function.arguments[0] = input_type;\n-\tif (input_type.id() == LogicalTypeId::SQLNULL) {\n-\t\tbound_function.return_type = LogicalType(LogicalTypeId::SQLNULL);\n-\t\treturn make_unique<VariableReturnBindData>(bound_function.return_type);\n-\t}\n \tif (input_type.id() == LogicalTypeId::UNKNOWN) {\n \t\tbound_function.arguments[0] = LogicalType(LogicalTypeId::UNKNOWN);\n \t\tbound_function.return_type = LogicalType(LogicalTypeId::SQLNULL);\ndiff --git a/src/function/scalar/list/list_aggregates.cpp b/src/function/scalar/list/list_aggregates.cpp\nindex e2a07afa0fee..07c100639097 100644\n--- a/src/function/scalar/list/list_aggregates.cpp\n+++ b/src/function/scalar/list/list_aggregates.cpp\n@@ -1,11 +1,11 @@\n-#include \"duckdb/planner/expression/bound_aggregate_expression.hpp\"\n-#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n-#include \"duckdb/function/scalar/nested_functions.hpp\"\n-#include \"duckdb/function/aggregate/nested_functions.hpp\"\n-#include \"duckdb/planner/expression_binder.hpp\"\n #include \"duckdb/catalog/catalog.hpp\"\n #include \"duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp\"\n #include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/function/aggregate/nested_functions.hpp\"\n+#include \"duckdb/function/scalar/nested_functions.hpp\"\n+#include \"duckdb/planner/expression/bound_aggregate_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/planner/expression_binder.hpp\"\n \n namespace duckdb {\n \n@@ -362,7 +362,6 @@ static unique_ptr<FunctionData> ListAggregatesBindFunction(ClientContext &contex\n template <bool IS_AGGR = false>\n static unique_ptr<FunctionData> ListAggregatesBind(ClientContext &context, ScalarFunction &bound_function,\n                                                    vector<unique_ptr<Expression>> &arguments) {\n-\n \tif (arguments[0]->return_type.id() == LogicalTypeId::SQLNULL) {\n \t\tbound_function.arguments[0] = LogicalType::SQLNULL;\n \t\tbound_function.return_type = LogicalType::SQLNULL;\n@@ -449,8 +448,10 @@ static unique_ptr<FunctionData> ListUniqueBind(ClientContext &context, ScalarFun\n }\n \n ScalarFunction ListAggregateFun::GetFunction() {\n-\treturn ScalarFunction({LogicalType::LIST(LogicalType::ANY), LogicalType::VARCHAR}, LogicalType::ANY,\n-\t                      ListAggregateFunction, false, false, ListAggregateBind);\n+\tauto result = ScalarFunction({LogicalType::LIST(LogicalType::ANY), LogicalType::VARCHAR}, LogicalType::ANY,\n+\t                             ListAggregateFunction, false, false, ListAggregateBind);\n+\tresult.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\treturn result;\n }\n \n ScalarFunction ListDistinctFun::GetFunction() {\ndiff --git a/src/function/scalar/list/list_concat.cpp b/src/function/scalar/list/list_concat.cpp\nindex 9dd7c1e53739..8c5ae4ce0abe 100644\n--- a/src/function/scalar/list/list_concat.cpp\n+++ b/src/function/scalar/list/list_concat.cpp\n@@ -79,9 +79,7 @@ static unique_ptr<FunctionData> ListConcatBind(ClientContext &context, ScalarFun\n \n \tauto &lhs = arguments[0]->return_type;\n \tauto &rhs = arguments[1]->return_type;\n-\tif (lhs.id() == LogicalTypeId::SQLNULL && rhs.id() == LogicalTypeId::SQLNULL) {\n-\t\tbound_function.return_type = LogicalType::SQLNULL;\n-\t} else if (lhs.id() == LogicalTypeId::SQLNULL || rhs.id() == LogicalTypeId::SQLNULL) {\n+\tif (lhs.id() == LogicalTypeId::SQLNULL || rhs.id() == LogicalTypeId::SQLNULL) {\n \t\t// we mimic postgres behaviour: list_concat(NULL, my_list) = my_list\n \t\tbound_function.arguments[0] = lhs;\n \t\tbound_function.arguments[1] = rhs;\n@@ -122,9 +120,11 @@ static unique_ptr<BaseStatistics> ListConcatStats(ClientContext &context, Functi\n \n ScalarFunction ListConcatFun::GetFunction() {\n \t// the arguments and return types are actually set in the binder function\n-\treturn ScalarFunction({LogicalType::LIST(LogicalType::ANY), LogicalType::LIST(LogicalType::ANY)},\n-\t                      LogicalType::LIST(LogicalType::ANY), ListConcatFunction, false, false, ListConcatBind,\n-\t                      nullptr, ListConcatStats);\n+\tauto fun = ScalarFunction({LogicalType::LIST(LogicalType::ANY), LogicalType::LIST(LogicalType::ANY)},\n+\t                          LogicalType::LIST(LogicalType::ANY), ListConcatFunction, false, false, ListConcatBind,\n+\t                          nullptr, ListConcatStats);\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\treturn fun;\n }\n \n void ListConcatFun::RegisterFunction(BuiltinFunctions &set) {\ndiff --git a/src/function/scalar/list/list_extract.cpp b/src/function/scalar/list/list_extract.cpp\nindex fd548704a817..c0ac501f4db0 100644\n--- a/src/function/scalar/list/list_extract.cpp\n+++ b/src/function/scalar/list/list_extract.cpp\n@@ -1,12 +1,12 @@\n-#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/common/pair.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/common/types/chunk_collection.hpp\"\n+#include \"duckdb/common/types/data_chunk.hpp\"\n #include \"duckdb/common/vector_operations/binary_executor.hpp\"\n-#include \"duckdb/parser/expression/bound_expression.hpp\"\n #include \"duckdb/function/scalar/nested_functions.hpp\"\n #include \"duckdb/function/scalar/string_functions.hpp\"\n-#include \"duckdb/common/types/chunk_collection.hpp\"\n-#include \"duckdb/common/types/data_chunk.hpp\"\n-#include \"duckdb/common/pair.hpp\"\n+#include \"duckdb/parser/expression/bound_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n #include \"duckdb/storage/statistics/list_statistics.hpp\"\n #include \"duckdb/storage/statistics/validity_statistics.hpp\"\n \n@@ -198,14 +198,9 @@ static void ListExtractFunction(DataChunk &args, ExpressionState &state, Vector\n static unique_ptr<FunctionData> ListExtractBind(ClientContext &context, ScalarFunction &bound_function,\n                                                 vector<unique_ptr<Expression>> &arguments) {\n \tD_ASSERT(bound_function.arguments.size() == 2);\n-\tif (arguments[0]->return_type.id() == LogicalTypeId::SQLNULL) {\n-\t\tbound_function.arguments[0] = LogicalType::SQLNULL;\n-\t\tbound_function.return_type = LogicalType::SQLNULL;\n-\t} else {\n-\t\tD_ASSERT(LogicalTypeId::LIST == arguments[0]->return_type.id());\n-\t\t// list extract returns the child type of the list as return type\n-\t\tbound_function.return_type = ListType::GetChildType(arguments[0]->return_type);\n-\t}\n+\tD_ASSERT(LogicalTypeId::LIST == arguments[0]->return_type.id());\n+\t// list extract returns the child type of the list as return type\n+\tbound_function.return_type = ListType::GetChildType(arguments[0]->return_type);\n \treturn make_unique<VariableReturnBindData>(bound_function.return_type);\n }\n \ndiff --git a/src/function/scalar/list/list_sort.cpp b/src/function/scalar/list/list_sort.cpp\nindex 14ff74907e4d..6ac88384a1de 100644\n--- a/src/function/scalar/list/list_sort.cpp\n+++ b/src/function/scalar/list/list_sort.cpp\n@@ -232,13 +232,6 @@ static void ListSortFunction(DataChunk &args, ExpressionState &state, Vector &re\n static unique_ptr<FunctionData> ListSortBind(ClientContext &context, ScalarFunction &bound_function,\n                                              vector<unique_ptr<Expression>> &arguments, OrderType &order,\n                                              OrderByNullType &null_order) {\n-\n-\tif (arguments[0]->return_type.id() == LogicalTypeId::SQLNULL) {\n-\t\tbound_function.arguments[0] = LogicalType::SQLNULL;\n-\t\tbound_function.return_type = LogicalType::SQLNULL;\n-\t\treturn make_unique<VariableReturnBindData>(bound_function.return_type);\n-\t}\n-\n \tbound_function.arguments[0] = arguments[0]->return_type;\n \tbound_function.return_type = arguments[0]->return_type;\n \tauto child_type = ListType::GetChildType(arguments[0]->return_type);\ndiff --git a/src/function/scalar/list/list_value.cpp b/src/function/scalar/list/list_value.cpp\nindex 30ee0a475a17..9528b7a5f0fb 100644\n--- a/src/function/scalar/list/list_value.cpp\n+++ b/src/function/scalar/list/list_value.cpp\n@@ -66,6 +66,7 @@ void ListValueFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunction fun(\"list_value\", {}, LogicalTypeId::LIST, ListValueFunction, false, ListValueBind, nullptr,\n \t                   ListValueStats);\n \tfun.varargs = LogicalType::ANY;\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tset.AddFunction(fun);\n \tfun.name = \"list_pack\";\n \tset.AddFunction(fun);\ndiff --git a/src/function/scalar/map/cardinality.cpp b/src/function/scalar/map/cardinality.cpp\nindex 93367aa45a6b..949fb660bb77 100644\n--- a/src/function/scalar/map/cardinality.cpp\n+++ b/src/function/scalar/map/cardinality.cpp\n@@ -39,6 +39,7 @@ void CardinalityFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunction fun(\"cardinality\", {LogicalType::ANY}, LogicalType::UBIGINT, CardinalityFunction, false,\n \t                   CardinalityBind);\n \tfun.varargs = LogicalType::ANY;\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tset.AddFunction(fun);\n }\n \ndiff --git a/src/function/scalar/map/map.cpp b/src/function/scalar/map/map.cpp\nindex 4fdaad4c7ecb..c8cba33f8282 100644\n--- a/src/function/scalar/map/map.cpp\n+++ b/src/function/scalar/map/map.cpp\n@@ -152,6 +152,7 @@ void MapFun::RegisterFunction(BuiltinFunctions &set) {\n \t//! the arguments and return types are actually set in the binder function\n \tScalarFunction fun(\"map\", {}, LogicalTypeId::MAP, MapFunction, false, MapBind);\n \tfun.varargs = LogicalType::ANY;\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tset.AddFunction(fun);\n }\n \ndiff --git a/src/function/scalar/map/map_extract.cpp b/src/function/scalar/map/map_extract.cpp\nindex a8e562e87491..7193281b357f 100644\n--- a/src/function/scalar/map/map_extract.cpp\n+++ b/src/function/scalar/map/map_extract.cpp\n@@ -70,6 +70,7 @@ void MapExtractFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunction fun(\"map_extract\", {LogicalType::ANY, LogicalType::ANY}, LogicalType::ANY, MapExtractFunction, false,\n \t                   MapExtractBind);\n \tfun.varargs = LogicalType::ANY;\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tset.AddFunction(fun);\n \tfun.name = \"element_at\";\n \tset.AddFunction(fun);\ndiff --git a/src/function/scalar/string/concat.cpp b/src/function/scalar/string/concat.cpp\nindex fdda6360971d..0377186c1233 100644\n--- a/src/function/scalar/string/concat.cpp\n+++ b/src/function/scalar/string/concat.cpp\n@@ -1,10 +1,9 @@\n-#include \"duckdb/function/scalar/string_functions.hpp\"\n-\n #include \"duckdb/common/exception.hpp\"\n #include \"duckdb/common/types/date.hpp\"\n-#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n #include \"duckdb/common/vector_operations/binary_executor.hpp\"\n+#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n #include \"duckdb/function/scalar/nested_functions.hpp\"\n+#include \"duckdb/function/scalar/string_functions.hpp\"\n \n #include <string.h>\n \n@@ -246,6 +245,7 @@ void ConcatFun::RegisterFunction(BuiltinFunctions &set) {\n \t// concat_ws(',', '', '') = \",\"\n \tScalarFunction concat = ScalarFunction(\"concat\", {LogicalType::VARCHAR}, LogicalType::VARCHAR, ConcatFunction);\n \tconcat.varargs = LogicalType::VARCHAR;\n+\tconcat.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tset.AddFunction(concat);\n \n \tScalarFunctionSet concat_op(\"||\");\n@@ -253,11 +253,15 @@ void ConcatFun::RegisterFunction(BuiltinFunctions &set) {\n \t    ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::VARCHAR, ConcatOperator));\n \tconcat_op.AddFunction(ScalarFunction({LogicalType::BLOB, LogicalType::BLOB}, LogicalType::BLOB, ConcatOperator));\n \tconcat_op.AddFunction(ListConcatFun::GetFunction());\n+\tfor (auto &fun : concat_op.functions) {\n+\t\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\t}\n \tset.AddFunction(concat_op);\n \n \tScalarFunction concat_ws = ScalarFunction(\"concat_ws\", {LogicalType::VARCHAR, LogicalType::VARCHAR},\n \t                                          LogicalType::VARCHAR, ConcatWSFunction);\n \tconcat_ws.varargs = LogicalType::VARCHAR;\n+\tconcat_ws.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tset.AddFunction(concat_ws);\n }\n \ndiff --git a/src/function/scalar/string/regexp.cpp b/src/function/scalar/string/regexp.cpp\nindex ba89feb5986a..65272e836cbf 100644\n--- a/src/function/scalar/string/regexp.cpp\n+++ b/src/function/scalar/string/regexp.cpp\n@@ -315,19 +315,22 @@ void RegexpFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunctionSet regexp_full_match(\"regexp_full_match\");\n \tregexp_full_match.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::BOOLEAN,\n \t                                             RegexpMatchesFunction<RegexFullMatch>, false, false, RegexpMatchesBind,\n-\t                                             nullptr, nullptr, RegexInitLocalState));\n+\t                                             nullptr, nullptr, RegexInitLocalState, LogicalType::INVALID,\n+\t                                             FunctionNullHandling::SPECIAL_HANDLING));\n \tregexp_full_match.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR},\n \t                                             LogicalType::BOOLEAN, RegexpMatchesFunction<RegexFullMatch>, false,\n-\t                                             false, RegexpMatchesBind, nullptr, nullptr, RegexInitLocalState));\n+\t                                             false, RegexpMatchesBind, nullptr, nullptr, RegexInitLocalState,\n+\t                                             LogicalType::INVALID, FunctionNullHandling::SPECIAL_HANDLING));\n \n \tScalarFunctionSet regexp_partial_match(\"regexp_matches\");\n \tregexp_partial_match.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::BOOLEAN,\n \t                                                RegexpMatchesFunction<RegexPartialMatch>, false, false,\n-\t                                                RegexpMatchesBind, nullptr, nullptr, RegexInitLocalState));\n-\tregexp_partial_match.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR},\n-\t                                                LogicalType::BOOLEAN, RegexpMatchesFunction<RegexPartialMatch>,\n-\t                                                false, false, RegexpMatchesBind, nullptr, nullptr,\n-\t                                                RegexInitLocalState));\n+\t                                                RegexpMatchesBind, nullptr, nullptr, RegexInitLocalState,\n+\t                                                LogicalType::INVALID, FunctionNullHandling::SPECIAL_HANDLING));\n+\tregexp_partial_match.AddFunction(\n+\t    ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::BOOLEAN,\n+\t                   RegexpMatchesFunction<RegexPartialMatch>, false, false, RegexpMatchesBind, nullptr, nullptr,\n+\t                   RegexInitLocalState, LogicalType::INVALID, FunctionNullHandling::SPECIAL_HANDLING));\n \n \tScalarFunctionSet regexp_replace(\"regexp_replace\");\n \tregexp_replace.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::VARCHAR},\n@@ -340,10 +343,12 @@ void RegexpFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunctionSet regexp_extract(\"regexp_extract\");\n \tregexp_extract.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, LogicalType::VARCHAR,\n \t                                          RegexExtractFunction, false, false, RegexExtractBind, nullptr, nullptr,\n-\t                                          RegexExtractInitLocalState));\n+\t                                          RegexExtractInitLocalState, LogicalType::INVALID,\n+\t                                          FunctionNullHandling::SPECIAL_HANDLING));\n \tregexp_extract.AddFunction(ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR, LogicalType::INTEGER},\n \t                                          LogicalType::VARCHAR, RegexExtractFunction, false, false,\n-\t                                          RegexExtractBind, nullptr, nullptr, RegexExtractInitLocalState));\n+\t                                          RegexExtractBind, nullptr, nullptr, RegexExtractInitLocalState,\n+\t                                          LogicalType::INVALID, FunctionNullHandling::SPECIAL_HANDLING));\n \n \tset.AddFunction(regexp_full_match);\n \tset.AddFunction(regexp_partial_match);\ndiff --git a/src/function/scalar/string/string_split.cpp b/src/function/scalar/string/string_split.cpp\nindex d554a65fea21..3b2ab37d2523 100644\n--- a/src/function/scalar/string/string_split.cpp\n+++ b/src/function/scalar/string/string_split.cpp\n@@ -1,15 +1,13 @@\n-#include \"duckdb/function/scalar/string_functions.hpp\"\n-#include \"duckdb/function/scalar/regexp.hpp\"\n-\n #include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/pair.hpp\"\n #include \"duckdb/common/types/chunk_collection.hpp\"\n #include \"duckdb/common/types/data_chunk.hpp\"\n #include \"duckdb/common/types/vector.hpp\"\n #include \"duckdb/common/vector_size.hpp\"\n-#include \"duckdb/common/pair.hpp\"\n-\n-#include \"utf8proc_wrapper.hpp\"\n+#include \"duckdb/function/scalar/regexp.hpp\"\n+#include \"duckdb/function/scalar/string_functions.hpp\"\n #include \"utf8proc.hpp\"\n+#include \"utf8proc_wrapper.hpp\"\n \n namespace duckdb {\n \n@@ -251,12 +249,15 @@ static void StringSplitRegexFunction(DataChunk &args, ExpressionState &state, Ve\n void StringSplitFun::RegisterFunction(BuiltinFunctions &set) {\n \tauto varchar_list_type = LogicalType::LIST(LogicalType::VARCHAR);\n \n-\tset.AddFunction(\n-\t    {\"string_split\", \"str_split\", \"string_to_array\", \"split\"},\n-\t    ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, varchar_list_type, StringSplitFunction));\n-\tset.AddFunction(\n-\t    {\"string_split_regex\", \"str_split_regex\", \"regexp_split_to_array\"},\n-\t    ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, varchar_list_type, StringSplitRegexFunction));\n+\tauto regular_fun =\n+\t    ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, varchar_list_type, StringSplitFunction);\n+\tregular_fun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\tset.AddFunction({\"string_split\", \"str_split\", \"string_to_array\", \"split\"}, regular_fun);\n+\n+\tauto regex_fun =\n+\t    ScalarFunction({LogicalType::VARCHAR, LogicalType::VARCHAR}, varchar_list_type, StringSplitRegexFunction);\n+\tregex_fun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\tset.AddFunction({\"string_split_regex\", \"str_split_regex\", \"regexp_split_to_array\"}, regex_fun);\n }\n \n } // namespace duckdb\ndiff --git a/src/function/scalar/struct/struct_extract.cpp b/src/function/scalar/struct/struct_extract.cpp\nindex e48e9d825f8e..2925e277fefb 100644\n--- a/src/function/scalar/struct/struct_extract.cpp\n+++ b/src/function/scalar/struct/struct_extract.cpp\n@@ -43,12 +43,6 @@ static void StructExtractFunction(DataChunk &args, ExpressionState &state, Vecto\n static unique_ptr<FunctionData> StructExtractBind(ClientContext &context, ScalarFunction &bound_function,\n                                                   vector<unique_ptr<Expression>> &arguments) {\n \tD_ASSERT(bound_function.arguments.size() == 2);\n-\tif (arguments[0]->return_type.id() == LogicalTypeId::SQLNULL ||\n-\t    arguments[1]->return_type.id() == LogicalTypeId::SQLNULL) {\n-\t\tbound_function.return_type = LogicalType::SQLNULL;\n-\t\tbound_function.arguments[0] = LogicalType::SQLNULL;\n-\t\treturn make_unique<StructExtractBindData>(\"\", 0, LogicalType::SQLNULL);\n-\t}\n \tD_ASSERT(LogicalTypeId::STRUCT == arguments[0]->return_type.id());\n \tauto &struct_children = StructType::GetChildTypes(arguments[0]->return_type);\n \tif (struct_children.empty()) {\ndiff --git a/src/function/scalar/struct/struct_pack.cpp b/src/function/scalar/struct/struct_pack.cpp\nindex f7a035c12f13..5729f6d5ff9d 100644\n--- a/src/function/scalar/struct/struct_pack.cpp\n+++ b/src/function/scalar/struct/struct_pack.cpp\n@@ -74,6 +74,7 @@ void StructPackFun::RegisterFunction(BuiltinFunctions &set) {\n \tScalarFunction fun(\"struct_pack\", {}, LogicalTypeId::STRUCT, StructPackFunction, false, StructPackBind, nullptr,\n \t                   StructPackStats);\n \tfun.varargs = LogicalType::ANY;\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tset.AddFunction(fun);\n \tfun.name = \"row\";\n \tset.AddFunction(fun);\ndiff --git a/src/function/scalar/system/aggregate_export.cpp b/src/function/scalar/system/aggregate_export.cpp\nindex 826152e7cb5c..d97eea4150cd 100644\n--- a/src/function/scalar/system/aggregate_export.cpp\n+++ b/src/function/scalar/system/aggregate_export.cpp\n@@ -1,8 +1,8 @@\n+#include \"duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp\"\n #include \"duckdb/function/scalar/generic_functions.hpp\"\n-#include \"duckdb/main/database.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n+#include \"duckdb/main/database.hpp\"\n #include \"duckdb/planner/expression/bound_function_expression.hpp\"\n-#include \"duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp\"\n \n namespace duckdb {\n \n@@ -290,14 +290,19 @@ ExportAggregateFunction::Bind(unique_ptr<BoundAggregateExpression> child_aggrega\n }\n \n ScalarFunction ExportAggregateFunction::GetFinalize() {\n-\treturn ScalarFunction(\"finalize\", {LogicalTypeId::AGGREGATE_STATE}, LogicalTypeId::INVALID, AggregateStateFinalize,\n-\t                      false, BindAggregateState, nullptr, nullptr, InitFinalizeState);\n+\tauto result =\n+\t    ScalarFunction(\"finalize\", {LogicalTypeId::AGGREGATE_STATE}, LogicalTypeId::INVALID, AggregateStateFinalize,\n+\t                   false, BindAggregateState, nullptr, nullptr, InitFinalizeState);\n+\tresult.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\treturn result;\n }\n \n ScalarFunction ExportAggregateFunction::GetCombine() {\n-\treturn ScalarFunction(\"combine\", {LogicalTypeId::AGGREGATE_STATE, LogicalTypeId::ANY},\n-\t                      LogicalTypeId::AGGREGATE_STATE, AggregateStateCombine, false, BindAggregateState, nullptr,\n-\t                      nullptr, InitCombineState);\n+\tauto result =\n+\t    ScalarFunction(\"combine\", {LogicalTypeId::AGGREGATE_STATE, LogicalTypeId::ANY}, LogicalTypeId::AGGREGATE_STATE,\n+\t                   AggregateStateCombine, false, BindAggregateState, nullptr, nullptr, InitCombineState);\n+\tresult.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n+\treturn result;\n }\n \n } // namespace duckdb\ndiff --git a/src/function/scalar_function.cpp b/src/function/scalar_function.cpp\nindex 0317dc82698c..46386875eecc 100644\n--- a/src/function/scalar_function.cpp\n+++ b/src/function/scalar_function.cpp\n@@ -8,19 +8,21 @@ FunctionLocalState::~FunctionLocalState() {\n ScalarFunction::ScalarFunction(string name, vector<LogicalType> arguments, LogicalType return_type,\n                                scalar_function_t function, bool has_side_effects, bind_scalar_function_t bind,\n                                dependency_function_t dependency, function_statistics_t statistics,\n-                               init_local_state_t init_local_state, LogicalType varargs, bool propagate_null_values)\n+                               init_local_state_t init_local_state, LogicalType varargs, bool propagate_null_values,\n+                               FunctionNullHandling null_handling)\n     : BaseScalarFunction(move(name), move(arguments), move(return_type), has_side_effects, move(varargs),\n                          propagate_null_values),\n       function(move(function)), bind(bind), init_local_state(init_local_state), dependency(dependency),\n-      statistics(statistics) {\n+      statistics(statistics), null_handling(null_handling) {\n }\n \n ScalarFunction::ScalarFunction(vector<LogicalType> arguments, LogicalType return_type, scalar_function_t function,\n                                bool propagate_null_values, bool has_side_effects, bind_scalar_function_t bind,\n                                dependency_function_t dependency, function_statistics_t statistics,\n-                               init_local_state_t init_local_state, LogicalType varargs)\n+                               init_local_state_t init_local_state, LogicalType varargs,\n+                               FunctionNullHandling null_handling)\n     : ScalarFunction(string(), move(arguments), move(return_type), move(function), has_side_effects, bind, dependency,\n-                     statistics, init_local_state, move(varargs), propagate_null_values) {\n+                     statistics, init_local_state, move(varargs), propagate_null_values, null_handling) {\n }\n \n bool ScalarFunction::operator==(const ScalarFunction &rhs) const {\ndiff --git a/src/include/duckdb/function/scalar_function.hpp b/src/include/duckdb/function/scalar_function.hpp\nindex 0bed14808182..f8670a83b153 100644\n--- a/src/include/duckdb/function/scalar_function.hpp\n+++ b/src/include/duckdb/function/scalar_function.hpp\n@@ -22,6 +22,9 @@ struct FunctionLocalState {\n \tDUCKDB_API virtual ~FunctionLocalState();\n };\n \n+enum class FunctionNullHandling : uint8_t { NULL_IN_NULL_OUT = 0, SPECIAL_HANDLING = 1 };\n+\n+class Binder;\n class BoundFunctionExpression;\n class ScalarFunctionCatalogEntry;\n \n@@ -55,13 +58,15 @@ class ScalarFunction : public BaseScalarFunction {\n \t                          bind_scalar_function_t bind = nullptr, dependency_function_t dependency = nullptr,\n \t                          function_statistics_t statistics = nullptr, init_local_state_t init_local_state = nullptr,\n \t                          LogicalType varargs = LogicalType(LogicalTypeId::INVALID),\n-\t                          bool propagate_null_values = false);\n+\t                          bool propagate_null_values = false,\n+\t                          FunctionNullHandling null_handling = FunctionNullHandling::NULL_IN_NULL_OUT);\n \n \tDUCKDB_API ScalarFunction(vector<LogicalType> arguments, LogicalType return_type, scalar_function_t function,\n \t                          bool propagate_null_values = false, bool has_side_effects = false,\n \t                          bind_scalar_function_t bind = nullptr, dependency_function_t dependency = nullptr,\n \t                          function_statistics_t statistics = nullptr, init_local_state_t init_local_state = nullptr,\n-\t                          LogicalType varargs = LogicalType(LogicalTypeId::INVALID));\n+\t                          LogicalType varargs = LogicalType(LogicalTypeId::INVALID),\n+\t                          FunctionNullHandling null_handling = FunctionNullHandling::NULL_IN_NULL_OUT);\n \n \t//! The main scalar function to execute\n \tscalar_function_t function;\n@@ -73,15 +78,17 @@ class ScalarFunction : public BaseScalarFunction {\n \tdependency_function_t dependency;\n \t//! The statistics propagation function (if any)\n \tfunction_statistics_t statistics;\n-\n-\tDUCKDB_API static unique_ptr<BoundFunctionExpression> BindScalarFunction(ClientContext &context,\n-\t                                                                         const string &schema, const string &name,\n-\t                                                                         vector<unique_ptr<Expression>> children,\n-\t                                                                         string &error, bool is_operator = false);\n-\tDUCKDB_API static unique_ptr<BoundFunctionExpression> BindScalarFunction(ClientContext &context,\n-\t                                                                         ScalarFunctionCatalogEntry &function,\n-\t                                                                         vector<unique_ptr<Expression>> children,\n-\t                                                                         string &error, bool is_operator = false);\n+\t//! How this function handles NULL values\n+\tFunctionNullHandling null_handling;\n+\n+\tDUCKDB_API static unique_ptr<Expression> BindScalarFunction(ClientContext &context, const string &schema,\n+\t                                                            const string &name,\n+\t                                                            vector<unique_ptr<Expression>> children, string &error,\n+\t                                                            bool is_operator = false, Binder *binder = nullptr);\n+\tDUCKDB_API static unique_ptr<Expression> BindScalarFunction(ClientContext &context,\n+\t                                                            ScalarFunctionCatalogEntry &function,\n+\t                                                            vector<unique_ptr<Expression>> children, string &error,\n+\t                                                            bool is_operator = false, Binder *binder = nullptr);\n \n \tDUCKDB_API static unique_ptr<BoundFunctionExpression>\n \tBindScalarFunction(ClientContext &context, ScalarFunction bound_function, vector<unique_ptr<Expression>> children,\ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex ff090254e792..3a54647dde2e 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -159,6 +159,9 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \tvoid AddTableName(string table_name);\n \tconst unordered_set<string> &GetTableNames();\n \n+\t//! Removes the BoundParameterExpressions from Binder::parameters if they occur in 'expressions'\n+\tvoid RemoveParameters(vector<unique_ptr<Expression>> &expressions);\n+\n private:\n \t//! The parent binder (if any)\n \tshared_ptr<Binder> parent;\ndiff --git a/src/include/duckdb/planner/expression/bound_function_expression.hpp b/src/include/duckdb/planner/expression/bound_function_expression.hpp\nindex 226514545697..db7d00d174dd 100644\n--- a/src/include/duckdb/planner/expression/bound_function_expression.hpp\n+++ b/src/include/duckdb/planner/expression/bound_function_expression.hpp\n@@ -21,7 +21,7 @@ class BoundFunctionExpression : public Expression {\n \t                        vector<unique_ptr<Expression>> arguments, unique_ptr<FunctionData> bind_info,\n \t                        bool is_operator = false);\n \n-\t// The bound function expression\n+\t//! The bound function expression\n \tScalarFunction function;\n \t//! List of child-expressions of the function\n \tvector<unique_ptr<Expression>> children;\ndiff --git a/src/optimizer/rule/date_part_simplification.cpp b/src/optimizer/rule/date_part_simplification.cpp\nindex 7a3082893d28..d757f7211af4 100644\n--- a/src/optimizer/rule/date_part_simplification.cpp\n+++ b/src/optimizer/rule/date_part_simplification.cpp\n@@ -100,7 +100,7 @@ unique_ptr<Expression> DatePartSimplificationRule::Apply(LogicalOperator &op, ve\n \tif (!function) {\n \t\tthrow BinderException(error);\n \t}\n-\treturn move(function);\n+\treturn function;\n }\n \n } // namespace duckdb\ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex d7a2591ecc78..eca6a30cbad7 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -1,20 +1,20 @@\n #include \"duckdb/planner/binder.hpp\"\n \n-#include \"duckdb/parser/statement/list.hpp\"\n+#include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n+#include \"duckdb/catalog/catalog_entry/view_catalog_entry.hpp\"\n #include \"duckdb/parser/query_node/select_node.hpp\"\n+#include \"duckdb/parser/statement/list.hpp\"\n+#include \"duckdb/parser/tableref/table_function_ref.hpp\"\n #include \"duckdb/planner/bound_query_node.hpp\"\n #include \"duckdb/planner/bound_tableref.hpp\"\n #include \"duckdb/planner/expression.hpp\"\n-#include \"duckdb/planner/operator/logical_sample.hpp\"\n-#include \"duckdb/planner/operator/logical_projection.hpp\"\n-#include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n-#include \"duckdb/catalog/catalog_entry/view_catalog_entry.hpp\"\n #include \"duckdb/planner/expression_binder/returning_binder.hpp\"\n+#include \"duckdb/planner/expression_iterator.hpp\"\n+#include \"duckdb/planner/operator/logical_projection.hpp\"\n+#include \"duckdb/planner/operator/logical_sample.hpp\"\n \n #include <algorithm>\n \n-#include \"duckdb/parser/tableref/table_function_ref.hpp\"\n-\n namespace duckdb {\n \n shared_ptr<Binder> Binder::CreateBinder(ClientContext &context, Binder *parent, bool inherit_ctes) {\n@@ -374,6 +374,22 @@ const unordered_set<string> &Binder::GetTableNames() {\n \treturn table_names;\n }\n \n+void Binder::RemoveParameters(vector<unique_ptr<Expression>> &expressions) {\n+\tfor (auto &expr : expressions) {\n+\t\tif (!expr->HasParameter()) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\tExpressionIterator::EnumerateExpression(expr, [&](Expression &child) {\n+\t\t\tfor (auto param_it = parameters->begin(); param_it != parameters->end(); param_it++) {\n+\t\t\t\tif (expr->Equals(*param_it)) {\n+\t\t\t\t\tparameters->erase(param_it);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+}\n+\n string Binder::FormatError(ParsedExpression &expr_context, const string &message) {\n \treturn FormatError(expr_context.query_location, message);\n }\ndiff --git a/src/planner/binder/expression/bind_function_expression.cpp b/src/planner/binder/expression/bind_function_expression.cpp\nindex 1a19162c69b1..44e99263959e 100644\n--- a/src/planner/binder/expression/bind_function_expression.cpp\n+++ b/src/planner/binder/expression/bind_function_expression.cpp\n@@ -2,11 +2,11 @@\n #include \"duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp\"\n #include \"duckdb/execution/expression_executor.hpp\"\n #include \"duckdb/parser/expression/function_expression.hpp\"\n+#include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n #include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n #include \"duckdb/planner/expression/bound_function_expression.hpp\"\n #include \"duckdb/planner/expression_binder.hpp\"\n-#include \"duckdb/planner/binder.hpp\"\n \n namespace duckdb {\n \n@@ -59,7 +59,7 @@ BindResult ExpressionBinder::BindFunction(FunctionExpression &function, ScalarFu\n \t\tchildren.push_back(move(child.expr));\n \t}\n \tunique_ptr<Expression> result =\n-\t    ScalarFunction::BindScalarFunction(context, *func, move(children), error, function.is_operator);\n+\t    ScalarFunction::BindScalarFunction(context, *func, move(children), error, function.is_operator, &binder);\n \tif (!result) {\n \t\tthrow BinderException(binder.FormatError(function, error));\n \t}\n",
  "test_patch": "diff --git a/test/issues/general/test_3822.test b/test/issues/general/test_3822.test\nnew file mode 100644\nindex 000000000000..25e8ec7897f8\n--- /dev/null\n+++ b/test/issues/general/test_3822.test\n@@ -0,0 +1,14 @@\n+# name: test/issues/general/test_3822.test\n+# description: Issue 3822: Array_slice in macro type error\n+# group: [general]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE MACRO pyfloats_to_floats(x) AS (CAST(string_split(x[2:-1], ',') AS FLOAT4[]))\n+\n+query T\n+select pyfloats_to_floats('[1.000000, 2.000000, 3.000000]')\n+----\n+[1.0, 2.0, 3.0]\n\\ No newline at end of file\ndiff --git a/test/sql/types/decimal/test_decimal_ops.test b/test/sql/types/decimal/test_decimal_ops.test\nindex dbed955b9c31..62734423fccc 100644\n--- a/test/sql/types/decimal/test_decimal_ops.test\n+++ b/test/sql/types/decimal/test_decimal_ops.test\n@@ -324,9 +324,11 @@ SELECT ROUND(12::DECIMAL(3,0))\n statement error\n SELECT ROUND(12::DECIMAL(3,0), i) FROM range(1) tbl(i)\n \n-# null precision is not supported\n-statement error\n+# null precision becomes null (postgres behavior)\n+query T\n SELECT ROUND(12::DECIMAL(3,0), NULL)\n+----\n+NULL\n \n # different types for ROUND\n query III\n",
  "problem_statement": "Array_slice in macro type error\n#### What happens?\r\n\r\nA typing error `Binder Error: ARRAY_SLICE can only operate on LISTs and VARCHARs` is raised slicing into a macro parameter.\r\n\r\nMytherin confirmed this as a bug on discord and suggested casting x to a varchar as a work around.\r\n\r\n#### To Reproduce\r\n\r\n```sql\r\nCREATE MACRO pyfloats_to_floats(x) AS (CAST(string_split(x[2:-1], ',') AS FLOAT4[]))\r\n```\r\n#### Environment (please complete the following information):\r\n - OS: Windows\r\n - DuckDB Version:  0.3.5.dev1091\r\n - DuckDB Client: Python\r\n\r\n#### Before Submitting\r\n\r\n- [X] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [X] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nArray_slice in macro type error\n#### What happens?\r\n\r\nA typing error `Binder Error: ARRAY_SLICE can only operate on LISTs and VARCHARs` is raised slicing into a macro parameter.\r\n\r\nMytherin confirmed this as a bug on discord and suggested casting x to a varchar as a work around.\r\n\r\n#### To Reproduce\r\n\r\n```sql\r\nCREATE MACRO pyfloats_to_floats(x) AS (CAST(string_split(x[2:-1], ',') AS FLOAT4[]))\r\n```\r\n#### Environment (please complete the following information):\r\n - OS: Windows\r\n - DuckDB Version:  0.3.5.dev1091\r\n - DuckDB Client: Python\r\n\r\n#### Before Submitting\r\n\r\n- [X] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [X] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "@Mytherin This is due to `ArraySliceBind` checking for `LogicalTypeId::UNKNOWN`, but not for `LogicalTypeId::SQLNULL`, which is used by macro's. We can simply add the check for `SQLNULL` there, or we can change the type of macro parameters to `UNKNOWN`, which requires changing the `Bind` for a few functions here and there. I'm happy to do either\nI think calling functions with `NULL` parameters should always work, so the `array_slice` would need to be fixed regardless.\r\n\r\nPerhaps we can add an additional flag to the `ScalarFunction`:\r\n\r\n```cpp\r\nenum FunctionNullHandling { NULL_IN_NULL_OUT, SPECIAL_HANDLING }\r\n```\r\n\r\nWhich defaults to `NULL_IN_NULL_OUT` and indicates that a `NULL` input results in a `NULL` output - since this is the case for the vast majority of functions. In this case, we can check in the Binder if any of the inputs are a constant `NULL`, and then replace the entire expression with a constant `NULL`. That way we don't need to handle this case in every single bind call.\nSounds good, I'll get on it!\n@Mytherin This is due to `ArraySliceBind` checking for `LogicalTypeId::UNKNOWN`, but not for `LogicalTypeId::SQLNULL`, which is used by macro's. We can simply add the check for `SQLNULL` there, or we can change the type of macro parameters to `UNKNOWN`, which requires changing the `Bind` for a few functions here and there. I'm happy to do either\nI think calling functions with `NULL` parameters should always work, so the `array_slice` would need to be fixed regardless.\r\n\r\nPerhaps we can add an additional flag to the `ScalarFunction`:\r\n\r\n```cpp\r\nenum FunctionNullHandling { NULL_IN_NULL_OUT, SPECIAL_HANDLING }\r\n```\r\n\r\nWhich defaults to `NULL_IN_NULL_OUT` and indicates that a `NULL` input results in a `NULL` output - since this is the case for the vast majority of functions. In this case, we can check in the Binder if any of the inputs are a constant `NULL`, and then replace the entire expression with a constant `NULL`. That way we don't need to handle this case in every single bind call.\nSounds good, I'll get on it!",
  "created_at": "2022-06-15T12:37:53Z"
}