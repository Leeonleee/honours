{
  "repo": "duckdb/duckdb",
  "pull_number": 7821,
  "instance_id": "duckdb__duckdb-7821",
  "issue_numbers": [
    "7391"
  ],
  "base_commit": "e8bcc0f50da1e76ae34e620561fec6e35dad6de1",
  "patch": "diff --git a/src/include/duckdb/optimizer/filter_pushdown.hpp b/src/include/duckdb/optimizer/filter_pushdown.hpp\nindex fa6edcf2487e..52b384d09ae5 100644\n--- a/src/include/duckdb/optimizer/filter_pushdown.hpp\n+++ b/src/include/duckdb/optimizer/filter_pushdown.hpp\n@@ -19,8 +19,11 @@ class Optimizer;\n class FilterPushdown {\n public:\n \texplicit FilterPushdown(Optimizer &optimizer);\n+\n \t//! Perform filter pushdown\n \tunique_ptr<LogicalOperator> Rewrite(unique_ptr<LogicalOperator> op);\n+\t//! Return a reference to the client context (from the optimizer)\n+\tClientContext &GetContext();\n \n \tstruct Filter {\n \t\tunordered_set<idx_t> bindings;\ndiff --git a/src/include/duckdb/optimizer/optimizer.hpp b/src/include/duckdb/optimizer/optimizer.hpp\nindex 96bde0ad7012..312fcc4908d2 100644\n--- a/src/include/duckdb/optimizer/optimizer.hpp\n+++ b/src/include/duckdb/optimizer/optimizer.hpp\n@@ -22,7 +22,10 @@ class Optimizer {\n public:\n \tOptimizer(Binder &binder, ClientContext &context);\n \n+\t//! Optimize a plan by running specialized optimizers\n \tunique_ptr<LogicalOperator> Optimize(unique_ptr<LogicalOperator> plan);\n+\t//! Return a reference to the client context of this optimizer\n+\tClientContext &GetContext();\n \n \tClientContext &context;\n \tBinder &binder;\ndiff --git a/src/include/duckdb/planner/operator/logical_comparison_join.hpp b/src/include/duckdb/planner/operator/logical_comparison_join.hpp\nindex bc11392a3502..1866ce0cff39 100644\n--- a/src/include/duckdb/planner/operator/logical_comparison_join.hpp\n+++ b/src/include/duckdb/planner/operator/logical_comparison_join.hpp\n@@ -38,25 +38,25 @@ class LogicalComparisonJoin : public LogicalJoin {\n \t                        FieldReader &reader);\n \n public:\n-\tstatic unique_ptr<LogicalOperator> CreateJoin(JoinType type, JoinRefType ref_type,\n+\tstatic unique_ptr<LogicalOperator> CreateJoin(ClientContext &context, JoinType type, JoinRefType ref_type,\n \t                                              unique_ptr<LogicalOperator> left_child,\n \t                                              unique_ptr<LogicalOperator> right_child,\n \t                                              unique_ptr<Expression> condition);\n-\tstatic unique_ptr<LogicalOperator> CreateJoin(JoinType type, JoinRefType ref_type,\n+\tstatic unique_ptr<LogicalOperator> CreateJoin(ClientContext &context, JoinType type, JoinRefType ref_type,\n \t                                              unique_ptr<LogicalOperator> left_child,\n \t                                              unique_ptr<LogicalOperator> right_child,\n \t                                              vector<JoinCondition> conditions,\n \t                                              vector<unique_ptr<Expression>> arbitrary_expressions);\n \n-\tstatic void ExtractJoinConditions(JoinType type, unique_ptr<LogicalOperator> &left_child,\n+\tstatic void ExtractJoinConditions(ClientContext &context, JoinType type, unique_ptr<LogicalOperator> &left_child,\n \t                                  unique_ptr<LogicalOperator> &right_child, unique_ptr<Expression> condition,\n \t                                  vector<JoinCondition> &conditions,\n \t                                  vector<unique_ptr<Expression>> &arbitrary_expressions);\n-\tstatic void ExtractJoinConditions(JoinType type, unique_ptr<LogicalOperator> &left_child,\n+\tstatic void ExtractJoinConditions(ClientContext &context, JoinType type, unique_ptr<LogicalOperator> &left_child,\n \t                                  unique_ptr<LogicalOperator> &right_child,\n \t                                  vector<unique_ptr<Expression>> &expressions, vector<JoinCondition> &conditions,\n \t                                  vector<unique_ptr<Expression>> &arbitrary_expressions);\n-\tstatic void ExtractJoinConditions(JoinType type, unique_ptr<LogicalOperator> &left_child,\n+\tstatic void ExtractJoinConditions(ClientContext &context, JoinType type, unique_ptr<LogicalOperator> &left_child,\n \t                                  unique_ptr<LogicalOperator> &right_child,\n \t                                  const unordered_set<idx_t> &left_bindings,\n \t                                  const unordered_set<idx_t> &right_bindings,\ndiff --git a/src/optimizer/filter_pushdown.cpp b/src/optimizer/filter_pushdown.cpp\nindex c76da8c81a4c..31c57db88c80 100644\n--- a/src/optimizer/filter_pushdown.cpp\n+++ b/src/optimizer/filter_pushdown.cpp\n@@ -47,6 +47,10 @@ unique_ptr<LogicalOperator> FilterPushdown::Rewrite(unique_ptr<LogicalOperator>\n \t}\n }\n \n+ClientContext &FilterPushdown::GetContext() {\n+\treturn optimizer.GetContext();\n+}\n+\n unique_ptr<LogicalOperator> FilterPushdown::PushdownJoin(unique_ptr<LogicalOperator> op) {\n \tD_ASSERT(op->type == LogicalOperatorType::LOGICAL_COMPARISON_JOIN ||\n \t         op->type == LogicalOperatorType::LOGICAL_ASOF_JOIN || op->type == LogicalOperatorType::LOGICAL_ANY_JOIN ||\ndiff --git a/src/optimizer/optimizer.cpp b/src/optimizer/optimizer.cpp\nindex 07b15a3b0b78..f6618051e112 100644\n--- a/src/optimizer/optimizer.cpp\n+++ b/src/optimizer/optimizer.cpp\n@@ -52,6 +52,10 @@ Optimizer::Optimizer(Binder &binder, ClientContext &context) : context(context),\n #endif\n }\n \n+ClientContext &Optimizer::GetContext() {\n+\treturn context;\n+}\n+\n void Optimizer::RunOptimizer(OptimizerType type, const std::function<void()> &callback) {\n \tauto &config = DBConfig::GetConfig(context);\n \tif (config.options.disabled_optimizers.find(type) != config.options.disabled_optimizers.end()) {\ndiff --git a/src/optimizer/pushdown/pushdown_cross_product.cpp b/src/optimizer/pushdown/pushdown_cross_product.cpp\nindex fa4f76769254..efa3fa4e7a03 100644\n--- a/src/optimizer/pushdown/pushdown_cross_product.cpp\n+++ b/src/optimizer/pushdown/pushdown_cross_product.cpp\n@@ -42,13 +42,13 @@ unique_ptr<LogicalOperator> FilterPushdown::PushdownCrossProduct(unique_ptr<Logi\n \t\tvector<JoinCondition> conditions;\n \t\tvector<unique_ptr<Expression>> arbitrary_expressions;\n \t\tauto join_type = JoinType::INNER;\n-\t\tLogicalComparisonJoin::ExtractJoinConditions(join_type, op->children[0], op->children[1], left_bindings,\n-\t\t                                             right_bindings, join_expressions, conditions,\n+\t\tLogicalComparisonJoin::ExtractJoinConditions(GetContext(), join_type, op->children[0], op->children[1],\n+\t\t                                             left_bindings, right_bindings, join_expressions, conditions,\n \t\t                                             arbitrary_expressions);\n \t\t// create the join from the join conditions\n-\t\treturn LogicalComparisonJoin::CreateJoin(JoinType::INNER, JoinRefType::REGULAR, std::move(op->children[0]),\n-\t\t                                         std::move(op->children[1]), std::move(conditions),\n-\t\t                                         std::move(arbitrary_expressions));\n+\t\treturn LogicalComparisonJoin::CreateJoin(GetContext(), JoinType::INNER, JoinRefType::REGULAR,\n+\t\t                                         std::move(op->children[0]), std::move(op->children[1]),\n+\t\t                                         std::move(conditions), std::move(arbitrary_expressions));\n \t} else {\n \t\t// no join conditions found: keep as cross product\n \t\treturn op;\ndiff --git a/src/planner/binder/query_node/plan_subquery.cpp b/src/planner/binder/query_node/plan_subquery.cpp\nindex 84819948e345..2843970e096d 100644\n--- a/src/planner/binder/query_node/plan_subquery.cpp\n+++ b/src/planner/binder/query_node/plan_subquery.cpp\n@@ -414,7 +414,7 @@ unique_ptr<LogicalOperator> Binder::PlanLateralJoin(unique_ptr<LogicalOperator>\n \tvector<unique_ptr<Expression>> arbitrary_expressions;\n \tif (condition) {\n \t\t// extract join conditions, if there are any\n-\t\tLogicalComparisonJoin::ExtractJoinConditions(join_type, left, right, std::move(condition), conditions,\n+\t\tLogicalComparisonJoin::ExtractJoinConditions(context, join_type, left, right, std::move(condition), conditions,\n \t\t                                             arbitrary_expressions);\n \t}\n \ndiff --git a/src/planner/binder/tableref/plan_joinref.cpp b/src/planner/binder/tableref/plan_joinref.cpp\nindex 7d2078cfeb9f..0e3d05d93848 100644\n--- a/src/planner/binder/tableref/plan_joinref.cpp\n+++ b/src/planner/binder/tableref/plan_joinref.cpp\n@@ -17,6 +17,7 @@\n #include \"duckdb/main/client_context.hpp\"\n #include \"duckdb/planner/expression_binder/lateral_binder.hpp\"\n #include \"duckdb/planner/subquery/recursive_dependent_join_planner.hpp\"\n+#include \"duckdb/execution/expression_executor.hpp\"\n \n namespace duckdb {\n \n@@ -46,13 +47,11 @@ static bool CreateJoinCondition(Expression &expr, const unordered_set<idx_t> &le\n \treturn false;\n }\n \n-void LogicalComparisonJoin::ExtractJoinConditions(JoinType type, unique_ptr<LogicalOperator> &left_child,\n-                                                  unique_ptr<LogicalOperator> &right_child,\n-                                                  const unordered_set<idx_t> &left_bindings,\n-                                                  const unordered_set<idx_t> &right_bindings,\n-                                                  vector<unique_ptr<Expression>> &expressions,\n-                                                  vector<JoinCondition> &conditions,\n-                                                  vector<unique_ptr<Expression>> &arbitrary_expressions) {\n+void LogicalComparisonJoin::ExtractJoinConditions(\n+    ClientContext &context, JoinType type, unique_ptr<LogicalOperator> &left_child,\n+    unique_ptr<LogicalOperator> &right_child, const unordered_set<idx_t> &left_bindings,\n+    const unordered_set<idx_t> &right_bindings, vector<unique_ptr<Expression>> &expressions,\n+    vector<JoinCondition> &conditions, vector<unique_ptr<Expression>> &arbitrary_expressions) {\n \tfor (auto &expr : expressions) {\n \t\tauto total_side = JoinSide::GetJoinSide(*expr, left_bindings, right_bindings);\n \t\tif (total_side != JoinSide::BOTH) {\n@@ -70,6 +69,15 @@ void LogicalComparisonJoin::ExtractJoinConditions(JoinType type, unique_ptr<Logi\n \t\t\t\tfilter.expressions.push_back(std::move(expr));\n \t\t\t\tcontinue;\n \t\t\t}\n+\t\t\t// if the join is a LEFT JOIN and the join expression constantly evaluates to TRUE,\n+\t\t\t// then we do not add it to the arbitrary expressions\n+\t\t\tif (type == JoinType::LEFT && expr->IsFoldable()) {\n+\t\t\t\tValue result;\n+\t\t\t\tExpressionExecutor::TryEvaluateScalar(context, *expr, result);\n+\t\t\t\tif (!result.IsNull() && result == Value(true)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n \t\t} else if ((expr->type >= ExpressionType::COMPARE_EQUAL &&\n \t\t            expr->type <= ExpressionType::COMPARE_GREATERTHANOREQUALTO) ||\n \t\t           expr->type == ExpressionType::COMPARE_DISTINCT_FROM ||\n@@ -84,7 +92,8 @@ void LogicalComparisonJoin::ExtractJoinConditions(JoinType type, unique_ptr<Logi\n \t}\n }\n \n-void LogicalComparisonJoin::ExtractJoinConditions(JoinType type, unique_ptr<LogicalOperator> &left_child,\n+void LogicalComparisonJoin::ExtractJoinConditions(ClientContext &context, JoinType type,\n+                                                  unique_ptr<LogicalOperator> &left_child,\n                                                   unique_ptr<LogicalOperator> &right_child,\n                                                   vector<unique_ptr<Expression>> &expressions,\n                                                   vector<JoinCondition> &conditions,\n@@ -92,11 +101,12 @@ void LogicalComparisonJoin::ExtractJoinConditions(JoinType type, unique_ptr<Logi\n \tunordered_set<idx_t> left_bindings, right_bindings;\n \tLogicalJoin::GetTableReferences(*left_child, left_bindings);\n \tLogicalJoin::GetTableReferences(*right_child, right_bindings);\n-\treturn ExtractJoinConditions(type, left_child, right_child, left_bindings, right_bindings, expressions, conditions,\n-\t                             arbitrary_expressions);\n+\treturn ExtractJoinConditions(context, type, left_child, right_child, left_bindings, right_bindings, expressions,\n+\t                             conditions, arbitrary_expressions);\n }\n \n-void LogicalComparisonJoin::ExtractJoinConditions(JoinType type, unique_ptr<LogicalOperator> &left_child,\n+void LogicalComparisonJoin::ExtractJoinConditions(ClientContext &context, JoinType type,\n+                                                  unique_ptr<LogicalOperator> &left_child,\n                                                   unique_ptr<LogicalOperator> &right_child,\n                                                   unique_ptr<Expression> condition, vector<JoinCondition> &conditions,\n                                                   vector<unique_ptr<Expression>> &arbitrary_expressions) {\n@@ -104,10 +114,12 @@ void LogicalComparisonJoin::ExtractJoinConditions(JoinType type, unique_ptr<Logi\n \tvector<unique_ptr<Expression>> expressions;\n \texpressions.push_back(std::move(condition));\n \tLogicalFilter::SplitPredicates(expressions);\n-\treturn ExtractJoinConditions(type, left_child, right_child, expressions, conditions, arbitrary_expressions);\n+\treturn ExtractJoinConditions(context, type, left_child, right_child, expressions, conditions,\n+\t                             arbitrary_expressions);\n }\n \n-unique_ptr<LogicalOperator> LogicalComparisonJoin::CreateJoin(JoinType type, JoinRefType reftype,\n+unique_ptr<LogicalOperator> LogicalComparisonJoin::CreateJoin(ClientContext &context, JoinType type,\n+                                                              JoinRefType reftype,\n                                                               unique_ptr<LogicalOperator> left_child,\n                                                               unique_ptr<LogicalOperator> right_child,\n                                                               vector<JoinCondition> conditions,\n@@ -218,15 +230,16 @@ static bool HasCorrelatedColumns(Expression &expression) {\n \treturn has_correlated_columns;\n }\n \n-unique_ptr<LogicalOperator> LogicalComparisonJoin::CreateJoin(JoinType type, JoinRefType reftype,\n+unique_ptr<LogicalOperator> LogicalComparisonJoin::CreateJoin(ClientContext &context, JoinType type,\n+                                                              JoinRefType reftype,\n                                                               unique_ptr<LogicalOperator> left_child,\n                                                               unique_ptr<LogicalOperator> right_child,\n                                                               unique_ptr<Expression> condition) {\n \tvector<JoinCondition> conditions;\n \tvector<unique_ptr<Expression>> arbitrary_expressions;\n-\tLogicalComparisonJoin::ExtractJoinConditions(type, left_child, right_child, std::move(condition), conditions,\n-\t                                             arbitrary_expressions);\n-\treturn LogicalComparisonJoin::CreateJoin(type, reftype, std::move(left_child), std::move(right_child),\n+\tLogicalComparisonJoin::ExtractJoinConditions(context, type, left_child, right_child, std::move(condition),\n+\t                                             conditions, arbitrary_expressions);\n+\treturn LogicalComparisonJoin::CreateJoin(context, type, reftype, std::move(left_child), std::move(right_child),\n \t                                         std::move(conditions), std::move(arbitrary_expressions));\n }\n \n@@ -297,7 +310,7 @@ unique_ptr<LogicalOperator> Binder::CreatePlan(BoundJoinRef &ref) {\n \t}\n \n \t// now create the join operator from the join condition\n-\tauto result = LogicalComparisonJoin::CreateJoin(ref.type, ref.ref_type, std::move(left), std::move(right),\n+\tauto result = LogicalComparisonJoin::CreateJoin(context, ref.type, ref.ref_type, std::move(left), std::move(right),\n \t                                                std::move(ref.condition));\n \n \toptional_ptr<LogicalOperator> join;\n",
  "test_patch": "diff --git a/test/sql/join/left_outer/test_left_join_on_true.test b/test/sql/join/left_outer/test_left_join_on_true.test\nnew file mode 100644\nindex 000000000000..f8554ddc8458\n--- /dev/null\n+++ b/test/sql/join/left_outer/test_left_join_on_true.test\n@@ -0,0 +1,124 @@\n+# name: test/sql/join/left_outer/test_left_join_on_true.test\n+# description: Test ON TRUE join conditions\n+# group: [left_outer]\n+\n+query II\n+WITH t AS (\n+  SELECT 1 AS r, [{n:1}, {n:2}] AS s\n+  UNION\n+  SELECT 2 AS r, [{n:3}, {n:4}] AS s\n+)\n+SELECT r, s1.s.n FROM t\n+LEFT JOIN UNNEST(s) AS s1(s) ON TRUE\n+ORDER BY 1, 2\n+----\n+1\t1\n+1\t2\n+2\t3\n+2\t4\n+\n+query II\n+WITH t AS (\n+  SELECT 1 AS r, ARRAY[1, 2, 3] AS a\n+  UNION SELECT 2 AS r, ARRAY[4] AS a\n+  UNION SELECT 4 AS r, ARRAY[] AS a\n+)\n+SELECT r, a.value\n+FROM t\n+LEFT JOIN UNNEST(a) AS a(value) ON TRUE\n+ORDER BY 1, 2\n+----\n+1\t1\n+1\t2\n+1\t3\n+2\t4\n+4\tNULL\n+\n+# more than one condition\n+\n+query II\n+WITH t AS (\n+  SELECT 1 AS r, ARRAY[1, 2, 3] AS a\n+  UNION SELECT 2 AS r, ARRAY[4] AS a\n+  UNION SELECT 4 AS r, ARRAY[]::INTEGER[] AS a\n+)\n+SELECT r, a.value\n+FROM t\n+LEFT JOIN UNNEST(a) AS a(value) ON TRUE AND a.value IS NULL\n+ORDER BY 1, 2\n+----\n+1\tNULL\n+2\tNULL\n+4\tNULL\n+\n+query II\n+WITH t AS (\n+  SELECT 1 AS r, ARRAY[1, 2, 3] AS a\n+  UNION SELECT 2 AS r, ARRAY[4] AS a\n+  UNION SELECT 4 AS r, ARRAY[] AS a\n+)\n+SELECT r, a.value\n+FROM t\n+LEFT JOIN UNNEST(a) AS a(value) ON (1 = 1) AND TRUE AND list_contains([2, 3], 2)\n+ORDER BY 1, 2\n+----\n+1\t1\n+1\t2\n+1\t3\n+2\t4\n+4\tNULL\n+\n+# non-true constant expressions cause a binder error\n+\n+statement error\n+WITH t AS (\n+  SELECT 1 AS r, [{n:1}, {n:2}] AS s\n+  UNION\n+  SELECT 2 AS r, [{n:3}, {n:4}] AS s\n+)\n+SELECT r, s1.s.n FROM t\n+LEFT JOIN UNNEST(s) AS s1(s) ON FALSE\n+----\n+Binder Error: Join condition for non-inner LATERAL JOIN must be a comparison between the left and right side\n+\n+# test non-lateral left joins\n+\n+statement ok\n+CREATE TABLE integers(i INTEGER, j INTEGER)\n+\n+statement ok\n+INSERT INTO integers VALUES (1, 2), (2, 3), (3, 4)\n+\n+statement ok\n+CREATE TABLE integers2(k INTEGER, l INTEGER)\n+\n+statement ok\n+INSERT INTO integers2 VALUES (1, 10), (2, 20)\n+\n+query IIII\n+SELECT * FROM integers LEFT OUTER JOIN integers2 ON TRUE AND integers.i=integers2.k AND TRUE ORDER BY i\n+----\n+1\t2\t1\t10\n+2\t3\t2\t20\n+3\t4\tNULL\tNULL\n+\n+query IIII\n+SELECT * FROM integers LEFT OUTER JOIN integers2 ON TRUE AND integers.i=integers2.k AND FALSE ORDER BY i\n+----\n+1\t2\tNULL\tNULL\n+2\t3\tNULL\tNULL\n+3\t4\tNULL\tNULL\n+\n+# this is just a cross product\n+\n+query IIII\n+SELECT * FROM integers LEFT OUTER JOIN integers2 ON TRUE ORDER BY i\n+----\n+1\t2\t1\t10\n+1\t2\t2\t20\n+2\t3\t1\t10\n+2\t3\t2\t20\n+3\t4\t1\t10\n+3\t4\t2\t20\n+\n+\ndiff --git a/test/sql/subquery/lateral/pg_lateral.test b/test/sql/subquery/lateral/pg_lateral.test\nindex 35b92b5a3944..f5b435392d6f 100644\n--- a/test/sql/subquery/lateral/pg_lateral.test\n+++ b/test/sql/subquery/lateral/pg_lateral.test\n@@ -315,7 +315,7 @@ where ss1.c2 = 0;\n \n mode unskip\n \n-statement error\n+query IIII\n select i8.*, ss.v, t.unique2\n   from int8_tbl i8\n     left join int4_tbl i4 on i4.f1 = 1\n@@ -323,7 +323,7 @@ select i8.*, ss.v, t.unique2\n     left join tenk1 t on t.unique2 = ss.v\n where q2 = 456;\n ----\n-Join condition for non-inner LATERAL JOIN must be a comparison\n+123\t456\tNULL\tNULL\n \n query II\n select unique2, x.*\n@@ -337,11 +337,15 @@ from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;\n ----\n 9998\t0\n \n-statement error\n+query II\n select unique2, x.*\n from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;\n ----\n-Join condition for non-inner LATERAL JOIN must be a comparison\n+9998\t0\n+NULL\t123456\n+NULL\t-123456\n+NULL\t2147483647\n+NULL\t-2147483647\n \n # FIXME: INTERNAL Error: Logical operator type \"DELIM_JOIN\" for dependent join\n mode skip\n",
  "problem_statement": "LEFT JOIN UNNEST() requires an ON clause\n### What happens?\n\nSometimes you want to UNNEST with a LEFT JOIN.  Currently you have to provide an ON clause in order to do this.  I have a hacky workaround that I would like to remove.\r\n\r\n\n\n### To Reproduce\n\n```\r\nwith t as (\r\n  select \r\n    1 as r, \r\n    [\r\n      {n:1},\r\n      {n:2}\r\n    ] as s\r\n  union   select \r\n    2 as r, \r\n    [\r\n      {n:3},\r\n      {n:4}\r\n    ] as s\r\n     \r\n)\r\nselect r, s1.s.n from t\r\nLEFT JOIN UNNEST(s) as s1(s)\r\n```\n\n### OS:\n\nlinux\n\n### DuckDB Version:\n\ncurrent\n\n### DuckDB Client:\n\nweb shell\n\n### Full Name:\n\nlloyd tabb\n\n### Affiliation:\n\ngoogle\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Here are the basic permutation I think are interesting.  Assume a table with two columns, a scalar and an array.\r\n\r\n```\r\nwith t as (\r\n  SELECT 1 as r, ARRAY[1,2,3] as a\r\n  UNION SELECT 2 as r, ARRAY[4] as a\r\n  UNION SELECT 3 as r, NULL as a\r\n)\r\nSELECT r, a.value\r\nFROM t \r\n, UNNEST(a) as a(value)\r\n```\r\nReturns no results.  UNNEST(NULL) basically eats everything.  Maybe this is should be an error.  (I think it is in BigQuery).\r\n\r\nThe Query below is  an inner join and eliminates row where r=4.\r\n```\r\nwith t as (\r\n  SELECT 1 as r, ARRAY[1,2,3] as a\r\n  UNION SELECT 2 as r, ARRAY[4] as a\r\n  UNION SELECT 4 as r, [] as a\r\n)\r\nSELECT r, a.value\r\nFROM t \r\n, UNNEST(a) as a(value)\r\n```\r\n\r\n```\r\n{\"r\":1,\"value\":3}\r\n{\"r\":2,\"value\":4}\r\n{\"r\":1,\"value\":2}\r\n{\"r\":1,\"value\":1}\r\n```\r\n\r\nWe get an error without an ON clause but the behaviour is a left join (the r=4 is retained) \r\n```\r\nwith t as (\r\n  SELECT 1 as r, ARRAY[1,2,3] as a\r\n  UNION SELECT 2 as r, ARRAY[4] as a\r\n  UNION SELECT 4 as r, [] as a\r\n)\r\nSELECT r, a.value\r\nFROM t \r\nLEFT JOIN UNNEST(a) as a(value) \r\n   ON a.value is NULL or a.value IS NOT NULL\r\n```\r\n\r\nr | value\r\n-- | --\r\n2 | 4\r\n1 | 3\r\n1 | 2\r\n1 | 1\r\n4 | NULL\r\n\r\n\r\n\r\n",
  "created_at": "2023-06-05T07:55:59Z"
}