{
  "repo": "duckdb/duckdb",
  "pull_number": 13462,
  "instance_id": "duckdb__duckdb-13462",
  "issue_numbers": [
    "13429"
  ],
  "base_commit": "e1568a2981c0f0ec86f322848a8bddb36e81e1d1",
  "patch": "diff --git a/src/include/duckdb/main/client_context.hpp b/src/include/duckdb/main/client_context.hpp\nindex b7aa81fc3cf6..c03e38ae0636 100644\n--- a/src/include/duckdb/main/client_context.hpp\n+++ b/src/include/duckdb/main/client_context.hpp\n@@ -94,6 +94,7 @@ class ClientContext : public enable_shared_from_this<ClientContext> {\n \n \t//! Interrupt execution of a query\n \tDUCKDB_API void Interrupt();\n+\tDUCKDB_API void CancelTransaction();\n \n \t//! Enable query profiling\n \tDUCKDB_API void EnableProfiling();\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex f98ee9753f32..a413a4ef0812 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -1030,6 +1030,11 @@ void ClientContext::Interrupt() {\n \tinterrupted = true;\n }\n \n+void ClientContext::CancelTransaction() {\n+\tauto lock = LockContext();\n+\tInitialCleanup(*lock);\n+}\n+\n void ClientContext::EnableProfiling() {\n \tauto lock = LockContext();\n \tauto &client_config = ClientConfig::GetConfig(*this);\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 05586c7c4d80..8fffa355fce3 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -376,8 +376,7 @@ DuckDBPyConnection::RegisterScalarUDF(const string &name, const py::function &ud\n \tauto &context = *connection.context;\n \n \tif (context.transaction.HasActiveTransaction()) {\n-\t\tthrow InvalidInputException(\n-\t\t    \"This function can not be called with an active transaction!, commit or abort the existing one first\");\n+\t\tcontext.CancelTransaction();\n \t}\n \tif (registered_functions.find(name) != registered_functions.end()) {\n \t\tthrow NotImplementedException(\"A function by the name of '%s' is already created, creating multiple \"\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/udf/test_scalar.py b/tools/pythonpkg/tests/fast/udf/test_scalar.py\nindex 65f38bb2f864..5a13b1e2dedd 100644\n--- a/tools/pythonpkg/tests/fast/udf/test_scalar.py\n+++ b/tools/pythonpkg/tests/fast/udf/test_scalar.py\n@@ -291,19 +291,9 @@ def func(x: int) -> int:\n         # Using fetchone keeps the result open, with a transaction\n         rel.fetchone()\n \n-        # If we would allow a UDF to be created when a transaction is active\n-        # then starting a new result-fetch would cancel the transaction\n-        # which would corrupt our internal mechanism used to check if a UDF is already registered\n-        # because that isn't transaction-aware\n-        with pytest.raises(\n-            duckdb.InvalidInputException,\n-            match='This function can not be called with an active transaction!, commit or abort the existing one first',\n-        ):\n-            con.create_function('func', func)\n+        con.create_function('func', func)\n \n-        # This would cancel the previous transaction, causing the function to no longer exist\n         rel.fetchall()\n \n-        con.create_function('func', func)\n         res = con.sql('select func(5)').fetchall()\n         assert res == [(5,)]\ndiff --git a/tools/pythonpkg/tests/fast/udf/test_transactionality.py b/tools/pythonpkg/tests/fast/udf/test_transactionality.py\nnew file mode 100644\nindex 000000000000..50286e8eb4ba\n--- /dev/null\n+++ b/tools/pythonpkg/tests/fast/udf/test_transactionality.py\n@@ -0,0 +1,18 @@\n+import duckdb\n+import pytest\n+\n+\n+class TestUDFTransactionality(object):\n+    @pytest.mark.xfail(reason='fetchone() does not realize the stream result was closed before completion')\n+    def test_type_coverage(self, duckdb_cursor):\n+        rel = duckdb_cursor.sql(\"select * from range(4096)\")\n+        res = rel.fetchone()\n+        assert res == (0,)\n+\n+        def my_func(x: str) -> int:\n+            return int(x)\n+\n+        duckdb_cursor.create_function('test', my_func)\n+\n+        with pytest.raises(duckdb.InvalidInputException, match='result closed'):\n+            res = rel.fetchone()\n",
  "problem_statement": "create_function -> Invalid Input Error: This function can not be called with an active transaction!, commit or abort the existing one first\n### What happens?\r\n\r\n  ```\r\nconn = duckdb.connect(database=':memory:')\r\nconn.execute(f\"SELECT installed,loaded FROM duckdb_extensions() ;\").fetchone()   \r\nconn.create_function(\"line_3point_min_angle\",CheckUdf.line_3point_min_angle )\r\n```\r\nbefore create_function,fetchone will be error \r\n`    conn.create_function(attr_name, attr_value,\r\nduckdb.duckdb.InvalidInputException: Invalid Input Error: This function can not be called with an active transaction!, commit or abort the existing one first`\r\n\r\nbut fetchall()  not error\r\n```\r\n conn = duckdb.connect(database=':memory:')\r\nconn.execute(f\"SELECT installed,loaded FROM duckdb_extensions() ;\").fetchall()\r\nconn.create_function(\"line_3point_min_angle\",CheckUdf.line_3point_min_angle )\r\n\r\n```\r\n\r\n\r\n\r\n### To Reproduce\r\n\r\n```\r\n    conn = duckdb.connect(database=':memory:')\r\n    conn.execute(f\"SELECT installed,loaded FROM duckdb_extensions() ;\").fetchone()\r\n    conn.create_function(CheckUdf.line_3point_min_angle, \"line_3point_min_angle\")\r\n```\r\nfetchone() then create_function will be error\r\n```\r\nconn.create_function(attr_name, attr_value,\r\nduckdb.duckdb.InvalidInputException: Invalid Input Error: This function can not be called with an active transaction!, commit or abort the existing one first\r\n\r\n```\r\nbut fetchall() not error\r\n```\r\n    conn = duckdb.connect(database=':memory:')\r\n    conn.execute(f\"SELECT installed,loaded FROM duckdb_extensions() ;\").fetchall()\r\n    conn.create_function(CheckUdf.line_3point_min_angle, \"line_3point_min_angle\")\r\n```\r\n\r\n### OS:\r\n\r\nMACOS\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0\r\n\r\n### DuckDB Client:\r\n\r\npython\r\n\r\n### Full Name:\r\n\r\ns\r\n\r\n### Affiliation:\r\n\r\nl\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Fetchone() creates a stream, an active query execution which is wrapped in a transaction.\r\n\r\nPerhaps we should just cancel the active query execution + transaction instead of letting this fail",
  "created_at": "2024-08-19T08:18:55Z"
}