diff --git a/tools/pythonpkg/tests/fast/udf/test_scalar.py b/tools/pythonpkg/tests/fast/udf/test_scalar.py
index 65f38bb2f864..5a13b1e2dedd 100644
--- a/tools/pythonpkg/tests/fast/udf/test_scalar.py
+++ b/tools/pythonpkg/tests/fast/udf/test_scalar.py
@@ -291,19 +291,9 @@ def func(x: int) -> int:
         # Using fetchone keeps the result open, with a transaction
         rel.fetchone()
 
-        # If we would allow a UDF to be created when a transaction is active
-        # then starting a new result-fetch would cancel the transaction
-        # which would corrupt our internal mechanism used to check if a UDF is already registered
-        # because that isn't transaction-aware
-        with pytest.raises(
-            duckdb.InvalidInputException,
-            match='This function can not be called with an active transaction!, commit or abort the existing one first',
-        ):
-            con.create_function('func', func)
+        con.create_function('func', func)
 
-        # This would cancel the previous transaction, causing the function to no longer exist
         rel.fetchall()
 
-        con.create_function('func', func)
         res = con.sql('select func(5)').fetchall()
         assert res == [(5,)]
diff --git a/tools/pythonpkg/tests/fast/udf/test_transactionality.py b/tools/pythonpkg/tests/fast/udf/test_transactionality.py
new file mode 100644
index 000000000000..50286e8eb4ba
--- /dev/null
+++ b/tools/pythonpkg/tests/fast/udf/test_transactionality.py
@@ -0,0 +1,18 @@
+import duckdb
+import pytest
+
+
+class TestUDFTransactionality(object):
+    @pytest.mark.xfail(reason='fetchone() does not realize the stream result was closed before completion')
+    def test_type_coverage(self, duckdb_cursor):
+        rel = duckdb_cursor.sql("select * from range(4096)")
+        res = rel.fetchone()
+        assert res == (0,)
+
+        def my_func(x: str) -> int:
+            return int(x)
+
+        duckdb_cursor.create_function('test', my_func)
+
+        with pytest.raises(duckdb.InvalidInputException, match='result closed'):
+            res = rel.fetchone()
