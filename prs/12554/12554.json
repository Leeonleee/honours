{
  "repo": "duckdb/duckdb",
  "pull_number": 12554,
  "instance_id": "duckdb__duckdb-12554",
  "issue_numbers": [
    "12552"
  ],
  "base_commit": "99765415d276e0a12cad86c3ecca14c484c9b8e1",
  "patch": "diff --git a/src/execution/operator/persistent/physical_insert.cpp b/src/execution/operator/persistent/physical_insert.cpp\nindex 25ab481927c3..64c706b83eb9 100644\n--- a/src/execution/operator/persistent/physical_insert.cpp\n+++ b/src/execution/operator/persistent/physical_insert.cpp\n@@ -446,10 +446,18 @@ SinkResultType PhysicalInsert::Sink(ExecutionContext &context, DataChunk &chunk,\n \t\t\tgstate.initialized = true;\n \t\t}\n \n-\t\tif (return_chunk) {\n+\t\tif (action_type != OnConflictAction::NOTHING && return_chunk) {\n+\t\t\t// If the action is UPDATE or REPLACE, we will always create either an APPEND or an INSERT\n+\t\t\t// for NOTHING we don't create either an APPEND or an INSERT for the tuple\n+\t\t\t// so it should not be added to the RETURNING chunk\n \t\t\tgstate.return_collection.Append(lstate.insert_chunk);\n \t\t}\n \t\tidx_t updated_tuples = OnConflictHandling(table, context, lstate);\n+\t\tif (action_type == OnConflictAction::NOTHING && return_chunk) {\n+\t\t\t// Because we didn't add to the RETURNING chunk yet\n+\t\t\t// we add the tuples that did not get filtered out now\n+\t\t\tgstate.return_collection.Append(lstate.insert_chunk);\n+\t\t}\n \t\tgstate.insert_count += lstate.insert_chunk.size();\n \t\tgstate.insert_count += updated_tuples;\n \t\tstorage.LocalAppend(gstate.append_state, table, context.client, lstate.insert_chunk, true);\n",
  "test_patch": "diff --git a/test/sql/upsert/insert_or_replace/returning_nothing.test b/test/sql/upsert/insert_or_replace/returning_nothing.test\nnew file mode 100644\nindex 000000000000..44d66c19a994\n--- /dev/null\n+++ b/test/sql/upsert/insert_or_replace/returning_nothing.test\n@@ -0,0 +1,31 @@\n+# name: test/sql/upsert/insert_or_replace/returning_nothing.test\n+# group: [insert_or_replace]\n+\n+statement ok\n+CREATE SEQUENCE seq START 1;\n+\n+statement ok\n+CREATE TABLE bug (\n+\tid INTEGER PRIMARY KEY DEFAULT NEXTVAL('seq'),\n+\tname VARCHAR\n+);\n+\n+statement ok\n+CREATE UNIQUE INDEX idx ON bug (name);\n+\n+query I\n+INSERT OR IGNORE INTO bug VALUES\n+\t(DEFAULT, 'toto') RETURNING(id);\n+----\n+1\n+\n+query I\n+INSERT OR IGNORE INTO bug VALUES\n+\t(DEFAULT, 'toto') RETURNING(id);\n+----\n+\n+query I\n+INSERT OR IGNORE INTO bug VALUES\n+\t(DEFAULT, 'toto'), (DEFAULT, 'yoyo') RETURNING(id);\n+----\n+4\n",
  "problem_statement": "Insert on conflict always returning nextval of primary key sequence\n### What happens?\r\n\r\nI created a table that uses a sequence for its primary key. When I insert a row with a conflict, the returned value is the next value of the sequence, not the primary key of the row.\r\n\r\n### To Reproduce\r\n\r\nTo reproduce, just paste this into the CLI:\r\n\r\n```sql\r\nCREATE SEQUENCE test_id_sequence START 1;\r\n\r\nCREATE OR REPLACE TABLE test (\r\n    id    INTEGER PRIMARY KEY DEFAULT nextval('test_id_sequence'),\r\n    value VARCHAR NOT NULL UNIQUE\r\n);\r\n\r\nINSERT INTO test (value) values ('abc') RETURNING id;\r\nINSERT INTO test (value) values ('abc') ON CONFLICT (value) DO NOTHING RETURNING id;\r\n```\r\n\r\nActual output:\r\n```\r\n./duckdb test.db\r\nv1.0.0 1f98600c2c\r\nEnter \".help\" for usage hints.\r\nD CREATE SEQUENCE test_id_sequence START 1;\r\nD \r\nD CREATE OR REPLACE TABLE test (\r\n      id    INTEGER PRIMARY KEY DEFAULT nextval('test_id_sequence'),\r\n      value VARCHAR NOT NULL UNIQUE\r\n  );\r\nD \r\nD INSERT INTO test (value) values ('abc') RETURNING id;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  id   \u2502\r\n\u2502 int32 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD \r\nD \r\nD INSERT INTO test (value) values ('abc') ON CONFLICT (value) DO NOTHING RETURNING id;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  id   \u2502\r\n\u2502 int32 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD \r\n```\r\n\r\nI expect that last `2` to be `1` as the row has not changed.\r\n\r\nTesting with the latest nightly python module produces the same result.\r\n\r\n### OS:\r\n\r\nUbuntu 20.04\r\n\r\n### DuckDB Version:\r\n\r\nv1.0.0 1f98600c2c\r\n\r\n### DuckDB Client:\r\n\r\nPython and CLI\r\n\r\n### Full Name:\r\n\r\nAndy Murdoch\r\n\r\n### Affiliation:\r\n\r\nmaxmine.com.au\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a nightly build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Is this not the exact same issue as <https://github.com/duckdb/duckdb/issues/12540> raised 2 days ago?",
  "created_at": "2024-06-16T15:18:11Z"
}