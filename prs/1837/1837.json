{
  "repo": "duckdb/duckdb",
  "pull_number": 1837,
  "instance_id": "duckdb__duckdb-1837",
  "issue_numbers": [
    "1834"
  ],
  "base_commit": "4867ff33a30e112c75683409b33cc51952ab68e8",
  "patch": "diff --git a/src/include/duckdb/storage/table/row_group.hpp b/src/include/duckdb/storage/table/row_group.hpp\nindex 081eae5b6f7f..51bb992cbfd2 100644\n--- a/src/include/duckdb/storage/table/row_group.hpp\n+++ b/src/include/duckdb/storage/table/row_group.hpp\n@@ -110,7 +110,7 @@ class RowGroup : public SegmentBase {\n \tvoid RevertAppend(idx_t start);\n \n \t//! Delete the given set of rows in the version manager\n-\tvoid Delete(Transaction &transaction, DataTable *table, Vector &row_ids, idx_t count);\n+\tvoid Delete(Transaction &transaction, DataTable *table, row_t *row_ids, idx_t count);\n \n \tRowGroupPointer Checkpoint(TableDataWriter &writer, vector<unique_ptr<BaseStatistics>> &global_stats);\n \tstatic void Serialize(RowGroupPointer &pointer, Serializer &serializer);\ndiff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp\nindex 8570a506e6ab..6ab0659e01e1 100644\n--- a/src/storage/data_table.cpp\n+++ b/src/storage/data_table.cpp\n@@ -758,8 +758,28 @@ void DataTable::Delete(TableCatalogEntry &table, ClientContext &context, Vector\n \t\t// deletion is in transaction-local storage: push delete into local chunk collection\n \t\ttransaction.storage.Delete(this, row_identifiers, count);\n \t} else {\n-\t\tauto row_group = (RowGroup *)row_groups->GetSegment(first_id);\n-\t\trow_group->Delete(transaction, this, row_identifiers, count);\n+\t\t// delete is in the row groups\n+\t\t// we need to figure out for each id to which row group it belongs\n+\t\t// usually all (or many) ids belong to the same row group\n+\t\t// we iterate over the ids and check for every id if it belongs to the same row group as their predecessor\n+\t\tidx_t pos = 0;\n+\t\tdo {\n+\t\t\tidx_t start = pos;\n+\t\t\tauto row_group = (RowGroup *)row_groups->GetSegment(ids[pos]);\n+\t\t\tfor (pos++; pos < count; pos++) {\n+\t\t\t\tD_ASSERT(ids[pos] >= 0);\n+\t\t\t\t// check if this id still belongs to this row group\n+\t\t\t\tif (idx_t(ids[pos]) < row_group->start) {\n+\t\t\t\t\t// id is before row_group start -> it does not\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tif (idx_t(ids[pos]) >= row_group->start + row_group->count) {\n+\t\t\t\t\t// id is after row group end -> it does not\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\trow_group->Delete(transaction, this, ids + start, pos - start);\n+\t\t} while (pos < count);\n \t}\n }\n \ndiff --git a/src/storage/table/row_group.cpp b/src/storage/table/row_group.cpp\nindex 5f92e508634b..54e49c78fd6e 100644\n--- a/src/storage/table/row_group.cpp\n+++ b/src/storage/table/row_group.cpp\n@@ -710,19 +710,15 @@ class VersionDeleteState {\n \tvoid Flush();\n };\n \n-void RowGroup::Delete(Transaction &transaction, DataTable *table, Vector &row_ids, idx_t count) {\n+void RowGroup::Delete(Transaction &transaction, DataTable *table, row_t *ids, idx_t count) {\n \tlock_guard<mutex> lock(row_group_lock);\n \tVersionDeleteState del_state(*this, transaction, table, this->start);\n \n-\tVectorData rdata;\n-\trow_ids.Orrify(count, rdata);\n \t// obtain a write lock\n-\tauto ids = (row_t *)rdata.data;\n \tfor (idx_t i = 0; i < count; i++) {\n-\t\tauto ridx = rdata.sel->get_index(i);\n-\t\tD_ASSERT(ids[ridx] >= 0);\n-\t\tD_ASSERT(idx_t(ids[ridx]) >= this->start && idx_t(ids[ridx]) < this->start + this->count);\n-\t\tdel_state.Delete(ids[ridx] - this->start);\n+\t\tD_ASSERT(ids[i] >= 0);\n+\t\tD_ASSERT(idx_t(ids[i]) >= this->start && idx_t(ids[i]) < this->start + this->count);\n+\t\tdel_state.Delete(ids[i] - this->start);\n \t}\n \tdel_state.Flush();\n }\n",
  "test_patch": "diff --git a/test/sql/delete/test_issue_1834.test_slow b/test/sql/delete/test_issue_1834.test_slow\nnew file mode 100644\nindex 000000000000..e9eda99e7442\n--- /dev/null\n+++ b/test/sql/delete/test_issue_1834.test_slow\n@@ -0,0 +1,26 @@\n+# name: test/sql/delete/test_issue_1834.test_slow\n+# description: Deleting with DELETE USING causes a segmentation fault\n+# group: [delete]\n+\n+require httpfs\n+\n+statement ok\n+CREATE TABLE Person_likes_Comment (creationDate timestamp without time zone not null, id bigint not null, likes_Comment bigint not null);\n+\n+statement ok\n+CREATE TABLE Person_Delete_candidates (deletionDate timestamp without time zone not null, id bigint);\n+\n+statement ok\n+COPY Person_likes_Comment FROM 'https://github.com/cwida/duckdb-data/releases/download/v1.0/Person_likes_Comment.csv' (DELIMITER '|', TIMESTAMPFORMAT '%Y-%m-%dT%H:%M:%S.%g+00:00');\n+\n+statement ok\n+COPY Person_Delete_candidates FROM 'https://github.com/cwida/duckdb-data/releases/download/v1.0/Person_Delete_candidates.csv' (DELIMITER '|', HEADER, TIMESTAMPFORMAT '%Y-%m-%dT%H:%M:%S.%g+00:00');\n+\n+statement ok\n+DELETE FROM Person_likes_Comment USING Person_Delete_candidates WHERE Person_Delete_candidates.id = Person_likes_Comment.id;\n+\n+# all tuples fulfilling this predicate should have been deleted\n+query I\n+SELECT COUNT(*) FROM Person_likes_Comment, Person_Delete_candidates WHERE Person_Delete_candidates.id = Person_likes_Comment.id;\n+----\n+0\n",
  "problem_statement": "Deleting with DELETE USING causes a segmentation fault\n**What does happen?**\r\nI am performing deletes with the `DELETE ... USING ...` (#1659) command. In some cases, it returns with a segmentation fault.\r\n\r\nI have also seen a few `Conflict on tuple deletion!` but the root cause of the two seems to be the same (sometimes, running the same script multiple times returns either a segfault or a conflict).\r\n\r\n**What should happen?**\r\nThe system should perform the delete operation on the tuples matching the condition.\r\n\r\n**To Reproduce**\r\n1. Grab the archive containing the data and the script  from https://surfdrive.surf.nl/files/index.php/s/VA92agRErNV2EJl\r\n2. Run the SQL script:\r\n   ```bash\r\n   cat delete-segfault-mwe.sql | sed \"s#PATHVAR#`pwd`/data#\" | duckdb\r\n   ```\r\n\r\n    It returns a `Segmentation fault (core dumped)`\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Fedora 34\r\n - DuckDB Version: 0.2.6, master (979f14ed48b865e0f775b2898640757b6302f4e7)\r\n\r\nThe content of the SQL script is the following:\r\n```sql\r\nCREATE TABLE Person_likes_Comment (creationDate timestamp without time zone not null, id bigint not null, likes_Comment bigint not null);\r\nCREATE TABLE Person_Delete_candidates (deletionDate timestamp without time zone not null, id bigint);\r\n\r\nCOPY Person_likes_Comment FROM 'PATHVAR/Person_likes_Comment.csv' (DELIMITER '|', TIMESTAMPFORMAT '%Y-%m-%dT%H:%M:%S.%g+00:00');\r\nCOPY Person_Delete_candidates FROM 'PATHVAR/Person_Delete_candidates.csv' (DELIMITER '|', HEADER, TIMESTAMPFORMAT '%Y-%m-%dT%H:%M:%S.%g+00:00');\r\n\r\nDELETE FROM Person_likes_Comment USING Person_Delete_candidates WHERE Person_Delete_candidates.id = Person_likes_Comment.id;\r\n```\r\n\r\nThe following query returns the tuples that should be deleted from the `Person_likes_Comment` (showing that there are no duplicates):\r\n```sql\r\nSELECT Person_likes_comment.* FROM Person_likes_Comment, Person_Delete_candidates WHERE Person_Delete_candidates.id = Person_likes_Comment.id;\r\n```\r\n\n",
  "hints_text": "I got the \"Conflict on tuple deletion!\" error too. It was because a row got more than one match in the join. A different check should be needed, such as a join where a row cannot have more than one match. In MonetDB it's a single join.\nThanks for looking into it.\r\n\r\n> It was because a row got more than one match in the join.\r\n\r\nI think `USING` should support that based on the example in https://www.postgresql.org/docs/13/sql-delete.html:\r\n\r\n```sql\r\nDELETE FROM films USING producers\r\n  WHERE producer_id = producers.id AND producers.name = 'foo';\r\n```\r\n\r\nInterestingly, if I turn the join into a selection, it works:\r\n\r\n```sql\r\nDELETE FROM Person_likes_Comment USING Person_Delete_candidates WHERE Person_likes_Comment.id = 26388279076874;\r\n```\r\n\nI ran it in `gdb` and there it reliably produces the `TransactionContext Error: Conflict on tuple deletion!` message.\r\n```\r\n$ gdb --args ./build/reldebug/test/unittest test/delete-using-segfault.test\r\n```\r\n```\r\n[Thread debugging using libthread_db enabled]\r\nUsing host libthread_db library \"/lib64/libthread_db.so.1\".\r\n[0/1] (0%): test/delete-using-segfault.test                                     \r\n================================================================================\r\nQuery unexpectedly failed! (test/delete-using-segfault.test:15)!\r\n================================================================================\r\nSQL Query\r\nDELETE FROM Person_likes_Comment USING Person_Delete_candidates WHERE Person_Delete_candidates.id = Person_likes_Comment.id;\r\n================================================================================\r\nTransactionContext Error: Conflict on tuple deletion!\r\n```",
  "created_at": "2021-06-03T07:22:20Z"
}