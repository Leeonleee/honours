{
  "repo": "duckdb/duckdb",
  "pull_number": 11745,
  "instance_id": "duckdb__duckdb-11745",
  "issue_numbers": [
    "11116"
  ],
  "base_commit": "1a3ed8fd1283aa06a9bbea242fa26f7e05884008",
  "patch": "diff --git a/src/core_functions/scalar/map/map_entries.cpp b/src/core_functions/scalar/map/map_entries.cpp\nindex 7629c7896227..47e6539938ec 100644\n--- a/src/core_functions/scalar/map/map_entries.cpp\n+++ b/src/core_functions/scalar/map/map_entries.cpp\n@@ -12,7 +12,15 @@ namespace duckdb {\n static void MapEntriesFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tauto count = args.size();\n \n-\tMapUtil::ReinterpretMap(result, args.data[0], count);\n+\tauto &map = args.data[0];\n+\tif (map.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\t// Input is a constant NULL\n+\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\t\tConstantVector::SetNull(result, true);\n+\t\treturn;\n+\t}\n+\n+\tMapUtil::ReinterpretMap(result, map, count);\n \n \tif (args.AllConstant()) {\n \t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n@@ -20,10 +28,20 @@ static void MapEntriesFunction(DataChunk &args, ExpressionState &state, Vector &\n \tresult.Verify(count);\n }\n \n-static unique_ptr<FunctionData> MapEntriesBind(ClientContext &context, ScalarFunction &bound_function,\n-                                               vector<unique_ptr<Expression>> &arguments) {\n+static LogicalType CreateReturnType(const LogicalType &map) {\n+\tauto &key_type = MapType::KeyType(map);\n+\tauto &value_type = MapType::ValueType(map);\n+\n \tchild_list_t<LogicalType> child_types;\n+\tchild_types.push_back(make_pair(\"key\", key_type));\n+\tchild_types.push_back(make_pair(\"value\", value_type));\n+\n+\tauto row_type = LogicalType::STRUCT(child_types);\n+\treturn LogicalType::LIST(row_type);\n+}\n \n+static unique_ptr<FunctionData> MapEntriesBind(ClientContext &context, ScalarFunction &bound_function,\n+                                               vector<unique_ptr<Expression>> &arguments) {\n \tif (arguments.size() != 1) {\n \t\tthrow InvalidInputException(\"Too many arguments provided, only expecting a single map\");\n \t}\n@@ -36,25 +54,24 @@ static unique_ptr<FunctionData> MapEntriesBind(ClientContext &context, ScalarFun\n \t\treturn nullptr;\n \t}\n \n+\tif (map.id() == LogicalTypeId::SQLNULL) {\n+\t\t// Input is NULL, output is STRUCT(NULL, NULL)[]\n+\t\tauto map_type = LogicalType::MAP(LogicalTypeId::SQLNULL, LogicalTypeId::SQLNULL);\n+\t\tbound_function.return_type = CreateReturnType(map_type);\n+\t\treturn make_uniq<VariableReturnBindData>(bound_function.return_type);\n+\t}\n+\n \tif (map.id() != LogicalTypeId::MAP) {\n \t\tthrow InvalidInputException(\"The provided argument is not a map\");\n \t}\n-\tauto &key_type = MapType::KeyType(map);\n-\tauto &value_type = MapType::ValueType(map);\n-\n-\tchild_types.push_back(make_pair(\"key\", key_type));\n-\tchild_types.push_back(make_pair(\"value\", value_type));\n-\n-\tauto row_type = LogicalType::STRUCT(child_types);\n-\n-\tbound_function.return_type = LogicalType::LIST(row_type);\n+\tbound_function.return_type = CreateReturnType(map);\n \treturn make_uniq<VariableReturnBindData>(bound_function.return_type);\n }\n \n ScalarFunction MapEntriesFun::GetFunction() {\n \t//! the arguments and return types are actually set in the binder function\n \tScalarFunction fun({}, LogicalTypeId::LIST, MapEntriesFunction, MapEntriesBind);\n-\tfun.null_handling = FunctionNullHandling::DEFAULT_NULL_HANDLING;\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tfun.varargs = LogicalType::ANY;\n \treturn fun;\n }\ndiff --git a/src/core_functions/scalar/map/map_extract.cpp b/src/core_functions/scalar/map/map_extract.cpp\nindex 8f6c4a8b03f5..9cf1ca1053e6 100644\n--- a/src/core_functions/scalar/map/map_extract.cpp\n+++ b/src/core_functions/scalar/map/map_extract.cpp\n@@ -70,14 +70,20 @@ void FillResult(Vector &map, Vector &offsets, Vector &result, idx_t count) {\n \t}\n }\n \n+static bool ArgumentIsConstantNull(Vector &argument) {\n+\treturn argument.GetType().id() == LogicalTypeId::SQLNULL;\n+}\n+\n static void MapExtractFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tD_ASSERT(args.data.size() == 2);\n-\tD_ASSERT(args.data[0].GetType().id() == LogicalTypeId::MAP);\n \tresult.SetVectorType(VectorType::FLAT_VECTOR);\n \n+\tauto &map = args.data[0];\n+\tauto &key = args.data[1];\n+\n \tidx_t tuple_count = args.size();\n \t// Optimization: because keys are not allowed to be NULL, we can early-out\n-\tif (args.data[1].GetType().id() == LogicalTypeId::SQLNULL) {\n+\tif (ArgumentIsConstantNull(map) || ArgumentIsConstantNull(key)) {\n \t\t//! We don't need to look through the map if the 'key' to look for is NULL\n \t\tListVector::SetListSize(result, 0);\n \t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n@@ -87,9 +93,7 @@ static void MapExtractFunction(DataChunk &args, ExpressionState &state, Vector &\n \t\tresult.Verify(tuple_count);\n \t\treturn;\n \t}\n-\n-\tauto &map = args.data[0];\n-\tauto &key = args.data[1];\n+\tD_ASSERT(map.GetType().id() == LogicalTypeId::MAP);\n \n \tUnifiedVectorFormat map_data;\n \n@@ -124,18 +128,27 @@ static unique_ptr<FunctionData> MapExtractBind(ClientContext &context, ScalarFun\n \tif (arguments.size() != 2) {\n \t\tthrow BinderException(\"MAP_EXTRACT must have exactly two arguments\");\n \t}\n-\tif (arguments[0]->return_type.id() != LogicalTypeId::MAP) {\n+\n+\tauto &map_type = arguments[0]->return_type;\n+\tauto &input_type = arguments[1]->return_type;\n+\n+\tif (map_type.id() == LogicalTypeId::SQLNULL) {\n+\t\tbound_function.return_type = LogicalType::LIST(LogicalTypeId::SQLNULL);\n+\t\treturn make_uniq<VariableReturnBindData>(bound_function.return_type);\n+\t}\n+\n+\tif (map_type.id() != LogicalTypeId::MAP) {\n \t\tthrow BinderException(\"MAP_EXTRACT can only operate on MAPs\");\n \t}\n-\tauto &value_type = MapType::ValueType(arguments[0]->return_type);\n+\tauto &value_type = MapType::ValueType(map_type);\n \n \t//! Here we have to construct the List Type that will be returned\n \tbound_function.return_type = LogicalType::LIST(value_type);\n-\tauto key_type = MapType::KeyType(arguments[0]->return_type);\n-\tif (key_type.id() != LogicalTypeId::SQLNULL && arguments[1]->return_type.id() != LogicalTypeId::SQLNULL) {\n-\t\tbound_function.arguments[1] = MapType::KeyType(arguments[0]->return_type);\n+\tauto key_type = MapType::KeyType(map_type);\n+\tif (key_type.id() != LogicalTypeId::SQLNULL && input_type.id() != LogicalTypeId::SQLNULL) {\n+\t\tbound_function.arguments[1] = MapType::KeyType(map_type);\n \t}\n-\treturn make_uniq<VariableReturnBindData>(value_type);\n+\treturn make_uniq<VariableReturnBindData>(bound_function.return_type);\n }\n \n ScalarFunction MapExtractFun::GetFunction() {\ndiff --git a/src/core_functions/scalar/map/map_keys_values.cpp b/src/core_functions/scalar/map/map_keys_values.cpp\nindex 6c1e8efb8c57..c5578895da5b 100644\n--- a/src/core_functions/scalar/map/map_keys_values.cpp\n+++ b/src/core_functions/scalar/map/map_keys_values.cpp\n@@ -10,10 +10,16 @@ namespace duckdb {\n \n static void MapKeyValueFunction(DataChunk &args, ExpressionState &state, Vector &result,\n                                 Vector &(*get_child_vector)(Vector &)) {\n+\tauto &map = args.data[0];\n+\n \tD_ASSERT(result.GetType().id() == LogicalTypeId::LIST);\n-\tauto count = args.size();\n+\tif (map.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\t\tConstantVector::SetNull(result, true);\n+\t\treturn;\n+\t}\n \n-\tauto &map = args.data[0];\n+\tauto count = args.size();\n \tD_ASSERT(map.GetType().id() == LogicalTypeId::MAP);\n \tauto child = get_child_vector(map);\n \n@@ -60,6 +66,12 @@ static unique_ptr<FunctionData> MapKeyValueBind(ClientContext &context, ScalarFu\n \t\treturn nullptr;\n \t}\n \n+\tif (map.id() == LogicalTypeId::SQLNULL) {\n+\t\t// Input is NULL, output is NULL[]\n+\t\tbound_function.return_type = LogicalType::LIST(LogicalTypeId::SQLNULL);\n+\t\treturn make_uniq<VariableReturnBindData>(bound_function.return_type);\n+\t}\n+\n \tif (map.id() != LogicalTypeId::MAP) {\n \t\tthrow InvalidInputException(\"The provided argument is not a map\");\n \t}\n@@ -83,14 +95,14 @@ static unique_ptr<FunctionData> MapValuesBind(ClientContext &context, ScalarFunc\n ScalarFunction MapKeysFun::GetFunction() {\n \t//! the arguments and return types are actually set in the binder function\n \tScalarFunction fun({}, LogicalTypeId::LIST, MapKeysFunction, MapKeysBind);\n-\tfun.null_handling = FunctionNullHandling::DEFAULT_NULL_HANDLING;\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tfun.varargs = LogicalType::ANY;\n \treturn fun;\n }\n \n ScalarFunction MapValuesFun::GetFunction() {\n \tScalarFunction fun({}, LogicalTypeId::LIST, MapValuesFunction, MapValuesBind);\n-\tfun.null_handling = FunctionNullHandling::DEFAULT_NULL_HANDLING;\n+\tfun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;\n \tfun.varargs = LogicalType::ANY;\n \treturn fun;\n }\n",
  "test_patch": "diff --git a/test/sql/types/nested/map/test_map_entries.test b/test/sql/types/nested/map/test_map_entries.test\nindex c3202243a422..e913f931f147 100644\n--- a/test/sql/types/nested/map/test_map_entries.test\n+++ b/test/sql/types/nested/map/test_map_entries.test\n@@ -82,3 +82,28 @@ SELECT map_entries(map_from_entries(\n ));\n ----\n [{'key': a, 'value': 5}, {'key': b, 'value': 6}, {'key': x, 'value': 21}, {'key': abc, 'value': 0}]\n+\n+query I\n+select MAP_ENTRIES(MAP([],[]))\n+----\n+[]\n+\n+query I\n+select MAP_ENTRIES(MAP(NULL, NULL))\n+----\n+NULL\n+\n+query I\n+select MAP_ENTRIES(NULL)\n+----\n+NULL\n+\n+query I\n+select MAP_ENTRIES(NULL::MAP(\"NULL\", \"NULL\"))\n+----\n+NULL\n+\n+query I\n+select MAP_ENTRIES(NULL::MAP(INT, BIGINT))\n+----\n+NULL\ndiff --git a/test/sql/types/nested/map/test_map_keys.test b/test/sql/types/nested/map/test_map_keys.test\nindex 0a5b70c5f4ff..7b60efd445d3 100644\n--- a/test/sql/types/nested/map/test_map_keys.test\n+++ b/test/sql/types/nested/map/test_map_keys.test\n@@ -138,3 +138,28 @@ select map_keys(col) from filtered where idx % 2 != 0;\n ----\n [6, 3, 87, 2]\n [9, 2, 7, 5, 8, 1]\n+\n+query I\n+select MAP_KEYS(MAP([],[]))\n+----\n+[]\n+\n+query I\n+select MAP_KEYS(MAP(NULL, NULL))\n+----\n+NULL\n+\n+query I\n+select MAP_KEYS(NULL)\n+----\n+NULL\n+\n+query I\n+select MAP_KEYS(NULL::MAP(\"NULL\", \"NULL\"))\n+----\n+NULL\n+\n+query I\n+select MAP_KEYS(NULL::MAP(INT, BIGINT))\n+----\n+NULL\ndiff --git a/test/sql/types/nested/map/test_map_subscript.test b/test/sql/types/nested/map/test_map_subscript.test\nindex 8ad48d29e48b..4aa03da877d2 100644\n--- a/test/sql/types/nested/map/test_map_subscript.test\n+++ b/test/sql/types/nested/map/test_map_subscript.test\n@@ -205,3 +205,28 @@ from (SELECT a%4 as grp, list(a) as lsta, list(a) as lstb FROM range(7) tbl(a) g\n 1\t{1=1, 5=5}\t[NULL]\n 2\t{2=2, 6=6}\t[]\n 3\t{3=3}\t[]\n+\n+query I\n+select MAP_EXTRACT(MAP([],[]), NULL)\n+----\n+[]\n+\n+query I\n+select MAP_EXTRACT(MAP(NULL, NULL), NULL)\n+----\n+[]\n+\n+query I\n+select MAP_EXTRACT(NULL, NULL)\n+----\n+[]\n+\n+query I\n+select MAP_EXTRACT(NULL::MAP(\"NULL\", \"NULL\"), NULL)\n+----\n+[]\n+\n+query I\n+select MAP_EXTRACT(NULL::MAP(INT, BIGINT), NULL)\n+----\n+[]\ndiff --git a/test/sql/types/nested/map/test_map_values.test b/test/sql/types/nested/map/test_map_values.test\nindex edb10bb14aed..b3a205ad24a6 100644\n--- a/test/sql/types/nested/map/test_map_values.test\n+++ b/test/sql/types/nested/map/test_map_values.test\n@@ -143,3 +143,28 @@ select map_values(col) from filtered where idx % 2 != 0;\n ----\n [0, NULL, 5, NULL]\n [NULL, NULL, 4, 5, 6, 7]\n+\n+query I\n+select MAP_VALUES(MAP([],[]))\n+----\n+[]\n+\n+query I\n+select MAP_VALUES(MAP(NULL, NULL))\n+----\n+NULL\n+\n+query I\n+select MAP_VALUES(NULL)\n+----\n+NULL\n+\n+query I\n+select MAP_VALUES(NULL::MAP(\"NULL\", \"NULL\"))\n+----\n+NULL\n+\n+query I\n+select MAP_VALUES(NULL::MAP(INT, BIGINT))\n+----\n+NULL\ndiff --git a/test/sql/types/nested/map/test_null_map_interaction.test b/test/sql/types/nested/map/test_null_map_interaction.test\nnew file mode 100644\nindex 000000000000..f4e73f573469\n--- /dev/null\n+++ b/test/sql/types/nested/map/test_null_map_interaction.test\n@@ -0,0 +1,45 @@\n+# name: test/sql/types/nested/map/test_null_map_interaction.test\n+# group: [map]\n+\n+statement ok\n+pragma enable_verification\n+\n+query I\n+SELECT TYPEOF(MAP_KEYS(NULL::MAP(TEXT, BIGINT)));\n+----\n+VARCHAR[]\n+\n+query I\n+SELECT TYPEOF(MAP_KEYS(NULL));\n+----\n+\"NULL\"[]\n+\n+query I\n+SELECT TYPEOF(MAP_VALUES(NULL::MAP(TEXT, BIGINT)));\n+----\n+BIGINT[]\n+\n+query I\n+SELECT TYPEOF(MAP_VALUES(NULL));\n+----\n+\"NULL\"[]\n+\n+query I\n+SELECT TYPEOF(MAP_ENTRIES(NULL::MAP(TEXT, BIGINT)));\n+----\n+STRUCT(\"key\" VARCHAR, \"value\" BIGINT)[]\n+\n+query I\n+SELECT TYPEOF(MAP_ENTRIES(NULL));\n+----\n+STRUCT(\"key\" \"NULL\", \"value\" \"NULL\")[]\n+\n+query I\n+SELECT TYPEOF(MAP_EXTRACT(NULL::MAP(TEXT, BIGINT), 'a'));\n+----\n+BIGINT[]\n+\n+query I\n+SELECT TYPEOF(MAP_EXTRACT(NULL, 'a'));\n+----\n+\"NULL\"[]\n",
  "problem_statement": "`MAP_KEYS()`, `MAP_VALUES()`, `MAP_ENTRIES()` do not propagate dtypes with NULLs\n### What happens?\r\n\r\n```sql\r\nSELECT TYPEOF(MAP_KEYS(NULL::MAP(TEXT, BIGINT)));\r\n--- gives NULL, should be TEXT[]\r\nSELECT TYPEOF(MAP_VALUES(NULL::MAP(TEXT, BIGINT)));\r\n--- gives NULL, should be BIGINT[]\r\nSELECT TYPEOF(MAP_ENTRIES(NULL::MAP(TEXT, BIGINT)));\r\n--- gives NULL, should be list<struct<key: TEXT, value: BIGINT>>\r\nSELECT TYPEOF(MAP_EXTRACT(NULL::MAP(TEXT, BIGINT), 'a'));\r\n--- gives BIGINT[], as expected\r\n```\r\n\r\n### To Reproduce\r\n\r\nsee above\r\n\r\n### OS:\r\n\r\nshell.duckdb.org\r\n\r\n### DuckDB Version:\r\n\r\n0.10.0\r\n\r\n### DuckDB Client:\r\n\r\n@duckdb/duckdb-wasm@1.28.1-dev166.0\r\n\r\n### Full Name:\r\n\r\nNick Crews\r\n\r\n### Affiliation:\r\n\r\nShip Creek Group\r\n\r\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\r\n\r\nI have tested with a nightly build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "~~PR is up <https://github.com/duckdb/duckdb/pull/11730>~~\r\n\r\nNever mind this is a different issue\r\n\n```py\r\n>>> con.sql(\"select MAP_KEYS(CAST(NULL AS MAP<INT, BIGINT>))\").show()\r\n+--------------+\r\n|map_keys(NULL)|\r\n+--------------+\r\n|          NULL|\r\n+--------------+\r\n```\r\n\r\n```py\r\n>>> con.sql(\"select MAP_VALUES(CAST(NULL AS MAP<INT, BIGINT>))\").show()\r\n+----------------+\r\n|map_values(NULL)|\r\n+----------------+\r\n|            NULL|\r\n+----------------+\r\n```\r\n\r\n```py\r\n>>> con.sql(\"select typeof(MAP_VALUES(CAST(NULL AS MAP<INT, BIGINT>)))\").show()\r\n+------------------------+\r\n|typeof(map_values(NULL))|\r\n+------------------------+\r\n|           array<bigint>|\r\n+------------------------+\r\n```\r\n\r\n```py\r\n>>> con.sql(\"select typeof(MAP_VALUES(NULL))\").show()\r\n+------------------------+\r\n|typeof(map_values(NULL))|\r\n+------------------------+\r\n|             array<void>|\r\n+------------------------+\r\n```\r\n\r\n```py\r\n>>> con.sql(\"select typeof(MAP_ENTRIES(NULL))\").show()\r\n+-------------------------+\r\n|typeof(map_entries(NULL))|\r\n+-------------------------+\r\n|     array<struct<key:...|\r\n+-------------------------+\r\n```\r\n\r\n```py\r\n>>> con.sql(\"select typeof(CAST(NULL AS MAP<INT, BIGINT>)['a'])\").show()\r\n+---------------+\r\n|typeof(NULL[a])|\r\n+---------------+\r\n|         bigint|\r\n+---------------+\r\n```\r\n\r\n```py\r\n>>> con.sql(\"select CAST(NULL AS MAP<INT, BIGINT>)['a']\").show()\r\n+-------+\r\n|NULL[a]|\r\n+-------+\r\n|   NULL|\r\n+-------+\r\n```",
  "created_at": "2024-04-20T09:26:42Z"
}