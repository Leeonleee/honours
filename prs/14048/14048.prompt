You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Add tests for sha1 function
This is a followup to #13020 that adds some basic tests for the new `sha1` function, modeled after the existing tests for `sha512`.
Catalog Errors only offer one suggestion when multiple suggestions are returned with the same score
### What happens?

Consider the case where there are multiple schemas with the same matching score for a Catalog error.

```sql
create schema a;
create schema b;
create table a.foo(name text);
create table b.foo(name text);
select * from foo;
```

```
Catalog Error: Table with name foo does not exist!
Did you mean "b.foo"?
LINE 1: select * from foo;
```

There is an equally qualified match in schema `a`, but Catalog Error just presents the last match.

Here is the relevant snippet of code.

https://github.com/duckdb/duckdb/blob/45787e5f9f8bdb9dce97890c1ac7a7eb2dc3a49f/src/catalog/catalog.cpp#L639-L654

I'd suggest that the code should be changed to present all suggestions that have the same score so that the a user that has tables in multiple schemas with the same name can make the appropriate choice.

Thanks,

Rusty

### To Reproduce

```sql
create schema a;
create schema b;
create table a.foo(name text);
create table b.foo(name text);
select * from foo;
```


### OS:

Mac OS X

### DuckDB Version:

1.0.0

### DuckDB Client:

CLI

### Full Name:

Rusty Conover

### Affiliation:

self

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/catalog/catalog.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: 
3: #include "duckdb/catalog/catalog_search_path.hpp"
4: #include "duckdb/catalog/catalog_entry/list.hpp"
5: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
6: #include "duckdb/catalog/catalog_set.hpp"
7: #include "duckdb/catalog/default/default_schemas.hpp"
8: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
9: #include "duckdb/common/exception.hpp"
10: #include "duckdb/main/client_context.hpp"
11: #include "duckdb/main/client_data.hpp"
12: #include "duckdb/main/database.hpp"
13: #include "duckdb/parser/expression/function_expression.hpp"
14: #include "duckdb/main/extension_helper.hpp"
15: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
16: #include "duckdb/parser/parsed_data/create_aggregate_function_info.hpp"
17: #include "duckdb/parser/parsed_data/create_collation_info.hpp"
18: #include "duckdb/parser/parsed_data/create_copy_function_info.hpp"
19: #include "duckdb/parser/parsed_data/create_index_info.hpp"
20: #include "duckdb/parser/parsed_data/create_pragma_function_info.hpp"
21: #include "duckdb/parser/parsed_data/create_secret_info.hpp"
22: #include "duckdb/parser/parsed_data/create_scalar_function_info.hpp"
23: #include "duckdb/parser/parsed_data/create_schema_info.hpp"
24: #include "duckdb/parser/parsed_data/create_sequence_info.hpp"
25: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
26: #include "duckdb/parser/parsed_data/create_type_info.hpp"
27: #include "duckdb/parser/parsed_data/create_view_info.hpp"
28: #include "duckdb/parser/parsed_data/drop_info.hpp"
29: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
30: #include "duckdb/planner/binder.hpp"
31: #include "duckdb/catalog/default/default_types.hpp"
32: #include "duckdb/main/extension_entries.hpp"
33: #include "duckdb/main/extension/generated_extension_loader.hpp"
34: #include "duckdb/main/connection.hpp"
35: #include "duckdb/main/attached_database.hpp"
36: #include "duckdb/main/database_manager.hpp"
37: #include "duckdb/function/built_in_functions.hpp"
38: #include "duckdb/catalog/similar_catalog_entry.hpp"
39: #include "duckdb/storage/database_size.hpp"
40: #include <algorithm>
41: 
42: namespace duckdb {
43: 
44: Catalog::Catalog(AttachedDatabase &db) : db(db) {
45: }
46: 
47: Catalog::~Catalog() {
48: }
49: 
50: DatabaseInstance &Catalog::GetDatabase() {
51: 	return db.GetDatabase();
52: }
53: 
54: AttachedDatabase &Catalog::GetAttached() {
55: 	return db;
56: }
57: 
58: const AttachedDatabase &Catalog::GetAttached() const {
59: 	return db;
60: }
61: 
62: const string &Catalog::GetName() const {
63: 	return GetAttached().GetName();
64: }
65: 
66: idx_t Catalog::GetOid() {
67: 	return GetAttached().oid;
68: }
69: 
70: Catalog &Catalog::GetSystemCatalog(ClientContext &context) {
71: 	return Catalog::GetSystemCatalog(*context.db);
72: }
73: 
74: const string &GetDefaultCatalog(CatalogEntryRetriever &retriever) {
75: 	return DatabaseManager::GetDefaultDatabase(retriever.GetContext());
76: }
77: 
78: optional_ptr<Catalog> Catalog::GetCatalogEntry(CatalogEntryRetriever &retriever, const string &catalog_name) {
79: 	auto &context = retriever.GetContext();
80: 	auto &db_manager = DatabaseManager::Get(context);
81: 	if (catalog_name == TEMP_CATALOG) {
82: 		return &ClientData::Get(context).temporary_objects->GetCatalog();
83: 	}
84: 	if (catalog_name == SYSTEM_CATALOG) {
85: 		return &GetSystemCatalog(context);
86: 	}
87: 	auto entry =
88: 	    db_manager.GetDatabase(context, IsInvalidCatalog(catalog_name) ? GetDefaultCatalog(retriever) : catalog_name);
89: 	if (!entry) {
90: 		return nullptr;
91: 	}
92: 	return &entry->GetCatalog();
93: }
94: 
95: optional_ptr<Catalog> Catalog::GetCatalogEntry(ClientContext &context, const string &catalog_name) {
96: 	CatalogEntryRetriever entry_retriever(context);
97: 	return GetCatalogEntry(entry_retriever, catalog_name);
98: }
99: 
100: Catalog &Catalog::GetCatalog(CatalogEntryRetriever &retriever, const string &catalog_name) {
101: 	auto catalog = Catalog::GetCatalogEntry(retriever, catalog_name);
102: 	if (!catalog) {
103: 		throw BinderException("Catalog \"%s\" does not exist!", catalog_name);
104: 	}
105: 	return *catalog;
106: }
107: 
108: Catalog &Catalog::GetCatalog(ClientContext &context, const string &catalog_name) {
109: 	CatalogEntryRetriever entry_retriever(context);
110: 	return GetCatalog(entry_retriever, catalog_name);
111: }
112: 
113: //===--------------------------------------------------------------------===//
114: // Schema
115: //===--------------------------------------------------------------------===//
116: optional_ptr<CatalogEntry> Catalog::CreateSchema(ClientContext &context, CreateSchemaInfo &info) {
117: 	return CreateSchema(GetCatalogTransaction(context), info);
118: }
119: 
120: CatalogTransaction Catalog::GetCatalogTransaction(ClientContext &context) {
121: 	return CatalogTransaction(*this, context);
122: }
123: 
124: //===--------------------------------------------------------------------===//
125: // Table
126: //===--------------------------------------------------------------------===//
127: optional_ptr<CatalogEntry> Catalog::CreateTable(ClientContext &context, BoundCreateTableInfo &info) {
128: 	return CreateTable(GetCatalogTransaction(context), info);
129: }
130: 
131: optional_ptr<CatalogEntry> Catalog::CreateTable(ClientContext &context, unique_ptr<CreateTableInfo> info) {
132: 	auto binder = Binder::CreateBinder(context);
133: 	auto bound_info = binder->BindCreateTableInfo(std::move(info));
134: 	return CreateTable(context, *bound_info);
135: }
136: 
137: optional_ptr<CatalogEntry> Catalog::CreateTable(CatalogTransaction transaction, SchemaCatalogEntry &schema,
138:                                                 BoundCreateTableInfo &info) {
139: 	return schema.CreateTable(transaction, info);
140: }
141: 
142: optional_ptr<CatalogEntry> Catalog::CreateTable(CatalogTransaction transaction, BoundCreateTableInfo &info) {
143: 	auto &schema = GetSchema(transaction, info.base->schema);
144: 	return CreateTable(transaction, schema, info);
145: }
146: 
147: //===--------------------------------------------------------------------===//
148: // View
149: //===--------------------------------------------------------------------===//
150: optional_ptr<CatalogEntry> Catalog::CreateView(CatalogTransaction transaction, CreateViewInfo &info) {
151: 	auto &schema = GetSchema(transaction, info.schema);
152: 	return CreateView(transaction, schema, info);
153: }
154: 
155: optional_ptr<CatalogEntry> Catalog::CreateView(ClientContext &context, CreateViewInfo &info) {
156: 	return CreateView(GetCatalogTransaction(context), info);
157: }
158: 
159: optional_ptr<CatalogEntry> Catalog::CreateView(CatalogTransaction transaction, SchemaCatalogEntry &schema,
160:                                                CreateViewInfo &info) {
161: 	return schema.CreateView(transaction, info);
162: }
163: 
164: //===--------------------------------------------------------------------===//
165: // Sequence
166: //===--------------------------------------------------------------------===//
167: optional_ptr<CatalogEntry> Catalog::CreateSequence(CatalogTransaction transaction, CreateSequenceInfo &info) {
168: 	auto &schema = GetSchema(transaction, info.schema);
169: 	return CreateSequence(transaction, schema, info);
170: }
171: 
172: optional_ptr<CatalogEntry> Catalog::CreateSequence(ClientContext &context, CreateSequenceInfo &info) {
173: 	return CreateSequence(GetCatalogTransaction(context), info);
174: }
175: 
176: optional_ptr<CatalogEntry> Catalog::CreateSequence(CatalogTransaction transaction, SchemaCatalogEntry &schema,
177:                                                    CreateSequenceInfo &info) {
178: 	return schema.CreateSequence(transaction, info);
179: }
180: 
181: //===--------------------------------------------------------------------===//
182: // Type
183: //===--------------------------------------------------------------------===//
184: optional_ptr<CatalogEntry> Catalog::CreateType(CatalogTransaction transaction, CreateTypeInfo &info) {
185: 	auto &schema = GetSchema(transaction, info.schema);
186: 	return CreateType(transaction, schema, info);
187: }
188: 
189: optional_ptr<CatalogEntry> Catalog::CreateType(ClientContext &context, CreateTypeInfo &info) {
190: 	return CreateType(GetCatalogTransaction(context), info);
191: }
192: 
193: optional_ptr<CatalogEntry> Catalog::CreateType(CatalogTransaction transaction, SchemaCatalogEntry &schema,
194:                                                CreateTypeInfo &info) {
195: 	return schema.CreateType(transaction, info);
196: }
197: 
198: //===--------------------------------------------------------------------===//
199: // Table Function
200: //===--------------------------------------------------------------------===//
201: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(CatalogTransaction transaction, CreateTableFunctionInfo &info) {
202: 	auto &schema = GetSchema(transaction, info.schema);
203: 	return CreateTableFunction(transaction, schema, info);
204: }
205: 
206: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(ClientContext &context, CreateTableFunctionInfo &info) {
207: 	return CreateTableFunction(GetCatalogTransaction(context), info);
208: }
209: 
210: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
211:                                                         CreateTableFunctionInfo &info) {
212: 	return schema.CreateTableFunction(transaction, info);
213: }
214: 
215: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(ClientContext &context,
216:                                                         optional_ptr<CreateTableFunctionInfo> info) {
217: 	return CreateTableFunction(context, *info);
218: }
219: 
220: //===--------------------------------------------------------------------===//
221: // Copy Function
222: //===--------------------------------------------------------------------===//
223: optional_ptr<CatalogEntry> Catalog::CreateCopyFunction(CatalogTransaction transaction, CreateCopyFunctionInfo &info) {
224: 	auto &schema = GetSchema(transaction, info.schema);
225: 	return CreateCopyFunction(transaction, schema, info);
226: }
227: 
228: optional_ptr<CatalogEntry> Catalog::CreateCopyFunction(ClientContext &context, CreateCopyFunctionInfo &info) {
229: 	return CreateCopyFunction(GetCatalogTransaction(context), info);
230: }
231: 
232: optional_ptr<CatalogEntry> Catalog::CreateCopyFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
233:                                                        CreateCopyFunctionInfo &info) {
234: 	return schema.CreateCopyFunction(transaction, info);
235: }
236: 
237: //===--------------------------------------------------------------------===//
238: // Pragma Function
239: //===--------------------------------------------------------------------===//
240: optional_ptr<CatalogEntry> Catalog::CreatePragmaFunction(CatalogTransaction transaction,
241:                                                          CreatePragmaFunctionInfo &info) {
242: 	auto &schema = GetSchema(transaction, info.schema);
243: 	return CreatePragmaFunction(transaction, schema, info);
244: }
245: 
246: optional_ptr<CatalogEntry> Catalog::CreatePragmaFunction(ClientContext &context, CreatePragmaFunctionInfo &info) {
247: 	return CreatePragmaFunction(GetCatalogTransaction(context), info);
248: }
249: 
250: optional_ptr<CatalogEntry> Catalog::CreatePragmaFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
251:                                                          CreatePragmaFunctionInfo &info) {
252: 	return schema.CreatePragmaFunction(transaction, info);
253: }
254: 
255: //===--------------------------------------------------------------------===//
256: // Function
257: //===--------------------------------------------------------------------===//
258: optional_ptr<CatalogEntry> Catalog::CreateFunction(CatalogTransaction transaction, CreateFunctionInfo &info) {
259: 	auto &schema = GetSchema(transaction, info.schema);
260: 	return CreateFunction(transaction, schema, info);
261: }
262: 
263: optional_ptr<CatalogEntry> Catalog::CreateFunction(ClientContext &context, CreateFunctionInfo &info) {
264: 	return CreateFunction(GetCatalogTransaction(context), info);
265: }
266: 
267: optional_ptr<CatalogEntry> Catalog::CreateFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
268:                                                    CreateFunctionInfo &info) {
269: 	return schema.CreateFunction(transaction, info);
270: }
271: 
272: optional_ptr<CatalogEntry> Catalog::AddFunction(ClientContext &context, CreateFunctionInfo &info) {
273: 	info.on_conflict = OnCreateConflict::ALTER_ON_CONFLICT;
274: 	return CreateFunction(context, info);
275: }
276: 
277: //===--------------------------------------------------------------------===//
278: // Collation
279: //===--------------------------------------------------------------------===//
280: optional_ptr<CatalogEntry> Catalog::CreateCollation(CatalogTransaction transaction, CreateCollationInfo &info) {
281: 	auto &schema = GetSchema(transaction, info.schema);
282: 	return CreateCollation(transaction, schema, info);
283: }
284: 
285: optional_ptr<CatalogEntry> Catalog::CreateCollation(ClientContext &context, CreateCollationInfo &info) {
286: 	return CreateCollation(GetCatalogTransaction(context), info);
287: }
288: 
289: optional_ptr<CatalogEntry> Catalog::CreateCollation(CatalogTransaction transaction, SchemaCatalogEntry &schema,
290:                                                     CreateCollationInfo &info) {
291: 	return schema.CreateCollation(transaction, info);
292: }
293: 
294: //===--------------------------------------------------------------------===//
295: // Index
296: //===--------------------------------------------------------------------===//
297: optional_ptr<CatalogEntry> Catalog::CreateIndex(CatalogTransaction transaction, CreateIndexInfo &info) {
298: 	auto &schema = GetSchema(transaction, info.schema);
299: 	auto &table = schema.GetEntry(transaction, CatalogType::TABLE_ENTRY, info.table)->Cast<TableCatalogEntry>();
300: 	return schema.CreateIndex(transaction, info, table);
301: }
302: 
303: optional_ptr<CatalogEntry> Catalog::CreateIndex(ClientContext &context, CreateIndexInfo &info) {
304: 	return CreateIndex(GetCatalogTransaction(context), info);
305: }
306: 
307: //===--------------------------------------------------------------------===//
308: // Lookup Structures
309: //===--------------------------------------------------------------------===//
310: struct CatalogLookup {
311: 	CatalogLookup(Catalog &catalog, string schema_p) : catalog(catalog), schema(std::move(schema_p)) {
312: 	}
313: 
314: 	Catalog &catalog;
315: 	string schema;
316: };
317: 
318: //! Return value of Catalog::LookupEntry
319: struct CatalogEntryLookup {
320: 	optional_ptr<SchemaCatalogEntry> schema;
321: 	optional_ptr<CatalogEntry> entry;
322: 	ErrorData error;
323: 
324: 	DUCKDB_API bool Found() const {
325: 		return entry;
326: 	}
327: };
328: 
329: //===--------------------------------------------------------------------===//
330: // Generic
331: //===--------------------------------------------------------------------===//
332: void Catalog::DropEntry(ClientContext &context, DropInfo &info) {
333: 	if (info.type == CatalogType::SCHEMA_ENTRY) {
334: 		// DROP SCHEMA
335: 		DropSchema(context, info);
336: 		return;
337: 	}
338: 
339: 	CatalogEntryRetriever retriever(context);
340: 	auto lookup = LookupEntry(retriever, info.type, info.schema, info.name, info.if_not_found);
341: 	if (!lookup.Found()) {
342: 		return;
343: 	}
344: 
345: 	lookup.schema->DropEntry(context, info);
346: }
347: 
348: SchemaCatalogEntry &Catalog::GetSchema(ClientContext &context, const string &name, QueryErrorContext error_context) {
349: 	return *Catalog::GetSchema(context, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
350: }
351: 
352: optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(ClientContext &context, const string &schema_name,
353:                                                     OnEntryNotFound if_not_found, QueryErrorContext error_context) {
354: 	return GetSchema(GetCatalogTransaction(context), schema_name, if_not_found, error_context);
355: }
356: 
357: SchemaCatalogEntry &Catalog::GetSchema(ClientContext &context, const string &catalog_name, const string &schema_name,
358:                                        QueryErrorContext error_context) {
359: 	return *Catalog::GetSchema(context, catalog_name, schema_name, OnEntryNotFound::THROW_EXCEPTION, error_context);
360: }
361: 
362: SchemaCatalogEntry &Catalog::GetSchema(CatalogTransaction transaction, const string &name,
363:                                        QueryErrorContext error_context) {
364: 	return *GetSchema(transaction, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
365: }
366: 
367: //===--------------------------------------------------------------------===//
368: // Lookup
369: //===--------------------------------------------------------------------===//
370: SimilarCatalogEntry Catalog::SimilarEntryInSchemas(ClientContext &context, const string &entry_name, CatalogType type,
371:                                                    const reference_set_t<SchemaCatalogEntry> &schemas) {
372: 	SimilarCatalogEntry result;
373: 	for (auto schema_ref : schemas) {
374: 		auto &schema = schema_ref.get();
375: 		auto transaction = schema.catalog.GetCatalogTransaction(context);
376: 		auto entry = schema.GetSimilarEntry(transaction, type, entry_name);
377: 		if (!entry.Found()) {
378: 			// no similar entry found
379: 			continue;
380: 		}
381: 		if (!result.Found() || result.score < entry.score) {
382: 			result = entry;
383: 			result.schema = &schema;
384: 		}
385: 	}
386: 	return result;
387: }
388: 
389: vector<CatalogSearchEntry> GetCatalogEntries(CatalogEntryRetriever &retriever, const string &catalog,
390:                                              const string &schema) {
391: 	auto &context = retriever.GetContext();
392: 	vector<CatalogSearchEntry> entries;
393: 	auto &search_path = retriever.GetSearchPath();
394: 	if (IsInvalidCatalog(catalog) && IsInvalidSchema(schema)) {
395: 		// no catalog or schema provided - scan the entire search path
396: 		entries = search_path.Get();
397: 	} else if (IsInvalidCatalog(catalog)) {
398: 		auto catalogs = search_path.GetCatalogsForSchema(schema);
399: 		for (auto &catalog_name : catalogs) {
400: 			entries.emplace_back(catalog_name, schema);
401: 		}
402: 		if (entries.empty()) {
403: 			entries.emplace_back(DatabaseManager::GetDefaultDatabase(context), schema);
404: 		}
405: 	} else if (IsInvalidSchema(schema)) {
406: 		auto schemas = search_path.GetSchemasForCatalog(catalog);
407: 		for (auto &schema_name : schemas) {
408: 			entries.emplace_back(catalog, schema_name);
409: 		}
410: 		if (entries.empty()) {
411: 			entries.emplace_back(catalog, DEFAULT_SCHEMA);
412: 		}
413: 	} else {
414: 		// specific catalog and schema provided
415: 		entries.emplace_back(catalog, schema);
416: 	}
417: 	return entries;
418: }
419: 
420: void FindMinimalQualification(CatalogEntryRetriever &retriever, const string &catalog_name, const string &schema_name,
421:                               bool &qualify_database, bool &qualify_schema) {
422: 	// check if we can we qualify ONLY the schema
423: 	bool found = false;
424: 	auto entries = GetCatalogEntries(retriever, INVALID_CATALOG, schema_name);
425: 	for (auto &entry : entries) {
426: 		if (entry.catalog == catalog_name && entry.schema == schema_name) {
427: 			found = true;
428: 			break;
429: 		}
430: 	}
431: 	if (found) {
432: 		qualify_database = false;
433: 		qualify_schema = true;
434: 		return;
435: 	}
436: 	// check if we can qualify ONLY the catalog
437: 	found = false;
438: 	entries = GetCatalogEntries(retriever, catalog_name, INVALID_SCHEMA);
439: 	for (auto &entry : entries) {
440: 		if (entry.catalog == catalog_name && entry.schema == schema_name) {
441: 			found = true;
442: 			break;
443: 		}
444: 	}
445: 	if (found) {
446: 		qualify_database = true;
447: 		qualify_schema = false;
448: 		return;
449: 	}
450: 	// need to qualify both catalog and schema
451: 	qualify_database = true;
452: 	qualify_schema = true;
453: }
454: 
455: bool Catalog::TryAutoLoad(ClientContext &context, const string &original_name) noexcept {
456: 	string extension_name = ExtensionHelper::ApplyExtensionAlias(original_name);
457: 	if (context.db->ExtensionIsLoaded(extension_name)) {
458: 		return true;
459: 	}
460: #ifndef DUCKDB_DISABLE_EXTENSION_LOAD
461: 	auto &dbconfig = DBConfig::GetConfig(context);
462: 	if (!dbconfig.options.autoload_known_extensions) {
463: 		return false;
464: 	}
465: 	try {
466: 		if (ExtensionHelper::CanAutoloadExtension(extension_name)) {
467: 			return ExtensionHelper::TryAutoLoadExtension(context, extension_name);
468: 		}
469: 	} catch (...) {
470: 		return false;
471: 	}
472: #endif
473: 	return false;
474: }
475: 
476: void Catalog::AutoloadExtensionByConfigName(ClientContext &context, const string &configuration_name) {
477: #ifndef DUCKDB_DISABLE_EXTENSION_LOAD
478: 	auto &dbconfig = DBConfig::GetConfig(context);
479: 	if (dbconfig.options.autoload_known_extensions) {
480: 		auto extension_name = ExtensionHelper::FindExtensionInEntries(configuration_name, EXTENSION_SETTINGS);
481: 		if (ExtensionHelper::CanAutoloadExtension(extension_name)) {
482: 			ExtensionHelper::AutoLoadExtension(context, extension_name);
483: 			return;
484: 		}
485: 	}
486: #endif
487: 
488: 	throw Catalog::UnrecognizedConfigurationError(context, configuration_name);
489: }
490: 
491: static bool IsAutoloadableFunction(CatalogType type) {
492: 	return (type == CatalogType::TABLE_FUNCTION_ENTRY || type == CatalogType::SCALAR_FUNCTION_ENTRY ||
493: 	        type == CatalogType::AGGREGATE_FUNCTION_ENTRY || type == CatalogType::PRAGMA_FUNCTION_ENTRY);
494: }
495: 
496: bool IsTableFunction(CatalogType type) {
497: 	switch (type) {
498: 	case CatalogType::TABLE_FUNCTION_ENTRY:
499: 	case CatalogType::TABLE_MACRO_ENTRY:
500: 	case CatalogType::PRAGMA_FUNCTION_ENTRY:
501: 		return true;
502: 	default:
503: 		return false;
504: 	}
505: }
506: 
507: bool IsScalarFunction(CatalogType type) {
508: 	switch (type) {
509: 	case CatalogType::SCALAR_FUNCTION_ENTRY:
510: 	case CatalogType::AGGREGATE_FUNCTION_ENTRY:
511: 	case CatalogType::MACRO_ENTRY:
512: 		return true;
513: 	default:
514: 		return false;
515: 	}
516: }
517: 
518: static bool CompareCatalogTypes(CatalogType type_a, CatalogType type_b) {
519: 	if (type_a == type_b) {
520: 		// Types are same
521: 		return true;
522: 	}
523: 	if (IsScalarFunction(type_a) && IsScalarFunction(type_b)) {
524: 		return true;
525: 	}
526: 	if (IsTableFunction(type_a) && IsTableFunction(type_b)) {
527: 		return true;
528: 	}
529: 	return false;
530: }
531: 
532: bool Catalog::AutoLoadExtensionByCatalogEntry(DatabaseInstance &db, CatalogType type, const string &entry_name) {
533: #ifndef DUCKDB_DISABLE_EXTENSION_LOAD
534: 	auto &dbconfig = DBConfig::GetConfig(db);
535: 	if (dbconfig.options.autoload_known_extensions) {
536: 		string extension_name;
537: 		if (IsAutoloadableFunction(type)) {
538: 			auto lookup_result = ExtensionHelper::FindExtensionInFunctionEntries(entry_name, EXTENSION_FUNCTIONS);
539: 			if (lookup_result.empty()) {
540: 				return false;
541: 			}
542: 			for (auto &function : lookup_result) {
543: 				auto function_type = function.second;
544: 				// FIXME: what if there are two functions with the same name, from different extensions?
545: 				if (CompareCatalogTypes(type, function_type)) {
546: 					extension_name = function.first;
547: 					break;
548: 				}
549: 			}
550: 		} else if (type == CatalogType::COPY_FUNCTION_ENTRY) {
551: 			extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COPY_FUNCTIONS);
552: 		} else if (type == CatalogType::TYPE_ENTRY) {
553: 			extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_TYPES);
554: 		} else if (type == CatalogType::COLLATION_ENTRY) {
555: 			extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COLLATIONS);
556: 		}
557: 
558: 		if (!extension_name.empty() && ExtensionHelper::CanAutoloadExtension(extension_name)) {
559: 			ExtensionHelper::AutoLoadExtension(db, extension_name);
560: 			return true;
561: 		}
562: 	}
563: #endif
564: 
565: 	return false;
566: }
567: 
568: CatalogException Catalog::UnrecognizedConfigurationError(ClientContext &context, const string &name) {
569: 	// check if the setting exists in any extensions
570: 	auto extension_name = ExtensionHelper::FindExtensionInEntries(name, EXTENSION_SETTINGS);
571: 	if (!extension_name.empty()) {
572: 		auto error_message = "Setting with name \"" + name + "\" is not in the catalog, but it exists in the " +
573: 		                     extension_name + " extension.";
574: 		error_message = ExtensionHelper::AddExtensionInstallHintToErrorMsg(context, error_message, extension_name);
575: 		return CatalogException(error_message);
576: 	}
577: 	// the setting is not in an extension
578: 	// get a list of all options
579: 	vector<string> potential_names = DBConfig::GetOptionNames();
580: 	for (auto &entry : DBConfig::GetConfig(context).extension_parameters) {
581: 		potential_names.push_back(entry.first);
582: 	}
583: 	throw CatalogException::MissingEntry("configuration parameter", name, potential_names);
584: }
585: 
586: CatalogException Catalog::CreateMissingEntryException(CatalogEntryRetriever &retriever, const string &entry_name,
587:                                                       CatalogType type,
588:                                                       const reference_set_t<SchemaCatalogEntry> &schemas,
589:                                                       QueryErrorContext error_context) {
590: 	auto &context = retriever.GetContext();
591: 	auto entry = SimilarEntryInSchemas(context, entry_name, type, schemas);
592: 
593: 	reference_set_t<SchemaCatalogEntry> unseen_schemas;
594: 	auto &db_manager = DatabaseManager::Get(context);
595: 	auto databases = db_manager.GetDatabases(context);
596: 	auto &config = DBConfig::GetConfig(context);
597: 
598: 	auto max_schema_count = config.options.catalog_error_max_schemas;
599: 	for (auto database : databases) {
600: 		if (unseen_schemas.size() >= max_schema_count) {
601: 			break;
602: 		}
603: 		auto &catalog = database.get().GetCatalog();
604: 		auto current_schemas = catalog.GetAllSchemas(context);
605: 		for (auto &current_schema : current_schemas) {
606: 			if (unseen_schemas.size() >= max_schema_count) {
607: 				break;
608: 			}
609: 			unseen_schemas.insert(current_schema.get());
610: 		}
611: 	}
612: 	// check if the entry exists in any extension
613: 	string extension_name;
614: 	if (type == CatalogType::TABLE_FUNCTION_ENTRY || type == CatalogType::SCALAR_FUNCTION_ENTRY ||
615: 	    type == CatalogType::AGGREGATE_FUNCTION_ENTRY || type == CatalogType::PRAGMA_FUNCTION_ENTRY) {
616: 		auto lookup_result = ExtensionHelper::FindExtensionInFunctionEntries(entry_name, EXTENSION_FUNCTIONS);
617: 		do {
618: 			if (lookup_result.empty()) {
619: 				break;
620: 			}
621: 			vector<string> other_types;
622: 			string extension_for_error;
623: 			for (auto &function : lookup_result) {
624: 				auto function_type = function.second;
625: 				if (CompareCatalogTypes(type, function_type)) {
626: 					extension_name = function.first;
627: 					break;
628: 				}
629: 				extension_for_error = function.first;
630: 				other_types.push_back(CatalogTypeToString(function_type));
631: 			}
632: 			if (!extension_name.empty()) {
633: 				break;
634: 			}
635: 			if (other_types.size() == 1) {
636: 				auto &function_type = other_types[0];
637: 				auto error =
638: 				    CatalogException("%s with name \"%s\" is not in the catalog, a function by this name exists "
639: 				                     "in the %s extension, but it's of a different type, namely %s",
640: 				                     CatalogTypeToString(type), entry_name, extension_for_error, function_type);
641: 				return error;
642: 			} else {
643: 				D_ASSERT(!other_types.empty());
644: 				auto list_of_types = StringUtil::Join(other_types, ", ");
645: 				auto error =
646: 				    CatalogException("%s with name \"%s\" is not in the catalog, functions with this name exist "
647: 				                     "in the %s extension, but they are of different types, namely %s",
648: 				                     CatalogTypeToString(type), entry_name, extension_for_error, list_of_types);
649: 				return error;
650: 			}
651: 		} while (false);
652: 	} else if (type == CatalogType::TYPE_ENTRY) {
653: 		extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_TYPES);
654: 	} else if (type == CatalogType::COPY_FUNCTION_ENTRY) {
655: 		extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COPY_FUNCTIONS);
656: 	} else if (type == CatalogType::COLLATION_ENTRY) {
657: 		extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COLLATIONS);
658: 	}
659: 
660: 	// if we found an extension that can handle this catalog entry, create an error hinting the user
661: 	if (!extension_name.empty()) {
662: 		auto error_message = CatalogTypeToString(type) + " with name \"" + entry_name +
663: 		                     "\" is not in the catalog, but it exists in the " + extension_name + " extension.";
664: 		error_message = ExtensionHelper::AddExtensionInstallHintToErrorMsg(context, error_message, extension_name);
665: 		return CatalogException(error_message);
666: 	}
667: 
668: 	// entries in other schemas get a penalty
669: 	// however, if there is an exact match in another schema, we will always show it
670: 	static constexpr const double UNSEEN_PENALTY = 0.2;
671: 	auto unseen_entry = SimilarEntryInSchemas(context, entry_name, type, unseen_schemas);
672: 	string did_you_mean;
673: 	if (unseen_entry.Found() && (unseen_entry.score == 1.0 || unseen_entry.score - UNSEEN_PENALTY > entry.score)) {
674: 		// the closest matching entry requires qualification as it is not in the default search path
675: 		// check how to minimally qualify this entry
676: 		auto catalog_name = unseen_entry.schema->catalog.GetName();
677: 		auto schema_name = unseen_entry.schema->name;
678: 		bool qualify_database;
679: 		bool qualify_schema;
680: 		FindMinimalQualification(retriever, catalog_name, schema_name, qualify_database, qualify_schema);
681: 		did_you_mean = unseen_entry.GetQualifiedName(qualify_database, qualify_schema);
682: 	} else if (entry.Found()) {
683: 		did_you_mean = entry.name;
684: 	}
685: 	return CatalogException::MissingEntry(type, entry_name, did_you_mean, error_context);
686: }
687: 
688: CatalogEntryLookup Catalog::TryLookupEntryInternal(CatalogTransaction transaction, CatalogType type,
689:                                                    const string &schema, const string &name) {
690: 	auto schema_entry = GetSchema(transaction, schema, OnEntryNotFound::RETURN_NULL);
691: 	if (!schema_entry) {
692: 		return {nullptr, nullptr, ErrorData()};
693: 	}
694: 	auto entry = schema_entry->GetEntry(transaction, type, name);
695: 	if (!entry) {
696: 		return {schema_entry, nullptr, ErrorData()};
697: 	}
698: 	return {schema_entry, entry, ErrorData()};
699: }
700: 
701: CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &schema,
702:                                            const string &name, OnEntryNotFound if_not_found,
703:                                            QueryErrorContext error_context) {
704: 	auto &context = retriever.GetContext();
705: 	reference_set_t<SchemaCatalogEntry> schemas;
706: 	if (IsInvalidSchema(schema)) {
707: 		// try all schemas for this catalog
708: 		auto entries = GetCatalogEntries(retriever, GetName(), INVALID_SCHEMA);
709: 		for (auto &entry : entries) {
710: 			auto &candidate_schema = entry.schema;
711: 			auto transaction = GetCatalogTransaction(context);
712: 			auto result = TryLookupEntryInternal(transaction, type, candidate_schema, name);
713: 			if (result.Found()) {
714: 				return result;
715: 			}
716: 			if (result.schema) {
717: 				schemas.insert(*result.schema);
718: 			}
719: 		}
720: 	} else {
721: 		auto transaction = GetCatalogTransaction(context);
722: 		auto result = TryLookupEntryInternal(transaction, type, schema, name);
723: 		if (result.Found()) {
724: 			return result;
725: 		}
726: 		if (result.schema) {
727: 			schemas.insert(*result.schema);
728: 		}
729: 	}
730: 
731: 	if (if_not_found == OnEntryNotFound::RETURN_NULL) {
732: 		return {nullptr, nullptr, ErrorData()};
733: 	} else {
734: 		auto except = CreateMissingEntryException(retriever, name, type, schemas, error_context);
735: 		return {nullptr, nullptr, ErrorData(except)};
736: 	}
737: }
738: 
739: CatalogEntryLookup Catalog::LookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &schema,
740:                                         const string &name, OnEntryNotFound if_not_found,
741:                                         QueryErrorContext error_context) {
742: 	auto res = TryLookupEntry(retriever, type, schema, name, if_not_found, error_context);
743: 
744: 	if (res.error.HasError()) {
745: 		res.error.Throw();
746: 	}
747: 
748: 	return res;
749: }
750: 
751: CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, vector<CatalogLookup> &lookups,
752:                                            CatalogType type, const string &name, OnEntryNotFound if_not_found,
753:                                            QueryErrorContext error_context) {
754: 	auto &context = retriever.GetContext();
755: 	reference_set_t<SchemaCatalogEntry> schemas;
756: 	for (auto &lookup : lookups) {
757: 		auto transaction = lookup.catalog.GetCatalogTransaction(context);
758: 		auto result = lookup.catalog.TryLookupEntryInternal(transaction, type, lookup.schema, name);
759: 		if (result.Found()) {
760: 			return result;
761: 		}
762: 		if (result.schema) {
763: 			schemas.insert(*result.schema);
764: 		}
765: 	}
766: 
767: 	if (if_not_found == OnEntryNotFound::RETURN_NULL) {
768: 		return {nullptr, nullptr, ErrorData()};
769: 	} else {
770: 		auto except = CreateMissingEntryException(retriever, name, type, schemas, error_context);
771: 		return {nullptr, nullptr, ErrorData(except)};
772: 	}
773: }
774: 
775: CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &catalog,
776:                                            const string &schema, const string &name, OnEntryNotFound if_not_found,
777:                                            QueryErrorContext error_context) {
778: 	auto entries = GetCatalogEntries(retriever, catalog, schema);
779: 	vector<CatalogLookup> lookups;
780: 	vector<CatalogLookup> final_lookups;
781: 	lookups.reserve(entries.size());
782: 	for (auto &entry : entries) {
783: 		optional_ptr<Catalog> catalog_entry;
784: 		if (if_not_found == OnEntryNotFound::RETURN_NULL) {
785: 			catalog_entry = Catalog::GetCatalogEntry(retriever, entry.catalog);
786: 		} else {
787: 			catalog_entry = &Catalog::GetCatalog(retriever, entry.catalog);
788: 		}
789: 		if (!catalog_entry) {
790: 			return {nullptr, nullptr, ErrorData()};
791: 		}
792: 		D_ASSERT(catalog_entry);
793: 		auto lookup_behavior = catalog_entry->CatalogTypeLookupRule(type);
794: 		if (lookup_behavior == CatalogLookupBehavior::STANDARD) {
795: 			lookups.emplace_back(*catalog_entry, entry.schema);
796: 		} else if (lookup_behavior == CatalogLookupBehavior::LOWER_PRIORITY) {
797: 			final_lookups.emplace_back(*catalog_entry, entry.schema);
798: 		}
799: 	}
800: 	for (auto &lookup : final_lookups) {
801: 		lookups.emplace_back(std::move(lookup));
802: 	}
803: 	return Catalog::TryLookupEntry(retriever, lookups, type, name, if_not_found, error_context);
804: }
805: 
806: optional_ptr<CatalogEntry> Catalog::GetEntry(CatalogEntryRetriever &retriever, CatalogType type,
807:                                              const string &schema_name, const string &name,
808:                                              OnEntryNotFound if_not_found, QueryErrorContext error_context) {
809: 	auto lookup_entry = TryLookupEntry(retriever, type, schema_name, name, if_not_found, error_context);
810: 
811: 	// Try autoloading extension to resolve lookup
812: 	if (!lookup_entry.Found()) {
813: 		if (AutoLoadExtensionByCatalogEntry(*retriever.GetContext().db, type, name)) {
814: 			lookup_entry = TryLookupEntry(retriever, type, schema_name, name, if_not_found, error_context);
815: 		}
816: 	}
817: 
818: 	if (lookup_entry.error.HasError()) {
819: 		lookup_entry.error.Throw();
820: 	}
821: 
822: 	return lookup_entry.entry.get();
823: }
824: 
825: optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema_name,
826:                                              const string &name, OnEntryNotFound if_not_found,
827:                                              QueryErrorContext error_context) {
828: 	CatalogEntryRetriever retriever(context);
829: 	return GetEntry(retriever, type, schema_name, name, if_not_found, error_context);
830: }
831: 
832: CatalogEntry &Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema, const string &name,
833:                                 QueryErrorContext error_context) {
834: 	return *Catalog::GetEntry(context, type, schema, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
835: }
836: 
837: optional_ptr<CatalogEntry> Catalog::GetEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &catalog,
838:                                              const string &schema, const string &name, OnEntryNotFound if_not_found,
839:                                              QueryErrorContext error_context) {
840: 	auto result = TryLookupEntry(retriever, type, catalog, schema, name, if_not_found, error_context);
841: 
842: 	// Try autoloading extension to resolve lookup
843: 	if (!result.Found()) {
844: 		if (AutoLoadExtensionByCatalogEntry(*retriever.GetContext().db, type, name)) {
845: 			result = TryLookupEntry(retriever, type, catalog, schema, name, if_not_found, error_context);
846: 		}
847: 	}
848: 
849: 	if (result.error.HasError()) {
850: 		result.error.Throw();
851: 	}
852: 
853: 	if (!result.Found()) {
854: 		D_ASSERT(if_not_found == OnEntryNotFound::RETURN_NULL);
855: 		return nullptr;
856: 	}
857: 	return result.entry.get();
858: }
859: optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType type, const string &catalog,
860:                                              const string &schema, const string &name, OnEntryNotFound if_not_found,
861:                                              QueryErrorContext error_context) {
862: 	CatalogEntryRetriever retriever(context);
863: 	return GetEntry(retriever, type, catalog, schema, name, if_not_found, error_context);
864: }
865: 
866: CatalogEntry &Catalog::GetEntry(ClientContext &context, CatalogType type, const string &catalog, const string &schema,
867:                                 const string &name, QueryErrorContext error_context) {
868: 	return *Catalog::GetEntry(context, type, catalog, schema, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
869: }
870: 
871: optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(CatalogEntryRetriever &retriever, const string &catalog_name,
872:                                                     const string &schema_name, OnEntryNotFound if_not_found,
873:                                                     QueryErrorContext error_context) {
874: 	auto entries = GetCatalogEntries(retriever, catalog_name, schema_name);
875: 	for (idx_t i = 0; i < entries.size(); i++) {
876: 		auto on_not_found = i + 1 == entries.size() ? if_not_found : OnEntryNotFound::RETURN_NULL;
877: 		auto &catalog = Catalog::GetCatalog(retriever, entries[i].catalog);
878: 		auto result = catalog.GetSchema(retriever.GetContext(), schema_name, on_not_found, error_context);
879: 		if (result) {
880: 			return result;
881: 		}
882: 	}
883: 	return nullptr;
884: }
885: 
886: optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(ClientContext &context, const string &catalog_name,
887:                                                     const string &schema_name, OnEntryNotFound if_not_found,
888:                                                     QueryErrorContext error_context) {
889: 	CatalogEntryRetriever retriever(context);
890: 	return GetSchema(retriever, catalog_name, schema_name, if_not_found, error_context);
891: }
892: 
893: vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(ClientContext &context) {
894: 	vector<reference<SchemaCatalogEntry>> schemas;
895: 	ScanSchemas(context, [&](SchemaCatalogEntry &entry) { schemas.push_back(entry); });
896: 	return schemas;
897: }
898: 
899: vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(CatalogEntryRetriever &retriever,
900:                                                           const string &catalog_name) {
901: 	vector<reference<Catalog>> catalogs;
902: 	if (IsInvalidCatalog(catalog_name)) {
903: 		reference_set_t<Catalog> inserted_catalogs;
904: 
905: 		auto &search_path = retriever.GetSearchPath();
906: 		for (auto &entry : search_path.Get()) {
907: 			auto &catalog = Catalog::GetCatalog(retriever, entry.catalog);
908: 			if (inserted_catalogs.find(catalog) != inserted_catalogs.end()) {
909: 				continue;
910: 			}
911: 			inserted_catalogs.insert(catalog);
912: 			catalogs.push_back(catalog);
913: 		}
914: 	} else {
915: 		catalogs.push_back(Catalog::GetCatalog(retriever, catalog_name));
916: 	}
917: 	vector<reference<SchemaCatalogEntry>> result;
918: 	for (auto catalog : catalogs) {
919: 		auto schemas = catalog.get().GetSchemas(retriever.GetContext());
920: 		result.insert(result.end(), schemas.begin(), schemas.end());
921: 	}
922: 	return result;
923: }
924: 
925: vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(ClientContext &context, const string &catalog_name) {
926: 	CatalogEntryRetriever retriever(context);
927: 	return GetSchemas(retriever, catalog_name);
928: }
929: 
930: vector<reference<SchemaCatalogEntry>> Catalog::GetAllSchemas(ClientContext &context) {
931: 	vector<reference<SchemaCatalogEntry>> result;
932: 
933: 	auto &db_manager = DatabaseManager::Get(context);
934: 	auto databases = db_manager.GetDatabases(context);
935: 	for (auto database : databases) {
936: 		auto &catalog = database.get().GetCatalog();
937: 		auto new_schemas = catalog.GetSchemas(context);
938: 		result.insert(result.end(), new_schemas.begin(), new_schemas.end());
939: 	}
940: 	sort(result.begin(), result.end(),
941: 	     [&](reference<SchemaCatalogEntry> left_p, reference<SchemaCatalogEntry> right_p) {
942: 		     auto &left = left_p.get();
943: 		     auto &right = right_p.get();
944: 		     if (left.catalog.GetName() < right.catalog.GetName()) {
945: 			     return true;
946: 		     }
947: 		     if (left.catalog.GetName() == right.catalog.GetName()) {
948: 			     return left.name < right.name;
949: 		     }
950: 		     return false;
951: 	     });
952: 
953: 	return result;
954: }
955: 
956: void Catalog::Alter(CatalogTransaction transaction, AlterInfo &info) {
957: 	if (transaction.HasContext()) {
958: 		CatalogEntryRetriever retriever(transaction.GetContext());
959: 		auto lookup = LookupEntry(retriever, info.GetCatalogType(), info.schema, info.name, info.if_not_found);
960: 		if (!lookup.Found()) {
961: 			return;
962: 		}
963: 		return lookup.schema->Alter(transaction, info);
964: 	}
965: 	D_ASSERT(info.if_not_found == OnEntryNotFound::THROW_EXCEPTION);
966: 	auto &schema = GetSchema(transaction, info.schema);
967: 	return schema.Alter(transaction, info);
968: }
969: 
970: void Catalog::Alter(ClientContext &context, AlterInfo &info) {
971: 	Alter(GetCatalogTransaction(context), info);
972: }
973: 
974: vector<MetadataBlockInfo> Catalog::GetMetadataInfo(ClientContext &context) {
975: 	return vector<MetadataBlockInfo>();
976: }
977: 
978: void Catalog::Verify() {
979: }
980: 
981: bool Catalog::IsSystemCatalog() const {
982: 	return db.IsSystem();
983: }
984: 
985: bool Catalog::IsTemporaryCatalog() const {
986: 	return db.IsTemporary();
987: }
988: 
989: } // namespace duckdb
[end of src/catalog/catalog.cpp]
[start of src/include/duckdb/catalog/catalog.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/catalog/catalog.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/catalog/catalog_entry.hpp"
12: #include "duckdb/common/mutex.hpp"
13: #include "duckdb/parser/query_error_context.hpp"
14: #include "duckdb/catalog/catalog_transaction.hpp"
15: #include "duckdb/common/reference_map.hpp"
16: #include "duckdb/common/atomic.hpp"
17: #include "duckdb/common/map.hpp"
18: #include "duckdb/common/optional_ptr.hpp"
19: #include "duckdb/common/enums/on_entry_not_found.hpp"
20: #include "duckdb/common/error_data.hpp"
21: #include "duckdb/common/exception/catalog_exception.hpp"
22: #include "duckdb/common/enums/catalog_lookup_behavior.hpp"
23: #include <functional>
24: 
25: namespace duckdb {
26: struct CreateSchemaInfo;
27: struct DropInfo;
28: struct BoundCreateTableInfo;
29: struct AlterTableInfo;
30: struct CreateTableFunctionInfo;
31: struct CreateCopyFunctionInfo;
32: struct CreatePragmaFunctionInfo;
33: struct CreateFunctionInfo;
34: struct CreateViewInfo;
35: struct CreateSequenceInfo;
36: struct CreateCollationInfo;
37: struct CreateIndexInfo;
38: struct CreateTypeInfo;
39: struct CreateTableInfo;
40: struct DatabaseSize;
41: struct MetadataBlockInfo;
42: 
43: class AttachedDatabase;
44: class ClientContext;
45: class Transaction;
46: 
47: class AggregateFunctionCatalogEntry;
48: class CollateCatalogEntry;
49: class SchemaCatalogEntry;
50: class TableCatalogEntry;
51: class ViewCatalogEntry;
52: class SequenceCatalogEntry;
53: class TableFunctionCatalogEntry;
54: class CopyFunctionCatalogEntry;
55: class PragmaFunctionCatalogEntry;
56: class CatalogSet;
57: class DatabaseInstance;
58: class DependencyManager;
59: 
60: struct CatalogLookup;
61: struct CatalogEntryLookup;
62: struct SimilarCatalogEntry;
63: 
64: class Binder;
65: class LogicalOperator;
66: class PhysicalOperator;
67: class LogicalCreateIndex;
68: class LogicalCreateTable;
69: class LogicalInsert;
70: class LogicalDelete;
71: class LogicalUpdate;
72: class CreateStatement;
73: class CatalogEntryRetriever;
74: 
75: //! The Catalog object represents the catalog of the database.
76: class Catalog {
77: public:
78: 	explicit Catalog(AttachedDatabase &db);
79: 	virtual ~Catalog();
80: 
81: public:
82: 	//! Get the SystemCatalog from the ClientContext
83: 	DUCKDB_API static Catalog &GetSystemCatalog(ClientContext &context);
84: 	//! Get the SystemCatalog from the DatabaseInstance
85: 	DUCKDB_API static Catalog &GetSystemCatalog(DatabaseInstance &db);
86: 	//! Get the specified Catalog from the ClientContext
87: 	DUCKDB_API static Catalog &GetCatalog(ClientContext &context, const string &catalog_name);
88: 	//! Get the specified Catalog from the ClientContext
89: 	DUCKDB_API static Catalog &GetCatalog(CatalogEntryRetriever &retriever, const string &catalog_name);
90: 	//! Get the specified Catalog from the DatabaseInstance
91: 	DUCKDB_API static Catalog &GetCatalog(DatabaseInstance &db, const string &catalog_name);
92: 	//! Gets the specified Catalog from the database if it exists
93: 	DUCKDB_API static optional_ptr<Catalog> GetCatalogEntry(ClientContext &context, const string &catalog_name);
94: 	//! Gets the specified Catalog from the database if it exists
95: 	DUCKDB_API static optional_ptr<Catalog> GetCatalogEntry(CatalogEntryRetriever &retriever,
96: 	                                                        const string &catalog_name);
97: 	//! Get the specific Catalog from the AttachedDatabase
98: 	DUCKDB_API static Catalog &GetCatalog(AttachedDatabase &db);
99: 
100: 	DUCKDB_API AttachedDatabase &GetAttached();
101: 	DUCKDB_API const AttachedDatabase &GetAttached() const;
102: 	DUCKDB_API DatabaseInstance &GetDatabase();
103: 
104: 	virtual bool IsDuckCatalog() {
105: 		return false;
106: 	}
107: 	virtual void Initialize(bool load_builtin) = 0;
108: 
109: 	bool IsSystemCatalog() const;
110: 	bool IsTemporaryCatalog() const;
111: 
112: 	//! Returns a version number that uniquely characterizes the current catalog snapshot.
113: 	//! If there are transaction-local changes, the version returned is >= TRANSACTION_START, o.w. it is a simple number
114: 	//! starting at 0 that is incremented at each commit that has had catalog changes.
115: 	//! If the catalog does not support versioning, no index is returned.
116: 	DUCKDB_API virtual optional_idx GetCatalogVersion(ClientContext &context) {
117: 		return {}; // don't return anything by default
118: 	}
119: 
120: 	//! Returns the catalog name - based on how the catalog was attached
121: 	DUCKDB_API const string &GetName() const;
122: 	DUCKDB_API idx_t GetOid();
123: 	DUCKDB_API virtual string GetCatalogType() = 0;
124: 
125: 	DUCKDB_API CatalogTransaction GetCatalogTransaction(ClientContext &context);
126: 
127: 	//! Creates a schema in the catalog.
128: 	DUCKDB_API virtual optional_ptr<CatalogEntry> CreateSchema(CatalogTransaction transaction,
129: 	                                                           CreateSchemaInfo &info) = 0;
130: 	DUCKDB_API optional_ptr<CatalogEntry> CreateSchema(ClientContext &context, CreateSchemaInfo &info);
131: 	//! Creates a table in the catalog.
132: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTable(CatalogTransaction transaction, BoundCreateTableInfo &info);
133: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTable(ClientContext &context, BoundCreateTableInfo &info);
134: 	//! Creates a table in the catalog.
135: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTable(ClientContext &context, unique_ptr<CreateTableInfo> info);
136: 	//! Create a table function in the catalog
137: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTableFunction(CatalogTransaction transaction,
138: 	                                                          CreateTableFunctionInfo &info);
139: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTableFunction(ClientContext &context, CreateTableFunctionInfo &info);
140: 	// Kept for backwards compatibility
141: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTableFunction(ClientContext &context,
142: 	                                                          optional_ptr<CreateTableFunctionInfo> info);
143: 	//! Create a copy function in the catalog
144: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCopyFunction(CatalogTransaction transaction,
145: 	                                                         CreateCopyFunctionInfo &info);
146: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCopyFunction(ClientContext &context, CreateCopyFunctionInfo &info);
147: 	//! Create a pragma function in the catalog
148: 	DUCKDB_API optional_ptr<CatalogEntry> CreatePragmaFunction(CatalogTransaction transaction,
149: 	                                                           CreatePragmaFunctionInfo &info);
150: 	DUCKDB_API optional_ptr<CatalogEntry> CreatePragmaFunction(ClientContext &context, CreatePragmaFunctionInfo &info);
151: 	//! Create a scalar or aggregate function in the catalog
152: 	DUCKDB_API optional_ptr<CatalogEntry> CreateFunction(CatalogTransaction transaction, CreateFunctionInfo &info);
153: 	DUCKDB_API optional_ptr<CatalogEntry> CreateFunction(ClientContext &context, CreateFunctionInfo &info);
154: 	//! Creates a table in the catalog.
155: 	DUCKDB_API optional_ptr<CatalogEntry> CreateView(CatalogTransaction transaction, CreateViewInfo &info);
156: 	DUCKDB_API optional_ptr<CatalogEntry> CreateView(ClientContext &context, CreateViewInfo &info);
157: 	//! Creates a sequence in the catalog.
158: 	DUCKDB_API optional_ptr<CatalogEntry> CreateSequence(CatalogTransaction transaction, CreateSequenceInfo &info);
159: 	DUCKDB_API optional_ptr<CatalogEntry> CreateSequence(ClientContext &context, CreateSequenceInfo &info);
160: 	//! Creates a Enum in the catalog.
161: 	DUCKDB_API optional_ptr<CatalogEntry> CreateType(CatalogTransaction transaction, CreateTypeInfo &info);
162: 	DUCKDB_API optional_ptr<CatalogEntry> CreateType(ClientContext &context, CreateTypeInfo &info);
163: 	//! Creates a collation in the catalog
164: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCollation(CatalogTransaction transaction, CreateCollationInfo &info);
165: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCollation(ClientContext &context, CreateCollationInfo &info);
166: 	//! Creates an index in the catalog
167: 	DUCKDB_API optional_ptr<CatalogEntry> CreateIndex(CatalogTransaction transaction, CreateIndexInfo &info);
168: 	DUCKDB_API optional_ptr<CatalogEntry> CreateIndex(ClientContext &context, CreateIndexInfo &info);
169: 
170: 	//! Creates a table in the catalog.
171: 	DUCKDB_API optional_ptr<CatalogEntry> CreateTable(CatalogTransaction transaction, SchemaCatalogEntry &schema,
172: 	                                                  BoundCreateTableInfo &info);
173: 	//! Create a table function in the catalog
174: 	DUCKDB_API optional_ptr<CatalogEntry>
175: 	CreateTableFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema, CreateTableFunctionInfo &info);
176: 	//! Create a copy function in the catalog
177: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCopyFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
178: 	                                                         CreateCopyFunctionInfo &info);
179: 	//! Create a pragma function in the catalog
180: 	DUCKDB_API optional_ptr<CatalogEntry>
181: 	CreatePragmaFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema, CreatePragmaFunctionInfo &info);
182: 	//! Create a scalar or aggregate function in the catalog
183: 	DUCKDB_API optional_ptr<CatalogEntry> CreateFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
184: 	                                                     CreateFunctionInfo &info);
185: 	//! Creates a view in the catalog
186: 	DUCKDB_API optional_ptr<CatalogEntry> CreateView(CatalogTransaction transaction, SchemaCatalogEntry &schema,
187: 	                                                 CreateViewInfo &info);
188: 	//! Creates a table in the catalog.
189: 	DUCKDB_API optional_ptr<CatalogEntry> CreateSequence(CatalogTransaction transaction, SchemaCatalogEntry &schema,
190: 	                                                     CreateSequenceInfo &info);
191: 	//! Creates a enum in the catalog.
192: 	DUCKDB_API optional_ptr<CatalogEntry> CreateType(CatalogTransaction transaction, SchemaCatalogEntry &schema,
193: 	                                                 CreateTypeInfo &info);
194: 	//! Creates a collation in the catalog
195: 	DUCKDB_API optional_ptr<CatalogEntry> CreateCollation(CatalogTransaction transaction, SchemaCatalogEntry &schema,
196: 	                                                      CreateCollationInfo &info);
197: 
198: 	//! Drops an entry from the catalog
199: 	DUCKDB_API void DropEntry(ClientContext &context, DropInfo &info);
200: 
201: 	//! Returns the schema object with the specified name, or throws an exception if it does not exist
202: 	DUCKDB_API SchemaCatalogEntry &GetSchema(ClientContext &context, const string &name,
203: 	                                         QueryErrorContext error_context = QueryErrorContext());
204: 	DUCKDB_API optional_ptr<SchemaCatalogEntry> GetSchema(ClientContext &context, const string &name,
205: 	                                                      OnEntryNotFound if_not_found,
206: 	                                                      QueryErrorContext error_context = QueryErrorContext());
207: 	//! Overloadable method for giving warnings on ambiguous naming id.tab due to a database and schema with name id
208: 	DUCKDB_API virtual bool CheckAmbiguousCatalogOrSchema(ClientContext &context, const string &name) {
209: 		return !!GetSchema(context, name, OnEntryNotFound::RETURN_NULL);
210: 	}
211: 	DUCKDB_API SchemaCatalogEntry &GetSchema(CatalogTransaction transaction, const string &name,
212: 	                                         QueryErrorContext error_context = QueryErrorContext());
213: 	DUCKDB_API virtual optional_ptr<SchemaCatalogEntry>
214: 	GetSchema(CatalogTransaction transaction, const string &schema_name, OnEntryNotFound if_not_found,
215: 	          QueryErrorContext error_context = QueryErrorContext()) = 0;
216: 	DUCKDB_API static SchemaCatalogEntry &GetSchema(ClientContext &context, const string &catalog_name,
217: 	                                                const string &schema_name,
218: 	                                                QueryErrorContext error_context = QueryErrorContext());
219: 	DUCKDB_API static optional_ptr<SchemaCatalogEntry> GetSchema(ClientContext &context, const string &catalog_name,
220: 	                                                             const string &schema_name,
221: 	                                                             OnEntryNotFound if_not_found,
222: 	                                                             QueryErrorContext error_context = QueryErrorContext());
223: 	DUCKDB_API static optional_ptr<SchemaCatalogEntry> GetSchema(CatalogEntryRetriever &retriever,
224: 	                                                             const string &catalog_name, const string &schema_name,
225: 	                                                             OnEntryNotFound if_not_found,
226: 	                                                             QueryErrorContext error_context = QueryErrorContext());
227: 	//! Scans all the schemas in the system one-by-one, invoking the callback for each entry
228: 	DUCKDB_API virtual void ScanSchemas(ClientContext &context, std::function<void(SchemaCatalogEntry &)> callback) = 0;
229: 
230: 	//! Gets the "schema.name" entry of the specified type, if entry does not exist behavior depends on OnEntryNotFound
231: 	DUCKDB_API optional_ptr<CatalogEntry> GetEntry(ClientContext &context, CatalogType type, const string &schema,
232: 	                                               const string &name, OnEntryNotFound if_not_found,
233: 	                                               QueryErrorContext error_context = QueryErrorContext());
234: 	DUCKDB_API optional_ptr<CatalogEntry> GetEntry(CatalogEntryRetriever &retriever, CatalogType type,
235: 	                                               const string &schema, const string &name,
236: 	                                               OnEntryNotFound if_not_found,
237: 	                                               QueryErrorContext error_context = QueryErrorContext());
238: 	DUCKDB_API CatalogEntry &GetEntry(ClientContext &context, CatalogType type, const string &schema,
239: 	                                  const string &name, QueryErrorContext error_context = QueryErrorContext());
240: 	//! Gets the "catalog.schema.name" entry of the specified type, if entry does not exist behavior depends on
241: 	//! OnEntryNotFound
242: 	DUCKDB_API static optional_ptr<CatalogEntry> GetEntry(ClientContext &context, CatalogType type,
243: 	                                                      const string &catalog, const string &schema,
244: 	                                                      const string &name, OnEntryNotFound if_not_found,
245: 	                                                      QueryErrorContext error_context = QueryErrorContext());
246: 	DUCKDB_API static optional_ptr<CatalogEntry> GetEntry(CatalogEntryRetriever &retriever, CatalogType type,
247: 	                                                      const string &catalog, const string &schema,
248: 	                                                      const string &name, OnEntryNotFound if_not_found,
249: 	                                                      QueryErrorContext error_context = QueryErrorContext());
250: 	DUCKDB_API static CatalogEntry &GetEntry(ClientContext &context, CatalogType type, const string &catalog,
251: 	                                         const string &schema, const string &name,
252: 	                                         QueryErrorContext error_context = QueryErrorContext());
253: 
254: 	template <class T>
255: 	optional_ptr<T> GetEntry(ClientContext &context, const string &schema_name, const string &name,
256: 	                         OnEntryNotFound if_not_found, QueryErrorContext error_context = QueryErrorContext()) {
257: 		auto entry = GetEntry(context, T::Type, schema_name, name, if_not_found, error_context);
258: 		if (!entry) {
259: 			return nullptr;
260: 		}
261: 		if (entry->type != T::Type) {
262: 			throw CatalogException(error_context, "%s is not an %s", name, T::Name);
263: 		}
264: 		return &entry->template Cast<T>();
265: 	}
266: 	template <class T>
267: 	T &GetEntry(ClientContext &context, const string &schema_name, const string &name,
268: 	            QueryErrorContext error_context = QueryErrorContext()) {
269: 		auto entry = GetEntry<T>(context, schema_name, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
270: 		return *entry;
271: 	}
272: 
273: 	//! Append a scalar or aggregate function to the catalog
274: 	DUCKDB_API optional_ptr<CatalogEntry> AddFunction(ClientContext &context, CreateFunctionInfo &info);
275: 
276: 	//! Alter an existing entry in the catalog.
277: 	DUCKDB_API void Alter(CatalogTransaction transaction, AlterInfo &info);
278: 	DUCKDB_API void Alter(ClientContext &context, AlterInfo &info);
279: 
280: 	virtual unique_ptr<PhysicalOperator> PlanCreateTableAs(ClientContext &context, LogicalCreateTable &op,
281: 	                                                       unique_ptr<PhysicalOperator> plan) = 0;
282: 	virtual unique_ptr<PhysicalOperator> PlanInsert(ClientContext &context, LogicalInsert &op,
283: 	                                                unique_ptr<PhysicalOperator> plan) = 0;
284: 	virtual unique_ptr<PhysicalOperator> PlanDelete(ClientContext &context, LogicalDelete &op,
285: 	                                                unique_ptr<PhysicalOperator> plan) = 0;
286: 	virtual unique_ptr<PhysicalOperator> PlanUpdate(ClientContext &context, LogicalUpdate &op,
287: 	                                                unique_ptr<PhysicalOperator> plan) = 0;
288: 	virtual unique_ptr<LogicalOperator> BindCreateIndex(Binder &binder, CreateStatement &stmt, TableCatalogEntry &table,
289: 	                                                    unique_ptr<LogicalOperator> plan) = 0;
290: 
291: 	virtual DatabaseSize GetDatabaseSize(ClientContext &context) = 0;
292: 	virtual vector<MetadataBlockInfo> GetMetadataInfo(ClientContext &context);
293: 
294: 	virtual bool InMemory() = 0;
295: 	virtual string GetDBPath() = 0;
296: 
297: 	//! Whether or not this catalog should search a specific type with the standard priority
298: 	DUCKDB_API virtual CatalogLookupBehavior CatalogTypeLookupRule(CatalogType type) const {
299: 		return CatalogLookupBehavior::STANDARD;
300: 	}
301: 
302: public:
303: 	template <class T>
304: 	static optional_ptr<T> GetEntry(ClientContext &context, const string &catalog_name, const string &schema_name,
305: 	                                const string &name, OnEntryNotFound if_not_found,
306: 	                                QueryErrorContext error_context = QueryErrorContext()) {
307: 		auto entry = GetEntry(context, T::Type, catalog_name, schema_name, name, if_not_found, error_context);
308: 		if (!entry) {
309: 			return nullptr;
310: 		}
311: 		if (entry->type != T::Type) {
312: 			throw CatalogException(error_context, "%s is not an %s", name, T::Name);
313: 		}
314: 		return &entry->template Cast<T>();
315: 	}
316: 	template <class T>
317: 	static T &GetEntry(ClientContext &context, const string &catalog_name, const string &schema_name,
318: 	                   const string &name, QueryErrorContext error_context = QueryErrorContext()) {
319: 		auto entry =
320: 		    GetEntry<T>(context, catalog_name, schema_name, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
321: 		return *entry;
322: 	}
323: 
324: 	DUCKDB_API vector<reference<SchemaCatalogEntry>> GetSchemas(ClientContext &context);
325: 	DUCKDB_API static vector<reference<SchemaCatalogEntry>> GetSchemas(ClientContext &context,
326: 	                                                                   const string &catalog_name);
327: 	DUCKDB_API static vector<reference<SchemaCatalogEntry>> GetSchemas(CatalogEntryRetriever &retriever,
328: 	                                                                   const string &catalog_name);
329: 	DUCKDB_API static vector<reference<SchemaCatalogEntry>> GetAllSchemas(ClientContext &context);
330: 
331: 	virtual void Verify();
332: 
333: 	static CatalogException UnrecognizedConfigurationError(ClientContext &context, const string &name);
334: 
335: 	//! Autoload the extension required for `configuration_name` or throw a CatalogException
336: 	static void AutoloadExtensionByConfigName(ClientContext &context, const string &configuration_name);
337: 	//! Autoload the extension required for `function_name` or throw a CatalogException
338: 	static bool AutoLoadExtensionByCatalogEntry(DatabaseInstance &db, CatalogType type, const string &entry_name);
339: 	DUCKDB_API static bool TryAutoLoad(ClientContext &context, const string &extension_name) noexcept;
340: 
341: protected:
342: 	//! Reference to the database
343: 	AttachedDatabase &db;
344: 
345: public:
346: private:
347: 	//! Lookup an entry in the schema, returning a lookup with the entry and schema if they exist
348: 	CatalogEntryLookup TryLookupEntryInternal(CatalogTransaction transaction, CatalogType type, const string &schema,
349: 	                                          const string &name);
350: 	//! Calls LookupEntryInternal on the schema, trying other schemas if the schema is invalid. Sets
351: 	//! CatalogEntryLookup->error depending on if_not_found when no entry is found
352: 	CatalogEntryLookup TryLookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &schema,
353: 	                                  const string &name, OnEntryNotFound if_not_found,
354: 	                                  QueryErrorContext error_context = QueryErrorContext());
355: 	//! Lookup an entry using TryLookupEntry, throws if entry not found and if_not_found == THROW_EXCEPTION
356: 	CatalogEntryLookup LookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &schema,
357: 	                               const string &name, OnEntryNotFound if_not_found,
358: 	                               QueryErrorContext error_context = QueryErrorContext());
359: 	static CatalogEntryLookup TryLookupEntry(CatalogEntryRetriever &retriever, vector<CatalogLookup> &lookups,
360: 	                                         CatalogType type, const string &name, OnEntryNotFound if_not_found,
361: 	                                         QueryErrorContext error_context = QueryErrorContext());
362: 	static CatalogEntryLookup TryLookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &catalog,
363: 	                                         const string &schema, const string &name, OnEntryNotFound if_not_found,
364: 	                                         QueryErrorContext error_context);
365: 
366: 	//! Return an exception with did-you-mean suggestion.
367: 	static CatalogException CreateMissingEntryException(CatalogEntryRetriever &retriever, const string &entry_name,
368: 	                                                    CatalogType type,
369: 	                                                    const reference_set_t<SchemaCatalogEntry> &schemas,
370: 	                                                    QueryErrorContext error_context);
371: 
372: 	//! Return the close entry name, the distance and the belonging schema.
373: 	static SimilarCatalogEntry SimilarEntryInSchemas(ClientContext &context, const string &entry_name, CatalogType type,
374: 	                                                 const reference_set_t<SchemaCatalogEntry> &schemas);
375: 
376: 	virtual void DropSchema(ClientContext &context, DropInfo &info) = 0;
377: 
378: public:
379: 	template <class TARGET>
380: 	TARGET &Cast() {
381: 		DynamicCastCheck<TARGET>(this);
382: 		return reinterpret_cast<TARGET &>(*this);
383: 	}
384: 
385: 	template <class TARGET>
386: 	const TARGET &Cast() const {
387: 		DynamicCastCheck<TARGET>(this);
388: 		return reinterpret_cast<const TARGET &>(*this);
389: 	}
390: };
391: 
392: } // namespace duckdb
[end of src/include/duckdb/catalog/catalog.hpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: