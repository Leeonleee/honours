You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
cannot define a macro inside a cursor - Cross catalog dependencies are not supported.
### What happens?

An error is thrown when trying to create a TEMP MACRO inside a cursor with a dependency.
This worked prior to 0.10.3

```
duckdb.duckdb.Error: Error adding dependency for object "m2" - dependency "m1" is in catalog "memory", which does not match the catalog "temp".
Cross catalog dependencies are not supported.
```

### To Reproduce

```python
import duckdb


def temp_macro() -> None:
    with duckdb.connect() as con:
        print(con.execute("SELECT * FROM pragma_version()").fetchall())
        con.execute("CREATE MACRO m1() AS (SELECT 1 AS x);")
        with con.cursor() as cur:
            cur.execute(
                """CREATE OR REPLACE TEMP MACRO m2() AS (SELECT m1() AS y);""")
            
temp_macro()

```

```sh
% python3 /tmp/macro.py 
[('v0.10.2', '1601d94f94')]

% python3 /tmp/macro.py 
[('v0.10.3', '70fd6a8a24')]
Traceback (most recent call last):
  File "/tmp/macro.py", line 12, in <module>
    temp_macro()
  File "/tmp/macro.py", line 5, in temp_macro
    with duckdb.connect() as con:
  File "/tmp/macro.py", line 8, in temp_macro
    with con.cursor() as cur:
  File "/tmp/macro.py", line 9, in temp_macro
    cur.execute(
duckdb.duckdb.Error: Error adding dependency for object "m2" - dependency "m1" is in catalog "memory", which does not match the catalog "temp".
Cross catalog dependencies are not supported.

% python3 /tmp/macro.py 
[('v0.10.4-dev72', '896686ffdf')]
Traceback (most recent call last):
  File "/tmp/macro.py", line 12, in <module>
    temp_macro()
  File "/tmp/macro.py", line 5, in temp_macro
    with duckdb.connect() as con:
  File "/tmp/macro.py", line 8, in temp_macro
    with con.cursor() as cur:
  File "/tmp/macro.py", line 9, in temp_macro
    cur.execute(
duckdb.duckdb.Error: Error adding dependency for object "m2" - dependency "m1" is in catalog "memory", which does not match the catalog "temp".
Cross catalog dependencies are not supported.
```

### OS:

macOS 14.5

### DuckDB Version:

0.10.3

### DuckDB Client:

Python

### Full Name:

Rob Jackson

### Affiliation:

exaforce.com

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a source build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
18: 
19: ## Installation
20: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
21: 
22: ## Data Import
23: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
24: 
25: ```sql
26: SELECT * FROM 'myfile.csv';
27: SELECT * FROM 'myfile.parquet';
28: ```
29: 
30: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
31: 
32: ## SQL Reference
33: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
34: 
35: ## Development
36: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
37: 
38: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
39: 
40: ## Support
41: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/include/duckdb/main/config.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/config.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/allocator.hpp"
12: #include "duckdb/common/case_insensitive_map.hpp"
13: #include "duckdb/common/common.hpp"
14: #include "duckdb/common/enums/access_mode.hpp"
15: #include "duckdb/common/enums/compression_type.hpp"
16: #include "duckdb/common/enums/optimizer_type.hpp"
17: #include "duckdb/common/enums/order_type.hpp"
18: #include "duckdb/common/enums/set_scope.hpp"
19: #include "duckdb/common/enums/window_aggregation_mode.hpp"
20: #include "duckdb/common/file_system.hpp"
21: #include "duckdb/common/set.hpp"
22: #include "duckdb/common/types/value.hpp"
23: #include "duckdb/common/vector.hpp"
24: #include "duckdb/common/winapi.hpp"
25: #include "duckdb/function/cast/default_casts.hpp"
26: #include "duckdb/function/replacement_scan.hpp"
27: #include "duckdb/optimizer/optimizer_extension.hpp"
28: #include "duckdb/parser/parsed_data/create_info.hpp"
29: #include "duckdb/parser/parser_extension.hpp"
30: #include "duckdb/planner/operator_extension.hpp"
31: #include "duckdb/storage/compression/bitpacking.hpp"
32: #include "duckdb/main/client_properties.hpp"
33: #include "duckdb/execution/index/index_type_set.hpp"
34: 
35: namespace duckdb {
36: 
37: class BufferManager;
38: class BufferPool;
39: class CastFunctionSet;
40: class ClientContext;
41: class ErrorManager;
42: class CompressionFunction;
43: class TableFunctionRef;
44: class OperatorExtension;
45: class StorageExtension;
46: class ExtensionCallback;
47: class SecretManager;
48: 
49: struct CompressionFunctionSet;
50: struct DBConfig;
51: 
52: enum class CheckpointAbort : uint8_t {
53: 	NO_ABORT = 0,
54: 	DEBUG_ABORT_BEFORE_TRUNCATE = 1,
55: 	DEBUG_ABORT_BEFORE_HEADER = 2,
56: 	DEBUG_ABORT_AFTER_FREE_LIST_WRITE = 3
57: };
58: 
59: typedef void (*set_global_function_t)(DatabaseInstance *db, DBConfig &config, const Value &parameter);
60: typedef void (*set_local_function_t)(ClientContext &context, const Value &parameter);
61: typedef void (*reset_global_function_t)(DatabaseInstance *db, DBConfig &config);
62: typedef void (*reset_local_function_t)(ClientContext &context);
63: typedef Value (*get_setting_function_t)(const ClientContext &context);
64: 
65: struct ConfigurationOption {
66: 	const char *name;
67: 	const char *description;
68: 	LogicalTypeId parameter_type;
69: 	set_global_function_t set_global;
70: 	set_local_function_t set_local;
71: 	reset_global_function_t reset_global;
72: 	reset_local_function_t reset_local;
73: 	get_setting_function_t get_setting;
74: };
75: 
76: typedef void (*set_option_callback_t)(ClientContext &context, SetScope scope, Value &parameter);
77: 
78: struct ExtensionOption {
79: 	// NOLINTNEXTLINE: work around bug in clang-tidy
80: 	ExtensionOption(string description_p, LogicalType type_p, set_option_callback_t set_function_p,
81: 	                Value default_value_p)
82: 	    : description(std::move(description_p)), type(std::move(type_p)), set_function(set_function_p),
83: 	      default_value(std::move(default_value_p)) {
84: 	}
85: 
86: 	string description;
87: 	LogicalType type;
88: 	set_option_callback_t set_function;
89: 	Value default_value;
90: };
91: 
92: class SerializationCompatibility {
93: public:
94: 	static SerializationCompatibility FromString(const string &input);
95: 	static SerializationCompatibility Default();
96: 	static SerializationCompatibility Latest();
97: 
98: public:
99: 	bool Compare(idx_t property_version) const;
100: 
101: public:
102: 	//! The user provided version
103: 	string duckdb_version;
104: 	//! The max version that should be serialized
105: 	idx_t serialization_version;
106: 	//! Whether this was set by a manual SET/PRAGMA or default
107: 	bool manually_set;
108: 
109: protected:
110: 	SerializationCompatibility() = default;
111: };
112: 
113: struct DBConfigOptions {
114: 	//! Database file path. May be empty for in-memory mode
115: 	string database_path;
116: 	//! Database type. If empty, automatically extracted from `database_path`, where a `type:path` syntax is expected
117: 	string database_type;
118: 	//! Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE)
119: 	AccessMode access_mode = AccessMode::AUTOMATIC;
120: 	//! Checkpoint when WAL reaches this size (default: 16MB)
121: 	idx_t checkpoint_wal_size = 1 << 24;
122: 	//! Whether or not to use Direct IO, bypassing operating system buffers
123: 	bool use_direct_io = false;
124: 	//! Whether extensions should be loaded on start-up
125: 	bool load_extensions = true;
126: #ifdef DUCKDB_EXTENSION_AUTOLOAD_DEFAULT
127: 	//! Whether known extensions are allowed to be automatically loaded when a query depends on them
128: 	bool autoload_known_extensions = DUCKDB_EXTENSION_AUTOLOAD_DEFAULT;
129: #else
130: 	bool autoload_known_extensions = false;
131: #endif
132: #ifdef DUCKDB_EXTENSION_AUTOINSTALL_DEFAULT
133: 	//! Whether known extensions are allowed to be automatically installed when a query depends on them
134: 	bool autoinstall_known_extensions = DUCKDB_EXTENSION_AUTOINSTALL_DEFAULT;
135: #else
136: 	bool autoinstall_known_extensions = false;
137: #endif
138: 	//! Override for the default extension repository
139: 	string custom_extension_repo = "";
140: 	//! Override for the default autoload extension repository
141: 	string autoinstall_extension_repo = "";
142: 	//! The maximum memory used by the database system (in bytes). Default: 80% of System available memory
143: 	idx_t maximum_memory = DConstants::INVALID_INDEX;
144: 	//! The maximum size of the 'temp_directory' folder when set (in bytes). Default: 90% of available disk space.
145: 	idx_t maximum_swap_space = DConstants::INVALID_INDEX;
146: 	//! The maximum amount of CPU threads used by the database system. Default: all available.
147: 	idx_t maximum_threads = DConstants::INVALID_INDEX;
148: 	//! The number of external threads that work on DuckDB tasks. Default: 1.
149: 	//! Must be smaller or equal to maximum_threads.
150: 	idx_t external_threads = 1;
151: 	//! Whether or not to create and use a temporary directory to store intermediates that do not fit in memory
152: 	bool use_temporary_directory = true;
153: 	//! Directory to store temporary structures that do not fit in memory
154: 	string temporary_directory;
155: 	//! Whether or not to invoke filesystem trim on free blocks after checkpoint. This will reclaim
156: 	//! space for sparse files, on platforms that support it.
157: 	bool trim_free_blocks = false;
158: 	//! Record timestamps of buffer manager unpin() events. Usable by custom eviction policies.
159: 	bool buffer_manager_track_eviction_timestamps = false;
160: 	//! Whether or not to allow printing unredacted secrets
161: 	bool allow_unredacted_secrets = false;
162: 	//! The collation type of the database
163: 	string collation = string();
164: 	//! The order type used when none is specified (default: ASC)
165: 	OrderType default_order_type = OrderType::ASCENDING;
166: 	//! Null ordering used when none is specified (default: NULLS LAST)
167: 	DefaultOrderByNullType default_null_order = DefaultOrderByNullType::NULLS_LAST;
168: 	//! enable COPY and related commands
169: 	bool enable_external_access = true;
170: 	//! Whether or not object cache is used
171: 	bool object_cache_enable = false;
172: 	//! Whether or not the global http metadata cache is used
173: 	bool http_metadata_cache_enable = false;
174: 	//! Force checkpoint when CHECKPOINT is called or on shutdown, even if no changes have been made
175: 	bool force_checkpoint = false;
176: 	//! Run a checkpoint on successful shutdown and delete the WAL, to leave only a single database file behind
177: 	bool checkpoint_on_shutdown = true;
178: 	//! Serialize the metadata on checkpoint with compatibility for a given DuckDB version.
179: 	SerializationCompatibility serialization_compatibility = SerializationCompatibility::Default();
180: 	//! Debug flag that decides when a checkpoing should be aborted. Only used for testing purposes.
181: 	CheckpointAbort checkpoint_abort = CheckpointAbort::NO_ABORT;
182: 	//! Initialize the database with the standard set of DuckDB functions
183: 	//! You should probably not touch this unless you know what you are doing
184: 	bool initialize_default_database = true;
185: 	//! The set of disabled optimizers (default empty)
186: 	set<OptimizerType> disabled_optimizers;
187: 	//! Force a specific compression method to be used when checkpointing (if available)
188: 	CompressionType force_compression = CompressionType::COMPRESSION_AUTO;
189: 	//! Force a specific bitpacking mode to be used when using the bitpacking compression method
190: 	BitpackingMode force_bitpacking_mode = BitpackingMode::AUTO;
191: 	//! Debug setting for window aggregation mode: (window, combine, separate)
192: 	WindowAggregationMode window_mode = WindowAggregationMode::WINDOW;
193: 	//! Whether or not preserving insertion order should be preserved
194: 	bool preserve_insertion_order = true;
195: 	//! Whether Arrow Arrays use Large or Regular buffers
196: 	ArrowOffsetSize arrow_offset_size = ArrowOffsetSize::REGULAR;
197: 	//! Database configuration variables as controlled by SET
198: 	case_insensitive_map_t<Value> set_variables;
199: 	//! Database configuration variable default values;
200: 	case_insensitive_map_t<Value> set_variable_defaults;
201: 	//! Directory to store extension binaries in
202: 	string extension_directory;
203: 	//! Whether unsigned extensions should be loaded
204: 	bool allow_unsigned_extensions = false;
205: 	//! Whether community extensions should be loaded
206: 	bool allow_community_extensions = true;
207: 	//! Whether extensions with missing metadata should be loaded
208: 	bool allow_extensions_metadata_mismatch = false;
209: 	//! Enable emitting FSST Vectors
210: 	bool enable_fsst_vectors = false;
211: 	//! Enable VIEWs to create dependencies
212: 	bool enable_view_dependencies = false;
213: 	//! Start transactions immediately in all attached databases - instead of lazily when a database is referenced
214: 	bool immediate_transaction_mode = false;
215: 	//! Debug setting - how to initialize  blocks in the storage layer when allocating
216: 	DebugInitialize debug_initialize = DebugInitialize::NO_INITIALIZE;
217: 	//! The set of unrecognized (other) options
218: 	unordered_map<string, Value> unrecognized_options;
219: 	//! Whether or not the configuration settings can be altered
220: 	bool lock_configuration = false;
221: 	//! Whether to print bindings when printing the plan (debug mode only)
222: 	static bool debug_print_bindings; // NOLINT: debug setting
223: 	//! The peak allocation threshold at which to flush the allocator after completing a task (1 << 27, ~128MB)
224: 	idx_t allocator_flush_threshold = 134217728;
225: 	//! DuckDB API surface
226: 	string duckdb_api;
227: 	//! Metadata from DuckDB callers
228: 	string custom_user_agent;
229: 	//! Use old implicit casting style (i.e. allow everything to be implicitly casted to VARCHAR)
230: 	bool old_implicit_casting = false;
231: 	//!  Whether or not to abort if a serialization exception is thrown during WAL playback (when reading truncated WAL)
232: 	bool abort_on_wal_failure = false;
233: 
234: 	bool operator==(const DBConfigOptions &other) const;
235: };
236: 
237: struct DBConfig {
238: 	friend class DatabaseInstance;
239: 	friend class StorageManager;
240: 
241: public:
242: 	DUCKDB_API DBConfig();
243: 	explicit DUCKDB_API DBConfig(bool read_only);
244: 	DUCKDB_API DBConfig(const case_insensitive_map_t<Value> &config_dict, bool read_only);
245: 	DUCKDB_API ~DBConfig();
246: 
247: 	mutex config_lock;
248: 	//! Replacement table scans are automatically attempted when a table name cannot be found in the schema
249: 	vector<ReplacementScan> replacement_scans;
250: 
251: 	//! Extra parameters that can be SET for loaded extensions
252: 	case_insensitive_map_t<ExtensionOption> extension_parameters;
253: 	//! The FileSystem to use, can be overwritten to allow for injecting custom file systems for testing purposes (e.g.
254: 	//! RamFS or something similar)
255: 	unique_ptr<FileSystem> file_system;
256: 	//! Secret manager
257: 	unique_ptr<SecretManager> secret_manager;
258: 	//! The allocator used by the system
259: 	unique_ptr<Allocator> allocator;
260: 	//! Database configuration options
261: 	DBConfigOptions options;
262: 	//! Extensions made to the parser
263: 	vector<ParserExtension> parser_extensions;
264: 	//! Extensions made to the optimizer
265: 	vector<OptimizerExtension> optimizer_extensions;
266: 	//! Error manager
267: 	unique_ptr<ErrorManager> error_manager;
268: 	//! A reference to the (shared) default allocator (Allocator::DefaultAllocator)
269: 	shared_ptr<Allocator> default_allocator;
270: 	//! Extensions made to binder
271: 	vector<unique_ptr<OperatorExtension>> operator_extensions;
272: 	//! Extensions made to storage
273: 	case_insensitive_map_t<duckdb::unique_ptr<StorageExtension>> storage_extensions;
274: 	//! A buffer pool can be shared across multiple databases (if desired).
275: 	shared_ptr<BufferPool> buffer_pool;
276: 	//! Provide a custom buffer manager implementation (if desired).
277: 	shared_ptr<BufferManager> buffer_manager;
278: 	//! Set of callbacks that can be installed by extensions
279: 	vector<unique_ptr<ExtensionCallback>> extension_callbacks;
280: 
281: public:
282: 	DUCKDB_API static DBConfig &GetConfig(ClientContext &context);
283: 	DUCKDB_API static DBConfig &GetConfig(DatabaseInstance &db);
284: 	DUCKDB_API static DBConfig &Get(AttachedDatabase &db);
285: 	DUCKDB_API static const DBConfig &GetConfig(const ClientContext &context);
286: 	DUCKDB_API static const DBConfig &GetConfig(const DatabaseInstance &db);
287: 	DUCKDB_API static vector<ConfigurationOption> GetOptions();
288: 	DUCKDB_API static idx_t GetOptionCount();
289: 	DUCKDB_API static vector<string> GetOptionNames();
290: 	DUCKDB_API static bool IsInMemoryDatabase(const char *database_path);
291: 
292: 	DUCKDB_API void AddExtensionOption(const string &name, string description, LogicalType parameter,
293: 	                                   const Value &default_value = Value(), set_option_callback_t function = nullptr);
294: 	//! Fetch an option by index. Returns a pointer to the option, or nullptr if out of range
295: 	DUCKDB_API static optional_ptr<const ConfigurationOption> GetOptionByIndex(idx_t index);
296: 	//! Fetch an option by name. Returns a pointer to the option, or nullptr if none exists.
297: 	DUCKDB_API static optional_ptr<const ConfigurationOption> GetOptionByName(const string &name);
298: 	DUCKDB_API void SetOption(const ConfigurationOption &option, const Value &value);
299: 	DUCKDB_API void SetOption(DatabaseInstance *db, const ConfigurationOption &option, const Value &value);
300: 	DUCKDB_API void SetOptionByName(const string &name, const Value &value);
301: 	DUCKDB_API void SetOptionsByName(const case_insensitive_map_t<Value> &values);
302: 	DUCKDB_API void ResetOption(DatabaseInstance *db, const ConfigurationOption &option);
303: 	DUCKDB_API void SetOption(const string &name, Value value);
304: 	DUCKDB_API void ResetOption(const string &name);
305: 
306: 	DUCKDB_API void CheckLock(const string &name);
307: 
308: 	DUCKDB_API static idx_t ParseMemoryLimit(const string &arg);
309: 
310: 	//! Return the list of possible compression functions for the specific physical type
311: 	DUCKDB_API vector<reference<CompressionFunction>> GetCompressionFunctions(PhysicalType data_type);
312: 	//! Return the compression function for the specified compression type/physical type combo
313: 	DUCKDB_API optional_ptr<CompressionFunction> GetCompressionFunction(CompressionType type, PhysicalType data_type);
314: 
315: 	bool operator==(const DBConfig &other);
316: 	bool operator!=(const DBConfig &other);
317: 
318: 	DUCKDB_API CastFunctionSet &GetCastFunctions();
319: 	DUCKDB_API IndexTypeSet &GetIndexTypes();
320: 	static idx_t GetSystemMaxThreads(FileSystem &fs);
321: 	void SetDefaultMaxMemory();
322: 	void SetDefaultTempDirectory();
323: 
324: 	OrderType ResolveOrder(OrderType order_type) const;
325: 	OrderByNullType ResolveNullOrder(OrderType order_type, OrderByNullType null_type) const;
326: 	const std::string UserAgent() const;
327: 
328: private:
329: 	unique_ptr<CompressionFunctionSet> compression_functions;
330: 	unique_ptr<CastFunctionSet> cast_functions;
331: 	unique_ptr<IndexTypeSet> index_types;
332: };
333: 
334: } // namespace duckdb
[end of src/include/duckdb/main/config.hpp]
[start of src/include/duckdb/main/settings.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/settings.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types/value.hpp"
13: 
14: namespace duckdb {
15: class ClientContext;
16: class DatabaseInstance;
17: struct DBConfig;
18: 
19: const string GetDefaultUserAgent();
20: 
21: enum class SettingScope : uint8_t { GLOBAL, LOCAL, INVALID };
22: 
23: struct SettingLookupResult {
24: public:
25: 	SettingLookupResult() : scope(SettingScope::INVALID) {
26: 	}
27: 	explicit SettingLookupResult(SettingScope scope) : scope(scope) {
28: 		D_ASSERT(scope != SettingScope::INVALID);
29: 	}
30: 
31: public:
32: 	operator bool() { // NOLINT: allow implicit conversion to bool
33: 		return scope != SettingScope::INVALID;
34: 	}
35: 
36: public:
37: 	SettingScope GetScope() {
38: 		D_ASSERT(scope != SettingScope::INVALID);
39: 		return scope;
40: 	}
41: 
42: private:
43: 	SettingScope scope = SettingScope::INVALID;
44: };
45: 
46: struct AccessModeSetting {
47: 	static constexpr const char *Name = "access_mode";
48: 	static constexpr const char *Description = "Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE)";
49: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
50: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
51: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
52: 	static Value GetSetting(const ClientContext &context);
53: };
54: 
55: struct AllowPersistentSecrets {
56: 	static constexpr const char *Name = "allow_persistent_secrets";
57: 	static constexpr const char *Description =
58: 	    "Allow the creation of persistent secrets, that are stored and loaded on restarts";
59: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
60: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
61: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
62: 	static Value GetSetting(const ClientContext &context);
63: };
64: 
65: struct CheckpointThresholdSetting {
66: 	static constexpr const char *Name = "checkpoint_threshold";
67: 	static constexpr const char *Description =
68: 	    "The WAL size threshold at which to automatically trigger a checkpoint (e.g. 1GB)";
69: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
70: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
71: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
72: 	static Value GetSetting(const ClientContext &context);
73: };
74: 
75: struct DebugCheckpointAbort {
76: 	static constexpr const char *Name = "debug_checkpoint_abort";
77: 	static constexpr const char *Description =
78: 	    "DEBUG SETTING: trigger an abort while checkpointing for testing purposes";
79: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
80: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
81: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
82: 	static Value GetSetting(const ClientContext &context);
83: };
84: 
85: struct DebugForceExternal {
86: 	static constexpr const char *Name = "debug_force_external";
87: 	static constexpr const char *Description =
88: 	    "DEBUG SETTING: force out-of-core computation for operators that support it, used for testing";
89: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
90: 	static void SetLocal(ClientContext &context, const Value &parameter);
91: 	static void ResetLocal(ClientContext &context);
92: 	static Value GetSetting(const ClientContext &context);
93: };
94: 
95: struct DebugForceNoCrossProduct {
96: 	static constexpr const char *Name = "debug_force_no_cross_product";
97: 	static constexpr const char *Description =
98: 	    "DEBUG SETTING: Force disable cross product generation when hyper graph isn't connected, used for testing";
99: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
100: 	static void SetLocal(ClientContext &context, const Value &parameter);
101: 	static void ResetLocal(ClientContext &context);
102: 	static Value GetSetting(const ClientContext &context);
103: };
104: 
105: struct OrderedAggregateThreshold {
106: 	static constexpr const char *Name = "ordered_aggregate_threshold"; // NOLINT
107: 	static constexpr const char *Description =                         // NOLINT
108: 	    "The number of rows to accumulate before sorting, used for tuning";
109: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT; // NOLINT
110: 	static void SetLocal(ClientContext &context, const Value &parameter);
111: 	static void ResetLocal(ClientContext &context);
112: 	static Value GetSetting(const ClientContext &context);
113: };
114: 
115: struct DebugAsOfIEJoin {
116: 	static constexpr const char *Name = "debug_asof_iejoin";                                                 // NOLINT
117: 	static constexpr const char *Description = "DEBUG SETTING: force use of IEJoin to implement AsOf joins"; // NOLINT
118: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;                                 // NOLINT
119: 	static void SetLocal(ClientContext &context, const Value &parameter);
120: 	static void ResetLocal(ClientContext &context);
121: 	static Value GetSetting(const ClientContext &context);
122: };
123: 
124: struct PreferRangeJoins {
125: 	static constexpr const char *Name = "prefer_range_joins";                                    // NOLINT
126: 	static constexpr const char *Description = "Force use of range joins with mixed predicates"; // NOLINT
127: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;                     // NOLINT
128: 	static void SetLocal(ClientContext &context, const Value &parameter);
129: 	static void ResetLocal(ClientContext &context);
130: 	static Value GetSetting(const ClientContext &context);
131: };
132: 
133: struct DebugWindowMode {
134: 	static constexpr const char *Name = "debug_window_mode";
135: 	static constexpr const char *Description = "DEBUG SETTING: switch window mode to use";
136: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
137: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
138: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
139: 	static Value GetSetting(const ClientContext &context);
140: };
141: 
142: struct DefaultCollationSetting {
143: 	static constexpr const char *Name = "default_collation";
144: 	static constexpr const char *Description = "The collation setting used when none is specified";
145: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
146: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
147: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
148: 	static void SetLocal(ClientContext &context, const Value &parameter);
149: 	static void ResetLocal(ClientContext &context);
150: 	static Value GetSetting(const ClientContext &context);
151: };
152: 
153: struct DefaultOrderSetting {
154: 	static constexpr const char *Name = "default_order";
155: 	static constexpr const char *Description = "The order type used when none is specified (ASC or DESC)";
156: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
157: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
158: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
159: 	static Value GetSetting(const ClientContext &context);
160: };
161: 
162: struct DefaultNullOrderSetting {
163: 	static constexpr const char *Name = "default_null_order";
164: 	static constexpr const char *Description = "Null ordering used when none is specified (NULLS_FIRST or NULLS_LAST)";
165: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
166: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
167: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
168: 	static Value GetSetting(const ClientContext &context);
169: };
170: 
171: struct DefaultSecretStorage {
172: 	static constexpr const char *Name = "default_secret_storage";
173: 	static constexpr const char *Description = "Allows switching the default storage for secrets";
174: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
175: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
176: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
177: 	static Value GetSetting(const ClientContext &context);
178: };
179: 
180: struct DisabledFileSystemsSetting {
181: 	static constexpr const char *Name = "disabled_filesystems";
182: 	static constexpr const char *Description = "Disable specific file systems preventing access (e.g. LocalFileSystem)";
183: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
184: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
185: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
186: 	static Value GetSetting(const ClientContext &context);
187: };
188: 
189: struct DisabledOptimizersSetting {
190: 	static constexpr const char *Name = "disabled_optimizers";
191: 	static constexpr const char *Description = "DEBUG SETTING: disable a specific set of optimizers (comma separated)";
192: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
193: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
194: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
195: 	static Value GetSetting(const ClientContext &context);
196: };
197: 
198: struct EnableExternalAccessSetting {
199: 	static constexpr const char *Name = "enable_external_access";
200: 	static constexpr const char *Description =
201: 	    "Allow the database to access external state (through e.g. loading/installing modules, COPY TO/FROM, CSV "
202: 	    "readers, pandas replacement scans, etc)";
203: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
204: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
205: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
206: 	static Value GetSetting(const ClientContext &context);
207: };
208: 
209: struct EnableViewDependencies {
210: 	static constexpr const char *Name = "enable_view_dependencies";
211: 	static constexpr const char *Description =
212: 	    "Enable created VIEWs to create dependencies on the referenced objects (such as tables)";
213: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
214: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
215: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
216: 	static Value GetSetting(const ClientContext &context);
217: };
218: 
219: struct EnableFSSTVectors {
220: 	static constexpr const char *Name = "enable_fsst_vectors";
221: 	static constexpr const char *Description =
222: 	    "Allow scans on FSST compressed segments to emit compressed vectors to utilize late decompression";
223: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
224: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
225: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
226: 	static Value GetSetting(const ClientContext &context);
227: };
228: 
229: struct AllowUnsignedExtensionsSetting {
230: 	static constexpr const char *Name = "allow_unsigned_extensions";
231: 	static constexpr const char *Description = "Allow to load extensions with invalid or missing signatures";
232: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
233: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
234: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
235: 	static Value GetSetting(const ClientContext &context);
236: };
237: 
238: struct AllowCommunityExtensionsSetting {
239: 	static constexpr const char *Name = "allow_community_extensions";
240: 	static constexpr const char *Description = "Allow to load community built extensions";
241: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
242: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
243: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
244: 	static Value GetSetting(const ClientContext &context);
245: };
246: 
247: struct AllowExtensionsMetadataMismatchSetting {
248: 	static constexpr const char *Name = "allow_extensions_metadata_mismatch";
249: 	static constexpr const char *Description = "Allow to load extensions with not compatible metadata";
250: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
251: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
252: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
253: 	static Value GetSetting(const ClientContext &context);
254: };
255: 
256: struct AllowUnredactedSecretsSetting {
257: 	static constexpr const char *Name = "allow_unredacted_secrets";
258: 	static constexpr const char *Description = "Allow printing unredacted secrets";
259: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
260: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
261: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
262: 	static Value GetSetting(const ClientContext &context);
263: };
264: 
265: struct CustomExtensionRepository {
266: 	static constexpr const char *Name = "custom_extension_repository";
267: 	static constexpr const char *Description = "Overrides the custom endpoint for remote extension installation";
268: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
269: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
270: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
271: 	static Value GetSetting(const ClientContext &context);
272: };
273: 
274: struct AutoloadExtensionRepository {
275: 	static constexpr const char *Name = "autoinstall_extension_repository";
276: 	static constexpr const char *Description =
277: 	    "Overrides the custom endpoint for extension installation on autoloading";
278: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
279: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
280: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
281: 	static Value GetSetting(const ClientContext &context);
282: };
283: 
284: struct AutoinstallKnownExtensions {
285: 	static constexpr const char *Name = "autoinstall_known_extensions";
286: 	static constexpr const char *Description =
287: 	    "Whether known extensions are allowed to be automatically installed when a query depends on them";
288: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
289: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
290: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
291: 	static Value GetSetting(const ClientContext &context);
292: };
293: 
294: struct AutoloadKnownExtensions {
295: 	static constexpr const char *Name = "autoload_known_extensions";
296: 	static constexpr const char *Description =
297: 	    "Whether known extensions are allowed to be automatically loaded when a query depends on them";
298: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
299: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
300: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
301: 	static Value GetSetting(const ClientContext &context);
302: };
303: 
304: struct EnableObjectCacheSetting {
305: 	static constexpr const char *Name = "enable_object_cache";
306: 	static constexpr const char *Description = "Whether or not object cache is used to cache e.g. Parquet metadata";
307: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
308: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
309: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
310: 	static Value GetSetting(const ClientContext &context);
311: };
312: 
313: struct StorageCompatibilityVersion {
314: 	static constexpr const char *Name = "storage_compatibility_version";
315: 	static constexpr const char *Description = "Serialize on checkpoint with compatibility for a given duckdb version";
316: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
317: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
318: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
319: 	static Value GetSetting(const ClientContext &context);
320: };
321: 
322: struct EnableHTTPMetadataCacheSetting {
323: 	static constexpr const char *Name = "enable_http_metadata_cache";
324: 	static constexpr const char *Description = "Whether or not the global http metadata is used to cache HTTP metadata";
325: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
326: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
327: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
328: 	static Value GetSetting(const ClientContext &context);
329: };
330: 
331: struct EnableProfilingSetting {
332: 	static constexpr const char *Name = "enable_profiling";
333: 	static constexpr const char *Description =
334: 	    "Enables profiling, and sets the output format (JSON, QUERY_TREE, QUERY_TREE_OPTIMIZER)";
335: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
336: 	static void SetLocal(ClientContext &context, const Value &parameter);
337: 	static void ResetLocal(ClientContext &context);
338: 	static Value GetSetting(const ClientContext &context);
339: };
340: 
341: struct EnableProgressBarSetting {
342: 	static constexpr const char *Name = "enable_progress_bar";
343: 	static constexpr const char *Description =
344: 	    "Enables the progress bar, printing progress to the terminal for long queries";
345: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
346: 	static void SetLocal(ClientContext &context, const Value &parameter);
347: 	static void ResetLocal(ClientContext &context);
348: 	static Value GetSetting(const ClientContext &context);
349: };
350: 
351: struct EnableProgressBarPrintSetting {
352: 	static constexpr const char *Name = "enable_progress_bar_print";
353: 	static constexpr const char *Description =
354: 	    "Controls the printing of the progress bar, when 'enable_progress_bar' is true";
355: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
356: 	static void SetLocal(ClientContext &context, const Value &parameter);
357: 	static void ResetLocal(ClientContext &context);
358: 	static Value GetSetting(const ClientContext &context);
359: };
360: 
361: struct ErrorsAsJsonSetting {
362: 	static constexpr const char *Name = "errors_as_json";
363: 	static constexpr const char *Description = "Output error messages as structured JSON instead of as a raw string";
364: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
365: 	static void SetLocal(ClientContext &context, const Value &parameter);
366: 	static void ResetLocal(ClientContext &context);
367: 	static Value GetSetting(const ClientContext &context);
368: };
369: 
370: struct ExplainOutputSetting {
371: 	static constexpr const char *Name = "explain_output";
372: 	static constexpr const char *Description = "Output of EXPLAIN statements (ALL, OPTIMIZED_ONLY, PHYSICAL_ONLY)";
373: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
374: 	static void SetLocal(ClientContext &context, const Value &parameter);
375: 	static void ResetLocal(ClientContext &context);
376: 	static Value GetSetting(const ClientContext &context);
377: };
378: 
379: struct ExportLargeBufferArrow {
380: 	static constexpr const char *Name = "arrow_large_buffer_size";
381: 	static constexpr const char *Description =
382: 	    "If arrow buffers for strings, blobs, uuids and bits should be exported using large buffers";
383: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
384: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
385: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
386: 	static Value GetSetting(const ClientContext &context);
387: };
388: 
389: struct ExtensionDirectorySetting {
390: 	static constexpr const char *Name = "extension_directory";
391: 	static constexpr const char *Description = "Set the directory to store extensions in";
392: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
393: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
394: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
395: 	static Value GetSetting(const ClientContext &context);
396: };
397: 
398: struct ExternalThreadsSetting {
399: 	static constexpr const char *Name = "external_threads";
400: 	static constexpr const char *Description = "The number of external threads that work on DuckDB tasks.";
401: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
402: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
403: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
404: 	static Value GetSetting(const ClientContext &context);
405: };
406: 
407: struct FileSearchPathSetting {
408: 	static constexpr const char *Name = "file_search_path";
409: 	static constexpr const char *Description = "A comma separated list of directories to search for input files";
410: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
411: 	static void SetLocal(ClientContext &context, const Value &parameter);
412: 	static void ResetLocal(ClientContext &context);
413: 	static Value GetSetting(const ClientContext &context);
414: };
415: 
416: struct ForceCompressionSetting {
417: 	static constexpr const char *Name = "force_compression";
418: 	static constexpr const char *Description = "DEBUG SETTING: forces a specific compression method to be used";
419: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
420: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
421: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
422: 	static Value GetSetting(const ClientContext &context);
423: };
424: 
425: struct ForceBitpackingModeSetting {
426: 	static constexpr const char *Name = "force_bitpacking_mode";
427: 	static constexpr const char *Description = "DEBUG SETTING: forces a specific bitpacking mode";
428: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
429: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
430: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
431: 	static Value GetSetting(const ClientContext &context);
432: };
433: 
434: struct HomeDirectorySetting {
435: 	static constexpr const char *Name = "home_directory";
436: 	static constexpr const char *Description = "Sets the home directory used by the system";
437: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
438: 	static void SetLocal(ClientContext &context, const Value &parameter);
439: 	static void ResetLocal(ClientContext &context);
440: 	static Value GetSetting(const ClientContext &context);
441: };
442: 
443: struct IntegerDivisionSetting {
444: 	static constexpr const char *Name = "integer_division";
445: 	static constexpr const char *Description =
446: 	    "Whether or not the / operator defaults to integer division, or to floating point division";
447: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
448: 	static void SetLocal(ClientContext &context, const Value &parameter);
449: 	static void ResetLocal(ClientContext &context);
450: 	static Value GetSetting(const ClientContext &context);
451: };
452: 
453: struct LogQueryPathSetting {
454: 	static constexpr const char *Name = "log_query_path";
455: 	static constexpr const char *Description =
456: 	    "Specifies the path to which queries should be logged (default: NULL, queries are not logged)";
457: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
458: 	static void SetLocal(ClientContext &context, const Value &parameter);
459: 	static void ResetLocal(ClientContext &context);
460: 	static Value GetSetting(const ClientContext &context);
461: };
462: 
463: struct LockConfigurationSetting {
464: 	static constexpr const char *Name = "lock_configuration";
465: 	static constexpr const char *Description = "Whether or not the configuration can be altered";
466: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
467: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
468: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
469: 	static Value GetSetting(const ClientContext &context);
470: };
471: 
472: struct ImmediateTransactionModeSetting {
473: 	static constexpr const char *Name = "immediate_transaction_mode";
474: 	static constexpr const char *Description =
475: 	    "Whether transactions should be started lazily when needed, or immediately when BEGIN TRANSACTION is called";
476: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
477: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
478: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
479: 	static Value GetSetting(const ClientContext &context);
480: };
481: 
482: struct MaximumExpressionDepthSetting {
483: 	static constexpr const char *Name = "max_expression_depth";
484: 	static constexpr const char *Description =
485: 	    "The maximum expression depth limit in the parser. WARNING: increasing this setting and using very deep "
486: 	    "expressions might lead to stack overflow errors.";
487: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;
488: 	static void SetLocal(ClientContext &context, const Value &parameter);
489: 	static void ResetLocal(ClientContext &context);
490: 	static Value GetSetting(const ClientContext &context);
491: };
492: 
493: struct MaximumMemorySetting {
494: 	static constexpr const char *Name = "max_memory";
495: 	static constexpr const char *Description = "The maximum memory of the system (e.g. 1GB)";
496: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
497: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
498: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
499: 	static Value GetSetting(const ClientContext &context);
500: };
501: 
502: struct MaximumTempDirectorySize {
503: 	static constexpr const char *Name = "max_temp_directory_size";
504: 	static constexpr const char *Description =
505: 	    "The maximum amount of data stored inside the 'temp_directory' (when set) (e.g. 1GB)";
506: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
507: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
508: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
509: 	static Value GetSetting(const ClientContext &context);
510: };
511: 
512: struct OldImplicitCasting {
513: 	static constexpr const char *Name = "old_implicit_casting";
514: 	static constexpr const char *Description = "Allow implicit casting to/from VARCHAR";
515: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
516: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
517: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
518: 	static Value GetSetting(const ClientContext &context);
519: };
520: 
521: struct PartitionedWriteFlushThreshold {
522: 	static constexpr const char *Name = "partitioned_write_flush_threshold";
523: 	static constexpr const char *Description =
524: 	    "The threshold in number of rows after which we flush a thread state when writing using PARTITION_BY";
525: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
526: 	static void SetLocal(ClientContext &context, const Value &parameter);
527: 	static void ResetLocal(ClientContext &context);
528: 	static Value GetSetting(const ClientContext &context);
529: };
530: 
531: struct PasswordSetting {
532: 	static constexpr const char *Name = "password";
533: 	static constexpr const char *Description = "The password to use. Ignored for legacy compatibility.";
534: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
535: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
536: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
537: 	static Value GetSetting(const ClientContext &context);
538: };
539: 
540: struct PerfectHashThresholdSetting {
541: 	static constexpr const char *Name = "perfect_ht_threshold";
542: 	static constexpr const char *Description = "Threshold in bytes for when to use a perfect hash table";
543: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
544: 	static void SetLocal(ClientContext &context, const Value &parameter);
545: 	static void ResetLocal(ClientContext &context);
546: 	static Value GetSetting(const ClientContext &context);
547: };
548: 
549: struct PivotFilterThreshold {
550: 	static constexpr const char *Name = "pivot_filter_threshold";
551: 	static constexpr const char *Description =
552: 	    "The threshold to switch from using filtered aggregates to LIST with a dedicated pivot operator";
553: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
554: 	static void SetLocal(ClientContext &context, const Value &parameter);
555: 	static void ResetLocal(ClientContext &context);
556: 	static Value GetSetting(const ClientContext &context);
557: };
558: 
559: struct PivotLimitSetting {
560: 	static constexpr const char *Name = "pivot_limit";
561: 	static constexpr const char *Description = "The maximum number of pivot columns in a pivot statement";
562: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
563: 	static void SetLocal(ClientContext &context, const Value &parameter);
564: 	static void ResetLocal(ClientContext &context);
565: 	static Value GetSetting(const ClientContext &context);
566: };
567: 
568: struct PreserveIdentifierCase {
569: 	static constexpr const char *Name = "preserve_identifier_case";
570: 	static constexpr const char *Description =
571: 	    "Whether or not to preserve the identifier case, instead of always lowercasing all non-quoted identifiers";
572: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
573: 	static void SetLocal(ClientContext &context, const Value &parameter);
574: 	static void ResetLocal(ClientContext &context);
575: 	static Value GetSetting(const ClientContext &context);
576: };
577: 
578: struct PreserveInsertionOrder {
579: 	static constexpr const char *Name = "preserve_insertion_order";
580: 	static constexpr const char *Description =
581: 	    "Whether or not to preserve insertion order. If set to false the system is allowed to re-order any results "
582: 	    "that do not contain ORDER BY clauses.";
583: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
584: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
585: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
586: 	static Value GetSetting(const ClientContext &context);
587: };
588: 
589: struct ProfileOutputSetting {
590: 	static constexpr const char *Name = "profile_output";
591: 	static constexpr const char *Description =
592: 	    "The file to which profile output should be saved, or empty to print to the terminal";
593: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
594: 	static void SetLocal(ClientContext &context, const Value &parameter);
595: 	static void ResetLocal(ClientContext &context);
596: 	static Value GetSetting(const ClientContext &context);
597: };
598: 
599: struct ProfilingModeSetting {
600: 	static constexpr const char *Name = "profiling_mode";
601: 	static constexpr const char *Description = "The profiling mode (STANDARD or DETAILED)";
602: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
603: 	static void SetLocal(ClientContext &context, const Value &parameter);
604: 	static void ResetLocal(ClientContext &context);
605: 	static Value GetSetting(const ClientContext &context);
606: };
607: 
608: struct ProgressBarTimeSetting {
609: 	static constexpr const char *Name = "progress_bar_time";
610: 	static constexpr const char *Description =
611: 	    "Sets the time (in milliseconds) how long a query needs to take before we start printing a progress bar";
612: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
613: 	static void SetLocal(ClientContext &context, const Value &parameter);
614: 	static void ResetLocal(ClientContext &context);
615: 	static Value GetSetting(const ClientContext &context);
616: };
617: 
618: struct SchemaSetting {
619: 	static constexpr const char *Name = "schema";
620: 	static constexpr const char *Description =
621: 	    "Sets the default search schema. Equivalent to setting search_path to a single value.";
622: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
623: 	static void SetLocal(ClientContext &context, const Value &parameter);
624: 	static void ResetLocal(ClientContext &context);
625: 	static Value GetSetting(const ClientContext &context);
626: };
627: 
628: struct SearchPathSetting {
629: 	static constexpr const char *Name = "search_path";
630: 	static constexpr const char *Description =
631: 	    "Sets the default catalog search path as a comma-separated list of values";
632: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
633: 	static void SetLocal(ClientContext &context, const Value &parameter);
634: 	static void ResetLocal(ClientContext &context);
635: 	static Value GetSetting(const ClientContext &context);
636: };
637: 
638: struct SecretDirectorySetting {
639: 	static constexpr const char *Name = "secret_directory";
640: 	static constexpr const char *Description = "Set the directory to which persistent secrets are stored";
641: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
642: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
643: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
644: 	static Value GetSetting(const ClientContext &context);
645: };
646: 
647: struct TempDirectorySetting {
648: 	static constexpr const char *Name = "temp_directory";
649: 	static constexpr const char *Description = "Set the directory to which to write temp files";
650: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
651: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
652: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
653: 	static Value GetSetting(const ClientContext &context);
654: };
655: 
656: struct ThreadsSetting {
657: 	static constexpr const char *Name = "threads";
658: 	static constexpr const char *Description = "The number of total threads used by the system.";
659: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
660: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
661: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
662: 	static Value GetSetting(const ClientContext &context);
663: };
664: 
665: struct UsernameSetting {
666: 	static constexpr const char *Name = "username";
667: 	static constexpr const char *Description = "The username to use. Ignored for legacy compatibility.";
668: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
669: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
670: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
671: 	static Value GetSetting(const ClientContext &context);
672: };
673: 
674: struct FlushAllocatorSetting {
675: 	static constexpr const char *Name = "allocator_flush_threshold";
676: 	static constexpr const char *Description =
677: 	    "Peak allocation threshold at which to flush the allocator after completing a task.";
678: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
679: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
680: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
681: 	static Value GetSetting(const ClientContext &context);
682: };
683: 
684: struct DuckDBApiSetting {
685: 	static constexpr const char *Name = "duckdb_api";
686: 	static constexpr const char *Description = "DuckDB API surface";
687: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
688: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
689: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
690: 	static Value GetSetting(const ClientContext &context);
691: };
692: 
693: struct CustomUserAgentSetting {
694: 	static constexpr const char *Name = "custom_user_agent";
695: 	static constexpr const char *Description = "Metadata from DuckDB callers";
696: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
697: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
698: 	static void ResetGlobal(DatabaseInstance *db, DBConfig &config);
699: 	static Value GetSetting(const ClientContext &context);
700: };
701: 
702: struct EnableHTTPLoggingSetting {
703: 	static constexpr const char *Name = "enable_http_logging";
704: 	static constexpr const char *Description = "Enables HTTP logging";
705: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
706: 	static void SetLocal(ClientContext &context, const Value &parameter);
707: 	static void ResetLocal(ClientContext &context);
708: 	static Value GetSetting(const ClientContext &context);
709: };
710: 
711: struct HTTPLoggingOutputSetting {
712: 	static constexpr const char *Name = "http_logging_output";
713: 	static constexpr const char *Description =
714: 	    "The file to which HTTP logging output should be saved, or empty to print to the terminal";
715: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
716: 	static void SetLocal(ClientContext &context, const Value &parameter);
717: 	static void ResetLocal(ClientContext &context);
718: 	static Value GetSetting(const ClientContext &context);
719: };
720: 
721: } // namespace duckdb
[end of src/include/duckdb/main/settings.hpp]
[start of src/main/config.cpp]
1: #include "duckdb/main/config.hpp"
2: 
3: #include "duckdb/common/operator/multiply.hpp"
4: #include "duckdb/common/operator/cast_operators.hpp"
5: #include "duckdb/common/string_util.hpp"
6: #include "duckdb/main/settings.hpp"
7: #include "duckdb/storage/storage_extension.hpp"
8: 
9: #ifndef DUCKDB_NO_THREADS
10: #include "duckdb/common/thread.hpp"
11: #endif
12: 
13: #include <cinttypes>
14: #include <cstdio>
15: 
16: namespace duckdb {
17: 
18: #ifdef DEBUG
19: bool DBConfigOptions::debug_print_bindings = false;
20: #endif
21: 
22: #define DUCKDB_GLOBAL(_PARAM)                                                                                          \
23: 	{                                                                                                                  \
24: 		_PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::ResetGlobal,         \
25: 		    nullptr, _PARAM::GetSetting                                                                                \
26: 	}
27: #define DUCKDB_GLOBAL_ALIAS(_ALIAS, _PARAM)                                                                            \
28: 	{                                                                                                                  \
29: 		_ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::ResetGlobal, nullptr,      \
30: 		    _PARAM::GetSetting                                                                                         \
31: 	}
32: 
33: #define DUCKDB_LOCAL(_PARAM)                                                                                           \
34: 	{                                                                                                                  \
35: 		_PARAM::Name, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, nullptr, _PARAM::ResetLocal,  \
36: 		    _PARAM::GetSetting                                                                                         \
37: 	}
38: #define DUCKDB_LOCAL_ALIAS(_ALIAS, _PARAM)                                                                             \
39: 	{                                                                                                                  \
40: 		_ALIAS, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, nullptr, _PARAM::ResetLocal,        \
41: 		    _PARAM::GetSetting                                                                                         \
42: 	}
43: 
44: #define DUCKDB_GLOBAL_LOCAL(_PARAM)                                                                                    \
45: 	{                                                                                                                  \
46: 		_PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal,                     \
47: 		    _PARAM::ResetGlobal, _PARAM::ResetLocal, _PARAM::GetSetting                                                \
48: 	}
49: #define DUCKDB_GLOBAL_LOCAL_ALIAS(_ALIAS, _PARAM)                                                                      \
50: 	{                                                                                                                  \
51: 		_ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal, _PARAM::ResetGlobal,      \
52: 		    _PARAM::ResetLocal, _PARAM::GetSetting                                                                     \
53: 	}
54: #define FINAL_SETTING                                                                                                  \
55: 	{ nullptr, nullptr, LogicalTypeId::INVALID, nullptr, nullptr, nullptr, nullptr, nullptr }
56: 
57: static const ConfigurationOption internal_options[] = {
58:     DUCKDB_GLOBAL(AccessModeSetting),
59:     DUCKDB_GLOBAL(AllowPersistentSecrets),
60:     DUCKDB_GLOBAL(CheckpointThresholdSetting),
61:     DUCKDB_GLOBAL(DebugCheckpointAbort),
62:     DUCKDB_GLOBAL(StorageCompatibilityVersion),
63:     DUCKDB_LOCAL(DebugForceExternal),
64:     DUCKDB_LOCAL(DebugForceNoCrossProduct),
65:     DUCKDB_LOCAL(DebugAsOfIEJoin),
66:     DUCKDB_LOCAL(PreferRangeJoins),
67:     DUCKDB_GLOBAL(DebugWindowMode),
68:     DUCKDB_GLOBAL_LOCAL(DefaultCollationSetting),
69:     DUCKDB_GLOBAL(DefaultOrderSetting),
70:     DUCKDB_GLOBAL(DefaultNullOrderSetting),
71:     DUCKDB_GLOBAL(DisabledFileSystemsSetting),
72:     DUCKDB_GLOBAL(DisabledOptimizersSetting),
73:     DUCKDB_GLOBAL(EnableExternalAccessSetting),
74:     DUCKDB_GLOBAL(EnableFSSTVectors),
75:     DUCKDB_GLOBAL(AllowUnsignedExtensionsSetting),
76:     DUCKDB_GLOBAL(AllowCommunityExtensionsSetting),
77:     DUCKDB_GLOBAL(AllowExtensionsMetadataMismatchSetting),
78:     DUCKDB_GLOBAL(AllowUnredactedSecretsSetting),
79:     DUCKDB_GLOBAL(CustomExtensionRepository),
80:     DUCKDB_GLOBAL(AutoloadExtensionRepository),
81:     DUCKDB_GLOBAL(AutoinstallKnownExtensions),
82:     DUCKDB_GLOBAL(AutoloadKnownExtensions),
83:     DUCKDB_GLOBAL(EnableObjectCacheSetting),
84:     DUCKDB_GLOBAL(EnableHTTPMetadataCacheSetting),
85:     DUCKDB_LOCAL(EnableProfilingSetting),
86:     DUCKDB_LOCAL(EnableProgressBarSetting),
87:     DUCKDB_LOCAL(EnableProgressBarPrintSetting),
88:     DUCKDB_LOCAL(ErrorsAsJsonSetting),
89:     DUCKDB_LOCAL(ExplainOutputSetting),
90:     DUCKDB_GLOBAL(ExtensionDirectorySetting),
91:     DUCKDB_GLOBAL(ExternalThreadsSetting),
92:     DUCKDB_LOCAL(FileSearchPathSetting),
93:     DUCKDB_GLOBAL(ForceCompressionSetting),
94:     DUCKDB_GLOBAL(ForceBitpackingModeSetting),
95:     DUCKDB_LOCAL(HomeDirectorySetting),
96:     DUCKDB_LOCAL(LogQueryPathSetting),
97:     DUCKDB_GLOBAL(EnableViewDependencies),
98:     DUCKDB_GLOBAL(LockConfigurationSetting),
99:     DUCKDB_GLOBAL(ImmediateTransactionModeSetting),
100:     DUCKDB_LOCAL(IntegerDivisionSetting),
101:     DUCKDB_LOCAL(MaximumExpressionDepthSetting),
102:     DUCKDB_GLOBAL(MaximumMemorySetting),
103:     DUCKDB_GLOBAL(MaximumTempDirectorySize),
104:     DUCKDB_GLOBAL(OldImplicitCasting),
105:     DUCKDB_GLOBAL_ALIAS("memory_limit", MaximumMemorySetting),
106:     DUCKDB_GLOBAL_ALIAS("null_order", DefaultNullOrderSetting),
107:     DUCKDB_LOCAL(OrderedAggregateThreshold),
108:     DUCKDB_GLOBAL(PasswordSetting),
109:     DUCKDB_LOCAL(PerfectHashThresholdSetting),
110:     DUCKDB_LOCAL(PivotFilterThreshold),
111:     DUCKDB_LOCAL(PivotLimitSetting),
112:     DUCKDB_LOCAL(PreserveIdentifierCase),
113:     DUCKDB_GLOBAL(PreserveInsertionOrder),
114:     DUCKDB_LOCAL(ProfileOutputSetting),
115:     DUCKDB_LOCAL(ProfilingModeSetting),
116:     DUCKDB_LOCAL_ALIAS("profiling_output", ProfileOutputSetting),
117:     DUCKDB_LOCAL(ProgressBarTimeSetting),
118:     DUCKDB_LOCAL(SchemaSetting),
119:     DUCKDB_LOCAL(SearchPathSetting),
120:     DUCKDB_GLOBAL(SecretDirectorySetting),
121:     DUCKDB_GLOBAL(DefaultSecretStorage),
122:     DUCKDB_GLOBAL(TempDirectorySetting),
123:     DUCKDB_GLOBAL(ThreadsSetting),
124:     DUCKDB_GLOBAL(UsernameSetting),
125:     DUCKDB_GLOBAL(ExportLargeBufferArrow),
126:     DUCKDB_GLOBAL_ALIAS("user", UsernameSetting),
127:     DUCKDB_GLOBAL_ALIAS("wal_autocheckpoint", CheckpointThresholdSetting),
128:     DUCKDB_GLOBAL_ALIAS("worker_threads", ThreadsSetting),
129:     DUCKDB_GLOBAL(FlushAllocatorSetting),
130:     DUCKDB_GLOBAL(DuckDBApiSetting),
131:     DUCKDB_GLOBAL(CustomUserAgentSetting),
132:     DUCKDB_LOCAL(PartitionedWriteFlushThreshold),
133:     DUCKDB_LOCAL(EnableHTTPLoggingSetting),
134:     DUCKDB_LOCAL(HTTPLoggingOutputSetting),
135:     FINAL_SETTING};
136: 
137: vector<ConfigurationOption> DBConfig::GetOptions() {
138: 	vector<ConfigurationOption> options;
139: 	for (idx_t index = 0; internal_options[index].name; index++) {
140: 		options.push_back(internal_options[index]);
141: 	}
142: 	return options;
143: }
144: 
145: idx_t DBConfig::GetOptionCount() {
146: 	idx_t count = 0;
147: 	for (idx_t index = 0; internal_options[index].name; index++) {
148: 		count++;
149: 	}
150: 	return count;
151: }
152: 
153: vector<std::string> DBConfig::GetOptionNames() {
154: 	vector<string> names;
155: 	for (idx_t i = 0, option_count = DBConfig::GetOptionCount(); i < option_count; i++) {
156: 		names.emplace_back(DBConfig::GetOptionByIndex(i)->name);
157: 	}
158: 	return names;
159: }
160: 
161: optional_ptr<const ConfigurationOption> DBConfig::GetOptionByIndex(idx_t target_index) {
162: 	for (idx_t index = 0; internal_options[index].name; index++) {
163: 		if (index == target_index) {
164: 			return internal_options + index;
165: 		}
166: 	}
167: 	return nullptr;
168: }
169: 
170: optional_ptr<const ConfigurationOption> DBConfig::GetOptionByName(const string &name) {
171: 	auto lname = StringUtil::Lower(name);
172: 	for (idx_t index = 0; internal_options[index].name; index++) {
173: 		D_ASSERT(StringUtil::Lower(internal_options[index].name) == string(internal_options[index].name));
174: 		if (internal_options[index].name == lname) {
175: 			return internal_options + index;
176: 		}
177: 	}
178: 	return nullptr;
179: }
180: 
181: void DBConfig::SetOption(const ConfigurationOption &option, const Value &value) {
182: 	SetOption(nullptr, option, value);
183: }
184: 
185: void DBConfig::SetOptionByName(const string &name, const Value &value) {
186: 	auto option = DBConfig::GetOptionByName(name);
187: 	if (option) {
188: 		SetOption(*option, value);
189: 		return;
190: 	}
191: 
192: 	auto param = extension_parameters.find(name);
193: 	if (param != extension_parameters.end()) {
194: 		Value target_value = value.DefaultCastAs(param->second.type);
195: 		SetOption(name, std::move(target_value));
196: 	} else {
197: 		options.unrecognized_options[name] = value;
198: 	}
199: }
200: 
201: void DBConfig::SetOptionsByName(const case_insensitive_map_t<Value> &values) {
202: 	for (auto &kv : values) {
203: 		auto &name = kv.first;
204: 		auto &value = kv.second;
205: 		SetOptionByName(name, value);
206: 	}
207: }
208: 
209: void DBConfig::SetOption(DatabaseInstance *db, const ConfigurationOption &option, const Value &value) {
210: 	lock_guard<mutex> l(config_lock);
211: 	if (!option.set_global) {
212: 		throw InvalidInputException("Could not set option \"%s\" as a global option", option.name);
213: 	}
214: 	D_ASSERT(option.reset_global);
215: 	Value input = value.DefaultCastAs(option.parameter_type);
216: 	option.set_global(db, *this, input);
217: }
218: 
219: void DBConfig::ResetOption(DatabaseInstance *db, const ConfigurationOption &option) {
220: 	lock_guard<mutex> l(config_lock);
221: 	if (!option.reset_global) {
222: 		throw InternalException("Could not reset option \"%s\" as a global option", option.name);
223: 	}
224: 	D_ASSERT(option.set_global);
225: 	option.reset_global(db, *this);
226: }
227: 
228: void DBConfig::SetOption(const string &name, Value value) {
229: 	lock_guard<mutex> l(config_lock);
230: 	options.set_variables[name] = std::move(value);
231: }
232: 
233: void DBConfig::ResetOption(const string &name) {
234: 	lock_guard<mutex> l(config_lock);
235: 	auto extension_option = extension_parameters.find(name);
236: 	D_ASSERT(extension_option != extension_parameters.end());
237: 	auto &default_value = extension_option->second.default_value;
238: 	if (!default_value.IsNull()) {
239: 		// Default is not NULL, override the setting
240: 		options.set_variables[name] = default_value;
241: 	} else {
242: 		// Otherwise just remove it from the 'set_variables' map
243: 		options.set_variables.erase(name);
244: 	}
245: }
246: 
247: void DBConfig::AddExtensionOption(const string &name, string description, LogicalType parameter,
248:                                   const Value &default_value, set_option_callback_t function) {
249: 	extension_parameters.insert(
250: 	    make_pair(name, ExtensionOption(std::move(description), std::move(parameter), function, default_value)));
251: 	if (!default_value.IsNull()) {
252: 		// Default value is set, insert it into the 'set_variables' list
253: 		options.set_variables[name] = default_value;
254: 	}
255: }
256: 
257: bool DBConfig::IsInMemoryDatabase(const char *database_path) {
258: 	if (!database_path) {
259: 		// Entirely empty
260: 		return true;
261: 	}
262: 	if (strlen(database_path) == 0) {
263: 		// '' empty string
264: 		return true;
265: 	}
266: 	if (strcmp(database_path, ":memory:") == 0) {
267: 		return true;
268: 	}
269: 	return false;
270: }
271: 
272: CastFunctionSet &DBConfig::GetCastFunctions() {
273: 	return *cast_functions;
274: }
275: 
276: IndexTypeSet &DBConfig::GetIndexTypes() {
277: 	return *index_types;
278: }
279: 
280: void DBConfig::SetDefaultMaxMemory() {
281: 	auto memory = FileSystem::GetAvailableMemory();
282: 	if (memory.IsValid()) {
283: 		options.maximum_memory = memory.GetIndex() * 8 / 10;
284: 	}
285: }
286: 
287: void DBConfig::SetDefaultTempDirectory() {
288: 	if (DBConfig::IsInMemoryDatabase(options.database_path.c_str())) {
289: 		options.temporary_directory = ".tmp";
290: 	} else {
291: 		options.temporary_directory = options.database_path + ".tmp";
292: 	}
293: }
294: 
295: void DBConfig::CheckLock(const string &name) {
296: 	if (!options.lock_configuration) {
297: 		// not locked
298: 		return;
299: 	}
300: 	case_insensitive_set_t allowed_settings {"schema", "search_path"};
301: 	if (allowed_settings.find(name) != allowed_settings.end()) {
302: 		// we are always allowed to change these settings
303: 		return;
304: 	}
305: 	// not allowed!
306: 	throw InvalidInputException("Cannot change configuration option \"%s\" - the configuration has been locked", name);
307: }
308: 
309: idx_t CGroupBandwidthQuota(idx_t physical_cores, FileSystem &fs) {
310: 	static constexpr const char *CPU_MAX = "/sys/fs/cgroup/cpu.max";
311: 	static constexpr const char *CFS_QUOTA = "/sys/fs/cgroup/cpu/cpu.cfs_quota_us";
312: 	static constexpr const char *CFS_PERIOD = "/sys/fs/cgroup/cpu/cpu.cfs_period_us";
313: 
314: 	int64_t quota, period;
315: 	char byte_buffer[1000];
316: 	unique_ptr<FileHandle> handle;
317: 	int64_t read_bytes;
318: 
319: 	if (fs.FileExists(CPU_MAX)) {
320: 		// cgroup v2
321: 		// https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html
322: 		handle = fs.OpenFile(CPU_MAX, FileFlags::FILE_FLAGS_READ);
323: 		read_bytes = fs.Read(*handle, (void *)byte_buffer, 999);
324: 		byte_buffer[read_bytes] = '\0';
325: 		if (std::sscanf(byte_buffer, "%" SCNd64 " %" SCNd64 "", &quota, &period) != 2) {
326: 			return physical_cores;
327: 		}
328: 	} else if (fs.FileExists(CFS_QUOTA) && fs.FileExists(CFS_PERIOD)) {
329: 		// cgroup v1
330: 		// https://www.kernel.org/doc/html/latest/scheduler/sched-bwc.html#management
331: 
332: 		// Read the quota, this indicates how many microseconds the CPU can be utilized by this cgroup per period
333: 		handle = fs.OpenFile(CFS_QUOTA, FileFlags::FILE_FLAGS_READ);
334: 		read_bytes = fs.Read(*handle, (void *)byte_buffer, 999);
335: 		byte_buffer[read_bytes] = '\0';
336: 		if (std::sscanf(byte_buffer, "%" SCNd64 "", &quota) != 1) {
337: 			return physical_cores;
338: 		}
339: 
340: 		// Read the time period, a cgroup can utilize the CPU up to quota microseconds every period
341: 		handle = fs.OpenFile(CFS_PERIOD, FileFlags::FILE_FLAGS_READ);
342: 		read_bytes = fs.Read(*handle, (void *)byte_buffer, 999);
343: 		byte_buffer[read_bytes] = '\0';
344: 		if (std::sscanf(byte_buffer, "%" SCNd64 "", &period) != 1) {
345: 			return physical_cores;
346: 		}
347: 	} else {
348: 		// No cgroup quota
349: 		return physical_cores;
350: 	}
351: 	if (quota > 0 && period > 0) {
352: 		return idx_t(std::ceil((double)quota / (double)period));
353: 	} else {
354: 		return physical_cores;
355: 	}
356: }
357: 
358: idx_t DBConfig::GetSystemMaxThreads(FileSystem &fs) {
359: #ifndef DUCKDB_NO_THREADS
360: 	idx_t physical_cores = std::thread::hardware_concurrency();
361: #ifdef __linux__
362: 	auto cores_available_per_period = CGroupBandwidthQuota(physical_cores, fs);
363: 	return MaxValue<idx_t>(cores_available_per_period, 1);
364: #else
365: 	return physical_cores;
366: #endif
367: #else
368: 	return 1;
369: #endif
370: }
371: 
372: idx_t DBConfig::ParseMemoryLimit(const string &arg) {
373: 	if (arg[0] == '-' || arg == "null" || arg == "none") {
374: 		// infinite
375: 		return NumericLimits<idx_t>::Maximum();
376: 	}
377: 	// split based on the number/non-number
378: 	idx_t idx = 0;
379: 	while (StringUtil::CharacterIsSpace(arg[idx])) {
380: 		idx++;
381: 	}
382: 	idx_t num_start = idx;
383: 	while ((arg[idx] >= '0' && arg[idx] <= '9') || arg[idx] == '.' || arg[idx] == 'e' || arg[idx] == 'E' ||
384: 	       arg[idx] == '-') {
385: 		idx++;
386: 	}
387: 	if (idx == num_start) {
388: 		throw ParserException("Memory limit must have a number (e.g. SET memory_limit=1GB");
389: 	}
390: 	string number = arg.substr(num_start, idx - num_start);
391: 
392: 	// try to parse the number
393: 	double limit = Cast::Operation<string_t, double>(string_t(number));
394: 
395: 	// now parse the memory limit unit (e.g. bytes, gb, etc)
396: 	while (StringUtil::CharacterIsSpace(arg[idx])) {
397: 		idx++;
398: 	}
399: 	idx_t start = idx;
400: 	while (idx < arg.size() && !StringUtil::CharacterIsSpace(arg[idx])) {
401: 		idx++;
402: 	}
403: 	if (limit < 0) {
404: 		// limit < 0, set limit to infinite
405: 		return (idx_t)-1;
406: 	}
407: 	string unit = StringUtil::Lower(arg.substr(start, idx - start));
408: 	idx_t multiplier;
409: 	if (unit == "byte" || unit == "bytes" || unit == "b") {
410: 		multiplier = 1;
411: 	} else if (unit == "kilobyte" || unit == "kilobytes" || unit == "kb" || unit == "k") {
412: 		multiplier = 1000LL;
413: 	} else if (unit == "megabyte" || unit == "megabytes" || unit == "mb" || unit == "m") {
414: 		multiplier = 1000LL * 1000LL;
415: 	} else if (unit == "gigabyte" || unit == "gigabytes" || unit == "gb" || unit == "g") {
416: 		multiplier = 1000LL * 1000LL * 1000LL;
417: 	} else if (unit == "terabyte" || unit == "terabytes" || unit == "tb" || unit == "t") {
418: 		multiplier = 1000LL * 1000LL * 1000LL * 1000LL;
419: 	} else if (unit == "kib") {
420: 		multiplier = 1024LL;
421: 	} else if (unit == "mib") {
422: 		multiplier = 1024LL * 1024LL;
423: 	} else if (unit == "gib") {
424: 		multiplier = 1024LL * 1024LL * 1024LL;
425: 	} else if (unit == "tib") {
426: 		multiplier = 1024LL * 1024LL * 1024LL * 1024LL;
427: 	} else {
428: 		throw ParserException("Unknown unit for memory_limit: %s (expected: KB, MB, GB, TB for 1000^i units or KiB, "
429: 		                      "MiB, GiB, TiB for 1024^i unites)");
430: 	}
431: 	return NumericCast<idx_t>(multiplier * limit);
432: }
433: 
434: // Right now we only really care about access mode when comparing DBConfigs
435: bool DBConfigOptions::operator==(const DBConfigOptions &other) const {
436: 	return other.access_mode == access_mode;
437: }
438: 
439: bool DBConfig::operator==(const DBConfig &other) {
440: 	return other.options == options;
441: }
442: 
443: bool DBConfig::operator!=(const DBConfig &other) {
444: 	return !(other.options == options);
445: }
446: 
447: OrderType DBConfig::ResolveOrder(OrderType order_type) const {
448: 	if (order_type != OrderType::ORDER_DEFAULT) {
449: 		return order_type;
450: 	}
451: 	return options.default_order_type;
452: }
453: 
454: OrderByNullType DBConfig::ResolveNullOrder(OrderType order_type, OrderByNullType null_type) const {
455: 	if (null_type != OrderByNullType::ORDER_DEFAULT) {
456: 		return null_type;
457: 	}
458: 	switch (options.default_null_order) {
459: 	case DefaultOrderByNullType::NULLS_FIRST:
460: 		return OrderByNullType::NULLS_FIRST;
461: 	case DefaultOrderByNullType::NULLS_LAST:
462: 		return OrderByNullType::NULLS_LAST;
463: 	case DefaultOrderByNullType::NULLS_FIRST_ON_ASC_LAST_ON_DESC:
464: 		return order_type == OrderType::ASCENDING ? OrderByNullType::NULLS_FIRST : OrderByNullType::NULLS_LAST;
465: 	case DefaultOrderByNullType::NULLS_LAST_ON_ASC_FIRST_ON_DESC:
466: 		return order_type == OrderType::ASCENDING ? OrderByNullType::NULLS_LAST : OrderByNullType::NULLS_FIRST;
467: 	default:
468: 		throw InternalException("Unknown null order setting");
469: 	}
470: }
471: 
472: const std::string DBConfig::UserAgent() const {
473: 	auto user_agent = GetDefaultUserAgent();
474: 
475: 	if (!options.duckdb_api.empty()) {
476: 		user_agent += " " + options.duckdb_api;
477: 	}
478: 
479: 	if (!options.custom_user_agent.empty()) {
480: 		user_agent += " " + options.custom_user_agent;
481: 	}
482: 	return user_agent;
483: }
484: 
485: SerializationCompatibility SerializationCompatibility::FromString(const string &input) {
486: 	if (input.empty()) {
487: 		throw InvalidInputException("Version string can not be empty");
488: 	}
489: 
490: 	auto serialization_version = GetSerializationVersion(input.c_str());
491: 	if (!serialization_version.IsValid()) {
492: 		auto candidates = GetSerializationCandidates();
493: 		throw InvalidInputException("The version string '%s' is not a valid DuckDB version, valid options are: %s",
494: 		                            input, StringUtil::Join(candidates, ", "));
495: 	}
496: 	SerializationCompatibility result;
497: 	result.duckdb_version = input;
498: 	result.serialization_version = serialization_version.GetIndex();
499: 	result.manually_set = true;
500: 	return result;
501: }
502: 
503: SerializationCompatibility SerializationCompatibility::Default() {
504: #ifdef DUCKDB_ALTERNATIVE_VERIFY
505: 	auto res = FromString("latest");
506: 	res.manually_set = false;
507: 	return res;
508: #else
509: 	auto res = FromString("v0.10.2");
510: 	res.manually_set = false;
511: 	return res;
512: #endif
513: }
514: 
515: SerializationCompatibility SerializationCompatibility::Latest() {
516: 	auto res = FromString("latest");
517: 	res.manually_set = false;
518: 	return res;
519: }
520: 
521: bool SerializationCompatibility::Compare(idx_t property_version) const {
522: 	return property_version <= serialization_version;
523: }
524: 
525: } // namespace duckdb
[end of src/main/config.cpp]
[start of src/main/settings/settings.cpp]
1: #include "duckdb/main/settings.hpp"
2: 
3: #include "duckdb/catalog/catalog_search_path.hpp"
4: #include "duckdb/common/string_util.hpp"
5: #include "duckdb/main/attached_database.hpp"
6: #include "duckdb/main/client_context.hpp"
7: #include "duckdb/main/client_data.hpp"
8: #include "duckdb/main/config.hpp"
9: #include "duckdb/main/database.hpp"
10: #include "duckdb/main/database_manager.hpp"
11: #include "duckdb/main/query_profiler.hpp"
12: #include "duckdb/main/secret/secret_manager.hpp"
13: #include "duckdb/parallel/task_scheduler.hpp"
14: #include "duckdb/parser/parser.hpp"
15: #include "duckdb/planner/expression_binder.hpp"
16: #include "duckdb/storage/buffer_manager.hpp"
17: #include "duckdb/storage/storage_manager.hpp"
18: 
19: namespace duckdb {
20: 
21: const string GetDefaultUserAgent() {
22: 	return StringUtil::Format("duckdb/%s(%s)", DuckDB::LibraryVersion(), DuckDB::Platform());
23: }
24: 
25: //===--------------------------------------------------------------------===//
26: // Access Mode
27: //===--------------------------------------------------------------------===//
28: void AccessModeSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
29: 	if (db) {
30: 		throw InvalidInputException("Cannot change access_mode setting while database is running - it must be set when "
31: 		                            "opening or attaching the database");
32: 	}
33: 	auto parameter = StringUtil::Lower(input.ToString());
34: 	if (parameter == "automatic") {
35: 		config.options.access_mode = AccessMode::AUTOMATIC;
36: 	} else if (parameter == "read_only") {
37: 		config.options.access_mode = AccessMode::READ_ONLY;
38: 	} else if (parameter == "read_write") {
39: 		config.options.access_mode = AccessMode::READ_WRITE;
40: 	} else {
41: 		throw InvalidInputException(
42: 		    "Unrecognized parameter for option ACCESS_MODE \"%s\". Expected READ_ONLY or READ_WRITE.", parameter);
43: 	}
44: }
45: 
46: void AccessModeSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
47: 	config.options.access_mode = DBConfig().options.access_mode;
48: }
49: 
50: Value AccessModeSetting::GetSetting(const ClientContext &context) {
51: 	auto &config = DBConfig::GetConfig(context);
52: 	switch (config.options.access_mode) {
53: 	case AccessMode::AUTOMATIC:
54: 		return "automatic";
55: 	case AccessMode::READ_ONLY:
56: 		return "read_only";
57: 	case AccessMode::READ_WRITE:
58: 		return "read_write";
59: 	default:
60: 		throw InternalException("Unknown access mode setting");
61: 	}
62: }
63: 
64: //===--------------------------------------------------------------------===//
65: // Allow Persistent Secrets
66: //===--------------------------------------------------------------------===//
67: void AllowPersistentSecrets::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
68: 	auto value = input.DefaultCastAs(LogicalType::BOOLEAN);
69: 	config.secret_manager->SetEnablePersistentSecrets(value.GetValue<bool>());
70: }
71: 
72: void AllowPersistentSecrets::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
73: 	config.secret_manager->ResetEnablePersistentSecrets();
74: }
75: 
76: Value AllowPersistentSecrets::GetSetting(const ClientContext &context) {
77: 	auto &config = DBConfig::GetConfig(context);
78: 	return Value::BOOLEAN(config.secret_manager->PersistentSecretsEnabled());
79: }
80: 
81: //===--------------------------------------------------------------------===//
82: // Checkpoint Threshold
83: //===--------------------------------------------------------------------===//
84: void CheckpointThresholdSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
85: 	idx_t new_limit = DBConfig::ParseMemoryLimit(input.ToString());
86: 	config.options.checkpoint_wal_size = new_limit;
87: }
88: 
89: void CheckpointThresholdSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
90: 	config.options.checkpoint_wal_size = DBConfig().options.checkpoint_wal_size;
91: }
92: 
93: Value CheckpointThresholdSetting::GetSetting(const ClientContext &context) {
94: 	auto &config = DBConfig::GetConfig(context);
95: 	return Value(StringUtil::BytesToHumanReadableString(config.options.checkpoint_wal_size));
96: }
97: 
98: //===--------------------------------------------------------------------===//
99: // Debug Checkpoint Abort
100: //===--------------------------------------------------------------------===//
101: void DebugCheckpointAbort::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
102: 	auto checkpoint_abort = StringUtil::Lower(input.ToString());
103: 	if (checkpoint_abort == "none") {
104: 		config.options.checkpoint_abort = CheckpointAbort::NO_ABORT;
105: 	} else if (checkpoint_abort == "before_truncate") {
106: 		config.options.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE;
107: 	} else if (checkpoint_abort == "before_header") {
108: 		config.options.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER;
109: 	} else if (checkpoint_abort == "after_free_list_write") {
110: 		config.options.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE;
111: 	} else {
112: 		throw ParserException(
113: 		    "Unrecognized option for PRAGMA debug_checkpoint_abort, expected none, before_truncate or before_header");
114: 	}
115: }
116: 
117: void DebugCheckpointAbort::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
118: 	config.options.checkpoint_abort = DBConfig().options.checkpoint_abort;
119: }
120: 
121: Value DebugCheckpointAbort::GetSetting(const ClientContext &context) {
122: 	auto &config = DBConfig::GetConfig(*context.db);
123: 	auto setting = config.options.checkpoint_abort;
124: 	switch (setting) {
125: 	case CheckpointAbort::NO_ABORT:
126: 		return "none";
127: 	case CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE:
128: 		return "before_truncate";
129: 	case CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER:
130: 		return "before_header";
131: 	case CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE:
132: 		return "after_free_list_write";
133: 	default:
134: 		throw InternalException("Type not implemented for CheckpointAbort");
135: 	}
136: }
137: 
138: //===--------------------------------------------------------------------===//
139: // Debug Force External
140: //===--------------------------------------------------------------------===//
141: void DebugForceExternal::ResetLocal(ClientContext &context) {
142: 	ClientConfig::GetConfig(context).force_external = ClientConfig().force_external;
143: }
144: 
145: void DebugForceExternal::SetLocal(ClientContext &context, const Value &input) {
146: 	ClientConfig::GetConfig(context).force_external = input.GetValue<bool>();
147: }
148: 
149: Value DebugForceExternal::GetSetting(const ClientContext &context) {
150: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).force_external);
151: }
152: 
153: //===--------------------------------------------------------------------===//
154: // Debug Force NoCrossProduct
155: //===--------------------------------------------------------------------===//
156: void DebugForceNoCrossProduct::ResetLocal(ClientContext &context) {
157: 	ClientConfig::GetConfig(context).force_no_cross_product = ClientConfig().force_no_cross_product;
158: }
159: 
160: void DebugForceNoCrossProduct::SetLocal(ClientContext &context, const Value &input) {
161: 	ClientConfig::GetConfig(context).force_no_cross_product = input.GetValue<bool>();
162: }
163: 
164: Value DebugForceNoCrossProduct::GetSetting(const ClientContext &context) {
165: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).force_no_cross_product);
166: }
167: 
168: //===--------------------------------------------------------------------===//
169: // Ordered Aggregate Threshold
170: //===--------------------------------------------------------------------===//
171: void OrderedAggregateThreshold::ResetLocal(ClientContext &context) {
172: 	ClientConfig::GetConfig(context).ordered_aggregate_threshold = ClientConfig().ordered_aggregate_threshold;
173: }
174: 
175: void OrderedAggregateThreshold::SetLocal(ClientContext &context, const Value &input) {
176: 	const auto param = input.GetValue<uint64_t>();
177: 	if (param <= 0) {
178: 		throw ParserException("Invalid option for PRAGMA ordered_aggregate_threshold, value must be positive");
179: 	}
180: 	ClientConfig::GetConfig(context).ordered_aggregate_threshold = param;
181: }
182: 
183: Value OrderedAggregateThreshold::GetSetting(const ClientContext &context) {
184: 	return Value::UBIGINT(ClientConfig::GetConfig(context).ordered_aggregate_threshold);
185: }
186: 
187: //===--------------------------------------------------------------------===//
188: // Debug Window Mode
189: //===--------------------------------------------------------------------===//
190: void DebugWindowMode::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
191: 	auto param = StringUtil::Lower(input.ToString());
192: 	if (param == "window") {
193: 		config.options.window_mode = WindowAggregationMode::WINDOW;
194: 	} else if (param == "combine") {
195: 		config.options.window_mode = WindowAggregationMode::COMBINE;
196: 	} else if (param == "separate") {
197: 		config.options.window_mode = WindowAggregationMode::SEPARATE;
198: 	} else {
199: 		throw ParserException("Unrecognized option for PRAGMA debug_window_mode, expected window, combine or separate");
200: 	}
201: }
202: 
203: void DebugWindowMode::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
204: 	config.options.window_mode = DBConfig().options.window_mode;
205: }
206: 
207: Value DebugWindowMode::GetSetting(const ClientContext &context) {
208: 	return Value();
209: }
210: 
211: //===--------------------------------------------------------------------===//
212: // Debug AsOf Join
213: //===--------------------------------------------------------------------===//
214: void DebugAsOfIEJoin::ResetLocal(ClientContext &context) {
215: 	ClientConfig::GetConfig(context).force_asof_iejoin = ClientConfig().force_asof_iejoin;
216: }
217: 
218: void DebugAsOfIEJoin::SetLocal(ClientContext &context, const Value &input) {
219: 	ClientConfig::GetConfig(context).force_asof_iejoin = input.GetValue<bool>();
220: }
221: 
222: Value DebugAsOfIEJoin::GetSetting(const ClientContext &context) {
223: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).force_asof_iejoin);
224: }
225: 
226: //===--------------------------------------------------------------------===//
227: // Prefer Range Joins
228: //===--------------------------------------------------------------------===//
229: void PreferRangeJoins::ResetLocal(ClientContext &context) {
230: 	ClientConfig::GetConfig(context).prefer_range_joins = ClientConfig().prefer_range_joins;
231: }
232: 
233: void PreferRangeJoins::SetLocal(ClientContext &context, const Value &input) {
234: 	ClientConfig::GetConfig(context).prefer_range_joins = input.GetValue<bool>();
235: }
236: 
237: Value PreferRangeJoins::GetSetting(const ClientContext &context) {
238: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).prefer_range_joins);
239: }
240: 
241: //===--------------------------------------------------------------------===//
242: // Default Collation
243: //===--------------------------------------------------------------------===//
244: void DefaultCollationSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
245: 	auto parameter = StringUtil::Lower(input.ToString());
246: 	config.options.collation = parameter;
247: }
248: 
249: void DefaultCollationSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
250: 	config.options.collation = DBConfig().options.collation;
251: }
252: 
253: void DefaultCollationSetting::ResetLocal(ClientContext &context) {
254: 	auto &config = DBConfig::GetConfig(context);
255: 	config.options.collation = DBConfig().options.collation;
256: }
257: 
258: void DefaultCollationSetting::SetLocal(ClientContext &context, const Value &input) {
259: 	auto parameter = input.ToString();
260: 	// bind the collation to verify that it exists
261: 	ExpressionBinder::TestCollation(context, parameter);
262: 	auto &config = DBConfig::GetConfig(context);
263: 	config.options.collation = parameter;
264: }
265: 
266: Value DefaultCollationSetting::GetSetting(const ClientContext &context) {
267: 	auto &config = DBConfig::GetConfig(context);
268: 	return Value(config.options.collation);
269: }
270: 
271: //===--------------------------------------------------------------------===//
272: // Default Order
273: //===--------------------------------------------------------------------===//
274: void DefaultOrderSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
275: 	auto parameter = StringUtil::Lower(input.ToString());
276: 	if (parameter == "ascending" || parameter == "asc") {
277: 		config.options.default_order_type = OrderType::ASCENDING;
278: 	} else if (parameter == "descending" || parameter == "desc") {
279: 		config.options.default_order_type = OrderType::DESCENDING;
280: 	} else {
281: 		throw InvalidInputException("Unrecognized parameter for option DEFAULT_ORDER \"%s\". Expected ASC or DESC.",
282: 		                            parameter);
283: 	}
284: }
285: 
286: void DefaultOrderSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
287: 	config.options.default_order_type = DBConfig().options.default_order_type;
288: }
289: 
290: Value DefaultOrderSetting::GetSetting(const ClientContext &context) {
291: 	auto &config = DBConfig::GetConfig(context);
292: 	switch (config.options.default_order_type) {
293: 	case OrderType::ASCENDING:
294: 		return "asc";
295: 	case OrderType::DESCENDING:
296: 		return "desc";
297: 	default:
298: 		throw InternalException("Unknown order type setting");
299: 	}
300: }
301: 
302: //===--------------------------------------------------------------------===//
303: // Default Null Order
304: //===--------------------------------------------------------------------===//
305: void DefaultNullOrderSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
306: 	auto parameter = StringUtil::Lower(input.ToString());
307: 
308: 	if (parameter == "nulls_first" || parameter == "nulls first" || parameter == "null first" || parameter == "first") {
309: 		config.options.default_null_order = DefaultOrderByNullType::NULLS_FIRST;
310: 	} else if (parameter == "nulls_last" || parameter == "nulls last" || parameter == "null last" ||
311: 	           parameter == "last") {
312: 		config.options.default_null_order = DefaultOrderByNullType::NULLS_LAST;
313: 	} else if (parameter == "nulls_first_on_asc_last_on_desc" || parameter == "sqlite" || parameter == "mysql") {
314: 		config.options.default_null_order = DefaultOrderByNullType::NULLS_FIRST_ON_ASC_LAST_ON_DESC;
315: 	} else if (parameter == "nulls_last_on_asc_first_on_desc" || parameter == "postgres") {
316: 		config.options.default_null_order = DefaultOrderByNullType::NULLS_LAST_ON_ASC_FIRST_ON_DESC;
317: 	} else {
318: 		throw ParserException("Unrecognized parameter for option NULL_ORDER \"%s\", expected either NULLS FIRST, NULLS "
319: 		                      "LAST, SQLite, MySQL or Postgres",
320: 		                      parameter);
321: 	}
322: }
323: 
324: void DefaultNullOrderSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
325: 	config.options.default_null_order = DBConfig().options.default_null_order;
326: }
327: 
328: Value DefaultNullOrderSetting::GetSetting(const ClientContext &context) {
329: 	auto &config = DBConfig::GetConfig(context);
330: 	switch (config.options.default_null_order) {
331: 	case DefaultOrderByNullType::NULLS_FIRST:
332: 		return "nulls_first";
333: 	case DefaultOrderByNullType::NULLS_LAST:
334: 		return "nulls_last";
335: 	case DefaultOrderByNullType::NULLS_FIRST_ON_ASC_LAST_ON_DESC:
336: 		return "nulls_first_on_asc_last_on_desc";
337: 	case DefaultOrderByNullType::NULLS_LAST_ON_ASC_FIRST_ON_DESC:
338: 		return "nulls_last_on_asc_first_on_desc";
339: 	default:
340: 		throw InternalException("Unknown null order setting");
341: 	}
342: }
343: 
344: //===--------------------------------------------------------------------===//
345: // Default Null Order
346: //===--------------------------------------------------------------------===//
347: void DefaultSecretStorage::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
348: 	config.secret_manager->SetDefaultStorage(input.ToString());
349: }
350: 
351: void DefaultSecretStorage::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
352: 	config.secret_manager->ResetDefaultStorage();
353: }
354: 
355: Value DefaultSecretStorage::GetSetting(const ClientContext &context) {
356: 	auto &config = DBConfig::GetConfig(context);
357: 	return config.secret_manager->DefaultStorage();
358: }
359: 
360: //===--------------------------------------------------------------------===//
361: // Disabled File Systems
362: //===--------------------------------------------------------------------===//
363: void DisabledFileSystemsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
364: 	if (!db) {
365: 		throw InternalException("disabled_filesystems can only be set in an active database");
366: 	}
367: 	auto &fs = FileSystem::GetFileSystem(*db);
368: 	auto list = StringUtil::Split(input.ToString(), ",");
369: 	fs.SetDisabledFileSystems(list);
370: }
371: 
372: void DisabledFileSystemsSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
373: 	if (!db) {
374: 		throw InternalException("disabled_filesystems can only be set in an active database");
375: 	}
376: 	auto &fs = FileSystem::GetFileSystem(*db);
377: 	fs.SetDisabledFileSystems(vector<string>());
378: }
379: 
380: Value DisabledFileSystemsSetting::GetSetting(const ClientContext &context) {
381: 	return Value("");
382: }
383: 
384: //===--------------------------------------------------------------------===//
385: // Disabled Optimizer
386: //===--------------------------------------------------------------------===//
387: void DisabledOptimizersSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
388: 	auto list = StringUtil::Split(input.ToString(), ",");
389: 	set<OptimizerType> disabled_optimizers;
390: 	for (auto &entry : list) {
391: 		auto param = StringUtil::Lower(entry);
392: 		StringUtil::Trim(param);
393: 		if (param.empty()) {
394: 			continue;
395: 		}
396: 		disabled_optimizers.insert(OptimizerTypeFromString(param));
397: 	}
398: 	config.options.disabled_optimizers = std::move(disabled_optimizers);
399: }
400: 
401: void DisabledOptimizersSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
402: 	config.options.disabled_optimizers = DBConfig().options.disabled_optimizers;
403: }
404: 
405: Value DisabledOptimizersSetting::GetSetting(const ClientContext &context) {
406: 	auto &config = DBConfig::GetConfig(context);
407: 	string result;
408: 	for (auto &optimizer : config.options.disabled_optimizers) {
409: 		if (!result.empty()) {
410: 			result += ",";
411: 		}
412: 		result += OptimizerTypeToString(optimizer);
413: 	}
414: 	return Value(result);
415: }
416: 
417: //===--------------------------------------------------------------------===//
418: // Enable External Access
419: //===--------------------------------------------------------------------===//
420: void EnableExternalAccessSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
421: 	auto new_value = input.GetValue<bool>();
422: 	if (db && new_value) {
423: 		throw InvalidInputException("Cannot change enable_external_access setting while database is running");
424: 	}
425: 	config.options.enable_external_access = new_value;
426: }
427: 
428: void EnableExternalAccessSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
429: 	if (db) {
430: 		throw InvalidInputException("Cannot change enable_external_access setting while database is running");
431: 	}
432: 	config.options.enable_external_access = DBConfig().options.enable_external_access;
433: }
434: 
435: Value EnableExternalAccessSetting::GetSetting(const ClientContext &context) {
436: 	auto &config = DBConfig::GetConfig(context);
437: 	return Value::BOOLEAN(config.options.enable_external_access);
438: }
439: 
440: //===--------------------------------------------------------------------===//
441: // Enable View Dependencies
442: //===--------------------------------------------------------------------===//
443: void EnableViewDependencies::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
444: 	config.options.enable_view_dependencies = input.GetValue<bool>();
445: }
446: 
447: void EnableViewDependencies::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
448: 	config.options.enable_view_dependencies = DBConfig().options.enable_view_dependencies;
449: }
450: 
451: Value EnableViewDependencies::GetSetting(const ClientContext &context) {
452: 	auto &config = DBConfig::GetConfig(context);
453: 	return Value::BOOLEAN(config.options.enable_view_dependencies);
454: }
455: 
456: //===--------------------------------------------------------------------===//
457: // Enable FSST Vectors
458: //===--------------------------------------------------------------------===//
459: void EnableFSSTVectors::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
460: 	config.options.enable_fsst_vectors = input.GetValue<bool>();
461: }
462: 
463: void EnableFSSTVectors::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
464: 	config.options.enable_fsst_vectors = DBConfig().options.enable_fsst_vectors;
465: }
466: 
467: Value EnableFSSTVectors::GetSetting(const ClientContext &context) {
468: 	auto &config = DBConfig::GetConfig(context);
469: 	return Value::BOOLEAN(config.options.enable_fsst_vectors);
470: }
471: 
472: //===--------------------------------------------------------------------===//
473: // Allow Unsigned Extensions
474: //===--------------------------------------------------------------------===//
475: void AllowUnsignedExtensionsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
476: 	auto new_value = input.GetValue<bool>();
477: 	if (db && new_value) {
478: 		throw InvalidInputException("Cannot change allow_unsigned_extensions setting while database is running");
479: 	}
480: 	config.options.allow_unsigned_extensions = new_value;
481: }
482: 
483: void AllowUnsignedExtensionsSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
484: 	if (db) {
485: 		throw InvalidInputException("Cannot change allow_unsigned_extensions setting while database is running");
486: 	}
487: 	config.options.allow_unsigned_extensions = DBConfig().options.allow_unsigned_extensions;
488: }
489: 
490: Value AllowUnsignedExtensionsSetting::GetSetting(const ClientContext &context) {
491: 	auto &config = DBConfig::GetConfig(context);
492: 	return Value::BOOLEAN(config.options.allow_unsigned_extensions);
493: }
494: 
495: //===--------------------------------------------------------------------===//
496: // Allow Community Extensions
497: //===--------------------------------------------------------------------===//
498: void AllowCommunityExtensionsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
499: 	if (db && !config.options.allow_community_extensions) {
500: 		auto new_value = input.GetValue<bool>();
501: 		if (new_value) {
502: 			throw InvalidInputException("Cannot upgrade allow_community_extensions setting while database is running");
503: 		}
504: 		return;
505: 	}
506: 	auto new_value = input.GetValue<bool>();
507: 	config.options.allow_community_extensions = new_value;
508: }
509: 
510: void AllowCommunityExtensionsSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
511: 	if (db && !config.options.allow_community_extensions) {
512: 		if (DBConfig().options.allow_community_extensions) {
513: 			throw InvalidInputException("Cannot upgrade allow_community_extensions setting while database is running");
514: 		}
515: 		return;
516: 	}
517: 	config.options.allow_community_extensions = DBConfig().options.allow_community_extensions;
518: }
519: 
520: Value AllowCommunityExtensionsSetting::GetSetting(const ClientContext &context) {
521: 	auto &config = DBConfig::GetConfig(context);
522: 	return Value::BOOLEAN(config.options.allow_community_extensions);
523: }
524: 
525: //===--------------------------------------------------------------------===//
526: // Allow Extensions Metadata Mismatch
527: //===--------------------------------------------------------------------===//
528: void AllowExtensionsMetadataMismatchSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
529: 	auto new_value = input.GetValue<bool>();
530: 	config.options.allow_extensions_metadata_mismatch = new_value;
531: }
532: 
533: void AllowExtensionsMetadataMismatchSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
534: 	config.options.allow_extensions_metadata_mismatch = DBConfig().options.allow_extensions_metadata_mismatch;
535: }
536: 
537: Value AllowExtensionsMetadataMismatchSetting::GetSetting(const ClientContext &context) {
538: 	auto &config = DBConfig::GetConfig(context);
539: 	return Value::BOOLEAN(config.options.allow_extensions_metadata_mismatch);
540: }
541: 
542: //===--------------------------------------------------------------------===//
543: // Allow Unredacted Secrets
544: //===--------------------------------------------------------------------===//
545: void AllowUnredactedSecretsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
546: 	auto new_value = input.GetValue<bool>();
547: 	if (db && new_value) {
548: 		throw InvalidInputException("Cannot change allow_unredacted_secrets setting while database is running");
549: 	}
550: 	config.options.allow_unredacted_secrets = new_value;
551: }
552: 
553: void AllowUnredactedSecretsSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
554: 	if (db) {
555: 		throw InvalidInputException("Cannot change allow_unredacted_secrets setting while database is running");
556: 	}
557: 	config.options.allow_unredacted_secrets = DBConfig().options.allow_unredacted_secrets;
558: }
559: 
560: Value AllowUnredactedSecretsSetting::GetSetting(const ClientContext &context) {
561: 	auto &config = DBConfig::GetConfig(context);
562: 	return Value::BOOLEAN(config.options.allow_unredacted_secrets);
563: }
564: 
565: //===--------------------------------------------------------------------===//
566: // Enable Object Cache
567: //===--------------------------------------------------------------------===//
568: void EnableObjectCacheSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
569: 	config.options.object_cache_enable = input.GetValue<bool>();
570: }
571: 
572: void EnableObjectCacheSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
573: 	config.options.object_cache_enable = DBConfig().options.object_cache_enable;
574: }
575: 
576: Value EnableObjectCacheSetting::GetSetting(const ClientContext &context) {
577: 	auto &config = DBConfig::GetConfig(context);
578: 	return Value::BOOLEAN(config.options.object_cache_enable);
579: }
580: 
581: //===--------------------------------------------------------------------===//
582: // Storage Compatibility Version (for serialization)
583: //===--------------------------------------------------------------------===//
584: void StorageCompatibilityVersion::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
585: 	auto version_string = input.GetValue<string>();
586: 	auto serialization_compatibility = SerializationCompatibility::FromString(version_string);
587: 	config.options.serialization_compatibility = serialization_compatibility;
588: }
589: 
590: void StorageCompatibilityVersion::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
591: 	config.options.serialization_compatibility = DBConfig().options.serialization_compatibility;
592: }
593: 
594: Value StorageCompatibilityVersion::GetSetting(const ClientContext &context) {
595: 	auto &config = DBConfig::GetConfig(context);
596: 
597: 	auto &version_name = config.options.serialization_compatibility.duckdb_version;
598: 	return Value(version_name);
599: }
600: 
601: //===--------------------------------------------------------------------===//
602: // Enable HTTP Metadata Cache
603: //===--------------------------------------------------------------------===//
604: void EnableHTTPMetadataCacheSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
605: 	config.options.http_metadata_cache_enable = input.GetValue<bool>();
606: }
607: 
608: void EnableHTTPMetadataCacheSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
609: 	config.options.http_metadata_cache_enable = DBConfig().options.http_metadata_cache_enable;
610: }
611: 
612: Value EnableHTTPMetadataCacheSetting::GetSetting(const ClientContext &context) {
613: 	auto &config = DBConfig::GetConfig(context);
614: 	return Value::BOOLEAN(config.options.http_metadata_cache_enable);
615: }
616: 
617: //===--------------------------------------------------------------------===//
618: // Enable Profiling
619: //===--------------------------------------------------------------------===//
620: void EnableProfilingSetting::ResetLocal(ClientContext &context) {
621: 	auto &config = ClientConfig::GetConfig(context);
622: 	config.profiler_print_format = ClientConfig().profiler_print_format;
623: 	config.enable_profiler = ClientConfig().enable_profiler;
624: 	config.emit_profiler_output = ClientConfig().emit_profiler_output;
625: }
626: 
627: void EnableProfilingSetting::SetLocal(ClientContext &context, const Value &input) {
628: 	auto parameter = StringUtil::Lower(input.ToString());
629: 
630: 	auto &config = ClientConfig::GetConfig(context);
631: 	if (parameter == "json") {
632: 		config.profiler_print_format = ProfilerPrintFormat::JSON;
633: 	} else if (parameter == "query_tree") {
634: 		config.profiler_print_format = ProfilerPrintFormat::QUERY_TREE;
635: 	} else if (parameter == "query_tree_optimizer") {
636: 		config.profiler_print_format = ProfilerPrintFormat::QUERY_TREE_OPTIMIZER;
637: 	} else {
638: 		throw ParserException(
639: 		    "Unrecognized print format %s, supported formats: [json, query_tree, query_tree_optimizer]", parameter);
640: 	}
641: 	config.enable_profiler = true;
642: 	config.emit_profiler_output = true;
643: }
644: 
645: Value EnableProfilingSetting::GetSetting(const ClientContext &context) {
646: 	auto &config = ClientConfig::GetConfig(context);
647: 	if (!config.enable_profiler) {
648: 		return Value();
649: 	}
650: 	switch (config.profiler_print_format) {
651: 	case ProfilerPrintFormat::JSON:
652: 		return Value("json");
653: 	case ProfilerPrintFormat::QUERY_TREE:
654: 		return Value("query_tree");
655: 	case ProfilerPrintFormat::QUERY_TREE_OPTIMIZER:
656: 		return Value("query_tree_optimizer");
657: 	default:
658: 		throw InternalException("Unsupported profiler print format");
659: 	}
660: }
661: 
662: //===--------------------------------------------------------------------===//
663: // Custom Extension Repository
664: //===--------------------------------------------------------------------===//
665: void CustomExtensionRepository::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
666: 	config.options.custom_extension_repo = DBConfig().options.custom_extension_repo;
667: }
668: 
669: void CustomExtensionRepository::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
670: 	config.options.custom_extension_repo = input.ToString();
671: }
672: 
673: Value CustomExtensionRepository::GetSetting(const ClientContext &context) {
674: 	auto &config = DBConfig::GetConfig(context);
675: 	return Value(config.options.custom_extension_repo);
676: }
677: 
678: //===--------------------------------------------------------------------===//
679: // Autoload Extension Repository
680: //===--------------------------------------------------------------------===//
681: void AutoloadExtensionRepository::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
682: 	config.options.autoinstall_extension_repo = DBConfig().options.autoinstall_extension_repo;
683: }
684: 
685: void AutoloadExtensionRepository::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
686: 	config.options.autoinstall_extension_repo = input.ToString();
687: }
688: 
689: Value AutoloadExtensionRepository::GetSetting(const ClientContext &context) {
690: 	auto &config = DBConfig::GetConfig(context);
691: 	return Value(config.options.autoinstall_extension_repo);
692: }
693: 
694: //===--------------------------------------------------------------------===//
695: // Autoinstall Known Extensions
696: //===--------------------------------------------------------------------===//
697: void AutoinstallKnownExtensions::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
698: 	config.options.autoinstall_known_extensions = input.GetValue<bool>();
699: }
700: 
701: void AutoinstallKnownExtensions::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
702: 	config.options.autoinstall_known_extensions = DBConfig().options.autoinstall_known_extensions;
703: }
704: 
705: Value AutoinstallKnownExtensions::GetSetting(const ClientContext &context) {
706: 	auto &config = DBConfig::GetConfig(context);
707: 	return Value::BOOLEAN(config.options.autoinstall_known_extensions);
708: }
709: //===--------------------------------------------------------------------===//
710: // Autoload Known Extensions
711: //===--------------------------------------------------------------------===//
712: void AutoloadKnownExtensions::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
713: 	config.options.autoload_known_extensions = input.GetValue<bool>();
714: }
715: 
716: void AutoloadKnownExtensions::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
717: 	config.options.autoload_known_extensions = DBConfig().options.autoload_known_extensions;
718: }
719: 
720: Value AutoloadKnownExtensions::GetSetting(const ClientContext &context) {
721: 	auto &config = DBConfig::GetConfig(context);
722: 	return Value::BOOLEAN(config.options.autoload_known_extensions);
723: }
724: 
725: //===--------------------------------------------------------------------===//
726: // Enable Progress Bar
727: //===--------------------------------------------------------------------===//
728: void EnableProgressBarSetting::ResetLocal(ClientContext &context) {
729: 	auto &config = ClientConfig::GetConfig(context);
730: 	ProgressBar::SystemOverrideCheck(config);
731: 	config.enable_progress_bar = ClientConfig().enable_progress_bar;
732: }
733: 
734: void EnableProgressBarSetting::SetLocal(ClientContext &context, const Value &input) {
735: 	auto &config = ClientConfig::GetConfig(context);
736: 	ProgressBar::SystemOverrideCheck(config);
737: 	config.enable_progress_bar = input.GetValue<bool>();
738: }
739: 
740: Value EnableProgressBarSetting::GetSetting(const ClientContext &context) {
741: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).enable_progress_bar);
742: }
743: 
744: //===--------------------------------------------------------------------===//
745: // Enable Progress Bar Print
746: //===--------------------------------------------------------------------===//
747: void EnableProgressBarPrintSetting::SetLocal(ClientContext &context, const Value &input) {
748: 	auto &config = ClientConfig::GetConfig(context);
749: 	ProgressBar::SystemOverrideCheck(config);
750: 	config.print_progress_bar = input.GetValue<bool>();
751: }
752: 
753: void EnableProgressBarPrintSetting::ResetLocal(ClientContext &context) {
754: 	auto &config = ClientConfig::GetConfig(context);
755: 	ProgressBar::SystemOverrideCheck(config);
756: 	config.print_progress_bar = ClientConfig().print_progress_bar;
757: }
758: 
759: Value EnableProgressBarPrintSetting::GetSetting(const ClientContext &context) {
760: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).print_progress_bar);
761: }
762: 
763: //===--------------------------------------------------------------------===//
764: // Errors As JSON
765: //===--------------------------------------------------------------------===//
766: void ErrorsAsJsonSetting::ResetLocal(ClientContext &context) {
767: 	ClientConfig::GetConfig(context).errors_as_json = ClientConfig().errors_as_json;
768: }
769: 
770: void ErrorsAsJsonSetting::SetLocal(ClientContext &context, const Value &input) {
771: 	ClientConfig::GetConfig(context).errors_as_json = BooleanValue::Get(input);
772: }
773: 
774: Value ErrorsAsJsonSetting::GetSetting(const ClientContext &context) {
775: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).errors_as_json ? 1 : 0);
776: }
777: 
778: //===--------------------------------------------------------------------===//
779: // Explain Output
780: //===--------------------------------------------------------------------===//
781: void ExplainOutputSetting::ResetLocal(ClientContext &context) {
782: 	ClientConfig::GetConfig(context).explain_output_type = ClientConfig().explain_output_type;
783: }
784: 
785: void ExplainOutputSetting::SetLocal(ClientContext &context, const Value &input) {
786: 	auto parameter = StringUtil::Lower(input.ToString());
787: 	if (parameter == "all") {
788: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::ALL;
789: 	} else if (parameter == "optimized_only") {
790: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::OPTIMIZED_ONLY;
791: 	} else if (parameter == "physical_only") {
792: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::PHYSICAL_ONLY;
793: 	} else {
794: 		throw ParserException("Unrecognized output type \"%s\", expected either ALL, OPTIMIZED_ONLY or PHYSICAL_ONLY",
795: 		                      parameter);
796: 	}
797: }
798: 
799: Value ExplainOutputSetting::GetSetting(const ClientContext &context) {
800: 	switch (ClientConfig::GetConfig(context).explain_output_type) {
801: 	case ExplainOutputType::ALL:
802: 		return "all";
803: 	case ExplainOutputType::OPTIMIZED_ONLY:
804: 		return "optimized_only";
805: 	case ExplainOutputType::PHYSICAL_ONLY:
806: 		return "physical_only";
807: 	default:
808: 		throw InternalException("Unrecognized explain output type");
809: 	}
810: }
811: 
812: //===--------------------------------------------------------------------===//
813: // Extension Directory Setting
814: //===--------------------------------------------------------------------===//
815: void ExtensionDirectorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
816: 	config.options.extension_directory = input.ToString();
817: }
818: 
819: void ExtensionDirectorySetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
820: 	config.options.extension_directory = DBConfig().options.extension_directory;
821: }
822: 
823: Value ExtensionDirectorySetting::GetSetting(const ClientContext &context) {
824: 	return Value(DBConfig::GetConfig(context).options.extension_directory);
825: }
826: 
827: //===--------------------------------------------------------------------===//
828: // External Threads Setting
829: //===--------------------------------------------------------------------===//
830: void ExternalThreadsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
831: 	auto new_val = input.GetValue<int64_t>();
832: 	if (new_val < 0) {
833: 		throw SyntaxException("Must have a non-negative number of external threads!");
834: 	}
835: 	auto new_external_threads = NumericCast<idx_t>(new_val);
836: 	if (db) {
837: 		TaskScheduler::GetScheduler(*db).SetThreads(config.options.maximum_threads, new_external_threads);
838: 	}
839: 	config.options.external_threads = new_external_threads;
840: }
841: 
842: void ExternalThreadsSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
843: 	idx_t new_external_threads = DBConfig().options.external_threads;
844: 	if (db) {
845: 		TaskScheduler::GetScheduler(*db).SetThreads(config.options.maximum_threads, new_external_threads);
846: 	}
847: 	config.options.external_threads = new_external_threads;
848: }
849: 
850: Value ExternalThreadsSetting::GetSetting(const ClientContext &context) {
851: 	auto &config = DBConfig::GetConfig(context);
852: 	return Value::BIGINT(NumericCast<int64_t>(config.options.external_threads));
853: }
854: 
855: //===--------------------------------------------------------------------===//
856: // File Search Path
857: //===--------------------------------------------------------------------===//
858: void FileSearchPathSetting::ResetLocal(ClientContext &context) {
859: 	auto &client_data = ClientData::Get(context);
860: 	client_data.file_search_path.clear();
861: }
862: 
863: void FileSearchPathSetting::SetLocal(ClientContext &context, const Value &input) {
864: 	auto parameter = input.ToString();
865: 	auto &client_data = ClientData::Get(context);
866: 	client_data.file_search_path = parameter;
867: }
868: 
869: Value FileSearchPathSetting::GetSetting(const ClientContext &context) {
870: 	auto &client_data = ClientData::Get(context);
871: 	return Value(client_data.file_search_path);
872: }
873: 
874: //===--------------------------------------------------------------------===//
875: // Force Compression
876: //===--------------------------------------------------------------------===//
877: void ForceCompressionSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
878: 	auto compression = StringUtil::Lower(input.ToString());
879: 	if (compression == "none" || compression == "auto") {
880: 		config.options.force_compression = CompressionType::COMPRESSION_AUTO;
881: 	} else {
882: 		auto compression_type = CompressionTypeFromString(compression);
883: 		if (CompressionTypeIsDeprecated(compression_type)) {
884: 			throw ParserException("Attempted to force a deprecated compression type (%s)",
885: 			                      CompressionTypeToString(compression_type));
886: 		}
887: 		if (compression_type == CompressionType::COMPRESSION_AUTO) {
888: 			auto compression_types = StringUtil::Join(ListCompressionTypes(), ", ");
889: 			throw ParserException("Unrecognized option for PRAGMA force_compression, expected %s", compression_types);
890: 		}
891: 		config.options.force_compression = compression_type;
892: 	}
893: }
894: 
895: void ForceCompressionSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
896: 	config.options.force_compression = DBConfig().options.force_compression;
897: }
898: 
899: Value ForceCompressionSetting::GetSetting(const ClientContext &context) {
900: 	auto &config = DBConfig::GetConfig(*context.db);
901: 	return CompressionTypeToString(config.options.force_compression);
902: }
903: 
904: //===--------------------------------------------------------------------===//
905: // Force Bitpacking mode
906: //===--------------------------------------------------------------------===//
907: void ForceBitpackingModeSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
908: 	auto mode_str = StringUtil::Lower(input.ToString());
909: 	auto mode = BitpackingModeFromString(mode_str);
910: 	if (mode == BitpackingMode::INVALID) {
911: 		throw ParserException("Unrecognized option for force_bitpacking_mode, expected none, constant, constant_delta, "
912: 		                      "delta_for, or for");
913: 	}
914: 	config.options.force_bitpacking_mode = mode;
915: }
916: 
917: void ForceBitpackingModeSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
918: 	config.options.force_bitpacking_mode = DBConfig().options.force_bitpacking_mode;
919: }
920: 
921: Value ForceBitpackingModeSetting::GetSetting(const ClientContext &context) {
922: 	return Value(BitpackingModeToString(context.db->config.options.force_bitpacking_mode));
923: }
924: 
925: //===--------------------------------------------------------------------===//
926: // Home Directory
927: //===--------------------------------------------------------------------===//
928: void HomeDirectorySetting::ResetLocal(ClientContext &context) {
929: 	ClientConfig::GetConfig(context).home_directory = ClientConfig().home_directory;
930: }
931: 
932: void HomeDirectorySetting::SetLocal(ClientContext &context, const Value &input) {
933: 	auto &config = ClientConfig::GetConfig(context);
934: 
935: 	if (!input.IsNull() && FileSystem::GetFileSystem(context).IsRemoteFile(input.ToString())) {
936: 		throw InvalidInputException("Cannot set the home directory to a remote path");
937: 	}
938: 
939: 	config.home_directory = input.IsNull() ? string() : input.ToString();
940: }
941: 
942: Value HomeDirectorySetting::GetSetting(const ClientContext &context) {
943: 	auto &config = ClientConfig::GetConfig(context);
944: 	return Value(config.home_directory);
945: }
946: 
947: //===--------------------------------------------------------------------===//
948: // Integer Division
949: //===--------------------------------------------------------------------===//
950: void IntegerDivisionSetting::ResetLocal(ClientContext &context) {
951: 	ClientConfig::GetConfig(context).integer_division = ClientConfig().integer_division;
952: }
953: 
954: void IntegerDivisionSetting::SetLocal(ClientContext &context, const Value &input) {
955: 	auto &config = ClientConfig::GetConfig(context);
956: 	config.integer_division = input.GetValue<bool>();
957: }
958: 
959: Value IntegerDivisionSetting::GetSetting(const ClientContext &context) {
960: 	auto &config = ClientConfig::GetConfig(context);
961: 	return Value(config.integer_division);
962: }
963: 
964: //===--------------------------------------------------------------------===//
965: // Log Query Path
966: //===--------------------------------------------------------------------===//
967: void LogQueryPathSetting::ResetLocal(ClientContext &context) {
968: 	auto &client_data = ClientData::Get(context);
969: 	// TODO: verify that this does the right thing
970: 	client_data.log_query_writer = std::move(ClientData(context).log_query_writer);
971: }
972: 
973: void LogQueryPathSetting::SetLocal(ClientContext &context, const Value &input) {
974: 	auto &client_data = ClientData::Get(context);
975: 	auto path = input.ToString();
976: 	if (path.empty()) {
977: 		// empty path: clean up query writer
978: 		client_data.log_query_writer = nullptr;
979: 	} else {
980: 		client_data.log_query_writer = make_uniq<BufferedFileWriter>(FileSystem::GetFileSystem(context), path,
981: 		                                                             BufferedFileWriter::DEFAULT_OPEN_FLAGS);
982: 	}
983: }
984: 
985: Value LogQueryPathSetting::GetSetting(const ClientContext &context) {
986: 	auto &client_data = ClientData::Get(context);
987: 	return client_data.log_query_writer ? Value(client_data.log_query_writer->path) : Value();
988: }
989: 
990: //===--------------------------------------------------------------------===//
991: // Lock Configuration
992: //===--------------------------------------------------------------------===//
993: void LockConfigurationSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
994: 	auto new_value = input.GetValue<bool>();
995: 	config.options.lock_configuration = new_value;
996: }
997: 
998: void LockConfigurationSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
999: 	config.options.lock_configuration = DBConfig().options.lock_configuration;
1000: }
1001: 
1002: Value LockConfigurationSetting::GetSetting(const ClientContext &context) {
1003: 	auto &config = DBConfig::GetConfig(context);
1004: 	return Value::BOOLEAN(config.options.lock_configuration);
1005: }
1006: 
1007: //===--------------------------------------------------------------------===//
1008: // Immediate Transaction Mode
1009: //===--------------------------------------------------------------------===//
1010: void ImmediateTransactionModeSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1011: 	config.options.immediate_transaction_mode = BooleanValue::Get(input);
1012: }
1013: 
1014: void ImmediateTransactionModeSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1015: 	config.options.immediate_transaction_mode = DBConfig().options.immediate_transaction_mode;
1016: }
1017: 
1018: Value ImmediateTransactionModeSetting::GetSetting(const ClientContext &context) {
1019: 	auto &config = DBConfig::GetConfig(context);
1020: 	return Value::BOOLEAN(config.options.immediate_transaction_mode);
1021: }
1022: 
1023: //===--------------------------------------------------------------------===//
1024: // Maximum Expression Depth
1025: //===--------------------------------------------------------------------===//
1026: void MaximumExpressionDepthSetting::ResetLocal(ClientContext &context) {
1027: 	ClientConfig::GetConfig(context).max_expression_depth = ClientConfig().max_expression_depth;
1028: }
1029: 
1030: void MaximumExpressionDepthSetting::SetLocal(ClientContext &context, const Value &input) {
1031: 	ClientConfig::GetConfig(context).max_expression_depth = input.GetValue<uint64_t>();
1032: }
1033: 
1034: Value MaximumExpressionDepthSetting::GetSetting(const ClientContext &context) {
1035: 	return Value::UBIGINT(ClientConfig::GetConfig(context).max_expression_depth);
1036: }
1037: 
1038: //===--------------------------------------------------------------------===//
1039: // Maximum Memory
1040: //===--------------------------------------------------------------------===//
1041: void MaximumMemorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1042: 	config.options.maximum_memory = DBConfig::ParseMemoryLimit(input.ToString());
1043: 	if (db) {
1044: 		BufferManager::GetBufferManager(*db).SetMemoryLimit(config.options.maximum_memory);
1045: 	}
1046: }
1047: 
1048: void MaximumMemorySetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1049: 	config.SetDefaultMaxMemory();
1050: }
1051: 
1052: Value MaximumMemorySetting::GetSetting(const ClientContext &context) {
1053: 	auto &config = DBConfig::GetConfig(context);
1054: 	return Value(StringUtil::BytesToHumanReadableString(config.options.maximum_memory));
1055: }
1056: 
1057: //===--------------------------------------------------------------------===//
1058: // Maximum Temp Directory Size
1059: //===--------------------------------------------------------------------===//
1060: void MaximumTempDirectorySize::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1061: 	auto maximum_swap_space = DBConfig::ParseMemoryLimit(input.ToString());
1062: 	if (maximum_swap_space == DConstants::INVALID_INDEX) {
1063: 		// We use INVALID_INDEX to indicate that the value is not set by the user
1064: 		// use one lower to indicate 'unlimited'
1065: 		maximum_swap_space--;
1066: 	}
1067: 	if (!db) {
1068: 		config.options.maximum_swap_space = maximum_swap_space;
1069: 		return;
1070: 	}
1071: 	auto &buffer_manager = BufferManager::GetBufferManager(*db);
1072: 	buffer_manager.SetSwapLimit(maximum_swap_space);
1073: 	config.options.maximum_swap_space = maximum_swap_space;
1074: }
1075: 
1076: void MaximumTempDirectorySize::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1077: 	config.options.maximum_swap_space = DConstants::INVALID_INDEX;
1078: 	if (!db) {
1079: 		return;
1080: 	}
1081: 	auto &buffer_manager = BufferManager::GetBufferManager(*db);
1082: 	buffer_manager.SetSwapLimit();
1083: }
1084: 
1085: Value MaximumTempDirectorySize::GetSetting(const ClientContext &context) {
1086: 	auto &config = DBConfig::GetConfig(context);
1087: 	if (config.options.maximum_swap_space != DConstants::INVALID_INDEX) {
1088: 		// Explicitly set by the user
1089: 		return Value(StringUtil::BytesToHumanReadableString(config.options.maximum_swap_space));
1090: 	}
1091: 	auto &buffer_manager = BufferManager::GetBufferManager(context);
1092: 	// Database is initialized, use the setting from the temporary directory
1093: 	auto max_swap = buffer_manager.GetMaxSwap();
1094: 	if (max_swap.IsValid()) {
1095: 		return Value(StringUtil::BytesToHumanReadableString(max_swap.GetIndex()));
1096: 	} else {
1097: 		// The temp directory has not been used yet
1098: 		return Value(StringUtil::BytesToHumanReadableString(0));
1099: 	}
1100: }
1101: 
1102: //===--------------------------------------------------------------------===//
1103: // Old Implicit Casting
1104: //===--------------------------------------------------------------------===//
1105: void OldImplicitCasting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1106: 	config.options.old_implicit_casting = input.GetValue<bool>();
1107: }
1108: 
1109: void OldImplicitCasting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1110: 	config.options.old_implicit_casting = DBConfig().options.old_implicit_casting;
1111: }
1112: 
1113: Value OldImplicitCasting::GetSetting(const ClientContext &context) {
1114: 	auto &config = DBConfig::GetConfig(context);
1115: 	return Value::BOOLEAN(config.options.old_implicit_casting);
1116: }
1117: 
1118: //===--------------------------------------------------------------------===//
1119: // Partitioned Write Flush Threshold
1120: //===--------------------------------------------------------------------===//
1121: void PartitionedWriteFlushThreshold::ResetLocal(ClientContext &context) {
1122: 	ClientConfig::GetConfig(context).partitioned_write_flush_threshold =
1123: 	    ClientConfig().partitioned_write_flush_threshold;
1124: }
1125: 
1126: void PartitionedWriteFlushThreshold::SetLocal(ClientContext &context, const Value &input) {
1127: 	ClientConfig::GetConfig(context).partitioned_write_flush_threshold = input.GetValue<idx_t>();
1128: }
1129: 
1130: Value PartitionedWriteFlushThreshold::GetSetting(const ClientContext &context) {
1131: 	return Value::BIGINT(NumericCast<int64_t>(ClientConfig::GetConfig(context).partitioned_write_flush_threshold));
1132: }
1133: 
1134: //===--------------------------------------------------------------------===//
1135: // Password Setting
1136: //===--------------------------------------------------------------------===//
1137: void PasswordSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1138: 	// nop
1139: }
1140: 
1141: void PasswordSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1142: 	// nop
1143: }
1144: 
1145: Value PasswordSetting::GetSetting(const ClientContext &context) {
1146: 	return Value();
1147: }
1148: 
1149: //===--------------------------------------------------------------------===//
1150: // Perfect Hash Threshold
1151: //===--------------------------------------------------------------------===//
1152: void PerfectHashThresholdSetting::ResetLocal(ClientContext &context) {
1153: 	ClientConfig::GetConfig(context).perfect_ht_threshold = ClientConfig().perfect_ht_threshold;
1154: }
1155: 
1156: void PerfectHashThresholdSetting::SetLocal(ClientContext &context, const Value &input) {
1157: 	auto bits = input.GetValue<int64_t>();
1158: 	if (bits < 0 || bits > 32) {
1159: 		throw ParserException("Perfect HT threshold out of range: should be within range 0 - 32");
1160: 	}
1161: 	ClientConfig::GetConfig(context).perfect_ht_threshold = NumericCast<idx_t>(bits);
1162: }
1163: 
1164: Value PerfectHashThresholdSetting::GetSetting(const ClientContext &context) {
1165: 	return Value::BIGINT(NumericCast<int64_t>(ClientConfig::GetConfig(context).perfect_ht_threshold));
1166: }
1167: 
1168: //===--------------------------------------------------------------------===//
1169: // Pivot Filter Threshold
1170: //===--------------------------------------------------------------------===//
1171: void PivotFilterThreshold::ResetLocal(ClientContext &context) {
1172: 	ClientConfig::GetConfig(context).pivot_filter_threshold = ClientConfig().pivot_filter_threshold;
1173: }
1174: 
1175: void PivotFilterThreshold::SetLocal(ClientContext &context, const Value &input) {
1176: 	ClientConfig::GetConfig(context).pivot_filter_threshold = input.GetValue<uint64_t>();
1177: }
1178: 
1179: Value PivotFilterThreshold::GetSetting(const ClientContext &context) {
1180: 	return Value::BIGINT(NumericCast<int64_t>(ClientConfig::GetConfig(context).pivot_filter_threshold));
1181: }
1182: 
1183: //===--------------------------------------------------------------------===//
1184: // Pivot Limit
1185: //===--------------------------------------------------------------------===//
1186: void PivotLimitSetting::ResetLocal(ClientContext &context) {
1187: 	ClientConfig::GetConfig(context).pivot_limit = ClientConfig().pivot_limit;
1188: }
1189: 
1190: void PivotLimitSetting::SetLocal(ClientContext &context, const Value &input) {
1191: 	ClientConfig::GetConfig(context).pivot_limit = input.GetValue<uint64_t>();
1192: }
1193: 
1194: Value PivotLimitSetting::GetSetting(const ClientContext &context) {
1195: 	return Value::BIGINT(NumericCast<int64_t>(ClientConfig::GetConfig(context).pivot_limit));
1196: }
1197: 
1198: //===--------------------------------------------------------------------===//
1199: // PreserveIdentifierCase
1200: //===--------------------------------------------------------------------===//
1201: void PreserveIdentifierCase::ResetLocal(ClientContext &context) {
1202: 	ClientConfig::GetConfig(context).preserve_identifier_case = ClientConfig().preserve_identifier_case;
1203: }
1204: 
1205: void PreserveIdentifierCase::SetLocal(ClientContext &context, const Value &input) {
1206: 	ClientConfig::GetConfig(context).preserve_identifier_case = input.GetValue<bool>();
1207: }
1208: 
1209: Value PreserveIdentifierCase::GetSetting(const ClientContext &context) {
1210: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).preserve_identifier_case);
1211: }
1212: 
1213: //===--------------------------------------------------------------------===//
1214: // PreserveInsertionOrder
1215: //===--------------------------------------------------------------------===//
1216: void PreserveInsertionOrder::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1217: 	config.options.preserve_insertion_order = input.GetValue<bool>();
1218: }
1219: 
1220: void PreserveInsertionOrder::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1221: 	config.options.preserve_insertion_order = DBConfig().options.preserve_insertion_order;
1222: }
1223: 
1224: Value PreserveInsertionOrder::GetSetting(const ClientContext &context) {
1225: 	auto &config = DBConfig::GetConfig(context);
1226: 	return Value::BOOLEAN(config.options.preserve_insertion_order);
1227: }
1228: 
1229: //===--------------------------------------------------------------------===//
1230: // ExportLargeBufferArrow
1231: //===--------------------------------------------------------------------===//
1232: void ExportLargeBufferArrow::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1233: 	auto export_large_buffers_arrow = input.GetValue<bool>();
1234: 
1235: 	config.options.arrow_offset_size = export_large_buffers_arrow ? ArrowOffsetSize::LARGE : ArrowOffsetSize::REGULAR;
1236: }
1237: 
1238: void ExportLargeBufferArrow::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1239: 	config.options.arrow_offset_size = DBConfig().options.arrow_offset_size;
1240: }
1241: 
1242: Value ExportLargeBufferArrow::GetSetting(const ClientContext &context) {
1243: 	auto &config = DBConfig::GetConfig(context);
1244: 	bool export_large_buffers_arrow = config.options.arrow_offset_size == ArrowOffsetSize::LARGE;
1245: 	return Value::BOOLEAN(export_large_buffers_arrow);
1246: }
1247: 
1248: //===--------------------------------------------------------------------===//
1249: // Profile Output
1250: //===--------------------------------------------------------------------===//
1251: void ProfileOutputSetting::ResetLocal(ClientContext &context) {
1252: 	ClientConfig::GetConfig(context).profiler_save_location = ClientConfig().profiler_save_location;
1253: }
1254: 
1255: void ProfileOutputSetting::SetLocal(ClientContext &context, const Value &input) {
1256: 	auto &config = ClientConfig::GetConfig(context);
1257: 	auto parameter = input.ToString();
1258: 	config.profiler_save_location = parameter;
1259: }
1260: 
1261: Value ProfileOutputSetting::GetSetting(const ClientContext &context) {
1262: 	auto &config = ClientConfig::GetConfig(context);
1263: 	return Value(config.profiler_save_location);
1264: }
1265: 
1266: //===--------------------------------------------------------------------===//
1267: // Profiling Mode
1268: //===--------------------------------------------------------------------===//
1269: void ProfilingModeSetting::ResetLocal(ClientContext &context) {
1270: 	ClientConfig::GetConfig(context).enable_profiler = ClientConfig().enable_profiler;
1271: 	ClientConfig::GetConfig(context).enable_detailed_profiling = ClientConfig().enable_detailed_profiling;
1272: 	ClientConfig::GetConfig(context).emit_profiler_output = ClientConfig().emit_profiler_output;
1273: }
1274: 
1275: void ProfilingModeSetting::SetLocal(ClientContext &context, const Value &input) {
1276: 	auto parameter = StringUtil::Lower(input.ToString());
1277: 	auto &config = ClientConfig::GetConfig(context);
1278: 	if (parameter == "standard") {
1279: 		config.enable_profiler = true;
1280: 		config.enable_detailed_profiling = false;
1281: 		config.emit_profiler_output = true;
1282: 	} else if (parameter == "detailed") {
1283: 		config.enable_profiler = true;
1284: 		config.enable_detailed_profiling = true;
1285: 		config.emit_profiler_output = true;
1286: 	} else {
1287: 		throw ParserException("Unrecognized profiling mode \"%s\", supported formats: [standard, detailed]", parameter);
1288: 	}
1289: }
1290: 
1291: Value ProfilingModeSetting::GetSetting(const ClientContext &context) {
1292: 	auto &config = ClientConfig::GetConfig(context);
1293: 	if (!config.enable_profiler) {
1294: 		return Value();
1295: 	}
1296: 	return Value(config.enable_detailed_profiling ? "detailed" : "standard");
1297: }
1298: 
1299: //===--------------------------------------------------------------------===//
1300: // Progress Bar Time
1301: //===--------------------------------------------------------------------===//
1302: void ProgressBarTimeSetting::ResetLocal(ClientContext &context) {
1303: 	auto &config = ClientConfig::GetConfig(context);
1304: 	ProgressBar::SystemOverrideCheck(config);
1305: 	config.wait_time = ClientConfig().wait_time;
1306: 	config.enable_progress_bar = ClientConfig().enable_progress_bar;
1307: }
1308: 
1309: void ProgressBarTimeSetting::SetLocal(ClientContext &context, const Value &input) {
1310: 	auto &config = ClientConfig::GetConfig(context);
1311: 	ProgressBar::SystemOverrideCheck(config);
1312: 	config.wait_time = input.GetValue<int32_t>();
1313: 	config.enable_progress_bar = true;
1314: }
1315: 
1316: Value ProgressBarTimeSetting::GetSetting(const ClientContext &context) {
1317: 	return Value::BIGINT(ClientConfig::GetConfig(context).wait_time);
1318: }
1319: 
1320: //===--------------------------------------------------------------------===//
1321: // Schema
1322: //===--------------------------------------------------------------------===//
1323: void SchemaSetting::ResetLocal(ClientContext &context) {
1324: 	// FIXME: catalog_search_path is controlled by both SchemaSetting and SearchPathSetting
1325: 	auto &client_data = ClientData::Get(context);
1326: 	client_data.catalog_search_path->Reset();
1327: }
1328: 
1329: void SchemaSetting::SetLocal(ClientContext &context, const Value &input) {
1330: 	auto parameter = input.ToString();
1331: 	auto &client_data = ClientData::Get(context);
1332: 	client_data.catalog_search_path->Set(CatalogSearchEntry::Parse(parameter), CatalogSetPathType::SET_SCHEMA);
1333: }
1334: 
1335: Value SchemaSetting::GetSetting(const ClientContext &context) {
1336: 	auto &client_data = ClientData::Get(context);
1337: 	return client_data.catalog_search_path->GetDefault().schema;
1338: }
1339: 
1340: //===--------------------------------------------------------------------===//
1341: // Search Path
1342: //===--------------------------------------------------------------------===//
1343: void SearchPathSetting::ResetLocal(ClientContext &context) {
1344: 	// FIXME: catalog_search_path is controlled by both SchemaSetting and SearchPathSetting
1345: 	auto &client_data = ClientData::Get(context);
1346: 	client_data.catalog_search_path->Reset();
1347: }
1348: 
1349: void SearchPathSetting::SetLocal(ClientContext &context, const Value &input) {
1350: 	auto parameter = input.ToString();
1351: 	auto &client_data = ClientData::Get(context);
1352: 	client_data.catalog_search_path->Set(CatalogSearchEntry::ParseList(parameter), CatalogSetPathType::SET_SCHEMAS);
1353: }
1354: 
1355: Value SearchPathSetting::GetSetting(const ClientContext &context) {
1356: 	auto &client_data = ClientData::Get(context);
1357: 	auto &set_paths = client_data.catalog_search_path->GetSetPaths();
1358: 	return Value(CatalogSearchEntry::ListToString(set_paths));
1359: }
1360: 
1361: //===--------------------------------------------------------------------===//
1362: // Secret Directory
1363: //===--------------------------------------------------------------------===//
1364: void SecretDirectorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1365: 	config.secret_manager->SetPersistentSecretPath(input.ToString());
1366: }
1367: 
1368: void SecretDirectorySetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1369: 	config.secret_manager->ResetPersistentSecretPath();
1370: }
1371: 
1372: Value SecretDirectorySetting::GetSetting(const ClientContext &context) {
1373: 	auto &config = DBConfig::GetConfig(context);
1374: 	return config.secret_manager->PersistentSecretPath();
1375: }
1376: 
1377: //===--------------------------------------------------------------------===//
1378: // Temp Directory
1379: //===--------------------------------------------------------------------===//
1380: void TempDirectorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1381: 	config.options.temporary_directory = input.ToString();
1382: 	config.options.use_temporary_directory = !config.options.temporary_directory.empty();
1383: 	if (db) {
1384: 		auto &buffer_manager = BufferManager::GetBufferManager(*db);
1385: 		buffer_manager.SetTemporaryDirectory(config.options.temporary_directory);
1386: 	}
1387: }
1388: 
1389: void TempDirectorySetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1390: 	config.SetDefaultTempDirectory();
1391: 
1392: 	config.options.use_temporary_directory = DBConfig().options.use_temporary_directory;
1393: 	if (db) {
1394: 		auto &buffer_manager = BufferManager::GetBufferManager(*db);
1395: 		buffer_manager.SetTemporaryDirectory(config.options.temporary_directory);
1396: 	}
1397: }
1398: 
1399: Value TempDirectorySetting::GetSetting(const ClientContext &context) {
1400: 	auto &buffer_manager = BufferManager::GetBufferManager(context);
1401: 	return Value(buffer_manager.GetTemporaryDirectory());
1402: }
1403: 
1404: //===--------------------------------------------------------------------===//
1405: // Threads Setting
1406: //===--------------------------------------------------------------------===//
1407: void ThreadsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1408: 	auto new_val = input.GetValue<int64_t>();
1409: 	if (new_val < 1) {
1410: 		throw SyntaxException("Must have at least 1 thread!");
1411: 	}
1412: 	auto new_maximum_threads = NumericCast<idx_t>(new_val);
1413: 	if (db) {
1414: 		TaskScheduler::GetScheduler(*db).SetThreads(new_maximum_threads, config.options.external_threads);
1415: 	}
1416: 	config.options.maximum_threads = new_maximum_threads;
1417: }
1418: 
1419: void ThreadsSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1420: 	idx_t new_maximum_threads = config.GetSystemMaxThreads(*config.file_system);
1421: 	if (db) {
1422: 		TaskScheduler::GetScheduler(*db).SetThreads(new_maximum_threads, config.options.external_threads);
1423: 	}
1424: 	config.options.maximum_threads = new_maximum_threads;
1425: }
1426: 
1427: Value ThreadsSetting::GetSetting(const ClientContext &context) {
1428: 	auto &config = DBConfig::GetConfig(context);
1429: 	return Value::BIGINT(NumericCast<int64_t>(config.options.maximum_threads));
1430: }
1431: 
1432: //===--------------------------------------------------------------------===//
1433: // Username Setting
1434: //===--------------------------------------------------------------------===//
1435: void UsernameSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1436: 	// nop
1437: }
1438: 
1439: void UsernameSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1440: 	// nop
1441: }
1442: 
1443: Value UsernameSetting::GetSetting(const ClientContext &context) {
1444: 	return Value();
1445: }
1446: 
1447: //===--------------------------------------------------------------------===//
1448: // Allocator Flush Threshold
1449: //===--------------------------------------------------------------------===//
1450: void FlushAllocatorSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1451: 	config.options.allocator_flush_threshold = DBConfig::ParseMemoryLimit(input.ToString());
1452: 	if (db) {
1453: 		TaskScheduler::GetScheduler(*db).SetAllocatorFlushTreshold(config.options.allocator_flush_threshold);
1454: 	}
1455: }
1456: 
1457: void FlushAllocatorSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1458: 	config.options.allocator_flush_threshold = DBConfig().options.allocator_flush_threshold;
1459: 	if (db) {
1460: 		TaskScheduler::GetScheduler(*db).SetAllocatorFlushTreshold(config.options.allocator_flush_threshold);
1461: 	}
1462: }
1463: 
1464: Value FlushAllocatorSetting::GetSetting(const ClientContext &context) {
1465: 	auto &config = DBConfig::GetConfig(context);
1466: 	return Value(StringUtil::BytesToHumanReadableString(config.options.allocator_flush_threshold));
1467: }
1468: 
1469: //===--------------------------------------------------------------------===//
1470: // DuckDBApi Setting
1471: //===--------------------------------------------------------------------===//
1472: 
1473: void DuckDBApiSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1474: 	auto new_value = input.GetValue<string>();
1475: 	if (db) {
1476: 		throw InvalidInputException("Cannot change duckdb_api setting while database is running");
1477: 	}
1478: 	config.options.duckdb_api = new_value;
1479: }
1480: 
1481: void DuckDBApiSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1482: 	if (db) {
1483: 		throw InvalidInputException("Cannot change duckdb_api setting while database is running");
1484: 	}
1485: 	config.options.duckdb_api = GetDefaultUserAgent();
1486: }
1487: 
1488: Value DuckDBApiSetting::GetSetting(const ClientContext &context) {
1489: 	auto &config = DBConfig::GetConfig(context);
1490: 	return Value(config.options.duckdb_api);
1491: }
1492: 
1493: //===--------------------------------------------------------------------===//
1494: // CustomUserAgent Setting
1495: //===--------------------------------------------------------------------===//
1496: 
1497: void CustomUserAgentSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
1498: 	auto new_value = input.GetValue<string>();
1499: 	if (db) {
1500: 		throw InvalidInputException("Cannot change custom_user_agent setting while database is running");
1501: 	}
1502: 	config.options.custom_user_agent =
1503: 	    config.options.custom_user_agent.empty() ? new_value : config.options.custom_user_agent + " " + new_value;
1504: }
1505: 
1506: void CustomUserAgentSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {
1507: 	if (db) {
1508: 		throw InvalidInputException("Cannot change custom_user_agent setting while database is running");
1509: 	}
1510: 	config.options.custom_user_agent = DBConfig().options.custom_user_agent;
1511: }
1512: 
1513: Value CustomUserAgentSetting::GetSetting(const ClientContext &context) {
1514: 	auto &config = DBConfig::GetConfig(context);
1515: 	return Value(config.options.custom_user_agent);
1516: }
1517: 
1518: //===--------------------------------------------------------------------===//
1519: // EnableHTTPLogging Setting
1520: //===--------------------------------------------------------------------===//
1521: void EnableHTTPLoggingSetting::ResetLocal(ClientContext &context) {
1522: 	ClientConfig::GetConfig(context).enable_http_logging = ClientConfig().enable_http_logging;
1523: }
1524: 
1525: void EnableHTTPLoggingSetting::SetLocal(ClientContext &context, const Value &input) {
1526: 	ClientConfig::GetConfig(context).enable_http_logging = input.GetValue<bool>();
1527: }
1528: 
1529: Value EnableHTTPLoggingSetting::GetSetting(const ClientContext &context) {
1530: 	return Value(ClientConfig::GetConfig(context).enable_http_logging);
1531: }
1532: 
1533: //===--------------------------------------------------------------------===//
1534: // HTTPLoggingOutput Setting
1535: //===--------------------------------------------------------------------===//
1536: void HTTPLoggingOutputSetting::ResetLocal(ClientContext &context) {
1537: 	ClientConfig::GetConfig(context).http_logging_output = ClientConfig().http_logging_output;
1538: }
1539: 
1540: void HTTPLoggingOutputSetting::SetLocal(ClientContext &context, const Value &input) {
1541: 	ClientConfig::GetConfig(context).http_logging_output = input.GetValue<string>();
1542: }
1543: 
1544: Value HTTPLoggingOutputSetting::GetSetting(const ClientContext &context) {
1545: 	return Value(ClientConfig::GetConfig(context).http_logging_output);
1546: }
1547: 
1548: } // namespace duckdb
[end of src/main/settings/settings.cpp]
[start of src/planner/binder/statement/bind_create.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/catalog/catalog_search_path.hpp"
3: #include "duckdb/catalog/catalog_entry/duck_table_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
6: #include "duckdb/main/secret/secret_manager.hpp"
7: #include "duckdb/main/client_context.hpp"
8: #include "duckdb/main/database.hpp"
9: #include "duckdb/parser/expression/constant_expression.hpp"
10: #include "duckdb/parser/expression/function_expression.hpp"
11: #include "duckdb/parser/expression/subquery_expression.hpp"
12: #include "duckdb/planner/expression/bound_cast_expression.hpp"
13: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
14: #include "duckdb/parser/parsed_data/create_index_info.hpp"
15: #include "duckdb/parser/parsed_data/create_macro_info.hpp"
16: #include "duckdb/parser/parsed_data/create_view_info.hpp"
17: #include "duckdb/parser/tableref/table_function_ref.hpp"
18: #include "duckdb/parser/parsed_data/create_secret_info.hpp"
19: #include "duckdb/parser/parsed_expression_iterator.hpp"
20: #include "duckdb/parser/statement/create_statement.hpp"
21: #include "duckdb/planner/binder.hpp"
22: #include "duckdb/planner/bound_query_node.hpp"
23: #include "duckdb/planner/expression_binder/index_binder.hpp"
24: #include "duckdb/planner/expression_binder/select_binder.hpp"
25: #include "duckdb/planner/operator/logical_create.hpp"
26: #include "duckdb/planner/operator/logical_create_index.hpp"
27: #include "duckdb/planner/operator/logical_create_table.hpp"
28: #include "duckdb/planner/operator/logical_get.hpp"
29: #include "duckdb/planner/operator/logical_projection.hpp"
30: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
31: #include "duckdb/planner/query_node/bound_select_node.hpp"
32: #include "duckdb/planner/tableref/bound_basetableref.hpp"
33: #include "duckdb/parser/constraints/foreign_key_constraint.hpp"
34: #include "duckdb/function/scalar_macro_function.hpp"
35: #include "duckdb/storage/data_table.hpp"
36: #include "duckdb/storage/storage_extension.hpp"
37: #include "duckdb/main/client_data.hpp"
38: #include "duckdb/parser/constraints/unique_constraint.hpp"
39: #include "duckdb/parser/constraints/list.hpp"
40: #include "duckdb/main/database_manager.hpp"
41: #include "duckdb/main/attached_database.hpp"
42: #include "duckdb/catalog/duck_catalog.hpp"
43: #include "duckdb/function/table/table_scan.hpp"
44: #include "duckdb/parser/tableref/basetableref.hpp"
45: #include "duckdb/planner/expression_binder/select_bind_state.hpp"
46: 
47: namespace duckdb {
48: 
49: void Binder::BindSchemaOrCatalog(ClientContext &context, string &catalog, string &schema) {
50: 	if (catalog.empty() && !schema.empty()) {
51: 		// schema is specified - but catalog is not
52: 		// try searching for the catalog instead
53: 		auto &db_manager = DatabaseManager::Get(context);
54: 		auto database = db_manager.GetDatabase(context, schema);
55: 		if (database) {
56: 			// we have a database with this name
57: 			// check if there is a schema
58: 			auto &search_path = *context.client_data->catalog_search_path;
59: 			auto catalog_names = search_path.GetCatalogsForSchema(schema);
60: 			if (catalog_names.empty()) {
61: 				catalog_names.push_back(DatabaseManager::GetDefaultDatabase(context));
62: 			}
63: 			for (auto &catalog_name : catalog_names) {
64: 				auto &catalog = Catalog::GetCatalog(context, catalog_name);
65: 				if (catalog.CheckAmbiguousCatalogOrSchema(context, schema)) {
66: 					throw BinderException(
67: 					    "Ambiguous reference to catalog or schema \"%s\" - use a fully qualified path like \"%s.%s\"",
68: 					    schema, catalog_name, schema);
69: 				}
70: 			}
71: 			catalog = schema;
72: 			schema = string();
73: 		}
74: 	}
75: }
76: 
77: void Binder::BindSchemaOrCatalog(string &catalog, string &schema) {
78: 	BindSchemaOrCatalog(context, catalog, schema);
79: }
80: 
81: const string Binder::BindCatalog(string &catalog) {
82: 	auto &db_manager = DatabaseManager::Get(context);
83: 	optional_ptr<AttachedDatabase> database = db_manager.GetDatabase(context, catalog);
84: 	if (database) {
85: 		return db_manager.GetDatabase(context, catalog).get()->GetName();
86: 	} else {
87: 		return db_manager.GetDefaultDatabase(context);
88: 	}
89: }
90: 
91: SchemaCatalogEntry &Binder::BindSchema(CreateInfo &info) {
92: 	BindSchemaOrCatalog(info.catalog, info.schema);
93: 	if (IsInvalidCatalog(info.catalog) && info.temporary) {
94: 		info.catalog = TEMP_CATALOG;
95: 	}
96: 	auto &search_path = ClientData::Get(context).catalog_search_path;
97: 	if (IsInvalidCatalog(info.catalog) && IsInvalidSchema(info.schema)) {
98: 		auto &default_entry = search_path->GetDefault();
99: 		info.catalog = default_entry.catalog;
100: 		info.schema = default_entry.schema;
101: 	} else if (IsInvalidSchema(info.schema)) {
102: 		info.schema = search_path->GetDefaultSchema(info.catalog);
103: 	} else if (IsInvalidCatalog(info.catalog)) {
104: 		info.catalog = search_path->GetDefaultCatalog(info.schema);
105: 	}
106: 	if (IsInvalidCatalog(info.catalog)) {
107: 		info.catalog = DatabaseManager::GetDefaultDatabase(context);
108: 	}
109: 	if (!info.temporary) {
110: 		// non-temporary create: not read only
111: 		if (info.catalog == TEMP_CATALOG) {
112: 			throw ParserException("Only TEMPORARY table names can use the \"%s\" catalog", TEMP_CATALOG);
113: 		}
114: 	} else {
115: 		if (info.catalog != TEMP_CATALOG) {
116: 			throw ParserException("TEMPORARY table names can *only* use the \"%s\" catalog", TEMP_CATALOG);
117: 		}
118: 	}
119: 	// fetch the schema in which we want to create the object
120: 	auto &schema_obj = Catalog::GetSchema(context, info.catalog, info.schema);
121: 	D_ASSERT(schema_obj.type == CatalogType::SCHEMA_ENTRY);
122: 	info.schema = schema_obj.name;
123: 	if (!info.temporary) {
124: 		auto &properties = GetStatementProperties();
125: 		properties.modified_databases.insert(schema_obj.catalog.GetName());
126: 	}
127: 	return schema_obj;
128: }
129: 
130: SchemaCatalogEntry &Binder::BindCreateSchema(CreateInfo &info) {
131: 	auto &schema = BindSchema(info);
132: 	if (schema.catalog.IsSystemCatalog()) {
133: 		throw BinderException("Cannot create entry in system catalog");
134: 	}
135: 	return schema;
136: }
137: 
138: void Binder::SetCatalogLookupCallback(catalog_entry_callback_t callback) {
139: 	entry_retriever.SetCallback(std::move(callback));
140: }
141: 
142: void Binder::BindCreateViewInfo(CreateViewInfo &base) {
143: 	// bind the view as if it were a query so we can catch errors
144: 	// note that we bind the original, and replace the original with a copy
145: 	auto view_binder = Binder::CreateBinder(context);
146: 	auto &dependencies = base.dependencies;
147: 	auto &catalog = Catalog::GetCatalog(context, base.catalog);
148: 
149: 	auto &db_config = DBConfig::GetConfig(context);
150: 	auto should_create_dependencies = db_config.options.enable_view_dependencies;
151: 
152: 	if (should_create_dependencies) {
153: 		view_binder->SetCatalogLookupCallback([&dependencies, &catalog](CatalogEntry &entry) {
154: 			if (&catalog != &entry.ParentCatalog()) {
155: 				// Don't register dependencies between catalogs
156: 				return;
157: 			}
158: 			dependencies.AddDependency(entry);
159: 		});
160: 	}
161: 	view_binder->can_contain_nulls = true;
162: 
163: 	auto copy = base.query->Copy();
164: 	auto query_node = view_binder->Bind(*base.query);
165: 	base.query = unique_ptr_cast<SQLStatement, SelectStatement>(std::move(copy));
166: 	if (base.aliases.size() > query_node.names.size()) {
167: 		throw BinderException("More VIEW aliases than columns in query result");
168: 	}
169: 	base.types = query_node.types;
170: 	base.names = query_node.names;
171: }
172: 
173: SchemaCatalogEntry &Binder::BindCreateFunctionInfo(CreateInfo &info) {
174: 	auto &base = info.Cast<CreateMacroInfo>();
175: 	auto &scalar_function = base.function->Cast<ScalarMacroFunction>();
176: 
177: 	if (scalar_function.expression->HasParameter()) {
178: 		throw BinderException("Parameter expressions within macro's are not supported!");
179: 	}
180: 
181: 	// create macro binding in order to bind the function
182: 	vector<LogicalType> dummy_types;
183: 	vector<string> dummy_names;
184: 	// positional parameters
185: 	for (auto &param_expr : base.function->parameters) {
186: 		auto param = param_expr->Cast<ColumnRefExpression>();
187: 		if (param.IsQualified()) {
188: 			throw BinderException("Invalid parameter name '%s': must be unqualified", param.ToString());
189: 		}
190: 		dummy_types.emplace_back(LogicalType::SQLNULL);
191: 		dummy_names.push_back(param.GetColumnName());
192: 	}
193: 	// default parameters
194: 	for (auto &entry : base.function->default_parameters) {
195: 		auto &val = entry.second->Cast<ConstantExpression>();
196: 		dummy_types.push_back(val.value.type());
197: 		dummy_names.push_back(entry.first);
198: 	}
199: 	auto this_macro_binding = make_uniq<DummyBinding>(dummy_types, dummy_names, base.name);
200: 	macro_binding = this_macro_binding.get();
201: 
202: 	// create a copy of the expression because we do not want to alter the original
203: 	auto expression = scalar_function.expression->Copy();
204: 	ExpressionBinder::QualifyColumnNames(*this, expression);
205: 
206: 	// bind it to verify the function was defined correctly
207: 	ErrorData error;
208: 	BoundSelectNode sel_node;
209: 	BoundGroupInformation group_info;
210: 	SelectBinder binder(*this, context, sel_node, group_info);
211: 	auto &dependencies = base.dependencies;
212: 	auto &catalog = Catalog::GetCatalog(context, info.catalog);
213: 	binder.SetCatalogLookupCallback([&dependencies, &catalog](CatalogEntry &entry) {
214: 		if (&catalog != &entry.ParentCatalog()) {
215: 			// Don't register any cross-catalog dependencies
216: 			return;
217: 		}
218: 		// Register any catalog entry required to bind the macro function
219: 		dependencies.AddDependency(entry);
220: 	});
221: 	error = binder.Bind(expression, 0, false);
222: 	if (error.HasError()) {
223: 		error.Throw();
224: 	}
225: 
226: 	return BindCreateSchema(info);
227: }
228: 
229: void Binder::BindLogicalType(LogicalType &type, optional_ptr<Catalog> catalog, const string &schema) {
230: 	if (type.id() == LogicalTypeId::LIST || type.id() == LogicalTypeId::MAP) {
231: 		auto child_type = ListType::GetChildType(type);
232: 		BindLogicalType(child_type, catalog, schema);
233: 		auto alias = type.GetAlias();
234: 		auto modifiers = type.GetModifiersCopy();
235: 		if (type.id() == LogicalTypeId::LIST) {
236: 			type = LogicalType::LIST(child_type);
237: 		} else {
238: 			D_ASSERT(child_type.id() == LogicalTypeId::STRUCT); // map must be list of structs
239: 			type = LogicalType::MAP(child_type);
240: 		}
241: 
242: 		type.SetAlias(alias);
243: 		type.SetModifiers(modifiers);
244: 	} else if (type.id() == LogicalTypeId::STRUCT) {
245: 		auto child_types = StructType::GetChildTypes(type);
246: 		for (auto &child_type : child_types) {
247: 			BindLogicalType(child_type.second, catalog, schema);
248: 		}
249: 		// Generate new Struct Type
250: 		auto alias = type.GetAlias();
251: 		auto modifiers = type.GetModifiersCopy();
252: 		type = LogicalType::STRUCT(child_types);
253: 		type.SetAlias(alias);
254: 		type.SetModifiers(modifiers);
255: 	} else if (type.id() == LogicalTypeId::ARRAY) {
256: 		auto child_type = ArrayType::GetChildType(type);
257: 		auto array_size = ArrayType::GetSize(type);
258: 		BindLogicalType(child_type, catalog, schema);
259: 		auto alias = type.GetAlias();
260: 		auto modifiers = type.GetModifiersCopy();
261: 		type = LogicalType::ARRAY(child_type, array_size);
262: 		type.SetAlias(alias);
263: 		type.SetModifiers(modifiers);
264: 	} else if (type.id() == LogicalTypeId::UNION) {
265: 		auto member_types = UnionType::CopyMemberTypes(type);
266: 		for (auto &member_type : member_types) {
267: 			BindLogicalType(member_type.second, catalog, schema);
268: 		}
269: 		// Generate new Union Type
270: 		auto alias = type.GetAlias();
271: 		auto modifiers = type.GetModifiersCopy();
272: 		type = LogicalType::UNION(member_types);
273: 		type.SetAlias(alias);
274: 		type.SetModifiers(modifiers);
275: 	} else if (type.id() == LogicalTypeId::USER) {
276: 		auto user_type_name = UserType::GetTypeName(type);
277: 		auto user_type_mods = UserType::GetTypeModifiers(type);
278: 
279: 		bind_type_modifiers_function_t user_bind_modifiers_func = nullptr;
280: 
281: 		if (catalog) {
282: 			// The search order is:
283: 			// 1) In the same schema as the table
284: 			// 2) In the same catalog
285: 			// 3) System catalog
286: 			auto entry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, *catalog, schema, user_type_name,
287: 			                                      OnEntryNotFound::RETURN_NULL);
288: 			if (!entry || entry->Cast<TypeCatalogEntry>().user_type.id() == LogicalTypeId::INVALID) {
289: 				entry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, *catalog, INVALID_SCHEMA, user_type_name,
290: 				                                 OnEntryNotFound::RETURN_NULL);
291: 				if (!entry || entry->Cast<TypeCatalogEntry>().user_type.id() == LogicalTypeId::INVALID) {
292: 					entry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, INVALID_CATALOG, INVALID_SCHEMA,
293: 					                                 user_type_name, OnEntryNotFound::THROW_EXCEPTION);
294: 				}
295: 			}
296: 			auto &type_entry = entry->Cast<TypeCatalogEntry>();
297: 			type = type_entry.user_type;
298: 			user_bind_modifiers_func = type_entry.bind_modifiers;
299: 		} else {
300: 			string type_catalog = UserType::GetCatalog(type);
301: 			string type_schema = UserType::GetSchema(type);
302: 
303: 			BindSchemaOrCatalog(context, type_catalog, type_schema);
304: 			auto entry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, type_catalog, type_schema, user_type_name);
305: 			auto &type_entry = entry->Cast<TypeCatalogEntry>();
306: 			type = type_entry.user_type;
307: 			user_bind_modifiers_func = type_entry.bind_modifiers;
308: 		}
309: 
310: 		BindLogicalType(type, catalog, schema);
311: 
312: 		// Apply the type modifiers (if any)
313: 		if (user_bind_modifiers_func) {
314: 			// If an explicit bind_modifiers function was provided, use that to set the type modifier
315: 			BindTypeModifiersInput input {context, type, user_type_mods};
316: 			type = user_bind_modifiers_func(input);
317: 		} else if (type.HasModifiers()) {
318: 			// If the type already has modifiers, try to replace them with the user-provided ones if they are compatible
319: 			// This enables registering custom types with "default" type modifiers that can be overridden, without
320: 			// having to provide a custom bind_modifiers function
321: 			auto type_mods_size = type.GetModifiers()->size();
322: 
323: 			// Are we trying to pass more type modifiers than the type has?
324: 			if (user_type_mods.size() > type_mods_size) {
325: 				throw BinderException(
326: 				    "Cannot apply '%d' type modifier(s) to type '%s' taking at most '%d' type modifier(s)",
327: 				    user_type_mods.size(), user_type_name, type_mods_size);
328: 			}
329: 
330: 			// Deep copy the type so that we can replace the type modifiers
331: 			type = type.DeepCopy();
332: 
333: 			// Re-fetch the type modifiers now that we've deduplicated the ExtraTypeInfo
334: 			auto &type_mods = *type.GetModifiers();
335: 
336: 			// Replace them in order, casting if necessary
337: 			for (idx_t i = 0; i < MinValue(type_mods.size(), user_type_mods.size()); i++) {
338: 				auto &type_mod = type_mods[i];
339: 				auto user_type_mod = user_type_mods[i];
340: 				if (type_mod.type() == user_type_mod.type()) {
341: 					type_mod = std::move(user_type_mod);
342: 				} else if (user_type_mod.DefaultTryCastAs(type_mod.type())) {
343: 					type_mod = std::move(user_type_mod);
344: 				} else {
345: 					throw BinderException("Cannot apply type modifier '%s' to type '%s', expected value of type '%s'",
346: 					                      user_type_mod.ToString(), user_type_name, type_mod.type().ToString());
347: 				}
348: 			}
349: 		} else if (!user_type_mods.empty()) {
350: 			// We're trying to pass type modifiers to a type that doesnt have any
351: 			throw BinderException("Type '%s' does not take any type modifiers", user_type_name);
352: 		}
353: 	}
354: }
355: 
356: static void FindMatchingPrimaryKeyColumns(const ColumnList &columns, const vector<unique_ptr<Constraint>> &constraints,
357:                                           ForeignKeyConstraint &fk) {
358: 	// find the matching primary key constraint
359: 	bool found_constraint = false;
360: 	// if no columns are defined, we will automatically try to bind to the primary key
361: 	bool find_primary_key = fk.pk_columns.empty();
362: 	for (auto &constr : constraints) {
363: 		if (constr->type != ConstraintType::UNIQUE) {
364: 			continue;
365: 		}
366: 		auto &unique = constr->Cast<UniqueConstraint>();
367: 		if (find_primary_key && !unique.IsPrimaryKey()) {
368: 			continue;
369: 		}
370: 		found_constraint = true;
371: 
372: 		vector<string> pk_names;
373: 		if (unique.HasIndex()) {
374: 			pk_names.push_back(columns.GetColumn(LogicalIndex(unique.GetIndex())).Name());
375: 		} else {
376: 			pk_names = unique.GetColumnNames();
377: 		}
378: 		if (find_primary_key) {
379: 			// found matching primary key
380: 			if (pk_names.size() != fk.fk_columns.size()) {
381: 				auto pk_name_str = StringUtil::Join(pk_names, ",");
382: 				auto fk_name_str = StringUtil::Join(fk.fk_columns, ",");
383: 				throw BinderException(
384: 				    "Failed to create foreign key: number of referencing (%s) and referenced columns (%s) differ",
385: 				    fk_name_str, pk_name_str);
386: 			}
387: 			fk.pk_columns = pk_names;
388: 			return;
389: 		}
390: 		if (pk_names.size() != fk.fk_columns.size()) {
391: 			// the number of referencing and referenced columns for foreign keys must be the same
392: 			continue;
393: 		}
394: 		bool equals = true;
395: 		for (idx_t i = 0; i < fk.pk_columns.size(); i++) {
396: 			if (!StringUtil::CIEquals(fk.pk_columns[i], pk_names[i])) {
397: 				equals = false;
398: 				break;
399: 			}
400: 		}
401: 		if (!equals) {
402: 			continue;
403: 		}
404: 		// found match
405: 		return;
406: 	}
407: 	// no match found! examine why
408: 	if (!found_constraint) {
409: 		// no unique constraint or primary key
410: 		string search_term = find_primary_key ? "primary key" : "primary key or unique constraint";
411: 		throw BinderException("Failed to create foreign key: there is no %s for referenced table \"%s\"", search_term,
412: 		                      fk.info.table);
413: 	}
414: 	// check if all the columns exist
415: 	for (auto &name : fk.pk_columns) {
416: 		bool found = columns.ColumnExists(name);
417: 		if (!found) {
418: 			throw BinderException(
419: 			    "Failed to create foreign key: referenced table \"%s\" does not have a column named \"%s\"",
420: 			    fk.info.table, name);
421: 		}
422: 	}
423: 	auto fk_names = StringUtil::Join(fk.pk_columns, ",");
424: 	throw BinderException("Failed to create foreign key: referenced table \"%s\" does not have a primary key or unique "
425: 	                      "constraint on the columns %s",
426: 	                      fk.info.table, fk_names);
427: }
428: 
429: static void FindForeignKeyIndexes(const ColumnList &columns, const vector<string> &names,
430:                                   vector<PhysicalIndex> &indexes) {
431: 	D_ASSERT(indexes.empty());
432: 	D_ASSERT(!names.empty());
433: 	for (auto &name : names) {
434: 		if (!columns.ColumnExists(name)) {
435: 			throw BinderException("column \"%s\" named in key does not exist", name);
436: 		}
437: 		auto &column = columns.GetColumn(name);
438: 		if (column.Generated()) {
439: 			throw BinderException("Failed to create foreign key: referenced column \"%s\" is a generated column",
440: 			                      column.Name());
441: 		}
442: 		indexes.push_back(column.Physical());
443: 	}
444: }
445: 
446: static void CheckForeignKeyTypes(const ColumnList &pk_columns, const ColumnList &fk_columns, ForeignKeyConstraint &fk) {
447: 	D_ASSERT(fk.info.pk_keys.size() == fk.info.fk_keys.size());
448: 	for (idx_t c_idx = 0; c_idx < fk.info.pk_keys.size(); c_idx++) {
449: 		auto &pk_col = pk_columns.GetColumn(fk.info.pk_keys[c_idx]);
450: 		auto &fk_col = fk_columns.GetColumn(fk.info.fk_keys[c_idx]);
451: 		if (pk_col.Type() != fk_col.Type()) {
452: 			throw BinderException("Failed to create foreign key: incompatible types between column \"%s\" (\"%s\") and "
453: 			                      "column \"%s\" (\"%s\")",
454: 			                      pk_col.Name(), pk_col.Type().ToString(), fk_col.Name(), fk_col.Type().ToString());
455: 		}
456: 	}
457: }
458: 
459: void ExpressionContainsGeneratedColumn(const ParsedExpression &expr, const unordered_set<string> &gcols,
460:                                        bool &contains_gcol) {
461: 	if (contains_gcol) {
462: 		return;
463: 	}
464: 	if (expr.type == ExpressionType::COLUMN_REF) {
465: 		auto &column_ref = expr.Cast<ColumnRefExpression>();
466: 		auto &name = column_ref.GetColumnName();
467: 		if (gcols.count(name)) {
468: 			contains_gcol = true;
469: 			return;
470: 		}
471: 	}
472: 	ParsedExpressionIterator::EnumerateChildren(
473: 	    expr, [&](const ParsedExpression &child) { ExpressionContainsGeneratedColumn(child, gcols, contains_gcol); });
474: }
475: 
476: static bool AnyConstraintReferencesGeneratedColumn(CreateTableInfo &table_info) {
477: 	unordered_set<string> generated_columns;
478: 	for (auto &col : table_info.columns.Logical()) {
479: 		if (!col.Generated()) {
480: 			continue;
481: 		}
482: 		generated_columns.insert(col.Name());
483: 	}
484: 	if (generated_columns.empty()) {
485: 		return false;
486: 	}
487: 
488: 	for (auto &constr : table_info.constraints) {
489: 		switch (constr->type) {
490: 		case ConstraintType::CHECK: {
491: 			auto &constraint = constr->Cast<CheckConstraint>();
492: 			auto &expr = constraint.expression;
493: 			bool contains_generated_column = false;
494: 			ExpressionContainsGeneratedColumn(*expr, generated_columns, contains_generated_column);
495: 			if (contains_generated_column) {
496: 				return true;
497: 			}
498: 			break;
499: 		}
500: 		case ConstraintType::NOT_NULL: {
501: 			auto &constraint = constr->Cast<NotNullConstraint>();
502: 			if (table_info.columns.GetColumn(constraint.index).Generated()) {
503: 				return true;
504: 			}
505: 			break;
506: 		}
507: 		case ConstraintType::UNIQUE: {
508: 			auto &constraint = constr->Cast<UniqueConstraint>();
509: 			if (!constraint.HasIndex()) {
510: 				for (auto &col : constraint.GetColumnNames()) {
511: 					if (generated_columns.count(col)) {
512: 						return true;
513: 					}
514: 				}
515: 			} else {
516: 				if (table_info.columns.GetColumn(constraint.GetIndex()).Generated()) {
517: 					return true;
518: 				}
519: 			}
520: 			break;
521: 		}
522: 		case ConstraintType::FOREIGN_KEY: {
523: 			// If it contained a generated column, an exception would have been thrown inside AddDataTableIndex earlier
524: 			break;
525: 		}
526: 		default: {
527: 			throw NotImplementedException("ConstraintType not implemented");
528: 		}
529: 		}
530: 	}
531: 	return false;
532: }
533: 
534: unique_ptr<LogicalOperator> DuckCatalog::BindCreateIndex(Binder &binder, CreateStatement &stmt,
535:                                                          TableCatalogEntry &table, unique_ptr<LogicalOperator> plan) {
536: 	D_ASSERT(plan->type == LogicalOperatorType::LOGICAL_GET);
537: 	auto &base = stmt.info->Cast<CreateIndexInfo>();
538: 
539: 	auto &get = plan->Cast<LogicalGet>();
540: 	// bind the index expressions
541: 	IndexBinder index_binder(binder, binder.context);
542: 	auto &dependencies = base.dependencies;
543: 	auto &catalog = Catalog::GetCatalog(binder.context, base.catalog);
544: 	index_binder.SetCatalogLookupCallback([&dependencies, &catalog](CatalogEntry &entry) {
545: 		if (&catalog != &entry.ParentCatalog()) {
546: 			// Don't register any cross-catalog dependencies
547: 			return;
548: 		}
549: 		dependencies.AddDependency(entry);
550: 	});
551: 	vector<unique_ptr<Expression>> expressions;
552: 	expressions.reserve(base.expressions.size());
553: 	for (auto &expr : base.expressions) {
554: 		expressions.push_back(index_binder.Bind(expr));
555: 	}
556: 
557: 	auto create_index_info = unique_ptr_cast<CreateInfo, CreateIndexInfo>(std::move(stmt.info));
558: 	for (auto &column_id : get.column_ids) {
559: 		if (column_id == COLUMN_IDENTIFIER_ROW_ID) {
560: 			throw BinderException("Cannot create an index on the rowid!");
561: 		}
562: 		create_index_info->scan_types.push_back(get.returned_types[column_id]);
563: 	}
564: 	create_index_info->scan_types.emplace_back(LogicalType::ROW_TYPE);
565: 	create_index_info->names = get.names;
566: 	create_index_info->column_ids = get.column_ids;
567: 	auto &bind_data = get.bind_data->Cast<TableScanBindData>();
568: 	bind_data.is_create_index = true;
569: 	get.column_ids.push_back(COLUMN_IDENTIFIER_ROW_ID);
570: 
571: 	// the logical CREATE INDEX also needs all fields to scan the referenced table
572: 	auto result = make_uniq<LogicalCreateIndex>(std::move(create_index_info), std::move(expressions), table);
573: 	result->children.push_back(std::move(plan));
574: 	return std::move(result);
575: }
576: 
577: BoundStatement Binder::Bind(CreateStatement &stmt) {
578: 	BoundStatement result;
579: 	result.names = {"Count"};
580: 	result.types = {LogicalType::BIGINT};
581: 
582: 	auto catalog_type = stmt.info->type;
583: 	auto &properties = GetStatementProperties();
584: 	switch (catalog_type) {
585: 	case CatalogType::SCHEMA_ENTRY: {
586: 		auto &base = stmt.info->Cast<CreateInfo>();
587: 		auto catalog = BindCatalog(base.catalog);
588: 		properties.modified_databases.insert(catalog);
589: 		result.plan = make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_SCHEMA, std::move(stmt.info));
590: 		break;
591: 	}
592: 	case CatalogType::VIEW_ENTRY: {
593: 		auto &base = stmt.info->Cast<CreateViewInfo>();
594: 		// bind the schema
595: 		auto &schema = BindCreateSchema(*stmt.info);
596: 		BindCreateViewInfo(base);
597: 		result.plan = make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_VIEW, std::move(stmt.info), &schema);
598: 		break;
599: 	}
600: 	case CatalogType::SEQUENCE_ENTRY: {
601: 		auto &schema = BindCreateSchema(*stmt.info);
602: 		result.plan =
603: 		    make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_SEQUENCE, std::move(stmt.info), &schema);
604: 		break;
605: 	}
606: 	case CatalogType::TABLE_MACRO_ENTRY: {
607: 		auto &schema = BindCreateSchema(*stmt.info);
608: 		result.plan =
609: 		    make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_MACRO, std::move(stmt.info), &schema);
610: 		break;
611: 	}
612: 	case CatalogType::MACRO_ENTRY: {
613: 		auto &schema = BindCreateFunctionInfo(*stmt.info);
614: 		auto logical_create =
615: 		    make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_MACRO, std::move(stmt.info), &schema);
616: 		result.plan = std::move(logical_create);
617: 		break;
618: 	}
619: 	case CatalogType::INDEX_ENTRY: {
620: 		auto &base = stmt.info->Cast<CreateIndexInfo>();
621: 
622: 		// visit the table reference
623: 		auto table_ref = make_uniq<BaseTableRef>();
624: 		table_ref->catalog_name = base.catalog;
625: 		table_ref->schema_name = base.schema;
626: 		table_ref->table_name = base.table;
627: 
628: 		auto bound_table = Bind(*table_ref);
629: 		if (bound_table->type != TableReferenceType::BASE_TABLE) {
630: 			throw BinderException("Can only create an index over a base table!");
631: 		}
632: 		auto &table_binding = bound_table->Cast<BoundBaseTableRef>();
633: 		auto &table = table_binding.table;
634: 		if (table.temporary) {
635: 			stmt.info->temporary = true;
636: 		}
637: 		properties.modified_databases.insert(table.catalog.GetName());
638: 
639: 		// create a plan over the bound table
640: 		auto plan = CreatePlan(*bound_table);
641: 		if (plan->type != LogicalOperatorType::LOGICAL_GET) {
642: 			throw BinderException("Cannot create index on a view!");
643: 		}
644: 		result.plan = table.catalog.BindCreateIndex(*this, stmt, table, std::move(plan));
645: 		break;
646: 	}
647: 	case CatalogType::TABLE_ENTRY: {
648: 		auto &create_info = stmt.info->Cast<CreateTableInfo>();
649: 		// If there is a foreign key constraint, resolve primary key column's index from primary key column's name
650: 		reference_set_t<SchemaCatalogEntry> fk_schemas;
651: 		for (idx_t i = 0; i < create_info.constraints.size(); i++) {
652: 			auto &cond = create_info.constraints[i];
653: 			if (cond->type != ConstraintType::FOREIGN_KEY) {
654: 				continue;
655: 			}
656: 			auto &fk = cond->Cast<ForeignKeyConstraint>();
657: 			if (fk.info.type != ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE) {
658: 				continue;
659: 			}
660: 			D_ASSERT(fk.info.pk_keys.empty());
661: 			D_ASSERT(fk.info.fk_keys.empty());
662: 			FindForeignKeyIndexes(create_info.columns, fk.fk_columns, fk.info.fk_keys);
663: 			if (StringUtil::CIEquals(create_info.table, fk.info.table)) {
664: 				// self-referential foreign key constraint
665: 				fk.info.type = ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE;
666: 				FindMatchingPrimaryKeyColumns(create_info.columns, create_info.constraints, fk);
667: 				FindForeignKeyIndexes(create_info.columns, fk.pk_columns, fk.info.pk_keys);
668: 				CheckForeignKeyTypes(create_info.columns, create_info.columns, fk);
669: 			} else {
670: 				// have to resolve referenced table
671: 				auto table_entry =
672: 				    entry_retriever.GetEntry(CatalogType::TABLE_ENTRY, INVALID_CATALOG, fk.info.schema, fk.info.table);
673: 				auto &pk_table_entry_ptr = table_entry->Cast<TableCatalogEntry>();
674: 				fk_schemas.insert(pk_table_entry_ptr.schema);
675: 				FindMatchingPrimaryKeyColumns(pk_table_entry_ptr.GetColumns(), pk_table_entry_ptr.GetConstraints(), fk);
676: 				FindForeignKeyIndexes(pk_table_entry_ptr.GetColumns(), fk.pk_columns, fk.info.pk_keys);
677: 				CheckForeignKeyTypes(pk_table_entry_ptr.GetColumns(), create_info.columns, fk);
678: 				auto &storage = pk_table_entry_ptr.GetStorage();
679: 
680: 				if (!storage.HasForeignKeyIndex(fk.info.pk_keys, ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE)) {
681: 					auto fk_column_names = StringUtil::Join(fk.pk_columns, ",");
682: 					throw BinderException("Failed to create foreign key on %s(%s): no UNIQUE or PRIMARY KEY constraint "
683: 					                      "present on these columns",
684: 					                      pk_table_entry_ptr.name, fk_column_names);
685: 				}
686: 			}
687: 			D_ASSERT(fk.info.pk_keys.size() == fk.info.fk_keys.size());
688: 			D_ASSERT(fk.info.pk_keys.size() == fk.pk_columns.size());
689: 			D_ASSERT(fk.info.fk_keys.size() == fk.fk_columns.size());
690: 		}
691: 		if (AnyConstraintReferencesGeneratedColumn(create_info)) {
692: 			throw BinderException("Constraints on generated columns are not supported yet");
693: 		}
694: 		auto bound_info = BindCreateTableInfo(std::move(stmt.info));
695: 		auto root = std::move(bound_info->query);
696: 		for (auto &fk_schema : fk_schemas) {
697: 			if (&fk_schema.get() != &bound_info->schema) {
698: 				throw BinderException("Creating foreign keys across different schemas or catalogs is not supported");
699: 			}
700: 		}
701: 
702: 		// create the logical operator
703: 		auto &schema = bound_info->schema;
704: 		auto create_table = make_uniq<LogicalCreateTable>(schema, std::move(bound_info));
705: 		if (root) {
706: 			// CREATE TABLE AS
707: 			properties.return_type = StatementReturnType::CHANGED_ROWS;
708: 			create_table->children.push_back(std::move(root));
709: 		}
710: 		result.plan = std::move(create_table);
711: 		break;
712: 	}
713: 	case CatalogType::TYPE_ENTRY: {
714: 		auto &schema = BindCreateSchema(*stmt.info);
715: 		auto &create_type_info = stmt.info->Cast<CreateTypeInfo>();
716: 		result.plan = make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_TYPE, std::move(stmt.info), &schema);
717: 
718: 		auto &catalog = Catalog::GetCatalog(context, create_type_info.catalog);
719: 		auto &dependencies = create_type_info.dependencies;
720: 		auto dependency_callback = [&dependencies, &catalog](CatalogEntry &entry) {
721: 			if (&catalog != &entry.ParentCatalog()) {
722: 				// Don't register any cross-catalog dependencies
723: 				return;
724: 			}
725: 			dependencies.AddDependency(entry);
726: 		};
727: 		if (create_type_info.query) {
728: 			// CREATE TYPE mood AS ENUM (SELECT 'happy')
729: 			auto query_obj = Bind(*create_type_info.query);
730: 			auto query = std::move(query_obj.plan);
731: 			create_type_info.query.reset();
732: 
733: 			auto &sql_types = query_obj.types;
734: 			if (sql_types.size() != 1) {
735: 				// add cast expression?
736: 				throw BinderException("The query must return a single column");
737: 			}
738: 			if (sql_types[0].id() != LogicalType::VARCHAR) {
739: 				// push a projection casting to varchar
740: 				vector<unique_ptr<Expression>> select_list;
741: 				auto ref = make_uniq<BoundColumnRefExpression>(sql_types[0], query->GetColumnBindings()[0]);
742: 				auto cast_expr = BoundCastExpression::AddCastToType(context, std::move(ref), LogicalType::VARCHAR);
743: 				select_list.push_back(std::move(cast_expr));
744: 				auto proj = make_uniq<LogicalProjection>(GenerateTableIndex(), std::move(select_list));
745: 				proj->AddChild(std::move(query));
746: 				query = std::move(proj);
747: 			}
748: 
749: 			result.plan->AddChild(std::move(query));
750: 		} else if (create_type_info.type.id() == LogicalTypeId::USER) {
751: 			SetCatalogLookupCallback(dependency_callback);
752: 			// two cases:
753: 			// 1: create a type with a non-existent type as source, Binder::BindLogicalType(...) will throw exception.
754: 			// 2: create a type alias with a custom type.
755: 			// eg. CREATE TYPE a AS INT; CREATE TYPE b AS a;
756: 			// We set b to be an alias for the underlying type of a
757: 			auto type_entry_p = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, schema.catalog.GetName(), schema.name,
758: 			                                             UserType::GetTypeName(create_type_info.type));
759: 			D_ASSERT(type_entry_p);
760: 			auto &type_entry = type_entry_p->Cast<TypeCatalogEntry>();
761: 			create_type_info.type = type_entry.user_type;
762: 		} else {
763: 			SetCatalogLookupCallback(dependency_callback);
764: 			// This is done so that if the type contains a USER type,
765: 			// we register this dependency
766: 			auto preserved_type = create_type_info.type;
767: 			BindLogicalType(create_type_info.type);
768: 			create_type_info.type = preserved_type;
769: 		}
770: 		break;
771: 	}
772: 	case CatalogType::SECRET_ENTRY: {
773: 		CatalogTransaction transaction = CatalogTransaction(Catalog::GetSystemCatalog(context), context);
774: 		properties.return_type = StatementReturnType::QUERY_RESULT;
775: 		return SecretManager::Get(context).BindCreateSecret(transaction, stmt.info->Cast<CreateSecretInfo>());
776: 	}
777: 	default:
778: 		throw InternalException("Unrecognized type!");
779: 	}
780: 	properties.return_type = StatementReturnType::NOTHING;
781: 	properties.allow_stream_result = false;
782: 	return result;
783: }
784: 
785: } // namespace duckdb
[end of src/planner/binder/statement/bind_create.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: