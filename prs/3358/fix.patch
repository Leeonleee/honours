diff --git a/src/include/duckdb/storage/data_table.hpp b/src/include/duckdb/storage/data_table.hpp
index ea09536932ff..abe664f3b7ae 100644
--- a/src/include/duckdb/storage/data_table.hpp
+++ b/src/include/duckdb/storage/data_table.hpp
@@ -76,6 +76,8 @@ class TableIndexList {
 		return indexes.size();
 	}
 
+	Index *FindForeignKeyIndex(const vector<idx_t> &fk_keys, ForeignKeyType fk_type);
+
 private:
 	//! Indexes associated with the current table
 	mutex indexes_lock;
diff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp
index f98f76feaca5..3f5a56ee8811 100644
--- a/src/planner/binder/statement/bind_create.cpp
+++ b/src/planner/binder/statement/bind_create.cpp
@@ -26,6 +26,7 @@
 #include "duckdb/planner/tableref/bound_basetableref.hpp"
 #include "duckdb/parser/constraints/foreign_key_constraint.hpp"
 #include "duckdb/function/scalar_macro_function.hpp"
+#include "duckdb/storage/data_table.hpp"
 
 namespace duckdb {
 
@@ -241,10 +242,18 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {
 				for (auto &keyname : fk.pk_columns) {
 					auto entry = pk_table_entry_ptr->name_map.find(keyname);
 					if (entry == pk_table_entry_ptr->name_map.end()) {
-						throw ParserException("column \"%s\" named in key does not exist", keyname);
+						throw BinderException("column \"%s\" named in key does not exist", keyname);
 					}
 					fk.info.pk_keys.push_back(entry->second);
 				}
+				auto index = pk_table_entry_ptr->storage->info->indexes.FindForeignKeyIndex(
+				    fk.info.pk_keys, ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE);
+				if (!index) {
+					auto fk_column_names = StringUtil::Join(fk.pk_columns, ",");
+					throw BinderException("Failed to create foreign key on %s(%s): no UNIQUE or PRIMARY KEY constraint "
+					                      "present on these columns",
+					                      pk_table_entry_ptr->name, fk_column_names);
+				}
 			}
 		}
 		// We first check if there are any user types, if yes we check to which custom types they refer.
diff --git a/src/planner/binder/statement/bind_create_table.cpp b/src/planner/binder/statement/bind_create_table.cpp
index 12c118fa24a4..14cd22f16776 100644
--- a/src/planner/binder/statement/bind_create_table.cpp
+++ b/src/planner/binder/statement/bind_create_table.cpp
@@ -113,7 +113,7 @@ static void BindConstraints(Binder &binder, BoundCreateTableInfo &info) {
 				for (auto &keyname : fk.pk_columns) {
 					auto entry = info.name_map.find(keyname);
 					if (entry == info.name_map.end()) {
-						throw ParserException("column \"%s\" named in key does not exist", keyname);
+						throw BinderException("column \"%s\" named in key does not exist", keyname);
 					}
 					fk.info.pk_keys.push_back(entry->second);
 				}
@@ -122,7 +122,7 @@ static void BindConstraints(Binder &binder, BoundCreateTableInfo &info) {
 				for (auto &keyname : fk.fk_columns) {
 					auto entry = info.name_map.find(keyname);
 					if (entry == info.name_map.end()) {
-						throw ParserException("column \"%s\" named in key does not exist", keyname);
+						throw BinderException("column \"%s\" named in key does not exist", keyname);
 					}
 					fk.info.fk_keys.push_back(entry->second);
 				}
diff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp
index d06fed2c20ee..f98f76a846d3 100644
--- a/src/storage/data_table.cpp
+++ b/src/storage/data_table.cpp
@@ -437,11 +437,17 @@ static void VerifyCheckConstraint(TableCatalogEntry &table, Expression &expr, Da
 	}
 }
 
-static bool FindColumnIndex(const vector<idx_t> *keys_ptr, const vector<column_t> &index_column_ids) {
-	for (idx_t i = 0; i < keys_ptr->size(); i++) {
+static bool IsForeignKeyIndex(const vector<idx_t> &fk_keys, Index &index, ForeignKeyType fk_type) {
+	if (fk_type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE ? !index.IsUnique() : !index.IsForeign()) {
+		return false;
+	}
+	if (fk_keys.size() != index.column_ids.size()) {
+		return false;
+	}
+	for (auto &fk_key : fk_keys) {
 		bool is_found = false;
-		for (idx_t j = 0; j < index_column_ids.size(); j++) {
-			if ((*keys_ptr)[i] == index_column_ids[j]) {
+		for (auto &index_key : index.column_ids) {
+			if (fk_key == index_key) {
 				is_found = true;
 				break;
 			}
@@ -450,10 +456,20 @@ static bool FindColumnIndex(const vector<idx_t> *keys_ptr, const vector<column_t
 			return false;
 		}
 	}
-
 	return true;
 }
 
+Index *TableIndexList::FindForeignKeyIndex(const vector<idx_t> &fk_keys, ForeignKeyType fk_type) {
+	Index *result = nullptr;
+	Scan([&](Index &index) {
+		if (IsForeignKeyIndex(fk_keys, index, fk_type)) {
+			result = &index;
+		}
+		return false;
+	});
+	return result;
+}
+
 static void VerifyForeignKeyConstraint(const BoundForeignKeyConstraint &bfk, ClientContext &context, DataChunk &chunk,
                                        bool is_append) {
 	const vector<idx_t> *src_keys_ptr = &bfk.info.fk_keys;
@@ -492,26 +508,24 @@ static void VerifyForeignKeyConstraint(const BoundForeignKeyConstraint &bfk, Cli
 	err_msgs.resize(count);
 	tran_err_msgs.resize(count);
 
+	auto fk_type = is_append ? ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE : ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE;
 	// check whether or not the chunk can be inserted or deleted into the referenced table' storage
-	TableIndexList &table_indices = data_table->info->indexes;
-	table_indices.Scan([&](Index &index) {
-		if (FindColumnIndex(dst_keys_ptr, index.column_ids)) {
-			if (is_append) {
-				index.VerifyAppendForeignKey(dst_chunk, err_msgs.data());
-			} else {
-				index.VerifyDeleteForeignKey(dst_chunk, err_msgs.data());
-			}
-		}
-		return false;
-	});
-
+	auto index = data_table->info->indexes.FindForeignKeyIndex(*dst_keys_ptr, fk_type);
+	if (!index) {
+		throw InternalException("Internal Foreign Key error: could not find index to verify...");
+	}
+	if (is_append) {
+		index->VerifyAppendForeignKey(dst_chunk, err_msgs.data());
+	} else {
+		index->VerifyDeleteForeignKey(dst_chunk, err_msgs.data());
+	}
 	// check whether or not the chunk can be inserted or deleted into the referenced table' transaction local storage
 	auto &transaction = Transaction::GetTransaction(context);
 	bool transaction_check = transaction.storage.Find(data_table);
 	if (transaction_check) {
 		vector<unique_ptr<Index>> &transact_index_vec = transaction.storage.GetIndexes(data_table);
 		for (idx_t i = 0; i < transact_index_vec.size(); i++) {
-			if (FindColumnIndex(dst_keys_ptr, transact_index_vec[i]->column_ids)) {
+			if (IsForeignKeyIndex(*dst_keys_ptr, *transact_index_vec[i], fk_type)) {
 				if (is_append) {
 					transact_index_vec[i]->VerifyAppendForeignKey(dst_chunk, tran_err_msgs.data());
 				} else {
