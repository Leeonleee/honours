{
  "repo": "duckdb/duckdb",
  "pull_number": 3358,
  "instance_id": "duckdb__duckdb-3358",
  "issue_numbers": [
    "3352",
    "3352"
  ],
  "base_commit": "7c5ba6c0e1521a76a6644a4525dd6f393215baed",
  "patch": "diff --git a/src/include/duckdb/storage/data_table.hpp b/src/include/duckdb/storage/data_table.hpp\nindex ea09536932ff..abe664f3b7ae 100644\n--- a/src/include/duckdb/storage/data_table.hpp\n+++ b/src/include/duckdb/storage/data_table.hpp\n@@ -76,6 +76,8 @@ class TableIndexList {\n \t\treturn indexes.size();\n \t}\n \n+\tIndex *FindForeignKeyIndex(const vector<idx_t> &fk_keys, ForeignKeyType fk_type);\n+\n private:\n \t//! Indexes associated with the current table\n \tmutex indexes_lock;\ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex f98f76feaca5..3f5a56ee8811 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -26,6 +26,7 @@\n #include \"duckdb/planner/tableref/bound_basetableref.hpp\"\n #include \"duckdb/parser/constraints/foreign_key_constraint.hpp\"\n #include \"duckdb/function/scalar_macro_function.hpp\"\n+#include \"duckdb/storage/data_table.hpp\"\n \n namespace duckdb {\n \n@@ -241,10 +242,18 @@ BoundStatement Binder::Bind(CreateStatement &stmt) {\n \t\t\t\tfor (auto &keyname : fk.pk_columns) {\n \t\t\t\t\tauto entry = pk_table_entry_ptr->name_map.find(keyname);\n \t\t\t\t\tif (entry == pk_table_entry_ptr->name_map.end()) {\n-\t\t\t\t\t\tthrow ParserException(\"column \\\"%s\\\" named in key does not exist\", keyname);\n+\t\t\t\t\t\tthrow BinderException(\"column \\\"%s\\\" named in key does not exist\", keyname);\n \t\t\t\t\t}\n \t\t\t\t\tfk.info.pk_keys.push_back(entry->second);\n \t\t\t\t}\n+\t\t\t\tauto index = pk_table_entry_ptr->storage->info->indexes.FindForeignKeyIndex(\n+\t\t\t\t    fk.info.pk_keys, ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE);\n+\t\t\t\tif (!index) {\n+\t\t\t\t\tauto fk_column_names = StringUtil::Join(fk.pk_columns, \",\");\n+\t\t\t\t\tthrow BinderException(\"Failed to create foreign key on %s(%s): no UNIQUE or PRIMARY KEY constraint \"\n+\t\t\t\t\t                      \"present on these columns\",\n+\t\t\t\t\t                      pk_table_entry_ptr->name, fk_column_names);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t// We first check if there are any user types, if yes we check to which custom types they refer.\ndiff --git a/src/planner/binder/statement/bind_create_table.cpp b/src/planner/binder/statement/bind_create_table.cpp\nindex 12c118fa24a4..14cd22f16776 100644\n--- a/src/planner/binder/statement/bind_create_table.cpp\n+++ b/src/planner/binder/statement/bind_create_table.cpp\n@@ -113,7 +113,7 @@ static void BindConstraints(Binder &binder, BoundCreateTableInfo &info) {\n \t\t\t\tfor (auto &keyname : fk.pk_columns) {\n \t\t\t\t\tauto entry = info.name_map.find(keyname);\n \t\t\t\t\tif (entry == info.name_map.end()) {\n-\t\t\t\t\t\tthrow ParserException(\"column \\\"%s\\\" named in key does not exist\", keyname);\n+\t\t\t\t\t\tthrow BinderException(\"column \\\"%s\\\" named in key does not exist\", keyname);\n \t\t\t\t\t}\n \t\t\t\t\tfk.info.pk_keys.push_back(entry->second);\n \t\t\t\t}\n@@ -122,7 +122,7 @@ static void BindConstraints(Binder &binder, BoundCreateTableInfo &info) {\n \t\t\t\tfor (auto &keyname : fk.fk_columns) {\n \t\t\t\t\tauto entry = info.name_map.find(keyname);\n \t\t\t\t\tif (entry == info.name_map.end()) {\n-\t\t\t\t\t\tthrow ParserException(\"column \\\"%s\\\" named in key does not exist\", keyname);\n+\t\t\t\t\t\tthrow BinderException(\"column \\\"%s\\\" named in key does not exist\", keyname);\n \t\t\t\t\t}\n \t\t\t\t\tfk.info.fk_keys.push_back(entry->second);\n \t\t\t\t}\ndiff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp\nindex d06fed2c20ee..f98f76a846d3 100644\n--- a/src/storage/data_table.cpp\n+++ b/src/storage/data_table.cpp\n@@ -437,11 +437,17 @@ static void VerifyCheckConstraint(TableCatalogEntry &table, Expression &expr, Da\n \t}\n }\n \n-static bool FindColumnIndex(const vector<idx_t> *keys_ptr, const vector<column_t> &index_column_ids) {\n-\tfor (idx_t i = 0; i < keys_ptr->size(); i++) {\n+static bool IsForeignKeyIndex(const vector<idx_t> &fk_keys, Index &index, ForeignKeyType fk_type) {\n+\tif (fk_type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE ? !index.IsUnique() : !index.IsForeign()) {\n+\t\treturn false;\n+\t}\n+\tif (fk_keys.size() != index.column_ids.size()) {\n+\t\treturn false;\n+\t}\n+\tfor (auto &fk_key : fk_keys) {\n \t\tbool is_found = false;\n-\t\tfor (idx_t j = 0; j < index_column_ids.size(); j++) {\n-\t\t\tif ((*keys_ptr)[i] == index_column_ids[j]) {\n+\t\tfor (auto &index_key : index.column_ids) {\n+\t\t\tif (fk_key == index_key) {\n \t\t\t\tis_found = true;\n \t\t\t\tbreak;\n \t\t\t}\n@@ -450,10 +456,20 @@ static bool FindColumnIndex(const vector<idx_t> *keys_ptr, const vector<column_t\n \t\t\treturn false;\n \t\t}\n \t}\n-\n \treturn true;\n }\n \n+Index *TableIndexList::FindForeignKeyIndex(const vector<idx_t> &fk_keys, ForeignKeyType fk_type) {\n+\tIndex *result = nullptr;\n+\tScan([&](Index &index) {\n+\t\tif (IsForeignKeyIndex(fk_keys, index, fk_type)) {\n+\t\t\tresult = &index;\n+\t\t}\n+\t\treturn false;\n+\t});\n+\treturn result;\n+}\n+\n static void VerifyForeignKeyConstraint(const BoundForeignKeyConstraint &bfk, ClientContext &context, DataChunk &chunk,\n                                        bool is_append) {\n \tconst vector<idx_t> *src_keys_ptr = &bfk.info.fk_keys;\n@@ -492,26 +508,24 @@ static void VerifyForeignKeyConstraint(const BoundForeignKeyConstraint &bfk, Cli\n \terr_msgs.resize(count);\n \ttran_err_msgs.resize(count);\n \n+\tauto fk_type = is_append ? ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE : ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE;\n \t// check whether or not the chunk can be inserted or deleted into the referenced table' storage\n-\tTableIndexList &table_indices = data_table->info->indexes;\n-\ttable_indices.Scan([&](Index &index) {\n-\t\tif (FindColumnIndex(dst_keys_ptr, index.column_ids)) {\n-\t\t\tif (is_append) {\n-\t\t\t\tindex.VerifyAppendForeignKey(dst_chunk, err_msgs.data());\n-\t\t\t} else {\n-\t\t\t\tindex.VerifyDeleteForeignKey(dst_chunk, err_msgs.data());\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t});\n-\n+\tauto index = data_table->info->indexes.FindForeignKeyIndex(*dst_keys_ptr, fk_type);\n+\tif (!index) {\n+\t\tthrow InternalException(\"Internal Foreign Key error: could not find index to verify...\");\n+\t}\n+\tif (is_append) {\n+\t\tindex->VerifyAppendForeignKey(dst_chunk, err_msgs.data());\n+\t} else {\n+\t\tindex->VerifyDeleteForeignKey(dst_chunk, err_msgs.data());\n+\t}\n \t// check whether or not the chunk can be inserted or deleted into the referenced table' transaction local storage\n \tauto &transaction = Transaction::GetTransaction(context);\n \tbool transaction_check = transaction.storage.Find(data_table);\n \tif (transaction_check) {\n \t\tvector<unique_ptr<Index>> &transact_index_vec = transaction.storage.GetIndexes(data_table);\n \t\tfor (idx_t i = 0; i < transact_index_vec.size(); i++) {\n-\t\t\tif (FindColumnIndex(dst_keys_ptr, transact_index_vec[i]->column_ids)) {\n+\t\t\tif (IsForeignKeyIndex(*dst_keys_ptr, *transact_index_vec[i], fk_type)) {\n \t\t\t\tif (is_append) {\n \t\t\t\t\ttransact_index_vec[i]->VerifyAppendForeignKey(dst_chunk, tran_err_msgs.data());\n \t\t\t\t} else {\n",
  "test_patch": "diff --git a/test/issues/fuzz/foreign_key_index_selection.test b/test/issues/fuzz/foreign_key_index_selection.test\nnew file mode 100644\nindex 000000000000..a4bbf806a011\n--- /dev/null\n+++ b/test/issues/fuzz/foreign_key_index_selection.test\n@@ -0,0 +1,37 @@\n+# name: test/issues/fuzz/foreign_key_index_selection.test\n+# description: Issue #3352: String null pointer in foreign key\n+# group: [fuzz]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE s1(t0 INTEGER, a TEXT, b TEXT);\n+\n+# key does not exist\n+statement error\n+CREATE TABLE c2(c0 INTEGER, c1 INTEgiGER UNIQUE, FOREIGN KEY (c0) REFERENCES s1(tz));\n+\n+# key does not have an index on it\n+statement error\n+CREATE TABLE c2(c0 INTEGER, c1 INTEGER UNIQUE, FOREIGN KEY (c0) REFERENCES s1(t0));\n+\n+statement ok\n+CREATE TABLE s2(t0 INTEGER, a TEXT, b TEXT, UNIQUE (t0, a));\n+\n+# key does not have an index on it\n+statement error\n+CREATE TABLE c2(c0 INTEGER, c1 INTEGER UNIQUE, FOREIGN KEY (c0) REFERENCES s2(t0));\n+\n+# this works\n+statement ok\n+CREATE TABLE s3(t0 INTEGER UNIQUE, a TEXT, b TEXT, UNIQUE (t0, a));\n+\n+statement ok\n+CREATE TABLE c2(c0 INTEGER, c1 INTEGER UNIQUE, FOREIGN KEY (c0) REFERENCES s3(t0));\n+\n+statement ok\n+INSERT INTO s3 VALUES (1, 'a', 'b');\n+\n+statement ok\n+INSERT INTO c2 VALUES (1, 2);\n",
  "problem_statement": "NullPointer at duckdb/src/common/types/vector.cpp:995:20\n#### What happens?\r\n```\r\n/root/duckdb/src/common/types/vector.cpp:995:20: runtime error: member call on null pointer of type 'duckdb::string_t'\r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /root/duckdb/src/common/types/vector.cpp:995:20 in \r\n```\r\n\r\n#### To Reproduce\r\n```sql\r\nCREATE TABLE strings(t0 INTEGER, a TEXT, b TEXT, UNIQUE (t0, a));\r\nCREATE TABLE c2(c0 INTEGER, c1 INTEGER UNIQUE, FOREIGN KEY (c0) REFERENCES strings(t0));\r\nINSERT INTO c2 VALUES (1, 101), (2, 102);\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: linux\r\n - DuckDB Version: v0.3.3-dev1395 80ae1e12d\r\n - DuckDB Client: /usr/local/bin/duckdb\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\r\n#### ASAN detail\r\n```\r\nAddressSanitizer:DEADLYSIGNAL\r\n=================================================================\r\n==42723==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x0000018d7787 bp 0x000000000001 sp 0x7ffd7373c320 T0)\r\n==42723==The signal is caused by a READ memory access.\r\n==42723==Hint: address points to the zero page.\r\n    #0 0x18d7787 in void duckdb::ConcatenateKeys<duckdb::string_t>(duckdb::Vector&, unsigned long, std::vector<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> >, std::allocator<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> > > >&, bool) /root/duckdb/src/execution/index/art/art.cpp:108:37\r\n    #1 0x18d7787 in duckdb::ART::GenerateKeys(duckdb::DataChunk&, std::vector<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> >, std::allocator<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> > > >&) /root/duckdb/src/execution/index/art/art.cpp:205:4\r\n    #2 0x18cda72 in duckdb::ART::VerifyExistence(duckdb::DataChunk&, duckdb::VerifyExistenceType, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) /root/duckdb/src/execution/index/art/art.cpp:871:2\r\n    #3 0x64095f in duckdb::VerifyForeignKeyConstraint(duckdb::BoundForeignKeyConstraint const&, duckdb::ClientContext&, duckdb::DataChunk&, bool)::$_18::operator()(duckdb::Index&) const /root/duckdb/src/storage/data_table.cpp:500:11\r\n    #4 0x64095f in void duckdb::TableIndexList::Scan<duckdb::VerifyForeignKeyConstraint(duckdb::BoundForeignKeyConstraint const&, duckdb::ClientContext&, duckdb::DataChunk&, bool)::$_18>(duckdb::VerifyForeignKeyConstraint(duckdb::BoundForeignKeyConstraint const&, duckdb::ClientContext&, duckdb::DataChunk&, bool)::$_18&&) /root/duckdb/src/include/duckdb/storage/data_table.hpp:44:8\r\n    #5 0x64095f in duckdb::VerifyForeignKeyConstraint(duckdb::BoundForeignKeyConstraint const&, duckdb::ClientContext&, duckdb::DataChunk&, bool) /root/duckdb/src/storage/data_table.cpp:497:16\r\n    #6 0x61ae95 in duckdb::VerifyAppendForeignKeyConstraint(duckdb::BoundForeignKeyConstraint const&, duckdb::ClientContext&, duckdb::DataChunk&) /root/duckdb/src/storage/data_table.cpp:558:2\r\n    #7 0x61ae95 in duckdb::DataTable::VerifyAppendConstraints(duckdb::TableCatalogEntry&, duckdb::ClientContext&, duckdb::DataChunk&) /root/duckdb/src/storage/data_table.cpp:592:5\r\n    #8 0x61c622 in duckdb::DataTable::Append(duckdb::TableCatalogEntry&, duckdb::ClientContext&, duckdb::DataChunk&) /root/duckdb/src/storage/data_table.cpp:616:2\r\n    #9 0x18c0b64 in duckdb::PhysicalInsert::Sink(duckdb::ExecutionContext&, duckdb::GlobalSinkState&, duckdb::LocalSinkState&, duckdb::DataChunk&) const /root/duckdb/src/execution/operator/persistent/physical_insert.cpp:78:18\r\n    #10 0x5f5a40 in duckdb::PipelineExecutor::ExecutePushInternal(duckdb::DataChunk&, unsigned long) /root/duckdb/src/parallel/pipeline_executor.cpp:103:38\r\n    #11 0x5ff186 in duckdb::PipelineExecutor::Execute(unsigned long) /root/duckdb/src/parallel/pipeline_executor.cpp:61:17\r\n    #12 0x5ff186 in duckdb::PipelineTask::ExecuteTask(duckdb::TaskExecutionMode) /root/duckdb/src/parallel/pipeline.cpp:42:39\r\n    #13 0x5e0934 in duckdb::ExecutorTask::Execute(duckdb::TaskExecutionMode) /root/duckdb/src/parallel/executor_task.cpp:17:10\r\n    #14 0x5ed394 in duckdb::Executor::ExecuteTask() /root/duckdb/src/parallel/executor.cpp:350:24\r\n    #15 0x5322d1 in duckdb::ClientContext::ExecuteTaskInternal(duckdb::ClientContextLock&, duckdb::PendingQueryResult&) /root/duckdb/src/main/client_context.cpp:336:41\r\n    #16 0x533ea3 in duckdb::PendingQueryResult::ExecuteTaskInternal(duckdb::ClientContextLock&) /root/duckdb/src/main/pending_query_result.cpp:45:18\r\n    #17 0x533ea3 in duckdb::PendingQueryResult::ExecuteInternal(duckdb::ClientContextLock&, bool) /root/duckdb/src/main/pending_query_result.cpp:50:9\r\n    #18 0x518357 in duckdb::ClientContext::ExecutePendingQueryInternal(duckdb::ClientContextLock&, duckdb::PendingQueryResult&, bool) /root/duckdb/src/main/client_context.cpp:700:15\r\n    #19 0x518357 in duckdb::ClientContext::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) /root/duckdb/src/main/client_context.cpp:639:21\r\n    #20 0x519c06 in duckdb::Connection::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /root/duckdb/src/main/connection.cpp:71:25\r\n    #21 0x4e57c8 in duckdb_query /root/duckdb/src/main/capi/duckdb-c.cpp:67:22\r\n    #22 0x4e10d3 in run_one_statement_new(void*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /mnt/jingzhou_workspace/sqlsim/client_new/duckdb/client_new.cpp:57:13\r\n    #23 0x4d3984 in run_testcase(void*&, char const*, int) /root/autodriver.cpp:102:14\r\n    #24 0x4d8601 in do_fuzz()::$_3::operator()() const /root/autodriver.cpp:227:13\r\n    #25 0x4d809e in do_fuzz() /root/autodriver.cpp:235:13\r\n    #26 0x4d8b43 in main /root/autodriver.cpp:292:9\r\n    #27 0x7fc18e43f0b2 in __libc_start_main /build/glibc-sMfBJT/glibc-2.31/csu/../csu/libc-start.c:308:16\r\n    #28 0x4247ad in _start (/root/autodriver+0x4247ad)\r\n\r\nAddressSanitizer can not provide additional info.\r\nSUMMARY: AddressSanitizer: SEGV /root/duckdb/src/execution/index/art/art.cpp:108:37 in void duckdb::ConcatenateKeys<duckdb::string_t>(duckdb::Vector&, unsigned long, std::vector<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> >, std::allocator<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> > > >&, bool)\r\n==42723==ABORTING\r\n```\nNullPointer at duckdb/src/common/types/vector.cpp:995:20\n#### What happens?\r\n```\r\n/root/duckdb/src/common/types/vector.cpp:995:20: runtime error: member call on null pointer of type 'duckdb::string_t'\r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /root/duckdb/src/common/types/vector.cpp:995:20 in \r\n```\r\n\r\n#### To Reproduce\r\n```sql\r\nCREATE TABLE strings(t0 INTEGER, a TEXT, b TEXT, UNIQUE (t0, a));\r\nCREATE TABLE c2(c0 INTEGER, c1 INTEGER UNIQUE, FOREIGN KEY (c0) REFERENCES strings(t0));\r\nINSERT INTO c2 VALUES (1, 101), (2, 102);\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: linux\r\n - DuckDB Version: v0.3.3-dev1395 80ae1e12d\r\n - DuckDB Client: /usr/local/bin/duckdb\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\r\n#### ASAN detail\r\n```\r\nAddressSanitizer:DEADLYSIGNAL\r\n=================================================================\r\n==42723==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x0000018d7787 bp 0x000000000001 sp 0x7ffd7373c320 T0)\r\n==42723==The signal is caused by a READ memory access.\r\n==42723==Hint: address points to the zero page.\r\n    #0 0x18d7787 in void duckdb::ConcatenateKeys<duckdb::string_t>(duckdb::Vector&, unsigned long, std::vector<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> >, std::allocator<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> > > >&, bool) /root/duckdb/src/execution/index/art/art.cpp:108:37\r\n    #1 0x18d7787 in duckdb::ART::GenerateKeys(duckdb::DataChunk&, std::vector<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> >, std::allocator<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> > > >&) /root/duckdb/src/execution/index/art/art.cpp:205:4\r\n    #2 0x18cda72 in duckdb::ART::VerifyExistence(duckdb::DataChunk&, duckdb::VerifyExistenceType, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*) /root/duckdb/src/execution/index/art/art.cpp:871:2\r\n    #3 0x64095f in duckdb::VerifyForeignKeyConstraint(duckdb::BoundForeignKeyConstraint const&, duckdb::ClientContext&, duckdb::DataChunk&, bool)::$_18::operator()(duckdb::Index&) const /root/duckdb/src/storage/data_table.cpp:500:11\r\n    #4 0x64095f in void duckdb::TableIndexList::Scan<duckdb::VerifyForeignKeyConstraint(duckdb::BoundForeignKeyConstraint const&, duckdb::ClientContext&, duckdb::DataChunk&, bool)::$_18>(duckdb::VerifyForeignKeyConstraint(duckdb::BoundForeignKeyConstraint const&, duckdb::ClientContext&, duckdb::DataChunk&, bool)::$_18&&) /root/duckdb/src/include/duckdb/storage/data_table.hpp:44:8\r\n    #5 0x64095f in duckdb::VerifyForeignKeyConstraint(duckdb::BoundForeignKeyConstraint const&, duckdb::ClientContext&, duckdb::DataChunk&, bool) /root/duckdb/src/storage/data_table.cpp:497:16\r\n    #6 0x61ae95 in duckdb::VerifyAppendForeignKeyConstraint(duckdb::BoundForeignKeyConstraint const&, duckdb::ClientContext&, duckdb::DataChunk&) /root/duckdb/src/storage/data_table.cpp:558:2\r\n    #7 0x61ae95 in duckdb::DataTable::VerifyAppendConstraints(duckdb::TableCatalogEntry&, duckdb::ClientContext&, duckdb::DataChunk&) /root/duckdb/src/storage/data_table.cpp:592:5\r\n    #8 0x61c622 in duckdb::DataTable::Append(duckdb::TableCatalogEntry&, duckdb::ClientContext&, duckdb::DataChunk&) /root/duckdb/src/storage/data_table.cpp:616:2\r\n    #9 0x18c0b64 in duckdb::PhysicalInsert::Sink(duckdb::ExecutionContext&, duckdb::GlobalSinkState&, duckdb::LocalSinkState&, duckdb::DataChunk&) const /root/duckdb/src/execution/operator/persistent/physical_insert.cpp:78:18\r\n    #10 0x5f5a40 in duckdb::PipelineExecutor::ExecutePushInternal(duckdb::DataChunk&, unsigned long) /root/duckdb/src/parallel/pipeline_executor.cpp:103:38\r\n    #11 0x5ff186 in duckdb::PipelineExecutor::Execute(unsigned long) /root/duckdb/src/parallel/pipeline_executor.cpp:61:17\r\n    #12 0x5ff186 in duckdb::PipelineTask::ExecuteTask(duckdb::TaskExecutionMode) /root/duckdb/src/parallel/pipeline.cpp:42:39\r\n    #13 0x5e0934 in duckdb::ExecutorTask::Execute(duckdb::TaskExecutionMode) /root/duckdb/src/parallel/executor_task.cpp:17:10\r\n    #14 0x5ed394 in duckdb::Executor::ExecuteTask() /root/duckdb/src/parallel/executor.cpp:350:24\r\n    #15 0x5322d1 in duckdb::ClientContext::ExecuteTaskInternal(duckdb::ClientContextLock&, duckdb::PendingQueryResult&) /root/duckdb/src/main/client_context.cpp:336:41\r\n    #16 0x533ea3 in duckdb::PendingQueryResult::ExecuteTaskInternal(duckdb::ClientContextLock&) /root/duckdb/src/main/pending_query_result.cpp:45:18\r\n    #17 0x533ea3 in duckdb::PendingQueryResult::ExecuteInternal(duckdb::ClientContextLock&, bool) /root/duckdb/src/main/pending_query_result.cpp:50:9\r\n    #18 0x518357 in duckdb::ClientContext::ExecutePendingQueryInternal(duckdb::ClientContextLock&, duckdb::PendingQueryResult&, bool) /root/duckdb/src/main/client_context.cpp:700:15\r\n    #19 0x518357 in duckdb::ClientContext::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) /root/duckdb/src/main/client_context.cpp:639:21\r\n    #20 0x519c06 in duckdb::Connection::Query(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /root/duckdb/src/main/connection.cpp:71:25\r\n    #21 0x4e57c8 in duckdb_query /root/duckdb/src/main/capi/duckdb-c.cpp:67:22\r\n    #22 0x4e10d3 in run_one_statement_new(void*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /mnt/jingzhou_workspace/sqlsim/client_new/duckdb/client_new.cpp:57:13\r\n    #23 0x4d3984 in run_testcase(void*&, char const*, int) /root/autodriver.cpp:102:14\r\n    #24 0x4d8601 in do_fuzz()::$_3::operator()() const /root/autodriver.cpp:227:13\r\n    #25 0x4d809e in do_fuzz() /root/autodriver.cpp:235:13\r\n    #26 0x4d8b43 in main /root/autodriver.cpp:292:9\r\n    #27 0x7fc18e43f0b2 in __libc_start_main /build/glibc-sMfBJT/glibc-2.31/csu/../csu/libc-start.c:308:16\r\n    #28 0x4247ad in _start (/root/autodriver+0x4247ad)\r\n\r\nAddressSanitizer can not provide additional info.\r\nSUMMARY: AddressSanitizer: SEGV /root/duckdb/src/execution/index/art/art.cpp:108:37 in void duckdb::ConcatenateKeys<duckdb::string_t>(duckdb::Vector&, unsigned long, std::vector<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> >, std::allocator<std::unique_ptr<duckdb::Key, std::default_delete<duckdb::Key> > > >&, bool)\r\n==42723==ABORTING\r\n```\n",
  "hints_text": "\n",
  "created_at": "2022-04-02T12:53:33Z"
}