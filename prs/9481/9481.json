{
  "repo": "duckdb/duckdb",
  "pull_number": 9481,
  "instance_id": "duckdb__duckdb-9481",
  "issue_numbers": [
    "9433"
  ],
  "base_commit": "3b810188dc707eaa592997be00de159e9ea33350",
  "patch": "diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex e594df23002d..ec3a0f7cd9a4 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -326,7 +326,8 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \tBoundStatement BindCopyFrom(CopyStatement &stmt);\n \n \tvoid BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);\n-\tvoid BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index);\n+\tvoid BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index,\n+\t                       const vector<idx_t> &expansion_count = {});\n \n \tBoundStatement BindSummarize(ShowStatement &stmt);\n \tunique_ptr<BoundResultModifier> BindLimit(OrderBinder &order_binder, LimitModifier &limit_mod);\ndiff --git a/src/include/duckdb/planner/expression_binder/order_binder.hpp b/src/include/duckdb/planner/expression_binder/order_binder.hpp\nindex 830952cc1911..3beed2c9506d 100644\n--- a/src/include/duckdb/planner/expression_binder/order_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/order_binder.hpp\n@@ -42,7 +42,8 @@ class OrderBinder {\n \tunique_ptr<Expression> CreateExtraReference(unique_ptr<ParsedExpression> expr);\n \n private:\n-\tunique_ptr<Expression> CreateProjectionReference(ParsedExpression &expr, idx_t index);\n+\tunique_ptr<Expression> CreateProjectionReference(ParsedExpression &expr, const idx_t index,\n+\t                                                 const LogicalType &logical_type);\n \tunique_ptr<Expression> BindConstant(ParsedExpression &expr, const Value &val);\n \n private:\ndiff --git a/src/planner/binder/expression/bind_unnest_expression.cpp b/src/planner/binder/expression/bind_unnest_expression.cpp\nindex 00b5a1dfc03f..03c3dccd242e 100644\n--- a/src/planner/binder/expression/bind_unnest_expression.cpp\n+++ b/src/planner/binder/expression/bind_unnest_expression.cpp\n@@ -121,7 +121,7 @@ BindResult SelectBinder::BindUnnest(FunctionExpression &function, idx_t depth, b\n \tif (child_type.id() == LogicalTypeId::SQLNULL) {\n \t\tlist_unnests = 1;\n \t} else {\n-\t\t// first do all of the list unnests\n+\t\t// perform all LIST unnests\n \t\tauto type = child_type;\n \t\tlist_unnests = 0;\n \t\twhile (type.id() == LogicalTypeId::LIST) {\n@@ -131,7 +131,7 @@ BindResult SelectBinder::BindUnnest(FunctionExpression &function, idx_t depth, b\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\t// unnest structs all the way afterwards, if there are any\n+\t\t// unnest structs\n \t\tif (type.id() == LogicalTypeId::STRUCT) {\n \t\t\tstruct_unnests = max_depth - list_unnests;\n \t\t}\n@@ -140,7 +140,7 @@ BindResult SelectBinder::BindUnnest(FunctionExpression &function, idx_t depth, b\n \t\treturn BindResult(binder.FormatError(\n \t\t    function, \"UNNEST() on a struct column can only be applied as the root element of a SELECT expression\"));\n \t}\n-\t// perform all of the list unnests first\n+\t// perform all LIST unnests\n \tauto return_type = child_type;\n \tfor (idx_t current_depth = 0; current_depth < list_unnests; current_depth++) {\n \t\tif (return_type.id() == LogicalTypeId::LIST) {\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 36d11109d945..a4906402b6d8 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -28,7 +28,7 @@\n namespace duckdb {\n \n unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {\n-\t// we treat the Distinct list as a order by\n+\t// we treat the distinct list as an ORDER BY\n \tauto bound_expr = order_binder.Bind(std::move(expr));\n \tif (!bound_expr) {\n \t\t// DISTINCT ON non-integer constant\n@@ -203,7 +203,8 @@ static void AssignReturnType(unique_ptr<Expression> &expr, const vector<LogicalT\n \tbound_colref.return_type = sql_types[bound_colref.binding.column_index];\n }\n \n-void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index) {\n+void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t,\n+                               const vector<idx_t> &expansion_count) {\n \tfor (auto &bound_mod : result.modifiers) {\n \t\tswitch (bound_mod->type) {\n \t\tcase ResultModifierType::DISTINCT_MODIFIER: {\n@@ -216,7 +217,13 @@ void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType>\n \t\t\t\tif (bound_colref.binding.column_index == DConstants::INVALID_INDEX) {\n \t\t\t\t\tthrow BinderException(\"Ambiguous name in DISTINCT ON!\");\n \t\t\t\t}\n-\t\t\t\tD_ASSERT(bound_colref.binding.column_index < sql_types.size());\n+\n+\t\t\t\tidx_t max_count = sql_types.size();\n+\t\t\t\tif (bound_colref.binding.column_index > max_count - 1) {\n+\t\t\t\t\tD_ASSERT(bound_colref.return_type == LogicalType::ANY);\n+\t\t\t\t\tthrow BinderException(\"ORDER term out of range - should be between 1 and %lld\", max_count);\n+\t\t\t\t}\n+\n \t\t\t\tbound_colref.return_type = sql_types[bound_colref.binding.column_index];\n \t\t\t}\n \t\t\tfor (auto &target_distinct : distinct.target_distincts) {\n@@ -239,17 +246,30 @@ void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType>\n \t\t\tbreak;\n \t\t}\n \t\tcase ResultModifierType::ORDER_MODIFIER: {\n+\n \t\t\tauto &order = bound_mod->Cast<BoundOrderModifier>();\n \t\t\tfor (auto &order_node : order.orders) {\n+\n \t\t\t\tauto &expr = order_node.expression;\n \t\t\t\tD_ASSERT(expr->type == ExpressionType::BOUND_COLUMN_REF);\n \t\t\t\tauto &bound_colref = expr->Cast<BoundColumnRefExpression>();\n \t\t\t\tif (bound_colref.binding.column_index == DConstants::INVALID_INDEX) {\n \t\t\t\t\tthrow BinderException(\"Ambiguous name in ORDER BY!\");\n \t\t\t\t}\n-\t\t\t\tD_ASSERT(bound_colref.binding.column_index < sql_types.size());\n+\n+\t\t\t\tif (!expansion_count.empty() && bound_colref.return_type.id() != LogicalTypeId::ANY) {\n+\t\t\t\t\tbound_colref.binding.column_index = expansion_count[bound_colref.binding.column_index];\n+\t\t\t\t}\n+\n+\t\t\t\tidx_t max_count = sql_types.size();\n+\t\t\t\tif (bound_colref.binding.column_index > max_count - 1) {\n+\t\t\t\t\tD_ASSERT(bound_colref.return_type == LogicalType::ANY);\n+\t\t\t\t\tthrow BinderException(\"ORDER term out of range - should be between 1 and %lld\", max_count);\n+\t\t\t\t}\n+\n \t\t\t\tconst auto &sql_type = sql_types[bound_colref.binding.column_index];\n-\t\t\t\tbound_colref.return_type = sql_types[bound_colref.binding.column_index];\n+\t\t\t\tbound_colref.return_type = sql_type;\n+\n \t\t\t\tExpressionBinder::PushCollation(context, order_node.expression, sql_type);\n \t\t\t}\n \t\t\tbreak;\n@@ -434,9 +454,15 @@ unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_\n \n \t// after that, we bind to the SELECT list\n \tSelectBinder select_binder(*this, context, *result, info, alias_map);\n-\tvector<LogicalType> internal_sql_types;\n+\n+\t// if we expand select-list expressions, e.g., via UNNEST, then we need to possibly\n+\t// adjust the column index of the already bound ORDER BY modifiers, and not only set their types\n+\tvector<LogicalType> modifier_sql_types;\n+\tvector<idx_t> modifier_expansion_count;\n+\n \tvector<idx_t> group_by_all_indexes;\n \tvector<string> new_names;\n+\n \tfor (idx_t i = 0; i < statement.select_list.size(); i++) {\n \t\tbool is_window = statement.select_list[i]->IsWindow();\n \t\tidx_t unnest_count = result->unnests.size();\n@@ -445,6 +471,7 @@ unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_\n \t\tbool is_original_column = i < result->column_count;\n \t\tbool can_group_by_all =\n \t\t    statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES && is_original_column;\n+\n \t\tif (select_binder.HasExpandedExpressions()) {\n \t\t\tif (!is_original_column) {\n \t\t\t\tthrow InternalException(\"Only original columns can have expanded expressions\");\n@@ -452,16 +479,26 @@ unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_\n \t\t\tif (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {\n \t\t\t\tthrow BinderException(\"UNNEST of struct cannot be combined with GROUP BY ALL\");\n \t\t\t}\n+\n \t\t\tauto &struct_expressions = select_binder.ExpandedExpressions();\n \t\t\tD_ASSERT(!struct_expressions.empty());\n+\t\t\tmodifier_expansion_count.push_back(modifier_sql_types.size());\n+\n \t\t\tfor (auto &struct_expr : struct_expressions) {\n+\t\t\t\tmodifier_sql_types.push_back(struct_expr->return_type);\n \t\t\t\tnew_names.push_back(struct_expr->GetName());\n \t\t\t\tresult->types.push_back(struct_expr->return_type);\n \t\t\t\tresult->select_list.push_back(std::move(struct_expr));\n \t\t\t}\n+\n \t\t\tstruct_expressions.clear();\n \t\t\tcontinue;\n \t\t}\n+\n+\t\t// not an expanded expression\n+\t\tmodifier_expansion_count.push_back(modifier_sql_types.size());\n+\t\tmodifier_sql_types.push_back(result_type);\n+\n \t\tif (can_group_by_all && select_binder.HasBoundColumns()) {\n \t\t\tif (select_binder.BoundAggregates()) {\n \t\t\t\tthrow BinderException(\"Cannot mix aggregates with non-aggregated columns!\");\n@@ -476,16 +513,18 @@ unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_\n \t\t\t// this entry becomes a group\n \t\t\tgroup_by_all_indexes.push_back(i);\n \t\t}\n+\n \t\tresult->select_list.push_back(std::move(expr));\n \t\tif (is_original_column) {\n \t\t\tnew_names.push_back(std::move(result->names[i]));\n \t\t\tresult->types.push_back(result_type);\n \t\t}\n-\t\tinternal_sql_types.push_back(result_type);\n+\n \t\tif (can_group_by_all) {\n \t\t\tselect_binder.ResetBindings();\n \t\t}\n \t}\n+\n \t// push the GROUP BY ALL expressions into the group set\n \tfor (auto &group_by_all_index : group_by_all_indexes) {\n \t\tauto &expr = result->select_list[group_by_all_index];\n@@ -541,7 +580,7 @@ unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_\n \t}\n \n \t// now that the SELECT list is bound, we set the types of DISTINCT/ORDER BY expressions\n-\tBindModifierTypes(*result, internal_sql_types, result->projection_index);\n+\tBindModifierTypes(*result, modifier_sql_types, result->projection_index, modifier_expansion_count);\n \treturn std::move(result);\n }\n \ndiff --git a/src/planner/expression_binder/order_binder.cpp b/src/planner/expression_binder/order_binder.cpp\nindex ee59c6844386..0235d55ea2ed 100644\n--- a/src/planner/expression_binder/order_binder.cpp\n+++ b/src/planner/expression_binder/order_binder.cpp\n@@ -25,7 +25,8 @@ OrderBinder::OrderBinder(vector<Binder *> binders, idx_t projection_index, Selec\n \tthis->extra_list = &node.select_list;\n }\n \n-unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &expr, idx_t index) {\n+unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &expr, const idx_t index,\n+                                                              const LogicalType &logical_type) {\n \tstring alias;\n \tif (extra_list && index < extra_list->size()) {\n \t\talias = extra_list->at(index)->ToString();\n@@ -34,8 +35,7 @@ unique_ptr<Expression> OrderBinder::CreateProjectionReference(ParsedExpression &\n \t\t\talias = expr.alias;\n \t\t}\n \t}\n-\treturn make_uniq<BoundColumnRefExpression>(std::move(alias), LogicalType::INVALID,\n-\t                                           ColumnBinding(projection_index, index));\n+\treturn make_uniq<BoundColumnRefExpression>(std::move(alias), logical_type, ColumnBinding(projection_index, index));\n }\n \n unique_ptr<Expression> OrderBinder::CreateExtraReference(unique_ptr<ParsedExpression> expr) {\n@@ -43,7 +43,7 @@ unique_ptr<Expression> OrderBinder::CreateExtraReference(unique_ptr<ParsedExpres\n \t\tthrow InternalException(\"CreateExtraReference called without extra_list\");\n \t}\n \tprojection_map[*expr] = extra_list->size();\n-\tauto result = CreateProjectionReference(*expr, extra_list->size());\n+\tauto result = CreateProjectionReference(*expr, extra_list->size(), LogicalType::INVALID);\n \textra_list->push_back(std::move(expr));\n \treturn result;\n }\n@@ -58,10 +58,7 @@ unique_ptr<Expression> OrderBinder::BindConstant(ParsedExpression &expr, const V\n \t}\n \t// INTEGER constant: we use the integer as an index into the select list (e.g. ORDER BY 1)\n \tauto index = (idx_t)val.GetValue<int64_t>();\n-\tif (index < 1 || index > max_count) {\n-\t\tthrow BinderException(\"ORDER term out of range - should be between 1 and %lld\", (idx_t)max_count);\n-\t}\n-\treturn CreateProjectionReference(expr, index - 1);\n+\treturn CreateProjectionReference(expr, index - 1, LogicalType::ANY);\n }\n \n unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {\n@@ -89,7 +86,7 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {\n \t\tauto entry = alias_map.find(colref.column_names[0]);\n \t\tif (entry != alias_map.end()) {\n \t\t\t// it does! point it to that entry\n-\t\t\treturn CreateProjectionReference(*expr, entry->second);\n+\t\t\treturn CreateProjectionReference(*expr, entry->second, LogicalType::INVALID);\n \t\t}\n \t\tbreak;\n \t}\n@@ -98,7 +95,7 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {\n \t\tif (posref.index < 1 || posref.index > max_count) {\n \t\t\tthrow BinderException(\"ORDER term out of range - should be between 1 and %lld\", (idx_t)max_count);\n \t\t}\n-\t\treturn CreateProjectionReference(*expr, posref.index - 1);\n+\t\treturn CreateProjectionReference(*expr, posref.index - 1, LogicalType::ANY);\n \t}\n \tcase ExpressionClass::PARAMETER: {\n \t\tthrow ParameterNotAllowedException(\"Parameter not supported in ORDER BY clause\");\n@@ -119,7 +116,7 @@ unique_ptr<Expression> OrderBinder::Bind(unique_ptr<ParsedExpression> expr) {\n \t\t}\n \t\t// there is a matching entry in the projection list\n \t\t// just point to that entry\n-\t\treturn CreateProjectionReference(*expr, entry->second);\n+\t\treturn CreateProjectionReference(*expr, entry->second, LogicalType::INVALID);\n \t}\n \tif (!extra_list) {\n \t\t// no extra list specified: we cannot push an extra ORDER BY clause\n",
  "test_patch": "diff --git a/test/sql/aggregate/distinct/test_distinct_on.test b/test/sql/aggregate/distinct/test_distinct_on.test\nindex 205d858c37ba..a2270579d62f 100644\n--- a/test/sql/aggregate/distinct/test_distinct_on.test\n+++ b/test/sql/aggregate/distinct/test_distinct_on.test\n@@ -129,4 +129,5 @@ SELECT DISTINCT ON (integers.i) integers.i, integers.j FROM integers ORDER BY i,\n # out of bounds\n statement error\n SELECT DISTINCT ON (2) i FROM integers\n-\n+----\n+Binder Error: ORDER term out of range - should be between 1 and 1\n\\ No newline at end of file\ndiff --git a/test/sql/order/test_order_by.test b/test/sql/order/test_order_by.test\nindex 6bc016c2dc56..da61c1ff8901 100644\n--- a/test/sql/order/test_order_by.test\n+++ b/test/sql/order/test_order_by.test\n@@ -174,5 +174,4 @@ SELECT a-10 AS k FROM test UNION SELECT a-11 AS l FROM test ORDER BY a-11;\n 0\n 1\n 2\n-3\n-\n+3\n\\ No newline at end of file\ndiff --git a/test/sql/order/test_order_unnest.test b/test/sql/order/test_order_unnest.test\nnew file mode 100644\nindex 000000000000..c835f34cc167\n--- /dev/null\n+++ b/test/sql/order/test_order_unnest.test\n@@ -0,0 +1,53 @@\n+# name: test/sql/order/test_order_unnest.test\n+# description: Test ORDER BY keyword with unnesting structs\n+# group: [order]\n+\n+# issue #9433\n+\n+statement ok\n+CREATE TABLE tbl_structs AS SELECT\n+\t{'a': 2.0, 'b': 'hello', 'c': [1, 2]} AS s1,\n+\t1::BIGINT AS i,\n+\t{'k': 1::TINYINT, 'j': 0::BOOL} AS s2;\n+\n+statement ok\n+INSERT INTO tbl_structs VALUES (\n+\t{'a': 1.0, 'b': 'yay', 'c': [10, 20]},\n+\t42,\n+\t{'k': 2, 'j': 1});\n+\n+query IIII\n+SELECT UNNEST(s1), s1.a AS id FROM tbl_structs ORDER BY id;\n+----\n+1.0\tyay\t[10, 20]\t1.0\n+2.0\thello\t[1, 2]\t2.0\n+\n+query II\n+SELECT s1, s1.a FROM tbl_structs ORDER BY 1;\n+----\n+{'a': 1.0, 'b': yay, 'c': [10, 20]}\t1.0\n+{'a': 2.0, 'b': hello, 'c': [1, 2]}\t2.0\n+\n+query IIII\n+SELECT UNNEST(s1), s1.a AS id FROM tbl_structs ORDER BY 1;\n+----\n+1.0\tyay\t[10, 20]\t1.0\n+2.0\thello\t[1, 2]\t2.0\n+\n+query IIIIII\n+SELECT UNNEST(s1), UNNEST(s2), i FROM tbl_structs ORDER BY i;\n+----\n+2.0\thello\t[1, 2]\t1\tFalse\t1\n+1.0\tyay\t[10, 20]\t2\tTrue\t42\n+\n+query IIIIII\n+SELECT UNNEST(s1), UNNEST(s2), i FROM tbl_structs ORDER BY 2 DESC;\n+----\n+1.0\tyay\t[10, 20]\t2\tTrue\t42\n+2.0\thello\t[1, 2]\t1\tFalse\t1\n+\n+query IIIIII\n+SELECT i, UNNEST(s1), UNNEST(s2) FROM tbl_structs ORDER BY 5 DESC;\n+----\n+42\t1.0\tyay\t[10, 20]\t2\tTrue\n+1\t2.0\thello\t[1, 2]\t1\tFalse\n\\ No newline at end of file\n",
  "problem_statement": "INTERNAL Error: Attempted to access index 1 within vector of size 1\n### What happens?\n\nWhen attempting to use an `ORDER BY` clause in a query, I get the below error. Without the `ORDER BY` clause, there is no issue with the query and it executes successfully.\r\n\r\nAfter the error is received, the database is in a bad state/crashed, and I must re-connect to run more queries.\r\n\r\nQuery:\r\n```\r\nSELECT UNNEST(player_statistics) FROM \r\n\t(SELECT player.id AS player_id,\r\n         UNNEST (player_stats.statistics).team.id AS team_id,\r\n         UNNEST (player_stats.statistics).games.appearences * UNNEST (player_stats.statistics).games.minutes AS totals\r\n\t FROM player_stats) AS player_statistics\r\nWHERE team_id = 48\r\nAND totals > 0\r\nORDER BY totals\r\n```\r\n\r\n```\r\norg.jkiss.dbeaver.model.sql.DBSQLException: SQL Error: java.sql.SQLException: INTERNAL Error: Attempted to access index 1 within vector of size 1\r\n\tat org.jkiss.dbeaver.model.impl.jdbc.exec.JDBCStatementImpl.executeStatement(JDBCStatementImpl.java:133)\r\n\tat org.jkiss.dbeaver.ui.editors.sql.execute.SQLQueryJob.executeStatement(SQLQueryJob.java:583)\r\n\tat org.jkiss.dbeaver.ui.editors.sql.execute.SQLQueryJob.lambda$1(SQLQueryJob.java:492)\r\n\tat org.jkiss.dbeaver.model.exec.DBExecUtils.tryExecuteRecover(DBExecUtils.java:190)\r\n\tat org.jkiss.dbeaver.ui.editors.sql.execute.SQLQueryJob.executeSingleQuery(SQLQueryJob.java:499)\r\n\tat org.jkiss.dbeaver.ui.editors.sql.execute.SQLQueryJob.extractData(SQLQueryJob.java:947)\r\n\tat org.jkiss.dbeaver.ui.editors.sql.SQLEditor$QueryResultsContainer.readData(SQLEditor.java:4100)\r\n\tat org.jkiss.dbeaver.ui.controls.resultset.ResultSetJobDataRead.lambda$0(ResultSetJobDataRead.java:123)\r\n\tat org.jkiss.dbeaver.model.exec.DBExecUtils.tryExecuteRecover(DBExecUtils.java:190)\r\n\tat org.jkiss.dbeaver.ui.controls.resultset.ResultSetJobDataRead.run(ResultSetJobDataRead.java:121)\r\n\tat org.jkiss.dbeaver.ui.controls.resultset.ResultSetViewer$ResultSetDataPumpJob.run(ResultSetViewer.java:5164)\r\n\tat org.jkiss.dbeaver.model.runtime.AbstractJob.run(AbstractJob.java:105)\r\n\tat org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)\r\nCaused by: java.sql.SQLException: java.sql.SQLException: INTERNAL Error: Attempted to access index 1 within vector of size 1\r\n\tat org.duckdb.DuckDBPreparedStatement.prepare(DuckDBPreparedStatement.java:112)\r\n\tat org.duckdb.DuckDBPreparedStatement.execute(DuckDBPreparedStatement.java:183)\r\n\tat org.jkiss.dbeaver.model.impl.jdbc.exec.JDBCStatementImpl.execute(JDBCStatementImpl.java:330)\r\n\tat org.jkiss.dbeaver.model.impl.jdbc.exec.JDBCStatementImpl.executeStatement(JDBCStatementImpl.java:131)\r\n\t... 12 more\r\nCaused by: java.sql.SQLException: INTERNAL Error: Attempted to access index 1 within vector of size 1\r\n\tat org.duckdb.DuckDBNative.duckdb_jdbc_prepare(Native Method)\r\n\tat org.duckdb.DuckDBPreparedStatement.prepare(DuckDBPreparedStatement.java:106)\r\n\t... 15 more\r\n```\n\n### To Reproduce\n\n1. Download the following duckdb database file: https://github.com/jbaranski/duck-db-bug-report/blob/main/data.db\r\n2. Connect to the database in DBeaver (I used `Version 23.2.3.202310221533`) on MacOS `Ventura 13.4.1` with an `M1` chip.\r\n3. Run the query successfully:\r\n```\r\nSELECT UNNEST(player_statistics) FROM \r\n\t(SELECT player.id AS player_id,\r\n         UNNEST (player_stats.statistics).team.id AS team_id,\r\n         UNNEST (player_stats.statistics).games.appearences * UNNEST (player_stats.statistics).games.minutes AS totals\r\n\t FROM player_stats) AS player_statistics\r\nWHERE team_id = 48\r\nAND totals > 0\r\n```\r\n4. Run the same query with an `ORDER BY` clause, it breaks:\r\n```\r\nSELECT UNNEST(player_statistics) FROM \r\n\t(SELECT player.id AS player_id,\r\n         UNNEST (player_stats.statistics).team.id AS team_id,\r\n         UNNEST (player_stats.statistics).games.appearences * UNNEST (player_stats.statistics).games.minutes AS totals\r\n\t FROM player_stats) AS player_statistics\r\nWHERE team_id = 48\r\nAND totals > 0\r\nORDER BY totals\r\n```\r\n\n\n### OS:\n\nMacOS - Ventura 13.4.1\n\n### DuckDB Version:\n\n0.9.1\n\n### DuckDB Client:\n\nJava/DBeaver\n\n### Full Name:\n\nJeff Baranski\n\n### Affiliation:\n\nHobby Project / No Affiliation\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2023-10-26T13:11:56Z"
}