{
  "repo": "duckdb/duckdb",
  "pull_number": 16832,
  "instance_id": "duckdb__duckdb-16832",
  "issue_numbers": [
    "16783",
    "16783"
  ],
  "base_commit": "d34a98dc0d2bb23e97994d28c69c83419691191e",
  "patch": "diff --git a/extension/jemalloc/jemalloc/include/jemalloc/jemalloc.h b/extension/jemalloc/jemalloc/include/jemalloc/jemalloc.h\nindex 8d4c1b13f259..3e6c661733ac 100644\n--- a/extension/jemalloc/jemalloc/include/jemalloc/jemalloc.h\n+++ b/extension/jemalloc/jemalloc/include/jemalloc/jemalloc.h\n@@ -5,8 +5,8 @@\n extern \"C\" {\n #endif\n \n-// DuckDB uses a 5s decay\n-#define DUCKDB_JEMALLOC_DECAY 5\n+// DuckDB uses a 1s decay\n+#define DUCKDB_JEMALLOC_DECAY 1\n \n /* Defined if __attribute__((...)) syntax is supported. */\n #define JEMALLOC_HAVE_ATTR\ndiff --git a/src/common/adbc/adbc.cpp b/src/common/adbc/adbc.cpp\nindex 71617e1e9376..e9dd12f7623a 100644\n--- a/src/common/adbc/adbc.cpp\n+++ b/src/common/adbc/adbc.cpp\n@@ -17,7 +17,7 @@\n #include \"duckdb/common/adbc/options.h\"\n #include \"duckdb/common/adbc/single_batch_array_stream.hpp\"\n #include \"duckdb/function/table/arrow.hpp\"\n-\n+#include \"duckdb/common/adbc/wrappers.hpp\"\n #include <stdlib.h>\n #include <string.h>\n \n@@ -249,7 +249,9 @@ AdbcStatusCode ConnectionNew(struct AdbcConnection *connection, struct AdbcError\n \t\treturn ADBC_STATUS_INVALID_ARGUMENT;\n \t}\n \n-\tconnection->private_data = nullptr;\n+\tauto connection_wrapper = new duckdb::DuckDBAdbcConnectionWrapper();\n+\tconnection_wrapper->connection = nullptr;\n+\tconnection->private_data = connection_wrapper;\n \treturn ADBC_STATUS_OK;\n }\n \n@@ -263,45 +265,65 @@ AdbcStatusCode ExecuteQuery(duckdb::Connection *conn, const char *query, struct\n \treturn ADBC_STATUS_OK;\n }\n \n+AdbcStatusCode InternalSetOption(duckdb::Connection &conn, std::unordered_map<std::string, std::string> &options,\n+                                 struct AdbcError *error) {\n+\t// If we got here, the options have already been validated and are acceptable\n+\tfor (auto &option : options) {\n+\t\tif (strcmp(option.first.c_str(), ADBC_CONNECTION_OPTION_AUTOCOMMIT) == 0) {\n+\t\t\tif (strcmp(option.second.c_str(), ADBC_OPTION_VALUE_ENABLED) == 0) {\n+\t\t\t\tif (conn.HasActiveTransaction()) {\n+\t\t\t\t\tAdbcStatusCode status = ExecuteQuery(&conn, \"COMMIT\", error);\n+\t\t\t\t\tif (status != ADBC_STATUS_OK) {\n+\t\t\t\t\t\toptions.clear();\n+\t\t\t\t\t\treturn status;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (strcmp(option.second.c_str(), ADBC_OPTION_VALUE_DISABLED) == 0) {\n+\t\t\t\tif (!conn.HasActiveTransaction()) {\n+\t\t\t\t\tAdbcStatusCode status = ExecuteQuery(&conn, \"START TRANSACTION\", error);\n+\t\t\t\t\tif (status != ADBC_STATUS_OK) {\n+\t\t\t\t\t\toptions.clear();\n+\t\t\t\t\t\treturn status;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\toptions.clear();\n+\treturn ADBC_STATUS_OK;\n+}\n AdbcStatusCode ConnectionSetOption(struct AdbcConnection *connection, const char *key, const char *value,\n                                    struct AdbcError *error) {\n \tif (!connection) {\n \t\tSetError(error, \"Connection is not set\");\n \t\treturn ADBC_STATUS_INVALID_ARGUMENT;\n \t}\n-\n-\tauto conn = static_cast<duckdb::Connection *>(connection->private_data);\n+\tstd::string key_string = std::string(key);\n+\tstd::string key_value = std::string(value);\n+\tauto conn_wrapper = static_cast<duckdb::DuckDBAdbcConnectionWrapper *>(connection->private_data);\n \tif (strcmp(key, ADBC_CONNECTION_OPTION_AUTOCOMMIT) == 0) {\n \t\tif (strcmp(value, ADBC_OPTION_VALUE_ENABLED) == 0) {\n-\t\t\tif (conn->HasActiveTransaction()) {\n-\t\t\t\tAdbcStatusCode status = ExecuteQuery(conn, \"COMMIT\", error);\n-\t\t\t\tif (status != ADBC_STATUS_OK) {\n-\t\t\t\t\treturn status;\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// no-op\n-\t\t\t}\n+\t\t\tconn_wrapper->options[key_string] = key_value;\n \t\t} else if (strcmp(value, ADBC_OPTION_VALUE_DISABLED) == 0) {\n-\t\t\tif (conn->HasActiveTransaction()) {\n-\t\t\t\t// no-op\n-\t\t\t} else {\n-\t\t\t\t// begin\n-\t\t\t\tAdbcStatusCode status = ExecuteQuery(conn, \"START TRANSACTION\", error);\n-\t\t\t\tif (status != ADBC_STATUS_OK) {\n-\t\t\t\t\treturn status;\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tconn_wrapper->options[key_string] = key_value;\n \t\t} else {\n \t\t\tauto error_message = \"Invalid connection option value \" + std::string(key) + \"=\" + std::string(value);\n \t\t\tSetError(error, error_message);\n \t\t\treturn ADBC_STATUS_INVALID_ARGUMENT;\n \t\t}\n+\t} else {\n+\t\t// This is an unknown option to the DuckDB driver\n+\t\tauto error_message =\n+\t\t    \"Unknown connection option \" + std::string(key) + \"=\" + (value ? std::string(value) : \"(NULL)\");\n+\t\tSetError(error, error_message);\n+\t\treturn ADBC_STATUS_NOT_IMPLEMENTED;\n+\t}\n+\tif (!conn_wrapper->connection) {\n+\t\t// If the connection has not yet been initialized, we just return here.\n \t\treturn ADBC_STATUS_OK;\n \t}\n-\tauto error_message =\n-\t    \"Unknown connection option \" + std::string(key) + \"=\" + (value ? std::string(value) : \"(NULL)\");\n-\tSetError(error, error_message);\n-\treturn ADBC_STATUS_NOT_IMPLEMENTED;\n+\tauto conn = reinterpret_cast<duckdb::Connection *>(conn_wrapper->connection);\n+\treturn InternalSetOption(*conn, conn_wrapper->options, error);\n }\n \n AdbcStatusCode ConnectionReadPartition(struct AdbcConnection *connection, const uint8_t *serialized_partition,\n@@ -323,7 +345,8 @@ AdbcStatusCode ConnectionCommit(struct AdbcConnection *connection, struct AdbcEr\n \t\tSetError(error, \"Connection is not set\");\n \t\treturn ADBC_STATUS_INVALID_ARGUMENT;\n \t}\n-\tauto conn = static_cast<duckdb::Connection *>(connection->private_data);\n+\tauto conn_wrapper = static_cast<duckdb::DuckDBAdbcConnectionWrapper *>(connection->private_data);\n+\tauto conn = reinterpret_cast<duckdb::Connection *>(conn_wrapper->connection);\n \tif (!conn->HasActiveTransaction()) {\n \t\tSetError(error, \"No active transaction, cannot commit\");\n \t\treturn ADBC_STATUS_INVALID_STATE;\n@@ -341,7 +364,8 @@ AdbcStatusCode ConnectionRollback(struct AdbcConnection *connection, struct Adbc\n \t\tSetError(error, \"Connection is not set\");\n \t\treturn ADBC_STATUS_INVALID_ARGUMENT;\n \t}\n-\tauto conn = static_cast<duckdb::Connection *>(connection->private_data);\n+\tauto conn_wrapper = static_cast<duckdb::DuckDBAdbcConnectionWrapper *>(connection->private_data);\n+\tauto conn = reinterpret_cast<duckdb::Connection *>(conn_wrapper->connection);\n \tif (!conn->HasActiveTransaction()) {\n \t\tSetError(error, \"No active transaction, cannot rollback\");\n \t\treturn ADBC_STATUS_INVALID_STATE;\n@@ -479,16 +503,25 @@ AdbcStatusCode ConnectionInit(struct AdbcConnection *connection, struct AdbcData\n \t\treturn ADBC_STATUS_INVALID_ARGUMENT;\n \t}\n \tauto database_wrapper = static_cast<DuckDBAdbcDatabaseWrapper *>(database->private_data);\n+\tauto conn_wrapper = static_cast<duckdb::DuckDBAdbcConnectionWrapper *>(connection->private_data);\n+\tconn_wrapper->connection = nullptr;\n \n-\tconnection->private_data = nullptr;\n-\tauto res =\n-\t    duckdb_connect(database_wrapper->database, reinterpret_cast<duckdb_connection *>(&connection->private_data));\n-\treturn CheckResult(res, error, \"Failed to connect to Database\");\n+\tauto res = duckdb_connect(database_wrapper->database, &conn_wrapper->connection);\n+\tauto adbc_status = CheckResult(res, error, \"Failed to connect to Database\");\n+\tif (adbc_status != ADBC_STATUS_OK) {\n+\t\treturn adbc_status;\n+\t}\n+\t// We might have options to set\n+\tauto conn = reinterpret_cast<duckdb::Connection *>(conn_wrapper->connection);\n+\treturn InternalSetOption(*conn, conn_wrapper->options, error);\n }\n \n AdbcStatusCode ConnectionRelease(struct AdbcConnection *connection, struct AdbcError *error) {\n \tif (connection && connection->private_data) {\n-\t\tduckdb_disconnect(reinterpret_cast<duckdb_connection *>(&connection->private_data));\n+\t\tauto conn_wrapper = static_cast<duckdb::DuckDBAdbcConnectionWrapper *>(connection->private_data);\n+\t\tauto conn = reinterpret_cast<duckdb::Connection *>(conn_wrapper->connection);\n+\t\tduckdb_disconnect(reinterpret_cast<duckdb_connection *>(&conn));\n+\t\tdelete conn_wrapper;\n \t\tconnection->private_data = nullptr;\n \t}\n \treturn ADBC_STATUS_OK;\n@@ -638,7 +671,9 @@ AdbcStatusCode StatementNew(struct AdbcConnection *connection, struct AdbcStatem\n \t}\n \n \tstatement->private_data = statement_wrapper;\n-\tstatement_wrapper->connection = static_cast<duckdb_connection>(connection->private_data);\n+\tauto conn_wrapper = static_cast<duckdb::DuckDBAdbcConnectionWrapper *>(connection->private_data);\n+\n+\tstatement_wrapper->connection = conn_wrapper->connection;\n \tstatement_wrapper->statement = nullptr;\n \tstatement_wrapper->result = nullptr;\n \tstatement_wrapper->ingestion_stream.release = nullptr;\ndiff --git a/src/common/adbc/driver_manager.cpp b/src/common/adbc/driver_manager.cpp\nindex 1d2bc1f233c3..9ac932380aee 100644\n--- a/src/common/adbc/driver_manager.cpp\n+++ b/src/common/adbc/driver_manager.cpp\n@@ -1080,6 +1080,7 @@ AdbcStatusCode AdbcConnectionGetTableTypes(struct AdbcConnection *connection, st\n \n AdbcStatusCode AdbcConnectionInit(struct AdbcConnection *connection, struct AdbcDatabase *database,\n                                   struct AdbcError *error) {\n+\n \tif (!connection->private_data) {\n \t\tSetError(error, \"Must call AdbcConnectionNew first\");\n \t\treturn ADBC_STATUS_INVALID_STATE;\n@@ -1087,6 +1088,7 @@ AdbcStatusCode AdbcConnectionInit(struct AdbcConnection *connection, struct Adbc\n \t\tSetError(error, \"Database is not initialized\");\n \t\treturn ADBC_STATUS_INVALID_ARGUMENT;\n \t}\n+\n \tTempConnection *args = reinterpret_cast<TempConnection *>(connection->private_data);\n \tconnection->private_data = nullptr;\n \tstd::unordered_map<std::string, std::string> options = std::move(args->options);\n@@ -1176,7 +1178,7 @@ AdbcStatusCode AdbcConnectionRollback(struct AdbcConnection *connection, struct\n \n AdbcStatusCode AdbcConnectionSetOption(struct AdbcConnection *connection, const char *key, const char *value,\n                                        struct AdbcError *error) {\n-\tif (!connection->private_data) {\n+\tif (!connection || !connection->private_data) {\n \t\tSetError(error, \"AdbcConnectionSetOption: must AdbcConnectionNew first\");\n \t\treturn ADBC_STATUS_INVALID_STATE;\n \t}\ndiff --git a/src/common/arrow/appender/CMakeLists.txt b/src/common/arrow/appender/CMakeLists.txt\nindex a342652e23a3..090e7bb15925 100644\n--- a/src/common/arrow/appender/CMakeLists.txt\n+++ b/src/common/arrow/appender/CMakeLists.txt\n@@ -1,5 +1,11 @@\n-add_library_unity(duckdb_common_arrow_appender OBJECT bool_data.cpp\n-                  struct_data.cpp union_data.cpp fixed_size_list_data.cpp)\n+add_library_unity(\n+  duckdb_common_arrow_appender\n+  OBJECT\n+  bool_data.cpp\n+  fixed_size_list_data.cpp\n+  null_data.cpp\n+  struct_data.cpp\n+  union_data.cpp)\n set(ALL_OBJECT_FILES\n     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_common_arrow_appender>\n     PARENT_SCOPE)\ndiff --git a/src/common/arrow/appender/null_data.cpp b/src/common/arrow/appender/null_data.cpp\nnew file mode 100644\nindex 000000000000..5f8806ed6761\n--- /dev/null\n+++ b/src/common/arrow/appender/null_data.cpp\n@@ -0,0 +1,19 @@\n+#include \"duckdb/common/arrow/arrow_appender.hpp\"\n+#include \"duckdb/common/arrow/appender/null_data.hpp\"\n+\n+namespace duckdb {\n+\n+void ArrowNullData::Initialize(ArrowAppendData &result, const LogicalType &type, idx_t capacity) {\n+\t// nop\n+}\n+\n+void ArrowNullData::Append(ArrowAppendData &append_data, Vector &input, idx_t from, idx_t to, idx_t input_size) {\n+\tidx_t size = to - from;\n+\tappend_data.row_count += size;\n+}\n+\n+void ArrowNullData::Finalize(ArrowAppendData &append_data, const LogicalType &type, ArrowArray *result) {\n+\tresult->n_buffers = 0;\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/common/arrow/arrow_appender.cpp b/src/common/arrow/arrow_appender.cpp\nindex 83f190b5700d..ee49bdd85c4e 100644\n--- a/src/common/arrow/arrow_appender.cpp\n+++ b/src/common/arrow/arrow_appender.cpp\n@@ -144,6 +144,9 @@ static void InitializeAppenderForType(ArrowAppendData &append_data) {\n static void InitializeFunctionPointers(ArrowAppendData &append_data, const LogicalType &type) {\n \t// handle special logical types\n \tswitch (type.id()) {\n+\tcase LogicalTypeId::SQLNULL:\n+\t\tInitializeAppenderForType<ArrowNullData>(append_data);\n+\t\tbreak;\n \tcase LogicalTypeId::BOOLEAN:\n \t\tInitializeAppenderForType<ArrowBoolData>(append_data);\n \t\tbreak;\ndiff --git a/src/common/arrow/arrow_converter.cpp b/src/common/arrow/arrow_converter.cpp\nindex 02b3999a06d0..5369b3d423d9 100644\n--- a/src/common/arrow/arrow_converter.cpp\n+++ b/src/common/arrow/arrow_converter.cpp\n@@ -61,6 +61,30 @@ void InitializeChild(ArrowSchema &child, DuckDBArrowSchemaHolder &root_holder, c\n void SetArrowFormat(DuckDBArrowSchemaHolder &root_holder, ArrowSchema &child, const LogicalType &type,\n                     ClientProperties &options, ClientContext &context);\n \n+void SetArrowStructFormat(DuckDBArrowSchemaHolder &root_holder, ArrowSchema &child, const LogicalType &type,\n+                          ClientProperties &options, ClientContext &context, bool map_is_parent = false) {\n+\tchild.format = \"+s\";\n+\tauto &child_types = StructType::GetChildTypes(type);\n+\tchild.n_children = NumericCast<int64_t>(child_types.size());\n+\troot_holder.nested_children.emplace_back();\n+\troot_holder.nested_children.back().resize(child_types.size());\n+\troot_holder.nested_children_ptr.emplace_back();\n+\troot_holder.nested_children_ptr.back().resize(child_types.size());\n+\tfor (idx_t type_idx = 0; type_idx < child_types.size(); type_idx++) {\n+\t\troot_holder.nested_children_ptr.back()[type_idx] = &root_holder.nested_children.back()[type_idx];\n+\t}\n+\tchild.children = &root_holder.nested_children_ptr.back()[0];\n+\tfor (size_t type_idx = 0; type_idx < child_types.size(); type_idx++) {\n+\t\tInitializeChild(*child.children[type_idx], root_holder);\n+\t\troot_holder.owned_type_names.push_back(AddName(child_types[type_idx].first));\n+\t\tchild.children[type_idx]->name = root_holder.owned_type_names.back().get();\n+\t\tSetArrowFormat(root_holder, *child.children[type_idx], child_types[type_idx].second, options, context);\n+\t}\n+\tif (map_is_parent) {\n+\t\tchild.children[0]->flags = 0; // Set the 'keys' field to non-nullable\n+\t}\n+}\n+\n void SetArrowMapFormat(DuckDBArrowSchemaHolder &root_holder, ArrowSchema &child, const LogicalType &type,\n                        ClientProperties &options, ClientContext &context) {\n \tchild.format = \"+m\";\n@@ -74,7 +98,7 @@ void SetArrowMapFormat(DuckDBArrowSchemaHolder &root_holder, ArrowSchema &child,\n \tchild.children = &root_holder.nested_children_ptr.back()[0];\n \tchild.children[0]->name = \"entries\";\n \tchild.children[0]->flags = 0; // Set the 'entries' field to non-nullable\n-\tSetArrowFormat(root_holder, **child.children, ListType::GetChildType(type), options, context);\n+\tSetArrowStructFormat(root_holder, **child.children, ListType::GetChildType(type), options, context, true);\n }\n \n bool SetArrowExtension(DuckDBArrowSchemaHolder &root_holder, ArrowSchema &child, const LogicalType &type,\n@@ -265,26 +289,7 @@ void SetArrowFormat(DuckDBArrowSchemaHolder &root_holder, ArrowSchema &child, co\n \t\tbreak;\n \t}\n \tcase LogicalTypeId::STRUCT: {\n-\t\tchild.format = \"+s\";\n-\t\tauto &child_types = StructType::GetChildTypes(type);\n-\t\tchild.n_children = NumericCast<int64_t>(child_types.size());\n-\t\troot_holder.nested_children.emplace_back();\n-\t\troot_holder.nested_children.back().resize(child_types.size());\n-\t\troot_holder.nested_children_ptr.emplace_back();\n-\t\troot_holder.nested_children_ptr.back().resize(child_types.size());\n-\t\tfor (idx_t type_idx = 0; type_idx < child_types.size(); type_idx++) {\n-\t\t\troot_holder.nested_children_ptr.back()[type_idx] = &root_holder.nested_children.back()[type_idx];\n-\t\t}\n-\t\tchild.children = &root_holder.nested_children_ptr.back()[0];\n-\t\tfor (size_t type_idx = 0; type_idx < child_types.size(); type_idx++) {\n-\n-\t\t\tInitializeChild(*child.children[type_idx], root_holder);\n-\n-\t\t\troot_holder.owned_type_names.push_back(AddName(child_types[type_idx].first));\n-\n-\t\t\tchild.children[type_idx]->name = root_holder.owned_type_names.back().get();\n-\t\t\tSetArrowFormat(root_holder, *child.children[type_idx], child_types[type_idx].second, options, context);\n-\t\t}\n+\t\tSetArrowStructFormat(root_holder, child, type, options, context);\n \t\tbreak;\n \t}\n \tcase LogicalTypeId::ARRAY: {\ndiff --git a/src/execution/operator/csv_scanner/sniffer/header_detection.cpp b/src/execution/operator/csv_scanner/sniffer/header_detection.cpp\nindex 2459deff7fbc..4d77bf3f99a3 100644\n--- a/src/execution/operator/csv_scanner/sniffer/header_detection.cpp\n+++ b/src/execution/operator/csv_scanner/sniffer/header_detection.cpp\n@@ -45,6 +45,11 @@ static string TrimWhitespace(const string &col_name) {\n \treturn col_name.substr(begin, end - begin);\n }\n \n+bool NormalizeThis(const KeywordCategory category, const string &col_name) {\n+\treturn category == KeywordCategory::KEYWORD_UNRESERVED || category == KeywordCategory::KEYWORD_TYPE_FUNC ||\n+\t       category == KeywordCategory::KEYWORD_RESERVED;\n+}\n+\n static string NormalizeColumnName(const string &col_name) {\n \t// normalize UTF8 characters to NFKD\n \tauto nfkd = utf8proc_NFKD(reinterpret_cast<const utf8proc_uint8_t *>(col_name.c_str()),\n@@ -89,8 +94,8 @@ static string NormalizeColumnName(const string &col_name) {\n \n \t// prepend _ if name starts with a digit or is a reserved keyword\n \tauto keyword = KeywordHelper::KeywordCategoryType(col_name_cleaned);\n-\tif (keyword == KeywordCategory::KEYWORD_TYPE_FUNC || keyword == KeywordCategory::KEYWORD_RESERVED ||\n-\t    (col_name_cleaned[0] >= '0' && col_name_cleaned[0] <= '9')) {\n+\n+\tif (NormalizeThis(keyword, col_name_cleaned) || (col_name_cleaned[0] >= '0' && col_name_cleaned[0] <= '9')) {\n \t\tcol_name_cleaned = \"_\" + col_name_cleaned;\n \t}\n \treturn col_name_cleaned;\ndiff --git a/src/execution/operator/order/physical_top_n.cpp b/src/execution/operator/order/physical_top_n.cpp\nindex 669c25a5ed80..cba653a8e5c9 100644\n--- a/src/execution/operator/order/physical_top_n.cpp\n+++ b/src/execution/operator/order/physical_top_n.cpp\n@@ -163,8 +163,8 @@ TopNHeap::TopNHeap(ClientContext &context, Allocator &allocator, const vector<Lo\n                    const vector<BoundOrderByNode> &orders_p, idx_t limit, idx_t offset)\n     : allocator(allocator), buffer_manager(BufferManager::GetBufferManager(context)), payload_types(payload_types_p),\n       orders(orders_p), limit(limit), offset(offset), heap_size(limit + offset), executor(context),\n-      matching_sel(STANDARD_VECTOR_SIZE), final_sel(STANDARD_VECTOR_SIZE), true_sel(STANDARD_VECTOR_SIZE),\n-      false_sel(STANDARD_VECTOR_SIZE), new_remaining_sel(STANDARD_VECTOR_SIZE) {\n+      sort_key_heap(allocator), matching_sel(STANDARD_VECTOR_SIZE), final_sel(STANDARD_VECTOR_SIZE),\n+      true_sel(STANDARD_VECTOR_SIZE), false_sel(STANDARD_VECTOR_SIZE), new_remaining_sel(STANDARD_VECTOR_SIZE) {\n \t// initialize the executor and the sort_chunk\n \tvector<LogicalType> sort_types;\n \tfor (auto &order : orders) {\n@@ -190,7 +190,7 @@ TopNHeap::TopNHeap(ClientContext &context, const vector<LogicalType> &payload_ty\n \n TopNHeap::TopNHeap(ExecutionContext &context, const vector<LogicalType> &payload_types,\n                    const vector<BoundOrderByNode> &orders, idx_t limit, idx_t offset)\n-    : TopNHeap(context.client, Allocator::Get(context.client), payload_types, orders, limit, offset) {\n+    : TopNHeap(context.client, BufferAllocator::Get(context.client), payload_types, orders, limit, offset) {\n }\n \n void TopNHeap::AddSmallHeap(DataChunk &input, Vector &sort_keys_vec) {\ndiff --git a/src/function/aggregate/sorted_aggregate_function.cpp b/src/function/aggregate/sorted_aggregate_function.cpp\nindex 5e3747cb462f..b6dbb7ece8c7 100644\n--- a/src/function/aggregate/sorted_aggregate_function.cpp\n+++ b/src/function/aggregate/sorted_aggregate_function.cpp\n@@ -133,18 +133,20 @@ struct SortedAggregateState {\n \t\t}\n \t}\n \n-\tstatic inline void InitializeChunk(unique_ptr<DataChunk> &chunk, const vector<LogicalType> &types) {\n+\tstatic inline void InitializeChunk(Allocator &allocator, unique_ptr<DataChunk> &chunk,\n+\t                                   const vector<LogicalType> &types) {\n \t\tif (!chunk && !types.empty()) {\n \t\t\tchunk = make_uniq<DataChunk>();\n-\t\t\tchunk->Initialize(Allocator::DefaultAllocator(), types);\n+\t\t\tchunk->Initialize(allocator, types);\n \t\t}\n \t}\n \n \tvoid InitializeChunks(const SortedAggregateBindData &order_bind) {\n \t\t// Lazy instantiation of the buffer chunks\n-\t\tInitializeChunk(sort_chunk, order_bind.sort_types);\n+\t\tauto &allocator = BufferManager::GetBufferManager(order_bind.context).GetBufferAllocator();\n+\t\tInitializeChunk(allocator, sort_chunk, order_bind.sort_types);\n \t\tif (!order_bind.sorted_on_args) {\n-\t\t\tInitializeChunk(arg_chunk, order_bind.arg_types);\n+\t\t\tInitializeChunk(allocator, arg_chunk, order_bind.arg_types);\n \t\t}\n \t}\n \n@@ -565,10 +567,12 @@ struct SortedAggregateFunction {\n \t\tauto &context = order_bind.context;\n \t\tRowLayout payload_layout;\n \t\tpayload_layout.Initialize(order_bind.arg_types);\n+\n+\t\tauto &buffer_allocator = BufferManager::GetBufferManager(order_bind.context).GetBufferAllocator();\n \t\tDataChunk chunk;\n-\t\tchunk.Initialize(Allocator::DefaultAllocator(), order_bind.arg_types);\n+\t\tchunk.Initialize(buffer_allocator, order_bind.arg_types);\n \t\tDataChunk sliced;\n-\t\tsliced.Initialize(Allocator::DefaultAllocator(), order_bind.arg_types);\n+\t\tsliced.Initialize(buffer_allocator, order_bind.arg_types);\n \n \t\t//\t Reusable inner state\n \t\tauto &aggr = order_bind.function;\n@@ -607,7 +611,7 @@ struct SortedAggregateFunction {\n \t\tlocal_sort->Initialize(*global_sort, global_sort->buffer_manager);\n \n \t\tDataChunk prefixed;\n-\t\tprefixed.Initialize(Allocator::DefaultAllocator(), global_sort->sort_layout.logical_types);\n+\t\tprefixed.Initialize(buffer_allocator, global_sort->sort_layout.logical_types);\n \n \t\t//\tGo through the states accumulating values to sort until we hit the sort threshold\n \t\tidx_t unsorted_count = 0;\ndiff --git a/src/function/table/system/duckdb_memory.cpp b/src/function/table/system/duckdb_memory.cpp\nindex a1eb044b7589..c5b2084c5103 100644\n--- a/src/function/table/system/duckdb_memory.cpp\n+++ b/src/function/table/system/duckdb_memory.cpp\n@@ -31,6 +31,13 @@ unique_ptr<GlobalTableFunctionState> DuckDBMemoryInit(ClientContext &context, Ta\n \treturn std::move(result);\n }\n \n+int64_t ClampReportedMemory(idx_t memory_usage) {\n+\tif (memory_usage > static_cast<idx_t>(NumericLimits<int64_t>::Maximum())) {\n+\t\treturn 0;\n+\t}\n+\treturn UnsafeNumericCast<int64_t>(memory_usage);\n+}\n+\n void DuckDBMemoryFunction(ClientContext &context, TableFunctionInput &data_p, DataChunk &output) {\n \tauto &data = data_p.global_state->Cast<DuckDBMemoryData>();\n \tif (data.offset >= data.entries.size()) {\n@@ -47,9 +54,9 @@ void DuckDBMemoryFunction(ClientContext &context, TableFunctionInput &data_p, Da\n \t\t// tag, VARCHAR\n \t\toutput.SetValue(col++, count, EnumUtil::ToString(entry.tag));\n \t\t// memory_usage_bytes, BIGINT\n-\t\toutput.SetValue(col++, count, Value::BIGINT(NumericCast<int64_t>(entry.size)));\n+\t\toutput.SetValue(col++, count, Value::BIGINT(ClampReportedMemory(entry.size)));\n \t\t// temporary_storage_bytes, BIGINT\n-\t\toutput.SetValue(col++, count, Value::BIGINT(NumericCast<int64_t>(entry.evicted_data)));\n+\t\toutput.SetValue(col++, count, Value::BIGINT(ClampReportedMemory(entry.evicted_data)));\n \t\tcount++;\n \t}\n \toutput.SetCardinality(count);\ndiff --git a/src/include/duckdb/common/adbc/wrappers.hpp b/src/include/duckdb/common/adbc/wrappers.hpp\nnew file mode 100644\nindex 000000000000..01d59dc901b5\n--- /dev/null\n+++ b/src/include/duckdb/common/adbc/wrappers.hpp\n@@ -0,0 +1,21 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/adbc/wrappers.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb.h\"\n+#include \"duckdb/common/string.hpp\"\n+#include \"duckdb/common/unordered_map.hpp\"\n+\n+namespace duckdb {\n+\n+struct DuckDBAdbcConnectionWrapper {\n+\tduckdb_connection connection;\n+\tunordered_map<string, string> options;\n+};\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/common/arrow/appender/append_data.hpp b/src/include/duckdb/common/arrow/appender/append_data.hpp\nindex 1b5a5e02ab9e..c136100ae23b 100644\n--- a/src/include/duckdb/common/arrow/appender/append_data.hpp\n+++ b/src/include/duckdb/common/arrow/appender/append_data.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/append_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include \"duckdb/common/types.hpp\"\ndiff --git a/src/include/duckdb/common/arrow/appender/bool_data.hpp b/src/include/duckdb/common/arrow/appender/bool_data.hpp\nindex 59313faa3696..3b8a4f142cbd 100644\n--- a/src/include/duckdb/common/arrow/appender/bool_data.hpp\n+++ b/src/include/duckdb/common/arrow/appender/bool_data.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/bool_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include \"duckdb/common/arrow/appender/append_data.hpp\"\ndiff --git a/src/include/duckdb/common/arrow/appender/enum_data.hpp b/src/include/duckdb/common/arrow/appender/enum_data.hpp\nindex 90473d9b540f..a5d066abbd44 100644\n--- a/src/include/duckdb/common/arrow/appender/enum_data.hpp\n+++ b/src/include/duckdb/common/arrow/appender/enum_data.hpp\n@@ -1,7 +1,16 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/enum_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include \"duckdb/common/arrow/appender/append_data.hpp\"\n #include \"duckdb/common/arrow/appender/scalar_data.hpp\"\n+#include \"duckdb/common/arrow/arrow_appender.hpp\"\n \n namespace duckdb {\n \ndiff --git a/src/include/duckdb/common/arrow/appender/fixed_size_list_data.hpp b/src/include/duckdb/common/arrow/appender/fixed_size_list_data.hpp\nindex 4ad609441393..775fb2e17b05 100644\n--- a/src/include/duckdb/common/arrow/appender/fixed_size_list_data.hpp\n+++ b/src/include/duckdb/common/arrow/appender/fixed_size_list_data.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/fixed_size_list_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===/\n+\n #pragma once\n \n #include \"duckdb/common/arrow/appender/append_data.hpp\"\ndiff --git a/src/include/duckdb/common/arrow/appender/list.hpp b/src/include/duckdb/common/arrow/appender/list.hpp\nindex 6ce97b5285f9..1fd664ff2150 100644\n--- a/src/include/duckdb/common/arrow/appender/list.hpp\n+++ b/src/include/duckdb/common/arrow/appender/list.hpp\n@@ -1,9 +1,18 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/list.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #include \"duckdb/common/arrow/appender/bool_data.hpp\"\n #include \"duckdb/common/arrow/appender/enum_data.hpp\"\n #include \"duckdb/common/arrow/appender/fixed_size_list_data.hpp\"\n #include \"duckdb/common/arrow/appender/list_data.hpp\"\n #include \"duckdb/common/arrow/appender/list_view_data.hpp\"\n #include \"duckdb/common/arrow/appender/map_data.hpp\"\n+#include \"duckdb/common/arrow/appender/null_data.hpp\"\n #include \"duckdb/common/arrow/appender/scalar_data.hpp\"\n #include \"duckdb/common/arrow/appender/struct_data.hpp\"\n #include \"duckdb/common/arrow/appender/union_data.hpp\"\ndiff --git a/src/include/duckdb/common/arrow/appender/list_data.hpp b/src/include/duckdb/common/arrow/appender/list_data.hpp\nindex 5f0f8621539f..21274da486ec 100644\n--- a/src/include/duckdb/common/arrow/appender/list_data.hpp\n+++ b/src/include/duckdb/common/arrow/appender/list_data.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/list_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include \"duckdb/common/arrow/appender/append_data.hpp\"\ndiff --git a/src/include/duckdb/common/arrow/appender/list_view_data.hpp b/src/include/duckdb/common/arrow/appender/list_view_data.hpp\nindex 158120c46341..f46b316dd9cb 100644\n--- a/src/include/duckdb/common/arrow/appender/list_view_data.hpp\n+++ b/src/include/duckdb/common/arrow/appender/list_view_data.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/list_view_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include \"duckdb/common/arrow/appender/append_data.hpp\"\ndiff --git a/src/include/duckdb/common/arrow/appender/map_data.hpp b/src/include/duckdb/common/arrow/appender/map_data.hpp\nindex afc67decdc59..7f82f401fc2f 100644\n--- a/src/include/duckdb/common/arrow/appender/map_data.hpp\n+++ b/src/include/duckdb/common/arrow/appender/map_data.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/map_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include \"duckdb/common/arrow/arrow_appender.hpp\"\ndiff --git a/src/include/duckdb/common/arrow/appender/null_data.hpp b/src/include/duckdb/common/arrow/appender/null_data.hpp\nnew file mode 100644\nindex 000000000000..d39b5d8f38dd\n--- /dev/null\n+++ b/src/include/duckdb/common/arrow/appender/null_data.hpp\n@@ -0,0 +1,23 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/null_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/arrow/appender/append_data.hpp\"\n+#include \"duckdb/common/types/vector.hpp\"\n+\n+namespace duckdb {\n+\n+struct ArrowNullData {\n+public:\n+\tstatic void Initialize(ArrowAppendData &result, const LogicalType &type, idx_t capacity);\n+\tstatic void Append(ArrowAppendData &append_data, Vector &input, idx_t from, idx_t to, idx_t input_size);\n+\tstatic void Finalize(ArrowAppendData &append_data, const LogicalType &type, ArrowArray *result);\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/common/arrow/appender/scalar_data.hpp b/src/include/duckdb/common/arrow/appender/scalar_data.hpp\nindex 00326a6a55c0..a6729b46070d 100644\n--- a/src/include/duckdb/common/arrow/appender/scalar_data.hpp\n+++ b/src/include/duckdb/common/arrow/appender/scalar_data.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/scalar_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include \"duckdb/common/arrow/appender/append_data.hpp\"\ndiff --git a/src/include/duckdb/common/arrow/appender/struct_data.hpp b/src/include/duckdb/common/arrow/appender/struct_data.hpp\nindex de2514fc1e18..299a05bab0dd 100644\n--- a/src/include/duckdb/common/arrow/appender/struct_data.hpp\n+++ b/src/include/duckdb/common/arrow/appender/struct_data.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/struct_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include \"duckdb/common/arrow/appender/append_data.hpp\"\ndiff --git a/src/include/duckdb/common/arrow/appender/union_data.hpp b/src/include/duckdb/common/arrow/appender/union_data.hpp\nindex 8b2850fca3a2..df8fc848f6b9 100644\n--- a/src/include/duckdb/common/arrow/appender/union_data.hpp\n+++ b/src/include/duckdb/common/arrow/appender/union_data.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/union_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include \"duckdb/common/arrow/appender/append_data.hpp\"\ndiff --git a/src/include/duckdb/common/arrow/appender/varchar_data.hpp b/src/include/duckdb/common/arrow/appender/varchar_data.hpp\nindex 6dc37652d5d6..45e9c14a985e 100644\n--- a/src/include/duckdb/common/arrow/appender/varchar_data.hpp\n+++ b/src/include/duckdb/common/arrow/appender/varchar_data.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/arrow/appender/varchar_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include \"duckdb/common/arrow/appender/append_data.hpp\"\ndiff --git a/src/include/duckdb/common/numeric_utils.hpp b/src/include/duckdb/common/numeric_utils.hpp\nindex 813213dde179..f61b927ab2ef 100644\n--- a/src/include/duckdb/common/numeric_utils.hpp\n+++ b/src/include/duckdb/common/numeric_utils.hpp\n@@ -76,17 +76,17 @@ struct NumericCastImpl<TO, FROM, false> {\n \n \t\tif (!NumericLimits<FROM>::IsSigned() && !NumericLimits<TO>::IsSigned() &&\n \t\t    (unsigned_in < unsigned_min || unsigned_in > unsigned_max)) {\n-\t\t\tThrowNumericCastError(val, minval, maxval);\n+\t\t\tThrowNumericCastError(val, static_cast<TO>(unsigned_min), static_cast<TO>(unsigned_max));\n \t\t}\n \n \t\tif (NumericLimits<FROM>::IsSigned() && NumericLimits<TO>::IsSigned() &&\n \t\t    (signed_in < signed_min || signed_in > signed_max)) {\n-\t\t\tThrowNumericCastError(val, minval, maxval);\n+\t\t\tThrowNumericCastError(val, static_cast<TO>(signed_min), static_cast<TO>(signed_max));\n \t\t}\n \n \t\tif (NumericLimits<FROM>::IsSigned() != NumericLimits<TO>::IsSigned() &&\n \t\t    (signed_in < signed_min || unsigned_in > unsigned_max)) {\n-\t\t\tThrowNumericCastError(val, minval, maxval);\n+\t\t\tThrowNumericCastError(val, static_cast<TO>(signed_min), static_cast<TO>(unsigned_max));\n \t\t}\n \n \t\treturn static_cast<TO>(val);\ndiff --git a/src/optimizer/rule/distributivity.cpp b/src/optimizer/rule/distributivity.cpp\nindex b1b18617c024..149557eacb23 100644\n--- a/src/optimizer/rule/distributivity.cpp\n+++ b/src/optimizer/rule/distributivity.cpp\n@@ -42,9 +42,10 @@ unique_ptr<Expression> DistributivityRule::ExtractExpression(BoundConjunctionExp\n \t\tif (and_expr.children.size() == 1) {\n \t\t\tconj.children[idx] = std::move(and_expr.children[0]);\n \t\t}\n-\t} else {\n-\t\t// not an AND node! remove the entire expression\n-\t\t// this happens in the case of e.g. (X AND B) OR X\n+\t}\n+\t// not an AND node(e.g. (X AND B) OR X) or this is the last expr,\n+\t// remove the entire expression\n+\tif (!result) {\n \t\tD_ASSERT(child->Equals(expr));\n \t\tresult = std::move(child);\n \t\tconj.children[idx] = nullptr;\ndiff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex 4ba150bcf885..ce6f33a2bcaf 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -105,6 +105,16 @@ vector<CatalogSearchEntry> Binder::GetSearchPath(Catalog &catalog, const string\n \treturn view_search_path;\n }\n \n+static vector<LogicalType> ExchangeAllNullTypes(const vector<LogicalType> &types) {\n+\tvector<LogicalType> result = types;\n+\tfor (auto &type : result) {\n+\t\tif (ExpressionBinder::ContainsNullType(type)) {\n+\t\t\ttype = ExpressionBinder::ExchangeNullType(type);\n+\t\t}\n+\t}\n+\treturn result;\n+}\n+\n unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \tQueryErrorContext error_context(ref.query_location);\n \t// CTEs and views are also referred to using BaseTableRefs, hence need to distinguish here\n@@ -340,9 +350,14 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \t\t// verify that the types and names match up with the expected types and names if the view has type info defined\n \t\tauto &bound_subquery = bound_child->Cast<BoundSubqueryRef>();\n \t\tif (GetBindingMode() != BindingMode::EXTRACT_NAMES && view_catalog_entry.HasTypes()) {\n-\t\t\tif (bound_subquery.subquery->types != view_catalog_entry.types) {\n-\t\t\t\tauto actual_types = StringUtil::ToString(bound_subquery.subquery->types, \", \");\n-\t\t\t\tauto expected_types = StringUtil::ToString(view_catalog_entry.types, \", \");\n+\t\t\t// we bind the view subquery and the original view with different \"can_contain_nulls\",\n+\t\t\t// but we don't want to throw an error when SQLNULL does not match up with INTEGER,\n+\t\t\t// so we exchange all SQLNULL with INTEGER here before comparing\n+\t\t\tauto bound_types = ExchangeAllNullTypes(bound_subquery.subquery->types);\n+\t\t\tauto view_types = ExchangeAllNullTypes(view_catalog_entry.types);\n+\t\t\tif (bound_types != view_types) {\n+\t\t\t\tauto actual_types = StringUtil::ToString(bound_types, \", \");\n+\t\t\t\tauto expected_types = StringUtil::ToString(view_types, \", \");\n \t\t\t\tthrow BinderException(\n \t\t\t\t    \"Contents of view were altered: types don't match! Expected [%s], but found [%s] instead\",\n \t\t\t\t    expected_types, actual_types);\ndiff --git a/tools/shell/shell.cpp b/tools/shell/shell.cpp\nindex 4ebb5fd854bc..9f6c1e0c05e2 100644\n--- a/tools/shell/shell.cpp\n+++ b/tools/shell/shell.cpp\n@@ -4687,7 +4687,7 @@ static const char zOptions[] =\n     \"   -markdown            set output mode to 'markdown'\\n\"\n     \"   -newline SEP         set output row separator. Default: '\\\\n'\\n\"\n     \"   -no-stdin            exit after processing options instead of reading stdin\\n\"\n-    \"   -nullvalue TEXT      set text string for NULL values. Default ''\\n\"\n+    \"   -nullvalue TEXT      set text string for NULL values. Default 'NULL'\\n\"\n     \"   -quote               set output mode to 'quote'\\n\"\n     \"   -readonly            open the database read-only\\n\"\n     \"   -s COMMAND           run \\\"COMMAND\\\" and exit\\n\"\n",
  "test_patch": "diff --git a/data/csv/test_commit_rollback.csv b/data/csv/test_commit_rollback.csv\nnew file mode 100644\nindex 000000000000..b3beb57a4113\n--- /dev/null\n+++ b/data/csv/test_commit_rollback.csv\n@@ -0,0 +1,2 @@\n+commit,rollback, abort\n+1,1,1\n\\ No newline at end of file\ndiff --git a/test/api/adbc/test_adbc.cpp b/test/api/adbc/test_adbc.cpp\nindex f2a534bac958..eb45ccd4d623 100644\n--- a/test/api/adbc/test_adbc.cpp\n+++ b/test/api/adbc/test_adbc.cpp\n@@ -1,8 +1,8 @@\n #include \"arrow/arrow_test_helper.hpp\"\n #include \"catch.hpp\"\n #include \"duckdb/common/adbc/adbc.hpp\"\n-\n-#include <duckdb/common/adbc/options.h>\n+#include \"duckdb/common/adbc/wrappers.hpp\"\n+#include \"duckdb/common/adbc/options.h\"\n #include <iostream>\n \n namespace duckdb {\n@@ -54,12 +54,15 @@ class ADBCTestDatabase {\n \n \tbool QueryAndCheck(const string &query) {\n \t\tQueryArrow(query);\n-\t\tauto cconn = static_cast<Connection *>(adbc_connection.private_data);\n+\t\tauto conn_wrapper = static_cast<DuckDBAdbcConnectionWrapper *>(adbc_connection.private_data);\n+\n+\t\tauto cconn = reinterpret_cast<Connection *>(conn_wrapper->connection);\n \t\treturn ArrowTestHelper::RunArrowComparison(*cconn, query, arrow_stream);\n \t}\n \n \tunique_ptr<MaterializedQueryResult> Query(const string &query) {\n-\t\tauto cconn = static_cast<Connection *>(adbc_connection.private_data);\n+\t\tauto conn_wrapper = static_cast<DuckDBAdbcConnectionWrapper *>(adbc_connection.private_data);\n+\t\tauto cconn = reinterpret_cast<Connection *>(conn_wrapper->connection);\n \t\treturn cconn->Query(query);\n \t}\n \n@@ -1113,6 +1116,40 @@ TEST_CASE(\"Test AdbcConnectionGetTableTypes\", \"[adbc]\") {\n \tREQUIRE((res->GetValue(0, 0).ToString() == \"BASE TABLE\"));\n }\n \n+TEST_CASE(\"Test Segfault Option Set\", \"[adbc]\") {\n+\tif (!duckdb_lib) {\n+\t\treturn;\n+\t}\n+\n+\tAdbcDatabase adbc_database;\n+\tAdbcConnection adbc_connection;\n+\n+\tAdbcError adbc_error;\n+\tInitializeADBCError(&adbc_error);\n+\n+\tREQUIRE(SUCCESS(AdbcDatabaseNew(&adbc_database, &adbc_error)));\n+\tREQUIRE(SUCCESS(AdbcDatabaseSetOption(&adbc_database, \"driver\", duckdb_lib, &adbc_error)));\n+\tREQUIRE(SUCCESS(AdbcDatabaseSetOption(&adbc_database, \"entrypoint\", \"duckdb_adbc_init\", &adbc_error)));\n+\tREQUIRE(SUCCESS(AdbcDatabaseSetOption(&adbc_database, \"path\", \":memory:\", &adbc_error)));\n+\n+\tREQUIRE(SUCCESS(AdbcDatabaseInit(&adbc_database, &adbc_error)));\n+\n+\tREQUIRE(SUCCESS(AdbcConnectionNew(&adbc_connection, &adbc_error)));\n+\n+\tREQUIRE(SUCCESS(AdbcConnectionSetOption(&adbc_connection, ADBC_CONNECTION_OPTION_AUTOCOMMIT,\n+\t                                        ADBC_OPTION_VALUE_DISABLED, &adbc_error)));\n+\n+\tREQUIRE(SUCCESS(AdbcConnectionInit(&adbc_connection, &adbc_database, &adbc_error)));\n+\n+\tauto conn_wrapper = static_cast<DuckDBAdbcConnectionWrapper *>(adbc_connection.private_data);\n+\tauto cconn = reinterpret_cast<Connection *>(conn_wrapper->connection);\n+\n+\tREQUIRE(!cconn->IsAutoCommit());\n+\n+\tREQUIRE(SUCCESS(AdbcConnectionRelease(&adbc_connection, &adbc_error)));\n+\tREQUIRE(SUCCESS(AdbcDatabaseRelease(&adbc_database, &adbc_error)));\n+}\n+\n TEST_CASE(\"Test AdbcConnectionGetObjects\", \"[adbc]\") {\n \tif (!duckdb_lib) {\n \t\treturn;\ndiff --git a/test/issues/general/test_16662.test b/test/issues/general/test_16662.test\nnew file mode 100644\nindex 000000000000..d18c37d8c16d\n--- /dev/null\n+++ b/test/issues/general/test_16662.test\n@@ -0,0 +1,63 @@\n+# name: test/issues/general/test_16662.test\n+# description: Issue 16662 - Unexpected binder error when using a CTE multiple times\n+# group: [general]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE VIEW\n+  \"tbl1\" AS\n+  -- End of EXAMPLE 4 (pt1)\n+WITH\n+  data_infra as (\n+    select\n+      'a' as AMES,\n+      'b' as TONG\n+      -- Example 6: Unomment out the following line to see it work\n+      -- If there is more than one resulting row in the group by then there is not error\n+      -- union all\n+      -- select\n+      --   'c' as AMES,\n+      --   'b' as TONG\n+      --End Example 6\n+      -- Example 5: Comment out the following line to see it work\n+      -- If there is no group by then there is an error\n+    group by\n+      1\n+      -- End of Example 5\n+  )\n+SELECT\n+  -- Example 1: Comment the following lines to see it work\n+  -- If the CTE is used only once then there is no error\n+  case\n+    when 'b' in (\n+      select\n+        TONG\n+      from\n+        data_infra\n+    ) then 'tong'\n+    else 'Various'\n+  end as collapsed_TONG,\n+  --- End of Example 1\n+  -- Example 2: Comment the following lines to see it work\n+  -- If the CTE is used only once then there is no error\n+  case\n+    when 'ba' in (\n+      select\n+        TONG\n+      from\n+        data_infra\n+    ) then 'ames'\n+    else null\n+  end as collapsed_AMES,\n+  --- End of Example 2\n+  -- Example 3: Delete this line to see it work\n+  -- If there is no null column there is no error\n+  NULL AS NULL_COL;\n+\n+statement ok\n+SELECT\n+  *\n+FROM\n+  \"tbl1\";\ndiff --git a/test/issues/general/test_16783.test b/test/issues/general/test_16783.test\nnew file mode 100644\nindex 000000000000..0ee2ce6e81da\n--- /dev/null\n+++ b/test/issues/general/test_16783.test\n@@ -0,0 +1,18 @@\n+# name: test/issues/general/test_16783.test\n+# description: Issue 16783 - Anti-join meets INTERNAL Error: Attempted to dereference unique_ptr that is NULL\n+# group: [general]\n+\n+statement ok\n+pragma enable_verification;\n+\n+statement ok\n+CREATE TABLE t0(c0 FLOAT);\n+\n+statement ok\n+CREATE TABLE t1(c0 FLOAT);\n+\n+statement ok\n+select * from t0\n+where not exists(\n+    select 1 from t1 where (((((t0.c0) AND ((t1.c0 BETWEEN t0.c0 AND t0.c0)))) OR (((t0.c0) AND ((t1.c0 BETWEEN t0.c0 AND t0.c0))))))\n+);\ndiff --git a/test/sql/copy/csv/afl/test_fuzz_4086.test b/test/sql/copy/csv/afl/test_fuzz_4086.test\nindex 08d2d36a80aa..23ed7869f1f0 100644\n--- a/test/sql/copy/csv/afl/test_fuzz_4086.test\n+++ b/test/sql/copy/csv/afl/test_fuzz_4086.test\n@@ -4,8 +4,7 @@\n \n require json\n \n-statement ok\n-PRAGMA enable_verification\n+loop i 0 2\n \n statement maybe\n FROM read_csv('data/csv/afl/4086/case_1.csv', auto_detect=false, columns={'json': 'JSON'}, delim=NULL, buffer_size=42, store_rejects=true, rejects_limit=658694493994253607);\n@@ -18,3 +17,8 @@ FROM read_csv('data/csv/afl/4086/case_2.csv', auto_detect=false, columns={'json'\n statement maybe\n FROM read_csv('data/csv/afl/4086/case_3.csv', auto_detect=false, columns={'json': 'JSON'}, delim='\\0', buffer_size=42, store_rejects=true, rejects_limit=658694493994253607);\n ----\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+endloop\n\\ No newline at end of file\ndiff --git a/test/sql/copy/csv/auto/test_normalize_names.test b/test/sql/copy/csv/auto/test_normalize_names.test\nindex a8ffbd5ef299..25e73786a720 100644\n--- a/test/sql/copy/csv/auto/test_normalize_names.test\n+++ b/test/sql/copy/csv/auto/test_normalize_names.test\n@@ -5,6 +5,10 @@\n statement ok\n PRAGMA enable_verification\n \n+query I\n+select columns from sniff_csv('data/csv/test_commit_rollback.csv',  normalize_names = true)\n+----\n+[{'name': _commit, 'type': BIGINT}, {'name': _rollback, 'type': BIGINT}, {'name': _abort, 'type': BIGINT}]\n \n # CSV file with uppercase header\n statement ok\n@@ -36,7 +40,7 @@ DROP TABLE test;\n query I\n select columns from sniff_csv('data/csv/auto/normalize_names_2.csv', normalize_names = true)\n ----\n-[{'name': _select, 'type': BIGINT}, {'name': insert, 'type': VARCHAR}, {'name': _join, 'type': VARCHAR}]\n+[{'name': _select, 'type': BIGINT}, {'name': _insert, 'type': VARCHAR}, {'name': _join, 'type': VARCHAR}]\n \n \n # CSV file with keywords in header\n@@ -44,7 +48,7 @@ statement ok\n CREATE TABLE test AS SELECT * FROM read_csv_auto ('data/csv/auto/normalize_names_2.csv', normalize_names=TRUE);\n \n query ITT\n-SELECT _select, insert, _join FROM test ORDER BY _select;\n+SELECT _select, _insert, _join FROM test ORDER BY _select;\n ----\n 123\tTEST1\ttext1\n 345\tTEST1\ttext2\n@@ -107,4 +111,4 @@ DROP TABLE test;\n query I\n select columns from sniff_csv('data/csv/normalize.csv', normalize_names = true)\n ----\n-[{'name': name, 'type': VARCHAR}, {'name': text, 'type': VARCHAR}]\n+[{'name': _name, 'type': VARCHAR}, {'name': _text, 'type': VARCHAR}]\ndiff --git a/test/sql/index/art/constraints/test_art_eager_batch_insert.test b/test/sql/index/art/constraints/test_art_eager_batch_insert.test\nnew file mode 100644\nindex 000000000000..1da9a7f5d7be\n--- /dev/null\n+++ b/test/sql/index/art/constraints/test_art_eager_batch_insert.test\n@@ -0,0 +1,51 @@\n+# name: test/sql/index/art/constraints/test_art_eager_batch_insert.test\n+# description: Test eager constraint checking during batch inserts.\n+# group: [constraints]\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+statement ok\n+CREATE TABLE test1 (id INT PRIMARY KEY, payload VARCHAR);\n+\n+statement ok\n+CREATE TABLE test2 (id INT PRIMARY KEY, payload VARCHAR);\n+\n+statement ok\n+INSERT INTO test1 VALUES (1, 'row 1');\n+\n+statement ok\n+INSERT INTO test2 VALUES (1, 'row 1 from test 2');\n+\n+query II\n+SELECT id, payload FROM test1;\n+----\n+1\trow 1\n+\n+statement ok\n+BEGIN;\n+\n+statement ok\n+DELETE FROM test1 WHERE id = 1;\n+\n+query II\n+SELECT id, payload FROM test1;\n+----\n+\n+statement ok\n+INSERT INTO test1 SELECT * FROM test2;\n+\n+query II\n+SELECT id, payload FROM test1;\n+----\n+1\trow 1 from test 2\n+\n+statement ok\n+COMMIT\n+\n+query II\n+SELECT id, payload FROM test1;\n+----\n+1\trow 1 from test 2\n+\n+\ndiff --git a/test/sql/storage_version/storage_version.db b/test/sql/storage_version/storage_version.db\nindex 6342d80a5d0b..eb3c37a6d8ba 100644\nBinary files a/test/sql/storage_version/storage_version.db and b/test/sql/storage_version/storage_version.db differ\n",
  "problem_statement": "Anti-join meets INTERNAL Error: Attempted to dereference unique_ptr that is NULL\n### What happens?\n\nThe following not exists query meet the internal error.\n```\nCREATE TABLE t0(c0 FLOAT);\nCREATE TABLE t1(c0 FLOAT);\nselect * from t0\nwhere not exists(\n    select 1 from t1 where (((((t0.c0) AND ((t1.c0 BETWEEN t0.c0 AND t0.c0)))) OR (((t0.c0) AND ((t1.c0 BETWEEN t0.c0 AND t0.c0))))))\n);\n```\n```\nINTERNAL Error:\nAttempted to dereference unique_ptr that is NULL!\n\nStack Trace:\n\n0        duckdb::Exception::Exception(duckdb::ExceptionType, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&) + 64\n1        duckdb::InternalException::InternalException(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&) + 20\n2        duckdb::DistributivityRule::Apply(duckdb::LogicalOperator&, duckdb::vector<std::__1::reference_wrapper<duckdb::Expression>, true>&, bool&, bool) + 1488\n3        duckdb::ExpressionRewriter::ApplyRules(duckdb::LogicalOperator&, duckdb::vector<std::__1::reference_wrapper<duckdb::Rule>, true> const&, duckdb::unique_ptr<duckdb::Expression, std::__1::default_delete<duckdb::Expression>, true>, bool&, bool) + 324\n4        duckdb::ExpressionRewriter::VisitExpression(duckdb::unique_ptr<duckdb::Expression, std::__1::default_delete<duckdb::Expression>, true>*) + 96\n5        duckdb::LogicalOperatorVisitor::EnumerateExpressions(duckdb::LogicalOperator&, std::__1::function<void (duckdb::unique_ptr<duckdb::Expression, std::__1::default_delete<duckdb::Expression>, true>*)> const&) + 852\n6        duckdb::LogicalOperatorVisitor::VisitOperatorExpressions(duckdb::LogicalOperator&) + 68\n7        duckdb::ExpressionRewriter::VisitOperator(duckdb::LogicalOperator&) + 440\n8        duckdb::LogicalOperatorVisitor::VisitOperatorChildren(duckdb::LogicalOperator&) + 108\n9        duckdb::ExpressionRewriter::VisitOperator(duckdb::LogicalOperator&) + 44\n10       duckdb::LogicalOperatorVisitor::VisitOperatorChildren(duckdb::LogicalOperator&) + 108\n11       duckdb::ExpressionRewriter::VisitOperator(duckdb::LogicalOperator&) + 44\n12       duckdb::LogicalOperatorVisitor::VisitOperatorChildren(duckdb::LogicalOperator&) + 108\n13       duckdb::ExpressionRewriter::VisitOperator(duckdb::LogicalOperator&) + 44\n14       duckdb::LogicalOperatorVisitor::VisitOperatorChildren(duckdb::LogicalOperator&) + 108\n15       duckdb::ExpressionRewriter::VisitOperator(duckdb::LogicalOperator&) + 44\n16       duckdb::Optimizer::RunOptimizer(duckdb::OptimizerType, std::__1::function<void ()> const&) + 152\n17       duckdb::Optimizer::RunBuiltInOptimizers() + 160\n18       duckdb::Optimizer::Optimize(duckdb::unique_ptr<duckdb::LogicalOperator, std::__1::default_delete<duckdb::LogicalOperator>, true>) + 244\n19       duckdb::ClientContext::CreatePreparedStatementInternal(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::optional_ptr<std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, duckdb::BoundParameterData, duckdb::CaseInsensitiveStringHashFunction, duckdb::CaseInsensitiveStringEquality, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, duckdb::BoundParameterData>>>, true>) + 988\n20       duckdb::ClientContext::CreatePreparedStatement(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::optional_ptr<std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, duckdb::BoundParameterData, duckdb::CaseInsensitiveStringHashFunction, duckdb::CaseInsensitiveStringEquality, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, duckdb::BoundParameterData>>>, true>, duckdb::PreparedStatementMode) + 916\n21       duckdb::ClientContext::PendingStatementInternal(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::PendingQueryParameters const&) + 128\n22       duckdb::ClientContext::PendingStatementOrPreparedStatement(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::shared_ptr<duckdb::PreparedStatementData, true>&, duckdb::PendingQueryParameters const&) + 332\n23       duckdb::ClientContext::PendingStatementOrPreparedStatementInternal(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::shared_ptr<duckdb::PreparedStatementData, true>&, duckdb::PendingQueryParameters const&) + 1556\n24       duckdb::ClientContext::PendingQueryInternal(duckdb::ClientContextLock&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::PendingQueryParameters const&, bool) + 144\n25       duckdb::ClientContext::PendingQuery(duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, duckdb::BoundParameterData, duckdb::CaseInsensitiveStringHashFunction, duckdb::CaseInsensitiveStringEquality, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, duckdb::BoundParameterData>>>&, bool) + 288\n26       duckdb::ClientContext::PendingQuery(duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, bool) + 64\n27       duckdb::Connection::PendingQuery(duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, bool) + 64\n28       duckdb_shell_sqlite3_prepare_v2 + 996\n29       duckdb_shell::ShellState::ExecuteSQL(char const*, char**) + 148\n30       duckdb_shell::ShellState::RunOneSqlLine(char*) + 248\n31       duckdb_shell::ShellState::ProcessInput() + 1148\n32       main + 3436\n33       start + 6000\n```\n\n### To Reproduce\n\n```\nCREATE TABLE t0(c0 FLOAT);\nCREATE TABLE t1(c0 FLOAT);\nselect * from t0\nwhere not exists(\n    select 1 from t1 where (((((t0.c0) AND ((t1.c0 BETWEEN t0.c0 AND t0.c0)))) OR (((t0.c0) AND ((t1.c0 BETWEEN t0.c0 AND t0.c0))))))\n);\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\nv1.3.0-dev1736 c87ae7a200\n\n### DuckDB Client:\n\nCLI\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nTheoristCoder\n\n### Affiliation:\n\n NUS\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\nAnti-join meets INTERNAL Error: Attempted to dereference unique_ptr that is NULL\n### What happens?\n\nThe following not exists query meet the internal error.\n```\nCREATE TABLE t0(c0 FLOAT);\nCREATE TABLE t1(c0 FLOAT);\nselect * from t0\nwhere not exists(\n    select 1 from t1 where (((((t0.c0) AND ((t1.c0 BETWEEN t0.c0 AND t0.c0)))) OR (((t0.c0) AND ((t1.c0 BETWEEN t0.c0 AND t0.c0))))))\n);\n```\n```\nINTERNAL Error:\nAttempted to dereference unique_ptr that is NULL!\n\nStack Trace:\n\n0        duckdb::Exception::Exception(duckdb::ExceptionType, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&) + 64\n1        duckdb::InternalException::InternalException(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&) + 20\n2        duckdb::DistributivityRule::Apply(duckdb::LogicalOperator&, duckdb::vector<std::__1::reference_wrapper<duckdb::Expression>, true>&, bool&, bool) + 1488\n3        duckdb::ExpressionRewriter::ApplyRules(duckdb::LogicalOperator&, duckdb::vector<std::__1::reference_wrapper<duckdb::Rule>, true> const&, duckdb::unique_ptr<duckdb::Expression, std::__1::default_delete<duckdb::Expression>, true>, bool&, bool) + 324\n4        duckdb::ExpressionRewriter::VisitExpression(duckdb::unique_ptr<duckdb::Expression, std::__1::default_delete<duckdb::Expression>, true>*) + 96\n5        duckdb::LogicalOperatorVisitor::EnumerateExpressions(duckdb::LogicalOperator&, std::__1::function<void (duckdb::unique_ptr<duckdb::Expression, std::__1::default_delete<duckdb::Expression>, true>*)> const&) + 852\n6        duckdb::LogicalOperatorVisitor::VisitOperatorExpressions(duckdb::LogicalOperator&) + 68\n7        duckdb::ExpressionRewriter::VisitOperator(duckdb::LogicalOperator&) + 440\n8        duckdb::LogicalOperatorVisitor::VisitOperatorChildren(duckdb::LogicalOperator&) + 108\n9        duckdb::ExpressionRewriter::VisitOperator(duckdb::LogicalOperator&) + 44\n10       duckdb::LogicalOperatorVisitor::VisitOperatorChildren(duckdb::LogicalOperator&) + 108\n11       duckdb::ExpressionRewriter::VisitOperator(duckdb::LogicalOperator&) + 44\n12       duckdb::LogicalOperatorVisitor::VisitOperatorChildren(duckdb::LogicalOperator&) + 108\n13       duckdb::ExpressionRewriter::VisitOperator(duckdb::LogicalOperator&) + 44\n14       duckdb::LogicalOperatorVisitor::VisitOperatorChildren(duckdb::LogicalOperator&) + 108\n15       duckdb::ExpressionRewriter::VisitOperator(duckdb::LogicalOperator&) + 44\n16       duckdb::Optimizer::RunOptimizer(duckdb::OptimizerType, std::__1::function<void ()> const&) + 152\n17       duckdb::Optimizer::RunBuiltInOptimizers() + 160\n18       duckdb::Optimizer::Optimize(duckdb::unique_ptr<duckdb::LogicalOperator, std::__1::default_delete<duckdb::LogicalOperator>, true>) + 244\n19       duckdb::ClientContext::CreatePreparedStatementInternal(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::optional_ptr<std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, duckdb::BoundParameterData, duckdb::CaseInsensitiveStringHashFunction, duckdb::CaseInsensitiveStringEquality, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, duckdb::BoundParameterData>>>, true>) + 988\n20       duckdb::ClientContext::CreatePreparedStatement(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::optional_ptr<std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, duckdb::BoundParameterData, duckdb::CaseInsensitiveStringHashFunction, duckdb::CaseInsensitiveStringEquality, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, duckdb::BoundParameterData>>>, true>, duckdb::PreparedStatementMode) + 916\n21       duckdb::ClientContext::PendingStatementInternal(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::PendingQueryParameters const&) + 128\n22       duckdb::ClientContext::PendingStatementOrPreparedStatement(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::shared_ptr<duckdb::PreparedStatementData, true>&, duckdb::PendingQueryParameters const&) + 332\n23       duckdb::ClientContext::PendingStatementOrPreparedStatementInternal(duckdb::ClientContextLock&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::shared_ptr<duckdb::PreparedStatementData, true>&, duckdb::PendingQueryParameters const&) + 1556\n24       duckdb::ClientContext::PendingQueryInternal(duckdb::ClientContextLock&, duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, duckdb::PendingQueryParameters const&, bool) + 144\n25       duckdb::ClientContext::PendingQuery(duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, duckdb::BoundParameterData, duckdb::CaseInsensitiveStringHashFunction, duckdb::CaseInsensitiveStringEquality, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, duckdb::BoundParameterData>>>&, bool) + 288\n26       duckdb::ClientContext::PendingQuery(duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, bool) + 64\n27       duckdb::Connection::PendingQuery(duckdb::unique_ptr<duckdb::SQLStatement, std::__1::default_delete<duckdb::SQLStatement>, true>, bool) + 64\n28       duckdb_shell_sqlite3_prepare_v2 + 996\n29       duckdb_shell::ShellState::ExecuteSQL(char const*, char**) + 148\n30       duckdb_shell::ShellState::RunOneSqlLine(char*) + 248\n31       duckdb_shell::ShellState::ProcessInput() + 1148\n32       main + 3436\n33       start + 6000\n```\n\n### To Reproduce\n\n```\nCREATE TABLE t0(c0 FLOAT);\nCREATE TABLE t1(c0 FLOAT);\nselect * from t0\nwhere not exists(\n    select 1 from t1 where (((((t0.c0) AND ((t1.c0 BETWEEN t0.c0 AND t0.c0)))) OR (((t0.c0) AND ((t1.c0 BETWEEN t0.c0 AND t0.c0))))))\n);\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\nv1.3.0-dev1736 c87ae7a200\n\n### DuckDB Client:\n\nCLI\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nTheoristCoder\n\n### Affiliation:\n\n NUS\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2025-03-25T19:50:11Z"
}