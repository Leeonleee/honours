{
  "repo": "duckdb/duckdb",
  "pull_number": 5697,
  "instance_id": "duckdb__duckdb-5697",
  "issue_numbers": [
    "5670"
  ],
  "base_commit": "ea97dacbbd7d913b5b07ca71c40fd825bc02b252",
  "patch": "diff --git a/tools/nodejs/src/connection.cpp b/tools/nodejs/src/connection.cpp\nindex cecc67c11a4c..7748834c6faf 100644\n--- a/tools/nodejs/src/connection.cpp\n+++ b/tools/nodejs/src/connection.cpp\n@@ -213,7 +213,8 @@ void DuckDBNodeUDFLauncher(Napi::Env env, Napi::Function jsudf, std::nullptr_t *\n \t\t\tauto data = ret.Get(\"data\").As<Napi::Array>();\n \t\t\tauto out = duckdb::FlatVector::GetData<duckdb::string_t>(*jsargs->result);\n \t\t\tfor (size_t i = 0; i < data.Length(); ++i) {\n-\t\t\t\tout[i] = duckdb::string_t(data.Get(i).ToString());\n+\t\t\t\t// Use the AddString method to save the memory into the StringHeap if it can't be inlined\n+\t\t\t\tout[i] = duckdb::StringVector::AddString(*jsargs->result, data.Get(i).ToString());\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n",
  "test_patch": "diff --git a/tools/nodejs/test/udf.test.ts b/tools/nodejs/test/udf.test.ts\nindex 99b49effac3e..6c5cf048e706 100644\n--- a/tools/nodejs/test/udf.test.ts\n+++ b/tools/nodejs/test/udf.test.ts\n@@ -36,6 +36,15 @@ describe('UDFs', function() {\n             db.unregister_udf(\"udf\", done);\n         });\n \n+        it('0ary non-inlined string', function(done) {\n+            db.register_udf(\"udf\", \"varchar\", () => 'this string is over 12 bytes');\n+            db.all(\"select udf() v\", function(err: null | Error, rows: TableData) {\n+                if (err) throw err;\n+                assert.equal(rows[0].v, 'this string is over 12 bytes');\n+            });\n+            db.unregister_udf(\"udf\", done);\n+        });\n+\n         it('0ary int null', function(done) {\n             db.register_udf(\"udf\", \"integer\", () => undefined);\n             db.all(\"select udf() v\", function(err: null | Error, rows: TableData) {\n",
  "problem_statement": "'Invalid unicode (byte sequence mismatch) detected in value construction' for JS UDF returning more than 12 characters\n### What happens?\n\nGetting `Invalid unicode (byte sequence mismatch) detected in value construction' when our UDF returns more than 12 characters.\r\n\r\nI assume this is a bug, have not seen anywhere in docs or code where we can specify the UDF should return more.\n\n### To Reproduce\n\nTry running this test:\r\n```\r\nconst duckdb = require('duckdb');\r\nconst assert = require('node:assert/strict');\r\n\r\nit('0ary string > 12 characters', function(done) {\r\n\r\n    db = new duckdb.Database(':memory:');\r\n\r\n    // Works if string is 12 characters or less \r\n    const str = '0123456789123';\r\n\r\n    db.register_udf(\"udf\", \"varchar\", () => str);\r\n    db.all(\"select udf() v\", function(err, rows) {\r\n        if (err) throw err;\r\n        assert.equal(rows[0].v, str);\r\n        done();\r\n    });\r\n    \r\n});\r\n```\n\n### OS:\n\nUbuntu running on WSL on Windows x64\n\n### DuckDB Version:\n\n0.6.1\n\n### DuckDB Client:\n\nnodejs\n\n### Full Name:\n\nChris Brain\n\n### Affiliation:\n\nNone\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Thanks for the report!\n\n12 is the max length for an inlined string internally, so if I had to guess this is probably an issue related to allocations, if the memory contains random garbage\nThanks for the quick response @Tishj!  - So this is a 'bug' and we should be able to return much longer text in these UDFs right?\nI haven't looked at or worked on this client code, so I cant say for sure\nBut I'd imagine this is not intended behavior",
  "created_at": "2022-12-14T11:36:30Z"
}