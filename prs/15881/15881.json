{
  "repo": "duckdb/duckdb",
  "pull_number": 15881,
  "instance_id": "duckdb__duckdb-15881",
  "issue_numbers": [
    "15316"
  ],
  "base_commit": "ba8eaca942c94550cf999e4f44208977401f0a7f",
  "patch": "diff --git a/src/optimizer/pushdown/pushdown_left_join.cpp b/src/optimizer/pushdown/pushdown_left_join.cpp\nindex 814adadc040d..8ac7d3e8472c 100644\n--- a/src/optimizer/pushdown/pushdown_left_join.cpp\n+++ b/src/optimizer/pushdown/pushdown_left_join.cpp\n@@ -1,12 +1,28 @@\n+#include \"duckdb/common/assert.hpp\"\n+#include \"duckdb/common/enums/join_type.hpp\"\n+#include \"duckdb/common/helper.hpp\"\n+#include \"duckdb/common/typedefs.hpp\"\n+#include \"duckdb/common/types.hpp\"\n+#include \"duckdb/common/types/value.hpp\"\n+#include \"duckdb/common/unique_ptr.hpp\"\n+#include \"duckdb/common/unordered_map.hpp\"\n #include \"duckdb/execution/expression_executor.hpp\"\n #include \"duckdb/optimizer/filter_pushdown.hpp\"\n #include \"duckdb/optimizer/optimizer.hpp\"\n+#include \"duckdb/planner/binder.hpp\"\n+#include \"duckdb/planner/column_binding.hpp\"\n #include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n #include \"duckdb/planner/expression/bound_comparison_expression.hpp\"\n #include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n #include \"duckdb/planner/expression_iterator.hpp\"\n+#include \"duckdb/planner/logical_operator.hpp\"\n+#include \"duckdb/planner/operator/logical_any_join.hpp\"\n #include \"duckdb/planner/operator/logical_comparison_join.hpp\"\n+#include \"duckdb/planner/operator/logical_cross_product.hpp\"\n+#include \"duckdb/planner/operator/logical_dummy_scan.hpp\"\n #include \"duckdb/planner/operator/logical_filter.hpp\"\n+#include \"duckdb/planner/operator/logical_projection.hpp\"\n+#include <utility>\n \n namespace duckdb {\n \n@@ -126,7 +142,49 @@ unique_ptr<LogicalOperator> FilterPushdown::PushdownLeftJoin(unique_ptr<LogicalO\n \t});\n \tright_pushdown.GenerateFilters();\n \top->children[0] = left_pushdown.Rewrite(std::move(op->children[0]));\n-\top->children[1] = right_pushdown.Rewrite(std::move(op->children[1]));\n+\n+\tbool rewrite_right = true;\n+\tif (op->type == LogicalOperatorType::LOGICAL_ANY_JOIN) {\n+\t\tauto &any_join = join.Cast<LogicalAnyJoin>();\n+\t\tif (AddFilter(any_join.condition->Copy()) == FilterResult::UNSATISFIABLE) {\n+\t\t\t// filter statically evaluates to false, turns it to the cross product join with 1 row NULLs\n+\t\t\tif (any_join.join_type == JoinType::LEFT) {\n+\t\t\t\tunordered_map<idx_t, vector<unique_ptr<Expression>>> projections_groups;\n+\t\t\t\tauto column_bindings = op->children[1]->GetColumnBindings();\n+\t\t\t\top->children[1]->ResolveOperatorTypes();\n+\t\t\t\tauto &types = op->children[1]->types;\n+\t\t\t\tfor (idx_t i = 0; i < column_bindings.size(); i++) {\n+\t\t\t\t\tprojections_groups[column_bindings[i].table_index].emplace_back(\n+\t\t\t\t\t    make_uniq<BoundConstantExpression>(Value(types[i])));\n+\t\t\t\t}\n+\n+\t\t\t\tauto create_proj_dummy_scan = [&](idx_t table_index) {\n+\t\t\t\t\tauto dummy_scan = make_uniq<LogicalDummyScan>(optimizer.binder.GenerateTableIndex());\n+\t\t\t\t\tauto proj = make_uniq<LogicalProjection>(table_index, std::move(projections_groups[table_index]));\n+\t\t\t\t\tproj->AddChild(std::move(dummy_scan));\n+\t\t\t\t\treturn proj;\n+\t\t\t\t};\n+\t\t\t\t// make cross products on the RHS first\n+\t\t\t\tauto begin = projections_groups.begin();\n+\t\t\t\tD_ASSERT(begin != projections_groups.end());\n+\t\t\t\tunique_ptr<LogicalOperator> left = create_proj_dummy_scan(begin->first);\n+\t\t\t\tprojections_groups.erase(begin);\n+\t\t\t\tfor (auto &group : projections_groups) {\n+\t\t\t\t\tauto proj = create_proj_dummy_scan(group.first);\n+\t\t\t\t\tauto op = LogicalCrossProduct::Create(std::move(left), std::move(proj));\n+\t\t\t\t\tleft = std::move(op);\n+\t\t\t\t}\n+\t\t\t\t// then make cross product with the LHS\n+\t\t\t\top = LogicalCrossProduct::Create(std::move(op->children[0]), std::move(left));\n+\t\t\t\trewrite_right = false;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (rewrite_right) {\n+\t\top->children[1] = right_pushdown.Rewrite(std::move(op->children[1]));\n+\t}\n+\n \treturn PushFinalFilters(std::move(op));\n }\n \n",
  "test_patch": "diff --git a/test/optimizer/statistics/statistics_is_null.test b/test/optimizer/statistics/statistics_is_null.test\nindex 5fce1b6b603b..0c77dce732f4 100644\n--- a/test/optimizer/statistics/statistics_is_null.test\n+++ b/test/optimizer/statistics/statistics_is_null.test\n@@ -45,12 +45,14 @@ EXPLAIN SELECT i IS NULL FROM integers2 WHERE i>0;\n ----\n logical_opt\t<!REGEX>:.*IS NULL.*\n \n-# left/right/full outer joins can introduce nulls, even if the base tables do not contain them\n+# left/right outer joins with false condition can convert to cross product with constant NULL value, \n+# so we don't need to check IS NULL here, since it's always NULL\n query II\n EXPLAIN SELECT i2.i IS NULL FROM integers i1 LEFT JOIN integers i2 ON (false);\n ----\n-logical_opt\t<REGEX>:.*IS NULL.*\n+logical_opt\t<!REGEX>:.*IS NULL.*\n \n+# full outer joins can introduce nulls, even if the base tables do not contain them\n query II\n EXPLAIN SELECT i1.i IS NULL FROM integers i1 FULL OUTER JOIN integers i2 ON (false);\n ----\ndiff --git a/test/sql/join/left_outer/left_join_issue_15316.test b/test/sql/join/left_outer/left_join_issue_15316.test\nnew file mode 100644\nindex 000000000000..2f63a9b99b9a\n--- /dev/null\n+++ b/test/sql/join/left_outer/left_join_issue_15316.test\n@@ -0,0 +1,53 @@\n+# name: test/sql/join/left_outer/left_join_issue_15316.test\n+# description: Issue #15316: Left join should strip tree if filter statically evaluates to false\n+# group: [left_outer]\n+\n+statement ok\n+set explain_output='optimized_only';\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE OR REPLACE TABLE big_table AS\n+SELECT i.range AS col1,\n+       CAST(random() * 1000 AS INTEGER) AS col2\n+FROM range(100) i;\n+\n+statement ok\n+CREATE OR REPLACE TABLE single_col_table AS\n+SELECT i.range AS col1\n+FROM range(50) i;\n+\n+query II\n+explain SELECT * \n+FROM big_table c\n+LEFT OUTER JOIN single_col_table hd ON hd.col1=c.col1 \n+AND (\n+    FALSE\n+);\n+----\n+logical_opt\t<REGEX>:.*CROSS_PRODUCT.*\n+\n+# RHS contains multiple tables\n+statement ok\n+CREATE TABLE integers1 AS SELECT * FROM (VALUES (1), (2), (3)) tbl(i);\n+\n+statement ok\n+CREATE TABLE integers2 AS SELECT * FROM (VALUES (1, '1'), (2, '2'), (3, '3')) tbl(i, s);\n+\n+statement ok\n+CREATE TABLE integers3 AS SELECT * FROM (VALUES (1, '4'), (2, '5'), (3, '6')) tbl(i, s);\n+\n+query III\n+SELECT\n+    i1.i AS i1_i,\n+    i2.s,\n+    i3.i AS i3_i\n+FROM\n+    integers1 i1\n+LEFT OUTER JOIN (integers2 i2 LEFT OUTER JOIN integers3 i3 ON i2.i = i3.i) on false;\n+----\n+1\tNULL\tNULL\n+2\tNULL\tNULL\n+3\tNULL\tNULL\n",
  "problem_statement": "Literal 'FALSE' much slower than false condition that triggers predicate pushdown\n### What happens?\r\n\r\nWhen querying against parquet files, I am using a JOIN condition that should return no rows. Joining on FALSE is far slower than joining on a FALSE-yielding statement that references a column available in the parquet files.\r\n\r\n## Example\r\nIn this example, `single_col_table.parquet` col1 is never < 0.\r\n\r\nSlow:\r\n```sql\r\nSELECT * \r\nFROM big_table.parquet c\r\nLEFT OUTER JOIN single_col_table.parquet hd ON hd.col1=c.col1 \r\nAND (\r\n    FALSE\r\n)\r\n\r\n```\r\n\r\nFast:\r\n```sql\r\nSELECT * \r\nFROM big_table.parquet c\r\nLEFT OUTER JOIN single_col_table.parquet hd ON hd.col1=c.col1 \r\nAND (\r\n    hd.col1 = -1\r\n)\r\n```\r\n\r\n### To Reproduce\r\n\r\n## Generate the tables\r\n\r\n`generate.sql`:\r\n```sql\r\n\r\n-- Create a large table with two columns\r\nCREATE OR REPLACE TABLE big_table AS\r\nSELECT i.range AS col1,\r\n       CAST(random() * 1000000 AS INTEGER) AS col2\r\nFROM range(1_000_000) i;\r\n\r\n-- Create another large table with one column\r\nCREATE OR REPLACE TABLE single_col_table AS\r\nSELECT i.range AS col1\r\nFROM range(500_000) i;\r\n\r\nCOPY big_table TO 'big_table.parquet' (FORMAT 'parquet');\r\nCOPY single_col_table TO 'single_col_table.parquet' (FORMAT 'parquet');\r\n\r\n```\r\n\r\n```sh\r\n\r\nduckdb < generate.sql\r\n\r\n```\r\n\r\n## Run the fast query\r\nIt executes quickly.\r\n\r\n`query_fast.sql`:\r\n```sql\r\nSELECT * \r\nFROM big_table.parquet c\r\nLEFT OUTER JOIN single_col_table.parquet hd ON hd.col1=c.col1 \r\nAND (\r\n    hd.col1 = -1\r\n);\r\n```\r\n\r\n```sh\r\nduckdb < query_fast.sql\r\n```\r\n\r\n## Run the slow query\r\nIt takes a long time.\r\n\r\n`query_slow.sql`:\r\n```sql\r\nSELECT * \r\nFROM big_table.parquet c\r\nLEFT OUTER JOIN single_col_table.parquet hd ON hd.col1=c.col1 \r\nAND (\r\n    FALSE\r\n);\r\n```\r\n\r\n```sh\r\nduckdb < query_slow.sql\r\n```\r\n\r\n## Notes\r\n* This has an easy workaround, documented in the \"fast\" query, so I am not requesting any support, but raising this in case it's of interest.\r\n* If the `slow` query runs too quickly for you, just increase the number of records in the `generate` step.\r\n\r\n### OS:\r\n\r\nmacOS Ventura (13.6.9)\r\n\r\n### DuckDB Version:\r\n\r\nv1.1.3\r\n\r\n### DuckDB Client:\r\n\r\nduckdb cli (it also repros with github.com/marcboeker/go-duckdb )\r\n\r\n### Hardware:\r\n\r\nrepros on mac ARM and linux x86\r\n\r\n### Full Name:\r\n\r\nJames Pirruccello\r\n\r\n### Affiliation:\r\n\r\nCarbocation Corporation\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "This is surely very interesting, thanks. We'll take a look.\nHi, I'm external and I would like to try myself on this issue. I have read the contributing.md. Can I go ahead and try to solve it? Here are my insights so far:\r\n\"I am using a JOIN condition that should return no rows\" - actually, since you are using a left outer join, the query should return as many rows as the lhs table has. It's a common misconception that the join condition behaves like a where-clause. What really happens is that the join condition determines whether the rows match and where they don't match, the columns of the rhs table are set to null.\r\nNevertheless, the query with a constant false join condition should still trigger predicate pushdown, but it doesn't:\r\n\r\noptimized logical plan for the fast query:\r\n![fast](https://github.com/user-attachments/assets/2bcaef8f-3658-4b21-9b5b-6a4afd32271b)\r\n\r\noptimized logical plan for the slow query:\r\n![slow](https://github.com/user-attachments/assets/839fe9d1-df22-4a23-8e1c-c31537e5d271)\r\n\r\nNotice, how the slow query scans the rhs table, whereas the fast query doesn't and simply fills up the columns with null values.",
  "created_at": "2025-01-24T08:14:13Z"
}