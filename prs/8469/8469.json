{
  "repo": "duckdb/duckdb",
  "pull_number": 8469,
  "instance_id": "duckdb__duckdb-8469",
  "issue_numbers": [
    "8359"
  ],
  "base_commit": "ce647e0ff3e9af413f464cf0cd77047e98baf625",
  "patch": "diff --git a/src/include/duckdb/main/relation.hpp b/src/include/duckdb/main/relation.hpp\nindex 0dd981e08d84..357c41930bee 100644\n--- a/src/include/duckdb/main/relation.hpp\n+++ b/src/include/duckdb/main/relation.hpp\n@@ -19,8 +19,11 @@\n #include \"duckdb/main/client_context.hpp\"\n #include \"duckdb/main/external_dependencies.hpp\"\n #include \"duckdb/parser/statement/explain_statement.hpp\"\n-\n-#include <memory>\n+#include \"duckdb/parser/parsed_expression.hpp\"\n+#include \"duckdb/parser/result_modifier.hpp\"\n+#include \"duckdb/common/unique_ptr.hpp\"\n+#include \"duckdb/common/vector.hpp\"\n+#include \"duckdb/common/helper.hpp\"\n \n namespace duckdb {\n struct BoundStatement;\n@@ -81,9 +84,12 @@ class Relation : public std::enable_shared_from_this<Relation> {\n \tDUCKDB_API shared_ptr<Relation> Project(const string &select_list, const vector<string> &aliases);\n \tDUCKDB_API shared_ptr<Relation> Project(const vector<string> &expressions);\n \tDUCKDB_API shared_ptr<Relation> Project(const vector<string> &expressions, const vector<string> &aliases);\n+\tDUCKDB_API shared_ptr<Relation> Project(vector<unique_ptr<ParsedExpression>> expressions,\n+\t                                        const vector<string> &aliases);\n \n \t// FILTER\n \tDUCKDB_API shared_ptr<Relation> Filter(const string &expression);\n+\tDUCKDB_API shared_ptr<Relation> Filter(unique_ptr<ParsedExpression> expression);\n \tDUCKDB_API shared_ptr<Relation> Filter(const vector<string> &expressions);\n \n \t// LIMIT\n@@ -92,6 +98,7 @@ class Relation : public std::enable_shared_from_this<Relation> {\n \t// ORDER\n \tDUCKDB_API shared_ptr<Relation> Order(const string &expression);\n \tDUCKDB_API shared_ptr<Relation> Order(const vector<string> &expressions);\n+\tDUCKDB_API shared_ptr<Relation> Order(vector<OrderByNode> expressions);\n \n \t// JOIN operation\n \tDUCKDB_API shared_ptr<Relation> Join(const shared_ptr<Relation> &other, const string &condition,\ndiff --git a/src/main/relation.cpp b/src/main/relation.cpp\nindex dc5be511677d..4a337b93e224 100644\n--- a/src/main/relation.cpp\n+++ b/src/main/relation.cpp\n@@ -47,6 +47,11 @@ shared_ptr<Relation> Relation::Project(const vector<string> &expressions) {\n \treturn Project(expressions, aliases);\n }\n \n+shared_ptr<Relation> Relation::Project(vector<unique_ptr<ParsedExpression>> expressions,\n+                                       const vector<string> &aliases) {\n+\treturn make_shared<ProjectionRelation>(shared_from_this(), std::move(expressions), aliases);\n+}\n+\n static vector<unique_ptr<ParsedExpression>> StringListToExpressionList(ClientContext &context,\n                                                                        const vector<string> &expressions) {\n \tif (expressions.empty()) {\n@@ -73,7 +78,11 @@ shared_ptr<Relation> Relation::Filter(const string &expression) {\n \tif (expression_list.size() != 1) {\n \t\tthrow ParserException(\"Expected a single expression as filter condition\");\n \t}\n-\treturn make_shared<FilterRelation>(shared_from_this(), std::move(expression_list[0]));\n+\treturn Filter(std::move(expression_list[0]));\n+}\n+\n+shared_ptr<Relation> Relation::Filter(unique_ptr<ParsedExpression> expression) {\n+\treturn make_shared<FilterRelation>(shared_from_this(), std::move(expression));\n }\n \n shared_ptr<Relation> Relation::Filter(const vector<string> &expressions) {\n@@ -95,6 +104,10 @@ shared_ptr<Relation> Relation::Limit(int64_t limit, int64_t offset) {\n \n shared_ptr<Relation> Relation::Order(const string &expression) {\n \tauto order_list = Parser::ParseOrderList(expression, context.GetContext()->GetParserOptions());\n+\treturn Order(std::move(order_list));\n+}\n+\n+shared_ptr<Relation> Relation::Order(vector<OrderByNode> order_list) {\n \treturn make_shared<OrderRelation>(shared_from_this(), std::move(order_list));\n }\n \n@@ -110,7 +123,7 @@ shared_ptr<Relation> Relation::Order(const vector<string> &expressions) {\n \t\t}\n \t\torder_list.push_back(std::move(inner_list[0]));\n \t}\n-\treturn make_shared<OrderRelation>(shared_from_this(), std::move(order_list));\n+\treturn Order(std::move(order_list));\n }\n \n shared_ptr<Relation> Relation::Join(const shared_ptr<Relation> &other, const string &condition, JoinType type,\ndiff --git a/tools/pythonpkg/duckdb-stubs/__init__.pyi b/tools/pythonpkg/duckdb-stubs/__init__.pyi\nindex ed88157dfbff..9c3853279892 100644\n--- a/tools/pythonpkg/duckdb-stubs/__init__.pyi\n+++ b/tools/pythonpkg/duckdb-stubs/__init__.pyi\n@@ -82,6 +82,68 @@ class PythonExceptionHandling:\n     @property\n     def value(self) -> int: ...\n \n+class Expression:\n+\tdef __init__(self, *args, **kwargs) -> None: ...\n+\tdef __neg__(self) -> \"Expression\": ...\n+\n+\tdef __add__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __radd__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+\tdef __sub__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __rsub__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+\tdef __mul__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __rmul__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+\tdef __div__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __rdiv__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+\tdef __truediv__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __rtruediv__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+\tdef __floordiv__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __rfloordiv__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+\tdef __mod__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __rmod__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+\tdef __pow__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __rpow__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+\tdef __and__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __rand__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __or__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __ror__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __invert__(self) -> \"Expression\": ...\n+\n+\tdef __eq__(# type: ignore[override]\n+\t\tself, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __ne__(# type: ignore[override]\n+\t\tself, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __gt__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __ge__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __lt__(self, expr: \"Expression\") -> \"Expression\": ...\n+\tdef __le__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+\tdef show(self) -> None: ...\n+\tdef __repr__(self) -> str: ...\n+\tdef alias(self, alias: str) -> None: ...\n+\tdef when(self, condition: \"Expression\", value: \"Expression\") -> \"Expression\": ...\n+\tdef otherwise(self, value: \"Expression\") -> \"Expression\": ...\n+\tdef cast(self, type: DuckDBPyType) -> \"Expression\": ...\n+\tdef asc(self) -> \"Expression\": ...\n+\tdef desc(self) -> \"Expression\": ...\n+\tdef nulls_first(self) -> \"Expression\": ...\n+\tdef nulls_last(self) -> \"Expression\": ...\n+\tdef isin(self, *cols: \"Expression\") -> \"Expression\": ...\n+\tdef isnotin(self, *cols: \"Expression\") -> \"Expression\": ...\n+\n+def StarExpression(exclude: Optional[List[str]]) -> Expression: ...\n+def ColumnExpression(column: str) -> Expression: ...\n+def ConstantExpression(val: Any) -> Expression: ...\n+def CaseExpression(condition: Expression, value: Expression) -> Expression: ...\n+def FunctionExpression(function: str, *cols: Expression) -> Expression: ...\n+\n class DuckDBPyConnection:\n     def __init__(self, *args, **kwargs) -> None: ...\n     def append(self, table_name: str, df: pandas.DataFrame) -> DuckDBPyConnection: ...\n@@ -257,7 +319,7 @@ class DuckDBPyRelation:\n     def fetchdf(self, *args, **kwargs) -> Any: ...\n     def fetch_arrow_reader(self, batch_size: int = ...) -> pyarrow.lib.RecordBatchReader: ...\n     def fetch_arrow_table(self, rows_per_batch: int = ...) -> pyarrow.lib.Table: ...\n-    def filter(self, filter_expr: str) -> DuckDBPyRelation: ...\n+    def filter(self, filter_expr: Union[Expression, str]) -> DuckDBPyRelation: ...\n     def first(self, column: str, window_spec: str, ignore_nulls: bool, projected_columns: str) -> DuckDBPyRelation: ...\n     def first_value(self, column: str, window_spec: str, ignore_nulls: bool, projected_columns: str) -> DuckDBPyRelation: ...\n     def fsum(self, column: str, groups: str, window_spec: str, projected_columns: str) -> DuckDBPyRelation: ...\n@@ -282,10 +344,12 @@ class DuckDBPyRelation:\n     def n_tile(self, window_spec: str, num_buckets: int, projected_columns: str) -> DuckDBPyRelation: ...\n     def nth_value(self, column: str, window_spec: str, offset: int, ignore_nulls: bool, projected_columns: str) -> DuckDBPyRelation: ...\n     def order(self, order_expr: str) -> DuckDBPyRelation: ...\n+    def sort(self, *cols: Expression) -> DuckDBPyRelation: ...\n+    def project(self, *cols: Union[str, Expression]) -> DuckDBPyRelation: ...\n+    def select(self, *cols: Union[str, Expression]) -> DuckDBPyRelation: ...\n     def percent_rank(self, window_spec: str, projected_columns: str) -> DuckDBPyRelation: ...\n     def pl(self, rows_per_batch: int = ..., connection: DuckDBPyConnection = ...) -> polars.DataFrame: ...\n     def product(self, column: str, groups: str, window_spec: str, projected_columns: str) -> DuckDBPyRelation: ...\n-    def project(self, project_expr: str) -> DuckDBPyRelation: ...\n     def quantile(self, q: str, quantile_aggr: str, group_expr: str = ...) -> DuckDBPyRelation: ...\n     def quantile_cont(self, column: str, q: Union[float, List[float]], groups: str, projected_columns: str) -> DuckDBPyRelation: ...\n     def quantile_disc(self, column: str, q: Union[float, List[float]], groups: str, projected_columns: str) -> DuckDBPyRelation: ...\ndiff --git a/tools/pythonpkg/duckdb/__init__.py b/tools/pythonpkg/duckdb/__init__.py\nindex 140db03af5c0..29cb61c114cb 100644\n--- a/tools/pythonpkg/duckdb/__init__.py\n+++ b/tools/pythonpkg/duckdb/__init__.py\n@@ -13,13 +13,25 @@\n     DuckDBPyRelation,\n     DuckDBPyConnection,\n     ExplainType,\n-    PythonExceptionHandling\n+    PythonExceptionHandling,\n+    Expression,\n+    ConstantExpression,\n+    ColumnExpression,\n+    StarExpression,\n+    FunctionExpression,\n+    CaseExpression,\n )\n _exported_symbols.extend([\n     \"DuckDBPyRelation\",\n     \"DuckDBPyConnection\",\n     \"ExplainType\",\n-    \"PythonExceptionHandling\"\n+    \"PythonExceptionHandling\",\n+    \"Expression\",\n+    \"ConstantExpression\",\n+    \"ColumnExpression\",\n+    \"StarExpression\",\n+    \"FunctionExpression\",\n+    \"CaseExpression\",\n ])\n \n # Enums\ndiff --git a/tools/pythonpkg/duckdb_python.cpp b/tools/pythonpkg/duckdb_python.cpp\nindex 4da932993bd2..d2632c076a96 100644\n--- a/tools/pythonpkg/duckdb_python.cpp\n+++ b/tools/pythonpkg/duckdb_python.cpp\n@@ -7,6 +7,7 @@\n #include \"duckdb_python/python_objects.hpp\"\n #include \"duckdb_python/pyconnection/pyconnection.hpp\"\n #include \"duckdb_python/pyrelation.hpp\"\n+#include \"duckdb_python/expression/pyexpression.hpp\"\n #include \"duckdb_python/pyresult.hpp\"\n #include \"duckdb_python/pybind11/exceptions.hpp\"\n #include \"duckdb_python/typing.hpp\"\n@@ -276,6 +277,7 @@ PYBIND11_MODULE(DUCKDB_PYTHON_LIB_NAME, m) { // NOLINT\n \n \tDuckDBPyTyping::Initialize(m);\n \tDuckDBPyFunctional::Initialize(m);\n+\tDuckDBPyExpression::Initialize(m);\n \tDuckDBPyRelation::Initialize(m);\n \tDuckDBPyConnection::Initialize(m);\n \tPythonObject::Initialize();\ndiff --git a/tools/pythonpkg/src/CMakeLists.txt b/tools/pythonpkg/src/CMakeLists.txt\nindex 5712bdf70286..1a3cbf705a2c 100644\n--- a/tools/pythonpkg/src/CMakeLists.txt\n+++ b/tools/pythonpkg/src/CMakeLists.txt\n@@ -6,6 +6,7 @@ include_directories(${pybind11_INCLUDE_DIR})\n include_directories(${PYTHON_INCLUDE_DIRS})\n \n add_subdirectory(pyrelation)\n+add_subdirectory(pyexpression)\n add_subdirectory(pybind11)\n add_subdirectory(numpy)\n add_subdirectory(native)\n@@ -24,6 +25,7 @@ add_library(\n   pyconnection.cpp\n   python_import_cache.cpp\n   pyrelation.cpp\n+  pyexpression.cpp\n   dataframe.cpp\n   pyresult.cpp\n   pyfilesystem.cpp\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp b/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\nindex a8f87764085f..e76ba64703b8 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\n@@ -174,7 +174,7 @@ class PyConnectionWrapper {\n \tstatic unique_ptr<DuckDBPyRelation> FromParquetDefault(const string &filename,\n \t                                                       shared_ptr<DuckDBPyConnection> conn = nullptr);\n \n-\tstatic unique_ptr<DuckDBPyRelation> ProjectDf(const PandasDataFrame &df, const string &expr,\n+\tstatic unique_ptr<DuckDBPyRelation> ProjectDf(const PandasDataFrame &df, const py::object &expr,\n \t                                              shared_ptr<DuckDBPyConnection> conn = nullptr);\n \n \tstatic unique_ptr<DuckDBPyRelation> AliasDF(const PandasDataFrame &df, const string &expr,\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/expression/pyexpression.hpp b/tools/pythonpkg/src/include/duckdb_python/expression/pyexpression.hpp\nnew file mode 100644\nindex 000000000000..6e9316c347cc\n--- /dev/null\n+++ b/tools/pythonpkg/src/include/duckdb_python/expression/pyexpression.hpp\n@@ -0,0 +1,125 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb_python/pyrelation.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb_python/pybind11/pybind_wrapper.hpp\"\n+#include \"duckdb.hpp\"\n+#include \"duckdb/common/string.hpp\"\n+#include \"duckdb/parser/parsed_expression.hpp\"\n+#include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/expression/columnref_expression.hpp\"\n+#include \"duckdb/parser/expression/function_expression.hpp\"\n+#include \"duckdb_python/python_conversion.hpp\"\n+#include \"duckdb_python/pyconnection/pyconnection.hpp\"\n+#include \"duckdb_python/pytype.hpp\"\n+#include \"duckdb/common/enums/order_type.hpp\"\n+\n+namespace duckdb {\n+\n+struct DuckDBPyExpression : public std::enable_shared_from_this<DuckDBPyExpression> {\n+public:\n+\texplicit DuckDBPyExpression(unique_ptr<ParsedExpression> expr, OrderType order_type = OrderType::ORDER_DEFAULT,\n+\t                            OrderByNullType null_order = OrderByNullType::ORDER_DEFAULT);\n+\n+public:\n+\tstd::shared_ptr<DuckDBPyExpression> shared_from_this() {\n+\t\treturn std::enable_shared_from_this<DuckDBPyExpression>::shared_from_this();\n+\t}\n+\n+public:\n+\tstatic void Initialize(py::module_ &m);\n+\n+\tstring Type() const;\n+\n+\tstring ToString() const;\n+\tvoid Print() const;\n+\tshared_ptr<DuckDBPyExpression> Add(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> Negate();\n+\tshared_ptr<DuckDBPyExpression> Subtract(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> Multiply(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> Division(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> FloorDivision(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> Modulo(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> Power(const DuckDBPyExpression &other);\n+\n+\t// Equality operations\n+\n+\tshared_ptr<DuckDBPyExpression> Equality(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> Inequality(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> GreaterThan(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> GreaterThanOrEqual(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> LessThan(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> LessThanOrEqual(const DuckDBPyExpression &other);\n+\n+\tshared_ptr<DuckDBPyExpression> SetAlias(const string &alias) const;\n+\tshared_ptr<DuckDBPyExpression> When(const DuckDBPyExpression &condition, const DuckDBPyExpression &value);\n+\tshared_ptr<DuckDBPyExpression> Else(const DuckDBPyExpression &value);\n+\tshared_ptr<DuckDBPyExpression> Cast(const DuckDBPyType &type) const;\n+\n+\t// AND, OR and NOT\n+\n+\tshared_ptr<DuckDBPyExpression> Not();\n+\tshared_ptr<DuckDBPyExpression> And(const DuckDBPyExpression &other);\n+\tshared_ptr<DuckDBPyExpression> Or(const DuckDBPyExpression &other);\n+\n+\t// IN / NOT IN\n+\n+\tshared_ptr<DuckDBPyExpression> In(const py::args &args);\n+\tshared_ptr<DuckDBPyExpression> NotIn(const py::args &args);\n+\n+\t// Order modifiers\n+\n+\tshared_ptr<DuckDBPyExpression> Ascending();\n+\tshared_ptr<DuckDBPyExpression> Descending();\n+\n+\t// Null order modifiers\n+\n+\tshared_ptr<DuckDBPyExpression> NullsFirst();\n+\tshared_ptr<DuckDBPyExpression> NullsLast();\n+\n+public:\n+\tconst ParsedExpression &GetExpression() const;\n+\tshared_ptr<DuckDBPyExpression> Copy() const;\n+\n+public:\n+\tstatic shared_ptr<DuckDBPyExpression> StarExpression(const py::list &exclude = py::none());\n+\tstatic shared_ptr<DuckDBPyExpression> ColumnExpression(const string &function_name);\n+\tstatic shared_ptr<DuckDBPyExpression> ConstantExpression(const py::object &value);\n+\tstatic shared_ptr<DuckDBPyExpression> CaseExpression(const DuckDBPyExpression &condition,\n+\t                                                     const DuckDBPyExpression &value);\n+\tstatic shared_ptr<DuckDBPyExpression> FunctionExpression(const string &function_name, const py::args &args);\n+\n+public:\n+\t// Internal functions (not exposed to Python)\n+\tstatic shared_ptr<DuckDBPyExpression> InternalFunctionExpression(const string &function_name,\n+\t                                                                 vector<unique_ptr<ParsedExpression>> children,\n+\t                                                                 bool is_operator = false);\n+\n+\tstatic shared_ptr<DuckDBPyExpression> InternalUnaryOperator(ExpressionType type, const DuckDBPyExpression &arg);\n+\tstatic shared_ptr<DuckDBPyExpression> InternalConjunction(ExpressionType type, const DuckDBPyExpression &arg,\n+\t                                                          const DuckDBPyExpression &other);\n+\tstatic shared_ptr<DuckDBPyExpression> InternalConstantExpression(Value value);\n+\tstatic shared_ptr<DuckDBPyExpression> BinaryOperator(const string &function_name, const DuckDBPyExpression &arg_one,\n+\t                                                     const DuckDBPyExpression &arg_two);\n+\tstatic shared_ptr<DuckDBPyExpression> ComparisonExpression(ExpressionType type, const DuckDBPyExpression &left,\n+\t                                                           const DuckDBPyExpression &right);\n+\tstatic shared_ptr<DuckDBPyExpression> InternalWhen(unique_ptr<duckdb::CaseExpression> expr,\n+\t                                                   const DuckDBPyExpression &condition,\n+\t                                                   const DuckDBPyExpression &value);\n+\tvoid AssertCaseExpression() const;\n+\n+private:\n+\tunique_ptr<ParsedExpression> expression;\n+\n+public:\n+\tOrderByNullType null_order = OrderByNullType::ORDER_DEFAULT;\n+\tOrderType order_type = OrderType::ORDER_DEFAULT;\n+};\n+\n+} // namespace duckdb\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp b/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp\nindex 63858bb9056b..dbc36fea5d31 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pybind11/pybind_wrapper.hpp\n@@ -14,12 +14,14 @@\n #include \"duckdb/common/vector.hpp\"\n #include \"duckdb/common/assert.hpp\"\n #include \"duckdb/common/helper.hpp\"\n+#include <memory>\n \n PYBIND11_DECLARE_HOLDER_TYPE(T, duckdb::unique_ptr<T>)\n \n namespace pybind11 {\n \n namespace detail {\n+\n template <typename Type, bool SAFE>\n struct type_caster<duckdb::vector<Type, SAFE>> : list_caster<duckdb::vector<Type, SAFE>, Type> {};\n } // namespace detail\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp b/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\nindex d36bb8bdafa2..f920f5fdeb8c 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyrelation.hpp\n@@ -67,11 +67,13 @@ struct DuckDBPyRelation {\n \n \tunique_ptr<DuckDBPyRelation> ProjectFromExpression(const string &expr);\n \tunique_ptr<DuckDBPyRelation> ProjectFromTypes(const py::object &types);\n-\tunique_ptr<DuckDBPyRelation> Project(const string &expr);\n+\tunique_ptr<DuckDBPyRelation> Project(const py::args &args);\n \n-\tunique_ptr<DuckDBPyRelation> Filter(const string &expr);\n+\tunique_ptr<DuckDBPyRelation> Filter(const py::object &expr);\n+\tunique_ptr<DuckDBPyRelation> FilterFromExpression(const string &expr);\n \tunique_ptr<DuckDBPyRelation> Limit(int64_t n, int64_t offset = 0);\n \tunique_ptr<DuckDBPyRelation> Order(const string &expr);\n+\tunique_ptr<DuckDBPyRelation> Sort(const py::args &args);\n \n \tunique_ptr<DuckDBPyRelation> Aggregate(const string &expr, const string &groups = \"\");\n \ndiff --git a/tools/pythonpkg/src/native/python_conversion.cpp b/tools/pythonpkg/src/native/python_conversion.cpp\nindex 91b063db4967..adf24e1f918e 100644\n--- a/tools/pythonpkg/src/native/python_conversion.cpp\n+++ b/tools/pythonpkg/src/native/python_conversion.cpp\n@@ -247,14 +247,10 @@ void TransformPythonUnsigned(uint64_t value, Value &res) {\n bool TrySniffPythonNumeric(Value &res, int64_t value) {\n \tif (value < (int64_t)std::numeric_limits<int32_t>::min() || value > (int64_t)std::numeric_limits<int32_t>::max()) {\n \t\tres = Value::BIGINT(value);\n-\t} else if (value < (int32_t)std::numeric_limits<int16_t>::min() ||\n-\t           value > (int32_t)std::numeric_limits<int16_t>::max()) {\n-\t\tres = Value::INTEGER(value);\n-\t} else if (value < (int16_t)std::numeric_limits<int8_t>::min() ||\n-\t           value > (int16_t)std::numeric_limits<int8_t>::max()) {\n-\t\tres = Value::SMALLINT(value);\n \t} else {\n-\t\tres = Value::TINYINT(value);\n+\t\t// To match default duckdb behavior, numeric values without a specified type should not become a smaller type\n+\t\t// than INT32\n+\t\tres = Value::INTEGER(value);\n \t}\n \treturn true;\n }\ndiff --git a/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp b/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\nindex 113344ffb9f5..29a919ccfb10 100644\n--- a/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\n+++ b/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\n@@ -317,8 +317,13 @@ unique_ptr<DuckDBPyRelation> PyConnectionWrapper::RunQuery(const string &query,\n \treturn conn->RunQuery(query, alias);\n }\n \n-unique_ptr<DuckDBPyRelation> PyConnectionWrapper::ProjectDf(const PandasDataFrame &df, const string &expr,\n+unique_ptr<DuckDBPyRelation> PyConnectionWrapper::ProjectDf(const PandasDataFrame &df, const py::object &expr,\n                                                             shared_ptr<DuckDBPyConnection> conn) {\n+\t// FIXME: if we want to support passing in DuckDBPyExpressions here\n+\t// we could also accept 'expr' as a List[DuckDBPyExpression], without changing the signature\n+\tif (!py::isinstance<py::str>(expr)) {\n+\t\tthrow InvalidInputException(\"Please provide 'expr' as a string\");\n+\t}\n \treturn conn->FromDF(df)->Project(expr);\n }\n \n@@ -329,7 +334,7 @@ unique_ptr<DuckDBPyRelation> PyConnectionWrapper::AliasDF(const PandasDataFrame\n \n unique_ptr<DuckDBPyRelation> PyConnectionWrapper::FilterDf(const PandasDataFrame &df, const string &expr,\n                                                            shared_ptr<DuckDBPyConnection> conn) {\n-\treturn conn->FromDF(df)->Filter(expr);\n+\treturn conn->FromDF(df)->FilterFromExpression(expr);\n }\n \n unique_ptr<DuckDBPyRelation> PyConnectionWrapper::LimitDF(const PandasDataFrame &df, int64_t n,\ndiff --git a/tools/pythonpkg/src/pyexpression.cpp b/tools/pythonpkg/src/pyexpression.cpp\nnew file mode 100644\nindex 000000000000..c6bf7b5f31c5\n--- /dev/null\n+++ b/tools/pythonpkg/src/pyexpression.cpp\n@@ -0,0 +1,345 @@\n+#include \"duckdb_python/expression/pyexpression.hpp\"\n+#include \"duckdb/parser/expression/comparison_expression.hpp\"\n+#include \"duckdb/parser/expression/star_expression.hpp\"\n+#include \"duckdb/parser/expression/case_expression.hpp\"\n+#include \"duckdb/parser/expression/cast_expression.hpp\"\n+#include \"duckdb/parser/expression/conjunction_expression.hpp\"\n+#include \"duckdb/parser/expression/operator_expression.hpp\"\n+\n+namespace duckdb {\n+\n+DuckDBPyExpression::DuckDBPyExpression(unique_ptr<ParsedExpression> expr_p, OrderType order_type,\n+                                       OrderByNullType null_order)\n+    : expression(std::move(expr_p)), order_type(order_type), null_order(null_order) {\n+\tif (!expression) {\n+\t\tthrow InternalException(\"DuckDBPyExpression created without an expression\");\n+\t}\n+}\n+\n+string DuckDBPyExpression::Type() const {\n+\treturn ExpressionTypeToString(expression->type);\n+}\n+\n+string DuckDBPyExpression::ToString() const {\n+\treturn expression->ToString();\n+}\n+\n+void DuckDBPyExpression::Print() const {\n+\tPrinter::Print(expression->ToString());\n+}\n+\n+const ParsedExpression &DuckDBPyExpression::GetExpression() const {\n+\treturn *expression;\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Copy() const {\n+\tauto expr = GetExpression().Copy();\n+\treturn make_shared<DuckDBPyExpression>(std::move(expr), order_type, null_order);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::SetAlias(const string &name) const {\n+\tauto copied_expression = GetExpression().Copy();\n+\tcopied_expression->alias = name;\n+\treturn make_shared<DuckDBPyExpression>(std::move(copied_expression));\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Cast(const DuckDBPyType &type) const {\n+\tauto copied_expression = GetExpression().Copy();\n+\tauto case_expr = make_uniq<duckdb::CastExpression>(type.Type(), std::move(copied_expression));\n+\treturn make_shared<DuckDBPyExpression>(std::move(case_expr));\n+}\n+\n+// Case Expression modifiers\n+\n+void DuckDBPyExpression::AssertCaseExpression() const {\n+\tif (expression->type != ExpressionType::CASE_EXPR) {\n+\t\tthrow py::value_error(\"This method can only be used on a Expression resulting from CaseExpression or When\");\n+\t}\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::InternalWhen(unique_ptr<duckdb::CaseExpression> expr,\n+                                                                const DuckDBPyExpression &condition,\n+                                                                const DuckDBPyExpression &value) {\n+\tCaseCheck check;\n+\tcheck.when_expr = condition.GetExpression().Copy();\n+\tcheck.then_expr = value.GetExpression().Copy();\n+\texpr->case_checks.push_back(std::move(check));\n+\treturn make_shared<DuckDBPyExpression>(std::move(expr));\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::When(const DuckDBPyExpression &condition,\n+                                                        const DuckDBPyExpression &value) {\n+\tAssertCaseExpression();\n+\tauto expr_p = expression->Copy();\n+\tauto expr = unique_ptr_cast<ParsedExpression, duckdb::CaseExpression>(std::move(expr_p));\n+\n+\treturn InternalWhen(std::move(expr), condition, value);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Else(const DuckDBPyExpression &value) {\n+\tAssertCaseExpression();\n+\tauto expr_p = expression->Copy();\n+\tauto expr = unique_ptr_cast<ParsedExpression, duckdb::CaseExpression>(std::move(expr_p));\n+\n+\texpr->else_expr = value.GetExpression().Copy();\n+\treturn make_shared<DuckDBPyExpression>(std::move(expr));\n+}\n+\n+// Binary operators\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Add(const DuckDBPyExpression &other) {\n+\treturn DuckDBPyExpression::BinaryOperator(\"+\", *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Subtract(const DuckDBPyExpression &other) {\n+\treturn DuckDBPyExpression::BinaryOperator(\"-\", *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Multiply(const DuckDBPyExpression &other) {\n+\treturn DuckDBPyExpression::BinaryOperator(\"*\", *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Division(const DuckDBPyExpression &other) {\n+\treturn DuckDBPyExpression::BinaryOperator(\"/\", *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::FloorDivision(const DuckDBPyExpression &other) {\n+\treturn DuckDBPyExpression::BinaryOperator(\"//\", *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Modulo(const DuckDBPyExpression &other) {\n+\treturn DuckDBPyExpression::BinaryOperator(\"%\", *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Power(const DuckDBPyExpression &other) {\n+\treturn DuckDBPyExpression::BinaryOperator(\"**\", *this, other);\n+}\n+\n+// Comparison expressions\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Equality(const DuckDBPyExpression &other) {\n+\treturn ComparisonExpression(ExpressionType::COMPARE_EQUAL, *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Inequality(const DuckDBPyExpression &other) {\n+\treturn ComparisonExpression(ExpressionType::COMPARE_NOTEQUAL, *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::GreaterThan(const DuckDBPyExpression &other) {\n+\treturn ComparisonExpression(ExpressionType::COMPARE_GREATERTHAN, *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::GreaterThanOrEqual(const DuckDBPyExpression &other) {\n+\treturn ComparisonExpression(ExpressionType::COMPARE_GREATERTHANOREQUALTO, *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::LessThan(const DuckDBPyExpression &other) {\n+\treturn ComparisonExpression(ExpressionType::COMPARE_LESSTHAN, *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::LessThanOrEqual(const DuckDBPyExpression &other) {\n+\treturn ComparisonExpression(ExpressionType::COMPARE_LESSTHANOREQUALTO, *this, other);\n+}\n+\n+// AND, OR and NOT\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Not() {\n+\treturn DuckDBPyExpression::InternalUnaryOperator(ExpressionType::OPERATOR_NOT, *this);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::And(const DuckDBPyExpression &other) {\n+\treturn DuckDBPyExpression::InternalConjunction(ExpressionType::CONJUNCTION_AND, *this, other);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Or(const DuckDBPyExpression &other) {\n+\treturn DuckDBPyExpression::InternalConjunction(ExpressionType::CONJUNCTION_OR, *this, other);\n+}\n+\n+// IN\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::In(const py::args &args) {\n+\tvector<unique_ptr<ParsedExpression>> expressions;\n+\texpressions.reserve(args.size() + 1);\n+\texpressions.push_back(GetExpression().Copy());\n+\n+\tfor (auto arg : args) {\n+\t\tshared_ptr<DuckDBPyExpression> py_expr;\n+\t\tif (!py::try_cast<shared_ptr<DuckDBPyExpression>>(arg, py_expr)) {\n+\t\t\tthrow InvalidInputException(\"Please provide arguments of type Expression!\");\n+\t\t}\n+\t\tauto expr = py_expr->GetExpression().Copy();\n+\t\texpressions.push_back(std::move(expr));\n+\t}\n+\tauto operator_expr = make_uniq<OperatorExpression>(ExpressionType::COMPARE_IN, std::move(expressions));\n+\treturn make_shared<DuckDBPyExpression>(std::move(operator_expr));\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::NotIn(const py::args &args) {\n+\tauto in_expr = In(args);\n+\treturn in_expr->Not();\n+}\n+\n+// Order modifiers\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Ascending() {\n+\tauto py_expr = Copy();\n+\tpy_expr->order_type = OrderType::ASCENDING;\n+\treturn py_expr;\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Descending() {\n+\tauto py_expr = Copy();\n+\tpy_expr->order_type = OrderType::DESCENDING;\n+\treturn py_expr;\n+}\n+\n+// Null order modifiers\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::NullsFirst() {\n+\tauto py_expr = Copy();\n+\tpy_expr->null_order = OrderByNullType::NULLS_FIRST;\n+\treturn py_expr;\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::NullsLast() {\n+\tauto py_expr = Copy();\n+\tpy_expr->null_order = OrderByNullType::NULLS_LAST;\n+\treturn py_expr;\n+}\n+\n+// Unary operators\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::Negate() {\n+\tvector<unique_ptr<ParsedExpression>> children;\n+\tchildren.push_back(GetExpression().Copy());\n+\treturn DuckDBPyExpression::InternalFunctionExpression(\"-\", std::move(children), true);\n+}\n+\n+// Static creation methods\n+\n+static void PopulateExcludeList(case_insensitive_set_t &exclude, const py::list &list) {\n+\tfor (auto item : list) {\n+\t\tif (py::isinstance<py::str>(item)) {\n+\t\t\texclude.insert(std::string(py::str(item)));\n+\t\t\tcontinue;\n+\t\t}\n+\t\tshared_ptr<DuckDBPyExpression> expr;\n+\t\tif (!py::try_cast(item, expr)) {\n+\t\t\tthrow py::value_error(\"Items in the exclude list should either be 'str' or Expression\");\n+\t\t}\n+\t\tif (expr->GetExpression().type != ExpressionType::COLUMN_REF) {\n+\t\t\tthrow py::value_error(\"Only ColumnExpressions are accepted Expression types here\");\n+\t\t}\n+\t\tauto &column = expr->GetExpression().Cast<ColumnRefExpression>();\n+\t\texclude.insert(column.GetColumnName());\n+\t}\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::StarExpression(const py::list &exclude_list) {\n+\tcase_insensitive_set_t exclude;\n+\tauto star = make_uniq<duckdb::StarExpression>();\n+\tPopulateExcludeList(star->exclude_list, exclude_list);\n+\treturn make_shared<DuckDBPyExpression>(std::move(star));\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::ColumnExpression(const string &column_name) {\n+\tif (column_name == \"*\") {\n+\t\treturn StarExpression();\n+\t}\n+\n+\tauto qualified_name = QualifiedName::Parse(column_name);\n+\tvector<string> column_names;\n+\tif (!qualified_name.catalog.empty()) {\n+\t\tcolumn_names.push_back(qualified_name.catalog);\n+\t}\n+\tif (!qualified_name.schema.empty()) {\n+\t\tcolumn_names.push_back(qualified_name.schema);\n+\t}\n+\tcolumn_names.push_back(qualified_name.name);\n+\n+\treturn make_shared<DuckDBPyExpression>(make_uniq<duckdb::ColumnRefExpression>(std::move(column_names)));\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::ConstantExpression(const py::object &value) {\n+\tauto val = TransformPythonValue(value);\n+\treturn InternalConstantExpression(std::move(val));\n+}\n+\n+// Private methods\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::BinaryOperator(const string &function_name,\n+                                                                  const DuckDBPyExpression &arg_one,\n+                                                                  const DuckDBPyExpression &arg_two) {\n+\tvector<unique_ptr<ParsedExpression>> children;\n+\n+\tchildren.push_back(arg_one.GetExpression().Copy());\n+\tchildren.push_back(arg_two.GetExpression().Copy());\n+\treturn InternalFunctionExpression(function_name, std::move(children), true);\n+}\n+\n+shared_ptr<DuckDBPyExpression>\n+DuckDBPyExpression::InternalFunctionExpression(const string &function_name,\n+                                               vector<unique_ptr<ParsedExpression>> children, bool is_operator) {\n+\tauto function_expression =\n+\t    make_uniq<duckdb::FunctionExpression>(function_name, std::move(children), nullptr, nullptr, false, is_operator);\n+\treturn make_shared<DuckDBPyExpression>(std::move(function_expression));\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::InternalUnaryOperator(ExpressionType type,\n+                                                                         const DuckDBPyExpression &arg) {\n+\tauto expr = arg.GetExpression().Copy();\n+\tauto operator_expression = make_uniq<OperatorExpression>(type, std::move(expr));\n+\treturn make_shared<DuckDBPyExpression>(std::move(operator_expression));\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::InternalConjunction(ExpressionType type,\n+                                                                       const DuckDBPyExpression &arg,\n+                                                                       const DuckDBPyExpression &other) {\n+\tvector<unique_ptr<ParsedExpression>> children;\n+\tchildren.reserve(2);\n+\tchildren.push_back(arg.GetExpression().Copy());\n+\tchildren.push_back(other.GetExpression().Copy());\n+\n+\tauto operator_expression = make_uniq<ConjunctionExpression>(type, std::move(children));\n+\treturn make_shared<DuckDBPyExpression>(std::move(operator_expression));\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::InternalConstantExpression(Value val) {\n+\treturn make_shared<DuckDBPyExpression>(make_uniq<duckdb::ConstantExpression>(std::move(val)));\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::ComparisonExpression(ExpressionType type,\n+                                                                        const DuckDBPyExpression &left_p,\n+                                                                        const DuckDBPyExpression &right_p) {\n+\tauto left = left_p.GetExpression().Copy();\n+\tauto right = right_p.GetExpression().Copy();\n+\treturn make_shared<DuckDBPyExpression>(\n+\t    make_uniq<duckdb::ComparisonExpression>(type, std::move(left), std::move(right)));\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::CaseExpression(const DuckDBPyExpression &condition,\n+                                                                  const DuckDBPyExpression &value) {\n+\tauto expr = make_uniq<duckdb::CaseExpression>();\n+\tauto case_expr = InternalWhen(std::move(expr), condition, value);\n+\n+\t// Add NULL as default Else expression\n+\tauto &internal_expression = reinterpret_cast<duckdb::CaseExpression &>(*case_expr->expression);\n+\tinternal_expression.else_expr = make_uniq<duckdb::ConstantExpression>(Value(LogicalTypeId::SQLNULL));\n+\treturn std::move(case_expr);\n+}\n+\n+shared_ptr<DuckDBPyExpression> DuckDBPyExpression::FunctionExpression(const string &function_name,\n+                                                                      const py::args &args) {\n+\tvector<unique_ptr<ParsedExpression>> expressions;\n+\tfor (auto arg : args) {\n+\t\tshared_ptr<DuckDBPyExpression> py_expr;\n+\t\tif (!py::try_cast<shared_ptr<DuckDBPyExpression>>(arg, py_expr)) {\n+\t\t\tthrow InvalidInputException(\"Please provide arguments of type Expression!\");\n+\t\t}\n+\t\tauto expr = py_expr->GetExpression().Copy();\n+\t\texpressions.push_back(std::move(expr));\n+\t}\n+\treturn InternalFunctionExpression(function_name, std::move(expressions));\n+}\n+\n+} // namespace duckdb\ndiff --git a/tools/pythonpkg/src/pyexpression/CMakeLists.txt b/tools/pythonpkg/src/pyexpression/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..e8e11e16c73e\n--- /dev/null\n+++ b/tools/pythonpkg/src/pyexpression/CMakeLists.txt\n@@ -0,0 +1,10 @@\n+# this is used for clang-tidy checks\n+include_directories(${pybind11_INCLUDE_DIR})\n+include_directories(${PYTHON_INCLUDE_DIRS})\n+find_package(pybind11 REQUIRED)\n+\n+add_library(python_expression OBJECT initialize.cpp)\n+\n+set(ALL_OBJECT_FILES\n+    ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:python_expression>\n+    PARENT_SCOPE)\ndiff --git a/tools/pythonpkg/src/pyexpression/initialize.cpp b/tools/pythonpkg/src/pyexpression/initialize.cpp\nnew file mode 100644\nindex 000000000000..e61a94c1653e\n--- /dev/null\n+++ b/tools/pythonpkg/src/pyexpression/initialize.cpp\n@@ -0,0 +1,246 @@\n+#include \"duckdb_python/pybind11/pybind_wrapper.hpp\"\n+#include \"duckdb_python/expression/pyexpression.hpp\"\n+#include \"duckdb/common/helper.hpp\"\n+#include \"duckdb/common/vector.hpp\"\n+#include \"duckdb_python/python_conversion.hpp\"\n+\n+namespace duckdb {\n+\n+void InitializeStaticMethods(py::module_ &m) {\n+\tconst char *docs;\n+\n+\t// Constant Expression\n+\tdocs = \"Create a constant expression from the provided value\";\n+\tm.def(\"ConstantExpression\", &DuckDBPyExpression::ConstantExpression, py::arg(\"value\"), docs);\n+\n+\t// ColumnRef Expression\n+\tdocs = \"Create a column reference from the provided column name\";\n+\tm.def(\"ColumnExpression\", &DuckDBPyExpression::ColumnExpression, py::arg(\"name\"), docs);\n+\n+\t// Case Expression\n+\tdocs = \"\";\n+\tm.def(\"CaseExpression\", &DuckDBPyExpression::CaseExpression, py::arg(\"condition\"), py::arg(\"value\"), docs);\n+\n+\t// Star Expression\n+\tdocs = \"\";\n+\tm.def(\"StarExpression\", &DuckDBPyExpression::StarExpression, py::kw_only(), py::arg(\"exclude\") = py::list(), docs);\n+\tm.def(\n+\t    \"StarExpression\", []() { return DuckDBPyExpression::StarExpression(); }, docs);\n+\n+\t// Function Expression\n+\tdocs = \"\";\n+\tm.def(\"FunctionExpression\", &DuckDBPyExpression::FunctionExpression, py::arg(\"function_name\"), docs);\n+}\n+\n+static void InitializeDunderMethods(py::class_<DuckDBPyExpression, shared_ptr<DuckDBPyExpression>> &m) {\n+\tconst char *docs;\n+\n+\tdocs = R\"(\n+\t\tAdd two expressions.\n+\n+\t\tParameters:\n+\t\t\texpr: The expression to add together with\n+\n+\t\tReturns:\n+\t\t\tFunctionExpression: A '+' on the two input expressions.\n+\t)\";\n+\n+\tm.def(\"__add__\", &DuckDBPyExpression::Add, py::arg(\"expr\"), docs);\n+\tm.def(\"__radd__\", &DuckDBPyExpression::Add, py::arg(\"expr\"), docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__neg__\", &DuckDBPyExpression::Negate, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__sub__\", &DuckDBPyExpression::Subtract, docs);\n+\tm.def(\"__rsub__\", &DuckDBPyExpression::Subtract, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__mul__\", &DuckDBPyExpression::Multiply, docs);\n+\tm.def(\"__rmul__\", &DuckDBPyExpression::Multiply, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__div__\", &DuckDBPyExpression::Division, docs);\n+\tm.def(\"__rdiv__\", &DuckDBPyExpression::Division, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__truediv__\", &DuckDBPyExpression::Division, docs);\n+\tm.def(\"__rtruediv__\", &DuckDBPyExpression::Division, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__floordiv__\", &DuckDBPyExpression::FloorDivision, docs);\n+\tm.def(\"__rfloordiv__\", &DuckDBPyExpression::FloorDivision, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__mod__\", &DuckDBPyExpression::Modulo, docs);\n+\tm.def(\"__rmod__\", &DuckDBPyExpression::Modulo, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__pow__\", &DuckDBPyExpression::Power, docs);\n+\tm.def(\"__rpow__\", &DuckDBPyExpression::Power, docs);\n+\n+\tdocs = R\"(\n+\t\tCreate an equality expression between two expressions\n+\t)\";\n+\tm.def(\"__eq__\", &DuckDBPyExpression::Equality, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__ne__\", &DuckDBPyExpression::Inequality, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__gt__\", &DuckDBPyExpression::GreaterThan, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__ge__\", &DuckDBPyExpression::GreaterThanOrEqual, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__lt__\", &DuckDBPyExpression::LessThan, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__le__\", &DuckDBPyExpression::LessThanOrEqual, docs);\n+\n+\t// AND, NOT and OR\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__and__\", &DuckDBPyExpression::And, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__or__\", &DuckDBPyExpression::Or, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__invert__\", &DuckDBPyExpression::Not, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__rand__\", &DuckDBPyExpression::And, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs\n+\t)\";\n+\tm.def(\"__ror__\", &DuckDBPyExpression::Or, docs);\n+}\n+\n+static void InitializeImplicitConversion(py::class_<DuckDBPyExpression, shared_ptr<DuckDBPyExpression>> &m) {\n+\tm.def(py::init<>([](const string &name) { return DuckDBPyExpression::ColumnExpression(name); }));\n+\tm.def(py::init<>([](const py::object &obj) {\n+\t\tauto val = TransformPythonValue(obj);\n+\t\treturn DuckDBPyExpression::InternalConstantExpression(std::move(val));\n+\t}));\n+\tpy::implicitly_convertible<py::str, DuckDBPyExpression>();\n+\tpy::implicitly_convertible<py::object, DuckDBPyExpression>();\n+}\n+\n+void DuckDBPyExpression::Initialize(py::module_ &m) {\n+\tauto expression =\n+\t    py::class_<DuckDBPyExpression, shared_ptr<DuckDBPyExpression>>(m, \"Expression\", py::module_local());\n+\n+\tInitializeStaticMethods(m);\n+\tInitializeDunderMethods(expression);\n+\tInitializeImplicitConversion(expression);\n+\n+\tconst char *docs;\n+\n+\tdocs = R\"(\n+\t\tPrint the stringified version of the expression.\n+\t)\";\n+\texpression.def(\"show\", &DuckDBPyExpression::Print, docs);\n+\n+\tdocs = R\"(\n+\t\tSet the order by modifier to ASCENDING.\n+\t)\";\n+\texpression.def(\"asc\", &DuckDBPyExpression::Ascending, docs);\n+\n+\tdocs = R\"(\n+\t\tSet the order by modifier to DESCENDING.\n+\t)\";\n+\texpression.def(\"desc\", &DuckDBPyExpression::Descending, docs);\n+\n+\tdocs = R\"(\n+\t\tSet the NULL order by modifier to NULLS FIRST.\n+\t)\";\n+\texpression.def(\"nulls_first\", &DuckDBPyExpression::NullsFirst, docs);\n+\n+\tdocs = R\"(\n+\t\tSet the NULL order by modifier to NULLS LAST.\n+\t)\";\n+\texpression.def(\"nulls_last\", &DuckDBPyExpression::NullsLast, docs);\n+\n+\tdocs = R\"(\n+\t\tReturn a IN expression comparing self to the input arguments.\n+\n+\t\tReturns:\n+\t\t\tDuckDBPyExpression: The compare IN expression\n+\t)\";\n+\texpression.def(\"isin\", &DuckDBPyExpression::In, docs);\n+\n+\tdocs = R\"(\n+\t\tReturn a NOT IN expression comparing self to the input arguments.\n+\n+\t\tReturns:\n+\t\t\tDuckDBPyExpression: The compare NOT IN expression\n+\t)\";\n+\texpression.def(\"isnotin\", &DuckDBPyExpression::NotIn, docs);\n+\n+\tdocs = R\"(\n+\t\tReturn the stringified version of the expression.\n+\n+\t\tReturns:\n+\t\t\tstr: The string representation.\n+\t)\";\n+\texpression.def(\"__repr__\", &DuckDBPyExpression::ToString, docs);\n+\n+\tdocs = R\"(\n+\t\tCreate a copy of this expression with the given alias.\n+\t)\";\n+\texpression.def(\"alias\", &DuckDBPyExpression::SetAlias, docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs.\n+\t)\";\n+\texpression.def(\"when\", &DuckDBPyExpression::When, py::arg(\"condition\"), py::arg(\"value\"), docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs.\n+\t)\";\n+\texpression.def(\"otherwise\", &DuckDBPyExpression::Else, py::arg(\"value\"), docs);\n+\n+\tdocs = R\"(\n+\t\tTODO: add docs.\n+\t)\";\n+\texpression.def(\"cast\", &DuckDBPyExpression::Cast, py::arg(\"type\"), docs);\n+}\n+\n+} // namespace duckdb\ndiff --git a/tools/pythonpkg/src/pyrelation.cpp b/tools/pythonpkg/src/pyrelation.cpp\nindex be99986e0c26..d3a20406f28b 100644\n--- a/tools/pythonpkg/src/pyrelation.cpp\n+++ b/tools/pythonpkg/src/pyrelation.cpp\n@@ -1,3 +1,4 @@\n+#include \"duckdb_python/pybind11/pybind_wrapper.hpp\"\n #include \"duckdb_python/pyrelation.hpp\"\n #include \"duckdb_python/pyconnection/pyconnection.hpp\"\n #include \"duckdb_python/pytype.hpp\"\n@@ -17,6 +18,7 @@\n #include \"duckdb/catalog/default/default_types.hpp\"\n #include \"duckdb/main/relation/value_relation.hpp\"\n #include \"duckdb/main/relation/filter_relation.hpp\"\n+#include \"duckdb_python/expression/pyexpression.hpp\"\n \n namespace duckdb {\n \n@@ -47,11 +49,31 @@ unique_ptr<DuckDBPyRelation> DuckDBPyRelation::ProjectFromExpression(const strin\n \treturn projected_relation;\n }\n \n-unique_ptr<DuckDBPyRelation> DuckDBPyRelation::Project(const string &expr) {\n+unique_ptr<DuckDBPyRelation> DuckDBPyRelation::Project(const py::args &args) {\n \tif (!rel) {\n \t\treturn nullptr;\n \t}\n-\treturn ProjectFromExpression(expr);\n+\tauto arg_count = args.size();\n+\tif (arg_count == 0) {\n+\t\treturn nullptr;\n+\t}\n+\tpy::handle first_arg = args[0];\n+\tif (arg_count == 1 && py::isinstance<py::str>(first_arg)) {\n+\t\tstring expr_string = py::str(first_arg);\n+\t\treturn ProjectFromExpression(expr_string);\n+\t} else {\n+\t\tvector<unique_ptr<ParsedExpression>> expressions;\n+\t\tfor (auto arg : args) {\n+\t\t\tshared_ptr<DuckDBPyExpression> py_expr;\n+\t\t\tif (!py::try_cast<shared_ptr<DuckDBPyExpression>>(arg, py_expr)) {\n+\t\t\t\tthrow InvalidInputException(\"Please provide arguments of type Expression!\");\n+\t\t\t}\n+\t\t\tauto expr = py_expr->GetExpression().Copy();\n+\t\t\texpressions.push_back(std::move(expr));\n+\t\t}\n+\t\tvector<string> empty_aliases;\n+\t\treturn make_uniq<DuckDBPyRelation>(rel->Project(std::move(expressions), empty_aliases));\n+\t}\n }\n \n unique_ptr<DuckDBPyRelation> DuckDBPyRelation::ProjectFromTypes(const py::object &obj) {\n@@ -115,7 +137,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyRelation::EmptyResult(const std::shared_ptr\n \tauto values_relation =\n \t    make_uniq<DuckDBPyRelation>(make_shared<ValueRelation>(context, single_row, std::move(names)));\n \t// Add a filter on an impossible condition\n-\treturn values_relation->Filter(\"true = false\");\n+\treturn values_relation->FilterFromExpression(\"true = false\");\n }\n \n unique_ptr<DuckDBPyRelation> DuckDBPyRelation::SetAlias(const string &expr) {\n@@ -126,7 +148,20 @@ py::str DuckDBPyRelation::GetAlias() {\n \treturn py::str(string(rel->GetAlias()));\n }\n \n-unique_ptr<DuckDBPyRelation> DuckDBPyRelation::Filter(const string &expr) {\n+unique_ptr<DuckDBPyRelation> DuckDBPyRelation::Filter(const py::object &expr) {\n+\tif (py::isinstance<py::str>(expr)) {\n+\t\tstring expression = py::cast<py::str>(expr);\n+\t\treturn FilterFromExpression(expression);\n+\t}\n+\tshared_ptr<DuckDBPyExpression> expression;\n+\tif (!py::try_cast(expr, expression)) {\n+\t\tthrow InvalidInputException(\"Please provide either a string or a DuckDBPyExpression object to 'filter'\");\n+\t}\n+\tauto expr_p = expression->GetExpression().Copy();\n+\treturn make_uniq<DuckDBPyRelation>(rel->Filter(std::move(expr_p)));\n+}\n+\n+unique_ptr<DuckDBPyRelation> DuckDBPyRelation::FilterFromExpression(const string &expr) {\n \treturn make_uniq<DuckDBPyRelation>(rel->Filter(expr));\n }\n \n@@ -138,6 +173,25 @@ unique_ptr<DuckDBPyRelation> DuckDBPyRelation::Order(const string &expr) {\n \treturn make_uniq<DuckDBPyRelation>(rel->Order(expr));\n }\n \n+unique_ptr<DuckDBPyRelation> DuckDBPyRelation::Sort(const py::args &args) {\n+\tvector<OrderByNode> order_nodes;\n+\torder_nodes.reserve(args.size());\n+\n+\tfor (auto arg : args) {\n+\t\tshared_ptr<DuckDBPyExpression> py_expr;\n+\t\tif (!py::try_cast<shared_ptr<DuckDBPyExpression>>(arg, py_expr)) {\n+\t\t\tstring actual_type = py::str(arg.get_type());\n+\t\t\tthrow InvalidInputException(\"Expected argument of type Expression, received '%s' instead\", actual_type);\n+\t\t}\n+\t\tauto expr = py_expr->GetExpression().Copy();\n+\t\torder_nodes.emplace_back(py_expr->order_type, py_expr->null_order, std::move(expr));\n+\t}\n+\tif (order_nodes.empty()) {\n+\t\tthrow InvalidInputException(\"Please provide at least one expression to sort on\");\n+\t}\n+\treturn make_uniq<DuckDBPyRelation>(rel->Order(std::move(order_nodes)));\n+}\n+\n unique_ptr<DuckDBPyRelation> DuckDBPyRelation::Aggregate(const string &expr, const string &groups) {\n \tif (!groups.empty()) {\n \t\treturn make_uniq<DuckDBPyRelation>(rel->Aggregate(expr, groups));\ndiff --git a/tools/pythonpkg/src/pyrelation/initialize.cpp b/tools/pythonpkg/src/pyrelation/initialize.cpp\nindex 6ded7e192908..6dfcb5336254 100644\n--- a/tools/pythonpkg/src/pyrelation/initialize.cpp\n+++ b/tools/pythonpkg/src/pyrelation/initialize.cpp\n@@ -222,16 +222,16 @@ void DuckDBPyRelation::Initialize(py::handle &m) {\n \t                    \"Get a projection relation created from this relation, on the provided column name\",\n \t                    py::arg(\"name\"));\n \n-\trelation_module\n-\t    .def(\"filter\", &DuckDBPyRelation::Filter, \"Filter the relation object by the filter in filter_expr\",\n-\t         py::arg(\"filter_expr\"))\n-\t    .def(\"project\", &DuckDBPyRelation::Project, \"Project the relation object by the projection in project_expr\",\n-\t         py::arg(\"project_expr\"));\n+\trelation_module.def(\"filter\", &DuckDBPyRelation::Filter, \"Filter the relation object by the filter in filter_expr\",\n+\t                    py::arg(\"filter_expr\"));\n+\tDefineMethod({\"select\", \"project\"}, relation_module, &DuckDBPyRelation::Project,\n+\t             \"Project the relation object by the projection in project_expr\");\n \tDefineMethod({\"select_types\", \"select_dtypes\"}, relation_module, &DuckDBPyRelation::ProjectFromTypes,\n \t             \"Select columns from the relation, by filtering based on type(s)\", py::arg(\"types\"));\n \trelation_module\n \t    .def(\"set_alias\", &DuckDBPyRelation::SetAlias, \"Rename the relation object to new alias\", py::arg(\"alias\"))\n \t    .def(\"order\", &DuckDBPyRelation::Order, \"Reorder the relation object by order_expr\", py::arg(\"order_expr\"))\n+\t    .def(\"sort\", &DuckDBPyRelation::Sort, \"Reorder the relation object by the provided expressions\")\n \t    .def(\"aggregate\", &DuckDBPyRelation::Aggregate,\n \t         \"Compute the aggregate aggr_expr by the optional groups group_expr on the relation\", py::arg(\"aggr_expr\"),\n \t         py::arg(\"group_expr\") = \"\")\n",
  "test_patch": "diff --git a/test/api/test_relation_api.cpp b/test/api/test_relation_api.cpp\nindex fa2fd5505b5a..4f51635198dd 100644\n--- a/test/api/test_relation_api.cpp\n+++ b/test/api/test_relation_api.cpp\n@@ -417,6 +417,13 @@ TEST_CASE(\"Test view creation of relations\", \"[relation_api]\") {\n \tREQUIRE_NOTHROW(result = tbl->Query(\"test\", \"SELECT * FROM test\"));\n \tREQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));\n \n+\tduckdb::vector<duckdb::unique_ptr<ParsedExpression>> expressions;\n+\texpressions.push_back(duckdb::make_uniq<duckdb::ColumnRefExpression>(\"i\"));\n+\tduckdb::vector<duckdb::string> aliases;\n+\taliases.push_back(\"j\");\n+\n+\tREQUIRE_NOTHROW(result = tbl->Project(std::move(expressions), aliases)->Query(\"test\", \"SELECT * FROM test\"));\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));\n \t// add a projection\n \tREQUIRE_NOTHROW(result = tbl->Project(\"i + 1\")->Query(\"test\", \"SELECT * FROM test\"));\n \tREQUIRE(CHECK_COLUMN(result, 0, {2, 3, 4}));\ndiff --git a/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py b/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py\nindex d42cddc5bf28..79c8b1f7dacb 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_df_object_resolution.py\n@@ -40,7 +40,7 @@ def test_integers(self, pandas):\n         data = [5, 0, 3]\n         df_in = create_generic_dataframe(data, pandas)\n         # These are float64 because pandas would force these to be float64 even if we set them to int8, int16, int32, int64 respectively\n-        df_expected_res = pandas.DataFrame({'0': pandas.Series(data=data, dtype='int8')})\n+        df_expected_res = pandas.DataFrame({'0': pandas.Series(data=data, dtype='int32')})\n         df_out = duckdb.query_df(df_in, \"data\", \"SELECT * FROM data\").df()\n         print(df_out)\n         pandas.testing.assert_frame_equal(df_expected_res, df_out)\ndiff --git a/tools/pythonpkg/tests/fast/test_expression.py b/tools/pythonpkg/tests/fast/test_expression.py\nnew file mode 100644\nindex 000000000000..9a00bc3afbab\n--- /dev/null\n+++ b/tools/pythonpkg/tests/fast/test_expression.py\n@@ -0,0 +1,699 @@\n+import duckdb\n+import pytest\n+from duckdb.typing import INTEGER, VARCHAR, TIMESTAMP\n+from duckdb import Expression, ConstantExpression, ColumnExpression, StarExpression, FunctionExpression, CaseExpression\n+from pyduckdb.value.constant import Value, IntegerValue\n+import datetime\n+\n+\n+@pytest.fixture(scope='function')\n+def filter_rel():\n+    con = duckdb.connect()\n+    rel = con.sql(\n+        \"\"\"\n+        select * from (VALUES\n+            (1, 'a'),\n+            (2, 'b'),\n+            (1, 'b'),\n+            (3, 'c'),\n+            (4, 'a')\n+        ) tbl(a, b)\n+    \"\"\"\n+    )\n+    yield rel\n+\n+\n+class TestExpression(object):\n+    def test_constant_expression(self):\n+        con = duckdb.connect()\n+\n+        val = Value(5, INTEGER)\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                1 as a,\n+                2 as b,\n+                3 as c\n+        \"\"\"\n+        )\n+\n+        constant = ConstantExpression(val)\n+\n+        rel = rel.select(constant)\n+        res = rel.fetchall()\n+        assert res == [(5,)]\n+\n+    def test_column_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                1 as a,\n+                2 as b,\n+                3 as c\n+        \"\"\"\n+        )\n+        column = ColumnExpression('a')\n+        rel2 = rel.select(column)\n+        res = rel2.fetchall()\n+        assert res == [(1,)]\n+\n+        column = ColumnExpression('d')\n+        with pytest.raises(duckdb.BinderException, match='Referenced column \"d\" not found'):\n+            rel2 = rel.select(column)\n+\n+    def test_column_expression_explain(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select 'unused'\n+        \"\"\"\n+        )\n+        rel = rel.select(\n+            ConstantExpression(\"a\").alias('c0'),\n+            ConstantExpression(42).alias('c1'),\n+            ConstantExpression(None).alias('c2'),\n+        )\n+        res = rel.explain()\n+        assert 'c0' in res\n+        assert 'c1' in res\n+        # 'c2' is not in the explain result because it shows NULL instead\n+        assert 'NULL' in res\n+        res = rel.fetchall()\n+        assert res == [('a', 42, None)]\n+\n+    def test_column_expression_table(self):\n+        con = duckdb.connect()\n+\n+        con.execute(\n+            \"\"\"\n+            CREATE TABLE tbl as FROM (\n+                VALUES\n+                    ('a', 'b', 'c'),\n+                    ('d', 'e', 'f'),\n+                    ('g', 'h', 'i')\n+            ) t(c0, c1, c2)\n+        \"\"\"\n+        )\n+\n+        rel = con.table('tbl')\n+        rel2 = rel.select('c0', 'c1', 'c2')\n+        res = rel2.fetchall()\n+        assert res == [('a', 'b', 'c'), ('d', 'e', 'f'), ('g', 'h', 'i')]\n+\n+    def test_column_expression_view(self):\n+        con = duckdb.connect()\n+        con.execute(\n+            \"\"\"\n+            CREATE TABLE tbl as FROM (\n+                VALUES\n+                    ('a', 'b', 'c'),\n+                    ('d', 'e', 'f'),\n+                    ('g', 'h', 'i')\n+            ) t(c0, c1, c2)\n+        \"\"\"\n+        )\n+        con.execute(\n+            \"\"\"\n+            CREATE VIEW v1 as select c0 as c3, c2 as c4 from tbl;\n+        \"\"\"\n+        )\n+        rel = con.view('v1')\n+        rel2 = rel.select('c3', 'c4')\n+        res = rel2.fetchall()\n+        assert res == [('a', 'c'), ('d', 'f'), ('g', 'i')]\n+\n+    def test_column_expression_replacement_scan(self):\n+        con = duckdb.connect()\n+\n+        pd = pytest.importorskip(\"pandas\")\n+        df = pd.DataFrame({'a': [42, 43, 0], 'b': [True, False, True], 'c': [23.123, 623.213, 0.30234]})\n+        rel = con.sql(\"select * from df\")\n+        rel2 = rel.select('a', 'b')\n+        res = rel2.fetchall()\n+        assert res == [(42, True), (43, False), (0, True)]\n+\n+    def test_add_operator(self):\n+        con = duckdb.connect()\n+\n+        val = Value(5, INTEGER)\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                1 as a,\n+                2 as b,\n+                3 as c\n+        \"\"\"\n+        )\n+\n+        constant = ConstantExpression(val)\n+        col = ColumnExpression('b')\n+        expr = col + constant\n+\n+        rel = rel.select(expr, expr)\n+        res = rel.fetchall()\n+        assert res == [(7, 7)]\n+\n+    def test_binary_function_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                1 as a,\n+                5 as b\n+        \"\"\"\n+        )\n+        function = FunctionExpression(\"-\", ColumnExpression('b'), ColumnExpression('a'))\n+        rel2 = rel.select(function)\n+        res = rel2.fetchall()\n+        assert res == [(4,)]\n+\n+    def test_negate_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select 5 as a\n+        \"\"\"\n+        )\n+        col = ColumnExpression('a')\n+        col = -col\n+        rel = rel.select(col)\n+        res = rel.fetchall()\n+        assert res == [(-5,)]\n+\n+    def test_subtract_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                3 as a,\n+                1 as b\n+        \"\"\"\n+        )\n+        col1 = ColumnExpression('a')\n+        col2 = ColumnExpression('b')\n+        expr = col1 - col2\n+        rel = rel.select(expr)\n+        res = rel.fetchall()\n+        assert res == [(2,)]\n+\n+    def test_multiply_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                3 as a,\n+                2 as b\n+        \"\"\"\n+        )\n+        col1 = ColumnExpression('a')\n+        col2 = ColumnExpression('b')\n+        expr = col1 * col2\n+        rel = rel.select(expr)\n+        res = rel.fetchall()\n+        assert res == [(6,)]\n+\n+    def test_division_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                5 as a,\n+                2 as b\n+        \"\"\"\n+        )\n+        col1 = ColumnExpression('a')\n+        col2 = ColumnExpression('b')\n+        expr = col1 / col2\n+        rel2 = rel.select(expr)\n+        res = rel2.fetchall()\n+        assert res == [(2.5,)]\n+\n+        expr = col1 // col2\n+        rel2 = rel.select(expr)\n+        res = rel2.fetchall()\n+        assert res == [(2,)]\n+\n+    def test_modulus_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                5 as a,\n+                2 as b\n+        \"\"\"\n+        )\n+        col1 = ColumnExpression('a')\n+        col2 = ColumnExpression('b')\n+        expr = col1 % col2\n+        rel2 = rel.select(expr)\n+        res = rel2.fetchall()\n+        assert res == [(1,)]\n+\n+    def test_power_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                5 as a,\n+                2 as b\n+        \"\"\"\n+        )\n+        col1 = ColumnExpression('a')\n+        col2 = ColumnExpression('b')\n+        expr = col1**col2\n+        rel2 = rel.select(expr)\n+        res = rel2.fetchall()\n+        assert res == [(25,)]\n+\n+    def test_equality_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                5 as a,\n+                2 as b,\n+                5 as c\n+        \"\"\"\n+        )\n+        col1 = ColumnExpression('a')\n+        col2 = ColumnExpression('b')\n+        col3 = ColumnExpression('c')\n+        expr1 = col1 == col2\n+        expr2 = col1 == col3\n+        rel2 = rel.select(expr1, expr2)\n+        res = rel2.fetchall()\n+        assert res == [(False, True)]\n+\n+    def test_inequality_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                5 as a,\n+                2 as b,\n+                5 as c\n+        \"\"\"\n+        )\n+        col1 = ColumnExpression('a')\n+        col2 = ColumnExpression('b')\n+        col3 = ColumnExpression('c')\n+        expr1 = col1 != col2\n+        expr2 = col1 != col3\n+        rel2 = rel.select(expr1, expr2)\n+        res = rel2.fetchall()\n+        assert res == [(True, False)]\n+\n+    def test_comparison_expressions(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                1 as a,\n+                2 as b,\n+                3 as c,\n+                3 as d\n+        \"\"\"\n+        )\n+        col1 = ColumnExpression('a')\n+        col2 = ColumnExpression('b')\n+        col3 = ColumnExpression('c')\n+        col4 = ColumnExpression('d')\n+\n+        # Greater than\n+        expr1 = col1 > col2\n+        expr2 = col2 > col1\n+        expr3 = col3 > col4\n+        rel2 = rel.select(expr1, expr2, expr3)\n+        res = rel2.fetchall()\n+        assert res == [(False, True, False)]\n+\n+        # Greater than or equal\n+        expr1 = col1 >= col2\n+        expr2 = col2 >= col1\n+        expr3 = col3 >= col4\n+        rel2 = rel.select(expr1, expr2, expr3)\n+        res = rel2.fetchall()\n+        assert res == [(False, True, True)]\n+\n+        # Less than\n+        expr1 = col1 < col2\n+        expr2 = col2 < col1\n+        expr3 = col3 < col4\n+        rel2 = rel.select(expr1, expr2, expr3)\n+        res = rel2.fetchall()\n+        assert res == [(True, False, False)]\n+\n+        # Less than or equal\n+        expr1 = col1 <= col2\n+        expr2 = col2 <= col1\n+        expr3 = col3 <= col4\n+        rel2 = rel.select(expr1, expr2, expr3)\n+        res = rel2.fetchall()\n+        assert res == [(True, False, True)]\n+\n+    def test_expression_alias(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select 1 as a\n+        \"\"\"\n+        )\n+        col = ColumnExpression('a')\n+        col = col.alias('b')\n+\n+        rel2 = rel.select(col)\n+        assert rel2.columns == ['b']\n+\n+    def test_star_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                1 as a,\n+                2 as b\n+        \"\"\"\n+        )\n+        star = StarExpression()\n+        rel2 = rel.select(star)\n+        res = rel2.fetchall()\n+        assert res == [(1, 2)]\n+\n+        # With exclude list\n+        star = StarExpression(exclude=['a'])\n+        rel2 = rel.select(star)\n+        res = rel2.fetchall()\n+        assert res == [(2,)]\n+\n+    def test_struct_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                1 as a,\n+                2 as b\n+        \"\"\"\n+        )\n+\n+        col1 = ColumnExpression('a')\n+        col2 = ColumnExpression('b')\n+        expr = FunctionExpression('struct_pack', col1, col2).alias('struct')\n+\n+        rel = rel.select(expr)\n+        res = rel.fetchall()\n+        assert res == [({'a': 1, 'b': 2},)]\n+\n+    def test_function_expression_udf(self):\n+        con = duckdb.connect()\n+\n+        def my_simple_func(a: int, b: int, c: int) -> int:\n+            return a + b + c\n+\n+        con.create_function('my_func', my_simple_func)\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                1 as a,\n+                2 as b,\n+                3 as c\n+        \"\"\"\n+        )\n+        col1 = ColumnExpression('a')\n+        col2 = ColumnExpression('b')\n+        col3 = ColumnExpression('c')\n+        expr = FunctionExpression('my_func', col1, col2, col3)\n+        rel2 = rel.select(expr)\n+        res = rel2.fetchall()\n+        assert res == [(6,)]\n+\n+    def test_function_expression_basic(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+                FROM (VALUES\n+                    (1, 'test', 3),\n+                    (2, 'this is a long string', 7),\n+                    (3, 'medium length', 4)\n+                ) tbl(text, start, \"end\")\n+            \"\"\"\n+        )\n+        expr = FunctionExpression('array_slice', \"start\", \"text\", \"end\")\n+        rel2 = rel.select(expr)\n+        res = rel2.fetchall()\n+        assert res == [('tes',), ('his is',), ('di',)]\n+\n+    def test_column_expression_function_coverage(self):\n+        con = duckdb.connect()\n+\n+        con.execute(\n+            \"\"\"\n+            CREATE TABLE tbl as FROM (\n+                VALUES\n+                    ('a', 'b', 'c'),\n+                    ('d', 'e', 'f'),\n+                    ('g', 'h', 'i')\n+            ) t(c0, c1, c2)\n+        \"\"\"\n+        )\n+\n+        rel = con.table('tbl')\n+        expr = FunctionExpression('||', FunctionExpression('||', 'c0', 'c1'), 'c2')\n+        rel2 = rel.select(expr)\n+        res = rel2.fetchall()\n+        assert res == [('abc',), ('def',), ('ghi',)]\n+\n+    def test_function_expression_aggregate(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+                FROM (VALUES\n+                    ('test'),\n+                    ('this is a long string'),\n+                    ('medium length'),\n+                ) tbl(text)\n+            \"\"\"\n+        )\n+        expr = FunctionExpression('first', 'text')\n+        with pytest.raises(\n+            duckdb.BinderException, match='Binder Error: Aggregates cannot be present in a Project relation!'\n+        ):\n+            rel2 = rel.select(expr)\n+\n+    def test_case_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\n+            \"\"\"\n+            select\n+                1 as a,\n+                2 as b,\n+                3 as c,\n+        \"\"\"\n+        )\n+\n+        col1 = ColumnExpression('a')\n+        col2 = ColumnExpression('b')\n+        col3 = ColumnExpression('c')\n+\n+        const1 = ConstantExpression(IntegerValue(1))\n+        # CASE WHEN col1 > 1 THEN 5 ELSE NULL\n+        case1 = CaseExpression(col1 > const1, ConstantExpression(IntegerValue(5)))\n+\n+        rel2 = rel.select(case1)\n+        res = rel2.fetchall()\n+        assert res == [(None,)]\n+\n+        # CASE WHEN col1 > 1 THEN 5 WHEN col2 < col1 THEN 10 ELSE NULL\n+        case2 = case1.when(col2 < col1, ConstantExpression(IntegerValue(10)))\n+        rel2 = rel.select(case2)\n+        res = rel2.fetchall()\n+        assert res == [(None,)]\n+\n+        # CASE WHEN col1 > 1 THEN 5 WHEN col2 < col1 THEN 10 ELSE 42\n+        case3 = case2.otherwise(ConstantExpression(IntegerValue(42)))\n+        rel2 = rel.select(case3)\n+        res = rel2.fetchall()\n+        assert res == [(42,)]\n+\n+        # CASE WHEN col3 = col3 THEN 21 WHEN col3 > col1 THEN col3 ELSE col2\n+        case4 = (\n+            CaseExpression(col3 == col3, ConstantExpression(IntegerValue(21))).when(col3 > col1, col3).otherwise(col2)\n+        )\n+        rel2 = rel.select(case4)\n+        res = rel2.fetchall()\n+        assert res == [(21,)]\n+\n+    def test_cast_expression(self):\n+        con = duckdb.connect()\n+\n+        rel = con.sql(\"select '2022/01/21' as a\")\n+        assert rel.types == [VARCHAR]\n+\n+        col = ColumnExpression(\"a\").cast(TIMESTAMP)\n+        rel = rel.select(col)\n+        assert rel.types == [TIMESTAMP]\n+\n+        res = rel.fetchall()\n+        assert res == [(datetime.datetime(2022, 1, 21, 0, 0),)]\n+\n+    def test_implicit_constant_conversion(self):\n+        con = duckdb.connect()\n+        rel = con.sql(\"select 42\")\n+        res = rel.select(5).fetchall()\n+        assert res == [(5,)]\n+\n+    def test_numeric_overflow(self):\n+        con = duckdb.connect()\n+        rel = con.sql('select 3000::SHORT salary')\n+        # If 100 is implicitly cast to TINYINT, the execution fails in an OverflowError\n+        expr = ColumnExpression(\"salary\") * 100\n+        rel2 = rel.select(expr)\n+        res = rel2.fetchall()\n+        assert res == [(300_000,)]\n+\n+        with pytest.raises(duckdb.OutOfRangeException, match=\"Overflow in multiplication of INT16\"):\n+            import pyduckdb\n+\n+            val = pyduckdb.Value(100, duckdb.typing.TINYINT)\n+            expr = ColumnExpression(\"salary\") * val\n+            rel2 = rel.select(expr)\n+            res = rel2.fetchall()\n+\n+    def test_struct_column_expression(self):\n+        con = duckdb.connect()\n+        rel = con.sql(\"select {'l': 1, 'ee': 33, 't': 7} as leet\")\n+        expr = ColumnExpression(\"leet.ee\")\n+        rel2 = rel.select(expr)\n+        res = rel2.fetchall()\n+        assert res == [(33,)]\n+\n+    def test_filter_equality(self, filter_rel):\n+        assert len(filter_rel.fetchall()) == 5\n+\n+        expr = ColumnExpression(\"a\") == 1\n+        rel2 = filter_rel.filter(expr)\n+        res = rel2.fetchall()\n+        assert len(res) == 2\n+        assert res == [(1, 'a'), (1, 'b')]\n+\n+    def test_filter_not(self, filter_rel):\n+        expr = ColumnExpression(\"a\") == 1\n+        # NOT operator\n+        expr = ~expr\n+        rel2 = filter_rel.filter(expr)\n+        res = rel2.fetchall()\n+        assert len(res) == 3\n+        assert res == [(2, 'b'), (3, 'c'), (4, 'a')]\n+\n+    def test_filter_and(self, filter_rel):\n+        expr = ColumnExpression(\"a\") == 1\n+        expr = ~expr\n+        # AND operator\n+\n+        expr = expr & ('b' != ConstantExpression('b'))\n+        rel2 = filter_rel.filter(expr)\n+        res = rel2.fetchall()\n+        assert len(res) == 2\n+        assert res == [(3, 'c'), (4, 'a')]\n+\n+    def test_filter_or(self, filter_rel):\n+        # OR operator\n+        expr = (ColumnExpression(\"a\") == 1) | (ColumnExpression(\"a\") == 4)\n+        rel2 = filter_rel.filter(expr)\n+        res = rel2.fetchall()\n+        assert len(res) == 3\n+        assert res == [(1, 'a'), (1, 'b'), (4, 'a')]\n+\n+    def test_filter_mixed(self, filter_rel):\n+        # Mixed\n+        expr = (ColumnExpression(\"b\") == ConstantExpression(\"a\")) & (\n+            (ColumnExpression(\"a\") == 1) | (ColumnExpression(\"a\") == 4)\n+        )\n+        rel2 = filter_rel.filter(expr)\n+        res = rel2.fetchall()\n+        assert len(res) == 2\n+        assert res == [(1, 'a'), (4, 'a')]\n+\n+    def test_filter_in(self, filter_rel):\n+        # IN expression\n+        expr = ColumnExpression(\"a\")\n+        expr = expr.isin(1, 2)\n+        rel2 = filter_rel.filter(expr)\n+        res = rel2.fetchall()\n+        assert len(res) == 3\n+        assert res == [(1, 'a'), (1, 'b'), (2, 'b')]\n+\n+    def test_filter_not_in(self, filter_rel):\n+        expr = ColumnExpression(\"a\")\n+        expr = expr.isin(1, 2)\n+        # NOT IN expression\n+        expr = ~expr\n+        rel2 = filter_rel.filter(expr)\n+        res = rel2.fetchall()\n+        assert len(res) == 2\n+        assert res == [(3, 'c'), (4, 'a')]\n+\n+        # NOT IN expression\n+        expr = ColumnExpression(\"a\")\n+        expr = expr.isnotin(1, 2)\n+        rel2 = filter_rel.filter(expr)\n+        res = rel2.fetchall()\n+        assert len(res) == 2\n+        assert res == [(3, 'c'), (4, 'a')]\n+\n+    def test_sort(self):\n+        con = duckdb.connect()\n+        rel = con.sql(\n+            \"\"\"\n+            select * from (VALUES\n+                (1, 'a'),\n+                (2, 'b'),\n+                (3, NULL),\n+                (4, 'c'),\n+                (5, 'a')\n+            ) tbl(a, b)\n+        \"\"\"\n+        )\n+        # Ascending sort order\n+\n+        a = ColumnExpression(\"a\")\n+        b = ColumnExpression(\"b\")\n+\n+        rel2 = rel.sort(a.asc())\n+        res = rel2.a.fetchall()\n+        assert res == [(1,), (2,), (3,), (4,), (5,)]\n+\n+        # Descending sort order\n+        rel2 = rel.sort(a.desc())\n+        res = rel2.a.fetchall()\n+        assert res == [(5,), (4,), (3,), (2,), (1,)]\n+\n+        # Nulls first\n+        rel2 = rel.sort(b.desc().nulls_first())\n+        res = rel2.b.fetchall()\n+        assert res == [(None,), ('c',), ('b',), ('a',), ('a',)]\n+\n+        # Nulls last\n+        rel2 = rel.sort(b.desc().nulls_last())\n+        res = rel2.b.fetchall()\n+        assert res == [('c',), ('b',), ('a',), ('a',), (None,)]\ndiff --git a/tools/pythonpkg/tests/fast/test_map.py b/tools/pythonpkg/tests/fast/test_map.py\nindex ee8a5bf787b8..d63501032115 100644\n--- a/tools/pythonpkg/tests/fast/test_map.py\n+++ b/tools/pythonpkg/tests/fast/test_map.py\n@@ -27,9 +27,10 @@ def evil1(df):\n \n         # column type differs from bind\n         def evil2(df):\n-            if len(df) == 0:\n-                df['col0'] = df['col0'].astype('int')\n-            return df\n+            result = df.copy(deep=True)\n+            if len(result) == 0:\n+                result['col0'] = result['col0'].astype('double')\n+            return result\n \n         # column name differs from bind\n         def evil3(df):\n@@ -43,7 +44,7 @@ def evil4(df):\n \n         # straight up throws exception\n         def evil5(df):\n-            this_makes_no_sense()\n+            raise TypeError\n \n         def return_dataframe(df):\n             return pandas.DataFrame({'A': [1]})\n",
  "problem_statement": "Prepared statement causing \"Out of Range Error\"\n### What happens?\n\nWhen executing a prepared statement using the Python API leads to a \"Out of Range Error\" when the following conditions are met:\r\n- The expression contains only literals\r\n- The precision of the result is larger than the precision of the inputs.\n\n### To Reproduce\n\n```python\r\nimport duckdb\r\ncon = duckdb.connect(\":default:\")\r\ncon.execute(\"SELECT ? + ?\", [100, 100]).fetchall()\r\n```\r\n\r\n```\r\n---------------------------------------------------------------------------\r\nOutOfRangeException                       Traceback (most recent call last)\r\n      1 import duckdb\r\n      2 con = duckdb.connect(\":default:\")\r\n----> 3 con.execute(\"SELECT ? + ?\", [100, 100]).fetchall()\r\n\r\nOutOfRangeException: Out of Range Error: Overflow in addition of INT8 (100 + 100)!\r\n```\r\n\r\nHowever, running the prepared statement via CLI works fine:\r\n```sql\r\nPREPARE S1 AS SELECT ? + ?;\r\nEXECUTE S1(100, 100);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 ($1 + $2) \u2502\r\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\r\n\u2502       200 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n\n### OS:\n\nMacOS aarch64\n\n### DuckDB Version:\n\n0.8.1\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nNicolas Camenisch\n\n### Affiliation:\n\nNone\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-08-04T11:48:46Z"
}