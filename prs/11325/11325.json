{
  "repo": "duckdb/duckdb",
  "pull_number": 11325,
  "instance_id": "duckdb__duckdb-11325",
  "issue_numbers": [
    "11284",
    "11284"
  ],
  "base_commit": "5d065f3a19e4ae1ff8d1f465ac5211de88cb172d",
  "patch": "diff --git a/src/catalog/catalog_entry/duck_table_entry.cpp b/src/catalog/catalog_entry/duck_table_entry.cpp\nindex 7c93ece48f4a..994b98b26a82 100644\n--- a/src/catalog/catalog_entry/duck_table_entry.cpp\n+++ b/src/catalog/catalog_entry/duck_table_entry.cpp\n@@ -279,9 +279,9 @@ unique_ptr<CatalogEntry> DuckTableEntry::RenameColumn(ClientContext &context, Re\n \t\tcase ConstraintType::UNIQUE: {\n \t\t\t// UNIQUE constraint: possibly need to rename columns\n \t\t\tauto &unique = copy->Cast<UniqueConstraint>();\n-\t\t\tfor (idx_t i = 0; i < unique.columns.size(); i++) {\n-\t\t\t\tif (unique.columns[i] == info.old_name) {\n-\t\t\t\t\tunique.columns[i] = info.new_name;\n+\t\t\tfor (auto &column_name : unique.GetColumnNamesMutable()) {\n+\t\t\t\tif (column_name == info.old_name) {\n+\t\t\t\t\tcolumn_name = info.new_name;\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n@@ -399,13 +399,13 @@ void DuckTableEntry::UpdateConstraintsOnColumnDrop(const LogicalIndex &removed_i\n \t\tcase ConstraintType::UNIQUE: {\n \t\t\tauto copy = constraint->Copy();\n \t\t\tauto &unique = copy->Cast<UniqueConstraint>();\n-\t\t\tif (unique.index.index != DConstants::INVALID_INDEX) {\n-\t\t\t\tif (unique.index == removed_index) {\n+\t\t\tif (unique.HasIndex()) {\n+\t\t\t\tif (unique.GetIndex() == removed_index) {\n \t\t\t\t\tthrow CatalogException(\n \t\t\t\t\t    \"Cannot drop column \\\"%s\\\" because there is a UNIQUE constraint that depends on it\",\n \t\t\t\t\t    info.removed_column);\n \t\t\t\t}\n-\t\t\t\tunique.index = adjusted_indices[unique.index.index];\n+\t\t\t\tunique.SetIndex(adjusted_indices[unique.GetIndex().index]);\n \t\t\t}\n \t\t\tcreate_info.constraints.push_back(std::move(copy));\n \t\t\tbreak;\ndiff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp\nindex c4332497321c..f89d214f5465 100644\n--- a/src/catalog/catalog_entry/table_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp\n@@ -85,19 +85,18 @@ string TableCatalogEntry::ColumnsToSQL(const ColumnList &columns, const vector<u\n \t\t\tnot_null_columns.insert(not_null.index);\n \t\t} else if (constraint->type == ConstraintType::UNIQUE) {\n \t\t\tauto &pk = constraint->Cast<UniqueConstraint>();\n-\t\t\tvector<string> constraint_columns = pk.columns;\n-\t\t\tif (pk.index.index != DConstants::INVALID_INDEX) {\n+\t\t\tif (pk.HasIndex()) {\n \t\t\t\t// no columns specified: single column constraint\n-\t\t\t\tif (pk.is_primary_key) {\n-\t\t\t\t\tpk_columns.insert(pk.index);\n+\t\t\t\tif (pk.IsPrimaryKey()) {\n+\t\t\t\t\tpk_columns.insert(pk.GetIndex());\n \t\t\t\t} else {\n-\t\t\t\t\tunique_columns.insert(pk.index);\n+\t\t\t\t\tunique_columns.insert(pk.GetIndex());\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// multi-column constraint, this constraint needs to go at the end after all columns\n-\t\t\t\tif (pk.is_primary_key) {\n+\t\t\t\tif (pk.IsPrimaryKey()) {\n \t\t\t\t\t// multi key pk column: insert set of columns into multi_key_pks\n-\t\t\t\t\tfor (auto &col : pk.columns) {\n+\t\t\t\t\tfor (auto &col : pk.GetColumnNames()) {\n \t\t\t\t\t\tmulti_key_pks.insert(col);\n \t\t\t\t\t}\n \t\t\t\t}\ndiff --git a/src/function/table/system/duckdb_constraints.cpp b/src/function/table/system/duckdb_constraints.cpp\nindex 560c6b3a3d64..64aff39469ed 100644\n--- a/src/function/table/system/duckdb_constraints.cpp\n+++ b/src/function/table/system/duckdb_constraints.cpp\n@@ -153,7 +153,7 @@ void DuckDBConstraintsFunction(ClientContext &context, TableFunctionInput &data_\n \t\t\t\tbreak;\n \t\t\tcase ConstraintType::UNIQUE: {\n \t\t\t\tauto &unique = constraint->Cast<UniqueConstraint>();\n-\t\t\t\tconstraint_type = unique.is_primary_key ? \"PRIMARY KEY\" : \"UNIQUE\";\n+\t\t\t\tconstraint_type = unique.IsPrimaryKey() ? \"PRIMARY KEY\" : \"UNIQUE\";\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase ConstraintType::NOT_NULL:\ndiff --git a/src/function/table/system/duckdb_tables.cpp b/src/function/table/system/duckdb_tables.cpp\nindex 256badef56ad..2503cfbf80c9 100644\n--- a/src/function/table/system/duckdb_tables.cpp\n+++ b/src/function/table/system/duckdb_tables.cpp\n@@ -87,7 +87,7 @@ static bool TableHasPrimaryKey(TableCatalogEntry &table) {\n \tfor (auto &constraint : table.GetConstraints()) {\n \t\tif (constraint->type == ConstraintType::UNIQUE) {\n \t\t\tauto &unique = constraint->Cast<UniqueConstraint>();\n-\t\t\tif (unique.is_primary_key) {\n+\t\t\tif (unique.IsPrimaryKey()) {\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}\ndiff --git a/src/function/table/system/pragma_table_info.cpp b/src/function/table/system/pragma_table_info.cpp\nindex 64ff4694fd71..3e47ff398bd6 100644\n--- a/src/function/table/system/pragma_table_info.cpp\n+++ b/src/function/table/system/pragma_table_info.cpp\n@@ -195,12 +195,16 @@ static ColumnConstraintInfo CheckConstraints(TableCatalogEntry &table, const Col\n \t\t}\n \t\tcase ConstraintType::UNIQUE: {\n \t\t\tauto &unique = constraint->Cast<UniqueConstraint>();\n-\t\t\tbool &constraint_info = unique.is_primary_key ? result.pk : result.unique;\n-\t\t\tif (unique.index == column.Logical()) {\n-\t\t\t\tconstraint_info = true;\n-\t\t\t}\n-\t\t\tif (std::find(unique.columns.begin(), unique.columns.end(), column.GetName()) != unique.columns.end()) {\n-\t\t\t\tconstraint_info = true;\n+\t\t\tbool &constraint_info = unique.IsPrimaryKey() ? result.pk : result.unique;\n+\t\t\tif (unique.HasIndex()) {\n+\t\t\t\tif (unique.GetIndex() == column.Logical()) {\n+\t\t\t\t\tconstraint_info = true;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tauto &columns = unique.GetColumnNames();\n+\t\t\t\tif (std::find(columns.begin(), columns.end(), column.GetName()) != columns.end()) {\n+\t\t\t\t\tconstraint_info = true;\n+\t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n \t\t}\ndiff --git a/src/include/duckdb/parser/constraints/unique_constraint.hpp b/src/include/duckdb/parser/constraints/unique_constraint.hpp\nindex 66073108bc92..570a3e27ccd0 100644\n--- a/src/include/duckdb/parser/constraints/unique_constraint.hpp\n+++ b/src/include/duckdb/parser/constraints/unique_constraint.hpp\n@@ -21,14 +21,6 @@ class UniqueConstraint : public Constraint {\n \tDUCKDB_API UniqueConstraint(LogicalIndex index, bool is_primary_key);\n \tDUCKDB_API UniqueConstraint(vector<string> columns, bool is_primary_key);\n \n-\t//! The index of the column for which this constraint holds. Only used when the constraint relates to a single\n-\t//! column, equal to DConstants::INVALID_INDEX if not used\n-\tLogicalIndex index;\n-\t//! The set of columns for which this constraint holds by name. Only used when the index field is not used.\n-\tvector<string> columns;\n-\t//! Whether or not this is a PRIMARY KEY constraint, or a UNIQUE constraint.\n-\tbool is_primary_key;\n-\n public:\n \tDUCKDB_API string ToString() const override;\n \n@@ -37,8 +29,57 @@ class UniqueConstraint : public Constraint {\n \tDUCKDB_API void Serialize(Serializer &serializer) const override;\n \tDUCKDB_API static unique_ptr<Constraint> Deserialize(Deserializer &deserializer);\n \n+\tbool IsPrimaryKey() const {\n+\t\treturn is_primary_key;\n+\t}\n+\n+\tbool HasIndex() const {\n+\t\treturn index.index != DConstants::INVALID_INDEX;\n+\t}\n+\n+\tLogicalIndex GetIndex() const {\n+\t\tif (!HasIndex()) {\n+\t\t\tthrow InternalException(\"UniqueConstraint::GetIndex called on a unique constraint without a defined index\");\n+\t\t}\n+\t\treturn index;\n+\t}\n+\tvoid SetIndex(LogicalIndex new_index) {\n+\t\tD_ASSERT(new_index.index != DConstants::INVALID_INDEX);\n+\t\tindex = new_index;\n+\t}\n+\n+\tconst vector<string> &GetColumnNames() const {\n+\t\tD_ASSERT(columns.size() >= 1);\n+\t\treturn columns;\n+\t}\n+\tvector<string> &GetColumnNamesMutable() {\n+\t\tD_ASSERT(columns.size() >= 1);\n+\t\treturn columns;\n+\t}\n+\n+\tvoid SetColumnName(string name) {\n+\t\tif (!columns.empty()) {\n+\t\t\t// name has already been set\n+\t\t\treturn;\n+\t\t}\n+\t\tcolumns.push_back(std::move(name));\n+\t}\n+\n private:\n \tUniqueConstraint();\n+\n+#ifdef DUCKDB_API_1_0\n+private:\n+#else\n+public:\n+#endif\n+\t//! The index of the column for which this constraint holds. Only used when the constraint relates to a single\n+\t//! column, equal to DConstants::INVALID_INDEX if not used\n+\tLogicalIndex index;\n+\t//! The set of columns for which this constraint holds by name. Only used when the index field is not used.\n+\tvector<string> columns;\n+\t//! Whether or not this is a PRIMARY KEY constraint, or a UNIQUE constraint.\n+\tbool is_primary_key;\n };\n \n } // namespace duckdb\ndiff --git a/src/parser/constraints/unique_constraint.cpp b/src/parser/constraints/unique_constraint.cpp\nindex 29fd536e8b22..8613231eb448 100644\n--- a/src/parser/constraints/unique_constraint.cpp\n+++ b/src/parser/constraints/unique_constraint.cpp\n@@ -28,11 +28,13 @@ string UniqueConstraint::ToString() const {\n }\n \n unique_ptr<Constraint> UniqueConstraint::Copy() const {\n-\tif (index.index == DConstants::INVALID_INDEX) {\n+\tif (!HasIndex()) {\n \t\treturn make_uniq<UniqueConstraint>(columns, is_primary_key);\n \t} else {\n \t\tauto result = make_uniq<UniqueConstraint>(index, is_primary_key);\n-\t\tresult->columns = columns;\n+\t\tif (!columns.empty()) {\n+\t\t\tresult->columns.push_back(columns[0]);\n+\t\t}\n \t\treturn std::move(result);\n \t}\n }\ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex 7903342bd8e3..69fdc4afca7a 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -272,16 +272,16 @@ static void FindMatchingPrimaryKeyColumns(const ColumnList &columns, const vecto\n \t\t\tcontinue;\n \t\t}\n \t\tauto &unique = constr->Cast<UniqueConstraint>();\n-\t\tif (find_primary_key && !unique.is_primary_key) {\n+\t\tif (find_primary_key && !unique.IsPrimaryKey()) {\n \t\t\tcontinue;\n \t\t}\n \t\tfound_constraint = true;\n \n \t\tvector<string> pk_names;\n-\t\tif (unique.index.index != DConstants::INVALID_INDEX) {\n-\t\t\tpk_names.push_back(columns.GetColumn(LogicalIndex(unique.index)).Name());\n+\t\tif (unique.HasIndex()) {\n+\t\t\tpk_names.push_back(columns.GetColumn(LogicalIndex(unique.GetIndex())).Name());\n \t\t} else {\n-\t\t\tpk_names = unique.columns;\n+\t\t\tpk_names = unique.GetColumnNames();\n \t\t}\n \t\tif (find_primary_key) {\n \t\t\t// found matching primary key\n@@ -414,15 +414,14 @@ static bool AnyConstraintReferencesGeneratedColumn(CreateTableInfo &table_info)\n \t\t}\n \t\tcase ConstraintType::UNIQUE: {\n \t\t\tauto &constraint = constr->Cast<UniqueConstraint>();\n-\t\t\tauto index = constraint.index;\n-\t\t\tif (index.index == DConstants::INVALID_INDEX) {\n-\t\t\t\tfor (auto &col : constraint.columns) {\n+\t\t\tif (!constraint.HasIndex()) {\n+\t\t\t\tfor (auto &col : constraint.GetColumnNames()) {\n \t\t\t\t\tif (generated_columns.count(col)) {\n \t\t\t\t\t\treturn true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tif (table_info.columns.GetColumn(index).Generated()) {\n+\t\t\t\tif (table_info.columns.GetColumn(constraint.GetIndex()).Generated()) {\n \t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\ndiff --git a/src/planner/binder/statement/bind_create_table.cpp b/src/planner/binder/statement/bind_create_table.cpp\nindex 683c475ddb99..b2b0bfbef592 100644\n--- a/src/planner/binder/statement/bind_create_table.cpp\n+++ b/src/planner/binder/statement/bind_create_table.cpp\n@@ -76,17 +76,16 @@ static void BindConstraints(Binder &binder, BoundCreateTableInfo &info) {\n \t\t\t// have to resolve columns of the unique constraint\n \t\t\tvector<LogicalIndex> keys;\n \t\t\tlogical_index_set_t key_set;\n-\t\t\tif (unique.index.index != DConstants::INVALID_INDEX) {\n-\t\t\t\tD_ASSERT(unique.index.index < base.columns.LogicalColumnCount());\n+\t\t\tif (unique.HasIndex()) {\n+\t\t\t\tD_ASSERT(unique.GetIndex().index < base.columns.LogicalColumnCount());\n \t\t\t\t// unique constraint is given by single index\n-\t\t\t\tunique.columns.push_back(base.columns.GetColumn(unique.index).Name());\n-\t\t\t\tkeys.push_back(unique.index);\n-\t\t\t\tkey_set.insert(unique.index);\n+\t\t\t\tunique.SetColumnName(base.columns.GetColumn(unique.GetIndex()).Name());\n+\t\t\t\tkeys.push_back(unique.GetIndex());\n+\t\t\t\tkey_set.insert(unique.GetIndex());\n \t\t\t} else {\n \t\t\t\t// unique constraint is given by list of names\n \t\t\t\t// have to resolve names\n-\t\t\t\tD_ASSERT(!unique.columns.empty());\n-\t\t\t\tfor (auto &keyname : unique.columns) {\n+\t\t\t\tfor (auto &keyname : unique.GetColumnNames()) {\n \t\t\t\t\tif (!base.columns.ColumnExists(keyname)) {\n \t\t\t\t\t\tthrow ParserException(\"column \\\"%s\\\" named in key does not exist\", keyname);\n \t\t\t\t\t}\n@@ -102,7 +101,7 @@ static void BindConstraints(Binder &binder, BoundCreateTableInfo &info) {\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif (unique.is_primary_key) {\n+\t\t\tif (unique.IsPrimaryKey()) {\n \t\t\t\t// we can only have one primary key per table\n \t\t\t\tif (has_primary_key) {\n \t\t\t\t\tthrow ParserException(\"table \\\"%s\\\" has more than one primary key\", base.table);\n@@ -111,7 +110,7 @@ static void BindConstraints(Binder &binder, BoundCreateTableInfo &info) {\n \t\t\t\tprimary_keys = keys;\n \t\t\t}\n \t\t\tinfo.bound_constraints.push_back(\n-\t\t\t    make_uniq<BoundUniqueConstraint>(std::move(keys), std::move(key_set), unique.is_primary_key));\n+\t\t\t    make_uniq<BoundUniqueConstraint>(std::move(keys), std::move(key_set), unique.IsPrimaryKey()));\n \t\t\tbreak;\n \t\t}\n \t\tcase ConstraintType::FOREIGN_KEY: {\n",
  "test_patch": "diff --git a/test/sql/table_function/duckdb_constraints_issue11284.test b/test/sql/table_function/duckdb_constraints_issue11284.test\nnew file mode 100644\nindex 000000000000..4299f72829a2\n--- /dev/null\n+++ b/test/sql/table_function/duckdb_constraints_issue11284.test\n@@ -0,0 +1,46 @@\n+# name: test/sql/table_function/duckdb_constraints_issue11284.test\n+# description: Issue #11284 - duckdb_constraints() column CONSTRAINT_TEXT contains bad definition for PRIMARY KEY if there are foreign keys referencing it\n+# group: [table_function]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+create table t (i int primary key);\n+\n+query I\n+select constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\n+----\n+PRIMARY KEY(i)\n+\n+statement ok\n+create table u (i int references t);\n+\n+query I\n+select constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\n+----\n+PRIMARY KEY(i)\n+\n+statement ok\n+create table v (i int references t);\n+\n+query I\n+select constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\n+----\n+PRIMARY KEY(i)\n+\n+statement ok\n+drop table v;\n+\n+query I\n+select constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\n+----\n+PRIMARY KEY(i)\n+\n+statement ok\n+drop table u;\n+\n+query I\n+select constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\n+----\n+PRIMARY KEY(i)\n",
  "problem_statement": "duckdb_constraints() column CONSTRAINT_TEXT contains bad definition for PRIMARY KEY if there are foreign keys referencing it\n### What happens?\n\nThe `duckdb_constraints()` column `CONSTRAINT_TEXT` contains bad definition for PRIMARY KEY if there are foreign keys referencing it\n\n### To Reproduce\n\n```sql\r\ncreate table t (i int primary key);\r\nselect constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\r\n\r\ncreate table u (i int references t);\r\nselect constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\r\n  \r\ncreate table v (i int references t);\r\nselect constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\r\n  \r\ndrop table v;\r\nselect constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\r\n\r\ndrop table u;\r\nselect constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\r\n```\r\n\r\nThe above `SELECT` statements produce these values:\r\n\r\n- `PRIMARY KEY(i)`\r\n- `PRIMARY KEY(i, i)`\r\n- `PRIMARY KEY(i, i, i)`\r\n- `PRIMARY KEY(i, i, i, i)`\r\n- `PRIMARY KEY(i, i, i, i, i)`\r\n\r\nNote, I couldn't test the latest snapshots because of:\r\n\r\n- https://github.com/duckdb/duckdb/issues/11244\n\n### OS:\n\nMicrosoft Windows [Version 10.0.22631.3296]\n\n### DuckDB Version:\n\n0.10.0\n\n### DuckDB Client:\n\nJDBC\n\n### Full Name:\n\nLukas Eder\n\n### Affiliation:\n\nData Geekery\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a release build (and could not test with a nightly build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\nduckdb_constraints() column CONSTRAINT_TEXT contains bad definition for PRIMARY KEY if there are foreign keys referencing it\n### What happens?\n\nThe `duckdb_constraints()` column `CONSTRAINT_TEXT` contains bad definition for PRIMARY KEY if there are foreign keys referencing it\n\n### To Reproduce\n\n```sql\r\ncreate table t (i int primary key);\r\nselect constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\r\n\r\ncreate table u (i int references t);\r\nselect constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\r\n  \r\ncreate table v (i int references t);\r\nselect constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\r\n  \r\ndrop table v;\r\nselect constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\r\n\r\ndrop table u;\r\nselect constraint_text from duckdb_constraints() where constraint_type = 'PRIMARY KEY';\r\n```\r\n\r\nThe above `SELECT` statements produce these values:\r\n\r\n- `PRIMARY KEY(i)`\r\n- `PRIMARY KEY(i, i)`\r\n- `PRIMARY KEY(i, i, i)`\r\n- `PRIMARY KEY(i, i, i, i)`\r\n- `PRIMARY KEY(i, i, i, i, i)`\r\n\r\nNote, I couldn't test the latest snapshots because of:\r\n\r\n- https://github.com/duckdb/duckdb/issues/11244\n\n### OS:\n\nMicrosoft Windows [Version 10.0.22631.3296]\n\n### DuckDB Version:\n\n0.10.0\n\n### DuckDB Client:\n\nJDBC\n\n### Full Name:\n\nLukas Eder\n\n### Affiliation:\n\nData Geekery\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a release build (and could not test with a nightly build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2024-03-23T15:54:18Z"
}