{
  "repo": "duckdb/duckdb",
  "pull_number": 8112,
  "instance_id": "duckdb__duckdb-8112",
  "issue_numbers": [
    "5365"
  ],
  "base_commit": "5eda1762d7a8791cdc445c8412a8ec5a3ecdceb8",
  "patch": "diff --git a/.github/config/uncovered_files.csv b/.github/config/uncovered_files.csv\nindex 071120dd9e0c..6ef9e393af58 100644\n--- a/.github/config/uncovered_files.csv\n+++ b/.github/config/uncovered_files.csv\n@@ -152,11 +152,12 @@ execution/expression_executor/execute_comparison.cpp\t5\n execution/expression_executor/execute_conjunction.cpp\t3\n execution/expression_executor/execute_operator.cpp\t3\n execution/expression_executor_state.cpp\t2\n-execution/index/art/art.cpp\t4\n-execution/index/art/art_key.cpp\t13\n-execution/index/art/iterator.cpp\t4\n-execution/index/art/node.cpp\t5\n+execution/index/art/art.cpp\t3\n+execution/index/art/art_key.cpp\t6\n+execution/index/art/iterator.cpp\t2\n+execution/index/art/node.cpp\t6\n execution/index/art/node256.cpp\t1\n+execution/index/art/prefix.cpp\t1\n execution/join_hashtable.cpp\t23\n execution/nested_loop_join/nested_loop_join_inner.cpp\t24\n execution/nested_loop_join/nested_loop_join_mark.cpp\t30\ndiff --git a/src/common/constants.cpp b/src/common/constants.cpp\nindex baa9da908d06..bd307f1ffdf7 100644\n--- a/src/common/constants.cpp\n+++ b/src/common/constants.cpp\n@@ -7,7 +7,8 @@\n namespace duckdb {\n \n constexpr const idx_t DConstants::INVALID_INDEX;\n-const row_t MAX_ROW_ID = 4611686018427388000ULL; // 2^62\n+const row_t MAX_ROW_ID = 36028797018960000ULL;       // 2^55\n+const row_t MAX_ROW_ID_LOCAL = 72057594037920000ULL; // 2^56\n const column_t COLUMN_IDENTIFIER_ROW_ID = (column_t)-1;\n const sel_t ZERO_VECTOR[STANDARD_VECTOR_SIZE] = {0};\n const double PI = 3.141592653589793;\ndiff --git a/src/common/enum_util.cpp b/src/common/enum_util.cpp\nindex a6fe4c149651..5e2ab6d5f0a7 100644\n--- a/src/common/enum_util.cpp\n+++ b/src/common/enum_util.cpp\n@@ -3112,8 +3112,6 @@ const char* EnumUtil::ToChars<NType>(NType value) {\n \tswitch(value) {\n \tcase NType::PREFIX:\n \t\treturn \"PREFIX\";\n-\tcase NType::LEAF_SEGMENT:\n-\t\treturn \"LEAF_SEGMENT\";\n \tcase NType::LEAF:\n \t\treturn \"LEAF\";\n \tcase NType::NODE_4:\n@@ -3124,6 +3122,8 @@ const char* EnumUtil::ToChars<NType>(NType value) {\n \t\treturn \"NODE_48\";\n \tcase NType::NODE_256:\n \t\treturn \"NODE_256\";\n+\tcase NType::LEAF_INLINED:\n+\t\treturn \"LEAF_INLINED\";\n \tdefault:\n \t\tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%d' not implemented\", value));\n \t}\n@@ -3134,9 +3134,6 @@ NType EnumUtil::FromString<NType>(const char *value) {\n \tif (StringUtil::Equals(value, \"PREFIX\")) {\n \t\treturn NType::PREFIX;\n \t}\n-\tif (StringUtil::Equals(value, \"LEAF_SEGMENT\")) {\n-\t\treturn NType::LEAF_SEGMENT;\n-\t}\n \tif (StringUtil::Equals(value, \"LEAF\")) {\n \t\treturn NType::LEAF;\n \t}\n@@ -3152,6 +3149,9 @@ NType EnumUtil::FromString<NType>(const char *value) {\n \tif (StringUtil::Equals(value, \"NODE_256\")) {\n \t\treturn NType::NODE_256;\n \t}\n+\tif (StringUtil::Equals(value, \"LEAF_INLINED\")) {\n+\t\treturn NType::LEAF_INLINED;\n+\t}\n \tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%s' not implemented\", value));\n }\n \ndiff --git a/src/execution/index/art/CMakeLists.txt b/src/execution/index/art/CMakeLists.txt\nindex ecd56561faa5..7c45869b9215 100644\n--- a/src/execution/index/art/CMakeLists.txt\n+++ b/src/execution/index/art/CMakeLists.txt\n@@ -6,12 +6,10 @@ add_library_unity(\n   fixed_size_allocator.cpp\n   iterator.cpp\n   leaf.cpp\n-  leaf_segment.cpp\n   node4.cpp\n   node16.cpp\n   node48.cpp\n   node256.cpp\n-  swizzleable_pointer.cpp\n   prefix.cpp\n   art.cpp)\n \ndiff --git a/src/execution/index/art/art.cpp b/src/execution/index/art/art.cpp\nindex 4d2b83975b55..fb7cb731a52e 100644\n--- a/src/execution/index/art/art.cpp\n+++ b/src/execution/index/art/art.cpp\n@@ -5,7 +5,6 @@\n #include \"duckdb/execution/expression_executor.hpp\"\n #include \"duckdb/storage/arena_allocator.hpp\"\n #include \"duckdb/execution/index/art/art_key.hpp\"\n-#include \"duckdb/execution/index/art/leaf_segment.hpp\"\n #include \"duckdb/execution/index/art/prefix.hpp\"\n #include \"duckdb/execution/index/art/leaf.hpp\"\n #include \"duckdb/execution/index/art/node4.hpp\"\n@@ -44,7 +43,6 @@ ART::ART(const vector<column_t> &column_ids, TableIOManager &table_io_manager,\n \n \t// initialize all allocators\n \tallocators.emplace_back(make_uniq<FixedSizeAllocator>(sizeof(Prefix), buffer_manager.GetBufferAllocator()));\n-\tallocators.emplace_back(make_uniq<FixedSizeAllocator>(sizeof(LeafSegment), buffer_manager.GetBufferAllocator()));\n \tallocators.emplace_back(make_uniq<FixedSizeAllocator>(sizeof(Leaf), buffer_manager.GetBufferAllocator()));\n \tallocators.emplace_back(make_uniq<FixedSizeAllocator>(sizeof(Node4), buffer_manager.GetBufferAllocator()));\n \tallocators.emplace_back(make_uniq<FixedSizeAllocator>(sizeof(Node16), buffer_manager.GetBufferAllocator()));\n@@ -54,8 +52,8 @@ ART::ART(const vector<column_t> &column_ids, TableIOManager &table_io_manager,\n \t// set the root node of the tree\n \ttree = make_uniq<Node>();\n \tif (block_id != DConstants::INVALID_INDEX) {\n-\t\ttree->buffer_id = block_id;\n-\t\ttree->offset = block_offset;\n+\t\ttree->SetSerialized();\n+\t\ttree->SetPtr(block_id, block_offset);\n \t\ttree->Deserialize(*this);\n \t}\n \tserialized_data_pointer = BlockPointer(block_id, block_offset);\n@@ -308,7 +306,7 @@ bool Construct(ART &art, vector<ARTKey> &keys, row_t *row_ids, Node &node, KeySe\n \t\treference<Node> ref_node(node);\n \t\tPrefix::New(art, ref_node, start_key, prefix_start, start_key.len - prefix_start);\n \t\tif (single_row_id) {\n-\t\t\tLeaf::New(art, ref_node, row_ids[key_section.start]);\n+\t\t\tLeaf::New(ref_node, row_ids[key_section.start]);\n \t\t} else {\n \t\t\tLeaf::New(art, ref_node, row_ids + key_section.start, num_row_ids);\n \t\t}\n@@ -358,19 +356,9 @@ bool ART::ConstructFromSorted(idx_t count, vector<ARTKey> &keys, Vector &row_ide\n \tD_ASSERT(!VerifyAndToStringInternal(true).empty());\n \tfor (idx_t i = 0; i < count; i++) {\n \t\tD_ASSERT(!keys[i].Empty());\n-\t\tauto leaf_node = Lookup(*tree, keys[i], 0);\n-\t\tD_ASSERT(leaf_node.IsSet());\n-\t\tauto &leaf = Leaf::Get(*this, leaf_node);\n-\n-\t\tif (leaf.IsInlined()) {\n-\t\t\tD_ASSERT(row_ids[i] == leaf.row_ids.inlined);\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tD_ASSERT(leaf.row_ids.ptr.IsSet());\n-\t\tNode leaf_segment = leaf.row_ids.ptr;\n-\t\tauto position = leaf.FindRowId(*this, leaf_segment, row_ids[i]);\n-\t\tD_ASSERT(position != (uint32_t)DConstants::INVALID_INDEX);\n+\t\tauto leaf = Lookup(*tree, keys[i], 0);\n+\t\tD_ASSERT(leaf.IsSet());\n+\t\tD_ASSERT(Leaf::ContainsRowId(*this, leaf, row_ids[i]));\n \t}\n #endif\n \n@@ -431,19 +419,9 @@ PreservedError ART::Insert(IndexLock &lock, DataChunk &input, Vector &row_ids) {\n \t\t\tcontinue;\n \t\t}\n \n-\t\tauto leaf_node = Lookup(*tree, keys[i], 0);\n-\t\tD_ASSERT(leaf_node.IsSet());\n-\t\tauto &leaf = Leaf::Get(*this, leaf_node);\n-\n-\t\tif (leaf.IsInlined()) {\n-\t\t\tD_ASSERT(row_identifiers[i] == leaf.row_ids.inlined);\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tD_ASSERT(leaf.row_ids.ptr.IsSet());\n-\t\tNode leaf_segment = leaf.row_ids.ptr;\n-\t\tauto position = leaf.FindRowId(*this, leaf_segment, row_identifiers[i]);\n-\t\tD_ASSERT(position != (uint32_t)DConstants::INVALID_INDEX);\n+\t\tauto leaf = Lookup(*tree, keys[i], 0);\n+\t\tD_ASSERT(leaf.IsSet());\n+\t\tD_ASSERT(Leaf::ContainsRowId(*this, leaf, row_identifiers[i]));\n \t}\n #endif\n \n@@ -471,19 +449,13 @@ void ART::VerifyAppend(DataChunk &chunk, ConflictManager &conflict_manager) {\n \tCheckConstraintsForChunk(chunk, conflict_manager);\n }\n \n-bool ART::InsertToLeaf(Node &leaf_node, const row_t &row_id) {\n+bool ART::InsertToLeaf(Node &leaf, const row_t &row_id) {\n \n-\tauto &leaf = Leaf::Get(*this, leaf_node);\n-\n-#ifdef DEBUG\n-\tfor (idx_t k = 0; k < leaf.count; k++) {\n-\t\tD_ASSERT(leaf.GetRowId(*this, k) != row_id);\n-\t}\n-#endif\n-\tif (IsUnique() && leaf.count != 0) {\n+\tif (IsUnique()) {\n \t\treturn false;\n \t}\n-\tleaf.Insert(*this, row_id);\n+\n+\tLeaf::Insert(*this, leaf, row_id);\n \treturn true;\n }\n \n@@ -494,14 +466,14 @@ bool ART::Insert(Node &node, const ARTKey &key, idx_t depth, const row_t &row_id\n \t\tD_ASSERT(depth <= key.len);\n \t\treference<Node> ref_node(node);\n \t\tPrefix::New(*this, ref_node, key, depth, key.len - depth);\n-\t\tLeaf::New(*this, ref_node, row_id);\n+\t\tLeaf::New(ref_node, row_id);\n \t\treturn true;\n \t}\n \n-\tauto node_type = node.DecodeARTNodeType();\n+\tauto node_type = node.GetType();\n \n \t// insert the row ID into this leaf\n-\tif (node_type == NType::LEAF) {\n+\tif (node_type == NType::LEAF || node_type == NType::LEAF_INLINED) {\n \t\treturn InsertToLeaf(node, row_id);\n \t}\n \n@@ -518,13 +490,11 @@ bool ART::Insert(Node &node, const ARTKey &key, idx_t depth, const row_t &row_id\n \n \t\t// insert a new leaf node at key[depth]\n \t\tNode leaf_node;\n+\t\treference<Node> ref_node(leaf_node);\n \t\tif (depth + 1 < key.len) {\n-\t\t\treference<Node> ref_node(leaf_node);\n \t\t\tPrefix::New(*this, ref_node, key, depth + 1, key.len - depth - 1);\n-\t\t\tLeaf::New(*this, ref_node, row_id);\n-\t\t} else {\n-\t\t\tLeaf::New(*this, leaf_node, row_id);\n \t\t}\n+\t\tLeaf::New(ref_node, row_id);\n \t\tNode::InsertChild(*this, node, key[depth], leaf_node);\n \t\treturn true;\n \t}\n@@ -534,7 +504,7 @@ bool ART::Insert(Node &node, const ARTKey &key, idx_t depth, const row_t &row_id\n \tauto mismatch_position = Prefix::Traverse(*this, next_node, key, depth);\n \n \t// prefix matches key\n-\tif (next_node.get().DecodeARTNodeType() != NType::PREFIX) {\n+\tif (next_node.get().GetType() != NType::PREFIX) {\n \t\treturn Insert(next_node, key, depth, row_id);\n \t}\n \n@@ -550,13 +520,11 @@ bool ART::Insert(Node &node, const ARTKey &key, idx_t depth, const row_t &row_id\n \n \t// insert new leaf\n \tNode leaf_node;\n+\treference<Node> ref_node(leaf_node);\n \tif (depth + 1 < key.len) {\n-\t\treference<Node> ref_node(leaf_node);\n \t\tPrefix::New(*this, ref_node, key, depth + 1, key.len - depth - 1);\n-\t\tLeaf::New(*this, ref_node, row_id);\n-\t} else {\n-\t\tLeaf::New(*this, leaf_node, row_id);\n \t}\n+\tLeaf::New(ref_node, row_id);\n \tNode4::InsertChild(*this, next_node, key[depth], leaf_node);\n \treturn true;\n }\n@@ -596,19 +564,9 @@ void ART::Delete(IndexLock &state, DataChunk &input, Vector &row_ids) {\n \t\t\tcontinue;\n \t\t}\n \n-\t\tauto node = Lookup(*tree, keys[i], 0);\n-\t\tif (node.IsSet()) {\n-\t\t\tauto &leaf = Leaf::Get(*this, node);\n-\n-\t\t\tif (leaf.IsInlined()) {\n-\t\t\t\tD_ASSERT(row_identifiers[i] != leaf.row_ids.inlined);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tD_ASSERT(leaf.row_ids.ptr.IsSet());\n-\t\t\tNode leaf_segment = leaf.row_ids.ptr;\n-\t\t\tauto position = leaf.FindRowId(*this, leaf_segment, row_identifiers[i]);\n-\t\t\tD_ASSERT(position == (uint32_t)DConstants::INVALID_INDEX);\n+\t\tauto leaf = Lookup(*tree, keys[i], 0);\n+\t\tif (leaf.IsSet()) {\n+\t\t\tD_ASSERT(!Leaf::ContainsRowId(*this, leaf, row_identifiers[i]));\n \t\t}\n \t}\n #endif\n@@ -622,21 +580,17 @@ void ART::Erase(Node &node, const ARTKey &key, idx_t depth, const row_t &row_id)\n \n \t// handle prefix\n \treference<Node> next_node(node);\n-\tif (next_node.get().DecodeARTNodeType() == NType::PREFIX) {\n+\tif (next_node.get().GetType() == NType::PREFIX) {\n \t\tPrefix::Traverse(*this, next_node, key, depth);\n-\t\tif (next_node.get().DecodeARTNodeType() == NType::PREFIX) {\n+\t\tif (next_node.get().GetType() == NType::PREFIX) {\n \t\t\treturn;\n \t\t}\n \t}\n \n \t// delete a row ID from a leaf (root is leaf with possible prefix nodes)\n-\tif (next_node.get().DecodeARTNodeType() == NType::LEAF) {\n-\t\tauto &leaf = Leaf::Get(*this, next_node.get());\n-\t\tleaf.Remove(*this, row_id);\n-\n-\t\tif (leaf.count == 0) {\n+\tif (next_node.get().GetType() == NType::LEAF || next_node.get().GetType() == NType::LEAF_INLINED) {\n+\t\tif (Leaf::Remove(*this, next_node, row_id)) {\n \t\t\tNode::Free(*this, node);\n-\t\t\tnode.Reset();\n \t\t}\n \t\treturn;\n \t}\n@@ -648,20 +602,16 @@ void ART::Erase(Node &node, const ARTKey &key, idx_t depth, const row_t &row_id)\n \n \t\tauto temp_depth = depth + 1;\n \t\treference<Node> child_node(*child);\n-\t\tif (child_node.get().DecodeARTNodeType() == NType::PREFIX) {\n+\t\tif (child_node.get().GetType() == NType::PREFIX) {\n \t\t\tPrefix::Traverse(*this, child_node, key, temp_depth);\n-\t\t\tif (child_node.get().DecodeARTNodeType() == NType::PREFIX) {\n+\t\t\tif (child_node.get().GetType() == NType::PREFIX) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (child_node.get().DecodeARTNodeType() == NType::LEAF) {\n+\t\tif (child_node.get().GetType() == NType::LEAF || child_node.get().GetType() == NType::LEAF_INLINED) {\n \t\t\t// leaf found, remove entry\n-\t\t\tauto &leaf = Leaf::Get(*this, child_node.get());\n-\t\t\tleaf.Remove(*this, row_id);\n-\n-\t\t\tif (leaf.count == 0) {\n-\t\t\t\t// leaf is empty, delete leaf, decrement node counter and maybe shrink node\n+\t\t\tif (Leaf::Remove(*this, child_node, row_id)) {\n \t\t\t\tNode::DeleteChild(*this, next_node, node, key[depth]);\n \t\t\t}\n \t\t\treturn;\n@@ -713,20 +663,11 @@ static ARTKey CreateKey(ArenaAllocator &allocator, PhysicalType type, Value &val\n \n bool ART::SearchEqual(ARTKey &key, idx_t max_count, vector<row_t> &result_ids) {\n \n-\tauto leaf_node = Lookup(*tree, key, 0);\n-\tif (!leaf_node.IsSet()) {\n+\tauto leaf = Lookup(*tree, key, 0);\n+\tif (!leaf.IsSet()) {\n \t\treturn true;\n \t}\n-\n-\tauto &leaf = Leaf::Get(*this, leaf_node);\n-\tif (leaf.count > max_count) {\n-\t\treturn false;\n-\t}\n-\tfor (idx_t i = 0; i < leaf.count; i++) {\n-\t\trow_t row_id = leaf.GetRowId(*this, i);\n-\t\tresult_ids.push_back(row_id);\n-\t}\n-\treturn true;\n+\treturn Leaf::GetRowIds(*this, leaf, result_ids, max_count);\n }\n \n void ART::SearchEqualJoinNoFetch(ARTKey &key, idx_t &result_size) {\n@@ -738,8 +679,10 @@ void ART::SearchEqualJoinNoFetch(ARTKey &key, idx_t &result_size) {\n \t\treturn;\n \t}\n \n-\tauto &leaf = Leaf::Get(*this, leaf_node);\n-\tresult_size = leaf.count;\n+\t// we only perform index joins on PK/FK columns\n+\tD_ASSERT(leaf_node.GetType() == NType::LEAF_INLINED);\n+\tresult_size = 1;\n+\treturn;\n }\n \n //===--------------------------------------------------------------------===//\n@@ -752,14 +695,14 @@ Node ART::Lookup(Node node, const ARTKey &key, idx_t depth) {\n \n \t\t// traverse prefix, if exists\n \t\treference<Node> next_node(node);\n-\t\tif (next_node.get().DecodeARTNodeType() == NType::PREFIX) {\n+\t\tif (next_node.get().GetType() == NType::PREFIX) {\n \t\t\tPrefix::Traverse(*this, next_node, key, depth);\n-\t\t\tif (next_node.get().DecodeARTNodeType() == NType::PREFIX) {\n+\t\t\tif (next_node.get().GetType() == NType::PREFIX) {\n \t\t\t\treturn Node();\n \t\t\t}\n \t\t}\n \n-\t\tif (next_node.get().DecodeARTNodeType() == NType::LEAF) {\n+\t\tif (next_node.get().GetType() == NType::LEAF || next_node.get().GetType() == NType::LEAF_INLINED) {\n \t\t\treturn next_node.get();\n \t\t}\n \n@@ -994,20 +937,18 @@ void ART::CheckConstraintsForChunk(DataChunk &input, ConflictManager &conflict_m\n \t\t\tcontinue;\n \t\t}\n \n-\t\tauto leaf_node = Lookup(*tree, keys[i], 0);\n-\t\tif (!leaf_node.IsSet()) {\n+\t\tauto leaf = Lookup(*tree, keys[i], 0);\n+\t\tif (!leaf.IsSet()) {\n \t\t\tif (conflict_manager.AddMiss(i)) {\n \t\t\t\tfound_conflict = i;\n \t\t\t}\n \t\t\tcontinue;\n \t\t}\n \n-\t\t// When we find a node, we need to update the 'matches' and 'row_ids'\n-\t\t// NOTE: Leafs can have more than one row_id, but for UNIQUE/PRIMARY KEY they will only have one\n-\t\tLeaf &leaf = Leaf::Get(*this, leaf_node);\n-\t\tD_ASSERT(leaf.count == 1);\n-\t\tauto row_id = leaf.GetRowId(*this, 0);\n-\t\tif (conflict_manager.AddHit(i, row_id)) {\n+\t\t// when we find a node, we need to update the 'matches' and 'row_ids'\n+\t\t// NOTE: leaves can have more than one row_id, but for UNIQUE/PRIMARY KEY they will only have one\n+\t\tD_ASSERT(leaf.GetType() == NType::LEAF_INLINED);\n+\t\tif (conflict_manager.AddHit(i, leaf.GetRowId())) {\n \t\t\tfound_conflict = i;\n \t\t}\n \t}\n@@ -1086,7 +1027,7 @@ void ART::Vacuum(IndexLock &state) {\n \t}\n \n \t// traverse the allocated memory of the tree to perform a vacuum\n-\tNode::Vacuum(*this, *tree, flags);\n+\ttree->Vacuum(*this, flags);\n \n \t// finalize the vacuum operation\n \tFinalizeVacuum(flags);\ndiff --git a/src/execution/index/art/art_key.cpp b/src/execution/index/art/art_key.cpp\nindex e26ed0e4685f..9cc26be2b54c 100644\n--- a/src/execution/index/art/art_key.cpp\n+++ b/src/execution/index/art/art_key.cpp\n@@ -72,17 +72,6 @@ bool ARTKey::operator>(const ARTKey &k) const {\n \treturn len > k.len;\n }\n \n-bool ARTKey::operator<(const ARTKey &k) const {\n-\tfor (uint32_t i = 0; i < MinValue<uint32_t>(len, k.len); i++) {\n-\t\tif (data[i] < k.data[i]) {\n-\t\t\treturn true;\n-\t\t} else if (data[i] > k.data[i]) {\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\treturn len < k.len;\n-}\n-\n bool ARTKey::operator>=(const ARTKey &k) const {\n \tfor (uint32_t i = 0; i < MinValue<uint32_t>(len, k.len); i++) {\n \t\tif (data[i] > k.data[i]) {\ndiff --git a/src/execution/index/art/fixed_size_allocator.cpp b/src/execution/index/art/fixed_size_allocator.cpp\nindex 595c3932c9c4..ac1526e228d2 100644\n--- a/src/execution/index/art/fixed_size_allocator.cpp\n+++ b/src/execution/index/art/fixed_size_allocator.cpp\n@@ -1,9 +1,5 @@\n #include \"duckdb/execution/index/art/fixed_size_allocator.hpp\"\n \n-#include \"duckdb/common/allocator.hpp\"\n-#include \"duckdb/common/exception.hpp\"\n-#include \"duckdb/common/helper.hpp\"\n-\n namespace duckdb {\n \n constexpr idx_t FixedSizeAllocator::BASE[];\n@@ -46,7 +42,7 @@ FixedSizeAllocator::~FixedSizeAllocator() {\n \t}\n }\n \n-SwizzleablePointer FixedSizeAllocator::New() {\n+Node FixedSizeAllocator::New() {\n \n \t// no more free pointers\n \tif (buffers_with_free_space.empty()) {\n@@ -77,19 +73,19 @@ SwizzleablePointer FixedSizeAllocator::New() {\n \t\tbuffers_with_free_space.erase(buffer_id);\n \t}\n \n-\treturn SwizzleablePointer(offset, buffer_id);\n+\treturn Node(buffer_id, offset);\n }\n \n-void FixedSizeAllocator::Free(const SwizzleablePointer ptr) {\n-\tauto bitmask_ptr = reinterpret_cast<validity_t *>(buffers[ptr.buffer_id].ptr);\n+void FixedSizeAllocator::Free(const Node ptr) {\n+\tauto bitmask_ptr = reinterpret_cast<validity_t *>(buffers[ptr.GetBufferId()].ptr);\n \tValidityMask mask(bitmask_ptr);\n-\tD_ASSERT(!mask.RowIsValid(ptr.offset));\n-\tmask.SetValid(ptr.offset);\n-\tbuffers_with_free_space.insert(ptr.buffer_id);\n+\tD_ASSERT(!mask.RowIsValid(ptr.GetOffset()));\n+\tmask.SetValid(ptr.GetOffset());\n+\tbuffers_with_free_space.insert(ptr.GetBufferId());\n \n \tD_ASSERT(total_allocations > 0);\n-\tD_ASSERT(buffers[ptr.buffer_id].allocation_count > 0);\n-\tbuffers[ptr.buffer_id].allocation_count--;\n+\tD_ASSERT(buffers[ptr.GetBufferId()].allocation_count > 0);\n+\tbuffers[ptr.GetBufferId()].allocation_count--;\n \ttotal_allocations--;\n }\n \n@@ -172,7 +168,7 @@ void FixedSizeAllocator::FinalizeVacuum() {\n \t}\n }\n \n-SwizzleablePointer FixedSizeAllocator::VacuumPointer(const SwizzleablePointer ptr) {\n+Node FixedSizeAllocator::VacuumPointer(const Node ptr) {\n \n \t// we do not need to adjust the bitmask of the old buffer, because we will free the entire\n \t// buffer after the vacuum operation\ndiff --git a/src/execution/index/art/iterator.cpp b/src/execution/index/art/iterator.cpp\nindex e9df313fcbff..68e71c906714 100644\n--- a/src/execution/index/art/iterator.cpp\n+++ b/src/execution/index/art/iterator.cpp\n@@ -58,17 +58,11 @@ bool Iterator::Scan(const ARTKey &upper_bound, const idx_t max_count, vector<row\n \t\t\t}\n \t\t}\n \n-\t\t// adding more elements would exceed the maximum count\n-\t\tif (result_ids.size() + last_leaf->count > max_count) {\n+\t\t// copy all row IDs of this leaf into the result IDs (if they don't exceed max_count)\n+\t\tif (!Leaf::GetRowIds(*art, last_leaf, result_ids, max_count)) {\n \t\t\treturn false;\n \t\t}\n \n-\t\t// FIXME: copy all at once to improve performance\n-\t\tfor (idx_t i = 0; i < last_leaf->count; i++) {\n-\t\t\trow_t row_id = last_leaf->GetRowId(*art, i);\n-\t\t\tresult_ids.push_back(row_id);\n-\t\t}\n-\n \t\t// get the next leaf\n \t\thas_next = Next();\n \n@@ -80,18 +74,18 @@ bool Iterator::Scan(const ARTKey &upper_bound, const idx_t max_count, vector<row\n void Iterator::FindMinimum(Node &node) {\n \n \tD_ASSERT(node.IsSet());\n-\tif (node.IsSwizzled()) {\n+\tif (node.IsSerialized()) {\n \t\tnode.Deserialize(*art);\n \t}\n \n \t// found the minimum\n-\tif (node.DecodeARTNodeType() == NType::LEAF) {\n-\t\tlast_leaf = Node::GetAllocator(*art, NType::LEAF).Get<Leaf>(node);\n+\tif (node.GetType() == NType::LEAF || node.GetType() == NType::LEAF_INLINED) {\n+\t\tlast_leaf = node;\n \t\treturn;\n \t}\n \n \t// traverse the prefix\n-\tif (node.DecodeARTNodeType() == NType::PREFIX) {\n+\tif (node.GetType() == NType::PREFIX) {\n \t\tauto &prefix = Prefix::Get(*art, node);\n \t\tfor (idx_t i = 0; i < prefix.data[Node::PREFIX_SIZE]; i++) {\n \t\t\tcurrent_key.Push(prefix.data[i]);\n@@ -115,20 +109,20 @@ bool Iterator::LowerBound(Node &node, const ARTKey &key, const bool equal, idx_t\n \t\treturn false;\n \t}\n \n-\tif (node.IsSwizzled()) {\n+\tif (node.IsSerialized()) {\n \t\tnode.Deserialize(*art);\n \t}\n \n \t// we found the lower bound\n-\tif (node.DecodeARTNodeType() == NType::LEAF) {\n+\tif (node.GetType() == NType::LEAF || node.GetType() == NType::LEAF_INLINED) {\n \t\tif (!equal && current_key == key) {\n \t\t\treturn Next();\n \t\t}\n-\t\tlast_leaf = Node::GetAllocator(*art, NType::LEAF).Get<Leaf>(node);\n+\t\tlast_leaf = node;\n \t\treturn true;\n \t}\n \n-\tif (node.DecodeARTNodeType() != NType::PREFIX) {\n+\tif (node.GetType() != NType::PREFIX) {\n \t\tauto next_byte = key[depth];\n \t\tauto child = node.GetNextChild(*art, next_byte);\n \t\tif (!child) {\n@@ -181,9 +175,9 @@ bool Iterator::Next() {\n \twhile (!nodes.empty()) {\n \n \t\tauto &top = nodes.top();\n-\t\tD_ASSERT(top.node.DecodeARTNodeType() != NType::LEAF);\n+\t\tD_ASSERT(top.node.GetType() != NType::LEAF && top.node.GetType() != NType::LEAF_INLINED);\n \n-\t\tif (top.node.DecodeARTNodeType() == NType::PREFIX) {\n+\t\tif (top.node.GetType() == NType::PREFIX) {\n \t\t\tPopNode();\n \t\t\tcontinue;\n \t\t}\n@@ -211,7 +205,7 @@ bool Iterator::Next() {\n }\n \n void Iterator::PopNode() {\n-\tif (nodes.top().node.DecodeARTNodeType() == NType::PREFIX) {\n+\tif (nodes.top().node.GetType() == NType::PREFIX) {\n \t\tauto prefix_byte_count = Prefix::Get(*art, nodes.top().node).data[Node::PREFIX_SIZE];\n \t\tcurrent_key.Pop(prefix_byte_count);\n \t} else {\ndiff --git a/src/execution/index/art/leaf.cpp b/src/execution/index/art/leaf.cpp\nindex bdb1acd7e95d..730d01704d71 100644\n--- a/src/execution/index/art/leaf.cpp\n+++ b/src/execution/index/art/leaf.cpp\n@@ -2,361 +2,410 @@\n \n #include \"duckdb/execution/index/art/art.hpp\"\n #include \"duckdb/execution/index/art/node.hpp\"\n-#include \"duckdb/execution/index/art/leaf_segment.hpp\"\n #include \"duckdb/storage/meta_block_reader.hpp\"\n #include \"duckdb/storage/meta_block_writer.hpp\"\n \n namespace duckdb {\n \n-Leaf &Leaf::New(ART &art, Node &node, const row_t row_id) {\n+void Leaf::New(Node &node, const row_t row_id) {\n \n-\tnode.SetPtr(Node::GetAllocator(art, NType::LEAF).New());\n-\tnode.type = (uint8_t)NType::LEAF;\n-\tauto &leaf = Leaf::Get(art, node);\n-\n-\t// set the fields of the leaf\n-\tleaf.count = 1;\n-\tleaf.row_ids.inlined = row_id;\n-\treturn leaf;\n+\t// we directly inline this row ID into the node pointer\n+\tD_ASSERT(row_id < MAX_ROW_ID_LOCAL);\n+\tnode.Reset();\n+\tnode.SetType((uint8_t)NType::LEAF_INLINED);\n+\tnode.SetRowId(row_id);\n }\n \n-Leaf &Leaf::New(ART &art, Node &node, const row_t *row_ids, const idx_t count) {\n+void Leaf::New(ART &art, reference<Node> &node, const row_t *row_ids, idx_t count) {\n \n \tD_ASSERT(count > 1);\n \n-\tnode.SetPtr(Node::GetAllocator(art, NType::LEAF).New());\n-\tnode.type = (uint8_t)NType::LEAF;\n-\tauto &leaf = Leaf::Get(art, node);\n+\tidx_t copy_count = 0;\n+\twhile (count) {\n+\t\tnode.get() = Node::GetAllocator(art, NType::LEAF).New();\n+\t\tnode.get().SetType((uint8_t)NType::LEAF);\n \n-\t// reset the count to copy the row IDs\n-\tleaf.count = 0;\n-\treference<LeafSegment> segment(LeafSegment::New(art, leaf.row_ids.ptr));\n-\tfor (idx_t i = 0; i < count; i++) {\n-\t\tsegment = segment.get().Append(art, leaf.count, row_ids[i]);\n-\t}\n+\t\tauto &leaf = Leaf::Get(art, node);\n \n-\treturn leaf;\n-}\n+\t\tleaf.count = MinValue((idx_t)Node::LEAF_SIZE, count);\n+\t\tfor (idx_t i = 0; i < leaf.count; i++) {\n+\t\t\tleaf.row_ids[i] = row_ids[copy_count + i];\n+\t\t}\n \n-void Leaf::Free(ART &art, Node &node) {\n+\t\tcopy_count += leaf.count;\n+\t\tcount -= leaf.count;\n \n-\tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n-\n-\t// free leaf segments\n-\tauto &leaf = Leaf::Get(art, node);\n-\tif (!leaf.IsInlined()) {\n-\t\tNode::Free(art, leaf.row_ids.ptr);\n+\t\tnode = leaf.ptr;\n+\t\tleaf.ptr.Reset();\n \t}\n }\n \n-void Leaf::InitializeMerge(const ART &art, const idx_t buffer_count) {\n+void Leaf::Free(ART &art, Node &node) {\n \n-\tif (IsInlined()) {\n-\t\treturn;\n-\t}\n+\tD_ASSERT(node.IsSet() && !node.IsSerialized());\n+\tauto &child = Leaf::Get(art, node).ptr;\n+\tNode::Free(art, child);\n+}\n+\n+void Leaf::InitializeMerge(ART &art, Node &node, const ARTFlags &flags) {\n \n-\treference<LeafSegment> segment(LeafSegment::Get(art, row_ids.ptr));\n-\trow_ids.ptr.buffer_id += buffer_count;\n+\tD_ASSERT(node.IsSet() && !node.IsSerialized());\n+\tD_ASSERT(node.GetType() == NType::LEAF);\n \n-\tauto ptr = segment.get().next;\n-\twhile (ptr.IsSet()) {\n-\t\tsegment.get().next.buffer_id += buffer_count;\n-\t\tsegment = LeafSegment::Get(art, ptr);\n-\t\tptr = segment.get().next;\n+\tauto &leaf = Leaf::Get(art, node);\n+\tif (leaf.ptr.IsSet()) {\n+\t\tleaf.ptr.InitializeMerge(art, flags);\n \t}\n }\n \n-void Leaf::Merge(ART &art, Node &other) {\n+void Leaf::Merge(ART &art, Node &l_node, Node &r_node) {\n \n-\tauto &other_leaf = Leaf::Get(art, other);\n+\tD_ASSERT(l_node.IsSet() && !l_node.IsSerialized());\n+\tD_ASSERT(r_node.IsSet() && !r_node.IsSerialized());\n \n-\t// copy inlined row ID\n-\tif (other_leaf.IsInlined()) {\n-\t\tInsert(art, other_leaf.row_ids.inlined);\n-\t\tNode::Free(art, other);\n+\t// copy inlined row ID of r_node\n+\tif (r_node.GetType() == NType::LEAF_INLINED) {\n+\t\tLeaf::Insert(art, l_node, r_node.GetRowId());\n+\t\tr_node.Reset();\n \t\treturn;\n \t}\n \n-\t// row ID was inlined, move to a new segment\n-\tif (IsInlined()) {\n-\t\tauto row_id = row_ids.inlined;\n-\t\tauto &segment = LeafSegment::New(art, row_ids.ptr);\n-\t\tsegment.row_ids[0] = row_id;\n+\t// l_node has an inlined row ID, swap and insert\n+\tif (l_node.GetType() == NType::LEAF_INLINED) {\n+\t\tauto row_id = l_node.GetRowId();\n+\t\tl_node = r_node;\n+\t\tLeaf::Insert(art, l_node, row_id);\n+\t\tr_node.Reset();\n+\t\treturn;\n \t}\n \n-\t// get the first segment to copy to\n-\treference<LeafSegment> segment(LeafSegment::Get(art, row_ids.ptr).GetTail(art));\n+\tD_ASSERT(l_node.GetType() != NType::LEAF_INLINED);\n+\tD_ASSERT(r_node.GetType() != NType::LEAF_INLINED);\n \n-\t// initialize loop variables\n-\tauto other_ptr = other_leaf.row_ids.ptr;\n-\tauto remaining = other_leaf.count;\n+\treference<Node> l_node_ref(l_node);\n+\treference<Leaf> l_leaf = Leaf::Get(art, l_node_ref);\n \n-\t// copy row IDs\n-\twhile (other_ptr.IsSet()) {\n-\t\tauto &other_segment = LeafSegment::Get(art, other_ptr);\n-\t\tauto copy_count = MinValue(Node::LEAF_SEGMENT_SIZE, remaining);\n+\t// find a non-full node\n+\twhile (l_leaf.get().count == Node::LEAF_SIZE) {\n+\t\tl_node_ref = l_leaf.get().ptr;\n \n-\t\t// copy the data\n-\t\tfor (idx_t i = 0; i < copy_count; i++) {\n-\t\t\tsegment = segment.get().Append(art, count, other_segment.row_ids[i]);\n+\t\t// the last leaf is full\n+\t\tif (!l_leaf.get().ptr.IsSet()) {\n+\t\t\tbreak;\n \t\t}\n-\n-\t\t// adjust the loop variables\n-\t\tother_ptr = other_segment.next;\n-\t\tremaining -= copy_count;\n+\t\tl_leaf = Leaf::Get(art, l_node_ref);\n \t}\n-\tD_ASSERT(remaining == 0);\n \n-\tNode::Free(art, other);\n+\t// store the last leaf and then append r_node\n+\tauto last_leaf_node = l_node_ref.get();\n+\tl_node_ref.get() = r_node;\n+\tr_node.Reset();\n+\n+\t// append the remaining row IDs of the last leaf node\n+\tif (last_leaf_node.IsSet()) {\n+\t\t// find the tail\n+\t\tl_leaf = Leaf::Get(art, l_node_ref);\n+\t\twhile (l_leaf.get().ptr.IsSet()) {\n+\t\t\tl_leaf = Leaf::Get(art, l_leaf.get().ptr);\n+\t\t}\n+\t\t// append the row IDs\n+\t\tauto &last_leaf = Leaf::Get(art, last_leaf_node);\n+\t\tfor (idx_t i = 0; i < last_leaf.count; i++) {\n+\t\t\tl_leaf = l_leaf.get().Append(art, last_leaf.row_ids[i]);\n+\t\t}\n+\t\tNode::GetAllocator(art, NType::LEAF).Free(last_leaf_node);\n+\t}\n }\n \n-void Leaf::Insert(ART &art, const row_t row_id) {\n+void Leaf::Insert(ART &art, Node &node, const row_t row_id) {\n+\n+\tD_ASSERT(node.IsSet() && !node.IsSerialized());\n \n-\tD_ASSERT(count != 0);\n-\tif (count == 1) {\n-\t\tMoveInlinedToSegment(art);\n+\tif (node.GetType() == NType::LEAF_INLINED) {\n+\t\tLeaf::MoveInlinedToLeaf(art, node);\n+\t\tLeaf::Insert(art, node, row_id);\n+\t\treturn;\n \t}\n \n \t// append to the tail\n-\tauto &first_segment = LeafSegment::Get(art, row_ids.ptr);\n-\tauto &tail = first_segment.GetTail(art);\n-\ttail.Append(art, count, row_id);\n+\treference<Leaf> leaf = Leaf::Get(art, node);\n+\twhile (leaf.get().ptr.IsSet()) {\n+\t\tif (leaf.get().ptr.IsSerialized()) {\n+\t\t\tleaf.get().ptr.Deserialize(art);\n+\t\t}\n+\t\tleaf = Leaf::Get(art, leaf.get().ptr);\n+\t}\n+\tleaf.get().Append(art, row_id);\n }\n \n-void Leaf::Remove(ART &art, const row_t row_id) {\n+bool Leaf::Remove(ART &art, reference<Node> &node, const row_t row_id) {\n \n-\tif (count == 0) {\n-\t\treturn;\n+\tD_ASSERT(node.get().IsSet() && !node.get().IsSerialized());\n+\n+\tif (node.get().GetType() == NType::LEAF_INLINED) {\n+\t\tif (node.get().GetRowId() == row_id) {\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n \t}\n \n-\tif (IsInlined()) {\n-\t\tif (row_ids.inlined == row_id) {\n-\t\t\tcount--;\n+\treference<Leaf> leaf = Leaf::Get(art, node);\n+\n+\t// inline the remaining row ID\n+\tif (leaf.get().count == 2) {\n+\t\tif (leaf.get().row_ids[0] == row_id || leaf.get().row_ids[1] == row_id) {\n+\t\t\tauto remaining_row_id = leaf.get().row_ids[0] == row_id ? leaf.get().row_ids[1] : leaf.get().row_ids[0];\n+\t\t\tNode::Free(art, node);\n+\t\t\tLeaf::New(node, remaining_row_id);\n \t\t}\n-\t\treturn;\n+\t\treturn false;\n \t}\n \n-\t// possibly inline the row ID\n-\tif (count == 2) {\n-\t\tauto &segment = LeafSegment::Get(art, row_ids.ptr);\n-\t\tD_ASSERT(segment.row_ids[0] == row_id || segment.row_ids[1] == row_id);\n-\t\tauto remaining_row_id = segment.row_ids[0] == row_id ? segment.row_ids[1] : segment.row_ids[0];\n-\t\tNode::Free(art, row_ids.ptr);\n-\t\trow_ids.inlined = remaining_row_id;\n-\t\tcount--;\n-\t\treturn;\n+\t// get the last row ID (the order within a leaf does not matter)\n+\t// because we want to overwrite the row ID to remove with that one\n+\n+\t// go to the tail and keep track of the previous leaf node\n+\treference<Leaf> prev_leaf(leaf);\n+\twhile (leaf.get().ptr.IsSet()) {\n+\t\tprev_leaf = leaf;\n+\t\tif (leaf.get().ptr.IsSerialized()) {\n+\t\t\tleaf.get().ptr.Deserialize(art);\n+\t\t}\n+\t\tleaf = Leaf::Get(art, leaf.get().ptr);\n \t}\n \n-\t// find the row ID, and the segment containing that row ID (stored in ptr)\n-\tauto ptr = row_ids.ptr;\n-\tauto copy_idx = FindRowId(art, ptr, row_id);\n-\tD_ASSERT(copy_idx != (uint32_t)DConstants::INVALID_INDEX);\n-\tcopy_idx++;\n-\n-\t// iterate all remaining segments and move the row IDs one field to the left\n-\treference<LeafSegment> segment(LeafSegment::Get(art, ptr));\n-\treference<LeafSegment> prev_segment(LeafSegment::Get(art, ptr));\n-\twhile (copy_idx < count) {\n-\n-\t\tauto copy_start = copy_idx % Node::LEAF_SEGMENT_SIZE;\n-\t\tD_ASSERT(copy_start != 0);\n-\t\tauto copy_end = MinValue(copy_start + count - copy_idx, Node::LEAF_SEGMENT_SIZE);\n-\n-\t\t// copy row IDs\n-\t\tfor (idx_t i = copy_start; i < copy_end; i++) {\n-\t\t\tsegment.get().row_ids[i - 1] = segment.get().row_ids[i];\n-\t\t\tcopy_idx++;\n+\tauto last_idx = leaf.get().count;\n+\tauto last_row_id = leaf.get().row_ids[last_idx - 1];\n+\n+\t// only one row ID in this leaf segment, free it\n+\tif (leaf.get().count == 1) {\n+\t\tNode::Free(art, prev_leaf.get().ptr);\n+\t\tif (last_row_id == row_id) {\n+\t\t\treturn false;\n \t\t}\n+\t} else {\n+\t\tleaf.get().count--;\n+\t}\n \n-\t\t// adjust loop variables\n-\t\tif (segment.get().next.IsSet()) {\n-\t\t\tprev_segment = segment;\n-\t\t\tsegment = LeafSegment::Get(art, segment.get().next);\n-\t\t\t// this segment has at least one element, and we need to copy it into the previous segment\n-\t\t\tprev_segment.get().row_ids[Node::LEAF_SEGMENT_SIZE - 1] = segment.get().row_ids[0];\n-\t\t\tcopy_idx++;\n+\t// find the row ID and copy the last row ID to that position\n+\twhile (node.get().IsSet()) {\n+\t\tD_ASSERT(!node.get().IsSerialized());\n+\t\tleaf = Leaf::Get(art, node);\n+\t\tfor (idx_t i = 0; i < leaf.get().count; i++) {\n+\t\t\tif (leaf.get().row_ids[i] == row_id) {\n+\t\t\t\tleaf.get().row_ids[i] = last_row_id;\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t}\n+\t\tnode = leaf.get().ptr;\n \t}\n+\treturn false;\n+}\n \n-\t// this evaluates to true, if we need to delete the last segment\n-\tif (count % Node::LEAF_SEGMENT_SIZE == 1) {\n-\t\tptr = row_ids.ptr;\n-\t\twhile (ptr.IsSet()) {\n+idx_t Leaf::TotalCount(ART &art, Node &node) {\n \n-\t\t\t// get the segment succeeding the current segment\n-\t\t\tauto &current_segment = LeafSegment::Get(art, ptr);\n-\t\t\tD_ASSERT(current_segment.next.IsSet());\n-\t\t\tauto &next_segment = LeafSegment::Get(art, current_segment.next);\n+\t// NOTE: first leaf in the leaf chain is already deserialized\n+\tD_ASSERT(node.IsSet() && !node.IsSerialized());\n \n-\t\t\t// next_segment is the tail of the segment list\n-\t\t\tif (!next_segment.next.IsSet()) {\n-\t\t\t\tNode::Free(art, current_segment.next);\n-\t\t\t}\n+\tif (node.GetType() == NType::LEAF_INLINED) {\n+\t\treturn 1;\n+\t}\n \n-\t\t\t// adjust loop variables\n-\t\t\tptr = current_segment.next;\n+\tidx_t count = 0;\n+\treference<Node> node_ref(node);\n+\twhile (node_ref.get().IsSet()) {\n+\t\tauto &leaf = Leaf::Get(art, node_ref);\n+\t\tcount += leaf.count;\n+\n+\t\tif (leaf.ptr.IsSerialized()) {\n+\t\t\tleaf.ptr.Deserialize(art);\n \t\t}\n+\t\tnode_ref = leaf.ptr;\n \t}\n-\tcount--;\n+\treturn count;\n }\n \n-row_t Leaf::GetRowId(const ART &art, const idx_t position) const {\n+bool Leaf::GetRowIds(ART &art, Node &node, vector<row_t> &result_ids, idx_t max_count) {\n \n-\tD_ASSERT(position < count);\n-\tif (IsInlined()) {\n-\t\treturn row_ids.inlined;\n+\t// adding more elements would exceed the maximum count\n+\tD_ASSERT(node.IsSet());\n+\tif (result_ids.size() + Leaf::TotalCount(art, node) > max_count) {\n+\t\treturn false;\n \t}\n \n-\t// get the correct segment\n-\treference<LeafSegment> segment(LeafSegment::Get(art, row_ids.ptr));\n-\tfor (idx_t i = 0; i < position / Node::LEAF_SEGMENT_SIZE; i++) {\n-\t\tD_ASSERT(segment.get().next.IsSet());\n-\t\tsegment = LeafSegment::Get(art, segment.get().next);\n+\t// NOTE: Leaf::TotalCount fully deserializes the leaf\n+\tD_ASSERT(!node.IsSerialized());\n+\n+\tif (node.GetType() == NType::LEAF_INLINED) {\n+\t\t// push back the inlined row ID of this leaf\n+\t\tresult_ids.push_back(node.GetRowId());\n+\n+\t} else {\n+\t\t// push back all the row IDs of this leaf\n+\t\treference<Node> last_leaf_ref(node);\n+\t\twhile (last_leaf_ref.get().IsSet()) {\n+\t\t\tauto &leaf = Leaf::Get(art, last_leaf_ref);\n+\t\t\tfor (idx_t i = 0; i < leaf.count; i++) {\n+\t\t\t\tresult_ids.push_back(leaf.row_ids[i]);\n+\t\t\t}\n+\n+\t\t\tD_ASSERT(!leaf.ptr.IsSerialized());\n+\t\t\tlast_leaf_ref = leaf.ptr;\n+\t\t}\n \t}\n \n-\treturn segment.get().row_ids[position % Node::LEAF_SEGMENT_SIZE];\n+\treturn true;\n }\n \n-uint32_t Leaf::FindRowId(const ART &art, Node &ptr, const row_t row_id) const {\n-\n-\tD_ASSERT(!IsInlined());\n+bool Leaf::ContainsRowId(ART &art, Node &node, const row_t row_id) {\n \n-\tauto remaining = count;\n-\twhile (ptr.IsSet()) {\n+\t// NOTE: we either just removed a row ID from this leaf (by copying the\n+\t// last row ID at a different position) or inserted a row ID into this leaf\n+\t// (at the end), so the whole leaf is deserialized\n+\tD_ASSERT(node.IsSet() && !node.IsSerialized());\n \n-\t\tauto &segment = LeafSegment::Get(art, ptr);\n-\t\tauto search_count = MinValue(Node::LEAF_SEGMENT_SIZE, remaining);\n+\tif (node.GetType() == NType::LEAF_INLINED) {\n+\t\treturn node.GetRowId() == row_id;\n+\t}\n \n-\t\t// search in this segment\n-\t\tfor (idx_t i = 0; i < search_count; i++) {\n-\t\t\tif (segment.row_ids[i] == row_id) {\n-\t\t\t\treturn count - remaining + i;\n+\treference<Node> ref_node(node);\n+\twhile (ref_node.get().IsSet()) {\n+\t\tauto &leaf = Leaf::Get(art, ref_node);\n+\t\tfor (idx_t i = 0; i < leaf.count; i++) {\n+\t\t\tif (leaf.row_ids[i] == row_id) {\n+\t\t\t\treturn true;\n \t\t\t}\n \t\t}\n \n-\t\t// adjust loop variables\n-\t\tremaining -= search_count;\n-\t\tptr = segment.next;\n+\t\tD_ASSERT(!leaf.ptr.IsSerialized());\n+\t\tref_node = leaf.ptr;\n \t}\n-\treturn (uint32_t)DConstants::INVALID_INDEX;\n+\n+\treturn false;\n }\n \n-string Leaf::VerifyAndToString(const ART &art, const bool only_verify) const {\n+string Leaf::VerifyAndToString(ART &art, Node &node) {\n \n-\tif (IsInlined()) {\n-\t\treturn only_verify ? \"\" : \"Leaf [count: 1, row ID: \" + to_string(row_ids.inlined) + \"]\";\n+\tif (node.GetType() == NType::LEAF_INLINED) {\n+\t\treturn \"Leaf [count: 1, row ID: \" + to_string(node.GetRowId()) + \"]\";\n \t}\n \n-\tauto ptr = row_ids.ptr;\n-\tauto remaining = count;\n+\t// NOTE: we could do this recursively, but the function-call overhead can become kinda crazy\n \tstring str = \"\";\n-\tuint32_t this_count = 0;\n-\twhile (ptr.IsSet()) {\n-\t\tauto &segment = LeafSegment::Get(art, ptr);\n-\t\tauto to_string_count = Node::LEAF_SEGMENT_SIZE < remaining ? Node::LEAF_SEGMENT_SIZE : remaining;\n-\n-\t\tfor (idx_t i = 0; i < to_string_count; i++) {\n-\t\t\tstr += \", \" + to_string(segment.row_ids[i]);\n-\t\t\tthis_count++;\n+\n+\treference<Node> node_ref(node);\n+\twhile (node_ref.get().IsSet()) {\n+\n+\t\tauto &leaf = Leaf::Get(art, node_ref);\n+\t\tD_ASSERT(leaf.count <= Node::LEAF_SIZE);\n+\n+\t\tstr += \"Leaf [count: \" + to_string(leaf.count) + \", row IDs: \";\n+\t\tfor (idx_t i = 0; i < leaf.count; i++) {\n+\t\t\tstr += to_string(leaf.row_ids[i]) + \"-\";\n \t\t}\n-\t\tremaining -= to_string_count;\n-\t\tptr = segment.next;\n-\t}\n+\t\tstr += \"] \";\n \n-\tD_ASSERT(remaining == 0);\n-\t(void)this_count;\n-\tD_ASSERT(this_count == count);\n-\treturn only_verify ? \"\" : \"Leaf [count: \" + to_string(count) + \", row IDs: \" + str + \"] \\n\";\n+\t\t// NOTE: we are currently only calling this function during CREATE INDEX\n+\t\t// statements (and debugging), so the index is never serialized\n+\t\tD_ASSERT(!leaf.ptr.IsSerialized());\n+\t\tnode_ref = leaf.ptr;\n+\t}\n+\treturn str;\n }\n \n-BlockPointer Leaf::Serialize(const ART &art, MetaBlockWriter &writer) const {\n-\n-\t// get pointer and write fields\n-\tauto block_pointer = writer.GetBlockPointer();\n-\twriter.Write(NType::LEAF);\n-\twriter.Write<uint32_t>(count);\n+BlockPointer Leaf::Serialize(ART &art, Node &node, MetaBlockWriter &writer) {\n \n-\tif (IsInlined()) {\n-\t\twriter.Write(row_ids.inlined);\n+\tif (node.GetType() == NType::LEAF_INLINED) {\n+\t\tauto block_pointer = writer.GetBlockPointer();\n+\t\twriter.Write(NType::LEAF_INLINED);\n+\t\twriter.Write(node.GetRowId());\n \t\treturn block_pointer;\n \t}\n \n-\tD_ASSERT(row_ids.ptr.IsSet());\n-\tauto ptr = row_ids.ptr;\n-\tauto remaining = count;\n-\n-\t// iterate all leaf segments and write their row IDs\n-\twhile (ptr.IsSet()) {\n-\t\tauto &segment = LeafSegment::Get(art, ptr);\n-\t\tauto write_count = MinValue(Node::LEAF_SEGMENT_SIZE, remaining);\n+\t// recurse into the child and retrieve its block pointer\n+\tauto &leaf = Leaf::Get(art, node);\n+\tauto child_block_pointer = leaf.ptr.Serialize(art, writer);\n \n-\t\t// write the row IDs\n-\t\tfor (idx_t i = 0; i < write_count; i++) {\n-\t\t\twriter.Write(segment.row_ids[i]);\n-\t\t}\n+\t// get pointer and write fields\n+\tauto block_pointer = writer.GetBlockPointer();\n+\twriter.Write(NType::LEAF);\n+\twriter.Write<uint8_t>(leaf.count);\n \n-\t\t// adjust loop variables\n-\t\tremaining -= write_count;\n-\t\tptr = segment.next;\n+\t// write row IDs\n+\tfor (idx_t i = 0; i < leaf.count; i++) {\n+\t\twriter.Write(leaf.row_ids[i]);\n \t}\n-\tD_ASSERT(remaining == 0);\n+\n+\t// write child block pointer\n+\twriter.Write(child_block_pointer.block_id);\n+\twriter.Write(child_block_pointer.offset);\n \n \treturn block_pointer;\n }\n \n-void Leaf::Deserialize(ART &art, MetaBlockReader &reader) {\n+void Leaf::Deserialize(ART &art, Node &node, MetaBlockReader &reader) {\n \n-\tauto count_p = reader.Read<uint32_t>();\n+\tD_ASSERT(node.GetType() == NType::LEAF);\n \n-\t// inlined\n-\tif (count_p == 1) {\n-\t\trow_ids.inlined = reader.Read<row_t>();\n-\t\tcount = count_p;\n-\t\treturn;\n-\t}\n+\tauto &leaf = Leaf::Get(art, node);\n+\tleaf.count = reader.Read<uint8_t>();\n \n-\t// copy into segments\n-\tcount = 0;\n-\treference<LeafSegment> segment(LeafSegment::New(art, row_ids.ptr));\n-\tfor (idx_t i = 0; i < count_p; i++) {\n-\t\tsegment = segment.get().Append(art, count, reader.Read<row_t>());\n+\t// read row IDs\n+\tfor (idx_t i = 0; i < leaf.count; i++) {\n+\t\tleaf.row_ids[i] = reader.Read<row_t>();\n \t}\n-\tD_ASSERT(count_p == count);\n-}\n \n-void Leaf::Vacuum(ART &art) {\n+\t// read child block pointer\n+\tleaf.ptr = Node(reader);\n+}\n \n-\tif (IsInlined()) {\n-\t\treturn;\n-\t}\n+void Leaf::Vacuum(ART &art, Node &node) {\n \n-\t// first pointer has special treatment because we don't obtain it from a leaf segment\n-\tauto &allocator = Node::GetAllocator(art, NType::LEAF_SEGMENT);\n-\tif (allocator.NeedsVacuum(row_ids.ptr)) {\n-\t\trow_ids.ptr.SetPtr(allocator.VacuumPointer(row_ids.ptr));\n-\t\trow_ids.ptr.type = (uint8_t)NType::LEAF_SEGMENT;\n-\t}\n+\t// NOTE: we could do this recursively, but the function-call overhead can become kinda crazy\n+\tauto &allocator = Node::GetAllocator(art, NType::LEAF);\n \n-\tauto ptr = row_ids.ptr;\n-\twhile (ptr.IsSet()) {\n-\t\tauto &segment = LeafSegment::Get(art, ptr);\n-\t\tptr = segment.next;\n-\t\tif (ptr.IsSet() && allocator.NeedsVacuum(ptr)) {\n-\t\t\tsegment.next.SetPtr(allocator.VacuumPointer(ptr));\n-\t\t\tsegment.next.type = (uint8_t)NType::LEAF_SEGMENT;\n-\t\t\tptr = segment.next;\n+\treference<Node> node_ref(node);\n+\twhile (node_ref.get().IsSet() && !node_ref.get().IsSerialized()) {\n+\t\tif (allocator.NeedsVacuum(node_ref)) {\n+\t\t\tnode_ref.get() = allocator.VacuumPointer(node_ref);\n+\t\t\tnode_ref.get().SetType((uint8_t)NType::LEAF);\n \t\t}\n+\t\tauto &leaf = Leaf::Get(art, node_ref);\n+\t\tnode_ref = leaf.ptr;\n \t}\n+\treturn;\n+}\n+\n+void Leaf::MoveInlinedToLeaf(ART &art, Node &node) {\n+\n+\tD_ASSERT(node.GetType() == NType::LEAF_INLINED);\n+\tauto row_id = node.GetRowId();\n+\tnode = Node::GetAllocator(art, NType::LEAF).New();\n+\tnode.SetType((uint8_t)NType::LEAF);\n+\n+\tauto &leaf = Leaf::Get(art, node);\n+\tleaf.count = 1;\n+\tleaf.row_ids[0] = row_id;\n+\tleaf.ptr.Reset();\n }\n \n-void Leaf::MoveInlinedToSegment(ART &art) {\n+Leaf &Leaf::Append(ART &art, const row_t row_id) {\n+\n+\treference<Leaf> leaf(*this);\n \n-\tD_ASSERT(IsInlined());\n+\t// we need a new leaf node\n+\tif (leaf.get().count == Node::LEAF_SIZE) {\n+\t\tleaf.get().ptr = Node::GetAllocator(art, NType::LEAF).New();\n+\t\tleaf.get().ptr.SetType((uint8_t)NType::LEAF);\n+\n+\t\tleaf = Leaf::Get(art, leaf.get().ptr);\n+\t\tleaf.get().count = 0;\n+\t\tleaf.get().ptr.Reset();\n+\t}\n \n-\tauto row_id = row_ids.inlined;\n-\tauto &segment = LeafSegment::New(art, row_ids.ptr);\n-\tsegment.row_ids[0] = row_id;\n+\tleaf.get().row_ids[leaf.get().count] = row_id;\n+\tleaf.get().count++;\n+\treturn leaf.get();\n }\n \n } // namespace duckdb\ndiff --git a/src/execution/index/art/leaf_segment.cpp b/src/execution/index/art/leaf_segment.cpp\ndeleted file mode 100644\nindex 89d3d7c748e2..000000000000\n--- a/src/execution/index/art/leaf_segment.cpp\n+++ /dev/null\n@@ -1,52 +0,0 @@\n-#include \"duckdb/execution/index/art/leaf_segment.hpp\"\n-\n-#include \"duckdb/execution/index/art/art.hpp\"\n-#include \"duckdb/execution/index/art/node.hpp\"\n-\n-namespace duckdb {\n-\n-LeafSegment &LeafSegment::New(ART &art, Node &node) {\n-\n-\tnode.SetPtr(Node::GetAllocator(art, NType::LEAF_SEGMENT).New());\n-\tnode.type = (uint8_t)NType::LEAF_SEGMENT;\n-\n-\tauto &segment = LeafSegment::Get(art, node);\n-\tsegment.next.Reset();\n-\treturn segment;\n-}\n-\n-void LeafSegment::Free(ART &art, Node &node) {\n-\n-\tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n-\n-\t// free next segment\n-\tauto next_segment = LeafSegment::Get(art, node).next;\n-\tNode::Free(art, next_segment);\n-}\n-\n-LeafSegment &LeafSegment::Append(ART &art, uint32_t &count, const row_t row_id) {\n-\n-\treference<LeafSegment> segment(*this);\n-\tauto position = count % Node::LEAF_SEGMENT_SIZE;\n-\n-\t// we need a new segment\n-\tif (position == 0 && count != 0) {\n-\t\tsegment = LeafSegment::New(art, next);\n-\t}\n-\n-\tsegment.get().row_ids[position] = row_id;\n-\tcount++;\n-\treturn segment.get();\n-}\n-\n-LeafSegment &LeafSegment::GetTail(const ART &art) {\n-\n-\treference<LeafSegment> segment(*this);\n-\twhile (segment.get().next.IsSet()) {\n-\t\tsegment = LeafSegment::Get(art, segment.get().next);\n-\t}\n-\treturn segment.get();\n-}\n-\n-} // namespace duckdb\ndiff --git a/src/execution/index/art/node.cpp b/src/execution/index/art/node.cpp\nindex fbc80e1be3ff..36f5d0b6c5a2 100644\n--- a/src/execution/index/art/node.cpp\n+++ b/src/execution/index/art/node.cpp\n@@ -8,7 +8,6 @@\n #include \"duckdb/execution/index/art/node16.hpp\"\n #include \"duckdb/execution/index/art/node4.hpp\"\n #include \"duckdb/execution/index/art/leaf.hpp\"\n-#include \"duckdb/execution/index/art/leaf_segment.hpp\"\n #include \"duckdb/execution/index/art/prefix.hpp\"\n #include \"duckdb/storage/meta_block_reader.hpp\"\n #include \"duckdb/storage/meta_block_writer.hpp\"\n@@ -20,12 +19,24 @@ namespace duckdb {\n // Constructors / Destructors\n //===--------------------------------------------------------------------===//\n \n-Node::Node() : SwizzleablePointer() {\n-}\n+Node::Node(MetaBlockReader &reader) {\n+\n+\tidx_t block_id = reader.Read<block_id_t>();\n+\tauto offset = reader.Read<uint32_t>();\n+\tReset();\n+\n+\tif (block_id == DConstants::INVALID_INDEX) {\n+\t\treturn;\n+\t}\n \n-Node::Node(MetaBlockReader &reader) : SwizzleablePointer(reader) {\n+\tSetSerialized();\n+\tSetPtr(block_id, offset);\n }\n \n+//===--------------------------------------------------------------------===//\n+// New / Free\n+//===--------------------------------------------------------------------===//\n+\n void Node::New(ART &art, Node &node, const NType type) {\n \n \t// NOTE: leaves and prefixes should not pass through this function\n@@ -50,22 +61,19 @@ void Node::New(ART &art, Node &node, const NType type) {\n \n void Node::Free(ART &art, Node &node) {\n \n-\t// recursively free all nodes that are in-memory, and skip swizzled and empty nodes\n+\t// recursively free all nodes that are in-memory, and skip serialized and empty nodes\n \tif (!node.IsSet()) {\n \t\treturn;\n \t}\n \n-\tif (!node.IsSwizzled()) {\n+\tif (!node.IsSerialized()) {\n \n \t\t// free the children of the nodes\n-\t\tauto type = node.DecodeARTNodeType();\n+\t\tauto type = node.GetType();\n \t\tswitch (type) {\n \t\tcase NType::PREFIX:\n \t\t\tPrefix::Free(art, node);\n \t\t\tbreak;\n-\t\tcase NType::LEAF_SEGMENT:\n-\t\t\tLeafSegment::Free(art, node);\n-\t\t\tbreak;\n \t\tcase NType::LEAF:\n \t\t\tLeaf::Free(art, node);\n \t\t\tbreak;\n@@ -81,6 +89,9 @@ void Node::Free(ART &art, Node &node) {\n \t\tcase NType::NODE_256:\n \t\t\tNode256::Free(art, node);\n \t\t\tbreak;\n+\t\tcase NType::LEAF_INLINED:\n+\t\t\tnode.Reset();\n+\t\t\treturn;\n \t\t}\n \n \t\tNode::GetAllocator(art, type).Free(node);\n@@ -96,9 +107,9 @@ void Node::Free(ART &art, Node &node) {\n \n void Node::ReplaceChild(const ART &art, const uint8_t byte, const Node child) {\n \n-\tD_ASSERT(!IsSwizzled());\n+\tD_ASSERT(!IsSerialized());\n \n-\tswitch (DecodeARTNodeType()) {\n+\tswitch (GetType()) {\n \tcase NType::NODE_4:\n \t\treturn Node4::Get(art, *this).ReplaceChild(byte, child);\n \tcase NType::NODE_16:\n@@ -114,7 +125,7 @@ void Node::ReplaceChild(const ART &art, const uint8_t byte, const Node child) {\n \n void Node::InsertChild(ART &art, Node &node, const uint8_t byte, const Node child) {\n \n-\tswitch (node.DecodeARTNodeType()) {\n+\tswitch (node.GetType()) {\n \tcase NType::NODE_4:\n \t\treturn Node4::InsertChild(art, node, byte, child);\n \tcase NType::NODE_16:\n@@ -134,7 +145,7 @@ void Node::InsertChild(ART &art, Node &node, const uint8_t byte, const Node chil\n \n void Node::DeleteChild(ART &art, Node &node, Node &prefix, const uint8_t byte) {\n \n-\tswitch (node.DecodeARTNodeType()) {\n+\tswitch (node.GetType()) {\n \tcase NType::NODE_4:\n \t\treturn Node4::DeleteChild(art, node, prefix, byte);\n \tcase NType::NODE_16:\n@@ -154,10 +165,10 @@ void Node::DeleteChild(ART &art, Node &node, Node &prefix, const uint8_t byte) {\n \n optional_ptr<Node> Node::GetChild(ART &art, const uint8_t byte) const {\n \n-\tD_ASSERT(IsSet() && !IsSwizzled());\n+\tD_ASSERT(IsSet() && !IsSerialized());\n \n \toptional_ptr<Node> child;\n-\tswitch (DecodeARTNodeType()) {\n+\tswitch (GetType()) {\n \tcase NType::NODE_4:\n \t\tchild = Node4::Get(art, *this).GetChild(byte);\n \t\tbreak;\n@@ -175,7 +186,7 @@ optional_ptr<Node> Node::GetChild(ART &art, const uint8_t byte) const {\n \t}\n \n \t// deserialize the ART node before returning it\n-\tif (child && child->IsSwizzled()) {\n+\tif (child && child->IsSerialized()) {\n \t\tchild->Deserialize(art);\n \t}\n \treturn child;\n@@ -183,10 +194,10 @@ optional_ptr<Node> Node::GetChild(ART &art, const uint8_t byte) const {\n \n optional_ptr<Node> Node::GetNextChild(ART &art, uint8_t &byte, const bool deserialize) const {\n \n-\tD_ASSERT(IsSet() && !IsSwizzled());\n+\tD_ASSERT(IsSet() && !IsSerialized());\n \n \toptional_ptr<Node> child;\n-\tswitch (DecodeARTNodeType()) {\n+\tswitch (GetType()) {\n \tcase NType::NODE_4:\n \t\tchild = Node4::Get(art, *this).GetNextChild(byte);\n \t\tbreak;\n@@ -204,7 +215,7 @@ optional_ptr<Node> Node::GetNextChild(ART &art, uint8_t &byte, const bool deseri\n \t}\n \n \t// deserialize the ART node before returning it\n-\tif (child && deserialize && child->IsSwizzled()) {\n+\tif (child && deserialize && child->IsSerialized()) {\n \t\tchild->Deserialize(art);\n \t}\n \treturn child;\n@@ -219,15 +230,15 @@ BlockPointer Node::Serialize(ART &art, MetaBlockWriter &writer) {\n \tif (!IsSet()) {\n \t\treturn {(block_id_t)DConstants::INVALID_INDEX, 0};\n \t}\n-\tif (IsSwizzled()) {\n+\tif (IsSerialized()) {\n \t\tDeserialize(art);\n \t}\n \n-\tswitch (DecodeARTNodeType()) {\n+\tswitch (GetType()) {\n \tcase NType::PREFIX:\n \t\treturn Prefix::Get(art, *this).Serialize(art, writer);\n \tcase NType::LEAF:\n-\t\treturn Leaf::Get(art, *this).Serialize(art, writer);\n+\t\treturn Leaf::Serialize(art, *this, writer);\n \tcase NType::NODE_4:\n \t\treturn Node4::Get(art, *this).Serialize(art, writer);\n \tcase NType::NODE_16:\n@@ -236,27 +247,35 @@ BlockPointer Node::Serialize(ART &art, MetaBlockWriter &writer) {\n \t\treturn Node48::Get(art, *this).Serialize(art, writer);\n \tcase NType::NODE_256:\n \t\treturn Node256::Get(art, *this).Serialize(art, writer);\n-\tdefault:\n-\t\tthrow InternalException(\"Invalid node type for Serialize.\");\n+\tcase NType::LEAF_INLINED:\n+\t\treturn Leaf::Serialize(art, *this, writer);\n \t}\n+\tthrow InternalException(\"Invalid node type for Serialize.\");\n }\n \n void Node::Deserialize(ART &art) {\n \n-\tMetaBlockReader reader(art.table_io_manager.GetIndexBlockManager(), buffer_id);\n-\treader.offset = offset;\n-\ttype = reader.Read<uint8_t>();\n-\tswizzle_flag = 0;\n+\tD_ASSERT(IsSet() && IsSerialized());\n+\n+\tMetaBlockReader reader(art.table_io_manager.GetIndexBlockManager(), GetBufferId());\n+\treader.offset = GetOffset();\n+\tReset();\n+\tSetType(reader.Read<uint8_t>());\n+\n+\tauto decoded_type = GetType();\n+\tif (decoded_type == NType::LEAF_INLINED) {\n+\t\tSetRowId(reader.Read<row_t>());\n+\t\treturn;\n+\t}\n \n-\tauto decoded_type = DecodeARTNodeType();\n-\tSetPtr(Node::GetAllocator(art, decoded_type).New());\n-\ttype = (uint8_t)decoded_type;\n+\t*this = Node::GetAllocator(art, decoded_type).New();\n+\tSetType((uint8_t)decoded_type);\n \n \tswitch (decoded_type) {\n \tcase NType::PREFIX:\n \t\treturn Prefix::Get(art, *this).Deserialize(reader);\n \tcase NType::LEAF:\n-\t\treturn Leaf::Get(art, *this).Deserialize(art, reader);\n+\t\treturn Leaf::Deserialize(art, *this, reader);\n \tcase NType::NODE_4:\n \t\treturn Node4::Get(art, *this).Deserialize(reader);\n \tcase NType::NODE_16:\n@@ -277,32 +296,27 @@ void Node::Deserialize(ART &art) {\n string Node::VerifyAndToString(ART &art, const bool only_verify) {\n \n \tD_ASSERT(IsSet());\n-\tif (IsSwizzled()) {\n-\t\treturn only_verify ? \"\" : \"swizzled\";\n+\tif (IsSerialized()) {\n+\t\treturn only_verify ? \"\" : \"serialized\";\n \t}\n \n-\tauto type = DecodeARTNodeType();\n-\tif (type == NType::LEAF) {\n-\t\tauto str = Leaf::Get(art, *this).VerifyAndToString(art, only_verify);\n+\tif (GetType() == NType::LEAF || GetType() == NType::LEAF_INLINED) {\n+\t\tauto str = Leaf::VerifyAndToString(art, *this);\n \t\treturn only_verify ? \"\" : \"\\n\" + str;\n \t}\n-\tif (type == NType::PREFIX) {\n-\t\tauto str = Prefix::Get(art, *this).VerifyAndToString(art, only_verify);\n+\tif (GetType() == NType::PREFIX) {\n+\t\tauto str = Prefix::Get(art, *this).VerifyAndToString(art, *this, only_verify);\n \t\treturn only_verify ? \"\" : \"\\n\" + str;\n \t}\n \n \tstring str = \"Node\" + to_string(GetCapacity()) + \": [\";\n-\n-\tidx_t child_count = 0;\n \tuint8_t byte = 0;\n \tauto child = GetNextChild(art, byte, false);\n \n \twhile (child) {\n-\n-\t\tchild_count++;\n-\t\tif (child->IsSwizzled()) {\n+\t\tif (child->IsSerialized()) {\n \t\t\tif (!only_verify) {\n-\t\t\t\tstr += \"(swizzled)\";\n+\t\t\t\tstr += \"(serialized)\";\n \t\t\t}\n \t\t} else {\n \t\t\tstr += \"(\" + to_string(byte) + \", \" + child->VerifyAndToString(art, only_verify) + \")\";\n@@ -315,17 +329,14 @@ string Node::VerifyAndToString(ART &art, const bool only_verify) {\n \t\tchild = GetNextChild(art, byte, false);\n \t}\n \n-\t(void)child_count;\n-\t// ensure that the child count is at least two\n-\tD_ASSERT(child_count > 1);\n \treturn only_verify ? \"\" : \"\\n\" + str + \"]\";\n }\n \n idx_t Node::GetCapacity() const {\n \n-\tD_ASSERT(!IsSwizzled());\n+\tD_ASSERT(!IsSerialized());\n \n-\tswitch (DecodeARTNodeType()) {\n+\tswitch (GetType()) {\n \tcase NType::NODE_4:\n \t\treturn Node::NODE_4_CAPACITY;\n \tcase NType::NODE_16:\n@@ -362,19 +373,14 @@ FixedSizeAllocator &Node::GetAllocator(const ART &art, NType type) {\n void Node::InitializeMerge(ART &art, const ARTFlags &flags) {\n \n \t// the index is fully in memory during CREATE [UNIQUE] INDEX statements\n-\tD_ASSERT(IsSet() && !IsSwizzled());\n+\tD_ASSERT(IsSet() && !IsSerialized());\n \n-\tauto type = DecodeARTNodeType();\n-\tswitch (type) {\n+\tswitch (GetType()) {\n \tcase NType::PREFIX:\n \t\tPrefix::Get(art, *this).InitializeMerge(art, flags);\n \t\tbreak;\n \tcase NType::LEAF:\n-\t\t// if not all leaves are inlined\n-\t\tif (flags.merge_buffer_counts[(uint8_t)NType::LEAF_SEGMENT - 1] != 0) {\n-\t\t\t// initialize leaf segments\n-\t\t\tLeaf::Get(art, *this).InitializeMerge(art, flags.merge_buffer_counts[(uint8_t)NType::LEAF_SEGMENT - 1]);\n-\t\t}\n+\t\tLeaf::InitializeMerge(art, *this, flags);\n \t\tbreak;\n \tcase NType::NODE_4:\n \t\tNode4::Get(art, *this).InitializeMerge(art, flags);\n@@ -388,11 +394,12 @@ void Node::InitializeMerge(ART &art, const ARTFlags &flags) {\n \tcase NType::NODE_256:\n \t\tNode256::Get(art, *this).InitializeMerge(art, flags);\n \t\tbreak;\n-\tdefault:\n-\t\tthrow InternalException(\"Invalid node type for InitializeMerge.\");\n+\tcase NType::LEAF_INLINED:\n+\t\treturn;\n \t}\n \n-\tbuffer_id += flags.merge_buffer_counts[(uint8_t)type - 1];\n+\t// NOTE: this works because the rightmost 32 bits contain the buffer ID\n+\tdata += flags.merge_buffer_counts[(uint8_t)GetType() - 1];\n }\n \n bool Node::Merge(ART &art, Node &other) {\n@@ -412,7 +419,7 @@ bool MergePrefixContainsOtherPrefix(ART &art, reference<Node> &l_node, reference\n \t// r_node's prefix contains l_node's prefix\n \t// l_node cannot be a leaf, otherwise the key represented by l_node would be a subset of another key\n \t// which is not possible by our construction\n-\tD_ASSERT(l_node.get().DecodeARTNodeType() != NType::LEAF);\n+\tD_ASSERT(l_node.get().GetType() != NType::LEAF && l_node.get().GetType() != NType::LEAF_INLINED);\n \n \t// test if the next byte (mismatch_position) in r_node (prefix) exists in l_node\n \tauto mismatch_byte = Prefix::GetByte(art, r_node, mismatch_position);\n@@ -454,11 +461,10 @@ bool Node::ResolvePrefixes(ART &art, Node &other) {\n \n \t// NOTE: we always merge into the left ART\n \n-\tD_ASSERT(IsSet());\n-\tD_ASSERT(other.IsSet());\n+\tD_ASSERT(IsSet() && other.IsSet());\n \n \t// case 1: both nodes have no prefix\n-\tif (DecodeARTNodeType() != NType::PREFIX && other.DecodeARTNodeType() != NType::PREFIX) {\n+\tif (GetType() != NType::PREFIX && other.GetType() != NType::PREFIX) {\n \t\treturn MergeInternal(art, other);\n \t}\n \n@@ -468,7 +474,7 @@ bool Node::ResolvePrefixes(ART &art, Node &other) {\n \tidx_t mismatch_position = DConstants::INVALID_INDEX;\n \n \t// traverse prefixes\n-\tif (l_node.get().DecodeARTNodeType() == NType::PREFIX && r_node.get().DecodeARTNodeType() == NType::PREFIX) {\n+\tif (l_node.get().GetType() == NType::PREFIX && r_node.get().GetType() == NType::PREFIX) {\n \n \t\tif (!Prefix::Traverse(art, l_node, r_node, mismatch_position)) {\n \t\t\treturn false;\n@@ -481,7 +487,7 @@ bool Node::ResolvePrefixes(ART &art, Node &other) {\n \t} else {\n \n \t\t// l_prefix contains r_prefix\n-\t\tif (l_node.get().DecodeARTNodeType() == NType::PREFIX) {\n+\t\tif (l_node.get().GetType() == NType::PREFIX) {\n \t\t\tswap(*this, other);\n \t\t}\n \t\tmismatch_position = 0;\n@@ -489,7 +495,7 @@ bool Node::ResolvePrefixes(ART &art, Node &other) {\n \tD_ASSERT(mismatch_position != DConstants::INVALID_INDEX);\n \n \t// case 2: one prefix contains the other prefix\n-\tif (l_node.get().DecodeARTNodeType() != NType::PREFIX && r_node.get().DecodeARTNodeType() == NType::PREFIX) {\n+\tif (l_node.get().GetType() != NType::PREFIX && r_node.get().GetType() == NType::PREFIX) {\n \t\treturn MergePrefixContainsOtherPrefix(art, l_node, r_node, mismatch_position);\n \t}\n \n@@ -501,13 +507,12 @@ bool Node::ResolvePrefixes(ART &art, Node &other) {\n bool Node::MergeInternal(ART &art, Node &other) {\n \n \tD_ASSERT(IsSet() && other.IsSet());\n-\tD_ASSERT(DecodeARTNodeType() != NType::PREFIX && DecodeARTNodeType() != NType::LEAF_SEGMENT);\n-\tD_ASSERT(other.DecodeARTNodeType() != NType::PREFIX && other.DecodeARTNodeType() != NType::LEAF_SEGMENT);\n+\tD_ASSERT(GetType() != NType::PREFIX && other.GetType() != NType::PREFIX);\n \n \t// always try to merge the smaller node into the bigger node\n \t// because maybe there is enough free space in the bigger node to fit the smaller one\n \t// without too much recursion\n-\tif (DecodeARTNodeType() < other.DecodeARTNodeType()) {\n+\tif (GetType() < other.GetType()) {\n \t\tswap(*this, other);\n \t}\n \n@@ -515,14 +520,14 @@ bool Node::MergeInternal(ART &art, Node &other) {\n \tauto &l_node = *this;\n \tauto &r_node = other;\n \n-\tif (r_node.DecodeARTNodeType() == NType::LEAF) {\n-\t\tD_ASSERT(l_node.DecodeARTNodeType() == NType::LEAF);\n+\tif (r_node.GetType() == NType::LEAF || r_node.GetType() == NType::LEAF_INLINED) {\n+\t\tD_ASSERT(l_node.GetType() == NType::LEAF || l_node.GetType() == NType::LEAF_INLINED);\n \n \t\tif (art.IsUnique()) {\n \t\t\treturn false;\n \t\t}\n \n-\t\tLeaf::Get(art, l_node).Merge(art, r_node);\n+\t\tLeaf::Merge(art, l_node, r_node);\n \t\treturn true;\n \t}\n \n@@ -559,38 +564,42 @@ bool Node::MergeInternal(ART &art, Node &other) {\n // Vacuum\n //===--------------------------------------------------------------------===//\n \n-void Node::Vacuum(ART &art, Node &node, const ARTFlags &flags) {\n+void Node::Vacuum(ART &art, const ARTFlags &flags) {\n \n-\tif (node.IsSwizzled()) {\n+\tD_ASSERT(IsSet());\n+\tif (IsSerialized()) {\n \t\treturn;\n \t}\n \n-\tauto type = node.DecodeARTNodeType();\n-\tauto &allocator = Node::GetAllocator(art, type);\n-\tauto needs_vacuum = flags.vacuum_flags[node.type - 1] && allocator.NeedsVacuum(node);\n-\tif (needs_vacuum) {\n-\t\tnode.SetPtr(allocator.VacuumPointer(node));\n-\t\tnode.type = (uint8_t)type;\n+\tauto node_type = GetType();\n+\tif (node_type == NType::LEAF_INLINED) {\n+\t\treturn;\n \t}\n-\n-\tswitch (type) {\n-\tcase NType::PREFIX:\n-\t\treturn Prefix::Get(art, node).Vacuum(art, flags);\n-\tcase NType::LEAF: {\n-\t\t// possibly vacuum leaf segments, if not all leaves are inlined\n-\t\tif (flags.vacuum_flags[(uint8_t)NType::LEAF_SEGMENT - 1]) {\n-\t\t\tLeaf::Get(art, node).Vacuum(art);\n+\tif (node_type == NType::LEAF) {\n+\t\tif (flags.vacuum_flags[(uint8_t)GetType() - 1]) {\n+\t\t\tLeaf::Vacuum(art, *this);\n \t\t}\n \t\treturn;\n \t}\n+\n+\tauto &allocator = Node::GetAllocator(art, node_type);\n+\tauto needs_vacuum = flags.vacuum_flags[(uint8_t)GetType() - 1] && allocator.NeedsVacuum(*this);\n+\tif (needs_vacuum) {\n+\t\t*this = allocator.VacuumPointer(*this);\n+\t\tSetType((uint8_t)node_type);\n+\t}\n+\n+\tswitch (node_type) {\n+\tcase NType::PREFIX:\n+\t\treturn Prefix::Get(art, *this).Vacuum(art, flags);\n \tcase NType::NODE_4:\n-\t\treturn Node4::Get(art, node).Vacuum(art, flags);\n+\t\treturn Node4::Get(art, *this).Vacuum(art, flags);\n \tcase NType::NODE_16:\n-\t\treturn Node16::Get(art, node).Vacuum(art, flags);\n+\t\treturn Node16::Get(art, *this).Vacuum(art, flags);\n \tcase NType::NODE_48:\n-\t\treturn Node48::Get(art, node).Vacuum(art, flags);\n+\t\treturn Node48::Get(art, *this).Vacuum(art, flags);\n \tcase NType::NODE_256:\n-\t\treturn Node256::Get(art, node).Vacuum(art, flags);\n+\t\treturn Node256::Get(art, *this).Vacuum(art, flags);\n \tdefault:\n \t\tthrow InternalException(\"Invalid node type for Vacuum.\");\n \t}\ndiff --git a/src/execution/index/art/node16.cpp b/src/execution/index/art/node16.cpp\nindex 50d53e938b86..a59138127d1c 100644\n--- a/src/execution/index/art/node16.cpp\n+++ b/src/execution/index/art/node16.cpp\n@@ -9,8 +9,8 @@ namespace duckdb {\n \n Node16 &Node16::New(ART &art, Node &node) {\n \n-\tnode.SetPtr(Node::GetAllocator(art, NType::NODE_16).New());\n-\tnode.type = (uint8_t)NType::NODE_16;\n+\tnode = Node::GetAllocator(art, NType::NODE_16).New();\n+\tnode.SetType((uint8_t)NType::NODE_16);\n \tauto &n16 = Node16::Get(art, node);\n \n \tn16.count = 0;\n@@ -20,7 +20,7 @@ Node16 &Node16::New(ART &art, Node &node) {\n void Node16::Free(ART &art, Node &node) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \n \tauto &n16 = Node16::Get(art, node);\n \n@@ -76,7 +76,7 @@ void Node16::InitializeMerge(ART &art, const ARTFlags &flags) {\n void Node16::InsertChild(ART &art, Node &node, const uint8_t byte, const Node child) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \tauto &n16 = Node16::Get(art, node);\n \n \t// ensure that there is no other child at the same byte\n@@ -112,7 +112,7 @@ void Node16::InsertChild(ART &art, Node &node, const uint8_t byte, const Node ch\n void Node16::DeleteChild(ART &art, Node &node, const uint8_t byte) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \tauto &n16 = Node16::Get(art, node);\n \n \tidx_t child_pos = 0;\n@@ -221,7 +221,7 @@ void Node16::Deserialize(MetaBlockReader &reader) {\n void Node16::Vacuum(ART &art, const ARTFlags &flags) {\n \n \tfor (idx_t i = 0; i < count; i++) {\n-\t\tNode::Vacuum(art, children[i], flags);\n+\t\tchildren[i].Vacuum(art, flags);\n \t}\n }\n \ndiff --git a/src/execution/index/art/node256.cpp b/src/execution/index/art/node256.cpp\nindex af56e012780d..4ba96ba0c6b4 100644\n--- a/src/execution/index/art/node256.cpp\n+++ b/src/execution/index/art/node256.cpp\n@@ -8,8 +8,8 @@ namespace duckdb {\n \n Node256 &Node256::New(ART &art, Node &node) {\n \n-\tnode.SetPtr(Node::GetAllocator(art, NType::NODE_256).New());\n-\tnode.type = (uint8_t)NType::NODE_256;\n+\tnode = Node::GetAllocator(art, NType::NODE_256).New();\n+\tnode.SetType((uint8_t)NType::NODE_256);\n \tauto &n256 = Node256::Get(art, node);\n \n \tn256.count = 0;\n@@ -23,7 +23,7 @@ Node256 &Node256::New(ART &art, Node &node) {\n void Node256::Free(ART &art, Node &node) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \n \tauto &n256 = Node256::Get(art, node);\n \n@@ -70,7 +70,7 @@ void Node256::InitializeMerge(ART &art, const ARTFlags &flags) {\n void Node256::InsertChild(ART &art, Node &node, const uint8_t byte, const Node child) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \tauto &n256 = Node256::Get(art, node);\n \n \t// ensure that there is no other child at the same byte\n@@ -84,7 +84,7 @@ void Node256::InsertChild(ART &art, Node &node, const uint8_t byte, const Node c\n void Node256::DeleteChild(ART &art, Node &node, const uint8_t byte) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \tauto &n256 = Node256::Get(art, node);\n \n \t// free the child and decrease the count\n@@ -145,7 +145,7 @@ void Node256::Vacuum(ART &art, const ARTFlags &flags) {\n \n \tfor (idx_t i = 0; i < Node::NODE_256_CAPACITY; i++) {\n \t\tif (children[i].IsSet()) {\n-\t\t\tNode::Vacuum(art, children[i], flags);\n+\t\t\tchildren[i].Vacuum(art, flags);\n \t\t}\n \t}\n }\ndiff --git a/src/execution/index/art/node4.cpp b/src/execution/index/art/node4.cpp\nindex 3f7c19148b8a..7ef1ba7c32a7 100644\n--- a/src/execution/index/art/node4.cpp\n+++ b/src/execution/index/art/node4.cpp\n@@ -9,8 +9,8 @@ namespace duckdb {\n \n Node4 &Node4::New(ART &art, Node &node) {\n \n-\tnode.SetPtr(Node::GetAllocator(art, NType::NODE_4).New());\n-\tnode.type = (uint8_t)NType::NODE_4;\n+\tnode = Node::GetAllocator(art, NType::NODE_4).New();\n+\tnode.SetType((uint8_t)NType::NODE_4);\n \tauto &n4 = Node4::Get(art, node);\n \n \tn4.count = 0;\n@@ -20,7 +20,7 @@ Node4 &Node4::New(ART &art, Node &node) {\n void Node4::Free(ART &art, Node &node) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \n \tauto &n4 = Node4::Get(art, node);\n \n@@ -57,7 +57,7 @@ void Node4::InitializeMerge(ART &art, const ARTFlags &flags) {\n void Node4::InsertChild(ART &art, Node &node, const uint8_t byte, const Node child) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \tauto &n4 = Node4::Get(art, node);\n \n \t// ensure that there is no other child at the same byte\n@@ -93,7 +93,7 @@ void Node4::InsertChild(ART &art, Node &node, const uint8_t byte, const Node chi\n void Node4::DeleteChild(ART &art, Node &node, Node &prefix, const uint8_t byte) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \tauto &n4 = Node4::Get(art, node);\n \n \tidx_t child_pos = 0;\n@@ -214,7 +214,7 @@ void Node4::Deserialize(MetaBlockReader &reader) {\n void Node4::Vacuum(ART &art, const ARTFlags &flags) {\n \n \tfor (idx_t i = 0; i < count; i++) {\n-\t\tNode::Vacuum(art, children[i], flags);\n+\t\tchildren[i].Vacuum(art, flags);\n \t}\n }\n \ndiff --git a/src/execution/index/art/node48.cpp b/src/execution/index/art/node48.cpp\nindex 2da5e95dbb0c..813444cca420 100644\n--- a/src/execution/index/art/node48.cpp\n+++ b/src/execution/index/art/node48.cpp\n@@ -9,8 +9,8 @@ namespace duckdb {\n \n Node48 &Node48::New(ART &art, Node &node) {\n \n-\tnode.SetPtr(Node::GetAllocator(art, NType::NODE_48).New());\n-\tnode.type = (uint8_t)NType::NODE_48;\n+\tnode = Node::GetAllocator(art, NType::NODE_48).New();\n+\tnode.SetType((uint8_t)NType::NODE_48);\n \tauto &n48 = Node48::Get(art, node);\n \n \tn48.count = 0;\n@@ -29,7 +29,7 @@ Node48 &Node48::New(ART &art, Node &node) {\n void Node48::Free(ART &art, Node &node) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \n \tauto &n48 = Node48::Get(art, node);\n \n@@ -109,7 +109,7 @@ void Node48::InitializeMerge(ART &art, const ARTFlags &flags) {\n void Node48::InsertChild(ART &art, Node &node, const uint8_t byte, const Node child) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \tauto &n48 = Node48::Get(art, node);\n \n \t// ensure that there is no other child at the same byte\n@@ -141,7 +141,7 @@ void Node48::InsertChild(ART &art, Node &node, const uint8_t byte, const Node ch\n void Node48::DeleteChild(ART &art, Node &node, const uint8_t byte) {\n \n \tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n+\tD_ASSERT(!node.IsSerialized());\n \tauto &n48 = Node48::Get(art, node);\n \n \t// free the child and decrease the count\n@@ -214,7 +214,7 @@ void Node48::Vacuum(ART &art, const ARTFlags &flags) {\n \n \tfor (idx_t i = 0; i < Node::NODE_256_CAPACITY; i++) {\n \t\tif (child_index[i] != Node::EMPTY_MARKER) {\n-\t\t\tNode::Vacuum(art, children[child_index[i]], flags);\n+\t\t\tchildren[child_index[i]].Vacuum(art, flags);\n \t\t}\n \t}\n }\ndiff --git a/src/execution/index/art/prefix.cpp b/src/execution/index/art/prefix.cpp\nindex a5cfa22abc44..49ed40e554ee 100644\n--- a/src/execution/index/art/prefix.cpp\n+++ b/src/execution/index/art/prefix.cpp\n@@ -11,8 +11,8 @@ namespace duckdb {\n \n Prefix &Prefix::New(ART &art, Node &node) {\n \n-\tnode.SetPtr(Node::GetAllocator(art, NType::PREFIX).New());\n-\tnode.type = (uint8_t)NType::PREFIX;\n+\tnode = Node::GetAllocator(art, NType::PREFIX).New();\n+\tnode.SetType((uint8_t)NType::PREFIX);\n \n \tauto &prefix = Prefix::Get(art, node);\n \tprefix.data[Node::PREFIX_SIZE] = 0;\n@@ -21,8 +21,8 @@ Prefix &Prefix::New(ART &art, Node &node) {\n \n Prefix &Prefix::New(ART &art, Node &node, uint8_t byte, Node next) {\n \n-\tnode.SetPtr(Node::GetAllocator(art, NType::PREFIX).New());\n-\tnode.type = (uint8_t)NType::PREFIX;\n+\tnode = Node::GetAllocator(art, NType::PREFIX).New();\n+\tnode.SetType((uint8_t)NType::PREFIX);\n \n \tauto &prefix = Prefix::Get(art, node);\n \tprefix.data[Node::PREFIX_SIZE] = 1;\n@@ -39,8 +39,8 @@ void Prefix::New(ART &art, reference<Node> &node, const ARTKey &key, const uint3\n \tidx_t copy_count = 0;\n \n \twhile (count) {\n-\t\tnode.get().SetPtr(Node::GetAllocator(art, NType::PREFIX).New());\n-\t\tnode.get().type = (uint8_t)NType::PREFIX;\n+\t\tnode.get() = Node::GetAllocator(art, NType::PREFIX).New();\n+\t\tnode.get().SetType((uint8_t)NType::PREFIX);\n \t\tauto &prefix = Prefix::Get(art, node);\n \n \t\tauto this_count = MinValue((uint32_t)Node::PREFIX_SIZE, count);\n@@ -55,38 +55,36 @@ void Prefix::New(ART &art, reference<Node> &node, const ARTKey &key, const uint3\n \n void Prefix::Free(ART &art, Node &node) {\n \n-\tD_ASSERT(node.IsSet());\n-\tD_ASSERT(!node.IsSwizzled());\n-\n+\tD_ASSERT(node.IsSet() && !node.IsSerialized());\n \tauto &child = Prefix::Get(art, node).ptr;\n \tNode::Free(art, child);\n }\n \n void Prefix::Concatenate(ART &art, Node &prefix_node, const uint8_t byte, Node &child_prefix_node) {\n \n-\tD_ASSERT(prefix_node.IsSet() && !prefix_node.IsSwizzled());\n+\tD_ASSERT(prefix_node.IsSet() && !prefix_node.IsSerialized());\n \tD_ASSERT(child_prefix_node.IsSet());\n \n-\tif (child_prefix_node.IsSwizzled()) {\n+\tif (child_prefix_node.IsSerialized()) {\n \t\tchild_prefix_node.Deserialize(art);\n \t}\n \n \t// append a byte and a child_prefix to prefix\n-\tif (prefix_node.DecodeARTNodeType() == NType::PREFIX) {\n+\tif (prefix_node.GetType() == NType::PREFIX) {\n \n \t\t// get the tail\n \t\treference<Prefix> prefix = Prefix::Get(art, prefix_node);\n-\t\tD_ASSERT(prefix.get().ptr.IsSet() && !prefix.get().ptr.IsSwizzled());\n+\t\tD_ASSERT(prefix.get().ptr.IsSet() && !prefix.get().ptr.IsSerialized());\n \n-\t\twhile (prefix.get().ptr.DecodeARTNodeType() == NType::PREFIX) {\n+\t\twhile (prefix.get().ptr.GetType() == NType::PREFIX) {\n \t\t\tprefix = Prefix::Get(art, prefix.get().ptr);\n-\t\t\tD_ASSERT(prefix.get().ptr.IsSet() && !prefix.get().ptr.IsSwizzled());\n+\t\t\tD_ASSERT(prefix.get().ptr.IsSet() && !prefix.get().ptr.IsSerialized());\n \t\t}\n \n \t\t// append the byte\n \t\tprefix = prefix.get().Append(art, byte);\n \n-\t\tif (child_prefix_node.DecodeARTNodeType() == NType::PREFIX) {\n+\t\tif (child_prefix_node.GetType() == NType::PREFIX) {\n \t\t\t// append the child prefix\n \t\t\tprefix.get().Append(art, child_prefix_node);\n \t\t} else {\n@@ -97,7 +95,7 @@ void Prefix::Concatenate(ART &art, Node &prefix_node, const uint8_t byte, Node &\n \t}\n \n \t// create a new prefix node containing the byte, then append the child_prefix to it\n-\tif (prefix_node.DecodeARTNodeType() != NType::PREFIX && child_prefix_node.DecodeARTNodeType() == NType::PREFIX) {\n+\tif (prefix_node.GetType() != NType::PREFIX && child_prefix_node.GetType() == NType::PREFIX) {\n \n \t\tauto child_prefix = child_prefix_node;\n \t\tauto &prefix = Prefix::New(art, prefix_node, byte, Node());\n@@ -112,11 +110,11 @@ void Prefix::Concatenate(ART &art, Node &prefix_node, const uint8_t byte, Node &\n \n idx_t Prefix::Traverse(ART &art, reference<Node> &prefix_node, const ARTKey &key, idx_t &depth) {\n \n-\tD_ASSERT(prefix_node.get().IsSet() && !prefix_node.get().IsSwizzled());\n-\tD_ASSERT(prefix_node.get().DecodeARTNodeType() == NType::PREFIX);\n+\tD_ASSERT(prefix_node.get().IsSet() && !prefix_node.get().IsSerialized());\n+\tD_ASSERT(prefix_node.get().GetType() == NType::PREFIX);\n \n \t// compare prefix nodes to key bytes\n-\twhile (prefix_node.get().DecodeARTNodeType() == NType::PREFIX) {\n+\twhile (prefix_node.get().GetType() == NType::PREFIX) {\n \t\tauto &prefix = Prefix::Get(art, prefix_node);\n \t\tfor (idx_t i = 0; i < prefix.data[Node::PREFIX_SIZE]; i++) {\n \t\t\tif (prefix.data[i] != key[depth]) {\n@@ -126,7 +124,7 @@ idx_t Prefix::Traverse(ART &art, reference<Node> &prefix_node, const ARTKey &key\n \t\t}\n \t\tprefix_node = prefix.ptr;\n \t\tD_ASSERT(prefix_node.get().IsSet());\n-\t\tif (prefix_node.get().IsSwizzled()) {\n+\t\tif (prefix_node.get().IsSerialized()) {\n \t\t\tprefix_node.get().Deserialize(art);\n \t\t}\n \t}\n@@ -158,7 +156,7 @@ bool Prefix::Traverse(ART &art, reference<Node> &l_node, reference<Node> &r_node\n \t\tmismatch_position = max_count;\n \n \t\t// l_prefix contains r_prefix\n-\t\tif (r_prefix.ptr.DecodeARTNodeType() != NType::PREFIX && r_prefix.data[Node::PREFIX_SIZE] == max_count) {\n+\t\tif (r_prefix.ptr.GetType() != NType::PREFIX && r_prefix.data[Node::PREFIX_SIZE] == max_count) {\n \t\t\tswap(l_node.get(), r_node.get());\n \t\t\tl_node = r_prefix.ptr;\n \n@@ -173,7 +171,7 @@ bool Prefix::Traverse(ART &art, reference<Node> &l_node, reference<Node> &r_node\n \n void Prefix::Reduce(ART &art, Node &prefix_node, const idx_t n) {\n \n-\tD_ASSERT(prefix_node.IsSet() && !prefix_node.IsSwizzled());\n+\tD_ASSERT(prefix_node.IsSet() && !prefix_node.IsSerialized());\n \tD_ASSERT(n < Node::PREFIX_SIZE);\n \n \treference<Prefix> prefix = Prefix::Get(art, prefix_node);\n@@ -201,7 +199,7 @@ void Prefix::Reduce(ART &art, Node &prefix_node, const idx_t n) {\n \n void Prefix::Split(ART &art, reference<Node> &prefix_node, Node &child_node, idx_t position) {\n \n-\tD_ASSERT(prefix_node.get().IsSet() && !prefix_node.get().IsSwizzled());\n+\tD_ASSERT(prefix_node.get().IsSet() && !prefix_node.get().IsSerialized());\n \n \tauto &prefix = Prefix::Get(art, prefix_node);\n \n@@ -223,11 +221,11 @@ void Prefix::Split(ART &art, reference<Node> &prefix_node, Node &child_node, idx\n \t\t}\n \n \t\tD_ASSERT(prefix.ptr.IsSet());\n-\t\tif (prefix.ptr.IsSwizzled()) {\n+\t\tif (prefix.ptr.IsSerialized()) {\n \t\t\tprefix.ptr.Deserialize(art);\n \t\t}\n \n-\t\tif (prefix.ptr.DecodeARTNodeType() == NType::PREFIX) {\n+\t\tif (prefix.ptr.GetType() == NType::PREFIX) {\n \t\t\tchild_prefix.get().Append(art, prefix.ptr);\n \t\t} else {\n \t\t\t// this is the last prefix node of the prefix\n@@ -255,19 +253,31 @@ void Prefix::Split(ART &art, reference<Node> &prefix_node, Node &child_node, idx\n \treturn;\n }\n \n-string Prefix::VerifyAndToString(ART &art, const bool only_verify) {\n+string Prefix::VerifyAndToString(ART &art, Node &node, const bool only_verify) {\n \n-\tD_ASSERT(data[Node::PREFIX_SIZE] != 0);\n-\tD_ASSERT(data[Node::PREFIX_SIZE] <= Node::PREFIX_SIZE);\n+\t// NOTE: we could do this recursively, but the function-call overhead can become kinda crazy\n+\tstring str = \"\";\n \n-\tstring str = \" prefix_bytes:[\";\n-\tfor (idx_t i = 0; i < data[Node::PREFIX_SIZE]; i++) {\n-\t\tstr += to_string(data[i]) + \"-\";\n+\treference<Node> node_ref(node);\n+\twhile (node_ref.get().GetType() == NType::PREFIX) {\n+\n+\t\tauto &prefix = Prefix::Get(art, node_ref);\n+\t\tD_ASSERT(prefix.data[Node::PREFIX_SIZE] != 0);\n+\t\tD_ASSERT(prefix.data[Node::PREFIX_SIZE] <= Node::PREFIX_SIZE);\n+\n+\t\tstr += \" prefix_bytes:[\";\n+\t\tfor (idx_t i = 0; i < prefix.data[Node::PREFIX_SIZE]; i++) {\n+\t\t\tstr += to_string(prefix.data[i]) + \"-\";\n+\t\t}\n+\t\tstr += \"] \";\n+\n+\t\tif (prefix.ptr.IsSerialized()) {\n+\t\t\treturn str + \" serialized\";\n+\t\t}\n+\t\tnode_ref = prefix.ptr;\n \t}\n-\tstr += \"] \";\n \n-\tstr = only_verify ? ptr.VerifyAndToString(art, only_verify) : str + ptr.VerifyAndToString(art, only_verify);\n-\treturn str;\n+\treturn str + node_ref.get().VerifyAndToString(art, only_verify);\n }\n \n BlockPointer Prefix::Serialize(ART &art, MetaBlockWriter &writer) {\n@@ -322,10 +332,10 @@ Prefix &Prefix::Append(ART &art, const uint8_t byte) {\n void Prefix::Append(ART &art, Node other_prefix) {\n \n \t// NOTE: all usages of this function already deserialize the other prefix\n-\tD_ASSERT(other_prefix.IsSet() && !other_prefix.IsSwizzled());\n+\tD_ASSERT(other_prefix.IsSet() && !other_prefix.IsSerialized());\n \n \treference<Prefix> prefix(*this);\n-\twhile (other_prefix.DecodeARTNodeType() == NType::PREFIX) {\n+\twhile (other_prefix.GetType() == NType::PREFIX) {\n \n \t\t// copy prefix bytes\n \t\tauto &other = Prefix::Get(art, other_prefix);\n@@ -334,7 +344,7 @@ void Prefix::Append(ART &art, Node other_prefix) {\n \t\t}\n \n \t\tD_ASSERT(other.ptr.IsSet());\n-\t\tif (other.ptr.IsSwizzled()) {\n+\t\tif (other.ptr.IsSerialized()) {\n \t\t\tother.ptr.Deserialize(art);\n \t\t}\n \n@@ -343,7 +353,7 @@ void Prefix::Append(ART &art, Node other_prefix) {\n \t\tother_prefix = prefix.get().ptr;\n \t}\n \n-\tD_ASSERT(prefix.get().ptr.DecodeARTNodeType() != NType::PREFIX);\n+\tD_ASSERT(prefix.get().ptr.GetType() != NType::PREFIX);\n }\n \n } // namespace duckdb\ndiff --git a/src/execution/index/art/swizzleable_pointer.cpp b/src/execution/index/art/swizzleable_pointer.cpp\ndeleted file mode 100644\nindex 626b5dd76cb2..000000000000\n--- a/src/execution/index/art/swizzleable_pointer.cpp\n+++ /dev/null\n@@ -1,22 +0,0 @@\n-#include \"duckdb/execution/index/art/swizzleable_pointer.hpp\"\n-\n-#include \"duckdb/storage/meta_block_reader.hpp\"\n-\n-namespace duckdb {\n-\n-SwizzleablePointer::SwizzleablePointer(MetaBlockReader &reader) {\n-\n-\tidx_t block_id = reader.Read<block_id_t>();\n-\toffset = reader.Read<uint32_t>();\n-\ttype = 0;\n-\n-\tif (block_id == DConstants::INVALID_INDEX) {\n-\t\tswizzle_flag = 0;\n-\t\treturn;\n-\t}\n-\n-\tbuffer_id = (uint32_t)block_id;\n-\tswizzle_flag = 1;\n-}\n-\n-} // namespace duckdb\ndiff --git a/src/execution/operator/schema/physical_create_index.cpp b/src/execution/operator/schema/physical_create_index.cpp\nindex f1e3b533adc3..161d4cd9b18c 100644\n--- a/src/execution/operator/schema/physical_create_index.cpp\n+++ b/src/execution/operator/schema/physical_create_index.cpp\n@@ -111,22 +111,12 @@ SinkResultType PhysicalCreateIndex::Sink(ExecutionContext &context, DataChunk &c\n \n #ifdef DEBUG\n \t// ensure that all row IDs of this chunk exist in the ART\n+\tauto &local_art = lstate.local_index->Cast<ART>();\n \tauto row_ids = FlatVector::GetData<row_t>(row_identifiers);\n \tfor (idx_t i = 0; i < lstate.key_chunk.size(); i++) {\n-\t\tauto leaf_node =\n-\t\t    lstate.local_index->Cast<ART>().Lookup(*lstate.local_index->Cast<ART>().tree, lstate.keys[i], 0);\n-\t\tD_ASSERT(leaf_node.IsSet());\n-\t\tauto &leaf = Leaf::Get(lstate.local_index->Cast<ART>(), leaf_node);\n-\n-\t\tif (leaf.IsInlined()) {\n-\t\t\tD_ASSERT(row_ids[i] == leaf.row_ids.inlined);\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tD_ASSERT(leaf.row_ids.ptr.IsSet());\n-\t\tNode leaf_segment = leaf.row_ids.ptr;\n-\t\tauto position = leaf.FindRowId(lstate.local_index->Cast<ART>(), leaf_segment, row_ids[i]);\n-\t\tD_ASSERT(position != (uint32_t)DConstants::INVALID_INDEX);\n+\t\tauto leaf = local_art.Lookup(*local_art.tree, lstate.keys[i], 0);\n+\t\tD_ASSERT(leaf.IsSet());\n+\t\tD_ASSERT(Leaf::ContainsRowId(local_art, leaf, row_ids[i]));\n \t}\n #endif\n \ndiff --git a/src/include/duckdb/common/constants.hpp b/src/include/duckdb/common/constants.hpp\nindex 46fca58a7bc9..4c2dda51c5a1 100644\n--- a/src/include/duckdb/common/constants.hpp\n+++ b/src/include/duckdb/common/constants.hpp\n@@ -39,6 +39,8 @@ DUCKDB_API bool IsRowIdColumnId(column_t column_id);\n \n //! The maximum row identifier used in tables\n extern const row_t MAX_ROW_ID;\n+//! Transaction-local row IDs start at MAX_ROW_ID\n+extern const row_t MAX_ROW_ID_LOCAL;\n \n extern const transaction_t TRANSACTION_ID_START;\n extern const transaction_t MAX_TRANSACTION_ID;\ndiff --git a/src/include/duckdb/common/type_util.hpp b/src/include/duckdb/common/type_util.hpp\nindex 19eae9e4ae44..fd8f40940e95 100644\n--- a/src/include/duckdb/common/type_util.hpp\n+++ b/src/include/duckdb/common/type_util.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/type_util.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include \"duckdb/common/types.hpp\"\ndiff --git a/src/include/duckdb/common/typedefs.hpp b/src/include/duckdb/common/typedefs.hpp\nindex 96dcd89be73d..1d24002da60c 100644\n--- a/src/include/duckdb/common/typedefs.hpp\n+++ b/src/include/duckdb/common/typedefs.hpp\n@@ -1,3 +1,11 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/typedefs.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n #pragma once\n \n #include <cstdint>\ndiff --git a/src/include/duckdb/execution/index/art/art.hpp b/src/include/duckdb/execution/index/art/art.hpp\nindex b8cb9d55c0d6..15cff52aa111 100644\n--- a/src/include/duckdb/execution/index/art/art.hpp\n+++ b/src/include/duckdb/execution/index/art/art.hpp\n@@ -105,7 +105,7 @@ class ART : public Index {\n \n private:\n \t//! Insert a row ID into a leaf\n-\tbool InsertToLeaf(Node &leaf_node, const row_t &row_id);\n+\tbool InsertToLeaf(Node &leaf, const row_t &row_id);\n \t//! Insert a key into the tree\n \tbool Insert(Node &node, const ARTKey &key, idx_t depth, const row_t &row_id);\n \t//! Erase a key from the tree (if a leaf has more than one value) or erase the leaf itself\ndiff --git a/src/include/duckdb/execution/index/art/art_key.hpp b/src/include/duckdb/execution/index/art/art_key.hpp\nindex 0c1fb7022a4e..0bb9c0f0c6c4 100644\n--- a/src/include/duckdb/execution/index/art/art_key.hpp\n+++ b/src/include/duckdb/execution/index/art/art_key.hpp\n@@ -59,7 +59,6 @@ class ARTKey {\n \t\treturn data[i];\n \t}\n \tbool operator>(const ARTKey &k) const;\n-\tbool operator<(const ARTKey &k) const;\n \tbool operator>=(const ARTKey &k) const;\n \tbool operator==(const ARTKey &k) const;\n \ndiff --git a/src/include/duckdb/execution/index/art/fixed_size_allocator.hpp b/src/include/duckdb/execution/index/art/fixed_size_allocator.hpp\nindex 23712b4fb540..dccf7b6523bf 100644\n--- a/src/include/duckdb/execution/index/art/fixed_size_allocator.hpp\n+++ b/src/include/duckdb/execution/index/art/fixed_size_allocator.hpp\n@@ -8,16 +8,14 @@\n \n #pragma once\n \n-#include \"duckdb/common/unordered_set.hpp\"\n-#include \"duckdb/common/constants.hpp\"\n-#include \"duckdb/common/vector.hpp\"\n-#include \"duckdb/common/assert.hpp\"\n #include \"duckdb/common/types/validity_mask.hpp\"\n+#include \"duckdb/common/unordered_set.hpp\"\n #include \"duckdb/storage/buffer_manager.hpp\"\n-#include \"duckdb/execution/index/art/swizzleable_pointer.hpp\"\n+#include \"duckdb/execution/index/art/node.hpp\"\n \n namespace duckdb {\n \n+// structs\n struct BufferEntry {\n \tBufferEntry(const data_ptr_t &ptr, const idx_t &allocation_count) : ptr(ptr), allocation_count(allocation_count) {\n \t}\n@@ -26,7 +24,7 @@ struct BufferEntry {\n };\n \n //! The FixedSizeAllocator provides pointers to fixed-size sections of pre-allocated memory buffers.\n-//! The pointers are SwizzleablePointers, and the leftmost byte (swizzle flag and type) must always be zero.\n+//! The pointers are Node pointers, and the leftmost byte (serialize flag and type) must always be zero.\n class FixedSizeAllocator {\n public:\n \t//! Fixed size of the buffers\n@@ -65,17 +63,17 @@ class FixedSizeAllocator {\n \tAllocator &allocator;\n \n public:\n-\t//! Get a new pointer to data, might cause a new buffer allocation\n-\tSwizzleablePointer New();\n-\t//! Free the data of the pointer\n-\tvoid Free(const SwizzleablePointer ptr);\n-\t//! Get the data of the pointer\n+\t//! Get a new Node pointer to data, might cause a new buffer allocation\n+\tNode New();\n+\t//! Free the data of the Node pointer\n+\tvoid Free(const Node ptr);\n+\t//! Get the data of the Node pointer\n \ttemplate <class T>\n-\tinline T *Get(const SwizzleablePointer ptr) const {\n+\tinline T *Get(const Node ptr) const {\n \t\treturn (T *)Get(ptr);\n \t}\n \n-\t//! Resets the allocator, which e.g. becomes necessary during DELETE FROM table\n+\t//! Resets the allocator, e.g., becomes necessary during DELETE FROM table\n \tvoid Reset();\n \n \t//! Returns the allocated memory size in bytes\n@@ -83,32 +81,32 @@ class FixedSizeAllocator {\n \t\treturn buffers.size() * BUFFER_ALLOC_SIZE;\n \t}\n \n-\t//! Merge another FixedSizeAllocator with this allocator. Both must have the same allocation size\n+\t//! Merge another FixedSizeAllocator into this allocator. Both must have the same allocation size\n \tvoid Merge(FixedSizeAllocator &other);\n \n \t//! Initialize a vacuum operation, and return true, if the allocator needs a vacuum\n \tbool InitializeVacuum();\n \t//! Finalize a vacuum operation by freeing all buffers exceeding the min_vacuum_buffer_id\n \tvoid FinalizeVacuum();\n-\t//! Returns true, if a pointer qualifies for a vacuum operation, and false otherwise\n-\tinline bool NeedsVacuum(const SwizzleablePointer ptr) const {\n-\t\tif (ptr.buffer_id >= min_vacuum_buffer_id) {\n+\t//! Returns true, if a Node pointer qualifies for a vacuum operation, and false otherwise\n+\tinline bool NeedsVacuum(const Node ptr) const {\n+\t\tif (ptr.GetBufferId() >= min_vacuum_buffer_id) {\n \t\t\treturn true;\n \t\t}\n \t\treturn false;\n \t}\n-\t//! Vacuums a pointer\n-\tSwizzleablePointer VacuumPointer(const SwizzleablePointer ptr);\n+\t//! Vacuums a Node pointer\n+\tNode VacuumPointer(const Node ptr);\n \n \t//! Verify that the allocation counts match the existing positions on the buffers\n \tvoid Verify() const;\n \n private:\n-\t//! Returns the data_ptr_t of a pointer\n-\tinline data_ptr_t Get(const SwizzleablePointer ptr) const {\n-\t\tD_ASSERT(ptr.buffer_id < buffers.size());\n-\t\tD_ASSERT(ptr.offset < allocations_per_buffer);\n-\t\treturn buffers[ptr.buffer_id].ptr + ptr.offset * allocation_size + allocation_offset;\n+\t//! Returns the data_ptr_t of a Node pointer\n+\tinline data_ptr_t Get(const Node ptr) const {\n+\t\tD_ASSERT(ptr.GetBufferId() < buffers.size());\n+\t\tD_ASSERT(ptr.GetOffset() < allocations_per_buffer);\n+\t\treturn buffers[ptr.GetBufferId()].ptr + ptr.GetOffset() * allocation_size + allocation_offset;\n \t}\n \t//! Returns the first free offset in a bitmask\n \tuint32_t GetOffset(ValidityMask &mask, const idx_t allocation_count);\ndiff --git a/src/include/duckdb/execution/index/art/iterator.hpp b/src/include/duckdb/execution/index/art/iterator.hpp\nindex e9ffea270ad3..52be15cd95e1 100644\n--- a/src/include/duckdb/execution/index/art/iterator.hpp\n+++ b/src/include/duckdb/execution/index/art/iterator.hpp\n@@ -70,8 +70,8 @@ class Iterator {\n private:\n \t//! Stack of nodes from the root to the currently active node\n \tstack<IteratorEntry> nodes;\n-\t//! Last visited leaf\n-\toptional_ptr<Leaf> last_leaf = nullptr;\n+\t//! Last visited leaf node\n+\tNode last_leaf = Node();\n \n \t//! Goes to the next leaf in the ART and sets it as last_leaf,\n \t//! returns false if there is no next leaf\ndiff --git a/src/include/duckdb/execution/index/art/leaf.hpp b/src/include/duckdb/execution/index/art/leaf.hpp\nindex 45d6e73f26a1..f754c865721e 100644\n--- a/src/include/duckdb/execution/index/art/leaf.hpp\n+++ b/src/include/duckdb/execution/index/art/leaf.hpp\n@@ -21,64 +21,67 @@ class MetaBlockReader;\n // structs\n struct BlockPointer;\n \n+//! The LEAF is a special node type that contains a count, up to LEAF_SIZE row IDs,\n+//! and a Node pointer. If this pointer is set, then it must point to another LEAF,\n+//! creating a chain of leaf nodes storing row IDs.\n+//! This class also contains functionality for nodes of type LEAF_INLINED, in which case we store the\n+//! row ID directly in the node pointer.\n class Leaf {\n public:\n-\t//! Number of row IDs\n-\tuint32_t count;\n-\tunion {\n-\t\t//! The pointer to the head of the list of leaf segments\n-\t\tNode ptr;\n-\t\t//! Inlined row ID\n-\t\trow_t inlined;\n-\t} row_ids;\n+\t//! The number of row IDs in this leaf\n+\tuint8_t count;\n+\t//! Up to LEAF_SIZE row IDs\n+\trow_t row_ids[Node::LEAF_SIZE];\n+\t//! A pointer to the next LEAF node\n+\tNode ptr;\n \n public:\n-\t//! Get a new leaf node, might cause a new buffer allocation, and initializes a leaf holding one row ID\n-\tstatic Leaf &New(ART &art, Node &node, const row_t row_id);\n-\t//! Get a new leaf node, might cause a new buffer allocation, and initializes a leaf holding n_row_ids row IDs\n-\tstatic Leaf &New(ART &art, Node &node, const row_t *row_ids, const idx_t count);\n-\t//! Free the leaf\n+\t//! Inline a row ID into a node pointer\n+\tstatic void New(Node &node, const row_t row_id);\n+\t//! Get a new chain of leaf nodes, might cause new buffer allocations,\n+\t//! with the node parameter holding the tail of the chain\n+\tstatic void New(ART &art, reference<Node> &node, const row_t *row_ids, idx_t count);\n+\t//! Free the leaf (chain)\n \tstatic void Free(ART &art, Node &node);\n \t//! Get a reference to the leaf\n \tstatic inline Leaf &Get(const ART &art, const Node ptr) {\n+\t\tD_ASSERT(!ptr.IsSerialized());\n \t\treturn *Node::GetAllocator(art, NType::LEAF).Get<Leaf>(ptr);\n \t}\n \n-\t//! Initializes a merge by incrementing the buffer IDs of the leaf segments\n-\tvoid InitializeMerge(const ART &art, const idx_t buffer_count);\n-\t//! Merge leaves\n-\tvoid Merge(ART &art, Node &other);\n+\t//! Initializes a merge by incrementing the buffer IDs of the leaf\n+\tstatic void InitializeMerge(ART &art, Node &node, const ARTFlags &flags);\n+\t//! Merge leaves and free all copied leaf nodes\n+\tstatic void Merge(ART &art, Node &l_node, Node &r_node);\n \n \t//! Insert a row ID into a leaf\n-\tvoid Insert(ART &art, const row_t row_id);\n-\t//! Remove a row ID from a leaf\n-\tvoid Remove(ART &art, const row_t row_id);\n+\tstatic void Insert(ART &art, Node &node, const row_t row_id);\n+\t//! Remove a row ID from a leaf. Returns true, if the leaf is empty after the removal\n+\tstatic bool Remove(ART &art, reference<Node> &node, const row_t row_id);\n \n-\t//! Returns whether this leaf is inlined\n-\tinline bool IsInlined() const {\n-\t\treturn count <= 1;\n-\t}\n-\t//! Get the row ID at the position\n-\trow_t GetRowId(const ART &art, const idx_t position) const;\n-\t//! Returns the position of a row ID, and an invalid index, if the leaf does not contain the row ID,\n-\t//! and sets the ptr to point to the segment containing the row ID\n-\tuint32_t FindRowId(const ART &art, Node &ptr, const row_t row_id) const;\n+\t//! Get the total count of row IDs in the chain of leaves\n+\tstatic idx_t TotalCount(ART &art, Node &node);\n+\t//! Fill the result_ids vector with the row IDs of this leaf chain, if the total count does not exceed max_count\n+\tstatic bool GetRowIds(ART &art, Node &node, vector<row_t> &result_ids, idx_t max_count);\n+\t//! Returns whether the leaf contains the row ID\n+\tstatic bool ContainsRowId(ART &art, Node &node, const row_t row_id);\n \n-\t//! Returns the string representation of the node, or only traverses and verifies the node and its subtree\n-\tstring VerifyAndToString(const ART &art, const bool only_verify) const;\n+\t//! Returns the string representation of the leaf, or only traverses and verifies the leaf\n+\tstatic string VerifyAndToString(ART &art, Node &node);\n \n-\t//! Serialize this leaf\n-\tBlockPointer Serialize(const ART &art, MetaBlockWriter &writer) const;\n-\t//! Deserialize this leaf\n-\tvoid Deserialize(ART &art, MetaBlockReader &reader);\n+\t//! Serialize the leaf\n+\tstatic BlockPointer Serialize(ART &art, Node &node, MetaBlockWriter &writer);\n+\t//! Deserialize the leaf\n+\tstatic void Deserialize(ART &art, Node &node, MetaBlockReader &reader);\n \n-\t//! Vacuum the leaf segments of a leaf, if not inlined\n-\tvoid Vacuum(ART &art);\n+\t//! Vacuum the leaf\n+\tstatic void Vacuum(ART &art, Node &node);\n \n private:\n-\t//! Moves the inlined row ID onto a leaf segment, does not change the size\n-\t//! so this will be a (temporarily) invalid leaf\n-\tvoid MoveInlinedToSegment(ART &art);\n+\t//! Moves the inlined row ID onto a leaf\n+\tstatic void MoveInlinedToLeaf(ART &art, Node &node);\n+\t//! Appends the row ID to this leaf, or creates a subsequent leaf, if this node is full\n+\tLeaf &Append(ART &art, const row_t row_id);\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/execution/index/art/leaf_segment.hpp b/src/include/duckdb/execution/index/art/leaf_segment.hpp\ndeleted file mode 100644\nindex 29d146f431c8..000000000000\n--- a/src/include/duckdb/execution/index/art/leaf_segment.hpp\n+++ /dev/null\n@@ -1,38 +0,0 @@\n-//===----------------------------------------------------------------------===//\n-//                         DuckDB\n-//\n-// duckdb/execution/index/art/leaf_segment.hpp\n-//\n-//\n-//===----------------------------------------------------------------------===//\n-#pragma once\n-\n-#include \"duckdb/execution/index/art/art.hpp\"\n-#include \"duckdb/execution/index/art/node.hpp\"\n-\n-namespace duckdb {\n-\n-class LeafSegment {\n-public:\n-\t//! The row IDs stored in this segment\n-\trow_t row_ids[Node::LEAF_SEGMENT_SIZE];\n-\t//! The pointer of the next segment, if the row IDs exceeds this segment\n-\tNode next;\n-\n-public:\n-\t//! Get a new leaf segment node, might cause a new buffer allocation, and initialize it\n-\tstatic LeafSegment &New(ART &art, Node &node);\n-\t//! Get a reference to the leaf segment\n-\tstatic inline LeafSegment &Get(const ART &art, const Node ptr) {\n-\t\treturn *Node::GetAllocator(art, NType::LEAF_SEGMENT).Get<LeafSegment>(ptr);\n-\t}\n-\t//! Free the leaf segment and any subsequent ones\n-\tstatic void Free(ART &art, Node &node);\n-\n-\t//! Append a row ID to the current segment, or create a new segment containing that row ID\n-\tLeafSegment &Append(ART &art, uint32_t &count, const row_t row_id);\n-\t//! Get the tail of a list of segments\n-\tLeafSegment &GetTail(const ART &art);\n-};\n-\n-} // namespace duckdb\ndiff --git a/src/include/duckdb/execution/index/art/node.hpp b/src/include/duckdb/execution/index/art/node.hpp\nindex bac651454044..ca1bdbfbe0cd 100644\n--- a/src/include/duckdb/execution/index/art/node.hpp\n+++ b/src/include/duckdb/execution/index/art/node.hpp\n@@ -1,30 +1,32 @@\n //===----------------------------------------------------------------------===//\n //                         DuckDB\n //\n-// duckdb/execution/index/art/art_node.hpp\n+// duckdb/execution/index/art/node.hpp\n //\n //\n //===----------------------------------------------------------------------===//\n \n #pragma once\n \n-#include \"duckdb/execution/index/art/fixed_size_allocator.hpp\"\n-#include \"duckdb/execution/index/art/swizzleable_pointer.hpp\"\n+#include \"duckdb/common/assert.hpp\"\n+#include \"duckdb/common/optional_ptr.hpp\"\n+#include \"duckdb/common/to_string.hpp\"\n+#include \"duckdb/common/typedefs.hpp\"\n \n namespace duckdb {\n \n // classes\n enum class NType : uint8_t {\n \tPREFIX = 1,\n-\tLEAF_SEGMENT = 2,\n-\tLEAF = 3,\n-\tNODE_4 = 4,\n-\tNODE_16 = 5,\n-\tNODE_48 = 6,\n-\tNODE_256 = 7\n+\tLEAF = 2,\n+\tNODE_4 = 3,\n+\tNODE_16 = 4,\n+\tNODE_48 = 5,\n+\tNODE_256 = 6,\n+\tLEAF_INLINED = 7,\n };\n+class FixedSizeAllocator;\n class ART;\n-class Node;\n class Prefix;\n class MetaBlockReader;\n class MetaBlockWriter;\n@@ -33,10 +35,10 @@ class MetaBlockWriter;\n struct BlockPointer;\n struct ARTFlags;\n \n-//! The ARTNode is the swizzleable pointer class of the ART index.\n-//! If the ARTNode pointer is not swizzled, then the leftmost byte identifies the NType.\n-//! The remaining bytes are the position in the respective ART buffer.\n-class Node : public SwizzleablePointer {\n+//! The Node is the pointer class of the ART index.\n+//! If the node is serialized, then the pointer points to a storage address (and has no type),\n+//! otherwise the pointer has a type and stores other information (e.g., a buffer location or a row ID).\n+class Node {\n public:\n \t//! Node thresholds\n \tstatic constexpr uint8_t NODE_48_SHRINK_THRESHOLD = 12;\n@@ -46,42 +48,40 @@ class Node : public SwizzleablePointer {\n \tstatic constexpr uint8_t NODE_16_CAPACITY = 16;\n \tstatic constexpr uint8_t NODE_48_CAPACITY = 48;\n \tstatic constexpr uint16_t NODE_256_CAPACITY = 256;\n+\t//! Bit-shifting\n+\tstatic constexpr uint64_t SHIFT_OFFSET = 32;\n+\tstatic constexpr uint64_t SHIFT_TYPE = 56;\n+\tstatic constexpr uint64_t SHIFT_SERIALIZED_FLAG = 63;\n+\t//! AND operations\n+\tstatic constexpr uint64_t AND_OFFSET = 0x0000000000FFFFFF;\n+\tstatic constexpr uint64_t AND_BUFFER_ID = 0x00000000FFFFFFFF;\n+\tstatic constexpr uint64_t AND_IS_SET = 0xFF00000000000000;\n+\tstatic constexpr uint64_t AND_RESET = 0x00FFFFFFFFFFFFFF;\n+\t//! OR operations\n+\tstatic constexpr uint64_t SET_SERIALIZED_FLAG = 0x8000000000000000;\n \t//! Other constants\n \tstatic constexpr uint8_t EMPTY_MARKER = 48;\n-\tstatic constexpr uint32_t LEAF_SEGMENT_SIZE = 8;\n+\tstatic constexpr uint8_t LEAF_SIZE = 4;\n \tstatic constexpr uint8_t PREFIX_SIZE = 15;\n \n public:\n-\t//! Constructs an empty ARTNode\n-\tNode();\n-\t//! Constructs a swizzled pointer from a block ID and an offset\n+\t//! Constructors\n+\n+\t//! Constructs an empty Node\n+\tNode() : data(0) {};\n+\t//! Constructs a serialized Node pointer from a block ID and an offset\n \texplicit Node(MetaBlockReader &reader);\n+\t//! Constructs an in-memory Node from a buffer ID and an offset\n+\tNode(const uint32_t buffer_id, const uint32_t offset) : data(0) {\n+\t\tSetPtr(buffer_id, offset);\n+\t};\n+\n+public:\n \t//! Get a new pointer to a node, might cause a new buffer allocation, and initialize it\n \tstatic void New(ART &art, Node &node, const NType type);\n \t//! Free the node (and its subtree)\n \tstatic void Free(ART &art, Node &node);\n \n-\tinline bool operator==(const Node &node) const {\n-\t\treturn swizzle_flag == node.swizzle_flag && type == node.type && offset == node.offset &&\n-\t\t       buffer_id == node.buffer_id;\n-\t}\n-\n-\t//! Retrieve the node type from the leftmost byte\n-\tinline NType DecodeARTNodeType() const {\n-\t\tD_ASSERT(!IsSwizzled());\n-\t\tD_ASSERT(type >= (uint8_t)NType::PREFIX);\n-\t\tD_ASSERT(type <= (uint8_t)NType::NODE_256);\n-\t\treturn NType(type);\n-\t}\n-\n-\t//! Set the pointer\n-\tinline void SetPtr(const SwizzleablePointer ptr) {\n-\t\tswizzle_flag = ptr.swizzle_flag;\n-\t\ttype = ptr.type;\n-\t\toffset = ptr.offset;\n-\t\tbuffer_id = ptr.buffer_id;\n-\t}\n-\n \t//! Replace the child node at the respective byte\n \tvoid ReplaceChild(const ART &art, const uint8_t byte, const Node child);\n \t//! Insert the child node at byte\n@@ -118,7 +118,86 @@ class Node : public SwizzleablePointer {\n \tbool MergeInternal(ART &art, Node &other);\n \n \t//! Vacuum all nodes that exceed their respective vacuum thresholds\n-\tstatic void Vacuum(ART &art, Node &node, const ARTFlags &flags);\n+\tvoid Vacuum(ART &art, const ARTFlags &flags);\n+\n+\t// Getters and Setters\n+\n+\t//! Returns whether the node is serialized or not (zero bit)\n+\tinline bool IsSerialized() const {\n+\t\treturn data >> Node::SHIFT_SERIALIZED_FLAG;\n+\t}\n+\t//! Get the type (1st to 7th bit)\n+\tinline NType GetType() const {\n+\t\tD_ASSERT(!IsSerialized());\n+\t\tauto type = data >> Node::SHIFT_TYPE;\n+\t\tD_ASSERT(type >= (uint8_t)NType::PREFIX);\n+\t\tD_ASSERT(type <= (uint8_t)NType::LEAF_INLINED);\n+\t\treturn NType(type);\n+\t}\n+\t//! Get the offset (8th to 23rd bit)\n+\tinline idx_t GetOffset() const {\n+\t\tauto offset = data >> Node::SHIFT_OFFSET;\n+\t\treturn offset & Node::AND_OFFSET;\n+\t}\n+\t//! Get the block/buffer ID (24th to 63rd bit)\n+\tinline idx_t GetBufferId() const {\n+\t\treturn data & Node::AND_BUFFER_ID;\n+\t}\n+\t//! Get the row ID (8th to 63rd bit)\n+\tinline row_t GetRowId() const {\n+\t\treturn data & Node::AND_RESET;\n+\t}\n+\n+\t//! Set the serialized flag (zero bit)\n+\tinline void SetSerialized() {\n+\t\tdata &= Node::AND_RESET;\n+\t\tdata |= Node::SET_SERIALIZED_FLAG;\n+\t}\n+\t//! Set the type (1st to 7th bit)\n+\tinline void SetType(const uint8_t type) {\n+\t\tD_ASSERT(!IsSerialized());\n+\t\tdata += (uint64_t)type << Node::SHIFT_TYPE;\n+\t}\n+\t//! Set the block/buffer ID (24th to 63rd bit) and offset (8th to 23rd bit)\n+\tinline void SetPtr(const uint32_t buffer_id, const uint32_t offset) {\n+\t\tD_ASSERT(!(data & Node::AND_RESET));\n+\t\tauto shifted_offset = ((uint64_t)offset) << Node::SHIFT_OFFSET;\n+\t\tdata += shifted_offset;\n+\t\tdata += buffer_id;\n+\t}\n+\t//! Set the row ID (8th to 63rd bit)\n+\tinline void SetRowId(const row_t row_id) {\n+\t\tD_ASSERT(!(data & Node::AND_RESET));\n+\t\tdata += row_id;\n+\t}\n+\n+\t//! Returns true, if neither the serialized flag is set nor the type\n+\tinline bool IsSet() const {\n+\t\treturn data & Node::AND_IS_SET;\n+\t}\n+\t//! Reset the Node pointer by setting the node info to zero\n+\tinline void Reset() {\n+\t\tdata = 0;\n+\t}\n+\n+\t//! Comparison operator\n+\tinline bool operator==(const Node &node) const {\n+\t\treturn data == node.data;\n+\t}\n+\n+private:\n+\t//! Data holds all the information contained in a Node pointer\n+\t//! [0: serialized flag, 1 - 7: type,\n+\t//! 8 - 23: offset, 24 - 63: buffer/block ID OR\n+\t//! 8 - 63: row ID]\n+\t//! NOTE: a Node pointer can be either serialized OR have a type\n+\t//! NOTE: we do not use bit fields because when using bit fields Windows compiles\n+\t//! the Node class into 16 bytes instead of the intended 8 bytes, doubling the\n+\t//! space requirements\n+\t//! https://learn.microsoft.com/en-us/cpp/cpp/cpp-bit-fields?view=msvc-170\n+\tuint64_t data;\n };\n \n+static_assert(sizeof(Node) == sizeof(uint64_t), \"Invalid size for Node type.\");\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/execution/index/art/node16.hpp b/src/include/duckdb/execution/index/art/node16.hpp\nindex 320f7489bc38..e771099a999e 100644\n--- a/src/include/duckdb/execution/index/art/node16.hpp\n+++ b/src/include/duckdb/execution/index/art/node16.hpp\n@@ -31,6 +31,7 @@ class Node16 {\n \tstatic void Free(ART &art, Node &node);\n \t//! Get a reference to the node\n \tstatic inline Node16 &Get(const ART &art, const Node ptr) {\n+\t\tD_ASSERT(!ptr.IsSerialized());\n \t\treturn *Node::GetAllocator(art, NType::NODE_16).Get<Node16>(ptr);\n \t}\n \t//! Initializes all the fields of the node while growing a Node4 to a Node16\ndiff --git a/src/include/duckdb/execution/index/art/node256.hpp b/src/include/duckdb/execution/index/art/node256.hpp\nindex 87b1e0e5464a..4d3c73920df8 100644\n--- a/src/include/duckdb/execution/index/art/node256.hpp\n+++ b/src/include/duckdb/execution/index/art/node256.hpp\n@@ -29,6 +29,7 @@ class Node256 {\n \tstatic void Free(ART &art, Node &node);\n \t//! Get a reference to the node\n \tstatic inline Node256 &Get(const ART &art, const Node ptr) {\n+\t\tD_ASSERT(!ptr.IsSerialized());\n \t\treturn *Node::GetAllocator(art, NType::NODE_256).Get<Node256>(ptr);\n \t}\n \t//! Initializes all the fields of the node while growing a Node48 to a Node256\ndiff --git a/src/include/duckdb/execution/index/art/node4.hpp b/src/include/duckdb/execution/index/art/node4.hpp\nindex 802489238b10..06c8e538bc68 100644\n--- a/src/include/duckdb/execution/index/art/node4.hpp\n+++ b/src/include/duckdb/execution/index/art/node4.hpp\n@@ -31,6 +31,7 @@ class Node4 {\n \tstatic void Free(ART &art, Node &node);\n \t//! Get a reference to the node\n \tstatic inline Node4 &Get(const ART &art, const Node ptr) {\n+\t\tD_ASSERT(!ptr.IsSerialized());\n \t\treturn *Node::GetAllocator(art, NType::NODE_4).Get<Node4>(ptr);\n \t}\n \t//! Initializes all fields of the node while shrinking a Node16 to a Node4\ndiff --git a/src/include/duckdb/execution/index/art/node48.hpp b/src/include/duckdb/execution/index/art/node48.hpp\nindex 58581686b5d4..2f31d069d56b 100644\n--- a/src/include/duckdb/execution/index/art/node48.hpp\n+++ b/src/include/duckdb/execution/index/art/node48.hpp\n@@ -32,6 +32,7 @@ class Node48 {\n \tstatic void Free(ART &art, Node &node);\n \t//! Get a reference to the node\n \tstatic inline Node48 &Get(const ART &art, const Node ptr) {\n+\t\tD_ASSERT(!ptr.IsSerialized());\n \t\treturn *Node::GetAllocator(art, NType::NODE_48).Get<Node48>(ptr);\n \t}\n \t//! Initializes all the fields of the node while growing a Node16 to a Node48\ndiff --git a/src/include/duckdb/execution/index/art/prefix.hpp b/src/include/duckdb/execution/index/art/prefix.hpp\nindex 14e14a837752..df2689599007 100644\n--- a/src/include/duckdb/execution/index/art/prefix.hpp\n+++ b/src/include/duckdb/execution/index/art/prefix.hpp\n@@ -8,6 +8,7 @@\n #pragma once\n \n #include \"duckdb/execution/index/art/art.hpp\"\n+#include \"duckdb/execution/index/art/fixed_size_allocator.hpp\"\n #include \"duckdb/execution/index/art/node.hpp\"\n \n namespace duckdb {\n@@ -37,6 +38,7 @@ class Prefix {\n \tstatic void Free(ART &art, Node &node);\n \t//! Get a reference to the prefix\n \tstatic inline Prefix &Get(const ART &art, const Node ptr) {\n+\t\tD_ASSERT(!ptr.IsSerialized());\n \t\treturn *Node::GetAllocator(art, NType::PREFIX).Get<Prefix>(ptr);\n \t}\n \n@@ -71,7 +73,7 @@ class Prefix {\n \tstatic void Split(ART &art, reference<Node> &prefix_node, Node &child_node, idx_t position);\n \n \t//! Returns the string representation of the node, or only traverses and verifies the node and its subtree\n-\tstring VerifyAndToString(ART &art, const bool only_verify);\n+\tstatic string VerifyAndToString(ART &art, Node &node, const bool only_verify);\n \n \t//! Serialize this node\n \tBlockPointer Serialize(ART &art, MetaBlockWriter &writer);\n@@ -80,7 +82,7 @@ class Prefix {\n \n \t//! Vacuum the child of the node\n \tinline void Vacuum(ART &art, const ARTFlags &flags) {\n-\t\tNode::Vacuum(art, ptr, flags);\n+\t\tptr.Vacuum(art, flags);\n \t}\n \n private:\ndiff --git a/src/include/duckdb/execution/index/art/swizzleable_pointer.hpp b/src/include/duckdb/execution/index/art/swizzleable_pointer.hpp\ndeleted file mode 100644\nindex 66297265d4b8..000000000000\n--- a/src/include/duckdb/execution/index/art/swizzleable_pointer.hpp\n+++ /dev/null\n@@ -1,58 +0,0 @@\n-//===----------------------------------------------------------------------===//\n-//                         DuckDB\n-//\n-// duckdb/execution/index/art/swizzleable_pointer.hpp\n-//\n-//\n-//===----------------------------------------------------------------------===//\n-#pragma once\n-\n-#include \"duckdb/common/constants.hpp\"\n-\n-namespace duckdb {\n-\n-// classes\n-class MetaBlockReader;\n-\n-// structs\n-struct BlockPointer;\n-\n-//! SwizzleablePointer provides functions on a (possibly) swizzled pointer. If the swizzle flag is set, then the\n-//! pointer points to a storage address (and has no type), otherwise the pointer has a type and stores\n-//! other information (e.g., a buffer location)\n-class SwizzleablePointer {\n-public:\n-\t//! Constructs an empty SwizzleablePointer\n-\tSwizzleablePointer() : swizzle_flag(0), type(0), offset(0), buffer_id(0) {};\n-\t//! Constructs a swizzled pointer from a buffer ID and an offset\n-\texplicit SwizzleablePointer(MetaBlockReader &reader);\n-\t//! Constructs a non-swizzled pointer from a buffer ID and an offset\n-\tSwizzleablePointer(uint32_t offset, uint32_t buffer_id)\n-\t    : swizzle_flag(0), type(0), offset(offset), buffer_id(buffer_id) {};\n-\n-\t//! The swizzle flag, set if swizzled, not set otherwise\n-\tuint8_t swizzle_flag : 1;\n-\t//! The type of the pointer, zero if not set\n-\tuint8_t type : 7;\n-\t//! The offset of a memory location\n-\tuint32_t offset : 24;\n-\t//! The buffer ID of a memory location\n-\tuint32_t buffer_id : 32;\n-\n-public:\n-\t//! Checks if the pointer is swizzled\n-\tinline bool IsSwizzled() const {\n-\t\treturn swizzle_flag;\n-\t}\n-\t//! Returns true, if neither the swizzle flag nor the type is set, and false otherwise\n-\tinline bool IsSet() const {\n-\t\treturn swizzle_flag || type;\n-\t}\n-\t//! Reset the pointer\n-\tinline void Reset() {\n-\t\tswizzle_flag = 0;\n-\t\ttype = 0;\n-\t}\n-};\n-\n-} // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/index/art/memory/test_art_linear.test_slow b/test/sql/index/art/memory/test_art_linear.test_slow\nindex ee0e6be1d25e..853c194eb390 100644\n--- a/test/sql/index/art/memory/test_art_linear.test_slow\n+++ b/test/sql/index/art/memory/test_art_linear.test_slow\n@@ -2,8 +2,6 @@\n # description: Test the memory usage of the ART for linear integer insertions\n # group: [memory]\n \n-# FIXME: once we inline leaves, these numbers should all go down\n-\n statement ok\n PRAGMA enable_verification\n \n@@ -66,7 +64,8 @@ statement ok\n INSERT INTO t SELECT * FROM range(1000000);\n \n query I\n-SELECT mem_to_bytes(current.memory_usage) > 2 * base.usage\n+SELECT mem_to_bytes(current.memory_usage) > base.usage AND\n+\tmem_to_bytes(current.memory_usage) < 3 * base.usage\n FROM base, pragma_database_size() current;\n ----\n 1\n@@ -99,7 +98,8 @@ statement ok\n INSERT INTO t SELECT * FROM range(1000000);\n \n query I\n-SELECT mem_to_bytes(current.memory_usage) > 2 * base.usage\n+SELECT mem_to_bytes(current.memory_usage) > base.usage AND\n+       \tmem_to_bytes(current.memory_usage) < 3 * base.usage\n FROM base, pragma_database_size() current;\n ----\n 1\n@@ -123,7 +123,8 @@ statement ok\n INSERT INTO t SELECT * FROM range(1000000);\n \n query I\n-SELECT mem_to_bytes(current.memory_usage) > 2 * base.usage\n+SELECT mem_to_bytes(current.memory_usage) > base.usage AND\n+       \tmem_to_bytes(current.memory_usage) < 3 * base.usage\n FROM base, pragma_database_size() current;\n ----\n 1\ndiff --git a/test/sql/index/art/memory/test_art_non_linear.test_slow b/test/sql/index/art/memory/test_art_non_linear.test_slow\nindex 6cd3e1a22c01..305e6e7281c7 100644\n--- a/test/sql/index/art/memory/test_art_non_linear.test_slow\n+++ b/test/sql/index/art/memory/test_art_non_linear.test_slow\n@@ -2,8 +2,6 @@\n # description: Test the memory usage of the ART for various workloads\n # group: [memory]\n \n-# FIXME: once we inline leaves, these numbers should all go down\n-\n statement ok\n PRAGMA enable_verification;\n \n@@ -38,12 +36,12 @@ DROP TABLE strings_temp;\n statement ok\n CREATE INDEX idx ON art USING ART(id);\n \n-# 12 blocks for prefixes, 10 blocks for leaves, 7 blocks for Node16\n-# 29 blocks * 256KB = 7424KB\n-# WITHOUT the index, our database size is already approximately 2MB here\n+# 10 blocks for prefixes, 6 blocks for Node16\n+# 16 blocks * 256KB = 4096KB\n+# WITHOUT the index, our database size is already approximately 2.1MB here\n \n query I\n-SELECT mem_to_bytes(memory_usage) < 11000000 FROM pragma_database_size();\n+SELECT mem_to_bytes(memory_usage) < 7000000 FROM pragma_database_size();\n ----\n true\n \n@@ -68,12 +66,12 @@ DROP TABLE strings_temp;\n statement ok\n CREATE INDEX idx ON art USING ART(id);\n \n-# 1 block for prefixes, 10 blocks for 100K distinct leaves, 3 blocks for Node4, 7 blocks for Node16,\n-# 21 blocks * 256KB = 5376KB\n+# 11 blocks for prefixes, 2 blocks for Node4, 6 blocks for Node16,\n+# 19 blocks * 256KB = 4864KB\n # WITHOUT the index, our database size is already approximately 17MB here\n \n query I\n-SELECT mem_to_bytes(memory_usage) < 25000000 FROM pragma_database_size();\n+SELECT mem_to_bytes(memory_usage) < 23000000 FROM pragma_database_size();\n ----\n true\n \n@@ -88,11 +86,11 @@ CREATE TABLE art AS SELECT (range * 9876983769044::INT128 % 10000000)::INT64 AS\n statement ok\n CREATE INDEX idx ON art USING ART(id);\n \n-# 10 blocks for approx. 100K distinct leaves, 8 blocks for Node4, 2 blocks for Node256\n-# 20 blocks * 256KB = 5120KB\n+# 1 block for prefixes, 6 blocks for Node4, 2 blocks for Node256\n+# 8 blocks * 256KB = 2048KB\n \n query I\n-SELECT mem_to_bytes(memory_usage) < 7000000 FROM pragma_database_size();\n+SELECT mem_to_bytes(memory_usage) < 4000000 FROM pragma_database_size();\n ----\n true\n \n@@ -107,8 +105,7 @@ CREATE TABLE art AS SELECT (range * 9876983769044::INT128 % 1000)::INT64 AS id F\n statement ok\n CREATE INDEX idx ON art USING ART(id);\n \n-# 1 block for prefixes, 4 blocks for leaf segments, 1 block for leaves,\n-# 1 block for Node4, 1 block for Node256\n+# 1 block for prefixes, 5 blocks for leaves, 1 block for Node4, 1 block for Node256\n # 8 blocks * 256KB = 2048KB\n \n query I\ndiff --git a/test/sql/index/art/nodes/test_art_leaf.test b/test/sql/index/art/nodes/test_art_leaf.test\nnew file mode 100644\nindex 000000000000..01bcf678449d\n--- /dev/null\n+++ b/test/sql/index/art/nodes/test_art_leaf.test\n@@ -0,0 +1,235 @@\n+# name: test/sql/index/art/nodes/test_art_leaf.test\n+# description: Test ART leaf containing duplicates on multi column table\n+# group: [nodes]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE integers AS SELECT range a, 1 AS b, 1 AS c FROM range(1024)\n+\n+statement ok\n+CREATE INDEX b_index ON integers(b)\n+\n+# verify counts\n+\n+query I\n+SELECT sum(b) FROM integers\n+----\n+1024\n+\n+query I\n+SELECT sum(b) FROM integers WHERE b = 1\n+----\n+1024\n+\n+query I\n+SELECT sum(b) FROM integers\n+----\n+1024\n+\n+# now delete some elements\n+\n+statement ok\n+DELETE FROM integers WHERE a < 100\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(b) FROM integers\n+----\n+924\n+\n+query I\n+SELECT COUNT(b) FROM integers WHERE b = 1\n+----\n+924\n+\n+query I\n+SELECT sum(b) FROM integers\n+----\n+924\n+\n+# now delete more elements\n+\n+statement ok\n+DELETE FROM integers WHERE a < 600\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(b) FROM integers\n+----\n+424\n+\n+query I\n+SELECT COUNT(b) FROM integers WHERE b = 1\n+----\n+424\n+\n+query I\n+SELECT sum(b) FROM integers\n+----\n+424\n+\n+# now delete all elements\n+\n+statement ok\n+DELETE FROM integers WHERE a < 1024\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(*) FROM integers\n+----\n+0\n+\n+query I\n+SELECT COUNT(*) FROM integers WHERE b = 1\n+----\n+0\n+\n+query I\n+SELECT COUNT(*) FROM integers\n+----\n+0\n+\n+statement ok\n+DROP INDEX b_index\n+\n+statement ok\n+DROP TABLE integers\n+\n+# test insertion after matching prefixes\n+\n+# load the DB from disk\n+load __TEST_DIR__/test_index.db\n+\n+statement ok\n+CREATE TABLE tbl_leaf_cov (id INTEGER);\n+\n+statement ok\n+CREATE INDEX idx_leaf_cov ON tbl_leaf_cov(id);\n+\n+statement ok\n+INSERT INTO tbl_leaf_cov VALUES (1), (1);\n+\n+# testing growing/shrinking leaves\n+\n+statement ok\n+CREATE TABLE tbl_grow_shrink (id_var VARCHAR, id_int INTEGER, id_point BIGINT);\n+\n+statement ok\n+CREATE INDEX idx_var ON tbl_grow_shrink(id_var);\n+\n+statement ok\n+CREATE INDEX idx_int ON tbl_grow_shrink(id_int);\n+\n+statement ok\n+CREATE INDEX idx_both ON tbl_grow_shrink(id_var, id_int, id_point);\n+\n+statement ok\n+CREATE INDEX idx_point ON tbl_grow_shrink(id_point);\n+\n+# growing\n+\n+loop i 0 29\n+\n+statement ok\n+INSERT INTO tbl_grow_shrink VALUES ('hello there stranger! :sunshine:', 2, ${i});\n+\n+query I\n+SELECT id_var FROM tbl_grow_shrink WHERE rowid = (SELECT min(rowid) FROM tbl_grow_shrink);\n+----\n+hello there stranger! :sunshine:\n+\n+query I\n+SELECT id_int FROM tbl_grow_shrink WHERE rowid = (SELECT min(rowid) FROM tbl_grow_shrink);\n+----\n+2\n+\n+query I\n+SELECT count(id_var) FROM tbl_grow_shrink WHERE id_point = ${i};\n+----\n+1\n+\n+restart\n+\n+query I\n+SELECT id_var FROM tbl_grow_shrink WHERE rowid = (SELECT min(rowid) FROM tbl_grow_shrink);\n+----\n+hello there stranger! :sunshine:\n+\n+query I\n+SELECT id_int FROM tbl_grow_shrink WHERE rowid = (SELECT min(rowid) FROM tbl_grow_shrink);\n+----\n+2\n+\n+query I\n+SELECT count(id_var) FROM tbl_grow_shrink WHERE id_point = ${i};\n+----\n+1\n+\n+endloop\n+\n+# some more queries\n+\n+query I\n+SELECT count(id_var) FROM tbl_grow_shrink;\n+----\n+29\n+\n+query I\n+SELECT sum(id_int) FROM tbl_grow_shrink;\n+----\n+58\n+\n+restart\n+\n+query I\n+SELECT count(id_var) FROM tbl_grow_shrink;\n+----\n+29\n+\n+query I\n+SELECT sum(id_int) FROM tbl_grow_shrink;\n+----\n+58\n+\n+# shrinking\n+\n+loop i 0 29\n+\n+query I\n+SELECT id_var FROM tbl_grow_shrink WHERE rowid = (SELECT min(rowid) FROM tbl_grow_shrink);\n+----\n+hello there stranger! :sunshine:\n+\n+query I\n+SELECT id_int FROM tbl_grow_shrink WHERE rowid = (SELECT min(rowid) FROM tbl_grow_shrink);\n+----\n+2\n+\n+query I\n+SELECT count(id_var) FROM tbl_grow_shrink WHERE id_point = ${i};\n+----\n+1\n+\n+statement ok\n+DELETE FROM tbl_grow_shrink WHERE rowid = (SELECT min(rowid) FROM tbl_grow_shrink);\n+\n+restart\n+\n+endloop\n+\n+# some final checking\n+\n+query I\n+SELECT count(id_var) FROM tbl_grow_shrink;\n+----\n+0\n+\n+query I\n+SELECT sum(id_int) FROM tbl_grow_shrink;\n+----\n+NULL\ndiff --git a/test/sql/index/art/test_art_coverage_leaf.test b/test/sql/index/art/nodes/test_art_leaf_coverage.test\nsimilarity index 73%\nrename from test/sql/index/art/test_art_coverage_leaf.test\nrename to test/sql/index/art/nodes/test_art_leaf_coverage.test\nindex be4ab8542312..88ceb2066d39 100644\n--- a/test/sql/index/art/test_art_coverage_leaf.test\n+++ b/test/sql/index/art/nodes/test_art_leaf_coverage.test\n@@ -1,6 +1,6 @@\n-# name: test/sql/index/art/test_art_coverage_leaf.test\n+# name: test/sql/index/art/nodes/test_art_leaf_coverage.test\n # description: ART coverage tests for leaf code coverage\n-# group: [art]\n+# group: [nodes]\n \n # test deserialization of leaf segments\n \n@@ -71,4 +71,18 @@ statement ok\n INSERT INTO leaf_merge_2 VALUES (2047, 2047)\n \n statement ok\n-CREATE INDEX idx_merge_2 ON leaf_merge_2(id, id2);\n\\ No newline at end of file\n+CREATE INDEX idx_merge_2 ON leaf_merge_2(id, id2);\n+\n+# test merging leaves with same key\n+\n+statement ok\n+CREATE TABLE tbl_dup_ser (id INTEGER);\n+\n+statement ok\n+INSERT INTO tbl_dup_ser SELECT range FROM range(2043);\n+\n+statement ok\n+INSERT INTO tbl_dup_ser SELECT 12345 FROM range(11);\n+\n+statement ok\n+CREATE INDEX idx_dup_ser ON tbl_dup_ser(id);\n\\ No newline at end of file\ndiff --git a/test/sql/index/art/nodes/test_art_leaf_with_duplicates.test b/test/sql/index/art/nodes/test_art_leaf_with_duplicates.test\ndeleted file mode 100644\nindex a16d5b512b73..000000000000\n--- a/test/sql/index/art/nodes/test_art_leaf_with_duplicates.test\n+++ /dev/null\n@@ -1,101 +0,0 @@\n-# name: test/sql/index/art/nodes/test_art_leaf_with_duplicates.test\n-# description: Test ART leaf containing duplicates on multi column table\n-# group: [nodes]\n-\n-statement ok\n-PRAGMA enable_verification\n-\n-statement ok\n-CREATE TABLE integers AS SELECT range a, 1 AS b, 1 AS c FROM range(1024)\n-\n-statement ok\n-CREATE INDEX b_index ON integers(b)\n-\n-# verify counts\n-\n-query I\n-SELECT sum(b) FROM integers\n-----\n-1024\n-\n-query I\n-SELECT sum(b) FROM integers WHERE b = 1\n-----\n-1024\n-\n-query I\n-SELECT sum(b) FROM integers\n-----\n-1024\n-\n-# now delete some elements\n-\n-statement ok\n-DELETE FROM integers WHERE a < 100\n-\n-# verify counts\n-\n-query I\n-SELECT COUNT(b) FROM integers\n-----\n-924\n-\n-query I\n-SELECT COUNT(b) FROM integers WHERE b = 1\n-----\n-924\n-\n-query I\n-SELECT sum(b) FROM integers\n-----\n-924\n-\n-# now delete more elements\n-\n-statement ok\n-DELETE FROM integers WHERE a < 600\n-\n-# verify counts\n-\n-query I\n-SELECT COUNT(b) FROM integers\n-----\n-424\n-\n-query I\n-SELECT COUNT(b) FROM integers WHERE b = 1\n-----\n-424\n-\n-query I\n-SELECT sum(b) FROM integers\n-----\n-424\n-\n-# now delete all elements\n-\n-statement ok\n-DELETE FROM integers WHERE a < 1024\n-\n-# verify counts\n-\n-query I\n-SELECT COUNT(*) FROM integers\n-----\n-0\n-\n-query I\n-SELECT COUNT(*) FROM integers WHERE b = 1\n-----\n-0\n-\n-query I\n-SELECT COUNT(*) FROM integers\n-----\n-0\n-\n-statement ok\n-DROP INDEX b_index\n-\n-statement ok\n-DROP TABLE integers\ndiff --git a/test/sql/index/art/nodes/test_art_prefixes_restart.test b/test/sql/index/art/nodes/test_art_prefixes_restart.test\nindex 87fbdce34a98..251f3244f4ed 100644\n--- a/test/sql/index/art/nodes/test_art_prefixes_restart.test\n+++ b/test/sql/index/art/nodes/test_art_prefixes_restart.test\n@@ -49,7 +49,7 @@ DELETE FROM tbl_varchar;\n statement ok\n INSERT INTO tbl_varchar VALUES ('012345678901234'), ('012345678901235');\n \n-# now with swizzled prefixes\n+# now with serialized prefixes\n \n statement ok\n DELETE FROM tbl_varchar;\ndiff --git a/test/sql/index/art/scan/test_art_scan_coverage.test b/test/sql/index/art/scan/test_art_scan_coverage.test\nnew file mode 100644\nindex 000000000000..23ada689e785\n--- /dev/null\n+++ b/test/sql/index/art/scan/test_art_scan_coverage.test\n@@ -0,0 +1,89 @@\n+# name: test/sql/index/art/scan/test_art_scan_coverage.test\n+# description: Test edge cases during index scans\n+# group: [scan]\n+\n+statement ok\n+CREATE TABLE tab0(pk INTEGER PRIMARY KEY, col0 INTEGER, col1 FLOAT, col2 TEXT, col3 INTEGER, col4 FLOAT, col5 TEXT)\n+\n+statement ok\n+INSERT INTO tab0 VALUES(0,25,74.4,'vvcgn',47,57.68,'ymlye')\n+\n+statement ok\n+INSERT INTO tab0 VALUES(1,72,81.64,'zsnbm',42,74.55,'tzagd')\n+\n+statement ok\n+INSERT INTO tab0 VALUES(2,45,38.39,'dmsso',87,29.20,'ywydk')\n+\n+statement ok\n+INSERT INTO tab0 VALUES(3,81,97.79,'tdbjm',48,89.67,'hvaol')\n+\n+statement ok\n+INSERT INTO tab0 VALUES(4,17,18.5,'ddcya',66,87.1,'ndulx')\n+\n+statement ok\n+INSERT INTO tab0 VALUES(5,46,83.75,'khqpe',31,31.98,'hzpio')\n+\n+statement ok\n+INSERT INTO tab0 VALUES(6,85,8.45,'ugwie',30,22.61,'klsxt')\n+\n+statement ok\n+INSERT INTO tab0 VALUES(7,36,54.34,'pflrv',18,61.89,'vrltg')\n+\n+statement ok\n+INSERT INTO tab0 VALUES(8,47,41.84,'plpkl',76,65.31,'yzivj')\n+\n+statement ok\n+INSERT INTO tab0 VALUES(9,76,63.21,'uakya',80,80.58,'ocfgj')\n+\n+statement ok\n+CREATE TABLE tab1(pk INTEGER PRIMARY KEY, col0 INTEGER, col1 FLOAT, col2 TEXT, col3 INTEGER, col4 FLOAT, col5 TEXT)\n+\n+statement ok\n+CREATE INDEX idx_tab1_0 on tab1 (col0)\n+\n+statement ok\n+CREATE INDEX idx_tab1_1 on tab1 (col1)\n+\n+statement ok\n+CREATE INDEX idx_tab1_3 on tab1 (col3)\n+\n+statement ok\n+CREATE INDEX idx_tab1_4 on tab1 (col4)\n+\n+statement ok\n+INSERT INTO tab1 SELECT * FROM tab0\n+\n+statement ok\n+DELETE FROM tab1 WHERE col3 = 54 AND col1 <= 76.83\n+\n+query I rowsort label-empty\n+SELECT pk FROM tab1 WHERE col3 = 54 AND col1 <= 76.83\n+----\n+\n+query I rowsort label-225\n+SELECT pk FROM tab1 WHERE NOT (col3 = 54 AND col1 <= 76.83)\n+----\n+10 values hashing to e20b902b49a98b1a05ed62804c757f94\n+\n+statement ok\n+DELETE FROM tab1 WHERE (col4 > 71.47) OR col0 IN (98,26,25,60)\n+\n+query I rowsort label-empty\n+SELECT pk FROM tab1 WHERE (col4 > 71.47) OR col0 IN (98,26,25,60)\n+----\n+\n+query I rowsort label-240\n+SELECT pk FROM tab1 WHERE NOT ((col4 > 71.47) OR col0 IN (98,26,25,60))\n+----\n+2\n+5\n+6\n+7\n+8\n+\n+statement ok\n+DELETE FROM tab1 WHERE ((col0 > 32) AND col0 < 87)\n+\n+query I rowsort label-empty\n+SELECT pk FROM tab1 WHERE ((col0 > 32) AND col0 < 87)\n+----\n\\ No newline at end of file\ndiff --git a/test/sql/index/art/storage/test_art_storage.test b/test/sql/index/art/storage/test_art_storage.test\nindex 3de0c524de98..3154be4cd202 100644\n--- a/test/sql/index/art/storage/test_art_storage.test\n+++ b/test/sql/index/art/storage/test_art_storage.test\n@@ -2,6 +2,8 @@\n # description: Test ART storage\n # group: [storage]\n \n+require vector_size 2048\n+\n statement ok\n PRAGMA enable_verification\n \n@@ -30,3 +32,53 @@ SELECT j FROM integers where i = 3;\n \n statement ok\n DROP INDEX i_index\n+\n+# test (de)serialization of leaves\n+\n+statement ok\n+CREATE TABLE tbl_deser_scan(id INTEGER);\n+\n+statement ok\n+INSERT INTO tbl_deser_scan SELECT range FROM range(100000);\n+\n+statement ok\n+INSERT INTO tbl_deser_scan SELECT 424242 FROM range(5);\n+\n+statement ok\n+INSERT INTO tbl_deser_scan SELECT 424243 FROM range(5);\n+\n+statement ok\n+INSERT INTO tbl_deser_scan SELECT 1 FROM range(5);\n+\n+statement ok\n+CREATE INDEX idx_deser_scan ON tbl_deser_scan(id);\n+\n+restart\n+\n+query I\n+SELECT id FROM tbl_deser_scan WHERE id >= 424242;\n+----\n+424242\n+424242\n+424242\n+424242\n+424242\n+424243\n+424243\n+424243\n+424243\n+424243\n+\n+statement ok\n+CREATE TABLE max_row_id AS\n+SELECT max(rowid) AS id FROM tbl_deser_scan WHERE id = 424242;\n+\n+restart\n+\n+statement ok\n+DELETE FROM tbl_deser_scan WHERE rowid = (SELECT MAX(id) FROM max_row_id);\n+\n+restart\n+\n+statement ok\n+INSERT INTO tbl_deser_scan VALUES (1);\ndiff --git a/test/sql/index/art/test_art_coverage_types.test b/test/sql/index/art/types/test_art_coverage_types.test\nsimilarity index 96%\nrename from test/sql/index/art/test_art_coverage_types.test\nrename to test/sql/index/art/types/test_art_coverage_types.test\nindex 74308242a410..f40579b0d775 100644\n--- a/test/sql/index/art/test_art_coverage_types.test\n+++ b/test/sql/index/art/types/test_art_coverage_types.test\n@@ -1,6 +1,6 @@\n-# name: test/sql/index/art/test_art_coverage_types.test\n+# name: test/sql/index/art/types/test_art_coverage_types.test\n # description: ART coverage tests with different key types\n-# group: [art]\n+# group: [types]\n \n # aborting merge due to constraint violation\n \ndiff --git a/test/sql/index/art/vacuum/test_art_vacuum_strings.test_slow b/test/sql/index/art/vacuum/test_art_vacuum_strings.test_slow\nindex de931adaee18..7532a5fa9775 100644\n--- a/test/sql/index/art/vacuum/test_art_vacuum_strings.test_slow\n+++ b/test/sql/index/art/vacuum/test_art_vacuum_strings.test_slow\n@@ -42,7 +42,7 @@ FROM base, empty;\n true\n \n statement ok\n-DROP TABLE temp\n+DROP TABLE temp;\n \n statement ok\n UPDATE empty SET usage = (SELECT mem_to_bytes(current.memory_usage) FROM pragma_database_size() AS current);\n@@ -60,7 +60,7 @@ statement ok\n CREATE INDEX idx ON t(i);\n \n query I\n-SELECT mem_to_bytes(current.memory_usage) > 5 * base.usage\n+SELECT mem_to_bytes(current.memory_usage) > 3 * base.usage AND mem_to_bytes(current.memory_usage) < 7 * base.usage\n FROM base, pragma_database_size() current;\n ----\n 1\n@@ -68,7 +68,7 @@ FROM base, pragma_database_size() current;\n restart\n \n query I\n-SELECT mem_to_bytes(current.memory_usage) < 4 * base.usage\n+SELECT mem_to_bytes(current.memory_usage) < base.usage\n FROM base, pragma_database_size() current;\n ----\n 1\n@@ -78,8 +78,9 @@ FROM base, pragma_database_size() current;\n statement ok\n INSERT INTO t SELECT (range * 4) || 'I am' || (range * 4) || 'a long not' || (range * 4) || 'inlined string' || (range * 4) FROM range(100000) AS range;\n \n+# NOTE: the table itselt also takes up significant memory\n query I\n-SELECT mem_to_bytes(current.memory_usage) > 10 * base.usage\n+SELECT mem_to_bytes(current.memory_usage) > 10 * base.usage AND mem_to_bytes(current.memory_usage) < 25 * base.usage\n FROM base, pragma_database_size() current;\n ----\n 1\ndiff --git a/test/sql/storage/test_index_checkpoint.test b/test/sql/storage/test_index_checkpoint.test\nindex 4efff03daea8..3754d855cd01 100644\n--- a/test/sql/storage/test_index_checkpoint.test\n+++ b/test/sql/storage/test_index_checkpoint.test\n@@ -2,7 +2,7 @@\n # description: Verify that database footprint remains within expected bounds when writing index data.\n # group: [storage]\n \n-# FIXME: once we inline leaves and refactor the (de)serialization, these numbers should all go down\n+# FIXME: once we refactor the (de)serialization, these numbers should go down\n \n require skip_reload\n \n",
  "problem_statement": "[ART] RowID Leaf node specialization\nWe would like to add a special type of Leaf node to the ART.\r\n\r\nThis leaf node only consists of a single rowid, and therefore fits in the size of a pointer.\r\nThat allows us to not need to occupy a page with this data, but instead store it directly in the child list of another node. (saving us a trip to disk that we would otherwise need to do the first time the node is visited)\r\n\r\nSince this specialization only contains a rowid and nothing more, this node can only be used in places where a prefix is not required.\r\n\r\nThe implementation requires adding a super class to the `Node` class that consists of nothing other than virtual functions, and all the variables of Node therefore also need to be private with getters/setters.\r\nThis also adds an extra option to the SwizzleablePointer, as a child pointer can now either be:\r\n- Unswizzled (regular pointer)\r\n- Swizzled (blockid + offset)\r\n- Rowid (rowid_t)\n",
  "hints_text": "I think this is a great idea - I wonder about using `virtual` methods, though. There are already a number of methods in the `Node` class that instead do a switch on the node type. Perhaps moving away from virtual methods for nodes entirely is a better idea? It is not like the `Node` class needs to be extended with logic outside of the few node types.",
  "created_at": "2023-06-30T11:35:53Z"
}