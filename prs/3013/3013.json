{
  "repo": "duckdb/duckdb",
  "pull_number": 3013,
  "instance_id": "duckdb__duckdb-3013",
  "issue_numbers": [
    "3005",
    "3005"
  ],
  "base_commit": "506b05a102a566d8e4a2d2376fbffdf90c5fd711",
  "patch": "diff --git a/src/function/scalar/list/array_slice.cpp b/src/function/scalar/list/array_slice.cpp\nindex 6ac26b67f445..9d724d8dbc36 100644\n--- a/src/function/scalar/list/array_slice.cpp\n+++ b/src/function/scalar/list/array_slice.cpp\n@@ -141,17 +141,11 @@ static void ArraySliceFunction(DataChunk &args, ExpressionState &state, Vector &\n \tD_ASSERT(args.data.size() == 3);\n \tauto count = args.size();\n \n-\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n-\tfor (idx_t i = 0; i < args.ColumnCount(); i++) {\n-\t\tif (args.data[i].GetVectorType() != VectorType::CONSTANT_VECTOR) {\n-\t\t\tresult.SetVectorType(VectorType::FLAT_VECTOR);\n-\t\t}\n-\t}\n-\n \tVector &s = args.data[0];\n \tVector &b = args.data[1];\n \tVector &e = args.data[2];\n \n+\ts.Normalify(count);\n \tswitch (result.GetType().id()) {\n \tcase LogicalTypeId::LIST:\n \t\t// Share the value dictionary as we are just going to slice it\n@@ -164,6 +158,14 @@ static void ArraySliceFunction(DataChunk &args, ExpressionState &state, Vector &\n \tdefault:\n \t\tthrow NotImplementedException(\"Specifier type not implemented\");\n \t}\n+\n+\tresult.SetVectorType(VectorType::CONSTANT_VECTOR);\n+\tfor (idx_t i = 0; i < args.ColumnCount(); i++) {\n+\t\tif (args.data[i].GetVectorType() != VectorType::CONSTANT_VECTOR) {\n+\t\t\tresult.SetVectorType(VectorType::FLAT_VECTOR);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n }\n \n static unique_ptr<FunctionData> ArraySliceBind(ClientContext &context, ScalarFunction &bound_function,\n",
  "test_patch": "diff --git a/test/sql/cte/recursive_array_slice.test b/test/sql/cte/recursive_array_slice.test\nnew file mode 100644\nindex 000000000000..6b60c80c0256\n--- /dev/null\n+++ b/test/sql/cte/recursive_array_slice.test\n@@ -0,0 +1,76 @@\n+# name: test/sql/cte/recursive_array_slice.test\n+# description: Issue #3005: array_slice prevents row values to be used more than once\n+# group: [cte]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE p(loc int8);\n+\n+statement ok\n+INSERT INTO p VALUES (1);\n+\n+query II\n+WITH RECURSIVE t(y, arr) AS\n+(\n+  SELECT 1, array[1,2,3,4,5,6]\n+    UNION ALL\n+  SELECT y+1, arr[:loc]\n+  FROM   t, p\n+  WHERE y < 10\n+) SELECT * FROM t;\n+----\n+1\t[1, 2, 3, 4, 5, 6]\n+2\t[1]\n+3\t[1]\n+4\t[1]\n+5\t[1]\n+6\t[1]\n+7\t[1]\n+8\t[1]\n+9\t[1]\n+10\t[1]\n+\n+query II\n+WITH RECURSIVE t(y, arr) AS\n+(\n+  SELECT 1, array[1,2,3,4,5,6]\n+    UNION ALL\n+  SELECT y+1, arr\n+  FROM   t, p\n+  WHERE y < 10\n+    AND y = loc\n+) SELECT * FROM t;\n+----\n+1\t[1, 2, 3, 4, 5, 6]\n+2\t[1, 2, 3, 4, 5, 6]\n+\n+query II\n+WITH RECURSIVE t(y, arr) AS\n+(\n+  SELECT 1, array[1,2,3,4,5,6]\n+    UNION ALL\n+  SELECT y+1, arr[:loc]\n+  FROM   t, p\n+  WHERE y < 10\n+    AND y = loc\n+) SELECT * FROM t;\n+----\n+1\t[1, 2, 3, 4, 5, 6]\n+2\t[1]\n+\n+query I\n+WITH RECURSIVE t(arr) AS\n+(\n+  SELECT array[1,2,3,4,5,6]\n+    UNION ALL\n+  SELECT  arr[arr[0]:6]\n+  FROM   t\n+  WHERE arr[0] < 6\n+) SELECT * FROM t;\n+----\n+[1, 2, 3, 4, 5, 6]\n+[2, 3, 4, 5, 6]\n+[4, 5, 6]\n+[]\n",
  "problem_statement": "array_slice prevents row values to be used more than once\n#### What happens?\r\n\r\nFunction `array_slice` prevents table rows to be used more than once.\r\n\r\n- `Q1` (see the examples below) works just fine. `p.loc` is used exactly once in `array_slice(arr, NULL, loc)`.\r\n- `Q2` works, too. Again, `p.loc` is used once in the `WHERE`-clause `AND y = loc`.\r\n- `Q3` uses `p.loc` twice, once in `array_slice`, once in the `WHERE`-clause. This fails with:\r\n   `Error: Not implemented Error: FIXME unimplemented vector type for VectorOperations::Copy`\r\n- The error disappears, when `array_slice(arr, NULL, loc)` is replaced with `array[arr[loc]]` in `Q3`.\r\n\r\nThese tests lead me to believe that `array_slice` is causing this strange behavior.\r\n\r\n#### To Reproduce\r\n\r\n```sql\r\nCREATE TABLE p(loc int8);\r\nINSERT INTO p VALUES (1);\r\n\r\n-- Q1: (works fine)\r\nWITH RECURSIVE t(y, arr) AS\r\n(\r\n  SELECT 1, array[1,2,3,4,5,6]\r\n    UNION ALL\r\n  SELECT y+1, array_slice(arr, NULL, loc)\r\n  FROM   t, p\r\n  WHERE y < 10\r\n--    AND y = loc\r\n) SELECT * FROM t;\r\n\r\n-- Q2: (works fine)\r\nWITH RECURSIVE t(y, arr) AS\r\n(\r\n  SELECT 1, array[1,2,3,4,5,6]\r\n    UNION ALL\r\n  SELECT y+1, arr --array_slice(arr, NULL, loc)\r\n  FROM   t, p\r\n  WHERE y < 10\r\n    AND y = loc\r\n) SELECT * FROM t;\r\n\r\n-- Q3: (does not work)\r\nWITH RECURSIVE t(y, arr) AS\r\n(\r\n  SELECT 1, array[1,2,3,4,5,6]\r\n    UNION ALL\r\n  SELECT y+1, array_slice(arr, NULL, loc)\r\n  FROM   t, p\r\n  WHERE y < 10\r\n    AND y = loc\r\n) SELECT * FROM t;\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: macOS Monterey\r\n - DuckDB Version: git head\r\n - DuckDB Client: shell\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\narray_slice prevents row values to be used more than once\n#### What happens?\r\n\r\nFunction `array_slice` prevents table rows to be used more than once.\r\n\r\n- `Q1` (see the examples below) works just fine. `p.loc` is used exactly once in `array_slice(arr, NULL, loc)`.\r\n- `Q2` works, too. Again, `p.loc` is used once in the `WHERE`-clause `AND y = loc`.\r\n- `Q3` uses `p.loc` twice, once in `array_slice`, once in the `WHERE`-clause. This fails with:\r\n   `Error: Not implemented Error: FIXME unimplemented vector type for VectorOperations::Copy`\r\n- The error disappears, when `array_slice(arr, NULL, loc)` is replaced with `array[arr[loc]]` in `Q3`.\r\n\r\nThese tests lead me to believe that `array_slice` is causing this strange behavior.\r\n\r\n#### To Reproduce\r\n\r\n```sql\r\nCREATE TABLE p(loc int8);\r\nINSERT INTO p VALUES (1);\r\n\r\n-- Q1: (works fine)\r\nWITH RECURSIVE t(y, arr) AS\r\n(\r\n  SELECT 1, array[1,2,3,4,5,6]\r\n    UNION ALL\r\n  SELECT y+1, array_slice(arr, NULL, loc)\r\n  FROM   t, p\r\n  WHERE y < 10\r\n--    AND y = loc\r\n) SELECT * FROM t;\r\n\r\n-- Q2: (works fine)\r\nWITH RECURSIVE t(y, arr) AS\r\n(\r\n  SELECT 1, array[1,2,3,4,5,6]\r\n    UNION ALL\r\n  SELECT y+1, arr --array_slice(arr, NULL, loc)\r\n  FROM   t, p\r\n  WHERE y < 10\r\n    AND y = loc\r\n) SELECT * FROM t;\r\n\r\n-- Q3: (does not work)\r\nWITH RECURSIVE t(y, arr) AS\r\n(\r\n  SELECT 1, array[1,2,3,4,5,6]\r\n    UNION ALL\r\n  SELECT y+1, array_slice(arr, NULL, loc)\r\n  FROM   t, p\r\n  WHERE y < 10\r\n    AND y = loc\r\n) SELECT * FROM t;\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: macOS Monterey\r\n - DuckDB Version: git head\r\n - DuckDB Client: shell\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "\n",
  "created_at": "2022-01-31T16:24:21Z"
}