You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Querying View of a View Crashes
#### What happens?
DuckDB crashes with "Segmentation fault: 11" when I try to query a view of a view

#### To Reproduce

```
# This is all fine
con = duckdb.connect(database='test.db')
con.execute("CREATE TABLE IF NOT EXISTS test (val INTEGER);")
con.execute("INSERT INTO test(val) VALUES (1), (2), (3)")
con.execute("CREATE OR REPLACE VIEW foo AS (SELECT * FROM test)")
con.execute("CREATE OR REPLACE VIEW foo AS (SELECT * FROM foo)")

# This crashes
con.execute("SELECT * FROM foo")
```

#### Environment (please complete the following information):
The reproduction above crashes on Google Colab

Querying View of a View Crashes
#### What happens?
DuckDB crashes with "Segmentation fault: 11" when I try to query a view of a view

#### To Reproduce

```
# This is all fine
con = duckdb.connect(database='test.db')
con.execute("CREATE TABLE IF NOT EXISTS test (val INTEGER);")
con.execute("INSERT INTO test(val) VALUES (1), (2), (3)")
con.execute("CREATE OR REPLACE VIEW foo AS (SELECT * FROM test)")
con.execute("CREATE OR REPLACE VIEW foo AS (SELECT * FROM foo)")

# This crashes
con.execute("SELECT * FROM foo")
```

#### Environment (please complete the following information):
The reproduction above crashes on Google Colab


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: #include "duckdb/parser/column_definition.hpp"
13: #include "duckdb/parser/tokens.hpp"
14: #include "duckdb/planner/bind_context.hpp"
15: #include "duckdb/planner/bound_tokens.hpp"
16: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
17: #include "duckdb/planner/logical_operator.hpp"
18: #include "duckdb/planner/bound_statement.hpp"
19: #include "duckdb/common/case_insensitive_map.hpp"
20: #include "duckdb/parser/result_modifier.hpp"
21: 
22: namespace duckdb {
23: class BoundResultModifier;
24: class BoundSelectNode;
25: class ClientContext;
26: class ExpressionBinder;
27: class LimitModifier;
28: class OrderBinder;
29: class TableCatalogEntry;
30: class ViewCatalogEntry;
31: 
32: struct CreateInfo;
33: struct BoundCreateTableInfo;
34: struct BoundCreateFunctionInfo;
35: struct CommonTableExpressionInfo;
36: 
37: enum class BindingMode : uint8_t { STANDARD_BINDING, EXTRACT_NAMES };
38: 
39: struct CorrelatedColumnInfo {
40: 	ColumnBinding binding;
41: 	LogicalType type;
42: 	string name;
43: 	idx_t depth;
44: 
45: 	explicit CorrelatedColumnInfo(BoundColumnRefExpression &expr)
46: 	    : binding(expr.binding), type(expr.return_type), name(expr.GetName()), depth(expr.depth) {
47: 	}
48: 
49: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
50: 		return binding == rhs.binding;
51: 	}
52: };
53: 
54: //! Bind the parsed query tree to the actual columns present in the catalog.
55: /*!
56:   The binder is responsible for binding tables and columns to actual physical
57:   tables and columns in the catalog. In the process, it also resolves types of
58:   all expressions.
59: */
60: class Binder : public std::enable_shared_from_this<Binder> {
61: 	friend class ExpressionBinder;
62: 	friend class SelectBinder;
63: 	friend class RecursiveSubqueryPlanner;
64: 
65: public:
66: 	static shared_ptr<Binder> CreateBinder(ClientContext &context, Binder *parent = nullptr, bool inherit_ctes = true);
67: 
68: 	//! The client context
69: 	ClientContext &context;
70: 	//! A mapping of names to common table expressions
71: 	case_insensitive_map_t<CommonTableExpressionInfo *> CTE_bindings;
72: 	//! The CTEs that have already been bound
73: 	unordered_set<CommonTableExpressionInfo *> bound_ctes;
74: 	//! The bind context
75: 	BindContext bind_context;
76: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
77: 	//! vector)
78: 	vector<CorrelatedColumnInfo> correlated_columns;
79: 	//! The set of parameter expressions bound by this binder
80: 	vector<BoundParameterExpression *> *parameters;
81: 	//! Whether or not the bound statement is read-only
82: 	bool read_only;
83: 	//! Whether or not the statement requires a valid transaction to run
84: 	bool requires_valid_transaction;
85: 	//! Whether or not the statement can be streamed to the client
86: 	bool allow_stream_result;
87: 	//! The alias for the currently processing subquery, if it exists
88: 	string alias;
89: 	//! Macro parameter bindings (if any)
90: 	MacroBinding *macro_binding = nullptr;
91: 
92: public:
93: 	BoundStatement Bind(SQLStatement &statement);
94: 	BoundStatement Bind(QueryNode &node);
95: 
96: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
97: 	void BindCreateViewInfo(CreateViewInfo &base);
98: 	SchemaCatalogEntry *BindSchema(CreateInfo &info);
99: 	SchemaCatalogEntry *BindCreateFunctionInfo(CreateInfo &info);
100: 
101: 	//! Check usage, and cast named parameters to their types
102: 	static void BindNamedParameters(named_parameter_type_map_t &types, named_parameter_map_t &values,
103: 	                                QueryErrorContext &error_context, string &func_name);
104: 
105: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
106: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
107: 
108: 	//! Generates an unused index for a table
109: 	idx_t GenerateTableIndex();
110: 
111: 	//! Add a common table expression to the binder
112: 	void AddCTE(const string &name, CommonTableExpressionInfo *cte);
113: 	//! Find a common table expression by name; returns nullptr if none exists
114: 	CommonTableExpressionInfo *FindCTE(const string &name, bool skip = false);
115: 
116: 	bool CTEIsAlreadyBound(CommonTableExpressionInfo *cte);
117: 
118: 	void PushExpressionBinder(ExpressionBinder *binder);
119: 	void PopExpressionBinder();
120: 	void SetActiveBinder(ExpressionBinder *binder);
121: 	ExpressionBinder *GetActiveBinder();
122: 	bool HasActiveBinder();
123: 
124: 	vector<ExpressionBinder *> &GetActiveBinders();
125: 
126: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
127: 	//! Add a correlated column to this binder (if it does not exist)
128: 	void AddCorrelatedColumn(const CorrelatedColumnInfo &info);
129: 
130: 	string FormatError(ParsedExpression &expr_context, const string &message);
131: 	string FormatError(TableRef &ref_context, const string &message);
132: 
133: 	string FormatErrorRecursive(idx_t query_location, const string &message, vector<ExceptionFormatValue> &values);
134: 	template <class T, typename... Args>
135: 	string FormatErrorRecursive(idx_t query_location, const string &msg, vector<ExceptionFormatValue> &values, T param,
136: 	                            Args... params) {
137: 		values.push_back(ExceptionFormatValue::CreateFormatValue<T>(param));
138: 		return FormatErrorRecursive(query_location, msg, values, params...);
139: 	}
140: 
141: 	template <typename... Args>
142: 	string FormatError(idx_t query_location, const string &msg, Args... params) {
143: 		vector<ExceptionFormatValue> values;
144: 		return FormatErrorRecursive(query_location, msg, values, params...);
145: 	}
146: 
147: 	static void BindLogicalType(ClientContext &context, LogicalType &type, const string &schema = "");
148: 
149: 	bool HasMatchingBinding(const string &table_name, const string &column_name, string &error_message);
150: 	bool HasMatchingBinding(const string &schema_name, const string &table_name, const string &column_name,
151: 	                        string &error_message);
152: 
153: 	void SetBindingMode(BindingMode mode);
154: 	BindingMode GetBindingMode();
155: 	void AddTableName(string table_name);
156: 	const unordered_set<string> &GetTableNames();
157: 
158: private:
159: 	//! The parent binder (if any)
160: 	shared_ptr<Binder> parent;
161: 	//! The vector of active binders
162: 	vector<ExpressionBinder *> active_binders;
163: 	//! The count of bound_tables
164: 	idx_t bound_tables;
165: 	//! Whether or not the binder has any unplanned subqueries that still need to be planned
166: 	bool has_unplanned_subqueries = false;
167: 	//! Whether or not subqueries should be planned already
168: 	bool plan_subquery = true;
169: 	//! Whether CTEs should reference the parent binder (if it exists)
170: 	bool inherit_ctes = true;
171: 	//! Whether or not the binder can contain NULLs as the root of expressions
172: 	bool can_contain_nulls = false;
173: 	//! The root statement of the query that is currently being parsed
174: 	SQLStatement *root_statement = nullptr;
175: 	//! Binding mode
176: 	BindingMode mode = BindingMode::STANDARD_BINDING;
177: 	//! Table names extracted for BindingMode::EXTRACT_NAMES
178: 	unordered_set<string> table_names;
179: 
180: private:
181: 	//! Bind the default values of the columns of a table
182: 	void BindDefaultValues(vector<ColumnDefinition> &columns, vector<unique_ptr<Expression>> &bound_defaults);
183: 	//! Bind a delimiter value (LIMIT or OFFSET)
184: 	unique_ptr<Expression> BindDelimiter(ClientContext &context, unique_ptr<ParsedExpression> delimiter,
185: 	                                     const LogicalType &type, Value &delimiter_value);
186: 
187: 	//! Move correlated expressions from the child binder to this binder
188: 	void MoveCorrelatedExpressions(Binder &other);
189: 
190: 	BoundStatement Bind(SelectStatement &stmt);
191: 	BoundStatement Bind(InsertStatement &stmt);
192: 	BoundStatement Bind(CopyStatement &stmt);
193: 	BoundStatement Bind(DeleteStatement &stmt);
194: 	BoundStatement Bind(UpdateStatement &stmt);
195: 	BoundStatement Bind(CreateStatement &stmt);
196: 	BoundStatement Bind(DropStatement &stmt);
197: 	BoundStatement Bind(AlterStatement &stmt);
198: 	BoundStatement Bind(TransactionStatement &stmt);
199: 	BoundStatement Bind(PragmaStatement &stmt);
200: 	BoundStatement Bind(ExplainStatement &stmt);
201: 	BoundStatement Bind(VacuumStatement &stmt);
202: 	BoundStatement Bind(RelationStatement &stmt);
203: 	BoundStatement Bind(ShowStatement &stmt);
204: 	BoundStatement Bind(CallStatement &stmt);
205: 	BoundStatement Bind(ExportStatement &stmt);
206: 	BoundStatement Bind(SetStatement &stmt);
207: 	BoundStatement Bind(LoadStatement &stmt);
208: 
209: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
210: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
211: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
212: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
213: 
214: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
215: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
216: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
217: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
218: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
219: 
220: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
221: 	unique_ptr<BoundTableRef> Bind(CrossProductRef &ref);
222: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
223: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref, CommonTableExpressionInfo *cte = nullptr);
224: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
225: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
226: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
227: 
228: 	bool BindFunctionParameters(vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
229: 	                            vector<Value> &parameters, named_parameter_map_t &named_parameters,
230: 	                            unique_ptr<BoundSubqueryRef> &subquery, string &error);
231: 
232: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
233: 	unique_ptr<LogicalOperator> CreatePlan(BoundCrossProductRef &ref);
234: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
235: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
236: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
237: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
238: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
239: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
240: 
241: 	unique_ptr<LogicalOperator> BindTable(TableCatalogEntry &table, BaseTableRef &ref);
242: 	unique_ptr<LogicalOperator> BindView(ViewCatalogEntry &view, BaseTableRef &ref);
243: 	unique_ptr<LogicalOperator> BindTableOrView(BaseTableRef &ref);
244: 
245: 	BoundStatement BindCopyTo(CopyStatement &stmt);
246: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
247: 
248: 	void BindModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
249: 	void BindModifierTypes(BoundQueryNode &result, const vector<LogicalType> &sql_types, idx_t projection_index);
250: 
251: 	BoundStatement BindSummarize(ShowStatement &stmt);
252: 	unique_ptr<BoundResultModifier> BindLimit(LimitModifier &limit_mod);
253: 	unique_ptr<BoundResultModifier> BindLimitPercent(LimitPercentModifier &limit_mod);
254: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
255: 
256: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
257: 
258: 	void PlanSubqueries(unique_ptr<Expression> *expr, unique_ptr<LogicalOperator> *root);
259: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
260: 
261: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,
262: 	                                                       vector<LogicalType> &target_types,
263: 	                                                       unique_ptr<LogicalOperator> op);
264: 
265: 	string FindBinding(const string &using_column, const string &join_side);
266: 	bool TryFindBinding(const string &using_column, const string &join_side, string &result);
267: 
268: 	void AddUsingBindingSet(unique_ptr<UsingColumnSet> set);
269: 	string RetrieveUsingBinding(Binder &current_binder, UsingColumnSet *current_set, const string &column_name,
270: 	                            const string &join_side, UsingColumnSet *new_set);
271: 
272: public:
273: 	// This should really be a private constructor, but make_shared does not allow it...
274: 	// If you are thinking about calling this, you should probably call Binder::CreateBinder
275: 	Binder(bool I_know_what_I_am_doing, ClientContext &context, shared_ptr<Binder> parent, bool inherit_ctes);
276: };
277: 
278: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/planner/binder.cpp]
1: #include "duckdb/planner/binder.hpp"
2: 
3: #include "duckdb/parser/statement/list.hpp"
4: #include "duckdb/parser/query_node/select_node.hpp"
5: #include "duckdb/planner/bound_query_node.hpp"
6: #include "duckdb/planner/bound_tableref.hpp"
7: #include "duckdb/planner/expression.hpp"
8: #include "duckdb/planner/operator/logical_sample.hpp"
9: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
10: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
11: 
12: #include <algorithm>
13: 
14: namespace duckdb {
15: 
16: shared_ptr<Binder> Binder::CreateBinder(ClientContext &context, Binder *parent, bool inherit_ctes) {
17: 	return make_shared<Binder>(true, context, parent ? parent->shared_from_this() : nullptr, inherit_ctes);
18: }
19: 
20: Binder::Binder(bool, ClientContext &context, shared_ptr<Binder> parent_p, bool inherit_ctes_p)
21:     : context(context), read_only(true), requires_valid_transaction(true), allow_stream_result(false),
22:       parent(move(parent_p)), bound_tables(0), inherit_ctes(inherit_ctes_p) {
23: 	parameters = nullptr;
24: 	if (parent) {
25: 		// We have to inherit macro parameter bindings from the parent binder, if there is a parent.
26: 		macro_binding = parent->macro_binding;
27: 		if (inherit_ctes) {
28: 			// We have to inherit CTE bindings from the parent bind_context, if there is a parent.
29: 			bind_context.SetCTEBindings(parent->bind_context.GetCTEBindings());
30: 			bind_context.cte_references = parent->bind_context.cte_references;
31: 			parameters = parent->parameters;
32: 		}
33: 	}
34: }
35: 
36: BoundStatement Binder::Bind(SQLStatement &statement) {
37: 	root_statement = &statement;
38: 	switch (statement.type) {
39: 	case StatementType::SELECT_STATEMENT:
40: 		return Bind((SelectStatement &)statement);
41: 	case StatementType::INSERT_STATEMENT:
42: 		return Bind((InsertStatement &)statement);
43: 	case StatementType::COPY_STATEMENT:
44: 		return Bind((CopyStatement &)statement);
45: 	case StatementType::DELETE_STATEMENT:
46: 		return Bind((DeleteStatement &)statement);
47: 	case StatementType::UPDATE_STATEMENT:
48: 		return Bind((UpdateStatement &)statement);
49: 	case StatementType::RELATION_STATEMENT:
50: 		return Bind((RelationStatement &)statement);
51: 	case StatementType::CREATE_STATEMENT:
52: 		return Bind((CreateStatement &)statement);
53: 	case StatementType::DROP_STATEMENT:
54: 		return Bind((DropStatement &)statement);
55: 	case StatementType::ALTER_STATEMENT:
56: 		return Bind((AlterStatement &)statement);
57: 	case StatementType::TRANSACTION_STATEMENT:
58: 		return Bind((TransactionStatement &)statement);
59: 	case StatementType::PRAGMA_STATEMENT:
60: 		return Bind((PragmaStatement &)statement);
61: 	case StatementType::EXPLAIN_STATEMENT:
62: 		return Bind((ExplainStatement &)statement);
63: 	case StatementType::VACUUM_STATEMENT:
64: 		return Bind((VacuumStatement &)statement);
65: 	case StatementType::SHOW_STATEMENT:
66: 		return Bind((ShowStatement &)statement);
67: 	case StatementType::CALL_STATEMENT:
68: 		return Bind((CallStatement &)statement);
69: 	case StatementType::EXPORT_STATEMENT:
70: 		return Bind((ExportStatement &)statement);
71: 	case StatementType::SET_STATEMENT:
72: 		return Bind((SetStatement &)statement);
73: 	case StatementType::LOAD_STATEMENT:
74: 		return Bind((LoadStatement &)statement);
75: 	default: // LCOV_EXCL_START
76: 		throw NotImplementedException("Unimplemented statement type \"%s\" for Bind",
77: 		                              StatementTypeToString(statement.type));
78: 	} // LCOV_EXCL_STOP
79: }
80: 
81: unique_ptr<BoundQueryNode> Binder::BindNode(QueryNode &node) {
82: 	// first we visit the set of CTEs and add them to the bind context
83: 	for (auto &cte_it : node.cte_map) {
84: 		AddCTE(cte_it.first, cte_it.second.get());
85: 	}
86: 	// now we bind the node
87: 	unique_ptr<BoundQueryNode> result;
88: 	switch (node.type) {
89: 	case QueryNodeType::SELECT_NODE:
90: 		result = BindNode((SelectNode &)node);
91: 		break;
92: 	case QueryNodeType::RECURSIVE_CTE_NODE:
93: 		result = BindNode((RecursiveCTENode &)node);
94: 		break;
95: 	default:
96: 		D_ASSERT(node.type == QueryNodeType::SET_OPERATION_NODE);
97: 		result = BindNode((SetOperationNode &)node);
98: 		break;
99: 	}
100: 	return result;
101: }
102: 
103: BoundStatement Binder::Bind(QueryNode &node) {
104: 	auto bound_node = BindNode(node);
105: 
106: 	BoundStatement result;
107: 	result.names = bound_node->names;
108: 	result.types = bound_node->types;
109: 
110: 	// and plan it
111: 	result.plan = CreatePlan(*bound_node);
112: 	return result;
113: }
114: 
115: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundQueryNode &node) {
116: 	switch (node.type) {
117: 	case QueryNodeType::SELECT_NODE:
118: 		return CreatePlan((BoundSelectNode &)node);
119: 	case QueryNodeType::SET_OPERATION_NODE:
120: 		return CreatePlan((BoundSetOperationNode &)node);
121: 	case QueryNodeType::RECURSIVE_CTE_NODE:
122: 		return CreatePlan((BoundRecursiveCTENode &)node);
123: 	default:
124: 		throw InternalException("Unsupported bound query node type");
125: 	}
126: }
127: 
128: unique_ptr<BoundTableRef> Binder::Bind(TableRef &ref) {
129: 	unique_ptr<BoundTableRef> result;
130: 	switch (ref.type) {
131: 	case TableReferenceType::BASE_TABLE:
132: 		result = Bind((BaseTableRef &)ref);
133: 		break;
134: 	case TableReferenceType::CROSS_PRODUCT:
135: 		result = Bind((CrossProductRef &)ref);
136: 		break;
137: 	case TableReferenceType::JOIN:
138: 		result = Bind((JoinRef &)ref);
139: 		break;
140: 	case TableReferenceType::SUBQUERY:
141: 		result = Bind((SubqueryRef &)ref);
142: 		break;
143: 	case TableReferenceType::EMPTY:
144: 		result = Bind((EmptyTableRef &)ref);
145: 		break;
146: 	case TableReferenceType::TABLE_FUNCTION:
147: 		result = Bind((TableFunctionRef &)ref);
148: 		break;
149: 	case TableReferenceType::EXPRESSION_LIST:
150: 		result = Bind((ExpressionListRef &)ref);
151: 		break;
152: 	default:
153: 		throw InternalException("Unknown table ref type");
154: 	}
155: 	result->sample = move(ref.sample);
156: 	return result;
157: }
158: 
159: unique_ptr<LogicalOperator> Binder::CreatePlan(BoundTableRef &ref) {
160: 	unique_ptr<LogicalOperator> root;
161: 	switch (ref.type) {
162: 	case TableReferenceType::BASE_TABLE:
163: 		root = CreatePlan((BoundBaseTableRef &)ref);
164: 		break;
165: 	case TableReferenceType::SUBQUERY:
166: 		root = CreatePlan((BoundSubqueryRef &)ref);
167: 		break;
168: 	case TableReferenceType::JOIN:
169: 		root = CreatePlan((BoundJoinRef &)ref);
170: 		break;
171: 	case TableReferenceType::CROSS_PRODUCT:
172: 		root = CreatePlan((BoundCrossProductRef &)ref);
173: 		break;
174: 	case TableReferenceType::TABLE_FUNCTION:
175: 		root = CreatePlan((BoundTableFunction &)ref);
176: 		break;
177: 	case TableReferenceType::EMPTY:
178: 		root = CreatePlan((BoundEmptyTableRef &)ref);
179: 		break;
180: 	case TableReferenceType::EXPRESSION_LIST:
181: 		root = CreatePlan((BoundExpressionListRef &)ref);
182: 		break;
183: 	case TableReferenceType::CTE:
184: 		root = CreatePlan((BoundCTERef &)ref);
185: 		break;
186: 	default:
187: 		throw InternalException("Unsupported bound table ref type type");
188: 	}
189: 	// plan the sample clause
190: 	if (ref.sample) {
191: 		root = make_unique<LogicalSample>(move(ref.sample), move(root));
192: 	}
193: 	return root;
194: }
195: 
196: void Binder::AddCTE(const string &name, CommonTableExpressionInfo *info) {
197: 	D_ASSERT(info);
198: 	D_ASSERT(!name.empty());
199: 	auto entry = CTE_bindings.find(name);
200: 	if (entry != CTE_bindings.end()) {
201: 		throw InternalException("Duplicate CTE \"%s\" in query!", name);
202: 	}
203: 	CTE_bindings[name] = info;
204: }
205: 
206: CommonTableExpressionInfo *Binder::FindCTE(const string &name, bool skip) {
207: 	auto entry = CTE_bindings.find(name);
208: 	if (entry != CTE_bindings.end()) {
209: 		if (!skip || entry->second->query->node->type == QueryNodeType::RECURSIVE_CTE_NODE) {
210: 			return entry->second;
211: 		}
212: 	}
213: 	if (parent && inherit_ctes) {
214: 		return parent->FindCTE(name, name == alias);
215: 	}
216: 	return nullptr;
217: }
218: 
219: bool Binder::CTEIsAlreadyBound(CommonTableExpressionInfo *cte) {
220: 	if (bound_ctes.find(cte) != bound_ctes.end()) {
221: 		return true;
222: 	}
223: 	if (parent && inherit_ctes) {
224: 		return parent->CTEIsAlreadyBound(cte);
225: 	}
226: 	return false;
227: }
228: 
229: idx_t Binder::GenerateTableIndex() {
230: 	if (parent) {
231: 		return parent->GenerateTableIndex();
232: 	}
233: 	return bound_tables++;
234: }
235: 
236: void Binder::PushExpressionBinder(ExpressionBinder *binder) {
237: 	GetActiveBinders().push_back(binder);
238: }
239: 
240: void Binder::PopExpressionBinder() {
241: 	D_ASSERT(HasActiveBinder());
242: 	GetActiveBinders().pop_back();
243: }
244: 
245: void Binder::SetActiveBinder(ExpressionBinder *binder) {
246: 	D_ASSERT(HasActiveBinder());
247: 	GetActiveBinders().back() = binder;
248: }
249: 
250: ExpressionBinder *Binder::GetActiveBinder() {
251: 	return GetActiveBinders().back();
252: }
253: 
254: bool Binder::HasActiveBinder() {
255: 	return !GetActiveBinders().empty();
256: }
257: 
258: vector<ExpressionBinder *> &Binder::GetActiveBinders() {
259: 	if (parent) {
260: 		return parent->GetActiveBinders();
261: 	}
262: 	return active_binders;
263: }
264: 
265: void Binder::AddUsingBindingSet(unique_ptr<UsingColumnSet> set) {
266: 	if (parent) {
267: 		parent->AddUsingBindingSet(move(set));
268: 		return;
269: 	}
270: 	bind_context.AddUsingBindingSet(move(set));
271: }
272: 
273: void Binder::MoveCorrelatedExpressions(Binder &other) {
274: 	MergeCorrelatedColumns(other.correlated_columns);
275: 	other.correlated_columns.clear();
276: }
277: 
278: void Binder::MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other) {
279: 	for (idx_t i = 0; i < other.size(); i++) {
280: 		AddCorrelatedColumn(other[i]);
281: 	}
282: }
283: 
284: void Binder::AddCorrelatedColumn(const CorrelatedColumnInfo &info) {
285: 	// we only add correlated columns to the list if they are not already there
286: 	if (std::find(correlated_columns.begin(), correlated_columns.end(), info) == correlated_columns.end()) {
287: 		correlated_columns.push_back(info);
288: 	}
289: }
290: 
291: bool Binder::HasMatchingBinding(const string &table_name, const string &column_name, string &error_message) {
292: 	string empty_schema;
293: 	return HasMatchingBinding(empty_schema, table_name, column_name, error_message);
294: }
295: 
296: bool Binder::HasMatchingBinding(const string &schema_name, const string &table_name, const string &column_name,
297:                                 string &error_message) {
298: 	Binding *binding;
299: 	if (macro_binding && table_name == macro_binding->alias) {
300: 		binding = macro_binding;
301: 	} else {
302: 		binding = bind_context.GetBinding(table_name, error_message);
303: 	}
304: 	if (!binding) {
305: 		return false;
306: 	}
307: 	if (!schema_name.empty()) {
308: 		auto table_entry = binding->GetTableEntry();
309: 		if (!table_entry) {
310: 			return false;
311: 		}
312: 		if (table_entry->schema->name != schema_name || table_entry->name != table_name) {
313: 			return false;
314: 		}
315: 	}
316: 	if (!binding->HasMatchingBinding(column_name)) {
317: 		error_message = binding->ColumnNotFoundError(column_name);
318: 		return false;
319: 	}
320: 	return true;
321: }
322: 
323: void Binder::SetBindingMode(BindingMode mode) {
324: 	if (parent) {
325: 		parent->SetBindingMode(mode);
326: 	}
327: 	this->mode = mode;
328: }
329: 
330: BindingMode Binder::GetBindingMode() {
331: 	if (parent) {
332: 		return parent->GetBindingMode();
333: 	}
334: 	return mode;
335: }
336: 
337: void Binder::AddTableName(string table_name) {
338: 	if (parent) {
339: 		parent->AddTableName(move(table_name));
340: 		return;
341: 	}
342: 	table_names.insert(move(table_name));
343: }
344: 
345: const unordered_set<string> &Binder::GetTableNames() {
346: 	if (parent) {
347: 		return parent->GetTableNames();
348: 	}
349: 	return table_names;
350: }
351: 
352: string Binder::FormatError(ParsedExpression &expr_context, const string &message) {
353: 	return FormatError(expr_context.query_location, message);
354: }
355: 
356: string Binder::FormatError(TableRef &ref_context, const string &message) {
357: 	return FormatError(ref_context.query_location, message);
358: }
359: 
360: string Binder::FormatErrorRecursive(idx_t query_location, const string &message, vector<ExceptionFormatValue> &values) {
361: 	QueryErrorContext context(root_statement, query_location);
362: 	return context.FormatErrorRecursive(message, values);
363: }
364: 
365: } // namespace duckdb
[end of src/planner/binder.cpp]
[start of src/planner/binder/tableref/bind_basetableref.cpp]
1: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
2: #include "duckdb/parser/tableref/basetableref.hpp"
3: #include "duckdb/parser/tableref/subqueryref.hpp"
4: #include "duckdb/parser/query_node/select_node.hpp"
5: #include "duckdb/planner/binder.hpp"
6: #include "duckdb/planner/tableref/bound_basetableref.hpp"
7: #include "duckdb/planner/tableref/bound_subqueryref.hpp"
8: #include "duckdb/planner/tableref/bound_cteref.hpp"
9: #include "duckdb/planner/operator/logical_get.hpp"
10: #include "duckdb/parser/statement/select_statement.hpp"
11: #include "duckdb/function/table/table_scan.hpp"
12: #include "duckdb/common/string_util.hpp"
13: #include "duckdb/parser/tableref/table_function_ref.hpp"
14: #include "duckdb/main/config.hpp"
15: #include "duckdb/planner/tableref/bound_dummytableref.hpp"
16: 
17: namespace duckdb {
18: 
19: unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {
20: 	QueryErrorContext error_context(root_statement, ref.query_location);
21: 	// CTEs and views are also referred to using BaseTableRefs, hence need to distinguish here
22: 	// check if the table name refers to a CTE
23: 	auto cte = FindCTE(ref.table_name, ref.table_name == alias);
24: 	if (cte) {
25: 		// Check if there is a CTE binding in the BindContext
26: 		auto ctebinding = bind_context.GetCTEBinding(ref.table_name);
27: 		if (!ctebinding) {
28: 			if (CTEIsAlreadyBound(cte)) {
29: 				throw BinderException("Circular reference to CTE \"%s\", use WITH RECURSIVE to use recursive CTEs",
30: 				                      ref.table_name);
31: 			}
32: 			// Move CTE to subquery and bind recursively
33: 			SubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(cte->query->Copy()));
34: 			subquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;
35: 			subquery.column_name_alias = cte->aliases;
36: 			for (idx_t i = 0; i < ref.column_name_alias.size(); i++) {
37: 				if (i < subquery.column_name_alias.size()) {
38: 					subquery.column_name_alias[i] = ref.column_name_alias[i];
39: 				} else {
40: 					subquery.column_name_alias.push_back(ref.column_name_alias[i]);
41: 				}
42: 			}
43: 			return Bind(subquery, cte);
44: 		} else {
45: 			// There is a CTE binding in the BindContext.
46: 			// This can only be the case if there is a recursive CTE present.
47: 			auto index = GenerateTableIndex();
48: 			auto result = make_unique<BoundCTERef>(index, ctebinding->index);
49: 			auto b = ctebinding;
50: 			auto alias = ref.alias.empty() ? ref.table_name : ref.alias;
51: 			auto names = BindContext::AliasColumnNames(alias, b->names, ref.column_name_alias);
52: 
53: 			bind_context.AddGenericBinding(index, alias, names, b->types);
54: 			// Update references to CTE
55: 			auto cteref = bind_context.cte_references[ref.table_name];
56: 			(*cteref)++;
57: 
58: 			result->types = b->types;
59: 			result->bound_columns = move(names);
60: 			return move(result);
61: 		}
62: 	}
63: 	// not a CTE
64: 	// extract a table or view from the catalog
65: 	auto table_or_view =
66: 	    Catalog::GetCatalog(context).GetEntry(context, CatalogType::TABLE_ENTRY, ref.schema_name, ref.table_name,
67: 	                                          ref.schema_name.empty() ? true : false, error_context);
68: 	if (!table_or_view) {
69: 		// table could not be found: try to bind a replacement scan
70: 		auto &config = DBConfig::GetConfig(context);
71: 		for (auto &scan : config.replacement_scans) {
72: 			auto replacement_function = scan.function(ref.table_name, scan.data);
73: 			if (replacement_function) {
74: 				replacement_function->alias = ref.alias.empty() ? ref.table_name : ref.alias;
75: 				replacement_function->column_name_alias = ref.column_name_alias;
76: 				return Bind(*replacement_function);
77: 			}
78: 		}
79: 		// we still didn't find the table
80: 		if (GetBindingMode() == BindingMode::EXTRACT_NAMES) {
81: 			// if we are in EXTRACT_NAMES, we create a dummy table ref
82: 			AddTableName(ref.table_name);
83: 
84: 			// add a bind context entry
85: 			auto table_index = GenerateTableIndex();
86: 			auto alias = ref.alias.empty() ? ref.table_name : ref.alias;
87: 			vector<LogicalType> types {LogicalType::INTEGER};
88: 			vector<string> names {"__dummy_col" + to_string(table_index)};
89: 			bind_context.AddGenericBinding(table_index, alias, names, types);
90: 			return make_unique_base<BoundTableRef, BoundEmptyTableRef>(table_index);
91: 		}
92: 		// could not find an alternative: bind again to get the error
93: 		table_or_view = Catalog::GetCatalog(context).GetEntry(context, CatalogType::TABLE_ENTRY, ref.schema_name,
94: 		                                                      ref.table_name, false, error_context);
95: 	}
96: 	switch (table_or_view->type) {
97: 	case CatalogType::TABLE_ENTRY: {
98: 		// base table: create the BoundBaseTableRef node
99: 		auto table_index = GenerateTableIndex();
100: 		auto table = (TableCatalogEntry *)table_or_view;
101: 
102: 		auto scan_function = TableScanFunction::GetFunction();
103: 		auto bind_data = make_unique<TableScanBindData>(table);
104: 		auto alias = ref.alias.empty() ? ref.table_name : ref.alias;
105: 		vector<LogicalType> table_types;
106: 		vector<string> table_names;
107: 		for (auto &col : table->columns) {
108: 			table_types.push_back(col.type);
109: 			table_names.push_back(col.name);
110: 		}
111: 		table_names = BindContext::AliasColumnNames(alias, table_names, ref.column_name_alias);
112: 
113: 		auto logical_get =
114: 		    make_unique<LogicalGet>(table_index, scan_function, move(bind_data), table_types, table_names);
115: 		bind_context.AddBaseTable(table_index, alias, table_names, table_types, *logical_get);
116: 		return make_unique_base<BoundTableRef, BoundBaseTableRef>(table, move(logical_get));
117: 	}
118: 	case CatalogType::VIEW_ENTRY: {
119: 		// the node is a view: get the query that the view represents
120: 		auto view_catalog_entry = (ViewCatalogEntry *)table_or_view;
121: 		// We need to use a new binder for the view that doesn't reference any CTEs
122: 		// defined for this binder so there are no collisions between the CTEs defined
123: 		// for the view and for the current query
124: 		bool inherit_ctes = false;
125: 		auto view_binder = Binder::CreateBinder(context, this, inherit_ctes);
126: 		view_binder->can_contain_nulls = true;
127: 		SubqueryRef subquery(unique_ptr_cast<SQLStatement, SelectStatement>(view_catalog_entry->query->Copy()));
128: 		subquery.alias = ref.alias.empty() ? ref.table_name : ref.alias;
129: 		subquery.column_name_alias =
130: 		    BindContext::AliasColumnNames(subquery.alias, view_catalog_entry->aliases, ref.column_name_alias);
131: 		// bind the child subquery
132: 		auto bound_child = view_binder->Bind(subquery);
133: 		D_ASSERT(bound_child->type == TableReferenceType::SUBQUERY);
134: 		// verify that the types and names match up with the expected types and names
135: 		auto &bound_subquery = (BoundSubqueryRef &)*bound_child;
136: 		if (bound_subquery.subquery->types != view_catalog_entry->types) {
137: 			throw BinderException("Contents of view were altered: types don't match!");
138: 		}
139: 		bind_context.AddSubquery(bound_subquery.subquery->GetRootIndex(), subquery.alias, subquery,
140: 		                         *bound_subquery.subquery);
141: 		return bound_child;
142: 	}
143: 	default:
144: 		throw InternalException("Catalog entry type");
145: 	}
146: }
147: } // namespace duckdb
[end of src/planner/binder/tableref/bind_basetableref.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: