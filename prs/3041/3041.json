{
  "repo": "duckdb/duckdb",
  "pull_number": 3041,
  "instance_id": "duckdb__duckdb-3041",
  "issue_numbers": [
    "3017",
    "3017"
  ],
  "base_commit": "d7a24678d7686d7cbeaeda1f67567b63ccd7564c",
  "patch": "diff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 6602c67e0b3d..14794e31c5eb 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -115,6 +115,9 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \n \tbool CTEIsAlreadyBound(CommonTableExpressionInfo *cte);\n \n+\t//! Add the view to the set of currently bound views - used for detecting recursive view definitions\n+\tvoid AddBoundView(ViewCatalogEntry *view);\n+\n \tvoid PushExpressionBinder(ExpressionBinder *binder);\n \tvoid PopExpressionBinder();\n \tvoid SetActiveBinder(ExpressionBinder *binder);\n@@ -176,6 +179,8 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \tBindingMode mode = BindingMode::STANDARD_BINDING;\n \t//! Table names extracted for BindingMode::EXTRACT_NAMES\n \tunordered_set<string> table_names;\n+\t//! The set of bound views\n+\tunordered_set<ViewCatalogEntry *> bound_views;\n \n private:\n \t//! Bind the default values of the columns of a table\ndiff --git a/src/planner/binder.cpp b/src/planner/binder.cpp\nindex 1119ff21bdb4..b396cec5e5c2 100644\n--- a/src/planner/binder.cpp\n+++ b/src/planner/binder.cpp\n@@ -8,6 +8,7 @@\n #include \"duckdb/planner/operator/logical_sample.hpp\"\n #include \"duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\"\n #include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n+#include \"duckdb/catalog/catalog_entry/view_catalog_entry.hpp\"\n \n #include <algorithm>\n \n@@ -226,6 +227,19 @@ bool Binder::CTEIsAlreadyBound(CommonTableExpressionInfo *cte) {\n \treturn false;\n }\n \n+void Binder::AddBoundView(ViewCatalogEntry *view) {\n+\t// check if the view is already bound\n+\tauto current = this;\n+\twhile (current) {\n+\t\tif (current->bound_views.find(view) != current->bound_views.end()) {\n+\t\t\tthrow BinderException(\"infinite recursion detected: attempting to recursively bind view \\\"%s\\\"\",\n+\t\t\t                      view->name);\n+\t\t}\n+\t\tcurrent = current->parent.get();\n+\t}\n+\tbound_views.insert(view);\n+}\n+\n idx_t Binder::GenerateTableIndex() {\n \tif (parent) {\n \t\treturn parent->GenerateTableIndex();\ndiff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex 78294c5c9c4d..ccebd1b31f9c 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -129,7 +129,9 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \t\tsubquery.column_name_alias =\n \t\t    BindContext::AliasColumnNames(subquery.alias, view_catalog_entry->aliases, ref.column_name_alias);\n \t\t// bind the child subquery\n+\t\tview_binder->AddBoundView(view_catalog_entry);\n \t\tauto bound_child = view_binder->Bind(subquery);\n+\n \t\tD_ASSERT(bound_child->type == TableReferenceType::SUBQUERY);\n \t\t// verify that the types and names match up with the expected types and names\n \t\tauto &bound_subquery = (BoundSubqueryRef &)*bound_child;\n",
  "test_patch": "diff --git a/test/sql/catalog/view/recursive_view.test b/test/sql/catalog/view/recursive_view.test\nnew file mode 100644\nindex 000000000000..a2f23da8a587\n--- /dev/null\n+++ b/test/sql/catalog/view/recursive_view.test\n@@ -0,0 +1,35 @@\n+# name: test/sql/catalog/view/recursive_view.test\n+# description: Issue #3017: Querying View of a View Crashes\n+# group: [view]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE IF NOT EXISTS test (val INTEGER);\n+\n+statement ok\n+INSERT INTO test(val) VALUES (1), (2), (3);\n+\n+# recursive view definition\n+statement ok\n+CREATE OR REPLACE VIEW foo AS (SELECT * FROM test);\n+\n+statement ok\n+CREATE OR REPLACE VIEW foo AS (SELECT * FROM foo);\n+\n+statement error\n+SELECT * FROM foo;\n+\n+# more complex recursive view definition\n+statement ok\n+CREATE OR REPLACE VIEW foo AS (SELECT * FROM test);\n+\n+statement ok\n+CREATE OR REPLACE VIEW foo2 AS (SELECT * FROM foo);\n+\n+statement ok\n+CREATE OR REPLACE VIEW foo AS (SELECT (SELECT * FROM foo2));\n+\n+statement error\n+SELECT * FROM foo;\n",
  "problem_statement": "Querying View of a View Crashes\n#### What happens?\r\nDuckDB crashes with \"Segmentation fault: 11\" when I try to query a view of a view\r\n\r\n#### To Reproduce\r\n\r\n```\r\n# This is all fine\r\ncon = duckdb.connect(database='test.db')\r\ncon.execute(\"CREATE TABLE IF NOT EXISTS test (val INTEGER);\")\r\ncon.execute(\"INSERT INTO test(val) VALUES (1), (2), (3)\")\r\ncon.execute(\"CREATE OR REPLACE VIEW foo AS (SELECT * FROM test)\")\r\ncon.execute(\"CREATE OR REPLACE VIEW foo AS (SELECT * FROM foo)\")\r\n\r\n# This crashes\r\ncon.execute(\"SELECT * FROM foo\")\r\n```\r\n\r\n#### Environment (please complete the following information):\r\nThe reproduction above crashes on Google Colab\r\n\nQuerying View of a View Crashes\n#### What happens?\r\nDuckDB crashes with \"Segmentation fault: 11\" when I try to query a view of a view\r\n\r\n#### To Reproduce\r\n\r\n```\r\n# This is all fine\r\ncon = duckdb.connect(database='test.db')\r\ncon.execute(\"CREATE TABLE IF NOT EXISTS test (val INTEGER);\")\r\ncon.execute(\"INSERT INTO test(val) VALUES (1), (2), (3)\")\r\ncon.execute(\"CREATE OR REPLACE VIEW foo AS (SELECT * FROM test)\")\r\ncon.execute(\"CREATE OR REPLACE VIEW foo AS (SELECT * FROM foo)\")\r\n\r\n# This crashes\r\ncon.execute(\"SELECT * FROM foo\")\r\n```\r\n\r\n#### Environment (please complete the following information):\r\nThe reproduction above crashes on Google Colab\r\n\n",
  "hints_text": "It looks like that second view has the same name as the prior view (both are foo). It shouldn't segfault for sure, but that should get it working for you in the short term!\n> It looks like that second view has the same name as the prior view (both are foo). It shouldn't segfault for sure, but that should get it working for you in the short term!\r\n\r\nThanks for the prompt reply! And thanks for DuckDB, I really do like it.\r\n\r\nYes I have it working with multiple view names. But I like the ability to incrementally build up a view, a few columns at a time, referencing previous columns by name. That experience mimics the favorable developer ergonomics of a Pandas DF. Having to name each table foo1, foo2, foo3 etc, incrementing as I add each column, is tedious and error prone.\nHmm, I don't know of any SQL database that supports that exact kind of incremental view building with the exact same name. CTE's (Common Table Expressions) are another way to build incrementally (but each must be named differently). \r\n\r\nOne more approach that will be slightly slower in performance, but maybe more convenient, is to execute each query and retrieve the results as the same Pandas DF, and have the next query point at that same DF. For example:\r\n```python\r\nmy_df = duckdb_conn.execute(\"SELECT * from test\").fetchdf()\r\nmy_df = duckdb_conn.execute(\"SELECT * from my_df\").fetchdf()\r\nmy_df = duckdb_conn.execute(\"SELECT * from my_df\").fetchdf()\r\n\r\n```\r\n\r\nAlso, have you had a look at our [Python Relational API](https://github.com/duckdb/duckdb/blob/master/examples/python/duckdb-python.py)?\r\n\nI can confirm this segfaults\n> Hmm, I don't know of any SQL database that supports that exact kind of incremental view building with the exact same name.\r\n\r\nIndeed. But DuckDB is forging a brave new path, bringing the power of databases to the data scientist workflow! There is a reason pandas has become hugely popular for data wrangling, and its api is entirely centered on incrementally building up a DF, one column at a time. \r\n\r\nActually the best solution may be to let us reference column aliases from within the same SELECT clause that defines them. That would be a super powerful feature. \r\n\r\nSaying all this as someone who is cheering for the DuckDB project to succeed, and take market share from DataFrames, but who has extensively used DataFrames and understands why they have a more appealing API than conventional SQL\u2026\r\n\r\n\nThanks for being on team DuckDB!\r\n\r\nReferring to previous aliases in the Select clause was requested previously in #1547. We agree that would be a great feature! We are open to a PR if you would like to give it a try!\nIt looks like that second view has the same name as the prior view (both are foo). It shouldn't segfault for sure, but that should get it working for you in the short term!\n> It looks like that second view has the same name as the prior view (both are foo). It shouldn't segfault for sure, but that should get it working for you in the short term!\r\n\r\nThanks for the prompt reply! And thanks for DuckDB, I really do like it.\r\n\r\nYes I have it working with multiple view names. But I like the ability to incrementally build up a view, a few columns at a time, referencing previous columns by name. That experience mimics the favorable developer ergonomics of a Pandas DF. Having to name each table foo1, foo2, foo3 etc, incrementing as I add each column, is tedious and error prone.\nHmm, I don't know of any SQL database that supports that exact kind of incremental view building with the exact same name. CTE's (Common Table Expressions) are another way to build incrementally (but each must be named differently). \r\n\r\nOne more approach that will be slightly slower in performance, but maybe more convenient, is to execute each query and retrieve the results as the same Pandas DF, and have the next query point at that same DF. For example:\r\n```python\r\nmy_df = duckdb_conn.execute(\"SELECT * from test\").fetchdf()\r\nmy_df = duckdb_conn.execute(\"SELECT * from my_df\").fetchdf()\r\nmy_df = duckdb_conn.execute(\"SELECT * from my_df\").fetchdf()\r\n\r\n```\r\n\r\nAlso, have you had a look at our [Python Relational API](https://github.com/duckdb/duckdb/blob/master/examples/python/duckdb-python.py)?\r\n\nI can confirm this segfaults\n> Hmm, I don't know of any SQL database that supports that exact kind of incremental view building with the exact same name.\r\n\r\nIndeed. But DuckDB is forging a brave new path, bringing the power of databases to the data scientist workflow! There is a reason pandas has become hugely popular for data wrangling, and its api is entirely centered on incrementally building up a DF, one column at a time. \r\n\r\nActually the best solution may be to let us reference column aliases from within the same SELECT clause that defines them. That would be a super powerful feature. \r\n\r\nSaying all this as someone who is cheering for the DuckDB project to succeed, and take market share from DataFrames, but who has extensively used DataFrames and understands why they have a more appealing API than conventional SQL\u2026\r\n\r\n\nThanks for being on team DuckDB!\r\n\r\nReferring to previous aliases in the Select clause was requested previously in #1547. We agree that would be a great feature! We are open to a PR if you would like to give it a try!",
  "created_at": "2022-02-05T16:16:14Z"
}