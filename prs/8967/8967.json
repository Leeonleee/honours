{
  "repo": "duckdb/duckdb",
  "pull_number": 8967,
  "instance_id": "duckdb__duckdb-8967",
  "issue_numbers": [
    "8857"
  ],
  "base_commit": "52a47a6b311a8aa008e7c78d8472eb52a937fa62",
  "patch": "diff --git a/src/execution/operator/csv_scanner/csv_reader_options.cpp b/src/execution/operator/csv_scanner/csv_reader_options.cpp\nindex ac0d07ba5780..a17e7b487ba9 100644\n--- a/src/execution/operator/csv_scanner/csv_reader_options.cpp\n+++ b/src/execution/operator/csv_scanner/csv_reader_options.cpp\n@@ -500,7 +500,7 @@ void CSVReaderOptions::ToNamedParameters(named_parameter_map_t &named_params) {\n \t}\n \n \tnamed_params[\"normalize_names\"] = Value::BOOLEAN(normalize_names);\n-\tif (!name_list.empty()) {\n+\tif (!name_list.empty() && !named_params.count(\"column_names\") && !named_params.count(\"names\")) {\n \t\tnamed_params[\"column_names\"] = StringVectorToValue(name_list);\n \t}\n \tnamed_params[\"all_varchar\"] = Value::BOOLEAN(all_varchar);\ndiff --git a/tools/pythonpkg/duckdb-stubs/__init__.pyi b/tools/pythonpkg/duckdb-stubs/__init__.pyi\nindex f7aee9235483..07955fc33387 100644\n--- a/tools/pythonpkg/duckdb-stubs/__init__.pyi\n+++ b/tools/pythonpkg/duckdb-stubs/__init__.pyi\n@@ -127,60 +127,60 @@ class PythonExceptionHandling:\n     def value(self) -> int: ...\n \n class Expression:\n-\tdef __init__(self, *args, **kwargs) -> None: ...\n-\tdef __neg__(self) -> \"Expression\": ...\n-\n-\tdef __add__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __radd__(self, expr: \"Expression\") -> \"Expression\": ...\n-\n-\tdef __sub__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __rsub__(self, expr: \"Expression\") -> \"Expression\": ...\n-\n-\tdef __mul__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __rmul__(self, expr: \"Expression\") -> \"Expression\": ...\n-\n-\tdef __div__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __rdiv__(self, expr: \"Expression\") -> \"Expression\": ...\n-\n-\tdef __truediv__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __rtruediv__(self, expr: \"Expression\") -> \"Expression\": ...\n-\n-\tdef __floordiv__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __rfloordiv__(self, expr: \"Expression\") -> \"Expression\": ...\n-\n-\tdef __mod__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __rmod__(self, expr: \"Expression\") -> \"Expression\": ...\n-\n-\tdef __pow__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __rpow__(self, expr: \"Expression\") -> \"Expression\": ...\n-\n-\tdef __and__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __rand__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __or__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __ror__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __invert__(self) -> \"Expression\": ...\n-\n-\tdef __eq__(# type: ignore[override]\n-\t\tself, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __ne__(# type: ignore[override]\n-\t\tself, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __gt__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __ge__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __lt__(self, expr: \"Expression\") -> \"Expression\": ...\n-\tdef __le__(self, expr: \"Expression\") -> \"Expression\": ...\n-\n-\tdef show(self, max_width: Optional[int] = None, max_rows: Optional[int] = None, max_col_width: Optional[int] = None, null_value: Optional[str] = None, render_mode: Optional[RenderMode] = None) -> None: ...\n-\tdef __repr__(self) -> str: ...\n-\tdef alias(self, alias: str) -> None: ...\n-\tdef when(self, condition: \"Expression\", value: \"Expression\") -> \"Expression\": ...\n-\tdef otherwise(self, value: \"Expression\") -> \"Expression\": ...\n-\tdef cast(self, type: DuckDBPyType) -> \"Expression\": ...\n-\tdef asc(self) -> \"Expression\": ...\n-\tdef desc(self) -> \"Expression\": ...\n-\tdef nulls_first(self) -> \"Expression\": ...\n-\tdef nulls_last(self) -> \"Expression\": ...\n-\tdef isin(self, *cols: \"Expression\") -> \"Expression\": ...\n-\tdef isnotin(self, *cols: \"Expression\") -> \"Expression\": ...\n+    def __init__(self, *args, **kwargs) -> None: ...\n+    def __neg__(self) -> \"Expression\": ...\n+\n+    def __add__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __radd__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+    def __sub__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __rsub__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+    def __mul__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __rmul__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+    def __div__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __rdiv__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+    def __truediv__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __rtruediv__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+    def __floordiv__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __rfloordiv__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+    def __mod__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __rmod__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+    def __pow__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __rpow__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+    def __and__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __rand__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __or__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __ror__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __invert__(self) -> \"Expression\": ...\n+\n+    def __eq__(# type: ignore[override]\n+        self, expr: \"Expression\") -> \"Expression\": ...\n+    def __ne__(# type: ignore[override]\n+        self, expr: \"Expression\") -> \"Expression\": ...\n+    def __gt__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __ge__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __lt__(self, expr: \"Expression\") -> \"Expression\": ...\n+    def __le__(self, expr: \"Expression\") -> \"Expression\": ...\n+\n+    def show(self, max_width: Optional[int] = None, max_rows: Optional[int] = None, max_col_width: Optional[int] = None, null_value: Optional[str] = None, render_mode: Optional[RenderMode] = None) -> None: ...\n+    def __repr__(self) -> str: ...\n+    def alias(self, alias: str) -> None: ...\n+    def when(self, condition: \"Expression\", value: \"Expression\") -> \"Expression\": ...\n+    def otherwise(self, value: \"Expression\") -> \"Expression\": ...\n+    def cast(self, type: DuckDBPyType) -> \"Expression\": ...\n+    def asc(self) -> \"Expression\": ...\n+    def desc(self) -> \"Expression\": ...\n+    def nulls_first(self) -> \"Expression\": ...\n+    def nulls_last(self) -> \"Expression\": ...\n+    def isin(self, *cols: \"Expression\") -> \"Expression\": ...\n+    def isnotin(self, *cols: \"Expression\") -> \"Expression\": ...\n \n def StarExpression(exclude: Optional[List[str]]) -> Expression: ...\n def ColumnExpression(column: str) -> Expression: ...\n@@ -239,10 +239,12 @@ class DuckDBPyConnection:\n         all_varchar: Optional[bool] = None,\n         normalize_names: Optional[bool] = None,\n         filename: Optional[bool] = None,\n+        null_padding: Optional[bool] = None,\n+        names: Optional[List[str]] = None\n     ) -> DuckDBPyRelation: ...\n     def from_csv_auto(\n         self,\n-        name: str,\n+        path_or_buffer: Union[str, StringIO, TextIOBase],\n         header: Optional[bool | int] = None,\n         compression: Optional[str] = None,\n         sep: Optional[str] = None,\n@@ -261,6 +263,7 @@ class DuckDBPyConnection:\n         normalize_names: Optional[bool] = None,\n         filename: Optional[bool] = None,\n         null_padding: Optional[bool] = None,\n+        names: Optional[List[str]] = None\n     ) -> DuckDBPyRelation: ...\n     def from_df(self, df: pandas.DataFrame = ...) -> DuckDBPyRelation: ...\n     @overload\ndiff --git a/tools/pythonpkg/duckdb_python.cpp b/tools/pythonpkg/duckdb_python.cpp\nindex d6a8c752a7b0..ff1e220844d4 100644\n--- a/tools/pythonpkg/duckdb_python.cpp\n+++ b/tools/pythonpkg/duckdb_python.cpp\n@@ -202,7 +202,7 @@ static void InitializeConnectionMethods(py::module_ &m) {\n \t    py::arg(\"encoding\") = py::none(), py::arg(\"parallel\") = py::none(), py::arg(\"date_format\") = py::none(),\n \t    py::arg(\"timestamp_format\") = py::none(), py::arg(\"sample_size\") = py::none(),\n \t    py::arg(\"all_varchar\") = py::none(), py::arg(\"normalize_names\") = py::none(), py::arg(\"filename\") = py::none(),\n-\t    py::arg(\"null_padding\") = py::none());\n+\t    py::arg(\"null_padding\") = py::none(), py::arg(\"names\") = py::none());\n \n \tm.def(\"append\", &PyConnectionWrapper::Append, \"Append the passed DataFrame to the named table\",\n \t      py::arg(\"table_name\"), py::arg(\"df\"), py::kw_only(), py::arg(\"by_name\") = false,\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp b/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\nindex cdf6dc7ea0e4..34c6a93b2e2a 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/connection_wrapper.hpp\n@@ -138,7 +138,7 @@ class PyConnectionWrapper {\n \t        const py::object &date_format = py::none(), const py::object &timestamp_format = py::none(),\n \t        const py::object &sample_size = py::none(), const py::object &all_varchar = py::none(),\n \t        const py::object &normalize_names = py::none(), const py::object &filename = py::none(),\n-\t        const py::object &null_padding = py::none());\n+\t        const py::object &null_padding = py::none(), const py::object &names = py::none());\n \n \tstatic py::list FetchAll(shared_ptr<DuckDBPyConnection> conn = nullptr);\n \ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\nindex ce1462244065..322311515861 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyconnection/pyconnection.hpp\n@@ -77,7 +77,8 @@ struct DuckDBPyConnection : public std::enable_shared_from_this<DuckDBPyConnecti\n \t        const py::object &parallel = py::none(), const py::object &date_format = py::none(),\n \t        const py::object &timestamp_format = py::none(), const py::object &sample_size = py::none(),\n \t        const py::object &all_varchar = py::none(), const py::object &normalize_names = py::none(),\n-\t        const py::object &filename = py::none(), const py::object &null_padding = py::none());\n+\t        const py::object &filename = py::none(), const py::object &null_padding = py::none(),\n+\t        const py::object &names = py::none());\n \n \tunique_ptr<DuckDBPyRelation> ReadJSON(const string &filename, const Optional<py::object> &columns = py::none(),\n \t                                      const Optional<py::object> &sample_size = py::none(),\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 1c90426dda2e..a2c0445b3c0c 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -214,7 +214,7 @@ static void InitializeConnectionMethods(py::class_<DuckDBPyConnection, shared_pt\n \t             py::arg(\"date_format\") = py::none(), py::arg(\"timestamp_format\") = py::none(),\n \t             py::arg(\"sample_size\") = py::none(), py::arg(\"all_varchar\") = py::none(),\n \t             py::arg(\"normalize_names\") = py::none(), py::arg(\"filename\") = py::none(),\n-\t             py::arg(\"null_padding\") = py::none());\n+\t             py::arg(\"null_padding\") = py::none(), py::arg(\"names\") = py::none());\n \n \tm.def(\"from_df\", &DuckDBPyConnection::FromDF, \"Create a relation object from the Data.Frame in df\",\n \t      py::arg(\"df\") = py::none())\n@@ -706,7 +706,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n     const py::object &quotechar, const py::object &escapechar, const py::object &encoding, const py::object &parallel,\n     const py::object &date_format, const py::object &timestamp_format, const py::object &sample_size,\n     const py::object &all_varchar, const py::object &normalize_names, const py::object &filename,\n-    const py::object &null_padding) {\n+    const py::object &null_padding, const py::object &names_p) {\n \tif (!connection) {\n \t\tthrow ConnectionException(\"Connection has already been closed\");\n \t}\n@@ -753,7 +753,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \t\t\t\tif (!py::try_cast(kv.second, sql_type)) {\n \t\t\t\t\tthrow py::value_error(\"The types provided to 'dtype' have to be DuckDBPyType\");\n \t\t\t\t}\n-\t\t\t\tstruct_fields.emplace_back(py::str(kv.first), Value(py::str(kv.second)));\n+\t\t\t\tstruct_fields.emplace_back(py::str(kv.first), Value(sql_type->ToString()));\n \t\t\t}\n \t\t\tauto dtype_struct = Value::STRUCT(std::move(struct_fields));\n \t\t\tbind_parameters[\"dtypes\"] = std::move(dtype_struct);\n@@ -765,7 +765,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \t\t\t\tif (!py::try_cast(child, sql_type)) {\n \t\t\t\t\tthrow py::value_error(\"The types provided to 'dtype' have to be DuckDBPyType\");\n \t\t\t\t}\n-\t\t\t\tlist_values.push_back(std::string(py::str(child)));\n+\t\t\t\tlist_values.push_back(sql_type->ToString());\n \t\t\t}\n \t\t\tbind_parameters[\"dtypes\"] = Value::LIST(LogicalType::VARCHAR, std::move(list_values));\n \t\t} else {\n@@ -784,22 +784,20 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \t\tbind_parameters[\"delim\"] = Value(py::str(delimiter));\n \t}\n \n-\t// We don't support overriding the names of the header yet\n-\t// 'names'\n-\t// if (keywords.count(\"names\")) {\n-\t//\tif (!py::isinstance<py::list>(kwargs[\"names\"])) {\n-\t//\t\tthrow InvalidInputException(\"read_csv only accepts 'names' as a list of strings\");\n-\t//\t}\n-\t//\tvector<string> names;\n-\t//\tpy::list names_list = kwargs[\"names\"];\n-\t//\tfor (auto& elem : names_list) {\n-\t//\t\tif (!py::isinstance<py::str>(elem)) {\n-\t//\t\t\tthrow InvalidInputException(\"read_csv 'names' list has to consist of only strings\");\n-\t//\t\t}\n-\t//\t\tnames.push_back(py::str(elem));\n-\t//\t}\n-\t//\t// FIXME: Check for uniqueness of 'names' ?\n-\t//}\n+\tif (!py::none().is(names_p)) {\n+\t\tif (!py::isinstance<py::list>(names_p)) {\n+\t\t\tthrow InvalidInputException(\"read_csv only accepts 'names' as a list of strings\");\n+\t\t}\n+\t\tvector<Value> names;\n+\t\tpy::list names_list = names_p;\n+\t\tfor (auto &elem : names_list) {\n+\t\t\tif (!py::isinstance<py::str>(elem)) {\n+\t\t\t\tthrow InvalidInputException(\"read_csv 'names' list has to consist of only strings\");\n+\t\t\t}\n+\t\t\tnames.push_back(Value(std::string(py::str(elem))));\n+\t\t}\n+\t\tbind_parameters[\"names\"] = Value::LIST(LogicalType::VARCHAR, std::move(names));\n+\t}\n \n \tif (!py::none().is(na_values)) {\n \t\tif (!py::isinstance<py::str>(na_values)) {\ndiff --git a/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp b/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\nindex bd4ed10bef88..060cf9a8fd41 100644\n--- a/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\n+++ b/tools/pythonpkg/src/pyduckdb/connection_wrapper.cpp\n@@ -245,16 +245,18 @@ unique_ptr<DuckDBPyRelation> PyConnectionWrapper::ReadJSON(const string &filenam\n \treturn conn->ReadJSON(filename, columns, sample_size, maximum_depth, records, format);\n }\n \n-unique_ptr<DuckDBPyRelation> PyConnectionWrapper::ReadCSV(\n-    const py::object &name, shared_ptr<DuckDBPyConnection> conn, const py::object &header,\n-    const py::object &compression, const py::object &sep, const py::object &delimiter, const py::object &dtype,\n-    const py::object &na_values, const py::object &skiprows, const py::object &quotechar, const py::object &escapechar,\n-    const py::object &encoding, const py::object &parallel, const py::object &date_format,\n-    const py::object &timestamp_format, const py::object &sample_size, const py::object &all_varchar,\n-    const py::object &normalize_names, const py::object &filename, const py::object &null_padding) {\n+unique_ptr<DuckDBPyRelation>\n+PyConnectionWrapper::ReadCSV(const py::object &name, shared_ptr<DuckDBPyConnection> conn, const py::object &header,\n+                             const py::object &compression, const py::object &sep, const py::object &delimiter,\n+                             const py::object &dtype, const py::object &na_values, const py::object &skiprows,\n+                             const py::object &quotechar, const py::object &escapechar, const py::object &encoding,\n+                             const py::object &parallel, const py::object &date_format,\n+                             const py::object &timestamp_format, const py::object &sample_size,\n+                             const py::object &all_varchar, const py::object &normalize_names,\n+                             const py::object &filename, const py::object &null_padding, const py::object &names) {\n \treturn conn->ReadCSV(name, header, compression, sep, delimiter, dtype, na_values, skiprows, quotechar, escapechar,\n \t                     encoding, parallel, date_format, timestamp_format, sample_size, all_varchar, normalize_names,\n-\t                     filename, null_padding);\n+\t                     filename, null_padding, names);\n }\n \n py::list PyConnectionWrapper::FetchMany(idx_t size, shared_ptr<DuckDBPyConnection> conn) {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/api/test_read_csv.py b/tools/pythonpkg/tests/fast/api/test_read_csv.py\nindex 4b35064d7365..b5d954556673 100644\n--- a/tools/pythonpkg/tests/fast/api/test_read_csv.py\n+++ b/tools/pythonpkg/tests/fast/api/test_read_csv.py\n@@ -5,6 +5,7 @@\n import pytest\n import duckdb\n from io import StringIO, BytesIO\n+from duckdb.typing import BIGINT, VARCHAR, INTEGER\n \n \n def TestFile(name):\n@@ -495,3 +496,51 @@ def test_read_csv_combined(self):\n         # And assert that the columns and types of the relations are the same\n         assert rel.columns == rel2.columns\n         assert rel.types == rel2.types\n+\n+    def test_read_csv_names(self):\n+        con = duckdb.connect()\n+        file = StringIO('one,two,three,four\\n1,2,3,4\\n1,2,3,4\\n1,2,3,4')\n+        rel = con.read_csv(file, names=['a', 'b', 'c'])\n+        assert rel.columns == ['a', 'b', 'c', 'four']\n+\n+        with pytest.raises(duckdb.InvalidInputException, match=\"read_csv only accepts 'names' as a list of strings\"):\n+            rel = con.read_csv(file, names=True)\n+\n+        # Excessive columns is fine, just doesn't have any effect past the number of provided columns\n+        rel = con.read_csv(file, names=['a', 'b', 'c', 'd', 'e'])\n+        assert rel.columns == ['a', 'b', 'c', 'd']\n+\n+        # Duplicates are not okay\n+        with pytest.raises(duckdb.BinderException, match=\"has duplicate column name\"):\n+            rel = con.read_csv(file, names=['a', 'b', 'a', 'b'])\n+            assert rel.columns == ['a', 'b', 'a', 'b']\n+\n+    def test_read_csv_names_mixed_with_dtypes(self):\n+        con = duckdb.connect()\n+        file = StringIO('one,two,three,four\\n1,2,3,4\\n1,2,3,4\\n1,2,3,4')\n+        rel = con.read_csv(\n+            file,\n+            names=['a', 'b', 'c'],\n+            dtype={\n+                'a': int,\n+                'b': bool,\n+                'c': str,\n+            },\n+        )\n+        assert rel.columns == ['a', 'b', 'c', 'four']\n+        assert rel.types == ['BIGINT', 'BOOLEAN', 'VARCHAR', 'BIGINT']\n+\n+        # dtypes and names dont match\n+        # FIXME: seems the order columns are named in this error is non-deterministic\n+        # so for now I'm excluding the list of columns from the expected error\n+        expected_error = \"\"\"do not exist in the CSV File\"\"\"\n+        with pytest.raises(duckdb.BinderException, match=expected_error):\n+            rel = con.read_csv(\n+                file,\n+                names=['a', 'b', 'c'],\n+                dtype={\n+                    'd': int,\n+                    'e': bool,\n+                    'f': str,\n+                },\n+            )\n",
  "problem_statement": "[python] read_csv() doesn't support the \"names\" or \"auto_detect\" parameters that the CLI/SQL function supports\n### What happens?\n\nI would like to see parity between the python `read_csv` method API and the duckdb SQL function `read_csv` API [as documented here](https://duckdb.org/docs/data/csv/overview.html#parameters). In particular, the `names` and `auto_dectect` parameters seem to be missing.\r\n\r\nHere is what the python API supports in v0.8.1: \r\n```\r\n(method) def read_csv(\r\n    path_or_buffer: str | StringIO | TextIOBase,\r\n    header: bool | int | None = None,\r\n    compression: str | None = None,\r\n    sep: str | None = None,\r\n    delimiter: str | None = None,\r\n    dtype: Dict[str, str] | List[str] | None = None,\r\n    na_values: str | None = None,\r\n    skiprows: int | None = None,\r\n    quotechar: str | None = None,\r\n    escapechar: str | None = None,\r\n    encoding: str | None = None,\r\n    parallel: bool | None = None,\r\n    date_format: str | None = None,\r\n    timestamp_format: str | None = None,\r\n    sample_size: int | None = None,\r\n    all_varchar: bool | None = None,\r\n    normalize_names: bool | None = None,\r\n    filename: bool | None = None\r\n) -> DuckDBPyRelation\r\n```\r\n\r\nAnd here's the error you'll see if you try to use one of the parameters:\r\n\r\n```\r\nTypeError: read_csv(): incompatible function arguments. The following argument types are supported:\r\n    1. (self: duckdb.duckdb.DuckDBPyConnection, name: object, *, header: object = None, compression: object = None, sep: object = None, delimiter: object = None, dtype: object = None, na_values: object = None, skiprows: object = None, quotechar: object = None, escapechar: object = None, encoding: object = None, parallel: object = None, date_format: object = None, timestamp_format: object = None, sample_size: object = None, all_varchar: object = None, normalize_names: object = None, filename: object = None, null_padding: object = None) -> duckdb.duckdb.DuckDBPyRelation\r\n```\n\n### To Reproduce\n\n_Assumes `python -m pip install duckdb, fsspec`_\r\n```\r\nimport io, duckdb\r\nconn = duckdb.connect()\r\nfile = io.StringIO('one,two,three,four\\n1,2,3,4\\n1,2,3,4\\n1,2,3,4')\r\nconn.read_csv(file, names=['a','b', 'c']) # TypeError\r\nconn.read_csv(file, auto_detect=False) # TypeError\r\nconn.read_csv(file) # Success\r\n```\n\n### OS:\n\nmacOS-arm64\n\n### DuckDB Version:\n\n0.8.1\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nTyler BoddySpargo\n\n### Affiliation:\n\nDataChat\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a main build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "Sounds like it's the same issue that will be fixed by #8387 \r\nI'll add it to the tests \ud83d\udc4d",
  "created_at": "2023-09-17T11:32:59Z"
}