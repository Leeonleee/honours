{
  "repo": "duckdb/duckdb",
  "pull_number": 1773,
  "instance_id": "duckdb__duckdb-1773",
  "issue_numbers": [
    "1771"
  ],
  "base_commit": "0109d4301b8ed005ca5396c177cf5ef36bef5274",
  "patch": "diff --git a/src/function/pragma/pragma_functions.cpp b/src/function/pragma/pragma_functions.cpp\nindex 23da0a27be9c..39e2ced72ba3 100644\n--- a/src/function/pragma/pragma_functions.cpp\n+++ b/src/function/pragma/pragma_functions.cpp\n@@ -72,10 +72,8 @@ static void PragmaProfileOutput(ClientContext &context, const FunctionParameters\n \tcontext.profiler->save_location = parameters.values[0].ToString();\n }\n \n-static idx_t ParseMemoryLimit(string arg);\n-\n static void PragmaMemoryLimit(ClientContext &context, const FunctionParameters &parameters) {\n-\tidx_t new_limit = ParseMemoryLimit(parameters.values[0].ToString());\n+\tidx_t new_limit = DBConfig::ParseMemoryLimit(parameters.values[0].ToString());\n \t// set the new limit in the buffer manager\n \tBufferManager::GetBufferManager(context).SetLimit(new_limit);\n }\n@@ -220,7 +218,7 @@ static void PragmaPerfectHashThreshold(ClientContext &context, const FunctionPar\n }\n \n static void PragmaAutoCheckpointThreshold(ClientContext &context, const FunctionParameters &parameters) {\n-\tidx_t new_limit = ParseMemoryLimit(parameters.values[0].ToString());\n+\tidx_t new_limit = DBConfig::ParseMemoryLimit(parameters.values[0].ToString());\n \tDBConfig::GetConfig(context).checkpoint_wal_size = new_limit;\n }\n \n@@ -310,56 +308,4 @@ void PragmaFunctions::RegisterFunction(BuiltinFunctions &set) {\n \t    PragmaFunction::PragmaAssignment(\"debug_checkpoint_abort\", PragmaDebugCheckpointAbort, LogicalType::VARCHAR));\n }\n \n-idx_t ParseMemoryLimit(string arg) {\n-\tif (arg[0] == '-' || arg == \"null\" || arg == \"none\") {\n-\t\treturn INVALID_INDEX;\n-\t}\n-\t// split based on the number/non-number\n-\tidx_t idx = 0;\n-\twhile (StringUtil::CharacterIsSpace(arg[idx])) {\n-\t\tidx++;\n-\t}\n-\tidx_t num_start = idx;\n-\twhile ((arg[idx] >= '0' && arg[idx] <= '9') || arg[idx] == '.' || arg[idx] == 'e' || arg[idx] == 'E' ||\n-\t       arg[idx] == '-') {\n-\t\tidx++;\n-\t}\n-\tif (idx == num_start) {\n-\t\tthrow ParserException(\"Memory limit must have a number (e.g. PRAGMA memory_limit=1GB\");\n-\t}\n-\tstring number = arg.substr(num_start, idx - num_start);\n-\n-\t// try to parse the number\n-\tdouble limit = Cast::Operation<string_t, double>(string_t(number));\n-\n-\t// now parse the memory limit unit (e.g. bytes, gb, etc)\n-\twhile (StringUtil::CharacterIsSpace(arg[idx])) {\n-\t\tidx++;\n-\t}\n-\tidx_t start = idx;\n-\twhile (idx < arg.size() && !StringUtil::CharacterIsSpace(arg[idx])) {\n-\t\tidx++;\n-\t}\n-\tif (limit < 0) {\n-\t\t// limit < 0, set limit to infinite\n-\t\treturn (idx_t)-1;\n-\t}\n-\tstring unit = StringUtil::Lower(arg.substr(start, idx - start));\n-\tidx_t multiplier;\n-\tif (unit == \"byte\" || unit == \"bytes\" || unit == \"b\") {\n-\t\tmultiplier = 1;\n-\t} else if (unit == \"kilobyte\" || unit == \"kilobytes\" || unit == \"kb\" || unit == \"k\") {\n-\t\tmultiplier = 1000LL;\n-\t} else if (unit == \"megabyte\" || unit == \"megabytes\" || unit == \"mb\" || unit == \"m\") {\n-\t\tmultiplier = 1000LL * 1000LL;\n-\t} else if (unit == \"gigabyte\" || unit == \"gigabytes\" || unit == \"gb\" || unit == \"g\") {\n-\t\tmultiplier = 1000LL * 1000LL * 1000LL;\n-\t} else if (unit == \"terabyte\" || unit == \"terabytes\" || unit == \"tb\" || unit == \"t\") {\n-\t\tmultiplier = 1000LL * 1000LL * 1000LL * 1000LL;\n-\t} else {\n-\t\tthrow ParserException(\"Unknown unit for memory_limit: %s (expected: b, mb, gb or tb)\", unit);\n-\t}\n-\treturn (idx_t)multiplier * limit;\n-}\n-\n } // namespace duckdb\n\\ No newline at end of file\ndiff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp\nindex 6ff22c59fe3a..f8749e420fdd 100644\n--- a/src/include/duckdb/main/config.hpp\n+++ b/src/include/duckdb/main/config.hpp\n@@ -24,6 +24,24 @@ class TableFunctionRef;\n enum class AccessMode : uint8_t { UNDEFINED = 0, AUTOMATIC = 1, READ_ONLY = 2, READ_WRITE = 3 };\n enum class CheckpointAbort : uint8_t { NO_ABORT = 0, DEBUG_ABORT_BEFORE_TRUNCATE = 1, DEBUG_ABORT_BEFORE_HEADER = 2 };\n \n+enum class ConfigurationOptionType : uint32_t {\n+\tINVALID = 0,\n+\tACCESS_MODE,\n+\tDEFAULT_ORDER_TYPE,\n+\tDEFAULT_NULL_ORDER,\n+\tENABLE_EXTERNAL_ACCESS,\n+\tENABLE_OBJECT_CACHE,\n+\tMAXIMUM_MEMORY,\n+\tTHREADS\n+};\n+\n+struct ConfigurationOption {\n+\tConfigurationOptionType type;\n+\tconst char *name;\n+\tconst char *description;\n+\tLogicalTypeId parameter_type;\n+};\n+\n // this is optional and only used in tests at the moment\n struct DBConfig {\n \tfriend class DatabaseInstance;\n@@ -58,7 +76,7 @@ struct DBConfig {\n \t//! Null ordering used when none is specified (default: NULLS FIRST)\n \tOrderByNullType default_null_order = OrderByNullType::NULLS_FIRST;\n \t//! enable COPY and related commands\n-\tbool enable_copy = true;\n+\tbool enable_external_access = true;\n \t//! Whether or not object cache is used\n \tbool object_cache_enable = false;\n \t//! Database configuration variables as controlled by SET\n@@ -75,6 +93,14 @@ struct DBConfig {\n public:\n \tDUCKDB_API static DBConfig &GetConfig(ClientContext &context);\n \tDUCKDB_API static DBConfig &GetConfig(DatabaseInstance &db);\n+\tDUCKDB_API static vector<ConfigurationOption> GetOptions();\n+\n+\t//! Fetch an option by name. Returns a pointer to the option, or nullptr if none exists.\n+\tDUCKDB_API static ConfigurationOption *GetOptionByName(const string &name);\n+\n+\tDUCKDB_API void SetOption(const ConfigurationOption &option, const Value &value);\n+\n+\tDUCKDB_API static idx_t ParseMemoryLimit(const string &arg);\n };\n \n } // namespace duckdb\ndiff --git a/src/main/CMakeLists.txt b/src/main/CMakeLists.txt\nindex f7466bf1f34a..42142fdf39f9 100644\n--- a/src/main/CMakeLists.txt\n+++ b/src/main/CMakeLists.txt\n@@ -3,6 +3,7 @@ add_subdirectory(relation)\n set(DUCKDB_MAIN_FILES\n     appender.cpp\n     client_context.cpp\n+    config.cpp\n     connection.cpp\n     database.cpp\n     materialized_query_result.cpp\ndiff --git a/src/main/config.cpp b/src/main/config.cpp\nnew file mode 100644\nindex 000000000000..8fdf3be32127\n--- /dev/null\n+++ b/src/main/config.cpp\n@@ -0,0 +1,156 @@\n+#include \"duckdb/main/config.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/common/operator/cast_operators.hpp\"\n+\n+namespace duckdb {\n+\n+static ConfigurationOption internal_options[] = {\n+    {ConfigurationOptionType::ACCESS_MODE, \"access_mode\",\n+     \"Access mode of the database ([AUTOMATIC], READ_ONLY or READ_WRITE)\", LogicalTypeId::VARCHAR},\n+    {ConfigurationOptionType::DEFAULT_ORDER_TYPE, \"default_order\",\n+     \"The order type used when none is specified ([ASC] or DESC)\", LogicalTypeId::VARCHAR},\n+    {ConfigurationOptionType::DEFAULT_NULL_ORDER, \"default_null_order\",\n+     \"Null ordering used when none is specified ([NULLS_FIRST] or NULLS_LAST)\", LogicalTypeId::VARCHAR},\n+    {ConfigurationOptionType::ENABLE_EXTERNAL_ACCESS, \"enable_external_access\",\n+     \"Allow the database to access external state (through e.g. COPY TO/FROM, CSV readers, pandas replacement scans, \"\n+     \"etc)\",\n+     LogicalTypeId::BOOLEAN},\n+    {ConfigurationOptionType::ENABLE_OBJECT_CACHE, \"enable_object_cache\",\n+     \"Whether or not object cache is used to cache e.g. Parquet metadata\", LogicalTypeId::BOOLEAN},\n+    {ConfigurationOptionType::MAXIMUM_MEMORY, \"max_memory\", \"The maximum memory of the system (e.g. 1GB)\",\n+     LogicalTypeId::VARCHAR},\n+    {ConfigurationOptionType::THREADS, \"threads\", \"The number of total threads used by the system\",\n+     LogicalTypeId::BIGINT},\n+    {ConfigurationOptionType::INVALID, nullptr, nullptr, LogicalTypeId::INVALID}};\n+\n+vector<ConfigurationOption> DBConfig::GetOptions() {\n+\tvector<ConfigurationOption> options;\n+\tfor (idx_t index = 0; internal_options[index].name; index++) {\n+\t\toptions.push_back(internal_options[index]);\n+\t}\n+\treturn options;\n+}\n+\n+ConfigurationOption *DBConfig::GetOptionByName(const string &name) {\n+\tfor (idx_t index = 0; internal_options[index].name; index++) {\n+\t\tif (internal_options[index].name == name) {\n+\t\t\treturn internal_options + index;\n+\t\t}\n+\t}\n+\treturn nullptr;\n+}\n+\n+void DBConfig::SetOption(const ConfigurationOption &option, const Value &value) {\n+\tswitch (option.type) {\n+\tcase ConfigurationOptionType::ACCESS_MODE: {\n+\t\tauto parameter = StringUtil::Lower(value.ToString());\n+\t\tif (parameter == \"automatic\") {\n+\t\t\taccess_mode = AccessMode::AUTOMATIC;\n+\t\t} else if (parameter == \"read_only\") {\n+\t\t\taccess_mode = AccessMode::READ_ONLY;\n+\t\t} else if (parameter == \"read_write\") {\n+\t\t\taccess_mode = AccessMode::READ_WRITE;\n+\t\t} else {\n+\t\t\tthrow InvalidInputException(\n+\t\t\t    \"Unrecognized parameter for option ACCESS_MODE \\\"%s\\\". Expected READ_ONLY or READ_WRITE.\", parameter);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase ConfigurationOptionType::DEFAULT_ORDER_TYPE: {\n+\t\tauto parameter = StringUtil::Lower(value.ToString());\n+\t\tif (parameter == \"asc\") {\n+\t\t\tdefault_order_type = OrderType::ASCENDING;\n+\t\t} else if (parameter == \"desc\") {\n+\t\t\tdefault_order_type = OrderType::DESCENDING;\n+\t\t} else {\n+\t\t\tthrow InvalidInputException(\"Unrecognized parameter for option DEFAULT_ORDER \\\"%s\\\". Expected ASC or DESC.\",\n+\t\t\t                            parameter);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase ConfigurationOptionType::DEFAULT_NULL_ORDER: {\n+\t\tauto parameter = StringUtil::Lower(value.ToString());\n+\t\tif (parameter == \"nulls_first\") {\n+\t\t\tdefault_null_order = OrderByNullType::NULLS_FIRST;\n+\t\t} else if (parameter == \"nulls_last\") {\n+\t\t\tdefault_null_order = OrderByNullType::NULLS_LAST;\n+\t\t} else {\n+\t\t\tthrow InvalidInputException(\n+\t\t\t    \"Unrecognized parameter for option NULL_ORDER \\\"%s\\\". Expected NULLS_FIRST or NULLS_LAST.\", parameter);\n+\t\t}\n+\t\tbreak;\n+\t}\n+\tcase ConfigurationOptionType::ENABLE_EXTERNAL_ACCESS: {\n+\t\tenable_external_access = value.CastAs(LogicalType::BOOLEAN).GetValueUnsafe<int8_t>();\n+\t\tbreak;\n+\t}\n+\tcase ConfigurationOptionType::ENABLE_OBJECT_CACHE: {\n+\t\tobject_cache_enable = value.CastAs(LogicalType::BOOLEAN).GetValueUnsafe<int8_t>();\n+\t\tbreak;\n+\t}\n+\tcase ConfigurationOptionType::MAXIMUM_MEMORY: {\n+\t\tmaximum_memory = ParseMemoryLimit(value.ToString());\n+\t\tbreak;\n+\t}\n+\tcase ConfigurationOptionType::THREADS: {\n+\t\tmaximum_threads = value.GetValue<int64_t>();\n+\t\tbreak;\n+\t}\n+\tdefault:\n+\t\tbreak;\n+\t}\n+}\n+\n+idx_t DBConfig::ParseMemoryLimit(const string &arg) {\n+\tif (arg[0] == '-' || arg == \"null\" || arg == \"none\") {\n+\t\treturn INVALID_INDEX;\n+\t}\n+\t// split based on the number/non-number\n+\tidx_t idx = 0;\n+\twhile (StringUtil::CharacterIsSpace(arg[idx])) {\n+\t\tidx++;\n+\t}\n+\tidx_t num_start = idx;\n+\twhile ((arg[idx] >= '0' && arg[idx] <= '9') || arg[idx] == '.' || arg[idx] == 'e' || arg[idx] == 'E' ||\n+\t       arg[idx] == '-') {\n+\t\tidx++;\n+\t}\n+\tif (idx == num_start) {\n+\t\tthrow ParserException(\"Memory limit must have a number (e.g. PRAGMA memory_limit=1GB\");\n+\t}\n+\tstring number = arg.substr(num_start, idx - num_start);\n+\n+\t// try to parse the number\n+\tdouble limit = Cast::Operation<string_t, double>(string_t(number));\n+\n+\t// now parse the memory limit unit (e.g. bytes, gb, etc)\n+\twhile (StringUtil::CharacterIsSpace(arg[idx])) {\n+\t\tidx++;\n+\t}\n+\tidx_t start = idx;\n+\twhile (idx < arg.size() && !StringUtil::CharacterIsSpace(arg[idx])) {\n+\t\tidx++;\n+\t}\n+\tif (limit < 0) {\n+\t\t// limit < 0, set limit to infinite\n+\t\treturn (idx_t)-1;\n+\t}\n+\tstring unit = StringUtil::Lower(arg.substr(start, idx - start));\n+\tidx_t multiplier;\n+\tif (unit == \"byte\" || unit == \"bytes\" || unit == \"b\") {\n+\t\tmultiplier = 1;\n+\t} else if (unit == \"kilobyte\" || unit == \"kilobytes\" || unit == \"kb\" || unit == \"k\") {\n+\t\tmultiplier = 1000LL;\n+\t} else if (unit == \"megabyte\" || unit == \"megabytes\" || unit == \"mb\" || unit == \"m\") {\n+\t\tmultiplier = 1000LL * 1000LL;\n+\t} else if (unit == \"gigabyte\" || unit == \"gigabytes\" || unit == \"gb\" || unit == \"g\") {\n+\t\tmultiplier = 1000LL * 1000LL * 1000LL;\n+\t} else if (unit == \"terabyte\" || unit == \"terabytes\" || unit == \"tb\" || unit == \"t\") {\n+\t\tmultiplier = 1000LL * 1000LL * 1000LL * 1000LL;\n+\t} else {\n+\t\tthrow ParserException(\"Unknown unit for memory_limit: %s (expected: b, mb, gb or tb)\", unit);\n+\t}\n+\treturn (idx_t)multiplier * limit;\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/main/database.cpp b/src/main/database.cpp\nindex d325b957b0e1..4d11ab6ccca0 100644\n--- a/src/main/database.cpp\n+++ b/src/main/database.cpp\n@@ -206,7 +206,7 @@ void DatabaseInstance::Configure(DBConfig &new_config) {\n \tconfig.collation = new_config.collation;\n \tconfig.default_order_type = new_config.default_order_type;\n \tconfig.default_null_order = new_config.default_null_order;\n-\tconfig.enable_copy = new_config.enable_copy;\n+\tconfig.enable_external_access = new_config.enable_external_access;\n \tconfig.replacement_scans = move(new_config.replacement_scans);\n }\n \ndiff --git a/src/planner/binder/statement/bind_copy.cpp b/src/planner/binder/statement/bind_copy.cpp\nindex a549df7841c7..1ef05bc2447b 100644\n--- a/src/planner/binder/statement/bind_copy.cpp\n+++ b/src/planner/binder/statement/bind_copy.cpp\n@@ -21,7 +21,7 @@ namespace duckdb {\n BoundStatement Binder::BindCopyTo(CopyStatement &stmt) {\n \t// COPY TO a file\n \tauto &config = DBConfig::GetConfig(context);\n-\tif (!config.enable_copy) {\n+\tif (!config.enable_external_access) {\n \t\tthrow Exception(\"COPY TO is disabled by configuration\");\n \t}\n \tBoundStatement result;\n@@ -51,7 +51,7 @@ BoundStatement Binder::BindCopyTo(CopyStatement &stmt) {\n \n BoundStatement Binder::BindCopyFrom(CopyStatement &stmt) {\n \tauto &config = DBConfig::GetConfig(context);\n-\tif (!config.enable_copy) {\n+\tif (!config.enable_external_access) {\n \t\tthrow Exception(\"COPY FROM is disabled by configuration\");\n \t}\n \tBoundStatement result;\ndiff --git a/src/planner/binder/statement/bind_export.cpp b/src/planner/binder/statement/bind_export.cpp\nindex b361ebde5d6a..d206c7887e36 100644\n--- a/src/planner/binder/statement/bind_export.cpp\n+++ b/src/planner/binder/statement/bind_export.cpp\n@@ -16,7 +16,7 @@ namespace duckdb {\n BoundStatement Binder::Bind(ExportStatement &stmt) {\n \t// COPY TO a file\n \tauto &config = DBConfig::GetConfig(context);\n-\tif (!config.enable_copy) {\n+\tif (!config.enable_external_access) {\n \t\tthrow Exception(\"COPY TO is disabled by configuration\");\n \t}\n \tBoundStatement result;\ndiff --git a/tools/pythonpkg/duckdb_python.cpp b/tools/pythonpkg/duckdb_python.cpp\nindex d4e9cf3bbfdf..4bc7a962c6b1 100644\n--- a/tools/pythonpkg/duckdb_python.cpp\n+++ b/tools/pythonpkg/duckdb_python.cpp\n@@ -74,7 +74,7 @@ PYBIND11_MODULE(duckdb, m) {\n \tm.def(\"connect\", &DuckDBPyConnection::Connect,\n \t      \"Create a DuckDB database instance. Can take a database file name to read/write persistent data and a \"\n \t      \"read_only flag if no changes are desired\",\n-\t      py::arg(\"database\") = \":memory:\", py::arg(\"read_only\") = false);\n+\t      py::arg(\"database\") = \":memory:\", py::arg(\"read_only\") = false, py::arg(\"config\") = py::dict());\n \tm.def(\"tokenize\", PyTokenize,\n \t      \"Tokenizes a SQL string, returning a list of (position, type) tuples that can be \"\n \t      \"used for e.g. syntax highlighting\",\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp b/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp\nindex 31e2a5cb27fb..855582d83159 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp\n@@ -106,7 +106,7 @@ struct DuckDBPyConnection {\n \n \tpy::object FetchArrow();\n \n-\tstatic shared_ptr<DuckDBPyConnection> Connect(const string &database, bool read_only);\n+\tstatic shared_ptr<DuckDBPyConnection> Connect(const string &database, bool read_only, const py::dict &config);\n \n \tstatic vector<Value> TransformPythonParamList(py::handle params);\n \ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 20f4ef51335f..8eecda7e592d 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -417,13 +417,25 @@ static unique_ptr<TableFunctionRef> PandasScanReplacement(const string &table_na\n \treturn TryPandasReplacement(global_dict, py_table_name);\n }\n \n-shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const string &database, bool read_only) {\n+shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const string &database, bool read_only,\n+                                                           const py::dict &config_dict) {\n \tauto res = make_shared<DuckDBPyConnection>();\n \tDBConfig config;\n \tif (read_only) {\n \t\tconfig.access_mode = AccessMode::READ_ONLY;\n \t}\n-\tconfig.replacement_scans.emplace_back(PandasScanReplacement);\n+\tfor (auto &kv : config_dict) {\n+\t\tstring key = py::str(kv.first);\n+\t\tstring val = py::str(kv.second);\n+\t\tauto config_property = DBConfig::GetOptionByName(key);\n+\t\tif (!config_property) {\n+\t\t\tthrow InvalidInputException(\"Unrecognized configuration property \\\"%s\\\"\", key);\n+\t\t}\n+\t\tconfig.SetOption(*config_property, Value(val));\n+\t}\n+\tif (config.enable_external_access) {\n+\t\tconfig.replacement_scans.emplace_back(PandasScanReplacement);\n+\t}\n \n \tres->database = make_unique<DuckDB>(database, &config);\n \tExtensionHelper::LoadAllExtensions(*res->database);\n@@ -498,7 +510,8 @@ vector<Value> DuckDBPyConnection::TransformPythonParamList(py::handle params) {\n \n DuckDBPyConnection *DuckDBPyConnection::DefaultConnection() {\n \tif (!default_connection) {\n-\t\tdefault_connection = DuckDBPyConnection::Connect(\":memory:\", false);\n+\t\tpy::dict config_dict;\n+\t\tdefault_connection = DuckDBPyConnection::Connect(\":memory:\", false, config_dict);\n \t}\n \treturn default_connection.get();\n }\ndiff --git a/tools/rest/server.cpp b/tools/rest/server.cpp\nindex 355de179d06d..8579025c5b44 100644\n--- a/tools/rest/server.cpp\n+++ b/tools/rest/server.cpp\n@@ -259,7 +259,7 @@ int main(int argc, char **argv) {\n \t\t} else if (arg == \"--read_only\") {\n \t\t\tconfig.access_mode = AccessMode::READ_ONLY;\n \t\t} else if (arg == \"--disable_copy\") {\n-\t\t\tconfig.enable_copy = false;\n+\t\t\tconfig.enable_external_access = false;\n \t\t} else if (StringUtil::StartsWith(arg, \"--database=\")) {\n \t\t\tauto splits = StringUtil::Split(arg, '=');\n \t\t\tif (splits.size() != 2) {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/api/test_config.py b/tools/pythonpkg/tests/api/test_config.py\nnew file mode 100644\nindex 000000000000..a80a57a98f42\n--- /dev/null\n+++ b/tools/pythonpkg/tests/api/test_config.py\n@@ -0,0 +1,57 @@\n+# simple DB API testcase\n+\n+import duckdb\n+import numpy\n+import pandas\n+\n+class TestDBConfig(object):\n+    def test_default_order(self, duckdb_cursor):\n+        df = pandas.DataFrame({'a': [1,2,3]})\n+        con = duckdb.connect(':memory:', config={'default_order': 'desc'})\n+        result = con.execute('select * from df order by a').fetchall()\n+        assert result == [(3,), (2,), (1,)]\n+\n+    def test_null_order(self, duckdb_cursor):\n+        df = pandas.DataFrame({'a': [1,2,3,None]})\n+        con = duckdb.connect(':memory:', config={'default_null_order': 'nulls_last'})\n+        result = con.execute('select * from df order by a').fetchall()\n+        assert result == [(1,), (2,), (3,), (None,)]\n+\n+    def test_multiple_options(self, duckdb_cursor):\n+        df = pandas.DataFrame({'a': [1,2,3,None]})\n+        con = duckdb.connect(':memory:', config={'default_null_order': 'nulls_last', 'default_order': 'desc'})\n+        result = con.execute('select * from df order by a').fetchall()\n+        assert result == [(3,), (2,), (1,), (None,)]\n+\n+    def test_external_access(self, duckdb_cursor):\n+        df = pandas.DataFrame({'a': [1,2,3]})\n+        # this works (replacement scan)\n+        con_regular = duckdb.connect(':memory:', config={})\n+        con_regular.execute('select * from df')\n+        # disable external access: this also disables pandas replacement scans\n+        con = duckdb.connect(':memory:', config={'enable_external_access': False})\n+        # this should fail\n+        query_failed = False\n+        try:\n+            con.execute('select * from df').fetchall()\n+        except:\n+            query_failed = True\n+        assert query_failed == True\n+\n+    def test_unrecognized_option(self, duckdb_cursor):\n+        success = True\n+        try:\n+            con_regular = duckdb.connect(':memory:', config={'thisoptionisprobablynotthere': '42'})\n+        except:\n+            success = False\n+        assert success==False\n+\n+    def test_incorrect_parameter(self, duckdb_cursor):\n+        success = True\n+        try:\n+            con_regular = duckdb.connect(':memory:', config={'default_null_order': '42'})\n+        except:\n+            success = False\n+        assert success==False\n+\n+\n",
  "problem_statement": "Auto DataFrame scans give too much access to server data\n**What does happen?**\r\nWhen DuckDB is used in a server environment, the automatic Pandas DataFrame, csv, and parquet scan capabilities grant too much authority on the server to users and is a security risk. The read_csv and read_csv_auto, as well as the parquet reader also have the same issue.\r\nThere is a related issue here: [#823](https://github.com/duckdb/duckdb/pull/823) \r\n\r\n**What should happen?**\r\nWe would love a configuration option that is accessible from the Python API to disable these features. Our code should need to register a table or a file prior to DuckDB querying it so that we can appropriately control permission to files and DataFrames on the server. \r\n\r\n**To Reproduce**\r\nAccess a Pandas DataFrame without registering it.\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Windows\r\n - DuckDB Version 0.2.6\r\n\r\n**Before submitting**\r\n- [X] Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n- [X] Have you tried this on the latest `master` branch? In case you cannot compile, you may find some binaries here: https://github.com/duckdb/duckdb/releases/tag/master-builds\r\n\n",
  "hints_text": "Indeed I think its best if we expand/rename `config.enable_copy` to also apply to replacement scans\nThank you! I think that would work well. A Pragma would also work if that is easier! The trick for us is just to be able to adjust that setting from Python.\nif its a pragma a malicious actor could also re-enable ay\nGreat point. Avoiding a Pragma would be better.\n\nThanks!\n\nOn Mon, May 17, 2021, 1:59 PM Hannes M\u00fchleisen ***@***.***>\nwrote:\n\n> if its a pragma a malicious actor could also re-enable ay\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/duckdb/duckdb/issues/1771#issuecomment-842634837>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AMOORAPH6ZR3ZOLVDV7ASDTTOF7S7ANCNFSM45APJXMA>\n> .\n>\n",
  "created_at": "2021-05-18T14:21:15Z"
}