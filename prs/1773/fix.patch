diff --git a/src/function/pragma/pragma_functions.cpp b/src/function/pragma/pragma_functions.cpp
index 23da0a27be9c..39e2ced72ba3 100644
--- a/src/function/pragma/pragma_functions.cpp
+++ b/src/function/pragma/pragma_functions.cpp
@@ -72,10 +72,8 @@ static void PragmaProfileOutput(ClientContext &context, const FunctionParameters
 	context.profiler->save_location = parameters.values[0].ToString();
 }
 
-static idx_t ParseMemoryLimit(string arg);
-
 static void PragmaMemoryLimit(ClientContext &context, const FunctionParameters &parameters) {
-	idx_t new_limit = ParseMemoryLimit(parameters.values[0].ToString());
+	idx_t new_limit = DBConfig::ParseMemoryLimit(parameters.values[0].ToString());
 	// set the new limit in the buffer manager
 	BufferManager::GetBufferManager(context).SetLimit(new_limit);
 }
@@ -220,7 +218,7 @@ static void PragmaPerfectHashThreshold(ClientContext &context, const FunctionPar
 }
 
 static void PragmaAutoCheckpointThreshold(ClientContext &context, const FunctionParameters &parameters) {
-	idx_t new_limit = ParseMemoryLimit(parameters.values[0].ToString());
+	idx_t new_limit = DBConfig::ParseMemoryLimit(parameters.values[0].ToString());
 	DBConfig::GetConfig(context).checkpoint_wal_size = new_limit;
 }
 
@@ -310,56 +308,4 @@ void PragmaFunctions::RegisterFunction(BuiltinFunctions &set) {
 	    PragmaFunction::PragmaAssignment("debug_checkpoint_abort", PragmaDebugCheckpointAbort, LogicalType::VARCHAR));
 }
 
-idx_t ParseMemoryLimit(string arg) {
-	if (arg[0] == '-' || arg == "null" || arg == "none") {
-		return INVALID_INDEX;
-	}
-	// split based on the number/non-number
-	idx_t idx = 0;
-	while (StringUtil::CharacterIsSpace(arg[idx])) {
-		idx++;
-	}
-	idx_t num_start = idx;
-	while ((arg[idx] >= '0' && arg[idx] <= '9') || arg[idx] == '.' || arg[idx] == 'e' || arg[idx] == 'E' ||
-	       arg[idx] == '-') {
-		idx++;
-	}
-	if (idx == num_start) {
-		throw ParserException("Memory limit must have a number (e.g. PRAGMA memory_limit=1GB");
-	}
-	string number = arg.substr(num_start, idx - num_start);
-
-	// try to parse the number
-	double limit = Cast::Operation<string_t, double>(string_t(number));
-
-	// now parse the memory limit unit (e.g. bytes, gb, etc)
-	while (StringUtil::CharacterIsSpace(arg[idx])) {
-		idx++;
-	}
-	idx_t start = idx;
-	while (idx < arg.size() && !StringUtil::CharacterIsSpace(arg[idx])) {
-		idx++;
-	}
-	if (limit < 0) {
-		// limit < 0, set limit to infinite
-		return (idx_t)-1;
-	}
-	string unit = StringUtil::Lower(arg.substr(start, idx - start));
-	idx_t multiplier;
-	if (unit == "byte" || unit == "bytes" || unit == "b") {
-		multiplier = 1;
-	} else if (unit == "kilobyte" || unit == "kilobytes" || unit == "kb" || unit == "k") {
-		multiplier = 1000LL;
-	} else if (unit == "megabyte" || unit == "megabytes" || unit == "mb" || unit == "m") {
-		multiplier = 1000LL * 1000LL;
-	} else if (unit == "gigabyte" || unit == "gigabytes" || unit == "gb" || unit == "g") {
-		multiplier = 1000LL * 1000LL * 1000LL;
-	} else if (unit == "terabyte" || unit == "terabytes" || unit == "tb" || unit == "t") {
-		multiplier = 1000LL * 1000LL * 1000LL * 1000LL;
-	} else {
-		throw ParserException("Unknown unit for memory_limit: %s (expected: b, mb, gb or tb)", unit);
-	}
-	return (idx_t)multiplier * limit;
-}
-
 } // namespace duckdb
\ No newline at end of file
diff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp
index 6ff22c59fe3a..f8749e420fdd 100644
--- a/src/include/duckdb/main/config.hpp
+++ b/src/include/duckdb/main/config.hpp
@@ -24,6 +24,24 @@ class TableFunctionRef;
 enum class AccessMode : uint8_t { UNDEFINED = 0, AUTOMATIC = 1, READ_ONLY = 2, READ_WRITE = 3 };
 enum class CheckpointAbort : uint8_t { NO_ABORT = 0, DEBUG_ABORT_BEFORE_TRUNCATE = 1, DEBUG_ABORT_BEFORE_HEADER = 2 };
 
+enum class ConfigurationOptionType : uint32_t {
+	INVALID = 0,
+	ACCESS_MODE,
+	DEFAULT_ORDER_TYPE,
+	DEFAULT_NULL_ORDER,
+	ENABLE_EXTERNAL_ACCESS,
+	ENABLE_OBJECT_CACHE,
+	MAXIMUM_MEMORY,
+	THREADS
+};
+
+struct ConfigurationOption {
+	ConfigurationOptionType type;
+	const char *name;
+	const char *description;
+	LogicalTypeId parameter_type;
+};
+
 // this is optional and only used in tests at the moment
 struct DBConfig {
 	friend class DatabaseInstance;
@@ -58,7 +76,7 @@ struct DBConfig {
 	//! Null ordering used when none is specified (default: NULLS FIRST)
 	OrderByNullType default_null_order = OrderByNullType::NULLS_FIRST;
 	//! enable COPY and related commands
-	bool enable_copy = true;
+	bool enable_external_access = true;
 	//! Whether or not object cache is used
 	bool object_cache_enable = false;
 	//! Database configuration variables as controlled by SET
@@ -75,6 +93,14 @@ struct DBConfig {
 public:
 	DUCKDB_API static DBConfig &GetConfig(ClientContext &context);
 	DUCKDB_API static DBConfig &GetConfig(DatabaseInstance &db);
+	DUCKDB_API static vector<ConfigurationOption> GetOptions();
+
+	//! Fetch an option by name. Returns a pointer to the option, or nullptr if none exists.
+	DUCKDB_API static ConfigurationOption *GetOptionByName(const string &name);
+
+	DUCKDB_API void SetOption(const ConfigurationOption &option, const Value &value);
+
+	DUCKDB_API static idx_t ParseMemoryLimit(const string &arg);
 };
 
 } // namespace duckdb
diff --git a/src/main/CMakeLists.txt b/src/main/CMakeLists.txt
index f7466bf1f34a..42142fdf39f9 100644
--- a/src/main/CMakeLists.txt
+++ b/src/main/CMakeLists.txt
@@ -3,6 +3,7 @@ add_subdirectory(relation)
 set(DUCKDB_MAIN_FILES
     appender.cpp
     client_context.cpp
+    config.cpp
     connection.cpp
     database.cpp
     materialized_query_result.cpp
diff --git a/src/main/config.cpp b/src/main/config.cpp
new file mode 100644
index 000000000000..8fdf3be32127
--- /dev/null
+++ b/src/main/config.cpp
@@ -0,0 +1,156 @@
+#include "duckdb/main/config.hpp"
+#include "duckdb/common/string_util.hpp"
+#include "duckdb/common/operator/cast_operators.hpp"
+
+namespace duckdb {
+
+static ConfigurationOption internal_options[] = {
+    {ConfigurationOptionType::ACCESS_MODE, "access_mode",
+     "Access mode of the database ([AUTOMATIC], READ_ONLY or READ_WRITE)", LogicalTypeId::VARCHAR},
+    {ConfigurationOptionType::DEFAULT_ORDER_TYPE, "default_order",
+     "The order type used when none is specified ([ASC] or DESC)", LogicalTypeId::VARCHAR},
+    {ConfigurationOptionType::DEFAULT_NULL_ORDER, "default_null_order",
+     "Null ordering used when none is specified ([NULLS_FIRST] or NULLS_LAST)", LogicalTypeId::VARCHAR},
+    {ConfigurationOptionType::ENABLE_EXTERNAL_ACCESS, "enable_external_access",
+     "Allow the database to access external state (through e.g. COPY TO/FROM, CSV readers, pandas replacement scans, "
+     "etc)",
+     LogicalTypeId::BOOLEAN},
+    {ConfigurationOptionType::ENABLE_OBJECT_CACHE, "enable_object_cache",
+     "Whether or not object cache is used to cache e.g. Parquet metadata", LogicalTypeId::BOOLEAN},
+    {ConfigurationOptionType::MAXIMUM_MEMORY, "max_memory", "The maximum memory of the system (e.g. 1GB)",
+     LogicalTypeId::VARCHAR},
+    {ConfigurationOptionType::THREADS, "threads", "The number of total threads used by the system",
+     LogicalTypeId::BIGINT},
+    {ConfigurationOptionType::INVALID, nullptr, nullptr, LogicalTypeId::INVALID}};
+
+vector<ConfigurationOption> DBConfig::GetOptions() {
+	vector<ConfigurationOption> options;
+	for (idx_t index = 0; internal_options[index].name; index++) {
+		options.push_back(internal_options[index]);
+	}
+	return options;
+}
+
+ConfigurationOption *DBConfig::GetOptionByName(const string &name) {
+	for (idx_t index = 0; internal_options[index].name; index++) {
+		if (internal_options[index].name == name) {
+			return internal_options + index;
+		}
+	}
+	return nullptr;
+}
+
+void DBConfig::SetOption(const ConfigurationOption &option, const Value &value) {
+	switch (option.type) {
+	case ConfigurationOptionType::ACCESS_MODE: {
+		auto parameter = StringUtil::Lower(value.ToString());
+		if (parameter == "automatic") {
+			access_mode = AccessMode::AUTOMATIC;
+		} else if (parameter == "read_only") {
+			access_mode = AccessMode::READ_ONLY;
+		} else if (parameter == "read_write") {
+			access_mode = AccessMode::READ_WRITE;
+		} else {
+			throw InvalidInputException(
+			    "Unrecognized parameter for option ACCESS_MODE \"%s\". Expected READ_ONLY or READ_WRITE.", parameter);
+		}
+		break;
+	}
+	case ConfigurationOptionType::DEFAULT_ORDER_TYPE: {
+		auto parameter = StringUtil::Lower(value.ToString());
+		if (parameter == "asc") {
+			default_order_type = OrderType::ASCENDING;
+		} else if (parameter == "desc") {
+			default_order_type = OrderType::DESCENDING;
+		} else {
+			throw InvalidInputException("Unrecognized parameter for option DEFAULT_ORDER \"%s\". Expected ASC or DESC.",
+			                            parameter);
+		}
+		break;
+	}
+	case ConfigurationOptionType::DEFAULT_NULL_ORDER: {
+		auto parameter = StringUtil::Lower(value.ToString());
+		if (parameter == "nulls_first") {
+			default_null_order = OrderByNullType::NULLS_FIRST;
+		} else if (parameter == "nulls_last") {
+			default_null_order = OrderByNullType::NULLS_LAST;
+		} else {
+			throw InvalidInputException(
+			    "Unrecognized parameter for option NULL_ORDER \"%s\". Expected NULLS_FIRST or NULLS_LAST.", parameter);
+		}
+		break;
+	}
+	case ConfigurationOptionType::ENABLE_EXTERNAL_ACCESS: {
+		enable_external_access = value.CastAs(LogicalType::BOOLEAN).GetValueUnsafe<int8_t>();
+		break;
+	}
+	case ConfigurationOptionType::ENABLE_OBJECT_CACHE: {
+		object_cache_enable = value.CastAs(LogicalType::BOOLEAN).GetValueUnsafe<int8_t>();
+		break;
+	}
+	case ConfigurationOptionType::MAXIMUM_MEMORY: {
+		maximum_memory = ParseMemoryLimit(value.ToString());
+		break;
+	}
+	case ConfigurationOptionType::THREADS: {
+		maximum_threads = value.GetValue<int64_t>();
+		break;
+	}
+	default:
+		break;
+	}
+}
+
+idx_t DBConfig::ParseMemoryLimit(const string &arg) {
+	if (arg[0] == '-' || arg == "null" || arg == "none") {
+		return INVALID_INDEX;
+	}
+	// split based on the number/non-number
+	idx_t idx = 0;
+	while (StringUtil::CharacterIsSpace(arg[idx])) {
+		idx++;
+	}
+	idx_t num_start = idx;
+	while ((arg[idx] >= '0' && arg[idx] <= '9') || arg[idx] == '.' || arg[idx] == 'e' || arg[idx] == 'E' ||
+	       arg[idx] == '-') {
+		idx++;
+	}
+	if (idx == num_start) {
+		throw ParserException("Memory limit must have a number (e.g. PRAGMA memory_limit=1GB");
+	}
+	string number = arg.substr(num_start, idx - num_start);
+
+	// try to parse the number
+	double limit = Cast::Operation<string_t, double>(string_t(number));
+
+	// now parse the memory limit unit (e.g. bytes, gb, etc)
+	while (StringUtil::CharacterIsSpace(arg[idx])) {
+		idx++;
+	}
+	idx_t start = idx;
+	while (idx < arg.size() && !StringUtil::CharacterIsSpace(arg[idx])) {
+		idx++;
+	}
+	if (limit < 0) {
+		// limit < 0, set limit to infinite
+		return (idx_t)-1;
+	}
+	string unit = StringUtil::Lower(arg.substr(start, idx - start));
+	idx_t multiplier;
+	if (unit == "byte" || unit == "bytes" || unit == "b") {
+		multiplier = 1;
+	} else if (unit == "kilobyte" || unit == "kilobytes" || unit == "kb" || unit == "k") {
+		multiplier = 1000LL;
+	} else if (unit == "megabyte" || unit == "megabytes" || unit == "mb" || unit == "m") {
+		multiplier = 1000LL * 1000LL;
+	} else if (unit == "gigabyte" || unit == "gigabytes" || unit == "gb" || unit == "g") {
+		multiplier = 1000LL * 1000LL * 1000LL;
+	} else if (unit == "terabyte" || unit == "terabytes" || unit == "tb" || unit == "t") {
+		multiplier = 1000LL * 1000LL * 1000LL * 1000LL;
+	} else {
+		throw ParserException("Unknown unit for memory_limit: %s (expected: b, mb, gb or tb)", unit);
+	}
+	return (idx_t)multiplier * limit;
+}
+
+} // namespace duckdb
diff --git a/src/main/database.cpp b/src/main/database.cpp
index d325b957b0e1..4d11ab6ccca0 100644
--- a/src/main/database.cpp
+++ b/src/main/database.cpp
@@ -206,7 +206,7 @@ void DatabaseInstance::Configure(DBConfig &new_config) {
 	config.collation = new_config.collation;
 	config.default_order_type = new_config.default_order_type;
 	config.default_null_order = new_config.default_null_order;
-	config.enable_copy = new_config.enable_copy;
+	config.enable_external_access = new_config.enable_external_access;
 	config.replacement_scans = move(new_config.replacement_scans);
 }
 
diff --git a/src/planner/binder/statement/bind_copy.cpp b/src/planner/binder/statement/bind_copy.cpp
index a549df7841c7..1ef05bc2447b 100644
--- a/src/planner/binder/statement/bind_copy.cpp
+++ b/src/planner/binder/statement/bind_copy.cpp
@@ -21,7 +21,7 @@ namespace duckdb {
 BoundStatement Binder::BindCopyTo(CopyStatement &stmt) {
 	// COPY TO a file
 	auto &config = DBConfig::GetConfig(context);
-	if (!config.enable_copy) {
+	if (!config.enable_external_access) {
 		throw Exception("COPY TO is disabled by configuration");
 	}
 	BoundStatement result;
@@ -51,7 +51,7 @@ BoundStatement Binder::BindCopyTo(CopyStatement &stmt) {
 
 BoundStatement Binder::BindCopyFrom(CopyStatement &stmt) {
 	auto &config = DBConfig::GetConfig(context);
-	if (!config.enable_copy) {
+	if (!config.enable_external_access) {
 		throw Exception("COPY FROM is disabled by configuration");
 	}
 	BoundStatement result;
diff --git a/src/planner/binder/statement/bind_export.cpp b/src/planner/binder/statement/bind_export.cpp
index b361ebde5d6a..d206c7887e36 100644
--- a/src/planner/binder/statement/bind_export.cpp
+++ b/src/planner/binder/statement/bind_export.cpp
@@ -16,7 +16,7 @@ namespace duckdb {
 BoundStatement Binder::Bind(ExportStatement &stmt) {
 	// COPY TO a file
 	auto &config = DBConfig::GetConfig(context);
-	if (!config.enable_copy) {
+	if (!config.enable_external_access) {
 		throw Exception("COPY TO is disabled by configuration");
 	}
 	BoundStatement result;
diff --git a/tools/pythonpkg/duckdb_python.cpp b/tools/pythonpkg/duckdb_python.cpp
index d4e9cf3bbfdf..4bc7a962c6b1 100644
--- a/tools/pythonpkg/duckdb_python.cpp
+++ b/tools/pythonpkg/duckdb_python.cpp
@@ -74,7 +74,7 @@ PYBIND11_MODULE(duckdb, m) {
 	m.def("connect", &DuckDBPyConnection::Connect,
 	      "Create a DuckDB database instance. Can take a database file name to read/write persistent data and a "
 	      "read_only flag if no changes are desired",
-	      py::arg("database") = ":memory:", py::arg("read_only") = false);
+	      py::arg("database") = ":memory:", py::arg("read_only") = false, py::arg("config") = py::dict());
 	m.def("tokenize", PyTokenize,
 	      "Tokenizes a SQL string, returning a list of (position, type) tuples that can be "
 	      "used for e.g. syntax highlighting",
diff --git a/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp b/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp
index 31e2a5cb27fb..855582d83159 100644
--- a/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp
+++ b/tools/pythonpkg/src/include/duckdb_python/pyconnection.hpp
@@ -106,7 +106,7 @@ struct DuckDBPyConnection {
 
 	py::object FetchArrow();
 
-	static shared_ptr<DuckDBPyConnection> Connect(const string &database, bool read_only);
+	static shared_ptr<DuckDBPyConnection> Connect(const string &database, bool read_only, const py::dict &config);
 
 	static vector<Value> TransformPythonParamList(py::handle params);
 
diff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp
index 20f4ef51335f..8eecda7e592d 100644
--- a/tools/pythonpkg/src/pyconnection.cpp
+++ b/tools/pythonpkg/src/pyconnection.cpp
@@ -417,13 +417,25 @@ static unique_ptr<TableFunctionRef> PandasScanReplacement(const string &table_na
 	return TryPandasReplacement(global_dict, py_table_name);
 }
 
-shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const string &database, bool read_only) {
+shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const string &database, bool read_only,
+                                                           const py::dict &config_dict) {
 	auto res = make_shared<DuckDBPyConnection>();
 	DBConfig config;
 	if (read_only) {
 		config.access_mode = AccessMode::READ_ONLY;
 	}
-	config.replacement_scans.emplace_back(PandasScanReplacement);
+	for (auto &kv : config_dict) {
+		string key = py::str(kv.first);
+		string val = py::str(kv.second);
+		auto config_property = DBConfig::GetOptionByName(key);
+		if (!config_property) {
+			throw InvalidInputException("Unrecognized configuration property \"%s\"", key);
+		}
+		config.SetOption(*config_property, Value(val));
+	}
+	if (config.enable_external_access) {
+		config.replacement_scans.emplace_back(PandasScanReplacement);
+	}
 
 	res->database = make_unique<DuckDB>(database, &config);
 	ExtensionHelper::LoadAllExtensions(*res->database);
@@ -498,7 +510,8 @@ vector<Value> DuckDBPyConnection::TransformPythonParamList(py::handle params) {
 
 DuckDBPyConnection *DuckDBPyConnection::DefaultConnection() {
 	if (!default_connection) {
-		default_connection = DuckDBPyConnection::Connect(":memory:", false);
+		py::dict config_dict;
+		default_connection = DuckDBPyConnection::Connect(":memory:", false, config_dict);
 	}
 	return default_connection.get();
 }
diff --git a/tools/rest/server.cpp b/tools/rest/server.cpp
index 355de179d06d..8579025c5b44 100644
--- a/tools/rest/server.cpp
+++ b/tools/rest/server.cpp
@@ -259,7 +259,7 @@ int main(int argc, char **argv) {
 		} else if (arg == "--read_only") {
 			config.access_mode = AccessMode::READ_ONLY;
 		} else if (arg == "--disable_copy") {
-			config.enable_copy = false;
+			config.enable_external_access = false;
 		} else if (StringUtil::StartsWith(arg, "--database=")) {
 			auto splits = StringUtil::Split(arg, '=');
 			if (splits.size() != 2) {
