diff --git a/tools/rpkg/NAMESPACE b/tools/rpkg/NAMESPACE
index e0279ae05cda..8850579c34c0 100644
--- a/tools/rpkg/NAMESPACE
+++ b/tools/rpkg/NAMESPACE
@@ -32,6 +32,7 @@ exportMethods(dbHasCompleted)
 exportMethods(dbIsValid)
 exportMethods(dbListFields)
 exportMethods(dbListTables)
+exportMethods(dbQuoteLiteral)
 exportMethods(dbRemoveTable)
 exportMethods(dbRollback)
 exportMethods(dbSendQuery)
diff --git a/tools/rpkg/R/Connection.R b/tools/rpkg/R/Connection.R
index fd39616b83f8..428853fcae22 100644
--- a/tools/rpkg/R/Connection.R
+++ b/tools/rpkg/R/Connection.R
@@ -208,19 +208,9 @@ setMethod(
       stop("Column name mismatch for append")
     }
 
-    is_factor <- vapply(value, is.factor, logical(1))
-    if (any(is_factor)) {
-      warning("Factors converted to character")
-    }
+    value <- encode_values(value)
 
     if (nrow(value)) {
-      is_character <- vapply(value, is.character, logical(1))
-      value[is_character] <- lapply(value[is_character], enc2utf8)
-      value[is_factor] <- lapply(value[is_factor], function(x) {
-        levels(x) <- enc2utf8(levels(x))
-        as.character(x)
-      })
-
       table_name <- dbQuoteIdentifier(conn, name)
 
       view_name <- sprintf("_duckdb_append_view_%s", duckdb_random_string())
@@ -235,6 +225,26 @@ setMethod(
   }
 )
 
+encode_values <- function(value) {
+  is_factor <- vapply(value, is.factor, logical(1))
+  if (any(is_factor)) {
+    warning("Factors converted to character")
+  }
+
+  value[is_factor] <- lapply(value[is_factor], function(x) {
+    levels(x) <- enc2utf8(levels(x))
+    as.character(x)
+  })
+
+  is_character <- vapply(value, is.character, logical(1))
+  value[is_character] <- lapply(value[is_character], enc2utf8)
+
+  is_posixlt <- vapply(value, inherits, "POSIXlt", FUN.VALUE = logical(1))
+  value[is_posixlt] <- lapply(value[is_posixlt], as.POSIXct)
+
+  value
+}
+
 #' @rdname duckdb_connection-class
 #' @inheritParams DBI::dbListTables
 #' @export
@@ -364,3 +374,65 @@ setMethod(
     invisible(TRUE)
   }
 )
+
+#' @rdname duckdb_connection-class
+#' @export
+setMethod(
+  "dbQuoteLiteral", signature("duckdb_connection"),
+  function(conn, x, ...) {
+    # Switchpatching to avoid ambiguous S4 dispatch, so that our method
+    # is used only if no alternatives are available.
+
+    if (is(x, "SQL")) {
+      return(x)
+    }
+
+    if (is.factor(x)) {
+      return(dbQuoteString(conn, as.character(x)))
+    }
+
+    if (is.character(x)) {
+      return(dbQuoteString(conn, x))
+    }
+
+    if (inherits(x, "POSIXt")) {
+      out <- dbQuoteString(
+        conn,
+        strftime(as.POSIXct(x), "%Y-%m-%d %H:%M:%S", tz = "UTC")
+      )
+
+      return(SQL(paste0(out, "::timestamp")))
+    }
+
+    if (inherits(x, "Date")) {
+      out <- callNextMethod()
+      return(SQL(paste0(out, "::date")))
+    }
+
+    if (inherits(x, "difftime")) {
+      out <- callNextMethod()
+      return(SQL(paste0(out, "::time")))
+    }
+
+    if (is.list(x)) {
+      blob_data <- vapply(
+        x,
+        function(x) {
+          if (is.null(x)) {
+            "NULL"
+          } else if (is.raw(x)) {
+            paste0("X'", paste(format(x), collapse = ""), "'")
+          } else {
+            stop("Lists must contain raw vectors or NULL", call. = FALSE)
+          }
+        },
+        character(1)
+      )
+      return(SQL(blob_data, names = names(x)))
+    }
+
+    x <- as.character(x)
+    x[is.na(x)] <- "NULL"
+    SQL(x, names = names(x))
+  }
+)
diff --git a/tools/rpkg/R/Result.R b/tools/rpkg/R/Result.R
index dc3c167f5d08..31ff904b9e36 100644
--- a/tools/rpkg/R/Result.R
+++ b/tools/rpkg/R/Result.R
@@ -42,19 +42,31 @@ duckdb_result <- function(connection, stmt_lst, arrow) {
 }
 
 duckdb_execute <- function(res) {
-  if (res@arrow){
-    query <- .Call(duckdb_execute_R, res@stmt_lst$ref, res@arrow)
-    return (query)
-  }
-  res@env$resultset <- .Call(duckdb_execute_R, res@stmt_lst$ref, res@arrow)
+  out <- .Call(duckdb_execute_R, res@stmt_lst$ref, res@arrow)
+  duckdb_post_execute(res, out)
+}
+
+duckdb_post_execute <- function(res, out) {
   if (!res@arrow) {
-      attr(res@env$resultset, "row.names") <-
-        c(NA_integer_, as.integer(-1 * length(res@env$resultset[[1]])))
-      class(res@env$resultset) <- "data.frame"
+    out <- list_to_df(out)
+
+    if (res@stmt_lst$type != "SELECT") {
+      res@env$rows_affected <- sum(as.numeric(out[[1]]))
+    }
+
+    res@env$resultset <- out
   }
-  if (res@stmt_lst$type != "SELECT") {
-    res@env$rows_affected <- as.numeric(res@env$resultset[[1]][1])
+
+  out
+}
+
+list_to_df <- function(x) {
+  if (is.data.frame(x)) {
+    return(x)
   }
+  attr(x, "row.names") <- c(NA_integer_, -length(x[[1]]))
+  class(x) <- "data.frame"
+  x
 }
 
 
@@ -127,6 +139,10 @@ setMethod(
     if (!res@env$open) {
       stop("result set was closed")
     }
+    if (is.null(res@env$resultset)) {
+      stop("Need to call `dbBind()` before `dbFetch()`")
+    }
+
     if (length(n) != 1) {
       stop("need exactly one value in n")
     }
@@ -195,10 +211,14 @@ setMethod(
     if (!res@env$open) {
       stop("result has already been cleared")
     }
-    if (res@stmt_lst$type != "SELECT") {
-      return(TRUE)
+
+    if (is.null(res@env$resultset)) {
+      FALSE
+    } else if (res@stmt_lst$type == "SELECT") {
+      res@env$rows_fetched == nrow(res@env$resultset)
+    } else {
+      TRUE
     }
-    return(res@env$rows_fetched == nrow(res@env$resultset))
   }
 )
 
@@ -271,6 +291,9 @@ setMethod(
     if (!res@env$open) {
       stop("result has already been cleared")
     }
+    if (is.null(res@env$resultset)) {
+      return(NA_integer_)
+    }
     return(res@env$rows_affected)
   }
 )
@@ -287,8 +310,23 @@ setMethod(
     res@env$rows_fetched <- 0
     res@env$resultset <- data.frame()
 
-    invisible(.Call(duckdb_bind_R, res@stmt_lst$ref, params))
-    duckdb_execute(res)
+    params <- as.list(params)
+    if (!is.null(names(params))) {
+      stop("`params` must not be named")
+    }
+
+    params <- encode_values(params)
+
+    out <- .Call(duckdb_bind_R, res@stmt_lst$ref, params, res@arrow)
+    if (length(out) == 1) {
+      out <- out[[1]]
+    } else if (length(out) == 0) {
+      out <- data.frame()
+    } else {
+      out <- do.call(rbind, lapply(out, list_to_df))
+    }
+    duckdb_post_execute(res, out)
+    invisible(res)
   }
 )
 
diff --git a/tools/rpkg/man/duckdb_connection-class.Rd b/tools/rpkg/man/duckdb_connection-class.Rd
index c50c9253d2da..1c25b073490d 100644
--- a/tools/rpkg/man/duckdb_connection-class.Rd
+++ b/tools/rpkg/man/duckdb_connection-class.Rd
@@ -18,6 +18,7 @@
 \alias{dbBegin,duckdb_connection-method}
 \alias{dbCommit,duckdb_connection-method}
 \alias{dbRollback,duckdb_connection-method}
+\alias{dbQuoteLiteral,duckdb_connection-method}
 \title{DuckDB connection class}
 \usage{
 \S4method{show}{duckdb_connection}(object)
@@ -57,6 +58,8 @@
 \S4method{dbCommit}{duckdb_connection}(conn, ...)
 
 \S4method{dbRollback}{duckdb_connection}(conn, ...)
+
+\S4method{dbQuoteLiteral}{duckdb_connection}(conn, x, ...)
 }
 \arguments{
 \item{object}{Any R object}
diff --git a/tools/rpkg/src/include/rapi.hpp b/tools/rpkg/src/include/rapi.hpp
index e33992ee1c3f..c4e2c70002e1 100644
--- a/tools/rpkg/src/include/rapi.hpp
+++ b/tools/rpkg/src/include/rapi.hpp
@@ -21,7 +21,7 @@ struct RApi {
 
 	static SEXP Prepare(SEXP connsexp, SEXP querysexp);
 
-	static SEXP Bind(SEXP stmtsexp, SEXP paramsexp);
+	static SEXP Bind(SEXP stmtsexp, SEXP paramsexp, SEXP arrowsexp);
 
 	static SEXP Execute(SEXP stmtsexp, SEXP arrowsexp);
 
diff --git a/tools/rpkg/src/include/typesr.hpp b/tools/rpkg/src/include/typesr.hpp
index 9fac65fca1e9..2501dd99d591 100644
--- a/tools/rpkg/src/include/typesr.hpp
+++ b/tools/rpkg/src/include/typesr.hpp
@@ -15,17 +15,23 @@ enum class RType {
 	STRING,
 	FACTOR,
 	DATE,
+	DATE_INTEGER,
 	TIMESTAMP,
 	TIME_SECONDS,
 	TIME_MINUTES,
 	TIME_HOURS,
 	TIME_DAYS,
-	TIME_WEEKS
+	TIME_WEEKS,
+	TIME_SECONDS_INTEGER,
+	TIME_MINUTES_INTEGER,
+	TIME_HOURS_INTEGER,
+	TIME_DAYS_INTEGER,
+	TIME_WEEKS_INTEGER,
 };
 
 struct RApiTypes {
 	static RType DetectRType(SEXP v);
-	static Value SexpToValue(SEXP valsexp);
+	static Value SexpToValue(SEXP valsexp, R_len_t idx);
 	static SEXP ValueToSexp(Value &val);
 };
 
diff --git a/tools/rpkg/src/rapi.cpp b/tools/rpkg/src/rapi.cpp
index 60d89d73e81e..5680b727a9ee 100644
--- a/tools/rpkg/src/rapi.cpp
+++ b/tools/rpkg/src/rapi.cpp
@@ -5,7 +5,7 @@ using namespace duckdb;
 static const R_CallMethodDef R_CallDef[] = {{"duckdb_startup_R", (DL_FUNC)RApi::Startup, 3},
                                             {"duckdb_connect_R", (DL_FUNC)RApi::Connect, 1},
                                             {"duckdb_prepare_R", (DL_FUNC)RApi::Prepare, 2},
-                                            {"duckdb_bind_R", (DL_FUNC)RApi::Bind, 2},
+                                            {"duckdb_bind_R", (DL_FUNC)RApi::Bind, 3},
                                             {"duckdb_execute_R", (DL_FUNC)RApi::Execute, 2},
                                             {"duckdb_fetch_arrow_R", (DL_FUNC)RApi::DuckDBExecuteArrow, 4},
                                             {"duckdb_fetch_record_batch_R", (DL_FUNC)RApi::DuckDBRecordBatchR, 1},
diff --git a/tools/rpkg/src/scan.cpp b/tools/rpkg/src/scan.cpp
index 459154d1dae8..364bdb2814fa 100644
--- a/tools/rpkg/src/scan.cpp
+++ b/tools/rpkg/src/scan.cpp
@@ -101,9 +101,15 @@ static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vect
 		case RType::TIME_HOURS:
 		case RType::TIME_DAYS:
 		case RType::TIME_WEEKS:
+		case RType::TIME_SECONDS_INTEGER:
+		case RType::TIME_MINUTES_INTEGER:
+		case RType::TIME_HOURS_INTEGER:
+		case RType::TIME_DAYS_INTEGER:
+		case RType::TIME_WEEKS_INTEGER:
 			duckdb_col_type = LogicalType::TIME;
 			break;
 		case RType::DATE:
+		case RType::DATE_INTEGER:
 			duckdb_col_type = LogicalType::DATE;
 			break;
 		default:
@@ -190,11 +196,41 @@ static void dataframe_scan_function(ClientContext &context, const FunctionData *
 			AppendColumnSegment<double, dtime_t, RTimeWeeksType>(data_ptr, v, this_count);
 			break;
 		}
+		case RType::TIME_SECONDS_INTEGER: {
+			auto data_ptr = INTEGER_POINTER(coldata) + state.position;
+			AppendColumnSegment<int, dtime_t, RTimeSecondsType>(data_ptr, v, this_count);
+			break;
+		}
+		case RType::TIME_MINUTES_INTEGER: {
+			auto data_ptr = INTEGER_POINTER(coldata) + state.position;
+			AppendColumnSegment<int, dtime_t, RTimeMinutesType>(data_ptr, v, this_count);
+			break;
+		}
+		case RType::TIME_HOURS_INTEGER: {
+			auto data_ptr = INTEGER_POINTER(coldata) + state.position;
+			AppendColumnSegment<int, dtime_t, RTimeHoursType>(data_ptr, v, this_count);
+			break;
+		}
+		case RType::TIME_DAYS_INTEGER: {
+			auto data_ptr = INTEGER_POINTER(coldata) + state.position;
+			AppendColumnSegment<int, dtime_t, RTimeDaysType>(data_ptr, v, this_count);
+			break;
+		}
+		case RType::TIME_WEEKS_INTEGER: {
+			auto data_ptr = INTEGER_POINTER(coldata) + state.position;
+			AppendColumnSegment<int, dtime_t, RTimeWeeksType>(data_ptr, v, this_count);
+			break;
+		}
 		case RType::DATE: {
 			auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
 			AppendColumnSegment<double, date_t, RDateType>(data_ptr, v, this_count);
 			break;
 		}
+		case RType::DATE_INTEGER: {
+			auto data_ptr = INTEGER_POINTER(coldata) + state.position;
+			AppendColumnSegment<int, date_t, RDateType>(data_ptr, v, this_count);
+			break;
+		}
 		default:
 			throw;
 		}
diff --git a/tools/rpkg/src/statement.cpp b/tools/rpkg/src/statement.cpp
index 88db412d4062..61793825d9f3 100644
--- a/tools/rpkg/src/statement.cpp
+++ b/tools/rpkg/src/statement.cpp
@@ -137,7 +137,7 @@ SEXP RApi::Prepare(SEXP connsexp, SEXP querysexp) {
 	return retlist;
 }
 
-SEXP RApi::Bind(SEXP stmtsexp, SEXP paramsexp) {
+SEXP RApi::Bind(SEXP stmtsexp, SEXP paramsexp, SEXP arrowsexp) {
 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
 		Rf_error("duckdb_bind_R: Need external pointer parameter");
 	}
@@ -151,22 +151,47 @@ SEXP RApi::Bind(SEXP stmtsexp, SEXP paramsexp) {
 
 	if (stmtholder->stmt->n_param == 0) {
 		Rf_error("duckdb_bind_R: dbBind called but query takes no parameters");
-		return R_NilValue;
 	}
 
 	if (TYPEOF(paramsexp) != VECSXP || (idx_t)Rf_length(paramsexp) != stmtholder->stmt->n_param) {
 		Rf_error("duckdb_bind_R: bind parameters need to be a list of length %i", stmtholder->stmt->n_param);
 	}
 
-	for (idx_t param_idx = 0; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {
+	if (TYPEOF(arrowsexp) != LGLSXP) {
+		Rf_error("duckdb_bind_R: Need logical for third parameter");
+	}
+
+	bool arrow_fetch = LOGICAL_POINTER(arrowsexp)[0] != 0;
+
+	R_len_t n_rows = Rf_length(VECTOR_ELT(paramsexp, 0));
+
+	for (idx_t param_idx = 1; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {
 		SEXP valsexp = VECTOR_ELT(paramsexp, param_idx);
-		if (Rf_length(valsexp) != 1) {
-			Rf_error("duckdb_bind_R: bind parameter values need to have length 1");
+		if (Rf_length(valsexp) != n_rows) {
+			Rf_error("duckdb_bind_R: bind parameter values need to have the same length");
 		}
-		auto val = RApiTypes::SexpToValue(valsexp);
-		stmtholder->parameters[param_idx] = val;
 	}
-	return R_NilValue;
+
+	if (n_rows != 1 && arrow_fetch) {
+		Rf_error("duckdb_bind_R: bind parameter values need to have length one for arrow queries");
+	}
+
+	RProtector r;
+	auto out = r.Protect(NEW_LIST(n_rows));
+
+	for (idx_t row_idx = 0; row_idx < n_rows; ++row_idx) {
+		for (idx_t param_idx = 0; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {
+			SEXP valsexp = VECTOR_ELT(paramsexp, param_idx);
+			auto val = RApiTypes::SexpToValue(valsexp, row_idx);
+			stmtholder->parameters[param_idx] = val;
+		}
+
+		// No protection, assigned immediately
+		auto exec_result = RApi::Execute(stmtsexp, arrowsexp);
+		SET_VECTOR_ELT(out, row_idx, exec_result);
+	}
+
+	return out;
 }
 
 static SEXP duckdb_execute_R_impl(MaterializedQueryResult *result) {
diff --git a/tools/rpkg/src/types.cpp b/tools/rpkg/src/types.cpp
index 625125bfb912..42d0543bfb88 100644
--- a/tools/rpkg/src/types.cpp
+++ b/tools/rpkg/src/types.cpp
@@ -13,6 +13,8 @@ RType RApiTypes::DetectRType(SEXP v) {
 		return RType::TIMESTAMP;
 	} else if (TYPEOF(v) == REALSXP && Rf_inherits(v, "Date")) {
 		return RType::DATE;
+	} else if (TYPEOF(v) == INTSXP && Rf_inherits(v, "Date")) {
+		return RType::DATE_INTEGER;
 	} else if (TYPEOF(v) == REALSXP && Rf_inherits(v, "difftime")) {
 		SEXP units = Rf_getAttrib(v, Rf_install("units"));
 		if (TYPEOF(units) != STRSXP) {
@@ -32,6 +34,25 @@ RType RApiTypes::DetectRType(SEXP v) {
 		} else {
 			return RType::UNKNOWN;
 		}
+	} else if (TYPEOF(v) == INTSXP && Rf_inherits(v, "difftime")) {
+		SEXP units = Rf_getAttrib(v, Rf_install("units"));
+		if (TYPEOF(units) != STRSXP) {
+			return RType::UNKNOWN;
+		}
+		SEXP units0 = STRING_ELT(units, 0);
+		if (units0 == RStrings::get().secs) {
+			return RType::TIME_SECONDS_INTEGER;
+		} else if (units0 == RStrings::get().mins) {
+			return RType::TIME_MINUTES_INTEGER;
+		} else if (units0 == RStrings::get().hours) {
+			return RType::TIME_HOURS_INTEGER;
+		} else if (units0 == RStrings::get().days) {
+			return RType::TIME_DAYS_INTEGER;
+		} else if (units0 == RStrings::get().weeks) {
+			return RType::TIME_WEEKS_INTEGER;
+		} else {
+			return RType::UNKNOWN;
+		}
 	} else if (Rf_isFactor(v) && TYPEOF(v) == INTSXP) {
 		return RType::FACTOR;
 	} else if (TYPEOF(v) == LGLSXP) {
diff --git a/tools/rpkg/src/utils.cpp b/tools/rpkg/src/utils.cpp
index 46b6c7ef5316..758daa7c0a42 100644
--- a/tools/rpkg/src/utils.cpp
+++ b/tools/rpkg/src/utils.cpp
@@ -65,36 +65,40 @@ static void AppendColumnSegment(SRC *source_data, Vector &result, idx_t count) {
 	}
 }
 
-Value RApiTypes::SexpToValue(SEXP valsexp) {
+Value RApiTypes::SexpToValue(SEXP valsexp, R_len_t idx) {
 	Value val;
 	auto rtype = RApiTypes::DetectRType(valsexp);
 	switch (rtype) {
 	case RType::LOGICAL: {
-		auto lgl_val = INTEGER_POINTER(valsexp)[0];
+		auto lgl_val = INTEGER_POINTER(valsexp)[idx];
 		val = Value::BOOLEAN(lgl_val);
 		val.is_null = RBooleanType::IsNull(lgl_val);
 		break;
 	}
 	case RType::INTEGER: {
-		auto int_val = INTEGER_POINTER(valsexp)[0];
+		auto int_val = INTEGER_POINTER(valsexp)[idx];
 		val = Value::INTEGER(int_val);
 		val.is_null = RIntegerType::IsNull(int_val);
 		break;
 	}
 	case RType::NUMERIC: {
-		auto dbl_val = NUMERIC_POINTER(valsexp)[0];
-		val = Value::DOUBLE(dbl_val);
-		val.is_null = RDoubleType::IsNull(dbl_val);
+		auto dbl_val = NUMERIC_POINTER(valsexp)[idx];
+		bool is_null = RDoubleType::IsNull(dbl_val);
+		if (is_null) {
+			val = Value(LogicalType::DOUBLE);
+		} else {
+			val = Value::DOUBLE(dbl_val);
+		}
 		break;
 	}
 	case RType::STRING: {
-		auto str_val = STRING_ELT(valsexp, 0);
+		auto str_val = STRING_ELT(valsexp, idx);
 		val = Value(CHAR(str_val));
 		val.is_null = str_val == NA_STRING;
 		break;
 	}
 	case RType::FACTOR: {
-		auto int_val = INTEGER_POINTER(valsexp)[0];
+		auto int_val = INTEGER_POINTER(valsexp)[idx];
 		auto levels = GET_LEVELS(valsexp);
 		bool is_null = RIntegerType::IsNull(int_val);
 		if (!is_null) {
@@ -106,47 +110,87 @@ Value RApiTypes::SexpToValue(SEXP valsexp) {
 		break;
 	}
 	case RType::TIMESTAMP: {
-		auto ts_val = NUMERIC_POINTER(valsexp)[0];
-		val = Value::TIMESTAMP(RTimestampType::Convert(ts_val));
-		val.is_null = RTimestampType::IsNull(ts_val);
+		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
+		bool is_null = RTimestampType::IsNull(ts_val);
+		if (!is_null) {
+			val = Value::TIMESTAMP(RTimestampType::Convert(ts_val));
+		} else {
+			val = Value(LogicalType::TIMESTAMP);
+		}
 		break;
 	}
 	case RType::DATE: {
-		auto d_val = NUMERIC_POINTER(valsexp)[0];
+		auto d_val = NUMERIC_POINTER(valsexp)[idx];
 		val = Value::DATE(RDateType::Convert(d_val));
 		val.is_null = RDateType::IsNull(d_val);
 		break;
 	}
+	case RType::DATE_INTEGER: {
+		auto d_val = INTEGER_POINTER(valsexp)[idx];
+		val = Value::DATE(RDateType::Convert(d_val));
+		val.is_null = RIntegerType::IsNull(d_val);
+		break;
+	}
 	case RType::TIME_SECONDS: {
-		auto ts_val = NUMERIC_POINTER(valsexp)[0];
+		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
 		val = Value::TIME(RTimeSecondsType::Convert(ts_val));
 		val.is_null = RTimeSecondsType::IsNull(ts_val);
 		break;
 	}
 	case RType::TIME_MINUTES: {
-		auto ts_val = NUMERIC_POINTER(valsexp)[0];
+		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
 		val = Value::TIME(RTimeMinutesType::Convert(ts_val));
 		val.is_null = RTimeMinutesType::IsNull(ts_val);
 		break;
 	}
 	case RType::TIME_HOURS: {
-		auto ts_val = NUMERIC_POINTER(valsexp)[0];
+		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
 		val = Value::TIME(RTimeHoursType::Convert(ts_val));
 		val.is_null = RTimeHoursType::IsNull(ts_val);
 		break;
 	}
 	case RType::TIME_DAYS: {
-		auto ts_val = NUMERIC_POINTER(valsexp)[0];
+		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
 		val = Value::TIME(RTimeDaysType::Convert(ts_val));
 		val.is_null = RTimeDaysType::IsNull(ts_val);
 		break;
 	}
 	case RType::TIME_WEEKS: {
-		auto ts_val = NUMERIC_POINTER(valsexp)[0];
+		auto ts_val = NUMERIC_POINTER(valsexp)[idx];
 		val = Value::TIME(RTimeWeeksType::Convert(ts_val));
 		val.is_null = RTimeWeeksType::IsNull(ts_val);
 		break;
 	}
+	case RType::TIME_SECONDS_INTEGER: {
+		auto ts_val = INTEGER_POINTER(valsexp)[idx];
+		val = Value::TIME(RTimeSecondsType::Convert(ts_val));
+		val.is_null = RIntegerType::IsNull(ts_val);
+		break;
+	}
+	case RType::TIME_MINUTES_INTEGER: {
+		auto ts_val = INTEGER_POINTER(valsexp)[idx];
+		val = Value::TIME(RTimeMinutesType::Convert(ts_val));
+		val.is_null = RIntegerType::IsNull(ts_val);
+		break;
+	}
+	case RType::TIME_HOURS_INTEGER: {
+		auto ts_val = INTEGER_POINTER(valsexp)[idx];
+		val = Value::TIME(RTimeHoursType::Convert(ts_val));
+		val.is_null = RIntegerType::IsNull(ts_val);
+		break;
+	}
+	case RType::TIME_DAYS_INTEGER: {
+		auto ts_val = INTEGER_POINTER(valsexp)[idx];
+		val = Value::TIME(RTimeDaysType::Convert(ts_val));
+		val.is_null = RIntegerType::IsNull(ts_val);
+		break;
+	}
+	case RType::TIME_WEEKS_INTEGER: {
+		auto ts_val = INTEGER_POINTER(valsexp)[idx];
+		val = Value::TIME(RTimeWeeksType::Convert(ts_val));
+		val.is_null = RIntegerType::IsNull(ts_val);
+		break;
+	}
 	default:
 		Rf_error("duckdb_sexp_to_value: Unsupported type");
 	}
