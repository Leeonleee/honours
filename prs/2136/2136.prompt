You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
R: Fix DBItest tests
https://github.com/cwida/duckdb/pull/738/commits/7b610e930071eb90fd3721d5cc358e9f88d7a92c and others.

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![codecov](https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN)](https://codecov.io/gh/duckdb/duckdb)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of tools/rpkg/NAMESPACE]
1: # Generated by roxygen2: do not edit by hand
2: 
3: export(duckdb)
4: export(duckdb_fetch_arrow)
5: export(duckdb_fetch_record_batch)
6: export(duckdb_read_csv)
7: export(duckdb_register)
8: export(duckdb_register_arrow)
9: export(duckdb_shutdown)
10: export(duckdb_unregister)
11: export(duckdb_unregister_arrow)
12: export(read_csv_duckdb)
13: exportClasses(duckdb_connection)
14: exportClasses(duckdb_driver)
15: exportClasses(duckdb_result)
16: exportMethods(dbAppendTable)
17: exportMethods(dbBegin)
18: exportMethods(dbBind)
19: exportMethods(dbClearResult)
20: exportMethods(dbColumnInfo)
21: exportMethods(dbCommit)
22: exportMethods(dbConnect)
23: exportMethods(dbDataType)
24: exportMethods(dbDisconnect)
25: exportMethods(dbExistsTable)
26: exportMethods(dbFetch)
27: exportMethods(dbGetInfo)
28: exportMethods(dbGetRowCount)
29: exportMethods(dbGetRowsAffected)
30: exportMethods(dbGetStatement)
31: exportMethods(dbHasCompleted)
32: exportMethods(dbIsValid)
33: exportMethods(dbListFields)
34: exportMethods(dbListTables)
35: exportMethods(dbRemoveTable)
36: exportMethods(dbRollback)
37: exportMethods(dbSendQuery)
38: exportMethods(dbWriteTable)
39: exportMethods(show)
40: import(DBI)
41: import(methods)
42: importFrom(DBI,dbConnect)
43: importFrom(utils,head)
44: useDynLib(duckdb, .registration = TRUE)
[end of tools/rpkg/NAMESPACE]
[start of tools/rpkg/R/Connection.R]
1: #' DuckDB driver class
2: #'
3: #' Implements \linkS4class{DBIDriver}.
4: #'
5: #' @aliases duckdb_driver
6: #' @keywords internal
7: #' @export
8: setClass("duckdb_driver", contains = "DBIDriver", slots = list(database_ref = "externalptr", dbdir = "character", read_only = "logical"))
9: 
10: #' DuckDB connection class
11: #'
12: #' Implements \linkS4class{DBIConnection}.
13: #'
14: #' @aliases duckdb_connection
15: #' @keywords internal
16: #' @export
17: setClass("duckdb_connection",
18:   contains = "DBIConnection",
19:   slots = list(conn_ref = "externalptr",
20:                driver = "duckdb_driver",
21:                debug = "logical",
22:                timezone_out = "character",
23:                tz_out_convert = "character")
24: )
25: 
26: duckdb_connection <- function(duckdb_driver, debug) {
27:   new(
28:     "duckdb_connection",
29:     conn_ref = .Call(duckdb_connect_R, duckdb_driver@database_ref),
30:     driver = duckdb_driver,
31:     debug = debug,
32:     timezone_out = "UTC",
33:     tz_out_convert = "with"
34:   )
35: }
36: 
37: #' @rdname duckdb_connection-class
38: #' @inheritParams methods::show
39: #' @export
40: setMethod(
41:   "show", "duckdb_connection",
42:   function(object) {
43:     message(sprintf("<duckdb_connection %s driver=%s>", extptr_str(object@conn_ref), drv_to_string(object@driver)))
44:     invisible(NULL)
45:   }
46: )
47: 
48: #' @rdname duckdb_connection-class
49: #' @inheritParams DBI::dbIsValid
50: #' @export
51: setMethod(
52:   "dbIsValid", "duckdb_connection",
53:   function(dbObj, ...) {
54:     valid <- FALSE
55:     tryCatch(
56:       {
57:         dbGetQuery(dbObj, SQL("SELECT 1"))
58:         valid <- TRUE
59:       },
60:       error = function(c) {
61:       }
62:     )
63:     valid
64:   }
65: )
66: 
67: #' @rdname duckdb_connection-class
68: #' @inheritParams DBI::dbSendQuery
69: #' @inheritParams DBI::dbBind
70: #' @param arrow Whether the query should be returned as an Arrow Table
71: #' @export
72: setMethod(
73:   "dbSendQuery", c("duckdb_connection", "character"),
74:   function(conn, statement, params = NULL, ..., arrow=FALSE) {
75:     if (conn@debug) {
76:       message("Q ", statement)
77:     }
78:     statement <- enc2utf8(statement)
79:     stmt_lst <- .Call(duckdb_prepare_R, conn@conn_ref, statement)
80: 
81:     res <- duckdb_result(
82:       connection = conn,
83:       stmt_lst = stmt_lst,
84:       arrow = arrow
85:     )
86:     if (length(params) > 0) {
87:       dbBind(res, params)
88:     }
89:     return(res)
90:   }
91: )
92: 
93: #' @rdname duckdb_connection-class
94: #' @inheritParams DBI::dbDataType
95: #' @export
96: setMethod(
97:   "dbDataType", "duckdb_connection",
98:   function(dbObj, obj, ...) {
99:     dbDataType(dbObj@driver, obj, ...)
100:   }
101: )
102: 
103: duckdb_random_string <- function(x) {
104:   paste(sample(letters, 10, replace = TRUE), collapse = "")
105: }
106: 
107: #' @rdname duckdb_connection-class
108: #' @inheritParams DBI::dbWriteTable
109: #' @param row.names Whether the row.names of the data.frame should be preserved
110: #' @param overwrite If a table with the given name already exists, should it be overwritten?
111: #' @param append If a table with the given name already exists, just try to append the passed data to it
112: #' @param field.types Override the auto-generated SQL types
113: #' @param temporary Should the created table be temporary?
114: #' @export
115: setMethod(
116:   "dbWriteTable", c("duckdb_connection", "character", "data.frame"),
117:   function(conn,
118:            name,
119:            value,
120:            row.names = FALSE,
121:            overwrite = FALSE,
122:            append = FALSE,
123:            field.types = NULL,
124:            temporary = FALSE,
125:            ...) {
126:     check_flag(overwrite)
127:     check_flag(append)
128:     check_flag(temporary)
129: 
130:     # TODO: start a transaction if one is not already running
131: 
132:     if (overwrite && append) {
133:       stop("Setting both overwrite and append makes no sense")
134:     }
135: 
136:     if (!is.null(field.types)) {
137:       if (!(is.character(field.types) && !is.null(names(field.types)) && !anyDuplicated(names(field.types)))) {
138:         stop("`field.types` must be a named character vector with unique names, or NULL")
139:       }
140:     }
141:     if (append && !is.null(field.types)) {
142:       stop("Cannot specify `field.types` with `append = TRUE`")
143:     }
144: 
145:     value <- as.data.frame(value)
146:     if (!is.data.frame(value)) {
147:       stop("need a data frame as parameter")
148:     }
149: 
150:     # use Kirill's magic, convert rownames to additional column
151:     value <- sqlRownamesToColumn(value, row.names)
152: 
153:     is_factor <- vapply(value, is.factor, logical(1))
154:     value[is_factor] <- lapply(value[is_factor], function(x) {
155:       levels(x) <- enc2utf8(levels(x))
156:       as.character(x)
157:     })
158: 
159:     if (dbExistsTable(conn, name)) {
160:       if (overwrite) {
161:         dbRemoveTable(conn, name)
162:       }
163:       if (!overwrite && !append) {
164:         stop(
165:           "Table ",
166:           name,
167:           " already exists. Set `overwrite = TRUE` if you want to remove the existing table. ",
168:           "Set `append = TRUE` if you would like to add the new data to the existing table."
169:         )
170:       }
171:     }
172:     table_name <- dbQuoteIdentifier(conn, name)
173: 
174:     if (!dbExistsTable(conn, name)) {
175:       column_names <- dbQuoteIdentifier(conn, names(value))
176:       column_types <-
177:         vapply(value, dbDataType, dbObj = conn, FUN.VALUE = "character")
178: 
179:       if (!is.null(field.types)) {
180:         column_types[names(field.types)] <- field.types
181:       }
182: 
183:       temp_str <- ""
184:       if (temporary) temp_str <- "TEMPORARY"
185: 
186:       schema_str <- paste(column_names, column_types, collapse = ", ")
187:       dbExecute(conn, SQL(sprintf(
188:         "CREATE %s TABLE %s (%s)", temp_str, table_name, schema_str
189:       )))
190:     }
191: 
192:     dbAppendTable(conn, name, value)
193:     invisible(TRUE)
194:   }
195: )
196: 
197: #' @rdname duckdb_connection-class
198: #' @inheritParams DBI::dbAppendTable
199: #' @export
200: setMethod(
201:   "dbAppendTable", "duckdb_connection",
202:   function(conn, name, value, ..., row.names = NULL) {
203:     if (!is.null(row.names)) {
204:       stop("Can't pass `row.names` to `dbAppendTable()`")
205:     }
206: 
207:     if (!identical(names(value), dbListFields(conn, name))) {
208:       stop("Column name mismatch for append")
209:     }
210: 
211:     is_factor <- vapply(value, is.factor, logical(1))
212:     if (any(is_factor)) {
213:       warning("Factors converted to character")
214:     }
215: 
216:     if (nrow(value)) {
217:       is_character <- vapply(value, is.character, logical(1))
218:       value[is_character] <- lapply(value[is_character], enc2utf8)
219:       value[is_factor] <- lapply(value[is_factor], function(x) {
220:         levels(x) <- enc2utf8(levels(x))
221:         as.character(x)
222:       })
223: 
224:       table_name <- dbQuoteIdentifier(conn, name)
225: 
226:       view_name <- sprintf("_duckdb_append_view_%s", duckdb_random_string())
227:       on.exit(duckdb_unregister(conn, view_name))
228:       duckdb_register(conn, view_name, value)
229:       dbExecute(conn, sprintf("INSERT INTO %s SELECT * FROM %s", table_name, view_name))
230: 
231:       rs_on_connection_updated(conn, hint=paste0("Updated table'", table_name,"'"))
232:     }
233: 
234:     invisible(nrow(value))
235:   }
236: )
237: 
238: #' @rdname duckdb_connection-class
239: #' @inheritParams DBI::dbListTables
240: #' @export
241: setMethod(
242:   "dbListTables", "duckdb_connection",
243:   function(conn, ...) {
244:     dbGetQuery(
245:       conn,
246:       SQL(
247:         "SELECT name FROM sqlite_master WHERE type='table' OR type='view' ORDER BY name"
248:       )
249:     )[[1]]
250:   }
251: )
252: 
253: #' @rdname duckdb_connection-class
254: #' @inheritParams DBI::dbExistsTable
255: #' @export
256: setMethod(
257:   "dbExistsTable", c("duckdb_connection", "character"),
258:   function(conn, name, ...) {
259:     if (!dbIsValid(conn)) {
260:       stop("Invalid connection")
261:     }
262:     if (length(name) != 1) {
263:       stop("Can only have a single name argument")
264:     }
265:     exists <- FALSE
266:     tryCatch(
267:       {
268:         dbGetQuery(
269:           conn,
270:           sqlInterpolate(
271:             conn,
272:             "SELECT * FROM ? WHERE FALSE",
273:             dbQuoteIdentifier(conn, name)
274:           )
275:         )
276:         exists <- TRUE
277:       },
278:       error = function(c) {
279:       }
280:     )
281:     exists
282:   }
283: )
284: 
285: #' @rdname duckdb_connection-class
286: #' @inheritParams DBI::dbListFields
287: #' @export
288: setMethod(
289:   "dbListFields", c("duckdb_connection", "character"),
290:   function(conn, name, ...) {
291:     names(dbGetQuery(
292:       conn,
293:       sqlInterpolate(
294:         conn,
295:         "SELECT * FROM ? WHERE FALSE",
296:         dbQuoteIdentifier(conn, name)
297:       )
298:     ))
299:   }
300: )
301: 
302: #' @rdname duckdb_connection-class
303: #' @inheritParams DBI::dbRemoveTable
304: #' @export
305: setMethod(
306:   "dbRemoveTable", c("duckdb_connection", "character"),
307:   function(conn, name, ..., fail_if_missing = TRUE) {
308:     sql <- paste0("DROP TABLE ", if (!fail_if_missing) "IF EXISTS ", "?")
309:     dbExecute(
310:       conn,
311:       sqlInterpolate(conn, sql, dbQuoteIdentifier(conn, name))
312:     )
313:     rs_on_connection_updated(conn, "Table removed")
314:     invisible(TRUE)
315:   }
316: )
317: 
318: #' @rdname duckdb_connection-class
319: #' @inheritParams DBI::dbGetInfo
320: #' @export
321: setMethod(
322:   "dbGetInfo", "duckdb_connection",
323:   function(dbObj, ...) {
324:     info <- dbGetInfo(dbObj@driver)
325:     list(
326:       dbname = info$dbname,
327:       db.version = info$driver.version,
328:       username = NA,
329:       host = NA,
330:       port = NA
331:     )
332:   }
333: )
334: 
335: #' @rdname duckdb_connection-class
336: #' @inheritParams DBI::dbBegin
337: #' @export
338: setMethod(
339:   "dbBegin", "duckdb_connection",
340:   function(conn, ...) {
341:     dbExecute(conn, SQL("BEGIN TRANSACTION"))
342:     invisible(TRUE)
343:   }
344: )
345: 
346: #' @rdname duckdb_connection-class
347: #' @inheritParams DBI::dbCommit
348: #' @export
349: setMethod(
350:   "dbCommit", "duckdb_connection",
351:   function(conn, ...) {
352:     dbExecute(conn, SQL("COMMIT"))
353:     invisible(TRUE)
354:   }
355: )
356: 
357: #' @rdname duckdb_connection-class
358: #' @inheritParams DBI::dbRollback
359: #' @export
360: setMethod(
361:   "dbRollback", "duckdb_connection",
362:   function(conn, ...) {
363:     dbExecute(conn, SQL("ROLLBACK"))
364:     invisible(TRUE)
365:   }
366: )
[end of tools/rpkg/R/Connection.R]
[start of tools/rpkg/R/Result.R]
1: #' DuckDB Result Set
2: #'
3: #' Methods for accessing result sets for queries on DuckDB connections.
4: #' Implements \linkS4class{DBIResult}.
5: #'
6: #' @aliases duckdb_result
7: #' @keywords internal
8: #' @export
9: setClass("duckdb_result",
10:   contains = "DBIResult",
11:   slots = list(
12:     connection = "duckdb_connection",
13:     stmt_lst = "list",
14:     env = "environment",
15:     arrow = "logical",
16:     query_result = "externalptr"
17:   )
18: )
19: 
20: duckdb_result <- function(connection, stmt_lst, arrow) {
21:   env <- new.env(parent = emptyenv())
22:   env$rows_fetched <- 0
23:   env$open <- TRUE
24:   env$rows_affected <- 0
25: 
26:   res <- new("duckdb_result", connection = connection, stmt_lst = stmt_lst, env = env, arrow=arrow)
27: 
28:   if (stmt_lst$n_param == 0) {
29:     if (arrow){
30:       query_result <- duckdb_execute(res)
31:       new_res <- new("duckdb_result", connection = connection, stmt_lst = stmt_lst, env = env, arrow=arrow, query_result=query_result)
32:       return (new_res)
33:     }
34:     else{
35:       duckdb_execute(res)
36:     }
37: 
38:   }
39: 
40: 
41:   return(res)
42: }
43: 
44: duckdb_execute <- function(res) {
45:   if (res@arrow){
46:     query <- .Call(duckdb_execute_R, res@stmt_lst$ref, res@arrow)
47:     return (query)
48:   }
49:   res@env$resultset <- .Call(duckdb_execute_R, res@stmt_lst$ref, res@arrow)
50:   if (!res@arrow) {
51:       attr(res@env$resultset, "row.names") <-
52:         c(NA_integer_, as.integer(-1 * length(res@env$resultset[[1]])))
53:       class(res@env$resultset) <- "data.frame"
54:   }
55:   if (res@stmt_lst$type != "SELECT") {
56:     res@env$rows_affected <- as.numeric(res@env$resultset[[1]][1])
57:   }
58: }
59: 
60: 
61: #' @rdname duckdb_result-class
62: #' @inheritParams methods::show
63: #' @export
64: setMethod(
65:   "show", "duckdb_result",
66:   function(object) {
67:     message(sprintf("<duckdb_result %s connection=%s statement='%s'>", extptr_str(object@stmt_lst$ref), extptr_str(object@connection@conn_ref), object@stmt_lst$str))
68:     invisible(NULL)
69:   }
70: )
71: 
72: #' @rdname duckdb_result-class
73: #' @inheritParams DBI::dbClearResult
74: #' @export
75: setMethod(
76:   "dbClearResult", "duckdb_result",
77:   function(res, ...) {
78:     if (res@env$open) {
79:       .Call(duckdb_release_R, res@stmt_lst$ref)
80:       res@env$open <- FALSE
81:     } else {
82:       warning("Result was cleared already")
83:     }
84:     return(invisible(TRUE))
85:   }
86: )
87: 
88: # as per is.integer documentation
89: is_wholenumber <- function(x, tol = .Machine$double.eps^0.5) abs(x - round(x)) < tol
90: 
91: fix_rownames <- function(df) {
92:   attr(df, "row.names") <- c(NA, as.integer(-nrow(df)))
93:   return(df)
94: }
95: 
96: #' @rdname duckdb_result-class
97: #' @param res Query result to be converted to an Arrow Table
98: #' @param stream If we are streaming the query result or returning it all at once
99: #' @param vector_per_chunk If streaming, how many vectors per chunk we should emit
100: #' @param return_table If we return results as a list of RecordBatches or an Arrow Table
101: #' @export
102: duckdb_fetch_arrow <- function(res,stream=FALSE,vector_per_chunk=1,return_table=FALSE) {
103:   if (vector_per_chunk < 0) {
104:       stop("cannot fetch negative vector_per_chunk")
105:   }
106:   result <- .Call(duckdb_fetch_arrow_R, res@query_result,stream,vector_per_chunk,return_table)
107:   return (result)
108: }
109: 
110: #' @rdname duckdb_result-class
111: #' @param res Query result to be converted to an Arrow Table
112: #' @export
113: duckdb_fetch_record_batch <- function(res) {
114:   result <- .Call(duckdb_fetch_record_batch_R, res@query_result)
115:   return (result)
116: }
117: 
118: 
119: 
120: #' @rdname duckdb_result-class
121: #' @inheritParams DBI::dbFetch
122: #' @importFrom utils head
123: #' @export
124: setMethod(
125:   "dbFetch", "duckdb_result",
126:   function(res, n = -1, ...) {
127:     if (!res@env$open) {
128:       stop("result set was closed")
129:     }
130:     if (length(n) != 1) {
131:       stop("need exactly one value in n")
132:     }
133:     if (is.infinite(n)) {
134:       n <- -1
135:     }
136:     if (n < -1) {
137:       stop("cannot fetch negative n other than -1")
138:     }
139:     if (!is_wholenumber(n)) {
140:       stop("n needs to be not a whole number")
141:     }
142:     if (res@stmt_lst$type != "SELECT") {
143:       warning("Should not call dbFetch() on results that do not come from SELECT")
144:       return(data.frame())
145:     }
146: 
147:     if (res@arrow) {
148:         stop("Cannot dbFetch() an Arrow result")
149:     }
150: 
151:     timezone_out <- res@connection@timezone_out
152:     tz_out_convert <- res@connection@tz_out_convert
153: 
154:     # FIXME this is ugly
155:     if (n == 0) {
156:       return(utils::head(res@env$resultset, 0))
157:     }
158:     if (res@env$rows_fetched < 0) {
159:       res@env$rows_fetched <- 0
160:     }
161:     if (res@env$rows_fetched >= nrow(res@env$resultset)) {
162:       df <- fix_rownames(res@env$resultset[F, , drop = F])
163:       df <- set_output_tz(df, timezone_out, tz_out_convert)
164:       return(df)
165:     }
166:     # special case, return everything
167:     if (n == -1 && res@env$rows_fetched == 0) {
168:       res@env$rows_fetched <- nrow(res@env$resultset)
169:       df <- res@env$resultset
170:       df <- set_output_tz(df, timezone_out, tz_out_convert)
171:       return(df)
172:     }
173:     if (n > -1) {
174:       n <- min(n, nrow(res@env$resultset) - res@env$rows_fetched)
175:       res@env$rows_fetched <- res@env$rows_fetched + n
176:       df <- res@env$resultset[(res@env$rows_fetched - n + 1):(res@env$rows_fetched), , drop = F]
177:       df <- set_output_tz(df, timezone_out, tz_out_convert)
178:       return(fix_rownames(df))
179:     }
180:     start <- res@env$rows_fetched + 1
181:     res@env$rows_fetched <- nrow(res@env$resultset)
182:     df <- res@env$resultset[nrow(res@env$resultset), , drop = F]
183: 
184:     df <- set_output_tz(df, timezone_out, tz_out_convert)
185:     return(fix_rownames(df))
186:   }
187: )
188: 
189: #' @rdname duckdb_result-class
190: #' @inheritParams DBI::dbHasCompleted
191: #' @export
192: setMethod(
193:   "dbHasCompleted", "duckdb_result",
194:   function(res, ...) {
195:     if (!res@env$open) {
196:       stop("result has already been cleared")
197:     }
198:     if (res@stmt_lst$type != "SELECT") {
199:       return(TRUE)
200:     }
201:     return(res@env$rows_fetched == nrow(res@env$resultset))
202:   }
203: )
204: 
205: #' @rdname duckdb_result-class
206: #' @inheritParams DBI::dbGetInfo
207: #' @export
208: setMethod(
209:   "dbGetInfo", "duckdb_result",
210:   function(dbObj, ...) {
211:     # Optional
212:     getMethod("dbGetInfo", "DBIResult", asNamespace("DBI"))(dbObj, ...)
213:   }
214: )
215: 
216: #' @rdname duckdb_result-class
217: #' @inheritParams DBI::dbIsValid
218: #' @export
219: setMethod(
220:   "dbIsValid", "duckdb_result",
221:   function(dbObj, ...) {
222:     return(dbObj@env$open)
223:   }
224: )
225: 
226: #' @rdname duckdb_result-class
227: #' @inheritParams DBI::dbGetStatement
228: #' @export
229: setMethod(
230:   "dbGetStatement", "duckdb_result",
231:   function(res, ...) {
232:     if (!res@env$open) {
233:       stop("result has already been cleared")
234:     }
235:     return(res@stmt_lst$str)
236:   }
237: )
238: 
239: #' @rdname duckdb_result-class
240: #' @inheritParams DBI::dbColumnInfo
241: #' @export
242: setMethod(
243:   "dbColumnInfo", "duckdb_result",
244:   function(res, ...) {
245:     if (!res@env$open) {
246:       stop("result has already been cleared")
247:     }
248:     return(data.frame(name = res@stmt_lst$names, type = res@stmt_lst$rtypes, stringsAsFactors = FALSE))
249:   }
250: )
251: 
252: #' @rdname duckdb_result-class
253: #' @inheritParams DBI::dbGetRowCount
254: #' @export
255: setMethod(
256:   "dbGetRowCount", "duckdb_result",
257:   function(res, ...) {
258:     if (!res@env$open) {
259:       stop("result has already been cleared")
260:     }
261:     return(res@env$rows_fetched)
262:   }
263: )
264: 
265: #' @rdname duckdb_result-class
266: #' @inheritParams DBI::dbGetRowsAffected
267: #' @export
268: setMethod(
269:   "dbGetRowsAffected", "duckdb_result",
270:   function(res, ...) {
271:     if (!res@env$open) {
272:       stop("result has already been cleared")
273:     }
274:     return(res@env$rows_affected)
275:   }
276: )
277: 
278: #' @rdname duckdb_result-class
279: #' @inheritParams DBI::dbBind
280: #' @export
281: setMethod(
282:   "dbBind", "duckdb_result",
283:   function(res, params, ...) {
284:     if (!res@env$open) {
285:       stop("result has already been cleared")
286:     }
287:     res@env$rows_fetched <- 0
288:     res@env$resultset <- data.frame()
289: 
290:     invisible(.Call(duckdb_bind_R, res@stmt_lst$ref, params))
291:     duckdb_execute(res)
292:   }
293: )
294: 
295: set_output_tz <- function(x, timezone, convert) {
296:   if (timezone == "UTC") return(x)
297: 
298:   tz_convert <- switch(convert,
299:                        with = tz_convert,
300:                        force = tz_force)
301: 
302:   is_datetime <- which(vapply(x, inherits, "POSIXt", FUN.VALUE = logical(1)))
303: 
304:   if (length(is_datetime) > 0) {
305:     x[is_datetime] <- lapply(x[is_datetime], tz_convert, timezone)
306:   }
307:   x
308: }
309: 
310: tz_convert <- function(x, timezone) {
311:   attr(x, "tzone") <- timezone
312:   x
313: }
314: 
315: tz_force <- function(x, timezone) {
316:   # convert to character, stripping the timezone
317:   ct <- as.character(x, usetz = FALSE)
318:   # recreate the POSIXct with specified timezone
319:   as.POSIXct(ct, tz = timezone)
320: }
[end of tools/rpkg/R/Result.R]
[start of tools/rpkg/man/duckdb_connection-class.Rd]
1: % Generated by roxygen2: do not edit by hand
2: % Please edit documentation in R/Connection.R
3: \docType{class}
4: \name{duckdb_connection-class}
5: \alias{duckdb_connection-class}
6: \alias{duckdb_connection}
7: \alias{show,duckdb_connection-method}
8: \alias{dbIsValid,duckdb_connection-method}
9: \alias{dbSendQuery,duckdb_connection,character-method}
10: \alias{dbDataType,duckdb_connection-method}
11: \alias{dbWriteTable,duckdb_connection,character,data.frame-method}
12: \alias{dbAppendTable,duckdb_connection-method}
13: \alias{dbListTables,duckdb_connection-method}
14: \alias{dbExistsTable,duckdb_connection,character-method}
15: \alias{dbListFields,duckdb_connection,character-method}
16: \alias{dbRemoveTable,duckdb_connection,character-method}
17: \alias{dbGetInfo,duckdb_connection-method}
18: \alias{dbBegin,duckdb_connection-method}
19: \alias{dbCommit,duckdb_connection-method}
20: \alias{dbRollback,duckdb_connection-method}
21: \title{DuckDB connection class}
22: \usage{
23: \S4method{show}{duckdb_connection}(object)
24: 
25: \S4method{dbIsValid}{duckdb_connection}(dbObj, ...)
26: 
27: \S4method{dbSendQuery}{duckdb_connection,character}(conn, statement, params = NULL, ..., arrow = FALSE)
28: 
29: \S4method{dbDataType}{duckdb_connection}(dbObj, obj, ...)
30: 
31: \S4method{dbWriteTable}{duckdb_connection,character,data.frame}(
32:   conn,
33:   name,
34:   value,
35:   row.names = FALSE,
36:   overwrite = FALSE,
37:   append = FALSE,
38:   field.types = NULL,
39:   temporary = FALSE,
40:   ...
41: )
42: 
43: \S4method{dbAppendTable}{duckdb_connection}(conn, name, value, ..., row.names = NULL)
44: 
45: \S4method{dbListTables}{duckdb_connection}(conn, ...)
46: 
47: \S4method{dbExistsTable}{duckdb_connection,character}(conn, name, ...)
48: 
49: \S4method{dbListFields}{duckdb_connection,character}(conn, name, ...)
50: 
51: \S4method{dbRemoveTable}{duckdb_connection,character}(conn, name, ..., fail_if_missing = TRUE)
52: 
53: \S4method{dbGetInfo}{duckdb_connection}(dbObj, ...)
54: 
55: \S4method{dbBegin}{duckdb_connection}(conn, ...)
56: 
57: \S4method{dbCommit}{duckdb_connection}(conn, ...)
58: 
59: \S4method{dbRollback}{duckdb_connection}(conn, ...)
60: }
61: \arguments{
62: \item{object}{Any R object}
63: 
64: \item{dbObj}{An object inheriting from \linkS4class{DBIObject},
65: i.e. \linkS4class{DBIDriver}, \linkS4class{DBIConnection},
66: or a \linkS4class{DBIResult}}
67: 
68: \item{...}{Other arguments to methods.}
69: 
70: \item{conn}{A \linkS4class{DBIConnection} object, as returned by
71: \code{\link[DBI:dbConnect]{dbConnect()}}.}
72: 
73: \item{statement}{a character string containing SQL.}
74: 
75: \item{params}{A list of bindings, named or unnamed.}
76: 
77: \item{arrow}{Whether the query should be returned as an Arrow Table}
78: 
79: \item{obj}{An R object whose SQL type we want to determine.}
80: 
81: \item{name}{A character string specifying the unquoted DBMS table name,
82: or the result of a call to \code{\link[DBI:dbQuoteIdentifier]{dbQuoteIdentifier()}}.}
83: 
84: \item{value}{a \link{data.frame} (or coercible to data.frame).}
85: 
86: \item{row.names}{Whether the row.names of the data.frame should be preserved}
87: 
88: \item{overwrite}{If a table with the given name already exists, should it be overwritten?}
89: 
90: \item{append}{If a table with the given name already exists, just try to append the passed data to it}
91: 
92: \item{field.types}{Override the auto-generated SQL types}
93: 
94: \item{temporary}{Should the created table be temporary?}
95: }
96: \description{
97: Implements \linkS4class{DBIConnection}.
98: }
99: \keyword{internal}
[end of tools/rpkg/man/duckdb_connection-class.Rd]
[start of tools/rpkg/src/include/rapi.hpp]
1: #pragma once
2: 
3: #define R_NO_REMAP
4: #include <Rdefines.h>
5: #include <R_ext/Altrep.h>
6: 
7: #include "duckdb.hpp"
8: #include "duckdb/function/table_function.hpp"
9: 
10: namespace duckdb {
11: 
12: struct RApi {
13: 
14: 	static SEXP Startup(SEXP dbdirsexp, SEXP readonlysexp, SEXP configsexp);
15: 
16: 	static SEXP Shutdown(SEXP dbsexp);
17: 
18: 	static SEXP Connect(SEXP dbsexp);
19: 
20: 	static SEXP Disconnect(SEXP connsexp);
21: 
22: 	static SEXP Prepare(SEXP connsexp, SEXP querysexp);
23: 
24: 	static SEXP Bind(SEXP stmtsexp, SEXP paramsexp);
25: 
26: 	static SEXP Execute(SEXP stmtsexp, SEXP arrowsexp);
27: 
28: 	static SEXP DuckDBExecuteArrow(SEXP query_resultsexp, SEXP streamsexp, SEXP vector_per_chunksexp,
29: 	                               SEXP return_tablesexp);
30: 
31: 	static SEXP DuckDBRecordBatchR(SEXP query_resultsexp);
32: 
33: 	static SEXP Release(SEXP stmtsexp);
34: 
35: 	static SEXP RegisterDataFrame(SEXP connsexp, SEXP namesexp, SEXP valuesexp);
36: 
37: 	static SEXP UnregisterDataFrame(SEXP connsexp, SEXP namesexp);
38: 
39: 	static SEXP RegisterArrow(SEXP connsexp, SEXP namesexp, SEXP export_funsexp, SEXP valuesexp);
40: 
41: 	static SEXP UnregisterArrow(SEXP connsexp, SEXP namesexp);
42: 
43: 	static SEXP PointerToString(SEXP extptr);
44: 	static SEXP StringsToSexp(vector<string> s);
45: 
46: 	static SEXP REvalThrows(SEXP call, SEXP env = R_GlobalEnv);
47: 	static SEXP REvalRerror(SEXP call, SEXP env = R_GlobalEnv);
48: };
49: 
50: struct RProtector {
51: 	RProtector() : protect_count(0) {
52: 	}
53: 	~RProtector() {
54: 		if (protect_count > 0) {
55: 			UNPROTECT(protect_count);
56: 		}
57: 	}
58: 
59: 	SEXP Protect(SEXP sexp) {
60: 		protect_count++;
61: 		return PROTECT(sexp);
62: 	}
63: 
64: private:
65: 	int protect_count;
66: };
67: 
68: struct DataFrameScanFunction : public TableFunction {
69: 	DataFrameScanFunction();
70: };
71: 
72: struct RStrings {
73: 	SEXP secs;
74: 	SEXP mins;
75: 	SEXP hours;
76: 	SEXP days;
77: 	SEXP weeks;
78: 
79: 	static const RStrings &get() {
80: 		// On demand
81: 		static RStrings strings;
82: 		return strings;
83: 	}
84: 
85: private:
86: 	RStrings();
87: };
88: 
89: } // namespace duckdb
[end of tools/rpkg/src/include/rapi.hpp]
[start of tools/rpkg/src/include/typesr.hpp]
1: #pragma once
2: 
3: namespace duckdb {
4: 
5: struct DuckDBAltrepStringWrapper {
6: 	vector<Vector> vectors;
7: 	idx_t length;
8: };
9: 
10: enum class RType {
11: 	UNKNOWN,
12: 	LOGICAL,
13: 	INTEGER,
14: 	NUMERIC,
15: 	STRING,
16: 	FACTOR,
17: 	DATE,
18: 	TIMESTAMP,
19: 	TIME_SECONDS,
20: 	TIME_MINUTES,
21: 	TIME_HOURS,
22: 	TIME_DAYS,
23: 	TIME_WEEKS
24: };
25: 
26: struct RApiTypes {
27: 	static RType DetectRType(SEXP v);
28: 	static Value SexpToValue(SEXP valsexp);
29: 	static SEXP ValueToSexp(Value &val);
30: };
31: 
32: struct RIntegralType {
33: 	template <class T>
34: 	static double DoubleCast(T val) {
35: 		return double(val);
36: 	}
37: };
38: 
39: template <class T>
40: static void RDecimalCastLoop(Vector &src_vec, size_t count, double *dest_ptr, uint8_t scale) {
41: 	auto src_ptr = FlatVector::GetData<T>(src_vec);
42: 	auto &mask = FlatVector::Validity(src_vec);
43: 	double division = std::pow((uint64_t)10, (uint64_t)scale);
44: 	for (size_t row_idx = 0; row_idx < count; row_idx++) {
45: 		dest_ptr[row_idx] =
46: 		    !mask.RowIsValid(row_idx) ? NA_REAL : RIntegralType::DoubleCast<T>(src_ptr[row_idx]) / division;
47: 	}
48: }
49: 
50: template <>
51: double RIntegralType::DoubleCast<>(hugeint_t val);
52: 
53: struct RDoubleType {
54: 	static bool IsNull(double val);
55: 	static double Convert(double val);
56: };
57: 
58: struct RDateType : public RDoubleType {
59: 	static date_t Convert(double val);
60: };
61: 
62: struct RTimestampType : public RDoubleType {
63: 	static timestamp_t Convert(double val);
64: };
65: 
66: struct RTimeSecondsType : public RDoubleType {
67: 	static dtime_t Convert(double val);
68: };
69: 
70: struct RTimeMinutesType : public RDoubleType {
71: 	static dtime_t Convert(double val);
72: };
73: 
74: struct RTimeHoursType : public RDoubleType {
75: 	static dtime_t Convert(double val);
76: };
77: 
78: struct RTimeDaysType : public RDoubleType {
79: 	static dtime_t Convert(double val);
80: };
81: 
82: struct RTimeWeeksType : public RDoubleType {
83: 	static dtime_t Convert(double val);
84: };
85: 
86: struct RIntegerType {
87: 	static bool IsNull(int val);
88: 	static int Convert(int val);
89: };
90: 
91: struct RBooleanType : public RIntegerType {
92: 	static bool Convert(int val);
93: };
94: 
95: } // namespace duckdb
[end of tools/rpkg/src/include/typesr.hpp]
[start of tools/rpkg/src/rapi.cpp]
1: #include "rapi.hpp"
2: #include "altrepstring.hpp"
3: using namespace duckdb;
4: 
5: static const R_CallMethodDef R_CallDef[] = {{"duckdb_startup_R", (DL_FUNC)RApi::Startup, 3},
6:                                             {"duckdb_connect_R", (DL_FUNC)RApi::Connect, 1},
7:                                             {"duckdb_prepare_R", (DL_FUNC)RApi::Prepare, 2},
8:                                             {"duckdb_bind_R", (DL_FUNC)RApi::Bind, 2},
9:                                             {"duckdb_execute_R", (DL_FUNC)RApi::Execute, 2},
10:                                             {"duckdb_fetch_arrow_R", (DL_FUNC)RApi::DuckDBExecuteArrow, 4},
11:                                             {"duckdb_fetch_record_batch_R", (DL_FUNC)RApi::DuckDBRecordBatchR, 1},
12:                                             {"duckdb_release_R", (DL_FUNC)RApi::Release, 1},
13:                                             {"duckdb_register_R", (DL_FUNC)RApi::RegisterDataFrame, 3},
14:                                             {"duckdb_unregister_R", (DL_FUNC)RApi::UnregisterDataFrame, 2},
15:                                             {"duckdb_register_arrow_R", (DL_FUNC)RApi::RegisterArrow, 4},
16:                                             {"duckdb_unregister_arrow_R", (DL_FUNC)RApi::UnregisterArrow, 2},
17:                                             {"duckdb_disconnect_R", (DL_FUNC)RApi::Disconnect, 1},
18:                                             {"duckdb_shutdown_R", (DL_FUNC)RApi::Shutdown, 1},
19:                                             {"duckdb_ptr_to_str", (DL_FUNC)RApi::PointerToString, 1},
20:                                             {NULL, NULL, 0}};
21: 
22: extern "C" {
23: void R_init_duckdb(DllInfo *dll) {
24: 	R_registerRoutines(dll, NULL, R_CallDef, NULL, NULL);
25: 	R_useDynamicSymbols(dll, FALSE);
26: 
27: 	AltrepString::Initialize(dll);
28: 	// TODO implement SEXP (*R_altvec_Extract_subset_method_t)(SEXP, SEXP, SEXP);
29: }
30: } // extern "C"
[end of tools/rpkg/src/rapi.cpp]
[start of tools/rpkg/src/scan.cpp]
1: #include "rapi.hpp"
2: #include "typesr.hpp"
3: 
4: #include "duckdb/main/client_context.hpp"
5: 
6: using namespace duckdb;
7: 
8: template <class SRC, class DST, class RTYPE>
9: static void AppendColumnSegment(SRC *source_data, Vector &result, idx_t count) {
10: 	auto result_data = FlatVector::GetData<DST>(result);
11: 	auto &result_mask = FlatVector::Validity(result);
12: 	for (idx_t i = 0; i < count; i++) {
13: 		auto val = source_data[i];
14: 		if (RTYPE::IsNull(val)) {
15: 			result_mask.SetInvalid(i);
16: 		} else {
17: 			result_data[i] = RTYPE::Convert(val);
18: 		}
19: 	}
20: }
21: 
22: static void AppendStringSegment(SEXP coldata, Vector &result, idx_t row_idx, idx_t count) {
23: 	auto result_data = FlatVector::GetData<string_t>(result);
24: 	auto &result_mask = FlatVector::Validity(result);
25: 	for (idx_t i = 0; i < count; i++) {
26: 		SEXP val = STRING_ELT(coldata, row_idx + i);
27: 		if (val == NA_STRING) {
28: 			result_mask.SetInvalid(i);
29: 		} else {
30: 			result_data[i] = string_t((char *)CHAR(val));
31: 		}
32: 	}
33: }
34: 
35: static void AppendFactor(SEXP coldata, Vector &result, idx_t row_idx, idx_t count) {
36: 	auto source_data = INTEGER_POINTER(coldata) + row_idx;
37: 	auto result_data = FlatVector::GetData<string_t>(result);
38: 	auto &result_mask = FlatVector::Validity(result);
39: 	SEXP factor_levels = GET_LEVELS(coldata);
40: 	for (idx_t i = 0; i < count; i++) {
41: 		int val = source_data[i];
42: 		if (RIntegerType::IsNull(val)) {
43: 			result_mask.SetInvalid(i);
44: 		} else {
45: 			result_data[i] = string_t(CHAR(STRING_ELT(factor_levels, val - 1)));
46: 		}
47: 	}
48: }
49: 
50: struct DataFrameScanFunctionData : public TableFunctionData {
51: 	DataFrameScanFunctionData(SEXP df, idx_t row_count, vector<RType> rtypes)
52: 	    : df(df), row_count(row_count), rtypes(rtypes) {
53: 	}
54: 	SEXP df;
55: 	idx_t row_count;
56: 	vector<RType> rtypes;
57: };
58: 
59: struct DataFrameScanState : public FunctionOperatorData {
60: 	DataFrameScanState() : position(0) {
61: 	}
62: 
63: 	idx_t position;
64: };
65: 
66: static unique_ptr<FunctionData> dataframe_scan_bind(ClientContext &context, vector<Value> &inputs,
67:                                                     unordered_map<string, Value> &named_parameters,
68:                                                     vector<LogicalType> &input_table_types,
69:                                                     vector<string> &input_table_names,
70:                                                     vector<LogicalType> &return_types, vector<string> &names) {
71: 	RProtector r;
72: 	SEXP df((SEXP)inputs[0].GetPointer());
73: 
74: 	auto df_names = r.Protect(GET_NAMES(df));
75: 	vector<RType> rtypes;
76: 
77: 	for (idx_t col_idx = 0; col_idx < (idx_t)Rf_length(df); col_idx++) {
78: 		names.push_back(string(CHAR(STRING_ELT(df_names, col_idx))));
79: 		SEXP coldata = VECTOR_ELT(df, col_idx);
80: 		rtypes.push_back(RApiTypes::DetectRType(coldata));
81: 		LogicalType duckdb_col_type;
82: 		switch (rtypes[col_idx]) {
83: 		case RType::LOGICAL:
84: 			duckdb_col_type = LogicalType::BOOLEAN;
85: 			break;
86: 		case RType::INTEGER:
87: 			duckdb_col_type = LogicalType::INTEGER;
88: 			break;
89: 		case RType::NUMERIC:
90: 			duckdb_col_type = LogicalType::DOUBLE;
91: 			break;
92: 		case RType::FACTOR:
93: 		case RType::STRING:
94: 			duckdb_col_type = LogicalType::VARCHAR;
95: 			break;
96: 		case RType::TIMESTAMP:
97: 			duckdb_col_type = LogicalType::TIMESTAMP;
98: 			break;
99: 		case RType::TIME_SECONDS:
100: 		case RType::TIME_MINUTES:
101: 		case RType::TIME_HOURS:
102: 		case RType::TIME_DAYS:
103: 		case RType::TIME_WEEKS:
104: 			duckdb_col_type = LogicalType::TIME;
105: 			break;
106: 		case RType::DATE:
107: 			duckdb_col_type = LogicalType::DATE;
108: 			break;
109: 		default:
110: 			Rf_error("Unsupported column type for scan");
111: 		}
112: 		return_types.push_back(duckdb_col_type);
113: 	}
114: 
115: 	auto row_count = Rf_length(VECTOR_ELT(df, 0));
116: 	return make_unique<DataFrameScanFunctionData>(df, row_count, rtypes);
117: }
118: 
119: static unique_ptr<FunctionOperatorData> dataframe_scan_init(ClientContext &context, const FunctionData *bind_data,
120:                                                             const vector<column_t> &column_ids,
121:                                                             TableFilterCollection *filters) {
122: 	return make_unique<DataFrameScanState>();
123: }
124: 
125: static void dataframe_scan_function(ClientContext &context, const FunctionData *bind_data,
126:                                     FunctionOperatorData *operator_state, DataChunk *input, DataChunk &output) {
127: 	auto &data = (DataFrameScanFunctionData &)*bind_data;
128: 	auto &state = (DataFrameScanState &)*operator_state;
129: 	if (state.position >= data.row_count) {
130: 		return;
131: 	}
132: 	idx_t this_count = std::min((idx_t)STANDARD_VECTOR_SIZE, data.row_count - state.position);
133: 
134: 	output.SetCardinality(this_count);
135: 
136: 	// TODO this is quite similar to append, unify!
137: 	for (idx_t col_idx = 0; col_idx < output.ColumnCount(); col_idx++) {
138: 		auto &v = output.data[col_idx];
139: 		SEXP coldata = VECTOR_ELT(data.df, col_idx);
140: 
141: 		switch (data.rtypes[col_idx]) {
142: 		case RType::LOGICAL: {
143: 			auto data_ptr = INTEGER_POINTER(coldata) + state.position;
144: 			AppendColumnSegment<int, bool, RBooleanType>(data_ptr, v, this_count);
145: 			break;
146: 		}
147: 		case RType::INTEGER: {
148: 			auto data_ptr = INTEGER_POINTER(coldata) + state.position;
149: 			AppendColumnSegment<int, int, RIntegerType>(data_ptr, v, this_count);
150: 			break;
151: 		}
152: 		case RType::NUMERIC: {
153: 			auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
154: 			AppendColumnSegment<double, double, RDoubleType>(data_ptr, v, this_count);
155: 			break;
156: 		}
157: 		case RType::STRING:
158: 			AppendStringSegment(coldata, v, state.position, this_count);
159: 			break;
160: 		case RType::FACTOR:
161: 			AppendFactor(coldata, v, state.position, this_count);
162: 			break;
163: 		case RType::TIMESTAMP: {
164: 			auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
165: 			AppendColumnSegment<double, timestamp_t, RTimestampType>(data_ptr, v, this_count);
166: 			break;
167: 		}
168: 		case RType::TIME_SECONDS: {
169: 			auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
170: 			AppendColumnSegment<double, dtime_t, RTimeSecondsType>(data_ptr, v, this_count);
171: 			break;
172: 		}
173: 		case RType::TIME_MINUTES: {
174: 			auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
175: 			AppendColumnSegment<double, dtime_t, RTimeMinutesType>(data_ptr, v, this_count);
176: 			break;
177: 		}
178: 		case RType::TIME_HOURS: {
179: 			auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
180: 			AppendColumnSegment<double, dtime_t, RTimeHoursType>(data_ptr, v, this_count);
181: 			break;
182: 		}
183: 		case RType::TIME_DAYS: {
184: 			auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
185: 			AppendColumnSegment<double, dtime_t, RTimeDaysType>(data_ptr, v, this_count);
186: 			break;
187: 		}
188: 		case RType::TIME_WEEKS: {
189: 			auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
190: 			AppendColumnSegment<double, dtime_t, RTimeWeeksType>(data_ptr, v, this_count);
191: 			break;
192: 		}
193: 		case RType::DATE: {
194: 			auto data_ptr = NUMERIC_POINTER(coldata) + state.position;
195: 			AppendColumnSegment<double, date_t, RDateType>(data_ptr, v, this_count);
196: 			break;
197: 		}
198: 		default:
199: 			throw;
200: 		}
201: 	}
202: 
203: 	state.position += this_count;
204: }
205: 
206: static unique_ptr<NodeStatistics> dataframe_scan_cardinality(ClientContext &context, const FunctionData *bind_data) {
207: 	auto &data = (DataFrameScanFunctionData &)*bind_data;
208: 	return make_unique<NodeStatistics>(data.row_count, data.row_count);
209: }
210: 
211: DataFrameScanFunction::DataFrameScanFunction()
212:     : TableFunction("r_dataframe_scan", {LogicalType::POINTER}, dataframe_scan_function, dataframe_scan_bind,
213:                     dataframe_scan_init, nullptr, nullptr, nullptr, dataframe_scan_cardinality) {};
[end of tools/rpkg/src/scan.cpp]
[start of tools/rpkg/src/statement.cpp]
1: #include "altrepstring.hpp"
2: #include "duckdb/common/arrow.hpp"
3: #include "duckdb/common/types/timestamp.hpp"
4: #include "rapi.hpp"
5: #include "typesr.hpp"
6: #include "duckdb/common/arrow_wrapper.hpp"
7: 
8: using namespace duckdb;
9: 
10: // converter for primitive types
11: template <class SRC, class DEST>
12: static void VectorToR(Vector &src_vec, size_t count, void *dest, uint64_t dest_offset, DEST na_val) {
13: 	auto src_ptr = FlatVector::GetData<SRC>(src_vec);
14: 	auto &mask = FlatVector::Validity(src_vec);
15: 	auto dest_ptr = ((DEST *)dest) + dest_offset;
16: 	for (size_t row_idx = 0; row_idx < count; row_idx++) {
17: 		dest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? na_val : src_ptr[row_idx];
18: 	}
19: }
20: 
21: struct RStatement {
22: 	unique_ptr<PreparedStatement> stmt;
23: 	vector<Value> parameters;
24: };
25: 
26: SEXP RApi::Release(SEXP stmtsexp) {
27: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
28: 		Rf_error("duckdb_release_R: Need external pointer parameter");
29: 	}
30: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
31: 	if (stmtsexp) {
32: 		R_ClearExternalPtr(stmtsexp);
33: 		delete stmtholder;
34: 	}
35: 	return R_NilValue;
36: }
37: 
38: static SEXP duckdb_finalize_statement_R(SEXP stmtsexp) {
39: 	return RApi::Release(stmtsexp);
40: }
41: 
42: SEXP RApi::Prepare(SEXP connsexp, SEXP querysexp) {
43: 	RProtector r;
44: 	if (TYPEOF(querysexp) != STRSXP || Rf_length(querysexp) != 1) {
45: 		Rf_error("duckdb_prepare_R: Need single string parameter for query");
46: 	}
47: 	if (TYPEOF(connsexp) != EXTPTRSXP) {
48: 		Rf_error("duckdb_prepare_R: Need external pointer parameter for connections");
49: 	}
50: 
51: 	char *query = (char *)CHAR(STRING_ELT(querysexp, 0));
52: 	if (!query) {
53: 		Rf_error("duckdb_prepare_R: No query");
54: 	}
55: 
56: 	Connection *conn = (Connection *)R_ExternalPtrAddr(connsexp);
57: 	if (!conn) {
58: 		Rf_error("duckdb_prepare_R: Invalid connection");
59: 	}
60: 
61: 	auto stmt = conn->Prepare(query);
62: 	if (!stmt->success) {
63: 		Rf_error("duckdb_prepare_R: Failed to prepare query %s\nError: %s", query, stmt->error.c_str());
64: 	}
65: 
66: 	auto stmtholder = new RStatement();
67: 	stmtholder->stmt = move(stmt);
68: 
69: 	SEXP retlist = r.Protect(NEW_LIST(6));
70: 
71: 	SEXP stmtsexp = r.Protect(R_MakeExternalPtr(stmtholder, R_NilValue, R_NilValue));
72: 	R_RegisterCFinalizer(stmtsexp, (void (*)(SEXP))duckdb_finalize_statement_R);
73: 
74: 	SEXP ret_names = RApi::StringsToSexp({"str", "ref", "type", "names", "rtypes", "n_param"});
75: 	SET_NAMES(retlist, ret_names);
76: 
77: 	SET_VECTOR_ELT(retlist, 0, querysexp);
78: 	SET_VECTOR_ELT(retlist, 1, stmtsexp);
79: 
80: 	SEXP stmt_type = RApi::StringsToSexp({StatementTypeToString(stmtholder->stmt->GetStatementType())});
81: 	SET_VECTOR_ELT(retlist, 2, stmt_type);
82: 
83: 	SEXP col_names = RApi::StringsToSexp(stmtholder->stmt->GetNames());
84: 	SET_VECTOR_ELT(retlist, 3, col_names);
85: 
86: 	vector<string> rtypes;
87: 
88: 	for (auto &stype : stmtholder->stmt->GetTypes()) {
89: 		string rtype = "";
90: 		switch (stype.id()) {
91: 		case LogicalTypeId::BOOLEAN:
92: 			rtype = "logical";
93: 			break;
94: 		case LogicalTypeId::UTINYINT:
95: 		case LogicalTypeId::TINYINT:
96: 		case LogicalTypeId::USMALLINT:
97: 		case LogicalTypeId::SMALLINT:
98: 		case LogicalTypeId::INTEGER:
99: 			rtype = "integer";
100: 			break;
101: 		case LogicalTypeId::TIMESTAMP:
102: 			rtype = "POSIXct";
103: 			break;
104: 		case LogicalTypeId::DATE:
105: 			rtype = "Date";
106: 			break;
107: 		case LogicalTypeId::TIME:
108: 			rtype = "difftime";
109: 			break;
110: 		case LogicalTypeId::UINTEGER:
111: 		case LogicalTypeId::UBIGINT:
112: 		case LogicalTypeId::BIGINT:
113: 		case LogicalTypeId::HUGEINT:
114: 		case LogicalTypeId::FLOAT:
115: 		case LogicalTypeId::DOUBLE:
116: 		case LogicalTypeId::DECIMAL:
117: 			rtype = "numeric";
118: 			break;
119: 		case LogicalTypeId::VARCHAR:
120: 			rtype = "character";
121: 			break;
122: 		case LogicalTypeId::BLOB:
123: 			rtype = "raw";
124: 			break;
125: 		default:
126: 			Rf_error("duckdb_prepare_R: Unknown column type for prepare: %s", stype.ToString().c_str());
127: 			break;
128: 		}
129: 		rtypes.push_back(rtype);
130: 	}
131: 
132: 	SEXP rtypessexp = StringsToSexp(rtypes);
133: 	SET_VECTOR_ELT(retlist, 4, rtypessexp);
134: 
135: 	SET_VECTOR_ELT(retlist, 5, Rf_ScalarInteger(stmtholder->stmt->n_param));
136: 
137: 	return retlist;
138: }
139: 
140: SEXP RApi::Bind(SEXP stmtsexp, SEXP paramsexp) {
141: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
142: 		Rf_error("duckdb_bind_R: Need external pointer parameter");
143: 	}
144: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
145: 	if (!stmtholder || !stmtholder->stmt) {
146: 		Rf_error("duckdb_bind_R: Invalid statement");
147: 	}
148: 
149: 	stmtholder->parameters.clear();
150: 	stmtholder->parameters.resize(stmtholder->stmt->n_param);
151: 
152: 	if (stmtholder->stmt->n_param == 0) {
153: 		Rf_error("duckdb_bind_R: dbBind called but query takes no parameters");
154: 		return R_NilValue;
155: 	}
156: 
157: 	if (TYPEOF(paramsexp) != VECSXP || (idx_t)Rf_length(paramsexp) != stmtholder->stmt->n_param) {
158: 		Rf_error("duckdb_bind_R: bind parameters need to be a list of length %i", stmtholder->stmt->n_param);
159: 	}
160: 
161: 	for (idx_t param_idx = 0; param_idx < (idx_t)Rf_length(paramsexp); param_idx++) {
162: 		SEXP valsexp = VECTOR_ELT(paramsexp, param_idx);
163: 		if (Rf_length(valsexp) != 1) {
164: 			Rf_error("duckdb_bind_R: bind parameter values need to have length 1");
165: 		}
166: 		auto val = RApiTypes::SexpToValue(valsexp);
167: 		stmtholder->parameters[param_idx] = val;
168: 	}
169: 	return R_NilValue;
170: }
171: 
172: static SEXP duckdb_execute_R_impl(MaterializedQueryResult *result) {
173: 	RProtector r;
174: 	// step 2: create result data frame and allocate columns
175: 	uint32_t ncols = result->types.size();
176: 	if (ncols == 0) {
177: 		return Rf_ScalarReal(0); // no need for protection because no allocation can happen afterwards
178: 	}
179: 
180: 	uint64_t nrows = result->collection.Count();
181: 	SEXP retlist = r.Protect(NEW_LIST(ncols));
182: 	SET_NAMES(retlist, RApi::StringsToSexp(result->names));
183: 
184: 	for (size_t col_idx = 0; col_idx < ncols; col_idx++) {
185: 		RProtector r_varvalue;
186: 
187: 		SEXP varvalue = NULL;
188: 		switch (result->types[col_idx].id()) {
189: 		case LogicalTypeId::BOOLEAN:
190: 			varvalue = r_varvalue.Protect(NEW_LOGICAL(nrows));
191: 			break;
192: 		case LogicalTypeId::UTINYINT:
193: 		case LogicalTypeId::TINYINT:
194: 		case LogicalTypeId::SMALLINT:
195: 		case LogicalTypeId::USMALLINT:
196: 		case LogicalTypeId::INTEGER:
197: 			varvalue = r_varvalue.Protect(NEW_INTEGER(nrows));
198: 			break;
199: 		case LogicalTypeId::UINTEGER:
200: 		case LogicalTypeId::UBIGINT:
201: 		case LogicalTypeId::BIGINT:
202: 		case LogicalTypeId::HUGEINT:
203: 		case LogicalTypeId::FLOAT:
204: 		case LogicalTypeId::DOUBLE:
205: 		case LogicalTypeId::DECIMAL:
206: 		case LogicalTypeId::TIMESTAMP:
207: 		case LogicalTypeId::DATE:
208: 		case LogicalTypeId::TIME:
209: 			varvalue = r_varvalue.Protect(NEW_NUMERIC(nrows));
210: 			break;
211: 		case LogicalTypeId::VARCHAR: {
212: 			auto wrapper = new DuckDBAltrepStringWrapper();
213: 			wrapper->length = nrows;
214: 			for (idx_t c_idx = 0; c_idx < result->collection.Chunks().size(); c_idx++) {
215: 				wrapper->vectors.emplace_back(LogicalType::VARCHAR, nullptr);
216: 			}
217: 
218: 			auto ptr = PROTECT(R_MakeExternalPtr((void *)wrapper, R_NilValue, R_NilValue));
219: 			R_RegisterCFinalizer(ptr, AltrepString::Finalize);
220: 			varvalue = r_varvalue.Protect(R_new_altrep(AltrepString::rclass, ptr, R_NilValue));
221: 			UNPROTECT(1);
222: 			break;
223: 		}
224: 
225: 		case LogicalTypeId::BLOB:
226: 			varvalue = r_varvalue.Protect(NEW_LIST(nrows));
227: 			break;
228: 		default:
229: 			Rf_error("duckdb_execute_R: Unknown column type for execute: %s",
230: 			         result->types[col_idx].ToString().c_str());
231: 		}
232: 		if (!varvalue) {
233: 			throw std::bad_alloc();
234: 		}
235: 		SET_VECTOR_ELT(retlist, col_idx, varvalue);
236: 	}
237: 
238: 	// at this point retlist is fully allocated and the only protected SEXP
239: 
240: 	// step 3: set values from chunks
241: 	uint64_t dest_offset = 0;
242: 	idx_t chunk_idx = 0;
243: 	while (true) {
244: 		auto chunk = result->Fetch();
245: 		if (!chunk || chunk->size() == 0) {
246: 			break;
247: 		}
248: 
249: 		D_ASSERT(chunk->ColumnCount() == ncols);
250: 		D_ASSERT(chunk->ColumnCount() == (idx_t)Rf_length(retlist));
251: 		for (size_t col_idx = 0; col_idx < chunk->ColumnCount(); col_idx++) {
252: 			SEXP dest = VECTOR_ELT(retlist, col_idx);
253: 			switch (result->types[col_idx].id()) {
254: 			case LogicalTypeId::BOOLEAN:
255: 				VectorToR<int8_t, uint32_t>(chunk->data[col_idx], chunk->size(), LOGICAL_POINTER(dest), dest_offset,
256: 				                            NA_LOGICAL);
257: 				break;
258: 			case LogicalTypeId::UTINYINT:
259: 				VectorToR<uint8_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest), dest_offset,
260: 				                             NA_INTEGER);
261: 				break;
262: 			case LogicalTypeId::TINYINT:
263: 				VectorToR<int8_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest), dest_offset,
264: 				                            NA_INTEGER);
265: 				break;
266: 			case LogicalTypeId::USMALLINT:
267: 				VectorToR<uint16_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest), dest_offset,
268: 				                              NA_INTEGER);
269: 				break;
270: 			case LogicalTypeId::SMALLINT:
271: 				VectorToR<int16_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest), dest_offset,
272: 				                             NA_INTEGER);
273: 				break;
274: 			case LogicalTypeId::INTEGER:
275: 				VectorToR<int32_t, uint32_t>(chunk->data[col_idx], chunk->size(), INTEGER_POINTER(dest), dest_offset,
276: 				                             NA_INTEGER);
277: 				break;
278: 			case LogicalTypeId::TIMESTAMP: {
279: 				auto &src_vec = chunk->data[col_idx];
280: 				auto src_data = FlatVector::GetData<timestamp_t>(src_vec);
281: 				auto &mask = FlatVector::Validity(src_vec);
282: 				double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
283: 				for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
284: 					dest_ptr[row_idx] =
285: 					    !mask.RowIsValid(row_idx) ? NA_REAL : (double)Timestamp::GetEpochSeconds(src_data[row_idx]);
286: 				}
287: 
288: 				// some dresssup for R
289: 				RProtector r_ts;
290: 				SEXP cl = r_ts.Protect(NEW_STRING(2));
291: 				SET_STRING_ELT(cl, 0, r_ts.Protect(Rf_mkChar("POSIXct")));
292: 				SET_STRING_ELT(cl, 1, r_ts.Protect(Rf_mkChar("POSIXt")));
293: 				SET_CLASS(dest, cl);
294: 				Rf_setAttrib(dest, Rf_install("tzone"), r_ts.Protect(Rf_mkString("UTC")));
295: 				break;
296: 			}
297: 			case LogicalTypeId::DATE: {
298: 				auto &src_vec = chunk->data[col_idx];
299: 				auto src_data = FlatVector::GetData<date_t>(src_vec);
300: 				auto &mask = FlatVector::Validity(src_vec);
301: 				double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
302: 				for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
303: 					dest_ptr[row_idx] = !mask.RowIsValid(row_idx) ? NA_REAL : (double)int32_t(src_data[row_idx]);
304: 				}
305: 
306: 				// some dresssup for R
307: 				RProtector r_date;
308: 				SET_CLASS(dest, r_date.Protect(Rf_mkString("Date")));
309: 				break;
310: 			}
311: 			case LogicalTypeId::TIME: {
312: 				auto &src_vec = chunk->data[col_idx];
313: 				auto src_data = FlatVector::GetData<dtime_t>(src_vec);
314: 				auto &mask = FlatVector::Validity(src_vec);
315: 				double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
316: 				for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
317: 					if (!mask.RowIsValid(row_idx)) {
318: 						dest_ptr[row_idx] = NA_REAL;
319: 					} else {
320: 						dtime_t n = src_data[row_idx];
321: 						dest_ptr[row_idx] = n.micros / 1000000.0;
322: 					}
323: 				}
324: 
325: 				// some dresssup for R
326: 				RProtector r_time;
327: 				SET_CLASS(dest, r_time.Protect(Rf_mkString("difftime")));
328: 				Rf_setAttrib(dest, Rf_install("units"), r_time.Protect(Rf_mkString("secs")));
329: 				break;
330: 			}
331: 			case LogicalTypeId::UINTEGER:
332: 				VectorToR<uint32_t, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
333: 				                            NA_REAL);
334: 				break;
335: 			case LogicalTypeId::UBIGINT:
336: 				VectorToR<uint64_t, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
337: 				                            NA_REAL);
338: 				break;
339: 			case LogicalTypeId::BIGINT:
340: 				VectorToR<int64_t, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
341: 				                           NA_REAL);
342: 				break;
343: 			case LogicalTypeId::HUGEINT: {
344: 				auto &src_vec = chunk->data[col_idx];
345: 				auto src_data = FlatVector::GetData<hugeint_t>(src_vec);
346: 				auto &mask = FlatVector::Validity(src_vec);
347: 				double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
348: 				for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
349: 					if (!mask.RowIsValid(row_idx)) {
350: 						dest_ptr[row_idx] = NA_REAL;
351: 					} else {
352: 						Hugeint::TryCast(src_data[row_idx], dest_ptr[row_idx]);
353: 					}
354: 				}
355: 				break;
356: 			}
357: 			case LogicalTypeId::DECIMAL: {
358: 				auto &src_vec = chunk->data[col_idx];
359: 				auto &decimal_type = result->types[col_idx];
360: 				double *dest_ptr = ((double *)NUMERIC_POINTER(dest)) + dest_offset;
361: 				auto dec_scale = DecimalType::GetScale(decimal_type);
362: 				switch (decimal_type.InternalType()) {
363: 				case PhysicalType::INT16:
364: 					RDecimalCastLoop<int16_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
365: 					break;
366: 				case PhysicalType::INT32:
367: 					RDecimalCastLoop<int32_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
368: 					break;
369: 				case PhysicalType::INT64:
370: 					RDecimalCastLoop<int64_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
371: 					break;
372: 				case PhysicalType::INT128:
373: 					RDecimalCastLoop<hugeint_t>(src_vec, chunk->size(), dest_ptr, dec_scale);
374: 					break;
375: 				default:
376: 					throw NotImplementedException("Unimplemented internal type for DECIMAL");
377: 				}
378: 				break;
379: 			}
380: 			case LogicalTypeId::FLOAT:
381: 				VectorToR<float, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
382: 				                         NA_REAL);
383: 				break;
384: 
385: 			case LogicalTypeId::DOUBLE:
386: 				VectorToR<double, double>(chunk->data[col_idx], chunk->size(), NUMERIC_POINTER(dest), dest_offset,
387: 				                          NA_REAL);
388: 				break;
389: 			case LogicalTypeId::VARCHAR: {
390: 				auto wrapper = (DuckDBAltrepStringWrapper *)R_ExternalPtrAddr(R_altrep_data1(dest));
391: 				wrapper->vectors[chunk_idx].Reference(chunk->data[col_idx]);
392: 				break;
393: 			}
394: 			case LogicalTypeId::BLOB: {
395: 				auto src_ptr = FlatVector::GetData<string_t>(chunk->data[col_idx]);
396: 				auto &mask = FlatVector::Validity(chunk->data[col_idx]);
397: 				for (size_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
398: 					if (!mask.RowIsValid(row_idx)) {
399: 						SET_VECTOR_ELT(dest, dest_offset + row_idx, Rf_ScalarLogical(NA_LOGICAL));
400: 					} else {
401: 						SEXP rawval = NEW_RAW(src_ptr[row_idx].GetSize());
402: 						if (!rawval) {
403: 							throw std::bad_alloc();
404: 						}
405: 						memcpy(RAW_POINTER(rawval), src_ptr[row_idx].GetDataUnsafe(), src_ptr[row_idx].GetSize());
406: 						SET_VECTOR_ELT(dest, dest_offset + row_idx, rawval);
407: 					}
408: 				}
409: 				break;
410: 			}
411: 			default:
412: 				Rf_error("duckdb_execute_R: Unknown column type for convert: %s",
413: 				         chunk->GetTypes()[col_idx].ToString().c_str());
414: 				break;
415: 			}
416: 		}
417: 		dest_offset += chunk->size();
418: 		chunk_idx++;
419: 	}
420: 
421: 	D_ASSERT(dest_offset == nrows);
422: 	return retlist;
423: }
424: 
425: struct AppendableRList {
426: 	AppendableRList() {
427: 		the_list = r.Protect(NEW_LIST(capacity));
428: 	}
429: 	void PrepAppend() {
430: 		if (size >= capacity) {
431: 			capacity = capacity * 2;
432: 			SEXP new_list = r.Protect(NEW_LIST(capacity));
433: 			D_ASSERT(new_list);
434: 			for (idx_t i = 0; i < size; i++) {
435: 				SET_VECTOR_ELT(new_list, i, VECTOR_ELT(the_list, i));
436: 			}
437: 			the_list = new_list;
438: 		}
439: 	}
440: 
441: 	void Append(SEXP val) {
442: 		D_ASSERT(size < capacity);
443: 		D_ASSERT(the_list != R_NilValue);
444: 		SET_VECTOR_ELT(the_list, size++, val);
445: 	}
446: 	SEXP the_list;
447: 	idx_t capacity = 1000;
448: 	idx_t size = 0;
449: 	RProtector r;
450: };
451: 
452: struct RQueryResult {
453: 	unique_ptr<QueryResult> result;
454: };
455: 
456: bool FetchArrowChunk(QueryResult *result, AppendableRList &batches_list, ArrowArray &arrow_data,
457:                      ArrowSchema &arrow_schema, SEXP &batch_import_from_c, SEXP &arrow_namespace) {
458: 	if (result->type == QueryResultType::STREAM_RESULT) {
459: 		auto stream_result = (StreamQueryResult *)result;
460: 		if (!stream_result->is_open) {
461: 			return false;
462: 		}
463: 	}
464: 	unique_ptr<DataChunk> data_chunk = result->Fetch();
465: 	if (!data_chunk || data_chunk->size() == 0) {
466: 		return false;
467: 	}
468: 	result->ToArrowSchema(&arrow_schema);
469: 	data_chunk->ToArrowArray(&arrow_data);
470: 	batches_list.PrepAppend();
471: 	batches_list.Append(RApi::REvalRerror(batch_import_from_c, arrow_namespace));
472: 	return true;
473: }
474: 
475: // Turn a DuckDB result set into an Arrow Table
476: SEXP RApi::DuckDBExecuteArrow(SEXP query_resultsexp, SEXP streamsexp, SEXP vector_per_chunksexp,
477:                               SEXP return_tablesexp) {
478: 	RProtector r;
479: 	RQueryResult *query_result_holder = (RQueryResult *)R_ExternalPtrAddr(query_resultsexp);
480: 	auto result = query_result_holder->result.get();
481: 	// somewhat dark magic below
482: 	SEXP arrow_name_sexp = r.Protect(RApi::StringsToSexp({"arrow"}));
483: 	SEXP arrow_namespace_call = r.Protect(Rf_lang2(Rf_install("getNamespace"), arrow_name_sexp));
484: 	SEXP arrow_namespace = r.Protect(RApi::REvalRerror(arrow_namespace_call, R_GlobalEnv));
485: 	bool stream = LOGICAL_POINTER(streamsexp)[0] != 0;
486: 	int num_of_vectors = NUMERIC_POINTER(vector_per_chunksexp)[0];
487: 	bool return_table = LOGICAL_POINTER(return_tablesexp)[0] != 0;
488: 	if (TYPEOF(streamsexp) != LGLSXP || LENGTH(streamsexp) != 1) {
489: 		Rf_error("stream parameter needs to be single-value logical");
490: 	}
491: 	if (TYPEOF(return_tablesexp) != LGLSXP || LENGTH(return_tablesexp) != 1) {
492: 		Rf_error("return_table parameter needs to be single-value logical");
493: 	}
494: 	if (TYPEOF(vector_per_chunksexp) != REALSXP || LENGTH(vector_per_chunksexp) != 1) {
495: 		Rf_error("vector_per_chunks parameter needs to be single-value numeric");
496: 	}
497: 	// export schema setup
498: 	ArrowSchema arrow_schema;
499: 	auto schema_ptr_sexp = r.Protect(Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&arrow_schema))));
500: 	auto schema_import_from_c = r.Protect(Rf_lang2(Rf_install("ImportSchema"), schema_ptr_sexp));
501: 
502: 	// export data setup
503: 	ArrowArray arrow_data;
504: 	auto data_ptr_sexp = r.Protect(Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&arrow_data))));
505: 	auto batch_import_from_c = r.Protect(Rf_lang3(Rf_install("ImportRecordBatch"), data_ptr_sexp, schema_ptr_sexp));
506: 	// create data batches
507: 	AppendableRList batches_list;
508: 	if (stream) {
509: 		for (idx_t i = 0; i < num_of_vectors; i++) {
510: 			if (!FetchArrowChunk(result, batches_list, arrow_data, arrow_schema, batch_import_from_c,
511: 			                     arrow_namespace)) {
512: 				break;
513: 			}
514: 		}
515: 	} else {
516: 		while (FetchArrowChunk(result, batches_list, arrow_data, arrow_schema, batch_import_from_c, arrow_namespace)) {
517: 		}
518: 	}
519: 
520: 	SET_LENGTH(batches_list.the_list, batches_list.size);
521: 
522: 	result->ToArrowSchema(&arrow_schema);
523: 	SEXP schema_arrow_obj = r.Protect(RApi::REvalRerror(schema_import_from_c, arrow_namespace));
524: 
525: 	// create arrow::Table
526: 	if (return_table) {
527: 		auto from_record_batches =
528: 		    r.Protect(Rf_lang3(Rf_install("Table__from_record_batches"), batches_list.the_list, schema_arrow_obj));
529: 		return RApi::REvalRerror(from_record_batches, arrow_namespace);
530: 	}
531: 	return batches_list.the_list;
532: }
533: 
534: // Turn a DuckDB result set into an RecordBatchReader
535: SEXP RApi::DuckDBRecordBatchR(SEXP query_resultsexp) {
536: 	RProtector r;
537: 	RQueryResult *query_result_holder = (RQueryResult *)R_ExternalPtrAddr(query_resultsexp);
538: 	// somewhat dark magic below
539: 	SEXP arrow_name_sexp = r.Protect(RApi::StringsToSexp({"arrow"}));
540: 	SEXP arrow_namespace_call = r.Protect(Rf_lang2(Rf_install("getNamespace"), arrow_name_sexp));
541: 	SEXP arrow_namespace = r.Protect(RApi::REvalRerror(arrow_namespace_call, R_GlobalEnv));
542: 
543: 	ResultArrowArrayStreamWrapper *result_stream = new ResultArrowArrayStreamWrapper(move(query_result_holder->result));
544: 	auto stream_ptr_sexp =
545: 	    r.Protect(Rf_ScalarReal(static_cast<double>(reinterpret_cast<uintptr_t>(&result_stream->stream))));
546: 	auto record_batch_reader = r.Protect(Rf_lang2(Rf_install("ImportRecordBatchReader"), stream_ptr_sexp));
547: 	return RApi::REvalRerror(record_batch_reader, arrow_namespace);
548: }
549: 
550: static SEXP DuckDBFinalizeQueryR(SEXP query_resultsexp) {
551: 	RQueryResult *query_result_holder = (RQueryResult *)R_ExternalPtrAddr(query_resultsexp);
552: 	if (query_resultsexp) {
553: 		R_ClearExternalPtr(query_resultsexp);
554: 		delete query_result_holder;
555: 	}
556: 	return R_NilValue;
557: }
558: 
559: SEXP RApi::Execute(SEXP stmtsexp, SEXP arrowsexp) {
560: 	if (TYPEOF(stmtsexp) != EXTPTRSXP) {
561: 		Rf_error("duckdb_execute_R: Need external pointer for first parameter");
562: 	}
563: 	if (TYPEOF(arrowsexp) != LGLSXP) {
564: 		Rf_error("duckdb_execute_R: Need logical for second parameter");
565: 	}
566: 	RStatement *stmtholder = (RStatement *)R_ExternalPtrAddr(stmtsexp);
567: 	if (!stmtholder || !stmtholder->stmt) {
568: 		Rf_error("duckdb_execute_R: Invalid statement");
569: 	}
570: 
571: 	bool arrow_fetch = LOGICAL_POINTER(arrowsexp)[0] != 0;
572: 	auto generic_result = stmtholder->stmt->Execute(stmtholder->parameters, arrow_fetch);
573: 	if (!generic_result->success) {
574: 		Rf_error("duckdb_execute_R: Failed to run query\nError: %s", generic_result->error.c_str());
575: 	}
576: 
577: 	if (arrow_fetch) {
578: 		RProtector r;
579: 		auto query_result = new RQueryResult();
580: 		query_result->result = move(generic_result);
581: 		SEXP query_resultexp = r.Protect(R_MakeExternalPtr(query_result, R_NilValue, R_NilValue));
582: 		R_RegisterCFinalizer(query_resultexp, (void (*)(SEXP))DuckDBFinalizeQueryR);
583: 		return query_resultexp;
584: 	} else {
585: 		D_ASSERT(generic_result->type == QueryResultType::MATERIALIZED_RESULT);
586: 		MaterializedQueryResult *result = (MaterializedQueryResult *)generic_result.get();
587: 		return duckdb_execute_R_impl(result);
588: 	}
589: }
[end of tools/rpkg/src/statement.cpp]
[start of tools/rpkg/src/types.cpp]
1: #include "rapi.hpp"
2: #include "typesr.hpp"
3: 
4: #include "duckdb/common/types/date.hpp"
5: #include "duckdb/common/types/hugeint.hpp"
6: #include "duckdb/common/types/interval.hpp"
7: #include "duckdb/common/types/timestamp.hpp"
8: 
9: using namespace duckdb;
10: 
11: RType RApiTypes::DetectRType(SEXP v) {
12: 	if (TYPEOF(v) == REALSXP && Rf_inherits(v, "POSIXct")) {
13: 		return RType::TIMESTAMP;
14: 	} else if (TYPEOF(v) == REALSXP && Rf_inherits(v, "Date")) {
15: 		return RType::DATE;
16: 	} else if (TYPEOF(v) == REALSXP && Rf_inherits(v, "difftime")) {
17: 		SEXP units = Rf_getAttrib(v, Rf_install("units"));
18: 		if (TYPEOF(units) != STRSXP) {
19: 			return RType::UNKNOWN;
20: 		}
21: 		SEXP units0 = STRING_ELT(units, 0);
22: 		if (units0 == RStrings::get().secs) {
23: 			return RType::TIME_SECONDS;
24: 		} else if (units0 == RStrings::get().mins) {
25: 			return RType::TIME_MINUTES;
26: 		} else if (units0 == RStrings::get().hours) {
27: 			return RType::TIME_HOURS;
28: 		} else if (units0 == RStrings::get().days) {
29: 			return RType::TIME_DAYS;
30: 		} else if (units0 == RStrings::get().weeks) {
31: 			return RType::TIME_WEEKS;
32: 		} else {
33: 			return RType::UNKNOWN;
34: 		}
35: 	} else if (Rf_isFactor(v) && TYPEOF(v) == INTSXP) {
36: 		return RType::FACTOR;
37: 	} else if (TYPEOF(v) == LGLSXP) {
38: 		return RType::LOGICAL;
39: 	} else if (TYPEOF(v) == INTSXP) {
40: 		return RType::INTEGER;
41: 	} else if (TYPEOF(v) == REALSXP) {
42: 		return RType::NUMERIC;
43: 	} else if (TYPEOF(v) == STRSXP) {
44: 		return RType::STRING;
45: 	}
46: 	return RType::UNKNOWN;
47: }
48: 
49: bool RDoubleType::IsNull(double val) {
50: 	return ISNA(val);
51: }
52: 
53: double RDoubleType::Convert(double val) {
54: 	return val;
55: }
56: 
57: date_t RDateType::Convert(double val) {
58: 	return date_t((int32_t)val);
59: }
60: 
61: timestamp_t RTimestampType::Convert(double val) {
62: 	return Timestamp::FromEpochSeconds(val);
63: }
64: 
65: dtime_t RTimeSecondsType::Convert(double val) {
66: 	return dtime_t(int64_t(val * Interval::MICROS_PER_SEC));
67: }
68: 
69: dtime_t RTimeMinutesType::Convert(double val) {
70: 	return dtime_t(int64_t(val * Interval::MICROS_PER_MINUTE));
71: }
72: 
73: dtime_t RTimeHoursType::Convert(double val) {
74: 	return dtime_t(int64_t(val * Interval::MICROS_PER_HOUR));
75: }
76: 
77: dtime_t RTimeDaysType::Convert(double val) {
78: 	return dtime_t(int64_t(val * Interval::MICROS_PER_DAY));
79: }
80: 
81: dtime_t RTimeWeeksType::Convert(double val) {
82: 	return dtime_t(int64_t(val * (Interval::MICROS_PER_DAY * Interval::DAYS_PER_WEEK)));
83: }
84: 
85: bool RIntegerType::IsNull(int val) {
86: 	return val == NA_INTEGER;
87: }
88: 
89: int RIntegerType::Convert(int val) {
90: 	return val;
91: }
92: 
93: bool RBooleanType::Convert(int val) {
94: 	return val;
95: }
96: 
97: template <>
98: double RIntegralType::DoubleCast<>(hugeint_t val) {
99: 	return Hugeint::Cast<double>(val);
100: }
[end of tools/rpkg/src/types.cpp]
[start of tools/rpkg/src/utils.cpp]
1: #include "rapi.hpp"
2: #include "typesr.hpp"
3: #include "duckdb/common/types/timestamp.hpp"
4: 
5: using namespace duckdb;
6: 
7: SEXP RApi::PointerToString(SEXP extptr) {
8: 	if (TYPEOF(extptr) != EXTPTRSXP) {
9: 		Rf_error("duckdb_ptr_to_str: Need external pointer parameter");
10: 	}
11: 	RProtector r;
12: 	SEXP ret = r.Protect(NEW_STRING(1));
13: 	SET_STRING_ELT(ret, 0, NA_STRING);
14: 	void *ptr = R_ExternalPtrAddr(extptr);
15: 	if (ptr != NULL) {
16: 		char buf[100];
17: 		snprintf(buf, 100, "%p", ptr);
18: 		SET_STRING_ELT(ret, 0, Rf_mkChar(buf));
19: 	}
20: 	return ret;
21: }
22: 
23: static SEXP cstr_to_charsexp(const char *s) {
24: 	return Rf_mkCharCE(s, CE_UTF8);
25: }
26: 
27: static SEXP cpp_str_to_charsexp(string s) {
28: 	return cstr_to_charsexp(s.c_str());
29: }
30: 
31: SEXP RApi::StringsToSexp(vector<string> s) {
32: 	RProtector r;
33: 	SEXP retsexp = r.Protect(NEW_STRING(s.size()));
34: 	for (idx_t i = 0; i < s.size(); i++) {
35: 		SET_STRING_ELT(retsexp, i, cpp_str_to_charsexp(s[i]));
36: 	}
37: 	return retsexp;
38: }
39: 
40: RStrings::RStrings() {
41: 	// allocate strings once
42: 	RProtector r;
43: 
44: 	SEXP out = r.Protect(Rf_allocVector(STRSXP, 5));
45: 	SET_STRING_ELT(out, 0, secs = Rf_mkChar("secs"));
46: 	SET_STRING_ELT(out, 1, mins = Rf_mkChar("mins"));
47: 	SET_STRING_ELT(out, 2, hours = Rf_mkChar("hours"));
48: 	SET_STRING_ELT(out, 3, days = Rf_mkChar("days"));
49: 	SET_STRING_ELT(out, 4, weeks = Rf_mkChar("weeks"));
50: 	R_PreserveObject(out);
51: 	MARK_NOT_MUTABLE(out);
52: }
53: 
54: template <class SRC, class DST, class RTYPE>
55: static void AppendColumnSegment(SRC *source_data, Vector &result, idx_t count) {
56: 	auto result_data = FlatVector::GetData<DST>(result);
57: 	auto &result_mask = FlatVector::Validity(result);
58: 	for (idx_t i = 0; i < count; i++) {
59: 		auto val = source_data[i];
60: 		if (RTYPE::IsNull(val)) {
61: 			result_mask.SetInvalid(i);
62: 		} else {
63: 			result_data[i] = RTYPE::Convert(val);
64: 		}
65: 	}
66: }
67: 
68: Value RApiTypes::SexpToValue(SEXP valsexp) {
69: 	Value val;
70: 	auto rtype = RApiTypes::DetectRType(valsexp);
71: 	switch (rtype) {
72: 	case RType::LOGICAL: {
73: 		auto lgl_val = INTEGER_POINTER(valsexp)[0];
74: 		val = Value::BOOLEAN(lgl_val);
75: 		val.is_null = RBooleanType::IsNull(lgl_val);
76: 		break;
77: 	}
78: 	case RType::INTEGER: {
79: 		auto int_val = INTEGER_POINTER(valsexp)[0];
80: 		val = Value::INTEGER(int_val);
81: 		val.is_null = RIntegerType::IsNull(int_val);
82: 		break;
83: 	}
84: 	case RType::NUMERIC: {
85: 		auto dbl_val = NUMERIC_POINTER(valsexp)[0];
86: 		val = Value::DOUBLE(dbl_val);
87: 		val.is_null = RDoubleType::IsNull(dbl_val);
88: 		break;
89: 	}
90: 	case RType::STRING: {
91: 		auto str_val = STRING_ELT(valsexp, 0);
92: 		val = Value(CHAR(str_val));
93: 		val.is_null = str_val == NA_STRING;
94: 		break;
95: 	}
96: 	case RType::FACTOR: {
97: 		auto int_val = INTEGER_POINTER(valsexp)[0];
98: 		auto levels = GET_LEVELS(valsexp);
99: 		bool is_null = RIntegerType::IsNull(int_val);
100: 		if (!is_null) {
101: 			auto str_val = STRING_ELT(levels, int_val - 1);
102: 			val = Value(CHAR(str_val));
103: 		} else {
104: 			val = Value(LogicalType::VARCHAR);
105: 		}
106: 		break;
107: 	}
108: 	case RType::TIMESTAMP: {
109: 		auto ts_val = NUMERIC_POINTER(valsexp)[0];
110: 		val = Value::TIMESTAMP(RTimestampType::Convert(ts_val));
111: 		val.is_null = RTimestampType::IsNull(ts_val);
112: 		break;
113: 	}
114: 	case RType::DATE: {
115: 		auto d_val = NUMERIC_POINTER(valsexp)[0];
116: 		val = Value::DATE(RDateType::Convert(d_val));
117: 		val.is_null = RDateType::IsNull(d_val);
118: 		break;
119: 	}
120: 	case RType::TIME_SECONDS: {
121: 		auto ts_val = NUMERIC_POINTER(valsexp)[0];
122: 		val = Value::TIME(RTimeSecondsType::Convert(ts_val));
123: 		val.is_null = RTimeSecondsType::IsNull(ts_val);
124: 		break;
125: 	}
126: 	case RType::TIME_MINUTES: {
127: 		auto ts_val = NUMERIC_POINTER(valsexp)[0];
128: 		val = Value::TIME(RTimeMinutesType::Convert(ts_val));
129: 		val.is_null = RTimeMinutesType::IsNull(ts_val);
130: 		break;
131: 	}
132: 	case RType::TIME_HOURS: {
133: 		auto ts_val = NUMERIC_POINTER(valsexp)[0];
134: 		val = Value::TIME(RTimeHoursType::Convert(ts_val));
135: 		val.is_null = RTimeHoursType::IsNull(ts_val);
136: 		break;
137: 	}
138: 	case RType::TIME_DAYS: {
139: 		auto ts_val = NUMERIC_POINTER(valsexp)[0];
140: 		val = Value::TIME(RTimeDaysType::Convert(ts_val));
141: 		val.is_null = RTimeDaysType::IsNull(ts_val);
142: 		break;
143: 	}
144: 	case RType::TIME_WEEKS: {
145: 		auto ts_val = NUMERIC_POINTER(valsexp)[0];
146: 		val = Value::TIME(RTimeWeeksType::Convert(ts_val));
147: 		val.is_null = RTimeWeeksType::IsNull(ts_val);
148: 		break;
149: 	}
150: 	default:
151: 		Rf_error("duckdb_sexp_to_value: Unsupported type");
152: 	}
153: 	return val;
154: }
155: 
156: SEXP RApiTypes::ValueToSexp(Value &val) {
157: 	if (val.is_null) {
158: 		return R_NilValue;
159: 	}
160: 	RProtector r;
161: 	SEXP res;
162: 	switch (val.type().id()) {
163: 	case LogicalTypeId::BOOLEAN:
164: 		res = r.Protect(NEW_LOGICAL(1));
165: 		LOGICAL_POINTER(res)[0] = val.GetValue<bool>();
166: 		return res;
167: 	case LogicalTypeId::TINYINT:
168: 	case LogicalTypeId::SMALLINT:
169: 	case LogicalTypeId::INTEGER:
170: 	case LogicalTypeId::UTINYINT:
171: 	case LogicalTypeId::USMALLINT:
172: 	case LogicalTypeId::UINTEGER:
173: 		res = r.Protect(NEW_INTEGER(1));
174: 		INTEGER_POINTER(res)[0] = val.GetValue<int32_t>();
175: 		return res;
176: 	case LogicalTypeId::BIGINT:
177: 	case LogicalTypeId::UBIGINT:
178: 	case LogicalTypeId::FLOAT:
179: 	case LogicalTypeId::DOUBLE:
180: 		res = r.Protect(NEW_NUMERIC(1));
181: 		NUMERIC_POINTER(res)[0] = val.GetValue<double>();
182: 		return res;
183: 	case LogicalTypeId::VARCHAR:
184: 		res = r.Protect(NEW_STRING(1));
185: 		SET_STRING_ELT(res, 0, cpp_str_to_charsexp(val.ToString()));
186: 		return res;
187: 	case LogicalTypeId::TIMESTAMP: {
188: 		// TODO bit of duplication here with statement.cpp, fix this
189: 		res = r.Protect(NEW_NUMERIC(1));
190: 		double *dest_ptr = ((double *)NUMERIC_POINTER(res));
191: 		dest_ptr[0] = (double)Timestamp::GetEpochSeconds(val.value_.timestamp);
192: 		// some dresssup for R
193: 		RProtector r_ts;
194: 		SEXP cl = r_ts.Protect(NEW_STRING(2));
195: 		SET_STRING_ELT(cl, 0, r_ts.Protect(Rf_mkChar("POSIXct")));
196: 		SET_STRING_ELT(cl, 1, r_ts.Protect(Rf_mkChar("POSIXt")));
197: 		SET_CLASS(res, cl);
198: 		Rf_setAttrib(res, Rf_install("tzone"), r_ts.Protect(Rf_mkString("UTC")));
199: 		return res;
200: 	}
201: 
202: 	case LogicalTypeId::DATE: {
203: 		res = r.Protect(NEW_NUMERIC(1));
204: 		double *dest_ptr = ((double *)NUMERIC_POINTER(res));
205: 		dest_ptr[0] = (double)int32_t(val.value_.date);
206: 		// some dresssup for R
207: 		RProtector r_date;
208: 		SET_CLASS(res, r_date.Protect(Rf_mkString("Date")));
209: 		return res;
210: 	}
211: 
212: 	default:
213: 		throw NotImplementedException("Can't convert %s of type %s", val.ToString(), val.type().ToString());
214: 	}
215: }
216: 
217: SEXP RApi::REvalThrows(SEXP call, SEXP env) {
218: 	RProtector r;
219: 	int err;
220: 	auto res = r.Protect(R_tryEval(call, env, &err));
221: 	if (err) {
222: 		throw InternalException("Failed to eval R expression %s", R_curErrorBuf());
223: 	}
224: 	return res;
225: }
226: 
227: SEXP RApi::REvalRerror(SEXP call, SEXP env) {
228: 	try {
229: 		return REvalThrows(call, env);
230: 	} catch (std::exception &e) {
231: 		Rf_error(e.what());
232: 	}
233: }
[end of tools/rpkg/src/utils.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: